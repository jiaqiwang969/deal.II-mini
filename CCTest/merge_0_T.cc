CCTest_file/step-1.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 1999 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 */ 


// @sect3{Include files}  

// 库中最基本的类是Triangulation类，它在这里声明。

#include <deal.II/grid/tria.h> 

// 这里有一些生成标准网格的函数。

#include <deal.II/grid/grid_generator.h> 

// 输出各种图形格式的网格。

#include <deal.II/grid/grid_out.h> 

// 这对于C++输出来说是需要的。

#include <iostream> 
#include <fstream> 

// 这是对 `std::sqrt` 和 `std::fabs` 函数声明的说明。

#include <cmath> 

//导入deal.II的最后一步是这样的。所有deal.II的函数和类都在一个命名空间 <code>dealii</code> 中，以确保它们不会与你可能想和deal.II一起使用的其他库的符号发生冲突。我们可以在使用这些函数和类时，在每个名字前加上 <code>dealii::</code> 的前缀，但这很快就会变得繁琐和令人厌烦。相反，我们只是简单地导入整个deal.II的名字空间，以供一般使用。

using namespace dealii; 
// @sect3{Creating the first mesh}  

// 在下面的第一个函数中，我们简单地使用单位方格作为域，并从中产生一个全局细化网格。

void first_grid() 
{ 

// 首先要做的是为二维域的三角化定义一个对象。

  Triangulation<2> triangulation; 

// 在这里和下面的许多情况下，类名后面的字符串"<2>"表示这是一个在两个空间维度上工作的对象。同样，也有一些三角形类的版本是在一个（"<1>"）和三个（"<3>"）空间维度上工作的。这种工作方式是通过一些模板魔法实现的，我们将在后面的示例程序中详细研究；在那里，我们也将看到如何以一种基本独立于维度的方式编写程序。

// 接下来，我们要用一个正方形领域的单个单元来填充三角结构。三角形被细化了四次，总共得到 $4^4=256$ 个单元。

  GridGenerator::hyper_cube(triangulation); 
  triangulation.refine_global(4); 

// 现在我们要将网格的图形表示写到输出文件中。deal.II的GridOut类可以用多种不同的输出格式来实现；在这里，我们选择可扩展矢量图（SVG）格式，你可以用你选择的网络浏览器来进行可视化。

  std::ofstream out("grid-1.svg"); 
  GridOut       grid_out; 
  grid_out.write_svg(triangulation, out); 
  std::cout << "Grid written to grid-1.svg" << std::endl; 
} 

//  @sect3{Creating the second mesh}  

// 下面第二个函数中的网格略微复杂一些，因为我们使用了一个环形域，并对结果进行了一次全局细化。

void second_grid() 
{ 

// 我们再次开始定义一个二维域的三角化对象。

  Triangulation<2> triangulation; 

// 然后我们用一个环形域来填充它。环的中心应是点(1,0)，内半径和外半径应是0.5和1。圆周单元的数量可以由这个函数自动调整，但我们选择在最后一个参数中明确设置为10。

  const Point<2> center(1, 0); 
  const double   inner_radius = 0.5, outer_radius = 1.0; 
  GridGenerator::hyper_shell( 
    triangulation, center, inner_radius, outer_radius, 10); 

// 默认情况下，三角测量假定所有边界都是直线，所有单元都是双线性四边形或三线性六边形，并且它们是由粗略网格（我们刚刚创建的）的单元定义的。除非我们做一些特别的事情，否则当需要引入新的点时，域被假定为由粗网格的直线划定，而新的点将简单地位于周围的中间。然而，在这里，我们知道领域是弯曲的，我们想让三角法根据底层的几何形状来放置新的点。幸运的是，一些优秀的灵魂实现了一个描述球状域的对象，而环是球状域的一个部分；它只需要环的中心，并自动计算出如何指示三角计算在哪里放置新的点。这在deal.II中的工作方式是，你用一个通常被称为 "流形指标 "的数字来标记你想要弯曲的三角形部分，然后告诉三角形在所有有这个流形指标的地方使用一个特定的 "流形对象"。具体如何操作在此并不重要（你可以在 step-53 和 @ref manifold 中阅读）。GridGenerator中的函数在大多数情况下为我们处理这个问题：它们将正确的流形附加到一个域上，这样当三角形被细化时，新的单元就会被放置在正确的位置上。在目前的情况下， GridGenerator::hyper_shell 为所有的单元格附加了一个球形流形：这将导致单元格在球面坐标的计算下被细化（因此新的单元格的边缘要么是径向的，要么是位于原点周围的同心圆）。

// 默认情况下（即对于手工创建的三角图或未调用GridGenerator函数（如 GridGenerator::hyper_shell 或 GridGenerator::hyper_ball), ），三角图的所有单元格和面都将其manifold_id设置为 numbers::flat_manifold_id, ，如果您想要一个产生直线边缘的流形，这是默认的，但您可以为个别单元格和面改变这个数字。在这种情况下，因此与数字0相关的曲面流形将不适用于那些流形指标为非零的部分，但其他流形描述对象可以与这些非零指标相关联。如果没有流形描述与特定的流形指标相关联，则暗示产生直角边缘的流形。(流形指标是一个略微复杂的话题；如果你对这里到底发生了什么感到困惑，你可能想看看 @ref GlossManifoldIndicator "关于这个话题的词汇表条目")。既然 GridGenerator::hyper_shell 选择的默认值是合理的，我们就不去管它。

// 为了演示如何在所有单元格上写一个循环，我们将分五个步骤向域的内圈细化网格。

  for (unsigned int step = 0; step < 5; ++step) 
    { 

// 接下来，我们需要对三角形的活动单元进行循环。你可以把三角形看作一个单元格的集合。如果它是一个数组，你只需要得到一个指针，用操作符`++`从一个元素递增到下一个元素。三角形的单元不是作为一个简单的数组来存储的，但是<i>iterator</i>的概念将指针的工作方式概括为任意的对象集合（更多信息见<a href= "http:en.wikipedia.org/wiki/Iterator#C.2B.2B">wikipedia</a>）。通常情况下，C++中的任何容器类型都会返回一个迭代器，指向集合的开始，方法称为`begin'，而迭代器则指向集合结束后的1，方法称为`end'。我们可以用操作符`++it`来增加一个迭代器`it`，用`*it`来解除引用以获得底层数据，并通过比较`it != collection.end()`来检查我们是否完成。

// 第二个重要的部分是我们只需要活动单元。活动单元是那些没有被进一步细化的单元，也是唯一可以被标记为进一步细化的单元。deal.II提供了迭代器类别，允许我们在<i>all</i>单元（包括活动单元的父单元）或只在活动单元上迭代。因为我们要的是后者，所以我们需要调用方法 Triangulation::active_cell_iterators().  。

//把所有这些放在一起，我们可以用
// @code{.cpp}
//      for (auto it = triangulation.active_cell_iterators().begin();
//           it != triangulation.active_cell_iterators().end();
//           ++it)
//        {
//          auto cell = *it;
//  //Then a miracle occurs...
//        }
//  @endcode
//  在一个三角形的所有活动单元上循环。 在这个循环的初始化器中，我们使用了`auto`关键字作为迭代器`it`的类型。`auto`关键字意味着被声明的对象的类型将从上下文中推断出来。当实际的类型名称很长，甚至可能是多余的时候，这个关键字很有用。如果你不确定类型是什么，想查一下结果支持什么操作，你可以去看方法的文档  Triangulation::active_cell_iterators().  在这个例子中，`it`的类型是  `Triangulation::active_cell_iterator`.  

// 虽然`auto`关键字可以让我们不用输入长长的数据类型名称，但我们仍然要输入大量冗余的关于开始和结束迭代器以及如何递增的声明。与其这样，我们不如使用<a href="http:en.cppreference.com/w/cpp/language/range-for">range-based for loops</a>，它将上面显示的所有语法包成一个更短的形式。

      for (auto &cell : triangulation.active_cell_iterators()) 
        { 
// @note  关于deal.II中使用的迭代器类的更多信息，见 @ref Iterators ，关于基于范围的for循环和`auto`关键字的更多信息，见 @ref CPP11 。

// 接下来，我们在单元格的所有顶点上循环。为此，我们查询一个顶点索引的迭代器（在2D中，这是一个包含元素`{0,1,2,3}`的数组，但是由于`cell->vertex_indices()`知道单元格所处的维度，因此返回的数组在所有维度上都是正确的，这使得无论我们在2D还是3D中运行这段代码都是正确的，也就是说，它实现了 "维度无关的编程" - 我们将在  step-4  中讨论一个重要部分）。

          for (const auto v : cell->vertex_indices()) 
            { 

// 如果这个单元格位于内边界，那么它至少有一个顶点必须位于内环上，因此与中心的径向距离正好是0.5，达到浮点精度。所以我们计算这个距离，如果我们发现一个顶点具有这个属性，我们就标记这个单元，以便以后进行细化。然后我们也可以打破所有顶点的循环，转到下一个单元。        因为离中心的距离是以浮点数计算的，所以我们必须期望我们所计算的东西只能精确到[round-off](https:en.wikipedia.org/wiki/Round-off_error)以内。因此，我们永远不能指望通过平等的方式来比较距离和内半径。诸如 "if (distance_from_center == inner_radius) "这样的语句将会失败，除非我们运气特别好。相反，我们需要以一定的容忍度进行比较，通常的方法是写成`if  (std::abs(distance_from_center  。

// - inner_radius) <= tolerance)`，其中`tolerance'是比四舍五入大的某个小数字。问题是如何选择它。我们可以直接选择，比如说，`1e-10'，但这只适合于我们比较的对象是大小为1的情况。如果我们创建了一个单元大小为`1e+10'的网格，那么`1e-10'将远远低于四舍五入，就像以前一样，只有在我们特别幸运的情况下，比较才会成功。相反，使公差*相对于被比较对象的典型 "比例 "几乎总是有用的。在这里，"尺度 "是指内半径，或者是细胞的直径。我们选择前者，并将公差设置为 $10^{-6}$ 倍环形物的内半径。

              const double distance_from_center = 
                center.distance(cell->vertex(v)); 

              if (std::fabs(distance_from_center - inner_radius) <= 
                  1e-6 * inner_radius) 
                { 
                  cell->set_refine_flag(); 
                  break; 
                } 
            } 
        } 

// 现在我们已经标记了所有我们想要细化的单元格，我们让三角化实际做这个细化。这样做的函数的名字很长，因为我们也可以标记单元格进行粗化，该函数一次完成粗化和细化。

      triangulation.execute_coarsening_and_refinement(); 
    } 

// 最后，在这五次细化迭代之后，我们要再次将得到的网格写入文件，同样是SVG格式。这和上面的工作一样。

  std::ofstream out("grid-2.svg"); 
  GridOut       grid_out; 
  grid_out.write_svg(triangulation, out); 

  std::cout << "Grid written to grid-2.svg" << std::endl; 
} 

//  @sect3{The main function}  

// 最后是主函数。这里没有什么可做的，只是调用两个子函数，产生两个网格。

int main() 
{ 
  first_grid(); 
  second_grid(); 
} 



CCTest_file/step-10.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2001 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Wolfgang Bangerth, Ralf Hartmann, University of Heidelberg, 2001 
 */ 



// 以下第一个include文件现在可能已经众所周知，不需要进一步解释。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/convergence_table.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/fe/fe_values.h> 

// 这个包含文件是新的。即使我们在本教程中不求解PDE，我们也要使用FE_Nothing类提供的自由度为零的假有限元。

#include <deal.II/fe/fe_nothing.h> 

// 下面的头文件也是新的：在其中，我们声明了MappingQ类，我们将使用该类来处理任意阶的多项式映射。

#include <deal.II/fe/mapping_q.h> 

// 这又是一个C++的文件。

#include <iostream> 
#include <fstream> 
#include <cmath> 

// 最后一步和以前的程序一样。

namespace Step10 
{ 
  using namespace dealii; 

// 现在，由于我们要计算 $\pi$ 的值，我们必须与一些东西进行比较。这些是 $\pi$ 的前几个数字，我们事先定义好，以便以后使用。由于我们想计算两个数字的差值，而这两个数字是相当精确的，计算出的 $\pi$ 的近似值的精度在一个双数变量可以容纳的数字范围内，所以我们宁可将参考值声明为 <code>long double</code> ，并给它增加一些数字。

  const long double pi = 3.141592653589793238462643L; 

// 然后，第一个任务将是生成一些输出。由于这个程序非常小，我们在其中没有采用面向对象的技术，也没有声明类（当然，我们使用了库的面向对象的功能）。相反，我们只是将功能打包成独立的函数。我们使这些函数成为空间维数的模板，以符合使用deal.II时的通常做法，尽管我们只对两个空间维数使用这些函数，当试图对任何其他空间维数使用时，会出现异常。

// 这些函数中的第一个只是生成一个圆的三角形（hyperball），并输出 $Q_p$ 的不同值的单元的映射。然后，我们细化一次网格，再做一次。

  template <int dim> 
  void gnuplot_output() 
  { 
    std::cout << "Output of grids into gnuplot files:" << std::endl 
              << "===================================" << std::endl; 
//因此，
//首先生成一个圆的粗略三角剖分，并将一个合适的边界描述与之关联。默认情况下， GridGenerator::hyper_ball 将SphericalManifold附加到边界上（内部使用FlatManifold），所以我们简单地调用该函数并继续前进。

    Triangulation<dim> triangulation; 
    GridGenerator::hyper_ball(triangulation); 

// 然后在当前网格上交替生成 $Q_1$ 、 $Q_2$ 和 $Q_3$ 映射的输出，以及（在循环体的末端）对网格进行一次全局细化。

    for (unsigned int refinement = 0; refinement < 2; ++refinement) 
      { 
        std::cout << "Refinement level: " << refinement << std::endl; 

        std::string filename_base = "ball_" + std::to_string(refinement); 

        for (unsigned int degree = 1; degree < 4; ++degree) 
          { 
            std::cout << "Degree = " << degree << std::endl; 

// 为此，首先建立一个描述映射的对象。这是用MappingQ类来完成的，该类在构造函数中采用了它应使用的多项式程度作为参数。

            const MappingQ<dim> mapping(degree); 

// 顺便提一下，对于一个片状线性映射，你可以给MappingQ的构造函数一个 <code>1</code> 的值，但也有一个MappingQ1类可以达到同样的效果。历史上，它以比MappingQ更简单的方式做了很多事情，但今天只是后者的一个包装。然而，如果你没有明确指定另一个映射，它仍然是库中许多地方隐含使用的类。

// 为了真正用这个映射写出现在的网格，我们设置了一个对象，我们将用它来输出。我们将生成Gnuplot输出，它由一组描述映射的三角图的线条组成。默认情况下，三角剖分的每个面只画一条线，但由于我们想明确地看到映射的效果，所以我们想更详细地了解这些面。这可以通过传递给输出对象一个包含一些标志的结构来实现。在目前的情况下，由于Gnuplot只能画直线，我们在面孔上输出了一些额外的点，这样每个面孔就由30条小线来画，而不是只有一条。这足以让我们看到一条弯曲的线，而不是一组直线的印象。

            GridOut               grid_out; 
            GridOutFlags::Gnuplot gnuplot_flags(false, 60); 
            grid_out.set_flags(gnuplot_flags); 

// 最后，生成一个文件名和一个用于输出的文件。

            std::string filename = 
              filename_base + "_mapping_q_" + std::to_string(degree) + ".dat"; 
            std::ofstream gnuplot_file(filename); 

// 然后把三角图写到这个文件里。该函数的最后一个参数是一个指向映射对象的指针。这个参数有一个默认值，如果没有给出值，就会取一个简单的MappingQ1对象，我们在上面简单介绍过。这样就会在输出中产生一个真实边界的片状线性近似。

            grid_out.write_gnuplot(triangulation, gnuplot_file, &mapping); 
          } 
        std::cout << std::endl; 

// 在循环结束时，对网格进行全局细化。

        triangulation.refine_global(); 
      } 
  } 

// 现在我们进行代码的主要部分，即 $\pi$ 的近似。圆的面积当然是由 $\pi r^2$ 给出的，所以有一个半径为1的圆，面积代表的只是被搜索的数字。面积的数值计算是通过在整个计算域中积分值为1的常数函数来进行的，即通过计算面积 $\int_K 1 dx=\int_{\hat K} 1
// \ \textrm{det}\ J(\hat x) d\hat x \approx \sum_i \textrm{det}
// \ J(\hat x_i)w(\hat x_i)$ ，其中总和延伸到三角形中所有活动单元上的所有正交点， $w(x_i)$ 是正交点的重量 $x_i$ 。每个单元上的积分都是通过数字正交来逼近的，因此我们唯一需要的额外成分是建立一个FEValues对象，提供每个单元的相应`JxW`值。注意`JxW`是指<i>Jacobian determinant
// times weight</i>的缩写；因为在数字正交中，两个因子总是出现在相同的地方，所以我们只提供合并的数量，而不是两个单独的数量）。我们注意到，在这里我们不会在其最初的目的中使用FEValues对象，即用于计算特定正交点上的特定有限元的基函数值。相反，我们只用它来获得正交点的 "JxW"，而不考虑我们将给FEValues对象的构造者的（假）有限元。给予FEValues对象的实际有限元根本不使用，所以我们可以给任何。

  template <int dim> 
  void compute_pi_by_area() 
  { 
    std::cout << "Computation of Pi by the area:" << std::endl 
              << "==============================" << std::endl; 

// 对于所有单元的数字正交，我们采用足够高的正交规则。我们选择8阶的QGauss（4点），以确保数字正交引起的误差比由于边界近似的阶数，即所采用的映射的阶数（最大6）要高。请注意，积分，雅各布行列式，不是一个多项式函数（相反，它是一个有理函数），所以我们不使用高斯正交来获得积分的精确值，就像在有限元计算中经常做的那样，但也可以使用任何类似阶数的正交公式来代替。

    const QGauss<dim> quadrature(4); 

// 现在开始在多项式映射度=1...4的基础上进行循环。

    for (unsigned int degree = 1; degree < 5; ++degree) 
      { 
        std::cout << "Degree = " << degree << std::endl; 

// 首先生成三角形、边界和映射对象，正如已经看到的那样。

        Triangulation<dim> triangulation; 
        GridGenerator::hyper_ball(triangulation); 

        const MappingQ<dim> mapping(degree); 

// 我们现在创建一个有限元。与其他的例子程序不同，我们实际上不需要用形状函数做任何计算；我们只需要FEValues对象的`JxW`值。因此，我们使用特殊的有限元类FE_Nothing，它的每个单元的自由度正好为零（顾名思义，每个单元的局部基础为空集）。FE_Nothing的一个比较典型的用法见  step-46  。

        const FE_Nothing<dim> fe; 

// 同样地，我们需要创建一个DoFHandler对象。我们实际上并没有使用它，但是它将为我们提供`active_cell_iterators'，这是重新初始化三角形的每个单元上的FEValues对象所需要的。

        DoFHandler<dim> dof_handler(triangulation); 

// 现在我们设置FEValues对象，向构造函数提供Mapping、假有限元和正交对象，以及要求只在正交点提供`JxW`值的更新标志。这告诉FEValues对象在调用 <code>reinit</code> 函数时不需要计算其他数量，从而节省计算时间。

// 与之前的例子程序相比，FEValues对象的构造最重要的区别是，我们传递了一个映射对象作为第一个参数，它将被用于计算从单元到实数单元的映射。在以前的例子中，这个参数被省略了，结果是隐含地使用了MappingQ1类型的对象。

        FEValues<dim> fe_values(mapping, fe, quadrature, update_JxW_values); 

// 我们使用一个ConvergenceTable类的对象来存储所有重要的数据，如 $\pi$ 的近似值和与 $\pi$ 的真实值相比的误差。我们还将使用ConvergenceTable类提供的函数来计算 $\pi$ 的近似值的收敛率。

        ConvergenceTable table; 

// 现在我们在三角形的几个细化步骤上循环。

        for (unsigned int refinement = 0; refinement < 6; 
             ++refinement, triangulation.refine_global(1)) 
          { 

// 在这个循环中，我们首先将当前三角形的活动单元的数量添加到表格中。这个函数会自动创建一个上标为 "cells "的表格列，以防这个列之前没有被创建。

            table.add_value("cells", triangulation.n_active_cells()); 

// 然后我们为虚拟有限元分配自由度。严格来说，在我们的特殊情况下，我们不需要这个函数的调用，但我们调用它是为了让DoFHandler高兴 -- 否则它将在下面的 FEValues::reinit 函数中抛出一个断言。

            dof_handler.distribute_dofs(fe); 

// 我们将变量面积定义为 "长双"，就像我们之前为 "pi "变量所做的那样。

            long double area = 0; 

// 现在我们循环所有的单元格，重新初始化每个单元格的FEValues对象，并将该单元格的所有`JxW`值加到`area`上......

            for (const auto &cell : dof_handler.active_cell_iterators()) 
              { 
                fe_values.reinit(cell); 
                for (unsigned int i = 0; i < fe_values.n_quadrature_points; ++i) 
                  area += static_cast<long double>(fe_values.JxW(i)); 
              } 

// ...并将得到的区域值和错误存储在表中。我们需要静态转换为双数，因为没有实现add_value(string, long double)函数。请注意，这也涉及到第二个调用，因为 <code>std</code> 命名空间中的 <code>fabs</code> 函数在其参数类型上是重载的，所以存在一个获取并返回 <code>long double</code> 的版本，而全局命名空间中只有一个这样的函数被声明（获取并返回一个双数）。

            table.add_value("eval.pi", static_cast<double>(area)); 
            table.add_value("error", static_cast<double>(std::fabs(area - pi))); 
          } 

// 我们想计算`error`列的收敛率。因此我们需要在调用`evaluate_all_convergence_rates`之前，将其他列从收敛率评估中省略。

        table.omit_column_from_convergence_rate_evaluation("cells"); 
        table.omit_column_from_convergence_rate_evaluation("eval.pi"); 
        table.evaluate_all_convergence_rates( 
                                    ConvergenceTable::reduction_rate_log2); 

// 最后我们设置一些量的输出精度和科学模式...

        table.set_precision("eval.pi", 16); 
        table.set_scientific("error", true); 

// ...并将整个表格写到  std::cout.  。
        table.write_text(std::cout); 

        std::cout << std::endl; 
      } 
  } 

// 下面的第二个函数也是计算 $\pi$ 的近似值，但这次是通过域的周长 $2\pi r$ 而不是面积。这个函数只是前一个函数的一个变体。因此，我们主要是给出不同之处的文件。

  template <int dim> 
  void compute_pi_by_perimeter() 
  { 
    std::cout << "Computation of Pi by the perimeter:" << std::endl 
              << "===================================" << std::endl; 

// 我们采取同样的正交顺序，但这次是`dim-1`维正交，因为我们将在（边界）线上而不是在单元上积分。

    const QGauss<dim - 1> quadrature(4); 

// 我们在所有度数上循环，创建三角形、边界、映射、假有限元和DoFHandler对象，如之前所见。

    for (unsigned int degree = 1; degree < 5; ++degree) 
      { 
        std::cout << "Degree = " << degree << std::endl; 
        Triangulation<dim> triangulation; 
        GridGenerator::hyper_ball(triangulation); 

        const MappingQ<dim>   mapping(degree); 
        const FE_Nothing<dim> fe; 

        DoFHandler<dim> dof_handler(triangulation); 

// 然后我们创建一个FEFaceValues对象，而不是像前一个函数中的FEValues对象。同样，我们传递一个映射作为第一个参数。

        FEFaceValues<dim> fe_face_values(mapping, 
                                         fe, 
                                         quadrature, 
                                         update_JxW_values); 
        ConvergenceTable  table; 

        for (unsigned int refinement = 0; refinement < 6; 
             ++refinement, triangulation.refine_global(1)) 
          { 
            table.add_value("cells", triangulation.n_active_cells()); 

            dof_handler.distribute_dofs(fe); 

// 现在我们在所有单元和每个单元的所有面上运行。只有边界面上的`JxW`值的贡献被添加到长双变量`周长`中。

            long double perimeter = 0; 
            for (const auto &cell : dof_handler.active_cell_iterators()) 
              for (const auto &face : cell->face_iterators()) 
                if (face->at_boundary()) 
                  { 

// 我们用单元格迭代器和面的编号重新启动FEFaceValues对象。

                    fe_face_values.reinit(cell, face); 
                    for (unsigned int i = 0; 
                         i < fe_face_values.n_quadrature_points; 
                         ++i) 
                      perimeter += 
                        static_cast<long double>(fe_face_values.JxW(i)); 
                  } 

// 然后将评估后的数值存储在表中...

            table.add_value("eval.pi", static_cast<double>(perimeter / 2.0L)); 
            table.add_value( 
              "error", static_cast<double>(std::fabs(perimeter / 2.0L - pi))); 
          } 

// ......然后像前一个函数那样结束这个函数。

        table.omit_column_from_convergence_rate_evaluation("cells"); 
        table.omit_column_from_convergence_rate_evaluation("eval.pi"); 
        table.evaluate_all_convergence_rates( 
          ConvergenceTable::reduction_rate_log2); 

        table.set_precision("eval.pi", 16); 
        table.set_scientific("error", true); 

        table.write_text(std::cout); 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step10 

// 下面的主函数只是按照上述函数的出现顺序来调用它们。除此以外，它看起来就像以前的教程程序的主函数一样。

int main() 
{ 
  try 
    { 
      std::cout.precision(16); 

      const unsigned int dim = 2; 

      Step10::gnuplot_output<dim>(); 

      Step10::compute_pi_by_area<dim>(); 
      Step10::compute_pi_by_perimeter<dim>(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-11.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2001 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 2001 
 */ 



// 像往常一样，程序以一个相当长的包含文件列表开始，你现在可能已经习惯了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/table_handler.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

// 只有这一条是新的：它声明了一个动态稀疏模式（DynamicSparsityPattern）类，我们将在下面进一步使用和解释。

#include <deal.II/lac/dynamic_sparsity_pattern.h> 

// 我们将使用C++标准库中的 std::find 算法，所以我们必须包括以下文件来声明它。

#include <algorithm> 
#include <iostream> 
#include <iomanip> 
#include <cmath> 

// 最后一步和以前所有的程序一样。

namespace Step11 
{ 
  using namespace dealii; 

// 然后我们声明一个表示拉普拉斯问题解决方案的类。由于这个例子程序是基于 step-5 ，这个类看起来相当相同，唯一的结构区别是函数 <code>assemble_system</code> now calls <code>solve</code> 本身，因此被称为 <code>assemble_and_solve</code> ，而且输出函数被删除，因为解函数非常无聊，不值得查看。

// 其他唯一值得注意的变化是，构造函数取一个值，代表以后要使用的映射的多项式程度，而且它还有一个成员变量，正好代表这个映射。一般来说，这个变量在实际应用中会出现在声明或使用有限元的相同地方。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(const unsigned int mapping_degree); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_and_solve(); 
    void solve(); 
    void write_high_order_mesh(const unsigned cycle); 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 
    MappingQ<dim>      mapping; 

    SparsityPattern           sparsity_pattern; 
    SparseMatrix<double>      system_matrix; 
    AffineConstraints<double> mean_value_constraints; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    TableHandler output_table; 
  }; 

// 构建这样一个对象，通过初始化变量。这里，我们使用线性有限元（ <code>fe</code> 变量的参数表示多项式的度数），以及给定阶数的映射。将我们要做的事情打印到屏幕上。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem(const unsigned int mapping_degree) 
    : fe(1) 
    , dof_handler(triangulation) 
    , mapping(mapping_degree) 
  { 
    std::cout << "Using mapping with degree " << mapping_degree << ":" 
              << std::endl 
              << "============================" << std::endl; 
  } 

// 第一个任务是为这个问题设置变量。这包括生成一个有效的 <code>DoFHandler</code> 对象，以及矩阵的稀疏模式，和代表边界上自由度平均值为零的约束条件的对象。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 

// 第一个任务很简单：生成一个自由度的枚举，并将解和右手向量初始化为正确的大小。

    dof_handler.distribute_dofs(fe); 
    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

// 下一个任务是构建代表约束的对象，即边界上自由度的平均值应该是零。为此，我们首先需要一个实际在边界上的节点的列表。 <code>DoFTools</code> 命名空间有一个函数可以返回一个IndexSet对象，该对象包含所有在边界上的自由度的指数。

// 一旦我们有了这个索引集，我们想知道哪个是对应于边界上的自由度的第一个索引。我们需要这个，因为我们想通过边界上所有其他自由度的值来约束边界上的一个节点。使用IndexSet类很容易得到这个 "第一个 "自由度的索引。

    const IndexSet boundary_dofs = DoFTools::extract_boundary_dofs(dof_handler); 

    const types::global_dof_index first_boundary_dof = 
      boundary_dofs.nth_index_in_set(0); 

// 然后生成一个只有这一个约束的约束对象。首先清除所有以前的内容（这些内容可能来自以前在更粗的网格上的计算），然后添加这一行，将 <code>first_boundary_dof</code> 约束到其他边界DoF的总和，每一个权重为-1。最后，关闭约束对象，也就是说，对它做一些内部记录，以便更快地处理后面的内容。

    mean_value_constraints.clear(); 
    mean_value_constraints.add_line(first_boundary_dof); 
    for (types::global_dof_index i : boundary_dofs) 
      if (i != first_boundary_dof) 
        mean_value_constraints.add_entry(first_boundary_dof, i, -1); 
    mean_value_constraints.close(); 

// 下一个任务是生成一个稀疏模式。这的确是一个棘手的任务。通常情况下，我们只需调用 <code>DoFTools::make_sparsity_pattern</code> 并使用悬挂节点约束来浓缩结果。我们在这里没有悬挂节点约束（因为我们在这个例子中只进行全局细化），但是我们在边界上有这个全局约束。在这种情况下，这带来了一个严重的问题： <code>SparsityPattern</code> 类希望我们事先说明每行的最大条目数，可以是所有行的，也可以是每行单独的。在库中有一些函数可以告诉你这个数字，如果你只有悬空的节点约束的话（即 DoFHandler::max_couplings_between_dofs), ，但这对现在的情况来说是怎样的？困难的出现是因为消除约束的自由度需要在矩阵中增加一些条目，而这些条目的位置并不那么容易确定。因此，如果我们在这里给出每行的最大条目数，我们就会有一个问题。

// 由于这可能非常困难，以至于无法给出合理的答案，只能分配合理的内存量，所以有一个DynamicSparsityPattern类，它可以帮助我们解决这个问题。它不要求我们事先知道行可以有多少个条目，而是允许任何长度。因此，在你对行的长度没有很好的估计的情况下，它明显更灵活，但是代价是建立这样一个模式也比建立一个你事先有信息的模式要昂贵得多。尽管如此，由于我们在这里没有其他选择，我们将建立这样一个对象，用矩阵的尺寸初始化它，并调用另一个函数 <code>DoFTools::make_sparsity_pattern</code> 来获得由于微分算子引起的稀疏模式，然后用约束对象浓缩它，在稀疏模式中增加那些消除约束所需的位置。

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    mean_value_constraints.condense(dsp); 

// 最后，一旦我们有了完整的模式，我们就可以从中初始化一个 <code>SparsityPattern</code> 类型的对象，并反过来用它初始化矩阵。请注意，这实际上是必要的，因为与 <code>SparsityPattern</code> 类相比，DynamicSparsityPattern的效率非常低，因为它必须使用更灵活的数据结构，所以我们不可能将稀疏矩阵类建立在它的基础上，而是需要一个 <code>SparsityPattern</code> 类型的对象，我们通过复制中间对象产生这个对象。

// 作为进一步的附带说明，你会注意到我们在这里没有明确的  <code>compress</code>  稀疏模式。当然，这是由于 <code>copy_from</code> 函数从一开始就生成了一个压缩对象，你不能再向其添加新的条目。因此， <code>compress</code> 的调用是隐含在 <code>copy_from</code> 的调用中的。

    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 
  } 

// 下一个函数接着组装线性方程组，对其进行求解，并对解进行评估。这样就有了三个动作，我们将把它们放到八个真实的语句中（不包括变量的声明，以及临时向量的处理）。因此，这个函数是为非常懒惰的人准备的。尽管如此，所调用的函数是相当强大的，通过它们，这个函数使用了整个库的大量内容。但让我们来看看每一个步骤。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_and_solve() 
  { 

// 首先，我们要把矩阵和右手边的内容组合起来。在之前的所有例子中，我们已经研究了如何手动完成这一工作的各种方法。然而，由于拉普拉斯矩阵和简单的右手边在应用中出现的频率很高，库中提供的函数实际上是为你做这件事的，也就是说，它们在所有单元格上进行循环，设置局部的矩阵和向量，并将它们放在一起，得到最终结果。

// 以下是两个最常用的函数：创建拉普拉斯矩阵和创建来自体或边界力的右侧向量。它们需要映射对象、代表自由度和使用中的有限元的 <code>DoFHandler</code> 对象、要使用的正交公式以及输出对象。创建右手向量的函数还必须接受一个描述（连续）右手向量函数的函数对象。

// 让我们来看看矩阵和体力的集成方式。

    const unsigned int gauss_degree = 
      std::max(static_cast<unsigned int>( 
                 std::ceil(1. * (mapping.get_degree() + 1) / 2)), 
               2U); 
    MatrixTools::create_laplace_matrix(mapping, 
                                       dof_handler, 
                                       QGauss<dim>(gauss_degree), 
                                       system_matrix); 
    VectorTools::create_right_hand_side(mapping, 
                                        dof_handler, 
                                        QGauss<dim>(gauss_degree), 
                                        Functions::ConstantFunction<dim>(-2), 
                                        system_rhs); 

// 这很简单，对吗？

// 不过，有两点需要注意。首先，这些函数在很多情况下都会用到。也许你想为一个矢量值有限元创建一个拉普拉斯或质量矩阵；或者你想使用默认的Q1映射；或者你想用拉普拉斯算子的一个系数来装配矩阵。由于这个原因，在 <code>MatrixCreator</code> 和 <code>MatrixTools</code> 命名空间中有相当多的这些函数的变种。每当你需要这些函数的一个与上面调用的略有不同的版本时，当然值得看一下文档，并检查一些东西是否适合你的需要。

// 第二点是关于我们使用的正交公式：我们想对双线性形状函数进行积分，所以我们知道我们至少要使用二阶高斯正交公式。另一方面，我们希望正交规则至少有边界近似的阶数。因为有 $r$ 点的高斯规则的阶数是 $2r -1$  ，而使用 $p$ 度的多项式的边界近似的阶数是 $p+1$ ，我们知道 $2r \geq p$  。由于r必须是一个整数，并且（如上所述）必须至少是 $2$ ，这就弥补了上述公式计算 <code>gauss_degree</code> 。

// 由于对右侧向量的体力贡献的生成是如此简单，我们对边界力也要重新做一遍：分配一个合适大小的向量并调用合适的函数。边界函数有常量值，所以我们可以从库中快速生成一个对象，我们使用与上面相同的正交公式，但这次的维度较低，因为我们现在是在面上而不是在单元上积分。

    Vector<double> tmp(system_rhs.size()); 
    VectorTools::create_boundary_right_hand_side( 
      mapping, 
      dof_handler, 
      QGauss<dim - 1>(gauss_degree), 
      Functions::ConstantFunction<dim>(1), 
      tmp); 

// 然后将边界的贡献与域内部的贡献相加。

    system_rhs += tmp; 

// 在组装右手边时，我们必须使用两个不同的矢量对象，然后将它们加在一起。我们不得不这样做的原因是， <code>VectorTools::create_right_hand_side</code> 和 <code>VectorTools::create_boundary_right_hand_side</code> 函数首先清除输出向量，而不是将它们的结果与之前的内容相加。这可以合理地称为库在起步阶段的设计缺陷，但不幸的是，事情现在已经是这样了，很难改变这种无声地破坏现有代码的事情，所以我们不得不接受。

// 现在，线性系统已经建立起来了，所以我们可以从矩阵和右手向量中消除我们约束到边界上其他DoF的一个自由度的均值约束，并解决这个系统。之后，再次分配约束，在这种情况下，这意味着将被约束的自由度设置为适当的值

    mean_value_constraints.condense(system_matrix); 
    mean_value_constraints.condense(system_rhs); 

    solve(); 
    mean_value_constraints.distribute(solution); 

// 最后，评估我们得到的解决方案。正如在介绍中所说，我们对解决方案的H1半正态感兴趣。在这里，我们在库中也有一个函数可以做到这一点，尽管是以一种稍微不明显的方式： <code>VectorTools::integrate_difference</code> 函数整合了一个有限元函数和一个连续函数之间的差值的规范。因此，如果我们想要一个有限元场的规范，我们只需将连续函数设为零。请注意，这个函数，就像库中的许多其他函数一样，至少有两个版本，一个是以映射为参数的（我们在这里使用），另一个是我们在以前的例子中使用的隐含的 <code>MappingQ1</code>  。 还要注意的是，我们采用的是高一级的正交公式，以避免出现超融合效应，即在某些点上的解特别接近精确解（我们不知道这里是否会出现这种情况，但有已知的案例，我们只是想确认一下）。

    Vector<float> norm_per_cell(triangulation.n_active_cells()); 
    VectorTools::integrate_difference(mapping, 
                                      dof_handler, 
                                      solution, 
                                      Functions::ZeroFunction<dim>(), 
                                      norm_per_cell, 
                                      QGauss<dim>(gauss_degree + 1), 
                                      VectorTools::H1_seminorm); 

// 然后，刚刚调用的函数将其结果作为一个值的向量返回，每个值表示一个单元格上的法线。为了得到全局法线，我们要做以下工作。

    const double norm = 
      VectorTools::compute_global_error(triangulation, 
                                        norm_per_cell, 
                                        VectorTools::H1_seminorm); 

// 最后一项任务--生成输出。

    output_table.add_value("cells", triangulation.n_active_cells()); 
    output_table.add_value("|u|_1", norm); 
    output_table.add_value("error", 
                           std::fabs(norm - std::sqrt(3.14159265358 / 2))); 
  } 

// 下面这个解线性方程组的函数是从 step-5 中复制过来的，在那里有详细的解释。

  template <int dim> 
  void LaplaceProblem<dim>::solve() 
  { 
    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 
  } 

// 接下来，我们把解决方案以及材料ID写到一个VTU文件中。这与其他许多教程程序中的做法相似。这个教程程序中提出的新内容是，我们要确保写到文件中用于可视化的数据实际上是deal.II内部使用的数据的忠实代表。这是因为大多数可视化数据格式只用顶点坐标表示单元，但没有办法表示deal.II中使用高阶映射时的曲线边界--换句话说，你在可视化工具中看到的东西实际上不是你正在计算的东西。顺带一提，在使用高阶形状函数时也是如此。大多数可视化工具只呈现双线性/三线性的表示。这在 DataOut::build_patches().) 中有详细的讨论。

// 所以我们需要确保高阶表示被写入文件中。我们需要考虑两个特别的话题。首先，我们通过 DataOutBase::VtkFlags 告诉DataOut对象，我们打算将元素的细分解释为高阶拉格朗日多项式，而不是双线性斑块的集合。最近的可视化程序，如ParaView 5.5版或更新版，然后可以呈现高阶解决方案（更多细节见<a
//  href="https:github.com/dealii/dealii/wiki/Notes-on-visualizing-high-order-output">wiki
//  page</a>）。其次，我们需要确保映射被传递给 DataOut::build_patches() 方法。最后，DataOut类默认只打印<i>boundary</i>单元的曲面，所以我们需要确保通过映射将内部单元也打印成曲面。

  template <int dim> 
  void LaplaceProblem<dim>::write_high_order_mesh(const unsigned cycle) 
  { 
    DataOut<dim> data_out; 

    DataOutBase::VtkFlags flags; 
    flags.write_higher_order_cells = true; 
    data_out.set_flags(flags); 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 

    data_out.build_patches(mapping, 
                           mapping.get_degree(), 
                           DataOut<dim>::curved_inner_cells); 

    std::ofstream file("solution-c=" + std::to_string(cycle) + 
                       ".p=" + std::to_string(mapping.get_degree()) + ".vtu"); 

    data_out.write_vtu(file); 
  } 

// 最后是控制要执行的不同步骤的主要函数。它的内容相当简单，生成一个圆的三角形，给它关联一个边界，然后在随后的更细的网格上做几个循环。请注意，我们将网格细化放到了循环头中；这对测试程序来说可能是件好事，但对实际应用来说，你应该考虑到这意味着网格是在循环最后一次执行后被细化的，因为增量子句（三部分循环头的最后一部分）是在比较部分（第二部分）之前执行的，如果网格已经相当细化了，这可能是相当昂贵的。在这种情况下，你应该安排代码，使网格在最后一次循环运行后不再被进一步细化（或者你应该在每次运行的开始就这样做，除了第一次）。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    GridGenerator::hyper_ball(triangulation); 

    for (unsigned int cycle = 0; cycle < 6; ++cycle) 
      { 
        setup_system(); 
        assemble_and_solve(); 
        write_high_order_mesh(cycle); 

        triangulation.refine_global(); 
      } 

// 在所有的数据生成之后，将结果的表格写到屏幕上。

    output_table.set_precision("|u|_1", 6); 
    output_table.set_precision("error", 6); 
    output_table.write_text(std::cout); 
    std::cout << std::endl; 
  } 
} // namespace Step11 

// 最后是主函数。它的结构与前面几个例子中使用的结构相同，所以可能不需要更多解释。

int main() 
{ 
  try 
    { 
      std::cout.precision(5); 

// 这是主循环，用线性到立方的映射做计算。注意，由于我们只需要一次 <code>LaplaceProblem@<2@></code> 类型的对象，我们甚至不给它命名，而是创建一个未命名的这样的对象，并调用它的 <code>run</code> 函数，随后它又立即被销毁。

      for (unsigned int mapping_degree = 1; mapping_degree <= 3; 
           ++mapping_degree) 
        Step11::LaplaceProblem<2>(mapping_degree).run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 

  return 0; 
} 


CCTest_file/step-12.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Guido Kanschat, Texas A&M University, 2009 
 *         Timo Heister, Clemson University, 2019 
 */ 



// 前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/fe/mapping_q1.h> 

// 这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过--正如你在以前的教程程序中所看到的--用户与有限元类的交互根本不多：它们被传递给 <code>DoFHandler</code> 和 <code>FEValues</code> 对象，仅此而已。

#include <deal.II/fe/fe_dgq.h> 

// FEInterfaceValues需要这个头来计算界面上的积分。

#include <deal.II/fe/fe_interface_values.h> 

// 我们将使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散产生的系统矩阵的特殊块状结构。

#include <deal.II/lac/solver_richardson.h> 
#include <deal.II/lac/precondition_block.h> 

// 我们将使用梯度作为细化指标。

#include <deal.II/numerics/derivative_approximation.h> 

// 最后，新的包含文件用于使用MeshWorker框架中的Mesh_loop。

#include <deal.II/meshworker/mesh_loop.h> 

// 像所有的程序一样，我们在完成这一部分时，要包括所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不含前缀。

#include <iostream> 
#include <fstream> 

namespace Step12 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

// 首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    BoundaryValues() = default; 
    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int component = 0) const override; 
  }; 

// 考虑到流动方向，单位方块 $[0,1]^2$ 的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右边界上规定了值0。该函数在流出边界上的值将不会在DG方案中使用。

  template <int dim> 
  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points, 
                                       std::vector<double> &          values, 
                                       const unsigned int component) const 
  {  
    (void)component; 
    AssertIndexRange(component, 1); 
    Assert(values.size() == points.size(), 
           ExcDimensionMismatch(values.size(), points.size())); 

    for (unsigned int i = 0; i < values.size(); ++i) 
      { 
        if (points[i](0) < 0.5)  
          values[i] = 1.; 
        else 
          values[i] = 0.; 
      } 
  } 

// 最后，一个计算并返回风场的函数  $\beta=\beta(\mathbf x)$  。正如在介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置 $z$ 分量（即为零），而这个函数在目前的实现中不能用于1D。

  template <int dim> 
  Tensor<1, dim> beta(const Point<dim> &p) 
  { 
    Assert(dim >= 2, ExcNotImplemented()); 

    Tensor<1, dim> wind_field; 
    wind_field[0] = -p[1]; 
    wind_field[1] = p[0]; 

    if (wind_field.norm() > 1e-10) 
      wind_field /= wind_field.norm(); 

    return wind_field; 
  } 
// @sect3{The ScratchData and CopyData classes}  

// 以下对象是我们在调用 MeshWorker::mesh_loop(). 时使用的抓取和复制对象 新对象是FEInterfaceValues对象，它的工作原理类似于FEValues或FEFacesValues，只是它作用于两个单元格之间的接口，并允许我们以我们的弱形式组装接口条款。

  template <int dim> 
  struct ScratchData 
  { 
    ScratchData(const Mapping<dim> &       mapping, 
                const FiniteElement<dim> & fe, 
                const Quadrature<dim> &    quadrature, 
                const Quadrature<dim - 1> &quadrature_face, 
                const UpdateFlags          update_flags = update_values | 
                                                 update_gradients | 
                                                 update_quadrature_points | 
                                                 update_JxW_values, 
                const UpdateFlags interface_update_flags = 
                  update_values | update_gradients | update_quadrature_points | 
                  update_JxW_values | update_normal_vectors) 
      : fe_values(mapping, fe, quadrature, update_flags) 
      , fe_interface_values(mapping, 
                            fe, 
                            quadrature_face, 
                            interface_update_flags) 
    {} 

    ScratchData(const ScratchData<dim> &scratch_data) 
      : fe_values(scratch_data.fe_values.get_mapping(), 
                  scratch_data.fe_values.get_fe(), 
                  scratch_data.fe_values.get_quadrature(), 
                  scratch_data.fe_values.get_update_flags()) 
      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(), 
                            scratch_data.fe_interface_values.get_fe(), 
                            scratch_data.fe_interface_values.get_quadrature(), 
                            scratch_data.fe_interface_values.get_update_flags()) 
    {} 

    FEValues<dim>          fe_values; 
    FEInterfaceValues<dim> fe_interface_values; 
  }; 

  struct CopyDataFace 
  { 
    FullMatrix<double>                   cell_matrix; 
    std::vector<types::global_dof_index> joint_dof_indices; 
  }; 

  struct CopyData 
  { 
    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_rhs; 
    std::vector<types::global_dof_index> local_dof_indices; 
    std::vector<CopyDataFace>            face_data; 

    template <class Iterator> 
    void reinit(const Iterator &cell, unsigned int dofs_per_cell) 
    { 
      cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 
      cell_rhs.reinit(dofs_per_cell); 

      local_dof_indices.resize(dofs_per_cell); 
      cell->get_dof_indices(local_dof_indices); 
    } 
  }; 
// @sect3{The AdvectionProblem class}  

// 在这个准备工作之后，我们继续进行这个程序的主类，称为AdvectionProblem。

// 这对你来说应该是非常熟悉的。有趣的细节只有在实现集合函数的时候才会出现。

  template <int dim> 
  class AdvectionProblem 
  { 
  public: 
    AdvectionProblem(); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim>   triangulation; 
    const MappingQ1<dim> mapping; 

// 此外，我们要使用DG元素。

    const FE_DGQ<dim> fe; 
    DoFHandler<dim>   dof_handler; 

    const QGauss<dim>     quadrature; 
    const QGauss<dim - 1> quadrature_face; 

// 接下来的四个成员代表要解决的线性系统。  <code>system_matrix</code> and <code>right_hand_side</code> 是由 <code>assemble_system()</code>, the <code>solution</code> 产生的，在 <code>solve()</code>. The <code>sparsity_pattern</code> 中计算，用于确定 <code>system_matrix</code> 中非零元素的位置。

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> right_hand_side; 
  }; 

// 我们从构造函数开始。 <code>fe</code> 的构造器调用中的1是多项式的度数。

  template <int dim> 
  AdvectionProblem<dim>::AdvectionProblem() 
    : mapping() 
    , fe(1) 
    , dof_handler(triangulation) 
    , quadrature(fe.tensor_degree() + 1) 
    , quadrature_face(fe.tensor_degree() + 1) 
  {} 

  template <int dim> 
  void AdvectionProblem<dim>::setup_system() 
  { 

// 在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。

    dof_handler.distribute_dofs(fe); 

// 我们从生成稀疏模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到 <code>sparsity_pattern</code> 并可以被丢弃。

// 为了建立DG离散的稀疏模式，我们可以调用类似于 DoFTools::make_sparsity_pattern, 的函数，该函数被称为 DoFTools::make_flux_sparsity_pattern:  。
    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

// 最后，我们设置了线性系统的所有组成部分的结构。

    system_matrix.reinit(sparsity_pattern); 
    solution.reinit(dof_handler.n_dofs()); 
    right_hand_side.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{The assemble_system function}  

// 这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是在调用 MeshWorker::mesh_loop() 时包含逻辑，我们只需要指定在每个单元格、每个边界面和每个内部面应该发生什么。这三个任务是由下面的函数里面的lambda函数处理的。

  template <int dim> 
  void AdvectionProblem<dim>::assemble_system() 
  { 
    using Iterator = typename DoFHandler<dim>::active_cell_iterator; 
    const BoundaryValues<dim> boundary_function; 

// 这是将对每个单元格执行的函数。

    const auto cell_worker = [&](const Iterator &  cell, 
                                 ScratchData<dim> &scratch_data, 
                                 CopyData &        copy_data) { 
      const unsigned int n_dofs = 
        scratch_data.fe_values.get_fe().n_dofs_per_cell(); 
      copy_data.reinit(cell, n_dofs); 
      scratch_data.fe_values.reinit(cell); 

      const auto &q_points = scratch_data.fe_values.get_quadrature_points(); 

      const FEValues<dim> &      fe_v = scratch_data.fe_values; 
      const std::vector<double> &JxW  = fe_v.get_JxW_values(); 

// 我们解决的是一个同质方程，因此在单元项中没有显示出右手。 剩下的就是整合矩阵条目。

      for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point) 
        { 
          auto beta_q = beta(q_points[point]); 
          for (unsigned int i = 0; i < n_dofs; ++i) 
            for (unsigned int j = 0; j < n_dofs; ++j) 
              { 
                copy_data.cell_matrix(i, j) += 
                  -beta_q                      // -\beta 
                  * fe_v.shape_grad(i, point)  // \nabla \phi_i 
                  * fe_v.shape_value(j, point) // \phi_j 
                  * JxW[point];                // dx 
              } 
        } 
    }; 

// 这是为边界面调用的函数，包括使用FEFaceValues的正常积分。新的逻辑是决定该术语是进入系统矩阵（流出）还是进入右手边（流入）。

    const auto boundary_worker = [&](const Iterator &    cell, 
                                     const unsigned int &face_no, 
                                     ScratchData<dim> &  scratch_data, 
                                     CopyData &          copy_data) { 
      scratch_data.fe_interface_values.reinit(cell, face_no); 
      const FEFaceValuesBase<dim> &fe_face = 
        scratch_data.fe_interface_values.get_fe_face_values(0); 

      const auto &q_points = fe_face.get_quadrature_points(); 

      const unsigned int n_facet_dofs = fe_face.get_fe().n_dofs_per_cell(); 
      const std::vector<double> &        JxW     = fe_face.get_JxW_values(); 
      const std::vector<Tensor<1, dim>> &normals = fe_face.get_normal_vectors(); 

      std::vector<double> g(q_points.size()); 
      boundary_function.value_list(q_points, g); 

      for (unsigned int point = 0; point < q_points.size(); ++point) 
        { 
          const double beta_dot_n = beta(q_points[point]) * normals[point]; 

          if (beta_dot_n > 0) 
            { 
              for (unsigned int i = 0; i < n_facet_dofs; ++i) 
                for (unsigned int j = 0; j < n_facet_dofs; ++j) 
                  copy_data.cell_matrix(i, j) += 
                    fe_face.shape_value(i, point)   // \phi_i 
                    * fe_face.shape_value(j, point) // \phi_j 
                    * beta_dot_n                    // \beta . n 
                    * JxW[point];                   // dx 
            } 
          else 
            for (unsigned int i = 0; i < n_facet_dofs; ++i) 
              copy_data.cell_rhs(i) += -fe_face.shape_value(i, point) // \phi_i 
                                       * g[point]                     // g 
                                       * beta_dot_n  // \beta . n 
                                       * JxW[point]; // dx 
        } 
    }; 

// 这是在内部面调用的函数。参数指定了单元格、面和子面的指数（用于自适应细化）。我们只是将它们传递给FEInterfaceValues的reinit()函数。

    const auto face_worker = [&](const Iterator &    cell, 
                                 const unsigned int &f, 
                                 const unsigned int &sf, 
                                 const Iterator &    ncell, 
                                 const unsigned int &nf, 
                                 const unsigned int &nsf, 
                                 ScratchData<dim> &  scratch_data, 
                                 CopyData &          copy_data) { 
      FEInterfaceValues<dim> &fe_iv = scratch_data.fe_interface_values; 
      fe_iv.reinit(cell, f, sf, ncell, nf, nsf); 
      const auto &q_points = fe_iv.get_quadrature_points(); 

      copy_data.face_data.emplace_back(); 
      CopyDataFace &copy_data_face = copy_data.face_data.back(); 

      const unsigned int n_dofs        = fe_iv.n_current_interface_dofs(); 
      copy_data_face.joint_dof_indices = fe_iv.get_interface_dof_indices(); 

      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs); 

      const std::vector<double> &        JxW     = fe_iv.get_JxW_values(); 
      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors(); 

      for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint) 
        { 
          const double beta_dot_n = beta(q_points[qpoint]) * normals[qpoint]; 
          for (unsigned int i = 0; i < n_dofs; ++i) 
            for (unsigned int j = 0; j < n_dofs; ++j) 
              copy_data_face.cell_matrix(i, j) +=  
                fe_iv.jump(i, qpoint) // [\phi_i] 
                * 
                fe_iv.shape_value((beta_dot_n > 0), j, qpoint) // phi_j^{upwind} 
                * beta_dot_n                                   // (\beta . n) 
                * JxW[qpoint];                                 // dx 
        }  
    }; 

// 下面的lambda函数将处理从单元格和面组件中复制数据到全局矩阵和右侧的问题。

// 虽然我们不需要AffineConstraints对象，因为在DG离散中没有悬空节点约束，但我们在这里使用一个空对象，因为这允许我们使用其`copy_local_to_global`功能。

    const AffineConstraints<double> constraints; 

    const auto copier = [&](const CopyData &c) { 
      constraints.distribute_local_to_global(c.cell_matrix, 
                                             c.cell_rhs, 
                                             c.local_dof_indices, 
                                             system_matrix, 
                                             right_hand_side); 

      for (auto &cdf : c.face_data) 
        { 
          constraints.distribute_local_to_global(cdf.cell_matrix, 
                                                 cdf.joint_dof_indices, 
                                                 system_matrix); 
        } 
    }; 

    ScratchData<dim> scratch_data(mapping, fe, quadrature, quadrature_face); 
    CopyData         copy_data; 

// 在这里，我们最终处理了装配问题。我们传入ScratchData和CopyData对象，以及上面的lambda函数，并指定我们要对内部面进行一次装配。

    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          copy_data, 
                          MeshWorker::assemble_own_cells | 
                            MeshWorker::assemble_boundary_faces | 
                            MeshWorker::assemble_own_interior_faces_once, 
                          boundary_worker, 
                          face_worker); 
  } 
// @sect3{All the rest}  

// 对于这个简单的问题，我们使用了最简单的求解器，称为Richardson迭代，它代表了简单的缺陷修正。这与一个块状SSOR预处理相结合，该预处理使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状的Gauss-Seidel预处理（见PreconditionBlockSOR类，放松=1）会做得更好。

  template <int dim> 
  void AdvectionProblem<dim>::solve() 
  { 
    SolverControl                    solver_control(1000, 1e-12); 
    SolverRichardson<Vector<double>> solver(solver_control); 

// 这里我们创建了预处理程序。

    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner; 

// 然后将矩阵分配给它，并设置正确的块大小。

    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell()); 

// 做完这些准备工作后，我们就可以启动线性求解器了。

    solver.solve(system_matrix, solution, right_hand_side, preconditioner); 

    std::cout << "  Solver converged in " << solver_control.last_step() 
              << " iterations." << std::endl; 
  } 

// 我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由 <code>DerivativeApproximation</code> 类完成的，它计算近似梯度的方式类似于本教程 step-9 中描述的 <code>GradientEstimation</code> 。事实上， <code>DerivativeApproximation</code> 类是在 step-9 的 <code>GradientEstimation</code> 类之后开发的。与  step-9  中的讨论相关，这里我们考虑  $h^{1+d/2}|\nabla_h u_h|$  。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在 $H^2$ 中，而只在 $H^1$ 中（或者，更准确地说：在 $H^1_\beta$ 中，即在方向 $\beta$ 上的导数是可平方整除的函数空间）。

  template <int dim> 
  void AdvectionProblem<dim>::refine_grid() 
  { 

//  <code>DerivativeApproximation</code> 类将梯度计算为浮点精度。这已经足够了，因为它们是近似的，只作为细化指标。

    Vector<float> gradient_indicator(triangulation.n_active_cells()); 

// 现在，近似梯度被计算出来了

    DerivativeApproximation::approximate_gradient(mapping, 
                                                  dof_handler, 
                                                  solution, 
                                                  gradient_indicator); 

//并且它们的单元格按系数 $h^{1+d/2}$ 进行缩放。
    unsigned int cell_no = 0; 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      gradient_indicator(cell_no++) *= 
        std::pow(cell->diameter(), 1 + 1.0 * dim / 2); 

// 最后它们作为细化指标。

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    gradient_indicator, 
                                                    0.3, 
                                                    0.1); 

    triangulation.execute_coarsening_and_refinement(); 
  } 

// 这个程序的输出包括一个自适应细化网格的vtk文件和数值解。最后，我们还用 VectorTools::integrate_difference(). 计算了解的L-无穷大规范。
  template <int dim> 
  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    const std::string filename = "solution-" + std::to_string(cycle) + ".vtk"; 
    std::cout << "  Writing solution to <" << filename << ">" << std::endl; 
    std::ofstream output(filename); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler);  
    data_out.add_data_vector(solution, "u", DataOut<dim>::type_dof_data); 

    data_out.build_patches(mapping); 

    data_out.write_vtk(output); 

    { 
      Vector<float> values(triangulation.n_active_cells()); 
      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        Functions::ZeroFunction<dim>(), 
                                        values, 
                                        quadrature, 
                                        VectorTools::Linfty_norm); 
      const double l_infty = 
        VectorTools::compute_global_error(triangulation, 
                                          values,  
                                          VectorTools::Linfty_norm); 
      std::cout << "  L-infinity norm: " << l_infty << std::endl; 
    } 
  } 

// 下面的 <code>run</code> 函数与前面的例子类似。

  template <int dim> 
  void AdvectionProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 6; ++cycle) 
      {  
        std::cout << "Cycle " << cycle << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation); 
            triangulation.refine_global(3); 
          } 
        else 
          refine_grid(); 

        std::cout << "  Number of active cells:       " 
                  << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        std::cout << "  Number of degrees of freedom: " << dof_handler.n_dofs() 
                  << std::endl; 

        assemble_system(); 
        solve(); 

        output_results(cycle); 
      } 
  } 
} // namespace Step12 

// 下面的 <code>main</code> 函数与前面的例子也类似，不需要注释。

int main() 
{ 
  try 
    { 
      Step12::AdvectionProblem<2> dgmethod; 
      dgmethod.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-12b.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Guido Kanschat, Texas A&M University, 2009 
 */ 



// 前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/fe/mapping_q1.h> 

// 这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过--正如你在以前的教程程序中所看到的--用户与有限元类的交互并不多：它们被传递给 <code>DoFHandler</code> 和 <code>FEValues</code> 对象，就这样了。

#include <deal.II/fe/fe_dgq.h> 

// 我们将使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散化产生的系统矩阵的特殊块状结构。

#include <deal.II/lac/solver_richardson.h> 
#include <deal.II/lac/precondition_block.h> 

// 我们将使用梯度作为细化指标。

#include <deal.II/numerics/derivative_approximation.h> 

// 这里是使用MeshWorker框架的新的包含文件。第一个文件包含了 MeshWorker::DoFInfo, 类，它为局部积分器提供了局部与全局自由度之间的映射。在第二个文件中，我们发现一个类型为 MeshWorker::IntegrationInfo, 的对象，它主要是对一组FEValues对象的封装。文件<tt>meshworker/simple.h</tt>包含了将局部集成数据组装成只包含一个矩阵的全局系统的类。最后，我们将需要在所有的网格单元和面中运行循环的文件。

#include <deal.II/meshworker/dof_info.h> 
#include <deal.II/meshworker/integration_info.h> 
#include <deal.II/meshworker/simple.h> 
#include <deal.II/meshworker/loop.h> 

// 像所有的程序一样，我们在完成这一部分时要包括所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不加前缀。

#include <iostream> 
#include <fstream> 

namespace Step12 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

// 首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    BoundaryValues() = default; 
    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int component = 0) const override; 
  }; 

// 考虑到流动方向，单位方块 $[0,1]^2$ 的流入边界为右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右边界上规定了值0。该函数在流出边界上的值将不会在DG方案中使用。

  template <int dim> 
  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points, 
                                       std::vector<double> &          values, 
                                       const unsigned int component) const 
  { 
    (void)component; 
    AssertIndexRange(component, 1); 
    Assert(values.size() == points.size(), 
           ExcDimensionMismatch(values.size(), points.size())); 

    for (unsigned int i = 0; i < values.size(); ++i) 
      { 
        if (points[i](0) < 0.5) 
          values[i] = 1.; 
        else 
          values[i] = 0.; 
      } 
  } 

// 最后，一个计算并返回风场的函数  $\beta=\beta(\mathbf x)$  。正如在介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置 $z$ 分量（即为零），而这个函数在目前的实现中不能用于1D。

  template <int dim> 
  Tensor<1, dim> beta(const Point<dim> &p) 
  { 
    Assert(dim >= 2, ExcNotImplemented()); 

    Tensor<1, dim> wind_field; 
    wind_field[0] = -p[1]; 
    wind_field[1] = p[0]; 
    wind_field /= wind_field.norm(); 

    return wind_field; 
  } 
// @sect3{The AdvectionProblem class}  

// 在这个准备工作之后，我们继续进行这个程序的主类，叫做AdvectionProblem。它基本上是  step-6  的主类。我们没有AffineConstraints对象，因为在DG离散中没有悬挂节点约束。

// 主要的区别只出现在集合函数的实现上，因为在这里，我们不仅需要覆盖面上的通量积分，我们还使用MeshWorker接口来简化涉及的循环。

  template <int dim> 
  class AdvectionProblem 
  { 
  public: 
    AdvectionProblem(); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(Vector<double> &solution); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim>   triangulation; 
    const MappingQ1<dim> mapping; 

// 此外，我们想使用程度为1的DG元素（但这只在构造函数中指定）。如果你想使用不同度数的DG方法，整个程序保持不变，只需在构造函数中用所需的多项式度数替换1。

    FE_DGQ<dim>     fe; 
    DoFHandler<dim> dof_handler; 

// 接下来的四个成员代表要解决的线性系统。  <code>system_matrix</code> and <code>right_hand_side</code> 是由 <code>assemble_system()</code>, the <code>solution</code> 产生的， <code>solve()</code>. The <code>sparsity_pattern</code> 是用来确定 <code>system_matrix</code> 中非零元素的位置。

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> right_hand_side; 

// 最后，我们必须提供集合单元、边界和内表面条款的函数。在MeshWorker框架中，所有单元的循环和大部分操作的设置都将在这个类之外完成，所以我们所要提供的只是这三个操作。他们将在中间对象上工作，首先，我们在这里定义了交给本地集成函数的信息对象的别名，以使我们的生活更轻松。

    using DoFInfo  = MeshWorker::DoFInfo<dim>; 
    using CellInfo = MeshWorker::IntegrationInfo<dim>; 

// 下面的三个函数是在所有单元和面的通用循环中被调用的。它们是进行实际整合的函数。

// 在我们下面的代码中，这些函数并不访问当前类的成员变量，所以我们可以将它们标记为 <code>static</code> ，并简单地将这些函数的指针传递给MeshWorker框架。然而，如果这些函数想要访问成员变量（或者需要额外的参数，而不是下面指定的参数），我们可以使用lambda函数的设施来为MeshWorker框架提供对象，这些对象就像它们拥有所需的参数数量和类型一样，但实际上已经绑定了其他参数。

    static void integrate_cell_term(DoFInfo &dinfo, CellInfo &info); 
    static void integrate_boundary_term(DoFInfo &dinfo, CellInfo &info); 
    static void integrate_face_term(DoFInfo & dinfo1, 
                                    DoFInfo & dinfo2, 
                                    CellInfo &info1, 
                                    CellInfo &info2); 
  }; 

// 我们从构造函数开始。 <code>fe</code> 的构造器调用中的1是多项式的度数。

  template <int dim> 
  AdvectionProblem<dim>::AdvectionProblem() 
    : mapping() 
    , fe(1) 
    , dof_handler(triangulation) 
  {} 

  template <int dim> 
  void AdvectionProblem<dim>::setup_system() 
  { 

// 在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。

    dof_handler.distribute_dofs(fe); 

// 我们从生成稀疏模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到 <code>sparsity_pattern</code> 并可以被丢弃。

// 为了建立DG离散的稀疏模式，我们可以调用类似于 DoFTools::make_sparsity_pattern, 的函数，它被称为 DoFTools::make_flux_sparsity_pattern:  
    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

// 最后，我们设置了线性系统的所有组成部分的结构。

    system_matrix.reinit(sparsity_pattern); 
    solution.reinit(dof_handler.n_dofs()); 
    right_hand_side.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{The assemble_system function}  

// 这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是将这一切交给MeshWorker框架。为了做到这一点，我们只需要定义局部的集成函数，并使用命名空间 MeshWorker::Assembler 中的一个类来构建全局系统。

  template <int dim> 
  void AdvectionProblem<dim>::assemble_system() 
  { 

// 这是一个神奇的对象，它知道关于数据结构和局部集成的一切。 这是在函数 MeshWorker::loop(), 中做工作的对象，它被下面的 MeshWorker::integration_loop() 隐式调用。在我们提供指针的函数完成局部积分后， MeshWorker::Assembler::SystemSimple 对象将这些数据分配到全局稀疏矩阵和右手边的向量。

    MeshWorker::IntegrationInfoBox<dim> info_box; 

// 首先，我们在工作者基类中初始化正交公式和更新标志。对于正交，我们采取安全措施，使用QGauss公式，其点数比使用的多项式度数高一个。由于单元格、边界和内部面的正交率可以独立选择，我们必须把这个值交给三次。

    const unsigned int n_gauss_points = dof_handler.get_fe().degree + 1; 
    info_box.initialize_gauss_quadrature(n_gauss_points, 
                                         n_gauss_points, 
                                         n_gauss_points); 

// 这些是我们整合系统时需要的数值类型。它们被添加到单元格、边界和内部面以及内部邻居面所使用的标志中，这是由四个 @p true 值强制执行的。

    info_box.initialize_update_flags(); 
    UpdateFlags update_flags = 
      update_quadrature_points | update_values | update_gradients; 
    info_box.add_update_flags(update_flags, true, true, true, true); 

// 在准备好<tt>info_box</tt>中的所有数据后，我们初始化其中的FEValues对象。

    info_box.initialize(fe, mapping); 

// 到目前为止创建的对象帮助我们在每个单元和面进行局部积分。现在，我们需要一个对象来接收整合后的（本地）数据，并将它们转发给装配程序。

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

// 现在，我们必须创建装配器对象，并告诉它将本地数据放在哪里。这些将是我们的系统矩阵和右手边的数据。

    MeshWorker::Assembler::SystemSimple<SparseMatrix<double>, Vector<double>> 
      assembler; 
    assembler.initialize(system_matrix, right_hand_side); 

// 最后，在所有活动单元上进行积分循环（由第一个参数决定，它是一个活动迭代器）。

// 正如在类声明中声明局部积分函数时的讨论中所指出的，装配积分器类所期望的参数实际上不是函数指针。相反，它们是可以像函数一样被调用的对象，有一定数量的参数。因此，我们也可以在这里传递具有适当的operator()实现的对象，或者如果本地集成器是，例如，非静态成员函数，则可以传递lambda函数。

    MeshWorker::loop<dim, 
                     dim, 
                     MeshWorker::DoFInfo<dim>, 
                     MeshWorker::IntegrationInfoBox<dim>>( 
      dof_handler.begin_active(), 
      dof_handler.end(), 
      dof_info, 
      info_box, 
      &AdvectionProblem<dim>::integrate_cell_term, 
      &AdvectionProblem<dim>::integrate_boundary_term, 
      &AdvectionProblem<dim>::integrate_face_term, 
      assembler); 
  } 
// @sect4{The local integrators}  

// 这些是给上面调用的 MeshWorker::integration_loop() 的函数。它们计算单元格和面中对系统矩阵和右手边的局部贡献。

  template <int dim> 
  void AdvectionProblem<dim>::integrate_cell_term(DoFInfo & dinfo, 
                                                  CellInfo &info) 
  { 

// 首先，让我们从 @p info. 中检索这里使用的一些对象。注意，这些对象可以处理更复杂的结构，因此这里的访问看起来比看起来更复杂。

    const FEValuesBase<dim> &  fe_values    = info.fe_values(); 
    FullMatrix<double> &       local_matrix = dinfo.matrix(0).matrix; 
    const std::vector<double> &JxW          = fe_values.get_JxW_values(); 

// 有了这些对象，我们像往常一样继续进行局部积分。首先，我们在正交点上循环，计算当前点的平流矢量。

    for (unsigned int point = 0; point < fe_values.n_quadrature_points; ++point) 
      { 
        const Tensor<1, dim> beta_at_q_point = 
          beta(fe_values.quadrature_point(point)); 

// 我们求解的是一个同质方程，因此在单元项中没有显示出右手。 剩下的就是对矩阵项的积分。

        for (unsigned int i = 0; i < fe_values.dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < fe_values.dofs_per_cell; ++j) 
            local_matrix(i, j) += -beta_at_q_point *                // 
                                  fe_values.shape_grad(i, point) *  // 
                                  fe_values.shape_value(j, point) * // 
                                  JxW[point]; 
      } 
  } 

// 现在对边界条款也是如此。注意，现在我们使用FEValuesBase，即FEFaceValues和FESubfaceValues的基类，以便获得法向量。

  template <int dim> 
  void AdvectionProblem<dim>::integrate_boundary_term(DoFInfo & dinfo, 
                                                      CellInfo &info) 
  { 
    const FEValuesBase<dim> &fe_face_values = info.fe_values(); 
    FullMatrix<double> &     local_matrix   = dinfo.matrix(0).matrix; 
    Vector<double> &         local_vector   = dinfo.vector(0).block(0); 

    const std::vector<double> &        JxW = fe_face_values.get_JxW_values(); 
    const std::vector<Tensor<1, dim>> &normals = 
      fe_face_values.get_normal_vectors(); 

    std::vector<double> g(fe_face_values.n_quadrature_points); 

    static BoundaryValues<dim> boundary_function; 
    boundary_function.value_list(fe_face_values.get_quadrature_points(), g); 

    for (unsigned int point = 0; point < fe_face_values.n_quadrature_points; 
         ++point) 
      { 
        const double beta_dot_n = 
          beta(fe_face_values.quadrature_point(point)) * normals[point]; 
        if (beta_dot_n > 0) 
          for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < fe_face_values.dofs_per_cell; ++j) 
              local_matrix(i, j) += beta_dot_n *                           // 
                                    fe_face_values.shape_value(j, point) * // 
                                    fe_face_values.shape_value(i, point) * // 
                                    JxW[point]; 
        else 
          for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i) 
            local_vector(i) += -beta_dot_n *                          // 
                               g[point] *                             // 
                               fe_face_values.shape_value(i, point) * // 
                               JxW[point]; 
      } 
  } 

// 最后是内部面的条款。这里的区别是，我们收到了两个信息对象，相邻面的每个单元都有一个，我们组装了四个矩阵，每个单元一个，两个用于来回耦合。

  template <int dim> 
  void AdvectionProblem<dim>::integrate_face_term(DoFInfo & dinfo1, 
                                                  DoFInfo & dinfo2, 
                                                  CellInfo &info1, 
                                                  CellInfo &info2) 
  { 

// 对于正交点、权重等，我们使用第一个参数的FEValuesBase对象。

    const FEValuesBase<dim> &fe_face_values = info1.fe_values(); 
    const unsigned int       dofs_per_cell  = fe_face_values.dofs_per_cell; 

// 对于额外的形状函数，我们必须询问邻居的FEValuesBase。

    const FEValuesBase<dim> &fe_face_values_neighbor = info2.fe_values(); 
    const unsigned int       neighbor_dofs_per_cell = 
      fe_face_values_neighbor.dofs_per_cell; 

// 然后我们得到对四个局部矩阵的引用。字母u和v分别指的是试验和测试函数。%的数字表示由info1和info2提供的单元。按照惯例，每个信息对象中的两个矩阵指的是各自单元上的试验函数。第一个矩阵包含该单元的内部耦合，而第二个矩阵包含单元之间的耦合。

    FullMatrix<double> &u1_v1_matrix = dinfo1.matrix(0, false).matrix; 
    FullMatrix<double> &u2_v1_matrix = dinfo1.matrix(0, true).matrix; 
    FullMatrix<double> &u1_v2_matrix = dinfo2.matrix(0, true).matrix; 
    FullMatrix<double> &u2_v2_matrix = dinfo2.matrix(0, false).matrix; 

// 在这里，按照前面的函数，我们会有本地的右手边向量。幸运的是，界面条款只涉及到解决方案，右手边没有收到任何贡献。

    const std::vector<double> &        JxW = fe_face_values.get_JxW_values(); 
    const std::vector<Tensor<1, dim>> &normals = 
      fe_face_values.get_normal_vectors(); 

    for (unsigned int point = 0; point < fe_face_values.n_quadrature_points; 
         ++point) 
      { 
        const double beta_dot_n = 
          beta(fe_face_values.quadrature_point(point)) * normals[point]; 
        if (beta_dot_n > 0) 
          { 

// 这个词我们已经看过了。

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                u1_v1_matrix(i, j) += beta_dot_n *                           // 
                                      fe_face_values.shape_value(j, point) * // 
                                      fe_face_values.shape_value(i, point) * // 
                                      JxW[point]; 

// 我们另外组装术语  $(\beta\cdot n u,\hat v)_{\partial \kappa_+}$  。

            for (unsigned int k = 0; k < neighbor_dofs_per_cell; ++k) 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                u1_v2_matrix(k, j) += 
                  -beta_dot_n *                                   // 
                  fe_face_values.shape_value(j, point) *          // 
                  fe_face_values_neighbor.shape_value(k, point) * // 
                  JxW[point]; 
          } 
        else 
          { 

// 这个我们也已经看过了。

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              for (unsigned int l = 0; l < neighbor_dofs_per_cell; ++l) 
                u2_v1_matrix(i, l) += 
                  beta_dot_n *                                    // 
                  fe_face_values_neighbor.shape_value(l, point) * // 
                  fe_face_values.shape_value(i, point) *          // 
                  JxW[point]; 

// 而这是另一个新的。 $(\beta\cdot n \hat u,\hat v)_{\partial \kappa_-}$  :

            for (unsigned int k = 0; k < neighbor_dofs_per_cell; ++k) 
              for (unsigned int l = 0; l < neighbor_dofs_per_cell; ++l) 
                u2_v2_matrix(k, l) += 
                  -beta_dot_n *                                   // 
                  fe_face_values_neighbor.shape_value(l, point) * // 
                  fe_face_values_neighbor.shape_value(k, point) * // 
                  JxW[point]; 
          } 
      } 
  } 
// @sect3{All the rest}  

// 对于这个简单的问题，我们使用了最简单的求解器，称为Richardson迭代，它代表了简单的缺陷修正。这与一个块状SSOR预处理相结合，该预处理使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。在这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状的Gauss-Seidel预处理（见PreconditionBlockSOR类，放松=1）会做得更好。

  template <int dim> 
  void AdvectionProblem<dim>::solve(Vector<double> &solution) 
  { 
    SolverControl                    solver_control(1000, 1e-12); 
    SolverRichardson<Vector<double>> solver(solver_control); 

// 这里我们创建了预处理程序。

    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner; 

// 然后将矩阵分配给它，并设置正确的块大小。

    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell()); 

// 做完这些准备工作后，我们就可以启动线性求解器了。

    solver.solve(system_matrix, solution, right_hand_side, preconditioner); 
  } 

// 我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由 <code>DerivativeApproximation</code> 类完成的，它计算近似梯度的方式类似于本教程 step-9 中描述的 <code>GradientEstimation</code> 。事实上， <code>DerivativeApproximation</code> 类是在 step-9 的 <code>GradientEstimation</code> 类之后开发的。与  step-9  中的讨论相关，这里我们考虑  $h^{1+d/2}|\nabla_h u_h|$  。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在 $H^2$ 中，而只在 $H^1$ 中（或者，更准确地说：在 $H^1_\beta$ 中，即在方向 $\beta$ 中的导数是可平方整除的函数空间）。

  template <int dim> 
  void AdvectionProblem<dim>::refine_grid() 
  { 

//  <code>DerivativeApproximation</code> 类将梯度计算为浮点精度。这已经足够了，因为它们是近似的，只作为细化指标。

    Vector<float> gradient_indicator(triangulation.n_active_cells()); 

// 现在，近似梯度被计算出来了

    DerivativeApproximation::approximate_gradient(mapping, 
                                                  dof_handler, 
                                                  solution, 
                                                  gradient_indicator); 

//并且它们被单元格按比例放大，系数为 $h^{1+d/2}$  。
    unsigned int cell_no = 0; 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      gradient_indicator(cell_no++) *= 
        std::pow(cell->diameter(), 1 + 1.0 * dim / 2); 

// 最后它们作为细化指标。

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    gradient_indicator, 
                                                    0.3, 
                                                    0.1); 

    triangulation.execute_coarsening_and_refinement(); 
  } 

// 这个程序的输出包括自适应细化网格的eps文件和gnuplot格式的数值解。

  template <int dim> 
  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const 
  { 

// 首先将网格写成eps格式。

    { 
      const std::string filename = "grid-" + std::to_string(cycle) + ".eps"; 
      deallog << "Writing grid to <" << filename << ">" << std::endl; 
      std::ofstream eps_output(filename); 

      GridOut grid_out; 
      grid_out.write_eps(triangulation, eps_output); 
    } 

// 然后以gnuplot格式输出解决方案。

    { 
      const std::string filename = "sol-" + std::to_string(cycle) + ".gnuplot"; 
      deallog << "Writing solution to <" << filename << ">" << std::endl; 
      std::ofstream gnuplot_output(filename); 

      DataOut<dim> data_out; 
      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution, "u"); 

      data_out.build_patches(); 

      data_out.write_gnuplot(gnuplot_output); 
    } 
  } 

// 下面的 <code>run</code> 函数与前面的例子类似。

  template <int dim> 
  void AdvectionProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 6; ++cycle) 
      { 
        deallog << "Cycle " << cycle << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation); 

            triangulation.refine_global(3); 
          } 
        else 
          refine_grid(); 

        deallog << "Number of active cells:       " 
                << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        deallog << "Number of degrees of freedom: " << dof_handler.n_dofs() 
                << std::endl; 

        assemble_system(); 
        solve(solution); 

        output_results(cycle); 
      } 
  } 
} // namespace Step12 

// 下面的 <code>main</code> 函数与前面的例子也类似，不需要注释。

int main() 
{ 
  try 
    { 
      dealii::deallog.depth_console(5); 

      Step12::AdvectionProblem<2> dgmethod; 
      dgmethod.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-13.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2001 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002 
 */ 



// 像所有的程序一样，我们从库中的include文件列表开始，像往常一样，它们的标准顺序是 <code>base</code>  --  <code>lac</code> -- <code>grid</code> -- <code>dofs</code>  --  <code>fe</code> -- <code>numerics</code> （因为每一类大致都是建立在前面的基础上），然后是C++标准头文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/table_handler.h> 
#include <deal.II/base/thread_management.h> 
#include <deal.II/base/work_stream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 现在是C++标准头文件。

#include <iostream> 
#include <fstream> 
#include <list> 

// 最后一步和以前所有的程序一样。

namespace Step13 
{ 
  using namespace dealii; 
// @sect3{Evaluation of the solution}  

// 至于程序本身，我们首先定义了评估拉普拉斯方程解的类。事实上，它们可以评估每一种解，只要它是由一个 <code>DoFHandler</code> 对象和一个解向量描述的。我们首先在这里定义它们，甚至在实际生成要评估的解的类之前，因为我们需要声明一个抽象的基类，以便解算器类可以引用。

// 从抽象的角度来看，我们声明一个纯粹的基类，它提供了一个评估算子（），它将对解进行评估（无论派生类如何考虑 <code>evaluation</code>  ）。由于这是该基类唯一真正的功能（除了一些簿记机器），我们通常把这样一个只有 <code>operator()</code> 的类称为C++术语中的 <code>functor</code> ，因为它的使用就像一个函数对象。

// 这种函数类型的对象随后将被传递给求解器对象，后者将其应用于刚刚计算出的解决方案。然后，评估对象可以从解决方案中提取他们喜欢的任何数量。将这些评估函数放入一个单独的类的层次结构的好处是，在设计上它们不能使用求解器对象的内部结构，因此独立于求解器工作方式的变化。此外，在不修改求解器类的情况下编写另一个评价类是很容易的，这就加快了编程速度（不能使用另一个类的内部结构也意味着你不必担心它们--对评价器的编程通常是一个相当快的任务），以及编译速度（如果求解器和评价类被放在不同的文件中：求解器只需要看到抽象基类的声明，因此在增加一个新的评价类或修改一个旧的类时不需要被重新编译）。 与此相关的是，你可以在其他项目中重复使用这些评估类，解决不同的方程。

// 为了提高代码在不同模块中的分离度，我们把评估类放到了一个自己的命名空间中。这使得在同一个程序中实际解决不同的方程更加容易，通过现有的构件进行组装。这样做的原因是，用于类似目的的类往往具有相同的名称，尽管它们是在不同的背景下开发的。为了能够在一个程序中一起使用它们，有必要将它们放在不同的命名空间中。我们在这里就是这样做的。

  namespace Evaluation 
  { 

// 现在是评估类的抽象基类：它的主要目的是声明一个纯虚函数 <code>operator()</code> ，接收一个 <code>DoFHandler</code> 对象和解向量。为了能够只使用指向这个基类的指针，它还必须声明一个虚拟的析构器，但这个析构器什么也不做。除此之外，它只提供了一点簿记功能：由于我们通常想在后续的细化水平上评估解决方案，我们存储了当前细化周期的编号，并提供了一个函数来改变这个编号。

    template <int dim> 
    class EvaluationBase 
    { 
    public: 
      virtual ~EvaluationBase() = default; 

      void set_refinement_cycle(const unsigned int refinement_cycle); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const = 0; 

    protected: 
      unsigned int refinement_cycle; 
    }; 

    template <int dim> 
    void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step) 
    { 
      refinement_cycle = step; 
    } 
// @sect4{%Point evaluation}  

// 下一件事是实现实际的评估类。正如介绍中指出的，我们想从解决方案中提取一个点值，所以第一个类在它的 <code>operator()</code> 中做这个。实际的点是通过构造函数给这个类的，还有一个表格对象，它将把它的发现放入其中。

// 如果我们不能依靠知道实际使用的有限元，那么找出任意点的有限元域的值是相当困难的，因为这样我们就不能，例如，在节点之间进行插值。因此，为了简单起见，我们在这里假设我们要评估场的点实际上是一个节点。如果在求解的过程中，我们发现我们在所有顶点上循环时没有遇到这个点，那么我们就必须抛出一个异常，以便向调用的函数发出信号，说明出了问题，而不是默默地忽略这个错误。

// 在  step-9  示例程序中，我们已经看到如何使用  <code>DeclExceptionN</code>  宏来声明这样一个异常类。我们在这里再次使用这种机制。

// 由此可见，这个类的实际声明应该是很明显的。请注意，即使我们没有明确地列出一个析构器，编译器也会生成一个隐含的析构器，而且它和基类的析构器一样是虚拟的。

    template <int dim> 
    class PointValueEvaluation : public EvaluationBase<dim> 
    { 
    public: 
      PointValueEvaluation(const Point<dim> &evaluation_point, 
                           TableHandler &    results_table); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const override; 

      DeclException1( 
        ExcEvaluationPointNotFound, 
        Point<dim>, 
        << "The evaluation point " << arg1 
        << " was not found among the vertices of the present grid."); 

 
      const Point<dim> evaluation_point; 
      TableHandler &   results_table; 
    }; 

// 至于定义，构造函数是微不足道的，只是接收数据并将其存储在对象本地的。

    template <int dim> 
    PointValueEvaluation<dim>::PointValueEvaluation( 
      const Point<dim> &evaluation_point, 
      TableHandler &    results_table) 
      : evaluation_point(evaluation_point) 
      , results_table(results_table) 
    {} 

// 现在是本类中主要感兴趣的函数，即点值的计算。

    template <int dim> 
    void PointValueEvaluation<dim>:: 
         operator()(const DoFHandler<dim> &dof_handler, 
               const Vector<double> & solution) const 
    { 

// 首先分配一个变量，用来保存点值。用一个明显是假的值来初始化它，这样如果我们不能把它设置成一个合理的值，我们就会马上注意到。这在像本函数这样小的函数中可能没有必要，因为我们在这里可以很容易地看到所有可能的执行路径，但事实证明它对更复杂的情况是有帮助的，所以我们在这里也采用了这个策略。

      double point_value = 1e20; 
//然后
//循环所有单元格及其所有顶点，并检查顶点是否与评估点匹配。如果是这样，就提取点的值，设置一个标志，表示我们已经找到了感兴趣的点，然后退出循环。

      bool evaluation_point_found = false; 
      for (const auto &cell : dof_handler.active_cell_iterators()) 
        if (!evaluation_point_found) 
          for (const auto vertex : cell->vertex_indices()) 
            if (cell->vertex(vertex) == evaluation_point) 
              { 

// 为了从全局解决方案矢量中提取点值，挑选属于感兴趣的顶点的那个分量，如果解决方案是矢量值的，则取其第一个分量。

                point_value = solution(cell->vertex_dof_index(vertex, 0)); 

// 请注意，我们在这里做了一个假设，这个假设并不总是有效的，如果这是实际应用的代码，而不是一个教程程序，就应该在类的声明中记录下来：我们假设用于我们试图评估的解决方案的有限元实际上有与顶点相关的自由度。例如，这对不连续元素来说是不成立的，因为形状函数的支持点恰好位于顶点，但不与顶点相关，而是与单元内部相关，因为与顶点相关意味着那里的连续性。这对于面向边缘的元素等也是不成立的。            理想情况下，我们会在函数开始时检查这一点，例如通过一个类似<code>Assert (dof_handler.get_fe().dofs_per_vertex  @>  0, ExcNotImplemented())</code>的语句，这应该可以在异常触发时很清楚地说明问题所在。在这种情况下，我们省略了它（这的确是不好的风格），但是知道这一点在这里并没有什么坏处，因为如果我们要求语句 <code>cell-@>vertex_dof_index(vertex,0)</code> 给我们顶点的DoF索引，如果没有的话，语句就会失败。            我们再次强调，这种对允许的有限元的限制应该在类的文档中说明。

// 由于我们找到了正确的点，我们现在设置相应的标志并退出最里面的循环。由于设置了标志，外循环也将被终止。

                evaluation_point_found = true; 
                break; 
              }; 

// 最后，我们要确定我们确实已经找到了评估点，因为如果不是这样，我们就不能在那里给出一个合理的解的值，反正剩下的计算也是无用的。所以通过 <code>AssertThrow</code> 程序中已经使用的 step-9 宏，确保我们确实找到了这个点。如果不是这样，这个宏就会抛出一个作为第二个参数给它的类型的异常，但与直接的 <code>throw</code> 语句相比，它在异常对象中填充了一组额外的信息，例如，产生异常的源文件和行号，以及失败的条件。如果你在你的主函数里有一个 <code>catch</code> 子句（就像这个程序一样），你会捕捉到所有没有在中间某个地方捕捉到的、因而已经处理过的异常，这些额外的信息会帮助你找出发生了什么以及哪里出了问题。

      AssertThrow(evaluation_point_found, 
                  ExcEvaluationPointNotFound(evaluation_point)); 

// 注意，我们在其他示例程序中也使用了 <code>Assert</code> 宏。它与这里使用的 <code>AssertThrow</code> 宏不同的是，它只是中止程序，而不是抛出一个异常，而且它只在调试模式下这样做。它是用来检查作为参数传递给函数的向量大小的正确宏，以及类似的。

// 然而，这里的情况是不同的：我们是否找到评估点可能会在不同的细化过程中发生变化（例如，如果点周围的四个单元被粗化掉了，那么在细化和粗化之后，点可能会消失）。这是在调试模式下无法预测的事情，但应该经常检查，在生产运行中也是如此。因此，这里使用了 <code>AssertThrow</code> 宏。

// 现在，如果我们确信我们已经找到了评估点，我们可以把结果加入到结果表中。

      results_table.add_value("DoFs", dof_handler.n_dofs()); 
      results_table.add_value("u(x_0)", point_value); 
    } 

//  @sect4{Generating output}  

// 一种不同的，也许略显奇怪的 <code>evaluation</code> 的解决方案是将其以图形格式输出到一个文件中。因为在评估函数中，我们得到了一个 <code>DoFHandler</code> 对象和解决方案的向量，我们已经有了做这件事所需要的一切，所以我们可以在评估类中做这件事。实际上这样做而不是把它放到计算解决方案的类中的原因是，这样我们有更多的灵活性：如果我们选择只输出它的某些方面，或者根本不输出它。在任何情况下，我们都不需要修改求解器类，我们只需要修改其中的一个模块，就可以构建这个程序了。如上所述，这种形式的封装可以帮助我们保持程序的每个部分相当简单，因为接口保持简单，不可能访问隐藏的数据。

// 由于这个生成输出的类是从普通的 <code>EvaluationBase</code> 基类派生出来的，它的主要接口是 <code>operator()</code> 函数。此外，它有一个构造函数，接收一个字符串，该字符串将被用作文件名的基本部分，输出将被发送到该文件名中（我们将用一个数字来增加它，表示细化周期的数量--基类手头有这个信息--以及一个后缀），构造函数还接收一个值，表示要求的格式，即我们将为哪个图形程序生成输出（然后我们也将从这个值中生成我们写入的文件名后缀）。

// 关于输出格式，DataOutBase命名空间提供了一个枚举字段 DataOutBase::OutputFormat ，列出了所有支持的输出格式的名称。在编写本程序时，支持的图形格式由枚举值 <code>ucd</code> 、 <code>gnuplot</code>, <code>povray</code>, <code>eps</code> 、 <code>gmv</code>, <code>tecplot</code>, <code>tecplot_binary</code> 、 <code>dx</code>, <code>vtk</code> 等表示，但这个列表肯定会随着时间而增加。现在，在该基类的各种函数中，你可以使用这种类型的值来获得关于这些图形格式的信息（例如每种格式的文件所使用的默认后缀），你可以调用一个通用的 <code>write</code> 函数，然后根据给它的第二个参数的值表示所需的输出格式，将其分支到我们在以前的例子中已经使用的 <code>write_gnuplot</code>, <code>write_ucd</code> 等函数。这种机制使得编写一个可扩展的程序变得很简单，它可以在运行时决定使用哪种输出格式，同时也使得编写程序的方式变得相当简单，它可以利用新实现的输出格式，而不需要改变应用程序。

// 在这两个字段中，即基本名称和输出格式描述符，构造函数取值并存储它们，以便以后由实际的评估函数使用。

    template <int dim> 
    class SolutionOutput : public EvaluationBase<dim> 
    { 
    public: 
      SolutionOutput(const std::string &             output_name_base, 
                     const DataOutBase::OutputFormat output_format); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const override; 

    private: 
      const std::string               output_name_base; 
      const DataOutBase::OutputFormat output_format; 
    }; 

    template <int dim> 
    SolutionOutput<dim>::SolutionOutput( 
      const std::string &             output_name_base, 
      const DataOutBase::OutputFormat output_format) 
      : output_name_base(output_name_base) 
      , output_format(output_format) 
    {} 

// 按照上面的描述，生成实际输出的函数现在相对简单了。与以前的例子程序相比，唯一特别有趣的特征是使用了 DataOutBase::default_suffix 函数，返回给定格式文件的通常后缀（例如，".eps "用于封装的postscript文件，".gnuplot "用于Gnuplot文件），以及带有第二个参数的通用 DataOut::write() 函数，该函数根据作为第二个参数的格式描述符的值，在内部分支到不同图形格式的实际输出函数。

//还要注意，我们必须在 <code>this-@></code> 前加上前缀，以访问依赖模板的基类的成员变量。这里的原因，以及在程序中更进一步的原因，与 step-7 示例程序中描述的相同（在那里寻找 <code>two-stage name lookup</code> ）。

    template <int dim> 
    void SolutionOutput<dim>::operator()(const DoFHandler<dim> &dof_handler, 
                                         const Vector<double> & solution) const 
    { 
      DataOut<dim> data_out; 
      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution, "solution"); 
      data_out.build_patches(); 

      std::ofstream out(output_name_base + "-" + 
                        std::to_string(this->refinement_cycle) + 
                        data_out.default_suffix(output_format)); 

      data_out.write(out, output_format); 
    } 

//  @sect4{Other evaluations}  

// 在实际应用中，人们会在这里添加一个其他可能的评价类的列表，代表人们可能感兴趣的数量。对于这个例子，这些就足够了，所以我们关闭命名空间。

  } // namespace Evaluation 
// @sect3{The Laplace solver classes}  

// 在定义了我们想知道的解决方案之后，我们现在应该关心如何去获得它。我们将把所有我们需要的东西都打包到一个自己的命名空间中，原因和上面的评估差不多。

// 由于我们在前面的例子中已经相当详细地讨论了拉普拉斯求解器，所以下面就没有什么新东西了。相反，我们在很大程度上拆解了以前的例子，并以稍微不同的形式把它们放到这个例子程序中。因此，我们将主要讨论与以前的例子的不同之处。

// 基本上，正如在介绍中已经说过的，这个例子中缺乏新的东西是故意的，因为它更多地是为了展示软件设计的实践，而不是数学。因此，下面解释的重点将更多地放在实际的实现上。

  namespace LaplaceSolver 
  { 
// @sect4{An abstract base class}  

// 在定义拉普拉斯求解器时，我们首先声明一个抽象的基类，它本身没有任何功能，只是接受和存储一个指向三角形的指针，以便以后使用。

// 这个基类是非常通用的，也可以用于任何其他静止问题。它提供了一些函数的声明，这些函数将在派生类中分别解决一个问题，用评估对象的列表对解决方案进行后处理，以及细化网格。在基类中，这些函数本身都没有做什么。

// 由于缺乏实际功能，声明非常抽象的基类的编程风格类似于Smalltalk或Java程序中使用的风格，所有的类都是从完全抽象的类派生出来的 <code>Object</code>  ，甚至是数字表示。作者承认，他并不特别喜欢在C++中使用这种风格，因为它将风格置于理性之上。此外，它提倡对一切事物使用虚拟函数（例如，在Java中，所有的函数本身就是虚拟的），然而，这在许多应用中被证明是相当低效的，在这些应用中，函数往往只是访问数据，而不是进行计算，因此很快就会返回；这样，虚拟函数的开销就会很大。笔者的观点是，只要至少有一部分实际实现的代码可以被共享，从而被分离到基类中，就应该有抽象的基类。

// 除了这些理论上的问题，我们在这里还有一个很好的理由，这个理由在下面会让读者更清楚。基本上，我们希望能够有一个不同的拉普拉斯求解器家族，这些求解器的差别很大，以至于无法找到更大的共同功能子集。因此，我们只是声明了这样一个抽象的基类，在构造函数中获取一个指向三角形的指针，并从此存储它。由于这个三角剖分将在所有的计算中使用，我们必须确保这个三角剖分在最后使用之前是有效的。我们通过保留一个 <code>SmartPointer</code> 到这个三角剖分来做到这一点，正如 step-7 中所解释的。

// 注意，虽然指针本身被声明为常数（即在这个对象的整个生命周期中，指针指向同一个对象），但它没有被声明为指向一个常数三角的指针。事实上，通过这种方式，我们允许派生类在 <code>refine_grid</code> 函数中细化或粗化三角结构。

// 最后，我们有一个函数 <code>n_dofs</code> 只是驱动函数的一个工具，用来决定我们是否要继续进行网格细化。它返回当前模拟的自由度数量。

    template <int dim> 
    class Base 
    { 
    public: 
      Base(Triangulation<dim> &coarse_grid); 
      virtual ~Base() = default; 

      virtual void solve_problem() = 0; 
      virtual void postprocess( 
        const Evaluation::EvaluationBase<dim> &postprocessor) const = 0; 
      virtual void         refine_grid()                            = 0; 
      virtual unsigned int n_dofs() const                           = 0; 

    protected: 
      const SmartPointer<Triangulation<dim>> triangulation; 
    }; 

// 仅有的两个非抽象函数的实现就相当无聊了。

    template <int dim> 
    Base<dim>::Base(Triangulation<dim> &coarse_grid) 
      : triangulation(&coarse_grid) 
    {} 
// @sect4{A general solver class}  

// 下面是主类，它实现了组装线性系统的矩阵，解决它，并在解决方案上调用后处理器对象。它实现了基类中声明的  <code>solve_problem</code>  和  <code>postprocess</code>  函数。然而，它并没有实现 <code>refine_grid</code> 方法，因为网格细化将在一些派生类中实现。

// 它还声明了一个新的抽象虚函数， <code>assemble_rhs</code>  ，需要在子类中重载。原因是我们将实现两个不同的类，它们将实现不同的方法来组装右手边的向量。这个函数在以下情况下可能也很有趣：右手边不仅仅取决于一个连续函数，还取决于其他东西，例如另一个离散问题的解，等等。后者经常发生在非线性问题中。

// 正如我们之前提到的，这门课的实际内容并不是新的，而是以前的例子中已经使用过的各种技术的混合。因此，我们将不对它们进行详细讨论，而是让读者参考这些程序。

// 基本上，用几句话来说，这个类的构造函数接收指向一个三角形、一个有限元和一个代表边界值的函数对象的指针。这些东西或者被传递给基类的构造函数，或者被存储起来并在以后用来生成一个 <code>DoFHandler</code> 对象。由于有限元和正交公式应该是匹配的，所以它也被传递给一个正交对象。

//  <code>solve_problem</code> 为实际求解设置数据结构，调用函数来组装线性系统，并求解它。

//  <code>postprocess</code> 函数最后接收一个评估对象并将其应用于计算出的解决方案。

//  <code>n_dofs</code> 函数最后实现了基类的纯虚拟函数。

    template <int dim> 
    class Solver : public virtual Base<dim> 
    { 
    public: 
      Solver(Triangulation<dim> &      triangulation, 
             const FiniteElement<dim> &fe, 
             const Quadrature<dim> &   quadrature, 
             const Function<dim> &     boundary_values); 
      virtual ~Solver() override; 

      virtual void solve_problem() override; 

 
        const Evaluation::EvaluationBase<dim> &postprocessor) const override; 

      virtual unsigned int n_dofs() const override; 

// 在这个类的保护部分，我们首先有一些成员变量，其用途在前面的例子中应该很清楚。

    protected: 
      const SmartPointer<const FiniteElement<dim>> fe; 
      const SmartPointer<const Quadrature<dim>>    quadrature; 
      DoFHandler<dim>                              dof_handler; 
      Vector<double>                               solution; 
      const SmartPointer<const Function<dim>>      boundary_values; 

// 然后我们声明一个抽象函数，该函数将用于组装右手边的内容。如上所述，在各种情况下，这个动作的必要性有很大的不同，所以我们将其推迟到派生类中。

      virtual void assemble_rhs(Vector<double> &rhs) const = 0; 

// 接下来，在私有部分，我们有一个小类，它代表了整个线性系统，即一个矩阵、一个右手边和一个解向量，以及应用于它的约束，如那些由于悬挂节点而产生的约束。它的构造函数初始化了各种子对象，还有一个函数实现了共轭梯度法作为求解器。

    private: 
      struct LinearSystem 
      { 
        LinearSystem(const DoFHandler<dim> &dof_handler); 

        void solve(Vector<double> &solution) const; 

        AffineConstraints<double> hanging_node_constraints; 
        SparsityPattern           sparsity_pattern; 
        SparseMatrix<double>      matrix; 
        Vector<double>            rhs; 
      }; 

// 最后，有一组函数将被用来组装实际的系统矩阵。这一组的主函数 <code>assemble_linear_system()</code> 使用以下两个辅助函数，在多核系统上并行计算矩阵。这样做的机制与  step-9  示例程序相同，并遵循  @ref threads  中概述的 WorkStream 概念。主函数还调用了组装右手边的虚拟函数。

      struct AssemblyScratchData 
      { 
        AssemblyScratchData(const FiniteElement<dim> &fe, 
                            const Quadrature<dim> &   quadrature); 
        AssemblyScratchData(const AssemblyScratchData &scratch_data); 

 
 

      struct AssemblyCopyData 
      { 
        FullMatrix<double>                   cell_matrix; 
        std::vector<types::global_dof_index> local_dof_indices; 
      }; 

      void assemble_linear_system(LinearSystem &linear_system); 

      void local_assemble_matrix( 
        const typename DoFHandler<dim>::active_cell_iterator &cell, 
        AssemblyScratchData &                                 scratch_data, 
        AssemblyCopyData &                                    copy_data) const; 

      void copy_local_to_global(const AssemblyCopyData &copy_data, 
                                LinearSystem &          linear_system) const; 
    }; 

// 现在是该类的构造函数。它没有做什么，只是存储了给定对象的指针，并生成了 <code>DoFHandler</code> 对象，初始化了给定的三角形的指针。这使得DoF处理程序存储该指针，但并没有生成有限元编号（我们只在 <code>solve_problem</code> 函数中要求这样做）。

    template <int dim> 
    Solver<dim>::Solver(Triangulation<dim> &      triangulation, 
                        const FiniteElement<dim> &fe, 
                        const Quadrature<dim> &   quadrature, 
                        const Function<dim> &     boundary_values) 
      : Base<dim>(triangulation) 
      , fe(&fe) 
      , quadrature(&quadrature) 
      , dof_handler(triangulation) 
      , boundary_values(&boundary_values) 
    {} 

// 解构器很简单，它只是清除存储在DoF处理程序对象中的信息以释放内存。

    template <int dim> 
    Solver<dim>::~Solver() 
    { 
      dof_handler.clear(); 
    } 

// 下一个函数是解决这个问题的主要工作：它用给这个对象的构造函数的有限元来设置DoF处理程序对象，创建一个表示线性系统的对象（即矩阵、右手向量和解向量），调用函数来组装它，最后解决它。

    template <int dim> 
    void Solver<dim>::solve_problem() 
    { 
      dof_handler.distribute_dofs(*fe); 
      solution.reinit(dof_handler.n_dofs()); 

      LinearSystem linear_system(dof_handler); 
      assemble_linear_system(linear_system); 
      linear_system.solve(solution); 
    } 

// 如上所述， <code>postprocess</code> 函数接收一个评估对象，并将其应用于计算的解决方案。这个函数可以被多次调用，对用户要求的每一个解的评估都要调用一次。

    template <int dim> 
    void Solver<dim>::postprocess( 
      const Evaluation::EvaluationBase<dim> &postprocessor) const 
    { 
      postprocessor(dof_handler, solution); 
    } 

//  <code>n_dofs</code> 函数应该是不言自明的。

    template <int dim> 
    unsigned int Solver<dim>::n_dofs() const 
    { 
      return dof_handler.n_dofs(); 
    } 

// 下面的函数在每一步中组装矩阵和要解决的线性系统的右手边。我们将在几个层面上并行地做事情。首先，请注意，我们需要组装矩阵和右手边。这些都是独立的操作，我们应该并行地进行这些操作。为此，我们使用 @ref threads 文档模块中讨论的 "任务 "概念。本质上，我们想说的是 "这里有一些需要处理的事情，只要有CPU核可用就去做"，然后再做其他事情，当我们需要第一个操作的结果时，就等待它的完成。在第二层，我们想使用与我们在 step-9 中已经使用过的完全相同的策略来组装矩阵，即WorkStream概念。

// 虽然我们可以考虑在做另一件事的时候在后台组装右侧或组装矩阵，但我们将选择前一种方法，只是因为调用 <code>Solver::assemble_rhs</code> 比调用 WorkStream::run 及其许多参数要简单得多。在任何情况下，代码看起来像这样，以组装整个线性系统。

    template <int dim> 
    void Solver<dim>::assemble_linear_system(LinearSystem &linear_system) 
    { 
      Threads::Task<void> rhs_task = 
        Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs); 

      auto worker = 
        [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
               AssemblyScratchData &scratch_data, 
               AssemblyCopyData &   copy_data) { 
          this->local_assemble_matrix(cell, scratch_data, copy_data); 
        }; 

      auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) { 
        this->copy_local_to_global(copy_data, linear_system); 
      }; 

      WorkStream::run(dof_handler.begin_active(), 
                      dof_handler.end(), 
                      worker, 
                      copier, 
                      AssemblyScratchData(*fe, *quadrature), 
                      AssemblyCopyData()); 
      linear_system.hanging_node_constraints.condense(linear_system.matrix); 

// 上面的语法需要一些解释。 WorkStream::run 有多个版本，期待不同的参数。在  step-9  中，我们使用了一个版本，它需要一对迭代器、一对指向具有非常具体的参数列表的成员函数的指针、一个指向这些成员函数必须工作的对象的指针或引用，以及一个抓取和复制数据对象。这有点限制性，因为这样调用的成员函数的参数列表必须与 WorkStream::run 所期望的完全一致：本地装配函数需要接收一个迭代器、一个抓取对象和一个复制对象；而复制-本地-全局函数需要接收的正是一个复制对象。但是，如果我们想要的东西稍微更通用一些呢？例如，在目前的程序中，copy-local-to-global函数需要知道将本地贡献写入哪个线性系统对象中，也就是说，它还必须接受一个 <code>LinearSystem</code> 参数。这在使用成员函数指针的方法中是行不通的。

// 幸运的是，C++提供了一条出路。这些被称为函数对象。本质上， WorkStream::run 想要做的不是调用一个成员函数。它想调用一些函数，这些函数在第一种情况下需要一个迭代器、一个抓取对象和一个拷贝对象，而在第二种情况下需要一个拷贝对象。不管这些是成员函数、全局函数，还是其他什么，对WorkStream来说，真的不是很关心。因此，有第二个版本的函数只接收函数对象--具有  <code>operator()</code>  的对象，因此可以像函数一样被调用，不管它们真正代表什么。产生这种函数对象的典型方法是使用一个<a href="http:en.wikipedia.org/wiki/Anonymous_function">lambda function</a>，它用固定的值来包装函数调用，包括各个参数。所有属于外层函数签名的参数在lambda函数中被指定为常规的函数参数。固定值使用捕获列表（`[...]`）传递到lambda函数中。可以使用捕获默认值，也可以明确列出所有要绑定到lambda的变量。为了清楚起见，我们决定在这里省略捕获默认值，但是捕获列表同样可以是`[&]`，这意味着所有使用的变量都通过引用复制到lambda中。

// 在这一点上，我们已经组装好了矩阵，并将其浓缩。右手边可能已经完全组装好了，也可能还没有，但是我们接下来想浓缩右手边的向量。我们只有在这个向量的组装完成后才能这样做，所以我们必须等待任务的完成；在计算机科学中，等待任务通常被称为 "加入 "任务，解释了我们下面调用的函数的名称。

// 既然这个任务可能已经完成，也可能没有完成，既然我们可能要等它完成，我们不妨试着把其他需要完成的事情装进这个空隙。因此，我们首先插值边界值，然后再等待右手边的工作。当然，另一种可能性是在一个单独的任务中也插值边界值，因为这样做与我们到目前为止在这个函数中所做的其他事情无关。请自由地找到正确的语法，为这个插值创建一个任务，并在这个函数的顶部启动它，同时装配右手边。(你会发现这稍微有点复杂，因为 VectorTools::interpolate_boundary_values(), 有多个版本，所以简单地取地址 <code>&VectorTools::interpolate_boundary_values</code> 会产生一组重载函数，不能马上传递给 Threads::new_task() --你必须通过将地址表达式转换为函数指针类型，选择你想要的这个重载集合中的哪个元素，这是你想在任务中调用的特定版本的函数。)

      std::map<types::global_dof_index, double> boundary_value_map; 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               *boundary_values, 
                                               boundary_value_map); 

      rhs_task.join(); 
      linear_system.hanging_node_constraints.condense(linear_system.rhs); 

// 现在我们有了完整的线性系统，我们也可以处理边界值，需要从矩阵和右手边消除。

      MatrixTools::apply_boundary_values(boundary_value_map, 
                                         linear_system.matrix, 
                                         solution, 
                                         linear_system.rhs); 
    } 

// 这组函数的后半部分是处理每个单元上的局部装配，并将局部贡献复制到全局矩阵对象中。这与  step-9  中描述的工作方式完全相同。

    template <int dim> 
    Solver<dim>::AssemblyScratchData::AssemblyScratchData( 
      const FiniteElement<dim> &fe, 
      const Quadrature<dim> &   quadrature) 
      : fe_values(fe, quadrature, update_gradients | update_JxW_values) 
    {} 

    template <int dim> 
    Solver<dim>::AssemblyScratchData::AssemblyScratchData( 
      const AssemblyScratchData &scratch_data) 
      : fe_values(scratch_data.fe_values.get_fe(), 
                  scratch_data.fe_values.get_quadrature(), 
                  update_gradients | update_JxW_values) 
    {} 

    template <int dim> 
    void Solver<dim>::local_assemble_matrix( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      AssemblyScratchData &                                 scratch_data, 
      AssemblyCopyData &                                    copy_data) const 
    { 
      const unsigned int dofs_per_cell = fe->n_dofs_per_cell(); 
      const unsigned int n_q_points    = quadrature->size(); 

      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 

      copy_data.local_dof_indices.resize(dofs_per_cell); 

      scratch_data.fe_values.reinit(cell); 

      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            copy_data.cell_matrix(i, j) += 
              (scratch_data.fe_values.shape_grad(i, q_point) * 
               scratch_data.fe_values.shape_grad(j, q_point) * 
               scratch_data.fe_values.JxW(q_point)); 

      cell->get_dof_indices(copy_data.local_dof_indices); 
    } 

    template <int dim> 
    void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data, 
                                           LinearSystem &linear_system) const 
    { 
      for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i) 
        for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j) 
          linear_system.matrix.add(copy_data.local_dof_indices[i], 
                                   copy_data.local_dof_indices[j], 
                                   copy_data.cell_matrix(i, j)); 
    } 

// 现在是实现线性系统类中动作的函数。首先，构造函数将所有数据元素初始化为正确的大小，并设置了一些额外的数据结构，例如由于悬挂节点而产生的约束。由于设置悬空节点和找出矩阵的非零元素是独立的，所以我们以并行方式进行（如果库被配置为使用并发，至少是这样；否则，这些动作是按顺序执行的）。注意，我们只启动一个线程，并在主线程中做第二个动作。由于只生成了一个任务，我们在这里不使用 <code>Threads::TaskGroup</code> 类，而是直接使用创建的一个任务对象来等待这个特定任务的退出。

// 注意，占用 <code>DoFTools::make_hanging_node_constraints</code> 函数的地址有点麻烦，因为它实际上有三个，每个支持的空间维度都有一个。在C++中，获取重载函数的地址有些复杂，因为在这种情况下，操作符 <code>&</code> 返回的更像是一组值（所有具有该名称的函数的地址），然后选择正确的函数是下一步的工作。如果上下文决定采取哪一个（例如通过分配给一个已知类型的函数指针），那么编译器可以自己做，但如果这组指针应作为一个采取模板的函数的参数，编译器可以选择所有的，而不偏向于一个。因此，我们必须向编译器说明我们想要哪一个；为此，我们可以使用cast，但为了更清楚，我们把它分配给一个具有正确类型的临时 <code>mhnc_p</code> （简称<code>pointer to make_hanging_node_constraints</code>），并使用这个指针代替。

    template <int dim> 
    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler) 
    { 
      hanging_node_constraints.clear(); 

      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) = 
        &DoFTools::make_hanging_node_constraints; 

// 启动一个辅助任务，然后在主线程上继续进行

      Threads::Task<void> side_task = 
        Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints); 

      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler, dsp); 

// 等到边上的任务完成后再继续前进

      side_task.join(); 

      hanging_node_constraints.close(); 
      hanging_node_constraints.condense(dsp); 
      sparsity_pattern.copy_from(dsp); 

// 最后初始化矩阵和右手边的向量

      matrix.reinit(sparsity_pattern); 
      rhs.reinit(dof_handler.n_dofs()); 
    } 

// 该类的第二个函数只是通过预处理的共轭梯度法来解决线性系统。这一点之前已经被广泛讨论过了，所以我们不再赘述了。

    template <int dim> 
    void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const 
    { 
      SolverControl            solver_control(1000, 1e-12); 
      SolverCG<Vector<double>> cg(solver_control); 

      PreconditionSSOR<SparseMatrix<double>> preconditioner; 
      preconditioner.initialize(matrix, 1.2); 

      cg.solve(matrix, solution, rhs, preconditioner); 

      hanging_node_constraints.distribute(solution); 
    } 

//  @sect4{A primal solver}  

// 在上一节中，我们实现了一个拉普拉斯求解器的基类，该基类缺乏组装右手边向量的功能，但是，由于其中的原因，我们已经解释了。现在我们实现了一个相应的类，它可以在问题的右边以函数对象的形式给出的情况下完成这一工作。

// 这个类的动作和你在以前的例子中已经看到的差不多，所以简单解释一下就够了：构造函数和底层类的数据相同（它把所有的信息传递给底层类），除了一个表示问题右侧的函数对象。这个对象的指针被存储起来（同样作为一个 <code>SmartPointer</code> ，以确保这个函数对象只要还被这个类使用就不会被删除）。

// 这个类的唯一功能部分是 <code>assemble_rhs</code> 方法，它的作用和它的名字一样。

    template <int dim> 
    class PrimalSolver : public Solver<dim> 
    { 
    public: 
      PrimalSolver(Triangulation<dim> &      triangulation, 
                   const FiniteElement<dim> &fe, 
                   const Quadrature<dim> &   quadrature, 
                   const Function<dim> &     rhs_function, 
                   const Function<dim> &     boundary_values); 

    protected: 
      const SmartPointer<const Function<dim>> rhs_function; 
      virtual void assemble_rhs(Vector<double> &rhs) const override; 
    }; 

// 这个类的构造函数基本上做了上面宣布的事情......

    template <int dim> 
    PrimalSolver<dim>::PrimalSolver(Triangulation<dim> &      triangulation, 
                                    const FiniteElement<dim> &fe, 
                                    const Quadrature<dim> &   quadrature, 
                                    const Function<dim> &     rhs_function, 
                                    const Function<dim> &     boundary_values) 
      : Base<dim>(triangulation) 
      , Solver<dim>(triangulation, fe, quadrature, boundary_values) 
      , rhs_function(&rhs_function) 
    {} 

// ... 和 <code>assemble_rhs</code> 函数一样。因为在前面的几个例子程序中已经解释过了，所以我们就不多说了。

    template <int dim> 
    void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const 
    { 
      FEValues<dim> fe_values(*this->fe, 
                              *this->quadrature, 
                              update_values | update_quadrature_points | 
                                update_JxW_values); 

      const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell(); 
      const unsigned int n_q_points    = this->quadrature->size(); 

 
      std::vector<double>                  rhs_values(n_q_points); 
      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

      for (const auto &cell : this->dof_handler.active_cell_iterators()) 
        { 
          cell_rhs = 0; 
          fe_values.reinit(cell); 
          rhs_function->value_list(fe_values.get_quadrature_points(), 
                                   rhs_values); 

          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_rhs(i) += fe_values.shape_value(i, q_point) * // 
                             rhs_values[q_point] *               // 
                             fe_values.JxW(q_point); 

          cell->get_dof_indices(local_dof_indices); 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            rhs(local_dof_indices[i]) += cell_rhs(i); 
        }; 
    } 
// @sect4{Global refinement}  

// 至此，除了 <code>refine_grid</code> 函数外，抽象基类的所有函数都已实现。现在我们将有两个类为 <code>PrimalSolver</code> 类实现这个函数，一个做全局细化，一个做局部细化的形式。

// 第一个做全局细化的类相当简单：它的主函数只是调用 <code>triangulation-@>refine_global (1);</code> ，它做所有的工作。

// 注意，由于 <code>Base</code> 类的基类是虚拟的，我们必须声明一个构造函数来初始化直接的基类和抽象的虚拟类。

// 除了这个技术上的复杂性之外，这个类可能很简单，可以不做进一步的评论。

    template <int dim> 
    class RefinementGlobal : public PrimalSolver<dim> 
    { 
    public: 
      RefinementGlobal(Triangulation<dim> &      coarse_grid, 
                       const FiniteElement<dim> &fe, 
                       const Quadrature<dim> &   quadrature, 
                       const Function<dim> &     rhs_function, 
                       const Function<dim> &     boundary_values); 

      virtual void refine_grid() override; 
    }; 

    template <int dim> 
    RefinementGlobal<dim>::RefinementGlobal( 
      Triangulation<dim> &      coarse_grid, 
      const FiniteElement<dim> &fe, 
      const Quadrature<dim> &   quadrature, 
      const Function<dim> &     rhs_function, 
      const Function<dim> &     boundary_values) 
      : Base<dim>(coarse_grid) 
      , PrimalSolver<dim>(coarse_grid, 
                          fe, 
                          quadrature, 
                          rhs_function, 
                          boundary_values) 
    {} 

    template <int dim> 
    void RefinementGlobal<dim>::refine_grid() 
    { 
      this->triangulation->refine_global(1); 
    } 
// @sect4{Local refinement by the Kelly error indicator}  

// 第二个实现细化策略的类使用了之前各种示例程序中使用的凯利细化指标。由于这个指标已经在deal.II库中用自己的类实现了，所以这里没有太多的事情要做，只是调用计算指标的函数，然后用它来选择一些单元进行细化和粗化，并相应地对网格进行细化。

// 同样，现在应该足够标准了，可以省去更多的注释。

    template <int dim> 
    class RefinementKelly : public PrimalSolver<dim> 
    { 
    public: 
      RefinementKelly(Triangulation<dim> &      coarse_grid, 
                      const FiniteElement<dim> &fe, 
                      const Quadrature<dim> &   quadrature, 
                      const Function<dim> &     rhs_function, 
                      const Function<dim> &     boundary_values); 

      virtual void refine_grid() override; 
    }; 

    template <int dim> 
    RefinementKelly<dim>::RefinementKelly(Triangulation<dim> &      coarse_grid, 
                                          const FiniteElement<dim> &fe, 
                                          const Quadrature<dim> &   quadrature, 
                                          const Function<dim> &rhs_function, 
                                          const Function<dim> &boundary_values) 
      : Base<dim>(coarse_grid) 
      , PrimalSolver<dim>(coarse_grid, 
                          fe, 
                          quadrature, 
                          rhs_function, 
                          boundary_values) 
    {} 

    template <int dim> 
    void RefinementKelly<dim>::refine_grid() 
    { 
      Vector<float> estimated_error_per_cell( 
        this->triangulation->n_active_cells()); 
      KellyErrorEstimator<dim>::estimate( 
        this->dof_handler, 
        QGauss<dim - 1>(this->fe->degree + 1), 
        std::map<types::boundary_id, const Function<dim> *>(), 
        this->solution, 
        estimated_error_per_cell); 
      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation, 
                                                      estimated_error_per_cell, 
                                                      0.3, 
                                                      0.03); 
      this->triangulation->execute_coarsening_and_refinement(); 
    } 

  } // namespace LaplaceSolver 

//  @sect3{Equation data}  

// 由于这又是一个学术性的例子，我们想对精确解和计算解进行相互比较。为此，我们需要声明代表精确解的函数类（用于比较和Dirichlet边界值），以及一个表示方程右边的类（这只是应用于我们想恢复的精确解的拉普拉斯算子）。

// 在这个例子中，让我们选择函数 $u(x,y)=exp(x+sin(10y+5x^2))$ 作为精确解。在超过两个维度的情况下，只需用 <code>y</code> replaced by <code>z</code> 重复正弦系数，以此类推。鉴于此，以下两类可能是直接从以前的例子中得出的。

  template <int dim> 
  class Solution : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component) const override; 
  }; 

  template <int dim> 
  double Solution<dim>::value(const Point<dim> & p, 
                              const unsigned int component) const 
  { 
    (void)component; 
    AssertIndexRange(component, 1); 
    double q = p(0); 
    for (unsigned int i = 1; i < dim; ++i) 
      q += std::sin(10 * p(i) + 5 * p(0) * p(0)); 
    const double exponential = std::exp(q); 
    return exponential; 
  } 

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component) const override; 
  }; 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & p, 
                                   const unsigned int component) const 
  { 
    (void)component; 
    AssertIndexRange(component, 1); 
    double q = p(0); 
    for (unsigned int i = 1; i < dim; ++i) 
      q += std::sin(10 * p(i) + 5 * p(0) * p(0)); 
    const double u  = std::exp(q); 
    double       t1 = 1, t2 = 0, t3 = 0; 
    for (unsigned int i = 1; i < dim; ++i) 
      { 
        t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0); 
        t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) - 
              100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0); 
        t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) * 
                std::cos(10 * p(i) + 5 * p(0) * p(0)) - 
              100 * std::sin(10 * p(i) + 5 * p(0) * p(0)); 
      }; 
    t1 = t1 * t1; 

    return -u * (t1 + t2 + t3); 
  } 

//  @sect3{The driver routines}  

// 现在缺少的只是实际选择各种选项的函数，以及在连续的更细的网格上运行模拟，监测网格细化的进展。

// 我们在下面的函数中做到了这一点：它接收一个求解器对象和一个后处理（评估）对象的列表，并在间歇性的网格细化中运行它们。

  template <int dim> 
  void run_simulation( 
    LaplaceSolver::Base<dim> &                          solver, 
    const std::list<Evaluation::EvaluationBase<dim> *> &postprocessor_list) 
  { 

// 我们将给出一个我们目前正在计算的步骤的指示器，以便让用户知道一些事情仍在发生，并且程序没有处于无尽的循环中。这就是这个状态行的标题。

    std::cout << "Refinement cycle: "; 

// 然后开始一个循环，只有当自由度数大于20000时才会结束（当然你可以改变这个限制，如果你需要更多--或者更少--你的程序的准确性）。

    for (unsigned int step = 0; true; ++step) 
      { 

// 然后给这个迭代的 <code>alive</code> 指示。注意， <code>std::flush</code> 是需要的，以使文本真正出现在屏幕上，而不是只出现在某个缓冲区中，而这个缓冲区只有在我们下一次发出结束线时才会被刷新。

        std::cout << step << " " << std::flush; 

// 现在在现在的网格上解决问题，并在其上运行评估器。迭代器进入列表的长类型名称有点烦人，但如果需要的话，可以用别名来缩短。

        solver.solve_problem(); 

        for (const auto &postprocessor : postprocessor_list) 
          { 
            postprocessor->set_refinement_cycle(step); 
            solver.postprocess(*postprocessor); 
          }; 

// 现在检查是否需要更多的迭代，或者是否应该结束循环。

        if (solver.n_dofs() < 20000) 
          solver.refine_grid(); 
        else 
          break; 
      }; 

// 最后结束我们显示状态报告的那一行。

    std::cout << std::endl; 
  } 

// 最后一个函数是接受一个求解器的名字（目前允许使用 "kelly "和 "global"），用一个粗网格（这里是无处不在的单位方格）和一个有限元对象（这里也是无处不在的双线性对象）创建一个求解器对象，并使用该求解器来要求在一连串的细化网格上解决问题。

// 该函数还设置了两个评估函数，一个是在(0.5,0.5)点评估解决方案，另一个是将解决方案写入一个文件。

  template <int dim> 
  void solve_problem(const std::string &solver_name) 
  { 

// 第一个小任务：告诉用户将发生什么。因此，写一个标题行，并在下面写上与第一个标题相同长度的所有'-'字符的行。

    const std::string header = 
      "Running tests with \"" + solver_name + "\" refinement criterion:"; 
    std::cout << header << std::endl 
              << std::string(header.size(), '-') << std::endl; 

// 然后设置三角法、有限元等。

    Triangulation<dim> triangulation; 
    GridGenerator::hyper_cube(triangulation, -1, 1); 
    triangulation.refine_global(2); 
    const FE_Q<dim>    fe(1); 
    const QGauss<dim>  quadrature(4); 
    RightHandSide<dim> rhs_function; 
    Solution<dim>      boundary_values; 

// 创建一个由该函数的参数指示的解算器对象。如果该名称不被识别，则抛出一个异常! 各自的求解器对象被存储在一个 `std::unique_ptr` 中，以避免使用后不得不删除指针。

    std::unique_ptr<LaplaceSolver::Base<dim>> solver; 
    if (solver_name == "global") 
      solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>( 
        triangulation, fe, quadrature, rhs_function, boundary_values); 
    else if (solver_name == "kelly") 
      solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>( 
        triangulation, fe, quadrature, rhs_function, boundary_values); 
    else 
      AssertThrow(false, ExcNotImplemented()); 

// 接下来创建一个表对象，其中将存储点（0.5,0.5）的数值解的值，并创建一个相应的评估对象。

    TableHandler                          results_table; 
    Evaluation::PointValueEvaluation<dim> postprocessor1(Point<dim>(0.5, 0.5), 
                                                         results_table); 

// 还会生成一个评估器，将解决方案写出来。

    Evaluation::SolutionOutput<dim> postprocessor2(std::string("solution-") + 
                                                     solver_name, 
                                                   DataOutBase::gnuplot); 

// 把这两个评价对象放在一个列表中...

    std::list<Evaluation::EvaluationBase<dim> *> postprocessor_list; 
    postprocessor_list.push_back(&postprocessor1); 
    postprocessor_list.push_back(&postprocessor2); 

// 然后，我们可以将其传递给在连续细化的网格上实际运行模拟的函数。

    run_simulation(*solver, postprocessor_list); 

// 当这一切完成后，写出点评估的结果。

    results_table.write_text(std::cout); 

// 在所有结果之后再写上一行空白。

    std::cout << std::endl; 
  } 
} // namespace Step13 

// 关于主函数没有什么可说的。它沿用了之前所有例子中的模式，试图捕捉被抛出的异常，并在我们得到一些信息时尽可能多地显示出来。剩下的就不言自明了。

int main() 
{ 
  try 
    { 
      Step13::solve_problem<2>("global"); 
      Step13::solve_problem<2>("kelly"); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 

  return 0; 
} 


CCTest_file/step-14.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2002 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, ETH Zurich, 2002 
 */ 



// 从众所周知的事情开始......

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/thread_management.h> 
#include <deal.II/base/work_stream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_tools.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <algorithm> 
#include <fstream> 
#include <iostream> 
#include <list> 
#include <memory> 
#include <numeric> 

// 最后一步和以前所有的程序一样。

namespace Step14 
{ 
  using namespace dealii; 
// @sect3{Evaluating the solution}  

// 正如介绍中提到的，该程序的重要部分只是从 step-13 的例子程序中拿过来的。因此，我们只对那些新的东西进行评论。

// 首先，评估解决方案的框架没有改变，即基类是相同的，评估网格点上的解决方案的类也没有改变。

  namespace Evaluation 
  { 
// @sect4{The EvaluationBase class}  
    template <int dim> 
    class EvaluationBase 
    { 
    public: 
      virtual ~EvaluationBase() = default; 

      void set_refinement_cycle(const unsigned int refinement_cycle); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const = 0; 

    protected: 
      unsigned int refinement_cycle; 
    }; 

    template <int dim> 
    void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step) 
    { 
      refinement_cycle = step; 
    } 
// @sect4{The PointValueEvaluation class}  
    template <int dim> 
    class PointValueEvaluation : public EvaluationBase<dim> 
    { 
    public: 
      PointValueEvaluation(const Point<dim> &evaluation_point); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const override; 

      DeclException1( 
        ExcEvaluationPointNotFound, 
        Point<dim>, 
        << "The evaluation point " << arg1 
        << " was not found among the vertices of the present grid."); 

    private: 
      const Point<dim> evaluation_point; 
    }; 

    template <int dim> 
    PointValueEvaluation<dim>::PointValueEvaluation( 
      const Point<dim> &evaluation_point) 
      : evaluation_point(evaluation_point) 
    {} 

    template <int dim> 
    void PointValueEvaluation<dim>:: 
         operator()(const DoFHandler<dim> &dof_handler, 
               const Vector<double> & solution) const 
    { 
      double point_value = 1e20; 

      bool evaluation_point_found = false; 
      for (const auto &cell : dof_handler.active_cell_iterators()) 
        if (!evaluation_point_found) 
          for (const auto vertex : cell->vertex_indices()) 
            if (cell->vertex(vertex).distance(evaluation_point) < 
                cell->diameter() * 1e-8) 
              { 
                point_value = solution(cell->vertex_dof_index(vertex, 0)); 

                evaluation_point_found = true; 
                break; 
              } 

      AssertThrow(evaluation_point_found, 
                  ExcEvaluationPointNotFound(evaluation_point)); 

      std::cout << "   Point value=" << point_value << std::endl; 
    } 
// @sect4{The PointXDerivativeEvaluation class}  

// 除了实现在一个点上求解的类，我们在这里提供一个在网格点上求梯度的类。由于一般情况下，有限元函数的梯度在一个顶点上是不连续的，所以我们在这里要稍微小心一点。我们要做的是在所有单元中循环，即使我们已经在一个单元中找到了点，也要使用所有相邻单元中的顶点梯度的平均值。

// 鉴于 <code>PointValueEvaluation</code> 类的接口，这个类的声明没有提供什么惊喜，构造函数也没有。

    template <int dim> 
    class PointXDerivativeEvaluation : public EvaluationBase<dim> 
    { 
    public: 
      PointXDerivativeEvaluation(const Point<dim> &evaluation_point); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const; 

      DeclException1( 
        ExcEvaluationPointNotFound, 
        Point<dim>, 
        << "The evaluation point " << arg1 
        << " was not found among the vertices of the present grid."); 

    private: 
      const Point<dim> evaluation_point; 
    }; 

    template <int dim> 
    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation( 
      const Point<dim> &evaluation_point) 
      : evaluation_point(evaluation_point) 
    {} 

// 更有趣的事情发生在进行实际评估的函数中。

    template <int dim> 
    void PointXDerivativeEvaluation<dim>:: 
         operator()(const DoFHandler<dim> &dof_handler, 
               const Vector<double> & solution) const 
    { 

// 这次用一些有用的东西来初始化返回值，因为我们要把一些贡献加起来，之后再取平均值。

      double point_derivative = 0; 

// ...然后有一些对象，其含义将在下面变得清晰...

      QTrapezoid<dim>             vertex_quadrature; 
      FEValues<dim>               fe_values(dof_handler.get_fe(), 
                              vertex_quadrature, 
                              update_gradients | update_quadrature_points); 
      std::vector<Tensor<1, dim>> solution_gradients(vertex_quadrature.size()); 

// ...接下来循环所有单元格及其顶点，并计算顶点被发现的频率。

      unsigned int evaluation_point_hits = 0; 
      for (const auto &cell : dof_handler.active_cell_iterators()) 
        for (const auto vertex : cell->vertex_indices()) 
          if (cell->vertex(vertex) == evaluation_point) 
            { 

// 现在事情不再那么简单了，因为我们不能像以前那样得到有限元场的梯度，我们只需要在一个顶点上选择一个自由度。        相反，我们必须在这个单元上，在某一点上评估有限元场。如你所知，在某一点上评估有限元场是通过 <code>FEValues</code> 类完成的，所以我们使用它。问题是： <code>FEValues</code> 对象需要给定一个正交公式，然后可以计算正交点的有限元量值。在这里，我们并不想做正交，我们只是想指定一些点!         尽管如此，还是选择同样的方式：使用一个特殊的正交规则，点在顶点，因为这些是我们感兴趣的。适当的规则是梯形规则，所以这就是我们上面使用该规则的原因。        因此：在这个单元格上初始化 <code>FEValues</code> 对象。

              fe_values.reinit(cell); 

// 并在顶点提取解向量的梯度。

              fe_values.get_function_gradients(solution, solution_gradients); 

// 现在我们有了所有顶点的梯度，所以选出属于评估点的那一个（注意顶点的顺序不一定和正交点的顺序一样）。

              unsigned int q_point = 0; 
              for (; q_point < solution_gradients.size(); ++q_point) 
                if (fe_values.quadrature_point(q_point) == evaluation_point) 
                  break; 

// 检查是否确实找到了评估点。

              Assert(q_point < solution_gradients.size(), ExcInternalError()); 

// 如果是这样，就把那里的梯度的X导数作为我们感兴趣的值，并增加计数器，表示我们向该变量添加了多少次。

              point_derivative += solution_gradients[q_point][0]; 
              ++evaluation_point_hits; 

// 最后跳出最内层的循环，遍历当前单元格的顶点，因为如果我们在一个顶点找到了评估点，就不可能在后面的顶点也找到。

              break; 
            } 

// 现在我们已经循环了所有的单元和顶点，所以检查是否找到了这个点。

      AssertThrow(evaluation_point_hits > 0, 
                  ExcEvaluationPointNotFound(evaluation_point)); 

// 我们已经简单地将所有相邻的单元格的贡献相加，所以我们仍然要计算出平均值。一旦完成，报告状态。

      point_derivative /= evaluation_point_hits; 
      std::cout << "   Point x-derivative=" << point_derivative << std::endl; 
    } 

//  @sect4{The GridOutput class}  

// 由于这个程序有一个更困难的结构（它除了计算一个原始解之外，还计算了一个对偶解），所以写出解不再由一个评估对象来完成，因为我们想把两个解同时写进一个文件，这需要一些比评估类可用的信息。

// 然而，我们也想看看生成的网格。这也可以通过一个这样的类来完成。它的结构类似于前面例子程序中的 <code>SolutionOutput</code> 类，所以我们在这里不做更详细的讨论。此外，这里所使用的一切都已经在前面的例子程序中使用过了。

    template <int dim> 
    class GridOutput : public EvaluationBase<dim> 
    { 
    public: 
      GridOutput(const std::string &output_name_base); 

      virtual void operator()(const DoFHandler<dim> &dof_handler, 
                              const Vector<double> & solution) const override; 

    private: 
      const std::string output_name_base; 
    }; 

    template <int dim> 
    GridOutput<dim>::GridOutput(const std::string &output_name_base) 
      : output_name_base(output_name_base) 
    {} 

    template <int dim> 
    void GridOutput<dim>::operator()(const DoFHandler<dim> &dof_handler, 
                                     const Vector<double> & /*solution*/) const 
    { 
      std::ofstream out(output_name_base + "-" + 
                        std::to_string(this->refinement_cycle) + ".svg"); 
      GridOut().write_svg(dof_handler.get_triangulation(), out); 
    } 
  } // namespace Evaluation 
// @sect3{The Laplace solver classes}  

// 接下来是实际的求解器类。同样，我们只讨论与之前程序的不同之处。

  namespace LaplaceSolver 
  { 
// @sect4{The Laplace solver base class}  

// 这个类几乎没有变化，只是多声明了两个函数。  <code>output_solution</code> 将用于从派生类计算的实际解决方案中生成输出文件，以及 <code>set_refinement_cycle</code> 函数，测试框架通过该函数将细化周期的编号设置为该类中的一个局部变量；该编号随后将用于生成解决方案输出的文件名。

    template <int dim> 
    class Base 
    { 
    public: 
      Base(Triangulation<dim> &coarse_grid); 
      virtual ~Base() = default; 

      virtual void solve_problem() = 0; 
      virtual void postprocess( 
        const Evaluation::EvaluationBase<dim> &postprocessor) const = 0; 
      virtual void         refine_grid()                            = 0; 
      virtual unsigned int n_dofs() const                           = 0; 

      virtual void set_refinement_cycle(const unsigned int cycle); 

      virtual void output_solution() const = 0; 

    protected: 
      const SmartPointer<Triangulation<dim>> triangulation; 

      unsigned int refinement_cycle; 
    }; 

    template <int dim> 
    Base<dim>::Base(Triangulation<dim> &coarse_grid) 
      : triangulation(&coarse_grid) 
      , refinement_cycle(numbers::invalid_unsigned_int) 
    {} 

    template <int dim> 
    void Base<dim>::set_refinement_cycle(const unsigned int cycle) 
    { 
      refinement_cycle = cycle; 
    } 
// @sect4{The Laplace Solver class}  

// 同样地， <code>Solver</code> 类完全没有变化，因此将不进行讨论。

    template <int dim> 
    class Solver : public virtual Base<dim> 
    { 
    public: 
      Solver(Triangulation<dim> &       triangulation, 
             const FiniteElement<dim> & fe, 
             const Quadrature<dim> &    quadrature, 
             const Quadrature<dim - 1> &face_quadrature, 
             const Function<dim> &      boundary_values); 
      virtual ~Solver() override; 

      virtual void solve_problem() override; 

      virtual void postprocess( 
        const Evaluation::EvaluationBase<dim> &postprocessor) const override; 

      virtual unsigned int n_dofs() const override; 

    protected: 
      const SmartPointer<const FiniteElement<dim>>  fe; 
      const SmartPointer<const Quadrature<dim>>     quadrature; 
      const SmartPointer<const Quadrature<dim - 1>> face_quadrature; 
      DoFHandler<dim>                               dof_handler; 
      Vector<double>                                solution; 
      const SmartPointer<const Function<dim>>       boundary_values; 

      virtual void assemble_rhs(Vector<double> &rhs) const = 0; 

    private: 
      struct LinearSystem 
      { 
        LinearSystem(const DoFHandler<dim> &dof_handler); 

        void solve(Vector<double> &solution) const; 

        AffineConstraints<double> hanging_node_constraints; 
        SparsityPattern           sparsity_pattern; 
        SparseMatrix<double>      matrix; 
        Vector<double>            rhs; 
      }; 

// 该类的其余部分基本上也是 step-13 的副本，包括使用WorkStream框架并行计算线性系统所需的数据结构和函数。

      struct AssemblyScratchData 
      { 
        AssemblyScratchData(const FiniteElement<dim> &fe, 
                            const Quadrature<dim> &   quadrature); 
        AssemblyScratchData(const AssemblyScratchData &scratch_data); 

        FEValues<dim> fe_values; 
      }; 

      struct AssemblyCopyData 
      { 
        FullMatrix<double>                   cell_matrix; 
        std::vector<types::global_dof_index> local_dof_indices; 
      }; 

      void assemble_linear_system(LinearSystem &linear_system); 

      void local_assemble_matrix( 
        const typename DoFHandler<dim>::active_cell_iterator &cell, 
        AssemblyScratchData &                                 scratch_data, 
        AssemblyCopyData &                                    copy_data) const; 

      void copy_local_to_global(const AssemblyCopyData &copy_data, 
                                LinearSystem &          linear_system) const; 
    }; 

    template <int dim> 
    Solver<dim>::Solver(Triangulation<dim> &       triangulation, 
                        const FiniteElement<dim> & fe, 
                        const Quadrature<dim> &    quadrature, 
                        const Quadrature<dim - 1> &face_quadrature, 
                        const Function<dim> &      boundary_values) 
      : Base<dim>(triangulation) 
      , fe(&fe) 
      , quadrature(&quadrature) 
      , face_quadrature(&face_quadrature) 
      , dof_handler(triangulation) 
      , boundary_values(&boundary_values) 
    {} 

    template <int dim> 
    Solver<dim>::~Solver() 
    { 
      dof_handler.clear(); 
    } 

    template <int dim> 
    void Solver<dim>::solve_problem() 
    { 
      dof_handler.distribute_dofs(*fe); 
      solution.reinit(dof_handler.n_dofs()); 

      LinearSystem linear_system(dof_handler); 
      assemble_linear_system(linear_system); 
      linear_system.solve(solution); 
    } 

    template <int dim> 
    void Solver<dim>::postprocess( 
      const Evaluation::EvaluationBase<dim> &postprocessor) const 
    { 
      postprocessor(dof_handler, solution); 
    } 

    template <int dim> 
    unsigned int Solver<dim>::n_dofs() const 
    { 
      return dof_handler.n_dofs(); 
    } 

// 以下几个函数和构造函数是逐字复制的，来自  step-13  。

    template <int dim> 
    void Solver<dim>::assemble_linear_system(LinearSystem &linear_system) 
    { 
      Threads::Task<void> rhs_task = 
        Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs); 

      auto worker = 
        [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
               AssemblyScratchData &scratch_data, 
               AssemblyCopyData &   copy_data) { 
          this->local_assemble_matrix(cell, scratch_data, copy_data); 
        }; 

      auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) { 
        this->copy_local_to_global(copy_data, linear_system); 
      }; 

      WorkStream::run(dof_handler.begin_active(), 
                      dof_handler.end(), 
                      worker, 
                      copier, 
                      AssemblyScratchData(*fe, *quadrature), 
                      AssemblyCopyData()); 
      linear_system.hanging_node_constraints.condense(linear_system.matrix); 

      std::map<types::global_dof_index, double> boundary_value_map; 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               *boundary_values, 
                                               boundary_value_map); 

      rhs_task.join(); 
      linear_system.hanging_node_constraints.condense(linear_system.rhs); 

      MatrixTools::apply_boundary_values(boundary_value_map, 
                                         linear_system.matrix, 
                                         solution, 
                                         linear_system.rhs); 
    } 

    template <int dim> 
    Solver<dim>::AssemblyScratchData::AssemblyScratchData( 
      const FiniteElement<dim> &fe, 
      const Quadrature<dim> &   quadrature) 
      : fe_values(fe, quadrature, update_gradients | update_JxW_values) 
    {} 

    template <int dim> 
    Solver<dim>::AssemblyScratchData::AssemblyScratchData( 
      const AssemblyScratchData &scratch_data) 
      : fe_values(scratch_data.fe_values.get_fe(), 
                  scratch_data.fe_values.get_quadrature(), 
                  update_gradients | update_JxW_values) 
    {} 

    template <int dim> 
    void Solver<dim>::local_assemble_matrix( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      AssemblyScratchData &                                 scratch_data, 
      AssemblyCopyData &                                    copy_data) const 
    { 
      const unsigned int dofs_per_cell = fe->n_dofs_per_cell(); 
      const unsigned int n_q_points    = quadrature->size(); 

      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 

      copy_data.local_dof_indices.resize(dofs_per_cell); 

      scratch_data.fe_values.reinit(cell); 

      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            copy_data.cell_matrix(i, j) += 
              (scratch_data.fe_values.shape_grad(i, q_point) * 
               scratch_data.fe_values.shape_grad(j, q_point) * 
               scratch_data.fe_values.JxW(q_point)); 

      cell->get_dof_indices(copy_data.local_dof_indices); 
    } 

    template <int dim> 
    void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data, 
                                           LinearSystem &linear_system) const 
    { 
      for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i) 
        for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j) 
          linear_system.matrix.add(copy_data.local_dof_indices[i], 
                                   copy_data.local_dof_indices[j], 
                                   copy_data.cell_matrix(i, j)); 
    } 

// 现在是实现线性系统类中动作的函数。首先，构造函数将所有数据元素初始化为正确的大小，并设置了一些额外的数据结构，例如由于悬挂节点而产生的约束。由于设置悬空节点和找出矩阵的非零元素是独立的，所以我们以并行方式进行（如果库被配置为使用并发，至少是这样；否则，这些动作是按顺序执行的）。注意，我们只启动一个线程，并在主线程中做第二个动作。由于只生成一个线程，我们在这里不使用 <code>Threads::TaskGroup</code> 类，而是直接使用创建的一个任务对象来等待这个特定任务的退出。这个方法与我们在上面 <code>Solver::assemble_linear_system()</code> 中使用的方法大致相同。

// 注意，获取 <code>DoFTools::make_hanging_node_constraints</code> 函数的地址有点麻烦，因为实际上有三个这个名字的函数，每个支持的空间维度都有一个。在C++中，获取重载函数的地址有些复杂，因为在这种情况下，操作符 <code>&</code> 会返回一组值（所有具有该名称的函数的地址），然后选择正确的函数是下一步的事情。如果上下文决定采取哪一个（例如通过分配给一个已知类型的函数指针），那么编译器可以自己做，但是如果这组指针应作为一个采取模板的函数的参数，编译器可以选择所有的，而不偏向于一个。因此，我们必须向编译器说明我们想要哪一个；为此，我们可以使用cast，但为了更清楚，我们把它分配给一个具有正确类型的临时 <code>mhnc_p</code> （简称<code>pointer to make_hanging_node_constraints</code>），并使用这个指针代替。

    template <int dim> 
    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler) 
    { 
      hanging_node_constraints.clear(); 

      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) = 
        &DoFTools::make_hanging_node_constraints; 

// 启动一个辅助任务，然后在主线程上继续进行

      Threads::Task<void> side_task = 
        Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints); 

      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler, dsp); 

// 等到边上的任务完成后再继续前进

      side_task.join(); 

      hanging_node_constraints.close(); 
      hanging_node_constraints.condense(dsp); 
      sparsity_pattern.copy_from(dsp); 

      matrix.reinit(sparsity_pattern); 
      rhs.reinit(dof_handler.n_dofs()); 
    } 

    template <int dim> 
    void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const 
    { 
      SolverControl            solver_control(5000, 1e-12); 
      SolverCG<Vector<double>> cg(solver_control); 

      PreconditionSSOR<SparseMatrix<double>> preconditioner; 
      preconditioner.initialize(matrix, 1.2); 

      cg.solve(matrix, solution, rhs, preconditioner); 

      hanging_node_constraints.distribute(solution); 
    } 

//  @sect4{The PrimalSolver class}  

//  <code>PrimalSolver</code> 类除了实现 <code>output_solution</code> 函数外，也基本没有变化。我们在这个程序中保留了 <code>GlobalRefinement</code> and <code>RefinementKelly</code> 类，它们就可以依赖这个函数的默认实现，这个函数只是输出原始解。实现双重加权误差估计的类将自行重载这个函数，以同时输出双重解。

    template <int dim> 
    class PrimalSolver : public Solver<dim> 
    { 
    public: 
      PrimalSolver(Triangulation<dim> &       triangulation, 
                   const FiniteElement<dim> & fe, 
                   const Quadrature<dim> &    quadrature, 
                   const Quadrature<dim - 1> &face_quadrature, 
                   const Function<dim> &      rhs_function, 
                   const Function<dim> &      boundary_values); 

      virtual void output_solution() const override; 

    protected: 
      const SmartPointer<const Function<dim>> rhs_function; 
      virtual void assemble_rhs(Vector<double> &rhs) const override; 
    }; 

    template <int dim> 
    PrimalSolver<dim>::PrimalSolver(Triangulation<dim> &       triangulation, 
                                    const FiniteElement<dim> & fe, 
                                    const Quadrature<dim> &    quadrature, 
                                    const Quadrature<dim - 1> &face_quadrature, 
                                    const Function<dim> &      rhs_function, 
                                    const Function<dim> &      boundary_values) 
      : Base<dim>(triangulation) 
      , Solver<dim>(triangulation, 
                    fe, 
                    quadrature, 
                    face_quadrature, 
                    boundary_values) 
      , rhs_function(&rhs_function) 
    {} 

    template <int dim> 
    void PrimalSolver<dim>::output_solution() const 
    { 
      DataOut<dim> data_out; 
      data_out.attach_dof_handler(this->dof_handler); 
      data_out.add_data_vector(this->solution, "solution"); 
      data_out.build_patches(); 

      std::ofstream out("solution-" + std::to_string(this->refinement_cycle) + 
                        ".vtu"); 
      data_out.write(out, DataOutBase::vtu); 
    } 

    template <int dim> 
    void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const 
    { 
      FEValues<dim> fe_values(*this->fe, 
                              *this->quadrature, 
                              update_values | update_quadrature_points | 
                                update_JxW_values); 

      const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell(); 
      const unsigned int n_q_points    = this->quadrature->size(); 

      Vector<double>                       cell_rhs(dofs_per_cell); 
      std::vector<double>                  rhs_values(n_q_points); 
      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

      for (const auto &cell : this->dof_handler.active_cell_iterators()) 
        { 
          cell_rhs = 0; 

          fe_values.reinit(cell); 

          rhs_function->value_list(fe_values.get_quadrature_points(), 
                                   rhs_values); 

          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q) 
                              rhs_values[q_point] *               // f((x_q) 
                              fe_values.JxW(q_point));            // dx 

          cell->get_dof_indices(local_dof_indices); 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            rhs(local_dof_indices[i]) += cell_rhs(i); 
        } 
    } 
// @sect4{The RefinementGlobal and RefinementKelly classes}  

// 对于下面的两个类，与上面的大多数情况相同：类是按原样取自前面的例子。

    template <int dim> 
    class RefinementGlobal : public PrimalSolver<dim> 
    { 
    public: 
      RefinementGlobal(Triangulation<dim> &       coarse_grid, 
                       const FiniteElement<dim> & fe, 
                       const Quadrature<dim> &    quadrature, 
                       const Quadrature<dim - 1> &face_quadrature, 
                       const Function<dim> &      rhs_function, 
                       const Function<dim> &      boundary_values); 

      virtual void refine_grid() override; 
    }; 

    template <int dim> 
    RefinementGlobal<dim>::RefinementGlobal( 
      Triangulation<dim> &       coarse_grid, 
      const FiniteElement<dim> & fe, 
      const Quadrature<dim> &    quadrature, 
      const Quadrature<dim - 1> &face_quadrature, 
      const Function<dim> &      rhs_function, 
      const Function<dim> &      boundary_values) 
      : Base<dim>(coarse_grid) 
      , PrimalSolver<dim>(coarse_grid, 
                          fe, 
                          quadrature, 
                          face_quadrature, 
                          rhs_function, 
                          boundary_values) 
    {} 

    template <int dim> 
    void RefinementGlobal<dim>::refine_grid() 
    { 
      this->triangulation->refine_global(1); 
    } 

    template <int dim> 
    class RefinementKelly : public PrimalSolver<dim> 
    { 
    public: 
      RefinementKelly(Triangulation<dim> &       coarse_grid, 
                      const FiniteElement<dim> & fe, 
                      const Quadrature<dim> &    quadrature, 
                      const Quadrature<dim - 1> &face_quadrature, 
                      const Function<dim> &      rhs_function, 
                      const Function<dim> &      boundary_values); 

      virtual void refine_grid() override; 
    }; 

    template <int dim> 
    RefinementKelly<dim>::RefinementKelly( 
      Triangulation<dim> &       coarse_grid, 
      const FiniteElement<dim> & fe, 
      const Quadrature<dim> &    quadrature, 
      const Quadrature<dim - 1> &face_quadrature, 
      const Function<dim> &      rhs_function, 
      const Function<dim> &      boundary_values) 
      : Base<dim>(coarse_grid) 
      , PrimalSolver<dim>(coarse_grid, 
                          fe, 
                          quadrature, 
                          face_quadrature, 
                          rhs_function, 
                          boundary_values) 
    {} 

    template <int dim> 
    void RefinementKelly<dim>::refine_grid() 
    { 
      Vector<float> estimated_error_per_cell( 
        this->triangulation->n_active_cells()); 
      KellyErrorEstimator<dim>::estimate( 
        this->dof_handler, 
        QGauss<dim - 1>(this->fe->degree + 1), 
        std::map<types::boundary_id, const Function<dim> *>(), 
        this->solution, 
        estimated_error_per_cell); 
      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation, 
                                                      estimated_error_per_cell, 
                                                      0.3, 
                                                      0.03); 
      this->triangulation->execute_coarsening_and_refinement(); 
    } 

//  @sect4{The RefinementWeightedKelly class}  

// 这个类是前一个类的变种，它允许通过一些函数来加权我们从库的凯利指标中得到的细化指标。我们包括这个类，因为这个例子程序的目标是展示自动细化标准，即使是复杂的输出量，如点值或应力。如果我们不解决一个对偶问题并计算其中的权重，我们很可能会想给指标一个手工制作的权重，以说明我们要评估这些数量的事实。这个类接受这样一个加权函数作为其构造函数的参数。

    template <int dim> 
    class RefinementWeightedKelly : public PrimalSolver<dim> 
    { 
    public: 
      RefinementWeightedKelly(Triangulation<dim> &       coarse_grid, 
                              const FiniteElement<dim> & fe, 
                              const Quadrature<dim> &    quadrature, 
                              const Quadrature<dim - 1> &face_quadrature, 
                              const Function<dim> &      rhs_function, 
                              const Function<dim> &      boundary_values, 
                              const Function<dim> &      weighting_function); 

      virtual void refine_grid() override; 

    private: 
      const SmartPointer<const Function<dim>> weighting_function; 
    }; 

    template <int dim> 
    RefinementWeightedKelly<dim>::RefinementWeightedKelly( 
      Triangulation<dim> &       coarse_grid, 
      const FiniteElement<dim> & fe, 
      const Quadrature<dim> &    quadrature, 
      const Quadrature<dim - 1> &face_quadrature, 
      const Function<dim> &      rhs_function, 
      const Function<dim> &      boundary_values, 
      const Function<dim> &      weighting_function) 
      : Base<dim>(coarse_grid) 
      , PrimalSolver<dim>(coarse_grid, 
                          fe, 
                          quadrature, 
                          face_quadrature, 
                          rhs_function, 
                          boundary_values) 
      , weighting_function(&weighting_function) 
    {} 

// 现在，这里是主函数，包括加权。

    template <int dim> 
    void RefinementWeightedKelly<dim>::refine_grid() 
    { 

// 首先通过库中已经实现的方法为所有单元计算一些基于残差的误差指标。我们在这里计算的具体内容在该类的文档中会有更详细的描述。

      Vector<float> estimated_error_per_cell( 
        this->triangulation->n_active_cells()); 
      std::map<types::boundary_id, const Function<dim> *> dummy_function_map; 
      KellyErrorEstimator<dim>::estimate(this->dof_handler, 
                                         *this->face_quadrature, 
                                         dummy_function_map, 
                                         this->solution, 
                                         estimated_error_per_cell); 

// 接下来用给与构造函数的值来衡量指标向量中的每个条目，在单元格中心进行评估。我们需要将结果写入对应于当前单元的向量条目中，我们可以通过使用 CellAccessor::active_cell_index(). 询问该单元在所有活动单元中的索引来获得（实际上，对于我们在循环中处理的第一个单元，该索引为0，第二个单元为1，等等，我们也可以使用一个整数计数器来跟踪该索引；但是使用 CellAccessor::active_cell_index() 使其更加明确。

      for (const auto &cell : this->dof_handler.active_cell_iterators()) 
        estimated_error_per_cell(cell->active_cell_index()) *= 
          weighting_function->value(cell->center()); 

      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation, 
                                                      estimated_error_per_cell, 
                                                      0.3, 
                                                      0.03); 
      this->triangulation->execute_coarsening_and_refinement(); 
    } 

  } // namespace LaplaceSolver 
// @sect3{Equation data}  

// 在这个例子中，我们使用的数据集和前面的一样，但由于可能有人想用不同的边界值和右手函数来运行程序，或者在不同的网格上运行，我们展示了一个简单的技术来做到这一点。为了更加清晰，我们进一步将所有与方程数据有关的东西都打包到一个自己的命名空间中。

// 我们的基本假设是，这是一个研究项目，我们经常有一些测试案例，包括一个域，一个右手边，边界值，可能还有一个指定的系数，以及一些其他参数。当从一个例子转移到另一个例子时，它们常常同时变化。为了使处理这样的问题描述参数集变得简单，是以下的目标。

// 基本上，这个想法是这样的：让我们为每一组数据都有一个结构，在这个结构中，我们把描述一个测试案例的所有东西都打包：这里，这些是两个子类，一个叫 <code>BoundaryValues</code> ，用于精确解的边界值，一个叫 <code>RightHandSide</code>  ，然后是生成粗略网格的方法。由于前面的例子程序的解看起来像弯曲的山脊，所以我们在这里用这个名字来表示包围的类。请注意，两个内层类的名称对于所有包围的测试案例类必须是相同的，同时我们将维度模板参数附加到包围类而不是内层类，以使进一步的处理更简单。 从语言的角度来看，用命名空间来封装这些内部类会比用结构来封装更好。然而，命名空间不能作为模板参数给出，所以我们使用一个结构来允许第二个对象从其给定的参数中选择。当然，这个封闭的结构除了它所声明的类之外，没有任何成员变量，还有一个静态函数来生成粗略的网格；一般来说，它永远不会被实例化）。)

//然后
//想法是如下的（这是正确的时间，也可以简单看看下面的代码）：我们可以为边界值和右手边生成对象，只需将外层类的名字作为模板参数给一个类，我们在这里称之为 <code>Data::SetUp</code> ，然后它为内部类创建对象。在这种情况下，为了得到所有描述弧形山脊解决方案的特征，我们将简单地生成一个 <code>Data::SetUp@<Data::CurvedRidge@></code> 的实例，而我们需要知道的关于该解决方案的一切都将是该对象的静态成员变量和函数。

// 在这种情况下，这种方法可能显得有些多余，但是一旦某种设定不仅有迪里希特边界值和右手函数的特征，而且还有材料属性、诺伊曼值、不同的边界描述符等，就会变得非常方便。在这种情况下， <code>SetUp</code> 类可能由十几个对象组成，而每个描述符类（如下面的 <code>CurvedRidges</code> 类）都必须提供这些对象。然后，你会很高兴，只需在一个地方改变 <code>SetUp</code> 类的模板参数，而不是在很多地方改变，就能从一组数据改变到另一组。

// 有了这个不同测试用例的框架，我们就快完成了，但还有一件事：现在我们可以通过改变一个模板参数，静态地选择要选择的数据集。为了能够动态地做到这一点，即在运行时，我们需要一个基类。我们以明显的方式提供这个基类，见下文，用虚拟抽象函数。这迫使我们引入第二个模板参数 <code>dim</code> ，我们需要这个基类（这可以通过一些模板魔法来避免，但我们省略），但这就是全部。

// 添加新的测试用例现在很简单，你不需要接触框架类，只需要一个类似于  <code>CurvedRidges</code>  的结构。

  namespace Data 
  { 
// @sect4{The SetUpBase and SetUp classes}  

// 基于上述描述， <code>SetUpBase</code> 类就看起来如下。为了允许用这个类来使用 <code>SmartPointer</code> 类，我们从 <code>Subscriptor</code> 类派生出来。

    template <int dim> 
    struct SetUpBase : public Subscriptor 
    { 
      virtual const Function<dim> &get_boundary_values() const = 0; 

      virtual const Function<dim> &get_right_hand_side() const = 0; 

      virtual void 
      create_coarse_grid(Triangulation<dim> &coarse_grid) const = 0; 
    }; 

// 现在是接受模板参数的派生类，如上所述。

// 在这里，我们把数据元素打包成私有变量，并允许通过基类的方法来访问它们。

    template <class Traits, int dim> 
    struct SetUp : public SetUpBase<dim> 
    { 
      virtual const Function<dim> &get_boundary_values() const override; 

      virtual const Function<dim> &get_right_hand_side() const override; 

      virtual void 
      create_coarse_grid(Triangulation<dim> &coarse_grid) const override; 

    private: 
      static const typename Traits::BoundaryValues boundary_values; 
      static const typename Traits::RightHandSide  right_hand_side; 
    }; 

// 我们必须为上述类的静态成员变量提供定义。

    template <class Traits, int dim> 
    const typename Traits::BoundaryValues SetUp<Traits, dim>::boundary_values; 
    template <class Traits, int dim> 
    const typename Traits::RightHandSide SetUp<Traits, dim>::right_hand_side; 

// 还有成员函数的定义。

    template <class Traits, int dim> 
    const Function<dim> &SetUp<Traits, dim>::get_boundary_values() const 
    { 
      return boundary_values; 
    } 

    template <class Traits, int dim> 
    const Function<dim> &SetUp<Traits, dim>::get_right_hand_side() const 
    { 
      return right_hand_side; 
    } 

    template <class Traits, int dim> 
    void SetUp<Traits, dim>::create_coarse_grid( 
      Triangulation<dim> &coarse_grid) const 
    { 
      Traits::create_coarse_grid(coarse_grid); 
    } 
// @sect4{The CurvedRidges class}  

// 用于描述 <code>curved ridge</code> 问题的边界值和右手边的类已经在 step-13 示例程序中使用，那么就像这样。

    template <int dim> 
    struct CurvedRidges 
    { 
      class BoundaryValues : public Function<dim> 
      { 
      public: 
        virtual double value(const Point<dim> & p, 
                             const unsigned int component) const;
      }; 

      class RightHandSide : public Function<dim> 
      { 
      public: 
        virtual double value(const Point<dim> & p, 
                             const unsigned int component) const; 
      }; 

      static void create_coarse_grid(Triangulation<dim> &coarse_grid); 
    }; 

    template <int dim> 
    double CurvedRidges<dim>::BoundaryValues::value( 
      const Point<dim> &p, 
      const unsigned int /*component*/) const 
    { 
      double q = p(0); 
      for (unsigned int i = 1; i < dim; ++i) 
        q += std::sin(10 * p(i) + 5 * p(0) * p(0)); 
      const double exponential = std::exp(q); 
      return exponential; 
    } 

    template <int dim> 
    double CurvedRidges<dim>::RightHandSide::value( 
      const Point<dim> &p, 
      const unsigned int /*component*/) const 
    { 
      double q = p(0); 
      for (unsigned int i = 1; i < dim; ++i) 
        q += std::sin(10 * p(i) + 5 * p(0) * p(0)); 
      const double u  = std::exp(q); 
      double       t1 = 1, t2 = 0, t3 = 0; 
      for (unsigned int i = 1; i < dim; ++i) 
        { 
          t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0); 
          t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) - 
                100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0); 
          t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) * 
                  std::cos(10 * p(i) + 5 * p(0) * p(0)) - 
                100 * std::sin(10 * p(i) + 5 * p(0) * p(0)); 
        } 
      t1 = t1 * t1; 

      return -u * (t1 + t2 + t3); 
    } 

    template <int dim> 
    void CurvedRidges<dim>::create_coarse_grid(Triangulation<dim> &coarse_grid) 
    { 
      GridGenerator::hyper_cube(coarse_grid, -1, 1); 
      coarse_grid.refine_global(2); 
    } 
// @sect4{The Exercise_2_3 class}  

// 这个例子程序是在为自适应有限元方法和基于对偶性的误差估计的讲座提供实践课程时写的。在这些课程中，我们有一个练习，要求在一个中心有方孔的正方形域上求解右方恒定的拉普拉斯方程，并且边界值为零。由于这个问题的属性在这里的实现特别简单，所以让我们来做。由于练习的编号是2.3，所以我们也擅自为这个类保留这个名称。

    template <int dim> 
    struct Exercise_2_3 
    { 

// 我们需要一个类来表示问题的边界值。在这种情况下，这很简单：它是零函数，所以甚至不需要声明一个类，只需要一个别名。

      using BoundaryValues = Functions::ZeroFunction<dim>; 

// 第二，一个表示右边的类。因为它们是常数，所以只要把库中相应的类子类化就可以了。

      class RightHandSide : public Functions::ConstantFunction<dim> 
      { 
      public: 
        RightHandSide() 
          : Functions::ConstantFunction<dim>(1.) 
        {} 
      }; 

// 最后是一个生成粗略网格的函数。这里的情况有些复杂，请看下面的内容。

      static void create_coarse_grid(Triangulation<dim> &coarse_grid); 
    }; 

// 如上所述，本例的网格是正方形[-1,1]^2，其中的正方形[-1/2,1/2]^2为孔。我们将粗略的网格创建为4乘以4的单元，中间的四个单元缺失。要了解网格的具体样子，最简单的方法可能是先看一下本教程程序的 "结果 "部分。一般来说，如果你想了解更多关于创建网格的信息，无论是像我们在这里所做的那样从头开始，还是使用其他技术，你都应该看一下  step-49  。

// 当然，这个例子可以扩展到3d，但是由于这个函数不能以独立于维度的方式编写，我们选择不在这里实现，而是只对dim=2的模板进行专业化处理。如果你编译3d的程序，你会从链接器中得到一个信息，即这个函数在3d中没有实现，需要提供。

// 对于这个几何体的创建，库中没有预定义的方法。在这种情况下，几何体还是很简单的，可以用手来创建，而不是用网格发生器。

    template <> 
    void Exercise_2_3<2>::create_coarse_grid(Triangulation<2> &coarse_grid) 
    { 

// 我们首先定义空间维度，以便让函数中那些实际上与维度无关的部分使用这个变量。这样，如果你以后把它作为一个起点来实现这个网格的三维版本，就会更简单。下一步是要有一个顶点的列表。这里，它们是24个（5乘以5，中间的省略）。最好的办法是在这里画一个草图。

      const unsigned int dim = 2; 

      const std::vector<Point<2>> vertices = { 
        {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, // 
        {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, // 
        {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               // 
        {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, // 
        {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}}; 

// 接下来，我们要定义单元格和它们所包含的顶点。

      const std::vector<std::array<int, GeometryInfo<dim>::vertices_per_cell>> 
        cell_vertices = {{{0, 1, 5, 6}}, 
                         {{1, 2, 6, 7}}, 
                         {{2, 3, 7, 8}}, 
                         {{3, 4, 8, 9}}, 
                         {{5, 6, 10, 11}}, 
                         {{8, 9, 12, 13}}, 
                         {{10, 11, 14, 15}}, 
                         {{12, 13, 17, 18}}, 
                         {{14, 15, 19, 20}}, 
                         {{15, 16, 20, 21}}, 
                         {{16, 17, 21, 22}}, 
                         {{17, 18, 22, 23}}}; 

      const unsigned int n_cells = cell_vertices.size(); 

// 我们再次从中生成一个C++向量类型，但这次是通过在单元格上循环来实现的（是的，这很无聊）。此外，我们将所有单元格的材料指标设置为零。

      std::vector<CellData<dim>> cells(n_cells, CellData<dim>()); 
      for (unsigned int i = 0; i < n_cells; ++i) 
        { 
          for (unsigned int j = 0; j < cell_vertices[i].size(); ++j) 
            cells[i].vertices[j] = cell_vertices[i][j]; 
          cells[i].material_id = 0; 
        } 

// 最后将所有这些信息传递给库，以生成一个三角图。最后一个参数可以用来将三角形的某些面的非零边界指标的信息传递给库，但我们在这里不希望这样，所以我们给出一个空对象。

      coarse_grid.create_triangulation(vertices, cells, SubCellData()); 

// 因为我们希望本例中的评估点（3/4,3/4）是一个网格点，所以我们在全局范围内细化一次。

      coarse_grid.refine_global(1); 
    } 
  } // namespace Data 
// @sect4{Discussion}  

// 你现在已经读完了这个框架，你可能会想，为什么我们没有选择直接把实现某种设置的类（比如 <code>CurvedRidges</code> 类）作为派生自 <code>Data::SetUpBase</code> 的类来实现。事实上，我们可以很好地这样做。唯一的原因是，这样我们就必须在 <code>CurvedRidges</code> 类中为解决方案和右手边的类设置成员变量，以及重载基类的抽象函数来访问这些成员变量的成员函数。 <code>SetUp</code> 类的唯一原因是让我们不必再重申这些成员变量和函数，而这些成员变量和函数在所有这些类中都是必要的。在某种程度上，这里的模板机制只是提供了一种方法，为一些依赖于外部量的函数提供默认的实现，因此不能使用正常的虚拟函数来提供，至少在没有模板的帮助下不能。

// 然而，可能有很好的理由来实际实现从 <code>Data::SetUpBase</code> 派生的类，例如，如果解或右手边的类需要带参数的构造函数，而 <code>Data::SetUpBase</code> 类无法提供。在这种情况下，子类化是一个值得考虑的策略。对于特殊情况的其他可能性是，从 <code>Data::SetUp@<SomeSetUp@></code> 派生，其中 <code>SomeSetUp</code> 表示一个类，或者甚至明确地专门化 <code>Data::SetUp@<SomeSetUp@></code>  。后者允许透明地使用 <code>SetUp</code> 类用于其他设置的方式，但对特殊参数采取特殊行动。

// 赞成这里采取的方法的最后一个意见是：我们无数次发现，当开始一个项目时，参数的数量（通常是边界值，右侧，粗略的网格，就像这里）很小，测试案例的数量也很小。然后，人们一开始就把它们手工编码成一些 <code>switch</code> 的语句。随着时间的推移，项目的增长，测试用例的数量也在增长。 <code>switch</code> 语句的数量也随之增长，它们的长度也是如此，人们开始想办法考虑不可能的例子，其中域、边界值和右手边不再适合在一起，并且开始失去对整个结构的概述。事实证明，把属于某个测试用例的所有东西都封装到一个自己的结构中是值得的，因为它把属于一个测试用例的所有东西都放在一个地方。此外，它允许把这些东西都放在一个或多个文件中，这些文件只用于测试用例和它们的数据，而不需要把它们的实际实现与程序的其他部分联系起来。

//  @sect3{Dual functionals}  

// 和程序的其他部分一样，我们把所有需要描述对偶函数的东西放到一个自己的命名空间中，并定义一个抽象的基类，提供解决对偶问题的类在工作中需要的接口。

// 然后，我们将实现两个这样的类，用于评估一个点的值和该点的解的导数。对于这些函数，我们已经有了相应的评估对象，所以它们是互补的。

  namespace DualFunctional 
  { 
// @sect4{The DualFunctionalBase class}  

// 首先从对偶函数的基类开始。因为对于线性问题来说，对偶问题的特征只在右手边起作用，所以我们只需要提供一个函数来组装给定离散化的右手边。

    template <int dim> 
    class DualFunctionalBase : public Subscriptor 
    { 
    public: 
      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler, 
                                Vector<double> &       rhs) const = 0; 
    }; 
// @sect4{The dual functional PointValueEvaluation class}  

// 作为第一个应用，我们考虑对应于在一个给定的点上评估解决方案的值的函数，我们再次假设该点为一个顶点。除了接受和存储评估点的构造函数之外，这个类只包括实现组装右手边的函数。

    template <int dim> 
    class PointValueEvaluation : public DualFunctionalBase<dim> 
    { 
    public: 
      PointValueEvaluation(const Point<dim> &evaluation_point); 

      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler, 
                                Vector<double> &       rhs) const override; 

      DeclException1( 
        ExcEvaluationPointNotFound, 
        Point<dim>, 
        << "The evaluation point " << arg1 
        << " was not found among the vertices of the present grid."); 

    protected: 
      const Point<dim> evaluation_point; 
    }; 

    template <int dim> 
    PointValueEvaluation<dim>::PointValueEvaluation( 
      const Point<dim> &evaluation_point) 
      : evaluation_point(evaluation_point) 
    {} 

// 至于做这门课的主要目的，组装右手边，让我们首先考虑什么是必要的。对偶问题的右手边是一个值的向量J(phi_i)，其中J是误差函数，phi_i是第i个形状函数。这里，J是在点x0处的评价，即J(phi_i)=phi_i(x0)。

// 现在，我们已经假定评价点是一个顶点。因此，对于我们在这个程序中可能使用的通常的有限元来说，我们可以想当然地认为在这样一个点上正好有一个形状函数是不为零的，特别是其值为1。因此，我们将右手边的向量设置为全零，然后寻找与该点相关的形状函数，并将右手边向量的相应值设置为1。

    template <int dim> 
    void 
    PointValueEvaluation<dim>::assemble_rhs(const DoFHandler<dim> &dof_handler, 
                                            Vector<double> &       rhs) const 
    { 

// 所以，首先把所有东西都设为零......

      rhs.reinit(dof_handler.n_dofs()); 

// ...然后在单元格上循环，在顶点中找到评估点（或者非常接近顶点，由于浮点舍入，可能会出现这种情况）。

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        for (const auto vertex : cell->vertex_indices()) 
          if (cell->vertex(vertex).distance(evaluation_point) < 
              cell->diameter() * 1e-8) 
            { 

// 好的，找到了，所以设置相应的条目，然后离开函数，因为我们已经完成了。

              rhs(cell->vertex_dof_index(vertex, 0)) = 1; 
              return; 
            } 

// 最后，一个理智的检查：如果我们以某种方式来到这里，那么我们一定是错过了评估点，所以无条件地引发一个异常。

      AssertThrow(false, ExcEvaluationPointNotFound(evaluation_point)); 
    } 
// @sect4{The dual functional PointXDerivativeEvaluation class}  

// 作为第二个应用，我们再次考虑在一个点上对解决方案的x导数进行评估。同样，这个类的声明和它的构造函数的实现也不是太有趣。

    template <int dim> 
    class PointXDerivativeEvaluation : public DualFunctionalBase<dim> 
    { 
    public: 
      PointXDerivativeEvaluation(const Point<dim> &evaluation_point); 

      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler, 
                                Vector<double> &       rhs) const; 

      DeclException1( 
        ExcEvaluationPointNotFound, 
        Point<dim>, 
        << "The evaluation point " << arg1 
        << " was not found among the vertices of the present grid."); 

    protected: 
      const Point<dim> evaluation_point; 
    }; 

    template <int dim> 
    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation( 
      const Point<dim> &evaluation_point) 
      : evaluation_point(evaluation_point) 
    {} 

//有趣的是这个函数的实现：这里，J(phi_i)=d/dx phi_i(x0)。

// 我们可以像实现各自的评价对象那样，在这个评价点上取每个形状函数phi_i的梯度的平均值。然而，我们采取了一个略微不同的方法：我们简单地取该点周围所有单元格的平均值。哪些单元 <code>surrounds</code> 是评估点，这个问题取决于网格宽度，包括那些单元的中点到评估点的距离小于单元的直径的单元。

// 在这些单元的面积/体积上取梯度的平均值，可以得到一个与梯度的点评估非常接近的对偶解。从理论上讲，这并没有明显改变方法，这一点很简单。

    template <int dim> 
    void PointXDerivativeEvaluation<dim>::assemble_rhs( 
      const DoFHandler<dim> &dof_handler, 
      Vector<double> &       rhs) const 
    { 

// 同样，首先将所有条目设置为零。

      rhs.reinit(dof_handler.n_dofs()); 

// 用正交公式初始化一个 <code>FEValues</code> 对象，有正交点数量和形状函数的缩写......

      QGauss<dim>        quadrature(dof_handler.get_fe().degree + 1); 
      FEValues<dim>      fe_values(dof_handler.get_fe(), 
                              quadrature, 
                              update_gradients | update_quadrature_points | 
                                update_JxW_values); 
      const unsigned int n_q_points    = fe_values.n_quadrature_points; 
      const unsigned int dofs_per_cell = dof_handler.get_fe().dofs_per_cell; 

// ...并有两个对象用于存储单元上自由度的全局指数，以及正交点上形状函数的梯度值。

      Vector<double>            cell_rhs(dofs_per_cell); 
      std::vector<unsigned int> local_dof_indices(dofs_per_cell); 

// 最后有一个变量，我们将通过对这些单元上的单位函数进行积分，总结出这些单元的面积/体积。

      double total_volume = 0; 

// 然后在所有单元上开始循环，并选择那些与评估点足够接近的单元。

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        if (cell->center().distance(evaluation_point) <= cell->diameter()) 
          { 

// 如果我们找到了这样的单元，那么就初始化 <code>FEValues</code> 对象，并整合每个形状函数梯度的x分量，以及总面积/体积的单位函数。

            fe_values.reinit(cell); 
            cell_rhs = 0; 

            for (unsigned int q = 0; q < n_q_points; ++q) 
              { 
                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  cell_rhs(i) += 
                    fe_values.shape_grad(i, q)[0] // (d/dx phi_i(x_q)) 
                    * fe_values.JxW(q);           // * dx 
                total_volume += fe_values.JxW(q); 
              } 

// 如果我们有本地的贡献，把它们分配到全局矢量。

            cell->get_dof_indices(local_dof_indices); 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              rhs(local_dof_indices[i]) += cell_rhs(i); 
          } 

// 在我们循环了所有的单元格之后，检查我们是否找到了任何单元格，确保其体积不为零。如果不是，那么结果将是错误的，因为这时的右边应该仍然是零，所以抛出一个异常。

      AssertThrow(total_volume > 0, 
                  ExcEvaluationPointNotFound(evaluation_point)); 

// 最后，我们现在只整合了形状函数的梯度，而没有取其平均值。我们通过除以我们所积分的体积的大小来解决这个问题。

      rhs /= total_volume; 
    } 

  } // namespace DualFunctional 
// @sect3{Extending the LaplaceSolver namespace}  
  namespace LaplaceSolver 
  { 
// @sect4{The DualSolver class}  

// 与上面的  <code>PrimalSolver</code>  类相同，我们现在实现一个  <code>DualSolver</code>  。它具有所有相同的特征，唯一的区别是它不接受一个表示右侧对象的函数对象，而现在接受一个 <code>DualFunctionalBase</code> 对象，它将集合对偶问题的右侧向量。这个类的其余部分是相当琐碎的。

// 由于原始求解器和对偶求解器将使用相同的三角形，但是不同的离散化，现在很清楚为什么我们将 <code>Base</code> 类变成了虚拟类：因为最终类将从 <code>PrimalSolver</code> 以及 <code>DualSolver</code>, it would have two <code>Base</code> 实例中派生，我们是不是应该将继承标记为虚拟。因为在许多应用中，基类会存储更多的信息，而不仅仅是需要在原始求解器和对偶求解器之间共享的三角形，所以我们通常不希望使用两个这样的基类。

    template <int dim> 
    class DualSolver : public Solver<dim> 
    { 
    public: 
      DualSolver( 
        Triangulation<dim> &                           triangulation, 
        const FiniteElement<dim> &                     fe, 
        const Quadrature<dim> &                        quadrature, 
        const Quadrature<dim - 1> &                    face_quadrature, 
        const DualFunctional::DualFunctionalBase<dim> &dual_functional); 

    protected: 
      const SmartPointer<const DualFunctional::DualFunctionalBase<dim>> 
                   dual_functional; 
      virtual void assemble_rhs(Vector<double> &rhs) const override; 

      static const Functions::ZeroFunction<dim> boundary_values; 
    }; 

    template <int dim> 
    const Functions::ZeroFunction<dim> DualSolver<dim>::boundary_values; 

    template <int dim> 
    DualSolver<dim>::DualSolver( 
      Triangulation<dim> &                           triangulation, 
      const FiniteElement<dim> &                     fe, 
      const Quadrature<dim> &                        quadrature, 
      const Quadrature<dim - 1> &                    face_quadrature, 
      const DualFunctional::DualFunctionalBase<dim> &dual_functional) 
      : Base<dim>(triangulation) 
      , Solver<dim>(triangulation, 
                    fe, 
                    quadrature, 
                    face_quadrature, 
                    boundary_values) 
      , dual_functional(&dual_functional) 
    {} 

    template <int dim> 
    void DualSolver<dim>::assemble_rhs(Vector<double> &rhs) const 
    { 
      dual_functional->assemble_rhs(this->dof_handler, rhs); 
    } 
// @sect4{The WeightedResidual class}  

// 这里终于出现了这个程序的主类，也就是实现双重加权残差估计器的类。它连接了原始和对偶求解器类，用于计算原始和对偶解，并实现了误差表示公式，用于误差估计和网格细化。

// 该类的前几个函数大多是对基类各自函数的覆盖。

    template <int dim> 
    class WeightedResidual : public PrimalSolver<dim>, public DualSolver<dim> 
    { 
    public: 
      WeightedResidual( 
        Triangulation<dim> &                           coarse_grid, 
        const FiniteElement<dim> &                     primal_fe, 
        const FiniteElement<dim> &                     dual_fe, 
        const Quadrature<dim> &                        quadrature, 
        const Quadrature<dim - 1> &                    face_quadrature, 
        const Function<dim> &                          rhs_function, 
        const Function<dim> &                          boundary_values, 
        const DualFunctional::DualFunctionalBase<dim> &dual_functional); 

      virtual void solve_problem() override; 

      virtual void postprocess( 
        const Evaluation::EvaluationBase<dim> &postprocessor) const override; 

      virtual unsigned int n_dofs() const override; 

      virtual void refine_grid() override; 

      virtual void output_solution() const override; 

    private: 

// 在私有部分，我们有两个函数，用来调用原始类和双基类的 <code>solve_problem</code> 函数。这两个函数将被本类的 <code>solve_problem</code> 函数所平行调用。

      void solve_primal_problem(); 
      void solve_dual_problem(); 

// 然后声明活动单元迭代器的缩写，以避免我们不得不重复写这个冗长的名字。

      using active_cell_iterator = 
        typename DoFHandler<dim>::active_cell_iterator; 

// 接下来，声明一个数据类型，我们将用它来存储面对误差估计器的贡献。我们的想法是，我们可以计算从两个单元格中的每一个到这个面的脸部条款，因为从两边看时它们是一样的。我们要做的是，根据下面解释的一些规则，只计算一次，由相邻的两个单元负责计算。然后，我们将每个面的贡献存储在一个映射面与它们的值的地图中，并通过第二次在单元格上循环并从地图上抓取值来收集每个单元格的贡献。

// 这个地图的数据类型在此声明。

      using FaceIntegrals = 
        typename std::map<typename DoFHandler<dim>::face_iterator, double>; 

// 在计算单元和面的误差估计时，我们需要一些辅助对象，例如 <code>FEValues</code> 和 <code>FEFaceValues</code> 函数，但也需要一些临时对象来存储原始和对偶解的值和梯度，例如。这些字段在三个函数中都是需要的，这些函数分别在单元格、规则面和不规则面上做积分。

// 有三种合理的方式来提供这些字段：第一，作为需要它们的函数中的局部变量；第二，作为本类的成员变量；第三，作为参数传递给该函数。

// 这三种方式都有缺点：第三种是它们的数量不可忽略，会使调用这些函数成为一项漫长的事业。第二种方法的缺点是不允许并行化，因为计算错误估计值的线程必须各自拥有这些变量的副本，所以包围类的成员变量将不起作用。第一种方法虽然直接，但有一个微妙但重要的缺点：我们会反复调用这些函数，也许是成千上万次；现在证明，从堆中分配向量和其他需要内存的对象在运行时间上是很昂贵的，因为当涉及到几个线程时，内存分配很昂贵。因此，只分配一次内存，并尽可能频繁地回收这些对象是明显更好的做法。

// 该怎么做呢？我们的答案是使用第三种策略的一个变种。事实上，这正是WorkStream概念所要做的（我们已经在上面介绍了它，但也可以参见 @ref threads ）。为了避免我们必须给这些函数十几个参数，我们将所有这些变量打包成两个结构，一个用于单元格的计算，另一个用于面的计算。然后，这两个结构被加入到WeightedResidualScratchData类中，该类将作为WorkStream概念的 "划痕数据 "类。

      struct CellData 
      { 
        FEValues<dim>                           fe_values; 
        const SmartPointer<const Function<dim>> right_hand_side; 

        std::vector<double> cell_residual; 
        std::vector<double> rhs_values; 
        std::vector<double> dual_weights; 
        std::vector<double> cell_laplacians; 
        CellData(const FiniteElement<dim> &fe, 
                 const Quadrature<dim> &   quadrature, 
                 const Function<dim> &     right_hand_side); 
        CellData(const CellData &cell_data); 
      }; 

      struct FaceData 
      { 
        FEFaceValues<dim>    fe_face_values_cell; 
        FEFaceValues<dim>    fe_face_values_neighbor; 
        FESubfaceValues<dim> fe_subface_values_cell; 

        std::vector<double>                  jump_residual; 
        std::vector<double>                  dual_weights; 
        typename std::vector<Tensor<1, dim>> cell_grads; 
        typename std::vector<Tensor<1, dim>> neighbor_grads;
        FaceData(const FiniteElement<dim> & fe, 
                 const Quadrature<dim - 1> &face_quadrature); 
        FaceData(const FaceData &face_data); 
      }; 

      struct WeightedResidualScratchData 
      { 
        WeightedResidualScratchData(
          const FiniteElement<dim> & primal_fe,
          const Quadrature<dim> &    primal_quadrature, 
          const Quadrature<dim - 1> &primal_face_quadrature, 
          const Function<dim> &      rhs_function, 
          const Vector<double> &     primal_solution, 
          const Vector<double> &     dual_weights); 

        WeightedResidualScratchData( 
          const WeightedResidualScratchData &scratch_data); 

        CellData       cell_data; 
        FaceData       face_data; 
        Vector<double> primal_solution;
        Vector<double> dual_weights;
      }; 
// WorkStream::run 一般要有一个从头开始的对象和一个拷贝对象。在这里，由于与我们在 step-9 中讨论梯度的近似计算时类似的原因，我们实际上不需要一个 "拷贝数据 "结构。既然WorkStream坚持要有一个这样的结构，我们就声明一个空的结构，除了存在之外什么都不做。

      struct WeightedResidualCopyData 
      {}; 

// 关于误差估计器的评估，我们有一个驱动函数，使用  WorkStream::run()  在每个单元上调用第二个函数。

      void estimate_error(Vector<float> &error_indicators) const; 

      void estimate_on_one_cell(const active_cell_iterator & cell, 
                                WeightedResidualScratchData &scratch_data, 
                                WeightedResidualCopyData &   copy_data, 
                                Vector<float> &              error_indicators, 
                                FaceIntegrals &face_integrals) const; 

// 然后我们有函数对误差表示公式进行实际积分。它们将分别处理单元格内部、没有悬挂节点的面和有悬挂节点的面的条款。

      void integrate_over_cell(const active_cell_iterator &cell, 
                               const Vector<double> &      primal_solution, 
                               const Vector<double> &      dual_weights, 
                               CellData &                  cell_data, 
                               Vector<float> &error_indicators) const; 

      void integrate_over_regular_face(const active_cell_iterator &cell, 
                                       const unsigned int          face_no, 
                                       const Vector<double> &primal_solution, 
                                       const Vector<double> &dual_weights, 
                                       FaceData &            face_data, 
                                       FaceIntegrals &face_integrals) const;  
      void integrate_over_irregular_face(const active_cell_iterator &cell, 
                                         const unsigned int          face_no, 
                                         const Vector<double> &primal_solution, 
                                         const Vector<double> &dual_weights, 
                                         FaceData &            face_data,  
                                         FaceIntegrals &face_integrals) const; 
    }; 

// 在这个类的实现中，我们首先有 <code>CellData</code> and <code>FaceData</code> 成员类的构造函数，以及 <code>WeightedResidual</code> 构造函数。它们只将字段初始化为正确的长度，所以我们不必过多地讨论它们。

    template <int dim> 
    WeightedResidual<dim>::CellData::CellData( 
      const FiniteElement<dim> &fe, 
      const Quadrature<dim> &   quadrature, 
      const Function<dim> &     right_hand_side) 
      : fe_values(fe, 
                  quadrature, 
                  update_values | update_hessians | update_quadrature_points | 
                    update_JxW_values)  
      , right_hand_side(&right_hand_side) 
      , cell_residual(quadrature.size()) 
      , rhs_values(quadrature.size()) 
      , dual_weights(quadrature.size()) 
      , cell_laplacians(quadrature.size()) 
    {} 

    template <int dim> 
    WeightedResidual<dim>::CellData::CellData(const CellData &cell_data) 
      : fe_values(cell_data.fe_values.get_fe(), 
                  cell_data.fe_values.get_quadrature(), 
                  update_values | update_hessians | update_quadrature_points | 
                    update_JxW_values) 
      , right_hand_side(cell_data.right_hand_side) 
      , cell_residual(cell_data.cell_residual) 
      , rhs_values(cell_data.rhs_values) 
      , dual_weights(cell_data.dual_weights) 
      , cell_laplacians(cell_data.cell_laplacians) 
    {} 

    template <int dim> 
    WeightedResidual<dim>::FaceData::FaceData( 
      const FiniteElement<dim> & fe, 
      const Quadrature<dim - 1> &face_quadrature) 
      : fe_face_values_cell(fe, 
                            face_quadrature, 
                            update_values | update_gradients | 
                              update_JxW_values | update_normal_vectors) 
      , fe_face_values_neighbor(fe, 
                                face_quadrature, 
                                update_values | update_gradients | 
                                  update_JxW_values | update_normal_vectors) 
      , fe_subface_values_cell(fe, face_quadrature, update_gradients) 
    { 
      const unsigned int n_face_q_points = face_quadrature.size(); 

      jump_residual.resize(n_face_q_points); 
      dual_weights.resize(n_face_q_points); 
      cell_grads.resize(n_face_q_points); 
      neighbor_grads.resize(n_face_q_points); 
    } 

    template <int dim> 
    WeightedResidual<dim>::FaceData::FaceData(const FaceData &face_data) 
      : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(), 
                            face_data.fe_face_values_cell.get_quadrature(), 
                            update_values | update_gradients | 
                              update_JxW_values | update_normal_vectors) 
      , fe_face_values_neighbor( 
          face_data.fe_face_values_neighbor.get_fe(), 
          face_data.fe_face_values_neighbor.get_quadrature(), 
          update_values | update_gradients | update_JxW_values | 
            update_normal_vectors) 
      , fe_subface_values_cell( 
          face_data.fe_subface_values_cell.get_fe(), 
          face_data.fe_subface_values_cell.get_quadrature(), 
          update_gradients)  
      , jump_residual(face_data.jump_residual) 
      , dual_weights(face_data.dual_weights) 
      , cell_grads(face_data.cell_grads) 
      , neighbor_grads(face_data.neighbor_grads) 
    {} 

    template <int dim> 
    WeightedResidual<dim>::WeightedResidualScratchData::  
      WeightedResidualScratchData( 
        const FiniteElement<dim> & primal_fe, 
        const Quadrature<dim> &    primal_quadrature, 
        const Quadrature<dim - 1> &primal_face_quadrature, 
        const Function<dim> &      rhs_function, 
        const Vector<double> &     primal_solution, 
        const Vector<double> &     dual_weights) 
      : cell_data(primal_fe, primal_quadrature, rhs_function) 
      , face_data(primal_fe, primal_face_quadrature) 
      , primal_solution(primal_solution) 
      , dual_weights(dual_weights) 
    {} 

    template <int dim> 
    WeightedResidual<dim>::WeightedResidualScratchData:: 
      WeightedResidualScratchData( 
        const WeightedResidualScratchData &scratch_data) 
      : cell_data(scratch_data.cell_data) 
      , face_data(scratch_data.face_data) 
      , primal_solution(scratch_data.primal_solution) 
      , dual_weights(scratch_data.dual_weights) 
    {} 

    template <int dim> 
    WeightedResidual<dim>::WeightedResidual( 
      Triangulation<dim> &                           coarse_grid, 
      const FiniteElement<dim> &                     primal_fe, 
      const FiniteElement<dim> &                     dual_fe, 
      const Quadrature<dim> &                        quadrature, 
      const Quadrature<dim - 1> &                    face_quadrature,  
      const Function<dim> &                          rhs_function, 
      const Function<dim> &                          bv, 
      const DualFunctional::DualFunctionalBase<dim> &dual_functional) 
      : Base<dim>(coarse_grid) 
      , PrimalSolver<dim>(coarse_grid, 
                          primal_fe, 
                          quadrature, 
                          face_quadrature, 
                          rhs_function, 
                          bv) 
      , DualSolver<dim>(coarse_grid, 
                        dual_fe, 
                        quadrature, 
                        face_quadrature, 
                        dual_functional) 
    {} 

// 接下来的五个函数很无聊，因为它们只是简单地将它们的工作传递给基类。第一个函数并行地调用原始和对偶求解器，而解的后处理和检索自由度的数量则由原始类完成。

    template <int dim> 
    void WeightedResidual<dim>::solve_problem() 
    { 
      Threads::TaskGroup<void> tasks; 
      tasks += 
        Threads::new_task(&WeightedResidual<dim>::solve_primal_problem, *this); 
      tasks += 
        Threads::new_task(&WeightedResidual<dim>::solve_dual_problem, *this); 
      tasks.join_all(); 
    } 

    template <int dim> 
    void WeightedResidual<dim>::solve_primal_problem() 
    { 
      PrimalSolver<dim>::solve_problem(); 
    } 

    template <int dim> 
    void WeightedResidual<dim>::solve_dual_problem() 
    { 
      DualSolver<dim>::solve_problem(); 
    } 

    template <int dim> 
    void WeightedResidual<dim>::postprocess( 
      const Evaluation::EvaluationBase<dim> &postprocessor) const 
    { 
      PrimalSolver<dim>::postprocess(postprocessor); 
    } 

    template <int dim> 
    unsigned int WeightedResidual<dim>::n_dofs() const 
    { 
      return PrimalSolver<dim>::n_dofs(); 
    } 

// 现在，变得更加有趣了： <code>refine_grid()</code> 函数要求误差估计器计算单元格的误差指标，然后使用其绝对值进行网格细化。

    template <int dim> 
    void WeightedResidual<dim>::refine_grid() 
    { 

// 首先调用计算单元格和全局误差的函数。

      Vector<float> error_indicators(this->triangulation->n_active_cells()); 
      estimate_error(error_indicators); 

//然后
//注意，只有当所有的指标都是正数时，标记单元的细化或粗化才会起作用，以便于它们的比较。因此，去掉所有这些指标上的符号。

      for (float &error_indicator : error_indicators) 
        error_indicator = std::fabs(error_indicator); 

// 最后，我们可以选择不同的细化策略。这里默认的是细化那些误差指标最大、占总误差80%的单元格，而我们粗化那些指标最小、占总误差2%的单元格。

      GridRefinement::refine_and_coarsen_fixed_fraction(*this->triangulation, 
                                                        error_indicators, 
                                                        0.8, 
                                                        0.02); 
      this->triangulation->execute_coarsening_and_refinement(); 
    } 

// 由于我们想同时输出原始解和对偶解，我们重载了 <code>output_solution</code> 函数。这个函数唯一有趣的特点是，原始解和对偶解是在不同的有限元空间上定义的，这不是 <code>DataOut</code> 类所期望的格式。因此，我们必须将它们转移到一个共同的有限元空间。由于我们只想从质量上看到这些解，所以我们要争夺将对偶解内插到（较小的）原始空间。对于插值，有一个库函数，它接收一个AffineConstraints对象，包括悬挂节点约束。其余的都是标准的。

    template <int dim> 
    void WeightedResidual<dim>::output_solution() const 
    { 
      AffineConstraints<double> primal_hanging_node_constraints; 
      DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler, 
                                              primal_hanging_node_constraints); 
      primal_hanging_node_constraints.close(); 
      Vector<double> dual_solution(PrimalSolver<dim>::dof_handler.n_dofs()); 
      FETools::interpolate(DualSolver<dim>::dof_handler, 
                           DualSolver<dim>::solution, 
                           PrimalSolver<dim>::dof_handler, 
                           primal_hanging_node_constraints, 
                           dual_solution); 

      DataOut<dim> data_out; 
      data_out.attach_dof_handler(PrimalSolver<dim>::dof_handler); 

// 添加我们想要输出的数据向量。两个都加上， <code>DataOut</code> 函数可以处理你想写到输出的多少个数据向量。

      data_out.add_data_vector(PrimalSolver<dim>::solution, "primal_solution"); 
      data_out.add_data_vector(dual_solution, "dual_solution"); 

      data_out.build_patches(); 

      std::ofstream out("solution-" + std::to_string(this->refinement_cycle) + 
                        ".vtu"); 
      data_out.write(out, DataOutBase::vtu); 
    } 
// @sect3{Estimating errors}  
// @sect4{Error estimation driver functions}  

// 至于误差估计的实际计算，让我们从驱动这一切的函数开始，即调用那些真正做工作的函数，并最终收集结果。

    template <int dim> 
    void 
    WeightedResidual<dim>::estimate_error(Vector<float> &error_indicators) const 
    { 

// 计算误差的第一个任务是建立向量，表示原始解，以及权重(z-z_h)=(z-I_hz)，两者都在我们已经计算出对偶解的有限元空间。为此，我们必须将原始解内插到对偶有限元空间，并将计算出的对偶解内插到原始有限元空间。幸运的是，库中提供了插值到更大或更小的有限元空间的函数，所以这一点是很明显的。

// 首先，让我们对原始解进行插值：它被逐格插值到我们已经解决了对偶问题的有限元空间中：但是，还是和 <code>WeightedResidual::output_solution</code> 函数一样，我们首先需要创建一个包括悬挂节点约束的AffineConstraints对象，但这次是对偶有限元空间的。

      AffineConstraints<double> dual_hanging_node_constraints; 
      DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler, 
                                              dual_hanging_node_constraints); 
      dual_hanging_node_constraints.close(); 
      Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs()); 
      FETools::interpolate(PrimalSolver<dim>::dof_handler, 
                           PrimalSolver<dim>::solution, 
                           DualSolver<dim>::dof_handler, 
                           dual_hanging_node_constraints, 
                           primal_solution); 
//然后
//为了计算数值逼近的对偶解z插值到原始解的有限元空间并从z中减去：使用 <code>interpolate_difference</code> 函数，在对偶解的元素空间中得到(z-I_hz)。

      AffineConstraints<double> primal_hanging_node_constraints; 
      DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler, 
                                              primal_hanging_node_constraints); 
      primal_hanging_node_constraints.close(); 
      Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs()); 
      FETools::interpolation_difference(DualSolver<dim>::dof_handler, 
                                        dual_hanging_node_constraints, 
                                        DualSolver<dim>::solution, 
                                        PrimalSolver<dim>::dof_handler, 
                                        primal_hanging_node_constraints, 
                                        dual_weights); 

// 请注意，这可能会更有效，因为这些约束条件在之前为原始问题组装矩阵和右手边以及写出对偶解时已经使用过了。我们把这方面的程序优化作为一个练习。

// 在计算了对偶权重之后，我们现在开始计算原始解的单元和面的残差。首先，我们在面的迭代器和它们的面的跳跃项对误差估计器的贡献之间建立一个映射。原因是我们只计算了一次跳跃项，从面的一侧开始，并且希望在第二次循环所有单元时才收集它们。

// 我们已经用一个-1e20的值初始化了这个地图，因为如果出现问题，我们因为某些原因无法计算某个面的值，这个值就会在结果中显示出来。其次，这个初始化已经让 std::map 对象分配了它可能需要的所有对象。这一点很重要，因为我们将从并行线程写进这个结构，如果地图需要分配内存，从而重塑其数据结构，那么这样做就不是线程安全的。换句话说，初始化使我们不必在线程每次写入（和修改）该地图的结构时通过互斥来同步。

      FaceIntegrals face_integrals; 
      for (const auto &cell : 
           DualSolver<dim>::dof_handler.active_cell_iterators()) 
        for (const auto &face : cell->face_iterators()) 
          face_integrals[face] = -1e20; 

      auto worker = [this, 
                     &error_indicators, 
                     &face_integrals](const active_cell_iterator & cell, 
                                      WeightedResidualScratchData &scratch_data, 
                                      WeightedResidualCopyData &   copy_data) { 
        this->estimate_on_one_cell( 
          cell, scratch_data, copy_data, error_indicators, face_integrals); 
      }; 

      auto do_nothing_copier = 
        std::function<void(const WeightedResidualCopyData &)>(); 

// 然后将其全部交给 WorkStream::run() ，以并行计算所有单元的估计器。

      WorkStream::run( 
        DualSolver<dim>::dof_handler.begin_active(), 
        DualSolver<dim>::dof_handler.end(), 
        worker, 
        do_nothing_copier, 
        WeightedResidualScratchData(*DualSolver<dim>::fe, 
                                    *DualSolver<dim>::quadrature, 
                                    *DualSolver<dim>::face_quadrature, 
                                    *this->rhs_function, 
                                    primal_solution, 
                                    dual_weights), 
        WeightedResidualCopyData()); 

// 一旦计算出误差贡献，就把它们加起来。为此，请注意，单元格项已经设置好了，只有边缘项需要收集。因此，在所有单元格和它们的面中循环，确保每个面的贡献都在那里，然后把它们加起来。只需要减去一半的跳跃项，因为另一半将被邻近的单元格拿走。

      unsigned int present_cell = 0; 
      for (const auto &cell : 
           DualSolver<dim>::dof_handler.active_cell_iterators()) 
        { 
          for (const auto &face : cell->face_iterators()) 
            { 
              Assert(face_integrals.find(face) != face_integrals.end(), 
                     ExcInternalError()); 
              error_indicators(present_cell) -= 0.5 * face_integrals[face]; 
            } 
          ++present_cell; 
        } 
      std::cout << "   Estimated error=" 
                << std::accumulate(error_indicators.begin(), 
                                   error_indicators.end(), 
                                   0.) 
                << std::endl; 
    } 
// @sect4{Estimating on a single cell}  

// 接下来我们有一个函数，它被调用来估计单个单元的误差。如果库被配置为使用多线程，该函数可能被多次调用。下面是它的内容。

    template <int dim> 
    void WeightedResidual<dim>::estimate_on_one_cell( 
      const active_cell_iterator & cell, 
      WeightedResidualScratchData &scratch_data, 
      WeightedResidualCopyData &   copy_data, 
      Vector<float> &              error_indicators, 
      FaceIntegrals &              face_integrals) const 
    { 

// 由于WorkStream的原因， estimate_on_one_cell需要一个CopyData对象，即使它没有被使用。下一行将对这个未使用的变量发出警告。

      (void)copy_data; 

// 每个单元的第一个任务是计算这个单元的剩余贡献，并把它们放入  <code>error_indicators</code>  变量中。

      integrate_over_cell(cell, 
                          scratch_data.primal_solution, 
                          scratch_data.dual_weights, 
                          scratch_data.cell_data, 
                          error_indicators); 

// 计算完单元格条款后，转向面条款。为此，在当前单元格的所有面中进行循环，看看是否需要对其进行计算。

      for (const auto face_no : cell->face_indices()) 
        { 

// 首先，如果这个面是边界的一部分，那么就没有什么可做的。然而，为了在汇总单元格的面的贡献时使事情变得简单，我们把这个面输入对误差贡献为零的面的列表中。

          if (cell->face(face_no)->at_boundary()) 
            { 
              face_integrals[cell->face(face_no)] = 0; 
              continue; 
            } 

// 接下来，请注意，由于我们想在每个面上只计算一次跳跃项，尽管我们访问它两次（如果它不在边界），我们必须定义一些规则，由谁负责在一个面上计算。

// 首先，如果相邻的单元格与这个单元格处于同一层次，也就是说，既不进一步细化，也不进一步粗化，那么这个层次中索引较低的单元格就负责计算。换句话说：如果另一个单元的索引更低，那么就跳过这个面的工作。

          if ((cell->neighbor(face_no)->has_children() == false) && 
              (cell->neighbor(face_no)->level() == cell->level()) && 
              (cell->neighbor(face_no)->index() < cell->index())) 
            continue; 

// 同样地，如果这个单元和它的邻居在细化程度上有差异，我们总是从较粗的单元开始工作。因此，如果相邻的单元比现在的单元细化程度低，那么就什么都不做，因为我们在访问粗略的单元时对子面进行整合。

          if (cell->at_boundary(face_no) == false) 
            if (cell->neighbor(face_no)->level() < cell->level()) 
              continue; 

// 现在我们知道，我们在这里负责，所以实际上是在计算面的跳跃项。如果这个面是一个规则的面，即另一边的单元格既不比这个单元格粗也不比这个单元格细，那么就调用一个函数，如果另一边的单元格进一步细化，那么就用另一个函数。请注意，另一边的单元格更粗的情况不可能发生，因为我们上面已经决定，当我们传递到另一个单元格时，我们会处理这种情况。

          if (cell->face(face_no)->has_children() == false) 
            integrate_over_regular_face(cell, 
                                        face_no, 
                                        scratch_data.primal_solution, 
                                        scratch_data.dual_weights, 
                                        scratch_data.face_data, 
                                        face_integrals); 
          else 
            integrate_over_irregular_face(cell, 
                                          face_no, 
                                          scratch_data.primal_solution, 
                                          scratch_data.dual_weights, 
                                          scratch_data.face_data, 
                                          face_integrals); 
        } 
    } 
// @sect4{Computing cell term error contributions}  

// 关于误差贡献的实际计算，首先转向单元条款。

    template <int dim> 
    void WeightedResidual<dim>::integrate_over_cell( 
      const active_cell_iterator &cell, 
      const Vector<double> &      primal_solution, 
      const Vector<double> &      dual_weights, 
      CellData &                  cell_data, 
      Vector<float> &             error_indicators) const 
    { 

// 需要完成的任务是通过观察误差估计公式看起来很自然的事情：首先在正交点得到单元残差的数值解的右手边和拉普拉斯。

      cell_data.fe_values.reinit(cell); 
      cell_data.right_hand_side->value_list( 
        cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values); 
      cell_data.fe_values.get_function_laplacians(primal_solution, 
                                                  cell_data.cell_laplacians); 

// ...然后得到双重权重...

      cell_data.fe_values.get_function_values(dual_weights, 
                                              cell_data.dual_weights); 

// ...最后建立所有正交点的总和，并将其存储在当前单元格中。

      double sum = 0; 
      for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p) 
        sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) * 
                cell_data.dual_weights[p] * cell_data.fe_values.JxW(p)); 
      error_indicators(cell->active_cell_index()) += sum; 
    } 
// @sect4{Computing edge term error contributions -- 1}  

// 另一方面，误差估计的边缘项的计算并不那么简单。首先，我们必须区分有悬挂节点和无悬挂节点的面。因为这是一种简单的情况，我们首先考虑一个面上没有悬挂节点的情况（我们称之为 "常规 "情况）。

    template <int dim> 
    void WeightedResidual<dim>::integrate_over_regular_face( 
      const active_cell_iterator &cell, 
      const unsigned int          face_no, 
      const Vector<double> &      primal_solution, 
      const Vector<double> &      dual_weights, 
      FaceData &                  face_data, 
      FaceIntegrals &             face_integrals) const 
    { 
      const unsigned int n_q_points = 
        face_data.fe_face_values_cell.n_quadrature_points; 

// 第一步是获取本单元上有限元场的正交点的梯度值。为此，初始化 <code>FEFaceValues</code> 对象，对应于面的这一侧，并使用该对象提取梯度。

      face_data.fe_face_values_cell.reinit(cell, face_no); 
      face_data.fe_face_values_cell.get_function_gradients( 
        primal_solution, face_data.cell_grads); 

// 第二步是提取面的另一侧正交点上的有限元解的梯度，即从相邻单元提取。

// 为此，在之前做一个理智的检查：确保邻居确实存在（是的，如果邻居不存在，我们就不应该来这里，但是在复杂的软件中会有bug，所以最好检查一下），如果不是这样，就扔一个错误。

      Assert(cell->neighbor(face_no).state() == IteratorState::valid, 
             ExcInternalError()); 

// 如果我们有了这个，那么我们需要找出相邻单元格的哪个面，也就是说， <code>how-many'th</code> 这个单元格是这个面后面的单元格的相邻面。为此，有一个函数，我们将结果放入一个变量，名称为 <code>neighbor_neighbor</code>  。

      const unsigned int neighbor_neighbor = 
        cell->neighbor_of_neighbor(face_no); 

// 然后定义一个邻近单元的缩写，在该单元上初始化 <code>FEFaceValues</code> 对象，并提取该单元上的梯度。

      const active_cell_iterator neighbor = cell->neighbor(face_no); 
      face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor); 
      face_data.fe_face_values_neighbor.get_function_gradients( 
        primal_solution, face_data.neighbor_grads); 

// 现在我们有了这个单元和邻近单元的梯度，通过将梯度的跳跃与法向量相乘来计算跳跃残差。

      for (unsigned int p = 0; p < n_q_points; ++p) 
        face_data.jump_residual[p] = 
          ((face_data.cell_grads[p] - face_data.neighbor_grads[p]) * 
           face_data.fe_face_values_cell.normal_vector(p)); 

// 接下来得到这个面的双重权重。

      face_data.fe_face_values_cell.get_function_values(dual_weights, 
                                                        face_data.dual_weights); 

// 最后，我们要计算跳跃残差、对偶权重和正交权重的总和，以得到这个面的结果。

      double face_integral = 0; 
      for (unsigned int p = 0; p < n_q_points; ++p) 
        face_integral += 
          (face_data.jump_residual[p] * face_data.dual_weights[p] * 
           face_data.fe_face_values_cell.JxW(p)); 

// 仔细检查该元素是否已经存在，是否已经被写入...

      Assert(face_integrals.find(cell->face(face_no)) != face_integrals.end(), 
             ExcInternalError()); 
      Assert(face_integrals[cell->face(face_no)] == -1e20, ExcInternalError()); 

// ...然后在指定的位置存储计算值。注意，存储的值不包含错误表示中出现的因子1/2。原因是，如果我们在三角形的所有面上进行循环，这个项实际上没有这个因子，但只有当我们把它写成所有单元和每个单元的所有面的总和时才会出现；因此我们两次访问同一个面。我们稍后在对每个单元的贡献进行单独求和时，会使用这个因子-1/2来考虑这个问题。

      face_integrals[cell->face(face_no)] = face_integral; 
    } 
// @sect4{Computing edge term error contributions -- 2}  

// 我们仍然缺少有悬挂节点的面的情况。这就是这个函数中所涉及的内容。

    template <int dim> 
    void WeightedResidual<dim>::integrate_over_irregular_face( 
      const active_cell_iterator &cell, 
      const unsigned int          face_no, 
      const Vector<double> &      primal_solution, 
      const Vector<double> &      dual_weights, 
      FaceData &                  face_data, 
      FaceIntegrals &             face_integrals) const 
    { 

// 首先还是两个缩写，以及一些一致性检查，以确定该函数是否只在它应该被调用的面上被调用。

      const unsigned int n_q_points = 
        face_data.fe_face_values_cell.n_quadrature_points; 

      const typename DoFHandler<dim>::face_iterator face = cell->face(face_no); 
      const typename DoFHandler<dim>::cell_iterator neighbor = 
        cell->neighbor(face_no); 
      Assert(neighbor.state() == IteratorState::valid, ExcInternalError()); 
      Assert(neighbor->has_children(), ExcInternalError()); 
      (void)neighbor; 

// 然后找出当前单元格是相邻单元格的哪个邻居。请注意，我们将对这个相邻单元的子女进行操作，但他们的方向与他们的母亲相同，也就是说，邻居的方向是一样的。

      const unsigned int neighbor_neighbor = 
        cell->neighbor_of_neighbor(face_no); 

// 然后简单地对所有的子面做我们在前面的函数中对一个面所做的一切。

      for (unsigned int subface_no = 0; subface_no < face->n_children(); 
           ++subface_no) 
        { 

// 再从一些检查开始：得到一个指向当前子面后面的单元格的迭代器，并检查其面是否是我们正在考虑的子面。如果不是这样，那么要么是上面调用的 <code>neighbor_neighbor</code> 函数存在错误，要么--更糟糕的是--库中的某些函数没有遵守关于单元格、它们的子面的一些基本假设。在任何情况下，即使这个断言不应该被触发，谨慎一点也无妨，而且在优化模式的计算中，这个断言无论如何都会被删除。

          const active_cell_iterator neighbor_child = 
            cell->neighbor_child_on_subface(face_no, subface_no); 
          Assert(neighbor_child->face(neighbor_neighbor) == 
                   cell->face(face_no)->child(subface_no), 
                 ExcInternalError()); 

// 现在开始工作，首先在界面的这一侧再次得到解决方案的梯度。

          face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no); 
          face_data.fe_subface_values_cell.get_function_gradients( 
            primal_solution, face_data.cell_grads); 

// 然后在另一边。

          face_data.fe_face_values_neighbor.reinit(neighbor_child, 
                                                   neighbor_neighbor); 
          face_data.fe_face_values_neighbor.get_function_gradients( 
            primal_solution, face_data.neighbor_grads); 

//最后建立跳跃残差。因为这次我们从另一个单元格中取法向量，所以与其他函数相比，将第一项的符号还原。

          for (unsigned int p = 0; p < n_q_points; ++p) 
            face_data.jump_residual[p] = 
              ((face_data.neighbor_grads[p] - face_data.cell_grads[p]) * 
               face_data.fe_face_values_neighbor.normal_vector(p)); 

// 然后得到双重权重。

          face_data.fe_face_values_neighbor.get_function_values( 
            dual_weights, face_data.dual_weights); 

// 最后，总结这个子面的贡献，并将其设置在全局图中。

          double face_integral = 0; 
          for (unsigned int p = 0; p < n_q_points; ++p) 
            face_integral += 
              (face_data.jump_residual[p] * face_data.dual_weights[p] * 
               face_data.fe_face_values_neighbor.JxW(p)); 
          face_integrals[neighbor_child->face(neighbor_neighbor)] = 
            face_integral; 
        } 

// 一旦所有子面的贡献被计算出来，循环收集所有子面，并将其与母面一起存储，以便以后收集单元格的误差项时简单使用。再次进行安全检查，确保子面的条目已经被计算出来，并且不带有无效的值。

      double sum = 0; 
      for (unsigned int subface_no = 0; subface_no < face->n_children(); 
           ++subface_no) 
        { 
          Assert(face_integrals.find(face->child(subface_no)) != 
                   face_integrals.end(), 
                 ExcInternalError());  
          Assert(face_integrals[face->child(subface_no)] != -1e20, 
                 ExcInternalError()); 

          sum += face_integrals[face->child(subface_no)]; 
        } 

// 最后将该值存储在父脸。

      face_integrals[face] = sum; 
    } 

  } // namespace LaplaceSolver 
// @sect3{A simulation framework}  

// 在前面的例子程序中，我们有两个函数，用来驱动在随后的更细的网格上求解的过程。我们在这里进行了扩展，允许向这些函数传递一些参数，并将这些参数全部放入框架类中。

// 你会注意到这个程序是由许多小部分组成的（评估函数、实现各种细化方法的求解器类、不同的对偶函数、不同的问题和数据描述），这使得程序的扩展相对简单，但也允许通过用一个部分替换另一个部分来解决大量的不同问题。我们通过在下面的框架类中声明一个结构来体现这种灵活性，该结构持有一些参数，可以设置这些参数来测试这个程序的各个部分的组合，可以用简单的方式在各种问题和离散度上进行测试。

  template <int dim> 
  struct Framework 
  { 
  public: 

// 首先，我们声明两个缩写，以便简单使用各自的数据类型。

    using Evaluator     = Evaluation::EvaluationBase<dim>; 
    using EvaluatorList = std::list<Evaluator *>; 

// 然后我们有一个结构，它声明了所有可能被设置的参数。在该结构的默认构造函数中，这些值都被设置为默认值，以便简单使用。

    struct ProblemDescription 
    { 

// 首先允许原始和对偶问题离散化的片状多项式的度数。对于原始问题，它们默认为（双，三）线性分解函数，对于对偶问题，默认为（双，三）二次函数。如果选择了一个不需要解决对偶问题的细化准则，对偶有限元度的值当然会被忽略。

      unsigned int primal_fe_degree; 
      unsigned int dual_fe_degree; 

// 然后有一个描述问题类型的对象，即右手边、领域、边界值等。这里需要的指针默认为Null指针，也就是说，你必须在这个对象的实际实例中设置它，才能使它发挥作用。

      std::unique_ptr<const Data::SetUpBase<dim>> data; 

// 由于我们允许使用不同的细化标准（全局细化、通过凯利误差指标细化，可能有一个权重，以及使用双重估计器），定义一些枚举值，并随后定义一个该类型的变量。它将默认为 <code>dual_weighted_error_estimator</code>  。

      enum RefinementCriterion 
      { 
        dual_weighted_error_estimator, 
        global_refinement, 
        kelly_indicator, 
        weighted_kelly_indicator 
      }; 

      RefinementCriterion refinement_criterion; 

// 接下来是一个描述双重函数的对象。只有在选择双重加权残差细化时才需要这个对象，并且默认为一个空指针。

      std::unique_ptr<const DualFunctional::DualFunctionalBase<dim>> 
        dual_functional; 

// 然后是一个评估对象的列表。其默认值为空，即没有评价对象。

      EvaluatorList evaluator_list; 

// 接下来是一个函数，作为 <code>RefinementWeightedKelly</code> 类的权重。这个指针的默认值是零，但是如果你想使用 <code>weighted_kelly_indicator</code> 的细化标准，你必须把它设置成其他的值。

      std::unique_ptr<const Function<dim>> kelly_weight; 

// 最后，我们有一个变量，表示我们允许的（原始）离散化的最大自由度数。如果超过这个数值，我们将停止解算和间歇性网格细化的过程。其默认值为20,000。

      unsigned int max_degrees_of_freedom; 

// 最后是这个类的默认构造函数。

      ProblemDescription(); 
    }; 

// 驱动程序框架类只有一个方法，它断断续续地调用求解器和网格细化，并在中间做一些其他的小任务。由于它除了给它的参数外不需要其他数据，我们把它变成静态的。

    static void run(const ProblemDescription &descriptor); 
  }; 

// 至于实现，首先是参数对象的构造函数，将所有的值设置为默认值。

  template <int dim> 
  Framework<dim>::ProblemDescription::ProblemDescription() 
    : primal_fe_degree(1) 
    , dual_fe_degree(2) 
    , refinement_criterion(dual_weighted_error_estimator) 
    , max_degrees_of_freedom(20000) 
  {} 

// 然后是驱动整个过程的函数。

  template <int dim> 
  void Framework<dim>::run(const ProblemDescription &descriptor) 
  { 

// 首先从给定的数据对象中创建一个三角图。

    Triangulation<dim> triangulation( 
      Triangulation<dim>::smoothing_on_refinement); 
    descriptor.data->create_coarse_grid(triangulation); 

// 然后是一组有限元和适当的正交公式。

    const FE_Q<dim>       primal_fe(descriptor.primal_fe_degree); 
    const FE_Q<dim>       dual_fe(descriptor.dual_fe_degree); 
    const QGauss<dim>     quadrature(descriptor.dual_fe_degree + 1); 
    const QGauss<dim - 1> face_quadrature(descriptor.dual_fe_degree + 1); 

// 接下来，从实现不同细化标准的类中选择一个。

    std::unique_ptr<LaplaceSolver::Base<dim>> solver; 
    switch (descriptor.refinement_criterion) 
      { 
        case ProblemDescription::dual_weighted_error_estimator: 
          { 
            solver = std::make_unique<LaplaceSolver::WeightedResidual<dim>>( 
              triangulation, 
              primal_fe, 
              dual_fe, 
              quadrature, 
              face_quadrature, 
              descriptor.data->get_right_hand_side(), 
              descriptor.data->get_boundary_values(), 
              *descriptor.dual_functional); 
            break; 
          } 

        case ProblemDescription::global_refinement: 
          { 
            solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>( 
              triangulation, 
              primal_fe, 
              quadrature, 
              face_quadrature, 
              descriptor.data->get_right_hand_side(), 
              descriptor.data->get_boundary_values()); 
            break; 
          } 

        case ProblemDescription::kelly_indicator: 
          { 
            solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>( 
              triangulation, 
              primal_fe, 
              quadrature, 
              face_quadrature, 
              descriptor.data->get_right_hand_side(), 
              descriptor.data->get_boundary_values()); 
            break; 
          } 

        case ProblemDescription::weighted_kelly_indicator: 
          { 
            solver = 
              std::make_unique<LaplaceSolver::RefinementWeightedKelly<dim>>( 
                triangulation, 
                primal_fe, 
                quadrature, 
                face_quadrature, 
                descriptor.data->get_right_hand_side(), 
                descriptor.data->get_boundary_values(), 
                *descriptor.kelly_weight); 
            break; 
          } 

        default: 
          AssertThrow(false, ExcInternalError()); 
      } 

// 现在所有对象都到位了，运行主循环。停止的标准在循环的底部实现。

// 在循环中，首先设置新的循环数，然后解决问题，输出它的解，对它应用评估对象，然后决定我们是否要进一步细化网格并在这个网格上再次解决问题，或者跳出循环。

    for (unsigned int step = 0; true; ++step) 
      { 
        std::cout << "Refinement cycle: " << step << std::endl; 

        solver->set_refinement_cycle(step); 
        solver->solve_problem(); 
        solver->output_solution(); 

        std::cout << "   Number of degrees of freedom=" << solver->n_dofs() 
                  << std::endl; 

        for (const auto &evaluator : descriptor.evaluator_list) 
          { 
            evaluator->set_refinement_cycle(step); 
            solver->postprocess(*evaluator); 
          } 

        if (solver->n_dofs() < descriptor.max_degrees_of_freedom) 
          solver->refine_grid(); 
        else 
          break; 
      } 

// 循环运行后清理屏幕。

    std::cout << std::endl; 
  } 

} // namespace Step14 

//  @sect3{The main function}  

// 这里最后是主函数。它通过指定一组用于模拟的参数（多项式度数、评估和对偶函数等）来驱动整个过程，并将它们打包成一个结构传给上面的框架工作类。

int main() 
{ 
  try 
    { 
      using namespace Step14; 

//描述我们要在这里解决的问题，将一个描述符对象传递给做其他工作的函数。

      const unsigned int                 dim = 2; 
      Framework<dim>::ProblemDescription descriptor; 

// 首先设置我们希望使用的细化标准。

      descriptor.refinement_criterion = 
        Framework<dim>::ProblemDescription::dual_weighted_error_estimator; 

// 在这里，我们也可以使用  <code>global_refinement</code>  或  <code>weighted_kelly_indicator</code>  。请注意，所给出的关于对偶有限元、对偶函数等信息只对给定的细化准则选择很重要，否则就会被忽略。

// 然后设置原始问题和对偶问题的多项式程度。我们在这里选择双线性和双二次方的问题。

      descriptor.primal_fe_degree = 1; 
      descriptor.dual_fe_degree   = 2; 

// 然后设置测试案例的描述，即域、边界值和右手边。这些都是预先打包在类中的。我们在这里采用  <code>Exercise_2_3</code>  的描述，但你也可以使用  <code>CurvedRidges@<dim@></code>  。

      descriptor.data = 
        std::make_unique<Data::SetUp<Data::Exercise_2_3<dim>, dim>>(); 

// 接下来先设置一个二元函数，然后设置一个评价对象的列表。我们默认选择在一个评价点对值进行评价，由评价和二元函数类命名空间中的 <code>PointValueEvaluation</code> 类代表。你也可以设置 <code>PointXDerivativeEvaluation</code> 类来代替评价点上的值的x-derivative。

// 注意，双功能和评价对象应该匹配。然而，你可以给你想要的评价函数，所以你可以在每一步之后让点值和导数都得到评价。 一个这样的附加评价是在每一步中输出网格。

      const Point<dim> evaluation_point(0.75, 0.75); 
      descriptor.dual_functional = 
        std::make_unique<DualFunctional::PointValueEvaluation<dim>>( 
          evaluation_point); 

      Evaluation::PointValueEvaluation<dim> postprocessor1(evaluation_point); 
      Evaluation::GridOutput<dim>           postprocessor2("grid"); 

      descriptor.evaluator_list.push_back(&postprocessor1); 
      descriptor.evaluator_list.push_back(&postprocessor2); 

// 设置最大的自由度数，在这个自由度数之后，我们希望程序停止进一步细化网格。

      descriptor.max_degrees_of_freedom = 20000; 

// 最后将描述符对象传递给一个函数，用它来运行整个解决方案。

      Framework<dim>::run(descriptor); 
    } 

// 捕获异常以提供有关失败的信息。

  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------"  
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 



CCTest_file/step-15.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2012 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Sven Wetterauer, University of Heidelberg, 2012 
 */ 


// @sect3{Include files}  

// 前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_q.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <fstream> 
#include <iostream> 

// 我们将在牛顿迭代之间使用自适应网格细化技术。要做到这一点，我们需要能够在新的网格上使用解决方案，尽管它是在旧的网格上计算出来的。SolutionTransfer类将解决方案从旧网格转移到新网格。

#include <deal.II/numerics/solution_transfer.h> 

// 然后，我们为这个程序打开一个命名空间，像以前的程序一样，将dealii命名空间中的所有东西导入其中。

namespace Step15 
{ 
  using namespace dealii; 
// @sect3{The <code>MinimalSurfaceProblem</code> class template}  

// 类模板与  step-6  中的基本相同。 增加了三个内容。

// - 有两个解决方案向量，一个用于牛顿更新  $\delta u^n$  ，另一个用于当前迭代  $u^n$  。

// -  <code>setup_system</code> 函数需要一个参数，表示这是否是第一次被调用。不同的是，第一次我们需要分配自由度，并将 $u^n$ 的解向量设置为正确的大小。接下来的几次，该函数是在我们已经完成了这些步骤，作为细化 <code>refine_mesh</code> 中网格的一部分之后被调用的。

// - 然后我们还需要新的函数。  <code>set_boundary_values()</code> 负责正确设置解向量的边界值，这在介绍的最后已经讨论过了。  <code>compute_residual()</code> 是一个计算非线性（离散）残差规范的函数。我们用这个函数来监测牛顿迭代的收敛性。该函数以步长 $\alpha^n$ 为参数来计算 $u^n + \alpha^n \; \delta u^n$ 的残差。这是人们通常需要的步长控制，尽管我们在这里不会使用这个功能。最后， <code>determine_step_length()</code> 计算每个牛顿迭代中的步长 $\alpha^n$ 。正如介绍中所讨论的，我们在这里使用一个固定的步长，并把实现一个更好的策略作为一个练习。(  step-77 的做法不同。它只是在整个求解过程中使用了一个外部包，而一个好的直线搜索策略是该包所提供的一部分）。)

  template <int dim> 
  class MinimalSurfaceProblem 
  { 
  public: 
    MinimalSurfaceProblem(); 
    void run(); 

  private: 
    void   setup_system(const bool initial_step); 
    void   assemble_system(); 
    void   solve(); 
    void   refine_mesh(); 
    void   set_boundary_values(); 
    double compute_residual(const double alpha) const; 
    double determine_step_length() const; 
    void   output_results(const unsigned int refinement_cycle) const; 

    Triangulation<dim> triangulation; 

    DoFHandler<dim> dof_handler; 
    FE_Q<dim>       fe; 

    AffineConstraints<double> hanging_node_constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> current_solution; 
    Vector<double> newton_update; 
    Vector<double> system_rhs; 
  }; 
// @sect3{Boundary condition}  

// 边界条件的实现就像在  step-4  中一样。 它被选为  $g(x,y)=\sin(2 \pi (x+y))$  。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> &p, 
                                    const unsigned int /*component*/) const 
  { 
    return std::sin(2 * numbers::PI * (p[0] + p[1])); 
  } 
// @sect3{The <code>MinimalSurfaceProblem</code> class implementation}  
// @sect4{MinimalSurfaceProblem::MinimalSurfaceProblem}  

// 该类的构造函数和析构函数与前几篇教程中的相同。

  template <int dim> 
  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem() 
    : dof_handler(triangulation) 
    , fe(2) 
  {} 
// @sect4{MinimalSurfaceProblem::setup_system}  

// 在setup-system函数中，我们总是设置有限元方法的变量。与 step-6 有相同的区别，因为在那里我们在每个细化周期中都要从头开始求解PDE，而在这里我们需要把以前的网格的解放到当前的网格上。因此，我们不能只是重置解向量。因此，传递给这个函数的参数表明我们是否可以分布自由度（加上计算约束）并将解向量设置为零，或者这在其他地方已经发生过了（特别是在 <code>refine_mesh()</code> ）。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step) 
  { 
    if (initial_step) 
      { 
        dof_handler.distribute_dofs(fe); 
        current_solution.reinit(dof_handler.n_dofs()); 

        hanging_node_constraints.clear(); 
        DoFTools::make_hanging_node_constraints(dof_handler, 
                                                hanging_node_constraints); 
        hanging_node_constraints.close(); 
      } 

// 该函数的其余部分与  step-6  中的相同。

    newton_update.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 

    hanging_node_constraints.condense(dsp); 

    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 
  } 
// @sect4{MinimalSurfaceProblem::assemble_system}  

// 这个函数的作用与前面的教程相同，当然，现在矩阵和右手边的函数取决于上一次迭代的解。正如在介绍中所讨论的，我们需要使用牛顿更新的零边界值；我们在这个函数的最后计算它们。

// 该函数的顶部包含了通常的模板代码，设置了允许我们在正交点评估形状函数的对象，以及本地矩阵和向量的临时存储位置，以及正交点上先前解的梯度。然后我们开始在所有单元格上进行循环。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::assemble_system() 
  { 
    const QGauss<dim> quadrature_formula(fe.degree + 1); 

    system_matrix = 0; 
    system_rhs    = 0; 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_gradients | update_quadrature_points | 
                              update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<Tensor<1, dim>> old_solution_gradients(n_q_points); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0; 
        cell_rhs    = 0; 

        fe_values.reinit(cell); 

// 为了组装线性系统，我们必须在正交点上获得前一个解的梯度值。有一个标准的方法： FEValues::get_function_gradients 函数接收一个代表定义在DoFHandler上的有限元场的向量，并评估这个场在FEValues对象最后被重新初始化的单元的正交点的梯度。然后将所有正交点的梯度值写入第二个参数中。

        fe_values.get_function_gradients(current_solution, 
                                         old_solution_gradients); 

// 有了这个，我们就可以对所有的正交点和形状函数进行积分循环。 在刚刚计算了正交点中旧解的梯度后，我们就可以计算这些点中的系数 $a_{n}$ 。 然后，系统本身的组装看起来与我们一贯的做法相似，除了非线性项之外，将结果从局部对象复制到全局对象中也是如此。

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double coeff = 
              1.0 / std::sqrt(1 + old_solution_gradients[q] * 
                                    old_solution_gradients[q]); 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              { 
                for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                  cell_matrix(i, j) += 
                    (((fe_values.shape_grad(i, q)      // ((\nabla \phi_i 
                       * coeff                         //   * a_n 
                       * fe_values.shape_grad(j, q))   //   * \nabla \phi_j) 
                      -                                //  - 
                      (fe_values.shape_grad(i, q)      //  (\nabla \phi_i 
                       * coeff * coeff * coeff         //   * a_n^3 
                       * (fe_values.shape_grad(j, q)   //   * (\nabla \phi_j 
                          * old_solution_gradients[q]) //      * \nabla u_n) 
                       * old_solution_gradients[q]))   //   * \nabla u_n))) 
                     * fe_values.JxW(q));              // * dx 

                cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \nabla \phi_i 
                                * coeff                     // * a_n 
                                * old_solution_gradients[q] // * u_n 
                                * fe_values.JxW(q));        // * dx 
              } 
          } 

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              system_matrix.add(local_dof_indices[i], 
                                local_dof_indices[j], 
                                cell_matrix(i, j)); 

            system_rhs(local_dof_indices[i]) += cell_rhs(i); 
          } 
      } 

// 最后，我们从系统中移除悬挂的节点，并将零边界值应用到定义牛顿更新的线性系统中  $\delta u^n$  。

    hanging_node_constraints.condense(system_matrix); 
    hanging_node_constraints.condense(system_rhs); 

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             boundary_values); 
    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       newton_update, 
                                       system_rhs); 
  } 

//  @sect4{MinimalSurfaceProblem::solve}  

// 解算函数和以往一样。在求解过程的最后，我们通过设置 $u^{n+1}=u^n+\alpha^n\;\delta u^n$ 来更新当前的解决方案。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::solve() 
  { 
    SolverControl            solver_control(system_rhs.size(), 
                                 system_rhs.l2_norm() * 1e-6); 
    SolverCG<Vector<double>> solver(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    solver.solve(system_matrix, newton_update, system_rhs, preconditioner); 

    hanging_node_constraints.distribute(newton_update); 

    const double alpha = determine_step_length(); 
    current_solution.add(alpha, newton_update); 
  } 
// @sect4{MinimalSurfaceProblem::refine_mesh}  

// 这个函数的第一部分与 step-6 中的内容相同 ... 然而，在细化网格后，我们必须将旧的解决方案转移到新的解决方案中，我们在SolutionTransfer类的帮助下完成。这个过程稍微有点复杂，所以让我们详细描述一下。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::refine_mesh() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      current_solution, 
      estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 

// 然后我们需要一个额外的步骤：例如，如果你标记了一个比它的邻居更精炼一次的单元，而这个邻居没有被标记为精炼，我们最终会在一个单元界面上跳过两个精炼级别。 为了避免这些情况，库将默默地也要对邻居单元进行一次细化。它通过在实际进行细化和粗化之前调用 Triangulation::prepare_coarsening_and_refinement 函数来实现。 这个函数标志着一组额外的单元格进行细化或粗化，以执行像单悬节点规则这样的规则。 调用此函数后，被标记为细化和粗化的单元格正是那些将被实际细化或粗化的单元格。通常情况下，你不需要手工操作 (Triangulation::execute_coarsening_and_refinement 为你做这个）。) 然而，我们需要初始化SolutionTransfer类，它需要知道最终将被粗化或细化的单元集，以便存储旧网格的数据并转移到新网格。因此，我们手动调用这个函数。

    triangulation.prepare_coarsening_and_refinement(); 

// 有了这个方法，我们用现在的DoFHandler初始化一个SolutionTransfer对象，并将解决方案向量附加到它上面，然后在新网格上进行实际的细化和自由度分配

    SolutionTransfer<dim> solution_transfer(dof_handler); 
    solution_transfer.prepare_for_coarsening_and_refinement(current_solution); 

    triangulation.execute_coarsening_and_refinement(); 

    dof_handler.distribute_dofs(fe); 

// 最后，我们找回插值到新网格的旧解。由于SolutionTransfer函数实际上并不存储旧的解决方案的值，而是索引，我们需要保留旧的解决方案向量，直到我们得到新的内插值。因此，我们将新的数值写入一个临时的向量中，之后才将其写入解决方案向量对象中。

    Vector<double> tmp(dof_handler.n_dofs()); 
    solution_transfer.interpolate(current_solution, tmp); 
    current_solution = tmp; 

// 在新的网格上，有不同的悬挂节点，对于这些节点，我们必须在扔掉之前的对象内容后，重新计算约束。为了安全起见，我们还应该确保当前解决方案的向量条目满足悬空节点的约束条件（参见SolutionTransfer类文档中的讨论，了解为什么必须这样做）。我们可以通过明确调用`hanging_node_constraints.distribution(current_solution)`来做到这一点；我们省略这一步，因为这将在下面调用`set_boundary_values()`的最后发生，而且没有必要做两次。

    hanging_node_constraints.clear(); 

    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

// 一旦我们有了内插的解决方案和所有关于悬挂节点的信息，我们必须确保我们现在的 $u^n$ 实际上有正确的边界值。正如在介绍的最后所解释的，即使细化前的解决方案有正确的边界值，也不会自动出现这种情况，因此我们必须明确地确保它现在有。

    set_boundary_values(); 

// 我们通过更新所有剩余的数据结构来结束这个函数，向 <code>setup_dofs()</code> 表明这不是第一次了，它需要保留解向量的内容。

    setup_system(false); 
  } 

//  @sect4{MinimalSurfaceProblem::set_boundary_values}  

// 下一个函数确保解向量的条目尊重我们问题的边界值。 在细化了网格之后（或者刚刚开始计算），边界上可能会出现新的节点。这些节点的数值是在`refine_mesh()`中从之前的网格中简单插值出来的，而不是正确的边界值。这个问题可以通过将当前解决方案向量的所有边界节点明确设置为正确的值来解决。

// 但是有一个问题我们必须注意：如果我们有一个挂起的节点紧挨着一个新的边界节点，那么它的值也必须被调整以确保有限元场保持连续。这就是这个函数最后一行的调用所做的。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::set_boundary_values() 
  { 
    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             BoundaryValues<dim>(), 
                                             boundary_values); 
    for (auto &boundary_value : boundary_values) 
      current_solution(boundary_value.first) = boundary_value.second; 

    hanging_node_constraints.distribute(current_solution); 
  } 
// @sect4{MinimalSurfaceProblem::compute_residual}  

// 为了监测收敛性，我们需要一种方法来计算（离散）残差的规范，即在介绍中讨论的向量 $\left<F(u^n),\varphi_i\right>$ 与 $F(u)=-\nabla \cdot \left(\frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right)$ 的规范。事实证明，（尽管我们在当前版本的程序中没有使用这个功能）在确定最佳步长时需要计算残差 $\left<F(u^n+\alpha^n\;\delta u^n),\varphi_i\right>$ ，因此这就是我们在这里实现的：该函数将步长 $\alpha^n$ 作为参数。原有的功能当然是通过传递一个零作为参数得到的。

// 在下面的函数中，我们首先为残差设置一个向量，然后为评估点设置一个向量  $u^n+\alpha^n\;\delta u^n$  。接下来是我们在所有的积分操作中使用的相同的模板代码。

  template <int dim> 
  double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const 
  { 
    Vector<double> residual(dof_handler.n_dofs()); 

    Vector<double> evaluation_point(dof_handler.n_dofs()); 
    evaluation_point = current_solution; 
    evaluation_point.add(alpha, newton_update); 

    const QGauss<dim> quadrature_formula(fe.degree + 1); 
    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_gradients | update_quadrature_points | 
                              update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double>              cell_residual(dofs_per_cell); 
    std::vector<Tensor<1, dim>> gradients(n_q_points); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_residual = 0; 
        fe_values.reinit(cell); 

// 实际的计算与  <code>assemble_system()</code>  中的计算差不多。我们首先评估 $u^n+\alpha^n\,\delta u^n$ 在正交点的梯度，然后计算系数 $a_n$ ，然后将其全部插入残差公式中。

        fe_values.get_function_gradients(evaluation_point, gradients); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double coeff = 
              1. / std::sqrt(1 + gradients[q] * gradients[q]); 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_residual(i) -= (fe_values.shape_grad(i, q) // \nabla \phi_i 
                                   * coeff                    // * a_n 
                                   * gradients[q]             // * u_n 
                                   * fe_values.JxW(q));       // * dx 
          } 

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          residual(local_dof_indices[i]) += cell_residual(i); 
      } 

// 在这个函数的最后，我们还必须处理悬挂节点的约束和边界值的问题。关于后者，我们必须将所有对应于位于边界的自由度的条目的残差向量元素设置为零。原因是，由于那里的解的值是固定的，它们当然不是 "真正的 "自由度，因此，严格来说，我们不应该在残差向量中为它们集合条目。然而，正如我们一直所做的那样，我们想在每个单元上做完全相同的事情，因此我们并不想在上面的积分中处理某个自由度是否位于边界的问题。相反，我们将简单地在事后将这些条目设置为零。为此，我们需要确定哪些自由度实际上属于边界，然后在所有这些自由度上进行循环，并将剩余条目设置为零。这发生在以下几行中，我们已经在 step-11 中看到了使用DoFTools命名空间的适当函数。

    hanging_node_constraints.condense(residual); 

    for (types::global_dof_index i : 
         DoFTools::extract_boundary_dofs(dof_handler)) 
      residual(i) = 0; 

// 在函数的最后，我们返回残差的常数。

    return residual.l2_norm(); 
  } 

//  @sect4{MinimalSurfaceProblem::determine_step_length}  

// 正如介绍中所讨论的，如果我们总是采取全步，即计算 $u^{n+1}=u^n+\delta u^n$ ，牛顿方法经常不收敛。相反，我们需要一个阻尼参数（步长）  $\alpha^n$  并设置  $u^{n+1}=u^n+\alpha^n\delta u^n$  。这个函数是用来计算 $\alpha^n$  的。

// 在这里，我们简单地总是返回0.1。这当然是一个次优的选择：理想情况下，人们希望的是，当我们越来越接近解的时候，步长变成1，这样我们就可以享受牛顿方法的快速二次收敛。我们将在下面的结果部分讨论更好的策略， step-77 也涉及这方面的内容。

  template <int dim> 
  double MinimalSurfaceProblem<dim>::determine_step_length() const 
  { 
    return 0.1; 
  } 

//  @sect4{MinimalSurfaceProblem::output_results}  

// 从`run()`调用的最后一个函数以图形形式输出当前的解决方案（和牛顿更新），作为VTU文件。它与之前教程中使用的完全相同。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::output_results( 
    const unsigned int refinement_cycle) const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(current_solution, "solution"); 
    data_out.add_data_vector(newton_update, "update"); 
    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu"; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 
// @sect4{MinimalSurfaceProblem::run}  

// 在运行函数中，我们建立第一个网格，然后有牛顿迭代的顶层逻辑。

// 正如在介绍中所描述的，领域是围绕原点的单位圆盘，创建方式与 step-6 中所示相同。网格经过两次全局细化，然后再进行若干次适应性循环。

// 在开始牛顿循环之前，我们还需要做一些设置工作。我们需要创建基本的数据结构，并确保第一个牛顿迭代已经有了正确的边界值，这在介绍中已经讨论过了。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::run() 
  { 
    GridGenerator::hyper_ball(triangulation); 
    triangulation.refine_global(2); 

    setup_system(/*first time=*/true); 
    set_boundary_values(); 

// 接下来开始牛顿迭代。我们一直迭代到上一次迭代结束时计算的残差（规范）小于 $10^{-3}$ ，正如在 "do{ ... } while "循环结束时的检查。因为我们没有一个合理的值来初始化这个变量，所以我们只是使用可以表示为`双数'的最大值。

    double       last_residual_norm = std::numeric_limits<double>::max(); 
    unsigned int refinement_cycle   = 0; 
    do 
      { 
        std::cout << "Mesh refinement step " << refinement_cycle << std::endl; 

        if (refinement_cycle != 0) 
          refine_mesh(); 

// 在每个网格上，我们正好做五个牛顿步骤。我们在这里打印初始残差，然后在这个网格上开始迭代。

// 在每一个牛顿步骤中，首先要计算系统矩阵和右手边，然后我们存储右手边的规范作为残差，以便在决定是否停止迭代时进行检查。然后我们求解线性系统（该函数也会更新 $u^{n+1}=u^n+\alpha^n\;\delta u^n$ ），并在这个牛顿步骤结束时输出残差的准则。

// 在这个循环结束后，我们还将以图形形式输出当前网格上的解，并增加网格细化循环的计数器。

        std::cout << "  Initial residual: " << compute_residual(0) << std::endl; 

        for (unsigned int inner_iteration = 0; inner_iteration < 5; 
             ++inner_iteration) 
          { 
            assemble_system(); 
            last_residual_norm = system_rhs.l2_norm(); 

            solve(); 

            std::cout << "  Residual: " << compute_residual(0) << std::endl; 
          } 

        output_results(refinement_cycle); 

        ++refinement_cycle; 
        std::cout << std::endl; 
      } 
    while (last_residual_norm > 1e-3); 
  } 
} // namespace Step15 
// @sect4{The main function}  

// 最后是主函数。这遵循了所有其他主函数的方案。

int main() 
{ 
  try 
    { 
      using namespace Step15; 

      MinimalSurfaceProblem<2> laplace_problem_2d; 
      laplace_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 



CCTest_file/step-16.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2003 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Guido Kanschat, University of Heidelberg, 2003 
 *          Baerbel Janssen, University of Heidelberg, 2010 
 *          Wolfgang Bangerth, Texas A&M University, 2010 
 *          Timo Heister, Clemson University, 2018 
 */ 


// @sect3{Include files}  

// 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 现在，这些是多级方法所需的包括。第一个声明了如何处理多网格方法每个层次上的Dirichlet边界条件。对于自由度的实际描述，我们不需要任何新的包含文件，因为DoFHandler已经实现了所有必要的方法。我们只需要将自由度分配给更多的层次。

// 其余的包含文件涉及到作为线性算子（求解器或预处理器）的多重网格的力学问题。

#include <deal.II/multigrid/mg_constrained_dofs.h> 
#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_matrix.h> 

// 我们将使用 MeshWorker::mesh_loop 来对单元格进行循环，所以在这里包括它。

#include <deal.II/meshworker/mesh_loop.h> 

// 这就是C++。

#include <iostream> 
#include <fstream> 

using namespace dealii; 

namespace Step16 
{ 
// @sect3{The Scratch and Copy objects}  

// 我们使用 MeshWorker::mesh_loop() 来组装我们的矩阵。为此，我们需要一个ScratchData对象来存储每个单元的临时数据（这只是FEValues对象）和一个CopyData对象，它将包含每个单元装配的输出。关于scratch和copy对象的用法的更多细节，请参见WorkStream命名空间。

  template <int dim> 
  struct ScratchData 
  { 
    ScratchData(const Mapping<dim> &      mapping, 
                const FiniteElement<dim> &fe, 
                const unsigned int        quadrature_degree, 
                const UpdateFlags         update_flags) 
      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags) 
    {} 

    ScratchData(const ScratchData<dim> &scratch_data) 
      : fe_values(scratch_data.fe_values.get_mapping(), 
                  scratch_data.fe_values.get_fe(), 
                  scratch_data.fe_values.get_quadrature(), 
                  scratch_data.fe_values.get_update_flags()) 
    {} 

    FEValues<dim> fe_values; 
  }; 

  struct CopyData 
  { 
    unsigned int                         level; 
    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_rhs; 
    std::vector<types::global_dof_index> local_dof_indices; 

    template <class Iterator> 
    void reinit(const Iterator &cell, unsigned int dofs_per_cell) 
    { 
      cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 
      cell_rhs.reinit(dofs_per_cell); 

      local_dof_indices.resize(dofs_per_cell); 
      cell->get_active_or_mg_dof_indices(local_dof_indices); 
      level = cell->level(); 
    } 
  }; 
// @sect3{The <code>LaplaceProblem</code> class template}  

// 这个主类与  step-6  中的同一类相似。就成员函数而言，唯一增加的是。

// --  <code>assemble_multigrid</code> 的函数，该函数组装了对应于中间层离散运算符的矩阵。

// -  <code>cell_worker</code> 函数，它将我们的PDE集合在一个单元上。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(const unsigned int degree); 
    void run(); 

  private: 
    template <class Iterator> 
    void cell_worker(const Iterator &  cell, 
                     ScratchData<dim> &scratch_data, 
                     CopyData &        copy_data); 

    void setup_system(); 
    void assemble_system(); 
    void assemble_multigrid(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    AffineConstraints<double> constraints; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    const unsigned int degree; 

// 以下成员是多网格方法的基本数据结构。前四个表示稀疏模式和多级层次结构中各个层次的矩阵，非常类似于上面的全局网格的对象。

// 然后，我们有两个新的矩阵，只需要在自适应网格上进行局部平滑的多网格方法。它们在细化区域的内部和细化边缘之间传递数据，在 @ref mg_paper "多网格论文 "中详细介绍过。

// 最后一个对象存储了每个层次上的边界指数信息和位于两个不同细化层次之间的细化边缘上的指数信息。因此，它的作用与AffineConstraints相似，但在每个层次上。

    MGLevelObject<SparsityPattern> mg_sparsity_patterns; 
    MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns; 

    MGLevelObject<SparseMatrix<double>> mg_matrices; 
    MGLevelObject<SparseMatrix<double>> mg_interface_matrices; 
    MGConstrainedDoFs                   mg_constrained_dofs; 
  }; 
// @sect3{The <code>LaplaceProblem</code> class implementation}  

// 关于三角形的构造函数只有一个简短的评论：按照惯例，deal.II中所有自适应精化的三角形在单元格之间的面的变化不会超过一个级别。然而，对于我们的多网格算法，我们需要一个更严格的保证，即网格在连接两个单元的顶点上的变化也不超过细化级别。换句话说，我们必须防止出现以下情况。

//  @image html limit_level_difference_at_vertices.png ""  

// 这可以通过向三角化类的构造函数传递 Triangulation::limit_level_difference_at_vertices 标志来实现。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree) 
    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices) 
    , fe(degree) 
    , dof_handler(triangulation) 
    , degree(degree) 
  {} 

//  @sect4{LaplaceProblem::setup_system}  

// 除了只是在DoFHandler中分配自由度之外，我们在每一层都做同样的事情。然后，我们按照之前的程序，在叶子网格上设置系统。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    dof_handler.distribute_mg_dofs(); 

    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (by level: "; 
    for (unsigned int level = 0; level < triangulation.n_levels(); ++level) 
      std::cout << dof_handler.n_dofs(level) 
                << (level == triangulation.n_levels() - 1 ? ")" : ", "); 
    std::cout << std::endl; 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

    std::set<types::boundary_id> dirichlet_boundary_ids = {0}; 
    Functions::ZeroFunction<dim> homogeneous_dirichlet_bc; 
    const std::map<types::boundary_id, const Function<dim> *> 
      dirichlet_boundary_functions = { 
        {types::boundary_id(0), &homogeneous_dirichlet_bc}}; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             dirichlet_boundary_functions, 
                                             constraints); 
    constraints.close(); 

    { 
      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints); 
      sparsity_pattern.copy_from(dsp); 
    } 
    system_matrix.reinit(sparsity_pattern); 

// 多网格约束必须被初始化。他们需要知道在哪里规定了Dirichlet边界条件。

    mg_constrained_dofs.clear(); 
    mg_constrained_dofs.initialize(dof_handler); 
    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, 
                                                       dirichlet_boundary_ids); 

// 现在是关于多网格数据结构的事情。首先，我们调整多级对象的大小，以容纳每一级的矩阵和稀疏模式。粗略的级别是零（现在是强制性的，但在未来的修订中可能会改变）。注意，这些函数在这里采取的是一个完整的、包容的范围（而不是一个起始索引和大小），所以最细的级别是 <code>n_levels-1</code>  。我们首先要调整容纳SparseMatrix类的容器的大小，因为它们必须在调整大小时释放它们的SparsityPattern才能被销毁。

    const unsigned int n_levels = triangulation.n_levels(); 

    mg_interface_matrices.resize(0, n_levels - 1); 
    mg_matrices.resize(0, n_levels - 1); 
    mg_sparsity_patterns.resize(0, n_levels - 1); 
    mg_interface_sparsity_patterns.resize(0, n_levels - 1); 

// 现在，我们必须在每个级别上提供一个矩阵。为此，我们首先使用 MGTools::make_sparsity_pattern 函数在每个层次上生成一个初步的压缩稀疏模式（关于这个主题的更多信息，请参见 @ref Sparsity 模块），然后将其复制到我们真正想要的那一个。下一步是用拟合的稀疏度模式初始化接口矩阵。

// 值得指出的是，界面矩阵只包含位于较粗和较细的网格之间的自由度的条目。因此，它们甚至比我们的多网格层次结构中的各个层次的矩阵还要稀疏。因此，我们使用一个专门为此目的而建立的函数来生成它。

    for (unsigned int level = 0; level < n_levels; ++level) 
      { 
        { 
          DynamicSparsityPattern dsp(dof_handler.n_dofs(level), 
                                     dof_handler.n_dofs(level)); 
          MGTools::make_sparsity_pattern(dof_handler, dsp, level); 

          mg_sparsity_patterns[level].copy_from(dsp); 
          mg_matrices[level].reinit(mg_sparsity_patterns[level]); 
        } 
        { 
          DynamicSparsityPattern dsp(dof_handler.n_dofs(level), 
                                     dof_handler.n_dofs(level)); 
          MGTools::make_interface_sparsity_pattern(dof_handler, 
                                                   mg_constrained_dofs, 
                                                   dsp, 
                                                   level); 
          mg_interface_sparsity_patterns[level].copy_from(dsp); 
          mg_interface_matrices[level].reinit( 
            mg_interface_sparsity_patterns[level]); 
        } 
      } 
  } 
// @sect4{LaplaceProblem::cell_worker}  

// cell_worker函数用于在给定的单元上组装矩阵和右手边。这个函数用于活动单元生成system_matrix，并在每个层次上建立层次矩阵。

// 注意，当从assemble_multigrid()调用时，我们也会组装一个右手边，尽管它没有被使用。

  template <int dim> 
  template <class Iterator> 
  void LaplaceProblem<dim>::cell_worker(const Iterator &  cell, 
                                        ScratchData<dim> &scratch_data, 
                                        CopyData &        copy_data) 
  { 
    FEValues<dim> &fe_values = scratch_data.fe_values; 
    fe_values.reinit(cell); 

    const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell(); 
    const unsigned int n_q_points    = fe_values.get_quadrature().size(); 

    copy_data.reinit(cell, dofs_per_cell); 

    const std::vector<double> &JxW = fe_values.get_JxW_values(); 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        const double coefficient = 
          (fe_values.get_quadrature_points()[q][0] < 0.0) ? 1.0 : 0.1; 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              { 
                copy_data.cell_matrix(i, j) += 
                  coefficient * 
                  (fe_values.shape_grad(i, q) * fe_values.shape_grad(j, q)) * 
                  JxW[q]; 
              } 
            copy_data.cell_rhs(i) += 1.0 * fe_values.shape_value(i, q) * JxW[q]; 
          } 
      } 
  } 

//  @sect4{LaplaceProblem::assemble_system}  

// 下面的函数将线性系统集合在网格的活动单元上。为此，我们向Mesh_loop()函数传递两个lambda函数。cell_worker函数重定向到同名的类成员函数，而copyer是这个函数特有的，它使用约束条件将本地矩阵和向量复制到相应的全局矩阵。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_system() 
  { 
    MappingQ1<dim> mapping; 

    auto cell_worker = 
      [&](const typename DoFHandler<dim>::active_cell_iterator &cell, 
          ScratchData<dim> &                                    scratch_data, 
          CopyData &                                            copy_data) { 
        this->cell_worker(cell, scratch_data, copy_data); 
      }; 

    auto copier = [&](const CopyData &cd) { 
      this->constraints.distribute_local_to_global(cd.cell_matrix, 
                                                   cd.cell_rhs, 
                                                   cd.local_dof_indices, 
                                                   system_matrix, 
                                                   system_rhs); 
    }; 

    const unsigned int n_gauss_points = degree + 1; 

    ScratchData<dim> scratch_data(mapping, 
                                  fe, 
                                  n_gauss_points, 
                                  update_values | update_gradients | 
                                    update_JxW_values | 
                                    update_quadrature_points); 

    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          CopyData(), 
                          MeshWorker::assemble_own_cells); 
  } 
// @sect4{LaplaceProblem::assemble_multigrid}  

// 下一个函数是建立矩阵，定义每一层网格上的多网格方法。集成的核心与上面的相同，但是下面的循环将遍历所有已存在的单元，而不仅仅是活动的单元，并且必须将结果输入正确的层矩阵。幸运的是，MeshWorker对我们隐藏了大部分的内容，因此这个函数和之前的函数的区别只在于汇编器的设置和循环中的不同迭代器。

// 我们为每个层次生成一个AffineConstraints对象，其中包含边界和界面道夫作为约束条目。然后，相应的对象被用来生成层次矩阵。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_multigrid() 
  { 
    MappingQ1<dim>     mapping; 
    const unsigned int n_levels = triangulation.n_levels(); 

    std::vector<AffineConstraints<double>> boundary_constraints(n_levels); 
    for (unsigned int level = 0; level < n_levels; ++level) 
      { 
        IndexSet dofset; 
        DoFTools::extract_locally_relevant_level_dofs(dof_handler, 
                                                      level, 
                                                      dofset); 
        boundary_constraints[level].reinit(dofset); 
        boundary_constraints[level].add_lines( 
          mg_constrained_dofs.get_refinement_edge_indices(level)); 
        boundary_constraints[level].add_lines( 
          mg_constrained_dofs.get_boundary_indices(level)); 
        boundary_constraints[level].close(); 
      } 

    auto cell_worker = 
      [&](const typename DoFHandler<dim>::level_cell_iterator &cell, 
          ScratchData<dim> &                                   scratch_data, 
          CopyData &                                           copy_data) { 
        this->cell_worker(cell, scratch_data, copy_data); 
      }; 

    auto copier = [&](const CopyData &cd) { 
      boundary_constraints[cd.level].distribute_local_to_global( 
        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]); 

      const unsigned int dofs_per_cell = cd.local_dof_indices.size(); 

// 接口条目在填充mg_matrices[cd.level]时被上面的boundary_constraints对象所忽略。相反，我们手动将这些条目复制到当前级别的界面矩阵中。

      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        for (unsigned int j = 0; j < dofs_per_cell; ++j) 
          if (mg_constrained_dofs.is_interface_matrix_entry( 
                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j])) 
            { 
              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i], 
                                                  cd.local_dof_indices[j], 
                                                  cd.cell_matrix(i, j)); 
            } 
    }; 

    const unsigned int n_gauss_points = degree + 1; 

    ScratchData<dim> scratch_data(mapping, 
                                  fe, 
                                  n_gauss_points, 
                                  update_values | update_gradients | 
                                    update_JxW_values | 
                                    update_quadrature_points); 

    MeshWorker::mesh_loop(dof_handler.begin_mg(), 
                          dof_handler.end_mg(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          CopyData(), 
                          MeshWorker::assemble_own_cells); 
  } 

//  @sect4{LaplaceProblem::solve}  

// 这是另外一个在支持多栅求解器（或者说，事实上，我们使用多栅方法的前提条件）方面有明显不同的函数。

// 让我们从建立多层次方法的两个组成部分开始：层次间的转移运算器和最粗层次上的求解器。在有限元方法中，转移算子来自所涉及的有限元函数空间，通常可以用独立于所考虑问题的通用方式计算。在这种情况下，我们可以使用MGTransferPrebuilt类，给定最终线性系统的约束和MGConstrainedDoFs对象，该对象知道每个层次的边界条件和不同细化层次之间接口的自由度，可以从具有层次自由度的DoFHandler对象中建立这些转移操作的矩阵。

// 下面几行的第二部分是关于粗略网格求解器的。由于我们的粗网格确实非常粗，我们决定采用直接求解器（最粗层次矩阵的Householder分解），即使其实现不是特别复杂。如果我们的粗网格比这里的5个单元多得多，那么这里显然需要更合适的东西。

  template <int dim> 
  void LaplaceProblem<dim>::solve() 
  { 
    MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs); 
    mg_transfer.build(dof_handler); 

    FullMatrix<double> coarse_matrix; 
    coarse_matrix.copy_from(mg_matrices[0]); 
    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver; 
    coarse_grid_solver.initialize(coarse_matrix); 

// 多级求解器或预处理器的下一个组成部分是，我们需要在每一级上设置平滑器。这方面常见的选择是使用松弛方法的应用（如SOR、Jacobi或Richardson方法）或求解器方法的少量迭代（如CG或GMRES）。 mg::SmootherRelaxation 和MGSmootherPrecondition类为这两种平滑器提供支持。这里，我们选择应用单一的SOR迭代。为此，我们定义一个适当的别名，然后设置一个平滑器对象。

// 最后一步是用我们的水平矩阵初始化平滑器对象，并设置一些平滑参数。 <code>initialize()</code> 函数可以有选择地接受额外的参数，这些参数将被传递给每一级的平滑器对象。在目前SOR平滑器的情况下，这可能包括一个松弛参数。然而，我们在这里将这些参数保留为默认值。对 <code>set_steps()</code> 的调用表明我们将在每个级别上使用两个前平滑步骤和两个后平滑步骤；为了在不同级别上使用可变数量的平滑器步骤，可以在对 <code>mg_smoother</code> 对象的构造函数调用中设置更多选项。

// 最后一步的结果是我们使用SOR方法作为平滑器的事实

// --这不是对称的

// 但我们在下面使用共轭梯度迭代（需要对称的预处理），我们需要让多级预处理确保我们得到一个对称的算子，即使是非对称的平滑器。

    using Smoother = PreconditionSOR<SparseMatrix<double>>; 
    mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother; 
    mg_smoother.initialize(mg_matrices); 
    mg_smoother.set_steps(2); 
    mg_smoother.set_symmetric(true); 

// 下一个准备步骤是，我们必须将我们的水平和接口矩阵包裹在一个具有所需乘法函数的对象中。我们将为从粗到细的接口对象创建两个对象，反之亦然；多网格算法将在后面的操作中使用转置运算器，允许我们用已经建立的矩阵初始化该运算器的上下版本。

    mg::Matrix<Vector<double>> mg_matrix(mg_matrices); 
    mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices); 
    mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices); 

// 现在，我们准备设置V型循环算子和多级预处理程序。

    Multigrid<Vector<double>> mg( 
      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother); 
    mg.set_edge_matrices(mg_interface_down, mg_interface_up); 

    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>> 
      preconditioner(dof_handler, mg, mg_transfer); 

// 有了这一切，我们终于可以用通常的方法来解决这个线性系统了。

    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> solver(solver_control); 

    solution = 0; 

    solver.solve(system_matrix, solution, system_rhs, preconditioner); 
    std::cout << "   Number of CG iterations: " << solver_control.last_step() 
              << "\n" 
              << std::endl; 
    constraints.distribute(solution); 
  } 

//  @sect4{Postprocessing}  

// 以下两个函数在计算出解决方案后对其进行后处理。特别是，第一个函数在每个周期开始时细化网格，第二个函数在每个周期结束时输出结果。这些函数与  step-6  中的函数几乎没有变化。

  template <int dim> 
  void LaplaceProblem<dim>::refine_grid() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(degree + 2), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      estimated_error_per_cell); 
    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 
    triangulation.execute_coarsening_and_refinement(); 
  } 

  template <int dim> 
  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(); 

    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk"); 
    data_out.write_vtk(output); 
  } 
// @sect4{LaplaceProblem::run}  

// 和上面的几个函数一样，这几乎是对  step-6  中相应函数的复制。唯一的区别是对 <code>assemble_multigrid</code> 的调用，它负责形成我们在多网格方法中需要的每一层的矩阵。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 8; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_ball(triangulation); 
            triangulation.refine_global(2); 
          } 
        else 
          refine_grid(); 

        std::cout << "   Number of active cells:       " 
                  << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        assemble_system(); 
        assemble_multigrid(); 

        solve(); 
        output_results(cycle); 
      } 
  } 
} // namespace Step16 
// @sect3{The main() function}  

// 这又是与 step-6 中相同的函数。

int main() 
{ 
  try 
    { 
      using namespace Step16; 

      LaplaceProblem<2> laplace_problem(1); 
      laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 



CCTest_file/step-16b.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2003 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Guido Kanschat, University of Heidelberg, 2003 
 *          Baerbel Janssen, University of Heidelberg, 2010 
 *          Wolfgang Bangerth, Texas A&M University, 2010 
 */ 


// @sect3{Include files}  

// 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 这些，现在，是多级方法所必需的包括。第一个声明了如何处理多网格方法每个层次上的Dirichlet边界条件。对于自由度的实际描述，我们不需要任何新的包含文件，因为DoFHandler已经实现了所有必要的方法。我们只需要将自由度分配给更多的层次。

// 其余的包含文件涉及到作为线性算子（求解器或预处理器）的多重网格的力学问题。

#include <deal.II/multigrid/mg_constrained_dofs.h> 
#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_matrix.h> 

// 最后我们包括MeshWorker框架。这个框架通过其函数loop()和integration_loop()，自动在单元格上进行循环，并将数据组装成向量、矩阵等。它自动服从约束。由于我们必须建立几个矩阵，并且必须注意几组约束，这将使我们省去很多麻烦。

#include <deal.II/meshworker/dof_info.h> 
#include <deal.II/meshworker/integration_info.h> 
#include <deal.II/meshworker/simple.h> 
#include <deal.II/meshworker/output.h> 
#include <deal.II/meshworker/loop.h> 

// 为了节省精力，我们使用了在以下文件中找到的预先实现的拉普拉斯。

#include <deal.II/integrators/laplace.h> 
#include <deal.II/integrators/l2.h> 

// 这就是C++。

#include <iostream> 
#include <fstream> 

using namespace dealii; 

namespace Step16 
{ 
// @sect3{The integrator on each cell}  

//  MeshWorker::integration_loop() 希望有一个类能够提供在单元格和边界及内部面的积分功能。这是由下面的类来完成的。在构造函数中，我们告诉循环应该计算单元格积分（"真"），但不应该计算边界和内部面的积分（两个 "假"）。因此，我们只需要一个单元格函数，而不需要面的函数。

  template <int dim> 
  class LaplaceIntegrator : public MeshWorker::LocalIntegrator<dim> 
  { 
  public: 
    LaplaceIntegrator(); 
    virtual void cell(MeshWorker::DoFInfo<dim> &        dinfo, 
                      MeshWorker::IntegrationInfo<dim> &info) const override; 
  }; 

  template <int dim> 
  LaplaceIntegrator<dim>::LaplaceIntegrator() 
    : MeshWorker::LocalIntegrator<dim>(true, false, false) 
  {} 

// 接下来是每个单元上的实际积分器。我们解决一个泊松问题，在右半平面上的系数为1，在左半平面上的系数为十分之一。

//  MeshWorker::LocalResults 的基类 MeshWorker::DoFInfo 包含可以在这个局部积分器中填充的对象。在MeshWorker框架内，有多少对象被创建是由装配器类决定的。在这里，我们举例测试一下，需要一个矩阵 (MeshWorker::LocalResults::n_matrices()).  矩阵是通过 MeshWorker::LocalResults::matrix(), 来访问的，它的第一个参数是矩阵的编号。第二个参数只用于面的积分，当每个测试函数使用两个矩阵时。那么，第二个指标为 "true "的矩阵将以相同的索引存在。

//  MeshWorker::IntegrationInfo 提供了一个或几个FEValues对象，下面这些对象被 LocalIntegrators::Laplace::cell_matrix() 或 LocalIntegrators::L2::L2(). 使用，因为我们只组装一个PDE，所以也只有一个索引为0的对象。

// 此外，我们注意到这个积分器的作用是计算多级预处理的矩阵，以及全局系统的矩阵和右手边。由于系统的汇编器需要一个额外的向量， MeshWorker::LocalResults::n_vectors() 要返回一个非零值。相应地，我们在这个函数的末尾填充了一个右边的向量。由于LocalResults可以处理多个BlockVector对象，但我们这里又是最简单的情况，所以我们将信息输入到零号向量的零号块中。

  template <int dim> 
  void 
  LaplaceIntegrator<dim>::cell(MeshWorker::DoFInfo<dim> &        dinfo, 
                               MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    AssertDimension(dinfo.n_matrices(), 1); 
    const double coefficient = (dinfo.cell->center()(0) > 0.) ? .1 : 1.; 

    LocalIntegrators::Laplace::cell_matrix(dinfo.matrix(0, false).matrix, 
                                           info.fe_values(0), 
                                           coefficient); 

    if (dinfo.n_vectors() > 0) 
      { 
        std::vector<double> rhs(info.fe_values(0).n_quadrature_points, 1.); 
        LocalIntegrators::L2::L2(dinfo.vector(0).block(0), 
                                 info.fe_values(0), 
                                 rhs); 
      } 
  } 
// @sect3{The <code>LaplaceProblem</code> class template}  

// 这个主类与  step-6  中的类基本相同。就成员函数而言，唯一增加的是 <code>assemble_multigrid</code> 函数，它组装了对应于中间层离散运算符的矩阵。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(const unsigned int degree); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void assemble_multigrid(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    AffineConstraints<double> constraints; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    const unsigned int degree; 

// 以下成员是多网格方法的基本数据结构。前两个表示稀疏模式和多级层次结构中各个层次的矩阵，非常类似于上面的全局网格的对象。

// 然后，我们有两个新的矩阵，只需要在自适应网格上进行局部平滑的多网格方法。它们在细化区域的内部和细化边缘之间传递数据，在 @ref mg_paper "多网格论文 "中详细介绍过。

// 最后一个对象存储了每个层次上的边界指数信息和位于两个不同细化层次之间的细化边缘上的指数信息。因此，它的作用与AffineConstraints类似，但在每个层次上。

    MGLevelObject<SparsityPattern>      mg_sparsity_patterns; 
    MGLevelObject<SparseMatrix<double>> mg_matrices; 
    MGLevelObject<SparseMatrix<double>> mg_interface_in; 
    MGLevelObject<SparseMatrix<double>> mg_interface_out; 
    MGConstrainedDoFs                   mg_constrained_dofs; 
  }; 
// @sect3{The <code>LaplaceProblem</code> class implementation}  

// 关于三角形的构造函数只有一个简短的评论：按照惯例，deal.II中所有自适应精化的三角形在单元格之间的面的变化不会超过一个级别。然而，对于我们的多网格算法，我们需要一个更严格的保证，即网格在连接两个单元的顶点上的变化也不超过细化级别。换句话说，我们必须防止出现以下情况。

//  @image html limit_level_difference_at_vertices.png ""  

// 这可以通过向三角化类的构造函数传递 Triangulation::limit_level_difference_at_vertices 标志来实现。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree) 
    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices) 
    , fe(degree) 
    , dof_handler(triangulation) 
    , degree(degree) 
  {} 

//  @sect4{LaplaceProblem::setup_system}  

// 除了只是在DoFHandler中分配自由度之外，我们在每一层都做同样的事情。然后，我们按照之前的程序，在叶子网格上设置系统。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    dof_handler.distribute_mg_dofs(); 

    deallog << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
            << " (by level: "; 
    for (unsigned int level = 0; level < triangulation.n_levels(); ++level) 
      deallog << dof_handler.n_dofs(level) 
              << (level == triangulation.n_levels() - 1 ? ")" : ", "); 
    deallog << std::endl; 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

    std::set<types::boundary_id> dirichlet_boundary_ids = {0}; 
    Functions::ZeroFunction<dim> homogeneous_dirichlet_bc; 
    const std::map<types::boundary_id, const Function<dim> *> 
      dirichlet_boundary_functions = { 
        {types::boundary_id(0), &homogeneous_dirichlet_bc}}; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             dirichlet_boundary_functions, 
                                             constraints); 
    constraints.close(); 
    constraints.condense(dsp); 
    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 

// 多网格约束必须被初始化。他们也需要知道边界值，所以我们也在这里传递 <code>dirichlet_boundary</code> 。

    mg_constrained_dofs.clear(); 
    mg_constrained_dofs.initialize(dof_handler); 
    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, 
                                                       dirichlet_boundary_ids); 

// 现在是关于多网格数据结构的事情。首先，我们调整多级对象的大小，以容纳每一级的矩阵和稀疏模式。粗略的级别是零（现在是强制性的，但在未来的修订中可能会改变）。注意，这些函数在这里采取的是一个完整的、包容的范围（而不是一个起始索引和大小），所以最细的级别是 <code>n_levels-1</code>  。我们首先要调整容纳SparseMatrix类的容器的大小，因为它们必须在调整大小时释放它们的SparsityPattern才能被销毁。

    const unsigned int n_levels = triangulation.n_levels(); 

    mg_interface_in.resize(0, n_levels - 1); 
    mg_interface_in.clear_elements(); 
    mg_interface_out.resize(0, n_levels - 1); 
    mg_interface_out.clear_elements(); 
    mg_matrices.resize(0, n_levels - 1); 
    mg_matrices.clear_elements(); 
    mg_sparsity_patterns.resize(0, n_levels - 1); 

// 现在，我们必须在每个层面上提供一个矩阵。为此，我们首先使用 MGTools::make_sparsity_pattern 函数在每个层次上生成一个初步的压缩稀疏模式（关于这个主题的更多信息，请参见 @ref Sparsity 模块），然后把它复制到我们真正想要的那个层次上。下一步是用这些稀疏模式初始化两种层次矩阵。

// 值得指出的是，界面矩阵只有位于较粗的网格和较细的网格之间的界面上的自由度条目。因此，它们甚至比我们多网格层次结构中的各个层次的矩阵还要稀少。如果我们更关心内存的使用（可能还有我们使用这些矩阵的速度），我们应该对这两种矩阵使用不同的稀疏性模式。

    for (unsigned int level = 0; level < n_levels; ++level) 
      { 
        DynamicSparsityPattern dsp(dof_handler.n_dofs(level), 
                                   dof_handler.n_dofs(level)); 
        MGTools::make_sparsity_pattern(dof_handler, dsp, level); 

        mg_sparsity_patterns[level].copy_from(dsp); 

        mg_matrices[level].reinit(mg_sparsity_patterns[level]); 
        mg_interface_in[level].reinit(mg_sparsity_patterns[level]); 
        mg_interface_out[level].reinit(mg_sparsity_patterns[level]); 
      } 
  } 
// @sect4{LaplaceProblem::assemble_system}  

// 下面的函数将线性系统装配在网格的最细层上。由于我们想在下面的层次装配中重用这里的代码，我们使用本地积分器类LaplaceIntegrator，而将循环留给MeshWorker框架。因此，这个函数首先设置了这个框架所需的对象，即  

// - 一个 MeshWorker::IntegrationInfoBox 对象，它将提供单元格上正交点的所有需要的数据。这个对象可以看作是FEValues的扩展，提供更多的有用信息。 

// - 一个 MeshWorker::DoFInfo 对象，它一方面扩展了单元格迭代器的功能，另一方面也为其基类LocalResults的返回值提供了空间。 

// - 一个汇编器，在这里是指整个系统。这里的 "简单 "指的是全局系统没有一个块状结构。 

// - 本地集成器，它实现了实际的形式。

// 在循环将所有这些组合成一个矩阵和一个右手边之后，还有一件事要做：集合器对受限自由度的矩阵行和列不做任何处理。因此，我们在对角线上放一个一，使整个系统摆好。一的值或任何固定的值都有一个好处，即它对矩阵的频谱的影响很容易理解。由于相应的特征向量形成了一个不变的子空间，所选择的值不会影响Krylov空间求解器的收敛性。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_system() 
  { 
    MappingQ1<dim>                      mapping; 
    MeshWorker::IntegrationInfoBox<dim> info_box; 
    UpdateFlags                         update_flags = 
      update_values | update_gradients | update_hessians; 
    info_box.add_update_flags_all(update_flags); 
    info_box.initialize(fe, mapping); 

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

    MeshWorker::Assembler::SystemSimple<SparseMatrix<double>, Vector<double>> 
      assembler; 
    assembler.initialize(constraints); 
    assembler.initialize(system_matrix, system_rhs); 

    LaplaceIntegrator<dim> matrix_integrator; 
    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(), 
                                           dof_handler.end(), 
                                           dof_info, 
                                           info_box, 
                                           matrix_integrator, 
                                           assembler); 

    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i) 
      if (constraints.is_constrained(i)) 
        system_matrix.set(i, i, 1.); 
  } 
// @sect4{LaplaceProblem::assemble_multigrid}  

// 下一个函数是建立线性算子（矩阵），定义每一级网格上的多栅方法。积分的核心和上面的一样，但是下面的循环会遍历所有已有的单元，而不仅仅是活动的单元，而且结果必须输入正确的层次矩阵。幸运的是，MeshWorker对我们隐藏了大部分的内容，因此这个函数和之前的函数的区别只在于汇编器的设置和循环中不同的迭代器。另外，最后修复矩阵的过程也比较复杂。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_multigrid() 
  { 
    MappingQ1<dim>                      mapping; 
    MeshWorker::IntegrationInfoBox<dim> info_box; 
    UpdateFlags                         update_flags = 
      update_values | update_gradients | update_hessians; 
    info_box.add_update_flags_all(update_flags); 
    info_box.initialize(fe, mapping); 

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

    MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler; 
    assembler.initialize(mg_constrained_dofs); 
    assembler.initialize(mg_matrices); 
    assembler.initialize_interfaces(mg_interface_in, mg_interface_out); 

    LaplaceIntegrator<dim> matrix_integrator; 
    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_mg(), 
                                           dof_handler.end_mg(), 
                                           dof_info, 
                                           info_box, 
                                           matrix_integrator, 
                                           assembler); 

    const unsigned int nlevels = triangulation.n_levels(); 
    for (unsigned int level = 0; level < nlevels; ++level) 
      { 
        for (unsigned int i = 0; i < dof_handler.n_dofs(level); ++i) 
          if (mg_constrained_dofs.is_boundary_index(level, i) || 
              mg_constrained_dofs.at_refinement_edge(level, i)) 
            mg_matrices[level].set(i, i, 1.); 
      } 
  } 

//  @sect4{LaplaceProblem::solve}  

// 这是另外一个在支持多栅求解器（或者说，事实上，我们使用多栅方法的前提条件）方面有明显不同的函数。

// 让我们从建立多层次方法的两个组成部分开始：层次间的转移运算器和最粗层次上的求解器。在有限元方法中，转移算子来自所涉及的有限元函数空间，通常可以用独立于所考虑问题的通用方式计算。在这种情况下，我们可以使用MGTransferPrebuilt类，给定最终线性系统的约束和MGConstrainedDoFs对象，该对象知道每个层次的边界条件和不同细化层次之间接口的自由度，可以从具有层次自由度的DoFHandler对象中建立这些转移操作的矩阵。

// 下面几行的第二部分是关于粗略网格求解器的。由于我们的粗网格确实非常粗，我们决定采用直接求解器（最粗层次矩阵的Householder分解），即使其实现不是特别复杂。如果我们的粗网格比这里的5个单元多得多，那么这里显然需要更合适的东西。

  template <int dim> 
  void LaplaceProblem<dim>::solve() 
  { 
    MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs); 
    mg_transfer.build(dof_handler); 

    FullMatrix<double> coarse_matrix; 
    coarse_matrix.copy_from(mg_matrices[0]); 
    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver; 
    coarse_grid_solver.initialize(coarse_matrix); 

// 多级求解器或预处理器的下一个组成部分是，我们需要在每一级上有一个平滑器。这方面常见的选择是使用松弛方法的应用（如SOR、Jacobi或Richardson方法）或求解器方法的少量迭代（如CG或GMRES）。 mg::SmootherRelaxation 和MGSmootherPrecondition类为这两种平滑器提供支持。这里，我们选择应用单一的SOR迭代。为此，我们定义一个适当的别名，然后设置一个平滑器对象。

// 最后一步是用我们的水平矩阵初始化平滑器对象，并设置一些平滑参数。 <code>initialize()</code> 函数可以有选择地接受额外的参数，这些参数将被传递给每一级的平滑器对象。在当前SOR平滑器的情况下，这可能包括一个松弛参数。然而，我们在这里将这些参数保留为默认值。对 <code>set_steps()</code> 的调用表明我们将在每个级别上使用两个前平滑步骤和两个后平滑步骤；为了在不同级别上使用可变数量的平滑器步骤，可以在对 <code>mg_smoother</code> 对象的构造函数调用中设置更多选项。

// 最后一步的结果是我们使用SOR方法作为平滑器的事实

// --这不是对称的

// 但我们在下面使用共轭梯度迭代（需要对称的预处理），我们需要让多级预处理确保我们得到一个对称的算子，即使是非对称的平滑器。

    using Smoother = PreconditionSOR<SparseMatrix<double>>; 
    mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother; 
    mg_smoother.initialize(mg_matrices); 
    mg_smoother.set_steps(2); 
    mg_smoother.set_symmetric(true); 

// 下一个准备步骤是，我们必须将我们的水平矩阵和接口矩阵包裹在一个具有所需乘法函数的对象中。我们将为从粗到细的接口对象创建两个对象，反之亦然；多网格算法将在以后的操作中使用转置运算器，允许我们用已经建立的矩阵初始化该运算器的上下版本。

    mg::Matrix<Vector<double>> mg_matrix(mg_matrices); 
    mg::Matrix<Vector<double>> mg_interface_up(mg_interface_in); 
    mg::Matrix<Vector<double>> mg_interface_down(mg_interface_out); 

// 现在，我们准备设置V型循环算子和多级预处理程序。

    Multigrid<Vector<double>> mg( 
      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother); 
    mg.set_edge_matrices(mg_interface_down, mg_interface_up); 

    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>> 
      preconditioner(dof_handler, mg, mg_transfer); 

// 有了这一切，我们终于可以用通常的方法来解决这个线性系统了。

    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> solver(solver_control); 

    solution = 0; 

    solver.solve(system_matrix, solution, system_rhs, preconditioner); 
    constraints.distribute(solution); 
  } 

//  @sect4{Postprocessing}  

// 下面两个函数在计算出解决方案后对其进行后处理。特别是，第一个函数在每个周期开始时细化网格，第二个函数在每个周期结束时输出结果。这些函数与 step-6 中的函数几乎没有变化，只有一个小的区别：我们以VTK格式生成输出，以使用当今更现代的可视化程序，而不是 step-6 编写时的那些。

  template <int dim> 
  void LaplaceProblem<dim>::refine_grid() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      estimated_error_per_cell); 
    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 
    triangulation.execute_coarsening_and_refinement(); 
  } 

  template <int dim> 
  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(); 

    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk"); 
    data_out.write_vtk(output); 
  } 
// @sect4{LaplaceProblem::run}  

// 和上面的几个函数一样，这几乎是对  step-6  中相应函数的复制。唯一的区别是对 <code>assemble_multigrid</code> 的调用，它负责形成我们在多网格方法中需要的每一层的矩阵。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 8; ++cycle) 
      { 
        deallog << "Cycle " << cycle << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_ball(triangulation); 
            triangulation.refine_global(1); 
          } 
        else 
          refine_grid(); 

        deallog << "   Number of active cells:       " 
                << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        assemble_system(); 
        assemble_multigrid(); 

        solve(); 
        output_results(cycle); 
      } 
  } 
} // namespace Step16 
// @sect3{The main() function}  

// 这又是与 step-6 中相同的函数。

int main() 
{ 
  try 
    { 
      using namespace Step16; 

      deallog.depth_console(2); 

      LaplaceProblem<2> laplace_problem(1); 
      laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-17.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2000 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 
 * Author: Wolfgang Bangerth, University of Texas at Austin, 2000, 2004 
 *         Wolfgang Bangerth, Texas A&M University, 2016 
 */ 


// @sect3{Include files}  

// 首先是我们在以前的例子程序中已经使用过的常见的各种头文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/multithread_info.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparsity_tools.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 这里是我们对这个例子程序特别需要的东西，而这些东西并不在  step-8  中。首先，我们替换掉标准输出 <code>std::cout</code> by a new stream <code>pcout</code> ，它在并行计算中只用于在其中一个MPI进程中生成输出。

#include <deal.II/base/conditional_ostream.h> 

// 我们将通过调用  Utilities::MPI  名称空间中的相应函数来查询进程的数量和当前进程的数量。

#include <deal.II/base/mpi.h> 

// 然后，我们要把所有涉及（全局）线性系统的线性代数组件替换成类，这些类围绕PETSc提供的接口与我们自己的线性代数类相似（PETSc是一个用C语言编写的库，而deal.II附带的包装类提供的PETSc功能的接口与我们自己的线性代数类已经有的接口相似）。特别是，我们需要在MPI程序中分布在几个 @ref GlossMPIProcess "进程 "中的向量和矩阵（如果只有一个进程，也就是说，如果你只在一台机器上运行，并且没有MPI支持，则简单映射为顺序的、本地的向量和矩阵）。

#include <deal.II/lac/petsc_vector.h> 
#include <deal.II/lac/petsc_sparse_matrix.h> 

// 然后，我们还需要PETSc提供的求解器和预处理器的接口。

#include <deal.II/lac/petsc_solver.h> 
#include <deal.II/lac/petsc_precondition.h> 

// 此外，我们还需要一些划分网格的算法，以便在MPI网络上有效地分布这些网格。分区算法在 <code>GridTools</code> 命名空间中实现，我们需要一个额外的包含文件，用于 <code>DoFRenumbering</code> 中的一个函数，该函数允许对与自由度相关的索引进行排序，以便根据它们所关联的子域进行编号。

#include <deal.II/grid/grid_tools.h> 
#include <deal.II/dofs/dof_renumbering.h> 

// 而这又是简单的C++。

#include <fstream> 
#include <iostream> 

// 最后一步和以前所有的程序一样。

namespace Step17 
{ 
  using namespace dealii; 
// @sect3{The <code>ElasticProblem</code> class template}  

// 该程序的第一个真正的部分是主类的声明。 正如在介绍中提到的，几乎所有的内容都是从 step-8 中逐字复制过来的，所以我们只对这两个教程之间的少数差异进行评论。 有一个（表面上的）变化是，我们让 <code>solve</code> 返回一个值，即收敛所需的迭代次数，这样我们就可以在适当的地方将其输出到屏幕上。

  template <int dim> 
  class ElasticProblem 
  { 
  public: 
    ElasticProblem(); 
    void run(); 

  private: 
    void         setup_system(); 
    void         assemble_system(); 
    unsigned int solve(); 
    void         refine_grid(); 
    void         output_results(const unsigned int cycle) const; 

// 第一个变化是，我们必须声明一个变量，表明我们应该通过它来分配我们的计算的 @ref GlossMPICommunicator "MPI通信器"。

    MPI_Comm mpi_communicator; 

// 然后我们有两个变量，告诉我们在并行世界中的位置。下面的第一个变量， <code>n_mpi_processes</code>  ，告诉我们总共有多少个MPI进程，而第二个变量， <code>this_mpi_process</code>  ，表示在这个进程空间中，目前进程的编号（在MPI语言中，这相当于进程的 @ref GlossMPIRank  "等级"）。后者对每个进程都有一个唯一的值，介于0和（小于） <code>n_mpi_processes</code>  之间。如果这个程序运行在没有MPI支持的单机上，那么它们的值分别为 <code>1</code> and <code>0</code>  ，。

    const unsigned int n_mpi_processes; 
    const unsigned int this_mpi_process; 

// 接下来是一个类似流的变量  <code>pcout</code>  。从本质上讲，它只是我们为了方便而使用的东西：在一个并行程序中，如果每个进程都输出状态信息，那么很快就会有很多杂乱的信息。相反，我们希望只让一个 @ref GlossMPIProcess "进程 "输出一次所有的信息，例如， @ref GlossMPIRank "等级 "为零的那个。同时，在我们创建输出的<i>every</i>地方加上 <code>if (my_rank==0)</code> 条件的前缀似乎很傻。

// 为了使这个问题更简单，ConditionalOStream类正是这样做的：它就像一个流一样，但只有在一个标志被设置后才转发到一个真正的、底层的流。通过将这个条件设置为 <code>this_mpi_process==0</code> （其中 <code>this_mpi_process</code> 对应于MPI进程的等级），我们确保输出只从第一个进程中产生，并且我们不会在每个进程中重复得到同样的输出行。因此，我们可以在每一个地方和每一个进程中使用 <code>pcout</code> ，但是除了一个进程之外，所有的进程都不会发生通过 <code>operator&lt;&lt;</code> 输送到对象中的信息。

    ConditionalOStream pcout; 

// 成员变量列表的其余部分与  step-8  中的内容基本相同。然而，我们改变了矩阵和矢量类型的声明，以使用并行的PETSc对象代替。请注意，我们没有使用单独的稀疏模式，因为PETSc将其作为矩阵数据结构的一部分进行内部管理。

    Triangulation<dim> triangulation; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> hanging_node_constraints; 

    PETScWrappers::MPI::SparseMatrix system_matrix; 

    PETScWrappers::MPI::Vector solution; 
    PETScWrappers::MPI::Vector system_rhs; 
  }; 
// @sect3{Right hand side values}  

// 以下内容取自 step-8 ，未作改动。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  values) const override 
    { 
      Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim)); 
      Assert(dim >= 2, ExcInternalError()); 

      Point<dim> point_1, point_2; 
      point_1(0) = 0.5; 
      point_2(0) = -0.5; 

      if (((p - point_1).norm_square() < 0.2 * 0.2) || 
          ((p - point_2).norm_square() < 0.2 * 0.2)) 
        values(0) = 1; 
      else 
        values(0) = 0; 

      if (p.square() < 0.2 * 0.2) 
        values(1) = 1; 
      else 
        values(1) = 0; 
    } 

    virtual void 
    vector_value_list(const std::vector<Point<dim>> &points, 
                      std::vector<Vector<double>> &  value_list) const override 
    { 
      const unsigned int n_points = points.size(); 

      Assert(value_list.size() == n_points, 
             ExcDimensionMismatch(value_list.size(), n_points)); 

      for (unsigned int p = 0; p < n_points; ++p) 
        RightHandSide<dim>::vector_value(points[p], value_list[p]); 
    } 
  }; 

//  @sect3{The <code>ElasticProblem</code> class implementation}  
// @sect4{ElasticProblem::ElasticProblem}  

// 实际实现的第一步是主类的构造函数。除了初始化我们在 step-8 中已经有的相同成员变量外，我们在这里用连接所有进程的全局MPI通信器来初始化我们将使用的MPI通信器变量（在更复杂的应用中，可以在这里使用只连接所有进程的一个子集的通信器对象），并调用 Utilities::MPI 辅助函数来确定进程的数量以及当前进程在这个画面中的地位。此外，我们确保输出只由（全局）第一个进程产生。我们通过将我们想要输出的流传给 (<code>std::cout</code>) 和一个真/假标志作为参数，后者是通过测试当前执行构造函数调用的进程是否是MPI宇宙中的第一个来确定的。

  template <int dim> 
  ElasticProblem<dim>::ElasticProblem() 
    : mpi_communicator(MPI_COMM_WORLD) 
    , n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator)) 
    , this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator)) 
    , pcout(std::cout, (this_mpi_process == 0)) 
    , fe(FE_Q<dim>(1), dim) 
    , dof_handler(triangulation) 
  {} 

//  @sect4{ElasticProblem::setup_system}  

// 接下来，我们需要实现为要解决的全局线性系统设置各种变量的函数。

// 然而，在我们进行这项工作之前，对于一个并行程序来说，有一件事要做：我们需要确定哪个MPI进程负责每个单元。在进程之间分割单元，通常称为 "划分网格"，是通过给每个单元分配一个 @ref GlossSubdomainId "子域id "来完成的。我们通过调用METIS库来完成这一工作，METIS库以一种非常有效的方式完成这一工作，试图将子域之间接口上的节点数量降到最低。我们没有尝试直接调用METIS，而是通过调用 GridTools::partition_triangulation() 函数来实现，该函数在更高的编程水平上实现了这一点。

//  @note  正如在介绍中提到的，如果我们使用 parallel::shared::Triangulation 类来代替三角形对象，我们就可以避免这个手动划分的步骤（正如我们在 step-18 中所做的）。  该类实质上做了所有常规三角形的工作，但它也在每次创建或细化网格操作后自动划分网格。

// 在分割之后，我们需要像往常一样列举所有的自由度。 然而，我们希望列举自由度的方式是：所有与子域0（位于进程0）的单元相关的自由度都在与子域1的单元相关的自由度之前，在进程2的单元之前，以此类推。我们需要这样做，因为我们必须将全局向量的右手边和解决方案，以及矩阵分割成连续的行块，住在每个处理器上，而且我们希望以一种需要最小通信的方式来做。这个特殊的列举可以通过使用 DoFRenumbering::subdomain_wise(). 对自由度指数重新排序来获得。

// 这个初始设置的最后一步是，我们为自己得到一个IndexSet，表示这个过程所负责的全局未知数的子集。(注意，一个自由度不一定是由拥有一个单元的进程所拥有，只是因为这个自由度生活在这个单元上：有些自由度生活在子域之间的接口上，因此只由这个接口附近的一个进程所拥有。)

// 在我们继续之前，让我们回顾一下在介绍中已经讨论过的一个事实。我们在这里使用的三角形是在所有进程中复制的，每个进程都有整个三角形的完整副本，包括所有单元。分区只提供了一种方法来确定每个进程 "拥有 "哪些单元，但它知道所有单元的一切。同样，DoFHandler对象知道每个单元的一切，特别是每个单元上的自由度，无论它是否是当前进程拥有的单元。这不能扩展到大型问题，因为如果问题足够大，最终只是在每个进程中存储整个网格以及与之相关的所有内容将变得不可行。另一方面，如果我们将三角形分割成若干部分，使每个进程只存储它 "拥有 "的单元格，而不存储其他的单元格（或者，至少是其他单元格的一小部分），那么，只要我们将足够多的MPI进程扔给它们，我们就可以解决大问题。这就是我们在 step-40 中要做的，例如，使用 parallel::distributed::Triangulation 类。 另一方面，我们在当前程序中演示的其余大部分内容实际上将继续工作，无论我们有整个三角形的可用，还是只有其中的一部分。

  template <int dim> 
  void ElasticProblem<dim>::setup_system() 
  { 
    GridTools::partition_triangulation(n_mpi_processes, triangulation); 

    dof_handler.distribute_dofs(fe); 
    DoFRenumbering::subdomain_wise(dof_handler); 

// 我们需要初始化表示当前网格的悬挂节点约束的对象。与三角形和DoFHandler对象一样，我们将简单地在每个进程上存储<i>all</i>约束；同样，这不会有规模，但我们在 step-40 中展示了如何通过在每个MPI进程上只存储对这个特定进程实际重要的自由度约束来解决这个问题。

    hanging_node_constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

// 现在我们为系统矩阵创建稀疏性模式。请注意，我们再次计算并存储所有条目，而不仅仅是与此相关的条目（参见 step-18 或 step-40 ，以获得更有效的处理方式）。

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    hanging_node_constraints, 
                                    false); 

// 现在我们确定本地拥有的DoF的集合，并使用它来初始化并行向量和矩阵。由于矩阵和向量需要并行工作，我们必须向它们传递一个MPI通信对象，以及IndexSet  @p locally_owned_dofs. 中包含的分区信息。IndexSet包含关于全局大小（<i>total</i>自由度数）的信息，也包含要在本地存储哪些行的子集。 注意，系统矩阵需要该行和列的分区信息。对于正方形矩阵，就像这里的情况一样，列的划分方式应该与行的划分方式相同，但是对于矩形矩阵，我们必须按照与矩阵相乘的向量的划分方式来划分列，而行的划分方式必须与矩阵-向量乘法的目的向量相同。

    const std::vector<IndexSet> locally_owned_dofs_per_proc = 
      DoFTools::locally_owned_dofs_per_subdomain(dof_handler); 
    const IndexSet locally_owned_dofs = 
      locally_owned_dofs_per_proc[this_mpi_process]; 

    system_matrix.reinit(locally_owned_dofs, 
                         locally_owned_dofs, 
                         dsp, 
                         mpi_communicator); 

    solution.reinit(locally_owned_dofs, mpi_communicator); 
    system_rhs.reinit(locally_owned_dofs, mpi_communicator); 
  } 

//  @sect4{ElasticProblem::assemble_system}  

// 我们现在组装矩阵和问题的右手边。在我们进行详细讨论之前，有一些事情值得一提。首先，我们将并行组装系统，也就是说，每个进程将负责在属于这个特定进程的单元上进行组装。请注意，自由度的分割方式是，单元内部和属于同一子域的单元之间的所有自由度都属于 <code>owns</code> 该单元的过程。然而，即使如此，我们有时也需要在一个单元上与属于不同过程的邻居集合，在这些情况下，当我们将局部贡献加到全局矩阵或右手向量中时，我们必须将这些条目转移到拥有这些元素的过程中。幸运的是，我们不需要用手去做这件事。PETSc为我们做了这一切，它在本地缓存了这些元素，当我们在这个函数的末尾对矩阵和向量调用 <code>compress()</code> 函数时，根据需要将它们发送给其他进程。

// 第二点是，一旦我们把矩阵和向量的贡献交给了PETSc，那么，a）很难，b）要把它们拿回来进行修改，效率非常低。这不仅是PETSc的错，也是这个程序的分布式性质的结果：如果一个条目驻留在另一个处理器上，那么要得到它必然是很昂贵的。这样做的后果是，我们不应该试图首先组装矩阵和右手边，就像没有悬挂的节点约束和边界值一样，然后在第二步中消除这些约束（例如使用 AffineConstraints::condense()). ），相反，我们应该在将这些条目交给PETSc之前尝试消除悬挂的节点约束。这很容易：我们不需要手工复制元素到全局矩阵中（就像我们在 step-4 中做的那样），而是使用 AffineConstraints::distribute_local_to_global() 函数来同时处理悬空节点的问题。我们在  step-6  中也已经这样做了。第二步，消除边界节点，也可以这样做，把边界值放到与悬挂节点相同的AffineConstraints对象中（例如，见 step-6 中的方法）；但是，严格来说，在这里没有必要这样做，因为消除边界值可以只用每个进程本身存储的数据来完成，因此，我们使用之前在 step-4 中使用的方法，即通过 MatrixTools::apply_boundary_values().  

// 说了这么多，下面是实际的实现，从辅助变量的一般设置开始。 请注意，我们仍然使用deal.II的全矩阵和向量类型的本地系统，因为这些类型很小，不需要在不同进程中共享）。

  template <int dim> 
  void ElasticProblem<dim>::assemble_system() 
  { 
    QGauss<dim>   quadrature_formula(fe.degree + 1); 
    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    std::vector<double> lambda_values(n_q_points); 
    std::vector<double> mu_values(n_q_points); 

    Functions::ConstantFunction<dim> lambda(1.), mu(1.); 

    RightHandSide<dim>          right_hand_side; 
    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim)); 

// 接下来是对所有元素的循环。请注意，我们不需要在每个进程上做<i>all</i>的工作：我们在这里的工作只是在实际属于这个MPI进程的单元上组装系统，所有其他的单元将由其他进程来处理。这就是紧随for-loop之后的if-clause所要处理的：它查询每个单元的子域标识符，这是一个与每个单元相关的数字，告诉我们所有者进程的情况。在更大的范围内，子域标识被用来将一个域分成几个部分（我们在上面 <code>setup_system()</code> 的开头就这样做了），并允许识别一个单元生活在哪个子域。在这个应用中，我们让每个进程恰好处理一个子域，所以我们确定了  <code>subdomain</code> and <code>MPI process</code>  的条款。

// 除此以外，如果你已经了解了  step-8  中的组装方式，那么组装本地系统就相对不容易了。如上所述，将本地贡献分配到全局矩阵和右手边，也是以与  step-6  中相同的方式来处理悬挂节点约束。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->subdomain_id() == this_mpi_process) 
        { 
          cell_matrix = 0; 
          cell_rhs    = 0; 

          fe_values.reinit(cell); 

          lambda.value_list(fe_values.get_quadrature_points(), lambda_values); 
          mu.value_list(fe_values.get_quadrature_points(), mu_values); 

          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const unsigned int component_i = 
                fe.system_to_component_index(i).first; 

              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const unsigned int component_j = 
                    fe.system_to_component_index(j).first; 

                  for (unsigned int q_point = 0; q_point < n_q_points; 
                       ++q_point) 
                    { 
                      cell_matrix(i, j) += 
                        ((fe_values.shape_grad(i, q_point)[component_i] * 
                          fe_values.shape_grad(j, q_point)[component_j] * 
                          lambda_values[q_point]) + 
                         (fe_values.shape_grad(i, q_point)[component_j] * 
                          fe_values.shape_grad(j, q_point)[component_i] * 
                          mu_values[q_point]) + 
                         ((component_i == component_j) ? 
                            (fe_values.shape_grad(i, q_point) * 
                             fe_values.shape_grad(j, q_point) * 
                             mu_values[q_point]) : 
                            0)) * 
                        fe_values.JxW(q_point); 
                    } 
                } 
            } 

          right_hand_side.vector_value_list(fe_values.get_quadrature_points(), 
                                            rhs_values); 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const unsigned int component_i = 
                fe.system_to_component_index(i).first; 

              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
                cell_rhs(i) += fe_values.shape_value(i, q_point) * 
                               rhs_values[q_point](component_i) * 
                               fe_values.JxW(q_point); 
            } 

          cell->get_dof_indices(local_dof_indices); 
          hanging_node_constraints.distribute_local_to_global(cell_matrix, 
                                                              cell_rhs, 
                                                              local_dof_indices, 
                                                              system_matrix, 
                                                              system_rhs); 
        } 

// 下一步是对向量和系统矩阵进行 "压缩"。这意味着每个进程将对矩阵和向量中那些自己不拥有的条目所做的添加发送给拥有这些条目的进程。在收到其他进程的这些加法后，每个进程再把它们加到它已经拥有的值上。这些加法是将生活在几个单元上的形状函数的积分贡献结合起来，就像在串行计算中一样，不同的是这些单元被分配给不同的进程。

    system_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 

// 全局矩阵和右边的向量现在已经形成。我们仍然要应用边界值，方法与我们在 step-3 ,  step-4 , 和其他一些程序中的方法相同。

// 下面调用 MatrixTools::apply_boundary_values() 的最后一个参数允许进行一些优化。它控制我们是否应该删除对应于边界节点的矩阵列中的条目（即，将其设置为零），或者保留它们（通过 <code>true</code> 意味着：是的，消除这些列）。如果我们消除了列，那么结果矩阵将再次成为对称的，如果我们不这样做，那么它将不会。不过，结果系统的解应该是一样的。我们想让系统重新成为对称的唯一原因是我们想使用CG方法，该方法只对对称矩阵有效。我们可能<i>not</i>想让矩阵对称的原因是，这将要求我们写进实际存在于其他进程中的列项，即涉及到数据的交流。这总是很昂贵的。

// 经验告诉我们，如果我们不删除与边界节点相关的列，CG也可以工作（而且工作得几乎一样好），这可以用这种特殊的非对称性结构来解释。为了避免通信的费用，我们因此不消除受影响列中的条目。

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(dim), 
                                             boundary_values); 
    MatrixTools::apply_boundary_values( 
      boundary_values, system_matrix, solution, system_rhs, false); 
  } 

//  @sect4{ElasticProblem::solve}  

// 组建了线性系统后，我们接下来需要解决它。PETSc提供了各种顺序和并行求解器，我们为这些求解器编写了包装器，其接口与之前所有示例程序中使用的deal.II求解器几乎相同。因此，下面的代码看起来应该相当熟悉。

// 在该函数的顶部，我们设置了一个收敛监视器，并指定了我们希望解决线性系统的精度。接下来，我们使用PETSc的CG求解器创建一个实际的求解器对象，该求解器也可用于并行（分布式）矢量和矩阵。最后是一个预处理程序；我们选择使用一个块状雅可比预处理程序，它通过计算矩阵的每个对角线块的不完全LU分解来工作。 换句话说，每个MPI进程从其存储的行中计算出一个ILU，丢掉与本地未存储的行指数相对应的列；这就产生了一个方形的矩阵块，我们可以从中计算出一个ILU。这意味着如果你只用一个进程来运行程序，那么你将使用一个ILU(0)作为预处理程序，而如果它在许多进程上运行，那么我们将在对角线上有许多块，预处理程序是这些块中每个块的ILU(0)。在每个处理器只有一个自由度的极端情况下，这个预处理程序只是一个雅可比预处理程序，因为对角线矩阵块只由一个条目组成。这样的预处理程序相对容易计算，因为它不需要在处理器之间进行任何形式的通信，但一般来说，对于大量的处理器来说，它的效率并不高)。

// 按照这样的设置，我们就可以解决这个线性系统。

  template <int dim> 
  unsigned int ElasticProblem<dim>::solve() 
  { 
    SolverControl solver_control(solution.size(), 1e-8 * system_rhs.l2_norm()); 
    PETScWrappers::SolverCG cg(solver_control, mpi_communicator); 

    PETScWrappers::PreconditionBlockJacobi preconditioner(system_matrix); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

// 下一步是分配悬挂的节点约束。这有点麻烦，因为要填入一个约束节点的值，你需要访问它所约束的节点的值（例如，对于2d中的Q1元素，我们需要访问悬挂节点面的大边上的两个节点，以计算中间的约束节点的值）。

// 问题是，我们已经建立了我们的向量（在 <code>setup_system()</code> 中），使每个进程只负责存储解向量中与该进程 "拥有 "的自由度相对应的那些元素。然而，在有些情况下，为了计算一个进程中受限自由度的向量项的值，我们需要访问存储在其他进程中的向量项。 PETSc（以及它所基于的MPI模型）不允许简单地查询存储在其他进程上的向量条目，所以我们在这里所做的是获得一个 "分布式 "向量的副本，我们将所有元素存储在本地。这很简单，因为deal.II包装器有一个针对deal.II Vector类的转换构造函数。这种转换当然需要通信，但实质上每个进程只需要将其数据批量发送给其他每个进程一次，而不需要对单个元素的查询做出回应）。

    Vector<double> localized_solution(solution); 

// 当然，和以前的讨论一样，如果你想在大量进程上解决大问题，这样的步骤显然不能扩展得很远，因为现在每个进程都存储了<i>all elements</i>的解向量。(我们将在 step-40 中展示如何更好地做到这一点。) 另一方面，在这个本地副本上分配悬挂节点约束很简单，使用通常的函数 AffineConstraints::distributed().  特别是，我们可以计算<i>all</i>约束自由度的值，无论当前进程是否拥有它们。

    hanging_node_constraints.distribute(localized_solution); 

// 然后把所有的东西都转回全局向量中。下面的操作是复制我们在分布式解决方案中本地存储的那些本地化解决方案的元素，而不碰其他的。由于我们在所有处理器上做同样的操作，我们最终得到一个分布式向量（即在每个进程上只存储与该进程拥有的自由度相对应的向量项），该向量的所有受限节点都被固定。

// 我们通过返回收敛所需的迭代次数来结束这个函数，以允许一些输出。

    solution = localized_solution; 

    return solver_control.last_step(); 
  } 
// @sect4{ElasticProblem::refine_grid}  

// 使用某种细化指标，可以对网格进行细化。这个问题与分布悬挂节点约束基本相同：为了计算误差指标（即使我们只是对当前进程拥有的单元上的指标感兴趣），我们需要访问解向量的更多元素，而不仅仅是当前处理器存储的那些元素。为了实现这一点，我们基本上做了我们在 <code>solve()</code> 中已经做过的事情，即获取<i>complete</i>解向量的副本到每个进程中，并使用它来计算。如上所述，这本身就很昂贵，尤其是没有必要，因为我们刚刚在 <code>solve()</code> 中创建并销毁了这样一个向量，但效率并不是这个程序的重点，所以让我们选择一种设计，即每个函数都尽可能地独立。

// 一旦我们有了这样一个包含<i>all</i>解向量元素的 "本地化 "向量，我们就可以计算属于当前过程的单元的指标。事实上，我们当然可以计算<i>all</i>细化指标，因为我们的Triangulation和DoFHandler对象存储了所有单元的信息，而且我们有一个完整的解向量副本。但是为了展示如何进行%并行操作，让我们演示一下，如果只计算<i>some</i>错误指标，然后与其他进程交换剩余的指标，会如何操作。(最终，每个进程都需要一套完整的细化指标，因为每个进程都需要细化他们的网格，并且需要以与其他进程完全相同的方式细化它。)

// 所以，为了做到这一切，我们需要。

// - 首先，获得分布式求解向量的本地拷贝。

// - 第二，创建一个向量来存储细化指标。

// - 第三，让KellyErrorEstimator计算属于当前子域/过程的所有单元的细化指标。调用的最后一个参数表明我们对哪个子域感兴趣。在它之前的三个参数是其他各种默认参数，通常不需要（也不说明数值，而是使用默认值），但我们必须在这里明确说明，因为我们要修改下面一个参数的值（即表示子域的参数）。

  template <int dim> 
  void ElasticProblem<dim>::refine_grid() 
  { 
    const Vector<double> localized_solution(solution); 

    Vector<float> local_error_per_cell(triangulation.n_active_cells()); 
    KellyErrorEstimator<dim>::estimate(dof_handler, 
                                       QGauss<dim - 1>(fe.degree + 1), 
                                       {}, 
                                       localized_solution, 
                                       local_error_per_cell, 
                                       ComponentMask(), 
                                       nullptr, 
                                       MultithreadInfo::n_threads(), 
                                       this_mpi_process); 

// 现在所有进程都计算了自己单元格的错误指标，并将其存储在 <code>local_error_per_cell</code> 向量的相应元素中。这个向量中不属于本进程的单元格的元素为零。然而，由于所有进程都有整个三角形的副本，并需要保持这些副本的同步，他们需要三角形的所有单元的细化指标值。因此，我们需要分配我们的结果。我们通过创建一个分布式向量来做到这一点，每个进程都有自己的份额，并设置它所计算的元素。因此，当你把这个向量看作是一个存在于所有进程中的向量时，那么这个向量的每个元素都被设置过一次。然后，我们可以将这个并行向量分配给每个进程上的一个本地非并行向量，使<i>all</i>错误指示器在每个进程上都可用。
//因此，
//在第一步，我们需要设置一个并行向量。为了简单起见，每个进程都将拥有一个元素块，其数量与该进程拥有的单元格一样多，因此第一个元素块存储在进程0，下一个元素块存储在进程1，以此类推。然而，需要注意的是，这些元素不一定是我们要写入的元素。这是单元格排列顺序的结果，也就是说，向量中的元素对应单元格的顺序并不是根据这些单元格所属的子域来排序的。换句话说，如果在这个过程中，我们计算某个子域的单元的指标，我们可能会把结果写到分布式向量的或多或少的随机元素中；特别是，它们不一定位于我们在这个过程中拥有的向量块中。它们随后将不得不被复制到另一个进程的内存空间中，当我们调用 <code>compress()</code> 函数时，PETSc为我们做了这项操作。这种低效率可以通过更多的代码来避免，但我们不这样做，因为它不是程序总运行时间的一个主要因素。

// 所以我们是这样做的：计算有多少个单元属于这个过程，建立一个有这么多元素的分布式向量存储在本地，将我们在本地计算的元素复制过去，最后将结果压缩。事实上，我们实际上只复制了非零的元素，所以我们可能会错过一些我们计算为零的元素，但这不会有什么影响，因为无论如何，向量的原始值是零。

    const unsigned int n_local_cells = 
      GridTools::count_cells_with_subdomain_association(triangulation, 
                                                        this_mpi_process); 
    PETScWrappers::MPI::Vector distributed_all_errors( 
      mpi_communicator, triangulation.n_active_cells(), n_local_cells); 

    for (unsigned int i = 0; i < local_error_per_cell.size(); ++i) 
      if (local_error_per_cell(i) != 0) 
        distributed_all_errors(i) = local_error_per_cell(i); 
    distributed_all_errors.compress(VectorOperation::insert); 

// 所以现在我们有了这个分布式向量，它包含了所有单元的细化指标。为了使用它，我们需要获得一个本地副本，然后用它来标记要细化或粗化的单元，并实际进行细化和粗化。重要的是要认识到，<i>every</i>过程对它自己的三角形副本做了这个工作，并且以完全相同的方式进行。

    const Vector<float> localized_all_errors(distributed_all_errors); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    localized_all_errors, 
                                                    0.3, 
                                                    0.03); 
    triangulation.execute_coarsening_and_refinement(); 
  } 
// @sect4{ElasticProblem::output_results}  

// 最后一个有意义的函数是创建图形输出的函数。它的工作方式与 step-8 中的相同，但有两个小的区别。在讨论这些之前，让我们说明这个函数的一般工作原理：我们打算让所有的数据都在一个进程中产生，然后写入一个文件中。正如本程序的许多其他部分已经讨论过的那样，这不是一个可以扩展的东西。之前，我们认为我们会在三角计算、DoFHandlers和解决方案向量的副本方面遇到麻烦，每个进程都必须存储所有的数据，而且会出现一个点，即每个进程根本没有足够的内存来存储这么多数据。在这里，情况是不同的：不仅是内存，而且运行时间也是一个问题。如果一个进程负责处理<i>all</i>的数据，而其他所有的进程什么都不做，那么这一个函数最终会在程序的整个运行时间中占主导地位。 特别是，这个函数花费的时间将与问题的整体大小（以单元数或自由度数计算）成正比，与我们扔给它的进程数量无关。

// 这种情况需要避免，我们将在 step-18 和 step-40 中展示如何解决这个问题。对于目前的问题，解决方案是让每个进程只为自己的本地单元产生输出数据，并将它们写入单独的文件，每个进程一个文件。这就是 step-18 的操作方式。另外，我们可以简单地把所有的东西放在一组独立的文件中，让可视化软件读取所有的文件（可能也使用多个处理器），并从所有的文件中创建一个单一的可视化；这就是 step-40 、 step-32 以及后来开发的所有其他并行程序的路径。

// 更具体地说，对于当前的函数，所有的进程都调用这个函数，但不是所有的进程都需要做与生成输出相关的工作。事实上，它们不应该这样做，因为我们会试图一次多次地写到同一个文件。所以我们只让第一个进程做这件事，而其他所有的进程在这段时间内闲置（或者为下一次迭代开始工作，或者干脆把它们的CPU让给碰巧在同一时间运行的其他作业）。第二件事是，我们不仅要输出解决方案的向量，还要输出一个向量，表明每个单元属于哪个子域。这将使一些分区域的图片变得很好。

// 为了实现这一点，过程0需要一个完整的本地向量中的解决方案组件。就像前面的函数一样，有效的方法是重新使用在 <code>solve()</code> 函数中已经创建的向量，但是为了使事情更加自洽，我们在这里简单地从分布式解决方案向量中重新创建一个向量。

// 需要认识到的一个重要问题是，我们在所有的进程中都做了这个定位操作，而不是只有那个实际需要数据的进程。然而，这一点是无法避免的，在本教程程序中，我们对向量使用的MPI简化通信模型。MPI没有办法查询另一个进程的数据，双方必须在同一时间启动通信。因此，即使大多数进程不需要本地化的解决方案，我们也必须把将分布式转换为本地化向量的语句放在那里，以便所有进程都执行它。

// （这项工作的一部分实际上可以避免。我们所做的是将所有进程的本地部分发送给所有其他进程。我们真正需要做的是在所有进程上发起一个操作，每个进程只需将其本地的数据块发送给进程0，因为只有这个进程才真正需要它，也就是说，我们需要类似于收集操作的东西。PETSc可以做到这一点，但是为了简单起见，我们在这里并不试图利用这一点。我们没有这样做，因为我们所做的事情在整个计划中并不昂贵：它是所有进程之间的一个矢量通信，这必须与我们在求解线性系统、为预处理程序设置块状ILU以及其他操作时必须进行的通信数量相比较。)

  template <int dim> 
  void ElasticProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    const Vector<double> localized_solution(solution); 

// 这样做后，零进程继续设置输出文件，如  step-8  ，并将（本地化的）解决方案矢量附加到输出对象上。

    if (this_mpi_process == 0) 
      { 
        std::ofstream output("solution-" + std::to_string(cycle) + ".vtk"); 

        DataOut<dim> data_out; 
        data_out.attach_dof_handler(dof_handler); 

        std::vector<std::string> solution_names; 
        switch (dim) 
          { 
            case 1: 
              solution_names.emplace_back("displacement"); 
              break; 
            case 2: 
              solution_names.emplace_back("x_displacement"); 
              solution_names.emplace_back("y_displacement"); 
              break; 
            case 3: 
              solution_names.emplace_back("x_displacement"); 
              solution_names.emplace_back("y_displacement"); 
              solution_names.emplace_back("z_displacement"); 
              break; 
            default: 
              Assert(false, ExcInternalError()); 
          } 

        data_out.add_data_vector(localized_solution, solution_names); 

// 我们在这里做的唯一其他事情是，我们也为每个单元格输出一个值，表明它属于哪个子域（即MPI进程）。这需要一些转换工作，因为库提供给我们的数据不是输出类所期望的数据，但这并不困难。首先，设置一个整数向量，每个单元格一个，然后由每个单元格的子域id填充。

// 这个向量的元素在第二步中被转换为浮点向量，这个向量被添加到DataOut对象中，然后它去创建VTK格式的输出。

        std::vector<unsigned int> partition_int(triangulation.n_active_cells()); 
        GridTools::get_subdomain_association(triangulation, partition_int); 

        const Vector<double> partitioning(partition_int.begin(), 
                                          partition_int.end()); 

        data_out.add_data_vector(partitioning, "partitioning"); 

        data_out.build_patches(); 
        data_out.write_vtk(output); 
      } 
  } 
// @sect4{ElasticProblem::run}  

// 最后，这里是驱动程序的功能。它与 step-8 几乎完全没有变化，只是我们替换了 <code>std::cout</code> by the <code>pcout</code> 流。除此以外，唯一的表面变化是我们输出了每个进程有多少个自由度，以及线性求解器花了多少次收敛。

  template <int dim> 
  void ElasticProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 10; ++cycle) 
      { 
        pcout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation, -1, 1); 
            triangulation.refine_global(3); 
          } 
        else 
          refine_grid(); 

        pcout << "   Number of active cells:       " 
              << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (by partition:"; 
        for (unsigned int p = 0; p < n_mpi_processes; ++p) 
          pcout << (p == 0 ? ' ' : '+') 
                << (DoFTools::count_dofs_with_subdomain_association(dof_handler, 
                                                                    p)); 
        pcout << ")" << std::endl; 

        assemble_system(); 
        const unsigned int n_iterations = solve(); 

        pcout << "   Solver converged in " << n_iterations << " iterations." 
              << std::endl; 

        output_results(cycle); 
      } 
  } 
} // namespace Step17 
// @sect3{The <code>main</code> function}  

//  <code>main()</code> 的工作方式与其他示例程序中的大多数主函数相同，即它将工作委托给管理对象的 <code>run</code> 函数，并且只将所有内容包装成一些代码来捕获异常。

int main(int argc, char **argv) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step17; 

// 这里是唯一真正的区别。MPI和PETSc都要求我们在程序开始时初始化这些库，并在结束时解除初始化。MPI_InitFinalize类处理了所有这些。后面的参数`1`意味着我们确实想让每个MPI进程以单线程运行，这是PETSc并行线性代数的前提条件。

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      ElasticProblem<2> elastic_problem; 
      elastic_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-18.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2000 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Texas at Austin, 2000, 2004, 2005, 
 * Timo Heister, 2013 
 */ 



// 首先是通常的头文件列表，这些文件已经在以前的示例程序中使用过了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/multithread_info.h> 
#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/petsc_vector.h> 
#include <deal.II/lac/petsc_sparse_matrix.h> 
#include <deal.II/lac/petsc_solver.h> 
#include <deal.II/lac/petsc_precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/sparsity_tools.h> 
#include <deal.II/distributed/shared_tria.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 这里是头文件中仅有的三个新东西：一个包含文件，其中实现了等级为2和4的对称张量，正如介绍中所介绍的那样。

#include <deal.II/base/symmetric_tensor.h> 

// 最后是一个包含一些函数的头文件，这些函数将帮助我们计算域中特定点的局部坐标系的旋转矩阵。

#include <deal.II/physics/transformations.h> 

// 然后，这又是简单的C++。

#include <fstream> 
#include <iostream> 
#include <iomanip> 

// 最后一步和以前所有的程序一样。

namespace Step18 
{ 
  using namespace dealii; 
// @sect3{The <code>PointHistory</code> class}  

// 正如介绍中提到的，我们必须在正交点存储旧的应力，这样我们就可以在下一个时间步骤中计算这一点的残余力。仅仅这一点还不能保证只有一个成员的结构，但在更复杂的应用中，我们还必须在正交点上存储更多的信息，比如塑性的历史变量等。从本质上讲，我们必须在这里存储所有影响材料当前状态的信息，在塑性中，这些信息是由变形历史变量决定的。

// 除了能够存储数据之外，我们不会给这个类任何有意义的功能，也就是说，没有构造函数、析构函数或其他成员函数。在这种 "哑巴 "类的情况下，我们通常选择将其声明为  <code>struct</code> rather than <code>class</code>  ，以表明它们更接近于C语言风格的结构而不是C++风格的类。

  template <int dim> 
  struct PointHistory 
  { 
    SymmetricTensor<2, dim> old_stress; 
  }; 
// @sect3{The stress-strain tensor}  

// 接下来，我们定义弹性中的应力和应变的线性关系。它由一个等级为4的张量给出，通常被写成  $C_{ijkl} = \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}) + \lambda \delta_{ij} \delta_{kl}$  的形式。这个张量将等级2的对称张量映射到等级2的对称张量。对于Lam&eacute;常数 $\lambda$ 和 $\mu$ 的给定值，一个实现其创建的函数是直接的。

  template <int dim> 
  SymmetricTensor<4, dim> get_stress_strain_tensor(const double lambda, 
                                                   const double mu) 
  { 
    SymmetricTensor<4, dim> tmp; 
    for (unsigned int i = 0; i < dim; ++i) 
      for (unsigned int j = 0; j < dim; ++j) 
        for (unsigned int k = 0; k < dim; ++k) 
          for (unsigned int l = 0; l < dim; ++l) 
            tmp[i][j][k][l] = (((i == k) && (j == l) ? mu : 0.0) + 
                               ((i == l) && (j == k) ? mu : 0.0) + 
                               ((i == j) && (k == l) ? lambda : 0.0)); 
    return tmp; 
  } 

// 通过这个函数，我们将在下面的主类中定义一个静态成员变量，在整个程序中作为应力-应变张量使用。请注意，在更复杂的程序中，这可能是某个类的成员变量，或者是一个根据其他输入返回应力-应变关系的函数。例如，在损伤理论模型中，Lam&eacute;常数被认为是一个点的先前应力/应变历史的函数。相反，在塑性中，如果材料在某一点达到了屈服应力，那么应力-应变张量的形式就会被修改，而且可能还取决于其先前的历史。

// 然而，在本程序中，我们假设材料是完全弹性和线性的，恒定的应力-应变张量对我们目前的目的来说是足够的。

//  @sect3{Auxiliary functions}  

// 在程序的其他部分之前，这里有几个我们需要的函数作为工具。这些是在内循环中调用的小函数，所以我们把它们标记为  <code>inline</code>  。

// 第一个是通过形成这个形状函数的对称梯度来计算形状函数 <code>shape_func</code> at quadrature point <code>q_point</code> 的对称应变张量。当我们想形成矩阵时，我们需要这样做，比如说。

// 我们应该注意到，在以前处理矢量值问题的例子中，我们总是问有限元对象在哪个矢量分量中的形状函数实际上是不为零的，从而避免计算任何我们反正可以证明为零的项。为此，我们使用了 <code>fe.system_to_component_index</code> 函数来返回形状函数在哪个分量中为零，同时 <code>fe_values.shape_value</code> 和 <code>fe_values.shape_grad</code> 函数只返回形状函数的单个非零分量的值和梯度，如果这是一个矢量值元素。

// 这是一个优化，如果不是非常关键的时间，我们可以用一个更简单的技术来解决：只需向 <code>fe_values</code> 询问一个给定形状函数的给定分量在给定正交点的值或梯度。这就是  <code>fe_values.shape_grad_component(shape_func,q_point,i)</code>  调用的作用：返回形状函数  <code>shape_func</code>  的第  <code>q_point</code>  个分量在正交点的全部梯度。如果某个形状函数的某个分量总是为零，那么这将简单地总是返回零。

// 如前所述，使用 <code>fe_values.shape_grad_component</code> 而不是 <code>fe.system_to_component_index</code> 和 <code>fe_values.shape_grad</code> 的组合可能效率较低，但其实现已针对这种情况进行了优化，应该不会有很大的减慢。我们在这里演示这个技术，因为它是如此的简单和直接。

  template <int dim> 
  inline SymmetricTensor<2, dim> get_strain(const FEValues<dim> &fe_values, 
                                            const unsigned int   shape_func, 
                                            const unsigned int   q_point) 
  { 

// 声明一个将保存返回值的暂存器。

    SymmetricTensor<2, dim> tmp; 

// 首先，填充对角线项，这只是矢量值形状函数的方向 <code>i</code> of the <code>i</code> 分量的导数。

    for (unsigned int i = 0; i < dim; ++i) 
      tmp[i][i] = fe_values.shape_grad_component(shape_func, q_point, i)[i]; 

// 然后填充应变张量的其余部分。注意，由于张量是对称的，我们只需要计算一半（这里：右上角）的非对角线元素， <code>SymmetricTensor</code> 类的实现确保至少到外面的对称条目也被填充（实际上，这个类当然只存储一份）。在这里，我们选择了张量的右上半部分，但是左下半部分也一样好。

    for (unsigned int i = 0; i < dim; ++i) 
      for (unsigned int j = i + 1; j < dim; ++j) 
        tmp[i][j] = 
          (fe_values.shape_grad_component(shape_func, q_point, i)[j] + 
           fe_values.shape_grad_component(shape_func, q_point, j)[i]) / 
          2; 

    return tmp; 
  } 

// 第二个函数做了非常类似的事情（因此被赋予相同的名字）：从一个矢量值场的梯度计算对称应变张量。如果你已经有了一个解场， <code>fe_values.get_function_gradients</code> 函数允许你在一个正交点上提取解场的每个分量的梯度。它返回的是一个秩-1张量的矢量：解的每个矢量分量有一个秩-1张量（梯度）。由此，我们必须通过转换数据存储格式和对称化来重建（对称的）应变张量。我们用和上面一样的方法来做，也就是说，我们通过首先填充对角线，然后只填充对称张量的一半来避免一些计算（ <code>SymmetricTensor</code> 类确保只写两个对称分量中的一个就足够了）。

// 不过在我们这样做之前，我们要确保输入有我们期望的那种结构：即有 <code>dim</code> 个矢量分量，即每个坐标方向有一个位移分量。我们用 <code>Assert</code> 宏来测试这一点，如果不符合条件，我们的程序就会被终止。

  template <int dim> 
  inline SymmetricTensor<2, dim> 
  get_strain(const std::vector<Tensor<1, dim>> &grad) 
  { 
    Assert(grad.size() == dim, ExcInternalError()); 

    SymmetricTensor<2, dim> strain; 
    for (unsigned int i = 0; i < dim; ++i) 
      strain[i][i] = grad[i][i]; 

    for (unsigned int i = 0; i < dim; ++i) 
      for (unsigned int j = i + 1; j < dim; ++j) 
        strain[i][j] = (grad[i][j] + grad[j][i]) / 2; 

    return strain; 
  } 

// 最后，下面我们将需要一个函数来计算某一点的位移所引起的旋转矩阵。当然，事实上，单点的位移只有一个方向和一个幅度，诱发旋转的是方向和幅度的变化。实际上，旋转矩阵可以通过位移的梯度来计算，或者更具体地说，通过卷曲来计算。

// 确定旋转矩阵的公式有点笨拙，特别是在三维中。对于2D来说，有一个更简单的方法，所以我们把这个函数实现了两次，一次用于2D，一次用于3D，这样我们就可以在两个空间维度上编译和使用这个程序，如果需要的话--毕竟，deal.II是关于独立维度编程和重复使用算法的，在2D的廉价计算中经过测试，在3D的更昂贵的计算中使用。下面是一种情况，我们必须为2D和3D实现不同的算法，但可以用独立于空间维度的方式来编写程序的其余部分。

// 所以，不用再多说了，来看看2D的实现。

  Tensor<2, 2> get_rotation_matrix(const std::vector<Tensor<1, 2>> &grad_u) 
  { 

// 首先，根据梯度计算出速度场的卷曲。注意，我们是在2d中，所以旋转是一个标量。

    const double curl = (grad_u[1][0] - grad_u[0][1]); 

// 由此计算出旋转的角度。

    const double angle = std::atan(curl); 

// 由此，建立反对称的旋转矩阵。我们希望这个旋转矩阵能够代表本地坐标系相对于全局直角坐标系的旋转，所以我们用一个负的角度来构建它。因此，这个旋转矩阵代表了从本地坐标系移动到全局坐标系所需的旋转。

    return Physics::Transformations::Rotations::rotation_matrix_2d(-angle); 
  } 

// 三维的情况就比较复杂了。

  Tensor<2, 3> get_rotation_matrix(const std::vector<Tensor<1, 3>> &grad_u) 
  { 

// 同样首先计算速度场的卷曲。这一次，它是一个实数向量。

    const Point<3> curl(grad_u[2][1] - grad_u[1][2], 
                        grad_u[0][2] - grad_u[2][0], 
                        grad_u[1][0] - grad_u[0][1]); 

// 从这个矢量中，利用它的大小，计算出旋转角度的正切值，并由此计算出相对于直角坐标系的实际旋转角度。

    const double tan_angle = std::sqrt(curl * curl); 
    const double angle     = std::atan(tan_angle); 

// 现在，这里有一个问题：如果旋转角度太小，那就意味着没有旋转发生（例如平移运动）。在这种情况下，旋转矩阵就是身份矩阵。

// 我们强调这一点的原因是，在这种情况下，我们有  <code>tan_angle==0</code>  。再往下看，我们在计算旋转轴的时候需要除以这个数字，这样做除法的时候会遇到麻烦。因此，让我们走捷径，如果旋转角度真的很小，就简单地返回同一矩阵。

    if (std::abs(angle) < 1e-9) 
      { 
        static const double rotation[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}; 
        static const Tensor<2, 3> rot(rotation); 
        return rot; 
      } 

// 否则计算真实的旋转矩阵。为此，我们再次依靠一个预定义的函数来计算本地坐标系的旋转矩阵。

    const Point<3> axis = curl / tan_angle; 
    return Physics::Transformations::Rotations::rotation_matrix_3d(axis, 
                                                                   -angle); 
  } 

//  @sect3{The <code>TopLevel</code> class}  

// 这就是程序的主类。由于命名空间已经表明了我们要解决的问题，让我们用它的作用来称呼它：它引导着程序的流程，也就是说，它是顶层驱动。

// 这个类的成员变量基本上和以前一样，即它必须有一个三角形，一个DoF处理程序和相关的对象，如约束条件，描述线性系统的变量等。现在还有很多成员函数，我们将在下面解释。

// 然而，该类的外部接口是不变的：它有一个公共的构造函数和析构函数，并且它有一个 <code>run</code> 函数来启动所有的工作。

  template <int dim> 
  class TopLevel 
  { 
  public: 
    TopLevel(); 
    ~TopLevel(); 
    void run(); 

  private: 

// 私有接口比  step-17  中的更加广泛。首先，我们显然需要创建初始网格的函数，设置描述当前网格上的线性系统的变量（即矩阵和向量），然后是实际组装系统的函数，指导每个时间步长中必须解决的问题，一个解决每个时间步长中出现的线性系统的函数（并返回它的迭代次数），最后在正确的网格上输出解向量。

    void create_coarse_grid(); 

    void setup_system(); 

    void assemble_system(); 

    void solve_timestep(); 

    unsigned int solve_linear_problem(); 

    void output_results() const; 

// 除了前两个，所有这些函数都在每个时间步中被调用。由于第一个时间步骤有点特殊，我们有单独的函数来描述一个时间步骤中必须发生的事情：一个用于第一个时间步骤，一个用于所有后续时间步骤。

    void do_initial_timestep(); 

    void do_timestep(); 

// 然后我们需要一大堆函数来做各种事情。第一个是细化初始网格：我们从原始状态的粗网格开始，解决这个问题，然后看一下，并相应地细化网格，然后重新开始同样的过程，再次以原始状态。因此，细化初始网格比在两个连续的时间步骤之间细化网格要简单一些，因为它不涉及将数据从旧的三角测量转移到新的三角测量，特别是存储在每个正交点的历史数据。

    void refine_initial_grid(); 

// 在每个时间步骤结束时，我们要根据这个时间步骤计算的增量位移来移动网格顶点。这就是完成这个任务的函数。

    void move_mesh(); 

// 接下来是两个处理存储在每个正交点的历史变量的函数。第一个函数在第一个时间步长之前被调用，为历史变量设置一个原始状态。它只对属于当前处理器的单元上的正交点起作用。

    void setup_quadrature_point_history(); 

// 第二项是在每个时间段结束时更新历史变量。

    void update_quadrature_point_history(); 

// 这是新的共享三角法。

    parallel::shared::Triangulation<dim> triangulation; 

    FESystem<dim> fe; 

    DoFHandler<dim> dof_handler; 

    AffineConstraints<double> hanging_node_constraints; 

// 这个程序的一个不同之处在于，我们在类声明中声明了正交公式。原因是在所有其他程序中，如果我们在计算矩阵和右手边时使用不同的正交公式，并没有什么坏处，比如说。然而，在目前的情况下，它确实如此：我们在正交点中存储了信息，所以我们必须确保程序的所有部分都同意它们的位置以及每个单元格上有多少个。因此，让我们首先声明将在整个程序中使用的正交公式...。

    const QGauss<dim> quadrature_formula; 

// ......然后也有一个历史对象的向量，在我们负责的那些单元格上的每个正交点都有一个（也就是说，我们不为其他处理器拥有的单元格上的正交点存储历史数据）。请注意，我们可以像在  step-44  中那样使用 CellDataStorage 类来代替我们自己存储和管理这些数据。然而，为了演示的目的，在这种情况下，我们手动管理存储。

    std::vector<PointHistory<dim>> quadrature_point_history; 

// 这个对象的访问方式是通过每个单元格、面或边持有的 <code>user pointer</code> ：它是一个 <code>void*</code> 指针，可以被应用程序用来将任意的数据与单元格、面或边联系起来。程序对这些数据的实际操作属于自己的职责范围，库只是为这些指针分配了一些空间，而应用程序可以设置和读取这些对象中的每个指针。

// 进一步说：我们需要待解的线性系统的对象，即矩阵、右手边的向量和解向量。由于我们预计要解决大问题，我们使用了与 step-17 中相同的类型，即建立在PETSc库之上的分布式%并行矩阵和向量。方便的是，它们也可以在只在一台机器上运行时使用，在这种情况下，这台机器正好是我们的%并行宇宙中唯一的机器。

// 然而，与 step-17 不同的是，我们不以分布式方式存储解向量--这里是在每个时间步骤中计算的增量位移。也就是说，在计算时它当然必须是一个分布式矢量，但紧接着我们确保每个处理器都有一个完整的副本。原因是我们已经在 step-17 中看到，许多函数需要一个完整的副本。虽然得到它并不难，但这需要在网络上进行通信，因此很慢。此外，这些都是重复的相同操作，这当然是不可取的，除非不必总是存储整个向量的收益超过了它。在编写这个程序时，事实证明，我们在很多地方都需要一份完整的解决方案，以至于只在必要时才获得它似乎不值得。相反，我们选择一劳永逸地获得完整的副本，而立即摆脱分散的副本。因此，请注意， <code>incremental_displacement</code> 的声明并没有像中间命名空间 <code>MPI</code> 所表示的那样，表示一个分布式向量。

    PETScWrappers::MPI::SparseMatrix system_matrix; 

    PETScWrappers::MPI::Vector system_rhs; 

    Vector<double> incremental_displacement; 

// 接下来的变量块与问题的时间依赖性有关：它们表示我们要模拟的时间间隔的长度，现在的时间和时间步数，以及现在时间步数的长度。

    double       present_time; 
    double       present_timestep; 
    double       end_time; 
    unsigned int timestep_no; 

// 然后是几个与%并行处理有关的变量：首先，一个变量表示我们使用的MPI通信器，然后是两个数字，告诉我们有多少个参与的处理器，以及我们在这个世界上的位置。最后，一个流对象，确保只有一个处理器实际产生输出到控制台。这与  step-17  中的所有内容相同。

    MPI_Comm mpi_communicator; 

    const unsigned int n_mpi_processes; 

    const unsigned int this_mpi_process; 

    ConditionalOStream pcout; 

// 我们正在存储本地拥有的和本地相关的索引。

    IndexSet locally_owned_dofs; 
    IndexSet locally_relevant_dofs; 

// 最后，我们有一个静态变量，表示应力和应变之间的线性关系。由于它是一个不依赖任何输入的常量对象（至少在这个程序中不依赖），我们把它作为一个静态变量，并将在我们定义这个类的构造函数的同一个地方初始化它。

    static const SymmetricTensor<4, dim> stress_strain_tensor; 
  }; 
// @sect3{The <code>BodyForce</code> class}  

// 在我们进入这个程序的主要功能之前，我们必须定义哪些力将作用在我们想要研究的变形的体上。这些力可以是体力，也可以是边界力。体力通常是由四种基本的物理力类型之一所介导的：重力、强弱相互作用和电磁力。除非人们想考虑亚原子物体（对于这些物体，无论如何准静态变形是不相关的，也是不合适的描述），否则只需要考虑引力和电磁力。为了简单起见，让我们假设我们的身体有一定的质量密度，但要么是非磁性的，不导电的，要么周围没有明显的电磁场。在这种情况下，身体的力只是 <code>rho g</code>, where <code>rho</code> 是材料密度， <code>g</code> 是一个负Z方向的矢量，大小为9.81米/秒^2。 密度和 <code>g</code> 都是在函数中定义的，我们把7700 kg/m^3作为密度，这是对钢材通常假定的值。

// 为了更普遍一点，也为了能够在2d中进行计算，我们意识到体力总是一个返回 <code>dim</code> 维矢量的函数。我们假设重力沿着最后一个，即 <code>dim-1</code> 个坐标的负方向作用。考虑到以前的例子程序中的类似定义，这个函数的其余实现应该大部分是不言自明的。请注意，身体的力量与位置无关；为了避免编译器对未使用的函数参数发出警告，我们因此注释了 <code>vector_value</code> 函数的第一个参数的名称。

  template <int dim> 
  class BodyForce : public Function<dim> 
  { 
  public: 
    BodyForce(); 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  values) const override; 

    virtual void 
    vector_value_list(const std::vector<Point<dim>> &points, 
                      std::vector<Vector<double>> &  value_list) const override; 
  }; 

  template <int dim> 
  BodyForce<dim>::BodyForce() 
    : Function<dim>(dim) 
  {} 

  template <int dim> 
  inline void BodyForce<dim>::vector_value(const Point<dim> & /*p*/, 
                                           Vector<double> &values) const 
  { 
    Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim)); 

    const double g   = 9.81; 
    const double rho = 7700; 

    values          = 0; 
    values(dim - 1) = -rho * g; 
  } 

  template <int dim> 
  void BodyForce<dim>::vector_value_list( 
    const std::vector<Point<dim>> &points, 
    std::vector<Vector<double>> &  value_list) const 
  { 
    const unsigned int n_points = points.size(); 

    Assert(value_list.size() == n_points, 
           ExcDimensionMismatch(value_list.size(), n_points)); 

    for (unsigned int p = 0; p < n_points; ++p) 
      BodyForce<dim>::vector_value(points[p], value_list[p]); 
  } 

//  @sect3{The <code>IncrementalBoundaryValue</code> class}  

// 除了身体的力之外，运动还可以由边界力和强制边界位移引起。后一种情况相当于以这样的方式选择力，使其诱发某种位移。

// 对于准静态位移，典型的边界力是对一个体的压力，或者对另一个体的切向摩擦。我们在这里选择了一种更简单的情况：我们规定了边界（部分）的某种运动，或者至少是位移矢量的某些分量。我们用另一个矢量值函数来描述，对于边界上的某一点，返回规定的位移。

// 由于我们有一个随时间变化的问题，边界的位移增量等于在时间段内累积的位移。因此，该类必须同时知道当前时间和当前时间步长，然后可以将位移增量近似为当前速度乘以当前时间步长。

// 在本程序中，我们选择了一种简单的边界位移形式：我们以恒定的速度向下位移顶部的边界。边界的其余部分要么是固定的（然后用一个 <code>Functions::ZeroFunction</code> 类型的对象来描述），要么是自由的（Neumann类型，在这种情况下不需要做任何特殊的事情）。 利用我们在前面所有的例子程序中获得的知识，描述持续向下运动的类的实现应该是很明显的。

  template <int dim> 
  class IncrementalBoundaryValues : public Function<dim> 
  { 
  public: 
    IncrementalBoundaryValues(const double present_time, 
                              const double present_timestep); 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  values) const override; 

    virtual void 
    vector_value_list(const std::vector<Point<dim>> &points, 
                      std::vector<Vector<double>> &  value_list) const override; 

  private: 
    const double velocity; 
    const double present_time; 
    const double present_timestep; 
  }; 

  template <int dim> 
  IncrementalBoundaryValues<dim>::IncrementalBoundaryValues( 
    const double present_time, 
    const double present_timestep) 
    : Function<dim>(dim) 
    , velocity(.08) 
    , present_time(present_time) 
    , present_timestep(present_timestep) 
  {} 

  template <int dim> 
  void 
  IncrementalBoundaryValues<dim>::vector_value(const Point<dim> & /*p*/, 
                                               Vector<double> &values) const 
  { 
    Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim)); 

    values    = 0; 
    values(2) = -present_timestep * velocity; 
  } 

  template <int dim> 
  void IncrementalBoundaryValues<dim>::vector_value_list( 
    const std::vector<Point<dim>> &points, 
    std::vector<Vector<double>> &  value_list) const 
  { 
    const unsigned int n_points = points.size(); 

    Assert(value_list.size() == n_points, 
           ExcDimensionMismatch(value_list.size(), n_points)); 

    for (unsigned int p = 0; p < n_points; ++p) 
      IncrementalBoundaryValues<dim>::vector_value(points[p], value_list[p]); 
  } 

//  @sect3{Implementation of the <code>TopLevel</code> class}  

// 现在是主类的实现。首先，我们初始化应力应变张量，我们将其声明为一个静态常量变量。我们选择了适合于钢铁的Lam&eacute;常数。

  template <int dim> 
  const SymmetricTensor<4, dim> TopLevel<dim>::stress_strain_tensor = 
    get_stress_strain_tensor<dim>(
      /*lambda = */ 9.695e10, 
      /*mu =  */  7.617e10)

//  @sect4{The public interface}  

// 下一步是构造函数和析构函数的定义。这里没有什么惊喜：我们为解的每个 <code>dim</code> 矢量分量选择线性和连续的有限元，以及每个坐标方向上有2个点的高斯正交公式。解构器应该是显而易见的。

  template <int dim> 
  TopLevel<dim>::TopLevel() 
    : triangulation(MPI_COMM_WORLD) 
    , fe(FE_Q<dim>(1), dim) 
    , dof_handler(triangulation) 
    , quadrature_formula(fe.degree + 1) 
    , present_time(0.0) 
    , present_timestep(1.0) 
    , end_time(10.0) 
    , timestep_no(0) 
    , mpi_communicator(MPI_COMM_WORLD) 
    , n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator)) 
    , this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator)) 
    , pcout(std::cout, this_mpi_process == 0) 
  {} 

  template <int dim> 
  TopLevel<dim>::~TopLevel() 
  { 
    dof_handler.clear(); 
  } 

// 最后一个公共函数是指导所有工作的函数，  <code>run()</code>  。它初始化了描述我们目前所处时间位置的变量，然后运行第一个时间步骤，再循环所有其他时间步骤。请注意，为了简单起见，我们使用一个固定的时间步长，而一个更复杂的程序当然要以某种更合理的方式自适应地选择它。

  template <int dim> 
  void TopLevel<dim>::run() 
  { 
    do_initial_timestep(); 

    while (present_time < end_time) 
      do_timestep(); 
  } 
// @sect4{TopLevel::create_coarse_grid}  

// 按照上面声明的顺序，下一个函数是创建粗略网格的函数，我们从这里开始。在这个示例程序中，我们想计算一个圆柱体在轴向压缩下的变形。因此第一步是生成一个长度为3，内外半径分别为0.8和1的圆柱体的网格。幸运的是，有一个库函数可以生成这样的网格。

// 在第二步中，我们必须在圆柱体的上表面和下表面关联边界条件。我们为边界面选择一个边界指示器0，这些边界面的中点的Z坐标为0（底面），Z=3的指示器为1（顶面）；最后，我们对圆柱体外壳内部的所有面使用边界指示器2，外部使用3。

  template <int dim> 
  void TopLevel<dim>::create_coarse_grid() 
  { 
    const double inner_radius = 0.8, outer_radius = 1; 
    GridGenerator::cylinder_shell(triangulation, 3, inner_radius, outer_radius); 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->at_boundary()) 
          { 
            const Point<dim> face_center = face->center(); 

            if (face_center[2] == 0) 
              face->set_boundary_id(0); 
            else if (face_center[2] == 3) 
              face->set_boundary_id(1); 
            else if (std::sqrt(face_center[0] * face_center[0] + 
                               face_center[1] * face_center[1]) < 
                     (inner_radius + outer_radius) / 2) 
              face->set_boundary_id(2); 
            else 
              face->set_boundary_id(3); 
          } 

// 一旦完成了这些，我们就可以对网格进行一次全面的细化。

    triangulation.refine_global(1); 

// 作为最后一步，我们需要设置一个干净的数据状态，我们将这些数据存储在目前处理器上处理的所有单元的正交点中。

    setup_quadrature_point_history(); 
  } 

//  @sect4{TopLevel::setup_system}  

// 下一个函数是为一个给定的网格设置数据结构。这与 step-17 中的方法基本相同：分配自由度，然后对这些自由度进行排序，使每个处理器得到一个连续的块。请注意，每个处理器的细分块是在创建或完善网格的函数中处理的，与之前的例子程序不同（发生这种情况的时间点主要是口味问题；在这里，我们选择在创建网格时进行，因为在 <code>do_initial_timestep</code> 和 <code>do_timestep</code> 函数中，我们想在还没有调用当前函数的时候输出每个处理器上的单元数量）。

  template <int dim> 
  void TopLevel<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    locally_owned_dofs = dof_handler.locally_owned_dofs(); 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 

// 下一步是设置由于悬挂节点而产生的约束。这在以前已经处理过很多次了。

    hanging_node_constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

// 然后我们要设置矩阵。这里我们偏离了  step-17  ，在那里我们简单地使用了PETSc的能力，即只知道矩阵的大小，随后分配那些被写入的非零元素。虽然从正确性的角度来看，这样做很好，但是效率却不高：如果我们不给PETSc提供关于哪些元素被写入的线索，那么当我们第一次设置矩阵中的元素时（即在第一个时间步中），它的速度会慢得令人难以忍受。后来，当元素被分配后，一切都快多了。在我们所做的实验中，如果我们指示PETSc哪些元素将被使用，哪些不被使用，那么第一个时间步骤可以加快近两个数量级。

// 要做到这一点，我们首先要生成我们要处理的矩阵的稀疏模式，并确保浓缩的悬挂节点约束在稀疏模式中增加必要的额外条目。

    DynamicSparsityPattern sparsity_pattern(locally_relevant_dofs); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    sparsity_pattern, 
                                    hanging_node_constraints, 
                                    /*保持约束性dofs  */ false)

    SparsityTools::distribute_sparsity_pattern(sparsity_pattern, 
                                               locally_owned_dofs, 
                                               mpi_communicator, 
                                               locally_relevant_dofs); 

// 注意，我们在这里使用了已经在 step-11 中介绍过的 <code>DynamicSparsityPattern</code> 类，而不是我们在所有其他情况下使用的 <code>SparsityPattern</code> 类。其原因是，为了使后一个类发挥作用，我们必须给每一行的条目数提供一个初始的上限，这项任务传统上是由 <code>DoFHandler::max_couplings_between_dofs()</code> 完成。然而，这个函数有一个严重的问题：它必须计算每一行中非零项的数量的上限，而这是一个相当复杂的任务，特别是在3D中。实际上，虽然它在2D中相当准确，但在3D中经常得出太大的数字，在这种情况下， <code>SparsityPattern</code> 一开始就分配了太多的内存，经常是几百MB。后来当 <code>DoFTools::make_sparsity_pattern</code> 被调用时，我们意识到我们不需要那么多的内存，但这时已经太晚了：对于大问题，临时分配太多的内存会导致内存不足的情况。

// 为了避免这种情况，我们采用了 <code>DynamicSparsityPattern</code> 类，该类速度较慢，但不需要预先估计每行非零条目的数量。因此，它在任何时候都只分配它所需要的内存，而且我们甚至可以为大型的三维问题建立它。

// 值得注意的是，由于 parallel::shared::Triangulation, 的特殊性，我们构建的稀疏模式是全局的，即包括所有的自由度，无论它们是属于我们所在的处理器还是另一个处理器（如果这个程序是通过MPI并行运行的）。这当然不是最好的--它限制了我们可以解决的问题的规模，因为在每个处理器上存储整个稀疏模式（即使只是短时间）的规模并不大。然而，在程序中还有几个地方我们是这样做的，例如，我们总是把全局三角测量和DoF处理对象保留在周围，即使我们只对它们的一部分进行工作。目前，deal.II没有必要的设施来完全分配这些对象（事实上，这项任务在自适应网格中很难实现，因为随着网格的自适应细化，领域的均衡分区往往会变得不均衡）。

// 有了这个数据结构，我们就可以进入PETSc稀疏矩阵，告诉它预先分配所有我们以后要写入的条目。

    system_matrix.reinit(locally_owned_dofs, 
                         locally_owned_dofs, 
                         sparsity_pattern, 
                         mpi_communicator); 

// 在这一点上，不再需要对稀疏模式有任何明确的了解，我们可以让 <code>sparsity_pattern</code> 这个变量离开范围，不会有任何问题。

// 这个函数的最后一个任务是将右侧向量和求解向量重置为正确的大小；记住，求解向量是一个本地向量，不像右侧向量是一个分布式的%并行向量，因此需要知道MPI通信器，它应该通过这个通信器来传输消息。

    system_rhs.reinit(locally_owned_dofs, mpi_communicator); 
    incremental_displacement.reinit(dof_handler.n_dofs()); 
  } 

//  @sect4{TopLevel::assemble_system}  

// 同样，组装系统矩阵和右手边的结构与之前许多例子程序中的结构相同。特别是，它主要等同于 step-17 ，除了不同的右手边，现在只需要考虑到内部应力。此外，通过使用 <code>SymmetricTensor</code> 类，组装矩阵明显变得更加透明：请注意形成2级和4级对称张量的标量积的优雅性。这个实现也更加通用，因为它与我们可能使用或不使用各向同性的弹性张量这一事实无关。

// 汇编程序的第一部分和以往一样。

  template <int dim> 
  void TopLevel<dim>::assemble_system() 
  { 
    system_rhs    = 0; 
    system_matrix = 0; 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    BodyForce<dim>              body_force; 
    std::vector<Vector<double>> body_force_values(n_q_points, 
                                                  Vector<double>(dim)); 

// 如同在  step-17  中一样，我们只需要在属于当前处理器的所有单元中进行循环。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell_matrix = 0; 
          cell_rhs    = 0; 

          fe_values.reinit(cell); 

// 然后在所有指数i,j和正交点上循环，并从这个单元中组合出系统矩阵的贡献。 注意我们如何从 <code>FEValues</code> 对象中提取给定正交点的形状函数的对称梯度（应变），以及我们如何优雅地形成三重收缩 <code>eps_phi_i : C : eps_phi_j</code> ；后者需要与 step-17 中需要的笨拙计算进行比较，无论是在介绍中还是在程序的相应位置。

          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
                { 
                  const SymmetricTensor<2, dim> 
                    eps_phi_i = get_strain(fe_values, i, q_point), 
                    eps_phi_j = get_strain(fe_values, j, q_point); 

                  cell_matrix(i, j) += (eps_phi_i *            // 
                                        stress_strain_tensor * // 
                                        eps_phi_j              // 
                                        ) *                    // 
                                       fe_values.JxW(q_point); // 
                } 

// 然后也要组装本地的右手边贡献。为此，我们需要访问这个正交点的先验应力值。为了得到它，我们使用该单元的用户指针，该指针指向全局数组中与当前单元的第一个正交点相对应的正交点数据，然后添加一个与我们现在考虑的正交点的索引相对应的偏移量。

          const PointHistory<dim> *local_quadrature_points_data = 
            reinterpret_cast<PointHistory<dim> *>(cell->user_pointer()); 

// 此外，我们还需要这个单元上的正交点的外体力值。

          body_force.vector_value_list(fe_values.get_quadrature_points(), 
                                       body_force_values); 

// 然后，我们可以循环计算这个单元上的所有自由度，并计算出对右侧的局部贡献。

          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const unsigned int component_i = 
                fe.system_to_component_index(i).first; 

              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
                { 
                  const SymmetricTensor<2, dim> &old_stress = 
                    local_quadrature_points_data[q_point].old_stress; 

                  cell_rhs(i) += 
                    (body_force_values[q_point](component_i) * 
                       fe_values.shape_value(i, q_point) - 
                     old_stress * get_strain(fe_values, i, q_point)) * 
                    fe_values.JxW(q_point); 
                } 
            } 

// 现在我们有了对线性系统的局部贡献，我们需要将其转移到全局对象中。这与  step-17  中的做法完全相同。

          cell->get_dof_indices(local_dof_indices); 

          hanging_node_constraints.distribute_local_to_global(cell_matrix, 
                                                              cell_rhs, 
                                                              local_dof_indices, 
                                                              system_matrix, 
                                                              system_rhs); 
        } 

// 现在压缩矢量和系统矩阵。

    system_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 

// 最后一步是再次修复边界值，就像我们在以前的程序中已经做的那样。一个稍微复杂的问题是， <code>apply_boundary_values</code> 函数希望有一个与矩阵和右手边兼容的解向量（即这里是一个分布式的%并行向量，而不是我们在这个程序中使用的顺序向量），以便用正确的边界值预设解向量的条目。我们以临时向量的形式提供这样一个兼容向量，然后将其复制到顺序向量中。

// 我们通过展示边界值的灵活使用来弥补这种复杂性：按照我们创建三角形的方式，有三个不同的边界指标用来描述领域，分别对应于底面和顶面，以及内/外表面。我们希望施加以下类型的边界条件。内外圆柱体表面没有外力，这一事实对应于自然（诺伊曼型）边界条件，我们不需要做任何事情。在底部，我们希望完全没有运动，对应于圆柱体在边界的这一部分被夹住或粘住。然而，在顶部，我们希望有一个规定的垂直向下的运动来压缩圆柱体；此外，我们只希望限制垂直运动，而不是水平运动--可以把这种情况看作是一块油性良好的板坐在圆柱体的顶部将其向下推：圆柱体的原子被迫向下移动，但它们可以自由地沿着板水平滑动。

//描述这种情况的方法如下：对于边界指标为零（底面）的边界，我们使用一个二维的零函数，代表在任何坐标方向都没有运动。对于指标1（顶面）的边界，我们使用 <code>IncrementalBoundaryValues</code> 类，但我们为 <code>VectorTools::interpolate_boundary_values</code> 函数指定一个额外的参数，表示它应该适用于哪些矢量分量；这是一个针对每个矢量分量的bools矢量，由于我们只想限制垂直运动，它只有最后一个分量的设置。

    FEValuesExtractors::Scalar                z_component(dim - 1); 
    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(dim), 
                                             boundary_values); 
    VectorTools::interpolate_boundary_values( 
      dof_handler, 
      1, 
      IncrementalBoundaryValues<dim>(present_time, present_timestep), 
      boundary_values, 
      fe.component_mask(z_component)); 

    PETScWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator); 
    MatrixTools::apply_boundary_values( 
      boundary_values, system_matrix, tmp, system_rhs, false); 
    incremental_displacement = tmp; 
  } 

//  @sect4{TopLevel::solve_timestep}  

// 下一个函数是控制一个时间段内必须发生的所有事情的函数。从函数名称上看，事情的顺序应该是相对不言自明的。

  template <int dim> 
  void TopLevel<dim>::solve_timestep() 
  { 
    pcout << "    Assembling system..." << std::flush; 
    assemble_system(); 
    pcout << " norm of rhs is " << system_rhs.l2_norm() << std::endl; 

    const unsigned int n_iterations = solve_linear_problem(); 

    pcout << "    Solver converged in " << n_iterations << " iterations." 
          << std::endl; 

    pcout << "    Updating quadrature point data..." << std::flush; 
    update_quadrature_point_history(); 
    pcout << std::endl; 
  } 

//  @sect4{TopLevel::solve_linear_problem}  

// 再次求解线性系统的工作原理与之前基本相同。唯一不同的是，我们只想保留一份完整的本地解向量，而不是从PETSc的求解程序中得到的分布式向量。为此，我们为分布式向量声明一个本地临时变量，并用本地变量的内容对其进行初始化（记得 <code>apply_boundary_values</code> 中调用的 <code>assemble_system</code> 函数预设了该向量中边界节点的值），用它进行求解，并在函数结束时将其再次复制到我们声明为成员变量的完整本地向量中。然后，挂起的节点约束只分布在本地拷贝上，也就是说，在每个处理器上都是独立的。

  template <int dim> 
  unsigned int TopLevel<dim>::solve_linear_problem() 
  { 
    PETScWrappers::MPI::Vector distributed_incremental_displacement( 
      locally_owned_dofs, mpi_communicator); 
    distributed_incremental_displacement = incremental_displacement; 

    SolverControl solver_control(dof_handler.n_dofs(), 
                                 1e-16 * system_rhs.l2_norm()); 

    PETScWrappers::SolverCG cg(solver_control, mpi_communicator); 

    PETScWrappers::PreconditionBlockJacobi preconditioner(system_matrix); 

    cg.solve(system_matrix, 
             distributed_incremental_displacement, 
             system_rhs, 
             preconditioner); 

    incremental_displacement = distributed_incremental_displacement; 

    hanging_node_constraints.distribute(incremental_displacement); 

    return solver_control.last_step(); 
  } 

//  @sect4{TopLevel::output_results}  

// 这个函数生成.vtu格式的图形输出，正如介绍中所解释的。每个进程将只对其拥有的单元格进行工作，然后将结果写入自己的文件中。此外，处理器0将写下引用所有.vtu文件的记录文件。

// 这个函数的关键部分是给 <code>DataOut</code> 类提供一种方法，使其只对当前进程拥有的单元格进行工作。

  template <int dim> 
  void TopLevel<dim>::output_results() const 
  { 
    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
//然后，
//就像在 step-17 中一样，定义求解变量的名称（这里是位移增量）并排队输出求解向量。请注意在下面的开关中，我们如何确保如果空间维度应该不被处理，我们抛出一个异常，说我们还没有实现这种情况（另一个防御性编程的案例）。

    std::vector<std::string> solution_names; 
    switch (dim) 
      { 
        case 1: 
          solution_names.emplace_back("delta_x"); 
          break; 
        case 2: 
          solution_names.emplace_back("delta_x"); 
          solution_names.emplace_back("delta_y"); 
          break; 
        case 3: 
          solution_names.emplace_back("delta_x"); 
          solution_names.emplace_back("delta_y"); 
          solution_names.emplace_back("delta_z"); 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    data_out.add_data_vector(incremental_displacement, solution_names); 

// 接下来的事情是，我们想输出类似于我们在每个单元中存储的应力的平均规范。这看起来很复杂，因为在目前的处理器上，我们只在那些实际属于目前进程的单元格上存储正交点的应力。换句话说，我们似乎无法计算出所有单元的平均应力。然而，请记住，我们源自 <code>DataOut</code> 的类只迭代那些实际属于当前处理器的单元，也就是说，我们不必为所有其他单元计算任何东西，因为这些信息不会被触及。下面的小循环就是这样做的。我们将整个区块包围在一对大括号中，以确保迭代器变量不会在它们被使用的区块结束后仍然意外地可见。

    Vector<double> norm_of_stress(triangulation.n_active_cells()); 
    { 

// 在所有的单元格上循环...

      for (auto &cell : triangulation.active_cell_iterators()) 
        if (cell->is_locally_owned()) 
          { 

// 在这些单元上，将所有正交点的应力相加...

            SymmetricTensor<2, dim> accumulated_stress; 
            for (unsigned int q = 0; q < quadrature_formula.size(); ++q) 
              accumulated_stress += 
                reinterpret_cast<PointHistory<dim> *>(cell->user_pointer())[q] 
                  .old_stress; 

// ...然后把平均值的常数写到它们的目的地。

            norm_of_stress(cell->active_cell_index()) = 
              (accumulated_stress / quadrature_formula.size()).norm(); 
          } 

// 在我们不感兴趣的单元格上，将向量中各自的值设置为一个假值（规范必须是正值，大的负值应该能吸引你的眼球），以确保如果我们的假设有误，即这些元素不会出现在输出文件中，我们会通过观察图形输出发现。

        else 
          norm_of_stress(cell->active_cell_index()) = -1e+20; 
    } 

// 最后把这个向量也附在上面，以便进行输出处理。

    data_out.add_data_vector(norm_of_stress, "norm_of_stress"); 

// 作为最后一个数据，如果这是一个并行作业，让我们也把域划分为与处理器相关的子域。这与 step-17 程序中的工作方式完全相同。

    std::vector<types::subdomain_id> partition_int( 
      triangulation.n_active_cells()); 
    GridTools::get_subdomain_association(triangulation, partition_int); 
    const Vector<double> partitioning(partition_int.begin(), 
                                      partition_int.end()); 
    data_out.add_data_vector(partitioning, "partitioning"); 

// 最后，有了这些数据，我们可以指示deal.II对信息进行整合，并产生一些中间数据结构，其中包含所有这些解决方案和其他数据向量。

    data_out.build_patches(); 

// 让我们调用一个函数，打开必要的输出文件，将我们生成的数据写入其中。该函数根据给定的目录名（第一个参数）和文件名基数（第二个参数）自动构建文件名。它通过由时间步数和 "片数 "产生的片断来增加所产生的字符串，"片数 "对应于整个域的一部分，可以由一个或多个子域组成。

// 该函数还为Paraview写了一个记录文件（后缀为`.pvd`），描述了所有这些输出文件如何组合成这个单一时间步骤的数据。

    const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record( 
      "./", "solution", timestep_no, mpi_communicator, 4); 

// 记录文件必须只写一次，而不是由每个处理器来写，所以我们在0号处理器上做这个。

    if (this_mpi_process == 0) 
      { 

// 最后，我们写入paraview记录，它引用了所有.pvtu文件和它们各自的时间。注意，变量times_and_names被声明为静态的，所以它将保留前几个时间段的条目。

        static std::vector<std::pair<double, std::string>> times_and_names; 
        times_and_names.push_back( 
          std::pair<double, std::string>(present_time, pvtu_filename)); 
        std::ofstream pvd_output("solution.pvd"); 
        DataOutBase::write_pvd_record(pvd_output, times_and_names); 
      } 
  } 

//  @sect4{TopLevel::do_initial_timestep}  

// 这个函数和下一个函数分别处理第一个和下一个时间步骤的整体结构。第一个时间步骤的工作量稍大，因为我们要在连续细化的网格上多次计算，每次都从一个干净的状态开始。在这些计算的最后，我们每次都计算增量位移，我们使用最后得到的增量位移的结果来计算产生的应力更新并相应地移动网格。在这个新的网格上，我们再输出解决方案和任何我们认为重要的附加数据。

// 所有这些都会穿插着产生输出到控制台，以更新屏幕上的人正在发生的事情。如同在 step-17 中一样，使用 <code>pcout</code> instead of <code>std::cout</code> 可以确保只有一个并行进程实际在向控制台写数据，而不需要在每个产生输出的地方明确地编码一个if语句。

  template <int dim> 
  void TopLevel<dim>::do_initial_timestep() 
  { 
    present_time += present_timestep; 
    ++timestep_no; 
    pcout << "Timestep " << timestep_no << " at time " << present_time 
          << std::endl; 

    for (unsigned int cycle = 0; cycle < 2; ++cycle) 
      { 
        pcout << "  Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          create_coarse_grid(); 
        else 
          refine_initial_grid(); 

        pcout << "    Number of active cells:       " 
              << triangulation.n_active_cells() << " (by partition:"; 
        for (unsigned int p = 0; p < n_mpi_processes; ++p) 
          pcout << (p == 0 ? ' ' : '+') 
                << (GridTools::count_cells_with_subdomain_association( 
                     triangulation, p)); 
        pcout << ")" << std::endl; 

        setup_system(); 

        pcout << "    Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (by partition:"; 
        for (unsigned int p = 0; p < n_mpi_processes; ++p) 
          pcout << (p == 0 ? ' ' : '+') 
                << (DoFTools::count_dofs_with_subdomain_association(dof_handler, 
                                                                    p)); 
        pcout << ")" << std::endl; 

        solve_timestep(); 
      } 

    move_mesh(); 
    output_results(); 

    pcout << std::endl; 
  } 

//  @sect4{TopLevel::do_timestep}  

// 后续的时间步骤比较简单，鉴于上面对前一个函数的解释，可能不需要更多的文件。

  template <int dim> 
  void TopLevel<dim>::do_timestep() 
  { 
    present_time += present_timestep; 
    ++timestep_no; 
    pcout << "Timestep " << timestep_no << " at time " << present_time 
          << std::endl; 
    if (present_time > end_time) 
      { 
        present_timestep -= (present_time - end_time); 
        present_time = end_time; 
      } 

    solve_timestep(); 

    move_mesh(); 
    output_results(); 

    pcout << std::endl; 
  } 
// @sect4{TopLevel::refine_initial_grid}  

// 当在连续细化的网格上求解第一个时间步骤时，调用以下函数。每次迭代后，它都会计算一个细化准则，细化网格，并将每个正交点的历史变量再次设置为干净状态。

  template <int dim> 
  void TopLevel<dim>::refine_initial_grid() 
  { 

// 首先，让每个进程计算其拥有的单元格的误差指标。

    Vector<float> error_per_cell(triangulation.n_active_cells()); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      incremental_displacement, 
      error_per_cell, 
      ComponentMask(), 
      nullptr, 
      MultithreadInfo::n_threads(), 
      this_mpi_process); 

// 然后建立一个全局向量，我们将来自每个%并行进程的局部指标合并到其中。

    const unsigned int n_local_cells = 
      triangulation.n_locally_owned_active_cells(); 

    PETScWrappers::MPI::Vector distributed_error_per_cell( 
      mpi_communicator, triangulation.n_active_cells(), n_local_cells); 

    for (unsigned int i = 0; i < error_per_cell.size(); ++i) 
      if (error_per_cell(i) != 0) 
        distributed_error_per_cell(i) = error_per_cell(i); 
    distributed_error_per_cell.compress(VectorOperation::insert); 

// 一旦我们有了这个，就把它复制回所有处理器上的本地副本，并相应地完善网格。

    error_per_cell = distributed_error_per_cell; 
    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    error_per_cell, 
                                                    0.35, 
                                                    0.03); 
    triangulation.execute_coarsening_and_refinement(); 

// 最后，在新的网格上再次设置正交点数据，并且只在那些我们已经确定是我们的单元上设置。

    setup_quadrature_point_history(); 
  } 

//  @sect4{TopLevel::move_mesh}  

// 在每个时间步骤结束时，我们根据这个时间步骤计算的增量位移来移动网格的节点。为了做到这一点，我们保留一个标志的向量，为每个顶点指示我们是否已经移动过它，然后在所有单元中循环，移动那些尚未移动的单元顶点。值得注意的是，我们从某个顶点相邻的单元中移动这个顶点并不重要：因为我们使用连续有限元计算位移，位移场也是连续的，我们可以从每个相邻的单元中计算某个顶点的位移。我们只需要确保每个节点都精确地移动一次，这就是为什么我们要保留标志的矢量。

// 在这个函数中，有两个值得注意的地方。首先，我们如何使用 <code>cell-@>vertex_dof_index(v,d)</code> 函数获得给定顶点的位移场，该函数返回给定单元的 <code>d</code>th degree of freedom at vertex <code>v</code> 的索引。在本例中，k-th坐标方向的位移对应于有限元的k-th分量。使用这样的函数有一定的风险，因为它使用了我们在 <code>FESystem</code> 元素中为这个程序共同采取的元素顺序的知识。如果我们决定增加一个额外的变量，例如用于稳定的压力变量，并碰巧将其作为元素的第一个变量插入，那么下面的计算将开始产生无意义的结果。此外，这种计算还依赖于其他假设：首先，我们使用的元素确实有与顶点相关的自由度。对于目前的Q1元素来说确实如此，对于所有多项式阶的Qp元素来说也是如此  <code>p</code>  。然而，这对不连续的元素或混合公式的元素来说是不成立的。其次，它还建立在这样的假设上：一个顶点的位移只由与这个顶点相关的自由度的值决定；换句话说，所有对应于其他自由度的形状函数在这个特定的顶点是零。同样，对于目前的元素来说是这样的，但对于目前在deal.II中的所有元素来说并非如此。尽管有风险，我们还是选择使用这种方式，以便提出一种查询与顶点相关的单个自由度的方法。

// 在这种情况下，指出一种更普遍的方法是很有意义的。对于一般的有限元来说，应该采用正交公式，将正交点放在单元的顶点上。梯形规则的 <code>QTrapezoid</code> 公式正是这样做的。有了这个正交公式，我们就可以在每个单元格中初始化一个 <code>FEValues</code> 对象，并使用 <code>FEValues::get_function_values</code> 函数来获得正交点，即单元格顶点的解函数值。这些是我们真正需要的唯一数值，也就是说，我们对与这个特定正交公式相关的权重（或 <code>JxW</code> 值）完全不感兴趣，这可以作为 <code>FEValues</code> 构造器的最后一个参数来指定。这个方案中唯一的一点小麻烦是，我们必须弄清楚哪个正交点对应于我们目前考虑的顶点，因为它们可能是以相同的顺序排列，也可能不是。

// 如果有限元在顶点上有支持点（这里的支持点是有的；关于支持点的概念，见 @ref GlossSupport "支持点"），这种不便就可以避免了。对于这种情况，我们可以使用 FiniteElement::get_unit_support_points(). 构建一个自定义的正交规则，然后第一个 <code>cell-&gt;n_vertices()*fe.dofs_per_vertex</code> 正交点将对应于单元格的顶点，其顺序与 <code>cell-@>vertex(i)</code> 一致，同时考虑到矢量元素的支持点将被重复 <code>fe.dofs_per_vertex</code> 次。

// 关于这个短函数值得解释的另一点是三角形类输出其顶点信息的方式：通过 <code>Triangulation::n_vertices</code> 函数，它公布了三角形中有多少个顶点。并非所有的顶点都是一直在使用的--有些是之前被粗化的单元的遗留物，自从deal.II以来一直存在，一旦一个顶点出现，即使数量较少的顶点消失了，也不会改变它的编号。其次， <code>cell-@>vertex(v)</code> 返回的位置不仅是一个类型为 <code>Point@<dim@></code> 的只读对象，而且事实上是一个可以写入的引用。这允许相对容易地移动网格的节点，但值得指出的是，使用该功能的应用程序有责任确保所得到的单元仍然有用，即没有扭曲到单元退化的程度（例如，用负的雅各布系数表示）。请注意，我们在这个函数中没有任何规定来实际保证这一点，我们只是有信心。

// 在这个冗长的介绍之后，下面是全部20行左右的代码。

  template <int dim> 
  void TopLevel<dim>::move_mesh() 
  { 
    pcout << "    Moving mesh..." << std::endl; 

    std::vector<bool> vertex_touched(triangulation.n_vertices(), false); 
    for (auto &cell : dof_handler.active_cell_iterators()) 
      for (const auto v : cell->vertex_indices()) 
        if (vertex_touched[cell->vertex_index(v)] == false) 
          { 
            vertex_touched[cell->vertex_index(v)] = true; 

            Point<dim> vertex_displacement; 
            for (unsigned int d = 0; d < dim; ++d) 
              vertex_displacement[d] = 
                incremental_displacement(cell->vertex_dof_index(v, d)); 

            cell->vertex(v) += vertex_displacement; 
          } 
  } 
// @sect4{TopLevel::setup_quadrature_point_history}  

// 在计算的开始，我们需要设置历史变量的初始值，例如材料中的现有应力，我们将其存储在每个正交点中。如上所述，我们使用每个单元中都有的 <code>user_pointer</code> 来做这个。

// 为了从更大的角度看这个问题，我们注意到，如果我们的模型中有先前可用的应力（为了这个程序的目的，我们假定这些应力不存在），那么我们就需要将先前存在的应力场插值到正交点上。同样，如果我们要模拟具有硬化/软化的弹塑性材料，那么我们就必须在每个正交点存储额外的历史变量，如累积塑性应变的当前屈服应力。预先存在的硬化或弱化也将通过在当前函数中插值这些变量来实现。

  template <int dim> 
  void TopLevel<dim>::setup_quadrature_point_history() 
  { 

// 为了慎重起见，我们把所有单元格的用户指针，不管是不是我们的，都设置为空指针。这样，如果我们访问了不应该访问的单元格的用户指针，一个分段故障将让我们知道这不应该发生。

    triangulation.clear_user_data(); 

// 接下来，分配属于这个处理器职责范围内的正交对象。当然，这等于属于这个处理器的单元格的数量乘以我们的正交公式在每个单元格上的正交点的数量。由于`resize()`函数在要求的新大小小于旧大小的情况下，实际上并没有缩小分配的内存量，所以我们采用了一个技巧，首先释放所有的内存，然后再重新分配：我们声明一个空向量作为临时变量，然后交换旧向量和这个临时变量的内容。这就确保了`正交点历史'现在确实是空的，我们可以让现在保存着以前的向量内容的临时变量超出范围并被销毁。在下一步中，我们可以根据需要重新分配尽可能多的元素，矢量默认初始化`PointHistory`对象，这包括将压力变量设置为零。

    { 
      std::vector<PointHistory<dim>> tmp; 
      quadrature_point_history.swap(tmp); 
    } 
    quadrature_point_history.resize( 
      triangulation.n_locally_owned_active_cells() * quadrature_formula.size()); 

// 最后再次循环所有单元，并将属于本处理器的单元的用户指针设置为指向此类对象的向量中与本单元对应的第一个正交点对象。

    unsigned int history_index = 0; 
    for (auto &cell : triangulation.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell->set_user_pointer(&quadrature_point_history[history_index]); 
          history_index += quadrature_formula.size(); 
        } 

// 最后，为了慎重起见，确保我们对元素的计数是正确的，而且我们已经用完了之前分配的所有对象，并且没有指向任何超出向量末端的对象。这样的防御性编程策略总是很好的检查，以避免意外的错误，并防止将来对这个函数的修改忘记同时更新一个变量的所有用途。回顾一下，使用 <code>Assert</code> 宏的构造在优化模式下被优化掉了，所以不影响优化运行的运行时间。

    Assert(history_index == quadrature_point_history.size(), 
           ExcInternalError()); 
  } 

//  @sect4{TopLevel::update_quadrature_point_history}  

// 在每个时间步骤结束时，我们应该计算出一个增量的位移更新，使材料在其新的配置中能够容纳这个时间步骤中施加的外部体和边界力减去通过预先存在的内部应力施加的力之间的差异。为了在下一个时间步骤中获得预先存在的应力，我们必须用本时间步骤中计算的增量位移引起的应力来更新预先存在的应力。理想情况下，所产生的内应力之和将完全抵消所有的外力。事实上，一个简单的实验可以确保这一点：如果我们选择边界条件和体力与时间无关，那么强迫项（外力和内应力之和）应该正好是零。如果你做了这个实验，你会从每个时间步长的右手边的规范输出中意识到这几乎是事实：它并不完全是零，因为在第一个时间步长中，增量位移和应力的更新是相对于未变形的网格计算的，然后再进行变形。在第二个时间步骤中，我们再次计算位移和应力的更新，但这次是在变形的网格中 -- 在那里，结果的更新非常小但不完全是零。这可以迭代，在每一次迭代中，残差，即右手边向量的法线，都会减少；如果做这个小实验，就会发现这个残差的法线会随着迭代次数的增加而呈指数下降，在最初的快速下降之后，每次迭代大约会减少3.5倍（对于我看的一个测试案例，其他测试案例和其他未知数都会改变这个系数，但不会改变指数下降的情况）。

// 在某种意义上，这可以被认为是一个准时序方案，以解决在一个以拉格朗日方式移动的网格上解决大变形弹性的非线性问题。

// 另一个复杂的问题是，现有的（旧的）应力是在旧的网格上定义的，我们将在更新应力后移动这个网格。如果这个网格的更新涉及到单元的旋转，那么我们也需要对更新的应力进行旋转，因为它是相对于旧单元的坐标系计算的。

// 因此，我们需要的是：在当前处理器拥有的每个单元上，我们需要从每个正交点存储的数据中提取旧的应力，计算应力更新，将两者相加，然后将结果与从当前正交点的增量位移计算出来的增量旋转一起旋转。下面我们将详细介绍这些步骤。

  template <int dim> 
  void TopLevel<dim>::update_quadrature_point_history() 
  { 

// 首先，建立一个 <code>FEValues</code> 对象，我们将通过它来评估正交点的增量位移及其梯度，还有一个保存这些信息的向量。

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients); 

    std::vector<std::vector<Tensor<1, dim>>> displacement_increment_grads( 
      quadrature_formula.size(), std::vector<Tensor<1, dim>>(dim)); 

// 然后在所有单元格上循环，在属于我们子域的单元格中进行工作。

    for (auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 

// 接下来，获得一个指向当前单元本地正交点历史数据的指针，作为防御措施，确保这个指针在全局数组的范围内。

          PointHistory<dim> *local_quadrature_points_history = 
            reinterpret_cast<PointHistory<dim> *>(cell->user_pointer()); 
          Assert(local_quadrature_points_history >= 
                   &quadrature_point_history.front(), 
                 ExcInternalError()); 
          Assert(local_quadrature_points_history <= 
                   &quadrature_point_history.back(), 
                 ExcInternalError()); 

// 然后在本单元上初始化 <code>FEValues</code> 对象，并提取正交点上的位移梯度，以便以后计算应变。

          fe_values.reinit(cell); 
          fe_values.get_function_gradients(incremental_displacement, 
                                           displacement_increment_grads); 

// 然后在这个单元的正交点上循环。

          for (unsigned int q = 0; q < quadrature_formula.size(); ++q) 
            { 

// 在每个正交点上，从梯度中计算出应变增量，并将其乘以应力-应变张量，得到应力更新。然后将此更新添加到该点已有的应变中。

              const SymmetricTensor<2, dim> new_stress = 
                (local_quadrature_points_history[q].old_stress + 
                 (stress_strain_tensor * 
                  get_strain(displacement_increment_grads[q]))); 

// 最后，我们要对结果进行旋转。为此，我们首先要从增量位移中计算出目前正交点的旋转矩阵。事实上，它可以从梯度中计算出来，而且我们已经有一个函数用于这个目的。

              const Tensor<2, dim> rotation = 
                get_rotation_matrix(displacement_increment_grads[q]); 

// 注意这个结果，即旋转矩阵，一般来说是一个等级为2的反对称张量，所以我们必须把它作为一个完整的张量来存储。

// 有了这个旋转矩阵，在我们将对称张量 <code>new_stress</code> 扩展为全张量之后，我们可以通过从左和右的收缩来计算旋转的张量。

              const SymmetricTensor<2, dim> rotated_new_stress = 
                symmetrize(transpose(rotation) * 
                           static_cast<Tensor<2, dim>>(new_stress) * rotation); 

// 注意，虽然这三个矩阵的乘法结果应该是对称的，但由于浮点舍入的原因，它并不是对称的：我们得到的结果的非对角线元素有1e-16的不对称性。当把结果赋给一个 <code>SymmetricTensor</code> 时，该类的构造函数会检查对称性并意识到它不是完全对称的；然后它会引发一个异常。为了避免这种情况，我们明确地对结果进行对称，使其完全对称。

// 所有这些操作的结果会被写回到原来的地方。

              local_quadrature_points_history[q].old_stress = 
                rotated_new_stress; 
            } 
        } 
  } 

// 这就结束了项目特定的命名空间  <code>Step18</code>  。其余的和往常一样，并且在  step-17  中已经显示：一个  <code>main()</code>  函数初始化和终止 PETSc，调用做实际工作的类，并确保我们捕捉所有传播到这一点的异常。

} // namespace Step18 

int main(int argc, char **argv) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step18; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      TopLevel<3> elastic_problem; 
      elastic_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-19.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2020 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Wolfgang Bangerth, Rene Gassmoeller, Peter Munch, 2020. 
 */ 


// @sect3{Include files}  

// 本程序中使用的大部分include文件都是 step-6 和类似程序中众所周知的。

#include <deal.II/base/quadrature_lib.h> 

#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/fe/mapping_q.h> 
#include <deal.II/matrix_free/fe_point_evaluation.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/error_estimator.h> 

// 新的只有以下三个。第一个声明了DiscreteTime类，它帮助我们在时间相关的模拟中跟踪时间。后面两个提供了所有的粒子功能，即记录位于网格上的粒子的方法（ Particles::ParticleHandler 类）和为可视化目的输出这些粒子的位置及其属性的能力（ Particles::DataOut  类）。

#include <deal.II/base/discrete_time.h> 
#include <deal.II/particles/particle_handler.h> 
#include <deal.II/particles/data_out.h> 

#include <fstream> 

using namespace dealii; 
// @sect3{Global definitions}  

// 按照惯例，我们把所有与程序细节相对应的东西都放到一个自己的命名空间中。在顶部，我们定义了一些常量，我们宁愿使用符号名称而不是硬编码的数字。

// 具体来说，我们为几何学的各个部分定义了 @ref GlossBoundaryIndicator "边界指标 "的数字，以及电子的物理属性和我们在这里使用的其他具体设置。

// 对于边界指标，让我们从某个随机值101开始列举。这里的原则是要使用*不常见的数字。如果之前有`GridGenerator'函数设置的预定义边界指标，它们很可能是从0开始的小整数，但不是在这个相当随机的范围内。使用下面这样的数字可以避免冲突的可能性，同时也减少了在程序中直接拼出这些数字的诱惑（因为你可能永远不会记得哪个是哪个，而如果它们从0开始，你可能会受到诱惑）。

namespace Step19 
{ 
  namespace BoundaryIds 
  { 
    constexpr types::boundary_id open          = 101; 
    constexpr types::boundary_id cathode       = 102; 
    constexpr types::boundary_id focus_element = 103; 
    constexpr types::boundary_id anode         = 104; 
  } // namespace BoundaryIds 

  namespace Constants 
  { 
    constexpr double electron_mass   = 9.1093837015e-31; 
    constexpr double electron_charge = 1.602176634e-19; 

    constexpr double V0 = 1; 

    constexpr double E_threshold = 0.05; 

    constexpr double electrons_per_particle = 3e15; 
  } // namespace Constants 
// @sect3{The main class}  

// 然后，下面是这个程序的主类。从根本上说，它的结构与 step-6 和其他许多教程程序相同。这包括大部分的成员函数（其余部分的目的可能从它们的名字中不难看出），以及超出 step-6 的少量成员变量，所有这些都与处理粒子有关。

  template <int dim> 
  class CathodeRaySimulator 
  { 
  public: 
    CathodeRaySimulator(); 

    void run(); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void assemble_system(); 
    void solve_field(); 
    void refine_grid(); 

    void create_particles(); 
    void move_particles(); 
    void track_lost_particle( 
      const typename Particles::ParticleIterator<dim> &        particle, 
      const typename Triangulation<dim>::active_cell_iterator &cell); 

    void update_timestep_size(); 
    void output_results() const; 

    Triangulation<dim>        triangulation; 
    MappingQGeneric<dim>      mapping; 
    FE_Q<dim>                 fe; 
    DoFHandler<dim>           dof_handler; 
    AffineConstraints<double> constraints; 

    SparseMatrix<double> system_matrix; 
    SparsityPattern      sparsity_pattern; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    Particles::ParticleHandler<dim> particle_handler; 
    types::particle_index           next_unused_particle_id; 
    types::particle_index           n_recently_lost_particles; 
    types::particle_index           n_total_lost_particles; 
    types::particle_index           n_particles_lost_through_anode; 

    DiscreteTime time; 
  }; 

//  @sect3{The <code>CathodeRaySimulator</code> class implementation}  
// @sect4{The <code>CathodeRaySimulator</code> constructor}  

// 那么，让我们开始执行。构造函数所做的实际上只是对顶部的所有成员变量进行简单的初始化。唯一值得一提的是`particle_handler'，它被交给了一个指向粒子所在的三角形的引用（目前当然还是空的，但是粒子处理程序存储了这个引用，一旦粒子被添加，就会使用它--这发生在三角形被构建之后）。它得到的另一个信息是每个粒子需要存储多少 "属性"。在这里，我们需要每个粒子记住的是它当前的速度，也就是一个带有`dim`分量的矢量。然而，每个粒子还有其他的内在属性， Particles::ParticleHandler 类会自动并始终确保这些属性是可用的；特别是，这些属性是粒子的当前位置、它所在的单元格、它在该单元格中的参考位置，以及粒子的ID。

// 唯一感兴趣的其他变量是 "时间"，一个DiscreteTime类型的对象。它记录了我们在一个随时间变化的模拟中的当前时间，并以开始时间（零）和结束时间（ $10^{-4}$ ）初始化。我们以后将在`update_timestep_size()`中设置时间步长。

// 构造函数的主体由我们在介绍中已经讨论过的一段代码组成。也就是说，我们要确保每次有粒子离开域时，`track_lost_particle()`函数都会被`particle_handler`对象调用。

  template <int dim> 
  CathodeRaySimulator<dim>::CathodeRaySimulator() 
    : mapping(1) 
    , fe(2) 
    , dof_handler(triangulation) 
    , particle_handler(triangulation, mapping, /*n_properties=*/dim) 
    , next_unused_particle_id(0) 
    , n_recently_lost_particles(0) 
    , n_total_lost_particles(0) 
    , n_particles_lost_through_anode(0) 
    , time(0, 1e-4) 
  { 
    particle_handler.signals.particle_lost.connect( 
      [this](const typename Particles::ParticleIterator<dim> &        particle, 
             const typename Triangulation<dim>::active_cell_iterator &cell) { 
        this->track_lost_particle(particle, cell); 
      }); 
  } 

//  @sect4{The <code>CathodeRaySimulator::make_grid</code> function}  

// 下一个函数是负责生成我们要解决的网格。回顾一下域的样子。    
// <p align="center">
//      <img
//      src="https:www.dealii.org/images/steps/developer/step-19.geometry.png"
//           alt="The geometry used in this program"
//           width="600">
//    </p>  我们把这个几何体细分为 $4\times 2$ 个单元的网格，看起来像这样。
//    @code
//    *---*---*---*---*
//    \   |   |   |   |
//     *--*---*---*---*
//    /   |   |   |   |
//    *---*---*---*---*
//  @endcode 
//  这样做的方法是首先定义 $15=5\times 3$ 顶点的位置--在这里，我们说它们在整数点上，左边的中间点向右移动了`delta=0.5`的值。

// 在下文中，我们必须说明哪些顶点共同组成了8个单元。下面的代码就完全等同于我们在 step-14 中的做法。

  template <int dim> 
  void CathodeRaySimulator<dim>::make_grid() 
  { 
    static_assert(dim == 2, 
                  "This function is currently only implemented for 2d."); 

    const double       delta = 0.5; 
    const unsigned int nx    = 5; 
    const unsigned int ny    = 3; 

    const std::vector<Point<dim>> vertices // 
      = {{0, 0}, 
         {1, 0}, 
         {2, 0}, 
         {3, 0}, 
         {4, 0}, 
         {delta, 1}, 
         {1, 1}, 
         {2, 1}, 
         {3, 1}, 
         {4, 1}, 
         {0, 2}, 
         {1, 2}, 
         {2, 2}, 
         {3, 2}, 
         {4, 2}}; 
    AssertDimension(vertices.size(), nx * ny); 

    const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = { 
      {0, 1, nx + 0, nx + 1}, 
      {1, 2, nx + 1, nx + 2}, 
      {2, 3, nx + 2, nx + 3}, 
      {3, 4, nx + 3, nx + 4}, 

      {5, nx + 1, 2 * nx + 0, 2 * nx + 1}, 
      {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2}, 
      {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3}, 
      {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}}; 

// 有了这些数组，我们可以转向稍高的高层数据结构。我们创建一个CellData对象的向量，为每个要创建的单元存储相关的顶点以及 @ref GlossMaterialId "材料ID"（我们在这里将其简单地设置为0，因为我们在程序中不使用它）。

// 然后，这些信息将被传递给 Triangulation::create_triangulation() 函数，并对网格进行两次全局细化。

    std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>()); 
    for (unsigned int i = 0; i < cells.size(); ++i) 
      { 
        cells[i].vertices    = cell_vertices[i]; 
        cells[i].material_id = 0; 
      } 

    triangulation.create_triangulation( 
      vertices, 
      cells, 
      SubCellData()); // No boundary information 

    triangulation.refine_global(2); 

// 该函数的其余部分循环所有的单元格和它们的面，如果一个面在边界上，则决定哪个边界指标应该应用于它。如果你将代码与上面的几何图形相比较，各种条件应该是有意义的。

// 一旦完成了这一步，我们再全局地细化一下网格。

    for (auto &cell : triangulation.active_cell_iterators()) 
      for (auto &face : cell->face_iterators()) 
        if (face->at_boundary()) 
          { 
            if ((face->center()[0] > 0) && (face->center()[0] < 0.5) && 
                (face->center()[1] > 0) && (face->center()[1] < 2)) 
              face->set_boundary_id(BoundaryIds::cathode); 
            else if ((face->center()[0] > 0) && (face->center()[0] < 2)) 
              face->set_boundary_id(BoundaryIds::focus_element); 
            else if ((face->center()[0] > 4 - 1e-12) && 
                     ((face->center()[1] > 1.5) || (face->center()[1] < 0.5))) 
              face->set_boundary_id(BoundaryIds::anode); 
            else 
              face->set_boundary_id(BoundaryIds::open); 
          } 

    triangulation.refine_global(1); 
  } 
// @sect4{The <code>CathodeRaySimulator::setup_system</code> function}  

// 本程序中的下一个函数是处理与解决偏微分方程有关的各种对象的设置。它本质上是对 step-6 中相应函数的复制，不需要进一步讨论。

  template <int dim> 
  void CathodeRaySimulator<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

    VectorTools::interpolate_boundary_values(dof_handler, 
                                             BoundaryIds::cathode, 
                                             Functions::ConstantFunction<dim>( 
                                               -Constants::V0), 
                                             constraints); 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             BoundaryIds::focus_element, 
                                             Functions::ConstantFunction<dim>( 
                                               -Constants::V0), 
                                             constraints); 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             BoundaryIds::anode, 
                                             Functions::ConstantFunction<dim>( 
                                               +Constants::V0), 
                                             constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    constraints, 
                                    /*keep_constrained_dofs =  */ false);

    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
  } 
// @sect4{The <code>CathodeRaySimulator::assemble_system</code> function}  

// 计算矩阵项的函数实质上还是复制了  step-6  中的相应函数。

  template <int dim> 
  void CathodeRaySimulator<dim>::assemble_system() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    const QGauss<dim> quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.dofs_per_cell; 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0; 
        cell_rhs    = 0; 

        fe_values.reinit(cell); 

        for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
          for (const unsigned int i : fe_values.dof_indices()) 
            { 
              for (const unsigned int j : fe_values.dof_indices()) 
                cell_matrix(i, j) += 
                  (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q) 
                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q) 
                   fe_values.JxW(q_index));           // dx 
            } 

// 这个函数唯一有趣的部分是它是如何形成线性系统的右手边的。回顾一下，PDE的右边是
// @f[
//    \sum_p (N e)\delta(\mathbf x-\mathbf x_p),
//  @f]
//  ，在这里我们用 $p$ 来索引粒子，以避免与形状函数 $\varphi_i$ 混淆； $\mathbf x_p$ 是第 $p$ 个粒子的位置。

// 当与测试函数 $\varphi_i$ 相乘并在域上积分时，会得到一个右手边的向量
// @f{align*}{
//    F_i &= \int_\Omega \varphi_i (\mathbf x)\left[
//                 \sum_p (N e)\delta(\mathbf x-\mathbf x_p) \right] dx
//    \\  &=  \sum_p (N e) \varphi_i(\mathbf x_p).
//  @f} 
//  注意最后一行不再包含一个积分，因此也没有出现 $dx$ ，这需要在我们的代码中出现`JxW`符号。
// 
// 对于一个给定的单元 $K$ ，这个单元对右边的贡献是
//  @f{align*}{
//    F_i^K &= \sum_{p, \mathbf x_p\in K} (N e) \varphi_i(\mathbf x_p),
//  @f}，
//  也就是说，我们只需要担心那些实际位于当前单元 $K$ 上的粒子。

// 在实践中，我们在这里所做的是以下几点。如果当前单元格上有任何粒子，那么我们首先获得一个迭代器范围，指向该单元格的第一个粒子以及该单元格上最后一个粒子之后的粒子（或结束迭代器）--即C++函数中常见的半开放范围。现在知道了粒子的列表，我们查询它们的参考位置（相对于参考单元），评估这些参考位置的形状函数，并根据上面的公式计算力（没有任何  FEValues::JxW).  ）。
// @note  值得指出的是，调用 Particles::ParticleHandler::particles_in_cell() 和 Particles::ParticleHandler::n_particles_in_cell() 函数在有大量粒子的问题上不是很有效。但是它说明了写这个算法的最简单的方法，所以我们愿意为了说明问题而暂时承担这个代价。  我们在下面的<a href="#extensions">"possibilities for extensions" section</a>中更详细地讨论了这个问题，并在 step-70 中使用了一个更好的方法，例如：。

        if (particle_handler.n_particles_in_cell(cell) > 0) 
          for (const auto &particle : particle_handler.particles_in_cell(cell)) 
            { 
              const Point<dim> &reference_location = 
                particle.get_reference_location(); 
              for (const unsigned int i : fe_values.dof_indices()) 
                cell_rhs(i) += 
                  (fe.shape_value(i, reference_location) * // phi_i(x_p) 
                   (-Constants::electrons_per_particle *   // N 
                    Constants::electron_charge));          // e 
            } 

// 最后，我们可以把这个单元格的贡献复制到全局矩阵和右边的向量中。

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global( 
          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); 
      } 
  } 
// @sect4{CathodeRaySimulator::solve}  

// 解决线性系统的函数又与 step-6 中的完全一样。

  template <int dim> 
  void CathodeRaySimulator<dim>::solve_field() 
  { 
    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> solver(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    solver.solve(system_matrix, solution, system_rhs, preconditioner); 

    constraints.distribute(solution); 
  } 
// @sect4{CathodeRaySimulator::refine_grid}  

// 最后一个与场相关的函数是细化网格的函数。我们将在第一个时间步骤中多次调用它，以获得一个能很好地适应解的结构的网格，特别是解决解中由于重心角和边界条件类型变化的地方而产生的各种奇异现象。你可能想再参考一下 step-6 以了解更多的细节。

  template <int dim> 
  void CathodeRaySimulator<dim>::refine_grid() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate(dof_handler, 
                                       QGauss<dim - 1>(fe.degree + 1), 
                                       {}, 
                                       solution, 
                                       estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.1, 
                                                    0.03); 

    triangulation.execute_coarsening_and_refinement(); 
  } 
// @sect4{CathodeRaySimulator::create_particles}  

// 现在让我们来看看处理粒子的函数。第一个是关于粒子的创建。正如介绍中提到的，如果电场 $\mathbf E=\nabla V$ 超过某个阈值，即如果 $|\mathbf E| \ge E_\text{threshold}$ ，并且如果电场进一步指向域内（即如果 $\mathbf E \cdot \mathbf n < 0$ ），我们希望在阴极的各点创建一个粒子。正如有限元方法中常见的那样，我们在特定的评估点评估场（及其导数）；通常，这些是 "正交点"，因此我们创建了一个 "正交公式"，我们将用它来指定我们要评估解决方案的点。在这里，我们将简单地采用QMidpoint，意味着我们将只在面的中点检查阈值条件。然后我们用它来初始化一个FEFaceValues类型的对象来评估这些点的解。

// 然后，所有这些将被用于所有单元格、它们的面，特别是那些位于边界的面，而且是边界的阴极部分的循环中。

  template <int dim> 
  void CathodeRaySimulator<dim>::create_particles() 
  { 
    FEFaceValues<dim> fe_face_values(fe, 
                                     QMidpoint<dim - 1>(), 
                                     update_quadrature_points | 
                                       update_gradients | 
                                       update_normal_vectors); 

    std::vector<Tensor<1, dim>> solution_gradients( 
      fe_face_values.n_quadrature_points); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->at_boundary() && 
            (face->boundary_id() == BoundaryIds::cathode)) 
          { 
            fe_face_values.reinit(cell, face); 

// 所以我们已经找到了阴极上的一个面。接下来，我们让FEFaceValues对象计算每个 "正交 "点的解的梯度，并通过 @ref vector_valued "矢量值问题 "文件模块中讨论的方法，以张量变量的形式从梯度中提取电场向量。

            const FEValuesExtractors::Scalar electric_potential(0); 
            fe_face_values[electric_potential].get_function_gradients( 
              solution, solution_gradients); 
            for (const unsigned int q_point : 
                 fe_face_values.quadrature_point_indices()) 
              { 
                const Tensor<1, dim> E = solution_gradients[q_point]; 

// 只有当电场强度超过阈值时，电子才能逃离阴极，而且关键是，如果电场指向*域内，电子才能逃离阴极。      一旦我们检查了这一点，我们就在这个位置创建一个新的 Particles::Particle 对象，并将其插入到 Particles::ParticleHandler 对象中，并设置一个唯一的ID。            这里唯一不明显的是，我们还将这个粒子与我们当前所在的单元格的参考坐标中的位置联系起来。这样做是因为我们将在下游函数中计算诸如粒子位置的电场等量（例如，在每个时间步长中更新其位置时计算作用于它的力）。在任意坐标上评估有限元场是一个相当昂贵的操作，因为形状函数实际上只定义在参考单元上，所以当要求一个任意点的电场时，我们首先要确定这个点的参考坐标是什么。为了避免反复操作，我们一次性地确定这些坐标，然后将这些参考坐标直接存储在粒子上。

                if ((E * fe_face_values.normal_vector(q_point) < 0) && 
                    (E.norm() > Constants::E_threshold)) 
                  { 
                    const Point<dim> &location = 
                      fe_face_values.quadrature_point(q_point); 

                    Particles::Particle<dim> new_particle; 
                    new_particle.set_location(location); 
                    new_particle.set_reference_location( 
                      mapping.transform_real_to_unit_cell(cell, location)); 
                    new_particle.set_id(next_unused_particle_id); 
                    particle_handler.insert_particle(new_particle, cell); 

                    ++next_unused_particle_id; 
                  } 
              } 
          } 

// 在所有这些插入结束时，我们让`particle_handler`更新它所存储的粒子的一些内部统计数据。

    particle_handler.update_cached_numbers(); 
  } 
// @sect4{CathodeRaySimulator::move_particles}  

// 第二个与粒子有关的函数是在每个时间步骤中移动粒子的函数。要做到这一点，我们必须在所有的单元格、每个单元格中的粒子上循环，并评估每个粒子位置的电场。

// 这里使用的方法在概念上与`assemble_system()`函数中使用的相同。我们在所有单元中循环，找到位于那里的粒子（同样要注意这里用来寻找这些粒子的算法的低效率），并使用FEPointEvaluation对象来评估这些位置的梯度。

  template <int dim> 
  void CathodeRaySimulator<dim>::move_particles() 
  { 
    const double dt = time.get_next_step_size(); 

    Vector<double>            solution_values(fe.n_dofs_per_cell()); 
    FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (particle_handler.n_particles_in_cell(cell) > 0) 
        { 
          const typename Particles::ParticleHandler< 
            dim>::particle_iterator_range particles_in_cell = 
            particle_handler.particles_in_cell(cell); 

          std::vector<Point<dim>> particle_positions; 
          for (const auto &particle : particles_in_cell) 
            particle_positions.push_back(particle.get_reference_location()); 

          cell->get_dof_values(solution, solution_values); 

// 然后，我们可以向FEPointEvaluation对象询问这些位置的解决方案的梯度（即电场 $\mathbf E$ ），并在各个粒子上循环。

          evaluator.reinit(cell, particle_positions); 
          evaluator.evaluate(make_array_view(solution_values), 
                             EvaluationFlags::gradients); 

          { 
            typename Particles::ParticleHandler<dim>::particle_iterator 
              particle = particles_in_cell.begin(); 
            for (unsigned int particle_index = 0; 
                 particle != particles_in_cell.end(); 
                 ++particle, ++particle_index) 
              { 
                const Tensor<1, dim> &E = 
                  evaluator.get_gradient(particle_index); 

// 现在我们已经得到了其中一个粒子位置的电场，我们首先用它来更新速度，然后更新位置。为此，我们首先从粒子的属性中获取旧的速度，计算加速度，更新速度，并将这个新的速度再次存储在粒子的属性中。回顾一下，这对应于介绍中所讨论的以下一组更新方程中的第一个。      
      //  @f{align*}{
      //      \frac{{\mathbf v}_i^{(n)}
      //            -{\mathbf v}_i^{(n-1)}}{\Delta t}
      //      &= \frac{e\nabla V^{(n)}}{m}
      //   \\ \frac{{\mathbf x}_i^{(n)}-{\mathbf x}_i^{(n-1)}}
      //           {\Delta t} &= {\mathbf v}_i^{(n)}.
      //  @f}

                const Tensor<1, dim> old_velocity(particle->get_properties()); 

                const Tensor<1, dim> acceleration = 
                  Constants::electron_charge / Constants::electron_mass * E; 

                const Tensor<1, dim> new_velocity = 
                  old_velocity + acceleration * dt; 

                particle->set_properties(make_array_view(new_velocity)); 

// 有了新的速度，我们也就可以更新粒子的位置，并告诉粒子这个位置。

                const Point<dim> new_location = 
                  particle->get_location() + dt * new_velocity; 
                particle->set_location(new_location); 
              } 
          } 
        } 

// 在更新了所有粒子的位置和属性（即速度）之后，我们需要确保`particle_handler`再次知道它们在哪个单元中，以及它们在参考单元坐标系中的位置。下面的函数就是这样做的。(它还确保在并行计算中，如果粒子从一个处理器拥有的子域移动到另一个处理器拥有的子域，那么粒子会从一个处理器移动到另一个处理器。)

    particle_handler.sort_particles_into_subdomains_and_cells(); 
  } 
// @sect4{CathodeRaySimulator::track_lost_particle}  

// 最后一个与粒子相关的函数是当一个粒子从模拟中丢失时被调用的函数。这通常发生在它离开域的时候。如果发生这种情况，这个函数会同时调用单元（我们可以询问它的新位置）和它之前所在的单元。然后，该函数不断跟踪更新这个时间步骤中丢失的粒子数，丢失的粒子总数，然后估计该粒子是否通过阳极中间的孔离开。我们这样做，首先检查它最后所在的单元是否有一个 $x$ 坐标在右边边界的左边（位于 $x=4$ ），而粒子现在的位置在右边边界的右边。如果是这样的话，我们就计算出它的运动方向矢量，这个方向矢量被归一化了，所以方向矢量的 $x$ 分量等于 $1$  。有了这个方向矢量，我们可以计算出它与直线 $x=4$ 的相交位置。如果这个相交点在 $0.5$ 和 $1.5$ 之间，那么我们就声称粒子从孔中离开，并增加一个计数器。

  template <int dim> 
  void CathodeRaySimulator<dim>::track_lost_particle( 
    const typename Particles::ParticleIterator<dim> &        particle, 
    const typename Triangulation<dim>::active_cell_iterator &cell) 
  { 
    ++n_recently_lost_particles; 
    ++n_total_lost_particles; 

    const Point<dim> current_location              = particle->get_location(); 
    const Point<dim> approximate_previous_location = cell->center(); 

    if ((approximate_previous_location[0] < 4) && (current_location[0] > 4)) 
      { 
        const Tensor<1, dim> direction = 
          (current_location - approximate_previous_location) / 
          (current_location[0] - approximate_previous_location[0]); 

        const double right_boundary_intercept = 
          approximate_previous_location[1] + 
          (4 - approximate_previous_location[0]) * direction[1]; 
        if ((right_boundary_intercept > 0.5) && 
            (right_boundary_intercept < 1.5)) 
          ++n_particles_lost_through_anode; 
      } 
  } 

//  @sect4{CathodeRaySimulator::update_timestep_size}  

// 正如在介绍中详细讨论的那样，我们需要尊重一个时间步长条件，即颗粒在一个时间步长中不能移动超过一个单元。为了确保这一点，我们首先计算每个单元上所有粒子的最大速度，然后用该速度除以单元大小。然后，我们使用介绍中讨论的安全系数，将下一个时间步长计算为所有单元上这个量的最小值，并使用 DiscreteTime::set_desired_time_step_size() 函数将其设定为所需的时间步长。

  template <int dim> 
  void CathodeRaySimulator<dim>::update_timestep_size() 
  { 
    if (time.get_step_number() > 0) 
      { 
        double min_cell_size_over_velocity = std::numeric_limits<double>::max(); 

        for (const auto &cell : dof_handler.active_cell_iterators()) 
          if (particle_handler.n_particles_in_cell(cell) > 0) 
            { 
              const double cell_size = cell->minimum_vertex_distance(); 

              double max_particle_velocity(0.0); 

              for (const auto &particle : 
                   particle_handler.particles_in_cell(cell)) 
                { 
                  const Tensor<1, dim> velocity(particle.get_properties()); 
                  max_particle_velocity = 
                    std::max(max_particle_velocity, velocity.norm()); 
                } 

              if (max_particle_velocity > 0) 
                min_cell_size_over_velocity = 
                  std::min(min_cell_size_over_velocity, 
                           cell_size / max_particle_velocity); 
            } 

        constexpr double c_safety = 0.5; 
        time.set_desired_next_step_size(c_safety * 0.5 * 
                                        min_cell_size_over_velocity); 
      } 

// 正如在介绍中提到的，我们必须以不同的方式对待第一个时间步长，因为在那里，粒子还没有出现，或者还没有我们计算合理步长所需的相关信息。下面的公式遵循介绍中的讨论。

    else 
      { 
        const QTrapezoid<dim> vertex_quadrature; 
        FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients); 

        std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size()); 

        double min_timestep = std::numeric_limits<double>::max(); 

        for (const auto &cell : dof_handler.active_cell_iterators()) 
          if (particle_handler.n_particles_in_cell(cell) > 0) 
            { 
              const double cell_size = cell->minimum_vertex_distance(); 

              fe_values.reinit(cell); 
              fe_values.get_function_gradients(solution, field_gradients); 

              double max_E = 0; 
              for (const auto q_point : fe_values.quadrature_point_indices()) 
                max_E = std::max(max_E, field_gradients[q_point].norm()); 

              if (max_E > 0) 
                min_timestep = 
                  std::min(min_timestep, 
                           std::sqrt(0.5 * cell_size * 
                                     Constants::electron_mass / 
                                     Constants::electron_charge / max_E)); 
            } 

        time.set_desired_next_step_size(min_timestep); 
      } 
  } 

//  @sect4{The <code>CathodeRaySimulator::output_results()</code> function}  

// 实现整个算法的最后一个函数是生成图形输出的函数。在目前的情况下，我们想同时输出电势场以及粒子的位置和速度。但我们也想输出电场，即解决方案的梯度。

// deal.II有一个一般的方法，可以从解决方案中计算出派生量，并输出这些量。在这里，这是电场，但也可以是其他的量--比如说，电场的法线，或者事实上任何其他人们想从解 $V_h(\mathbf x)$ 或其导数中计算的量。这个一般的解决方案使用了DataPostprocessor类，在像这里的情况下，我们想输出一个代表矢量场的量，则使用DataPostprocessorVector类。

// 与其尝试解释这个类是如何工作的，不如让我们简单地参考一下DataPostprocessorVector类的文档，这个案例基本上是一个有据可查的例子。

  template <int dim> 
  class ElectricFieldPostprocessor : public DataPostprocessorVector<dim> 
  { 
  public: 
    ElectricFieldPostprocessor() 
      : DataPostprocessorVector<dim>("electric_field", update_gradients) 
    {} 

    virtual void evaluate_scalar_field( 
      const DataPostprocessorInputs::Scalar<dim> &input_data, 
      std::vector<Vector<double>> &computed_quantities) const override 
    { 
      AssertDimension(input_data.solution_gradients.size(), 
                      computed_quantities.size()); 

      for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p) 
        { 
          AssertDimension(computed_quantities[p].size(), dim); 
          for (unsigned int d = 0; d < dim; ++d) 
            computed_quantities[p][d] = input_data.solution_gradients[p][d]; 
        } 
    } 
  }; 

// 有了这个，`output_results()`函数就变得相对简单了。我们使用DataOut类，就像我们在以前几乎所有的教程程序中使用的那样，来输出解决方案（"电动势"），我们使用上面定义的后处理程序来输出其梯度（"电场"）。这些都被写入一个VTU格式的文件中，同时将当前时间和时间步长与该文件联系起来。

  template <int dim> 
  void CathodeRaySimulator<dim>::output_results() const 
  { 
    { 
      ElectricFieldPostprocessor<dim> electric_field; 
      DataOut<dim>                    data_out; 
      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution, "electric_potential"); 
      data_out.add_data_vector(solution, electric_field); 
      data_out.build_patches(); 

      data_out.set_flags( 
        DataOutBase::VtkFlags(time.get_current_time(), time.get_step_number())); 

      std::ofstream output("solution-" + 
                           Utilities::int_to_string(time.get_step_number(), 4) + 
                           ".vtu"); 
      data_out.write_vtu(output); 
    } 

// 输出粒子的位置和属性并不复杂。 Particles::DataOut 类扮演了粒子的DataOut类的角色，我们所要做的就是告诉该类从哪里获取粒子，以及如何解释属性中的`dim`分量--即作为表示速度的单一矢量，而不是作为`dim`标量属性。剩下的就和上面一样了。

    { 
      Particles::DataOut<dim, dim> particle_out; 
      particle_out.build_patches( 
        particle_handler, 
        std::vector<std::string>(dim, "velocity"), 
        std::vector<DataComponentInterpretation::DataComponentInterpretation>( 
          dim, DataComponentInterpretation::component_is_part_of_vector)); 

      particle_out.set_flags( 
        DataOutBase::VtkFlags(time.get_current_time(), time.get_step_number())); 

      std::ofstream output("particles-" + 
                           Utilities::int_to_string(time.get_step_number(), 4) + 
                           ".vtu"); 
      particle_out.write_vtu(output); 
    } 
  } 
// @sect4{CathodeRaySimulator::run}  

// 这个程序的主类的最后一个成员函数是驱动。在顶层，它通过在一连串越来越细的网格上求解问题（尚未创建粒子），对网格进行多次细化。

  template <int dim> 
  void CathodeRaySimulator<dim>::run() 
  { 
    make_grid(); 

//在前面做几个细化循环

    const unsigned int n_pre_refinement_cycles = 3; 
    for (unsigned int refinement_cycle = 0; 
         refinement_cycle < n_pre_refinement_cycles; 
         ++refinement_cycle) 
      { 
        setup_system(); 
        assemble_system(); 
        solve_field(); 
        refine_grid(); 
      } 

// 现在进行时间上的循环。这个步骤的顺序紧跟介绍中讨论的算法大纲。正如在DiscreteTime类的文档中详细讨论的那样，虽然我们将场和粒子信息向前移动了一个时间步长，但存储在`time`变量中的时间与这些量的（部分）位置不一致（在DiscreteTime的字典中，这就是 "更新阶段"）。对`time.advance_time()`的调用通过将`time`变量设置为场和粒子已经处于的时间而使一切重新保持一致，一旦我们处于这个 "一致阶段"，我们就可以生成图形输出并将模拟的当前状态的信息写入屏幕。

    setup_system(); 
    do 
      { 
        std::cout << "Timestep " << time.get_step_number() + 1 << std::endl; 
        std::cout << "  Field degrees of freedom:                 " 
                  << dof_handler.n_dofs() << std::endl; 

        assemble_system(); 
        solve_field(); 

        create_particles(); 
        std::cout << "  Total number of particles in simulation:  " 
                  << particle_handler.n_global_particles() << std::endl; 

        n_recently_lost_particles = 0; 
        update_timestep_size(); 
        move_particles(); 

        time.advance_time(); 

        output_results(); 

        std::cout << "  Number of particles lost this time step:  " 
                  << n_recently_lost_particles << std::endl; 
        if (n_total_lost_particles > 0) 
          std::cout << "  Fraction of particles lost through anode: " 
                    << 1. * n_particles_lost_through_anode / 
                         n_total_lost_particles 
                    << std::endl; 

        std::cout << std::endl 
                  << "  Now at t=" << time.get_current_time() 
                  << ", dt=" << time.get_previous_step_size() << '.' 
                  << std::endl 
                  << std::endl; 
      } 
    while (time.is_at_end() == false); 
  } 
} // namespace Step19 

//  @sect3{The <code>main</code> function}  

// 程序的最后一个函数又是`main()`函数。自 step-6 以来，它在所有的教程程序中都没有变化，因此没有什么新的内容需要讨论。

int main() 
{ 
  try 
    { 
      Step19::CathodeRaySimulator<2> cathode_ray_simulator_2d; 
      cathode_ray_simulator_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 


CCTest_file/step-2.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 1999 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 1999 
 */ 



// 前面几个包括的内容和前面的程序一样，所以不需要额外的注释。

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

// 然而，下一个文件是新的。我们需要这个包含文件来将自由度（DoF）与顶点、直线和单元联系起来。

#include <deal.II/dofs/dof_handler.h> 

// 以下文件包含了对双线性有限元的描述，包括它在三角形的每个顶点上有一个自由度，但在面和单元内部没有自由度。

// (事实上，该文件包含了对拉格朗日元素的一般描述，即还有二次、三次等版本，而且不仅是2d，还有1d和3d。)

#include <deal.II/fe/fe_q.h> 

// 在下面的文件中，可以找到几个操作自由度的工具。

#include <deal.II/dofs/dof_tools.h> 

// 我们将使用一个稀疏矩阵来可视化自由度在网格上的分布所产生的非零条目模式。这个类可以在这里找到。

#include <deal.II/lac/sparse_matrix.h> 

// 我们还需要使用一个中间的稀疏模式结构，可以在这个文件中找到。

#include <deal.II/lac/dynamic_sparsity_pattern.h> 

// 我们希望使用一种特殊的算法来重新计算自由度。它被声明在这里。

#include <deal.II/dofs/dof_renumbering.h> 

// 而这又是C++输出所需要的。

#include <fstream> 

// 最后，和 step-1 一样，我们将deal.II命名空间导入到全局范围。

using namespace dealii; 
// @sect3{Mesh generation}  

// 这就是前面 step-1 例子程序中产生圆形网格的函数，细化步骤较少。唯一不同的是，它通过其参数返回它所产生的网格。

void make_grid(Triangulation<2> &triangulation) 
{ 
  const Point<2> center(1, 0); 
  const double   inner_radius = 0.5, outer_radius = 1.0; 
  GridGenerator::hyper_shell( 
    triangulation, center, inner_radius, outer_radius, 5); 

  for (unsigned int step = 0; step < 3; ++step) 
    { 
      for (auto &cell : triangulation.active_cell_iterators()) 
        for (const auto v : cell->vertex_indices()) 
          { 
            const double distance_from_center = 
              center.distance(cell->vertex(v)); 

            if (std::fabs(distance_from_center - inner_radius) <= 
                1e-6 * inner_radius) 
              { 
                cell->set_refine_flag(); 
                break; 
              } 
          } 

      triangulation.execute_coarsening_and_refinement(); 
    } 
} 
// @sect3{Creation of a DoFHandler}  

// 到目前为止，我们只有一个网格，即一些几何信息（顶点的位置）和一些拓扑信息（顶点如何与线相连，线与单元格相连，以及哪些单元格与哪些其他单元格相邻）。要使用数值算法，还需要一些逻辑信息：我们希望将自由度数字与每个顶点（或线，或单元，如果我们使用高阶元素的话）联系起来，以便以后生成描述三角形上有限元场的矩阵和矢量。

// 这个函数显示了如何做到这一点。要考虑的对象是 <code>DoFHandler</code> 类模板。 然而，在这之前，我们首先需要一些东西来描述这些对象中的每一个要与多少个自由度相关联。由于这是有限元空间定义的一个方面，有限元基类存储了这个信息。在目前的情况下，我们因此创建了一个描述拉格朗日元素的派生类 <code>FE_Q</code> 的对象。它的构造函数需要一个参数，说明元素的多项式程度，这里是1（表示一个双线性元素）；这就对应于每个顶点的一个自由度，而线和四边形内部没有自由度。如果给构造函数的值是3，我们就会得到一个双立方体元素，每个顶点有一个自由度，每条线有两个自由度，单元内有四个自由度。一般来说， <code>FE_Q</code> 表示具有完整多项式（即张量积多项式）的连续元素家族，直到指定的顺序。

// 我们首先需要创建一个这个类的对象，然后把它传递给 <code>DoFHandler</code> 对象，为自由度分配存储空间（用deal.II的行话说：我们<i>distribute degrees of freedom</i>）。

void distribute_dofs(DoFHandler<2> &dof_handler) 
{ 
  const FE_Q<2> finite_element(1); 
  dof_handler.distribute_dofs(finite_element); 

// 现在我们已经将自由度与每个顶点的全局数字联系起来，我们想知道如何将其可视化？ 没有简单的方法可以直接将与每个顶点相关的自由度数字可视化。然而，这样的信息几乎不会真正重要，因为编号本身或多或少是任意的。还有更重要的因素，我们将在下文中展示其中一个。

// 与三角形的每个顶点相关的是一个形状函数。假设我们想解决类似拉普拉斯方程的问题，那么不同的矩阵条目将是每对这样的形状函数的梯度的积分。显然，由于形状函数只在与它们相关的顶点相邻的单元格上是非零的，所以只有当与该列和行%号相关的形状函数的支持相交时，矩阵条目才是非零的。这只是相邻形状函数的情况，因此也只是相邻顶点的情况。现在，由于顶点被上述函数 (DoFHandler::distribute_dofs), 或多或少地随机编号，矩阵中非零项的模式将有些参差不齐，我们现在就来看看它。

// 首先，我们要创建一个结构，用来存储非零元素的位置。然后，这个结构可以被一个或多个稀疏矩阵对象使用，这些对象在这个稀疏模式所存储的位置上存储条目的值。存储这些位置的类是SparsityPattern类。然而，事实证明，当我们试图立即填充这个类时，它有一些缺点：它的数据结构的设置方式是，我们需要对我们可能希望在每一行的最大条目数有一个估计。在两个空间维度上，通过 DoFHandler::max_couplings_between_dofs() 函数可以得到合理的估计值，但是在三个维度上，该函数几乎总是严重高估真实的数字，导致大量的内存浪费，有时对于所使用的机器来说太多，即使未使用的内存可以在计算稀疏模式后立即释放。为了避免这种情况，我们使用了一个中间对象DynamicSparsityPattern，该对象使用了一个不同的%内部数据结构，我们可以随后将其复制到SparsityPattern对象中，而不需要太多的开销。关于这些数据结构的一些更多信息可以在 @ref Sparsity 模块中找到）。为了初始化这个中间数据结构，我们必须给它提供矩阵的大小，在我们的例子中，矩阵是正方形的，行和列的数量与网格上的自由度相同。

  DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(), 
                                                  dof_handler.n_dofs()); 

// 然后我们在这个对象中填入非零元素的位置，考虑到目前自由度的编号。

  DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern); 

// 现在我们已经准备好创建实际的稀疏模式了，以后我们可以用在我们的矩阵上。它将包含已经在DynamicSparsityPattern中集合的数据。

  SparsityPattern sparsity_pattern; 
  sparsity_pattern.copy_from(dynamic_sparsity_pattern); 

// 有了这个，我们现在可以把结果写到一个文件里。

  std::ofstream out("sparsity_pattern1.svg"); 
  sparsity_pattern.print_svg(out); 

// 结果被存储在一个 <code>.svg</code> 文件中，矩阵中的每个非零条目都对应于图像中的一个红色方块。输出结果将显示如下。

// 如果你看一下，你会注意到稀疏性模式是对称的。这不应该是一个惊喜，因为我们没有给 <code>DoFTools::make_sparsity_pattern</code> 任何信息，表明我们的双线性形式可能以非对称的方式耦合形状函数。你还会注意到它有几个明显的区域，这源于编号从最粗的单元开始，然后到较细的单元；由于它们都是围绕原点对称分布的，这在稀疏模式中再次显示出来。

} 
// @sect3{Renumbering of DoFs}  

// 在上面产生的稀疏模式中，非零条目在对角线上延伸得很远。对于某些算法来说，例如不完全LU分解或Gauss-Seidel预处理，这是不利的，我们将展示一个简单的方法来改善这种情况。

// 请记住，为了使矩阵中的一个条目 $(i,j)$ 不为零，形状函数i和j的支持需要相交（否则在积分中，积分将到处为零，因为在某个点上，一个或另一个形状函数为零）。然而，形状函数的支撑点只有在彼此相邻的情况下才会相交，所以为了使非零条目聚集在对角线周围（其中 $i$ 等于 $j$ ），我们希望相邻的形状函数的索引（DoF编号）相差不大。

// 这可以通过一个简单的前行算法来实现，即从一个给定的顶点开始，给它的索引为0。然后，依次对其邻居进行编号，使其指数接近于原始指数。然后，他们的邻居，如果还没有被编号，也被编号，以此类推。

// 有一种算法沿着这些思路增加了一点复杂性，那就是Cuthill和McKee的算法。我们将在下面的函数中使用它来对自由度进行重新编号，从而使产生的稀疏模式在对角线周围更加本地化。该函数唯一有趣的部分是对 <code>DoFRenumbering::Cuthill_McKee</code> 的第一次调用，其余部分基本上与以前一样。

void renumber_dofs(DoFHandler<2> &dof_handler) 
{ 
  DoFRenumbering::Cuthill_McKee(dof_handler); 

  DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(), 
                                                  dof_handler.n_dofs()); 
  DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern); 

  SparsityPattern sparsity_pattern; 
  sparsity_pattern.copy_from(dynamic_sparsity_pattern); 

  std::ofstream out("sparsity_pattern2.svg"); 
  sparsity_pattern.print_svg(out); 
} 

// 再次，输出如下。请注意，非零项在对角线附近的聚类情况要比以前好得多。这种效果对于较大的矩阵来说更加明显（目前的矩阵有1260行和列，但是大的矩阵往往有几十万行）。

// 值得注意的是， <code>DoFRenumbering</code> 类也提供了一些其他的算法来重新编号自由度。例如，如果所有的耦合都在矩阵的下三角或上三角部分，那当然是最理想的，因为这样的话，解决线性系统就只需要向前或向后替换。当然，这对于对称稀疏模式来说是无法实现的，但在一些涉及传输方程的特殊情况下，通过列举从流入边界沿流线到流出边界的自由度，这是可能的。毫不奇怪， <code>DoFRenumbering</code> 也有这方面的算法。

//  @sect3{The main function}  

// 最后，这是主程序。它所做的唯一一件事就是分配和创建三角形，然后创建一个 <code>DoFHandler</code> 对象并将其与三角形相关联，最后对其调用上述两个函数。

int main() 
{ 
  Triangulation<2> triangulation; 
  make_grid(triangulation); 

  DoFHandler<2> dof_handler(triangulation); 

  distribute_dofs(dof_handler); 
  renumber_dofs(dof_handler); 
} 


CCTest_file/step-20.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2005 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 */ 


// @sect3{Include files}  

// 由于这个程序只是对 step-4 的改编，所以在头文件方面没有太多的新东西。在deal.II中，我们通常按照base-lac-grid-dofs-fe-numerics的顺序列出包含文件，然后是C++标准包含文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 

#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 

// 唯一值得关注的两个新头文件是LinearOperator和PackagedOperation类的文件。

#include <deal.II/lac/linear_operator.h> 
#include <deal.II/lac/packaged_operation.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iostream> 

// 这是唯一重要的新标题，即声明Raviart-Thomas有限元的标题。

#include <deal.II/fe/fe_raviart_thomas.h> 

// 最后，作为本程序中的一项奖励，我们将使用一个张量系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了 <code>TensorFunction</code> 类，提供了这样的功能。

#include <deal.II/base/tensor_function.h> 

// 最后一步和以前所有的程序一样。我们把所有与这个程序相关的代码放到一个命名空间中。(这个想法在  step-7  中首次提出) 。

namespace Step20 
{ 
  using namespace dealii; 
// @sect3{The <code>MixedLaplaceProblem</code> class template}  

// 同样，由于这是对 step-6 的改编，主类与该教程程序中的主类几乎相同。就成员函数而言，主要区别在于构造函数将Raviart-Thomas元素的度数作为参数（并且有一个相应的成员变量来存储这个值），并且增加了 <code>compute_error</code> 函数，在这个函数中，不出意外，我们将计算精确解和数值解之间的差异，以确定我们计算的收敛性。

  template <int dim> 
  class MixedLaplaceProblem 
  { 
  public: 
    MixedLaplaceProblem(const unsigned int degree); 
    void run(); 

  private: 
    void make_grid_and_dofs(); 
    void assemble_system(); 
    void solve(); 
    void compute_errors() const; 
    void output_results() const; 

    const unsigned int degree; 

    Triangulation<dim> triangulation; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 

// 第二个区别是疏散模式、系统矩阵、解和右手向量现在被封锁了。这意味着什么，人们可以用这些对象做什么，在本程序的介绍中已经解释过了，下面我们在解释这个问题的线性求解器和预处理器时也会进一步解释。

    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> system_matrix; 

    BlockVector<double> solution; 
    BlockVector<double> system_rhs; 
  }; 
// @sect3{Right hand side, boundary values, and exact solution}  

// 我们的下一个任务是定义我们问题的右手边（即原始拉普拉斯方程中压力的标量右手边），压力的边界值，以及一个描述压力和精确解的速度的函数，以便以后计算误差。请注意，这些函数分别有一个、一个和 <code>dim+1</code> 个分量，我们将分量的数量传递给 <code>Function@<dim@></code> 基类。对于精确解，我们只声明实际一次性返回整个解向量（即其中的所有成分）的函数。下面是各自的声明。

  namespace PrescribedSolution 
  { 
    constexpr double alpha = 0.3; 
    constexpr double beta  = 1; 

    template <int dim> 
    class RightHandSide : public Function<dim> 
    { 
    public: 
      RightHandSide() 
        : Function<dim>(1) 
      {} 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 
    }; 

    template <int dim> 
    class PressureBoundaryValues : public Function<dim> 
    { 
    public: 
      PressureBoundaryValues() 
        : Function<dim>(1) 
      {} 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 
    }; 

    template <int dim> 
    class ExactSolution : public Function<dim> 
    { 
    public: 
      ExactSolution() 
        : Function<dim>(dim + 1) 
      {} 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  value) const override; 
    }; 

// 然后我们还必须定义这些各自的函数，当然了。鉴于我们在介绍中讨论了解决方案应该是怎样的，下面的计算应该是很简单的。

    template <int dim> 
    double RightHandSide<dim>::value(const Point<dim> & /*p*/, 
                                     const unsigned int /*component*/) const 
    { 
      return 0; 
    } 

    template <int dim> 
    double 
    PressureBoundaryValues<dim>::value(const Point<dim> &p, 
                                       const unsigned int /*component*/) const 
    { 
      return -(alpha * p[0] * p[1] * p[1] / 2 + beta * p[0] - 
               alpha * p[0] * p[0] * p[0] / 6); 
    } 

    template <int dim> 
    void ExactSolution<dim>::vector_value(const Point<dim> &p, 
                                          Vector<double> &  values) const 
    { 
      Assert(values.size() == dim + 1, 
             ExcDimensionMismatch(values.size(), dim + 1)); 

      values(0) = alpha * p[1] * p[1] / 2 + beta - alpha * p[0] * p[0] / 2; 
      values(1) = alpha * p[0] * p[1]; 
      values(2) = -(alpha * p[0] * p[1] * p[1] / 2 + beta * p[0] - 
                    alpha * p[0] * p[0] * p[0] / 6); 
    } 

//  @sect3{The inverse permeability tensor}  

// 除了其他方程数据外，我们还想使用渗透性张量，或者更好的是--因为这是在弱形式中出现的全部内容--渗透性张量的逆，  <code>KInverse</code>  。对于验证解的精确性和确定收敛顺序的目的来说，这个张量的作用大于帮助。因此，我们将简单地把它设置为同一矩阵。

// 然而，在现实生活中的多孔介质流动模拟中，空间变化的渗透率张量是不可缺少的，我们想利用这个机会来展示使用张量值函数的技术。

// 可能不足为奇，deal.II也有一个基类，不仅适用于标量和一般的矢量值函数（ <code>Function</code> 基类），也适用于返回固定维度和等级的张量的函数， <code>TensorFunction</code> 模板。在这里，所考虑的函数返回一个dim-by-dim矩阵，即一个等级为2、维度为 <code>dim</code> 的张量。然后我们适当地选择基类的模板参数。

//  <code>TensorFunction</code> 类提供的接口本质上等同于 <code>Function</code> 类。特别是，存在一个 <code>value_list</code> 函数，它接收一个评估函数的点的列表，并在第二个参数中返回函数的值，一个张量的列表。

    template <int dim> 
    class KInverse : public TensorFunction<2, dim> 
    { 
    public: 
      KInverse() 
        : TensorFunction<2, dim>() 
      {} 

      virtual void 
      value_list(const std::vector<Point<dim>> &points, 
                 std::vector<Tensor<2, dim>> &  values) const override; 
    }; 

// 实现起来就不那么有趣了。和以前的例子一样，我们在类的开头添加一个检查，以确保输入和输出参数的大小是相同的（关于这个技术的讨论见 step-5 ）。然后我们在所有的评估点上循环，对于每一个评估点，将输出张量设置为身份矩阵。

// 在函数的顶部有一个奇怪的地方（`(void)point;`语句），值得讨论。我们放到输出`values`数组中的值实际上并不取决于函数被评估的坐标`points`数组。换句话说，`points'参数实际上是不用的，如果我们想的话，可以不给它起名字。但是我们想用`points`对象来检查`values`对象是否有正确的大小。问题是，在发布模式下，`AssertDimension`被定义为一个宏，扩展为空；然后编译器会抱怨`points`对象没有使用。消除这个警告的习惯方法是有一个评估（读取）变量的语句，但实际上不做任何事情：这就是`(void)points;`所做的：它从`points`中读取，然后将读取的结果转换为`void`，也就是什么都没有。换句话说，这句话是完全没有意义的，除了向编译器解释是的，这个变量事实上是被使用的，即使是在发布模式下。(在调试模式下，`AssertDimension`宏会扩展为从变量中读出的东西，所以在调试模式下，这个有趣的语句是没有必要的)。

    template <int dim> 
    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points, 
                                   std::vector<Tensor<2, dim>> &  values) const 
    { 
      (void)points; 
      AssertDimension(points.size(), values.size()); 

      for (auto &value : values) 
        value = unit_symmetric_tensor<dim>(); 
    } 
  } // namespace PrescribedSolution 

//  @sect3{MixedLaplaceProblem class implementation}  
// @sect4{MixedLaplaceProblem::MixedLaplaceProblem}  

// 在这个类的构造函数中，我们首先存储传入的关于我们将使用的有限元的度数的值（例如，度数为0，意味着使用RT(0)和DG(0)），然后构造属于介绍中描述的空间 $X_h$ 的向量值的元素。构造函数的其余部分与早期的教程程序一样。

// 这里唯一值得描述的是，这个变量所属的 <code>fe</code> variable. The <code>FESystem</code> 类的构造函数调用有很多不同的构造函数，它们都是指将较简单的元素绑定在一起，成为一个较大的元素。在目前的情况下，我们想把一个RT(度)元素与一个DQ(度)元素结合起来。这样做的 <code>FESystem</code> 构造函数要求我们首先指定第一个基本元素（给定程度的 <code>FE_RaviartThomas</code> 对象），然后指定这个基本元素的副本数量，然后类似地指定 <code>FE_DGQ</code> 元素的种类和数量。注意Raviart-Thomas元素已经有 <code>dim</code> 个矢量分量，所以耦合元素将有 <code>dim+1</code> 个矢量分量，其中第一个 <code>dim</code> 个对应于速度变量，最后一个对应于压力。

// 我们从基本元素中构建这个元素的方式与我们在 step-8 中的方式也值得比较：在那里，我们将其构建为 <code>fe (FE_Q@<dim@>(1), dim)</code> ，即我们简单地使用 <code>dim</code> copies of the <code>FE_Q(1)</code> 元素，每个坐标方向上的位移都有一份。

  template <int dim> 
  MixedLaplaceProblem<dim>::MixedLaplaceProblem(const unsigned int degree) 
    : degree(degree) 
    , fe(FE_RaviartThomas<dim>(degree), 1, FE_DGQ<dim>(degree), 1) 
    , dof_handler(triangulation) 
  {} 

//  @sect4{MixedLaplaceProblem::make_grid_and_dofs}  

// 接下来的函数开始于众所周知的函数调用，创建和细化一个网格，然后将自由度与之关联。

  template <int dim> 
  void MixedLaplaceProblem<dim>::make_grid_and_dofs() 
  { 
    GridGenerator::hyper_cube(triangulation, -1, 1); 
    triangulation.refine_global(5); 

    dof_handler.distribute_dofs(fe); 

// 然而，接下来事情就变得不同了。正如介绍中提到的，我们要将矩阵细分为对应于速度和压力这两种不同的变量的块。为此，我们首先要确保与速度和压力相对应的指数不会混在一起。首先是所有速度自由度，然后是所有压力自由度。这样一来，全局矩阵就很好地分离成一个 $2 \times 2$ 系统。为了达到这个目的，我们必须根据自由度的矢量分量对其重新编号，这个操作已经很方便地实现了。

    DoFRenumbering::component_wise(dof_handler); 

// 接下来，我们要弄清楚这些块的大小，以便我们可以分配适当的空间量。为此，我们调用了 DoFTools::count_dofs_per_fe_component() 函数，该函数计算了某个向量分量的形状函数非零的数量。我们有 <code>dim+1</code> 个向量分量， DoFTools::count_dofs_per_fe_component() 将计算有多少个形状函数属于这些分量中的每个。

// 这里有一个问题。正如该函数的文档所描述的，它 <i>wants</i> 将  $x$  -速度形状函数的数量放入  <code>dofs_per_component[0]</code>  中，将  $y$  -速度形状函数的数量放入  <code>dofs_per_component[1]</code>  中（以及类似的3d），并将压力形状函数的数量放入  <code>dofs_per_component[dim]</code>  中 。但是，Raviart-Thomas元素的特殊性在于它是非 @ref GlossPrimitive "原始 "的，也就是说，对于Raviart-Thomas元素，所有的速度形状函数在所有分量中都是非零。换句话说，该函数不能区分 $x$ 和 $y$ 速度函数，因为<i>is</i>没有这种区分。因此，它将速度的总体数量放入 <code>dofs_per_component[c]</code>  ,  $0\le c\le \text{dim}$ 中的每一个。另一方面，压力变量的数量等于在dim-th分量中不为零的形状函数的数量。

// 利用这些知识，我们可以从 <code>dofs_per_component</code> 的第一个 <code>dim</code> 元素中的任何一个得到速度形状函数的数量，然后用下面这个来初始化向量和矩阵块的大小，以及创建输出。

//  @note  如果你觉得这个概念难以理解，你可以考虑用函数  DoFTools::count_dofs_per_fe_block()  来代替，就像我们在  step-22  的相应代码中做的那样。你可能还想阅读一下术语表中 @ref GlossBlock "块 "和 @ref GlossComponent "组件 "的区别。

    const std::vector<types::global_dof_index> dofs_per_component = 
      DoFTools::count_dofs_per_fe_component(dof_handler); 
    const unsigned int n_u = dofs_per_component[0], 
                       n_p = dofs_per_component[dim]; 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "Total number of cells: " << triangulation.n_cells() 
              << std::endl 
              << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (" << n_u << '+' << n_p << ')' << std::endl; 

// 下一个任务是为我们将要创建的矩阵分配一个稀疏模式。我们使用与前面步骤一样的压缩稀疏模式，但是由于 <code>system_matrix</code> 是一个块状矩阵，我们使用 <code>BlockDynamicSparsityPattern</code> 类，而不仅仅是 <code>DynamicSparsityPattern</code>  。这种块状稀疏模式在 $2 \times 2$ 模式下有四个块。块的大小取决于 <code>n_u</code> and <code>n_p</code> ，它持有速度和压力变量的数量。在第二步中，我们必须指示块系统更新它所管理的块的大小的知识；这发生在 <code>dsp.collect_sizes ()</code> 的调用中。

    BlockDynamicSparsityPattern dsp(2, 2); 
    dsp.block(0, 0).reinit(n_u, n_u); 
    dsp.block(1, 0).reinit(n_p, n_u); 
    dsp.block(0, 1).reinit(n_u, n_p); 
    dsp.block(1, 1).reinit(n_p, n_p); 
    dsp.collect_sizes(); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 

// 我们以与非区块版本相同的方式使用压缩的区块稀疏模式，以创建稀疏模式，然后创建系统矩阵。

    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 

// 然后，我们必须以与块压缩稀疏度模式完全相同的方式调整解决方案和右侧向量的大小。

    solution.reinit(2); 
    solution.block(0).reinit(n_u); 
    solution.block(1).reinit(n_p); 
    solution.collect_sizes(); 

    system_rhs.reinit(2); 
    system_rhs.block(0).reinit(n_u); 
    system_rhs.block(1).reinit(n_p); 
    system_rhs.collect_sizes(); 
  } 
// @sect4{MixedLaplaceProblem::assemble_system}  

// 同样地，组装线性系统的函数在这个例子的介绍中已经讨论过很多了。在它的顶部，发生的是所有常见的步骤，此外，我们不仅为单元项分配正交和 <code>FEValues</code> 对象，而且还为面项分配。之后，我们为变量定义通常的缩写，并为本地矩阵和右手贡献分配空间，以及保存当前单元的全局自由度数的数组。

  template <int dim> 
  void MixedLaplaceProblem<dim>::assemble_system() 
  { 
    QGauss<dim>     quadrature_formula(degree + 2); 
    QGauss<dim - 1> face_quadrature_formula(degree + 2); 

    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    FEFaceValues<dim> fe_face_values(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_normal_vectors | 
                                       update_quadrature_points | 
                                       update_JxW_values); 

    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 下一步是声明代表方程中源项、压力边界值和系数的对象。除了这些代表连续函数的对象外，我们还需要数组来保存它们在各个单元格（或面，对于边界值）的正交点的值。请注意，在系数的情况下，数组必须是矩阵的一种。

    const PrescribedSolution::RightHandSide<dim> right_hand_side; 
    const PrescribedSolution::PressureBoundaryValues<dim> 
                                            pressure_boundary_values; 
    const PrescribedSolution::KInverse<dim> k_inverse; 

    std::vector<double>         rhs_values(n_q_points); 
    std::vector<double>         boundary_values(n_face_q_points); 
    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points); 

// 最后，我们需要几个提取器，用来获取矢量值形状函数的速度和压力成分。它们的功能和使用在 @ref vector_valued报告中有详细描述。基本上，我们将把它们作为下面FEValues对象的下标：FEValues对象描述了形状函数的所有矢量分量，而在订阅后，它将只指速度（一组从零分量开始的 <code>dim</code> 分量）或压力（位于 <code>dim</code> 位置的标量分量）。

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

// 有了这些，我们就可以继续对所有单元进行循环。这个循环的主体已经在介绍中讨论过了，这里就不再做任何评论了。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        local_matrix = 0; 
        local_rhs    = 0; 

        right_hand_side.value_list(fe_values.get_quadrature_points(), 
                                   rhs_values); 
        k_inverse.value_list(fe_values.get_quadrature_points(), 
                             k_inverse_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const Tensor<1, dim> phi_i_u = fe_values[velocities].value(i, q); 
              const double div_phi_i_u = fe_values[velocities].divergence(i, q); 
              const double phi_i_p     = fe_values[pressure].value(i, q); 

              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const Tensor<1, dim> phi_j_u = 
                    fe_values[velocities].value(j, q); 
                  const double div_phi_j_u = 
                    fe_values[velocities].divergence(j, q); 
                  const double phi_j_p = fe_values[pressure].value(j, q); 

                  local_matrix(i, j) += 
                    (phi_i_u * k_inverse_values[q] * phi_j_u // 
                     - phi_i_p * div_phi_j_u                 // 
                     - div_phi_i_u * phi_j_p)                // 
                    * fe_values.JxW(q); 
                } 

              local_rhs(i) += -phi_i_p * rhs_values[q] * fe_values.JxW(q); 
            } 

        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary()) 
            { 
              fe_face_values.reinit(cell, face); 

              pressure_boundary_values.value_list( 
                fe_face_values.get_quadrature_points(), boundary_values); 

              for (unsigned int q = 0; q < n_face_q_points; ++q) 
                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  local_rhs(i) += -(fe_face_values[velocities].value(i, q) * // 
                                    fe_face_values.normal_vector(q) *        // 
                                    boundary_values[q] *                     // 
                                    fe_face_values.JxW(q)); 
            } 

// 循环所有单元的最后一步是将局部贡献转移到全局矩阵和右手向量中。请注意，我们使用的接口与之前的例子完全相同，尽管我们现在使用的是块状矩阵和向量，而不是常规的。换句话说，对于外界来说，块对象具有与矩阵和向量相同的接口，但它们还允许访问单个块。

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              local_matrix(i, j)); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          system_rhs(local_dof_indices[i]) += local_rhs(i); 
      } 
  } 
// @sect3{Implementation of linear solvers and preconditioners}  

// 我们在这个例子中使用的线性求解器和预处理器已经在介绍中进行了详细的讨论。因此，我们在这里不再讨论我们的方法的原理，而只是对剩下的一些实现方面进行评论。

//  @sect4{MixedLaplace::solve}  

// 正如在介绍中所概述的那样，求解函数基本上由两个步骤组成。首先，我们必须形成涉及舒尔补数的第一个方程，并求解压力（解决方案的第一部分）。然后，我们可以从第二个方程（解的第0部分）中重构速度。

  template <int dim> 
  void MixedLaplaceProblem<dim>::solve() 
  { 

// 作为第一步，我们声明对矩阵的所有块状成分、右手边和我们将需要的解向量的引用。

    const auto &M = system_matrix.block(0, 0); 
    const auto &B = system_matrix.block(0, 1); 

    const auto &F = system_rhs.block(0); 
    const auto &G = system_rhs.block(1); 

    auto &U = solution.block(0); 
    auto &P = solution.block(1); 

// 然后，我们将创建相应的LinearOperator对象并创建 <code>op_M_inv</code> 运算器。

    const auto op_M = linear_operator(M); 
    const auto op_B = linear_operator(B); 

    ReductionControl         reduction_control_M(2000, 1.0e-18, 1.0e-10); 
    SolverCG<Vector<double>> solver_M(reduction_control_M); 
    PreconditionJacobi<SparseMatrix<double>> preconditioner_M; 

    preconditioner_M.initialize(M); 

    const auto op_M_inv = inverse_operator(op_M, solver_M, preconditioner_M); 

// 这样我们就可以声明舒尔补数  <code>op_S</code>  和近似舒尔补数  <code>op_aS</code>  。

    const auto op_S = transpose_operator(op_B) * op_M_inv * op_B; 
    const auto op_aS = 
      transpose_operator(op_B) * linear_operator(preconditioner_M) * op_B; 

// 我们现在从 <code>op_aS</code> 中创建一个预处理程序，应用固定数量的30次（便宜的）CG迭代。

    IterationNumberControl   iteration_number_control_aS(30, 1.e-18); 
    SolverCG<Vector<double>> solver_aS(iteration_number_control_aS); 

    const auto preconditioner_S = 
      inverse_operator(op_aS, solver_aS, PreconditionIdentity()); 

// 现在来看看第一个方程。它的右边是 $B^TM^{-1}F-G$  ，这就是我们在前几行计算的结果。然后我们用CG求解器和我们刚刚声明的预处理程序来解决第一个方程。

    const auto schur_rhs = transpose_operator(op_B) * op_M_inv * F - G; 

    SolverControl            solver_control_S(2000, 1.e-12); 
    SolverCG<Vector<double>> solver_S(solver_control_S); 

    const auto op_S_inv = inverse_operator(op_S, solver_S, preconditioner_S); 

    P = op_S_inv * schur_rhs; 

    std::cout << solver_control_S.last_step() 
              << " CG Schur complement iterations to obtain convergence." 
              << std::endl; 

// 得到压力后，我们可以计算速度。方程为 $MU=-BP+F$  ，我们通过首先计算右手边，然后与代表质量矩阵逆的对象相乘来解决这个问题。

    U = op_M_inv * (F - op_B * P); 
  } 
// @sect3{MixedLaplaceProblem class implementation (continued)}  
// @sect4{MixedLaplace::compute_errors}  

// 在我们处理完线性求解器和预处理器之后，我们继续实现我们的主类。特别是，下一个任务是计算我们数值解的误差，包括压力和速度。

// 为了计算解的误差，我们已经在  step-7  和  step-11  中介绍了  <code>VectorTools::integrate_difference</code>  函数。然而，在那里我们只处理了标量解，而在这里我们有一个矢量值的解，其组成部分甚至表示不同的量，并且可能有不同的收敛阶数（由于所使用的有限元的选择，这里不是这种情况，但在混合有限元应用中经常出现这种情况）。因此，我们要做的是 "掩盖 "我们感兴趣的成分。这很容易做到： <code>VectorTools::integrate_difference</code> 函数将一个指向权重函数的指针作为其参数之一（该参数默认为空指针，意味着单位权重）。我们要做的是传递一个函数对象，在我们感兴趣的成分中等于1，而在其他成分中等于0。例如，为了计算压力误差，我们应该传入一个函数，该函数在分量 <code>dim</code> 中代表单位值的常数向量，而对于速度，常数向量在第一个 <code>dim</code> 分量中应该是1，而在压力的位置是0。

// 在deal.II中， <code>ComponentSelectFunction</code> 正是这样做的：它想知道它要表示的函数应该有多少个向量分量（在我们的例子中，这将是 <code>dim+1</code> ，用于联合速度-压力空间），哪个个体或范围的分量应该等于1。因此，我们在函数的开头定义了两个这样的掩码，接下来是一个代表精确解的对象和一个向量，我们将在其中存储由 <code>integrate_difference</code> 计算的单元误差。

  template <int dim> 
  void MixedLaplaceProblem<dim>::compute_errors() const 
  { 
    const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1); 
    const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim), 
                                                     dim + 1); 

    PrescribedSolution::ExactSolution<dim> exact_solution; 
    Vector<double> cellwise_errors(triangulation.n_active_cells()); 

// 正如在 step-7 中已经讨论过的那样，我们必须认识到，不可能精确地整合误差。我们所能做的就是用正交法对这个积分进行近似。这实际上在这里提出了一个小小的转折：如果我们像人们可能倾向于做的那样天真地选择一个 <code>QGauss@<dim@>(degree+1)</code> 类型的对象（这就是我们用于积分线性系统的对象），就会发现误差非常小，根本不遵循预期的收敛曲线。现在的情况是，对于这里使用的混合有限元，高斯点恰好是超收敛点，其中的点误差要比其他地方小得多（而且收敛的阶数更高）。因此，这些点不是特别好的积分点。为了避免这个问题，我们只需使用梯形法则，并在每个坐标方向上迭代 <code>degree+2</code> 次（同样如 step-7 中的解释）。

    QTrapezoid<1>  q_trapez; 
    QIterated<dim> quadrature(q_trapez, degree + 2); 

// 有了这个，我们就可以让库计算出误差并将其输出到屏幕上。

    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      exact_solution, 
                                      cellwise_errors, 
                                      quadrature, 
                                      VectorTools::L2_norm, 
                                      &pressure_mask); 
    const double p_l2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        cellwise_errors, 
                                        VectorTools::L2_norm); 

    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      exact_solution, 
                                      cellwise_errors, 
                                      quadrature, 
                                      VectorTools::L2_norm, 
                                      &velocity_mask); 
    const double u_l2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        cellwise_errors, 
                                        VectorTools::L2_norm); 

    std::cout << "Errors: ||e_p||_L2 = " << p_l2_error 
              << ",   ||e_u||_L2 = " << u_l2_error << std::endl; 
  } 
// @sect4{MixedLaplace::output_results}  

// 最后一个有趣的函数是我们生成图形输出的函数。请注意，所有的速度分量都得到相同的解名 "u"。再加上使用 DataComponentInterpretation::component_is_part_of_vector ，这将导致 DataOut<dim>::write_vtu() 生成各个速度分量的矢量表示，更多信息请参见 step-22 或 @ref VVOutput 模块中的 "生成图形输出 "部分。最后，对于高阶元素来说，在图形输出中每个单元只显示一个双线性四边形似乎不合适。因此，我们生成大小为(度数+1)x(度数+1)的斑块来捕捉解决方案的全部信息内容。有关这方面的更多信息，请参见 step-7 的教程程序。

  template <int dim> 
  void MixedLaplaceProblem<dim>::output_results() const 
  { 
    std::vector<std::string> solution_names(dim, "u"); 
    solution_names.emplace_back("p"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      interpretation(dim, 
                     DataComponentInterpretation::component_is_part_of_vector); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 
    data_out.add_data_vector(dof_handler, 
                             solution, 
                             solution_names, 
                             interpretation); 

    data_out.build_patches(degree + 1); 

    std::ofstream output("solution.vtu"); 
    data_out.write_vtu(output); 
  } 

//  @sect4{MixedLaplace::run}  

// 这是我们主类的最后一个函数。它唯一的工作是按照自然顺序调用其他函数。

  template <int dim> 
  void MixedLaplaceProblem<dim>::run() 
  { 
    make_grid_and_dofs(); 
    assemble_system(); 
    solve(); 
    compute_errors(); 
    output_results(); 
  } 
} // namespace Step20 
// @sect3{The <code>main</code> function}  

// 我们从  step-6  而不是  step-4  那里偷来的主函数。它几乎等同于 step-6 中的函数（当然，除了改变的类名），唯一的例外是我们将有限元空间的度数传递给混合拉普拉斯问题的构造函数（这里，我们使用零阶元素）。

int main() 
{ 
  try 
    { 
      using namespace Step20; 

      const unsigned int     fe_degree = 0; 
      MixedLaplaceProblem<2> mixed_laplace_problem(fe_degree); 
      mixed_laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 



CCTest_file/step-21.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2006 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Yan Li, Wolfgang Bangerth, Texas A&M University, 2006 
 */ 



// 这个程序是对  step-20  的改编，包括一些来自  step-12  的DG方法的技术。因此，该程序的很大一部分与  step-20  非常相似，我们将不再对这些部分进行评论。只有新的东西才会被详细讨论。

//  @sect3{Include files}  

// 这些include文件以前都用过了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 

#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_raviart_thomas.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <iostream> 
#include <fstream> 

// 在这个程序中，我们使用一个张量值的系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了提供这种功能的 <code>TensorFunction</code> 类。

#include <deal.II/base/tensor_function.h> 

// 此外，我们使用 <code>DiscreteTime</code> 类来执行与时间递增有关的操作。

#include <deal.II/base/discrete_time.h> 

// 最后一步和以前所有的程序一样。

namespace Step21 
{ 
  using namespace dealii; 
// @sect3{The <code>TwoPhaseFlowProblem</code> class}  

// 这是该程序的主类。它与 step-20 中的类很接近，但增加了一些功能。

//  <ul>  
// <li>  
// <code>assemble_rhs_S</code> 集合了饱和度方程的右侧。正如介绍中所解释的，这不能被集成到 <code>assemble_rhs</code> 中，因为它取决于在时间步长的第一部分计算的速度。

//  <li>  
// <code>get_maximal_velocity</code> 的作用正如其名称所示。这个函数用于计算时间步长。

//  <li>  
// <code>project_back_saturation</code>  将所有饱和度小于0的自由度重置为0，所有饱和度大于1的自由度重置为1。   </ul>  

// 该类的其余部分应该是非常明显的。变量 <code>viscosity</code> 存储粘度 $\mu$ ，它进入了非线性方程中的几个公式。变量 <code>time</code> 记录了模拟过程中的时间信息。

  template <int dim> 
  class TwoPhaseFlowProblem 
  { 
  public: 
    TwoPhaseFlowProblem(const unsigned int degree); 
    void run(); 

  private: 
    void   make_grid_and_dofs(); 
    void   assemble_system(); 
    void   assemble_rhs_S(); 
    double get_maximal_velocity() const; 
    void   solve(); 
    void   project_back_saturation(); 
    void   output_results() const; 

    const unsigned int degree; 

    Triangulation<dim> triangulation; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 

    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> system_matrix; 

    const unsigned int n_refinement_steps; 

    DiscreteTime time; 
    double       viscosity; 

    BlockVector<double> solution; 
    BlockVector<double> old_solution; 
    BlockVector<double> system_rhs; 
  }; 
// @sect3{Equation data}  
// @sect4{Pressure right hand side}  

// 目前，压力方程的右侧仅仅是零函数。但是，如果需要的话，程序的其余部分完全可以处理其他的东西。

  template <int dim> 
  class PressureRightHandSide : public Function<dim> 
  { 
  public: 
    PressureRightHandSide() 
      : Function<dim>(1) 
    {} 

    virtual double value(const Point<dim> & /*p*/, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      return 0; 
    } 
  }; 

//  @sect4{Pressure boundary values}  

// 接下来是压力边界值。正如介绍中提到的，我们选择一个线性压力场。

  template <int dim> 
  class PressureBoundaryValues : public Function<dim> 
  { 
  public: 
    PressureBoundaryValues() 
      : Function<dim>(1) 
    {} 

    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      return 1 - p[0]; 
    } 
  }; 

//  @sect4{Saturation boundary values}  

// 然后，我们还需要边界的流入部分的边界值。某物是否为流入部分的问题是在组装右手边时决定的，我们只需要提供边界值的功能描述。这正如介绍中所解释的。

  template <int dim> 
  class SaturationBoundaryValues : public Function<dim> 
  { 
  public: 
    SaturationBoundaryValues() 
      : Function<dim>(1) 
    {} 

    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      if (p[0] == 0) 
        return 1; 
      else 
        return 0; 
    } 
  }; 

//  @sect4{Initial data}  

// 最后，我们需要初始数据。实际上，我们只需要饱和度的初始数据，但我们很懒，所以以后在第一个时间步骤之前，我们会简单地从一个包含所有矢量分量的函数中插值出前一个时间步骤的整个解决方案。
//因此，
//我们简单地创建一个所有分量都返回0的函数。我们通过简单地将每个函数转发到 Functions::ZeroFunction 类来做到这一点。为什么不在这个程序中我们目前使用 <code>InitialValues</code> 类的地方立即使用呢？因为这样，以后再回去选择不同的函数来做初始值就更简单了。

  template <int dim> 
  class InitialValues : public Function<dim> 
  { 
  public: 
    InitialValues() 
      : Function<dim>(dim + 2) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override 
    { 
      return Functions::ZeroFunction<dim>(dim + 2).value(p, component); 
    } 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  values) const override 
    { 
      Functions::ZeroFunction<dim>(dim + 2).vector_value(p, values); 
    } 
  }; 

//  @sect3{The inverse permeability tensor}  

// 正如介绍中所宣布的，我们实现了两个不同的渗透率张量场。我们把它们各自放入一个命名空间，这样以后就可以很容易地在代码中用另一个来代替一个。

//  @sect4{Single curving crack permeability}  

// 渗透率的第一个函数是模拟单个弯曲裂缝的函数。它在 step-20 的结尾已经使用过了，它的函数形式在本教程程序的介绍中给出。和以前的一些程序一样，我们必须声明KInverse类的一个（似乎是不必要的）默认构造函数，以避免某些编译器的警告。

  namespace SingleCurvingCrack 
  { 
    template <int dim> 
    class KInverse : public TensorFunction<2, dim> 
    { 
    public: 
      KInverse() 
        : TensorFunction<2, dim>() 
      {} 

      virtual void 
      value_list(const std::vector<Point<dim>> &points, 
                 std::vector<Tensor<2, dim>> &  values) const override 
      { 
        Assert(points.size() == values.size(), 
               ExcDimensionMismatch(points.size(), values.size())); 

        for (unsigned int p = 0; p < points.size(); ++p) 
          { 
            values[p].clear(); 

            const double distance_to_flowline = 
              std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0])); 

            const double permeability = 
              std::max(std::exp(-(distance_to_flowline * distance_to_flowline) / 
                                (0.1 * 0.1)), 
                       0.01); 

            for (unsigned int d = 0; d < dim; ++d) 
              values[p][d][d] = 1. / permeability; 
          } 
      } 
    }; 
  } // namespace SingleCurvingCrack 
// @sect4{Random medium permeability}  

// 这个函数的作用与介绍中公布的一样，即在随机的地方创建一个叠加的指数。对于这个类，有一件事值得考虑。这个问题的核心是，这个类使用随机函数创建指数的中心。如果我们因此在每次创建本类型的对象时都创建中心，我们每次都会得到一个不同的中心列表。这不是我们对这种类型的类的期望：它们应该可靠地表示同一个函数。

// 解决这个问题的方法是使中心列表成为这个类的静态成员变量，也就是说，在整个程序中只存在一个这样的变量，而不是为这个类型的每个对象。这正是我们所要做的。

// 然而，接下来的问题是，我们需要一种方法来初始化这个变量。由于这个变量是在程序开始时初始化的，我们不能使用普通的成员函数来实现，因为当时身边可能没有这个类型的对象。因此C++标准规定，只有非成员函数和静态成员函数可以用来初始化静态变量。我们通过定义一个函数 <code>get_centers</code> 来使用后一种可能性，该函数在调用时计算中心点的列表。

// 注意，这个类在2D和3D中都能正常工作，唯一的区别是我们在3D中使用了更多的点：通过实验我们发现，我们在3D中比2D中需要更多的指数（毕竟我们有更多的地方需要覆盖，如果我们想保持中心之间的距离大致相等），所以我们在2D中选择40，在3D中选择100。对于任何其他维度，该函数目前不知道该怎么做，所以只是抛出一个异常，表明这一点。

  namespace RandomMedium 
  { 
    template <int dim> 
    class KInverse : public TensorFunction<2, dim> 
    { 
    public: 
      KInverse() 
        : TensorFunction<2, dim>() 
      {} 

      virtual void 
      value_list(const std::vector<Point<dim>> &points, 
                 std::vector<Tensor<2, dim>> &  values) const override 
      { 
        Assert(points.size() == values.size(), 
               ExcDimensionMismatch(points.size(), values.size())); 

        for (unsigned int p = 0; p < points.size(); ++p) 
          { 
            values[p].clear(); 

            double permeability = 0; 
            for (unsigned int i = 0; i < centers.size(); ++i) 
              permeability += std::exp(-(points[p] - centers[i]).norm_square() / 
                                       (0.05 * 0.05)); 

            const double normalized_permeability = 
              std::min(std::max(permeability, 0.01), 4.); 

            for (unsigned int d = 0; d < dim; ++d) 
              values[p][d][d] = 1. / normalized_permeability; 
          } 
      } 

    private: 
      static std::vector<Point<dim>> centers; 

      static std::vector<Point<dim>> get_centers() 
      { 
        const unsigned int N = 
          (dim == 2 ? 40 : (dim == 3 ? 100 : throw ExcNotImplemented())); 

        std::vector<Point<dim>> centers_list(N); 
        for (unsigned int i = 0; i < N; ++i) 
          for (unsigned int d = 0; d < dim; ++d) 
            centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX; 

        return centers_list; 
      } 
    }; 

    template <int dim> 
    std::vector<Point<dim>> 
      KInverse<dim>::centers = KInverse<dim>::get_centers(); 
  } // namespace RandomMedium 

//  @sect3{The inverse mobility and saturation functions}  

// 还有两个数据我们需要描述，即反流动性函数和饱和度曲线。它们的形式也在介绍中给出。

  double mobility_inverse(const double S, const double viscosity) 
  { 
    return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S)); 
  } 

  double fractional_flow(const double S, const double viscosity) 
  { 
    return S * S / (S * S + viscosity * (1 - S) * (1 - S)); 
  } 

//  @sect3{Linear solvers and preconditioners}  

// 我们使用的线性求解器也完全类似于  step-20  中使用的。因此，下面的类是逐字逐句从那里复制过来的。请注意，这里的类不仅是从 step-20 中复制的，而且在deal.II中也有重复的类。在这个例子的未来版本中，它们应该被一个有效的方法所取代，不过。有一个变化：如果线性系统的尺寸很小，即当网格很粗时，那么在 <code>src.size()</code> 函数中的求解器收敛之前，设置 <code>vmult()</code> CG迭代的最大值有时是不够的。(当然，这是数值取舍的结果，因为我们知道在纸面上，CG方法最多在 <code>src.size()</code> 步内收敛)。因此，我们将最大的迭代次数设定为等于线性系统的最大规模和200。

  template <class MatrixType> 
  class InverseMatrix : public Subscriptor 
  { 
  public: 
    InverseMatrix(const MatrixType &m) 
      : matrix(&m) 
    {} 

    void vmult(Vector<double> &dst, const Vector<double> &src) const 
    { 
      SolverControl solver_control(std::max<unsigned int>(src.size(), 200), 
                                   1e-8 * src.l2_norm()); 
      SolverCG<Vector<double>> cg(solver_control); 

      dst = 0; 

      cg.solve(*matrix, dst, src, PreconditionIdentity()); 
    } 

  private: 
    const SmartPointer<const MatrixType> matrix; 
  }; 

  class SchurComplement : public Subscriptor 
  { 
  public: 
    SchurComplement(const BlockSparseMatrix<double> &          A, 
                    const InverseMatrix<SparseMatrix<double>> &Minv) 
      : system_matrix(&A) 
      , m_inverse(&Minv) 
      , tmp1(A.block(0, 0).m()) 
      , tmp2(A.block(0, 0).m()) 
    {} 

    void vmult(Vector<double> &dst, const Vector<double> &src) const 
    { 
      system_matrix->block(0, 1).vmult(tmp1, src); 
      m_inverse->vmult(tmp2, tmp1); 
      system_matrix->block(1, 0).vmult(dst, tmp2); 
    } 

  private: 
    const SmartPointer<const BlockSparseMatrix<double>>           system_matrix; 
    const SmartPointer<const InverseMatrix<SparseMatrix<double>>> m_inverse; 

    mutable Vector<double> tmp1, tmp2; 
  }; 

  class ApproximateSchurComplement : public Subscriptor 
  { 
  public: 
    ApproximateSchurComplement(const BlockSparseMatrix<double> &A) 
      : system_matrix(&A) 
      , tmp1(A.block(0, 0).m()) 
      , tmp2(A.block(0, 0).m()) 
    {} 

    void vmult(Vector<double> &dst, const Vector<double> &src) const 
    { 
      system_matrix->block(0, 1).vmult(tmp1, src); 
      system_matrix->block(0, 0).precondition_Jacobi(tmp2, tmp1); 
      system_matrix->block(1, 0).vmult(dst, tmp2); 
    } 

  private: 
    const SmartPointer<const BlockSparseMatrix<double>> system_matrix; 

    mutable Vector<double> tmp1, tmp2; 
  }; 

//  @sect3{<code>TwoPhaseFlowProblem</code> class implementation}  

// 现在是主类的实现。它的大部分内容实际上是从  step-20  中复制过来的，所以我们不会对它进行详细的评论。你应该试着先熟悉一下那个程序，然后这里发生的大部分事情就应该很清楚了。

//  @sect4{TwoPhaseFlowProblem::TwoPhaseFlowProblem}  

// 首先是构造函数。我们使用 $RT_k \times DQ_k \times DQ_k$ 空间。对于初始化DiscreteTime对象，我们不在构造函数中设置时间步长，因为我们还没有它的值。时间步长最初被设置为零，但在需要增量时间之前，它将被计算出来，正如介绍的一个小节中所描述的。时间对象在内部阻止自己在 $dt = 0$ 时被递增，迫使我们在推进时间之前为 $dt$ 设置一个非零的期望大小。

  template <int dim> 
  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree) 
    : degree(degree) 
    , fe(FE_RaviartThomas<dim>(degree), 
         1, 
         FE_DGQ<dim>(degree), 
         1, 
         FE_DGQ<dim>(degree), 
         1) 
    , dof_handler(triangulation) 
    , n_refinement_steps(5) 
    , time(/*start time*/ 0., /*end time*/ 1.) 
    , viscosity(0.2) 
  {} 

//  @sect4{TwoPhaseFlowProblem::make_grid_and_dofs}  

// 下一个函数从众所周知的函数调用开始，创建和细化一个网格，然后将自由度与之关联。它所做的事情与 step-20 中的相同，只是现在是三个组件而不是两个。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::make_grid_and_dofs() 
  { 
    GridGenerator::hyper_cube(triangulation, 0, 1); 
    triangulation.refine_global(n_refinement_steps); 

    dof_handler.distribute_dofs(fe); 
    DoFRenumbering::component_wise(dof_handler); 

    const std::vector<types::global_dof_index> dofs_per_component = 
      DoFTools::count_dofs_per_fe_component(dof_handler); 
    const unsigned int n_u = dofs_per_component[0], 
                       n_p = dofs_per_component[dim], 
                       n_s = dofs_per_component[dim + 1]; 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (" << n_u << '+' << n_p << '+' << n_s << ')' << std::endl 
              << std::endl; 

    const unsigned int n_couplings = dof_handler.max_couplings_between_dofs(); 

    sparsity_pattern.reinit(3, 3); 
    sparsity_pattern.block(0, 0).reinit(n_u, n_u, n_couplings); 
    sparsity_pattern.block(1, 0).reinit(n_p, n_u, n_couplings); 
    sparsity_pattern.block(2, 0).reinit(n_s, n_u, n_couplings); 
    sparsity_pattern.block(0, 1).reinit(n_u, n_p, n_couplings); 
    sparsity_pattern.block(1, 1).reinit(n_p, n_p, n_couplings); 
    sparsity_pattern.block(2, 1).reinit(n_s, n_p, n_couplings); 
    sparsity_pattern.block(0, 2).reinit(n_u, n_s, n_couplings); 
    sparsity_pattern.block(1, 2).reinit(n_p, n_s, n_couplings); 
    sparsity_pattern.block(2, 2).reinit(n_s, n_s, n_couplings); 

    sparsity_pattern.collect_sizes(); 

    DoFTools::make_sparsity_pattern(dof_handler, sparsity_pattern); 
    sparsity_pattern.compress(); 

    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(3); 
    solution.block(0).reinit(n_u); 
    solution.block(1).reinit(n_p); 
    solution.block(2).reinit(n_s); 
    solution.collect_sizes(); 

    old_solution.reinit(3); 
    old_solution.block(0).reinit(n_u); 
    old_solution.block(1).reinit(n_p); 
    old_solution.block(2).reinit(n_s); 
    old_solution.collect_sizes(); 

    system_rhs.reinit(3); 
    system_rhs.block(0).reinit(n_u); 
    system_rhs.block(1).reinit(n_p); 
    system_rhs.block(2).reinit(n_s); 
    system_rhs.collect_sizes(); 
  } 
// @sect4{TwoPhaseFlowProblem::assemble_system}  

// 这是组装线性系统的函数，或者至少是除了(1,3)块之外的所有东西，它取决于在这个时间步长中计算的仍然未知的速度（我们在 <code>assemble_rhs_S</code> 中处理这个问题）。它的大部分内容与 step-20 一样，但这次我们必须处理一些非线性的问题。 然而，该函数的顶部与往常一样（注意我们在开始时将矩阵和右手边设置为零&mdash; 对于静止问题我们不必这样做，因为在那里我们只使用一次矩阵对象，而且在开始时它是空的）。

// 注意，在目前的形式下，该函数使用 RandomMedium::KInverse 类中实现的渗透率。切换到单曲裂缝渗透率函数就像改变命名空间名称一样简单。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_system() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    QGauss<dim>     quadrature_formula(degree + 2); 
    QGauss<dim - 1> face_quadrature_formula(degree + 2); 

    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    FEFaceValues<dim> fe_face_values(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_normal_vectors | 
                                       update_quadrature_points | 
                                       update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const PressureRightHandSide<dim>  pressure_right_hand_side; 
    const PressureBoundaryValues<dim> pressure_boundary_values; 
    const RandomMedium::KInverse<dim> k_inverse; 

    std::vector<double>         pressure_rhs_values(n_q_points); 
    std::vector<double>         boundary_values(n_face_q_points); 
    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points); 

    std::vector<Vector<double>>              old_solution_values(n_q_points, 
                                                                 Vector<double>(dim + 2)); 
    std::vector<std::vector<Tensor<1, dim>>> old_solution_grads( 
      n_q_points, std::vector<Tensor<1, dim>>(dim + 2)); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 
    const FEValuesExtractors::Scalar saturation(dim + 1); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        local_matrix = 0; 
        local_rhs    = 0; 

// 这里是第一个重要的区别。我们必须在正交点上获得前一个时间步骤的饱和函数值。为此，我们可以使用 FEValues::get_function_values （之前已经在 step-9 、 step-14 和 step-15 中使用），这个函数接收一个解向量并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。

        fe_values.get_function_values(old_solution, old_solution_values); 

// 然后，我们还必须得到压力的右手边和反渗透性张量在正交点的数值。

        pressure_right_hand_side.value_list(fe_values.get_quadrature_points(), 
                                            pressure_rhs_values); 
        k_inverse.value_list(fe_values.get_quadrature_points(), 
                             k_inverse_values); 

// 有了这些，我们现在可以在这个单元格上的所有正交点和形状函数上进行循环，并将我们在这个函数中处理的矩阵和右手边的那些部分组合起来。考虑到引言中所述的双线性形式的明确形式，贡献中的各个条款应该是不言自明的。

        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const double old_s = old_solution_values[q](dim + 1); 

              const Tensor<1, dim> phi_i_u = fe_values[velocities].value(i, q); 
              const double div_phi_i_u = fe_values[velocities].divergence(i, q); 
              const double phi_i_p     = fe_values[pressure].value(i, q); 
              const double phi_i_s     = fe_values[saturation].value(i, q); 

              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const Tensor<1, dim> phi_j_u = 
                    fe_values[velocities].value(j, q); 
                  const double div_phi_j_u = 
                    fe_values[velocities].divergence(j, q); 
                  const double phi_j_p = fe_values[pressure].value(j, q); 
                  const double phi_j_s = fe_values[saturation].value(j, q); 

                  local_matrix(i, j) += 
                    (phi_i_u * k_inverse_values[q] * 
                       mobility_inverse(old_s, viscosity) * phi_j_u - 
                     div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u + 
                     phi_i_s * phi_j_s) * 
                    fe_values.JxW(q); 
                } 

              local_rhs(i) += 
                (-phi_i_p * pressure_rhs_values[q]) * fe_values.JxW(q); 
            } 

// 接下来，我们还必须处理压力边界值。这一点，还是和 step-20 中一样。

        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary()) 
            { 
              fe_face_values.reinit(cell, face); 

              pressure_boundary_values.value_list( 
                fe_face_values.get_quadrature_points(), boundary_values); 

              for (unsigned int q = 0; q < n_face_q_points; ++q) 
                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  { 
                    const Tensor<1, dim> phi_i_u = 
                      fe_face_values[velocities].value(i, q); 

                    local_rhs(i) += 
                      -(phi_i_u * fe_face_values.normal_vector(q) * 
                        boundary_values[q] * fe_face_values.JxW(q)); 
                  } 
            } 

// 在所有单元的循环中，最后一步是将局部贡献转移到全局矩阵和右侧向量中。

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              local_matrix(i, j)); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          system_rhs(local_dof_indices[i]) += local_rhs(i); 
      } 
  } 

// 矩阵和右手边的组装就这么多了。请注意，我们不需要插值和应用边界值，因为它们都已经在弱式中被处理过了。

//  @sect4{TwoPhaseFlowProblem::assemble_rhs_S}  

// 正如在介绍中所解释的，我们只有在计算出速度后才能评估饱和方程的右边。因此，我们有这个单独的函数来实现这个目的。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_rhs_S() 
  { 
    QGauss<dim>       quadrature_formula(degree + 2); 
    QGauss<dim - 1>   face_quadrature_formula(degree + 2); 
    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    FEFaceValues<dim> fe_face_values(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_normal_vectors | 
                                       update_quadrature_points | 
                                       update_JxW_values); 
    FEFaceValues<dim> fe_face_values_neighbor(fe, 
                                              face_quadrature_formula, 
                                              update_values); 

    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    Vector<double> local_rhs(dofs_per_cell); 

    std::vector<Vector<double>> old_solution_values(n_q_points, 
                                                    Vector<double>(dim + 2)); 
    std::vector<Vector<double>> old_solution_values_face(n_face_q_points, 
                                                         Vector<double>(dim + 
                                                                        2)); 
    std::vector<Vector<double>> old_solution_values_face_neighbor( 
      n_face_q_points, Vector<double>(dim + 2)); 
    std::vector<Vector<double>> present_solution_values(n_q_points, 
                                                        Vector<double>(dim + 
                                                                       2)); 
    std::vector<Vector<double>> present_solution_values_face( 
      n_face_q_points, Vector<double>(dim + 2)); 

    std::vector<double>                  neighbor_saturation(n_face_q_points); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    SaturationBoundaryValues<dim> saturation_boundary_values; 

    const FEValuesExtractors::Scalar saturation(dim + 1); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        local_rhs = 0; 
        fe_values.reinit(cell); 

        fe_values.get_function_values(old_solution, old_solution_values); 
        fe_values.get_function_values(solution, present_solution_values); 

// 首先是单元格条款。按照介绍中的公式，这些是  $(S^n,\sigma)-(F(S^n) \mathbf{v}^{n+1},\nabla \sigma)$  ，其中  $\sigma$  是测试函数的饱和成分。

        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const double   old_s = old_solution_values[q](dim + 1); 
              Tensor<1, dim> present_u; 
              for (unsigned int d = 0; d < dim; ++d) 
                present_u[d] = present_solution_values[q](d); 

              const double         phi_i_s = fe_values[saturation].value(i, q); 
              const Tensor<1, dim> grad_phi_i_s = 
                fe_values[saturation].gradient(i, q); 

              local_rhs(i) += 
                (time.get_next_step_size() * fractional_flow(old_s, viscosity) * 
                   present_u * grad_phi_i_s + 
                 old_s * phi_i_s) * 
                fe_values.JxW(q); 
            } 

// 其次，我们必须处理面的边界上的通量部分。这就有点麻烦了，因为我们首先要确定哪些是细胞边界的流入和流出部分。如果我们有一个流入的边界，我们需要评估面的另一边的饱和度（或者边界值，如果我们在域的边界上）。

// 所有这些都有点棘手，但在  step-9  中已经有了一些详细的解释。请看这里，这应该是如何工作的!

        for (const auto face_no : cell->face_indices()) 
          { 
            fe_face_values.reinit(cell, face_no); 

            fe_face_values.get_function_values(old_solution, 
                                               old_solution_values_face); 
            fe_face_values.get_function_values(solution, 
                                               present_solution_values_face); 

            if (cell->at_boundary(face_no)) 
              saturation_boundary_values.value_list( 
                fe_face_values.get_quadrature_points(), neighbor_saturation); 
            else 
              { 
                const auto         neighbor = cell->neighbor(face_no); 
                const unsigned int neighbor_face = 
                  cell->neighbor_of_neighbor(face_no); 

                fe_face_values_neighbor.reinit(neighbor, neighbor_face); 

                fe_face_values_neighbor.get_function_values( 
                  old_solution, old_solution_values_face_neighbor); 

                for (unsigned int q = 0; q < n_face_q_points; ++q) 
                  neighbor_saturation[q] = 
                    old_solution_values_face_neighbor[q](dim + 1); 
              } 

            for (unsigned int q = 0; q < n_face_q_points; ++q) 
              { 
                Tensor<1, dim> present_u_face; 
                for (unsigned int d = 0; d < dim; ++d) 
                  present_u_face[d] = present_solution_values_face[q](d); 

                const double normal_flux = 
                  present_u_face * fe_face_values.normal_vector(q); 

                const bool is_outflow_q_point = (normal_flux >= 0); 

                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  local_rhs(i) -= 
                    time.get_next_step_size() * normal_flux * 
                    fractional_flow((is_outflow_q_point == true ? 
                                       old_solution_values_face[q](dim + 1) : 
                                       neighbor_saturation[q]), 
                                    viscosity) * 
                    fe_face_values[saturation].value(i, q) * 
                    fe_face_values.JxW(q); 
              } 
          } 

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          system_rhs(local_dof_indices[i]) += local_rhs(i); 
      } 
  } 

//  @sect4{TwoPhaseFlowProblem::solve}  

// 在所有这些准备工作之后，我们最终以与  step-20  相同的方式解决速度和压力的线性系统。在这之后，我们必须处理饱和方程（见下文）。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::solve() 
  { 
    const InverseMatrix<SparseMatrix<double>> m_inverse( 
      system_matrix.block(0, 0)); 
    Vector<double> tmp(solution.block(0).size()); 
    Vector<double> schur_rhs(solution.block(1).size()); 
    Vector<double> tmp2(solution.block(2).size()); 

// 首先是压力，使用前两个方程的压力舒尔补。

    { 
      m_inverse.vmult(tmp, system_rhs.block(0)); 
      system_matrix.block(1, 0).vmult(schur_rhs, tmp); 
      schur_rhs -= system_rhs.block(1); 

      SchurComplement schur_complement(system_matrix, m_inverse); 

      ApproximateSchurComplement approximate_schur_complement(system_matrix); 

      InverseMatrix<ApproximateSchurComplement> preconditioner( 
        approximate_schur_complement); 

      SolverControl            solver_control(solution.block(1).size(), 
                                   1e-12 * schur_rhs.l2_norm()); 
      SolverCG<Vector<double>> cg(solver_control); 

      cg.solve(schur_complement, solution.block(1), schur_rhs, preconditioner); 

      std::cout << "   " << solver_control.last_step() 
                << " CG Schur complement iterations for pressure." << std::endl; 
    } 

// 现在是速度。

    { 
      system_matrix.block(0, 1).vmult(tmp, solution.block(1)); 
      tmp *= -1; 
      tmp += system_rhs.block(0); 

      m_inverse.vmult(solution.block(0), tmp); 
    } 

// 最后，我们必须处理好饱和度方程。在这里，我们要做的第一件事是使用介绍中的公式来确定时间步长。知道了我们领域的形状，以及我们通过有规律地划分单元来创建网格，我们可以很容易地计算出每个单元的直径（事实上我们使用的是单元坐标方向上的线性扩展，而不是直径）。请注意，我们将在 step-24 中学习一种更通用的方法，在那里我们使用 GridTools::minimal_cell_diameter 函数。

// 我们使用一个辅助函数来计算下面定义的最大速度，有了这些，我们就可以评估我们新的时间步长了。我们使用方法 DiscreteTime::set_desired_next_time_step() 来向DiscreteTime对象建议新的时间步长的计算值。在大多数情况下，时间对象使用精确提供的值来增加时间。在某些情况下，时间对象可以进一步修改步骤大小。例如，如果计算出的时间增量超过了结束时间，它将被相应地截断。

    time.set_desired_next_step_size(std::pow(0.5, double(n_refinement_steps)) / 
                                    get_maximal_velocity()); 

// 下一步是组装右手边，然后把所有的东西都传给解。最后，我们把饱和度投射回物理上合理的范围。

    assemble_rhs_S(); 
    { 
      SolverControl            solver_control(system_matrix.block(2, 2).m(), 
                                   1e-8 * system_rhs.block(2).l2_norm()); 
      SolverCG<Vector<double>> cg(solver_control); 
      cg.solve(system_matrix.block(2, 2), 
               solution.block(2), 
               system_rhs.block(2), 
               PreconditionIdentity()); 

      project_back_saturation(); 

      std::cout << "   " << solver_control.last_step() 
                << " CG iterations for saturation." << std::endl; 
    } 

    old_solution = solution; 
  } 
// @sect4{TwoPhaseFlowProblem::output_results}  

// 这里没有什么值得惊讶的。由于程序会做大量的时间步骤，我们只在每第五个时间步骤创建一个输出文件，并在文件的顶部已经跳过所有其他时间步骤。

// 在为接近函数底部的输出创建文件名时，我们将时间步长的数字转换为字符串表示，用前导零填充到四位数。我们这样做是因为这样所有的输出文件名都有相同的长度，因此在创建目录列表时可以很好地排序。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::output_results() const 
  { 
    if (time.get_step_number() % 5 != 0) 
      return; 

    std::vector<std::string> solution_names; 
    switch (dim) 
      { 
        case 2: 
          solution_names = {"u", "v", "p", "S"}; 
          break; 

        case 3: 
          solution_names = {"u", "v", "w", "p", "S"}; 
          break; 

        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, solution_names); 

    data_out.build_patches(degree + 1); 

    std::ofstream output("solution-" + 
                         Utilities::int_to_string(time.get_step_number(), 4) + 
                         ".vtk"); 
    data_out.write_vtk(output); 
  } 

//  @sect4{TwoPhaseFlowProblem::project_back_saturation}  

// 在这个函数中，我们简单地遍历所有的饱和自由度，并确保如果它们离开了物理上的合理范围，它们将被重置到区间  $[0,1]$  。要做到这一点，我们只需要循环解决向量的所有饱和分量；这些分量存储在块2中（块0是速度，块1是压力）。

// 值得注意的是，当时间步长选择如介绍中提到的那样时，这个函数几乎从未触发过，这一点可能很有启发。然而，如果我们只选择稍大的时间步长，我们会得到大量超出适当范围的数值。严格来说，如果我们选择的时间步长足够小，这个函数因此是不必要的。从某种意义上说，这个函数只是一个安全装置，以避免由于个别自由度在几个时间步长之前变得不符合物理条件而导致我们的整个解决方案变得不符合物理条件的情况。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::project_back_saturation() 
  { 
    for (unsigned int i = 0; i < solution.block(2).size(); ++i) 
      if (solution.block(2)(i) < 0) 
        solution.block(2)(i) = 0; 
      else if (solution.block(2)(i) > 1) 
        solution.block(2)(i) = 1; 
  } 
// @sect4{TwoPhaseFlowProblem::get_maximal_velocity}  

// 下面的函数用于确定允许的最大时间步长。它的作用是在域中的所有正交点上循环，找出速度的最大幅度。

  template <int dim> 
  double TwoPhaseFlowProblem<dim>::get_maximal_velocity() const 
  { 
    QGauss<dim>        quadrature_formula(degree + 2); 
    const unsigned int n_q_points = quadrature_formula.size(); 

    FEValues<dim> fe_values(fe, quadrature_formula, update_values); 
    std::vector<Vector<double>> solution_values(n_q_points, 
                                                Vector<double>(dim + 2)); 
    double                      max_velocity = 0; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        fe_values.get_function_values(solution, solution_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            Tensor<1, dim> velocity; 
            for (unsigned int i = 0; i < dim; ++i) 
              velocity[i] = solution_values[q](i); 

            max_velocity = std::max(max_velocity, velocity.norm()); 
          } 
      } 

    return max_velocity; 
  } 
// @sect4{TwoPhaseFlowProblem::run}  

// 这是我们主类的最后一个函数。它的简洁不言自明。只有两点是值得注意的。首先，该函数在开始时将初始值投射到有限元空间上； VectorTools::project 函数这样做需要一个表明悬挂节点约束的参数。我们在这个程序中没有（我们在一个均匀细化的网格上计算），但是这个函数当然需要这个参数。所以我们必须创建一个约束对象。在原始状态下，约束对象是没有排序的，在使用前必须进行排序（使用 AffineConstraints::close 函数）。这就是我们在这里所做的，这也是为什么我们不能简单地用一个匿名的临时对象 <code>AffineConstraints<double>()</code> 作为第二个参数来调用 VectorTools::project 函数。

// 值得一提的第二点是，我们只在求解每个时间步长对应的线性系统的过程中计算当前时间步长。因此，我们只有在时间步长结束时才能输出一个时间步长的当前时间。我们通过调用循环内的方法 DiscreteTime::advance_time() 来增加时间。由于我们在增量后报告时间和dt，我们必须调用方法 DiscreteTime::get_previous_step_size() ，而不是 DiscreteTime::get_next_step_size(). 。 经过许多步，当模拟到达结束时间时，最后的dt由DiscreteTime类选择，其方式是最后一步正好在结束时间完成。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::run() 
  { 
    make_grid_and_dofs(); 

    { 
      AffineConstraints<double> constraints; 
      constraints.close(); 

      VectorTools::project(dof_handler, 
                           constraints, 
                           QGauss<dim>(degree + 2), 
                           InitialValues<dim>(), 
                           old_solution); 
    } 

    do 
      { 
        std::cout << "Timestep " << time.get_step_number() + 1 << std::endl; 

        assemble_system(); 

        solve(); 

        output_results(); 

        time.advance_time(); 
        std::cout << "   Now at t=" << time.get_current_time() 
                  << ", dt=" << time.get_previous_step_size() << '.' 
                  << std::endl 
                  << std::endl; 
      } 
    while (time.is_at_end() == false); 
  } 
} // namespace Step21 
// @sect3{The <code>main</code> function}  

// 这就是了。在主函数中，我们将有限元空间的度数传递给TwoPhaseFlowProblem对象的构造函数。 这里，我们使用零度元素，即 $RT_0\times DQ_0 \times DQ_0$  。其余部分与其他所有程序一样。

int main() 
{ 
  try 
    { 
      using namespace Step21; 

      TwoPhaseFlowProblem<2> two_phase_flow_problem(0); 
      two_phase_flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-22.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2008 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Texas A&M University, 2008 
 */ 


// @sect3{Include files}  

// 像往常一样，我们从包括一些著名的文件开始。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 然后我们需要包括稀疏直接求解器UMFPACK的头文件。

#include <deal.II/lac/sparse_direct.h> 

// 这包括不完全LU因子化的库，它将被用作3D的预处理程序。

#include <deal.II/lac/sparse_ilu.h> 

// 这是C++语言。

#include <iostream> 
#include <fstream> 
#include <memory> 

// 和所有的程序一样，名字空间dealii被包括在内。

namespace Step22 
{ 
  using namespace dealii; 
// @sect3{Defining the inner preconditioner type}  

// 正如介绍中所解释的，我们将分别对两个和三个空间维度使用不同的预处理程序。我们通过使用空间维度作为模板参数来区分它们。关于模板的细节，请参见 step-4 。我们不打算在这里创建任何预处理对象，我们所做的只是创建一个持有确定预处理类的本地别名的类，这样我们就可以以独立于维度的方式编写我们的程序。

  template <int dim> 
  struct InnerPreconditioner; 

// 在二维中，我们将使用一个稀疏的直接求解器作为预处理程序。

  template <> 
  struct InnerPreconditioner<2> 
  { 
    using type = SparseDirectUMFPACK; 
  }; 

// 还有三维的ILU预处理，由SparseILU调用。

  template <> 
  struct InnerPreconditioner<3> 
  { 
    using type = SparseILU<double>; 
  }; 
// @sect3{The <code>StokesProblem</code> class template}  

// 这是对 step-20 的改编，所以主类和数据类型与那里使用的几乎相同。唯一不同的是，我们有一个额外的成员  <code>preconditioner_matrix</code>  ，用于预处理Schur补码，以及一个相应的稀疏模式  <code>preconditioner_sparsity_pattern</code>  。此外，我们没有依赖LinearOperator，而是实现了我们自己的InverseMatrix类。

// 在这个例子中，我们还使用了自适应网格细化，其处理方式与  step-6  类似。根据介绍中的讨论，我们也将使用AffineConstraints对象来实现Dirichlet边界条件。因此，我们改变名称  <code>hanging_node_constraints</code> into <code>constraints</code>  。

  template <int dim> 
  class StokesProblem 
  { 
  public: 
    StokesProblem(const unsigned int degree); 
    void run(); 

  private: 
    void setup_dofs(); 
    void assemble_system(); 
    void solve(); 
    void output_results(const unsigned int refinement_cycle) const; 
    void refine_mesh(); 

    const unsigned int degree; 

    Triangulation<dim> triangulation; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> constraints; 

    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> system_matrix; 

    BlockSparsityPattern      preconditioner_sparsity_pattern; 
    BlockSparseMatrix<double> preconditioner_matrix; 

    BlockVector<double> solution; 
    BlockVector<double> system_rhs; 

// 这一条是新的：我们将使用一个所谓的共享指针结构来访问预处理程序。共享指针本质上只是指针的一种方便形式。几个共享指针可以指向同一个对象（就像普通的指针一样），但是当最后一个指向前提器对象的共享指针对象被删除时（例如共享指针对象超出了范围，它所在的类被销毁，或者指针被分配给了不同的前提器对象），那么指向的前提器对象也被销毁。这确保了我们不必手动跟踪有多少地方仍在引用一个前置条件器对象，它永远不会产生内存泄漏，也不会产生一个指向已被销毁对象的悬空指针。

    std::shared_ptr<typename InnerPreconditioner<dim>::type> A_preconditioner; 
  }; 
// @sect3{Boundary values and right hand side}  

// 与 step-20 和其他大多数例子程序一样，下一个任务是定义PDE的数据：对于斯托克斯问题，我们将在部分边界上使用自然边界值（即同质诺伊曼型），对于这些边界，我们不必做任何特殊处理（同质性意味着弱形式中的相应项只是零），而在边界的其余部分使用速度的边界条件（迪里希勒型），如介绍中所述。

// 为了强制执行速度上的Dirichlet边界值，我们将像往常一样使用 VectorTools::interpolate_boundary_values 函数，这要求我们写一个具有与有限元一样多分量的函数对象。换句话说，我们必须在 $(u,p)$ -空间上定义函数，但在插值边界值时，我们要过滤掉压力分量。

// 下面的函数对象是介绍中描述的边界值的表示。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    BoundaryValues() 
      : Function<dim>(dim + 1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & p, 
                                    const unsigned int component) const 
  { 
    Assert(component < this->n_components, 
           ExcIndexRange(component, 0, this->n_components)); 

    if (component == 0) 
      return (p[0] < 0 ? -1 : (p[0] > 0 ? 1 : 0)); 
    return 0; 
  } 

  template <int dim> 
  void BoundaryValues<dim>::vector_value(const Point<dim> &p, 
                                         Vector<double> &  values) const 
  { 
    for (unsigned int c = 0; c < this->n_components; ++c) 
      values(c) = BoundaryValues<dim>::value(p, c); 
  } 

// 我们为右手边实现类似的函数，在目前的例子中，右手边只是零。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide() 
      : Function<dim>(dim + 1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & /*p*/, 
                                   const unsigned int /*component*/) const 
  { 
    return 0; 
  } 

  template <int dim> 
  void RightHandSide<dim>::vector_value(const Point<dim> &p, 
                                        Vector<double> &  values) const 
  { 
    for (unsigned int c = 0; c < this->n_components; ++c) 
      values(c) = RightHandSide<dim>::value(p, c); 
  } 
// @sect3{Linear solvers and preconditioners}  

// 在介绍中广泛讨论了线性求解器和预处理器。在这里，我们创建将被使用的各自对象。

//  @sect4{The <code>InverseMatrix</code> class template}   <code>InverseMatrix</code> 类表示逆矩阵的数据结构。与 step-20 不同，我们用一个类来实现，而不是用辅助函数inverse_linear_operator()，我们将把这个类应用于不同种类的矩阵，这些矩阵需要不同的预处理程序（在 step-20 中，我们只对质量矩阵使用非同一性预处理程序）。矩阵和预处理器的类型通过模板参数传递给这个类，当创建 <code>InverseMatrix</code> 对象时，这些类型的矩阵和预处理器对象将被传递给构造器。成员函数 <code>vmult</code> 是通过解决一个线性系统得到的。

  template <class MatrixType, class PreconditionerType> 
  class InverseMatrix : public Subscriptor 
  { 
  public: 
    InverseMatrix(const MatrixType &        m, 
                  const PreconditionerType &preconditioner); 

    void vmult(Vector<double> &dst, const Vector<double> &src) const; 

  private: 
    const SmartPointer<const MatrixType>         matrix; 
    const SmartPointer<const PreconditionerType> preconditioner; 
  }; 

  template <class MatrixType, class PreconditionerType> 
  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix( 
    const MatrixType &        m, 
    const PreconditionerType &preconditioner) 
    : matrix(&m) 
    , preconditioner(&preconditioner) 
  {} 

// 这就是 <code>vmult</code> 函数的实现。

// 在这个类中，我们对解算器控制使用了一个相当大的容忍度。这样做的原因是，该函数被频繁使用，因此，任何使CG求解中的残差变小的额外努力都会使求解更加昂贵。请注意，我们不仅将该类作为Schur补码的预处理程序，而且在形成拉普拉斯矩阵的逆时也使用该类；因此，该类直接对解本身的精度负责，所以我们也不能选择太大的公差。

  template <class MatrixType, class PreconditionerType> 
  void InverseMatrix<MatrixType, PreconditionerType>::vmult( 
    Vector<double> &      dst, 
    const Vector<double> &src) const 
  { 
    SolverControl            solver_control(src.size(), 1e-6 * src.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    dst = 0; 

    cg.solve(*matrix, dst, src, *preconditioner); 
  } 
// @sect4{The <code>SchurComplement</code> class template}  

// 这个类实现了介绍中讨论的Schur补码。它与  step-20  相类似。 不过，我们现在用一个模板参数 <code>PreconditionerType</code> 来调用它，以便在指定逆矩阵类的各自类型时访问它。作为上述定义的结果，声明  <code>InverseMatrix</code>  现在包含了上述预处理类的第二个模板参数，这也影响到  <code>SmartPointer</code> object <code>m_inverse</code>  。

  template <class PreconditionerType> 
  class SchurComplement : public Subscriptor 
  { 
  public: 
    SchurComplement( 
      const BlockSparseMatrix<double> &system_matrix, 
      const InverseMatrix<SparseMatrix<double>, PreconditionerType> &A_inverse); 

    void vmult(Vector<double> &dst, const Vector<double> &src) const; 

  private: 
    const SmartPointer<const BlockSparseMatrix<double>> system_matrix; 
    const SmartPointer< 
      const InverseMatrix<SparseMatrix<double>, PreconditionerType>> 
      A_inverse; 

    mutable Vector<double> tmp1, tmp2; 
  }; 

  template <class PreconditionerType> 
  SchurComplement<PreconditionerType>::SchurComplement( 
    const BlockSparseMatrix<double> &system_matrix, 
    const InverseMatrix<SparseMatrix<double>, PreconditionerType> &A_inverse) 
    : system_matrix(&system_matrix) 
    , A_inverse(&A_inverse) 
    , tmp1(system_matrix.block(0, 0).m()) 
    , tmp2(system_matrix.block(0, 0).m()) 
  {} 

  template <class PreconditionerType> 
  void 
  SchurComplement<PreconditionerType>::vmult(Vector<double> &      dst, 
                                             const Vector<double> &src) const 
  { 
    system_matrix->block(0, 1).vmult(tmp1, src); 
    A_inverse->vmult(tmp2, tmp1); 
    system_matrix->block(1, 0).vmult(dst, tmp2); 
  } 
// @sect3{StokesProblem class implementation}  
// @sect4{StokesProblem::StokesProblem}  

// 这个类的构造函数看起来与  step-20  的构造函数非常相似。构造函数初始化了多项式程度、三角形、有限元系统和dof处理器的变量。矢量速度分量的基础多项式函数的阶数为 <code>degree+1</code> ，压力的阶数为 <code>degree</code> 。 这就得到了LBB稳定元对 $Q_{degree+1}^d\times Q_{degree}$ ，通常被称为泰勒-霍德元。

// 请注意，我们用MeshSmoothing参数初始化三角形，这可以确保单元的细化是以PDE解的近似保持良好的方式进行的（如果网格过于非结构化就会出现问题），详情请参见 <code>Triangulation::MeshSmoothing</code> 的文档。

  template <int dim> 
  StokesProblem<dim>::StokesProblem(const unsigned int degree) 
    : degree(degree) 
    , triangulation(Triangulation<dim>::maximum_smoothing) 
    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1) 
    , dof_handler(triangulation) 
  {} 
// @sect4{StokesProblem::setup_dofs}  

// 给定一个网格，该函数将自由度与之关联，并创建相应的矩阵和向量。在开始的时候，它还释放了指向预处理对象的指针（如果共享指针在此时指向任何东西的话），因为在这之后肯定不会再需要它了，在组装矩阵后必须重新计算，并将稀疏矩阵从其稀疏模式对象中解开。

// 然后，我们继续分配自由度并重新编号。为了使ILU预处理程序（在3D中）有效地工作，重要的是以这样的方式列举自由度，以减少矩阵的带宽，或者也许更重要的是：以这样的方式使ILU尽可能地接近于真正的LU分解。另一方面，我们需要保留在  step-20  和  step-21  中已经看到的速度和压力的块状结构。这将分两步完成。首先，对所有的道次进行重新编号，以改善ILU，然后我们再一次按组件重新编号。由于 <code>DoFRenumbering::component_wise</code> 没有触及单个块内的重新编号，所以第一步的基本重新编号仍然存在。至于如何对自由度进行重新编号以提高ILU：deal.II有许多算法试图找到排序以提高ILU，或减少矩阵的带宽，或优化其他方面。DoFRenumbering命名空间显示了我们在本教程程序中基于这里讨论的测试案例而获得的几种算法的结果比较。在这里，我们将使用传统的Cuthill-McKee算法，该算法已经在之前的一些教程程序中使用。 在<a href="#improved-ilu">section on improved ILU</a>中我们将更详细地讨论这个问题。
//与以前的教程程序相比，
//还有一个变化。没有理由对 <code>dim</code> 的速度成分进行单独排序。事实上，与其先列举所有 $x$ -velocities，再列举所有 $y$ -velocities，等等，我们希望将所有速度放在一起，只在速度（所有分量）和压力之间分开。默认情况下， DoFRenumbering::component_wise 函数不是这样做的：它把每个矢量分量分开处理；我们要做的是把几个分量分成 "块"，并把这个块结构传递给该函数。因此，我们分配一个矢量 <code>block_component</code> ，有多少个元素就有多少个分量，描述所有的速度分量对应于块0，而压力分量将形成块1。

  template <int dim> 
  void StokesProblem<dim>::setup_dofs() 
  { 
    A_preconditioner.reset(); 
    system_matrix.clear(); 
    preconditioner_matrix.clear(); 

    dof_handler.distribute_dofs(fe); 
    DoFRenumbering::Cuthill_McKee(dof_handler); 

    std::vector<unsigned int> block_component(dim + 1, 0); 
    block_component[dim] = 1; 
    DoFRenumbering::component_wise(dof_handler, block_component); 

// 现在是对Dirichlet边界条件的实现，在介绍中的讨论之后，这应该是很明显的。所有的变化是，这个函数已经出现在设置函数中，而我们习惯于在一些汇编例程中看到它。在我们设置网格的下面，我们将把施加Dirichlet边界条件的顶部边界与边界指标1联系起来。 我们必须将这个边界指标作为第二个参数传递给下面的插值函数。 不过，还有一件事。 描述Dirichlet条件的函数是为所有分量定义的，包括速度和压力。然而，Dirichlet条件只为速度而设置。 为此，我们使用一个只选择速度分量的ComponentMask。通过指定我们想要的特定分量，从有限元中获得该分量掩码。由于我们使用自适应细化网格，仿生约束对象需要首先填充由DoF处理程序生成的悬挂节点约束。注意这两个函数的顺序；我们首先计算悬挂节点约束，然后将边界值插入约束对象。这确保了我们在有悬挂节点的边界上尊重H<sup>1</sup>一致性（在三个空间维度上），悬挂节点需要支配Dirichlet边界值。

    { 
      constraints.clear(); 

      FEValuesExtractors::Vector velocities(0); 
      DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               1, 
                                               BoundaryValues<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 
    } 

    constraints.close(); 

// 与 step-20 相类似，我们计算各个组件中的道夫。我们可以用与那里相同的方式来做，但我们想在我们已经用于重新编号的块结构上进行操作。函数  <code>DoFTools::count_dofs_per_fe_block</code>  的作用与  <code>DoFTools::count_dofs_per_fe_component</code>  相同，但现在通过  <code>block_component</code>  将速度和压力块分组。

    const std::vector<types::global_dof_index> dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, block_component); 
    const unsigned int n_u = dofs_per_block[0]; 
    const unsigned int n_p = dofs_per_block[1]; 

    std::cout << "   Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (" << n_u << '+' << n_p << ')' << std::endl; 

// 下一个任务是为我们将创建的系统矩阵分配一个稀疏模式，为预处理矩阵分配一个稀疏模式。我们可以用与 step-20 相同的方式来做这件事，即通过 DoFTools::make_sparsity_pattern. 直接建立一个SparsityPattern类型的对象，但是，有一个重要的理由不这样做。在3D中，函数 DoFTools::max_couplings_between_dofs 对各个道夫之间的耦合产生了一个保守但相当大的数字，因此，最初为创建矩阵的稀疏模式提供的内存太多--实际上，对于中等大小的3D问题，初始稀疏模式甚至无法放入大多数系统的物理内存中，也请参见 step-18  中的讨论。相反，我们首先建立临时对象，使用不同的数据结构，不需要分配更多的内存，但不适合作为SparseMatrix或BlockSparseMatrix对象的基础；在第二步，我们将这些对象复制到BlockSparsityPattern类型的对象中。这完全类似于我们在  step-11  和  step-18  中已经做过的事情。特别是，我们利用了这样一个事实，即我们永远不会写入系统矩阵的 $(1,1)$ 块中，而且这是唯一需要填充的预处理矩阵块。

// 所有这些都是在新范围内完成的，这意味着一旦信息被复制到  <code>sparsity_pattern</code>  ，  <code>dsp</code>  的内存将被释放。

    { 
      BlockDynamicSparsityPattern dsp(2, 2); 

      dsp.block(0, 0).reinit(n_u, n_u); 
      dsp.block(1, 0).reinit(n_p, n_u); 
      dsp.block(0, 1).reinit(n_u, n_p); 
      dsp.block(1, 1).reinit(n_p, n_p); 

      dsp.collect_sizes(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 

      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (!((c == dim) && (d == dim))) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern( 
        dof_handler, coupling, dsp, constraints, false); 

 
    } 

    { 
      BlockDynamicSparsityPattern preconditioner_dsp(2, 2); 

      preconditioner_dsp.block(0, 0).reinit(n_u, n_u); 
      preconditioner_dsp.block(1, 0).reinit(n_p, n_u); 
      preconditioner_dsp.block(0, 1).reinit(n_u, n_p); 
      preconditioner_dsp.block(1, 1).reinit(n_p, n_p); 

      preconditioner_dsp.collect_sizes(); 

      Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1); 

      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (((c == dim) && (d == dim))) 
            preconditioner_coupling[c][d] = DoFTools::always; 
          else 
            preconditioner_coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern(dof_handler, 
                                      preconditioner_coupling, 
                                      preconditioner_dsp, 
                                      constraints, 
                                      false); 

      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp); 
    } 

// 最后，与  step-20  中的方法类似，从块状结构中创建系统矩阵、前导矩阵、解决方案和右侧向量。

    system_matrix.reinit(sparsity_pattern); 
    preconditioner_matrix.reinit(preconditioner_sparsity_pattern); 

    solution.reinit(2); 
    solution.block(0).reinit(n_u); 
    solution.block(1).reinit(n_p); 
    solution.collect_sizes(); 

    system_rhs.reinit(2); 
    system_rhs.block(0).reinit(n_u); 
    system_rhs.block(1).reinit(n_p); 
    system_rhs.collect_sizes(); 
  } 
// @sect4{StokesProblem::assemble_system}  

// 汇编过程遵循 step-20 和介绍中的讨论。我们使用众所周知的缩写来表示保存本单元自由度的局部矩阵、右手边和全局编号的数据结构。

  template <int dim> 
  void StokesProblem<dim>::assemble_system() 
  { 
    system_matrix         = 0; 
    system_rhs            = 0; 
    preconditioner_matrix = 0; 

    QGauss<dim> quadrature_formula(degree + 2); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values | update_gradients); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

    const unsigned int n_q_points = quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> local_preconditioner_matrix(dofs_per_cell, 
                                                   dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const RightHandSide<dim>    right_hand_side; 
    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1)); 

// 接下来，我们需要两个对象，作为FEValues对象的提取器。它们的用途在  @ref  vector_valued 的报告中详细解释。

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

// 作为对 step-20 和 step-21 的扩展，我们包括了一些优化，使这个特定问题的装配速度大大加快。这些改进是基于这样的观察：当我们像 step-20 那样做时，我们做了太多次的计算：对称梯度实际上在每个正交点有 <code>dofs_per_cell</code> 个不同的值，但是我们从FEValues对象中提取了 <code>dofs_per_cell*dofs_per_cell</code> 次。

// - 在 <code>i</code> 的循环和 <code>j</code> 的内循环中。在3D中，这意味着评估它 $89^2=7921$ 次而不是 $89$ 次，这是一个不小的差别。

// 所以我们在这里要做的是，在开始对单元上的道夫进行循环之前，在正交点得到一个秩-2张量的向量（类似的还有压力上的发散和基函数值）来避免这种重复计算。首先，我们创建各自的对象来保存这些值。然后，我们开始在所有单元上进行循环，并在正交点上进行循环，在那里我们首先提取这些值。我们在这里还实现了一个优化：本地矩阵（以及全局矩阵）将是对称的，因为所有涉及的操作都是相对于 $i$ 和 $j$ 对称的。这可以通过简单地运行内循环而不是 <code>dofs_per_cell</code>, but only up to <code>i</code> 来实现，即外循环的索引。

    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell); 
    std::vector<double>                  div_phi_u(dofs_per_cell); 
    std::vector<double>                  phi_p(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        local_matrix                = 0; 
        local_preconditioner_matrix = 0; 
        local_rhs                   = 0; 

        right_hand_side.vector_value_list(fe_values.get_quadrature_points(), 
                                          rhs_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                symgrad_phi_u[k] = 
                  fe_values[velocities].symmetric_gradient(k, q); 
                div_phi_u[k] = fe_values[velocities].divergence(k, q); 
                phi_p[k]     = fe_values[pressure].value(k, q); 
              } 

// 最后是系统矩阵和我们用于预处理程序的矩阵的双线性形式。回顾一下，这两个的公式分别是
  //  @f{align*}{
  //    A_{ij} &= a(\varphi_i,\varphi_j)
  //    \\     &= \underbrace{2(\varepsilon(\varphi_{i,\textbf{u}}),
  //                            \varepsilon(\varphi_{j,\textbf{u}}))_{\Omega}}
  //                         _{(1)}
  //            \;
  //              \underbrace{- (\textrm{div}\; \varphi_{i,\textbf{u}},
  //                             \varphi_{j,p})_{\Omega}}
  //                         _{(2)}
  //            \;
  //              \underbrace{- (\varphi_{i,p},
  //                             \textrm{div}\;
  //                             \varphi_{j,\textbf{u}})_{\Omega}}
  //                         _{(3)}
  //  @f}
  //  和
  //  @f{align*}{
  //    M_{ij} &= \underbrace{(\varphi_{i,p},
  //                           \varphi_{j,p})_{\Omega}}
  //                         _{(4)},
  //  @f} ， 
  //  其中 $\varphi_{i,\textbf{u}}$ 和 $\varphi_{i,p}$ 是 $i$ th形状函数的速度和压力成分。然后，上述各种术语在下面的实现中很容易识别。

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              { 
                for (unsigned int j = 0; j <= i; ++j) 
                  { 
                    local_matrix(i, j) += 
                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) // (1) 
                       - div_phi_u[i] * phi_p[j]                 // (2) 
                       - phi_p[i] * div_phi_u[j])                // (3) 
                      * fe_values.JxW(q);                        // * dx 

                    local_preconditioner_matrix(i, j) += 
                      (phi_p[i] * phi_p[j]) // (4) 
                      * fe_values.JxW(q);   // * dx 
                  } 

// 注意在上述（1）的实现中，`operator*`被重载用于对称张量，产生两个张量之间的标量乘积。            对于右手边，我们利用形状函数只在一个分量中不为零的事实（因为我们的元素是原始的）。 我们不是将代表形状函数i的dim+1值的张量与整个右手边的向量相乘，而是只看唯一的非零分量。函数 FiniteElement::system_to_component_index 将返回这个形状函数所处的分量（0=x速度，1=y速度，2=2d中的压力），我们用它来挑选出右手边向量的正确分量来相乘。

                const unsigned int component_i = 
                  fe.system_to_component_index(i).first; 
                local_rhs(i) += (fe_values.shape_value(i, q)   // (phi_u_i(x_q) 
                                 * rhs_values[q](component_i)) // * f(x_q)) 
                                * fe_values.JxW(q);            // * dx 
              } 
          } 

// 在我们将局部数据写入全局矩阵之前（同时使用AffineConstraints对象来应用Dirichlet边界条件并消除悬挂的节点约束，正如我们在介绍中讨论的那样），我们必须注意一件事。由于对称性，我们只建立了一半的局部矩阵，但我们要保存完整的矩阵，以便使用标准函数进行解算。这是通过翻转指数来实现的，以防我们指向本地矩阵的空部分。

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = i + 1; j < dofs_per_cell; ++j) 
            { 
              local_matrix(i, j) = local_matrix(j, i); 
              local_preconditioner_matrix(i, j) = 
                local_preconditioner_matrix(j, i); 
            } 

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global(local_matrix, 
                                               local_rhs, 
                                               local_dof_indices, 
                                               system_matrix, 
                                               system_rhs); 
        constraints.distribute_local_to_global(local_preconditioner_matrix, 
                                               local_dof_indices, 
                                               preconditioner_matrix); 
      } 

// 在我们要解决这个线性系统之前，我们为速度-速度矩阵生成一个预处理程序，即系统矩阵中的 <code>block(0,0)</code> 。如上所述，这取决于空间维度。由于 <code>InnerPreconditioner::type</code> 别名所描述的两个类具有相同的接口，因此无论我们想使用稀疏直接求解器还是ILU，都不需要做任何不同的事情。

    std::cout << "   Computing preconditioner..." << std::endl << std::flush; 

    A_preconditioner = 
      std::make_shared<typename InnerPreconditioner<dim>::type>(); 
    A_preconditioner->initialize( 
      system_matrix.block(0, 0), 
      typename InnerPreconditioner<dim>::type::AdditionalData()); 
  } 

//  @sect4{StokesProblem::solve}  

// 经过前面介绍中的讨论和各自类的定义， <code>solve</code> 函数的实现是相当直接的，其方式与 step-20 类似。首先，我们需要一个 <code>InverseMatrix</code> 类的对象，代表矩阵A的逆。正如在介绍中所描述的，在  <code>InnerPreconditioner::type</code>  类型的内部预处理器的帮助下，生成了逆。

  template <int dim> 
  void StokesProblem<dim>::solve() 
  { 
    const InverseMatrix<SparseMatrix<double>, 
                        typename InnerPreconditioner<dim>::type> 
                   A_inverse(system_matrix.block(0, 0), *A_preconditioner); 
    Vector<double> tmp(solution.block(0).size()); 

// 这与  step-20  中的情况一样。我们生成 Schur 补数的右手边  $B A^{-1} F - G$  和一个代表各自线性运算的对象  $B A^{-1} B^T$  ，现在有一个模板参数表示预处理器

// - 按照类的定义。

    { 
      Vector<double> schur_rhs(solution.block(1).size()); 
      A_inverse.vmult(tmp, system_rhs.block(0)); 
      system_matrix.block(1, 0).vmult(schur_rhs, tmp); 
      schur_rhs -= system_rhs.block(1); 

      SchurComplement<typename InnerPreconditioner<dim>::type> schur_complement( 
        system_matrix, A_inverse); 

// 解算器调用的常规控制结构被创建...

      SolverControl            solver_control(solution.block(1).size(), 
                                   1e-6 * schur_rhs.l2_norm()); 
      SolverCG<Vector<double>> cg(solver_control); 

// 现在是对舒尔补码的预处理。正如介绍中所解释的，预处理是由压力变量的质量矩阵来完成的。

// 实际上，求解器需要有 $P^{-1}$ 形式的预处理，所以我们需要创建一个逆运算。我们再次使用一个 <code>InverseMatrix</code> 类的对象，它实现了求解器需要的 <code>vmult</code> 操作。 在这种情况下，我们必须对压力质量矩阵进行反转。正如在早期的教程程序中已经证明的那样，质量矩阵的反转是一个相当便宜和简单的操作（与拉普拉斯矩阵等相比）。带有ILU预处理的CG方法在5-10步内收敛，与网格大小无关。 这正是我们在这里所做的。我们选择另一个ILU预处理，并通过相应的模板参数将其带入InverseMatrix对象。 然后在逆矩阵的vmult操作中调用一个CG求解器。

// 另一种方法是选择因子为1.2的SSOR预处理器，这种方法构建成本较低，但之后需要更多的迭代。它需要大约两倍的迭代次数，但其生成的成本几乎可以忽略不计。

      SparseILU<double> preconditioner; 
      preconditioner.initialize(preconditioner_matrix.block(1, 1), 
                                SparseILU<double>::AdditionalData()); 

      InverseMatrix<SparseMatrix<double>, SparseILU<double>> m_inverse( 
        preconditioner_matrix.block(1, 1), preconditioner); 

// 有了舒尔补码和高效的预处理程序，我们可以用通常的方法解决压力的相关方程（即解向量中的0块）。

      cg.solve(schur_complement, solution.block(1), schur_rhs, m_inverse); 

// 在这第一个求解步骤之后，必须将悬挂的节点约束分布到求解中，以实现一致的压力场。

      constraints.distribute(solution); 

      std::cout << "  " << solver_control.last_step() 
                << " outer CG Schur complement iterations for pressure" 
                << std::endl; 
    } 

// 和 step-20 一样，我们最后需要解速度方程，在这里我们插入压力方程的解。这只涉及我们已经知道的对象

// 所以我们只需用 $p$ 乘以 $B^T$ ，减去右边的部分，再乘以 $A$ 的逆数。最后，我们需要分配悬挂节点的约束，以获得一个一致的流场。

    { 
      system_matrix.block(0, 1).vmult(tmp, solution.block(1)); 
      tmp *= -1; 
      tmp += system_rhs.block(0); 

      A_inverse.vmult(solution.block(0), tmp); 

      constraints.distribute(solution); 
    } 
  } 
// @sect4{StokesProblem::output_results}  

// 下一个函数生成图形输出。在这个例子中，我们将使用VTK文件格式。 我们给问题中的各个变量附上名字： <code>velocity</code> to the <code>dim</code> 速度的组成部分和 <code>pressure</code> 压力的组成部分。

// 并非所有的可视化程序都有能力将各个矢量分量组合成一个矢量来提供矢量图；特别是对于一些基于VTK的可视化程序来说，这一点是成立的。在这种情况下，在包含数据的文件中应该已经描述了组件的逻辑分组为矢量的情况。换句话说，我们需要做的是为我们的输出编写者提供一种方法，让他们知道有限元的哪些分量在逻辑上形成一个矢量（在 $d$ 空间维度上有 $d$ 分量），而不是让他们假设我们只是有一堆标量场。 这是用 <code>DataComponentInterpretation</code> 命名空间的成员实现的：和文件名一样，我们创建一个矢量，其中第一个 <code>dim</code> 分量指的是速度，并被赋予 DataComponentInterpretation::component_is_part_of_vector; 标签，我们最后推一个标签 DataComponentInterpretation::component_is_scalar 来描述压力变量的分组。

// 然后函数的其余部分与  step-20  中的相同。

  template <int dim> 
  void 
  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("pressure"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.build_patches(); 

    std::ofstream output( 
      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk"); 
    data_out.write_vtk(output); 
  } 
// @sect4{StokesProblem::refine_mesh}  

// 这是 <code>StokesProblem</code> 类中最后一个有趣的函数。 正如它的名字所示，它获取问题的解决方案，并在需要时细化网格。其过程与 step-6 中的相应步骤相同，不同的是我们只根据压力的变化进行细化，也就是说，我们用ComponentMask类型的掩码对象调用Kelly误差估计器，选择我们感兴趣的压力的单一标量分量（我们通过指定我们想要的分量从有限元类中得到这样一个掩码）。此外，我们没有再次粗化网格。

  template <int dim> 
  void StokesProblem<dim>::refine_mesh() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    FEValuesExtractors::Scalar pressure(dim); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      estimated_error_per_cell, 
      fe.component_mask(pressure)); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.0); 
    triangulation.execute_coarsening_and_refinement(); 
  } 
// @sect4{StokesProblem::run}  

// 在斯托克斯类中的最后一步，像往常一样，是生成初始网格的函数，并按各自的顺序调用其他函数。

// 我们从一个大小为 $4 \times 1$ （2D）或 $4 \times 1 \times 1$ （3D）的矩形开始，在 $R^2/R^3$ 中分别放置为 $(-2,2)\times(-1,0)$ 或 $(-2,2)\times(0,1)\times(-1,0)$  。在每个方向上以相等的网格大小开始是很自然的，所以我们在第一个坐标方向上将初始矩形细分四次。为了将创建网格所涉及的变量的范围限制在我们实际需要的范围内，我们将整个块放在一对大括号之间。

  template <int dim> 
  void StokesProblem<dim>::run() 
  { 
    { 
      std::vector<unsigned int> subdivisions(dim, 1); 
      subdivisions[0] = 4; 

      const Point<dim> bottom_left = (dim == 2 ?                // 
                                        Point<dim>(-2, -1) :    // 2d case 
                                        Point<dim>(-2, 0, -1)); // 3d case 

      const Point<dim> top_right = (dim == 2 ?              // 
                                      Point<dim>(2, 0) :    // 2d case 
                                      Point<dim>(2, 1, 0)); // 3d case 

      GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                                subdivisions, 
                                                bottom_left, 
                                                top_right); 
    } 

// 边界指标1被设置为所有受Dirichlet边界条件约束的边界，即位于最后一个坐标方向上的0的面。详见上面的例子描述。

    for (const auto &cell : triangulation.active_cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->center()[dim - 1] == 0) 
          face->set_all_boundary_ids(1); 

// 然后，在第一次求解之前，我们应用一个初始细化。在3D中，会有更多的自由度，所以我们在那里细化得更少。

    triangulation.refine_global(4 - dim); 

// 正如在 step-6 中第一次看到的那样，我们在不同的细化级别上循环细化（除了第一个循环），设置自由度和矩阵，组装，求解和创建输出。

    for (unsigned int refinement_cycle = 0; refinement_cycle < 6; 
         ++refinement_cycle) 
      { 
        std::cout << "Refinement cycle " << refinement_cycle << std::endl; 

        if (refinement_cycle > 0) 
          refine_mesh(); 

        setup_dofs(); 

        std::cout << "   Assembling..." << std::endl << std::flush; 
        assemble_system(); 

        std::cout << "   Solving..." << std::flush; 
        solve(); 

        output_results(refinement_cycle); 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step22 
// @sect3{The <code>main</code> function}  

// 主函数与  step-20  中的相同。我们将元素度数作为参数传递，并在众所周知的模板槽中选择空间尺寸。

int main() 
{ 
  try 
    { 
      using namespace Step22; 

      StokesProblem<2> flow_problem(1); 
      flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-23.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2006 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Texas A&M University, 2006 
 */ 


// @sect3{Include files}  

// 我们从通常的各种各样的包含文件开始，我们在以前的许多测试中都看到过。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 

#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iostream> 

// 这里是仅有的三个有一些新兴趣的包含文件。第一个文件已经被使用了，例如，用于 VectorTools::interpolate_boundary_values 和 MatrixTools::apply_boundary_values 函数。然而，我们在这里使用该类中的另一个函数， VectorTools::project 来计算我们的初始值，作为连续初始值的 $L^2$ 投影。此外，我们使用  VectorTools::create_right_hand_side  来生成积分  $(f^n,\phi^n_i)$  。这些以前总是由 <code>assemble_system</code> 或应用程序代码中的类似函数手工生成。然而，我们太懒了，不能在这里这么做，所以干脆使用库函数。

#include <deal.II/numerics/vector_tools.h> 

// 与此非常相似，我们也懒得写代码来组装质量矩阵和拉普拉斯矩阵，尽管这只需要从以前的任何一个教程程序中复制相关代码。相反，我们想把重点放在这个程序中真正新的东西上，因此使用了 MatrixCreator::create_mass_matrix 和 MatrixCreator::create_laplace_matrix 函数。它们被声明在这里。

#include <deal.II/numerics/matrix_tools.h> 

// 最后，这里有一个include文件，它包含了人们有时需要的各种工具函数。特别是，我们需要 Utilities::int_to_string 类，该类在给定一个整数参数后，返回它的字符串表示。它特别有用，因为它允许第二个参数，表明我们希望结果用前导零填充的数字数。我们将用它来写输出文件，其形式为 <code>solution-XXX.vtu</code> where <code>XXX</code> 表示时间步数，并且总是由三位数组成，即使我们仍然处于个位或两位数的时间步数中。

#include <deal.II/base/utilities.h> 

// 最后一步和以前所有的程序一样。

namespace Step23 
{ 
  using namespace dealii; 
// @sect3{The <code>WaveEquation</code> class}  

// 接下来是主类的声明。它的公共函数接口与其他大多数教程程序一样。值得一提的是，我们现在必须存储四个矩阵，而不是一个：质量矩阵  $M$  ，拉普拉斯矩阵  $A$  ，用于求解  $U^n$  的矩阵  $M+k^2\theta^2A$  ，以及用于求解  $V^n$  的带有边界条件的质量矩阵副本。请注意，在周围有一个额外的质量矩阵副本是有点浪费的。我们将在可能的改进部分讨论如何避免这种情况的策略。

// 同样，我们需要 $U^n,V^n$ 的解向量，以及前一个时间步骤 $U^{n-1},V^{n-1}$ 的相应向量。 <code>system_rhs</code> 将用于我们在每个时间步骤中求解两个线性系统之一时的任何右手向量。这些将在两个函数  <code>solve_u</code>  和  <code>solve_v</code>  中解决。

// 最后，变量 <code>theta</code> 用来表示参数 $\theta$ ，该参数用于定义使用哪种时间步进方案，这在介绍中已经说明。剩下的就不言而喻了。

  template <int dim> 
  class WaveEquation 
  { 
  public: 
    WaveEquation(); 
    void run(); 

  private: 
    void setup_system(); 
    void solve_u(); 
    void solve_v(); 
    void output_results() const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> mass_matrix; 
    SparseMatrix<double> laplace_matrix; 
    SparseMatrix<double> matrix_u; 
    SparseMatrix<double> matrix_v; 

    Vector<double> solution_u, solution_v; 
    Vector<double> old_solution_u, old_solution_v; 
    Vector<double> system_rhs; 

    double       time_step; 
    double       time; 
    unsigned int timestep_number; 
    const double theta; 
  }; 

//  @sect3{Equation data}  

// 在我们继续填写主类的细节之前，让我们定义与问题相对应的方程数据，即解 $u$ 及其时间导数 $v$ 的初始值和边界值，以及一个右手类。我们使用从Function类模板派生出来的类来做这件事，这个模板以前已经用过很多次了，所以下面的内容不应该是一个惊喜。

// 我们从初始值开始，对数值 $u$ 以及它的时间导数，即速度 $v$ 都选择零。

  template <int dim> 
  class InitialValuesU : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & /*p*/, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      Assert(component == 0, ExcIndexRange(component, 0, 1)); 
      return 0; 
    } 
  }; 

  template <int dim> 
  class InitialValuesV : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & /*p*/, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      Assert(component == 0, ExcIndexRange(component, 0, 1)); 
      return 0; 
    } 
  }; 

// 其次，我们有右手边的强制项。无聊的是，我们在这里也选择零。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & /*p*/, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      Assert(component == 0, ExcIndexRange(component, 0, 1)); 
      return 0; 
    } 
  }; 

// 最后，我们有  $u$  和  $v$  的边界值。它们与介绍中描述的一样，一个是另一个的时间导数。

  template <int dim> 
  class BoundaryValuesU : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      Assert(component == 0, ExcIndexRange(component, 0, 1)); 

      if ((this->get_time() <= 0.5) && (p[0] < 0) && (p[1] < 1. / 3) && 
          (p[1] > -1. / 3)) 
        return std::sin(this->get_time() * 4 * numbers::PI); 
      else 
        return 0; 
    } 
  }; 

  template <int dim> 
  class BoundaryValuesV : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      Assert(component == 0, ExcIndexRange(component, 0, 1)); 

      if ((this->get_time() <= 0.5) && (p[0] < 0) && (p[1] < 1. / 3) && 
          (p[1] > -1. / 3)) 
        return (std::cos(this->get_time() * 4 * numbers::PI) * 4 * numbers::PI); 
      else 
        return 0; 
    } 
  }; 

//  @sect3{Implementation of the <code>WaveEquation</code> class}  

// 实际逻辑的实现实际上是相当短的，因为我们把组装矩阵和右手边的向量等事情交给了库。其余的实际代码不超过130行，其中相当一部分是可以从以前的例子程序中获取的模板代码（例如，解决线性系统的函数，或生成输出的函数）。

// 我们从构造函数开始（关于时间步长的选择的解释，请参见介绍中关于Courant, Friedrichs, and Lewy的部分）。

  template <int dim> 
  WaveEquation<dim>::WaveEquation() 
    : fe(1) 
    , dof_handler(triangulation) 
    , time_step(1. / 64) 
    , time(time_step) 
    , timestep_number(1) 
    , theta(0.5) 
  {} 
// @sect4{WaveEquation::setup_system}  

// 下一个函数是在程序开始时，也就是在第一个时间步骤之前，设置网格、DoFHandler以及矩阵和向量。如果你已经阅读了至少到 step-6 为止的教程程序，那么前几行是相当标准的。

  template <int dim> 
  void WaveEquation<dim>::setup_system() 
  { 
    GridGenerator::hyper_cube(triangulation, -1, 1); 
    triangulation.refine_global(7); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl; 

    dof_handler.distribute_dofs(fe); 

    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl 
              << std::endl; 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

// 然后，我们必须初始化程序过程中需要的3个矩阵：质量矩阵、拉普拉斯矩阵和在每个时间步长中求解 $M+k^2\theta^2A$ 时使用的矩阵 $U^n$ 。

// 在设置这些矩阵时，请注意它们都是利用了相同的稀疏模式对象。最后，在deal.II中矩阵和稀疏模式是独立对象的原因（与其他许多有限元或线性代数类不同）变得很清楚：在相当一部分应用中，我们必须持有几个恰好具有相同稀疏模式的矩阵，它们没有理由不共享这一信息，而不是重新建立并多次浪费内存。

// 在初始化所有这些矩阵后，我们调用库函数来建立拉普拉斯和质量矩阵。它们所需要的只是一个DoFHandler对象和一个将用于数值积分的正交公式对象。请注意，在许多方面，这些函数比我们通常在应用程序中做的要好，例如，如果一台机器有多个处理器，它们会自动并行构建矩阵：更多信息见WorkStream的文档或 @ref threads "多处理器并行计算 "模块。解决线性系统的矩阵将在run()方法中被填充，因为我们需要在每个时间步长中重新应用边界条件。

    mass_matrix.reinit(sparsity_pattern); 
    laplace_matrix.reinit(sparsity_pattern); 
    matrix_u.reinit(sparsity_pattern); 
    matrix_v.reinit(sparsity_pattern); 

    MatrixCreator::create_mass_matrix(dof_handler, 
                                      QGauss<dim>(fe.degree + 1), 
                                      mass_matrix); 
    MatrixCreator::create_laplace_matrix(dof_handler, 
                                         QGauss<dim>(fe.degree + 1), 
                                         laplace_matrix); 

// 该函数的其余部分用于将矢量大小设置为正确的值。最后一行关闭了悬挂的节点约束对象。由于我们在一个均匀细化的网格上工作，所以不存在或没有计算过约束条件（即没有必要像其他程序那样调用 DoFTools::make_hanging_node_constraints ），但无论如何，我们需要在下面的一个地方进一步设置一个约束对象。

    solution_u.reinit(dof_handler.n_dofs()); 
    solution_v.reinit(dof_handler.n_dofs()); 
    old_solution_u.reinit(dof_handler.n_dofs()); 
    old_solution_v.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.close(); 
  } 

//  @sect4{WaveEquation::solve_u and WaveEquation::solve_v}  

// 接下来的两个函数是解决与  $U^n$  和  $V^n$  的方程有关的线性系统。这两个函数并不特别有趣，因为它们基本沿用了前面所有教程程序中的方案。

// 我们可以对我们要反转的两个矩阵的预处理程序做一些小实验。然而，事实证明，对于这里的矩阵，使用雅可比或SSOR预处理器可以稍微减少解决线性系统所需的迭代次数，但由于应用预处理器的成本，在运行时间方面并不占优势。这也不是什么损失，但让我们保持简单，只做不做。

  template <int dim> 
  void WaveEquation<dim>::solve_u() 
  { 
    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    cg.solve(matrix_u, solution_u, system_rhs, PreconditionIdentity()); 

    std::cout << "   u-equation: " << solver_control.last_step() 
              << " CG iterations." << std::endl; 
  } 

  template <int dim> 
  void WaveEquation<dim>::solve_v() 
  { 
    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    cg.solve(matrix_v, solution_v, system_rhs, PreconditionIdentity()); 

    std::cout << "   v-equation: " << solver_control.last_step() 
              << " CG iterations." << std::endl; 
  } 

//  @sect4{WaveEquation::output_results}  

// 同样地，下面的函数也和我们之前做的差不多。唯一值得一提的是，这里我们使用 Utilities::int_to_string 函数的第二个参数，生成了一个用前导零填充的时间步长的字符串表示，长度为3个字符。

  template <int dim> 
  void WaveEquation<dim>::output_results() const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution_u, "U"); 
    data_out.add_data_vector(solution_v, "V"); 

    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu"; 

// 像  step-15  一样，由于我们在每个时间步长写输出（而且我们要解决的系统相对简单），我们指示DataOut使用zlib压缩算法，该算法针对速度而不是磁盘使用进行了优化，因为否则绘制输出会成为一个瓶颈。

    DataOutBase::VtkFlags vtk_flags; 
    vtk_flags.compression_level = 
      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed; 
    data_out.set_flags(vtk_flags); 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 

//  @sect4{WaveEquation::run}  

// 下面是程序中唯一有趣的功能。它包含了所有时间步骤的循环，但在这之前我们必须设置网格、DoFHandler和矩阵。此外，我们必须以某种方式从初始值开始。为此，我们使用 VectorTools::project 函数，该函数接收一个描述连续函数的对象，并计算该函数在DoFHandler对象所描述的有限元空间的 $L^2$ 投影。没有比这更简单的了。

  template <int dim> 
  void WaveEquation<dim>::run() 
  { 
    setup_system(); 

    VectorTools::project(dof_handler, 
                         constraints, 
                         QGauss<dim>(fe.degree + 1), 
                         InitialValuesU<dim>(), 
                         old_solution_u); 
    VectorTools::project(dof_handler, 
                         constraints, 
                         QGauss<dim>(fe.degree + 1), 
                         InitialValuesV<dim>(), 
                         old_solution_v); 

// 接下来是循环所有的时间步骤，直到我们到达结束时间（本例中为 $T=5$ ）。在每个时间步骤中，我们首先要解决 $U^n$ ，使用方程  $(M^n + k^2\theta^2 A^n)U^n =$  。
// $(M^{n,n-1} - k^2\theta(1-\theta) A^{n,n-1})U^{n-1} + kM^{n,n-1}V^{n-1} +$  
// $k\theta \left[k \theta F^n + k(1-\theta) F^{n-1} \right]$  . 请注意，我们在所有的时间步骤中使用相同的网格，因此， $M^n=M^{n,n-1}=M$  和  $A^n=A^{n,n-1}=A$  。因此，我们首先要做的是将 $MU^{n-1} - k^2\theta(1-\theta) AU^{n-1} + kMV^{n-1}$ 和强制项相加，并将结果放入 <code>system_rhs</code> 向量中。(对于这些加法，我们需要在循环之前声明一个临时向量，以避免在每个时间步骤中重复分配内存)。

// 这里需要意识到的是我们如何将时间变量传达给描述右手边的对象：每个从函数类派生出来的对象都有一个时间字段，可以用 Function::set_time 来设置，用 Function::get_time. 来读取。 实质上，使用这种机制，所有空间和时间的函数因此被认为是在某个特定时间评估的空间的函数。这与我们在有限元程序中的典型需求非常吻合，在有限元程序中，我们几乎总是在一个时间步长上工作，而且从来没有发生过，例如，人们想在任何给定的空间位置上为所有时间评估一个时空函数。

    Vector<double> tmp(solution_u.size()); 
    Vector<double> forcing_terms(solution_u.size()); 

    for (; time <= 5; time += time_step, ++timestep_number) 
      { 
        std::cout << "Time step " << timestep_number << " at t=" << time 
                  << std::endl; 

        mass_matrix.vmult(system_rhs, old_solution_u); 

        mass_matrix.vmult(tmp, old_solution_v); 
        system_rhs.add(time_step, tmp); 

        laplace_matrix.vmult(tmp, old_solution_u); 
        system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp); 

        RightHandSide<dim> rhs_function; 
        rhs_function.set_time(time); 
        VectorTools::create_right_hand_side(dof_handler, 
                                            QGauss<dim>(fe.degree + 1), 
                                            rhs_function, 
                                            tmp); 
        forcing_terms = tmp; 
        forcing_terms *= theta * time_step; 

        rhs_function.set_time(time - time_step); 
        VectorTools::create_right_hand_side(dof_handler, 
                                            QGauss<dim>(fe.degree + 1), 
                                            rhs_function, 
                                            tmp); 

        forcing_terms.add((1 - theta) * time_step, tmp); 

        system_rhs.add(theta * time_step, forcing_terms); 

// 如此构建了第一个方程的右手向量后，我们要做的就是应用正确的边界值。至于右手边，这是一个在特定时间评估的时空函数，我们在边界节点插值，然后像通常那样用结果来应用边界值。然后将结果交给solve_u()函数。

        { 
          BoundaryValuesU<dim> boundary_values_u_function; 
          boundary_values_u_function.set_time(time); 

          std::map<types::global_dof_index, double> boundary_values; 
          VectorTools::interpolate_boundary_values(dof_handler, 
                                                   0, 
                                                   boundary_values_u_function, 
                                                   boundary_values); 

// solve_u()的矩阵在每个时间步骤中都是相同的，所以人们可以认为只在模拟开始时做一次就足够了。然而，由于我们需要对线性系统应用边界值（消除了一些矩阵的行和列，并对右手边做出了贡献），在实际应用边界数据之前，我们必须在每个时间步骤中重新填充该矩阵。实际内容非常简单：它是质量矩阵和加权拉普拉斯矩阵的总和。

          matrix_u.copy_from(mass_matrix); 
          matrix_u.add(theta * theta * time_step * time_step, laplace_matrix); 
          MatrixTools::apply_boundary_values(boundary_values, 
                                             matrix_u, 
                                             solution_u, 
                                             system_rhs); 
        } 
        solve_u(); 

// 第二步，即求解 $V^n$ ，工作原理类似，只是这次左边的矩阵是质量矩阵（我们再次复制，以便能够应用边界条件，而右边是 $MV^{n-1} - k\left[ \theta A U^n + (1-\theta) AU^{n-1}\right]$ 加上强制项。边界值的应用方式与之前相同，只是现在我们必须使用BoundaryValuesV类。

        laplace_matrix.vmult(system_rhs, solution_u); 
        system_rhs *= -theta * time_step; 

        mass_matrix.vmult(tmp, old_solution_v); 
        system_rhs += tmp; 

        laplace_matrix.vmult(tmp, old_solution_u); 
        system_rhs.add(-time_step * (1 - theta), tmp); 

        system_rhs += forcing_terms; 

        { 
          BoundaryValuesV<dim> boundary_values_v_function; 
          boundary_values_v_function.set_time(time); 

          std::map<types::global_dof_index, double> boundary_values; 
          VectorTools::interpolate_boundary_values(dof_handler, 
                                                   0, 
                                                   boundary_values_v_function, 
                                                   boundary_values); 
          matrix_v.copy_from(mass_matrix); 
          MatrixTools::apply_boundary_values(boundary_values, 
                                             matrix_v, 
                                             solution_v, 
                                             system_rhs); 
        } 
        solve_v(); 

// 最后，在计算完两个解的组成部分后，我们输出结果，计算解中的能量，并在将现在的解移入持有上一个时间步长的解的向量后，继续下一个时间步长。注意函数 SparseMatrix::matrix_norm_square 可以在一个步骤中计算 $\left<V^n,MV^n\right>$ 和 $\left<U^n,AU^n\right>$ ，为我们节省了一个临时向量和几行代码的费用。

        output_results(); 

        std::cout << "   Total energy: " 
                  << (mass_matrix.matrix_norm_square(solution_v) + 
                      laplace_matrix.matrix_norm_square(solution_u)) / 
                       2 
                  << std::endl; 

        old_solution_u = solution_u; 
        old_solution_v = solution_v; 
      } 
  } 
} // namespace Step23 
// @sect3{The <code>main</code> function}  

//剩下的就是程序的主要功能了。这里没有什么是在前面几个程序中没有展示过的。

int main() 
{ 
  try 
    { 
      using namespace Step23; 

      WaveEquation<2> wave_equation_solver; 
      wave_equation_solver.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-24.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2006 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Xing Jin, Wolfgang Bangerth, Texas A&M University, 2006 
 */ 


// @sect3{Include files}  

// 以下内容之前都已经介绍过了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/vector_tools.h> 

#include <fstream> 
#include <iostream> 

// 这是唯一一个新的。我们将需要一个定义在GridTools命名空间的库函数，用来计算最小的单元格直径。

#include <deal.II/grid/grid_tools.h> 

// 最后一步和以前所有的程序一样。

namespace Step24 
{ 
  using namespace dealii; 
// @sect3{The "forward problem" class template}  

// 主类的第一部分与 step-23 中的内容完全一致（除了名字）。

  template <int dim> 
  class TATForwardProblem 
  { 
  public: 
    TATForwardProblem(); 
    void run(); 

  private: 
    void setup_system(); 
    void solve_p(); 
    void solve_v(); 
    void output_results() const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 
    SparseMatrix<double> mass_matrix; 
    SparseMatrix<double> laplace_matrix; 

    Vector<double> solution_p, solution_v; 
    Vector<double> old_solution_p, old_solution_v; 
    Vector<double> system_rhs_p, system_rhs_v; 

    double       time_step, time; 
    unsigned int timestep_number; 
    const double theta; 

// 下面是新的内容：首先，我们需要从吸收边界条件出来的那个边界质量矩阵 $B$ 。同样，由于这次我们考虑的是一个现实的介质，我们必须有一个衡量波速的标准 $c_0$ ，它将进入所有与拉普拉斯矩阵（我们仍然定义为 $(\nabla \phi_i,\nabla \phi_j)$ ）有关的公式。

    SparseMatrix<double> boundary_matrix; 
    const double         wave_speed; 

// 我们必须注意的最后一件事是，我们想在一定数量的检测器位置评估解决方案。我们需要一个数组来保存这些位置，在这里声明并在构造函数中填充。

    std::vector<Point<dim>> detector_locations; 
  }; 
// @sect3{Equation data}  

// 像往常一样，我们必须定义我们的初始值、边界条件和右手边的函数。这次事情有点简单：我们考虑的是一个由初始条件驱动的问题，所以没有右手函数（尽管你可以在 step-23 中查找，看看如何做到这一点）。其次，没有边界条件：域的整个边界由吸收性边界条件组成。这就只剩下初始条件了，这里的事情也很简单，因为对于这个特殊的应用，只规定了压力的非零初始条件，而没有规定速度的非零初始条件（速度在初始时间为零）。

// 所以这就是我们所需要的：一个指定压力初始条件的类。在本程序所考虑的物理环境中，这些是小的吸收器，我们将其建模为一系列的小圆圈，我们假设压力盈余为1，而其他地方没有吸收，因此没有压力盈余。我们是这样做的（注意，如果我们想把这个程序扩展到不仅可以编译，而且可以运行，我们将不得不用三维源的位置来初始化源）。

  template <int dim> 
  class InitialValuesP : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      static const std::array<Source, 5> sources{ 
        {Source(Point<dim>(0, 0), 0.025), 
         Source(Point<dim>(-0.135, 0), 0.05), 
         Source(Point<dim>(0.17, 0), 0.03), 
         Source(Point<dim>(-0.25, 0), 0.02), 
         Source(Point<dim>(-0.05, -0.15), 0.015)}}; 

      for (const auto &source : sources) 
        if (p.distance(source.location) < source.radius) 
          return 1; 

      return 0; 
    } 

 
    struct Source 
    { 
      Source(const Point<dim> &l, const double r) 
        : location(l) 
        , radius(r) 
      {} 

      const Point<dim> location; 
      const double     radius; 
    }; 
  }; 
// @sect3{Implementation of the <code>TATForwardProblem</code> class}  

// 让我们再从构造函数开始。设置成员变量是很直接的。我们使用矿物油的声波速度（单位为毫米/微秒，是实验性生物医学成像中的常用单位），因为我们想和输出的许多实验都是在这里进行的。再次使用Crank-Nicolson方案，即theta被设定为0.5。随后选择时间步长以满足 $k = \frac hc$ ：这里我们把它初始化为一个无效的数字。

  template <int dim> 
  TATForwardProblem<dim>::TATForwardProblem() 
    : fe(1) 
    , dof_handler(triangulation) 
    , time_step(std::numeric_limits<double>::quiet_NaN()) 
    , time(time_step) 
    , timestep_number(1) 
    , theta(0.5) 
    , wave_speed(1.437) 
  { 

// 构造函数中的第二个任务是初始化存放检测器位置的数组。这个程序的结果与实验进行了比较，其中检测器间距的步长为2.25度，对应160个检测器位置。扫描圆的半径被选为中心和边界之间的一半，以避免不完善的边界条件带来的剩余反射破坏我们的数值结果。

// 然后按顺时针顺序计算探测器的位置。请注意，下面的内容当然只有在我们以2D计算时才有效，我们用一个断言来保护这个条件。如果我们以后想在三维中运行同样的程序，我们将不得不在这里添加代码来初始化三维中的探测器位置。由于断言的存在，我们不可能忘记这样做。

    Assert(dim == 2, ExcNotImplemented()); 

    const double detector_step_angle = 2.25; 
    const double detector_radius     = 0.5; 

    for (double detector_angle = 2 * numbers::PI; detector_angle >= 0; 
         detector_angle -= detector_step_angle / 360 * 2 * numbers::PI) 
      detector_locations.push_back( 
        Point<dim>(std::cos(detector_angle), std::sin(detector_angle)) * 
        detector_radius); 
  } 

//  @sect4{TATForwardProblem::setup_system}  

// 下面的系统几乎就是我们在  step-23  中已经做过的，但有两个重要的区别。首先，我们必须在原点周围创建一个半径为1的圆形（或球形）网格。这并不新鲜：我们之前在 step-6 和 step-10 中已经这样做了，在那里我们还解释了PolarManifold或SphericalManifold对象如何在细化单元时将新点放在同心圆上，我们在这里也将使用它。

// 我们必须确保的一点是，时间步长满足  step-23  的介绍中讨论的 CFL 条件。在那个程序中，我们通过设置一个与网格宽度相匹配的时间步长来确保这一点，但是这很容易出错，因为如果我们再细化一次网格，我们也必须确保时间步长有所改变。在这里，我们自动做到了这一点：我们向一个库函数询问任何单元的最小直径。然后我们设置 $k=\frac h{c_0}$  。唯一的问题是： $h$ 到底是什么？关键是，对于波浪方程来说，这个问题确实没有好的理论。众所周知，对于由矩形组成的均匀细化网格， $h$ 是最小边长。但对于一般四边形的网格，确切的关系似乎是未知的，也就是说，不知道单元格的什么属性与CFL条件有关。问题是，CFL条件来自于对拉普拉斯矩阵最小特征值的了解，而这只能对简单结构的网格进行分析计算。

// 这一切的结果是，我们并不十分确定我们应该对 $h$ 采取什么措施。函数 GridTools::minimal_cell_diameter 计算了所有单元的最小直径。如果单元格都是正方形或立方体，那么最小边长就是最小直径除以 <code>std::sqrt(dim)</code>  。我们简单地将此概括为非均匀网格的情况，没有理论上的理由。

// 唯一的其他重大变化是我们需要建立边界质量矩阵。我们将在下文中进一步评论这个问题。

  template <int dim> 
  void TATForwardProblem<dim>::setup_system() 
  { 
    const Point<dim> center; 
    GridGenerator::hyper_ball(triangulation, center, 1.); 
    triangulation.refine_global(7); 

    time_step = GridTools::minimal_cell_diameter(triangulation) / wave_speed / 
                std::sqrt(1. * dim); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl; 

    dof_handler.distribute_dofs(fe); 

    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl 
              << std::endl; 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
    mass_matrix.reinit(sparsity_pattern); 
    laplace_matrix.reinit(sparsity_pattern); 

    MatrixCreator::create_mass_matrix(dof_handler, 
                                      QGauss<dim>(fe.degree + 1), 
                                      mass_matrix); 
    MatrixCreator::create_laplace_matrix(dof_handler, 
                                         QGauss<dim>(fe.degree + 1), 
                                         laplace_matrix); 

// 如前所述，与 step-23 的第二个区别是，我们需要建立从吸收性边界条件中生长出来的边界质量矩阵。

// 第一个观察结果是，这个矩阵比常规质量矩阵要稀疏得多，因为没有一个具有纯内部支持的形状函数对这个矩阵有贡献。因此，我们可以根据这种情况优化存储模式，建立第二个稀疏模式，只包含我们需要的非零项。这里有一个权衡：首先，我们必须要有第二个稀疏模式对象，所以这需要花费内存。其次，与该稀疏性模式相连的矩阵将更小，因此需要更少的内存；用它进行矩阵-向量乘法也会更快。然而，最后一个论点是提示规模的论点：我们主要感兴趣的不是单独对边界矩阵进行矩阵-向量运算（尽管我们需要在每个时间步长对右侧向量进行一次运算），而是主要希望将其与两个方程中的第一个方程使用的其他矩阵相加，因为这是CG方法每个迭代都要与之相乘的，即明显更频繁。现在的情况是， SparseMatrix::add 类允许将一个矩阵添加到另一个矩阵中，但前提是它们使用相同的稀疏模式（原因是我们不能在稀疏模式创建后向矩阵添加非零条目，所以我们只是要求这两个矩阵具有相同的稀疏模式）。

// 所以，我们就用这个方法吧。

    boundary_matrix.reinit(sparsity_pattern); 

// 第二件要做的事是实际建立矩阵。在这里，我们需要对单元格的面进行积分，所以首先我们需要一个能在 <code>dim-1</code> 维对象上工作的正交对象。其次，FEValues的变体FEFaceValues，正如它的名字所暗示的，它可以在面上工作。最后，其他的变量是组装机器的一部分。所有这些我们都放在大括号里，以便将这些变量的范围限制在我们真正需要它们的地方。
//然后
//组装矩阵的实际行为是相当直接的：我们在所有单元中循环，在每个单元的所有面中循环，然后只在特定的面位于域的边界时做一些事情。像这样。

    { 
      const QGauss<dim - 1> quadrature_formula(fe.degree + 1); 
      FEFaceValues<dim>     fe_values(fe, 
                                  quadrature_formula, 
                                  update_values | update_JxW_values); 

      const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
      const unsigned int n_q_points    = quadrature_formula.size(); 

      FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 

      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary()) 
            { 
              cell_matrix = 0; 

              fe_values.reinit(cell, face); 

              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    cell_matrix(i, j) += (fe_values.shape_value(i, q_point) * 
                                          fe_values.shape_value(j, q_point) * 
                                          fe_values.JxW(q_point)); 

              cell->get_dof_indices(local_dof_indices); 
              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                  boundary_matrix.add(local_dof_indices[i], 
                                      local_dof_indices[j], 
                                      cell_matrix(i, j)); 
            } 
    } 

    system_matrix.copy_from(mass_matrix); 
    system_matrix.add(time_step * time_step * theta * theta * wave_speed * 
                        wave_speed, 
                      laplace_matrix); 
    system_matrix.add(wave_speed * theta * time_step, boundary_matrix); 

    solution_p.reinit(dof_handler.n_dofs()); 
    old_solution_p.reinit(dof_handler.n_dofs()); 
    system_rhs_p.reinit(dof_handler.n_dofs()); 

    solution_v.reinit(dof_handler.n_dofs()); 
    old_solution_v.reinit(dof_handler.n_dofs()); 
    system_rhs_v.reinit(dof_handler.n_dofs()); 

    constraints.close(); 
  } 
// @sect4{TATForwardProblem::solve_p and TATForwardProblem::solve_v}  

// 下面两个函数，解决压力和速度变量的线性系统，几乎是逐字逐句地从 step-23 中提取的（除了主变量的名字从 $u$ 改为 $p$ ）。

  template <int dim> 
  void TATForwardProblem<dim>::solve_p() 
  { 
    SolverControl solver_control(1000, 1e-8 * system_rhs_p.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    cg.solve(system_matrix, solution_p, system_rhs_p, PreconditionIdentity()); 

    std::cout << "   p-equation: " << solver_control.last_step() 
              << " CG iterations." << std::endl; 
  } 

  template <int dim> 
  void TATForwardProblem<dim>::solve_v() 
  { 
    SolverControl solver_control(1000, 1e-8 * system_rhs_v.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    cg.solve(mass_matrix, solution_v, system_rhs_v, PreconditionIdentity()); 

    std::cout << "   v-equation: " << solver_control.last_step() 
              << " CG iterations." << std::endl; 
  } 

//  @sect4{TATForwardProblem::output_results}  

// 这里也是如此：该函数来自  step-23  。

  template <int dim> 
  void TATForwardProblem<dim>::output_results() const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution_p, "P"); 
    data_out.add_data_vector(solution_v, "V"); 

    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu"; 
    DataOutBase::VtkFlags vtk_flags; 
    vtk_flags.compression_level = 
      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 

//  @sect4{TATForwardProblem::run}  

// 这个做大部分工作的函数又和 step-23 中的差不多，尽管我们通过使用介绍中提到的向量G1和G2使事情变得更加清晰。与程序的整体内存消耗相比，引入几个临时向量并没有什么坏处。

// 这个函数唯一的变化是：首先，我们不必为速度 $v$ 预测初始值，因为我们知道它是零。其次，我们在构造函数中计算的检测器位置上评估解决方案。这是用 VectorTools::point_value 函数完成的。然后，这些值被写入我们在函数开始时打开的一个文件中。

  template <int dim> 
  void TATForwardProblem<dim>::run() 
  { 
    setup_system(); 

    VectorTools::project(dof_handler, 
                         constraints, 
                         QGauss<dim>(fe.degree + 1), 
                         InitialValuesP<dim>(), 
                         old_solution_p); 
    old_solution_v = 0; 

    std::ofstream detector_data("detectors.dat"); 

    Vector<double> tmp(solution_p.size()); 
    Vector<double> G1(solution_p.size()); 
    Vector<double> G2(solution_v.size()); 

    const double end_time = 0.7; 
    for (time = time_step; time <= end_time; 
         time += time_step, ++timestep_number) 
      { 
        std::cout << std::endl; 
        std::cout << "time_step " << timestep_number << " @ t=" << time 
                  << std::endl; 

        mass_matrix.vmult(G1, old_solution_p); 
        mass_matrix.vmult(tmp, old_solution_v); 
        G1.add(time_step * (1 - theta), tmp); 

        mass_matrix.vmult(G2, old_solution_v); 
        laplace_matrix.vmult(tmp, old_solution_p); 
        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp); 

        boundary_matrix.vmult(tmp, old_solution_p); 
        G2.add(wave_speed, tmp); 

        system_rhs_p = G1; 
        system_rhs_p.add(time_step * theta, G2); 

        solve_p(); 

        system_rhs_v = G2; 
        laplace_matrix.vmult(tmp, solution_p); 
        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp); 

        boundary_matrix.vmult(tmp, solution_p); 
        system_rhs_v.add(-wave_speed, tmp); 

        solve_v(); 

        output_results(); 

        detector_data << time; 
        for (unsigned int i = 0; i < detector_locations.size(); ++i) 
          detector_data << " " 
                        << VectorTools::point_value(dof_handler, 
                                                    solution_p, 
                                                    detector_locations[i]) 
                        << " "; 
        detector_data << std::endl; 

        old_solution_p = solution_p; 
        old_solution_v = solution_v; 
      } 
  } 
} // namespace Step24 

//  @sect3{The <code>main</code> function}  

// 剩下的就是程序的主要功能了。这里没有什么是在前面几个程序中没有展示过的。

int main() 
{ 
  try 
    { 
      using namespace Step24; 

      TATForwardProblem<2> forward_problem_solver; 
      forward_problem_solver.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-25.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2006 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Ivan Christov, Wolfgang Bangerth, Texas A&M University, 2006 
 */ 


// @sect3{Include files and global variables}  

// 关于包含文件的解释，读者应该参考示例程序  step-1  到  step-4  。它们的标准顺序是  <code>base</code> -- <code>lac</code> -- <code>grid</code>  --  <code>dofs</code> -- <code>fe</code> -- <code>numerics</code>  （因为每一类大致都是建立在前面的基础上），然后是一些用于文件输入/输出和字符串流的C++头文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iostream> 

// 最后一步和以前所有的程序一样。

namespace Step25 
{ 
  using namespace dealii; 
// @sect3{The <code>SineGordonProblem</code> class template}  

// 解决问题的整个算法被封装在这个类中。和以前的例子程序一样，这个类在声明时有一个模板参数，就是空间维度，这样我们就可以在一个、两个或三个空间维度上解决正弦-戈登方程。关于这个问题的独立于维度的类封装的更多信息，读者应该参考  step-3  和  step-4  。

// 与 step-23 和 step-24 相比，在程序的总体结构中没有任何值得注意的地方（当然，在各种函数的内部运作中也有！）。最明显的区别是出现了两个新的函数 <code>compute_nl_term</code> 和 <code>compute_nl_matrix</code> ，计算系统矩阵的非线性贡献和第一个方程的右手边，正如在介绍中讨论的那样。此外，我们还必须有一个向量 <code>solution_update</code> ，它包含在每个牛顿步骤中对解向量的非线性更新。

// 正如介绍中也提到的，我们在这个程序中不存储速度变量，而是质量矩阵乘以速度。这是在 <code>M_x_velocity</code> 变量中完成的（"x "是代表 "次数"）。

// 最后， <code>output_timestep_skip</code> 变量存储了在生成图形输出前每次所需的时间步数。这一点在使用精细网格（因此时间步数较小）时非常重要，在这种情况下，我们会运行大量的时间步数，并创建大量的输出文件，这些文件中的解决方案在后续文件中看起来几乎是一样的。这只会堵塞我们的可视化程序，我们应该避免创建比我们真正感兴趣的更多的输出。因此，如果这个变量被设置为大于1的值 $n$ ，那么只有在每一个 $n$ 的时间步长时才会产生输出。

  template <int dim> 
  class SineGordonProblem 
  { 
  public: 
    SineGordonProblem(); 
    void run(); 

  private: 
    void         make_grid_and_dofs(); 
    void         assemble_system(); 
    void         compute_nl_term(const Vector<double> &old_data, 
                                 const Vector<double> &new_data, 
                                 Vector<double> &      nl_term) const; 
    void         compute_nl_matrix(const Vector<double> &old_data, 
                                   const Vector<double> &new_data, 
                                   SparseMatrix<double> &nl_matrix) const; 
    unsigned int solve(); 
    void         output_results(const unsigned int timestep_number) const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 
    SparseMatrix<double> mass_matrix; 
    SparseMatrix<double> laplace_matrix; 

    const unsigned int n_global_refinements; 

    double       time; 
    const double final_time, time_step; 
    const double theta; 

    Vector<double> solution, solution_update, old_solution; 
    Vector<double> M_x_velocity; 
    Vector<double> system_rhs; 

    const unsigned int output_timestep_skip; 
  }; 
// @sect3{Initial conditions}  

// 在下面两类中，我们首先实现了本程序介绍中提到的一维、二维和三维的精确解。如果想通过比较数值解和分析解来测试程序的准确性，那么这个时空解可能会有独立的意义（但是请注意，程序使用的是有限域，而这些是无界域的分析解）。例如，这可以用 VectorTools::integrate_difference 函数来完成。再次注意（正如在 step-23 中已经讨论过的），我们如何将时空函数描述为依赖于时间变量的空间函数，该变量可以使用FunctionTime基类的 FunctionTime::set_time() 和 FunctionTime::get_time() 成员函数进行设置和查询。

  template <int dim> 
  class ExactSolution : public Function<dim> 
  { 
  public: 
    ExactSolution(const unsigned int n_components = 1, const double time = 0.) 
      : Function<dim>(n_components, time) 
    {} 

    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      const double t = this->get_time(); 

      switch (dim) 
        { 
          case 1: 
            { 
              const double m  = 0.5; 
              const double c1 = 0.; 
              const double c2 = 0.; 
              return -4. * std::atan(m / std::sqrt(1. - m * m) * 
                                     std::sin(std::sqrt(1. - m * m) * t + c2) / 
                                     std::cosh(m * p[0] + c1)); 
            } 

          case 2: 
            { 
              const double theta  = numbers::PI / 4.; 
              const double lambda = 1.; 
              const double a0     = 1.; 
              const double s      = 1.; 
              const double arg    = p[0] * std::cos(theta) + 
                                 std::sin(theta) * (p[1] * std::cosh(lambda) + 
                                                    t * std::sinh(lambda)); 
              return 4. * std::atan(a0 * std::exp(s * arg)); 
            } 

          case 3: 
            { 
              const double theta = numbers::PI / 4; 
              const double phi   = numbers::PI / 4; 
              const double tau   = 1.; 
              const double c0    = 1.; 
              const double s     = 1.; 
              const double arg   = p[0] * std::cos(theta) + 
                                 p[1] * std::sin(theta) * std::cos(phi) + 
                                 std::sin(theta) * std::sin(phi) * 
                                   (p[2] * std::cosh(tau) + t * std::sinh(tau)); 
              return 4. * std::atan(c0 * std::exp(s * arg)); 
            } 

          default: 
            Assert(false, ExcNotImplemented()); 
            return -1e8; 
        } 
    } 
  }; 

// 在本节的第二部分，我们提供初始条件。我们很懒惰（也很谨慎），不想第二次实现与上面相同的函数。相反，如果我们被查询到初始条件，我们会创建一个对象 <code>ExactSolution</code> ，将其设置为正确的时间，并让它计算当时的精确解的任何值。

  template <int dim> 
  class InitialValues : public Function<dim> 
  { 
  public: 
    InitialValues(const unsigned int n_components = 1, const double time = 0.) 
      : Function<dim>(n_components, time) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override 
    { 
      return ExactSolution<dim>(1, this->get_time()).value(p, component); 
    } 
  }; 
// @sect3{Implementation of the <code>SineGordonProblem</code> class}  

// 让我们继续讨论主类的实现，因为它实现了介绍中概述的算法。

//  @sect4{SineGordonProblem::SineGordonProblem}  

// 这是 <code>SineGordonProblem</code> 类的构造函数。它指定了所需的有限元的多项式程度，关联了一个 <code>DoFHandler</code> to the <code>triangulation</code> 对象（就像在示例程序 step-3 和 step-4 中一样），初始化了当前或初始时间、最终时间、时间步长，以及时间步长方案的 $\theta$ 值。由于我们在这里计算的解是时间周期性的，所以开始时间的实际值并不重要，我们选择它是为了让我们在一个有趣的时间开始。

// 请注意，如果我们选择显式欧拉时间步进方案（ $\theta = 0$ ），那么我们必须选择一个时间步进 $k \le h$ ，否则该方案不稳定，解中可能出现振荡。Crank-Nicolson方案（ $\theta = \frac{1}{2}$ ）和隐式Euler方案（ $\theta=1$ ）不存在这个缺陷，因为它们是无条件稳定的。然而，即使如此，时间步长也应选择在 $h$ 的数量级上，以获得一个好的解决方案。由于我们知道我们的网格是由矩形的均匀细分而来，我们可以很容易地计算出这个时间步长；如果我们有一个不同的域， step-24 中的技术使用 GridTools::minimal_cell_diameter 也是可以的。

  template <int dim> 
  SineGordonProblem<dim>::SineGordonProblem() 
    : fe(1) 
    , dof_handler(triangulation) 
    , n_global_refinements(6) 
    , time(-5.4414) 
    , final_time(2.7207) 
    , time_step(10 * 1. / std::pow(2., 1. * n_global_refinements)) 
    , theta(0.5) 
    , output_timestep_skip(1) 
  {} 
// @sect4{SineGordonProblem::make_grid_and_dofs}  

// 这个函数创建了一个 <code>dim</code> 维度的矩形网格，并对其进行了多次细化。同时，一旦自由度被集合起来， <code>SineGordonProblem</code> 类的所有矩阵和向量成员都被初始化为相应的大小。像 step-24 一样，我们使用 <code>MatrixCreator</code> 函数来生成质量矩阵 $M$ 和拉普拉斯矩阵 $A$ ，并在程序的剩余时间里将它们存储在适当的变量中。

  template <int dim> 
  void SineGordonProblem<dim>::make_grid_and_dofs() 
  { 
    GridGenerator::hyper_cube(triangulation, -10, 10); 
    triangulation.refine_global(n_global_refinements); 

    std::cout << "   Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "   Total number of cells: " << triangulation.n_cells() 
              << std::endl; 

    dof_handler.distribute_dofs(fe); 

    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
    mass_matrix.reinit(sparsity_pattern); 
    laplace_matrix.reinit(sparsity_pattern); 

    MatrixCreator::create_mass_matrix(dof_handler, 
                                      QGauss<dim>(fe.degree + 1), 
                                      mass_matrix); 
    MatrixCreator::create_laplace_matrix(dof_handler, 
                                         QGauss<dim>(fe.degree + 1), 
                                         laplace_matrix); 

    solution.reinit(dof_handler.n_dofs()); 
    solution_update.reinit(dof_handler.n_dofs()); 
    old_solution.reinit(dof_handler.n_dofs()); 
    M_x_velocity.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{SineGordonProblem::assemble_system}  

// 这个函数为牛顿方法的每次迭代组装系统矩阵和右手向量。关于系统矩阵和右手边的明确公式，读者应该参考导论。

// 请注意，在每个时间步长中，我们必须把对矩阵和右手边的各种贡献加起来。与 step-23 和 step-24 相比，这需要集合更多的项，因为它们取决于前一个时间步骤或前一个非线性步骤的解。我们使用函数 <code>compute_nl_matrix</code> 和 <code>compute_nl_term</code> 来做到这一点，而本函数提供了顶层逻辑。

  template <int dim> 
  void SineGordonProblem<dim>::assemble_system() 
  { 

// 首先我们组装雅各布矩阵 $F'_h(U^{n,l})$  ，其中 $U^{n,l}$ 为方便起见被储存在向量 <code>solution</code> 中。

    system_matrix.copy_from(mass_matrix); 
    system_matrix.add(std::pow(time_step * theta, 2), laplace_matrix); 

    SparseMatrix<double> tmp_matrix(sparsity_pattern); 
    compute_nl_matrix(old_solution, solution, tmp_matrix); 
    system_matrix.add(std::pow(time_step * theta, 2), tmp_matrix); 

// 接下来我们计算右手边的向量。这只是介绍中对 $-F_h(U^{n,l})$ 的描述所暗示的矩阵-向量的组合。

    system_rhs = 0.; 

    Vector<double> tmp_vector(solution.size()); 

    mass_matrix.vmult(system_rhs, solution); 
    laplace_matrix.vmult(tmp_vector, solution); 
    system_rhs.add(std::pow(time_step * theta, 2), tmp_vector); 

    mass_matrix.vmult(tmp_vector, old_solution); 
    system_rhs.add(-1.0, tmp_vector); 
    laplace_matrix.vmult(tmp_vector, old_solution); 
    system_rhs.add(std::pow(time_step, 2) * theta * (1 - theta), tmp_vector); 

    system_rhs.add(-time_step, M_x_velocity); 

    compute_nl_term(old_solution, solution, tmp_vector); 
    system_rhs.add(std::pow(time_step, 2) * theta, tmp_vector); 

    system_rhs *= -1.; 
  } 
// @sect4{SineGordonProblem::compute_nl_term}  

// 这个函数计算向量 $S(\cdot,\cdot)$ ，它出现在分裂公式的两个方程的非线性项中。这个函数不仅简化了这个项的重复计算，而且也是我们在时间步长为隐式时使用的非线性迭代求解器的基本组成部分（即 $\theta\ne 0$  ）。此外，我们必须允许该函数接收一个 "旧 "和一个 "新 "的解决方案作为输入。这些可能不是存储在 <code>old_solution</code> and <code>solution</code> 中的问题的实际解决方案，而只是我们线性化的两个函数。为了这个函数的目的，让我们在下面这个类的文档中分别调用前两个参数  $w_{\mathrm{old}}$  和  $w_{\mathrm{new}}$  。

// 作为一个旁注，也许值得研究一下什么阶次的正交公式最适合这种类型的积分。由于 $\sin(\cdot)$ 不是一个多项式，可能没有正交公式可以准确地积分这些项。通常只需确保右手边的积分达到与离散化方案相同的精度即可，但通过选择更精确的正交公式，也许可以改善渐近收敛声明中的常数。

  template <int dim> 
  void SineGordonProblem<dim>::compute_nl_term(const Vector<double> &old_data, 
                                               const Vector<double> &new_data, 
                                               Vector<double> &nl_term) const 
  { 
    nl_term = 0; 
    const QGauss<dim> quadrature_formula(fe.degree + 1); 
    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_JxW_values | 
                              update_quadrature_points); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double>                       local_nl_term(dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    std::vector<double>                  old_data_values(n_q_points); 
    std::vector<double>                  new_data_values(n_q_points); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        local_nl_term = 0; 

// 一旦我们将 <code>FEValues</code> 实例化重新初始化到当前单元格，我们就利用 <code>get_function_values</code> 例程来获取 "旧 "数据（大概在 $t=t_{n-1}$ ）和 "新 "数据（大概在 $t=t_n$ ）在所选正交公式节点的值。

        fe_values.reinit(cell); 
        fe_values.get_function_values(old_data, old_data_values); 
        fe_values.get_function_values(new_data, new_data_values); 

// 现在，我们可以用所需的正交公式来评估  $\int_K \sin\left[\theta w_{\mathrm{new}} + (1-\theta) w_{\mathrm{old}}\right] \,\varphi_j\,\mathrm{d}x$  。

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            local_nl_term(i) += 
              (std::sin(theta * new_data_values[q_point] + 
                        (1 - theta) * old_data_values[q_point]) * 
               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point)); 

// 我们通过将各单元的积分对全局积分的贡献相加来得出结论。

        cell->get_dof_indices(local_dof_indices); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          nl_term(local_dof_indices[i]) += local_nl_term(i); 
      } 
  } 
// @sect4{SineGordonProblem::compute_nl_matrix}  

// 这是处理非线性方案的第二个函数。它计算矩阵  $N(\cdot,\cdot)$  ，它出现在  $F(\cdot)$  的雅各布项的非线性项中。正如 <code>compute_nl_term</code> 一样，我们必须让这个函数接收一个 "旧 "和一个 "新 "的解决方案作为输入，我们再次将其分别称为 $w_{\mathrm{old}}$ 和 $w_{\mathrm{new}}$ ，如下。

  template <int dim> 
  void SineGordonProblem<dim>::compute_nl_matrix( 
    const Vector<double> &old_data, 
    const Vector<double> &new_data, 
    SparseMatrix<double> &nl_matrix) const 
  { 
    QGauss<dim>   quadrature_formula(fe.degree + 1); 
    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_JxW_values | 
                              update_quadrature_points); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> local_nl_matrix(dofs_per_cell, dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    std::vector<double>                  old_data_values(n_q_points); 
    std::vector<double>                  new_data_values(n_q_points); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        local_nl_matrix = 0; 

// 同样，首先我们将我们的 <code>FEValues</code> 实例化重新初始化为当前单元。

        fe_values.reinit(cell); 
        fe_values.get_function_values(old_data, old_data_values); 
        fe_values.get_function_values(new_data, new_data_values); 

// 然后，我们用所需的正交公式评估 $\int_K \cos\left[\theta w_{\mathrm{new}} + (1-\theta) w_{\mathrm{old}}\right]\, \varphi_i\, \varphi_j\,\mathrm{d}x$ 。

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              local_nl_matrix(i, j) += 
                (std::cos(theta * new_data_values[q_point] + 
                          (1 - theta) * old_data_values[q_point]) * 
                 fe_values.shape_value(i, q_point) * 
                 fe_values.shape_value(j, q_point) * fe_values.JxW(q_point)); 

// 最后，我们将各单元的积分对全局积分的贡献相加。

        cell->get_dof_indices(local_dof_indices); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            nl_matrix.add(local_dof_indices[i], 
                          local_dof_indices[j], 
                          local_nl_matrix(i, j)); 
      } 
  } 

//  @sect4{SineGordonProblem::solve}  

// 正如在介绍中所讨论的，这个函数在线性方程组上使用CG迭代求解器，该方程组是由牛顿方法的每个迭代的有限元空间离散化产生的，用于分割公式中的（非线性）第一个方程。该系统的解实际上是 $\delta U^{n,l}$ ，所以它被存储在 <code>solution_update</code> and used to update <code>solution</code> 的 <code>run</code> 函数中。

// 注意，我们在求解前将解的更新值重新设置为零。这是没有必要的：迭代求解器可以从任何一点开始并收敛到正确的解。如果对线性系统的解有一个很好的估计，那么从这个向量开始可能是值得的，但是作为一个一般的观察，起点并不是很重要：它必须是一个非常非常好的猜测，以减少超过几个迭代的次数。事实证明，对于这个问题，使用之前的非线性更新作为起点实际上会损害收敛性并增加所需的迭代次数，所以我们简单地将其设置为零。

// 该函数返回收敛到一个解决方案所需的迭代次数。这个数字以后将被用来在屏幕上生成输出，显示每次非线性迭代需要多少次迭代。

  template <int dim> 
  unsigned int SineGordonProblem<dim>::solve() 
  { 
    SolverControl            solver_control(1000, 1e-12 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution_update, system_rhs, preconditioner); 

    return solver_control.last_step(); 
  } 
// @sect4{SineGordonProblem::output_results}  

// 这个函数将结果输出到一个文件。它与  step-23  和  step-24  中的相应函数基本相同。

  template <int dim> 
  void SineGordonProblem<dim>::output_results( 
    const unsigned int timestep_number) const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "u"); 
    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu"; 
    DataOutBase::VtkFlags vtk_flags; 
    vtk_flags.compression_level = 
      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed; 
    data_out.set_flags(vtk_flags); 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 
// @sect4{SineGordonProblem::run}  

// 这个函数对一切都有最高级别的控制：它运行（外部）时间步长循环，（内部）非线性求解器循环，并在每个时间步长后输出解。

  template <int dim> 
  void SineGordonProblem<dim>::run() 
  { 
    make_grid_and_dofs(); 

// 为了确认初始条件，我们必须使用函数  $u_0(x)$  来计算  $U^0$  。为此，下面我们将创建一个 <code>InitialValues</code> 类型的对象；注意，当我们创建这个对象（它来自 <code>Function</code> 类）时，我们将其内部的时间变量设置为 $t_0$ ，以表明初始条件是在 $t=t_0$ 处评估的空间和时间的函数。

// 然后我们通过使用 <code>VectorTools::project</code> 将 $u_0(x)$ 投影到网格上，产生 $U^0$ 。我们必须使用与 step-21 相同的悬挂节点约束结构： VectorTools::project 函数需要一个悬挂节点约束对象，但为了使用它，我们首先需要关闭它。

    { 
      AffineConstraints<double> constraints; 
      constraints.close(); 
      VectorTools::project(dof_handler, 
                           constraints, 
                           QGauss<dim>(fe.degree + 1), 
                           InitialValues<dim>(1, time), 
                           solution); 
    } 

// 为了完整起见，我们像其他时间步长一样，将第2个时间步长输出到一个文件。

    output_results(0); 

// 现在我们进行时间步进：在每个时间步进中，我们解决与问题的有限元离散化相对应的矩阵方程，然后根据我们在介绍中讨论的时间步进公式推进我们的解决方案。

    unsigned int timestep_number = 1; 
    for (time += time_step; time <= final_time; 
         time += time_step, ++timestep_number) 
      { 
        old_solution = solution; 

        std::cout << std::endl 
                  << "Time step #" << timestep_number << "; " 
                  << "advancing to t = " << time << "." << std::endl; 

// 在每个时间步长的开始，我们必须通过牛顿方法求解拆分公式中的非线性方程---即先求解 $\delta U^{n,l}$ ，然后再计算 $U^{n,l+1}$ ，如此反复。这种非线性迭代的停止标准是： $\|F_h(U^{n,l})\|_2 \le 10^{-6} \|F_h(U^{n,0})\|_2$  。因此，我们需要记录第一次迭代中残差的规范。

// 在每次迭代结束时，我们向控制台输出我们花了多少次线性求解器的迭代。当下面的循环完成后，我们有（一个近似的） $U^n$  。

        double initial_rhs_norm = 0.; 
        bool   first_iteration  = true; 
        do 
          { 
            assemble_system(); 

            if (first_iteration == true) 
              initial_rhs_norm = system_rhs.l2_norm(); 

            const unsigned int n_iterations = solve(); 

            solution += solution_update; 

            if (first_iteration == true) 
              std::cout << "    " << n_iterations; 
            else 
              std::cout << '+' << n_iterations; 
            first_iteration = false; 
          } 
        while (system_rhs.l2_norm() > 1e-6 * initial_rhs_norm); 

        std::cout << " CG iterations per nonlinear step." << std::endl; 

// 在得到问题的第一个方程 $t=t_n$ 的解后，我们必须更新辅助速度变量  $V^n$  。然而，我们不计算和存储 $V^n$ ，因为它不是我们在问题中直接使用的数量。因此，为了简单起见，我们直接更新 $MV^n$ 。

        Vector<double> tmp_vector(solution.size()); 
        laplace_matrix.vmult(tmp_vector, solution); 
        M_x_velocity.add(-time_step * theta, tmp_vector); 

        laplace_matrix.vmult(tmp_vector, old_solution); 
        M_x_velocity.add(-time_step * (1 - theta), tmp_vector); 

        compute_nl_term(old_solution, solution, tmp_vector); 
        M_x_velocity.add(-time_step, tmp_vector); 

// 很多时候，特别是对于细网格，我们必须选择相当小的时间步长，以使方案稳定。因此，有很多时间步长，在解的过程中 "没有什么有趣的事情发生"。为了提高整体效率--特别是加快程序速度和节省磁盘空间--我们每隔 <code>output_timestep_skip</code> 个时间步数才输出解。

        if (timestep_number % output_timestep_skip == 0) 
          output_results(timestep_number); 
      } 
  } 
} // namespace Step25 
// @sect3{The <code>main</code> function}  

// 这是该程序的主函数。它创建一个顶层类的对象并调用其主函数。如果在执行 <code>SineGordonProblem</code> 类的运行方法时抛出了异常，我们会在这里捕获并报告它们。关于异常的更多信息，读者应该参考  step-6  。

int main() 
{ 
  try 
    { 
      using namespace Step25; 

      SineGordonProblem<1> sg_problem; 
      sg_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-26.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2013 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Texas A&M University, 2013 
 */ 



// 程序以通常的包含文件开始，所有这些文件你现在应该都见过了。

#include <deal.II/base/utilities.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/solution_transfer.h> 
#include <deal.II/numerics/matrix_tools.h> 

#include <fstream> 
#include <iostream> 

// 然后照例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入到我们将要工作的命名空间中。

namespace Step26 
{ 
  using namespace dealii; 
// @sect3{The <code>HeatEquation</code> class}  

// 下一个部分是这个程序的主类的声明。它沿用了以前的例子中公认的路径。如果你看过 step-6 ，例如，这里唯一值得注意的是，我们需要建立两个矩阵（质量和拉普拉斯矩阵），并保存当前和前一个时间步骤的解。然后，我们还需要存储当前时间、时间步长和当前时间步长的编号。最后一个成员变量表示介绍中讨论的theta参数，它允许我们在一个程序中处理显式和隐式欧拉方法，以及Crank-Nicolson方法和其他通用方法。

// 就成员函数而言，唯一可能的惊喜是 <code>refine_mesh</code> 函数需要最小和最大的网格细化级别的参数。这样做的目的在介绍中已经讨论过了。

  template <int dim> 
  class HeatEquation 
  { 
  public: 
    HeatEquation(); 
    void run(); 

  private: 
    void setup_system(); 
    void solve_time_step(); 
    void output_results() const; 
    void refine_mesh(const unsigned int min_grid_level, 
                     const unsigned int max_grid_level); 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> mass_matrix; 
    SparseMatrix<double> laplace_matrix; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> old_solution; 
    Vector<double> system_rhs; 

    double       time; 
    double       time_step; 
    unsigned int timestep_number; 

    const double theta; 
  }; 

//  @sect3{Equation data}  

// 在下面的类和函数中，我们实现了定义这个问题的各种数据（右手边和边界值），这些数据在这个程序中使用，我们需要函数对象。右手边的选择是在介绍的最后讨论的。对于边界值，我们选择零值，但这很容易在下面改变。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide() 
      : Function<dim>() 
      , period(0.2) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

  private: 
    const double period; 
  }; 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & p, 
                                   const unsigned int component) const 
  { 
    (void)component; 
    AssertIndexRange(component, 1); 
    Assert(dim == 2, ExcNotImplemented()); 

    const double time = this->get_time(); 
    const double point_within_period = 
      (time / period - std::floor(time / period)); 

    if ((point_within_period >= 0.0) && (point_within_period <= 0.2)) 
      { 
        if ((p[0] > 0.5) && (p[1] > -0.5)) 
          return 1; 
        else 
          return 0; 
      } 
    else if ((point_within_period >= 0.5) && (point_within_period <= 0.7)) 
      { 
        if ((p[0] > -0.5) && (p[1] > 0.5)) 
          return 1; 
        else 
          return 0; 
      } 
    else 
      return 0; 
  } 

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & /*p*/, 
                                    const unsigned int component) const 
  { 
    (void)component; 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 
    return 0; 
  } 

//  @sect3{The <code>HeatEquation</code> implementation}  

// 现在是实现主类的时候了。让我们从构造函数开始，它选择了一个线性元素，一个时间步长为1/500的常数（记得上面把右边的源的一个周期设置为0.2，所以我们用100个时间步长来解决每个周期），并通过设置  $\theta=1/2$  选择了Crank Nicolson方法.

  template <int dim> 
  HeatEquation<dim>::HeatEquation() 
    : fe(1) 
    , dof_handler(triangulation) 
    , time_step(1. / 500) 
    , theta(0.5) 
  {} 

//  @sect4{<code>HeatEquation::setup_system</code>}  

// 下一个函数是设置DoFHandler对象，计算约束，并将线性代数对象设置为正确的大小。我们还在这里通过简单地调用库中的两个函数来计算质量和拉普拉斯矩阵。

// 注意我们在组装矩阵时不考虑悬挂节点的约束（两个函数都有一个AffineConstraints参数，默认为一个空对象）。这是因为我们要在结合当前时间步长的矩阵后，在run()中浓缩约束。

  template <int dim> 
  void HeatEquation<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 

    std::cout << std::endl 
              << "===========================================" << std::endl 
              << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl 
              << std::endl; 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    constraints, 
                                    /*keep_constrained_dofs =  */ true);

    sparsity_pattern.copy_from(dsp); 

    mass_matrix.reinit(sparsity_pattern); 
    laplace_matrix.reinit(sparsity_pattern); 
    system_matrix.reinit(sparsity_pattern); 

    MatrixCreator::create_mass_matrix(dof_handler, 
                                      QGauss<dim>(fe.degree + 1), 
                                      mass_matrix); 
    MatrixCreator::create_laplace_matrix(dof_handler, 
                                         QGauss<dim>(fe.degree + 1), 
                                         laplace_matrix); 

    solution.reinit(dof_handler.n_dofs()); 
    old_solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{<code>HeatEquation::solve_time_step</code>}  

// 下一个函数是解决单个时间步骤的实际线性系统的函数。这里没有什么值得惊讶的。

  template <int dim> 
  void HeatEquation<dim>::solve_time_step() 
  { 
    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.0); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    constraints.distribute(solution); 

    std::cout << "     " << solver_control.last_step() << " CG iterations." 
              << std::endl; 
  } 

//  @sect4{<code>HeatEquation::output_results</code>}  

// 在生成图形输出方面也没有什么新东西，只是我们告诉DataOut对象当前的时间和时间步长是多少，以便将其写入输出文件中。

  template <int dim> 
  void HeatEquation<dim>::output_results() const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "U"); 

    data_out.build_patches(); 

    data_out.set_flags(DataOutBase::VtkFlags(time, timestep_number)); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtk"; 
    std::ofstream output(filename); 
    data_out.write_vtk(output); 
  } 
// @sect4{<code>HeatEquation::refine_mesh</code>}  

// 这个函数是程序中最有趣的部分。它负责自适应网格细化的工作。这个函数执行的三个任务是：首先找出需要细化/粗化的单元，然后实际进行细化，最后在两个不同的网格之间传输解向量。第一个任务是通过使用成熟的凯利误差估计器来实现的。第二项任务是实际进行再细化。这也只涉及到基本的函数，例如 <code>refine_and_coarsen_fixed_fraction</code> ，它可以细化那些具有最大估计误差的单元，这些误差加起来占60%，并粗化那些具有最小误差的单元，这些单元加起来占40%的误差。请注意，对于像当前这样的问题，即有事发生的区域正在四处移动，我们希望积极地进行粗化，以便我们能够将单元格移动到有必要的地方。

// 正如在介绍中已经讨论过的，太小的网格会导致太小的时间步长，而太大的网格会导致太小的分辨率。因此，在前两个步骤之后，我们有两个循环，将细化和粗化限制在一个允许的单元范围内。

  template <int dim> 
  void HeatEquation<dim>::refine_mesh(const unsigned int min_grid_level, 
                                      const unsigned int max_grid_level) 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_fraction(triangulation, 
                                                      estimated_error_per_cell, 
                                                      0.6, 
                                                      0.4); 

    if (triangulation.n_levels() > max_grid_level) 
      for (const auto &cell : 
           triangulation.active_cell_iterators_on_level(max_grid_level)) 
        cell->clear_refine_flag(); 
    for (const auto &cell : 
         triangulation.active_cell_iterators_on_level(min_grid_level)) 
      cell->clear_coarsen_flag(); 

// 上面这两个循环略有不同，但这很容易解释。在第一个循环中，我们没有调用  <code>triangulation.end()</code>  ，而是调用  <code>triangulation.end_active(max_grid_level)</code>  。这两个调用应该产生相同的迭代器，因为迭代器是按级别排序的，不应该有任何级别高于 <code>max_grid_level</code> 的单元格。事实上，这段代码确保了这种情况的发生。

// 作为网格细化的一部分，我们需要将旧的网格中的解向量转移到新的网格中。为此，我们使用了SolutionTransfer类，我们必须准备好需要转移到新网格的解向量（一旦完成细化，我们将失去旧的网格，所以转移必须与细化同时发生）。在我们调用这个函数的时候，我们将刚刚计算出解决方案，所以我们不再需要old_solution变量（它将在网格被细化后被解决方案覆盖，也就是在时间步长结束时；见下文）。换句话说，我们只需要一个求解向量，并将其复制到一个临时对象中，当我们进一步向下调用 <code>setup_system()</code> 时，它就不会被重置。

// 因此，我们将一个SolutionTransfer对象附加到旧的DoF处理程序中，以初始化它。然后，我们准备好三角形和数据向量，以便进行细化（按照这个顺序）。

    SolutionTransfer<dim> solution_trans(dof_handler); 

    Vector<double> previous_solution; 
    previous_solution = solution; 
    triangulation.prepare_coarsening_and_refinement(); 
    solution_trans.prepare_for_coarsening_and_refinement(previous_solution); 

// 现在一切都准备好了，所以进行细化并在新网格上重新创建DoF结构，最后在 <code>setup_system</code> 函数中初始化矩阵结构和新的向量。接下来，我们实际执行从旧网格到新网格的插值解。最后一步是对解向量应用悬空节点约束，即确保位于悬空节点上的自由度值，使解是连续的。这是必要的，因为SolutionTransfer只对单元格进行局部操作，不考虑邻域。

    triangulation.execute_coarsening_and_refinement(); 
    setup_system(); 

    solution_trans.interpolate(previous_solution, solution); 
    constraints.distribute(solution); 
  } 

//  @sect4{<code>HeatEquation::run</code>}  

// 这是程序的主要驱动，我们在这里循环所有的时间步骤。在函数的顶部，我们通过重复第一个时间步长，设置初始全局网格细化的数量和自适应网格细化的初始周期数量。然后，我们创建一个网格，初始化我们要处理的各种对象，设置一个标签，说明我们在重新运行第一个时间步长时应该从哪里开始，并将初始解插值到网格上（我们在这里选择了零函数，当然，我们可以用更简单的方法，直接将解向量设置为零）。我们还输出一次初始时间步长。

//  @note  如果你是一个有经验的程序员，你可能会对我们在这段代码中使用 <code>goto</code> 语句感到吃惊   <code>goto</code> 语句现在已经不是特别受人欢迎了，因为计算机科学界的大师之一Edsgar Dijkstra在1968年写了一封信，叫做 "Go To Statement considered harmful"（见<a href="http:en.wikipedia.org/wiki/Considered_harmful">here</a>）。这段代码的作者全心全意地赞同这一观念。  <code>goto</code> 是难以理解的。事实上，deal.II几乎不包含任何出现的情况：不包括基本上是从书本上转录的代码，也不计算重复的代码片断，在写这篇笔记时，大约60万行代码中有3个位置；我们还在4个教程程序中使用它，其背景与这里完全相同。与其在这里试图证明这种情况的出现，不如先看看代码，我们在函数的最后再来讨论这个问题。

  template <int dim> 
  void HeatEquation<dim>::run() 
  { 
    const unsigned int initial_global_refinement       = 2; 
    const unsigned int n_adaptive_pre_refinement_steps = 4; 

    GridGenerator::hyper_L(triangulation); 
    triangulation.refine_global(initial_global_refinement); 

    setup_system(); 

    unsigned int pre_refinement_step = 0; 

    Vector<double> tmp; 
    Vector<double> forcing_terms; 

  start_time_iteration: 

    time            = 0.0; 
    timestep_number = 0; 

    tmp.reinit(solution.size()); 
    forcing_terms.reinit(solution.size()); 

    VectorTools::interpolate(dof_handler, 
                             Functions::ZeroFunction<dim>(), 
                             old_solution); 
    solution = old_solution; 

    output_results(); 

// 然后我们开始主循环，直到计算的时间超过我们的结束时间0.5。第一个任务是建立我们需要在每个时间步骤中解决的线性系统的右手边。回顾一下，它包含项 $MU^{n-1}-(1-\theta)k_n AU^{n-1}$  。我们把这些项放到变量system_rhs中，借助于一个临时矢量。

    while (time <= 0.5) 
      { 
        time += time_step; 
        ++timestep_number; 

        std::cout << "Time step " << timestep_number << " at t=" << time 
                  << std::endl; 

        mass_matrix.vmult(system_rhs, old_solution); 

        laplace_matrix.vmult(tmp, old_solution); 
        system_rhs.add(-(1 - theta) * time_step, tmp); 

// 第二块是计算源项的贡献。这与术语  $k_n \left[ (1-\theta)F^{n-1} + \theta F^n \right]$  相对应。下面的代码调用  VectorTools::create_right_hand_side  来计算向量  $F$  ，在这里我们在评估之前设置了右侧（源）函数的时间。这一切的结果最终都在forcing_terms变量中。

        RightHandSide<dim> rhs_function; 
        rhs_function.set_time(time); 
        VectorTools::create_right_hand_side(dof_handler, 
                                            QGauss<dim>(fe.degree + 1), 
                                            rhs_function, 
                                            tmp); 
        forcing_terms = tmp; 
        forcing_terms *= time_step * theta; 

        rhs_function.set_time(time - time_step); 
        VectorTools::create_right_hand_side(dof_handler, 
                                            QGauss<dim>(fe.degree + 1), 
                                            rhs_function, 
                                            tmp); 

        forcing_terms.add(time_step * (1 - theta), tmp); 

// 接下来，我们将强迫项加入到来自时间步长的强迫项中，同时建立矩阵 $M+k_n\theta A$ ，我们必须在每个时间步长中进行反转。这些操作的最后一块是消除线性系统中悬挂的节点约束自由度。

        system_rhs += forcing_terms; 

        system_matrix.copy_from(mass_matrix); 
        system_matrix.add(theta * time_step, laplace_matrix); 

        constraints.condense(system_matrix, system_rhs); 

// 在解决这个问题之前，我们还需要做一个操作：边界值。为此，我们创建一个边界值对象，将适当的时间设置为当前时间步长的时间，并像以前多次那样对其进行评估。其结果也被用来在线性系统中设置正确的边界值。

        { 
          BoundaryValues<dim> boundary_values_function; 
          boundary_values_function.set_time(time); 

          std::map<types::global_dof_index, double> boundary_values; 
          VectorTools::interpolate_boundary_values(dof_handler, 
                                                   0, 
                                                   boundary_values_function, 
                                                   boundary_values); 

          MatrixTools::apply_boundary_values(boundary_values, 
                                             system_matrix, 
                                             solution, 
                                             system_rhs); 
        } 

// 有了这些，我们要做的就是解决这个系统，生成图形数据，以及......

        solve_time_step(); 

        output_results(); 

// ...负责网格的细化。在这里，我们要做的是：(i)在求解过程的最开始，细化所要求的次数，之后我们跳到顶部重新开始时间迭代，(ii)之后每隔五步细化一次。

// 时间循环和程序的主要部分以开始进入下一个时间步骤结束，将old_solution设置为我们刚刚计算出的解决方案。

        if ((timestep_number == 1) && 
            (pre_refinement_step < n_adaptive_pre_refinement_steps)) 
          { 
            refine_mesh(initial_global_refinement, 
                        initial_global_refinement + 
                          n_adaptive_pre_refinement_steps); 
            ++pre_refinement_step; 

            tmp.reinit(solution.size()); 
            forcing_terms.reinit(solution.size()); 

            std::cout << std::endl; 

            goto start_time_iteration; 
          } 
        else if ((timestep_number > 0) && (timestep_number % 5 == 0)) 
          { 
            refine_mesh(initial_global_refinement, 
                        initial_global_refinement + 
                          n_adaptive_pre_refinement_steps); 
            tmp.reinit(solution.size()); 
            forcing_terms.reinit(solution.size()); 
          } 

        old_solution = solution; 
      } 
  } 
} // namespace Step26 

// 现在你已经看到了这个函数的作用，让我们再来看看  <code>goto</code>  的问题。从本质上讲，代码所做的事情是这样的。
// @code
//    void run ()
//    {
//      initialize;
//    start_time_iteration:
//      for (timestep=1...)
//      {
//         solve timestep;
//         if (timestep==1 && not happy with the result)
//         {
//           adjust some data structures;
//           goto start_time_iteration; simply try again
//         }
//         postprocess;
//      }
//    }
//  @endcode 
//  这里，"对结果满意 "的条件是我们想保留当前的网格，还是宁愿细化网格并在新网格上重新开始。我们当然可以用下面的方法来取代  <code>goto</code>  的使用。
//  @code
//    void run ()
//    {
//      initialize;
//      while (true)
//      {
//         solve timestep;
//         if (not happy with the result)
//            adjust some data structures;
//         else
//            break;
//      }
//      postprocess;


//      for (timestep=2...)
//      {
//         solve timestep;
//         postprocess;
//      }
//    }
//  @endcode 
//  这样做的好处是摆脱了 <code>goto</code> ，但缺点是必须在两个不同的地方重复实现 "解算时间步长 "和 "后处理 "操作的代码。这可以通过将这些部分的代码（在上面的实际实现中是相当大的块）放到自己的函数中来解决，但是一个带有 <code>break</code> 语句的 <code>while(true)</code> 循环并不真的比 <code>goto</code> 容易阅读或理解。

// 最后，人们可能会简单地同意，<i>in general</i> 。
// <code>goto</code>  语句是个坏主意，但要务实地指出，在某些情况下，它们可以帮助避免代码重复和尴尬的控制流。这可能就是其中之一，它与Steve McConnell在他关于良好编程实践的优秀书籍 "Code Complete"  @cite CodeComplete 中采取的立场一致（见 step-1 的介绍中提到的这本书），该书花了惊人的10页来讨论一般的 <code>goto</code> 问题。

//  @sect3{The <code>main</code> function}  

// 走到这一步，这个程序的主函数又没有什么好讨论的了：它看起来就像自 step-6 以来的所有此类函数一样。

int main() 
{ 
  try 
    { 
      using namespace Step26; 

      HeatEquation<2> heat_equation_solver; 
      heat_equation_solver.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-27.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2006 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Wolfgang Bangerth, Texas A&M University, 2006, 2007; 
 *          Denis Davydov, University of Erlangen-Nuremberg, 2016; 
 *          Marc Fehling, Colorado State University, 2020. 
 */ 


// @sect3{Include files}  

// 前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 这些是我们需要的新文件。第一个和第二个提供了FECollection和<i>hp</i>版本的FEValues类，如本程序介绍中所述。下一个文件提供了自动 $hp$ 适应的功能，为此我们将使用基于衰减系列扩展系数的估计算法，这是最后两个文件的一部分。

#include <deal.II/hp/fe_collection.h> 
#include <deal.II/hp/fe_values.h> 
#include <deal.II/hp/refinement.h> 
#include <deal.II/fe/fe_series.h> 
#include <deal.II/numerics/smoothness_estimator.h> 

// 最后一组包含文件是标准的C++头文件。

#include <fstream> 
#include <iostream> 

// 最后，这和以前的程序一样。

namespace Step27 
{ 
  using namespace dealii; 
// @sect3{The main class}  

// 这个程序的主类看起来非常像前几个教程程序中已经使用过的，例如  step-6  中的那个。主要的区别是我们将refine_grid和output_results函数合并为一个，因为我们还想输出一些用于决定如何细化网格的量（特别是估计的解决方案的平滑度）。

// 就成员变量而言，我们使用与 step-6 中相同的结构，但我们需要集合来代替单个的有限元、正交和面状正交对象。我们将在类的构造函数中填充这些集合。最后一个变量， <code>max_degree</code> ，表示所用形状函数的最大多项式程度。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(); 
    ~LaplaceProblem(); 

    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void create_coarse_grid(); 
    void postprocess(const unsigned int cycle); 

    Triangulation<dim> triangulation; 

 
 
    hp::QCollection<dim>     quadrature_collection; 
    hp::QCollection<dim - 1> face_quadrature_collection; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    const unsigned int max_degree; 
  }; 

//  @sect3{Equation data}  

// 接下来，让我们为这个问题定义右手边的函数。它在1d中是 $x+1$ ，在2d中是 $(x+1)(y+1)$ ，以此类推。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component) const override; 
  }; 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> &p, 
                                   const unsigned int /*component*/) const 
  { 
    double product = 1; 
    for (unsigned int d = 0; d < dim; ++d) 
      product *= (p[d] + 1); 
    return product; 
  } 

//  @sect3{Implementation of the main class}  
// @sect4{LaplaceProblem::LaplaceProblem constructor}  

// 这个类的构造函数是相当直接的。它将DoFHandler对象与三角形相关联，然后将最大多项式度数设置为7（在1d和2d中）或5（在3d及以上）。我们这样做是因为使用高阶多项式度数会变得非常昂贵，尤其是在更高的空间维度上。

// 在这之后，我们填充有限元、单元和面的四分法对象集合。我们从二次元开始，每个正交公式的选择都是为了适合 hp::FECollection 对象中的匹配有限元。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem() 
    : dof_handler(triangulation) 
    , max_degree(dim <= 2 ? 7 : 5) 
  { 
    for (unsigned int degree = 2; degree <= max_degree; ++degree) 
      { 
        fe_collection.push_back(FE_Q<dim>(degree)); 
        quadrature_collection.push_back(QGauss<dim>(degree + 1)); 
        face_quadrature_collection.push_back(QGauss<dim - 1>(degree + 1)); 
      } 
  } 
// @sect4{LaplaceProblem::~LaplaceProblem destructor}  

// 解构器与我们在  step-6  中已经做过的没有变化。

  template <int dim> 
  LaplaceProblem<dim>::~LaplaceProblem() 
  { 
    dof_handler.clear(); 
  } 
// @sect4{LaplaceProblem::setup_system}  

// 这个函数又是对我们在  step-6  中已经做过的事情的逐字复制。尽管函数调用的名称和参数完全相同，但内部使用的算法在某些方面是不同的，因为这里的dof_handler变量是在  $hp$  -mode。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe_collection); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
  } 

//  @sect4{LaplaceProblem::assemble_system}  

// 这是一个从每个单元的局部贡献中集合全局矩阵和右侧向量的函数。它的主要工作与之前许多教程中描述的一样。重要的差异是<i>hp</i>有限元方法所需要的。特别是，我们需要使用FEValues对象的集合（通过 hp::FEValues 类实现），并且在将局部贡献复制到全局对象时，我们必须消除受限自由度。这两点在本程序的介绍中都有详细解释。

// 还有一个小问题是，由于我们在不同的单元格中使用了不同的多项式度数，持有局部贡献的矩阵和向量在所有单元格中的大小不尽相同。因此，在所有单元的循环开始时，我们每次都必须将它们的大小调整到正确的大小（由 <code>dofs_per_cell</code> 给出）。因为这些类的实现方式是减少矩阵或向量的大小不会释放当前分配的内存（除非新的大小为零），所以在循环开始时调整大小的过程只需要在最初几次迭代中重新分配内存。一旦我们在一个单元中找到了最大的有限元度，就不会再发生重新分配，因为所有后续的 <code>reinit</code> 调用只会将大小设置为适合当前分配的内存。这一点很重要，因为分配内存是很昂贵的，而且每次我们访问一个新的单元时都这样做会花费大量的计算时间。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_system() 
  { 
    hp::FEValues<dim> hp_fe_values(fe_collection, 
                                   quadrature_collection, 
                                   update_values | update_gradients | 
                                     update_quadrature_points | 
                                     update_JxW_values); 

    RightHandSide<dim> rhs_function; 

    FullMatrix<double> cell_matrix; 
    Vector<double>     cell_rhs; 

    std::vector<types::global_dof_index> local_dof_indices; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell(); 

        cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 
        cell_matrix = 0; 

        cell_rhs.reinit(dofs_per_cell); 
        cell_rhs = 0; 

        hp_fe_values.reinit(cell); 

        const FEValues<dim> &fe_values = hp_fe_values.get_present_fe_values(); 

        std::vector<double> rhs_values(fe_values.n_quadrature_points); 
        rhs_function.value_list(fe_values.get_quadrature_points(), rhs_values); 

        for (unsigned int q_point = 0; q_point < fe_values.n_quadrature_points; 
             ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                cell_matrix(i, j) += 
                  (fe_values.shape_grad(i, q_point) * // grad phi_i(x_q) 
                   fe_values.shape_grad(j, q_point) * // grad phi_j(x_q) 
                   fe_values.JxW(q_point));           // dx 

              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q) 
                              rhs_values[q_point] *               // f(x_q) 
                              fe_values.JxW(q_point));            // dx 
            } 

        local_dof_indices.resize(dofs_per_cell); 
        cell->get_dof_indices(local_dof_indices); 

        constraints.distribute_local_to_global( 
          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); 
      } 
  } 

//  @sect4{LaplaceProblem::solve}  

// 解决线性系统的函数与之前的例子完全没有变化。我们只是试图将初始残差（相当于右手边的 $l_2$ 准则）减少一定的系数。

  template <int dim> 
  void LaplaceProblem<dim>::solve() 
  { 
    SolverControl            solver_control(system_rhs.size(), 
                                 1e-12 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    constraints.distribute(solution); 
  } 

//  @sect4{LaplaceProblem::postprocess}  

// 解完线性系统后，我们要对解进行后处理。在这里，我们所做的就是估计误差，估计解的局部平滑度，如介绍中所述，然后写出图形输出，最后根据之前计算的指标细化 $h$ 和 $p$ 中的网格。我们在同一个函数中完成这一切，因为我们希望估计的误差和平滑度指标不仅用于细化，而且还包括在图形输出中。

  template <int dim> 
  void LaplaceProblem<dim>::postprocess(const unsigned int cycle) 
  { 

// 让我们开始计算估计的误差和平滑度指标，这两个指标对于我们三角测量的每个活动单元来说都是一个数字。对于误差指标，我们一如既往地使用KellyErrorEstimator类。

    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      face_quadrature_collection, 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      estimated_error_per_cell); 

// 估计平滑度是用介绍中所述的衰减膨胀系数的方法进行的。我们首先需要创建一个对象，能够将每一个单元上的有限元解转化为一串傅里叶级数系数。SmoothnessEstimator命名空间为这样一个 FESeries::Fourier 对象提供了一个工厂函数，它为估计平滑度的过程进行了优化。然后在最后一个函数中实际确定每个单独单元上的傅里叶系数的衰减情况。

    Vector<float> smoothness_indicators(triangulation.n_active_cells()); 
    FESeries::Fourier<dim> fourier = 
      SmoothnessEstimator::Fourier::default_fe_series(fe_collection); 
    SmoothnessEstimator::Fourier::coefficient_decay(fourier, 
                                                    dof_handler, 
                                                    solution, 
                                                    smoothness_indicators); 

// 接下来我们要生成图形输出。除了上面得出的两个估计量之外，我们还想输出网格上每个元素所使用的有限元的多项式程度。

// 要做到这一点，我们需要在所有单元上循环，用  <code>cell-@>active_fe_index()</code>  轮询它们的活动有限元索引。然后我们使用这个操作的结果，在有限元集合中查询具有该索引的有限元，最后确定该元素的多项式程度。我们将结果放入一个矢量，每个单元有一个元素。DataOut类要求这是一个 <code>float</code> or <code>double</code> 的向量，尽管我们的值都是整数，所以我们就用这个向量。

    { 
      Vector<float> fe_degrees(triangulation.n_active_cells()); 
      for (const auto &cell : dof_handler.active_cell_iterators()) 
        fe_degrees(cell->active_cell_index()) = 
          fe_collection[cell->active_fe_index()].degree; 

// 现在有了所有的数据向量--解决方案、估计误差和平滑度指标以及有限元度--我们创建一个用于图形输出的DataOut对象并附加所有数据。

      DataOut<dim> data_out; 

      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution, "solution"); 
      data_out.add_data_vector(estimated_error_per_cell, "error"); 
      data_out.add_data_vector(smoothness_indicators, "smoothness"); 
      data_out.add_data_vector(fe_degrees, "fe_degree"); 
      data_out.build_patches(); 

// 生成输出的最后一步是确定一个文件名，打开文件，并将数据写入其中（这里，我们使用VTK格式）。

      const std::string filename = 
        "solution-" + Utilities::int_to_string(cycle, 2) + ".vtk"; 
      std::ofstream output(filename); 
      data_out.write_vtk(output); 
    } 

// 在这之后，我们想在 $h$ 和 $p$ 两个地方实际细化网格。我们要做的是：首先，我们用估计的误差来标记那些误差最大的单元，以便进行细化。这就是我们一直以来的做法。

    { 
      GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                      estimated_error_per_cell, 
                                                      0.3, 
                                                      0.03); 

// 接下来我们要弄清楚哪些被标记为细化的单元格实际上应该增加 $p$ 而不是减少 $h$ 。我们在这里选择的策略是，我们查看那些被标记为细化的单元格的平滑度指标，并为那些平滑度大于某个相对阈值的单元格增加 $p$ 。换句话说，对于每一个(i)细化标志被设置，(ii)平滑度指标大于阈值，以及(iii)我们在有限元集合中仍有一个多项式度数高于当前度数的有限元的单元，我们将分配一个未来的FE指数，对应于一个比当前度数高一的多项式。下面的函数正是能够做到这一点。在没有更好的策略的情况下，我们将通过在标记为细化的单元上的最小和最大平滑度指标之间进行插值来设置阈值。由于角部奇点具有很强的局部性，我们将支持 $p$ 。

// - 而不是 $h$  - 精细化的数量。我们通过设置0.2的小插值系数，以低门槛实现这一点。用同样的方法，我们处理那些要被粗化的单元，当它们的平滑度指标低于在要粗化的单元上确定的相应阈值时，减少它们的多项式程度。

      hp::Refinement::p_adaptivity_from_relative_threshold( 
        dof_handler, smoothness_indicators, 0.2, 0.2); 

// 上面的函数只决定了多项式程度是否会通过未来的FE指数发生变化，但并没有操作 $h$  -细化标志。因此，对于被标记为两个细化类别的单元格，我们更倾向于 $p$  。

// 而不是 $h$  -细化。下面的函数调用确保只有 $p$ 中的一个

// - 或  $h$  - 精炼中的一种，而不是同时实施两种。

      hp::Refinement::choose_p_over_h(dof_handler); 

// 对于网格自适应细化，我们通过调用 Triangulation::prepare_coarsening_and_refinement(). 将相邻单元的细化水平差限制为1来确保2:1的网格平衡。 我们希望对相邻单元的p水平实现类似的效果：未来有限元的水平差不允许超过指定的差。通过其默认参数，调用 hp::Refinement::limit_p_level_difference() 可以确保它们的级差被限制在1以内。这不一定会减少域中的悬挂节点的数量，但可以确保高阶多项式不会被限制在面的低得多的多项式上，例如五阶多项式到二阶多项式。

      triangulation.prepare_coarsening_and_refinement(); 
      hp::Refinement::limit_p_level_difference(dof_handler); 

// 在这个过程结束后，我们再细化网格。在这个过程中，正在进行分割的单元的子单元会继承其母单元的有限元索引。此外，未来的有限元指数将变成活动的，因此新的有限元将在下一次调用 DoFHandler::distribute_dofs(). 后被分配给单元。
      triangulation.execute_coarsening_and_refinement(); 
    } 
  } 
// @sect4{LaplaceProblem::create_coarse_grid}  

// 在创建初始网格时，会用到下面这个函数。我们想要创建的网格实际上与 step-14 中的网格类似，即中间有方孔的方形域。它可以由完全相同的函数生成。然而，由于它的实现只是2d情况下的一种特殊化，我们将介绍一种不同的方法来创建这个域，它是独立于维度的。

// 我们首先创建一个有足够单元的超立方体三角形，这样它就已经包含了我们想要的域 $[-1,1]^d$ ，并细分为 $4^d$ 单元。然后，我们通过测试每个单元上顶点的坐标值来移除域中心的那些单元。最后，我们像往常一样对如此创建的网格进行全局细化。

  template <int dim> 
  void LaplaceProblem<dim>::create_coarse_grid() 
  { 
    Triangulation<dim> cube; 
    GridGenerator::subdivided_hyper_cube(cube, 4, -1., 1.); 

    std::set<typename Triangulation<dim>::active_cell_iterator> cells_to_remove; 
    for (const auto &cell : cube.active_cell_iterators()) 
      for (unsigned int v = 0; v < GeometryInfo<dim>::vertices_per_cell; ++v) 
        if (cell->vertex(v).square() < .1) 
          cells_to_remove.insert(cell); 

    GridGenerator::create_triangulation_with_removed_cells(cube, 
                                                           cells_to_remove, 
                                                           triangulation); 

    triangulation.refine_global(3); 
  } 

//  @sect4{LaplaceProblem::run}  

// 这个函数实现了程序的逻辑，就像以前大多数程序中的相应函数一样，例如见  step-6  。

// 基本上，它包含了自适应循环：在第一次迭代中创建一个粗略的网格，然后建立线性系统，对其进行组合，求解，并对解进行后处理，包括网格细化。然后再重新开始。同时，也为那些盯着屏幕试图弄清楚程序是干什么的人输出一些信息。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 6; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          create_coarse_grid(); 

        setup_system(); 

        std::cout << "   Number of active cells      : " 
                  << triangulation.n_active_cells() << std::endl 
                  << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
                  << std::endl 
                  << "   Number of constraints       : " 
                  << constraints.n_constraints() << std::endl; 

        assemble_system(); 
        solve(); 
        postprocess(cycle); 
      } 
  } 
} // namespace Step27 
// @sect3{The main function}  

// 主函数仍然是我们之前的版本：将创建和运行一个主类的对象包装成一个 <code>try</code> 块，并捕捉任何抛出的异常，从而在出现问题时产生有意义的输出。

int main() 
{ 
  try 
    { 
      using namespace Step27; 

      LaplaceProblem<2> laplace_problem; 
      laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-28.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Yaqi Wang, Texas A&M University, 2009, 2010 
 */ 


// @sect3{Include files}  

// 我们从一堆包含文件开始，这些文件已经在以前的教程程序中解释过了。一个新的文件是  <code>timer.h</code>  : 这是第一个使用Timer类的例子程序。Timer同时记录了经过的挂钟时间（即安装在墙上的时钟所测量的时间）和CPU时钟时间（当前进程在CPU上使用的时间）。我们将在下面使用一个Timer来测量每个网格细化周期所需的CPU时间。

#include <deal.II/base/timer.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/parameter_handler.h> 
#include <deal.II/base/thread_management.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparsity_pattern.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <fstream> 
#include <iostream> 

// 我们使用下一个include文件来访问块向量，它为我们提供了一种方便的方式来管理所有能量组的解和右手向量。

#include <deal.II/lac/block_vector.h> 

// 这个文件是用来将解从一个网格转移到另一个不同的网格。我们在每次网格迭代后初始化解法时使用它。

#include <deal.II/numerics/solution_transfer.h> 

// 当在一个网格上定义的函数与另一个网格上定义的形状函数进行整合时，我们需要一个函数  @p get_finest_common_cells  (在介绍中已经讨论过)，它定义在以下头文件中。

#include <deal.II/grid/grid_tools.h> 

// 我们使用一个来自boost的小工具类来保存输出流的状态（见下面的 <code>run</code> 函数）。

#include <boost/io/ios_state.hpp> 

// 这里还有两个C++标准头，我们用它们来定义列表数据类型，以及微调我们生成的输出。

#include <list> 
#include <iomanip> 

// 最后一步和以前所有的程序一样。

namespace Step28 
{ 
  using namespace dealii; 
// @sect3{Material data}  

// 首先，我们需要定义一个类，为主类提供材料数据（包括扩散系数、清除截面、散射截面、裂变截面和裂变光谱）。

// 构造函数的参数决定了我们为多少个能量组设置了相关的表格。目前，这个程序只包括2个能量组的数据，但是一个更复杂的程序可能也能为更多的能量组初始化数据结构，这取决于在参数文件中选择了多少个能量组。

// 对于每个不同的系数类型，都有一个函数来返回该系数在特定能量组（或能量组的组合，如分布截面 $\chi_g\nu\Sigma_{f,g'}$ 或散射截面 $\Sigma_{s,g'\to g}$ ）的值。除了能量组之外，这些系数还取决于燃料或控制棒的类型，正如介绍中所解释的那样。因此，这些函数需要一个额外的参数， @p  material_id，以确定特定种类的棒。在这个程序中，我们使用 <code>n_materials=8</code> 不同种类的棒子。

// 除了散射截面，每个系数都可以表示为一个二维浮点数组中的一个条目，该数组由能量组编号以及材料ID索引。表类模板是存储此类数据的理想方式。最后，散射系数取决于两个能量组的索引，因此需要存储在一个三维数组中，为此我们再次使用表类，这时第一个模板参数（表示数组的维度）当然需要是三。

  class MaterialData 
  { 
  public: 
    MaterialData(const unsigned int n_groups); 

    double get_diffusion_coefficient(const unsigned int group, 
                                     const unsigned int material_id) const; 
    double get_removal_XS(const unsigned int group, 
                          const unsigned int material_id) const; 
    double get_fission_XS(const unsigned int group, 
                          const unsigned int material_id) const; 
    double get_fission_dist_XS(const unsigned int group_1, 
                               const unsigned int group_2, 
                               const unsigned int material_id) const; 
    double get_scattering_XS(const unsigned int group_1, 
                             const unsigned int group_2, 
                             const unsigned int material_id) const; 
    double get_fission_spectrum(const unsigned int group, 
                                const unsigned int material_id) const; 

  private: 
    const unsigned int n_groups; 
    const unsigned int n_materials; 

    Table<2, double> diffusion; 
    Table<2, double> sigma_r; 
    Table<2, double> nu_sigma_f; 
    Table<3, double> sigma_s; 
    Table<2, double> chi; 
  }; 

// 该类的构造函数用于初始化所有材料数据数组。它需要能量组的数量作为参数（如果该值不等于2，就会抛出一个错误，因为目前只实现了两个能量组的数据；但是，使用这个参数，该函数仍然是灵活的，可以扩展到未来）。在开始的成员初始化部分，它也将数组的大小调整为正确的大小。

// 目前，材料数据被存储为8种不同类型的材料。这一点在将来也可以很容易地被扩展。

  MaterialData::MaterialData(const unsigned int n_groups) 
    : n_groups(n_groups) 
    , n_materials(8) 
    , diffusion(n_materials, n_groups) 
    , sigma_r(n_materials, n_groups) 
    , nu_sigma_f(n_materials, n_groups) 
    , sigma_s(n_materials, n_groups, n_groups) 
    , chi(n_materials, n_groups) 
  { 
    switch (this->n_groups) 
      { 
        case 2: 
          { 
            for (unsigned int m = 0; m < n_materials; ++m) 
              { 
                diffusion[m][0] = 1.2; 
                diffusion[m][1] = 0.4; 
                chi[m][0]       = 1.0; 
                chi[m][1]       = 0.0; 
                sigma_r[m][0]   = 0.03; 
                for (unsigned int group_1 = 0; group_1 < n_groups; ++group_1) 
                  for (unsigned int group_2 = 0; group_2 < n_groups; ++group_2) 
                    sigma_s[m][group_1][group_2] = 0.0; 
              } 

            diffusion[5][1] = 0.2; 

            sigma_r[4][0] = 0.026; 
            sigma_r[5][0] = 0.051; 
            sigma_r[6][0] = 0.026; 
            sigma_r[7][0] = 0.050; 

            sigma_r[0][1] = 0.100; 
            sigma_r[1][1] = 0.200; 
            sigma_r[2][1] = 0.250; 
            sigma_r[3][1] = 0.300; 
            sigma_r[4][1] = 0.020; 
            sigma_r[5][1] = 0.040; 
            sigma_r[6][1] = 0.020; 
            sigma_r[7][1] = 0.800; 

            nu_sigma_f[0][0] = 0.0050; 
            nu_sigma_f[1][0] = 0.0075; 
            nu_sigma_f[2][0] = 0.0075; 
            nu_sigma_f[3][0] = 0.0075; 
            nu_sigma_f[4][0] = 0.000; 
            nu_sigma_f[5][0] = 0.000; 
            nu_sigma_f[6][0] = 1e-7; 
            nu_sigma_f[7][0] = 0.00; 

            nu_sigma_f[0][1] = 0.125; 
            nu_sigma_f[1][1] = 0.300; 
            nu_sigma_f[2][1] = 0.375; 
            nu_sigma_f[3][1] = 0.450; 
            nu_sigma_f[4][1] = 0.000; 
            nu_sigma_f[5][1] = 0.000; 
            nu_sigma_f[6][1] = 3e-6; 
            nu_sigma_f[7][1] = 0.00; 

            sigma_s[0][0][1] = 0.020; 
            sigma_s[1][0][1] = 0.015; 
            sigma_s[2][0][1] = 0.015; 
            sigma_s[3][0][1] = 0.015; 
            sigma_s[4][0][1] = 0.025; 
            sigma_s[5][0][1] = 0.050; 
            sigma_s[6][0][1] = 0.025; 
            sigma_s[7][0][1] = 0.010; 

            break; 
          } 

        default: 
          Assert(false, 
                 ExcMessage( 
                   "Presently, only data for 2 groups is implemented")); 
      } 
  } 

// 接下来是返回给定材料和能量组的系数值的函数。它们所做的就是确保给定的参数在允许的范围内，然后在相应的表格中查找相应的值。

  double 
  MaterialData::get_diffusion_coefficient(const unsigned int group, 
                                          const unsigned int material_id) const 
  { 
    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups)); 
    Assert(material_id < n_materials, 
           ExcIndexRange(material_id, 0, n_materials)); 

    return diffusion[material_id][group]; 
  } 

  double MaterialData::get_removal_XS(const unsigned int group, 
                                      const unsigned int material_id) const 
  { 
    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups)); 
    Assert(material_id < n_materials, 
           ExcIndexRange(material_id, 0, n_materials)); 

    return sigma_r[material_id][group]; 
  } 

  double MaterialData::get_fission_XS(const unsigned int group, 
                                      const unsigned int material_id) const 
  { 
    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups)); 
    Assert(material_id < n_materials, 
           ExcIndexRange(material_id, 0, n_materials)); 

    return nu_sigma_f[material_id][group]; 
  } 

  double MaterialData::get_scattering_XS(const unsigned int group_1, 
                                         const unsigned int group_2, 
                                         const unsigned int material_id) const 
  { 
    Assert(group_1 < n_groups, ExcIndexRange(group_1, 0, n_groups)); 
    Assert(group_2 < n_groups, ExcIndexRange(group_2, 0, n_groups)); 
    Assert(material_id < n_materials, 
           ExcIndexRange(material_id, 0, n_materials)); 

    return sigma_s[material_id][group_1][group_2]; 
  } 

  double 
  MaterialData::get_fission_spectrum(const unsigned int group, 
                                     const unsigned int material_id) const 
  { 
    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups)); 
    Assert(material_id < n_materials, 
           ExcIndexRange(material_id, 0, n_materials)); 

    return chi[material_id][group]; 
  } 

// 计算裂变分布截面的函数略有不同，因为它将其值计算为另外两个系数的乘积。我们不需要在这里检查参数，因为这在我们调用其他两个相关函数时已经发生了，尽管这样做可能也无妨。

  double MaterialData::get_fission_dist_XS(const unsigned int group_1, 
                                           const unsigned int group_2, 
                                           const unsigned int material_id) const 
  { 
    return (get_fission_spectrum(group_1, material_id) * 
            get_fission_XS(group_2, material_id)); 
  } 

//  @sect3{The <code>EnergyGroup</code> class}  

// 第一个有趣的类是包含所有特定于单个能量组的东西。为了将那些属于同一个对象的东西分组，我们声明了一个结构，该结构包含了用于单个能量组的网格的Triangulation和DoFHandler对象，以及一些其他对象和成员函数，我们将在下面的章节中讨论。

// 这个类的主要原因如下：对于正向问题（有指定的右手边）和特征值问题，人们通常要解决一连串的问题，而不是完全耦合的问题，每个能量组。一旦意识到单一能量组的系统矩阵是对称和正定的（它只是一个扩散算子），而完全耦合问题的矩阵通常是非对称和非定值的，这就可以理解了。如果涉及几个以上的能量组，它也是非常大和相当完整的。

// 让我们先看看在有外部右手的情况下要解决的方程（对于时间无关的情况）。
// @f{eqnarray*} -\nabla
//  \cdot(D_g(x) \nabla \phi_g(x)) + \Sigma_{r,g}(x)\phi_g(x) =
//  \chi_g\sum_{g'=1}^G\nu\Sigma_{f,g'}(x)\phi_{g'}(x) + \sum_{g'\ne
//  g}\Sigma_{s,g'\to g}(x)\phi_{g'}(x) + s_{\mathrm{ext},g}(x) 
//  @f}

// 我们通常会通过将右手边的所有项与  $g'=g$  移到左手边来解决这个方程，并求出  $\phi_g$  。当然，我们还不知道 $\phi_{g'}$ ，因为这些变量的方程包括涉及 $\phi_g$ 的右侧项。在这种情况下，通常的做法是进行迭代：计算 
// @f{eqnarray*} -\nabla \cdot(D_g(x) \nabla \phi^{(n)}_g(x)) &+&
//  \Sigma_{r,g}(x)\phi^{(n)}_g(x) \\ &=&
//  \chi_g\sum_{g'=1}^{g-1}\nu\Sigma_{f,g'}(x)\phi^{(n)}_{g'}(x) +
//  \chi_g\sum_{g'=g}^G\nu\Sigma_{f,g'}(x)\phi^{(n-1)}_{g'}(x) + \sum_{g'\ne
//  g, g'<g}\Sigma_{s,g'\to g}(x)\phi^{(n)}_{g'}(x) + \sum_{g'\ne g,
//  g'>g}\Sigma_{s,g'\to g}(x)\phi^{(n-1)}_{g'}(x) + s_{\mathrm{ext},g}(x)
//  @f} 。

// 换句话说，我们一个一个地解方程，如果 $g'\ge g$ ，就用上一次迭代的 $\phi_{g'}$ 的值，如果 $g'<g$ ，就用本次迭代已经计算的 $\phi_{g'}$ 的值。

// 在计算特征值时，我们做了一个非常类似的迭代，只是我们没有外部的右手边，而且每次迭代后的解都会被缩放，正如在介绍中所解释的。

// 在任何一种情况下，如果我们所做的只是让下面这一类人具备这些能力，那么这两种情况就可以共同处理。(i) 形成左手边的矩阵，(ii) 形成组内右手边的贡献，即涉及不相干的来源，(iii) 形成源于组  $g'$  的对右手边的贡献。这个类正是做这些工作（以及一些簿记工作，如网格细化、设置矩阵和向量等）。另一方面，这个类本身并不知道有多少个能量组，特别是它们之间的相互作用，也就是说，外部迭代的样子（以及因此我们是解决一个特征值还是一个直接问题）的决定是留给本程序下面的NeutronDiffusionProblem类。

// 所以让我们来看看这个类和它的接口。

  template <int dim> 
  class EnergyGroup 
  { 
  public: 
// @sect5{<code>EnergyGroup</code> public member functions}  

// 该类有相当数量的公共成员函数，因为其操作方式是由外部控制的，因此所有做重要事情的函数都需要从另一个类中调用。让我们从记账开始：该类显然需要知道它所代表的能量组，使用哪些材料数据，以及从哪个粗略的网格开始。构造函数接收这些信息，并通过这些信息初始化相关的成员变量（见下文）。

// 然后，我们还需要设置线性系统的函数，即在给定的有限元对象的情况下，正确地确定矩阵的大小和它的稀疏模式等。 <code>setup_linear_system</code> 函数就是这样做的。最后，对于这个初始块，有两个函数可以返回这个对象中使用的活动单元和自由度的数量--利用这一点，我们可以使三角形和DoF处理成员变量成为私有的，不必授予外部使用，增强了封装性。

    EnergyGroup(const unsigned int        group, 
                const MaterialData &      material_data, 
                const Triangulation<dim> &coarse_grid, 
                const FiniteElement<dim> &fe); 

    void setup_linear_system(); 

    unsigned int n_active_cells() const; 
    unsigned int n_dofs() const; 

// 然后是为每个迭代和当前能量组组装线性系统的函数。请注意，该矩阵与迭代次数无关，因此在每个细化周期只需计算一次。对于必须在每次逆功率迭代中更新的右手边来说，情况就有点复杂了，而且由于计算它可能涉及到几个不同的网格，正如介绍中所解释的那样，这就更复杂了。为了使事情在解决正向或特征值问题方面更加灵活，我们将右手边的计算分成一个函数，将无关的源和组内贡献（我们将其称为零函数，作为特征值问题的源项）和一个计算来自另一个能量组的右手边的贡献。

    void assemble_system_matrix(); 
    void assemble_ingroup_rhs(const Function<dim> &extraneous_source); 
    void assemble_cross_group_rhs(const EnergyGroup<dim> &g_prime); 

// 接下来我们需要一组函数来实际计算线性系统的解，并对其进行处理（比如计算介绍中提到的裂变源贡献，将图形信息写入输出文件，计算误差指标，或者根据这些标准和阈值实际细化和粗化网格）。所有这些函数以后都可以从驱动类 <code>NeutronDiffusionProblem</code> 中调用，或者你想实现的任何其他类来解决涉及中子通量方程的问题。

    void solve(); 

    double get_fission_source() const; 

    void output_results(const unsigned int cycle) const; 

    void estimate_errors(Vector<float> &error_indicators) const; 

    void refine_grid(const Vector<float> &error_indicators, 
                     const double         refine_threshold, 
                     const double         coarsen_threshold); 
// @sect5{<code>EnergyGroup</code> public data members}  

// 作为面向对象编程的良好实践，我们通过使它们成为私有的来隐藏大多数数据成员。然而，我们必须允许驱动进程的类访问解向量以及上一次迭代的解，因为在幂迭代中，解向量在每次迭代中都被我们正在寻找的特征值的当前猜测所缩放。

  public: 
    Vector<double> solution; 
    Vector<double> solution_old; 
// @sect5{<code>EnergyGroup</code> private data members}  

// 其余的数据成员是私有的。与之前所有的教程程序相比，唯一的新数据成员是一个存储此对象所代表的能量组的整数，以及此对象的构造函数从驱动类中得到的材料数据对象的引用。同样地，构造函数得到了我们要使用的有限元对象的引用。

// 最后，我们必须在每次迭代中对线性系统应用边界值，即相当频繁。我们不是每次都插值，而是在每个新的网格上插值一次，然后和这个类的所有其他数据一起存储。

  private: 
    const unsigned int  group; 
    const MaterialData &material_data; 

    Triangulation<dim>        triangulation; 
    const FiniteElement<dim> &fe; 
    DoFHandler<dim>           dof_handler; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> system_rhs; 

    std::map<types::global_dof_index, double> boundary_values; 
    AffineConstraints<double>                 hanging_node_constraints; 
// @sect5{<code>EnergyGroup</code> private member functions}  

// 在这个类中有一个私有成员函数。它递归地走过两个网格的单元，以计算跨组的右手边项。这个算法在本程序的介绍中已经解释过了。这个函数的参数是对一个对象的引用，该对象代表了我们要整合的右手项的能量组，一个指向用于当前能量组的网格单元的迭代器，一个指向另一个网格上相应单元的迭代器，以及将自由度从两个单元中较粗的单元插补到较细的单元的矩阵。

  private: 
    void assemble_cross_group_rhs_recursive( 
      const EnergyGroup<dim> &                       g_prime, 
      const typename DoFHandler<dim>::cell_iterator &cell_g, 
      const typename DoFHandler<dim>::cell_iterator &cell_g_prime, 
      const FullMatrix<double> &                     prolongation_matrix); 
  }; 
// @sect4{Implementation of the <code>EnergyGroup</code> class}  

// 这个类的前几个函数大部分是不言自明的。构造函数只设置了几个数据成员，并创建了一个给定三角形的副本，作为该能量组使用的三角形的基础。接下来的两个函数只是从私有数据成员中返回数据，从而使我们能够使这些数据成员私有化。

  template <int dim> 
  EnergyGroup<dim>::EnergyGroup(const unsigned int        group, 
                                const MaterialData &      material_data, 
                                const Triangulation<dim> &coarse_grid, 
                                const FiniteElement<dim> &fe) 
    : group(group) 
    , material_data(material_data) 
    , fe(fe) 
    , dof_handler(triangulation) 
  { 
    triangulation.copy_triangulation(coarse_grid); 
    dof_handler.distribute_dofs(fe); 
  } 

  template <int dim> 
  unsigned int EnergyGroup<dim>::n_active_cells() const 
  { 
    return triangulation.n_active_cells(); 
  } 

  template <int dim> 
  unsigned int EnergyGroup<dim>::n_dofs() const 
  { 
    return dof_handler.n_dofs(); 
  } 

//  @sect5{<code>EnergyGroup::setup_linear_system</code>}  

// 第一个 "真正的 "函数是在新的网格上或网格细化后设置网格、矩阵等。我们用这个函数来初始化稀疏系统矩阵，以及右手边的向量。如果求解向量之前从未被设置过（如用零大小表示），我们也会初始化它并将其设置为默认值。如果它已经有一个非零的大小，我们就不这么做了（也就是说，这个函数是在网格细化之后调用的），因为在这种情况下，我们希望在不同的网格细化中保留解决方案（这一点我们在 <code>EnergyGroup::refine_grid</code> 函数中做到了）。

  template <int dim> 
  void EnergyGroup<dim>::setup_linear_system() 
  { 
    const unsigned int n_dofs = dof_handler.n_dofs(); 

    hanging_node_constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

    system_matrix.clear(); 

    DynamicSparsityPattern dsp(n_dofs, n_dofs); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    hanging_node_constraints.condense(dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 

    system_rhs.reinit(n_dofs); 

    if (solution.size() == 0) 
      { 
        solution.reinit(n_dofs); 
        solution_old.reinit(n_dofs); 
        solution_old = 1.0; 
        solution     = solution_old; 
      } 

// 在这个函数的最后，我们更新边界节点列表和它们的数值，首先清除这个列表和重新插值的边界数值（记住，这个函数是在第一次设置网格后，以及每次网格细化后调用）。

// 为了理解这段代码，有必要认识到我们使用 <code>GridGenerator::subdivided_hyper_rectangle</code> 函数来创建网格(在 <code>NeutronDiffusionProblem::initialize_problem</code> )，其中我们将最后一个参数设置为 <code>true</code>  。这意味着域的边界被 "着色"，也就是说，域的四个（或六个，在3D）边被分配了不同的边界指标。结果是，底部边界得到指标0，顶部一个边界指标1，左右边界分别得到指标2和3。

// 在这个程序中，我们只模拟一个，即右上角的反应器的四分之一。也就是说，我们只想在顶部和右侧边界插值边界条件，而在底部和左侧边界不做任何事情（即施加自然的、无流量的诺伊曼边界条件）。这很容易被推广到任意维度，即我们想在指标为1、3、......的边界上插值，我们在下面的循环中这样做（注意，对 <code>VectorTools::interpolate_boundary_values</code> 的调用是加法的，即它们不首先清除边界值图）。

    boundary_values.clear(); 

    for (unsigned int i = 0; i < dim; ++i) 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               2 * i + 1, 
                                               Functions::ZeroFunction<dim>(), 
                                               boundary_values); 
  } 

//  @sect5{<code>EnergyGroup::assemble_system_matrix</code>}  

// 接下来我们需要函数来组装系统矩阵和右手边。考虑到介绍中列出的方程以及我们在以前的例子程序中看到的内容，组装矩阵是很简单的。注意使用 <code>cell->material_id()</code> 来获取一个单元的材料种类。还请注意我们是如何设置正交公式的顺序的，以便它总是适合于正在使用的有限元。

// 最后，请注意，由于我们在这里只组装了系统矩阵，所以我们还不能消除边界值（我们需要右边的向量来实现）。我们将其推迟到 <code>EnergyGroup::solve</code> 函数中，这时所有的信息都可以得到。

  template <int dim> 
  void EnergyGroup<dim>::assemble_system_matrix() 
  { 
    const QGauss<dim> quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0; 

        fe_values.reinit(cell); 

        const double diffusion_coefficient = 
          material_data.get_diffusion_coefficient(group, cell->material_id()); 
        const double removal_XS = 
          material_data.get_removal_XS(group, cell->material_id()); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              cell_matrix(i, j) += 
                ((diffusion_coefficient * fe_values.shape_grad(i, q_point) * 
                    fe_values.shape_grad(j, q_point) + 
                  removal_XS * fe_values.shape_value(i, q_point) * 
                    fe_values.shape_value(j, q_point)) * 
                 fe_values.JxW(q_point)); 

        cell->get_dof_indices(local_dof_indices); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 
      } 

    hanging_node_constraints.condense(system_matrix); 
  } 

//  @sect5{<code>EnergyGroup::assemble_ingroup_rhs</code>}  

// 正如 <code>EnergyGroup</code> 类的文档中所解释的，我们将组装右手边分成两部分：组内耦合和跨组耦合。首先，我们需要一个函数来组装这里的一个特定组的右手边，即包括一个无关的源（我们将在特征值问题上设置为零）以及组内裂变贡献。 组内散射已经在清除截面的定义中得到了考虑）。这个函数的工作原理就组装右手边而言是非常标准的，因此不需要更多的评论，只是我们要提到在函数的开头将右手边的向量设置为零--这一点我们不打算为跨组项做，这些跨组项只是添加到右手边的向量。

  template <int dim> 
  void 
  EnergyGroup<dim>::assemble_ingroup_rhs(const Function<dim> &extraneous_source) 
  { 
    system_rhs.reinit(dof_handler.n_dofs()); 

    const QGauss<dim> quadrature_formula(fe.degree + 1); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values); 

    Vector<double>      cell_rhs(dofs_per_cell); 
    std::vector<double> extraneous_source_values(n_q_points); 
    std::vector<double> solution_old_values(n_q_points); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_rhs = 0; 

        fe_values.reinit(cell); 

        const double fission_dist_XS = 
          material_data.get_fission_dist_XS(group, group, cell->material_id()); 

        extraneous_source.value_list(fe_values.get_quadrature_points(), 
                                     extraneous_source_values); 

        fe_values.get_function_values(solution_old, solution_old_values); 

        cell->get_dof_indices(local_dof_indices); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            cell_rhs(i) += 
              ((extraneous_source_values[q_point] + 
                fission_dist_XS * solution_old_values[q_point]) * 
               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point)); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
      } 
  } 

//  @sect5{<code>EnergyGroup::assemble_cross_group_rhs</code>}  

// 对于组装单一能量组方程的右手向量来说，更有趣的函数是将能量组  $g$  和  $g'$  耦合起来。正如介绍中所解释的，我们首先要找到两个能量组的网格所共有的单元集。首先我们调用 <code>get_finest_common_cells</code> 来获得这一对来自两个网格的共同单元的列表。一对单元格中的两个单元格可能都不活跃，但至少有一个是活跃的。然后我们将这些单元对中的每一个交给一个函数，该函数将递归地计算右手边的项。

// 注意，组内耦合在之前已经处理过了，所以我们提前退出这个函数，如果  $g=g'$  。

  template <int dim> 
  void 
  EnergyGroup<dim>::assemble_cross_group_rhs(const EnergyGroup<dim> &g_prime) 
  { 
    if (group == g_prime.group) 
      return; 

    const std::list<std::pair<typename DoFHandler<dim>::cell_iterator, 
                              typename DoFHandler<dim>::cell_iterator>> 
      cell_list = 
        GridTools::get_finest_common_cells(dof_handler, g_prime.dof_handler); 

    for (const auto &cell_pair : cell_list) 
      { 
        FullMatrix<double> unit_matrix(fe.n_dofs_per_cell()); 
        for (unsigned int i = 0; i < unit_matrix.m(); ++i) 
          unit_matrix(i, i) = 1; 
        assemble_cross_group_rhs_recursive(g_prime, 
                                           cell_pair.first, 
                                           cell_pair.second, 
                                           unit_matrix); 
      } 
  } 

//  @sect5{<code>EnergyGroup::assemble_cross_group_rhs_recursive</code>}  

// 这是最后一个处理在潜在的不同网格上递归组装右手边条款的函数，使用介绍中描述的算法。该函数接收一个代表能量组 $g'$ 的对象的引用，以及能量组 $g$ 和 $g'$ 的网格中相应单元的迭代器。起初，即从上面的函数中调用这个函数时，这两个单元将是两个网格上的匹配单元；然而，这两个单元中的一个可能被进一步细化，我们将递归地调用这个函数，两个迭代器中的一个被原始单元的一个子单元所取代。

// 最后一个参数是介绍中的矩阵乘积矩阵 $B_{c^{(k)}}^T \cdots B_{c'}^T B_c^T$ ，它从两个单元中较粗的单元插值到较细的单元。如果这两个单元格匹配，那么这就是身份矩阵--正是我们最初传递给这个函数的。

// 该函数必须考虑两种情况：两种单元格都没有进一步细化，即没有子代，在这种情况下，我们可以最终组装这对单元格的右侧贡献；以及两种单元格中的一种被进一步细化，在这种情况下，我们必须通过循环未被激活的单元格的子代来不断地进行循环。下面将讨论这两种情况。

  template <int dim> 
  void EnergyGroup<dim>::assemble_cross_group_rhs_recursive( 
    const EnergyGroup<dim> &                       g_prime, 
    const typename DoFHandler<dim>::cell_iterator &cell_g, 
    const typename DoFHandler<dim>::cell_iterator &cell_g_prime, 
    const FullMatrix<double> &                     prolongation_matrix) 
  { 

// 第一种情况是，两个单元格都没有进一步的细化。在这种情况下，我们可以组装相关条款（见介绍）。这涉及到在两个单元中较细的单元上组装质量矩阵（事实上有两个具有不同系数的质量矩阵，一个用于裂变分布截面 $\chi_g\nu\Sigma_{f,g'}$ ，一个用于散射截面 $\Sigma_{s,g'\to g}$ ）。这是直截了当的，但请注意我们如何通过查看两个单元的细化程度来确定哪个是更细的单元。

    if (!cell_g->has_children() && !cell_g_prime->has_children()) 
      { 
        const QGauss<dim>  quadrature_formula(fe.degree + 1); 
        const unsigned int n_q_points = quadrature_formula.size(); 

        FEValues<dim> fe_values(fe, 
                                quadrature_formula, 
                                update_values | update_JxW_values); 

        if (cell_g->level() > cell_g_prime->level()) 
          fe_values.reinit(cell_g); 
        else 
          fe_values.reinit(cell_g_prime); 

        const double fission_dist_XS = 
          material_data.get_fission_dist_XS(group, 
                                            g_prime.group, 
                                            cell_g_prime->material_id()); 

        const double scattering_XS = 
          material_data.get_scattering_XS(g_prime.group, 
                                          group, 
                                          cell_g_prime->material_id()); 

        FullMatrix<double> local_mass_matrix_f(fe.n_dofs_per_cell(), 
                                               fe.n_dofs_per_cell()); 
        FullMatrix<double> local_mass_matrix_g(fe.n_dofs_per_cell(), 
                                               fe.n_dofs_per_cell()); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i) 
            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j) 
              { 
                local_mass_matrix_f(i, j) += 
                  (fission_dist_XS * fe_values.shape_value(i, q_point) * 
                   fe_values.shape_value(j, q_point) * fe_values.JxW(q_point)); 
                local_mass_matrix_g(i, j) += 
                  (scattering_XS * fe_values.shape_value(i, q_point) * 
                   fe_values.shape_value(j, q_point) * fe_values.JxW(q_point)); 
              } 

// 现在我们有了所有的插值（延长）矩阵以及局部质量矩阵，所以我们只需要根据两个单元中哪一个更细，形成积
//  @f[
//  F_i|_{K_{cc'\cdots c^{(k)}}} = [B_c B_{c'} \cdots B_{c^{(k)}}
//  M_{K_{cc'\cdots c^{(k)}}}]^{ij} \phi_{g'}^j, 
//  @f]

//  或

//  @f[
//  F_i|_{K_{cc'\cdots c^{(k)}}} = [(B_c B_{c'} \cdots B_{c^{(k)}}
//  M_{K_{cc'\cdots c^{(k)}}})^T]^{ij} \phi_{g'}^j, 
//  @f]
//  。我们使用 <code>vmult</code> 函数提供的矩阵-向量乘积，或者使用 <code>Tvmult</code> 与转置矩阵的乘积来完成。这样做之后，我们将结果转移到能量组的全局右侧向量中  $g$  。


        Vector<double> g_prime_new_values(fe.n_dofs_per_cell()); 
        Vector<double> g_prime_old_values(fe.n_dofs_per_cell()); 
        cell_g_prime->get_dof_values(g_prime.solution_old, g_prime_old_values); 
        cell_g_prime->get_dof_values(g_prime.solution, g_prime_new_values); 

        Vector<double> cell_rhs(fe.n_dofs_per_cell()); 
        Vector<double> tmp(fe.n_dofs_per_cell()); 

        if (cell_g->level() > cell_g_prime->level()) 
          { 
            prolongation_matrix.vmult(tmp, g_prime_old_values); 
            local_mass_matrix_f.vmult(cell_rhs, tmp); 

            prolongation_matrix.vmult(tmp, g_prime_new_values); 
            local_mass_matrix_g.vmult_add(cell_rhs, tmp); 
          } 
        else 
          { 
            local_mass_matrix_f.vmult(tmp, g_prime_old_values); 
            prolongation_matrix.Tvmult(cell_rhs, tmp); 

            local_mass_matrix_g.vmult(tmp, g_prime_new_values); 
            prolongation_matrix.Tvmult_add(cell_rhs, tmp); 
          } 

        std::vector<types::global_dof_index> local_dof_indices( 
          fe.n_dofs_per_cell()); 
        cell_g->get_dof_indices(local_dof_indices); 

        for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i) 
          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
      } 

// 另一种情况是，两个单元中的一个被进一步细化。在这种情况下，我们必须在所有的子单元上循环，将现有的矩阵的插值（延长）乘以从现在的单元到其子单元的插值（使用矩阵-矩阵乘法函数 <code>mmult</code> ），然后将结果再次交给这个非常相同的函数，但将有子单元替换为其子单元之一。

    else 
      for (unsigned int child = 0; 
           child < GeometryInfo<dim>::max_children_per_cell; 
           ++child) 
        { 
          FullMatrix<double> new_matrix(fe.n_dofs_per_cell(), 
                                        fe.n_dofs_per_cell()); 
          fe.get_prolongation_matrix(child).mmult(new_matrix, 
                                                  prolongation_matrix); 

          if (cell_g->has_children()) 
            assemble_cross_group_rhs_recursive(g_prime, 
                                               cell_g->child(child), 
                                               cell_g_prime, 
                                               new_matrix); 
          else 
            assemble_cross_group_rhs_recursive(g_prime, 
                                               cell_g, 
                                               cell_g_prime->child(child), 
                                               new_matrix); 
        } 
  } 
// @sect5{<code>EnergyGroup::get_fission_source</code>}  

// 在（反）功率迭代中，我们使用综合裂变源来更新 $k$  -特征值。鉴于其定义，以下函数基本上是不言自明的。

  template <int dim> 
  double EnergyGroup<dim>::get_fission_source() const 
  { 
    const QGauss<dim>  quadrature_formula(fe.degree + 1); 
    const unsigned int n_q_points = quadrature_formula.size(); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_JxW_values); 

    std::vector<double> solution_values(n_q_points); 

    double fission_source = 0; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 

        const double fission_XS = 
          material_data.get_fission_XS(group, cell->material_id()); 

        fe_values.get_function_values(solution, solution_values); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          fission_source += 
            (fission_XS * solution_values[q_point] * fe_values.JxW(q_point)); 
      } 

    return fission_source; 
  } 
// @sect5{<code>EnergyGroup::solve</code>}  

// 接下来是一个解决之前组装的线性系统的函数。事情基本是标准的，只是我们把应用边界值的时间推迟到了这里，因为在之前的所有函数中，我们还是在为右边的向量做加法。

  template <int dim> 
  void EnergyGroup<dim>::solve() 
  { 
    hanging_node_constraints.condense(system_rhs); 
    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       solution, 
                                       system_rhs); 

    SolverControl            solver_control(system_matrix.m(), 
                                 1e-12 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    hanging_node_constraints.distribute(solution); 
  } 

//  @sect5{<code>EnergyGroup::estimate_errors</code>}  

// 网格细化被分成两个函数。第一个函数估计每个单元的误差，用解的大小对其进行归一化处理，并将其返回到作为参数的向量中。调用函数收集所有能量组的所有误差指标，并计算出细化和粗化单元的阈值。

  template <int dim> 
  void EnergyGroup<dim>::estimate_errors(Vector<float> &error_indicators) const 
  { 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      error_indicators); 
    error_indicators /= solution.linfty_norm(); 
  } 

//  @sect5{<code>EnergyGroup::refine_grid</code>}  

// 第二部分是细化网格，给定前一个函数中计算的误差指标和误差阈值，超过这个阈值的单元应被细化，低于这个阈值的单元应被粗化。注意，我们在这里没有使用 <code>GridRefinement</code> 中的任何函数，而是自己设置细化标志。

// 在设置完这些标志后，我们使用SolutionTransfer类将求解向量从旧网格转移到新网格。这里使用的程序在该类的文档中已有详细描述。

  template <int dim> 
  void EnergyGroup<dim>::refine_grid(const Vector<float> &error_indicators, 
                                     const double         refine_threshold, 
                                     const double         coarsen_threshold) 
  { 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      if (error_indicators(cell->active_cell_index()) > refine_threshold) 
        cell->set_refine_flag(); 
      else if (error_indicators(cell->active_cell_index()) < coarsen_threshold) 
        cell->set_coarsen_flag(); 

    SolutionTransfer<dim> soltrans(dof_handler); 

    triangulation.prepare_coarsening_and_refinement(); 
    soltrans.prepare_for_coarsening_and_refinement(solution); 

    triangulation.execute_coarsening_and_refinement(); 
    dof_handler.distribute_dofs(fe); 
    setup_linear_system(); 

    solution.reinit(dof_handler.n_dofs()); 
    soltrans.interpolate(solution_old, solution); 

// 强制执行约束条件，使插值后的解决方案在新的网格上符合要求。

    hanging_node_constraints.distribute(solution); 

    solution_old.reinit(dof_handler.n_dofs()); 
    solution_old = solution; 
  } 
// @sect5{<code>EnergyGroup::output_results</code>}  

// 该类的最后一个函数在每次网格迭代后输出网格和解。这在以前已经展示过很多次了。唯一值得指出的是使用 <code>Utilities::int_to_string</code> 函数将一个整数转换为其字符串表示。该函数的第二个参数表示我们应使用多少个数字 -- 如果这个值大于1，那么数字将被填充前导零。

  template <int dim> 
  void EnergyGroup<dim>::output_results(const unsigned int cycle) const 
  { 
    const std::string filename = std::string("solution-") + 
                                 Utilities::int_to_string(group, 2) + "." + 
                                 Utilities::int_to_string(cycle, 2) + ".vtu"; 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(); 

    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 

//  @sect3{The <code>NeutronDiffusionProblem</code> class template}  

// 这是程序的主类，并不是因为它实现了所有的功能（事实上，大部分的功能都在 <code>EnergyGroup</code> 类中实现了），而是因为它包含了决定什么时候计算的驱动算法。它主要是像其他许多教程程序中显示的那样，它有一个公共的 <code>run</code> 函数和私有函数来做其他的事情。在一些地方，我们必须为所有能源组做一些事情，在这种情况下，如果deal.II被配置为多线程，我们将为每个组启动任务，让这些事情并行运行。 关于并行化的策略，请看一下 @ref threads 模块。

// 与以前的例子程序最大的不同是，我们还声明了一个嵌套类，该类有成员变量，用于所有可在输入文件中传递给程序的运行时参数。现在，这些参数是能量组的数量、细化周期的数量、要使用的有限元的多项式程度以及用于确定反幂迭代何时收敛的公差。此外，我们有一个该类的构造函数，将所有这些值设置为默认值，还有一个函数 <code>declare_parameters</code> 向ParameterHandler类描述输入文件中接受哪些参数，还有一个函数 <code>get_parameters</code> 可以从ParameterHandler对象中提取这些参数的值。参见 step-29 ，了解另一个使用ParameterHandler的例子。

  template <int dim> 
  class NeutronDiffusionProblem 
  { 
  public: 
    class Parameters 
    { 
    public: 
      Parameters(); 

      static void declare_parameters(ParameterHandler &prm); 
      void        get_parameters(ParameterHandler &prm); 

      unsigned int n_groups; 
      unsigned int n_refinement_cycles; 

      unsigned int fe_degree; 

      double convergence_tolerance; 
    }; 

    NeutronDiffusionProblem(const Parameters &parameters); 

    void run(); 

  private: 
// @sect5{<code>NeutronDiffusionProblem</code> private member functions}  

// 这个类中没有那么多的成员函数，因为大部分的功能已经被移到了 <code>EnergyGroup</code> 类中，只是从这个类的 <code>run()</code> 成员函数中调用。留下来的成员函数有不言自明的名字。

    void initialize_problem(); 

    void refine_grid(); 

    double get_total_fission_source() const; 
// @sect5{<code>NeutronDiffusionProblem</code> private member variables}  

// 接下来，我们有几个成员变量。特别是，这些是（i）对参数对象的引用（由本程序的主函数拥有，并传递给本类的构造函数），（ii）描述输入文件中要求的能量组数量的材料参数的对象，以及（iii）所有能量组将使用的有限元。

    const Parameters & parameters; 
    const MaterialData material_data; 
    FE_Q<dim>          fe; 

// 此外，我们有(iv)目前迭代时计算的特征值的值。事实上，这是在所有能量组之间共享的解决方案的唯一部分--解决方案的所有其他部分，如中子通量是特定于一个或另一个能量组的，因此被存储在描述单一能量组的对象中。

    double k_eff; 

// 最后一个计算对象（v）是一个指向能量组对象的数组。当然，这个数组的长度等于参数文件中指定的能量组的数量。

    std::vector<std::unique_ptr<EnergyGroup<dim>>> energy_groups; 

// 最后(vi)我们有一个文件流，我们将把总结的输出保存到这个文件中。

    std::ofstream convergence_table_stream; 
  }; 
// @sect4{Implementation of the <code>Parameters</code> class}  

// 在继续实现外层类之前，我们必须实现参数结构的功能。这是很直接的，事实上，对于所有使用ParameterHandler功能的这类参数类来说，看起来都是一样的。因此，我们将不再对此进行评论。

  template <int dim> 
  NeutronDiffusionProblem<dim>::Parameters::Parameters() 
    : n_groups(2) 
    , n_refinement_cycles(5) 
    , fe_degree(2) 
    , convergence_tolerance(1e-12) 
  {} 

  template <int dim> 
  void NeutronDiffusionProblem<dim>::Parameters::declare_parameters( 
    ParameterHandler &prm) 
  { 
    prm.declare_entry("Number of energy groups", 
                      "2", 
                      Patterns::Integer(), 
                      "The number of energy different groups considered"); 
    prm.declare_entry("Refinement cycles", 
                      "5", 
                      Patterns::Integer(), 
                      "Number of refinement cycles to be performed"); 
    prm.declare_entry("Finite element degree", 
                      "2", 
                      Patterns::Integer(), 
                      "Polynomial degree of the finite element to be used"); 
    prm.declare_entry( 
      "Power iteration tolerance", 
      "1e-12", 
      Patterns::Double(), 
      "Inner power iterations are stopped when the change in k_eff falls " 
      "below this tolerance"); 
  } 

  template <int dim> 
  void NeutronDiffusionProblem<dim>::Parameters::get_parameters( 
    ParameterHandler &prm) 
  { 
    n_groups              = prm.get_integer("Number of energy groups"); 
    n_refinement_cycles   = prm.get_integer("Refinement cycles"); 
    fe_degree             = prm.get_integer("Finite element degree"); 
    convergence_tolerance = prm.get_double("Power iteration tolerance"); 
  } 

//  @sect4{Implementation of the <code>NeutronDiffusionProblem</code> class}  

// 现在是 <code>NeutronDiffusionProblem</code> 类。构造函数和析构函数没有什么值得注意的地方。

  template <int dim> 
  NeutronDiffusionProblem<dim>::NeutronDiffusionProblem( 
    const Parameters &parameters) 
    : parameters(parameters) 
    , material_data(parameters.n_groups) 
    , fe(parameters.fe_degree) 
    , k_eff(std::numeric_limits<double>::quiet_NaN()) 
  {} 

//  @sect5{<code>NeutronDiffusionProblem::initialize_problem</code>}  

// 第一个感兴趣的函数是设置反应堆核心的几何形状的函数。这在介绍中会有更详细的描述。

// 该函数的第一部分定义了几何数据，然后创建了一个粗略的网格，其单元数与我们模拟的那部分反应堆堆芯中的燃料棒（或针状单元）的数量相当。正如上面插值边界值时提到的， <code>GridGenerator::subdivided_hyper_rectangle</code> 函数的最后一个参数指定域的两侧应具有唯一的边界指标，这将使我们能够以简单的方式确定哪些边界具有诺伊曼条件，哪些边界具有迪里希特条件。

  template <int dim> 
  void NeutronDiffusionProblem<dim>::initialize_problem() 
  { 
    const unsigned int rods_per_assembly_x = 17, rods_per_assembly_y = 17; 
    const double       pin_pitch_x = 1.26, pin_pitch_y = 1.26; 
    const double       assembly_height = 200; 

    const unsigned int assemblies_x = 2, assemblies_y = 2, assemblies_z = 1; 

    const Point<dim> bottom_left = Point<dim>(); 
    const Point<dim> upper_right = 
      (dim == 2 ? Point<dim>(assemblies_x * rods_per_assembly_x * pin_pitch_x, 
                             assemblies_y * rods_per_assembly_y * pin_pitch_y) : 
                  Point<dim>(assemblies_x * rods_per_assembly_x * pin_pitch_x, 
                             assemblies_y * rods_per_assembly_y * pin_pitch_y, 
                             assemblies_z * assembly_height)); 

    std::vector<unsigned int> n_subdivisions; 
    n_subdivisions.push_back(assemblies_x * rods_per_assembly_x); 
    if (dim >= 2) 
      n_subdivisions.push_back(assemblies_y * rods_per_assembly_y); 
    if (dim >= 3) 
      n_subdivisions.push_back(assemblies_z); 

    Triangulation<dim> coarse_grid; 
    GridGenerator::subdivided_hyper_rectangle( 
      coarse_grid, n_subdivisions, bottom_left, upper_right, true); 

// 该函数的第二部分涉及每种类型的组件的引脚单元的材料数量。在这里，我们定义了四种不同类型的组件，对于这些组件，我们在以下表格中描述了燃料棒的排列。

// 这里描述的装配体来自于介绍中提到的基准，它们是（按照这个顺序）。  <ol>  
// <li>  'UX'组件。二氧化铀燃料组件，带有24个导向管和一个中央可移动裂变室  <li>  'UA' 组件。带有24个AIC的二氧化铀燃料组件和一个中央可移动裂变室  <li>  'PX'组件。MOX燃料组件，带有24个导向管和一个中央可移动裂变室  <li>  'R'组件：一个反射器。   </ol>  

// 注意这里列出的数字和从基准描述中提取的数字，以良好的老Fortran方式，是基于一的。我们以后在给各个单元分配材料时将从每个数字中减去1，以便将事情转换为C语言风格的零基索引。

    const unsigned int n_assemblies = 4; 
    const unsigned int assembly_materials 
      [n_assemblies][rods_per_assembly_x][rods_per_assembly_y] = { 
        {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 5, 1, 1, 5, 1, 1, 7, 1, 1, 5, 1, 1, 5, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}}, 
        {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 8, 1, 1, 8, 1, 1, 7, 1, 1, 8, 1, 1, 8, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}}, 
        {{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}, 
         {2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2}, 
         {2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2}, 
         {2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2}, 
         {2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2}, 
         {2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2}, 
         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2}, 
         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2}, 
         {2, 3, 5, 4, 4, 5, 4, 4, 7, 4, 4, 5, 4, 4, 5, 3, 2}, 
         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2}, 
         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2}, 
         {2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2}, 
         {2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2}, 
         {2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2}, 
         {2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2}, 
         {2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2}, 
         {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}}, 
        {{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, 
         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}}}; 

// 在描述了组成装配体的材料之后，我们必须指定装配体在核心中的排列。我们使用一个对称的模式，实际上只使用'UX'和'PX'装配体。

    const unsigned int core[assemblies_x][assemblies_y][assemblies_z] = { 
      {{0}, {2}}, {{2}, {0}}}; 

// 我们现在可以为每个单元实际设置材料ID。为此，我们在所有单元中循环，查看单元中心的位置，并确定它将在哪个组件和燃料棒中。我们增加了一些检查，以确保我们计算的位置在我们必须查找材料的数组的范围内）。在循环结束时，我们相应地设置材料标识符。

    for (auto &cell : coarse_grid.active_cell_iterators()) 
      { 
        const Point<dim> cell_center = cell->center(); 

        const unsigned int tmp_x = int(cell_center[0] / pin_pitch_x); 
        const unsigned int ax    = tmp_x / rods_per_assembly_x; 
        const unsigned int cx    = tmp_x - ax * rods_per_assembly_x; 

        const unsigned     tmp_y = int(cell_center[1] / pin_pitch_y); 
        const unsigned int ay    = tmp_y / rods_per_assembly_y; 
        const unsigned int cy    = tmp_y - ay * rods_per_assembly_y; 

        const unsigned int az = 
          (dim == 2 ? 0 : int(cell_center[dim - 1] / assembly_height)); 

        Assert(ax < assemblies_x, ExcInternalError()); 
        Assert(ay < assemblies_y, ExcInternalError()); 
        Assert(az < assemblies_z, ExcInternalError()); 

        Assert(core[ax][ay][az] < n_assemblies, ExcInternalError()); 

        Assert(cx < rods_per_assembly_x, ExcInternalError()); 
        Assert(cy < rods_per_assembly_y, ExcInternalError()); 

        cell->set_material_id(assembly_materials[core[ax][ay][az]][cx][cy] - 1); 
      } 

// 有了这样初始化的粗网格，我们创建适当数量的能量组对象，让它们用上面生成的粗网格初始化各自的网格。

    for (unsigned int group = 0; group < parameters.n_groups; ++group) 
      energy_groups.emplace_back(std::make_unique<EnergyGroup<dim>>( 
        group, material_data, coarse_grid, fe)); 
    convergence_table_stream.open("convergence_table"); 
    convergence_table_stream.precision(12); 
  } 
// @sect5{<code>NeutronDiffusionProblem::get_total_fission_source</code>}  

// 在特征值计算中，我们需要在每次功率迭代后计算裂变中子源总量。然后用总功率来更新k-effective。

// 由于总裂变源是所有能量组的总和，而且每个总和都可以独立计算，所以我们实际上是以并行方式进行的。其中一个问题是， <code>EnergyGroup</code> 类中计算裂变源的函数会返回一个值。我们想在循环本身中把这些值加在一起：理想的情况是，每个任务计算它的值，然后立即把它加到总数中。以这种方式对数值进行加总需要两个功能。  <ol>  
// <li>  我们需要一种存储数值的方式，使多个线程能够以防止数据竞赛的方式并发地读写（即线程安全的读写）。 </li>  
// <li>  我们需要一种方法来增加这样一个值，而且是线程安全的。 </li>  
// </ol>  

// 第一个特性可以通过模板类实现  <code>std::atomic</code>  。然而，第二个特性，由 <code>std::atomic<double>::fetch_add()</code> 实现，只在C++20及以后的版本中可用：由于deal.II支持旧版本的C++语言标准，我们还不能使用这个特性。因此，取而代之的是，我们简单地将每个组的值写成向量中的一个条目，并在函数的最后将这些值相加。

  template <int dim> 
  double NeutronDiffusionProblem<dim>::get_total_fission_source() const 
  { 
    std::vector<double>  fission_sources(parameters.n_groups); 
    Threads::TaskGroup<> tasks; 
    for (unsigned int group = 0; group < parameters.n_groups; ++group) 
      tasks += Threads::new_task<>([&, group]() { 
        fission_sources[group] = energy_groups[group]->get_fission_source(); 
      }); 
    tasks.join_all(); 

    return std::accumulate(fission_sources.begin(), fission_sources.end(), 0.0); 
  } 

//  @sect5{<code>NeutronDiffusionProblem::refine_grid</code>}  

// 下一个函数让各个能量组对象细化其网格。这其中的大部分，也是可以独立并行完成的任务：首先，让所有的能量组对象并行计算它们的误差指标，然后计算所有能量组的最大误差指标，并确定细化和粗化单元的阈值，然后要求所有的能量组相应地细化它们的网格，也是并行的。

  template <int dim> 
  void NeutronDiffusionProblem<dim>::refine_grid() 
  { 
    std::vector<types::global_dof_index> n_cells(parameters.n_groups); 
    for (unsigned int group = 0; group < parameters.n_groups; ++group) 
      n_cells[group] = energy_groups[group]->n_active_cells(); 

    BlockVector<float> group_error_indicators(n_cells); 

    { 
      Threads::TaskGroup<> tasks; 
      for (unsigned int group = 0; group < parameters.n_groups; ++group) 
        tasks += Threads::new_task([&, group]() { 
          energy_groups[group]->estimate_errors( 
            group_error_indicators.block(group)); 
        }); 
    } 

//  Threads::TaskGroup 的析构器连接所有线程，所以我们知道在我们退出范围时，计算已经完成。

    const float max_error         = group_error_indicators.linfty_norm(); 
    const float refine_threshold  = 0.3 * max_error; 
    const float coarsen_threshold = 0.01 * max_error; 

    { 
      Threads::TaskGroup<void> tasks; 
      for (unsigned int group = 0; group < parameters.n_groups; ++group) 
        tasks += Threads::new_task([&, group]() { 
          energy_groups[group]->refine_grid(group_error_indicators.block(group), 
                                            refine_threshold, 
                                            coarsen_threshold); 
        }); 
    } 
  } 
// @sect5{<code>NeutronDiffusionProblem::run</code>}  

// 最后，这就是肉的函数：在一连串的网格上进行迭代，并对每一个网格进行幂级迭代，以计算特征值。

// 鉴于介绍中对算法的描述，实际上没有什么可评论的。

  template <int dim> 
  void NeutronDiffusionProblem<dim>::run() 
  { 

// 我们希望只为这个函数改变输出精度，并在这个函数返回时恢复到 <code>std::cout</code> 的状态。因此，我们需要一种方法来撤销输出格式的改变。Boost提供了一种方便的方法来保存输出流的状态，并在当前块结束时（当调用 <code>restore_flags</code> 的析构器时）用 <code>ios_flags_saver</code> 类来恢复它，我们在这里使用了这种方法。

    boost::io::ios_flags_saver restore_flags(std::cout); 
    std::cout << std::setprecision(12) << std::fixed; 

// 我们通过k_eff的变化来计算下面的误差（即k_eff_old的区别。

    double k_eff_old = 0.0; 

    for (unsigned int cycle = 0; cycle < parameters.n_refinement_cycles; 
         ++cycle) 
      { 

// 我们将在下面测量每个周期所需的CPU时间。计时器的构造函数调用 Timer::start(), ，所以一旦我们创建了一个计时器，就可以查询它的信息。由于这个循环的许多部分是用任务并行化的，所以我们测量的CPU时间（如果我们用一个以上的线程运行）将大于墙的时间。

        Timer timer; 

        std::cout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 
            initialize_problem(); 
            for (unsigned int group = 0; group < parameters.n_groups; ++group) 
              energy_groups[group]->setup_linear_system(); 
          } 

        else 
          { 
            refine_grid(); 
            for (unsigned int group = 0; group < parameters.n_groups; ++group) 
              energy_groups[group]->solution *= k_eff; 
          } 

        std::cout << "   Numbers of active cells:       "; 
        for (unsigned int group = 0; group < parameters.n_groups; ++group) 
          std::cout << energy_groups[group]->n_active_cells() << ' '; 
        std::cout << std::endl; 
        std::cout << "   Numbers of degrees of freedom: "; 
        for (unsigned int group = 0; group < parameters.n_groups; ++group) 
          std::cout << energy_groups[group]->n_dofs() << ' '; 
        std::cout << std::endl << std::endl; 

        Threads::TaskGroup<> tasks; 
        for (unsigned int group = 0; group < parameters.n_groups; ++group) 
          tasks += Threads::new_task( 
            [&, group]() { energy_groups[group]->assemble_system_matrix(); }); 
        tasks.join_all(); 

        double       error; 
        unsigned int iteration = 1; 
        do 
          { 
            for (unsigned int group = 0; group < parameters.n_groups; ++group) 
              { 
                energy_groups[group]->assemble_ingroup_rhs( 
                  Functions::ZeroFunction<dim>()); 

                for (unsigned int bgroup = 0; bgroup < parameters.n_groups; 
                     ++bgroup) 
                  energy_groups[group]->assemble_cross_group_rhs( 
                    *energy_groups[bgroup]); 

                energy_groups[group]->solve(); 
              } 

            k_eff = get_total_fission_source(); 
            error = std::abs(k_eff - k_eff_old) / std::abs(k_eff); 
            const double flux_ratio = energy_groups[0]->solution.linfty_norm() / 
                                      energy_groups[1]->solution.linfty_norm(); 
            const double max_thermal = energy_groups[1]->solution.linfty_norm(); 
            std::cout << "Iter number:" << std::setw(2) << std::right 
                      << iteration << " k_eff=" << k_eff 
                      << " flux_ratio=" << flux_ratio 
                      << " max_thermal=" << max_thermal << std::endl; 
            k_eff_old = k_eff; 

            for (unsigned int group = 0; group < parameters.n_groups; ++group) 
              { 
                energy_groups[group]->solution_old = 
                  energy_groups[group]->solution; 
                energy_groups[group]->solution_old /= k_eff; 
              } 

            ++iteration; 
          } 
        while ((error > parameters.convergence_tolerance) && (iteration < 500)); 
        convergence_table_stream << cycle << " " << energy_groups[0]->n_dofs() 
                                 << " " << energy_groups[1]->n_dofs() << " " 
                                 << k_eff << " " 
                                 << energy_groups[0]->solution.linfty_norm() / 
                                      energy_groups[1]->solution.linfty_norm() 
                                 << '\n'; 

        for (unsigned int group = 0; group < parameters.n_groups; ++group) 
          energy_groups[group]->output_results(cycle); 

// 打印出关于模拟的信息以及耗费的CPU时间。我们可以不先调用 Timer::cpu_time() ，而直接调用 Timer::stop() ，以获得调用该函数时的已用CPU时间。

        std::cout << std::endl; 
        std::cout << "   Cycle=" << cycle << ", n_dofs=" 
                  << energy_groups[0]->n_dofs() + energy_groups[1]->n_dofs() 
                  << ",  k_eff=" << k_eff << ", time=" << timer.cpu_time() 
                  << std::endl; 

        std::cout << std::endl << std::endl; 
      } 
  } 
} // namespace Step28 

//  @sect3{The <code>main()</code> function}  

// 程序中的最后一件事在 <code>main()</code> 函数中。其结构与其他大多数教程程序一样，唯一的例外是我们在这里处理一个参数文件。 为此，我们首先看一下传递给这个函数的命令行参数：如果在命令行上没有指定输入文件，那么就使用 "project.prm"，否则就取命令行上作为第一个参数给出的文件名。

// 有了这个，我们创建一个ParameterHandler对象，让 <code>NeutronDiffusionProblem::Parameters</code> 类声明它想在输入文件中看到的所有参数（或者，采取默认值，如果参数文件中没有列出任何参数），然后读取输入文件，要求参数对象提取数值，最后把所有东西交给 <code>NeutronDiffusionProblem</code> 类型的对象来计算特征值。

int main(int argc, char **argv) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step28; 

      std::string filename; 
      if (argc < 2) 
        filename = "project.prm"; 
      else 
        filename = argv[1]; 

      const unsigned int dim = 2; 

      ParameterHandler parameter_handler; 

      NeutronDiffusionProblem<dim>::Parameters parameters; 
      parameters.declare_parameters(parameter_handler); 

      parameter_handler.parse_input(filename); 

      parameters.get_parameters(parameter_handler); 

      NeutronDiffusionProblem<dim> neutron_diffusion_problem(parameters); 
      neutron_diffusion_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-29.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2007 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Moritz Allmaras, Texas A&M University, 2007 
 */ 


// @sect3{Include files}  

// 下面的头文件以前都讨论过了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/manifold_lib.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

#include <iostream> 
#include <fstream> 

// 这个头文件包含了ParameterHandler类的必要声明，我们将用它来从配置文件中读取我们的参数。

#include <deal.II/base/parameter_handler.h> 

// 为了解决线性系统，我们将使用UMFPACK提供的稀疏LU分解（见SparseDirectUMFPACK类），为此需要以下头文件。 请注意，为了编译这个教程程序，deal.II-library需要在UMFPACK支持下构建，默认情况下是启用的。

#include <deal.II/lac/sparse_direct.h> 

// FESystem类允许我们将多个FE对象堆叠成一个复合的、矢量值的有限元场。该类的必要声明在该头文件中提供。

#include <deal.II/fe/fe_system.h> 

// 最后，包括声明定时器类的头文件，我们将用它来确定我们程序的每个操作需要多少时间。

#include <deal.II/base/timer.h> 

// 作为本程序开始时的最后一步，我们将本程序中的所有内容放入其命名空间，并在其中使deal.II命名空间中的所有内容全局可用，不需要在所有内容前加上 <code>dealii</code><code>::</code>  。

namespace Step29 
{ 
  using namespace dealii; 
// @sect3{The <code>DirichletBoundaryValues</code> class}  

// 首先我们为代表Dirichlet边界值的函数定义一个类。这在以前已经做过很多次了，因此不需要过多解释。

// 由于有两个值 $v$ 和 $w$ 需要在边界处规定，我们必须告诉基类这是一个有两个分量的向量值函数， <code>vector_value</code> 函数和它的表亲 <code>vector_value_list</code> 必须返回有两个条目的向量。在我们的例子中，这个函数非常简单，它只是对实部 $v$ 返回1，对虚部 $w$ 返回0，而不管它在哪个点被评估。

  template <int dim> 
  class DirichletBoundaryValues : public Function<dim> 
  { 
  public: 
    DirichletBoundaryValues() 
      : Function<dim>(2) 
    {} 

    virtual void vector_value(const Point<dim> & /*p*/, 
                              Vector<double> &values) const override 
    { 
      Assert(values.size() == 2, ExcDimensionMismatch(values.size(), 2)); 

      values(0) = 1; 
      values(1) = 0; 
    } 

    virtual void 
    vector_value_list(const std::vector<Point<dim>> &points, 
                      std::vector<Vector<double>> &  value_list) const override 
    { 
      Assert(value_list.size() == points.size(), 
             ExcDimensionMismatch(value_list.size(), points.size())); 

      for (unsigned int p = 0; p < points.size(); ++p) 
        DirichletBoundaryValues<dim>::vector_value(points[p], value_list[p]); 
    } 
  }; 
// @sect3{The <code>ParameterReader</code> class}  

// 下一个类负责准备ParameterHandler对象并从输入文件中读取参数。 它包括一个声明所有必要参数的函数 <code>declare_parameters</code> 和一个从外部调用的 <code>read_parameters</code> 函数，以启动参数读取过程。

  class ParameterReader : public Subscriptor 
  { 
  public: 
    ParameterReader(ParameterHandler &); 
    void read_parameters(const std::string &); 

  private: 
    void              declare_parameters(); 
    ParameterHandler &prm; 
  }; 

// 构造函数存储了一个传递给它的ParameterHandler对象的引用。

  ParameterReader::ParameterReader(ParameterHandler &paramhandler) 
    : prm(paramhandler) 
  {} 
// @sect4{<code>ParameterReader::declare_parameters</code>}  

//  <code>declare_parameters</code> 函数声明了我们的ParameterHandler对象能够从输入文件中读取的所有参数，以及它们的类型、范围条件和它们出现在哪个分段。我们将用一对大括号包住所有进入一个部分的条目，以迫使编辑器将它们缩进一级，使其更容易阅读哪些条目共同构成一个部分。

  void ParameterReader::declare_parameters() 
  { 

// 网格和几何参数包括应用于初始粗略网格的全局细化步数和换能器镜头的焦距 $d$ 。对于细化步数，我们允许在 $[0,\infty)$ 范围内的整数，其中 Patterns::Integer 对象的第二个参数被省略，表示半开区间。 对于焦距，任何大于零的数字都可以接受。

    prm.enter_subsection("Mesh & geometry parameters"); 
    { 
      prm.declare_entry("Number of refinements", 
                        "6", 
                        Patterns::Integer(0), 
                        "Number of global mesh refinement steps " 
                        "applied to initial coarse grid"); 

      prm.declare_entry("Focal distance", 
                        "0.3", 
                        Patterns::Double(0), 
                        "Distance of the focal point of the lens " 
                        "to the x-axis"); 
    } 
    prm.leave_subsection(); 

// 下一小节专门讨论方程中出现的物理参数，它们是频率  $\omega$  和波速  $c$  。同样，两者都需要位于半开区间 $[0,\infty)$ 内，通过调用 Patterns::Double 类，仅以左端点为参数来表示。

    prm.enter_subsection("Physical constants"); 
    { 
      prm.declare_entry("c", "1.5e5", Patterns::Double(0), "Wave speed"); 

      prm.declare_entry("omega", "5.0e7", Patterns::Double(0), "Frequency"); 
    } 
    prm.leave_subsection(); 

// 最后但并非最不重要的是，我们希望能够通过配置文件中的条目来改变输出的一些属性，如文件名和格式，这就是最后一小节的目的。

    prm.enter_subsection("Output parameters"); 
    { 
      prm.declare_entry("Output filename", 
                        "solution", 
                        Patterns::Anything(), 
                        "Name of the output file (without extension)"); 

// 由于不同的输出格式在生成输出时可能需要不同的参数（例如，postscript输出需要视角角度、线宽、颜色等），如果我们必须为库中支持的每一种可能的输出格式手工声明所有这些参数，那就太麻烦了。相反，每种输出格式都有一个 <code>FormatFlags::declare_parameters</code> 函数，它在自己的小节中声明了该格式的所有特定参数。下面调用 DataOutInterface<1>::declare_parameters 为所有可用的输出格式执行 <code>declare_parameters</code> ，这样就为每一种格式创建了一个自己的小节，为该特定的输出格式声明参数。(上面 <code>@<1@></code> 的调用中，模板参数的实际值在这里并不重要：该函数做了同样的工作，与维度无关，但恰好是在一个依赖模板参数的类中。)  要想知道哪种输出格式有哪些参数，你可以查阅DataOutBase类的文档，或者干脆在没有参数文件的情况下运行这个程序。然后它将创建一个文件，其中所有声明的参数都设置为默认值，这可以方便地作为一个起点，将参数设置为你想要的值。

      DataOutInterface<1>::declare_parameters(prm); 
    } 
    prm.leave_subsection(); 
  } 
// @sect4{<code>ParameterReader::read_parameters</code>}  

// 这是ParameterReader类中的主函数。 它从外部被调用，首先声明所有的参数，然后从输入文件中读取参数，文件名由调用者提供。对这个函数的调用完成后，可以用 <code>prm</code> 对象来检索从文件中读入的参数值。

  void ParameterReader::read_parameters(const std::string &parameter_file) 
  { 
    declare_parameters(); 

    prm.parse_input(parameter_file); 
  } 

//  @sect3{The <code>ComputeIntensity</code> class}  

// 正如介绍中所提到的，我们真正追求的量是超声波强度的空间分布，它对应于  $|u|=\sqrt{v^2+w^2}$  。现在我们可以只满足于在输出中拥有 $v$ 和 $w$ ，并使用合适的可视化或后处理工具从我们计算的解决方案中得出 $|u|$ 。然而，也有一种方法可以输出从deal.II中的解决方案中得出的数据，我们在这里要利用这个机制。

// 到目前为止，我们一直使用 DataOut::add_data_vector 函数将包含输出数据的向量添加到一个DataOut对象中。 这个函数有一个特殊的版本，除了数据向量之外，还有一个额外的参数类型为DataPostprocessor。当这个函数用于输出时，在每个要生成输出数据的点上，指定的DataPostprocessor对象的 DataPostprocessor::evaluate_scalar_field() 或 DataPostprocessor::evaluate_vector_field() 函数被调用，从数据向量代表的有限元函数的值、梯度和二阶导数计算输出量（在面相关数据的情况下，法向量也是可用的）。因此，这使我们可以输出任何可以从解的值及其导数中局部导出的数量。 当然，超声强度 $|u|$ 就是这样一个量，它的计算甚至不涉及任何 $v$ 或 $w$ 的导数。

// 在实践中，DataPostprocessor类只提供了这个功能的接口，我们需要从它派生出我们自己的类，以实现接口所指定的功能。在最一般的情况下，我们必须实现几个成员函数，但是如果输出量是一个单一的标量，那么其中的一些模板代码可以由一个更专业的类DataPostprocessorScalar来处理，我们可以从这个类派生。这就是 <code>ComputeIntensity</code> 类的作用。

  template <int dim> 
  class ComputeIntensity : public DataPostprocessorScalar<dim> 
  { 
  public: 
    ComputeIntensity(); 

    virtual void evaluate_vector_field( 
      const DataPostprocessorInputs::Vector<dim> &inputs, 
      std::vector<Vector<double>> &computed_quantities) const override; 
  }; 

// 在构造函数中，我们需要用两个参数调用基类的构造函数。第一个参数表示由该类计算的单一标量在输出文件中应表示的名称。在我们的例子中，后处理程序有 $|u|$ 作为输出，所以我们使用 "Intensity"。

// 第二个参数是一组标志，表示后处理程序需要哪些数据来计算输出量。 这可以是update_values、update_gradients和update_hessians（如果是脸部数据，也可以是update_normal_vector）的任何一个子集，这些都在UpdateFlags中记录。 当然，导数的计算需要额外的资源，所以这里只应该给出真正需要的数据的标志，就像我们使用FEValues对象时一样。在我们的例子中，只有  $v$  和  $w$  的函数值需要用来计算  $|u|$  ，所以我们用 update_values 标志就可以了。

  template <int dim> 
  ComputeIntensity<dim>::ComputeIntensity() 
    : DataPostprocessorScalar<dim>("Intensity", update_values) 
  {} 

// 实际的后处理发生在下面这个函数中。它的输入是一个存储函数值的对象（这里是向量值），代表给 DataOut::add_data_vector, 的数据向量在我们产生输出的所有评估点的评估值，以及一些代表导数的张量对象（我们在这里没有使用，因为 $|u|$ 只是从 $v$ 和 $w$ 计算出来）。派生量在 <code>computed_quantities</code> 向量中返回。请记住，这个函数只能使用由  <code>get_needed_update_flags</code>  指定的各自更新标志的数据。例如，我们可能不会在这里使用导数，因为我们对  <code>get_needed_update_flags</code>  的实现要求只提供函数值。

  template <int dim> 
  void ComputeIntensity<dim>::evaluate_vector_field( 
    const DataPostprocessorInputs::Vector<dim> &inputs, 
    std::vector<Vector<double>> &               computed_quantities) const 
  { 
    Assert(computed_quantities.size() == inputs.solution_values.size(), 
           ExcDimensionMismatch(computed_quantities.size(), 
                                inputs.solution_values.size())); 

// 计算本身是很简单的。我们遍历输出向量中的每个条目，并从 $v$ 和 $w$ 的相应值中计算出 $|u|$ 。我们通过创建一个复数 $u$ ，然后对结果调用 `std::abs()` 来实现。(我们可能想调用 `std::norm()`, ，但是在一个历史的怪圈中，C++委员会决定 `std::norm()` 应该返回绝对值的<i>square</i>--从而不满足数学家对所谓 "规范 "的属性要求。)

    for (unsigned int i = 0; i < computed_quantities.size(); i++) 
      { 
        Assert(computed_quantities[i].size() == 1, 
               ExcDimensionMismatch(computed_quantities[i].size(), 1)); 
        Assert(inputs.solution_values[i].size() == 2, 
               ExcDimensionMismatch(inputs.solution_values[i].size(), 2)); 

        const std::complex<double> u(inputs.solution_values[i](0), 
                                     inputs.solution_values[i](1)); 

        computed_quantities[i](0) = std::abs(u); 
      } 
  } 
// @sect3{The <code>UltrasoundProblem</code> class}  

// 最后这里是这个程序的主类。 它的成员函数与前面的例子非常相似，特别是 step-4 ，成员变量的列表也没有什么大的惊喜。传递给构造函数的ParameterHandler对象被存储为一个引用，以便于从该类的所有函数中访问参数。 由于我们正在使用矢量值的有限元，我们使用的FE对象是FESystem类型的。

  template <int dim> 
  class UltrasoundProblem 
  { 
  public: 
    UltrasoundProblem(ParameterHandler &); 
    void run(); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void output_results() const; 

    ParameterHandler &prm; 

    Triangulation<dim> triangulation; 
    DoFHandler<dim>    dof_handler; 
    FESystem<dim>      fe; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 
    Vector<double>       solution, system_rhs; 
  }; 

// 构造函数接收ParameterHandler对象并将其存储在一个引用中。它还初始化了DoF-Handler和有限元系统，该系统由标量Q1场的两个副本组成，一个用于 $v$ ，一个用于 $w$  。

  template <int dim> 
  UltrasoundProblem<dim>::UltrasoundProblem(ParameterHandler &param) 
    : prm(param) 
    , dof_handler(triangulation) 
    , fe(FE_Q<dim>(1), 2) 
  {} 
// @sect4{<code>UltrasoundProblem::make_grid</code>}  

// 这里我们为我们的领域设置网格。 正如论述中所提到的，这个几何体只是一个单位正方形（2d），其边界部分代表换能器透镜，由一个圆的扇形代替。

  template <int dim> 
  void UltrasoundProblem<dim>::make_grid() 
  { 

// 首先我们生成一些日志输出，并启动一个定时器，这样我们就可以在这个函数完成后计算出执行时间。

    std::cout << "Generating grid... "; 
    Timer timer; 

// 然后，我们从ParameterHandler对象中查询换能器镜头的焦距和网格细化步数的值。

    prm.enter_subsection("Mesh & geometry parameters"); 

    const double       focal_distance = prm.get_double("Focal distance"); 
    const unsigned int n_refinements = prm.get_integer("Number of refinements"); 

    prm.leave_subsection(); 

// 接下来，为换能器镜头的位置和焦点定义了两个点，也就是圆的中心，其线段将形成边界的换能器部分。注意，这是程序中唯一一个在二维和三维中略有不同的地方。尽管本教程只涉及二维情况，但要使这个程序在三维中发挥作用，必要的补充是非常少的，所以我们选择包括它们。

    const Point<dim> transducer = 
      (dim == 2) ? Point<dim>(0.5, 0.0) : Point<dim>(0.5, 0.5, 0.0); 
    const Point<dim> focal_point = (dim == 2) ? 
                                     Point<dim>(0.5, focal_distance) : 
                                     Point<dim>(0.5, 0.5, focal_distance); 

// 作为初始粗网格，我们采用一个简单的单位正方形，每个方向上有5个细分。分区的数量是这样选择的：我们想指定为传感器边界的线段 $[0.4,0.6]$ 是由一个面来跨越的。然后，我们通过所有的单元格，找到换能器所在的面，事实上，这只是X轴上从0.4到0.6的一条边。这是我们希望根据圆环形边界进行细化的地方，所以我们用不同的流形指标来标记这个边缘。由于我们要在换能器上设置迪里希特边界条件，所以我们也要改变其边界指标。

    GridGenerator::subdivided_hyper_cube(triangulation, 5, 0, 1); 

    for (auto &cell : triangulation.cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->at_boundary() && 
            ((face->center() - transducer).norm_square() < 0.01)) 
          { 
            face->set_boundary_id(1); 
            face->set_manifold_id(1); 
          } 

// 对于换能器镜头的圆形部分，使用了一个SphericalManifold对象（当然，在2D中只是代表一个圆），中心的计算方法如上。

    triangulation.set_manifold(1, SphericalManifold<dim>(focal_point)); 

// 现在，全局细化被执行。靠近换能器位置的单元格将根据换能器透镜的圆形边界被自动细化。

    triangulation.refine_global(n_refinements); 

// 最后，我们再生成一些日志输出。我们停止定时器，并查询自函数开始以来所经过的CPU秒数。

    timer.stop(); 
    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl; 

    std::cout << "  Number of active cells:  " << triangulation.n_active_cells() 
              << std::endl; 
  } 
// @sect4{<code>UltrasoundProblem::setup_system</code>}  

// 系统矩阵的初始化、稀疏模式和向量与前面的例子相同，因此不需要进一步评论。和前面的函数一样，我们也输出我们在这里所做的运行时间。

  template <int dim> 
  void UltrasoundProblem<dim>::setup_system() 
  { 
    std::cout << "Setting up system... "; 
    Timer timer; 

    dof_handler.distribute_dofs(fe); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
    system_rhs.reinit(dof_handler.n_dofs()); 
    solution.reinit(dof_handler.n_dofs()); 

    timer.stop(); 
    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl; 

    std::cout << "  Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 
  } 
// @sect4{<code>UltrasoundProblem::assemble_system</code>}  

// 和以前一样，这个函数负责组装系统矩阵和右手边的向量。

  template <int dim> 
  void UltrasoundProblem<dim>::assemble_system() 
  { 
    std::cout << "Assembling system matrix... "; 
    Timer timer; 

// 首先我们从ParameterHandler对象中查询波速和频率，并将其存储在本地变量中，因为它们将在本函数中频繁使用。

    prm.enter_subsection("Physical constants"); 

    const double omega = prm.get_double("omega"), c = prm.get_double("c"); 

    prm.leave_subsection(); 

// 像往常一样，计算积分时使用普通的高斯正交规则。由于我们的双线性形式涉及到 $\Gamma_2$ 上的边界积分，所以我们还需要一个正交法则来计算面的积分，这些面是 $dim-1$ 维的。

    QGauss<dim>     quadrature_formula(fe.degree + 1); 
    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1); 

    const unsigned int n_q_points      = quadrature_formula.size(), 
                       n_face_q_points = face_quadrature_formula.size(), 
                       dofs_per_cell   = fe.n_dofs_per_cell(); 

// FEValues对象将为我们评估形状函数。 对于涉及到 $\Omega$ 上的积分的双线性形式的部分，我们需要形状函数的值和梯度，当然还有正交权重。 对于涉及边界积分的条款，只需要形状函数值和正交权重。

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_JxW_values); 

    FEFaceValues<dim> fe_face_values(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_JxW_values); 

// 像往常一样，系统矩阵是逐个单元组装的，我们需要一个矩阵来存储本地单元的贡献，以及一个索引向量来将单元的贡献转移到全局系统矩阵中的适当位置，然后。

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 

// 在每个单元，我们首先需要重置本地贡献矩阵，并请求FEValues对象计算当前单元的形状函数。

        cell_matrix = 0; 
        fe_values.reinit(cell); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              { 

// 在这一点上，重要的是要记住，我们所处理的是一个有两个组成部分的有限元系统。由于我们构造这个FESystem的方式，即作为两个标量有限元场的笛卡尔乘积，每个形状函数只有一个非零分量（用deal.II的行话说，它们是 @ref  GlossPrimitive "原始"）。 因此，每个形状函数可以被看作是引言中的 $\phi$ 's或 $\psi$ 's之一，同样，相应的自由度也可以归属于 $\alpha$ 或 $\beta$  。      然而，当我们遍历当前单元上的所有自由度时，它们并不以任何特定的顺序出现，因此我们无法立即决定索引为 $i$ 和 $j$ 的自由度是属于我们解决方案的实部还是虚部。 另一方面，如果你看一下介绍中的系统矩阵的形式，这个区别是至关重要的，因为它将决定当前一对DoF的贡献将归入系统矩阵的哪个块，因此我们需要从给定的两个形状函数中计算哪个数量。 幸运的是，FESystem对象可以为我们提供这些信息，即它有一个函数 FESystem::system_to_component_index, ，为每个局部的DoF索引返回一对整数，其中第一个表示该DoF属于系统的哪个组成部分。这对整数中的第二个整数表示该DoF在标量基有限元场中的索引，但这一信息在这里并不相关。如果你想知道更多关于这个函数和原始向量值元素背后的基本方案，可以看看 step-8 或 @ref vector_valued 模块，那里对这些主题有深入的解释。

                if (fe.system_to_component_index(i).first == 
                    fe.system_to_component_index(j).first) 
                  { 

// 如果DoF $i$ 和 $j$ 都属于同一个分量，即它们的形状函数都是 $\phi$ 的，或者都是 $\psi$ 的，贡献将最终出现在我们系统矩阵的一个对角块中，由于相应的条目是由同一个公式计算的，我们不必理会它们实际上是 $\phi$ 还是 $\psi$ 形状函数。我们可以简单地通过遍历所有正交点并将其贡献相加来计算条目，其中形状函数的值和梯度由我们的FEValues对象提供。

                    for (unsigned int q_point = 0; q_point < n_q_points; 
                         ++q_point) 
                      cell_matrix(i, j) += 
                        (((fe_values.shape_value(i, q_point) * 
                           fe_values.shape_value(j, q_point)) * 
                            (-omega * omega) + 
                          (fe_values.shape_grad(i, q_point) * 
                           fe_values.shape_grad(j, q_point)) * 
                            c * c) * 
                         fe_values.JxW(q_point)); 

// 你可能认为我们在向FEValues对象请求形状函数值或梯度时，必须指定我们想评估的形状函数的哪个分量。然而，由于形状函数是原始的，它们只有一个非零分量，而且FEValues类足够聪明，它知道我们肯定对这一个非零分量感兴趣。

                  } 
              } 
          } 

// 我们还必须增加由于边界项的贡献。为此，我们对当前单元格的所有面进行循环，首先看它是否在边界上，其次看它是否有与 $\Gamma_2$ 相关的正确的边界指标，即我们有吸收边界条件的那部分边界。

        for (const auto face_no : cell->face_indices()) 
          if (cell->face(face_no)->at_boundary() && 
              (cell->face(face_no)->boundary_id() == 0)) 
            { 

// 这些面肯定会对系统矩阵的非对角线块作出贡献，所以我们要求FEFaceValues对象为我们提供这个面上的形状函数值。

              fe_face_values.reinit(cell, face_no); 

// 接下来，我们循环浏览当前单元格的所有DoF，找到属于不同组件且都支持当前面号的一对。

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                  if ((fe.system_to_component_index(i).first != 
                       fe.system_to_component_index(j).first) && 
                      fe.has_support_on_face(i, face_no) && 
                      fe.has_support_on_face(j, face_no)) 

// 检查形状函数在一个面上是否有支持并不是严格必要的：如果我们不检查它，我们会简单地把本地单元矩阵的项加起来，这些项碰巧是零，因为至少有一个形状函数碰巧是零。然而，我们可以通过添加上面的检查来节省这项工作。

// 在任何一种情况下，这些DoFs都会对系统矩阵的对角线区块的边界积分作出贡献。为了计算积分，我们在面的所有正交点上进行循环，然后用面的正交规则提供的正交权重对贡献进行加权求和。 与对角线块上的条目不同，这里的形状函数哪一个是 $\psi$ ，哪一个是 $\phi$ ，确实很重要，因为这将决定该条目的符号。 我们通过一个简单的条件语句来说明这一点，它决定了正确的符号。由于我们已经检查了DoF  $i$  和  $j$  属于不同的组件，这里只需测试其中一个组件属于哪个组件即可。

                    for (unsigned int q_point = 0; q_point < n_face_q_points; 
                         ++q_point) 
                      cell_matrix(i, j) += 
                        ((fe.system_to_component_index(i).first == 0) ? -1 : 
                                                                        1) * 
                        fe_face_values.shape_value(i, q_point) * 
                        fe_face_values.shape_value(j, q_point) * c * omega * 
                        fe_face_values.JxW(q_point); 
            } 

// 现在，我们已经完成了这个单元，必须将其贡献从本地系统矩阵转移到全局系统矩阵。为此，我们首先得到这个单元的全局指数列表......

        cell->get_dof_indices(local_dof_indices); 

// ...然后将这些条目逐一添加到系统矩阵中。

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 
      } 

// 唯一剩下的是 $\Gamma_1$ 上的迪里希特边界值，其特征是边界指标1。Dirichlet值由我们上面定义的 <code>DirichletBoundaryValues</code> 类提供。

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             1, 
                                             DirichletBoundaryValues<dim>(), 
                                             boundary_values); 

    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       solution, 
                                       system_rhs); 

    timer.stop(); 
    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl; 
  } 

//  @sect4{<code>UltrasoundProblem::solve</code>}  

// 正如介绍中已经提到的，系统矩阵既不是对称的，也不是确定的，因此，如何提出一个迭代求解器和预处理器来很好地处理这个矩阵并不是很明显。 我们选择了另一种方式，用UMFPACK提供的稀疏LU分解来解决线性系统。这通常是二维问题的一个很好的首选，即使对于大量的DoF也能很好地工作。 SparseDirectUMFPACK类提供了UMFPACK的deal.II接口，它非常容易使用，使我们仅用3行代码就能解决我们的线性系统。

// 再次注意，为了编译这个例子程序，你需要有支持UMFPACK的deal.II库。

  template <int dim> 
  void UltrasoundProblem<dim>::solve() 
  { 
    std::cout << "Solving linear system... "; 
    Timer timer; 

// 解决线性系统的代码很短：首先，我们分配一个正确类型的对象。下面的 <code>initialize</code> 调用提供了我们想要反转的矩阵给SparseDirectUMFPACK对象，并同时启动了LU分解。因此，这也是这个程序中大部分计算工作发生的地方。

    SparseDirectUMFPACK A_direct; 
    A_direct.initialize(system_matrix); 

// 分解之后，我们可以把 <code>A_direct</code> 当作代表我们系统矩阵的逆矩阵来使用，所以要计算出解决方案，我们只需要与右边的向量相乘。

    A_direct.vmult(solution, system_rhs); 

    timer.stop(); 
    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl; 
  } 

//  @sect4{<code>UltrasoundProblem::output_results</code>}  

// 这里我们按照参数文件中指定的格式输出我们的解 $v$ 和 $w$ 以及导出的量 $|u|$ 。从 $v$ 和 $w$ 导出 $|u|$ 的大部分工作已经在 <code>ComputeIntensity</code> 类的实现中完成，因此输出程序相当简单，与前面教程中的内容非常相似。

  template <int dim> 
  void UltrasoundProblem<dim>::output_results() const 
  { 
    std::cout << "Generating output... "; 
    Timer timer; 

// 定义我们的  <code>ComputeIntensity</code>  类的对象和一个 DataOut 对象。

    ComputeIntensity<dim> intensities; 
    DataOut<dim>          data_out; 

    data_out.attach_dof_handler(dof_handler); 

// 接下来我们从ParameterHandler查询输出相关的参数。 DataOut::parse_parameters  调用作为  <code>ParameterReader::declare_parameters</code>  中  DataOutInterface<1>::declare_parameters  调用的对应方。它从ParameterHandler收集所有与输出格式相关的参数，并相应地设置DataOut对象的相应属性。

    prm.enter_subsection("Output parameters"); 

    const std::string output_filename = prm.get("Output filename"); 
    data_out.parse_parameters(prm); 

    prm.leave_subsection(); 

// 现在，我们从ParameterHandler提供的基本名称和DataOut类提供的后缀（默认后缀被设置为正确的类型，与.prm文件中通过parse_parameters()设置的后缀相匹配）来组合文件名。

    const std::string filename = output_filename + data_out.default_suffix(); 

    std::ofstream output(filename); 

//解向量 $v$ 和 $w$ 以常规方式添加到DataOut对象中。

    std::vector<std::string> solution_names; 
    solution_names.emplace_back("Re_u"); 
    solution_names.emplace_back("Im_u"); 

    data_out.add_data_vector(solution, solution_names); 

// 对于强度，我们只是再次调用 <code>add_data_vector</code> ，但这次用我们的 <code>ComputeIntensity</code> 对象作为第二个参数，这实际上是将 $|u|$ 加入到输出数据中。

    data_out.add_data_vector(solution, intensities); 

// 最后的步骤和以前一样。注意，现在实际的输出格式是由输入文件中的内容决定的，也就是说，人们可以改变输出格式而不必重新编译这个程序。

    data_out.build_patches(); 
    data_out.write(output); 

    timer.stop(); 
    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl; 
  } 

//  @sect4{<code>UltrasoundProblem::run</code>}  

// 这里我们简单地一个接一个地执行我们的函数。

  template <int dim> 
  void UltrasoundProblem<dim>::run() 
  { 
    make_grid(); 
    setup_system(); 
    assemble_system(); 
    solve(); 
    output_results(); 
  } 
} // namespace Step29 
// @sect4{The <code>main</code> function}  

// 最后是该程序的 <code>main</code> 功能。它的结构与其他几乎所有的教程程序相同。唯一的例外是，我们定义了ParameterHandler和 <code>ParameterReader</code> 对象，并让后者从一个名为 <code>step-29.prm</code> 的文本文件中读入参数值。这样读到的值会被交给UltrasoundProblem类的一个实例。

int main() 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step29; 

      ParameterHandler prm; 
      ParameterReader  param(prm); 
      param.read_parameters("step-29.prm"); 

      UltrasoundProblem<2> ultrasound_problem(prm); 
      ultrasound_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 


CCTest_file/step-3.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 1999 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Wolfgang Bangerth, 1999, 
 *          Guido Kanschat, 2011 
 */ 


// @sect3{Many new include files}  

// 这些包含文件已经为你所知。它们声明了处理三角形和自由度枚举的类。

#include <deal.II/grid/tria.h> 
#include <deal.II/dofs/dof_handler.h> 

// 在这个文件中声明了创建网格的函数。

#include <deal.II/grid/grid_generator.h> 

// 这个文件包含了对拉格朗日插值有限元的描述。

#include <deal.II/fe/fe_q.h> 

// 而这个文件是创建稀疏矩阵的稀疏模式所需要的，如前面的例子中所示。

#include <deal.II/dofs/dof_tools.h> 

// 接下来的两个文件是在每个单元上使用正交法组装矩阵所需要的。下面将对其中声明的类进行解释。

#include <deal.II/fe/fe_values.h> 
#include <deal.II/base/quadrature_lib.h> 

// 以下是我们在处理边界值时需要的三个包含文件。

#include <deal.II/base/function.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 

// 我们现在几乎到了终点。第二组到最后一组include文件是用于线性代数的，我们用它来解决拉普拉斯方程的有限元离散化所产生的方程组。我们将使用向量和全矩阵在每个单元中组装方程组，并将结果转移到稀疏矩阵中。然后我们将使用共轭梯度求解器来解决这个问题，为此我们需要一个预处理程序（在这个程序中，我们使用身份预处理程序，它没有任何作用，但我们还是需要包括这个文件）。

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 

// 最后，这是为了输出到文件和控制台。

#include <deal.II/numerics/data_out.h> 
#include <fstream> 
#include <iostream> 

// ...这是为了将deal.II命名空间导入到全局范围。

using namespace dealii; 
// @sect3{The <code>Step3</code> class}  

// 在这个程序中，我们没有采用以前例子中的程序化编程，而是将所有东西都封装到一个类中。这个类由一些函数组成，这些函数分别执行有限元程序的某些方面，一个`main`函数控制先做什么和后做什么，还有一个成员变量列表。

// 该类的公共部分相当简短：它有一个构造函数和一个从外部调用的函数`run`，其作用类似于`main`函数：它协调该类的哪些操作应以何种顺序运行。该类中的其他东西，即所有真正做事情的函数，都在该类的私有部分。

class Step3 
{ 
public: 
  Step3(); 

  void run(); 

// 然后，还有一些成员函数，它们主要是做它们名字所暗示的事情，在介绍中已经讨论过了。由于它们不需要从外部调用，所以它们是本类的私有函数。

private: 
  void make_grid(); 
  void setup_system(); 
  void assemble_system(); 
  void solve(); 
  void output_results() const; 

// 最后我们还有一些成员变量。有一些变量描述了三角形和自由度的全局编号（我们将在这个类的构造函数中指定有限元的确切多项式程度）...

  Triangulation<2> triangulation; 
  FE_Q<2>          fe; 
  DoFHandler<2>    dof_handler; 

// ...拉普拉斯方程离散化产生的系统矩阵的稀疏模式和数值的变量...

  SparsityPattern      sparsity_pattern; 
  SparseMatrix<double> system_matrix; 

// .......以及用于保存右手边和解决方案向量的变量。

  Vector<double> solution; 
  Vector<double> system_rhs; 
}; 
// @sect4{Step3::Step3}  

// 这里是构造函数。它除了首先指定我们需要双线性元素（由有限元对象的参数表示，它表示多项式的程度），并将dof_handler变量与我们使用的三角形相关联之外，没有做更多的工作。(注意，目前三角结构并没有设置网格，但是DoFHandler并不关心：它只想知道它将与哪个三角结构相关联，只有当你使用distribution_dofs()函数试图在网格上分布自由度时，它才开始关心实际的网格。) Step3类的所有其他成员变量都有一个默认的构造函数，它可以完成我们想要的一切。

Step3::Step3() 
  : fe(1) 
  , dof_handler(triangulation) 
{} 
// @sect4{Step3::make_grid}  

// 现在，我们要做的第一件事是生成我们想在其上进行计算的三角形，并对每个顶点进行自由度编号。我们之前在 step-1 和 step-2 中分别看到过这两个步骤。

// 这个函数做的是第一部分，创建网格。 我们创建网格并对所有单元格进行五次细化。由于初始网格（也就是正方形 $[-1,1] \times [-1,1]$ ）只由一个单元组成，所以最终的网格有32乘以32个单元，总共是1024个。

// 不确定1024是否是正确的数字？我们可以通过使用三角形上的 <code>n_active_cells()</code> 函数输出单元格的数量来检查。

void Step3::make_grid() 
{ 
  GridGenerator::hyper_cube(triangulation, -1, 1); 
  triangulation.refine_global(5); 

  std::cout << "Number of active cells: " << triangulation.n_active_cells() 
            << std::endl; 
} 
// @note  我们调用 Triangulation::n_active_cells() 函数，而不是 Triangulation::n_cells(). 这里，<i>active</i>指的是没有进一步提炼的单元。我们强调 "活跃 "这个形容词，因为还有更多的单元，即最细的单元的父单元，它们的父单元等等，直到构成初始网格的一个单元为止。当然，在下一个更粗的层次上，单元格的数量是最细层次上的单元格的四分之一，即256，然后是64、16、4和1。如果你在上面的代码中调用 <code>triangulation.n_cells()</code> ，你会因此得到一个1365的值。另一方面，单元格的数量（相对于活动单元格的数量）通常没有什么意义，所以没有很好的理由去打印它。

//  @sect4{Step3::setup_system}  

// 接下来我们列举所有的自由度，并建立矩阵和向量对象来保存系统数据。枚举是通过使用 DoFHandler::distribute_dofs(), 来完成的，我们在 step-2 的例子中已经看到了。由于我们使用了FE_Q类，并且在构造函数中设置了多项式的度数为1，即双线性元素，这就将一个自由度与每个顶点联系起来。当我们在生成输出时，让我们也看看有多少自由度被生成。

void Step3::setup_system() 
{ 
  dof_handler.distribute_dofs(fe); 
  std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
            << std::endl; 

// 每个顶点应该有一个DoF。因为我们有一个32乘以32的网格，所以DoFs的数量应该是33乘以33，即1089。

// 正如我们在前面的例子中所看到的，我们通过首先创建一个临时结构，标记那些可能为非零的条目，然后将数据复制到SparsityPattern对象中，然后可以被系统矩阵使用，来设置一个稀疏模式。

  DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
  DoFTools::make_sparsity_pattern(dof_handler, dsp); 
  sparsity_pattern.copy_from(dsp); 

// 注意，SparsityPattern对象并不保存矩阵的值，它只保存条目所在的位置。条目本身存储在SparseMatrix类型的对象中，我们的变量system_matrix就是其中之一。

// 稀疏模式和矩阵之间的区别是为了让几个矩阵使用相同的稀疏模式。这在这里似乎并不重要，但是当你考虑到矩阵的大小，以及建立稀疏模式可能需要一些时间时，如果你必须在程序中存储几个矩阵，这在大规模问题中就变得很重要了。

  system_matrix.reinit(sparsity_pattern); 

// 在这个函数中要做的最后一件事是将右侧向量和解向量的大小设置为正确的值。

  solution.reinit(dof_handler.n_dofs()); 
  system_rhs.reinit(dof_handler.n_dofs()); 
} 
// @sect4{Step3::assemble_system}  

// 下一步是计算形成线性系统的矩阵和右手边的条目，我们从中计算出解决方案。这是每一个有限元程序的核心功能，我们在介绍中已经讨论了主要步骤。

// 组装矩阵和向量的一般方法是在所有单元上循环，并在每个单元上通过正交计算该单元对全局矩阵和右侧的贡献。现在要认识到的一点是，我们需要实心单元上正交点位置的形状函数值。然而，有限元形状函数和正交点都只定义在参考单元上。因此，它们对我们帮助不大，事实上，我们几乎不会直接从这些对象中查询有关有限元形状函数或正交点的信息。

// 相反，我们需要的是一种将这些数据从参考单元映射到实际单元的方法。能够做到这一点的类都是由Mapping类派生出来的，尽管人们常常不必直接与它们打交道：库中的许多函数都可以将映射对象作为参数，但当它被省略时，它们只是简单地诉诸于标准的双线性Q1映射。我们将走这条路，暂时不打扰它（我们将在 step-10 、 step-11 和 step-12 中再讨论这个问题）。

// 所以我们现在有三个类的集合来处理：有限元、正交、和映射对象。这就太多了，所以有一种类型的类可以协调这三者之间的信息交流：FEValues类。如果给这三个对象各一个实例（或两个，以及一个隐式线性映射），它就能为你提供实心单元上正交点的形状函数值和梯度的信息。

// 利用所有这些，我们将把这个问题的线性系统组装在以下函数中。

void Step3::assemble_system() 
{ 

// 好的，我们开始吧：我们需要一个正交公式来计算每个单元格的积分。让我们采用一个高斯公式，每个方向有两个正交点，即总共有四个点，因为我们是在二维。这个正交公式可以准确地积分三度以下的多项式（在一维）。很容易检查出，这对目前的问题来说是足够的。

  QGauss<2> quadrature_formula(fe.degree + 1); 

// 然后我们初始化我们在上面简单谈及的对象。它需要被告知我们要使用哪个有限元，以及正交点和它们的权重（由一个正交对象共同描述）。如前所述，我们使用隐含的Q1映射，而不是自己明确指定一个。最后，我们必须告诉它我们希望它在每个单元上计算什么：我们需要正交点的形状函数值（对于右手 $(\varphi_i,f)$ ），它们的梯度（对于矩阵条目 $(\nabla \varphi_i, \nabla \varphi_j)$ ），以及正交点的权重和从参考单元到实际单元的雅各布变换的行列式。

// 我们实际需要的信息列表是作为FEValues构造函数的第三个参数的标志集合给出的。由于这些值必须重新计算，或者说更新，每次我们进入一个新的单元时，所有这些标志都以前缀 <code>update_</code> 开始，然后指出我们想要更新的实际内容。如果我们想要计算形状函数的值，那么给出的标志是#update_values；对于梯度，它是#update_gradients。雅各布的行列式和正交权重总是一起使用的，所以只计算乘积（雅各布乘以权重，或者简称 <code>JxW</code> ）；由于我们需要它们，我们必须同时列出#update_JxW_values。

  FEValues<2> fe_values(fe, 
                        quadrature_formula, 
                        update_values | update_gradients | update_JxW_values); 

// 这种方法的优点是，我们可以指定每个单元上究竟需要什么样的信息。很容易理解的是，这种方法可以大大加快有限元计算的速度，相比之下，所有的东西，包括二阶导数、单元的法向量等都在每个单元上计算，不管是否需要它们。

//  @note  <code>update_values | update_gradients | update_JxW_values</code>的语法对于那些不习惯用C语言编程多年的位操作的人来说不是很明显。首先， <code>operator|</code> 是<i>bitwise or operator</i>，也就是说，它接受两个整数参数，这些参数被解释为比特模式，并返回一个整数，其中每个比特都被设置，因为在两个参数中至少有一个的对应比特被设置。例如，考虑操作 <code>9|10</code>. In binary, <code>9=0b1001</code> （其中前缀 <code>0b</code> 表示该数字将被解释为二进制数字）和 <code>10=0b1010</code>  。通过每个比特，看它是否在其中一个参数中被设置，我们得出 <code>0b1001|0b1010=0b1011</code> ，或者用十进制符号表示， <code>9|10=11</code>  。你需要知道的第二个信息是，各种 <code>update_*</code> 标志都是有<i>exactly one bit set</i>的整数。例如，假设  <code>update_values=0b00001=1</code>  ,  <code>update_gradients=0b00010=2</code>  ,  <code>update_JxW_values=0b10000=16</code>  。那么<code>update_values | update_gradients | update_JxW_values = 0b10011 = 19</code>。换句话说，我们得到一个数字，即<i>encodes a binary mask representing all of the operations you want to happen</i>，其中每个操作正好对应于整数中的一个位，如果等于1，意味着每个单元格上应该更新一个特定的片断，如果是0，意味着我们不需要计算它。换句话说，即使 <code>operator|</code> 是<i>bitwise OR operation</i>，它真正代表的是<i>I want this AND that AND the other</i>。这样的二进制掩码在C语言编程中很常见，但在C++这样的高级语言中也许不是这样，但对当前的目的有很好的作用。

// 为了在下文中进一步使用，我们为一个将被频繁使用的值定义了一个快捷方式。也就是每个单元的自由度数的缩写（因为我们是在二维，自由度只与顶点相关，所以这个数字是4，但是我们更希望在写这个变量的定义时，不妨碍我们以后选择不同的有限元，每个单元有不同的自由度数，或者在不同的空间维度工作）。

// 一般来说，使用符号名称而不是硬编码这些数字是个好主意，即使你知道它们，因为例如，你可能想在某个时候改变有限元。改变元素就必须在不同的函数中进行，而且很容易忘记在程序的另一部分做相应的改变。最好不要依赖自己的计算，而是向正确的对象索取信息。在这里，我们要求有限元告诉我们每个单元的自由度数，无论我们在程序中的其他地方选择什么样的空间尺寸或多项式程度，我们都会得到正确的数字。

// 这里定义的快捷方式主要是为了讨论基本概念，而不是因为它节省了大量的输入，然后会使下面的循环更容易阅读。在大型程序中，你会在很多地方看到这样的快捷方式，`dofs_per_cell`就是一个或多或少是这类对象的传统名称。

  const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

// 现在，我们说我们想逐个单元地组装全局矩阵和向量。我们可以将结果直接写入全局矩阵，但是这样做的效率并不高，因为对稀疏矩阵元素的访问是很慢的。相反，我们首先在一个小矩阵中计算每个单元的贡献，并在这个单元的计算结束后将其转移到全局矩阵中。我们对右手边的向量也是这样做的。所以我们首先分配这些对象（这些是局部对象，所有的自由度都与所有其他的自由度耦合，我们应该使用一个完整的矩阵对象，而不是一个用于局部操作的稀疏矩阵；以后所有的东西都将转移到全局的稀疏矩阵中）。

  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
  Vector<double>     cell_rhs(dofs_per_cell); 

// 在集合每个单元的贡献时，我们用自由度的局部编号（即从零到dofs_per_cell-1的编号）来做。然而，当我们将结果转移到全局矩阵时，我们必须知道自由度的全局编号。当我们查询它们时，我们需要为这些数字建立一个从头开始的（临时）数组（关于这里使用的类型， types::global_dof_index, ，见介绍末尾的讨论）。

  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 现在是所有单元格的循环。我们之前已经看到这对一个三角形是如何工作的。DoFHandler的单元格迭代器与Triangulation的迭代器完全类似，但有关于你所使用的有限元的自由度的额外信息。在自由度处理程序的活动单元上进行循环操作的方法与三角法相同。

// 注意，这次我们将单元的类型声明为`const auto &`，而不是`auto`。在第1步中，我们通过用细化指标标记来修改三角形的单元。在这里，我们只检查单元格而不修改它们，所以把`cell`声明为`const`是很好的做法，以便执行这个不变性。

  for (const auto &cell : dof_handler.active_cell_iterators()) 
    { 

// 我们现在坐在一个单元上，我们希望计算形状函数的值和梯度，以及参考单元和真实单元之间映射的雅各布矩阵的行列式，在正交点上。由于所有这些值都取决于单元格的几何形状，我们必须让FEValues对象在每个单元格上重新计算它们。

      fe_values.reinit(cell); 

// 接下来，在我们填充之前，将本地单元对全局矩阵和全局右手边的贡献重置为零。

      cell_matrix = 0; 
      cell_rhs    = 0; 

// 现在是时候开始对单元进行积分了，我们通过对所有的正交点进行循环来完成，我们将用q_index来编号。

      for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
        { 

// 首先组装矩阵。对于拉普拉斯问题，每个单元格上的矩阵是形状函数i和j的梯度的积分。由于我们不进行积分，而是使用正交，所以这是在所有正交点的积分之和乘以正交点的雅各布矩阵的行列式乘以这个正交点的权重。你可以通过使用 <code>fe_values.shape_grad(i,q_index)</code> 得到形状函数 $i$ 在数字q_index的正交点上的梯度；这个梯度是一个二维向量（事实上它是张量 @<1,dim@>, 类型，这里dim=2），两个这样的向量的乘积是标量乘积，即两个shape_grad函数调用的积是点乘。这又要乘以雅各布行列式和正交点权重（通过调用 FEValues::JxW() 得到）。最后，对所有形状函数 $i$ 和 $j$ 重复上述操作。

          for (const unsigned int i : fe_values.dof_indices()) 
            for (const unsigned int j : fe_values.dof_indices()) 
              cell_matrix(i, j) += 
                (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q) 
                 fe_values.shape_grad(j, q_index) * // grad phi_j(x_q) 
                 fe_values.JxW(q_index));           // dx 

// 然后我们对右手边做同样的事情。在这里，积分是对形状函数i乘以右手边的函数，我们选择的是常值为1的函数（更有趣的例子将在下面的程序中考虑）。

          for (const unsigned int i : fe_values.dof_indices()) 
            cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q) 
                            1. *                                // f(x_q) 
                            fe_values.JxW(q_index));            // dx 
        } 

// 现在我们有了这个单元的贡献，我们必须把它转移到全局矩阵和右手边。为此，我们首先要找出这个单元上的自由度有哪些全局数字。让我们简单地询问该单元的信息。

      cell->get_dof_indices(local_dof_indices); 

// 然后再次循环所有形状函数i和j，并将局部元素转移到全局矩阵中。全局数字可以用local_dof_indices[i]获得。

      for (const unsigned int i : fe_values.dof_indices()) 
        for (const unsigned int j : fe_values.dof_indices()) 
          system_matrix.add(local_dof_indices[i], 
                            local_dof_indices[j], 
                            cell_matrix(i, j)); 

// 再来，我们对右边的向量做同样的事情。

      for (const unsigned int i : fe_values.dof_indices()) 
        system_rhs(local_dof_indices[i]) += cell_rhs(i); 
    } 

// 现在，几乎所有的东西都为离散系统的求解做好了准备。然而，我们还没有照顾到边界值（事实上，没有迪里切特边界值的拉普拉斯方程甚至不是唯一可解的，因为你可以在离散解中加入一个任意的常数）。因此，我们必须对这种情况做一些处理。

// 为此，我们首先获得边界上的自由度列表以及形状函数在那里的值。为了简单起见，我们只对边界值函数进行插值，而不是将其投影到边界上。库中有一个函数正是这样做的。  VectorTools::interpolate_boundary_values(). 它的参数是（省略存在默认值而我们不关心的参数）：DoFHandler对象，用于获取边界上自由度的全局数字；边界上边界值应被内插的部分；边界值函数本身；以及输出对象。

// 边界分量的含义如下：在很多情况下，你可能只想在边界的一部分施加某些边界值。例如，在流体力学中，你可能有流入和流出的边界，或者在身体变形计算中，身体的夹紧和自由部分。那么你就想用指标来表示边界的这些不同部分，并告诉interpolate_boundary_values函数只计算边界的某一部分（例如夹住的部分，或流入的边界）的边界值。默认情况下，所有的边界都有一个0的边界指标，除非另有规定。如果边界的部分有不同的边界条件，你必须用不同的边界指示器为这些部分编号。然后，下面的函数调用将只确定那些边界指标实际上是作为第二个参数指定的0的边界部分的边界值。

// 描述边界值的函数是一个Function类型的对象或一个派生类的对象。其中一个派生类是 Functions::ZeroFunction, ，它描述了一个到处都是零的函数（并不意外）。我们就地创建这样一个对象，并将其传递给 VectorTools::interpolate_boundary_values() 函数。

// 最后，输出对象是一对全局自由度数（即边界上的自由度数）和它们的边界值（这里所有条目都是零）的列表。这种自由度数到边界值的映射是由 <code>std::map</code> 类完成的。

  std::map<types::global_dof_index, double> boundary_values; 
  VectorTools::interpolate_boundary_values(dof_handler, 
                                           0, 
                                           Functions::ZeroFunction<2>(), 
                                           boundary_values); 

// 现在我们得到了边界DoF的列表和它们各自的边界值，让我们用它们来相应地修改方程组。这可以通过以下函数调用来实现。

  MatrixTools::apply_boundary_values(boundary_values, 
                                     system_matrix, 
                                     solution, 
                                     system_rhs); 
} 
// @sect4{Step3::solve}  

// 下面的函数简单地求解了离散化的方程。由于该系统对于高斯消除或LU分解等直接求解器来说是一个相当大的系统，我们使用共轭梯度算法。你应该记住，这里的变量数量（只有1089个）对于有限元计算来说是一个非常小的数字，而100.000是一个比较常见的数字。 对于这个数量的变量，直接方法已经不能使用了，你不得不使用CG这样的方法。

void Step3::solve() 
{ 

// 首先，我们需要有一个对象，知道如何告诉CG算法何时停止。这是通过使用SolverControl对象来实现的，作为停止标准，我们说：在最多1000次迭代后停止（这远远超过了1089个变量的需要；见结果部分以了解真正使用了多少次），如果残差的规范低于 $10^{-12}$ 就停止。在实践中，后一个标准将是停止迭代的一个标准。

  SolverControl solver_control(1000, 1e-12); 

// 然后，我们需要解算器本身。SolverCG类的模板参数是向量的类型，留下空的角括号将表明我们采取的是默认参数（即 <code>Vector@<double@></code>  ）。然而，我们明确地提到了模板参数。

  SolverCG<Vector<double>> solver(solver_control); 

// 现在求解方程组。CG求解器的第四个参数是一个预处理程序。我们觉得还没有准备好深入研究这个问题，所以我们告诉它使用身份运算作为预处理。

  solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity()); 

// 现在求解器已经完成了它的工作，求解变量包含了求解函数的结点值。

} 
// @sect4{Step3::output_results}  

// 典型的有限元程序的最后一部分是输出结果，也许会做一些后处理（例如计算边界处的最大应力值，或者计算整个流出物的平均通量，等等）。我们这里没有这样的后处理，但是我们想把解决方案写到一个文件里。

void Step3::output_results() const 
{ 

// 为了将输出写入文件，我们需要一个知道输出格式等的对象。这就是DataOut类，我们需要一个该类型的对象。

  DataOut<2> data_out; 

// 现在我们必须告诉它从哪里获取它要写的值。我们告诉它使用哪个DoFHandler对象，以及求解向量（以及求解变量在输出文件中的名称）。如果我们有不止一个我们想在输出中查看的向量（例如右手边，每个单元格的错误，等等），我们也要把它们加进去。

  data_out.attach_dof_handler(dof_handler); 
  data_out.add_data_vector(solution, "solution"); 

// 在DataOut对象知道它要处理哪些数据后，我们必须告诉它把它们处理成后端可以处理的数据。原因是我们将前端（知道如何处理DoFHandler对象和数据向量）与后端（知道许多不同的输出格式）分开，使用一种中间数据格式将数据从前端传输到后端。数据通过以下函数转换为这种中间格式。

  data_out.build_patches(); 

// 现在我们已经为实际输出做好了一切准备。只要打开一个文件，用VTK格式把数据写进去就可以了（在我们这里使用的DataOut类中还有很多其他函数，可以把数据写成postscript、AVS、GMV、Gnuplot或其他一些文件格式）。

  std::ofstream output("solution.vtk"); 
  data_out.write_vtk(output); 
} 
// @sect4{Step3::run}  

// 最后，这个类的最后一个函数是主函数，调用 <code>Step3</code> 类的所有其他函数。这样做的顺序类似于大多数有限元程序的工作顺序。由于这些名字大多是不言自明的，所以没有什么可评论的。

void Step3::run() 
{ 
  make_grid(); 
  setup_system(); 
  assemble_system(); 
  solve(); 
  output_results(); 
} 
// @sect3{The <code>main</code> function}  

// 这是程序的主函数。由于主函数的概念大多是C++编程之前的面向对象时代的遗留物，所以它通常不做更多的事情，只是创建一个顶层类的对象并调用其原理函数。

// 最后，函数的第一行是用来启用deal.II可以生成的一些诊断程序的输出。  @p deallog 变量（代表deal-log，而不是de-allog）代表一个流，库的某些部分将输出写入其中。例如，迭代求解器将产生诊断程序（起始残差、求解器步骤数、最终残差），在运行这个教程程序时可以看到。

//  @p deallog 的输出可以写到控制台，也可以写到文件，或者两者都写。两者在默认情况下都是禁用的，因为多年来我们已经知道，一个程序只应该在用户明确要求的时候才产生输出。但这是可以改变的，为了解释如何做到这一点，我们需要解释 @p deallog 是如何工作的。当库的个别部分想要记录输出时，它们会打开一个 "上下文 "或 "部分"，这个输出将被放入其中。在想要写输出的部分结束时，人们再次退出这个部分。由于一个函数可以在这个输出部分打开的范围内调用另一个函数，所以输出实际上可以分层嵌套到这些部分。LogStream类（ @p deallog 是一个变量）将这些部分中的每一个称为 "前缀"，因为所有的输出都以这个前缀打印在行的左端，前缀由冒号分隔。总是有一个默认的前缀叫做 "DEAL"（暗示了deal.II的历史，它是以前一个叫做 "DEAL "的库的继承者，LogStream类是被带入deal.II的少数代码之一）。

// 默认情况下， @p logstream 只输出前缀为零的行--也就是说，所有的输出都是禁用的，因为默认的 "DEAL "前缀总是存在的。但人们可以为应该输出的行设置不同的最大前缀数，以达到更大的效果，事实上在这里我们通过调用 LogStream::depth_console(). 将其设置为两个。这意味着对于所有的屏幕输出，在默认的 "DEAL "之外再推一个前缀的上下文被允许将其输出打印到屏幕上（"控制台"），而所有进一步嵌套的部分将有三个或更多的前缀被激活，会写到 @p deallog, ，但 @p deallog 并不转发这个输出到屏幕。因此，运行这个例子（或者看 "结果 "部分），你会看到解算器的统计数据前缀为 "DEAL:CG"，这是两个前缀。这对于当前程序的上下文来说已经足够了，但是你将在以后看到一些例子（例如，在 step-22 中），其中求解器嵌套得更深，你可能通过设置更高的深度来获得有用的信息。

int main() 
{ 
  deallog.depth_console(2); 

  Step3 laplace_problem; 
  laplace_problem.run(); 

  return 0; 
} 


CCTest_file/step-30.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2007 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Tobias Leicht, 2007 
 */ 



// deal.II包括的文件已经在前面的例子中介绍过了，因此不再做进一步的评论。

#include <deal.II/base/function.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/lac/precondition_block.h> 
#include <deal.II/lac/solver_richardson.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q1.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/derivative_approximation.h> 

// 而这又是C++。

#include <array> 
#include <iostream> 
#include <fstream> 

// 最后一步和以前所有的程序一样。

namespace Step30 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

// 描述方程数据的类和单个术语的实际装配几乎完全照搬自  step-12  。我们将对差异进行评论。

  template <int dim> 
  class RHS : public Function<dim> 
  { 
  public: 
    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int /*component*/ = 0) const override 
    { 
      (void)points; 
      Assert(values.size() == points.size(), 
             ExcDimensionMismatch(values.size(), points.size())); 

      std::fill(values.begin(), values.end(), 0.); 
    } 
  }; 

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int /*component*/ = 0) const override 
    { 
      Assert(values.size() == points.size(), 
             ExcDimensionMismatch(values.size(), points.size())); 

      for (unsigned int i = 0; i < values.size(); ++i) 
        { 
          if (points[i](0) < 0.5) 
            values[i] = 1.; 
          else 
            values[i] = 0.; 
        } 
    } 
  }; 

  template <int dim> 
  class Beta 
  { 
  public: 

//流场选择为逆时针方向的四分之一圆，原点为域的右半部分的中点，数值为正 $x$ ，而在域的左边部分，流速只是向左走，与从右边进来的流速一致。在圆形部分，流速的大小与离原点的距离成正比。这与 step-12 不同，在该定义中，到处都是1。新定义导致 $\beta$ 沿单元的每个给定面的线性变化。另一方面， $u(x,y)$ 的解决方案与之前完全相同。

    void value_list(const std::vector<Point<dim>> &points, 
                    std::vector<Point<dim>> &      values) const 
    { 
      Assert(values.size() == points.size(), 
             ExcDimensionMismatch(values.size(), points.size())); 

      for (unsigned int i = 0; i < points.size(); ++i) 
        { 
          if (points[i](0) > 0) 
            { 
              values[i](0) = -points[i](1); 
              values[i](1) = points[i](0); 
            } 
          else 
            { 
              values[i]    = Point<dim>(); 
              values[i](0) = -points[i](1); 
            } 
        } 
    } 
  }; 

//  @sect3{Class: DGTransportEquation}  

// 这个类的声明完全不受我们目前的变化影响。

  template <int dim> 
  class DGTransportEquation 
  { 
  public: 
    DGTransportEquation(); 

    void assemble_cell_term(const FEValues<dim> &fe_v, 
                            FullMatrix<double> & ui_vi_matrix, 
                            Vector<double> &     cell_vector) const; 

    void assemble_boundary_term(const FEFaceValues<dim> &fe_v, 
                                FullMatrix<double> &     ui_vi_matrix, 
                                Vector<double> &         cell_vector) const; 

    void assemble_face_term(const FEFaceValuesBase<dim> &fe_v, 
                            const FEFaceValuesBase<dim> &fe_v_neighbor, 
                            FullMatrix<double> &         ui_vi_matrix, 
                            FullMatrix<double> &         ue_vi_matrix, 
                            FullMatrix<double> &         ui_ve_matrix, 
                            FullMatrix<double> &         ue_ve_matrix) const; 

  private: 
    const Beta<dim>           beta_function; 
    const RHS<dim>            rhs_function; 
    const BoundaryValues<dim> boundary_function; 
  }; 

// 同样地，该类的构造函数以及组装对应于单元格内部和边界面的术语的函数与之前没有变化。装配单元间面术语的函数也没有改变，因为它所做的只是对两个FEFaceValuesBase类型的对象进行操作（它是FEFaceValues和FESubfaceValues的基类）。这些对象从何而来，即它们是如何被初始化的，对这个函数来说并不重要：它只是假设这两个对象所代表的面或子面上的正交点与物理空间中的相同点相对应。

  template <int dim> 
  DGTransportEquation<dim>::DGTransportEquation() 
    : beta_function() 
    , rhs_function() 
    , boundary_function() 
  {} 

  template <int dim> 
  void DGTransportEquation<dim>::assemble_cell_term( 
    const FEValues<dim> &fe_v, 
    FullMatrix<double> & ui_vi_matrix, 
    Vector<double> &     cell_vector) const 
  { 
    const std::vector<double> &JxW = fe_v.get_JxW_values(); 

    std::vector<Point<dim>> beta(fe_v.n_quadrature_points); 
    std::vector<double>     rhs(fe_v.n_quadrature_points); 

    beta_function.value_list(fe_v.get_quadrature_points(), beta); 
    rhs_function.value_list(fe_v.get_quadrature_points(), rhs); 

    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point) 
      for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
        { 
          for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j) 
            ui_vi_matrix(i, j) -= beta[point] * fe_v.shape_grad(i, point) * 
                                  fe_v.shape_value(j, point) * JxW[point]; 

          cell_vector(i) += 
            rhs[point] * fe_v.shape_value(i, point) * JxW[point]; 
        } 
  } 

  template <int dim> 
  void DGTransportEquation<dim>::assemble_boundary_term( 
    const FEFaceValues<dim> &fe_v, 
    FullMatrix<double> &     ui_vi_matrix, 
    Vector<double> &         cell_vector) const 
  { 
    const std::vector<double> &        JxW     = fe_v.get_JxW_values(); 
    const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors(); 

    std::vector<Point<dim>> beta(fe_v.n_quadrature_points); 
    std::vector<double>     g(fe_v.n_quadrature_points); 

    beta_function.value_list(fe_v.get_quadrature_points(), beta); 
    boundary_function.value_list(fe_v.get_quadrature_points(), g); 

    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point) 
      { 
        const double beta_n = beta[point] * normals[point]; 
        if (beta_n > 0) 
          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j) 
              ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) * 
                                    fe_v.shape_value(i, point) * JxW[point]; 
        else 
          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
            cell_vector(i) -= 
              beta_n * g[point] * fe_v.shape_value(i, point) * JxW[point]; 
      } 
  } 

  template <int dim> 
  void DGTransportEquation<dim>::assemble_face_term( 
    const FEFaceValuesBase<dim> &fe_v, 
    const FEFaceValuesBase<dim> &fe_v_neighbor, 
    FullMatrix<double> &         ui_vi_matrix, 
    FullMatrix<double> &         ue_vi_matrix, 
    FullMatrix<double> &         ui_ve_matrix, 
    FullMatrix<double> &         ue_ve_matrix) const 
  { 
    const std::vector<double> &        JxW     = fe_v.get_JxW_values(); 
    const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors(); 

    std::vector<Point<dim>> beta(fe_v.n_quadrature_points); 

    beta_function.value_list(fe_v.get_quadrature_points(), beta); 

    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point) 
      { 
        const double beta_n = beta[point] * normals[point]; 
        if (beta_n > 0) 
          { 
            for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j) 
                ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) * 
                                      fe_v.shape_value(i, point) * JxW[point]; 

            for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k) 
              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j) 
                ui_ve_matrix(k, j) -= beta_n * fe_v.shape_value(j, point) * 
                                      fe_v_neighbor.shape_value(k, point) * 
                                      JxW[point]; 
          } 
        else 
          { 
            for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
              for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l) 
                ue_vi_matrix(i, l) += beta_n * 
                                      fe_v_neighbor.shape_value(l, point) * 
                                      fe_v.shape_value(i, point) * JxW[point]; 

            for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k) 
              for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l) 
                ue_ve_matrix(k, l) -= 
                  beta_n * fe_v_neighbor.shape_value(l, point) * 
                  fe_v_neighbor.shape_value(k, point) * JxW[point]; 
          } 
      } 
  } 
// @sect3{Class: DGMethod}  

// 这个声明很像  step-12  的声明。然而，我们引入了一个新的例程（set_anisotropic_flags）并修改了另一个例程（refine_grid）。

  template <int dim> 
  class DGMethod 
  { 
  public: 
    DGMethod(const bool anisotropic); 

    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(Vector<double> &solution); 
    void refine_grid(); 
    void set_anisotropic_flags(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim>   triangulation; 
    const MappingQ1<dim> mapping; 

// 我们再次希望使用程度为1的DG元素（但这只在构造函数中指定）。如果你想使用不同程度的DG方法，请在构造函数中用新的程度替换1。

    const unsigned int degree; 
    FE_DGQ<dim>        fe; 
    DoFHandler<dim>    dof_handler; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

// 这是新的，在介绍中解释的各向异性跳跃指标的评估中使用的阈值。它的值在构造函数中被设置为3.0，但它可以很容易地被改变为一个大于1的不同值。

    const double anisotropic_threshold_ratio; 

// 这是一个指示是否使用各向异性细化的bool标志。它由构造函数设置，构造函数需要一个同名的参数。

    const bool anisotropic; 

    const QGauss<dim>     quadrature; 
    const QGauss<dim - 1> face_quadrature; 

    Vector<double> solution2; 
    Vector<double> right_hand_side; 

    const DGTransportEquation<dim> dg; 
  }; 

  template <int dim> 
  DGMethod<dim>::DGMethod(const bool anisotropic) 
    : mapping() 
    , 

// 对于不同程度的DG方法，在这里进行修改。

    degree(1) 
    , fe(degree) 
    , dof_handler(triangulation) 
    , anisotropic_threshold_ratio(3.) 
    , anisotropic(anisotropic) 
    , 

// 由于β是一个线性函数，我们可以选择正交的度数，对于这个度数，所得的积分是正确的。因此，我们选择使用  <code>degree+1</code>  高斯点，这使我们能够准确地积分度数为  <code>2*degree+1</code>  的多项式，足以满足我们在本程序中要进行的所有积分。

    quadrature(degree + 1) 
    , face_quadrature(degree + 1) 
    , dg() 
  {} 

  template <int dim> 
  void DGMethod<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    sparsity_pattern.reinit(dof_handler.n_dofs(), 
                            dof_handler.n_dofs(), 
                            (GeometryInfo<dim>::faces_per_cell * 
                               GeometryInfo<dim>::max_children_per_face + 
                             1) * 
                              fe.n_dofs_per_cell()); 

    DoFTools::make_flux_sparsity_pattern(dof_handler, sparsity_pattern); 

    sparsity_pattern.compress(); 

    system_matrix.reinit(sparsity_pattern); 

    solution2.reinit(dof_handler.n_dofs()); 
    right_hand_side.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{Function: assemble_system}  

// 我们继续使用 <code>assemble_system</code> 函数来实现DG离散化。这个函数与 step-12 中的 <code>assemble_system</code> 函数的作用相同（但没有MeshWorker）。 一个单元的邻居关系所考虑的四种情况与各向同性的情况相同，即a)单元在边界上，b)有更细的邻居单元，c)邻居既不粗也不细，d)邻居更粗。 然而，我们决定哪种情况的方式是按照介绍中描述的方式进行修改的。

  template <int dim> 
  void DGMethod<dim>::assemble_system() 
  { 
    const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell(); 
    std::vector<types::global_dof_index> dofs(dofs_per_cell); 
    std::vector<types::global_dof_index> dofs_neighbor(dofs_per_cell); 

    const UpdateFlags update_flags = update_values | update_gradients | 
                                     update_quadrature_points | 
                                     update_JxW_values; 

    const UpdateFlags face_update_flags = 
      update_values | update_quadrature_points | update_JxW_values | 
      update_normal_vectors; 

    const UpdateFlags neighbor_face_update_flags = update_values; 

    FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags); 
    FEFaceValues<dim>    fe_v_face(mapping, 
                                fe, 
                                face_quadrature, 
                                face_update_flags); 
    FESubfaceValues<dim> fe_v_subface(mapping, 
                                      fe, 
                                      face_quadrature, 
                                      face_update_flags); 
    FEFaceValues<dim>    fe_v_face_neighbor(mapping, 
                                         fe, 
                                         face_quadrature, 
                                         neighbor_face_update_flags); 

    FullMatrix<double> ui_vi_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> ue_vi_matrix(dofs_per_cell, dofs_per_cell); 

    FullMatrix<double> ui_ve_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> ue_ve_matrix(dofs_per_cell, dofs_per_cell); 

    Vector<double> cell_vector(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        ui_vi_matrix = 0; 
        cell_vector  = 0; 

        fe_v.reinit(cell); 

        dg.assemble_cell_term(fe_v, ui_vi_matrix, cell_vector); 

        cell->get_dof_indices(dofs); 

        for (const auto face_no : cell->face_indices()) 
          { 
            const auto face = cell->face(face_no); 

// 情况(a)。该面在边界上。

            if (face->at_boundary()) 
              { 
                fe_v_face.reinit(cell, face_no); 

                dg.assemble_boundary_term(fe_v_face, ui_vi_matrix, cell_vector); 
              } 
            else 
              { 
                Assert(cell->neighbor(face_no).state() == IteratorState::valid, 
                       ExcInternalError()); 
                const auto neighbor = cell->neighbor(face_no); 

// 情况(b)。这是一个内部面，邻居是精炼的（我们可以通过询问当前单元格的面是否有孩子来测试）。在这种情况下，我们需要对 "子面 "进行整合，即当前单元格的面的子女。            (有一个稍微令人困惑的角落案例。如果我们是在1d中--诚然，当前的程序和它对各向异性细化的演示并不特别相关--那么单元间的面总是相同的：它们只是顶点。换句话说，在1d中，我们不希望对不同层次的单元之间的面进行不同的处理。我们在这里检查的条件`face->has_children()`确保了这一点：在1d中，这个函数总是返回`false`，因此在1d中我们不会进入这个`if`分支。但我们将不得不在下面的情况（c）中回到这个角落。

                if (face->has_children()) 
                  { 

// 我们需要知道，哪个邻居的面朝向我们单元格的方向。使用  @p  neighbor_face_no 函数，我们可以得到粗邻和非粗邻的这些信息。

                    const unsigned int neighbor2 = 
                      cell->neighbor_face_no(face_no); 

// 现在我们对所有的子脸进行循环，也就是当前脸的子脸和可能的孙子脸。

                    for (unsigned int subface_no = 0; 
                         subface_no < face->n_active_descendants(); 
                         ++subface_no) 
                      { 

// 为了得到当前子面后面的单元，我们可以使用 @p neighbor_child_on_subface 函数。它照顾到了所有各向异性细化和非标准面的复杂情况。

                        const auto neighbor_child = 
                          cell->neighbor_child_on_subface(face_no, subface_no); 
                        Assert(!neighbor_child->has_children(), 
                               ExcInternalError()); 

// 这个案例的其余部分没有变化。

                        ue_vi_matrix = 0; 
                        ui_ve_matrix = 0; 
                        ue_ve_matrix = 0; 

                        fe_v_subface.reinit(cell, face_no, subface_no); 
                        fe_v_face_neighbor.reinit(neighbor_child, neighbor2); 

                        dg.assemble_face_term(fe_v_subface, 
                                              fe_v_face_neighbor, 
                                              ui_vi_matrix, 
                                              ue_vi_matrix, 
                                              ui_ve_matrix, 
                                              ue_ve_matrix); 

                        neighbor_child->get_dof_indices(dofs_neighbor); 

                        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                            { 
                              system_matrix.add(dofs[i], 
                                                dofs_neighbor[j], 
                                                ue_vi_matrix(i, j)); 
                              system_matrix.add(dofs_neighbor[i], 
                                                dofs[j], 
                                                ui_ve_matrix(i, j)); 
                              system_matrix.add(dofs_neighbor[i], 
                                                dofs_neighbor[j], 
                                                ue_ve_matrix(i, j)); 
                            } 
                      } 
                  } 
                else 
                  { 

//情况(c)。如果这是一个内部面，并且邻居没有进一步细化，我们就会得到这里（或者，如上所述，我们是在1d中，在这种情况下，我们对每个内部面都会得到这里）。然后我们需要决定是否要对当前面进行整合。如果邻居实际上更粗，那么我们就忽略这个面，而是在访问邻居单元并查看当前面的时候处理它（除了在1d中，如上所述，这不会发生）。

                    if (dim > 1 && cell->neighbor_is_coarser(face_no)) 
                      continue; 

// 另一方面，如果邻居是更精细的，那么我们已经处理了上面(b)情况下的脸（1d除外）。所以对于2d和3d，我们只需要决定是要处理来自当前一侧的同一层次的单元格之间的面，还是来自邻接一侧的面。 我们通过引入一个平局来做到这一点。          我们只取索引较小的单元格（在当前细化级别内）。在1d中，我们取较粗的单元，或者如果它们在同一层次，则取该层次中指数较小的单元。这就导致了一个复杂的条件，希望在上面的描述中可以理解。

                    if (((dim > 1) && (cell->index() < neighbor->index())) || 
                        ((dim == 1) && ((cell->level() < neighbor->level()) || 
                                        ((cell->level() == neighbor->level()) && 
                                         (cell->index() < neighbor->index()))))) 
                      { 

// 这里我们知道，邻居不是更粗的，所以我们可以使用通常的  @p neighbor_of_neighbor  函数。然而，我们也可以使用更通用的 @p neighbor_face_no 函数。

                        const unsigned int neighbor2 = 
                          cell->neighbor_of_neighbor(face_no); 

                        ue_vi_matrix = 0; 
                        ui_ve_matrix = 0; 
                        ue_ve_matrix = 0; 

                        fe_v_face.reinit(cell, face_no); 
                        fe_v_face_neighbor.reinit(neighbor, neighbor2); 

                        dg.assemble_face_term(fe_v_face, 
                                              fe_v_face_neighbor, 
                                              ui_vi_matrix, 
                                              ue_vi_matrix, 
                                              ui_ve_matrix, 
                                              ue_ve_matrix); 

                        neighbor->get_dof_indices(dofs_neighbor); 

                        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                            { 
                              system_matrix.add(dofs[i], 
                                                dofs_neighbor[j], 
                                                ue_vi_matrix(i, j)); 
                              system_matrix.add(dofs_neighbor[i], 
                                                dofs[j], 
                                                ui_ve_matrix(i, j)); 
                              system_matrix.add(dofs_neighbor[i], 
                                                dofs_neighbor[j], 
                                                ue_ve_matrix(i, j)); 
                            } 
                      } 

// 我们不需要考虑情况(d)，因为这些面在情况(b)中被 "从另一侧 "处理。

                  } 
              } 
          } 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i, j)); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          right_hand_side(dofs[i]) += cell_vector(i); 
      } 
  } 
// @sect3{Solver}  

// 对于这个简单的问题，我们再次使用简单的Richardson迭代法。该求解器完全不受我们各向异性变化的影响。

  template <int dim> 
  void DGMethod<dim>::solve(Vector<double> &solution) 
  { 
    SolverControl                    solver_control(1000, 1e-12, false, false); 
    SolverRichardson<Vector<double>> solver(solver_control); 

    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner; 

    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell()); 

    solver.solve(system_matrix, solution, right_hand_side, preconditioner); 
  } 
// @sect3{Refinement}  

// 我们根据 step-12 中使用的相同的简单细化标准来细化网格，即对解的梯度的近似。

  template <int dim> 
  void DGMethod<dim>::refine_grid() 
  { 
    Vector<float> gradient_indicator(triangulation.n_active_cells()); 

// 我们对梯度进行近似计算。

    DerivativeApproximation::approximate_gradient(mapping, 
                                                  dof_handler, 
                                                  solution2, 
                                                  gradient_indicator); 

//并对其进行缩放，以获得一个误差指标。

    for (const auto &cell : triangulation.active_cell_iterators()) 
      gradient_indicator[cell->active_cell_index()] *= 
        std::pow(cell->diameter(), 1 + 1.0 * dim / 2); 

// 然后我们用这个指标来标记误差指标最高的30%的单元格来进行精炼。

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    gradient_indicator, 
                                                    0.3, 
                                                    0.1); 

// 现在，细化标志被设置为那些具有大误差指标的单元。如果不做任何改变，这些单元将被等向细化。如果给这个函数的 @p anisotropic 标志被设置，我们现在调用set_anisotropic_flags()函数，该函数使用跳转指标将一些细化标志重置为各向异性细化。

    if (anisotropic) 
      set_anisotropic_flags(); 

// 现在执行考虑各向异性以及各向同性的细化标志的细化。

    triangulation.execute_coarsening_and_refinement(); 
  } 

// 一旦错误指标被评估，误差最大的单元被标记为细化，我们要再次循环这些被标记的单元，以决定它们是否需要各向同性的细化或各向异性的细化更为合适。这就是在介绍中解释的各向异性跳跃指标。

  template <int dim> 
  void DGMethod<dim>::set_anisotropic_flags() 
  { 

// 我们想在被标记的单元格的面上评估跳跃，所以我们需要一些对象来评估面上的解决方案的值。

    UpdateFlags face_update_flags = 
      UpdateFlags(update_values | update_JxW_values); 

    FEFaceValues<dim>    fe_v_face(mapping, 
                                fe, 
                                face_quadrature, 
                                face_update_flags); 
    FESubfaceValues<dim> fe_v_subface(mapping, 
                                      fe, 
                                      face_quadrature, 
                                      face_update_flags); 
    FEFaceValues<dim>    fe_v_face_neighbor(mapping, 
                                         fe, 
                                         face_quadrature, 
                                         update_values); 

// 现在我们需要对所有活动单元进行循环。

    for (const auto &cell : dof_handler.active_cell_iterators()) 

// 我们只需要考虑那些被标记为细化的单元。

      if (cell->refine_flag_set()) 
        { 
          Point<dim> jump; 
          Point<dim> area; 

          for (const auto face_no : cell->face_indices()) 
            { 
              const auto face = cell->face(face_no); 

              if (!face->at_boundary()) 
                { 
                  Assert(cell->neighbor(face_no).state() == 
                           IteratorState::valid, 
                         ExcInternalError()); 
                  const auto neighbor = cell->neighbor(face_no); 

                  std::vector<double> u(fe_v_face.n_quadrature_points); 
                  std::vector<double> u_neighbor(fe_v_face.n_quadrature_points); 

// 在汇编例程中看到的四种不同的邻居关系的情况在这里以同样的方式重复。

                  if (face->has_children()) 
                    { 

// 邻居被完善。 首先，我们存储信息，即邻居的哪个面指向我们当前单元的方向。这个属性将被继承给子代。

                      unsigned int neighbor2 = cell->neighbor_face_no(face_no); 

// 现在我们对所有的子面进行循环。

                      for (unsigned int subface_no = 0; 
                           subface_no < face->n_active_descendants(); 
                           ++subface_no) 
                        { 

//得到一个迭代器，指向当前子面后面的单元格...

                          const auto neighbor_child = 
                            cell->neighbor_child_on_subface(face_no, 
                                                            subface_no); 
                          Assert(!neighbor_child->has_children(), 
                                 ExcInternalError()); 

// ...并重新启动各自的FEFaceValues和FESSubFaceValues对象。

                          fe_v_subface.reinit(cell, face_no, subface_no); 
                          fe_v_face_neighbor.reinit(neighbor_child, neighbor2); 

// 我们获得了函数值

                          fe_v_subface.get_function_values(solution2, u); 
                          fe_v_face_neighbor.get_function_values(solution2, 
                                                                 u_neighbor); 

//以及正交权重，乘以雅各布行列式。

                          const std::vector<double> &JxW = 
                            fe_v_subface.get_JxW_values(); 

// 现在我们在所有的正交点上循环。

                          for (unsigned int x = 0; 
                               x < fe_v_subface.n_quadrature_points; 
                               ++x) 
                            { 

//并整合解决方案的跳跃的绝对值，即分别从当前单元和邻近单元看到的函数值的绝对值。我们知道，前两个面与单元格上的第一个坐标方向正交，后两个面与第二个坐标方向正交，以此类推，所以我们将这些值累积成具有 <code>dim</code> 成分的向量。

                              jump[face_no / 2] += 
                                std::abs(u[x] - u_neighbor[x]) * JxW[x]; 

// 我们还将缩放后的权重相加，以获得脸部的量度。

                              area[face_no / 2] += JxW[x]; 
                            } 
                        } 
                    } 
                  else 
                    { 
                      if (!cell->neighbor_is_coarser(face_no)) 
                        { 

// 我们的当前单元和邻居在所考虑的面有相同的细化。除此以外，我们的做法与上述情况下的一个子单元的做法基本相同。

                          unsigned int neighbor2 = 
                            cell->neighbor_of_neighbor(face_no); 

                          fe_v_face.reinit(cell, face_no); 
                          fe_v_face_neighbor.reinit(neighbor, neighbor2); 

                          fe_v_face.get_function_values(solution2, u); 
                          fe_v_face_neighbor.get_function_values(solution2, 
                                                                 u_neighbor); 

                          const std::vector<double> &JxW = 
                            fe_v_face.get_JxW_values(); 

                          for (unsigned int x = 0; 
                               x < fe_v_face.n_quadrature_points; 
                               ++x) 
                            { 
                              jump[face_no / 2] += 
                                std::abs(u[x] - u_neighbor[x]) * JxW[x]; 
                              area[face_no / 2] += JxW[x]; 
                            } 
                        } 
                      else // i.e. neighbor is coarser than cell 
                        { 

// 现在邻居实际上更粗了。这种情况是新的，因为它没有出现在汇编程序中。在这里，我们必须考虑它，但这并不太复杂。我们只需使用  @p  neighbor_of_coarser_neighbor 函数，它再次自行处理各向异性的细化和非标准面的方向。

                          std::pair<unsigned int, unsigned int> 
                            neighbor_face_subface = 
                              cell->neighbor_of_coarser_neighbor(face_no); 
                          Assert(neighbor_face_subface.first < cell->n_faces(), 
                                 ExcInternalError()); 
                          Assert(neighbor_face_subface.second < 
                                   neighbor->face(neighbor_face_subface.first) 
                                     ->n_active_descendants(), 
                                 ExcInternalError()); 
                          Assert(neighbor->neighbor_child_on_subface( 
                                   neighbor_face_subface.first, 
                                   neighbor_face_subface.second) == cell, 
                                 ExcInternalError()); 

                          fe_v_face.reinit(cell, face_no); 
                          fe_v_subface.reinit(neighbor, 
                                              neighbor_face_subface.first, 
                                              neighbor_face_subface.second); 

                          fe_v_face.get_function_values(solution2, u); 
                          fe_v_subface.get_function_values(solution2, 
                                                           u_neighbor); 

                          const std::vector<double> &JxW = 
                            fe_v_face.get_JxW_values(); 

                          for (unsigned int x = 0; 
                               x < fe_v_face.n_quadrature_points; 
                               ++x) 
                            { 
                              jump[face_no / 2] += 
                                std::abs(u[x] - u_neighbor[x]) * JxW[x]; 
                              area[face_no / 2] += JxW[x]; 
                            } 
                        } 
                    } 
                } 
            } 

// 现在我们分析一下平均跳动的大小，我们用跳动除以各面的度量得到。

          std::array<double, dim> average_jumps; 
          double                  sum_of_average_jumps = 0.; 
          for (unsigned int i = 0; i < dim; ++i) 
            { 
              average_jumps[i] = jump(i) / area(i); 
              sum_of_average_jumps += average_jumps[i]; 
            } 

// 现在我们在单元格的 <code>dim</code> 坐标方向上进行循环，并比较与该方向正交的面的平均跳跃和与其余方向正交的面的平均跳跃。如果前者比后者大一个给定的系数，我们只沿帽轴进行细化。否则，我们不改变细化标志，导致各向同性的细化。

          for (unsigned int i = 0; i < dim; ++i) 
            if (average_jumps[i] > anisotropic_threshold_ratio * 
                                     (sum_of_average_jumps - average_jumps[i])) 
              cell->set_refine_flag(RefinementCase<dim>::cut_axis(i)); 
        } 
  } 
// @sect3{The Rest}  

// 程序的其余部分非常遵循之前教程程序的方案。我们以VTU格式输出网格（就像我们在 step-1 中所做的那样，例如），并以VTU格式输出可视化，我们几乎总是这样做。

  template <int dim> 
  void DGMethod<dim>::output_results(const unsigned int cycle) const 
  { 
    std::string refine_type; 
    if (anisotropic) 
      refine_type = ".aniso"; 
    else 
      refine_type = ".iso"; 

    { 
      const std::string filename = 
        "grid-" + std::to_string(cycle) + refine_type + ".svg"; 
      std::cout << "   Writing grid to <" << filename << ">..." << std::endl; 
      std::ofstream svg_output(filename); 

      GridOut grid_out; 
      grid_out.write_svg(triangulation, svg_output); 
    } 

    { 
      const std::string filename = 
        "sol-" + std::to_string(cycle) + refine_type + ".vtu"; 
      std::cout << "   Writing solution to <" << filename << ">..." 
                << std::endl; 
      std::ofstream gnuplot_output(filename); 

      DataOut<dim> data_out; 
      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution2, "u"); 

      data_out.build_patches(degree); 

      data_out.write_vtu(gnuplot_output); 
    } 
  } 

  template <int dim> 
  void DGMethod<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 6; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 

// 创建矩形域。

            Point<dim> p1, p2; 
            p1(0) = 0; 
            p1(0) = -1; 
            for (unsigned int i = 0; i < dim; ++i) 
              p2(i) = 1.; 

// 调整不同方向的单元数，以获得原始网格的完全各向同性的单元。

            std::vector<unsigned int> repetitions(dim, 1); 
            repetitions[0] = 2; 
            GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                                      repetitions, 
                                                      p1, 
                                                      p2); 

            triangulation.refine_global(5 - dim); 
          } 
        else 
          refine_grid(); 

        std::cout << "   Number of active cells:       " 
                  << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
                  << std::endl; 

        Timer assemble_timer; 
        assemble_system(); 
        std::cout << "   Time of assemble_system: " << assemble_timer.cpu_time() 
                  << std::endl; 
        solve(solution2); 

        output_results(cycle); 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step30 

int main() 
{ 
  try 
    { 
      using namespace Step30; 

// 如果你想以3D方式运行程序，只需将下面一行改为 <code>const unsigned int dim = 3;</code>  。

      const unsigned int dim = 2; 

      { 

// 首先，我们用各向同性的细化方法进行一次运行。

        std::cout << "Performing a " << dim 
                  << "D run with isotropic refinement..." << std::endl 
                  << "------------------------------------------------" 
                  << std::endl; 
        DGMethod<dim> dgmethod_iso(false); 
        dgmethod_iso.run(); 
      } 

      { 

// 现在我们进行第二次运行，这次是各向异性的细化。

        std::cout << std::endl 
                  << "Performing a " << dim 
                  << "D run with anisotropic refinement..." << std::endl 
                  << "--------------------------------------------------" 
                  << std::endl; 
        DGMethod<dim> dgmethod_aniso(true); 
        dgmethod_aniso.run(); 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 

  return 0; 
} 

CCTest_file/step-31.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2007 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Martin Kronbichler, Uppsala University, 
 *          Wolfgang Bangerth, Texas A&M University 2007, 2008 
 */ 


// @sect3{Include files}  

// 像往常一样，第一步是包括这些著名的deal.II库文件和一些C++头文件的功能。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/block_sparsity_pattern.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/solution_transfer.h> 

// 然后我们需要包括一些头文件，这些文件提供了矢量、矩阵和预处理类，这些类实现了各自Trilinos类的接口。特别是，我们将需要基于Trilinos的矩阵和向量类以及Trilinos预处理程序的接口。

#include <deal.II/base/index_set.h> 
#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/trilinos_block_sparse_matrix.h> 
#include <deal.II/lac/trilinos_vector.h> 
#include <deal.II/lac/trilinos_parallel_block_vector.h> 
#include <deal.II/lac/trilinos_precondition.h> 

// 最后，这里有几个C++头文件还没有被上述头文件中的某个文件所包含。

#include <iostream> 
#include <fstream> 
#include <memory> 
#include <limits> 

// 在这个顶层事项的最后，我们将所有deal.II的名字导入到全局命名空间。

namespace Step31 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

// 同样，程序的下一阶段是定义方程数据，即各种边界条件、右手边和初始条件（记住，我们要解决的是一个时间依赖型系统）。这个定义的基本策略与  step-22  中的相同。不过关于细节，还是有一些区别。

// 首先，我们没有在速度上设置任何不均匀的边界条件，因为正如介绍中所解释的，我们将使用无流条件  $\mathbf{n}\cdot\mathbf{u}=0$  。所以剩下的是应力张量法线分量的切向部分的条件 <code>dim-1</code> ， $\textbf{n} \cdot [p \textbf{1} - \eta\varepsilon(\textbf{u})]$ ；我们假定这些分量的值是同质的，也就是说，一个自然的边界条件，不需要具体的动作（它作为零项出现在弱形式的右边）。

// 对于温度  $T$  ，我们假设没有热能通量，即  $\mathbf{n} \cdot \kappa \nabla T=0$  。这也是一个边界条件，不需要我们做任何特别的事情。

// 第二，我们必须设定温度的初始条件（速度和压力不需要初始条件，因为我们在这里考虑的准稳态情况下的斯托克斯方程没有速度或压力的时间导数）。在这里，我们选择一个非常简单的测试案例，即初始温度为零，所有的动力学都由温度的右手边驱动。

// 第三，我们需要定义温度方程的右边。我们选择它在域的底部某处的三个圆（或三维球）内为常数，如介绍中所解释的那样，而在域外为零。

// 最后，或者说首先，在这个命名空间的顶部，我们定义我们需要的各种材料常数（ $\eta,\kappa$ ，密度 $\rho$ 和热膨胀系数 $\beta$ ）。

  namespace EquationData 
  { 
    constexpr double eta     = 1; 
    constexpr double kappa   = 1e-6; 
    constexpr double beta    = 10; 
    constexpr double density = 1; 

    template <int dim> 
    class TemperatureInitialValues : public Function<dim> 
    { 
    public: 
      TemperatureInitialValues() 
        : Function<dim>(1) 
      {} 

      virtual double value(const Point<dim> & /*p*/, 
                           const unsigned int /*component*/ = 0) const override 
      { 
        return 0; 
      } 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  value) const override 
      { 
        for (unsigned int c = 0; c < this->n_components; ++c) 
          value(c) = TemperatureInitialValues<dim>::value(p, c); 
      } 
    }; 

    template <int dim> 
    class TemperatureRightHandSide : public Function<dim> 
    { 
    public: 
      TemperatureRightHandSide() 
        : Function<dim>(1) 
      {} 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override 
      { 
        (void)component; 
        Assert(component == 0, 
               ExcMessage("Invalid operation for a scalar function.")); 

        Assert((dim == 2) || (dim == 3), ExcNotImplemented()); 

        static const Point<dim> source_centers[3] = { 
          (dim == 2 ? Point<dim>(.3, .1) : Point<dim>(.3, .5, .1)), 
          (dim == 2 ? Point<dim>(.45, .1) : Point<dim>(.45, .5, .1)), 
          (dim == 2 ? Point<dim>(.75, .1) : Point<dim>(.75, .5, .1))}; 
        static const double source_radius = (dim == 2 ? 1. / 32 : 1. / 8); 

        return ((source_centers[0].distance(p) < source_radius) || 
                    (source_centers[1].distance(p) < source_radius) || 
                    (source_centers[2].distance(p) < source_radius) ? 
                  1 : 
                  0); 
      } 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  value) const override 
      { 
        for (unsigned int c = 0; c < this->n_components; ++c) 
          value(c) = TemperatureRightHandSide<dim>::value(p, c); 
      } 
    }; 
  } // namespace EquationData 

//  @sect3{Linear solvers and preconditioners}  

// 本节介绍了一些用于求解斯托克斯系统线性方程的对象，我们需要在每个时间步长中求解。这里使用的许多想法与 step-20 相同，其中介绍了基于Schur补的预处理程序和求解器，实际接口来自 step-22 （特别是 step-22 中 "结果 "部分的讨论，其中我们介绍了直接Schur补方法的替代品）。但是请注意，在这里我们不使用Schur补数来解决Stokes方程，尽管预处理程序中出现了一个近似的Schur补数（压力空间的质量矩阵）。

  namespace LinearSolvers 
  { 
// @sect4{The <code>InverseMatrix</code> class template}  

// 这个类是一个接口，用于计算 "倒置 "矩阵对向量的作用（使用 <code>vmult</code> 操作），其方式与 step-22 中的相应类相同：当请求这个类的对象的乘积时，我们使用CG方法解决与该矩阵有关的线性方程组，通过（模板化） <code>PreconditionerType</code> 类的预处理器加速。

// 与 step-22 中同一类别的实现略有不同，我们让 <code>vmult</code> 函数接受任何类型的向量类型（但是，如果矩阵不允许与这种向量进行矩阵-向量乘积，它将产生编译器错误）。

// 第二，我们捕捉解算器可能抛出的任何异常。原因如下。在调试这样的程序时，偶尔会犯一个错误，即把一个不确定或不对称的矩阵或预处理程序传递给当前的类。在这种情况下，求解器将不能收敛并抛出一个运行时异常。如果在这里没有被捕捉到，它就会在调用堆栈中传播，最后可能会在 <code>main()</code> 中出现，在那里我们会输出一个错误信息，说CG求解器失败。那么问题来了。哪个CG求解器？倒置质量矩阵的那个？用拉普拉斯算子反转左上角块的那个？还是在当前代码中我们使用线性求解器的其他几个嵌套位置中的一个CG求解器？在运行时异常中没有这方面的指示，因为它没有存储我们到达产生异常的地方的调用栈。
//所以
//与其让异常自由传播到 <code>main()</code> ，不如意识到如果内部求解器失败，外部函数能做的很少，不如将运行时异常转化为一个断言，该断言失败后会触发对 <code>abort()</code> 的调用，允许我们在调试器中追溯我们如何到达当前位置。

    template <class MatrixType, class PreconditionerType> 
    class InverseMatrix : public Subscriptor 
    { 
    public: 
      InverseMatrix(const MatrixType &        m, 
                    const PreconditionerType &preconditioner); 

      template <typename VectorType> 
      void vmult(VectorType &dst, const VectorType &src) const; 

    private: 
      const SmartPointer<const MatrixType> matrix; 
      const PreconditionerType &           preconditioner; 
    }; 

    template <class MatrixType, class PreconditionerType> 
    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix( 
      const MatrixType &        m, 
      const PreconditionerType &preconditioner) 
      : matrix(&m) 
      , preconditioner(preconditioner) 
    {} 

    template <class MatrixType, class PreconditionerType> 
    template <typename VectorType> 
    void InverseMatrix<MatrixType, PreconditionerType>::vmult( 
      VectorType &      dst, 
      const VectorType &src) const 
    { 
      SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm()); 
      SolverCG<VectorType> cg(solver_control); 

      dst = 0; 

      try 
        { 
          cg.solve(*matrix, dst, src, preconditioner); 
        } 
      catch (std::exception &e) 
        { 
          Assert(false, ExcMessage(e.what())); 
        } 
    } 
// @sect4{Schur complement preconditioner}  

// 这是在介绍中详细描述的舒尔补码预处理程序的实现。与 step-20 和 step-22 相反，我们使用GMRES一次性解决块系统，并使用块结构矩阵的Schur补码来建立一个良好的预处理程序。

// 让我们看看介绍中描述的理想预处理矩阵  $P=\left(\begin{array}{cc} A & 0 \\ B & -S \end{array}\right)$  。如果我们在线性系统的求解中应用这个矩阵，迭代式GMRES求解器的收敛性将受矩阵
// @f{eqnarray*} P^{-1}\left(\begin{array}{cc} A &
//  B^T \\ B & 0 \end{array}\right) = \left(\begin{array}{cc} I & A^{-1}
//  B^T \\ 0 & I \end{array}\right), 
//  @f}
//  的制约，这确实非常简单。基于精确矩阵的GMRES求解器将在一次迭代中收敛，因为所有的特征值都是相等的（任何Krylov方法最多需要多少次迭代就有多少个不同的特征值）。Silvester和Wathen提出了这样一个用于受阻斯托克斯系统的预处理程序（"稳定的斯托克斯系统的快速迭代解第二部分。 Using general block preconditioners", SIAM J. Numer. Anal., 31 (1994), pp.1352-1367）。)

//用 $\tilde{P}$ 代替 $P$ 可以保持这种精神：乘积 $P^{-1} A$ 仍将接近于特征值为1的矩阵，其分布不取决于问题大小。这让我们希望能够得到一个与问题规模无关的GMRES迭代次数。

// 已经通过 step-20 和 step-22 教程的deal.II用户当然可以想象我们将如何实现这一点。 我们用一些由InverseMatrix类构建的近似逆矩阵取代 $P^{-1}$ 中的精确逆矩阵，逆舒尔补码将由压力质量矩阵 $M_p$ 近似（如介绍中提到的由 $\eta^{-1}$ 加权）。正如在 step-22 的结果部分所指出的，我们可以通过应用一个预处理程序来取代 $A$ 的精确逆，在这种情况下，如介绍中所解释的那样，在一个矢量拉普拉斯矩阵上。这确实增加了（外部）GMRES的迭代次数，但仍然比精确的逆运算便宜得多，因为 <em> 的每个 </em> 外部求解器步骤（使用AMG预处理程序）需要20到35次CG迭代。

// 考虑到上述解释，我们定义了一个具有 <code>vmult</code> 功能的预处理类，这就是我们在程序代码中进一步与通常的求解器函数交互所需要的。

// 首先是声明。这与 step-20 中Schur补码的定义相似，不同的是我们在构造函数中需要更多的预处理程序，而且我们在这里使用的矩阵是建立在Trilinos之上的。

    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    class BlockSchurPreconditioner : public Subscriptor 
    { 
    public: 
      BlockSchurPreconditioner( 
        const TrilinosWrappers::BlockSparseMatrix &S, 
        const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                            PreconditionerTypeMp> &Mpinv, 
        const PreconditionerTypeA &                Apreconditioner); 

      void vmult(TrilinosWrappers::MPI::BlockVector &      dst, 
                 const TrilinosWrappers::MPI::BlockVector &src) const; 

    private: 
      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> 
        stokes_matrix; 
      const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                                             PreconditionerTypeMp>> 
                                 m_inverse; 
      const PreconditionerTypeA &a_preconditioner; 

      mutable TrilinosWrappers::MPI::Vector tmp; 
    }; 

// 当使用 TrilinosWrappers::MPI::Vector 或 TrilinosWrappers::MPI::BlockVector, 时，Vector被使用IndexSet初始化。IndexSet不仅用于调整 TrilinosWrappers::MPI::Vector 的大小，而且还将 TrilinosWrappers::MPI::Vector 中的一个索引与一个自由度联系起来（更详细的解释见 step-40 ）。函数complete_index_set()创建了一个IndexSet，每个有效的索引都是这个集合的一部分。请注意，这个程序只能按顺序运行，如果并行使用，将抛出一个异常。

    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>:: 
      BlockSchurPreconditioner( 
        const TrilinosWrappers::BlockSparseMatrix &S, 
        const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                            PreconditionerTypeMp> &Mpinv, 
        const PreconditionerTypeA &                Apreconditioner) 
      : stokes_matrix(&S) 
      , m_inverse(&Mpinv) 
      , a_preconditioner(Apreconditioner) 
      , tmp(complete_index_set(stokes_matrix->block(1, 1).m())) 
    {} 

// 接下来是 <code>vmult</code> 函数。我们以三个连续的步骤实现上述 $P^{-1}$ 的动作。 在公式中，我们要计算 $Y=P^{-1}X$ ，其中 $X,Y$ 都是有两个块成分的向量。

// 第一步用矩阵 $A$ 的预处理乘以矢量的速度部分，即计算 $Y_0={\tilde A}^{-1}X_0$  。 然后将得到的速度矢量乘以 $B$ 并减去压力，即我们要计算 $X_1-BY_0$  。这第二步只作用于压力向量，由我们矩阵类的残差函数完成，只是符号不对。因此，我们改变临时压力向量中的符号，最后乘以反压力质量矩阵，得到最终的压力向量，完成我们对斯托克斯预处理的工作。

    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    void 
    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult( 
      TrilinosWrappers::MPI::BlockVector &      dst, 
      const TrilinosWrappers::MPI::BlockVector &src) const 
    { 
      a_preconditioner.vmult(dst.block(0), src.block(0)); 
      stokes_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1)); 
      tmp *= -1; 
      m_inverse->vmult(dst.block(1), tmp); 
    } 
  } // namespace LinearSolvers 

//  @sect3{The <code>BoussinesqFlowProblem</code> class template}  

// 定义了解决随时间变化的Boussinesq问题的顶层逻辑的类的定义主要是基于 step-22 的教程程序。主要的区别在于，现在我们还必须求解温度方程，这迫使我们为温度变量准备第二个DoFHandler对象，以及当前和之前的时间步骤的矩阵、右手边和求解向量。正如介绍中提到的，所有的线性代数对象都将使用相应的Trilinos功能的包装器。

// 这个类的成员函数让人想起 step-21 ，在那里我们也使用了一个交错的方案，首先解决流动方程（这里是斯托克斯方程， step-21 是达西流），然后更新平流量（这里是温度，那里是饱和度）。新的函数主要涉及到确定时间步长，以及人工粘性稳定的适当大小。

// 最后三个变量表示在下次调用相应的建立函数时，是否需要重建各种矩阵或预处理程序。这使得我们可以将相应的 <code>if</code> 移到相应的函数中，从而使我们的主 <code>run()</code> 函数保持干净，易于阅读。

  template <int dim> 
  class BoussinesqFlowProblem 
  { 
  public: 
    BoussinesqFlowProblem(); 
    void run(); 

  private: 
    void   setup_dofs(); 
    void   assemble_stokes_preconditioner(); 
    void   build_stokes_preconditioner(); 
    void   assemble_stokes_system(); 
    void   assemble_temperature_system(const double maximal_velocity); 
    void   assemble_temperature_matrix(); 
    double get_maximal_velocity() const; 
    std::pair<double, double> get_extrapolated_temperature_range() const; 
    void                      solve(); 
    void                      output_results() const; 
    void                      refine_mesh(const unsigned int max_grid_level); 

    double compute_viscosity( 
      const std::vector<double> &        old_temperature, 
      const std::vector<double> &        old_old_temperature, 
      const std::vector<Tensor<1, dim>> &old_temperature_grads, 
      const std::vector<Tensor<1, dim>> &old_old_temperature_grads, 
      const std::vector<double> &        old_temperature_laplacians, 
      const std::vector<double> &        old_old_temperature_laplacians, 
      const std::vector<Tensor<1, dim>> &old_velocity_values, 
      const std::vector<Tensor<1, dim>> &old_old_velocity_values, 
      const std::vector<double> &        gamma_values, 
      const double                       global_u_infty, 
      const double                       global_T_variation, 
      const double                       cell_diameter) const; 

    Triangulation<dim> triangulation; 
    double             global_Omega_diameter; 

    const unsigned int        stokes_degree; 
    FESystem<dim>             stokes_fe; 
    DoFHandler<dim>           stokes_dof_handler; 
    AffineConstraints<double> stokes_constraints; 

    std::vector<IndexSet>               stokes_partitioning; 
    TrilinosWrappers::BlockSparseMatrix stokes_matrix; 
    TrilinosWrappers::BlockSparseMatrix stokes_preconditioner_matrix; 

    TrilinosWrappers::MPI::BlockVector stokes_solution; 
    TrilinosWrappers::MPI::BlockVector old_stokes_solution; 
    TrilinosWrappers::MPI::BlockVector stokes_rhs; 

    const unsigned int        temperature_degree; 
    FE_Q<dim>                 temperature_fe; 
    DoFHandler<dim>           temperature_dof_handler; 
    AffineConstraints<double> temperature_constraints; 

    TrilinosWrappers::SparseMatrix temperature_mass_matrix; 
    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix; 
    TrilinosWrappers::SparseMatrix temperature_matrix; 

    TrilinosWrappers::MPI::Vector temperature_solution; 
    TrilinosWrappers::MPI::Vector old_temperature_solution; 
    TrilinosWrappers::MPI::Vector old_old_temperature_solution; 
    TrilinosWrappers::MPI::Vector temperature_rhs; 

    double       time_step; 
    double       old_time_step; 
    unsigned int timestep_number; 

    std::shared_ptr<TrilinosWrappers::PreconditionAMG> Amg_preconditioner; 
    std::shared_ptr<TrilinosWrappers::PreconditionIC>  Mp_preconditioner; 

    bool rebuild_stokes_matrix; 
    bool rebuild_temperature_matrices; 
    bool rebuild_stokes_preconditioner; 
  }; 
// @sect3{BoussinesqFlowProblem class implementation}  
// @sect4{BoussinesqFlowProblem::BoussinesqFlowProblem}  

// 这个类的构造函数是对  step-22  中的构造函数的扩展。我们需要添加涉及温度的各种变量。正如介绍中所讨论的，我们将再次使用 $Q_2\times Q_1$ （Taylor-Hood）元素来表示斯托克斯部分，并使用 $Q_2$ 元素表示温度。然而，通过使用存储斯托克斯和温度有限元的多项式程度的变量，可以很容易地持续修改这些元素的程度以及下游使用的所有正交公式。此外，我们还初始化了时间步长以及矩阵组合和预处理的选项。

  template <int dim> 
  BoussinesqFlowProblem<dim>::BoussinesqFlowProblem() 
    : triangulation(Triangulation<dim>::maximum_smoothing) 
    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN()) 
    , stokes_degree(1) 
    , stokes_fe(FE_Q<dim>(stokes_degree + 1), dim, FE_Q<dim>(stokes_degree), 1) 
    , stokes_dof_handler(triangulation) 
    , 

    temperature_degree(2) 
    , temperature_fe(temperature_degree) 
    , temperature_dof_handler(triangulation) 
    , 

    time_step(0) 
    , old_time_step(0) 
    , timestep_number(0) 
    , rebuild_stokes_matrix(true) 
    , rebuild_temperature_matrices(true) 
    , rebuild_stokes_preconditioner(true) 
  {} 

//  @sect4{BoussinesqFlowProblem::get_maximal_velocity}  

// 开始这个类的真正功能是一个辅助函数，确定域内（事实上是正交点）的最大（ $L_\infty$  ）速度。它是如何工作的，对所有已经达到本教程这一点的人来说应该是比较明显的。请注意，由于我们只对速度感兴趣，我们不使用 <code>stokes_fe_values.get_function_values</code> 来获取整个斯托克斯解的值（速度和压力），而是使用 <code>stokes_fe_values[velocities].get_function_values</code> 来提取速度部分。这样做的额外好处是，我们得到的是张量<1,dim>，而不是向量<double>中的一些分量，这样我们就可以马上用 <code>norm()</code> 函数来处理它，得到速度的大小。

// 唯一值得思考的一点是如何选择我们在这里使用的正交点。由于这个函数的目标是通过查看每个单元格上的正交点来寻找域内的最大速度。所以我们应该问，我们应该如何最好地选择每个单元上的这些正交点。为此，回顾一下，如果我们有一个单一的 $Q_1$ 场（而不是高阶的矢量值场），那么最大值将在网格的一个顶点达到。换句话说，我们应该使用QTrapezoid类，它的正交点只在单元的顶点。

// 对于高阶形状函数，情况更为复杂：最大值和最小值可能在形状函数的支持点之间达到（对于通常的 $Q_p$ 元素，支持点是等距的Lagrange插值点）；此外，由于我们正在寻找一个矢量值的最大幅值，我们更不能肯定地说潜在的最大点集合在哪里。然而，从直觉上讲，即使不能证明，拉格朗日插值点似乎也是比高斯点更好的选择。

// 现在有不同的方法来产生一个正交公式，其正交点等于有限元的插值点。一种选择是使用 FiniteElement::get_unit_support_points() 函数，将输出减少到一组唯一的点以避免重复的函数评估，并使用这些点创建一个正交对象。另一个选择，这里选择的是使用QTrapezoid类，并将其与QIterated类相结合，该类在每个坐标方向的若干子单元上重复QTrapezoid公式。为了覆盖所有的支持点，我们需要对其进行 <code>stokes_degree+1</code> 次迭代，因为这是使用中的斯托克斯元素的多项式程度。

  template <int dim> 
  double BoussinesqFlowProblem<dim>::get_maximal_velocity() const 
  { 
    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), stokes_degree + 1); 
    const unsigned int   n_q_points = quadrature_formula.size(); 

    FEValues<dim> fe_values(stokes_fe, quadrature_formula, update_values); 
    std::vector<Tensor<1, dim>> velocity_values(n_q_points); 
    double                      max_velocity = 0; 

    const FEValuesExtractors::Vector velocities(0); 

    for (const auto &cell : stokes_dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        fe_values[velocities].get_function_values(stokes_solution, 
                                                  velocity_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          max_velocity = std::max(max_velocity, velocity_values[q].norm()); 
      } 

    return max_velocity; 
  } 

//  @sect4{BoussinesqFlowProblem::get_extrapolated_temperature_range}  

// 接下来是一个函数，确定从前两个时间步长推算到当前步长时， $\Omega$ 内正交点的最低和最高温度。我们在计算人工粘性参数 $\nu$ 时需要这个信息，正如在介绍中所讨论的那样。

// 外推温度的公式是  $\left(1+\frac{k_n}{k_{n-1}} \right)T^{n-1} + \frac{k_n}{k_{n-1}} T^{n-2}$  。计算的方法是在所有正交点上循环，如果当前值比前一个值大/小，则更新最大和最小值。在对所有正交点进行循环之前，我们将存储最大和最小值的变量初始化为可表示为双数的最小和最大的数字。这样我们就知道它比最小/最大值大/小，并且所有正交点的循环最终会用正确的值来更新初始值。

// 这里唯一值得一提的复杂情况是，在第一个时间步骤中， $T^{k-2}$ 当然还不能使用。在这种情况下，我们只能使用 $T^{k-1}$ ，这是我们从初始温度得到的。作为正交点，我们使用与前一个函数相同的选择，但不同的是，现在重复的数量由温度场的多项式程度决定。

  template <int dim> 
  std::pair<double, double> 
  BoussinesqFlowProblem<dim>::get_extrapolated_temperature_range() const 
  { 
    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), 
                                            temperature_degree); 
    const unsigned int   n_q_points = quadrature_formula.size(); 

    FEValues<dim> fe_values(temperature_fe, quadrature_formula, update_values); 
    std::vector<double> old_temperature_values(n_q_points); 
    std::vector<double> old_old_temperature_values(n_q_points); 

    if (timestep_number != 0) 
      { 
        double min_temperature = std::numeric_limits<double>::max(), 
               max_temperature = -std::numeric_limits<double>::max(); 

        for (const auto &cell : temperature_dof_handler.active_cell_iterators()) 
          { 
            fe_values.reinit(cell); 
            fe_values.get_function_values(old_temperature_solution, 
                                          old_temperature_values); 
            fe_values.get_function_values(old_old_temperature_solution, 
                                          old_old_temperature_values); 

            for (unsigned int q = 0; q < n_q_points; ++q) 
              { 
                const double temperature = 
                  (1. + time_step / old_time_step) * old_temperature_values[q] - 
                  time_step / old_time_step * old_old_temperature_values[q]; 

                min_temperature = std::min(min_temperature, temperature); 
                max_temperature = std::max(max_temperature, temperature); 
              } 
          } 

        return std::make_pair(min_temperature, max_temperature); 
      } 
    else 
      { 
        double min_temperature = std::numeric_limits<double>::max(), 
               max_temperature = -std::numeric_limits<double>::max(); 

        for (const auto &cell : temperature_dof_handler.active_cell_iterators()) 
          { 
            fe_values.reinit(cell); 
            fe_values.get_function_values(old_temperature_solution, 
                                          old_temperature_values); 

            for (unsigned int q = 0; q < n_q_points; ++q) 
              { 
                const double temperature = old_temperature_values[q]; 

                min_temperature = std::min(min_temperature, temperature); 
                max_temperature = std::max(max_temperature, temperature); 
              } 
          } 

        return std::make_pair(min_temperature, max_temperature); 
      } 
  } 

//  @sect4{BoussinesqFlowProblem::compute_viscosity}  

// 最后一个工具函数计算单元 $\nu|_K$ 上的人工粘度参数 $K$ ，作为外推温度、其梯度和Hessian（二阶导数）、速度、当前单元正交点上的所有右手 $\gamma$ 和其他各种参数的函数，在介绍中已详细说明。

// 这里有一些值得一提的通用常数。首先，我们需要固定 $\beta$ ；我们选择 $\beta=0.017\cdot dim$ ，这个选择在本教程程序的结果部分有详细讨论。其次是指数 $\alpha$ ； $\alpha=1$ 对于目前的程序似乎很好用，尽管选择 $\alpha = 2$ 可能会有一些额外的好处。最后，有一件事需要特别说明。在第一个时间步骤中，速度等于零， $\nu|_K$ 的公式没有定义。在这种情况下，我们返回 $\nu|_K=5\cdot 10^3 \cdot h_K$ ，这个选择无疑更多的是出于启发式的考虑（不过，它与第二个时间步骤中大多数单元的返回值处于同一数量级）。

// 根据介绍中讨论的材料，该函数的其余部分应该是显而易见的。

  template <int dim> 
  double BoussinesqFlowProblem<dim>::compute_viscosity( 
    const std::vector<double> &        old_temperature, 
    const std::vector<double> &        old_old_temperature, 
    const std::vector<Tensor<1, dim>> &old_temperature_grads, 
    const std::vector<Tensor<1, dim>> &old_old_temperature_grads, 
    const std::vector<double> &        old_temperature_laplacians, 
    const std::vector<double> &        old_old_temperature_laplacians, 
    const std::vector<Tensor<1, dim>> &old_velocity_values, 
    const std::vector<Tensor<1, dim>> &old_old_velocity_values, 
    const std::vector<double> &        gamma_values, 
    const double                       global_u_infty, 
    const double                       global_T_variation, 
    const double                       cell_diameter) const 
  { 
    constexpr double beta  = 0.017 * dim; 
    constexpr double alpha = 1.0; 

    if (global_u_infty == 0) 
      return 5e-3 * cell_diameter; 

    const unsigned int n_q_points = old_temperature.size(); 

    double max_residual = 0; 
    double max_velocity = 0; 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        const Tensor<1, dim> u = 
          (old_velocity_values[q] + old_old_velocity_values[q]) / 2; 

        const double dT_dt = 
          (old_temperature[q] - old_old_temperature[q]) / old_time_step; 
        const double u_grad_T = 
          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2; 

        const double kappa_Delta_T = 
          EquationData::kappa * 
          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) / 
          2; 

        const double residual = 
          std::abs((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) * 
                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2, 
                            alpha - 1.)); 

        max_residual = std::max(residual, max_residual); 
        max_velocity = std::max(std::sqrt(u * u), max_velocity); 
      } 

    const double c_R            = std::pow(2., (4. - 2 * alpha) / dim); 
    const double global_scaling = c_R * global_u_infty * global_T_variation * 
                                  std::pow(global_Omega_diameter, alpha - 2.); 

    return ( 
      beta * max_velocity * 
      std::min(cell_diameter, 
               std::pow(cell_diameter, alpha) * max_residual / global_scaling)); 
  } 

//  @sect4{BoussinesqFlowProblem::setup_dofs}  

// 这是一个函数，用于设置我们这里的DoFHandler对象（一个用于斯托克斯部分，一个用于温度部分），以及将本程序中线性代数所需的各种对象设置为合适的尺寸。它的基本操作与我们在  step-22  中的操作类似。

// 该函数的主体首先列举了斯托克斯和温度系统的所有自由度。对于斯托克斯部分，自由度被排序，以确保速度优先于压力自由度，这样我们就可以将斯托克斯矩阵划分为一个 $2\times 2$ 矩阵。作为与 step-22 的区别，我们不进行任何额外的DoF重新编号。在那个程序中，它得到了回报，因为我们的求解器严重依赖ILU，而我们在这里使用AMG，它对DoF编号不敏感。用于压力质量矩阵反演的IC预处理程序当然会利用类似Cuthill-McKee的重新编号，但是与速度部分相比，其成本很低，所以额外的工作并没有得到回报。

// 然后，我们继续生成悬挂的节点约束，这些约束来自两个DoFHandler对象的自适应网格细化。对于速度，我们通过向已经存储了悬挂节点约束矩阵的对象添加约束来施加无流边界条件 $\mathbf{u}\cdot \mathbf{n}=0$ 。函数中的第二个参数描述了总dof向量中的第一个速度分量，这里是零。变量 <code>no_normal_flux_boundaries</code> 表示要设置无通量边界条件的边界指标；这里是边界指标0。

// 做完这些后，我们计算各块中的自由度数量。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::setup_dofs() 
  { 
    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0); 
    stokes_sub_blocks[dim] = 1; 

    { 
      stokes_dof_handler.distribute_dofs(stokes_fe); 
      DoFRenumbering::component_wise(stokes_dof_handler, stokes_sub_blocks); 

      stokes_constraints.clear(); 
      DoFTools::make_hanging_node_constraints(stokes_dof_handler, 
                                              stokes_constraints); 
      std::set<types::boundary_id> no_normal_flux_boundaries; 
      no_normal_flux_boundaries.insert(0); 
      VectorTools::compute_no_normal_flux_constraints(stokes_dof_handler, 
                                                      0, 
                                                      no_normal_flux_boundaries, 
                                                      stokes_constraints); 
      stokes_constraints.close(); 
    } 
    { 
      temperature_dof_handler.distribute_dofs(temperature_fe); 

      temperature_constraints.clear(); 
      DoFTools::make_hanging_node_constraints(temperature_dof_handler, 
                                              temperature_constraints); 
      temperature_constraints.close(); 
    } 

    const std::vector<types::global_dof_index> stokes_dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(stokes_dof_handler, stokes_sub_blocks); 

    const unsigned int n_u = stokes_dofs_per_block[0], 
                       n_p = stokes_dofs_per_block[1], 
                       n_T = temperature_dof_handler.n_dofs(); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << " (on " << triangulation.n_levels() << " levels)" << std::endl 
              << "Number of degrees of freedom: " << n_u + n_p + n_T << " (" 
              << n_u << '+' << n_p << '+' << n_T << ')' << std::endl 
              << std::endl; 

// 下一步是创建斯托克斯和温度系统矩阵的稀疏模式，以及建立斯托克斯预处理矩阵的预处理。如同在 step-22 中一样，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。

// 因此，我们首先释放存储在矩阵中的内存，然后建立一个BlockDynamicSparsityPattern类型的对象，该对象由 $2\times 2$ 块（用于斯托克斯系统矩阵和预处理器）或DynamicSparsityPattern（用于温度部分）组成。然后我们用非零模式填充这些对象，考虑到对于斯托克斯系统矩阵，在压力-压力块中没有条目（但所有速度矢量分量相互耦合并与压力耦合）。同样，在斯托克斯预处理矩阵中，只有对角线块是非零的，因为我们使用了介绍中讨论的矢量拉普拉斯。这个算子只把拉普拉斯的每个矢量分量与它自己联系起来，而不是与其他矢量分量联系起来。然而，应用无流量边界条件产生的约束条件将在边界处再次耦合向量分量）。

// 在生成稀疏模式时，我们直接应用悬挂节点和无流边界条件的约束。这种方法在 step-27 中已经使用过了，但与早期教程中的方法不同，在早期教程中我们先建立原始的稀疏模式，然后才加入约束条件产生的条目。这样做的原因是，在以后的装配过程中，我们要在将本地道夫转移到全局道夫时立即分配约束。因此，在受限自由度的位置不会有数据写入，所以我们可以通过将最后一个布尔标志设置为 <code>false</code> ，让 DoFTools::make_sparsity_pattern 函数省略这些条目。一旦稀疏性模式准备好了，我们就可以用它来初始化特里诺斯矩阵。由于Trilinos矩阵在内部存储了稀疏模式，所以在初始化矩阵之后，没有必要再保留稀疏模式。

    stokes_partitioning.resize(2); 
    stokes_partitioning[0] = complete_index_set(n_u); 
    stokes_partitioning[1] = complete_index_set(n_p); 
    { 
      stokes_matrix.clear(); 

      BlockDynamicSparsityPattern dsp(2, 2); 

      dsp.block(0, 0).reinit(n_u, n_u); 
      dsp.block(0, 1).reinit(n_u, n_p); 
      dsp.block(1, 0).reinit(n_p, n_u); 
      dsp.block(1, 1).reinit(n_p, n_p); 

      dsp.collect_sizes(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 

      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (!((c == dim) && (d == dim))) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern( 
        stokes_dof_handler, coupling, dsp, stokes_constraints, false); 

      stokes_matrix.reinit(dsp); 
    } 

    { 
      Amg_preconditioner.reset(); 
      Mp_preconditioner.reset(); 
      stokes_preconditioner_matrix.clear(); 

      BlockDynamicSparsityPattern dsp(2, 2); 

      dsp.block(0, 0).reinit(n_u, n_u); 
      dsp.block(0, 1).reinit(n_u, n_p); 
      dsp.block(1, 0).reinit(n_p, n_u); 
      dsp.block(1, 1).reinit(n_p, n_p); 

      dsp.collect_sizes(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (c == d) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern( 
        stokes_dof_handler, coupling, dsp, stokes_constraints, false); 

      stokes_preconditioner_matrix.reinit(dsp); 
    } 

// 温度矩阵（或者说是矩阵，因为我们提供了一个温度质量矩阵和一个温度刚度矩阵，它们将在时间离散化中被加在一起）的创建与斯托克斯矩阵的生成相同；只是在这里要简单得多，因为我们不需要照顾任何块或组件之间的耦合。注意我们是如何初始化三个温度矩阵的。我们只使用稀疏模式对第一个矩阵进行再初始化，而对其余两个再初始化则使用先前生成的矩阵。这样做的原因是，从一个已经生成的矩阵进行重新初始化，可以让Trilinos重新使用稀疏模式，而不是为每个副本生成一个新的模式。这样可以节省一些时间和内存。

    { 
      temperature_mass_matrix.clear(); 
      temperature_stiffness_matrix.clear(); 
      temperature_matrix.clear(); 

      DynamicSparsityPattern dsp(n_T, n_T); 
      DoFTools::make_sparsity_pattern(temperature_dof_handler, 
                                      dsp, 
                                      temperature_constraints, 
                                      false); 

      temperature_matrix.reinit(dsp); 
      temperature_mass_matrix.reinit(temperature_matrix); 
      temperature_stiffness_matrix.reinit(temperature_matrix); 
    } 

// 最后，我们将斯托克斯解的向量 $\mathbf u^{n-1}$ 和 $\mathbf u^{n-2}$ ，以及温度 $T^{n}$ 、 $T^{n-1}$ 和 $T^{n-2}$ （时间步进所需）和所有系统的右手边设置为正确的大小和块结构。

    IndexSet temperature_partitioning = complete_index_set(n_T); 
    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD); 
    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD); 
    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD); 

    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD); 
    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD); 
    old_old_temperature_solution.reinit(temperature_partitioning, 
                                        MPI_COMM_WORLD); 

    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD); 
  } 

//  @sect4{BoussinesqFlowProblem::assemble_stokes_preconditioner}  

// 这个函数组装了我们用于预处理斯托克斯系统的矩阵。我们需要的是速度分量上的矢量拉普拉斯矩阵和压力分量上的质量矩阵，并以 $\eta^{-1}$ 加权。我们首先生成一个适当阶数的正交对象，即FEValues对象，它可以给出正交点的值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量 <code>grad_phi_u</code> and <code>phi_p</code> 将保存基函数的值，以便更快地建立局部矩阵，正如在 step-22 中已经完成的那样。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_stokes_preconditioner() 
  { 
    stokes_preconditioner_matrix = 0; 

    const QGauss<dim> quadrature_formula(stokes_degree + 2); 
    FEValues<dim>     stokes_fe_values(stokes_fe, 
                                   quadrature_formula, 
                                   update_JxW_values | update_values | 
                                     update_gradients); 

    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell); 
    std::vector<double>         phi_p(dofs_per_cell); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    for (const auto &cell : stokes_dof_handler.active_cell_iterators()) 
      { 
        stokes_fe_values.reinit(cell); 
        local_matrix = 0; 

// 本地矩阵的创建相当简单。只有一个拉普拉斯项（关于速度）和一个由 $\eta^{-1}$ 加权的质量矩阵需要生成，所以本地矩阵的创建在两行中完成。一旦本地矩阵准备好了（在每个正交点上循环查看本地矩阵的行和列），我们就可以得到本地的DoF指数，并将本地信息写入全局矩阵中。我们像在 step-27 中那样做，也就是说，我们直接应用本地悬挂节点的约束。这样做，我们就不必事后再做，而且我们也不会在消除约束时将矩阵的条目写成实际上将再次设置为零。

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q); 
                phi_p[k]      = stokes_fe_values[pressure].value(k, q); 
              } 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                local_matrix(i, j) += 
                  (EquationData::eta * 
                     scalar_product(grad_phi_u[i], grad_phi_u[j]) + 
                   (1. / EquationData::eta) * phi_p[i] * phi_p[j]) * 
                  stokes_fe_values.JxW(q); 
          } 

        cell->get_dof_indices(local_dof_indices); 
        stokes_constraints.distribute_local_to_global( 
          local_matrix, local_dof_indices, stokes_preconditioner_matrix); 
      } 
  } 

//  @sect4{BoussinesqFlowProblem::build_stokes_preconditioner}  

// 这个函数生成将用于Schur互补块预处理的内部预处理。由于只有当矩阵发生变化时才需要重新生成预处理程序，因此在矩阵没有变化的情况下，该函数不需要做任何事情（即标志 <code>rebuild_stokes_preconditioner</code> 的值为 <code>false</code> ）。否则，它的第一个任务是调用 <code>assemble_stokes_preconditioner</code> 来生成预处理矩阵。

// 接下来，我们为速度-速度矩阵  $A$  设置预处理程序。正如介绍中所解释的，我们将使用基于矢量拉普拉斯矩阵 $\hat{A}$ 的AMG预处理器（它在频谱上与斯托克斯矩阵 $A$ 接近）。通常， TrilinosWrappers::PreconditionAMG 类可以被看作是一个好的黑箱预处理程序，不需要任何特殊的知识。然而，在这种情况下，我们必须小心：因为我们为一个矢量问题建立了一个AMG，我们必须告诉预处理程序设置哪个道夫属于哪个矢量成分。我们使用 DoFTools::extract_constant_modes, 函数来做这件事，该函数生成一组 <code>dim</code> 向量，其中每个向量在向量问题的相应分量中为1，在其他地方为0。因此，这些是每个分量上的常数模式，这解释了变量的名称。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::build_stokes_preconditioner() 
  { 
    if (rebuild_stokes_preconditioner == false) 
      return; 

    std::cout << "   Rebuilding Stokes preconditioner..." << std::flush; 

    assemble_stokes_preconditioner(); 

    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionAMG>(); 

    std::vector<std::vector<bool>> constant_modes; 
    FEValuesExtractors::Vector     velocity_components(0); 
    DoFTools::extract_constant_modes(stokes_dof_handler, 
                                     stokes_fe.component_mask( 
                                       velocity_components), 
                                     constant_modes); 
    TrilinosWrappers::PreconditionAMG::AdditionalData amg_data; 
    amg_data.constant_modes = constant_modes; 

// 接下来，我们再设置一些AMG预处理程序的选项。特别是，我们需要告诉AMG设置，我们对速度矩阵使用二次基函数（这意味着矩阵中有更多的非零元素，因此需要在内部选择一种更稳健的算法）。此外，我们希望能够控制粗化结构的建立方式。Trilinos平滑聚合AMG的方法是寻找哪些矩阵条目与对角线条目大小相似，以便代数式地建立一个粗网格结构。通过将参数 <code>aggregation_threshold</code> 设置为0.02，我们指定所有尺寸超过该行中一些对角线枢轴的百分之二的条目应该形成一个粗网格点。这个参数是比较特别的，对它进行一些微调会影响预处理程序的性能。根据经验，较大的 <code>aggregation_threshold</code> 值会减少迭代次数，但增加每次迭代的成本。看一下Trilinos的文档会提供更多关于这些参数的信息。有了这个数据集，我们就用我们想要的矩阵来初始化预处理程序。

// 最后，我们也初始化预处理程序以反转压力质量矩阵。这个矩阵是对称的，表现良好，所以我们可以选择一个简单的预处理程序。我们坚持使用不完全Cholesky（IC）因子化预处理器，它是为对称矩阵设计的。我们也可以选择SSOR预处理器，其松弛系数约为1.2，但IC对我们的例子来说更便宜。我们把预处理程序包成一个 <code>std::shared_ptr</code> 指针，这使得下次重新创建预处理程序更加容易，因为我们不必关心破坏以前使用的对象。

    amg_data.elliptic              = true; 
    amg_data.higher_order_elements = true; 
    amg_data.smoother_sweeps       = 2; 
    amg_data.aggregation_threshold = 0.02; 
    Amg_preconditioner->initialize(stokes_preconditioner_matrix.block(0, 0), 
                                   amg_data); 

    Mp_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>(); 
    Mp_preconditioner->initialize(stokes_preconditioner_matrix.block(1, 1)); 

    std::cout << std::endl; 

    rebuild_stokes_preconditioner = false; 
  } 

//  @sect4{BoussinesqFlowProblem::assemble_stokes_system}  

// 我们用于推进耦合的斯托克斯-温度系统的时滞方案迫使我们将装配（以及线性系统的解）分成两步。第一步是创建斯托克斯系统的矩阵和右手边，第二步是创建温度道夫的矩阵和右手边，这取决于速度的线性系统的结果。

// 该函数在每个时间步长的开始时被调用。在第一个时间步骤中，或者如果网格已经改变，由 <code>rebuild_stokes_matrix</code> 表示，我们需要组装斯托克斯矩阵；另一方面，如果网格没有改变，矩阵已经有了，这就没有必要了，我们需要做的就是组装右手边的向量，它在每个时间步骤中都会改变。

// 关于实现的技术细节，与  step-22  相比没有太大变化。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。对于更新标志，我们只在完全装配的情况下需要基函数导数，因为右手边不需要它们；像往常一样，根据当前需要选择最小的标志集，使程序中进一步调用  FEValues::reinit  的效率更高。

// 有一件事需要评论&ndash；因为我们有一个单独的有限元和DoFHandler来处理温度问题，所以我们需要生成第二个FEValues对象来正确评估温度解决方案。要实现这一点并不复杂：只需使用温度结构，并为我们需要用于评估温度解决方案的基函数值设置一个更新标志。这里需要记住的唯一重要部分是，两个FEValues对象使用相同的正交公式，以确保我们在循环计算两个对象的正交点时得到匹配的信息。

// 声明的过程中，有一些关于数组大小的快捷方式，本地矩阵和右手的创建，以及与全局系统相比，本地道夫的索引的向量。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_stokes_system() 
  { 
    std::cout << "   Assembling..." << std::flush; 

    if (rebuild_stokes_matrix == true) 
      stokes_matrix = 0; 

    stokes_rhs = 0; 

    const QGauss<dim> quadrature_formula(stokes_degree + 2); 
    FEValues<dim>     stokes_fe_values( 
      stokes_fe, 
      quadrature_formula, 
      update_values | update_quadrature_points | update_JxW_values | 
        (rebuild_stokes_matrix == true ? update_gradients : UpdateFlags(0))); 

    FEValues<dim> temperature_fe_values(temperature_fe, 
                                        quadrature_formula, 
                                        update_values); 

    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 接下来我们需要一个向量，它将包含前一个时间层的温度解在正交点的值，以组装动量方程右侧的源项。让我们把这个向量称为  <code>old_solution_values</code>  。

// 我们接下来创建的向量集包含了基函数的评估以及它们的梯度和对称梯度，将用于创建矩阵。将这些放到自己的数组中，而不是每次都向FEValues对象索取这些信息，是为了加速装配过程的优化，详情请参见 step-22 。

// 最后两个声明是用来从整个FE系统中提取各个块（速度、压力、温度）的。

    std::vector<double> old_temperature_values(n_q_points); 

    std::vector<Tensor<1, dim>>          phi_u(dofs_per_cell); 
    std::vector<SymmetricTensor<2, dim>> grads_phi_u(dofs_per_cell); 
    std::vector<double>                  div_phi_u(dofs_per_cell); 
    std::vector<double>                  phi_p(dofs_per_cell); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

// 现在开始对问题中的所有单元格进行循环。我们正在为这个装配例程处理两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，因为斯托克斯系统和温度系统都使用相同的网格，但这是保持自由度同步的唯一方法。循环中的第一条语句也是非常熟悉的，按照更新标志的规定对有限元数据进行更新，将局部数组清零，并在正交点处获得旧解的值。然后我们准备在单元格上的正交点上循环。

    auto       cell             = stokes_dof_handler.begin_active(); 
    const auto endc             = stokes_dof_handler.end(); 
    auto       temperature_cell = temperature_dof_handler.begin_active(); 

    for (; cell != endc; ++cell, ++temperature_cell) 
      { 
        stokes_fe_values.reinit(cell); 
        temperature_fe_values.reinit(temperature_cell); 

        local_matrix = 0; 
        local_rhs    = 0; 

        temperature_fe_values.get_function_values(old_temperature_solution, 
                                                  old_temperature_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double old_temperature = old_temperature_values[q]; 

// 接下来我们提取与内积中的条款相关的基础函数的值和梯度。如 step-22 所示，这有助于加速装配。    一旦完成，我们开始在本地矩阵的行和列上进行循环，并将相关的乘积送入矩阵。右手边是由温度驱动的重力方向（在我们的例子中是垂直方向）的强迫项。 请注意，右手边的项总是生成的，而矩阵的贡献只有在 <code>rebuild_matrices</code> 标志要求时才会更新。

            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                phi_u[k] = stokes_fe_values[velocities].value(k, q); 
                if (rebuild_stokes_matrix) 
                  { 
                    grads_phi_u[k] = 
                      stokes_fe_values[velocities].symmetric_gradient(k, q); 
                    div_phi_u[k] = 
                      stokes_fe_values[velocities].divergence(k, q); 
                    phi_p[k] = stokes_fe_values[pressure].value(k, q); 
                  } 
              } 

            if (rebuild_stokes_matrix) 
              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                  local_matrix(i, j) += 
                    (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) - 
                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) * 
                    stokes_fe_values.JxW(q); 

            const Point<dim> gravity = 
              -((dim == 2) ? (Point<dim>(0, 1)) : (Point<dim>(0, 0, 1))); 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              local_rhs(i) += (-EquationData::density * EquationData::beta * 
                               gravity * phi_u[i] * old_temperature) * 
                              stokes_fe_values.JxW(q); 
          } 

// 循环所有单元的最后一步是将局部贡献输入到全局矩阵和向量结构中，并将其输入到  <code>local_dof_indices</code>  指定的位置。 同样，我们让AffineConstraints类来完成将单元格矩阵元素插入全局矩阵的工作，这已经浓缩了悬挂的节点约束。

        cell->get_dof_indices(local_dof_indices); 

        if (rebuild_stokes_matrix == true) 
          stokes_constraints.distribute_local_to_global(local_matrix, 
                                                        local_rhs, 
                                                        local_dof_indices, 
                                                        stokes_matrix, 
                                                        stokes_rhs); 
        else 
          stokes_constraints.distribute_local_to_global(local_rhs, 
                                                        local_dof_indices, 
                                                        stokes_rhs); 
      } 

    rebuild_stokes_matrix = false; 

    std::cout << std::endl; 
  } 

//  @sect4{BoussinesqFlowProblem::assemble_temperature_matrix}  

// 这个函数组装温度方程中的矩阵。温度矩阵由两部分组成，质量矩阵和时间步长乘以刚度矩阵，由拉普拉斯项乘以扩散量给出。由于该矩阵取决于时间步长（从一个步长到另一个步长），温度矩阵需要在每个时间步长进行更新。我们可以简单地在每个时间步长中重新生成矩阵，但这并不真正有效，因为质量和拉普拉斯矩阵只有在我们改变网格时才会改变。因此，我们通过在这个函数中生成两个单独的矩阵，一个是质量矩阵，一个是刚度（扩散）矩阵，这样做更有效率。一旦我们知道了实际的时间步长，我们将把这个矩阵加上刚度矩阵乘以时间步长的总和。

// 所以这第一步的细节非常简单。为了防止我们需要重建矩阵（即网格发生了变化），我们将数据结构归零，得到一个正交公式和一个FEValues对象，并为基函数创建局部矩阵、局部dof指数和评估结构。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_temperature_matrix() 
  { 
    if (rebuild_temperature_matrices == false) 
      return; 

    temperature_mass_matrix      = 0; 
    temperature_stiffness_matrix = 0; 

    QGauss<dim>   quadrature_formula(temperature_degree + 2); 
    FEValues<dim> temperature_fe_values(temperature_fe, 
                                        quadrature_formula, 
                                        update_values | update_gradients | 
                                          update_JxW_values); 

    const unsigned int dofs_per_cell = temperature_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> local_mass_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> local_stiffness_matrix(dofs_per_cell, dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    std::vector<double>         phi_T(dofs_per_cell); 
    std::vector<Tensor<1, dim>> grad_phi_T(dofs_per_cell); 

// 现在，让我们开始在三角结构中的所有单元上进行循环。我们需要将局部矩阵清零，更新有限元评估，然后在每个正交点上循环矩阵的行和列，然后我们创建质量矩阵和刚度矩阵（拉普拉斯项乘以扩散  <code>EquationData::kappa</code>  。最后，我们让约束对象将这些值插入全局矩阵中，并直接将约束条件浓缩到矩阵中。

    for (const auto &cell : temperature_dof_handler.active_cell_iterators()) 
      { 
        local_mass_matrix      = 0; 
        local_stiffness_matrix = 0; 

        temperature_fe_values.reinit(cell); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q); 
                phi_T[k]      = temperature_fe_values.shape_value(k, q); 
              } 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  local_mass_matrix(i, j) += 
                    (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q)); 
                  local_stiffness_matrix(i, j) += 
                    (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] * 
                     temperature_fe_values.JxW(q)); 
                } 
          } 

        cell->get_dof_indices(local_dof_indices); 

        temperature_constraints.distribute_local_to_global( 
          local_mass_matrix, local_dof_indices, temperature_mass_matrix); 
        temperature_constraints.distribute_local_to_global( 
          local_stiffness_matrix, 
          local_dof_indices, 
          temperature_stiffness_matrix); 
      } 

    rebuild_temperature_matrices = false; 
  } 

//  @sect4{BoussinesqFlowProblem::assemble_temperature_system}  

// 这个函数对温度矩阵进行第二部分的装配工作，实际添加压力质量和刚度矩阵（时间步长在这里起作用），以及创建依赖于速度的右手边。这个函数中的右侧装配的声明与其他装配例程中使用的声明基本相同，只是这次我们把自己限制在矢量上。我们将计算温度系统的残差，这意味着我们必须评估二阶导数，由更新标志 <code>update_hessians</code> 指定。

// 温度方程通过流体速度与斯托克斯系统相耦合。解决方案的这两部分与不同的DoFHandlers相关联，因此我们需要再次创建第二个FEValues对象来评估正交点的速度。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_temperature_system( 
    const double maximal_velocity) 
  { 
    const bool use_bdf2_scheme = (timestep_number != 0); 

    if (use_bdf2_scheme == true) 
      { 
        temperature_matrix.copy_from(temperature_mass_matrix); 
        temperature_matrix *= 
          (2 * time_step + old_time_step) / (time_step + old_time_step); 
        temperature_matrix.add(time_step, temperature_stiffness_matrix); 
      } 
    else 
      { 
        temperature_matrix.copy_from(temperature_mass_matrix); 
        temperature_matrix.add(time_step, temperature_stiffness_matrix); 
      } 

    temperature_rhs = 0; 

    const QGauss<dim> quadrature_formula(temperature_degree + 2); 
    FEValues<dim>     temperature_fe_values(temperature_fe, 
                                        quadrature_formula, 
                                        update_values | update_gradients | 
                                          update_hessians | 
                                          update_quadrature_points | 
                                          update_JxW_values); 
    FEValues<dim>     stokes_fe_values(stokes_fe, 
                                   quadrature_formula, 
                                   update_values); 

    const unsigned int dofs_per_cell = temperature_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double> local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 接下来是向量的声明，用来保存旧的和更早的解决方案的值（分别作为时间级别 $n-1$ 和 $n-2$ 的符号）和当前单元的正交点的梯度。我们还声明了一个对象来保存温度的右侧值（ <code>gamma_values</code> ），并且我们再次使用温度基函数的快捷方式。最终，我们需要找到温度极值和计算域的直径，这将用于稳定参数的定义（我们得到了最大速度作为这个函数的输入）。

    std::vector<Tensor<1, dim>> old_velocity_values(n_q_points); 
    std::vector<Tensor<1, dim>> old_old_velocity_values(n_q_points); 
    std::vector<double>         old_temperature_values(n_q_points); 
    std::vector<double>         old_old_temperature_values(n_q_points); 
    std::vector<Tensor<1, dim>> old_temperature_grads(n_q_points); 
    std::vector<Tensor<1, dim>> old_old_temperature_grads(n_q_points); 
    std::vector<double>         old_temperature_laplacians(n_q_points); 
    std::vector<double>         old_old_temperature_laplacians(n_q_points); 

    EquationData::TemperatureRightHandSide<dim> temperature_right_hand_side; 
    std::vector<double>                         gamma_values(n_q_points); 

    std::vector<double>         phi_T(dofs_per_cell); 
    std::vector<Tensor<1, dim>> grad_phi_T(dofs_per_cell); 

    const std::pair<double, double> global_T_range = 
      get_extrapolated_temperature_range(); 

    const FEValuesExtractors::Vector velocities(0); 

// 现在，让我们开始在三角结构中的所有单元格上进行循环。同样，我们需要两个单元格迭代器，平行走过两个参与的DoFHandler对象的单元格，用于斯托克斯和温度部分。在这个循环中，我们首先将局部rhs设置为零，然后在正交点上获得旧的解函数的值和导数，因为它们将被用于稳定参数的定义和作为方程中的系数，分别需要。请注意，由于温度有自己的DoFHandler和FEValues对象，我们在正交点得到整个解（反正只有标量温度场），而对于斯托克斯部分，我们仅限于通过使用 <code>stokes_fe_values[velocities].get_function_values</code> 提取速度部分（而忽略压力部分）。

    auto       cell        = temperature_dof_handler.begin_active(); 
    const auto endc        = temperature_dof_handler.end(); 
    auto       stokes_cell = stokes_dof_handler.begin_active(); 

    for (; cell != endc; ++cell, ++stokes_cell) 
      { 
        local_rhs = 0; 

        temperature_fe_values.reinit(cell); 
        stokes_fe_values.reinit(stokes_cell); 

        temperature_fe_values.get_function_values(old_temperature_solution, 
                                                  old_temperature_values); 
        temperature_fe_values.get_function_values(old_old_temperature_solution, 
                                                  old_old_temperature_values); 

        temperature_fe_values.get_function_gradients(old_temperature_solution, 
                                                     old_temperature_grads); 
        temperature_fe_values.get_function_gradients( 
          old_old_temperature_solution, old_old_temperature_grads); 

        temperature_fe_values.get_function_laplacians( 
          old_temperature_solution, old_temperature_laplacians); 
        temperature_fe_values.get_function_laplacians( 
          old_old_temperature_solution, old_old_temperature_laplacians); 

        temperature_right_hand_side.value_list( 
          temperature_fe_values.get_quadrature_points(), gamma_values); 

        stokes_fe_values[velocities].get_function_values(stokes_solution, 
                                                         old_velocity_values); 
        stokes_fe_values[velocities].get_function_values( 
          old_stokes_solution, old_old_velocity_values); 

// 接下来，我们根据介绍中的讨论，使用专用函数计算用于稳定的人工粘性。有了这个，我们就可以进入正交点和局部rhs矢量分量的循环了。这里的术语相当冗长，但其定义遵循本方案介绍中开发的时间-离散系统。BDF-2方案比用于第一时间步的后向欧拉方案多需要一个旧时间步的术语（并且涉及更复杂的因素）。当所有这些都完成后，我们将局部向量分配到全局向量中（包括悬挂节点约束）。

        const double nu = 
          compute_viscosity(old_temperature_values, 
                            old_old_temperature_values, 
                            old_temperature_grads, 
                            old_old_temperature_grads, 
                            old_temperature_laplacians, 
                            old_old_temperature_laplacians, 
                            old_velocity_values, 
                            old_old_velocity_values, 
                            gamma_values, 
                            maximal_velocity, 
                            global_T_range.second - global_T_range.first, 
                            cell->diameter()); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q); 
                phi_T[k]      = temperature_fe_values.shape_value(k, q); 
              } 

            const double T_term_for_rhs = 
              (use_bdf2_scheme ? 
                 (old_temperature_values[q] * (1 + time_step / old_time_step) - 
                  old_old_temperature_values[q] * (time_step * time_step) / 
                    (old_time_step * (time_step + old_time_step))) : 
                 old_temperature_values[q]); 

            const Tensor<1, dim> ext_grad_T = 
              (use_bdf2_scheme ? 
                 (old_temperature_grads[q] * (1 + time_step / old_time_step) - 
                  old_old_temperature_grads[q] * time_step / old_time_step) : 
                 old_temperature_grads[q]); 

            const Tensor<1, dim> extrapolated_u = 
              (use_bdf2_scheme ? 
                 (old_velocity_values[q] * (1 + time_step / old_time_step) - 
                  old_old_velocity_values[q] * time_step / old_time_step) : 
                 old_velocity_values[q]); 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              local_rhs(i) += 
                (T_term_for_rhs * phi_T[i] - 
                 time_step * extrapolated_u * ext_grad_T * phi_T[i] - 
                 time_step * nu * ext_grad_T * grad_phi_T[i] + 
                 time_step * gamma_values[q] * phi_T[i]) * 
                temperature_fe_values.JxW(q); 
          } 

        cell->get_dof_indices(local_dof_indices); 
        temperature_constraints.distribute_local_to_global(local_rhs, 
                                                           local_dof_indices, 
                                                           temperature_rhs); 
      } 
  } 

//  @sect4{BoussinesqFlowProblem::solve}  

// 这个函数可以解决线性方程组的问题。在介绍之后，我们从斯托克斯系统开始，在这里我们需要生成我们的块状舒尔预处理器。由于所有相关的动作都在类 <code>BlockSchurPreconditioner</code> 中实现，我们所要做的就是适当地初始化这个类。我们需要传递的是一个用于压力质量矩阵的 <code>InverseMatrix</code> 对象，我们使用相应的类和我们已经生成的IC预处理器以及用于速度-速度矩阵的AMG预处理器一起设置。注意， <code>Mp_preconditioner</code> 和 <code>Amg_preconditioner</code> 都只是指针，所以我们用 <code>*</code> 来传递实际的预处理对象。

// 一旦预处理程序准备好了，我们就为该块系统创建一个GMRES求解器。由于我们使用的是Trilinos数据结构，我们必须在求解器中设置相应的模板参数。GMRES需要在内部存储每次迭代的临时向量（见 step-22 的结果部分的讨论）&ndash；它可以使用的向量越多，一般来说性能越好。为了控制内存需求，我们将向量的数量设置为100。这意味着在求解器的100次迭代中，每个临时向量都可以被存储。如果求解器需要更频繁地迭代以获得指定的容忍度，它将通过每100次迭代重新开始，在一个减少的向量集上工作。

// 有了这些设置，我们求解系统并在斯托克斯系统中分配约束条件，即悬挂节点和无流体边界条件，以便即使在受约束的道夫下也有适当的解值。最后，我们把迭代次数写到屏幕上。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::solve() 
  { 
    std::cout << "   Solving..." << std::endl; 

    { 
      const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix, 
                                         TrilinosWrappers::PreconditionIC> 
        mp_inverse(stokes_preconditioner_matrix.block(1, 1), 
                   *Mp_preconditioner); 

      const LinearSolvers::BlockSchurPreconditioner< 
        TrilinosWrappers::PreconditionAMG, 
        TrilinosWrappers::PreconditionIC> 
        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner); 

      SolverControl solver_control(stokes_matrix.m(), 
                                   1e-6 * stokes_rhs.l2_norm()); 

      SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres( 
        solver_control, 
        SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData(100)); 

      for (unsigned int i = 0; i < stokes_solution.size(); ++i) 
        if (stokes_constraints.is_constrained(i)) 
          stokes_solution(i) = 0; 

      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner); 

      stokes_constraints.distribute(stokes_solution); 

      std::cout << "   " << solver_control.last_step() 
                << " GMRES iterations for Stokes subsystem." << std::endl; 
    } 

// 一旦我们知道了斯托克斯解，我们就可以根据最大速度确定新的时间步长。我们必须这样做以满足CFL条件，因为对流项在温度方程中得到了明确的处理，正如在介绍中所讨论的那样。这里使用的时间步长公式的确切形式将在本程序的结果部分讨论。

// 这里有一个插曲。该公式包含了对速度最大值的除法。然而，在计算开始时，我们有一个恒定的温度场（我们以恒定的温度开始，只有在源作用的第一个时间步长后，它才会变成非恒定的）。恒定温度意味着没有浮力作用，所以速度为零。除以它不可能得到什么好结果。

// 为了避免产生无限的时间步长，我们问最大速度是否非常小（特别是小于我们在接下来的任何时间步长中遇到的值），如果是，我们就不除以零，而是除以一个小值，从而产生一个大的但有限的时间步长。

    old_time_step                 = time_step; 
    const double maximal_velocity = get_maximal_velocity(); 

    if (maximal_velocity >= 0.01) 
      time_step = 1. / (1.7 * dim * std::sqrt(1. * dim)) / temperature_degree * 
                  GridTools::minimal_cell_diameter(triangulation) / 
                  maximal_velocity; 
    else 
      time_step = 1. / (1.7 * dim * std::sqrt(1. * dim)) / temperature_degree * 
                  GridTools::minimal_cell_diameter(triangulation) / .01; 

    std::cout << "   " 
              << "Time step: " << time_step << std::endl; 

    temperature_solution = old_temperature_solution; 

// 接下来我们用函数  <code>assemble_temperature_system()</code>  设置温度系统和右手边。 知道了温度方程的矩阵和右手边，我们设置了一个预处理程序和一个求解器。温度矩阵是一个质量矩阵（特征值在1左右）加上一个拉普拉斯矩阵（特征值在0和 $ch^{-2}$ 之间）乘以一个与时间步长成正比的小数字  $k_n$  。因此，产生的对称和正定矩阵的特征值在 $[1,1+k_nh^{-2}]$ 范围内（至于常数）。这个矩阵即使对于小的网格尺寸也只是适度的条件不良，我们通过简单的方法得到一个相当好的预处理，例如用一个不完全的Cholesky分解预处理（IC），我们也用它来预处理压力质量矩阵求解器。作为一个求解器，我们选择共轭梯度法CG。和以前一样，我们通过模板参数 <code>TrilinosWrappers::MPI::Vector</code> 告诉求解器使用Trilinos向量。最后，我们求解，分配悬挂节点约束，并写出迭代次数。

    assemble_temperature_system(maximal_velocity); 
    { 
      SolverControl solver_control(temperature_matrix.m(), 
                                   1e-8 * temperature_rhs.l2_norm()); 
      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control); 

      TrilinosWrappers::PreconditionIC preconditioner; 
      preconditioner.initialize(temperature_matrix); 

      cg.solve(temperature_matrix, 
               temperature_solution, 
               temperature_rhs, 
               preconditioner); 

      temperature_constraints.distribute(temperature_solution); 

      std::cout << "   " << solver_control.last_step() 
                << " CG iterations for temperature." << std::endl; 

// 在这个函数的结尾，我们在向量中步进并读出最大和最小的温度值，我们也想输出这些值。在本程序的结果部分讨论的确定时间步长的正确常数时，这将非常有用。

      double min_temperature = temperature_solution(0), 
             max_temperature = temperature_solution(0); 
      for (unsigned int i = 0; i < temperature_solution.size(); ++i) 
        { 
          min_temperature = 
            std::min<double>(min_temperature, temperature_solution(i)); 
          max_temperature = 
            std::max<double>(max_temperature, temperature_solution(i)); 
        } 

      std::cout << "   Temperature range: " << min_temperature << ' ' 
                << max_temperature << std::endl; 
    } 
  } 

//  @sect4{BoussinesqFlowProblem::output_results}  

// 该函数将解决方案写入VTK输出文件，用于可视化，每隔10个时间步长就会完成。这通常是一个相当简单的任务，因为deal.II库提供的函数几乎为我们完成了所有的工作。与以前的例子相比，有一个新的函数。我们想把斯托克斯解和温度都看作一个数据集，但是我们已经根据两个不同的DoFHandler对象完成了所有的计算。幸运的是，DataOut类已经准备好处理这个问题。我们所要做的就是不要在一开始就附加一个单一的DoFHandler，然后将其用于所有添加的向量，而是为每个向量分别指定DoFHandler。剩下的就像  step-22  中所做的那样。我们创建解决方案的名称（这些名称将出现在各个组件的可视化程序中）。第一个 <code>dim</code> 分量是矢量速度，然后我们有斯托克斯部分的压力，而温度是标量。这些信息是用DataComponentInterpretation辅助类读出来的。接下来，我们将数据向量与它们的DoFHandler对象连接起来，根据自由度建立补丁，这些补丁是描述可视化程序数据的（子）元素。最后，我们打开一个文件（包括时间步数）并将vtk数据写入其中。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::output_results() const 
  { 
    if (timestep_number % 10 != 0) 
      return; 

    std::vector<std::string> stokes_names(dim, "velocity"); 
    stokes_names.emplace_back("p"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      stokes_component_interpretation( 
        dim + 1, DataComponentInterpretation::component_is_scalar); 
    for (unsigned int i = 0; i < dim; ++i) 
      stokes_component_interpretation[i] = 
        DataComponentInterpretation::component_is_part_of_vector; 

    DataOut<dim> data_out; 
    data_out.add_data_vector(stokes_dof_handler, 
                             stokes_solution, 
                             stokes_names, 
                             stokes_component_interpretation); 
    data_out.add_data_vector(temperature_dof_handler, 
                             temperature_solution, 
                             "T"); 
    data_out.build_patches(std::min(stokes_degree, temperature_degree)); 

    std::ofstream output("solution-" + 
                         Utilities::int_to_string(timestep_number, 4) + ".vtk"); 
    data_out.write_vtk(output); 
  } 

//  @sect4{BoussinesqFlowProblem::refine_mesh}  

// 这个函数负责处理自适应网格细化。这个函数执行的三个任务是：首先找出需要细化/粗化的单元，然后实际进行细化，并最终在两个不同的网格之间传输解向量。第一个任务是通过对温度使用成熟的凯利误差估计器来实现的（对于这个程序，我们主要关注的是温度，我们需要在高温度梯度的区域保持精确，同时也要避免有太多的数值扩散）。第二项任务是实际进行再塑形。这也只涉及到基本函数，例如 <code>refine_and_coarsen_fixed_fraction</code> ，它可以细化那些具有最大估计误差的单元，这些误差合计占80%，并粗化那些具有最小误差的单元，这些误差合计占10%。

// 如果像这样实施，我们会得到一个不会有太大进展的程序。请记住，我们期望的温度场几乎是不连续的（扩散率 $\kappa$ 毕竟非常小），因此我们可以预期，一个自由适应的网格会越来越细化到大梯度的区域。网格大小的减少将伴随着时间步长的减少，需要大量的时间步长来解决给定的最终时间。这也会导致在几个网格细化周期后，网格的不连续性解决得比开始时好得多。

// 特别是为了防止时间步长的减少和相应的大量时间步长，我们限制了网格的最大细化深度。为此，在细化指标应用于单元格后，我们简单地在最细层的所有单元格上循环，如果它们会导致网格层次过高，则取消对它们的细化选择。

  template <int dim> 
  void 
  BoussinesqFlowProblem<dim>::refine_mesh(const unsigned int max_grid_level) 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate(temperature_dof_handler, 
                                       QGauss<dim - 1>(temperature_degree + 1), 
                                       {}, 
                                       temperature_solution, 
                                       estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_fraction(triangulation, 
                                                      estimated_error_per_cell, 
                                                      0.8, 
                                                      0.1); 
    if (triangulation.n_levels() > max_grid_level) 
      for (auto &cell : 
           triangulation.active_cell_iterators_on_level(max_grid_level)) 
        cell->clear_refine_flag(); 

// 作为网格细化的一部分，我们需要将旧的网格中的解决方案向量转移到新的网格中。为此，我们使用SolutionTransfer类，我们必须准备好需要转移到新网格的解向量（一旦完成细化，我们将失去旧的网格，所以转移必须与细化同时发生）。我们肯定需要的是当前温度和旧温度（BDF-2时间步长需要两个旧的解决方案）。由于SolutionTransfer对象只支持在每个dof处理程序中传输一个对象，我们需要在一个数据结构中收集两个温度解决方案。此外，我们也选择转移斯托克斯解，因为我们需要前两个时间步长的速度，其中只有一个是在飞行中计算的。

// 因此，我们为斯托克斯和温度的DoFHandler对象初始化了两个SolutionTransfer对象，将它们附加到旧的dof处理程序中。有了这个，我们就可以准备三角测量和数据向量的细化了（按这个顺序）。

    std::vector<TrilinosWrappers::MPI::Vector> x_temperature(2); 
    x_temperature[0]                            = temperature_solution; 
    x_temperature[1]                            = old_temperature_solution; 
    TrilinosWrappers::MPI::BlockVector x_stokes = stokes_solution; 

    SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> temperature_trans( 
      temperature_dof_handler); 
    SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> stokes_trans( 
      stokes_dof_handler); 

    triangulation.prepare_coarsening_and_refinement(); 
    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature); 
    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes); 

// 现在一切都准备好了，所以进行细化，在新的网格上重新创建dof结构，并初始化矩阵结构和 <code>setup_dofs</code> 函数中的新向量。接下来，我们实际执行网格之间的插值解。我们为温度创建另一份临时向量（现在与新网格相对应），并让插值函数完成这项工作。然后，产生的向量数组被写入各自的向量成员变量中。

// 记住，约束集将在setup_dofs()调用中为新的三角结构进行更新。

    triangulation.execute_coarsening_and_refinement(); 
    setup_dofs(); 

    std::vector<TrilinosWrappers::MPI::Vector> tmp(2); 
    tmp[0].reinit(temperature_solution); 
    tmp[1].reinit(temperature_solution); 
    temperature_trans.interpolate(x_temperature, tmp); 

    temperature_solution     = tmp[0]; 
    old_temperature_solution = tmp[1]; 

// 在解决方案被转移后，我们再对被转移的解决方案实施约束。

    temperature_constraints.distribute(temperature_solution); 
    temperature_constraints.distribute(old_temperature_solution); 

// 对于斯托克斯矢量，一切都一样&ndash;除了我们不需要另一个临时矢量，因为我们只是插值了一个矢量。最后，我们必须告诉程序，矩阵和预处理程序需要重新生成，因为网格已经改变。

    stokes_trans.interpolate(x_stokes, stokes_solution); 

    stokes_constraints.distribute(stokes_solution); 

    rebuild_stokes_matrix         = true; 
    rebuild_temperature_matrices  = true; 
    rebuild_stokes_preconditioner = true; 
  } 

//  @sect4{BoussinesqFlowProblem::run}  

// 这个函数执行Boussinesq程序中的所有基本步骤。它首先设置一个网格（根据空间维度，我们选择一些不同级别的初始细化和额外的自适应细化步骤，然后在 <code>dim</code> 维度上创建一个立方体，并首次设置了道夫。由于我们想用一个自适应细化的网格开始时间步进，我们执行一些预细化步骤，包括所有的装配、求解和细化，但实际上没有在时间上推进。相反，我们使用被人诟病的 <code>goto</code> 语句，在网格细化后立即跳出时间循环，从 <code>start_time_iteration</code> 标签开始的新网格上重新开始。( <code>goto</code> 的使用将在 step-26 中讨论) 。

// 在我们开始之前，我们将初始值投影到网格上，并获得 <code>old_temperature_solution</code> 矢量的第一个数据。然后，我们初始化时间步数和时间步长，开始时间循环。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::run() 
  { 
    const unsigned int initial_refinement     = (dim == 2 ? 4 : 2); 
    const unsigned int n_pre_refinement_steps = (dim == 2 ? 4 : 3); 

    GridGenerator::hyper_cube(triangulation); 
    global_Omega_diameter = GridTools::diameter(triangulation); 

    triangulation.refine_global(initial_refinement); 

    setup_dofs(); 

    unsigned int pre_refinement_step = 0; 

  start_time_iteration: 

    VectorTools::project(temperature_dof_handler, 
                         temperature_constraints, 
                         QGauss<dim>(temperature_degree + 2), 
                         EquationData::TemperatureInitialValues<dim>(), 
                         old_temperature_solution); 

    timestep_number = 0; 
    time_step = old_time_step = 0; 

    double time = 0; 

    do 
      { 
        std::cout << "Timestep " << timestep_number << ":  t=" << time 
                  << std::endl; 

// 时间循环的第一步都是显而易见的；我们组装斯托克斯系统、预处理程序、温度矩阵（矩阵和预处理程序实际上只在我们之前重新处理的情况下发生变化），然后进行求解。在继续下一个时间步骤之前，我们必须检查我们是否应该首先完成预精炼步骤，或者是否应该重新啮合（每五个时间步骤），精炼到一个与初始精炼和预精炼步骤一致的水平。循环的最后一个步骤是推进解，即把解复制到下一个 "较早 "的时间层。

        assemble_stokes_system(); 
        build_stokes_preconditioner(); 
        assemble_temperature_matrix(); 

        solve(); 

        output_results(); 

        std::cout << std::endl; 

        if ((timestep_number == 0) && 
            (pre_refinement_step < n_pre_refinement_steps)) 
          { 
            refine_mesh(initial_refinement + n_pre_refinement_steps); 
            ++pre_refinement_step; 
            goto start_time_iteration; 
          } 
        else if ((timestep_number > 0) && (timestep_number % 5 == 0)) 
          refine_mesh(initial_refinement + n_pre_refinement_steps); 

        time += time_step; 
        ++timestep_number; 

        old_stokes_solution          = stokes_solution; 
        old_old_temperature_solution = old_temperature_solution; 
        old_temperature_solution     = temperature_solution; 
      } 

// 做以上所有的工作，直到我们到达时间100。

    while (time <= 100); 
  } 
} // namespace Step31 

//  @sect3{The <code>main</code> function}  

// 主函数看起来与所有其他程序几乎一样。

// 有一个区别是我们必须要注意的。这个程序使用了Trilinos，而通常情况下，Trilinos被配置为可以使用MPI在%parallel中运行。这并不意味着它<i>has</i>可以在%parallel中运行，事实上这个程序（不像 step-32 ）根本没有尝试使用MPI在%parallel中做任何事情。然而，Trilinos希望MPI系统被初始化。我们通过创建一个类型为 Utilities::MPI::MPI_InitFinalize 的对象来做到这一点，该对象使用给main()的参数（即 <code>argc</code> 和 <code>argv</code> ）初始化MPI（如果可用的话），并在对象超出范围时再次去初始化它。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step31; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization( 
        argc, argv, numbers::invalid_unsigned_int); 

// 这个程序只能在串行中运行。否则，将抛出一个异常。

      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1, 
                  ExcMessage( 
                    "This program can only be run in serial, use ./step-31")); 

      BoussinesqFlowProblem<2> flow_problem; 
      flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-32.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2008 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Martin Kronbichler, Uppsala University, 
 *          Wolfgang Bangerth, Texas A&M University, 
 *          Timo Heister, University of Goettingen, 2008-2011 
 */ 


// @sect3{Include files}  

// 像往常一样，第一个任务是包括这些著名的deal.II库文件和一些C++头文件的功能。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/work_stream.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/parameter_handler.h> 

#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/solver_bicgstab.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/block_sparsity_pattern.h> 
#include <deal.II/lac/trilinos_parallel_block_vector.h> 
#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/trilinos_block_sparse_matrix.h> 
#include <deal.II/lac/trilinos_precondition.h> 
#include <deal.II/lac/trilinos_solver.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/filtered_iterator.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_dgp.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/solution_transfer.h> 

#include <fstream> 
#include <iostream> 
#include <limits> 
#include <locale> 
#include <string> 

// 这是唯一一个新的包含文件：它引入了相当于 parallel::distributed::SolutionTransfer 的 dealii::SolutionTransfer 类，用于在网格细化时将解决方案从一个网格带到下一个网格，但在并行分布式三角形计算的情况下。

#include <deal.II/distributed/solution_transfer.h> 

// 以下是用于并行分布式计算的类，在 step-40 中已经全部介绍过。

#include <deal.II/base/index_set.h> 
#include <deal.II/distributed/tria.h> 
#include <deal.II/distributed/grid_refinement.h> 

// 接下来的步骤与之前所有的教程程序一样。我们把所有东西放到一个自己的命名空间中，然后把deal.II的类和函数导入其中。

namespace Step32 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

// 在以下命名空间中，我们定义了描述问题的各种方程数据。这对应于使问题至少有一点现实性的各个方面，并且在介绍中对测试案例的描述中已经详尽地讨论了这些方面。

// 我们从一些具有常数的系数开始（数值后面的注释表示其物理单位）。

  namespace EquationData 
  { 
    constexpr double eta                   = 1e21;    /* Pa s       */ 


    constexpr double kappa                 = 1e-6;    /* m^2 / s    */ 


    constexpr double reference_density     = 3300;    /* kg / m^3   */ 


    constexpr double reference_temperature = 293;     /* K          */ 


    constexpr double expansion_coefficient = 2e-5;    /* 1/K        */ 


    constexpr double specific_heat         = 1250;    /* J / K / kg */ 


    constexpr double radiogenic_heating    = 7.4e-12; /* W / kg     */ 



    constexpr double R0 = 6371000. - 2890000.; /* m          */ 


    constexpr double R1 = 6371000. - 35000.;   /* m          */ 



    constexpr double T0 = 4000 + 273; /* K          */ 


    constexpr double T1 = 700 + 273;  /* K          */ 



// 下一组定义是用于编码密度与温度的函数、重力矢量和温度的初始值的函数。同样，所有这些（以及它们所计算的值）都在介绍中讨论过。

    double density(const double temperature) 
    { 
      return ( 
        reference_density * 
        (1 - expansion_coefficient * (temperature - reference_temperature))); 
    } 

    template <int dim> 
    Tensor<1, dim> gravity_vector(const Point<dim> &p) 
    { 
      const double r = p.norm(); 
      return -(1.245e-6 * r + 7.714e13 / r / r) * p / r; 
    } 

    template <int dim> 
    class TemperatureInitialValues : public Function<dim> 
    { 
    public: 
      TemperatureInitialValues() 
        : Function<dim>(1) 
      {} 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  value) const override; 
    }; 

    template <int dim> 
    double TemperatureInitialValues<dim>::value(const Point<dim> &p, 
                                                const unsigned int) const 
    { 
      const double r = p.norm(); 
      const double h = R1 - R0; 

      const double s = (r - R0) / h; 
      const double q = 
        (dim == 3) ? std::max(0.0, cos(numbers::PI * abs(p(2) / R1))) : 1.0; 
      const double phi = std::atan2(p(0), p(1)); 
      const double tau = s + 0.2 * s * (1 - s) * std::sin(6 * phi) * q; 

      return T0 * (1.0 - tau) + T1 * tau; 
    } 

    template <int dim> 
    void 
    TemperatureInitialValues<dim>::vector_value(const Point<dim> &p, 
                                                Vector<double> &  values) const 
    { 
      for (unsigned int c = 0; c < this->n_components; ++c) 
        values(c) = TemperatureInitialValues<dim>::value(p, c); 
    } 

// 正如介绍中所提到的，我们需要重新调整压力的比例，以避免动量和质量守恒方程的相对条件不良。比例系数为 $\frac{\eta}{L}$ ，其中 $L$ 是一个典型的长度尺度。通过实验发现，一个好的长度尺度是烟羽的直径，大约是10公里。

    constexpr double pressure_scaling = eta / 10000; 

// 这个命名空间的最后一个数字是一个常数，表示每（平均，热带）年的秒数。我们只在生成屏幕输出时使用它：在内部，这个程序的所有计算都是以SI单位（公斤、米、秒）进行的，但是用秒来写地质学时间产生的数字无法与现实联系起来，所以我们用这里定义的系数转换为年。

    const double year_in_seconds = 60 * 60 * 24 * 365.2425; 

  } // namespace EquationData 

//  @sect3{Preconditioning the Stokes system}  

// 这个命名空间实现了预处理程序。正如介绍中所讨论的，这个预处理程序在一些关键部分与  step-31  中使用的预处理程序不同。具体来说，它是一个右预处理程序，实现了矩阵
//  @f{align*}
//    \left(\begin{array}{cc}A^{-1} & B^T
//                         \\0 & S^{-1}
//  \end{array}\right)
//  @f}
//  中的两个逆矩阵操作由线性求解器近似，或者，如果给这个类的构造函数加上右标志，则由速度块的单个AMG V-循环实现。 <code>vmult</code> 函数的三个代码块实现了与该预处理矩阵的三个块的乘法运算，如果你读过 step-31 或 step-20 中关于组成求解器的讨论，应该是不言自明的。

  namespace LinearSolvers 
  { 
    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    class BlockSchurPreconditioner : public Subscriptor 
    { 
    public: 
      BlockSchurPreconditioner(const TrilinosWrappers::BlockSparseMatrix &S, 
                               const TrilinosWrappers::BlockSparseMatrix &Spre, 
                               const PreconditionerTypeMp &Mppreconditioner, 
                               const PreconditionerTypeA & Apreconditioner, 
                               const bool                  do_solve_A) 
        : stokes_matrix(&S) 
        , stokes_preconditioner_matrix(&Spre) 
        , mp_preconditioner(Mppreconditioner) 
        , a_preconditioner(Apreconditioner) 
        , do_solve_A(do_solve_A) 
      {} 

      void vmult(TrilinosWrappers::MPI::BlockVector &      dst, 
                 const TrilinosWrappers::MPI::BlockVector &src) const 
      { 
        TrilinosWrappers::MPI::Vector utmp(src.block(0)); 

        { 
          SolverControl solver_control(5000, 1e-6 * src.block(1).l2_norm()); 

          SolverCG<TrilinosWrappers::MPI::Vector> solver(solver_control); 

          solver.solve(stokes_preconditioner_matrix->block(1, 1), 
                       dst.block(1), 
                       src.block(1), 
                       mp_preconditioner); 

          dst.block(1) *= -1.0; 
        } 

        { 
          stokes_matrix->block(0, 1).vmult(utmp, dst.block(1)); 
          utmp *= -1.0; 
          utmp.add(src.block(0)); 
        } 

        if (do_solve_A == true) 
          { 
            SolverControl solver_control(5000, utmp.l2_norm() * 1e-2); 
            TrilinosWrappers::SolverCG solver(solver_control); 
            solver.solve(stokes_matrix->block(0, 0), 
                         dst.block(0), 
                         utmp, 
                         a_preconditioner); 
          } 
        else 
          a_preconditioner.vmult(dst.block(0), utmp); 
      } 

    private: 
      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> 
        stokes_matrix; 
      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> 
                                  stokes_preconditioner_matrix; 
      const PreconditionerTypeMp &mp_preconditioner; 
      const PreconditionerTypeA & a_preconditioner; 
      const bool                  do_solve_A; 
    }; 
  } // namespace LinearSolvers 

//  @sect3{Definition of assembly data structures}  

// 如介绍中所述，我们将使用 @ref threads 模块中讨论的WorkStream机制来实现单台机器的处理器之间的并行操作。WorkStream类要求数据在两种数据结构中传递，一种是用于抓取数据，一种是将数据从装配函数传递到将本地贡献复制到全局对象的函数。

// 下面的命名空间（以及两个子命名空间）包含了服务于这一目的的数据结构的集合，介绍中讨论的四种操作中的每一种都有一对，我们将想把它们并行化。每个装配例程都会得到两组数据：一个是Scratch数组，收集所有用于计算单元格贡献的类和数组，另一个是CopyData数组，保存将被写入全局矩阵的本地矩阵和向量。而CopyData是一个容器，用来存放最终写入全局矩阵和向量的数据（因此是绝对必要的），Scratch数组只是出于性能的考虑而存在；在每个单元上设置一个FEValues对象，要比只创建一次并更新一些导数数据要昂贵得多。

//  Step-31 有四个汇编程序。一个用于斯托克斯系统的预处理矩阵，一个用于斯托克斯矩阵和右手边，一个用于温度矩阵，一个用于温度方程的右手边。我们在这里使用 <code>struct</code> 环境为这四个汇编组件中的每一个组织从头数组和CopyData对象（因为我们认为这些是我们传递的临时对象，而不是实现自己功能的类，尽管这是区分 <code>struct</code>s and <code>class</code> es的一个比较主观的观点）。

// 关于Scratch对象，每个结构都配备了一个构造函数，可以使用 @ref FiniteElement 、正交、 @ref Mapping （描述弯曲边界的插值）和 @ref UpdateFlags 实例创建一个 @ref FEValues 对象。此外，我们手动实现了一个复制构造函数（因为FEValues类本身是不可复制的），并提供了一些额外的矢量字段，用于在计算局部贡献时保存中间数据。

// 让我们从抓取数组开始，特别是用于组装斯托克斯预处理程序的数组。

  namespace Assembly 
  { 
    namespace Scratch 
    { 
      template <int dim> 
      struct StokesPreconditioner 
      { 
        StokesPreconditioner(const FiniteElement<dim> &stokes_fe, 
                             const Quadrature<dim> &   stokes_quadrature, 
                             const Mapping<dim> &      mapping, 
                             const UpdateFlags         update_flags); 

        StokesPreconditioner(const StokesPreconditioner &data); 

        FEValues<dim> stokes_fe_values; 

        std::vector<Tensor<2, dim>> grad_phi_u; 
        std::vector<double>         phi_p; 
      }; 

      template <int dim> 
      StokesPreconditioner<dim>::StokesPreconditioner( 
        const FiniteElement<dim> &stokes_fe, 
        const Quadrature<dim> &   stokes_quadrature, 
        const Mapping<dim> &      mapping, 
        const UpdateFlags         update_flags) 
        : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags) 
        , grad_phi_u(stokes_fe.n_dofs_per_cell()) 
        , phi_p(stokes_fe.n_dofs_per_cell()) 
      {} 

      template <int dim> 
      StokesPreconditioner<dim>::StokesPreconditioner( 
        const StokesPreconditioner &scratch) 
        : stokes_fe_values(scratch.stokes_fe_values.get_mapping(), 
                           scratch.stokes_fe_values.get_fe(), 
                           scratch.stokes_fe_values.get_quadrature(), 
                           scratch.stokes_fe_values.get_update_flags()) 
        , grad_phi_u(scratch.grad_phi_u) 
        , phi_p(scratch.phi_p) 
      {} 

// 下一个是用于组装完整的斯托克斯系统的从头对象。请注意，我们从上面的StokesPreconditioner类派生出StokesSystem scratch类。我们这样做是因为所有用于组装预处理程序的对象也需要用于实际的矩阵系统和右手边，还有一些额外的数据。这使得程序更加紧凑。还需要注意的是，斯托克斯系统的装配和进一步的温度右手边分别需要温度和速度的数据，所以我们实际上需要两个FEValues对象来处理这两种情况。

      template <int dim> 
      struct StokesSystem : public StokesPreconditioner<dim> 
      { 
        StokesSystem(const FiniteElement<dim> &stokes_fe, 
                     const Mapping<dim> &      mapping, 
                     const Quadrature<dim> &   stokes_quadrature, 
                     const UpdateFlags         stokes_update_flags, 
                     const FiniteElement<dim> &temperature_fe, 
                     const UpdateFlags         temperature_update_flags); 

        StokesSystem(const StokesSystem<dim> &data); 

        FEValues<dim> temperature_fe_values; 

        std::vector<Tensor<1, dim>>          phi_u; 
        std::vector<SymmetricTensor<2, dim>> grads_phi_u; 
        std::vector<double>                  div_phi_u; 

        std::vector<double> old_temperature_values; 
      }; 

      template <int dim> 
      StokesSystem<dim>::StokesSystem( 
        const FiniteElement<dim> &stokes_fe, 
        const Mapping<dim> &      mapping, 
        const Quadrature<dim> &   stokes_quadrature, 
        const UpdateFlags         stokes_update_flags, 
        const FiniteElement<dim> &temperature_fe, 
        const UpdateFlags         temperature_update_flags) 
        : StokesPreconditioner<dim>(stokes_fe, 
                                    stokes_quadrature, 
                                    mapping, 
                                    stokes_update_flags) 
        , temperature_fe_values(mapping, 
                                temperature_fe, 
                                stokes_quadrature, 
                                temperature_update_flags) 
        , phi_u(stokes_fe.n_dofs_per_cell()) 
        , grads_phi_u(stokes_fe.n_dofs_per_cell()) 
        , div_phi_u(stokes_fe.n_dofs_per_cell()) 
        , old_temperature_values(stokes_quadrature.size()) 
      {} 

      template <int dim> 
      StokesSystem<dim>::StokesSystem(const StokesSystem<dim> &scratch) 
        : StokesPreconditioner<dim>(scratch) 
        , temperature_fe_values( 
            scratch.temperature_fe_values.get_mapping(), 
            scratch.temperature_fe_values.get_fe(), 
            scratch.temperature_fe_values.get_quadrature(), 
            scratch.temperature_fe_values.get_update_flags()) 
        , phi_u(scratch.phi_u) 
        , grads_phi_u(scratch.grads_phi_u) 
        , div_phi_u(scratch.div_phi_u) 
        , old_temperature_values(scratch.old_temperature_values) 
      {} 

// 在定义了用于组装斯托克斯系统的对象之后，我们对温度系统所需的矩阵的组装也做了同样的工作。一般的结构是非常相似的。

      template <int dim> 
      struct TemperatureMatrix 
      { 
        TemperatureMatrix(const FiniteElement<dim> &temperature_fe, 
                          const Mapping<dim> &      mapping, 
                          const Quadrature<dim> &   temperature_quadrature); 

        TemperatureMatrix(const TemperatureMatrix &data); 

        FEValues<dim> temperature_fe_values; 

        std::vector<double>         phi_T; 
        std::vector<Tensor<1, dim>> grad_phi_T; 
      }; 

      template <int dim> 
      TemperatureMatrix<dim>::TemperatureMatrix( 
        const FiniteElement<dim> &temperature_fe, 
        const Mapping<dim> &      mapping, 
        const Quadrature<dim> &   temperature_quadrature) 
        : temperature_fe_values(mapping, 
                                temperature_fe, 
                                temperature_quadrature, 
                                update_values | update_gradients | 
                                  update_JxW_values) 
        , phi_T(temperature_fe.n_dofs_per_cell()) 
        , grad_phi_T(temperature_fe.n_dofs_per_cell()) 
      {} 

      template <int dim> 
      TemperatureMatrix<dim>::TemperatureMatrix( 
        const TemperatureMatrix &scratch) 
        : temperature_fe_values( 
            scratch.temperature_fe_values.get_mapping(), 
            scratch.temperature_fe_values.get_fe(), 
            scratch.temperature_fe_values.get_quadrature(), 
            scratch.temperature_fe_values.get_update_flags()) 
        , phi_T(scratch.phi_T) 
        , grad_phi_T(scratch.grad_phi_T) 
      {} 

// 最后的划痕对象被用于温度系统右侧的装配。这个对象比上面的对象要大得多，因为有更多的量进入温度方程右边的计算中。特别是，前两个时间步骤的温度值和梯度需要在正交点评估，还有速度和应变率（即速度的对称梯度），它们作为摩擦加热项进入右侧。尽管有很多条款，但以下内容应该是不言自明的。

      template <int dim> 
      struct TemperatureRHS 
      { 
        TemperatureRHS(const FiniteElement<dim> &temperature_fe, 
                       const FiniteElement<dim> &stokes_fe, 
                       const Mapping<dim> &      mapping, 
                       const Quadrature<dim> &   quadrature); 

        TemperatureRHS(const TemperatureRHS &data); 

        FEValues<dim> temperature_fe_values; 
        FEValues<dim> stokes_fe_values; 

        std::vector<double>         phi_T; 
        std::vector<Tensor<1, dim>> grad_phi_T; 

        std::vector<Tensor<1, dim>> old_velocity_values; 
        std::vector<Tensor<1, dim>> old_old_velocity_values; 

        std::vector<SymmetricTensor<2, dim>> old_strain_rates; 
        std::vector<SymmetricTensor<2, dim>> old_old_strain_rates; 

        std::vector<double>         old_temperature_values; 
        std::vector<double>         old_old_temperature_values; 
        std::vector<Tensor<1, dim>> old_temperature_grads; 
        std::vector<Tensor<1, dim>> old_old_temperature_grads; 
        std::vector<double>         old_temperature_laplacians; 
        std::vector<double>         old_old_temperature_laplacians; 
      }; 

      template <int dim> 
      TemperatureRHS<dim>::TemperatureRHS( 
        const FiniteElement<dim> &temperature_fe, 
        const FiniteElement<dim> &stokes_fe, 
        const Mapping<dim> &      mapping, 
        const Quadrature<dim> &   quadrature) 
        : temperature_fe_values(mapping, 
                                temperature_fe, 
                                quadrature, 
                                update_values | update_gradients | 
                                  update_hessians | update_quadrature_points | 
                                  update_JxW_values) 
        , stokes_fe_values(mapping, 
                           stokes_fe, 
                           quadrature, 
                           update_values | update_gradients) 
        , phi_T(temperature_fe.n_dofs_per_cell()) 
        , grad_phi_T(temperature_fe.n_dofs_per_cell()) 
        , 

        old_velocity_values(quadrature.size()) 
        , old_old_velocity_values(quadrature.size()) 
        , old_strain_rates(quadrature.size()) 
        , old_old_strain_rates(quadrature.size()) 
        , 

        old_temperature_values(quadrature.size()) 
        , old_old_temperature_values(quadrature.size()) 
        , old_temperature_grads(quadrature.size()) 
        , old_old_temperature_grads(quadrature.size()) 
        , old_temperature_laplacians(quadrature.size()) 
        , old_old_temperature_laplacians(quadrature.size()) 
      {} 

      template <int dim> 
      TemperatureRHS<dim>::TemperatureRHS(const TemperatureRHS &scratch) 
        : temperature_fe_values( 
            scratch.temperature_fe_values.get_mapping(), 
            scratch.temperature_fe_values.get_fe(), 
            scratch.temperature_fe_values.get_quadrature(), 
            scratch.temperature_fe_values.get_update_flags()) 
        , stokes_fe_values(scratch.stokes_fe_values.get_mapping(), 
                           scratch.stokes_fe_values.get_fe(), 
                           scratch.stokes_fe_values.get_quadrature(), 
                           scratch.stokes_fe_values.get_update_flags()) 
        , phi_T(scratch.phi_T) 
        , grad_phi_T(scratch.grad_phi_T) 
        , 

        old_velocity_values(scratch.old_velocity_values) 
        , old_old_velocity_values(scratch.old_old_velocity_values) 
        , old_strain_rates(scratch.old_strain_rates) 
        , old_old_strain_rates(scratch.old_old_strain_rates) 
        , 

        old_temperature_values(scratch.old_temperature_values) 
        , old_old_temperature_values(scratch.old_old_temperature_values) 
        , old_temperature_grads(scratch.old_temperature_grads) 
        , old_old_temperature_grads(scratch.old_old_temperature_grads) 
        , old_temperature_laplacians(scratch.old_temperature_laplacians) 
        , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians) 
      {} 
    } // namespace Scratch 

// CopyData对象比Scratch对象更简单，因为它们所要做的就是存储本地计算的结果，直到它们可以被复制到全局矩阵或向量对象中。因此，这些结构只需要提供一个构造函数，一个复制操作，以及一些用于本地矩阵、本地向量和本地与全局自由度之间关系的数组（又称 <code>local_dof_indices</code> ）。同样，我们为我们将使用WorkStream类并行化的四个操作中的每一个都有一个这样的结构。

    namespace CopyData 
    { 
      template <int dim> 
      struct StokesPreconditioner 
      { 
        StokesPreconditioner(const FiniteElement<dim> &stokes_fe); 
        StokesPreconditioner(const StokesPreconditioner &data); 
        StokesPreconditioner &operator=(const StokesPreconditioner &) = default; 

        FullMatrix<double>                   local_matrix; 
        std::vector<types::global_dof_index> local_dof_indices; 
      }; 

      template <int dim> 
      StokesPreconditioner<dim>::StokesPreconditioner( 
        const FiniteElement<dim> &stokes_fe) 
        : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell()) 
        , local_dof_indices(stokes_fe.n_dofs_per_cell()) 
      {} 

      template <int dim> 
      StokesPreconditioner<dim>::StokesPreconditioner( 
        const StokesPreconditioner &data) 
        : local_matrix(data.local_matrix) 
        , local_dof_indices(data.local_dof_indices) 
      {} 

      template <int dim> 
      struct StokesSystem : public StokesPreconditioner<dim> 
      { 
        StokesSystem(const FiniteElement<dim> &stokes_fe); 

        Vector<double> local_rhs; 
      }; 

      template <int dim> 
      StokesSystem<dim>::StokesSystem(const FiniteElement<dim> &stokes_fe) 
        : StokesPreconditioner<dim>(stokes_fe) 
        , local_rhs(stokes_fe.n_dofs_per_cell()) 
      {} 

      template <int dim> 
      struct TemperatureMatrix 
      { 
        TemperatureMatrix(const FiniteElement<dim> &temperature_fe); 

        FullMatrix<double>                   local_mass_matrix; 
        FullMatrix<double>                   local_stiffness_matrix; 
        std::vector<types::global_dof_index> local_dof_indices; 
      }; 

      template <int dim> 
      TemperatureMatrix<dim>::TemperatureMatrix( 
        const FiniteElement<dim> &temperature_fe) 
        : local_mass_matrix(temperature_fe.n_dofs_per_cell(), 
                            temperature_fe.n_dofs_per_cell()) 
        , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(), 
                                 temperature_fe.n_dofs_per_cell()) 
        , local_dof_indices(temperature_fe.n_dofs_per_cell()) 
      {} 

      template <int dim> 
      struct TemperatureRHS 
      { 
        TemperatureRHS(const FiniteElement<dim> &temperature_fe); 

        Vector<double>                       local_rhs; 
        std::vector<types::global_dof_index> local_dof_indices; 
        FullMatrix<double>                   matrix_for_bc; 
      }; 

      template <int dim> 
      TemperatureRHS<dim>::TemperatureRHS( 
        const FiniteElement<dim> &temperature_fe) 
        : local_rhs(temperature_fe.n_dofs_per_cell()) 
        , local_dof_indices(temperature_fe.n_dofs_per_cell()) 
        , matrix_for_bc(temperature_fe.n_dofs_per_cell(), 
                        temperature_fe.n_dofs_per_cell()) 
      {} 
    } // namespace CopyData 
  }   // namespace Assembly 

//  @sect3{The <code>BoussinesqFlowProblem</code> class template}  

// 这是主类的声明。它与 step-31 非常相似，但有一些区别我们将在下面评论。

// 该类的顶部与 step-31 中的内容基本相同，列出了公共方法和一组做重活的私有函数。与 step-31 相比，这部分只增加了两个：计算所有单元的最大CFL数的函数 <code>get_cfl_number()</code> ，然后我们根据它计算全局时间步长；以及用于计算熵值稳定的函数 <code>get_entropy_variation()</code> 。它类似于我们在 step-31 中用于此目的的 <code>get_extrapolated_temperature_range()</code> ，但它的工作对象是熵而不是温度。

  template <int dim> 
  class BoussinesqFlowProblem 
  { 
  public: 
    struct Parameters; 
    BoussinesqFlowProblem(Parameters &parameters); 
    void run(); 

  private: 
    void   setup_dofs(); 
    void   assemble_stokes_preconditioner(); 
    void   build_stokes_preconditioner(); 
    void   assemble_stokes_system(); 
    void   assemble_temperature_matrix(); 
    void   assemble_temperature_system(const double maximal_velocity); 
    double get_maximal_velocity() const; 
    double get_cfl_number() const; 
    double get_entropy_variation(const double average_temperature) const; 
    std::pair<double, double> get_extrapolated_temperature_range() const; 
    void                      solve(); 
    void                      output_results(); 
    void                      refine_mesh(const unsigned int max_grid_level); 

    double compute_viscosity( 
      const std::vector<double> &        old_temperature, 
      const std::vector<double> &        old_old_temperature, 
      const std::vector<Tensor<1, dim>> &old_temperature_grads, 
      const std::vector<Tensor<1, dim>> &old_old_temperature_grads, 
      const std::vector<double> &        old_temperature_laplacians, 
      const std::vector<double> &        old_old_temperature_laplacians, 
      const std::vector<Tensor<1, dim>> &old_velocity_values, 
      const std::vector<Tensor<1, dim>> &old_old_velocity_values, 
      const std::vector<SymmetricTensor<2, dim>> &old_strain_rates, 
      const std::vector<SymmetricTensor<2, dim>> &old_old_strain_rates, 
      const double                                global_u_infty, 
      const double                                global_T_variation, 
      const double                                average_temperature, 
      const double                                global_entropy_variation, 
      const double                                cell_diameter) const; 

  public: 

// 第一个重要的新组件是根据介绍中的讨论为参数定义了一个结构。这个结构是在构建这个对象的过程中通过读取参数文件来初始化的。

    struct Parameters 
    { 
      Parameters(const std::string &parameter_filename); 

      static void declare_parameters(ParameterHandler &prm); 
      void        parse_parameters(ParameterHandler &prm); 

      double end_time; 

      unsigned int initial_global_refinement; 
      unsigned int initial_adaptive_refinement; 

      bool         generate_graphical_output; 
      unsigned int graphical_output_interval; 

      unsigned int adaptive_refinement_interval; 

      double stabilization_alpha; 
      double stabilization_c_R; 
      double stabilization_beta; 

      unsigned int stokes_velocity_degree; 
      bool         use_locally_conservative_discretization; 

      unsigned int temperature_degree; 
    }; 

  private: 
    Parameters &parameters; 

//  <code>pcout</code> （用于<i>%parallel <code>std::cout</code></i>）对象被用来简化输出的书写：每个MPI进程都可以像往常一样使用它来产生输出，但由于这些进程中的每一个都会（希望）产生相同的输出，它只是被重复了许多次；使用ConditionalOStream类，只有一个MPI进程产生的输出会真正被打印到屏幕上，而所有其他线程的输出将只是被遗忘。

    ConditionalOStream pcout; 

// 下面的成员变量将再次与 step-31 中的成员变量相似（也与其他教程程序相似）。正如介绍中提到的，我们完全分布计算，所以我们将不得不使用 parallel::distributed::Triangulation 类（见 step-40  ），但这些变量的其余部分相当标准，有两个例外。



// --  <code>mapping</code> 这个变量是用来表示高阶多项式映射的。正如在介绍中提到的，我们在通过正交形成积分时使用这个映射，用于所有与我们域的内边界或外边界相邻的单元，其中边界是弯曲的。



// - 在命名混乱的情况下，你会注意到下面一些来自命名空间TrilinosWrappers的变量取自命名空间 TrilinosWrappers::MPI （比如右手边的向量），而其他变量则不是（比如各种矩阵）。这是由于遗留的原因。我们经常需要查询任意正交点的速度和温度；因此，每当我们需要访问与本地相关但属于另一个处理器的自由度时，我们不是导入矢量的幽灵信息，而是以%并行方式求解线性系统，但随后立即初始化一个矢量，包括求解的幽灵条目，以便进一步处理。因此，各种 <code>*_solution</code> 向量在以%parallel求解各自的线性系统后立即被填充，并且总是包含所有 @ref GlossLocallyRelevantDof "本地相关自由度 "的值；我们从求解过程中获得的完全分布的向量，只包含 @ref GlossLocallyOwnedDof "本地拥有的自由度"，在求解过程后，在我们将相关值复制到成员变量向量后立即销毁。

    parallel::distributed::Triangulation<dim> triangulation; 
    double                                    global_Omega_diameter; 

    const MappingQ<dim> mapping; 

    const FESystem<dim>       stokes_fe; 
    DoFHandler<dim>           stokes_dof_handler; 
    AffineConstraints<double> stokes_constraints; 

    TrilinosWrappers::BlockSparseMatrix stokes_matrix; 
    TrilinosWrappers::BlockSparseMatrix stokes_preconditioner_matrix; 

    TrilinosWrappers::MPI::BlockVector stokes_solution; 
    TrilinosWrappers::MPI::BlockVector old_stokes_solution; 
    TrilinosWrappers::MPI::BlockVector stokes_rhs; 

    FE_Q<dim>                 temperature_fe; 
    DoFHandler<dim>           temperature_dof_handler; 
    AffineConstraints<double> temperature_constraints; 

    TrilinosWrappers::SparseMatrix temperature_mass_matrix; 
    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix; 
    TrilinosWrappers::SparseMatrix temperature_matrix; 

    TrilinosWrappers::MPI::Vector temperature_solution; 
    TrilinosWrappers::MPI::Vector old_temperature_solution; 
    TrilinosWrappers::MPI::Vector old_old_temperature_solution; 
    TrilinosWrappers::MPI::Vector temperature_rhs; 

    double       time_step; 
    double       old_time_step; 
    unsigned int timestep_number; 

    std::shared_ptr<TrilinosWrappers::PreconditionAMG>    Amg_preconditioner; 
    std::shared_ptr<TrilinosWrappers::PreconditionJacobi> Mp_preconditioner; 
    std::shared_ptr<TrilinosWrappers::PreconditionJacobi> T_preconditioner; 

    bool rebuild_stokes_matrix; 
    bool rebuild_stokes_preconditioner; 
    bool rebuild_temperature_matrices; 
    bool rebuild_temperature_preconditioner; 

// 下一个成员变量， <code>computing_timer</code> 是用来方便地计算在某些重复输入的代码 "部分 "所花费的计算时间。例如，我们将进入（和离开）斯托克斯矩阵装配的部分，并希望在所有的时间步骤中累积在这部分花费的运行时间。每隔一段时间，以及在程序结束时（通过TimerOutput类的析构器），我们将产生一个很好的总结，即在不同部分花费的时间，我们把这个程序的运行时间归类为不同部分。

    TimerOutput computing_timer; 

// 在这些成员变量之后，我们有一些辅助函数，这些函数已经从上面列出的那些函数中分解出来。具体来说，首先有三个我们从 <code>setup_dofs</code> 中调用的函数，然后是做线性系统组装的函数。

    void setup_stokes_matrix( 
      const std::vector<IndexSet> &stokes_partitioning, 
      const std::vector<IndexSet> &stokes_relevant_partitioning); 
    void setup_stokes_preconditioner( 
      const std::vector<IndexSet> &stokes_partitioning, 
      const std::vector<IndexSet> &stokes_relevant_partitioning); 
    void setup_temperature_matrices( 
      const IndexSet &temperature_partitioning, 
      const IndexSet &temperature_relevant_partitioning); 

// 遵循 @ref MTWorkStream "基于任务的并行化 "范式，我们将所有的汇编例程分成两部分：第一部分可以在某个单元上做所有的计算，而不需要照顾其他线程；第二部分（就是将本地数据写入全局矩阵和向量中），每次只能由一个线程进入。为了实现这一点，我们为这一程序中使用的所有四个汇编例程的这两个步骤分别提供了函数。下面的八个函数正是这样做的。

    void local_assemble_stokes_preconditioner( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      Assembly::Scratch::StokesPreconditioner<dim> &        scratch, 
      Assembly::CopyData::StokesPreconditioner<dim> &       data); 

    void copy_local_to_global_stokes_preconditioner( 
      const Assembly::CopyData::StokesPreconditioner<dim> &data); 

    void local_assemble_stokes_system( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      Assembly::Scratch::StokesSystem<dim> &                scratch, 
      Assembly::CopyData::StokesSystem<dim> &               data); 

    void copy_local_to_global_stokes_system( 
      const Assembly::CopyData::StokesSystem<dim> &data); 

    void local_assemble_temperature_matrix( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      Assembly::Scratch::TemperatureMatrix<dim> &           scratch, 
      Assembly::CopyData::TemperatureMatrix<dim> &          data); 

    void copy_local_to_global_temperature_matrix( 
      const Assembly::CopyData::TemperatureMatrix<dim> &data); 

    void local_assemble_temperature_rhs( 
      const std::pair<double, double> global_T_range, 
      const double                    global_max_velocity, 
      const double                    global_entropy_variation, 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      Assembly::Scratch::TemperatureRHS<dim> &              scratch, 
      Assembly::CopyData::TemperatureRHS<dim> &             data); 

    void copy_local_to_global_temperature_rhs( 
      const Assembly::CopyData::TemperatureRHS<dim> &data); 

// 最后，我们向前声明一个成员类，我们将在以后定义这个成员类，它将被用来从我们的解决方案向量中计算一些数量，我们希望将这些数量放入输出文件中，以便进行可视化。

    class Postprocessor; 
  }; 
// @sect3{BoussinesqFlowProblem class implementation}  
// @sect4{BoussinesqFlowProblem::Parameters}  

// 这里是对斯托克斯问题的参数的定义。我们允许设置模拟的结束时间、细化水平（包括全局细化和自适应细化，总的来说就是允许单元的最大细化水平），以及细化的时间间隔。

// 然后，我们让用户指定稳定参数的常数（如介绍中所讨论的）、斯托克斯速度空间的多项式程度、是否对压力使用基于FE_DGP元素的局部保守离散化（对压力使用FE_Q元素）、以及温度插值的多项式程度。

// 构造函数检查是否有有效的输入文件（如果没有，将写一个带有默认参数的文件），并最终解析参数。

  template <int dim> 
  BoussinesqFlowProblem<dim>::Parameters::Parameters( 
    const std::string &parameter_filename) 
    : end_time(1e8) 
    , initial_global_refinement(2) 
    , initial_adaptive_refinement(2) 
    , adaptive_refinement_interval(10) 
    , stabilization_alpha(2) 
    , stabilization_c_R(0.11) 
    , stabilization_beta(0.078) 
    , stokes_velocity_degree(2) 
    , use_locally_conservative_discretization(true) 
    , temperature_degree(2) 
  { 
    ParameterHandler prm; 
    BoussinesqFlowProblem<dim>::Parameters::declare_parameters(prm); 

    std::ifstream parameter_file(parameter_filename); 

    if (!parameter_file) 
      { 
        parameter_file.close(); 

        std::ofstream parameter_out(parameter_filename); 
        prm.print_parameters(parameter_out, ParameterHandler::Text); 

        AssertThrow( 
          false, 
          ExcMessage( 
            "Input parameter file <" + parameter_filename + 
            "> not found. Creating a template file of the same name.")); 
      } 

    prm.parse_input(parameter_file); 
    parse_parameters(prm); 
  } 

// 接下来我们有一个函数，声明我们在输入文件中期望的参数，以及它们的数据类型、默认值和描述。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::Parameters::declare_parameters( 
    ParameterHandler &prm) 
  { 
    prm.declare_entry("End time", 
                      "1e8", 
                      Patterns::Double(0), 
                      "The end time of the simulation in years."); 
    prm.declare_entry("Initial global refinement", 
                      "2", 
                      Patterns::Integer(0), 
                      "The number of global refinement steps performed on " 
                      "the initial coarse mesh, before the problem is first " 
                      "solved there."); 
    prm.declare_entry("Initial adaptive refinement", 
                      "2", 
                      Patterns::Integer(0), 
                      "The number of adaptive refinement steps performed after " 
                      "initial global refinement."); 
    prm.declare_entry("Time steps between mesh refinement", 
                      "10", 
                      Patterns::Integer(1), 
                      "The number of time steps after which the mesh is to be " 
                      "adapted based on computed error indicators."); 
    prm.declare_entry("Generate graphical output", 
                      "false", 
                      Patterns::Bool(), 
                      "Whether graphical output is to be generated or not. " 
                      "You may not want to get graphical output if the number " 
                      "of processors is large."); 
    prm.declare_entry("Time steps between graphical output", 
                      "50", 
                      Patterns::Integer(1), 
                      "The number of time steps between each generation of " 
                      "graphical output files."); 

    prm.enter_subsection("Stabilization parameters"); 
    { 
      prm.declare_entry("alpha", 
                        "2", 
                        Patterns::Double(1, 2), 
                        "The exponent in the entropy viscosity stabilization."); 
      prm.declare_entry("c_R", 
                        "0.11", 
                        Patterns::Double(0), 
                        "The c_R factor in the entropy viscosity " 
                        "stabilization."); 
      prm.declare_entry("beta", 
                        "0.078", 
                        Patterns::Double(0), 
                        "The beta factor in the artificial viscosity " 
                        "stabilization. An appropriate value for 2d is 0.052 " 
                        "and 0.078 for 3d."); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Discretization"); 
    { 
      prm.declare_entry( 
        "Stokes velocity polynomial degree", 
        "2", 
        Patterns::Integer(1), 
        "The polynomial degree to use for the velocity variables " 
        "in the Stokes system."); 
      prm.declare_entry( 
        "Temperature polynomial degree", 
        "2", 
        Patterns::Integer(1), 
        "The polynomial degree to use for the temperature variable."); 
      prm.declare_entry( 
        "Use locally conservative discretization", 
        "true", 
        Patterns::Bool(), 
        "Whether to use a Stokes discretization that is locally " 
        "conservative at the expense of a larger number of degrees " 
        "of freedom, or to go with a cheaper discretization " 
        "that does not locally conserve mass (although it is " 
        "globally conservative."); 
    } 
    prm.leave_subsection(); 
  } 

// 然后，我们需要一个函数来读取我们通过读取输入文件得到的ParameterHandler对象的内容，并将结果放入储存我们之前声明的参数值的变量。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::Parameters::parse_parameters( 
    ParameterHandler &prm) 
  { 
    end_time                  = prm.get_double("End time"); 
    initial_global_refinement = prm.get_integer("Initial global refinement"); 
    initial_adaptive_refinement = 
      prm.get_integer("Initial adaptive refinement"); 

    adaptive_refinement_interval = 
      prm.get_integer("Time steps between mesh refinement"); 

    generate_graphical_output = prm.get_bool("Generate graphical output"); 
    graphical_output_interval = 
      prm.get_integer("Time steps between graphical output"); 

    prm.enter_subsection("Stabilization parameters"); 
    { 
      stabilization_alpha = prm.get_double("alpha"); 
      stabilization_c_R   = prm.get_double("c_R"); 
      stabilization_beta  = prm.get_double("beta"); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Discretization"); 
    { 
      stokes_velocity_degree = 
        prm.get_integer("Stokes velocity polynomial degree"); 
      temperature_degree = prm.get_integer("Temperature polynomial degree"); 
      use_locally_conservative_discretization = 
        prm.get_bool("Use locally conservative discretization"); 
    } 
    prm.leave_subsection(); 
  } 

//  @sect4{BoussinesqFlowProblem::BoussinesqFlowProblem}  

// 该问题的构造函数与  step-31  中的构造函数非常相似。不同的是%并行通信。Trilinos使用消息传递接口（MPI）进行数据分配。当进入BoussinesqFlowProblem类时，我们必须决定如何进行并行化。我们选择一个相当简单的策略，让所有正在运行程序的处理器一起工作，由通信器  <code>MPI_COMM_WORLD</code>  指定。接下来，我们创建输出流（就像我们在 step-18 中已经做的那样），它只在第一个MPI进程上产生输出，而在其他所有进程上则完全不考虑。这个想法的实现是在 <code>pcout</code> 得到一个真实参数时检查进程号，它使用 <code>std::cout</code> 流进行输出。例如，如果我们是一个处理器五，那么我们将给出一个  <code>false</code> argument to <code>pcout</code>  ，这意味着该处理器的输出将不会被打印。除了映射对象（我们对其使用4度的多项式），除了最后的成员变量外，其他都与  step-31  中的完全相同。

// 这个最后的对象，TimerOutput对象，然后被告知限制输出到 <code>pcout</code> 流（处理器0），然后我们指定要在程序结束时得到一个汇总表，该表显示我们的壁挂时钟时间（而不是CPU时间）。我们还将在下面的 <code>run()</code> 函数中手动请求每隔这么多时间步的中间总结。

  template <int dim> 
  BoussinesqFlowProblem<dim>::BoussinesqFlowProblem(Parameters &parameters_) 
    : parameters(parameters_) 
    , pcout(std::cout, (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)) 
    , 

    triangulation(MPI_COMM_WORLD, 
                  typename Triangulation<dim>::MeshSmoothing( 
                    Triangulation<dim>::smoothing_on_refinement | 
                    Triangulation<dim>::smoothing_on_coarsening)) 
    , 

    global_Omega_diameter(0.) 
    , 

    mapping(4) 
    , 

    stokes_fe(FE_Q<dim>(parameters.stokes_velocity_degree), 
              dim, 
              (parameters.use_locally_conservative_discretization ? 
                 static_cast<const FiniteElement<dim> &>( 
                   FE_DGP<dim>(parameters.stokes_velocity_degree - 1)) : 
                 static_cast<const FiniteElement<dim> &>( 
                   FE_Q<dim>(parameters.stokes_velocity_degree - 1))), 
              1) 
    , 

    stokes_dof_handler(triangulation) 
    , 

    temperature_fe(parameters.temperature_degree) 
    , temperature_dof_handler(triangulation) 
    , 

    time_step(0) 
    , old_time_step(0) 
    , timestep_number(0) 
    , rebuild_stokes_matrix(true) 
    , rebuild_stokes_preconditioner(true) 
    , rebuild_temperature_matrices(true) 
    , rebuild_temperature_preconditioner(true) 
    , 

    computing_timer(MPI_COMM_WORLD, 
                    pcout, 
                    TimerOutput::summary, 
                    TimerOutput::wall_times) 
  {} 

//  @sect4{The BoussinesqFlowProblem helper functions}  
// @sect5{BoussinesqFlowProblem::get_maximal_velocity}  

// 除了两个小细节外，计算速度全局最大值的函数与 step-31 中的相同。第一个细节实际上是所有在三角形的所有单元上实现循环的函数所共有的。当以%并行方式操作时，每个处理器只能处理一大块单元，因为每个处理器只拥有整个三角结构的某一部分。我们要处理的这块单元是通过所谓的 <code>subdomain_id</code> 来确定的，正如我们在 step-18 中做的那样。因此，我们需要改变的是只对当前进程所拥有的单元格（相对于幽灵或人造单元格）进行与单元格相关的操作，即对子域id等于进程ID的数字。由于这是一个常用的操作，所以这个操作有一个快捷方式：我们可以用 <code>cell-@>is_locally_owned()</code> 询问单元格是否为当前处理器所拥有。

// 第二个区别是我们计算最大值的方式。以前，我们可以简单地有一个 <code>double</code> 变量，在每个单元的每个正交点上进行检查。现在，我们必须更加小心，因为每个处理器只对单元格的一个子集进行操作。我们要做的是，首先让每个处理器计算其单元中的最大值，然后做一个全局通信操作 <code>Utilities::MPI::max</code> ，计算各个处理器所有最大值中的最大值。MPI提供了这样的调用，但更简单的是使用MPI通信器对象在命名空间 Utilities::MPI 中使用相应的函数，因为即使我们没有MPI并且只在一台机器上工作，这也会做正确的事情。对 <code>Utilities::MPI::max</code> 的调用需要两个参数，即本地最大值（input）和MPI通信器，在这个例子中是MPI_COMM_WORLD。

  template <int dim> 
  double BoussinesqFlowProblem<dim>::get_maximal_velocity() const 
  { 
    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), 
                                            parameters.stokes_velocity_degree); 
    const unsigned int   n_q_points = quadrature_formula.size(); 

    FEValues<dim>               fe_values(mapping, 
                            stokes_fe, 
                            quadrature_formula, 
                            update_values); 
    std::vector<Tensor<1, dim>> velocity_values(n_q_points); 

    const FEValuesExtractors::Vector velocities(0); 

    double max_local_velocity = 0; 

    for (const auto &cell : stokes_dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_values.reinit(cell); 
          fe_values[velocities].get_function_values(stokes_solution, 
                                                    velocity_values); 

          for (unsigned int q = 0; q < n_q_points; ++q) 
            max_local_velocity = 
              std::max(max_local_velocity, velocity_values[q].norm()); 
        } 

    return Utilities::MPI::max(max_local_velocity, MPI_COMM_WORLD); 
  } 
// @sect5{BoussinesqFlowProblem::get_cfl_number}  

// 下一个函数做了类似的事情，但我们现在计算CFL数，即一个单元上的最大速度除以单元直径。这个数字对于确定时间步长是必要的，因为我们对温度方程使用半显式的时间步长方案（讨论见 step-31 ）。我们用上述同样的方法计算它。在所有本地拥有的单元上计算本地最大值，然后通过MPI交换，找到全球最大值。

  template <int dim> 
  double BoussinesqFlowProblem<dim>::get_cfl_number() const 
  { 
    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), 
                                            parameters.stokes_velocity_degree); 
    const unsigned int   n_q_points = quadrature_formula.size(); 

    FEValues<dim>               fe_values(mapping, 
                            stokes_fe, 
                            quadrature_formula, 
                            update_values); 
    std::vector<Tensor<1, dim>> velocity_values(n_q_points); 

    const FEValuesExtractors::Vector velocities(0); 

    double max_local_cfl = 0; 

    for (const auto &cell : stokes_dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_values.reinit(cell); 
          fe_values[velocities].get_function_values(stokes_solution, 
                                                    velocity_values); 

          double max_local_velocity = 1e-10; 
          for (unsigned int q = 0; q < n_q_points; ++q) 
            max_local_velocity = 
              std::max(max_local_velocity, velocity_values[q].norm()); 
          max_local_cfl = 
            std::max(max_local_cfl, max_local_velocity / cell->diameter()); 
        } 

    return Utilities::MPI::max(max_local_cfl, MPI_COMM_WORLD); 
  } 
// @sect5{BoussinesqFlowProblem::get_entropy_variation}  

// 接下来是计算全局熵的变化 $\|E(T)-\bar{E}(T)\|_\infty$ ，其中熵 $E$ 的定义如介绍中所讨论的。 这对于评估温度方程中的稳定度是必要的，正如介绍中所解释的。实际上，只有当我们在残差计算中使用 $\alpha=2$ 作为幂时，才需要熵的变化。无限准则是由正交点上的最大值计算出来的，就像离散计算中通常的那样。

// 为了计算这个量，我们首先要找到空间平均数 $\bar{E}(T)$ ，然后评估最大值。然而，这意味着我们需要执行两个循环。我们可以通过注意到 $\|E(T)-\bar{E}(T)\|_\infty =
//  \max\big(E_{\textrm{max}}(T)-\bar{E}(T),
//  \bar{E}(T)-E_{\textrm{min}}(T)\big)$ ，即正负方向上与平均熵的偏差的最大值来避免开销。我们在后一个公式中需要的四个量（最大熵、最小熵、平均熵、面积）都可以在所有单元格的同一个循环中进行评估，所以我们选择这个更简单的变体。

  template <int dim> 
  double BoussinesqFlowProblem<dim>::get_entropy_variation( 
    const double average_temperature) const 
  { 
    if (parameters.stabilization_alpha != 2) 
      return 1.; 

    const QGauss<dim>  quadrature_formula(parameters.temperature_degree + 1); 
    const unsigned int n_q_points = quadrature_formula.size(); 

    FEValues<dim>       fe_values(temperature_fe, 
                            quadrature_formula, 
                            update_values | update_JxW_values); 
    std::vector<double> old_temperature_values(n_q_points); 
    std::vector<double> old_old_temperature_values(n_q_points); 

// 在上面的两个函数中，我们计算了所有非负数的最大值，所以我们知道0肯定是一个下限。另一方面，在这里我们需要找到与平均值的最大偏差，也就是说，我们需要知道熵的最大和最小值，而这些值的符号我们并不事先知道。

// 为了计算它，我们可以从我们可以存储在一个双精度数字中的最大和最小的可能值开始。最小值被初始化为一个更大的数字，最大值被初始化为一个比将要出现的任何一个数字都小的数字。然后，我们保证这些数字将在第一个单元的循环中被覆盖，或者，如果这个处理器不拥有任何单元，最迟在通信步骤中被覆盖。下面的循环将计算最小和最大的局部熵，并跟踪我们局部拥有的域的面积/体积，以及对其熵的积分。

    double min_entropy = std::numeric_limits<double>::max(), 
           max_entropy = -std::numeric_limits<double>::max(), area = 0, 
           entropy_integrated = 0; 

    for (const auto &cell : temperature_dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_values.reinit(cell); 
          fe_values.get_function_values(old_temperature_solution, 
                                        old_temperature_values); 
          fe_values.get_function_values(old_old_temperature_solution, 
                                        old_old_temperature_values); 
          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 
              const double T = 
                (old_temperature_values[q] + old_old_temperature_values[q]) / 2; 
              const double entropy = 
                ((T - average_temperature) * (T - average_temperature)); 

              min_entropy = std::min(min_entropy, entropy); 
              max_entropy = std::max(max_entropy, entropy); 
              area += fe_values.JxW(q); 
              entropy_integrated += fe_values.JxW(q) * entropy; 
            } 
        } 

// 现在我们只需要在处理器之间交换数据：我们需要将两个积分相加（  <code>area</code>, <code>entropy_integrated</code>  ），并得到最大和最小的极值。我们可以通过四个不同的数据交换来完成这个任务，但我们只需要两个就可以了。  Utilities::MPI::sum 也有一个变体，它接受一个数组的值，这些值都是要加起来的。我们还可以利用 Utilities::MPI::max 函数，认识到在最小熵上形成最小值等于在最小熵的负值上形成最大值的负值；然后这个最大值可以与在最大熵上形成最大值结合起来。

    const double local_sums[2]   = {entropy_integrated, area}, 
                 local_maxima[2] = {-min_entropy, max_entropy}; 
    double global_sums[2], global_maxima[2]; 

    Utilities::MPI::sum(local_sums, MPI_COMM_WORLD, global_sums); 
    Utilities::MPI::max(local_maxima, MPI_COMM_WORLD, global_maxima); 

// 以这种方式计算了所有的东西之后，我们就可以计算平均熵，并通过取最大值或最小值与平均值的偏差中的较大值来找到 $L^\infty$ 准则。

    const double average_entropy = global_sums[0] / global_sums[1]; 
    const double entropy_diff    = std::max(global_maxima[1] - average_entropy, 
                                         average_entropy - (-global_maxima[0])); 
    return entropy_diff; 
  } 

//  @sect5{BoussinesqFlowProblem::get_extrapolated_temperature_range}  

// 下一个函数是计算整个领域内外推温度的最小值和最大值。同样，这只是  step-31  中相应函数的一个略微修改的版本。和上面的函数一样，我们收集局部最小值和最大值，然后用上面的技巧计算全局极值。

// 正如在 step-31 中已经讨论过的，该函数需要区分第一个时间步长和所有后续时间步长，因为当至少有两个以前的时间步长时，它使用了一个高阶温度外推方案。

  template <int dim> 
  std::pair<double, double> 
  BoussinesqFlowProblem<dim>::get_extrapolated_temperature_range() const 
  { 
    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), 
                                            parameters.temperature_degree); 
    const unsigned int   n_q_points = quadrature_formula.size(); 

    FEValues<dim>       fe_values(mapping, 
                            temperature_fe, 
                            quadrature_formula, 
                            update_values); 
    std::vector<double> old_temperature_values(n_q_points); 
    std::vector<double> old_old_temperature_values(n_q_points); 

    double min_local_temperature = std::numeric_limits<double>::max(), 
           max_local_temperature = -std::numeric_limits<double>::max(); 

    if (timestep_number != 0) 
      { 
        for (const auto &cell : temperature_dof_handler.active_cell_iterators()) 
          if (cell->is_locally_owned()) 
            { 
              fe_values.reinit(cell); 
              fe_values.get_function_values(old_temperature_solution, 
                                            old_temperature_values); 
              fe_values.get_function_values(old_old_temperature_solution, 
                                            old_old_temperature_values); 

              for (unsigned int q = 0; q < n_q_points; ++q) 
                { 
                  const double temperature = 
                    (1. + time_step / old_time_step) * 
                      old_temperature_values[q] - 
                    time_step / old_time_step * old_old_temperature_values[q]; 

                  min_local_temperature = 
                    std::min(min_local_temperature, temperature); 
                  max_local_temperature = 
                    std::max(max_local_temperature, temperature); 
                } 
            } 
      } 
    else 
      { 
        for (const auto &cell : temperature_dof_handler.active_cell_iterators()) 
          if (cell->is_locally_owned()) 
            { 
              fe_values.reinit(cell); 
              fe_values.get_function_values(old_temperature_solution, 
                                            old_temperature_values); 

              for (unsigned int q = 0; q < n_q_points; ++q) 
                { 
                  const double temperature = old_temperature_values[q]; 

                  min_local_temperature = 
                    std::min(min_local_temperature, temperature); 
                  max_local_temperature = 
                    std::max(max_local_temperature, temperature); 
                } 
            } 
      } 

    double local_extrema[2] = {-min_local_temperature, max_local_temperature}; 
    double global_extrema[2]; 
    Utilities::MPI::max(local_extrema, MPI_COMM_WORLD, global_extrema); 

    return std::make_pair(-global_extrema[0], global_extrema[1]); 
  } 
// @sect5{BoussinesqFlowProblem::compute_viscosity}  

// 计算粘度的函数是纯粹的本地函数，所以根本不需要通信。它与 step-31 中的内容基本相同，但如果选择 $\alpha=2$ ，则会有一个最新的粘度表述。

  template <int dim> 
  double BoussinesqFlowProblem<dim>::compute_viscosity( 
    const std::vector<double> &                 old_temperature, 
    const std::vector<double> &                 old_old_temperature, 
    const std::vector<Tensor<1, dim>> &         old_temperature_grads, 
    const std::vector<Tensor<1, dim>> &         old_old_temperature_grads, 
    const std::vector<double> &                 old_temperature_laplacians, 
    const std::vector<double> &                 old_old_temperature_laplacians, 
    const std::vector<Tensor<1, dim>> &         old_velocity_values, 
    const std::vector<Tensor<1, dim>> &         old_old_velocity_values, 
    const std::vector<SymmetricTensor<2, dim>> &old_strain_rates, 
    const std::vector<SymmetricTensor<2, dim>> &old_old_strain_rates, 
    const double                                global_u_infty, 
    const double                                global_T_variation, 
    const double                                average_temperature, 
    const double                                global_entropy_variation, 
    const double                                cell_diameter) const 
  { 
    if (global_u_infty == 0) 
      return 5e-3 * cell_diameter; 

    const unsigned int n_q_points = old_temperature.size(); 

    double max_residual = 0; 
    double max_velocity = 0; 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        const Tensor<1, dim> u = 
          (old_velocity_values[q] + old_old_velocity_values[q]) / 2; 

        const SymmetricTensor<2, dim> strain_rate = 
          (old_strain_rates[q] + old_old_strain_rates[q]) / 2; 

        const double T = (old_temperature[q] + old_old_temperature[q]) / 2; 
        const double dT_dt = 
          (old_temperature[q] - old_old_temperature[q]) / old_time_step; 
        const double u_grad_T = 
          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2; 

        const double kappa_Delta_T = 
          EquationData::kappa * 
          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) / 
          2; 
        const double gamma = 
          ((EquationData::radiogenic_heating * EquationData::density(T) + 
            2 * EquationData::eta * strain_rate * strain_rate) / 
           (EquationData::density(T) * EquationData::specific_heat)); 

        double residual = std::abs(dT_dt + u_grad_T - kappa_Delta_T - gamma); 
        if (parameters.stabilization_alpha == 2) 
          residual *= std::abs(T - average_temperature); 

        max_residual = std::max(residual, max_residual); 
        max_velocity = std::max(std::sqrt(u * u), max_velocity); 
      } 

    const double max_viscosity = 
      (parameters.stabilization_beta * max_velocity * cell_diameter); 
    if (timestep_number == 0) 
      return max_viscosity; 
    else 
      { 
        Assert(old_time_step > 0, ExcInternalError()); 

        double entropy_viscosity; 
        if (parameters.stabilization_alpha == 2) 
          entropy_viscosity = 
            (parameters.stabilization_c_R * cell_diameter * cell_diameter * 
             max_residual / global_entropy_variation); 
        else 
          entropy_viscosity = 
            (parameters.stabilization_c_R * cell_diameter * 
             global_Omega_diameter * max_velocity * max_residual / 
             (global_u_infty * global_T_variation)); 

        return std::min(max_viscosity, entropy_viscosity); 
      } 
  } 

//  @sect4{The BoussinesqFlowProblem setup functions}  

// 以下三个函数设置了斯托克斯矩阵、用于斯托克斯预调节器的矩阵和温度矩阵。这些代码与 step-31 中的代码基本相同，但为了简单起见，将其分成了三个自己的函数。

// 这里的代码与 step-31 中的代码在功能上的主要区别是，我们要建立的矩阵是分布在多个处理器上的。由于我们仍然希望出于效率的原因先建立起稀疏性模式，我们可以继续将<i>entire</i>的稀疏性模式作为BlockDynamicSparsityPattern来建立，正如我们在 step-31 中所做的那样。然而，这将是低效的：每个处理器将建立相同的稀疏性模式，但只用它初始化矩阵的一小部分。这也违反了一个原则，即每个处理器应该只对它所拥有的单元格（如果有必要的话，还有它周围的幽灵单元格层）工作。

// 相反，我们使用一个类型为 TrilinosWrappers::BlockSparsityPattern, 的对象，它（显然）是对Trilinos提供的稀疏模式对象的一个封装。这样做的好处是Trilinos稀疏模式类可以在多个处理器之间进行通信：如果这个处理器填入它所拥有的单元格产生的所有非零条目，并且其他每个处理器也这样做，那么在由 <code>compress()</code> 调用发起的MPI通信结束后，我们将有全局组装的稀疏模式可用，全局矩阵可以被初始化。

// 在并行初始化Trilinos稀疏度模式时，有一个重要的方面。除了通过 @p stokes_partitioning 索引集指定矩阵的本地拥有的行和列之外，我们还提供了在某个处理器上装配时可能要写进的所有行的信息。本地相关行的集合包含了所有这样的行（可能还有一些不必要的行，但在实际获得所有单元格的索引和解决约束之前，很难找到确切的行索引）。这种额外的信息可以准确地确定在装配过程中发现的非处理器数据的结构。虽然Trilinos矩阵也能在飞行中收集这些信息（当从其他一些reinit方法初始化它们时），但效率较低，在用多线程组装矩阵时，会导致问题。在这个程序中，我们悲观地假设每次只有一个处理器可以在组装时写入矩阵（而计算是并行的），这对特里诺斯矩阵是没有问题的。在实践中，可以通过在不共享顶点的单元中提示WorkStream来做得更好，允许这些单元之间的并行性（参见图形着色算法和带有彩色迭代器的WorkStream参数）。然而，这只在只有一个MPI处理器的情况下有效，因为Trilinos的内部数据结构在飞行中积累非处理器的数据，不是线程安全。有了这里介绍的初始化，就不存在这样的问题，人们可以安全地为这个算法引入图形着色。

// 我们唯一需要做的改变是告诉 DoFTools::make_sparsity_pattern() 函数，它只应该在一个单元格子集上工作，即那些 <code>subdomain_id</code> 等于当前处理器数量的单元格，而忽略所有其他单元格。

// 这个策略被复制到以下三个函数中。

// 注意，Trilinos 矩阵存储的信息包含在稀疏模式中，所以一旦矩阵被赋予稀疏结构，我们就可以安全地释放  <code>sp</code>  变量。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::setup_stokes_matrix( 
    const std::vector<IndexSet> &stokes_partitioning, 
    const std::vector<IndexSet> &stokes_relevant_partitioning) 
  { 
    stokes_matrix.clear(); 

    TrilinosWrappers::BlockSparsityPattern sp(stokes_partitioning, 
                                              stokes_partitioning, 
                                              stokes_relevant_partitioning, 
                                              MPI_COMM_WORLD); 

    Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
    for (unsigned int c = 0; c < dim + 1; ++c) 
      for (unsigned int d = 0; d < dim + 1; ++d) 
        if (!((c == dim) && (d == dim))) 
          coupling[c][d] = DoFTools::always; 
        else 
          coupling[c][d] = DoFTools::none; 

    DoFTools::make_sparsity_pattern(stokes_dof_handler, 
                                    coupling, 
                                    sp, 
                                    stokes_constraints, 
                                    false, 
                                    Utilities::MPI::this_mpi_process( 
                                      MPI_COMM_WORLD)); 
    sp.compress(); 

    stokes_matrix.reinit(sp); 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::setup_stokes_preconditioner( 
    const std::vector<IndexSet> &stokes_partitioning, 
    const std::vector<IndexSet> &stokes_relevant_partitioning) 
  { 
    Amg_preconditioner.reset(); 
    Mp_preconditioner.reset(); 

    stokes_preconditioner_matrix.clear(); 

    TrilinosWrappers::BlockSparsityPattern sp(stokes_partitioning, 
                                              stokes_partitioning, 
                                              stokes_relevant_partitioning, 
                                              MPI_COMM_WORLD); 

    Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
    for (unsigned int c = 0; c < dim + 1; ++c) 
      for (unsigned int d = 0; d < dim + 1; ++d) 
        if (c == d) 
          coupling[c][d] = DoFTools::always; 
        else 
          coupling[c][d] = DoFTools::none; 

    DoFTools::make_sparsity_pattern(stokes_dof_handler, 
                                    coupling, 
                                    sp, 
                                    stokes_constraints, 
                                    false, 
                                    Utilities::MPI::this_mpi_process( 
                                      MPI_COMM_WORLD)); 
    sp.compress(); 

    stokes_preconditioner_matrix.reinit(sp); 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::setup_temperature_matrices( 
    const IndexSet &temperature_partitioner, 
    const IndexSet &temperature_relevant_partitioner) 
  { 
    T_preconditioner.reset(); 
    temperature_mass_matrix.clear(); 
    temperature_stiffness_matrix.clear(); 
    temperature_matrix.clear(); 

    TrilinosWrappers::SparsityPattern sp(temperature_partitioner, 
                                         temperature_partitioner, 
                                         temperature_relevant_partitioner, 
                                         MPI_COMM_WORLD); 
    DoFTools::make_sparsity_pattern(temperature_dof_handler, 
                                    sp, 
                                    temperature_constraints, 
                                    false, 
                                    Utilities::MPI::this_mpi_process( 
                                      MPI_COMM_WORLD)); 
    sp.compress(); 

    temperature_matrix.reinit(sp); 
    temperature_mass_matrix.reinit(sp); 
    temperature_stiffness_matrix.reinit(sp); 
  } 

// 设置函数的其余部分（在拆分出上面的三个函数后）主要是处理我们需要做的跨处理器并行化的事情。因为设置所有这些都是程序的一个重要的计算时间支出，所以我们把在这里做的所有事情都放到一个定时器组中，这样我们就可以在程序结束时得到关于这部分时间的总结信息。

// 像往常一样，我们在顶部列举自由度，并按照组件/块进行排序，然后从零号处理器开始将它们的数字写到屏幕上。当 DoFHandler::distributed_dofs() 函数应用于 parallel::distributed::Triangulation 对象时，对自由度的排序是这样的：所有与子域0相关的自由度排在所有与子域1相关的自由度之前，等等。对于斯托克斯部分，这意味着速度和压力会混在一起，但这可以通过再次按块排序来解决；值得注意的是，后一种操作只保留了所有速度和压力的相对顺序，即在速度块内，我们仍然会将所有与子域零相关的速度放在与子域一相关的速度之前，等等。这一点很重要，因为我们把这个矩阵的每一个块都分布在所有的处理器上，并且希望这样做的方式是，每个处理器存储的矩阵部分与它将实际工作的单元上的自由度大致相等。

// 在打印自由度的数字时，注意如果我们使用许多处理器，这些数字将会很大。因此，我们让流在每三个数字之间放一个逗号分隔符。流的状态，使用locale，从这个操作之前保存到之后。虽然有点不透明，但这段代码是有效的，因为默认的locale（我们使用构造函数调用 <code>std::locale("")</code> 得到的）意味着打印数字时，每三位数字都有一个逗号分隔符（即千、百万、亿）。

// 在这个函数以及下面的许多函数中，我们测量了我们在这里花费的时间，并将其收集在一个叫做 "设置dof系统 "的部分，跨函数调用。这是用一个 TimerOutput::Scope 对象完成的，该对象在构建本地变量时，在上述名称为`computing_timer`的部分启动一个定时器；当`timing_section`变量的析构器被调用时，该定时器再次停止。 当然，这要么发生在函数的末尾，要么我们通过`return`语句离开函数，或者在某处抛出异常时--换句话说，只要我们以任何方式离开这个函数。因此，使用这种 "范围 "对象可以确保我们不必手动添加代码，告诉定时器在每个可能离开这个函数的地方停止。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::setup_dofs() 
  { 
    TimerOutput::Scope timing_section(computing_timer, "Setup dof systems"); 

    stokes_dof_handler.distribute_dofs(stokes_fe); 

    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0); 
    stokes_sub_blocks[dim] = 1; 
    DoFRenumbering::component_wise(stokes_dof_handler, stokes_sub_blocks); 

    temperature_dof_handler.distribute_dofs(temperature_fe); 

    const std::vector<types::global_dof_index> stokes_dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(stokes_dof_handler, stokes_sub_blocks); 

    const unsigned int n_u = stokes_dofs_per_block[0], 
                       n_p = stokes_dofs_per_block[1], 
                       n_T = temperature_dof_handler.n_dofs(); 

    std::locale s = pcout.get_stream().getloc(); 
    pcout.get_stream().imbue(std::locale("")); 
    pcout << "Number of active cells: " << triangulation.n_global_active_cells() 
          << " (on " << triangulation.n_levels() << " levels)" << std::endl 
          << "Number of degrees of freedom: " << n_u + n_p + n_T << " (" << n_u 
          << '+' << n_p << '+' << n_T << ')' << std::endl 
          << std::endl; 
    pcout.get_stream().imbue(s); 

// 在这之后，我们必须设置各种分区器（类型为 <code>IndexSet</code>  ，见介绍），描述每个矩阵或向量的哪些部分将被存储在哪里，然后调用实际设置矩阵的函数，在最后还要调整我们在这个程序中保留的各种向量的大小。

    std::vector<IndexSet> stokes_partitioning, stokes_relevant_partitioning; 
    IndexSet              temperature_partitioning(n_T), 
      temperature_relevant_partitioning(n_T); 
    IndexSet stokes_relevant_set; 
    { 
      IndexSet stokes_index_set = stokes_dof_handler.locally_owned_dofs(); 
      stokes_partitioning.push_back(stokes_index_set.get_view(0, n_u)); 
      stokes_partitioning.push_back(stokes_index_set.get_view(n_u, n_u + n_p)); 

      DoFTools::extract_locally_relevant_dofs(stokes_dof_handler, 
                                              stokes_relevant_set); 
      stokes_relevant_partitioning.push_back( 
        stokes_relevant_set.get_view(0, n_u)); 
      stokes_relevant_partitioning.push_back( 
        stokes_relevant_set.get_view(n_u, n_u + n_p)); 

      temperature_partitioning = temperature_dof_handler.locally_owned_dofs(); 
      DoFTools::extract_locally_relevant_dofs( 
        temperature_dof_handler, temperature_relevant_partitioning); 
    } 

// 在这之后，我们可以计算求解向量的约束，包括悬挂节点约束和斯托克斯和温度场的同质和非同质边界值。请注意，和其他一切一样，约束对象不能在每个处理器上都持有<i>all</i>约束。相反，鉴于每个处理器只在其拥有的单元上组装线性系统，因此每个处理器只需要存储那些对正确性实际必要的约束。正如在 @ref distributed_paper "本文 "中所讨论的，我们需要了解的约束集正是所有本地相关自由度的约束集，所以这就是我们用来初始化约束对象的。

    { 
      stokes_constraints.clear(); 
      stokes_constraints.reinit(stokes_relevant_set); 

      DoFTools::make_hanging_node_constraints(stokes_dof_handler, 
                                              stokes_constraints); 

      FEValuesExtractors::Vector velocity_components(0); 
      VectorTools::interpolate_boundary_values( 
        stokes_dof_handler, 
        0, 
        Functions::ZeroFunction<dim>(dim + 1), 
        stokes_constraints, 
        stokes_fe.component_mask(velocity_components)); 

      std::set<types::boundary_id> no_normal_flux_boundaries; 
      no_normal_flux_boundaries.insert(1); 
      VectorTools::compute_no_normal_flux_constraints(stokes_dof_handler, 
                                                      0, 
                                                      no_normal_flux_boundaries, 
                                                      stokes_constraints, 
                                                      mapping); 
      stokes_constraints.close(); 
    } 
    { 
      temperature_constraints.clear(); 
      temperature_constraints.reinit(temperature_relevant_partitioning); 

      DoFTools::make_hanging_node_constraints(temperature_dof_handler, 
                                              temperature_constraints); 
      VectorTools::interpolate_boundary_values( 
        temperature_dof_handler, 
        0, 
        EquationData::TemperatureInitialValues<dim>(), 
        temperature_constraints); 
      VectorTools::interpolate_boundary_values( 
        temperature_dof_handler, 
        1, 
        EquationData::TemperatureInitialValues<dim>(), 
        temperature_constraints); 
      temperature_constraints.close(); 
    } 

// 做完这些，我们就可以将各种矩阵和向量对象初始化到合适的大小。在最后，我们还记录了所有的矩阵和前置条件器必须在下一个时间步长开始时重新计算。注意我们是如何初始化斯托克斯和温度右侧的向量的。这些是可写的向量（最后一个布尔参数设置为 @p true) ），具有正确的一对一的本地拥有元素的分区，但仍被赋予相关的分区，以弄清要立即设置的向量条目。至于矩阵，这允许用多个线程将本地贡献写入向量（总是假设同一向量条目不被多个线程同时访问）。其他向量只允许对单个元素的读取访问，包括鬼魂，但不适合求解器。

    setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning); 
    setup_stokes_preconditioner(stokes_partitioning, 
                                stokes_relevant_partitioning); 
    setup_temperature_matrices(temperature_partitioning, 
                               temperature_relevant_partitioning); 

    stokes_rhs.reinit(stokes_partitioning, 
                      stokes_relevant_partitioning, 
                      MPI_COMM_WORLD, 
                      true); 
    stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD); 
    old_stokes_solution.reinit(stokes_solution); 

    temperature_rhs.reinit(temperature_partitioning, 
                           temperature_relevant_partitioning, 
                           MPI_COMM_WORLD, 
                           true); 
    temperature_solution.reinit(temperature_relevant_partitioning, 
                                MPI_COMM_WORLD); 
    old_temperature_solution.reinit(temperature_solution); 
    old_old_temperature_solution.reinit(temperature_solution); 

    rebuild_stokes_matrix              = true; 
    rebuild_stokes_preconditioner      = true; 
    rebuild_temperature_matrices       = true; 
    rebuild_temperature_preconditioner = true; 
  } 

//  @sect4{The BoussinesqFlowProblem assembly functions}  

// 按照介绍和 @ref threads 模块中的讨论，我们将装配功能分成不同的部分。

//  <ul>  
//  <li>  矩阵和右手边的局部计算，给定某个单元作为输入（这些函数被命名为下面的 <code>local_assemble_*</code> ）。换句话说，得出的函数基本上是 step-31 中所有单元格的循环体。然而，请注意，这些函数将本地计算的结果存储在CopyData命名空间的类的变量中。

//  <li>  然后这些对象被交给第二步，将本地数据写入全局数据结构中（这些函数被命名为下面的 <code>copy_local_to_global_*</code> ）。这些函数是相当琐碎的。

//  <li>  然后这两个子函数被用于各自的汇编例程（下面称为 <code>assemble_*</code> ），在那里，一个WorkStream对象被设置并在属于处理器子域的所有单元中运行。   </ul>  
// @sect5{Stokes preconditioner assembly}  

// 让我们从构建斯托克斯预处理的函数开始。考虑到上面的讨论，其中的前两个是非常微不足道的。请特别注意，使用scratch数据对象的主要意义在于，我们希望避免每次访问新单元时在自由空间上分配任何对象。因此，下面的汇编函数只有自动的局部变量，其他的都是通过从头开始的数据对象访问的，在我们开始对所有单元进行循环之前，只分配了一次。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::local_assemble_stokes_preconditioner( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    Assembly::Scratch::StokesPreconditioner<dim> &        scratch, 
    Assembly::CopyData::StokesPreconditioner<dim> &       data) 
  { 
    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points = 
      scratch.stokes_fe_values.n_quadrature_points; 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    scratch.stokes_fe_values.reinit(cell); 
    cell->get_dof_indices(data.local_dof_indices); 

    data.local_matrix = 0; 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        for (unsigned int k = 0; k < dofs_per_cell; ++k) 
          { 
            scratch.grad_phi_u[k] = 
              scratch.stokes_fe_values[velocities].gradient(k, q); 
            scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q); 
          } 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            data.local_matrix(i, j) += 
              (EquationData::eta * 
                 scalar_product(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) + 
               (1. / EquationData::eta) * EquationData::pressure_scaling * 
                 EquationData::pressure_scaling * 
                 (scratch.phi_p[i] * scratch.phi_p[j])) * 
              scratch.stokes_fe_values.JxW(q); 
      } 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::copy_local_to_global_stokes_preconditioner( 
    const Assembly::CopyData::StokesPreconditioner<dim> &data) 
  { 
    stokes_constraints.distribute_local_to_global(data.local_matrix, 
                                                  data.local_dof_indices, 
                                                  stokes_preconditioner_matrix); 
  } 

// 现在是真正把事情放在一起的函数，使用WorkStream函数。   WorkStream::run 需要一个开始和结束迭代器来列举它应该工作的单元格。通常情况下，我们会使用 DoFHandler::begin_active() 和 DoFHandler::end() 来实现这一点，但在这里，我们实际上只想获得事实上由当前处理器拥有的单元格子集。这就是FilteredIterator类发挥作用的地方：你给它一个单元格范围，它提供一个迭代器，只迭代满足某个谓词的单元格子集（谓词是一个参数的函数，要么返回真，要么返回假）。我们在这里使用的谓词是 IteratorFilters::LocallyOwnedCell, ，也就是说，如果单元格为当前处理器所拥有，它就会准确返回真。这样得到的迭代器范围正是我们需要的。

// 有了这个障碍，我们用这组单元格、scratch和copy对象以及两个函数的指针来调用 WorkStream::run 函数：本地装配和copy-local-to-global函数。这些函数需要有非常具体的签名：前者有三个参数，后者有一个参数（关于这些参数的含义，请参见 WorkStream::run 函数的文档）。注意我们是如何使用lambda函数来创建一个满足这一要求的函数对象的。它使用了指定单元格、抓取数据和复制数据的本地装配函数的函数参数，以及期望将数据写入全局矩阵的复制函数的函数参数（也可参见 step-13 的 <code>assemble_linear_system()</code> 函数中的讨论）。另一方面，成员函数的隐含的第2个参数（即该成员函数要操作的对象的 <code>this</code> 指针）是<i>bound</i>到当前函数的 <code>this</code> 指针的，并被捕获。因此， WorkStream::run 函数不需要知道这些函数所操作的对象的任何信息。

// 当WorkStream被执行时，它将为几个单元创建几个第一类的本地装配例程，并让一些可用的处理器对其工作。然而，需要同步的函数，即写进全局矩阵的操作，每次只由一个线程按照规定的顺序执行。当然，这只适用于单个MPI进程上的并行化。不同的MPI进程将有自己的WorkStream对象，并完全独立地进行这项工作（并且在不同的内存空间）。在分布式计算中，一些数据将积累在不属于各自处理器的自由度上。如果每次遇到这样的自由度就把数据送来送去，那就没有效率了。取而代之的是，Trilinos稀疏矩阵将保留这些数据，并在装配结束时通过调用 <code>compress()</code> 命令将其发送给所有者。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_stokes_preconditioner() 
  { 
    stokes_preconditioner_matrix = 0; 

    const QGauss<dim> quadrature_formula(parameters.stokes_velocity_degree + 1); 

    using CellFilter = 
      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>; 

    auto worker = 
      [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
             Assembly::Scratch::StokesPreconditioner<dim> &        scratch, 
             Assembly::CopyData::StokesPreconditioner<dim> &       data) { 
        this->local_assemble_stokes_preconditioner(cell, scratch, data); 
      }; 

    auto copier = 
      [this](const Assembly::CopyData::StokesPreconditioner<dim> &data) { 
        this->copy_local_to_global_stokes_preconditioner(data); 
      }; 

    WorkStream::run(CellFilter(IteratorFilters::LocallyOwnedCell(), 
                               stokes_dof_handler.begin_active()), 
                    CellFilter(IteratorFilters::LocallyOwnedCell(), 
                               stokes_dof_handler.end()), 
                    worker, 
                    copier, 
                    Assembly::Scratch::StokesPreconditioner<dim>( 
                      stokes_fe, 
                      quadrature_formula, 
                      mapping, 
                      update_JxW_values | update_values | update_gradients), 
                    Assembly::CopyData::StokesPreconditioner<dim>(stokes_fe)); 

    stokes_preconditioner_matrix.compress(VectorOperation::add); 
  } 

// 这个模块的最后一个函数启动了斯托克斯预处理矩阵的装配，然后实际上是建立了斯托克斯预处理程序。它与串行情况下的功能基本相同。与 step-31 唯一不同的是，我们对压力质量矩阵使用雅可比预处理，而不是IC，这一点在介绍中已经讨论过。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::build_stokes_preconditioner() 
  { 
    if (rebuild_stokes_preconditioner == false) 
      return; 

    TimerOutput::Scope timer_section(computing_timer, 
                                     "   Build Stokes preconditioner"); 
    pcout << "   Rebuilding Stokes preconditioner..." << std::flush; 

    assemble_stokes_preconditioner(); 

    std::vector<std::vector<bool>> constant_modes; 
    FEValuesExtractors::Vector     velocity_components(0); 
    DoFTools::extract_constant_modes(stokes_dof_handler, 
                                     stokes_fe.component_mask( 
                                       velocity_components), 
                                     constant_modes); 

    Mp_preconditioner = 
      std::make_shared<TrilinosWrappers::PreconditionJacobi>(); 
    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionAMG>(); 

    TrilinosWrappers::PreconditionAMG::AdditionalData Amg_data; 
    Amg_data.constant_modes        = constant_modes; 
    Amg_data.elliptic              = true; 
    Amg_data.higher_order_elements = true; 
    Amg_data.smoother_sweeps       = 2; 
    Amg_data.aggregation_threshold = 0.02; 

    Mp_preconditioner->initialize(stokes_preconditioner_matrix.block(1, 1)); 
    Amg_preconditioner->initialize(stokes_preconditioner_matrix.block(0, 0), 
                                   Amg_data); 

    rebuild_stokes_preconditioner = false; 

    pcout << std::endl; 
  } 
// @sect5{Stokes system assembly}  

// 接下来的三个函数实现了斯托克斯系统的装配，同样分为执行局部计算的部分，将局部数据写入全局矩阵和向量的部分，以及在WorkStream类的帮助下实际运行所有单元的循环。请注意，只有在我们改变了网格的情况下才需要进行斯托克斯矩阵的组装。否则，这里只需要计算（与温度有关的）右手边。由于我们正在处理分布式矩阵和向量，我们必须在装配结束时调用相应的 <code>compress()</code> 函数，以便将非本地数据发送到所有者进程。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::local_assemble_stokes_system( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    Assembly::Scratch::StokesSystem<dim> &                scratch, 
    Assembly::CopyData::StokesSystem<dim> &               data) 
  { 
    const unsigned int dofs_per_cell = 
      scratch.stokes_fe_values.get_fe().n_dofs_per_cell(); 
    const unsigned int n_q_points = 
      scratch.stokes_fe_values.n_quadrature_points; 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    scratch.stokes_fe_values.reinit(cell); 

    typename DoFHandler<dim>::active_cell_iterator temperature_cell( 
      &triangulation, cell->level(), cell->index(), &temperature_dof_handler); 
    scratch.temperature_fe_values.reinit(temperature_cell); 

    if (rebuild_stokes_matrix) 
      data.local_matrix = 0; 
    data.local_rhs = 0; 

    scratch.temperature_fe_values.get_function_values( 
      old_temperature_solution, scratch.old_temperature_values); 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        const double old_temperature = scratch.old_temperature_values[q]; 

        for (unsigned int k = 0; k < dofs_per_cell; ++k) 
          { 
            scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q); 
            if (rebuild_stokes_matrix) 
              { 
                scratch.grads_phi_u[k] = 
                  scratch.stokes_fe_values[velocities].symmetric_gradient(k, q); 
                scratch.div_phi_u[k] = 
                  scratch.stokes_fe_values[velocities].divergence(k, q); 
                scratch.phi_p[k] = 
                  scratch.stokes_fe_values[pressure].value(k, q); 
              } 
          } 

        if (rebuild_stokes_matrix == true) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              data.local_matrix(i, j) += 
                (EquationData::eta * 2 * 
                   (scratch.grads_phi_u[i] * scratch.grads_phi_u[j]) - 
                 (EquationData::pressure_scaling * scratch.div_phi_u[i] * 
                  scratch.phi_p[j]) - 
                 (EquationData::pressure_scaling * scratch.phi_p[i] * 
                  scratch.div_phi_u[j])) * 
                scratch.stokes_fe_values.JxW(q); 

        const Tensor<1, dim> gravity = EquationData::gravity_vector( 
          scratch.stokes_fe_values.quadrature_point(q)); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          data.local_rhs(i) += (EquationData::density(old_temperature) * 
                                gravity * scratch.phi_u[i]) * 
                               scratch.stokes_fe_values.JxW(q); 
      } 

    cell->get_dof_indices(data.local_dof_indices); 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::copy_local_to_global_stokes_system( 
    const Assembly::CopyData::StokesSystem<dim> &data) 
  { 
    if (rebuild_stokes_matrix == true) 
      stokes_constraints.distribute_local_to_global(data.local_matrix, 
                                                    data.local_rhs, 
                                                    data.local_dof_indices, 
                                                    stokes_matrix, 
                                                    stokes_rhs); 
    else 
      stokes_constraints.distribute_local_to_global(data.local_rhs, 
                                                    data.local_dof_indices, 
                                                    stokes_rhs); 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_stokes_system() 
  { 
    TimerOutput::Scope timer_section(computing_timer, 
                                     "   Assemble Stokes system"); 

    if (rebuild_stokes_matrix == true) 
      stokes_matrix = 0; 

    stokes_rhs = 0; 

    const QGauss<dim> quadrature_formula(parameters.stokes_velocity_degree + 1); 

    using CellFilter = 
      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>; 

    WorkStream::run( 
      CellFilter(IteratorFilters::LocallyOwnedCell(), 
                 stokes_dof_handler.begin_active()), 
      CellFilter(IteratorFilters::LocallyOwnedCell(), stokes_dof_handler.end()), 
      [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
             Assembly::Scratch::StokesSystem<dim> &                scratch, 
             Assembly::CopyData::StokesSystem<dim> &               data) { 
        this->local_assemble_stokes_system(cell, scratch, data); 
      }, 
      [this](const Assembly::CopyData::StokesSystem<dim> &data) { 
        this->copy_local_to_global_stokes_system(data); 
      }, 
      Assembly::Scratch::StokesSystem<dim>( 
        stokes_fe, 
        mapping, 
        quadrature_formula, 
        (update_values | update_quadrature_points | update_JxW_values | 
         (rebuild_stokes_matrix == true ? update_gradients : UpdateFlags(0))), 
        temperature_fe, 
        update_values), 
      Assembly::CopyData::StokesSystem<dim>(stokes_fe)); 

    if (rebuild_stokes_matrix == true) 
      stokes_matrix.compress(VectorOperation::add); 
    stokes_rhs.compress(VectorOperation::add); 

    rebuild_stokes_matrix = false; 

    pcout << std::endl; 
  } 
// @sect5{Temperature matrix assembly}  

// 下面三个函数要完成的任务是计算温度系统的质量矩阵和拉普拉斯矩阵。这些将被结合起来，以产生半隐式时间步进矩阵，该矩阵由质量矩阵加上一个与时间 step- 相关的权重系数乘以拉普拉斯矩阵组成。这个函数本质上还是从 step-31 开始的所有单元的循环主体。

// 下面两个函数的功能与上面的类似。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::local_assemble_temperature_matrix( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    Assembly::Scratch::TemperatureMatrix<dim> &           scratch, 
    Assembly::CopyData::TemperatureMatrix<dim> &          data) 
  { 
    const unsigned int dofs_per_cell = 
      scratch.temperature_fe_values.get_fe().n_dofs_per_cell(); 
    const unsigned int n_q_points = 
      scratch.temperature_fe_values.n_quadrature_points; 

    scratch.temperature_fe_values.reinit(cell); 
    cell->get_dof_indices(data.local_dof_indices); 

    data.local_mass_matrix      = 0; 
    data.local_stiffness_matrix = 0; 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        for (unsigned int k = 0; k < dofs_per_cell; ++k) 
          { 
            scratch.grad_phi_T[k] = 
              scratch.temperature_fe_values.shape_grad(k, q); 
            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q); 
          } 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            { 
              data.local_mass_matrix(i, j) += 
                (scratch.phi_T[i] * scratch.phi_T[j] * 
                 scratch.temperature_fe_values.JxW(q)); 
              data.local_stiffness_matrix(i, j) += 
                (EquationData::kappa * scratch.grad_phi_T[i] * 
                 scratch.grad_phi_T[j] * scratch.temperature_fe_values.JxW(q)); 
            } 
      } 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::copy_local_to_global_temperature_matrix( 
    const Assembly::CopyData::TemperatureMatrix<dim> &data) 
  { 
    temperature_constraints.distribute_local_to_global(data.local_mass_matrix, 
                                                       data.local_dof_indices, 
                                                       temperature_mass_matrix); 
    temperature_constraints.distribute_local_to_global( 
      data.local_stiffness_matrix, 
      data.local_dof_indices, 
      temperature_stiffness_matrix); 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_temperature_matrix() 
  { 
    if (rebuild_temperature_matrices == false) 
      return; 

    TimerOutput::Scope timer_section(computing_timer, 
                                     "   Assemble temperature matrices"); 
    temperature_mass_matrix      = 0; 
    temperature_stiffness_matrix = 0; 

    const QGauss<dim> quadrature_formula(parameters.temperature_degree + 2); 

    using CellFilter = 
      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>; 

    WorkStream::run( 
      CellFilter(IteratorFilters::LocallyOwnedCell(), 
                 temperature_dof_handler.begin_active()), 
      CellFilter(IteratorFilters::LocallyOwnedCell(), 
                 temperature_dof_handler.end()), 
      [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
             Assembly::Scratch::TemperatureMatrix<dim> &           scratch, 
             Assembly::CopyData::TemperatureMatrix<dim> &          data) { 
        this->local_assemble_temperature_matrix(cell, scratch, data); 
      }, 
      [this](const Assembly::CopyData::TemperatureMatrix<dim> &data) { 
        this->copy_local_to_global_temperature_matrix(data); 
      }, 
      Assembly::Scratch::TemperatureMatrix<dim>(temperature_fe, 
                                                mapping, 
                                                quadrature_formula), 
      Assembly::CopyData::TemperatureMatrix<dim>(temperature_fe)); 

    temperature_mass_matrix.compress(VectorOperation::add); 
    temperature_stiffness_matrix.compress(VectorOperation::add); 

    rebuild_temperature_matrices       = false; 
    rebuild_temperature_preconditioner = true; 
  } 
// @sect5{Temperature right hand side assembly}  

// 这是最后一个装配函数。它计算温度系统的右侧，其中包括对流和稳定项。它包括对正交点上的旧解的大量评估（这对于计算稳定化的人工粘性是必要的），但在其他方面与其他装配函数类似。请注意，我们再次解决了具有不均匀边界条件的困境，只是在这一点上做了一个右手边（比较上面对 <code>project()</code> 函数的评论）。我们创建一些矩阵列，其值正好是为温度刚度矩阵输入的值，如果我们有不均匀约束的DFS的话。这将说明右边的向量与温度矩阵系统的正确平衡。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::local_assemble_temperature_rhs( 
    const std::pair<double, double> global_T_range, 
    const double                    global_max_velocity, 
    const double                    global_entropy_variation, 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    Assembly::Scratch::TemperatureRHS<dim> &              scratch, 
    Assembly::CopyData::TemperatureRHS<dim> &             data) 
  { 
    const bool use_bdf2_scheme = (timestep_number != 0); 

    const unsigned int dofs_per_cell = 
      scratch.temperature_fe_values.get_fe().n_dofs_per_cell(); 
    const unsigned int n_q_points = 
      scratch.temperature_fe_values.n_quadrature_points; 

    const FEValuesExtractors::Vector velocities(0); 

    data.local_rhs     = 0; 
    data.matrix_for_bc = 0; 
    cell->get_dof_indices(data.local_dof_indices); 

    scratch.temperature_fe_values.reinit(cell); 

    typename DoFHandler<dim>::active_cell_iterator stokes_cell( 
      &triangulation, cell->level(), cell->index(), &stokes_dof_handler); 
    scratch.stokes_fe_values.reinit(stokes_cell); 

    scratch.temperature_fe_values.get_function_values( 
      old_temperature_solution, scratch.old_temperature_values); 
    scratch.temperature_fe_values.get_function_values( 
      old_old_temperature_solution, scratch.old_old_temperature_values); 

    scratch.temperature_fe_values.get_function_gradients( 
      old_temperature_solution, scratch.old_temperature_grads); 
    scratch.temperature_fe_values.get_function_gradients( 
      old_old_temperature_solution, scratch.old_old_temperature_grads); 

    scratch.temperature_fe_values.get_function_laplacians( 
      old_temperature_solution, scratch.old_temperature_laplacians); 
    scratch.temperature_fe_values.get_function_laplacians( 
      old_old_temperature_solution, scratch.old_old_temperature_laplacians); 

    scratch.stokes_fe_values[velocities].get_function_values( 
      stokes_solution, scratch.old_velocity_values); 
    scratch.stokes_fe_values[velocities].get_function_values( 
      old_stokes_solution, scratch.old_old_velocity_values); 
    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients( 
      stokes_solution, scratch.old_strain_rates); 
    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients( 
      old_stokes_solution, scratch.old_old_strain_rates); 

    const double nu = 
      compute_viscosity(scratch.old_temperature_values, 
                        scratch.old_old_temperature_values, 
                        scratch.old_temperature_grads, 
                        scratch.old_old_temperature_grads, 
                        scratch.old_temperature_laplacians, 
                        scratch.old_old_temperature_laplacians, 
                        scratch.old_velocity_values, 
                        scratch.old_old_velocity_values, 
                        scratch.old_strain_rates, 
                        scratch.old_old_strain_rates, 
                        global_max_velocity, 
                        global_T_range.second - global_T_range.first, 
                        0.5 * (global_T_range.second + global_T_range.first), 
                        global_entropy_variation, 
                        cell->diameter()); 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        for (unsigned int k = 0; k < dofs_per_cell; ++k) 
          { 
            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q); 
            scratch.grad_phi_T[k] = 
              scratch.temperature_fe_values.shape_grad(k, q); 
          } 

        const double T_term_for_rhs = 
          (use_bdf2_scheme ? 
             (scratch.old_temperature_values[q] * 
                (1 + time_step / old_time_step) - 
              scratch.old_old_temperature_values[q] * (time_step * time_step) / 
                (old_time_step * (time_step + old_time_step))) : 
             scratch.old_temperature_values[q]); 

        const double ext_T = 
          (use_bdf2_scheme ? (scratch.old_temperature_values[q] * 
                                (1 + time_step / old_time_step) - 
                              scratch.old_old_temperature_values[q] * 
                                time_step / old_time_step) : 
                             scratch.old_temperature_values[q]); 

        const Tensor<1, dim> ext_grad_T = 
          (use_bdf2_scheme ? (scratch.old_temperature_grads[q] * 
                                (1 + time_step / old_time_step) - 
                              scratch.old_old_temperature_grads[q] * time_step / 
                                old_time_step) : 
                             scratch.old_temperature_grads[q]); 

        const Tensor<1, dim> extrapolated_u = 
          (use_bdf2_scheme ? 
             (scratch.old_velocity_values[q] * (1 + time_step / old_time_step) - 
              scratch.old_old_velocity_values[q] * time_step / old_time_step) : 
             scratch.old_velocity_values[q]); 

        const SymmetricTensor<2, dim> extrapolated_strain_rate = 
          (use_bdf2_scheme ? 
             (scratch.old_strain_rates[q] * (1 + time_step / old_time_step) - 
              scratch.old_old_strain_rates[q] * time_step / old_time_step) : 
             scratch.old_strain_rates[q]); 

        const double gamma = 
          ((EquationData::radiogenic_heating * EquationData::density(ext_T) + 
            2 * EquationData::eta * extrapolated_strain_rate * 
              extrapolated_strain_rate) / 
           (EquationData::density(ext_T) * EquationData::specific_heat)); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          { 
            data.local_rhs(i) += 
              (T_term_for_rhs * scratch.phi_T[i] - 
               time_step * extrapolated_u * ext_grad_T * scratch.phi_T[i] - 
               time_step * nu * ext_grad_T * scratch.grad_phi_T[i] + 
               time_step * gamma * scratch.phi_T[i]) * 
              scratch.temperature_fe_values.JxW(q); 

            if (temperature_constraints.is_inhomogeneously_constrained( 
                  data.local_dof_indices[i])) 
              { 
                for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                  data.matrix_for_bc(j, i) += 
                    (scratch.phi_T[i] * scratch.phi_T[j] * 
                       (use_bdf2_scheme ? ((2 * time_step + old_time_step) / 
                                           (time_step + old_time_step)) : 
                                          1.) + 
                     scratch.grad_phi_T[i] * scratch.grad_phi_T[j] * 
                       EquationData::kappa * time_step) * 
                    scratch.temperature_fe_values.JxW(q); 
              } 
          } 
      } 
  } 

  template <int dim> 
  void BoussinesqFlowProblem<dim>::copy_local_to_global_temperature_rhs( 
    const Assembly::CopyData::TemperatureRHS<dim> &data) 
  { 
    temperature_constraints.distribute_local_to_global(data.local_rhs, 
                                                       data.local_dof_indices, 
                                                       temperature_rhs, 
                                                       data.matrix_for_bc); 
  } 

// 在运行实际计算右手边的WorkStream的函数中，我们也生成了最终矩阵。如上所述，它是质量矩阵和拉普拉斯矩阵的总和，再加上一些与时间 step- 相关的权重。这个权重是由BDF-2时间积分方案指定的，见  step-31  中的介绍。这个教程程序的新内容（除了使用MPI并行化和WorkStream类），是我们现在也预先计算了温度预处理程序。原因是与求解器相比，设置雅可比预处理器需要明显的时间，因为我们通常只需要10到20次迭代来求解温度系统（这听起来很奇怪，因为雅可比实际上只包括对角线，但在特里诺斯，它是从更普遍的点松弛预处理器框架中衍生出来的，效率有点低）。因此，尽管由于时间步长可能会发生变化，矩阵条目可能会略有变化，但预先计算预处理程序的效率更高。这不是太大的问题，因为我们每隔几步就重新网格化（然后重新生成预处理程序）。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::assemble_temperature_system( 
    const double maximal_velocity) 
  { 
    const bool use_bdf2_scheme = (timestep_number != 0); 

    if (use_bdf2_scheme == true) 
      { 
        temperature_matrix.copy_from(temperature_mass_matrix); 
        temperature_matrix *= 
          (2 * time_step + old_time_step) / (time_step + old_time_step); 
        temperature_matrix.add(time_step, temperature_stiffness_matrix); 
      } 
    else 
      { 
        temperature_matrix.copy_from(temperature_mass_matrix); 
        temperature_matrix.add(time_step, temperature_stiffness_matrix); 
      } 

    if (rebuild_temperature_preconditioner == true) 
      { 
        T_preconditioner = 
          std::make_shared<TrilinosWrappers::PreconditionJacobi>(); 
        T_preconditioner->initialize(temperature_matrix); 
        rebuild_temperature_preconditioner = false; 
      } 

// 接下来的部分是计算右手边的向量。 为此，我们首先计算平均温度  $T_m$  ，我们通过残差  $E(T) =
//  (T-T_m)^2$  来评估人工黏度的稳定。我们通过在熵粘度的定义中把最高和最低温度之间的中点定义为平均温度来做到这一点。另一种方法是使用积分平均，但结果对这种选择不是很敏感。那么剩下的就只需要再次调用 WorkStream::run ，将每次调用都相同的 <code>local_assemble_temperature_rhs</code> 函数的参数绑定到正确的值中。

    temperature_rhs = 0; 

    const QGauss<dim> quadrature_formula(parameters.temperature_degree + 2); 
    const std::pair<double, double> global_T_range = 
      get_extrapolated_temperature_range(); 

    const double average_temperature = 
      0.5 * (global_T_range.first + global_T_range.second); 
    const double global_entropy_variation = 
      get_entropy_variation(average_temperature); 

    using CellFilter = 
      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>; 

    auto worker = 
      [this, global_T_range, maximal_velocity, global_entropy_variation]( 
        const typename DoFHandler<dim>::active_cell_iterator &cell, 
        Assembly::Scratch::TemperatureRHS<dim> &              scratch, 
        Assembly::CopyData::TemperatureRHS<dim> &             data) { 
        this->local_assemble_temperature_rhs(global_T_range, 
                                             maximal_velocity, 
                                             global_entropy_variation, 
                                             cell, 
                                             scratch, 
                                             data); 
      }; 

    auto copier = [this](const Assembly::CopyData::TemperatureRHS<dim> &data) { 
      this->copy_local_to_global_temperature_rhs(data); 
    }; 

    WorkStream::run(CellFilter(IteratorFilters::LocallyOwnedCell(), 
                               temperature_dof_handler.begin_active()), 
                    CellFilter(IteratorFilters::LocallyOwnedCell(), 
                               temperature_dof_handler.end()), 
                    worker, 
                    copier, 
                    Assembly::Scratch::TemperatureRHS<dim>( 
                      temperature_fe, stokes_fe, mapping, quadrature_formula), 
                    Assembly::CopyData::TemperatureRHS<dim>(temperature_fe)); 

    temperature_rhs.compress(VectorOperation::add); 
  } 

//  @sect4{BoussinesqFlowProblem::solve}  

// 这个函数在Boussinesq问题的每个时间步长中求解线性系统。首先，我们在斯托克斯系统上工作，然后在温度系统上工作。从本质上讲，它与  step-31  中的相应函数做了同样的事情。然而，这里有一些变化。

// 第一个变化与我们存储解决方案的方式有关：我们在每个MPI节点上保留具有本地拥有的自由度的向量加鬼魂节点。当我们进入一个应该用分布式矩阵进行矩阵-向量乘积的求解器时，这不是合适的形式，虽然。在那里，我们希望求解向量的分布方式与矩阵的分布方式相同，即没有任何重影。所以我们首先要做的是生成一个名为 <code>distributed_stokes_solution</code> 的分布式向量，并只将本地拥有的dof放入其中，这可以通过特里诺向量的 <code>operator=</code> 整齐地完成。

// 接下来，我们为求解器缩放压力解（或者说，初始猜测），使其与矩阵中的长度尺度相匹配，正如在介绍中讨论的那样。在求解完成后，我们也会立即将压力值缩回到正确的单位。 我们还需要将悬挂节点的压力值设置为零。这一点我们在 step-31 中也做过，以避免一些在求解阶段实际上无关紧要的向量项干扰舒尔补数。与 step-31 不同的是，这里我们只对局部拥有的压力道夫进行了处理。在对斯托克斯解进行求解后，每个处理器将分布式解复制到解向量中，其中也包括鬼元素。

// 第三个也是最明显的变化是，我们有两种斯托克斯求解器的变体。一种是有时会崩溃的快速求解器，另一种是速度较慢的稳健求解器。这就是我们在介绍中已经讨论过的。以下是我们如何实现它的。首先，我们用快速求解器进行30次迭代，该求解器是基于AMG V型循环的简单预处理，而不是近似求解（这由 <code>false</code> 对象的 <code>LinearSolvers::BlockSchurPreconditioner</code> 参数表示）。如果我们收敛了，一切都很好。如果我们没有收敛，求解器控制对象将抛出一个异常 SolverControl::NoConvergence. 通常，这将中止程序，因为我们在通常的 <code>solve()</code> 函数中没有捕捉它们。这当然不是我们想在这里发生的。相反，我们希望切换到强求解器，并继续用我们目前得到的任何矢量进行求解。因此，我们用C++的try/catch机制来捕获这个异常。然后我们在 <code>catch</code> 子句中简单地再次经历相同的求解器序列，这次我们将 @p true 标志传递给强求解器的预处理程序，表示近似CG求解。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::solve() 
  { 
    { 
      TimerOutput::Scope timer_section(computing_timer, 
                                       "   Solve Stokes system"); 

      pcout << "   Solving Stokes system... " << std::flush; 

      TrilinosWrappers::MPI::BlockVector distributed_stokes_solution( 
        stokes_rhs); 
      distributed_stokes_solution = stokes_solution; 

      distributed_stokes_solution.block(1) /= EquationData::pressure_scaling; 

      const unsigned int 
        start = (distributed_stokes_solution.block(0).size() + 
                 distributed_stokes_solution.block(1).local_range().first), 
        end   = (distributed_stokes_solution.block(0).size() + 
               distributed_stokes_solution.block(1).local_range().second); 
      for (unsigned int i = start; i < end; ++i) 
        if (stokes_constraints.is_constrained(i)) 
          distributed_stokes_solution(i) = 0; 

      PrimitiveVectorMemory<TrilinosWrappers::MPI::BlockVector> mem; 

      unsigned int  n_iterations     = 0; 
      const double  solver_tolerance = 1e-8 * stokes_rhs.l2_norm(); 
      SolverControl solver_control(30, solver_tolerance); 

      try 
        { 
          const LinearSolvers::BlockSchurPreconditioner< 
            TrilinosWrappers::PreconditionAMG, 
            TrilinosWrappers::PreconditionJacobi> 
            preconditioner(stokes_matrix, 
                           stokes_preconditioner_matrix, 
                           *Mp_preconditioner, 
                           *Amg_preconditioner, 
                           false); 

          SolverFGMRES<TrilinosWrappers::MPI::BlockVector> solver( 
            solver_control, 
            mem, 
            SolverFGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData( 
              30)); 
          solver.solve(stokes_matrix, 
                       distributed_stokes_solution, 
                       stokes_rhs, 
                       preconditioner); 

          n_iterations = solver_control.last_step(); 
        } 

      catch (SolverControl::NoConvergence &) 
        { 
          const LinearSolvers::BlockSchurPreconditioner< 
            TrilinosWrappers::PreconditionAMG, 
            TrilinosWrappers::PreconditionJacobi> 
            preconditioner(stokes_matrix, 
                           stokes_preconditioner_matrix, 
                           *Mp_preconditioner, 
                           *Amg_preconditioner, 
                           true); 

          SolverControl solver_control_refined(stokes_matrix.m(), 
                                               solver_tolerance); 
          SolverFGMRES<TrilinosWrappers::MPI::BlockVector> solver( 
            solver_control_refined, 
            mem, 
            SolverFGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData( 
              50)); 
          solver.solve(stokes_matrix, 
                       distributed_stokes_solution, 
                       stokes_rhs, 
                       preconditioner); 

          n_iterations = 
            (solver_control.last_step() + solver_control_refined.last_step()); 
        } 

      stokes_constraints.distribute(distributed_stokes_solution); 

      distributed_stokes_solution.block(1) *= EquationData::pressure_scaling; 

      stokes_solution = distributed_stokes_solution; 
      pcout << n_iterations << " iterations." << std::endl; 
    } 

// 现在让我们转到温度部分。首先，我们计算时间步长。我们发现，对于壳的几何形状，我们需要三维的时间步长比二维的小。这是因为在这种情况下，单元格的变形更大（决定CFL数值的是最小的边长）。我们不是像 step-31 中那样从最大速度和最小网格尺寸计算时间步长，而是计算局部的CFL数，即在每个单元上计算最大速度乘以网格尺寸，并计算它们的最大值。因此，我们需要将时间步长前面的因子选择得稍小一些。

// 在温度的右手边装配后，我们解决温度的线性系统（有完全分布的向量，没有任何鬼魂），应用约束条件，并将向量复制回有鬼魂的向量。

// 最后，我们提取与 step-31 类似的温度范围，以产生一些输出（例如为了帮助我们选择稳定常数，如介绍中所讨论的）。唯一的区别是，我们需要在所有处理器上交换最大值。

    { 
      TimerOutput::Scope timer_section(computing_timer, 
                                       "   Assemble temperature rhs"); 

      old_time_step = time_step; 

      const double scaling = (dim == 3 ? 0.25 : 1.0); 
      time_step            = (scaling / (2.1 * dim * std::sqrt(1. * dim)) / 
                   (parameters.temperature_degree * get_cfl_number())); 

      const double maximal_velocity = get_maximal_velocity(); 
      pcout << "   Maximal velocity: " 
            << maximal_velocity * EquationData::year_in_seconds * 100 
            << " cm/year" << std::endl; 
      pcout << "   " 
            << "Time step: " << time_step / EquationData::year_in_seconds 
            << " years" << std::endl; 

      temperature_solution = old_temperature_solution; 
      assemble_temperature_system(maximal_velocity); 
    } 

    { 
      TimerOutput::Scope timer_section(computing_timer, 
                                       "   Solve temperature system"); 

      SolverControl solver_control(temperature_matrix.m(), 
                                   1e-12 * temperature_rhs.l2_norm()); 
      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control); 

      TrilinosWrappers::MPI::Vector distributed_temperature_solution( 
        temperature_rhs); 
      distributed_temperature_solution = temperature_solution; 

      cg.solve(temperature_matrix, 
               distributed_temperature_solution, 
               temperature_rhs, 
               *T_preconditioner); 

      temperature_constraints.distribute(distributed_temperature_solution); 
      temperature_solution = distributed_temperature_solution; 

      pcout << "   " << solver_control.last_step() 
            << " CG iterations for temperature" << std::endl; 

      double temperature[2] = {std::numeric_limits<double>::max(), 
                               -std::numeric_limits<double>::max()}; 
      double global_temperature[2]; 

      for (unsigned int i = 
             distributed_temperature_solution.local_range().first; 
           i < distributed_temperature_solution.local_range().second; 
           ++i) 
        { 
          temperature[0] = 
            std::min<double>(temperature[0], 
                             distributed_temperature_solution(i)); 
          temperature[1] = 
            std::max<double>(temperature[1], 
                             distributed_temperature_solution(i)); 
        } 

      temperature[0] *= -1.0; 
      Utilities::MPI::max(temperature, MPI_COMM_WORLD, global_temperature); 
      global_temperature[0] *= -1.0; 

      pcout << "   Temperature range: " << global_temperature[0] << ' ' 
            << global_temperature[1] << std::endl; 
    } 
  } 
// @sect4{BoussinesqFlowProblem::output_results}  

// 接下来是生成输出的函数。输出的数量可以像我们在  step-31  中那样手动引入。另一种方法是把这个任务交给一个继承自DataPostprocessor类的PostProcessor，它可以被附加到DataOut。这允许我们从解决方案中输出派生量，比如本例中包含的摩擦热。它重载了虚拟函数 DataPostprocessor::evaluate_vector_field(), ，然后从 DataOut::build_patches(). 内部调用。 我们必须给它数值解、它的导数、单元的法线、实际评估点和任何额外的数量。这与 step-29 和其他程序中讨论的程序相同。

  template <int dim> 
  class BoussinesqFlowProblem<dim>::Postprocessor 
    : public DataPostprocessor<dim> 
  { 
  public: 
    Postprocessor(const unsigned int partition, const double minimal_pressure); 

    virtual void evaluate_vector_field( 
      const DataPostprocessorInputs::Vector<dim> &inputs, 
      std::vector<Vector<double>> &computed_quantities) const override; 

    virtual std::vector<std::string> get_names() const override; 

    virtual std::vector< 
      DataComponentInterpretation::DataComponentInterpretation> 
    get_data_component_interpretation() const override; 

    virtual UpdateFlags get_needed_update_flags() const override; 

  private: 
    const unsigned int partition; 
    const double       minimal_pressure; 
  }; 

  template <int dim> 
  BoussinesqFlowProblem<dim>::Postprocessor::Postprocessor( 
    const unsigned int partition, 
    const double       minimal_pressure) 
    : partition(partition) 
    , minimal_pressure(minimal_pressure) 
  {} 

// 这里我们定义了要输出的变量的名称。这些是速度、压力和温度的实际求解值，以及摩擦热和对每个单元拥有的处理器的编号。这使我们能够直观地看到处理器之间的领域划分。除了速度是矢量值的，其他的量都是标量。

  template <int dim> 
  std::vector<std::string> 
  BoussinesqFlowProblem<dim>::Postprocessor::get_names() const 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("p"); 
    solution_names.emplace_back("T"); 
    solution_names.emplace_back("friction_heating"); 
    solution_names.emplace_back("partition"); 

    return solution_names; 
  } 

  template <int dim> 
  std::vector<DataComponentInterpretation::DataComponentInterpretation> 
  BoussinesqFlowProblem<dim>::Postprocessor::get_data_component_interpretation() 
    const 
  { 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      interpretation(dim, 
                     DataComponentInterpretation::component_is_part_of_vector); 

    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 

    return interpretation; 
  } 

  template <int dim> 
  UpdateFlags 
  BoussinesqFlowProblem<dim>::Postprocessor::get_needed_update_flags() const 
  { 
    return update_values | update_gradients | update_quadrature_points; 
  } 

// 现在我们实现计算派生量的函数。正如我们对输出所做的那样，我们将速度从其SI单位重新调整为更容易阅读的单位，即厘米/年。接下来，压力被缩放为0和最大压力之间。这使得它更容易比较--本质上是使所有的压力变量变成正数或零。温度按原样计算，摩擦热按  $2 \eta \varepsilon(\mathbf{u}) \cdot \varepsilon(\mathbf{u})$  计算。

// 我们在这里输出的数量更多的是为了说明问题，而不是为了实际的科学价值。我们在本程序的结果部分简要地回到这一点，并解释人们实际上可能感兴趣的是什么。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::Postprocessor::evaluate_vector_field( 
    const DataPostprocessorInputs::Vector<dim> &inputs, 
    std::vector<Vector<double>> &               computed_quantities) const 
  { 
    const unsigned int n_quadrature_points = inputs.solution_values.size(); 
    Assert(inputs.solution_gradients.size() == n_quadrature_points, 
           ExcInternalError()); 
    Assert(computed_quantities.size() == n_quadrature_points, 
           ExcInternalError()); 
    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError()); 

    for (unsigned int q = 0; q < n_quadrature_points; ++q) 
      { 
        for (unsigned int d = 0; d < dim; ++d) 
          computed_quantities[q](d) = (inputs.solution_values[q](d) * 
                                       EquationData::year_in_seconds * 100); 

        const double pressure = 
          (inputs.solution_values[q](dim) - minimal_pressure); 
        computed_quantities[q](dim) = pressure; 

        const double temperature        = inputs.solution_values[q](dim + 1); 
        computed_quantities[q](dim + 1) = temperature; 

        Tensor<2, dim> grad_u; 
        for (unsigned int d = 0; d < dim; ++d) 
          grad_u[d] = inputs.solution_gradients[q][d]; 
        const SymmetricTensor<2, dim> strain_rate = symmetrize(grad_u); 
        computed_quantities[q](dim + 2) = 
          2 * EquationData::eta * strain_rate * strain_rate; 

        computed_quantities[q](dim + 3) = partition; 
      } 
  } 

//  <code>output_results()</code> 函数的任务与 step-31 中的类似。然而，在这里我们将演示一种不同的技术，即如何合并来自不同DoFHandler对象的输出。我们要实现这种重组的方法是创建一个联合的DoFHandler，收集两个部分，斯托克斯解和温度解。这可以通过将两个系统的有限元结合起来形成一个FES系统来很好地完成，并让这个集体系统定义一个新的DoFHandler对象。为了确保一切都做得很正确，我们进行了一次理智的检查，确保我们从斯托克斯和温度两个系统中得到了所有的道夫，甚至是在组合系统中。然后我们将数据向量合并。不幸的是，没有直接的关系告诉我们如何将斯托克斯和温度矢量分类到联合矢量中。我们可以绕过这个麻烦的方法是依靠FES系统中收集的信息。对于一个单元上的每个dof，联合有限元知道它属于哪个方程分量（速度分量、压力或温度）--这就是我们所需要的信息！这就是我们所需要的。因此，我们通过所有单元（迭代器进入所有三个DoFHandlers同步移动），对于每个联合单元dof，我们使用 FiniteElement::system_to_base_index 函数读出该分量（关于其返回值的各个部分的描述见那里）。我们还需要跟踪我们是在斯托克斯道次还是温度道次，这包含在joint_fe.system_to_base_index(i).first.first中。最终，三个系统中的任何一个系统的dof_indices数据结构都会告诉我们全局矢量和局部dof之间的关系在当前单元上是怎样的，这就结束了这项繁琐的工作。我们确保每个处理器在建立联合求解向量时，只在其本地拥有的子域上工作（而不是在幽灵或人工单元上）。然后在 DataOut::build_patches(), 中也要这样做，但该函数会自动这样做。

// 我们最终得到的是一组补丁，我们可以使用DataOutBase中的函数以各种输出格式编写补丁。在这里，我们必须注意，每个处理器所写的实际上只是它自己领域的一部分，也就是说，我们要把每个处理器的贡献写进一个单独的文件。我们通过在写解决方案时给文件名添加一个额外的数字来做到这一点。这其实并不新鲜，我们在  step-40  中也是这样做的。注意，我们用压缩格式 @p .vtu 而不是普通的vtk文件来写，这样可以节省不少存储空间。

// 所有其余的工作都在后处理程序类中完成。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::output_results() 
  { 
    TimerOutput::Scope timer_section(computing_timer, "Postprocessing"); 

    const FESystem<dim> joint_fe(stokes_fe, 1, temperature_fe, 1); 

    DoFHandler<dim> joint_dof_handler(triangulation); 
    joint_dof_handler.distribute_dofs(joint_fe); 
    Assert(joint_dof_handler.n_dofs() == 
             stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(), 
           ExcInternalError()); 

    TrilinosWrappers::MPI::Vector joint_solution; 
    joint_solution.reinit(joint_dof_handler.locally_owned_dofs(), 
                          MPI_COMM_WORLD); 

    { 
      std::vector<types::global_dof_index> local_joint_dof_indices( 
        joint_fe.n_dofs_per_cell()); 
      std::vector<types::global_dof_index> local_stokes_dof_indices( 
        stokes_fe.n_dofs_per_cell()); 
      std::vector<types::global_dof_index> local_temperature_dof_indices( 
        temperature_fe.n_dofs_per_cell()); 

      typename DoFHandler<dim>::active_cell_iterator 
        joint_cell       = joint_dof_handler.begin_active(), 
        joint_endc       = joint_dof_handler.end(), 
        stokes_cell      = stokes_dof_handler.begin_active(), 
        temperature_cell = temperature_dof_handler.begin_active(); 
      for (; joint_cell != joint_endc; 
           ++joint_cell, ++stokes_cell, ++temperature_cell) 
        if (joint_cell->is_locally_owned()) 
          { 
            joint_cell->get_dof_indices(local_joint_dof_indices); 
            stokes_cell->get_dof_indices(local_stokes_dof_indices); 
            temperature_cell->get_dof_indices(local_temperature_dof_indices); 

            for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i) 
              if (joint_fe.system_to_base_index(i).first.first == 0) 
                { 
                  Assert(joint_fe.system_to_base_index(i).second < 
                           local_stokes_dof_indices.size(), 
                         ExcInternalError()); 

                  joint_solution(local_joint_dof_indices[i]) = stokes_solution( 
                    local_stokes_dof_indices[joint_fe.system_to_base_index(i) 
                                               .second]); 
                } 
              else 
                { 
                  Assert(joint_fe.system_to_base_index(i).first.first == 1, 
                         ExcInternalError()); 
                  Assert(joint_fe.system_to_base_index(i).second < 
                           local_temperature_dof_indices.size(), 
                         ExcInternalError()); 
                  joint_solution(local_joint_dof_indices[i]) = 
                    temperature_solution( 
                      local_temperature_dof_indices 
                        [joint_fe.system_to_base_index(i).second]); 
                } 
          } 
    } 

    joint_solution.compress(VectorOperation::insert); 

    IndexSet locally_relevant_joint_dofs(joint_dof_handler.n_dofs()); 
    DoFTools::extract_locally_relevant_dofs(joint_dof_handler, 
                                            locally_relevant_joint_dofs); 
    TrilinosWrappers::MPI::Vector locally_relevant_joint_solution; 
    locally_relevant_joint_solution.reinit(locally_relevant_joint_dofs, 
                                           MPI_COMM_WORLD); 
    locally_relevant_joint_solution = joint_solution; 

    Postprocessor postprocessor(Utilities::MPI::this_mpi_process( 
                                  MPI_COMM_WORLD), 
                                stokes_solution.block(1).min()); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(joint_dof_handler); 
    data_out.add_data_vector(locally_relevant_joint_solution, postprocessor); 
    data_out.build_patches(); 

    static int out_index = 0; 
    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", out_index, MPI_COMM_WORLD, 5); 

    out_index++; 
  } 

//  @sect4{BoussinesqFlowProblem::refine_mesh}  

// 这个函数也不是真正的新函数。因为我们在中间调用的 <code>setup_dofs</code> 函数有自己的定时器部分，所以我们把这个函数的定时分成两部分。这也可以让我们很容易地识别出这两个中哪个更昂贵。
//但是，
//有一点需要注意的是，我们只想在本地拥有的子域上计算错误指标。为了达到这个目的，我们向 KellyErrorEstimator::estimate 函数传递一个额外的参数。请注意，用于误差估计的向量被调整为当前进程上存在的活动单元的数量，它小于所有处理器上活动单元的总数（但大于本地拥有的活动单元的数量）；每个处理器只有本地拥有的单元周围有一些粗略的单元，这在  step-40  中也有解释。

// 本地误差估计值然后被交给GridRefinement的%并行版本（在命名空间 parallel::distributed::GridRefinement, 中，也见 step-40 ），它查看误差并通过比较各处理器的误差值找到需要细化的单元。正如在 step-31 中，我们希望限制最大的网格级别。因此，万一有些单元格已经被标记为最精细的级别，我们只需清除细化标志。

  template <int dim> 
  void 
  BoussinesqFlowProblem<dim>::refine_mesh(const unsigned int max_grid_level) 
  { 
    parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> 
      temperature_trans(temperature_dof_handler); 
    parallel::distributed::SolutionTransfer<dim, 
                                            TrilinosWrappers::MPI::BlockVector> 
      stokes_trans(stokes_dof_handler); 

    { 
      TimerOutput::Scope timer_section(computing_timer, 
                                       "Refine mesh structure, part 1"); 

      Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

      KellyErrorEstimator<dim>::estimate( 
        temperature_dof_handler, 
        QGauss<dim - 1>(parameters.temperature_degree + 1), 
        std::map<types::boundary_id, const Function<dim> *>(), 
        temperature_solution, 
        estimated_error_per_cell, 
        ComponentMask(), 
        nullptr, 
        0, 
        triangulation.locally_owned_subdomain()); 

      parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction( 
        triangulation, estimated_error_per_cell, 0.3, 0.1); 

      if (triangulation.n_levels() > max_grid_level) 
        for (typename Triangulation<dim>::active_cell_iterator cell = 
               triangulation.begin_active(max_grid_level); 
             cell != triangulation.end(); 
             ++cell) 
          cell->clear_refine_flag(); 

// 有了所有的标记，我们就可以告诉 parallel::distributed::SolutionTransfer 对象准备将数据从一个网格转移到下一个网格，当Triangulation作为 @p execute_coarsening_and_refinement() 调用的一部分通知他们时，他们就会这样做。语法类似于非%并行解决方案的传输（例外的是这里有一个指向向量项的指针就足够了）。下面函数的其余部分是在网格细化后再次设置数据结构，并在新的网格上恢复求解向量。

      std::vector<const TrilinosWrappers::MPI::Vector *> x_temperature(2); 
      x_temperature[0] = &temperature_solution; 
      x_temperature[1] = &old_temperature_solution; 
      std::vector<const TrilinosWrappers::MPI::BlockVector *> x_stokes(2); 
      x_stokes[0] = &stokes_solution; 
      x_stokes[1] = &old_stokes_solution; 

      triangulation.prepare_coarsening_and_refinement(); 

      temperature_trans.prepare_for_coarsening_and_refinement(x_temperature); 
      stokes_trans.prepare_for_coarsening_and_refinement(x_stokes); 

      triangulation.execute_coarsening_and_refinement(); 
    } 

    setup_dofs(); 

    { 
      TimerOutput::Scope timer_section(computing_timer, 
                                       "Refine mesh structure, part 2"); 

      { 
        TrilinosWrappers::MPI::Vector distributed_temp1(temperature_rhs); 
        TrilinosWrappers::MPI::Vector distributed_temp2(temperature_rhs); 

        std::vector<TrilinosWrappers::MPI::Vector *> tmp(2); 
        tmp[0] = &(distributed_temp1); 
        tmp[1] = &(distributed_temp2); 
        temperature_trans.interpolate(tmp); 

// 强制执行约束条件，使插值后的解决方案在新的网格上符合要求。

        temperature_constraints.distribute(distributed_temp1); 
        temperature_constraints.distribute(distributed_temp2); 

        temperature_solution     = distributed_temp1; 
        old_temperature_solution = distributed_temp2; 
      } 

      { 
        TrilinosWrappers::MPI::BlockVector distributed_stokes(stokes_rhs); 
        TrilinosWrappers::MPI::BlockVector old_distributed_stokes(stokes_rhs); 

        std::vector<TrilinosWrappers::MPI::BlockVector *> stokes_tmp(2); 
        stokes_tmp[0] = &(distributed_stokes); 
        stokes_tmp[1] = &(old_distributed_stokes); 

        stokes_trans.interpolate(stokes_tmp); 

// 强制执行约束条件，使插值后的解决方案在新的网格上符合要求。

        stokes_constraints.distribute(distributed_stokes); 
        stokes_constraints.distribute(old_distributed_stokes); 

        stokes_solution     = distributed_stokes; 
        old_stokes_solution = old_distributed_stokes; 
      } 
    } 
  } 

//  @sect4{BoussinesqFlowProblem::run}  

// 这是这个类中的最后一个控制函数。事实上，它运行了整个程序的其余部分，并且再次与  step-31  非常相似。唯一的实质性区别是我们现在使用了一个不同的网格（一个 GridGenerator::hyper_shell 而不是一个简单的立方体几何）。

  template <int dim> 
  void BoussinesqFlowProblem<dim>::run() 
  { 
    GridGenerator::hyper_shell(triangulation, 
                               Point<dim>(), 
                               EquationData::R0, 
                               EquationData::R1, 
                               (dim == 3) ? 96 : 12, 
                               true); 

    global_Omega_diameter = GridTools::diameter(triangulation); 

    triangulation.refine_global(parameters.initial_global_refinement); 

    setup_dofs(); 

    unsigned int pre_refinement_step = 0; 

  start_time_iteration: 

    { 
      TrilinosWrappers::MPI::Vector solution( 
        temperature_dof_handler.locally_owned_dofs()); 
// VectorTools::project 通过deal.II自己的本地MatrixFree框架支持具有大多数标准有限元素的并行矢量类：由于我们使用中等阶数的标准拉格朗日元素，这个函数在这里工作得很好。

      VectorTools::project(temperature_dof_handler, 
                           temperature_constraints, 
                           QGauss<dim>(parameters.temperature_degree + 2), 
                           EquationData::TemperatureInitialValues<dim>(), 
                           solution); 

// 在如此计算了当前的温度字段之后，让我们设置保存温度节点的成员变量。严格来说，我们真的只需要设置 <code>old_temperature_solution</code> ，因为我们要做的第一件事是计算斯托克斯解，它只需要前一个时间步长的温度场。尽管如此，如果我们想扩展我们的数值方法或物理模型，不初始化其他的向量也不会有什么好处（特别是这是一个相对便宜的操作，我们只需要在程序开始时做一次），所以我们也初始化 <code>old_temperature_solution</code> 和 <code>old_old_temperature_solution</code> 。这个赋值确保了左边的向量（初始化后也包含鬼魂元素）也得到了正确的鬼魂元素。换句话说，这里的赋值需要处理器之间的通信。

      temperature_solution         = solution; 
      old_temperature_solution     = solution; 
      old_old_temperature_solution = solution; 
    } 

    timestep_number = 0; 
    time_step = old_time_step = 0; 

    double time = 0; 

    do 
      { 
        pcout << "Timestep " << timestep_number 
              << ":  t=" << time / EquationData::year_in_seconds << " years" 
              << std::endl; 

        assemble_stokes_system(); 
        build_stokes_preconditioner(); 
        assemble_temperature_matrix(); 

        solve(); 

        pcout << std::endl; 

        if ((timestep_number == 0) && 
            (pre_refinement_step < parameters.initial_adaptive_refinement)) 
          { 
            refine_mesh(parameters.initial_global_refinement + 
                        parameters.initial_adaptive_refinement); 
            ++pre_refinement_step; 
            goto start_time_iteration; 
          } 
        else if ((timestep_number > 0) && 
                 (timestep_number % parameters.adaptive_refinement_interval == 
                  0)) 
          refine_mesh(parameters.initial_global_refinement + 
                      parameters.initial_adaptive_refinement); 

        if ((parameters.generate_graphical_output == true) && 
            (timestep_number % parameters.graphical_output_interval == 0)) 
          output_results(); 

// 为了加快线性求解器的速度，我们从旧的时间水平上推断出新的解决方案。这可以提供一个非常好的初始猜测，使求解器所需的迭代次数减少一半以上。我们不需要在最后一次迭代中进行推断，所以如果我们达到了最后的时间，我们就在这里停止。

// 作为一个时间步长的最后一件事（在实际提高时间步长之前），我们检查当前的时间步长是否被100整除，如果是的话，我们让计算计时器打印一个到目前为止所花费的CPU时间的总结。

        if (time > parameters.end_time * EquationData::year_in_seconds) 
          break; 

        TrilinosWrappers::MPI::BlockVector old_old_stokes_solution; 
        old_old_stokes_solution      = old_stokes_solution; 
        old_stokes_solution          = stokes_solution; 
        old_old_temperature_solution = old_temperature_solution; 
        old_temperature_solution     = temperature_solution; 
        if (old_time_step > 0) 
          { 

// Trilinos sadd不喜欢鬼魂向量，即使作为输入。暂时复制到分布式向量中。

            { 
              TrilinosWrappers::MPI::BlockVector distr_solution(stokes_rhs); 
              distr_solution = stokes_solution; 
              TrilinosWrappers::MPI::BlockVector distr_old_solution(stokes_rhs); 
              distr_old_solution = old_old_stokes_solution; 
              distr_solution.sadd(1. + time_step / old_time_step, 
                                  -time_step / old_time_step, 
                                  distr_old_solution); 
              stokes_solution = distr_solution; 
            } 
            { 
              TrilinosWrappers::MPI::Vector distr_solution(temperature_rhs); 
              distr_solution = temperature_solution; 
              TrilinosWrappers::MPI::Vector distr_old_solution(temperature_rhs); 
              distr_old_solution = old_old_temperature_solution; 
              distr_solution.sadd(1. + time_step / old_time_step, 
                                  -time_step / old_time_step, 
                                  distr_old_solution); 
              temperature_solution = distr_solution; 
            } 
          } 

        if ((timestep_number > 0) && (timestep_number % 100 == 0)) 
          computing_timer.print_summary(); 

        time += time_step; 
        ++timestep_number; 
      } 
    while (true); 

// 如果我们要生成图形输出，也要对最后一个时间步骤这样做，除非我们在离开do-while循环之前刚刚这样做。

    if ((parameters.generate_graphical_output == true) && 
        !((timestep_number - 1) % parameters.graphical_output_interval == 0)) 
      output_results(); 
  } 
} // namespace Step32 

//  @sect3{The <code>main</code> function}  

// 主函数像往常一样简短，与  step-31  中的函数非常相似。由于我们使用了一个参数文件，该文件在命令行中被指定为参数，所以我们必须在这里读取它，并将其传递给参数类进行解析。如果命令行中没有给出文件名，我们就简单地使用与程序一起分发的  <code>\step-32.prm</code>  文件。

// 由于三维计算非常缓慢，除非你投入大量的处理器，程序默认为二维。你可以通过把下面的常数维度改为3来获得三维版本。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace Step32; 
      using namespace dealii; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization( 
        argc, argv, numbers::invalid_unsigned_int); 

      std::string parameter_filename; 
      if (argc >= 2) 
        parameter_filename = argv[1]; 
      else 
        parameter_filename = "step-32.prm"; 

      const int                              dim = 2; 
      BoussinesqFlowProblem<dim>::Parameters parameters(parameter_filename); 
      BoussinesqFlowProblem<dim>             flow_problem(parameters); 
      flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-33.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2007 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: David Neckels, Boulder, Colorado, 2007, 2008 
 */ 


// @sect3{Include files}  

// 首先是一套标准的deal.II包括。这里没有什么特别需要评论的。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/parameter_handler.h> 
#include <deal.II/base/function_parser.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/conditional_ostream.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/grid_in.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/mapping_q1.h> 
#include <deal.II/fe/fe_q.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/solution_transfer.h> 

// 然后，正如介绍中提到的，我们使用各种Trilinos软件包作为线性求解器以及自动微分。这些都在以下的包含文件中。

// 由于deal.II提供了基本的Trilinos矩阵、预处理程序和求解器的接口，我们把它们作为deal.II线性代数结构类似地包括在内。

#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/trilinos_precondition.h> 
#include <deal.II/lac/trilinos_solver.h> 

// Sacado是Trilinos中的自动微分包，用于寻找全隐式牛顿迭代的雅各布系数。

#include <Sacado.hpp> 

// 这又是C++语言。

#include <iostream> 
#include <fstream> 
#include <vector> 
#include <memory> 
#include <array> 

// 在本节结束时，将dealii库中的所有内容引入本程序内容将进入的命名空间。

namespace Step33 
{ 
  using namespace dealii; 
// @sect3{Euler equation specifics}  

// 这里我们定义了这个特定的守恒定律系统的通量函数，以及几乎所有其他的气体动力学欧拉方程所特有的东西，原因在介绍中讨论过。我们将所有这些归入一个结构，该结构定义了所有与通量有关的东西。这个结构的所有成员都是静态的，也就是说，这个结构没有由实例成员变量指定的实际状态。更好的方法是使用命名空间，而不是一个拥有所有静态成员的结构--但是命名空间不能被模板化，而且我们希望结构中的一些成员变量取决于空间维度，我们以通常的方式用模板参数来引入。

  template <int dim> 
  struct EulerEquations 
  { 
// @sect4{Component description}  

// 首先是几个变量，它们以一种通用的方式描述了我们的解向量的各个组成部分。这包括系统中分量的数量（欧拉方程中每个空间方向的动量都有一个条目，加上能量和密度分量，总共有 <code>dim+2</code> 个分量），以及描述第一个动量分量、密度分量和能量密度分量在解向量中的索引的函数。请注意，所有这些%数都取决于空间维度；以通用的方式定义它们（而不是以隐含的惯例）使我们的代码更加灵活，并使以后的扩展更加容易，例如，在方程中加入更多的分量。

    static const unsigned int n_components             = dim + 2; 
    static const unsigned int first_momentum_component = 0; 
    static const unsigned int density_component        = dim; 
    static const unsigned int energy_component         = dim + 1; 

// 在这个程序中一路生成图形输出时，我们需要指定解变量的名称，以及各种成分如何分组为矢量和标量场。我们可以在这里进行描述，但是为了使与欧拉方程有关的事情在这里得到解决，并使程序的其他部分尽可能地通用，我们在以下两个函数中提供了这类信息。

    static std::vector<std::string> component_names() 
    { 
      std::vector<std::string> names(dim, "momentum"); 
      names.emplace_back("density"); 
      names.emplace_back("energy_density"); 

      return names; 
    } 

    static std::vector<DataComponentInterpretation::DataComponentInterpretation> 
    component_interpretation() 
    { 
      std::vector<DataComponentInterpretation::DataComponentInterpretation> 
        data_component_interpretation( 
          dim, DataComponentInterpretation::component_is_part_of_vector); 
      data_component_interpretation.push_back( 
        DataComponentInterpretation::component_is_scalar); 
      data_component_interpretation.push_back( 
        DataComponentInterpretation::component_is_scalar); 

      return data_component_interpretation; 
    } 
// @sect4{Transformations between variables}  

// 接下来，我们定义气体常数。我们将在紧接着这个类的声明之后的定义中把它设置为1.4（与整数变量不同，比如上面的变量，静态常量浮点成员变量不能在C++的类声明中被初始化）。这个1.4的值代表了由两个原子组成的分子的气体，比如空气，它几乎完全由 $N_2$ 和 $O_2$ 组成，痕迹很小。

    static const double gas_gamma; 

// 在下文中，我们将需要从保守变量的矢量中计算动能和压力。我们可以根据能量密度和动能 $\frac 12 \rho |\mathbf v|^2= \frac{|\rho \mathbf v|^2}{2\rho}$ 来做这件事（注意，独立变量包含动量分量 $\rho v_i$ ，而不是速度 $v_i$ ）。

    template <typename InputVector> 
    static typename InputVector::value_type 
    compute_kinetic_energy(const InputVector &W) 
    { 
      typename InputVector::value_type kinetic_energy = 0; 
      for (unsigned int d = 0; d < dim; ++d) 
        kinetic_energy += 
          W[first_momentum_component + d] * W[first_momentum_component + d]; 
      kinetic_energy *= 1. / (2 * W[density_component]); 

      return kinetic_energy; 
    } 

    template <typename InputVector> 
    static typename InputVector::value_type 
    compute_pressure(const InputVector &W) 
    { 
      return ((gas_gamma - 1.0) * 
              (W[energy_component] - compute_kinetic_energy(W))); 
    } 
// @sect4{EulerEquations::compute_flux_matrix}  

// 我们将通量函数 $F(W)$ 定义为一个大矩阵。 这个矩阵的每一行都代表了该行成分的标量守恒定律。 这个矩阵的确切形式在介绍中给出。请注意，我们知道这个矩阵的大小：它的行数与系统的分量一样多， <code>dim</code> 列数一样多；我们没有为这样的矩阵使用FullMatrix对象（它的行数和列数是可变的，因此每次创建这样的矩阵时必须在堆上分配内存），而是马上使用一个矩形的数字阵列。

// 我们将通量函数的数值类型模板化，这样我们就可以在这里使用自动微分类型。 同样地，我们将用不同的输入矢量数据类型来调用该函数，所以我们也对其进行模板化。

    template <typename InputVector> 
    static void compute_flux_matrix(const InputVector &W, 
                                    ndarray<typename InputVector::value_type, 
                                            EulerEquations<dim>::n_components, 
                                            dim> &     flux) 
    { 

// 首先计算出现在通量矩阵中的压力，然后计算矩阵中对应于动量项的前 <code>dim</code> 列。

      const typename InputVector::value_type pressure = compute_pressure(W); 

      for (unsigned int d = 0; d < dim; ++d) 
        { 
          for (unsigned int e = 0; e < dim; ++e) 
            flux[first_momentum_component + d][e] = 
              W[first_momentum_component + d] * 
              W[first_momentum_component + e] / W[density_component]; 

          flux[first_momentum_component + d][d] += pressure; 
        } 

// 然后是密度（即质量守恒）的条款，最后是能量守恒。

      for (unsigned int d = 0; d < dim; ++d) 
        flux[density_component][d] = W[first_momentum_component + d]; 

      for (unsigned int d = 0; d < dim; ++d) 
        flux[energy_component][d] = W[first_momentum_component + d] / 
                                    W[density_component] * 
                                    (W[energy_component] + pressure); 
    } 
// @sect4{EulerEquations::compute_normal_flux}  

// 在域的边界和跨挂节点上，我们使用一个数值通量函数来强制执行边界条件。 这个程序是基本的Lax-Friedrich的通量，有一个稳定的参数  $\alpha$  。它的形式也已经在介绍中给出。

    template <typename InputVector> 
    static void numerical_normal_flux( 
      const Tensor<1, dim> &                                      normal, 
      const InputVector &                                         Wplus, 
      const InputVector &                                         Wminus, 
      const double                                                alpha, 
      std::array<typename InputVector::value_type, n_components> &normal_flux) 
    { 
      ndarray<typename InputVector::value_type, 
              EulerEquations<dim>::n_components, 
              dim> 
        iflux, oflux; 

      compute_flux_matrix(Wplus, iflux); 
      compute_flux_matrix(Wminus, oflux); 

      for (unsigned int di = 0; di < n_components; ++di) 
        { 
          normal_flux[di] = 0; 
          for (unsigned int d = 0; d < dim; ++d) 
            normal_flux[di] += 0.5 * (iflux[di][d] + oflux[di][d]) * normal[d]; 

          normal_flux[di] += 0.5 * alpha * (Wplus[di] - Wminus[di]); 
        } 
    } 
// @sect4{EulerEquations::compute_forcing_vector}  

// 与描述通量函数 $\mathbf F(\mathbf w)$ 的方式相同，我们也需要有一种方法来描述右侧的强迫项。正如介绍中提到的，我们在这里只考虑重力，这导致了具体的形式 $\mathbf G(\mathbf w) = \left( g_1\rho, g_2\rho, g_3\rho, 0, \rho \mathbf g \cdot \mathbf v \right)^T$ ，这里显示的是三维情况。更具体地说，我们将只考虑三维的 $\mathbf g=(0,0,-1)^T$ ，或二维的 $\mathbf g=(0,-1)^T$ 。这自然导致了以下函数。

    template <typename InputVector> 
    static void compute_forcing_vector( 
      const InputVector &                                         W, 
      std::array<typename InputVector::value_type, n_components> &forcing) 
    { 
      const double gravity = -1.0; 

      for (unsigned int c = 0; c < n_components; ++c) 
        switch (c) 
          { 
            case first_momentum_component + dim - 1: 
              forcing[c] = gravity * W[density_component]; 
              break; 
            case energy_component: 
              forcing[c] = gravity * W[first_momentum_component + dim - 1]; 
              break; 
            default: 
              forcing[c] = 0; 
          } 
    } 
// @sect4{Dealing with boundary conditions}  

// 我们必须处理的另一件事是边界条件。为此，让我们首先定义一下我们目前知道如何处理的各种边界条件。

    enum BoundaryKind 
    { 
      inflow_boundary, 
      outflow_boundary, 
      no_penetration_boundary, 
      pressure_boundary 
    }; 

// 接下来的部分是实际决定在每一种边界上做什么。为此，请记住，从介绍中可以看出，边界条件是通过在给定的不均匀性 $\mathbf j$ 的边界外侧选择一个值 $\mathbf w^-$ ，以及可能在内部选择解的值 $\mathbf w^+$ 来指定的。然后，两者都被传递给数值通量 $\mathbf H(\mathbf{w}^+, \mathbf{w}^-, \mathbf{n})$ ，以定义边界对双线性形式的贡献。

// 边界条件在某些情况下可以为解矢量的每个分量独立指定。例如，如果分量 $c$ 被标记为流入，那么 $w^-_c = j_c$  。如果是流出，那么 $w^-_c = w^+_c$  。这两种简单的情况在下面的函数中首先得到处理。

// 有一个小插曲，从C++语言的角度来看，这个函数是不愉快的。输出向量  <code>Wminus</code>  当然会被修改，所以它不应该是  <code>const</code>  的参数。然而，在下面的实现中，它却成为了参数，而且为了使代码能够编译，它必须成为参数。原因是我们在 <code>Wminus</code> 类型为 <code>Table@<2,Sacado::Fad::DFad@<double@> @></code> 的地方调用这个函数，这是一个2d表，其指数分别代表正交点和向量分量。我们用 <code>Wminus[q]</code> 作为最后一个参数来调用这个函数；对2d表进行下标会产生一个代表1d向量的临时访问器对象，这正是我们在这里想要的。问题是，根据C++ 1998和2003标准，临时访问器对象不能被绑定到一个函数的非静态引用参数上，就像我们在这里希望的那样（这个问题将在下一个标准中以rvalue引用的形式得到解决）。 我们在这里把输出参数变成常量，是因为<i>accessor</i>对象是常量，而不是它所指向的表：那个表仍然可以被写到。然而，这个黑客是不愉快的，因为它限制了可以作为这个函数的模板参数的数据类型：一个普通的向量是不行的，因为当标记为  <code>const</code>  时，不能被写入。由于目前没有好的解决方案，我们将采用这里显示的务实的，甚至是不漂亮的解决方案。

    template <typename DataVector> 
    static void 
    compute_Wminus(const std::array<BoundaryKind, n_components> &boundary_kind, 
                   const Tensor<1, dim> &                        normal_vector, 
                   const DataVector &                            Wplus, 
                   const Vector<double> &boundary_values, 
                   const DataVector &    Wminus) 
    { 
      for (unsigned int c = 0; c < n_components; c++) 
        switch (boundary_kind[c]) 
          { 
            case inflow_boundary: 
              { 
                Wminus[c] = boundary_values(c); 
                break; 
              } 

            case outflow_boundary: 
              { 
                Wminus[c] = Wplus[c]; 
                break; 
              } 

// 规定的压力边界条件有点复杂，因为即使压力是规定的，我们在这里真正设定的是能量分量，它将取决于速度和压力。因此，尽管这似乎是一个Dirichlet类型的边界条件，但我们得到了能量对速度和密度的敏感性（除非这些也被规定了）。

            case pressure_boundary: 
              { 
                const typename DataVector::value_type density = 
                  (boundary_kind[density_component] == inflow_boundary ? 
                     boundary_values(density_component) : 
                     Wplus[density_component]); 

                typename DataVector::value_type kinetic_energy = 0; 
                for (unsigned int d = 0; d < dim; ++d) 
                  if (boundary_kind[d] == inflow_boundary) 
                    kinetic_energy += boundary_values(d) * boundary_values(d); 
                  else 
                    kinetic_energy += Wplus[d] * Wplus[d]; 
                kinetic_energy *= 1. / 2. / density; 

                Wminus[c] = 
                  boundary_values(c) / (gas_gamma - 1.0) + kinetic_energy; 

                break; 
              } 

            case no_penetration_boundary: 
              { 

// 我们规定了速度（我们在这里处理的是一个特定的分量，所以速度的平均值是与表面法线正交的。 这就形成了整个速度分量的敏感度。

                typename DataVector::value_type vdotn = 0; 
                for (unsigned int d = 0; d < dim; d++) 
                  { 
                    vdotn += Wplus[d] * normal_vector[d]; 
                  } 

                Wminus[c] = Wplus[c] - 2.0 * vdotn * normal_vector[c]; 
                break; 
              } 

            default: 
              Assert(false, ExcNotImplemented()); 
          } 
    } 
// @sect4{EulerEquations::compute_refinement_indicators}  

// 在这个类中，我们也要指定如何细化网格。这个类 <code>ConservationLaw</code> 将使用我们在 <code>EulerEquation</code> 类中提供的所有信息，对于它所求解的特定守恒定律是不可知的：它甚至不关心一个求解向量有多少个分量。因此，它不可能知道合理的细化指标是什么。另一方面，在这里我们知道，或者至少我们可以想出一个合理的选择：我们简单地看一下密度的梯度，然后计算  $\eta_K=\log\left(1+|\nabla\rho(x_K)|\right)$  ，其中  $x_K$  是单元格  $K$  的中心。

// 当然也有很多同样合理的细化指标，但这个指标确实如此，而且很容易计算。

    static void 
    compute_refinement_indicators(const DoFHandler<dim> &dof_handler, 
                                  const Mapping<dim> &   mapping, 
                                  const Vector<double> & solution, 
                                  Vector<double> &       refinement_indicators) 
    { 
      const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell(); 
      std::vector<unsigned int> dofs(dofs_per_cell); 

      const QMidpoint<dim> quadrature_formula; 
      const UpdateFlags    update_flags = update_gradients; 
      FEValues<dim>        fe_v(mapping, 
                         dof_handler.get_fe(), 
                         quadrature_formula, 
                         update_flags); 

      std::vector<std::vector<Tensor<1, dim>>> dU( 
        1, std::vector<Tensor<1, dim>>(n_components)); 

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        { 
          const unsigned int cell_no = cell->active_cell_index(); 
          fe_v.reinit(cell); 
          fe_v.get_function_gradients(solution, dU); 

          refinement_indicators(cell_no) = std::log( 
            1 + std::sqrt(dU[0][density_component] * dU[0][density_component])); 
        } 
    } 

//  @sect4{EulerEquations::Postprocessor}  

// 最后，我们声明一个实现数据组件后处理的类。这个类解决的问题是，我们使用的欧拉方程的表述中的变量是保守的而不是物理形式的：它们是动量密度  $\mathbf m=\rho\mathbf v$  ，密度  $\rho$  ，和能量密度  $E$  。我们还想把速度  $\mathbf v=\frac{\mathbf m}{\rho}$  和压力  $p=(\gamma-1)(E-\frac{1}{2} \rho |\mathbf v|^2)$  放入我们的输出文件中。

// 此外，我们还想增加生成Schlieren图的可能性。Schlieren图是一种将冲击和其他尖锐界面可视化的方法。Schlieren "这个词是一个德语单词，可以翻译成 "条纹"--不过，用一个例子来解释可能更简单：比如说，当你把高浓度的酒精或透明的盐水倒入水中时，你会看到schlieren；这两种物质的颜色相同，但它们的折射率不同，所以在它们完全混合之前，光线会沿着弯曲的光线穿过混合物，如果你看它，会导致亮度变化。这就是 "分光"。类似的效果发生在可压缩流中，因为折射率取决于气体的压力（以及因此的密度）。

// 这个词的起源是指三维体积的二维投影（我们看到的是三维流体的二维图片）。在计算流体力学中，我们可以通过考虑其原因来了解这种效应：密度变化。因此，Schlieren图是通过绘制 $s=|\nabla \rho|^2$ 产生的；显然， $s$ 在冲击和其他高度动态的地方很大。如果用户需要（通过在输入文件中指定），我们希望除了上面列出的其他派生量之外，还能生成这些希里伦图。

// 从解决我们问题的数量中计算出派生数量，并将其输出到数据文件中的算法的实现依赖于DataPostprocessor类。它有大量的文档，该类的其他用途也可以在  step-29  中找到。因此，我们避免了大量的评论。

    class Postprocessor : public DataPostprocessor<dim> 
    { 
    public: 
      Postprocessor(const bool do_schlieren_plot); 

      virtual void evaluate_vector_field( 
        const DataPostprocessorInputs::Vector<dim> &inputs, 
        std::vector<Vector<double>> &computed_quantities) const override; 

      virtual std::vector<std::string> get_names() const override; 

      virtual std::vector< 
        DataComponentInterpretation::DataComponentInterpretation> 
      get_data_component_interpretation() const override; 

      virtual UpdateFlags get_needed_update_flags() const override; 

    private: 
      const bool do_schlieren_plot; 
    }; 
  }; 

  template <int dim> 
  const double EulerEquations<dim>::gas_gamma = 1.4; 

  template <int dim> 
  EulerEquations<dim>::Postprocessor::Postprocessor( 
    const bool do_schlieren_plot) 
    : do_schlieren_plot(do_schlieren_plot) 
  {} 

// 这是唯一值得评论的函数。在生成图形输出时，DataOut和相关的类将在每个单元格上调用这个函数，以获取每个正交点的值、梯度、Hessians和法向量（如果我们在处理面）。请注意，每个正交点的数据本身就是矢量值，即保守变量。我们在这里要做的是计算每个正交点上我们感兴趣的量。注意，为此我们可以忽略Hessians（"inputs.solution_hessians"）和法向量（"inputs.normals"）。

  template <int dim> 
  void EulerEquations<dim>::Postprocessor::evaluate_vector_field( 
    const DataPostprocessorInputs::Vector<dim> &inputs, 
    std::vector<Vector<double>> &               computed_quantities) const 
  { 

// 在函数的开始，让我们确保所有的变量都有正确的大小，这样我们就可以访问各个向量元素，而不必怀疑我们是否可能读或写无效的元素；我们还检查 <code>solution_gradients</code> 向量只包含我们真正需要的数据（系统知道这个，因为我们在下面的 <code>get_needed_update_flags()</code> 函数中这样说）。对于内向量，我们检查至少外向量的第一个元素有正确的内部大小。

    const unsigned int n_quadrature_points = inputs.solution_values.size(); 

    if (do_schlieren_plot == true) 
      Assert(inputs.solution_gradients.size() == n_quadrature_points, 
             ExcInternalError()); 

    Assert(computed_quantities.size() == n_quadrature_points, 
           ExcInternalError()); 

    Assert(inputs.solution_values[0].size() == n_components, 
           ExcInternalError()); 

    if (do_schlieren_plot == true) 
      { 
        Assert(computed_quantities[0].size() == dim + 2, ExcInternalError()); 
      } 
    else 
      { 
        Assert(computed_quantities[0].size() == dim + 1, ExcInternalError()); 
      } 

// 然后在所有的正交点上循环，在那里做我们的工作。这段代码应该是不言自明的。输出变量的顺序首先是 <code>dim</code> 速度，然后是压力，如果需要的话，还可以是SCHLIEREN图。请注意，我们尝试使用 <code>first_momentum_component</code> 和 <code>density_component</code> 的信息，对输入向量中的变量顺序进行通用处理。

    for (unsigned int q = 0; q < n_quadrature_points; ++q) 
      { 
        const double density = inputs.solution_values[q](density_component); 

        for (unsigned int d = 0; d < dim; ++d) 
          computed_quantities[q](d) = 
            inputs.solution_values[q](first_momentum_component + d) / density; 

        computed_quantities[q](dim) = 
          compute_pressure(inputs.solution_values[q]); 

        if (do_schlieren_plot == true) 
          computed_quantities[q](dim + 1) = 
            inputs.solution_gradients[q][density_component] * 
            inputs.solution_gradients[q][density_component]; 
      } 
  } 

  template <int dim> 
  std::vector<std::string> EulerEquations<dim>::Postprocessor::get_names() const 
  { 
    std::vector<std::string> names; 
    for (unsigned int d = 0; d < dim; ++d) 
      names.emplace_back("velocity"); 
    names.emplace_back("pressure"); 

    if (do_schlieren_plot == true) 
      names.emplace_back("schlieren_plot"); 

    return names; 
  } 

  template <int dim> 
  std::vector<DataComponentInterpretation::DataComponentInterpretation> 
  EulerEquations<dim>::Postprocessor::get_data_component_interpretation() const 
  { 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      interpretation(dim, 
                     DataComponentInterpretation::component_is_part_of_vector); 

    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 

    if (do_schlieren_plot == true) 
      interpretation.push_back( 
        DataComponentInterpretation::component_is_scalar); 

    return interpretation; 
  } 

  template <int dim> 
  UpdateFlags 
  EulerEquations<dim>::Postprocessor::get_needed_update_flags() const 
  { 
    if (do_schlieren_plot == true) 
      return update_values | update_gradients; 
    else 
      return update_values; 
  } 
// @sect3{Run time parameter handling}  

// 我们接下来的工作是定义一些包含运行时参数的类（例如求解器的公差、迭代次数、稳定参数等等）。我们可以在主类中完成这项工作，但我们将其与主类分开，以使程序更加模块化和易于阅读。所有与运行时参数有关的东西都在以下命名空间中，而程序逻辑则在主类中。

// 我们将把运行时参数分成几个独立的结构，我们将把这些结构全部放在一个命名空间  <code>Parameters</code>  中。在这些类中，有几个类将参数分组，用于单独的组，比如用于求解器、网格细化或输出。这些类中的每一个都有函数  <code>declare_parameters()</code>  和  <code>parse_parameters()</code>  ，分别在ParameterHandler对象中声明参数子段和条目，并从这样的对象中检索实际参数值。这些类在ParameterHandler的子段中声明它们的所有参数。

// 以下命名空间的最后一个类结合了前面所有的类，从它们派生出来，并负责处理输入文件顶层的一些条目，以及其他一些奇特的条目，这些条目在子段中太短了，不值得本身有一个结构。

// 这里值得指出的是一件事。下面这些类中没有一个构造函数可以初始化各种成员变量。不过这不是问题，因为我们将从输入文件中读取这些类中声明的所有变量（或者间接地：一个ParameterHandler对象将从那里读取，我们将从这个对象中获取数值），它们将以这种方式被初始化。如果输入文件中根本没有指定某个变量，这也不是问题。在这种情况下，ParameterHandler类将简单地采取默认值，这个默认值是在声明下面这些类的 <code>declare_parameters()</code> 函数中的一个条目时指定的。

  namespace Parameters 
  { 
// @sect4{Parameters::Solver}  

// 这些类中的第一个是关于线性内部求解器的参数。它提供的参数表明使用哪种求解器（GMRES作为一般非对称不定式系统的求解器，或稀疏直接求解器），要产生的输出量，以及各种调整阈值不完全LU分解（ILUT）的参数，我们使用它作为GMRES的预处理器。

// 特别是，ILUT需要以下参数。

// - ilut_fill：形成ILU分解时要增加的额外条目数

// - ilut_atol, ilut_rtol: 在形成预处理程序时，对于某些问题，不好的条件（或者只是运气不好）会导致预处理程序的条件很差。 因此，将对角线扰动添加到原始矩阵中，并为这个稍好的矩阵形成预处理程序会有帮助。 ATOL是一个绝对扰动，在形成预处理之前加到对角线上，RTOL是一个比例因子  $rtol \geq 1$  。

// - ilut_drop: ILUT将放弃任何幅度小于此值的数值。 这是一种管理该预处理程序所使用的内存量的方法。

// 每个参数的含义在  ParameterHandler::declare_entry  调用的第三个参数中也有简要说明  <code>declare_parameters()</code>  。

    struct Solver 
    { 
      enum SolverType 
      { 
        gmres, 
        direct 
      }; 
      SolverType solver; 

      enum OutputType 
      { 
        quiet, 
        verbose 
      }; 
      OutputType output; 

      double linear_residual; 
      int    max_iterations; 

      double ilut_fill; 
      double ilut_atol; 
      double ilut_rtol; 
      double ilut_drop; 

      static void declare_parameters(ParameterHandler &prm); 
      void        parse_parameters(ParameterHandler &prm); 
    }; 

    void Solver::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("linear solver"); 
      { 
        prm.declare_entry( 
          "output", 
          "quiet", 
          Patterns::Selection("quiet|verbose"), 
          "State whether output from solver runs should be printed. " 
          "Choices are <quiet|verbose>."); 
        prm.declare_entry("method", 
                          "gmres", 
                          Patterns::Selection("gmres|direct"), 
                          "The kind of solver for the linear system. " 
                          "Choices are <gmres|direct>."); 
        prm.declare_entry("residual", 
                          "1e-10", 
                          Patterns::Double(), 
                          "Linear solver residual"); 
        prm.declare_entry("max iters", 
                          "300", 
                          Patterns::Integer(), 
                          "Maximum solver iterations"); 
        prm.declare_entry("ilut fill", 
                          "2", 
                          Patterns::Double(), 
                          "Ilut preconditioner fill"); 
        prm.declare_entry("ilut absolute tolerance", 
                          "1e-9", 
                          Patterns::Double(), 
                          "Ilut preconditioner tolerance"); 
        prm.declare_entry("ilut relative tolerance", 
                          "1.1", 
                          Patterns::Double(), 
                          "Ilut relative tolerance"); 
        prm.declare_entry("ilut drop tolerance", 
                          "1e-10", 
                          Patterns::Double(), 
                          "Ilut drop tolerance"); 
      } 
      prm.leave_subsection(); 
    } 

    void Solver::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("linear solver"); 
      { 
        const std::string op = prm.get("output"); 
        if (op == "verbose") 
          output = verbose; 
        if (op == "quiet") 
          output = quiet; 

        const std::string sv = prm.get("method"); 
        if (sv == "direct") 
          solver = direct; 
        else if (sv == "gmres") 
          solver = gmres; 

        linear_residual = prm.get_double("residual"); 
        max_iterations  = prm.get_integer("max iters"); 
        ilut_fill       = prm.get_double("ilut fill"); 
        ilut_atol       = prm.get_double("ilut absolute tolerance"); 
        ilut_rtol       = prm.get_double("ilut relative tolerance"); 
        ilut_drop       = prm.get_double("ilut drop tolerance"); 
      } 
      prm.leave_subsection(); 
    } 

//  @sect4{Parameters::Refinement}  

// 同样的，这里有几个参数决定了网格如何被细化（以及是否要被细化）。关于冲击参数的具体作用，请看下面的网格细化函数。

    struct Refinement 
    { 
      bool   do_refine; 
      double shock_val; 
      double shock_levels; 

      static void declare_parameters(ParameterHandler &prm); 
      void        parse_parameters(ParameterHandler &prm); 
    }; 

    void Refinement::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("refinement"); 
      { 
        prm.declare_entry("refinement", 
                          "true", 
                          Patterns::Bool(), 
                          "Whether to perform mesh refinement or not"); 
        prm.declare_entry("refinement fraction", 
                          "0.1", 
                          Patterns::Double(), 
                          "Fraction of high refinement"); 
        prm.declare_entry("unrefinement fraction", 
                          "0.1", 
                          Patterns::Double(), 
                          "Fraction of low unrefinement"); 
        prm.declare_entry("max elements", 
                          "1000000", 
                          Patterns::Double(), 
                          "maximum number of elements"); 
        prm.declare_entry("shock value", 
                          "4.0", 
                          Patterns::Double(), 
                          "value for shock indicator"); 
        prm.declare_entry("shock levels", 
                          "3.0", 
                          Patterns::Double(), 
                          "number of shock refinement levels"); 
      } 
      prm.leave_subsection(); 
    } 

    void Refinement::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("refinement"); 
      { 
        do_refine    = prm.get_bool("refinement"); 
        shock_val    = prm.get_double("shock value"); 
        shock_levels = prm.get_double("shock levels"); 
      } 
      prm.leave_subsection(); 
    } 

//  @sect4{Parameters::Flux}  

// 接下来是关于通量修改的部分，使其更加稳定。特别是提供了两个选项来稳定Lax-Friedrichs通量：要么选择 $\mathbf{H}(\mathbf{a},\mathbf{b},\mathbf{n}) = \frac{1}{2}(\mathbf{F}(\mathbf{a})\cdot \mathbf{n} + \mathbf{F}(\mathbf{b})\cdot \mathbf{n} + \alpha (\mathbf{a} - \mathbf{b}))$ ，其中 $\alpha$ 是在输入文件中指定的一个固定数字，要么 $\alpha$ 是一个与网格有关的值。在后一种情况下，它被选择为 $\frac{h}{2\delta T}$ ，其中 $h$ 是施加流量的面的直径， $\delta T$ 是当前的时间步长。

    struct Flux 
    { 
      enum StabilizationKind 
      { 
        constant, 
        mesh_dependent 
      }; 
      StabilizationKind stabilization_kind; 

      double stabilization_value; 

      static void declare_parameters(ParameterHandler &prm); 
      void        parse_parameters(ParameterHandler &prm); 
    }; 

    void Flux::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("flux"); 
      { 
        prm.declare_entry( 
          "stab", 
          "mesh", 
          Patterns::Selection("constant|mesh"), 
          "Whether to use a constant stabilization parameter or " 
          "a mesh-dependent one"); 
        prm.declare_entry("stab value", 
                          "1", 
                          Patterns::Double(), 
                          "alpha stabilization"); 
      } 
      prm.leave_subsection(); 
    } 

    void Flux::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("flux"); 
      { 
        const std::string stab = prm.get("stab"); 
        if (stab == "constant") 
          stabilization_kind = constant; 
        else if (stab == "mesh") 
          stabilization_kind = mesh_dependent; 
        else 
          AssertThrow(false, ExcNotImplemented()); 

        stabilization_value = prm.get_double("stab value"); 
      } 
      prm.leave_subsection(); 
    } 

//  @sect4{Parameters::Output}  

// 然后是关于输出参数的部分。我们提供产生Schlieren图（密度的平方梯度，一种可视化冲击前沿的工具），以及图形输出的时间间隔，以防我们不希望每个时间步骤都有输出文件。

    struct Output 
    { 
      bool   schlieren_plot; 
      double output_step; 

      static void declare_parameters(ParameterHandler &prm); 
      void        parse_parameters(ParameterHandler &prm); 
    }; 

    void Output::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("output"); 
      { 
        prm.declare_entry("schlieren plot", 
                          "true", 
                          Patterns::Bool(), 
                          "Whether or not to produce schlieren plots"); 
        prm.declare_entry("step", 
                          "-1", 
                          Patterns::Double(), 
                          "Output once per this period"); 
      } 
      prm.leave_subsection(); 
    } 

    void Output::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("output"); 
      { 
        schlieren_plot = prm.get_bool("schlieren plot"); 
        output_step    = prm.get_double("step"); 
      } 
      prm.leave_subsection(); 
    } 

//  @sect4{Parameters::AllParameters}  

// 最后是将这一切结合起来的类。它自己声明了一些参数，主要是参数文件顶层的参数，以及一些太小的部分，以至于不值得有自己的类。它还包含了所有实际上与空间维度有关的东西，比如初始或边界条件。

// 因为这个类是由上面所有的类派生出来的，所以 <code>declare_parameters()</code> and <code>parse_parameters()</code> 函数也会调用基类的相应函数。

// 注意这个类也处理输入文件中指定的初始和边界条件的声明。为此，在这两种情况下，都有像 "w_0值 "这样的条目，它代表了 $x,y,z$ 方面的表达式，将初始或边界条件描述为一个公式，随后将由FunctionParser类来解析。类似的表达方式还有 "w_1"、"w_2 "等，表示欧拉系统的 <code>dim+2</code> 守恒变量。同样，我们允许在输入文件中最多使用 <code>max_n_boundaries</code> 个边界指标，这些边界指标中的每一个都可以与流入、流出或压力边界条件相关联，同质的边界条件要分别为每个组件和每个边界指标指定。

// 用来存储边界指标的数据结构有点复杂。它是一个 <code>max_n_boundaries</code> 元素的数组，表示将被接受的边界指标的范围。对于这个数组中的每个条目，我们在 <code>BoundaryCondition</code> 结构中存储一对数据：首先是一个大小为 <code>n_components</code> 的数组，对于解向量的每个分量，它表明它是流入、流出还是其他类型的边界，其次是一个FunctionParser对象，它一次描述了这个边界ID的解向量的所有分量。

//  <code>BoundaryCondition</code> 结构需要一个构造器，因为我们需要在构造时告诉函数解析器对象它要描述多少个向量分量。因此，这个初始化不能等到我们在后面的 <code>AllParameters::parse_parameters()</code> 中实际设置FunctionParser对象所代表的公式。

// 由于必须在构造时告诉Function对象其向量大小的同样原因，我们必须有一个 <code>AllParameters</code> 类的构造函数，至少要初始化另一个FunctionParser对象，即描述初始条件的对象。

    template <int dim> 
    struct AllParameters : public Solver, 
                           public Refinement, 
                           public Flux, 
                           public Output 
    { 
      static const unsigned int max_n_boundaries = 10; 

      struct BoundaryConditions 
      { 
        std::array<typename EulerEquations<dim>::BoundaryKind, 
                   EulerEquations<dim>::n_components> 
          kind; 

        FunctionParser<dim> values; 

        BoundaryConditions(); 
      }; 

      AllParameters(); 

      double diffusion_power; 

      double time_step, final_time; 
      double theta; 
      bool   is_stationary; 

      std::string mesh_filename; 

 
      BoundaryConditions  boundary_conditions[max_n_boundaries]; 

      static void declare_parameters(ParameterHandler &prm); 
      void        parse_parameters(ParameterHandler &prm); 
    }; 

    template <int dim> 
    AllParameters<dim>::BoundaryConditions::BoundaryConditions() 
      : values(EulerEquations<dim>::n_components) 
    { 
      std::fill(kind.begin(), 
                kind.end(), 
                EulerEquations<dim>::no_penetration_boundary); 
    } 

    template <int dim> 
    AllParameters<dim>::AllParameters() 
      : diffusion_power(0.) 
      , time_step(1.) 
      , final_time(1.) 
      , theta(.5) 
      , is_stationary(true) 
      , initial_conditions(EulerEquations<dim>::n_components) 
    {} 

    template <int dim> 
    void AllParameters<dim>::declare_parameters(ParameterHandler &prm) 
    { 
      prm.declare_entry("mesh", 
                        "grid.inp", 
                        Patterns::Anything(), 
                        "input file name"); 

      prm.declare_entry("diffusion power", 
                        "2.0", 
                        Patterns::Double(), 
                        "power of mesh size for diffusion"); 

      prm.enter_subsection("time stepping"); 
      { 
        prm.declare_entry("time step", 
                          "0.1", 
                          Patterns::Double(0), 
                          "simulation time step"); 
        prm.declare_entry("final time", 
                          "10.0", 
                          Patterns::Double(0), 
                          "simulation end time"); 
        prm.declare_entry("theta scheme value", 
                          "0.5", 
                          Patterns::Double(0, 1), 
                          "value for theta that interpolated between explicit " 
                          "Euler (theta=0), Crank-Nicolson (theta=0.5), and " 
                          "implicit Euler (theta=1)."); 
      } 
      prm.leave_subsection(); 

      for (unsigned int b = 0; b < max_n_boundaries; ++b) 
        { 
          prm.enter_subsection("boundary_" + Utilities::int_to_string(b)); 
          { 
            prm.declare_entry("no penetration", 
                              "false", 
                              Patterns::Bool(), 
                              "whether the named boundary allows gas to " 
                              "penetrate or is a rigid wall"); 

            for (unsigned int di = 0; di < EulerEquations<dim>::n_components; 
                 ++di) 
              { 
                prm.declare_entry("w_" + Utilities::int_to_string(di), 
                                  "outflow", 
                                  Patterns::Selection( 
                                    "inflow|outflow|pressure"), 
                                  "<inflow|outflow|pressure>"); 

                prm.declare_entry("w_" + Utilities::int_to_string(di) + 
                                    " value", 
                                  "0.0", 
                                  Patterns::Anything(), 
                                  "expression in x,y,z"); 
              } 
          } 
          prm.leave_subsection(); 
        } 

      prm.enter_subsection("initial condition"); 
      { 
        for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di) 
          prm.declare_entry("w_" + Utilities::int_to_string(di) + " value", 
                            "0.0", 
                            Patterns::Anything(), 
                            "expression in x,y,z"); 
      } 
      prm.leave_subsection(); 

      Parameters::Solver::declare_parameters(prm); 
      Parameters::Refinement::declare_parameters(prm); 
      Parameters::Flux::declare_parameters(prm); 
      Parameters::Output::declare_parameters(prm); 
    } 

    template <int dim> 
    void AllParameters<dim>::parse_parameters(ParameterHandler &prm) 
    { 
      mesh_filename   = prm.get("mesh"); 
      diffusion_power = prm.get_double("diffusion power"); 

      prm.enter_subsection("time stepping"); 
      { 
        time_step = prm.get_double("time step"); 
        if (time_step == 0) 
          { 
            is_stationary = true; 
            time_step     = 1.0; 
            final_time    = 1.0; 
          } 
        else 
          is_stationary = false; 

        final_time = prm.get_double("final time"); 
        theta      = prm.get_double("theta scheme value"); 
      } 
      prm.leave_subsection(); 

      for (unsigned int boundary_id = 0; boundary_id < max_n_boundaries; 
           ++boundary_id) 
        { 
          prm.enter_subsection("boundary_" + 
                               Utilities::int_to_string(boundary_id)); 
          { 
            std::vector<std::string> expressions( 
              EulerEquations<dim>::n_components, "0.0"); 

            const bool no_penetration = prm.get_bool("no penetration"); 

            for (unsigned int di = 0; di < EulerEquations<dim>::n_components; 
                 ++di) 
              { 
                const std::string boundary_type = 
                  prm.get("w_" + Utilities::int_to_string(di)); 

                if ((di < dim) && (no_penetration == true)) 
                  boundary_conditions[boundary_id].kind[di] = 
                    EulerEquations<dim>::no_penetration_boundary; 
                else if (boundary_type == "inflow") 
                  boundary_conditions[boundary_id].kind[di] = 
                    EulerEquations<dim>::inflow_boundary; 
                else if (boundary_type == "pressure") 
                  boundary_conditions[boundary_id].kind[di] = 
                    EulerEquations<dim>::pressure_boundary; 
                else if (boundary_type == "outflow") 
                  boundary_conditions[boundary_id].kind[di] = 
                    EulerEquations<dim>::outflow_boundary; 
                else 
                  AssertThrow(false, ExcNotImplemented()); 

                expressions[di] = 
                  prm.get("w_" + Utilities::int_to_string(di) + " value"); 
              } 

            boundary_conditions[boundary_id].values.initialize( 
              FunctionParser<dim>::default_variable_names(), 
              expressions, 
              std::map<std::string, double>()); 
          } 
          prm.leave_subsection(); 
        } 

      prm.enter_subsection("initial condition"); 
      { 
        std::vector<std::string> expressions(EulerEquations<dim>::n_components, 
                                             "0.0"); 
        for (unsigned int di = 0; di < EulerEquations<dim>::n_components; di++) 
          expressions[di] = 
            prm.get("w_" + Utilities::int_to_string(di) + " value"); 
        initial_conditions.initialize( 
          FunctionParser<dim>::default_variable_names(), 
          expressions, 
          std::map<std::string, double>()); 
      } 
      prm.leave_subsection(); 

      Parameters::Solver::parse_parameters(prm); 
      Parameters::Refinement::parse_parameters(prm); 
      Parameters::Flux::parse_parameters(prm); 
      Parameters::Output::parse_parameters(prm); 
    } 
  } // namespace Parameters 

//  @sect3{Conservation law class}  

// 这里终于出现了一个类，它实际上是对我们上面定义的所有欧拉方程和参数的具体内容做了一些事情。公共接口与以往基本相同（构造函数现在需要一个文件名来读取参数，这个文件名在命令行中传递）。私有函数接口也与通常的安排非常相似， <code>assemble_system</code> 函数被分成三个部分：一个包含所有单元的主循环，然后分别调用另外两个单元和面的积分。

  template <int dim> 
  class ConservationLaw 
  { 
  public: 
    ConservationLaw(const char *input_filename); 
    void run(); 

  private: 
    void setup_system(); 

    void assemble_system(); 
    void assemble_cell_term(const FEValues<dim> &                       fe_v, 
                            const std::vector<types::global_dof_index> &dofs); 
    void assemble_face_term( 
      const unsigned int                          face_no, 
      const FEFaceValuesBase<dim> &               fe_v, 
      const FEFaceValuesBase<dim> &               fe_v_neighbor, 
      const std::vector<types::global_dof_index> &dofs, 
      const std::vector<types::global_dof_index> &dofs_neighbor, 
      const bool                                  external_face, 
      const unsigned int                          boundary_id, 
      const double                                face_diameter); 

    std::pair<unsigned int, double> solve(Vector<double> &solution); 

    void compute_refinement_indicators(Vector<double> &indicator) const; 
    void refine_grid(const Vector<double> &indicator); 

    void output_results() const; 

// 前面的几个成员变量也相当标准。请注意，我们定义了一个映射对象，在整个程序中组装术语时使用（我们将把它交给每个FEValues和FEFaceValues对象）；我们使用的映射只是标准的 $Q_1$ 映射--换句话说，没有什么花哨的东西--但是在这里声明一个映射并在整个程序中使用它将使以后在有必要时改变它更加简单。事实上，这一点相当重要：众所周知，对于欧拉方程的跨音速模拟，如果边界近似没有足够高的阶数，计算就不会收敛，即使像 $h\rightarrow 0$ 那样。

    Triangulation<dim>   triangulation; 
    const MappingQ1<dim> mapping; 

    const FESystem<dim> fe; 
    DoFHandler<dim>     dof_handler; 

    const QGauss<dim>     quadrature; 
    const QGauss<dim - 1> face_quadrature; 

// 接下来是一些数据向量，对应于前一个时间步骤的解决方案（ <code>old_solution</code> ），当前解决方案的最佳猜测（ <code>current_solution</code> ；我们说<i>guess</i>是因为计算它的牛顿迭代可能还没有收敛，而 <code>old_solution</code> 是指前一个时间步骤的完全收敛的最终结果），以及下一个时间步骤的解决方案的预测器，通过将当前和之前的解决方案推算到未来一个时间步骤计算。

    Vector<double> old_solution; 
    Vector<double> current_solution; 
    Vector<double> predictor; 

    Vector<double> right_hand_side; 

// 这一组最后的成员变量（除了最下面的保存所有运行时参数的对象和一个屏幕输出流，它只在要求verbose输出的情况下打印一些东西）处理我们在这个程序中与Trilinos库的接口，该库为我们提供了线性求解器。与在 step-17 和 step-18 中包括PETSc矩阵类似，我们需要做的是创建一个Trilinos稀疏矩阵而不是标准的deal.II类。该系统矩阵在每个牛顿步骤中被用于雅各布系数。由于我们不打算并行运行这个程序（不过用Trilinos数据结构也不难），所以我们不必考虑其他的事情，比如分配自由度。

    TrilinosWrappers::SparseMatrix system_matrix; 

    Parameters::AllParameters<dim> parameters; 
    ConditionalOStream             verbose_cout; 
  }; 
// @sect4{ConservationLaw::ConservationLaw}  

// 关于构造函数没有什么可说的。基本上，它读取输入文件并将解析后的值填充到参数对象中。

  template <int dim> 
  ConservationLaw<dim>::ConservationLaw(const char *input_filename) 
    : mapping() 
    , fe(FE_Q<dim>(1), EulerEquations<dim>::n_components) 
    , dof_handler(triangulation) 
    , quadrature(fe.degree + 1) 
    , face_quadrature(fe.degree + 1) 
    , verbose_cout(std::cout, false) 
  { 
    ParameterHandler prm; 
    Parameters::AllParameters<dim>::declare_parameters(prm); 

    prm.parse_input(input_filename); 
    parameters.parse_parameters(prm); 

    verbose_cout.set_condition(parameters.output == 
                               Parameters::Solver::verbose); 
  } 

//  @sect4{ConservationLaw::setup_system}  

// 每次改变网格时都会调用下面这个（简单的）函数。它所做的就是根据我们在之前所有的教程程序中生成的稀疏模式来调整特里诺斯矩阵的大小。

  template <int dim> 
  void ConservationLaw<dim>::setup_system() 
  { 
    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 

    system_matrix.reinit(dsp); 
  } 
// @sect4{ConservationLaw::assemble_system}  

// 这个和下面两个函数是这个程序的核心。它们将牛顿方法应用于非线性守恒方程组所产生的线性系统组合起来。

// 第一个函数将所有的装配部件放在一个例行程序中，为每个单元格/面分配正确的部件。 对这些对象的装配的实际实现是在以下函数中完成的。

// 在函数的顶部，我们做了常规的内务处理：分配FEValues、FEFaceValues和FESubfaceValues对象，这些对象对单元、面和子面（在不同细化级别的相邻单元的情况下）进行积分。请注意，我们并不需要所有这些对象的所有信息（如值、梯度或正交点的实际位置），所以我们只让FEValues类通过指定最小的UpdateFlags集来获得实际需要的信息。例如，当使用邻接单元的FEFaceValues对象时，我们只需要形状值。给定一个特定的面，正交点和 <code>JxW</code> 值与当前单元格相同，法向量已知为当前单元格的法向量的负值。

  template <int dim> 
  void ConservationLaw<dim>::assemble_system() 
  { 
    const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell(); 

    std::vector<types::global_dof_index> dof_indices(dofs_per_cell); 
    std::vector<types::global_dof_index> dof_indices_neighbor(dofs_per_cell); 

    const UpdateFlags update_flags = update_values | update_gradients | 
                                     update_quadrature_points | 
                                     update_JxW_values, 
                      face_update_flags = 
                        update_values | update_quadrature_points | 
                        update_JxW_values | update_normal_vectors, 
                      neighbor_face_update_flags = update_values; 

    FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags); 
    FEFaceValues<dim>    fe_v_face(mapping, 
                                fe, 
                                face_quadrature, 
                                face_update_flags); 
    FESubfaceValues<dim> fe_v_subface(mapping, 
                                      fe, 
                                      face_quadrature, 
                                      face_update_flags); 
    FEFaceValues<dim>    fe_v_face_neighbor(mapping, 
                                         fe, 
                                         face_quadrature, 
                                         neighbor_face_update_flags); 
    FESubfaceValues<dim> fe_v_subface_neighbor(mapping, 
                                               fe, 
                                               face_quadrature, 
                                               neighbor_face_update_flags); 

// 然后循环所有单元，初始化当前单元的FEValues对象，并调用在此单元上组装问题的函数。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_v.reinit(cell); 
        cell->get_dof_indices(dof_indices); 

        assemble_cell_term(fe_v, dof_indices); 

// 然后在这个单元的所有面上循环。 如果一个面是外部边界的一部分，那么就在那里集合边界条件（ <code>assemble_face_terms</code> 的第五个参数表示我们是在外部面还是内部面工作；如果是外部面，表示邻居自由度指数的第四个参数被忽略，所以我们传递一个空向量）。

        for (const auto face_no : cell->face_indices()) 
          if (cell->at_boundary(face_no)) 
            { 
              fe_v_face.reinit(cell, face_no); 
              assemble_face_term(face_no, 
                                 fe_v_face, 
                                 fe_v_face, 
                                 dof_indices, 
                                 std::vector<types::global_dof_index>(), 
                                 true, 
                                 cell->face(face_no)->boundary_id(), 
                                 cell->face(face_no)->diameter()); 
            } 

// 另一种情况是，我们正在处理一个内部面。我们需要区分两种情况：这是在同一细化水平的两个单元之间的正常面，和在不同细化水平的两个单元之间的面。

// 在第一种情况下，我们不需要做什么：我们使用的是连续有限元，在这种情况下，面条款不会出现在双线性表格中。第二种情况通常也不会导致面条款，如果我们强烈地执行悬挂节点约束的话（就像到目前为止，只要我们使用连续有限元的所有教程程序一样--这种执行是由AffineConstraints类和 DoFTools::make_hanging_node_constraints). 一起完成的）。 然而，在当前程序中，我们选择在不同细化水平的单元之间的面弱地执行连续性，原因有二。(i)因为我们可以，更重要的是(ii)因为我们必须通过AffineConstraints类的操作，将我们用来计算牛顿矩阵元素的自动微分穿起来。这是有可能的，但不是微不足道的，所以我们选择了这种替代方法。

// 需要决定的是我们坐在两个不同细化水平的单元之间的接口的哪一边。

// 让我们先来看看邻居更精细的情况。然后，我们必须在当前单元格的面的子代上循环，并在每个子代上进行整合。我们在代码中加入了几个断言，以确保我们试图找出邻居的哪个子面与当前单元格的某个子面重合的推理是正确的--有点防御性的编程永远不会有坏处。

// 然后我们调用对面进行整合的函数；由于这是一个内部面，第五个参数是假的，第六个参数被忽略了，所以我们再次传递一个无效的值。

          else 
            { 
              if (cell->neighbor(face_no)->has_children()) 
                { 
                  const unsigned int neighbor2 = 
                    cell->neighbor_of_neighbor(face_no); 

                  for (unsigned int subface_no = 0; 
                       subface_no < cell->face(face_no)->n_children(); 
                       ++subface_no) 
                    { 
                      const typename DoFHandler<dim>::active_cell_iterator 
                        neighbor_child = 
                          cell->neighbor_child_on_subface(face_no, subface_no); 

                      Assert(neighbor_child->face(neighbor2) == 
                               cell->face(face_no)->child(subface_no), 
                             ExcInternalError()); 
                      Assert(neighbor_child->is_active(), ExcInternalError()); 

                      fe_v_subface.reinit(cell, face_no, subface_no); 
                      fe_v_face_neighbor.reinit(neighbor_child, neighbor2); 

                      neighbor_child->get_dof_indices(dof_indices_neighbor); 

                      assemble_face_term( 
                        face_no, 
                        fe_v_subface, 
                        fe_v_face_neighbor, 
                        dof_indices, 
                        dof_indices_neighbor, 
                        false, 
                        numbers::invalid_unsigned_int, 
                        neighbor_child->face(neighbor2)->diameter()); 
                    } 
                } 

// 我们必须关注的另一种可能性是邻居是否比当前单元更粗（特别是，由于每个面只有一个悬挂节点的通常限制，邻居必须正好比当前单元更粗一级，这是我们用断言检查的）。同样，我们在这个接口上进行整合。

              else if (cell->neighbor(face_no)->level() != cell->level()) 
                { 
                  const typename DoFHandler<dim>::cell_iterator neighbor = 
                    cell->neighbor(face_no); 
                  Assert(neighbor->level() == cell->level() - 1, 
                         ExcInternalError()); 

                  neighbor->get_dof_indices(dof_indices_neighbor); 

                  const std::pair<unsigned int, unsigned int> faceno_subfaceno = 
                    cell->neighbor_of_coarser_neighbor(face_no); 
                  const unsigned int neighbor_face_no = faceno_subfaceno.first, 
                                     neighbor_subface_no = 
                                       faceno_subfaceno.second; 

                  Assert(neighbor->neighbor_child_on_subface( 
                           neighbor_face_no, neighbor_subface_no) == cell, 
                         ExcInternalError()); 

                  fe_v_face.reinit(cell, face_no); 
                  fe_v_subface_neighbor.reinit(neighbor, 
                                               neighbor_face_no, 
                                               neighbor_subface_no); 

                  assemble_face_term(face_no, 
                                     fe_v_face, 
                                     fe_v_subface_neighbor, 
                                     dof_indices, 
                                     dof_indices_neighbor, 
                                     false, 
                                     numbers::invalid_unsigned_int, 
                                     cell->face(face_no)->diameter()); 
                } 
            } 
      } 
  } 
// @sect4{ConservationLaw::assemble_cell_term}  

// 这个函数通过计算残差的单元部分来组装单元项，将其负数加到右手边的向量上，并将其相对于局部变量的导数加到雅各布系数（即牛顿矩阵）上。回顾一下，单元格对残差的贡献为 $R_i = \left(\frac{\mathbf{w}^{k}_{n+1} - \mathbf{w}_n}{\delta t} , \mathbf{z}_i \right)_K $ 。
// $ + \theta \mathbf{B}(\mathbf{w}^{k}_{n+1})(\mathbf{z}_i)_K $  
// $ + (1-\theta) \mathbf{B}(\mathbf{w}_{n}) (\mathbf{z}_i)_K $ ，其中 $\mathbf{B}(\mathbf{w})(\mathbf{z}_i)_K = - \left(\mathbf{F}(\mathbf{w}),\nabla\mathbf{z}_i\right)_K $  。
// $ + h^{\eta}(\nabla \mathbf{w} , \nabla \mathbf{z}_i)_K $  
// $ - (\mathbf{G}(\mathbf {w}), \mathbf{z}_i)_K $ 为 $\mathbf{w} = \mathbf{w}^k_{n+1}$ 和 $\mathbf{w} = \mathbf{w}_{n}$  ， $\mathbf{z}_i$ 为 $i$ 的第1个向量值测试函数。  此外，标量积 $\left(\mathbf{F}(\mathbf{w}), \nabla\mathbf{z}_i\right)_K$ 可以理解为 $\int_K \sum_{c=1}^{\text{n\_components}}  \sum_{d=1}^{\text{dim}} \mathbf{F}(\mathbf{w})_{cd} \frac{\partial z^c_i}{x_d}$ ，其中 $z^c_i$ 是 $i$ 第1个测试函数的 $c$ 分量。

// 在这个函数的顶部，我们做了一些常规的内务工作，即分配一些我们以后需要的局部变量。特别是，我们将分配一些变量来保存 $k$ 次牛顿迭代后的当前解 $W_{n+1}^k$ （变量 <code>W</code> ）和上一时间步长的解 $W_{n}$ （变量 <code>W_old</code> ）的值。

// 除此以外，我们还需要当前变量的梯度。 我们必须计算这些是有点遗憾的，我们几乎不需要。 一个简单的守恒定律的好处是，通量一般不涉及任何梯度。 然而，我们确实需要这些梯度，用于扩散稳定化。

// 我们存储这些变量的实际格式需要一些解释。首先，我们需要解向量的 <code>EulerEquations::n_components</code> 分量在每个正交点的数值。这就构成了一个二维表，我们使用deal.II的表类（这比 <code>std::vector@<std::vector@<T@> @></code> 更有效，因为它只需要分配一次内存，而不是为外向量的每个元素分配一次）。同样地，梯度是一个三维表，Table类也支持。

// 其次，我们想使用自动微分。为此，我们使用 Sacado::Fad::DFad 模板来计算所有我们想计算导数的变量。这包括当前解和正交点的梯度（是自由度的线性组合），以及由它们计算出来的所有东西，如残差，但不包括前一个时间步长的解。这些变量都可以在函数的第一部分找到，同时还有一个变量，我们将用它来存储残差的一个分量的导数。

  template <int dim> 
  void ConservationLaw<dim>::assemble_cell_term( 
    const FEValues<dim> &                       fe_v, 
    const std::vector<types::global_dof_index> &dof_indices) 
  { 
    const unsigned int dofs_per_cell = fe_v.dofs_per_cell; 
    const unsigned int n_q_points    = fe_v.n_quadrature_points; 

    Table<2, Sacado::Fad::DFad<double>> W(n_q_points, 
                                          EulerEquations<dim>::n_components); 

    Table<2, double> W_old(n_q_points, EulerEquations<dim>::n_components); 

    Table<3, Sacado::Fad::DFad<double>> grad_W( 
      n_q_points, EulerEquations<dim>::n_components, dim); 

    Table<3, double> grad_W_old(n_q_points, 
                                EulerEquations<dim>::n_components, 
                                dim); 

    std::vector<double> residual_derivatives(dofs_per_cell); 

// 接下来，我们必须定义自变量，我们将尝试通过解决一个牛顿步骤来确定自变量。这些自变量是局部自由度的值，我们在这里提取。

    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values( 
      dofs_per_cell); 
    for (unsigned int i = 0; i < dofs_per_cell; ++i) 
      independent_local_dof_values[i] = current_solution(dof_indices[i]); 

// 下一步包含了所有的魔法：我们宣布自分变量的一个子集为独立自由度，而所有其他的变量仍然是依存函数。这些正是刚刚提取的局部自由度。所有引用它们的计算（无论是直接还是间接）都将积累与这些变量有关的敏感度。

// 为了将这些变量标记为独立变量，下面的方法可以起到作用，将 <code>independent_local_dof_values[i]</code> 标记为总共 <code>dofs_per_cell</code> 中的 $i$ 个独立变量。

    for (unsigned int i = 0; i < dofs_per_cell; ++i) 
      independent_local_dof_values[i].diff(i, dofs_per_cell); 

// 在所有这些声明之后，让我们实际计算一些东西。首先， <code>W</code>, <code>W_old</code>, <code>grad_W</code> 和 <code>grad_W_old</code> 的值，我们可以通过使用公式 $W(x_q)=\sum_i \mathbf W_i \Phi_i(x_q)$ 从局部DoF值计算出来，其中 $\mathbf W_i$ 是解向量（局部部分）的第 $i$ 项，而 $\Phi_i(x_q)$ 是在正交点 $x_q$ 评估的第 $i$ 个矢量值的形状函数的值。梯度可以用类似的方法来计算。

// 理想情况下，我们可以通过调用类似 FEValues::get_function_values 和 FEValues::get_function_gradients, 的东西来计算这些信息，但是由于（i）我们必须为此扩展FEValues类，以及（ii）我们不想让整个 <code>old_solution</code> 矢量fad类型，只有局部单元变量，我们明确编码上面的循环。在这之前，我们增加一个循环，将所有的fad变量初始化为零。

    for (unsigned int q = 0; q < n_q_points; ++q) 
      for (unsigned int c = 0; c < EulerEquations<dim>::n_components; ++c) 
        { 
          W[q][c]     = 0; 
          W_old[q][c] = 0; 
          for (unsigned int d = 0; d < dim; ++d) 
            { 
              grad_W[q][c][d]     = 0; 
              grad_W_old[q][c][d] = 0; 
            } 
        } 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          const unsigned int c = 
            fe_v.get_fe().system_to_component_index(i).first; 

          W[q][c] += independent_local_dof_values[i] * 
                     fe_v.shape_value_component(i, q, c); 
          W_old[q][c] += 
            old_solution(dof_indices[i]) * fe_v.shape_value_component(i, q, c); 

          for (unsigned int d = 0; d < dim; d++) 
            { 
              grad_W[q][c][d] += independent_local_dof_values[i] * 
                                 fe_v.shape_grad_component(i, q, c)[d]; 
              grad_W_old[q][c][d] += old_solution(dof_indices[i]) * 
                                     fe_v.shape_grad_component(i, q, c)[d]; 
            } 
        } 

// 接下来，为了计算单元贡献，我们需要在所有正交点评估 $\mathbf{F}({\mathbf w}^k_{n+1})$  ,  $\mathbf{G}({\mathbf w}^k_{n+1})$  和  $\mathbf{F}({\mathbf w}_n)$  ,  $\mathbf{G}({\mathbf w}_n)$  。为了存储这些，我们还需要分配一点内存。请注意，我们以自分变量的方式计算通量矩阵和右手边，这样以后就可以很容易地从中计算出雅各布贡献。

    std::vector<ndarray<Sacado::Fad::DFad<double>, 
                        EulerEquations<dim>::n_components, 
                        dim>> 
      flux(n_q_points); 

    std::vector<ndarray<double, EulerEquations<dim>::n_components, dim>> 
      flux_old(n_q_points); 

 
      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>> 
      forcing(n_q_points); 

    std::vector<std::array<double, EulerEquations<dim>::n_components>> 
      forcing_old(n_q_points); 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        EulerEquations<dim>::compute_flux_matrix(W_old[q], flux_old[q]); 
        EulerEquations<dim>::compute_forcing_vector(W_old[q], forcing_old[q]); 
        EulerEquations<dim>::compute_flux_matrix(W[q], flux[q]); 
        EulerEquations<dim>::compute_forcing_vector(W[q], forcing[q]); 
      } 

// 我们现在已经有了所有的部件，所以进行组装。 我们有一个通过系统组件的外循环，和一个通过正交点的内循环，在那里我们积累了对 $i$ 的残差 $R_i$ 的贡献。这个残差的一般公式在引言和本函数的顶部给出。然而，考虑到  $i$  第三个（矢量值）测试函数  $\mathbf{z}_i$  实际上只有一个非零分量（关于这个主题的更多信息可以在  @ref  矢量值模块中找到），我们可以把它简化一下。它将由下面的变量 <code>component_i</code> 表示。有了这个，残差项可以重新写成
// @f{eqnarray*}
//  R_i &=&
//  \left(\frac{(\mathbf{w}_{n+1} -
//  \mathbf{w}_n)_{\text{component\_i}}}{\delta
//  t},(\mathbf{z}_i)_{\text{component\_i}}\right)_K
//  \\ &-& \sum_{d=1}^{\text{dim}} \left(  \theta \mathbf{F}
//  ({\mathbf{w}^k_{n+1}})_{\text{component\_i},d} + (1-\theta)
//  \mathbf{F} ({\mathbf{w}_{n}})_{\text{component\_i},d}  ,
//  \frac{\partial(\mathbf{z}_i)_{\text{component\_i}}} {\partial
//  x_d}\right)_K
//  \\ &+& \sum_{d=1}^{\text{dim}} h^{\eta} \left( \theta \frac{\partial
//  (\mathbf{w}^k_{n+1})_{\text{component\_i}}}{\partial x_d} + (1-\theta)
//  \frac{\partial (\mathbf{w}_n)_{\text{component\_i}}}{\partial x_d} ,
//  \frac{\partial (\mathbf{z}_i)_{\text{component\_i}}}{\partial x_d}
//  \right)_K
//  \\ &-& \left( \theta\mathbf{G}({\mathbf{w}^k_n+1} )_{\text{component\_i}}
//  + (1-\theta)\mathbf{G}({\mathbf{w}_n})_{\text{component\_i}} ,
//  (\mathbf{z}_i)_{\text{component\_i}} \right)_K ,
//  @f}
//  ，其中积分可以理解为通过对正交点求和来评估。

// 我们最初对残差的所有贡献进行正向求和，这样我们就不需要对雅各布项进行负数。 然后，当我们对 <code>right_hand_side</code> 矢量进行求和时，我们就否定了这个残差。

    for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
      { 
        Sacado::Fad::DFad<double> R_i = 0; 

        const unsigned int component_i = 
          fe_v.get_fe().system_to_component_index(i).first; 

// 每一行（i）的残差将被累积到这个fad变量中。 在这一行的装配结束时，我们将查询这个变量的敏感度，并将其加入到雅各布系数中。

        for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point) 
          { 
            if (parameters.is_stationary == false) 
              R_i += 1.0 / parameters.time_step * 
                     (W[point][component_i] - W_old[point][component_i]) * 
                     fe_v.shape_value_component(i, point, component_i) * 
                     fe_v.JxW(point); 

            for (unsigned int d = 0; d < dim; d++) 
              R_i -= 
                (parameters.theta * flux[point][component_i][d] + 
                 (1.0 - parameters.theta) * flux_old[point][component_i][d]) * 
                fe_v.shape_grad_component(i, point, component_i)[d] * 
                fe_v.JxW(point); 

            for (unsigned int d = 0; d < dim; d++) 
              R_i += 
                1.0 * 
                std::pow(fe_v.get_cell()->diameter(), 
                         parameters.diffusion_power) * 
                (parameters.theta * grad_W[point][component_i][d] + 
                 (1.0 - parameters.theta) * grad_W_old[point][component_i][d]) * 
                fe_v.shape_grad_component(i, point, component_i)[d] * 
                fe_v.JxW(point); 

            R_i -= 
              (parameters.theta * forcing[point][component_i] + 
               (1.0 - parameters.theta) * forcing_old[point][component_i]) * 
              fe_v.shape_value_component(i, point, component_i) * 
              fe_v.JxW(point); 
          } 

// 在循环结束时，我们必须将敏感度加到矩阵上，并从右手边减去残差。Trilinos FAD数据类型让我们可以使用  <code>R_i.fastAccessDx(k)</code>  访问导数，所以我们将数据存储在一个临时数组中。然后，这些关于整行本地道夫的信息被一次性添加到特里诺斯矩阵中（支持我们选择的数据类型）。

        for (unsigned int k = 0; k < dofs_per_cell; ++k) 
          residual_derivatives[k] = R_i.fastAccessDx(k); 
        system_matrix.add(dof_indices[i], dof_indices, residual_derivatives); 
        right_hand_side(dof_indices[i]) -= R_i.val(); 
      } 
  } 
// @sect4{ConservationLaw::assemble_face_term}  

// 在这里，我们做的事情与前面的函数基本相同。在顶部，我们引入自变量。因为如果我们在两个单元格之间的内部面上工作，也会使用当前的函数，所以自变量不仅是当前单元格上的自由度，而且在内部面上的情况下，也是邻近单元格上的自由度。

  template <int dim> 
  void ConservationLaw<dim>::assemble_face_term( 
    const unsigned int                          face_no, 
    const FEFaceValuesBase<dim> &               fe_v, 
    const FEFaceValuesBase<dim> &               fe_v_neighbor, 
    const std::vector<types::global_dof_index> &dof_indices, 
    const std::vector<types::global_dof_index> &dof_indices_neighbor, 
    const bool                                  external_face, 
    const unsigned int                          boundary_id, 
    const double                                face_diameter) 
  { 
    const unsigned int n_q_points    = fe_v.n_quadrature_points; 
    const unsigned int dofs_per_cell = fe_v.dofs_per_cell; 

    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values( 
      dofs_per_cell), 
      independent_neighbor_dof_values(external_face == false ? dofs_per_cell : 
                                                               0); 

    const unsigned int n_independent_variables = 
      (external_face == false ? 2 * dofs_per_cell : dofs_per_cell); 

    for (unsigned int i = 0; i < dofs_per_cell; i++) 
      { 
        independent_local_dof_values[i] = current_solution(dof_indices[i]); 
        independent_local_dof_values[i].diff(i, n_independent_variables); 
      } 

    if (external_face == false) 
      for (unsigned int i = 0; i < dofs_per_cell; i++) 
        { 
          independent_neighbor_dof_values[i] = 
            current_solution(dof_indices_neighbor[i]); 
          independent_neighbor_dof_values[i].diff(i + dofs_per_cell, 
                                                  n_independent_variables); 
        } 

// 接下来，我们需要定义保守变量  ${\mathbf W}$  在面的这一侧（  $ {\mathbf W}^+$  ）和另一侧（  ${\mathbf W}^-$  ）的值，对于  ${\mathbf W} = {\mathbf W}^k_{n+1}$  和  ${\mathbf W} = {\mathbf W}_n$  。"这一边 "的值可以用与前一个函数完全相同的方式计算，但注意 <code>fe_v</code> 变量现在是FEFaceValues或FESubfaceValues的类型。

    Table<2, Sacado::Fad::DFad<double>> Wplus( 
      n_q_points, EulerEquations<dim>::n_components), 
      Wminus(n_q_points, EulerEquations<dim>::n_components); 
    Table<2, double> Wplus_old(n_q_points, EulerEquations<dim>::n_components), 
      Wminus_old(n_q_points, EulerEquations<dim>::n_components); 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          const unsigned int component_i = 
            fe_v.get_fe().system_to_component_index(i).first; 
          Wplus[q][component_i] += 
            independent_local_dof_values[i] * 
            fe_v.shape_value_component(i, q, component_i); 
          Wplus_old[q][component_i] += 
            old_solution(dof_indices[i]) * 
            fe_v.shape_value_component(i, q, component_i); 
        } 

// 计算 "对立面 "就比较复杂了。如果这是一个内部面，我们可以像上面那样，简单地使用邻居的独立变量来计算它。

    if (external_face == false) 
      { 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const unsigned int component_i = 
                fe_v_neighbor.get_fe().system_to_component_index(i).first; 
              Wminus[q][component_i] += 
                independent_neighbor_dof_values[i] * 
                fe_v_neighbor.shape_value_component(i, q, component_i); 
              Wminus_old[q][component_i] += 
                old_solution(dof_indices_neighbor[i]) * 
                fe_v_neighbor.shape_value_component(i, q, component_i); 
            } 
      } 

// 另一方面，如果这是一个外部边界面，那么 $\mathbf{W}^-$ 的值将是 $\mathbf{W}^+$ 的函数，或者它们将是规定的，这取决于这里施加的边界条件的种类。

// 为了开始评估，让我们确保为这个边界指定的边界ID是我们在参数对象中实际有数据的一个。接下来，我们对不均匀性的函数对象进行评估。 这有点棘手：一个给定的边界可能同时有规定的和隐含的值。 如果一个特定的成分没有被规定，那么这些值就会被评估为零，并在下面被忽略。

// 剩下的部分由一个实际了解欧拉方程边界条件具体内容的函数完成。请注意，由于我们在这里使用的是fad变量，敏感度将被适当地更新，否则这个过程将是非常复杂的。

    else 
      { 
        Assert(boundary_id < Parameters::AllParameters<dim>::max_n_boundaries, 
               ExcIndexRange(boundary_id, 
                             0, 
                             Parameters::AllParameters<dim>::max_n_boundaries)); 

        std::vector<Vector<double>> boundary_values( 
          n_q_points, Vector<double>(EulerEquations<dim>::n_components)); 
        parameters.boundary_conditions[boundary_id].values.vector_value_list( 
          fe_v.get_quadrature_points(), boundary_values); 

        for (unsigned int q = 0; q < n_q_points; q++) 
          { 
            EulerEquations<dim>::compute_Wminus( 
              parameters.boundary_conditions[boundary_id].kind, 
              fe_v.normal_vector(q), 
              Wplus[q], 
              boundary_values[q], 
              Wminus[q]); 

// 这里我们假设边界类型、边界法向量和边界数据值在时间推进中保持不变。

            EulerEquations<dim>::compute_Wminus( 
              parameters.boundary_conditions[boundary_id].kind, 
              fe_v.normal_vector(q), 
              Wplus_old[q], 
              boundary_values[q], 
              Wminus_old[q]); 
          } 
      } 

// 现在我们有了 $\mathbf w^+$ 和 $\mathbf w^-$ ，我们可以去计算每个正交点的数值通量函数 $\mathbf H(\mathbf w^+,\mathbf w^-, \mathbf n)$ 。在调用这个函数之前，我们还需要确定Lax-Friedrich的稳定性参数。

    std::vector< 
      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>> 
      normal_fluxes(n_q_points); 
    std::vector<std::array<double, EulerEquations<dim>::n_components>> 
      normal_fluxes_old(n_q_points); 

    double alpha; 

 
      { 
        case Parameters::Flux::constant: 
          alpha = parameters.stabilization_value; 
          break; 
        case Parameters::Flux::mesh_dependent: 
          alpha = face_diameter / (2.0 * parameters.time_step); 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
          alpha = 1; 
      } 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        EulerEquations<dim>::numerical_normal_flux( 
          fe_v.normal_vector(q), Wplus[q], Wminus[q], alpha, normal_fluxes[q]); 
        EulerEquations<dim>::numerical_normal_flux(fe_v.normal_vector(q), 
                                                   Wplus_old[q], 
                                                   Wminus_old[q], 
                                                   alpha, 
                                                   normal_fluxes_old[q]); 
      } 

// 现在以与前面函数中的单元格贡献完全相同的方式组装面项。唯一不同的是，如果这是一个内部面，我们还必须考虑到剩余贡献对相邻单元自由度的敏感性。

    std::vector<double> residual_derivatives(dofs_per_cell); 
    for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
      if (fe_v.get_fe().has_support_on_face(i, face_no) == true) 
        { 
          Sacado::Fad::DFad<double> R_i = 0; 

          for (unsigned int point = 0; point < n_q_points; ++point) 
            { 
              const unsigned int component_i = 
                fe_v.get_fe().system_to_component_index(i).first; 

              R_i += (parameters.theta * normal_fluxes[point][component_i] + 
                      (1.0 - parameters.theta) * 
                        normal_fluxes_old[point][component_i]) * 
                     fe_v.shape_value_component(i, point, component_i) * 
                     fe_v.JxW(point); 
            } 

          for (unsigned int k = 0; k < dofs_per_cell; ++k) 
            residual_derivatives[k] = R_i.fastAccessDx(k); 
          system_matrix.add(dof_indices[i], dof_indices, residual_derivatives); 

          if (external_face == false) 
            { 
              for (unsigned int k = 0; k < dofs_per_cell; ++k) 
                residual_derivatives[k] = R_i.fastAccessDx(dofs_per_cell + k); 
              system_matrix.add(dof_indices[i], 
                                dof_indices_neighbor, 
                                residual_derivatives); 
            } 

          right_hand_side(dof_indices[i]) -= R_i.val(); 
        } 
  } 
// @sect4{ConservationLaw::solve}  

// 在这里，我们实际解决线性系统，使用Trilinos的Aztec或Amesos线性求解器。计算的结果将被写入传递给这个函数的参数向量中。其结果是一对迭代次数和最终的线性残差。

  template <int dim> 
  std::pair<unsigned int, double> 
  ConservationLaw<dim>::solve(Vector<double> &newton_update) 
  { 
    switch (parameters.solver) 
      { 

// 如果参数文件指定要使用直接求解器，那么我们就到这里。这个过程很简单，因为deal.II在Trilinos中为Amesos直接求解器提供了一个封装类。我们所要做的就是创建一个求解器控制对象（这里只是一个虚拟对象，因为我们不会进行任何迭代），然后创建直接求解器对象。在实际进行求解时，注意我们没有传递一个预处理程序。无论如何，这对直接求解器来说没有什么意义。 最后我们返回求解器的控制统计信息&mdash;它将告诉我们没有进行任何迭代，并且最终的线性残差为零，这里没有任何可能提供的更好的信息。

        case Parameters::Solver::direct: 
          { 
            SolverControl                                  solver_control(1, 0); 
            TrilinosWrappers::SolverDirect::AdditionalData data( 
              parameters.output == Parameters::Solver::verbose); 
            TrilinosWrappers::SolverDirect direct(solver_control, data); 

            direct.solve(system_matrix, newton_update, right_hand_side); 

            return {solver_control.last_step(), solver_control.last_value()}; 
          } 

// 同样地，如果我们要使用一个迭代求解器，我们使用Aztec的GMRES求解器。我们也可以在这里使用Trilinos的迭代求解器和预处理类，但是我们选择直接使用Aztec的求解器。对于给定的问题，Aztec的内部预处理实现优于deal.II的包装类，所以我们在AztecOO求解器中使用ILU-T预处理，并设置了一堆可以从参数文件中修改的选项。

// 还有两个实际问题。由于我们将右手边和求解向量建立为deal.II向量对象（而不是矩阵，它是一个Trilinos对象），我们必须将Trilinos Epetra向量交给求解器。 幸运的是，他们支持 "视图 "的概念，所以我们只需发送一个指向deal.II向量的指针。我们必须为设置平行分布的向量提供一个Epetra_Map，这只是一个串行的假对象。最简单的方法是要求矩阵提供它的地图，我们要用它为矩阵-向量乘积做好准备。

// 其次，Aztec求解器希望我们传入一个Trilinos Epetra_CrsMatrix，而不是 deal.II包装类本身。所以我们通过trilinos_matrix()命令来访问Trilinos包装类中的实际Trilinos矩阵。Trilinos希望矩阵是非常量的，所以我们必须使用const_cast手动删除常量。

        case Parameters::Solver::gmres: 
          { 
            Epetra_Vector x(View, 
                            system_matrix.trilinos_matrix().DomainMap(), 
                            newton_update.begin()); 
            Epetra_Vector b(View, 
                            system_matrix.trilinos_matrix().RangeMap(), 
                            right_hand_side.begin()); 

            AztecOO solver; 
            solver.SetAztecOption( 
              AZ_output, 
              (parameters.output == Parameters::Solver::quiet ? AZ_none : 
                                                                AZ_all)); 
            solver.SetAztecOption(AZ_solver, AZ_gmres); 
            solver.SetRHS(&b); 
            solver.SetLHS(&x); 

            solver.SetAztecOption(AZ_precond, AZ_dom_decomp); 
            solver.SetAztecOption(AZ_subdomain_solve, AZ_ilut); 
            solver.SetAztecOption(AZ_overlap, 0); 
            solver.SetAztecOption(AZ_reorder, 0); 

            solver.SetAztecParam(AZ_drop, parameters.ilut_drop); 
            solver.SetAztecParam(AZ_ilut_fill, parameters.ilut_fill); 
            solver.SetAztecParam(AZ_athresh, parameters.ilut_atol); 
            solver.SetAztecParam(AZ_rthresh, parameters.ilut_rtol); 

            solver.SetUserMatrix( 
              const_cast<Epetra_CrsMatrix *>(&system_matrix.trilinos_matrix())); 

            solver.Iterate(parameters.max_iterations, 
                           parameters.linear_residual); 

            return {solver.NumIters(), solver.TrueResidual()}; 
          } 
      } 

    Assert(false, ExcNotImplemented()); 
    return {0, 0}; 
  } 
// @sect4{ConservationLaw::compute_refinement_indicators}  

// 这个函数是真正的简单。我们在这里并不假装知道一个好的细化指标会是什么。相反，我们认为 <code>EulerEquation</code> 类会知道这个问题，所以我们只是简单地服从于我们在那里实现的相应函数。

  template <int dim> 
  void ConservationLaw<dim>::compute_refinement_indicators( 
    Vector<double> &refinement_indicators) const 
  { 
    EulerEquations<dim>::compute_refinement_indicators(dof_handler, 
                                                       mapping, 
                                                       predictor, 
                                                       refinement_indicators); 
  } 

//  @sect4{ConservationLaw::refine_grid}  

// 在这里，我们使用之前计算的细化指标来细化网格。在开始的时候，我们在所有的单元格上循环，并标记那些我们认为应该被细化的单元格。

  template <int dim> 
  void 
  ConservationLaw<dim>::refine_grid(const Vector<double> &refinement_indicators) 
  { 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        const unsigned int cell_no = cell->active_cell_index(); 
        cell->clear_coarsen_flag(); 
        cell->clear_refine_flag(); 

        if ((cell->level() < parameters.shock_levels) && 
            (std::fabs(refinement_indicators(cell_no)) > parameters.shock_val)) 
          cell->set_refine_flag(); 
        else if ((cell->level() > 0) && 
                 (std::fabs(refinement_indicators(cell_no)) < 
                  0.75 * parameters.shock_val)) 
          cell->set_coarsen_flag(); 
      } 

// 然后，我们需要在进行细化的同时，将各种解决方案向量从旧网格转移到新网格。SolutionTransfer类是我们的朋友；它有相当丰富的文档，包括例子，所以我们不会对下面的代码做太多评论。最后三行只是把其他一些向量的大小重新设置为现在的正确大小。

    std::vector<Vector<double>> transfer_in; 
    std::vector<Vector<double>> transfer_out; 

    transfer_in.push_back(old_solution); 
    transfer_in.push_back(predictor); 

    triangulation.prepare_coarsening_and_refinement(); 

    SolutionTransfer<dim> soltrans(dof_handler); 
    soltrans.prepare_for_coarsening_and_refinement(transfer_in); 

    triangulation.execute_coarsening_and_refinement(); 

    dof_handler.clear(); 
    dof_handler.distribute_dofs(fe); 

    { 
      Vector<double> new_old_solution(1); 
      Vector<double> new_predictor(1); 

      transfer_out.push_back(new_old_solution); 
      transfer_out.push_back(new_predictor); 
      transfer_out[0].reinit(dof_handler.n_dofs()); 
      transfer_out[1].reinit(dof_handler.n_dofs()); 
    } 

    soltrans.interpolate(transfer_in, transfer_out); 

 
    old_solution = transfer_out[0]; 

    predictor.reinit(transfer_out[1].size()); 
    predictor = transfer_out[1]; 

    current_solution.reinit(dof_handler.n_dofs()); 
    current_solution = old_solution; 
    right_hand_side.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{ConservationLaw::output_results}  

// 现在的这个函数是相当直接的。所有的魔法，包括将数据从保守变量转化为物理变量，都已经被抽象化，并被移到EulerEquations类中，这样在我们想要解决其他双曲守恒定律时就可以被替换。

// 请注意，输出文件的数量是通过保持一个静态变量形式的计数器来确定的，这个计数器在我们第一次来到这个函数时被设置为零，并在每次调用结束时被增加一。

  template <int dim> 
  void ConservationLaw<dim>::output_results() const 
  { 
    typename EulerEquations<dim>::Postprocessor postprocessor( 
      parameters.schlieren_plot); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 

    data_out.add_data_vector(current_solution, 
                             EulerEquations<dim>::component_names(), 
                             DataOut<dim>::type_dof_data, 
                             EulerEquations<dim>::component_interpretation()); 

    data_out.add_data_vector(current_solution, postprocessor); 

    data_out.build_patches(); 

    static unsigned int output_file_number = 0; 
    std::string         filename = 
      "solution-" + Utilities::int_to_string(output_file_number, 3) + ".vtk"; 
    std::ofstream output(filename); 
    data_out.write_vtk(output); 

    ++output_file_number; 
  } 

//  @sect4{ConservationLaw::run}  

// 这个函数包含了这个程序的顶层逻辑：初始化，时间循环，以及牛顿内部迭代。

// 在开始时，我们读取参数文件指定的网格文件，设置DoFHandler和各种向量，然后在这个网格上插值给定的初始条件。然后我们在初始条件的基础上进行一系列的网格细化，以获得一个已经很适应起始解的网格。在这个过程结束时，我们输出初始解。

  template <int dim> 
  void ConservationLaw<dim>::run() 
  { 
    { 
      GridIn<dim> grid_in; 
      grid_in.attach_triangulation(triangulation); 

      std::ifstream input_file(parameters.mesh_filename); 
      Assert(input_file, ExcFileNotOpen(parameters.mesh_filename.c_str())); 

      grid_in.read_ucd(input_file); 
    } 

    dof_handler.clear(); 
    dof_handler.distribute_dofs(fe); 

// 所有字段的大小。

    old_solution.reinit(dof_handler.n_dofs()); 
    current_solution.reinit(dof_handler.n_dofs()); 
    predictor.reinit(dof_handler.n_dofs()); 
    right_hand_side.reinit(dof_handler.n_dofs()); 

    setup_system(); 

    VectorTools::interpolate(dof_handler, 
                             parameters.initial_conditions, 
                             old_solution); 
    current_solution = old_solution; 
    predictor        = old_solution; 

    if (parameters.do_refine == true) 
      for (unsigned int i = 0; i < parameters.shock_levels; ++i) 
        { 
          Vector<double> refinement_indicators(triangulation.n_active_cells()); 

          compute_refinement_indicators(refinement_indicators); 
          refine_grid(refinement_indicators); 

          setup_system(); 

          VectorTools::interpolate(dof_handler, 
                                   parameters.initial_conditions, 
                                   old_solution); 
          current_solution = old_solution; 
          predictor        = old_solution; 
        } 

    output_results(); 

// 然后我们进入主时间步进循环。在顶部，我们简单地输出一些状态信息，这样就可以跟踪计算的位置，以及显示非线性内部迭代进展的表格的标题。

    Vector<double> newton_update(dof_handler.n_dofs()); 

    double time        = 0; 
    double next_output = time + parameters.output_step; 

    predictor = old_solution; 
    while (time < parameters.final_time) 
      { 
        std::cout << "T=" << time << std::endl 
                  << "   Number of active cells:       " 
                  << triangulation.n_active_cells() << std::endl 
                  << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
                  << std::endl 
                  << std::endl; 

        std::cout << "   NonLin Res     Lin Iter       Lin Res" << std::endl 
                  << "   _____________________________________" << std::endl; 

// 然后是内牛顿迭代，解决每个时间步长的非线性问题。它的工作方式是将矩阵和右手边重置为零，然后组装线性系统。如果右手边的规范足够小，那么我们就宣布牛顿迭代已经收敛了。否则，我们求解线性系统，用牛顿增量更新当前解，并输出收敛信息。最后，我们检查牛顿迭代的次数是否超过了10次的限制--如果超过了，就说明迭代有可能出现了发散，继续迭代也没有什么好处。如果发生这种情况，我们就抛出一个异常，这个异常将在 <code>main()</code> 中被捕获，并在程序终止前显示状态信息。

// 注意，我们写AssertThrow宏的方式基本上等同于写<code>if (!(nonlin_iter  @<=  10)) throw ExcMessage ("No convergence in nonlinear solver");</code>这样的话。唯一显著的区别是，AssertThrow还确保被抛出的异常带有它产生的位置（文件名和行号）的信息。这在这里不是太关键，因为只有一个地方可能发生这种异常；然而，当人们想找出错误发生的地方时，它通常是一个非常有用的工具。

        unsigned int nonlin_iter = 0; 
        current_solution         = predictor; 
        while (true) 
          { 
            system_matrix = 0; 

            right_hand_side = 0; 
            assemble_system(); 

            const double res_norm = right_hand_side.l2_norm(); 
            if (std::fabs(res_norm) < 1e-10) 
              { 
                std::printf("   %-16.3e (converged)\n\n", res_norm); 
                break; 
              } 
            else 
              { 
                newton_update = 0; 

                std::pair<unsigned int, double> convergence = 
                  solve(newton_update); 

                current_solution += newton_update; 

                std::printf("   %-16.3e %04d        %-5.2e\n", 
                            res_norm, 
                            convergence.first, 
                            convergence.second); 
              } 

            ++nonlin_iter; 
            AssertThrow(nonlin_iter <= 10, 
                        ExcMessage("No convergence in nonlinear solver")); 
          } 

// 只有在牛顿迭代已经收敛的情况下，我们才会到达这一点，所以在这里做各种收敛后的任务。

// 首先，我们更新时间，如果需要的话，产生图形输出。然后，我们通过近似 $\mathbf w^{n+1}\approx \mathbf w^n + \delta t \frac{\partial \mathbf w}{\partial t} \approx \mathbf w^n + \delta t \; \frac{\mathbf w^n-\mathbf w^{n-1}}{\delta t} = 2 \mathbf w^n - \mathbf w^{n-1}$ 来更新下一个时间步长的解决方案的预测器，以尝试使适应性更好地工作。 我们的想法是尝试在前面进行细化，而不是步入一个粗略的元素集并抹去旧的解决方案。 这个简单的时间推断器可以完成这个工作。有了这个，如果用户需要的话，我们就可以对网格进行细化，最后继续进行下一个时间步骤。

        time += parameters.time_step; 

        if (parameters.output_step < 0) 
          output_results(); 
        else if (time >= next_output) 
          { 
            output_results(); 
            next_output += parameters.output_step; 
          } 

        predictor = current_solution; 
        predictor.sadd(2.0, -1.0, old_solution); 

        old_solution = current_solution; 

        if (parameters.do_refine == true) 
          { 
            Vector<double> refinement_indicators( 
              triangulation.n_active_cells()); 
            compute_refinement_indicators(refinement_indicators); 

            refine_grid(refinement_indicators); 
            setup_system(); 

            newton_update.reinit(dof_handler.n_dofs()); 
          } 
      } 
  } 
} // namespace Step33 
// @sect3{main()}  

// 下面的``main''函数与前面的例子类似，不需要进行注释。请注意，如果在命令行上没有给出输入文件名，程序就会中止。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step33; 

      if (argc != 2) 
        { 
          std::cout << "Usage:" << argv[0] << " input_file" << std::endl; 
          std::exit(1); 
        } 

      Utilities::MPI::MPI_InitFinalize mpi_initialization( 
        argc, argv, dealii::numbers::invalid_unsigned_int); 

      ConservationLaw<2> cons(argv[1]); 
      cons.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 

  return 0; 
} 


CCTest_file/step-34.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Luca Heltai, Cataldo Manigrasso, 2009 
 */ 


// @sect3{Include files}  

// 程序一开始就包括了一堆include文件，我们将在程序的各个部分使用这些文件。其中大部分在以前的教程中已经讨论过了。

#include <deal.II/base/smartpointer.h> 
#include <deal.II/base/convergence_table.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/quadrature_selector.h> 
#include <deal.II/base/parsed_function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/solver_control.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/precondition.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_in.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/manifold_lib.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 这里有一些我们需要的C++标准头文件。

#include <cmath> 
#include <iostream> 
#include <fstream> 
#include <string> 

// 这个序言的最后部分是将dealii命名空间中的所有内容导入到这个程序中的所有内容中。

namespace Step34 
{ 
  using namespace dealii; 
// @sect3{Single and double layer operator kernels}  

// 首先，让我们定义一下边界积分方程的机制。

// 以下两个函数是单层和双层势能核的实际计算，即  $G$  和  $\nabla G$  。只有当矢量 $R = \mathbf{y}-\mathbf{x}$ 不同于零时，它们才是定义良好的。

  namespace LaplaceKernel 
  { 
    template <int dim> 
    double single_layer(const Tensor<1, dim> &R) 
    { 
      switch (dim) 
        { 
          case 2: 
            return (-std::log(R.norm()) / (2 * numbers::PI)); 

          case 3: 
            return (1. / (R.norm() * 4 * numbers::PI)); 

          default: 
            Assert(false, ExcInternalError()); 
            return 0.; 
        } 
    } 

    template <int dim> 
    Tensor<1, dim> double_layer(const Tensor<1, dim> &R) 
    { 
      switch (dim) 
        { 
          case 2: 
            return R / (-2 * numbers::PI * R.norm_square()); 
          case 3: 
            return R / (-4 * numbers::PI * R.norm_square() * R.norm()); 

          default: 
            Assert(false, ExcInternalError()); 
            return Tensor<1, dim>(); 
        } 
    } 
  } // namespace LaplaceKernel 
// @sect3{The BEMProblem class}  

// 边界元素方法代码的结构与有限元素代码的结构非常相似，所以这个类的成员函数与其他大多数教程程序的成员函数一样。特别是，现在你应该熟悉从外部文件中读取参数，以及将不同的任务分割成不同的模块。这同样适用于边界元素方法，我们不会对其进行过多的评论，只是对其中的差异进行评论。

  template <int dim> 
  class BEMProblem 
  { 
  public: 
    BEMProblem(const unsigned int fe_degree      = 1, 
               const unsigned int mapping_degree = 1); 

    void run(); 

  private: 
    void read_parameters(const std::string &filename); 

    void read_domain(); 

    void refine_and_resize(); 

// 我们在这里发现的唯一真正不同的函数是装配程序。我们以最通用的方式编写了这个函数，以便能够方便地推广到高阶方法和不同的基本解（例如斯托克斯或麦克斯韦）。

// 最明显的区别是，最终的矩阵是完整的，而且我们在通常的单元格循环内有一个嵌套的循环，访问所有自由度的支持点。 此外，当支持点位于我们所访问的单元内时，我们所执行的积分就会变成单数。

// 实际的结果是，我们有两套正交公式、有限元值和临时存储，一套用于标准积分，另一套用于奇异积分，在必要时使用。

    void assemble_system(); 

// 对于这个问题的解决有两种选择。第一个是使用直接求解器，第二个是使用迭代求解器。我们选择了第二种方案。

// 我们组装的矩阵不是对称的，我们选择使用GMRES方法；然而为边界元素方法构建一个有效的预处理程序并不是一个简单的问题。这里我们使用一个非预处理的GMRES求解器。迭代求解器的选项，如公差、最大迭代次数等，都是通过参数文件选择的。

    void solve_system(); 

// 一旦我们得到了解决方案，我们将计算计算出的势的 $L^2$ 误差，以及实体角的近似值的 $L^\infty$ 误差。我们使用的网格是平滑曲线的近似值，因此计算出的角的分量或实体角的对角线矩阵  $\alpha(\mathbf{x})$  应该一直等于  $\frac 12$  。在这个例程中，我们输出势的误差和计算角度的近似值的误差。注意，后者的误差实际上不是计算角度的误差，而是衡量我们对球体和圆的近似程度。

// 对角度的计算做一些实验，对于较简单的几何形状，可以得到非常准确的结果。为了验证这一点，你可以在read_domain()方法中注释掉tria.set_manifold(1, manifold)一行，并检查程序生成的alpha。通过删除这个调用，每当细化网格时，新的节点将沿着构成粗略网格的直线放置，而不是被拉到我们真正想要近似的表面。在三维案例中，球体的粗网格是从一个立方体开始得到的，得到的字母值正好是面的节点上的 $\frac 12$ ，边的节点上的 $\frac 34$ 和顶点的8个节点上的 $\frac 78$ 。

    void compute_errors(const unsigned int cycle); 

// 一旦我们在一维领域得到了一个解决方案，我们就想把它插值到空间的其他部分。这可以通过在compute_exterior_solution()函数中再次进行解与核的卷积来实现。

// 我们想绘制速度变量，也就是势解的梯度。势解只在边界上是已知的，但我们使用与基本解的卷积在标准的二维连续有限元空间上进行插值。外推解的梯度图将给我们提供我们想要的速度。

// 除了外域上的解，我们还在output_results()函数中输出域的边界上的解，当然了。

    void compute_exterior_solution(); 

    void output_results(const unsigned int cycle); 

// 为了实现不受维度限制的编程，我们对这个单一的函数进行了专业化处理，以提取整合单元内部的奇异核所需的奇异正交公式。

    const Quadrature<dim - 1> &get_singular_quadrature( 
      const typename DoFHandler<dim - 1, dim>::active_cell_iterator &cell, 
      const unsigned int index) const; 

// 通常的deal.II类可以通过指定问题的 "二维 "来用于边界元素方法。这是通过将Triangulation, FiniteElement和DoFHandler的可选第二模板参数设置为嵌入空间的维度来实现的。在我们的例子中，我们生成了嵌入在二维或三维空间的一维或二维网格。

// 可选参数默认等于第一个参数，并产生我们在之前所有例子中看到的通常的有限元类。

// 该类的构造方式是允许任意的域（通过高阶映射）和有限元空间的逼近顺序。有限元空间和映射的顺序可以在该类的构造函数中选择。

    Triangulation<dim - 1, dim> tria; 
    FE_Q<dim - 1, dim>          fe; 
    DoFHandler<dim - 1, dim>    dof_handler; 
    MappingQ<dim - 1, dim>      mapping; 

// 在BEM方法中，生成的矩阵是密集的。根据问题的大小，最终的系统可能通过直接的LU分解来解决，或者通过迭代方法来解决。在这个例子中，我们使用了一个无条件的GMRES方法。为BEM方法建立一个预处理程序是不容易的，我们在此不做处理。

    FullMatrix<double> system_matrix; 
    Vector<double>     system_rhs; 

// 接下来的两个变量将表示解决方案 $\phi$ 以及一个向量，它将保存 $\alpha(\mathbf x)$ 的值（从一个点 $\mathbf x$ 可见的 $\Omega$ 的部分）在我们形状函数的支持点。

    Vector<double> phi; 
    Vector<double> alpha; 

// 收敛表是用来输出精确解和计算出的字母的误差的。

    ConvergenceTable convergence_table; 

// 下面的变量是我们通过参数文件来填充的。 本例中我们使用的新对象是 Functions::ParsedFunction 对象和QuadratureSelector对象。

//  Functions::ParsedFunction 类允许我们通过参数文件方便快捷地定义新的函数对象，自定义的定义可以非常复杂（关于所有可用的选项，见该类的文档）。

// 我们将使用QuadratureSelector类来分配正交对象，该类允许我们根据一个识别字符串和公式本身的可能程度来生成正交公式。我们用它来允许自定义选择标准积分的正交公式，并定义奇异正交规则的顺序。

// 我们还定义了几个参数，这些参数是在我们想把解决方案扩展到整个领域的情况下使用的。

    Functions::ParsedFunction<dim> wind; 
    Functions::ParsedFunction<dim> exact_solution; 

    unsigned int                         singular_quadrature_order; 
    std::shared_ptr<Quadrature<dim - 1>> quadrature; 

    SolverControl solver_control; 

    unsigned int n_cycles; 
    unsigned int external_refinement; 

    bool run_in_this_dimension; 
    bool extend_solution; 
  }; 
// @sect4{BEMProblem::BEMProblem and BEMProblem::read_parameters}  

//构造函数初始化各种对象的方式与有限元程序（如  step-4  或  step-6  ）中的方式基本相同。这里唯一的新成分是ParsedFunction对象，它在构造时需要说明组件的数量。

// 对于精确解来说，向量分量的数量是1，而且不需要任何操作，因为1是ParsedFunction对象的默认值。然而，风需要指定dim组件。注意，在为 Functions::ParsedFunction, 的表达式声明参数文件中的条目时，我们需要明确指定分量的数量，因为函数 Functions::ParsedFunction::declare_parameters 是静态的，对分量的数量没有了解。

  template <int dim> 
  BEMProblem<dim>::BEMProblem(const unsigned int fe_degree, 
                              const unsigned int mapping_degree) 
    : fe(fe_degree) 
    , dof_handler(tria) 
    , mapping(mapping_degree, true) 
    , wind(dim) 
    , singular_quadrature_order(5) 
    , n_cycles(4) 
    , external_refinement(5) 
    , run_in_this_dimension(true) 
    , extend_solution(true) 
  {} 

  template <int dim> 
  void BEMProblem<dim>::read_parameters(const std::string &filename) 
  { 
    deallog << std::endl 
            << "Parsing parameter file " << filename << std::endl 
            << "for a " << dim << " dimensional simulation. " << std::endl; 

    ParameterHandler prm; 

    prm.declare_entry("Number of cycles", "4", Patterns::Integer()); 
    prm.declare_entry("External refinement", "5", Patterns::Integer()); 
    prm.declare_entry("Extend solution on the -2,2 box", 
                      "true", 
                      Patterns::Bool()); 
    prm.declare_entry("Run 2d simulation", "true", Patterns::Bool()); 
    prm.declare_entry("Run 3d simulation", "true", Patterns::Bool()); 

    prm.enter_subsection("Quadrature rules"); 
    { 
      prm.declare_entry( 
        "Quadrature type", 
        "gauss", 
        Patterns::Selection( 
          QuadratureSelector<(dim - 1)>::get_quadrature_names())); 
      prm.declare_entry("Quadrature order", "4", Patterns::Integer()); 
      prm.declare_entry("Singular quadrature order", "5", Patterns::Integer()); 
    } 
    prm.leave_subsection(); 

// 对于二维和三维，我们将默认的输入数据设置为：解为  $x+y$  或  $x+y+z$  。实际计算出的解在无穷大时的数值为零。在这种情况下，这与精确解相吻合，不需要额外的修正，但是你应该注意，我们任意设置了 $\phi_\infty$ ，而我们传递给程序的精确解需要在无穷远处有相同的值，才能正确计算出误差。

//  Functions::ParsedFunction 对象的使用是非常直接的。 Functions::ParsedFunction::declare_parameters 函数需要一个额外的整数参数，指定给定函数的分量数量。它的默认值是1。当相应的 Functions::ParsedFunction::parse_parameters 方法被调用时，调用对象必须有与这里定义的相同数量的组件，否则会产生异常。

// 在声明条目时，我们同时声明了二维和三维的函数。然而只有二维的最终被解析。这使得我们对二维和三维问题都只需要一个参数文件。

// 注意，从数学的角度来看，边界上的风函数应该满足条件 $\int_{\partial\Omega} \mathbf{v}\cdot \mathbf{n} d \Gamma = 0$  ，这样问题才会有解。如果不满足这个条件，那么就找不到解，求解器也就不会收敛。

    prm.enter_subsection("Wind function 2d"); 
    { 
      Functions::ParsedFunction<2>::declare_parameters(prm, 2); 
      prm.set("Function expression", "1; 1"); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Wind function 3d"); 
    { 
      Functions::ParsedFunction<3>::declare_parameters(prm, 3); 
      prm.set("Function expression", "1; 1; 1"); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Exact solution 2d"); 
    { 
      Functions::ParsedFunction<2>::declare_parameters(prm); 
      prm.set("Function expression", "x+y"); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Exact solution 3d"); 
    { 
      Functions::ParsedFunction<3>::declare_parameters(prm); 
      prm.set("Function expression", "x+y+z"); 
    } 
    prm.leave_subsection(); 

// 在求解器部分，我们设置所有的SolverControl参数。然后，该对象将在solve_system()函数中被送入GMRES求解器。

    prm.enter_subsection("Solver"); 
    SolverControl::declare_parameters(prm); 
    prm.leave_subsection(); 

// 在向ParameterHandler对象声明了所有这些参数后，让我们读取一个输入文件，该文件将为这些参数提供其值。然后我们继续从ParameterHandler对象中提取这些值。

    prm.parse_input(filename); 

    n_cycles            = prm.get_integer("Number of cycles"); 
    external_refinement = prm.get_integer("External refinement"); 
    extend_solution     = prm.get_bool("Extend solution on the -2,2 box"); 

    prm.enter_subsection("Quadrature rules"); 
    { 
      quadrature = std::shared_ptr<Quadrature<dim - 1>>( 
        new QuadratureSelector<dim - 1>(prm.get("Quadrature type"), 
                                        prm.get_integer("Quadrature order"))); 
      singular_quadrature_order = prm.get_integer("Singular quadrature order"); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Wind function " + std::to_string(dim) + "d"); 
    { 
      wind.parse_parameters(prm); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Exact solution " + std::to_string(dim) + "d"); 
    { 
      exact_solution.parse_parameters(prm); 
    } 
    prm.leave_subsection(); 

    prm.enter_subsection("Solver"); 
    solver_control.parse_parameters(prm); 
    prm.leave_subsection(); 

// 最后，这里是另一个如何在独立维度编程中使用参数文件的例子。 如果我们想关闭两个模拟中的一个，我们可以通过设置相应的 "运行2D模拟 "或 "运行3D模拟 "标志为假来实现。

    run_in_this_dimension = 
      prm.get_bool("Run " + std::to_string(dim) + "d simulation"); 
  } 
// @sect4{BEMProblem::read_domain}  

// 边界元素法三角剖分与（dim-1）维三角剖分基本相同，不同之处在于顶点属于（dim）维空间。

// deal.II中支持的一些网格格式默认使用三维点来描述网格。这些格式与deal.II的边界元素方法功能兼容。特别是我们可以使用UCD或GMSH格式。在这两种情况下，我们必须特别注意网格的方向，因为与标准有限元的情况不同，这里没有进行重新排序或兼容性检查。 所有的网格都被认为是有方向性的，因为它们被嵌入到一个高维空间中。参见GridIn和Triangulation的文档，以进一步了解三角结构中单元的方向。在我们的例子中，网格的法线是外在于2D的圆或3D的球体。

// 对边界元素网格进行适当细化所需要的另一个细节是对网格所逼近的流形的准确描述。对于标准有限元网格的边界，我们已经多次看到了这一点（例如在 step-5 和 step-6 中），这里的原理和用法是一样的，只是SphericalManifold类需要一个额外的模板参数来指定嵌入空间维度。

  template <int dim> 
  void BEMProblem<dim>::read_domain() 
  { 
    const Point<dim>                      center = Point<dim>(); 
    const SphericalManifold<dim - 1, dim> manifold(center); 

    std::ifstream in; 
    switch (dim) 
      { 
        case 2: 
          in.open("coarse_circle.inp"); 
          break; 

        case 3: 
          in.open("coarse_sphere.inp"); 
          break; 

        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    GridIn<dim - 1, dim> gi; 
    gi.attach_triangulation(tria); 
    gi.read_ucd(in); 

    tria.set_all_manifold_ids(1); 

// 对  Triangulation::set_manifold  的调用复制了流形（通过  Manifold::clone()),  所以我们不需要担心对  <code>manifold</code>  的无效指针。

    tria.set_manifold(1, manifold); 
  } 
// @sect4{BEMProblem::refine_and_resize}  

// 这个函数对网格进行全局细化，分配自由度，并调整矩阵和向量的大小。

  template <int dim> 
  void BEMProblem<dim>::refine_and_resize() 
  { 
    tria.refine_global(1); 

    dof_handler.distribute_dofs(fe); 

    const unsigned int n_dofs = dof_handler.n_dofs(); 

    system_matrix.reinit(n_dofs, n_dofs); 

    system_rhs.reinit(n_dofs); 
    phi.reinit(n_dofs); 
    alpha.reinit(n_dofs); 
  } 
// @sect4{BEMProblem::assemble_system}  

// 下面是这个程序的主要功能，组装与边界积分方程相对应的矩阵。

  template <int dim> 
  void BEMProblem<dim>::assemble_system() 
  { 

// 首先我们用正交公式初始化一个FEValues对象，用于在非奇异单元中进行内核积分。这个正交公式是通过参数文件选择的，并且需要相当精确，因为我们要积分的函数不是多项式函数。

    FEValues<dim - 1, dim> fe_v(mapping, 
                                fe, 
                                *quadrature, 
                                update_values | update_normal_vectors | 
                                  update_quadrature_points | update_JxW_values); 

    const unsigned int n_q_points = fe_v.n_quadrature_points; 

    std::vector<types::global_dof_index> local_dof_indices( 
      fe.n_dofs_per_cell()); 

    std::vector<Vector<double>> cell_wind(n_q_points, Vector<double>(dim)); 
    double                      normal_wind; 

// 与有限元方法不同的是，如果我们使用拼合边界元方法，那么在每个装配循环中，我们只装配与一个自由度（与支撑点 $i$ 相关的自由度）和当前单元之间的耦合信息。这是用fe.dofs_per_cell元素的向量完成的，然后将其分配到全局行的矩阵中  $i$  。以下对象将持有这些信息。

    Vector<double> local_matrix_row_i(fe.n_dofs_per_cell()); 

// 索引  $i$  运行在拼合点上，这是  $i$  第三个基函数的支持点，而  $j$  运行在内部积分点上。

// 我们构建一个支持点的向量，它将用于局部积分。

    std::vector<Point<dim>> support_points(dof_handler.n_dofs()); 
    DoFTools::map_dofs_to_support_points<dim - 1, dim>(mapping, 
                                                       dof_handler, 
                                                       support_points); 

// 这样做之后，我们就可以开始对所有单元进行积分循环，首先初始化FEValues对象，得到正交点的 $\mathbf{\tilde v}$ 的值（这个向量场应该是常数，但更通用也无妨）。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_v.reinit(cell); 
        cell->get_dof_indices(local_dof_indices); 

        const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points(); 
        const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors(); 
        wind.vector_value_list(q_points, cell_wind); 

// 然后我们在当前单元上形成所有自由度的积分（注意，这包括不在当前单元上的自由度，这与通常的有限元积分有偏差）。如果其中一个局部自由度与支持点 $i$ 相同，我们需要执行的积分是单数。因此，在循环的开始，我们检查是否是这种情况，并存储哪一个是奇异指数。

        for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i) 
          { 
            local_matrix_row_i = 0; 

            bool         is_singular    = false; 
            unsigned int singular_index = numbers::invalid_unsigned_int; 

            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j) 
              if (local_dof_indices[j] == i) 
                { 
                  singular_index = j; 
                  is_singular    = true; 
                  break; 
                } 

// 然后我们进行积分。如果指数 $i$ 不是局部自由度之一，我们只需将单层项加到右边，将双层项加到矩阵中。

            if (is_singular == false) 
              { 
                for (unsigned int q = 0; q < n_q_points; ++q) 
                  { 
                    normal_wind = 0; 
                    for (unsigned int d = 0; d < dim; ++d) 
                      normal_wind += normals[q][d] * cell_wind[q](d); 

                    const Tensor<1, dim> R = q_points[q] - support_points[i]; 

                    system_rhs(i) += (LaplaceKernel::single_layer(R) * 
                                      normal_wind * fe_v.JxW(q)); 

                    for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j) 

                      local_matrix_row_i(j) -= 
                        ((LaplaceKernel::double_layer(R) * normals[q]) * 
                         fe_v.shape_value(j, q) * fe_v.JxW(q)); 
                  } 
              } 
            else 
              { 

// 现在我们处理更微妙的情况。如果我们在这里，这意味着在 $j$ 索引上运行的单元包含support_point[i]。在这种情况下，单层和双层势都是单数，它们需要特殊处理。            
//每当在给定单元内进行积分时，就会使用一个特殊的正交公式，允许人们对参考单元上的奇异权重进行任意函数的积分。            
//正确的正交公式由get_singular_quadrature函数选择，下面将详细说明。

                Assert(singular_index != numbers::invalid_unsigned_int, 
                       ExcInternalError()); 

                const Quadrature<dim - 1> &singular_quadrature = 
                  get_singular_quadrature(cell, singular_index); 

                FEValues<dim - 1, dim> fe_v_singular( 
                  mapping, 
                  fe, 
                  singular_quadrature, 
                  update_jacobians | update_values | update_normal_vectors | 
                    update_quadrature_points); 

                fe_v_singular.reinit(cell); 

                std::vector<Vector<double>> singular_cell_wind( 
                  singular_quadrature.size(), Vector<double>(dim)); 

                const std::vector<Tensor<1, dim>> &singular_normals = 
                  fe_v_singular.get_normal_vectors(); 
                const std::vector<Point<dim>> &singular_q_points = 
                  fe_v_singular.get_quadrature_points(); 

                wind.vector_value_list(singular_q_points, singular_cell_wind); 

                for (unsigned int q = 0; q < singular_quadrature.size(); ++q) 
                  { 
                    const Tensor<1, dim> R = 
                      singular_q_points[q] - support_points[i]; 
                    double normal_wind = 0; 
                    for (unsigned int d = 0; d < dim; ++d) 
                      normal_wind += 
                        (singular_cell_wind[q](d) * singular_normals[q][d]); 

                    system_rhs(i) += (LaplaceKernel::single_layer(R) * 
                                      normal_wind * fe_v_singular.JxW(q)); 

                    for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j) 
                      { 
                        local_matrix_row_i(j) -= 
                          ((LaplaceKernel::double_layer(R) * 
                            singular_normals[q]) * 
                           fe_v_singular.shape_value(j, q) * 
                           fe_v_singular.JxW(q)); 
                      } 
                  } 
              } 

// 最后，我们需要将当前单元格的贡献添加到全局矩阵中。

            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j) 
              system_matrix(i, local_dof_indices[j]) += local_matrix_row_i(j); 
          } 
      } 

// 积分运算符的第二部分是术语  $\alpha(\mathbf{x}_i) \phi_j(\mathbf{x}_i)$  。由于我们使用的是配位方案， $\phi_j(\mathbf{x}_i)=\delta_{ij}$  而相应的矩阵是一个对角线的矩阵，其条目等于 $\alpha(\mathbf{x}_i)$  。

// 计算这个实体角的对角矩阵的一个快速方法是使用诺伊曼矩阵本身。只需将该矩阵与一个元素都等于-1的向量相乘，就可以得到阿尔法角或实体角的对角线矩阵（见介绍中的公式）。然后将这个结果加回到系统矩阵对象上，得到矩阵的最终形式。

    Vector<double> ones(dof_handler.n_dofs()); 
    ones.add(-1.); 

    system_matrix.vmult(alpha, ones); 
    alpha.add(1); 
    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i) 
      system_matrix(i, i) += alpha(i); 
  } 
// @sect4{BEMProblem::solve_system}  

// 下一个函数简单地解决了线性系统。

  template <int dim> 
  void BEMProblem<dim>::solve_system() 
  { 
    SolverGMRES<Vector<double>> solver(solver_control); 
    solver.solve(system_matrix, phi, system_rhs, PreconditionIdentity()); 
  } 
// @sect4{BEMProblem::compute_errors}  

// 误差的计算在其他所有的例子程序中都是完全一样的，我们就不做过多的评论。请注意，在有限元方法中使用的方法在这里也可以使用。

  template <int dim> 
  void BEMProblem<dim>::compute_errors(const unsigned int cycle) 
  { 
    Vector<float> difference_per_cell(tria.n_active_cells()); 
    VectorTools::integrate_difference(mapping, 
                                      dof_handler, 
                                      phi, 
                                      exact_solution, 
                                      difference_per_cell, 
                                      QGauss<(dim - 1)>(2 * fe.degree + 1), 
                                      VectorTools::L2_norm); 
    const double L2_error = 
      VectorTools::compute_global_error(tria, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

//可以直接使用 Vector::linfty_norm() 函数来计算α向量的误差，因为在每个节点上，该值应该是 $\frac 12$  。然后，所有的误差都会被输出并附加到我们的ConvergenceTable对象中，以便以后计算收敛率。

    Vector<double> difference_per_node(alpha); 
    difference_per_node.add(-.5); 

    const double       alpha_error    = difference_per_node.linfty_norm(); 
    const unsigned int n_active_cells = tria.n_active_cells(); 
    const unsigned int n_dofs         = dof_handler.n_dofs(); 

    deallog << "Cycle " << cycle << ':' << std::endl 
            << "   Number of active cells:       " << n_active_cells 
            << std::endl 
            << "   Number of degrees of freedom: " << n_dofs << std::endl; 

    convergence_table.add_value("cycle", cycle); 
    convergence_table.add_value("cells", n_active_cells); 
    convergence_table.add_value("dofs", n_dofs); 
    convergence_table.add_value("L2(phi)", L2_error); 
    convergence_table.add_value("Linfty(alpha)", alpha_error); 
  } 

// 奇异积分需要仔细选择正交规则。特别是deal.II库提供了为对数奇异性（QGaussLog, QGaussLogR）以及1/R奇异性（QGaussOneOverR）量身定制的正交规则。

// 奇异积分通常是通过构建具有奇异权重的加权正交公式得到的，因此可以写成

// \f[ \int_K f(x) s(x) dx = \sum_{i=1}^N w_i f(q_i) \f]

// 其中 $s(x)$ 是一个给定的奇点，权重和正交点 $w_i,q_i$ 是精心选择的，以使上述公式对某类函数 $f(x)$ 是一个等式。

// 在我们目前看到的所有有限元例子中，正交点本身的权重（即函数  $s(x)$  ），总是不断地等于1。 对于奇异积分，我们有两个选择：我们可以使用上面的定义，从积分中剔除奇异性（即用特殊的正交规则对 $f(x)$ 进行积分），或者我们可以要求正交规则用 $s(q_i)$ 对权重 $w_i$ 进行 "标准化"。

// \f[ \int_K f(x) s(x) dx = \int_K g(x) dx = \sum_{i=1}^N \frac{w_i}{s(q_i)} g(q_i) \f]

// 我们通过QGaussLogR和QGaussOneOverR的 @p factor_out_singularity 参数来使用这第二种选择。

// 这些积分有些微妙，特别是在二维空间，由于从实数到参考单元的转换，积分的变量是以转换的行列式为尺度的。

// 在二维空间中，这个过程不仅会导致一个因子作为常数出现在整个积分上，而且还会导致一个需要评估的额外积分。

// \f[ \int_0^1 f(x)\ln(x/\alpha) dx = \int_0^1 f(x)\ln(x) dx - \int_0^1  f(x) \ln(\alpha) dx.  \f]

// 这个过程由QGaussLogR类的构造函数来处理，它增加了额外的正交点和权重，以考虑到积分的第二部分。

// 类似的推理应该在三维情况下进行，因为奇异正交是在参考单元的半径 $r$ 的逆上定制的，而我们的奇异函数生活在实空间，然而在三维情况下一切都更简单，因为奇异性与变换的行列式成线性比例。这使我们可以只建立一次奇异的二维正交规则，并在所有单元格中重复使用。

// 在一维的奇异积分中，这是不可能的，因为我们需要知道正交的缩放参数，而这个参数并不是先验的。这里，正交规则本身也取决于当前单元格的大小。出于这个原因，有必要为每个单数积分创建一个新的正交。

// 不同的正交规则是在get_singular_quadrature中建立的，它专门用于dim=2和dim=3，它们在assemble_system函数中被检索。作为参数给出的索引是奇异点所在的单位支持点的索引。

  template <> 
  const Quadrature<2> &BEMProblem<3>::get_singular_quadrature( 
    const DoFHandler<2, 3>::active_cell_iterator &, 
    const unsigned int index) const 
  { 
    Assert(index < fe.n_dofs_per_cell(), 
           ExcIndexRange(0, fe.n_dofs_per_cell(), index)); 

    static std::vector<QGaussOneOverR<2>> quadratures; 
    if (quadratures.size() == 0) 
      for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i) 
        quadratures.emplace_back(singular_quadrature_order, 
                                 fe.get_unit_support_points()[i], 
                                 true); 
    return quadratures[index]; 
  } 

  template <> 
  const Quadrature<1> &BEMProblem<2>::get_singular_quadrature( 
    const DoFHandler<1, 2>::active_cell_iterator &cell, 
    const unsigned int                            index) const 
  { 
    Assert(index < fe.n_dofs_per_cell(), 
           ExcIndexRange(0, fe.n_dofs_per_cell(), index)); 

    static Quadrature<1> *q_pointer = nullptr; 
    if (q_pointer) 
      delete q_pointer; 

    q_pointer = new QGaussLogR<1>(singular_quadrature_order, 
                                  fe.get_unit_support_points()[index], 
                                  1. / cell->measure(), 
                                  true); 
    return (*q_pointer); 
  } 

//  @sect4{BEMProblem::compute_exterior_solution}  

// 我们还想知道一些关于外域中电势 $\phi$ 的值：毕竟我们考虑边界积分问题的动机是想知道外域中的速度!

// 为此，我们在此假设边界元素域包含在盒子 $[-2,2]^{\text{dim}}$ 中，我们用与基本解的卷积来推算这个盒子内的实际解。这方面的公式在介绍中已经给出。

// 整个空间的解的重建是在一个连续的、尺寸为dim的有限元网格上完成的。这些都是常用的，我们不做进一步评论。在函数的最后，我们再次以通常的方式输出这个外部解。

  template <int dim> 
  void BEMProblem<dim>::compute_exterior_solution() 
  { 
    Triangulation<dim> external_tria; 
    GridGenerator::hyper_cube(external_tria, -2, 2); 

    FE_Q<dim>       external_fe(1); 
    DoFHandler<dim> external_dh(external_tria); 
    Vector<double>  external_phi; 

    external_tria.refine_global(external_refinement); 
    external_dh.distribute_dofs(external_fe); 
    external_phi.reinit(external_dh.n_dofs()); 

    FEValues<dim - 1, dim> fe_v(mapping, 
                                fe, 
                                *quadrature, 
                                update_values | update_normal_vectors | 
                                  update_quadrature_points | update_JxW_values); 

    const unsigned int n_q_points = fe_v.n_quadrature_points; 

    std::vector<types::global_dof_index> dofs(fe.n_dofs_per_cell()); 

    std::vector<double>         local_phi(n_q_points); 
    std::vector<double>         normal_wind(n_q_points); 
    std::vector<Vector<double>> local_wind(n_q_points, Vector<double>(dim)); 

    std::vector<Point<dim>> external_support_points(external_dh.n_dofs()); 
    DoFTools::map_dofs_to_support_points<dim>(StaticMappingQ1<dim>::mapping, 
                                              external_dh, 
                                              external_support_points); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_v.reinit(cell); 

        const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points(); 
        const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors(); 

        cell->get_dof_indices(dofs); 
        fe_v.get_function_values(phi, local_phi); 

        wind.vector_value_list(q_points, local_wind); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            normal_wind[q] = 0; 
            for (unsigned int d = 0; d < dim; ++d) 
              normal_wind[q] += normals[q][d] * local_wind[q](d); 
          } 

        for (unsigned int i = 0; i < external_dh.n_dofs(); ++i) 
          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 
              const Tensor<1, dim> R = q_points[q] - external_support_points[i]; 

              external_phi(i) += 
                ((LaplaceKernel::single_layer(R) * normal_wind[q] + 
                  (LaplaceKernel::double_layer(R) * normals[q]) * 
                    local_phi[q]) * 
                 fe_v.JxW(q)); 
            } 
      } 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(external_dh); 
    data_out.add_data_vector(external_phi, "external_phi"); 
    data_out.build_patches(); 

    const std::string filename = std::to_string(dim) + "d_external.vtk"; 
    std::ofstream     file(filename); 

 
  } 
// @sect4{BEMProblem::output_results}  

// 输出我们的计算结果是一个相当机械的任务。这个函数的所有组成部分之前已经讨论过了。

  template <int dim> 
  void BEMProblem<dim>::output_results(const unsigned int cycle) 
  { 
    DataOut<dim - 1, dim> dataout; 

    dataout.attach_dof_handler(dof_handler); 
    dataout.add_data_vector(phi, "phi", DataOut<dim - 1, dim>::type_dof_data); 
    dataout.add_data_vector(alpha, 
                            "alpha", 
                            DataOut<dim - 1, dim>::type_dof_data); 
    dataout.build_patches(mapping, 
                          mapping.get_degree(), 
                          DataOut<dim - 1, dim>::curved_inner_cells); 

    const std::string filename = std::to_string(dim) + "d_boundary_solution_" + 
                                 std::to_string(cycle) + ".vtk"; 
    std::ofstream file(filename); 

    dataout.write_vtk(file); 

    if (cycle == n_cycles - 1) 
      { 
        convergence_table.set_precision("L2(phi)", 3); 
        convergence_table.set_precision("Linfty(alpha)", 3); 

        convergence_table.set_scientific("L2(phi)", true); 
        convergence_table.set_scientific("Linfty(alpha)", true); 

 
          "L2(phi)", ConvergenceTable::reduction_rate_log2); 
        convergence_table.evaluate_convergence_rates( 
          "Linfty(alpha)", ConvergenceTable::reduction_rate_log2); 
        deallog << std::endl; 
        convergence_table.write_text(std::cout); 
      } 
  } 
// @sect4{BEMProblem::run}  

// 这是最主要的功能。它应该是不言自明的。

  template <int dim> 
  void BEMProblem<dim>::run() 
  { 
    read_parameters("parameters.prm"); 

    if (run_in_this_dimension == false) 
      { 
        deallog << "Run in dimension " << dim 
                << " explicitly disabled in parameter file. " << std::endl; 
        return; 
      } 

    read_domain(); 

    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle) 
      { 
        refine_and_resize(); 
        assemble_system(); 
        solve_system(); 
        compute_errors(cycle); 
        output_results(cycle); 
      } 

    if (extend_solution == true) 
      compute_exterior_solution(); 
  } 
} // namespace Step34 
// @sect3{The main() function}  

// 这是本程序的主要功能。它与以前所有的教程程序完全一样。

int main() 
{ 
  try 
    { 
      using namespace Step34; 

      const unsigned int degree         = 1; 
      const unsigned int mapping_degree = 1; 

      deallog.depth_console(3); 
      BEMProblem<2> laplace_problem_2d(degree, mapping_degree); 
      laplace_problem_2d.run(); 

      BEMProblem<3> laplace_problem_3d(degree, mapping_degree); 
      laplace_problem_3d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-35.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Abner Salgado, Texas A&M University 2009 
 */ 


// @sect3{Include files}  

// 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。它们中的每一个都已经在以前的教程程序中讨论过了，所以我们在这里就不做详细介绍了。

#include <deal.II/base/parameter_handler.h> 
#include <deal.II/base/point.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/multithread_info.h> 
#include <deal.II/base/thread_management.h> 
#include <deal.II/base/work_stream.h> 
#include <deal.II/base/parallel.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/conditional_ostream.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/sparse_ilu.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/grid_in.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/dofs/dof_renumbering.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_tools.h> 
#include <deal.II/fe/fe_system.h> 

#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <cmath> 
#include <iostream> 

// 最后这和以前的所有程序一样。

namespace Step35 
{ 
  using namespace dealii; 
// @sect3{Run time parameters}  

// 由于我们的方法有几个可以微调的参数，我们把它们放到一个外部文件中，这样就可以在运行时确定它们。

// 这尤其包括辅助变量  $\phi$  的方程表述，为此我们声明一个  <code>enum</code>  。接下来，我们声明一个类，它将读取和存储我们的程序运行所需的所有参数。

  namespace RunTimeParameters 
  { 
    enum class Method 
    { 
      standard, 
      rotational 
    }; 

    class Data_Storage 
    { 
    public: 
      Data_Storage(); 

      void read_data(const std::string &filename); 

      Method form; 

      double dt; 
      double initial_time; 
      double final_time; 

      double Reynolds; 

      unsigned int n_global_refines; 

      unsigned int pressure_degree; 

      unsigned int vel_max_iterations; 
      unsigned int vel_Krylov_size; 
      unsigned int vel_off_diagonals; 
      unsigned int vel_update_prec; 
      double       vel_eps; 
      double       vel_diag_strength; 

      bool         verbose; 
      unsigned int output_interval; 

    protected: 
      ParameterHandler prm; 
    }; 

// 在这个类的构造函数中，我们声明所有的参数。这方面的细节已经在其他地方讨论过了，例如在  step-29  。

    Data_Storage::Data_Storage() 
      : form(Method::rotational) 
      , dt(5e-4) 
      , initial_time(0.) 
      , final_time(1.) 
      , Reynolds(1.) 
      , n_global_refines(0) 
      , pressure_degree(1) 
      , vel_max_iterations(1000) 
      , vel_Krylov_size(30) 
      , vel_off_diagonals(60) 
      , vel_update_prec(15) 
      , vel_eps(1e-12) 
      , vel_diag_strength(0.01) 
      , verbose(true) 
      , output_interval(15) 
    { 
      prm.declare_entry("Method_Form", 
                        "rotational", 
                        Patterns::Selection("rotational|standard"), 
                        " Used to select the type of method that we are going " 
                        "to use. "); 
      prm.enter_subsection("Physical data"); 
      { 
        prm.declare_entry("initial_time", 
                          "0.", 
                          Patterns::Double(0.), 
                          " The initial time of the simulation. "); 
        prm.declare_entry("final_time", 
                          "1.", 
                          Patterns::Double(0.), 
                          " The final time of the simulation. "); 
        prm.declare_entry("Reynolds", 
                          "1.", 
                          Patterns::Double(0.), 
                          " The Reynolds number. "); 
      } 
      prm.leave_subsection(); 

      prm.enter_subsection("Time step data"); 
      { 
        prm.declare_entry("dt", 
                          "5e-4", 
                          Patterns::Double(0.), 
                          " The time step size. "); 
      } 
      prm.leave_subsection(); 

      prm.enter_subsection("Space discretization"); 
      { 
        prm.declare_entry("n_of_refines", 
                          "0", 
                          Patterns::Integer(0, 15), 
                          " The number of global refines we do on the mesh. "); 
        prm.declare_entry("pressure_fe_degree", 
                          "1", 
                          Patterns::Integer(1, 5), 
                          " The polynomial degree for the pressure space. "); 
      } 
      prm.leave_subsection(); 

      prm.enter_subsection("Data solve velocity"); 
      { 
        prm.declare_entry( 
          "max_iterations", 
          "1000", 
          Patterns::Integer(1, 1000), 
          " The maximal number of iterations GMRES must make. "); 
        prm.declare_entry("eps", 
                          "1e-12", 
                          Patterns::Double(0.), 
                          " The stopping criterion. "); 
        prm.declare_entry("Krylov_size", 
                          "30", 
                          Patterns::Integer(1), 
                          " The size of the Krylov subspace to be used. "); 
        prm.declare_entry("off_diagonals", 
                          "60", 
                          Patterns::Integer(0), 
                          " The number of off-diagonal elements ILU must " 
                          "compute. "); 
        prm.declare_entry("diag_strength", 
                          "0.01", 
                          Patterns::Double(0.), 
                          " Diagonal strengthening coefficient. "); 
        prm.declare_entry("update_prec", 
                          "15", 
                          Patterns::Integer(1), 
                          " This number indicates how often we need to " 
                          "update the preconditioner"); 
      } 
      prm.leave_subsection(); 

      prm.declare_entry("verbose", 
                        "true", 
                        Patterns::Bool(), 
                        " This indicates whether the output of the solution " 
                        "process should be verbose. "); 

      prm.declare_entry("output_interval", 
                        "1", 
                        Patterns::Integer(1), 
                        " This indicates between how many time steps we print " 
                        "the solution. "); 
    } 

    void Data_Storage::read_data(const std::string &filename) 
    { 
      std::ifstream file(filename); 
      AssertThrow(file, ExcFileNotOpen(filename)); 

      prm.parse_input(file); 

      if (prm.get("Method_Form") == std::string("rotational")) 
        form = Method::rotational; 
      else 
        form = Method::standard; 

      prm.enter_subsection("Physical data"); 
      { 
        initial_time = prm.get_double("initial_time"); 
        final_time   = prm.get_double("final_time"); 
        Reynolds     = prm.get_double("Reynolds"); 
      } 
      prm.leave_subsection(); 

      prm.enter_subsection("Time step data"); 
      { 
        dt = prm.get_double("dt"); 
      } 
      prm.leave_subsection(); 

      prm.enter_subsection("Space discretization"); 
      { 
        n_global_refines = prm.get_integer("n_of_refines"); 
        pressure_degree  = prm.get_integer("pressure_fe_degree"); 
      } 
      prm.leave_subsection(); 

      prm.enter_subsection("Data solve velocity"); 
      { 
        vel_max_iterations = prm.get_integer("max_iterations"); 
        vel_eps            = prm.get_double("eps"); 
        vel_Krylov_size    = prm.get_integer("Krylov_size"); 
        vel_off_diagonals  = prm.get_integer("off_diagonals"); 
        vel_diag_strength  = prm.get_double("diag_strength"); 
        vel_update_prec    = prm.get_integer("update_prec"); 
      } 
      prm.leave_subsection(); 

      verbose = prm.get_bool("verbose"); 

      output_interval = prm.get_integer("output_interval"); 
    } 
  } // namespace RunTimeParameters 

//  @sect3{Equation data}  

// 在下一个命名空间中，我们声明初始和边界条件。

  namespace EquationData 
  { 

// 由于我们选择了一个完全解耦的公式，我们将不利用deal.II处理矢量值问题的能力。然而，我们确实希望为方程数据使用一个独立于维度的接口。为了做到这一点，我们的函数应该能够知道我们目前在哪个空间分量上工作，而且我们应该能够有一个通用的接口来做到这一点。下面的类是在这个方向上的一个尝试。

    template <int dim> 
    class MultiComponentFunction : public Function<dim> 
    { 
    public: 
      MultiComponentFunction(const double initial_time = 0.); 
      void set_component(const unsigned int d); 

    protected: 
      unsigned int comp; 
    }; 

    template <int dim> 
    MultiComponentFunction<dim>::MultiComponentFunction( 
      const double initial_time) 
      : Function<dim>(1, initial_time) 
      , comp(0) 
    {} 

    template <int dim> 
    void MultiComponentFunction<dim>::set_component(const unsigned int d) 
    { 
      Assert(d < dim, ExcIndexRange(d, 0, dim)); 
      comp = d; 
    } 

// 有了这个类的定义，我们声明描述速度和压力的边界条件的类。

    template <int dim> 
    class Velocity : public MultiComponentFunction<dim> 
    { 
    public: 
      Velocity(const double initial_time = 0.0); 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 

      virtual void value_list(const std::vector<Point<dim>> &points, 
                              std::vector<double> &          values, 
                              const unsigned int component = 0) const override; 
    }; 

    template <int dim> 
    Velocity<dim>::Velocity(const double initial_time) 
      : MultiComponentFunction<dim>(initial_time) 
    {} 

    template <int dim> 
    void Velocity<dim>::value_list(const std::vector<Point<dim>> &points, 
                                   std::vector<double> &          values, 
                                   const unsigned int) const 
    { 
      const unsigned int n_points = points.size(); 
      Assert(values.size() == n_points, 
             ExcDimensionMismatch(values.size(), n_points)); 
      for (unsigned int i = 0; i < n_points; ++i) 
        values[i] = Velocity<dim>::value(points[i]); 
    } 

    template <int dim> 
    double Velocity<dim>::value(const Point<dim> &p, const unsigned int) const 
    { 
      if (this->comp == 0) 
        { 
          const double Um = 1.5; 
          const double H  = 4.1; 
          return 4. * Um * p(1) * (H - p(1)) / (H * H); 
        } 
      else 
        return 0.; 
    } 

    template <int dim> 
    class Pressure : public Function<dim> 
    { 
    public: 
      Pressure(const double initial_time = 0.0); 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 

      virtual void value_list(const std::vector<Point<dim>> &points, 
                              std::vector<double> &          values, 
                              const unsigned int component = 0) const override; 
    }; 

    template <int dim> 
    Pressure<dim>::Pressure(const double initial_time) 
      : Function<dim>(1, initial_time) 
    {} 

    template <int dim> 
    double Pressure<dim>::value(const Point<dim> & p, 
                                const unsigned int component) const 
    { 
      (void)component; 
      AssertIndexRange(component, 1); 
      return 25. - p(0); 
    } 

    template <int dim> 
    void Pressure<dim>::value_list(const std::vector<Point<dim>> &points, 
                                   std::vector<double> &          values, 
                                   const unsigned int component) const 
    { 
      (void)component; 
      AssertIndexRange(component, 1); 
      const unsigned int n_points = points.size(); 
      Assert(values.size() == n_points, 
             ExcDimensionMismatch(values.size(), n_points)); 
      for (unsigned int i = 0; i < n_points; ++i) 
        values[i] = Pressure<dim>::value(points[i]); 
    } 
  } // namespace EquationData 

//  @sect3{The <code>NavierStokesProjection</code> class}  

// 现在是程序的主类。它实现了纳维-斯托克斯方程的各种版本的投影方法。考虑到介绍中给出的实现细节，所有方法和成员变量的名称应该是不言自明的。

  template <int dim> 
  class NavierStokesProjection 
  { 
  public: 
    NavierStokesProjection(const RunTimeParameters::Data_Storage &data); 

    void run(const bool verbose = false, const unsigned int n_plots = 10); 

  protected: 
    RunTimeParameters::Method type; 

    const unsigned int deg; 
    const double       dt; 
    const double       t_0; 
    const double       T; 
    const double       Re; 

    EquationData::Velocity<dim>               vel_exact; 
    std::map<types::global_dof_index, double> boundary_values; 
    std::vector<types::boundary_id>           boundary_ids; 

    Triangulation<dim> triangulation; 

    FE_Q<dim> fe_velocity; 
    FE_Q<dim> fe_pressure; 

    DoFHandler<dim> dof_handler_velocity; 
    DoFHandler<dim> dof_handler_pressure; 

    QGauss<dim> quadrature_pressure; 
    QGauss<dim> quadrature_velocity; 

    SparsityPattern sparsity_pattern_velocity; 
    SparsityPattern sparsity_pattern_pressure; 
    SparsityPattern sparsity_pattern_pres_vel; 

    SparseMatrix<double> vel_Laplace_plus_Mass; 
    SparseMatrix<double> vel_it_matrix[dim]; 
    SparseMatrix<double> vel_Mass; 
    SparseMatrix<double> vel_Laplace; 
    SparseMatrix<double> vel_Advection; 
    SparseMatrix<double> pres_Laplace; 
    SparseMatrix<double> pres_Mass; 
    SparseMatrix<double> pres_Diff[dim]; 
    SparseMatrix<double> pres_iterative; 

    Vector<double> pres_n; 
    Vector<double> pres_n_minus_1; 
    Vector<double> phi_n; 
    Vector<double> phi_n_minus_1; 
    Vector<double> u_n[dim]; 
    Vector<double> u_n_minus_1[dim]; 
    Vector<double> u_star[dim]; 
    Vector<double> force[dim]; 
    Vector<double> v_tmp; 
    Vector<double> pres_tmp; 
    Vector<double> rot_u; 

    SparseILU<double>   prec_velocity[dim]; 
    SparseILU<double>   prec_pres_Laplace; 
    SparseDirectUMFPACK prec_mass; 
    SparseDirectUMFPACK prec_vel_mass; 

    DeclException2(ExcInvalidTimeStep, 
                   double, 
                   double, 
                   << " The time step " << arg1 << " is out of range." 
                   << std::endl 
                   << " The permitted range is (0," << arg2 << "]"); 

    void create_triangulation_and_dofs(const unsigned int n_refines); 

    void initialize(); 

    void interpolate_velocity(); 

    void diffusion_step(const bool reinit_prec); 

    void projection_step(const bool reinit_prec); 

    void update_pressure(const bool reinit_prec); 

  private: 
    unsigned int vel_max_its; 
    unsigned int vel_Krylov_size; 
    unsigned int vel_off_diagonals; 
    unsigned int vel_update_prec; 
    double       vel_eps; 
    double       vel_diag_strength; 

    void initialize_velocity_matrices(); 

    void initialize_pressure_matrices(); 

// 接下来的几个结构和函数是用来做各种并行的事情。它们遵循 @ref threads 中规定的方案，使用WorkStream类。正如那里所解释的，这需要我们为每个装配器声明两个结构，一个是每个任务的数据，一个是scratch数据结构。然后，这些结构被移交给组装本地贡献的函数，并将这些本地贡献复制到全局对象上。

// 这个程序的一个特殊之处在于，我们并不是只有一个DoFHandler对象来代表速度和压力，而是为这两种变量使用单独的DoFHandler对象。当我们想把涉及这两个变量的条款，如速度的发散和压力的梯度，乘以各自的测试函数时，我们要为这种优化付费。在这样做的时候，我们不能只使用一个FEValues对象，而是需要两个，而且需要用单元格迭代器来初始化它们，这些单元格迭代器指向三角形中的同一个单元格，但不同的DoFHandlers。

// 为了在实践中做到这一点，我们声明一个 "同步 "迭代器--一个内部由几个（在我们的例子中是两个）迭代器组成的对象，每次同步迭代器向前移动一步，内部存储的每个迭代器也向前移动一步，从而始终保持同步。碰巧的是，有一个deal.II类可以促进这种事情。这里重要的是要知道，建立在同一个三角形上的两个DoFHandler对象将以相同的顺序走过三角形的单元。

    using IteratorTuple = 
      std::tuple<typename DoFHandler<dim>::active_cell_iterator, 
                 typename DoFHandler<dim>::active_cell_iterator>; 

    using IteratorPair = SynchronousIterators<IteratorTuple>; 

    void initialize_gradient_operator(); 

    struct InitGradPerTaskData 
    { 
      unsigned int                         d; 
      unsigned int                         vel_dpc; 
      unsigned int                         pres_dpc; 
      FullMatrix<double>                   local_grad; 
      std::vector<types::global_dof_index> vel_local_dof_indices; 
      std::vector<types::global_dof_index> pres_local_dof_indices; 

      InitGradPerTaskData(const unsigned int dd, 
                          const unsigned int vdpc, 
                          const unsigned int pdpc) 
        : d(dd) 
        , vel_dpc(vdpc) 
        , pres_dpc(pdpc) 
        , local_grad(vdpc, pdpc) 
        , vel_local_dof_indices(vdpc) 
        , pres_local_dof_indices(pdpc) 
      {} 
    }; 

    struct InitGradScratchData 
    { 
      unsigned int  nqp; 
      FEValues<dim> fe_val_vel; 
      FEValues<dim> fe_val_pres; 
      InitGradScratchData(const FE_Q<dim> &  fe_v, 
                          const FE_Q<dim> &  fe_p, 
                          const QGauss<dim> &quad, 
                          const UpdateFlags  flags_v, 
                          const UpdateFlags  flags_p) 
        : nqp(quad.size()) 
        , fe_val_vel(fe_v, quad, flags_v) 
        , fe_val_pres(fe_p, quad, flags_p) 
      {} 
      InitGradScratchData(const InitGradScratchData &data) 
        : nqp(data.nqp) 
        , fe_val_vel(data.fe_val_vel.get_fe(), 
                     data.fe_val_vel.get_quadrature(), 
                     data.fe_val_vel.get_update_flags()) 
        , fe_val_pres(data.fe_val_pres.get_fe(), 
                      data.fe_val_pres.get_quadrature(), 
                      data.fe_val_pres.get_update_flags()) 
      {} 
    }; 

    void assemble_one_cell_of_gradient(const IteratorPair & SI, 
                                       InitGradScratchData &scratch, 
                                       InitGradPerTaskData &data); 

    void copy_gradient_local_to_global(const InitGradPerTaskData &data); 

// 同样的一般布局也适用于以下实现平流项组装的类和函数。

    void assemble_advection_term(); 

    struct AdvectionPerTaskData 
    { 
      FullMatrix<double>                   local_advection; 
      std::vector<types::global_dof_index> local_dof_indices; 
      AdvectionPerTaskData(const unsigned int dpc) 
        : local_advection(dpc, dpc) 
        , local_dof_indices(dpc) 
      {} 
    }; 

    struct AdvectionScratchData 
    { 
      unsigned int                nqp; 
      unsigned int                dpc; 
      std::vector<Point<dim>>     u_star_local; 
      std::vector<Tensor<1, dim>> grad_u_star; 
      std::vector<double>         u_star_tmp; 
      FEValues<dim>               fe_val; 
      AdvectionScratchData(const FE_Q<dim> &  fe, 
                           const QGauss<dim> &quad, 
                           const UpdateFlags  flags) 
        : nqp(quad.size()) 
        , dpc(fe.n_dofs_per_cell()) 
        , u_star_local(nqp) 
        , grad_u_star(nqp) 
        , u_star_tmp(nqp) 
        , fe_val(fe, quad, flags) 
      {} 

      AdvectionScratchData(const AdvectionScratchData &data) 
        : nqp(data.nqp) 
        , dpc(data.dpc) 
        , u_star_local(nqp) 
        , grad_u_star(nqp) 
        , u_star_tmp(nqp) 
        , fe_val(data.fe_val.get_fe(), 
                 data.fe_val.get_quadrature(), 
                 data.fe_val.get_update_flags()) 
      {} 
    }; 

    void assemble_one_cell_of_advection( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      AdvectionScratchData &                                scratch, 
      AdvectionPerTaskData &                                data); 

    void copy_advection_local_to_global(const AdvectionPerTaskData &data); 

// 最后几个函数实现了扩散解以及输出的后处理，包括计算速度的曲线。

    void diffusion_component_solve(const unsigned int d); 

    void output_results(const unsigned int step); 

    void assemble_vorticity(const bool reinit_prec); 
  }; 

//  @sect4{ <code>NavierStokesProjection::NavierStokesProjection</code> }  

// 在构造函数中，我们只是从作为参数传递的 <code>Data_Storage</code> 对象中读取所有数据，验证我们读取的数据是否合理，最后，创建三角形并加载初始数据。

  template <int dim> 
  NavierStokesProjection<dim>::NavierStokesProjection( 
    const RunTimeParameters::Data_Storage &data) 
    : type(data.form) 
    , deg(data.pressure_degree) 
    , dt(data.dt) 
    , t_0(data.initial_time) 
    , T(data.final_time) 
    , Re(data.Reynolds) 
    , vel_exact(data.initial_time) 
    , fe_velocity(deg + 1) 
    , fe_pressure(deg) 
    , dof_handler_velocity(triangulation) 
    , dof_handler_pressure(triangulation) 
    , quadrature_pressure(deg + 1) 
    , quadrature_velocity(deg + 2) 
    , vel_max_its(data.vel_max_iterations) 
    , vel_Krylov_size(data.vel_Krylov_size) 
    , vel_off_diagonals(data.vel_off_diagonals) 
    , vel_update_prec(data.vel_update_prec) 
    , vel_eps(data.vel_eps) 
    , vel_diag_strength(data.vel_diag_strength) 
  { 
    if (deg < 1) 
      std::cout 
        << " WARNING: The chosen pair of finite element spaces is not stable." 
        << std::endl 
        << " The obtained results will be nonsense" << std::endl; 

    AssertThrow(!((dt <= 0.) || (dt > .5 * T)), ExcInvalidTimeStep(dt, .5 * T)); 

    create_triangulation_and_dofs(data.n_global_refines); 
    initialize(); 
  } 
// @sect4{<code>NavierStokesProjection::create_triangulation_and_dofs</code>}  

// 创建三角形的方法，并将其细化到所需的次数。在创建三角形之后，它创建了与网格相关的数据，即分配自由度和重新编号，并初始化我们将使用的矩阵和向量。

  template <int dim> 
  void NavierStokesProjection<dim>::create_triangulation_and_dofs( 
    const unsigned int n_refines) 
  { 
    GridIn<dim> grid_in; 
    grid_in.attach_triangulation(triangulation); 

    { 
      std::string   filename = "nsbench2.inp"; 
      std::ifstream file(filename); 
      Assert(file, ExcFileNotOpen(filename.c_str())); 
      grid_in.read_ucd(file); 
    } 

    std::cout << "Number of refines = " << n_refines << std::endl; 
    triangulation.refine_global(n_refines); 
    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl; 

    boundary_ids = triangulation.get_boundary_ids(); 

 
    DoFRenumbering::boost::Cuthill_McKee(dof_handler_velocity); 
    dof_handler_pressure.distribute_dofs(fe_pressure); 
    DoFRenumbering::boost::Cuthill_McKee(dof_handler_pressure); 

    initialize_velocity_matrices(); 
    initialize_pressure_matrices(); 
    initialize_gradient_operator(); 

    pres_n.reinit(dof_handler_pressure.n_dofs()); 
    pres_n_minus_1.reinit(dof_handler_pressure.n_dofs()); 
    phi_n.reinit(dof_handler_pressure.n_dofs()); 
    phi_n_minus_1.reinit(dof_handler_pressure.n_dofs()); 
    pres_tmp.reinit(dof_handler_pressure.n_dofs()); 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        u_n[d].reinit(dof_handler_velocity.n_dofs()); 
        u_n_minus_1[d].reinit(dof_handler_velocity.n_dofs()); 
        u_star[d].reinit(dof_handler_velocity.n_dofs()); 
        force[d].reinit(dof_handler_velocity.n_dofs()); 
      } 
    v_tmp.reinit(dof_handler_velocity.n_dofs()); 
    rot_u.reinit(dof_handler_velocity.n_dofs()); 

    std::cout << "dim (X_h) = " << (dof_handler_velocity.n_dofs() * dim) // 
              << std::endl                                               // 
              << "dim (M_h) = " << dof_handler_pressure.n_dofs()         // 
              << std::endl                                               // 
              << "Re        = " << Re << std::endl                       // 
              << std::endl; 
  } 
// @sect4{ <code>NavierStokesProjection::initialize</code> }  

// 该方法创建常数矩阵并加载初始数据。

  template <int dim> 
  void NavierStokesProjection<dim>::initialize() 
  { 
    vel_Laplace_plus_Mass = 0.; 
    vel_Laplace_plus_Mass.add(1. / Re, vel_Laplace); 
    vel_Laplace_plus_Mass.add(1.5 / dt, vel_Mass); 

    EquationData::Pressure<dim> pres(t_0); 
    VectorTools::interpolate(dof_handler_pressure, pres, pres_n_minus_1); 
    pres.advance_time(dt); 
    VectorTools::interpolate(dof_handler_pressure, pres, pres_n); 
    phi_n         = 0.; 
    phi_n_minus_1 = 0.; 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        vel_exact.set_time(t_0); 
        vel_exact.set_component(d); 
        VectorTools::interpolate(dof_handler_velocity, 
                                 vel_exact, 
                                 u_n_minus_1[d]); 
        vel_exact.advance_time(dt); 
        VectorTools::interpolate(dof_handler_velocity, vel_exact, u_n[d]); 
      } 
  } 
// @sect4{ <code>NavierStokesProjection::initialize_*_matrices</code> }  

// 在这组方法中，我们初始化了稀疏模式、约束条件（如果有的话）并组装了不依赖于时间步长的矩阵  <code>dt</code>  。请注意，对于拉普拉斯矩阵和质量矩阵，我们可以使用库中的函数来做这件事。因为这个函数的昂贵操作--创建两个矩阵--是完全独立的，我们原则上可以把它们标记为可以使用 Threads::new_task 函数进行%并行工作的任务。我们不会在这里这样做，因为这些函数在内部已经被并行化了，特别是由于当前的函数在每个程序运行中只被调用一次，所以在每个时间步长中不会产生费用。然而，必要的修改将是非常直接的。

  template <int dim> 
  void NavierStokesProjection<dim>::initialize_velocity_matrices() 
  { 
    { 
      DynamicSparsityPattern dsp(dof_handler_velocity.n_dofs(), 
                                 dof_handler_velocity.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler_velocity, dsp); 
      sparsity_pattern_velocity.copy_from(dsp); 
    } 
    vel_Laplace_plus_Mass.reinit(sparsity_pattern_velocity); 
    for (unsigned int d = 0; d < dim; ++d) 
      vel_it_matrix[d].reinit(sparsity_pattern_velocity); 
    vel_Mass.reinit(sparsity_pattern_velocity); 
    vel_Laplace.reinit(sparsity_pattern_velocity); 
    vel_Advection.reinit(sparsity_pattern_velocity); 

    MatrixCreator::create_mass_matrix(dof_handler_velocity, 
                                      quadrature_velocity, 
                                      vel_Mass); 
    MatrixCreator::create_laplace_matrix(dof_handler_velocity, 
                                         quadrature_velocity, 
                                         vel_Laplace); 
  } 

//作用于压力空间的矩阵的初始化与作用于速度空间的矩阵相似。

  template <int dim> 
  void NavierStokesProjection<dim>::initialize_pressure_matrices() 
  { 
    { 
      DynamicSparsityPattern dsp(dof_handler_pressure.n_dofs(), 
                                 dof_handler_pressure.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler_pressure, dsp); 
      sparsity_pattern_pressure.copy_from(dsp); 
    } 

    pres_Laplace.reinit(sparsity_pattern_pressure); 
    pres_iterative.reinit(sparsity_pattern_pressure); 
    pres_Mass.reinit(sparsity_pattern_pressure); 

    MatrixCreator::create_laplace_matrix(dof_handler_pressure, 
                                         quadrature_pressure, 
                                         pres_Laplace); 
    MatrixCreator::create_mass_matrix(dof_handler_pressure, 
                                      quadrature_pressure, 
                                      pres_Mass); 
  } 

// 对于梯度算子，我们从初始化稀疏模式和压缩它开始。这里需要注意的是，梯度算子从压力空间作用到速度空间，所以我们必须处理两个不同的有限元空间。为了保持循环的同步，我们使用之前定义的别名，即 <code>PairedIterators</code> and <code>IteratorPair</code>  。

  template <int dim> 
  void NavierStokesProjection<dim>::initialize_gradient_operator() 
  { 
    { 
      DynamicSparsityPattern dsp(dof_handler_velocity.n_dofs(), 
                                 dof_handler_pressure.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler_velocity, 
                                      dof_handler_pressure, 
                                      dsp); 
      sparsity_pattern_pres_vel.copy_from(dsp); 
    } 

    InitGradPerTaskData per_task_data(0, 
                                      fe_velocity.n_dofs_per_cell(), 
                                      fe_pressure.n_dofs_per_cell()); 
    InitGradScratchData scratch_data(fe_velocity, 
                                     fe_pressure, 
                                     quadrature_velocity, 
                                     update_gradients | update_JxW_values, 
                                     update_values); 

    for (unsigned int d = 0; d < dim; ++d) 
      { 
        pres_Diff[d].reinit(sparsity_pattern_pres_vel); 
        per_task_data.d = d; 
        WorkStream::run( 
          IteratorPair(IteratorTuple(dof_handler_velocity.begin_active(), 
                                     dof_handler_pressure.begin_active())), 
          IteratorPair(IteratorTuple(dof_handler_velocity.end(), 
                                     dof_handler_pressure.end())), 
          *this, 
          &NavierStokesProjection<dim>::assemble_one_cell_of_gradient, 
          &NavierStokesProjection<dim>::copy_gradient_local_to_global, 
          scratch_data, 
          per_task_data); 
      } 
  } 

  template <int dim> 
  void NavierStokesProjection<dim>::assemble_one_cell_of_gradient( 
    const IteratorPair & SI, 
    InitGradScratchData &scratch, 
    InitGradPerTaskData &data) 
  { 
    scratch.fe_val_vel.reinit(std::get<0>(*SI)); 
    scratch.fe_val_pres.reinit(std::get<1>(*SI)); 

    std::get<0>(*SI)->get_dof_indices(data.vel_local_dof_indices); 
    std::get<1>(*SI)->get_dof_indices(data.pres_local_dof_indices); 

    data.local_grad = 0.; 
    for (unsigned int q = 0; q < scratch.nqp; ++q) 
      { 
        for (unsigned int i = 0; i < data.vel_dpc; ++i) 
          for (unsigned int j = 0; j < data.pres_dpc; ++j) 
            data.local_grad(i, j) += 
              -scratch.fe_val_vel.JxW(q) * 
              scratch.fe_val_vel.shape_grad(i, q)[data.d] * 
              scratch.fe_val_pres.shape_value(j, q); 
      } 
  } 

  template <int dim> 
  void NavierStokesProjection<dim>::copy_gradient_local_to_global( 
    const InitGradPerTaskData &data) 
  { 
    for (unsigned int i = 0; i < data.vel_dpc; ++i) 
      for (unsigned int j = 0; j < data.pres_dpc; ++j) 
        pres_Diff[data.d].add(data.vel_local_dof_indices[i], 
                              data.pres_local_dof_indices[j], 
                              data.local_grad(i, j)); 
  } 
// @sect4{ <code>NavierStokesProjection::run</code> }  

// 这是时间行进函数，从 <code>t_0</code> 开始，使用时间步长 <code>dt</code> 的投影法在时间上前进，直到 <code>T</code>  。

// 它的第二个参数 <code>verbose</code> 表示该函数是否应该输出它在任何特定时刻正在做什么的信息：例如，它将说明我们是否正在进行扩散、投影子步骤；更新前置条件器等等。我们没有使用像
// @code
//    if (verbose) std::cout << "something";
//  @endcode
//  那样的代码来实现这种输出，而是使用ConditionalOStream类来为我们做这个。该类接受一个输出流和一个条件，该条件表明你传递给它的东西是否应该被传递到给定的输出流，或者应该被忽略。这样，上面的代码就变成了
//  @code
//    verbose_cout << "something";
//  @endcode，并且在任何情况下都会做正确的事情。

  template <int dim> 
  void NavierStokesProjection<dim>::run(const bool         verbose, 
                                        const unsigned int output_interval) 
  { 
    ConditionalOStream verbose_cout(std::cout, verbose); 

    const auto n_steps = static_cast<unsigned int>((T - t_0) / dt); 
    vel_exact.set_time(2. * dt); 
    output_results(1); 
    for (unsigned int n = 2; n <= n_steps; ++n) 
      { 
        if (n % output_interval == 0) 
          { 
            verbose_cout << "Plotting Solution" << std::endl; 
            output_results(n); 
          } 
        std::cout << "Step = " << n << " Time = " << (n * dt) << std::endl; 
        verbose_cout << "  Interpolating the velocity " << std::endl; 

        interpolate_velocity(); 
        verbose_cout << "  Diffusion Step" << std::endl; 
        if (n % vel_update_prec == 0) 
          verbose_cout << "    With reinitialization of the preconditioner" 
                       << std::endl; 
        diffusion_step((n % vel_update_prec == 0) || (n == 2)); 
        verbose_cout << "  Projection Step" << std::endl; 
        projection_step((n == 2)); 
        verbose_cout << "  Updating the Pressure" << std::endl; 
        update_pressure((n == 2)); 
        vel_exact.advance_time(dt); 
      } 
    output_results(n_steps); 
  } 

  template <int dim> 
  void NavierStokesProjection<dim>::interpolate_velocity() 
  { 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        u_star[d].equ(2., u_n[d]); 
        u_star[d] -= u_n_minus_1[d]; 
      } 
  } 
// @sect4{<code>NavierStokesProjection::diffusion_step</code>}  

// 扩散步骤的实现。请注意，昂贵的操作是函数末尾的扩散解，我们必须为每个速度分量做一次。为了加快进度，我们允许以%并行方式进行，使用 Threads::new_task 函数，确保 <code>dim</code> 的求解都得到处理，并被安排到可用的处理器上：如果你的机器有一个以上的处理器核心，并且这个程序的其他部分目前没有使用资源，那么扩散求解将以%并行方式运行。另一方面，如果你的系统只有一个处理器核心，那么以%并行方式运行将是低效的（因为它导致了，例如，缓存拥堵），事情将被顺序地执行。

  template <int dim> 
  void NavierStokesProjection<dim>::diffusion_step(const bool reinit_prec) 
  { 
    pres_tmp.equ(-1., pres_n); 
    pres_tmp.add(-4. / 3., phi_n, 1. / 3., phi_n_minus_1); 

    assemble_advection_term(); 

    for (unsigned int d = 0; d < dim; ++d) 
      { 
        force[d] = 0.; 
        v_tmp.equ(2. / dt, u_n[d]); 
        v_tmp.add(-.5 / dt, u_n_minus_1[d]); 
        vel_Mass.vmult_add(force[d], v_tmp); 

        pres_Diff[d].vmult_add(force[d], pres_tmp); 
        u_n_minus_1[d] = u_n[d]; 

        vel_it_matrix[d].copy_from(vel_Laplace_plus_Mass); 
        vel_it_matrix[d].add(1., vel_Advection); 

        vel_exact.set_component(d); 
        boundary_values.clear(); 
        for (const auto &boundary_id : boundary_ids) 
          { 
            switch (boundary_id) 
              { 
                case 1: 
                  VectorTools::interpolate_boundary_values( 
                    dof_handler_velocity, 
                    boundary_id, 
                    Functions::ZeroFunction<dim>(), 
                    boundary_values); 
                  break; 
                case 2: 
                  VectorTools::interpolate_boundary_values(dof_handler_velocity, 
                                                           boundary_id, 
                                                           vel_exact, 
                                                           boundary_values); 
                  break; 
                case 3: 
                  if (d != 0) 
                    VectorTools::interpolate_boundary_values( 
                      dof_handler_velocity, 
                      boundary_id, 
                      Functions::ZeroFunction<dim>(), 
                      boundary_values); 
                  break; 
                case 4: 
                  VectorTools::interpolate_boundary_values( 
                    dof_handler_velocity, 
                    boundary_id, 
                    Functions::ZeroFunction<dim>(), 
                    boundary_values); 
                  break; 
                default: 
                  Assert(false, ExcNotImplemented()); 
              } 
          } 
        MatrixTools::apply_boundary_values(boundary_values, 
                                           vel_it_matrix[d], 
                                           u_n[d], 
                                           force[d]); 
      } 

    Threads::TaskGroup<void> tasks; 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        if (reinit_prec) 
          prec_velocity[d].initialize(vel_it_matrix[d], 
                                      SparseILU<double>::AdditionalData( 
                                        vel_diag_strength, vel_off_diagonals)); 
        tasks += Threads::new_task( 
          &NavierStokesProjection<dim>::diffusion_component_solve, *this, d); 
      } 
    tasks.join_all(); 
  } 

  template <int dim> 
  void 
  NavierStokesProjection<dim>::diffusion_component_solve(const unsigned int d) 
  { 
    SolverControl solver_control(vel_max_its, vel_eps * force[d].l2_norm()); 
    SolverGMRES<Vector<double>> gmres( 
      solver_control, 
      SolverGMRES<Vector<double>>::AdditionalData(vel_Krylov_size)); 
    gmres.solve(vel_it_matrix[d], u_n[d], force[d], prec_velocity[d]); 
  } 
// @sect4{ <code>NavierStokesProjection::assemble_advection_term</code> }  

// 下面的几个函数是关于集合平流项的，平流项是扩散步骤的系统矩阵的一部分，在每个时间步骤中都会发生变化。如上所述，我们将使用WorkStream类和文件模块 @ref threads 中描述的其他设施，在所有单元上平行运行装配循环。

  template <int dim> 
  void NavierStokesProjection<dim>::assemble_advection_term() 
  { 
    vel_Advection = 0.; 
    AdvectionPerTaskData data(fe_velocity.n_dofs_per_cell()); 
    AdvectionScratchData scratch(fe_velocity, 
                                 quadrature_velocity, 
                                 update_values | update_JxW_values | 
                                   update_gradients); 
    WorkStream::run( 
      dof_handler_velocity.begin_active(), 
      dof_handler_velocity.end(), 
      *this, 
      &NavierStokesProjection<dim>::assemble_one_cell_of_advection, 
      &NavierStokesProjection<dim>::copy_advection_local_to_global, 
      scratch, 
      data); 
  } 

  template <int dim> 
  void NavierStokesProjection<dim>::assemble_one_cell_of_advection( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    AdvectionScratchData &                                scratch, 
    AdvectionPerTaskData &                                data) 
  { 
    scratch.fe_val.reinit(cell); 
    cell->get_dof_indices(data.local_dof_indices); 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        scratch.fe_val.get_function_values(u_star[d], scratch.u_star_tmp); 
        for (unsigned int q = 0; q < scratch.nqp; ++q) 
          scratch.u_star_local[q](d) = scratch.u_star_tmp[q]; 
      } 

    for (unsigned int d = 0; d < dim; ++d) 
      { 
        scratch.fe_val.get_function_gradients(u_star[d], scratch.grad_u_star); 
        for (unsigned int q = 0; q < scratch.nqp; ++q) 
          { 
            if (d == 0) 
              scratch.u_star_tmp[q] = 0.; 
            scratch.u_star_tmp[q] += scratch.grad_u_star[q][d]; 
          } 
      } 

    data.local_advection = 0.; 
    for (unsigned int q = 0; q < scratch.nqp; ++q) 
      for (unsigned int i = 0; i < scratch.dpc; ++i) 
        for (unsigned int j = 0; j < scratch.dpc; ++j) 
          data.local_advection(i, j) += (scratch.u_star_local[q] *            // 
                                           scratch.fe_val.shape_grad(j, q) *  // 
                                           scratch.fe_val.shape_value(i, q)   // 
                                         +                                    // 
                                         0.5 *                                // 
                                           scratch.u_star_tmp[q] *            // 
                                           scratch.fe_val.shape_value(i, q) * // 
                                           scratch.fe_val.shape_value(j, q))  // 
                                        * scratch.fe_val.JxW(q); 
  } 

  template <int dim> 
  void NavierStokesProjection<dim>::copy_advection_local_to_global( 
    const AdvectionPerTaskData &data) 
  { 
    for (unsigned int i = 0; i < fe_velocity.n_dofs_per_cell(); ++i) 
      for (unsigned int j = 0; j < fe_velocity.n_dofs_per_cell(); ++j) 
        vel_Advection.add(data.local_dof_indices[i], 
                          data.local_dof_indices[j], 
                          data.local_advection(i, j)); 
  } 

//  @sect4{<code>NavierStokesProjection::projection_step</code>}  

// 这实现了投影的步骤。

  template <int dim> 
  void NavierStokesProjection<dim>::projection_step(const bool reinit_prec) 
  { 
    pres_iterative.copy_from(pres_Laplace); 

    pres_tmp = 0.; 
    for (unsigned d = 0; d < dim; ++d) 
      pres_Diff[d].Tvmult_add(pres_tmp, u_n[d]); 

    phi_n_minus_1 = phi_n; 

    static std::map<types::global_dof_index, double> bval; 
    if (reinit_prec) 
      VectorTools::interpolate_boundary_values(dof_handler_pressure, 
                                               3, 
                                               Functions::ZeroFunction<dim>(), 
                                               bval); 

    MatrixTools::apply_boundary_values(bval, pres_iterative, phi_n, pres_tmp); 

    if (reinit_prec) 
      prec_pres_Laplace.initialize(pres_iterative, 
                                   SparseILU<double>::AdditionalData( 
                                     vel_diag_strength, vel_off_diagonals)); 

    SolverControl solvercontrol(vel_max_its, vel_eps * pres_tmp.l2_norm()); 
    SolverCG<Vector<double>> cg(solvercontrol); 
    cg.solve(pres_iterative, phi_n, pres_tmp, prec_pres_Laplace); 

    phi_n *= 1.5 / dt; 
  } 
// @sect4{ <code>NavierStokesProjection::update_pressure</code> }  

// 这是投影法的压力更新步骤。它实现了该方法的标准表述，即
//  @f[ p^{n+1} = p^n +
//  \phi^{n+1}, 
//  @f]
//  或旋转形式，即
//  @f[ p^{n+1} = p^n +
//  \phi^{n+1} - \frac{1}{Re} \nabla\cdot u^{n+1}. 
//  @f] 

  template <int dim> 
  void NavierStokesProjection<dim>::update_pressure(const bool reinit_prec) 
  { 
    pres_n_minus_1 = pres_n; 
    switch (type) 
      { 
        case RunTimeParameters::Method::standard: 
          pres_n += phi_n; 
          break; 
        case RunTimeParameters::Method::rotational: 
          if (reinit_prec) 
            prec_mass.initialize(pres_Mass); 
          pres_n = pres_tmp; 
          prec_mass.solve(pres_n); 
          pres_n.sadd(1. / Re, 1., pres_n_minus_1); 
          pres_n += phi_n; 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      }; 
  } 
// @sect4{ <code>NavierStokesProjection::output_results</code> }  

// 该方法绘制了当前的解决方案。主要的困难是，我们想创建一个单一的输出文件，其中包含所有的速度分量、压力以及流动的涡度的数据。另一方面，速度和压力存在于不同的DoFHandler对象中，因此不能用一个DataOut对象写入同一个文件。因此，我们必须更努力地把各种数据放到一个DoFHandler对象中，然后用它来驱动图形输出。

// 我们不会在这里详细说明这个过程，而是参考  step-32  ，那里使用了一个类似的程序（并有记录），为所有变量创建一个联合的 DoFHandler 对象。

// 我们还注意到，我们在这里将涡度作为一个单独的函数中的标量来计算，使用 $L^2$ 量的投影 $\text{curl} u$ 到用于速度成分的有限元空间。但原则上，我们也可以从速度中计算出一个点状量，并通过 step-29 和 step-33 中讨论的DataPostprocessor机制实现。

  template <int dim> 
  void NavierStokesProjection<dim>::output_results(const unsigned int step) 
  { 
    assemble_vorticity((step == 1)); 
    const FESystem<dim> joint_fe( 
      fe_velocity, dim, fe_pressure, 1, fe_velocity, 1); 
    DoFHandler<dim> joint_dof_handler(triangulation); 
    joint_dof_handler.distribute_dofs(joint_fe); 
    Assert(joint_dof_handler.n_dofs() == 
             ((dim + 1) * dof_handler_velocity.n_dofs() + 
              dof_handler_pressure.n_dofs()), 
           ExcInternalError()); 
    Vector<double> joint_solution(joint_dof_handler.n_dofs()); 
    std::vector<types::global_dof_index> loc_joint_dof_indices( 
      joint_fe.n_dofs_per_cell()), 
      loc_vel_dof_indices(fe_velocity.n_dofs_per_cell()), 
      loc_pres_dof_indices(fe_pressure.n_dofs_per_cell()); 
    typename DoFHandler<dim>::active_cell_iterator 
      joint_cell = joint_dof_handler.begin_active(), 
      joint_endc = joint_dof_handler.end(), 
      vel_cell   = dof_handler_velocity.begin_active(), 
      pres_cell  = dof_handler_pressure.begin_active(); 
    for (; joint_cell != joint_endc; ++joint_cell, ++vel_cell, ++pres_cell) 
      { 
        joint_cell->get_dof_indices(loc_joint_dof_indices); 
        vel_cell->get_dof_indices(loc_vel_dof_indices); 
        pres_cell->get_dof_indices(loc_pres_dof_indices); 
        for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i) 
          switch (joint_fe.system_to_base_index(i).first.first) 
            { 
              case 0: 
                Assert(joint_fe.system_to_base_index(i).first.second < dim, 
                       ExcInternalError()); 
                joint_solution(loc_joint_dof_indices[i]) = 
                  u_n[joint_fe.system_to_base_index(i).first.second]( 
                    loc_vel_dof_indices[joint_fe.system_to_base_index(i) 
                                          .second]); 
                break; 
              case 1: 
                Assert(joint_fe.system_to_base_index(i).first.second == 0, 
                       ExcInternalError()); 
                joint_solution(loc_joint_dof_indices[i]) = 
                  pres_n(loc_pres_dof_indices[joint_fe.system_to_base_index(i) 
                                                .second]); 
                break; 
              case 2: 
                Assert(joint_fe.system_to_base_index(i).first.second == 0, 
                       ExcInternalError()); 
                joint_solution(loc_joint_dof_indices[i]) = rot_u( 
                  loc_vel_dof_indices[joint_fe.system_to_base_index(i).second]); 
                break; 
              default: 
                Assert(false, ExcInternalError()); 
            } 
      } 
    std::vector<std::string> joint_solution_names(dim, "v"); 
    joint_solution_names.emplace_back("p"); 
    joint_solution_names.emplace_back("rot_u"); 
    DataOut<dim> data_out; 
    data_out.attach_dof_handler(joint_dof_handler); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      component_interpretation( 
        dim + 2, DataComponentInterpretation::component_is_part_of_vector); 
    component_interpretation[dim] = 
      DataComponentInterpretation::component_is_scalar; 
    component_interpretation[dim + 1] = 
      DataComponentInterpretation::component_is_scalar; 
    data_out.add_data_vector(joint_solution, 
                             joint_solution_names, 
                             DataOut<dim>::type_dof_data, 
                             component_interpretation); 
    data_out.build_patches(deg + 1); 
    std::ofstream output("solution-" + Utilities::int_to_string(step, 5) + 
                         ".vtk"); 
    data_out.write_vtk(output); 
  } 

// 下面是一个辅助函数，通过将 $\text{curl} u$ 项投影到用于速度分量的有限元空间来计算涡度。这个函数只有在我们生成图形输出时才会被调用，所以不是很频繁，因此我们没有像对待其他装配函数那样，麻烦地使用WorkStream概念来并行化它。不过，如果需要的话，这应该不会太复杂。此外，我们在这里的实现只适用于2D，所以如果不是这种情况，我们就放弃了。

  template <int dim> 
  void NavierStokesProjection<dim>::assemble_vorticity(const bool reinit_prec) 
  { 
    Assert(dim == 2, ExcNotImplemented()); 
    if (reinit_prec) 
      prec_vel_mass.initialize(vel_Mass); 

    FEValues<dim>      fe_val_vel(fe_velocity, 
                             quadrature_velocity, 
                             update_gradients | update_JxW_values | 
                               update_values); 
    const unsigned int dpc = fe_velocity.n_dofs_per_cell(), 
                       nqp = quadrature_velocity.size(); 
    std::vector<types::global_dof_index> ldi(dpc); 
    Vector<double>                       loc_rot(dpc); 

    std::vector<Tensor<1, dim>> grad_u1(nqp), grad_u2(nqp); 
    rot_u = 0.; 

    for (const auto &cell : dof_handler_velocity.active_cell_iterators()) 
      { 
        fe_val_vel.reinit(cell); 
        cell->get_dof_indices(ldi); 
        fe_val_vel.get_function_gradients(u_n[0], grad_u1); 
        fe_val_vel.get_function_gradients(u_n[1], grad_u2); 
        loc_rot = 0.; 
        for (unsigned int q = 0; q < nqp; ++q) 
          for (unsigned int i = 0; i < dpc; ++i) 
            loc_rot(i) += (grad_u2[q][0] - grad_u1[q][1]) * // 
                          fe_val_vel.shape_value(i, q) *    // 
                          fe_val_vel.JxW(q); 

        for (unsigned int i = 0; i < dpc; ++i) 
          rot_u(ldi[i]) += loc_rot(i); 
      } 

    prec_vel_mass.solve(rot_u); 
  } 
} // namespace Step35 
// @sect3{ The main function }  

// 主函数看起来和其他所有的教程程序非常相似，所以这里没有什么可评论的。

int main() 
{ 
  try 
    { 
      using namespace Step35; 

      RunTimeParameters::Data_Storage data; 
      data.read_data("parameter-file.prm"); 

      deallog.depth_console(data.verbose ? 2 : 0); 

      NavierStokesProjection<2> test(data); 
      test.run(data.verbose, data.output_interval); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  std::cout << "----------------------------------------------------" 
            << std::endl 
            << "Apparently everything went fine!" << std::endl 
            << "Don't forget to brush your teeth :-)" << std::endl 
            << std::endl; 
  return 0; 
} 

CCTest_file/step-36.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Toby D. Young, Polish Academy of Sciences, 
 *          Wolfgang Bangerth, Texas A&M University 
 */ 


// @sect3{Include files}  

// 正如介绍中提到的，本程序基本上只是  step-4  的一个小修改版本。因此，以下大部分的include文件都是在那里使用的，或者至少是在以前的教程程序中已经使用的。

#include <deal.II/base/logstream.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/function_parser.h> 
#include <deal.II/base/parameter_handler.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/full_matrix.h> 

// IndexSet用于设置每个  PETScWrappers::MPI::Vector:  的大小。
#include <deal.II/base/index_set.h> 

// PETSc出现在这里是因为SLEPc依赖于这个库。

#include <deal.II/lac/petsc_sparse_matrix.h> 
#include <deal.II/lac/petsc_vector.h> 

// 然后我们需要实际导入SLEPc提供的求解器接口。

#include <deal.II/lac/slepc_solver.h> 

// 我们还需要一些标准的C++。

#include <fstream> 
#include <iostream> 

// 最后，和以前的程序一样，我们将所有的deal.II类和函数名导入到本程序中所有的名字空间中。

namespace Step36 
{ 
  using namespace dealii; 
// @sect3{The <code>EigenvalueProblem</code> class template}  

// 下面是主类模板的类声明。它看起来和在  step-4  中已经展示过的差不多了。

  template <int dim> 
  class EigenvalueProblem 
  { 
  public: 
    EigenvalueProblem(const std::string &prm_file); 
    void run(); 

  private: 
    void         make_grid_and_dofs(); 
    void         assemble_system(); 
    unsigned int solve(); 
    void         output_results() const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

// 有了这些例外情况。对于我们的特征值问题，我们既需要左手边的刚度矩阵，也需要右手边的质量矩阵。我们还需要的不仅仅是一个解函数，而是一整套我们想要计算的特征函数，以及相应的特征值。

    PETScWrappers::SparseMatrix             stiffness_matrix, mass_matrix; 
    std::vector<PETScWrappers::MPI::Vector> eigenfunctions; 
    std::vector<double>                     eigenvalues; 

// 然后，我们需要一个对象来存储几个运行时参数，我们将在输入文件中指定。

    ParameterHandler parameters; 

// 最后，我们将有一个对象，包含对我们自由度的 "约束"。如果我们有自适应细化的网格（目前的程序中没有），这可能包括悬挂节点约束。这里，我们将存储边界节点的约束  $U_i=0$  。

    AffineConstraints<double> constraints; 
  }; 
// @sect3{Implementation of the <code>EigenvalueProblem</code> class}  
// @sect4{EigenvalueProblem::EigenvalueProblem}  

// 首先是构造函数。主要的新部分是处理运行时的输入参数。我们需要首先声明它们的存在，然后从输入文件中读取它们的值，该文件的名称被指定为该函数的参数。

  template <int dim> 
  EigenvalueProblem<dim>::EigenvalueProblem(const std::string &prm_file) 
    : fe(1) 
    , dof_handler(triangulation) 
  { 

// TODO研究为什么获得正确的特征值退化所需的最小细化步骤数为6

    parameters.declare_entry( 
      "Global mesh refinement steps", 
      "5", 
      Patterns::Integer(0, 20), 
      "The number of times the 1-cell coarse mesh should " 
      "be refined globally for our computations."); 
    parameters.declare_entry("Number of eigenvalues/eigenfunctions", 
                             "5", 
                             Patterns::Integer(0, 100), 
                             "The number of eigenvalues/eigenfunctions " 
                             "to be computed."); 
    parameters.declare_entry("Potential", 
                             "0", 
                             Patterns::Anything(), 
                             "A functional description of the potential."); 

    parameters.parse_input(prm_file); 
  } 
// @sect4{EigenvalueProblem::make_grid_and_dofs}  

// 下一个函数在域 $[-1,1]^d$ 上创建一个网格，根据输入文件的要求对其进行多次细化，然后给它附加一个DoFHandler，将矩阵和向量初始化为正确的大小。我们还建立了对应于边界值的约束  $u|_{\partial\Omega}=0$  。

// 对于矩阵，我们使用PETSc包装器。这些包装器能够在非零条目被添加时分配必要的内存。这看起来效率很低：我们可以先计算稀疏模式，用它来初始化矩阵，然后在我们插入条目时，我们可以确定我们不需要重新分配内存和释放之前使用的内存。一种方法是使用这样的代码。用
// @code
//    DynamicSparsityPattern
//       dsp (dof_handler.n_dofs(),
//            dof_handler.n_dofs());
//    DoFTools::make_sparsity_pattern (dof_handler, dsp);
//    dsp.compress ();
//    stiffness_matrix.reinit (dsp);
//    mass_matrix.reinit (dsp);
//  @endcode
//  代替下面两个 <code>reinit()</code> 的刚度和质量矩阵的调用。

// 不幸的是，这并不完全可行。上面的代码可能会导致在非零模式下的一些条目，我们只写零条目；最值得注意的是，对于那些属于边界节点的行和列的非对角线条目，这一点是成立的。这不应该是一个问题，但是不管什么原因，PETSc的ILU预处理程序（我们用来解决特征值求解器中的线性系统）不喜欢这些额外的条目，并以错误信息中止。

// 在没有任何明显的方法来避免这种情况的情况下，我们干脆选择第二种最好的方法，即让PETSc在必要时分配内存。也就是说，由于这不是一个时间上的关键部分，这整个事件就不再重要了。

  template <int dim> 
  void EigenvalueProblem<dim>::make_grid_and_dofs() 
  { 
    GridGenerator::hyper_cube(triangulation, -1, 1); 
    triangulation.refine_global( 
      parameters.get_integer("Global mesh refinement steps")); 
    dof_handler.distribute_dofs(fe); 

    DoFTools::make_zero_boundary_constraints(dof_handler, constraints); 
    constraints.close(); 

    stiffness_matrix.reinit(dof_handler.n_dofs(), 
                            dof_handler.n_dofs(), 
                            dof_handler.max_couplings_between_dofs()); 
    mass_matrix.reinit(dof_handler.n_dofs(), 
                       dof_handler.n_dofs(), 
                       dof_handler.max_couplings_between_dofs()); 

// 下一步是处理特征谱的问题。在这种情况下，输出是特征值和特征函数，所以我们将特征函数和特征值列表的大小设置为与我们在输入文件中要求的一样大。当使用 PETScWrappers::MPI::Vector, 时，Vector是使用IndexSet初始化的。IndexSet不仅用于调整 PETScWrappers::MPI::Vector 的大小，而且还将 PETScWrappers::MPI::Vector 中的一个索引与一个自由度联系起来（更详细的解释见 step-40 ）。函数complete_index_set()创建了一个IndexSet，每个有效的索引都是这个集合的一部分。请注意，这个程序只能按顺序运行，如果并行使用，将抛出一个异常。

    IndexSet eigenfunction_index_set = dof_handler.locally_owned_dofs(); 
    eigenfunctions.resize( 
      parameters.get_integer("Number of eigenvalues/eigenfunctions")); 
    for (unsigned int i = 0; i < eigenfunctions.size(); ++i) 
      eigenfunctions[i].reinit(eigenfunction_index_set, MPI_COMM_WORLD); 

    eigenvalues.resize(eigenfunctions.size()); 
  } 
// @sect4{EigenvalueProblem::assemble_system}  

// 在这里，我们从局部贡献 $A^K_{ij} = \int_K \nabla\varphi_i(\mathbf x) \cdot \nabla\varphi_j(\mathbf x) + V(\mathbf x)\varphi_i(\mathbf x)\varphi_j(\mathbf x)$ 和 $M^K_{ij} = \int_K \varphi_i(\mathbf x)\varphi_j(\mathbf x)$ 中分别组合出全局刚度和质量矩阵。如果你看过以前的教程程序，这个函数应该会很熟悉。唯一新的东西是使用我们从输入文件中得到的表达式，设置一个描述势 $V(\mathbf x)$ 的对象。然后我们需要在每个单元的正交点上评估这个对象。如果你见过如何评估函数对象（例如，见 step-5 中的系数），这里的代码也会显得相当熟悉。

  template <int dim> 
  void EigenvalueProblem<dim>::assemble_system() 
  { 
    QGauss<dim> quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    FunctionParser<dim> potential; 
    potential.initialize(FunctionParser<dim>::default_variable_names(), 
                         parameters.get("Potential"), 
                         typename FunctionParser<dim>::ConstMap()); 

    std::vector<double> potential_values(n_q_points); 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        cell_stiffness_matrix = 0; 
        cell_mass_matrix      = 0; 

        potential.value_list(fe_values.get_quadrature_points(), 
                             potential_values); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              { 
                cell_stiffness_matrix(i, j) +=           // 
                  (fe_values.shape_grad(i, q_point) *    // 
                     fe_values.shape_grad(j, q_point)    // 
                   +                                     // 
                   potential_values[q_point] *           // 
                     fe_values.shape_value(i, q_point) * // 
                     fe_values.shape_value(j, q_point)   // 
                   ) *                                   // 
                  fe_values.JxW(q_point);                // 

                cell_mass_matrix(i, j) +=              // 
                  (fe_values.shape_value(i, q_point) * // 
                   fe_values.shape_value(j, q_point)   // 
                   ) *                                 // 
                  fe_values.JxW(q_point);              // 
              } 

// 现在我们有了本地矩阵的贡献，我们把它们转移到全局对象中，并处理好零边界约束。

        cell->get_dof_indices(local_dof_indices); 

        constraints.distribute_local_to_global(cell_stiffness_matrix, 
                                               local_dof_indices, 
                                               stiffness_matrix); 
        constraints.distribute_local_to_global(cell_mass_matrix, 
                                               local_dof_indices, 
                                               mass_matrix); 
      } 

// 在函数的最后，我们告诉PETSc，矩阵现在已经完全组装好了，稀疏矩阵表示法现在可以被压缩了，因为不会再添加任何条目。

    stiffness_matrix.compress(VectorOperation::add); 
    mass_matrix.compress(VectorOperation::add); 

// 在离开函数之前，我们计算虚假的特征值，这些特征值是由零Dirichlet约束引入到系统中的。正如介绍中所讨论的，使用Dirichlet边界条件，加上位于域的边界的自由度仍然是我们所求解的线性系统的一部分，引入了一些虚假的特征值。下面，我们输出它们所处的区间，以确保我们在计算中出现时可以忽略它们。

    double min_spurious_eigenvalue = std::numeric_limits<double>::max(), 
           max_spurious_eigenvalue = -std::numeric_limits<double>::max(); 

    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i) 
      if (constraints.is_constrained(i)) 
        { 
          const double ev         = stiffness_matrix(i, i) / mass_matrix(i, i); 
          min_spurious_eigenvalue = std::min(min_spurious_eigenvalue, ev); 
          max_spurious_eigenvalue = std::max(max_spurious_eigenvalue, ev); 
        } 

    std::cout << "   Spurious eigenvalues are all in the interval " 
              << "[" << min_spurious_eigenvalue << "," 
              << max_spurious_eigenvalue << "]" << std::endl; 
  } 
// @sect4{EigenvalueProblem::solve}  

// 这是该程序的关键新功能。现在系统已经设置好了，现在是实际解决问题的好时机：和其他例子一样，这是使用 "解决 "程序来完成的。从本质上讲，它的工作原理与其他程序一样：你设置一个SolverControl对象，描述我们要解决的线性系统的精度，然后我们选择我们想要的解算器类型。这里我们选择了SLEPc的Krylov-Schur求解器，对于这类问题来说，这是一个相当快速和强大的选择。

  template <int dim> 
  unsigned int EigenvalueProblem<dim>::solve() 
  { 

// 我们从这里开始，就像我们通常做的那样，指定我们想要的收敛控制。

    SolverControl                    solver_control(dof_handler.n_dofs(), 1e-9); 
    SLEPcWrappers::SolverKrylovSchur eigensolver(solver_control); 

// 在我们实际求解特征函数和-值之前，我们还必须选择哪一组特征值来求解。让我们选择那些实部最小的特征值和相应的特征函数（事实上，我们在这里解决的问题是对称的，所以特征值是纯实部的）。之后，我们就可以真正让SLEPc做它的工作了。

    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL); 

    eigensolver.set_problem_type(EPS_GHEP); 

    eigensolver.solve(stiffness_matrix, 
                      mass_matrix, 
                      eigenvalues, 
                      eigenfunctions, 
                      eigenfunctions.size()); 

// 上述调用的输出是一组向量和数值。在特征值问题中，特征函数只确定到一个常数，这个常数可以很随意地固定。由于对特征值问题的原点一无所知，SLEPc除了将特征向量归一到 $l_2$ （向量）准则外，没有其他选择。不幸的是，这个规范与我们从特征函数角度可能感兴趣的任何规范没有什么关系： $L_2(\Omega)$ 规范，或者也许是 $L_\infty(\Omega)$ 规范。

//让我们选择后者，重新划分特征函数的尺度，使其具有 $\|\phi_i(\mathbf x)\|_{L^\infty(\Omega)}=1$ 而不是 $\|\Phi\|_{l_2}=1$ （其中 $\phi_i$ 是 $i$ 第三个特征<i>function</i>， $\Phi_i$ 是相应的结点值矢量）。对于这里选择的 $Q_1$ 元素，我们知道函数 $\phi_i(\mathbf x)$ 的最大值是在其中一个节点达到的，所以 $\max_{\mathbf x}\phi_i(\mathbf x)=\max_j (\Phi_i)_j$ ，使得在 $L_\infty$ 准则下的归一化是微不足道的。请注意，如果我们选择 $Q_k$ 元素与 $k>1$ ，这就不容易了：在那里，一个函数的最大值不一定要在一个节点上达到，所以 $\max_{\mathbf x}\phi_i(\mathbf x)\ge\max_j (\Phi_i)_j$ （尽管平等通常几乎是真的）。

    for (unsigned int i = 0; i < eigenfunctions.size(); ++i) 
      eigenfunctions[i] /= eigenfunctions[i].linfty_norm(); 

// 最后返回收敛所需的迭代次数。

    return solver_control.last_step(); 
  } 
// @sect4{EigenvalueProblem::output_results}  

// 这是本程序的最后一个重要功能。它使用DataOut类来生成特征函数的图形输出，以便以后进行可视化。它的工作原理与其他许多教程中的程序一样。

// 整个函数的集合被输出为一个单一的VTK文件。

  template <int dim> 
  void EigenvalueProblem<dim>::output_results() const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 

    for (unsigned int i = 0; i < eigenfunctions.size(); ++i) 
      data_out.add_data_vector(eigenfunctions[i], 
                               std::string("eigenfunction_") + 
                                 Utilities::int_to_string(i)); 

// 唯一值得讨论的可能是，由于势在输入文件中被指定为函数表达式，因此最好能将其与特征函数一起以图形形式表示。实现这一目的的过程相对简单：我们建立一个代表 $V(\mathbf x)$ 的对象，然后将这个连续函数插值到有限元空间。我们还将结果附加到DataOut对象上，以便进行可视化。

    Vector<double> projected_potential(dof_handler.n_dofs()); 
    { 
      FunctionParser<dim> potential; 
      potential.initialize(FunctionParser<dim>::default_variable_names(), 
                           parameters.get("Potential"), 
                           typename FunctionParser<dim>::ConstMap()); 
      VectorTools::interpolate(dof_handler, potential, projected_potential); 
    } 
    data_out.add_data_vector(projected_potential, "interpolated_potential"); 

    data_out.build_patches(); 

    std::ofstream output("eigenvectors.vtk"); 
    data_out.write_vtk(output); 
  } 
// @sect4{EigenvalueProblem::run}  

// 这是一个对一切都有顶层控制的函数。它几乎与  step-4  中的内容完全相同。

  template <int dim> 
  void EigenvalueProblem<dim>::run() 
  { 
    make_grid_and_dofs(); 

    std::cout << "   Number of active cells:       " 
              << triangulation.n_active_cells() << std::endl 
              << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

    assemble_system(); 

    const unsigned int n_iterations = solve(); 
    std::cout << "   Solver converged in " << n_iterations << " iterations." 
              << std::endl; 

    output_results(); 

    std::cout << std::endl; 
    for (unsigned int i = 0; i < eigenvalues.size(); ++i) 
      std::cout << "      Eigenvalue " << i << " : " << eigenvalues[i] 
                << std::endl; 
  } 
} // namespace Step36 
// @sect3{The <code>main</code> function}  
int main(int argc, char **argv) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step36; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

// 这个程序只能在串行中运行。否则，将抛出一个异常。

      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1, 
                  ExcMessage( 
                    "This program can only be run in serial, use ./step-36")); 

      EigenvalueProblem<2> problem("step-36.prm"); 
      problem.run(); 
    } 

// 在这期间，我们一直在注意是否有任何异常应该被生成。如果是这样的话，我们就会惊慌失措...

  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

// 如果没有抛出异常，我们就告诉程序不要再胡闹了，乖乖地退出。

  std::cout << std::endl << "   Job done." << std::endl; 

  return 0; 
} 


CCTest_file/step-37.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Katharina Kormann, Martin Kronbichler, Uppsala University, 
 * 2009-2012, updated to MPI version with parallel vectors in 2016 
 */ 



// 首先包括deal.II库中的必要文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/la_parallel_vector.h> 
#include <deal.II/lac/precondition.h> 

#include <deal.II/fe/fe_q.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer_matrix_free.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_matrix.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 这包括有效实现无矩阵方法的数据结构，或者用MatrixFree类的更通用的有限元算子。

#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/operators.h> 
#include <deal.II/matrix_free/fe_evaluation.h> 

#include <iostream> 
#include <fstream> 

namespace Step37 
{ 
  using namespace dealii; 

// 为了提高效率，在无矩阵实现中进行的操作需要在编译时了解循环长度，这些长度是由有限元的度数给出的。因此，我们收集了两个模板参数的值，可以在代码中的一个地方改变。当然，我们可以把有限元的度数作为一个运行时的参数，通过编译所有可能的度数（比如，1到6之间）的计算核，并在运行时选择合适的核。在这里，我们只是选择二阶 $Q_2$ 元素，并选择维度3作为标准。

  const unsigned int degree_finite_element = 2; 
  const unsigned int dimension             = 3; 
// @sect3{Equation data}  

// 我们为泊松问题定义了一个可变系数函数。它与 step-5 中的函数类似，但我们使用 $a(\mathbf x)=\frac{1}{0.05 + 2\|\bf x\|^2}$ 的形式，而不是不连续的形式。这只是为了证明这种实现的可能性，而不是在物理上有什么意义。我们定义系数的方式与早期教程程序中的函数相同。有一个新的函数，即有模板参数 @p value 的 @p number. 方法。
template <int dim> 
  class Coefficient : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    template <typename number> 
    number value(const Point<dim, number> &p, 
                 const unsigned int        component = 0) const; 
  }; 

// 这就是上面提到的新函数。评估抽象类型的系数  @p number.  它可能只是一个普通的双数，但也可能是一个有点复杂的类型，我们称之为VectorizedArray。这种数据类型本质上是一个短的双数数组，正如在介绍中所讨论的那样，它可以容纳几个单元格的数据。例如，我们在这里评估的系数不是像通常那样在一个简单的点上，而是交给一个Point<dim,VectorizedArray<double>>点，在AVX的情况下，它实际上是四个点的集合。不要把VectorizedArray中的条目与点的不同坐标混淆。事实上，数据的布局是这样的： <code>p[0]</code> 返回一个VectorizedArray，它又包含了第一个点和第二个点的x坐标。你可以使用例如  <code>p[0][j]</code>  单独访问坐标，j=0,1,2,3，但建议尽可能在一个VectorizedArray上定义操作，以便利用矢量操作。

// 在函数的实现中，我们假设数字类型重载了基本的算术运算，所以我们只需照常写代码。然后，基类函数 @p value 是由带有双倍类型的模板函数计算出来的，以避免重复代码。

  template <int dim> 
  template <typename number> 
  number Coefficient<dim>::value(const Point<dim, number> &p, 
                                 const unsigned int /*component*/) const 
  { 
    return 1. / (0.05 + 2. * p.square()); 
  } 

  template <int dim> 
  double Coefficient<dim>::value(const Point<dim> & p, 
                                 const unsigned int component) const 
  { 
    return value<double>(p, component); 
  } 
// @sect3{Matrix-free implementation}  

// 下面这个名为 <code>LaplaceOperator</code> 的类，实现了微分运算符。就所有的实用目的而言，它是一个矩阵，也就是说，你可以向它询问它的大小（成员函数  <code>m(), n()</code>  ），你可以将它应用于一个矢量（ <code>vmult()</code>  函数）。当然，与实数矩阵的区别在于，这个类实际上并不存储矩阵的<i>elements</i>，而只知道如何计算运算器应用于向量时的动作。

// 描述矩阵大小的基础结构，来自MatrixFree对象的初始化，以及通过vmult()和Tvmult()方法实现矩阵-向量乘积的各种接口，是由本类派生的 MatrixFreeOperator::Base 类提供的。这里定义的LaplaceOperator类只需要提供几个接口，即通过vmult()函数中使用的apply_add()方法来实现运算符的实际操作，以及计算底层矩阵对角线项的方法。我们需要对角线来定义多梯度平滑器。由于我们考虑的是一个具有可变系数的问题，我们进一步实现了一个可以填充系数值的方法。

// 注意文件 <code>include/deal.II/matrix_free/operators.h</code> 已经包含了通过类 MatrixFreeOperators::LaplaceOperator. 对拉普拉斯的实现。 出于教育目的，本教程程序中重新实现了该运算符，解释了其中的成分和概念。

// 这个程序利用了集成在deal.II中的有限元算子应用的数据缓存。这个数据缓存类被称为MatrixFree。它包含局部和全局自由度之间的映射信息（Jacobian）和索引关系。它还包含约束条件，如来自悬挂节点或迪里切特边界条件的约束。此外，它可以在所有单元上以%并行方式发出一个循环，确保只有不共享任何自由度的单元被处理（这使得循环在写入目标向量时是线程安全的）。与 @ref threads 模块中描述的WorkStream类相比，这是一个更先进的策略。当然，为了不破坏线程安全，我们在写进类全局结构时必须小心。

// 实现拉普拉斯算子的类有三个模板参数，一个是维度（正如许多deal.II类所携带的），一个是有限元的度数（我们需要通过FEEvaluation类来实现高效计算），还有一个是底层标量类型。我们希望对最终矩阵使用 <code>double</code> 数字（即双精度，64位浮点），但对多网格级矩阵使用浮点数（单精度，32位浮点数字）（因为那只是一个预处理程序，而浮点数的处理速度是两倍）。FEEvaluation类也需要一个模板参数，用于确定一维正交点的数量。在下面的代码中，我们把它硬编码为  <code>fe_degree+1</code>  。如果我们想独立于多项式程度来改变它，我们需要添加一个模板参数，就像在  MatrixFreeOperators::LaplaceOperator  类中做的那样。

// 顺便说一下，如果我们在同一个网格和自由度上实现了几个不同的操作（比如质量矩阵和拉普拉斯矩阵），我们将为每个操作者定义两个像现在这样的类（来自于 MatrixFreeOperators::Base 类），并让它们都引用一般问题类中的同一个MatrixFree数据缓存。通过 MatrixFreeOperators::Base 的接口要求我们只提供一组最小的函数。这个概念允许编写具有许多无矩阵操作的复杂应用代码。

//  @note  储存类型 <code>VectorizedArray<number></code> 的值需要注意。在这里，我们使用deal.II表类，它准备以正确的对齐方式保存数据。然而，存储例如一个 <code>std::vector<VectorizedArray<number> ></code> 是不可能用矢量化的。数据与内存地址的边界需要一定的对齐（基本上，在AVX的情况下，一个32字节的VectorizedArray需要从一个能被32整除的内存地址开始）。表类（以及它所基于的AlignedVector类）确保这种对齐方式得到尊重，而 std::vector 一般不这样做，这可能会导致一些系统在奇怪的地方出现分段故障，或者其他系统的性能不理想。

  template <int dim, int fe_degree, typename number> 
  class LaplaceOperator 
    : public MatrixFreeOperators:: 
        Base<dim, LinearAlgebra::distributed::Vector<number>> 
  { 
  public: 
    using value_type = number; 

    LaplaceOperator(); 

    void clear() override; 

    void evaluate_coefficient(const Coefficient<dim> &coefficient_function); 

    virtual void compute_diagonal() override; 

  private: 
    virtual void apply_add( 
      LinearAlgebra::distributed::Vector<number> &      dst, 
      const LinearAlgebra::distributed::Vector<number> &src) const override; 

    void 
    local_apply(const MatrixFree<dim, number> &                   data, 
                LinearAlgebra::distributed::Vector<number> &      dst, 
                const LinearAlgebra::distributed::Vector<number> &src, 
                const std::pair<unsigned int, unsigned int> &cell_range) const; 

    void local_compute_diagonal( 
      const MatrixFree<dim, number> &              data, 
      LinearAlgebra::distributed::Vector<number> & dst, 
      const unsigned int &                         dummy, 
      const std::pair<unsigned int, unsigned int> &cell_range) const; 

    Table<2, VectorizedArray<number>> coefficient; 
  }; 

// 这是 @p LaplaceOperator 类的构造函数。它所做的就是调用基类 MatrixFreeOperators::Base, 的默认构造函数，而基类又是基于Subscriptor类的，它断言这个类在超出范围后不会被访问，比如在一个预处理程序中。

  template <int dim, int fe_degree, typename number> 
  LaplaceOperator<dim, fe_degree, number>::LaplaceOperator() 
    : MatrixFreeOperators::Base<dim, 
                                LinearAlgebra::distributed::Vector<number>>() 
  {} 

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::clear() 
  { 
    coefficient.reinit(0, 0); 
    MatrixFreeOperators::Base<dim, LinearAlgebra::distributed::Vector<number>>:: 
      clear(); 
  } 

//  @sect4{Computation of coefficient}  

// 为了初始化系数，我们直接赋予它上面定义的系数类，然后选择带有矢量数的方法 <code>coefficient_function.value</code> （编译器可以从点数据类型中推导出来）。下面将解释FEEvaluation类（及其模板参数）的使用。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::evaluate_coefficient( 
    const Coefficient<dim> &coefficient_function) 
  { 
    const unsigned int n_cells = this->data->n_cell_batches(); 
    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*this->data); 

    coefficient.reinit(n_cells, phi.n_q_points); 
    for (unsigned int cell = 0; cell < n_cells; ++cell) 
      { 
        phi.reinit(cell); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          coefficient(cell, q) = 
            coefficient_function.value(phi.quadrature_point(q)); 
      } 
  } 

//  @sect4{Local evaluation of Laplace operator}  

// 这里是这个类的主要功能，矩阵-向量乘积的评估（或者，一般来说，有限元算子评估）。这是在一个函数中完成的，该函数需要四个参数，MatrixFree对象，目标和源向量，以及要处理的单元格范围。MatrixFree类中的方法 <code>cell_loop</code> 将在内部用一些单元格范围来调用这个函数，这些单元格范围是通过检查哪些单元格可以同时工作来获得的，这样写操作就不会引起任何竞赛条件。请注意，循环中使用的单元格范围并不是直接指当前网格中的（活动）单元格数量，而是一个单元格批次的集合。 换句话说，"单元 "可能是一个错误的开始，因为FEEvaluation将几个单元的数据分组在一起。这意味着在正交点的循环中，我们实际上是将几个单元的正交点作为一个块来看待。这样做是为了实现更高的矢量化程度。 这种 "单元 "或 "单元批 "的数量存储在MatrixFree中，可以通过 MatrixFree::n_cell_batches(). 查询。与deal.II单元迭代器相比，在这个类中，所有的单元都被布置在一个普通的数组中，不直接知道水平或相邻关系，这使得通过无符号整数索引单元成为可能。

// 拉普拉斯运算符的实现非常简单。首先，我们需要创建一个对象FEEvaluation，它包含计算核，并有数据字段来存储临时结果（例如，在几个单元格集合的所有正交点上评估的梯度）。请注意，临时结果不会使用大量的内存，而且由于我们用元素顺序指定模板参数，数据被存储在堆栈中（没有昂贵的内存分配）。通常，只需要设置两个模板参数，维度作为第一个参数，有限元的度数作为第二个参数（这等于每个维度的自由度数减去FE_Q元素的一个）。然而，在这里，我们也希望能够使用浮点数来计算多网格预处理，这是最后一个（第五个）模板参数。因此，我们不能依赖默认的模板参数，因此必须填写第三和第四个字段。第三个参数指定每个方向的正交点的数量，其默认值等于元素的度数加1。第四个参数设置分量的数量（在PDEs系统中也可以评估矢量值的函数，但默认是标量元素），最后一个参数设置数字类型。

// 接下来，我们在给定的单元格范围内循环，然后继续进行实际的实现。  <ol>  
// <li>  告诉FEEvaluation对象我们要处理的（宏）单元。   <li>  读入源向量的值（  @p read_dof_values),  包括约束的解析。这将存储 $u_\mathrm{cell}$ ，如介绍中所述。   <li>  计算单元格梯度（有限元函数的评价）。由于FEEvaluation可以结合值计算和梯度计算，它使用一个统一的接口来处理0到2阶之间的各种导数。我们只想要梯度，不想要值，也不想要二阶导数，所以我们在梯度槽（第二槽）中将函数参数设置为真，而在值槽（第一槽）中设置为假。还有一个用于Hessian的第三槽，默认为假，所以不需要给它。请注意，FEEvaluation类在内部以一种有效的方式评估形状函数，一次只处理一个维度（如介绍中提到的使用形状函数和正交点的张量积形式）。与FEValues中使用的在所有局部自由度和正交点上循环的天真方法相比，在 $d$ 维度上，这给出了等于 $\mathcal O(d^2 (p+1)^{d+1})$ 的多项式度数 $p$ 的复杂度，并花费了 $\mathcal O(d (p+1)^{2d})$  。   <li>  接下来是雅各布变换的应用，乘以变量系数和正交权重。FEEvaluation有一个访问函数 @p get_gradient ，可以应用Jacobian并返回实空间中的梯度。然后，我们只需要乘以（标量）系数，并让函数 @p submit_gradient 应用第二个雅各布式（用于测试函数）和正交权重及雅各布式行列式（JxW）。注意，提交的梯度存储在与 @p get_gradient. 中读取梯度的地方相同的数据字段中。因此，你需要确保在调用 @p submit_gradient 后不要再从同一正交点读取该特定正交点。一般来说，当 @p get_gradient 被多次使用时，复制其结果是个好主意。   <li>  接下来是对所有测试函数的正交点进行求和，对应于实际积分步骤。对于拉普拉斯算子，我们只是乘以梯度，所以我们用各自的参数集调用积分函数。如果你有一个方程，同时用测试函数的值和梯度进行测试，那么两个模板参数都需要设置为真。先调用积分函数的值，再单独调用梯度，会导致错误的结果，因为第二次调用会在内部覆盖第一次调用的结果。请注意，积分步骤的二次导数没有函数参数。   <li>  最终，介绍中提到的向量 $v_\mathrm{cell}$ 中的局部贡献需要被添加到结果向量中（并应用约束）。这是通过调用 @p distribute_local_to_global, 来完成的，该函数与AffineConstraints中的相应函数名称相同（只是我们现在将局部向量存储在FEEvaluation对象中，正如局部和全局自由度之间的指数一样）。   </ol>  
  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::local_apply( 
    const MatrixFree<dim, number> &                   data, 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src, 
    const std::pair<unsigned int, unsigned int> &     cell_range) const 
  { 
    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data); 

    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        AssertDimension(coefficient.size(0), data.n_cell_batches()); 
        AssertDimension(coefficient.size(1), phi.n_q_points); 

        phi.reinit(cell); 
        phi.read_dof_values(src); 
        phi.evaluate(EvaluationFlags::gradients); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q); 
        phi.integrate(EvaluationFlags::gradients); 
        phi.distribute_local_to_global(dst); 
      } 
  } 

// 这个函数实现了对 Base::apply_add() 接口的所有单元的循环。这是用MatrixFree类的 @p cell_loop 来实现的，它接受这个类的operator()，参数为MatrixFree, OutVector, InVector, cell_range。当使用MPI并行化（但没有线程）时，如本教程程序中所做的，单元格循环对应于以下三行代码。

// 
// @code
//  src.update_ghost_values();
//  local_apply(*this->data, dst, src, std::make_pair(0U,
//                                                    data.n_cell_batches()));
//  dst.compress(VectorOperation::add);
//  @endcode

// 这里，两个调用update_ghost_values()和compress()为MPI执行处理器边界上的数据交换，一次用于源向量，我们需要从远程处理器拥有的条目中读取，一次用于目的向量，我们已经积累了部分残余，需要添加到所有者处理器的相应条目中。然而， MatrixFree::cell_loop 不仅抽象出这两个调用，而且还进行了一些额外的优化。一方面，它将把update_ghost_values()和compress()的调用拆开，以允许通信和计算的重叠。然后用三个代表从0到 MatrixFree::n_cell_batches(). 的单元格范围的分区来调用local_apply函数。另一方面，cell_loop也支持线程并行，在这种情况下，单元格范围被分割成更小的块，并以一种先进的方式安排，避免了几个线程对同一个向量条目的访问。这一特性在  step-48  中有解释。

// 注意，在单元格循环之后，受约束的自由度需要再次被触及，以实现合理的vmult()操作。由于装配循环会自动解决约束问题（就像 AffineConstraints::distribute_local_to_global() 的调用一样），它不会计算对受约束自由度的任何贡献，而是将各自的条目留为零。这将表示一个矩阵的受限自由度的行和列都是空的。然而，像CG这样的迭代求解器只对非星形矩阵有效。最简单的方法是将矩阵中对应于受限自由度的子块设置为同一矩阵，在这种情况下，矩阵的应用只是将右侧向量的元素复制到左侧。幸运的是，vmult()的实现 MatrixFreeOperators::Base 在apply_add()函数之外自动为我们做了这个，所以我们不需要在这里采取进一步的行动。

// 当使用MatrixFree和FEEvaluation的组合与MPI并行时，有一个方面需要注意&mdash; 用于访问向量的索引。出于性能的考虑，MatrixFree和FEEvaluation被设计为在MPI本地索引空间中访问向量，当与多个处理器一起工作时也是如此。在本地索引空间工作意味着除了不可避免的间接寻址外，在向量访问发生的地方不需要进行索引转换。然而，本地索引空间是模糊的：虽然标准的惯例是用0和本地大小之间的索引访问向量的本地拥有的范围，但对于重影项的编号并不那么明确，而且有些随意。对于矩阵-向量乘积，只有出现在本地拥有的单元格上的指数（加上那些通过悬挂节点约束引用的指数）是必要的。然而，在deal.II中，我们经常将重影元素上的所有自由度设置为重影向量条目，称为 @ref GlossLocallyRelevantDof "术语表中描述的本地相关DoF"。在这种情况下，尽管指的是同一个全局索引，但在两个可能的重影集中，重影向量条目的MPI本地索引一般会有所不同。为了避免问题，FEEvaluation通过一个名为 LinearAlgebra::distributed::Vector::partitioners_are_compatible. 的检查来检查用于矩阵-向量乘积的向量分区是否确实与MatrixFree中的索引分区相匹配。 为了方便， MatrixFreeOperators::Base 类包括一个机制来使鬼魂集适合正确的布局。这发生在向量的重影区域，所以请记住，在调用vmult()方法后，目标和源向量的重影区域都可能被修改。这是合法的，因为分布式deal.II向量的ghost区域是一个可变的部分，并按需填充。在矩阵-向量乘积中使用的向量在进入vmult()函数时不能被重影，所以没有信息丢失。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::apply_add( 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src) const 
  { 
    this->data->cell_loop(&LaplaceOperator::local_apply, this, dst, src); 
  } 

// 下面的函数实现了算子对角线的计算。计算无矩阵算子评估的矩阵项，结果比评估算子更复杂。从根本上说，我们可以通过在<i>all</i>单位向量上应用算子来获得算子的矩阵表示。当然，这将是非常低效的，因为我们需要进行<i>n</i>运算符的评估来检索整个矩阵。此外，这种方法会完全忽视矩阵的稀疏性。然而，对于单个单元来说，这是一种方法，而且实际上效率并不低，因为单元内的所有自由度之间通常都存在着耦合。

// 我们首先将对角线向量初始化为正确的平行布局。这个向量被封装在基类 MatrixFreeOperators::Base. 中DiagonalMatrix类型的一个名为inverse_diagonal_entries的成员中，这个成员是一个共享指针，我们首先需要初始化它，然后获得代表矩阵中对角线条目的向量。至于实际的对角线计算，我们再次使用MatrixFree的cell_loop基础设施来调用一个名为local_compute_diagonal()的本地工作程序。由于我们只写进一个向量，而没有任何源向量，我们用一个<tt>unsigned int</tt>类型的假参数来代替源向量，以便与cell_loop接口确认。在循环之后，我们需要将受Dirichlet边界条件约束的向量条目设置为1（要么是MatrixFree内部AffineConstraints对象描述的边界上的条目，要么是自适应多网格中不同网格层次之间的索引）。这是通过函数 MatrixFreeOperators::Base::set_constrained_entries_to_one() 完成的，并与Base算子提供的矩阵-向量乘积中的设置相匹配。最后，我们需要反转对角线条目，这是基于Jacobi迭代的Chebyshev平滑器所要求的形式。在循环中，我们断言所有的条目都是非零的，因为它们应该从积分中获得正的贡献，或者被约束并被 @p set_constrained_entries_to_one() 以下的cell_loop处理。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::compute_diagonal() 
  { 
    this->inverse_diagonal_entries.reset( 
      new DiagonalMatrix<LinearAlgebra::distributed::Vector<number>>()); 
    LinearAlgebra::distributed::Vector<number> &inverse_diagonal = 
      this->inverse_diagonal_entries->get_vector(); 
    this->data->initialize_dof_vector(inverse_diagonal); 
    unsigned int dummy = 0; 
    this->data->cell_loop(&LaplaceOperator::local_compute_diagonal, 
                          this, 
                          inverse_diagonal, 
                          dummy); 

    this->set_constrained_entries_to_one(inverse_diagonal); 

    for (unsigned int i = 0; i < inverse_diagonal.locally_owned_size(); ++i) 
      { 
        Assert(inverse_diagonal.local_element(i) > 0., 
               ExcMessage("No diagonal entry in a positive definite operator " 
                          "should be zero")); 
        inverse_diagonal.local_element(i) = 
          1. / inverse_diagonal.local_element(i); 
      } 
  } 

// 在本地计算循环中，我们通过循环本地矩阵中的所有列来计算对角线，并将条目1放在<i>i</i>槽中，将条目0放在所有其他槽中，也就是说，我们一次在一个单位向量上应用单元格微分运算。调用 FEEvaluation::evaluate, 的内部部分是对正交点的循环， FEEvalution::integrate, 则与local_apply函数完全相同。之后，我们挑出本地结果的第<i>i</i>个条目，并将其放入一个临时存储器（因为我们在下一次循环迭代时覆盖了 FEEvaluation::get_dof_value() 后面数组中的所有条目）。最后，临时存储被写到目标向量中。注意我们是如何使用 FEEvaluation::get_dof_value() 和 FEEvaluation::submit_dof_value() 来读取和写入FEEvaluation用于积分的数据字段，并在另一方面写入全局向量的。

// 鉴于我们只对矩阵的对角线感兴趣，我们简单地扔掉了沿途计算过的本地矩阵的所有其他条目。虽然计算完整的单元格矩阵，然后扔掉除对角线以外的所有东西看起来很浪费，但是整合的效率很高，所以计算并没有花费太多时间。请注意，对于多项式度数来说，每个元素的算子评估的复杂度是 $\mathcal O((p+1)^{d+1})$ ，所以计算整个矩阵要花费我们 $\mathcal O((p+1)^{2d+1})$ 次操作，与用FEValues计算对角线的复杂度 $\mathcal O((p+1)^{2d})$ 相差不大。由于FEEvaluation也由于矢量化和其他优化而大大加快了速度，所以用这个函数计算对角线实际上是最快的（简单的）变量。(有可能用 $\mathcal O((p+1)^{d+1})$ 操作中的和分解技术来计算对角线，这涉及到特别适应的内核&mdash;但是由于这种内核只在特定的环境下有用，而对角线计算通常不在关键路径上，所以它们没有在deal.II中实现。)

// 注意在向量上调用distribution_local_to_global来将对角线条目累积到全局矩阵的代码有一些限制。对于带有悬空节点约束的操作者来说，在distribution_local_to_global的调用中，将一个受约束的DoF的积分贡献分配给其他几个条目，这里使用的向量接口并不完全计算对角线条目，而是将一些位于本地矩阵对角线上的贡献，最终在全局矩阵的非对角线位置堆积到对角线上。如<a href="http:dx.doi.org/10.4208/cicp.101214.021015a">Kormann (2016), section 5.3</a>中所解释的，该结果在离散化精度上是正确的，但在数学上并不平等。在这个教程程序中，不会发生任何危害，因为对角线只用于没有悬空节点约束出现的多网格水平矩阵中。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::local_compute_diagonal( 
    const MatrixFree<dim, number> &             data, 
    LinearAlgebra::distributed::Vector<number> &dst, 
    const unsigned int &, 
    const std::pair<unsigned int, unsigned int> &cell_range) const 
  { 
    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data); 

    AlignedVector<VectorizedArray<number>> diagonal(phi.dofs_per_cell); 

    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        AssertDimension(coefficient.size(0), data.n_cell_batches()); 
        AssertDimension(coefficient.size(1), phi.n_q_points); 

        phi.reinit(cell); 
        for (unsigned int i = 0; i < phi.dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < phi.dofs_per_cell; ++j) 
              phi.submit_dof_value(VectorizedArray<number>(), j); 
            phi.submit_dof_value(make_vectorized_array<number>(1.), i); 

            phi.evaluate(EvaluationFlags::gradients); 
            for (unsigned int q = 0; q < phi.n_q_points; ++q) 
              phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), 
                                  q); 
            phi.integrate(EvaluationFlags::gradients); 
            diagonal[i] = phi.get_dof_value(i); 
          } 
        for (unsigned int i = 0; i < phi.dofs_per_cell; ++i) 
          phi.submit_dof_value(diagonal[i], i); 
        phi.distribute_local_to_global(dst); 
      } 
  } 

//  @sect3{LaplaceProblem class}  

// 这个类是基于  step-16  中的一个。然而，我们用我们的无矩阵实现取代了SparseMatrix<double>类，这意味着我们也可以跳过稀疏性模式。请注意，我们定义LaplaceOperator类时，将有限元的度数作为模板参数（该值在文件的顶部定义），我们使用浮点数来表示多网格级矩阵。

// 该类还有一个成员变量，用来记录在我们真正去解决这个问题之前设置整个数据链的所有详细时间。此外，还有一个输出流（默认情况下是禁用的），可以用来输出各个设置操作的细节，而不是默认情况下只打印出的摘要。

// 由于这个程序被设计成与MPI一起使用，我们也提供了通常的 @p pcout 输出流，只打印MPI等级为0的处理器的信息。这个程序使用的网格可以是基于p4est的分布式三角图（在deal.II被配置为使用p4est的情况下），否则它就是一个只在没有MPI的情况下运行的串行网格。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_rhs(); 
    void solve(); 
    void output_results(const unsigned int cycle) const; 

#ifdef DEAL_II_WITH_P4EST 
    parallel::distributed::Triangulation<dim> triangulation; 
#else 
    Triangulation<dim> triangulation; 
#endif 

    FE_Q<dim>       fe; 
    DoFHandler<dim> dof_handler; 

    MappingQ1<dim> mapping; 

 
    using SystemMatrixType = 
      LaplaceOperator<dim, degree_finite_element, double>; 
    SystemMatrixType system_matrix; 

    MGConstrainedDoFs mg_constrained_dofs; 
    using LevelMatrixType = LaplaceOperator<dim, degree_finite_element, float>; 
    MGLevelObject<LevelMatrixType> mg_matrices; 

    LinearAlgebra::distributed::Vector<double> solution; 
    LinearAlgebra::distributed::Vector<double> system_rhs; 

    double             setup_time; 
    ConditionalOStream pcout; 
    ConditionalOStream time_details; 
  }; 

// 当我们初始化有限元时，我们当然也要使用文件顶部指定的度数（否则，在某些时候会抛出一个异常，因为在模板化的LaplaceOperator类中定义的计算内核和MatrixFree读出的有限元信息将不匹配）。三角形的构造函数需要设置一个额外的标志，告诉网格要符合顶点上的2:1单元平衡，这对于几何多网格例程的收敛是必需的。对于分布式网格，我们还需要特别启用多网格的层次结构。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem() 
    : 
#ifdef DEAL_II_WITH_P4EST 
    triangulation( 
      MPI_COMM_WORLD, 
      Triangulation<dim>::limit_level_difference_at_vertices, 
      parallel::distributed::Triangulation<dim>::construct_multigrid_hierarchy) 
    , 
#else 
    triangulation(Triangulation<dim>::limit_level_difference_at_vertices) 
    , 
#endif 
    fe(degree_finite_element) 
    , dof_handler(triangulation) 
    , setup_time(0.) 
    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
    , 

// LaplaceProblem类拥有一个额外的输出流，用于收集关于设置阶段的详细时间信息。这个流被称为time_details，默认情况下通过这里指定的 @p false 参数被禁用。对于详细的时间，去掉 @p false 参数可以打印出所有的细节。

    time_details(std::cout, 
                 false && Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
  {} 

//  @sect4{LaplaceProblem::setup_system}  

// 设置阶段与 step-16 类似，由于LaplaceOperator类的存在而有相关的变化。首先要做的是设置DoFHandler，包括多网格层次的自由度，以及初始化悬挂节点的约束和同质二列条件。由于我们打算用MPI的%并行方式使用这个程序，我们需要确保约束条件能知道本地相关的自由度，否则在使用超过几亿个自由度的时候，存储会爆炸，见  step-40  。

// 一旦我们创建了多网格dof_handler和约束条件，我们就可以为全局矩阵算子以及多网格方案的每一层调用reinit函数。主要的操作是为问题设置 <code> MatrixFree </code> 实例。 <code>LaplaceOperator</code> 类的基类， MatrixFreeOperators::Base, 被初始化为一个指向MatrixFree对象的共享指针。这样，我们可以在这里简单地创建它，然后将它分别传递给系统矩阵和水平矩阵。为了设置MatrixFree，我们需要激活MatrixFree的AdditionalData字段中的更新标志，使其能够存储实空间中的正交点坐标（默认情况下，它只缓存梯度（反转置的雅各布）和JxW值的数据）。请注意，如果我们调用 reinit 函数而不指定级别（即给出  <code>level = numbers::invalid_unsigned_int</code>  ），MatrixFree 将在活动单元上构建一个循环。在本教程中，除了MPI之外，我们不使用线程，这就是为什么我们通过将 MatrixFree::AdditionalData::tasks_parallel_scheme 设置为 MatrixFree::AdditionalData::none. 来明确地禁用它 最后，系数被评估，向量被初始化，如上所述。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 
    Timer time; 
    setup_time = 0; 

    system_matrix.clear(); 
    mg_matrices.clear_elements(); 

    dof_handler.distribute_dofs(fe); 
    dof_handler.distribute_mg_dofs(); 

    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
          << std::endl; 

    IndexSet locally_relevant_dofs; 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 

    constraints.clear(); 
    constraints.reinit(locally_relevant_dofs); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    VectorTools::interpolate_boundary_values( 
      mapping, dof_handler, 0, Functions::ZeroFunction<dim>(), constraints); 
    constraints.close(); 
    setup_time += time.wall_time(); 
    time_details << "Distribute DoFs & B.C.     (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s" << std::endl; 
    time.restart(); 

    { 
      typename MatrixFree<dim, double>::AdditionalData additional_data; 
      additional_data.tasks_parallel_scheme = 
        MatrixFree<dim, double>::AdditionalData::none; 
      additional_data.mapping_update_flags = 
        (update_gradients | update_JxW_values | update_quadrature_points); 
      std::shared_ptr<MatrixFree<dim, double>> system_mf_storage( 
        new MatrixFree<dim, double>()); 
      system_mf_storage->reinit(mapping, 
                                dof_handler, 
                                constraints, 
                                QGauss<1>(fe.degree + 1), 
                                additional_data); 
      system_matrix.initialize(system_mf_storage); 
    } 

    system_matrix.evaluate_coefficient(Coefficient<dim>()); 

    system_matrix.initialize_dof_vector(solution); 
    system_matrix.initialize_dof_vector(system_rhs); 

    setup_time += time.wall_time(); 
    time_details << "Setup matrix-free system   (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s" << std::endl; 
    time.restart(); 

// 接下来，初始化所有层次上的多网格方法的矩阵。数据结构MGConstrainedDoFs保留了受边界条件约束的指数信息，以及不同细化层次之间的边缘指数，如 step-16 教程程序中所述。然后，我们穿过网格的各个层次，在每个层次上构建约束和矩阵。这与原始网格上的系统矩阵的构造密切相关，只是在访问层级信息而不是活动单元的信息时，在命名上略有不同。

    const unsigned int nlevels = triangulation.n_global_levels(); 
    mg_matrices.resize(0, nlevels - 1); 

    std::set<types::boundary_id> dirichlet_boundary; 
    dirichlet_boundary.insert(0); 
    mg_constrained_dofs.initialize(dof_handler); 
    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, 
                                                       dirichlet_boundary); 

    for (unsigned int level = 0; level < nlevels; ++level) 
      { 
        IndexSet relevant_dofs; 
        DoFTools::extract_locally_relevant_level_dofs(dof_handler, 
                                                      level, 
                                                      relevant_dofs); 
        AffineConstraints<double> level_constraints; 
        level_constraints.reinit(relevant_dofs); 
        level_constraints.add_lines( 
          mg_constrained_dofs.get_boundary_indices(level)); 
        level_constraints.close(); 

        typename MatrixFree<dim, float>::AdditionalData additional_data; 
        additional_data.tasks_parallel_scheme = 
          MatrixFree<dim, float>::AdditionalData::none; 
        additional_data.mapping_update_flags = 
          (update_gradients | update_JxW_values | update_quadrature_points); 
        additional_data.mg_level = level; 
        std::shared_ptr<MatrixFree<dim, float>> mg_mf_storage_level( 
          new MatrixFree<dim, float>()); 
        mg_mf_storage_level->reinit(mapping, 
                                    dof_handler, 
                                    level_constraints, 
                                    QGauss<1>(fe.degree + 1), 
                                    additional_data); 

        mg_matrices[level].initialize(mg_mf_storage_level, 
                                      mg_constrained_dofs, 
                                      level); 
        mg_matrices[level].evaluate_coefficient(Coefficient<dim>()); 
      } 
    setup_time += time.wall_time(); 
    time_details << "Setup matrix-free levels   (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s" << std::endl; 
  } 

//  @sect4{LaplaceProblem::assemble_rhs}  

// 组装函数非常简单，因为我们所要做的就是组装右侧。多亏了FEEvaluation和所有缓存在MatrixFree类中的数据，我们从 MatrixFreeOperators::Base, 中查询，这可以在几行中完成。由于这个调用没有被包裹到 MatrixFree::cell_loop 中（这将是一个替代方案），我们一定不要忘记在装配结束时调用compress()，将右手边的所有贡献发送给各自自由度的所有者。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_rhs() 
  { 
    Timer time; 

    system_rhs = 0; 
    FEEvaluation<dim, degree_finite_element> phi( 
      *system_matrix.get_matrix_free()); 
    for (unsigned int cell = 0; 
         cell < system_matrix.get_matrix_free()->n_cell_batches(); 
         ++cell) 
      { 
        phi.reinit(cell); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          phi.submit_value(make_vectorized_array<double>(1.0), q); 
        phi.integrate(EvaluationFlags::values); 
        phi.distribute_local_to_global(system_rhs); 
      } 
    system_rhs.compress(VectorOperation::add); 

    setup_time += time.wall_time(); 
    time_details << "Assemble right hand side   (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s" << std::endl; 
  } 

//  @sect4{LaplaceProblem::solve}  

// 解决的过程与  step-16  中类似。我们先从转移的设置开始。对于 LinearAlgebra::distributed::Vector, 来说，有一个非常快速的转移类，叫做MGTransferMatrixFree，它用FEEvaluation中同样的快速和因子化核在网格层之间进行插值。

  template <int dim> 
  void LaplaceProblem<dim>::solve() 
  { 
    Timer                            time; 
    MGTransferMatrixFree<dim, float> mg_transfer(mg_constrained_dofs); 
    mg_transfer.build(dof_handler); 
    setup_time += time.wall_time(); 
    time_details << "MG build transfer time     (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s\n"; 
    time.restart(); 

// 作为一个平滑器，本教程程序使用切比雪夫迭代，而不是 step-16 中的SOR。（SOR将很难实现，因为我们没有明确的矩阵元素，而且很难使其在%并行中有效工作）。 平滑器是用我们的水平矩阵和切比雪夫平滑器的强制性附加数据初始化的。我们在这里使用一个相对较高的度数（5），因为矩阵-向量乘积是比较便宜的。我们选择在平滑器中平滑出 $[1.2 \hat{\lambda}_{\max}/15,1.2 \hat{\lambda}_{\max}]$ 的范围，其中 $\hat{\lambda}_{\max}$ 是对最大特征值的估计（系数1.2在PreconditionChebyshev中应用）。为了计算该特征值，Chebyshev初始化执行了几步没有预处理的CG算法。由于最高的特征值通常是最容易找到的，而且一个粗略的估计就足够了，我们选择10次迭代。最后，我们还设置了切比雪夫方法中的内部预处理类型，这是一个雅可比迭代。这由DiagonalMatrix类来表示，该类得到了由我们的LaplaceOperator类提供的反对角线条目。

// 在第0层，我们以不同的方式初始化平滑器，因为我们想使用切比雪夫迭代作为求解器。PreconditionChebyshev允许用户切换到求解器模式，其中迭代次数在内部选择为正确值。在附加数据对象中，通过将多项式的度数选择为 @p numbers::invalid_unsigned_int. 来激活这一设置，然后算法将攻击粗级矩阵中最小和最大之间的所有特征值。切比雪夫平滑器的步数是这样选择的：切比雪夫收敛估计值保证将残差减少到变量 @p  smoothing_range中指定的数字。注意，对于求解来说， @p smoothing_range 是一个相对的公差，并且选择小于1，在这种情况下，我们选择三个数量级，而当只对选定的特征值进行平滑时，它是一个大于1的数字。

// 从计算的角度来看，只要粗粒度适中，Chebyshev迭代是一个非常有吸引力的粗粒度求解器。这是因为Chebyshev方法只执行矩阵-向量乘积和向量更新，这通常比其他迭代方法中涉及的内积更好地并行到有几万个核心的最大集群规模。前者只涉及到（粗）网格中邻居之间的局部通信，而后者则需要在所有处理器上进行全局通信。

    using SmootherType = 
      PreconditionChebyshev<LevelMatrixType, 
                            LinearAlgebra::distributed::Vector<float>>; 
    mg::SmootherRelaxation<SmootherType, 
                           LinearAlgebra::distributed::Vector<float>> 
                                                         mg_smoother; 
    MGLevelObject<typename SmootherType::AdditionalData> smoother_data; 
    smoother_data.resize(0, triangulation.n_global_levels() - 1); 
    for (unsigned int level = 0; level < triangulation.n_global_levels(); 
         ++level) 
      { 
        if (level > 0) 
          { 
            smoother_data[level].smoothing_range     = 15.; 
            smoother_data[level].degree              = 5; 
            smoother_data[level].eig_cg_n_iterations = 10; 
          } 
        else 
          { 
            smoother_data[0].smoothing_range = 1e-3; 
            smoother_data[0].degree          = numbers::invalid_unsigned_int; 
            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m(); 
          } 
        mg_matrices[level].compute_diagonal(); 
        smoother_data[level].preconditioner = 
          mg_matrices[level].get_matrix_diagonal_inverse(); 
      } 
    mg_smoother.initialize(mg_matrices, smoother_data); 

    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>> 
      mg_coarse; 
    mg_coarse.initialize(mg_smoother); 

// 下一步是设置悬挂节点情况下所需的接口矩阵。deal.II中的自适应多网格实现了一种叫做局部平滑的方法。这意味着最细级别的平滑只覆盖固定（最细）网格级别所定义的网格的局部部分，而忽略了计算域中终端单元比该级别更粗的部分。随着该方法向更粗的级别发展，越来越多的全局网格将被覆盖。在某个更粗的层次上，整个网格将被覆盖。由于多网格方法中的所有层次矩阵都覆盖了网格中的单一层次，所以在层次矩阵上不会出现悬空节点。在多网格层之间的界面上，在平滑的同时设置同质Dirichlet边界条件。然而，当残差被转移到下一个更粗的层次时，需要考虑到多网格界面的耦合。这是由所谓的界面（或边缘）矩阵来完成的，它计算了被具有同质Dirichlet条件的层次矩阵所遗漏的残差部分。我们参考 @ref mg_paper "Janssen和Kanschat的多网格论文 "以了解更多细节。

// 对于这些接口矩阵的实现，已经有一个预定义的类 MatrixFreeOperators::MGInterfaceOperator ，它将例程 MatrixFreeOperators::Base::vmult_interface_down() 和 MatrixFreeOperators::Base::vmult_interface_up() 包装在一个带有 @p vmult()和 @p Tvmult() 操作（最初是为矩阵编写的，因此期待这些名字）的新类中。请注意，vmult_interface_down是在多网格V周期的限制阶段使用的，而vmult_interface_up是在延长阶段使用的。

// 一旦接口矩阵被创建，我们完全按照 step-16 的方法设置剩余的多网格预处理基础设施，以获得一个可以应用于矩阵的 @p preconditioner 对象。

    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix( 
      mg_matrices); 

    MGLevelObject<MatrixFreeOperators::MGInterfaceOperator<LevelMatrixType>> 
      mg_interface_matrices; 
    mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1); 
    for (unsigned int level = 0; level < triangulation.n_global_levels(); 
         ++level) 
      mg_interface_matrices[level].initialize(mg_matrices[level]); 
    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_interface( 
      mg_interface_matrices); 

    Multigrid<LinearAlgebra::distributed::Vector<float>> mg( 
      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother); 
    mg.set_edge_matrices(mg_interface, mg_interface); 

    PreconditionMG<dim, 
                   LinearAlgebra::distributed::Vector<float>, 
                   MGTransferMatrixFree<dim, float>> 
      preconditioner(dof_handler, mg, mg_transfer); 

// 多网格程序的设置非常简单，与  step-16  相比，在求解过程中看不出有什么不同。所有的魔法都隐藏在  LaplaceOperator::vmult  操作的实现背后。请注意，我们通过标准输出打印出求解时间和累积的设置时间，也就是说，在任何情况下，而设置操作的详细时间只在构造函数中的detail_times标志被改变的情况下打印。

    SolverControl solver_control(100, 1e-12 * system_rhs.l2_norm()); 
    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control); 
    setup_time += time.wall_time(); 
    time_details << "MG build smoother time     (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s\n"; 
    pcout << "Total setup time               (wall) " << setup_time << "s\n"; 

    time.reset(); 
    time.start(); 
    constraints.set_zero(solution); 
    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    constraints.distribute(solution); 

    pcout << "Time solve (" << solver_control.last_step() << " iterations)" 
          << (solver_control.last_step() < 10 ? "  " : " ") << "(CPU/wall) " 
          << time.cpu_time() << "s/" << time.wall_time() << "s\n"; 
  } 

//  @sect4{LaplaceProblem::output_results}  

// 这里是数据输出，是  step-5  的简化版本。我们对细化过程中产生的每个网格使用标准的VTU（=压缩的VTK）输出。此外，我们还使用了一种针对速度而不是磁盘使用量进行优化的压缩算法。默认设置（针对磁盘使用进行优化）使得保存输出的时间是运行线性求解器的4倍，而将 DataOutBase::VtkFlags::compression_level 设置为 DataOutBase::VtkFlags::best_speed 则将其降低到只有线性求解的四分之一的时间。

// 当网格过大时，我们禁用输出。这个程序的一个变种已经在几十万个MPI行列上运行，网格单元多达1000亿个，经典的可视化工具无法直接访问。

  template <int dim> 
  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    Timer time; 
    if (triangulation.n_global_active_cells() > 1000000) 
      return; 

    DataOut<dim> data_out; 

    solution.update_ghost_values(); 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(mapping); 

    DataOutBase::VtkFlags flags; 
    flags.compression_level = DataOutBase::VtkFlags::best_speed; 
    data_out.set_flags(flags); 
    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", cycle, MPI_COMM_WORLD, 3); 

    time_details << "Time write output          (CPU/wall) " << time.cpu_time() 
                 << "s/" << time.wall_time() << "s\n"; 
  } 

//  @sect4{LaplaceProblem::run}  

// 运行该程序的函数与  step-16  中的函数非常相似。与2D相比，我们在3D中做了很少的细化步骤，但仅此而已。

// 在运行程序之前，我们先输出一些关于检测到的矢量化水平的信息，正如在介绍中所讨论的那样。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    { 
      const unsigned int n_vect_doubles = VectorizedArray<double>::size(); 
      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles; 

      pcout << "Vectorization over " << n_vect_doubles 
            << " doubles = " << n_vect_bits << " bits (" 
            << Utilities::System::get_current_vectorization_level() << ")" 
            << std::endl; 
    } 

    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle) 
      { 
        pcout << "Cycle " << cycle << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation, 0., 1.); 
            triangulation.refine_global(3 - dim); 
          } 
        triangulation.refine_global(1); 
        setup_system(); 
        assemble_rhs(); 
        solve(); 
        output_results(cycle); 
        pcout << std::endl; 
      }; 
  } 
} // namespace Step37 

//  @sect3{The <code>main</code> function}  

// 除了我们根据 step-40 设置了MPI框架外，主函数中没有任何意外。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace Step37; 

      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1); 

      LaplaceProblem<dimension> laplace_problem; 
      laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-38.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2010 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Andrea Bonito, Sebastian Pauletti. 
 */ 


// @sect3{Include files}  

// 如果你读过 step-4 和 step-7 ，你会认识到我们已经在那里使用了以下所有的包含文件。因此，我们不会在这里再次解释它们的含义。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 

#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/solver_control.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 

#include <fstream> 
#include <iostream> 

namespace Step38 
{ 
  using namespace dealii; 
// @sect3{The <code>LaplaceBeltramiProblem</code> class template}  

//这个类几乎与 step-4 中的 <code>LaplaceProblem</code> 类完全相似。

//本质上的区别是这样的。



// - 模板参数现在表示嵌入空间的维度，它不再与域和我们计算的三角形的维度相同。我们通过调用参数 @p spacedim, 并引入一个等于域的维度的常数 @p dim 来表明这一点--这里等于 <code>spacedim-1</code>  。

// - 所有具有几何特征的成员变量现在都需要知道它们自己的维度以及嵌入空间的维度。因此，我们需要指定它们的模板参数，一个是网格的维度 @p dim, ，另一个是嵌入空间的维度， @p spacedim.  这正是我们在 step-34 中所做的，请看那里有更深的解释。

// - 我们需要一个对象来描述从参考单元到三角形组成的单元所使用的哪种映射。从Mapping基类派生出来的类正是这样做的。在deal.II的大部分时间里，如果你不做任何事情，图书馆会假定你想要一个使用（双，三）线性映射的MappingQ1对象。在许多情况下，这就足够了，这就是为什么这些对象的使用大多是可选的：例如，如果你有一个二维空间中的多边形二维域，参考单元到三角形单元的双线性映射会产生该域的精确表示。如果你有一个弯曲的域，你可能想对那些位于域的边界的单元使用一个高阶映射--例如，这就是我们在 step-11 中所做的。然而，在这里我们有一个弯曲的域，而不仅仅是一个弯曲的边界，虽然我们可以用双线性映射的单元来近似它，但对所有单元使用高阶映射才是真正谨慎的。因此，这个类有一个MappingQ类型的成员变量；我们将选择映射的多项式程度等于计算中使用的有限元的多项式程度，以确保最佳近似，尽管这种等参数性不是必须的。

  template <int spacedim> 
  class LaplaceBeltramiProblem 
  { 
  public: 
    LaplaceBeltramiProblem(const unsigned degree = 2); 
    void run(); 

  private: 
    static constexpr unsigned int dim = spacedim - 1; 

    void make_grid_and_dofs(); 
    void assemble_system(); 
    void solve(); 
    void output_results() const; 
    void compute_error() const; 

    Triangulation<dim, spacedim> triangulation; 
    FE_Q<dim, spacedim>          fe; 
    DoFHandler<dim, spacedim>    dof_handler; 
    MappingQ<dim, spacedim>      mapping; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 
  }; 
// @sect3{Equation data}  

// 接下来，让我们定义描述问题的精确解和右手边的类。这与 step-4 和 step-7 相类似，在那里我们也定义了此类对象。鉴于介绍中的讨论，实际的公式应该是不言自明的。值得关注的一点是，我们是如何使用一般模板的明确特化，分别定义2D和3D情况下的值和梯度函数的。另一种方法是定义通用模板，并为空间维度的每个可能的值设置一个 <code>switch</code> 语句（或一串 <code>if</code> s）。

  template <int dim> 
  class Solution : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual Tensor<1, dim> 
    gradient(const Point<dim> & p, 
             const unsigned int component = 0) const override; 
  }; 

  template <> 
  double Solution<2>::value(const Point<2> &p, const unsigned int) const 
  { 
    return (-2. * p(0) * p(1)); 
  } 

  template <> 
  Tensor<1, 2> Solution<2>::gradient(const Point<2> &p, 
                                     const unsigned int) const 
  { 
    Tensor<1, 2> return_value; 
    return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0)); 
    return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1)); 

    return return_value; 
  } 

  template <> 
  double Solution<3>::value(const Point<3> &p, const unsigned int) const 
  { 
    return (std::sin(numbers::PI * p(0)) * std::cos(numbers::PI * p(1)) * 
            exp(p(2))); 
  } 

  template <> 
  Tensor<1, 3> Solution<3>::gradient(const Point<3> &p, 
                                     const unsigned int) const 
  { 
    using numbers::PI; 

    Tensor<1, 3> return_value; 

    return_value[0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 
    return_value[1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2)); 
    return_value[2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 

    return return_value; 
  } 

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <> 
  double RightHandSide<2>::value(const Point<2> &p, 
                                 const unsigned int /*component*/) const 
  { 
    return (-8. * p(0) * p(1)); 
  } 

  template <> 
  double RightHandSide<3>::value(const Point<3> &p, 
                                 const unsigned int /*component*/) const 
  { 
    using numbers::PI; 

    Tensor<2, 3> hessian; 

    hessian[0][0] = -PI * PI * sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 
    hessian[1][1] = -PI * PI * sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 
    hessian[2][2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 

    hessian[0][1] = -PI * PI * cos(PI * p(0)) * sin(PI * p(1)) * exp(p(2)); 
    hessian[1][0] = -PI * PI * cos(PI * p(0)) * sin(PI * p(1)) * exp(p(2)); 

    hessian[0][2] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 
    hessian[2][0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 

    hessian[1][2] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2)); 
    hessian[2][1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2)); 

    Tensor<1, 3> gradient; 
    gradient[0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 
    gradient[1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2)); 
    gradient[2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2)); 

    Point<3> normal = p; 
    normal /= p.norm(); 

    return (-trace(hessian) + 2 * (gradient * normal) + 
            (hessian * normal) * normal); 
  } 
// @sect3{Implementation of the <code>LaplaceBeltramiProblem</code> class}  

// 如果你知道  step-4  ，程序的其余部分实际上是很不引人注目的。我们的第一步是定义构造函数，设置有限元和映射的多项式程度，并将DoF处理程序与三角形关联。

  template <int spacedim> 
  LaplaceBeltramiProblem<spacedim>::LaplaceBeltramiProblem( 
    const unsigned degree) 
    : fe(degree) 
    , dof_handler(triangulation) 
    , mapping(degree) 
  {} 
// @sect4{LaplaceBeltramiProblem::make_grid_and_dofs}  

// 下一步是创建网格，分配自由度，并设置描述线性系统的各种变量。所有这些步骤都是标准的，只有如何创建一个描述曲面的网格除外。我们可以为我们感兴趣的领域生成一个网格，用一个网格生成器生成一个三角形，然后用GridIn类将其读入。或者，就像我们在这里做的那样，我们使用GridGenerator命名空间的设施来生成网格。

// 具体来说，我们要做的是这样的（在下面的大括号中）：我们使用 <code>spacedim</code> 函数为半圆盘（2D）或半球（3D）生成一个 GridGenerator::half_hyper_ball 维度的网格。这个函数将位于圆盘/球周边的所有面的边界指标设置为零，而在将整个圆盘/球分成两半的直线部分设置为零。下一步是主要的一点。 GridGenerator::extract_boundary_mesh 函数创建的网格是由那些作为前一个网格的面的单元组成的，也就是说，它描述了原始（体积）网格的<i>surface</i>单元。然而，我们不需要所有的面：只需要那些在圆盘或球的周边，边界指示器为零的面；我们可以使用一组边界指示器来选择这些单元，并传递给 GridGenerator::extract_boundary_mesh. 。

// 有一点需要提及。为了在流形是弯曲的情况下适当地细化表面网格（类似于细化与弯曲边界相邻的单元面），三角形必须要有一个对象附加在上面，描述新顶点应该位于何处。如果你不附加这样的边界对象，它们将位于现有顶点之间的中间位置；如果你有一个具有直线边界的域（例如多边形），这是很合适的，但如果像这里一样，流形具有曲率，则不合适。因此，为了让事情正常进行，我们需要将流形对象附加到我们的（表面）三角形上，其方式与我们在1d中为边界所做的大致相同。我们创建这样一个对象，并将其附加到三角剖面上。

// 创建网格的最后一步是对其进行多次细化。该函数的其余部分与之前的教程程序中相同。

  template <int spacedim> 
  void LaplaceBeltramiProblem<spacedim>::make_grid_and_dofs() 
  { 
    { 
      Triangulation<spacedim> volume_mesh; 
      GridGenerator::half_hyper_ball(volume_mesh); 

      std::set<types::boundary_id> boundary_ids; 
      boundary_ids.insert(0); 

      GridGenerator::extract_boundary_mesh(volume_mesh, 
                                           triangulation, 
                                           boundary_ids); 
    } 
    triangulation.set_all_manifold_ids(0); 
    triangulation.set_manifold(0, SphericalManifold<dim, spacedim>()); 

    triangulation.refine_global(4); 

    std::cout << "Surface mesh has " << triangulation.n_active_cells() 
              << " cells." << std::endl; 

    dof_handler.distribute_dofs(fe); 

    std::cout << "Surface mesh has " << dof_handler.n_dofs() 
              << " degrees of freedom." << std::endl; 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{LaplaceBeltramiProblem::assemble_system}  

// 下面是这个程序的中心函数，即组装与表面拉普拉斯（Laplace-Beltrami算子）相对应的矩阵。也许令人惊讶的是，它实际上与例如在  step-4  中讨论的普通拉普拉斯算子看起来完全一样。关键是 FEValues::shape_grad() 函数发挥了魔力：它返回 $i$ 第1个形状函数在 $q$ 第1个正交点的表面梯度 $\nabla_K \phi_i(x_q)$ 。其余的也不需要任何改变。

  template <int spacedim> 
  void LaplaceBeltramiProblem<spacedim>::assemble_system() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    const QGauss<dim>       quadrature_formula(2 * fe.degree); 
    FEValues<dim, spacedim> fe_values(mapping, 
                                      fe, 
                                      quadrature_formula, 
                                      update_values | update_gradients | 
                                        update_quadrature_points | 
                                        update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<double>                  rhs_values(n_q_points); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    RightHandSide<spacedim> rhs; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0; 
        cell_rhs    = 0; 

        fe_values.reinit(cell); 

        rhs.value_list(fe_values.get_quadrature_points(), rhs_values); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
              cell_matrix(i, j) += fe_values.shape_grad(i, q_point) * 
                                   fe_values.shape_grad(j, q_point) * 
                                   fe_values.JxW(q_point); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            cell_rhs(i) += fe_values.shape_value(i, q_point) * 
                           rhs_values[q_point] * fe_values.JxW(q_point); 

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              system_matrix.add(local_dof_indices[i], 
                                local_dof_indices[j], 
                                cell_matrix(i, j)); 

            system_rhs(local_dof_indices[i]) += cell_rhs(i); 
          } 
      } 

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values( 
      mapping, dof_handler, 0, Solution<spacedim>(), boundary_values); 

    MatrixTools::apply_boundary_values( 
      boundary_values, system_matrix, solution, system_rhs, false); 
  } 

//  @sect4{LaplaceBeltramiProblem::solve}  

// 下一个函数是解决线性系统的函数。在这里，也不需要做任何改变。

  template <int spacedim> 
  void LaplaceBeltramiProblem<spacedim>::solve() 
  { 
    SolverControl solver_control(solution.size(), 1e-7 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 
  } 

//  @sect4{LaplaceBeltramiProblem::output_result}  

// 这是一个从解决方案中生成图形输出的函数。它的大部分都是模板代码，但有两点值得指出。



// -  DataOut::add_data_vector() 函数可以接受两种向量。  一种是之前通过 DataOut::attach_dof_handler(); 连接的DoFHandler对象定义的每个自由度有一个值的向量，另一种是三角测量的每个单元有一个值的向量，例如，输出每个单元的估计误差。通常，DataOut类知道如何区分这两种向量：自由度几乎总是比单元格多，所以我们可以通过两种向量的长度来区分。我们在这里也可以这样做，但只是因为我们很幸运：我们使用了一个半球体。如果我们用整个球体作为域和 $Q_1$ 元素，我们将有相同数量的单元格作为顶点，因此这两种向量将有相同数量的元素。为了避免由此产生的混乱，我们必须告诉 DataOut::add_data_vector() 函数我们有哪种矢量。DoF数据。这就是该函数的第三个参数的作用。

// -  DataOut::build_patches() 函数可以生成细分每个单元的输出，这样可视化程序可以更好地解决弯曲流形或更高的多项式程度的形状函数。在这里，我们在每个坐标方向上对每个元素进行细分，细分的次数与使用的有限元的多项式程度相同。

  template <int spacedim> 
  void LaplaceBeltramiProblem<spacedim>::output_results() const 
  { 
    DataOut<dim, spacedim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, 
                             "solution", 
                             DataOut<dim, spacedim>::type_dof_data); 
    data_out.build_patches(mapping, mapping.get_degree()); 

    const std::string filename = 
      "solution-" + std::to_string(spacedim) + "d.vtk"; 
    std::ofstream output(filename); 
    data_out.write_vtk(output); 
  } 

//  @sect4{LaplaceBeltramiProblem::compute_error}  

// 这是最后一块功能：我们要计算数值解的误差。它是之前在  step-7  中展示和讨论的代码的逐字复制。正如介绍中提到的， <code>Solution</code> 类提供了解决方案的（切向）梯度。为了避免只评估超收敛点的误差，我们选择一个足够高阶的正交规则。

  template <int spacedim> 
  void LaplaceBeltramiProblem<spacedim>::compute_error() const 
  { 
    Vector<float> difference_per_cell(triangulation.n_active_cells()); 
    VectorTools::integrate_difference(mapping, 
                                      dof_handler, 
                                      solution, 
                                      Solution<spacedim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(2 * fe.degree + 1), 
                                      VectorTools::H1_norm); 

    double h1_error = VectorTools::compute_global_error(triangulation, 
                                                        difference_per_cell, 
                                                        VectorTools::H1_norm); 
    std::cout << "H1 error = " << h1_error << std::endl; 
  } 

//  @sect4{LaplaceBeltramiProblem::run}  

// 最后一个函数提供了顶层的逻辑。它的内容是不言自明的。

  template <int spacedim> 
  void LaplaceBeltramiProblem<spacedim>::run() 
  { 
    make_grid_and_dofs(); 
    assemble_system(); 
    solve(); 
    output_results(); 
    compute_error(); 
  } 
} // namespace Step38 
// @sect3{The main() function}  

// 该程序的其余部分由 <code>main()</code> 函数占据。它完全遵循首次在 step-6 中介绍的一般布局，并在随后的所有教程程序中使用。

int main() 
{ 
  try 
    { 
      using namespace Step38; 

      LaplaceBeltramiProblem<3> laplace_beltrami; 
      laplace_beltrami.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-39.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2010 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Guido Kanschat, Texas A&M University, 2009 
 */ 



// 线性代数的包含文件。一个普通的SparseMatrix，它又将包括SparsityPattern和Vector类的必要文件。

#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/precondition_block.h> 
#include <deal.II/lac/block_vector.h> 

// 包括用于设置网格的文件

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

// FiniteElement类和DoFHandler的包含文件。

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_dgp.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/dofs/dof_tools.h> 

// 使用MeshWorker框架的包含文件

#include <deal.II/meshworker/dof_info.h> 
#include <deal.II/meshworker/integration_info.h> 
#include <deal.II/meshworker/assembler.h> 
#include <deal.II/meshworker/loop.h> 

// 与拉普拉斯相关的局部积分器的包含文件

#include <deal.II/integrators/laplace.h> 

// 支持多网格方法

#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_matrix.h> 
#include <deal.II/multigrid/mg_transfer.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 

// 最后，我们从库中取出我们的精确解，以及正交和附加工具。

#include <deal.II/base/function_lib.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <iostream> 
#include <fstream> 

// deal.II库的所有类都在dealii命名空间中。为了节省打字，我们告诉编译器也要在其中搜索名字。

namespace Step39 
{ 
  using namespace dealii; 

// 这是我们用来设置边界值的函数，也是我们比较的精确解。

  Functions::SlitSingularityFunction<2> exact_solution; 
// @sect3{The local integrators}  

// MeshWorker将局部积分与单元格和面的循环分离开来。因此，我们必须编写局部积分类来生成矩阵、右手边和误差估计器。

// 所有这些类都有相同的三个函数，分别用于对单元、边界面和内部面的积分。局部积分所需的所有信息都由 MeshWorker::IntegrationInfo<dim>. 提供。请注意，函数的签名不能改变，因为它是由 MeshWorker::integration_loop(). 所期望的。

// 第一个定义局部积分器的类负责计算单元和面矩阵。它被用来组装全局矩阵以及水平矩阵。

  template <int dim> 
  class MatrixIntegrator : public MeshWorker::LocalIntegrator<dim> 
  { 
  public: 
    void cell(MeshWorker::DoFInfo<dim> &                 dinfo, 
              typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void 
         boundary(MeshWorker::DoFInfo<dim> &                 dinfo, 
                  typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void face(MeshWorker::DoFInfo<dim> &                 dinfo1, 
              MeshWorker::DoFInfo<dim> &                 dinfo2, 
              typename MeshWorker::IntegrationInfo<dim> &info1, 
              typename MeshWorker::IntegrationInfo<dim> &info2) const override; 
  }; 

// 在每个单元上，我们对Dirichlet形式进行积分。我们使用LocalIntegrators中的现成积分库来避免自己编写这些循环。同样地，我们实现了Nitsche边界条件和单元间的内部惩罚通量。

// 边界和通量项需要一个惩罚参数，这个参数应该根据单元的大小和多项式的度数来调整。在 LocalIntegrators::Laplace::compute_penalty() 中可以找到关于这个参数的安全选择，我们在下面使用这个参数。

  template <int dim> 
  void MatrixIntegrator<dim>::cell( 
    MeshWorker::DoFInfo<dim> &                 dinfo, 
    typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    LocalIntegrators::Laplace::cell_matrix(dinfo.matrix(0, false).matrix, 
                                           info.fe_values()); 
  } 

  template <int dim> 
  void MatrixIntegrator<dim>::boundary( 
    MeshWorker::DoFInfo<dim> &                 dinfo, 
    typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    const unsigned int degree = info.fe_values(0).get_fe().tensor_degree(); 
    LocalIntegrators::Laplace::nitsche_matrix( 
      dinfo.matrix(0, false).matrix, 
      info.fe_values(0), 
      LocalIntegrators::Laplace::compute_penalty(dinfo, dinfo, degree, degree)); 
  } 

// 内部面使用内部惩罚方法

  template <int dim> 
  void MatrixIntegrator<dim>::face( 
    MeshWorker::DoFInfo<dim> &                 dinfo1, 
    MeshWorker::DoFInfo<dim> &                 dinfo2, 
    typename MeshWorker::IntegrationInfo<dim> &info1, 
    typename MeshWorker::IntegrationInfo<dim> &info2) const 
  { 
    const unsigned int degree = info1.fe_values(0).get_fe().tensor_degree(); 
    LocalIntegrators::Laplace::ip_matrix( 
      dinfo1.matrix(0, false).matrix, 
      dinfo1.matrix(0, true).matrix, 
      dinfo2.matrix(0, true).matrix, 
      dinfo2.matrix(0, false).matrix, 
      info1.fe_values(0), 
      info2.fe_values(0), 
      LocalIntegrators::Laplace::compute_penalty( 
        dinfo1, dinfo2, degree, degree)); 
  } 

// 第二个局部积分器建立了右手边。在我们的例子中，右手边的函数为零，这样，这里只设置了弱形式的边界条件。

  template <int dim> 
  class RHSIntegrator : public MeshWorker::LocalIntegrator<dim> 
  { 
  public: 
    void cell(MeshWorker::DoFInfo<dim> &                 dinfo, 
              typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void 
         boundary(MeshWorker::DoFInfo<dim> &                 dinfo, 
                  typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void face(MeshWorker::DoFInfo<dim> &                 dinfo1, 
              MeshWorker::DoFInfo<dim> &                 dinfo2, 
              typename MeshWorker::IntegrationInfo<dim> &info1, 
              typename MeshWorker::IntegrationInfo<dim> &info2) const override; 
  }; 

  template <int dim> 
  void 
  RHSIntegrator<dim>::cell(MeshWorker::DoFInfo<dim> &, 
                           typename MeshWorker::IntegrationInfo<dim> &) const 
  {} 

  template <int dim> 
  void RHSIntegrator<dim>::boundary( 
    MeshWorker::DoFInfo<dim> &                 dinfo, 
    typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    const FEValuesBase<dim> &fe           = info.fe_values(); 
    Vector<double> &         local_vector = dinfo.vector(0).block(0); 

    std::vector<double> boundary_values(fe.n_quadrature_points); 
    exact_solution.value_list(fe.get_quadrature_points(), boundary_values); 

    const unsigned int degree = fe.get_fe().tensor_degree(); 
    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() / 
                           dinfo.cell->measure(); 

    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      for (unsigned int i = 0; i < fe.dofs_per_cell; ++i) 
        local_vector(i) += 
          (-penalty * fe.shape_value(i, k)              // (-sigma * v_i(x_k) 
           + fe.normal_vector(k) * fe.shape_grad(i, k)) // + n * grad v_i(x_k)) 
          * boundary_values[k] * fe.JxW(k);             // u^D(x_k) * dx 
  } 

  template <int dim> 
  void 
  RHSIntegrator<dim>::face(MeshWorker::DoFInfo<dim> &, 
                           MeshWorker::DoFInfo<dim> &, 
                           typename MeshWorker::IntegrationInfo<dim> &, 
                           typename MeshWorker::IntegrationInfo<dim> &) const 
  {} 

//第三个局部积分器负责对误差估计的贡献。这是由Karakashian和Pascal（2003）提出的标准能量估计器。

  template <int dim> 
  class Estimator : public MeshWorker::LocalIntegrator<dim> 
  { 
  public: 
    void cell(MeshWorker::DoFInfo<dim> &                 dinfo, 
              typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void 
         boundary(MeshWorker::DoFInfo<dim> &                 dinfo, 
                  typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void face(MeshWorker::DoFInfo<dim> &                 dinfo1, 
              MeshWorker::DoFInfo<dim> &                 dinfo2, 
              typename MeshWorker::IntegrationInfo<dim> &info1, 
              typename MeshWorker::IntegrationInfo<dim> &info2) const override; 
  }; 

// 单元的贡献是离散解的拉普拉斯，因为右手边是零。

  template <int dim> 
  void 
  Estimator<dim>::cell(MeshWorker::DoFInfo<dim> &                 dinfo, 
                       typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    const FEValuesBase<dim> &fe = info.fe_values(); 

    const std::vector<Tensor<2, dim>> &DDuh = info.hessians[0][0]; 
    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      { 
        const double t = dinfo.cell->diameter() * trace(DDuh[k]); 
        dinfo.value(0) += t * t * fe.JxW(k); 
      } 
    dinfo.value(0) = std::sqrt(dinfo.value(0)); 
  } 

// 在边界，我们简单地使用边界残差的加权形式，即有限元解和正确边界条件之间的差值的规范。

  template <int dim> 
  void Estimator<dim>::boundary( 
    MeshWorker::DoFInfo<dim> &                 dinfo, 
    typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    const FEValuesBase<dim> &fe = info.fe_values(); 

    std::vector<double> boundary_values(fe.n_quadrature_points); 
    exact_solution.value_list(fe.get_quadrature_points(), boundary_values); 

    const std::vector<double> &uh = info.values[0][0]; 

    const unsigned int degree = fe.get_fe().tensor_degree(); 
    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() / 
                           dinfo.cell->measure(); 

    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      { 
        const double diff = boundary_values[k] - uh[k]; 
        dinfo.value(0) += penalty * diff * diff * fe.JxW(k); 
      } 
    dinfo.value(0) = std::sqrt(dinfo.value(0)); 
  } 

// 最后，在内部面，估计器由解的跳跃和它的法向导数组成，并进行适当的加权。

  template <int dim> 
  void 
  Estimator<dim>::face(MeshWorker::DoFInfo<dim> &                 dinfo1, 
                       MeshWorker::DoFInfo<dim> &                 dinfo2, 
                       typename MeshWorker::IntegrationInfo<dim> &info1, 
                       typename MeshWorker::IntegrationInfo<dim> &info2) const 
  { 
    const FEValuesBase<dim> &          fe   = info1.fe_values(); 
    const std::vector<double> &        uh1  = info1.values[0][0]; 
    const std::vector<double> &        uh2  = info2.values[0][0]; 
    const std::vector<Tensor<1, dim>> &Duh1 = info1.gradients[0][0]; 
    const std::vector<Tensor<1, dim>> &Duh2 = info2.gradients[0][0]; 

    const unsigned int degree = fe.get_fe().tensor_degree(); 
    const double       penalty1 = 
      degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure(); 
    const double penalty2 = 
      degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure(); 
    const double penalty = penalty1 + penalty2; 
    const double h       = dinfo1.face->measure(); 

    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      { 
        const double diff1 = uh1[k] - uh2[k]; 
        const double diff2 = 
          fe.normal_vector(k) * Duh1[k] - fe.normal_vector(k) * Duh2[k]; 
        dinfo1.value(0) += 
          (penalty * diff1 * diff1 + h * diff2 * diff2) * fe.JxW(k); 
      } 
    dinfo1.value(0) = std::sqrt(dinfo1.value(0)); 
    dinfo2.value(0) = dinfo1.value(0); 
  } 

// 最后我们有一个误差的积分器。由于不连续Galerkin问题的能量准则不仅涉及到单元内部的梯度差，还涉及到跨面和边界的跳跃项，所以我们不能仅仅使用  VectorTools::integrate_difference().  而是使用MeshWorker接口来自己计算误差。

//有几种不同的方法来定义这个能量准则，但是所有的方法都是随着网格大小的变化而等价的（有些不是随着多项式程度的变化而等价）。这里，我们选择
// @f[ \|u\|_{1,h} =
//  \sum_{K\in \mathbb T_h} \|\nabla u\|_K^2 + \sum_{F \in F_h^i}
//  4\sigma_F\|\average{ u \mathbf n}\|^2_F + \sum_{F \in F_h^b}
//  2\sigma_F\|u\|^2_F 
//  @f]

  template <int dim> 
  class ErrorIntegrator : public MeshWorker::LocalIntegrator<dim> 
  { 
  public: 
    void cell(MeshWorker::DoFInfo<dim> &                 dinfo, 
              typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void 
         boundary(MeshWorker::DoFInfo<dim> &                 dinfo, 
                  typename MeshWorker::IntegrationInfo<dim> &info) const override; 
    void face(MeshWorker::DoFInfo<dim> &                 dinfo1, 
              MeshWorker::DoFInfo<dim> &                 dinfo2, 
              typename MeshWorker::IntegrationInfo<dim> &info1, 
              typename MeshWorker::IntegrationInfo<dim> &info2) const override; 
  }; 

// 这里我们有关于单元格的集成。目前MeshWorker中还没有很好的接口可以让我们访问正交点中的正则函数值。因此，我们必须在单元格积分器中创建精确函数值和梯度的向量。之后，一切照旧，我们只需将差值的平方加起来。

// 除了计算能量准则的误差，我们还利用网格工作者的能力同时计算两个函数并在同一个循环中计算<i>L<sup>2</sup></i>的误差。很明显，这个函数没有任何跳跃项，只出现在单元格的积分中。

  template <int dim> 
  void ErrorIntegrator<dim>::cell( 
    MeshWorker::DoFInfo<dim> &                 dinfo, 
    typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    const FEValuesBase<dim> &   fe = info.fe_values(); 
    std::vector<Tensor<1, dim>> exact_gradients(fe.n_quadrature_points); 
    std::vector<double>         exact_values(fe.n_quadrature_points); 

    exact_solution.gradient_list(fe.get_quadrature_points(), exact_gradients); 
    exact_solution.value_list(fe.get_quadrature_points(), exact_values); 

    const std::vector<Tensor<1, dim>> &Duh = info.gradients[0][0]; 
    const std::vector<double> &        uh  = info.values[0][0]; 

    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      { 
        double sum = 0; 
        for (unsigned int d = 0; d < dim; ++d) 
          { 
            const double diff = exact_gradients[k][d] - Duh[k][d]; 
            sum += diff * diff; 
          } 
        const double diff = exact_values[k] - uh[k]; 
        dinfo.value(0) += sum * fe.JxW(k); 
        dinfo.value(1) += diff * diff * fe.JxW(k); 
      } 
    dinfo.value(0) = std::sqrt(dinfo.value(0)); 
    dinfo.value(1) = std::sqrt(dinfo.value(1)); 
  } 

  template <int dim> 
  void ErrorIntegrator<dim>::boundary( 
    MeshWorker::DoFInfo<dim> &                 dinfo, 
    typename MeshWorker::IntegrationInfo<dim> &info) const 
  { 
    const FEValuesBase<dim> &fe = info.fe_values(); 

    std::vector<double> exact_values(fe.n_quadrature_points); 
    exact_solution.value_list(fe.get_quadrature_points(), exact_values); 

    const std::vector<double> &uh = info.values[0][0]; 

    const unsigned int degree = fe.get_fe().tensor_degree(); 
    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() / 
                           dinfo.cell->measure(); 

    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      { 
        const double diff = exact_values[k] - uh[k]; 
        dinfo.value(0) += penalty * diff * diff * fe.JxW(k); 
      } 
    dinfo.value(0) = std::sqrt(dinfo.value(0)); 
  } 

  template <int dim> 
  void ErrorIntegrator<dim>::face( 
    MeshWorker::DoFInfo<dim> &                 dinfo1, 
    MeshWorker::DoFInfo<dim> &                 dinfo2, 
    typename MeshWorker::IntegrationInfo<dim> &info1, 
    typename MeshWorker::IntegrationInfo<dim> &info2) const 
  { 
    const FEValuesBase<dim> &  fe  = info1.fe_values(); 
    const std::vector<double> &uh1 = info1.values[0][0]; 
    const std::vector<double> &uh2 = info2.values[0][0]; 

    const unsigned int degree = fe.get_fe().tensor_degree(); 
    const double       penalty1 = 
      degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure(); 
    const double penalty2 = 
      degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure(); 
    const double penalty = penalty1 + penalty2; 

    for (unsigned k = 0; k < fe.n_quadrature_points; ++k) 
      { 
        const double diff = uh1[k] - uh2[k]; 
        dinfo1.value(0) += (penalty * diff * diff) * fe.JxW(k); 
      } 
    dinfo1.value(0) = std::sqrt(dinfo1.value(0)); 
    dinfo2.value(0) = dinfo1.value(0); 
  } 

//  @sect3{The main class}  

// 这个类做主要的工作，就像前面的例子一样。关于这里声明的函数的描述，请参考下面的实现。

  template <int dim> 
  class InteriorPenaltyProblem 
  { 
  public: 
    using CellInfo = MeshWorker::IntegrationInfo<dim>; 

    InteriorPenaltyProblem(const FiniteElement<dim> &fe); 

    void run(unsigned int n_steps); 

  private: 
    void   setup_system(); 
    void   assemble_matrix(); 
    void   assemble_mg_matrix(); 
    void   assemble_right_hand_side(); 
    void   error(); 
    double estimate(); 
    void   solve(); 
    void   output_results(const unsigned int cycle) const; 

// 与离散化有关的成员对象在这里。

    Triangulation<dim>        triangulation; 
    const MappingQ1<dim>      mapping; 
    const FiniteElement<dim> &fe; 
    DoFHandler<dim>           dof_handler; 

// 然后，我们有与全局离散系统相关的矩阵和向量。

    SparsityPattern      sparsity; 
    SparseMatrix<double> matrix; 
    Vector<double>       solution; 
    Vector<double>       right_hand_side; 
    BlockVector<double>  estimates; 

// 最后，我们有一组与多级预处理程序相关的稀疏模式和稀疏矩阵。 首先，我们有一个水平矩阵和它的稀疏性模式。

    MGLevelObject<SparsityPattern>      mg_sparsity; 
    MGLevelObject<SparseMatrix<double>> mg_matrix; 

// 当我们在局部细化的网格上进行局部平滑的多重网格时，需要额外的矩阵；见Kanschat（2004）。这里是这些边缘矩阵的稀疏性模式。我们只需要一个，因为上矩阵的模式是下矩阵的转置。实际上，我们并不太关心这些细节，因为MeshWorker正在填充这些矩阵。

    MGLevelObject<SparsityPattern> mg_sparsity_dg_interface; 

// 精细化边缘的通量矩阵，将精细级自由度与粗略级自由度相耦合。

    MGLevelObject<SparseMatrix<double>> mg_matrix_dg_down; 

// 精细化边缘的通量矩阵的转置，将粗级自由度耦合到精细级。

    MGLevelObject<SparseMatrix<double>> mg_matrix_dg_up; 
  }; 

// 构造函数简单地设置了粗略的网格和DoFHandler。FiniteElement作为一个参数被提供，以实现灵活性。

  template <int dim> 
  InteriorPenaltyProblem<dim>::InteriorPenaltyProblem( 
    const FiniteElement<dim> &fe) 
    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices) 
    , mapping() 
    , fe(fe) 
    , dof_handler(triangulation) 
    , estimates(1) 
  { 
    GridGenerator::hyper_cube_slit(triangulation, -1, 1); 
  } 

// 在这个函数中，我们设置了线性系统的维度和全局矩阵以及水平矩阵的稀疏性模式。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::setup_system() 
  { 

// 首先，我们用有限元将自由度分布在网格上并对其进行编号。

    dof_handler.distribute_dofs(fe); 
    dof_handler.distribute_mg_dofs(); 
    unsigned int n_dofs = dof_handler.n_dofs(); 

// 然后，我们已经知道代表有限元函数的向量的大小。

    solution.reinit(n_dofs); 
    right_hand_side.reinit(n_dofs); 

// 接下来，我们为全局矩阵设置稀疏性模式。由于我们事先不知道行的大小，所以我们首先填充一个临时的DynamicSparsityPattern对象，一旦完成，就将其复制到常规的SparsityPattern中。

    DynamicSparsityPattern dsp(n_dofs); 
    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp); 
    sparsity.copy_from(dsp); 
    matrix.reinit(sparsity); 

    const unsigned int n_levels = triangulation.n_levels(); 

// 全局系统已经设置好了，现在我们来关注一下级别矩阵。我们调整所有矩阵对象的大小，以便每一级都有一个矩阵。

    mg_matrix.resize(0, n_levels - 1); 
    mg_matrix.clear_elements(); 
    mg_matrix_dg_up.resize(0, n_levels - 1); 
    mg_matrix_dg_up.clear_elements(); 
    mg_matrix_dg_down.resize(0, n_levels - 1); 
    mg_matrix_dg_down.clear_elements(); 

// 在为水平矩阵调用<tt>clear()</tt>之后更新稀疏模式很重要，因为矩阵通过SmartPointer和Subscriptor机制锁定了稀疏模式。

    mg_sparsity.resize(0, n_levels - 1); 
    mg_sparsity_dg_interface.resize(0, n_levels - 1); 

// 现在，所有的对象都准备好了，可以在每一层容纳一个稀疏模式或矩阵。剩下的就是在每一层设置稀疏模式了。

    for (unsigned int level = mg_sparsity.min_level(); 
         level <= mg_sparsity.max_level(); 
         ++level) 
      { 

// 这些与上面的全局矩阵的行数大致相同，现在是每个级别的。

        DynamicSparsityPattern dsp(dof_handler.n_dofs(level)); 
        MGTools::make_flux_sparsity_pattern(dof_handler, dsp, level); 
        mg_sparsity[level].copy_from(dsp); 
        mg_matrix[level].reinit(mg_sparsity[level]); 

// 另外，我们需要初始化各层之间细化边缘的转移矩阵。它们被存储在两个索引中较细的索引处，因此在0层没有这样的对象。

        if (level > 0) 
          { 
            DynamicSparsityPattern dsp; 
            dsp.reinit(dof_handler.n_dofs(level - 1), 
                       dof_handler.n_dofs(level)); 
            MGTools::make_flux_sparsity_pattern_edge(dof_handler, dsp, level); 
            mg_sparsity_dg_interface[level].copy_from(dsp); 
            mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]); 
            mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]); 
          } 
      } 
  } 

// 在这个函数中，我们组装全局系统矩阵，这里的全局是指我们解决的离散系统的矩阵，它覆盖了整个网格。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::assemble_matrix() 
  { 

// 首先，我们需要设置提供我们集成值的对象。这个对象包含了所有需要的FEValues和FEFaceValues对象，并且自动维护它们，使它们总是指向当前单元。为此，我们首先需要告诉它，在哪里计算，计算什么。由于我们没有做任何花哨的事情，我们可以依靠他们对正交规则的标准选择。

// 由于他们的默认更新标志是最小的，我们另外添加我们需要的东西，即所有对象（单元格、边界和内部面）上的形状函数的值和梯度。之后，我们准备初始化容器，它将创建所有必要的FEValuesBase对象进行整合。

    MeshWorker::IntegrationInfoBox<dim> info_box; 
    UpdateFlags update_flags = update_values | update_gradients; 
    info_box.add_update_flags_all(update_flags); 
    info_box.initialize(fe, mapping); 

// 这就是我们整合本地数据的对象。它由MatrixIntegrator中的局部整合例程填充，然后由汇编器用来将信息分配到全局矩阵中。

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

// 此外，我们还需要一个将局部矩阵装配到全局矩阵的对象。这些装配器对象拥有目标对象结构的所有知识，在这里是一个稀疏矩阵，可能的约束和网格结构。

    MeshWorker::Assembler::MatrixSimple<SparseMatrix<double>> assembler; 
    assembler.initialize(matrix); 

// 现在是我们自己编码的部分，局部积分器。这是唯一与问题有关的部分。

    MatrixIntegrator<dim> integrator; 

// 现在，我们把所有的东西都扔到 MeshWorker::loop(), 中，在这里遍历网格的所有活动单元，计算单元和面的矩阵，并把它们集合到全局矩阵中。我们在这里使用变量<tt>dof_handler</tt>，以便使用全局自由度的编号。

    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(), 
                                           dof_handler.end(), 
                                           dof_info, 
                                           info_box, 
                                           integrator, 
                                           assembler); 
  } 

// 现在，我们对水平矩阵做同样的处理。不太令人惊讶的是，这个函数看起来像前一个函数的孪生兄弟。事实上，只有两个小的区别。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::assemble_mg_matrix() 
  { 
    MeshWorker::IntegrationInfoBox<dim> info_box; 
    UpdateFlags update_flags = update_values | update_gradients; 
    info_box.add_update_flags_all(update_flags); 
    info_box.initialize(fe, mapping); 

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

// 很明显，需要用一个填充水平矩阵的汇编器来代替。请注意，它也会自动填充边缘矩阵。

    MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler; 
    assembler.initialize(mg_matrix); 
    assembler.initialize_fluxes(mg_matrix_dg_up, mg_matrix_dg_down); 

    MatrixIntegrator<dim> integrator; 

// 这里是与前一个函数的另一个不同之处：我们在所有单元上运行，而不仅仅是活动单元。而且我们使用以 <code>_mg</code> 结尾的函数，因为我们需要每一层的自由度，而不是全局的编号。

    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_mg(), 
                                           dof_handler.end_mg(), 
                                           dof_info, 
                                           info_box, 
                                           integrator, 
                                           assembler); 
  } 

// 这里我们有另一个assemble函数的克隆。与组装系统矩阵的区别在于，我们在这里组装了一个向量。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::assemble_right_hand_side() 
  { 
    MeshWorker::IntegrationInfoBox<dim> info_box; 
    UpdateFlags                         update_flags = 
      update_quadrature_points | update_values | update_gradients; 
    info_box.add_update_flags_all(update_flags); 
    info_box.initialize(fe, mapping); 

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

// 因为这个汇编器允许我们填充多个向量，所以接口要比上面复杂一些。向量的指针必须存储在一个AnyData对象中。虽然这在这里似乎造成了两行额外的代码，但实际上在更复杂的应用中它是很方便的。

    MeshWorker::Assembler::ResidualSimple<Vector<double>> assembler; 
    AnyData                                               data; 
    data.add<Vector<double> *>(&right_hand_side, "RHS"); 
    assembler.initialize(data); 

    RHSIntegrator<dim> integrator; 
    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(), 
                                           dof_handler.end(), 
                                           dof_info, 
                                           info_box, 
                                           integrator, 
                                           assembler); 

    right_hand_side *= -1.; 
  } 

// 现在，我们已经对构建离散线性系统的所有函数进行了编码，现在是我们实际解决它的时候了。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::solve() 
  { 

// 选择的求解器是共轭梯度。

    SolverControl            control(1000, 1.e-12); 
    SolverCG<Vector<double>> solver(control); 

// 现在我们正在设置多级预处理程序的组件。首先，我们需要在网格层之间进行转移。我们在这里使用的对象为这些转移生成了稀疏矩阵。

    MGTransferPrebuilt<Vector<double>> mg_transfer; 
    mg_transfer.build(dof_handler); 

// 然后，我们需要一个精确的解算器来解算最粗层次上的矩阵。

    FullMatrix<double> coarse_matrix; 
    coarse_matrix.copy_from(mg_matrix[0]); 
    MGCoarseGridHouseholder<double, Vector<double>> mg_coarse; 
    mg_coarse.initialize(coarse_matrix); 

// 虽然转移和粗略网格求解器几乎是通用的，但为平滑器提供了更多的灵活性。首先，我们选择Gauss-Seidel作为我们的平滑方法。

    GrowingVectorMemory<Vector<double>> mem; 
    using RELAXATION = PreconditionSOR<SparseMatrix<double>>; 
    mg::SmootherRelaxation<RELAXATION, Vector<double>> mg_smoother; 
    RELAXATION::AdditionalData                         smoother_data(1.); 
    mg_smoother.initialize(mg_matrix, smoother_data); 

// 在每个级别上做两个平滑步骤。

    mg_smoother.set_steps(2); 

// 由于SOR方法不是对称的，但我们在下面使用共轭梯度迭代，这里有一个技巧，使多级预处理器成为对称算子，即使是对非对称平滑器。

    mg_smoother.set_symmetric(true); 

// 平滑器类可以选择实现变量V型循环，我们在这里不需要。

    mg_smoother.set_variable(false); 

// 最后，我们必须将我们的矩阵包裹在一个具有所需乘法函数的对象中。

    mg::Matrix<Vector<double>> mgmatrix(mg_matrix); 
    mg::Matrix<Vector<double>> mgdown(mg_matrix_dg_down); 
    mg::Matrix<Vector<double>> mgup(mg_matrix_dg_up); 

// 现在，我们准备设置V型循环算子和多级预处理程序。

    Multigrid<Vector<double>> mg( 
      mgmatrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother); 

// 让我们不要忘记因为自适应细化而需要的边缘矩阵。

    mg.set_edge_flux_matrices(mgdown, mgup); 

// 在所有的准备工作完成后，将Multigrid对象包装成另一个对象，它可以作为一个普通的预处理程序使用。

    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>> 
      preconditioner(dof_handler, mg, mg_transfer); 

// 并用它来解决这个系统。

    solver.solve(matrix, solution, right_hand_side, preconditioner); 
  } 

// 另一个克隆的集合函数。与之前的最大区别是，这里我们也有一个输入向量。

  template <int dim> 
  double InteriorPenaltyProblem<dim>::estimate() 
  { 

// 估算器的结果存储在一个每个单元格有一个条目的向量中。由于deal.II中的单元格没有编号，我们必须建立自己的编号，以便使用这个向量。对于下面使用的汇编器来说，结果存储在向量的哪个分量中的信息是由每个单元的user_index变量传送的。我们需要在这里设置这个编号。

// 另一方面，有人可能已经使用了用户指数。所以，让我们做个好公民，在篡改它们之前保存它们。

    std::vector<unsigned int> old_user_indices; 
    triangulation.save_user_indices(old_user_indices); 

    estimates.block(0).reinit(triangulation.n_active_cells()); 
    unsigned int i = 0; 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      cell->set_user_index(i++); 

// 这就像以前一样开始。

    MeshWorker::IntegrationInfoBox<dim> info_box; 
    const unsigned int                  n_gauss_points = 
      dof_handler.get_fe().tensor_degree() + 1; 
    info_box.initialize_gauss_quadrature(n_gauss_points, 
                                         n_gauss_points + 1, 
                                         n_gauss_points); 

// 但现在我们需要通知信息框我们要在正交点上评估的有限元函数。首先，我们用这个向量创建一个AnyData对象，这个向量就是我们刚刚计算的解。

    AnyData solution_data; 
    solution_data.add<const Vector<double> *>(&solution, "solution"); 

// 然后，我们告诉单元格的 Meshworker::VectorSelector ，我们需要这个解决方案的二次导数（用来计算拉普拉斯）。因此，选择函数值和第一导数的布尔参数是假的，只有选择第二导数的最后一个参数是真的。

    info_box.cell_selector.add("solution", false, false, true); 

// 在内部和边界面，我们需要函数值和第一导数，但不需要第二导数。

    info_box.boundary_selector.add("solution", true, true, false); 
    info_box.face_selector.add("solution", true, true, false); 

// 我们继续像以前一样，除了默认的更新标志已经被调整为我们上面要求的值和导数之外。

    info_box.add_update_flags_boundary(update_quadrature_points); 
    info_box.initialize(fe, mapping, solution_data, solution); 

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

// 汇编器在每个单元格中存储一个数字，否则这与右侧的计算是一样的。

    MeshWorker::Assembler::CellsAndFaces<double> assembler; 
    AnyData                                      out_data; 
    out_data.add<BlockVector<double> *>(&estimates, "cells"); 
    assembler.initialize(out_data, false); 

    Estimator<dim> integrator; 
    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(), 
                                           dof_handler.end(), 
                                           dof_info, 
                                           info_box, 
                                           integrator, 
                                           assembler); 

// 就在我们返回错误估计的结果之前，我们恢复旧的用户索引。

    triangulation.load_user_indices(old_user_indices); 
    return estimates.block(0).l2_norm(); 
  } 

// 这里我们把我们的有限元解和（已知的）精确解进行比较，计算梯度和函数本身的平均二次误差。这个函数是上面那个估计函数的克隆。

// 由于我们分别计算能量和<i>L<sup>2</sup></i>-norm的误差，我们的块向量在这里需要两个块。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::error() 
  { 
    BlockVector<double> errors(2); 
    errors.block(0).reinit(triangulation.n_active_cells()); 
    errors.block(1).reinit(triangulation.n_active_cells()); 

    std::vector<unsigned int> old_user_indices; 
    triangulation.save_user_indices(old_user_indices); 
    unsigned int i = 0; 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      cell->set_user_index(i++); 

    MeshWorker::IntegrationInfoBox<dim> info_box; 
    const unsigned int                  n_gauss_points = 
      dof_handler.get_fe().tensor_degree() + 1; 
    info_box.initialize_gauss_quadrature(n_gauss_points, 
                                         n_gauss_points + 1, 
                                         n_gauss_points); 

    AnyData solution_data; 
    solution_data.add<Vector<double> *>(&solution, "solution"); 

    info_box.cell_selector.add("solution", true, true, false); 
    info_box.boundary_selector.add("solution", true, false, false); 
    info_box.face_selector.add("solution", true, false, false); 

    info_box.add_update_flags_cell(update_quadrature_points); 
    info_box.add_update_flags_boundary(update_quadrature_points); 
    info_box.initialize(fe, mapping, solution_data, solution); 

    MeshWorker::DoFInfo<dim> dof_info(dof_handler); 

    MeshWorker::Assembler::CellsAndFaces<double> assembler; 
    AnyData                                      out_data; 
    out_data.add<BlockVector<double> *>(&errors, "cells"); 
    assembler.initialize(out_data, false); 

    ErrorIntegrator<dim> integrator; 
    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(), 
                                           dof_handler.end(), 
                                           dof_info, 
                                           info_box, 
                                           integrator, 
                                           assembler); 
    triangulation.load_user_indices(old_user_indices); 

    deallog << "energy-error: " << errors.block(0).l2_norm() << std::endl; 
    deallog << "L2-error:     " << errors.block(1).l2_norm() << std::endl; 
  } 

// 创建图形输出。我们通过整理其各个组成部分的名称来产生文件名，包括我们用两个数字输出的细化周期。

  template <int dim> 
  void 
  InteriorPenaltyProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    const std::string filename = 
      "sol-" + Utilities::int_to_string(cycle, 2) + ".gnuplot"; 

    deallog << "Writing solution to <" << filename << ">..." << std::endl 
            << std::endl; 
    std::ofstream gnuplot_output(filename); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "u"); 
    data_out.add_data_vector(estimates.block(0), "est"); 

    data_out.build_patches(); 

    data_out.write_gnuplot(gnuplot_output); 
  } 

// 最后是自适应循环，或多或少和前面的例子一样。

  template <int dim> 
  void InteriorPenaltyProblem<dim>::run(unsigned int n_steps) 
  { 
    deallog << "Element: " << fe.get_name() << std::endl; 
    for (unsigned int s = 0; s < n_steps; ++s) 
      { 
        deallog << "Step " << s << std::endl; 
        if (estimates.block(0).size() == 0) 
          triangulation.refine_global(1); 
        else 
          { 
            GridRefinement::refine_and_coarsen_fixed_fraction( 
              triangulation, estimates.block(0), 0.5, 0.0); 
            triangulation.execute_coarsening_and_refinement(); 
          } 

        deallog << "Triangulation " << triangulation.n_active_cells() 
                << " cells, " << triangulation.n_levels() << " levels" 
                << std::endl; 

        setup_system(); 
        deallog << "DoFHandler " << dof_handler.n_dofs() << " dofs, level dofs"; 
        for (unsigned int l = 0; l < triangulation.n_levels(); ++l) 
          deallog << ' ' << dof_handler.n_dofs(l); 
        deallog << std::endl; 

        deallog << "Assemble matrix" << std::endl; 
        assemble_matrix(); 
        deallog << "Assemble multilevel matrix" << std::endl; 
        assemble_mg_matrix(); 
        deallog << "Assemble right hand side" << std::endl; 
        assemble_right_hand_side(); 
        deallog << "Solve" << std::endl; 
        solve(); 
        error(); 
        deallog << "Estimate " << estimate() << std::endl; 
        output_results(s); 
      } 
  } 
} // namespace Step39 

int main() 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step39; 

      deallog.depth_console(2); 
      std::ofstream logfile("deallog"); 
      deallog.attach(logfile); 
      FE_DGQ<2>                 fe1(3); 
      InteriorPenaltyProblem<2> test1(fe1); 
      test1.run(12); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-4.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 1999 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 1999 
 */ 


// @sect3{Include files}  

// 前面几个（很多）include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。

#include <deal.II/grid/tria.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 

#include <deal.II/numerics/data_out.h> 
#include <fstream> 
#include <iostream> 

// 这是新的，但是：在前面的例子中，我们从线性求解器得到了一些不需要的输出。如果我们想抑制它，我们必须包括这个文件，并在程序的某个地方添加一行字（见下面的main()函数）。

#include <deal.II/base/logstream.h> 

// 最后一步，和以前的程序一样，是将所有deal.II的类和函数名导入全局命名空间中。

using namespace dealii; 
// @sect3{The <code>Step4</code> class template}  

// 这又是前面例子中的 <code>Step4</code> 类。唯一不同的是，我们现在把它声明为一个带有模板参数的类，而模板参数当然是我们要解决拉普拉斯方程的空间维度。当然，几个成员变量也取决于这个维度，特别是Triangulation类，它必须分别表示四边形或六面体。除此以外，一切都和以前一样。

template <int dim> 
class Step4 
{ 
public: 
  Step4(); 
  void run(); 

private: 
  void make_grid(); 
  void setup_system(); 
  void assemble_system(); 
  void solve(); 
  void output_results() const; 

  Triangulation<dim> triangulation; 
  FE_Q<dim>          fe; 
  DoFHandler<dim>    dof_handler; 

  SparsityPattern      sparsity_pattern; 
  SparseMatrix<double> system_matrix; 

  Vector<double> solution; 
  Vector<double> system_rhs; 
}; 
// @sect3{Right hand side and boundary values}  

// 在下文中，我们又声明了两个类，表示右手边和非均质的Dirichlet边界值。两者都是一个二维空间变量的函数，所以我们也将它们声明为模板。

// 这些类中的每一个都是从一个共同的、抽象的基类Function派生出来的，它声明了所有函数都必须遵循的共同接口。特别是，具体的类必须重载 <code>value</code> 函数，该函数接收二维空间中的一个点作为参数，并将该点的值作为 <code>double</code> 变量返回。

//  <code>value</code> 函数需要第二个参数，我们在这里将其命名为 <code>component</code>  : 这只适用于矢量值函数，你可能想访问点 <code>p</code> 处的矢量的某个分量。然而，我们的函数是标量的，所以我们不需要担心这个参数，在函数的实现中也不会使用它。在库的头文件中，Function基类对 <code>value</code> 函数的声明中，分量的默认值为0，所以我们在访问右侧的 <code>value</code> 函数时，只需要一个参数，即我们要评估函数的点。然后，对于标量函数，可以简单地省略分量的值。

// 函数对象在库中很多地方都有使用（例如，在 step-3 中我们使用了一个 Functions::ZeroFunction 实例作为 VectorTools::interpolate_boundary_values) 的参数，这是我们定义一个继承自Function的新类的第一个教程。由于我们只调用 Function::value(), ，我们可以只用一个普通的函数（这就是 step-5 中的做法），但由于这是一个教程，为了举例说明，我们继承了Function。

template <int dim> 
class RightHandSide : public Function<dim> 
{ 
public: 
  virtual double value(const Point<dim> & p, 
                       const unsigned int component = 0) const override; 
}; 

template <int dim> 
class BoundaryValues : public Function<dim> 
{ 
public: 
  virtual double value(const Point<dim> & p, 
                       const unsigned int component = 0) const override; 
}; 

// 如果你不熟悉上述函数声明中的关键字 "virtual "和 "override "是什么意思，你可能会想看看你最喜欢的C++书籍或在线教程，如http:www.cplusplus.com/doc/tutorial/polymorphism/ 。从本质上讲，这里发生的事情是Function<dim>是一个 "抽象 "基类，它声明了某种 "接口"--一组可以在这类对象上调用的函数。但它实际上并没有*实现*这些函数：它只是说 "Function对象是这样的"，但它实际上是什么样的函数，则留给实现了`value()`函数的派生类。

// 从另一个类中派生出一个类，通常称为 "is-a "关系函数。在这里，`RightHandSide`类 "是一个 "函数类，因为它实现了Function基类所描述的接口。("value() "函数的实际实现在下面的代码块中)。那么`virtual`关键字意味着 "是的，这里的函数可以被派生类覆盖"，而`override`关键字意味着 "是的，这实际上是一个我们知道已经被声明为基类一部分的函数"。覆盖 "关键字不是严格必要的，但它是防止打字错误的一个保险。如果我们把函数的名字或一个参数的类型弄错了，编译器会警告我们说："你说这个函数覆盖了基类中的一个函数，但实际上我不知道有任何这样的函数有这个名字和这些参数。"

// 但回到这里的具体案例。在本教程中，我们选择2D中的函数 $4(x^4+y^4)$ ，或者3D中的 $4(x^4+y^4+z^4)$ 作为右手边。我们可以用空间维度上的if语句来写这个区别，但这里有一个简单的方法，通过使用一个短循环，也允许我们在一维（或四维，如果你想这样做）中使用相同的函数。 幸运的是，编译器在编译时就知道循环的大小（记住，在你定义模板时，编译器不知道 <code>dim</code> 的值，但当它后来遇到语句或声明 <code>RightHandSide@<2@></code> 时，它将采取模板，用2替换所有出现的dim，并编译出结果函数）。 换句话说，在编译这个函数的时候，主体将被执行的次数是已知的，编译器可以将循环所需的开销降到最低；结果将和我们马上使用上面的公式一样快。

// 最后要注意的是， <code>Point@<dim@></code> 表示二维空间中的一个点，它的各个组成部分（即 $x$ 、 $y$ 、...坐标）可以像C和C++中一样用（）运算符访问（事实上，[]运算符也同样有效），索引从0开始。

template <int dim> 
double RightHandSide<dim>::value(const Point<dim> &p, 
                                 const unsigned int /*component*/) const 
{ 
  double return_value = 0.0; 
  for (unsigned int i = 0; i < dim; ++i) 
    return_value += 4.0 * std::pow(p(i), 4.0); 

  return return_value; 
} 

// 作为边界值，我们选择二维的 $x^2+y^2$ ，三维的 $x^2+y^2+z^2$ 。这恰好等于从原点到我们想评估函数的点的矢量的平方，而不考虑维度。所以这就是我们的返回值。

template <int dim> 
double BoundaryValues<dim>::value(const Point<dim> &p, 
                                  const unsigned int /*component*/) const 
{ 
  return p.square(); 
} 

//  @sect3{Implementation of the <code>Step4</code> class}  

// 接下来是利用上述函数的类模板的实现。和以前一样，我们将把所有东西写成模板，这些模板有一个形式参数 <code>dim</code> ，在我们定义模板函数时，我们假设这个参数是未知的。只有在以后，编译器才会发现 <code>Step4@<2@></code> (in the <code>main</code> 函数的声明，实际上），并在编译整个类时将 <code>dim</code> 替换成2，这个过程被称为 "模板的实例化"。这样做的时候，它也会用 <code>RightHandSide@<dim@></code> 的实例替换 <code>RightHandSide@<2@></code> ，并从类模板中实例化后一个类。

// 事实上，编译器也会在 <code>main()</code> 中找到一个 <code>Step4@<3@></code> 声明。这将导致它再次回到一般的 <code>Step4@<dim@></code> 模板，替换所有出现的 <code>dim</code> ，这次是3，并第二次编译这个类。注意这两个实例  <code>Step4@<2@></code>  和  <code>Step4@<3@></code>  是完全独立的类；它们唯一的共同特征是它们都是从同一个通用模板中实例化出来的，但是它们不能相互转换，例如，它们没有共享代码（两个实例都是完全独立编译的）。

//  @sect4{Step4::Step4}  

// 在这个介绍之后，这里是  <code>Step4</code>  类的构造函数。它指定了所需的有限元素的多项式程度，并将DoFHandler与三角形关联起来，就像在前面的例子程序中一样，  step-3  。

template <int dim> 
Step4<dim>::Step4() 
  : fe(1) 
  , dof_handler(triangulation) 
{} 
// @sect4{Step4::make_grid}  

// 网格的创建在本质上是与维度有关的东西。然而，只要领域在二维或三维中足够相似，库就可以为你抽象。在我们的例子中，我们想再次在二维的正方形 $[-1,1]\times [-1,1]$ 上求解，或者在三维的立方体 $[-1,1] \times [-1,1] \times [-1,1]$ 上求解；两者都可以被称为 GridGenerator::hyper_cube(), ，因此我们可以在任何维度上使用同一个函数。当然，在二维和三维中创建超立方体的函数有很大的不同，但这是你不需要关心的事情。让库来处理这些困难的事情。

template <int dim> 
void Step4<dim>::make_grid() 
{ 
  GridGenerator::hyper_cube(triangulation, -1, 1); 
  triangulation.refine_global(4); 

  std::cout << "   Number of active cells: " << triangulation.n_active_cells() 
            << std::endl 
            << "   Total number of cells: " << triangulation.n_cells() 
            << std::endl; 
} 
// @sect4{Step4::setup_system}  

// 这个函数看起来和前面的例子完全一样，尽管它执行的动作在细节上有很大的不同，如果 <code>dim</code> 刚好是3。从用户的角度来看，唯一显著的区别是所产生的单元格数量，在三个空间维度中比两个空间维度中要高得多

template <int dim> 
void Step4<dim>::setup_system() 
{ 
  dof_handler.distribute_dofs(fe); 

  std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
            << std::endl; 

  DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
  DoFTools::make_sparsity_pattern(dof_handler, dsp); 
  sparsity_pattern.copy_from(dsp); 

  system_matrix.reinit(sparsity_pattern); 

  solution.reinit(dof_handler.n_dofs()); 
  system_rhs.reinit(dof_handler.n_dofs()); 
} 
// @sect4{Step4::assemble_system}  

// 与前面的例子不同，我们现在想使用一个非恒定的右侧函数和非零边界值。这两个任务都是很容易实现的，只需在矩阵和右手边的组合中增加几行代码即可。

// 更有趣的是，我们将矩阵和右手边的向量维度独立组装起来的方式：与二维的情况根本没有区别。由于这个函数中使用的重要对象（正交公式、FEValues）也通过模板参数的方式依赖于维度，它们可以为这个函数所编译的维度正确设置一切。通过使用模板参数声明所有可能依赖于维度的类，库可以为你完成几乎所有的工作，你不需要关心大多数事情。

template <int dim> 
void Step4<dim>::assemble_system() 
{ 
  QGauss<dim> quadrature_formula(fe.degree + 1); 

// 我们希望有一个非恒定的右手，所以我们使用上面声明的类的一个对象来生成必要的数据。由于这个右侧对象只在本函数中局部使用，所以我们在这里把它声明为一个局部变量。

  RightHandSide<dim> right_hand_side; 

// 与之前的例子相比，为了评估非恒定右手函数，我们现在还需要我们目前所在单元上的正交点（之前，我们只需要FEValues对象中的形状函数的值和梯度，以及正交权重， FEValues::JxW() ）。我们可以通过给FEValues对象添加#update_quadrature_points标志来让它为我们做事。

  FEValues<dim> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_gradients | 
                            update_quadrature_points | update_JxW_values); 

// 然后我们再次定义与前面程序中相同的缩写。这个变量的值当然取决于我们现在使用的维度，但是FiniteElement类为你做了所有必要的工作，你不需要关心与维度有关的部分。

  const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
  Vector<double>     cell_rhs(dofs_per_cell); 

  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 接下来，我们又要在所有的单元格上进行循环，并汇集局部贡献。 请注意，一个单元在两个空间维度上是一个四边形，但在三维上是一个六面体。事实上， <code>active_cell_iterator</code> 的数据类型是不同的，这取决于我们所处的维度，但对外界来说，它们看起来是一样的，你可能永远不会看到区别。在任何情况下，真正的类型是通过使用`auto`来隐藏的。

  for (const auto &cell : dof_handler.active_cell_iterators()) 
    { 
      fe_values.reinit(cell); 
      cell_matrix = 0; 
      cell_rhs    = 0; 

// 现在我们要把本地矩阵和右手边组合起来。这个过程和前面的例子完全一样，但是现在我们重新调整循环的顺序（我们可以安全地这样做，因为它们是相互独立的），并尽可能地合并本地矩阵和本地向量的循环，使事情变得更快。

// 组装右手边与我们在 step-3 中的做法有唯一的区别：我们没有使用值为1的常数右手边，而是使用代表右手边的对象并在正交点对其进行评估。

      for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
        for (const unsigned int i : fe_values.dof_indices()) 
          { 
            for (const unsigned int j : fe_values.dof_indices()) 
              cell_matrix(i, j) += 
                (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q) 
                 fe_values.shape_grad(j, q_index) * // grad phi_j(x_q) 
                 fe_values.JxW(q_index));           // dx 

            const auto &x_q = fe_values.quadrature_point(q_index); 
            cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q) 
                            right_hand_side.value(x_q) *        // f(x_q) 
                            fe_values.JxW(q_index));            // dx 
          } 

// 作为对这些循环的最后说明：当我们将局部贡献集合到 <code>cell_matrix(i,j)</code> 时，我们必须将形状函数 $i$ 和 $j$ 在点号q_index的梯度相乘并与标量权重JxW相乘。这就是实际发生的情况。  <code>fe_values.shape_grad(i,q_index)</code> 返回一个 <code>dim</code> 维向量，由 <code>Tensor@<1,dim@></code> 对象表示，将其与 <code>fe_values.shape_grad(j,q_index)</code> 的结果相乘的运算器*确保两个向量的 <code>dim</code> 分量被适当收缩，结果是一个标量浮点数，然后与权重相乘。在内部，这个操作符*确保对向量的所有 <code>dim</code> 分量都能正确发生，无论 <code>dim</code> 是2、3还是其他空间维度；从用户的角度来看，这并不值得费心，然而，如果想独立编写代码维度，事情就会简单很多。

// 随着本地系统的组装，转移到全局矩阵和右手边的工作与之前完全一样，但在这里我们再次合并了一些循环以提高效率。

      cell->get_dof_indices(local_dof_indices); 
      for (const unsigned int i : fe_values.dof_indices()) 
        { 
          for (const unsigned int j : fe_values.dof_indices()) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 

          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
        } 
    } 

// 作为这个函数的最后一步，我们希望在这个例子中拥有非均质的边界值，与之前的例子不同。这是一个简单的任务，我们只需要用一个描述我们想使用的边界值的类的对象（即上面声明的 <code>BoundaryValues</code> 类）来替换那里使用的 Functions::ZeroFunction 。

// 函数 VectorTools::interpolate_boundary_values() 只对标有边界指标0的面起作用（因为我们在下面的第二个参数中说该函数应该对其起作用）。如果有的面的边界指标不是0，那么函数interpolate_boundary_values将对这些面不起作用。对于拉普拉斯方程来说，什么都不做相当于假设在边界的这些部分，零诺伊曼边界条件成立。

  std::map<types::global_dof_index, double> boundary_values; 
  VectorTools::interpolate_boundary_values(dof_handler, 
                                           0, 
                                           BoundaryValues<dim>(), 
                                           boundary_values); 
  MatrixTools::apply_boundary_values(boundary_values, 
                                     system_matrix, 
                                     solution, 
                                     system_rhs); 
} 
// @sect4{Step4::solve}  

// 解决线性方程组是在大多数程序中看起来几乎相同的事情。特别是，它与维度无关，所以这个函数是从前面的例子中逐字复制的。

template <int dim> 
void Step4<dim>::solve() 
{ 
  SolverControl            solver_control(1000, 1e-12); 
  SolverCG<Vector<double>> solver(solver_control); 
  solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity()); 

// 不过我们做了一个补充：由于我们抑制了线性求解器的输出，我们必须手工打印迭代次数。

  std::cout << "   " << solver_control.last_step() 
            << " CG iterations needed to obtain convergence." << std::endl; 
} 
// @sect4{Step4::output_results}  

// 这个函数也做了  step-3  中各自的工作。这里也没有改变维度的独立性。

// 由于程序将同时运行拉普拉斯求解器的2D和3D版本，我们使用文件名中的维度为每次运行生成不同的文件名（在一个更好的程序中，我们将检查 <code>dim</code> 是否可以有2或3以外的其他值，但为了简洁起见，我们在这里忽略了这一点）。

template <int dim> 
void Step4<dim>::output_results() const 
{ 
  DataOut<dim> data_out; 

  data_out.attach_dof_handler(dof_handler); 
  data_out.add_data_vector(solution, "solution"); 

  data_out.build_patches(); 

  std::ofstream output(dim == 2 ? "solution-2d.vtk" : "solution-3d.vtk"); 
  data_out.write_vtk(output); 
} 

//  @sect4{Step4::run}  

// 这是一个对所有事情都有最高级别控制的函数。除了一行额外的输出外，它与前面的例子相同。

template <int dim> 
void Step4<dim>::run() 
{ 
  std::cout << "Solving problem in " << dim << " space dimensions." 
            << std::endl; 

  make_grid(); 
  setup_system(); 
  assemble_system(); 
  solve(); 
  output_results(); 
} 
// @sect3{The <code>main</code> function}  

// 这是主函数。它看起来也大多像 step-3 中的内容，但如果你看下面的代码，注意我们是如何首先创建一个 <code>Step4@<2@></code> 类型的变量（迫使编译器用 <code>dim</code> replaced by <code>2</code> 编译类模板）并运行一个2d模拟，然后我们用3d做整个事情。

// 在实践中，这可能不是你经常做的事情（你可能要么想解决一个2D的问题，要么想解决一个3D的问题，但不会同时解决这两个问题）。然而，它展示了一种机制，我们可以在一个地方简单地改变我们想要的维度，从而迫使编译器为我们要求的维度重新编译独立的类模板。这里的重点在于，我们只需要改变一个地方。这使得在计算速度较快的2D环境下调试程序变得非常简单，然后将一个地方切换到3，在3D环境下运行计算量大得多的程序，进行 "真实 "的计算。

// 这两个区块中的每一个都用大括号括起来，以确保 <code>laplace_problem_2d</code> 这个变量在我们继续为3D情况分配内存之前就已经超出了范围（并释放了它所持有的内存）。如果没有额外的大括号， <code>laplace_problem_2d</code> 变量只会在函数结束时被销毁，也就是在运行完3d问题后被销毁，而且会在3d运行时不必要地占用内存，而实际使用它。

int main() 
{ 
  { 
    Step4<2> laplace_problem_2d; 
    laplace_problem_2d.run(); 
  } 

  { 
    Step4<3> laplace_problem_3d; 
    laplace_problem_3d.run(); 
  } 

  return 0; 
} 


CCTest_file/step-40.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Texas A&M University, 2009, 2010 
 *         Timo Heister, University of Goettingen, 2009, 2010 
 */ 


// @sect3{Include files}  

// 我们在这个程序中需要的大部分包含文件已经在以前的程序中讨论过了。特别是，以下所有的文件都应该已经是熟悉的朋友了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/lac/generic_linear_algebra.h> 

// 这个程序可以使用PETSc或Trilinos来满足其并行代数的需要。默认情况下，如果deal.II已经被配置为PETSc，它将使用PETSc。否则，下面几行将检查deal.II是否已被配置为Trilinos，并采用它。

// 但是在某些情况下，即使deal.II也被配置为PETSc，你还是想使用Trilinos，例如，比较这两个库的性能。要做到这一点，请在源代码中添加以下的\#define。
// @code
//  #define FORCE_USE_OF_TRILINOS
//  @endcode

// 使用这个逻辑，下面几行将导入PETSc或Trilinos包装器到命名空间`LA`（代表 "线性代数"）。在前一种情况下，我们还要定义宏 `USE_PETSC_LA`，这样我们就可以检测到我们是否在使用PETSc（参见solve()中需要用到的例子）。

namespace LA 
{ 
#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \ 
  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS)) 
  using namespace dealii::LinearAlgebraPETSc; 
#  define USE_PETSC_LA 
#elif defined(DEAL_II_WITH_TRILINOS) 
  using namespace dealii::LinearAlgebraTrilinos; 
#else 
#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required 
#endif 
} // namespace LA 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 然而，下面这些将是新的，或在新的角色中使用。让我们来看看它们。其中第一个将提供 Utilities::System 命名空间的工具，我们将用它来查询诸如与当前MPI宇宙相关的处理器数量，或者这个作业运行的处理器在这个宇宙中的编号。

#include <deal.II/base/utilities.h> 

// 下一个提供了一个类，ConditionOStream，它允许我们编写代码，将东西输出到一个流中（例如在每个处理器上的 <code>std::cout</code> ，但在除了一个处理器以外的所有处理器上都将文本扔掉。我们可以通过简单地在每个可能产生输出的地方前面放一个 <code>if</code> 语句来实现同样的目的，但这并不能使代码更漂亮。此外，这个处理器是否应该向屏幕输出的条件每次都是一样的--因此，把它放在产生输出的语句中应该是很简单的。

#include <deal.II/base/conditional_ostream.h> 

// 在这些预演之后，这里变得更加有趣。正如在 @ref distributed 模块中提到的，在大量处理器上解决问题的一个基本事实是，任何处理器都不可能存储所有的东西（例如，关于网格中所有单元的信息，所有的自由度，或者解向量中所有元素的值）。相反，每个处理器都会<i>own</i>其中的几个，如果有必要，还可能<i>know</i>另外几个，例如，位于与该处理器自己拥有的单元相邻的那些单元。我们通常称后者为<i>ghost cells</i>、<i>ghost nodes</i>或<i>ghost elements of a vector</i>。这里讨论的重点是，我们需要有一种方法来表明一个特定的处理器拥有或需要知道哪些元素。这就是IndexSet类的领域：如果总共有 $N$ 个单元、自由度或向量元素，与（非负）积分指数 $[0,N)$ 相关，那么当前处理器拥有的元素集以及它需要了解的（可能更大）指数集都是集合 $[0,N)$ 的子集。IndexSet是一个类，它以一种有效的格式存储这个集合的子集。

#include <deal.II/base/index_set.h> 

// 下一个头文件是一个单一的函数所必需的，  SparsityTools::distribute_sparsity_pattern.  这个函数的作用将在下面解释。

#include <deal.II/lac/sparsity_tools.h> 

// 最后两个新的头文件提供了类 parallel::distributed::Triangulation ，它提供了分布在可能非常多的处理器上的网格，而第二个文件提供了命名空间 parallel::distributed::GridRefinement ，它提供了可以自适应细化这种分布式网格的函数。

#include <deal.II/distributed/tria.h> 
#include <deal.II/distributed/grid_refinement.h> 

#include <fstream> 
#include <iostream> 

namespace Step40 
{ 
  using namespace dealii; 
// @sect3{The <code>LaplaceProblem</code> class template}  

// 接下来我们来声明这个程序的主类。它的结构几乎与 step-6 的教程程序一模一样。唯一显著的区别是。

// --  <code>mpi_communicator</code> 变量，它描述了我们希望这段代码运行在哪一组处理器上。在实践中，这将是MPI_COMM_WORLD，即批处理调度系统分配给这个特定作业的所有处理器。

// - ConditionOStream类型的 <code>pcout</code> 变量的存在。

// - 明显使用 parallel::distributed::Triangulation 而不是Triangulation。

// - 两个IndexSet对象的存在，表示我们在当前处理器上拥有哪些自由度集（以及解和右手向量的相关元素），以及我们需要哪些（作为幽灵元素）来使本程序中的算法工作。

// - 现在所有的矩阵和向量都是分布式的。我们使用PETSc或Trilinos包装类，这样我们就可以使用Hypre（使用PETSc）或ML（使用Trilinos）提供的复杂的预处理器之一。请注意，作为这个类的一部分，我们存储的解向量不仅包含当前处理器拥有的自由度，还包括（作为鬼魂元素）所有对应于 "本地相关 "自由度的向量元素（即所有生活在本地拥有的单元或围绕它的鬼魂单元层的自由度）。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(); 

    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    MPI_Comm mpi_communicator; 

    parallel::distributed::Triangulation<dim> triangulation; 

    FE_Q<dim>       fe; 
    DoFHandler<dim> dof_handler; 

    IndexSet locally_owned_dofs; 
    IndexSet locally_relevant_dofs; 

    AffineConstraints<double> constraints; 

    LA::MPI::SparseMatrix system_matrix; 
    LA::MPI::Vector       locally_relevant_solution; 
    LA::MPI::Vector       system_rhs; 

    ConditionalOStream pcout; 
    TimerOutput        computing_timer; 
  }; 
// @sect3{The <code>LaplaceProblem</code> class implementation}  
// @sect4{Constructor}  

// 构造函数和析构函数是相当微不足道的。除了我们在 step-6 中所做的，我们将我们想要工作的处理器集合设置为所有可用的机器（MPI_COMM_WORLD）；要求三角化以确保网格保持平滑并自由精炼岛屿，例如；并初始化 <code>pcout</code> 变量，只允许处理器0输出任何东西。最后一块是初始化一个定时器，我们用它来决定程序的不同部分需要多少计算时间。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem() 
    : mpi_communicator(MPI_COMM_WORLD) 
    , triangulation(mpi_communicator, 
                    typename Triangulation<dim>::MeshSmoothing( 
                      Triangulation<dim>::smoothing_on_refinement | 
                      Triangulation<dim>::smoothing_on_coarsening)) 
    , fe(2) 
    , dof_handler(triangulation) 
    , pcout(std::cout, 
            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
    , computing_timer(mpi_communicator, 
                      pcout, 
                      TimerOutput::summary, 
                      TimerOutput::wall_times) 
  {} 

//  @sect4{LaplaceProblem::setup_system}  

// 下面这个函数可以说是整个程序中最有趣的一个，因为它涉及到了%并行  step-40  和顺序  step-6  的核心区别。

// 在顶部我们做了我们一直在做的事情：告诉DoFHandler对象来分配自由度。由于我们在这里使用的三角测量是分布式的，DoFHandler对象足够聪明，它认识到在每个处理器上只能在它所拥有的单元上分配自由度；接下来是一个交换步骤，处理器互相告诉对方关于ghost单元的自由度。结果是DoFHandler知道本地拥有的单元和幽灵单元（即与本地拥有的单元相邻的单元）的自由度，但对更远的单元则一无所知，这与分布式计算的基本理念一致，即没有处理器可以知道所有的事情。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 
    TimerOutput::Scope t(computing_timer, "setup"); 

    dof_handler.distribute_dofs(fe); 

// 接下来的两行提取了一些我们以后需要的信息，即两个索引集，提供了关于哪些自由度为当前处理器所拥有的信息（这些信息将被用来初始化解和右手向量以及系统矩阵，表明哪些元素要存储在当前处理器上，哪些要期望存储在其他地方）；以及一个索引集，表明哪些自由度是本地相关的（即生活在当前处理器所拥有的单元上或本地所拥有的单元周围的鬼魂单元上；我们将把这些自由度存储在当前处理器上。 例如，生活在当前处理器拥有的单元上或本地拥有的单元周围的幽灵单元层上；例如，我们需要所有这些自由度来估计本地单元的误差）。)

    locally_owned_dofs = dof_handler.locally_owned_dofs(); 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 

// 接下来，让我们初始化解和右手边的向量。如上所述，我们寻求的解向量不仅存储了我们自己的元素，还存储了幽灵条目；另一方面，右手向量只需要有当前处理器拥有的条目，因为我们所做的只是向其中写入，而不是从其中读取本地拥有的单元（当然，线性求解器会从其中读取，但它们并不关心自由度的几何位置）。

    locally_relevant_solution.reinit(locally_owned_dofs, 
                                     locally_relevant_dofs, 
                                     mpi_communicator); 
    system_rhs.reinit(locally_owned_dofs, mpi_communicator); 

// 下一步是计算悬挂节点和边界值约束，我们将其合并为一个存储所有约束的对象。

// 就像在%parallel中的所有其他事情一样，口头禅必须是：没有一个处理器可以存储整个宇宙的所有信息。因此，我们需要告诉AffineConstraints对象哪些自由度可以存储约束条件，哪些可以不期望存储任何信息。在我们的例子中，正如 @ref distributed 模块所解释的，我们需要在每个处理器上关心的自由度是本地相关的自由度，所以我们把这个传递给 AffineConstraints::reinit 函数。顺便提一下，如果你忘记传递这个参数，AffineConstraints类将分配一个长度等于它目前看到的最大自由度索引的数组。对于MPI进程数很高的处理器来说，这可能是非常大的 -- 也许是数十亿的数量级。然后，程序将为这个单一的数组分配比其他所有操作加起来还要多的内存。

    constraints.clear(); 
    constraints.reinit(locally_relevant_dofs); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             constraints); 
    constraints.close(); 

// 这个函数的最后一部分涉及到用伴随的稀疏模式初始化矩阵。和以前的教程程序一样，我们使用DynamicSparsityPattern作为一个中介，然后用它来初始化系统矩阵。为了做到这一点，我们必须告诉稀疏模式它的大小，但如上所述，所产生的对象不可能为每个全局自由度存储哪怕一个指针；我们最好的希望是它能存储每个局部相关自由度的信息，即所有我们在组装矩阵的过程中可能接触到的自由度（ @ref distributed_paper "分布式计算论文 "有很长的讨论，为什么我们真的需要局部相关自由度，而不是在此背景下的小的局部活动自由度集）。

// 所以我们告诉稀疏模式它的大小和要存储什么自由度，然后要求 DoFTools::make_sparsity_pattern 来填充它（这个函数忽略了所有不属于本地的单元，模仿我们下面在装配过程中的做法）。在这之后，我们调用一个函数，在处理器之间交换这些稀疏模式的条目，以便最后每个处理器真正知道它将拥有的那部分有限元矩阵中的所有条目。最后一步是用稀疏模式初始化矩阵。

    DynamicSparsityPattern dsp(locally_relevant_dofs); 

    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); 
    SparsityTools::distribute_sparsity_pattern(dsp, 
                                               dof_handler.locally_owned_dofs(), 
                                               mpi_communicator, 
                                               locally_relevant_dofs); 

    system_matrix.reinit(locally_owned_dofs, 
                         locally_owned_dofs, 
                         dsp, 
                         mpi_communicator); 
  } 

//  @sect4{LaplaceProblem::assemble_system}  

// 然后组装线性系统的函数相对来说比较无聊，几乎和我们之前看到的一模一样。需要注意的地方是。

// - 装配必须只在本地拥有的单元上循环。有多种方法来测试；例如，我们可以将一个单元的subdomain_id与三角形的信息进行比较，如<code>cell->subdomain_id() == triangulation.local_owned_subdomain()</code>，或者跳过所有条件<code>cell->is_ghost() || cell->is_artificial()</code>为真的单元。然而，最简单的方法是简单地询问单元格是否为本地处理器所拥有。

// - 将本地贡献复制到全局矩阵中必须包括分配约束和边界值。换句话说，我们不能（就像我们在 step-6 中所做的那样）首先将每个本地贡献复制到全局矩阵中，然后在后面的步骤中才处理悬挂节点的约束和边界值。原因是，正如在 step-17 中所讨论的那样，一旦矩阵中的任意元素被组装到矩阵中，并行矢量类就不能提供对这些元素的访问--部分原因是它们可能不再存在于当前的处理器中，而是被运到了不同的机器上。

// - 我们计算右手边的方式（考虑到介绍中的公式）可能不是最优雅的，但对于重点在某个完全不同的地方的程序来说是可以的。

  template <int dim> 
  void LaplaceProblem<dim>::assemble_system() 
  { 
    TimerOutput::Scope t(computing_timer, "assembly"); 

    const QGauss<dim> quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell_matrix = 0.; 
          cell_rhs    = 0.; 

          fe_values.reinit(cell); 

          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            { 
              const double rhs_value = 
                (fe_values.quadrature_point(q_point)[1] > 
                     0.5 + 
                       0.25 * std::sin(4.0 * numbers::PI * 
                                       fe_values.quadrature_point(q_point)[0]) ? 
                   1. : 
                   -1.); 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    cell_matrix(i, j) += fe_values.shape_grad(i, q_point) * 
                                         fe_values.shape_grad(j, q_point) * 
                                         fe_values.JxW(q_point); 

                  cell_rhs(i) += rhs_value *                         // 
                                 fe_values.shape_value(i, q_point) * // 
                                 fe_values.JxW(q_point); 
                } 
            } 

          cell->get_dof_indices(local_dof_indices); 
          constraints.distribute_local_to_global(cell_matrix, 
                                                 cell_rhs, 
                                                 local_dof_indices, 
                                                 system_matrix, 
                                                 system_rhs); 
        } 

// 注意，上面的装配只是一个局部操作。因此，为了形成 "全局 "线性系统，需要在所有处理器之间进行同步。这可以通过调用函数compress()来实现。参见 @ref GlossCompress "压缩分布式对象"，以了解更多关于compress()的设计目的的信息。

    system_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 
  } 

//  @sect4{LaplaceProblem::solve}  

// 尽管在可能是数以万计的处理器上求解线性系统到目前为止并不是一项微不足道的工作，但完成这项工作的函数--至少在外表上--相对简单。大部分的部分你都见过了。真正值得一提的只有两件事。

// - 解算器和预处理器是建立在PETSc和Trilinos功能的deal.II包装上的。众所周知，大规模并行线性求解器的主要瓶颈实际上不是处理器之间的通信，而是很难产生能够很好地扩展到大量处理器的预处理程序。在21世纪前十年的后半段，代数多网格（AMG）方法在这种情况下显然是非常有效的，我们将使用其中的一种方法--要么是可以通过PETSc接口的Hypre软件包的BoomerAMG实现，要么是由ML提供的预处理程序，它是Trilinos的一部分--用于当前的程序。解算器本身的其余部分是模板，之前已经展示过了。由于线性系统是对称和正定的，我们可以使用CG方法作为外解器。

// - 最终，我们想要一个向量，它不仅存储了当前处理器拥有的自由度的解的元素，而且还存储了所有其他本地相关的自由度。另一方面，求解器本身需要一个在处理器之间唯一分割的向量，没有任何重叠。因此，我们在这个函数的开头创建一个具有这些特性的向量，用它来求解线性系统，并在最后才把它分配给我们想要的向量。这最后一步确保所有的鬼魂元素也在必要时被复制。

  template <int dim> 
  void LaplaceProblem<dim>::solve() 
  { 
    TimerOutput::Scope t(computing_timer, "solve"); 
    LA::MPI::Vector    completely_distributed_solution(locally_owned_dofs, 
                                                    mpi_communicator); 

    SolverControl solver_control(dof_handler.n_dofs(), 1e-12); 

#ifdef USE_PETSC_LA 
    LA::SolverCG solver(solver_control, mpi_communicator); 
#else 
    LA::SolverCG solver(solver_control); 
#endif 

    LA::MPI::PreconditionAMG preconditioner; 

    LA::MPI::PreconditionAMG::AdditionalData data; 

#ifdef USE_PETSC_LA 
    data.symmetric_operator = true; 
#else 
/* Trilinos的默认值是好的  */ 
#endif 
    preconditioner.initialize(system_matrix, data); 

    solver.solve(system_matrix, 
                 completely_distributed_solution, 
                 system_rhs, 
                 preconditioner); 

    pcout << "   Solved in " << solver_control.last_step() << " iterations." 
          << std::endl; 

    constraints.distribute(completely_distributed_solution); 

    locally_relevant_solution = completely_distributed_solution; 
  } 

//  @sect4{LaplaceProblem::refine_grid}  

// 估计误差和细化网格的函数又与  step-6  中的函数几乎完全一样。唯一不同的是，标志着要细化的单元格的函数现在在命名空间  parallel::distributed::GridRefinement  中 -- 这个命名空间的函数可以在所有参与的处理器之间进行通信，并确定全局阈值，用于决定哪些单元格要细化，哪些要粗化。

// 注意，我们不需要对KellyErrorEstimator类做任何特殊处理：我们只是给它一个向量，其元素数量与本地三角形的单元（本地拥有的单元、幽灵单元和人工单元）一样多，但它只填入那些对应于本地拥有的单元的条目。

  template <int dim> 
  void LaplaceProblem<dim>::refine_grid() 
  { 
    TimerOutput::Scope t(computing_timer, "refine"); 

    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      locally_relevant_solution, 
      estimated_error_per_cell); 
    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number( 
      triangulation, estimated_error_per_cell, 0.3, 0.03); 
    triangulation.execute_coarsening_and_refinement(); 
  } 

//  @sect4{LaplaceProblem::output_results}  

// 与 step-6 中的相应函数相比，这里的函数要复杂一点。有两个原因：第一个原因是，我们不只是想输出解决方案，还想输出每个单元的处理器（即它在哪个 "子域"）。其次，正如在 step-17 和 step-18 中详细讨论的那样，生成图形数据可能是并行化的一个瓶颈。在 step-18 中，我们将这一步骤从实际计算中移出，而是将其转移到一个单独的程序中，随后将各个处理器的输出合并到一个文件中。但这并不具规模：如果处理器的数量很大，这可能意味着在单个处理器上合并数据的步骤后来成为程序中运行时间最长的部分，或者它可能产生一个大到无法再可视化的文件。我们在这里遵循一个更合理的方法，即为每个MPI进程创建单独的文件，并将其留给可视化程序来理解。

// 首先，函数的顶部看起来和平时一样。除了附加解决方案向量（包含所有本地相关元素的条目，而不仅仅是本地拥有的元素）外，我们还附加一个数据向量，为每个单元存储该单元所属的子域。这稍微有点棘手，因为当然不是每个处理器都知道每个单元。因此，我们附加的向量有一个当前处理器在其网格中拥有的每个单元的条目（本地拥有的单元、幽灵单元和人造单元），但DataOut类将忽略所有对应于不属于当前处理器的单元的条目。因此，我们在这些向量条目中写入什么值实际上并不重要：我们只需用当前MPI进程的编号（即当前进程的子域_id）来填充整个向量；这就正确地设置了我们关心的值，即对应于本地拥有的单元的条目，而为所有其他元素提供了错误的值--但无论如何这些都会被忽略。

  template <int dim> 
  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(locally_relevant_solution, "u"); 

    Vector<float> subdomain(triangulation.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      subdomain(i) = triangulation.locally_owned_subdomain(); 
    data_out.add_data_vector(subdomain, "subdomain"); 

    data_out.build_patches(); 

// 下一步是把这些数据写到磁盘上。在MPI-IO的帮助下，我们最多可以并行写入8个VTU文件。此外，还产生了一个PVTU记录，它将写入的VTU文件分组。

    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", cycle, mpi_communicator, 2, 8); 
  } 

//  @sect4{LaplaceProblem::run}  

// 控制程序整体行为的函数又和  step-6  中的一样。小的区别是使用 <code>pcout</code> instead of <code>std::cout</code> 来输出到控制台（也见 step-17 ），而且我们只在最多涉及32个处理器的情况下产生图形输出。如果没有这个限制，人们很容易在没有阅读这个程序的情况下粗心大意地运行这个程序，从而导致集群互连中断，并填满任何可用的文件系统 :-)

// 与 step-6 的一个功能上的区别是使用了一个正方形域，并且我们从一个稍细的网格开始（5个全局细化周期）--在4个单元上开始显示一个大规模的%并行程序没有什么意义（尽管承认在1024单元上开始显示的意义只是稍强）。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    pcout << "Running with " 
#ifdef USE_PETSC_LA 
          << "PETSc" 
#else 
          << "Trilinos" 
#endif 
          << " on " << Utilities::MPI::n_mpi_processes(mpi_communicator) 
          << " MPI rank(s)..." << std::endl; 

    const unsigned int n_cycles = 8; 
    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle) 
      { 
        pcout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation); 
            triangulation.refine_global(5); 
          } 
        else 
          refine_grid(); 

        setup_system(); 

        pcout << "   Number of active cells:       " 
              << triangulation.n_global_active_cells() << std::endl 
              << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

        assemble_system(); 
        solve(); 

        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32) 
          { 
            TimerOutput::Scope t(computing_timer, "output"); 
            output_results(cycle); 
          } 

        computing_timer.print_summary(); 
        computing_timer.reset(); 

        pcout << std::endl; 
      } 
  } 
} // namespace Step40 

//  @sect4{main()}  

// 最后一个函数，  <code>main()</code>  ，同样具有与所有其他程序相同的结构，特别是  step-6  。像其他使用MPI的程序一样，我们必须初始化和最终确定MPI，这是用辅助对象  Utilities::MPI::MPI_InitFinalize.  完成的。该类的构造函数也初始化了依赖MPI的库，如p4est、PETSc、SLEPc和Zoltan（尽管最后两个在本教程中没有使用）。这里的顺序很重要：在这些库被初始化之前，我们不能使用它们，所以在创建  Utilities::MPI::MPI_InitFinalize.  的实例之前做任何事情都没有意义。

// 在求解器完成后，LaplaceProblem解构器将运行，然后是 Utilities::MPI::MPI_InitFinalize::~MPI_InitFinalize().  这个顺序也很重要： Utilities::MPI::MPI_InitFinalize::~MPI_InitFinalize() 调用 <code>PetscFinalize</code> （以及其他库的最终确定函数），这将删除任何正在使用的PETSc对象。这必须在我们解构拉普拉斯求解器之后进行，以避免双重删除错误。幸运的是，由于C++的析构器调用顺序规则，我们不需要担心这些：一切都以正确的顺序发生（即，与构造顺序相反）。由 Utilities::MPI::MPI_InitFinalize::~MPI_InitFinalize() 调用的最后一个函数是 <code>MPI_Finalize</code> ：也就是说，一旦这个对象被析构，程序应该退出，因为MPI将不再可用。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step40; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      LaplaceProblem<2> laplace_problem_2d; 
      laplace_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-41.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2011 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Joerg Frohne, Texas A&M University and 
 *                        University of Siegen, 2011, 2012 
 *          Wolfgang Bangerth, Texas A&M University, 2012 
 */ 


// @sect3{Include files}  

// 像往常一样，在开始的时候，我们把所有我们需要的头文件都包含在这里。除了为Trilinos库提供接口的各种文件外，没有什么意外。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/index_set.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/trilinos_vector.h> 
#include <deal.II/lac/trilinos_precondition.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iostream> 

namespace Step41 
{ 
  using namespace dealii; 
// @sect3{The <code>ObstacleProblem</code> class template}  

// 该类提供了描述障碍问题所需的所有函数和变量。它与我们在 step-4 中要做的事情很接近，所以相对简单。唯一真正的新组件是计算主动集合的update_solution_and_constraints函数和一些描述线性系统原始（无约束）形式所需的变量（ <code>complete_system_matrix</code> 和 <code>complete_system_rhs</code> ），以及主动集合本身和主动集合公式中用于缩放拉格朗日乘数的质量矩阵 $B$ 的对角线。其余的内容与 step-4 相同。

  template <int dim> 
  class ObstacleProblem 
  { 
  public: 
    ObstacleProblem(); 
    void run(); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void assemble_system(); 
    void 
         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix); 
    void update_solution_and_constraints(); 
    void solve(); 
    void output_results(const unsigned int iteration) const; 

    Triangulation<dim>        triangulation; 
    FE_Q<dim>                 fe; 
    DoFHandler<dim>           dof_handler; 
    AffineConstraints<double> constraints; 
    IndexSet                  active_set; 

    TrilinosWrappers::SparseMatrix system_matrix; 
    TrilinosWrappers::SparseMatrix complete_system_matrix; 

    TrilinosWrappers::MPI::Vector solution; 
    TrilinosWrappers::MPI::Vector system_rhs; 
    TrilinosWrappers::MPI::Vector complete_system_rhs; 
    TrilinosWrappers::MPI::Vector diagonal_of_mass_matrix; 
    TrilinosWrappers::MPI::Vector contact_force; 
  }; 
// @sect3{Right hand side, boundary values, and the obstacle}  

// 在下文中，我们定义了描述右侧函数、Dirichlet边界值以及作为 $\mathbf x$ 函数的障碍物高度的类。在这三种情况下，我们都从函数 @<dim@>, 派生出这些类，尽管在 <code>RightHandSide</code> 和 <code>Obstacle</code> 的情况下，这更多的是出于惯例而非必要，因为我们从未将此类对象传递给库。在任何情况下，鉴于我们选择了 $f=-10$  ,  $u|_{\partial\Omega}=0$  ...，右手和边界值类的定义是显而易见的。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & /*p*/, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      AssertIndexRange(component, 1); 

      return -10; 
    } 
  }; 

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & /*p*/, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      AssertIndexRange(component, 1); 

      return 0; 
    } 
  }; 

// 我们用一个级联的障碍物来描述障碍物的功能（想想看：楼梯的阶梯）。

  template <int dim> 
  class Obstacle : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override 
    { 
      (void)component; 
      Assert(component == 0, ExcIndexRange(component, 0, 1)); 

      if (p(0) < -0.5) 
        return -0.2; 
      else if (p(0) >= -0.5 && p(0) < 0.0) 
        return -0.4; 
      else if (p(0) >= 0.0 && p(0) < 0.5) 
        return -0.6; 
      else 
        return -0.8; 
    } 
  }; 

//  @sect3{Implementation of the <code>ObstacleProblem</code> class}  
// @sect4{ObstacleProblem::ObstacleProblem}  

// 对每个看过前几个教程程序的人来说，构造函数是完全显而易见的。

  template <int dim> 
  ObstacleProblem<dim>::ObstacleProblem() 
    : fe(1) 
    , dof_handler(triangulation) 
  {} 
// @sect4{ObstacleProblem::make_grid}  

// 我们在二维的正方形 $[-1,1]\times [-1,1]$ 上解决我们的障碍物问题。因此这个函数只是设置了一个最简单的网格。

  template <int dim> 
  void ObstacleProblem<dim>::make_grid() 
  { 
    GridGenerator::hyper_cube(triangulation, -1, 1); 
    triangulation.refine_global(7); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "Total number of cells: " << triangulation.n_cells() 
              << std::endl; 
  } 
// @sect4{ObstacleProblem::setup_system}  

// 在这个值得注意的第一个函数中，我们设置了自由度处理程序，调整了向量和矩阵的大小，并处理了约束。最初，约束条件当然只是由边界值给出的，所以我们在函数的顶部对它们进行插值。

  template <int dim> 
  void ObstacleProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    active_set.set_size(dof_handler.n_dofs()); 

    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl 
              << std::endl; 

    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             BoundaryValues<dim>(), 
                                             constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); 

    system_matrix.reinit(dsp); 
    complete_system_matrix.reinit(dsp); 

    IndexSet solution_index_set = dof_handler.locally_owned_dofs(); 
    solution.reinit(solution_index_set, MPI_COMM_WORLD); 
    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD); 
    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD); 
    contact_force.reinit(solution_index_set, MPI_COMM_WORLD); 

// 这里唯一要做的事情是计算 $B$ 矩阵中的因子，该矩阵用于缩放残差。正如在介绍中所讨论的，我们将使用一个小技巧来使这个质量矩阵成为对角线，在下文中，首先将所有这些计算成一个矩阵，然后提取对角线元素供以后使用。

    TrilinosWrappers::SparseMatrix mass_matrix; 
    mass_matrix.reinit(dsp); 
    assemble_mass_matrix_diagonal(mass_matrix); 
    diagonal_of_mass_matrix.reinit(solution_index_set); 
    for (unsigned int j = 0; j < solution.size(); j++) 
      diagonal_of_mass_matrix(j) = mass_matrix.diag_element(j); 
  } 
// @sect4{ObstacleProblem::assemble_system}  

// 这个函数一次就把系统矩阵和右手边集合起来，并把约束条件（由于活动集以及来自边界值）应用到我们的系统中。否则，它在功能上等同于例如  step-4  中的相应函数。

  template <int dim> 
  void ObstacleProblem<dim>::assemble_system() 
  { 
    std::cout << "   Assembling system..." << std::endl; 

    system_matrix = 0; 
    system_rhs    = 0; 

    const QGauss<dim>  quadrature_formula(fe.degree + 1); 
    RightHandSide<dim> right_hand_side; 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        cell_matrix = 0; 
        cell_rhs    = 0; 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                cell_matrix(i, j) += 
                  (fe_values.shape_grad(i, q_point) * 
                   fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point)); 

              cell_rhs(i) += 
                (fe_values.shape_value(i, q_point) * 
                 right_hand_side.value(fe_values.quadrature_point(q_point)) * 
                 fe_values.JxW(q_point)); 
            } 

        cell->get_dof_indices(local_dof_indices); 

        constraints.distribute_local_to_global(cell_matrix, 
                                               cell_rhs, 
                                               local_dof_indices, 
                                               system_matrix, 
                                               system_rhs, 
                                               true); 
      } 
  } 

//  @sect4{ObstacleProblem::assemble_mass_matrix_diagonal}  

// 下一个函数用于计算对角线质量矩阵 $B$ ，用于在主动集方法中缩放变量。正如介绍中所讨论的，我们通过选择正交的梯形规则来获得质量矩阵的对角线。这样一来，我们就不再需要在正交点、指数 $i$ 和指数 $j$ 上进行三重循环，而是可以直接使用双重循环。考虑到我们在以前的许多教程程序中讨论过的内容，该函数的其余部分是显而易见的。

// 注意在调用这个函数的时候，约束对象只包含边界值约束；因此我们在最后的复制-本地-全局步骤中不必注意保留矩阵项的值，这些项以后可能会受到活动集的约束。

// 还需要注意的是，只有在我们拥有 $Q_1$ 元素的情况下，使用梯形规则的技巧才有效。对于更高阶的元素，我们需要使用一个正交公式，在有限元的所有支持点都有正交点。构建这样一个正交公式其实并不难，但不是这里的重点，所以我们只是在函数的顶部断言我们对有限元的隐含假设实际上得到了满足。

  template <int dim> 
  void ObstacleProblem<dim>::assemble_mass_matrix_diagonal( 
    TrilinosWrappers::SparseMatrix &mass_matrix) 
  { 
    Assert(fe.degree == 1, ExcNotImplemented()); 

    const QTrapezoid<dim> quadrature_formula; 
    FEValues<dim>         fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

 
      { 
        fe_values.reinit(cell); 
        cell_matrix = 0; 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            cell_matrix(i, i) += 
              (fe_values.shape_value(i, q_point) * 
               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point)); 

        cell->get_dof_indices(local_dof_indices); 

        constraints.distribute_local_to_global(cell_matrix, 
                                               local_dof_indices, 
                                               mass_matrix); 
      } 
  } 
// @sect4{ObstacleProblem::update_solution_and_constraints}  

// 在某种意义上，这是本程序的核心功能。 它更新了介绍中所讨论的受限自由度的活动集，并从中计算出一个AffineConstraints对象，然后可以用来在下一次迭代的解中消除受限自由度。同时，我们将解决方案的受限自由度设置为正确的值，即障碍物的高度。

// 从根本上说，这个函数是相当简单的。我们必须在所有自由度上循环，并检查函数 $\Lambda^k_i + c([BU^k]_i - G_i) = \Lambda^k_i + cB_i(U^k_i - [g_h]_i)$ 的符号，因为在我们的例子中 $G_i = B_i[g_h]_i$  。为此，我们使用介绍中给出的公式，通过该公式我们可以计算出拉格朗日乘数，作为原始线性系统的残差（通过变量 <code>complete_system_matrix</code> and <code>complete_system_rhs</code> 给出。在这个函数的顶部，我们使用一个属于矩阵类的函数来计算这个残差。

  template <int dim> 
  void ObstacleProblem<dim>::update_solution_and_constraints() 
  { 
    std::cout << "   Updating active set..." << std::endl; 

    const double penalty_parameter = 100.0; 

    TrilinosWrappers::MPI::Vector lambda( 
      complete_index_set(dof_handler.n_dofs())); 
    complete_system_matrix.residual(lambda, solution, complete_system_rhs); 

// 计算 contact_force[i] =

// - lambda[i] * diagonal_of_mass_matrix[i]。

    contact_force = lambda; 
    contact_force.scale(diagonal_of_mass_matrix); 
    contact_force *= -1; 

// 下一步是重置活动集和约束对象，并在所有自由度上开始循环。由于我们不能只是在解向量的所有元素上循环，所以这变得稍微复杂了一些，因为我们没有办法找出一个自由度与哪个位置相关；但是，我们需要这个位置来测试一个自由度的位移是大于还是小于这个位置的障碍物高度。

// 我们通过在所有单元和定义在每个单元上的DoF上循环来解决这个问题。我们在这里使用一个 $Q_1$ 函数来描述位移，对于该函数，自由度总是位于单元格的顶点上；因此，我们可以通过询问顶点来获得每个自由度的索引及其位置。另一方面，这显然对高阶元素不起作用，因此我们添加了一个断言，确保我们只处理所有自由度都位于顶点的元素，以避免万一有人想玩增加解的多项式程度时用非功能性代码绊倒自己。

// 循环单元格而不是自由度的代价是我们可能会多次遇到一些自由度，即每次我们访问与给定顶点相邻的一个单元格时。因此，我们必须跟踪我们已经接触过的顶点和尚未接触的顶点。我们通过使用一个标志数组来做到这一点  <code>dof_touched</code>  。

    constraints.clear(); 
    active_set.clear(); 

    const Obstacle<dim> obstacle; 
    std::vector<bool>   dof_touched(dof_handler.n_dofs(), false); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      for (const auto v : cell->vertex_indices()) 
        { 
          Assert(dof_handler.get_fe().n_dofs_per_cell() == cell->n_vertices(), 
                 ExcNotImplemented()); 

          const unsigned int dof_index = cell->vertex_dof_index(v, 0); 

          if (dof_touched[dof_index] == false) 
            dof_touched[dof_index] = true; 
          else 
            continue; 

// 现在我们知道我们还没有触及这个DoF，让我们得到那里的位移函数的值以及障碍函数的值，并使用这个来决定当前DoF是否属于活动集。为此，我们使用上面和介绍中给出的函数。

// 如果我们决定该DoF应该是活动集的一部分，我们将其索引添加到活动集中，在AffineConstraints对象中引入一个不均匀的平等约束，并将解的值重置为障碍物的高度。最后，系统的非接触部分的残差作为一个额外的控制（残差等于剩余的、未计算的力，在接触区之外应该为零），所以我们把残差向量的分量（即拉格朗日乘数lambda）清零，这些分量对应于身体接触的区域；在所有单元的循环结束时，残差将因此只包括非接触区的残差。我们在循环结束后输出这个残差的准则和活动集的大小。

          const double obstacle_value = obstacle.value(cell->vertex(v)); 
          const double solution_value = solution(dof_index); 

          if (lambda(dof_index) + penalty_parameter * 
                                    diagonal_of_mass_matrix(dof_index) * 
                                    (solution_value - obstacle_value) < 
              0) 
            { 
              active_set.add_index(dof_index); 
              constraints.add_line(dof_index); 
              constraints.set_inhomogeneity(dof_index, obstacle_value); 

              solution(dof_index) = obstacle_value; 

              lambda(dof_index) = 0; 
            } 
        } 
    std::cout << "      Size of active set: " << active_set.n_elements() 
              << std::endl; 

    std::cout << "   Residual of the non-contact part of the system: " 
              << lambda.l2_norm() << std::endl; 

// 在最后一步中，我们将迄今为止从活动集合中得到的对DoF的约束加入到那些由Dirichlet边界值产生的约束中，并关闭约束对象。

    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             BoundaryValues<dim>(), 
                                             constraints); 
    constraints.close(); 
  } 
// @sect4{ObstacleProblem::solve}  

// 关于求解函数，其实没有什么可说的。在牛顿方法的背景下，我们通常对非常高的精度不感兴趣（为什么要求一个高度精确的线性问题的解，而我们知道它只能给我们一个非线性问题的近似解），所以我们使用ReductionControl类，当达到一个绝对公差（为此我们选择 $10^{-12}$ ）或者当残差减少一定的系数（这里是 $10^{-3}$ ）时停止反复运算。

  template <int dim> 
  void ObstacleProblem<dim>::solve() 
  { 
    std::cout << "   Solving system..." << std::endl; 

    ReductionControl                        reduction_control(100, 1e-12, 1e-3); 
    SolverCG<TrilinosWrappers::MPI::Vector> solver(reduction_control); 
    TrilinosWrappers::PreconditionAMG       precondition; 
    precondition.initialize(system_matrix); 

    solver.solve(system_matrix, solution, system_rhs, precondition); 
    constraints.distribute(solution); 

    std::cout << "      Error: " << reduction_control.initial_value() << " -> " 
              << reduction_control.last_value() << " in " 
              << reduction_control.last_step() << " CG iterations." 
              << std::endl; 
  } 
// @sect4{ObstacleProblem::output_results}  

// 我们使用vtk-format进行输出。 该文件包含位移和活动集的数字表示。

  template <int dim> 
  void ObstacleProblem<dim>::output_results(const unsigned int iteration) const 
  { 
    std::cout << "   Writing graphical output..." << std::endl; 

    TrilinosWrappers::MPI::Vector active_set_vector( 
      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD); 
    for (const auto index : active_set) 
      active_set_vector[index] = 1.; 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "displacement"); 
    data_out.add_data_vector(active_set_vector, "active_set"); 
    data_out.add_data_vector(contact_force, "lambda"); 

    data_out.build_patches(); 

    std::ofstream output_vtk("output_" + 
                             Utilities::int_to_string(iteration, 3) + ".vtk"); 
    data_out.write_vtk(output_vtk); 
  } 

//  @sect4{ObstacleProblem::run}  

// 这是一个对所有事情都有最高级别控制的函数。 它并不长，而且事实上相当直接：在主动集方法的每一次迭代中，我们都要组装线性系统，求解它，更新主动集并将解投射回可行集，然后输出结果。只要主动集在前一次迭代中没有变化，迭代就会终止。

// 唯一比较棘手的部分是，我们必须在第一次迭代组装好线性系统（即矩阵和右手边）后保存它。原因是这是唯一一个我们可以在没有任何接触约束的情况下访问线性系统的步骤。我们需要这个来计算其他迭代中解决方案的残差，但是在其他迭代中，我们形成的线性系统中对应于约束自由度的行和列都被消除了，因此我们不能再访问原始方程的全部残差。

  template <int dim> 
  void ObstacleProblem<dim>::run() 
  { 
    make_grid(); 
    setup_system(); 

    IndexSet active_set_old(active_set); 
    for (unsigned int iteration = 0; iteration <= solution.size(); ++iteration) 
      { 
        std::cout << "Newton iteration " << iteration << std::endl; 

        assemble_system(); 

        if (iteration == 0) 
          { 
            complete_system_matrix.copy_from(system_matrix); 
            complete_system_rhs = system_rhs; 
          } 

        solve(); 
        update_solution_and_constraints(); 
        output_results(iteration); 

        if (active_set == active_set_old) 
          break; 

        active_set_old = active_set; 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step41 
// @sect3{The <code>main</code> function}  

// 这就是主函数。它遵循所有其他主函数的模式。调用初始化MPI是因为我们在这个程序中建立线性求解器的Trilinos库需要它。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step41; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization( 
        argc, argv, numbers::invalid_unsigned_int); 

// 这个程序只能在串行中运行。否则，将抛出一个异常。

      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1, 
                  ExcMessage( 
                    "This program can only be run in serial, use ./step-41")); 

      ObstacleProblem<2> obstacle_problem; 
      obstacle_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-42.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2012 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Joerg Frohne, Texas A&M University and 
 *                        University of Siegen, 2012, 2013 
 *          Wolfgang Bangerth, Texas A&M University, 2012, 2013 
 *          Timo Heister, Texas A&M University, 2013 
 */ 


// @sect3{Include files}  这组包含文件在这个时候已经没有什么惊喜了。

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/parameter_handler.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/index_set.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparsity_tools.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/block_sparsity_pattern.h> 
#include <deal.II/lac/solver_bicgstab.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/trilinos_block_sparse_matrix.h> 
#include <deal.II/lac/trilinos_vector.h> 
#include <deal.II/lac/trilinos_parallel_block_vector.h> 
#include <deal.II/lac/trilinos_precondition.h> 
#include <deal.II/lac/trilinos_solver.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/manifold_lib.h> 

#include <deal.II/distributed/tria.h> 
#include <deal.II/distributed/grid_refinement.h> 
#include <deal.II/distributed/solution_transfer.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/fe_field_function.h> 

#include <fstream> 
#include <iostream> 

// 最后，我们包括两个系统头文件，让我们为输出文件创建一个目录。第一个头文件提供了 <code>mkdir</code> 的功能，第二个头文件让我们确定在 <code>mkdir</code> 失败时发生了什么。

#include <sys/stat.h> 
#include <cerrno> 

namespace Step42 
{ 
  using namespace dealii; 
// @sect3{The <code>ConstitutiveLaw</code> class template}  

// 该类提供了一个构成法的接口，即应变  $\varepsilon(\mathbf u)$  和应力  $\sigma$  之间的关系。在这个例子中，我们使用的是具有线性、各向同性硬化的弹塑性材料行为。这种材料的特点是杨氏模量  $E$  ，泊松比  $\nu$  ，初始屈服应力  $\sigma_0$  和各向同性硬化参数  $\gamma$  。 对于 $\gamma = 0$ ，我们得到完美的弹塑性行为。

// 正如描述这个程序的论文所解释的那样，第一个牛顿步骤是用一个完全弹性材料模型来解决的，以避免同时处理两种非线性（塑性和接触）。为此，这个类有一个函数 <code>set_sigma_0()</code> ，我们在后面使用这个函数，简单地将 $\sigma_0$ 设置为一个非常大的值--基本上保证了实际应力不会超过它，从而产生一个弹性材料。当我们准备使用塑性模型时，我们使用相同的函数将 $\sigma_0$ 设置回其适当的值。 由于这种方法，我们需要将 <code>sigma_0</code> 作为这个类的唯一非静态成员变量。

  template <int dim> 
  class ConstitutiveLaw 
  { 
  public: 
    ConstitutiveLaw(const double E, 
                    const double nu, 
                    const double sigma_0, 
                    const double gamma); 

    void set_sigma_0(double sigma_zero); 

    bool get_stress_strain_tensor( 
      const SymmetricTensor<2, dim> &strain_tensor, 
      SymmetricTensor<4, dim> &      stress_strain_tensor) const; 

    void get_linearized_stress_strain_tensors( 
      const SymmetricTensor<2, dim> &strain_tensor, 
      SymmetricTensor<4, dim> &      stress_strain_tensor_linearized, 
      SymmetricTensor<4, dim> &      stress_strain_tensor) const; 

  private: 
    const double kappa; 
    const double mu; 
    double       sigma_0; 
    const double gamma; 

    const SymmetricTensor<4, dim> stress_strain_tensor_kappa; 
    const SymmetricTensor<4, dim> stress_strain_tensor_mu; 
  }; 

// ConstitutiveLaw类的构造函数为我们的可变形体设置所需的材料参数。弹性各向同性介质的材料参数可以用多种方式定义，如一对 $E, \nu$ （弹性模量和泊松数），使用Lam&eacute;参数 $\lambda,mu$ 或其他几种常用的约定。在这里，构造器采用 $E,\nu$ 形式的材料参数描述，但由于这证明这些不是出现在塑性投影仪方程中的系数，我们立即将它们转换为更合适的体模和剪模集合 $\kappa,\mu$ 。 此外，构造器以 $\sigma_0$ （无任何塑性应变的屈服应力）和 $\gamma$ （硬化参数）作为参数。在这个构造函数中，我们还计算了应力-应变关系的两个主成分及其线性化。

  template <int dim> 
  ConstitutiveLaw<dim>::ConstitutiveLaw(double E, 
                                        double nu, 
                                        double sigma_0, 
                                        double gamma) 
    : kappa(E / (3 * (1 - 2 * nu))) 
    , mu(E / (2 * (1 + nu))) 
    , sigma_0(sigma_0) 
    , gamma(gamma) 
    , stress_strain_tensor_kappa(kappa * 
                                 outer_product(unit_symmetric_tensor<dim>(), 
                                               unit_symmetric_tensor<dim>())) 
    , stress_strain_tensor_mu( 
        2 * mu * 
        (identity_tensor<dim>() - outer_product(unit_symmetric_tensor<dim>(), 
                                                unit_symmetric_tensor<dim>()) / 
                                    3.0)) 
  {} 

  template <int dim> 
  void ConstitutiveLaw<dim>::set_sigma_0(double sigma_zero) 
  { 
    sigma_0 = sigma_zero; 
  } 
// @sect4{ConstitutiveLaw::get_stress_strain_tensor}  

// 这是构成法则的主成分。它计算的是四阶对称张量，根据上面给出的投影，当在一个特定的应变点上评估时，该张量将应变与应力联系起来。我们需要这个函数来计算 <code>PlasticityContactProblem::residual_nl_system()</code> 中的非线性残差，我们将这个张量与正交点的应变相乘。计算遵循介绍中列出的公式。在比较那里的公式和下面的实现时，记得 $C_\mu : \varepsilon = \tau_D$ 和 $C_\kappa : \varepsilon = \kappa \text{trace}(\varepsilon) I = \frac 13 \text{trace}(\tau) I$  。

// 该函数返回正交点是否是塑性的，以便在下游对有多少正交点是塑性的，有多少是弹性的进行一些统计。

  template <int dim> 
  bool ConstitutiveLaw<dim>::get_stress_strain_tensor( 
    const SymmetricTensor<2, dim> &strain_tensor, 
    SymmetricTensor<4, dim> &      stress_strain_tensor) const 
  { 
    Assert(dim == 3, ExcNotImplemented()); 

    SymmetricTensor<2, dim> stress_tensor; 
    stress_tensor = 
      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor; 

    const SymmetricTensor<2, dim> deviator_stress_tensor = 
      deviator(stress_tensor); 
    const double deviator_stress_tensor_norm = deviator_stress_tensor.norm(); 

    stress_strain_tensor = stress_strain_tensor_mu; 
    if (deviator_stress_tensor_norm > sigma_0) 
      { 
        const double beta = sigma_0 / deviator_stress_tensor_norm; 
        stress_strain_tensor *= (gamma + (1 - gamma) * beta); 
      } 

    stress_strain_tensor += stress_strain_tensor_kappa; 

    return (deviator_stress_tensor_norm > sigma_0); 
  } 
// @sect4{ConstitutiveLaw::get_linearized_stress_strain_tensors}  

// 该函数返回线性化的应力应变张量，围绕前一个牛顿步骤 $u^{i-1}$ 的解进行线性化  $i-1$  。 参数 <code>strain_tensor</code> （通常表示为 $\varepsilon(u^{i-1})$ ）必须作为参数传递，并作为线性化点。该函数在变量stress_strain_tensor中返回非线性构成法的导数，在stress_strain_tensor_linearized中返回线性化问题的应力-应变张量。 参见 PlasticityContactProblem::assemble_nl_system ，其中使用了这个函数。

  template <int dim> 
  void ConstitutiveLaw<dim>::get_linearized_stress_strain_tensors( 
    const SymmetricTensor<2, dim> &strain_tensor, 
    SymmetricTensor<4, dim> &      stress_strain_tensor_linearized, 
    SymmetricTensor<4, dim> &      stress_strain_tensor) const 
  { 
    Assert(dim == 3, ExcNotImplemented()); 

    SymmetricTensor<2, dim> stress_tensor; 
    stress_tensor = 
      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor; 

    stress_strain_tensor            = stress_strain_tensor_mu; 
    stress_strain_tensor_linearized = stress_strain_tensor_mu; 

    SymmetricTensor<2, dim> deviator_stress_tensor = deviator(stress_tensor); 
    const double deviator_stress_tensor_norm = deviator_stress_tensor.norm(); 

    if (deviator_stress_tensor_norm > sigma_0) 
      { 
        const double beta = sigma_0 / deviator_stress_tensor_norm; 
        stress_strain_tensor *= (gamma + (1 - gamma) * beta); 
        stress_strain_tensor_linearized *= (gamma + (1 - gamma) * beta); 
        deviator_stress_tensor /= deviator_stress_tensor_norm; 
        stress_strain_tensor_linearized -= 
          (1 - gamma) * beta * 2 * mu * 
          outer_product(deviator_stress_tensor, deviator_stress_tensor); 
      } 

    stress_strain_tensor += stress_strain_tensor_kappa; 
    stress_strain_tensor_linearized += stress_strain_tensor_kappa; 
  } 
//<h3>Equation data: boundary forces, boundary values, obstacles</h3>

// 下面的内容应该是比较标准的。我们需要边界强迫项（我们在此选择为零）和不属于接触面的边界部分的边界值（在此也选择为零）的类。

  namespace EquationData 
  { 
    template <int dim> 
    class BoundaryForce : public Function<dim> 
    { 
    public: 
      BoundaryForce(); 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  values) const override; 
    }; 

    template <int dim> 
    BoundaryForce<dim>::BoundaryForce() 
      : Function<dim>(dim) 
    {} 

    template <int dim> 
    double BoundaryForce<dim>::value(const Point<dim> &, 
                                     const unsigned int) const 
    { 
      return 0.; 
    } 

    template <int dim> 
    void BoundaryForce<dim>::vector_value(const Point<dim> &p, 
                                          Vector<double> &  values) const 
    { 
      for (unsigned int c = 0; c < this->n_components; ++c) 
        values(c) = BoundaryForce<dim>::value(p, c); 
    } 

    template <int dim> 
    class BoundaryValues : public Function<dim> 
    { 
    public: 
      BoundaryValues(); 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 
    }; 

    template <int dim> 
    BoundaryValues<dim>::BoundaryValues() 
      : Function<dim>(dim) 
    {} 

    template <int dim> 
    double BoundaryValues<dim>::value(const Point<dim> &, 
                                      const unsigned int) const 
    { 
      return 0.; 
    } 

//  @sect4{The <code>SphereObstacle</code> class}  

// 下面这个类是可以从输入文件中选择的两个障碍物中的第一个。它描述了一个以位置 $x=y=0.5, z=z_{\text{surface}}+0.59$ 和半径 $r=0.6$ 为中心的球体，其中 $z_{\text{surface}}$ 是可变形体的（平）表面的垂直位置。该函数的 <code>value</code> 返回给定 $x,y$ 值的障碍物位置，如果该点实际位于球体下方，则返回一个不可能干扰变形的大正值，如果它位于球体的 "阴影 "之外。

    template <int dim> 
    class SphereObstacle : public Function<dim> 
    { 
    public: 
      SphereObstacle(const double z_surface); 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  values) const override; 

    private: 
      const double z_surface; 
    }; 

    template <int dim> 
    SphereObstacle<dim>::SphereObstacle(const double z_surface) 
      : Function<dim>(dim) 
      , z_surface(z_surface) 
    {} 

    template <int dim> 
    double SphereObstacle<dim>::value(const Point<dim> & p, 
                                      const unsigned int component) const 
    { 
      if (component == 0) 
        return p(0); 
      else if (component == 1) 
        return p(1); 
      else if (component == 2) 
        { 
          if ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) < 0.36) 
            return (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) - 
                               (p(1) - 0.5) * (p(1) - 0.5)) + 
                    z_surface + 0.59); 
          else 
            return 1000; 
        } 

      Assert(false, ExcNotImplemented()); 
      return 1e9; // an unreasonable value; ignored in debug mode because of the 

// 前面的断言

    } 

    template <int dim> 
    void SphereObstacle<dim>::vector_value(const Point<dim> &p, 
                                           Vector<double> &  values) const 
    { 
      for (unsigned int c = 0; c < this->n_components; ++c) 
        values(c) = SphereObstacle<dim>::value(p, c); 
    } 
// @sect4{The <code>BitmapFile</code> and <code>ChineseObstacle</code> classes}  

// 下面两个类描述了介绍中概述的障碍物，即汉字。两个中的第一个， <code>BitmapFile</code> 负责从一个以pbm ascii格式存储的图片文件中读入数据。这个数据将被双线性插值，从而提供一个描述障碍物的函数。(下面的代码显示了如何通过在给定的数据点之间进行内插来构造一个函数。人们可以使用在这个教程程序写完后引入的 Functions::InterpolatedUniformGridData, ，它正是我们在这里想要的，但看看如何手工操作是有启发的）。)

// 我们从文件中读取的数据将被存储在一个名为 obstacle_data 的双 std::vector 中。 这个向量构成了计算单片双线性函数的基础，作为一个多项式插值。我们将从文件中读取的数据由零（白色）和一（黑色）组成。

//  <code>hx,hy</code> 变量表示 $x$ 和 $y$ 方向的像素之间的间距。  <code>nx,ny</code> 是这些方向上的像素的数量。   <code>get_value()</code> 返回图像在给定位置的值，由相邻像素值插值而成。

    template <int dim> 
    class BitmapFile 
    { 
    public: 
      BitmapFile(const std::string &name); 

      double get_value(const double x, const double y) const; 

    private: 
      std::vector<double> obstacle_data; 
      double              hx, hy; 
      int                 nx, ny; 

      double get_pixel_value(const int i, const int j) const; 
    }; 

// 该类的构造函数从给定的文件名中读入描述障碍物的数据。

    template <int dim> 
    BitmapFile<dim>::BitmapFile(const std::string &name) 
      : obstacle_data(0) 
      , hx(0) 
      , hy(0) 
      , nx(0) 
      , ny(0) 
    { 
      std::ifstream f(name); 
      AssertThrow(f, 
                  ExcMessage(std::string("Can't read from file <") + name + 
                             ">!")); 

      std::string temp; 
      f >> temp >> nx >> ny; 

      AssertThrow(nx > 0 && ny > 0, ExcMessage("Invalid file format.")); 

      for (int k = 0; k < nx * ny; ++k) 
        { 
          double val; 
          f >> val; 
          obstacle_data.push_back(val); 
        } 

      hx = 1.0 / (nx - 1); 
      hy = 1.0 / (ny - 1); 

      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
        std::cout << "Read obstacle from file <" << name << ">" << std::endl 
                  << "Resolution of the scanned obstacle picture: " << nx 
                  << " x " << ny << std::endl; 
    } 

// 下面两个函数返回坐标为 $i,j$ 的给定像素的值，我们将其与定义在位置 <code>i*hx, j*hy</code> 的函数值和任意坐标 $x,y$ 的函数值相识别，在这里我们对两个函数中第一个函数返回的点值进行双线性内插。在第二个函数中，对于每个 $x,y$ ，我们首先计算离 $x,y$ 左下方最近的像素坐标的（整数）位置，然后计算这个像素内的坐标 $\xi,\eta$ 。我们从下方和上方截断这两种变量，以避免在评估函数时超出其定义的范围而可能发生的舍入误差问题。

    template <int dim> 
    double BitmapFile<dim>::get_pixel_value(const int i, const int j) const 
    { 
      assert(i >= 0 && i < nx); 
      assert(j >= 0 && j < ny); 
      return obstacle_data[nx * (ny - 1 - j) + i]; 
    } 

    template <int dim> 
    double BitmapFile<dim>::get_value(const double x, const double y) const 
    { 
      const int ix = std::min(std::max(static_cast<int>(x / hx), 0), nx - 2); 
      const int iy = std::min(std::max(static_cast<int>(y / hy), 0), ny - 2); 

      const double xi  = std::min(std::max((x - ix * hx) / hx, 1.), 0.); 
      const double eta = std::min(std::max((y - iy * hy) / hy, 1.), 0.); 

      return ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) + 
              xi * (1 - eta) * get_pixel_value(ix + 1, iy) + 
              (1 - xi) * eta * get_pixel_value(ix, iy + 1) + 
              xi * eta * get_pixel_value(ix + 1, iy + 1)); 
    } 

// 最后，这是一个实际使用上面的类的类。它有一个BitmapFile对象作为成员，描述障碍物的高度。如上所述，BitmapFile类将为我们提供一个掩码，即要么是0，要么是1的值（如果你要求的是像素之间的位置，则是在0和1之间插值的值）。这个类将其转化为高度，即低于可变形体表面的0.001（如果BitmapFile类在此位置报告为1）或高于障碍物的0.999（如果BitmapFile类报告为0）。那么下面的函数应该是不言自明的。

    template <int dim> 
    class ChineseObstacle : public Function<dim> 
    { 
    public: 
      ChineseObstacle(const std::string &filename, const double z_surface); 

      virtual double value(const Point<dim> & p, 
                           const unsigned int component = 0) const override; 

      virtual void vector_value(const Point<dim> &p, 
                                Vector<double> &  values) const override; 

    private: 
      const BitmapFile<dim> input_obstacle; 
      double                z_surface; 
    }; 

    template <int dim> 
    ChineseObstacle<dim>::ChineseObstacle(const std::string &filename, 
                                          const double       z_surface) 
      : Function<dim>(dim) 
      , input_obstacle(filename) 
      , z_surface(z_surface) 
    {} 

    template <int dim> 
    double ChineseObstacle<dim>::value(const Point<dim> & p, 
                                       const unsigned int component) const 
    { 
      if (component == 0) 
        return p(0); 
      if (component == 1) 
        return p(1); 
      else if (component == 2) 
        { 
          if (p(0) >= 0.0 && p(0) <= 1.0 && p(1) >= 0.0 && p(1) <= 1.0) 
            return z_surface + 0.999 - input_obstacle.get_value(p(0), p(1)); 
        } 

      Assert(false, ExcNotImplemented()); 
      return 1e9; // an unreasonable value; ignored in debug mode because of the 

// 前面的断言

    } 

    template <int dim> 
    void ChineseObstacle<dim>::vector_value(const Point<dim> &p, 
                                            Vector<double> &  values) const 
    { 
      for (unsigned int c = 0; c < this->n_components; ++c) 
        values(c) = ChineseObstacle<dim>::value(p, c); 
    } 
  } // namespace EquationData 
// @sect3{The <code>PlasticityContactProblem</code> class template}  

// 这是本程序的主类，提供了描述非线性接触问题所需的所有函数和变量。它接近于 step-41 ，但有一些额外的功能，如处理悬挂节点，牛顿方法，使用Trilinos和p4est进行并行分布式计算。处理悬空节点使生活变得有点复杂，因为我们现在需要另一个AffineConstraints对象。我们为接触情况下的主动集合方法创建一个牛顿方法，并处理构成法的非线性算子。

// 这个类的总体布局与其他大多数教程程序非常相似。为了使我们的生活更容易一些，这个类从输入文件中读取一组输入参数。这些参数，使用ParameterHandler类，在 <code>declare_parameters</code> 函数中声明（该函数是静态的，因此它可以在我们创建当前类型的对象之前被调用），然后一个已经用于读取输入文件的ParameterHandler对象将被传递给该类的构造函数。

// 其余的成员函数大体上与我们在其他几个教程程序中看到的一样，虽然为当前的非线性系统增加了一些内容。我们将在下文中对它们的用途进行评论。

  template <int dim> 
  class PlasticityContactProblem 
  { 
  public: 
    PlasticityContactProblem(const ParameterHandler &prm); 

    void run(); 

    static void declare_parameters(ParameterHandler &prm); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void compute_dirichlet_constraints(); 
    void update_solution_and_constraints(); 
    void 
         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix); 
    void assemble_newton_system( 
      const TrilinosWrappers::MPI::Vector &linearization_point); 
    void compute_nonlinear_residual( 
      const TrilinosWrappers::MPI::Vector &linearization_point); 
    void solve_newton_system(); 
    void solve_newton(); 
    void refine_grid(); 
    void move_mesh(const TrilinosWrappers::MPI::Vector &displacement) const; 
    void output_results(const unsigned int current_refinement_cycle); 

    void output_contact_force() const; 

// 就成员变量而言，我们先用一个变量来表示这个程序运行的MPI宇宙，一个我们用来让确切的一个处理器产生输出到控制台的流（见 step-17  ）和一个用来为程序的各个部分计时的变量。

    MPI_Comm           mpi_communicator; 
    ConditionalOStream pcout; 
    TimerOutput        computing_timer; 

// 下一组描述网格和有限元空间。特别是，对于这个并行程序，有限元空间有与之相关的变量，表明哪些自由度存在于当前的处理器上（索引集，也见 step-40 和 @ref distributed 文档模块），以及各种约束：那些由悬挂节点，由Dirichlet边界条件，以及由接触节点的活动集施加的约束。在这里定义的三个AffineConstraints变量中，第一个变量只包含悬挂节点的约束，第二个变量也包含与Dirichlet边界条件相关的约束，第三个变量包含这些约束和接触约束。

// 变量 <code>active_set</code> 包括那些由接触约束的自由度，我们用 <code>fraction_of_plastic_q_points_per_cell</code> 来跟踪每个单元上应力等于屈服应力的正交点的分数。后者仅用于创建显示塑性区的图形输出，但不用于任何进一步的计算；该变量是该类的成员变量，因为该信息是作为计算残差的副产品计算的，但仅在很晚的时候使用。(注意，该向量是一个长度等于<i>local mesh</i>上活动单元数量的向量；它从未被用来在处理器之间交换信息，因此可以是一个普通的deal.II向量)。

    const unsigned int                        n_initial_global_refinements; 
    parallel::distributed::Triangulation<dim> triangulation; 

    const unsigned int fe_degree; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 

    IndexSet locally_owned_dofs; 
    IndexSet locally_relevant_dofs; 

    AffineConstraints<double> constraints_hanging_nodes; 
    AffineConstraints<double> constraints_dirichlet_and_hanging_nodes; 
    AffineConstraints<double> all_constraints; 

    IndexSet      active_set; 
    Vector<float> fraction_of_plastic_q_points_per_cell; 

// 下一个变量块对应的是解决方案和我们需要形成的线性系统。特别是，这包括牛顿矩阵和右手边；与残差（即牛顿右手边）相对应的向量，但我们没有消除其中的各种约束，该向量用于确定在下一次迭代中需要约束哪些自由度；以及一个与介绍中简要提到的 $B$ 矩阵的对角线相对应的向量，并在随文中讨论。

    TrilinosWrappers::SparseMatrix newton_matrix; 

    TrilinosWrappers::MPI::Vector solution; 
    TrilinosWrappers::MPI::Vector newton_rhs; 
    TrilinosWrappers::MPI::Vector newton_rhs_uncondensed; 
    TrilinosWrappers::MPI::Vector diag_mass_matrix_vector; 

// 下一个块包含描述材料响应的变量。

    const double         e_modulus, nu, gamma, sigma_0; 
    ConstitutiveLaw<dim> constitutive_law; 

// 然后是各种各样的其他变量，用于识别参数文件所选择的要求我们建立的网格，被推入可变形体的障碍物，网格细化策略，是否将解决方案从一个网格转移到下一个网格，以及要执行多少个网格细化循环。在可能的情况下，我们将这些类型的变量标记为 <code>const</code> ，以帮助读者识别哪些变量以后可能会被修改，哪些可能不会被修改（输出目录是一个例外--它在构造函数之外从不被修改，但在构造函数中冒号后面的成员初始化列表中初始化是很尴尬的，因为在那里我们只有一次机会设置它；网格细化准则也是如此）。

    const std::string                          base_mesh; 
    const std::shared_ptr<const Function<dim>> obstacle; 

    struct RefinementStrategy 
    { 
      enum value 
      { 
        refine_global, 
        refine_percentage, 
        refine_fix_dofs 
      }; 
    }; 
    typename RefinementStrategy::value refinement_strategy; 

    const bool         transfer_solution; 
    std::string        output_dir; 
    const unsigned int n_refinement_cycles; 
    unsigned int       current_refinement_cycle; 
  }; 
// @sect3{Implementation of the <code>PlasticityContactProblem</code> class}  
// @sect4{PlasticityContactProblem::declare_parameters}  

// 让我们从声明可在输入文件中选择的运行时参数开始。这些值将在本类的构造函数中读回，以初始化本类的成员变量。

  template <int dim> 
  void PlasticityContactProblem<dim>::declare_parameters(ParameterHandler &prm) 
  { 
    prm.declare_entry( 
      "polynomial degree", 
      "1", 
      Patterns::Integer(), 
      "Polynomial degree of the FE_Q finite element space, typically 1 or 2."); 
    prm.declare_entry("number of initial refinements", 
                      "2", 
                      Patterns::Integer(), 
                      "Number of initial global mesh refinement steps before " 
                      "the first computation."); 
    prm.declare_entry( 
      "refinement strategy", 
      "percentage", 
      Patterns::Selection("global|percentage"), 
      "Mesh refinement strategy:\n" 
      " global: one global refinement\n" 
      " percentage: a fixed percentage of cells gets refined using the Kelly estimator."); 
    prm.declare_entry("number of cycles", 
                      "5", 
                      Patterns::Integer(), 
                      "Number of adaptive mesh refinement cycles to run."); 
    prm.declare_entry( 
      "obstacle", 
      "sphere", 
      Patterns::Selection("sphere|read from file"), 
      "The name of the obstacle to use. This may either be 'sphere' if we should " 
      "use a spherical obstacle, or 'read from file' in which case the obstacle " 
      "will be read from a file named 'obstacle.pbm' that is supposed to be in " 
      "ASCII PBM format."); 
    prm.declare_entry( 
      "output directory", 
      "", 
      Patterns::Anything(), 
      "Directory for output files (graphical output and benchmark " 
      "statistics). If empty, use the current directory."); 
    prm.declare_entry( 
      "transfer solution", 
      "false", 
      Patterns::Bool(), 
      "Whether the solution should be used as a starting guess " 
      "for the next finer mesh. If false, then the iteration starts at " 
      "zero on every mesh."); 
    prm.declare_entry("base mesh", 
                      "box", 
                      Patterns::Selection("box|half sphere"), 
                      "Select the shape of the domain: 'box' or 'half sphere'"); 
  } 
// @sect4{The <code>PlasticityContactProblem</code> constructor}  

// 鉴于成员变量的声明以及从输入文件中读取的运行时参数的声明，在这个构造函数中没有任何令人惊讶的地方。在正文中，我们初始化了网格细化策略和输出目录，必要时创建这样一个目录。

  template <int dim> 
  PlasticityContactProblem<dim>::PlasticityContactProblem( 
    const ParameterHandler &prm) 
    : mpi_communicator(MPI_COMM_WORLD) 
    , pcout(std::cout, 
            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
    , computing_timer(MPI_COMM_WORLD, 
                      pcout, 
                      TimerOutput::never, 
                      TimerOutput::wall_times) 

    , n_initial_global_refinements( 
        prm.get_integer("number of initial refinements")) 
    , triangulation(mpi_communicator) 
    , fe_degree(prm.get_integer("polynomial degree")) 
    , fe(FE_Q<dim>(QGaussLobatto<1>(fe_degree + 1)), dim) 
    , dof_handler(triangulation) 

    , e_modulus(200000) 
    , nu(0.3) 
    , gamma(0.01) 
    , sigma_0(400.0) 
    , constitutive_law(e_modulus, nu, sigma_0, gamma) 

    , base_mesh(prm.get("base mesh")) 
    , obstacle(prm.get("obstacle") == "read from file" ? 
                 static_cast<const Function<dim> *>( 
                   new EquationData::ChineseObstacle<dim>( 
                     "obstacle.pbm", 
                     (base_mesh == "box" ? 1.0 : 0.5))) : 
                 static_cast<const Function<dim> *>( 
                   new EquationData::SphereObstacle<dim>( 
                     base_mesh == "box" ? 1.0 : 0.5))) 

    , transfer_solution(prm.get_bool("transfer solution")) 
    , n_refinement_cycles(prm.get_integer("number of cycles")) 
    , current_refinement_cycle(0) 

  { 
    std::string strat = prm.get("refinement strategy"); 
    if (strat == "global") 
      refinement_strategy = RefinementStrategy::refine_global; 
    else if (strat == "percentage") 
      refinement_strategy = RefinementStrategy::refine_percentage; 
    else 
      AssertThrow(false, ExcNotImplemented()); 

    output_dir = prm.get("output directory"); 
    if (output_dir != "" && *(output_dir.rbegin()) != '/') 
      output_dir += "/"; 

// 如果有必要，为输出创建一个新的目录。

    if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0) 
      { 
        const int ierr = mkdir(output_dir.c_str(), 0777); 
        AssertThrow(ierr == 0 || errno == EEXIST, ExcIO()); 
      } 

    pcout << "    Using output directory '" << output_dir << "'" << std::endl; 
    pcout << "    FE degree " << fe_degree << std::endl; 
    pcout << "    transfer solution " << (transfer_solution ? "true" : "false") 
          << std::endl; 
  } 

//  @sect4{PlasticityContactProblem::make_grid}  

// 下一个区块是关于构建起始网格的。我们将使用下面的辅助函数和 <code>make_grid()</code> 的第一个块来构造一个对应于半球形的网格。deal.II有一个函数可以创建这样的网格，但是它的位置和方向都是错误的，所以我们需要在使用它之前对它进行一些位移和旋转。

// 供以后参考，如 GridGenerator::half_hyper_ball(), 文件中所述，半球体的平坦表面的边界指标为零，而其余部分的边界指标为一。

  Point<3> rotate_half_sphere(const Point<3> &in) 
  { 
    return {in(2), in(1), -in(0)}; 
  } 

  template <int dim> 
  void PlasticityContactProblem<dim>::make_grid() 
  { 
    if (base_mesh == "half sphere") 
      { 
        const Point<dim> center(0, 0, 0); 
        const double     radius = 0.8; 
        GridGenerator::half_hyper_ball(triangulation, center, radius); 

// 由于我们将在下面附加一个不同的流形，我们立即清除默认的流形描述。

        triangulation.reset_all_manifolds(); 

        GridTools::transform(&rotate_half_sphere, triangulation); 
        GridTools::shift(Point<dim>(0.5, 0.5, 0.5), triangulation); 

        SphericalManifold<dim> manifold_description(Point<dim>(0.5, 0.5, 0.5)); 
        GridTools::copy_boundary_to_manifold_id(triangulation); 
        triangulation.set_manifold(0, manifold_description); 
      } 

// 或者，创建一个超立方体网格。创建后，按如下方式分配边界指标。
// @code
//  >     _______
//  >    /  1    /|
//  >   /______ / |
//  >  |       | 8|
//  >  |   8   | /
//  >  |_______|/
//  >      6
//  @endcode
  // 换句话说，立方体的边的边界指标是8。底部的边界指标是6，顶部的指标是1。我们通过循环所有面的所有单元并查看单元中心的坐标值来设置这些指标，并在以后评估哪个边界将携带迪里希特边界条件或将受到潜在接触时使用这些指标。(在目前的情况下，网格只包含一个单元，它的所有面都在边界上，所以严格来说，所有单元的循环和查询一个面是否在边界上都是不必要的；我们保留它们只是出于习惯：这种代码可以在许多程序中找到，基本上都是这种形式。)

    else 
      { 
        const Point<dim> p1(0, 0, 0); 
        const Point<dim> p2(1.0, 1.0, 1.0); 

        GridGenerator::hyper_rectangle(triangulation, p1, p2); 

        for (const auto &cell : triangulation.active_cell_iterators()) 
          for (const auto &face : cell->face_iterators()) 
            if (face->at_boundary()) 
              { 
                if (std::fabs(face->center()[2] - p2[2]) < 1e-12) 
                  face->set_boundary_id(1); 
                if (std::fabs(face->center()[0] - p1[0]) < 1e-12 || 
                    std::fabs(face->center()[0] - p2[0]) < 1e-12 || 
                    std::fabs(face->center()[1] - p1[1]) < 1e-12 || 
                    std::fabs(face->center()[1] - p2[1]) < 1e-12) 
                  face->set_boundary_id(8); 
                if (std::fabs(face->center()[2] - p1[2]) < 1e-12) 
                  face->set_boundary_id(6); 
              } 
      } 

    triangulation.refine_global(n_initial_global_refinements); 
  } 

//  @sect4{PlasticityContactProblem::setup_system}  

// 谜题的下一块是设置DoFHandler，调整向量大小，并处理其他各种状态变量，如索引集和约束矩阵。

// 在下面的内容中，每一组操作都被放入一个大括号封闭的块中，该块的顶部声明的变量正在进行计时（ TimerOutput::Scope 变量的构造器开始计时部分，在块的末端调用的析构器再次停止计时）。

  template <int dim> 
  void PlasticityContactProblem<dim>::setup_system() 
  { 

/* 设置dofs，并为本地拥有的相关dofs获取索引集  */ 

    { 
      TimerOutput::Scope t(computing_timer, "Setup: distribute DoFs"); 
      dof_handler.distribute_dofs(fe); 

      locally_owned_dofs = dof_handler.locally_owned_dofs(); 
      locally_relevant_dofs.clear(); 
      DoFTools::extract_locally_relevant_dofs(dof_handler, 
                                              locally_relevant_dofs); 
    } 

/*设置悬挂节点和Dirichlet约束 */ 

 
    { 
      TimerOutput::Scope t(computing_timer, "Setup: constraints"); 
      constraints_hanging_nodes.reinit(locally_relevant_dofs); 
      DoFTools::make_hanging_node_constraints(dof_handler, 
                                              constraints_hanging_nodes); 
      constraints_hanging_nodes.close(); 

      pcout << "   Number of active cells: " 
            << triangulation.n_global_active_cells() << std::endl 
            << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
            << std::endl; 

      compute_dirichlet_constraints(); 
    } 

/* 初始化向量和活动集  */ 

    { 
      TimerOutput::Scope t(computing_timer, "Setup: vectors"); 
      solution.reinit(locally_relevant_dofs, mpi_communicator); 
      newton_rhs.reinit(locally_owned_dofs, mpi_communicator); 
      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator); 
      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator); 
      fraction_of_plastic_q_points_per_cell.reinit( 
        triangulation.n_active_cells()); 

      active_set.clear(); 
      active_set.set_size(dof_handler.n_dofs()); 
    } 

// 最后，我们设置了稀疏模式和矩阵。我们暂时（ab）用系统矩阵来同时建立（对角线）矩阵，用于消除与障碍物接触的自由度，但我们随后立即将牛顿矩阵设回零。

    { 
      TimerOutput::Scope                t(computing_timer, "Setup: matrix"); 
      TrilinosWrappers::SparsityPattern sp(locally_owned_dofs, 
                                           mpi_communicator); 

      DoFTools::make_sparsity_pattern(dof_handler, 
                                      sp, 
                                      constraints_dirichlet_and_hanging_nodes, 
                                      false, 
                                      Utilities::MPI::this_mpi_process( 
                                        mpi_communicator)); 
      sp.compress(); 
      newton_matrix.reinit(sp); 

      TrilinosWrappers::SparseMatrix &mass_matrix = newton_matrix; 

      assemble_mass_matrix_diagonal(mass_matrix); 

      const unsigned int start = (newton_rhs.local_range().first), 
                         end   = (newton_rhs.local_range().second); 
      for (unsigned int j = start; j < end; ++j) 
        diag_mass_matrix_vector(j) = mass_matrix.diag_element(j); 
      diag_mass_matrix_vector.compress(VectorOperation::insert); 

      mass_matrix = 0; 
    } 
  } 
// @sect4{PlasticityContactProblem::compute_dirichlet_constraints}  

// 这个函数从前面的函数中分离出来，计算与迪里切特型边界条件相关的约束，并通过与来自悬挂节点的约束合并，将其放入 <code>constraints_dirichlet_and_hanging_nodes</code> 变量。

// 正如在介绍中所阐述的，我们需要区分两种情况。

// - 如果域是一个盒子，我们将底部的位移设置为零，并允许沿侧面的Z方向的垂直运动。如 <code>make_grid()</code> 函数所示，前者对应于边界指标6，后者对应于8。

// - 如果域是一个半球形，那么我们沿边界的弯曲部分施加零位移，与边界指标0相关。

  template <int dim> 
  void PlasticityContactProblem<dim>::compute_dirichlet_constraints() 
  { 
    constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs); 
    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes); 

    if (base_mesh == "box") 
      { 

//插值解决方案的所有组成部分

        VectorTools::interpolate_boundary_values( 
          dof_handler, 
          6, 
          EquationData::BoundaryValues<dim>(), 
          constraints_dirichlet_and_hanging_nodes, 
          ComponentMask()); 

//对解决方案的X和Y分量进行插值（这是一个位掩码，所以应用运算器|）。

        const FEValuesExtractors::Scalar x_displacement(0); 
        const FEValuesExtractors::Scalar y_displacement(1); 
        VectorTools::interpolate_boundary_values( 
          dof_handler, 
          8, 
          EquationData::BoundaryValues<dim>(), 
          constraints_dirichlet_and_hanging_nodes, 
          (fe.component_mask(x_displacement) | 
           fe.component_mask(y_displacement))); 
      } 
    else 
      VectorTools::interpolate_boundary_values( 
        dof_handler, 
        0, 
        EquationData::BoundaryValues<dim>(), 
        constraints_dirichlet_and_hanging_nodes, 
        ComponentMask()); 

    constraints_dirichlet_and_hanging_nodes.close(); 
  } 

//  @sect4{PlasticityContactProblem::assemble_mass_matrix_diagonal}  

// 下一个辅助函数计算（对角线）质量矩阵，用于确定我们在接触算法中使用的主动集合方法的主动集合。这个矩阵是质量矩阵类型的，但与标准质量矩阵不同，我们可以通过使用正交公式使其成为对角线（即使在高阶元素的情况下），该公式的正交点与有限元插值点的位置完全相同。我们通过使用QGaussLobatto正交公式来实现这一点，同时用一组从同一正交公式得出的插值点初始化有限元。该函数的其余部分相对简单：我们将得到的矩阵放入给定的参数中；因为我们知道矩阵是对角线的，所以只需在 $i$ 而不是 $j$ 上有一个循环即可。严格来说，我们甚至可以避免在正交点 <code>q_point</code> 处将形状函数的值与自身相乘，因为我们知道形状值是一个恰好有一个的向量，当与自身相点时产生1。由于这个函数不是时间关键，为了清楚起见，我们添加了这个术语。

  template <int dim> 
  void PlasticityContactProblem<dim>::assemble_mass_matrix_diagonal( 
    TrilinosWrappers::SparseMatrix &mass_matrix) 
  { 
    QGaussLobatto<dim - 1> face_quadrature_formula(fe.degree + 1); 

    FEFaceValues<dim> fe_values_face(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_JxW_values); 

    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const FEValuesExtractors::Vector displacement(0); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary() && face->boundary_id() == 1) 
            { 
              fe_values_face.reinit(cell, face); 
              cell_matrix = 0; 

              for (unsigned int q_point = 0; q_point < n_face_q_points; 
                   ++q_point) 
                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  cell_matrix(i, i) += 
                    (fe_values_face[displacement].value(i, q_point) * 
                     fe_values_face[displacement].value(i, q_point) * 
                     fe_values_face.JxW(q_point)); 

              cell->get_dof_indices(local_dof_indices); 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                mass_matrix.add(local_dof_indices[i], 
                                local_dof_indices[i], 
                                cell_matrix(i, i)); 
            } 
    mass_matrix.compress(VectorOperation::add); 
  } 
// @sect4{PlasticityContactProblem::update_solution_and_constraints}  

// 下面的函数是我们在 <code>solve_newton()</code> 函数中每次牛顿迭代时调用的第一个函数。它的作用是将解决方案投射到可行集上，并更新接触或穿透障碍物的自由度的活动集。

// 为了实现这个功能，我们首先需要做一些记账工作。我们需要写入解决方案向量（我们只能用没有鬼魂元素的完全分布的向量来做），我们需要从各自的向量中读取拉格朗日乘数和对角线质量矩阵的元素（我们只能用有鬼魂元素的向量来做），所以我们创建各自的向量。然后我们还要初始化约束对象，该对象将包含来自接触和所有其他来源的约束，以及一个包含所有属于接触的本地自由度的索引集的对象。

  template <int dim> 
  void PlasticityContactProblem<dim>::update_solution_and_constraints() 
  { 
    std::vector<bool> dof_touched(dof_handler.n_dofs(), false); 

    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs, 
                                                       mpi_communicator); 
    distributed_solution = solution; 

    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs, 
                                         mpi_communicator); 
    lambda = newton_rhs_uncondensed; 

    TrilinosWrappers::MPI::Vector diag_mass_matrix_vector_relevant( 
      locally_relevant_dofs, mpi_communicator); 
    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector; 

    all_constraints.reinit(locally_relevant_dofs); 
    active_set.clear(); 

// 第二部分是在所有单元格上的循环，在这个循环中，我们看每一个自由度被定义的点的活动集条件是否为真，我们需要把这个自由度加入到接触节点的活动集中。正如我们一直所做的，如果我们想在单个点上评估函数，我们用一个FEValues对象（或者，这里是FEFaceValues对象，因为我们需要检查表面的接触）和一个适当选择的正交对象来做。我们通过选择定义在单元格面上的形状函数的 "支持点 "来创建这个面的正交对象（关于支持点的更多信息，请参见这个 @ref GlossSupport "词汇表条目"）。因此，我们有多少个正交点，就有多少个面的形状函数，在正交点上循环就相当于在面的形状函数上循环。有了这个，代码看起来如下。

    Quadrature<dim - 1> face_quadrature(fe.get_unit_face_support_points()); 
    FEFaceValues<dim>   fe_values_face(fe, 
                                     face_quadrature, 
                                     update_quadrature_points); 

    const unsigned int dofs_per_face   = fe.n_dofs_per_face(); 
    const unsigned int n_face_q_points = face_quadrature.size(); 

    std::vector<types::global_dof_index> dof_indices(dofs_per_face); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (!cell->is_artificial()) 
        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary() && face->boundary_id() == 1) 
            { 
              fe_values_face.reinit(cell, face); 
              face->get_dof_indices(dof_indices); 

              for (unsigned int q_point = 0; q_point < n_face_q_points; 
                   ++q_point) 
                { 

// 在每个正交点（即位于接触边界上的自由度的每个支持点），我们再询问它是否是z-位移自由度的一部分，如果我们还没有遇到这个自由度（对于那些位于面之间的边缘的自由度可能发生），我们需要评估变形物体与障碍物之间的间隙。如果活动集条件为真，那么我们在AffineConstraints对象中添加一个约束，下一次牛顿更新需要满足这个约束，将求解向量的相应元素设置为正确的值，并将索引添加到IndexSet对象中，该索引存储哪个自由度是接触的一部分。

                  const unsigned int component = 
                    fe.face_system_to_component_index(q_point).first; 

                  const unsigned int index_z = dof_indices[q_point]; 

                  if ((component == 2) && (dof_touched[index_z] == false)) 
                    { 
                      dof_touched[index_z] = true; 

                      const Point<dim> this_support_point = 
                        fe_values_face.quadrature_point(q_point); 

                      const double obstacle_value = 
                        obstacle->value(this_support_point, 2); 
                      const double solution_here = solution(index_z); 
                      const double undeformed_gap = 
                        obstacle_value - this_support_point(2); 

                      const double c = 100.0 * e_modulus; 
                      if ((lambda(index_z) / 
                               diag_mass_matrix_vector_relevant(index_z) + 
                             c * (solution_here - undeformed_gap) > 
                           0) && 
                          !constraints_hanging_nodes.is_constrained(index_z)) 
                        { 
                          all_constraints.add_line(index_z); 
                          all_constraints.set_inhomogeneity(index_z, 
                                                            undeformed_gap); 
                          distributed_solution(index_z) = undeformed_gap; 

                          active_set.add_index(index_z); 
                        } 
                    } 
                } 
            } 

// 在这个函数的最后，我们在处理器之间交换数据，更新 <code>solution</code> 变量中那些已经被其他处理器写入的幽灵元素。然后我们将Dirichlet约束和那些来自悬挂节点的约束合并到已经包含活动集的AffineConstraints对象中。我们通过输出主动约束自由度的总数来结束这个函数，对于这个自由度，我们对每个处理器拥有的主动约束自由度的数量进行加总。这个本地拥有的受限自由度的数量当然是活动集和本地拥有的自由度集的交集的元素数量，我们可以通过在两个IndexSets上使用 <code>operator&</code> 得到。

    distributed_solution.compress(VectorOperation::insert); 
    solution = distributed_solution; 

    all_constraints.close(); 
    all_constraints.merge(constraints_dirichlet_and_hanging_nodes); 

 
          << Utilities::MPI::sum((active_set & locally_owned_dofs).n_elements(), 
                                 mpi_communicator) 
          << std::endl; 
  } 
// @sect4{PlasticityContactProblem::assemble_newton_system}  

// 鉴于问题的复杂性，可能会让人感到惊讶的是，在每次牛顿迭代中组装我们要解决的线性系统实际上是相当简单的。下面的函数建立了牛顿的右手边和牛顿矩阵。它看起来相当简单，因为繁重的工作发生在对 <code>ConstitutiveLaw::get_linearized_stress_strain_tensors()</code> 的调用中，特别是在 AffineConstraints::distribute_local_to_global(), 中使用我们之前计算的约束。

  template <int dim> 
  void PlasticityContactProblem<dim>::assemble_newton_system( 
    const TrilinosWrappers::MPI::Vector &linearization_point) 
  { 
    TimerOutput::Scope t(computing_timer, "Assembling"); 

    QGauss<dim>     quadrature_formula(fe.degree + 1); 
    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_JxW_values); 

    FEFaceValues<dim> fe_values_face(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_quadrature_points | 
                                       update_JxW_values); 

    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    const EquationData::BoundaryForce<dim> boundary_force; 
    std::vector<Vector<double>> boundary_force_values(n_face_q_points, 
                                                      Vector<double>(dim)); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const FEValuesExtractors::Vector displacement(0); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_values.reinit(cell); 
          cell_matrix = 0; 
          cell_rhs    = 0; 

          std::vector<SymmetricTensor<2, dim>> strain_tensor(n_q_points); 
          fe_values[displacement].get_function_symmetric_gradients( 
            linearization_point, strain_tensor); 

          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            { 
              SymmetricTensor<4, dim> stress_strain_tensor_linearized; 
              SymmetricTensor<4, dim> stress_strain_tensor; 
              constitutive_law.get_linearized_stress_strain_tensors( 
                strain_tensor[q_point], 
                stress_strain_tensor_linearized, 
                stress_strain_tensor); 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 

// 在计算了应力-应变张量及其线性化之后，我们现在可以把矩阵和右手边的部分放在一起。在这两部分中，我们需要线性化的应力-应变张量乘以 $\varphi_i$ 的对称梯度，即 $I_\Pi\varepsilon(\varphi_i)$ 项，因此我们引入这个项的缩写。回顾一下，该矩阵对应于随附出版物的符号中的双线性形式 $A_{ij}=(I_\Pi\varepsilon(\varphi_i),\varepsilon(\varphi_j))$ ，而右手边是 $F_i=([I_\Pi-P_\Pi C]\varepsilon(\varphi_i),\varepsilon(\mathbf u))$ ，其中 $u$ 是当前的线性化点（通常是最后的解）。这可能表明，如果材料是完全弹性的（其中 $I_\Pi=P_\Pi$ ），右手边将为零，但这忽略了一个事实，即右手边还将包含由于接触而产生的非均质约束的贡献。                
//接下来的代码块增加了由于边界力的贡献，如果有的话。

                  const SymmetricTensor<2, dim> stress_phi_i = 
                    stress_strain_tensor_linearized * 
                    fe_values[displacement].symmetric_gradient(i, q_point); 

                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    cell_matrix(i, j) += 
                      (stress_phi_i * 
                       fe_values[displacement].symmetric_gradient(j, q_point) * 
                       fe_values.JxW(q_point)); 

                  cell_rhs(i) += 
                    ((stress_phi_i - 
                      stress_strain_tensor * 
                        fe_values[displacement].symmetric_gradient(i, 
                                                                   q_point)) * 
                     strain_tensor[q_point] * fe_values.JxW(q_point)); 
                } 
            } 

          for (const auto &face : cell->face_iterators()) 
            if (face->at_boundary() && face->boundary_id() == 1) 
              { 
                fe_values_face.reinit(cell, face); 

                boundary_force.vector_value_list( 
                  fe_values_face.get_quadrature_points(), 
                  boundary_force_values); 

                for (unsigned int q_point = 0; q_point < n_face_q_points; 
                     ++q_point) 
                  { 
                    Tensor<1, dim> rhs_values; 
                    rhs_values[2] = boundary_force_values[q_point][2]; 
                    for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                      cell_rhs(i) += 
                        (fe_values_face[displacement].value(i, q_point) * 
                         rhs_values * fe_values_face.JxW(q_point)); 
                  } 
              } 

          cell->get_dof_indices(local_dof_indices); 
          all_constraints.distribute_local_to_global(cell_matrix, 
                                                     cell_rhs, 
                                                     local_dof_indices, 
                                                     newton_matrix, 
                                                     newton_rhs, 
                                                     true); 
        } 

    newton_matrix.compress(VectorOperation::add); 
    newton_rhs.compress(VectorOperation::add); 
  } 

//  @sect4{PlasticityContactProblem::compute_nonlinear_residual}  

// 下面的函数计算给定当前解（或任何其他线性化点）的方程的非线性残差。这在线性搜索算法中是需要的，我们需要尝试之前和当前（试验）解的各种线性组合来计算当前牛顿步骤的（真实的、全局化的）解。

// 说到这里，在稍微滥用函数名称的情况下，它实际上做了很多事情。例如，它还计算出与牛顿残差相对应的矢量，但没有消除受限自由度。我们需要这个向量来计算接触力，并最终计算出下一个活动集。同样，通过跟踪我们在每个单元上遇到的显示塑性屈服的正交点的数量，我们也可以计算出 <code>fraction_of_plastic_q_points_per_cell</code> 矢量，随后我们可以输出这个矢量来可视化塑性区。在这两种情况下，作为线条搜索的一部分，这些结果是不必要的，因此我们可能会浪费少量的时间来计算它们。同时，无论如何，这些信息是我们在这里需要做的事情的自然副产品，而且我们想在每个牛顿步骤结束时收集一次，所以我们不妨在这里做。

// 这个函数的实际实现应该是相当明显的。

  template <int dim> 
  void PlasticityContactProblem<dim>::compute_nonlinear_residual( 
    const TrilinosWrappers::MPI::Vector &linearization_point) 
  { 
    QGauss<dim>     quadrature_formula(fe.degree + 1); 
    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_JxW_values); 

    FEFaceValues<dim> fe_values_face(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_quadrature_points | 
                                       update_JxW_values); 

    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    const EquationData::BoundaryForce<dim> boundary_force; 
    std::vector<Vector<double>> boundary_force_values(n_face_q_points, 
                                                      Vector<double>(dim)); 

    Vector<double> cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const FEValuesExtractors::Vector displacement(0); 

    newton_rhs             = 0; 
    newton_rhs_uncondensed = 0; 

    fraction_of_plastic_q_points_per_cell = 0; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_values.reinit(cell); 
          cell_rhs = 0; 

          std::vector<SymmetricTensor<2, dim>> strain_tensors(n_q_points); 
          fe_values[displacement].get_function_symmetric_gradients( 
            linearization_point, strain_tensors); 

          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            { 
              SymmetricTensor<4, dim> stress_strain_tensor; 
              const bool              q_point_is_plastic = 
                constitutive_law.get_stress_strain_tensor( 
                  strain_tensors[q_point], stress_strain_tensor); 
              if (q_point_is_plastic) 
                ++fraction_of_plastic_q_points_per_cell( 
                  cell->active_cell_index()); 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  cell_rhs(i) -= 
                    (strain_tensors[q_point] * stress_strain_tensor * 
                     fe_values[displacement].symmetric_gradient(i, q_point) * 
                     fe_values.JxW(q_point)); 

                  Tensor<1, dim> rhs_values; 
                  rhs_values = 0; 
                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) * 
                                  rhs_values * fe_values.JxW(q_point)); 
                } 
            } 

          for (const auto &face : cell->face_iterators()) 
            if (face->at_boundary() && face->boundary_id() == 1) 
              { 
                fe_values_face.reinit(cell, face); 

                boundary_force.vector_value_list( 
                  fe_values_face.get_quadrature_points(), 
                  boundary_force_values); 

                for (unsigned int q_point = 0; q_point < n_face_q_points; 
                     ++q_point) 
                  { 
                    Tensor<1, dim> rhs_values; 
                    rhs_values[2] = boundary_force_values[q_point][2]; 
                    for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                      cell_rhs(i) += 
                        (fe_values_face[displacement].value(i, q_point) * 
                         rhs_values * fe_values_face.JxW(q_point)); 
                  } 
              } 

          cell->get_dof_indices(local_dof_indices); 
          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global( 
            cell_rhs, local_dof_indices, newton_rhs); 

          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i); 
        } 

    fraction_of_plastic_q_points_per_cell /= quadrature_formula.size(); 
    newton_rhs.compress(VectorOperation::add); 
    newton_rhs_uncondensed.compress(VectorOperation::add); 
  } 

//  @sect4{PlasticityContactProblem::solve_newton_system}  

// 在我们讨论单个网格上的实际牛顿迭代之前的最后一块是线性系统的求解器。有几个复杂的问题使代码略显模糊，但大多数情况下，它只是设置然后求解。在这些复杂的问题中，包括。



// 对于悬空节点，我们必须将 AffineConstraints::set_zero 函数应用于newton_rhs。  如果一个求解值为 $x_0$ 的悬空节点有一个与障碍物接触的数值为 $x_1$ 的邻居和一个没有接触的邻居 $x_2$ ，这就有必要。因为前者的更新将是规定的，所以悬挂的节点约束将有一个不均匀性，看起来像  $x_0 = x_1/2 +   \text{gap}/2$  。所以右侧的相应条目是无意义的非零值。这些值我们必须设置为零。

// - 就像在  step-40  中一样，在求解或使用解决方案时，我们需要在有和没有鬼魂元素的向量之间进行洗牌。

// 该函数的其余部分与 step-40 和 step-41 类似，只是我们使用BiCGStab求解器而不是CG。这是由于对于非常小的硬化参数 $\gamma$ ，线性系统变得几乎是半无限的，尽管仍然是对称的。BiCGStab似乎更容易处理这种线性系统。

  template <int dim> 
  void PlasticityContactProblem<dim>::solve_newton_system() 
  { 
    TimerOutput::Scope t(computing_timer, "Solve"); 

    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs, 
                                                       mpi_communicator); 
    distributed_solution = solution; 

    constraints_hanging_nodes.set_zero(distributed_solution); 
    constraints_hanging_nodes.set_zero(newton_rhs); 

 
    { 
      TimerOutput::Scope t(computing_timer, "Solve: setup preconditioner"); 

      std::vector<std::vector<bool>> constant_modes; 
      DoFTools::extract_constant_modes(dof_handler, 
                                       ComponentMask(), 
                                       constant_modes); 

      TrilinosWrappers::PreconditionAMG::AdditionalData additional_data; 
      additional_data.constant_modes        = constant_modes; 
      additional_data.elliptic              = true; 
      additional_data.n_cycles              = 1; 
      additional_data.w_cycle               = false; 
      additional_data.output_details        = false; 
      additional_data.smoother_sweeps       = 2; 
      additional_data.aggregation_threshold = 1e-2; 

      preconditioner.initialize(newton_matrix, additional_data); 
    } 

    { 
      TimerOutput::Scope t(computing_timer, "Solve: iterate"); 

      TrilinosWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator); 

      const double relative_accuracy = 1e-8; 
      const double solver_tolerance = 
        relative_accuracy * 
        newton_matrix.residual(tmp, distributed_solution, newton_rhs); 

      SolverControl solver_control(newton_matrix.m(), solver_tolerance); 
      SolverBicgstab<TrilinosWrappers::MPI::Vector> solver(solver_control); 
      solver.solve(newton_matrix, 
                   distributed_solution, 
                   newton_rhs, 
                   preconditioner); 

      pcout << "         Error: " << solver_control.initial_value() << " -> " 
            << solver_control.last_value() << " in " 
            << solver_control.last_step() << " Bicgstab iterations." 
            << std::endl; 
    } 

    all_constraints.distribute(distributed_solution); 

    solution = distributed_solution; 
  } 
// @sect4{PlasticityContactProblem::solve_newton}  

// 最后，这是在当前网格上实现阻尼牛顿方法的函数。这里有两个嵌套的循环：外循环用于牛顿迭代，内循环用于直线搜索，只有在必要时才会使用。为了获得一个好的和合理的起始值，我们在每个网格上的第一个牛顿步骤中解决一个弹性问题（如果我们在网格之间转移解决方案，则只在第一个网格上解决）。我们通过在这些迭代中将屈服应力设置为一个不合理的大值，然后在随后的迭代中将其设置为正确值。

// 除此以外，这个函数的顶部部分应该是相当明显的。我们将变量 <code>previous_residual_norm</code> 初始化为可以用双精度数字表示的最大负值，以便在第一步中比较当前残差是否小于前一步的残差时总是失败。

  template <int dim> 
  void PlasticityContactProblem<dim>::solve_newton() 
  { 
    TrilinosWrappers::MPI::Vector old_solution(locally_owned_dofs, 
                                               mpi_communicator); 
    TrilinosWrappers::MPI::Vector residual(locally_owned_dofs, 
                                           mpi_communicator); 
    TrilinosWrappers::MPI::Vector tmp_vector(locally_owned_dofs, 
                                             mpi_communicator); 
    TrilinosWrappers::MPI::Vector locally_relevant_tmp_vector( 
      locally_relevant_dofs, mpi_communicator); 
    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs, 
                                                       mpi_communicator); 

    double residual_norm; 
    double previous_residual_norm = -std::numeric_limits<double>::max(); 

    const double correct_sigma = sigma_0; 

    IndexSet old_active_set(active_set); 

    for (unsigned int newton_step = 1; newton_step <= 100; ++newton_step) 
      { 
        if (newton_step == 1 && 
            ((transfer_solution && current_refinement_cycle == 0) || 
             !transfer_solution)) 
          constitutive_law.set_sigma_0(1e+10); 
        else if (newton_step == 2 || current_refinement_cycle > 0 || 
                 !transfer_solution) 
          constitutive_law.set_sigma_0(correct_sigma); 

        pcout << " " << std::endl; 
        pcout << "   Newton iteration " << newton_step << std::endl; 
        pcout << "      Updating active set..." << std::endl; 

        { 
          TimerOutput::Scope t(computing_timer, "update active set"); 
          update_solution_and_constraints(); 
        } 

        pcout << "      Assembling system... " << std::endl; 
        newton_matrix = 0; 
        newton_rhs    = 0; 
        assemble_newton_system(solution); 

        pcout << "      Solving system... " << std::endl; 
        solve_newton_system(); 

// 在我们计算了当前牛顿步骤的试解 $\tilde{\mathbf u}$ 之后，情况就变得有点棘手了。我们处理的是一个高度非线性的问题，所以我们必须用直线搜索的方式来抑制牛顿方法。为了理解我们如何做到这一点，请回顾一下，在我们的表述中，我们在每一个牛顿步骤中计算一个试解，而不是在新旧解之间进行更新。由于解集是一个凸集，我们将使用直线搜索，尝试以前的解和试验解的线性组合，以保证阻尼解再次出现在我们的解集中。我们最多应用5个阻尼步骤。

// 在我们使用直线搜索的时候有一些例外情况。首先，如果这是任何网格上的第一个牛顿步骤，那么我们就没有任何点来比较残差，所以我们总是接受一个完整的步骤。同样地，如果这是第一个网格上的第二个牛顿步骤（如果我们不在网格之间转移解决方案，则是任何网格上的第二个牛顿步骤），则我们只用弹性模型计算了其中的第一个步骤（见上文我们如何将屈服应力σ设置为一个不合理的大值）。在这种情况下，第一个牛顿解是一个纯粹的弹性解，第二个牛顿解是一个塑性解，任何线性组合都不一定会位于可行的集合中--所以我们只是接受我们刚刚得到的解。

// 在这两种情况下，我们绕过直线搜索，只是在必要时更新残差和其他向量。

        if ((newton_step == 1) || 
            (transfer_solution && newton_step == 2 && 
             current_refinement_cycle == 0) || 
            (!transfer_solution && newton_step == 2)) 
          { 
            compute_nonlinear_residual(solution); 
            old_solution = solution; 

            residual                     = newton_rhs; 
            const unsigned int start_res = (residual.local_range().first), 
                               end_res   = (residual.local_range().second); 
            for (unsigned int n = start_res; n < end_res; ++n) 
              if (all_constraints.is_inhomogeneously_constrained(n)) 
                residual(n) = 0; 

            residual.compress(VectorOperation::insert); 

            residual_norm = residual.l2_norm(); 

            pcout << "      Accepting Newton solution with residual: " 
                  << residual_norm << std::endl; 
          } 
        else 
          { 
            for (unsigned int i = 0; i < 5; ++i) 
              { 
                distributed_solution = solution; 

                const double alpha = std::pow(0.5, static_cast<double>(i)); 
                tmp_vector         = old_solution; 
                tmp_vector.sadd(1 - alpha, alpha, distributed_solution); 

                TimerOutput::Scope t(computing_timer, "Residual and lambda"); 

                locally_relevant_tmp_vector = tmp_vector; 
                compute_nonlinear_residual(locally_relevant_tmp_vector); 
                residual = newton_rhs; 

                const unsigned int start_res = (residual.local_range().first), 
                                   end_res   = (residual.local_range().second); 
                for (unsigned int n = start_res; n < end_res; ++n) 
                  if (all_constraints.is_inhomogeneously_constrained(n)) 
                    residual(n) = 0; 

                residual.compress(VectorOperation::insert); 

                residual_norm = residual.l2_norm(); 

 
                  << "      Residual of the non-contact part of the system: " 
                  << residual_norm << std::endl 
                  << "         with a damping parameter alpha = " << alpha 
                  << std::endl; 

                if (residual_norm < previous_residual_norm) 
                  break; 
              } 

            solution     = tmp_vector; 
            old_solution = solution; 
          } 

        previous_residual_norm = residual_norm; 

// 最后一步是检查收敛情况。如果活动集在所有处理器中都没有变化，并且残差小于阈值 $10^{-10}$  ，那么我们就终止对当前网格的迭代。

        if (Utilities::MPI::sum((active_set == old_active_set) ? 0 : 1, 
                                mpi_communicator) == 0) 
          { 
            pcout << "      Active set did not change!" << std::endl; 
            if (residual_norm < 1e-10) 
              break; 
          } 

        old_active_set = active_set; 
      } 
  } 
// @sect4{PlasticityContactProblem::refine_grid}  

// 如果你已经在deal.II教程中做到了这一点，下面这个细化网格的函数应该不会再对你构成任何挑战。它对网格进行细化，可以是全局的，也可以是使用Kelly误差估计器的，如果这样要求的话，还可以将上一个网格的解转移到下一个网格。在后一种情况下，我们还需要再次计算活动集和其他数量，为此我们需要由  <code>compute_nonlinear_residual()</code>  计算的信息。

  template <int dim> 
  void PlasticityContactProblem<dim>::refine_grid() 
  { 
    if (refinement_strategy == RefinementStrategy::refine_global) 
      { 
        for (typename Triangulation<dim>::active_cell_iterator cell = 
               triangulation.begin_active(); 
             cell != triangulation.end(); 
             ++cell) 
          if (cell->is_locally_owned()) 
            cell->set_refine_flag(); 
      } 
    else 
      { 
        Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 
        KellyErrorEstimator<dim>::estimate( 
          dof_handler, 
          QGauss<dim - 1>(fe.degree + 2), 
          std::map<types::boundary_id, const Function<dim> *>(), 
          solution, 
          estimated_error_per_cell); 

        parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number( 
          triangulation, estimated_error_per_cell, 0.3, 0.03); 
      } 

    triangulation.prepare_coarsening_and_refinement(); 

    parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> 
      solution_transfer(dof_handler); 
    if (transfer_solution) 
      solution_transfer.prepare_for_coarsening_and_refinement(solution); 

    triangulation.execute_coarsening_and_refinement(); 

    setup_system(); 

    if (transfer_solution) 
      { 
        TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs, 
                                                           mpi_communicator); 
        solution_transfer.interpolate(distributed_solution); 

// 强制执行约束条件，使插值后的解决方案在新的网格上符合要求。

        constraints_hanging_nodes.distribute(distributed_solution); 

        solution = distributed_solution; 
        compute_nonlinear_residual(solution); 
      } 
  } 
// @sect4{PlasticityContactProblem::move_mesh}  

// 在我们到达 <code>run()</code> 之前的其余三个函数都与生成输出有关。下面一个是尝试显示变形体的变形构造。为此，这个函数接收一个位移矢量场，通过先前计算的位移来移动网格（局部）的每个顶点。在生成图形输出之前，我们将以当前的位移场调用该函数，在生成图形输出之后，我们将以负的位移场再次调用该函数，以撤销对网格所做的修改。

// 这个函数本身是非常简单的。我们所要做的就是跟踪我们已经接触过的顶点，因为我们在单元格上循环时多次遇到相同的顶点。

  template <int dim> 
  void PlasticityContactProblem<dim>::move_mesh( 
    const TrilinosWrappers::MPI::Vector &displacement) const 
  { 
    std::vector<bool> vertex_touched(triangulation.n_vertices(), false); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        for (const auto v : cell->vertex_indices()) 
          if (vertex_touched[cell->vertex_index(v)] == false) 
            { 
              vertex_touched[cell->vertex_index(v)] = true; 

              Point<dim> vertex_displacement; 
              for (unsigned int d = 0; d < dim; ++d) 
                vertex_displacement[d] = 
                  displacement(cell->vertex_dof_index(v, d)); 

              cell->vertex(v) += vertex_displacement; 
            } 
  } 

//  @sect4{PlasticityContactProblem::output_results}  

// 接下来是我们用来实际生成图形输出的函数。这个函数有点繁琐，但实际上并不特别复杂。它在顶部移动网格（最后再把它移回来），然后计算沿接触面的接触力。我们可以通过取未处理的残差向量，并通过询问它们是否有与之相关的不均匀约束来确定哪些自由度对应于有接触的自由度（如随文所示）。一如既往，我们需要注意的是，我们只能写进完全分布的向量（即没有鬼魂元素的向量），但当我们想产生输出时，我们需要的向量确实对所有局部相关的自由度都有鬼魂项。

  template <int dim> 
  void PlasticityContactProblem<dim>::output_results( 
    const unsigned int current_refinement_cycle) 
  { 
    TimerOutput::Scope t(computing_timer, "Graphical output"); 

    pcout << "      Writing graphical output... " << std::flush; 

    move_mesh(solution); 

// 接触力的计算

    TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs, 
                                                     mpi_communicator); 
    const unsigned int start_res = (newton_rhs_uncondensed.local_range().first), 
                       end_res = (newton_rhs_uncondensed.local_range().second); 
    for (unsigned int n = start_res; n < end_res; ++n) 
      if (all_constraints.is_inhomogeneously_constrained(n)) 
        distributed_lambda(n) = 
          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n); 
    distributed_lambda.compress(VectorOperation::insert); 
    constraints_hanging_nodes.distribute(distributed_lambda); 

    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs, 
                                         mpi_communicator); 
    lambda = distributed_lambda; 

    TrilinosWrappers::MPI::Vector distributed_active_set_vector( 
      locally_owned_dofs, mpi_communicator); 
    distributed_active_set_vector = 0.; 
    for (const auto index : active_set) 
      distributed_active_set_vector[index] = 1.; 
    distributed_lambda.compress(VectorOperation::insert); 

    TrilinosWrappers::MPI::Vector active_set_vector(locally_relevant_dofs, 
                                                    mpi_communicator); 
    active_set_vector = distributed_active_set_vector; 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 

    const std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_out.add_data_vector(solution, 
                             std::vector<std::string>(dim, "displacement"), 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.add_data_vector(lambda, 
                             std::vector<std::string>(dim, "contact_force"), 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.add_data_vector(active_set_vector, 
                             std::vector<std::string>(dim, "active_set"), 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 

    Vector<float> subdomain(triangulation.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      subdomain(i) = triangulation.locally_owned_subdomain(); 
    data_out.add_data_vector(subdomain, "subdomain"); 

    data_out.add_data_vector(fraction_of_plastic_q_points_per_cell, 
                             "fraction_of_plastic_q_points"); 

    data_out.build_patches(); 

// 在函数的其余部分，我们在每个处理器上生成一个VTU文件，以这个处理器的子域ID为索引。在第一个处理器上，我们随后还创建了一个 <code>.pvtu</code> 文件，对VTU文件的<i>all</i>进行索引，这样就可以一次性读取整个输出文件集。这些 <code>.pvtu</code> 被Paraview用来描述整个并行计算的输出文件。然后我们再为Paraview的竞争者--VisIt可视化程序做同样的事情，创建一个匹配的 <code>.visit</code> 文件。

    const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record( 
      output_dir, "solution", current_refinement_cycle, mpi_communicator, 2); 
    pcout << pvtu_filename << std::endl; 

    TrilinosWrappers::MPI::Vector tmp(solution); 
    tmp *= -1; 
    move_mesh(tmp); 
  } 
// @sect4{PlasticityContactProblem::output_contact_force}  

// 这最后一个辅助函数通过计算接触面积上Z方向的接触压力的积分来计算接触力。为此，我们将所有非活动因子的接触压力lambda设置为0（一个自由度是否是接触的一部分，就像我们在前一个函数中做的那样）。对于所有活动的自由度，lambda包含非线性残差（newton_rhs_uncondensed）和质量矩阵（diag_mass_matrix_vector）的相应对角线条目的商数。因为悬空节点出现在接触区的可能性不小，所以对分布式_lambda向量应用constraints_hanging_nodes.distribution是很重要的。

  template <int dim> 
  void PlasticityContactProblem<dim>::output_contact_force() const 
  { 
    TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs, 
                                                     mpi_communicator); 
    const unsigned int start_res = (newton_rhs_uncondensed.local_range().first), 
                       end_res = (newton_rhs_uncondensed.local_range().second); 
    for (unsigned int n = start_res; n < end_res; ++n) 
      if (all_constraints.is_inhomogeneously_constrained(n)) 
        distributed_lambda(n) = 
          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n); 
      else 
        distributed_lambda(n) = 0; 
    distributed_lambda.compress(VectorOperation::insert); 
    constraints_hanging_nodes.distribute(distributed_lambda); 

    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs, 
                                         mpi_communicator); 
    lambda = distributed_lambda; 

    double contact_force = 0.0; 

    QGauss<dim - 1>   face_quadrature_formula(fe.degree + 1); 
    FEFaceValues<dim> fe_values_face(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_JxW_values); 

    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    const FEValuesExtractors::Vector displacement(0); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary() && face->boundary_id() == 1) 
            { 
              fe_values_face.reinit(cell, face); 

              std::vector<Tensor<1, dim>> lambda_values(n_face_q_points); 
              fe_values_face[displacement].get_function_values(lambda, 
                                                               lambda_values); 

              for (unsigned int q_point = 0; q_point < n_face_q_points; 
                   ++q_point) 
                contact_force += 
                  lambda_values[q_point][2] * fe_values_face.JxW(q_point); 
            } 
    contact_force = Utilities::MPI::sum(contact_force, MPI_COMM_WORLD); 

    pcout << "Contact force = " << contact_force << std::endl; 
  } 
// @sect4{PlasticityContactProblem::run}  

// 和其他所有的教程程序一样， <code>run()</code> 函数包含了整体逻辑。这里没有太多的内容：本质上，它在所有的网格细化循环中执行循环，并在每个循环中，将事情交给 <code>solve_newton()</code> 中的牛顿求解器，并调用函数来创建如此计算的解决方案的图形输出。然后输出一些关于运行时间和内存消耗的统计数据，这些数据是在这个网格的计算过程中收集的。

  template <int dim> 
  void PlasticityContactProblem<dim>::run() 
  { 
    computing_timer.reset(); 
    for (; current_refinement_cycle < n_refinement_cycles; 
         ++current_refinement_cycle) 
      { 
        { 
          TimerOutput::Scope t(computing_timer, "Setup"); 

          pcout << std::endl; 
          pcout << "Cycle " << current_refinement_cycle << ':' << std::endl; 

          if (current_refinement_cycle == 0) 
            { 
              make_grid(); 
              setup_system(); 
            } 
          else 
            { 
              TimerOutput::Scope t(computing_timer, "Setup: refine mesh"); 
              refine_grid(); 
            } 
        } 

        solve_newton(); 

        output_results(current_refinement_cycle); 

        computing_timer.print_summary(); 
        computing_timer.reset(); 

        Utilities::System::MemoryStats stats; 
        Utilities::System::get_memory_stats(stats); 
        pcout << "Peak virtual memory used, resident in kB: " << stats.VmSize 
              << " " << stats.VmRSS << std::endl; 

        if (base_mesh == "box") 
          output_contact_force(); 
      } 
  } 
} // namespace Step42 
// @sect3{The <code>main</code> function}  

//  <code>main()</code> 函数真的没有什么内容。看起来他们总是这样做。

int main(int argc, char *argv[]) 
{ 
  using namespace dealii; 
  using namespace Step42; 

  try 
    { 
      ParameterHandler prm; 
      PlasticityContactProblem<3>::declare_parameters(prm); 
      if (argc != 2) 
        { 
          std::cerr << "*** Call this program as <./step-42 input.prm>" 
                    << std::endl; 
          return 1; 
        } 

      prm.parse_input(argv[1]); 
      Utilities::MPI::MPI_InitFinalize mpi_initialization( 
        argc, argv, numbers::invalid_unsigned_int); 
      { 
        PlasticityContactProblem<3> problem(prm); 
        problem.run(); 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-43.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2010 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Chih-Che Chueh, University of Victoria, 2010 
 *          Wolfgang Bangerth, Texas A&M University, 2010 
 */ 


// @sect3{Include files}  

// 像往常一样，第一步是包括一些deal.II和C++头文件的功能。

// 列表中包括一些提供向量、矩阵和预处理类的头文件，这些头文件实现了各自Trilinos类的接口；关于这些的一些更多信息可以在  step-31  中找到。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/tensor_function.h> 
#include <deal.II/base/index_set.h> 

#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/block_sparsity_pattern.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/solution_transfer.h> 

#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/trilinos_block_sparse_matrix.h> 
#include <deal.II/lac/trilinos_vector.h> 
#include <deal.II/lac/trilinos_parallel_block_vector.h> 
#include <deal.II/lac/trilinos_precondition.h> 

#include <iostream> 
#include <fstream> 
#include <memory> 

// 在这个顶层设计的最后，我们为当前项目开辟一个命名空间，下面的所有材料都将进入这个命名空间，然后将所有deal.II名称导入这个命名空间。

namespace Step43 
{ 
  using namespace dealii; 
// @sect3{Boundary and initial value classes}  

// 下面的部分直接取自 step-21 ，所以没有必要重复那里的描述。

  template <int dim> 
  class PressureBoundaryValues : public Function<dim> 
  { 
  public: 
    PressureBoundaryValues() 
      : Function<dim>(1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double 
  PressureBoundaryValues<dim>::value(const Point<dim> &p, 
                                     const unsigned int /*component*/) const 
  { 
    return 1 - p[0]; 
  } 

  template <int dim> 
  class SaturationBoundaryValues : public Function<dim> 
  { 
  public: 
    SaturationBoundaryValues() 
      : Function<dim>(1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double 
  SaturationBoundaryValues<dim>::value(const Point<dim> &p, 
                                       const unsigned int /*component*/) const 
  { 
    if (p[0] == 0) 
      return 1; 
    else 
      return 0; 
  } 

  template <int dim> 
  class SaturationInitialValues : public Function<dim> 
  { 
  public: 
    SaturationInitialValues() 
      : Function<dim>(1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  double 
  SaturationInitialValues<dim>::value(const Point<dim> & /*p*/, 
                                      const unsigned int /*component*/) const 
  { 
    return 0.2; 
  } 

  template <int dim> 
  void SaturationInitialValues<dim>::vector_value(const Point<dim> &p, 
                                                  Vector<double> &values) const 
  { 
    for (unsigned int c = 0; c < this->n_components; ++c) 
      values(c) = SaturationInitialValues<dim>::value(p, c); 
  } 
// @sect3{Permeability models}  

// 在本教程中，我们仍然使用之前在 step-21 中使用的两个渗透率模型，所以我们再次避免对它们进行详细评论。

  namespace SingleCurvingCrack 
  { 
    template <int dim> 
    class KInverse : public TensorFunction<2, dim> 
    { 
    public: 
      KInverse() 
        : TensorFunction<2, dim>() 
      {} 

      virtual void 
      value_list(const std::vector<Point<dim>> &points, 
                 std::vector<Tensor<2, dim>> &  values) const override; 
    }; 

    template <int dim> 
    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points, 
                                   std::vector<Tensor<2, dim>> &  values) const 
    { 
      Assert(points.size() == values.size(), 
             ExcDimensionMismatch(points.size(), values.size())); 

      for (unsigned int p = 0; p < points.size(); ++p) 
        { 
          values[p].clear(); 

          const double distance_to_flowline = 
            std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0])); 

          const double permeability = 
            std::max(std::exp(-(distance_to_flowline * distance_to_flowline) / 
                              (0.1 * 0.1)), 
                     0.01); 

          for (unsigned int d = 0; d < dim; ++d) 
            values[p][d][d] = 1. / permeability; 
        } 
    } 
  } // namespace SingleCurvingCrack 

  namespace RandomMedium 
  { 
    template <int dim> 
    class KInverse : public TensorFunction<2, dim> 
    { 
    public: 
      KInverse() 
        : TensorFunction<2, dim>() 
      {} 

      virtual void 
      value_list(const std::vector<Point<dim>> &points, 
                 std::vector<Tensor<2, dim>> &  values) const override; 

    private: 
      static std::vector<Point<dim>> centers; 
    }; 

    template <int dim> 
    std::vector<Point<dim>> KInverse<dim>::centers = []() { 
      const unsigned int N = 
        (dim == 2 ? 40 : (dim == 3 ? 100 : throw ExcNotImplemented())); 

      std::vector<Point<dim>> centers_list(N); 
      for (unsigned int i = 0; i < N; ++i) 
        for (unsigned int d = 0; d < dim; ++d) 
          centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX; 

      return centers_list; 
    }(); 

    template <int dim> 
    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points, 
                                   std::vector<Tensor<2, dim>> &  values) const 
    { 
      AssertDimension(points.size(), values.size()); 

      for (unsigned int p = 0; p < points.size(); ++p) 
        { 
          values[p].clear(); 

          double permeability = 0; 
          for (unsigned int i = 0; i < centers.size(); ++i) 
            permeability += 
              std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05)); 

          const double normalized_permeability = 
            std::min(std::max(permeability, 0.01), 4.); 

          for (unsigned int d = 0; d < dim; ++d) 
            values[p][d][d] = 1. / normalized_permeability; 
        } 
    } 
  } // namespace RandomMedium 
// @sect3{Physical quantities}  

// 所有物理量的实现，如总流动性 $\lambda_t$ 和水的部分流量 $F$ 都来自 step-21 ，所以我们也没有对它们做任何评论。与 step-21 相比，我们增加了检查，即传递给这些函数的饱和度实际上是在物理上有效的范围内。此外，鉴于润湿相以速度 $\mathbf u F'(S)$ 移动，很明显 $F'(S)$ 必须大于或等于零，所以我们也断言，以确保我们的计算得到的导数公式是合理的。

  double mobility_inverse(const double S, const double viscosity) 
  { 
    return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S)); 
  } 

  double fractional_flow(const double S, const double viscosity) 
  { 
    Assert((S >= 0) && (S <= 1), 
           ExcMessage("Saturation is outside its physically valid range.")); 

    return S * S / (S * S + viscosity * (1 - S) * (1 - S)); 
  } 

  double fractional_flow_derivative(const double S, const double viscosity) 
  { 
    Assert((S >= 0) && (S <= 1), 
           ExcMessage("Saturation is outside its physically valid range.")); 

    const double temp = (S * S + viscosity * (1 - S) * (1 - S)); 

    const double numerator = 
      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S)); 
    const double denominator = std::pow(temp, 2.0); 

    const double F_prime = numerator / denominator; 

    Assert(F_prime >= 0, ExcInternalError()); 

    return F_prime; 
  } 
// @sect3{Helper classes for solvers and preconditioners}  

// 在这第一部分中，我们定义了一些我们在构建线性求解器和预处理器时需要的类。这一部分与  step-31  中使用的基本相同。唯一不同的是，原来的变量名称stokes_matrix被另一个名称darcy_matrix取代，以配合我们的问题。

  namespace LinearSolvers 
  { 
    template <class MatrixType, class PreconditionerType> 
    class InverseMatrix : public Subscriptor 
    { 
    public: 
      InverseMatrix(const MatrixType &        m, 
                    const PreconditionerType &preconditioner); 

      template <typename VectorType> 
      void vmult(VectorType &dst, const VectorType &src) const; 

    private: 
      const SmartPointer<const MatrixType> matrix; 
      const PreconditionerType &           preconditioner; 
    }; 

    template <class MatrixType, class PreconditionerType> 
    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix( 
      const MatrixType &        m, 
      const PreconditionerType &preconditioner) 
      : matrix(&m) 
      , preconditioner(preconditioner) 
    {} 

    template <class MatrixType, class PreconditionerType> 
    template <typename VectorType> 
    void InverseMatrix<MatrixType, PreconditionerType>::vmult( 
      VectorType &      dst, 
      const VectorType &src) const 
    { 
      SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm()); 
      SolverCG<VectorType> cg(solver_control); 

      dst = 0; 

      try 
        { 
          cg.solve(*matrix, dst, src, preconditioner); 
        } 
      catch (std::exception &e) 
        { 
          Assert(false, ExcMessage(e.what())); 
        } 
    } 

    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    class BlockSchurPreconditioner : public Subscriptor 
    { 
    public: 
      BlockSchurPreconditioner( 
        const TrilinosWrappers::BlockSparseMatrix &S, 
        const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                            PreconditionerTypeMp> &Mpinv, 
        const PreconditionerTypeA &                Apreconditioner); 

      void vmult(TrilinosWrappers::MPI::BlockVector &      dst, 
                 const TrilinosWrappers::MPI::BlockVector &src) const; 

    private: 
      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> 
        darcy_matrix; 
      const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                                             PreconditionerTypeMp>> 
                                 m_inverse; 
      const PreconditionerTypeA &a_preconditioner; 

      mutable TrilinosWrappers::MPI::Vector tmp; 
    }; 

    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>:: 
      BlockSchurPreconditioner( 
        const TrilinosWrappers::BlockSparseMatrix &S, 
        const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                            PreconditionerTypeMp> &Mpinv, 
        const PreconditionerTypeA &                Apreconditioner) 
      : darcy_matrix(&S) 
      , m_inverse(&Mpinv) 
      , a_preconditioner(Apreconditioner) 
      , tmp(complete_index_set(darcy_matrix->block(1, 1).m())) 
    {} 

    template <class PreconditionerTypeA, class PreconditionerTypeMp> 
    void 
    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult( 
      TrilinosWrappers::MPI::BlockVector &      dst, 
      const TrilinosWrappers::MPI::BlockVector &src) const 
    { 
      a_preconditioner.vmult(dst.block(0), src.block(0)); 
      darcy_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1)); 
      tmp *= -1; 
      m_inverse->vmult(dst.block(1), tmp); 
    } 
  } // namespace LinearSolvers 
// @sect3{The TwoPhaseFlowProblem class}  

// 定义解决随时间变化的平流主导的两相流问题（或Buckley-Leverett问题[Buckley 1942]）的顶层逻辑的类的定义主要基于教程程序 step-21 和 step-33 ，特别是 step-31 ，我们在这里使用的一般结构基本相同。与 step-31 一样，在下面的实现中需要寻找的关键例程是 <code>run()</code> and <code>solve()</code> 函数。

// 与 step-31 的主要区别是，由于考虑了自适应算子拆分，我们需要多几个成员变量来保存最近两次计算的达西（速度/压力）解，以及当前的达西（直接计算，或从前两次计算中推断），我们需要记住最近两次计算的达西解。我们还需要一个辅助函数来确定我们是否真的需要重新计算达西解。

// 与 step-31 不同，这一步多用了一个AffineConstraints对象，叫做darcy_preconditioner_constraints。这个约束对象只用于为Darcy预处理程序组装矩阵，包括悬挂节点约束以及压力变量的Dirichlet边界值约束。我们需要这个，因为我们正在为压力建立一个拉普拉斯矩阵，作为舒尔补码的近似值），如果应用边界条件，这个矩阵是正定的。

// 这样在这个类中声明的成员函数和变量的集合与  step-31  中的相当相似。

  template <int dim> 
  class TwoPhaseFlowProblem 
  { 
  public: 
    TwoPhaseFlowProblem(const unsigned int degree); 
    void run(); 

  private: 
    void setup_dofs(); 
    void assemble_darcy_preconditioner(); 
    void build_darcy_preconditioner(); 
    void assemble_darcy_system(); 
    void assemble_saturation_system(); 
    void assemble_saturation_matrix(); 
    void assemble_saturation_rhs(); 
    void assemble_saturation_rhs_cell_term( 
      const FEValues<dim> &                       saturation_fe_values, 
      const FEValues<dim> &                       darcy_fe_values, 
      const double                                global_max_u_F_prime, 
      const double                                global_S_variation, 
      const std::vector<types::global_dof_index> &local_dof_indices); 
    void assemble_saturation_rhs_boundary_term( 
      const FEFaceValues<dim> &                   saturation_fe_face_values, 
      const FEFaceValues<dim> &                   darcy_fe_face_values, 
      const std::vector<types::global_dof_index> &local_dof_indices); 
    void solve(); 
    void refine_mesh(const unsigned int min_grid_level, 
                     const unsigned int max_grid_level); 
    void output_results() const; 

// 我们接下来会有一些辅助函数，这些函数在整个程序中的不同地方都会用到。

    double                    get_max_u_F_prime() const; 
    std::pair<double, double> get_extrapolated_saturation_range() const; 
    bool   determine_whether_to_solve_for_pressure_and_velocity() const; 
    void   project_back_saturation(); 
    double compute_viscosity( 
      const std::vector<double> &        old_saturation, 
      const std::vector<double> &        old_old_saturation, 
      const std::vector<Tensor<1, dim>> &old_saturation_grads, 
      const std::vector<Tensor<1, dim>> &old_old_saturation_grads, 
      const std::vector<Vector<double>> &present_darcy_values, 
      const double                       global_max_u_F_prime, 
      const double                       global_S_variation, 
      const double                       cell_diameter) const; 

// 接下来是成员变量，其中大部分与 step-31 中的变量类似，但与速度/压力系统的宏观时间步长有关的变量除外。

    Triangulation<dim> triangulation; 
    double             global_Omega_diameter; 

    const unsigned int degree; 

    const unsigned int        darcy_degree; 
    FESystem<dim>             darcy_fe; 
    DoFHandler<dim>           darcy_dof_handler; 
    AffineConstraints<double> darcy_constraints; 

    AffineConstraints<double> darcy_preconditioner_constraints; 

    TrilinosWrappers::BlockSparseMatrix darcy_matrix; 
    TrilinosWrappers::BlockSparseMatrix darcy_preconditioner_matrix; 

    TrilinosWrappers::MPI::BlockVector darcy_solution; 
    TrilinosWrappers::MPI::BlockVector darcy_rhs; 

    TrilinosWrappers::MPI::BlockVector last_computed_darcy_solution; 
    TrilinosWrappers::MPI::BlockVector second_last_computed_darcy_solution; 

    const unsigned int        saturation_degree; 
    FE_Q<dim>                 saturation_fe; 
    DoFHandler<dim>           saturation_dof_handler; 
    AffineConstraints<double> saturation_constraints; 

    TrilinosWrappers::SparseMatrix saturation_matrix; 

    TrilinosWrappers::MPI::Vector saturation_solution; 
    TrilinosWrappers::MPI::Vector old_saturation_solution; 
    TrilinosWrappers::MPI::Vector old_old_saturation_solution; 
    TrilinosWrappers::MPI::Vector saturation_rhs; 

    TrilinosWrappers::MPI::Vector 
      saturation_matching_last_computed_darcy_solution; 

    const double saturation_refinement_threshold; 

    double       time; 
    const double end_time; 

    double current_macro_time_step; 
    double old_macro_time_step; 

    double       time_step; 
    double       old_time_step; 
    unsigned int timestep_number; 

    const double viscosity; 
    const double porosity; 
    const double AOS_threshold; 

    std::shared_ptr<TrilinosWrappers::PreconditionIC> Amg_preconditioner; 
    std::shared_ptr<TrilinosWrappers::PreconditionIC> Mp_preconditioner; 

    bool rebuild_saturation_matrix; 

// 在最后，我们声明一个变量，表示材料模型。与 step-21 相比，我们在这里把它作为一个成员变量，因为我们想在不同的地方使用它，所以有一个声明这样一个变量的中心位置，将使我们更容易用另一个类来替换 RandomMedium::KInverse （例如，用 SingleCurvingCrack::KInverse). 替换 RandomMedium::KInverse ）。
    const RandomMedium::KInverse<dim> k_inverse; 
  }; 
// @sect3{TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem}  

// 这个类的构造函数是对  step-21  和  step-31  中的构造函数的扩展。我们需要添加涉及饱和度的各种变量。正如介绍中所讨论的，我们将再次使用 $Q_2 \times Q_1$ （Taylor-Hood）元素来处理Darcy系统，这是一个满足Ladyzhenskaya-Babuska-Brezzi（LBB）条件的元素组合[Brezzi and Fortin 1991, Chen 2005]，并使用 $Q_1$ 元素处理饱和度。然而，通过使用存储Darcy和温度有限元的多项式程度的变量，可以很容易地持续修改这些元素的程度以及在其上使用的所有正交公式的下游。此外，我们还初始化了与算子分割有关的时间步进变量，以及矩阵装配和预处理的选项。

  template <int dim> 
  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree) 
    : triangulation(Triangulation<dim>::maximum_smoothing) 
    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN()) 
    , degree(degree) 
    , darcy_degree(degree) 
    , darcy_fe(FE_Q<dim>(darcy_degree + 1), dim, FE_Q<dim>(darcy_degree), 1) 
    , darcy_dof_handler(triangulation) 
    , 

    saturation_degree(degree + 1) 
    , saturation_fe(saturation_degree) 
    , saturation_dof_handler(triangulation) 
    , 

    saturation_refinement_threshold(0.5) 
    , 

    time(0) 
    , end_time(10) 
    , 

    current_macro_time_step(0) 
    , old_macro_time_step(0) 
    , 

    time_step(0) 
    , old_time_step(0) 
    , timestep_number(0) 
    , viscosity(0.2) 
    , porosity(1.0) 
    , AOS_threshold(3.0) 
    , 

    rebuild_saturation_matrix(true) 
  {} 
// @sect3{TwoPhaseFlowProblem<dim>::setup_dofs}  

// 这个函数设置了我们这里的DoFHandler对象（一个用于Darcy部分，一个用于饱和部分），以及将本程序中线性代数所需的各种对象设置为合适的尺寸。其基本操作与 step-31 所做的类似。

// 该函数的主体首先列举了达西和饱和系统的所有自由度。对于Darcy部分，自由度会被排序，以确保速度优先于压力DoF，这样我们就可以将Darcy矩阵划分为一个 $2 \times 2$ 矩阵。
//然后，
//我们需要将悬挂节点约束和Dirichlet边界值约束纳入 darcy_preconditioner_constraints。 边界条件约束只设置在压力分量上，因为对应于非混合形式的多孔介质流算子的Schur complement预处理程序 $-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla$  ，只作用于压力变量。因此，我们使用一个过滤掉速度分量的分量掩码，这样就可以只对压力自由度进行缩减。

// 做完这些后，我们计算各个块中的自由度数量。然后，这些信息被用来创建达西和饱和系统矩阵的稀疏模式，以及用于建立达西预处理的预处理矩阵。如同 step-31 ，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。因此，对于这一点，我们遵循与 step-31 相同的方式，对于成员函数的其他部分，我们不必再重复描述。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::setup_dofs() 
  { 
    std::vector<unsigned int> darcy_block_component(dim + 1, 0); 
    darcy_block_component[dim] = 1; 
    { 
      darcy_dof_handler.distribute_dofs(darcy_fe); 
      DoFRenumbering::Cuthill_McKee(darcy_dof_handler); 
      DoFRenumbering::component_wise(darcy_dof_handler, darcy_block_component); 

      darcy_constraints.clear(); 
      DoFTools::make_hanging_node_constraints(darcy_dof_handler, 
                                              darcy_constraints); 
      darcy_constraints.close(); 
    } 
    { 
      saturation_dof_handler.distribute_dofs(saturation_fe); 

      saturation_constraints.clear(); 
      DoFTools::make_hanging_node_constraints(saturation_dof_handler, 
                                              saturation_constraints); 
      saturation_constraints.close(); 
    } 
    { 
      darcy_preconditioner_constraints.clear(); 

      FEValuesExtractors::Scalar pressure(dim); 

      DoFTools::make_hanging_node_constraints(darcy_dof_handler, 
                                              darcy_preconditioner_constraints); 
      DoFTools::make_zero_boundary_constraints(darcy_dof_handler, 
                                               darcy_preconditioner_constraints, 
                                               darcy_fe.component_mask( 
                                                 pressure)); 

      darcy_preconditioner_constraints.close(); 
    } 

    const std::vector<types::global_dof_index> darcy_dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(darcy_dof_handler, 
                                        darcy_block_component); 
    const unsigned int n_u = darcy_dofs_per_block[0], 
                       n_p = darcy_dofs_per_block[1], 
                       n_s = saturation_dof_handler.n_dofs(); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << " (on " << triangulation.n_levels() << " levels)" << std::endl 
              << "Number of degrees of freedom: " << n_u + n_p + n_s << " (" 
              << n_u << '+' << n_p << '+' << n_s << ')' << std::endl 
              << std::endl; 

    { 
      darcy_matrix.clear(); 

      BlockDynamicSparsityPattern dsp(2, 2); 

      dsp.block(0, 0).reinit(n_u, n_u); 
      dsp.block(0, 1).reinit(n_u, n_p); 
      dsp.block(1, 0).reinit(n_p, n_u); 
      dsp.block(1, 1).reinit(n_p, n_p); 

      dsp.collect_sizes(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 

      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (!((c == dim) && (d == dim))) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern( 
        darcy_dof_handler, coupling, dsp, darcy_constraints, false); 

      darcy_matrix.reinit(dsp); 
    } 

    { 
      Amg_preconditioner.reset(); 
      Mp_preconditioner.reset(); 
      darcy_preconditioner_matrix.clear(); 

      BlockDynamicSparsityPattern dsp(2, 2); 

      dsp.block(0, 0).reinit(n_u, n_u); 
      dsp.block(0, 1).reinit(n_u, n_p); 
      dsp.block(1, 0).reinit(n_p, n_u); 
      dsp.block(1, 1).reinit(n_p, n_p); 

      dsp.collect_sizes(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (c == d) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern( 
        darcy_dof_handler, coupling, dsp, darcy_constraints, false); 

      darcy_preconditioner_matrix.reinit(dsp); 
    } 

    { 
      saturation_matrix.clear(); 

      DynamicSparsityPattern dsp(n_s, n_s); 

      DoFTools::make_sparsity_pattern(saturation_dof_handler, 
                                      dsp, 
                                      saturation_constraints, 
                                      false); 

      saturation_matrix.reinit(dsp); 
    } 

    std::vector<IndexSet> darcy_partitioning(2); 
    darcy_partitioning[0] = complete_index_set(n_u); 
    darcy_partitioning[1] = complete_index_set(n_p); 
    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD); 
    darcy_solution.collect_sizes(); 

    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD); 
    last_computed_darcy_solution.collect_sizes(); 

    second_last_computed_darcy_solution.reinit(darcy_partitioning, 
                                               MPI_COMM_WORLD); 
    second_last_computed_darcy_solution.collect_sizes(); 

    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD); 
    darcy_rhs.collect_sizes(); 

    IndexSet saturation_partitioning = complete_index_set(n_s); 
    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD); 
    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD); 
    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD); 

    saturation_matching_last_computed_darcy_solution.reinit( 
      saturation_partitioning, MPI_COMM_WORLD); 

    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD); 
  } 
// @sect3{Assembling matrices and preconditioners}  

// 接下来的几个函数专门用来设置我们在这个程序中必须处理的各种系统和预处理矩阵及右手边。

//  @sect4{TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner}  

// 这个函数组装我们用于预处理达西系统的矩阵。我们需要的是在速度分量上用 $\left(\mathbf{K} \lambda_t\right)^{-1}$ 加权的向量质量矩阵和在压力分量上用 $\left(\mathbf{K} \lambda_t\right)$ 加权的质量矩阵。我们首先生成一个适当阶数的正交对象，即FEValues对象，可以给出正交点的数值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量phi_u和grad_phi_p将保存基函数的值，以便更快地建立局部矩阵，正如在  step-22  中已经做的。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。

// 局部矩阵的创建是相当简单的。只有一个由 $\left(\mathbf{K} \lambda_t\right)^{-1}$ 加权的项（关于速度）和一个由 $\left(\mathbf{K} \lambda_t\right)$ 加权的拉普拉斯矩阵需要生成，所以局部矩阵的创建基本上只需要两行就可以完成。由于该文件顶部的材料模型函数只提供了渗透率和迁移率的倒数，我们必须根据给定的数值手工计算 $\mathbf K$ 和 $\lambda_t$ ，每个正交点一次。

// 一旦本地矩阵准备好了（在每个正交点上对本地矩阵的行和列进行循环），我们就可以得到本地的DoF指数，并将本地信息写入全局矩阵中。我们通过直接应用约束条件（即darcy_preconditioner_constraints）来做到这一点，该约束条件负责处理悬挂节点和零Dirichlet边界条件约束。这样做，我们就不必事后再做，以后也不必使用 AffineConstraints::condense 和 MatrixTools::apply_boundary_values, 这两个需要修改矩阵和向量项的函数，因此对于我们不能立即访问单个内存位置的特里诺斯类来说，很难编写。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner() 
  { 
    std::cout << "   Rebuilding darcy preconditioner..." << std::endl; 

    darcy_preconditioner_matrix = 0; 

    const QGauss<dim> quadrature_formula(darcy_degree + 2); 
    FEValues<dim>     darcy_fe_values(darcy_fe, 
                                  quadrature_formula, 
                                  update_JxW_values | update_values | 
                                    update_gradients | 
                                    update_quadrature_points); 
    FEValues<dim>     saturation_fe_values(saturation_fe, 
                                       quadrature_formula, 
                                       update_values); 

    const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points); 

    std::vector<double> old_saturation_values(n_q_points); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell); 
    std::vector<Tensor<1, dim>> grad_phi_p(dofs_per_cell); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    auto       cell            = darcy_dof_handler.begin_active(); 
    const auto endc            = darcy_dof_handler.end(); 
    auto       saturation_cell = saturation_dof_handler.begin_active(); 

    for (; cell != endc; ++cell, ++saturation_cell) 
      { 
        darcy_fe_values.reinit(cell); 
        saturation_fe_values.reinit(saturation_cell); 

        local_matrix = 0; 

        saturation_fe_values.get_function_values(old_saturation_solution, 
                                                 old_saturation_values); 

        k_inverse.value_list(darcy_fe_values.get_quadrature_points(), 
                             k_inverse_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double old_s = old_saturation_values[q]; 

            const double inverse_mobility = mobility_inverse(old_s, viscosity); 
            const double mobility         = 1.0 / inverse_mobility; 
            const Tensor<2, dim> permeability = invert(k_inverse_values[q]); 

            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                phi_u[k]      = darcy_fe_values[velocities].value(k, q); 
                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q); 
              } 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  local_matrix(i, j) += 
                    (k_inverse_values[q] * inverse_mobility * phi_u[i] * 
                       phi_u[j] + 
                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) * 
                    darcy_fe_values.JxW(q); 
                } 
          } 

        cell->get_dof_indices(local_dof_indices); 
        darcy_preconditioner_constraints.distribute_local_to_global( 
          local_matrix, local_dof_indices, darcy_preconditioner_matrix); 
      } 
  } 
// @sect4{TwoPhaseFlowProblem<dim>::build_darcy_preconditioner}  

// 在调用上述函数组装预处理矩阵后，该函数生成将用于舒尔补块预处理的内部预处理器。前置条件需要在每个饱和时间步长时重新生成，因为它们取决于随时间变化的饱和度  $S$  。

// 在这里，我们为速度-速度矩阵  $\mathbf{M}^{\mathbf{u}}$  和Schur补码  $\mathbf{S}$  设置了预处理器。正如介绍中所解释的，我们将使用一个基于矢量矩阵 $\mathbf{M}^{\mathbf{u}}$ 的IC预处理器和另一个基于标量拉普拉斯矩阵 $\tilde{\mathbf{S}}^p$ 的IC预处理器（它在频谱上与达西矩阵的舒尔补码接近）。通常， TrilinosWrappers::PreconditionIC 类可以被看作是一个很好的黑盒预处理程序，不需要对矩阵结构和/或背后的算子有任何特殊的了解。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::build_darcy_preconditioner() 
  { 
    assemble_darcy_preconditioner(); 

    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>(); 
    Amg_preconditioner->initialize(darcy_preconditioner_matrix.block(0, 0)); 

    Mp_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>(); 
    Mp_preconditioner->initialize(darcy_preconditioner_matrix.block(1, 1)); 
  } 
// @sect4{TwoPhaseFlowProblem<dim>::assemble_darcy_system}  

// 这是为达西系统组装线性系统的函数。

// 关于执行的技术细节，其程序与  step-22  和  step-31  中的程序相似。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。

// 有一件事需要评论：由于我们有一个单独的有限元和DoFHandler来处理饱和问题，我们需要生成第二个FEValues对象来正确评估饱和解。要实现这一点并不复杂：只需使用饱和结构，并为基函数值设置一个更新标志，我们需要对饱和解进行评估。这里需要记住的唯一重要部分是，两个FEValues对象使用相同的正交公式，以确保我们在循环计算两个对象的正交点时获得匹配的信息。

// 声明的过程中，对数组的大小、本地矩阵的创建、右手边以及与全局系统相比较的本地道夫指数的向量都有一些快捷方式。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_darcy_system() 
  { 
    darcy_matrix = 0; 
    darcy_rhs    = 0; 

    QGauss<dim>     quadrature_formula(darcy_degree + 2); 
    QGauss<dim - 1> face_quadrature_formula(darcy_degree + 2); 

    FEValues<dim> darcy_fe_values(darcy_fe, 
                                  quadrature_formula, 
                                  update_values | update_gradients | 
                                    update_quadrature_points | 
                                    update_JxW_values); 

    FEValues<dim> saturation_fe_values(saturation_fe, 
                                       quadrature_formula, 
                                       update_values); 

    FEFaceValues<dim> darcy_fe_face_values(darcy_fe, 
                                           face_quadrature_formula, 
                                           update_values | 
                                             update_normal_vectors | 
                                             update_quadrature_points | 
                                             update_JxW_values); 

    const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell(); 

    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const Functions::ZeroFunction<dim> pressure_right_hand_side; 
    const PressureBoundaryValues<dim>  pressure_boundary_values; 

    std::vector<double>         pressure_rhs_values(n_q_points); 
    std::vector<double>         boundary_values(n_face_q_points); 
    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points); 

// 接下来我们需要一个向量，该向量将包含前一时间层在正交点的饱和解的值，以组装达西方程中的饱和相关系数。

// 我们接下来创建的向量集包含了基函数的评价以及它们的梯度，将用于创建矩阵。把这些放到自己的数组中，而不是每次都向FEValues对象索取这些信息，是为了加速装配过程的优化，详情请见 step-22 。

// 最后两个声明是用来从整个FE系统中提取各个块（速度、压力、饱和度）的。

    std::vector<double> old_saturation_values(n_q_points); 

    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell); 
    std::vector<double>         div_phi_u(dofs_per_cell); 
    std::vector<double>         phi_p(dofs_per_cell); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

// 现在开始对问题中的所有单元格进行循环。我们在这个装配例程中使用了两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，但是由于达西系统和饱和系统都使用相同的网格，我们可以假设这两个迭代器在两个DoFHandler对象的单元格中同步运行。

// 循环中的第一条语句又是非常熟悉的，按照更新标志的规定对有限元数据进行更新，将局部数组清零，并得到正交点上的旧解的值。 在这一点上，我们还必须在正交点上获得前一个时间步长的饱和函数的值。为此，我们可以使用 FEValues::get_function_values （之前已经在 step-9 、 step-14 和 step-15 中使用），这个函数接收一个解向量，并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。

// 然后，我们就可以在单元格上的正交点上进行循环，以进行积分。这方面的公式直接来自介绍中所讨论的内容。

// 一旦这样做了，我们就开始在局部矩阵的行和列上进行循环，并将相关的乘积输入矩阵中。

// 循环所有单元的最后一步是将本地贡献输入到全局矩阵和向量结构中，并在local_dof_indices中指定位置。同样，我们让AffineConstraints类将单元格矩阵元素插入到全局矩阵中，全局矩阵已经浓缩了悬挂节点的约束。

    auto       cell            = darcy_dof_handler.begin_active(); 
    const auto endc            = darcy_dof_handler.end(); 
    auto       saturation_cell = saturation_dof_handler.begin_active(); 

    for (; cell != endc; ++cell, ++saturation_cell) 
      { 
        darcy_fe_values.reinit(cell); 
        saturation_fe_values.reinit(saturation_cell); 

        local_matrix = 0; 
        local_rhs    = 0; 

        saturation_fe_values.get_function_values(old_saturation_solution, 
                                                 old_saturation_values); 

        pressure_right_hand_side.value_list( 
          darcy_fe_values.get_quadrature_points(), pressure_rhs_values); 
        k_inverse.value_list(darcy_fe_values.get_quadrature_points(), 
                             k_inverse_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                phi_u[k]     = darcy_fe_values[velocities].value(k, q); 
                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q); 
                phi_p[k]     = darcy_fe_values[pressure].value(k, q); 
              } 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              { 
                const double old_s = old_saturation_values[q]; 
                for (unsigned int j = 0; j <= i; ++j) 
                  { 
                    local_matrix(i, j) += 
                      (phi_u[i] * k_inverse_values[q] * 
                         mobility_inverse(old_s, viscosity) * phi_u[j] - 
                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) * 
                      darcy_fe_values.JxW(q); 
                  } 

                local_rhs(i) += 
                  (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.JxW(q); 
              } 
          } 

        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary()) 
            { 
              darcy_fe_face_values.reinit(cell, face); 

              pressure_boundary_values.value_list( 
                darcy_fe_face_values.get_quadrature_points(), boundary_values); 

              for (unsigned int q = 0; q < n_face_q_points; ++q) 
                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  { 
                    const Tensor<1, dim> phi_i_u = 
                      darcy_fe_face_values[velocities].value(i, q); 

                    local_rhs(i) += 
                      -(phi_i_u * darcy_fe_face_values.normal_vector(q) * 
                        boundary_values[q] * darcy_fe_face_values.JxW(q)); 
                  } 
            } 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = i + 1; j < dofs_per_cell; ++j) 
            local_matrix(i, j) = local_matrix(j, i); 

        cell->get_dof_indices(local_dof_indices); 

        darcy_constraints.distribute_local_to_global( 
          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs); 
      } 
  } 
// @sect4{TwoPhaseFlowProblem<dim>::assemble_saturation_system}  

// 这个函数是为了组装饱和传输方程的线性系统。如果有必要，它会调用另外两个成员函数：assemble_saturation_matrix()和assemble_saturation_rhs()。前一个函数然后组装饱和度矩阵，只需要偶尔改变。另一方面，后一个组装右手边的函数必须在每个饱和时间步骤中调用。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_saturation_system() 
  { 
    if (rebuild_saturation_matrix == true) 
      { 
        saturation_matrix = 0; 
        assemble_saturation_matrix(); 
      } 

    saturation_rhs = 0; 
    assemble_saturation_rhs(); 
  } 

//  @sect4{TwoPhaseFlowProblem<dim>::assemble_saturation_matrix}  

// 这个函数很容易理解，因为它只是通过基函数phi_i_s和phi_j_s为饱和线性系统的左侧形成一个简单的质量矩阵。最后，像往常一样，我们通过在local_dof_indices中指定位置将局部贡献输入全局矩阵。这是通过让AffineConstraints类将单元矩阵元素插入全局矩阵来完成的，全局矩阵已经浓缩了悬挂节点约束。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_saturation_matrix() 
  { 
    QGauss<dim> quadrature_formula(saturation_degree + 2); 

    FEValues<dim> saturation_fe_values(saturation_fe, 
                                       quadrature_formula, 
                                       update_values | update_JxW_values); 

    const unsigned int dofs_per_cell = saturation_fe.n_dofs_per_cell(); 

    const unsigned int n_q_points = quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : saturation_dof_handler.active_cell_iterators()) 
      { 
        saturation_fe_values.reinit(cell); 
        local_matrix = 0; 
        local_rhs    = 0; 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const double phi_i_s = saturation_fe_values.shape_value(i, q); 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const double phi_j_s = saturation_fe_values.shape_value(j, q); 
                  local_matrix(i, j) += 
                    porosity * phi_i_s * phi_j_s * saturation_fe_values.JxW(q); 
                } 
            } 
        cell->get_dof_indices(local_dof_indices); 

        saturation_constraints.distribute_local_to_global(local_matrix, 
                                                          local_dof_indices, 
                                                          saturation_matrix); 
      } 
  } 

//  @sect4{TwoPhaseFlowProblem<dim>::assemble_saturation_rhs}  

// 这个函数是用来组装饱和传输方程的右边。在进行这项工作之前，我们必须为达西系统和饱和系统分别创建两个FEValues对象，此外，还必须为这两个系统创建两个FEFaceValues对象，因为我们在饱和方程的弱形式中存在一个边界积分项。对于饱和系统的FEFaceValues对象，我们还需要法向量，我们使用update_normal_vectors标志来申请。

// 接下来，在对所有单元进行循环之前，我们必须计算一些参数（例如global_u_infty、global_S_variation和global_Omega_diameter），这是人工黏度 $\nu$ 需要的。这与 step-31 中的做法基本相同，所以你可以在那里看到更多的信息。

// 真正的工作是从循环所有的饱和和Darcy单元开始的，以便将局部贡献放到全局矢量中。在这个循环中，为了简化实现，我们把一些工作分成两个辅助函数：assemble_saturation_rhs_cell_term和assemble_saturation_rhs_boundary_term。 我们注意到，我们在这两个函数中把细胞或边界贡献插入全局向量，而不是在本函数中。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs() 
  { 
    QGauss<dim>     quadrature_formula(saturation_degree + 2); 
    QGauss<dim - 1> face_quadrature_formula(saturation_degree + 2); 

    FEValues<dim> saturation_fe_values(saturation_fe, 
                                       quadrature_formula, 
                                       update_values | update_gradients | 
                                         update_quadrature_points | 
                                         update_JxW_values); 
    FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values); 
    FEFaceValues<dim> saturation_fe_face_values(saturation_fe, 
                                                face_quadrature_formula, 
                                                update_values | 
                                                  update_normal_vectors | 
                                                  update_quadrature_points | 
                                                  update_JxW_values); 
    FEFaceValues<dim> darcy_fe_face_values(darcy_fe, 
                                           face_quadrature_formula, 
                                           update_values); 
    FEFaceValues<dim> saturation_fe_face_values_neighbor( 
      saturation_fe, face_quadrature_formula, update_values); 

    const unsigned int dofs_per_cell = 
      saturation_dof_handler.get_fe().n_dofs_per_cell(); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const double                    global_max_u_F_prime = get_max_u_F_prime(); 
    const std::pair<double, double> global_S_range = 
      get_extrapolated_saturation_range(); 
    const double global_S_variation = 
      global_S_range.second - global_S_range.first; 

    auto       cell       = saturation_dof_handler.begin_active(); 
    const auto endc       = saturation_dof_handler.end(); 
    auto       darcy_cell = darcy_dof_handler.begin_active(); 
    for (; cell != endc; ++cell, ++darcy_cell) 
      { 
        saturation_fe_values.reinit(cell); 
        darcy_fe_values.reinit(darcy_cell); 

        cell->get_dof_indices(local_dof_indices); 

        assemble_saturation_rhs_cell_term(saturation_fe_values, 
                                          darcy_fe_values, 
                                          global_max_u_F_prime, 
                                          global_S_variation, 
                                          local_dof_indices); 

        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary()) 
            { 
              darcy_fe_face_values.reinit(darcy_cell, face); 
              saturation_fe_face_values.reinit(cell, face); 
              assemble_saturation_rhs_boundary_term(saturation_fe_face_values, 
                                                    darcy_fe_face_values, 
                                                    local_dof_indices); 
            } 
      } 
  } 

//  @sect4{TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term}  

// 这个函数负责整合饱和度方程右边的单元项，然后将其组装成全局右边的矢量。鉴于介绍中的讨论，这些贡献的形式很清楚。唯一棘手的部分是获得人工黏度和计算它所需的一切。该函数的前半部分专门用于这项任务。

// 该函数的最后一部分是将局部贡献复制到全局向量中，其位置由local_dof_indices指定。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term( 
    const FEValues<dim> &                       saturation_fe_values, 
    const FEValues<dim> &                       darcy_fe_values, 
    const double                                global_max_u_F_prime, 
    const double                                global_S_variation, 
    const std::vector<types::global_dof_index> &local_dof_indices) 
  { 
    const unsigned int dofs_per_cell = saturation_fe_values.dofs_per_cell; 
    const unsigned int n_q_points    = saturation_fe_values.n_quadrature_points; 

    std::vector<double>         old_saturation_solution_values(n_q_points); 
    std::vector<double>         old_old_saturation_solution_values(n_q_points); 
    std::vector<Tensor<1, dim>> old_grad_saturation_solution_values(n_q_points); 
    std::vector<Tensor<1, dim>> old_old_grad_saturation_solution_values( 
      n_q_points); 
    std::vector<Vector<double>> present_darcy_solution_values( 
      n_q_points, Vector<double>(dim + 1)); 

    saturation_fe_values.get_function_values(old_saturation_solution, 
                                             old_saturation_solution_values); 
    saturation_fe_values.get_function_values( 
      old_old_saturation_solution, old_old_saturation_solution_values); 
    saturation_fe_values.get_function_gradients( 
      old_saturation_solution, old_grad_saturation_solution_values); 
    saturation_fe_values.get_function_gradients( 
      old_old_saturation_solution, old_old_grad_saturation_solution_values); 
    darcy_fe_values.get_function_values(darcy_solution, 
                                        present_darcy_solution_values); 

    const double nu = 
      compute_viscosity(old_saturation_solution_values, 
                        old_old_saturation_solution_values, 
                        old_grad_saturation_solution_values, 
                        old_old_grad_saturation_solution_values, 
                        present_darcy_solution_values, 
                        global_max_u_F_prime, 
                        global_S_variation, 
                        saturation_fe_values.get_cell()->diameter()); 

    Vector<double> local_rhs(dofs_per_cell); 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          const double   old_s = old_saturation_solution_values[q]; 
          Tensor<1, dim> present_u; 
          for (unsigned int d = 0; d < dim; ++d) 
            present_u[d] = present_darcy_solution_values[q](d); 

          const double         phi_i_s = saturation_fe_values.shape_value(i, q); 
          const Tensor<1, dim> grad_phi_i_s = 
            saturation_fe_values.shape_grad(i, q); 

          local_rhs(i) += 
            (time_step * fractional_flow(old_s, viscosity) * present_u * 
               grad_phi_i_s - 
             time_step * nu * old_grad_saturation_solution_values[q] * 
               grad_phi_i_s + 
             porosity * old_s * phi_i_s) * 
            saturation_fe_values.JxW(q); 
        } 

    saturation_constraints.distribute_local_to_global(local_rhs, 
                                                      local_dof_indices, 
                                                      saturation_rhs); 
  } 
// @sect4{TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term}  

// 下一个函数负责饱和方程右侧形式中的边界积分项。 对于这些，我们必须计算全局边界面上的上行通量，也就是说，我们只对全局边界的流入部分弱加迪里切特边界条件。如前所述，这在 step-21 中已经描述过了，所以我们不对其进行更多的描述。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term( 
    const FEFaceValues<dim> &                   saturation_fe_face_values, 
    const FEFaceValues<dim> &                   darcy_fe_face_values, 
    const std::vector<types::global_dof_index> &local_dof_indices) 
  { 
    const unsigned int dofs_per_cell = saturation_fe_face_values.dofs_per_cell; 
    const unsigned int n_face_q_points = 
      saturation_fe_face_values.n_quadrature_points; 

    Vector<double> local_rhs(dofs_per_cell); 

 
    std::vector<Vector<double>> present_darcy_solution_values_face( 
      n_face_q_points, Vector<double>(dim + 1)); 
    std::vector<double> neighbor_saturation(n_face_q_points); 

    saturation_fe_face_values.get_function_values( 
      old_saturation_solution, old_saturation_solution_values_face); 
    darcy_fe_face_values.get_function_values( 
      darcy_solution, present_darcy_solution_values_face); 

    SaturationBoundaryValues<dim> saturation_boundary_values; 
    saturation_boundary_values.value_list( 
      saturation_fe_face_values.get_quadrature_points(), neighbor_saturation); 

    for (unsigned int q = 0; q < n_face_q_points; ++q) 
      { 
        Tensor<1, dim> present_u_face; 
        for (unsigned int d = 0; d < dim; ++d) 
          present_u_face[d] = present_darcy_solution_values_face[q](d); 

 
          present_u_face * saturation_fe_face_values.normal_vector(q); 

        const bool is_outflow_q_point = (normal_flux >= 0); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          local_rhs(i) -= 
            time_step * normal_flux * 
            fractional_flow((is_outflow_q_point == true ? 
                               old_saturation_solution_values_face[q] : 
                               neighbor_saturation[q]), 
                            viscosity) * 
            saturation_fe_face_values.shape_value(i, q) * 
            saturation_fe_face_values.JxW(q); 
      } 
    saturation_constraints.distribute_local_to_global(local_rhs, 
                                                      local_dof_indices, 
                                                      saturation_rhs); 
  } 
// @sect3{TwoPhaseFlowProblem<dim>::solve}  

// 该函数实现了算子分割算法，即在每个时间步长中，它要么重新计算达西系统的解，要么从以前的时间步长中推算出速度/压力，然后确定时间步长的大小，然后更新饱和度变量。其实现主要遵循  step-31  中的类似代码。除了run()函数外，它是本程序中的核心函数。

// 在函数的开始，我们询问是否要通过评估后验准则来解决压力-速度部分（见下面的函数）。如果有必要，我们将使用GMRES求解器和Schur补充块预处理来求解压力-速度部分，如介绍中所述。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::solve() 
  { 
    const bool solve_for_pressure_and_velocity = 
      determine_whether_to_solve_for_pressure_and_velocity(); 

    if (solve_for_pressure_and_velocity == true) 
      { 
        std::cout << "   Solving Darcy (pressure-velocity) system..." 
                  << std::endl; 

        assemble_darcy_system(); 
        build_darcy_preconditioner(); 

        { 
          const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix, 
                                             TrilinosWrappers::PreconditionIC> 
            mp_inverse(darcy_preconditioner_matrix.block(1, 1), 
                       *Mp_preconditioner); 

          const LinearSolvers::BlockSchurPreconditioner< 
            TrilinosWrappers::PreconditionIC, 
            TrilinosWrappers::PreconditionIC> 
            preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner); 

          SolverControl solver_control(darcy_matrix.m(), 
                                       1e-16 * darcy_rhs.l2_norm()); 

          SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres( 
            solver_control, 
            SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData( 
              100)); 

          for (unsigned int i = 0; i < darcy_solution.size(); ++i) 
            if (darcy_constraints.is_constrained(i)) 
              darcy_solution(i) = 0; 

          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner); 

          darcy_constraints.distribute(darcy_solution); 

          std::cout << "        ..." << solver_control.last_step() 
                    << " GMRES iterations." << std::endl; 
        } 

        { 
  }; 
          last_computed_darcy_solution        = darcy_solution; 

          saturation_matching_last_computed_darcy_solution = 
            saturation_solution; 
        } 
      } 

// 另一方面，如果我们决定不计算当前时间步长的达西系统的解，那么我们需要简单地将前两个达西解外推到与我们计算速度/压力的时间相同。我们做一个简单的线性外推，即给定从上次计算达西解到现在的宏观时间步长 $dt$ （由 <code>current_macro_time_step</code> 给出），以及 $DT$ 上一个宏观时间步长（由 <code>old_macro_time_step</code> 给出），然后得到 $u^\ast = u_p + dt \frac{u_p-u_{pp}}{DT} = (1+dt/DT)u_p - dt/DT u_{pp}$  ，其中 $u_p$ 和 $u_{pp}$ 是最近两个计算的达西解。我们只需用两行代码就可以实现这个公式。

// 请注意，这里的算法只有在我们至少有两个先前计算的Darcy解，我们可以从中推断出当前的时间，这一点通过要求重新计算前两个时间步骤的Darcy解来保证。

    else 
      { 
        darcy_solution = last_computed_darcy_solution; 
        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step, 
                            -current_macro_time_step / old_macro_time_step, 
                            second_last_computed_darcy_solution); 
      } 

// 用这样计算出来的速度矢量，根据介绍中讨论的CFL标准计算出最佳时间步长......

    { 
      old_time_step = time_step; 

      const double max_u_F_prime = get_max_u_F_prime(); 
      if (max_u_F_prime > 0) 
        time_step = porosity * GridTools::minimal_cell_diameter(triangulation) / 
                    saturation_degree / max_u_F_prime / 50; 
      else 
        time_step = end_time - time; 
    } 

// ......然后在我们处理时间步长的时候，还要更新我们使用的宏观时间步长。具体而言，这涉及到。(i) 如果我们刚刚重新计算了达西解，那么之前的宏观时间步长现在是固定的，当前的宏观时间步长，到现在为止，只是当前（微观）时间步长。(ii) 如果我们没有重新计算达西解，那么当前的宏观时间步长刚刚增长了 <code>time_step</code>  。

    if (solve_for_pressure_and_velocity == true) 
      { 
        old_macro_time_step     = current_macro_time_step; 
        current_macro_time_step = time_step; 
      } 
    else 
      current_macro_time_step += time_step; 

// 这个函数的最后一步是根据我们刚刚得到的速度场重新计算饱和解。这自然发生在每一个时间步骤中，我们不会跳过这些计算。在计算饱和度的最后，我们投射回允许的区间 $[0,1]$ ，以确保我们的解保持物理状态。

    { 
      std::cout << "   Solving saturation transport equation..." << std::endl; 

      assemble_saturation_system(); 

      SolverControl solver_control(saturation_matrix.m(), 
                                   1e-16 * saturation_rhs.l2_norm()); 
      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control); 

      TrilinosWrappers::PreconditionIC preconditioner; 
      preconditioner.initialize(saturation_matrix); 

      cg.solve(saturation_matrix, 
               saturation_solution, 
               saturation_rhs, 
               preconditioner); 

      saturation_constraints.distribute(saturation_solution); 
      project_back_saturation(); 

      std::cout << "        ..." << solver_control.last_step() 
                << " CG iterations." << std::endl; 
    } 
  } 
// @sect3{TwoPhaseFlowProblem<dim>::refine_mesh}  

// 下一个函数是对网格进行细化和粗化。它的工作分三块进行。(i) 计算细化指标，方法是通过使用各自的时间步长（如果这是第一个时间步长，则取唯一的解决方案），从前两个时间步长中线性推断出的解决方案向量的梯度。(ii) 在梯度大于或小于某一阈值的单元中标记出细化和粗化的单元，保留网格细化的最小和最大水平。(iii) 将解决方案从旧网格转移到新网格。这些都不是特别困难。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::refine_mesh(const unsigned int min_grid_level, 
                                             const unsigned int max_grid_level) 
  { 
    Vector<double> refinement_indicators(triangulation.n_active_cells()); 
    { 
      const QMidpoint<dim>        quadrature_formula; 
      FEValues<dim>               fe_values(saturation_fe, 
                              quadrature_formula, 
                              update_gradients); 
      std::vector<Tensor<1, dim>> grad_saturation(1); 

      TrilinosWrappers::MPI::Vector extrapolated_saturation_solution( 
        saturation_solution); 
      if (timestep_number != 0) 
        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step), 
                                              time_step / old_time_step, 
                                              old_saturation_solution); 

      for (const auto &cell : saturation_dof_handler.active_cell_iterators()) 
        { 
          const unsigned int cell_no = cell->active_cell_index(); 
          fe_values.reinit(cell); 
          fe_values.get_function_gradients(extrapolated_saturation_solution, 
                                           grad_saturation); 

          refinement_indicators(cell_no) = grad_saturation[0].norm(); 
        } 
    } 

    { 
      for (const auto &cell : saturation_dof_handler.active_cell_iterators()) 
        { 
          const unsigned int cell_no = cell->active_cell_index(); 
          cell->clear_coarsen_flag(); 
          cell->clear_refine_flag(); 

          if ((static_cast<unsigned int>(cell->level()) < max_grid_level) && 
              (std::fabs(refinement_indicators(cell_no)) > 
               saturation_refinement_threshold)) 
            cell->set_refine_flag(); 
          else if ((static_cast<unsigned int>(cell->level()) > 
                    min_grid_level) && 
                   (std::fabs(refinement_indicators(cell_no)) < 
                    0.5 * saturation_refinement_threshold)) 
            cell->set_coarsen_flag(); 
        } 
    } 

    triangulation.prepare_coarsening_and_refinement(); 

    { 
      std::vector<TrilinosWrappers::MPI::Vector> x_saturation(3); 
      x_saturation[0] = saturation_solution; 
      x_saturation[1] = old_saturation_solution; 
      x_saturation[2] = saturation_matching_last_computed_darcy_solution; 

      std::vector<TrilinosWrappers::MPI::BlockVector> x_darcy(2); 
      x_darcy[0] = last_computed_darcy_solution; 
      x_darcy[1] = second_last_computed_darcy_solution; 

      SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> saturation_soltrans( 
        saturation_dof_handler); 

      SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> darcy_soltrans( 
        darcy_dof_handler); 

      triangulation.prepare_coarsening_and_refinement(); 
      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation); 

      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy); 

      triangulation.execute_coarsening_and_refinement(); 
      setup_dofs(); 

      std::vector<TrilinosWrappers::MPI::Vector> tmp_saturation(3); 
      tmp_saturation[0].reinit(saturation_solution); 
      tmp_saturation[1].reinit(saturation_solution); 
      tmp_saturation[2].reinit(saturation_solution); 
      saturation_soltrans.interpolate(x_saturation, tmp_saturation); 

      saturation_solution                              = tmp_saturation[0]; 
      old_saturation_solution                          = tmp_saturation[1]; 
      saturation_matching_last_computed_darcy_solution = tmp_saturation[2]; 

      saturation_constraints.distribute(saturation_solution); 
      saturation_constraints.distribute(old_saturation_solution); 
      saturation_constraints.distribute( 
        saturation_matching_last_computed_darcy_solution); 

      std::vector<TrilinosWrappers::MPI::BlockVector> tmp_darcy(2); 
      tmp_darcy[0].reinit(darcy_solution); 
      tmp_darcy[1].reinit(darcy_solution); 
      darcy_soltrans.interpolate(x_darcy, tmp_darcy); 

      last_computed_darcy_solution        = tmp_darcy[0]; 
      second_last_computed_darcy_solution = tmp_darcy[1]; 

      darcy_constraints.distribute(last_computed_darcy_solution); 
      darcy_constraints.distribute(second_last_computed_darcy_solution); 

      rebuild_saturation_matrix = true; 
    } 
  } 

//  @sect3{TwoPhaseFlowProblem<dim>::output_results}  

// 这个函数生成图形输出。它实质上是对  step-31  中实现的复制。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::output_results() const 
  { 
    const FESystem<dim> joint_fe(darcy_fe, 1, saturation_fe, 1); 
    DoFHandler<dim>     joint_dof_handler(triangulation); 
    joint_dof_handler.distribute_dofs(joint_fe); 
    Assert(joint_dof_handler.n_dofs() == 
             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(), 
           ExcInternalError()); 

    Vector<double> joint_solution(joint_dof_handler.n_dofs()); 

    { 
      std::vector<types::global_dof_index> local_joint_dof_indices( 
        joint_fe.n_dofs_per_cell()); 
      std::vector<types::global_dof_index> local_darcy_dof_indices( 
        darcy_fe.n_dofs_per_cell()); 
      std::vector<types::global_dof_index> local_saturation_dof_indices( 
        saturation_fe.n_dofs_per_cell()); 

      auto       joint_cell      = joint_dof_handler.begin_active(); 
      const auto joint_endc      = joint_dof_handler.end(); 
      auto       darcy_cell      = darcy_dof_handler.begin_active(); 
      auto       saturation_cell = saturation_dof_handler.begin_active(); 

      for (; joint_cell != joint_endc; 
           ++joint_cell, ++darcy_cell, ++saturation_cell) 
        { 
          joint_cell->get_dof_indices(local_joint_dof_indices); 
          darcy_cell->get_dof_indices(local_darcy_dof_indices); 
          saturation_cell->get_dof_indices(local_saturation_dof_indices); 

          for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i) 
            if (joint_fe.system_to_base_index(i).first.first == 0) 
              { 
                Assert(joint_fe.system_to_base_index(i).second < 
                         local_darcy_dof_indices.size(), 
                       ExcInternalError()); 
                joint_solution(local_joint_dof_indices[i]) = darcy_solution( 
                  local_darcy_dof_indices[joint_fe.system_to_base_index(i) 
                                            .second]); 
              } 
            else 
              { 
                Assert(joint_fe.system_to_base_index(i).first.first == 1, 
                       ExcInternalError()); 
                Assert(joint_fe.system_to_base_index(i).second < 
                         local_darcy_dof_indices.size(), 
                       ExcInternalError()); 
                joint_solution(local_joint_dof_indices[i]) = 
                  saturation_solution( 
                    local_saturation_dof_indices 
                      [joint_fe.system_to_base_index(i).second]); 
              } 
        } 
    } 
    std::vector<std::string> joint_solution_names(dim, "velocity"); 
    joint_solution_names.emplace_back("pressure"); 
    joint_solution_names.emplace_back("saturation"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(joint_dof_handler); 
    data_out.add_data_vector(joint_solution, 
                             joint_solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 

    data_out.build_patches(); 

    std::string filename = 
      "solution-" + Utilities::int_to_string(timestep_number, 5) + ".vtu"; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 

//  @sect3{Tool functions}  
// @sect4{TwoPhaseFlowProblem<dim>::determine_whether_to_solve_for_pressure_and_velocity}  

// 这个函数实现了自适应运算符拆分的后验标准。考虑到我们在上面实现其他函数的方式，并考虑到论文中得出的准则公式，该函数是相对简单的。

// 如果我们决定要采用原始的IMPES方法，即在每个时间步长中求解Darcy方程，那么可以通过将阈值 <code>AOS_threshold</code> （默认为 $5.0$ ）设置为0来实现，从而迫使该函数总是返回true。

// 最后，请注意，该函数在前两个时间步骤中无条件地返回真，以确保我们在跳过达西系统的解时总是至少解了两次，从而允许我们从 <code>solve()</code> 中的最后两次解中推算出速度。

  template <int dim> 
  bool TwoPhaseFlowProblem< 
    dim>::determine_whether_to_solve_for_pressure_and_velocity() const 
  { 
    if (timestep_number <= 2) 
      return true; 

    const QGauss<dim>  quadrature_formula(saturation_degree + 2); 
    const unsigned int n_q_points = quadrature_formula.size(); 

    FEValues<dim> fe_values(saturation_fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points); 

    std::vector<double> old_saturation_after_solving_pressure(n_q_points); 
    std::vector<double> present_saturation(n_q_points); 

    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points); 

    double max_global_aop_indicator = 0.0; 

    for (const auto &cell : saturation_dof_handler.active_cell_iterators()) 
      { 
        double max_local_mobility_reciprocal_difference = 0.0; 
        double max_local_permeability_inverse_l1_norm   = 0.0; 

        fe_values.reinit(cell); 
        fe_values.get_function_values( 
          saturation_matching_last_computed_darcy_solution, 
          old_saturation_after_solving_pressure); 
        fe_values.get_function_values(saturation_solution, present_saturation); 

        k_inverse.value_list(fe_values.get_quadrature_points(), 
                             k_inverse_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double mobility_reciprocal_difference = std::fabs( 
              mobility_inverse(present_saturation[q], viscosity) - 
              mobility_inverse(old_saturation_after_solving_pressure[q], 
                               viscosity)); 

            max_local_mobility_reciprocal_difference = 
              std::max(max_local_mobility_reciprocal_difference, 
                       mobility_reciprocal_difference); 

            max_local_permeability_inverse_l1_norm = 
              std::max(max_local_permeability_inverse_l1_norm, 
                       l1_norm(k_inverse_values[q])); 
          } 

        max_global_aop_indicator = 
          std::max(max_global_aop_indicator, 
                   (max_local_mobility_reciprocal_difference * 
                    max_local_permeability_inverse_l1_norm)); 
      } 

    return (max_global_aop_indicator > AOS_threshold); 
  } 

//  @sect4{TwoPhaseFlowProblem<dim>::project_back_saturation}  

// 下一个函数只是确保饱和度值始终保持在  $[0,1]$  的物理合理范围内。虽然连续方程保证了这一点，但离散方程并没有。然而，如果我们允许离散解逃脱这个范围，我们就会遇到麻烦，因为像 $F(S)$ 和 $F'(S)$ 这样的项会产生不合理的结果（例如 $F'(S)<0$ 为 $S<0$ ，这将意味着润湿液相的流动方向为<i>against</i>的散流体速度））。因此，在每个时间步骤结束时，我们只需将饱和场投射回物理上合理的区域。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::project_back_saturation() 
  { 
    for (unsigned int i = 0; i < saturation_solution.size(); ++i) 
      if (saturation_solution(i) < 0.2) 
        saturation_solution(i) = 0.2; 
      else if (saturation_solution(i) > 1) 
        saturation_solution(i) = 1; 
  } 

//  @sect4{TwoPhaseFlowProblem<dim>::get_max_u_F_prime}  

// 另一个比较简单的辅助函数。计算总速度乘以分数流函数的导数的最大值，即计算  $\|\mathbf{u} F'(S)\|_{L_\infty(\Omega)}$  。这个项既用于时间步长的计算，也用于人工黏度中熵留项的正常化。

  template <int dim> 
  double TwoPhaseFlowProblem<dim>::get_max_u_F_prime() const 
  { 
    const QGauss<dim>  quadrature_formula(darcy_degree + 2); 
    const unsigned int n_q_points = quadrature_formula.size(); 

    FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values); 
    FEValues<dim> saturation_fe_values(saturation_fe, 
                                       quadrature_formula, 
                                       update_values); 

    std::vector<Vector<double>> darcy_solution_values(n_q_points, 
                                                      Vector<double>(dim + 1)); 
    std::vector<double>         saturation_values(n_q_points); 

    double max_velocity_times_dF_dS = 0; 

    auto       cell            = darcy_dof_handler.begin_active(); 
    const auto endc            = darcy_dof_handler.end(); 
    auto       saturation_cell = saturation_dof_handler.begin_active(); 
    for (; cell != endc; ++cell, ++saturation_cell) 
      { 
        darcy_fe_values.reinit(cell); 
        saturation_fe_values.reinit(saturation_cell); 

        darcy_fe_values.get_function_values(darcy_solution, 
                                            darcy_solution_values); 
        saturation_fe_values.get_function_values(old_saturation_solution, 
                                                 saturation_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            Tensor<1, dim> velocity; 
            for (unsigned int i = 0; i < dim; ++i) 
              velocity[i] = darcy_solution_values[q](i); 

            const double dF_dS = 
              fractional_flow_derivative(saturation_values[q], viscosity); 

            max_velocity_times_dF_dS = 
              std::max(max_velocity_times_dF_dS, velocity.norm() * dF_dS); 
          } 
      } 

    return max_velocity_times_dF_dS; 
  } 
// @sect4{TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range}  

// 为了计算稳定化项，我们需要知道饱和变量的范围。与 step-31 不同，这个范围很容易被区间 $[0,1]$ 所约束，但是我们可以通过在正交点的集合上循环，看看那里的值是多少，从而做得更好。如果可以的话，也就是说，如果周围至少有两个时间步长，我们甚至可以把这些值推算到下一个时间步长。

// 和以前一样，这个函数是在对  step-31  进行最小修改后取的。

  template <int dim> 
  std::pair<double, double> 
  TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range() const 
  { 
    const QGauss<dim>  quadrature_formula(saturation_degree + 2); 
    const unsigned int n_q_points = quadrature_formula.size(); 

    FEValues<dim> fe_values(saturation_fe, quadrature_formula, update_values); 
    std::vector<double> old_saturation_values(n_q_points); 
    std::vector<double> old_old_saturation_values(n_q_points); 

    if (timestep_number != 0) 
      { 
        double min_saturation = std::numeric_limits<double>::max(), 
               max_saturation = -std::numeric_limits<double>::max(); 

        for (const auto &cell : saturation_dof_handler.active_cell_iterators()) 
          { 
            fe_values.reinit(cell); 
            fe_values.get_function_values(old_saturation_solution, 
                                          old_saturation_values); 
            fe_values.get_function_values(old_old_saturation_solution, 
                                          old_old_saturation_values); 

            for (unsigned int q = 0; q < n_q_points; ++q) 
              { 
                const double saturation = 
                  (1. + time_step / old_time_step) * old_saturation_values[q] - 
                  time_step / old_time_step * old_old_saturation_values[q]; 

                min_saturation = std::min(min_saturation, saturation); 
                max_saturation = std::max(max_saturation, saturation); 
              } 
          } 

        return std::make_pair(min_saturation, max_saturation); 
      } 
    else 
      { 
        double min_saturation = std::numeric_limits<double>::max(), 
               max_saturation = -std::numeric_limits<double>::max(); 

        for (const auto &cell : saturation_dof_handler.active_cell_iterators()) 
          { 
            fe_values.reinit(cell); 
            fe_values.get_function_values(old_saturation_solution, 
                                          old_saturation_values); 

            for (unsigned int q = 0; q < n_q_points; ++q) 
              { 
                const double saturation = old_saturation_values[q]; 

                min_saturation = std::min(min_saturation, saturation); 
                max_saturation = std::max(max_saturation, saturation); 
              } 
          } 

        return std::make_pair(min_saturation, max_saturation); 
      } 
  } 

//  @sect4{TwoPhaseFlowProblem<dim>::compute_viscosity}  

// 最后一个工具函数是用来计算给定单元上的人工粘度的。如果你面前有它的公式，这并不特别复杂，看一下  step-31  中的实现。与那个教程程序的主要区别是，这里的速度不是简单的 $\mathbf u$ ，而是 $\mathbf u F'(S)$ ，一些公式需要做相应的调整。

  template <int dim> 
  double TwoPhaseFlowProblem<dim>::compute_viscosity( 
    const std::vector<double> &        old_saturation, 
    const std::vector<double> &        old_old_saturation, 
    const std::vector<Tensor<1, dim>> &old_saturation_grads, 
    const std::vector<Tensor<1, dim>> &old_old_saturation_grads, 
    const std::vector<Vector<double>> &present_darcy_values, 
    const double                       global_max_u_F_prime, 
    const double                       global_S_variation, 
    const double                       cell_diameter) const 
  { 
    const double beta  = .4 * dim; 
    const double alpha = 1; 

    if (global_max_u_F_prime == 0) 
      return 5e-3 * cell_diameter; 

    const unsigned int n_q_points = old_saturation.size(); 

    double max_residual             = 0; 
    double max_velocity_times_dF_dS = 0; 

    const bool use_dF_dS = true; 

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        Tensor<1, dim> u; 
        for (unsigned int d = 0; d < dim; ++d) 
          u[d] = present_darcy_values[q](d); 

        const double dS_dt = porosity * 
                             (old_saturation[q] - old_old_saturation[q]) / 
                             old_time_step; 

        const double dF_dS = fractional_flow_derivative( 
          (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity); 

        const double u_grad_S = 
          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) / 
          2.0; 

        const double residual = 
          std::abs((dS_dt + u_grad_S) * 
                   std::pow((old_saturation[q] + old_old_saturation[q]) / 2, 
                            alpha - 1.)); 

        max_residual = std::max(residual, max_residual); 
        max_velocity_times_dF_dS = 
          std::max(std::sqrt(u * u) * (use_dF_dS ? std::max(dF_dS, 1.) : 1), 
                   max_velocity_times_dF_dS); 
      } 

    const double c_R            = 1.0; 
    const double global_scaling = c_R * porosity * 
                                  (global_max_u_F_prime)*global_S_variation / 
                                  std::pow(global_Omega_diameter, alpha - 2.); 

    return (beta * 
            (max_velocity_times_dF_dS)*std::min(cell_diameter, 
                                                std::pow(cell_diameter, alpha) * 
                                                  max_residual / 
                                                  global_scaling)); 
  } 
// @sect3{TwoPhaseFlowProblem<dim>::run}  

// 除了 <code>solve()</code> 之外，这个函数是这个程序的主要功能，因为它控制了迭代的时间，以及何时将解决方案写入输出文件，何时进行网格细化。

// 除了启动代码通过 <code>goto start_time_iteration</code> 标签循环回到函数的开头外，一切都应该是相对简单的。无论如何，它模仿了  step-31  中的相应函数。

  template <int dim> 
  void TwoPhaseFlowProblem<dim>::run() 
  { 
    const unsigned int initial_refinement     = (dim == 2 ? 5 : 2); 
    const unsigned int n_pre_refinement_steps = (dim == 2 ? 3 : 2); 

    GridGenerator::hyper_cube(triangulation, 0, 1); 
    triangulation.refine_global(initial_refinement); 
    global_Omega_diameter = GridTools::diameter(triangulation); 

    setup_dofs(); 

    unsigned int pre_refinement_step = 0; 

  start_time_iteration: 

    VectorTools::project(saturation_dof_handler, 
                         saturation_constraints, 
                         QGauss<dim>(saturation_degree + 2), 
                         SaturationInitialValues<dim>(), 
                         old_saturation_solution); 

    time_step = old_time_step = 0; 
    current_macro_time_step = old_macro_time_step = 0; 

    time = 0; 

    do 
      { 
        std::cout << "Timestep " << timestep_number << ":  t=" << time 
                  << ", dt=" << time_step << std::endl; 

        solve(); 

        std::cout << std::endl; 

        if (timestep_number % 200 == 0) 
          output_results(); 

        if (timestep_number % 25 == 0) 
          refine_mesh(initial_refinement, 
                      initial_refinement + n_pre_refinement_steps); 

        if ((timestep_number == 0) && 
            (pre_refinement_step < n_pre_refinement_steps)) 
          { 
            ++pre_refinement_step; 
            goto start_time_iteration; 
          } 

        time += time_step; 
        ++timestep_number; 

        old_old_saturation_solution = old_saturation_solution; 
        old_saturation_solution     = saturation_solution; 
      } 
    while (time <= end_time); 
  } 
} // namespace Step43 

//  @sect3{The <code>main()</code> function}  

// 主函数看起来与所有其他程序几乎一样。对于使用Trilinos的程序来说，需要初始化MPI子系统--即使是那些实际上没有并行运行的程序--在  step-31  中有解释。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step43; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization( 
        argc, argv, numbers::invalid_unsigned_int); 

// 这个程序只能在串行中运行。否则，将抛出一个异常。

      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1, 
                  ExcMessage( 
                    "This program can only be run in serial, use ./step-43")); 

      TwoPhaseFlowProblem<2> two_phase_flow_problem(1); 
      two_phase_flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-44.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2010 - 2020 by the deal.II authors and 
 *                              & Jean-Paul Pelteret and Andrew McBride 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Jean-Paul Pelteret, University of Cape Town, 
 *          Andrew McBride, University of Erlangen-Nuremberg, 2010 
 */ 



// 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。它们已经在以前的教程程序中详细讨论过了，所以你只需要参考过去的教程就可以了。

#include <deal.II/base/function.h> 
#include <deal.II/base/parameter_handler.h> 
#include <deal.II/base/point.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/symmetric_tensor.h> 
#include <deal.II/base/tensor.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/work_stream.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

// 这个标头为我们提供了在正交点存储数据的功能

#include <deal.II/base/quadrature_point_data.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/grid_in.h> 
#include <deal.II/grid/tria.h> 

#include <deal.II/fe/fe_dgp_monomial.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q_eulerian.h> 

#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/precondition_selector.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/solver_selector.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/lac/affine_constraints.h> 

// 这里是使用LinearOperator类所需的头文件。这些头文件也都被方便地打包到一个头文件中，即<deal.II/lac/linear_operator_tools.h>，但为了透明起见，我们在此列出那些特别需要的头文件。

#include <deal.II/lac/linear_operator.h> 
#include <deal.II/lac/packaged_operation.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 在这两个标题中定义的是一些与有限应变弹性有关的操作。第一个将帮助我们计算一些运动量，第二个提供一些标准的张量定义。

#include <deal.II/physics/elasticity/kinematics.h> 
#include <deal.II/physics/elasticity/standard_tensors.h> 

#include <iostream> 
#include <fstream> 

// 然后，我们将所有与本教程程序有关的东西都放入一个自己的命名空间，并将所有deal.II的函数和类名导入其中。

namespace Step44 
{ 
  using namespace dealii; 
// @sect3{Run-time parameters}  

// 有几个参数可以在代码中设置，所以我们设置了一个ParameterHandler对象，在运行时读入选择。

  namespace Parameters 
  { 
// @sect4{Finite Element system}  

// 正如介绍中提到的，对于位移 $\mathbf{u}$ 应该使用不同的阶次插值，而不是压力 $\widetilde{p}$ 和膨胀 $\widetilde{J}$ 。 选择 $\widetilde{p}$ 和 $\widetilde{J}$ 作为元素级的不连续（常数）函数，导致了平均扩张方法。不连续的近似允许 $\widetilde{p}$ 和 $\widetilde{J}$ 被浓缩出来，并恢复了基于位移的经典方法。这里我们指定用于近似解的多项式阶数。正交阶数应作相应调整。

    struct FESystem 
    { 
      unsigned int poly_degree; 
      unsigned int quad_order; 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    void FESystem::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Finite element system"); 
      { 
        prm.declare_entry("Polynomial degree", 
                          "2", 
                          Patterns::Integer(0), 
                          "Displacement system polynomial order"); 

        prm.declare_entry("Quadrature order", 
                          "3", 
                          Patterns::Integer(0), 
                          "Gauss quadrature order"); 
      } 
      prm.leave_subsection(); 
    } 

    void FESystem::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Finite element system"); 
      { 
        poly_degree = prm.get_integer("Polynomial degree"); 
        quad_order  = prm.get_integer("Quadrature order"); 
      } 
      prm.leave_subsection(); 
    } 
// @sect4{Geometry}  

// 对问题的几何形状和应用的载荷进行调整。 由于这里模拟的问题比较特殊，所以可以将载荷比例改变为特定的数值，以便与文献中给出的结果进行比较。

    struct Geometry 
    { 
      unsigned int global_refinement; 
      double       scale; 
      double       p_p0; 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    void Geometry::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Geometry"); 
      { 
        prm.declare_entry("Global refinement", 
                          "2", 
                          Patterns::Integer(0), 
                          "Global refinement level"); 

        prm.declare_entry("Grid scale", 
                          "1e-3", 
                          Patterns::Double(0.0), 
                          "Global grid scaling factor"); 

        prm.declare_entry("Pressure ratio p/p0", 
                          "100", 
                          Patterns::Selection("20|40|60|80|100"), 
                          "Ratio of applied pressure to reference pressure"); 
      } 
      prm.leave_subsection(); 
    } 

    void Geometry::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Geometry"); 
      { 
        global_refinement = prm.get_integer("Global refinement"); 
        scale             = prm.get_double("Grid scale"); 
        p_p0              = prm.get_double("Pressure ratio p/p0"); 
      } 
      prm.leave_subsection(); 
    } 
// @sect4{Materials}  

// 我们还需要新胡克材料的剪切模量 $ \mu $ 和泊松率 $ \nu $ 。

    struct Materials 
    { 
      double nu; 
      double mu; 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    void Materials::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Material properties"); 
      { 
        prm.declare_entry("Poisson's ratio", 
                          "0.4999", 
                          Patterns::Double(-1.0, 0.5), 
                          "Poisson's ratio"); 

        prm.declare_entry("Shear modulus", 
                          "80.194e6", 
                          Patterns::Double(), 
                          "Shear modulus"); 
      } 
      prm.leave_subsection(); 
    } 

    void Materials::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Material properties"); 
      { 
        nu = prm.get_double("Poisson's ratio"); 
        mu = prm.get_double("Shear modulus"); 
      } 
      prm.leave_subsection(); 
    } 
// @sect4{Linear solver}  

// 接下来，我们选择求解器和预处理器的设置。 当牛顿增量中出现大的非线性运动时，使用有效的前置条件对于确保收敛性至关重要。

    struct LinearSolver 
    { 
      std::string type_lin; 
      double      tol_lin; 
      double      max_iterations_lin; 
      bool        use_static_condensation; 
      std::string preconditioner_type; 
      double      preconditioner_relaxation; 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    void LinearSolver::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Linear solver"); 
      { 
        prm.declare_entry("Solver type", 
                          "CG", 
                          Patterns::Selection("CG|Direct"), 
                          "Type of solver used to solve the linear system"); 

        prm.declare_entry("Residual", 
                          "1e-6", 
                          Patterns::Double(0.0), 
                          "Linear solver residual (scaled by residual norm)"); 

        prm.declare_entry( 
          "Max iteration multiplier", 
          "1", 
          Patterns::Double(0.0), 
          "Linear solver iterations (multiples of the system matrix size)"); 

        prm.declare_entry("Use static condensation", 
                          "true", 
                          Patterns::Bool(), 
                          "Solve the full block system or a reduced problem"); 

        prm.declare_entry("Preconditioner type", 
                          "ssor", 
                          Patterns::Selection("jacobi|ssor"), 
                          "Type of preconditioner"); 

        prm.declare_entry("Preconditioner relaxation", 
                          "0.65", 
                          Patterns::Double(0.0), 
                          "Preconditioner relaxation value"); 
      } 
      prm.leave_subsection(); 
    } 

    void LinearSolver::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Linear solver"); 
      { 
        type_lin                  = prm.get("Solver type"); 
        tol_lin                   = prm.get_double("Residual"); 
        max_iterations_lin        = prm.get_double("Max iteration multiplier"); 
        use_static_condensation   = prm.get_bool("Use static condensation"); 
        preconditioner_type       = prm.get("Preconditioner type"); 
        preconditioner_relaxation = prm.get_double("Preconditioner relaxation"); 
      } 
      prm.leave_subsection(); 
    } 
// @sect4{Nonlinear solver}  

// 采用牛顿-拉弗森方案来解决非线性治理方程组。 我们现在定义牛顿-拉弗森非线性求解器的公差和最大迭代次数。

    struct NonlinearSolver 
    { 
      unsigned int max_iterations_NR; 
      double       tol_f; 
      double       tol_u; 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    void NonlinearSolver::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Nonlinear solver"); 
      { 
        prm.declare_entry("Max iterations Newton-Raphson", 
                          "10", 
                          Patterns::Integer(0), 
                          "Number of Newton-Raphson iterations allowed"); 

        prm.declare_entry("Tolerance force", 
                          "1.0e-9", 
                          Patterns::Double(0.0), 
                          "Force residual tolerance"); 

        prm.declare_entry("Tolerance displacement", 
                          "1.0e-6", 
                          Patterns::Double(0.0), 
                          "Displacement error tolerance"); 
      } 
      prm.leave_subsection(); 
    } 

    void NonlinearSolver::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Nonlinear solver"); 
      { 
        max_iterations_NR = prm.get_integer("Max iterations Newton-Raphson"); 
        tol_f             = prm.get_double("Tolerance force"); 
        tol_u             = prm.get_double("Tolerance displacement"); 
      } 
      prm.leave_subsection(); 
    } 
// @sect4{Time}  

// 设置时间步长 $ \varDelta t $ 和模拟结束时间。

    struct Time 
    { 
      double delta_t; 
      double end_time; 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    void Time::declare_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Time"); 
      { 
        prm.declare_entry("End time", "1", Patterns::Double(), "End time"); 

        prm.declare_entry("Time step size", 
                          "0.1", 
                          Patterns::Double(), 
                          "Time step size"); 
      } 
      prm.leave_subsection(); 
    } 

    void Time::parse_parameters(ParameterHandler &prm) 
    { 
      prm.enter_subsection("Time"); 
      { 
        end_time = prm.get_double("End time"); 
        delta_t  = prm.get_double("Time step size"); 
      } 
      prm.leave_subsection(); 
    } 
// @sect4{All parameters}  

// 最后，我们将上述所有的结构合并到一个容器中，这个容器可以容纳我们所有的运行时选择。

    struct AllParameters : public FESystem, 
                           public Geometry, 
                           public Materials, 
                           public LinearSolver, 
                           public NonlinearSolver, 
                           public Time 

    { 
      AllParameters(const std::string &input_file); 

      static void declare_parameters(ParameterHandler &prm); 

      void parse_parameters(ParameterHandler &prm); 
    }; 

    AllParameters::AllParameters(const std::string &input_file) 
    { 
      ParameterHandler prm; 
      declare_parameters(prm); 
      prm.parse_input(input_file); 
      parse_parameters(prm); 
    } 

    void AllParameters::declare_parameters(ParameterHandler &prm) 
    { 
      FESystem::declare_parameters(prm); 
      Geometry::declare_parameters(prm); 
      Materials::declare_parameters(prm); 
      LinearSolver::declare_parameters(prm); 
      NonlinearSolver::declare_parameters(prm); 
      Time::declare_parameters(prm); 
    } 

    void AllParameters::parse_parameters(ParameterHandler &prm) 
    { 
      FESystem::parse_parameters(prm); 
      Geometry::parse_parameters(prm); 
      Materials::parse_parameters(prm); 
      LinearSolver::parse_parameters(prm); 
      NonlinearSolver::parse_parameters(prm); 
      Time::parse_parameters(prm); 
    } 
  } // namespace Parameters 
// @sect3{Time class}  

// 一个简单的类来存储时间数据。它的功能是透明的，所以没有必要讨论。为了简单起见，我们假设一个恒定的时间步长。

  class Time 
  { 
  public: 
    Time(const double time_end, const double delta_t) 
      : timestep(0) 
      , time_current(0.0) 
      , time_end(time_end) 
      , delta_t(delta_t) 
    {} 

    virtual ~Time() = default; 

    double current() const 
    { 
      return time_current; 
    } 
    double end() const 
    { 
      return time_end; 
    } 
    double get_delta_t() const 
    { 
      return delta_t; 
    } 
    unsigned int get_timestep() const 
    { 
      return timestep; 
    } 
    void increment() 
    { 
      time_current += delta_t; 
      ++timestep; 
    } 

  private: 
    unsigned int timestep; 
    double       time_current; 
    const double time_end; 
    const double delta_t; 
  }; 
// @sect3{Compressible neo-Hookean material within a three-field formulation}  

// 正如介绍中所讨论的，新胡克材料是一种超弹性材料。 整个领域被假定为由可压缩的新胡克材料组成。 这个类别定义了这种材料在三场公式中的行为。 可压缩的新胡克材料可以用应变能量函数（SEF）来描述  $ \Psi = \Psi_{\text{iso}}(\overline{\mathbf{b}}) + \Psi_{\text{vol}}(\widetilde{J})$ 

// 等效响应由 $ \Psi_{\text{iso}}(\overline{\mathbf{b}}) = c_{1} [\overline{I}_{1} - 3] $ 给出，其中 $ c_{1} = \frac{\mu}{2} $ 和 $\overline{I}_{1}$ 是左或右等效Cauchy-Green变形张量的第一不变量。这就是 $\overline{I}_1 \dealcoloneq \textrm{tr}(\overline{\mathbf{b}})$  。在这个例子中，支配体积响应的SEF被定义为 $ \Psi_{\text{vol}}(\widetilde{J}) = \kappa \frac{1}{4} [ \widetilde{J}^2 - 1 - 2\textrm{ln}\; \widetilde{J} ]$  ，其中 $\kappa \dealcoloneq \lambda + 2/3 \mu$  是<a href="http:en.wikipedia.org/wiki/Bulk_modulus">bulk modulus</a>， $\lambda$ 是<a href="http:en.wikipedia.org/wiki/Lam%C3%A9_parameters">Lam&eacute;'s first parameter</a>。

// 下面的类将被用来描述我们工作中的材料特征，并提供了一个中心点，如果要实现不同的材料模型，就需要对其进行修改。为了使其发挥作用，我们将在每个正交点存储一个这种类型的对象，并在每个对象中存储当前状态（由三个场的值或度量来表征），这样我们就可以围绕当前状态计算出线性化的弹性系数。

  template <int dim> 
  class Material_Compressible_Neo_Hook_Three_Field 
  { 
  public: 
    Material_Compressible_Neo_Hook_Three_Field(const double mu, const double nu) 
      : kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu))) 
      , c_1(mu / 2.0) 
      , det_F(1.0) 
      , p_tilde(0.0) 
      , J_tilde(1.0) 
      , b_bar(Physics::Elasticity::StandardTensors<dim>::I) 
    { 
      Assert(kappa > 0, ExcInternalError()); 
    } 

// 我们用基于  $F$  和压力  $\widetilde{p}$  以及膨胀  $\widetilde{J}$  的各种变形相关数据来更新材料模型，并在函数的最后包括一个内部一致性的物理检查。

    void update_material_data(const Tensor<2, dim> &F, 
                              const double          p_tilde_in, 
                              const double          J_tilde_in) 
    { 
      det_F                      = determinant(F); 
      const Tensor<2, dim> F_bar = Physics::Elasticity::Kinematics::F_iso(F); 
      b_bar                      = Physics::Elasticity::Kinematics::b(F_bar); 
      p_tilde                    = p_tilde_in; 
      J_tilde                    = J_tilde_in; 

      Assert(det_F > 0, ExcInternalError()); 
    } 

// 第二个函数决定了基尔霍夫应力  $\boldsymbol{\tau} = \boldsymbol{\tau}_{\textrm{iso}} + \boldsymbol{\tau}_{\textrm{vol}}$  。
    SymmetricTensor<2, dim> get_tau() 
    { 
      return get_tau_iso() + get_tau_vol(); 
    } 

// 空间设置中的四阶弹性张量 $\mathfrak{c}$ 由SEF $\Psi$ 计算为 $ J \mathfrak{c}_{ijkl} = F_{iA} F_{jB} \mathfrak{C}_{ABCD} F_{kC} F_{lD}$  其中 $ \mathfrak{C} = 4 \frac{\partial^2 \Psi(\mathbf{C})}{\partial \mathbf{C} \partial \mathbf{C}}$  
    SymmetricTensor<4, dim> get_Jc() const 
    { 
      return get_Jc_vol() + get_Jc_iso(); 
    } 

// 体积自由能相对于  $\widetilde{J}$  的导数，返回  $\frac{\partial \Psi_{\text{vol}}(\widetilde{J})}{\partial \widetilde{J}}$  。
    double get_dPsi_vol_dJ() const 
    { 
      return (kappa / 2.0) * (J_tilde - 1.0 / J_tilde); 
    } 

// 体积自由能的二次导数，相对于  $\widetilde{J}$  。我们需要在切线中明确地进行以下计算，所以我们将其公开。 我们计算出  $\frac{\partial^2 \Psi_{\textrm{vol}}(\widetilde{J})}{\partial \widetilde{J} \partial \widetilde{J}}$  。
    double get_d2Psi_vol_dJ2() const 
    { 
      return ((kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde))); 
    } 

// 接下来的几个函数会返回各种数据，我们选择将其与材料一起存储。

    double get_det_F() const 
    { 
      return det_F; 
    } 

    double get_p_tilde() const 
    { 
      return p_tilde; 
    } 

    double get_J_tilde() const 
    { 
      return J_tilde; 
    } 

  protected: 

// 定义构成模型参数  $\kappa$  （体积模量）和新胡克模型参数  $c_1$  。

    const double kappa; 
    const double c_1; 

// 模型的具体数据，方便与材料一起存储。

    double                  det_F; 
    double                  p_tilde; 
    double                  J_tilde; 
    SymmetricTensor<2, dim> b_bar; 

// 以下函数在内部用于确定上述一些公共函数的结果。第一个函数决定了体积基尔霍夫应力  $\boldsymbol{\tau}_{\textrm{vol}}$  。

    SymmetricTensor<2, dim> get_tau_vol() const 
    { 
      return p_tilde * det_F * Physics::Elasticity::StandardTensors<dim>::I; 
    } 

// 接下来，确定等效基尔霍夫应力  $\boldsymbol{\tau}_{\textrm{iso}} = \mathcal{P}:\overline{\boldsymbol{\tau}}$  。

    SymmetricTensor<2, dim> get_tau_iso() const 
    { 
      return Physics::Elasticity::StandardTensors<dim>::dev_P * get_tau_bar(); 
    } 

// 然后，确定虚构的基尔霍夫应力  $\overline{\boldsymbol{\tau}}$  。

    SymmetricTensor<2, dim> get_tau_bar() const 
    { 
      return 2.0 * c_1 * b_bar; 
    } 

// 计算切线的体积部分  $J \mathfrak{c}_\textrm{vol}$  。

    SymmetricTensor<4, dim> get_Jc_vol() const 
    { 
      return p_tilde * det_F * 
             (Physics::Elasticity::StandardTensors<dim>::IxI - 
              (2.0 * Physics::Elasticity::StandardTensors<dim>::S)); 
    } 

// 计算切线的等值部分  $J \mathfrak{c}_\textrm{iso}$  。

    SymmetricTensor<4, dim> get_Jc_iso() const 
    { 
      const SymmetricTensor<2, dim> tau_bar = get_tau_bar(); 
      const SymmetricTensor<2, dim> tau_iso = get_tau_iso(); 
      const SymmetricTensor<4, dim> tau_iso_x_I = 
        outer_product(tau_iso, Physics::Elasticity::StandardTensors<dim>::I); 
      const SymmetricTensor<4, dim> I_x_tau_iso = 
        outer_product(Physics::Elasticity::StandardTensors<dim>::I, tau_iso); 
      const SymmetricTensor<4, dim> c_bar = get_c_bar(); 

      return (2.0 / dim) * trace(tau_bar) * 
               Physics::Elasticity::StandardTensors<dim>::dev_P - 
             (2.0 / dim) * (tau_iso_x_I + I_x_tau_iso) + 
             Physics::Elasticity::StandardTensors<dim>::dev_P * c_bar * 
               Physics::Elasticity::StandardTensors<dim>::dev_P; 
    } 

// 计算虚构的弹性张量  $\overline{\mathfrak{c}}$  。对于所选择的材料模型，这只是零。

    SymmetricTensor<4, dim> get_c_bar() const 
    { 
      return SymmetricTensor<4, dim>(); 
    } 
  }; 
// @sect3{Quadrature point history}  

// 正如在 step-18 中所看到的， <code> PointHistory </code> 类提供了一种在正交点存储数据的方法。 这里每个正交点都持有一个指向材料描述的指针。 因此，不同的材料模型可以用在域的不同区域。 在其他数据中，我们选择为正交点存储Kirchhoff应力 $\boldsymbol{\tau}$ 和正切 $J\mathfrak{c}$ 。

  template <int dim> 
  class PointHistory 
  { 
  public: 
    PointHistory() 
      : F_inv(Physics::Elasticity::StandardTensors<dim>::I) 
      , tau(SymmetricTensor<2, dim>()) 
      , d2Psi_vol_dJ2(0.0) 
      , dPsi_vol_dJ(0.0) 
      , Jc(SymmetricTensor<4, dim>()) 
    {} 

    virtual ~PointHistory() = default; 

// 第一个函数用于创建一个材料对象并正确初始化所有的张量。第二个函数根据当前的变形量 $\textrm{Grad}\mathbf{u}_{\textrm{n}}$ 、压力 $\widetilde{p}$ 和扩张 $\widetilde{J}$ 场值更新存储的数值和应力。

    void setup_lqp(const Parameters::AllParameters &parameters) 
    { 
      material = 
        std::make_shared<Material_Compressible_Neo_Hook_Three_Field<dim>>( 
          parameters.mu, parameters.nu); 
      update_values(Tensor<2, dim>(), 0.0, 1.0); 
    } 

// 为此，我们从位移梯度 $\textrm{Grad}\ \mathbf{u}$ 中计算出变形梯度 $\mathbf{F}$  ，即 $\mathbf{F}(\mathbf{u}) = \mathbf{I} + \textrm{Grad}\ \mathbf{u}$ ，然后让与这个正交点相关的材料模型进行自我更新。当计算变形梯度时，我们必须注意与哪些数据类型进行比较 $\mathbf{I} + \textrm{Grad}\ \mathbf{u}$ ：由于 $I$ 有数据类型SymmetricTensor，只要写 <code>I + Grad_u_n</code> 就可以将第二个参数转换为对称张量，进行求和，然后将结果投给Tensor（即可能是非对称张量的类型）。然而，由于 <code>Grad_u_n</code> 在一般情况下是非对称的，转换为SymmetricTensor将会失败。我们可以通过先将 $I$ 转换为Tensor，然后像在非对称张量之间一样执行加法，来避免这种来回折腾。

    void update_values(const Tensor<2, dim> &Grad_u_n, 
                       const double          p_tilde, 
                       const double          J_tilde) 
    { 
      const Tensor<2, dim> F = Physics::Elasticity::Kinematics::F(Grad_u_n); 
      material->update_material_data(F, p_tilde, J_tilde); 

// 材料已经更新，所以我们现在计算基尔霍夫应力 $\mathbf{\tau}$ ，切线 $J\mathfrak{c}$ 和体积自由能的一、二次导数。

// 我们还存储了变形梯度的逆值，因为我们经常使用它。

      F_inv         = invert(F); 
      tau           = material->get_tau(); 
      Jc            = material->get_Jc(); 
      dPsi_vol_dJ   = material->get_dPsi_vol_dJ(); 
      d2Psi_vol_dJ2 = material->get_d2Psi_vol_dJ2(); 
    } 

// 我们提供一个接口来检索某些数据。 下面是运动学变量。

    double get_J_tilde() const 
    { 
      return material->get_J_tilde(); 
    } 

    double get_det_F() const 
    { 
      return material->get_det_F(); 
    } 

    const Tensor<2, dim> &get_F_inv() const 
    { 
      return F_inv; 
    } 

// ...和动能变量。 这些在材料和全局切线矩阵以及残余装配操作中使用。

    double get_p_tilde() const 
    { 
      return material->get_p_tilde(); 
    } 

    const SymmetricTensor<2, dim> &get_tau() const 
    { 
      return tau; 
    } 

    double get_dPsi_vol_dJ() const 
    { 
      return dPsi_vol_dJ; 
    } 

    double get_d2Psi_vol_dJ2() const 
    { 
      return d2Psi_vol_dJ2; 
    } 

// 最后是切线。

    const SymmetricTensor<4, dim> &get_Jc() const 
    { 
      return Jc; 
    } 

// 在成员函数方面，这个类为它所代表的正交点存储了一个材料类型的副本，以备在域的不同区域使用不同的材料，以及变形梯度的逆值...

  private: 
    std::shared_ptr<Material_Compressible_Neo_Hook_Three_Field<dim>> material; 

    Tensor<2, dim> F_inv; 

// ...... 和应力型变量以及切线  $J\mathfrak{c}$  。

    SymmetricTensor<2, dim> tau; 
    double                  d2Psi_vol_dJ2; 
    double                  dPsi_vol_dJ; 

    SymmetricTensor<4, dim> Jc; 
  }; 
// @sect3{Quasi-static quasi-incompressible finite-strain solid}  

// Solid类是中心类，它代表了手头的问题。它遵循通常的方案，即它真正拥有的是一个构造函数、解构函数和一个 <code>run()</code> 函数，该函数将所有的工作分派给这个类的私有函数。

  template <int dim> 
  class Solid 
  { 
  public: 
    Solid(const std::string &input_file); 

    void run(); 

  private: 

// 在这个类的私有部分，我们首先向前声明一些对象，这些对象在使用WorkStream对象进行并行工作时使用（关于这方面的更多信息，请参见 @ref threads 模块）。

// 我们声明这样的结构，用于正切（刚度）矩阵和右手边矢量的计算，静态冷凝，以及更新正交点。

    struct PerTaskData_ASM; 
    struct ScratchData_ASM; 

    struct PerTaskData_SC; 
    struct ScratchData_SC; 

    struct PerTaskData_UQPH; 
    struct ScratchData_UQPH; 

// 我们从一个建立网格的成员函数开始收集。

    void make_grid(); 

// 设置要解决的有限元系统。

    void system_setup(); 

    void determine_component_extractors(); 

// 为增量位移场创建Dirichlet约束。

    void make_constraints(const int it_nr); 

// 使用多线程的几个函数来组装系统和右手边的矩阵。它们中的每一个都是包装函数，一个是在WorkStream模型中对一个单元进行工作的执行函数，另一个是将对这一个单元的工作复制到代表它的全局对象中。

    void assemble_system(); 

    void assemble_system_one_cell( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      ScratchData_ASM &                                     scratch, 
      PerTaskData_ASM &                                     data) const; 

// 还有类似的，执行全局静态冷凝。

    void assemble_sc(); 

    void assemble_sc_one_cell( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      ScratchData_SC &                                      scratch, 
      PerTaskData_SC &                                      data); 

    void copy_local_to_global_sc(const PerTaskData_SC &data); 

// 创建并更新正交点。在这里，没有数据需要被复制到全局对象中，所以copy_local_to_global函数是空的。

    void setup_qph(); 

    void update_qph_incremental(const BlockVector<double> &solution_delta); 

    void update_qph_incremental_one_cell( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      ScratchData_UQPH &                                    scratch, 
      PerTaskData_UQPH &                                    data); 

    void copy_local_to_global_UQPH(const PerTaskData_UQPH & /*data*/) 
    {} 

// 用牛顿-拉弗森方法求解位移。我们把这个函数分成非线性循环和解决线性化的Newton-Raphson步骤的函数。

    void solve_nonlinear_timestep(BlockVector<double> &solution_delta); 

    std::pair<unsigned int, double> 
    solve_linear_system(BlockVector<double> &newton_update); 

// 检索解决方案，以及后期处理和将数据写入文件。

    BlockVector<double> 
    get_total_solution(const BlockVector<double> &solution_delta) const; 

    void output_results() const; 

// 最后是一些描述当前状态的成员变量。一个用于描述问题设置的参数集合...

    Parameters::AllParameters parameters; 

// ...参考配置的体积...

    double vol_reference; 

// ......以及对解决问题的几何形状的描述。

    Triangulation<dim> triangulation; 

// 同时，记录当前时间和评估某些函数的时间

    Time                time; 
    mutable TimerOutput timer; 

// 一个存储正交点信息的对象。与 step-18 不同，这里采用了deal.II的本地正交点数据管理器。

    CellDataStorage<typename Triangulation<dim>::cell_iterator, 
                    PointHistory<dim>> 
      quadrature_point_history; 

// 对有限元系统的描述，包括位移多项式程度、自由度处理程序、每个单元的DoF数量以及用于从解向量中检索信息的提取器对象。

    const unsigned int               degree; 
    const FESystem<dim>              fe; 
    DoFHandler<dim>                  dof_handler; 
    const unsigned int               dofs_per_cell; 
    const FEValuesExtractors::Vector u_fe; 
    const FEValuesExtractors::Scalar p_fe; 
    const FEValuesExtractors::Scalar J_fe; 

// 说明块系统是如何安排的。有3个块，第一个包含一个矢量DOF  $\mathbf{u}$  ，而另外两个描述标量DOF， $\widetilde{p}$  和  $\widetilde{J}$  。

    static const unsigned int n_blocks          = 3; 
    static const unsigned int n_components      = dim + 2; 
    static const unsigned int first_u_component = 0; 
    static const unsigned int p_component       = dim; 
    static const unsigned int J_component       = dim + 1; 

    enum 
    { 
      u_dof = 0, 
      p_dof = 1, 
      J_dof = 2 
    }; 

    std::vector<types::global_dof_index> dofs_per_block; 
    std::vector<types::global_dof_index> element_indices_u; 
    std::vector<types::global_dof_index> element_indices_p; 
    std::vector<types::global_dof_index> element_indices_J; 

//单元和面的高斯正交规则。单元和面的正交点的数量被记录下来。

    const QGauss<dim>     qf_cell; 
    const QGauss<dim - 1> qf_face; 
    const unsigned int    n_q_points; 
    const unsigned int    n_q_points_f; 

// 用于存储收敛的解和右手边向量以及切线矩阵的对象。有一个AffineConstraints对象，用于跟踪约束条件。 我们利用了为块状系统设计的稀疏性模式。

    AffineConstraints<double> constraints; 
    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> tangent_matrix; 
    BlockVector<double>       system_rhs; 
    BlockVector<double>       solution_n; 
//然后
//定义一些变量来存储规范，并更新规范和归一化系数。

    struct Errors 
    { 
      Errors() 
        : norm(1.0) 
        , u(1.0) 
        , p(1.0) 
        , J(1.0) 
      {} 

      void reset() 
      { 
        norm = 1.0; 
        u    = 1.0; 
        p    = 1.0; 
        J    = 1.0; 
      } 
      void normalize(const Errors &rhs) 
      { 
        if (rhs.norm != 0.0) 
          norm /= rhs.norm; 
        if (rhs.u != 0.0) 
          u /= rhs.u; 
        if (rhs.p != 0.0) 
          p /= rhs.p; 
        if (rhs.J != 0.0) 
          J /= rhs.J; 
      } 

      double norm, u, p, J; 
    }; 

    Errors error_residual, error_residual_0, error_residual_norm, error_update, 
      error_update_0, error_update_norm; 

// 计算误差措施的方法

    void get_error_residual(Errors &error_residual); 

    void get_error_update(const BlockVector<double> &newton_update, 
                          Errors &                   error_update); 

    std::pair<double, double> get_error_dilation() const; 

// 计算空间配置中的体积

    double compute_vol_current() const; 

// 以悦目的方式向屏幕打印信息...

    static void print_conv_header(); 

    void print_conv_footer(); 
  }; 
// @sect3{Implementation of the <code>Solid</code> class}  
// @sect4{Public interface}  

// 我们使用从参数文件中提取的数据来初始化Solid类。

  template <int dim> 
  Solid<dim>::Solid(const std::string &input_file) 
    : parameters(input_file) 
    , vol_reference(0.) 
    , triangulation(Triangulation<dim>::maximum_smoothing) 
    , time(parameters.end_time, parameters.delta_t) 
    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times) 
    , degree(parameters.poly_degree) 
    , 

// 有限元系统是由昏暗的连续位移DOF和不连续的压力和膨胀DOF组成。为了满足Babuska-Brezzi或LBB稳定性条件（见Hughes（2000）），我们设置了一个 $Q_n \times DGPM_{n-1} \times DGPM_{n-1}$ 系统。  $Q_2 \times DGPM_1 \times DGPM_1$ 元素满足这个条件，而 $Q_1 \times DGPM_0 \times DGPM_0$ 元素不满足。然而，事实证明，后者还是表现出良好的收敛特性。

    fe(FE_Q<dim>(parameters.poly_degree), 
       dim, // displacement 
       FE_DGPMonomial<dim>(parameters.poly_degree - 1), 
       1, // pressure 
       FE_DGPMonomial<dim>(parameters.poly_degree - 1), 
       1) 
    , // dilatation 
    dof_handler(triangulation) 
    , dofs_per_cell(fe.n_dofs_per_cell()) 
    , u_fe(first_u_component) 
    , p_fe(p_component) 
    , J_fe(J_component) 
    , dofs_per_block(n_blocks) 
    , qf_cell(parameters.quad_order) 
    , qf_face(parameters.quad_order) 
    , n_q_points(qf_cell.size()) 
    , n_q_points_f(qf_face.size()) 
  { 
    Assert(dim == 2 || dim == 3, 
           ExcMessage("This problem only works in 2 or 3 space dimensions.")); 
    determine_component_extractors(); 
  } 

// 在解决准静态问题时，时间成为一个加载参数，即我们随着时间线性增加加载量，使得这两个概念可以互换。我们选择用恒定的时间步长来线性递增时间。

// 我们从预处理开始，设置初始扩张值，然后输出初始网格，然后开始模拟，开始第一次时间（和载荷）递增。

// 在对初始解场施加约束 $\widetilde{J}=1$ 时，必须注意（或者至少要考虑一下）。该约束对应于未变形构型中变形梯度的行列式，也就是身份张量。我们使用FE_DGPMonomial基数来插值扩张场，因此我们不能简单地将相应的dof设置为unity，因为它们对应于单项式系数。因此，我们使用 VectorTools::project 函数来为我们做这项工作。 VectorTools::project 函数需要一个参数，表明悬挂节点的约束。我们在这个程序中没有 所以我们必须创建一个约束对象。在原始状态下，约束对象是没有排序的，必须先进行排序（使用 AffineConstraints::close 函数）才能使用。请看  step-21  以了解更多信息。我们只需要强制执行扩张的初始条件。为了做到这一点，我们使用ComponentSelectFunction，它作为一个掩码，将n_components的J_component设置为1。 这正是我们想要的。请看 step-20 中的用法，了解更多信息。

  template <int dim> 
  void Solid<dim>::run() 
  { 
    make_grid(); 
    system_setup(); 
    { 
      AffineConstraints<double> constraints; 
      constraints.close(); 

      const ComponentSelectFunction<dim> J_mask(J_component, n_components); 

      VectorTools::project( 
        dof_handler, constraints, QGauss<dim>(degree + 2), J_mask, solution_n); 
    } 
    output_results(); 
    time.increment(); 

// 然后我们宣布增量解决方案更新 $\varDelta \mathbf{\Xi} \dealcoloneq \{\varDelta \mathbf{u},\varDelta \widetilde{p}, \varDelta \widetilde{J} \}$ 并开始在时域上循环。

// 在开始的时候，我们重置这个时间步长的解决方案更新...

    BlockVector<double> solution_delta(dofs_per_block); 
    while (time.current() < time.end()) 
      { 
        solution_delta = 0.0; 

// ...求解当前时间步长并更新总解向量  $\mathbf{\Xi}_{\textrm{n}} = \mathbf{\Xi}_{\textrm{n-1}} + \varDelta \mathbf{\Xi}$  ...

        solve_nonlinear_timestep(solution_delta); 
        solution_n += solution_delta; 

// ...并在快乐地进入下一个时间步骤之前绘制结果。

        output_results(); 
        time.increment(); 
      } 
  } 
// @sect3{Private interface}  
// @sect4{Threading-building-blocks structures}  

// 第一组私有成员函数与并行化有关。我们使用线程积木库（TBB）来执行尽可能多的计算密集型分布式任务。特别是，我们使用TBB组装正切矩阵和右手向量、静态凝结贡献，以及更新存储在正交点的数据。我们在这方面的主要工具是WorkStream类（更多信息见 @ref 线程模块）。

// 首先我们要处理正切矩阵和右手边的装配结构。PerTaskData对象存储了本地对全局系统的贡献。

  template <int dim> 
  struct Solid<dim>::PerTaskData_ASM 
  { 
    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_rhs; 
    std::vector<types::global_dof_index> local_dof_indices; 

    PerTaskData_ASM(const unsigned int dofs_per_cell) 
      : cell_matrix(dofs_per_cell, dofs_per_cell) 
      , cell_rhs(dofs_per_cell) 
      , local_dof_indices(dofs_per_cell) 
    {} 

    void reset() 
    { 
      cell_matrix = 0.0; 
      cell_rhs    = 0.0; 
    } 
  }; 

// 另一方面，ScratchData对象存储了较大的对象，如形状函数值数组（  <code>Nx</code>  ）和形状函数梯度和对称梯度向量，我们将在装配时使用。

  template <int dim> 
  struct Solid<dim>::ScratchData_ASM 
  { 
    FEValues<dim>     fe_values; 
    FEFaceValues<dim> fe_face_values; 

    std::vector<std::vector<double>>                  Nx; 
    std::vector<std::vector<Tensor<2, dim>>>          grad_Nx; 
    std::vector<std::vector<SymmetricTensor<2, dim>>> symm_grad_Nx; 

    ScratchData_ASM(const FiniteElement<dim> &fe_cell, 
                    const QGauss<dim> &       qf_cell, 
                    const UpdateFlags         uf_cell, 
                    const QGauss<dim - 1> &   qf_face, 
                    const UpdateFlags         uf_face) 
      : fe_values(fe_cell, qf_cell, uf_cell) 
      , fe_face_values(fe_cell, qf_face, uf_face) 
      , Nx(qf_cell.size(), std::vector<double>(fe_cell.n_dofs_per_cell())) 
      , grad_Nx(qf_cell.size(), 
                std::vector<Tensor<2, dim>>(fe_cell.n_dofs_per_cell())) 
      , symm_grad_Nx(qf_cell.size(), 
                     std::vector<SymmetricTensor<2, dim>>( 
                       fe_cell.n_dofs_per_cell())) 
    {} 

    ScratchData_ASM(const ScratchData_ASM &rhs) 
      : fe_values(rhs.fe_values.get_fe(), 
                  rhs.fe_values.get_quadrature(), 
                  rhs.fe_values.get_update_flags()) 
      , fe_face_values(rhs.fe_face_values.get_fe(), 
                       rhs.fe_face_values.get_quadrature(), 
                       rhs.fe_face_values.get_update_flags()) 
      , Nx(rhs.Nx) 
      , grad_Nx(rhs.grad_Nx) 
      , symm_grad_Nx(rhs.symm_grad_Nx) 
    {} 

    void reset() 
    { 
      const unsigned int n_q_points      = Nx.size(); 
      const unsigned int n_dofs_per_cell = Nx[0].size(); 
      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
        { 
          Assert(Nx[q_point].size() == n_dofs_per_cell, ExcInternalError()); 
          Assert(grad_Nx[q_point].size() == n_dofs_per_cell, 
                 ExcInternalError()); 
          Assert(symm_grad_Nx[q_point].size() == n_dofs_per_cell, 
                 ExcInternalError()); 
          for (unsigned int k = 0; k < n_dofs_per_cell; ++k) 
            { 
              Nx[q_point][k]           = 0.0; 
              grad_Nx[q_point][k]      = 0.0; 
              symm_grad_Nx[q_point][k] = 0.0; 
            } 
        } 
    } 
  }; 

// 然后我们定义结构来组装静态凝结的切线矩阵。回顾一下，我们希望解决一个基于位移的公式。由于 $\widetilde{p}$ 和 $\widetilde{J}$ 字段在元素层面上是不连续的，所以我们在元素层面上进行缩合。 由于这些操作是基于矩阵的，我们需要设置一些矩阵来存储一些切线矩阵子块的局部贡献。 我们把这些放在PerTaskData结构中。

// 我们选择不在 <code>reset()</code> 函数中重置任何数据，因为矩阵提取和替换工具会处理这个问题。

  template <int dim> 
  struct Solid<dim>::PerTaskData_SC 
  { 
    FullMatrix<double>                   cell_matrix; 
    std::vector<types::global_dof_index> local_dof_indices; 

    FullMatrix<double> k_orig; 
    FullMatrix<double> k_pu; 
    FullMatrix<double> k_pJ; 
    FullMatrix<double> k_JJ; 
    FullMatrix<double> k_pJ_inv; 
    FullMatrix<double> k_bbar; 
    FullMatrix<double> A; 
    FullMatrix<double> B; 
    FullMatrix<double> C; 

    PerTaskData_SC(const unsigned int dofs_per_cell, 
                   const unsigned int n_u, 
                   const unsigned int n_p, 
                   const unsigned int n_J) 
      : cell_matrix(dofs_per_cell, dofs_per_cell) 
      , local_dof_indices(dofs_per_cell) 
      , k_orig(dofs_per_cell, dofs_per_cell) 
      , k_pu(n_p, n_u) 
      , k_pJ(n_p, n_J) 
      , k_JJ(n_J, n_J) 
      , k_pJ_inv(n_p, n_J) 
      , k_bbar(n_u, n_u) 
      , A(n_J, n_u) 
      , B(n_J, n_u) 
      , C(n_p, n_u) 
    {} 

    void reset() 
    {} 
  }; 

// 我们希望在这里执行的操作的ScratchData对象是空的，因为我们不需要临时数据，但它仍然需要为当前deal.II中TBB的实现而定义。 所以我们为此创建了一个假的结构。

  template <int dim> 
  struct Solid<dim>::ScratchData_SC 
  { 
    void reset() 
    {} 
  }; 

// 最后我们定义结构以协助更新正交点信息。与SC的装配过程类似，我们不需要PerTaskData对象（因为这里没有什么可存储的），但还是必须定义一个。请注意，这是因为对于我们这里的操作--更新正交点的数据--是纯粹的局部操作：我们在每个单元上做的事情在每个单元上都会被消耗掉，没有像使用WorkStream类时通常会有的全局聚合操作。我们仍然必须定义每个任务的数据结构，这表明WorkStream类可能不适合这种操作（原则上，我们可以简单地为每个单元使用 Threads::new_task 创建一个新的任务），但无论如何这样做也没有什么坏处。此外，如果一个正交点有不同的材料模型，需要不同程度的计算费用，那么这里使用的方法可能是有利的。

  template <int dim> 
  struct Solid<dim>::PerTaskData_UQPH 
  { 
    void reset() 
    {} 
  }; 

// ScratchData对象将被用来存储解向量的别名，这样我们就不必复制这个大的数据结构。然后我们定义一些向量来提取正交点的解值和梯度。

  template <int dim> 
  struct Solid<dim>::ScratchData_UQPH 
  { 
    const BlockVector<double> &solution_total; 

    std::vector<Tensor<2, dim>> solution_grads_u_total; 
    std::vector<double>         solution_values_p_total; 
    std::vector<double>         solution_values_J_total; 

    FEValues<dim> fe_values; 

    ScratchData_UQPH(const FiniteElement<dim> & fe_cell, 
                     const QGauss<dim> &        qf_cell, 
                     const UpdateFlags          uf_cell, 
                     const BlockVector<double> &solution_total) 
      : solution_total(solution_total) 
      , solution_grads_u_total(qf_cell.size()) 
      , solution_values_p_total(qf_cell.size()) 
      , solution_values_J_total(qf_cell.size()) 
      , fe_values(fe_cell, qf_cell, uf_cell) 
    {} 

    ScratchData_UQPH(const ScratchData_UQPH &rhs) 
      : solution_total(rhs.solution_total) 
      , solution_grads_u_total(rhs.solution_grads_u_total) 
      , solution_values_p_total(rhs.solution_values_p_total) 
      , solution_values_J_total(rhs.solution_values_J_total) 
      , fe_values(rhs.fe_values.get_fe(), 
                  rhs.fe_values.get_quadrature(), 
                  rhs.fe_values.get_update_flags()) 
    {} 

    void reset() 
    { 
      const unsigned int n_q_points = solution_grads_u_total.size(); 
      for (unsigned int q = 0; q < n_q_points; ++q) 
        { 
          solution_grads_u_total[q]  = 0.0; 
          solution_values_p_total[q] = 0.0; 
          solution_values_J_total[q] = 0.0; 
        } 
    } 
  }; 
// @sect4{Solid::make_grid}  

// 进入第一个私有成员函数。在这里我们创建域的三角形，为此我们选择了按比例的立方体，每个面都有一个边界ID号。 对于缩进问题，网格必须至少被细化一次。

// 然后，我们确定参考配置的体积，并将其打印出来进行比较。

  template <int dim> 
  void Solid<dim>::make_grid() 
  { 
    GridGenerator::hyper_rectangle( 
      triangulation, 
      (dim == 3 ? Point<dim>(0.0, 0.0, 0.0) : Point<dim>(0.0, 0.0)), 
      (dim == 3 ? Point<dim>(1.0, 1.0, 1.0) : Point<dim>(1.0, 1.0)), 
      true); 
    GridTools::scale(parameters.scale, triangulation); 
    triangulation.refine_global(std::max(1U, parameters.global_refinement)); 

    vol_reference = GridTools::volume(triangulation); 
    std::cout << "Grid:\n\t Reference volume: " << vol_reference << std::endl; 

// 由于我们希望对顶面的一个补丁应用诺伊曼BC，我们必须找到域的这一部分的单元格面，并用一个明显的边界ID号来标记它们。 我们要找的面在+y面上，将得到边界ID 6（0到5已经在创建立方体域的六个面时使用了）。

    for (const auto &cell : triangulation.active_cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        { 
          if (face->at_boundary() == true && 
              face->center()[1] == 1.0 * parameters.scale) 
            { 
              if (dim == 3) 
                { 
                  if (face->center()[0] < 0.5 * parameters.scale && 
                      face->center()[2] < 0.5 * parameters.scale) 
                    face->set_boundary_id(6); 
                } 
              else 
                { 
                  if (face->center()[0] < 0.5 * parameters.scale) 
                    face->set_boundary_id(6); 
                } 
            } 
        } 
  } 
// @sect4{Solid::system_setup}  

// 接下来我们描述FE系统是如何设置的。 我们首先确定每块的分量数量。由于位移是一个矢量分量，所以前两个分量属于它，而后两个分量描述标量压力和扩张DOF。

  template <int dim> 
  void Solid<dim>::system_setup() 
  { 
    timer.enter_subsection("Setup system"); 

    std::vector<unsigned int> block_component(n_components, 
                                              u_dof); // Displacement 
    block_component[p_component] = p_dof;             // Pressure 
    block_component[J_component] = J_dof;             // Dilatation 

// 然后，DOF处理程序被初始化，我们以一种有效的方式对网格进行重新编号。我们还记录了每块DOF的数量。

    dof_handler.distribute_dofs(fe); 
    DoFRenumbering::Cuthill_McKee(dof_handler); 
    DoFRenumbering::component_wise(dof_handler, block_component); 

    dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, block_component); 

    std::cout << "Triangulation:" 
              << "\n\t Number of active cells: " 
              << triangulation.n_active_cells() 
              << "\n\t Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

// 设置稀疏模式和切线矩阵

    tangent_matrix.clear(); 
    { 
      const types::global_dof_index n_dofs_u = dofs_per_block[u_dof]; 
      const types::global_dof_index n_dofs_p = dofs_per_block[p_dof]; 
      const types::global_dof_index n_dofs_J = dofs_per_block[J_dof]; 

      BlockDynamicSparsityPattern dsp(n_blocks, n_blocks); 

      dsp.block(u_dof, u_dof).reinit(n_dofs_u, n_dofs_u); 
      dsp.block(u_dof, p_dof).reinit(n_dofs_u, n_dofs_p); 
      dsp.block(u_dof, J_dof).reinit(n_dofs_u, n_dofs_J); 

      dsp.block(p_dof, u_dof).reinit(n_dofs_p, n_dofs_u); 
      dsp.block(p_dof, p_dof).reinit(n_dofs_p, n_dofs_p); 
      dsp.block(p_dof, J_dof).reinit(n_dofs_p, n_dofs_J); 

      dsp.block(J_dof, u_dof).reinit(n_dofs_J, n_dofs_u); 
      dsp.block(J_dof, p_dof).reinit(n_dofs_J, n_dofs_p); 
      dsp.block(J_dof, J_dof).reinit(n_dofs_J, n_dofs_J); 
      dsp.collect_sizes(); 

// 全局系统矩阵最初具有以下结构 
// @f{align*}
//  \underbrace{\begin{bmatrix}
//    \mathsf{\mathbf{K}}_{uu}  & \mathsf{\mathbf{K}}_{u\widetilde{p}} &
//    \mathbf{0}
//    \\ \mathsf{\mathbf{K}}_{\widetilde{p}u} & \mathbf{0} &
//    \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}
//    \\ \mathbf{0} & \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}} &
//    \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
//  \end{bmatrix}}_{\mathsf{\mathbf{K}}(\mathbf{\Xi}_{\textrm{i}})}
//       \underbrace{\begin{bmatrix}
//           d \mathsf{u}
//       \\  d \widetilde{\mathsf{\mathbf{p}}}
//       \\  d \widetilde{\mathsf{\mathbf{J}}}
//       \end{bmatrix}}_{d \mathbf{\Xi}}
//  =
//  \underbrace{\begin{bmatrix}
//   \mathsf{\mathbf{F}}_{u}(\mathbf{u}_{\textrm{i}})
//   \\ \mathsf{\mathbf{F}}_{\widetilde{p}}(\widetilde{p}_{\textrm{i}})
//   \\ \mathsf{\mathbf{F}}_{\widetilde{J}}(\widetilde{J}_{\textrm{i}})
// \end{bmatrix}}_{ \mathsf{\mathbf{F}}(\mathbf{\Xi}_{\textrm{i}}) } \, .
//  @f}
//   我们优化稀疏模式以反映这一结构，并防止为右对角块成分创建不必要的数据。

      Table<2, DoFTools::Coupling> coupling(n_components, n_components); 
      for (unsigned int ii = 0; ii < n_components; ++ii) 
        for (unsigned int jj = 0; jj < n_components; ++jj) 
          if (((ii < p_component) && (jj == J_component)) || 
              ((ii == J_component) && (jj < p_component)) || 
              ((ii == p_component) && (jj == p_component))) 
            coupling[ii][jj] = DoFTools::none; 
          else 
            coupling[ii][jj] = DoFTools::always; 
      DoFTools::make_sparsity_pattern( 
        dof_handler, coupling, dsp, constraints, false); 
      sparsity_pattern.copy_from(dsp); 
    } 

    tangent_matrix.reinit(sparsity_pattern); 

// 然后，我们设置了存储向量

    system_rhs.reinit(dofs_per_block); 
    system_rhs.collect_sizes(); 

    solution_n.reinit(dofs_per_block); 
    solution_n.collect_sizes(); 

// ...最后设置正交点历史。

    setup_qph(); 

    timer.leave_subsection(); 
  } 
//接下来我们从FE系统中计算出一些信息，描述哪些局部元素DOF连接到哪个块组件上。 这将在后面用于从全局矩阵中提取子块。

// 本质上，我们所需要的就是让FES系统对象指出参考单元上的DOF连接到哪个块状部件上。 目前，插值域的设置是这样的：0表示位移DOF，1表示压力DOF，2表示膨胀DOF。

  template <int dim> 
  void Solid<dim>::determine_component_extractors() 
  { 
    element_indices_u.clear(); 
    element_indices_p.clear(); 
    element_indices_J.clear(); 

    for (unsigned int k = 0; k < fe.n_dofs_per_cell(); ++k) 
      { 
        const unsigned int k_group = fe.system_to_base_index(k).first.first; 
        if (k_group == u_dof) 
          element_indices_u.push_back(k); 
        else if (k_group == p_dof) 
          element_indices_p.push_back(k); 
        else if (k_group == J_dof) 
          element_indices_J.push_back(k); 
        else 
          { 
            Assert(k_group <= J_dof, ExcInternalError()); 
          } 
      } 
  } 
// @sect4{Solid::setup_qph}  用于存储正交信息的方法已经在  step-18  中描述。这里我们为SMP机器实现一个类似的设置。

// 首先，实际的QPH数据对象被创建。这必须在网格被细化到最细的程度后才能完成。

  template <int dim> 
  void Solid<dim>::setup_qph() 
  { 
    std::cout << "    Setting up quadrature point data..." << std::endl; 

    quadrature_point_history.initialize(triangulation.begin_active(), 
                                        triangulation.end(), 
                                        n_q_points); 

// 接下来我们设置初始正交点数据。请注意，当检索正交点数据时，它将作为一个智能指针的向量返回。

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        const std::vector<std::shared_ptr<PointHistory<dim>>> lqph = 
          quadrature_point_history.get_data(cell); 
        Assert(lqph.size() == n_q_points, ExcInternalError()); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          lqph[q_point]->setup_lqp(parameters); 
      } 
  } 
// @sect4{Solid::update_qph_incremental}  由于QP信息的更新经常发生，并且涉及一些昂贵的操作，我们定义了一个多线程的方法，将任务分布在一些CPU核心上。

// 要开始这样做，首先我们需要获得这个牛顿增量时的总解，然后创建初始的从头开始的副本和复制数据对象。

  template <int dim> 
  void 
  Solid<dim>::update_qph_incremental(const BlockVector<double> &solution_delta) 
  { 
    timer.enter_subsection("Update QPH data"); 
    std::cout << " UQPH " << std::flush; 

    const BlockVector<double> solution_total( 
      get_total_solution(solution_delta)); 

    const UpdateFlags uf_UQPH(update_values | update_gradients); 
    PerTaskData_UQPH  per_task_data_UQPH; 
    ScratchData_UQPH  scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total); 

// 然后，我们将它们和单格更新函数传递给WorkStream进行处理。

    WorkStream::run(dof_handler.active_cell_iterators(), 
                    *this, 
                    &Solid::update_qph_incremental_one_cell, 
                    &Solid::copy_local_to_global_UQPH, 
                    scratch_data_UQPH, 
                    per_task_data_UQPH); 

    timer.leave_subsection(); 
  } 

// 现在我们描述一下我们如何从解决方案向量中提取数据，并将其传递给每个QP存储对象进行处理。

  template <int dim> 
  void Solid<dim>::update_qph_incremental_one_cell( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    ScratchData_UQPH &                                    scratch, 
    PerTaskData_UQPH & /*data*/) 
  { 
    const std::vector<std::shared_ptr<PointHistory<dim>>> lqph = 
      quadrature_point_history.get_data(cell); 
    Assert(lqph.size() == n_q_points, ExcInternalError()); 

    Assert(scratch.solution_grads_u_total.size() == n_q_points, 
           ExcInternalError()); 
    Assert(scratch.solution_values_p_total.size() == n_q_points, 
           ExcInternalError()); 
    Assert(scratch.solution_values_J_total.size() == n_q_points, 
           ExcInternalError()); 

    scratch.reset(); 

// 我们首先需要找到当前单元内正交点的数值和梯度，然后利用位移梯度和总压力及扩张解数值更新每个局部QP。

    scratch.fe_values.reinit(cell); 
    scratch.fe_values[u_fe].get_function_gradients( 
      scratch.solution_total, scratch.solution_grads_u_total); 
    scratch.fe_values[p_fe].get_function_values( 
      scratch.solution_total, scratch.solution_values_p_total); 
    scratch.fe_values[J_fe].get_function_values( 
      scratch.solution_total, scratch.solution_values_J_total); 

    for (const unsigned int q_point : 
         scratch.fe_values.quadrature_point_indices()) 
      lqph[q_point]->update_values(scratch.solution_grads_u_total[q_point], 
                                   scratch.solution_values_p_total[q_point], 
                                   scratch.solution_values_J_total[q_point]); 
  } 
// @sect4{Solid::solve_nonlinear_timestep}  

// 下一个函数是牛顿-拉弗逊方案的驱动方法。在它的顶部，我们创建一个新的向量来存储当前的牛顿更新步骤，重置错误存储对象并打印求解器头。

  template <int dim> 
  void Solid<dim>::solve_nonlinear_timestep(BlockVector<double> &solution_delta) 
  { 
    std::cout << std::endl 
              << "Timestep " << time.get_timestep() << " @ " << time.current() 
              << "s" << std::endl; 

    BlockVector<double> newton_update(dofs_per_block); 

    error_residual.reset(); 
    error_residual_0.reset(); 
    error_residual_norm.reset(); 
    error_update.reset(); 
    error_update_0.reset(); 
    error_update_norm.reset(); 

    print_conv_header(); 

// 我们现在进行一些牛顿迭代来迭代解决这个非线性问题。 由于问题是完全非线性的，而且我们使用的是完全牛顿方法，所以存储在切线矩阵和右手边向量中的数据是不能重复使用的，必须在每个牛顿步骤中清除。然后，我们最初建立线性系统并检查收敛性（并在第一次迭代中存储这个值）。rhs向量的无约束DOF持有失衡的力，并共同决定是否达到了平衡解。

// 尽管对于这个特定的问题，我们可以在组合系统矩阵之前构建RHS向量，但为了扩展性，我们选择不这样做。分别组装RHS向量和系统矩阵的好处是，后者是一个昂贵的操作，我们可以通过在达到收敛时不组装切线矩阵来避免一个额外的组装过程。然而，这使得使用MPI并行化代码变得更加困难。此外，当把问题扩展到瞬态情况时，由于时间离散化和对速度和加速度场的约束应用，可能会对RHS产生额外的贡献。

    unsigned int newton_iteration = 0; 
    for (; newton_iteration < parameters.max_iterations_NR; ++newton_iteration) 
      { 
        std::cout << " " << std::setw(2) << newton_iteration << " " 
                  << std::flush; 

// 我们构建线性系统，但暂不求解它（这一步应该比装配要贵得多）。

        make_constraints(newton_iteration); 
        assemble_system(); 

// 我们现在可以确定归一化剩余误差，并检查解决方案的收敛性。

        get_error_residual(error_residual); 
        if (newton_iteration == 0) 
          error_residual_0 = error_residual; 

        error_residual_norm = error_residual; 
        error_residual_norm.normalize(error_residual_0); 

        if (newton_iteration > 0 && error_update_norm.u <= parameters.tol_u && 
            error_residual_norm.u <= parameters.tol_f) 
          { 
            std::cout << " CONVERGED! " << std::endl; 
            print_conv_footer(); 

            break; 
          } 

// 如果我们决定要继续迭代，我们就解决线性化系统。

        const std::pair<unsigned int, double> lin_solver_output = 
          solve_linear_system(newton_update); 

// 我们现在可以确定归一化的牛顿更新误差。

        get_error_update(newton_update, error_update); 
        if (newton_iteration == 0) 
          error_update_0 = error_update; 

        error_update_norm = error_update; 
        error_update_norm.normalize(error_update_0); 

// 最后，由于我们隐含地接受了求解步骤，我们可以对当前时间步骤的求解增量进行实际更新，更新与这个新位移和应力状态有关的所有正交点信息，并继续迭代。

        solution_delta += newton_update; 
        update_qph_incremental(solution_delta); 

        std::cout << " | " << std::fixed << std::setprecision(3) << std::setw(7) 
                  << std::scientific << lin_solver_output.first << "  " 
                  << lin_solver_output.second << "  " 
                  << error_residual_norm.norm << "  " << error_residual_norm.u 
                  << "  " << error_residual_norm.p << "  " 
                  << error_residual_norm.J << "  " << error_update_norm.norm 
                  << "  " << error_update_norm.u << "  " << error_update_norm.p 
                  << "  " << error_update_norm.J << "  " << std::endl; 
      } 

// 在最后，如果发现我们事实上做了比参数文件允许的更多的迭代，我们会引发一个异常，可以在main()函数中捕获。调用<code>AssertThrow(condition, exc_object)</code>实质上等同于<code>if (!cond) throw exc_object;</code>，但前一种形式在异常对象中填充了某些字段，以确定异常发生的位置（文件名和行号），使之更容易识别问题发生的位置。

    AssertThrow(newton_iteration < parameters.max_iterations_NR, 
                ExcMessage("No convergence in nonlinear solver!")); 
  } 
// @sect4{Solid::print_conv_header and Solid::print_conv_footer}  

// 这个程序在一个漂亮的表格中打印出数据，这个表格在每次迭代的基础上被更新。接下来的两个函数设置了表头和表脚。

  template <int dim> 
  void Solid<dim>::print_conv_header() 
  { 
    static const unsigned int l_width = 150; 

    for (unsigned int i = 0; i < l_width; ++i) 
      std::cout << "_"; 
    std::cout << std::endl; 

    std::cout << "               SOLVER STEP               " 
              << " |  LIN_IT   LIN_RES    RES_NORM    " 
              << " RES_U     RES_P      RES_J     NU_NORM     " 
              << " NU_U       NU_P       NU_J " << std::endl; 

    for (unsigned int i = 0; i < l_width; ++i) 
      std::cout << "_"; 
    std::cout << std::endl; 
  } 

  template <int dim> 
  void Solid<dim>::print_conv_footer() 
  { 
    static const unsigned int l_width = 150; 

    for (unsigned int i = 0; i < l_width; ++i) 
      std::cout << "_"; 
    std::cout << std::endl; 

    const std::pair<double, double> error_dil = get_error_dilation(); 

    std::cout << "Relative errors:" << std::endl 
              << "Displacement:\t" << error_update.u / error_update_0.u 
              << std::endl 
              << "Force: \t\t" << error_residual.u / error_residual_0.u 
              << std::endl 
              << "Dilatation:\t" << error_dil.first << std::endl 
              << "v / V_0:\t" << error_dil.second * vol_reference << " / " 
              << vol_reference << " = " << error_dil.second << std::endl; 
  } 
// @sect4{Solid::get_error_dilation}  

// 计算空间配置中的域的体积

  template <int dim> 
  double Solid<dim>::compute_vol_current() const 
  { 
    double vol_current = 0.0; 

    FEValues<dim> fe_values(fe, qf_cell, update_JxW_values); 

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 

// 与之前调用的不同，在这个例子中，正交点的数据是特别不可修改的，因为我们将只访问数据。我们通过将这个更新函数标记为常量来确保正确的get_data函数被调用。

        const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph = 
          quadrature_point_history.get_data(cell); 
        Assert(lqph.size() == n_q_points, ExcInternalError()); 

        for (const unsigned int q_point : fe_values.quadrature_point_indices()) 
          { 
            const double det_F_qp = lqph[q_point]->get_det_F(); 
            const double JxW      = fe_values.JxW(q_point); 

            vol_current += det_F_qp * JxW; 
          } 
      } 
    Assert(vol_current > 0.0, ExcInternalError()); 
    return vol_current; 
  } 

//从 $L^2$ 的误差 $ \bigl[ \int_{\Omega_0} {[ J - \widetilde{J}]}^{2}\textrm{d}V \bigr]^{1/2}$ 中计算出扩张 $\widetilde{J}$ $J \dealcoloneq \textrm{det}\ \mathbf{F}$ 的吻合程度。我们还返回域的当前体积与参考体积的比率。这对于不可压缩介质来说是很有意义的，因为我们要检查等熵约束的执行情况。

  template <int dim> 
  std::pair<double, double> Solid<dim>::get_error_dilation() const 
  { 
    double dil_L2_error = 0.0; 

    FEValues<dim> fe_values(fe, qf_cell, update_JxW_values); 

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 

        const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph = 
          quadrature_point_history.get_data(cell); 
        Assert(lqph.size() == n_q_points, ExcInternalError()); 

        for (const unsigned int q_point : fe_values.quadrature_point_indices()) 
          { 
            const double det_F_qp   = lqph[q_point]->get_det_F(); 
            const double J_tilde_qp = lqph[q_point]->get_J_tilde(); 
            const double the_error_qp_squared = 
              std::pow((det_F_qp - J_tilde_qp), 2); 
            const double JxW = fe_values.JxW(q_point); 

            dil_L2_error += the_error_qp_squared * JxW; 
          } 
      } 

    return std::make_pair(std::sqrt(dil_L2_error), 
                          compute_vol_current() / vol_reference); 
  } 
// @sect4{Solid::get_error_residual}  

// 确定问题的真实残差误差。 也就是说，确定无约束自由度的残差误差。 注意，要做到这一点，我们需要忽略受约束的自由度，将这些向量分量的残差设置为零。

  template <int dim> 
  void Solid<dim>::get_error_residual(Errors &error_residual) 
  { 
    BlockVector<double> error_res(dofs_per_block); 

    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i) 
      if (!constraints.is_constrained(i)) 
        error_res(i) = system_rhs(i); 

    error_residual.norm = error_res.l2_norm(); 
    error_residual.u    = error_res.block(u_dof).l2_norm(); 
    error_residual.p    = error_res.block(p_dof).l2_norm(); 
    error_residual.J    = error_res.block(J_dof).l2_norm(); 
  } 
// @sect4{Solid::get_error_update}  

// 确定问题的真实牛顿更新误差

  template <int dim> 
  void Solid<dim>::get_error_update(const BlockVector<double> &newton_update, 
                                    Errors &                   error_update) 
  { 
    BlockVector<double> error_ud(dofs_per_block); 
    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i) 
      if (!constraints.is_constrained(i)) 
        error_ud(i) = newton_update(i); 

    error_update.norm = error_ud.l2_norm(); 
    error_update.u    = error_ud.block(u_dof).l2_norm(); 
    error_update.p    = error_ud.block(p_dof).l2_norm(); 
    error_update.J    = error_ud.block(J_dof).l2_norm(); 
  } 

//  @sect4{Solid::get_total_solution}  

// 这个函数提供了总解，它在任何牛顿步都有效。这是必须的，因为为了减少计算误差，总解只在时间步数结束时更新。

  template <int dim> 
  BlockVector<double> Solid<dim>::get_total_solution( 
    const BlockVector<double> &solution_delta) const 
  { 
    BlockVector<double> solution_total(solution_n); 
    solution_total += solution_delta; 
    return solution_total; 
  } 
// @sect4{Solid::assemble_system}  

// 由于我们使用TBB进行装配，我们只需设置一份流程所需的数据结构，并将其与装配函数一起传递给WorkStream对象进行处理。请注意，我们必须确保在任何装配操作发生之前，矩阵和RHS向量被重置。此外，由于我们描述的是一个诺伊曼BC的问题，我们将需要面的法线，因此必须在面的更新标志中指定这个。

  template <int dim> 
  void Solid<dim>::assemble_system() 
  { 
    timer.enter_subsection("Assemble system"); 
    std::cout << " ASM_SYS " << std::flush; 

    tangent_matrix = 0.0; 
    system_rhs     = 0.0; 

    const UpdateFlags uf_cell(update_values | update_gradients | 
                              update_JxW_values); 
    const UpdateFlags uf_face(update_values | update_normal_vectors | 
                              update_JxW_values); 

    PerTaskData_ASM per_task_data(dofs_per_cell); 
    ScratchData_ASM scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face); 

// 这里用于向WorkStream类传递数据的语法在  step-13  中讨论。

    WorkStream::run( 
      dof_handler.active_cell_iterators(), 
      [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
             ScratchData_ASM &                                     scratch, 
             PerTaskData_ASM &                                     data) { 
        this->assemble_system_one_cell(cell, scratch, data); 
      }, 
      [this](const PerTaskData_ASM &data) { 
        this->constraints.distribute_local_to_global(data.cell_matrix, 
                                                     data.cell_rhs, 
                                                     data.local_dof_indices, 
                                                     tangent_matrix, 
                                                     system_rhs); 
      }, 
      scratch_data, 
      per_task_data); 

    timer.leave_subsection(); 
  } 

// 当然，我们仍然要定义如何组装单个单元的切线矩阵贡献。 我们首先需要重置和初始化一些从头开始的数据结构，并检索一些关于这个单元上DOF编号的基本信息。 我们可以预先计算单元的形状函数值和梯度。请注意，形状函数梯度是根据当前配置来定义的。 也就是  $\textrm{grad}\ \boldsymbol{\varphi} = \textrm{Grad}\ \boldsymbol{\varphi} \ \mathbf{F}^{-1}$  。

  template <int dim> 
  void Solid<dim>::assemble_system_one_cell( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    ScratchData_ASM &                                     scratch, 
    PerTaskData_ASM &                                     data) const 
  { 
    data.reset(); 
    scratch.reset(); 
    scratch.fe_values.reinit(cell); 
    cell->get_dof_indices(data.local_dof_indices); 

    const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph = 
      quadrature_point_history.get_data(cell); 
    Assert(lqph.size() == n_q_points, ExcInternalError()); 

    for (const unsigned int q_point : 
         scratch.fe_values.quadrature_point_indices()) 
      { 
        const Tensor<2, dim> F_inv = lqph[q_point]->get_F_inv(); 
        for (const unsigned int k : scratch.fe_values.dof_indices()) 
          { 
            const unsigned int k_group = fe.system_to_base_index(k).first.first; 

            if (k_group == u_dof) 
              { 
                scratch.grad_Nx[q_point][k] = 
                  scratch.fe_values[u_fe].gradient(k, q_point) * F_inv; 
                scratch.symm_grad_Nx[q_point][k] = 
                  symmetrize(scratch.grad_Nx[q_point][k]); 
              } 
            else if (k_group == p_dof) 
              scratch.Nx[q_point][k] = 
                scratch.fe_values[p_fe].value(k, q_point); 
            else if (k_group == J_dof) 
              scratch.Nx[q_point][k] = 
                scratch.fe_values[J_fe].value(k, q_point); 
            else 
              Assert(k_group <= J_dof, ExcInternalError()); 
          } 
      } 

// 现在我们建立本地单元刚度矩阵和RHS向量。由于全局和局部系统矩阵是对称的，我们可以利用这一特性，只建立局部矩阵的下半部分，并将其值复制到上半部分。 所以我们只组装一半的 $\mathsf{\mathbf{k}}_{uu}$  ,  $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{p}} = \mathbf{0}$  ,  $\mathsf{\mathbf{k}}_{\widetilde{J} \widetilde{J}}$ 块，而整个 $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$  ,  $\mathsf{\mathbf{k}}_{u \widetilde{J}} = \mathbf{0}$  ,  $\mathsf{\mathbf{k}}_{u \widetilde{p}}$ 块被构建。

// 在这样做的时候，我们首先从我们的正交历史对象中提取一些配置相关的变量，用于当前的正交点。

    for (const unsigned int q_point : 
         scratch.fe_values.quadrature_point_indices()) 
      { 
        const SymmetricTensor<2, dim> tau     = lqph[q_point]->get_tau(); 
        const Tensor<2, dim>          tau_ns  = lqph[q_point]->get_tau(); 
        const SymmetricTensor<4, dim> Jc      = lqph[q_point]->get_Jc(); 
        const double                  det_F   = lqph[q_point]->get_det_F(); 
        const double                  p_tilde = lqph[q_point]->get_p_tilde(); 
        const double                  J_tilde = lqph[q_point]->get_J_tilde(); 
        const double dPsi_vol_dJ   = lqph[q_point]->get_dPsi_vol_dJ(); 
        const double d2Psi_vol_dJ2 = lqph[q_point]->get_d2Psi_vol_dJ2(); 
        const SymmetricTensor<2, dim> &I = 
          Physics::Elasticity::StandardTensors<dim>::I; 

// 这两个张量存储了一些预计算的数据。它们的用途将很快得到解释。

        SymmetricTensor<2, dim> symm_grad_Nx_i_x_Jc; 
        Tensor<1, dim>          grad_Nx_i_comp_i_x_tau; 

// 接下来我们定义一些别名，使装配过程更容易操作。

        const std::vector<double> &                 N = scratch.Nx[q_point]; 
        const std::vector<SymmetricTensor<2, dim>> &symm_grad_Nx = 
          scratch.symm_grad_Nx[q_point]; 
        const std::vector<Tensor<2, dim>> &grad_Nx = scratch.grad_Nx[q_point]; 
        const double                       JxW = scratch.fe_values.JxW(q_point); 

        for (const unsigned int i : scratch.fe_values.dof_indices()) 
          { 
            const unsigned int component_i = 
              fe.system_to_component_index(i).first; 
            const unsigned int i_group = fe.system_to_base_index(i).first.first; 

// 我们首先计算来自内力的贡献。 注意，根据rhs作为残差负数的定义，这些贡献被减去。

            if (i_group == u_dof) 
              data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW; 
            else if (i_group == p_dof) 
              data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW; 
            else if (i_group == J_dof) 
              data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW; 
            else 
              Assert(i_group <= J_dof, ExcInternalError()); 

// 在我们进入内循环之前，我们还有最后一次机会来引入一些优化。我们已经考虑到了系统的对称性，现在我们可以预先计算一些在内循环中反复应用的常用项。  我们在这里不会过分，而是将重点放在昂贵的操作上，即那些涉及等级4材料刚度张量和等级2应力张量的操作。    我们可以观察到的是，这两个张量都是以 "i "DoF为索引的形状函数梯度收缩的。这意味着，当我们在 "j "DoF上循环时，这个特殊的操作保持不变。出于这个原因，我们可以从内循环中提取这个操作，并节省许多操作，对于每个正交点和DoF索引 "i"，并在索引 "j "上重复，需要用等级4对称张量对等级2对称张量进行双重收缩，用等级2张量对等级1张量进行双重收缩。    在损失一些可读性的情况下，当使用模拟默认参数时，这个小变化将使对称系统的装配时间减少一半左右，并且随着h-细化水平的提高而变得更加显著。

            if (i_group == u_dof) 
              { 
                symm_grad_Nx_i_x_Jc    = symm_grad_Nx[i] * Jc; 
                grad_Nx_i_comp_i_x_tau = grad_Nx[i][component_i] * tau_ns; 
              } 

// 现在我们准备计算正切矩阵的贡献。

            for (const unsigned int j : 
                 scratch.fe_values.dof_indices_ending_at(i)) 
              { 
                const unsigned int component_j = 
                  fe.system_to_component_index(j).first; 
                const unsigned int j_group = 
                  fe.system_to_base_index(j).first.first; 

// 这就是 $\mathsf{\mathbf{k}}_{uu}$ 的贡献。它包括一个材料贡献和一个几何应力贡献，后者只沿局部矩阵对角线添加。

                if ((i_group == j_group) && (i_group == u_dof)) 
                  { 

// 材料贡献。

                    data.cell_matrix(i, j) += symm_grad_Nx_i_x_Jc *  // 
                                              symm_grad_Nx[j] * JxW; // 

// 几何应力的贡献。

                    if (component_i == component_j) 
                      data.cell_matrix(i, j) += 
                        grad_Nx_i_comp_i_x_tau * grad_Nx[j][component_j] * JxW; 
                  } 

// 接下来是 $\mathsf{\mathbf{k}}_{ \widetilde{p} u}$ 的贡献。

                else if ((i_group == p_dof) && (j_group == u_dof)) 
                  { 
                    data.cell_matrix(i, j) += N[i] * det_F *               // 
                                              (symm_grad_Nx[j] * I) * JxW; // 
                  } 

// 最后是  $\mathsf{\mathbf{k}}_{ \widetilde{J \widetilde{p}}$  和  $\mathsf{\mathbf{k}}_{ \widetilde{J} \widetilde{J}}$  的贡献。

                else if ((i_group == J_dof) && (j_group == p_dof)) 
                  data.cell_matrix(i, j) -= N[i] * N[j] * JxW; 
                else if ((i_group == j_group) && (i_group == J_dof)) 
                  data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW; 
                else 
                  Assert((i_group <= J_dof) && (j_group <= J_dof), 
                         ExcInternalError()); 
              } 
          } 
      } 

// 接下来，我们组装诺伊曼贡献。我们首先检查单元格面是否存在于施加了牵引力的边界上，如果是这样的话，就加入贡献。

    for (const auto &face : cell->face_iterators()) 
      if (face->at_boundary() && face->boundary_id() == 6) 
        { 
          scratch.fe_face_values.reinit(cell, face); 

          for (const unsigned int f_q_point : 
               scratch.fe_face_values.quadrature_point_indices()) 
            { 
              const Tensor<1, dim> &N = 
                scratch.fe_face_values.normal_vector(f_q_point); 

// 使用该正交点的面法线，我们指定参考配置中的牵引力。对于这个问题，在参考配置中应用了一个定义的压力。    假设施加的牵引力的方向不随领域的变形而变化。牵引力是用第一个Piola-Kirchhoff应力简单地定义的 $\mathbf{t} = \mathbf{P}\mathbf{N} = [p_0 \mathbf{I}] \mathbf{N} = p_0 \mathbf{N}$ 我们用时间变量来线性提升压力负荷。        请注意，我们在这里计算的对右手边向量的贡献只存在于向量的位移分量中。

              static const double p0 = 
                -4.0 / (parameters.scale * parameters.scale); 
              const double         time_ramp = (time.current() / time.end()); 
              const double         pressure  = p0 * parameters.p_p0 * time_ramp; 
              const Tensor<1, dim> traction  = pressure * N; 

              for (const unsigned int i : scratch.fe_values.dof_indices()) 
                { 
                  const unsigned int i_group = 
                    fe.system_to_base_index(i).first.first; 

                  if (i_group == u_dof) 
                    { 
                      const unsigned int component_i = 
                        fe.system_to_component_index(i).first; 
                      const double Ni = 
                        scratch.fe_face_values.shape_value(i, f_q_point); 
                      const double JxW = scratch.fe_face_values.JxW(f_q_point); 

                      data.cell_rhs(i) += (Ni * traction[component_i]) * JxW; 
                    } 
                } 
            } 
        } 

// 最后，我们需要将本地矩阵的下半部分复制到上半部分。

    for (const unsigned int i : scratch.fe_values.dof_indices()) 
      for (const unsigned int j : 
           scratch.fe_values.dof_indices_starting_at(i + 1)) 
        data.cell_matrix(i, j) = data.cell_matrix(j, i); 
  } 

//  @sect4{Solid::make_constraints}  这个问题的约束条件很容易描述。在这个特殊的例子中，边界值将被计算为牛顿算法的两次第一次迭代。一般来说，我们会在第2次迭代中建立非均质约束（也就是在后面的代码块中`apply_dirichlet_bc == true`时），在接下来的步骤中只建立相应的均质约束。虽然目前的例子只有同质约束，但以前的经验表明，一个常见的错误是在重构代码到特定用途时忘记添加额外的条件。这可能导致难以调试的错误。本着这种精神，我们选择让代码在每个牛顿步骤中执行什么操作方面更加啰嗦。

  template <int dim> 
  void Solid<dim>::make_constraints(const int it_nr) 
  { 

// 由于我们(a)处理的是牛顿迭代方法，(b)使用的是位移的增量公式，以及(c)将约束条件应用于增量位移场，所以对位移更新的任何非均质约束条件只应在第2次迭代时指定。由于该迭代后约束条件将得到完全满足，因此不需要做后续的贡献。

    const bool apply_dirichlet_bc = (it_nr == 0); 

此外，//在一个时间段内的第一次牛顿迭代之后，约束条件保持不变，只要不清除 @p constraints 对象，我们就不需要修改或重建它们。

    if (it_nr > 1) 
      { 
        std::cout << " --- " << std::flush; 
        return; 
      } 

    std::cout << " CST " << std::flush; 

    if (apply_dirichlet_bc) 
      { 

// 在牛顿第2次迭代时，我们希望应用代表位移增量的边界条件的全套非均质和均质约束。因为一般来说，每个时间步长的约束条件可能是不同的，我们需要清除约束矩阵并完全重建它。一个例子是，如果一个表面正在加速，在这种情况下，每个时间步长的位移变化是不恒定的。

        constraints.clear(); 

// 三维压痕问题的边界条件如下。在-x、-y和-z面（IDs 0,2,4）我们设置了一个对称条件，只允许平面运动，而+x和+z面（IDs 1,5）无牵引力。在这个设计好的问题中，+y面的一部分（ID 3）被设定为在x-和z-分量上没有运动。最后，如前所述，+y面的另一部分有一个施加的压力，但在x和z方向上也受到约束。

// 在下文中，我们必须告诉函数插值的边界值应该约束解向量的哪些分量（也就是说，是x-、y-、z-位移还是它们的组合）。这是用ComponentMask对象完成的（见 @ref GlossComponentMask ），如果我们为有限元提供一个我们希望选择的分量的提取器对象，我们可以从有限元得到这些对象。为此，我们首先设置了这样的提取器对象，然后在生成相关构件掩码时使用它。

        const FEValuesExtractors::Scalar x_displacement(0); 
        const FEValuesExtractors::Scalar y_displacement(1); 

        { 
          const int boundary_id = 0; 

          VectorTools::interpolate_boundary_values( 
            dof_handler, 
            boundary_id, 
            Functions::ZeroFunction<dim>(n_components), 
            constraints, 
            fe.component_mask(x_displacement)); 
        } 
        { 
          const int boundary_id = 2; 

          VectorTools::interpolate_boundary_values( 
            dof_handler, 
            boundary_id, 
            Functions::ZeroFunction<dim>(n_components), 
            constraints, 
            fe.component_mask(y_displacement)); 
        } 

        if (dim == 3) 
          { 
            const FEValuesExtractors::Scalar z_displacement(2); 

            { 
              const int boundary_id = 3; 

              VectorTools::interpolate_boundary_values( 
                dof_handler, 
                boundary_id, 
                Functions::ZeroFunction<dim>(n_components), 
                constraints, 
                (fe.component_mask(x_displacement) | 
                 fe.component_mask(z_displacement))); 
            } 
            { 
              const int boundary_id = 4; 

              VectorTools::interpolate_boundary_values( 
                dof_handler, 
                boundary_id, 
                Functions::ZeroFunction<dim>(n_components), 
                constraints, 
                fe.component_mask(z_displacement)); 
            } 

            { 
              const int boundary_id = 6; 

              VectorTools::interpolate_boundary_values( 
                dof_handler, 
                boundary_id, 
                Functions::ZeroFunction<dim>(n_components), 
                constraints, 
                (fe.component_mask(x_displacement) | 
                 fe.component_mask(z_displacement))); 
            } 
          } 
        else 
          { 
            { 
              const int boundary_id = 3; 

              VectorTools::interpolate_boundary_values( 
                dof_handler, 
                boundary_id, 
                Functions::ZeroFunction<dim>(n_components), 
                constraints, 
                (fe.component_mask(x_displacement))); 
            } 
            { 
              const int boundary_id = 6; 

              VectorTools::interpolate_boundary_values( 
                dof_handler, 
                boundary_id, 
                Functions::ZeroFunction<dim>(n_components), 
                constraints, 
                (fe.component_mask(x_displacement))); 
            } 
          } 
      } 
    else 
      { 

// 由于所有的Dirichlet约束在牛顿第2次迭代后被完全满足，我们要确保对这些条目不做进一步的修改。这意味着我们要将所有非均质的Dirichlet约束转换成均质的约束。

// 在这个例子中，这样做的程序是非常简单的，事实上，当只应用同质边界条件时，我们可以（也会）规避任何不必要的操作。在一个更普遍的问题中，我们应该注意悬挂节点和周期性约束，这也可能引入一些不均匀性。那么，为不同类型的约束保留不同的对象可能是有利的，一旦构建了同质Dirichlet约束，就将它们合并在一起。

        if (constraints.has_inhomogeneities()) 
          { 

// 由于仿生约束是在上一次牛顿迭代中完成的，所以不能直接修改。所以我们需要将它们复制到另一个临时对象，并在那里进行修改。一旦我们完成了，我们将把它们转移回主 @p constraints 对象。

            AffineConstraints<double> homogeneous_constraints(constraints); 
            for (unsigned int dof = 0; dof != dof_handler.n_dofs(); ++dof) 
              if (homogeneous_constraints.is_inhomogeneously_constrained(dof)) 
                homogeneous_constraints.set_inhomogeneity(dof, 0.0); 

            constraints.clear(); 
            constraints.copy_from(homogeneous_constraints); 
          } 
      } 

    constraints.close(); 
  } 
// @sect4{Solid::assemble_sc}  解决整个块系统有点问题，因为对 $\mathsf{\mathbf{K}}_{ \widetilde{J} \widetilde{J}}$ 块没有贡献，使其不可逆转（当使用迭代求解器时）。由于压力和扩张变量DOF是不连续的，我们可以将它们浓缩成一个较小的仅有位移的系统，然后我们将对其进行求解，随后进行后处理以检索出压力和扩张的解决方案。

// 静态凝结过程可以在全局层面上进行，但我们需要其中一个块的逆向。然而，由于压力和扩张变量是不连续的，静态凝结（SC）操作也可以在每个单元的基础上进行，我们可以通过反转局部块来产生块对角线 $\mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}$ 块的逆。我们可以再次使用TBB来做这件事，因为每个操作都将是相互独立的。

//通过WorkStream类使用TBB，我们把每个元素的贡献集合起来形成 $ \mathsf{\mathbf{K}}_{\textrm{con}}= \bigl[ \mathsf{\mathbf{K}}_{uu} + \overline{\overline{\mathsf{\mathbf{K}}}}~ \bigr]$ 。然后这些贡献被添加到全局刚度矩阵中。鉴于这样的描述，以下两个函数应该是清楚的。

  template <int dim> 
  void Solid<dim>::assemble_sc() 
  { 
    timer.enter_subsection("Perform static condensation"); 
    std::cout << " ASM_SC " << std::flush; 

    PerTaskData_SC per_task_data(dofs_per_cell, 
                                 element_indices_u.size(), 
                                 element_indices_p.size(), 
                                 element_indices_J.size()); 
    ScratchData_SC scratch_data; 

    WorkStream::run(dof_handler.active_cell_iterators(), 
                    *this, 
                    &Solid::assemble_sc_one_cell, 
                    &Solid::copy_local_to_global_sc, 
                    scratch_data, 
                    per_task_data); 

    timer.leave_subsection(); 
  } 

  template <int dim> 
  void Solid<dim>::copy_local_to_global_sc(const PerTaskData_SC &data) 
  { 
    for (unsigned int i = 0; i < dofs_per_cell; ++i) 
      for (unsigned int j = 0; j < dofs_per_cell; ++j) 
        tangent_matrix.add(data.local_dof_indices[i], 
                           data.local_dof_indices[j], 
                           data.cell_matrix(i, j)); 
  } 

// 现在我们描述静态凝结过程。按照惯例，我们必须首先找出这个单元上的自由度有哪些全局数字，并重置一些数据结构。

  template <int dim> 
  void Solid<dim>::assemble_sc_one_cell( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    ScratchData_SC &                                      scratch, 
    PerTaskData_SC &                                      data) 
  { 
    data.reset(); 
    scratch.reset(); 
    cell->get_dof_indices(data.local_dof_indices); 

// 我们现在提取与当前单元相关的DFS对全局刚度矩阵的贡献。  $\widetilde{p}$ 和 $\widetilde{J}$ 插值的不连续性质意味着它们在全局水平上没有局部贡献的耦合。而 $\mathbf{u}$ 道夫则不是这样。 换句话说， $\mathsf{\mathbf{k}}_{\widetilde{J} \widetilde{p}}$ 、 $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{p}}$ 和 $\mathsf{\mathbf{k}}_{\widetilde{J} \widetilde{p}}$ ，当从全局刚度矩阵中提取时是元素贡献。 而 $\mathsf{\mathbf{k}}_{uu}$ 则不是这种情况。

// 注：用小写的符号表示元素刚度矩阵。

// 目前，与当前元素相关的dof矩阵（松散地表示为 $\mathsf{\mathbf{k}}$ ）是这样的。
// @f{align*}
//     \begin{bmatrix}
//        \mathsf{\mathbf{k}}_{uu}  &  \mathsf{\mathbf{k}}_{u\widetilde{p}}
//        & \mathbf{0}
//     \\ \mathsf{\mathbf{k}}_{\widetilde{p}u} & \mathbf{0}  &
//     \mathsf{\mathbf{k}}_{\widetilde{p}\widetilde{J}}
//     \\ \mathbf{0}  &  \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{p}}  &
//     \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{J}} \end{bmatrix}
//  @f}

// 我们现在需要对其进行修改，使其显示为
// @f{align*}
//    \begin{bmatrix}
//       \mathsf{\mathbf{k}}_{\textrm{con}}   &
//       \mathsf{\mathbf{k}}_{u\widetilde{p}}    & \mathbf{0}
//    \\ \mathsf{\mathbf{k}}_{\widetilde{p}u} & \mathbf{0} &
//    \mathsf{\mathbf{k}}_{\widetilde{p}\widetilde{J}}^{-1}
//    \\ \mathbf{0} & \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{p}} &
//    \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{J}} \end{bmatrix}
// @f}
// with $\mathsf{\mathbf{k}}_{\textrm{con}} = \bigl[
// \mathsf{\mathbf{k}}_{uu} +\overline{\overline{\mathsf{\mathbf{k}}}}~
// \bigr]$ where $               \overline{\overline{\mathsf{\mathbf{k}}}}
// \dealcoloneq \mathsf{\mathbf{k}}_{u\widetilde{p}}
// \overline{\mathsf{\mathbf{k}}} \mathsf{\mathbf{k}}_{\widetilde{p}u}
// $
// and
// $
//    \overline{\mathsf{\mathbf{k}}} =
//     \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{p}}^{-1}
//     \mathsf{\mathbf{k}}_{\widetilde{J}\widetilde{J}}
//    \mathsf{\mathbf{k}}_{\widetilde{p}\widetilde{J}}^{-1}
// $.

// 在这一点上，我们需要注意到全局数据已经存在于 $\mathsf{\mathbf{K}}_{uu}$  ,  $\mathsf{\mathbf{K}}_{\widetilde{p} \widetilde{J}}$  和  $\mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{p}}$  子块中。 因此，如果我们要修改它们，我们必须考虑到已经存在的数据（也就是说，如果需要的话，简单地添加到它或删除它）。 由于copy_local_to_global操作是一个 "+="操作，我们需要考虑到这一点

// 特别是对于 $\mathsf{\mathbf{K}}_{uu}$ 块，这意味着从周围的单元格中加入了贡献，所以我们在操作这个块时需要小心。 我们不能直接擦除子块。

// 我们将采用这种策略来获得我们想要的子块。



// -  $ {\mathsf{\mathbf{k}}}_{\textrm{store}}$  : 由于我们不能访问 $\mathsf{\mathbf{k}}_{uu}$ ，但我们知道它的贡献被添加到全局 $\mathsf{\mathbf{K}}_{uu}$ 矩阵中，我们只想添加元素明智的静态凝结 $\overline{\overline{\mathsf{\mathbf{k}}}}$  。



// -  $\mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}$  : 类似地， $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$ 存在于子块中。由于复制操作是一个+=操作，我们需要减去现有的 $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$ 子矩阵，此外还需要 "添加 "我们想要替换它的东西。



// -  $\mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{p}}$  : 由于全局矩阵是对称的，这个块和上面那个块是一样的，我们可以简单地用 $\mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}$ 来代替这个块。

// 我们首先从系统矩阵中提取元素数据。因此，首先我们得到单元格的整个子块，然后提取 $\mathsf{\mathbf{k}}$ 作为与当前元素相关的道夫。

    data.k_orig.extract_submatrix_from(tangent_matrix, 
                                       data.local_dof_indices, 
                                       data.local_dof_indices); 

//接下来是 $\mathsf{\mathbf{k}}_{ \widetilde{p} u}$ 的局部矩阵 
// $\mathsf{\mathbf{k}}_{ \widetilde{p} \widetilde{J}}$  和  $\mathsf{\mathbf{k}}_{ \widetilde{J} \widetilde{J}}$  的局部矩阵。

    data.k_pu.extract_submatrix_from(data.k_orig, 
                                     element_indices_p, 
                                     element_indices_u); 
    data.k_pJ.extract_submatrix_from(data.k_orig, 
                                     element_indices_p, 
                                     element_indices_J); 
    data.k_JJ.extract_submatrix_from(data.k_orig, 
                                     element_indices_J, 
                                     element_indices_J); 

// 为了得到 $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$ 的逆值，我们直接将其反转。 由于 $\mathsf{\mathbf{k}}_{\widetilde{p} \widetilde{J}}$ 是块状对角线，所以这个操作相对便宜。

    data.k_pJ_inv.invert(data.k_pJ); 

// 现在，我们可以将凝结项添加到 $\mathsf{\mathbf{k}}_{uu}$ 块中，并将其放入单元格局部矩阵 
    // $ 
    // \mathsf{\mathbf{A}}
    // =
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}
    // \mathsf{\mathbf{k}}_{\widetilde{p} u}
    // $  中。

    data.k_pJ_inv.mmult(data.A, data.k_pu); 
//       
      // $
      // \mathsf{\mathbf{B}}
      // =
      // \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{J}}
      // \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}
      // \mathsf{\mathbf{k}}_{\widetilde{p} u}
      // $  
    data.k_JJ.mmult(data.B, data.A); 
// 
    // $
    // \mathsf{\mathbf{C}}
    // =
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{p}}
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{J}}
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}
    // \mathsf{\mathbf{k}}_{\widetilde{p} u}
    // $  
    data.k_pJ_inv.Tmmult(data.C, data.B); 
// 
    // $
    // \overline{\overline{\mathsf{\mathbf{k}}}}
    // =
    // \mathsf{\mathbf{k}}_{u \widetilde{p}}
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{p}}
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{J} \widetilde{J}}
    // \mathsf{\mathbf{k}}^{-1}_{\widetilde{p} \widetilde{J}}
    // \mathsf{\mathbf{k}}_{\widetilde{p} u}
    // $  
    data.k_pu.Tmmult(data.k_bbar, data.C); 
    data.k_bbar.scatter_matrix_to(element_indices_u, 
                                  element_indices_u, 
                                  data.cell_matrix); 

// 接下来我们将 $\mathsf{\mathbf{k}}^{-1}_{ \widetilde{p} \widetilde{J}}$ 放在 $\mathsf{\mathbf{k}}_{ \widetilde{p} \widetilde{J}}$ 块中进行后处理。 再次注意，我们需要删除那里已经存在的贡献。

    data.k_pJ_inv.add(-1.0, data.k_pJ); 
    data.k_pJ_inv.scatter_matrix_to(element_indices_p, 
                                    element_indices_J, 
                                    data.cell_matrix); 
  } 
// @sect4{Solid::solve_linear_system}  我们现在拥有所有必要的组件，可以使用两种可能的方法之一来解决线性化系统。第一种是在元素层面上进行静态凝结，这需要对切线矩阵和RHS向量进行一些改动。另外，也可以通过在全局层面上进行凝结来解决全块系统。下面我们将实现这两种方法。

  template <int dim> 
  std::pair<unsigned int, double> 
  Solid<dim>::solve_linear_system(BlockVector<double> &newton_update) 
  { 
    unsigned int lin_it  = 0; 
    double       lin_res = 0.0; 

    if (parameters.use_static_condensation == true) 
      { 

// 首先，这里是使用切线矩阵的（永久）增量的方法。对于下面的内容，回顾一下
// @f{align*}
//   \mathsf{\mathbf{K}}_{\textrm{store}}
// \dealcoloneq
//   \begin{bmatrix}
//       \mathsf{\mathbf{K}}_{\textrm{con}}      &
//       \mathsf{\mathbf{K}}_{u\widetilde{p}}    & \mathbf{0}
//   \\  \mathsf{\mathbf{K}}_{\widetilde{p}u}    &       \mathbf{0} &
//   \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1}
//   \\  \mathbf{0}      &
//   \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}                &
//   \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}} \end{bmatrix} \, .
//  @f}
//  和
//  @f{align*}
//               d \widetilde{\mathsf{\mathbf{p}}}
//               & =
//               \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}
//               \bigl[
//                        \mathsf{\mathbf{F}}_{\widetilde{J}}
//                        -
//                        \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
//                        d \widetilde{\mathsf{\mathbf{J}}} \bigr]
//               \\ d \widetilde{\mathsf{\mathbf{J}}}
//               & =
//               \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1}
//               \bigl[
//                       \mathsf{\mathbf{F}}_{\widetilde{p}}
//                       - \mathsf{\mathbf{K}}_{\widetilde{p}u} d
//                       \mathsf{\mathbf{u}} \bigr]
//                \\ \Rightarrow d \widetilde{\mathsf{\mathbf{p}}}
//               &= \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}
//               \mathsf{\mathbf{F}}_{\widetilde{J}}
//               -
//               \underbrace{\bigl[\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}
//               \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
//               \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1}\bigr]}_{\overline{\mathsf{\mathbf{K}}}}\bigl[
//               \mathsf{\mathbf{F}}_{\widetilde{p}}
//               - \mathsf{\mathbf{K}}_{\widetilde{p}u} d
//               \mathsf{\mathbf{u}} \bigr]
//   @f}
  // ，从而
  // @f[
  //             \underbrace{\bigl[ \mathsf{\mathbf{K}}_{uu} +
  //             \overline{\overline{\mathsf{\mathbf{K}}}}~ \bigr]
  //             }_{\mathsf{\mathbf{K}}_{\textrm{con}}} d
  //             \mathsf{\mathbf{u}}
  //             =
  //         \underbrace{
  //             \Bigl[
  //             \mathsf{\mathbf{F}}_{u}
  //                     - \mathsf{\mathbf{K}}_{u\widetilde{p}} \bigl[
  //                     \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}
  //                     \mathsf{\mathbf{F}}_{\widetilde{J}}
  //                     -
  //                     \overline{\mathsf{\mathbf{K}}}\mathsf{\mathbf{F}}_{\widetilde{p}}
  //                     \bigr]
  //             \Bigr]}_{\mathsf{\mathbf{F}}_{\textrm{con}}}
  // @f]
  // 其中
  // @f[
  //             \overline{\overline{\mathsf{\mathbf{K}}}} \dealcoloneq
  //                     \mathsf{\mathbf{K}}_{u\widetilde{p}}
  //                     \overline{\mathsf{\mathbf{K}}}
  //                     \mathsf{\mathbf{K}}_{\widetilde{p}u} \, .
  // @f]

// 在顶部，我们分配了两个临时向量来帮助进行静态凝结，并分配了变量来存储线性求解器的迭代次数和（希望收敛的）残差。

        BlockVector<double> A(dofs_per_block); 
        BlockVector<double> B(dofs_per_block); 

// 在这个函数的第一步，我们求解增量位移  $d\mathbf{u}$  。 为此，我们进行静态浓缩，使 
    // $\mathsf{\mathbf{K}}_{\textrm{con}}
    // = \bigl[ \mathsf{\mathbf{K}}_{uu} +
    // \overline{\overline{\mathsf{\mathbf{K}}}}~ \bigr]$ ，并将 $\mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}$ 放在原 $\mathsf{\mathbf{K}}_{\widetilde{p} \widetilde{J}}$ 块中。也就是说，我们制作 $\mathsf{\mathbf{K}}_{\textrm{store}}$  。

        { 
          assemble_sc(); 

//  
    //  $
    //   \mathsf{\mathbf{A}}_{\widetilde{J}}
    //   =
    //           \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}
    //           \mathsf{\mathbf{F}}_{\widetilde{p}}
    //   $ 
          tangent_matrix.block(p_dof, J_dof) 
            .vmult(A.block(J_dof), system_rhs.block(p_dof)); 

      // $
      // \mathsf{\mathbf{B}}_{\widetilde{J}}
      // =
      // \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // $  
          tangent_matrix.block(J_dof, J_dof) 
            .vmult(B.block(J_dof), A.block(J_dof)); 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{J}}
      // =
      // \mathsf{\mathbf{F}}_{\widetilde{J}}
      // -
      // \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // $  
          A.block(J_dof) = system_rhs.block(J_dof); 
          A.block(J_dof) -= B.block(J_dof); 
//    
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{J}}
      // =
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{J} \widetilde{p}}
      // [
      // \mathsf{\mathbf{F}}_{\widetilde{J}}
      // -
      // \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // ]
      // $  
          tangent_matrix.block(p_dof, J_dof) 
            .Tvmult(A.block(p_dof), A.block(J_dof)); 
// 
      // $
      // \mathsf{\mathbf{A}}_{u}
      // =
      // \mathsf{\mathbf{K}}_{u \widetilde{p}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{J} \widetilde{p}}
      // [
      // \mathsf{\mathbf{F}}_{\widetilde{J}}
      // -
      // \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // ]
      // $  
          tangent_matrix.block(u_dof, p_dof) 
            .vmult(A.block(u_dof), A.block(p_dof)); 
// 
      // $
      // \mathsf{\mathbf{F}}_{\text{con}}
      // =
      // \mathsf{\mathbf{F}}_{u}
      // -
      // \mathsf{\mathbf{K}}_{u \widetilde{p}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{J} \widetilde{p}}
      // [
      // \mathsf{\mathbf{F}}_{\widetilde{J}}
      // -
      // \mathsf{\mathbf{K}}_{\widetilde{J} \widetilde{J}}
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{p} \widetilde{J}}
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // ]
      // $  
          system_rhs.block(u_dof) -= A.block(u_dof); 

          timer.enter_subsection("Linear solver"); 
          std::cout << " SLV " << std::flush; 
          if (parameters.type_lin == "CG") 
            { 
              const auto solver_its = static_cast<unsigned int>( 
                tangent_matrix.block(u_dof, u_dof).m() * 
                parameters.max_iterations_lin); 
              const double tol_sol = 
                parameters.tol_lin * system_rhs.block(u_dof).l2_norm(); 

              SolverControl solver_control(solver_its, tol_sol); 

              GrowingVectorMemory<Vector<double>> GVM; 
              SolverCG<Vector<double>> solver_CG(solver_control, GVM); 

// 我们默认选择了SSOR预处理程序，因为在单线程机器上，它似乎为这个问题提供了最快的求解器收敛特性。 然而，对于不同的问题规模，这可能不是真的。

              PreconditionSelector<SparseMatrix<double>, Vector<double>> 
                preconditioner(parameters.preconditioner_type, 
                               parameters.preconditioner_relaxation); 
              preconditioner.use_matrix(tangent_matrix.block(u_dof, u_dof)); 

              solver_CG.solve(tangent_matrix.block(u_dof, u_dof), 
                              newton_update.block(u_dof), 
                              system_rhs.block(u_dof), 
                              preconditioner); 

              lin_it  = solver_control.last_step(); 
              lin_res = solver_control.last_value(); 
            } 
          else if (parameters.type_lin == "Direct") 
            { 

// 否则，如果问题足够小，可以利用直接求解器。

              SparseDirectUMFPACK A_direct; 
              A_direct.initialize(tangent_matrix.block(u_dof, u_dof)); 
              A_direct.vmult(newton_update.block(u_dof), 
                             system_rhs.block(u_dof)); 

              lin_it  = 1; 
              lin_res = 0.0; 
            } 
          else 
            Assert(false, ExcMessage("Linear solver type not implemented")); 

          timer.leave_subsection(); 
        } 

// 现在我们有了位移更新，将约束分配回牛顿更新。

        constraints.distribute(newton_update); 

        timer.enter_subsection("Linear solver postprocessing"); 
        std::cout << " PP " << std::flush; 

// 解决位移问题后的下一步是进行后处理，从置换中得到扩张解。     
    // $
    //  d \widetilde{\mathsf{\mathbf{J}}}
    //   = \mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1} \bigl[
    //    \mathsf{\mathbf{F}}_{\widetilde{p}}
    //  - \mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}}
    //   \bigr]
    // $  
        { 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{p}}
      // =
      // \mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}}
      // $  
          tangent_matrix.block(p_dof, u_dof) 
            .vmult(A.block(p_dof), newton_update.block(u_dof)); 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{p}}
      // =
      // -\mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}}
      // $  
          A.block(p_dof) *= -1.0; 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{p}}
      // =
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // -\mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}}
      // $  
          A.block(p_dof) += system_rhs.block(p_dof); 
// 
      // $
      // d\mathsf{\mathbf{\widetilde{J}}}
      // =
      // \mathsf{\mathbf{K}}^{-1}_{\widetilde{p}\widetilde{J}}
      // [
      // \mathsf{\mathbf{F}}_{\widetilde{p}}
      // -\mathsf{\mathbf{K}}_{\widetilde{p}u} d \mathsf{\mathbf{u}}
      // ]
      // $  
          tangent_matrix.block(p_dof, J_dof) 
            .vmult(newton_update.block(J_dof), A.block(p_dof)); 
        } 

// 我们在此确保任何迪里希特约束都分布在更新的解决方案上。

        constraints.distribute(newton_update); 

// 最后我们用代入法求解压力的更新。     
    // $
    // d \widetilde{\mathsf{\mathbf{p}}}
    //  =
    // \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}
    // \bigl[
    //  \mathsf{\mathbf{F}}_{\widetilde{J}}
    //   - \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
    // d \widetilde{\mathsf{\mathbf{J}}}
    // \bigr]
    // $  
        { 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{J}}
      //  =
      // \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
      // d \widetilde{\mathsf{\mathbf{J}}}
      // $  
          tangent_matrix.block(J_dof, J_dof) 
            .vmult(A.block(J_dof), newton_update.block(J_dof)); 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{J}}
      //  =
      // -\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
      // d \widetilde{\mathsf{\mathbf{J}}}
      // $  
          A.block(J_dof) *= -1.0; 
// 
      // $
      // \mathsf{\mathbf{A}}_{\widetilde{J}}
      //  =
      // \mathsf{\mathbf{F}}_{\widetilde{J}}
      // -
      // \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
      // d \widetilde{\mathsf{\mathbf{J}}}
      // $  
          A.block(J_dof) += system_rhs.block(J_dof); 

//和
//最后....      

  //  $
  //   d \widetilde{\mathsf{\mathbf{p}}}
  //    =
  //   \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}
  //   \bigl[
  //    \mathsf{\mathbf{F}}_{\widetilde{J}}
  //     - \mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{J}}
  //   d \widetilde{\mathsf{\mathbf{J}}}
  //   \bigr]
  //   $  
          tangent_matrix.block(p_dof, J_dof) 
            .Tvmult(newton_update.block(p_dof), A.block(J_dof)); 
        } 

// 我们现在已经到了终点，所以我们将所有受限的道夫分配到牛顿更新中。

        constraints.distribute(newton_update); 

        timer.leave_subsection(); 
      } 
    else 
      { 
        std::cout << " ------ " << std::flush; 

        timer.enter_subsection("Linear solver"); 
        std::cout << " SLV " << std::flush; 

        if (parameters.type_lin == "CG") 
          { 

// 在局部水平上手动凝结扩张和压力场，以及随后的后处理，需要花费相当大的努力才能实现。简而言之，我们必须产生逆矩阵 $\mathsf{\mathbf{K}}_{\widetilde{p}\widetilde{J}}^{-1}$ ，并将其永久写入全局切线矩阵中。然后我们对 $\mathsf{\mathbf{K}}_{uu}$ 进行永久修改，产生 $\mathsf{\mathbf{K}}_{\textrm{con}}$ 。这涉及到对切线矩阵的局部子块的提取和操作。在对位移进行求解后，对扩张和压力进行求解所需的各个矩阵-向量操作被仔细地执行。将这些众多的步骤与使用LinearOperator类提供的功能进行的更简单、更透明的实现形成对比。

// 为了便于以后使用，我们为RHS向量中的块定义了一些别名

            const Vector<double> &f_u = system_rhs.block(u_dof); 
            const Vector<double> &f_p = system_rhs.block(p_dof); 
            const Vector<double> &f_J = system_rhs.block(J_dof); 

// ... 对于牛顿更新向量中的块。

            Vector<double> &d_u = newton_update.block(u_dof); 
            Vector<double> &d_p = newton_update.block(p_dof); 
            Vector<double> &d_J = newton_update.block(J_dof); 

// 我们将利用系统的对称性，所以不是所有的块都需要。

            const auto K_uu = 
              linear_operator(tangent_matrix.block(u_dof, u_dof)); 
            const auto K_up = 
              linear_operator(tangent_matrix.block(u_dof, p_dof)); 
            const auto K_pu = 
              linear_operator(tangent_matrix.block(p_dof, u_dof)); 
            const auto K_Jp = 
              linear_operator(tangent_matrix.block(J_dof, p_dof)); 
            const auto K_JJ = 
              linear_operator(tangent_matrix.block(J_dof, J_dof)); 

// 然后我们构建一个LinearOperator，代表（方形块） $\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}$ 的逆。由于它是对角线的（或者，当使用高阶分解时，几乎是对角线的），所以雅可比预处理器是合适的。

            PreconditionSelector<SparseMatrix<double>, Vector<double>> 
              preconditioner_K_Jp_inv("jacobi"); 
            preconditioner_K_Jp_inv.use_matrix( 
              tangent_matrix.block(J_dof, p_dof)); 
            ReductionControl solver_control_K_Jp_inv( 
              static_cast<unsigned int>(tangent_matrix.block(J_dof, p_dof).m() * 
                                        parameters.max_iterations_lin), 
              1.0e-30, 
              parameters.tol_lin); 
            SolverSelector<Vector<double>> solver_K_Jp_inv; 
            solver_K_Jp_inv.select("cg"); 
            solver_K_Jp_inv.set_control(solver_control_K_Jp_inv); 
            const auto K_Jp_inv = 
              inverse_operator(K_Jp, solver_K_Jp_inv, preconditioner_K_Jp_inv); 

// 现在我们可以构建 $\mathsf{\mathbf{K}}_{\widetilde{J}\widetilde{p}}^{-1}$ 的那个转置和一个线性算子，它代表了浓缩的操作 $\overline{\mathsf{\mathbf{K}}}$ 和 $\overline{\overline{\mathsf{\mathbf{K}}}}$ 以及最后的增强矩阵 $\mathsf{\mathbf{K}}_{\textrm{con}}$  。  请注意，schur_complement()算子在这里也能派上用场，但为了清楚起见，也为了展示线性求解方案的表述和实现之间的相似性，我们将手动执行这些操作。

            const auto K_pJ_inv     = transpose_operator(K_Jp_inv); 
            const auto K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv; 
            const auto K_uu_bar_bar = K_up * K_pp_bar * K_pu; 
            const auto K_uu_con     = K_uu + K_uu_bar_bar; 

// 最后，我们定义了一个增强刚度矩阵的逆运算，即  $\mathsf{\mathbf{K}}_{\textrm{con}}^{-1}$  。请注意，增强刚度矩阵的预处理程序与我们使用静态凝结的情况不同。在这种情况下，预处理程序是基于未修改的 $\mathsf{\mathbf{K}}_{uu}$ ，而在第一种方法中，我们实际上修改了这个子块的条目。然而，由于 $\mathsf{\mathbf{K}}_{\textrm{con}}$ 和 $\mathsf{\mathbf{K}}_{uu}$ 在同一空间操作，它对这个问题仍然足够。

            PreconditionSelector<SparseMatrix<double>, Vector<double>> 
              preconditioner_K_con_inv(parameters.preconditioner_type, 
                                       parameters.preconditioner_relaxation); 
            preconditioner_K_con_inv.use_matrix( 
              tangent_matrix.block(u_dof, u_dof)); 
            ReductionControl solver_control_K_con_inv( 
              static_cast<unsigned int>(tangent_matrix.block(u_dof, u_dof).m() * 
                                        parameters.max_iterations_lin), 
              1.0e-30, 
              parameters.tol_lin); 
            SolverSelector<Vector<double>> solver_K_con_inv; 
            solver_K_con_inv.select("cg"); 
            solver_K_con_inv.set_control(solver_control_K_con_inv); 
            const auto K_uu_con_inv = 
              inverse_operator(K_uu_con, 
                               solver_K_con_inv, 
                               preconditioner_K_con_inv); 

// 现在我们可以对位移场进行求解了。  我们可以嵌套线性运算，结果立即写入牛顿更新向量中。  很明显，这个实现密切模仿了介绍中所说的推导。

            d_u = 
              K_uu_con_inv * (f_u - K_up * (K_Jp_inv * f_J - K_pp_bar * f_p)); 

            timer.leave_subsection(); 

// 需要对扩张场和压力场进行后处理的操作，也同样容易表达。

            timer.enter_subsection("Linear solver postprocessing"); 
            std::cout << " PP " << std::flush; 

            d_J = K_pJ_inv * (f_p - K_pu * d_u); 
            d_p = K_Jp_inv * (f_J - K_JJ * d_J); 

            lin_it  = solver_control_K_con_inv.last_step(); 
            lin_res = solver_control_K_con_inv.last_value(); 
          } 
        else if (parameters.type_lin == "Direct") 
          { 

// 用直接求解器求解全块系统。由于它是相对稳健的，它可能对因零 $\mathsf{\mathbf{K}}_{ \widetilde{J} \widetilde{J}}$ 块的存在而产生的问题免疫。

            SparseDirectUMFPACK A_direct; 
            A_direct.initialize(tangent_matrix); 
            A_direct.vmult(newton_update, system_rhs); 

            lin_it  = 1; 
            lin_res = 0.0; 

            std::cout << " -- " << std::flush; 
          } 
        else 
          Assert(false, ExcMessage("Linear solver type not implemented")); 

        timer.leave_subsection(); 

// 最后，我们在这里再次确保任何Dirichlet约束都分布在更新的解决方案上。

        constraints.distribute(newton_update); 
      } 

    return std::make_pair(lin_it, lin_res); 
  } 
// @sect4{Solid::output_results}  这里我们介绍如何将结果写入文件，以便用ParaView或Visi来查看。该方法与以前的教程中的方法类似，因此将不作详细讨论。

  template <int dim> 
  void Solid<dim>::output_results() const 
  { 
    DataOut<dim> data_out; 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    std::vector<std::string> solution_name(dim, "displacement"); 
    solution_name.emplace_back("pressure"); 
    solution_name.emplace_back("dilatation"); 

    DataOutBase::VtkFlags output_flags; 
    output_flags.write_higher_order_cells = true; 
    data_out.set_flags(output_flags); 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution_n, 
                             solution_name, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 

// 由于我们处理的是一个大的变形问题，如果能在一个位移的网格上显示结果就更好了!  与DataOut类相连的MappingQEulerian类提供了一个接口，通过该接口可以实现这一目的，而不需要我们自己物理地移动三角测量对象中的网格点。 我们首先需要将解决方案复制到一个临时矢量，然后创建欧拉映射。我们还向DataOut对象指定了多项式的度数，以便在使用高阶多项式时产生一个更精细的输出数据集。

    Vector<double> soln(solution_n.size()); 
    for (unsigned int i = 0; i < soln.size(); ++i) 
      soln(i) = solution_n(i); 
    MappingQEulerian<dim> q_mapping(degree, dof_handler, soln); 
    data_out.build_patches(q_mapping, degree); 

    std::ofstream output("solution-" + std::to_string(dim) + "d-" + 
                         std::to_string(time.get_timestep()) + ".vtu"); 
    data_out.write_vtu(output); 
  } 

} // namespace Step44 
// @sect3{Main function}  最后我们提供了主要的驱动函数，它看起来与其他教程没有什么不同。

int main() 
{ 
  using namespace Step44; 

  try 
    { 
      const unsigned int dim = 3; 
      Solid<dim>         solid("parameters.prm"); 
      solid.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-45.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2008 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Daniel Arndt, Matthias Maier, 2015 
 * 
 * Based on step-22 by Wolfgang Bangerth and Martin Kronbichler 
 */ 



// 这个例子程序是对 step-22 的轻微修改，使用Trilinos并行运行，以演示交易.II中周期性边界条件的使用。因此我们不讨论大部分的源代码，只对处理周期性约束的部分进行评论。其余的请看 step-22 和底部的完整源代码。

// 为了实现周期性边界条件，只有两个函数需要修改。

// -  <code>StokesProblem<dim>::setup_dofs()</code>  : 用周期性约束来填充AffineConstraints对象

// -  <code>StokesProblem<dim>::create_mesh()</code>  : 为分布式三角形提供周期性信息。

// 程序的其余部分与 step-22 相同，所以让我们跳过这一部分，只在下面显示这两个函数。完整的程序可以在下面的 "普通程序 "部分找到）。

//  @cond  跳过

#include <deal.II/base/conditional_ostream.h> 

#include <deal.II/distributed/grid_refinement.h> 

#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/lac/trilinos_solver.h> 
#include <deal.II/lac/trilinos_precondition.h> 
#include <deal.II/lac/trilinos_block_sparse_matrix.h> 
#include <deal.II/lac/trilinos_parallel_block_vector.h> 
#include <deal.II/lac/block_sparsity_pattern.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 

#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

namespace Step45 
{ 
  using namespace dealii; 

  template <int dim> 
  class StokesProblem 
  { 
  public: 
    StokesProblem(const unsigned int degree); 
    void run(); 

  private: 
    void create_mesh(); 
    void setup_dofs(); 
    void assemble_system(); 
    void solve(); 
    void output_results(const unsigned int refinement_cycle) const; 
    void refine_mesh(); 

    const unsigned int degree; 

    MPI_Comm mpi_communicator; 

    parallel::distributed::Triangulation<dim> triangulation; 
    FESystem<dim>                             fe; 
    DoFHandler<dim>                           dof_handler; 

    AffineConstraints<double> constraints; 
    std::vector<IndexSet>     owned_partitioning; 
    std::vector<IndexSet>     relevant_partitioning; 

    TrilinosWrappers::BlockSparseMatrix system_matrix; 

    TrilinosWrappers::BlockSparseMatrix preconditioner_matrix; 

    TrilinosWrappers::MPI::BlockVector solution; 
    TrilinosWrappers::MPI::BlockVector system_rhs; 

    ConditionalOStream pcout; 

    MappingQ<dim> mapping; 
  }; 

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    BoundaryValues() 
      : Function<dim>(dim + 1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & /*p*/, 
                                    const unsigned int component) const 
  { 
    (void)component; 
    Assert(component < this->n_components, 
           ExcIndexRange(component, 0, this->n_components)); 

    return 0; 
  } 

  template <int dim> 
  void BoundaryValues<dim>::vector_value(const Point<dim> &p, 
                                         Vector<double> &  values) const 
  { 
    for (unsigned int c = 0; c < this->n_components; ++c) 
      values(c) = BoundaryValues<dim>::value(p, c); 
  } 

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide() 
      : Function<dim>(dim + 1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & p, 
                                   const unsigned int component) const 
  { 
    const Point<dim> center(0.75, 0.1); 
    const double     r = (p - center).norm(); 

    if (component == 0) 
      return std::exp(-100. * r * r); 
    return 0; 
  } 

  template <int dim> 
  void RightHandSide<dim>::vector_value(const Point<dim> &p, 
                                        Vector<double> &  values) const 
  { 
    for (unsigned int c = 0; c < this->n_components; ++c) 
      values(c) = RightHandSide<dim>::value(p, c); 
  } 

  template <class MatrixType, class PreconditionerType> 
  class InverseMatrix : public Subscriptor 
  { 
  public: 
    InverseMatrix(const MatrixType &        m, 
                  const PreconditionerType &preconditioner, 
                  const IndexSet &          locally_owned, 
                  const MPI_Comm &          mpi_communicator); 

    void vmult(TrilinosWrappers::MPI::Vector &      dst, 
               const TrilinosWrappers::MPI::Vector &src) const; 

  private: 
    const SmartPointer<const MatrixType>         matrix; 
    const SmartPointer<const PreconditionerType> preconditioner; 

    const MPI_Comm *                      mpi_communicator; 
    mutable TrilinosWrappers::MPI::Vector tmp; 
  }; 

  template <class MatrixType, class PreconditionerType> 
  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix( 
    const MatrixType &        m, 
    const PreconditionerType &preconditioner, 
    const IndexSet &          locally_owned, 
    const MPI_Comm &          mpi_communicator) 
    : matrix(&m) 
    , preconditioner(&preconditioner) 
    , mpi_communicator(&mpi_communicator) 
    , tmp(locally_owned, mpi_communicator) 
  {} 

  template <class MatrixType, class PreconditionerType> 
  void InverseMatrix<MatrixType, PreconditionerType>::vmult( 
    TrilinosWrappers::MPI::Vector &      dst, 
    const TrilinosWrappers::MPI::Vector &src) const 
  { 
    SolverControl              solver_control(src.size(), 1e-6 * src.l2_norm()); 
    TrilinosWrappers::SolverCG cg(solver_control, 
                                  TrilinosWrappers::SolverCG::AdditionalData()); 

    tmp = 0.; 
    cg.solve(*matrix, tmp, src, *preconditioner); 
    dst = tmp; 
  } 

  template <class PreconditionerType> 
  class SchurComplement : public TrilinosWrappers::SparseMatrix 
  { 
  public: 
    SchurComplement(const TrilinosWrappers::BlockSparseMatrix &system_matrix, 
                    const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                                        PreconditionerType> &  A_inverse, 
                    const IndexSet &                           owned_pres, 
                    const MPI_Comm &mpi_communicator); 

    void vmult(TrilinosWrappers::MPI::Vector &      dst, 
               const TrilinosWrappers::MPI::Vector &src) const; 

  private: 
    const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> system_matrix; 
    const SmartPointer< 
      const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>> 
                                          A_inverse; 
    mutable TrilinosWrappers::MPI::Vector tmp1, tmp2; 
  }; 

  template <class PreconditionerType> 
  SchurComplement<PreconditionerType>::SchurComplement( 
    const TrilinosWrappers::BlockSparseMatrix &system_matrix, 
    const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType> 
      &             A_inverse, 
    const IndexSet &owned_vel, 
    const MPI_Comm &mpi_communicator) 
    : system_matrix(&system_matrix) 
    , A_inverse(&A_inverse) 
    , tmp1(owned_vel, mpi_communicator) 
    , tmp2(tmp1) 
  {} 

  template <class PreconditionerType> 
  void SchurComplement<PreconditionerType>::vmult( 
    TrilinosWrappers::MPI::Vector &      dst, 
    const TrilinosWrappers::MPI::Vector &src) const 
  { 
    system_matrix->block(0, 1).vmult(tmp1, src); 
    A_inverse->vmult(tmp2, tmp1); 
    system_matrix->block(1, 0).vmult(dst, tmp2); 
  } 

  template <int dim> 
  StokesProblem<dim>::StokesProblem(const unsigned int degree) 
    : degree(degree) 
    , mpi_communicator(MPI_COMM_WORLD) 
    , triangulation(mpi_communicator) 
    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1) 
    , dof_handler(triangulation) 
    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0) 
    , mapping(degree + 1) 
  {} 
// @endcond  
// @sect3{Setting up periodicity constraints on distributed triangulations}  
  template <int dim> 
  void StokesProblem<dim>::create_mesh() 
  { 
    Point<dim>   center; 
    const double inner_radius = .5; 
    const double outer_radius = 1.; 

    GridGenerator::quarter_hyper_shell( 
      triangulation, center, inner_radius, outer_radius, 0, true); 

// 在我们可以规定周期性约束之前，我们需要确保位于域的对面但由周期性面连接的单元是幽灵层的一部分，如果其中一个单元存储在本地处理器上。在这一点上，我们需要考虑我们要如何规定周期性。左边边界上的面的顶点 $\text{vertices}_2$ 应该与下面边界上的面的顶点 $\text{vertices}_1$ 相匹配，由 $\text{vertices}_2=R\cdot \text{vertices}_1+b$ 给出，其中旋转矩阵 $R$ 和偏移量 $b$ 由
//  @f{align*}
//  R=\begin{pmatrix}
//  0&1\\-1&0
//  \end{pmatrix},
//  \quad
//  b=\begin{pmatrix}0&0\end{pmatrix}.
//  @f}
//  给出。 我们将所得信息保存到这里的数据结构是基于三角结构的。

    std::vector<GridTools::PeriodicFacePair< 
      typename parallel::distributed::Triangulation<dim>::cell_iterator>> 
      periodicity_vector; 

    FullMatrix<double> rotation_matrix(dim); 
    rotation_matrix[0][1] = 1.; 
    rotation_matrix[1][0] = -1.; 

    GridTools::collect_periodic_faces(triangulation, 
                                      2, 
                                      3, 
                                      1, 
                                      periodicity_vector, 
                                      Tensor<1, dim>(), 
                                      rotation_matrix); 

// 现在，只要调用 parallel::distributed::Triangulation::add_periodicity. 就可以告诉三角函数所需的周期性，特别容易。
    triangulation.add_periodicity(periodicity_vector); 

    triangulation.refine_global(4 - dim); 
  } 

  template <int dim> 
  void StokesProblem<dim>::setup_dofs() 
  { 
    dof_handler.distribute_dofs(fe); 

    std::vector<unsigned int> block_component(dim + 1, 0); 
    block_component[dim] = 1; 
    DoFRenumbering::component_wise(dof_handler, block_component); 

    const std::vector<types::global_dof_index> dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, block_component); 
    const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1]; 

    { 
      owned_partitioning.clear(); 
      IndexSet locally_owned_dofs = dof_handler.locally_owned_dofs(); 
      owned_partitioning.push_back(locally_owned_dofs.get_view(0, n_u)); 
      owned_partitioning.push_back(locally_owned_dofs.get_view(n_u, n_u + n_p)); 

      relevant_partitioning.clear(); 
      IndexSet locally_relevant_dofs; 
      DoFTools::extract_locally_relevant_dofs(dof_handler, 
                                              locally_relevant_dofs); 
      relevant_partitioning.push_back(locally_relevant_dofs.get_view(0, n_u)); 
      relevant_partitioning.push_back( 
        locally_relevant_dofs.get_view(n_u, n_u + n_p)); 

      constraints.clear(); 
      constraints.reinit(locally_relevant_dofs); 

      FEValuesExtractors::Vector velocities(0); 

      DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
      VectorTools::interpolate_boundary_values(mapping, 
                                               dof_handler, 
                                               0, 
                                               BoundaryValues<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 
      VectorTools::interpolate_boundary_values(mapping, 
                                               dof_handler, 
                                               1, 
                                               BoundaryValues<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 

// 在我们为网格提供了周期性约束的必要信息后，我们现在可以实际创建它们。对于描述匹配，我们使用与之前相同的方法，也就是说，左边边界上的一个面的 $\text{vertices}_2$ 应该与下面边界上的一个面的顶点 $\text{vertices}_1$ 匹配，由 $\text{vertices}_2=R\cdot \text{vertices}_1+b$  ]，其中旋转矩阵 $R$ 和偏移量 $b$ 由
// @f{align*}
//  R=\begin{pmatrix}
//  0&1\\-1&0
//  \end{pmatrix},
//  \quad
//  b=\begin{pmatrix}0&0\end{pmatrix}.
//  @f}
//  给出。 这两个对象不仅描述了应该如何匹配面，而且还描述了解决方案应该从 $\text{face}_2$ 转换到 $\text{face}_1$ 的意义。

      FullMatrix<double> rotation_matrix(dim); 
      rotation_matrix[0][1] = 1.; 
      rotation_matrix[1][0] = -1.; 

      Tensor<1, dim> offset; 

// 为了设置约束，我们首先将周期性信息存储在一个类型为 <code>std::vector@<GridTools::PeriodicFacePair<typename 的辅助对象中。
// DoFHandler@<dim@>::%cell_iterator@>  </code>。周期性边界的边界指标为2（x=0）和3（y=0）。所有其他的参数我们之前已经设置好了。在这种情况下，方向并不重要。由于 $\text{vertices}_2=R\cdot \text{vertices}_1+b$ 这正是我们想要的。

      std::vector< 
        GridTools::PeriodicFacePair<typename DoFHandler<dim>::cell_iterator>> 
        periodicity_vector; 

      const unsigned int direction = 1; 

      GridTools::collect_periodic_faces(dof_handler, 
                                        2, 
                                        3, 
                                        direction, 
                                        periodicity_vector, 
                                        offset, 
                                        rotation_matrix); 

// 接下来，我们需要提供关于解决方案中哪些矢量值分量应该被旋转的信息。由于我们在这里选择只约束速度，并且从解决方案矢量的第一个分量开始，我们只需插入一个0。

      std::vector<unsigned int> first_vector_components; 
      first_vector_components.push_back(0); 

// 在设置了周期性_vector中的所有信息之后，我们要做的就是告诉make_periodicity_constraints来创建所需的约束。

      DoFTools::make_periodicity_constraints<dim, dim>(periodicity_vector, 
                                                       constraints, 
                                                       fe.component_mask( 
                                                         velocities), 
                                                       first_vector_components); 

      VectorTools::interpolate_boundary_values(mapping, 
                                               dof_handler, 
                                               0, 
                                               BoundaryValues<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 
      VectorTools::interpolate_boundary_values(mapping, 
                                               dof_handler, 
                                               1, 
                                               BoundaryValues<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 
    } 

    constraints.close(); 

    { 
      TrilinosWrappers::BlockSparsityPattern bsp(owned_partitioning, 
                                                 owned_partitioning, 
                                                 relevant_partitioning, 
                                                 mpi_communicator); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (!((c == dim) && (d == dim))) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern(dof_handler, 
                                      coupling, 
                                      bsp, 
                                      constraints, 
                                      false, 
                                      Utilities::MPI::this_mpi_process( 
                                        mpi_communicator)); 

      bsp.compress(); 

      system_matrix.reinit(bsp); 
    } 

    { 
      TrilinosWrappers::BlockSparsityPattern preconditioner_bsp( 
        owned_partitioning, 
        owned_partitioning, 
        relevant_partitioning, 
        mpi_communicator); 

      Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1); 
      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if ((c == dim) && (d == dim)) 
            preconditioner_coupling[c][d] = DoFTools::always; 
          else 
            preconditioner_coupling[c][d] = DoFTools::none; 

      DoFTools::make_sparsity_pattern(dof_handler, 
                                      preconditioner_coupling, 
                                      preconditioner_bsp, 
                                      constraints, 
                                      false, 
                                      Utilities::MPI::this_mpi_process( 
                                        mpi_communicator)); 

      preconditioner_bsp.compress(); 

      preconditioner_matrix.reinit(preconditioner_bsp); 
    } 

    system_rhs.reinit(owned_partitioning, mpi_communicator); 
    solution.reinit(owned_partitioning, 
                    relevant_partitioning, 
                    mpi_communicator); 
  } 

// 然后程序的其余部分又与  step-22  相同。我们现在省略它，但和以前一样，你可以在下面的 "普通程序 "部分找到这些部分。

//  @cond  SKIP

  template <int dim> 
  void StokesProblem<dim>::assemble_system() 
  { 
    system_matrix         = 0.; 
    system_rhs            = 0.; 
    preconditioner_matrix = 0.; 

    QGauss<dim> quadrature_formula(degree + 2); 

    FEValues<dim> fe_values(mapping, 
                            fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values | update_gradients); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

    const unsigned int n_q_points = quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> local_preconditioner_matrix(dofs_per_cell, 
                                                   dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const RightHandSide<dim>    right_hand_side; 
    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1)); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell); 
    std::vector<double>                  div_phi_u(dofs_per_cell); 
    std::vector<double>                  phi_p(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_values.reinit(cell); 
          local_matrix                = 0; 
          local_preconditioner_matrix = 0; 
          local_rhs                   = 0; 

          right_hand_side.vector_value_list(fe_values.get_quadrature_points(), 
                                            rhs_values); 

          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 
              for (unsigned int k = 0; k < dofs_per_cell; ++k) 
                { 
                  symgrad_phi_u[k] = 
                    fe_values[velocities].symmetric_gradient(k, q); 
                  div_phi_u[k] = fe_values[velocities].divergence(k, q); 
                  phi_p[k]     = fe_values[pressure].value(k, q); 
                } 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j <= i; ++j) 
                    { 
                      local_matrix(i, j) += 
                        (symgrad_phi_u[i] * symgrad_phi_u[j] // diffusion 
                         - div_phi_u[i] * phi_p[j]           // pressure force 
                         - phi_p[i] * div_phi_u[j])          // divergence 
                        * fe_values.JxW(q); 

                      local_preconditioner_matrix(i, j) += 
                        (phi_p[i] * phi_p[j]) * fe_values.JxW(q); 
                    } 

                  const unsigned int component_i = 
                    fe.system_to_component_index(i).first; 
                  local_rhs(i) += fe_values.shape_value(i, q)  // 
                                  * rhs_values[q](component_i) // 
                                  * fe_values.JxW(q); 
                } 
            } 

          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = i + 1; j < dofs_per_cell; ++j) 
              { 
                local_matrix(i, j) = local_matrix(j, i); 
                local_preconditioner_matrix(i, j) = 
                  local_preconditioner_matrix(j, i); 
              } 

          cell->get_dof_indices(local_dof_indices); 
          constraints.distribute_local_to_global(local_matrix, 
                                                 local_rhs, 
                                                 local_dof_indices, 
                                                 system_matrix, 
                                                 system_rhs); 
          constraints.distribute_local_to_global(local_preconditioner_matrix, 
                                                 local_dof_indices, 
                                                 preconditioner_matrix); 
        } 

    system_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 

    pcout << "   Computing preconditioner..." << std::endl << std::flush; 
  } 

  template <int dim> 
  void StokesProblem<dim>::solve() 
  { 
    TrilinosWrappers::PreconditionJacobi A_preconditioner; 
    A_preconditioner.initialize(system_matrix.block(0, 0)); 

    const InverseMatrix<TrilinosWrappers::SparseMatrix, 
                        TrilinosWrappers::PreconditionJacobi> 
      A_inverse(system_matrix.block(0, 0), 
                A_preconditioner, 
                owned_partitioning[0], 
                mpi_communicator); 

    TrilinosWrappers::MPI::BlockVector tmp(owned_partitioning, 
                                           mpi_communicator); 

 
      TrilinosWrappers::MPI::Vector schur_rhs(owned_partitioning[1], 
                                              mpi_communicator); 
      A_inverse.vmult(tmp.block(0), system_rhs.block(0)); 
      system_matrix.block(1, 0).vmult(schur_rhs, tmp.block(0)); 
      schur_rhs -= system_rhs.block(1); 

      SchurComplement<TrilinosWrappers::PreconditionJacobi> schur_complement( 
        system_matrix, A_inverse, owned_partitioning[0], mpi_communicator); 

      SolverControl solver_control(solution.block(1).size(), 
                                   1e-6 * schur_rhs.l2_norm()); 
      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control); 

      TrilinosWrappers::PreconditionAMG preconditioner; 
      preconditioner.initialize(preconditioner_matrix.block(1, 1)); 

      InverseMatrix<TrilinosWrappers::SparseMatrix, 
                    TrilinosWrappers::PreconditionAMG> 
        m_inverse(preconditioner_matrix.block(1, 1), 
                  preconditioner, 
                  owned_partitioning[1], 
                  mpi_communicator); 

      cg.solve(schur_complement, tmp.block(1), schur_rhs, preconditioner); 

      constraints.distribute(tmp); 
      solution.block(1) = tmp.block(1); 
    } 

    { 
      system_matrix.block(0, 1).vmult(tmp.block(0), tmp.block(1)); 
      tmp.block(0) *= -1; 
      tmp.block(0) += system_rhs.block(0); 

      A_inverse.vmult(tmp.block(0), tmp.block(0)); 

      constraints.distribute(tmp); 
      solution.block(0) = tmp.block(0); 
    } 
  } 

  template <int dim> 
  void 
  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("pressure"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    Vector<float> subdomain(triangulation.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      subdomain(i) = triangulation.locally_owned_subdomain(); 
    data_out.add_data_vector(subdomain, "subdomain"); 
    data_out.build_patches(mapping, degree + 1); 

    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", refinement_cycle, MPI_COMM_WORLD, 2); 
  } 

  template <int dim> 
  void StokesProblem<dim>::refine_mesh() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    FEValuesExtractors::Scalar pressure(dim); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      estimated_error_per_cell, 
      fe.component_mask(pressure)); 

    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number( 
      triangulation, estimated_error_per_cell, 0.3, 0.0); 
    triangulation.execute_coarsening_and_refinement(); 
  } 

  template <int dim> 
  void StokesProblem<dim>::run() 
  { 
    create_mesh(); 

    for (unsigned int refinement_cycle = 0; refinement_cycle < 9; 
         ++refinement_cycle) 
      { 
        pcout << "Refinement cycle " << refinement_cycle << std::endl; 

        if (refinement_cycle > 0) 
          refine_mesh(); 

        setup_dofs(); 

        pcout << "   Assembling..." << std::endl << std::flush; 
        assemble_system(); 

        pcout << "   Solving..." << std::flush; 
        solve(); 

        output_results(refinement_cycle); 

        pcout << std::endl; 
      } 
  } 
} // namespace Step45 

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step45; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 
      StokesProblem<2>                 flow_problem(1); 
      flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 
// @endcond  


CCTest_file/step-46.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2011 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Texas A&M University, 2011 
 */ 


// @sect3{Include files}  

// 这个程序的包含文件与之前许多其他程序的包含文件是一样的。唯一的新文件是在介绍中讨论的声明FE_Nothing的文件。hp目录下的文件已经在  step-27  中讨论过了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_nothing.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/hp/fe_collection.h> 
#include <deal.II/hp/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <iostream> 
#include <fstream> 

namespace Step46 
{ 
  using namespace dealii; 
// @sect3{The <code>FluidStructureProblem</code> class template}  

// 这是主类。如果你想的话，它是 step-8 和 step-22 的组合，因为它的成员变量要么针对全局问题（Triangulation和DoFHandler对象，以及 hp::FECollection 和各种线性代数对象），要么与弹性或斯托克斯子问题有关。然而，该类的一般结构与其他大多数实现静止问题的程序一样。

// 有几个不言自明的辅助函数（<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>）（对两个子域的符号名称进行操作，这些名称将被用作属于子域的单元的 material_ids。正如介绍中所解释的那样）和几个函数（<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>），这些函数已经从其他的函数中分离出来，可以在其他的教程程序中找到，我们将在实现它们的时候讨论。

// 最后一组变量 (  <code>viscosity, lambda, eta</code>  ) 描述了用于两个物理模型的材料属性。

  template <int dim> 
  class FluidStructureProblem 
  { 
  public: 
    FluidStructureProblem(const unsigned int stokes_degree, 
                          const unsigned int elasticity_degree); 
    void run(); 

  private: 
    enum 
    { 
      fluid_domain_id, 
      solid_domain_id 
    }; 

    static bool cell_is_in_fluid_domain( 
      const typename DoFHandler<dim>::cell_iterator &cell); 

    static bool cell_is_in_solid_domain( 
      const typename DoFHandler<dim>::cell_iterator &cell); 

    void make_grid(); 
    void set_active_fe_indices(); 
    void setup_dofs(); 
    void assemble_system(); 
    void assemble_interface_term( 
      const FEFaceValuesBase<dim> &         elasticity_fe_face_values, 
      const FEFaceValuesBase<dim> &         stokes_fe_face_values, 
      std::vector<Tensor<1, dim>> &         elasticity_phi, 
      std::vector<SymmetricTensor<2, dim>> &stokes_symgrad_phi_u, 
      std::vector<double> &                 stokes_phi_p, 
      FullMatrix<double> &                  local_interface_matrix) const; 
    void solve(); 
    void output_results(const unsigned int refinement_cycle) const; 
    void refine_mesh(); 

    const unsigned int stokes_degree; 
    const unsigned int elasticity_degree; 

    Triangulation<dim>    triangulation; 
    FESystem<dim>         stokes_fe; 
    FESystem<dim>         elasticity_fe; 
    hp::FECollection<dim> fe_collection; 
    DoFHandler<dim>       dof_handler; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    const double viscosity; 
    const double lambda; 
    const double mu; 
  }; 
// @sect3{Boundary values and right hand side}  

// 下面这个类如其名。速度的边界值分别为2d的 
//  $\mathbf u=(0, \sin(\pi x))^T$ 和3d的 $\mathbf u=(0,
//  0, \sin(\pi x)\sin(\pi y))^T$ 。
//  这个问题的其余边界条件都是同质的，在介绍中已经讨论过。右边的强迫项对于流体和固体都是零，所以我们不需要为它设置额外的类。

  template <int dim> 
  class StokesBoundaryValues : public Function<dim> 
  { 
  public: 
    StokesBoundaryValues() 
      : Function<dim>(dim + 1 + dim) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  double StokesBoundaryValues<dim>::value(const Point<dim> & p, 
                                          const unsigned int component) const 
  { 
    Assert(component < this->n_components, 
           ExcIndexRange(component, 0, this->n_components)); 

    if (component == dim - 1) 
      switch (dim) 
        { 
          case 2: 
            return std::sin(numbers::PI * p[0]); 
          case 3: 
            return std::sin(numbers::PI * p[0]) * std::sin(numbers::PI * p[1]); 
          default: 
            Assert(false, ExcNotImplemented()); 
        } 

    return 0; 
  } 

  template <int dim> 
  void StokesBoundaryValues<dim>::vector_value(const Point<dim> &p, 
                                               Vector<double> &  values) const 
  { 
    for (unsigned int c = 0; c < this->n_components; ++c) 
      values(c) = StokesBoundaryValues<dim>::value(p, c); 
  } 

//  @sect3{The <code>FluidStructureProblem</code> implementation}  
// @sect4{Constructors and helper functions}  

// 现在我们来谈谈这个程序的主类的实现。最初的几个函数是构造函数和辅助函数，可以用来确定一个单元格在域的哪个部分。鉴于介绍中对这些主题的讨论，它们的实现是相当明显的。在构造函数中，注意我们必须从斯托克斯和弹性的基本元素中构造 hp::FECollection 对象；使用 hp::FECollection::push_back 函数在这个集合中为它们分配了0和1的位置，我们必须记住这个顺序，并在程序的其余部分一致使用。

  template <int dim> 
  FluidStructureProblem<dim>::FluidStructureProblem( 
    const unsigned int stokes_degree, 
    const unsigned int elasticity_degree) 
    : stokes_degree(stokes_degree) 
    , elasticity_degree(elasticity_degree) 
    , triangulation(Triangulation<dim>::maximum_smoothing) 
    , stokes_fe(FE_Q<dim>(stokes_degree + 1), 
                dim, 
                FE_Q<dim>(stokes_degree), 
                1, 
                FE_Nothing<dim>(), 
                dim) 
    , elasticity_fe(FE_Nothing<dim>(), 
                    dim, 
                    FE_Nothing<dim>(), 
                    1, 
                    FE_Q<dim>(elasticity_degree), 
                    dim) 
    , dof_handler(triangulation) 
    , viscosity(2) 
    , lambda(1) 
    , mu(1) 
  { 
    fe_collection.push_back(stokes_fe); 
    fe_collection.push_back(elasticity_fe); 
  } 

  template <int dim> 
  bool FluidStructureProblem<dim>::cell_is_in_fluid_domain( 
    const typename DoFHandler<dim>::cell_iterator &cell) 
  { 
    return (cell->material_id() == fluid_domain_id); 
  } 

  template <int dim> 
  bool FluidStructureProblem<dim>::cell_is_in_solid_domain( 
    const typename DoFHandler<dim>::cell_iterator &cell) 
  { 
    return (cell->material_id() == solid_domain_id); 
  } 
// @sect4{Meshes and assigning subdomains}  

// 接下来的一对函数是处理生成网格，并确保所有表示子域的标志都是正确的。  <code>make_grid</code>  ，正如在介绍中所讨论的，生成一个 $8\times 8$ 的网格（或者一个 $8\times 8\times 8$ 的三维网格）以确保每个粗略的网格单元完全在一个子域内。生成这个网格后，我们在其边界上循环，并在顶部边界设置边界指标为1，这是我们设置非零迪里希特边界条件的唯一地方。在这之后，我们再次在所有单元上循环，设置材料指标&mdash;用来表示我们处于域的哪一部分，是流体指标还是固体指标。

  template <int dim> 
  void FluidStructureProblem<dim>::make_grid() 
  { 
    GridGenerator::subdivided_hyper_cube(triangulation, 8, -1, 1); 

    for (const auto &cell : triangulation.active_cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->at_boundary() && (face->center()[dim - 1] == 1)) 
          face->set_all_boundary_ids(1); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (((std::fabs(cell->center()[0]) < 0.25) && 
           (cell->center()[dim - 1] > 0.5)) || 
          ((std::fabs(cell->center()[0]) >= 0.25) && 
           (cell->center()[dim - 1] > -0.5))) 
        cell->set_material_id(fluid_domain_id); 
      else 
        cell->set_material_id(solid_domain_id); 
  } 

// 这对函数的第二部分决定在每个单元上使用哪个有限元。上面我们设置了每个粗略网格单元的材料指标，正如在介绍中提到的，这个信息在网格细化时将从母单元继承到子单元。

// 换句话说，只要我们细化（或创建）了网格，我们就可以依靠材料指示器来正确描述一个单元所处的域的哪一部分。然后我们利用这一点将单元的活动FE索引设置为该类的 hp::FECollection 成员变量中的相应元素：流体单元为0，固体单元为1。

  template <int dim> 
  void FluidStructureProblem<dim>::set_active_fe_indices() 
  { 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        if (cell_is_in_fluid_domain(cell)) 
          cell->set_active_fe_index(0); 
        else if (cell_is_in_solid_domain(cell)) 
          cell->set_active_fe_index(1); 
        else 
          Assert(false, ExcNotImplemented()); 
      } 
  } 
// @sect4{<code>FluidStructureProblem::setup_dofs</code>}  

// 下一步是为线性系统设置数据结构。为此，我们首先要用上面的函数设置活动FE指数，然后分配自由度，再确定线性系统的约束。后者包括像往常一样的悬挂节点约束，但也包括顶部流体边界的不均匀边界值，以及沿固体子域周边的零边界值。

  template <int dim> 
  void FluidStructureProblem<dim>::setup_dofs() 
  { 
    set_active_fe_indices(); 
    dof_handler.distribute_dofs(fe_collection); 

    { 
      constraints.clear(); 
      DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

      const FEValuesExtractors::Vector velocities(0); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               1, 
                                               StokesBoundaryValues<dim>(), 
                                               constraints, 
                                               fe_collection.component_mask( 
                                                 velocities)); 

      const FEValuesExtractors::Vector displacements(dim + 1); 
      VectorTools::interpolate_boundary_values( 
        dof_handler, 
        0, 
        Functions::ZeroFunction<dim>(dim + 1 + dim), 
        constraints, 
        fe_collection.component_mask(displacements)); 
    } 

// 不过，我们还需要处理更多的约束条件：我们必须确保在流体和固体的界面上速度为零。下面这段代码已经在介绍中介绍过了。

    { 
      std::vector<types::global_dof_index> local_face_dof_indices( 
        stokes_fe.n_dofs_per_face()); 
      for (const auto &cell : dof_handler.active_cell_iterators()) 
        if (cell_is_in_fluid_domain(cell)) 
          for (const auto face_no : cell->face_indices()) 
            if (cell->face(face_no)->at_boundary() == false) 
              { 
                bool face_is_on_interface = false; 

                if ((cell->neighbor(face_no)->has_children() == false) && 
                    (cell_is_in_solid_domain(cell->neighbor(face_no)))) 
                  face_is_on_interface = true; 
                else if (cell->neighbor(face_no)->has_children() == true) 
                  { 
                    for (unsigned int sf = 0; 
                         sf < cell->face(face_no)->n_children(); 
                         ++sf) 
                      if (cell_is_in_solid_domain( 
                            cell->neighbor_child_on_subface(face_no, sf))) 
                        { 
                          face_is_on_interface = true; 
                          break; 
                        } 
                  } 

                if (face_is_on_interface) 
                  { 
                    cell->face(face_no)->get_dof_indices(local_face_dof_indices, 
                                                         0); 
                    for (unsigned int i = 0; i < local_face_dof_indices.size(); 
                         ++i) 
                      if (stokes_fe.face_system_to_component_index(i).first < 
                          dim) 
                        constraints.add_line(local_face_dof_indices[i]); 
                  } 
              } 
    } 

// 在这一切结束后，我们可以向约束对象声明，我们现在已经准备好了所有的约束，并且该对象可以重建其内部数据结构以提高效率。

    constraints.close(); 

    std::cout << "   Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

// 在这个函数的其余部分，我们创建了一个在介绍中广泛讨论的稀疏模式，并使用它来初始化矩阵；然后还将向量设置为正确的大小。

    { 
      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 

      Table<2, DoFTools::Coupling> cell_coupling(fe_collection.n_components(), 
                                                 fe_collection.n_components()); 
      Table<2, DoFTools::Coupling> face_coupling(fe_collection.n_components(), 
                                                 fe_collection.n_components()); 

      for (unsigned int c = 0; c < fe_collection.n_components(); ++c) 
        for (unsigned int d = 0; d < fe_collection.n_components(); ++d) 
          { 
            if (((c < dim + 1) && (d < dim + 1) && 
                 !((c == dim) && (d == dim))) || 
                ((c >= dim + 1) && (d >= dim + 1))) 
              cell_coupling[c][d] = DoFTools::always; 

            if ((c >= dim + 1) && (d < dim + 1)) 
              face_coupling[c][d] = DoFTools::always; 
          } 

      DoFTools::make_flux_sparsity_pattern(dof_handler, 
                                           dsp, 
                                           cell_coupling, 
                                           face_coupling); 
      constraints.condense(dsp); 
      sparsity_pattern.copy_from(dsp); 
    } 

    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 

//  @sect4{<code>FluidStructureProblem::assemble_system</code>}  

// 下面是这个程序的中心函数：组装线性系统的函数。它在开始时有一长段设置辅助函数的内容：从创建正交公式到设置FEValues、FEFaceValues和FESubfaceValues对象，这些都是整合单元项以及界面项所必需的，以应对界面上的单元以相同大小或不同细化程度聚集在一起的情况...

  template <int dim> 
  void FluidStructureProblem<dim>::assemble_system() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    const QGauss<dim> stokes_quadrature(stokes_degree + 2); 
    const QGauss<dim> elasticity_quadrature(elasticity_degree + 2); 

    hp::QCollection<dim> q_collection; 
    q_collection.push_back(stokes_quadrature); 
    q_collection.push_back(elasticity_quadrature); 

    hp::FEValues<dim> hp_fe_values(fe_collection, 
                                   q_collection, 
                                   update_values | update_quadrature_points | 
                                     update_JxW_values | update_gradients); 

    const QGauss<dim - 1> common_face_quadrature( 
      std::max(stokes_degree + 2, elasticity_degree + 2)); 

    FEFaceValues<dim>    stokes_fe_face_values(stokes_fe, 
                                            common_face_quadrature, 
                                            update_JxW_values | 
                                              update_gradients | update_values); 
    FEFaceValues<dim>    elasticity_fe_face_values(elasticity_fe, 
                                                common_face_quadrature, 
                                                update_normal_vectors | 
                                                  update_values); 
    FESubfaceValues<dim> stokes_fe_subface_values(stokes_fe, 
                                                  common_face_quadrature, 
                                                  update_JxW_values | 
                                                    update_gradients | 
                                                    update_values); 
    FESubfaceValues<dim> elasticity_fe_subface_values(elasticity_fe, 
                                                      common_face_quadrature, 
                                                      update_normal_vectors | 
                                                        update_values); 

// ...描述局部对全局线性系统贡献所需的对象...

    const unsigned int stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell(); 
    const unsigned int elasticity_dofs_per_cell = 
      elasticity_fe.n_dofs_per_cell(); 

    FullMatrix<double> local_matrix; 
    FullMatrix<double> local_interface_matrix(elasticity_dofs_per_cell, 
                                              stokes_dofs_per_cell); 
    Vector<double>     local_rhs; 

    std::vector<types::global_dof_index> local_dof_indices; 
    std::vector<types::global_dof_index> neighbor_dof_indices( 
      stokes_dofs_per_cell); 

    const Functions::ZeroFunction<dim> right_hand_side(dim + 1); 

// ...到变量，允许我们提取形状函数的某些成分并缓存它们的值，而不是在每个正交点重新计算它们。

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 
    const FEValuesExtractors::Vector displacements(dim + 1); 

    std::vector<SymmetricTensor<2, dim>> stokes_symgrad_phi_u( 
      stokes_dofs_per_cell); 
    std::vector<double> stokes_div_phi_u(stokes_dofs_per_cell); 
    std::vector<double> stokes_phi_p(stokes_dofs_per_cell); 

    std::vector<Tensor<2, dim>> elasticity_grad_phi(elasticity_dofs_per_cell); 
    std::vector<double>         elasticity_div_phi(elasticity_dofs_per_cell); 
    std::vector<Tensor<1, dim>> elasticity_phi(elasticity_dofs_per_cell); 

// 然后是所有单元格的主循环，和 step-27 一样，初始化当前单元格的 hp::FEValues 对象，提取适合当前单元格的FEValues对象。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        hp_fe_values.reinit(cell); 

        const FEValues<dim> &fe_values = hp_fe_values.get_present_fe_values(); 

        local_matrix.reinit(cell->get_fe().n_dofs_per_cell(), 
                            cell->get_fe().n_dofs_per_cell()); 
        local_rhs.reinit(cell->get_fe().n_dofs_per_cell()); 

// 做完这些后，我们继续为属于斯托克斯和弹性区域的单元组装单元项。虽然我们原则上可以在一个公式中完成，实际上就是实现了介绍中所说的双线性形式，但我们意识到，我们的有限元空间的选择方式是，在每个单元上，有一组变量（速度和压力，或者位移）总是为零，因此，计算局部积分的更有效的方法是，根据测试我们处于域的哪一部分的 <code>if</code> 条款，只做必要的事情。

// 局部矩阵的实际计算与 step-22 以及 @ref vector_valued 文件模块中给出的弹性方程的计算相同。

        if (cell_is_in_fluid_domain(cell)) 
          { 
            const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell(); 
            Assert(dofs_per_cell == stokes_dofs_per_cell, ExcInternalError()); 

            for (unsigned int q = 0; q < fe_values.n_quadrature_points; ++q) 
              { 
                for (unsigned int k = 0; k < dofs_per_cell; ++k) 
                  { 
                    stokes_symgrad_phi_u[k] = 
                      fe_values[velocities].symmetric_gradient(k, q); 
                    stokes_div_phi_u[k] = 
                      fe_values[velocities].divergence(k, q); 
                    stokes_phi_p[k] = fe_values[pressure].value(k, q); 
                  } 

                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    local_matrix(i, j) += 
                      (2 * viscosity * stokes_symgrad_phi_u[i] * 
                         stokes_symgrad_phi_u[j] - 
                       stokes_div_phi_u[i] * stokes_phi_p[j] - 
                       stokes_phi_p[i] * stokes_div_phi_u[j]) * 
                      fe_values.JxW(q); 
              } 
          } 
        else 
          { 
            const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell(); 
            Assert(dofs_per_cell == elasticity_dofs_per_cell, 
                   ExcInternalError()); 

            for (unsigned int q = 0; q < fe_values.n_quadrature_points; ++q) 
              { 
                for (unsigned int k = 0; k < dofs_per_cell; ++k) 
                  { 
                    elasticity_grad_phi[k] = 
                      fe_values[displacements].gradient(k, q); 
                    elasticity_div_phi[k] = 
                      fe_values[displacements].divergence(k, q); 
                  } 

                for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    { 
                      local_matrix(i, j) += 
                        (lambda * elasticity_div_phi[i] * 
                           elasticity_div_phi[j] + 
                         mu * scalar_product(elasticity_grad_phi[i], 
                                             elasticity_grad_phi[j]) + 
                         mu * 
                           scalar_product(elasticity_grad_phi[i], 
                                          transpose(elasticity_grad_phi[j]))) * 
                        fe_values.JxW(q); 
                    } 
              } 
          } 

// 一旦我们得到了单元积分的贡献，我们就把它们复制到全局矩阵中（通过 AffineConstraints::distribute_local_to_global 函数，立即处理约束）。请注意，我们没有向 <code>local_rhs</code> 变量中写入任何东西，尽管我们仍然需要传递它，因为消除非零边界值需要修改局部，因此也需要修改全局的右手值。

        local_dof_indices.resize(cell->get_fe().n_dofs_per_cell()); 
        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global(local_matrix, 
                                               local_rhs, 
                                               local_dof_indices, 
                                               system_matrix, 
                                               system_rhs); 

// 这个函数更有趣的部分是我们看到关于两个子域之间的界面上的脸部条款。为此，我们首先要确保我们只组装一次，即使在所有单元的所有面的循环中会遇到界面的每一部分两次。我们武断地决定，只有当当前单元是固体子域的一部分，并且因此一个面不在边界上，并且它后面的潜在邻居是流体域的一部分时，我们才会评估界面条款。让我们从这些条件开始。

        if (cell_is_in_solid_domain(cell)) 
          for (const auto f : cell->face_indices()) 
            if (cell->face(f)->at_boundary() == false) 
              { 

// 在这一点上，我们知道当前的单元格是一个候选的整合对象，并且面 <code>f</code> 后面存在一个邻居。现在有三种可能性。           

// - 邻居处于同一细化水平，并且没有孩子。     

// - 邻居有子女。     

// - 邻居比较粗糙。            在所有这三种情况下，我们只对它感兴趣，如果它是流体子域的一部分。因此，让我们从第一种最简单的情况开始：如果邻居处于同一层次，没有子女，并且是一个流体单元，那么这两个单元共享一个边界，这个边界是界面的一部分，我们想沿着这个边界整合界面项。我们所要做的就是用当前面和邻接单元的面初始化两个FEFaceValues对象（注意我们是如何找出邻接单元的哪个面与当前单元接壤的），然后把东西传给评估界面项的函数（这个函数的第三个到第五个参数为它提供了抓取数组）。然后，结果再次被复制到全局矩阵中，使用一个知道本地矩阵的行和列的DoF指数来自不同单元的函数。

                if ((cell->neighbor(f)->level() == cell->level()) && 
                    (cell->neighbor(f)->has_children() == false) && 
                    cell_is_in_fluid_domain(cell->neighbor(f))) 
                  { 
                    elasticity_fe_face_values.reinit(cell, f); 
                    stokes_fe_face_values.reinit(cell->neighbor(f), 
                                                 cell->neighbor_of_neighbor(f)); 

                    assemble_interface_term(elasticity_fe_face_values, 
                                            stokes_fe_face_values, 
                                            elasticity_phi, 
                                            stokes_symgrad_phi_u, 
                                            stokes_phi_p, 
                                            local_interface_matrix); 

                    cell->neighbor(f)->get_dof_indices(neighbor_dof_indices); 
                    constraints.distribute_local_to_global( 
                      local_interface_matrix, 
                      local_dof_indices, 
                      neighbor_dof_indices, 
                      system_matrix); 
                  } 

// 第二种情况是，如果邻居还有更多的孩子。在这种情况下，我们必须在邻居的所有子女中进行循环，看他们是否属于流体子域的一部分。如果它们是，那么我们就在共同界面上进行整合，这个界面是邻居的一个面和当前单元的一个子面，要求我们对邻居使用FEFaceValues，对当前单元使用FESubfaceValues。

                else if ((cell->neighbor(f)->level() == cell->level()) && 
                         (cell->neighbor(f)->has_children() == true)) 
                  { 
                    for (unsigned int subface = 0; 
                         subface < cell->face(f)->n_children(); 
                         ++subface) 
                      if (cell_is_in_fluid_domain( 
                            cell->neighbor_child_on_subface(f, subface))) 
                        { 
                          elasticity_fe_subface_values.reinit(cell, f, subface); 
                          stokes_fe_face_values.reinit( 
                            cell->neighbor_child_on_subface(f, subface), 
                            cell->neighbor_of_neighbor(f)); 

                          assemble_interface_term(elasticity_fe_subface_values, 
                                                  stokes_fe_face_values, 
                                                  elasticity_phi, 
                                                  stokes_symgrad_phi_u, 
                                                  stokes_phi_p, 
                                                  local_interface_matrix); 

                          cell->neighbor_child_on_subface(f, subface) 
                            ->get_dof_indices(neighbor_dof_indices); 
                          constraints.distribute_local_to_global( 
                            local_interface_matrix, 
                            local_dof_indices, 
                            neighbor_dof_indices, 
                            system_matrix); 
                        } 
                  } 

// 最后一个选项是，邻居比较粗大。在这种情况下，我们必须为邻居使用一个FESubfaceValues对象，为当前单元使用一个FEFaceValues；其余部分与之前相同。

                else if (cell->neighbor_is_coarser(f) && 
                         cell_is_in_fluid_domain(cell->neighbor(f))) 
                  { 
                    elasticity_fe_face_values.reinit(cell, f); 
                    stokes_fe_subface_values.reinit( 
                      cell->neighbor(f), 
                      cell->neighbor_of_coarser_neighbor(f).first, 
                      cell->neighbor_of_coarser_neighbor(f).second); 

                    assemble_interface_term(elasticity_fe_face_values, 
                                            stokes_fe_subface_values, 
                                            elasticity_phi, 
                                            stokes_symgrad_phi_u, 
                                            stokes_phi_p, 
                                            local_interface_matrix); 

                    cell->neighbor(f)->get_dof_indices(neighbor_dof_indices); 
                    constraints.distribute_local_to_global( 
                      local_interface_matrix, 
                      local_dof_indices, 
                      neighbor_dof_indices, 
                      system_matrix); 
                  } 
              } 
      } 
  } 

// 在组装全局系统的函数中，我们将计算接口条款传递给我们在此讨论的一个单独的函数。关键是，尽管我们无法预测FEFaceValues和FESubfaceValues对象的组合，但它们都是从FEFaceValuesBase类派生出来的，因此我们不必在意：该函数被简单地调用，有两个这样的对象表示面的两边的正交点上的形状函数值。然后我们做我们一直在做的事情：我们用形状函数的值和它们的导数来填充从头数组，然后循环计算矩阵的所有条目来计算局部积分。我们在这里评估的双线性形式的细节在介绍中给出。

  template <int dim> 
  void FluidStructureProblem<dim>::assemble_interface_term( 
    const FEFaceValuesBase<dim> &         elasticity_fe_face_values, 
    const FEFaceValuesBase<dim> &         stokes_fe_face_values, 
    std::vector<Tensor<1, dim>> &         elasticity_phi, 
    std::vector<SymmetricTensor<2, dim>> &stokes_symgrad_phi_u, 
    std::vector<double> &                 stokes_phi_p, 
    FullMatrix<double> &                  local_interface_matrix) const 
  { 
    Assert(stokes_fe_face_values.n_quadrature_points == 
             elasticity_fe_face_values.n_quadrature_points, 
           ExcInternalError()); 
    const unsigned int n_face_quadrature_points = 
      elasticity_fe_face_values.n_quadrature_points; 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 
    const FEValuesExtractors::Vector displacements(dim + 1); 

    local_interface_matrix = 0; 
    for (unsigned int q = 0; q < n_face_quadrature_points; ++q) 
      { 
        const Tensor<1, dim> normal_vector = 
          elasticity_fe_face_values.normal_vector(q); 

        for (unsigned int k = 0; k < stokes_fe_face_values.dofs_per_cell; ++k) 
          { 
            stokes_symgrad_phi_u[k] = 
              stokes_fe_face_values[velocities].symmetric_gradient(k, q); 
            stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q); 
          } 
        for (unsigned int k = 0; k < elasticity_fe_face_values.dofs_per_cell; 
             ++k) 
          elasticity_phi[k] = 
            elasticity_fe_face_values[displacements].value(k, q); 

        for (unsigned int i = 0; i < elasticity_fe_face_values.dofs_per_cell; 
             ++i) 
          for (unsigned int j = 0; j < stokes_fe_face_values.dofs_per_cell; ++j) 
            local_interface_matrix(i, j) += 
              -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) - 
                 stokes_phi_p[j] * normal_vector) * 
                elasticity_phi[i] * stokes_fe_face_values.JxW(q)); 
      } 
  } 
// @sect4{<code>FluidStructureProblem::solve</code>}  

// 正如介绍中所讨论的，我们在这里使用了一个相当琐碎的求解器：我们只是将线性系统传递给SparseDirectUMFPACK直接求解器（例如，见 step-29  ）。在求解之后，我们唯一要做的是确保悬挂的节点和边界值约束是正确的。

  template <int dim> 
  void FluidStructureProblem<dim>::solve() 
  { 
    SparseDirectUMFPACK direct_solver; 
    direct_solver.initialize(system_matrix); 
    direct_solver.vmult(solution, system_rhs); 

    constraints.distribute(solution); 
  } 

//  @sect4{<code>FluidStructureProblem::output_results</code>}  

// 生成图形输出在这里相当简单：我们所要做的就是确定解向量的哪些成分属于标量和/或向量（例如，见 step-22 之前的例子），然后把它全部传递给DataOut类。

  template <int dim> 
  void FluidStructureProblem<dim>::output_results( 
    const unsigned int refinement_cycle) const 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("pressure"); 
    for (unsigned int d = 0; d < dim; ++d) 
      solution_names.emplace_back("displacement"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    for (unsigned int d = 0; d < dim; ++d) 
      data_component_interpretation.push_back( 
        DataComponentInterpretation::component_is_part_of_vector); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 

    data_out.add_data_vector(solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.build_patches(); 

    std::ofstream output( 
      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk"); 
    data_out.write_vtk(output); 
  } 
// @sect4{<code>FluidStructureProblem::refine_mesh</code>}  

// 下一步是细化网格。正如在介绍中所讨论的，这有点棘手，主要是因为流体和固体子域使用的变量具有不同的物理尺寸，因此，误差估计的绝对大小不能直接比较。因此，我们将不得不对它们进行缩放。因此，在函数的顶部，我们首先分别计算不同变量的误差估计值（在流体域中使用速度而不是压力，在固体域中使用位移）。

  template <int dim> 
  void FluidStructureProblem<dim>::refine_mesh() 
  { 
    Vector<float> stokes_estimated_error_per_cell( 
      triangulation.n_active_cells()); 
    Vector<float> elasticity_estimated_error_per_cell( 
      triangulation.n_active_cells()); 

    const QGauss<dim - 1> stokes_face_quadrature(stokes_degree + 2); 
    const QGauss<dim - 1> elasticity_face_quadrature(elasticity_degree + 2); 

    hp::QCollection<dim - 1> face_q_collection; 
    face_q_collection.push_back(stokes_face_quadrature); 
    face_q_collection.push_back(elasticity_face_quadrature); 

    const FEValuesExtractors::Vector velocities(0); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      face_q_collection, 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      stokes_estimated_error_per_cell, 
      fe_collection.component_mask(velocities)); 

    const FEValuesExtractors::Vector displacements(dim + 1); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      face_q_collection, 
      std::map<types::boundary_id, const Function<dim> *>(), 
      solution, 
      elasticity_estimated_error_per_cell, 
      fe_collection.component_mask(displacements)); 

// 然后，我们通过除以误差估计值的法线对其进行归一化处理，并按照介绍中所讨论的那样，将流体误差指标按4的系数进行缩放。然后将这些结果加在一起，形成一个包含所有单元的误差指标的向量。

    stokes_estimated_error_per_cell *= 
      4. / stokes_estimated_error_per_cell.l2_norm(); 
    elasticity_estimated_error_per_cell *= 
      1. / elasticity_estimated_error_per_cell.l2_norm(); 

    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    estimated_error_per_cell += stokes_estimated_error_per_cell; 
    estimated_error_per_cell += elasticity_estimated_error_per_cell; 

// 在实际细化网格之前，函数的倒数第二部分涉及到我们在介绍中已经提到的启发式方法：由于解是不连续的，KellyErrorEstimator类对位于子域之间边界的单元感到困惑：它认为那里的误差很大，因为梯度的跳跃很大，尽管这完全是预期的，事实上在精确解中也存在这一特征，因此不表明任何数值错误。

// 因此，我们将界面上的所有单元的误差指标设置为零；决定影响哪些单元的条件略显尴尬，因为我们必须考虑到自适应细化网格的可能性，这意味着邻近的单元可能比当前的单元更粗，或者事实上可能被细化一些。这些嵌套条件的结构与我们在 <code>assemble_system</code> 中组装接口条款时遇到的情况基本相同。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      for (const auto f : cell->face_indices()) 
        if (cell_is_in_solid_domain(cell)) 
          { 
            if ((cell->at_boundary(f) == false) && 
                (((cell->neighbor(f)->level() == cell->level()) && 
                  (cell->neighbor(f)->has_children() == false) && 
                  cell_is_in_fluid_domain(cell->neighbor(f))) || 
                 ((cell->neighbor(f)->level() == cell->level()) && 
                  (cell->neighbor(f)->has_children() == true) && 
                  (cell_is_in_fluid_domain( 
                    cell->neighbor_child_on_subface(f, 0)))) || 
                 (cell->neighbor_is_coarser(f) && 
                  cell_is_in_fluid_domain(cell->neighbor(f))))) 
              estimated_error_per_cell(cell->active_cell_index()) = 0; 
          } 
        else 
          { 
            if ((cell->at_boundary(f) == false) && 
                (((cell->neighbor(f)->level() == cell->level()) && 
                  (cell->neighbor(f)->has_children() == false) && 
                  cell_is_in_solid_domain(cell->neighbor(f))) || 
                 ((cell->neighbor(f)->level() == cell->level()) && 
                  (cell->neighbor(f)->has_children() == true) && 
                  (cell_is_in_solid_domain( 
                    cell->neighbor_child_on_subface(f, 0)))) || 
                 (cell->neighbor_is_coarser(f) && 
                  cell_is_in_solid_domain(cell->neighbor(f))))) 
              estimated_error_per_cell(cell->active_cell_index()) = 0; 
          } 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.0); 
    triangulation.execute_coarsening_and_refinement(); 
  } 

//  @sect4{<code>FluidStructureProblem::run</code>}  

// 像往常一样，这是控制整个操作流程的函数。如果你读过教程程序  step-1  到  step-6  ，例如，那么你已经对以下结构相当熟悉。

  template <int dim> 
  void FluidStructureProblem<dim>::run() 
  { 
    make_grid(); 

    for (unsigned int refinement_cycle = 0; refinement_cycle < 10 - 2 * dim; 
         ++refinement_cycle) 
      { 
        std::cout << "Refinement cycle " << refinement_cycle << std::endl; 

        if (refinement_cycle > 0) 
          refine_mesh(); 

        setup_dofs(); 

        std::cout << "   Assembling..." << std::endl; 
        assemble_system(); 

        std::cout << "   Solving..." << std::endl; 
        solve(); 

        std::cout << "   Writing output..." << std::endl; 
        output_results(refinement_cycle); 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step46 

//  @sect4{The <code>main()</code> function}  

// 这个，最后的，函数所包含的内容几乎与其他大多数教程程序的内容完全一样。

int main() 
{ 
  try 
    { 
      using namespace Step46; 

      FluidStructureProblem<2> flow_problem(1, 1); 
      flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-47.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2019 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Natasha Sharma, University of Texas at El Paso, 
 *          Guido Kanschat, University of Heidelberg 
 *          Timo Heister, Clemson University 
 *          Wolfgang Bangerth, Colorado State University 
 *          Zhuroan Wang, Colorado State University 
 */ 


// @sect3{Include files}  

// 前面的几个include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。该程序的主要结构与例如 step-4 的结构非常相似，因此我们包含了许多相同的头文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/sparse_direct.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 

// 最有趣的两个头文件将是这两个。

#include <deal.II/fe/fe_interface_values.h> 
#include <deal.II/meshworker/mesh_loop.h> 

// 其中第一个文件负责提供FEInterfaceValues类，该类可用于评估单元间界面的形状函数（或其梯度）的跳跃或平均值等数量。这个类在评估C0IP公式中出现的惩罚项时将相当有用。

#include <fstream> 
#include <iostream> 
#include <cmath> 

namespace Step47 
{ 
  using namespace dealii; 

// 在下面的命名空间中，让我们定义精确解，我们将与数值计算的解进行比较。它的形式是 $u(x,y) = \sin(\pi x) \sin(\pi y)$ （只实现了2d的情况），该命名空间还包含一个对应于产生该解的右手边的类。

  namespace ExactSolution 
  { 
    using numbers::PI; 

    template <int dim> 
    class Solution : public Function<dim> 
    { 
    public: 
      static_assert(dim == 2, "Only dim==2 is implemented."); 

      virtual double value(const Point<dim> &p, 
                           const unsigned int /*component*/ = 0) const override 
      { 
        return std::sin(PI * p[0]) * std::sin(PI * p[1]); 
      } 

      virtual Tensor<1, dim> 
      gradient(const Point<dim> &p, 
               const unsigned int /*component*/ = 0) const override 
      { 
        Tensor<1, dim> r; 
        r[0] = PI * std::cos(PI * p[0]) * std::sin(PI * p[1]); 
        r[1] = PI * std::cos(PI * p[1]) * std::sin(PI * p[0]); 
        return r; 
      } 

      virtual void 
      hessian_list(const std::vector<Point<dim>> &       points, 
                   std::vector<SymmetricTensor<2, dim>> &hessians, 
                   const unsigned int /*component*/ = 0) const override 
      { 
        for (unsigned i = 0; i < points.size(); ++i) 
          { 
            const double x = points[i][0]; 
            const double y = points[i][1]; 

            hessians[i][0][0] = -PI * PI * std::sin(PI * x) * std::sin(PI * y); 
            hessians[i][0][1] = PI * PI * std::cos(PI * x) * std::cos(PI * y); 
            hessians[i][1][1] = -PI * PI * std::sin(PI * x) * std::sin(PI * y); 
          } 
      } 
    }; 

    template <int dim> 
    class RightHandSide : public Function<dim> 
    { 
    public: 
      static_assert(dim == 2, "Only dim==2 is implemented"); 

      virtual double value(const Point<dim> &p, 
                           const unsigned int /*component*/ = 0) const override 

      { 
        return 4 * std::pow(PI, 4.0) * std::sin(PI * p[0]) * 
               std::sin(PI * p[1]); 
      } 
    }; 
  } // namespace ExactSolution 

//  @sect3{The main class}  

// 以下是本教程程序的主类。它具有许多其他教程程序的结构，其内容和后面的构造函数应该没有什么特别令人惊讶的地方。

  template <int dim> 
  class BiharmonicProblem 
  { 
  public: 
    BiharmonicProblem(const unsigned int fe_degree); 

    void run(); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void compute_errors(); 
    void output_results(const unsigned int iteration) const; 

    Triangulation<dim> triangulation; 

    MappingQ<dim> mapping; 

    FE_Q<dim>                 fe; 
    DoFHandler<dim>           dof_handler; 
    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 
  }; 

  template <int dim> 
  BiharmonicProblem<dim>::BiharmonicProblem(const unsigned int fe_degree) 
    : mapping(1) 
    , fe(fe_degree) 
    , dof_handler(triangulation) 
  {} 

// 接下来是创建初始网格（一次精炼的单元格）和设置每个网格的约束、向量和矩阵的函数。同样，这两个函数与之前的许多教程程序基本没有变化。

  template <int dim> 
  void BiharmonicProblem<dim>::make_grid() 
  { 
    GridGenerator::hyper_cube(triangulation, 0., 1.); 
    triangulation.refine_global(1); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "Total number of cells: " << triangulation.n_cells() 
              << std::endl; 
  } 

  template <int dim> 
  void BiharmonicProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 

    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             ExactSolution::Solution<dim>(), 
                                             constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp, constraints, true); 
    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 

//  @sect4{Assembling the linear system}  

// 下面的几段代码更有意思。它们都与线性系统的组装有关。虽然组装单元格内部项的难度不大--这在本质上就像组装拉普拉斯方程的相应项一样，你已经在 step-4 或 step-6 中看到了这是如何工作的，例如，困难在于公式中的惩罚项。这需要在单元格的界面上对形状函数的梯度进行评估。因此，至少需要使用两个FEFaceValues对象，但如果其中一个面是自适应细化的，那么实际上需要一个FEFaceValues和一个FESubfaceValues对象；我们还需要跟踪哪些形状函数在哪里，最后我们需要确保每个面只被访问一次。所有这些对于我们真正想要实现的逻辑（即双线性形式中的惩罚项）来说都是一笔不小的开销。因此，我们将使用FEInterfaceValues类--这是deal.II中的一个辅助类，它允许我们抽象出两个FEFaceValues或FESubfaceValues对象，直接访问我们真正关心的东西：跳跃、平均等。

// 但这还没有解决我们的问题，即当我们在所有单元格和它们的所有面中循环时，必须跟踪我们已经访问过哪些面。为了使这个过程更简单，我们使用了 MeshWorker::mesh_loop() 函数，它为这个任务提供了一个简单的接口：基于WorkStream命名空间文档中概述的想法， MeshWorker::mesh_loop() 需要三个函数对单元、内部面和边界面进行工作。这些函数在抓取对象上工作，以获得中间结果，然后将其计算结果复制到复制数据对象中，由一个复制器函数将其复制到全局矩阵和右侧对象中。

// 然后，下面的结构提供了这种方法所需的从头开始和复制对象。你可以查阅WorkStream命名空间以及 @ref threads "多处理器并行计算 "模块，了解更多关于它们通常如何工作的信息。

  template <int dim> 
  struct ScratchData 
  { 
    ScratchData(const Mapping<dim> &      mapping, 
                const FiniteElement<dim> &fe, 
                const unsigned int        quadrature_degree, 
                const UpdateFlags         update_flags, 
                const UpdateFlags         interface_update_flags) 
      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags) 
      , fe_interface_values(mapping, 
                            fe, 
                            QGauss<dim - 1>(quadrature_degree), 
                            interface_update_flags) 
    {} 

    ScratchData(const ScratchData<dim> &scratch_data) 
      : fe_values(scratch_data.fe_values.get_mapping(), 
                  scratch_data.fe_values.get_fe(), 
                  scratch_data.fe_values.get_quadrature(), 
                  scratch_data.fe_values.get_update_flags()) 
      , fe_interface_values(scratch_data.fe_values.get_mapping(), 
                            scratch_data.fe_values.get_fe(), 
                            scratch_data.fe_interface_values.get_quadrature(), 
                            scratch_data.fe_interface_values.get_update_flags()) 
    {} 

    FEValues<dim>          fe_values; 
    FEInterfaceValues<dim> fe_interface_values; 
  }; 

  struct CopyData 
  { 
    CopyData(const unsigned int dofs_per_cell) 
      : cell_matrix(dofs_per_cell, dofs_per_cell) 
      , cell_rhs(dofs_per_cell) 
      , local_dof_indices(dofs_per_cell) 
    {} 

    CopyData(const CopyData &) = default; 

    CopyData(CopyData &&) = default; 

    ~CopyData() = default; 

    CopyData &operator=(const CopyData &) = default; 

    CopyData &operator=(CopyData &&) = default; 

    struct FaceData 
    { 
      FullMatrix<double>                   cell_matrix; 
      std::vector<types::global_dof_index> joint_dof_indices; 
    }; 

    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_rhs; 
    std::vector<types::global_dof_index> local_dof_indices; 
    std::vector<FaceData>                face_data; 
  }; 

// 更有趣的部分是我们实际组装线性系统的地方。从根本上说，这个函数有五个部分。

// - `cell_worker`λ函数的定义，这是一个定义在`assemble_system()`函数中的小函数，它将负责计算单个单元上的局部积分。它将在`ScratchData`类的副本上工作，并将其结果放入相应的`CopyData`对象。

// - `face_worker` lambda函数的定义，它将对单元格之间的界面上的所有项进行积分。

// - 定义了`boundary_worker`函数，对位于域的边界上的单元面做同样的工作。

// - `copier`函数的定义，该函数负责将前面三个函数中的所有数据复制到单个单元的复制对象中，并复制到全局矩阵和右侧。

// 第五部分是我们把所有这些都集中在一起。

// 让我们轮流浏览一下这些组装所需的每一块。

  template <int dim> 
  void BiharmonicProblem<dim>::assemble_system() 
  { 
    using Iterator = typename DoFHandler<dim>::active_cell_iterator; 

// 第一部分是`cell_worker'，它在细胞内部进行组装。它是一个（lambda）函数，以一个单元格（输入）、一个抓取对象和一个复制对象（输出）为参数。它看起来像许多其他教程程序的装配函数，或者至少是所有单元格的循环主体。

// 我们在这里整合的条款是单元格对全局矩阵的贡献
// @f{align*}{
//     A^K_{ij} = \int_K \nabla^2\varphi_i(x) : \nabla^2\varphi_j(x) dx
//  @f} ，
//  以及对右侧向量的贡献
//  @f{align*}{
//     f^K_i = \int_K \varphi_i(x) f(x) dx
//  @f}

// 我们使用与组装 step-22 相同的技术来加速该函数。我们不在最里面的循环中调用`fe_values.shape_hessian(i, qpoint)`，而是创建一个变量`hessian_i`，在循环中对`i`进行一次评估，在循环中对`j`重新使用如此评估的值。为了对称，我们对变量`hessian_j`也做了同样的处理，尽管它确实只用了一次，而且我们可以在计算两个项之间标量乘积的指令中留下对`fe_values.shape_hessian(j,qpoint)`的调用。

    auto cell_worker = [&](const Iterator &  cell, 
                           ScratchData<dim> &scratch_data, 
                           CopyData &        copy_data) { 
      copy_data.cell_matrix = 0; 
      copy_data.cell_rhs    = 0; 

      FEValues<dim> &fe_values = scratch_data.fe_values; 
      fe_values.reinit(cell); 

      cell->get_dof_indices(copy_data.local_dof_indices); 

      const ExactSolution::RightHandSide<dim> right_hand_side; 

      const unsigned int dofs_per_cell = 
        scratch_data.fe_values.get_fe().n_dofs_per_cell(); 

      for (unsigned int qpoint = 0; qpoint < fe_values.n_quadrature_points; 
           ++qpoint) 
        { 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              const Tensor<2, dim> &hessian_i = 
                fe_values.shape_hessian(i, qpoint); 

              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const Tensor<2, dim> &hessian_j = 
                    fe_values.shape_hessian(j, qpoint); 

                  copy_data.cell_matrix(i, j) += 
                    scalar_product(hessian_i,   // nabla^2 phi_i(x) 
                                   hessian_j) * // nabla^2 phi_j(x) 
                    fe_values.JxW(qpoint);      // dx 
                } 

              copy_data.cell_rhs(i) += 
                fe_values.shape_value(i, qpoint) * // phi_i(x) 
                right_hand_side.value( 
                  fe_values.quadrature_point(qpoint)) * // f(x) 
                fe_values.JxW(qpoint);                  // dx 
            } 
        } 
    }; 

// 下一个构建模块是在网格的每个内部面组装惩罚项。正如 MeshWorker::mesh_loop(), 文档中所描述的，这个函数接收到的参数表示一个单元和它的相邻单元，以及（对于这两个单元中的每一个）我们必须整合的面（以及潜在的子面）。同样地，我们也得到了一个从头开始的对象，以及一个用于放置结果的拷贝对象。

// 这个函数本身有三个部分。在顶部，我们初始化FEInterfaceValues对象，并创建一个新的 `CopyData::FaceData` 对象来存储我们的输入。这将被推到`copy_data.face_data`变量的末尾。我们需要这样做，因为我们对一个给定单元进行积分的面（或子面）的数量因单元而异，而且这些矩阵的大小也不同，取决于面或子面相邻的自由度。正如 MeshWorker::mesh_loop(), 文档中所讨论的，每次访问一个新的单元时，复制对象都会被重置，所以我们推到`copy_data.face_data()`末尾的内容实际上就是后来的`copier`函数在复制每个单元的贡献到全局矩阵和右侧对象时所能看到的。

    auto face_worker = [&](const Iterator &    cell, 
                           const unsigned int &f, 
                           const unsigned int &sf, 
                           const Iterator &    ncell, 
                           const unsigned int &nf, 
                           const unsigned int &nsf, 
                           ScratchData<dim> &  scratch_data, 
                           CopyData &          copy_data) { 
      FEInterfaceValues<dim> &fe_interface_values = 
        scratch_data.fe_interface_values; 
      fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf); 

      copy_data.face_data.emplace_back(); 
      CopyData::FaceData &copy_data_face = copy_data.face_data.back(); 

      copy_data_face.joint_dof_indices = 
        fe_interface_values.get_interface_dof_indices(); 

      const unsigned int n_interface_dofs = 
        fe_interface_values.n_current_interface_dofs(); 
      copy_data_face.cell_matrix.reinit(n_interface_dofs, n_interface_dofs); 

// 第二部分涉及到确定惩罚参数应该是什么。通过观察双线性形式中各种项的单位，很明显，惩罚必须具有 $\frac{\gamma}{h_K}$ 的形式（即，超过长度尺度的一个），但如何选择无维数 $\gamma$ 并不是先验的。从拉普拉斯方程的不连续Galerkin理论来看，人们可能猜想正确的选择是 $\gamma=p(p+1)$ 是正确的选择，其中 $p$ 是所用有限元的多项式程度。我们将在本程序的结果部分更详细地讨论这个选择。

// 在上面的公式中， $h_K$  是单元格  $K$  的大小。但这也不是很简单的事情。如果使用高度拉伸的单元格，那么一个更复杂的理论说， $h$ 应该被单元格 $K$ 的直径取代，该直径是有关边缘方向的法线。 事实证明，在deal.II中有一个函数用于此。其次，当从一个面的两个不同侧面看时， $h_K$ 可能是不同的。

// 为了安全起见，我们取这两个值的最大值。我们将注意到，如果使用自适应网格细化所产生的悬空节点，有可能需要进一步调整这一计算方法。

      const unsigned int p = fe.degree; 
      const double       gamma_over_h = 
        std::max((1.0 * p * (p + 1) / 
                  cell->extent_in_direction( 
                    GeometryInfo<dim>::unit_normal_direction[f])), 
                 (1.0 * p * (p + 1) / 
                  ncell->extent_in_direction( 
                    GeometryInfo<dim>::unit_normal_direction[nf]))); 

// 最后，像往常一样，我们在正交点和指数`i`和`j`上循环，把这个面或子面的贡献加起来。然后将这些数据存储在上面创建的`copy_data.face_data`对象中。至于单元格工作者，如果可能的话，我们将平均数和跳跃的评估从循环中拉出来，引入局部变量来存储这些结果。然后组件只需要在最里面的循环中使用这些局部变量。关于这段代码实现的具体公式，回顾一下，双线性形式的接口项如下。
// @f{align*}{
//   -\sum_{e \in \mathbb{F}} \int_{e}
//   \jump{ \frac{\partial v_h}{\partial \mathbf n}}
//   \average{\frac{\partial^2 u_h}{\partial \mathbf n^2}} \ ds
//  -\sum_{e \in \mathbb{F}} \int_{e}
//  \average{\frac{\partial^2 v_h}{\partial \mathbf n^2}}
//  \jump{\frac{\partial u_h}{\partial \mathbf n}} \ ds
//  + \sum_{e \in \mathbb{F}}
//  \frac{\gamma}{h_e}
//  \int_e
//  \jump{\frac{\partial v_h}{\partial \mathbf n}}
//  \jump{\frac{\partial u_h}{\partial \mathbf n}} \ ds.
//  @f}

      for (unsigned int qpoint = 0; 
           qpoint < fe_interface_values.n_quadrature_points; 
           ++qpoint) 
        { 
          const auto &n = fe_interface_values.normal(qpoint); 

          for (unsigned int i = 0; i < n_interface_dofs; ++i) 
            { 
              const double av_hessian_i_dot_n_dot_n = 
                (fe_interface_values.average_hessian(i, qpoint) * n * n); 
              const double jump_grad_i_dot_n = 
                (fe_interface_values.jump_gradient(i, qpoint) * n); 

              for (unsigned int j = 0; j < n_interface_dofs; ++j) 
                { 
                  const double av_hessian_j_dot_n_dot_n = 
                    (fe_interface_values.average_hessian(j, qpoint) * n * n); 
                  const double jump_grad_j_dot_n = 
                    (fe_interface_values.jump_gradient(j, qpoint) * n); 

                  copy_data_face.cell_matrix(i, j) += 
                    (-av_hessian_i_dot_n_dot_n       // - {grad^2 v n n } 
                       * jump_grad_j_dot_n           // [grad u n] 
                     - av_hessian_j_dot_n_dot_n      // - {grad^2 u n n } 
                         * jump_grad_i_dot_n         // [grad v n] 
                     +                               // + 
                     gamma_over_h *                  // gamma/h 
                       jump_grad_i_dot_n *           // [grad v n] 
                       jump_grad_j_dot_n) *          // [grad u n] 
                    fe_interface_values.JxW(qpoint); // dx 
                } 
            } 
        } 
    }; 

// 第三块是对处于边界的面做同样的装配。当然，想法和上面一样，唯一不同的是，现在有惩罚条款也进入了右手边。

// 和以前一样，这个函数的第一部分只是设置了一些辅助对象。

    auto boundary_worker = [&](const Iterator &    cell, 
                               const unsigned int &face_no, 
                               ScratchData<dim> &  scratch_data, 
                               CopyData &          copy_data) { 
      FEInterfaceValues<dim> &fe_interface_values = 
        scratch_data.fe_interface_values; 
      fe_interface_values.reinit(cell, face_no); 
      const auto &q_points = fe_interface_values.get_quadrature_points(); 

      copy_data.face_data.emplace_back(); 
      CopyData::FaceData &copy_data_face = copy_data.face_data.back(); 

      const unsigned int n_dofs = 
        fe_interface_values.n_current_interface_dofs(); 
      copy_data_face.joint_dof_indices = 
        fe_interface_values.get_interface_dof_indices(); 

      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs); 

      const std::vector<double> &JxW = fe_interface_values.get_JxW_values(); 
      const std::vector<Tensor<1, dim>> &normals = 
        fe_interface_values.get_normal_vectors(); 

      const ExactSolution::Solution<dim> exact_solution; 
      std::vector<Tensor<1, dim>>        exact_gradients(q_points.size()); 
      exact_solution.gradient_list(q_points, exact_gradients); 

// 从正面看，由于我们现在只处理与面相邻的一个单元（因为我们在边界上），惩罚因子 $\gamma$ 的计算大大简化了。

      const unsigned int p = fe.degree; 
      const double       gamma_over_h = 
        (1.0 * p * (p + 1) / 
         cell->extent_in_direction( 
           GeometryInfo<dim>::unit_normal_direction[face_no])); 

// 第三块是术语的组合。由于这些条款包含了矩阵的条款和右手边的条款，所以现在稍微有些麻烦。前者与上面所说的内部面完全相同，如果我们只是适当地定义了跳跃和平均（这就是FEInterfaceValues类所做的）。后者需要我们评估边界条件 $j(\mathbf x)$ ，在当前情况下（我们知道确切的解决方案），我们从 $j(\mathbf x) = \frac{\partial u(\mathbf x)}{\partial {\mathbf n}}$ 中计算出来。然后，要添加到右侧向量的项是  $\frac{\gamma}{h_e}\int_e \jump{\frac{\partial v_h}{\partial \mathbf n}} j \ ds$  。

      for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint) 
        { 
          const auto &n = normals[qpoint]; 

          for (unsigned int i = 0; i < n_dofs; ++i) 
            { 
              const double av_hessian_i_dot_n_dot_n = 
                (fe_interface_values.average_hessian(i, qpoint) * n * n); 
              const double jump_grad_i_dot_n = 
                (fe_interface_values.jump_gradient(i, qpoint) * n); 

              for (unsigned int j = 0; j < n_dofs; ++j) 
                { 
                  const double av_hessian_j_dot_n_dot_n = 
                    (fe_interface_values.average_hessian(j, qpoint) * n * n); 
                  const double jump_grad_j_dot_n = 
                    (fe_interface_values.jump_gradient(j, qpoint) * n); 

                  copy_data_face.cell_matrix(i, j) += 
                    (-av_hessian_i_dot_n_dot_n  // - {grad^2 v n n} 
                       * jump_grad_j_dot_n      //   [grad u n] 

//                                      

                     - av_hessian_j_dot_n_dot_n // - {grad^2 u n n} 
                         * jump_grad_i_dot_n    //   [grad v n] 

//                                      

                     + gamma_over_h             //  gamma/h 
                         * jump_grad_i_dot_n    // [grad v n] 
                         * jump_grad_j_dot_n    // [grad u n] 
                     ) * 
                    JxW[qpoint]; // dx 
                } 

              copy_data.cell_rhs(i) += 
                (-av_hessian_i_dot_n_dot_n *       // - {grad^2 v n n } 
                   (exact_gradients[qpoint] * n)   //   (grad u_exact . n) 
                 +                                 // + 
                 gamma_over_h                      //  gamma/h 
                   * jump_grad_i_dot_n             // [grad v n] 
                   * (exact_gradients[qpoint] * n) // (grad u_exact . n) 
                 ) * 
                JxW[qpoint]; // dx 
            } 
        } 
    }; 

// 第四部分是一个小函数，它将上面的单元格、内部和边界面装配程序产生的数据复制到全局矩阵和右手向量中。这里真的没有什么可做的。我们分配单元格矩阵和右侧贡献，就像我们在其他几乎所有的教程程序中使用约束对象那样。然后，我们还必须对面矩阵的贡献做同样的处理，这些贡献已经获得了面（内部和边界）的内容，并且`面_工作`和`边界_工作`已经添加到`copy_data.face_data`阵列中。

    auto copier = [&](const CopyData &copy_data) { 
      constraints.distribute_local_to_global(copy_data.cell_matrix, 
                                             copy_data.cell_rhs, 
                                             copy_data.local_dof_indices, 
                                             system_matrix, 
                                             system_rhs); 

      for (auto &cdf : copy_data.face_data) 
        { 
          constraints.distribute_local_to_global(cdf.cell_matrix, 
                                                 cdf.joint_dof_indices, 
                                                 system_matrix); 
        } 
    }; 

// 在设置了所有这些之后，剩下的就是创建一个从头开始和复制数据的对象，并调用 MeshWorker::mesh_loop() 函数，然后遍历所有的单元格和面，调用它们各自的工作器，然后是复制器函数，将东西放入全局矩阵和右侧。作为一个额外的好处， MeshWorker::mesh_loop() 以并行方式完成所有这些工作，使用你的机器恰好有多少个处理器核心。

    const unsigned int n_gauss_points = dof_handler.get_fe().degree + 1; 
    ScratchData<dim>   scratch_data(mapping, 
                                  fe, 
                                  n_gauss_points, 
                                  update_values | update_gradients | 
                                    update_hessians | update_quadrature_points | 
                                    update_JxW_values, 
                                  update_values | update_gradients | 
                                    update_hessians | update_quadrature_points | 
                                    update_JxW_values | update_normal_vectors); 
    CopyData           copy_data(dof_handler.get_fe().n_dofs_per_cell()); 
    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          copy_data, 
                          MeshWorker::assemble_own_cells | 
                            MeshWorker::assemble_boundary_faces | 
                            MeshWorker::assemble_own_interior_faces_once, 
                          boundary_worker, 
                          face_worker); 
  } 

//  @sect4{Solving the linear system and postprocessing}  

// 到此为止，节目基本上结束了。其余的函数并不太有趣或新颖。第一个函数只是用一个直接求解器来求解线性系统（也见 step-29  ）。

  template <int dim> 
  void BiharmonicProblem<dim>::solve() 
  { 
    std::cout << "   Solving system..." << std::endl; 

    SparseDirectUMFPACK A_direct; 
    A_direct.initialize(system_matrix); 
    A_direct.vmult(solution, system_rhs); 

    constraints.distribute(solution); 
  } 

// 下一个函数评估了计算出的解和精确解之间的误差（在这里是已知的，因为我们选择了右手边和边界值的方式，所以我们知道相应的解）。在下面的前两个代码块中，我们计算了 $L_2$ 准则和 $H^1$ 半准则下的误差。

  template <int dim> 
  void BiharmonicProblem<dim>::compute_errors() 
  { 
    { 
      Vector<float> norm_per_cell(triangulation.n_active_cells()); 
      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        ExactSolution::Solution<dim>(), 
                                        norm_per_cell, 
                                        QGauss<dim>(fe.degree + 2), 
                                        VectorTools::L2_norm); 
      const double error_norm = 
        VectorTools::compute_global_error(triangulation, 
                                          norm_per_cell, 
                                          VectorTools::L2_norm); 
      std::cout << "   Error in the L2 norm           :     " << error_norm 
                << std::endl; 
    } 

    { 
      Vector<float> norm_per_cell(triangulation.n_active_cells()); 
      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        ExactSolution::Solution<dim>(), 
                                        norm_per_cell, 
                                        QGauss<dim>(fe.degree + 2), 
                                        VectorTools::H1_seminorm); 
      const double error_norm = 
        VectorTools::compute_global_error(triangulation, 
                                          norm_per_cell, 
                                          VectorTools::H1_seminorm); 
      std::cout << "   Error in the H1 seminorm       : " << error_norm 
                << std::endl; 
    } 

// 现在也计算一下 $H^2$ 半正态误差的近似值。实际的 $H^2$ 半规范要求我们对解决方案 $u_h$ 的二阶导数进行积分，但是考虑到我们使用的拉格朗日形状函数， $u_h$ 当然在单元间的界面上有结点，因此二阶导数在界面是奇异的。因此，我们实际上只对单元的内部进行积分，而忽略了界面的贡献。这不是*等同于问题的能量准则，但是仍然可以让我们了解误差收敛的速度。

// 我们注意到，我们可以通过定义一个等同于能量准则的准则来解决这个问题。这将涉及到不仅要像我们下面做的那样将细胞内部的积分相加，而且还要为 $u_h$ 的导数在界面上的跳跃添加惩罚项，并对这两种项进行适当的缩放。我们将把这个问题留给以后的工作。

    { 
      const QGauss<dim>            quadrature_formula(fe.degree + 2); 
      ExactSolution::Solution<dim> exact_solution; 
      Vector<double> error_per_cell(triangulation.n_active_cells()); 

      FEValues<dim> fe_values(mapping, 
                              fe, 
                              quadrature_formula, 
                              update_values | update_hessians | 
                                update_quadrature_points | update_JxW_values); 

      FEValuesExtractors::Scalar scalar(0); 
      const unsigned int         n_q_points = quadrature_formula.size(); 

      std::vector<SymmetricTensor<2, dim>> exact_hessians(n_q_points); 
      std::vector<Tensor<2, dim>>          hessians(n_q_points); 
      for (auto &cell : dof_handler.active_cell_iterators()) 
        { 
          fe_values.reinit(cell); 
          fe_values[scalar].get_function_hessians(solution, hessians); 
          exact_solution.hessian_list(fe_values.get_quadrature_points(), 
                                      exact_hessians); 

          double local_error = 0; 
          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            { 
              local_error += 
                ((exact_hessians[q_point] - hessians[q_point]).norm_square() * 
                 fe_values.JxW(q_point)); 
            } 
          error_per_cell[cell->active_cell_index()] = std::sqrt(local_error); 
        } 

      const double error_norm = error_per_cell.l2_norm(); 
      std::cout << "   Error in the broken H2 seminorm: " << error_norm 
                << std::endl; 
    } 
  } 

// 同样无趣的是生成图形输出的函数。它看起来和  step-6  中的一模一样，比如说。

  template <int dim> 
  void 
  BiharmonicProblem<dim>::output_results(const unsigned int iteration) const 
  { 
    std::cout << "   Writing graphical output..." << std::endl; 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(); 

    const std::string filename = 
      ("output_" + Utilities::int_to_string(iteration, 6) + ".vtu"); 
    std::ofstream output_vtu(filename); 
    data_out.write_vtu(output_vtu); 
  } 

// `run()`函数的情况也是如此。就像在以前的程序中一样。

  template <int dim> 
  void BiharmonicProblem<dim>::run() 
  { 
    make_grid(); 

    const unsigned int n_cycles = 4; 
    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << " of " << n_cycles << std::endl; 

        triangulation.refine_global(1); 
        setup_system(); 

        assemble_system(); 
        solve(); 

        output_results(cycle); 

        compute_errors(); 
        std::cout << std::endl; 
      } 
  } 
} // namespace Step47 

//  @sect3{The main() function}  

// 最后是 "main() "函数。同样，这里没有什么可看的。它看起来和以前的教程程序中的一样。有一个变量，可以选择我们要用来解方程的元素的多项式程度。因为我们使用的C0IP公式要求元素的度数至少为2，所以我们用一个断言来检查，无论为多项式度数设置什么都是有意义的。

int main() 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step47; 

      const unsigned int fe_degree = 2; 
      Assert(fe_degree >= 2, 
             ExcMessage("The C0IP formulation for the biharmonic problem " 
                        "only works if one uses elements of polynomial " 
                        "degree at least 2.")); 

      BiharmonicProblem<2> biharmonic_problem(fe_degree); 
      biharmonic_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-48.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2011 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Katharina Kormann, Martin Kronbichler, Uppsala University, 2011-2012 
 */ 



// deal.II库中的必要文件。

#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/distributed/tria.h> 

// 这包括用于有效实现无矩阵方法的数据结构。

#include <deal.II/lac/la_parallel_vector.h> 
#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/fe_evaluation.h> 

#include <fstream> 
#include <iostream> 
#include <iomanip> 

namespace Step48 
{ 
  using namespace dealii; 

// 我们首先定义了两个全局变量，以便在一个地方收集所有需要改变的参数。一个是尺寸，一个是有限元度。维度在主函数中是作为实际类的模板参数使用的（就像所有其他deal.II程序一样），而有限元的度数则更为关键，因为它是作为模板参数传递给Sine-Gordon算子的实现。因此，它需要成为一个编译时常数。

  const unsigned int dimension = 2; 
  const unsigned int fe_degree = 4; 
// @sect3{SineGordonOperation}  

//  <code>SineGordonOperation</code> 类实现了每个时间步骤中需要的基于单元的操作。这个非线性操作可以在 <code>MatrixFree</code> 类的基础上直接实现，与线性操作在这个实现的有限元算子应用中的处理方式相同。我们对该类应用了两个模板参数，一个是尺寸，一个是有限元的程度。这与deal.II中的其他函数不同，其中只有维度是模板参数。这对于为 @p FEEvaluation 中的内循环提供关于循环长度等的信息是必要的，这对于效率是至关重要的。另一方面，这使得将度数作为一个运行时参数来实现更具挑战性。

  template <int dim, int fe_degree> 
  class SineGordonOperation 
  { 
  public: 
    SineGordonOperation(const MatrixFree<dim, double> &data_in, 
                        const double                   time_step); 

    void apply(LinearAlgebra::distributed::Vector<double> &dst, 
               const std::vector<LinearAlgebra::distributed::Vector<double> *> 
                 &src) const; 

  private: 
    const MatrixFree<dim, double> &            data; 
    const VectorizedArray<double>              delta_t_sqr; 
    LinearAlgebra::distributed::Vector<double> inv_mass_matrix; 

    void local_apply( 
      const MatrixFree<dim, double> &                                  data, 
      LinearAlgebra::distributed::Vector<double> &                     dst, 
      const std::vector<LinearAlgebra::distributed::Vector<double> *> &src, 
      const std::pair<unsigned int, unsigned int> &cell_range) const; 
  }; 

//  @sect4{SineGordonOperation::SineGordonOperation}  

// 这是SineGordonOperation类的构造函数。它接收一个对MatrixFree的引用，该引用持有问题信息和时间步长作为输入参数。初始化程序设置了质量矩阵。由于我们使用Gauss-Lobatto元素，质量矩阵是一个对角矩阵，可以存储为一个矢量。利用FEEvaluation提供的数据结构，质量矩阵对角线的计算很容易实现。只要在所有的单元格批次上循环，即由于SIMD矢量化的单元格集合，并通过使用 <code>integrate</code> 函数与 @p true 参数在数值的槽上对所有正交点上常一的函数进行积分。最后，我们将对角线条目进行反转，以便在每个时间步长中直接获得反质量矩阵。

  template <int dim, int fe_degree> 
  SineGordonOperation<dim, fe_degree>::SineGordonOperation( 
    const MatrixFree<dim, double> &data_in, 
    const double                   time_step) 
    : data(data_in) 
    , delta_t_sqr(make_vectorized_array(time_step * time_step)) 
  { 
    data.initialize_dof_vector(inv_mass_matrix); 

    FEEvaluation<dim, fe_degree> fe_eval(data); 
    const unsigned int           n_q_points = fe_eval.n_q_points; 

    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        fe_eval.reinit(cell); 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          fe_eval.submit_value(make_vectorized_array(1.), q); 
        fe_eval.integrate(EvaluationFlags::values); 
        fe_eval.distribute_local_to_global(inv_mass_matrix); 
      } 

    inv_mass_matrix.compress(VectorOperation::add); 
    for (unsigned int k = 0; k < inv_mass_matrix.locally_owned_size(); ++k) 
      if (inv_mass_matrix.local_element(k) > 1e-15) 
        inv_mass_matrix.local_element(k) = 
          1. / inv_mass_matrix.local_element(k); 
      else 
        inv_mass_matrix.local_element(k) = 1; 
  } 

//  @sect4{SineGordonOperation::local_apply}  

// 这个算子实现了程序的核心操作，即对正弦-戈登问题的非线性算子进行单元范围的积分。其实现是基于  step-37  中的FEEvaluation类。由于Gauss-Lobatto元素的特殊结构，某些操作变得更加简单，特别是正交点上的形状函数值的评估，这只是单元自由度值的注入。MatrixFree类在初始化时检测了正交点上有限元的可能结构，然后由FEEvaluation自动用于选择最合适的数值核。

// 我们要为时间步进例程评估的非线性函数包括当前时间的函数值 @p current 以及前一个时间步进的值 @p old. 这两个值都在源向量集合 @p src, 中传递给运算器，该集合只是一个指向实际解向量的 <tt>std::vector</tt> 指针。这种将多个源向量收集到一起的结构是必要的，因为 @p MatrixFree 中的单元格循环正好需要一个源向量和一个目的向量，即使我们碰巧使用了很多向量，比如本例中的两个。请注意，单元格循环接受任何有效的输入和输出类，这不仅包括向量，还包括一般的数据类型。 然而，只有在遇到收集这些向量的 LinearAlgebra::distributed::Vector<Number> 或 <tt>std::vector</tt> 时，它才会在循环的开始和结束时调用由于MPI而交换幽灵数据的函数。在单元格的循环中，我们首先要读入与本地值相关的向量中的值。 然后，我们评估当前求解向量的值和梯度以及正交点的旧向量的值。接下来，我们在正交点的循环中结合方案中的条款。最后，我们将结果与测试函数进行积分，并将结果累积到全局解向量 @p  dst。

  template <int dim, int fe_degree> 
  void SineGordonOperation<dim, fe_degree>::local_apply( 
    const MatrixFree<dim> &                                          data, 
    LinearAlgebra::distributed::Vector<double> &                     dst, 
    const std::vector<LinearAlgebra::distributed::Vector<double> *> &src, 
    const std::pair<unsigned int, unsigned int> &cell_range) const 
  { 
    AssertDimension(src.size(), 2); 
    FEEvaluation<dim, fe_degree> current(data), old(data); 
    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        current.reinit(cell); 
        old.reinit(cell); 

        current.read_dof_values(*src[0]); 
        old.read_dof_values(*src[1]); 

        current.evaluate(EvaluationFlags::values | EvaluationFlags::gradients); 
        old.evaluate(EvaluationFlags::values); 

        for (unsigned int q = 0; q < current.n_q_points; ++q) 
          { 
            const VectorizedArray<double> current_value = current.get_value(q); 
            const VectorizedArray<double> old_value     = old.get_value(q); 

            current.submit_value(2. * current_value - old_value - 
                                   delta_t_sqr * std::sin(current_value), 
                                 q); 
            current.submit_gradient(-delta_t_sqr * current.get_gradient(q), q); 
          } 

        current.integrate(EvaluationFlags::values | EvaluationFlags::gradients); 
        current.distribute_local_to_global(dst); 
      } 
  } 

//  @sect4{SineGordonOperation::apply}  

// 该函数根据单元本地策略执行时间步进例程。请注意，在添加当前时间步长的积分贡献之前，我们需要将目标向量设置为零（通过 FEEvaluation::distribute_local_to_global() 调用）。在本教程中，我们通过传递给 MatrixFree::cell_loop. 的第五个`true`参数让单元格循环进行归零操作。 循环可以将归零操作安排在更接近对支持的向量项的操作，从而可能提高数据的定位性（首先被归零的向量项后来在`distribute_local_to_global()`调用中重新使用）。单元循环的结构是在单元有限元运算器类中实现的。在每个单元上，它应用定义为类 <code>local_apply()</code> 方法的例程  <code>SineGordonOperation</code>, i.e., <code>this</code>  。我们也可以提供一个具有相同签名的、不属于类的函数。最后，积分的结果要乘以质量矩阵的逆值。

  template <int dim, int fe_degree> 
  void SineGordonOperation<dim, fe_degree>::apply( 
    LinearAlgebra::distributed::Vector<double> &                     dst, 
    const std::vector<LinearAlgebra::distributed::Vector<double> *> &src) const 
  { 
    data.cell_loop( 
      &SineGordonOperation<dim, fe_degree>::local_apply, this, dst, src, true); 
    dst.scale(inv_mass_matrix); 
  } 

//  @sect3{Equation data}  

// 我们定义了一个随时间变化的函数，作为初始值使用。通过改变起始时间，可以得到不同的解决方案。这个函数取自 step-25 ，将代表一维中所有时间的分析解，但在这里只是用来设置一些感兴趣的起始解。在  step-25  中给出了可以测试该程序收敛性的更详细的选择。

  template <int dim> 
  class InitialCondition : public Function<dim> 
  { 
  public: 
    InitialCondition(const unsigned int n_components = 1, 
                     const double       time         = 0.) 
      : Function<dim>(n_components, time) 
    {} 
    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/) const override 
    { 
      double t = this->get_time(); 

      const double m  = 0.5; 
      const double c1 = 0.; 
      const double c2 = 0.; 
      const double factor = 
        (m / std::sqrt(1. - m * m) * std::sin(std::sqrt(1. - m * m) * t + c2)); 
      double result = 1.; 
      for (unsigned int d = 0; d < dim; ++d) 
        result *= -4. * std::atan(factor / std::cosh(m * p[d] + c1)); 
      return result; 
    } 
  }; 

//  @sect3{SineGordonProblem class}  

// 这是在  step-25  中的类基础上的主类。 然而，我们用MatrixFree类代替了SparseMatrix<double>类来存储几何数据。另外，我们在这个例子中使用了一个分布式三角形。

  template <int dim> 
  class SineGordonProblem 
  { 
  public: 
    SineGordonProblem(); 
    void run(); 

  private: 
    ConditionalOStream pcout; 

    void make_grid_and_dofs(); 
    void output_results(const unsigned int timestep_number); 

#ifdef DEAL_II_WITH_P4EST 
    parallel::distributed::Triangulation<dim> triangulation; 
#else 
    Triangulation<dim> triangulation; 
#endif 
    FE_Q<dim>       fe; 
    DoFHandler<dim> dof_handler; 

    MappingQ1<dim> mapping; 

    AffineConstraints<double> constraints; 
    IndexSet                  locally_relevant_dofs; 

    MatrixFree<dim, double> matrix_free_data; 

    LinearAlgebra::distributed::Vector<double> solution, old_solution, 
      old_old_solution; 

    const unsigned int n_global_refinements; 
    double             time, time_step; 
    const double       final_time; 
    const double       cfl_number; 
    const unsigned int output_timestep_skip; 
  }; 
// @sect4{SineGordonProblem::SineGordonProblem}  

// 这是SineGordonProblem类的构造函数。时间间隔和时间步长在此定义。此外，我们使用在程序顶部定义的有限元的程度来初始化一个基于Gauss-Lobatto支持点的FE_Q有限元。这些点很方便，因为与同阶的QGauss-Lobatto正交规则相结合，它们可以得到一个对角线质量矩阵，而不会太影响精度（注意，虽然积分是不精确的），也可以参见介绍中的讨论。请注意，FE_Q默认选择Gauss-Lobatto结点，因为它们相对于等距结点有更好的条件。为了使事情更加明确，我们还是要说明节点的选择。

  template <int dim> 
  SineGordonProblem<dim>::SineGordonProblem() 
    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
    , 
#ifdef DEAL_II_WITH_P4EST 
    triangulation(MPI_COMM_WORLD) 
    , 
#endif 
    fe(QGaussLobatto<1>(fe_degree + 1)) 
    , dof_handler(triangulation) 
    , n_global_refinements(10 - 2 * dim) 
    , time(-10) 
    , time_step(10.) 
    , final_time(10.) 
    , cfl_number(.1 / fe_degree) 
    , output_timestep_skip(200) 
  {} 
// @sect4{SineGordonProblem::make_grid_and_dofs}  

// 和 step-25 一样，这个函数在 <code>dim</code> 维度上设置了一个范围为 $[-15,15]$ 的立方体网格。我们在域的中心更多的细化网格，因为解决方案都集中在那里。我们首先细化所有中心在半径为11的单元，然后再细化一次半径为6的单元。 这种简单的临时细化可以通过在时间步进过程中使用误差估计器来适应网格，并使用 parallel::distributed::SolutionTransfer 将解决方案转移到新的网格中来完成。

  template <int dim> 
  void SineGordonProblem<dim>::make_grid_and_dofs() 
  { 
    GridGenerator::hyper_cube(triangulation, -15, 15); 
    triangulation.refine_global(n_global_refinements); 
    { 
      typename Triangulation<dim>::active_cell_iterator 
        cell     = triangulation.begin_active(), 
        end_cell = triangulation.end(); 
      for (; cell != end_cell; ++cell) 
        if (cell->is_locally_owned()) 
          if (cell->center().norm() < 11) 
            cell->set_refine_flag(); 
      triangulation.execute_coarsening_and_refinement(); 

      cell     = triangulation.begin_active(); 
      end_cell = triangulation.end(); 
      for (; cell != end_cell; ++cell) 
        if (cell->is_locally_owned()) 
          if (cell->center().norm() < 6) 
            cell->set_refine_flag(); 
      triangulation.execute_coarsening_and_refinement(); 
    } 

    pcout << "   Number of global active cells: " 
#ifdef DEAL_II_WITH_P4EST 
          << triangulation.n_global_active_cells() 
#else 
          << triangulation.n_active_cells() 
#endif 
          << std::endl; 

    dof_handler.distribute_dofs(fe); 

    pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
          << std::endl; 

// 我们生成悬挂节点约束，以确保解决方案的连续性。如同在 step-40 中，我们需要为约束矩阵配备本地相关自由度的IndexSet，以避免它在大问题中消耗过多的内存。接下来，问题的<code>MatrixFree</code>对象被设置。请注意，我们为共享内存并行化指定了一个特定的方案（因此，人们会使用多线程来实现节点内的并行化，而不是MPI；我们在这里选择了标准选项&mdash；如果我们想在程序中有一个以上的TBB线程的情况下禁用共享内存并行化，我们会选择 MatrixFree::AdditionalData::TasksParallelScheme::none).  另外请注意，我们没有使用默认的QGauss正交参数，而是提供一个QGaussLobatto正交公式来实现期望的行为。最后，三个求解向量被初始化。MatrixFree期望有一个特定的鬼魂索引布局（因为它在MPI本地数字中处理索引访问，需要在向量和MatrixFree之间匹配），所以我们只是要求它初始化向量，以确保鬼魂交换得到正确处理。

    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 
    constraints.clear(); 
    constraints.reinit(locally_relevant_dofs); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    constraints.close(); 

    typename MatrixFree<dim>::AdditionalData additional_data; 
    additional_data.tasks_parallel_scheme = 
      MatrixFree<dim>::AdditionalData::TasksParallelScheme::partition_partition; 

    matrix_free_data.reinit(mapping, 
                            dof_handler, 
                            constraints, 
                            QGaussLobatto<1>(fe_degree + 1), 
                            additional_data); 

    matrix_free_data.initialize_dof_vector(solution); 
    old_solution.reinit(solution); 
    old_old_solution.reinit(solution); 
  } 

//  @sect4{SineGordonProblem::output_results}  

// 这个函数打印出解的规范，并将解的向量写到一个文件中。法线是标准的（除了我们需要累积所有处理器上的法线，用于并行网格，我们通过  VectorTools::compute_global_error()  函数来做），第二项类似于我们在  step-40  或  step-37  . 请注意，我们可以使用与计算过程中使用的相同的向量进行输出。无矩阵框架中的向量总是提供所有本地拥有的单元的全部信息（这也是本地评估中需要的），包括这些单元上的鬼向量条目。这是 VectorTools::integrate_difference() 函数以及DataOut中唯一需要的数据。这时唯一要做的就是确保在我们从矢量中读取数据之前更新其鬼魂值，并在完成后重置鬼魂值。这是一个只存在于 LinearAlgebra::distributed::Vector 类中的特性。另一方面，带有PETSc和Trilinos的分布式向量需要被复制到包括ghost值的特殊向量（见 step-40 中的相关章节 ）。如果我们还想访问幽灵单元上的所有自由度（例如，当计算使用单元边界上的解的跳跃的误差估计时），我们将需要更多的信息，并创建一个初始化了本地相关自由度的向量，就像在  step-40  中一样。还请注意，我们需要为输出分配约束条件

// --它们在计算过程中不被填充（相反，它们在无矩阵的方法中被实时插值  FEEvaluation::read_dof_values()).  
  template <int dim> 
  void 
  SineGordonProblem<dim>::output_results(const unsigned int timestep_number) 
  { 
    constraints.distribute(solution); 

    Vector<float> norm_per_cell(triangulation.n_active_cells()); 
    solution.update_ghost_values(); 
    VectorTools::integrate_difference(mapping, 
                                      dof_handler, 
                                      solution, 
                                      Functions::ZeroFunction<dim>(), 
                                      norm_per_cell, 
                                      QGauss<dim>(fe_degree + 1), 
                                      VectorTools::L2_norm); 
    const double solution_norm = 
      VectorTools::compute_global_error(triangulation, 
                                        norm_per_cell, 
                                        VectorTools::L2_norm); 

    pcout << "   Time:" << std::setw(8) << std::setprecision(3) << time 
          << ", solution norm: " << std::setprecision(5) << std::setw(7) 
          << solution_norm << std::endl; 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(mapping); 

    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", timestep_number, MPI_COMM_WORLD, 3); 

    solution.zero_out_ghost_values(); 
  } 
// @sect4{SineGordonProblem::run}  

// 这个函数被主函数调用，并步入类的子程序中。

// 在打印了一些关于并行设置的信息后，第一个动作是设置网格和单元运算器。然后，根据构造函数中给出的CFL编号和最细的网格尺寸计算出时间步长。最细的网格尺寸计算为三角形中最后一个单元的直径，也就是网格中最细层次上的最后一个单元。这只适用于一个层次上的所有元素都具有相同尺寸的网格，否则就需要对所有单元进行循环。请注意，我们需要查询所有处理器的最细单元，因为不是所有的处理器都可能持有网格处于最细级别的区域。然后，我们重新调整一下时间步长，以准确地达到最后的时间。

  template <int dim> 
  void SineGordonProblem<dim>::run() 
  { 
    { 
      pcout << "Number of MPI ranks:            " 
            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) << std::endl; 
      pcout << "Number of threads on each rank: " 
            << MultithreadInfo::n_threads() << std::endl; 
      const unsigned int n_vect_doubles = VectorizedArray<double>::size(); 
      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles; 
      pcout << "Vectorization over " << n_vect_doubles 
            << " doubles = " << n_vect_bits << " bits (" 
            << Utilities::System::get_current_vectorization_level() << ")" 
            << std::endl 
            << std::endl; 
    } 
    make_grid_and_dofs(); 

    const double local_min_cell_diameter = 
      triangulation.last()->diameter() / std::sqrt(dim); 
    const double global_min_cell_diameter = 
      -Utilities::MPI::max(-local_min_cell_diameter, MPI_COMM_WORLD); 
    time_step = cfl_number * global_min_cell_diameter; 
    time_step = (final_time - time) / (int((final_time - time) / time_step)); 
    pcout << "   Time step size: " << time_step 
          << ", finest cell: " << global_min_cell_diameter << std::endl 
          << std::endl; 

// 接下来是初始值的设置。由于我们有一个两步的时间步进方法，我们还需要一个在时间步进时的解的值。为了得到准确的结果，需要根据初始时间的解的时间导数来计算，但是在这里我们忽略了这个困难，只是将其设置为该人工时间的初始值函数。

// 然后，我们继续将初始状态写入文件，并将两个初始解收集到 <tt>std::vector</tt> 的指针中，这些指针随后被 SineGordonOperation::apply() 函数消耗。接下来，根据文件顶部指定的有限元程度，建立一个 <code> SineGordonOperation class </code> 的实例。

    VectorTools::interpolate(mapping, 
                             dof_handler, 
                             InitialCondition<dim>(1, time), 
                             solution); 
    VectorTools::interpolate(mapping, 
                             dof_handler, 
                             InitialCondition<dim>(1, time - time_step), 
                             old_solution); 
    output_results(0); 

    std::vector<LinearAlgebra::distributed::Vector<double> *> 
      previous_solutions({&old_solution, &old_old_solution}); 

    SineGordonOperation<dim, fe_degree> sine_gordon_op(matrix_free_data, 
                                                       time_step); 

// 现在在时间步骤上循环。在每个迭代中，我们将解的向量移动一个，并调用`正弦戈登运算器'类的`应用'函数。然后，我们将解决方案写到一个文件中。我们对所需的计算时间和创建输出所需的时间进行计时，并在时间步长结束后报告这些数字。

// 注意这个交换是如何实现的。我们只是在两个向量上调用了交换方法，只交换了一些指针，而不需要复制数据，这在显式时间步进方法中是比较昂贵的操作。让我们来看看发生了什么。首先，我们交换 <code>old_solution</code> with <code>old_old_solution</code> ，这意味着 <code>old_old_solution</code> 得到 <code>old_solution</code> ，这就是我们所期望的。同样，在下一步中， <code>old_solution</code> gets the content from <code>solution</code> 也是如此。在这之后， <code>solution</code> 持有 <code>old_old_solution</code> ，但这将在这一步被覆盖。

    unsigned int timestep_number = 1; 

    Timer  timer; 
    double wtime       = 0; 
    double output_time = 0; 
    for (time += time_step; time <= final_time; 
         time += time_step, ++timestep_number) 
      { 
        timer.restart(); 
        old_old_solution.swap(old_solution); 
        old_solution.swap(solution); 
        sine_gordon_op.apply(solution, previous_solutions); 
        wtime += timer.wall_time(); 

        timer.restart(); 
        if (timestep_number % output_timestep_skip == 0) 
          output_results(timestep_number / output_timestep_skip); 

        output_time += timer.wall_time(); 
      } 
    timer.restart(); 
    output_results(timestep_number / output_timestep_skip + 1); 
    output_time += timer.wall_time(); 

    pcout << std::endl 
          << "   Performed " << timestep_number << " time steps." << std::endl; 

    pcout << "   Average wallclock time per time step: " 
          << wtime / timestep_number << "s" << std::endl; 

    pcout << "   Spent " << output_time << "s on output and " << wtime 
          << "s on computations." << std::endl; 
  } 
} // namespace Step48 

//  @sect3{The <code>main</code> function}  

// 与 step-40 中一样，我们在程序开始时初始化MPI。由于我们一般会将MPI并行化与线程混合在一起，所以我们也将MPI_InitFinalize中控制线程数量的第三个参数设置为无效数字，这意味着TBB库会自动选择线程的数量，通常为系统中可用的内核数量。作为一种选择，如果你想设置一个特定的线程数（例如，当需要只使用MPI时），你也可以手动设置这个数字。

int main(int argc, char **argv) 
{ 
  using namespace Step48; 
  using namespace dealii; 

  Utilities::MPI::MPI_InitFinalize mpi_initialization( 
    argc, argv, numbers::invalid_unsigned_int); 

  try 
    { 
      SineGordonProblem<dimension> sg_problem; 
      sg_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-49.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2013 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Timo Heister, Texas A&M University, 2013 
 */ 



// 这个教程程序很奇怪，与其他大多数步骤不同，介绍中已经提供了关于如何使用各种策略来生成网格的大部分信息。因此，这里没有什么需要评论的，我们在代码中穿插了相对较少的文字。从本质上讲，这里的代码只是提供了一个在介绍中已经描述过的内容的参考实现。

//  @sect3{Include files}  
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_in.h> 

#include <iostream> 
#include <fstream> 

#include <map> 

using namespace dealii; 
// @sect3{Generating output for a given mesh}  

// 下面的函数为我们将在本程序的剩余部分中生成的任何网格生成一些输出。特别是，它生成了以下信息。



// - 一些关于这个网格所处的空间维数和它的单元数的一般信息。

// - 使用每个边界指标的边界面的数量，这样就可以和我们预期的情况进行比较。

// 最后，该函数将网格输出为VTU格式，可以方便地在Paraview或VisIt中进行可视化。

template <int dim> 
void print_mesh_info(const Triangulation<dim> &triangulation, 
                     const std::string &       filename) 
{ 
  std::cout << "Mesh info:" << std::endl 
            << " dimension: " << dim << std::endl 
            << " no. of cells: " << triangulation.n_active_cells() << std::endl; 

// 接下来循环所有单元格的所有面，找出每个边界指标的使用频率（请记住，如果你访问一个不存在的 std::map 对象的元素，它将被隐式创建并默认初始化--在当前情况下为零--然后我们再将其增加）。

  { 
    std::map<types::boundary_id, unsigned int> boundary_count; 
    for (const auto &face : triangulation.active_face_iterators()) 
      if (face->at_boundary()) 
        boundary_count[face->boundary_id()]++; 

    std::cout << " boundary indicators: "; 
    for (const std::pair<const types::boundary_id, unsigned int> &pair : 
         boundary_count) 
      { 
        std::cout << pair.first << "(" << pair.second << " times) "; 
      } 
    std::cout << std::endl; 
  } 

// 最后，产生一个网格的图形表示到一个输出文件。

  std::ofstream out(filename); 
  GridOut       grid_out; 
  grid_out.write_vtu(triangulation, out); 
  std::cout << " written to " << filename << std::endl << std::endl; 
} 
// @sect3{Main routines}  
// @sect4{grid_1: Loading a mesh generated by gmsh}  

// 在这第一个例子中，我们展示了如何加载我们在介绍中讨论过的如何生成的网格。这与 step-5 中加载网格的模式相同，尽管那里是以不同的文件格式（UCD而不是MSH）编写。

void grid_1() 
{ 
  Triangulation<2> triangulation; 

  GridIn<2> gridin; 
  gridin.attach_triangulation(triangulation); 
  std::ifstream f("example.msh"); 
  gridin.read_msh(f); 

  print_mesh_info(triangulation, "grid-1.vtu"); 
} 
// @sect4{grid_2: Merging triangulations}  

// 在这里，我们首先创建两个三角形，然后将它们合并成一个。 正如介绍中所讨论的，必须确保共同界面的顶点位于相同的坐标上。

void grid_2() 
{ 
  Triangulation<2> tria1; 
  GridGenerator::hyper_cube_with_cylindrical_hole(tria1, 0.25, 1.0); 

  Triangulation<2>          tria2; 
  std::vector<unsigned int> repetitions(2); 
  repetitions[0] = 3; 
  repetitions[1] = 2; 
  GridGenerator::subdivided_hyper_rectangle(tria2, 
                                            repetitions, 
                                            Point<2>(1.0, -1.0), 
                                            Point<2>(4.0, 1.0)); 

  Triangulation<2> triangulation; 
  GridGenerator::merge_triangulations(tria1, tria2, triangulation); 

  print_mesh_info(triangulation, "grid-2.vtu"); 
} 
// @sect4{grid_3: Moving vertices}  

// 在这个函数中，我们移动一个网格的顶点。这比人们通常想象的要简单：如果你用 <code>cell-@>vertex(i)</code> 询问一个单元格的 <code>i</code> 的顶点的坐标，它不只是提供这个顶点的位置，实际上是对存储这些坐标的位置的引用。然后我们可以修改存储在那里的值。

// 所以这就是我们在这个函数的第一部分所做的。我们创建一个几何形状为 $[-1,1]^2$ 的正方形，在原点处有一个半径为0.25的圆孔。然后我们在所有单元格和所有顶点上循环，如果一个顶点的 $y$ 坐标等于1，我们就把它向上移动0.5。

// 注意，这种程序通常不是这样工作的，因为通常会多次遇到相同的顶点，并且可能会多次移动它们。它在这里起作用是因为我们根据顶点的几何位置来选择要使用的顶点，而移动过一次的顶点在未来将无法通过这个测试。解决这个问题的一个更普遍的方法是保留一个 std::set ，即那些我们已经移动过的顶点索引（我们可以用 <code>cell-@>vertex_index(i)</code> 获得，并且只移动那些索引还不在这个集合中的顶点。

void grid_3() 
{ 
  Triangulation<2> triangulation; 
  GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 0.25, 1.0); 

  for (const auto &cell : triangulation.active_cell_iterators()) 
    { 
      for (const auto i : cell->vertex_indices()) 
        { 
          Point<2> &v = cell->vertex(i); 
          if (std::abs(v(1) - 1.0) < 1e-5) 
            v(1) += 0.5; 
        } 
    } 

// 在第二步，我们将对网格进行两次细化。为了正确做到这一点，我们应该沿着以原点为中心的圆的表面在内部边界上放置新的点。幸运的是， GridGenerator::hyper_cube_with_cylindrical_hole 已经在内部边界上附加了一个Manifold对象，所以我们不需要做任何事情，只需要细化网格（参见<a href="#Results">results section</a>中一个完全可行的例子，我们 <em> 做 </em> 附加一个Manifold对象）。

  triangulation.refine_global(2); 
  print_mesh_info(triangulation, "grid-3.vtu"); 
} 

// 如上图所示，做事有一个障碍。如果像这里所示的那样移动边界上的节点，由于内部的节点没有被移动，所以经常会出现内部的单元被严重扭曲的情况。在目前的情况下，这并不是一个很大的问题，因为当节点被移动时，网格并不包含任何内部节点--它是粗略的网格，而且恰好所有的顶点都在边界上。还有一种情况是，我们在这里的移动，与平均单元的大小相比，并没有太大影响。然而，有时我们确实想把顶点移动一段距离，在这种情况下，我们也需要移动内部节点。一个自动完成的方法是调用函数 GridTools::laplace_transform ，该函数接收一组转换后的顶点坐标并移动所有其他的顶点，使产生的网格在某种意义上有一个小的变形。

//  @sect4{grid_4: Demonstrating extrude_triangulation}  

// 这个例子从前面的函数中获取初始网格，并简单地将其挤压到第三空间维度。

void grid_4() 
{ 
  Triangulation<2> triangulation; 
  Triangulation<3> out; 
  GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 0.25, 1.0); 

  GridGenerator::extrude_triangulation(triangulation, 3, 2.0, out); 
  print_mesh_info(out, "grid-4.vtu"); 
} 
// @sect4{grid_5: Demonstrating GridTools::transform, part 1}  

// 这个例子和下一个例子首先创建一个网格，然后根据一个函数移动网格的每个节点，这个函数接收一个点并返回一个映射的点。在这个例子中，我们转换  $(x,y) \mapsto (x,y+\sin(\pi x/5))$  。

//  GridTools::transform()  需要一个三角形和一个参数，这个参数可以像一个函数一样被调用，接收一个点并返回一个点。有不同的方式来提供这样一个参数。它可以是一个函数的指针；它可以是一个具有`operator()`的类的对象；它可以是一个lambda函数；或者它可以是任何通过 <code>std::function@<Point@<2@>(const Point@<2@>)@></code> 对象描述的东西。

// 更现代的方法是使用一个接受一个点并返回一个点的lambda函数，这就是我们在下面所做的。

void grid_5() 
{ 
  Triangulation<2>          triangulation; 
  std::vector<unsigned int> repetitions(2); 
  repetitions[0] = 14; 
  repetitions[1] = 2; 
  GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                            repetitions, 
                                            Point<2>(0.0, 0.0), 
                                            Point<2>(10.0, 1.0)); 

  GridTools::transform( 
    [](const Point<2> &in) { 
      return Point<2>(in[0], in[1] + std::sin(numbers::PI * in[0] / 5.0)); 
    }, 
    triangulation); 
  print_mesh_info(triangulation, "grid-5.vtu"); 
} 

//  @sect4{grid_6: Demonstrating GridTools::transform, part 2}  

// 在第二个例子中，我们将使用映射  $(x,y) \mapsto (x,\tanh(2y)/\tanh(2))$  将原始网格中的点转换为新的网格。为了使事情更有趣，而不是像前面的例子那样在一个单一的函数中完成，我们在这里创建一个具有  <code>operator()</code>  的对象，这个对象将被  GridTools::transform.  所调用。当然，这个对象实际上可能要复杂得多：这个对象可能有成员变量，在计算顶点的新位置时起作用。

struct Grid6Func 
{ 
  double trans(const double y) const 
  { 
    return std::tanh(2 * y) / tanh(2); 
  } 

  Point<2> operator()(const Point<2> &in) const 
  { 
    return {in(0), trans(in(1))}; 
  } 
}; 

void grid_6() 
{ 
  Triangulation<2>          triangulation; 
  std::vector<unsigned int> repetitions(2); 
  repetitions[0] = repetitions[1] = 40; 
  GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                            repetitions, 
                                            Point<2>(0.0, 0.0), 
                                            Point<2>(1.0, 1.0)); 

  GridTools::transform(Grid6Func(), triangulation); 
  print_mesh_info(triangulation, "grid-6.vtu"); 
} 
// @sect4{grid_7: Demonstrating distort_random}  

// 在这最后一个例子中，我们创建了一个网格，然后通过随机扰动使其（内部）顶点变形。这不是你想在生产计算中做的事情（因为在具有 "良好形状 "单元的网格上的结果通常比在 GridTools::distort_random()), 产生的变形单元上的结果要好，但这是一个有用的工具，可以测试离散化和代码，确保它们不会因为网格恰好是均匀结构和支持超级收敛特性而意外地工作。

void grid_7() 
{ 
  Triangulation<2>          triangulation; 
  std::vector<unsigned int> repetitions(2); 
  repetitions[0] = repetitions[1] = 16; 
  GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                            repetitions, 
                                            Point<2>(0.0, 0.0), 
                                            Point<2>(1.0, 1.0)); 

  GridTools::distort_random(0.3, triangulation, true); 
  print_mesh_info(triangulation, "grid-7.vtu"); 
} 
// @sect3{The main function}  

// 最后是主函数。这里没有什么可做的，只是调用我们上面写的所有各种函数。

int main() 
{ 
  try 
    { 
      grid_1(); 
      grid_2(); 
      grid_3(); 
      grid_4(); 
      grid_5(); 
      grid_6(); 
      grid_7(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
} 


CCTest_file/step-5.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 1999 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 1999 
 */ 


// @sect3{Include files}  

// 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

// 这个是新的。我们想从磁盘上读取一个三角图，做这个的类在下面的文件中声明。

#include <deal.II/grid/grid_in.h> 

// 我们将使用一个圆形域，而描述其边界的对象来自这个文件。

#include <deal.II/grid/manifold_lib.h> 

// 这是C++ ...

#include <fstream> 
#include <iostream> 

// 最后，这在以前的教程程序中已经讨论过了。

using namespace dealii; 
// @sect3{The <code>Step5</code> class template}  

// 主类大部分和前面的例子一样。最明显的变化是删除了 <code>make_grid</code> 函数，因为现在创建网格是在 <code>run</code> 函数中完成的，其余功能都在 <code>setup_system</code> 中。除此以外，一切都和以前一样。

template <int dim> 
class Step5 
{ 
public: 
  Step5(); 
  void run(); 

private: 
  void setup_system(); 
  void assemble_system(); 
  void solve(); 
  void output_results(const unsigned int cycle) const; 

  Triangulation<dim> triangulation; 
  FE_Q<dim>          fe; 
  DoFHandler<dim>    dof_handler; 

  SparsityPattern      sparsity_pattern; 
  SparseMatrix<double> system_matrix; 

  Vector<double> solution; 
  Vector<double> system_rhs; 
}; 
// @sect3{Working with nonconstant coefficients}  

// 在  step-4  中，我们展示了如何使用非恒定边界值和右手边。 在这个例子中，我们想在椭圆算子中使用一个可变系数来代替。由于我们有一个只取决于空间中的点的函数，我们可以做得更简单一些，使用一个普通的函数而不是继承自Function。

// 这是对单点的系数函数的实现。如果与原点的距离小于0.5，我们让它返回20，否则返回1。

template <int dim> 
double coefficient(const Point<dim> &p) 
{ 
  if (p.square() < 0.5 * 0.5) 
    return 20; 
  else 
    return 1; 
} 
// @sect3{The <code>Step5</code> class implementation}  
// @sect4{Step5::Step5}  

// 这个函数和以前一样。

template <int dim> 
Step5<dim>::Step5() 
  : fe(1) 
  , dof_handler(triangulation) 
{} 

//  @sect4{Step5::setup_system}  

// 这是前面例子中的函数 <code>make_grid</code> ，减去了生成网格的部分。其他一切都没有变化。

template <int dim> 
void Step5<dim>::setup_system() 
{ 
  dof_handler.distribute_dofs(fe); 

  std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
            << std::endl; 

  DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
  DoFTools::make_sparsity_pattern(dof_handler, dsp); 
  sparsity_pattern.copy_from(dsp); 

  system_matrix.reinit(sparsity_pattern); 

  solution.reinit(dof_handler.n_dofs()); 
  system_rhs.reinit(dof_handler.n_dofs()); 
} 

//  @sect4{Step5::assemble_system}  

// 和前面的例子一样，这个函数在功能上没有太大变化，但仍有一些优化，我们将展示这些优化。对此，需要注意的是，如果使用高效的求解器（如预设条件的CG方法），组装矩阵和右手边会花费相当的时间，你应该考虑在某些地方使用一到两个优化。

// 该函数的前几部分与之前完全没有变化。

template <int dim> 
void Step5<dim>::assemble_system() 
{ 
  QGauss<dim> quadrature_formula(fe.degree + 1); 

  FEValues<dim> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_gradients | 
                            update_quadrature_points | update_JxW_values); 

  const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
  Vector<double>     cell_rhs(dofs_per_cell); 

  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 接下来是对所有单元的典型循环，以计算局部贡献，然后将它们转移到全局矩阵和向量中。与 step-4 相比，这部分的唯一变化是我们将使用上面定义的 <code>coefficient()</code> 函数来计算每个正交点的系数值。

  for (const auto &cell : dof_handler.active_cell_iterators()) 
    { 
      cell_matrix = 0.; 
      cell_rhs    = 0.; 

      fe_values.reinit(cell); 

      for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
        { 
          const double current_coefficient = 
            coefficient(fe_values.quadrature_point(q_index)); 
          for (const unsigned int i : fe_values.dof_indices()) 
            { 
              for (const unsigned int j : fe_values.dof_indices()) 
                cell_matrix(i, j) += 
                  (current_coefficient *              // a(x_q) 
                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q) 
                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q) 
                   fe_values.JxW(q_index));           // dx 

              cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q) 
                              1.0 *                               // f(x_q) 
                              fe_values.JxW(q_index));            // dx 
            } 
        } 

      cell->get_dof_indices(local_dof_indices); 
      for (const unsigned int i : fe_values.dof_indices()) 
        { 
          for (const unsigned int j : fe_values.dof_indices()) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 

          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
        } 
    } 

// 有了这样构建的矩阵，我们再次使用零边界值。

  std::map<types::global_dof_index, double> boundary_values; 
  VectorTools::interpolate_boundary_values(dof_handler, 
                                           0, 
                                           Functions::ZeroFunction<dim>(), 
                                           boundary_values); 
  MatrixTools::apply_boundary_values(boundary_values, 
                                     system_matrix, 
                                     solution, 
                                     system_rhs); 
} 
// @sect4{Step5::solve}  

// 求解过程看起来又和前面的例子差不多。然而，我们现在将使用一个预设条件的共轭梯度算法。做出这种改变并不难。事实上，我们唯一需要改变的是，我们需要一个作为预处理程序的对象。我们将使用SSOR（对称连续过度放松），放松系数为1.2。为此， <code>SparseMatrix</code> 类有一个函数可以做一个SSOR步骤，我们需要把这个函数的地址和它应该作用的矩阵（也就是要反转的矩阵）以及松弛因子打包成一个对象。 <code>PreconditionSSOR</code> 类为我们做了这个。(  <code>PreconditionSSOR</code>  类需要一个模板参数，表示它应该工作的矩阵类型。默认值是 <code>SparseMatrix@<double@></code> ，这正是我们在这里需要的，所以我们只需坚持使用默认值，不在角括号中指定任何东西。)

// 请注意，在目前的情况下，SSOR的表现并不比其他大多数预处理程序好多少（尽管比没有预处理好）。在下一个教程程序  step-6  的结果部分，将对不同的预处理进行简要比较。

// 有了这个，函数的其余部分就很简单了：我们现在使用我们声明的预处理程序，而不是之前创建的 <code>PreconditionIdentity</code> 对象，CG求解器将为我们完成其余的工作。

template <int dim> 
void Step5<dim>::solve() 
{ 
  SolverControl            solver_control(1000, 1e-12); 
  SolverCG<Vector<double>> solver(solver_control); 

  PreconditionSSOR<SparseMatrix<double>> preconditioner; 
  preconditioner.initialize(system_matrix, 1.2); 

  solver.solve(system_matrix, solution, system_rhs, preconditioner); 

  std::cout << "   " << solver_control.last_step() 
            << " CG iterations needed to obtain convergence." << std::endl; 
} 
// @sect4{Step5::output_results and setting output flags}  

// 将输出写入文件的方法与上一个教程中的基本相同。唯一不同的是，我们现在需要为每个细化周期构建一个不同的文件名。

// 这个函数以VTU格式写入输出，这是VTK格式的一个变种，因为它压缩了数据，所以需要更少的磁盘空间。当然，如果你希望使用一个不理解VTK或VTU的可视化程序，DataOut类还支持许多其他格式。

template <int dim> 
void Step5<dim>::output_results(const unsigned int cycle) const 
{ 
  DataOut<dim> data_out; 

  data_out.attach_dof_handler(dof_handler); 
  data_out.add_data_vector(solution, "solution"); 

  data_out.build_patches(); 

  std::ofstream output("solution-" + std::to_string(cycle) + ".vtu"); 
  data_out.write_vtu(output); 
} 

//  @sect4{Step5::run}  

// 在这个程序中，倒数第二件事是对 <code>run()</code> 函数的定义。与之前的程序不同，我们将在一个网格序列上进行计算，在每次迭代后都会进行全局细化。因此，该函数由6个周期的循环组成。在每个循环中，我们首先打印循环编号，然后决定如何处理网格。如果这不是第一个周期，我们就简单地对现有的网格进行一次全局精炼。然而，在运行这些循环之前，我们必须先生成一个网格。

// 在前面的例子中，我们已经使用了 <code>GridGenerator</code> 类中的一些函数。在这里，我们想从一个存储单元的文件中读取网格，这个文件可能来自其他人，也可能是一个网格生成工具的产物。

// 为了从文件中读取网格，我们生成一个数据类型为GridIn的对象，并将三角剖分与之相关联（也就是说，当我们要求它读取文件时，我们告诉它要填充我们的三角剖分对象）。然后我们打开相应的文件，用文件中的数据初始化三角剖分。

template <int dim> 
void Step5<dim>::run() 
{ 
  GridIn<dim> grid_in; 
  grid_in.attach_triangulation(triangulation); 
  std::ifstream input_file("circle-grid.inp"); 

// 我们现在想读取该文件。但是，输入文件只针对二维三角图，而这个函数是一个任意维度的模板。由于这只是一个演示程序，我们不会为不同的维度使用不同的输入文件，而是在不在二维的情况下迅速杀死整个程序。当然，由于下面的主函数假定我们是在二维空间工作，我们可以跳过这个检查，在这个版本的程序中，不会有任何不良影响。

// 事实证明，90%以上的编程错误都是无效的函数参数，如无效的数组大小等，所以我们在整个deal.II中大量使用断言来捕捉此类错误。为此， <code>Assert</code> 宏是一个很好的选择，因为它确保作为第一个参数的条件是有效的，如果不是，就抛出一个异常（它的第二个参数），通常会终止程序，并给出错误发生的位置和原因的信息。关于 @p Assert 宏的具体作用，可以在 @ref Exceptions "异常文档模块 "中找到更详细的讨论）。这通常会大大减少发现编程错误的时间，我们发现断言是快速编程的宝贵手段。

// 另一方面，如果你想做大的计算，所有这些检查（目前库中有超过10000个）不应该使程序太慢。为此， <code>Assert</code> 宏只在调试模式下使用，如果在优化模式下则扩展为零。因此，当你在小问题上测试你的程序并进行调试时，断言会告诉你问题出在哪里。一旦你的程序稳定了，你可以关闭调试，程序将在没有断言的情况下以最大速度运行你的实际计算。更准确地说：通过在优化模式下编译你的程序，关闭库中的所有检查（这些检查可以防止你用错误的参数调用函数，从数组中走出来，等等），通常可以使程序的运行速度提高四倍左右。即使优化后的程序性能更高，我们仍然建议在调试模式下开发，因为它允许库自动发现许多常见的编程错误。对于那些想尝试的人来说。从调试模式切换到优化模式的方法是用<code>make release</code>命令重新编译你的程序。现在 <code>make</code> 程序的输出应该向你表明，该程序现在是以优化模式编译的，以后也会被链接到已经为优化模式编译的库。为了切换回调试模式，只需用  <code>make debug</code>  命令重新编译。

  Assert(dim == 2, ExcInternalError()); 

// ExcInternalError是一个全局定义的异常，每当出现严重的错误时就会抛出。通常，人们希望使用更具体的异常，特别是在这种情况下，如果 <code>dim</code> 不等于2，人们当然会尝试做其他事情，例如使用库函数创建一个网格。终止程序通常不是一个好主意，断言实际上只应该用于不应该发生的特殊情况，但由于程序员、用户或其他人的愚蠢而可能发生。上面的情况并不是对Assert的巧妙使用，但是再次强调：这是一个教程，也许值得展示一下什么是不应该做的，毕竟。

// 所以，如果我们通过了断言，我们就知道dim==2，现在我们就可以真正地读取网格。它的格式是UCD（非结构化单元数据）（尽管惯例是使用UCD文件的后缀 <code>inp</code> ）。

  grid_in.read_ucd(input_file); 

// 如果你想使用其他输入格式，你必须使用其他 <code>grid_in.read_xxx</code> 函数之一。(参见  <code>GridIn</code>  类的文档，以了解目前支持哪些输入格式)。

// 文件中的网格描述了一个圆。因此，我们必须使用一个流形对象，告诉三角计算在细化网格时将边界上的新点放在哪里。与 step-1 不同的是，由于GridIn不知道域的边界是圆形的（与 GridGenerator::hyper_shell) 不同的是，我们必须在创建三角网格后明确地将流形附加到边界上，以便在细化网格时获得正确的结果。

  const SphericalManifold<dim> boundary; 
  triangulation.set_all_manifold_ids_on_boundary(0); 
  triangulation.set_manifold(0, boundary); 

  for (unsigned int cycle = 0; cycle < 6; ++cycle) 
    { 
      std::cout << "Cycle " << cycle << ':' << std::endl; 

      if (cycle != 0) 
        triangulation.refine_global(1); 

// 现在我们有了一个确定的网格，我们写一些输出，做所有我们在前面的例子中已经看到的事情。

      std::cout << "   Number of active cells: "  // 
                << triangulation.n_active_cells() // 
                << std::endl                      // 
                << "   Total number of cells: "   // 
                << triangulation.n_cells()        // 
                << std::endl; 

      setup_system(); 
      assemble_system(); 
      solve(); 
      output_results(cycle); 
    } 
} 
// @sect3{The <code>main</code> function}  

// 主函数看起来和前面的例子中的函数差不多，所以我们就不进一步评论了。

int main() 
{ 
  Step5<2> laplace_problem_2d; 
  laplace_problem_2d.run(); 
  return 0; 
} 

CCTest_file/step-50.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2019 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Thomas C. Clevenger, Clemson University 
 *         Timo Heister, Clemson University 
 *         Guido Kanschat, Heidelberg University 
 *         Martin Kronbichler, Technical University of Munich 
 */ 


// @sect3{Include files}  

// 包含文件是  step-40  ,  step-16  , 和  step-37  的组合。

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/data_out_base.h> 
#include <deal.II/base/index_set.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/parameter_handler.h> 
#include <deal.II/distributed/grid_refinement.h> 
#include <deal.II/distributed/tria.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 

// 我们使用与 step-40 相同的策略，在PETSc和Trilinos之间进行切换。

#include <deal.II/lac/generic_linear_algebra.h> 

// 如果你已经安装了PETSc和Trilinos，并且你喜欢在本例中使用PETSc，请将下面的预处理程序定义注释进去或退出。

#define FORCE_USE_OF_TRILINOS 

namespace LA 
{ 
#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \ 
  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS)) 
  using namespace dealii::LinearAlgebraPETSc; 
#  define USE_PETSC_LA 
#elif defined(DEAL_II_WITH_TRILINOS) 
  using namespace dealii::LinearAlgebraTrilinos; 
#else 
#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required 
#endif 
} // namespace LA 

#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/operators.h> 
#include <deal.II/matrix_free/fe_evaluation.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_constrained_dofs.h> 
#include <deal.II/multigrid/mg_matrix.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_transfer.h> 
#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer_matrix_free.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 以下文件用于组装误差估计器，如  step-12  。

#include <deal.II/fe/fe_interface_values.h> 
#include <deal.II/meshworker/mesh_loop.h> 

using namespace dealii; 
// @sect3{Coefficients and helper classes}  

// MatrixFree运算符必须使用 dealii::LinearAlgebra::distributed::Vector 矢量类型。这里我们定义了复制到Trilinos向量的操作，以便与基于矩阵的代码兼容。请注意，目前PETSc矢量类型不存在这种功能，所以必须安装Trilinos来使用本教程中的MatrixFree求解器。

namespace ChangeVectorTypes 
{ 
  template <typename number> 
  void copy(LA::MPI::Vector &                                         out, 
            const dealii::LinearAlgebra::distributed::Vector<number> &in) 
  { 
    dealii::LinearAlgebra::ReadWriteVector<double> rwv( 
      out.locally_owned_elements()); 
    rwv.import(in, VectorOperation::insert); 
#ifdef USE_PETSC_LA 
    AssertThrow(false, 
                ExcMessage("CopyVectorTypes::copy() not implemented for " 
                           "PETSc vector types.")); 
#else 
    out.import(rwv, VectorOperation::insert); 
#endif 
  } 

  template <typename number> 
  void copy(dealii::LinearAlgebra::distributed::Vector<number> &out, 
            const LA::MPI::Vector &                             in) 
  { 
    dealii::LinearAlgebra::ReadWriteVector<double> rwv; 
#ifdef USE_PETSC_LA 
    (void)in; 
    AssertThrow(false, 
                ExcMessage("CopyVectorTypes::copy() not implemented for " 
                           "PETSc vector types.")); 
#else 
    rwv.reinit(in); 
#endif 
    out.import(rwv, VectorOperation::insert); 
  } 
} // namespace ChangeVectorTypes 

// 让我们继续描述我们要解决的问题。我们把右边的函数设置为1.0。 @p value 函数返回一个VectorizedArray，被无矩阵代码路径所使用。

template <int dim> 
class RightHandSide : public Function<dim> 
{ 
public: 
  virtual double value(const Point<dim> & /*p*/, 
                       const unsigned int /*component*/ = 0) const override 
  { 
    return 1.0; 
  } 

  template <typename number> 
  VectorizedArray<number> 
  value(const Point<dim, VectorizedArray<number>> & /*p*/, 
        const unsigned int /*component*/ = 0) const 
  { 
    return VectorizedArray<number>(1.0); 
  } 
}; 

// 接下来的这个类表示扩散系数。我们使用一个可变的系数，在任何一个至少有一个坐标小于-0.5的点上是100.0，在所有其他点上是1.0。如上所述，一个单独的value()返回一个VectorizedArray，用于无矩阵代码。一个 @p average()函数计算了一组点的算术平均。

template <int dim> 
class Coefficient : public Function<dim> 
{ 
public: 
  virtual double value(const Point<dim> &p, 
                       const unsigned int /*component*/ = 0) const override; 

  template <typename number> 
  VectorizedArray<number> value(const Point<dim, VectorizedArray<number>> &p, 
                                const unsigned int /*component*/ = 0) const; 

  template <typename number> 
  number average_value(const std::vector<Point<dim, number>> &points) const; 

// 当在MatrixFree框架中使用一个系数时，我们还需要一个函数，为MatrixFree运算符参数提供的一组单元格创建一个系数表。

  template <typename number> 
  std::shared_ptr<Table<2, VectorizedArray<number>>> make_coefficient_table( 
    const MatrixFree<dim, number, VectorizedArray<number>> &mf_storage) const; 
}; 

template <int dim> 
double Coefficient<dim>::value(const Point<dim> &p, const unsigned int) const 
{ 
  for (int d = 0; d < dim; ++d) 
    { 
      if (p[d] < -0.5) 
        return 100.0; 
    } 
  return 1.0; 
} 

template <int dim> 
template <typename number> 
VectorizedArray<number> 
Coefficient<dim>::value(const Point<dim, VectorizedArray<number>> &p, 
                        const unsigned int) const 
{ 
  VectorizedArray<number> return_value = VectorizedArray<number>(1.0); 
  for (unsigned int i = 0; i < VectorizedArray<number>::size(); ++i) 
    { 
      for (int d = 0; d < dim; ++d) 
        if (p[d][i] < -0.5) 
          { 
            return_value[i] = 100.0; 
            break; 
          } 
    } 

  return return_value; 
} 

template <int dim> 
template <typename number> 
number Coefficient<dim>::average_value( 
  const std::vector<Point<dim, number>> &points) const 
{ 
  number average(0); 
  for (unsigned int i = 0; i < points.size(); ++i) 
    average += value(points[i]); 
  average /= points.size(); 

  return average; 
} 

template <int dim> 
template <typename number> 
std::shared_ptr<Table<2, VectorizedArray<number>>> 
Coefficient<dim>::make_coefficient_table( 
  const MatrixFree<dim, number, VectorizedArray<number>> &mf_storage) const 
{ 
  auto coefficient_table = 
    std::make_shared<Table<2, VectorizedArray<number>>>(); 

  FEEvaluation<dim, -1, 0, 1, number> fe_eval(mf_storage); 

  const unsigned int n_cells    = mf_storage.n_cell_batches(); 
  const unsigned int n_q_points = fe_eval.n_q_points; 

  coefficient_table->reinit(n_cells, 1); 

  for (unsigned int cell = 0; cell < n_cells; ++cell) 
    { 
      fe_eval.reinit(cell); 

      VectorizedArray<number> average_value = 0.; 
      for (unsigned int q = 0; q < n_q_points; ++q) 
        average_value += value(fe_eval.quadrature_point(q)); 
      average_value /= n_q_points; 

      (*coefficient_table)(cell, 0) = average_value; 
    } 

  return coefficient_table; 
} 

//  @sect3{Run time parameters}  

// 我们将使用ParameterHandler来在运行时传入参数。 该结构 @p Settings 解析并存储这些参数，以便在整个程序中进行查询。

struct Settings 
{ 
  bool try_parse(const std::string &prm_filename); 

  enum SolverType 
  { 
    gmg_mb, 
    gmg_mf, 
    amg 
  }; 

  SolverType solver; 

  int          dimension; 
  double       smoother_dampen; 
  unsigned int smoother_steps; 
  unsigned int n_steps; 
  bool         output; 
}; 

bool Settings::try_parse(const std::string &prm_filename) 
{ 
  ParameterHandler prm; 
  prm.declare_entry("dim", "2", Patterns::Integer(), "The problem dimension."); 
  prm.declare_entry("n_steps", 
                    "10", 
                    Patterns::Integer(0), 
                    "Number of adaptive refinement steps."); 
  prm.declare_entry("smoother dampen", 
                    "1.0", 
                    Patterns::Double(0.0), 
                    "Dampen factor for the smoother."); 
  prm.declare_entry("smoother steps", 
                    "1", 
                    Patterns::Integer(1), 
                    "Number of smoother steps."); 
  prm.declare_entry("solver", 
                    "MF", 
                    Patterns::Selection("MF|MB|AMG"), 
                    "Switch between matrix-free GMG, " 
                    "matrix-based GMG, and AMG."); 
  prm.declare_entry("output", 
                    "false", 
                    Patterns::Bool(), 
                    "Output graphical results."); 

  if (prm_filename.size() == 0) 
    { 
      std::cout << "****  Error: No input file provided!\n" 
                << "****  Error: Call this program as './step-50 input.prm\n" 
                << "\n" 
                << "****  You may want to use one of the input files in this\n" 
                << "****  directory, or use the following default values\n" 
                << "****  to create an input file:\n"; 
      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
        prm.print_parameters(std::cout, ParameterHandler::Text); 
      return false; 
    } 

  try 
    { 
      prm.parse_input(prm_filename); 
    } 
  catch (std::exception &e) 
    { 
      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
        std::cerr << e.what() << std::endl; 
      return false; 
    } 

  if (prm.get("solver") == "MF") 
    this->solver = gmg_mf; 
  else if (prm.get("solver") == "MB") 
    this->solver = gmg_mb; 
  else if (prm.get("solver") == "AMG") 
    this->solver = amg; 
  else 
    AssertThrow(false, ExcNotImplemented()); 

  this->dimension       = prm.get_integer("dim"); 
  this->n_steps         = prm.get_integer("n_steps"); 
  this->smoother_dampen = prm.get_double("smoother dampen"); 
  this->smoother_steps  = prm.get_integer("smoother steps"); 
  this->output          = prm.get_bool("output"); 

  return true; 
} 

//  @sect3{LaplaceProblem class}  

// 这是该程序的主类。它看起来与  step-16  ,  step-37  , 和  step-40  非常相似。对于MatrixFree的设置，我们使用 MatrixFreeOperators::LaplaceOperator 类，它在内部定义了`local_apply()`, `compute_diagonal()`, 和`set_coefficient()`函数。请注意，多项式的度数是这个类的一个模板参数。这对无矩阵代码来说是必要的。

template <int dim, int degree> 
class LaplaceProblem 
{ 
public: 
  LaplaceProblem(const Settings &settings); 
  void run(); 

private: 

// 我们将在整个程序中使用以下类型。首先是基于矩阵的类型，之后是无矩阵的类。对于无矩阵的实现，我们使用 @p float 作为水平运算符。

  using MatrixType         = LA::MPI::SparseMatrix; 
  using VectorType         = LA::MPI::Vector; 
  using PreconditionAMG    = LA::MPI::PreconditionAMG; 
  using PreconditionJacobi = LA::MPI::PreconditionJacobi; 

  using MatrixFreeLevelMatrix = MatrixFreeOperators::LaplaceOperator< 
    dim, 
    degree, 
    degree + 1, 
    1, 
    LinearAlgebra::distributed::Vector<float>>; 
  using MatrixFreeActiveMatrix = MatrixFreeOperators::LaplaceOperator< 
    dim, 
    degree, 
    degree + 1, 
    1, 
    LinearAlgebra::distributed::Vector<double>>; 

  using MatrixFreeLevelVector  = LinearAlgebra::distributed::Vector<float>; 
  using MatrixFreeActiveVector = LinearAlgebra::distributed::Vector<double>; 

  void setup_system(); 
  void setup_multigrid(); 
  void assemble_system(); 
  void assemble_multigrid(); 
  void assemble_rhs(); 
  void solve(); 
  void estimate(); 
  void refine_grid(); 
  void output_results(const unsigned int cycle); 

  Settings settings; 

  MPI_Comm           mpi_communicator; 
  ConditionalOStream pcout; 

  parallel::distributed::Triangulation<dim> triangulation; 
  const MappingQ1<dim>                      mapping; 
  FE_Q<dim>                                 fe; 

  DoFHandler<dim> dof_handler; 

 
  IndexSet                  locally_relevant_dofs; 
  AffineConstraints<double> constraints; 

  MatrixType             system_matrix; 
  MatrixFreeActiveMatrix mf_system_matrix; 
  VectorType             solution; 
  VectorType             right_hand_side; 
  Vector<double>         estimated_error_square_per_cell; 

  MGLevelObject<MatrixType> mg_matrix; 
  MGLevelObject<MatrixType> mg_interface_in; 
  MGConstrainedDoFs         mg_constrained_dofs; 

  MGLevelObject<MatrixFreeLevelMatrix> mf_mg_matrix; 

  TimerOutput computing_timer; 
}; 

// 关于构造函数的唯一有趣的部分是，除非我们使用AMG，否则我们会构造多网格的层次结构。为此，我们需要在这个构造函数完成之前解析运行时参数。

template <int dim, int degree> 
LaplaceProblem<dim, degree>::LaplaceProblem(const Settings &settings) 
  : settings(settings) 
  , mpi_communicator(MPI_COMM_WORLD) 
  , pcout(std::cout, (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
  , triangulation(mpi_communicator, 
                  Triangulation<dim>::limit_level_difference_at_vertices, 
                  (settings.solver == Settings::amg) ? 
                    parallel::distributed::Triangulation<dim>::default_setting : 
                    parallel::distributed::Triangulation< 
                      dim>::construct_multigrid_hierarchy) 
  , mapping() 
  , fe(degree) 
  , dof_handler(triangulation) 
  , computing_timer(pcout, TimerOutput::never, TimerOutput::wall_times) 
{ 
  GridGenerator::hyper_L(triangulation, -1., 1., /*colorize*/ false); 
  triangulation.refine_global(1); 
} 

//  @sect4{LaplaceProblem::setup_system()}  

// 与  step-16  和  step-37  不同，我们将设置分成两部分，setup_system() 和 setup_multigrid() 。下面是大多数教程中常见的主动网格的典型setup_system()函数。对于无矩阵，活动网格的设置类似于  step-37  ；对于基于矩阵（GMG和AMG求解器），设置类似于  step-40  。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::setup_system() 
{ 
  TimerOutput::Scope timing(computing_timer, "Setup"); 

  dof_handler.distribute_dofs(fe); 

  DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 
  locally_owned_dofs = dof_handler.locally_owned_dofs(); 

  solution.reinit(locally_owned_dofs, mpi_communicator); 
  right_hand_side.reinit(locally_owned_dofs, mpi_communicator); 
  constraints.reinit(locally_relevant_dofs); 
  DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

  VectorTools::interpolate_boundary_values( 
    mapping, dof_handler, 0, Functions::ZeroFunction<dim>(), constraints); 
  constraints.close(); 

  switch (settings.solver) 
    { 
      case Settings::gmg_mf: 
        { 
          typename MatrixFree<dim, double>::AdditionalData additional_data; 
          additional_data.tasks_parallel_scheme = 
            MatrixFree<dim, double>::AdditionalData::none; 
          additional_data.mapping_update_flags = 
            (update_gradients | update_JxW_values | update_quadrature_points); 
          std::shared_ptr<MatrixFree<dim, double>> mf_storage = 
            std::make_shared<MatrixFree<dim, double>>(); 
          mf_storage->reinit(mapping, 
                             dof_handler, 
                             constraints, 
                             QGauss<1>(degree + 1), 
                             additional_data); 

          mf_system_matrix.initialize(mf_storage); 

          const Coefficient<dim> coefficient; 
          mf_system_matrix.set_coefficient( 
            coefficient.make_coefficient_table(*mf_storage)); 

          break; 
        } 

      case Settings::gmg_mb: 
      case Settings::amg: 
        { 
#ifdef USE_PETSC_LA 
          DynamicSparsityPattern dsp(locally_relevant_dofs); 
          DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints); 

          SparsityTools::distribute_sparsity_pattern(dsp, 
                                                     locally_owned_dofs, 
                                                     mpi_communicator, 
                                                     locally_relevant_dofs); 

          system_matrix.reinit(locally_owned_dofs, 
                               locally_owned_dofs, 
                               dsp, 
                               mpi_communicator); 
#else 
          TrilinosWrappers::SparsityPattern dsp(locally_owned_dofs, 
                                                locally_owned_dofs, 
                                                locally_relevant_dofs, 
                                                mpi_communicator); 
          DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints); 
          dsp.compress(); 
          system_matrix.reinit(dsp); 
#endif 

          break; 
        } 

      default: 
        Assert(false, ExcNotImplemented()); 
    } 
} 
// @sect4{LaplaceProblem::setup_multigrid()}  

// 该函数为无矩阵和基于矩阵的GMG进行多级设置。无矩阵的设置类似于 step-37 ，而基于矩阵的设置类似于 step-16 ，只是我们必须使用适当的分布式稀疏度模式。

// 该函数没有被AMG方法调用，但为了安全起见，该函数的主`switch`语句还是确保了该函数只在已知的多网格设置下运行，如果该函数被调用到两种几何多网格方法以外的地方，则抛出一个断言。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::setup_multigrid() 
{ 
  TimerOutput::Scope timing(computing_timer, "Setup multigrid"); 

  dof_handler.distribute_mg_dofs(); 

  mg_constrained_dofs.clear(); 
  mg_constrained_dofs.initialize(dof_handler); 

  const std::set<types::boundary_id> boundary_ids = {types::boundary_id(0)}; 
  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, boundary_ids); 

  const unsigned int n_levels = triangulation.n_global_levels(); 

  switch (settings.solver) 
    { 
      case Settings::gmg_mf: 
        { 
          mf_mg_matrix.resize(0, n_levels - 1); 

          for (unsigned int level = 0; level < n_levels; ++level) 
            { 
              IndexSet relevant_dofs; 
              DoFTools::extract_locally_relevant_level_dofs(dof_handler, 
                                                            level, 
                                                            relevant_dofs); 
              AffineConstraints<double> level_constraints; 
              level_constraints.reinit(relevant_dofs); 
              level_constraints.add_lines( 
                mg_constrained_dofs.get_boundary_indices(level)); 
              level_constraints.close(); 

              typename MatrixFree<dim, float>::AdditionalData additional_data; 
              additional_data.tasks_parallel_scheme = 
                MatrixFree<dim, float>::AdditionalData::none; 
              additional_data.mapping_update_flags = 
                (update_gradients | update_JxW_values | 
                 update_quadrature_points); 
              additional_data.mg_level = level; 
              std::shared_ptr<MatrixFree<dim, float>> mf_storage_level( 
                new MatrixFree<dim, float>()); 
              mf_storage_level->reinit(mapping, 
                                       dof_handler, 
                                       level_constraints, 
                                       QGauss<1>(degree + 1), 
                                       additional_data); 

              mf_mg_matrix[level].initialize(mf_storage_level, 
                                             mg_constrained_dofs, 
                                             level); 

              const Coefficient<dim> coefficient; 
              mf_mg_matrix[level].set_coefficient( 
                coefficient.make_coefficient_table(*mf_storage_level)); 

              mf_mg_matrix[level].compute_diagonal(); 
            } 

          break; 
        } 

      case Settings::gmg_mb: 
        { 
          mg_matrix.resize(0, n_levels - 1); 
          mg_matrix.clear_elements(); 
          mg_interface_in.resize(0, n_levels - 1); 
          mg_interface_in.clear_elements(); 

          for (unsigned int level = 0; level < n_levels; ++level) 
            { 
              IndexSet dof_set; 
              DoFTools::extract_locally_relevant_level_dofs(dof_handler, 
                                                            level, 
                                                            dof_set); 

              { 
#ifdef USE_PETSC_LA 
                DynamicSparsityPattern dsp(dof_set); 
                MGTools::make_sparsity_pattern(dof_handler, dsp, level); 
                dsp.compress(); 
                SparsityTools::distribute_sparsity_pattern( 
                  dsp, 
                  dof_handler.locally_owned_mg_dofs(level), 
                  mpi_communicator, 
                  dof_set); 

                mg_matrix[level].reinit( 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dsp, 
                  mpi_communicator); 
#else 
                TrilinosWrappers::SparsityPattern dsp( 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dof_set, 
                  mpi_communicator); 
                MGTools::make_sparsity_pattern(dof_handler, dsp, level); 

                dsp.compress(); 
                mg_matrix[level].reinit(dsp); 
#endif 
              } 

              { 
#ifdef USE_PETSC_LA 
                DynamicSparsityPattern dsp(dof_set); 
                MGTools::make_interface_sparsity_pattern(dof_handler, 
                                                         mg_constrained_dofs, 
                                                         dsp, 
                                                         level); 
                dsp.compress(); 
                SparsityTools::distribute_sparsity_pattern( 
                  dsp, 
                  dof_handler.locally_owned_mg_dofs(level), 
                  mpi_communicator, 
                  dof_set); 

                mg_interface_in[level].reinit( 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dsp, 
                  mpi_communicator); 
#else 
                TrilinosWrappers::SparsityPattern dsp( 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dof_handler.locally_owned_mg_dofs(level), 
                  dof_set, 
                  mpi_communicator); 

                MGTools::make_interface_sparsity_pattern(dof_handler, 
                                                         mg_constrained_dofs, 
                                                         dsp, 
                                                         level); 
                dsp.compress(); 
                mg_interface_in[level].reinit(dsp); 
#endif 
              } 
            } 
          break; 
        } 

      default: 
        Assert(false, ExcNotImplemented()); 
    } 
} 
// @sect4{LaplaceProblem::assemble_system()}  

// 汇编被分成三个部分：`assemble_system()`, `assemble_multigrid()`, 和`assemble_rhs()`。这里的`assemble_system()`函数组装并存储（全局）系统矩阵和基于矩阵的方法的右手边。它类似于  step-40  中的装配。

// 注意，无矩阵方法不执行这个函数，因为它不需要组装矩阵，而是在assemble_rhs()中组装右手边。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::assemble_system() 
{ 
  TimerOutput::Scope timing(computing_timer, "Assemble"); 

  const QGauss<dim> quadrature_formula(degree + 1); 

  FEValues<dim> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_gradients | 
                            update_quadrature_points | update_JxW_values); 

  const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
  const unsigned int n_q_points    = quadrature_formula.size(); 

  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
  Vector<double>     cell_rhs(dofs_per_cell); 

  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

  const Coefficient<dim> coefficient; 
  RightHandSide<dim>     rhs; 
  std::vector<double>    rhs_values(n_q_points); 

  for (const auto &cell : dof_handler.active_cell_iterators()) 
    if (cell->is_locally_owned()) 
      { 
        cell_matrix = 0; 
        cell_rhs    = 0; 

        fe_values.reinit(cell); 

        const double coefficient_value = 
          coefficient.average_value(fe_values.get_quadrature_points()); 
        rhs.value_list(fe_values.get_quadrature_points(), rhs_values); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                cell_matrix(i, j) += 
                  coefficient_value *                // epsilon(x) 
                  fe_values.shape_grad(i, q_point) * // * grad phi_i(x) 
                  fe_values.shape_grad(j, q_point) * // * grad phi_j(x) 
                  fe_values.JxW(q_point);            // * dx 

              cell_rhs(i) += 
                fe_values.shape_value(i, q_point) * // grad phi_i(x) 
                rhs_values[q_point] *               // * f(x) 
                fe_values.JxW(q_point);             // * dx 
            } 

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global(cell_matrix, 
                                               cell_rhs, 
                                               local_dof_indices, 
                                               system_matrix, 
                                               right_hand_side); 
      } 

  system_matrix.compress(VectorOperation::add); 
  right_hand_side.compress(VectorOperation::add); 
} 
// @sect4{LaplaceProblem::assemble_multigrid()}  

// 下面的函数为基于矩阵的GMG方法组装和存储多级矩阵。这个函数与 step-16 中的函数类似，只是在这里它适用于分布式网格。这个区别在于增加了一个条件，即我们只在本地拥有的水平单元上进行组装，并为每个被建立的矩阵调用压缩（）。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::assemble_multigrid() 
{ 
  TimerOutput::Scope timing(computing_timer, "Assemble multigrid"); 

  QGauss<dim> quadrature_formula(degree + 1); 

  FEValues<dim> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_gradients | 
                            update_quadrature_points | update_JxW_values); 

  const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
  const unsigned int n_q_points    = quadrature_formula.size(); 

  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 

  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

  const Coefficient<dim> coefficient; 

  std::vector<AffineConstraints<double>> boundary_constraints( 
    triangulation.n_global_levels()); 
  for (unsigned int level = 0; level < triangulation.n_global_levels(); ++level) 
    { 
      IndexSet dof_set; 
      DoFTools::extract_locally_relevant_level_dofs(dof_handler, 
                                                    level, 
                                                    dof_set); 
      boundary_constraints[level].reinit(dof_set); 
      boundary_constraints[level].add_lines( 
        mg_constrained_dofs.get_refinement_edge_indices(level)); 
      boundary_constraints[level].add_lines( 
        mg_constrained_dofs.get_boundary_indices(level)); 

      boundary_constraints[level].close(); 
    } 

  for (const auto &cell : dof_handler.cell_iterators()) 
    if (cell->level_subdomain_id() == triangulation.locally_owned_subdomain()) 
      { 
        cell_matrix = 0; 
        fe_values.reinit(cell); 

        const double coefficient_value = 
          coefficient.average_value(fe_values.get_quadrature_points()); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              cell_matrix(i, j) += 
                coefficient_value * fe_values.shape_grad(i, q_point) * 
                fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point); 

        cell->get_mg_dof_indices(local_dof_indices); 

        boundary_constraints[cell->level()].distribute_local_to_global( 
          cell_matrix, local_dof_indices, mg_matrix[cell->level()]); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            if (mg_constrained_dofs.is_interface_matrix_entry( 
                  cell->level(), local_dof_indices[i], local_dof_indices[j])) 
              mg_interface_in[cell->level()].add(local_dof_indices[i], 
                                                 local_dof_indices[j], 
                                                 cell_matrix(i, j)); 
      } 

  for (unsigned int i = 0; i < triangulation.n_global_levels(); ++i) 
    { 
      mg_matrix[i].compress(VectorOperation::add); 
      mg_interface_in[i].compress(VectorOperation::add); 
    } 
} 

//  @sect4{LaplaceProblem::assemble_rhs()}  

// 这个三要素中的最后一个函数为无矩阵方法组装右手边的向量--因为在无矩阵框架中，我们不需要组装矩阵，只需要组装右手边就可以了。我们可以通过从上面的`assemble_system()`函数中提取处理右手边的代码来做到这一点，但是我们决定完全采用无矩阵的方法，也用这种方法进行装配。

// 结果是一个类似于 step-37 中 "使用 FEEvaluation::read_dof_values_plain() 来避免解决约束 "一节中的函数。

// 这个函数的原因是MatrixFree运算符不考虑非同质的Dirichlet约束，而是将所有的Dirichlet约束视为同质的。为了说明这一点，这里的右手边被组装成残差 $r_0 = f-Au_0$ ，其中 $u_0$ 是一个零向量，除了在Dirichlet值中。然后在求解的时候，我们可以看到，解决方案是  $u = u_0 + A^{-1}r_0$  。这可以看作是对初始猜测为  $u_0$  的线性系统进行的牛顿迭代。下面`solve()`函数中的CG解计算了 $A^{-1}r_0$ ，调用`constraints.distribution()`（直接在后面）增加了 $u_0$  。

// 显然，由于我们考虑的是一个零迪里希特边界的问题，我们可以采取类似于 step-37  `assemble_rhs()`的方法，但是这个额外的工作允许我们改变问题声明，如果我们选择的话。

// 这个函数在积分循环中有两个部分：通过提交梯度的负值将矩阵  $A$  的负值应用于  $u_0$  ，并通过提交值  $f$  添加右手边的贡献。我们必须确保使用`read_dof_values_plain()`来评估 $u_0$ ，因为`read_dof_vaues()`会将所有Dirichlet值设置为0。

// 最后，system_rhs向量的类型是 LA::MPI::Vector, ，但MatrixFree类只对 dealii::LinearAlgebra::distributed::Vector. 起作用，因此我们必须使用MatrixFree功能计算右手边，然后使用`ChangeVectorType`命名空间的函数将其复制到正确的类型。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::assemble_rhs() 
{ 
  TimerOutput::Scope timing(computing_timer, "Assemble right-hand side"); 

  MatrixFreeActiveVector solution_copy; 
  MatrixFreeActiveVector right_hand_side_copy; 
  mf_system_matrix.initialize_dof_vector(solution_copy); 
  mf_system_matrix.initialize_dof_vector(right_hand_side_copy); 

  solution_copy = 0.; 
  constraints.distribute(solution_copy); 
  solution_copy.update_ghost_values(); 
  right_hand_side_copy = 0; 
  const Table<2, VectorizedArray<double>> &coefficient = 
    *(mf_system_matrix.get_coefficient()); 

  RightHandSide<dim> right_hand_side_function; 

  FEEvaluation<dim, degree, degree + 1, 1, double> phi( 
    *mf_system_matrix.get_matrix_free()); 

  for (unsigned int cell = 0; 
       cell < mf_system_matrix.get_matrix_free()->n_cell_batches(); 
       ++cell) 
    { 
      phi.reinit(cell); 
      phi.read_dof_values_plain(solution_copy); 
      phi.evaluate(EvaluationFlags::gradients); 

      for (unsigned int q = 0; q < phi.n_q_points; ++q) 
        { 
          phi.submit_gradient(-1.0 * 
                                (coefficient(cell, 0) * phi.get_gradient(q)), 
                              q); 
          phi.submit_value( 
            right_hand_side_function.value(phi.quadrature_point(q)), q); 
        } 

      phi.integrate_scatter(EvaluationFlags::values | 
                              EvaluationFlags::gradients, 
                            right_hand_side_copy); 
    } 

  right_hand_side_copy.compress(VectorOperation::add); 

  ChangeVectorTypes::copy(right_hand_side, right_hand_side_copy); 
} 

//  @sect4{LaplaceProblem::solve()}  

// 这里我们设置了多网格预处理程序，测试了单个V型周期的时间，并解决了线性系统。不出所料，这是三种方法差别最大的地方之一。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::solve() 
{ 
  TimerOutput::Scope timing(computing_timer, "Solve"); 

  SolverControl solver_control(1000, 1.e-10 * right_hand_side.l2_norm()); 
  solver_control.enable_history_data(); 

  solution = 0.; 

// 无矩阵GMG方法的求解器类似于  step-37  ，除了增加一些接口矩阵，完全类似于  step-16  。

  switch (settings.solver) 
    { 
      case Settings::gmg_mf: 
        { 
          computing_timer.enter_subsection("Solve: Preconditioner setup"); 

          MGTransferMatrixFree<dim, float> mg_transfer(mg_constrained_dofs); 
          mg_transfer.build(dof_handler); 

          SolverControl coarse_solver_control(1000, 1e-12, false, false); 
          SolverCG<MatrixFreeLevelVector> coarse_solver(coarse_solver_control); 
          PreconditionIdentity            identity; 
          MGCoarseGridIterativeSolver<MatrixFreeLevelVector, 
                                      SolverCG<MatrixFreeLevelVector>, 
                                      MatrixFreeLevelMatrix, 
                                      PreconditionIdentity> 
            coarse_grid_solver(coarse_solver, mf_mg_matrix[0], identity); 

          using Smoother = dealii::PreconditionJacobi<MatrixFreeLevelMatrix>; 
          MGSmootherPrecondition<MatrixFreeLevelMatrix, 
                                 Smoother, 
                                 MatrixFreeLevelVector> 
            smoother; 
          smoother.initialize(mf_mg_matrix, 
                              typename Smoother::AdditionalData( 
                                settings.smoother_dampen)); 
          smoother.set_steps(settings.smoother_steps); 

          mg::Matrix<MatrixFreeLevelVector> mg_m(mf_mg_matrix); 

          MGLevelObject< 
            MatrixFreeOperators::MGInterfaceOperator<MatrixFreeLevelMatrix>> 
            mg_interface_matrices; 
          mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1); 
          for (unsigned int level = 0; level < triangulation.n_global_levels(); 
               ++level) 
            mg_interface_matrices[level].initialize(mf_mg_matrix[level]); 
          mg::Matrix<MatrixFreeLevelVector> mg_interface(mg_interface_matrices); 

          Multigrid<MatrixFreeLevelVector> mg( 
            mg_m, coarse_grid_solver, mg_transfer, smoother, smoother); 
          mg.set_edge_matrices(mg_interface, mg_interface); 

          PreconditionMG<dim, 
                         MatrixFreeLevelVector, 
                         MGTransferMatrixFree<dim, float>> 
            preconditioner(dof_handler, mg, mg_transfer); 

// 将求解向量和右手边从 LA::MPI::Vector 复制到 dealii::LinearAlgebra::distributed::Vector ，这样我们就可以解决了。

          MatrixFreeActiveVector solution_copy; 
          MatrixFreeActiveVector right_hand_side_copy; 
          mf_system_matrix.initialize_dof_vector(solution_copy); 
          mf_system_matrix.initialize_dof_vector(right_hand_side_copy); 

          ChangeVectorTypes::copy(solution_copy, solution); 
          ChangeVectorTypes::copy(right_hand_side_copy, right_hand_side); 
          computing_timer.leave_subsection("Solve: Preconditioner setup"); 

// 1个V型周期的时间安排。

          { 
            TimerOutput::Scope timing(computing_timer, 
                                      "Solve: 1 multigrid V-cycle"); 
            preconditioner.vmult(solution_copy, right_hand_side_copy); 
          } 
          solution_copy = 0.; 

// 解出线性系统，更新解的鬼魂值，复制回 LA::MPI::Vector 并分配约束。

          { 
            SolverCG<MatrixFreeActiveVector> solver(solver_control); 

            TimerOutput::Scope timing(computing_timer, "Solve: CG"); 
            solver.solve(mf_system_matrix, 
                         solution_copy, 
                         right_hand_side_copy, 
                         preconditioner); 
          } 

          solution_copy.update_ghost_values(); 
          ChangeVectorTypes::copy(solution, solution_copy); 
          constraints.distribute(solution); 

          break; 
        } 

// 基于矩阵的GMG方法的求解器，类似于  step-16  ，只是使用了雅可比平滑器，而不是SOR平滑器（该平滑器没有并行实现）。

      case Settings::gmg_mb: 
        { 
          computing_timer.enter_subsection("Solve: Preconditioner setup"); 

          MGTransferPrebuilt<VectorType> mg_transfer(mg_constrained_dofs); 
          mg_transfer.build(dof_handler); 

          SolverControl        coarse_solver_control(1000, 1e-12, false, false); 
          SolverCG<VectorType> coarse_solver(coarse_solver_control); 
          PreconditionIdentity identity; 
          MGCoarseGridIterativeSolver<VectorType, 
                                      SolverCG<VectorType>, 
                                      MatrixType, 
                                      PreconditionIdentity> 
            coarse_grid_solver(coarse_solver, mg_matrix[0], identity); 

          using Smoother = LA::MPI::PreconditionJacobi; 
          MGSmootherPrecondition<MatrixType, Smoother, VectorType> smoother; 

#ifdef USE_PETSC_LA 
          smoother.initialize(mg_matrix); 
          Assert( 
            settings.smoother_dampen == 1.0, 
            ExcNotImplemented( 
              "PETSc's PreconditionJacobi has no support for a damping parameter.")); 
#else 
          smoother.initialize(mg_matrix, settings.smoother_dampen); 
#endif 

          smoother.set_steps(settings.smoother_steps); 

          mg::Matrix<VectorType> mg_m(mg_matrix); 
          mg::Matrix<VectorType> mg_in(mg_interface_in); 
          mg::Matrix<VectorType> mg_out(mg_interface_in); 

          Multigrid<VectorType> mg( 
            mg_m, coarse_grid_solver, mg_transfer, smoother, smoother); 
          mg.set_edge_matrices(mg_out, mg_in); 

          PreconditionMG<dim, VectorType, MGTransferPrebuilt<VectorType>> 
            preconditioner(dof_handler, mg, mg_transfer); 

          computing_timer.leave_subsection("Solve: Preconditioner setup"); 

// 1个V型周期的计时。

          { 
            TimerOutput::Scope timing(computing_timer, 
                                      "Solve: 1 multigrid V-cycle"); 
            preconditioner.vmult(solution, right_hand_side); 
          } 
          solution = 0.; 

// 解决线性系统和分配约束。

          { 
            SolverCG<VectorType> solver(solver_control); 

            TimerOutput::Scope timing(computing_timer, "Solve: CG"); 
            solver.solve(system_matrix, 
                         solution, 
                         right_hand_side, 
                         preconditioner); 
          } 

          constraints.distribute(solution); 

 
        } 

// AMG方法的求解器，类似于  step-40  。

      case Settings::amg: 
        { 
          computing_timer.enter_subsection("Solve: Preconditioner setup"); 

          PreconditionAMG                 preconditioner; 
          PreconditionAMG::AdditionalData Amg_data; 

#ifdef USE_PETSC_LA 
          Amg_data.symmetric_operator = true; 
#else 
          Amg_data.elliptic              = true; 
          Amg_data.smoother_type         = "Jacobi"; 
          Amg_data.higher_order_elements = true; 
          Amg_data.smoother_sweeps       = settings.smoother_steps; 
          Amg_data.aggregation_threshold = 0.02; 
#endif 

          Amg_data.output_details = false; 

          preconditioner.initialize(system_matrix, Amg_data); 
          computing_timer.leave_subsection("Solve: Preconditioner setup"); 

// 1个V型周期的计时。

          { 
            TimerOutput::Scope timing(computing_timer, 
                                      "Solve: 1 multigrid V-cycle"); 
            preconditioner.vmult(solution, right_hand_side); 
          } 
          solution = 0.; 

// 解决线性系统和分配约束。

          { 
            SolverCG<VectorType> solver(solver_control); 

            TimerOutput::Scope timing(computing_timer, "Solve: CG"); 
            solver.solve(system_matrix, 
                         solution, 
                         right_hand_side, 
                         preconditioner); 
          } 
          constraints.distribute(solution); 

          break; 
        } 

      default: 
        Assert(false, ExcInternalError()); 
    } 

  pcout << "   Number of CG iterations:      " << solver_control.last_step() 
        << std::endl; 
} 
// @sect3{The error estimator}  

// 我们使用FEInterfaceValues类来组装一个误差估计器，以决定哪些单元需要细化。请看介绍中对单元和面积分的确切定义。为了使用该方法，我们为 MeshWorker::mesh_loop() 定义了Scratch和Copy对象，下面的大部分代码本质上与 step-12 中已经设置的一样（或者至少精神上相似）。

template <int dim> 
struct ScratchData 
{ 
  ScratchData(const Mapping<dim> &      mapping, 
              const FiniteElement<dim> &fe, 
              const unsigned int        quadrature_degree, 
              const UpdateFlags         update_flags, 
              const UpdateFlags         interface_update_flags) 
    : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags) 
    , fe_interface_values(mapping, 
                          fe, 
                          QGauss<dim - 1>(quadrature_degree), 
                          interface_update_flags) 
  {} 

  ScratchData(const ScratchData<dim> &scratch_data) 
    : fe_values(scratch_data.fe_values.get_mapping(), 
                scratch_data.fe_values.get_fe(), 
                scratch_data.fe_values.get_quadrature(), 
                scratch_data.fe_values.get_update_flags()) 
    , fe_interface_values(scratch_data.fe_values.get_mapping(), 
                          scratch_data.fe_values.get_fe(), 
                          scratch_data.fe_interface_values.get_quadrature(), 
                          scratch_data.fe_interface_values.get_update_flags()) 
  {} 

  FEValues<dim>          fe_values; 
  FEInterfaceValues<dim> fe_interface_values; 
}; 

struct CopyData 
{ 
  CopyData() 
    : cell_index(numbers::invalid_unsigned_int) 
    , value(0.) 
  {} 

  CopyData(const CopyData &) = default; 

  struct FaceData 
  { 
    unsigned int cell_indices[2]; 
    double       values[2]; 
  }; 

  unsigned int          cell_index; 
  double                value; 
  std::vector<FaceData> face_data; 
}; 

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::estimate() 
{ 
  TimerOutput::Scope timing(computing_timer, "Estimate"); 

  VectorType temp_solution; 
  temp_solution.reinit(locally_owned_dofs, 
                       locally_relevant_dofs, 
                       mpi_communicator); 
  temp_solution = solution; 

  const Coefficient<dim> coefficient; 

  estimated_error_square_per_cell.reinit(triangulation.n_active_cells()); 

  using Iterator = typename DoFHandler<dim>::active_cell_iterator; 

// 剩余单元的汇编程序  $h^2 \| f + \epsilon \triangle u \|_K^2$  。
  auto cell_worker = [&](const Iterator &  cell, 
                         ScratchData<dim> &scratch_data, 
                         CopyData &        copy_data) { 
    FEValues<dim> &fe_values = scratch_data.fe_values; 
    fe_values.reinit(cell); 

    RightHandSide<dim> rhs; 
    const double       rhs_value = rhs.value(cell->center()); 

    const double nu = coefficient.value(cell->center()); 

 
    fe_values.get_function_hessians(temp_solution, hessians); 

    copy_data.cell_index = cell->active_cell_index(); 

    double residual_norm_square = 0.; 
    for (unsigned k = 0; k < fe_values.n_quadrature_points; ++k) 
      { 
        const double residual = (rhs_value + nu * trace(hessians[k])); 
        residual_norm_square += residual * residual * fe_values.JxW(k); 
      } 

    copy_data.value = 
      cell->diameter() * cell->diameter() * residual_norm_square; 
  }; 

// 脸部术语的汇编器  $\sum_F h_F \| \jump{\epsilon \nabla u \cdot n} \|_F^2$  。
  auto face_worker = [&](const Iterator &    cell, 
                         const unsigned int &f, 
                         const unsigned int &sf, 
                         const Iterator &    ncell, 
                         const unsigned int &nf, 
                         const unsigned int &nsf, 
                         ScratchData<dim> &  scratch_data, 
                         CopyData &          copy_data) { 
    FEInterfaceValues<dim> &fe_interface_values = 
      scratch_data.fe_interface_values; 
    fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf); 

    copy_data.face_data.emplace_back(); 
    CopyData::FaceData &copy_data_face = copy_data.face_data.back(); 

    copy_data_face.cell_indices[0] = cell->active_cell_index(); 
    copy_data_face.cell_indices[1] = ncell->active_cell_index(); 

    const double coeff1 = coefficient.value(cell->center()); 
    const double coeff2 = coefficient.value(ncell->center()); 

    std::vector<Tensor<1, dim>> grad_u[2]; 

    for (unsigned int i = 0; i < 2; ++i) 
      { 
        grad_u[i].resize(fe_interface_values.n_quadrature_points); 
        fe_interface_values.get_fe_face_values(i).get_function_gradients( 
          temp_solution, grad_u[i]); 
      } 

    double jump_norm_square = 0.; 

    for (unsigned int qpoint = 0; 
         qpoint < fe_interface_values.n_quadrature_points; 
         ++qpoint) 
      { 
        const double jump = 
          coeff1 * grad_u[0][qpoint] * fe_interface_values.normal(qpoint) - 
          coeff2 * grad_u[1][qpoint] * fe_interface_values.normal(qpoint); 

        jump_norm_square += jump * jump * fe_interface_values.JxW(qpoint); 
      } 

    const double h           = cell->face(f)->measure(); 
    copy_data_face.values[0] = 0.5 * h * jump_norm_square; 
    copy_data_face.values[1] = copy_data_face.values[0]; 
  }; 

  auto copier = [&](const CopyData &copy_data) { 
    if (copy_data.cell_index != numbers::invalid_unsigned_int) 
      estimated_error_square_per_cell[copy_data.cell_index] += copy_data.value; 

    for (auto &cdf : copy_data.face_data) 
      for (unsigned int j = 0; j < 2; ++j) 
        estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j]; 
  }; 

  const unsigned int n_gauss_points = degree + 1; 
  ScratchData<dim>   scratch_data(mapping, 
                                fe, 
                                n_gauss_points, 
                                update_hessians | update_quadrature_points | 
                                  update_JxW_values, 
                                update_values | update_gradients | 
                                  update_JxW_values | update_normal_vectors); 
  CopyData           copy_data; 

// 我们需要对每个内部面进行一次装配，但我们需要确保两个进程都对本地拥有的单元和幽灵单元之间的面术语进行装配。这可以通过设置 MeshWorker::assemble_ghost_faces_both 标志来实现。我们需要这样做，因为我们不在这里交流误差估计器的贡献。

  MeshWorker::mesh_loop(dof_handler.begin_active(), 
                        dof_handler.end(), 
                        cell_worker, 
                        copier, 
                        scratch_data, 
                        copy_data, 
                        MeshWorker::assemble_own_cells | 
                          MeshWorker::assemble_ghost_faces_both | 
                          MeshWorker::assemble_own_interior_faces_once, 
                          /*boundary_worker=*/nullptr, face_worker);


 

  const double global_error_estimate = 
    std::sqrt(Utilities::MPI::sum(estimated_error_square_per_cell.l1_norm(), 
                                  mpi_communicator)); 
  pcout << "   Global error estimate:        " << global_error_estimate 
        << std::endl; 
} 
// @sect4{LaplaceProblem::refine_grid()}  

// 我们使用存储在向量 @p estimate_vector 中的单元估计器，并细化固定数量的单元（这里选择的是每一步中大约两倍的DoFs数量）。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::refine_grid() 
{ 
  TimerOutput::Scope timing(computing_timer, "Refine grid"); 

  const double refinement_fraction = 1. / (std::pow(2.0, dim) - 1.); 
  parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number( 
    triangulation, estimated_error_square_per_cell, refinement_fraction, 0.0); 

  triangulation.execute_coarsening_and_refinement(); 
} 
// @sect4{LaplaceProblem::output_results()}  

// output_results()函数与许多教程中的函数类似（例如，见 step-40 ）。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::output_results(const unsigned int cycle) 
{ 
  TimerOutput::Scope timing(computing_timer, "Output results"); 

  VectorType temp_solution; 
  temp_solution.reinit(locally_owned_dofs, 
                       locally_relevant_dofs, 
                       mpi_communicator); 
  temp_solution = solution; 

  DataOut<dim> data_out; 
  data_out.attach_dof_handler(dof_handler); 
  data_out.add_data_vector(temp_solution, "solution"); 

  Vector<float> subdomain(triangulation.n_active_cells()); 
  for (unsigned int i = 0; i < subdomain.size(); ++i) 
    subdomain(i) = triangulation.locally_owned_subdomain(); 
  data_out.add_data_vector(subdomain, "subdomain"); 

  Vector<float> level(triangulation.n_active_cells()); 
  for (const auto &cell : triangulation.active_cell_iterators()) 
    level(cell->active_cell_index()) = cell->level(); 
  data_out.add_data_vector(level, "level"); 

  if (estimated_error_square_per_cell.size() > 0) 
    data_out.add_data_vector(estimated_error_square_per_cell, 
                             "estimated_error_square_per_cell"); 

  data_out.build_patches(); 

  const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record( 
    "", "solution", cycle, mpi_communicator, 2 /*n_digits*/, 1 /*n_groups*/); 

  pcout << "   Wrote " << pvtu_filename << std::endl; 
} 
// @sect4{LaplaceProblem::run()}  

// 和大多数教程一样，这个函数调用上面定义的各种函数来设置、组合、求解和输出结果。

template <int dim, int degree> 
void LaplaceProblem<dim, degree>::run() 
{ 
  for (unsigned int cycle = 0; cycle < settings.n_steps; ++cycle) 
    { 
      pcout << "Cycle " << cycle << ':' << std::endl; 
      if (cycle > 0) 
        refine_grid(); 

      pcout << "   Number of active cells:       " 
            << triangulation.n_global_active_cells(); 

// 我们只为GMG方法输出层次单元数据（与下面的DoF数据相同）。请注意，对于AMG来说，分区效率是不相关的，因为在计算过程中没有分布或使用层次结构。

      if (settings.solver == Settings::gmg_mf || 
          settings.solver == Settings::gmg_mb) 
        pcout << " (" << triangulation.n_global_levels() << " global levels)" 
              << std::endl 
              << "   Partition efficiency:         " 
              << 1.0 / MGTools::workload_imbalance(triangulation); 
      pcout << std::endl; 

      setup_system(); 

// 只为GMG设置多级层次结构。

      if (settings.solver == Settings::gmg_mf || 
          settings.solver == Settings::gmg_mb) 
        setup_multigrid(); 

      pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs(); 
      if (settings.solver == Settings::gmg_mf || 
          settings.solver == Settings::gmg_mb) 
        { 
          pcout << " (by level: "; 
          for (unsigned int level = 0; level < triangulation.n_global_levels(); 
               ++level) 
            pcout << dof_handler.n_dofs(level) 
                  << (level == triangulation.n_global_levels() - 1 ? ")" : 
                                                                     ", "); 
        } 
      pcout << std::endl; 

// 对于无矩阵的方法，我们只组装右手边。对于这两种基于矩阵的方法，我们同时装配主动矩阵和右手边，对于基于矩阵的GMG，我们只装配多网格矩阵。

      if (settings.solver == Settings::gmg_mf) 
        assemble_rhs(); 
      else /*gmg_mb or amg*/ 
        { 
          assemble_system(); 
          if (settings.solver == Settings::gmg_mb) 
            assemble_multigrid(); 
        } 

      solve(); 
      estimate(); 

      if (settings.output) 
        output_results(cycle); 

      computing_timer.print_summary(); 
      computing_timer.reset(); 
    } 
} 
// @sect3{The main() function}  

// 这是一个类似于 step-40 的主函数，但我们要求用户传递一个.prm文件作为唯一的命令行参数（参见 step-29 和ParameterHandler类的文档，以了解关于参数文件的完整讨论）。

int main(int argc, char *argv[]) 
{ 
  using namespace dealii; 
  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

  Settings settings; 
  if (!settings.try_parse((argc > 1) ? (argv[1]) : "")) 
    return 0; 

  try 
    { 
      constexpr unsigned int fe_degree = 2; 

      switch (settings.dimension) 
        { 
          case 2: 
            { 
              LaplaceProblem<2, fe_degree> test(settings); 
              test.run(); 

              break; 
            } 

          case 3: 
            { 
              LaplaceProblem<3, fe_degree> test(settings); 
              test.run(); 

              break; 
            } 

          default: 
            Assert(false, ExcMessage("This program only works in 2d and 3d.")); 
        } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      MPI_Abort(MPI_COMM_WORLD, 1); 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      MPI_Abort(MPI_COMM_WORLD, 2); 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-51.cc


/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2013 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Martin Kronbichler, Technische Universität München, 
 *         Scott T. Miller, The Pennsylvania State University, 2013 
 */ 


// @sect3{Include files}  

// 大多数deal.II的include文件已经在前面的例子中涉及到了，没有注释。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/tensor_function.h> 
#include <deal.II/base/exceptions.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/work_stream.h> 
#include <deal.II/base/convergence_table.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_bicgstab.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

// 然而，我们确实有一些新的包括在这个例子中。第一个定义了三角形面的有限元空间，我们把它称为 "骨架"。这些有限元在元素内部没有任何支持，它们代表的是在每个模数一的表面上有一个单一的值的多项式，但在模数二的表面上允许有不连续。

#include <deal.II/fe/fe_face.h> 

// 我们包含的第二个新文件定义了一种新的稀疏矩阵类型。 常规的 <code>SparseMatrix</code> 类型存储了所有非零条目的索引。  <code>ChunkSparseMatrix</code> 则是利用了DG解的耦合性。 它存储了一个指定大小的矩阵子块的索引。 在HDG背景下，这个子块大小实际上是由骨架解场定义的每个面的自由度数量。这使得矩阵的内存消耗减少了三分之一，并且在求解器中使用矩阵时也会有类似的速度提升。

#include <deal.II/lac/chunk_sparse_matrix.h> 

// 这个例子的最后一个新的包括涉及到数据输出。 由于我们在网格的骨架上定义了一个有限元场，我们希望能够直观地看到这个解决方案的实际情况。DataOutFaces正是这样做的；它的接口与我们熟悉的DataOut几乎一样，但输出的数据只有模拟的二维1数据。

#include <deal.II/numerics/data_out_faces.h> 

#include <iostream> 

// 我们首先将所有的类放入自己的命名空间。

namespace Step51 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

//分析解的结构与 step-7 中相同。有两个例外情况。首先，我们也为3D情况创建了一个解决方案，其次，我们对解决方案进行了缩放，使其在解决方案的所有宽度值上的规范是统一的。

  template <int dim> 
  class SolutionBase 
  { 
  protected: 
    static const unsigned int n_source_centers = 3; 
    static const Point<dim>   source_centers[n_source_centers]; 
    static const double       width; 
  }; 

  template <> 
  const Point<1> 
    SolutionBase<1>::source_centers[SolutionBase<1>::n_source_centers] = 
      {Point<1>(-1.0 / 3.0), Point<1>(0.0), Point<1>(+1.0 / 3.0)}; 

  template <> 
  const Point<2> 
    SolutionBase<2>::source_centers[SolutionBase<2>::n_source_centers] = 
      {Point<2>(-0.5, +0.5), Point<2>(-0.5, -0.5), Point<2>(+0.5, -0.5)}; 

  template <> 
  const Point<3> 
    SolutionBase<3>::source_centers[SolutionBase<3>::n_source_centers] = { 
      Point<3>(-0.5, +0.5, 0.25), 
      Point<3>(-0.6, -0.5, -0.125), 
      Point<3>(+0.5, -0.5, 0.5)}; 

  template <int dim> 
  const double SolutionBase<dim>::width = 1. / 5.; 

  template <int dim> 
  class Solution : public Function<dim>, protected SolutionBase<dim> 
  { 
  public: 
    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      double sum = 0; 
      for (unsigned int i = 0; i < this->n_source_centers; ++i) 
        { 
          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i]; 
          sum += 
            std::exp(-x_minus_xi.norm_square() / (this->width * this->width)); 
        } 

      return sum / 
             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.); 
    } 

    virtual Tensor<1, dim> 
    gradient(const Point<dim> &p, 
             const unsigned int /*component*/ = 0) const override 
    { 
      Tensor<1, dim> sum; 
      for (unsigned int i = 0; i < this->n_source_centers; ++i) 
        { 
          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i]; 

          sum += 
            (-2 / (this->width * this->width) * 
             std::exp(-x_minus_xi.norm_square() / (this->width * this->width)) * 
             x_minus_xi); 
        } 

      return sum / 
             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.); 
    } 
  }; 

// 这个类实现了一个函数，标量解和它的负梯度被收集在一起。这个函数在计算HDG近似的误差时使用，它的实现是简单地调用Solution类的值和梯度函数。

  template <int dim> 
  class SolutionAndGradient : public Function<dim>, protected SolutionBase<dim> 
  { 
  public: 
    SolutionAndGradient() 
      : Function<dim>(dim + 1) 
    {} 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  v) const override 
    { 
      AssertDimension(v.size(), dim + 1); 
      Solution<dim>  solution; 
      Tensor<1, dim> grad = solution.gradient(p); 
      for (unsigned int d = 0; d < dim; ++d) 
        v[d] = -grad[d]; 
      v[dim] = solution.value(p); 
    } 
  }; 

// 接下来是对流速度的实现。如介绍中所述，我们选择的速度场在二维是 $(y, -x)$ ，在三维是 $(y, -x, 1)$ 。这就得到了一个无发散的速度场。

  template <int dim> 
  class ConvectionVelocity : public TensorFunction<1, dim> 
  { 
  public: 
    ConvectionVelocity() 
      : TensorFunction<1, dim>() 
    {} 

    virtual Tensor<1, dim> value(const Point<dim> &p) const override 
    { 
      Tensor<1, dim> convection; 
      switch (dim) 
        { 
          case 1: 
            convection[0] = 1; 
            break; 
          case 2: 
            convection[0] = p[1]; 
            convection[1] = -p[0]; 
            break; 
          case 3: 
            convection[0] = p[1]; 
            convection[1] = -p[0]; 
            convection[2] = 1; 
            break; 
          default: 
            Assert(false, ExcNotImplemented()); 
        } 
      return convection; 
    } 
  }; 

// 我们实现的最后一个函数是用于制造解决方案的右手边。它与 step-7 非常相似，不同的是我们现在有一个对流项而不是反应项。由于速度场是不可压缩的，即 $\nabla \cdot \mathbf{c} =0$ ，对流项简单读作  $\mathbf{c} \nabla u$  。

  template <int dim> 
  class RightHandSide : public Function<dim>, protected SolutionBase<dim> 
  { 
  public: 
    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      ConvectionVelocity<dim> convection_velocity; 
      Tensor<1, dim>          convection = convection_velocity.value(p); 
      double                  sum        = 0; 
      for (unsigned int i = 0; i < this->n_source_centers; ++i) 
        { 
          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i]; 

          sum += 
            ((2 * dim - 2 * convection * x_minus_xi - 
              4 * x_minus_xi.norm_square() / (this->width * this->width)) / 
             (this->width * this->width) * 
             std::exp(-x_minus_xi.norm_square() / (this->width * this->width))); 
        } 

      return sum / 
             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.); 
    } 
  }; 

//  @sect3{The HDG solver class}  

// HDG的求解过程与  step-7  的求解过程非常相似。主要区别在于使用了三套不同的DoFHandler和FE对象，以及ChunkSparseMatrix和相应的解决方案向量。我们还使用WorkStream来实现多线程的本地求解过程，该过程利用了本地求解器的尴尬的并行性质。对于WorkStream，我们定义了对单元格的本地操作和复制到全局矩阵和向量的函数。我们这样做既是为了装配（装配要运行两次，一次是在我们生成系统矩阵时，另一次是在我们从骨架值计算元素内部解时），也是为了后处理，在后处理中我们提取一个在高阶收敛的解。

  template <int dim> 
  class HDG 
  { 
  public: 
    enum RefinementMode 
    { 
      global_refinement, 
      adaptive_refinement 
    }; 

    HDG(const unsigned int degree, const RefinementMode refinement_mode); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(const bool reconstruct_trace = false); 
    void solve(); 
    void postprocess(); 
    void refine_grid(const unsigned int cycle); 
    void output_results(const unsigned int cycle); 

// 用于组装和解决原始变量的数据。

    struct PerTaskData; 
    struct ScratchData; 

// 对解决方案进行后处理以获得  $u^*$  是一个逐个元素的过程；因此，我们不需要组装任何全局数据，也不需要声明任何 "任务数据 "供WorkStream使用。

    struct PostProcessScratchData; 

// 以下三个函数被 WorkStream 用来完成程序的实际工作。

    void assemble_system_one_cell( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      ScratchData &                                         scratch, 
      PerTaskData &                                         task_data); 

    void copy_local_to_global(const PerTaskData &data); 

    void postprocess_one_cell( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      PostProcessScratchData &                              scratch, 
      unsigned int &                                        empty_data); 

    Triangulation<dim> triangulation; 

// "局部 "解是每个元素的内部。 这些代表了原始解场  $u$  以及辅助场  $\mathbf{q}$  。

    FESystem<dim>   fe_local; 
    DoFHandler<dim> dof_handler_local; 
    Vector<double>  solution_local; 

// 新的有限元类型和相应的 <code>DoFHandler</code> 被用于耦合元素级局部解的全局骨架解。

    FE_FaceQ<dim>   fe; 
    DoFHandler<dim> dof_handler; 
    Vector<double>  solution; 
    Vector<double>  system_rhs; 

// 如介绍中所述，HDG解可以通过后处理达到  $\mathcal{O}(h^{p+2})$  的超收敛率。 后处理的解是一个不连续的有限元解，代表每个单元内部的原始变量。 我们定义了一个程度为 $p+1$ 的FE类型来表示这个后处理的解，我们只在构造后用于输出。

    FE_DGQ<dim>     fe_u_post; 
    DoFHandler<dim> dof_handler_u_post; 
    Vector<double>  solution_u_post; 

// 与骨架相对应的自由度强烈地执行Dirichlet边界条件，就像在连续Galerkin有限元方法中一样。我们可以通过AffineConstraints对象以类似的方式强制执行边界条件。此外，悬挂节点的处理方式与连续有限元的处理方式相同。对于只在面定义自由度的面元素，这个过程将精炼面的解设置为与粗略面的表示相吻合。

// 请注意，对于HDG来说，消除悬空节点并不是唯一的可能性，就HDG理论而言，我们也可以使用精炼侧的未知数，通过精炼侧的跟踪值来表达粗略侧的局部解。然而，这样的设置在deal.II循环方面并不容易实现，因此没有进一步分析。

    AffineConstraints<double> constraints; 

// ChunkSparseMatrix类的用法与通常的稀疏矩阵类似。你需要一个ChunkSparsityPattern类型的稀疏模式和实际的矩阵对象。在创建稀疏模式时，我们只需要额外传递局部块的大小。

    ChunkSparsityPattern      sparsity_pattern; 
    ChunkSparseMatrix<double> system_matrix; 

// 与  step-7  相同。

    const RefinementMode refinement_mode; 
    ConvergenceTable     convergence_table; 
  }; 
// @sect3{The HDG class implementation}  
// @sect4{Constructor}  该构造函数与其他例子中的构造函数类似，除了处理多个DoFHandler和FiniteElement对象。请注意，我们为局部DG部分创建了一个有限元系统，包括梯度/通量部分和标量部分。

  template <int dim> 
  HDG<dim>::HDG(const unsigned int degree, const RefinementMode refinement_mode) 
    : fe_local(FE_DGQ<dim>(degree), dim, FE_DGQ<dim>(degree), 1) 
    , dof_handler_local(triangulation) 
    , fe(degree) 
    , dof_handler(triangulation) 
    , fe_u_post(degree + 1) 
    , dof_handler_u_post(triangulation) 
    , refinement_mode(refinement_mode) 
  {} 

//  @sect4{HDG::setup_system}  HDG解决方案的系统是以类似于其他大多数教程程序的方式设置的。 我们小心翼翼地用我们所有的DoFHandler对象来分配道夫。  @p solution 和 @p system_matrix 对象与全局骨架解决方案一起。

  template <int dim> 
  void HDG<dim>::setup_system() 
  { 
    dof_handler_local.distribute_dofs(fe_local); 
    dof_handler.distribute_dofs(fe); 
    dof_handler_u_post.distribute_dofs(fe_u_post); 

    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    solution_local.reinit(dof_handler_local.n_dofs()); 
    solution_u_post.reinit(dof_handler_u_post.n_dofs()); 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    std::map<types::boundary_id, const Function<dim> *> boundary_functions; 
    Solution<dim>                                       solution_function; 
    boundary_functions[0] = &solution_function; 
    VectorTools::project_boundary_values(dof_handler, 
                                         boundary_functions, 
                                         QGauss<dim - 1>(fe.degree + 1), 
                                         constraints); 
    constraints.close(); 

// 在创建块状稀疏模式时，我们首先创建通常的动态稀疏模式，然后设置块状大小，该大小等于一个面的道夫数，当把它复制到最终的稀疏模式时。

    { 
      DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
      DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); 
      sparsity_pattern.copy_from(dsp, fe.n_dofs_per_face()); 
    } 
    system_matrix.reinit(sparsity_pattern); 
  } 

//  @sect4{HDG::PerTaskData}  接下来是定义并行装配的本地数据结构。第一个结构 @p PerTaskData 包含了被写入全局矩阵的本地向量和矩阵，而ScratchData包含了我们在本地装配中需要的所有数据。这里有一个变量值得注意，即布尔变量 @p  trace_reconstruct。正如介绍中提到的，我们分两步解决HDG系统。首先，我们为骨架系统创建一个线性系统，通过舒尔补码 $D-CA^{-1}B$  将局部部分浓缩到其中。然后，我们用骨架的解来解决局部部分。对于这两个步骤，我们需要两次元素上的相同矩阵，我们希望通过两个装配步骤来计算。由于大部分的代码是相似的，我们用相同的函数来做这件事，但只是根据我们在开始装配时设置的一个标志在两者之间切换。因为我们需要把这个信息传递给本地的工作程序，所以我们把它存储在任务数据中一次。

  template <int dim> 
  struct HDG<dim>::PerTaskData 
  { 
    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_vector; 
    std::vector<types::global_dof_index> dof_indices; 

    bool trace_reconstruct; 

    PerTaskData(const unsigned int n_dofs, const bool trace_reconstruct) 
      : cell_matrix(n_dofs, n_dofs) 
      , cell_vector(n_dofs) 
      , dof_indices(n_dofs) 
      , trace_reconstruct(trace_reconstruct) 
    {} 
  }; 

//  @sect4{HDG::ScratchData}  
// @p ScratchData  包含WorkStream中每个线程的持久化数据。 FEValues、矩阵和矢量对象现在应该很熟悉了。 有两个对象需要讨论。  `std::vector<std::vector<unsigned  int> > fe_local_support_on_face` 和  `std::vector<std::vector<unsigned  int> > fe_support_on_face`。 这些用于指示所选择的有限元是否在与 @p fe_local 相关的局部部分和骨架部分 @p fe. 的参考单元的特定面上有支持（非零值）。 我们在构造函数中提取这一信息，并为我们工作的所有单元存储一次。 如果我们不存储这一信息，我们将被迫在每个单元上装配大量的零项，这将大大降低程序的速度。

  template <int dim> 
  struct HDG<dim>::ScratchData 
  { 
    FEValues<dim>     fe_values_local; 
    FEFaceValues<dim> fe_face_values_local; 
    FEFaceValues<dim> fe_face_values; 

    FullMatrix<double> ll_matrix; 
    FullMatrix<double> lf_matrix; 
    FullMatrix<double> fl_matrix; 
    FullMatrix<double> tmp_matrix; 
    Vector<double>     l_rhs; 
    Vector<double>     tmp_rhs; 

    std::vector<Tensor<1, dim>> q_phi; 
    std::vector<double>         q_phi_div; 
    std::vector<double>         u_phi; 
    std::vector<Tensor<1, dim>> u_phi_grad; 
    std::vector<double>         tr_phi; 
    std::vector<double>         trace_values; 

    std::vector<std::vector<unsigned int>> fe_local_support_on_face; 
    std::vector<std::vector<unsigned int>> fe_support_on_face; 

    ConvectionVelocity<dim> convection_velocity; 
    RightHandSide<dim>      right_hand_side; 
    const Solution<dim>     exact_solution; 

    ScratchData(const FiniteElement<dim> &fe, 
                const FiniteElement<dim> &fe_local, 
                const QGauss<dim> &       quadrature_formula, 
                const QGauss<dim - 1> &   face_quadrature_formula, 
                const UpdateFlags         local_flags, 
                const UpdateFlags         local_face_flags, 
                const UpdateFlags         flags) 
      : fe_values_local(fe_local, quadrature_formula, local_flags) 
      , fe_face_values_local(fe_local, 
                             face_quadrature_formula, 
                             local_face_flags) 
      , fe_face_values(fe, face_quadrature_formula, flags) 
      , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell()) 
      , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell()) 
      , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell()) 
      , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell()) 
      , l_rhs(fe_local.n_dofs_per_cell()) 
      , tmp_rhs(fe_local.n_dofs_per_cell()) 
      , q_phi(fe_local.n_dofs_per_cell()) 
      , q_phi_div(fe_local.n_dofs_per_cell()) 
      , u_phi(fe_local.n_dofs_per_cell()) 
      , u_phi_grad(fe_local.n_dofs_per_cell()) 
      , tr_phi(fe.n_dofs_per_cell()) 
      , trace_values(face_quadrature_formula.size()) 
      , fe_local_support_on_face(GeometryInfo<dim>::faces_per_cell) 
      , fe_support_on_face(GeometryInfo<dim>::faces_per_cell) 
      , exact_solution() 
    { 
      for (unsigned int face_no : GeometryInfo<dim>::face_indices()) 
        for (unsigned int i = 0; i < fe_local.n_dofs_per_cell(); ++i) 
          { 
            if (fe_local.has_support_on_face(i, face_no)) 
              fe_local_support_on_face[face_no].push_back(i); 
          } 

      for (unsigned int face_no : GeometryInfo<dim>::face_indices()) 
        for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i) 
          { 
            if (fe.has_support_on_face(i, face_no)) 
              fe_support_on_face[face_no].push_back(i); 
          } 
    } 

    ScratchData(const ScratchData &sd) 
      : fe_values_local(sd.fe_values_local.get_fe(), 
                        sd.fe_values_local.get_quadrature(), 
                        sd.fe_values_local.get_update_flags()) 
      , fe_face_values_local(sd.fe_face_values_local.get_fe(), 
                             sd.fe_face_values_local.get_quadrature(), 
                             sd.fe_face_values_local.get_update_flags()) 
      , fe_face_values(sd.fe_face_values.get_fe(), 
                       sd.fe_face_values.get_quadrature(), 
                       sd.fe_face_values.get_update_flags()) 
      , ll_matrix(sd.ll_matrix) 
      , lf_matrix(sd.lf_matrix) 
      , fl_matrix(sd.fl_matrix) 
      , tmp_matrix(sd.tmp_matrix) 
      , l_rhs(sd.l_rhs) 
      , tmp_rhs(sd.tmp_rhs) 
      , q_phi(sd.q_phi) 
      , q_phi_div(sd.q_phi_div) 
      , u_phi(sd.u_phi) 
      , u_phi_grad(sd.u_phi_grad) 
      , tr_phi(sd.tr_phi) 
      , trace_values(sd.trace_values) 
      , fe_local_support_on_face(sd.fe_local_support_on_face) 
      , fe_support_on_face(sd.fe_support_on_face) 
      , exact_solution() 
    {} 
  }; 

//  @sect4{HDG::PostProcessScratchData}  
// @p PostProcessScratchData  包含WorkStream在对本地解决方案进行后处理时使用的数据  $u^*$  。 它与  @p ScratchData.  类似，但要简单得多。
  template <int dim> 
  struct HDG<dim>::PostProcessScratchData 
  { 
    FEValues<dim> fe_values_local; 
    FEValues<dim> fe_values; 

    std::vector<double>         u_values; 
    std::vector<Tensor<1, dim>> u_gradients; 
    FullMatrix<double>          cell_matrix; 

    Vector<double> cell_rhs; 
    Vector<double> cell_sol; 

    PostProcessScratchData(const FiniteElement<dim> &fe, 
                           const FiniteElement<dim> &fe_local, 
                           const QGauss<dim> &       quadrature_formula, 
                           const UpdateFlags         local_flags, 
                           const UpdateFlags         flags) 
      : fe_values_local(fe_local, quadrature_formula, local_flags) 
      , fe_values(fe, quadrature_formula, flags) 
      , u_values(quadrature_formula.size()) 
      , u_gradients(quadrature_formula.size()) 
      , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell()) 
      , cell_rhs(fe.n_dofs_per_cell()) 
      , cell_sol(fe.n_dofs_per_cell()) 
    {} 

    PostProcessScratchData(const PostProcessScratchData &sd) 
      : fe_values_local(sd.fe_values_local.get_fe(), 
                        sd.fe_values_local.get_quadrature(), 
                        sd.fe_values_local.get_update_flags()) 
      , fe_values(sd.fe_values.get_fe(), 
                  sd.fe_values.get_quadrature(), 
                  sd.fe_values.get_update_flags()) 
      , u_values(sd.u_values) 
      , u_gradients(sd.u_gradients) 
      , cell_matrix(sd.cell_matrix) 
      , cell_rhs(sd.cell_rhs) 
      , cell_sol(sd.cell_sol) 
    {} 
  }; 

//  @sect4{HDG::assemble_system}   @p assemble_system 函数与 Step-32 上的函数类似，其中正交公式和更新标志被设置，然后 <code>WorkStream</code> 被用来以多线程的方式进行工作。  @p trace_reconstruct  输入参数用于决定我们是求全局骨架解（false）还是局部解（true）。

// 对于汇编的多线程执行，有一点值得注意的是，`assemble_system_one_cell()`中的局部计算会调用BLAS和LAPACK函数，如果这些函数在deal.II中可用。因此，底层的BLAS/LAPACK库必须支持同时来自多个线程的调用。大多数实现都支持这一点，但有些库需要以特定方式构建以避免问题。例如，在BLAS/LAPACK调用内部没有多线程的情况下编译的OpenBLAS需要在构建时将一个名为`USE_LOCKING'的标志设置为true。

  template <int dim> 
  void HDG<dim>::assemble_system(const bool trace_reconstruct) 
  { 
    const QGauss<dim>     quadrature_formula(fe.degree + 1); 
    const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1); 

    const UpdateFlags local_flags(update_values | update_gradients | 
                                  update_JxW_values | update_quadrature_points); 

    const UpdateFlags local_face_flags(update_values); 

    const UpdateFlags flags(update_values | update_normal_vectors | 
                            update_quadrature_points | update_JxW_values); 

    PerTaskData task_data(fe.n_dofs_per_cell(), trace_reconstruct); 
    ScratchData scratch(fe, 
                        fe_local, 
                        quadrature_formula, 
                        face_quadrature_formula, 
                        local_flags, 
                        local_face_flags, 
                        flags); 

    WorkStream::run(dof_handler.begin_active(), 
                    dof_handler.end(), 
                    *this, 
                    &HDG<dim>::assemble_system_one_cell, 
                    &HDG<dim>::copy_local_to_global, 
                    scratch, 
                    task_data); 
  } 

//  @sect4{HDG::assemble_system_one_cell}  HDG程序的实际工作由  @p assemble_system_one_cell.  组装局部矩阵  $A, B, C$  在这里完成，同时还有全局矩阵的局部贡献  $D$  。

  template <int dim> 
  void HDG<dim>::assemble_system_one_cell( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    ScratchData &                                         scratch, 
    PerTaskData &                                         task_data) 
  { 

//为Dof_handler_local构建迭代器，用于FEValues的reinit函数。

    typename DoFHandler<dim>::active_cell_iterator loc_cell(&triangulation, 
                                                            cell->level(), 
                                                            cell->index(), 
                                                            &dof_handler_local); 

    const unsigned int n_q_points = 
      scratch.fe_values_local.get_quadrature().size(); 
    const unsigned int n_face_q_points = 
      scratch.fe_face_values_local.get_quadrature().size(); 

    const unsigned int loc_dofs_per_cell = 
      scratch.fe_values_local.get_fe().n_dofs_per_cell(); 

    const FEValuesExtractors::Vector fluxes(0); 
    const FEValuesExtractors::Scalar scalar(dim); 

    scratch.ll_matrix = 0; 
    scratch.l_rhs     = 0; 
    if (!task_data.trace_reconstruct) 
      { 
        scratch.lf_matrix     = 0; 
        scratch.fl_matrix     = 0; 
        task_data.cell_matrix = 0; 
        task_data.cell_vector = 0; 
      } 
    scratch.fe_values_local.reinit(loc_cell); 

// 我们首先计算对应于局部-局部耦合的 @p ll_matrix 矩阵（在介绍中称为矩阵 $A$ ）的单元内部贡献，以及局部右手向量。 我们在每个正交点存储基函数、右手边值和对流速度的值，以便快速访问这些场。

    for (unsigned int q = 0; q < n_q_points; ++q) 
      { 
        const double rhs_value = scratch.right_hand_side.value( 
          scratch.fe_values_local.quadrature_point(q)); 
        const Tensor<1, dim> convection = scratch.convection_velocity.value( 
          scratch.fe_values_local.quadrature_point(q)); 
        const double JxW = scratch.fe_values_local.JxW(q); 
        for (unsigned int k = 0; k < loc_dofs_per_cell; ++k) 
          { 
            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q); 
            scratch.q_phi_div[k] = 
              scratch.fe_values_local[fluxes].divergence(k, q); 
            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q); 
            scratch.u_phi_grad[k] = 
              scratch.fe_values_local[scalar].gradient(k, q); 
          } 
        for (unsigned int i = 0; i < loc_dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < loc_dofs_per_cell; ++j) 
              scratch.ll_matrix(i, j) += 
                (scratch.q_phi[i] * scratch.q_phi[j] - 
                 scratch.q_phi_div[i] * scratch.u_phi[j] + 
                 scratch.u_phi[i] * scratch.q_phi_div[j] - 
                 (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) * 
                JxW; 
            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW; 
          } 
      } 

// 脸部条款是在所有元素的所有面上集合起来的。这与更传统的DG方法相反，在组装过程中，每个面只被访问一次。

    for (const auto face_no : cell->face_indices()) 
      { 
        scratch.fe_face_values_local.reinit(loc_cell, face_no); 
        scratch.fe_face_values.reinit(cell, face_no); 

// 在求解局部变量时需要已经得到的  $\hat{u}$  值。

        if (task_data.trace_reconstruct) 
          scratch.fe_face_values.get_function_values(solution, 
                                                     scratch.trace_values); 

        for (unsigned int q = 0; q < n_face_q_points; ++q) 
          { 
            const double     JxW = scratch.fe_face_values.JxW(q); 
            const Point<dim> quadrature_point = 
              scratch.fe_face_values.quadrature_point(q); 
            const Tensor<1, dim> normal = 
              scratch.fe_face_values.normal_vector(q); 
            const Tensor<1, dim> convection = 
              scratch.convection_velocity.value(quadrature_point); 

// 这里我们计算介绍中讨论的稳定参数：由于扩散是1，并且扩散长度尺度被设定为1/5，它只是导致扩散部分的贡献为5，而对流部分的贡献是通过元素边界的居中方案中的对流大小。

            const double tau_stab = (5. + std::abs(convection * normal)); 

// 我们存储非零通量和标量值，利用我们在 @p ScratchData. 中创建的 support_on_face 信息。
            for (unsigned int k = 0; 
                 k < scratch.fe_local_support_on_face[face_no].size(); 
                 ++k) 
              { 
                const unsigned int kk = 
                  scratch.fe_local_support_on_face[face_no][k]; 
                scratch.q_phi[k] = 
                  scratch.fe_face_values_local[fluxes].value(kk, q); 
                scratch.u_phi[k] = 
                  scratch.fe_face_values_local[scalar].value(kk, q); 
              } 

// 当  @p trace_reconstruct=false,  我们准备为骨架变量  $\hat{u}$  组装系统。如果是这种情况，我们必须组装所有与问题相关的局部矩阵：局部-局部、局部-面部、面部-局部和面部-面部。 面-面矩阵被存储为 @p TaskData::cell_matrix, ，这样就可以通过 @p copy_local_to_global将其组装到全局系统中。

            if (!task_data.trace_reconstruct) 
              { 
                for (unsigned int k = 0; 
                     k < scratch.fe_support_on_face[face_no].size(); 
                     ++k) 
                  scratch.tr_phi[k] = scratch.fe_face_values.shape_value( 
                    scratch.fe_support_on_face[face_no][k], q); 
                for (unsigned int i = 0; 
                     i < scratch.fe_local_support_on_face[face_no].size(); 
                     ++i) 
                  for (unsigned int j = 0; 
                       j < scratch.fe_support_on_face[face_no].size(); 
                       ++j) 
                    { 
                      const unsigned int ii = 
                        scratch.fe_local_support_on_face[face_no][i]; 
                      const unsigned int jj = 
                        scratch.fe_support_on_face[face_no][j]; 
                      scratch.lf_matrix(ii, jj) += 
                        ((scratch.q_phi[i] * normal + 
                          (convection * normal - tau_stab) * scratch.u_phi[i]) * 
                         scratch.tr_phi[j]) * 
                        JxW; 

// 注意face_no-local矩阵的符号。 我们在组装时否定了这个符号，这样我们就可以在计算舒尔补时使用 FullMatrix::mmult 的加法。

                      scratch.fl_matrix(jj, ii) -= 
                        ((scratch.q_phi[i] * normal + 
                          tau_stab * scratch.u_phi[i]) * 
                         scratch.tr_phi[j]) * 
                        JxW; 
                    } 

                for (unsigned int i = 0; 
                     i < scratch.fe_support_on_face[face_no].size(); 
                     ++i) 
                  for (unsigned int j = 0; 
                       j < scratch.fe_support_on_face[face_no].size(); 
                       ++j) 
                    { 
                      const unsigned int ii = 
                        scratch.fe_support_on_face[face_no][i]; 
                      const unsigned int jj = 
                        scratch.fe_support_on_face[face_no][j]; 
                      task_data.cell_matrix(ii, jj) += 
                        ((convection * normal - tau_stab) * scratch.tr_phi[i] * 
                         scratch.tr_phi[j]) * 
                        JxW; 
                    } 

                if (cell->face(face_no)->at_boundary() && 
                    (cell->face(face_no)->boundary_id() == 1)) 
                  { 
                    const double neumann_value = 
                      -scratch.exact_solution.gradient(quadrature_point) * 
                        normal + 
                      convection * normal * 
                        scratch.exact_solution.value(quadrature_point); 
                    for (unsigned int i = 0; 
                         i < scratch.fe_support_on_face[face_no].size(); 
                         ++i) 
                      { 
                        const unsigned int ii = 
                          scratch.fe_support_on_face[face_no][i]; 
                        task_data.cell_vector(ii) += 
                          scratch.tr_phi[i] * neumann_value * JxW; 
                      } 
                  } 
              } 

// 这最后一个项将 $\left<w,\tau u_h\right>_{\partial \mathcal T}$ 项的贡献加入到本地矩阵中。相对于上面的脸部矩阵，我们在两个装配阶段都需要它。

            for (unsigned int i = 0; 
                 i < scratch.fe_local_support_on_face[face_no].size(); 
                 ++i) 
              for (unsigned int j = 0; 
                   j < scratch.fe_local_support_on_face[face_no].size(); 
                   ++j) 
                { 
                  const unsigned int ii = 
                    scratch.fe_local_support_on_face[face_no][i]; 
                  const unsigned int jj = 
                    scratch.fe_local_support_on_face[face_no][j]; 
                  scratch.ll_matrix(ii, jj) += 
                    tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW; 
                } 

// 当 @p trace_reconstruct=true, 时，我们在逐个元素的基础上求解局部解。 局部右手边的计算是通过用计算值 @p trace_values替换 @p 计算中的基函数 @p tr_phi。 当然，现在矩阵的符号是减号，因为我们已经把所有的东西移到了方程的另一边。

            if (task_data.trace_reconstruct) 
              for (unsigned int i = 0; 
                   i < scratch.fe_local_support_on_face[face_no].size(); 
                   ++i) 
                { 
                  const unsigned int ii = 
                    scratch.fe_local_support_on_face[face_no][i]; 
                  scratch.l_rhs(ii) -= 
                    (scratch.q_phi[i] * normal + 
                     scratch.u_phi[i] * (convection * normal - tau_stab)) * 
                    scratch.trace_values[q] * JxW; 
                } 
          } 
      } 

// 一旦完成所有局部贡献的组装，我们必须：（1）组装全局系统；（2）计算局部贡献。(1)组装全局系统，或者(2)计算局部解值并保存。无论哪种情况，第一步都是对局部-局部矩阵进行反转。

    scratch.ll_matrix.gauss_jordan(); 

// 对于(1)，我们计算舒尔补码，并将其添加到 @p  cell_matrix，介绍中的矩阵 $D$ 。

    if (task_data.trace_reconstruct == false) 
      { 
        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix); 
        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs); 
        scratch.tmp_matrix.mmult(task_data.cell_matrix, 
                                 scratch.lf_matrix, 
                                 true); 
        cell->get_dof_indices(task_data.dof_indices); 
      } 

// 对于(2)，我们只是求解(ll_matrix). (solution_local) = (l_rhs)。因此，我们用 @p l_rhs 乘以我们已经倒置的局部-局部矩阵，并用 <code>set_dof_values</code> 函数来存储结果。

    else 
      { 
        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs); 
        loc_cell->set_dof_values(scratch.tmp_rhs, solution_local); 
      } 
  } 

// 如果我们处于解题的第一步，即 @sect4{HDG::copy_local_to_global} ，那么我们就把局部矩阵组装到全局系统中。

  template <int dim> 
  void HDG<dim>::copy_local_to_global(const PerTaskData &data) 
  { 
    if (data.trace_reconstruct == false) 
      constraints.distribute_local_to_global(data.cell_matrix, 
                                             data.cell_vector, 
                                             data.dof_indices, 
                                             system_matrix, 
                                             system_rhs); 
  } 

//  @sect4{HDG::solve}  骨架解是通过使用带有身份预处理程序的BiCGStab求解器来解决的。

  template <int dim> 
  void HDG<dim>::solve() 
  { 
    SolverControl                  solver_control(system_matrix.m() * 10, 
                                 1e-11 * system_rhs.l2_norm()); 
    SolverBicgstab<Vector<double>> solver(solver_control); 
    solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity()); 

    std::cout << "   Number of BiCGStab iterations: " 
              << solver_control.last_step() << std::endl; 

    system_matrix.clear(); 
    sparsity_pattern.reinit(0, 0, 0, 1); 

    constraints.distribute(solution); 

// 一旦我们求出了骨架解，我们就可以以逐个元素的方式求出局部解。 我们通过重新使用相同的 @p assemble_system 函数来做到这一点，但将 @p trace_reconstruct 切换为真。

    assemble_system(true); 
  } 

//  @sect4{HDG::postprocess}  

// 后处理方法有两个目的。首先，我们要在度数为 $p+1$ 的元素空间中构造一个后处理的标量变量，我们希望它能在阶 $p+2$ 上收敛。这也是一个逐个元素的过程，只涉及标量解以及局部单元上的梯度。为了做到这一点，我们引入了已经定义好的从头开始的数据以及一些更新标志，并运行工作流来并行地完成这一工作。

// 第二，我们要计算离散化误差，就像我们在  step-7  中做的那样。整个过程与调用 VectorTools::integrate_difference. 相似，区别在于我们如何计算标量变量和梯度变量的误差。在 step-7 中，我们通过计算 @p L2_norm 或 @p H1_seminorm 的贡献来做到这一点。在这里，我们有一个DoFHandler，计算了这两个贡献，并按其矢量分量排序， <code>[0, dim)</code> 为梯度， @p dim 为标量。为了计算它们的值，我们用一个ComponentSelectFunction来计算它们中的任何一个，再加上上面介绍的 @p SolutionAndGradient类，它包含了它们中任何一个的分析部分。最终，我们还计算了后处理的解决方案的L2-误差，并将结果添加到收敛表中。

  template <int dim> 
  void HDG<dim>::postprocess() 
  { 
    { 
      const QGauss<dim> quadrature_formula(fe_u_post.degree + 1); 
      const UpdateFlags local_flags(update_values); 
      const UpdateFlags flags(update_values | update_gradients | 
                              update_JxW_values); 

      PostProcessScratchData scratch( 
        fe_u_post, fe_local, quadrature_formula, local_flags, flags); 

      WorkStream::run( 
        dof_handler_u_post.begin_active(), 
        dof_handler_u_post.end(), 
        [this](const typename DoFHandler<dim>::active_cell_iterator &cell, 
               PostProcessScratchData &                              scratch, 
               unsigned int &                                        data) { 
          this->postprocess_one_cell(cell, scratch, data); 
        }, 
        std::function<void(const unsigned int &)>(), 
        scratch, 
        0U); 
    } 

    Vector<float> difference_per_cell(triangulation.n_active_cells()); 

    ComponentSelectFunction<dim> value_select(dim, dim + 1); 
    VectorTools::integrate_difference(dof_handler_local, 
                                      solution_local, 
                                      SolutionAndGradient<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(fe.degree + 2), 
                                      VectorTools::L2_norm, 
                                      &value_select); 
    const double L2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

    ComponentSelectFunction<dim> gradient_select( 
      std::pair<unsigned int, unsigned int>(0, dim), dim + 1); 
    VectorTools::integrate_difference(dof_handler_local, 
                                      solution_local, 
                                      SolutionAndGradient<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(fe.degree + 2), 
                                      VectorTools::L2_norm, 
                                      &gradient_select); 
    const double grad_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

    VectorTools::integrate_difference(dof_handler_u_post, 
                                      solution_u_post, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(fe.degree + 3), 
                                      VectorTools::L2_norm); 
    const double post_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

    convergence_table.add_value("cells", triangulation.n_active_cells()); 
    convergence_table.add_value("dofs", dof_handler.n_dofs()); 

    convergence_table.add_value("val L2", L2_error); 
    convergence_table.set_scientific("val L2", true); 
    convergence_table.set_precision("val L2", 3); 

    convergence_table.add_value("grad L2", grad_error); 
    convergence_table.set_scientific("grad L2", true); 
    convergence_table.set_precision("grad L2", 3); 

    convergence_table.add_value("val L2-post", post_error); 
    convergence_table.set_scientific("val L2-post", true); 
    convergence_table.set_precision("val L2-post", 3); 
  } 

//  @sect4{HDG::postprocess_one_cell}  

// 这是为后处理所做的实际工作。根据介绍中的讨论，我们需要建立一个系统，将DG解的梯度部分投影到后处理变量的梯度上。此外，我们还需要将新的后处理变量的平均值设置为等于标量DG解在单元上的平均值。

// 从技术上讲，梯度的投影是一个有可能填满我们的 @p dofs_per_cell 乘以 @p dofs_per_cell 矩阵的系统，但它是单数（所有行的总和为零，因为常数函数的梯度为零）。因此，我们拿掉一行，用它来强加标量值的平均值。我们为标量部分挑选第一行，尽管我们可以为 $\mathcal Q_{-p}$ 元素挑选任何一行。然而，如果我们使用FE_DGP元素，第一行将对应常数部分，删除例如最后一行将得到一个奇异系统。这样一来，我们的程序也可以用于这些元素。

  template <int dim> 
  void HDG<dim>::postprocess_one_cell( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    PostProcessScratchData &                              scratch, 
    unsigned int &) 
  { 
    typename DoFHandler<dim>::active_cell_iterator loc_cell(&triangulation, 
                                                            cell->level(), 
                                                            cell->index(), 
                                                            &dof_handler_local); 

    scratch.fe_values_local.reinit(loc_cell); 
    scratch.fe_values.reinit(cell); 

    FEValuesExtractors::Vector fluxes(0); 
    FEValuesExtractors::Scalar scalar(dim); 

    const unsigned int n_q_points = scratch.fe_values.get_quadrature().size(); 
    const unsigned int dofs_per_cell = scratch.fe_values.dofs_per_cell; 

    scratch.fe_values_local[scalar].get_function_values(solution_local, 
                                                        scratch.u_values); 
    scratch.fe_values_local[fluxes].get_function_values(solution_local, 
                                                        scratch.u_gradients); 

    double sum = 0; 
    for (unsigned int i = 1; i < dofs_per_cell; ++i) 
      { 
        for (unsigned int j = 0; j < dofs_per_cell; ++j) 
          { 
            sum = 0; 
            for (unsigned int q = 0; q < n_q_points; ++q) 
              sum += (scratch.fe_values.shape_grad(i, q) * 
                      scratch.fe_values.shape_grad(j, q)) * 
                     scratch.fe_values.JxW(q); 
            scratch.cell_matrix(i, j) = sum; 
          } 

        sum = 0; 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) * 
                 scratch.fe_values.JxW(q); 
        scratch.cell_rhs(i) = sum; 
      } 
    for (unsigned int j = 0; j < dofs_per_cell; ++j) 
      { 
        sum = 0; 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q); 
        scratch.cell_matrix(0, j) = sum; 
      } 
    { 
      sum = 0; 
      for (unsigned int q = 0; q < n_q_points; ++q) 
        sum += scratch.u_values[q] * scratch.fe_values.JxW(q); 
      scratch.cell_rhs(0) = sum; 
    } 

// 集合了所有条款后，我们又可以继续解决这个线性系统。我们对矩阵进行反转，然后将反转结果乘以右手边。另一种方法（数字上更稳定）是只对矩阵进行因式分解，然后应用因式分解。

    scratch.cell_matrix.gauss_jordan(); 
    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs); 
    cell->distribute_local_to_global(scratch.cell_sol, solution_u_post); 
  } 

//  @sect4{HDG::output_results}  我们有三组我们想输出的结果：局部解决方案，后处理的局部解决方案，以及骨架解决方案。前两个结果都 "活 "在元素体积上，而后者则活在三角形的一维表面上。 我们的 @p output_results 函数将所有的局部解决方案写入同一个vtk文件，尽管它们对应于不同的DoFHandler对象。 骨架变量的图形输出是通过使用DataOutFaces类完成的。

  template <int dim> 
  void HDG<dim>::output_results(const unsigned int cycle) 
  { 
    std::string filename; 
    switch (refinement_mode) 
      { 
        case global_refinement: 
          filename = "solution-global"; 
          break; 
        case adaptive_refinement: 
          filename = "solution-adaptive"; 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    std::string face_out(filename); 
    face_out += "-face"; 

    filename += "-q" + Utilities::int_to_string(fe.degree, 1); 
    filename += "-" + Utilities::int_to_string(cycle, 2); 
    filename += ".vtk"; 
    std::ofstream output(filename); 

    DataOut<dim> data_out; 

// 我们首先定义本地解决方案的名称和类型，并将数据添加到  @p data_out.  中。
    std::vector<std::string> names(dim, "gradient"); 
    names.emplace_back("solution"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      component_interpretation( 
        dim + 1, DataComponentInterpretation::component_is_part_of_vector); 
    component_interpretation[dim] = 
      DataComponentInterpretation::component_is_scalar; 
    data_out.add_data_vector(dof_handler_local, 
                             solution_local, 
                             names, 
                             component_interpretation); 

// 我们添加的第二个数据项是后处理的解决方案。在这种情况下，它是一个属于不同DoFHandler的单一标量变量。

    std::vector<std::string> post_name(1, "u_post"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      post_comp_type(1, DataComponentInterpretation::component_is_scalar); 
    data_out.add_data_vector(dof_handler_u_post, 
                             solution_u_post, 
                             post_name, 
                             post_comp_type); 

    data_out.build_patches(fe.degree); 
    data_out.write_vtk(output); 

    face_out += "-q" + Utilities::int_to_string(fe.degree, 1); 
    face_out += "-" + Utilities::int_to_string(cycle, 2); 
    face_out += ".vtk"; 
    std::ofstream face_output(face_out); 

//  <code>DataOutFaces</code> 类的工作原理与 <code>DataOut</code> class when we have a <code>DoFHandler</code> 类似，后者定义了三角形骨架上的解决方案。 我们在此将其视为如此，代码与上面类似。

    DataOutFaces<dim>        data_out_face(false); 
    std::vector<std::string> face_name(1, "u_hat"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      face_component_type(1, DataComponentInterpretation::component_is_scalar); 

    data_out_face.add_data_vector(dof_handler, 
                                  solution, 
                                  face_name, 
                                  face_component_type); 

    data_out_face.build_patches(fe.degree); 
    data_out_face.write_vtk(face_output); 
  } 
// @sect4{HDG::refine_grid}  

// 我们为HDG实现了两种不同的细化情况，就像在 <code>Step-7</code> 中一样：adaptive_refinement和global_refinement。 global_refinement选项每次都会重新创建整个三角形。这是因为我们想使用比一个细化步骤更细的网格序列，即每个方向2、3、4、6、8、12、16...个元素。

// adaptive_refinement模式使用 <code>KellyErrorEstimator</code> 对标量局部解中的非规则区域给出一个体面的指示。

  template <int dim> 
  void HDG<dim>::refine_grid(const unsigned int cycle) 
  { 
    if (cycle == 0) 
      { 
        GridGenerator::subdivided_hyper_cube(triangulation, 2, -1, 1); 
        triangulation.refine_global(3 - dim); 
      } 
    else 
      switch (refinement_mode) 
        { 
          case global_refinement: 
            { 
              triangulation.clear(); 
              GridGenerator::subdivided_hyper_cube(triangulation, 
                                                   2 + (cycle % 2), 
                                                   -1, 
                                                   1); 
              triangulation.refine_global(3 - dim + cycle / 2); 
              break; 
            } 

          case adaptive_refinement: 
            { 
              Vector<float> estimated_error_per_cell( 
                triangulation.n_active_cells()); 

              FEValuesExtractors::Scalar scalar(dim); 
              std::map<types::boundary_id, const Function<dim> *> 
                neumann_boundary; 
              KellyErrorEstimator<dim>::estimate(dof_handler_local, 
                                                 QGauss<dim - 1>(fe.degree + 1), 
                                                 neumann_boundary, 
                                                 solution_local, 
                                                 estimated_error_per_cell, 
                                                 fe_local.component_mask( 
                                                   scalar)); 

              GridRefinement::refine_and_coarsen_fixed_number( 
                triangulation, estimated_error_per_cell, 0.3, 0.); 

              triangulation.execute_coarsening_and_refinement(); 

              break; 
            } 

          default: 
            { 
              Assert(false, ExcNotImplemented()); 
            } 
        } 

// 就像在 step-7 中一样，我们将其中两个面的边界指标设置为1，在这里我们要指定诺伊曼边界条件而不是迪里希特条件。由于我们每次都会为全局细化重新创建三角形，所以在每个细化步骤中都会设置标志，而不仅仅是在开始时。

    for (const auto &cell : triangulation.cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->at_boundary()) 
          if ((std::fabs(face->center()(0) - (-1)) < 1e-12) || 
              (std::fabs(face->center()(1) - (-1)) < 1e-12)) 
            face->set_boundary_id(1); 
  } 
// @sect4{HDG::run}  这里的功能与 <code>Step-7</code>  基本相同。我们在10个周期中循环，在每个周期中细化网格。 在最后，收敛表被创建。

  template <int dim> 
  void HDG<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 10; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << ':' << std::endl; 

        refine_grid(cycle); 
        setup_system(); 
        assemble_system(false); 
        solve(); 
        postprocess(); 
        output_results(cycle); 
      } 

// 与 step-7 相比，收敛表有一个微小的变化：由于我们没有在每个周期内以2的系数细化我们的网格（而是使用2，3，4，6，8，12，...的序列），我们需要告诉收敛率评估这一点。我们通过设置单元格数量作为参考列，并额外指定问题的维度来实现这一目的，这为单元格数量和网格大小之间的关系提供了必要的信息。

    if (refinement_mode == global_refinement) 
      { 
        convergence_table.evaluate_convergence_rates( 
          "val L2", "cells", ConvergenceTable::reduction_rate_log2, dim); 
        convergence_table.evaluate_convergence_rates( 
          "grad L2", "cells", ConvergenceTable::reduction_rate_log2, dim); 
        convergence_table.evaluate_convergence_rates( 
          "val L2-post", "cells", ConvergenceTable::reduction_rate_log2, dim); 
      } 
    convergence_table.write_text(std::cout); 
  } 

} // end of namespace Step51 

int main() 
{ 
  const unsigned int dim = 2; 

  try 
    { 

// 现在是对主类的三次调用，完全类似于  step-7  。

      { 
        std::cout << "Solving with Q1 elements, adaptive refinement" 
                  << std::endl 
                  << "=============================================" 
                  << std::endl 
                  << std::endl; 

        Step51::HDG<dim> hdg_problem(1, Step51::HDG<dim>::adaptive_refinement); 
        hdg_problem.run(); 

        std::cout << std::endl; 
      } 

      { 
        std::cout << "Solving with Q1 elements, global refinement" << std::endl 
                  << "===========================================" << std::endl 
                  << std::endl; 

        Step51::HDG<dim> hdg_problem(1, Step51::HDG<dim>::global_refinement); 
        hdg_problem.run(); 

        std::cout << std::endl; 
      } 

      { 
        std::cout << "Solving with Q3 elements, global refinement" << std::endl 
                  << "===========================================" << std::endl 
                  << std::endl; 

        Step51::HDG<dim> hdg_problem(3, Step51::HDG<dim>::global_refinement); 
        hdg_problem.run(); 

        std::cout << std::endl; 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-52.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2014 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014 
 */ 


// @sect3{Include files}  

// 像往常一样，第一个任务是包括这些著名的deal.II库文件和一些C++头文件的功能。

#include <deal.II/base/discrete_time.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/quadrature_lib.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_out.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/sparse_direct.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iostream> 
#include <cmath> 
#include <map> 

// 这是唯一一个新的包含文件：它包括所有的Runge-Kutta方法。

#include <deal.II/base/time_stepping.h> 

// 接下来的步骤与之前所有的教程程序一样。我们把所有的东西放到一个自己的命名空间中，然后把deal.II的类和函数导入其中。

namespace Step52 
{ 
  using namespace dealii; 
// @sect3{The <code>Diffusion</code> class}  

// 下一块是主类的声明。这个类中的大部分函数并不新鲜，在以前的教程中已经解释过了。唯一有趣的函数是  <code>evaluate_diffusion()</code>  和  <code>id_minus_tau_J_inverse()</code>. <code>evaluate_diffusion()</code>  评估扩散方程，  $M^{-1}(f(t,y))$  ，在一个给定的时间和一个给定的  $y$  。  <code>id_minus_tau_J_inverse()</code>  在给定的时间和给定的 $\tau$ 和 $y$ 下，评估 $\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}$ 或类似的 $\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M$ 。当使用隐式方法时，就需要这个函数。

  class Diffusion 
  { 
  public: 
    Diffusion(); 

    void run(); 

  private: 
    void setup_system(); 

    void assemble_system(); 

    double get_source(const double time, const Point<2> &point) const; 

    Vector<double> evaluate_diffusion(const double          time, 
                                      const Vector<double> &y) const; 

    Vector<double> id_minus_tau_J_inverse(const double          time, 
                                          const double          tau, 
                                          const Vector<double> &y); 

    void output_results(const double                     time, 
                        const unsigned int               time_step, 
                        TimeStepping::runge_kutta_method method) const; 

// 接下来的三个函数分别是显式方法、隐式方法和嵌入式显式方法的驱动。嵌入显式方法的驱动函数返回执行的步数，鉴于它只接受作为参数传递的时间步数作为提示，但内部计算了最佳时间步数本身。

    void explicit_method(const TimeStepping::runge_kutta_method method, 
                         const unsigned int                     n_time_steps, 
                         const double                           initial_time, 
                         const double                           final_time); 

    void implicit_method(const TimeStepping::runge_kutta_method method, 
                         const unsigned int                     n_time_steps, 
                         const double                           initial_time, 
                         const double                           final_time); 

    unsigned int 
    embedded_explicit_method(const TimeStepping::runge_kutta_method method, 
                             const unsigned int n_time_steps, 
                             const double       initial_time, 
                             const double       final_time); 

    const unsigned int fe_degree; 

    const double diffusion_coefficient; 
    const double absorption_cross_section; 

    Triangulation<2> triangulation; 

    const FE_Q<2> fe; 

    DoFHandler<2> dof_handler; 

    AffineConstraints<double> constraint_matrix; 

    SparsityPattern sparsity_pattern; 

    SparseMatrix<double> system_matrix; 
    SparseMatrix<double> mass_matrix; 
    SparseMatrix<double> mass_minus_tau_Jacobian; 

    SparseDirectUMFPACK inverse_mass_matrix; 

    Vector<double> solution; 
  }; 

// 我们选择二次方有限元，并初始化参数。

  Diffusion::Diffusion() 
    : fe_degree(2) 
    , diffusion_coefficient(1. / 30.) 
    , absorption_cross_section(1.) 
    , fe(fe_degree) 
    , dof_handler(triangulation) 
  {} 

// 现在，我们创建约束矩阵和稀疏模式。然后，我们初始化这些矩阵和求解向量。

  void Diffusion::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 

    VectorTools::interpolate_boundary_values(dof_handler, 
                                             1, 
                                             Functions::ZeroFunction<2>(), 
                                             constraint_matrix); 
    constraint_matrix.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraint_matrix); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
    mass_matrix.reinit(sparsity_pattern); 
    mass_minus_tau_Jacobian.reinit(sparsity_pattern); 
    solution.reinit(dof_handler.n_dofs()); 
  } 

//  @sect4{<code>Diffusion::assemble_system</code>}  在这个函数中，我们计算  $-\int D \nabla b_i \cdot \nabla b_j d\boldsymbol{r} - \int \Sigma_a b_i b_j d\boldsymbol{r}$  和质量矩阵  $\int b_i b_j d\boldsymbol{r}$  。然后使用直接求解器对质量矩阵进行反演；然后 <code>inverse_mass_matrix</code> 变量将存储质量矩阵的反值，这样 $M^{-1}$ 就可以使用该对象的 <code>vmult()</code> 函数应用于一个矢量。在内部，UMFPACK并没有真正存储矩阵的逆，而是存储它的LU因子；应用矩阵的逆相当于用这两个因子做一次正解和一次逆解，这与应用矩阵的显式逆具有相同的复杂性）。

  void Diffusion::assemble_system() 
  { 
    system_matrix = 0.; 
    mass_matrix   = 0.; 

    const QGauss<2> quadrature_formula(fe_degree + 1); 

    FEValues<2> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_gradients | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix      = 0.; 
        cell_mass_matrix = 0.; 

        fe_values.reinit(cell); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              { 
                cell_matrix(i, j) += 
                  ((-diffusion_coefficient *                // (-D 
                      fe_values.shape_grad(i, q_point) *    //  * grad phi_i 
                      fe_values.shape_grad(j, q_point)      //  * grad phi_j 
                    - absorption_cross_section *            //  -Sigma 
                        fe_values.shape_value(i, q_point) * //  * phi_i 
                        fe_values.shape_value(j, q_point))  //  * phi_j) 
                   * fe_values.JxW(q_point));               // * dx 
                cell_mass_matrix(i, j) += fe_values.shape_value(i, q_point) * 
                                          fe_values.shape_value(j, q_point) * 
                                          fe_values.JxW(q_point); 
              } 

        cell->get_dof_indices(local_dof_indices); 

        constraint_matrix.distribute_local_to_global(cell_matrix, 
                                                     local_dof_indices, 
                                                     system_matrix); 
        constraint_matrix.distribute_local_to_global(cell_mass_matrix, 
                                                     local_dof_indices, 
                                                     mass_matrix); 
      } 

    inverse_mass_matrix.initialize(mass_matrix); 
  } 

//  @sect4{<code>Diffusion::get_source</code>}  

// 在这个函数中，计算出特定时间和特定点的方程的源项。

  double Diffusion::get_source(const double time, const Point<2> &point) const 
  { 
    const double intensity = 10.; 
    const double frequency = numbers::PI / 10.; 
    const double b         = 5.; 
    const double x         = point(0); 

    return intensity * 
           (frequency * std::cos(frequency * time) * (b * x - x * x) + 
            std::sin(frequency * time) * 
              (absorption_cross_section * (b * x - x * x) + 
               2. * diffusion_coefficient)); 
  } 

//  @sect4{<code>Diffusion::evaluate_diffusion</code>}  

// 接下来，我们在给定的时间  $t$  和给定的矢量  $y$  评价扩散方程的弱形式。换句话说，正如介绍中所述，我们评估  $M^{-1}(-{\cal D}y - {\cal A}y + {\cal S})$  。为此，我们必须将矩阵 $-{\cal D} - {\cal A}$ （之前计算并存储在变量 <code>system_matrix</code> 中）应用于 $y$ ，然后添加源项，我们像通常那样进行积分。(如果你想节省几行代码，或者想利用并行积分的优势，可以用 VectorTools::create_right_hand_side() 来进行积分。) 然后将结果乘以 $M^{-1}$  。

  Vector<double> Diffusion::evaluate_diffusion(const double          time, 
                                               const Vector<double> &y) const 
  { 
    Vector<double> tmp(dof_handler.n_dofs()); 
    tmp = 0.; 
    system_matrix.vmult(tmp, y); 

    const QGauss<2> quadrature_formula(fe_degree + 1); 

    FEValues<2> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_quadrature_points | 
                            update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double> cell_source(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_source = 0.; 

        fe_values.reinit(cell); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          { 
            const double source = 
              get_source(time, fe_values.quadrature_point(q_point)); 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_source(i) += fe_values.shape_value(i, q_point) * // phi_i(x) 
                                source *                            // * S(x) 
                                fe_values.JxW(q_point);             // * dx 
          } 

        cell->get_dof_indices(local_dof_indices); 

        constraint_matrix.distribute_local_to_global(cell_source, 
                                                     local_dof_indices, 
                                                     tmp); 
      } 

    Vector<double> value(dof_handler.n_dofs()); 
    inverse_mass_matrix.vmult(value, tmp); 

    return value; 
  } 
// @sect4{<code>Diffusion::id_minus_tau_J_inverse</code>}  

// 我们计算  $\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M$  。这要分几个步骤进行。 

// - 计算  $M-\tau \frac{\partial f}{\partial y}$  。  

// - 反转矩阵，得到  $\left(M-\tau \frac{\partial f} {\partial y}\right)^{-1}$  。  

// --计算 $tmp=My$ 。  

// --计算 $z=\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} tmp =  \left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} My$ 。  

// - 返回z。

  Vector<double> Diffusion::id_minus_tau_J_inverse(const double /*time*/, 
                                                   const double          tau, 
                                                   const Vector<double> &y) 
  { 
    SparseDirectUMFPACK inverse_mass_minus_tau_Jacobian; 

    mass_minus_tau_Jacobian.copy_from(mass_matrix); 
    mass_minus_tau_Jacobian.add(-tau, system_matrix); 

    inverse_mass_minus_tau_Jacobian.initialize(mass_minus_tau_Jacobian); 

    Vector<double> tmp(dof_handler.n_dofs()); 
    mass_matrix.vmult(tmp, y); 

    Vector<double> result(y); 
    inverse_mass_minus_tau_Jacobian.vmult(result, tmp); 

    return result; 
  } 

//  @sect4{<code>Diffusion::output_results</code>}  

// 下面的函数将解决方案以vtu文件的形式输出，并以时间步长和时间步长方法的名称为索引。当然，所有时间步长方法的（精确）结果应该是一样的，但这里的输出至少可以让我们对它们进行比较。

  void Diffusion::output_results(const double                     time, 
                                 const unsigned int               time_step, 
                                 TimeStepping::runge_kutta_method method) const 
  { 
    std::string method_name; 

    switch (method) 
      { 
        case TimeStepping::FORWARD_EULER: 
          { 
            method_name = "forward_euler"; 
            break; 
          } 
        case TimeStepping::RK_THIRD_ORDER: 
          { 
            method_name = "rk3"; 
            break; 
          } 
        case TimeStepping::RK_CLASSIC_FOURTH_ORDER: 
          { 
            method_name = "rk4"; 
            break; 
          } 
        case TimeStepping::BACKWARD_EULER: 
          { 
            method_name = "backward_euler"; 
            break; 
          } 
        case TimeStepping::IMPLICIT_MIDPOINT: 
          { 
            method_name = "implicit_midpoint"; 
            break; 
          } 
        case TimeStepping::SDIRK_TWO_STAGES: 
          { 
            method_name = "sdirk"; 
            break; 
          } 
        case TimeStepping::HEUN_EULER: 
          { 
            method_name = "heun_euler"; 
            break; 
          } 
        case TimeStepping::BOGACKI_SHAMPINE: 
          { 
            method_name = "bocacki_shampine"; 
            break; 
          } 
        case TimeStepping::DOPRI: 
          { 
            method_name = "dopri"; 
            break; 
          } 
        case TimeStepping::FEHLBERG: 
          { 
            method_name = "fehlberg"; 
            break; 
          } 
        case TimeStepping::CASH_KARP: 
          { 
            method_name = "cash_karp"; 
            break; 
          } 
        default: 
          { 
            break; 
          } 
      } 

    DataOut<2> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 

    data_out.build_patches(); 

    data_out.set_flags(DataOutBase::VtkFlags(time, time_step)); 

    const std::string filename = "solution_" + method_name + "-" + 
                                 Utilities::int_to_string(time_step, 3) + 
                                 ".vtu"; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 

    static std::vector<std::pair<double, std::string>> times_and_names; 

    static std::string method_name_prev = ""; 
    static std::string pvd_filename; 
    if (method_name_prev != method_name) 
      { 
        times_and_names.clear(); 
        method_name_prev = method_name; 
        pvd_filename     = "solution_" + method_name + ".pvd"; 
      } 
    times_and_names.emplace_back(time, filename); 
    std::ofstream pvd_output(pvd_filename); 
    DataOutBase::write_pvd_record(pvd_output, times_and_names); 
  } 
// @sect4{<code>Diffusion::explicit_method</code>}  

// 这个函数是所有显式方法的驱动。在顶部，它初始化了时间步长和解决方案（通过将其设置为零，然后确保边界值和悬挂节点约束得到尊重；当然，对于我们在这里使用的网格，悬挂节点约束实际上不是一个问题）。然后调用 <code>evolve_one_time_step</code> ，执行一个时间步骤。时间是通过DiscreteTime对象来存储和增加的。

// 对于显式方法， <code>evolve_one_time_step</code> 需要评估 $M^{-1}(f(t,y))$ ，也就是说，它需要 <code>evaluate_diffusion</code>  。因为 <code>evaluate_diffusion</code> 是一个成员函数，它需要被绑定到 <code>this</code> 。在每个进化步骤之后，我们再次应用正确的边界值和悬挂节点约束。

// 最后，每隔10个时间步骤就会输出解决方案。

  void Diffusion::explicit_method(const TimeStepping::runge_kutta_method method, 
                                  const unsigned int n_time_steps, 
                                  const double       initial_time, 
                                  const double       final_time) 
  { 
    const double time_step = 
      (final_time - initial_time) / static_cast<double>(n_time_steps); 

    solution = 0.; 
    constraint_matrix.distribute(solution); 

    TimeStepping::ExplicitRungeKutta<Vector<double>> explicit_runge_kutta( 
      method); 
    output_results(initial_time, 0, method); 
    DiscreteTime time(initial_time, final_time, time_step); 
    while (time.is_at_end() == false) 
      { 
        explicit_runge_kutta.evolve_one_time_step( 
          [this](const double time, const Vector<double> &y) { 
            return this->evaluate_diffusion(time, y); 
          }, 
          time.get_current_time(), 
          time.get_next_step_size(), 
          solution); 
        time.advance_time(); 

        constraint_matrix.distribute(solution); 

        if (time.get_step_number() % 10 == 0) 
          output_results(time.get_current_time(), 
                         time.get_step_number(), 
                         method); 
      } 
  } 

//  @sect4{<code>Diffusion::implicit_method</code>}  这个函数等同于 <code>explicit_method</code> ，但用于隐式方法。当使用隐式方法时，我们需要评估 $M^{-1}(f(t,y))$ 和 $\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}$ ，为此我们使用之前介绍的两个成员函数。

  void Diffusion::implicit_method(const TimeStepping::runge_kutta_method method, 
                                  const unsigned int n_time_steps, 
                                  const double       initial_time, 
                                  const double       final_time) 
  { 
    const double time_step = 
      (final_time - initial_time) / static_cast<double>(n_time_steps); 

    solution = 0.; 
    constraint_matrix.distribute(solution); 

    TimeStepping::ImplicitRungeKutta<Vector<double>> implicit_runge_kutta( 
      method); 
    output_results(initial_time, 0, method); 
    DiscreteTime time(initial_time, final_time, time_step); 
    while (time.is_at_end() == false) 
      { 
        implicit_runge_kutta.evolve_one_time_step( 
          [this](const double time, const Vector<double> &y) { 
            return this->evaluate_diffusion(time, y); 
          }, 
          [this](const double time, const double tau, const Vector<double> &y) { 
            return this->id_minus_tau_J_inverse(time, tau, y); 
          }, 
          time.get_current_time(), 
          time.get_next_step_size(), 
          solution); 
        time.advance_time(); 

        constraint_matrix.distribute(solution); 

        if (time.get_step_number() % 10 == 0) 
          output_results(time.get_current_time(), 
                         time.get_step_number(), 
                         method); 
      } 
  } 

//  @sect4{<code>Diffusion::embedded_explicit_method</code>}  这个函数是嵌入式显式方法的驱动。它需要更多的参数。 

// - coarsen_param：当误差低于阈值时，乘以当前时间步长的系数。 

// - refine_param: 当误差高于阈值时，乘以当前时间步长的系数。 

// - min_delta: 可接受的最小时间步长。 

// - max_delta: 可接受的最大时间步长。 

// - refine_tol：时间步长超过的阈值。 

// - coarsen_tol：阈值，低于该阈值的时间步长将被粗化。

// 嵌入方法使用一个猜测的时间步长。如果使用这个时间步长的误差太大，时间步长将被缩小。如果误差低于阈值，则在下一个时间步长时将尝试更大的时间步长。  <code>delta_t_guess</code> 是由嵌入式方法产生的猜测的时间步长。总之，时间步长有可能以三种方式修改。 

// - 在 TimeStepping::EmbeddedExplicitRungeKutta::evolve_one_time_step(). 内减少或增加时间步长。  

// - 使用计算出的  <code>delta_t_guess</code>  。 

// - 自动调整最后一个时间步长，以确保模拟在  <code>final_time</code>  处精确结束。这种调整是在DiscreteTime实例中处理的。

  unsigned int Diffusion::embedded_explicit_method( 
    const TimeStepping::runge_kutta_method method, 
    const unsigned int                     n_time_steps, 
    const double                           initial_time, 
    const double                           final_time) 
  { 
    const double time_step = 
      (final_time - initial_time) / static_cast<double>(n_time_steps); 
    const double coarsen_param = 1.2; 
    const double refine_param  = 0.8; 
    const double min_delta     = 1e-8; 
    const double max_delta     = 10 * time_step; 
    const double refine_tol    = 1e-1; 
    const double coarsen_tol   = 1e-5; 

    solution = 0.; 
    constraint_matrix.distribute(solution); 

    TimeStepping::EmbeddedExplicitRungeKutta<Vector<double>> 
      embedded_explicit_runge_kutta(method, 
                                    coarsen_param, 
                                    refine_param, 
                                    min_delta, 
                                    max_delta, 
                                    refine_tol, 
                                    coarsen_tol); 
    output_results(initial_time, 0, method); 
    DiscreteTime time(initial_time, final_time, time_step); 
    while (time.is_at_end() == false) 
      { 
        const double new_time = 
          embedded_explicit_runge_kutta.evolve_one_time_step( 
            [this](const double time, const Vector<double> &y) { 
              return this->evaluate_diffusion(time, y); 
            }, 
            time.get_current_time(), 
            time.get_next_step_size(), 
            solution); 
        time.set_next_step_size(new_time - time.get_current_time()); 
        time.advance_time(); 

        constraint_matrix.distribute(solution); 

        if (time.get_step_number() % 10 == 0) 
          output_results(time.get_current_time(), 
                         time.get_step_number(), 
                         method); 

        time.set_desired_next_step_size( 
          embedded_explicit_runge_kutta.get_status().delta_t_guess); 
      } 

    return time.get_step_number(); 
  } 

//  @sect4{<code>Diffusion::run</code>}  

// 下面是该程序的主要功能。在顶部，我们创建网格（一个[0,5]x[0,5]的正方形）并对其进行四次细化，得到一个有16乘16单元的网格，共256个。 然后我们将边界指示器设置为1，用于边界中 $x=0$ 和 $x=5$ 的部分。

  void Diffusion::run() 
  { 
    GridGenerator::hyper_cube(triangulation, 0., 5.); 
    triangulation.refine_global(4); 

    for (const auto &cell : triangulation.active_cell_iterators()) 
      for (const auto &face : cell->face_iterators()) 
        if (face->at_boundary()) 
          { 
            if ((face->center()[0] == 0.) || (face->center()[0] == 5.)) 
              face->set_boundary_id(1); 
            else 
              face->set_boundary_id(0); 
          } 

// 接下来，我们设置线性系统并为其填充内容，以便在整个时间步进过程中使用它们。

    setup_system(); 

    assemble_system(); 

// 最后，我们使用命名空间TimeStepping中实现的几种Runge-Kutta方法来解决扩散问题，每次都会在结束时输出误差。(正如介绍中所解释的，由于精确解在最后时间为零，所以误差等于数值解，只需取解向量的 $l_2$ 准则即可计算出来。)

    unsigned int       n_steps      = 0; 
    const unsigned int n_time_steps = 200; 
    const double       initial_time = 0.; 
    const double       final_time   = 10.; 

    std::cout << "Explicit methods:" << std::endl; 
    explicit_method(TimeStepping::FORWARD_EULER, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   Forward Euler:            error=" << solution.l2_norm() 
              << std::endl; 

    explicit_method(TimeStepping::RK_THIRD_ORDER, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   Third order Runge-Kutta:  error=" << solution.l2_norm() 
              << std::endl; 

    explicit_method(TimeStepping::RK_CLASSIC_FOURTH_ORDER, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   Fourth order Runge-Kutta: error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << std::endl; 

    std::cout << "Implicit methods:" << std::endl; 
    implicit_method(TimeStepping::BACKWARD_EULER, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   Backward Euler:           error=" << solution.l2_norm() 
              << std::endl; 

    implicit_method(TimeStepping::IMPLICIT_MIDPOINT, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   Implicit Midpoint:        error=" << solution.l2_norm() 
              << std::endl; 

    implicit_method(TimeStepping::CRANK_NICOLSON, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   Crank-Nicolson:           error=" << solution.l2_norm() 
              << std::endl; 

    implicit_method(TimeStepping::SDIRK_TWO_STAGES, 
                    n_time_steps, 
                    initial_time, 
                    final_time); 
    std::cout << "   SDIRK:                    error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << std::endl; 

    std::cout << "Embedded explicit methods:" << std::endl; 
    n_steps = embedded_explicit_method(TimeStepping::HEUN_EULER, 
                                       n_time_steps, 
                                       initial_time, 
                                       final_time); 
    std::cout << "   Heun-Euler:               error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << "                   steps performed=" << n_steps << std::endl; 

    n_steps = embedded_explicit_method(TimeStepping::BOGACKI_SHAMPINE, 
                                       n_time_steps, 
                                       initial_time, 
                                       final_time); 
    std::cout << "   Bogacki-Shampine:         error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << "                   steps performed=" << n_steps << std::endl; 

    n_steps = embedded_explicit_method(TimeStepping::DOPRI, 
                                       n_time_steps, 
                                       initial_time, 
                                       final_time); 
    std::cout << "   Dopri:                    error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << "                   steps performed=" << n_steps << std::endl; 

    n_steps = embedded_explicit_method(TimeStepping::FEHLBERG, 
                                       n_time_steps, 
                                       initial_time, 
                                       final_time); 
    std::cout << "   Fehlberg:                 error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << "                   steps performed=" << n_steps << std::endl; 

    n_steps = embedded_explicit_method(TimeStepping::CASH_KARP, 
                                       n_time_steps, 
                                       initial_time, 
                                       final_time); 
    std::cout << "   Cash-Karp:                error=" << solution.l2_norm() 
              << std::endl; 
    std::cout << "                   steps performed=" << n_steps << std::endl; 
  } 
} // namespace Step52 

//  @sect3{The <code>main()</code> function}  

// 下面的 <code>main</code> 函数与前面的例子类似，不需要注释。

int main() 
{ 
  try 
    { 
      Step52::Diffusion diffusion; 
      diffusion.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 

  return 0; 
} 


CCTest_file/step-53.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2014 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Wolfgang Bangerth, Texas A&M University, 2014 
 *          Luca Heltai, SISSA, 2014 
 *          D. Sarah Stamps, MIT, 2014 
 */ 



// 让我们从这里需要的包含文件开始。显然，我们需要描述三角形的文件（  <code>tria.h</code>  ），以及允许我们创建和输出三角形的文件（  <code>grid_generator.h</code>  和  <code>grid_out.h</code>  ）。此外，我们需要声明Manifold和ChartManifold类的头文件，我们将需要这些类来描述几何体（ <code>manifold.h</code> ）。然后我们还需要以下头文件中的 GridTools::transform() 函数；这个函数的用途将在我们使用它时讨论。

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/manifold.h> 
#include <deal.II/grid/grid_tools.h> 

// 其余的包含文件与读取地形数据有关。正如介绍中所解释的，我们将从一个文件中读取它，然后使用下面头文件中第一个声明的 Functions::InterpolatedUniformGridData  类。因为数据很大，所以我们读取的文件是以gzip压缩数据的形式存储的，我们利用BOOST提供的一些功能来直接读取gzipped数据。

#include <deal.II/base/function_lib.h> 

#include <boost/iostreams/filtering_stream.hpp> 
#include <boost/iostreams/filter/gzip.hpp> 
#include <boost/iostreams/device/file.hpp> 

#include <fstream> 
#include <iostream> 
#include <memory> 

// 上事的最后部分是打开一个命名空间，把所有东西都放进去，然后把dealii命名空间导入其中。

namespace Step53 
{ 
  using namespace dealii; 
// @sect3{Describing topography: AfricaTopography}  

// 这个程序的第一个重要部分是描述地形 $h(\hat phi,\hat \theta)$ 作为经度和纬度的函数的类。正如在介绍中所讨论的那样，我们在这里将使我们的生活更容易一些，不以最普遍的方式来写这个类，而是只为我们在这里感兴趣的特定目的来写：插值从一个非常具体的数据文件中获得的数据，该文件包含了关于世界上一个特定地区的信息，我们知道该地区的范围。

// 该类的总体布局已经在上面讨论过了。下面是它的声明，包括我们在初始化 <code>topography_data</code> 成员变量时需要的三个静态成员函数。

  class AfricaTopography 
  { 
  public: 
    AfricaTopography(); 

    double value(const double lon, const double lat) const; 

  private: 
    const Functions::InterpolatedUniformGridData<2> topography_data; 

    static std::vector<double> get_data(); 
  }; 

// 让我们来看看这个类的实现。该类的有趣部分是构造函数和 <code>value()</code> 函数。前者初始化了 Functions::InterpolatedUniformGridData 成员变量，我们将使用这个构造函数，它要求我们传入我们要插值的二维数据集的端点（这里由区间 $[-6.983333, 11.98333]$ 给出）。 ]，使用介绍中讨论的切换端点的技巧，和 $[25, 35.983333]$ ，都是以度数给出的），数据被分割成的区间数（纬度方向379，经度方向219，总共 $380\times 220$ 个数据点），和一个包含数据的表对象。然后，数据的大小当然是 $380\times 220$ ，我们通过提供一个迭代器给下面 std::vector 函数返回的 <code>get_data()</code> 对象的83,600个元素中的第一个来初始化它。注意，我们在这里调用的所有成员函数都是静态的，因为(i)它们不访问类的任何成员变量，(ii)因为它们是在对象没有完全初始化的时候调用的。

  AfricaTopography::AfricaTopography() 
    : topography_data({{std::make_pair(-6.983333, 11.966667), 
                        std::make_pair(25, 35.95)}}, 
                      {{379, 219}}, 
                      Table<2, double>(380, 220, get_data().begin())) 
  {} 

  double AfricaTopography::value(const double lon, const double lat) const 
  { 
    return topography_data.value( 
      Point<2>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI)); 
  } 

// 唯一一个更有意义的函数是 <code>get_data()</code> 函数。它返回一个临时向量，其中包含描述高度的所有83600个数据点，并从文件 <code>topography.txt.gz</code> 中读取。因为文件被gzip压缩了，所以我们不能直接通过类型为 std::ifstream, 的对象来读取它，但在BOOST库中有一些方便的方法（见http:www.boost.org），允许我们从压缩的文件中读取，而不用先在磁盘上解压缩。其结果是，基本上，只是另一个输入流，就所有的实际目的而言，看起来就像我们一直使用的那些输入流。

// 当读取数据时，我们读取三列数据，但忽略了前两列。最后一列的数据被附加到一个数组中，我们返回的数组将被复制到 <code>topography_data</code> 的表中，并被初始化。由于BOOST.iostreams库在输入文件不存在、不可读或不包含正确的数据行数时没有提供非常有用的异常，我们捕捉它可能产生的所有异常并创建我们自己的异常。为此，在 <code>catch</code> 子句中，我们让程序运行到一个 <code>AssertThrow(false, ...)</code> 语句中。由于条件总是假的，这总是会触发一个异常。换句话说，这相当于写了 <code>throw ExcMessage("...")</code> ，但它也填补了异常对象中的某些字段，这些字段以后会被打印在屏幕上，识别出发生异常的函数、文件和行。

  std::vector<double> AfricaTopography::get_data() 
  { 
    std::vector<double> data; 

// 创建一个流，我们从gzipped数据中读取

    boost::iostreams::filtering_istream in; 
    in.push(boost::iostreams::basic_gzip_decompressor<>()); 
    in.push(boost::iostreams::file_source("topography.txt.gz")); 

    for (unsigned int line = 0; line < 83600; ++line) 
      { 
        try 
          { 
            double lat, lon, elevation; 
            in >> lat >> lon >> elevation; 

            data.push_back(elevation); 
          } 
        catch (...) 
          { 
            AssertThrow(false, 
                        ExcMessage("Could not read all 83,600 data points " 
                                   "from the file <topography.txt.gz>!")); 
          } 
      } 

    return data; 
  } 
// @sect3{Describing the geometry: AfricaGeometry}  

// 下面的类是本程序的主类。它的结构已经在介绍中详细描述过了，不需要再多做介绍。

  class AfricaGeometry : public ChartManifold<3, 3> 
  { 
  public: 
    virtual Point<3> pull_back(const Point<3> &space_point) const override; 

    virtual Point<3> push_forward(const Point<3> &chart_point) const override; 

    virtual std::unique_ptr<Manifold<3, 3>> clone() const override; 

  private: 
    static const double R; 
    static const double ellipticity; 

    const AfricaTopography topography; 

    Point<3> push_forward_wgs84(const Point<3> &phi_theta_d) const; 
    Point<3> pull_back_wgs84(const Point<3> &x) const; 

    Point<3> push_forward_topo(const Point<3> &phi_theta_d_hat) const; 
    Point<3> pull_back_topo(const Point<3> &phi_theta_d) const; 
  }; 

  const double AfricaGeometry::R           = 6378137; 
  const double AfricaGeometry::ellipticity = 8.1819190842622e-2; 

// 如果你读过介绍，实现起来也是非常简单的。特别是，回拉和前推函数都只是WGS 84和地形图映射各自函数的串联。

  Point<3> AfricaGeometry::pull_back(const Point<3> &space_point) const 
  { 
    return pull_back_topo(pull_back_wgs84(space_point)); 
  } 

  Point<3> AfricaGeometry::push_forward(const Point<3> &chart_point) const 
  { 
    return push_forward_wgs84(push_forward_topo(chart_point)); 
  } 

// 下一个函数是Manifold基类的接口所要求的，它允许克隆AfricaGeometry类。注意，虽然该函数返回一个  `std::unique_ptr<Manifold<3,3>>`,  我们在内部创建了一个 `unique_ptr<AfricaGeometry>`。换句话说，这个库需要一个指向基类的指针，我们通过创建一个指向派生类的指针来提供这个指针。

  std::unique_ptr<Manifold<3, 3>> AfricaGeometry::clone() const 
  { 
    return std::make_unique<AfricaGeometry>(); 
  } 

// 下面的两个函数就定义了对应于地球WGS84参考形状的正向和反向变换。正向变换遵循介绍中所示的公式。反变换要复杂得多，至少不是直观的。它还存在一个问题，即它返回一个角度，在函数结束时，如果它应该从那里逃出来，我们需要将其夹回区间 $[0,2\pi]$ 。

  Point<3> AfricaGeometry::push_forward_wgs84(const Point<3> &phi_theta_d) const 
  { 
    const double phi   = phi_theta_d[0]; 
    const double theta = phi_theta_d[1]; 
    const double d     = phi_theta_d[2]; 

    const double R_bar = R / std::sqrt(1 - (ellipticity * ellipticity * 
                                            std::sin(theta) * std::sin(theta))); 

    return {(R_bar + d) * std::cos(phi) * std::cos(theta), 
            (R_bar + d) * std::sin(phi) * std::cos(theta), 
            ((1 - ellipticity * ellipticity) * R_bar + d) * std::sin(theta)}; 
  } 

  Point<3> AfricaGeometry::pull_back_wgs84(const Point<3> &x) const 
  { 
    const double b   = std::sqrt(R * R * (1 - ellipticity * ellipticity)); 
    const double ep  = std::sqrt((R * R - b * b) / (b * b)); 
    const double p   = std::sqrt(x(0) * x(0) + x(1) * x(1)); 
    const double th  = std::atan2(R * x(2), b * p); 
    const double phi = std::atan2(x(1), x(0)); 
    const double theta = 
      std::atan2(x(2) + ep * ep * b * std::pow(std::sin(th), 3), 
                 (p - 
                  (ellipticity * ellipticity * R * std::pow(std::cos(th), 3)))); 
    const double R_bar = 
      R / (std::sqrt(1 - ellipticity * ellipticity * std::sin(theta) * 
                           std::sin(theta))); 
    const double R_plus_d = p / std::cos(theta); 

    Point<3> phi_theta_d; 
    if (phi < 0) 
      phi_theta_d[0] = phi + 2 * numbers::PI; 
    else if (phi > 2 * numbers::PI) 
      phi_theta_d[0] = phi - 2 * numbers::PI; 
    else 
      phi_theta_d[0] = phi; 
    phi_theta_d[1] = theta; 
    phi_theta_d[2] = R_plus_d - R_bar; 
    return phi_theta_d; 
  } 

// 与此相反，地形变换完全按照介绍中的描述进行。因此，没有什么可以补充的。

  Point<3> 
  AfricaGeometry::push_forward_topo(const Point<3> &phi_theta_d_hat) const 
  { 
    const double d_hat = phi_theta_d_hat[2]; 
    const double h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]); 
    const double d = d_hat + (d_hat + 500000) / 500000 * h; 
    return {phi_theta_d_hat[0], phi_theta_d_hat[1], d}; 
  } 

  Point<3> AfricaGeometry::pull_back_topo(const Point<3> &phi_theta_d) const 
  { 
    const double d     = phi_theta_d[2]; 
    const double h     = topography.value(phi_theta_d[0], phi_theta_d[1]); 
    const double d_hat = 500000 * (d - h) / (500000 + h); 
    return {phi_theta_d[0], phi_theta_d[1], d_hat}; 
  } 
// @sect3{Creating the mesh}  

// 在描述了几何体的属性之后，现在是处理用于离散它的网格的时候了。为此，我们为几何体和三角形创建对象，然后继续创建一个与参考域 $1\times 2\times 1$ 相对应的 $\hat U=[26,35]\times[-10,5]\times[-500000,0]$ 矩形网格。我们选择这个数目的细分，因为它导致了单元格大致上像立方体，而不是在某个方向上被拉伸。

// 当然，我们实际上对参考域的网格划分不感兴趣。我们感兴趣的是对真实域的网格划分。因此，我们将使用 GridTools::transform() 函数，它只是根据一个给定的变换来移动三角形的每个点。它想要的变换函数是一个将参考域中的一个点作为其单一参数的函数，并返回我们想要映射到的域中的相应位置。当然，这正是我们使用的几何学的前推函数。我们用一个lambda函数来包装它，以获得转换所需的那种函数对象。

  void run() 
  { 
    AfricaGeometry   geometry; 
    Triangulation<3> triangulation; 

    { 
      const Point<3> corner_points[2] = { 
        Point<3>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000), 
        Point<3>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)}; 
      std::vector<unsigned int> subdivisions(3); 
      subdivisions[0] = 1; 
      subdivisions[1] = 2; 
      subdivisions[2] = 1; 
      GridGenerator::subdivided_hyper_rectangle( 
        triangulation, subdivisions, corner_points[0], corner_points[1], true); 

      GridTools::transform( 
        [&geometry](const Point<3> &chart_point) { 
          return geometry.push_forward(chart_point); 
        }, 
        triangulation); 
    } 

// 下一步是向三角计算说明，在细化网格时，每当需要一个新的点时，都要使用我们的几何对象。我们通过告诉三角计算对所有流形指示器为零的物体使用我们的几何体，然后继续用流形指示器为零标记所有单元及其边界面和边。这确保了三角计算在每次需要新的顶点时都会参考我们的几何对象。由于流形指标是由母体继承给子体的，这也会在几个递归细化步骤之后发生。

    triangulation.set_manifold(0, geometry); 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      cell->set_all_manifold_ids(0); 

// 最后一步是在最初的 $1\times 2\times 1$ 粗略网格之外细化该网格。我们可以在全局范围内细化若干次，但由于本教程程序的目的，我们实际上只对靠近表面的情况感兴趣，所以我们只是对所有在边界上有一个指标为5的面的单元进行6次细化。在我们上面使用的 GridGenerator::subdivided_hyper_rectangle() 函数的文档中查找，发现边界指标5对应于域的顶面（这就是上面调用 GridGenerator::subdivided_hyper_rectangle() 的最后一个 <code>true</code> 参数的含义：通过给每个边界分配一个独特的边界指标来给边界 "着色"）。

    for (unsigned int i = 0; i < 6; ++i) 
      { 
        for (const auto &cell : triangulation.active_cell_iterators()) 
          for (const auto &face : cell->face_iterators()) 
            if (face->boundary_id() == 5) 
              { 
                cell->set_refine_flag(); 
                break; 
              } 
        triangulation.execute_coarsening_and_refinement(); 

        std::cout << "Refinement step " << i + 1 << ": " 
                  << triangulation.n_active_cells() << " cells, " 
                  << GridTools::minimal_cell_diameter(triangulation) / 1000 
                  << "km minimal cell diameter" << std::endl; 
      } 

// 做完这一切，我们现在可以将网格输出到一个自己的文件中。

    const std::string filename = "mesh.vtu"; 
    std::ofstream     out(filename); 
    GridOut           grid_out; 
    grid_out.write_vtu(triangulation, out); 
  } 
} // namespace Step53 

//  @sect3{The main function}  

// 最后是主函数，它采用了从  step-6  开始的所有教程程序中使用的相同方案。这里没有什么可做的，只需要调用单一的  <code>run()</code>  函数。

int main() 
{ 
  try 
    { 
      Step53::run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
} 


CCTest_file/step-54.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2009 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 *  Authors: Andrea Mola, Luca Heltai, 2014 
 */ 


// @sect3{Include files}  

// 我们首先包括一堆我们将在程序的各个部分使用的文件。它们中的大多数已经在以前的教程中讨论过了。

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_in.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 这些是opencascade支持类和函数的头文件。注意，只有当你在编译deal.II库时支持OpenCASCADE，即在deal.II配置过程中调用 <code>-DDEAL_II_WITH_OPENCASCADE=ON</code> 和 <code>-DOPENCASCADE_DIR=/path/to/your/opencascade/installation</code> 时，这些将包含合理的数据。

#include <deal.II/opencascade/manifold_lib.h> 
#include <deal.II/opencascade/utilities.h> 

// 最后，几个C++标准头文件

#include <cmath> 
#include <iostream> 
#include <fstream> 
#include <string> 

// 我们将程序的其他部分隔离在自己的命名空间中

namespace Step54 
{ 
  using namespace dealii; 

//  @sect3{The TriangulationOnCAD class}  

// 这是主类。它真正做的是存储输入和输出文件的名称，以及一个三角图。然后，它提供了一个函数，可以从一个粗略的网格中生成这样一个三角形，使用介绍中所讨论的策略之一，并在类的顶部的枚举类型中列出。

// 这个类的成员函数与你在其他大多数教程程序中可以找到的类似，都是在模拟的网格设置阶段。

  class TriangulationOnCAD 
  { 
  public: 
    enum ProjectionType 
    { 
      NormalProjection       = 0, 
      DirectionalProjection  = 1, 
      NormalToMeshProjection = 2 
    }; 

    TriangulationOnCAD( 
      const std::string &  initial_mesh_filename, 
      const std::string &  cad_file_name, 
      const std::string &  output_filename, 
      const ProjectionType surface_projection_kind = NormalProjection); 

    void run(); 

  private: 
    void read_domain(); 

    void refine_mesh(); 

    void output_results(const unsigned int cycle); 

    Triangulation<2, 3> tria; 

    const std::string initial_mesh_filename; 
    const std::string cad_file_name; 
    const std::string output_filename; 

    const ProjectionType surface_projection_kind; 
  }; 
// @sect4{TriangulationOnCAD::TriangulationOnCAD}  

// TriangulationOnCAD类的构造函数非常简单。输入参数是输入和输出文件名的字符串，以及决定在网格细化循环中使用哪种曲面投影仪的枚举类型（详见下文）。

  TriangulationOnCAD::TriangulationOnCAD( 
    const std::string &  initial_mesh_filename, 
    const std::string &  cad_file_name, 
    const std::string &  output_filename, 
    const ProjectionType surface_projection_kind) 
    : initial_mesh_filename(initial_mesh_filename) 
    , cad_file_name(cad_file_name) 
    , output_filename(output_filename) 
    , surface_projection_kind(surface_projection_kind) 
  {} 
// @sect4{TriangulationOnCAD::read_domain}  

// 下面的函数代表了这个程序的核心。 在这个函数中，我们导入CAD形状，在此基础上生成并完善我们的三角测量。我们假设CAD曲面包含在 @p cad_file_name 文件中（我们在输入目录中提供了一个名为 "input/DTMB-5415_bulbous_bow.iges "的IGES文件例子，它代表了一艘船的球形船头）。几个凸和凹的高曲率区域的存在使得我们提供的几何体成为一个特别有意义的例子。

// 在导入船首表面后，我们提取了一些构成它的曲线和曲面，并使用它们来生成一组投影仪。这些投影仪定义了三角法在细化单元时必须遵循的规则，以定位每个新节点。

// 为了初始化Triangulation，就像在以前的教程中一样，我们导入一个以VTK格式保存的现有网格。在这里我们假设用户已经在外部生成了一个粗略的网格，与IGES的几何图形相匹配。在编写本教程的时候，deal.II库并不自动支持生成这样的网格，但是有一些工具可以从CAD文件开始为你提供合理的初始网格。在我们的例子中，导入的网格是由一个四边形单元组成的，其顶点被放置在CAD形状上。

// 在导入IGES几何体和初始网格后，我们将之前讨论过的投影仪分配给每个需要在CAD表面上进行细化的边和单元。

// 在本教程中，我们将测试介绍中所描述的三种不同的CAD表面投影器，并将分析每一种投影器所得到的结果。 如前所述，这些投影策略中的每一种都是在不同的类中实现的，这些类型的对象可以用 Triangulation::set_manifold 的方法分配给一个三角形。
//然后，
//下面的函数首先导入给定的CAD文件。函数的参数是一个包含所需文件名的字符串，以及一个比例因子。在这个例子中，比例因子被设置为1e-3，因为原始几何体是以毫米为单位的（这是大多数IGES文件的典型计量单位），而我们更喜欢以米为单位工作。 该函数的输出是一个OpenCASCADE通用拓扑形状类的对象，即一个 @p TopoDS_Shape. 。
  void TriangulationOnCAD::read_domain() 
  { 
    TopoDS_Shape bow_surface = OpenCASCADE::read_IGES(cad_file_name, 1e-3); 

// 每个CAD几何对象都被定义了一个公差，它表示其位置可能的不精确性。例如，顶点的公差 @p tol 表示它可以位于以标称位置为中心，半径为 @p tol. 的球体中的任何一点。

// 下面的方法是提取给定形状的公差，并使其变大一些以避免麻烦。

    const double tolerance = OpenCASCADE::get_shape_tolerance(bow_surface) * 5; 

// 我们现在要从通用形状中提取一组复合子形状。特别是，CAD文件的每个面都是由类型为 @p TopoDS_Wire, 的修剪曲线组成的，它是构成曲面边界的 @p TopoDS_Edges 的集合，以及曲面本身的NURBS描述。我们将使用线型投影仪将我们的三角形的边界与划定曲面的线联系起来。 为了提取所有的复合子形状，如线、壳或实体，我们求助于OpenCASCADE命名空间的一种方法。  OpenCASCADE::extract_compound_shapes 的输入是一个形状和一组空的 std::vectors 子形状，它将被填入在给定拓扑形状中发现的所有复合形状。

    std::vector<TopoDS_Compound>  compounds; 
    std::vector<TopoDS_CompSolid> compsolids; 
    std::vector<TopoDS_Solid>     solids; 
    std::vector<TopoDS_Shell>     shells; 
    std::vector<TopoDS_Wire>      wires; 

    OpenCASCADE::extract_compound_shapes( 
      bow_surface, compounds, compsolids, solids, shells, wires); 

// 接下来的几个步骤比较熟悉，允许我们从外部VTK文件中导入一个现有的网格，并将其转换为一个交易三角图。

    std::ifstream in; 

    in.open(initial_mesh_filename); 

    GridIn<2, 3> gi; 
    gi.attach_triangulation(tria); 
    gi.read_vtk(in); 

// 我们输出这个初始网格，将其保存为细化步骤0。

    output_results(0); 

// 导入的网格有一个位于三维空间中的单一的二维单元。我们现在要确保它是根据上面导入的CAD几何图形进行细化的。为此，我们得到一个单元的迭代器，并给它分配manifold_id 1（见  @ref GlossManifoldIndicator  "这个词汇表条目"）。我们还得到了一个指向其四个面的迭代器，并为每个面分配了manifold_id 2。

    Triangulation<2, 3>::active_cell_iterator cell = tria.begin_active(); 
    cell->set_manifold_id(1); 

    for (const auto &face : cell->face_iterators()) 
      face->set_manifold_id(2); 

// 一旦CAD几何体和初始网格都被导入和消化，我们就用CAD的曲面和曲线来定义投影仪，并将它们分配给刚才指定的流形ID。

// 使用我们的CAD文件中的单线来定义第一个投影仪。 ArclengthProjectionLineManifold将确保位于导线上的每条网格边缘都被细化为一个位于导线上的点，并将其分割为两个位于边缘顶点之间的相等弧线。我们首先检查线的向量是否至少包含一个元素，然后为它创建一个Manifold对象。

// 一旦投影仪被创建，我们就把它分配给三角形的所有部分，manifold_id = 2。

    Assert( 
      wires.size() > 0, 
      ExcMessage( 
        "I could not find any wire in the CAD file you gave me. Bailing out.")); 

    OpenCASCADE::ArclengthProjectionLineManifold<2, 3> line_projector( 
      wires[0], tolerance); 

    tria.set_manifold(2, line_projector); 

// 根据构造函数的 @p surface_projection_kind 选项所指定的内容来创建表面投影仪。特别是，如果surface_projection_kind的值等于 @p NormalProjection, ，我们选择 OpenCASCADE::NormalProjectionManifold. ，那么新的网格点最初将在所考虑的单元格/边的arycenter处生成，然后沿其法线方向投影到CAD表面。 NormalProjectionManifold构造函数只需要一个形状和一个公差，然后我们把它分配给三角结构，用于所有具有id 1的流形的部分。

    switch (surface_projection_kind) 
      { 
        case NormalProjection: 
          { 
            OpenCASCADE::NormalProjectionManifold<2, 3> normal_projector( 
              bow_surface, tolerance); 
            tria.set_manifold(1, normal_projector); 

            break; 
          } 
// @p If  surface_projection_kind值为 @p DirectionalProjection,  我们选择 OpenCASCADE::DirectionalProjectionManifold 类。新的网格点将在所考虑的单元格/边的arycenter处初始生成，然后沿着 OpenCASCADE::DirectionalProjectionManifold 构造函数指定的方向投影到CAD表面上。在这个例子中，投影是沿着Y轴进行的。

        case DirectionalProjection: 
          { 
            OpenCASCADE::DirectionalProjectionManifold<2, 3> 
              directional_projector(bow_surface, 
                                    Point<3>(0.0, 1.0, 0.0), 
                                    tolerance); 
            tria.set_manifold(1, directional_projector); 

            break; 
          } 

// 作为第三个选项，如果 @p surface_projection_kind 的值是 @p NormalToMeshProjection, ，我们选择 OpenCASCADE::NormalToMeshProjectionManifold.  新的网格点将再次在所考虑的单元/边的arycenter处初始生成，然后沿着一个估计为网格法线方向的方向投影到CAD表面。 OpenCASCADE::NormalToMeshProjectionManifold  构造函数只需要一个形状（至少包含一个面）和一个公差。

        case NormalToMeshProjection: 
          { 
            OpenCASCADE::NormalToMeshProjectionManifold<2, 3> 
              normal_to_mesh_projector(bow_surface, tolerance); 
            tria.set_manifold(1, normal_to_mesh_projector); 

            break; 
          } 

// 最后，我们使用良好的软件清洁性，确保这真的涵盖了 @p case 语句的所有可能选项。如果我们得到任何其他的值，我们就直接中止程序。

        default: 
          AssertThrow(false, ExcInternalError()); 
      } 
  } 
// @sect4{TriangulationOnCAD::refine_mesh}  

// 这个函数是全局细化网格的。在其他教程中，它通常也会分配自由度，并调整矩阵和向量的大小。这里没有进行这些工作，因为我们没有在生成的三角形上运行任何模拟。

// 虽然这个函数看起来很简单，但这是我们对这个教程程序感兴趣的大部分工作的实际发生地点。特别是，在完善定义船体表面的四边形和直线时，Triangulation类将询问我们分配给处理单个流形ID的各种对象，以确定新顶点的位置。

  void TriangulationOnCAD::refine_mesh() 
  { 
    tria.refine_global(1); 
  } 

//  @sect4{TriangulationOnCAD::output_results}  

// 输出我们的计算结果是一个相当机械的任务。这个函数的所有组成部分之前已经讨论过了。

  void TriangulationOnCAD::output_results(const unsigned int cycle) 
  { 
    const std::string filename = 
      (output_filename + "_" + Utilities::int_to_string(cycle) + ".vtk"); 
    std::ofstream logfile(filename); 
    GridOut       grid_out; 
    grid_out.write_vtk(tria, logfile); 
  } 
// @sect4{TriangulationOnCAD::run}  

// 这是主函数。它应该是不言自明的。

  void TriangulationOnCAD::run() 
  { 
    read_domain(); 

    const unsigned int n_cycles = 5; 
    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle) 
      { 
        refine_mesh(); 
        output_results(cycle + 1); 
      } 
  } 
} // namespace Step54 
// @sect3{The main() function}  

// 这是本程序的主要功能。它的基本结构与之前所有的教程程序一样，但通过新顶点放置的三种可能性来运行主类。

int main() 
{ 
  try 
    { 
      using namespace Step54; 

      const std::string in_mesh_filename = "input/initial_mesh_3d.vtk"; 
      const std::string cad_file_name    = "input/DTMB-5415_bulbous_bow.iges"; 

      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      std::cout << "Testing projection in direction normal to CAD surface" 
                << std::endl; 
      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      std::string        out_mesh_filename = ("3d_mesh_normal_projection"); 
      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename, 
                                          cad_file_name, 
                                          out_mesh_filename, 
                                          TriangulationOnCAD::NormalProjection); 
      tria_on_cad_norm.run(); 
      std::cout << "----------------------------------------------------------" 
                << std::endl;
      std::cout << std::endl; 
      std::cout << std::endl; 

      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      std::cout << "Testing projection in y-axis direction" << std::endl; 
      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      out_mesh_filename = ("3d_mesh_directional_projection"); 
      TriangulationOnCAD tria_on_cad_dir( 
        in_mesh_filename, 
        cad_file_name, 
        out_mesh_filename, 
        TriangulationOnCAD::DirectionalProjection);  
      tria_on_cad_dir.run();  
      std::cout << "----------------------------------------------------------"  
                << std::endl; 
      std::cout << std::endl; 
      std::cout << std::endl; 

      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      std::cout << "Testing projection in direction normal to mesh elements" 
                << std::endl; 
      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      out_mesh_filename = ("3d_mesh_normal_to_mesh_projection"); 
      TriangulationOnCAD tria_on_cad_norm_to_mesh( 
        in_mesh_filename, 
        cad_file_name, 
        out_mesh_filename, 
        TriangulationOnCAD::NormalToMeshProjection); 
      tria_on_cad_norm_to_mesh.run(); 
      std::cout << "----------------------------------------------------------" 
                << std::endl; 
      std::cout << std::endl; 
      std::cout << std::endl; 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-55.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2016 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Timo Heister, Clemson University, 2016 
 */ 



#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/timer.h> 

// 下面这块出场代码与 step-40 相同，可以在PETSc和Trilinos之间切换。

#include <deal.II/lac/generic_linear_algebra.h> 

/* #define FORCE_USE_OF_TRILINOS */ 



namespace LA 
{ 
#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \ 
  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS)) 
  using namespace dealii::LinearAlgebraPETSc; 
#  define USE_PETSC_LA 
#elif defined(DEAL_II_WITH_TRILINOS) 
  using namespace dealii::LinearAlgebraTrilinos; 
#else 
#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required 
#endif 
} // namespace LA 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/solver_minres.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 

#include <deal.II/lac/petsc_sparse_matrix.h> 
#include <deal.II/lac/petsc_vector.h> 
#include <deal.II/lac/petsc_solver.h> 
#include <deal.II/lac/petsc_precondition.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <deal.II/base/utilities.h> 
#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/index_set.h> 
#include <deal.II/lac/sparsity_tools.h> 
#include <deal.II/distributed/tria.h> 
#include <deal.II/distributed/grid_refinement.h> 

#include <cmath> 
#include <fstream> 
#include <iostream> 

namespace Step55 
{ 
  using namespace dealii; 
// @sect3{Linear solvers and preconditioners}  

// 我们需要一些辅助类来表示我们在介绍中描述的求解器策略。

  namespace LinearSolvers 
  { 

// 这个类暴露了通过函数 InverseMatrix::vmult(). 应用给定矩阵的逆的动作，在内部，逆不是显式形成的。相反，一个带有CG的线性求解器被执行。这个类扩展了 step-22 中的InverseMatrix类，增加了一个指定预处理程序的选项，并允许在vmult函数中使用不同的矢量类型。

    template <class Matrix, class Preconditioner> 
    class InverseMatrix : public Subscriptor 
    { 
    public: 
      InverseMatrix(const Matrix &m, const Preconditioner &preconditioner); 

      template <typename VectorType> 
      void vmult(VectorType &dst, const VectorType &src) const; 

    private: 
      const SmartPointer<const Matrix> matrix; 
      const Preconditioner &           preconditioner; 
    }; 

    template <class Matrix, class Preconditioner> 
    InverseMatrix<Matrix, Preconditioner>::InverseMatrix( 
      const Matrix &        m, 
      const Preconditioner &preconditioner) 
      : matrix(&m) 
      , preconditioner(preconditioner) 
    {} 

    template <class Matrix, class Preconditioner> 
    template <typename VectorType> 
    void 
    InverseMatrix<Matrix, Preconditioner>::vmult(VectorType &      dst, 
                                                 const VectorType &src) const 
    { 
      SolverControl solver_control(src.size(), 1e-8 * src.l2_norm()); 
      SolverCG<LA::MPI::Vector> cg(solver_control); 
      dst = 0; 

      try 
        { 
          cg.solve(*matrix, dst, src, preconditioner); 
        } 
      catch (std::exception &e) 
        { 
          Assert(false, ExcMessage(e.what())); 
        } 
    } 

// 该类是一个简单的2x2矩阵的块状对角线预处理器的模板类。

    template <class PreconditionerA, class PreconditionerS> 
    class BlockDiagonalPreconditioner : public Subscriptor 
    { 
    public: 
      BlockDiagonalPreconditioner(const PreconditionerA &preconditioner_A, 
                                  const PreconditionerS &preconditioner_S); 

      void vmult(LA::MPI::BlockVector &      dst, 
                 const LA::MPI::BlockVector &src) const; 

    private: 
      const PreconditionerA &preconditioner_A; 
      const PreconditionerS &preconditioner_S; 
    }; 

    template <class PreconditionerA, class PreconditionerS> 
    BlockDiagonalPreconditioner<PreconditionerA, PreconditionerS>:: 
      BlockDiagonalPreconditioner(const PreconditionerA &preconditioner_A, 
                                  const PreconditionerS &preconditioner_S) 
      : preconditioner_A(preconditioner_A) 
      , preconditioner_S(preconditioner_S) 
    {} 

    template <class PreconditionerA, class PreconditionerS> 
    void BlockDiagonalPreconditioner<PreconditionerA, PreconditionerS>::vmult( 
      LA::MPI::BlockVector &      dst, 
      const LA::MPI::BlockVector &src) const 
    { 
      preconditioner_A.vmult(dst.block(0), src.block(0)); 
      preconditioner_S.vmult(dst.block(1), src.block(1)); 
    } 

 
// @sect3{Problem setup}  

// 下面的类代表测试问题的右手边和精确解。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide() 
      : Function<dim>(dim + 1) 
    {} 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  void RightHandSide<dim>::vector_value(const Point<dim> &p, 
                                        Vector<double> &  values) const 
  { 
    const double R_x = p[0]; 
    const double R_y = p[1]; 

    const double pi  = numbers::PI; 
    const double pi2 = pi * pi; 
    values[0] = 
      -1.0L / 2.0L * (-2 * sqrt(25.0 + 4 * pi2) + 10.0) * 
        exp(R_x * (-2 * sqrt(25.0 + 4 * pi2) + 10.0)) - 
      0.4 * pi2 * exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi) + 
      0.1 * pow(-sqrt(25.0 + 4 * pi2) + 5.0, 2) * 
        exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi); 
    values[1] = 0.2 * pi * (-sqrt(25.0 + 4 * pi2) + 5.0) * 
                  exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) - 
                0.05 * pow(-sqrt(25.0 + 4 * pi2) + 5.0, 3) * 
                  exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) / 
                  pi; 
    values[2] = 0; 
  } 

  template <int dim> 
  class ExactSolution : public Function<dim> 
  { 
  public: 
    ExactSolution() 
      : Function<dim>(dim + 1) 
    {} 

    virtual void vector_value(const Point<dim> &p, 
                              Vector<double> &  value) const override; 
  }; 

  template <int dim> 
  void ExactSolution<dim>::vector_value(const Point<dim> &p, 
                                        Vector<double> &  values) const 
  { 
    const double R_x = p[0]; 
    const double R_y = p[1]; 

    const double pi  = numbers::PI; 
    const double pi2 = pi * pi; 
    values[0] = 
      -exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi) + 1; 
    values[1] = (1.0L / 2.0L) * (-sqrt(25.0 + 4 * pi2) + 5.0) * 
                exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) / 
                pi; 
    values[2] = 
      -1.0L / 2.0L * exp(R_x * (-2 * sqrt(25.0 + 4 * pi2) + 10.0)) - 
      2.0 * 
        (-6538034.74494422 + 
         0.0134758939981709 * exp(4 * sqrt(25.0 + 4 * pi2))) / 
        (-80.0 * exp(3 * sqrt(25.0 + 4 * pi2)) + 
         16.0 * sqrt(25.0 + 4 * pi2) * exp(3 * sqrt(25.0 + 4 * pi2))) - 
      1634508.68623606 * exp(-3.0 * sqrt(25.0 + 4 * pi2)) / 
        (-10.0 + 2.0 * sqrt(25.0 + 4 * pi2)) + 
      (-0.00673794699908547 * exp(sqrt(25.0 + 4 * pi2)) + 
       3269017.37247211 * exp(-3 * sqrt(25.0 + 4 * pi2))) / 
        (-8 * sqrt(25.0 + 4 * pi2) + 40.0) + 
      0.00336897349954273 * exp(1.0 * sqrt(25.0 + 4 * pi2)) / 
        (-10.0 + 2.0 * sqrt(25.0 + 4 * pi2)); 
  } 

//  @sect3{The main program}  

// 主类与  step-40  非常相似，只是矩阵和向量现在是块状的，而且我们为拥有的和相关的DoF存储一个  std::vector<IndexSet>  ，而不是一个IndexSet。我们正好有两个IndexSets，一个用于所有速度未知数，一个用于所有压力未知数。

  template <int dim> 
  class StokesProblem 
  { 
  public: 
    StokesProblem(unsigned int velocity_degree); 

    void run(); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    unsigned int velocity_degree; 
    double       viscosity; 
    MPI_Comm     mpi_communicator; 

    FESystem<dim>                             fe; 
    parallel::distributed::Triangulation<dim> triangulation; 
    DoFHandler<dim>                           dof_handler; 

    std::vector<IndexSet> owned_partitioning; 
    std::vector<IndexSet> relevant_partitioning; 

    AffineConstraints<double> constraints; 

    LA::MPI::BlockSparseMatrix system_matrix; 
    LA::MPI::BlockSparseMatrix preconditioner_matrix; 
    LA::MPI::BlockVector       locally_relevant_solution; 
    LA::MPI::BlockVector       system_rhs; 

    ConditionalOStream pcout; 
    TimerOutput        computing_timer; 
  }; 

  template <int dim> 
  StokesProblem<dim>::StokesProblem(unsigned int velocity_degree) 
    : velocity_degree(velocity_degree) 
    , viscosity(0.1) 
    , mpi_communicator(MPI_COMM_WORLD) 
    , fe(FE_Q<dim>(velocity_degree), dim, FE_Q<dim>(velocity_degree - 1), 1) 
    , triangulation(mpi_communicator, 
                    typename Triangulation<dim>::MeshSmoothing( 
                      Triangulation<dim>::smoothing_on_refinement | 
                      Triangulation<dim>::smoothing_on_coarsening)) 
    , dof_handler(triangulation) 
    , pcout(std::cout, 
            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
    , computing_timer(mpi_communicator, 
                      pcout, 
                      TimerOutput::summary, 
                      TimerOutput::wall_times) 
  {} 

// Kovasnay流定义在域[-0.5, 1.5]^2上，我们通过将最小和最大值传递给 GridGenerator::hyper_cube. 来创建这个域。
  template <int dim> 
  void StokesProblem<dim>::make_grid() 
  { 
    GridGenerator::hyper_cube(triangulation, -0.5, 1.5); 
    triangulation.refine_global(3); 
  } 
// @sect3{System Setup}  

// 与 step-40 相比，块矩阵和向量的构造是新的，与 step-22 这样的串行代码相比也是不同的，因为我们需要提供属于我们处理器的行的集合。

  template <int dim> 
  void StokesProblem<dim>::setup_system() 
  { 
    TimerOutput::Scope t(computing_timer, "setup"); 

    dof_handler.distribute_dofs(fe); 

// 将所有的昏暗速度放入0区块，压力放入1区块，然后按区块重新排列未知数。最后计算每块有多少个未知数。

    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0); 
    stokes_sub_blocks[dim] = 1; 
    DoFRenumbering::component_wise(dof_handler, stokes_sub_blocks); 

    const std::vector<types::global_dof_index> dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, stokes_sub_blocks); 

    const unsigned int n_u = dofs_per_block[0]; 
    const unsigned int n_p = dofs_per_block[1]; 

    pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs() << " (" 
          << n_u << '+' << n_p << ')' << std::endl; 

// 我们根据我们想要创建块状矩阵和向量的方式，将本地拥有的和本地相关的DoF的IndexSet分割成两个IndexSets。

    owned_partitioning.resize(2); 
    owned_partitioning[0] = dof_handler.locally_owned_dofs().get_view(0, n_u); 
    owned_partitioning[1] = 
      dof_handler.locally_owned_dofs().get_view(n_u, n_u + n_p); 

    IndexSet locally_relevant_dofs; 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 
    relevant_partitioning.resize(2); 
    relevant_partitioning[0] = locally_relevant_dofs.get_view(0, n_u); 
    relevant_partitioning[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p); 

// 设置边界条件和悬挂节点的约束与  step-40  相同。尽管我们没有任何悬空节点，因为我们只进行全局细化，但把这个函数调用放进去仍然是个好主意，以备以后引入自适应细化。

    { 
      constraints.reinit(locally_relevant_dofs); 

      FEValuesExtractors::Vector velocities(0); 
      DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               ExactSolution<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 
      constraints.close(); 
    } 

// 现在我们根据BlockDynamicSparsityPattern来创建系统矩阵。我们知道我们不会有不同速度分量之间的耦合（因为我们使用的是拉普拉斯而不是变形张量），也不会有压力与其测试函数之间的耦合，所以我们使用一个表来将这个耦合信息传达给  DoFTools::make_sparsity_pattern.  。
    { 
      system_matrix.clear(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (c == dim && d == dim) 
            coupling[c][d] = DoFTools::none; 
          else if (c == dim || d == dim || c == d) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block); 

      DoFTools::make_sparsity_pattern( 
        dof_handler, coupling, dsp, constraints, false); 

      SparsityTools::distribute_sparsity_pattern( 
        dsp, 
        dof_handler.locally_owned_dofs(), 
        mpi_communicator, 
        locally_relevant_dofs); 

      system_matrix.reinit(owned_partitioning, dsp, mpi_communicator); 
    } 

// 先决条件矩阵有不同的耦合（我们只在1,1块中填入质量矩阵），否则这段代码与上面的system_matrix的构造是相同的。

    { 
      preconditioner_matrix.clear(); 

      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1); 
      for (unsigned int c = 0; c < dim + 1; ++c) 
        for (unsigned int d = 0; d < dim + 1; ++d) 
          if (c == dim && d == dim) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block); 

      DoFTools::make_sparsity_pattern( 
        dof_handler, coupling, dsp, constraints, false); 
      SparsityTools::distribute_sparsity_pattern( 
        dsp, 
        Utilities::MPI::all_gather(mpi_communicator, 
                                   dof_handler.locally_owned_dofs()), 
        mpi_communicator, 
        locally_relevant_dofs); 
      preconditioner_matrix.reinit(owned_partitioning, 

// owned_partitioning。

                                   dsp, 
                                   mpi_communicator); 
    } 

// 最后，我们以正确的尺寸构建块状向量。带有两个 std::vector<IndexSet> 的函数调用将创建一个重影向量。

    locally_relevant_solution.reinit(owned_partitioning, 
                                     relevant_partitioning, 
                                     mpi_communicator); 
    system_rhs.reinit(owned_partitioning, mpi_communicator); 
  } 

//  @sect3{Assembly}  

// 这个函数将系统矩阵、预处理矩阵和右手边集合起来。其代码非常标准。

  template <int dim> 
  void StokesProblem<dim>::assemble_system() 
  { 
    TimerOutput::Scope t(computing_timer, "assembly"); 

    system_matrix         = 0; 
    preconditioner_matrix = 0; 
    system_rhs            = 0; 

    const QGauss<dim> quadrature_formula(velocity_degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    const RightHandSide<dim>    right_hand_side; 
    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1)); 

    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell); 
    std::vector<double>         div_phi_u(dofs_per_cell); 
    std::vector<double>         phi_p(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    const FEValuesExtractors::Vector     velocities(0); 
    const FEValuesExtractors::Scalar     pressure(dim); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell_matrix  = 0; 
          cell_matrix2 = 0; 
          cell_rhs     = 0; 

          fe_values.reinit(cell); 
          right_hand_side.vector_value_list(fe_values.get_quadrature_points(), 
                                            rhs_values); 
          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 
              for (unsigned int k = 0; k < dofs_per_cell; ++k) 
                { 
                  grad_phi_u[k] = fe_values[velocities].gradient(k, q); 
                  div_phi_u[k]  = fe_values[velocities].divergence(k, q); 
                  phi_p[k]      = fe_values[pressure].value(k, q); 
                } 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    { 
                      cell_matrix(i, j) += 
                        (viscosity * 
                           scalar_product(grad_phi_u[i], grad_phi_u[j]) - 
                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) * 
                        fe_values.JxW(q); 

                      cell_matrix2(i, j) += 1.0 / viscosity * phi_p[i] * 
                                            phi_p[j] * fe_values.JxW(q); 
                    } 

                  const unsigned int component_i = 
                    fe.system_to_component_index(i).first; 
                  cell_rhs(i) += fe_values.shape_value(i, q) * 
                                 rhs_values[q](component_i) * fe_values.JxW(q); 
                } 
            } 

          cell->get_dof_indices(local_dof_indices); 
          constraints.distribute_local_to_global(cell_matrix, 
                                                 cell_rhs, 
                                                 local_dof_indices, 
                                                 system_matrix, 
                                                 system_rhs); 

          constraints.distribute_local_to_global(cell_matrix2, 
                                                 local_dof_indices, 
                                                 preconditioner_matrix); 
        } 

    system_matrix.compress(VectorOperation::add); 
    preconditioner_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 
  } 

//  @sect3{Solving}  

// 这个函数用MINRES求解线性系统，如介绍中所述，对两个对角线块使用块状对角线预处理和AMG。预处理程序对0,0块应用v循环，对1,1块应用质量矩阵的CG（Schur补充）。

  template <int dim> 
  void StokesProblem<dim>::solve() 
  { 
    TimerOutput::Scope t(computing_timer, "solve"); 

    LA::MPI::PreconditionAMG prec_A; 
    { 
      LA::MPI::PreconditionAMG::AdditionalData data; 

#ifdef USE_PETSC_LA 
      data.symmetric_operator = true; 
#endif 
      prec_A.initialize(system_matrix.block(0, 0), data); 
    } 

    LA::MPI::PreconditionAMG prec_S; 
    { 
      LA::MPI::PreconditionAMG::AdditionalData data; 

#ifdef USE_PETSC_LA 
      data.symmetric_operator = true; 
#endif 
      prec_S.initialize(preconditioner_matrix.block(1, 1), data); 
    } 

// InverseMatrix用于解决质量矩阵的问题。

    using mp_inverse_t = LinearSolvers::InverseMatrix<LA::MPI::SparseMatrix, 
                                                      LA::MPI::PreconditionAMG>; 
    const mp_inverse_t mp_inverse(preconditioner_matrix.block(1, 1), prec_S); 

// 这是在上面定义的各个块的预处理的基础上构造的块预处理。

    const LinearSolvers::BlockDiagonalPreconditioner<LA::MPI::PreconditionAMG, 
                                                     mp_inverse_t> 
      preconditioner(prec_A, mp_inverse); 

// 有了这些，我们终于可以设置线性求解器并求解该系统。

    SolverControl solver_control(system_matrix.m(), 
                                 1e-10 * system_rhs.l2_norm()); 

    SolverMinRes<LA::MPI::BlockVector> solver(solver_control); 

    LA::MPI::BlockVector distributed_solution(owned_partitioning, 
                                              mpi_communicator); 

    constraints.set_zero(distributed_solution); 

    solver.solve(system_matrix, 
                 distributed_solution, 
                 system_rhs, 
                 preconditioner); 

    pcout << "   Solved in " << solver_control.last_step() << " iterations." 
          << std::endl; 

    constraints.distribute(distributed_solution); 

// 像在  step-56  中一样，我们减去平均压力，以便与我们的参考解决方案进行误差计算，该解决方案的平均值为零。

    locally_relevant_solution = distributed_solution; 
    const double mean_pressure = 
      VectorTools::compute_mean_value(dof_handler, 
                                      QGauss<dim>(velocity_degree + 2), 
                                      locally_relevant_solution, 
                                      dim); 
    distributed_solution.block(1).add(-mean_pressure); 
    locally_relevant_solution.block(1) = distributed_solution.block(1); 
  } 

//  @sect3{The rest}  

// 其余处理网格细化、输出和主循环的代码非常标准。

  template <int dim> 
  void StokesProblem<dim>::refine_grid() 
  { 
    TimerOutput::Scope t(computing_timer, "refine"); 

    triangulation.refine_global(); 
  } 

  template <int dim> 
  void StokesProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    { 
      const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1); 
      const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim), 
                                                       dim + 1); 

      Vector<double> cellwise_errors(triangulation.n_active_cells()); 
      QGauss<dim>    quadrature(velocity_degree + 2); 

      VectorTools::integrate_difference(dof_handler, 
                                        locally_relevant_solution, 
                                        ExactSolution<dim>(), 
                                        cellwise_errors, 
                                        quadrature, 
                                        VectorTools::L2_norm, 
                                        &velocity_mask); 

      const double error_u_l2 = 
        VectorTools::compute_global_error(triangulation, 
                                          cellwise_errors, 
                                          VectorTools::L2_norm); 

      VectorTools::integrate_difference(dof_handler, 
                                        locally_relevant_solution, 
                                        ExactSolution<dim>(), 
                                        cellwise_errors, 
                                        quadrature, 
                                        VectorTools::L2_norm, 
                                        &pressure_mask); 

      const double error_p_l2 = 
        VectorTools::compute_global_error(triangulation, 
                                          cellwise_errors, 
                                          VectorTools::L2_norm); 

      pcout << "error: u_0: " << error_u_l2 << " p_0: " << error_p_l2 
            << std::endl; 
    } 

    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("pressure"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(locally_relevant_solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 

    LA::MPI::BlockVector interpolated; 
    interpolated.reinit(owned_partitioning, MPI_COMM_WORLD); 
    VectorTools::interpolate(dof_handler, ExactSolution<dim>(), interpolated); 

    LA::MPI::BlockVector interpolated_relevant(owned_partitioning, 
                                               relevant_partitioning, 
                                               MPI_COMM_WORLD); 
    interpolated_relevant = interpolated; 
    { 
      std::vector<std::string> solution_names(dim, "ref_u"); 
      solution_names.emplace_back("ref_p"); 
      data_out.add_data_vector(interpolated_relevant, 
                               solution_names, 
                               DataOut<dim>::type_dof_data, 
                               data_component_interpretation); 
    } 

    Vector<float> subdomain(triangulation.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      subdomain(i) = triangulation.locally_owned_subdomain(); 
    data_out.add_data_vector(subdomain, "subdomain"); 

    data_out.build_patches(); 

    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", cycle, mpi_communicator, 2); 
  } 

  template <int dim> 
  void StokesProblem<dim>::run() 
  { 
#ifdef USE_PETSC_LA 
    pcout << "Running using PETSc." << std::endl; 
#else 
    pcout << "Running using Trilinos." << std::endl; 
#endif 
    const unsigned int n_cycles = 5; 
    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle) 
      { 
        pcout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          make_grid(); 
        else 
          refine_grid(); 

        setup_system(); 

        assemble_system(); 
        solve(); 

        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32) 
          { 
            TimerOutput::Scope t(computing_timer, "output"); 
            output_results(cycle); 
          } 

        computing_timer.print_summary(); 
        computing_timer.reset(); 

        pcout << std::endl; 
      } 
  } 
} // namespace Step55 

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step55; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      StokesProblem<2> problem(2); 
      problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-56.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2016 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * Author: Ryan Grove, Clemson University 
 *         Timo Heister, Clemson University 
 */ 


// @sect3{Include files}  
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/block_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_gmres.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <deal.II/lac/sparse_direct.h> 

#include <deal.II/lac/sparse_ilu.h> 
#include <deal.II/grid/grid_out.h> 

// 我们需要包括以下文件来做计时。

#include <deal.II/base/timer.h> 

// 这包括我们使用几何多网格所需的文件

#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_matrix.h> 

#include <iostream> 
#include <fstream> 

namespace Step56 
{ 
  using namespace dealii; 

// 为了便于在所使用的不同求解器之间进行切换，我们声明了一个枚举，可以作为参数传递给主类的构造函数。

  enum class SolverType 
  { 
    FGMRES_ILU, 
    FGMRES_GMG, 
    UMFPACK 
  }; 
// @sect3{Functions for Solution and Righthand side}  

//Solution类用于定义边界条件和计算数值解的误差。请注意，我们需要定义数值和梯度，以便计算L2和H1误差。在这里，我们决定使用模板的特殊化来分离2D和3D的实现。

// 请注意，前几个分量是速度分量，最后一个分量是压力。

  template <int dim> 
  class Solution : public Function<dim> 
  { 
  public: 
    Solution() 
      : Function<dim>(dim + 1) 
    {} 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
    virtual Tensor<1, dim> 
    gradient(const Point<dim> & p, 
             const unsigned int component = 0) const override; 
  }; 

  template <> 
  double Solution<2>::value(const Point<2> &   p, 
                            const unsigned int component) const 
  { 
    Assert(component <= 2 + 1, ExcIndexRange(component, 0, 2 + 1)); 

    using numbers::PI; 
    const double x = p(0); 
    const double y = p(1); 

    if (component == 0) 
      return sin(PI * x); 
    if (component == 1) 
      return -PI * y * cos(PI * x); 
    if (component == 2) 
      return sin(PI * x) * cos(PI * y); 

    return 0; 
  } 

  template <> 
  double Solution<3>::value(const Point<3> &   p, 
                            const unsigned int component) const 
  { 
    Assert(component <= 3 + 1, ExcIndexRange(component, 0, 3 + 1)); 

    using numbers::PI; 
    const double x = p(0); 
    const double y = p(1); 
    const double z = p(2); 

    if (component == 0) 
      return 2.0 * sin(PI * x); 
    if (component == 1) 
      return -PI * y * cos(PI * x); 
    if (component == 2) 
      return -PI * z * cos(PI * x); 
    if (component == 3) 
      return sin(PI * x) * cos(PI * y) * sin(PI * z); 

    return 0; 
  } 

// 注意，对于梯度，我们需要返回一个Tensor<1,dim>。

  template <> 
  Tensor<1, 2> Solution<2>::gradient(const Point<2> &   p, 
                                     const unsigned int component) const 
  { 
    Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1)); 

    using numbers::PI; 
    const double x = p(0); 
    const double y = p(1); 

    Tensor<1, 2> return_value; 
    if (component == 0) 
      { 
        return_value[0] = PI * cos(PI * x); 
        return_value[1] = 0.0; 
      } 
    else if (component == 1) 
      { 
        return_value[0] = y * PI * PI * sin(PI * x); 
        return_value[1] = -PI * cos(PI * x); 
      } 
    else if (component == 2) 
      { 
        return_value[0] = PI * cos(PI * x) * cos(PI * y); 
        return_value[1] = -PI * sin(PI * x) * sin(PI * y); 
      } 

    return return_value; 
  } 

  template <> 
  Tensor<1, 3> Solution<3>::gradient(const Point<3> &   p, 
                                     const unsigned int component) const 
  { 
    Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1)); 

    using numbers::PI; 
    const double x = p(0); 
    const double y = p(1); 
    const double z = p(2); 

    Tensor<1, 3> return_value; 
    if (component == 0) 
      { 
        return_value[0] = 2 * PI * cos(PI * x); 
        return_value[1] = 0.0; 
        return_value[2] = 0.0; 
      } 
    else if (component == 1) 
      { 
        return_value[0] = y * PI * PI * sin(PI * x); 
        return_value[1] = -PI * cos(PI * x); 
        return_value[2] = 0.0; 
      } 
    else if (component == 2) 
      { 
        return_value[0] = z * PI * PI * sin(PI * x); 
        return_value[1] = 0.0; 
        return_value[2] = -PI * cos(PI * x); 
      } 
    else if (component == 3) 
      { 
        return_value[0] = PI * cos(PI * x) * cos(PI * y) * sin(PI * z); 
        return_value[1] = -PI * sin(PI * x) * sin(PI * y) * sin(PI * z); 
        return_value[2] = PI * sin(PI * x) * cos(PI * y) * cos(PI * z); 
      } 

    return return_value; 
  } 

// 实现  $f$  。更多信息请参见介绍。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide() 
      : Function<dim>(dim + 1) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <> 
  double RightHandSide<2>::value(const Point<2> &   p, 
                                 const unsigned int component) const 
  { 
    Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1)); 

    using numbers::PI; 
    double x = p(0); 
    double y = p(1); 
    if (component == 0) 
      return PI * PI * sin(PI * x) + PI * cos(PI * x) * cos(PI * y); 
    if (component == 1) 
      return -PI * PI * PI * y * cos(PI * x) - PI * sin(PI * y) * sin(PI * x); 
    if (component == 2) 
      return 0; 

    return 0; 
  } 

  template <> 
  double RightHandSide<3>::value(const Point<3> &   p, 
                                 const unsigned int component) const 
  { 
    Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1)); 

    using numbers::PI; 
    double x = p(0); 
    double y = p(1); 
    double z = p(2); 
    if (component == 0) 
      return 2 * PI * PI * sin(PI * x) + 
             PI * cos(PI * x) * cos(PI * y) * sin(PI * z); 
    if (component == 1) 
      return -PI * PI * PI * y * cos(PI * x) + 
             PI * (-1) * sin(PI * y) * sin(PI * x) * sin(PI * z); 
    if (component == 2) 
      return -PI * PI * PI * z * cos(PI * x) + 
             PI * cos(PI * z) * sin(PI * x) * cos(PI * y); 
    if (component == 3) 
      return 0; 

    return 0; 
  } 

//  @sect3{ASPECT BlockSchurPreconditioner}  

// 在下文中，我们将实现一个预处理程序，它扩展了  step-22  的结果部分所讨论的想法。具体来说，我们1.使用一个上块三角的预处理器，因为我们想使用右预处理。2.可选择允许对速度块使用内部求解器，而不是使用单一的预处理程序。3.不使用InverseMatrix，而是明确地调用SolverCG。这种方法也用于ASPECT代码（见https:aspect.geodynamics.org），该代码在模拟地幔对流的背景下求解斯托克斯方程，该代码已被用于解决成千上万个处理器上的问题。

//构造函数中的bool标志 @p do_solve_A 允许我们对速度块应用一次预处理，或者使用内部迭代求解器来代替更精确的近似。

// 注意我们是如何跟踪内部迭代的总和（预处理程序的应用）的。

  template <class PreconditionerAType, class PreconditionerSType> 
  class BlockSchurPreconditioner : public Subscriptor 
  { 
  public: 
    BlockSchurPreconditioner( 
      const BlockSparseMatrix<double> &system_matrix, 
      const SparseMatrix<double> &     schur_complement_matrix, 
      const PreconditionerAType &      preconditioner_A, 
      const PreconditionerSType &      preconditioner_S, 
 

    void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const; 

    mutable unsigned int n_iterations_A; 
    mutable unsigned int n_iterations_S; 

  private: 
    const BlockSparseMatrix<double> &system_matrix; 
    const SparseMatrix<double> &     schur_complement_matrix; 
    const PreconditionerAType &      preconditioner_A; 
    const PreconditionerSType &      preconditioner_S; 

    const bool do_solve_A; 
  }; 

  template <class PreconditionerAType, class PreconditionerSType> 
  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>:: 
    BlockSchurPreconditioner( 
      const BlockSparseMatrix<double> &system_matrix, 
      const SparseMatrix<double> &     schur_complement_matrix, 
      const PreconditionerAType &      preconditioner_A, 
      const PreconditionerSType &      preconditioner_S, 
      const bool                       do_solve_A) 
    : n_iterations_A(0)  
    , n_iterations_S(0) 
    , system_matrix(system_matrix) 
    , schur_complement_matrix(schur_complement_matrix) 
    , preconditioner_A(preconditioner_A) 
    , preconditioner_S(preconditioner_S) 
    , do_solve_A(do_solve_A) 
  {} 

  template <class PreconditionerAType, class PreconditionerSType> 
  void 
  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::vmult( 
    BlockVector<double> &      dst, 
    const BlockVector<double> &src) const 
  { 
    Vector<double> utmp(src.block(0)); 

// 首先用S的近似值求解

    { 
      SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm()); 
      SolverCG<Vector<double>> cg(solver_control); 

      dst.block(1) = 0.0; 
      cg.solve(schur_complement_matrix, 
               dst.block(1), 
               src.block(1), 
               preconditioner_S); 

      n_iterations_S += solver_control.last_step(); 
      dst.block(1) *= -1.0; 
    } 

// 第二，应用右上方的块（B^T

    { 
      system_matrix.block(0, 1).vmult(utmp, dst.block(1)); 
      utmp *= -1.0; 
      utmp += src.block(0); 
    } 

// 最后，要么用左上角的块求解，要么只应用一个预设条件器扫频

    if (do_solve_A == true) 
      { 
        SolverControl            solver_control(10000, utmp.l2_norm() * 1e-4); 
        SolverCG<Vector<double>> cg(solver_control); 

        dst.block(0) = 0.0; 
        cg.solve(system_matrix.block(0, 0), 
                 dst.block(0), 
                 utmp, 
                 preconditioner_A); 

        n_iterations_A += solver_control.last_step(); 
      } 
    else 
      { 
        preconditioner_A.vmult(dst.block(0), utmp); 
        n_iterations_A += 1; 
      } 
  } 
// @sect3{The StokesProblem class}  

// 这是该问题的主类。

  template <int dim> 
  class StokesProblem 
  { 
  public: 
    StokesProblem(const unsigned int pressure_degree, 
                  const SolverType   solver_type); 
    void run(); 

  private: 
    void setup_dofs(); 
    void assemble_system(); 
    void assemble_multigrid(); 
    void solve(); 
    void compute_errors(); 
    void output_results(const unsigned int refinement_cycle) const; 

    const unsigned int pressure_degree; 
    const SolverType   solver_type; 

    Triangulation<dim> triangulation; 
    FESystem<dim>      velocity_fe; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 
    DoFHandler<dim>    velocity_dof_handler; 

    AffineConstraints<double> constraints; 

    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> system_matrix; 
    SparseMatrix<double>      pressure_mass_matrix; 

    BlockVector<double> solution; 
    BlockVector<double> system_rhs; 

    MGLevelObject<SparsityPattern>      mg_sparsity_patterns; 
    MGLevelObject<SparseMatrix<double>> mg_matrices; 
    MGLevelObject<SparseMatrix<double>> mg_interface_matrices; 
    MGConstrainedDoFs                   mg_constrained_dofs; 

    TimerOutput computing_timer; 
  }; 

  template <int dim> 
  StokesProblem<dim>::StokesProblem(const unsigned int pressure_degree, 
                                    const SolverType   solver_type) 

    : pressure_degree(pressure_degree) 
    , solver_type(solver_type) 
    , triangulation(Triangulation<dim>::maximum_smoothing) 
    , 

// 仅为速度的有限元。

    velocity_fe(FE_Q<dim>(pressure_degree + 1), dim) 
    , 

// 整个系统的有限元。

    fe(velocity_fe, 1, FE_Q<dim>(pressure_degree), 1) 
    , dof_handler(triangulation) 
    , velocity_dof_handler(triangulation) 
    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times) 
  {} 

//  @sect4{StokesProblem::setup_dofs}  

// 这个函数设置了DoFHandler、矩阵、向量和Multigrid结构（如果需要）。

  template <int dim> 
  void StokesProblem<dim>::setup_dofs() 
  { 
    TimerOutput::Scope scope(computing_timer, "Setup"); 

    system_matrix.clear(); 
    pressure_mass_matrix.clear(); 

// 主DoFHandler只需要活动的DoF，所以我们不在这里调用distribution_mg_dofs()

    dof_handler.distribute_dofs(fe); 

// 这个块结构将dim速度分量与压力分量（用于重新排序）分开。注意，我们有2个而不是像 step-22 中的dim+1块，因为我们的FESystem是嵌套的，dim速度分量作为一个块出现。

    std::vector<unsigned int> block_component(2); 
    block_component[0] = 0; 
    block_component[1] = 1; 

// 速度从组件0开始。

    const FEValuesExtractors::Vector velocities(0); 

如果我们应用重新排序来减少填充，//ILU的表现会更好。对于其他求解器来说，这样做并没有什么好处。

    if (solver_type == SolverType::FGMRES_ILU) 
      { 
        TimerOutput::Scope ilu_specific(computing_timer, "(ILU specific)"); 
        DoFRenumbering::Cuthill_McKee(dof_handler); 
      } 

// 这确保了所有的速度DoFs在压力未知数之前被列举出来。这允许我们使用块来处理向量和矩阵，并允许我们为dof_handler和velocity_dof_handler获得相同的DoF编号。

    DoFRenumbering::block_wise(dof_handler); 

    if (solver_type == SolverType::FGMRES_GMG) 
      { 
        TimerOutput::Scope multigrid_specific(computing_timer, 
                                              "(Multigrid specific)"); 
        TimerOutput::Scope setup_multigrid(computing_timer, 
                                           "Setup - Multigrid"); 

// 这将在一个单独的DoFHandler中分配速度空间的主动道夫和多网格道夫，如介绍中所述。

        velocity_dof_handler.distribute_dofs(velocity_fe); 
        velocity_dof_handler.distribute_mg_dofs(); 

// 下面的代码块初始化了MGConstrainedDofs（使用速度的边界条件），以及每个层次的稀疏模式和矩阵。MGLevelObject<T>的resize()函数将破坏所有现有的包含对象。

        std::set<types::boundary_id> zero_boundary_ids; 
        zero_boundary_ids.insert(0); 

        mg_constrained_dofs.clear(); 
        mg_constrained_dofs.initialize(velocity_dof_handler); 
        mg_constrained_dofs.make_zero_boundary_constraints(velocity_dof_handler, 
                                                           zero_boundary_ids); 
        const unsigned int n_levels = triangulation.n_levels(); 

        mg_interface_matrices.resize(0, n_levels - 1); 
        mg_matrices.resize(0, n_levels - 1); 
        mg_sparsity_patterns.resize(0, n_levels - 1); 

        for (unsigned int level = 0; level < n_levels; ++level) 
          { 
            DynamicSparsityPattern csp(velocity_dof_handler.n_dofs(level), 
                                       velocity_dof_handler.n_dofs(level)); 
            MGTools::make_sparsity_pattern(velocity_dof_handler, csp, level); 
            mg_sparsity_patterns[level].copy_from(csp); 

            mg_matrices[level].reinit(mg_sparsity_patterns[level]); 
            mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]); 
          } 
      } 

    const std::vector<types::global_dof_index> dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, block_component); 
    const unsigned int n_u = dofs_per_block[0]; 
    const unsigned int n_p = dofs_per_block[1]; 

    { 
      constraints.clear(); 

// 下面利用分量掩码对速度的边界值进行插值，这在矢量值dealii  step-20 教程中进一步说明。

      DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               Solution<dim>(), 
                                               constraints, 
                                               fe.component_mask(velocities)); 

// 正如在介绍中所讨论的，我们需要固定压力变量的一个自由度以确保问题的可解性。在这里，我们将第一个压力自由度标记为受限自由度，该自由度的索引为n_u。

      if (solver_type == SolverType::UMFPACK) 
        constraints.add_line(n_u); 

      constraints.close(); 
    } 

    std::cout << "\tNumber of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "\tNumber of degrees of freedom: " << dof_handler.n_dofs() 
              << " (" << n_u << '+' << n_p << ')' << std::endl; 

    { 
      BlockDynamicSparsityPattern csp(dofs_per_block, dofs_per_block); 
      DoFTools::make_sparsity_pattern(dof_handler, csp, constraints, false); 
      sparsity_pattern.copy_from(csp); 
    } 
    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dofs_per_block); 
    system_rhs.reinit(dofs_per_block); 
  } 
// @sect4{StokesProblem::assemble_system}  

// 在这个函数中，系统矩阵被组装起来。我们在(1,1)块中组装压力质量矩阵（如果需要），并在此函数结束时将其移出此位置。

  template <int dim> 
  void StokesProblem<dim>::assemble_system() 
  { 
    TimerOutput::Scope assemble(computing_timer, "Assemble"); 
    system_matrix = 0; 
    system_rhs    = 0; 

// 如果为真，我们将在(1,1)块中装配压力质量矩阵。

    const bool assemble_pressure_mass_matrix = 
      (solver_type == SolverType::UMFPACK) ? false : true; 

    QGauss<dim> quadrature_formula(pressure_degree + 2); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values | update_gradients); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

    const unsigned int n_q_points = quadrature_formula.size(); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const RightHandSide<dim>    right_hand_side; 
    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1)); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell); 
    std::vector<double>                  div_phi_u(dofs_per_cell); 
    std::vector<double>                  phi_p(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        local_matrix = 0; 
        local_rhs    = 0; 

        right_hand_side.vector_value_list(fe_values.get_quadrature_points(), 
                                          rhs_values); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                symgrad_phi_u[k] = 
                  fe_values[velocities].symmetric_gradient(k, q); 
                div_phi_u[k] = fe_values[velocities].divergence(k, q); 
                phi_p[k]     = fe_values[pressure].value(k, q); 
              } 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              { 
                for (unsigned int j = 0; j <= i; ++j) 
                  { 
                    local_matrix(i, j) += 
                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) - 
                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] + 
                       (assemble_pressure_mass_matrix ? phi_p[i] * phi_p[j] : 
                                                        0)) * 
                      fe_values.JxW(q); 
                  } 

                const unsigned int component_i = 
                  fe.system_to_component_index(i).first; 
                local_rhs(i) += fe_values.shape_value(i, q) * 
                                rhs_values[q](component_i) * fe_values.JxW(q); 
              } 
          } 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = i + 1; j < dofs_per_cell; ++j) 
            local_matrix(i, j) = local_matrix(j, i); 

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global(local_matrix, 
                                               local_rhs, 
                                               local_dof_indices, 
                                               system_matrix, 
                                               system_rhs); 
      } 

    if (solver_type != SolverType::UMFPACK) 
      { 
        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1)); 
        pressure_mass_matrix.copy_from(system_matrix.block(1, 1)); 
        system_matrix.block(1, 1) = 0; 
      } 
  } 
// @sect4{StokesProblem::assemble_multigrid}  

// 在这里，与 step-16 中一样，我们有一个函数，用于组装多网格预处理程序所需的水平矩阵和界面矩阵。

  template <int dim> 
  void StokesProblem<dim>::assemble_multigrid() 
  { 
    TimerOutput::Scope multigrid_specific(computing_timer, 
                                          "(Multigrid specific)"); 
    TimerOutput::Scope assemble_multigrid(computing_timer, 
                                          "Assemble Multigrid"); 

    mg_matrices = 0.; 

    QGauss<dim> quadrature_formula(pressure_degree + 2); 

    FEValues<dim> fe_values(velocity_fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values | update_gradients); 

    const unsigned int dofs_per_cell = velocity_fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    const FEValuesExtractors::Vector velocities(0); 

    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell); 

    std::vector<AffineConstraints<double>> boundary_constraints( 
      triangulation.n_levels()); 
    std::vector<AffineConstraints<double>> boundary_interface_constraints( 
      triangulation.n_levels()); 
    for (unsigned int level = 0; level < triangulation.n_levels(); ++level) 
      { 
        boundary_constraints[level].add_lines( 
          mg_constrained_dofs.get_refinement_edge_indices(level)); 
        boundary_constraints[level].add_lines( 
          mg_constrained_dofs.get_boundary_indices(level)); 
        boundary_constraints[level].close(); 

        IndexSet idx = mg_constrained_dofs.get_refinement_edge_indices(level) & 
                       mg_constrained_dofs.get_boundary_indices(level); 

        boundary_interface_constraints[level].add_lines(idx); 
        boundary_interface_constraints[level].close(); 
      } 

// 这个迭代器会覆盖所有的单元格（不仅仅是活动的）。

    for (const auto &cell : velocity_dof_handler.cell_iterators()) 
      { 
        fe_values.reinit(cell); 
        cell_matrix = 0; 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient(k, q); 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              for (unsigned int j = 0; j <= i; ++j) 
                { 
                  cell_matrix(i, j) += 
                    (symgrad_phi_u[i] * symgrad_phi_u[j]) * fe_values.JxW(q); 
                } 
          } 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = i + 1; j < dofs_per_cell; ++j) 
            cell_matrix(i, j) = cell_matrix(j, i); 

        cell->get_mg_dof_indices(local_dof_indices); 

        boundary_constraints[cell->level()].distribute_local_to_global( 
          cell_matrix, local_dof_indices, mg_matrices[cell->level()]); 

        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            if (!mg_constrained_dofs.at_refinement_edge(cell->level(), 
                                                        local_dof_indices[i]) || 
                mg_constrained_dofs.at_refinement_edge(cell->level(), 
                                                       local_dof_indices[j])) 
              cell_matrix(i, j) = 0; 

        boundary_interface_constraints[cell->level()] 
          .distribute_local_to_global(cell_matrix, 
                                      local_dof_indices, 
                                      mg_interface_matrices[cell->level()]); 
      } 
  } 
// @sect4{StokesProblem::solve}  

// 这个函数根据你想使用ILU或GMG作为预处理程序的情况进行不同的设置。 这两种方法共享相同的求解器（FGMRES），但需要初始化不同的预处理器。在这里，我们不仅为整个求解函数计时，还为预处理程序的设置以及求解本身分别计时。

  template <int dim> 
  void StokesProblem<dim>::solve() 
  { 
    TimerOutput::Scope solve(computing_timer, "Solve"); 
    constraints.set_zero(solution); 

    if (solver_type == SolverType::UMFPACK) 
      { 
        computing_timer.enter_subsection("(UMFPACK specific)"); 
        computing_timer.enter_subsection("Solve - Initialize"); 

        SparseDirectUMFPACK A_direct; 
        A_direct.initialize(system_matrix); 

        computing_timer.leave_subsection(); 
        computing_timer.leave_subsection(); 

        { 
          TimerOutput::Scope solve_backslash(computing_timer, 
                                             "Solve - Backslash"); 
          A_direct.vmult(solution, system_rhs); 
        } 

        constraints.distribute(solution); 
        return; 
      } 

// 这里我们必须确保以 "足够好 "的精度求解残差

    SolverControl solver_control(system_matrix.m(), 
                                 1e-10 * system_rhs.l2_norm()); 
    unsigned int  n_iterations_A; 
    unsigned int  n_iterations_S; 

// 这是用来传递我们是否要在预处理程序中解决A的问题。 我们可以把它改为false，看看是否还能收敛，如果能收敛，那么程序的运行速度是快是慢？

    const bool use_expensive = true; 

    SolverFGMRES<BlockVector<double>> solver(solver_control); 

    if (solver_type == SolverType::FGMRES_ILU) 
      { 
        computing_timer.enter_subsection("(ILU specific)"); 
        computing_timer.enter_subsection("Solve - Set-up Preconditioner"); 

        std::cout << "   Computing preconditioner..." << std::endl 
                  << std::flush; 

        SparseILU<double> A_preconditioner; 
        A_preconditioner.initialize(system_matrix.block(0, 0)); 

        SparseILU<double> S_preconditioner; 
        S_preconditioner.initialize(pressure_mass_matrix); 

        const BlockSchurPreconditioner<SparseILU<double>, SparseILU<double>> 
          preconditioner(system_matrix, 
                         pressure_mass_matrix, 
                         A_preconditioner, 
                         S_preconditioner, 
                         use_expensive); 

        computing_timer.leave_subsection(); 
        computing_timer.leave_subsection(); 

        { 
          TimerOutput::Scope solve_fmgres(computing_timer, "Solve - FGMRES"); 

          solver.solve(system_matrix, solution, system_rhs, preconditioner); 
          n_iterations_A = preconditioner.n_iterations_A; 
          n_iterations_S = preconditioner.n_iterations_S; 
        } 
      } 
    else 
      { 
        computing_timer.enter_subsection("(Multigrid specific)"); 
        computing_timer.enter_subsection("Solve - Set-up Preconditioner"); 

// 在各级之间转移运算符

        MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs); 
        mg_transfer.build(velocity_dof_handler); 

// 设置粗略的网格解算器

        FullMatrix<double> coarse_matrix; 
        coarse_matrix.copy_from(mg_matrices[0]); 
        MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver; 
        coarse_grid_solver.initialize(coarse_matrix); 

        using Smoother = PreconditionSOR<SparseMatrix<double>>; 
        mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother; 
        mg_smoother.initialize(mg_matrices); 
        mg_smoother.set_steps(2); 

// Multigrid作为CG的预处理程序时，需要是一个对称的运算器，所以平滑器必须是对称的

        mg_smoother.set_symmetric(true); 

        mg::Matrix<Vector<double>> mg_matrix(mg_matrices); 
        mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices); 
        mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices); 

// 现在，我们准备设置V型循环算子和多级预处理程序。

        Multigrid<Vector<double>> mg( 
          mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother); 
        mg.set_edge_matrices(mg_interface_down, mg_interface_up); 

        PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>> 
          A_Multigrid(velocity_dof_handler, mg, mg_transfer); 

        SparseILU<double> S_preconditioner; 
        S_preconditioner.initialize(pressure_mass_matrix, 
                                    SparseILU<double>::AdditionalData()); 

        const BlockSchurPreconditioner< 
          PreconditionMG<dim, 
                         Vector<double>, 
                         MGTransferPrebuilt<Vector<double>>>, 
          SparseILU<double>> 
          preconditioner(system_matrix, 
                         pressure_mass_matrix, 
                         A_Multigrid, 
                         S_preconditioner, 
                         use_expensive); 

        computing_timer.leave_subsection(); 
        computing_timer.leave_subsection(); 

        { 
          TimerOutput::Scope solve_fmgres(computing_timer, "Solve - FGMRES"); 
          solver.solve(system_matrix, solution, system_rhs, preconditioner); 
          n_iterations_A = preconditioner.n_iterations_A; 
          n_iterations_S = preconditioner.n_iterations_S; 
        } 
      } 

    constraints.distribute(solution); 

    std::cout 
      << std::endl 
      << "\tNumber of FGMRES iterations: " << solver_control.last_step() 
      << std::endl 
      << "\tTotal number of iterations used for approximation of A inverse: " 
      << n_iterations_A << std::endl 
      << "\tTotal number of iterations used for approximation of S inverse: " 
      << n_iterations_S << std::endl 
      << std::endl; 
  } 
// @sect4{StokesProblem::process_solution}  

// 这个函数计算出解决方案的L2和H1误差。为此，我们需要确保压力的平均值为零。

  template <int dim> 
  void StokesProblem<dim>::compute_errors() 
  { 

// 计算平均压力 $\frac{1}{\Omega} \int_{\Omega} p(x) dx $ ，然后从每个压力系数中减去它。这将产生一个平均值为零的压力。这里我们利用了压力是分量 $dim$ 和有限元空间是结点的事实。

    const double mean_pressure = VectorTools::compute_mean_value( 
      dof_handler, QGauss<dim>(pressure_degree + 2), solution, dim); 
    solution.block(1).add(-mean_pressure); 
    std::cout << "   Note: The mean value was adjusted by " << -mean_pressure 
              << std::endl; 

    const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1); 
    const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim), 
                                                     dim + 1); 

    Vector<float> difference_per_cell(triangulation.n_active_cells()); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(pressure_degree + 2), 
                                      VectorTools::L2_norm, 
                                      &velocity_mask); 

    const double Velocity_L2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(pressure_degree + 2), 
                                      VectorTools::L2_norm, 
                                      &pressure_mask); 

    const double Pressure_L2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(pressure_degree + 2), 
                                      VectorTools::H1_norm, 
                                      &velocity_mask); 

    const double Velocity_H1_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::H1_norm); 

    std::cout << std::endl 
              << "   Velocity L2 Error: " << Velocity_L2_error << std::endl 
              << "   Pressure L2 Error: " << Pressure_L2_error << std::endl 
              << "   Velocity H1 Error: " << Velocity_H1_error << std::endl; 
  } 
// @sect4{StokesProblem::output_results}  

// 这个函数生成图形输出，就像在  step-22  中所做的那样。

  template <int dim> 
  void 
  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("pressure"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.build_patches(); 

    std::ofstream output( 
      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk"); 
    data_out.write_vtk(output); 
  } 

//  @sect4{StokesProblem::run}  

// 斯托克斯类的最后一步是像往常一样，生成初始网格的函数，并按各自的顺序调用其他函数。

  template <int dim> 
  void StokesProblem<dim>::run() 
  { 
    GridGenerator::hyper_cube(triangulation); 
    triangulation.refine_global(6 - dim); 

    if (solver_type == SolverType::FGMRES_ILU) 
      std::cout << "Now running with ILU" << std::endl; 
    else if (solver_type == SolverType::FGMRES_GMG) 
      std::cout << "Now running with Multigrid" << std::endl; 
    else 
      std::cout << "Now running with UMFPACK" << std::endl; 

    for (unsigned int refinement_cycle = 0; refinement_cycle < 3; 
         ++refinement_cycle) 
      { 
        std::cout << "Refinement cycle " << refinement_cycle << std::endl; 

        if (refinement_cycle > 0) 
          triangulation.refine_global(1); 

        std::cout << "   Set-up..." << std::endl; 
        setup_dofs(); 

        std::cout << "   Assembling..." << std::endl; 
        assemble_system(); 

        if (solver_type == SolverType::FGMRES_GMG) 
          { 
            std::cout << "   Assembling Multigrid..." << std::endl; 

            assemble_multigrid(); 
          } 

        std::cout << "   Solving..." << std::flush; 
        solve(); 

        compute_errors(); 

        output_results(refinement_cycle); 

        Utilities::System::MemoryStats mem; 
        Utilities::System::get_memory_stats(mem); 
        std::cout << "   VM Peak: " << mem.VmPeak << std::endl; 

        computing_timer.print_summary(); 
        computing_timer.reset(); 
      } 
  } 
} // namespace Step56 
// @sect3{The main function}  
int main() 
{ 
  try 
    { 
      using namespace Step56; 

      const int degree = 1; 
      const int dim    = 3; 

// SolverType的选项。umfpack fgmres_ilu fgmres_gmg

      StokesProblem<dim> flow_problem(degree, SolverType::FGMRES_GMG); 

      flow_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-57.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2008 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Liang Zhao and Timo Heister, Clemson University, 2016 
 */ 


// @sect3{Include files}  

// 像往常一样，我们从包括一些著名的文件开始。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/tensor.h> 

#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/grid_tools.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 为了在网格之间传输解决方案，包括这个文件。

#include <deal.II/numerics/solution_transfer.h> 

// 这个文件包括UMFPACK：直接求解器。

#include <deal.II/lac/sparse_direct.h> 

// 还有一个ILU预处理程序。

#include <deal.II/lac/sparse_ilu.h> 

#include <fstream> 
#include <iostream> 

namespace Step57 
{ 
  using namespace dealii; 
// @sect3{The <code>NavierStokesProblem</code> class template}  

// 该类管理介绍中描述的矩阵和向量：特别是，我们为当前的解决方案、当前的牛顿更新和直线搜索更新存储了一个BlockVector。 我们还存储了两个AffineConstraints对象：一个是强制执行Dirichlet边界条件的对象，另一个是将所有边界值设为0的对象。第一个约束解向量，第二个约束更新（也就是说，我们从不更新边界值，所以我们强制相关的更新向量值为零）。

  template <int dim> 
  class StationaryNavierStokes 
  { 
  public: 
    StationaryNavierStokes(const unsigned int degree); 
    void run(const unsigned int refinement); 

  private: 
    void setup_dofs(); 

    void initialize_system(); 

    void assemble(const bool initial_step, const bool assemble_matrix); 

    void assemble_system(const bool initial_step); 

    void assemble_rhs(const bool initial_step); 

    void solve(const bool initial_step); 

    void refine_mesh(); 

    void process_solution(unsigned int refinement); 

    void output_results(const unsigned int refinement_cycle) const; 

    void newton_iteration(const double       tolerance, 
                          const unsigned int max_n_line_searches, 
                          const unsigned int max_n_refinements, 
                          const bool         is_initial_step, 
                          const bool         output_result); 

    void compute_initial_guess(double step_size); 

    double                               viscosity; 
    double                               gamma; 
    const unsigned int                   degree; 
    std::vector<types::global_dof_index> dofs_per_block; 

    Triangulation<dim> triangulation; 
    FESystem<dim>      fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> zero_constraints; 
    AffineConstraints<double> nonzero_constraints; 

    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> system_matrix; 
    SparseMatrix<double>      pressure_mass_matrix; 

    BlockVector<double> present_solution; 
    BlockVector<double> newton_update; 
    BlockVector<double> system_rhs; 
    BlockVector<double> evaluation_point; 
  }; 
// @sect3{Boundary values and right hand side}  

// 在这个问题中，我们设定沿空腔上表面的速度为1，其他三面墙的速度为0。右边的函数为零，所以我们在本教程中不需要设置右边的函数。边界函数的分量数为  <code>dim+1</code>  。我们最终将使用 VectorTools::interpolate_boundary_values 来设置边界值，这就要求边界值函数的分量数与解相同，即使没有全部使用。换个说法：为了让这个函数高兴，我们为压力定义了边界值，尽管我们实际上永远不会用到它们。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    BoundaryValues() 
      : Function<dim>(dim + 1) 
    {} 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & p, 
                                    const unsigned int component) const 
  { 
    Assert(component < this->n_components, 
           ExcIndexRange(component, 0, this->n_components)); 
    if (component == 0 && std::abs(p[dim - 1] - 1.0) < 1e-10) 
      return 1.0; 

    return 0; 
  } 
// @sect3{BlockSchurPreconditioner for Navier Stokes equations}  

// 正如介绍中所讨论的，Krylov迭代方法中的预处理器是作为一个矩阵-向量乘积算子实现的。在实践中，舒尔补码预处理器被分解为三个矩阵的乘积（如第一节所述）。第一个因素中的 $\tilde{A}^{-1}$ 涉及到对线性系统 $\tilde{A}x=b$ 的求解。在这里，为了简单起见，我们通过一个直接求解器来解决这个系统。第二个因素中涉及的计算是一个简单的矩阵-向量乘法。舒尔补码 $\tilde{S}$ 可以被压力质量矩阵很好地近似，其逆值可以通过不精确求解器得到。因为压力质量矩阵是对称和正定的，我们可以用CG来解决相应的线性系统。

  template <class PreconditionerMp> 
  class BlockSchurPreconditioner : public Subscriptor 
  { 
  public: 
    BlockSchurPreconditioner(double                           gamma, 
                             double                           viscosity, 
                             const BlockSparseMatrix<double> &S, 
                             const SparseMatrix<double> &     P, 
                             const PreconditionerMp &         Mppreconditioner); 

    void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const; 

  private: 
    const double                     gamma; 
    const double                     viscosity; 
    const BlockSparseMatrix<double> &stokes_matrix; 
    const SparseMatrix<double> &     pressure_mass_matrix; 
    const PreconditionerMp &         mp_preconditioner; 
    SparseDirectUMFPACK              A_inverse; 
  }; 

// 我们可以注意到，左上角的矩阵逆的初始化是在构造函数中完成的。如果是这样，那么预处理程序的每一次应用就不再需要计算矩阵因子了。

  template <class PreconditionerMp> 
  BlockSchurPreconditioner<PreconditionerMp>::BlockSchurPreconditioner( 
    double                           gamma, 
    double                           viscosity, 
    const BlockSparseMatrix<double> &S, 
    const SparseMatrix<double> &     P, 
    const PreconditionerMp &         Mppreconditioner) 
    : gamma(gamma) 
    , viscosity(viscosity) 
    , stokes_matrix(S) 
    , pressure_mass_matrix(P) 
    , mp_preconditioner(Mppreconditioner) 
  { 
    A_inverse.initialize(stokes_matrix.block(0, 0)); 
  } 

  template <class PreconditionerMp> 
  void BlockSchurPreconditioner<PreconditionerMp>::vmult( 
    BlockVector<double> &      dst, 
    const BlockVector<double> &src) const 
  { 
    Vector<double> utmp(src.block(0)); 

    { 
      SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm()); 
      SolverCG<Vector<double>> cg(solver_control); 

      dst.block(1) = 0.0; 
      cg.solve(pressure_mass_matrix, 
               dst.block(1), 
               src.block(1), 
               mp_preconditioner); 
      dst.block(1) *= -(viscosity + gamma); 
    } 

    { 
      stokes_matrix.block(0, 1).vmult(utmp, dst.block(1)); 
      utmp *= -1.0; 
      utmp += src.block(0); 
    } 

    A_inverse.vmult(dst.block(0), utmp); 
  } 
// @sect3{StationaryNavierStokes class implementation}  
// @sect4{StationaryNavierStokes::StationaryNavierStokes}  

// 该类的构造函数看起来与  step-22  中的构造函数非常相似。唯一的区别是粘度和增强的拉格朗日系数  <code>gamma</code>  。

  template <int dim> 
  StationaryNavierStokes<dim>::StationaryNavierStokes(const unsigned int degree) 
    : viscosity(1.0 / 7500.0) 
    , gamma(1.0) 
    , degree(degree) 
    , triangulation(Triangulation<dim>::maximum_smoothing) 
    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1) 
    , dof_handler(triangulation) 
  {} 
// @sect4{StationaryNavierStokes::setup_dofs}  

// 这个函数初始化DoFHandler，列举当前网格上的自由度和约束。

  template <int dim> 
  void StationaryNavierStokes<dim>::setup_dofs() 
  { 
    system_matrix.clear(); 
    pressure_mass_matrix.clear(); 

// 第一步是将DoFs与给定的网格联系起来。

    dof_handler.distribute_dofs(fe); 

// 我们对组件重新编号，使所有的速度DoF在压力DoF之前，以便能够将解向量分成两个块，在块预处理程序中分别访问。

    std::vector<unsigned int> block_component(dim + 1, 0); 
    block_component[dim] = 1; 
    DoFRenumbering::component_wise(dof_handler, block_component); 

    dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, block_component); 
    unsigned int dof_u = dofs_per_block[0]; 
    unsigned int dof_p = dofs_per_block[1]; 

// 在牛顿方案中，我们首先将边界条件应用于从初始步骤得到的解。为了确保边界条件在牛顿迭代过程中保持满足，在更新时使用零边界条件  $\delta u^k$  。因此我们设置了两个不同的约束对象。

    FEValuesExtractors::Vector velocities(0); 
    { 
      nonzero_constraints.clear(); 

      DoFTools::make_hanging_node_constraints(dof_handler, nonzero_constraints); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               BoundaryValues<dim>(), 
                                               nonzero_constraints, 
                                               fe.component_mask(velocities)); 
    } 
    nonzero_constraints.close(); 

    { 
      zero_constraints.clear(); 

      DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               Functions::ZeroFunction<dim>( 
                                                 dim + 1), 
                                               zero_constraints, 
                                               fe.component_mask(velocities)); 
    } 
    zero_constraints.close(); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << " (" << dof_u << " + " << dof_p << ')' << std::endl; 
  } 
// @sect4{StationaryNavierStokes::initialize_system}  

// 在每个网格上，SparsityPattern和线性系统的大小是不同的。这个函数在网格细化后初始化它们。

  template <int dim> 
  void StationaryNavierStokes<dim>::initialize_system() 
  { 
    { 
      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block); 
      DoFTools::make_sparsity_pattern(dof_handler, dsp, nonzero_constraints); 
      sparsity_pattern.copy_from(dsp); 
    } 

    system_matrix.reinit(sparsity_pattern); 

    present_solution.reinit(dofs_per_block); 
    newton_update.reinit(dofs_per_block); 
    system_rhs.reinit(dofs_per_block); 
  } 
// @sect4{StationaryNavierStokes::assemble}  

// 这个函数建立了我们目前工作的系统矩阵和右手边。 @p initial_step 参数用于确定我们应用哪一组约束（初始步骤为非零，其他为零）。 @p assemble_matrix 参数分别决定了是组装整个系统还是只组装右手边的向量。

  template <int dim> 
  void StationaryNavierStokes<dim>::assemble(const bool initial_step, 
                                             const bool assemble_matrix) 
  { 
    if (assemble_matrix) 
      system_matrix = 0; 

    system_rhs = 0; 

    QGauss<dim> quadrature_formula(degree + 2); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values | update_gradients); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(dim); 

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     local_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 对于线性化系统，我们为当前速度和梯度以及当前压力创建临时存储。在实践中，它们都是通过正交点的形状函数获得的。

    std::vector<Tensor<1, dim>> present_velocity_values(n_q_points); 
    std::vector<Tensor<2, dim>> present_velocity_gradients(n_q_points); 
    std::vector<double>         present_pressure_values(n_q_points); 

    std::vector<double>         div_phi_u(dofs_per_cell); 
    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell); 
    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell); 
    std::vector<double>         phi_p(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 

        local_matrix = 0; 
        local_rhs    = 0; 

        fe_values[velocities].get_function_values(evaluation_point, 
                                                  present_velocity_values); 

        fe_values[velocities].get_function_gradients( 
          evaluation_point, present_velocity_gradients); 

        fe_values[pressure].get_function_values(evaluation_point, 
                                                present_pressure_values); 

//装配类似于  step-22  。一个以gamma为系数的附加项是增强拉格朗日（AL），它是通过grad-div稳定化组装的。 正如我们在介绍中所讨论的，系统矩阵的右下块应该为零。由于压力质量矩阵是在创建预处理程序时使用的，所以我们在这里组装它，然后在最后把它移到一个单独的SparseMatrix中（与 step-22 相同）。

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                div_phi_u[k]  = fe_values[velocities].divergence(k, q); 
                grad_phi_u[k] = fe_values[velocities].gradient(k, q); 
                phi_u[k]      = fe_values[velocities].value(k, q); 
                phi_p[k]      = fe_values[pressure].value(k, q); 
              } 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              { 
                if (assemble_matrix) 
                  { 
                    for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                      { 
                        local_matrix(i, j) += 
                          (viscosity * 
                             scalar_product(grad_phi_u[j], grad_phi_u[i]) + 
                           present_velocity_gradients[q] * phi_u[j] * phi_u[i] + 
                           grad_phi_u[j] * present_velocity_values[q] * 
                             phi_u[i] - 
                           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] + 
                           gamma * div_phi_u[j] * div_phi_u[i] + 
                           phi_p[i] * phi_p[j]) * 
                          fe_values.JxW(q); 
                      } 
                  } 

                double present_velocity_divergence = 
                  trace(present_velocity_gradients[q]); 
                local_rhs(i) += 
                  (-viscosity * scalar_product(present_velocity_gradients[q], 
                                               grad_phi_u[i]) - 
                   present_velocity_gradients[q] * present_velocity_values[q] * 
                     phi_u[i] + 
                   present_pressure_values[q] * div_phi_u[i] + 
                   present_velocity_divergence * phi_p[i] - 
                   gamma * present_velocity_divergence * div_phi_u[i]) * 
                  fe_values.JxW(q); 
              } 
          } 

        cell->get_dof_indices(local_dof_indices); 

        const AffineConstraints<double> &constraints_used = 
          initial_step ? nonzero_constraints : zero_constraints; 

        if (assemble_matrix) 
          { 
            constraints_used.distribute_local_to_global(local_matrix, 
                                                        local_rhs, 
                                                        local_dof_indices, 
                                                        system_matrix, 
                                                        system_rhs); 
          } 
        else 
          { 
            constraints_used.distribute_local_to_global(local_rhs, 
                                                        local_dof_indices, 
                                                        system_rhs); 
          } 
      } 

    if (assemble_matrix) 
      { 

// 最后我们把压力质量矩阵移到一个单独的矩阵中。

        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1)); 
        pressure_mass_matrix.copy_from(system_matrix.block(1, 1)); 

// 注意，将这个压力块设置为零并不等同于不在这个块中装配任何东西，因为这里的操作将（错误地）删除从压力作用力的悬挂节点约束中进来的对角线条目。这意味着，我们的整个系统矩阵将有完全为零的行。幸运的是，FGMRES处理这些行没有任何问题。

        system_matrix.block(1, 1) = 0; 
      } 
  } 

  template <int dim> 
  void StationaryNavierStokes<dim>::assemble_system(const bool initial_step) 
  { 
    assemble(initial_step, true); 
  } 

  template <int dim> 
  void StationaryNavierStokes<dim>::assemble_rhs(const bool initial_step) 
  { 
    assemble(initial_step, false); 
  } 
// @sect4{StationaryNavierStokes::solve}  

// 在这个函数中，我们使用FGMRES和程序开始时定义的块状预处理程序来解决线性系统。我们在这一步得到的是解向量。如果这是初始步骤，解向量为我们提供了纳维尔-斯托克斯方程的初始猜测。对于初始步骤，非零约束被应用，以确保边界条件得到满足。在下面的步骤中，我们将求解牛顿更新，所以使用零约束。

  template <int dim> 
  void StationaryNavierStokes<dim>::solve(const bool initial_step) 
  { 
    const AffineConstraints<double> &constraints_used = 
      initial_step ? nonzero_constraints : zero_constraints; 

    SolverControl solver_control(system_matrix.m(), 
                                 1e-4 * system_rhs.l2_norm(), 
                                 true); 

    SolverFGMRES<BlockVector<double>> gmres(solver_control); 
    SparseILU<double>                 pmass_preconditioner; 
    pmass_preconditioner.initialize(pressure_mass_matrix, 
                                    SparseILU<double>::AdditionalData()); 

    const BlockSchurPreconditioner<SparseILU<double>> preconditioner( 
      gamma, 
      viscosity, 
      system_matrix, 
      pressure_mass_matrix, 
      pmass_preconditioner); 

    gmres.solve(system_matrix, newton_update, system_rhs, preconditioner); 
    std::cout << "FGMRES steps: " << solver_control.last_step() << std::endl; 

    constraints_used.distribute(newton_update); 
  } 
// @sect4{StationaryNavierStokes::refine_mesh}  

// 在粗略的网格上找到一个好的初始猜测后，我们希望通过细化网格来减少误差。这里我们做了类似于 step-15 的自适应细化，只是我们只使用了速度上的Kelly估计器。我们还需要使用SolutionTransfer类将当前的解转移到下一个网格。

  template <int dim> 
  void StationaryNavierStokes<dim>::refine_mesh() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 
    FEValuesExtractors::Vector velocity(0); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      present_solution, 
      estimated_error_per_cell, 
      fe.component_mask(velocity)); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.0); 

    triangulation.prepare_coarsening_and_refinement(); 
    SolutionTransfer<dim, BlockVector<double>> solution_transfer(dof_handler); 
    solution_transfer.prepare_for_coarsening_and_refinement(present_solution); 
    triangulation.execute_coarsening_and_refinement(); 

// 首先，DoFHandler被设置，约束被生成。然后我们创建一个临时的BlockVector  <code>tmp</code>  ，其大小与新网格上的解决方案一致。

    setup_dofs(); 

    BlockVector<double> tmp(dofs_per_block); 

// 将解决方案从粗网格转移到细网格，并对新转移的解决方案应用边界值约束。注意，present_solution仍然是对应于旧网格的一个向量。

    solution_transfer.interpolate(present_solution, tmp); 
    nonzero_constraints.distribute(tmp); 

// 最后设置矩阵和向量，并将present_solution设置为插值后的数据。

    initialize_system(); 
    present_solution = tmp; 
  } 
// @sect4{StationaryNavierStokes<dim>::newton_iteration}  

// 这个函数实现了牛顿迭代，给定了公差、最大迭代次数和要做的网格细化次数。

// 参数 <code>is_initial_step</code> 告诉我们是否需要 <code>setup_system</code> ，以及应该装配哪一部分，系统矩阵或右手边的矢量。如果我们做直线搜索，在最后一次迭代中检查残差准则时，右手边已经被组装起来了。因此，我们只需要在当前迭代中装配系统矩阵。最后一个参数 <code>output_result</code> 决定了是否应该产生图形输出。

  template <int dim> 
  void StationaryNavierStokes<dim>::newton_iteration( 
    const double       tolerance, 
    const unsigned int max_n_line_searches, 
    const unsigned int max_n_refinements, 
    const bool         is_initial_step, 
    const bool         output_result) 
  { 
    bool first_step = is_initial_step; 

    for (unsigned int refinement_n = 0; refinement_n < max_n_refinements + 1; 
         ++refinement_n) 
      { 
        unsigned int line_search_n = 0; 
        double       last_res      = 1.0; 
        double       current_res   = 1.0; 
        std::cout << "grid refinements: " << refinement_n << std::endl 
                  << "viscosity: " << viscosity << std::endl; 

        while ((first_step || (current_res > tolerance)) && 
               line_search_n < max_n_line_searches) 
          { 
            if (first_step) 
              { 
                setup_dofs(); 
                initialize_system(); 
                evaluation_point = present_solution; 
                assemble_system(first_step); 
                solve(first_step); 
                present_solution = newton_update; 
                nonzero_constraints.distribute(present_solution); 
                first_step       = false; 
                evaluation_point = present_solution; 
                assemble_rhs(first_step); 
                current_res = system_rhs.l2_norm(); 
 
 
 
 
 
 
                evaluation_point = present_solution; 
                assemble_system(first_step); 
                solve(first_step); 

// 为了确保我们的解决方案越来越接近精确的解决方案，我们让解决方案用权重 <code>alpha</code> 更新，使新的残差小于上一步的残差，这是在下面的循环中完成。这与  step-15  中使用的线搜索算法相同。

                for (double alpha = 1.0; alpha > 1e-5; alpha *= 0.5) 
                  { 
                    evaluation_point = present_solution; 
                    evaluation_point.add(alpha, newton_update); 
                    nonzero_constraints.distribute(evaluation_point); 
                    assemble_rhs(first_step); 
                    current_res = system_rhs.l2_norm(); 
                    std::cout << "  alpha: " << std::setw(10) << alpha 
                              << std::setw(0) << "  residual: " << current_res 
                              << std::endl; 
                    if (current_res < last_res) 
                      break; 
                  } 
                { 
                  present_solution = evaluation_point; 
                  std::cout << "  number of line searches: " << line_search_n 
                            << "  residual: " << current_res << std::endl; 
                  last_res = current_res; 
                } 
                ++line_search_n; 
              } 

            if (output_result) 
              { 
                output_results(max_n_line_searches * refinement_n + 
                               line_search_n); 

                if (current_res <= tolerance) 
                  process_solution(refinement_n); 
              } 
          } 

        if (refinement_n < max_n_refinements) 
          { 
            refine_mesh(); 
          } 
      } 
  } 
// @sect4{StationaryNavierStokes::compute_initial_guess}  

// 这个函数将通过使用延续法为我们提供一个初始猜测，正如我们在介绍中讨论的那样。雷诺数被逐级增加 step- ，直到我们达到目标值。通过实验，斯托克斯的解足以成为雷诺数为1000的NSE的初始猜测，所以我们从这里开始。 为了确保前一个问题的解决方案与下一个问题足够接近，步长必须足够小。

  template <int dim> 
  void StationaryNavierStokes<dim>::compute_initial_guess(double step_size) 
  { 
    const double target_Re = 1.0 / viscosity; 

    bool is_initial_step = true; 

    for (double Re = 1000.0; Re < target_Re; 
         Re        = std::min(Re + step_size, target_Re)) 
      { 
        viscosity = 1.0 / Re; 
        std::cout << "Searching for initial guess with Re = " << Re 
                  << std::endl; 
        newton_iteration(1e-12, 50, 0, is_initial_step, false); 
        is_initial_step = false; 
      } 
  } 
// @sect4{StationaryNavierStokes::output_results}  

// 这个函数与 step-22 中的函数相同，只是我们为输出文件选择了一个同时包含雷诺数（即当前环境下的粘度的倒数）的名称。

  template <int dim> 
  void StationaryNavierStokes<dim>::output_results( 
    const unsigned int output_index) const 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.emplace_back("pressure"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(present_solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.build_patches(); 

    std::ofstream output(std::to_string(1.0 / viscosity) + "-solution-" + 
                         Utilities::int_to_string(output_index, 4) + ".vtk"); 
    data_out.write_vtk(output); 
  } 
// @sect4{StationaryNavierStokes::process_solution}  

// 在我们的测试案例中，我们不知道分析解。该函数输出沿 $x=0.5$ 和 $0 \leq y \leq 1$ 的速度分量，以便与文献中的数据进行比较。

  template <int dim> 
  void StationaryNavierStokes<dim>::process_solution(unsigned int refinement) 
  { 
    std::ofstream f(std::to_string(1.0 / viscosity) + "-line-" + 
                    std::to_string(refinement) + ".txt"); 
    f << "# y u_x u_y" << std::endl; 

    Point<dim> p; 
    p(0) = 0.5; 
    p(1) = 0.5; 

    f << std::scientific; 

    for (unsigned int i = 0; i <= 100; ++i) 
      { 
        p(dim - 1) = i / 100.0; 

        Vector<double> tmp_vector(dim + 1); 
        VectorTools::point_value(dof_handler, present_solution, p, tmp_vector); 
        f << p(dim - 1); 

        for (int j = 0; j < dim; j++) 
          f << " " << tmp_vector(j); 
        f << std::endl; 
      } 
  } 
// @sect4{StationaryNavierStokes::run}  

// 这是本程序的最后一步。在这一部分，我们分别生成网格和运行其他函数。最大细化度可以通过参数来设置。

  template <int dim> 
  void StationaryNavierStokes<dim>::run(const unsigned int refinement) 
  { 
    GridGenerator::hyper_cube(triangulation); 
    triangulation.refine_global(5); 

    const double Re = 1.0 / viscosity; 

// 如果粘度小于 $1/1000$ ，我们必须首先通过延续法搜索初始猜测。我们应该注意的是，搜索总是在初始网格上进行的，也就是这个程序中的 $8 \times 8$ 网格。之后，我们只需做与粘度大于 $1/1000$ 时相同的工作：运行牛顿迭代，细化网格，转移解决方案，并重复。

    if (Re > 1000.0) 
      { 
        std::cout << "Searching for initial guess ..." << std::endl; 
        const double step_size = 2000.0; 
        compute_initial_guess(step_size); 
        std::cout << "Found initial guess." << std::endl; 
        std::cout << "Computing solution with target Re = " << Re << std::endl; 
        viscosity = 1.0 / Re; 
        newton_iteration(1e-12, 50, refinement, false, true); 
      } 
    else 
      { 

// 当粘度大于1/1000时，斯托克斯方程的解作为初始猜测已经足够好。如果是这样，我们就不需要用延续法来搜索初始猜测了。牛顿迭代可以直接开始。

        newton_iteration(1e-12, 50, refinement, true, true); 
      } 
  } 
} // namespace Step57 

int main() 
{ 
  try 
    { 
      using namespace Step57; 

      StationaryNavierStokes<2> flow(/* degree = */ 

1); 
      flow.run(4); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
 
 
 
 
 
 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 


CCTest_file/step-58.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2018 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE at 
 * the top level of the deal.II distribution. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Colorado State University 
 *         Yong-Yong Cai, Beijing Computational Science Research Center 
 */ 


// @sect3{Include files}  程序以通常的包含文件开始，所有这些文件你现在应该都见过了。

#include <deal.II/base/logstream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/matrix_tools.h> 

#include <fstream> 
#include <iostream> 

// 然后按照惯例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入到我们将要工作的命名空间中。

namespace Step58 
{ 
  using namespace dealii; 
// @sect3{The <code>NonlinearSchroedingerEquation</code> class}  

// 然后是主类。它看起来非常像  step-4  或  step-6  中的相应类，唯一的例外是，矩阵和向量以及其他所有与线性系统相关的元素现在都存储为  `std::complex<double>`  类型，而不仅仅是 `double`。

  template <int dim> 
  class NonlinearSchroedingerEquation 
  { 
  public: 
    NonlinearSchroedingerEquation(); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_matrices(); 
    void do_half_phase_step(); 
    void do_full_spatial_step(); 
    void output_results() const; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<std::complex<double>> constraints; 

    SparsityPattern                    sparsity_pattern; 
    SparseMatrix<std::complex<double>> system_matrix; 
    SparseMatrix<std::complex<double>> rhs_matrix; 

    Vector<std::complex<double>> solution; 
    Vector<std::complex<double>> system_rhs; 

    double       time; 
    double       time_step; 
    unsigned int timestep_number; 

    double kappa; 
  }; 

//  @sect3{Equation data}  

// 在我们继续填写主类的细节之前，让我们定义与问题相对应的方程数据，即初始值，以及一个右手类。我们将把初始条件也用于边界值，我们只是保持边界值不变）。我们使用派生自Function类模板的类来做这件事，这个模板之前已经用过很多次了，所以下面的内容看起来并不令人惊讶。唯一值得注意的是，我们这里有一个复值问题，所以我们必须提供Function类的第二个模板参数（否则会默认为`double`）。此外，`value()`函数的返回类型当然也是复数。

// 这些函数精确地返回什么，在介绍部分的最后已经讨论过了。

  template <int dim> 
  class InitialValues : public Function<dim, std::complex<double>> 
  { 
  public: 
    InitialValues() 
      : Function<dim, std::complex<double>>(1) 
    {} 

    virtual std::complex<double> 
    value(const Point<dim> &p, const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  std::complex<double> 
  InitialValues<dim>::value(const Point<dim> & p, 
                            const unsigned int component) const 
  { 
    static_assert(dim == 2, "This initial condition only works in 2d."); 

    (void)component; 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 

    const std::vector<Point<dim>> vortex_centers = {{0, -0.3}, 
                                                    {0, +0.3}, 
                                                    {+0.3, 0}, 
                                                    {-0.3, 0}}; 

    const double R = 0.1; 
    const double alpha = 
      1. / (std::pow(R, dim) * std::pow(numbers::PI, dim / 2.)); 

    double sum = 0; 
    for (const auto &vortex_center : vortex_centers) 
      { 
        const Tensor<1, dim> distance = p - vortex_center; 
        const double         r        = distance.norm(); 

        sum += alpha * std::exp(-(r * r) / (R * R)); 
      } 

    return {std::sqrt(sum), 0.}; 
  } 

  template <int dim> 
  class Potential : public Function<dim> 
  { 
  public: 
    Potential() = default; 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double Potential<dim>::value(const Point<dim> & p, 
                               const unsigned int component) const 
  { 
    (void)component; 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 

    return (Point<dim>().distance(p) > 0.7 ? 1000 : 0); 
  } 

//  @sect3{Implementation of the <code>NonlinearSchroedingerEquation</code> class}  

// 我们首先指定了类的构造函数的实现。

  template <int dim> 
  NonlinearSchroedingerEquation<dim>::NonlinearSchroedingerEquation() 
    : fe(2) 
    , dof_handler(triangulation) 
    , time(0) 
    , time_step(1. / 128) 
    , timestep_number(0) 
    , kappa(1) 
  {} 
// @sect4{Setting up data structures and assembling matrices}  

// 下一个函数是在程序开始时，也就是在第一个时间步骤之前，设置网格、DoFHandler以及矩阵和向量。如果你已经阅读了至少到 step-6 为止的教程程序，那么前几行是相当标准的。

  template <int dim> 
  void NonlinearSchroedingerEquation<dim>::setup_system() 
  { 
    GridGenerator::hyper_cube(triangulation, -1, 1); 
    triangulation.refine_global(6); 

    std::cout << "Number of active cells: " << triangulation.n_active_cells() 
              << std::endl; 

    dof_handler.distribute_dofs(fe); 

    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl 
              << std::endl; 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
    rhs_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.close(); 
  } 

// 接下来，我们组装相关的矩阵。按照我们对斯特朗分裂的空间步骤（即每个时间步骤中三个部分步骤中的第二个步骤）的Crank-Nicolson离散化的写法，我们被引导到线性系统  
// $\left[ -iM  +  \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right]
//    \Psi^{(n,2)}
//   =
//   \left[ -iM  -  \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right]
//    \Psi^{(n,1)}$ 
   
//     换句话说，这里有两个矩阵在起作用--一个用于左手边，一个用于右手边。我们分别建立这些矩阵。我们可以避免建立右手边的矩阵，而只是在每个时间步长中形成矩阵的*作用* $\Psi^{(n,1)}$ 。这可能更有效，也可能不有效，但是对于这个程序来说，效率并不是最重要的）。)

  template <int dim> 
  void NonlinearSchroedingerEquation<dim>::assemble_matrices() 
  { 
    const QGauss<dim> quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<std::complex<double>> cell_matrix_lhs(dofs_per_cell, 
                                                     dofs_per_cell); 
    FullMatrix<std::complex<double>> cell_matrix_rhs(dofs_per_cell, 
                                                     dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    std::vector<double>                  potential_values(n_q_points); 
    const Potential<dim>                 potential; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix_lhs = std::complex<double>(0.); 
        cell_matrix_rhs = std::complex<double>(0.); 

        fe_values.reinit(cell); 

        potential.value_list(fe_values.get_quadrature_points(), 
                             potential_values); 

        for (unsigned int q_index = 0; q_index < n_q_points; ++q_index) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell; ++k) 
              { 
                for (unsigned int l = 0; l < dofs_per_cell; ++l) 
                  { 
                    const std::complex<double> i = {0, 1}; 

                    cell_matrix_lhs(k, l) += 
                      (-i * fe_values.shape_value(k, q_index) * 
                         fe_values.shape_value(l, q_index) + 
                       time_step / 4 * fe_values.shape_grad(k, q_index) * 
                         fe_values.shape_grad(l, q_index) + 
                       time_step / 2 * potential_values[q_index] * 
                         fe_values.shape_value(k, q_index) * 
                         fe_values.shape_value(l, q_index)) * 
                      fe_values.JxW(q_index); 

                    cell_matrix_rhs(k, l) += 
                      (-i * fe_values.shape_value(k, q_index) * 
                         fe_values.shape_value(l, q_index) - 
                       time_step / 4 * fe_values.shape_grad(k, q_index) * 
                         fe_values.shape_grad(l, q_index) - 
                       time_step / 2 * potential_values[q_index] * 
                         fe_values.shape_value(k, q_index) * 
                         fe_values.shape_value(l, q_index)) * 
                      fe_values.JxW(q_index); 
                  } 
              } 
          } 

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global(cell_matrix_lhs, 
                                               local_dof_indices, 
                                               system_matrix); 
        constraints.distribute_local_to_global(cell_matrix_rhs, 
                                               local_dof_indices, 
                                               rhs_matrix); 
      } 
  } 
// @sect4{Implementing the Strang splitting steps}  

// 在建立了上述所有数据结构后，我们现在可以实现构成斯特朗分裂方案的部分步骤。我们从推进阶段的半步开始，这被用作每个时间步骤的第一和最后部分。

// 为此，回顾一下，对于第一个半步，我们需要计算  $\psi^{(n,1)} = e^{-i\kappa|\psi^{(n,0)}|^2 \tfrac 12\Delta t} \; \psi^{(n,0)}$  。这里， $\psi^{(n,0)}=\psi^{(n)}$ 和 $\psi^{(n,1)}$ 是空间的函数，分别对应于前一个完整时间步骤的输出和三个部分步骤中第一个步骤的结果。必须为第三个部分步骤计算相应的解决方案，即  $\psi^{(n,3)} = e^{-i\kappa|\psi^{(n,2)}|^2 \tfrac 12\Delta t} \; \psi^{(n,2)}$  ，其中  $\psi^{(n,3)}=\psi^{(n+1)}$  是整个时间步骤的结果，其输入  $\psi^{(n,2)}$  是斯特朗分割的空间步骤的结果。

// 一个重要的认识是，虽然 $\psi^{(n,0)}(\mathbf x)$ 可能是一个有限元函数（即，是片状多项式），但对于我们使用指数因子更新相位的 "旋转 "函数来说，不一定是这样的（回顾一下，该函数的振幅在该步骤中保持不变）。换句话说，我们可以在每一个点 $\psi^{(n,1)}(\mathbf x)$ *计算 $\mathbf x\in\Omega$ ，但我们不能在网格上表示它，因为它不是一个片状多项式函数。在一个离散的环境中，我们能做的最好的事情就是计算一个投影或内插。换句话说，我们可以计算 $\psi_h^{(n,1)}(\mathbf x) = \Pi_h \left(e^{-i\kappa|\psi_h^{(n,0)}(\mathbf x)|^2 \tfrac 12\Delta t} \; \psi_h^{(n,0)}(\mathbf x) \right)$ ，其中 $\Pi_h$ 是一个投影或内插算子。如果我们选择插值，情况就特别简单。那么，我们需要计算的就是*在节点点上的右手边的值，并将这些作为自由度向量 $\Psi^{(n,1)}$ 的节点值。这很容易做到，因为在这里使用的拉格朗日有限元的节点点上评估右手边，需要我们只看节点向量的一个（复值）条目。换句话说，我们需要做的是计算 $\Psi^{(n,1)}_j = e^{-i\kappa|\Psi^{(n,0)}_j|^2 \tfrac 12\Delta t} \; \Psi^{(n,0)}_j$ ，其中 $j$ 在我们的解向量的所有条目上循环。这就是下面的函数所做的--事实上，它甚至没有为 $\Psi^{(n,0)}$ 和 $\Psi^{(n,1)}$ 使用单独的向量，而只是适当地更新同一个向量。

  template <int dim> 
  void NonlinearSchroedingerEquation<dim>::do_half_phase_step() 
  { 
    for (auto &value : solution) 
      { 
        const std::complex<double> i         = {0, 1}; 
        const double               magnitude = std::abs(value); 

        value = std::exp(-i * kappa * magnitude * magnitude * (time_step / 2)) * 
                value; 
      } 
  } 

// 下一步是求解每个时间步骤中的线性系统，即我们使用的Strang分割的后半步。记得它的形式是 $C\Psi^{(n,2)} = R\Psi^{(n,1)}$ ，其中 $C$ 和 $R$ 是我们之前组装的矩阵。

// 我们在这里解决这个问题的方法是使用直接求解器。我们首先使用 $r=R\Psi^{(n,1)}$ 函数形成右边的 SparseMatrix::vmult() ，并将结果放入`system_rhs`变量。然后我们调用 SparseDirectUMFPACK::solver() ，该函数以矩阵 $C$ 和右手边的向量为参数，并在同一向量`system_rhs`中返回解。最后一步是将计算出的解放回`solution`变量中。

  template <int dim> 
  void NonlinearSchroedingerEquation<dim>::do_full_spatial_step() 
  { 
    rhs_matrix.vmult(system_rhs, solution); 

    SparseDirectUMFPACK direct_solver; 
    direct_solver.solve(system_matrix, system_rhs); 

    solution = system_rhs; 
  } 

//  @sect4{Creating graphical output}  

// 我们应该讨论的最后一个辅助函数和类是那些创建图形输出的函数。对斯特朗分裂的局部和空间部分运行半步和全步的结果是，我们在每个时间步数结束时将`solution`向量 $\Psi^n$ 更新为正确的值。它的条目包含有限元网格节点上的解的复数。

// 复数不容易被视觉化。我们可以输出它们的实部和虚部，即字段 $\text{Re}(\psi_h^{(n)}(\mathbf x))$ 和 $\text{Im}(\psi_h^{(n)}(\mathbf x))$ ，这正是DataOut类在通过 DataOut::add_data_vector() 附加复数向量，然后调用 DataOut::build_patches(). 时所做的事情，这确实是我们下面要做的。

// 但很多时候，我们对解向量的实部和虚部并不特别感兴趣，而是对解的幅度 $|\psi|$ 和相位角 $\text{arg}(\psi)$ 等衍生量感兴趣。在这里这样的量子系统的背景下，幅度本身并不那么有趣，相反，"振幅"， $|\psi|^2$ 才是一个物理属性：它对应于在一个特定的状态场所找到一个粒子的概率密度。将计算出的量放入输出文件以实现可视化的方法--正如在以前的许多教程程序中使用的那样--是使用数据后处理程序和派生类的设施。具体来说，一个复数的振幅和它的相位角都是标量，因此DataPostprocessorScalar类是我们要做的正确工具。

// 因此，我们在这里要做的是实现两个类`ComplexAmplitude`和`ComplexPhase`，为DataOut决定生成输出的每个点计算解决方案的振幅 $|\psi_h|^2$ 和相位 $\text{arg}(\psi_h)$ ，以便进行可视化。下面有大量的模板代码，这两个类中的第一个唯一有趣的部分是它的`evaluate_vector_field()`函数如何计算`computed_quantities`对象。

//（还有一个相当尴尬的事实是，<a
//  href="https:en.cppreference.com/w/cpp/numeric/complex/norm">std::norm()</a>函数并没有计算人们天真的想象，即 $|\psi|$  ，而是返回 $|\psi|^2$ 。一个标准函数以这样的方式被错误地命名，这当然是相当令人困惑的......)

  namespace DataPostprocessors 
  { 
    template <int dim> 
    class ComplexAmplitude : public DataPostprocessorScalar<dim> 
    { 
    public: 
      ComplexAmplitude(); 

      virtual void evaluate_vector_field( 
        const DataPostprocessorInputs::Vector<dim> &inputs, 
        std::vector<Vector<double>> &computed_quantities) const override; 
    }; 

    template <int dim> 
    ComplexAmplitude<dim>::ComplexAmplitude() 
      : DataPostprocessorScalar<dim>("Amplitude", update_values) 
    {} 

    template <int dim> 
    void ComplexAmplitude<dim>::evaluate_vector_field( 
      const DataPostprocessorInputs::Vector<dim> &inputs, 
      std::vector<Vector<double>> &               computed_quantities) const 
    { 
      Assert(computed_quantities.size() == inputs.solution_values.size(), 
             ExcDimensionMismatch(computed_quantities.size(), 
                                  inputs.solution_values.size())); 

      for (unsigned int q = 0; q < computed_quantities.size(); ++q) 
        { 
          Assert(computed_quantities[q].size() == 1, 
                 ExcDimensionMismatch(computed_quantities[q].size(), 1)); 
          Assert(inputs.solution_values[q].size() == 2, 
                 ExcDimensionMismatch(inputs.solution_values[q].size(), 2)); 

          const std::complex<double> psi(inputs.solution_values[q](0), 
                                         inputs.solution_values[q](1)); 
          computed_quantities[q](0) = std::norm(psi); 
        } 
    } 

// 这些后处理程序类中的第二个是计算每一个点的复值解决方案的相位角。换句话说，如果我们表示  $\psi(\mathbf x,t)=r(\mathbf x,t) e^{i\varphi(\mathbf x,t)}$  ，那么这个类就会计算  $\varphi(\mathbf x,t)$  。函数 <a href="https:en.cppreference.com/w/cpp/numeric/complex/arg">std::arg</a> 为我们做这个，并将角度作为实数返回  $-\pi$  和  $+\pi$  之间。

// 由于我们将在结果部分详细解释的原因，我们实际上没有在产生输出的每个位置输出这个值。相反，我们取相位所有评估点的最大值，然后用这个最大值填充每个评估点的输出字段--实质上，我们将相位角作为一个片状常数字段输出，其中每个单元都有自己的常数值。一旦你读完下面的讨论就会明白其中的原因。

    template <int dim> 
    class ComplexPhase : public DataPostprocessorScalar<dim> 
    { 
    public: 
      ComplexPhase(); 

      virtual void evaluate_vector_field( 
        const DataPostprocessorInputs::Vector<dim> &inputs, 
        std::vector<Vector<double>> &computed_quantities) const override; 
    }; 

    template <int dim> 
    ComplexPhase<dim>::ComplexPhase() 
      : DataPostprocessorScalar<dim>("Phase", update_values) 
    {} 

    template <int dim> 
    void ComplexPhase<dim>::evaluate_vector_field( 
      const DataPostprocessorInputs::Vector<dim> &inputs, 
      std::vector<Vector<double>> &               computed_quantities) const 
    { 
      Assert(computed_quantities.size() == inputs.solution_values.size(), 
             ExcDimensionMismatch(computed_quantities.size(), 
                                  inputs.solution_values.size())); 

      double max_phase = -numbers::PI; 
      for (unsigned int q = 0; q < computed_quantities.size(); ++q) 
        { 
          Assert(computed_quantities[q].size() == 1, 
                 ExcDimensionMismatch(computed_quantities[q].size(), 1)); 
          Assert(inputs.solution_values[q].size() == 2, 
                 ExcDimensionMismatch(inputs.solution_values[q].size(), 2)); 

          max_phase = 
            std::max(max_phase, 
                     std::arg( 
                       std::complex<double>(inputs.solution_values[q](0), 
                                            inputs.solution_values[q](1)))); 
        } 

      for (auto &output : computed_quantities) 
        output(0) = max_phase; 
    } 

  } // namespace DataPostprocessors 

// 在这样实现了这些后处理程序后，我们像往常一样创建输出。与其他许多时间相关的教程程序一样，我们给DataOut附加标志，表示时间步数和当前模拟时间。

  template <int dim> 
  void NonlinearSchroedingerEquation<dim>::output_results() const 
  { 
    const DataPostprocessors::ComplexAmplitude<dim> complex_magnitude; 
    const DataPostprocessors::ComplexPhase<dim>     complex_phase; 

    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "Psi"); 
    data_out.add_data_vector(solution, complex_magnitude); 
    data_out.add_data_vector(solution, complex_phase); 
    data_out.build_patches(); 

    data_out.set_flags(DataOutBase::VtkFlags(time, timestep_number)); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu"; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 

//  @sect4{Running the simulation}  

// 剩下的步骤是我们如何设置这个程序的整体逻辑。这其实是比较简单的。设置数据结构；将初始条件插值到有限元空间；然后迭代所有时间步长，在每个时间步长上执行斯特朗分割法的三个部分。每隔10个时间步长，我们就生成图形输出。这就是了。

  template <int dim> 
  void NonlinearSchroedingerEquation<dim>::run() 
  { 
    setup_system(); 
    assemble_matrices(); 

    time = 0; 
    VectorTools::interpolate(dof_handler, InitialValues<dim>(), solution); 
    output_results(); 

    const double end_time = 1; 
    for (; time <= end_time; time += time_step) 
      { 
        ++timestep_number; 

        std::cout << "Time step " << timestep_number << " at t=" << time 
                  << std::endl; 

        do_half_phase_step(); 
        do_full_spatial_step(); 
        do_half_phase_step(); 

        if (timestep_number % 1 == 0) 
          output_results(); 
      } 
  } 
} // namespace Step58 

//  @sect4{The main() function}  

// 其余的又是锅炉板，和以前几乎所有的教程程序完全一样。

int main() 
{ 
  try 
    { 
      using namespace Step58; 

      NonlinearSchroedingerEquation<2> nse; 
      nse.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 

CCTest_file/step-59.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2018 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Katharina Kormann, Martin Kronbichler, 2018 
 */ 



// 包含的文件与  step-37  中的基本相同，只是用有限元类FE_DGQHermite代替了FE_Q。所有对面积分进行无矩阵计算的功能已经包含在`fe_evaluation.h`中。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/la_parallel_vector.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/tensor_product_matrix.h> 

#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_tools.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 

#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer_matrix_free.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_matrix.h> 

#include <deal.II/numerics/vector_tools.h> 

#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/fe_evaluation.h> 

#include <iostream> 
#include <fstream> 

namespace Step59 
{ 
  using namespace dealii; 

// 和 step-37 一样，为了简单起见，我们在程序顶部将维数和多项式程度收集为常数。与 step-37 不同的是，这次我们选择了一个真正的高阶方法，度数为8，任何不使用和因式分解的实现都会变得非常慢，而使用MatrixFree的实现则提供了与度数为2或3时基本相同的效率。此外，本教程程序中的所有类都是模板化的，因此，通过在`main()`函数中添加适当度数的实例，可以很容易地在运行时从输入文件或命令行参数中选择度数。

  const unsigned int degree_finite_element = 8; 
  const unsigned int dimension             = 3; 
// @sect3{Equation data}  

// 与 step-7 相类似，我们定义了一个分析解，我们试图用离散化重现这个分析解。由于本教程的目的是展示无矩阵方法，我们选择了一个最简单的可能性，即一个余弦函数，其导数对我们来说足够简单，可以通过分析计算。再往下看，我们在这里选择的波数2.4将与 $x$ -方向的域范围即2.5相匹配，这样我们在 $x = 2.5$ 得到一个周期性的解，包括 $6pi$ 或余弦的三个整波转。第一个函数定义了解和它的梯度，分别用于表达Dirichlet和Neumann边界条件的解析解。此外，一个代表解的负拉普拉斯的类被用来表示右手边（强制）函数，我们用它来匹配离散化版本中的给定分析解（制造解）。

  template <int dim> 
  class Solution : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> &p, 
                         const unsigned int = 0) const override final 
    { 
      double val = 1.; 
      for (unsigned int d = 0; d < dim; ++d) 
        val *= std::cos(numbers::PI * 2.4 * p[d]); 
      return val; 
    } 

    virtual Tensor<1, dim> gradient(const Point<dim> &p, 
                                    const unsigned int = 0) const override final 
    { 
      const double   arg = numbers::PI * 2.4; 
      Tensor<1, dim> grad; 
      for (unsigned int d = 0; d < dim; ++d) 
        { 
          grad[d] = 1.; 
          for (unsigned int e = 0; e < dim; ++e) 
            if (d == e) 
              grad[d] *= -arg * std::sin(arg * p[e]); 
            else 
              grad[d] *= std::cos(arg * p[e]); 
        } 
      return grad; 
    } 
  }; 

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> &p, 
                         const unsigned int = 0) const override final 
    { 
      const double arg = numbers::PI * 2.4; 
      double       val = 1.; 
      for (unsigned int d = 0; d < dim; ++d) 
        val *= std::cos(arg * p[d]); 
      return dim * arg * arg * val; 
    } 
  }; 

//  @sect3{Matrix-free implementation}  

// `LaplaceOperator`类与  step-37  中的相应类类似。一个重要的区别是，我们没有从  MatrixFreeOperators::Base  派生出这个类，因为我们想呈现  MatrixFree::loop()  的一些额外特性，这些特性在通用类  MatrixFreeOperators::Base.  中是不可用的。我们从Subscriptor类派生出这个类，以便能够在Chebyshev预处理程序中使用该操作符，因为该预处理程序通过SmartPointer存储基础矩阵。

// 鉴于我们手工实现了一个完整的矩阵接口，我们需要添加一个`initialize()`函数，一个`m()`函数，一个`vmult()`函数和一个`Tvmult()`函数，这些都是之前由  MatrixFreeOperators::Base.  我们的LaplaceOperator还包含一个成员函数`get_penalty_factor()`，根据  step-39  集中选择对称内部惩罚方法中的惩罚参数 。

  template <int dim, int fe_degree, typename number> 
  class LaplaceOperator : public Subscriptor 
  { 
  public: 
    using value_type = number; 

    LaplaceOperator() = default; 

    void initialize(std::shared_ptr<const MatrixFree<dim, number>> data); 

    void clear(); 

    types::global_dof_index m() const; 

    void initialize_dof_vector( 
      LinearAlgebra::distributed::Vector<number> &vec) const; 

    std::shared_ptr<const MatrixFree<dim, number>> get_matrix_free() const; 

    void vmult(LinearAlgebra::distributed::Vector<number> &      dst, 
               const LinearAlgebra::distributed::Vector<number> &src) const; 

    void Tvmult(LinearAlgebra::distributed::Vector<number> &      dst, 
                const LinearAlgebra::distributed::Vector<number> &src) const; 

    number get_penalty_factor() const 
    { 
      return 1.0 * fe_degree * (fe_degree + 1); 
    } 

  private: 
    void 
    apply_cell(const MatrixFree<dim, number> &                   data, 
               LinearAlgebra::distributed::Vector<number> &      dst, 
               const LinearAlgebra::distributed::Vector<number> &src, 
               const std::pair<unsigned int, unsigned int> &cell_range) const; 

    void 
    apply_face(const MatrixFree<dim, number> &                   data, 
               LinearAlgebra::distributed::Vector<number> &      dst, 
               const LinearAlgebra::distributed::Vector<number> &src, 
               const std::pair<unsigned int, unsigned int> &face_range) const; 

    void apply_boundary( 
      const MatrixFree<dim, number> &                   data, 
      LinearAlgebra::distributed::Vector<number> &      dst, 
      const LinearAlgebra::distributed::Vector<number> &src, 
      const std::pair<unsigned int, unsigned int> &     face_range) const; 

    std::shared_ptr<const MatrixFree<dim, number>> data; 
  }; 

// `%PreconditionBlockJacobi`类定义了我们对这个问题的自定义预处理程序。与基于矩阵对角线的 step-37 不同，我们在这里通过使用介绍中讨论的所谓快速对角线化方法来计算非连续Galerkin方法中对角线块的近似反演。

  template <int dim, int fe_degree, typename number> 
  class PreconditionBlockJacobi 
  { 
  public: 
    using value_type = number; 

    void clear() 
    { 
      cell_matrices.clear(); 
    } 

    void initialize(const LaplaceOperator<dim, fe_degree, number> &op); 

    void vmult(LinearAlgebra::distributed::Vector<number> &      dst, 
               const LinearAlgebra::distributed::Vector<number> &src) const; 

    void Tvmult(LinearAlgebra::distributed::Vector<number> &      dst, 
                const LinearAlgebra::distributed::Vector<number> &src) const 
    { 
      vmult(dst, src); 
    } 

  private: 
    std::shared_ptr<const MatrixFree<dim, number>> data; 
    std::vector<TensorProductMatrixSymmetricSum<dim, 
                                                VectorizedArray<number>, 
                                                fe_degree + 1>> 
      cell_matrices; 
  }; 

//这个独立的函数在`LaplaceOperator'和`%PreconditionBlockJacobi'类中都被用来调整鬼魂范围。这个函数是必要的，因为`vmult()`函数所提供的一些向量没有用包括正确的鬼魂条目布局的 `LaplaceOperator::initialize_dof_vector` 来正确初始化，而是来自MGTransferMatrixFree类，该类对无矩阵类的鬼魂选择没有概念。为了避免索引混乱，我们必须在对这些向量进行实际操作之前调整鬼域。由于向量在多网格平滑器和传输类中被保留下来，一个曾经被调整过重影范围的向量在对象的整个生命周期中都会保持这种状态，所以我们可以在函数的开始使用一个快捷方式来查看分布式向量的分区器对象（以共享指针的形式存储）是否与MatrixFree所期望的布局相同，它被存储在一个由 MatrixFree::get_dof_info(0),  访问的数据结构中 ]，其中的0表示从中提取的DoFHandler编号；我们在MatrixFree中只使用一个DoFHandler，所以这里唯一有效的编号是0。

  template <int dim, typename number> 
  void adjust_ghost_range_if_necessary( 
    const MatrixFree<dim, number> &                   data, 
    const LinearAlgebra::distributed::Vector<number> &vec) 
  { 
    if (vec.get_partitioner().get() == 
        data.get_dof_info(0).vector_partitioner.get()) 
      return; 

    LinearAlgebra::distributed::Vector<number> copy_vec(vec); 
    const_cast<LinearAlgebra::distributed::Vector<number> &>(vec).reinit( 
      data.get_dof_info(0).vector_partitioner); 
    const_cast<LinearAlgebra::distributed::Vector<number> &>(vec) 
      .copy_locally_owned_data_from(copy_vec); 
  } 

// 接下来的五个函数用于清除和初始化`LaplaceOperator`类，返回持有MatrixFree数据容器的共享指针，以及正确初始化向量和运算符大小，与 step-37 或者说 MatrixFreeOperators::Base. 的内容相同。
  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::clear() 
  { 
    data.reset(); 
  } 

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::initialize( 
    std::shared_ptr<const MatrixFree<dim, number>> data) 
  { 
    this->data = data; 
  } 

  template <int dim, int fe_degree, typename number> 
  std::shared_ptr<const MatrixFree<dim, number>> 
  LaplaceOperator<dim, fe_degree, number>::get_matrix_free() const 
  { 
    return data; 
  } 

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::initialize_dof_vector( 
    LinearAlgebra::distributed::Vector<number> &vec) const 
  { 
    data->initialize_dof_vector(vec); 
  } 

  template <int dim, int fe_degree, typename number> 
  types::global_dof_index LaplaceOperator<dim, fe_degree, number>::m() const 
  { 
    Assert(data.get() != nullptr, ExcNotInitialized()); 
    return data->get_dof_handler().n_dofs(); 
  } 

// 这个函数在向量`src`上实现了LaplaceOperator的动作，并将结果存储在向量`dst`中。与 step-37 相比，这个调用有四个新特性。

// 第一个新特性是上面提到的`adjust_ghost_range_if_necessary`函数，该函数需要使向量符合单元和面函数中FEEvaluation和FEFaceEvaluation所期望的布局。

// 第二个新特征是我们没有像 step-37 中那样实现`vmult_add()`函数（通过虚拟函数 MatrixFreeOperators::Base::vmult_add()), ，而是直接实现`vmult()`功能。由于单元和面的积分都将和到目的向量中，我们当然必须在某处将向量归零。对于DG元素，我们有两个选择&ndash；一个是使用 FEEvaluation::set_dof_values() 而不是下面`apply_cell`函数中的 FEEvaluation::distribute_local_to_global() 。这是因为MatrixFree中的循环布局是这样的：单元积分总是在面积分之前接触到一个给定的向量条目。然而，这实际上只适用于完全不连续的基数，其中每个单元都有自己的自由度，不与邻近的结果共享。另一种设置，即这里选择的设置，是让 MatrixFree::loop() 来处理向量的归零问题。这可以被认为是在代码的某个地方简单地调用`dst = 0;`。对于像 `LinearAlgebra::distributed::Vector`, 这样的支持性向量来说，实现起来就比较麻烦了，因为我们的目标是不要一次性将整个向量清零。在足够小的几千个向量项上进行归零操作的好处是，在 FEEvaluation::distribute_local_to_global() 和 FEFaceEvaluation::distribute_local_to_global(). 中再次访问之前，被归零的向量项会保留在缓存中，因为无矩阵运算符的评估真的很快，仅仅归零一个大的向量就会相当于运算符评估时间的25%，我们显然希望避免这种代价。对于 MatrixFree::cell_loop 和连续基数来说，也可以使用这种将向量归零的选项，尽管在 step-37 或 step-48 的教程程序中没有使用它。

// 第三个新特征是我们提供了在单元格、内面和边界面进行计算的函数方式。MatrixFree类有一个叫做`loop`的函数，它接收三个函数指针，用于三种情况，允许分开实现不同的东西。正如在 step-37 中所解释的，这些函数指针可以是 `std::function` 对象或类的成员函数。在这种情况下，我们使用指向成员函数的指针。

// 最后的新特征是可以给 MatrixFree::DataAccessOnFaces 类型的最后两个参数，这个类将面积分的数据访问类型传递给并行向量的MPI数据交换例程 LinearAlgebra::distributed::Vector::update_ghost_values() 和 LinearAlgebra::distributed::Vector::compress() 。其目的是不发送相邻元素的所有自由度，而是将数据量减少到手头计算真正需要的程度。数据交换是一个真正的瓶颈，特别是对于高自由度的DG方法来说，因此一个更严格的交换方式往往是有益的。枚举字段 MatrixFree::DataAccessOnFaces 可以取值`none`，这意味着根本不做面的积分，这类似于 MatrixFree::cell_loop(), 的值`values`，意味着只使用面的形状函数值（但不使用导数），而值`gradients`时，除了值之外还访问面的第一导数。值`unspecified`意味着所有的自由度将被交换给位于处理器边界的面，并指定在本地处理器上进行处理。

// 为了了解数据是如何被减少的，想想节点元素FE_DGQ的情况，节点点在元素表面，在一个单元的 $(k+1)^d$ 个自由度中，只有 $(k+1)^{d-1}$ 个自由度对 $d$ 个空间维度的多项式程度的面的值有贡献。类似的减少也可以用于内部惩罚方法，该方法评估面的值和一导数。当在一维中使用类Hermite基时，最多只有两个基函数对数值和导数有贡献。FE_DGQHermite类实现了这一概念的张量乘积，在介绍中已经讨论过。因此，每个面只需交换 $2(k+1)^{d-1}$ 个自由度，一旦 $k$ 个自由度大于4或5个，这显然是一种胜利。请注意，FE_DGQHermite的这种减少的交换在具有弯曲边界的网格上也是有效的，因为导数是在参考元素上取的，而几何体只在内部混合它们。因此，这与试图用连续的Hermite型形状函数获得 $C^1$ 的连续性不同，在这种情况下，非笛卡尔的情况会大大改变情况。显然，在非笛卡尔网格上，导数还包括超出法向导数的形状函数的切向导数，但这些也只需要元素表面的函数值。如果元素不提供任何压缩，循环会自动交换受影响单元的所有条目。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::vmult( 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src) const 
  { 
    adjust_ghost_range_if_necessary(*data, dst); 
    adjust_ghost_range_if_necessary(*data, src); 
    data->loop(&LaplaceOperator::apply_cell, 
               &LaplaceOperator::apply_face, 
               &LaplaceOperator::apply_boundary, 
               this, 
               dst, 
               src, 
               /* zero_dst =  */ true,
               MatrixFree<dim, number>::DataAccessOnFaces::gradients,
               MatrixFree<dim, number>::DataAccessOnFaces::gradients);
  } 

// 由于拉普拉斯是对称的，`Tvmult()`（多网格平滑界面需要）操作被简单地转发给`vmult()`的情况。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::Tvmult( 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src) const 
  { 
    vmult(dst, src); 
  } 

//单元格的操作与 step-37 非常相似。不过我们在这里没有使用系数。第二个区别是，我们用一个单一的函数调用 FEEvaluation::gather_evaluate() 代替了 FEEvaluation::read_dof_values() 后面的 FEEvaluation::evaluate() 这两个步骤，在内部调用这两个单独方法的序列。同样， FEEvaluation::integrate_scatter() 实现了 FEEvaluation::integrate() 之后的 FEEvaluation::distribute_local_to_global(). 的序列。 在这种情况下，这些新函数只是节省了两行代码。然而，我们用它们来与FEFaceEvaluation进行类比，在那里它们更重要，如下所述。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::apply_cell( 
    const MatrixFree<dim, number> &                   data, 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src, 
    const std::pair<unsigned int, unsigned int> &     cell_range) const 
  { 
    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data); 
    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        phi.reinit(cell); 
        phi.gather_evaluate(src, EvaluationFlags::gradients); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          phi.submit_gradient(phi.get_gradient(q), q); 
        phi.integrate_scatter(EvaluationFlags::gradients, dst); 
      } 
  } 

// 面部操作实现了与 step-39 类似的内部惩罚方法的条款，正如介绍中所解释的。我们需要两个评估器对象来完成这个任务，一个用于处理来自内部面的两边之一的单元格的解，另一个用于处理来自另一边的解。面积分的评价器被称为FEFaceEvaluation，并在构造函数的第二个槽中接受一个布尔参数，以指示评价器应属于两边中的哪一边。在FEFaceEvaluation和MatrixFree中，我们称两边中的一边为 "内部"，另一边为 "外部"。`外部'这个名字是指两边的评价器将返回相同的法向量。对于 "内部 "一侧，法向量指向外部，而另一侧则指向内部，并且与该单元的外部法向量相对应。除了新的类名之外，我们再次得到了一系列的项目，与 step-37 中讨论的类似，但在这种情况下是针对内部面的。请注意，MatrixFree的数据结构形成了面的批次，类似于单元积分的单元批次。一批中的所有面涉及不同的单元格编号，但在参考单元格中具有相同的面编号，具有相同的细化配置（无细化或相同的子面）和相同的方向，以保持SIMD操作的简单和高效。

// 注意，除了法线方向的逻辑决定外，内部与外部没有任何隐含的意义，这在内部是相当随机的。我们绝对不能依赖分配内部与外部标志的某种模式，因为这个决定是为了MatrixFree设置例程中的访问规则性和统一性而做出的。由于大多数正常的DG方法都是保守的，也就是说，通量在接口的两边看起来都是一样的，所以如果内部/外部标志被调换，法线向量得到相反的符号，那么数学就不会有任何改变。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::apply_face( 
    const MatrixFree<dim, number> &                   data, 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src, 
    const std::pair<unsigned int, unsigned int> &     face_range) const 
  { 
    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_inner(data, 
                                                                         true); 
    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_outer(data, 
                                                                         false); 
    for (unsigned int face = face_range.first; face < face_range.second; ++face) 
      { 

// 在给定的一批面孔上，我们首先更新指向当前面孔的指针，然后访问矢量。如上所述，我们把访问向量和评估结合起来。在面积分的情况下，对于FE_DGQHermite基础的特殊情况，可以减少对向量的数据访问，正如上面解释的数据交换。由于 $2(k+1)^{d-1}$ 个单元自由度中只有 $(k+1)^d$ 个单元自由度被非零值或形状函数的导数所乘，这种结构可以被用于评估，大大减少了数据访问。减少数据访问不仅是有益的，因为它减少了飞行中的数据，从而有助于缓存，而且当从单元格索引列表中相距较远的单元格收集数值时，对面的数据访问往往比单元格积分更不规则。

        phi_inner.reinit(face); 
        phi_inner.gather_evaluate(src, 
                                  EvaluationFlags::values | 
                                    EvaluationFlags::gradients); 
        phi_outer.reinit(face); 
        phi_outer.gather_evaluate(src, 
                                  EvaluationFlags::values | 
                                    EvaluationFlags::gradients); 

// 接下来的两个语句是计算内部惩罚法的惩罚参数。正如在介绍中所解释的，我们希望有一个像 $\frac{1}{h_\text{i}}$ 这样的长度 $h_\text{i}$ 法线到面的缩放比例。对于一般的非笛卡尔网格，这个长度必须由反雅各布系数乘以实坐标的法向量的乘积来计算。从这个 "dim "分量的向量中，我们必须最终挑选出与参考单元的法线方向一致的分量。在MatrixFree中存储的几何数据中，雅各布式中的分量被应用，使得后一个方向总是最后一个分量`dim-1`（这很有利，因为参考单元的导数排序可以与面的方向无关）。这意味着我们可以简单地访问最后一个分量`dim-1`，而不必在`data.get_face_info(face).internal_face_no`和`data.get_face_info(face).exterior_face_no`中查找局部面的编号。最后，我们还必须取这些因素的绝对值，因为法线可能指向正或负的方向。

        const VectorizedArray<number> inverse_length_normal_to_face = 
          0.5 * (std::abs((phi_inner.get_normal_vector(0) * 
                           phi_inner.inverse_jacobian(0))[dim - 1]) + 
                 std::abs((phi_outer.get_normal_vector(0) * 
                           phi_outer.inverse_jacobian(0))[dim - 1])); 
        const VectorizedArray<number> sigma = 
          inverse_length_normal_to_face * get_penalty_factor(); 

// 在正交点的循环中，我们最终计算了对内部惩罚方案的所有贡献。根据介绍中的公式，测试函数的值被乘以解决方案中的跳跃乘以惩罚参数和实空间中的法向导数的平均值的差值。由于内侧和外侧的两个评估器由于跳跃而得到不同的符号，我们在这里用不同的符号传递结果。测试函数的正态导数会被内侧和外侧的解决方案中的负跳跃所乘。这个术语，被称为邻接一致性术语，根据其与原始一致性术语的关系，在代码中还必须包括 $\frac{1}{2}$ 的系数，由于测试函数槽中的平均数，它得到了二分之一的系数。

        for (unsigned int q = 0; q < phi_inner.n_q_points; ++q) 
          { 
            const VectorizedArray<number> solution_jump = 
              (phi_inner.get_value(q) - phi_outer.get_value(q)); 
            const VectorizedArray<number> average_normal_derivative = 
              (phi_inner.get_normal_derivative(q) + 
               phi_outer.get_normal_derivative(q)) * 
              number(0.5); 
            const VectorizedArray<number> test_by_value = 
              solution_jump * sigma - average_normal_derivative; 

            phi_inner.submit_value(test_by_value, q); 
            phi_outer.submit_value(-test_by_value, q); 

            phi_inner.submit_normal_derivative(-solution_jump * number(0.5), q); 
            phi_outer.submit_normal_derivative(-solution_jump * number(0.5), q); 
          } 

// 一旦我们完成了正交点的循环，我们就可以对面的积分循环进行和因子化操作，并将结果加到结果向量中，使用`integrate_scatter`函数。`scatter'这个名字反映了使用与`gather_evaluate'相同的模式将矢量数据分布到矢量中的分散位置。像以前一样，整合+写操作的组合允许我们减少数据访问。

        phi_inner.integrate_scatter(EvaluationFlags::values | 
                                      EvaluationFlags::gradients, 
                                    dst); 
        phi_outer.integrate_scatter(EvaluationFlags::values | 
                                      EvaluationFlags::gradients, 
                                    dst); 
      } 
  } 

// 边界面函数大体上沿用了内部面函数。唯一的区别是，我们没有一个单独的FEFaceEvaluation对象为我们提供外部值  $u^+$  ，但我们必须从边界条件和内部值  $u^-$  来定义它们。正如介绍中所解释的，我们在Dirichlet边界上使用 $u^+ = -u^- + 2 g_\text{D}$ 和 $\mathbf{n}^-\cdot \nabla u^+ = \mathbf{n}^-\cdot \nabla u^-$ ，在Neumann边界上使用 $u^+=u^-$ 和 $\mathbf{n}^-\cdot \nabla u^+ = -\mathbf{n}^-\cdot \nabla u^- + 2 g_\text{N}$  。由于这个操作实现了同质部分，即矩阵-向量乘积，我们必须在这里忽略边界函数 $g_\text{D}$ 和 $g_\text{N}$ ，并在 `LaplaceProblem::compute_rhs()`. 中把它们加到右侧。 ] 注意，由于通过 $u^+$ 将解 $u^-$ 扩展到外部，我们可以保持所有因子 $0.5$ 与内面函数相同，也可参见 step-39 中的讨论。

// 在这一点上有一个问题。下面的实现使用一个布尔变量`is_dirichlet`来切换Dirichlet和Neumann情况。然而，我们解决了一个问题，我们还想在一些边界上施加周期性的边界条件，即沿着 $x$ 方向的边界。人们可能会问，这里应该如何处理这些条件。答案是MatrixFree会自动将周期性边界视为技术上的边界，即两个相邻单元的解值相遇的内面，必须用适当的数值通量来处理。因此，周期性边界上的所有面将出现在`apply_face()`函数中，而不是这个函数中。

  template <int dim, int fe_degree, typename number> 
  void LaplaceOperator<dim, fe_degree, number>::apply_boundary( 
    const MatrixFree<dim, number> &                   data, 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src, 
    const std::pair<unsigned int, unsigned int> &     face_range) const 
  { 
    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_inner(data, 
                                                                         true); 
    for (unsigned int face = face_range.first; face < face_range.second; ++face) 
      { 
        phi_inner.reinit(face); 
        phi_inner.gather_evaluate(src, 
                                  EvaluationFlags::values | 
                                    EvaluationFlags::gradients); 

        const VectorizedArray<number> inverse_length_normal_to_face = 
          std::abs((phi_inner.get_normal_vector(0) * 
                    phi_inner.inverse_jacobian(0))[dim - 1]); 
        const VectorizedArray<number> sigma = 
          inverse_length_normal_to_face * get_penalty_factor(); 

        const bool is_dirichlet = (data.get_boundary_id(face) == 0); 

        for (unsigned int q = 0; q < phi_inner.n_q_points; ++q) 
          { 
            const VectorizedArray<number> u_inner = phi_inner.get_value(q); 
            const VectorizedArray<number> u_outer = 
              is_dirichlet ? -u_inner : u_inner; 
            const VectorizedArray<number> normal_derivative_inner = 
              phi_inner.get_normal_derivative(q); 
            const VectorizedArray<number> normal_derivative_outer = 
              is_dirichlet ? normal_derivative_inner : -normal_derivative_inner; 
            const VectorizedArray<number> solution_jump = (u_inner - u_outer); 
            const VectorizedArray<number> average_normal_derivative = 
              (normal_derivative_inner + normal_derivative_outer) * number(0.5); 
            const VectorizedArray<number> test_by_value = 
              solution_jump * sigma - average_normal_derivative; 
            phi_inner.submit_normal_derivative(-solution_jump * number(0.5), q); 
            phi_inner.submit_value(test_by_value, q); 
          } 
        phi_inner.integrate_scatter(EvaluationFlags::values | 
                                      EvaluationFlags::gradients, 
                                    dst); 
      } 
  } 

// 接下来我们来看看预处理程序的初始化。正如介绍中所解释的，我们想从一维质量和拉普拉斯矩阵的乘积中构造一个（近似的）单元矩阵的逆。我们的首要任务是计算一维矩阵，我们通过首先创建一个一维有限元来实现。在这里，我们没有预见到FE_DGQHermite<1>，而是从DoFHandler获得有限元的名称，用1替换 @p dim 参数（2或3）来创建一个一维名称，并通过使用FETools来构造一维元素。

  template <int dim, int fe_degree, typename number> 
  void PreconditionBlockJacobi<dim, fe_degree, number>::initialize( 
    const LaplaceOperator<dim, fe_degree, number> &op) 
  { 
    data = op.get_matrix_free(); 

    std::string name = data->get_dof_handler().get_fe().get_name(); 
    name.replace(name.find('<') + 1, 1, "1"); 
    std::unique_ptr<FiniteElement<1>> fe_1d = FETools::get_fe_by_name<1>(name); 

// 至于在单位元素上计算一维矩阵，我们简单地写下在矩阵的行和列以及正交点上的典型装配程序会做什么。我们一劳永逸地选择相同的拉普拉斯矩阵，对内部面使用系数0.5（但可能由于网格的原因，在不同方向上的缩放比例不同）。因此，我们在Dirichlet边界（正确的系数应该是导数项为1，惩罚项为2，见 step-39 ）或在Neumann边界（系数应该为0）犯了一个小错误。由于我们只在多网格方案中使用这个类作为平滑器，这个错误不会有任何重大影响，只是影响平滑质量。

    const unsigned int                                 N = fe_degree + 1; 
    FullMatrix<double>                                 laplace_unscaled(N, N); 
    std::array<Table<2, VectorizedArray<number>>, dim> mass_matrices; 
    std::array<Table<2, VectorizedArray<number>>, dim> laplace_matrices; 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        mass_matrices[d].reinit(N, N); 
        laplace_matrices[d].reinit(N, N); 
      } 

    QGauss<1> quadrature(N); 
    for (unsigned int i = 0; i < N; ++i) 
      for (unsigned int j = 0; j < N; ++j) 
        { 
          double sum_mass = 0, sum_laplace = 0; 
          for (unsigned int q = 0; q < quadrature.size(); ++q) 
            { 
              sum_mass += (fe_1d->shape_value(i, quadrature.point(q)) * 
                           fe_1d->shape_value(j, quadrature.point(q))) * 
                          quadrature.weight(q); 
              sum_laplace += (fe_1d->shape_grad(i, quadrature.point(q))[0] * 
                              fe_1d->shape_grad(j, quadrature.point(q))[0]) * 
                             quadrature.weight(q); 
            } 
          for (unsigned int d = 0; d < dim; ++d) 
            mass_matrices[d](i, j) = sum_mass; 

// 接下来两个语句组装的左右边界项似乎有一些任意的符号，但这些都是正确的，可以通过查看 step-39 并插入1D情况下的法向量的值-1和1来验证。

          sum_laplace += 
            (1. * fe_1d->shape_value(i, Point<1>()) * 
               fe_1d->shape_value(j, Point<1>()) * op.get_penalty_factor() + 
             0.5 * fe_1d->shape_grad(i, Point<1>())[0] * 
               fe_1d->shape_value(j, Point<1>()) + 
             0.5 * fe_1d->shape_grad(j, Point<1>())[0] * 
               fe_1d->shape_value(i, Point<1>())); 

          sum_laplace += 
            (1. * fe_1d->shape_value(i, Point<1>(1.0)) * 
               fe_1d->shape_value(j, Point<1>(1.0)) * op.get_penalty_factor() - 
             0.5 * fe_1d->shape_grad(i, Point<1>(1.0))[0] * 
               fe_1d->shape_value(j, Point<1>(1.0)) - 
             0.5 * fe_1d->shape_grad(j, Point<1>(1.0))[0] * 
               fe_1d->shape_value(i, Point<1>(1.0))); 

          laplace_unscaled(i, j) = sum_laplace; 
        } 

// 接下来，我们通过单元格，将缩放后的矩阵传递给TensorProductMatrixSymmetricSum，以实际计算代表逆的广义特征值问题。由于矩阵的近似构造为 $A\otimes M + M\otimes A$ ，并且每个元素的权重是恒定的，我们可以在拉普拉斯矩阵上应用所有的权重，并简单地保持质量矩阵不被缩放。在单元格的循环中，我们要利用MatrixFree类提供的几何体压缩，并检查当前的几何体是否与上一批单元格上的几何体相同，在这种情况下就没有什么可做的。一旦调用了`reinit()`，就可以通过 FEEvaluation::get_mapping_data_index_offset() 访问这种压缩。

// 一旦我们通过FEEvaluation访问函数访问了反雅各布系数（我们取第4个正交点的，因为它们在笛卡尔单元的所有正交点上都应该是一样的），我们检查它是对角线的，然后提取原始雅各布系数的行列式，即反雅各布系数的行列式，并根据质量矩阵的一维拉普拉斯乘以 $d-1$ 份，设置权重为 $\text{det}(J) / h_d^2$  。

    cell_matrices.clear(); 
    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*data); 
    unsigned int old_mapping_data_index = numbers::invalid_unsigned_int; 
    for (unsigned int cell = 0; cell < data->n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 

        if (phi.get_mapping_data_index_offset() == old_mapping_data_index) 
          continue; 

        Tensor<2, dim, VectorizedArray<number>> inverse_jacobian = 
          phi.inverse_jacobian(0); 

        for (unsigned int d = 0; d < dim; ++d) 
          for (unsigned int e = 0; e < dim; ++e) 
            if (d != e) 
              for (unsigned int v = 0; v < VectorizedArray<number>::size(); ++v) 
                AssertThrow(inverse_jacobian[d][e][v] == 0., 
                            ExcNotImplemented()); 

        VectorizedArray<number> jacobian_determinant = inverse_jacobian[0][0]; 
        for (unsigned int e = 1; e < dim; ++e) 
          jacobian_determinant *= inverse_jacobian[e][e]; 
        jacobian_determinant = 1. / jacobian_determinant; 

        for (unsigned int d = 0; d < dim; ++d) 
          { 
            const VectorizedArray<number> scaling_factor = 
              inverse_jacobian[d][d] * inverse_jacobian[d][d] * 
              jacobian_determinant; 

// 一旦我们知道了拉普拉斯矩阵的比例系数，我们就将这个权重应用于未被缩放的DG拉普拉斯矩阵，并将数组发送到TensorProductMatrixSymmetricSum类，以计算介绍中提到的广义特征值问题。

            for (unsigned int i = 0; i < N; ++i) 
              for (unsigned int j = 0; j < N; ++j) 
                laplace_matrices[d](i, j) = 
                  scaling_factor * laplace_unscaled(i, j); 
          } 
        if (cell_matrices.size() <= phi.get_mapping_data_index_offset()) 
          cell_matrices.resize(phi.get_mapping_data_index_offset() + 1); 
        cell_matrices[phi.get_mapping_data_index_offset()].reinit( 
          mass_matrices, laplace_matrices); 
      } 
  } 

// 在DG背景下，用于近似块状Jacobi预处理的vmult函数非常简单。我们只需要读取当前单元格批次的值，对张量积矩阵阵列中的给定条目进行逆运算，并将结果写回。在这个循环中，我们覆盖了`dst`中的内容，而不是首先将条目设置为零。这对于DG方法来说是合法的，因为每个单元都有独立的自由度。此外，我们手动写出所有单元批的循环，而不是通过 MatrixFree::cell_loop(). 我们这样做是因为我们知道我们在这里不需要通过MPI网络进行数据交换，因为所有的计算都是在每个处理器上的本地单元上完成的。

  template <int dim, int fe_degree, typename number> 
  void PreconditionBlockJacobi<dim, fe_degree, number>::vmult( 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src) const 
  { 
    adjust_ghost_range_if_necessary(*data, dst); 
    adjust_ghost_range_if_necessary(*data, src); 

    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*data); 
    for (unsigned int cell = 0; cell < data->n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        phi.read_dof_values(src); 
        cell_matrices[phi.get_mapping_data_index_offset()].apply_inverse( 
          ArrayView<VectorizedArray<number>>(phi.begin_dof_values(), 
                                             phi.dofs_per_cell), 
          ArrayView<const VectorizedArray<number>>(phi.begin_dof_values(), 
                                                   phi.dofs_per_cell)); 
        phi.set_dof_values(dst); 
      } 
  } 

// LaplaceProblem类的定义与  step-37  非常相似。一个区别是我们将元素度作为模板参数添加到类中，这将允许我们通过在`main()`函数中创建不同的实例，更容易在同一个程序中包含多个度。第二个区别是选择了FE_DGQHermite这个元素，它是专门用于这种方程的。

  template <int dim, int fe_degree> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(); 
    void run(); 

  private: 
    void setup_system(); 
    void compute_rhs(); 
    void solve(); 
    void analyze_results() const; 

#ifdef DEAL_II_WITH_P4EST 
    parallel::distributed::Triangulation<dim> triangulation; 
#else 
    Triangulation<dim> triangulation; 
#endif 

    FE_DGQHermite<dim> fe; 
    DoFHandler<dim>    dof_handler; 

    MappingQ1<dim> mapping; 

    using SystemMatrixType = LaplaceOperator<dim, fe_degree, double>; 
    SystemMatrixType system_matrix; 

    using LevelMatrixType = LaplaceOperator<dim, fe_degree, float>; 
    MGLevelObject<LevelMatrixType> mg_matrices; 

    LinearAlgebra::distributed::Vector<double> solution; 
    LinearAlgebra::distributed::Vector<double> system_rhs; 

    double             setup_time; 
    ConditionalOStream pcout; 
    ConditionalOStream time_details; 
  }; 

  template <int dim, int fe_degree> 
  LaplaceProblem<dim, fe_degree>::LaplaceProblem() 
    : 
#ifdef DEAL_II_WITH_P4EST 
    triangulation( 
      MPI_COMM_WORLD, 
      Triangulation<dim>::limit_level_difference_at_vertices, 
      parallel::distributed::Triangulation<dim>::construct_multigrid_hierarchy) 
    , 
#else 
    triangulation(Triangulation<dim>::limit_level_difference_at_vertices) 
    , 
#endif 
    fe(fe_degree) 
    , dof_handler(triangulation) 
    , setup_time(0.) 
    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
    , time_details(std::cout, 
                   false && 
                     Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
  {} 

// 设置函数在两个方面与  step-37  不同。首先是我们不需要为不连续的Ansatz空间插值任何约束，而只是将一个假的AffineConstraints对象传入 Matrixfree::reinit().  第二个变化是因为我们需要告诉MatrixFree同时初始化面的数据结构。我们通过为内部面和边界面分别设置更新标志来做到这一点。在边界面，我们需要函数值、它们的梯度、JxW值（用于积分）、法向量和正交点（用于边界条件的评估），而对于内部面，我们只需要形状函数值、梯度、JxW值和法向量。只要`mapping_update_flags_inner_faces`或`mapping_update_flags_boundary_faces`中的一个与UpdateFlags的默认值`update_default`不同，MatrixFree中的面数据结构总是被建立的。

  template <int dim, int fe_degree> 
  void LaplaceProblem<dim, fe_degree>::setup_system() 
  { 
    Timer time; 
    setup_time = 0; 

    system_matrix.clear(); 
    mg_matrices.clear_elements(); 

    dof_handler.distribute_dofs(fe); 
    dof_handler.distribute_mg_dofs(); 

    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
          << std::endl; 

    setup_time += time.wall_time(); 
    time_details << "Distribute DoFs               " << time.wall_time() << " s" 
                 << std::endl; 
    time.restart(); 

    AffineConstraints<double> dummy; 
    dummy.close(); 

    { 
      typename MatrixFree<dim, double>::AdditionalData additional_data; 
      additional_data.tasks_parallel_scheme = 
        MatrixFree<dim, double>::AdditionalData::none; 
      additional_data.mapping_update_flags = 
        (update_gradients | update_JxW_values | update_quadrature_points); 
      additional_data.mapping_update_flags_inner_faces = 
        (update_gradients | update_JxW_values | update_normal_vectors); 
      additional_data.mapping_update_flags_boundary_faces = 
        (update_gradients | update_JxW_values | update_normal_vectors | 
         update_quadrature_points); 
      const auto system_mf_storage = 
        std::make_shared<MatrixFree<dim, double>>(); 
      system_mf_storage->reinit( 
        mapping, dof_handler, dummy, QGauss<1>(fe.degree + 1), additional_data); 
      system_matrix.initialize(system_mf_storage); 
    } 

    system_matrix.initialize_dof_vector(solution); 
    system_matrix.initialize_dof_vector(system_rhs); 

    setup_time += time.wall_time(); 
    time_details << "Setup matrix-free system      " << time.wall_time() << " s" 
                 << std::endl; 
    time.restart(); 

    const unsigned int nlevels = triangulation.n_global_levels(); 
    mg_matrices.resize(0, nlevels - 1); 

    for (unsigned int level = 0; level < nlevels; ++level) 
      { 
        typename MatrixFree<dim, float>::AdditionalData additional_data; 
        additional_data.tasks_parallel_scheme = 
          MatrixFree<dim, float>::AdditionalData::none; 
        additional_data.mapping_update_flags = 
          (update_gradients | update_JxW_values); 
        additional_data.mapping_update_flags_inner_faces = 
          (update_gradients | update_JxW_values); 
        additional_data.mapping_update_flags_boundary_faces = 
          (update_gradients | update_JxW_values); 
        additional_data.mg_level = level; 
        const auto mg_mf_storage_level = 
          std::make_shared<MatrixFree<dim, float>>(); 
        mg_mf_storage_level->reinit(mapping, 
                                    dof_handler, 
                                    dummy, 
                                    QGauss<1>(fe.degree + 1), 
                                    additional_data); 

        mg_matrices[level].initialize(mg_mf_storage_level); 
      } 
    setup_time += time.wall_time(); 
    time_details << "Setup matrix-free levels      " << time.wall_time() << " s" 
                 << std::endl; 
  } 

// 右手边的计算比  step-37  中的计算要复杂一些。现在的单元项包括分析解的负拉普拉斯，`RightHandSide'，为此我们需要首先将VectorizedArray字段的Point，即一批点，通过分别评估VectorizedArray中的所有通道，拆成一个点。请记住，通道的数量取决于硬件；对于不提供矢量化的系统（或deal.II没有本征），它可能是1，但在最近的Intel架构的AVX-512上也可能是8或16。

  template <int dim, int fe_degree> 
  void LaplaceProblem<dim, fe_degree>::compute_rhs() 
  { 
    Timer time; 
    system_rhs                          = 0; 
    const MatrixFree<dim, double> &data = *system_matrix.get_matrix_free(); 
    FEEvaluation<dim, fe_degree>   phi(data); 
    RightHandSide<dim>             rhs_func; 
    Solution<dim>                  exact_solution; 
    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            VectorizedArray<double> rhs_val = VectorizedArray<double>(); 
            Point<dim, VectorizedArray<double>> point_batch = 
              phi.quadrature_point(q); 
            for (unsigned int v = 0; v < VectorizedArray<double>::size(); ++v) 
              { 
                Point<dim> single_point; 
                for (unsigned int d = 0; d < dim; ++d) 
                  single_point[d] = point_batch[d][v]; 
                rhs_val[v] = rhs_func.value(single_point); 
              } 
            phi.submit_value(rhs_val, q); 
          } 
        phi.integrate_scatter(EvaluationFlags::values, system_rhs); 
      } 

// 其次，我们还需要应用Dirichlet和Neumann边界条件。一旦Dirichlet边界上的外部求解值 $u^+ = -u^- + 2 g_\text{D}$ 和 $\mathbf{n}^-\cdot \nabla u^+ = \mathbf{n}^-\cdot \nabla u^-$ 以及Neumann边界上的 $u^+=u^-$ 和 $\mathbf{n}^-\cdot \nabla u^+ = -\mathbf{n}^-\cdot \nabla u^- + 2 g_\text{N}$ 被插入并以边界函数 $g_\text{D}$ 和 $g_\text{N}$ 展开，这个函数就是到函数 `LaplaceOperator::apply_boundary()` 所缺的部分。需要记住的一点是，我们把边界条件移到右手边，所以符号与我们强加在解的部分相反。

// 我们可以通过 MatrixFree::loop 部分发出单元格和边界部分，但我们选择手动写出所有面的完整循环，以了解MatrixFree中面的索引布局是如何设置的：内部面和边界面都共享索引范围，所有批次的内部面的数字都比批次的边界单元格低。两种变体的单一索引使我们可以很容易地在两种情况下使用相同的数据结构FEFaceEvaluation，它附着在同一个数据域上，只是位置不同。内层面的批次（其中一个批次是由于将几个面合并成一个面进行矢量化）的数量由 MatrixFree::n_inner_face_batches(), 给出，而边界面的批次数量由 MatrixFree::n_boundary_face_batches(). 给出。
    FEFaceEvaluation<dim, fe_degree> phi_face(data, true); 
    for (unsigned int face = data.n_inner_face_batches(); 
         face < data.n_inner_face_batches() + data.n_boundary_face_batches(); 
         ++face) 
      { 
        phi_face.reinit(face); 

        const VectorizedArray<double> inverse_length_normal_to_face = 
          std::abs((phi_face.get_normal_vector(0) * 
                    phi_face.inverse_jacobian(0))[dim - 1]); 
        const VectorizedArray<double> sigma = 
          inverse_length_normal_to_face * system_matrix.get_penalty_factor(); 

        for (unsigned int q = 0; q < phi_face.n_q_points; ++q) 
          { 
            VectorizedArray<double> test_value = VectorizedArray<double>(), 
                                    test_normal_derivative = 
                                      VectorizedArray<double>(); 
            Point<dim, VectorizedArray<double>> point_batch = 
              phi_face.quadrature_point(q); 

            for (unsigned int v = 0; v < VectorizedArray<double>::size(); ++v) 
              { 
                Point<dim> single_point; 
                for (unsigned int d = 0; d < dim; ++d) 
                  single_point[d] = point_batch[d][v]; 

// MatrixFree类让我们查询当前面批的边界_id。请记住，MatrixFree为矢量化设置了批次，使一个批次中的所有面孔都有相同的属性，其中包括它们的`边界_id'。因此，我们可以在这里为当前面的索引`face`查询该id，并在Dirichlet情况下（我们在函数值上添加一些东西）或Neumann情况下（我们在法线导数上添加一些东西）施加。

                if (data.get_boundary_id(face) == 0) 
                  test_value[v] = 2.0 * exact_solution.value(single_point); 
                else 
                  { 
                    Tensor<1, dim> normal; 
                    for (unsigned int d = 0; d < dim; ++d) 
                      normal[d] = phi_face.get_normal_vector(q)[d][v]; 
                    test_normal_derivative[v] = 
                      -normal * exact_solution.gradient(single_point); 
                  } 
              } 
            phi_face.submit_value(test_value * sigma - test_normal_derivative, 
                                  q); 
            phi_face.submit_normal_derivative(-0.5 * test_value, q); 
          } 
        phi_face.integrate_scatter(EvaluationFlags::values | 
                                     EvaluationFlags::gradients, 
                                   system_rhs); 
      } 

// 由于我们手动运行了单元格的循环，而不是使用 MatrixFree::loop(), ，我们不能忘记与MPI进行数据交换。

// 或者说，对于DG元素来说，我们不需要这样做，因为每个单元都有自己的自由度，单元和边界积分只对本地拥有的单元进行评估。与相邻子域的耦合只通过内表面积分来实现，我们在这里没有做这个。也就是说，在这里调用这个函数并没有什么坏处，所以我们这样做是为了提醒大家在 MatrixFree::loop(). 里面发生了什么。
    system_rhs.compress(VectorOperation::add); 
    setup_time += time.wall_time(); 
    time_details << "Compute right hand side       " << time.wall_time() 
                 << " s\n"; 
  } 

// `solve()`函数几乎逐字复制自  step-37  。我们设置了相同的多网格成分，即水平转移、平滑器和粗略的网格求解器。唯一不同的是，我们没有使用拉普拉斯的对角线作为用于平滑的切比雪夫迭代的预处理，而是使用我们新解决的类`%PreconditionBlockJacobi`。不过，机制是一样的。

  template <int dim, int fe_degree> 
  void LaplaceProblem<dim, fe_degree>::solve() 
  { 
    Timer                            time; 
    MGTransferMatrixFree<dim, float> mg_transfer; 
    mg_transfer.build(dof_handler); 
    setup_time += time.wall_time(); 
    time_details << "MG build transfer time        " << time.wall_time() 
                 << " s\n"; 
    time.restart(); 

    using SmootherType = 
      PreconditionChebyshev<LevelMatrixType, 
                            LinearAlgebra::distributed::Vector<float>, 
                            PreconditionBlockJacobi<dim, fe_degree, float>>; 
    mg::SmootherRelaxation<SmootherType, 
                           LinearAlgebra::distributed::Vector<float>> 
                                                         mg_smoother; 
    MGLevelObject<typename SmootherType::AdditionalData> smoother_data; 
    smoother_data.resize(0, triangulation.n_global_levels() - 1); 
    for (unsigned int level = 0; level < triangulation.n_global_levels(); 
         ++level) 
      { 
        if (level > 0) 
          { 
            smoother_data[level].smoothing_range     = 15.; 
            smoother_data[level].degree              = 3; 
            smoother_data[level].eig_cg_n_iterations = 10; 
          } 
        else 
          { 
            smoother_data[0].smoothing_range = 2e-2; 
            smoother_data[0].degree          = numbers::invalid_unsigned_int; 
            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m(); 
          } 
        smoother_data[level].preconditioner = 
          std::make_shared<PreconditionBlockJacobi<dim, fe_degree, float>>(); 
        smoother_data[level].preconditioner->initialize(mg_matrices[level]); 
      } 
    mg_smoother.initialize(mg_matrices, smoother_data); 

    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>> 
      mg_coarse; 
    mg_coarse.initialize(mg_smoother); 

    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix( 
      mg_matrices); 

    Multigrid<LinearAlgebra::distributed::Vector<float>> mg( 
      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother); 

    PreconditionMG<dim, 
                   LinearAlgebra::distributed::Vector<float>, 
                   MGTransferMatrixFree<dim, float>> 
      preconditioner(dof_handler, mg, mg_transfer); 

    SolverControl solver_control(10000, 1e-12 * system_rhs.l2_norm()); 
    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control); 
    setup_time += time.wall_time(); 
    time_details << "MG build smoother time        " << time.wall_time() 
                 << "s\n"; 
    pcout << "Total setup time              " << setup_time << " s\n"; 

    time.reset(); 
    time.start(); 
    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    pcout << "Time solve (" << solver_control.last_step() << " iterations)    " 
          << time.wall_time() << " s" << std::endl; 
  } 

// 由于我们已经用分析法解决了一个问题，我们想通过计算数值结果与分析法的L2误差来验证我们实现的正确性。

  template <int dim, int fe_degree> 
  void LaplaceProblem<dim, fe_degree>::analyze_results() const 
  { 
    Vector<float> error_per_cell(triangulation.n_active_cells()); 
    VectorTools::integrate_difference(mapping, 
                                      dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      error_per_cell, 
                                      QGauss<dim>(fe.degree + 2), 
                                      VectorTools::L2_norm); 
    pcout << "Verification via L2 error:    " 
          << std::sqrt( 
               Utilities::MPI::sum(error_per_cell.norm_sqr(), MPI_COMM_WORLD)) 
          << std::endl; 
  } 

// `run()`函数设置了初始网格，然后以常规方式运行多网格程序。作为一个域，我们选择一个矩形，在 $x$ -方向上有周期性的边界条件，在 $y$ 方向上的正面（即索引号为2的面，边界id等于0）有迪里希特条件，在背面以及 $z$ 方向上的两个面为三维情况（边界id等于1）有纽曼条件。与 $y$ 和 $z$ 方向相比， $x$ 方向的域的范围有些不同（考虑到 "解决方案 "的定义，我们希望在这里实现周期性的解决方案）。

  template <int dim, int fe_degree> 
  void LaplaceProblem<dim, fe_degree>::run() 
  { 
    const unsigned int n_ranks = 
      Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD); 
    pcout << "Running with " << n_ranks << " MPI process" 
          << (n_ranks > 1 ? "es" : "") << ", element " << fe.get_name() 
          << std::endl 
          << std::endl; 
    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle) 
      { 
        pcout << "Cycle " << cycle << std::endl; 

        if (cycle == 0) 
          { 
            Point<dim> upper_right; 
            upper_right[0] = 2.5; 
            for (unsigned int d = 1; d < dim; ++d) 
              upper_right[d] = 2.8; 
            GridGenerator::hyper_rectangle(triangulation, 
                                           Point<dim>(), 
                                           upper_right); 
            triangulation.begin_active()->face(0)->set_boundary_id(10); 
            triangulation.begin_active()->face(1)->set_boundary_id(11); 
            triangulation.begin_active()->face(2)->set_boundary_id(0); 
            for (unsigned int f = 3; 
                 f < triangulation.begin_active()->n_faces(); 
                 ++f) 
              triangulation.begin_active()->face(f)->set_boundary_id(1); 

            std::vector<GridTools::PeriodicFacePair< 
              typename Triangulation<dim>::cell_iterator>> 
              periodic_faces; 
            GridTools::collect_periodic_faces( 
              triangulation, 10, 11, 0, periodic_faces); 
            triangulation.add_periodicity(periodic_faces); 

            triangulation.refine_global(6 - 2 * dim); 
          } 
        triangulation.refine_global(1); 
        setup_system(); 
        compute_rhs(); 
        solve(); 
        analyze_results(); 
        pcout << std::endl; 
      }; 
  } 
} // namespace Step59 

// `main()`函数中没有任何意外。我们通过`MPI_Init()`类调用`MPI_InitFinalize`，传入文件顶部设置的关于维度和度的两个参数，然后运行拉普拉斯问题。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace Step59; 

      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1); 

      LaplaceProblem<dimension, degree_finite_element> laplace_problem; 
      laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-6.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2000 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 2000 
 */ 


// @sect3{Include files}  

// 前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。

#include <deal.II/base/quadrature_lib.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_values.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 

#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

#include <fstream> 

// 从下面的include文件中我们将导入H1-conforming有限元形状函数的声明。这个有限元系列被称为  <code>FE_Q</code>  ，在之前的所有例子中已经被用来定义通常的双线性或三线性元素，但我们现在将用它来定义双二次元元素。

#include <deal.II/fe/fe_q.h> 

// 我们不会像前面的例子那样从文件中读取网格，而是使用库中的一个函数生成网格。然而，我们将希望在每一步中写出局部细化的网格（只是网格，而不是解决方案），所以我们需要以下的include文件，而不是 <code>grid_in.h</code>  。

#include <deal.II/grid/grid_out.h> 

// 当使用局部细化网格时，我们会得到所谓的<code>悬空节点</code>。然而，标准的有限元方法假定离散的解空间是连续的，所以我们需要确保悬挂节点上的自由度符合一些约束条件，这样全局解是连续的。我们也要在这个对象中存储边界条件。下面的文件包含一个用来处理这些约束条件的类。

#include <deal.II/lac/affine_constraints.h> 

// 为了在本地细化我们的网格，我们需要一个来自库的函数，根据我们计算的误差指标来决定哪些单元需要细化或粗化。这个函数被定义在这里。

#include <deal.II/grid/grid_refinement.h> 

// 最后，我们需要一个简单的方法来实际计算基于某种误差估计的细化指标。虽然一般来说，适应性是非常具体的问题，但以下文件中的误差指标通常会对一大类问题产生相当好的适应网格。

#include <deal.II/numerics/error_estimator.h> 

// 最后，这和以前的程序一样。

using namespace dealii; 
// @sect3{The <code>Step6</code> class template}  

// 主类又是几乎没有变化的。然而，我们增加了两项内容：我们增加了 <code>refine_grid</code> 函数，该函数用于自适应地细化网格（而不是之前例子中的全局细化），还有一个变量，它将保存约束条件。

template <int dim> 
class Step6 
{ 
public: 
  Step6(); 

  void run(); 

private: 
  void setup_system(); 
  void assemble_system(); 
  void solve(); 
  void refine_grid(); 
  void output_results(const unsigned int cycle) const; 

  Triangulation<dim> triangulation; 

  FE_Q<dim>       fe; 
  DoFHandler<dim> dof_handler; 

// 这是主类中的新变量。我们需要一个对象，它持有一个约束条件的列表，以保持悬挂节点和边界条件。

  AffineConstraints<double> constraints; 

  SparseMatrix<double> system_matrix; 
  SparsityPattern      sparsity_pattern; 

  Vector<double> solution; 
  Vector<double> system_rhs; 
}; 
// @sect3{Nonconstant coefficients}  

//非恒定系数的实现是逐字复制自  step-5  。

template <int dim> 
double coefficient(const Point<dim> &p) 
{ 
  if (p.square() < 0.5 * 0.5) 
    return 20; 
  else 
    return 1; 
} 

//  @sect3{The <code>Step6</code> class implementation}  
// @sect4{Step6::Step6}  

// 这个类的构造函数与之前的基本相同，但这一次我们要使用二次元。为此，我们只需用所需的多项式度数（这里是 <code>2</code> ）替换构造函数参数（在之前的所有例子中是 <code>1</code> ）。

template <int dim> 
Step6<dim>::Step6() 
  : fe(2) 
  , dof_handler(triangulation) 
{} 

//  @sect4{Step6::setup_system}  

// 下一个函数设置了所有描述线性有限元问题的变量，如DoFHandler、矩阵和向量。与我们在 step-5 中所做的不同的是，我们现在还必须处理悬挂节点约束。这些约束几乎完全由库来处理，也就是说，你只需要知道它们的存在以及如何获得它们，但你不需要知道它们是如何形成的，也不需要知道对它们到底做了什么。

// 在函数的开头，你会发现所有与 step-5 中相同的东西：设置自由度（这次我们有二次元，但从用户代码的角度看与线性--或任何其他程度的情况没有区别），生成稀疏模式，并初始化解和右手向量。请注意，现在每行的稀疏模式将有更多的条目，因为现在每个单元有9个自由度（而不是只有4个），它们可以相互耦合。

template <int dim> 
void Step6<dim>::setup_system() 
{ 
  dof_handler.distribute_dofs(fe); 

  solution.reinit(dof_handler.n_dofs()); 
  system_rhs.reinit(dof_handler.n_dofs()); 

// 我们现在可以用悬挂节点的约束来填充AffineConstraints对象。由于我们将在一个循环中调用这个函数，所以我们首先清除上一个系统中的当前约束集，然后计算新的约束。

  constraints.clear(); 
  DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

// 现在我们准备用指标0（整个边界）来插值边界值，并将得到的约束存储在我们的 <code>constraints</code> 对象中。请注意，我们并不像在前面的步骤中那样，在装配后应用边界条件：相反，我们将所有的约束条件放在AffineConstraints对象中的我们的函数空间。我们可以按任何顺序向AffineConstraints对象添加约束：如果两个约束发生冲突，那么约束矩阵要么中止，要么通过Assert宏抛出一个异常。

  VectorTools::interpolate_boundary_values(dof_handler, 
                                           0, 
                                           Functions::ZeroFunction<dim>(), 
                                           constraints); 

// 在所有约束条件被添加之后，需要对它们进行排序和重新排列，以便更有效地执行一些操作。这种后处理是用 <code>close()</code> 函数完成的，之后就不能再添加任何约束了。

  constraints.close(); 

// 现在我们首先建立我们的压缩稀疏模式，就像我们在前面的例子中做的那样。然而，我们并没有立即将其复制到最终的稀疏度模式中。 请注意，我们调用了make_sparsity_pattern的一个变体，它把AffineConstraints对象作为第三个参数。我们通过将参数 <code>keep_constrained_dofs</code> 设置为false（换句话说，我们永远不会写入矩阵中对应于受限自由度的条目），让该例程知道我们永远不会写入 <code>constraints</code> 所给的位置。如果我们在装配后对约束进行压缩，我们就必须通过 <code>true</code> 来代替，因为这样我们就会先写进这些位置，然后在压缩过程中再将它们设置为零。

  DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
  DoFTools::make_sparsity_pattern(dof_handler, 
                                  dsp, 
                                  constraints, 
                                  /*keep_constrained_dofs =  */ false);

// 现在，矩阵的所有非零条目都是已知的（即那些来自定期组装矩阵的条目和那些通过消除约束引入的条目）。我们可以将我们的中间对象复制到稀疏模式中。

  sparsity_pattern.copy_from(dsp); 

// 我们现在可以，最后，初始化稀疏矩阵。

  system_matrix.reinit(sparsity_pattern); 
} 
// @sect4{Step6::assemble_system}  

// 接下来，我们要对矩阵进行组装。然而，为了将每个单元上的本地矩阵和向量复制到全局系统中，我们不再使用手写的循环。相反，我们使用 AffineConstraints::distribute_local_to_global() ，在内部执行这个循环，同时对对应于受限自由度的行和列进行高斯消除。

// 构成局部贡献的其余代码保持不变。然而，值得注意的是，在引擎盖下，有几件事与以前不同。首先，变量 <code>dofs_per_cell</code> 和返回值 <code>quadrature_formula.size()</code> 现在各为9，以前是4。引入这样的变量作为缩写是一个很好的策略，可以使代码在不同的元素下工作，而不需要改变太多的代码。其次， <code>fe_values</code> 对象当然也需要做其他事情，因为现在的形状函数是二次的，而不是线性的，在每个坐标变量中。不过，这也是完全由库来处理的事情。

template <int dim> 
void Step6<dim>::assemble_system() 
{ 
  const QGauss<dim> quadrature_formula(fe.degree + 1); 

  FEValues<dim> fe_values(fe, 
                          quadrature_formula, 
                          update_values | update_gradients | 
                            update_quadrature_points | update_JxW_values); 

  const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
  Vector<double>     cell_rhs(dofs_per_cell); 

  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

  for (const auto &cell : dof_handler.active_cell_iterators()) 
    { 
      cell_matrix = 0; 
      cell_rhs    = 0; 

      fe_values.reinit(cell); 

      for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
        { 
          const double current_coefficient = 
            coefficient(fe_values.quadrature_point(q_index)); 
          for (const unsigned int i : fe_values.dof_indices()) 
            { 
              for (const unsigned int j : fe_values.dof_indices()) 
                cell_matrix(i, j) += 
                  (current_coefficient *              // a(x_q) 
                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q) 
                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q) 
                   fe_values.JxW(q_index));           // dx 

              cell_rhs(i) += (1.0 *                               // f(x) 
                              fe_values.shape_value(i, q_index) * // phi_i(x_q) 
                              fe_values.JxW(q_index));            // dx 
            } 
        } 

// 最后，将 @p cell_matrix 和 @p cell_rhs 中的贡献转移到全局对象中。

      cell->get_dof_indices(local_dof_indices); 
      constraints.distribute_local_to_global( 
        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); 
    } 

// 现在我们已经完成了线性系统的组装。约束矩阵处理了应用边界条件的问题，也消除了悬挂的节点约束。受约束的节点仍然在线性系统中（在矩阵的对角线上有一个非零条目，选择的方式是使矩阵具有良好的条件，并且这一行的所有其他条目都被设置为零），但是计算出来的值是无效的（也就是说， <code>system_rhs</code> 中的相应条目目前是没有意义的）。我们在 <code>solve</code> 函数的最后为这些节点计算出正确的值。

} 
// @sect4{Step6::solve}  

// 我们继续逐步改进。解决线性系统的函数再次使用了SSOR预处理程序，除了我们必须加入悬空节点约束外，其他的都没有改变。如上所述，通过对矩阵的行和列进行特殊处理，从AffineConstraints对象中删除了对应于悬挂节点约束和边界值的自由度。这样一来，这些自由度的值在求解线性系统后就有了错误的、但定义明确的值。然后我们要做的就是利用约束条件给它们分配它们应该有的值。这个过程被称为 <code>distributing</code> 约束，从无约束的节点的值中计算出约束节点的值，只需要一个额外的函数调用，你可以在这个函数的末尾找到。

template <int dim> 
void Step6<dim>::solve() 
{ 
  SolverControl            solver_control(1000, 1e-12); 
  SolverCG<Vector<double>> solver(solver_control); 

  PreconditionSSOR<SparseMatrix<double>> preconditioner; 
  preconditioner.initialize(system_matrix, 1.2); 

  solver.solve(system_matrix, solution, system_rhs, preconditioner); 

  constraints.distribute(solution); 
} 
// @sect4{Step6::refine_grid}  

// 我们使用一个复杂的误差估计方案来细化网格，而不是全局细化。我们将使用KellyErrorEstimator类，该类实现了拉普拉斯方程的误差估计器；原则上它可以处理可变系数，但我们不会使用这些高级功能，而是使用其最简单的形式，因为我们对定量结果不感兴趣，只对生成局部细化网格的快速方法感兴趣。

// 尽管Kelly等人得出的误差估计器最初是为拉普拉斯方程开发的，但我们发现它也很适合于为一类广泛的问题快速生成局部细化网格。这个误差估计器使用了解梯度在单元面上的跳跃（这是一个测量二阶导数的方法），并将其按单元的大小进行缩放。因此，它是对每个单元的解的局部平滑性的测量，因此可以理解，它对双曲运输问题或波浪方程也能产生合理的网格，尽管这些网格与专门针对该问题的方法相比肯定是次优的。因此，这个误差估计器可以理解为测试自适应程序的一种快速方法。

// 估算器的工作方式是将描述自由度的 <code>DoFHandler</code> 对象和每个自由度的数值向量作为输入，为三角剖分的每个活动单元计算一个指标值（即每个活动单元一个数值）。为此，它需要两个额外的信息：一个面部正交公式，即 <code>dim-1</code> 维物体上的正交公式。我们再次使用3点高斯法则，这个选择与本程序中的双二次方有限元形状函数是一致和合适的。当然，什么是合适的正交规则取决于对误差估计器评估解场的方式的了解。如上所述，梯度的跳跃在每个面上都是集成的，对于本例中使用的二次元元素来说，这将是每个面上的二次元函数。然而，事实上，它是梯度跳动的平方，正如该类文件中所解释的那样，这是一个二次函数，对于它来说，3点高斯公式就足够了，因为它可以精确地整合5阶以下的多项式。)

// 其次，该函数需要一个边界指示器的列表，用于那些我们施加了 $\partial_n u(\mathbf x) = h(\mathbf x)$ 类诺伊曼值的边界，以及每个此类边界的函数 $h(\mathbf x)$ 。这些信息由一个从边界指标到描述诺伊曼边界值的函数对象的映射来表示。在本例程序中，我们不使用诺伊曼边界值，所以这个映射是空的，实际上是在函数调用期望得到相应函数参数的地方使用映射的默认构造器构造的。

// 输出是一个所有活动单元的值的向量。虽然非常精确地计算一个解的自由度的<b>value</b>可能是有意义的，但通常没有必要特别精确地计算一个单元上的解对应的<b>error
 indicator</b>。因此，我们通常使用一个浮点数的向量而不是一个双数的向量来表示误差指标。

template <int dim> 
void Step6<dim>::refine_grid() 
{ 
  Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

  KellyErrorEstimator<dim>::estimate(dof_handler, 
                                     QGauss<dim - 1>(fe.degree + 1), 
                                     {}, 
                                     solution, 
                                     estimated_error_per_cell); 

// 上述函数为 <code>estimated_error_per_cell</code> 数组中的每个单元格返回一个错误指标值。现在的细化工作如下：细化那些误差值最高的30%的单元，粗化那些误差值最低的3%的单元。

// 人们可以很容易地验证，如果第二个数字为零，这大约会导致在两个空间维度上的每一步的细胞翻倍，因为对于每一个30%的细胞，四个新的将被替换，而其余70%的细胞保持不动。在实践中，通常会产生一些更多的单元，因为不允许一个单元被精炼两次而相邻的单元没有被精炼；在这种情况下，相邻的单元也会被精炼。

// 在许多应用中，被粗化的单元格数量将被设置为大于3%的数值。一个非零的值是很有用的，特别是当初始（粗）网格由于某种原因已经相当精细时。在这种情况下，可能有必要在某些区域进行细化，而在另一些区域进行粗化是有用的。在我们这里，初始网格是非常粗的，所以粗化只需要在一些可能发生过度细化的区域。因此，一个小的、非零的值在这里是合适的。

// 下面的函数现在接受这些细化指标，并使用上述方法对三角形的一些单元进行细化或粗化标记。它来自一个实现了几种不同算法的类，可以根据单元的误差指标来细化三角形。

  GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                  estimated_error_per_cell, 
                                                  0.3, 
                                                  0.03); 

// 在前一个函数退出后，一些单元被标记为细化，另一些单元被标记为粗化。然而，细化或粗化本身并没有被执行，因为有些情况下，进一步修改这些标志是有用的。在这里，我们不想做任何这样的事情，所以我们可以告诉三角计算执行单元格被标记的动作。

  triangulation.execute_coarsening_and_refinement(); 
} 
// @sect4{Step6::output_results}  

// 在每个网格的计算结束后，在我们继续下一个网格细化周期之前，我们要输出这个周期的结果。

// 我们已经在 step-1 中看到了如何实现对网格本身的输出。在这里，我们改变一些东西。  <ol>  
// <li>  我们使用两种不同的格式。gnuplot和VTU。 </li>  
// <li>  我们在输出文件名中嵌入了周期号。 </li>  
// <li>  对于gnuplot输出，我们设置了一个 GridOutFlags::Gnuplot 对象，以提供一些额外的可视化参数，使边缘看起来是弯曲的。这在  step-10  中有进一步的详细解释。 </li>  
// </ol>  
template <int dim> 
void Step6<dim>::output_results(const unsigned int cycle) const 
{ 
  { 
    GridOut               grid_out; 
    std::ofstream         output("grid-" + std::to_string(cycle) + ".gnuplot"); 
    GridOutFlags::Gnuplot gnuplot_flags(false, 5); 
    grid_out.set_flags(gnuplot_flags); 
    MappingQGeneric<dim> mapping(3); 
    grid_out.write_gnuplot(triangulation, output, &mapping); 
  } 

  { 
    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.build_patches(); 

    std::ofstream output("solution-" + std::to_string(cycle) + ".vtu"); 
    data_out.write_vtu(output); 
  } 
} 
// @sect4{Step6::run}  

//  <code>main()</code> 之前的最后一个函数又是该类的主要驱动，  <code>run()</code>  。它与  step-5  的函数类似，只是我们在程序中再次生成一个文件，而不是从磁盘中读取，我们自适应地而不是全局地细化网格，并且我们在本函数中输出最终网格上的解决方案。

// 该函数主循环的第一个块是处理网格生成。如果这是该程序的第一个循环，我们现在不是像上一个例子那样从磁盘上的文件中读取网格，而是再次使用库函数来创建它。域还是一个圆，中心在原点，半径为1（这是函数的两个隐藏参数，有默认值）。

// 你会注意到粗略的网格比我们在前面的例子中从文件中读出的网格质量要差：单元格的形成不太平均。然而，使用库函数，这个程序在任何空间维度上都可以工作，而以前不是这样的。

// 如果我们发现这不是第一个周期，我们要细化网格。与上一个例子程序中采用的全局细化不同，我们现在使用上述的自适应程序。

// 循环的其余部分看起来和以前一样。

template <int dim> 
void Step6<dim>::run() 
{ 
  for (unsigned int cycle = 0; cycle < 8; ++cycle) 
    { 
      std::cout << "Cycle " << cycle << ':' << std::endl; 

      if (cycle == 0) 
        { 
          GridGenerator::hyper_ball(triangulation); 
          triangulation.refine_global(1); 
        } 
      else 
        refine_grid(); 

      std::cout << "   Number of active cells:       " 
                << triangulation.n_active_cells() << std::endl; 

      setup_system(); 

      std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
                << std::endl; 

      assemble_system(); 
      solve(); 
      output_results(cycle); 
    } 
} 
// @sect3{The <code>main</code> function}  

// 主函数的功能与之前的例子相比没有改变，但我们采取了额外的谨慎措施。有时，会出现一些问题（比如写输出文件时磁盘空间不足，试图分配向量或矩阵时内存不足，或者由于某种原因我们无法从文件中读取或写入文件），在这些情况下，库会抛出异常。由于这些是运行时的问题，而不是可以一劳永逸的编程错误，这种异常在优化模式下不会被关闭，与我们用来测试编程错误的 <code>Assert</code> 宏相反。如果没有被捕获，这些异常会传播到 <code>main</code> 函数的调用树上，如果它们在那里也没有被捕获，程序就会被中止。在很多情况下，比如内存或磁盘空间不足，我们什么也做不了，但我们至少可以打印一些文字，试图解释程序失败的原因。下面显示了一种方法。以这种方式编写任何较大的程序当然是有用的，你可以通过或多或少地复制这个函数来做到这一点，但 <code>try</code> 块除外，它实际上编码了本应用程序所特有的功能。

int main() 
{ 

// 这个函数布局的总体思路如下：让我们试着像以前那样运行程序......

  try 
    { 
      Step6<2> laplace_problem_2d; 
      laplace_problem_2d.run(); 
    } 

// ......如果这应该是失败的，尽量收集尽可能多的信息。具体来说，如果被抛出的异常是一个从C++标准类派生出来的对象  <code>exception</code>, then we can use the <code>what</code>  成员函数，以获得一个描述异常被抛出原因的字符串。

// deal.II的异常类都是从标准类派生出来的，特别是 <code>exc.what()</code> 函数将返回与使用 <code>Assert</code> 宏抛出的异常所产生的字符串大致相同。在前面的例子中，你已经看到了这种异常的输出，然后你知道它包含了异常发生的文件和行号，以及其他一些信息。这也是下面的语句会打印的内容。

// 除此以外，除了用错误代码退出程序（这就是 <code>return 1;</code> 的作用），我们能做的并不多。

  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 

// 如果在某处抛出的异常不是从标准 <code>exception</code> 类派生出来的对象，那么我们根本无法做任何事情。那么我们就简单地打印一个错误信息并退出。

  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

// 如果我们走到这一步，就没有任何异常传播到主函数上（可能有异常，但它们在程序或库的某个地方被捕获）。因此，程序按预期执行，我们可以无误返回。

  return 0; 
} 


CCTest_file/step-60.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2018 - 2020 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Luca Heltai, Giovanni Alzetta, 
 * International School for Advanced Studies, Trieste, 2018 
 */ 


// @sect3{Include files}  其中大部分已经在其他地方介绍过了，我们只对新的部分进行评论。

#include <deal.II/base/logstream.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/timer.h> 

// 参数接受器类是本教程程序的第一个新颖之处：一般来说，参数文件是用来在运行时引导程序的执行。虽然即使是简单的方法也能节省编译时间，因为同一个可执行文件可以用不同的参数设置来运行，但要同时处理数百个参数，同时保持不同程序之间的兼容性，会变得很困难。这就是ParameterAcceptor类证明有用的地方。

// 该类用于定义一个公共接口，供那些希望使用一个全局ParameterHandler来处理参数的类使用。该类提供了一个静态的ParameterHandler成员，即 ParameterAcceptor::prm, ，并实现了 "命令设计模式"（例如，见E. Gamma, R. Helm, R. Johnson, J. Vlissides, 设计模式。Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. https:goo.gl/NYByc）。)

// ParameterAcceptor提供了一个全局订阅机制。每当一个从ParameterAcceptor派生出来的类的对象被构造出来时，一个指向该派生型对象的指针就会被注册，同时在参数文件中还有一个部分条目。这种注册表在调用单一函数 ParameterAcceptor::initialize("file.prm") 时被遍历，该函数反过来确保所有存储在全局注册表中的类都声明它们将使用的参数，在声明了这些参数后，它读取`file.prm`的内容来解析实际参数。

// 如果你为你想在代码中使用的每个参数调用方法 ParameterHandler::add_parameter ，你就不需要做其他事情了。如果你使用的是一个已经存在的类，它提供了`declare_parameters`和`parse_parameters`这两个函数，你仍然可以使用ParameterAcceptor，方法是将现有的类封装成ParameterAcceptorProxy类。

// 在这个例子中，我们将同时使用这两种策略，为deal.II类使用ParameterAcceptorProxy，并直接从ParameterAcceptor派生出我们自己的参数类。

#include <deal.II/base/parameter_acceptor.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 

// 另一个新的包含文件是包含 GridTools::Cache 类的文件。deal.II的结构和许多现代数值库一样，是按照有向无环图（DAG）组织的。DAG是一个具有拓扑顺序的有向图：每个节点在结构上代表一个对象，并通过一条（或多条）有向边与非根节点相连，从父节点到子节点。这种结构最重要的例子是Triangulation及其 Triangulation::cell_iterator 结构。从Triangulation（主节点），我们可以访问每个单元（三角形的子节点）。从单元本身，我们可以访问该单元的所有顶点。在这个简单的例子中，DAG结构可以表示为三种节点类型（三角结构、单元格迭代器和顶点），由从三角结构到单元格迭代器，以及从单元格迭代器到顶点的定向边连接。这有几个优点，但它本质上造成了 "不对称"，使某些操作变得很快，而它们的逆向操作却很慢：寻找一个单元的顶点的计算成本很低，可以通过简单地遍历DAG来完成，而寻找所有共享一个顶点的单元则需要进行非难事的计算，除非添加一个新的DAG数据结构来表示逆向搜索。

// 由于在有限元代码中通常不需要逆向操作，所以在GridTools中实现了这些操作，而没有使用与Triangulation相关的额外数据结构，这将使它们的速度更快。例如，这样的数据结构是一个从三角结构的顶点到所有共享这些顶点的单元的映射，这将减少回答前面问题所需的计算。

// 有些方法，例如 GridTools::find_active_cell_around_point, 大量使用了这些非标准操作。如果你需要多次调用这些方法，那么将这些数据结构存储在某个地方就变得很方便。  GridTools::Cache 正是这样做的，它让你可以访问以前计算过的对象，或者在飞行中计算它们（然后将它们存储在类中供以后使用），并确保每当三角测量被更新时，相关的数据结构也被重新计算。

#include <deal.II/grid/grid_tools_cache.h> 

#include <deal.II/fe/fe.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 

// 在这个例子中，我们将使用一个参考域来描述一个嵌入的三角形，通过一个有限元矢量场进行变形。

// 接下来的两个包含文件包含了在这些情况下可以使用的两个类的定义。MappingQEulerian允许人们通过一个*位移*场来描述一个域，基于FESystem[FE_Q(p)^spacedim]有限元空间。第二种是比较通用的，允许你使用任意的矢量有限元空间，只要它们能提供*连续*的
//对你的领域的描述。在这种情况下，这种描述是通过实际的*变形*场，而不是*位移*场来完成的。

// 使用哪一个取决于用户想如何指定参考域，和/或实际配置。我们将提供这两种选择，并在本教程程序的结果部分做一些实验。

#include <deal.II/fe/mapping_q_eulerian.h> 
#include <deal.II/fe/mapping_fe_field.h> 

#include <deal.II/dofs/dof_tools.h> 

// 被解析的函数类是另一个新条目。它允许人们创建一个Function对象，从参数文件中的一个字符串开始，它被解析成一个对象，你可以在deal.II接受Function的任何地方使用（例如，用于插值、边界条件等）。

#include <deal.II/base/parsed_function.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 

// 这是本教程程序的最后一个新条目。NonMatching命名空间包含了一些方法，这些方法在对非匹配网格或与底层网格不对齐的曲线进行计算时很有用。

// 我们将在后面的 "setup_coupling "方法中详细讨论其用途。

#include <deal.II/non_matching/coupling.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/linear_operator.h> 
#include <deal.II/lac/linear_operator_tools.h> 

#include <iostream> 
#include <fstream> 

namespace Step60 
{ 
  using namespace dealii; 
// @sect3{DistributedLagrangeProblem}  

// 在DistributedLagrangeProblem中，我们需要两个参数来描述域 $\Gamma$ （`dim`）和域 $\Omega$ （`spacedim`）的尺寸。

// 这些参数将用于初始化一个Triangulation<dim,spacedim>（用于 $\Gamma$  ）和一个Triangulation<spacedim,spacedim>（用于 $\Omega$  ）。

// 与其他教程程序相比，一个新奇之处在于大量使用了  std::unique_ptr.  这些指针的行为与经典指针一样，其优点是可以进行自动的内部管理：一旦unique_ptr超出范围，所包含的对象就会被自动销毁，即使它是在一个容器内或者有一个异常。此外，它不允许有重复的指针，这可以防止所有权问题。我们这样做，是因为我们希望能够 i) 构建问题，ii) 读取参数，iii) 根据参数文件中指定的内容初始化所有对象。

// 我们在派生于ParameterAcceptor的内部类`Parameters`中构建我们问题的参数。`DistributedLagrangeProblem`类需要一个对`Parameters`对象的常量引用，因此不可能从DistributedLagrangeProblem类本身修改参数。

// 我们可以先初始化参数，然后将参数传递给DistributedLagrangeProblem，假设所有条目都设置为所需的值，但这有两个缺点。



// - 我们不应该对用户如何初始化一个不受我们直接控制的类做出假设。如果用户未能初始化该类，我们应该注意到并抛出一个异常。



// - 当我们构造参数时，并不是所有需要从参数文件中读取参数的对象都可以使用；对于复杂的程序，有多种物理现象，或者我们在一些外部类中重复使用现有的代码，往往是这种情况。我们通过将一些 "复杂 "的对象，如ParsedFunction对象，保留在`DistributedLagrangeProblem`内而不是`Parameters`内来模拟这种情况。

// 这里我们假设在构建时，构建我们问题的类还不能使用。解析参数文件是确保我们有所有的成分来建立我们的类，我们的设计是，如果解析失败，或者没有被执行，运行就会被中止。

  template <int dim, int spacedim = dim> 
  class DistributedLagrangeProblem 
  { 
  public: 

// `Parameters`类是由ParameterAcceptor派生的。这使得我们可以在其构造函数中使用 ParameterAcceptor::add_parameter() 方法。

// 这个函数的成员都是非常量的，但是`DistributedLagrangeProblem`类需要一个对`Parameters`对象的常量引用：这确保参数不会从`DistributedLagrangeProblem`类中被修改。

    class Parameters : public ParameterAcceptor 
    { 
    public: 
      Parameters(); 

// 现在描述的参数都可以通过参数文件在外部设置：如果运行可执行文件时没有参数文件，程序将创建一个 "参数.prm "文件，并在这里定义默认值，然后中止，让用户有机会修改参数.prm文件。

// 嵌入网格的初始细化，对应于域 $\Omega$  。

      unsigned int initial_refinement = 4; 

// 嵌入网格 $\Omega$ 和嵌入网格 $\Gamma$ 之间的交互是通过 $C$ 的计算来处理的，这涉及到 $\Omega$ 的所有单元与 $\Gamma$ 的部分重叠：这些单元的更高细化可能提高我们计算的质量。出于这个原因，我们定义了`delta_refinement'：如果它大于零，那么我们将空间网格中包含嵌入网格顶点的每个单元及其邻居标记出来，执行细化，并重复这个过程`delta_refinement'的次数。

      unsigned int delta_refinement = 3; 

// 开始细化嵌入网格，对应于域  $\Gamma$  。

      unsigned int initial_embedded_refinement = 8; 

// 边界id列表，我们在其中施加同质Dirichlet边界条件。在其余的边界id上（如果有的话），我们施加同质的诺伊曼边界条件。作为一个默认问题，我们在 $\partial \Omega$ 上设置了零迪里希特边界条件。
      std::list<types::boundary_id> homogeneous_dirichlet_ids{0, 1, 2, 3}; 

// 嵌入空间的有限元素程度。  $V_h(\Omega)$  
      unsigned int embedding_space_finite_element_degree = 1; 

// 嵌入空间的有限元素度。  $Q_h(\Gamma)$  
      unsigned int embedded_space_finite_element_degree = 1; 

// 用于描述嵌入域变形的空间的有限元度

      unsigned int embedded_configuration_finite_element_degree = 1; 

// 用于积分耦合的正交公式的阶数

      unsigned int coupling_quadrature_order = 3; 

// 如果设置为 "true"，则嵌入式配置函数被解释为位移函数。

      bool use_displacement = false; 

// 在输出中使用的粗略程度

      unsigned int verbosity_level = 10; 

// 用来记录我们是否被初始化的一个标志。

      bool initialized = false; 
    }; 

    DistributedLagrangeProblem(const Parameters &parameters); 

// 分布式拉格朗日问题的入口点

    void run(); 

  private: 

// 包含实际参数的对象

    const Parameters &parameters; 

// 下面的函数与其他所有的教程程序相似，不同的是，我们现在需要为两个不同系列的对象设置东西，即与*嵌入*网格有关的对象，以及与*嵌入*有关的对象。

    void setup_grids_and_dofs(); 

    void setup_embedding_dofs(); 

    void setup_embedded_dofs(); 

// 这里唯一的非常规函数是`setup_coupling()`方法，用于生成耦合矩阵的稀疏性模式  $C$  。

    void setup_coupling(); 

    void assemble_system(); 

    void solve(); 

    void output_results(); 

// 首先我们收集所有与嵌入空间几何学有关的对象

    std::unique_ptr<Triangulation<spacedim>> space_grid; 
    std::unique_ptr<GridTools::Cache<spacedim, spacedim>> 
                                             space_grid_tools_cache; 
    std::unique_ptr<FiniteElement<spacedim>> space_fe; 
    std::unique_ptr<DoFHandler<spacedim>>    space_dh; 

// 然后是与嵌入网格有关的，与拉格朗日乘数`lambda`有关的DoFHandler

    std::unique_ptr<Triangulation<dim, spacedim>> embedded_grid; 
    std::unique_ptr<FiniteElement<dim, spacedim>> embedded_fe; 
    std::unique_ptr<DoFHandler<dim, spacedim>>    embedded_dh; 

// 最后，需要对嵌入的三角形进行*变形的所有内容

    std::unique_ptr<FiniteElement<dim, spacedim>> embedded_configuration_fe; 
    std::unique_ptr<DoFHandler<dim, spacedim>>    embedded_configuration_dh; 
    Vector<double>                                embedded_configuration; 

// ParameterAcceptorProxy类是一个 "透明 "的包装器，它同时来自ParameterAcceptor和作为其模板参数传递的类型。在构造时，参数被分成两部分：第一个参数是一个 std::string, ，转发给ParameterAcceptor类，并包含应该用于该类的部分名称，而所有其余的参数都转发给模板类型的构造器，在本例中，转发给 Functions::ParsedFunction 构造器。

// 这个类允许你结合ParameterAcceptor注册机制使用现有的类，只要这些类有`declare_parameters()`和`parse_parameters()`成员。

// 这里就是这种情况，使得利用 Functions::ParsedFunction 类变得相当容易：而不是要求用户在代码中为RHS、边界函数等创建新的Function对象。在这里，我们允许用户使用deal.II接口到muParser（http:muparser.beltoforion.de），在这里，函数的指定不是在编译时完成的，而是在运行时完成的，使用一个字符串被解析成一个实际的Function对象。

// 在这种情况下，`embedded_configuration_function`是一个向量值的Function，根据`parameters.use_displacement`的布尔值，可以被解释为*变形*或*位移*。分量的数量将在后面的结构中指定。

    ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> 
      embedded_configuration_function; 

    std::unique_ptr<Mapping<dim, spacedim>> embedded_mapping; 

// 我们做同样的事情来指定函数的值  $g$  ，这就是我们希望我们的解决方案在嵌入空间中的值。在这种情况下，该函数是一个标量函数。

    ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> 
      embedded_value_function; 

// 与我们对 Functions::ParsedFunction 类所做的类似，我们对ReductionControl类重复同样的做法，允许我们为我们以后使用的Schur补码迭代求解器指定所有可能的停止标准。

    ParameterAcceptorProxy<ReductionControl> schur_solver_control; 

// 接下来我们收集所有我们需要的SparsityPattern, SparseMatrix, 和Vector对象

    SparsityPattern stiffness_sparsity; 
    SparsityPattern coupling_sparsity; 

    SparseMatrix<double> stiffness_matrix; 
    SparseMatrix<double> coupling_matrix; 

    AffineConstraints<double> constraints; 

    Vector<double> solution; 
    Vector<double> rhs; 

    Vector<double> lambda; 
    Vector<double> embedded_rhs; 
    Vector<double> embedded_value; 

// TimerOutput类用来提供一些关于我们程序性能的统计数据。

    TimerOutput monitor; 
  }; 
// @sect3{DistributedLagrangeProblem::Parameters}  

// 在构造时，我们也初始化ParameterAcceptor类，在解析参数文件时，我们希望问题使用的部分名称。

// 参数文件可以被组织成section/subsection/etc.：这样做的好处是，当共享同一section/subsection/etc.时，定义的对象可以共享参数。ParameterAcceptor允许使用Unix约定的路径来指定部分名称。如果部分名称以斜线（"/"）开头，那么该部分将被解释为*绝对路径*，ParameterAcceptor为路径中的每个目录输入一个小节，使用它遇到的最后一个名称作为当前类的着陆小节。

// 例如，如果你使用`ParameterAcceptor("/first/second/third/My Class")`构建你的类，参数将被组织成如下样子。

// 
// @code
//  # Example parameter file
//  subsection first
//    subsection second
//      subsection third
//        subsection My Class
//         ... # all the parameters
//        end
//      end
//    end
//  end
//  @endcode

// 在内部，存储在ParameterAcceptor中的*当前路径现在被认为是"/first/second/third/"，也就是说，当你指定一个绝对路径时，ParameterAcceptor将*当前的部分改为当前路径，即改为直到*最后一个"/"的部分名称的路径。

// 你现在可以使用相对路径（例如：`ParameterAcceptor("My Other Class")`）而不是绝对路径（例如：`ParameterAcceptor("/first/second/third/My Other Class")`）来构造从ParameterAcceptor派生的另一个类，获得。
// @code
//  # Example parameter file
//  subsection first
//    subsection second
//      subsection third
//        subsection My Class
//          ... # all the parameters
//        end
//        subsection My Other Class
//          ... # all the parameters of MyOtherClass
//        end
//      end
//    end
//  end
//  @endcode

// 如果部分名称*以斜线结尾，那么后续的类将把它解释为完整的路径：例如，与上面类似，如果我们有两个类，一个用`ParameterAcceptor("/first/second/third/My Class/")`初始化，另一个用`ParameterAcceptor("My Other Class")`，那么得到的参数文件将看起来像。

// 
// @code
//  # Example parameter file
//  subsection first
//    subsection second
//      subsection third
//        subsection My Class
//          ... # all the parameters of MyClass
//          ... # notice My Class subsection does not end here
//          subsection My Other Class
//            ... # all the parameters of MyOtherClass
//          end # of subsection My Other Class
//        end # of subsection My Class
//      end
//    end
//  end
//  @endcode

// 我们将利用这一点，使我们的`Parameters`成为所有后续构建的类的*父类。由于大多数其他的类都是`DistributedLagrangeProblem`的成员，这就允许，例如，为两个不同的维度构造两个`DistributedLagrangeProblem`，而不会在这两个问题的参数上产生冲突。

  template <int dim, int spacedim> 
  DistributedLagrangeProblem<dim, spacedim>::Parameters::Parameters() 
    : ParameterAcceptor("/Distributed Lagrange<" + 
                        Utilities::int_to_string(dim) + "," + 
                        Utilities::int_to_string(spacedim) + ">/") 
  { 

//  ParameterAcceptor::add_parameter() 函数做了几件事。



// - 在构造时向ParameterAcceptor输入指定的分段



// - 调用 ParameterAcceptor::prm.add_parameter() 函数



// - 调用你可能附加到 ParameterAcceptor::declare_parameters_call_back 的任何信号。



// --离开分节

// 反过来， ParameterAcceptor::prm.add_parameter  。



// - 在参数处理程序中为给定的变量声明一个条目。



// - 取得该变量的当前值



// - 将其转换为一个字符串，作为参数文件的默认值使用



// - 在 ParameterAcceptor::prm 中附加一个*动作，当文件被解析时，或者当一个条目被设置时，它会更新传递给`add_parameter()`的变量的值，将其设置为输入文件中指定的值（当然，是在输入文件被解析并将文本表示转换为变量的类型后）。

    add_parameter("Initial embedding space refinement", initial_refinement); 

    add_parameter("Initial embedded space refinement", 
                  initial_embedded_refinement); 

    add_parameter("Local refinements steps near embedded domain", 
                  delta_refinement); 

    add_parameter("Homogeneous Dirichlet boundary ids", 
                  homogeneous_dirichlet_ids); 

    add_parameter("Use displacement in embedded interface", use_displacement); 

    add_parameter("Embedding space finite element degree", 
                  embedding_space_finite_element_degree); 

 
                  embedded_space_finite_element_degree); 

    add_parameter("Embedded configuration finite element degree", 
                  embedded_configuration_finite_element_degree); 

    add_parameter("Coupling quadrature order", coupling_quadrature_order); 

    add_parameter("Verbosity level", verbosity_level); 

// 一旦参数文件被解析，那么参数就可以使用了。将内部变量`initialized`设置为true。

    parse_parameters_call_back.connect([&]() -> void { initialized = true; }); 
  } 

// 构造函数是非常标准的，除了前面解释的`ParameterAcceptorProxy`对象之外。

  template <int dim, int spacedim> 
  DistributedLagrangeProblem<dim, spacedim>::DistributedLagrangeProblem( 
    const Parameters &parameters) 
    : parameters(parameters) 
    , embedded_configuration_function("Embedded configuration", spacedim) 
    , embedded_value_function("Embedded value") 
    , schur_solver_control("Schur solver control") 
    , monitor(std::cout, TimerOutput::summary, TimerOutput::cpu_and_wall_times) 
  { 

// 下面是一个为使用ParameterAcceptorProxy构建的ParameterAcceptor类设置默认值的方法。

// 在这种情况下，我们将嵌入式网格的默认变形设置为半径为 $R$ 、中心为 $(Cx, Cy)$ 的圆，我们将embedded_value_function的默认值设置为常数，并为SolverControl对象指定一些合理的值。

// 嵌入 $\Gamma$ 是最基本的：从 $C_{\alpha j}$ 的定义可以看出，如果 $\Gamma \not\subseteq \Omega$ ，矩阵 $C$ 的某些行将是零。这将是一个问题，因为舒尔补码法要求 $C$ 具有全列秩。

    embedded_configuration_function.declare_parameters_call_back.connect( 
      []() -> void { 
        ParameterAcceptor::prm.set("Function constants", "R=.3, Cx=.4, Cy=.4"); 

        ParameterAcceptor::prm.set("Function expression", 
                                   "R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy"); 
      }); 

    embedded_value_function.declare_parameters_call_back.connect( 
      []() -> void { ParameterAcceptor::prm.set("Function expression", "1"); }); 

    schur_solver_control.declare_parameters_call_back.connect([]() -> void { 
      ParameterAcceptor::prm.set("Max steps", "1000"); 
      ParameterAcceptor::prm.set("Reduction", "1.e-12"); 
      ParameterAcceptor::prm.set("Tolerance", "1.e-12"); 
    }); 
  } 
// @sect3{Set up}  

//函数 `DistributedLagrangeProblem::setup_grids_and_dofs()` 是用来设置有限元空间的。注意 `std::make_unique` 是如何用来创建包裹在 `std::unique_ptr` 对象里面的对象的。

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::setup_grids_and_dofs() 
  { 
    TimerOutput::Scope timer_section(monitor, "Setup grids and dofs"); 

// 初始化  $\Omega$  : 构建三角形，并将其包装成一个  `std::unique_ptr`  对象

    space_grid = std::make_unique<Triangulation<spacedim>>(); 

// 接下来，我们使用 GridGenerator::hyper_cube(). 实际创建三角形，最后一个参数设置为true：这激活了着色（即为边界的不同部分分配不同的边界指标），我们用它来分配Dirichlet和Neumann条件。

    GridGenerator::hyper_cube(*space_grid, 0, 1, true); 

// 一旦我们构建了一个三角形，我们就根据参数文件中的规格对其进行全局细化，并用它构建一个 GridTools::Cache 。

    space_grid->refine_global(parameters.initial_refinement); 
    space_grid_tools_cache = 
      std::make_unique<GridTools::Cache<spacedim, spacedim>>(*space_grid); 

// 对嵌入式网格也是这样做的。由于嵌入式网格是变形的，我们首先需要设置变形映射。我们在下面几行中这样做。

    embedded_grid = std::make_unique<Triangulation<dim, spacedim>>(); 
    GridGenerator::hyper_cube(*embedded_grid); 
    embedded_grid->refine_global(parameters.initial_embedded_refinement); 

    embedded_configuration_fe = std::make_unique<FESystem<dim, spacedim>>( 
      FE_Q<dim, spacedim>( 
        parameters.embedded_configuration_finite_element_degree), 
      spacedim); 

    embedded_configuration_dh = 
      std::make_unique<DoFHandler<dim, spacedim>>(*embedded_grid); 

    embedded_configuration_dh->distribute_dofs(*embedded_configuration_fe); 
    embedded_configuration.reinit(embedded_configuration_dh->n_dofs()); 

// 一旦我们为变形定义了一个有限维度的空间，我们就对参数文件中定义的 "嵌入_配置_函数 "进行插值。

    VectorTools::interpolate(*embedded_configuration_dh, 
                             embedded_configuration_function, 
                             embedded_configuration); 

// 现在我们可以根据用户在参数文件中指定的内容来解释它：作为位移，在这种情况下，我们构建一个映射，将我们的配置有限元空间的每个支持点的位置在相应的配置矢量上*移开指定的数量，或者作为赦免位置。

// 在第一种情况下，MappingQEulerian类提供其服务，而在第二种情况下，我们将使用MappingFEField类。它们实际上是非常相似的。MappingQEulerian只适用于FE_Q有限元空间系统，其中位移矢量存储在FESystem的第一个`spacedim`分量中，并且在构造时作为参数给出的度数必须与第一个`spacedim`分量的度数一致。

// MappingFEField类稍显一般，因为它允许你在构造近似值时选择任意的FiniteElement类型。当然，根据你选择的FiniteElement的类型，一些选择可能（也可能没有）意义。MappingFEField实现了纯粹的等参量概念，例如，可以通过与FE_Bernstein有限元类结合，在deal.II中实现等参量分析代码。在这个例子中，我们将考虑到一个配置将是一个 "位移"，而另一个将是一个绝对的 "变形 "场，从而将这两者互换使用。

    if (parameters.use_displacement == true) 
      embedded_mapping = 
        std::make_unique<MappingQEulerian<dim, Vector<double>, spacedim>>( 
          parameters.embedded_configuration_finite_element_degree, 
          *embedded_configuration_dh, 
          embedded_configuration); 
    else 
      embedded_mapping = 
        std::make_unique<MappingFEField<dim, spacedim, Vector<double>>>( 
          *embedded_configuration_dh, embedded_configuration); 

    setup_embedded_dofs(); 

// 在本教程中，我们不仅对 $\Omega$ 进行全局细化，还允许根据 $\Gamma$ 的位置进行局部细化，根据`parameters.delta_refinement`的值，我们用来决定对 $\Omega$ 进行多少轮局部细化，对应于 $\Gamma$  的位置。

// 有了这个映射，现在就可以通过调用方法 DoFTools::map_dofs_to_support_points. 来查询与`embedded_dh`相关的所有支持点的位置了。

// 这个方法有两个变种。一种是不接受Mapping，另一种是接受Mapping。如果你使用第二种类型，就像我们在这种情况下所做的那样，支持点是通过指定的映射来计算的，它可以对它们进行相应操作。

// 这正是`embedded_mapping`的作用。

    std::vector<Point<spacedim>> support_points(embedded_dh->n_dofs()); 
    if (parameters.delta_refinement != 0) 
      DoFTools::map_dofs_to_support_points(*embedded_mapping, 
                                           *embedded_dh, 
                                           support_points); 

// 一旦我们有了嵌入有限元空间的支持点，我们就想确定嵌入空间的哪些单元包含哪些支持点，以便在有必要的地方，也就是嵌入网格的地方，获得完善嵌入网格的机会。这可以手动完成，在每个支持点上循环，然后为嵌入空间的每个单元调用方法 Mapping::transform_real_to_unit_cell ，直到我们找到一个返回单位参考单元中的点，或者可以用更智能的方式完成。

//  GridTools::find_active_cell_around_point 是一个可能的选择，它以更便宜的方式执行上述任务，首先确定嵌入三角的最接近目标点的顶点，然后只对那些共享找到的顶点的单元格调用 Mapping::transform_real_to_unit_cell 。

// 事实上，在GridTools命名空间中，有一些算法利用 GridTools::Cache 对象，可能还有KDTree对象来尽可能地加快这些操作。

// 利用最大速度的最简单方法是调用一个专门的方法， GridTools::compute_point_locations, ，该方法将在第一个点的搜索过程中存储大量有用的信息和数据结构，然后在随后的点中重复使用所有这些信息。

//  GridTools::compute_point_locations 返回一个元组，其中第一个元素是一个包含输入点的单元格向量，在这里是support_points。对于细化来说，这是我们唯一需要的信息，而这正是现在所发生的。

// 然而，当我们需要组装一个耦合矩阵时，我们还需要每个点的参考位置来评估嵌入空间的基础函数。由 GridTools::compute_point_locations 返回的元组的其他元素允许你重建，对于每个点，什么单元包含它，以及什么是给定点的参考单元的位置。由于这些信息最好被分组到单元格中，那么这就是算法返回的内容：一个元组，包含所有单元格中至少有一个点的向量，以及所有参考点的列表和它们在原始向量中的相应索引。

// 在下面的循环中，我们将忽略所有返回的对象，除了第一个，确定所有单元格至少包含一个嵌入空间的支持点。这允许一个简单的自适应细化策略：细化这些单元和它们的邻居。

// 注意，我们需要做一些理智的检查，在这个意义上，我们希望有一个嵌入网格，它在嵌入网格周围被很好地细化，但其中两个连续的支持点要么位于同一个单元，要么位于邻近的嵌入单元。

// 这只有在我们确保嵌入网格的最小单元尺寸仍然大于嵌入网格的最大单元尺寸时才有可能。由于用户可以修改细化水平，以及他们希望在嵌入网格周围进行的局部细化的数量，我们要确保所得到的网格满足我们的要求，如果不是这样，我们就用一个例外来放弃。

    for (unsigned int i = 0; i < parameters.delta_refinement; ++i) 
      { 
        const auto point_locations = 
          GridTools::compute_point_locations(*space_grid_tools_cache, 
                                             support_points); 
        const auto &cells = std::get<0>(point_locations); 
        for (auto &cell : cells) 
          { 
            cell->set_refine_flag(); 
            for (const auto face_no : cell->face_indices()) 
              if (!cell->at_boundary(face_no)) 
                cell->neighbor(face_no)->set_refine_flag(); 
          } 
        space_grid->execute_coarsening_and_refinement(); 
      } 

// 为了构造一个良好的耦合插值算子 $C$ ，对嵌入域和被嵌入域之间的网格的相对尺寸有一些限制。耦合算子 $C$ 和空间 $V$ 和 $Q$ 必须满足一个inf-sup条件，以使问题有一个解决方案。事实证明，只要空间 $V$ 和 $Q$ 之间相互兼容（例如，只要它们被选为引言中所述的空间），非匹配 $L^2$ 投影就满足这种inf-sup条件。

// 然而，*离散*的inf-sup条件也必须成立。这里没有出现复杂的情况，但事实证明，当非匹配网格的局部直径相距太远时，离散的inf-sup常数会恶化。特别是，事实证明，如果你选择一个相对于嵌入网格*细的嵌入网格，inf-sup常数的恶化程度要比你让嵌入网格更细的情况下大得多。

// 为了避免问题，在本教程中，如果用户选择的参数使嵌入网格的最大直径大于嵌入网格的最小直径，我们将抛出一个异常。

// 这个选择保证了嵌入网格的几乎每一个单元都不超过嵌入网格的两个单元，只有一些罕见的例外，这些例外在结果的inf-sup方面可以忽略不计。

    const double embedded_space_maximal_diameter = 
      GridTools::maximal_cell_diameter(*embedded_grid, *embedded_mapping); 
    double embedding_space_minimal_diameter = 
      GridTools::minimal_cell_diameter(*space_grid); 

    deallog << "Embedding minimal diameter: " 
            << embedding_space_minimal_diameter 
            << ", embedded maximal diameter: " 
            << embedded_space_maximal_diameter << ", ratio: " 
            << embedded_space_maximal_diameter / 
                 embedding_space_minimal_diameter 
            << std::endl; 

    AssertThrow(embedded_space_maximal_diameter < 
                  embedding_space_minimal_diameter, 
                ExcMessage( 
                  "The embedding grid is too refined (or the embedded grid " 
                  "is too coarse). Adjust the parameters so that the minimal " 
                  "grid size of the embedding grid is larger " 
                  "than the maximal grid size of the embedded grid.")); 
// $\Omega$ 已经被完善，我们现在可以设置它的DoF了

    setup_embedding_dofs(); 
  } 

// 我们现在设置 $\Omega$ 和 $\Gamma$ 的DoF：因为它们基本上是独立的（除了 $\Omega$ 的网格在 $\Gamma$ 周围更加精细），这个过程是标准的。

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::setup_embedding_dofs() 
  { 
    space_dh = std::make_unique<DoFHandler<spacedim>>(*space_grid); 
    space_fe = std::make_unique<FE_Q<spacedim>>( 
      parameters.embedding_space_finite_element_degree); 
    space_dh->distribute_dofs(*space_fe); 

    DoFTools::make_hanging_node_constraints(*space_dh, constraints); 
    for (auto id : parameters.homogeneous_dirichlet_ids) 
      { 
        VectorTools::interpolate_boundary_values( 
          *space_dh, id, Functions::ZeroFunction<spacedim>(), constraints); 
      } 
    constraints.close(); 

// 根据定义，刚度矩阵只涉及 $\Omega$ 的DoF。

    DynamicSparsityPattern dsp(space_dh->n_dofs(), space_dh->n_dofs()); 
    DoFTools::make_sparsity_pattern(*space_dh, dsp, constraints); 
    stiffness_sparsity.copy_from(dsp); 
    stiffness_matrix.reinit(stiffness_sparsity); 
    solution.reinit(space_dh->n_dofs()); 
    rhs.reinit(space_dh->n_dofs()); 

    deallog << "Embedding dofs: " << space_dh->n_dofs() << std::endl; 
  } 

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::setup_embedded_dofs() 
  { 
    embedded_dh = std::make_unique<DoFHandler<dim, spacedim>>(*embedded_grid); 
    embedded_fe = std::make_unique<FE_Q<dim, spacedim>>( 
      parameters.embedded_space_finite_element_degree); 
    embedded_dh->distribute_dofs(*embedded_fe); 

// 根据定义，我们要解决的系统的rhs只涉及一个零向量和 $G$ ，它只用 $\Gamma$ 的DoF计算。

    lambda.reinit(embedded_dh->n_dofs()); 
    embedded_rhs.reinit(embedded_dh->n_dofs()); 
    embedded_value.reinit(embedded_dh->n_dofs()); 

    deallog << "Embedded dofs: " << embedded_dh->n_dofs() << std::endl; 
  } 

// 创建耦合稀疏模式是一个复杂的操作，但可以使用 NonMatching::create_coupling_sparsity_pattern, 轻松完成，它需要两个DoFHandler对象、耦合的正交点、一个DynamicSparsityPattern（然后需要像往常一样复制到稀疏模式中）、嵌入和嵌入三角形的组件掩码（我们留空）以及嵌入和嵌入三角形的映射关系。

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::setup_coupling() 
  { 
    TimerOutput::Scope timer_section(monitor, "Setup coupling"); 

    QGauss<dim> quad(parameters.coupling_quadrature_order); 

    DynamicSparsityPattern dsp(space_dh->n_dofs(), embedded_dh->n_dofs()); 

    NonMatching::create_coupling_sparsity_pattern(*space_grid_tools_cache, 
                                                  *space_dh, 
                                                  *embedded_dh, 
                                                  quad, 
                                                  dsp, 
                                                  AffineConstraints<double>(), 
                                                  ComponentMask(), 
                                                  ComponentMask(), 
                                                  *embedded_mapping); 
    coupling_sparsity.copy_from(dsp); 
    coupling_matrix.reinit(coupling_sparsity); 
  } 
// @sect3{Assembly}  

// 以下是创建矩阵的函数：如前所述，计算刚度矩阵和rhs是一个标准程序。

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::assemble_system() 
  { 
    { 
      TimerOutput::Scope timer_section(monitor, "Assemble system"); 

//嵌入刚度矩阵  $K$  ，以及右手边  $G$  。

      MatrixTools::create_laplace_matrix( 
        *space_dh, 
        QGauss<spacedim>(2 * space_fe->degree + 1), 
        stiffness_matrix, 
        static_cast<const Function<spacedim> *>(nullptr), 
        constraints); 

      VectorTools::create_right_hand_side(*embedded_mapping, 
                                          *embedded_dh, 
                                          QGauss<dim>(2 * embedded_fe->degree + 
                                                      1), 
                                          embedded_value_function, 
                                          embedded_rhs); 
    } 
    { 
      TimerOutput::Scope timer_section(monitor, "Assemble coupling system"); 

// 为了计算耦合矩阵，我们使用 NonMatching::create_coupling_mass_matrix 工具，其工作原理与 NonMatching::create_coupling_sparsity_pattern. 类似。
      QGauss<dim> quad(parameters.coupling_quadrature_order); 
      NonMatching::create_coupling_mass_matrix(*space_grid_tools_cache, 
                                               *space_dh, 
                                               *embedded_dh, 
                                               quad, 
                                               coupling_matrix, 
                                               AffineConstraints<double>(), 
                                               ComponentMask(), 
                                               ComponentMask(), 
                                               *embedded_mapping); 

      VectorTools::interpolate(*embedded_mapping, 
                               *embedded_dh, 
                               embedded_value_function, 
                               embedded_value); 
    } 
  } 
// @sect3{Solve}  

// 所有的部分都已经组装好了：我们用舒尔补数法解决这个系统

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::solve() 
  { 
    TimerOutput::Scope timer_section(monitor, "Solve system"); 

// 从创建反刚度矩阵开始

    SparseDirectUMFPACK K_inv_umfpack; 
    K_inv_umfpack.initialize(stiffness_matrix); 

//初始化运算符，如介绍中所述

    auto K  = linear_operator(stiffness_matrix); 
    auto Ct = linear_operator(coupling_matrix); 
    auto C  = transpose_operator(Ct); 

    auto K_inv = linear_operator(K, K_inv_umfpack); 

// 使用舒尔补数法

    auto                     S = C * K_inv * Ct; 
    SolverCG<Vector<double>> solver_cg(schur_solver_control); 
    auto S_inv = inverse_operator(S, solver_cg, PreconditionIdentity()); 

    lambda = S_inv * embedded_rhs; 

    solution = K_inv * Ct * lambda; 

    constraints.distribute(solution); 
  } 

// 下面的函数只是在两个独立的文件上生成标准结果输出，每个网格一个。

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::output_results() 
  { 
    TimerOutput::Scope timer_section(monitor, "Output results"); 

    DataOut<spacedim> embedding_out; 

    std::ofstream embedding_out_file("embedding.vtu"); 

    embedding_out.attach_dof_handler(*space_dh); 
    embedding_out.add_data_vector(solution, "solution"); 
    embedding_out.build_patches( 
      parameters.embedding_space_finite_element_degree); 
    embedding_out.write_vtu(embedding_out_file); 

// 这两个输出例程之间的唯一区别是，在第二种情况下，我们想在当前配置上输出数据，而不是在参考配置上。这可以通过将实际的embedded_mapping传递给 DataOut::build_patches 函数来实现。该映射将负责在实际变形的配置上输出结果。

    DataOut<dim, spacedim> embedded_out; 

    std::ofstream embedded_out_file("embedded.vtu"); 

    embedded_out.attach_dof_handler(*embedded_dh); 
    embedded_out.add_data_vector(lambda, "lambda"); 
    embedded_out.add_data_vector(embedded_value, "g"); 
    embedded_out.build_patches(*embedded_mapping, 
                               parameters.embedded_space_finite_element_degree); 
    embedded_out.write_vtu(embedded_out_file); 
  } 

// 与所有其他教程程序类似，`run()`函数只是按照正确的顺序调用所有其他方法。没有什么特别需要注意的，只是在我们实际尝试运行我们的程序之前，我们检查是否完成了解析。

  template <int dim, int spacedim> 
  void DistributedLagrangeProblem<dim, spacedim>::run() 
  { 
    AssertThrow(parameters.initialized, ExcNotInitialized()); 
    deallog.depth_console(parameters.verbosity_level); 

    setup_grids_and_dofs(); 
    setup_coupling(); 
    assemble_system(); 
    solve(); 
    output_results(); 
  } 
} // namespace Step60 

int main(int argc, char **argv) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step60; 

      const unsigned int dim = 1, spacedim = 2; 

// 与其他教程程序中的情况不同，这里我们使用ParameterAcceptor风格的初始化，即首先构建所有对象，然后对静态方法 ParameterAcceptor::initialize 发出一次调用，以填充从ParameterAcceptor派生的类的所有参数。

// 我们检查用户是否在程序启动时指定了一个要使用的参数文件名。如果是，就尝试读取该参数文件，否则就尝试读取文件 "parameters.prm"。

// 如果指定的参数文件（隐式或显式）不存在， ParameterAcceptor::initialize 将为你创建一个，并退出程序。

      DistributedLagrangeProblem<dim, spacedim>::Parameters parameters; 
      DistributedLagrangeProblem<dim, spacedim>             problem(parameters); 

      std::string parameter_file; 
      if (argc > 1) 
        parameter_file = argv[1]; 
      else 
        parameter_file = "parameters.prm"; 

      ParameterAcceptor::initialize(parameter_file, "used_parameters.prm"); 
      problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 


CCTest_file/step-61.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2018 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 *      Author: Zhuoran Wang, Colorado State University, 2018 
 */ 


// @sect3{Include files}  这个程序是基于 step-7  、 step-20  和  step-51  ，所以下面的头文件大部分是熟悉的。我们需要以下文件，其中只有导入FE_DGRaviartThomas类的文件（即`deal.II/fe/fe_dg_vector.h`）是真正的新文件；FE_DGRaviartThomas实现了介绍中讨论的 "破碎 "Raviart-Thomas空间。

#include <deal.II/base/quadrature.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/tensor_function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/point.h> 
#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_raviart_thomas.h> 
#include <deal.II/fe/fe_dg_vector.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_face.h> 
#include <deal.II/fe/component_mask.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/data_out_faces.h> 

#include <fstream> 
#include <iostream> 

// 我们的第一步，像往常一样，是把所有与本教程程序有关的东西放到自己的命名空间中。

namespace Step61 
{ 
  using namespace dealii; 
// @sect3{The WGDarcyEquation class template}  

// 这是本程序的主类。我们将使用弱加勒金（WG）方法求解内部和面上的数值压力，并计算出压力的 $L_2$ 误差。在后处理步骤中，我们还将计算速度和通量的 $L_2$  误差。

// 该类的结构与以前的教程程序没有根本的不同，所以除了一个例外，没有必要对细节进行评论。该类有一个成员变量`fe_dgrt`，对应于介绍中提到的 "破碎 "的Raviart-Thomas空间。还有一个与之匹配的`dof_handler_dgrt`，表示从这个元素创建的有限元场的全局枚举，还有一个向量`darcy_velocity`，用于保持这个场的节点值。在求解压力后，我们将使用这三个变量来计算一个后处理的速度场，然后我们可以对其进行误差评估，并将其输出用于可视化。

  template <int dim> 
  class WGDarcyEquation 
  { 
  public: 
    WGDarcyEquation(const unsigned int degree); 
    void run(); 

  private: 
    void make_grid(); 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void compute_postprocessed_velocity(); 
    void compute_velocity_errors(); 
    void compute_pressure_error(); 
    void output_results() const; 

    Triangulation<dim> triangulation; 

    FESystem<dim>   fe; 
    DoFHandler<dim> dof_handler; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    FE_DGRaviartThomas<dim> fe_dgrt; 
    DoFHandler<dim>         dof_handler_dgrt; 
    Vector<double>          darcy_velocity; 
  }; 

//  @sect3{Right hand side, boundary values, and exact solution}  

// 接下来，我们定义系数矩阵 $\mathbf{K}$ （这里是身份矩阵），迪里希特边界条件，右手边 $f = 2\pi^2 \sin(\pi x) \sin(\pi y)$  ，以及与这些选择相对应的 $K$ 和 $f$ 的精确解，即 $p = \sin(\pi x) \sin(\pi y)$  。

  template <int dim> 
  class Coefficient : public TensorFunction<2, dim> 
  { 
  public: 
    Coefficient() 
      : TensorFunction<2, dim>() 
    {} 

    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<Tensor<2, dim>> &values) const override; 
  }; 

  template <int dim> 
  void Coefficient<dim>::value_list(const std::vector<Point<dim>> &points, 
                                    std::vector<Tensor<2, dim>> &  values) const 
  { 
    Assert(points.size() == values.size(), 
           ExcDimensionMismatch(points.size(), values.size())); 
    for (unsigned int p = 0; p < points.size(); ++p) 
      values[p] = unit_symmetric_tensor<dim>(); 
  } 

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    BoundaryValues() 
      : Function<dim>(2) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & /*p*/, 
                                    const unsigned int /*component*/) const 
  { 
    return 0; 
  } 

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> &p, 
                                   const unsigned int /*component*/) const 
  { 
    return (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) * 
            std::sin(numbers::PI * p[1])); 
  } 

// 实现精确压力解决方案的类有一个奇怪的地方，我们把它作为一个有两个分量的向量值来实现。(我们在构造函数中说它有两个分量，在这里我们调用基函数类的构造函数)。在`value()`函数中，我们不测试`component`参数的值，这意味着我们为向量值函数的两个分量返回相同的值。我们这样做是因为我们将本程序中使用的有限元描述为一个包含内部和界面压力的矢量值系统，当我们计算误差时，我们希望使用相同的压力解来测试这两个分量。

  template <int dim> 
  class ExactPressure : public Function<dim> 
  { 
  public: 
    ExactPressure() 
      : Function<dim>(2) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component) const override; 
  }; 

  template <int dim> 
  double ExactPressure<dim>::value(const Point<dim> &p, 
                                   const unsigned int /*component*/) const 
  { 
    return std::sin(numbers::PI * p[0]) * std::sin(numbers::PI * p[1]); 
  } 

  template <int dim> 
  class ExactVelocity : public TensorFunction<1, dim> 
  { 
  public: 
    ExactVelocity() 
      : TensorFunction<1, dim>() 
    {} 

    virtual Tensor<1, dim> value(const Point<dim> &p) const override; 
  }; 

  template <int dim> 
  Tensor<1, dim> ExactVelocity<dim>::value(const Point<dim> &p) const 
  { 
    Tensor<1, dim> return_value; 
    return_value[0] = -numbers::PI * std::cos(numbers::PI * p[0]) * 
                      std::sin(numbers::PI * p[1]); 
    return_value[1] = -numbers::PI * std::sin(numbers::PI * p[0]) * 
                      std::cos(numbers::PI * p[1]); 
    return return_value; 
  } 

//  @sect3{WGDarcyEquation class implementation}  
// @sect4{WGDarcyEquation::WGDarcyEquation}  

// 在这个构造函数中，我们创建了一个矢量值函数的有限元空间，这里将包括用于内部和界面压力的函数， $p^\circ$  和  $p^\partial$  。

  template <int dim> 
  WGDarcyEquation<dim>::WGDarcyEquation(const unsigned int degree) 
    : fe(FE_DGQ<dim>(degree), 1, FE_FaceQ<dim>(degree), 1) 
    , dof_handler(triangulation) 
    , fe_dgrt(degree) 
    , dof_handler_dgrt(triangulation) 
  {} 

//  @sect4{WGDarcyEquation::make_grid}  

// 我们在单位平方域上生成一个网格并对其进行细化。

  template <int dim> 
  void WGDarcyEquation<dim>::make_grid() 
  { 
    GridGenerator::hyper_cube(triangulation, 0, 1); 
    triangulation.refine_global(5); 

    std::cout << "   Number of active cells: " << triangulation.n_active_cells() 
              << std::endl 
              << "   Total number of cells: " << triangulation.n_cells() 
              << std::endl; 
  } 

//  @sect4{WGDarcyEquation::setup_system}  

// 在我们创建了上面的网格后，我们分配自由度并调整矩阵和向量的大小。这个函数中唯一值得关注的部分是我们如何插值压力的边界值。由于压力由内部和界面分量组成，我们需要确保我们只插值到矢量值解空间中与界面压力相对应的分量上（因为这些分量是唯一定义在域的边界上的）。我们通过一个只针对界面压力的分量屏蔽对象来做到这一点。

  template <int dim> 
  void WGDarcyEquation<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    dof_handler_dgrt.distribute_dofs(fe_dgrt); 

    std::cout << "   Number of pressure degrees of freedom: " 
              << dof_handler.n_dofs() << std::endl; 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    { 
      constraints.clear(); 
      const FEValuesExtractors::Scalar interface_pressure(1); 
      const ComponentMask              interface_pressure_mask = 
        fe.component_mask(interface_pressure); 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               BoundaryValues<dim>(), 
                                               constraints, 
                                               interface_pressure_mask); 
      constraints.close(); 
    } 

// 在双线性形式中，在两个相邻单元之间的面上没有积分项，所以我们可以直接使用 <code>DoFTools::make_sparsity_pattern</code> 来计算稀疏矩阵。

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
  } 

//  @sect4{WGDarcyEquation::assemble_system}  

// 这个函数比较有趣。正如介绍中所详述的，线性系统的装配要求我们评估形状函数的弱梯度，这是Raviart-Thomas空间的一个元素。因此，我们需要定义一个Raviart-Thomas有限元对象，并有FEValues对象在正交点评估它。然后我们需要计算每个单元 $K$ 上的矩阵 $C^K$ ，为此我们需要介绍中提到的矩阵 $M^K$ 和 $G^K$ 。

// 有一点可能不是很明显，在之前所有的教程程序中，我们总是用DoFHandler的单元格迭代器来调用 FEValues::reinit() 。这样就可以调用诸如 FEValuesBase::get_function_values() 这样的函数，在单元格的正交点上提取有限元函数的值（用DoF值的矢量表示）。为了使这种操作发挥作用，人们需要知道哪些向量元素对应于给定单元上的自由度--也就是说，正是DoFHandler类所提供的那种信息和操作。

// 我们可以为 "破碎的 "Raviart-Thomas空间创建一个DoFHandler对象（使用FE_DGRT类），但是我们在这里真的不想这样做。至少在当前函数中，我们不需要任何与这个破碎空间相关的全局定义的自由度，而只需要引用当前单元上的这种空间的形状函数。因此，我们利用这样一个事实，即人们也可以用单元格迭代器来调用 FEValues::reinit() 的Triangulation对象（而不是DoFHandler对象）。在这种情况下，FEValues当然只能为我们提供只引用单元格的信息，而不是这些单元格上列举的自由度。所以我们不能使用 FEValuesBase::get_function_values(), ，但我们可以使用 FEValues::shape_value() 来获取当前单元上正交点的形状函数值。下面我们要利用的就是这种功能。下面给我们提供Raviart-Thomas函数信息的变量是`fe_values_rt`（和相应的`fe_face_values_rt`）对象。

// 鉴于上述介绍，下面的声明应该是非常明显的。

  template <int dim> 
  void WGDarcyEquation<dim>::assemble_system() 
  { 
    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1); 
    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1); 

    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values); 
    FEFaceValues<dim> fe_face_values(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_normal_vectors | 
                                       update_quadrature_points | 
                                       update_JxW_values); 

    FEValues<dim>     fe_values_dgrt(fe_dgrt, 
                                 quadrature_formula, 
                                 update_values | update_gradients | 
                                   update_quadrature_points | 
                                   update_JxW_values); 
    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt, 
                                          face_quadrature_formula, 
                                          update_values | 
                                            update_normal_vectors | 
                                            update_quadrature_points | 
                                            update_JxW_values); 

    const unsigned int dofs_per_cell      = fe.n_dofs_per_cell(); 
    const unsigned int dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell(); 

    const unsigned int n_q_points      = fe_values.get_quadrature().size(); 
    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size(); 

    const unsigned int n_face_q_points = fe_face_values.get_quadrature().size(); 

    RightHandSide<dim>  right_hand_side; 
    std::vector<double> right_hand_side_values(n_q_points); 

    const Coefficient<dim>      coefficient; 
    std::vector<Tensor<2, dim>> coefficient_values(n_q_points); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 接下来，让我们声明介绍中讨论的各种单元格矩阵。

    FullMatrix<double> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt); 
    FullMatrix<double> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell); 
    FullMatrix<double> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt); 
    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 
    Vector<double>     cell_solution(dofs_per_cell); 

// 我们需要  <code>FEValuesExtractors</code>  来访问形状函数的  @p interior  和  @p face  部分。

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure_interior(0); 
    const FEValuesExtractors::Scalar pressure_face(1); 

// 这最终让我们在所有单元格上进行循环。在每个单元中，我们将首先计算用于构建局部矩阵的各种单元矩阵--因为它们取决于相关的单元，所以它们需要在每个单元中重新计算。我们还需要Raviart-Thomas空间的形状函数，为此我们需要首先创建一个通往三角化单元的迭代器，我们可以通过从指向DoFHandler的单元中的赋值来获得。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        fe_values.reinit(cell); 

        const typename Triangulation<dim>::active_cell_iterator cell_dgrt = 
          cell; 
        fe_values_dgrt.reinit(cell_dgrt); 

        right_hand_side.value_list(fe_values.get_quadrature_points(), 
                                   right_hand_side_values); 
        coefficient.value_list(fe_values.get_quadrature_points(), 
                               coefficient_values); 

// 我们要计算的第一个单元矩阵是拉维-托马斯空间的质量矩阵。 因此，我们需要循环计算速度FEValues对象的所有正交点。

        cell_matrix_M = 0; 
        for (unsigned int q = 0; q < n_q_points_dgrt; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i) 
            { 
              const Tensor<1, dim> v_i = fe_values_dgrt[velocities].value(i, q); 
              for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k) 
                { 
                  const Tensor<1, dim> v_k = 
                    fe_values_dgrt[velocities].value(k, q); 
                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q)); 
                } 
            } 

// 接下来我们通过使用 FullMatrix::gauss_jordan(). 对这个矩阵进行求逆 它将被用来计算后面的系数矩阵 $C^K$ 。值得一提的是，后面的 "cell_matrix_M "实际上包含了*的逆*。
//在这个调用之后的 $M^K$ 的*逆。

        cell_matrix_M.gauss_jordan(); 

// 从介绍中，我们知道定义 $C^K$ 的方程的右边 $G^K$ 是面积分和单元积分的区别。在这里，我们对内部的贡献的负值进行了近似。这个矩阵的每个分量都是多项式空间的一个基函数与拉维-托马斯空间的一个基函数的发散之间的乘积的积分。这些基函数是在内部定义的。

        cell_matrix_G = 0; 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i) 
            { 
              const double div_v_i = 
                fe_values_dgrt[velocities].divergence(i, q); 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const double phi_j_interior = 
                    fe_values[pressure_interior].value(j, q); 

                  cell_matrix_G(i, j) -= 
                    (div_v_i * phi_j_interior * fe_values.JxW(q)); 
                } 
            } 

// 接下来，我们用正交法对面的积分进行近似。每个分量都是多项式空间的基函数与Raviart-Thomas空间的基函数与法向量的点积的积分。所以我们在元素的所有面上循环，得到法向量。

        for (const auto &face : cell->face_iterators()) 
          { 
            fe_face_values.reinit(cell, face); 
            fe_face_values_dgrt.reinit(cell_dgrt, face); 

            for (unsigned int q = 0; q < n_face_q_points; ++q) 
              { 
                const Tensor<1, dim> &normal = fe_face_values.normal_vector(q); 

                for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i) 
                  { 
                    const Tensor<1, dim> v_i = 
                      fe_face_values_dgrt[velocities].value(i, q); 
                    for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                      { 
                        const double phi_j_face = 
                          fe_face_values[pressure_face].value(j, q); 

                        cell_matrix_G(i, j) += 
                          ((v_i * normal) * phi_j_face * fe_face_values.JxW(q)); 
                      } 
                  } 
              } 
          } 
// @p cell_matrix_C 是 $G^K$ 的转置与质量矩阵的逆之间的矩阵乘积（该逆存储在 @p cell_matrix_M): 中）。
        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M); 

// 最后我们可以计算出本地矩阵  $A^K$  。 元素  $A^K_{ij}$  由  $\int_{E} \sum_{k,l} C_{ik} C_{jl} (\mathbf{K} \mathbf{v}_k) \cdot \mathbf{v}_l \mathrm{d}x$  得到。我们在上一步已经计算了系数 $C$ ，因此在适当地重新排列循环后得到以下结果。

        local_matrix = 0; 
        for (unsigned int q = 0; q < n_q_points_dgrt; ++q) 
          { 
            for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k) 
              { 
                const Tensor<1, dim> v_k = 
                  fe_values_dgrt[velocities].value(k, q); 
                for (unsigned int l = 0; l < dofs_per_cell_dgrt; ++l) 
                  { 
                    const Tensor<1, dim> v_l = 
                      fe_values_dgrt[velocities].value(l, q); 

                    for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                      for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                        local_matrix(i, j) += 
                          (coefficient_values[q] * cell_matrix_C[i][k] * v_k) * 
                          cell_matrix_C[j][l] * v_l * fe_values_dgrt.JxW(q); 
                  } 
              } 
          } 

// 接下来，我们计算右手边， $\int_{K} f q \mathrm{d}x$  。

        cell_rhs = 0; 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              cell_rhs(i) += (fe_values[pressure_interior].value(i, q) * 
                              right_hand_side_values[q] * fe_values.JxW(q)); 
            } 

// 最后一步是将本地矩阵的组件分配到系统矩阵中，并将单元格右侧的组件转移到系统右侧。

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global( 
          local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); 
      } 
  } 

//  @sect4{WGDarcyEquation<dim>::solve}  

// 这一步相当琐碎，与之前的许多教程程序相同。

  template <int dim> 
  void WGDarcyEquation<dim>::solve() 
  { 
    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm()); 
    SolverCG<Vector<double>> solver(solver_control); 
    solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity()); 
    constraints.distribute(solution); 
  } 
// @sect4{WGDarcyEquation<dim>::compute_postprocessed_velocity}  

// 在这个函数中，根据之前计算的压力解计算出速度场。速度被定义为 $\mathbf{u}_h = \mathbf{Q}_h \left(-\mathbf{K}\nabla_{w,d}p_h \right)$ ，这需要我们计算许多与系统矩阵组装相同的项。还有一些矩阵 $E^K,D^K$ 我们也需要组装（见介绍），但它们实际上只是遵循相同的模式。

// 在这里计算与我们在`assemble_system()`函数中已经完成的相同的矩阵，当然是浪费CPU时间的。同样地，我们把那里的一些代码复制到这个函数中，这通常也是一个糟糕的主意。一个更好的实现可能会提供一个函数来封装这些重复的代码。我们也可以考虑使用计算效率和内存效率之间的经典权衡，在装配过程中每个单元只计算一次 $C^K$ 矩阵，把它们存储在边上的某个地方，然后在这里重新使用它们。例如， step-51 就是这样做的，`assemble_system()`函数需要一个参数来决定是否重新计算本地矩阵，类似的方法--也许是将本地矩阵存储在其他地方--可以适用于当前的程序）。

  template <int dim> 
  void WGDarcyEquation<dim>::compute_postprocessed_velocity() 
  { 
    darcy_velocity.reinit(dof_handler_dgrt.n_dofs()); 

    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1); 
    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_quadrature_points | 
                              update_JxW_values); 

    FEFaceValues<dim> fe_face_values(fe, 
                                     face_quadrature_formula, 
                                     update_values | update_normal_vectors | 
                                       update_quadrature_points | 
                                       update_JxW_values); 

    FEValues<dim> fe_values_dgrt(fe_dgrt, 
                                 quadrature_formula, 
                                 update_values | update_gradients | 
                                   update_quadrature_points | 
                                   update_JxW_values); 

    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt, 
                                          face_quadrature_formula, 
                                          update_values | 
                                            update_normal_vectors | 
                                            update_quadrature_points | 
                                            update_JxW_values); 

    const unsigned int dofs_per_cell      = fe.n_dofs_per_cell(); 
    const unsigned int dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell(); 

    const unsigned int n_q_points      = fe_values.get_quadrature().size(); 
    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size(); 

    const unsigned int n_face_q_points = fe_face_values.get_quadrature().size(); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    std::vector<types::global_dof_index> local_dof_indices_dgrt( 
      dofs_per_cell_dgrt); 

    FullMatrix<double> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt); 
    FullMatrix<double> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell); 
    FullMatrix<double> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt); 
    FullMatrix<double> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt); 
    FullMatrix<double> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt); 

    Vector<double> cell_solution(dofs_per_cell); 
    Vector<double> cell_velocity(dofs_per_cell_dgrt); 

    const Coefficient<dim>      coefficient; 
    std::vector<Tensor<2, dim>> coefficient_values(n_q_points_dgrt); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure_interior(0); 
    const FEValuesExtractors::Scalar pressure_face(1); 

// 在介绍中，我们解释了如何计算单元上的数值速度。我们需要每个单元上的压力解值、格拉姆矩阵的系数和 $L_2$ 投影的系数。我们已经计算了全局解，所以我们将从全局解中提取单元解。格拉姆矩阵的系数在我们计算压力的系统矩阵时已经计算过了。我们在这里也要这样做。对于投影的系数，我们做矩阵乘法，即用格拉姆矩阵的倒数乘以 $(\mathbf{K} \mathbf{w}, \mathbf{w})$ 的矩阵作为组成部分。然后，我们将所有这些系数相乘，称之为β。数值速度是贝塔和拉维尔特-托马斯空间的基础函数的乘积。

    typename DoFHandler<dim>::active_cell_iterator 
      cell = dof_handler.begin_active(), 
      endc = dof_handler.end(), cell_dgrt = dof_handler_dgrt.begin_active(); 
    for (; cell != endc; ++cell, ++cell_dgrt) 
      { 
        fe_values.reinit(cell); 
        fe_values_dgrt.reinit(cell_dgrt); 

        coefficient.value_list(fe_values_dgrt.get_quadrature_points(), 
                               coefficient_values); 

// 这个 <code>cell_matrix_E</code> 的分量是 $(\mathbf{K} \mathbf{w}, \mathbf{w})$ 的积分。  <code>cell_matrix_M</code> 是格拉姆矩阵。

        cell_matrix_M = 0; 
        cell_matrix_E = 0; 
        for (unsigned int q = 0; q < n_q_points_dgrt; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i) 
            { 
              const Tensor<1, dim> v_i = fe_values_dgrt[velocities].value(i, q); 
              for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k) 
                { 
                  const Tensor<1, dim> v_k = 
                    fe_values_dgrt[velocities].value(k, q); 

                  cell_matrix_E(i, k) += 
                    (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q)); 

                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q)); 
                } 
            } 

// 为了计算介绍中提到的矩阵 $D$ ，我们就需要按照介绍中的解释来评估 $D=M^{-1}E$ 。

        cell_matrix_M.gauss_jordan(); 
        cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E); 

// 然后，我们还需要再次计算矩阵 $C$ ，用于评估弱离散梯度。这与组装系统矩阵时使用的代码完全相同，所以我们只需从那里复制它。

        cell_matrix_G = 0; 
        for (unsigned int q = 0; q < n_q_points; ++q) 
          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i) 
            { 
              const double div_v_i = 
                fe_values_dgrt[velocities].divergence(i, q); 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const double phi_j_interior = 
                    fe_values[pressure_interior].value(j, q); 

                  cell_matrix_G(i, j) -= 
                    (div_v_i * phi_j_interior * fe_values.JxW(q)); 
                } 
            } 

        for (const auto &face : cell->face_iterators()) 
          { 
            fe_face_values.reinit(cell, face); 
            fe_face_values_dgrt.reinit(cell_dgrt, face); 

            for (unsigned int q = 0; q < n_face_q_points; ++q) 
              { 
                const Tensor<1, dim> &normal = fe_face_values.normal_vector(q); 

                for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i) 
                  { 
                    const Tensor<1, dim> v_i = 
                      fe_face_values_dgrt[velocities].value(i, q); 
                    for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                      { 
                        const double phi_j_face = 
                          fe_face_values[pressure_face].value(j, q); 

                        cell_matrix_G(i, j) += 
                          ((v_i * normal) * phi_j_face * fe_face_values.JxW(q)); 
                      } 
                  } 
              } 
          } 
        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M); 

// 最后，我们需要提取对应于当前单元的压力未知数。

        cell->get_dof_values(solution, cell_solution); 

// 我们现在可以计算当地的速度未知数（相对于我们将 $-\mathbf K \nabla_{w,d} p_h$ 项投影到的Raviart-Thomas空间而言）。

        cell_velocity = 0; 
        for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k) 
          for (unsigned int j = 0; j < dofs_per_cell_dgrt; ++j) 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_velocity(k) += 
                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j)); 

// 我们计算达西速度。这与cell_velocity相同，但用于绘制Darcy速度图。

        cell_dgrt->get_dof_indices(local_dof_indices_dgrt); 
        for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k) 
          for (unsigned int j = 0; j < dofs_per_cell_dgrt; ++j) 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              darcy_velocity(local_dof_indices_dgrt[k]) += 
                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j)); 
      } 
  } 

//  @sect4{WGDarcyEquation<dim>::compute_pressure_error}  

// 这一部分是为了计算压力的 $L_2$ 误差。 我们定义一个向量，用来保存每个单元上的误差规范。接下来，我们使用 VectorTool::integrate_difference() 来计算每个单元上的 $L_2$ 准则的误差。然而，我们实际上只关心解向量的内部分量的误差（我们甚至不能评估正交点的界面压力，因为这些都位于单元格的内部），因此必须使用一个权重函数，确保解变量的界面分量被忽略。这是通过使用ComponentSelectFunction来实现的，其参数表明我们要选择哪个分量（零分量，即内部压力）以及总共有多少分量（两个）。

  template <int dim> 
  void WGDarcyEquation<dim>::compute_pressure_error() 
  { 
    Vector<float> difference_per_cell(triangulation.n_active_cells()); 
    const ComponentSelectFunction<dim> select_interior_pressure(0, 2); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      ExactPressure<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(fe.degree + 2), 
                                      VectorTools::L2_norm, 
                                      &select_interior_pressure); 

    const double L2_error = difference_per_cell.l2_norm(); 
    std::cout << "L2_error_pressure " << L2_error << std::endl; 
  } 

//  @sect4{WGDarcyEquation<dim>::compute_velocity_error}  

// 在这个函数中，我们评估每个单元的速度的 $L_2$ 误差，以及面的流量的 $L_2$ 误差。该函数依赖于之前计算过的`compute_postprocessed_velocity()`函数，该函数根据之前计算过的压力解来计算速度场。

// 我们将评估每个单元的速度，并计算数值速度和精确速度之间的差异。

  template <int dim> 
  void WGDarcyEquation<dim>::compute_velocity_errors() 
  { 
    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1); 
    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1); 

    FEValues<dim> fe_values_dgrt(fe_dgrt, 
                                 quadrature_formula, 
                                 update_values | update_gradients | 
                                   update_quadrature_points | 
                                   update_JxW_values); 

    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt, 
                                          face_quadrature_formula, 
                                          update_values | 
                                            update_normal_vectors | 
                                            update_quadrature_points | 
                                            update_JxW_values); 

    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size(); 
    const unsigned int n_face_q_points_dgrt = 
      fe_face_values_dgrt.get_quadrature().size(); 

    std::vector<Tensor<1, dim>> velocity_values(n_q_points_dgrt); 
    std::vector<Tensor<1, dim>> velocity_face_values(n_face_q_points_dgrt); 

    const FEValuesExtractors::Vector velocities(0); 

    const ExactVelocity<dim> exact_velocity; 

    double L2_err_velocity_cell_sqr_global = 0; 
    double L2_err_flux_sqr                 = 0; 

// 在之前计算了后处理的速度之后，我们在这里只需要提取每个单元和面的相应数值，并与精确的数值进行比较。

    for (const auto &cell_dgrt : dof_handler_dgrt.active_cell_iterators()) 
      { 
        fe_values_dgrt.reinit(cell_dgrt); 

// 首先计算后处理的速度场与精确速度场之间的 $L_2$ 误差。

        fe_values_dgrt[velocities].get_function_values(darcy_velocity, 
                                                       velocity_values); 
        double L2_err_velocity_cell_sqr_local = 0; 
        for (unsigned int q = 0; q < n_q_points_dgrt; ++q) 
          { 
            const Tensor<1, dim> velocity = velocity_values[q]; 
            const Tensor<1, dim> true_velocity = 
              exact_velocity.value(fe_values_dgrt.quadrature_point(q)); 

            L2_err_velocity_cell_sqr_local += 
              ((velocity - true_velocity) * (velocity - true_velocity) * 
               fe_values_dgrt.JxW(q)); 
          } 
        L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local; 

// 为了重建通量，我们需要单元格和面的大小。由于通量是按面计算的，我们必须在每个单元的所有四个面上进行循环。为了计算面的速度，我们从之前计算的`darcy_velocity`中提取正交点的值。然后，我们计算法线方向的速度平方误差。最后，我们通过对面和单元面积的适当缩放来计算单元上的 $L_2$ 通量误差，并将其加入全局误差。

        const double cell_area = cell_dgrt->measure(); 
        for (const auto &face_dgrt : cell_dgrt->face_iterators()) 
          { 
            const double face_length = face_dgrt->measure(); 
            fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt); 
            fe_face_values_dgrt[velocities].get_function_values( 
              darcy_velocity, velocity_face_values); 

            double L2_err_flux_face_sqr_local = 0; 
            for (unsigned int q = 0; q < n_face_q_points_dgrt; ++q) 
              { 
                const Tensor<1, dim> velocity = velocity_face_values[q]; 
                const Tensor<1, dim> true_velocity = 
                  exact_velocity.value(fe_face_values_dgrt.quadrature_point(q)); 

                const Tensor<1, dim> &normal = 
                  fe_face_values_dgrt.normal_vector(q); 

 
                  ((velocity * normal - true_velocity * normal) * 
                   (velocity * normal - true_velocity * normal) * 
                   fe_face_values_dgrt.JxW(q)); 
              } 
            const double err_flux_each_face = 
              L2_err_flux_face_sqr_local / face_length * cell_area; 
            L2_err_flux_sqr += err_flux_each_face; 
          } 
      } 

// 将所有单元和面的误差相加后，我们进行平方根计算，得到速度和流量的 $L_2$ 误差。我们将这些数据输出到屏幕上。

    const double L2_err_velocity_cell = 
      std::sqrt(L2_err_velocity_cell_sqr_global); 
    const double L2_err_flux_face = std::sqrt(L2_err_flux_sqr); 

    std::cout << "L2_error_vel:  " << L2_err_velocity_cell << std::endl 
              << "L2_error_flux: " << L2_err_flux_face << std::endl; 
  } 
// @sect4{WGDarcyEquation::output_results}  

// 我们有两组结果要输出：内部解和骨架解。我们使用 <code>DataOut</code> 来显示内部结果。骨架结果的图形输出是通过使用DataOutFaces类完成的。

// 在这两个输出文件中，内部和面的变量都被存储。对于界面输出，输出文件只是包含了内部压力对面的插值，但是因为没有确定从两个相邻的单元中得到的是哪一个内部压力变量，所以在界面输出文件中最好是忽略内部压力。相反，对于单元格内部输出文件，当然不可能显示任何界面压力 $p^\partial$ ，因为这些压力只适用于界面，而不是单元格内部。因此，你会看到它们被显示为一个无效的值（比如一个无穷大）。

// 对于单元内部的输出，我们还想输出速度变量。这有点棘手，因为它生活在同一个网格上，但使用不同的DoFHandler对象（压力变量生活在`dof_handler`对象上，达西速度生活在`dof_handler_dgrt`对象上）。幸运的是， DataOut::add_data_vector() 函数有一些变化，允许指定一个矢量对应的DoFHandler，因此我们可以在同一个文件中对两个DoFHandler对象的数据进行可视化。

  template <int dim> 
  void WGDarcyEquation<dim>::output_results() const 
  { 
    { 
      DataOut<dim> data_out; 

// 首先将压力解决方案附加到DataOut对象上。

      const std::vector<std::string> solution_names = {"interior_pressure", 
                                                       "interface_pressure"}; 
      data_out.add_data_vector(dof_handler, solution, solution_names); 

// 然后对达西速度场做同样的处理，并继续将所有内容写进文件。

      const std::vector<std::string> velocity_names(dim, "velocity"); 
      const std::vector< 
        DataComponentInterpretation::DataComponentInterpretation> 
        velocity_component_interpretation( 
          dim, DataComponentInterpretation::component_is_part_of_vector); 
      data_out.add_data_vector(dof_handler_dgrt, 
                               darcy_velocity, 
                               velocity_names, 
                               velocity_component_interpretation); 

      data_out.build_patches(fe.degree); 
      std::ofstream output("solution_interior.vtu"); 
      data_out.write_vtu(output); 
    } 

    { 
      DataOutFaces<dim> data_out_faces(false); 
      data_out_faces.attach_dof_handler(dof_handler); 
      data_out_faces.add_data_vector(solution, "Pressure_Face"); 
      data_out_faces.build_patches(fe.degree); 
      std::ofstream face_output("solution_interface.vtu"); 
      data_out_faces.write_vtu(face_output); 
    } 
  } 
// @sect4{WGDarcyEquation::run}  

// 这是主类的最后一个函数。它调用我们类的其他函数。

  template <int dim> 
  void WGDarcyEquation<dim>::run() 
  { 
    std::cout << "Solving problem in " << dim << " space dimensions." 
              << std::endl; 
    make_grid(); 
    setup_system(); 
    assemble_system(); 
    solve(); 
    compute_postprocessed_velocity(); 
    compute_pressure_error(); 
    compute_velocity_errors(); 
    output_results(); 
  } 

} // namespace Step61 
// @sect3{The <code>main</code> function}  

// 这是主函数。我们可以在这里改变维度以在3D中运行。

int main() 
{ 
  try 
    { 
      Step61::WGDarcyEquation<2> wg_darcy(0); 
      wg_darcy.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-62.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2018 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE at 
 * the top level of the deal.II distribution. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Daniel Garcia-Sanchez, CNRS, 2019 
 */ 


// @sect3{Include files}  

// 我们在这个程序中需要的大部分包含文件已经在以前的程序中讨论过了，特别是在  step-40  .

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/function.h> 

#include <deal.II/base/index_set.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/generic_linear_algebra.h> 
#include <deal.II/lac/petsc_solver.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <fstream> 
#include <iostream> 

// 下面的标头提供了我们用来表示材料属性的张量类。

#include <deal.II/base/tensor.h> 

// 下面的标头对于deal.II的HDF5接口是必要的。

#include <deal.II/base/hdf5.h> 

// 这个头是我们用来评估模拟结果的函数 VectorTools::point_value 所需要的。

#include <deal.II/numerics/vector_tools.h> 

// 我们在函数 GridTools::find_active_cell_around_point 中使用的函数 `ElasticWave::store_frequency_step_data()` 需要这些头文件。
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/grid_tools_cache.h> 

namespace step62 
{ 
  using namespace dealii; 
// @sect3{Auxiliary classes and functions}  下列类用于存储模拟的参数。

//  @sect4{The `RightHandSide` class}  该类用于定义结构左侧的力脉冲。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide(HDF5::Group &data); 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component) const override; 

  private: 

// 变量`data`是 HDF5::Group ，所有的模拟结果都将被储存在其中。请注意， `RightHandSide::data`, 变量 
// `PML::data`,  
// `Rho::data` 和 `Parameters::data` 指向HDF5文件的同一个组。当 HDF5::Group 被复制时，它将指向HDF5文件的同一组。

    HDF5::Group data; 

// 仿真参数作为HDF5属性存储在`data`中。以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。

    const double     max_force_amplitude; 
    const double     force_sigma_x; 
    const double     force_sigma_y; 
    const double     max_force_width_x; 
    const double     max_force_width_y; 
    const Point<dim> force_center; 

  public: 

// 在这个特定的模拟中，力只有一个 $x$ 分量， $F_y=0$  。

    const unsigned int force_component = 0; 
  }; 
// @sect4{The `PML` class}  这个类是用来定义完美匹配层（PML）的形状，以吸收向边界传播的波。

  template <int dim> 
  class PML : public Function<dim, std::complex<double>> 
  { 
  public: 
    PML(HDF5::Group &data); 

    virtual std::complex<double> 
    value(const Point<dim> &p, const unsigned int component) const override; 

  private: 
// HDF5::Group ，所有的模拟结果将被存储在其中。

    HDF5::Group data; 

// 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。

    const double pml_coeff; 
    const int    pml_coeff_degree; 
    const double dimension_x; 
    const double dimension_y; 
    const bool   pml_x; 
    const bool   pml_y; 
    const double pml_width_x; 
    const double pml_width_y; 
    const double a_coeff_x; 
    const double a_coeff_y; 
  }; 

//  @sect4{The `Rho` class}  这个类是用来定义质量密度的。

  template <int dim> 
  class Rho : public Function<dim> 
  { 
  public: 
    Rho(HDF5::Group &data); 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

  private: 
// HDF5::Group ，所有的模拟结果将被存储在其中。

    HDF5::Group data; 

// 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。

    const double       lambda; 
    const double       mu; 
    const double       material_a_rho; 
    const double       material_b_rho; 
    const double       cavity_resonance_frequency; 
    const unsigned int nb_mirror_pairs; 
    const double       dimension_y; 
    const unsigned int grid_level; 
    double             average_rho_width; 
  }; 

//  @sect4{The `Parameters` class}  该类包含所有将在模拟中使用的参数。

  template <int dim> 
  class Parameters 
  { 
  public: 
    Parameters(HDF5::Group &data); 
// HDF5::Group ，所有的模拟结果将被存储在其中。

    HDF5::Group data; 

// 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。

    const std::string        simulation_name; 
    const bool               save_vtu_files; 
    const double             start_frequency; 
    const double             stop_frequency; 
    const unsigned int       nb_frequency_points; 
    const double             lambda; 
    const double             mu; 
    const double             dimension_x; 
    const double             dimension_y; 
    const unsigned int       nb_probe_points; 
    const unsigned int       grid_level; 
    const Point<dim>         probe_start_point; 
    const Point<dim>         probe_stop_point; 
    const RightHandSide<dim> right_hand_side; 
    const PML<dim>           pml; 
    const Rho<dim>           rho; 

  private: 
    const double comparison_float_constant = 1e-12; 
  }; 

//  @sect4{The `QuadratureCache` class}  质量和刚度矩阵的计算是非常昂贵的。这些矩阵对所有的频率步骤都是一样的。右手边的向量对所有的频率步长也是一样的。我们用这个类来存储这些对象，并在每个频率步骤中重新使用它们。请注意，这里我们不存储集合的质量和刚度矩阵以及右手边，而是存储单个单元的数据。QuadratureCache "类与在  step-18  中使用过的 "PointHistory "类非常相似。

  template <int dim> 
  class QuadratureCache 
  { 
  public: 
    QuadratureCache(const unsigned int dofs_per_cell); 

  private: 
    unsigned int dofs_per_cell; 

  public: 

// 我们在变量mass_coefficient和stiffness_coefficient中存储质量和刚度矩阵。我们还存储了右手边和JxW值，这些值对所有的频率步骤都是一样的。

    FullMatrix<std::complex<double>>  mass_coefficient; 
    FullMatrix<std::complex<double>>  stiffness_coefficient; 
    std::vector<std::complex<double>> right_hand_side; 
    double                            JxW; 
  }; 

//  @sect4{The `get_stiffness_tensor()` function}  

// 该函数返回材料的刚度张量。为了简单起见，我们认为刚度是各向同性和同质的；只有密度  $\rho$  取决于位置。正如我们之前在  step-8  中所表明的，如果刚度是各向同性和均质的，那么刚度系数  $c_{ijkl}$  可以表示为两个系数  $\lambda$  和  $\mu$  的函数。系数张量简化为 
// @f[
//    c_{ijkl}
//    =
//    \lambda \delta_{ij} \delta_{kl} +
//    \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}).
//  @f] 。

  template <int dim> 
  SymmetricTensor<4, dim> get_stiffness_tensor(const double lambda, 
                                               const double mu) 
  { 
    SymmetricTensor<4, dim> stiffness_tensor; 
    for (unsigned int i = 0; i < dim; ++i) 
      for (unsigned int j = 0; j < dim; ++j) 
        for (unsigned int k = 0; k < dim; ++k) 
          for (unsigned int l = 0; l < dim; ++l) 
            stiffness_tensor[i][j][k][l] = 
              (((i == k) && (j == l) ? mu : 0.0) + 
               ((i == l) && (j == k) ? mu : 0.0) + 
               ((i == j) && (k == l) ? lambda : 0.0)); 
    return stiffness_tensor; 
  } 

//  @sect3{The `ElasticWave` class}  

// 接下来让我们声明这个程序的主类。它的结构与 step-40 的教程程序非常相似。主要的区别是。

// - 扫过的频率值。

// - 我们将刚度和质量矩阵保存在`quadrature_cache`中，并在每个频率步骤中使用它们。

// - 我们在HDF5文件中存储每个频率步骤的探头测量的能量。

  template <int dim> 
  class ElasticWave 
  { 
  public: 
    ElasticWave(const Parameters<dim> &parameters); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(const double omega, 
                         const bool   calculate_quadrature_data); 
    void solve(); 
    void initialize_probe_positions_vector(); 
    void store_frequency_step_data(const unsigned int frequency_idx); 
    void output_results(); 

// 在每个频率步骤之前都会调用这个，以便为缓存变量设置一个原始状态。

    void setup_quadrature_cache(); 

// 这个函数在频率向量上循环，并在每个频率步骤上运行模拟。

    void frequency_sweep(); 

// 参数存储在这个变量中。

    Parameters<dim> parameters; 

    MPI_Comm mpi_communicator; 

    parallel::distributed::Triangulation<dim> triangulation; 

    QGauss<dim> quadrature_formula; 

// 我们将每个单元的质量和刚度矩阵存储在这个向量中。

    std::vector<QuadratureCache<dim>> quadrature_cache; 

    FESystem<dim>   fe; 
    DoFHandler<dim> dof_handler; 

    IndexSet locally_owned_dofs; 
    IndexSet locally_relevant_dofs; 

    AffineConstraints<std::complex<double>> constraints; 

    LinearAlgebraPETSc::MPI::SparseMatrix system_matrix; 
    LinearAlgebraPETSc::MPI::Vector       locally_relevant_solution; 
    LinearAlgebraPETSc::MPI::Vector       system_rhs; 

// 这个向量包含我们要模拟的频率范围。

    std::vector<double> frequency; 

// 这个向量包含了测量探头各点的坐标 $(x,y)$ 。

    FullMatrix<double> probe_positions; 

// HDF5数据集来存储频率和`探头位置`向量。

    HDF5::DataSet frequency_dataset; 
    HDF5::DataSet probe_positions_dataset; 

// HDF5数据集，存储探头测量的能量值。

    HDF5::DataSet displacement; 

    ConditionalOStream pcout; 
    TimerOutput        computing_timer; 
  }; 

//  @sect3{Implementation of the auxiliary classes}  
// @sect4{The `RightHandSide` class implementation}  

// 构造函数使用 HDF5::Group  `data`函数从 HDF5::Group::get_attribute()  读取所有参数。

  template <int dim> 
  RightHandSide<dim>::RightHandSide(HDF5::Group &data) 
    : Function<dim>(dim) 
    , data(data) 
    , max_force_amplitude(data.get_attribute<double>("max_force_amplitude")) 
    , force_sigma_x(data.get_attribute<double>("force_sigma_x")) 
    , force_sigma_y(data.get_attribute<double>("force_sigma_y")) 
    , max_force_width_x(data.get_attribute<double>("max_force_width_x")) 
    , max_force_width_y(data.get_attribute<double>("max_force_width_y")) 
    , force_center(Point<dim>(data.get_attribute<double>("force_x_pos"), 
                              data.get_attribute<double>("force_y_pos"))) 
  {} 

//这个函数定义了力矢量脉冲的空间形状，它采取高斯函数
// @f{align*}
//  F_x &=
//  \left\{
//  \begin{array}{ll}
//    a \exp(- (\frac{(x-b_x)^2 }{ 2 \sigma_x^2}+\frac{(y-b_y)^2 }{ 2
//    \sigma_y^2}))
//  & \text{if}\, x_\textrm{min} <x<x_\textrm{max}\, \text{and}\,
//  y_\textrm{min} <y<y_\textrm{max}  \\ 0 & \text{otherwise},
//  \end{array}
//  \right.\\ F_y &= 0
//  @f}
//  的形式，其中 $a$ 是取力的最大振幅， $\sigma_x$ 和 $\sigma_y$ 是 $x$ 和 $y$ 分量的标准偏差。请注意，脉冲已被裁剪为 $x_\textrm{min}<x<x_\textrm{max}$ 和 $y_\textrm{min} <y<y_\textrm{max}$  。

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & p, 
                                   const unsigned int component) const 
  { 
    if (component == force_component) 
      { 
        if (std::abs(p[0] - force_center[0]) < max_force_width_x / 2 && 
            std::abs(p[1] - force_center[1]) < max_force_width_y / 2) 
          { 
            return max_force_amplitude * 
                   std::exp(-(std::pow(p[0] - force_center[0], 2) / 
                                (2 * std::pow(force_sigma_x, 2)) + 
                              std::pow(p[1] - force_center[1], 2) / 
                                (2 * std::pow(force_sigma_y, 2)))); 
          } 
        else 
          { 
            return 0; 
          } 
      } 
    else 
      { 
        return 0; 
      } 
  } 

//  @sect4{The `PML` class implementation}  

// 和以前一样，构造函数使用 HDF5::Group 函数从 HDF5::Group::get_attribute() `data`中读取所有参数。正如我们所讨论的，在jupyter笔记本中已经定义了PML的二次开机。通过改变参数`pml_coeff_degree`，可以使用线性、立方或其他幂度。参数`pml_x`和`pml_y`可以用来开启和关闭`x`和`y`PML。

  template <int dim> 
  PML<dim>::PML(HDF5::Group &data) 
    : Function<dim, std::complex<double>>(dim) 
    , data(data) 
    , pml_coeff(data.get_attribute<double>("pml_coeff")) 
    , pml_coeff_degree(data.get_attribute<int>("pml_coeff_degree")) 
    , dimension_x(data.get_attribute<double>("dimension_x")) 
    , dimension_y(data.get_attribute<double>("dimension_y")) 
    , pml_x(data.get_attribute<bool>("pml_x")) 
    , pml_y(data.get_attribute<bool>("pml_y")) 
    , pml_width_x(data.get_attribute<double>("pml_width_x")) 
    , pml_width_y(data.get_attribute<double>("pml_width_y")) 
    , a_coeff_x(pml_coeff / std::pow(pml_width_x, pml_coeff_degree)) 
    , a_coeff_y(pml_coeff / std::pow(pml_width_y, pml_coeff_degree)) 
  {} 

// `x`部分的PML系数的形式为  $s'_x = a_x x^{\textrm{degree}}$  。
  template <int dim> 
  std::complex<double> PML<dim>::value(const Point<dim> & p, 
                                       const unsigned int component) const 
  { 
    double calculated_pml_x_coeff = 0; 
    double calculated_pml_y_coeff = 0; 

    if ((component == 0) && pml_x) 
      { 
        const double pml_x_start_position = dimension_x / 2 - pml_width_x; 
        if (std::abs(p[0]) > pml_x_start_position) 
          { 
            const double x_prime = std::abs(p[0]) - pml_x_start_position; 
            calculated_pml_x_coeff = 
              a_coeff_x * std::pow(x_prime, pml_coeff_degree); 
          } 
      } 

    if ((component == 1) && pml_y) 
      { 
        const double pml_y_start_position = dimension_y / 2 - pml_width_y; 
        if (std::abs(p[1]) > pml_y_start_position) 
          { 
            const double y_prime = std::abs(p[1]) - pml_y_start_position; 
            calculated_pml_y_coeff = 
              a_coeff_y * std::pow(y_prime, pml_coeff_degree); 
          } 
      } 

    return 1. + std::max(calculated_pml_x_coeff, calculated_pml_y_coeff) * 
                  std::complex<double>(0., 1.); 
  } 

//  @sect4{The `Rho` class implementation}  

// 这个类是用来定义质量密度的。正如我们之前所解释的，一个声学超晶格空腔是由两个[分布式反射器](https:en.wikipedia.org/wiki/Band_gap)、镜子和一个 $\lambda/2$ 空腔组成的，其中 $\lambda$ 是声波长。声学DBRs是一种周期性结构，其中一组具有对比性物理特性（声速指数）的双层堆栈被重复 $N$ 次。波速的变化是由具有不同密度的层交替产生的。

  template <int dim> 
  Rho<dim>::Rho(HDF5::Group &data) 
    : Function<dim>(1) 
    , data(data) 
    , lambda(data.get_attribute<double>("lambda")) 
    , mu(data.get_attribute<double>("mu")) 
    , material_a_rho(data.get_attribute<double>("material_a_rho")) 
    , material_b_rho(data.get_attribute<double>("material_b_rho")) 
    , cavity_resonance_frequency( 
        data.get_attribute<double>("cavity_resonance_frequency")) 
    , nb_mirror_pairs(data.get_attribute<int>("nb_mirror_pairs")) 
    , dimension_y(data.get_attribute<double>("dimension_y")) 
    , grid_level(data.get_attribute<int>("grid_level")) 
  { 

// 为了提高精度，我们使用[subpixel smoothing]（https:meep.readthedocs.io/en/latest/Subpixel_Smoothing/）。

    average_rho_width = dimension_y / (std::pow(2.0, grid_level)); 
    data.set_attribute("average_rho_width", average_rho_width); 
  } 

  template <int dim> 
  double Rho<dim>::value(const Point<dim> &p, 
                         const unsigned int /*component*/) const 
  { 

// 声速由
// @f[
//   c = \frac{K_e}{\rho}
//  @f]
//  定义，其中 $K_e$ 是有效弹性常数， $\rho$ 是密度。这里我们考虑的是波导宽度远小于波长的情况。在这种情况下，可以证明对于二维的情况
//  @f[
//   K_e = 4\mu\frac{\lambda +\mu}{\lambda+2\mu}
//  @f]
//  和三维的情况 $K_e$ 等于杨氏模量。
//  @f[
//   K_e = \mu\frac{3\lambda +2\mu}{\lambda+\mu}
//  @f]

    double elastic_constant; 
    if (dim == 2) 
      { 
        elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu); 
      } 
    else if (dim == 3) 
      { 
        elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu); 
      } 
    else 
      { 
        Assert(false, ExcInternalError()); 
      } 
    const double material_a_speed_of_sound = 
      std::sqrt(elastic_constant / material_a_rho); 
    const double material_a_wavelength = 
      material_a_speed_of_sound / cavity_resonance_frequency; 
    const double material_b_speed_of_sound = 
      std::sqrt(elastic_constant / material_b_rho); 
    const double material_b_wavelength = 
      material_b_speed_of_sound / cavity_resonance_frequency; 

//密度 $\rho$ 采取以下形式 <img alt="声学超晶格空腔" src="https:www.dealii.org/images/steps/developer/  step-62  .04.svg" height="200" //其中棕色代表材料_a，绿色代表材料_b。

    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++) 
      { 
        const double layer_transition_center = 
          material_a_wavelength / 2 + 
          idx * (material_b_wavelength / 4 + material_a_wavelength / 4); 
        if (std::abs(p[0]) >= 
              (layer_transition_center - average_rho_width / 2) && 
            std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2)) 
          { 
            const double coefficient = 
              (std::abs(p[0]) - 
               (layer_transition_center - average_rho_width / 2)) / 
              average_rho_width; 
            return (1 - coefficient) * material_a_rho + 
                   coefficient * material_b_rho; 
          } 
      } 

// 这里我们定义了[subpixel smoothing](https:meep.readthedocs.io/en/latest/Subpixel_Smoothing/)，它可以提高模拟的精度。

    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++) 
      { 
        const double layer_transition_center = 
          material_a_wavelength / 2 + 
          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + 
          material_b_wavelength / 4; 
        if (std::abs(p[0]) >= 
              (layer_transition_center - average_rho_width / 2) && 
            std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2)) 
          { 
            const double coefficient = 
              (std::abs(p[0]) - 
               (layer_transition_center - average_rho_width / 2)) / 
              average_rho_width; 
            return (1 - coefficient) * material_b_rho + 
                   coefficient * material_a_rho; 
          } 
      } 

// 然后是腔体

    if (std::abs(p[0]) <= material_a_wavelength / 2) 
      { 
        return material_a_rho; 
      } 

// 材料层_a

    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++) 
      { 
        const double layer_center = 
          material_a_wavelength / 2 + 
          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + 
          material_b_wavelength / 4 + material_a_wavelength / 8; 
        const double layer_width = material_a_wavelength / 4; 
        if (std::abs(p[0]) >= (layer_center - layer_width / 2) && 
            std::abs(p[0]) <= (layer_center + layer_width / 2)) 
          { 
            return material_a_rho; 
          } 
      } 

// material_b层

    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++) 
      { 
        const double layer_center = 
          material_a_wavelength / 2 + 
          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + 
          material_b_wavelength / 8; 
        const double layer_width = material_b_wavelength / 4; 
        if (std::abs(p[0]) >= (layer_center - layer_width / 2) && 
            std::abs(p[0]) <= (layer_center + layer_width / 2)) 
          { 
            return material_b_rho; 
          } 
      } 

// 最后，默认的是 material_a。

    return material_a_rho; 
  } 

//  @sect4{The `Parameters` class implementation}  

// 构造函数使用 HDF5::Group 函数从 HDF5::Group::get_attribute() `data`中读取所有参数。

  template <int dim> 
  Parameters<dim>::Parameters(HDF5::Group &data) 
    : data(data) 
    , simulation_name(data.get_attribute<std::string>("simulation_name")) 
    , save_vtu_files(data.get_attribute<bool>("save_vtu_files")) 
    , start_frequency(data.get_attribute<double>("start_frequency")) 
    , stop_frequency(data.get_attribute<double>("stop_frequency")) 
    , nb_frequency_points(data.get_attribute<int>("nb_frequency_points")) 
    , lambda(data.get_attribute<double>("lambda")) 
    , mu(data.get_attribute<double>("mu")) 
    , dimension_x(data.get_attribute<double>("dimension_x")) 
    , dimension_y(data.get_attribute<double>("dimension_y")) 
    , nb_probe_points(data.get_attribute<int>("nb_probe_points")) 
    , grid_level(data.get_attribute<int>("grid_level")) 
    , probe_start_point(data.get_attribute<double>("probe_pos_x"), 
                        data.get_attribute<double>("probe_pos_y") - 
                          data.get_attribute<double>("probe_width_y") / 2) 
    , probe_stop_point(data.get_attribute<double>("probe_pos_x"), 
                       data.get_attribute<double>("probe_pos_y") + 
                         data.get_attribute<double>("probe_width_y") / 2) 
    , right_hand_side(data) 
    , pml(data) 
    , rho(data) 
  {} 

//  @sect4{The `QuadratureCache` class implementation}  

// 我们需要为质量和刚度矩阵以及右手边的矢量保留足够的空间。

  template <int dim> 
  QuadratureCache<dim>::QuadratureCache(const unsigned int dofs_per_cell) 
    : dofs_per_cell(dofs_per_cell) 
    , mass_coefficient(dofs_per_cell, dofs_per_cell) 
    , stiffness_coefficient(dofs_per_cell, dofs_per_cell) 
    , right_hand_side(dofs_per_cell) 
  {} 

//  @sect3{Implementation of the `ElasticWave` class}  
// @sect4{Constructor}  

// 这与  step-40  的构造函数非常相似。此外，我们还创建了HDF5数据集`frequency_dataset`，`position_dataset`和`displacement`。注意在创建HDF5数据集时使用了 "模板 "关键字。这是C++的要求，使用`template`关键字是为了将`create_dataset`作为一个依赖的模板名称。

  template <int dim> 
  ElasticWave<dim>::ElasticWave(const Parameters<dim> &parameters) 
    : parameters(parameters) 
    , mpi_communicator(MPI_COMM_WORLD) 
    , triangulation(mpi_communicator, 
                    typename Triangulation<dim>::MeshSmoothing( 
                      Triangulation<dim>::smoothing_on_refinement | 
                      Triangulation<dim>::smoothing_on_coarsening)) 
    , quadrature_formula(2) 
    , fe(FE_Q<dim>(1), dim) 
    , dof_handler(triangulation) 
    , frequency(parameters.nb_frequency_points) 
    , probe_positions(parameters.nb_probe_points, dim) 
    , frequency_dataset(parameters.data.template create_dataset<double>( 
        "frequency", 
        std::vector<hsize_t>{parameters.nb_frequency_points})) 
    , probe_positions_dataset(parameters.data.template create_dataset<double>( 
        "position", 
        std::vector<hsize_t>{parameters.nb_probe_points, dim})) 
    , displacement( 
        parameters.data.template create_dataset<std::complex<double>>( 
          "displacement", 
          std::vector<hsize_t>{parameters.nb_probe_points, 
                               parameters.nb_frequency_points})) 
    , pcout(std::cout, 
            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
    , computing_timer(mpi_communicator, 
                      pcout, 
                      TimerOutput::summary, 
                      TimerOutput::wall_times) 
  {} 

//  @sect4{ElasticWave::setup_system}  

// 这个函数没有什么新内容，与 step-40 的唯一区别是，我们不需要应用边界条件，因为我们使用PML来截断域。

  template <int dim> 
  void ElasticWave<dim>::setup_system() 
  { 
    TimerOutput::Scope t(computing_timer, "setup"); 

    dof_handler.distribute_dofs(fe); 

    locally_owned_dofs = dof_handler.locally_owned_dofs(); 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 

    locally_relevant_solution.reinit(locally_owned_dofs, 
                                     locally_relevant_dofs, 
                                     mpi_communicator); 

    system_rhs.reinit(locally_owned_dofs, mpi_communicator); 

    constraints.clear(); 
    constraints.reinit(locally_relevant_dofs); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

    constraints.close(); 

    DynamicSparsityPattern dsp(locally_relevant_dofs); 

    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); 
    SparsityTools::distribute_sparsity_pattern(dsp, 
                                               locally_owned_dofs, 
                                               mpi_communicator, 
                                               locally_relevant_dofs); 

    system_matrix.reinit(locally_owned_dofs, 
                         locally_owned_dofs, 
                         dsp, 
                         mpi_communicator); 
  } 

//  @sect4{ElasticWave::assemble_system}  

// 这个函数也与 step-40 非常相似，尽管有明显的区别。我们为每个频率/欧米茄步骤组装系统。在第一步中，我们设置`calculate_quadrature_data = True`，然后我们计算质量和刚度矩阵以及右手边的矢量。在随后的步骤中，我们将使用这些数据来加速计算。

  template <int dim> 
  void ElasticWave<dim>::assemble_system(const double omega, 
                                         const bool   calculate_quadrature_data) 
  { 
    TimerOutput::Scope t(computing_timer, "assembly"); 

    FEValues<dim>      fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<std::complex<double>> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<std::complex<double>>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 这里我们存储右手边的值，rho和PML的值。

    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim)); 
    std::vector<double>         rho_values(n_q_points); 
    std::vector<Vector<std::complex<double>>> pml_values( 
      n_q_points, Vector<std::complex<double>>(dim)); 

// 我们计算已经在jupyter笔记本中定义的 $\lambda$ 和 $\mu$ 的刚度张量。请注意，与 $\rho$ 相反，刚度在整个领域中是恒定的。

    const SymmetricTensor<4, dim> stiffness_tensor = 
      get_stiffness_tensor<dim>(parameters.lambda, parameters.mu); 

// 我们使用与 step-20 相同的方法处理矢量值问题。

    const FEValuesExtractors::Vector displacement(0); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell_matrix = 0; 
          cell_rhs    = 0; 

// 只有当我们要计算质量和刚度矩阵时，我们才必须计算右手边的rho和PML的值。否则我们可以跳过这个计算，这样可以大大减少总的计算时间。

          if (calculate_quadrature_data) 
            { 
              fe_values.reinit(cell); 

              parameters.right_hand_side.vector_value_list( 
                fe_values.get_quadrature_points(), rhs_values); 
              parameters.rho.value_list(fe_values.get_quadrature_points(), 
                                        rho_values); 
              parameters.pml.vector_value_list( 
                fe_values.get_quadrature_points(), pml_values); 
            } 

// 我们已经在  step-18  中做了这个工作。获得一个指向当前单元本地正交缓存数据的指针，作为防御措施，确保这个指针在全局数组的范围内。

          QuadratureCache<dim> *local_quadrature_points_data = 
            reinterpret_cast<QuadratureCache<dim> *>(cell->user_pointer()); 
          Assert(local_quadrature_points_data >= &quadrature_cache.front(), 
                 ExcInternalError()); 
          Assert(local_quadrature_points_data <= &quadrature_cache.back(), 
                 ExcInternalError()); 
          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 

// quadrature_data变量用于存储质量和刚度矩阵、右手边向量和`JxW`的值。

              QuadratureCache<dim> &quadrature_data = 
                local_quadrature_points_data[q]; 

// 下面我们声明力向量和PML的参数  $s$  和  $\xi$  。

              Tensor<1, dim>                       force; 
              Tensor<1, dim, std::complex<double>> s; 
              std::complex<double>                 xi(1, 0); 

// 下面的块只在第一个频率步骤中计算。

              if (calculate_quadrature_data) 
                { 

// 存储`JxW`的值。

                  quadrature_data.JxW = fe_values.JxW(q); 

                  for (unsigned int component = 0; component < dim; ++component) 
                    { 

// 将向量转换为张量，并计算出xi

                      force[component] = rhs_values[q][component]; 
                      s[component]     = pml_values[q][component]; 
                      xi *= s[component]; 
                    } 

// 这里我们计算 $\alpha_{mnkl}$ 和 $\beta_{mnkl}$ 张量。

                  Tensor<4, dim, std::complex<double>> alpha; 
                  Tensor<4, dim, std::complex<double>> beta; 
                  for (unsigned int m = 0; m < dim; ++m) 
                    for (unsigned int n = 0; n < dim; ++n) 
                      for (unsigned int k = 0; k < dim; ++k) 
                        for (unsigned int l = 0; l < dim; ++l) 
                          { 
                            alpha[m][n][k][l] = xi * 
                                                stiffness_tensor[m][n][k][l] / 
                                                (2.0 * s[n] * s[k]); 
                            beta[m][n][k][l] = xi * 
                                               stiffness_tensor[m][n][k][l] / 
                                               (2.0 * s[n] * s[l]); 
                          } 

                  for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                    { 
                      const Tensor<1, dim> phi_i = 
                        fe_values[displacement].value(i, q); 
                      const Tensor<2, dim> grad_phi_i = 
                        fe_values[displacement].gradient(i, q); 

                      for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                        { 
                          const Tensor<1, dim> phi_j = 
                            fe_values[displacement].value(j, q); 
                          const Tensor<2, dim> grad_phi_j = 
                            fe_values[displacement].gradient(j, q); 

// 计算质量矩阵的值。

                          quadrature_data.mass_coefficient[i][j] = 
                            rho_values[q] * xi * phi_i * phi_j; 

//在刚度张量的 $mnkl$ 指数上循环。

                          std::complex<double> stiffness_coefficient = 0; 
                          for (unsigned int m = 0; m < dim; ++m) 
                            for (unsigned int n = 0; n < dim; ++n) 
                              for (unsigned int k = 0; k < dim; ++k) 
                                for (unsigned int l = 0; l < dim; ++l) 
                                  { 

// 这里我们计算刚度矩阵。                          
//注意，由于PML的存在，刚度矩阵不是对称的。我们使用梯度函数（见[文档](https:www.dealii.org/current/doxygen/deal.II/group__vector__valued.html)），它是一个  <code>Tensor@<2,dim@></code>  。                          
// 矩阵 $G_{ij}$ 由条目
                          // @f[
                          //  G_{ij}=
                          //  \frac{\partial\phi_i}{\partial x_j}
                          //  =\partial_j \phi_i
                          // @f]
                          // 组成 注意指数 $i$ 和 $j$ 的位置以及我们在本教程中使用的符号。  $\partial_j\phi_i$  . 由于刚度张量不是对称的，所以很容易出错。

                                    stiffness_coefficient += 
                                      grad_phi_i[m][n] * 
                                      (alpha[m][n][k][l] * grad_phi_j[l][k] + 
                                       beta[m][n][k][l] * grad_phi_j[k][l]); 
                                  } 

// 我们将刚度矩阵的值保存在quadrature_data中。

                          quadrature_data.stiffness_coefficient[i][j] = 
                            stiffness_coefficient; 
                        } 

// 和正交数据中的右手边的值。

 
                        phi_i * force * fe_values.JxW(q); 
                    } 
                } 

// 我们再次循环单元的自由度来计算系统矩阵。这些循环非常快，因为我们已经计算了刚度和质量矩阵，只有 $\omega$ 的值发生了变化。

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    { 
                      std::complex<double> matrix_sum = 0; 
                      matrix_sum += -std::pow(omega, 2) * 
                                    quadrature_data.mass_coefficient[i][j]; 
                      matrix_sum += quadrature_data.stiffness_coefficient[i][j]; 
                      cell_matrix(i, j) += matrix_sum * quadrature_data.JxW; 
                    } 
                  cell_rhs(i) += quadrature_data.right_hand_side[i]; 
                } 
            } 
          cell->get_dof_indices(local_dof_indices); 
          constraints.distribute_local_to_global(cell_matrix, 
                                                 cell_rhs, 
                                                 local_dof_indices, 
                                                 system_matrix, 
                                                 system_rhs); 
        } 

    system_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 
  } 
// @sect4{ElasticWave::solve}  

// 这比  step-40  更加简单。我们使用并行的直接求解器MUMPS，它比迭代求解器需要更少的选项。缺点是它不能很好地扩展。用迭代求解器来解决Helmholtz方程并不简单。移位拉普拉斯多网格法是一种众所周知的预处理该系统的方法，但这超出了本教程的范围。

  template <int dim> 
  void ElasticWave<dim>::solve() 
  { 
    TimerOutput::Scope              t(computing_timer, "solve"); 
    LinearAlgebraPETSc::MPI::Vector completely_distributed_solution( 
      locally_owned_dofs, mpi_communicator); 

    SolverControl                    solver_control; 
    PETScWrappers::SparseDirectMUMPS solver(solver_control, mpi_communicator); 
    solver.solve(system_matrix, completely_distributed_solution, system_rhs); 

    pcout << "   Solved in " << solver_control.last_step() << " iterations." 
          << std::endl; 
    constraints.distribute(completely_distributed_solution); 
    locally_relevant_solution = completely_distributed_solution; 
  } 
// @sect4{ElasticWave::initialize_position_vector}  

// 我们用这个函数来计算位置向量的值。

  template <int dim> 
  void ElasticWave<dim>::initialize_probe_positions_vector() 
  { 
    for (unsigned int position_idx = 0; 
         position_idx < parameters.nb_probe_points; 
         ++position_idx) 
      { 

// 由于运算符+和

// -被重载来减去两个点，所以必须做如下操作。`Point_b<dim> + (-Point_a<dim>)`。

        const Point<dim> p = 
          (position_idx / ((double)(parameters.nb_probe_points - 1))) * 
            (parameters.probe_stop_point + (-parameters.probe_start_point)) + 
          parameters.probe_start_point; 
        probe_positions[position_idx][0] = p[0]; 
        probe_positions[position_idx][1] = p[1]; 
        if (dim == 3) 
          { 
            probe_positions[position_idx][2] = p[2]; 
          } 
      } 
  } 
// @sect4{ElasticWave::store_frequency_step_data}  

// 该函数在HDF5文件中存储探头测量的能量。

  template <int dim> 
  void 
  ElasticWave<dim>::store_frequency_step_data(const unsigned int frequency_idx) 
  { 
    TimerOutput::Scope t(computing_timer, "store_frequency_step_data"); 

// 我们存储 $x$ 方向的位移； $y$ 方向的位移可以忽略不计。

    const unsigned int probe_displacement_component = 0; 

// 向量坐标包含HDF5文件中位于本地所有单元中的探测点的坐标。向量displacement_data包含这些点的位移值。

    std::vector<hsize_t>              coordinates; 
    std::vector<std::complex<double>> displacement_data; 

    const auto &mapping = get_default_linear_mapping(triangulation); 
    GridTools::Cache<dim, dim> cache(triangulation, mapping); 
    typename Triangulation<dim, dim>::active_cell_iterator cell_hint{}; 
    std::vector<bool>                                      marked_vertices = {}; 
    const double                                           tolerance = 1.e-10; 

    for (unsigned int position_idx = 0; 
         position_idx < parameters.nb_probe_points; 
         ++position_idx) 
      { 
        Point<dim> point; 
        for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx) 
          { 
            point[dim_idx] = probe_positions[position_idx][dim_idx]; 
          } 
        bool point_in_locally_owned_cell = false; 
        { 
          auto cell_and_ref_point = GridTools::find_active_cell_around_point( 
            cache, point, cell_hint, marked_vertices, tolerance); 
          if (cell_and_ref_point.first.state() == IteratorState::valid) 
            { 
              cell_hint = cell_and_ref_point.first; 
              point_in_locally_owned_cell = 
                cell_and_ref_point.first->is_locally_owned(); 
            } 
        } 
        if (point_in_locally_owned_cell) 
          { 

// 然后，我们可以在`displacement_data`中存储探头各点的位移值。

            Vector<std::complex<double>> tmp_vector(dim); 
            VectorTools::point_value(dof_handler, 
                                     locally_relevant_solution, 
                                     point, 
                                     tmp_vector); 
            coordinates.emplace_back(position_idx); 
            coordinates.emplace_back(frequency_idx); 
            displacement_data.emplace_back( 
              tmp_vector(probe_displacement_component)); 
          } 
      } 

// 我们在HDF5文件中写入位移数据。调用 HDF5::DataSet::write_selection() 是MPI集体的，这意味着所有进程都要参与。

    if (coordinates.size() > 0) 
      { 
        displacement.write_selection(displacement_data, coordinates); 
      } 

// 因此，即使进程没有数据可写，它也必须参与集体调用。为此我们可以使用  HDF5::DataSet::write_none().  注意，我们必须指定数据类型，在这种情况下  `std::complex<double>`.  。
    else 
      { 
        displacement.write_none<std::complex<double>>(); 
      } 

// 如果输入文件中的变量`save_vtu_files`等于`True`，那么所有数据将被保存为vtu。写入`vtu'文件的过程已经在  step-40  中描述。

    if (parameters.save_vtu_files) 
      { 
        std::vector<std::string> solution_names(dim, "displacement"); 
        std::vector<DataComponentInterpretation::DataComponentInterpretation> 
          interpretation( 
            dim, DataComponentInterpretation::component_is_part_of_vector); 

        DataOut<dim> data_out; 
        data_out.add_data_vector(dof_handler, 
                                 locally_relevant_solution, 
                                 solution_names, 
                                 interpretation); 
        Vector<float> subdomain(triangulation.n_active_cells()); 
        for (unsigned int i = 0; i < subdomain.size(); ++i) 
          subdomain(i) = triangulation.locally_owned_subdomain(); 
        data_out.add_data_vector(subdomain, "subdomain"); 

        std::vector<Vector<double>> force( 
          dim, Vector<double>(triangulation.n_active_cells())); 
        std::vector<Vector<double>> pml( 
          dim, Vector<double>(triangulation.n_active_cells())); 
        Vector<double> rho(triangulation.n_active_cells()); 

        for (auto &cell : triangulation.active_cell_iterators()) 
          { 
            if (cell->is_locally_owned()) 
              { 
                for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx) 
                  { 
                    force[dim_idx](cell->active_cell_index()) = 
                      parameters.right_hand_side.value(cell->center(), dim_idx); 
                    pml[dim_idx](cell->active_cell_index()) = 
                      parameters.pml.value(cell->center(), dim_idx).imag(); 
                  } 
                rho(cell->active_cell_index()) = 
                  parameters.rho.value(cell->center()); 
              } 

// 在我们不感兴趣的单元格上，将各自的值设置为一个假值，以确保如果我们的假设有什么错误，我们会通过查看图形输出发现。

            else 
              { 
                for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx) 
                  { 
                    force[dim_idx](cell->active_cell_index()) = -1e+20; 
                    pml[dim_idx](cell->active_cell_index())   = -1e+20; 
                  } 
                rho(cell->active_cell_index()) = -1e+20; 
              } 
          } 

        for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx) 
          { 
            data_out.add_data_vector(force[dim_idx], 
                                     "force_" + std::to_string(dim_idx)); 
            data_out.add_data_vector(pml[dim_idx], 
                                     "pml_" + std::to_string(dim_idx)); 
          } 
        data_out.add_data_vector(rho, "rho"); 

        data_out.build_patches(); 

        std::stringstream  frequency_idx_stream; 
        const unsigned int nb_number_positions = 
          ((unsigned int)std::log10(parameters.nb_frequency_points)) + 1; 
        frequency_idx_stream << std::setw(nb_number_positions) 
                             << std::setfill('0') << frequency_idx; 
        std::string filename = (parameters.simulation_name + "_" + 
                                frequency_idx_stream.str() + ".vtu"); 
        data_out.write_vtu_in_parallel(filename.c_str(), mpi_communicator); 
      } 
  } 

//  @sect4{ElasticWave::output_results}  

// 该函数写入尚未写入的数据集。

  template <int dim> 
  void ElasticWave<dim>::output_results() 
  { 

// 向量`频率`和`位置`对所有进程都是一样的。因此任何一个进程都可以写入相应的`数据集'。因为调用 HDF5::DataSet::write 是MPI集体的，其余进程将不得不调用 HDF5::DataSet::write_none.  。
    if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0) 
      { 
        frequency_dataset.write(frequency); 
        probe_positions_dataset.write(probe_positions); 
      } 
    else 
      { 
        frequency_dataset.write_none<double>(); 
        probe_positions_dataset.write_none<double>(); 
      } 
  } 

//  @sect4{ElasticWave::setup_quadrature_cache}  

// 我们在计算开始时使用这个函数来设置缓存变量的初始值。这个函数在  step-18  中已经描述过。与  step-18  的函数没有区别。

  template <int dim> 
  void ElasticWave<dim>::setup_quadrature_cache() 
  { 
    triangulation.clear_user_data(); 

    { 
      std::vector<QuadratureCache<dim>> tmp; 
      quadrature_cache.swap(tmp); 
    } 

    quadrature_cache.resize(triangulation.n_locally_owned_active_cells() * 
                              quadrature_formula.size(), 
                            QuadratureCache<dim>(fe.n_dofs_per_cell())); 
    unsigned int cache_index = 0; 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell->set_user_pointer(&quadrature_cache[cache_index]); 
          cache_index += quadrature_formula.size(); 
        } 
    Assert(cache_index == quadrature_cache.size(), ExcInternalError()); 
  } 

//  @sect4{ElasticWave::frequency_sweep}  

// 为了清楚起见，我们将 step-40 的函数`run`分为函数`run`和`frequency_sweep`。在函数`frequency_sweep`中，我们把迭代放在频率向量上。

  template <int dim> 
  void ElasticWave<dim>::frequency_sweep() 
  { 
    for (unsigned int frequency_idx = 0; 
         frequency_idx < parameters.nb_frequency_points; 
         ++frequency_idx) 
      { 
        pcout << parameters.simulation_name + " frequency idx: " 
              << frequency_idx << '/' << parameters.nb_frequency_points - 1 
              << std::endl; 

        setup_system(); 
        if (frequency_idx == 0) 
          { 
            pcout << "   Number of active cells :       " 
                  << triangulation.n_active_cells() << std::endl; 
            pcout << "   Number of degrees of freedom : " 
                  << dof_handler.n_dofs() << std::endl; 
          } 

        if (frequency_idx == 0) 
          { 

// 只写一次模拟参数

            parameters.data.set_attribute("active_cells", 
                                          triangulation.n_active_cells()); 
            parameters.data.set_attribute("degrees_of_freedom", 
                                          dof_handler.n_dofs()); 
          } 

// 我们计算出这个特定步骤的频率和欧米茄值。

        const double current_loop_frequency = 
          (parameters.start_frequency + 
           frequency_idx * 
             (parameters.stop_frequency - parameters.start_frequency) / 
             (parameters.nb_frequency_points - 1)); 
        const double current_loop_omega = 
          2 * numbers::PI * current_loop_frequency; 

// 在第一个频率步骤中，我们计算出质量和刚度矩阵以及右手边的数据。在随后的频率步骤中，我们将使用这些值。这大大改善了计算时间。

        assemble_system(current_loop_omega, 
                        (frequency_idx == 0) ? true : false); 
        solve(); 

        frequency[frequency_idx] = current_loop_frequency; 
        store_frequency_step_data(frequency_idx); 

        computing_timer.print_summary(); 
        computing_timer.reset(); 
        pcout << std::endl; 
      } 
  } 

//  @sect4{ElasticWave::run}  

// 这个函数与  step-40  中的函数非常相似。

  template <int dim> 
  void ElasticWave<dim>::run() 
  { 
#ifdef DEBUG 
    pcout << "Debug mode" << std::endl; 
#else 
    pcout << "Release mode" << std::endl; 
#endif 

    { 
      Point<dim> p1; 
      p1(0) = -parameters.dimension_x / 2; 
      p1(1) = -parameters.dimension_y / 2; 
      if (dim == 3) 
        { 
          p1(2) = -parameters.dimension_y / 2; 
        } 
      Point<dim> p2; 
      p2(0) = parameters.dimension_x / 2; 
      p2(1) = parameters.dimension_y / 2; 
      if (dim == 3) 
        { 
          p2(2) = parameters.dimension_y / 2; 
        } 
      std::vector<unsigned int> divisions(dim); 
      divisions[0] = int(parameters.dimension_x / parameters.dimension_y); 
      divisions[1] = 1; 
      if (dim == 3) 
        { 
          divisions[2] = 1; 
        } 
      GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                                divisions, 
                                                p1, 
                                                p2); 
    } 

    triangulation.refine_global(parameters.grid_level); 

    setup_quadrature_cache(); 

    initialize_probe_positions_vector(); 

    frequency_sweep(); 

    output_results(); 
  } 
} // namespace step62 

//  @sect4{The main function}  

// 主函数与  step-40  中的函数非常相似。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      const unsigned int dim = 2; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      HDF5::File data_file("results.h5", 
                           HDF5::File::FileAccessMode::create, 
                           MPI_COMM_WORLD); 
      auto       data = data_file.create_group("data"); 

// 每个模拟（位移和校准）都存储在一个单独的HDF5组中。

      const std::vector<std::string> group_names = {"displacement", 
                                                    "calibration"}; 
      for (auto group_name : group_names) 
        { 

// 对于这两个组名中的每一个，我们现在创建组并将属性放入这些组。具体来说，这些是。

// - 波导的尺寸（在 $x$ 和 $y$ 方向）。

// - 探头的位置（在 $x$ 和 $y$ 方向）。

// - 探针中的点的数量

// - 全局细化水平

// - 腔体谐振频率

// - 镜像对的数量 

// - 镜子的数量 

// - 材料特性

// - 力的参数

// - PML参数

// - 频率参数

          auto group = data.create_group(group_name); 

          group.set_attribute<double>("dimension_x", 2e-5); 
          group.set_attribute<double>("dimension_y", 2e-8); 
          group.set_attribute<double>("probe_pos_x", 8e-6); 
          group.set_attribute<double>("probe_pos_y", 0); 
          group.set_attribute<double>("probe_width_y", 2e-08); 
          group.set_attribute<unsigned int>("nb_probe_points", 5); 
          group.set_attribute<unsigned int>("grid_level", 1); 
          group.set_attribute<double>("cavity_resonance_frequency", 20e9); 
          group.set_attribute<unsigned int>("nb_mirror_pairs", 15); 

          group.set_attribute<double>("poissons_ratio", 0.27); 
          group.set_attribute<double>("youngs_modulus", 270000000000.0); 
          group.set_attribute<double>("material_a_rho", 3200); 

          if (group_name == std::string("displacement")) 
            group.set_attribute<double>("material_b_rho", 2000); 
          else 
            group.set_attribute<double>("material_b_rho", 3200); 

          group.set_attribute( 
            "lambda", 
            group.get_attribute<double>("youngs_modulus") * 
              group.get_attribute<double>("poissons_ratio") / 
              ((1 + group.get_attribute<double>("poissons_ratio")) * 
               (1 - 2 * group.get_attribute<double>("poissons_ratio")))); 
          group.set_attribute("mu", 
                              group.get_attribute<double>("youngs_modulus") / 
                                (2 * (1 + group.get_attribute<double>( 
                                            "poissons_ratio")))); 

          group.set_attribute<double>("max_force_amplitude", 1e26); 
          group.set_attribute<double>("force_sigma_x", 1e-7); 
          group.set_attribute<double>("force_sigma_y", 1); 
          group.set_attribute<double>("max_force_width_x", 3e-7); 
          group.set_attribute<double>("max_force_width_y", 2e-8); 
          group.set_attribute<double>("force_x_pos", -8e-6); 
          group.set_attribute<double>("force_y_pos", 0); 

          group.set_attribute<bool>("pml_x", true); 
          group.set_attribute<bool>("pml_y", false); 
          group.set_attribute<double>("pml_width_x", 1.8e-6); 
          group.set_attribute<double>("pml_width_y", 5e-7); 
          group.set_attribute<double>("pml_coeff", 1.6); 
          group.set_attribute<unsigned int>("pml_coeff_degree", 2); 

          group.set_attribute<double>("center_frequency", 20e9); 
          group.set_attribute<double>("frequency_range", 0.5e9); 
          group.set_attribute<double>( 
            "start_frequency", 
            group.get_attribute<double>("center_frequency") - 
              group.get_attribute<double>("frequency_range") / 2); 
          group.set_attribute<double>( 
            "stop_frequency", 
            group.get_attribute<double>("center_frequency") + 
              group.get_attribute<double>("frequency_range") / 2); 
          group.set_attribute<unsigned int>("nb_frequency_points", 400); 

          if (group_name == std::string("displacement")) 
            group.set_attribute<std::string>( 
              "simulation_name", std::string("phononic_cavity_displacement")); 
          else 
            group.set_attribute<std::string>( 
              "simulation_name", std::string("phononic_cavity_calibration")); 

          group.set_attribute<bool>("save_vtu_files", false); 
        } 

      { 

// 位移模拟。参数从位移HDF5组中读取，结果保存在同一HDF5组中。

        auto                    displacement = data.open_group("displacement"); 
        step62::Parameters<dim> parameters(displacement); 

        step62::ElasticWave<dim> elastic_problem(parameters); 
        elastic_problem.run(); 
      } 

      { 

// 校准模拟。参数从校准HDF5组中读取，结果保存在同一HDF5组中。

        auto                    calibration = data.open_group("calibration"); 
        step62::Parameters<dim> parameters(calibration); 

        step62::ElasticWave<dim> elastic_problem(parameters); 
        elastic_problem.run(); 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-63.cc


/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2018 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Thomas C. Clevenger, Clemson University 
 *          Timo Heister, Clemson University and University of Utah 
 */ 


// @sect3{Include files}  

// 标准deal.II需要的典型文件。

#include <deal.II/base/tensor_function.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/parameter_handler.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/relaxation_block.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/grid_out.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/mapping_q.h> 
#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

// 包括所有相关的多层次文件。

#include <deal.II/multigrid/mg_constrained_dofs.h> 
#include <deal.II/multigrid/multigrid.h> 
#include <deal.II/multigrid/mg_transfer.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_matrix.h> 

// C++:

#include <algorithm> 
#include <fstream> 
#include <iostream> 
#include <random> 

// 我们将使用 MeshWorker::mesh_loop 功能来组装矩阵。

#include <deal.II/meshworker/mesh_loop.h> 
// @sect3{MeshWorker data}  

// 像往常一样，我们将把所有与这个程序有关的东西放到一个自己的命名空间中。

// 由于我们将使用MeshWorker框架，第一步是定义以下由 MeshWorker::mesh_loop(): 使用的assemble_cell()函数所需要的结构 `ScratchData`包含一个FEValues对象，这是组装一个单元的局部贡献所需要的，而`CopyData`包含一个单元的局部贡献的输出和复制到全局系统的必要信息。它们的目的在WorkStream类的文档中也有解释）。

namespace Step63 
{ 
  using namespace dealii; 

  template <int dim> 
  struct ScratchData 
  { 
    ScratchData(const FiniteElement<dim> &fe, 
                const unsigned int        quadrature_degree) 
      : fe_values(fe, 
                  QGauss<dim>(quadrature_degree), 
                  update_values | update_gradients | update_hessians | 
                    update_quadrature_points | update_JxW_values) 
    {} 

    ScratchData(const ScratchData<dim> &scratch_data) 
      : fe_values(scratch_data.fe_values.get_fe(), 
                  scratch_data.fe_values.get_quadrature(), 
                  update_values | update_gradients | update_hessians | 
                    update_quadrature_points | update_JxW_values) 
    {} 

    FEValues<dim> fe_values; 
  }; 

  struct CopyData 
  { 
    CopyData() = default; 

    unsigned int level; 
    unsigned int dofs_per_cell; 

    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_rhs; 
    std::vector<types::global_dof_index> local_dof_indices; 
  }; 

//  @sect3{Problem parameters}  

// 第二步是定义处理要从输入文件中读取的运行时参数的类。

// 我们将使用ParameterHandler在运行时传入参数。结构`Settings`解析并存储整个程序要查询的参数。

  struct Settings 
  { 
    enum DoFRenumberingStrategy 
    { 
      none, 
      downstream, 
      upstream, 
      random 
    }; 

    void get_parameters(const std::string &prm_filename); 

    double                 epsilon; 
    unsigned int           fe_degree; 
    std::string            smoother_type; 
    unsigned int           smoothing_steps; 
    DoFRenumberingStrategy dof_renumbering; 
    bool                   with_streamline_diffusion; 
    bool                   output; 
  }; 

  void Settings::get_parameters(const std::string &prm_filename) 
  { 

/* 首先声明参数...   */ 

 
    ParameterHandler prm; 

    prm.declare_entry("Epsilon", 
                      "0.005", 
                      Patterns::Double(0), 
                      "Diffusion parameter"); 

    prm.declare_entry("Fe degree", 
                      "1", 
                      Patterns::Integer(1), 
                      "Finite Element degree"); 
    prm.declare_entry("Smoother type", 
                      "block SOR", 
                      Patterns::Selection("SOR|Jacobi|block SOR|block Jacobi"), 
                      "Select smoother: SOR|Jacobi|block SOR|block Jacobi"); 
    prm.declare_entry("Smoothing steps", 
                      "2", 
                      Patterns::Integer(1), 
                      "Number of smoothing steps"); 
    prm.declare_entry( 
      "DoF renumbering", 
      "downstream", 
      Patterns::Selection("none|downstream|upstream|random"), 
      "Select DoF renumbering: none|downstream|upstream|random"); 
    prm.declare_entry("With streamline diffusion", 
                      "true", 
                      Patterns::Bool(), 
                      "Enable streamline diffusion stabilization: true|false"); 
    prm.declare_entry("Output", 
                      "true", 
                      Patterns::Bool(), 
                      "Generate graphical output: true|false"); 
    /* ...然后尝试从输入文件中读取它们的值。  */ 
    if (prm_filename.empty()) 
      { 
        prm.print_parameters(std::cout, ParameterHandler::Text); 
        AssertThrow( 
          false, ExcMessage("Please pass a .prm file as the first argument!")); 
      } 

    prm.parse_input(prm_filename); 

    epsilon         = prm.get_double("Epsilon"); 
    fe_degree       = prm.get_integer("Fe degree"); 
    smoother_type   = prm.get("Smoother type"); 
    smoothing_steps = prm.get_integer("Smoothing steps"); 

    const std::string renumbering = prm.get("DoF renumbering"); 
    if (renumbering == "none") 
      dof_renumbering = DoFRenumberingStrategy::none; 
    else if (renumbering == "downstream") 
      dof_renumbering = DoFRenumberingStrategy::downstream; 
    else if (renumbering == "upstream") 
      dof_renumbering = DoFRenumberingStrategy::upstream; 
    else if (renumbering == "random") 
      dof_renumbering = DoFRenumberingStrategy::random; 
    else 
      AssertThrow(false, 
                  ExcMessage("The <DoF renumbering> parameter has " 
                             "an invalid value.")); 

    with_streamline_diffusion = prm.get_bool("With streamline diffusion"); 
    output                    = prm.get_bool("Output"); 
  } 
// @sect3{Cell permutations}  

// 遍历单元和自由度的顺序将对乘法的收敛速度起作用。在这里，我们定义了一些函数，这些函数返回单元格的特定顺序，供块平滑器使用。

// 对于每种类型的单元格排序，我们定义了一个用于活动网格的函数和一个用于水平网格的函数（即用于多网格层次结构中的某一层的单元格）。虽然求解系统所需的唯一重新排序是在水平网格上进行的，但为了可视化的目的，我们在output_results()中包含了主动网格的重新排序。

// 对于两个下游排序函数，我们首先创建一个包含所有相关单元的数组，然后使用一个 "比较器 "对象在下游方向进行排序。然后，函数的输出是一个简单的数组，包含了刚刚计算出来的单元格的索引。

  template <int dim> 
  std::vector<unsigned int> 
  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler, 
                                  const Tensor<1, dim>   direction, 
                                  const unsigned int     level) 
  { 
    std::vector<typename DoFHandler<dim>::level_cell_iterator> ordered_cells; 
    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level)); 
    for (const auto &cell : dof_handler.cell_iterators_on_level(level)) 
      ordered_cells.push_back(cell); 

    const DoFRenumbering:: 
      CompareDownstream<typename DoFHandler<dim>::level_cell_iterator, dim> 
        comparator(direction); 
    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator); 

    std::vector<unsigned> ordered_indices; 
    ordered_indices.reserve(dof_handler.get_triangulation().n_cells(level)); 

    for (const auto &cell : ordered_cells) 
      ordered_indices.push_back(cell->index()); 

    return ordered_indices; 
  } 

  template <int dim> 
  std::vector<unsigned int> 
  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler, 
                                  const Tensor<1, dim>   direction) 
  { 
    std::vector<typename DoFHandler<dim>::active_cell_iterator> ordered_cells; 
    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells()); 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      ordered_cells.push_back(cell); 

    const DoFRenumbering:: 
      CompareDownstream<typename DoFHandler<dim>::active_cell_iterator, dim> 
        comparator(direction); 
    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator); 

    std::vector<unsigned int> ordered_indices; 
    ordered_indices.reserve(dof_handler.get_triangulation().n_active_cells()); 

    for (const auto &cell : ordered_cells) 
      ordered_indices.push_back(cell->index()); 

    return ordered_indices; 
  } 

// 产生随机排序的函数在精神上是相似的，它们首先将所有单元的信息放入一个数组。但是，它们不是对它们进行排序，而是利用C++提供的生成随机数的设施对元素进行随机洗牌。这样做的方式是在数组的所有元素上进行迭代，为之前的另一个元素抽取一个随机数，然后交换这些元素。其结果是对数组中的元素进行随机洗牌。

  template <int dim> 
  std::vector<unsigned int> 
  create_random_cell_ordering(const DoFHandler<dim> &dof_handler, 
                              const unsigned int     level) 
  { 
    std::vector<unsigned int> ordered_cells; 
    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level)); 
    for (const auto &cell : dof_handler.cell_iterators_on_level(level)) 
      ordered_cells.push_back(cell->index()); 

    std::mt19937 random_number_generator; 
    std::shuffle(ordered_cells.begin(), 
                 ordered_cells.end(), 
                 random_number_generator); 

    return ordered_cells; 
  } 

  template <int dim> 
  std::vector<unsigned int> 
  create_random_cell_ordering(const DoFHandler<dim> &dof_handler) 
  { 
    std::vector<unsigned int> ordered_cells; 
    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells()); 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      ordered_cells.push_back(cell->index()); 

    std::mt19937 random_number_generator; 
    std::shuffle(ordered_cells.begin(), 
                 ordered_cells.end(), 
                 random_number_generator); 

    return ordered_cells; 
  } 
// @sect3{Right-hand side and boundary values}  

// 本教程中所解决的问题是对<a
//  href="https:global.oup.com/academic/product/finite-elements-and-fast-iterative-solvers-9780199678808">
//  Finite Elements and Fast Iterative Solvers: with Applications in
//  Incompressible Fluid Dynamics by Elman, Silvester, and Wathen</a>第118页上的例3.1.3的修改。主要的区别是我们在域的中心增加了一个洞，其边界条件为零的Dirichlet。

// 为了获得完整的描述，我们需要首先实现零右手边的类（当然，我们可以直接使用 Functions::ZeroFunction):  。
  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> &, 
                                   const unsigned int component) const 
  { 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 
    (void)component; 

    return 0.0; 
  } 

  template <int dim> 
  void RightHandSide<dim>::value_list(const std::vector<Point<dim>> &points, 
                                      std::vector<double> &          values, 
                                      const unsigned int component) const 
  { 
    Assert(values.size() == points.size(), 
           ExcDimensionMismatch(values.size(), points.size())); 

    for (unsigned int i = 0; i < points.size(); ++i) 
      values[i] = RightHandSide<dim>::value(points[i], component); 
  } 

// 我们也有迪里希特的边界条件。在外部正方形边界的连接部分，我们将数值设置为1，其他地方（包括内部圆形边界）的数值设置为0。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & p, 
                                    const unsigned int component) const 
  { 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 
    (void)component; 

// 如果  $x=1$  ，或如果  $x>0.5$  和  $y=-1$  ，则将边界设为 1。

    if (std::fabs(p[0] - 1) < 1e-8 || 
        (std::fabs(p[1] + 1) < 1e-8 && p[0] >= 0.5)) 
      { 
        return 1.0; 
      } 
    else 
      { 
        return 0.0; 
      } 
  } 

  template <int dim> 
  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points, 
                                       std::vector<double> &          values, 
                                       const unsigned int component) const 
  { 
    Assert(values.size() == points.size(), 
           ExcDimensionMismatch(values.size(), points.size())); 

    for (unsigned int i = 0; i < points.size(); ++i) 
      values[i] = BoundaryValues<dim>::value(points[i], component); 
  } 

//  @sect3{Streamline diffusion implementation}  

// 流水线扩散方法有一个稳定常数，我们需要能够计算出来。这个参数的计算方式的选择取自于<a
//  href="https:link.springer.com/chapter/10.1007/978-3-540-34288-5_27">On
//  Discontinuity-Capturing Methods for Convection-Diffusion
//  Equations by Volker John and Petr Knobloch</a>。

  template <int dim> 
  double compute_stabilization_delta(const double         hk, 
                                     const double         eps, 
                                     const Tensor<1, dim> dir, 
                                     const double         pk) 
  { 
    const double Peclet = dir.norm() * hk / (2.0 * eps * pk); 
    const double coth = 
      (1.0 + std::exp(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet)); 

    return hk / (2.0 * dir.norm() * pk) * (coth - 1.0 / Peclet); 
  } 
// @sect3{<code>AdvectionProlem</code> class}  

// 这是程序的主类，看起来应该与  step-16  非常相似。主要的区别是，由于我们是在运行时定义我们的多网格平滑器，我们选择定义一个函数`create_smoother()`和一个类对象`mg_smoother`，这是一个  `std::unique_ptr`  派生于MGSmoother的平滑器。请注意，对于从RelaxationBlock派生的平滑器，我们必须为每个级别包括一个`smoother_data`对象。这将包含关于单元格排序和单元格矩阵倒置方法的信息。

  template <int dim> 
  class AdvectionProblem 
  { 
  public: 
    AdvectionProblem(const Settings &settings); 
    void run(); 

  private: 
    void setup_system(); 

    template <class IteratorType> 
    void assemble_cell(const IteratorType &cell, 
                       ScratchData<dim> &  scratch_data, 
                       CopyData &          copy_data); 
    void assemble_system_and_multigrid(); 

    void setup_smoother(); 

    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim> triangulation; 
    DoFHandler<dim>    dof_handler; 

    const FE_Q<dim>     fe; 
    const MappingQ<dim> mapping; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    MGLevelObject<SparsityPattern> mg_sparsity_patterns; 
    MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns; 

    MGLevelObject<SparseMatrix<double>> mg_matrices; 
    MGLevelObject<SparseMatrix<double>> mg_interface_in; 
    MGLevelObject<SparseMatrix<double>> mg_interface_out; 

    mg::Matrix<Vector<double>> mg_matrix; 
    mg::Matrix<Vector<double>> mg_interface_matrix_in; 
    mg::Matrix<Vector<double>> mg_interface_matrix_out; 

    std::unique_ptr<MGSmoother<Vector<double>>> mg_smoother; 

    using SmootherType = 
      RelaxationBlock<SparseMatrix<double>, double, Vector<double>>; 
    using SmootherAdditionalDataType = SmootherType::AdditionalData; 
    MGLevelObject<SmootherAdditionalDataType> smoother_data; 

    MGConstrainedDoFs mg_constrained_dofs; 

    Tensor<1, dim> advection_direction; 

    const Settings settings; 
  }; 

  template <int dim> 
  AdvectionProblem<dim>::AdvectionProblem(const Settings &settings) 
    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices) 
    , dof_handler(triangulation) 
    , fe(settings.fe_degree) 
    , mapping(settings.fe_degree) 
    , settings(settings) 
  { 
    advection_direction[0] = -std::sin(numbers::PI / 6.0); 
    if (dim >= 2) 
      advection_direction[1] = std::cos(numbers::PI / 6.0); 
    if (dim >= 3) 
      AssertThrow(false, ExcNotImplemented()); 
  } 
// @sect4{<code>AdvectionProblem::setup_system()</code>}  

// 在这里，我们首先为活动和多网格级别的网格设置DoFHandler、AffineConstraints和SparsityPattern对象。

// 我们可以用DoFRenumbering类对活动DoF进行重新编号，但是平滑器只作用于多网格层，因此，这对计算并不重要。相反，我们将对每个多网格层的DoFs进行重新编号。

  template <int dim> 
  void AdvectionProblem<dim>::setup_system() 
  { 
    const unsigned int n_levels = triangulation.n_levels(); 

    dof_handler.distribute_dofs(fe); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 

    VectorTools::interpolate_boundary_values( 
      mapping, dof_handler, 0, BoundaryValues<dim>(), constraints); 
    VectorTools::interpolate_boundary_values( 
      mapping, dof_handler, 1, BoundaryValues<dim>(), constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    constraints, 
                                    /*keep_constrained_dofs =  */ false);

    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 

    dof_handler.distribute_mg_dofs(); 

// 在列举了全局自由度以及（上面最后一行）水平自由度之后，让我们对水平自由度进行重新编号，以获得一个更好的平滑器，正如介绍中所解释的。 如果需要的话，下面的第一个区块会对下游或上游方向的每个层次的自由度进行重新编号。这只对点平滑器（SOR和Jacobi）有必要，因为块平滑器是在单元上操作的（见`create_smoother()`）。然后，下面的块也实现了随机编号。

    if (settings.smoother_type == "SOR" || settings.smoother_type == "Jacobi") 
      { 
        if (settings.dof_renumbering == 
              Settings::DoFRenumberingStrategy::downstream || 
            settings.dof_renumbering == 
              Settings::DoFRenumberingStrategy::upstream) 
          { 
            const Tensor<1, dim> direction = 
              (settings.dof_renumbering == 
                   Settings::DoFRenumberingStrategy::upstream ? 
                 -1.0 : 
                 1.0) * 
              advection_direction; 

            for (unsigned int level = 0; level < n_levels; ++level) 
              DoFRenumbering::downstream(dof_handler, 
                                         level, 
                                         direction, 
                                         /*dof_wise_renumbering =  */ true);

          } 
        else if (settings.dof_renumbering == 
                 Settings::DoFRenumberingStrategy::random) 
          { 
            for (unsigned int level = 0; level < n_levels; ++level) 
              DoFRenumbering::random(dof_handler, level); 
          } 
        else 
          Assert(false, ExcNotImplemented()); 
      } 

// 该函数的其余部分只是设置了数据结构。下面代码的最后几行与其他GMG教程不同，因为它同时设置了接口输入和输出矩阵。我们需要这样做，因为我们的问题是非对称性的。

    mg_constrained_dofs.clear(); 
    mg_constrained_dofs.initialize(dof_handler); 

    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1}); 

    mg_matrices.resize(0, n_levels - 1); 
    mg_matrices.clear_elements(); 
    mg_interface_in.resize(0, n_levels - 1); 
    mg_interface_in.clear_elements(); 
    mg_interface_out.resize(0, n_levels - 1); 
    mg_interface_out.clear_elements(); 
    mg_sparsity_patterns.resize(0, n_levels - 1); 
    mg_interface_sparsity_patterns.resize(0, n_levels - 1); 

    for (unsigned int level = 0; level < n_levels; ++level) 
      { 
        { 
          DynamicSparsityPattern dsp(dof_handler.n_dofs(level), 
                                     dof_handler.n_dofs(level)); 
          MGTools::make_sparsity_pattern(dof_handler, dsp, level); 
          mg_sparsity_patterns[level].copy_from(dsp); 
          mg_matrices[level].reinit(mg_sparsity_patterns[level]); 
        } 
        { 
          DynamicSparsityPattern dsp(dof_handler.n_dofs(level), 
                                     dof_handler.n_dofs(level)); 
          MGTools::make_interface_sparsity_pattern(dof_handler, 
                                                   mg_constrained_dofs, 
                                                   dsp, 
                                                   level); 
          mg_interface_sparsity_patterns[level].copy_from(dsp); 

          mg_interface_in[level].reinit(mg_interface_sparsity_patterns[level]); 
          mg_interface_out[level].reinit(mg_interface_sparsity_patterns[level]); 
        } 
      } 
  } 
// @sect4{<code>AdvectionProblem::assemble_cell()</code>}  

// 这里我们定义了每个单元上的线性系统的装配，以便被下面的Mesh_loop()函数使用。这个函数为活动单元或水平单元（不管它的第一个参数是什么）装配单元矩阵，并且只有在调用活动单元时才装配右手边。

  template <int dim> 
  template <class IteratorType> 
  void AdvectionProblem<dim>::assemble_cell(const IteratorType &cell, 
                                            ScratchData<dim> &  scratch_data, 
                                            CopyData &          copy_data) 
  { 
    copy_data.level = cell->level(); 

    const unsigned int dofs_per_cell = 
      scratch_data.fe_values.get_fe().n_dofs_per_cell(); 
    copy_data.dofs_per_cell = dofs_per_cell; 
    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 

    const unsigned int n_q_points = 
      scratch_data.fe_values.get_quadrature().size(); 

    if (cell->is_level_cell() == false) 
      copy_data.cell_rhs.reinit(dofs_per_cell); 

    copy_data.local_dof_indices.resize(dofs_per_cell); 
    cell->get_active_or_mg_dof_indices(copy_data.local_dof_indices); 

    scratch_data.fe_values.reinit(cell); 

    RightHandSide<dim>  right_hand_side; 
    std::vector<double> rhs_values(n_q_points); 

    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(), 
                               rhs_values); 

// 如果我们使用流线扩散，我们必须把它的贡献加到单元格矩阵和单元格的右手边。如果我们不使用流线扩散，设置 $\delta=0$ 就可以否定这个贡献，我们就可以使用标准的Galerkin有限元组合。

    const double delta = (settings.with_streamline_diffusion ? 
                            compute_stabilization_delta(cell->diameter(), 
                                                        settings.epsilon, 
                                                        advection_direction, 
                                                        settings.fe_degree) : 
                            0.0); 

    for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            { 

// 本地矩阵的组装有两个部分。首先是Galerkin贡献。

              copy_data.cell_matrix(i, j) += 
                (settings.epsilon * 
                 scratch_data.fe_values.shape_grad(i, q_point) * 
                 scratch_data.fe_values.shape_grad(j, q_point) * 
                 scratch_data.fe_values.JxW(q_point)) + 
                (scratch_data.fe_values.shape_value(i, q_point) * 
                 (advection_direction * 
                  scratch_data.fe_values.shape_grad(j, q_point)) * 
                 scratch_data.fe_values.JxW(q_point)) 

//然后是流线扩散贡献。

                + delta * 
                    (advection_direction * 
                     scratch_data.fe_values.shape_grad(j, q_point)) * 
                    (advection_direction * 
                     scratch_data.fe_values.shape_grad(i, q_point)) * 
                    scratch_data.fe_values.JxW(q_point) - 
                delta * settings.epsilon * 
                  trace(scratch_data.fe_values.shape_hessian(j, q_point)) * 
                  (advection_direction * 
                   scratch_data.fe_values.shape_grad(i, q_point)) * 
                  scratch_data.fe_values.JxW(q_point); 
            } 
          if (cell->is_level_cell() == false) 
            { 

// 同样的情况也适用于右手边。首先是Galerkin贡献。

              copy_data.cell_rhs(i) += 
                scratch_data.fe_values.shape_value(i, q_point) * 
                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point) 

// 然后是流线扩散贡献。

                + delta * rhs_values[q_point] * advection_direction * 
                    scratch_data.fe_values.shape_grad(i, q_point) * 
                    scratch_data.fe_values.JxW(q_point); 
            } 
        } 
  } 
// @sect4{<code>AdvectionProblem::assemble_system_and_multigrid()</code>}  

// 这里我们采用 MeshWorker::mesh_loop() 来翻阅单元格，为我们组装system_matrix、system_rhs和所有mg_matrices。

  template <int dim> 
  void AdvectionProblem<dim>::assemble_system_and_multigrid() 
  { 
    const auto cell_worker_active = 
      [&](const decltype(dof_handler.begin_active()) &cell, 
          ScratchData<dim> &                          scratch_data, 
          CopyData &                                  copy_data) { 
        this->assemble_cell(cell, scratch_data, copy_data); 
      }; 

    const auto copier_active = [&](const CopyData &copy_data) { 
      constraints.distribute_local_to_global(copy_data.cell_matrix, 
                                             copy_data.cell_rhs, 
                                             copy_data.local_dof_indices, 
                                             system_matrix, 
                                             system_rhs); 
    }; 

    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker_active, 
                          copier_active, 
                          ScratchData<dim>(fe, fe.degree + 1), 
                          CopyData(), 
                          MeshWorker::assemble_own_cells); 

// 与活动层的约束不同，我们选择在这个函数的本地为每个多网格层创建约束对象，因为它们在程序的其他地方从来不需要。

    std::vector<AffineConstraints<double>> boundary_constraints( 
      triangulation.n_global_levels()); 
    for (unsigned int level = 0; level < triangulation.n_global_levels(); 
         ++level) 
      { 
        IndexSet locally_owned_level_dof_indices; 
        DoFTools::extract_locally_relevant_level_dofs( 
          dof_handler, level, locally_owned_level_dof_indices); 
        boundary_constraints[level].reinit(locally_owned_level_dof_indices); 
        boundary_constraints[level].add_lines( 
          mg_constrained_dofs.get_refinement_edge_indices(level)); 
        boundary_constraints[level].add_lines( 
          mg_constrained_dofs.get_boundary_indices(level)); 
        boundary_constraints[level].close(); 
      } 

    const auto cell_worker_mg = 
      [&](const decltype(dof_handler.begin_mg()) &cell, 
          ScratchData<dim> &                      scratch_data, 
          CopyData &                              copy_data) { 
        this->assemble_cell(cell, scratch_data, copy_data); 
      }; 

    const auto copier_mg = [&](const CopyData &copy_data) { 
      boundary_constraints[copy_data.level].distribute_local_to_global( 
        copy_data.cell_matrix, 
        copy_data.local_dof_indices, 
        mg_matrices[copy_data.level]); 

// 如果 $(i,j)$ 是一个`interface_out` dof对，那么 $(j,i)$ 就是一个`interface_in` dof对。注意：对于 "interface_in"，我们加载接口条目的转置，即，dof对 $(j,i)$ 的条目被存储在 "interface_in(i,j)"。这是对对称情况的优化，允许在solve()中设置边缘矩阵时只使用一个矩阵。然而，在这里，由于我们的问题是非对称的，我们必须同时存储`interface_in`和`interface_out`矩阵。

      for (unsigned int i = 0; i < copy_data.dofs_per_cell; ++i) 
        for (unsigned int j = 0; j < copy_data.dofs_per_cell; ++j) 
          if (mg_constrained_dofs.is_interface_matrix_entry( 
                copy_data.level, 
                copy_data.local_dof_indices[i], 
                copy_data.local_dof_indices[j])) 
            { 
              mg_interface_out[copy_data.level].add( 
                copy_data.local_dof_indices[i], 
                copy_data.local_dof_indices[j], 
                copy_data.cell_matrix(i, j)); 
              mg_interface_in[copy_data.level].add( 
                copy_data.local_dof_indices[i], 
                copy_data.local_dof_indices[j], 
                copy_data.cell_matrix(j, i)); 
            } 
    }; 

    MeshWorker::mesh_loop(dof_handler.begin_mg(), 
                          dof_handler.end_mg(), 
                          cell_worker_mg, 
                          copier_mg, 
                          ScratchData<dim>(fe, fe.degree + 1), 
                          CopyData(), 
                          MeshWorker::assemble_own_cells); 
  } 
// @sect4{<code>AdvectionProblem::setup_smoother()</code>}  

// 接下来，我们根据`.prm`文件中的设置来设置平滑器。两个重要的选项是多网格v周期每一级的平滑前和平滑后步骤的数量以及松弛参数。

// 由于乘法往往比加法更强大，所以需要较少的平滑步骤来实现收敛，与网格大小无关。块平滑器比点平滑器也是如此。这反映在下面对每种平滑器的平滑步数的选择上。

// 点平滑器的松弛参数是在试验和错误的基础上选择的，它反映了在我们细化网格时保持GMRES求解的迭代次数不变（或尽可能接近）的必要值。在`.prm`文件中给 "Jacobi "和 "SOR "的两个值是针对1度和3度有限元的。如果用户想改成其他度数，他们可能需要调整这些数字。对于块平滑器，这个参数有一个更直接的解释，即对于二维的加法，一个DoF可以有多达4个单元的重复贡献，因此我们必须将这些方法放松0.25来补偿。对于乘法来说，这不是一个问题，因为每个单元的逆向应用都会给其所有的DoF带来新的信息。

// 最后，如上所述，点平滑器只对DoF进行操作，而块平滑器对单元进行操作，因此只有块平滑器需要被赋予有关单元排序的信息。点平滑器的DoF排序已经在`setup_system()`中得到了处理。

  template <int dim> 
  void AdvectionProblem<dim>::setup_smoother() 
  { 
    if (settings.smoother_type == "SOR") 
      { 
        using Smoother = PreconditionSOR<SparseMatrix<double>>; 

        auto smoother = 
          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>, 
                                                  Smoother, 
                                                  Vector<double>>>(); 
        smoother->initialize(mg_matrices, 
                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 : 
                                                                       0.62)); 
        smoother->set_steps(settings.smoothing_steps); 
        mg_smoother = std::move(smoother); 
      } 
    else if (settings.smoother_type == "Jacobi") 
      { 
        using Smoother = PreconditionJacobi<SparseMatrix<double>>; 
        auto smoother = 
          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>, 
                                                  Smoother, 
                                                  Vector<double>>>(); 
        smoother->initialize(mg_matrices, 
                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 : 
                                                                       0.47)); 
        smoother->set_steps(settings.smoothing_steps); 
        mg_smoother = std::move(smoother); 
      } 
    else if (settings.smoother_type == "block SOR" || 
             settings.smoother_type == "block Jacobi") 
      { 
        smoother_data.resize(0, triangulation.n_levels() - 1); 

        for (unsigned int level = 0; level < triangulation.n_levels(); ++level) 
          { 
            DoFTools::make_cell_patches(smoother_data[level].block_list, 
                                        dof_handler, 
                                        level); 

            smoother_data[level].relaxation = 
              (settings.smoother_type == "block SOR" ? 1.0 : 0.25); 
            smoother_data[level].inversion = PreconditionBlockBase<double>::svd; 

            std::vector<unsigned int> ordered_indices; 
            switch (settings.dof_renumbering) 
              { 
                case Settings::DoFRenumberingStrategy::downstream: 
                  ordered_indices = 
                    create_downstream_cell_ordering(dof_handler, 
                                                    advection_direction, 
                                                    level); 
                  break; 

                case Settings::DoFRenumberingStrategy::upstream: 
                  ordered_indices = 
                    create_downstream_cell_ordering(dof_handler, 
                                                    -1.0 * advection_direction, 
                                                    level); 
                  break; 

                case Settings::DoFRenumberingStrategy::random: 
                  ordered_indices = 
                    create_random_cell_ordering(dof_handler, level); 
                  break; 

                case Settings::DoFRenumberingStrategy::none: 
                  break; 

                default: 
                  AssertThrow(false, ExcNotImplemented()); 
                  break; 
              } 

            smoother_data[level].order = 
              std::vector<std::vector<unsigned int>>(1, ordered_indices); 
          } 

        if (settings.smoother_type == "block SOR") 
          { 
            auto smoother = std::make_unique<MGSmootherPrecondition< 
              SparseMatrix<double>, 
              RelaxationBlockSOR<SparseMatrix<double>, double, Vector<double>>, 
              Vector<double>>>(); 
            smoother->initialize(mg_matrices, smoother_data); 
            smoother->set_steps(settings.smoothing_steps); 
            mg_smoother = std::move(smoother); 
          } 
        else if (settings.smoother_type == "block Jacobi") 
          { 
            auto smoother = std::make_unique< 
              MGSmootherPrecondition<SparseMatrix<double>, 
                                     RelaxationBlockJacobi<SparseMatrix<double>, 
                                                           double, 
                                                           Vector<double>>, 
                                     Vector<double>>>(); 
            smoother->initialize(mg_matrices, smoother_data); 
            smoother->set_steps(settings.smoothing_steps); 
            mg_smoother = std::move(smoother); 
          } 
      } 
    else 
      AssertThrow(false, ExcNotImplemented()); 
  } 
// @sect4{<code>AdvectionProblem::solve()</code>}  

// 在解决这个系统之前，我们必须首先设置多网格预处理程序。这需要设置各级之间的转换、粗略矩阵求解器和平滑器。这个设置几乎与 Step-16 相同，主要区别在于上面定义的各种平滑器，以及由于我们的问题是非对称的，我们需要不同的界面边缘矩阵。实际上，在本教程中，这些接口矩阵是空的，因为我们只使用全局细化，因此没有细化边。然而，我们在这里仍然包括了这两个矩阵，因为如果我们简单地切换到自适应细化方法，程序仍然可以正常运行）。)

// 最后要注意的是，由于我们的问题是非对称的，我们必须使用适当的Krylov子空间方法。我们在这里选择使用GMRES，因为它能保证在每次迭代中减少残差。GMRES的主要缺点是，每次迭代，存储的临时向量的数量都会增加一个，而且还需要计算与之前存储的所有向量的标量积。这是很昂贵的。通过使用重启的GMRES方法可以放松这一要求，该方法对我们在任何时候需要存储的向量数量设置了上限（这里我们在50个临时向量后重启，即48次迭代）。这样做的缺点是我们失去了在整个迭代过程中收集的信息，因此我们可以看到收敛速度较慢。因此，在哪里重启是一个平衡内存消耗、CPU工作量和收敛速度的问题。然而，本教程的目标是通过使用强大的GMG预处理程序来实现非常低的迭代次数，所以我们选择了重启长度，使下面显示的所有结果在重启发生之前就能收敛，因此我们有一个标准的GMRES方法。如果用户有兴趣，deal.II中提供的另一种合适的方法是BiCGStab。

  template <int dim> 
  void AdvectionProblem<dim>::solve() 
  { 
    const unsigned int max_iters       = 200; 
    const double       solve_tolerance = 1e-8 * system_rhs.l2_norm(); 
    SolverControl      solver_control(max_iters, solve_tolerance, true, true); 
    solver_control.enable_history_data(); 

    using Transfer = MGTransferPrebuilt<Vector<double>>; 
    Transfer mg_transfer(mg_constrained_dofs); 
    mg_transfer.build(dof_handler); 

    FullMatrix<double> coarse_matrix; 
    coarse_matrix.copy_from(mg_matrices[0]); 
    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver; 
    coarse_grid_solver.initialize(coarse_matrix); 

    setup_smoother(); 

    mg_matrix.initialize(mg_matrices); 
    mg_interface_matrix_in.initialize(mg_interface_in); 
    mg_interface_matrix_out.initialize(mg_interface_out); 

    Multigrid<Vector<double>> mg( 
      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother); 
    mg.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in); 

    PreconditionMG<dim, Vector<double>, Transfer> preconditioner(dof_handler, 
                                                                 mg, 
                                                                 mg_transfer); 

    std::cout << "     Solving with GMRES to tol " << solve_tolerance << "..." 
              << std::endl; 
    SolverGMRES<Vector<double>> solver( 
      solver_control, SolverGMRES<Vector<double>>::AdditionalData(50, true)); 

    Timer time; 
    time.start(); 
    solver.solve(system_matrix, solution, system_rhs, preconditioner); 
    time.stop(); 

    std::cout << "          converged in " << solver_control.last_step() 
              << " iterations" 
              << " in " << time.last_wall_time() << " seconds " << std::endl; 

    constraints.distribute(solution); 

    mg_smoother.release(); 
  } 
// @sect4{<code>AdvectionProblem::output_results()</code>}  

// 最后一个感兴趣的函数会生成图形输出。这里我们以.vtu格式输出解决方案和单元格排序。

// 在函数的顶部，我们为每个单元生成一个索引，以显示平滑器所使用的排序。请注意，我们只对活动单元而不是平滑器实际使用的层级做这个处理。对于点平滑器，我们对DoFs而不是单元进行重新编号，所以这只是对现实中发生的情况的一种近似。最后，这个随机排序不是我们实际使用的随机排序（见`create_smoother()`）。

// 然后，单元格的（整数）排序被复制到一个（浮点）矢量中，用于图形输出。

  template <int dim> 
  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    const unsigned int n_active_cells = triangulation.n_active_cells(); 
    Vector<double>     cell_indices(n_active_cells); 
    { 
      std::vector<unsigned int> ordered_indices; 
      switch (settings.dof_renumbering) 
        { 
          case Settings::DoFRenumberingStrategy::downstream: 
            ordered_indices = 
              create_downstream_cell_ordering(dof_handler, advection_direction); 
            break; 

          case Settings::DoFRenumberingStrategy::upstream: 
            ordered_indices = 
              create_downstream_cell_ordering(dof_handler, 
                                              -1.0 * advection_direction); 
            break; 

          case Settings::DoFRenumberingStrategy::random: 
            ordered_indices = create_random_cell_ordering(dof_handler); 
            break; 

          case Settings::DoFRenumberingStrategy::none: 
            ordered_indices.resize(n_active_cells); 
            for (unsigned int i = 0; i < n_active_cells; ++i) 
              ordered_indices[i] = i; 
            break; 

          default: 
            AssertThrow(false, ExcNotImplemented()); 
            break; 
        } 

      for (unsigned int i = 0; i < n_active_cells; ++i) 
        cell_indices(ordered_indices[i]) = static_cast<double>(i); 
    } 

// 考虑到以前的教程程序，该函数的其余部分就很简单了。

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 
    data_out.add_data_vector(cell_indices, "cell_index"); 
    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(cycle) + ".vtu"; 
    std::ofstream output(filename.c_str()); 
    data_out.write_vtu(output); 
  } 
// @sect4{<code>AdvectionProblem::run()</code>}  

// 和大多数教程一样，这个函数创建/细化网格并调用上面定义的各种函数来设置、装配、求解和输出结果。

// 在第0个循环中，我们在正方形 <code>[-1,1]^dim</code> 上生成网格，半径为3/10个单位的孔以原点为中心。对于`manifold_id`等于1的对象（即与洞相邻的面），我们指定了一个球形流形。

  template <int dim> 
  void AdvectionProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < (settings.fe_degree == 1 ? 7 : 5); 
         ++cycle) 
      { 
        std::cout << "  Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 
                                                            0.3, 
                                                            1.0); 

            const SphericalManifold<dim> manifold_description(Point<dim>(0, 0)); 
            triangulation.set_manifold(1, manifold_description); 
          } 

        triangulation.refine_global(); 

        setup_system(); 

        std::cout << "     Number of active cells:       " 
                  << triangulation.n_active_cells() << " (" 
                  << triangulation.n_levels() << " levels)" << std::endl; 
        std::cout << "     Number of degrees of freedom: " 
                  << dof_handler.n_dofs() << std::endl; 

        assemble_system_and_multigrid(); 

        solve(); 

        if (settings.output) 
          output_results(cycle); 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step63 
// @sect3{The <code>main</code> function}  

// 最后，主函数和大多数教程一样。唯一有趣的一点是，我们要求用户传递一个`.prm`文件作为唯一的命令行参数。如果没有给出参数文件，程序将在屏幕上输出一个带有所有默认值的样本参数文件的内容，然后用户可以复制并粘贴到自己的`.prm`文件中。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      Step63::Settings settings; 
      settings.get_parameters((argc > 1) ? (argv[1]) : ""); 

      Step63::AdvectionProblem<2> advection_problem_2d(settings); 
      advection_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-65.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2019 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * This tutorial program was contributed by Martin Kronbichler 
 */ 


// @sect3{Include files}  

// 本教程的包含文件与  step-6  中的基本相同。重要的是，我们将使用的TransfiniteInterpolationManifold类是由`deal.II/grid/manifold_lib.h`提供。

#include <deal.II/base/timer.h> 

#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/manifold_lib.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_q_generic.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/vector_tools.h> 

#include <fstream> 

// 唯一的新include文件是MappingQCache类的文件。

#include <deal.II/fe/mapping_q_cache.h> 

namespace Step65 
{ 
  using namespace dealii; 
// @sect3{Analytical solution and coefficient}  

// 在这个教程程序中，我们要解决泊松方程，其系数沿半径为0.5的球体跳跃，并使用一个恒定的右手边值 $f(\mathbf{x}) = -3$  。（这个设置与 step-5 和 step-6 相似，但系数和右手边的具体数值不同）。由于系数的跳跃，分析解必须有一个结点，即系数从一个值切换到另一个值。为了保持简单，我们选择了一个在所有分量中都是二次的分析解，即在半径为0.5的球中为 $u(x,y,z) = x^2 + y^2 + z^2$ ，在域的外部为 $u(x,y,z) = 0.1(x^2 + y^2 + z^2) + 0.25-0.025$ 。这个分析解在内球的系数为0.5，外球的系数为5的情况下与右手边兼容。它也是沿着半径为0.5的圆连续的。

  template <int dim> 
  class ExactSolution : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/ = 0) const override 
    { 
      if (p.norm_square() < 0.25) 
        return p.norm_square(); 
      else 
        return 0.1 * p.norm_square() + (0.25 - 0.025); 
    } 

    virtual Tensor<1, dim> 
    gradient(const Point<dim> &p, 
             const unsigned int /*component*/ = 0) const override 
    { 
      if (p.norm_square() < 0.25) 
        return 2. * p; 
      else 
        return 0.2 * p; 
    } 
  }; 

  template <int dim> 
  double coefficient(const Point<dim> &p) 
  { 
    if (p.norm_square() < 0.25) 
      return 0.5; 
    else 
      return 5.0; 
  } 

//  @sect3{The PoissonProblem class}  

// 泊松问题的实现与我们在  step-5  教程中使用的非常相似。两个主要的区别是，我们向程序中的各个步骤传递了一个映射对象，以便在两种映射表示法之间进行切换，正如介绍中所解释的那样，还有一个`计时器'对象（TimerOutput类型），将用于测量各种情况下的运行时间。(映射对象的概念在 step-10 和 step-11 中首次提出，如果你想查一下这些类的用途的话)。

  template <int dim> 
  class PoissonProblem 
  { 
  public: 
    PoissonProblem(); 
    void run(); 

  private: 
    void create_grid(); 
    void setup_system(const Mapping<dim> &mapping); 
    void assemble_system(const Mapping<dim> &mapping); 
    void solve(); 
    void postprocess(const Mapping<dim> &mapping); 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> constraints; 
    SparsityPattern           sparsity_pattern; 
    SparseMatrix<double>      system_matrix; 
    Vector<double>            solution; 
    Vector<double>            system_rhs; 

    TimerOutput timer; 
  }; 

// 在构造函数中，我们设置了定时器对象来记录墙的时间，但在正常执行过程中是安静的。我们将在 `PoissonProblem::run()` 函数中查询它的计时细节。此外，我们为正在使用的有限元选择了一个相对较高的多项式三度。

  template <int dim> 
  PoissonProblem<dim>::PoissonProblem() 
    : fe(3) 
    , dof_handler(triangulation) 
    , timer(std::cout, TimerOutput::never, TimerOutput::wall_times) 
  {} 

//  @sect3{Grid creation and initialization of the manifolds}  

// 接下来的函数介绍了TransfiniteInterpolationManifold的典型用法。第一步是创建所需的网格，这可以通过GridGenerator的两个网格的组合来完成。内球网格是很简单的。我们以原点为中心运行 GridGenerator::hyper_cube() ，半径为0.5（第三个函数参数）。第二个网格更有趣，构建方法如下。我们希望有一个在内部是球形的，但在外表面是平的网格。此外，内球的网格拓扑结构应该与外球的网格兼容，即它们的顶点重合，这样才能使两个网格合并起来。从 GridGenerator::hyper_shell 出来的网格满足了内侧的要求，如果它是用 $2d$ 的粗大单元创建的（在3D中我们将使用6个粗大单元）&ndash；这与球的边界面的单元数量相同。对于外表面，我们利用这样一个事实：没有流形附着的壳表面的6个面将退化为立方体的表面。我们仍然缺少的是外壳边界的半径。由于我们想要一个范围为 $[-1, 1]$ 的立方体，而6单元壳将其8个外顶点放在8条对角线上，我们必须将点 $(\pm 1, \pm 1, \pm 1)$ 转化为半径。显然，在 $d$ 维度上，半径必须是 $\sqrt{d}$ ，也就是说，对于我们要考虑的三维情况，半径是 $\sqrt{3}$ 。

// 这样，我们就有了一个计划。在创建了球的内部三角形和外壳的三角形之后，我们将这两个网格合并，但是将GridGenerator中的函数可能从产生的三角形中设置的所有流形移除，以确保我们对流形有充分的控制。特别是，我们希望在细化过程中在边界上添加的额外点能够遵循平坦的流形描述。为了开始添加更合适的流形ID的过程，我们给所有的网格实体（单元、面、线）分配流形ID 0，这些实体以后将与TransfiniteInterpolationManifold相关联。然后，我们必须识别沿着半径为0.5的球体的面和线，并给它们标记一个不同的流形ID，以便随后给这些面和线分配一个SphericalManifold。由于我们在调用 GridGenerator::hyper_ball(), 后丢弃了所有预先存在的流形，我们手动检查了网格的单元格和所有的面。如果四个顶点的半径都是0.5，我们就在球体上找到了一个面，或者像我们在程序中写的那样，有  $r^2-0.25 \approx 0$  。注意，我们调用`cell->face(f)->set_all_manifold_ids(1)`来设置面和周围线上的流形id。此外，我们希望通过一个材料ID来区分球内和球外的单元，以便于可视化，对应于介绍中的图片。

  template <int dim> 
  void PoissonProblem<dim>::create_grid() 
  { 
    Triangulation<dim> tria_inner; 
    GridGenerator::hyper_ball(tria_inner, Point<dim>(), 0.5); 

    Triangulation<dim> tria_outer; 
    GridGenerator::hyper_shell( 
      tria_outer, Point<dim>(), 0.5, std::sqrt(dim), 2 * dim); 

    GridGenerator::merge_triangulations(tria_inner, tria_outer, triangulation); 

    triangulation.reset_all_manifolds(); 
    triangulation.set_all_manifold_ids(0); 

    for (const auto &cell : triangulation.cell_iterators()) 
      { 
        for (const auto &face : cell->face_iterators()) 
          { 
            bool face_at_sphere_boundary = true; 
            for (const auto v : face->vertex_indices()) 
              { 
                if (std::abs(face->vertex(v).norm_square() - 0.25) > 1e-12) 
                  face_at_sphere_boundary = false; 
              } 
            if (face_at_sphere_boundary) 
              face->set_all_manifold_ids(1); 
          } 
        if (cell->center().norm_square() < 0.25) 
          cell->set_material_id(1); 
        else 
          cell->set_material_id(0); 
      } 

// 有了所有单元格、面和线的适当标记，我们可以将流形对象附加到这些数字上。流形ID为1的实体将得到一个球形流形，而流形ID为0的其他实体将被分配到TransfiniteInterpolationManifold。正如介绍中提到的，我们必须通过调用 TransfiniteInterpolationManifold::initialize() 显式初始化当前网格的流形，以获取粗略的网格单元和连接到这些单元边界的流形。我们还注意到，我们在这个函数中本地创建的流形对象是允许超出范围的（就像它们在函数范围结束时那样），因为Triangulation对象在内部复制它们。

// 在连接了所有的流形之后，我们最后将去细化网格几次，以创建一个足够大的测试案例。

    triangulation.set_manifold(1, SphericalManifold<dim>()); 

    TransfiniteInterpolationManifold<dim> transfinite_manifold; 
    transfinite_manifold.initialize(triangulation); 
    triangulation.set_manifold(0, transfinite_manifold); 

    triangulation.refine_global(9 - 2 * dim); 
  } 

//  @sect3{Setup of data structures}  

// 下面的函数在其他教程中是众所周知的，它枚举了自由度，创建了一个约束对象并为线性系统设置了一个稀疏矩阵。唯一值得一提的是，该函数接收了一个映射对象的引用，然后我们将其传递给 VectorTools::interpolate_boundary_values() 函数，以确保我们的边界值在用于装配的高阶网格上被评估。在本例中，这并不重要，因为外表面是平的，但对于弯曲的外单元，这将导致边界值的更精确的近似。

  template <int dim> 
  void PoissonProblem<dim>::setup_system(const Mapping<dim> &mapping) 
  { 
    dof_handler.distribute_dofs(fe); 
    std::cout << "   Number of active cells:       " 
              << triangulation.n_global_active_cells() << std::endl; 
    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
              << std::endl; 

    { 
      TimerOutput::Scope scope(timer, "Compute constraints"); 

      constraints.clear(); 

      DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
      VectorTools::interpolate_boundary_values( 
        mapping, dof_handler, 0, ExactSolution<dim>(), constraints); 

      constraints.close(); 
    } 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); 

    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 
// @sect3{Assembly of the system matrix and right hand side}  

// 组装线性系统的函数在前面的教程程序中也是众所周知的。有一点需要注意的是，我们将正交点的数量设置为多项式的度数加2，而不是像其他大多数教程中的度数加1。这是因为我们期望有一些额外的精度，因为映射也涉及到比解的多项式多一度的程度。

// 汇编中唯一有点不寻常的代码是我们计算单元格矩阵的方式。我们没有使用正交点索引、行和矩阵列的三个嵌套循环，而是首先收集形状函数的导数，乘以系数和积分因子`JxW`的乘积的平方根，放在一个单独的矩阵`partial_matrix`中。为了计算单元矩阵，我们在 "partial_matrix.mTmult(cell_matrix, partial_matrix); "一行中执行 "cell_matrix = partial_matrix * transpose(partial_matrix)"。为了理解这一点，我们要知道矩阵与矩阵的乘法是对`partial_matrix`的各列进行求和。如果我们用 
// $a(\mathbf{x}_q)$ 表示系数，临时矩阵的条目是 $\sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol
//  \xi_q)}{\partial x_k}$ 。如果我们将该矩阵的第<i>i</i>行与第<i>j</i>列相乘，我们计算出一个涉及 $\sum_q \sum_{k=1}^d \sqrt{\text{det}(J) w_q a(x)} \frac{\partial
//  \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \sqrt{\text{det}(J) w_q a(x)}
//  \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k} = \sum_q
//  \sum_{k=1}^d\text{det}(J) w_q a(x)\frac{\partial \varphi_i(\boldsymbol
//  \xi_q)}{\partial x_k} \frac{\partial \varphi_j(\boldsymbol
//  \xi_q)}{\partial x_k}$ 的嵌套和，这正是拉普拉斯方程的双线性形式所需的条款。

// 选择这种有点不寻常的方案的原因是由于计算三维中相对较高的多项式程度的单元矩阵所涉及的繁重工作。由于我们想在这个教程程序中强调映射的成本，我们最好以优化的方式进行装配，以便不追逐已经被社区解决的瓶颈。矩阵-矩阵乘法是HPC背景下最好的优化内核之一， FullMatrix::mTmult() 函数将调用到那些优化的BLAS函数。如果用户在配置deal.II时提供了一个好的BLAS库（如OpenBLAS或英特尔的MKL），那么单元矩阵的计算将执行到接近处理器的峰值算术性能。顺便提一下，尽管有优化的矩阵-矩阵乘法，但目前的策略在复杂性方面是次优的，因为要做的工作与 $(p+1)^9$ 度 $p$ 的运算成正比（这也适用于用FEValues的通常评估）。我们可以通过利用形状函数的张量乘积结构，用 $\mathcal O((p+1)^7)$ 的操作来计算单元格矩阵，就像交易二中的无矩阵框架那样。我们参考 step-37 和张量积感知评估器FEEvaluation的文档，以了解如何实现更有效的单元矩阵计算的细节。

  template <int dim> 
  void PoissonProblem<dim>::assemble_system(const Mapping<dim> &mapping) 
  { 
    TimerOutput::Scope scope(timer, "Assemble linear system"); 

    const QGauss<dim> quadrature_formula(fe.degree + 2); 
    FEValues<dim>     fe_values(mapping, 
                            fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 
    FullMatrix<double> partial_matrix(dofs_per_cell, dim * n_q_points); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_rhs = 0.; 
        fe_values.reinit(cell); 

        for (unsigned int q_index = 0; q_index < n_q_points; ++q_index) 
          { 
            const double current_coefficient = 
              coefficient(fe_values.quadrature_point(q_index)); 
            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              { 
                for (unsigned int d = 0; d < dim; ++d) 
                  partial_matrix(i, q_index * dim + d) = 
                    std::sqrt(fe_values.JxW(q_index) * current_coefficient) * 
                    fe_values.shape_grad(i, q_index)[d]; 
                cell_rhs(i) += 
                  (fe_values.shape_value(i, q_index) * // phi_i(x_q) 
                   (-dim) *                            // f(x_q) 
                   fe_values.JxW(q_index));            // dx 
              } 
          } 

        partial_matrix.mTmult(cell_matrix, partial_matrix); 

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global( 
          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); 
      } 
  } 

//  @sect3{Solution of the linear system}  

// 对于线性系统的求解，我们选择一个简单的雅可比条件共轭梯度求解器，类似于早期教程中的设置。

  template <int dim> 
  void PoissonProblem<dim>::solve() 
  { 
    TimerOutput::Scope scope(timer, "Solve linear system"); 

    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> solver(solver_control); 

    PreconditionJacobi<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix); 

    solver.solve(system_matrix, solution, system_rhs, preconditioner); 
    constraints.distribute(solution); 

    std::cout << "   Number of solver iterations:  " 
              << solver_control.last_step() << std::endl; 
  } 

//  @sect3{Output of the solution and computation of errors}  

// 在下一个函数中，我们对解决方案做了各种后处理步骤，所有这些步骤都以这种或那种方式涉及映射。

// 我们做的第一个操作是把解决方案以及材料ID写到VTU文件中。这与其他许多教程程序中的做法类似。这个教程程序中提出的新内容是，我们要确保写到文件中用于可视化的数据实际上是deal.II内部使用的数据的忠实代表。这是因为大多数可视化数据格式只用顶点坐标表示单元，但没有办法表示deal.II中使用高阶映射时的曲线边界--换句话说，你在可视化工具中看到的东西实际上不是你正在计算的东西。顺带一提，在使用高阶形状函数时也是如此。大多数可视化工具只呈现双线性/三线性的表示。这在 DataOut::build_patches().) 中有详细的讨论。

// 所以我们需要确保高阶表示被写入文件中。我们需要考虑两个特别的话题。首先，我们通过 DataOutBase::VtkFlags 告诉DataOut对象，我们打算把元素的细分解释为高阶拉格朗日多项式，而不是双线性补丁的集合。最近的可视化程序，如ParaView 5.5版或更新的程序，然后可以呈现高阶解决方案（更多细节见<a
//  href="https:github.com/dealii/dealii/wiki/Notes-on-visualizing-high-order-output">wiki
//  page</a>）。其次，我们需要确保映射被传递给 DataOut::build_patches() 方法。最后，DataOut类默认只打印<i>boundary</i>单元的曲面，所以我们需要确保通过映射将内部单元也打印成曲面。

  template <int dim> 
  void PoissonProblem<dim>::postprocess(const Mapping<dim> &mapping) 
  { 
    { 
      TimerOutput::Scope scope(timer, "Write output"); 

      DataOut<dim> data_out; 

      DataOutBase::VtkFlags flags; 
      flags.write_higher_order_cells = true; 
      data_out.set_flags(flags); 

      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution, "solution"); 

      Vector<double> material_ids(triangulation.n_active_cells()); 
      for (const auto &cell : triangulation.active_cell_iterators()) 
        material_ids[cell->active_cell_index()] = cell->material_id(); 
      data_out.add_data_vector(material_ids, "material_ids"); 

      data_out.build_patches(mapping, 
                             fe.degree, 
                             DataOut<dim>::curved_inner_cells); 

      std::ofstream file( 
        ("solution-" + 
         std::to_string(triangulation.n_global_levels() - 10 + 2 * dim) + 
         ".vtu") 
          .c_str()); 

      data_out.write_vtu(file); 
    } 

// 后处理函数的下一个操作是对照分析解计算 $L_2$ 和 $H^1$ 误差。由于分析解是一个二次多项式，我们期望在这一点上得到一个非常准确的结果。如果我们是在一个具有平面面的简单网格上求解，并且系数的跳动与单元间的面对齐，那么我们会期望数值结果与分析解相吻合，直至舍去精度。然而，由于我们使用的是跟随球体的变形单元，这些单元只能由4度的多项式跟踪（比有限元的度数多一个），我们会发现在 $10^{-7}$ 附近有一个误差。我们可以通过增加多项式的度数或细化网格来获得更多的精度。

    { 
      TimerOutput::Scope scope(timer, "Compute error norms"); 

      Vector<double> norm_per_cell_p(triangulation.n_active_cells()); 

      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        ExactSolution<dim>(), 
                                        norm_per_cell_p, 
                                        QGauss<dim>(fe.degree + 2), 
                                        VectorTools::L2_norm); 
      std::cout << "   L2 error vs exact solution:   " 
                << norm_per_cell_p.l2_norm() << std::endl; 

      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        ExactSolution<dim>(), 
                                        norm_per_cell_p, 
                                        QGauss<dim>(fe.degree + 2), 
                                        VectorTools::H1_norm); 
      std::cout << "   H1 error vs exact solution:   " 
                << norm_per_cell_p.l2_norm() << std::endl; 
    } 

// 我们在这里做的最后一个后处理操作是用KellyErrorEstimator计算出一个误差估计。我们使用了与 step-6 教程程序中完全相同的设置，只是我们还交出了映射，以确保误差是沿着曲线元素评估的，与程序的其余部分一致。然而，我们并没有真正使用这里的结果来驱动网格适应步骤（会沿着球体细化材料界面周围的网格），因为这里的重点是这个操作的成本。

    { 
      TimerOutput::Scope scope(timer, "Compute error estimator"); 

      Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 
      KellyErrorEstimator<dim>::estimate( 
        mapping, 
        dof_handler, 
        QGauss<dim - 1>(fe.degree + 1), 
        std::map<types::boundary_id, const Function<dim> *>(), 
        solution, 
        estimated_error_per_cell); 
      std::cout << "   Max cell-wise error estimate: " 
                << estimated_error_per_cell.linfty_norm() << std::endl; 
    } 
  } 

//  @sect3{The PoissonProblem::run() function}  

// 最后，我们定义了`run()`函数，控制我们如何执行这个程序（由main()函数以常规方式调用）。我们首先调用`create_grid()`函数，用适当的流形设置我们的几何体。然后我们运行两个求解器链的实例，从方程的设置开始，组装线性系统，用一个简单的迭代求解器求解，以及上面讨论的后处理。这两个实例在使用映射的方式上有所不同。第一个使用传统的MappingQGeneric映射对象，我们将其初始化为比有限元多一级的程度；毕竟，我们期望几何表示是瓶颈，因为分析解只是二次多项式。实际上，事情在相当程度上是相互关联的，因为实坐标中多项式的评估涉及到高阶多项式的映射，而高阶多项式代表一些光滑的有理函数。因此，高阶多项式还是有回报的，所以进一步增加映射的度数是没有意义的)。一旦第一遍完成，我们就让定时器打印出各个阶段的计算时间的摘要。

  template <int dim> 
  void PoissonProblem<dim>::run() 
  { 
    create_grid(); 

    { 
      std::cout << std::endl 
                << "====== Running with the basic MappingQGeneric class ====== " 
                << std::endl 
                << std::endl; 

      MappingQGeneric<dim> mapping(fe.degree + 1); 
      setup_system(mapping); 
      assemble_system(mapping); 
      solve(); 
      postprocess(mapping); 

      timer.print_summary(); 
      timer.reset(); 
    } 

// 对于第二个实例，我们转而设置了MappingQCache类。它的使用非常简单。在构建好它之后（考虑到我们希望它在其他情况下显示正确的度数功能，所以用度数），我们通过 MappingQCache::initialize() 函数填充缓存。在这个阶段，我们为缓存指定我们想要使用的映射（很明显，与之前的MappingQGeneric相同，以便重复相同的计算），然后再次运行相同的函数，现在交出修改后的映射。最后，我们再次打印重置后的累计壁挂时间，看看这些时间与原来的设置相比如何。

    { 
      std::cout 
        << "====== Running with the optimized MappingQCache class ====== " 
        << std::endl 
        << std::endl; 

      MappingQCache<dim> mapping(fe.degree + 1); 
      { 
        TimerOutput::Scope scope(timer, "Initialize mapping cache"); 
        mapping.initialize(MappingQGeneric<dim>(fe.degree + 1), triangulation); 
      } 
      std::cout << "   Memory consumption cache:     " 
                << 1e-6 * mapping.memory_consumption() << " MB" << std::endl; 

      setup_system(mapping); 
      assemble_system(mapping); 
      solve(); 
      postprocess(mapping); 

      timer.print_summary(); 
    } 
  } 
} // namespace Step65 

int main() 
{ 
  Step65::PoissonProblem<3> test_program; 
  test_program.run(); 
  return 0; 
} 


CCTest_file/step-66.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Fabian Castelli, Karlsruhe Institute of Technology (KIT) 
 */ 



// 首先我们包括本教程所需的deal.II库的典型头文件。

#include <deal.II/base/function.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/vectorization.h> 

#include <deal.II/dofs/dof_accessor.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/mapping_q_generic.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/manifold_lib.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/tria_accessor.h> 
#include <deal.II/grid/tria_iterator.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 特别是，我们需要包括无矩阵框架的头文件。

#include <deal.II/matrix_free/fe_evaluation.h> 
#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/operators.h> 
#include <deal.II/matrix_free/tools.h> 

// 由于我们要使用几何多网格预处理程序，所以我们还需要多级头文件。

#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_constrained_dofs.h> 
#include <deal.II/multigrid/mg_matrix.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_transfer_matrix_free.h> 
#include <deal.II/multigrid/multigrid.h> 

// 最后是一些常用的C++头文件，用于输入和输出。

#include <fstream> 
#include <iostream> 

namespace Step66 
{ 
  using namespace dealii; 

//  @sect3{Matrix-free JacobianOperator}  

// 在开始时，我们定义了雅各布系数的无矩阵算子。作为指导，我们遵循教程  step-37  和  step-48  ，其中广泛记录了  MatrixFreeOperators::Base  类的精确接口。

// 由于我们希望将雅各布（Jacobian）作为系统矩阵使用，并将其传递给线性求解器以及多级预处理类，我们从 MatrixFreeOperators::Base 类派生出 <code>JacobianOperator</code> 类，这样我们就有了正确的接口。我们需要从基类中覆盖的两个函数是 MatrixFreeOperators::Base::apply_add() 和 MatrixFreeOperators::Base::compute_diagonal() 函数。为了允许用浮动精度进行预处理，我们将数字类型定义为模板参数。

// 正如在介绍中提到的，我们需要在最后一个牛顿步骤 $u_h^n$ 中评估雅各布 $F'$ ，以便计算牛顿更新 $s_h^n$ 。为了获得最后一个牛顿步骤 $u_h^n$ 的信息，我们的做法与 step-37 基本相同，在使用无矩阵算子之前，我们将一个系数函数的值存储在一个表中 <code>nonlinear_values</code> 。我们在这里实现的不是一个函数  <code>evaluate_coefficient()</code>  ，而是一个函数  <code>evaluate_newton_step()</code>  。

// 作为 <code>JacobianOperator</code> 的额外私有成员函数，我们实现了 <code>local_apply()</code> 和 <code>local_compute_diagonal()</code> 函数。第一个是矩阵-向量应用的实际工作函数，我们在 <code>apply_add()</code> 函数中将其传递给 MatrixFree::cell_loop() 。后面一个是计算对角线的工作函数，我们把它传递给 MatrixFreeTools::compute_diagonal() 函数。

// 为了提高源代码的可读性，我们进一步为FEEvaluation对象定义了一个别名。

  template <int dim, int fe_degree, typename number> 
  class JacobianOperator 
    : public MatrixFreeOperators:: 
        Base<dim, LinearAlgebra::distributed::Vector<number>> 
  { 
  public: 
    using value_type = number; 

    using FECellIntegrator = 
      FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number>; 

    JacobianOperator(); 

    virtual void clear() override; 

    void evaluate_newton_step( 
      const LinearAlgebra::distributed::Vector<number> &newton_step); 

    virtual void compute_diagonal() override; 

  private: 
    virtual void apply_add( 
      LinearAlgebra::distributed::Vector<number> &      dst, 
      const LinearAlgebra::distributed::Vector<number> &src) const override; 

    void 
    local_apply(const MatrixFree<dim, number> &                   data, 
                LinearAlgebra::distributed::Vector<number> &      dst, 
                const LinearAlgebra::distributed::Vector<number> &src, 
                const std::pair<unsigned int, unsigned int> &cell_range) const; 

    void local_compute_diagonal(FECellIntegrator &integrator) const; 

    Table<2, VectorizedArray<number>> nonlinear_values; 
  }; 

//  <code>JacobianOperator</code> 的构造函数只是调用基类 MatrixFreeOperators::Base, 的构造函数，而基类本身就是派生于Subscriptor类。

  template <int dim, int fe_degree, typename number> 
  JacobianOperator<dim, fe_degree, number>::JacobianOperator() 
    : MatrixFreeOperators::Base<dim, 
                                LinearAlgebra::distributed::Vector<number>>() 
  {} 

//  <code>clear()</code> 函数重置了保存非线性值的表格，并调用基类的 <code>clear()</code> 函数。

  template <int dim, int fe_degree, typename number> 
  void JacobianOperator<dim, fe_degree, number>::clear() 
  { 
    nonlinear_values.reinit(0, 0); 
    MatrixFreeOperators::Base<dim, LinearAlgebra::distributed::Vector<number>>:: 
      clear(); 
  } 

//  @sect4{Evaluation of the old Newton step}  

// 下面的  <code>evaluate_newton_step()</code>  函数是基于  step-37  的  <code>evaluate_coefficient()</code>  函数。然而，它并不评估一个函数对象，而是评估一个代表有限元函数的向量，即雅各布系数所需的最后一个牛顿步骤。因此，我们设置了一个FEEvaluation对象，用 FEEvaluation::read_dof_values_plain() 和 FEEvaluation::evaluate() 函数评估正交点的有限元函数。我们将有限元函数的评估值直接存储在 <code>nonlinear_values</code> 表中。

//这样做会很好，在 <code>local_apply()</code> 函数中我们可以使用存储在表中的值来应用矩阵-向量乘积。然而，我们也可以在这个阶段优化雅各布系数的实现。我们可以直接评估非线性函数 <code>std::exp(newton_step[q])</code> 并将这些值存储在表中。这就跳过了在每次调用 <code>vmult()</code> 函数时对非线性的所有评估。

  template <int dim, int fe_degree, typename number> 
  void JacobianOperator<dim, fe_degree, number>::evaluate_newton_step( 
    const LinearAlgebra::distributed::Vector<number> &newton_step) 
  { 
    const unsigned int n_cells = this->data->n_cell_batches(); 
    FECellIntegrator   phi(*this->data); 

    nonlinear_values.reinit(n_cells, phi.n_q_points); 

    for (unsigned int cell = 0; cell < n_cells; ++cell) 
      { 
        phi.reinit(cell); 
        phi.read_dof_values_plain(newton_step); 
        phi.evaluate(EvaluationFlags::values); 

        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            nonlinear_values(cell, q) = std::exp(phi.get_value(q)); 
          } 
      } 
  } 

//  @sect4{Nonlinear matrix-free operator application}  

// 现在在  <code>local_apply()</code>  函数中，实际上实现了系统矩阵的单元格动作，我们可以使用存储在表  <code>nonlinear_values</code>  中的最后一个牛顿步骤的信息。这个函数的其余部分与  step-37  中的基本相同。我们设置 FEEvaluation 对象，收集并评估输入向量的值和梯度  <code>src</code>  ，根据雅各布的形式提交值和梯度，最后调用  FEEvaluation::integrate_scatter()  进行单元积分，将局部贡献分配到全局向量  <code> dst</code>  。

  template <int dim, int fe_degree, typename number> 
  void JacobianOperator<dim, fe_degree, number>::local_apply( 
    const MatrixFree<dim, number> &                   data, 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src, 
    const std::pair<unsigned int, unsigned int> &     cell_range) const 
  { 
    FECellIntegrator phi(data); 

    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        AssertDimension(nonlinear_values.size(0), 
                        phi.get_matrix_free().n_cell_batches()); 
        AssertDimension(nonlinear_values.size(1), phi.n_q_points); 

        phi.reinit(cell); 

        phi.gather_evaluate(src, 
                            EvaluationFlags::values | 
                              EvaluationFlags::gradients); 

        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q); 
            phi.submit_gradient(phi.get_gradient(q), q); 
          } 

        phi.integrate_scatter(EvaluationFlags::values | 
                                EvaluationFlags::gradients, 
                              dst); 
      } 
  } 

// 接下来我们使用 MatrixFree::cell_loop() 对所有单元进行实际循环，计算单元对矩阵-向量积的贡献。

  template <int dim, int fe_degree, typename number> 
  void JacobianOperator<dim, fe_degree, number>::apply_add( 
    LinearAlgebra::distributed::Vector<number> &      dst, 
    const LinearAlgebra::distributed::Vector<number> &src) const 
  { 
    this->data->cell_loop(&JacobianOperator::local_apply, this, dst, src); 
  } 

//  @sect4{Diagonal of the JacobianOperator}  

// 用于计算对角线的内部工作函数  <code>local_compute_diagonal()</code>  与上述工作函数  <code>local_apply()</code>  类似。然而，作为主要区别，我们不从输入向量中读取数值，也不将任何局部结果分配给输出向量。相反，唯一的输入参数是使用的FEEvaluation对象。

  template <int dim, int fe_degree, typename number> 
  void JacobianOperator<dim, fe_degree, number>::local_compute_diagonal( 
    FECellIntegrator &phi) const 
  { 
    AssertDimension(nonlinear_values.size(0), 
                    phi.get_matrix_free().n_cell_batches()); 
    AssertDimension(nonlinear_values.size(1), phi.n_q_points); 

    const unsigned int cell = phi.get_current_cell_index(); 

    phi.evaluate(EvaluationFlags::values | EvaluationFlags::gradients); 

    for (unsigned int q = 0; q < phi.n_q_points; ++q) 
      { 
        phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q); 
        phi.submit_gradient(phi.get_gradient(q), q); 
      } 

    phi.integrate(EvaluationFlags::values | EvaluationFlags::gradients); 
  } 

// 最后我们覆盖  MatrixFreeOperators::Base::compute_diagonal()  的基类的  <code>JacobianOperator</code>  的函数。虽然这个函数的名字表明只是计算对角线，但这个函数的作用更大。因为我们实际上只需要矩阵对角线元素的逆值，用于多网格预处理器的切比雪夫平滑器，我们计算对角线并存储逆值元素。因此我们首先初始化 <code>inverse_diagonal_entries</code>  。然后我们通过将工作函数 <code>local_compute_diagonal()</code> 传递给 MatrixFreeTools::compute_diagonal() 函数来计算对角线。最后，我们在对角线上循环，用手反转这些元素。注意，在这个循环过程中，我们捕捉受限的DOF，并手动将其设置为1。

  template <int dim, int fe_degree, typename number> 
  void JacobianOperator<dim, fe_degree, number>::compute_diagonal() 
  { 
    this->inverse_diagonal_entries.reset( 
      new DiagonalMatrix<LinearAlgebra::distributed::Vector<number>>()); 
    LinearAlgebra::distributed::Vector<number> &inverse_diagonal = 
      this->inverse_diagonal_entries->get_vector(); 
    this->data->initialize_dof_vector(inverse_diagonal); 

    MatrixFreeTools::compute_diagonal(*this->data, 
                                      inverse_diagonal, 
                                      &JacobianOperator::local_compute_diagonal, 
                                      this); 

    for (auto &diagonal_element : inverse_diagonal) 
      { 
        diagonal_element = (std::abs(diagonal_element) > 1.0e-10) ? 
                             (1.0 / diagonal_element) : 
                             1.0; 
      } 
  } 

//  @sect3{GelfandProblem class}  

// 在实现了无矩阵运算符之后，我们现在可以为<i>Gelfand problem</i>定义求解器类。这个类是基于之前所有教程程序的共同结构，特别是它是基于 step-15 ，解决的也是一个非线性问题。由于我们使用的是无矩阵框架，所以我们不再需要assemble_system函数，相反，在每次调用 <code>vmult()</code> 函数时都会重建矩阵的信息。然而，对于牛顿方案的应用，我们需要组装线性化问题的右手边并计算残差。因此，我们实现了一个额外的函数 <code>evaluate_residual()</code> ，后来我们在 <code>assemble_rhs()</code> and the <code>compute_residual()</code> 函数中调用了它。最后，这里典型的 <code>solve()</code> 函数实现了牛顿方法，而线性化系统的解是在 <code>compute_update()</code> 函数中计算的。由于MatrixFree框架将拉格朗日有限元方法的多项式程度作为一个模板参数来处理，我们也将其作为问题求解器类的模板参数来声明。

  template <int dim, int fe_degree> 
  class GelfandProblem 
  { 
  public: 
    GelfandProblem(); 

    void run(); 

  private: 
    void make_grid(); 

    void setup_system(); 

    void evaluate_residual( 
      LinearAlgebra::distributed::Vector<double> &      dst, 
      const LinearAlgebra::distributed::Vector<double> &src) const; 

    void local_evaluate_residual( 
      const MatrixFree<dim, double> &                   data, 
      LinearAlgebra::distributed::Vector<double> &      dst, 
      const LinearAlgebra::distributed::Vector<double> &src, 
      const std::pair<unsigned int, unsigned int> &     cell_range) const; 

    void assemble_rhs(); 

    double compute_residual(const double alpha); 

    void compute_update(); 

    void solve(); 

    double compute_solution_norm() const; 

    void output_results(const unsigned int cycle) const; 

// 对于并行计算，我们定义了一个  parallel::distributed::Triangulation.  由于计算域在二维是一个圆，在三维是一个球，我们除了为边界单元分配SphericalManifold外，还为内部单元的映射分配了一个TransfiniteInterpolationManifold对象，它负责处理内部单元的映射。在这个例子中，我们使用了一个等参数的有限元方法，因此使用了MappingQGeneric类。注意，我们也可以创建一个MappingQ类的实例，并在构造函数调用中设置 <code>use_mapping_q_on_all_cells</code> 标志为 <code>true</code>  。关于MappingQ和MappingQGeneric连接的进一步细节，你可以阅读这些类的详细描述。

    parallel::distributed::Triangulation<dim> triangulation; 
    const MappingQGeneric<dim>                mapping; 

// 像往常一样，我们接着定义拉格朗日有限元FE_Q和一个DoFHandler。

    FE_Q<dim>       fe; 
    DoFHandler<dim> dof_handler; 

// 对于线性化的离散系统，我们定义一个AffineConstraints对象和 <code>system_matrix</code>  ，在本例中它被表示为一个无矩阵算子。

    AffineConstraints<double> constraints; 
    using SystemMatrixType = JacobianOperator<dim, fe_degree, double>; 
    SystemMatrixType system_matrix; 

// 多级对象也是基于雅各布系数的无矩阵算子。由于我们需要用最后一个牛顿步骤来评估雅各布，所以我们也需要用最后一个牛顿步骤来评估预处理器的水平算子。因此，除了 <code>mg_matrices</code> 之外，我们还需要一个MGLevelObject来存储每一级的插值解向量。与 step-37 一样，我们对预处理程序使用浮点精度。此外，我们将MGTransferMatrixFree对象定义为一个类变量，因为我们只需要在三角形变化时设置一次，然后可以在每个牛顿步骤中再次使用它。

    MGConstrainedDoFs mg_constrained_dofs; 
    using LevelMatrixType = JacobianOperator<dim, fe_degree, float>; 
    MGLevelObject<LevelMatrixType>                           mg_matrices; 
    MGLevelObject<LinearAlgebra::distributed::Vector<float>> mg_solution; 
    MGTransferMatrixFree<dim, float>                         mg_transfer; 

// 当然，我们还需要持有  <code>solution</code>  ,  <code>newton_update</code> and the <code>system_rhs</code>  的向量。这样，我们就可以一直将上一个牛顿步存储在解的向量中，只需添加更新就可以得到下一个牛顿步。

    LinearAlgebra::distributed::Vector<double> solution; 
    LinearAlgebra::distributed::Vector<double> newton_update; 
    LinearAlgebra::distributed::Vector<double> system_rhs; 

// 最后我们有一个变量，用来表示线性求解器的迭代次数。

    unsigned int linear_iterations; 

// 对于与MPI并行运行的程序中的输出，我们使用ConditionalOStream类来避免不同MPI等级对同一数据的多次输出。

    ConditionalOStream pcout; 

// 最后，对于时间测量，我们使用一个TimerOutput对象，它在程序结束后将每个函数的耗时CPU和墙体时间打印在一个格式良好的表格中。

    TimerOutput computing_timer; 
  }; 

//  <code>GelfandProblem</code> 的构造函数初始化了类的变量。特别是，我们为 parallel::distributed::Triangulation, 设置了多级支持，将映射度设为有限元度，初始化ConditionalOStream，并告诉TimerOutput，我们只想在需求时看到墙体时间。

  template <int dim, int fe_degree> 
  GelfandProblem<dim, fe_degree>::GelfandProblem() 
    : triangulation(MPI_COMM_WORLD, 
                    Triangulation<dim>::limit_level_difference_at_vertices, 
                    parallel::distributed::Triangulation< 
                      dim>::construct_multigrid_hierarchy) 
    , mapping(fe_degree) 
    , fe(fe_degree) 
    , dof_handler(triangulation) 
    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
    , computing_timer(MPI_COMM_WORLD, 
                      pcout, 
                      TimerOutput::never, 
                      TimerOutput::wall_times) 
  {} 

//  @sect4{GelfandProblem::make_grid}  

// 作为计算域，我们使用 <code>dim</code>  -维的单位球。我们按照TransfiniteInterpolationManifold类的说明，也为边界指定了一个SphericalManifold。最后，我们将初始网格细化为3

// -  <code>dim</code> 次全局。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::make_grid() 
  { 
    TimerOutput::Scope t(computing_timer, "make grid"); 

    SphericalManifold<dim>                boundary_manifold; 
    TransfiniteInterpolationManifold<dim> inner_manifold; 

    GridGenerator::hyper_ball(triangulation); 

 
    triangulation.set_all_manifold_ids_on_boundary(0); 

    triangulation.set_manifold(0, boundary_manifold); 

    inner_manifold.initialize(triangulation); 
    triangulation.set_manifold(1, inner_manifold); 

    triangulation.refine_global(3 - dim); 
  } 

//  @sect4{GelfandProblem::setup_system}  

//  <code>setup_system()</code> 函数与  step-37  中的函数基本相同。唯一的区别显然是时间测量只有一个 TimerOutput::Scope ，而不是单独测量每个部分，更重要的是对前一个牛顿步骤的内插解向量的MGLevelObject的初始化。另一个重要的变化是MGTransferMatrixFree对象的设置，我们可以在每个牛顿步骤中重复使用它，因为 <code>triangulation</code> 不会被改变。

// 注意我们如何在 <code>JacobianOperator</code> 和多网格预处理程序中两次使用同一个MatrixFree对象。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::setup_system() 
  { 
    TimerOutput::Scope t(computing_timer, "setup system"); 

    system_matrix.clear(); 
    mg_matrices.clear_elements(); 

    dof_handler.distribute_dofs(fe); 
    dof_handler.distribute_mg_dofs(); 

    IndexSet locally_relevant_dofs; 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 

    constraints.clear(); 
    constraints.reinit(locally_relevant_dofs); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             constraints); 
    constraints.close(); 

    { 
      typename MatrixFree<dim, double>::AdditionalData additional_data; 
      additional_data.tasks_parallel_scheme = 
        MatrixFree<dim, double>::AdditionalData::partition_color; 
      additional_data.mapping_update_flags = 
        (update_values | update_gradients | update_JxW_values | 
         update_quadrature_points); 
      auto system_mf_storage = std::make_shared<MatrixFree<dim, double>>(); 
      system_mf_storage->reinit(mapping, 
                                dof_handler, 
                                constraints, 
                                QGauss<1>(fe.degree + 1), 
                                additional_data); 

      system_matrix.initialize(system_mf_storage); 
    } 

    system_matrix.initialize_dof_vector(solution); 
    system_matrix.initialize_dof_vector(newton_update); 
    system_matrix.initialize_dof_vector(system_rhs); 

    const unsigned int nlevels = triangulation.n_global_levels(); 
    mg_matrices.resize(0, nlevels - 1); 
    mg_solution.resize(0, nlevels - 1); 

    std::set<types::boundary_id> dirichlet_boundary; 
    dirichlet_boundary.insert(0); 
    mg_constrained_dofs.initialize(dof_handler); 
    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, 
                                                       dirichlet_boundary); 

    mg_transfer.initialize_constraints(mg_constrained_dofs); 
    mg_transfer.build(dof_handler); 

    for (unsigned int level = 0; level < nlevels; ++level) 
      { 
        IndexSet relevant_dofs; 
        DoFTools::extract_locally_relevant_level_dofs(dof_handler, 
                                                      level, 
                                                      relevant_dofs); 

        AffineConstraints<double> level_constraints; 
        level_constraints.reinit(relevant_dofs); 
        level_constraints.add_lines( 
          mg_constrained_dofs.get_boundary_indices(level)); 
        level_constraints.close(); 

        typename MatrixFree<dim, float>::AdditionalData additional_data; 
        additional_data.tasks_parallel_scheme = 
          MatrixFree<dim, float>::AdditionalData::partition_color; 
        additional_data.mapping_update_flags = 
          (update_values | update_gradients | update_JxW_values | 
           update_quadrature_points); 
        additional_data.mg_level = level; 
        auto mg_mf_storage_level = std::make_shared<MatrixFree<dim, float>>(); 
        mg_mf_storage_level->reinit(mapping, 
                                    dof_handler, 
                                    level_constraints, 
                                    QGauss<1>(fe.degree + 1), 
                                    additional_data); 

        mg_matrices[level].initialize(mg_mf_storage_level, 
                                      mg_constrained_dofs, 
                                      level); 
        mg_matrices[level].initialize_dof_vector(mg_solution[level]); 
      } 
  } 

//  @sect4{GelfandProblem::evaluate_residual}  

// 接下来我们实现一个函数，该函数对给定的输入向量评估非线性离散残差（  $\texttt{dst} = F(\texttt{src})$  ）。这个函数随后被用于组装线性化系统的右手边，随后用于计算下一个牛顿步骤的残差，以检查我们是否已经达到了误差容忍度。由于这个函数不应该影响任何类别的变量，我们把它定义为一个常数函数。在内部，我们通过FEEvaluation类和类似于 MatrixFree::cell_loop(), 的 <code>apply_add()</code> function of the <code>JacobianOperator</code> 来利用快速有限元评估。

// 首先我们创建一个指向MatrixFree对象的指针，它被存储在  <code>system_matrix</code>  中。然后，我们将用于残差的单元评估的工作函数  <code>local_evaluate_residual()</code>  以及输入和输出向量传递给  MatrixFree::cell_loop().  此外，我们在循环中启用输出向量的清零，这比之前单独调用<code>dst = 0.0</code>更有效率。

// 注意，使用这种方法，我们不必关心MPI相关的数据交换，因为所有的记账工作都是由  MatrixFree::cell_loop().  完成的。
  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::evaluate_residual( 
    LinearAlgebra::distributed::Vector<double> &      dst, 
    const LinearAlgebra::distributed::Vector<double> &src) const 
  { 
    auto matrix_free = system_matrix.get_matrix_free(); 

    matrix_free->cell_loop( 
      &GelfandProblem::local_evaluate_residual, this, dst, src, true); 
  } 

//  @sect4{GelfandProblem::local_evaluate_residual}  

// 这是用于评估残差的内部工作函数。本质上它与  <code>JacobianOperator</code>  的  <code>local_apply()</code>  函数具有相同的结构，在给定的单元格集合  <code>cell_range</code>  上对输入向量  <code>src</code>  进行残差评估。与上述 <code>local_apply()</code> 函数不同的是，我们将 FEEvaluation::gather_evaluate() 函数分成 FEEvaluation::read_dof_values_plain() 和 FEEvaluation::evaluate(), ，因为输入向量可能有受限的DOF。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::local_evaluate_residual( 
    const MatrixFree<dim, double> &                   data, 
    LinearAlgebra::distributed::Vector<double> &      dst, 
    const LinearAlgebra::distributed::Vector<double> &src, 
    const std::pair<unsigned int, unsigned int> &     cell_range) const 
  { 
    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, double> phi(data); 

    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        phi.reinit(cell); 

        phi.read_dof_values_plain(src); 
        phi.evaluate(EvaluationFlags::values | EvaluationFlags::gradients); 

        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            phi.submit_value(-std::exp(phi.get_value(q)), q); 
            phi.submit_gradient(phi.get_gradient(q), q); 
          } 

        phi.integrate_scatter(EvaluationFlags::values | 
                                EvaluationFlags::gradients, 
                              dst); 
      } 
  } 

//  @sect4{GelfandProblem::assemble_rhs}  

// 使用上述函数 <code>evaluate_residual()</code> 来评估非线性残差，组装线性化系统的右手边现在变得非常容易。我们只需调用 <code>evaluate_residual()</code> 函数并将结果乘以减一。

// 经验表明，使用FEEvaluation类要比使用FEValues和co的经典实现快得多。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::assemble_rhs() 
  { 
    TimerOutput::Scope t(computing_timer, "assemble right hand side"); 

    evaluate_residual(system_rhs, solution); 

    system_rhs *= -1.0; 
  } 

//  @sect4{GelfandProblem::compute_residual}  

// 根据 step-15 ，下面的函数在 $u_h^n + \alpha s_h^n$ 函数的帮助下计算出解的非线性残差的规范。如果我们使用牛顿方法的自适应版本，牛顿步长 $\alpha$ 就变得很重要。例如，我们将计算不同步长的残差并比较残差。然而，对于我们的问题，使用 $\alpha=1$ 的完整牛顿步长是我们能做的最好的。如果我们没有好的初始值，牛顿方法的自适应版本就变得有趣了。请注意，在理论上，牛顿方法是以二次方顺序收敛的，但只有当我们有一个合适的初始值时才会收敛。对于不合适的初始值，牛顿方法甚至在二次方程下也会发散。一个常见的方法是使用阻尼版本 $\alpha<1$ ，直到牛顿步骤足够好，可以进行完整的牛顿步骤。这在  step-15  中也有讨论。

  template <int dim, int fe_degree> 
  double GelfandProblem<dim, fe_degree>::compute_residual(const double alpha) 
  { 
    TimerOutput::Scope t(computing_timer, "compute residual"); 

    LinearAlgebra::distributed::Vector<double> residual; 
    LinearAlgebra::distributed::Vector<double> evaluation_point; 

    system_matrix.initialize_dof_vector(residual); 
    system_matrix.initialize_dof_vector(evaluation_point); 

    evaluation_point = solution; 
    if (alpha > 1e-12) 
      { 
        evaluation_point.add(alpha, newton_update); 
      } 

    evaluate_residual(residual, evaluation_point); 

    return residual.l2_norm(); 
  } 

//  @sect4{GelfandProblem::compute_update}  

// 为了计算每个牛顿步骤中的牛顿更新，我们用CG算法和一个几何多网格预处理程序来解决线性系统。为此，我们首先像在  step-37  中那样，用切比雪夫平滑器设置PreconditionMG对象。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::compute_update() 
  { 
    TimerOutput::Scope t(computing_timer, "compute update"); 

// 我们记得，雅各布系数取决于存储在解决方案向量中的最后一个牛顿步骤。所以我们更新牛顿步骤的鬼魂值，并将其传递给 <code>JacobianOperator</code> 来存储信息。

    solution.update_ghost_values(); 

    system_matrix.evaluate_newton_step(solution); 

// 接下来我们还要将最后一个牛顿步骤传递给多级运算符。因此，我们需要将牛顿步骤插值到三角形的所有层面。这是用 MGTransferMatrixFree::interpolate_to_mg(). 来完成的。
    mg_transfer.interpolate_to_mg(dof_handler, mg_solution, solution); 

// 现在我们可以设置预处理程序了。我们定义平滑器并将牛顿步的内插向量传递给多级运算器。

    using SmootherType = 
      PreconditionChebyshev<LevelMatrixType, 
                            LinearAlgebra::distributed::Vector<float>>; 
    mg::SmootherRelaxation<SmootherType, 
                           LinearAlgebra::distributed::Vector<float>> 
                                                         mg_smoother; 
    MGLevelObject<typename SmootherType::AdditionalData> smoother_data; 
    smoother_data.resize(0, triangulation.n_global_levels() - 1); 
    for (unsigned int level = 0; level < triangulation.n_global_levels(); 
         ++level) 
      { 
        if (level > 0) 
          { 
            smoother_data[level].smoothing_range     = 15.; 
            smoother_data[level].degree              = 4; 
            smoother_data[level].eig_cg_n_iterations = 10; 
          } 
        else 
          { 
            smoother_data[0].smoothing_range = 1e-3; 
            smoother_data[0].degree          = numbers::invalid_unsigned_int; 
            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m(); 
          } 

        mg_matrices[level].evaluate_newton_step(mg_solution[level]); 
        mg_matrices[level].compute_diagonal(); 

        smoother_data[level].preconditioner = 
          mg_matrices[level].get_matrix_diagonal_inverse(); 
      } 
    mg_smoother.initialize(mg_matrices, smoother_data); 

    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>> 
      mg_coarse; 
    mg_coarse.initialize(mg_smoother); 

    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix( 
      mg_matrices); 

    MGLevelObject<MatrixFreeOperators::MGInterfaceOperator<LevelMatrixType>> 
      mg_interface_matrices; 
    mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1); 
    for (unsigned int level = 0; level < triangulation.n_global_levels(); 
         ++level) 
      { 
        mg_interface_matrices[level].initialize(mg_matrices[level]); 
      } 
    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_interface( 
      mg_interface_matrices); 

    Multigrid<LinearAlgebra::distributed::Vector<float>> mg( 
      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother); 
    mg.set_edge_matrices(mg_interface, mg_interface); 

    PreconditionMG<dim, 
                   LinearAlgebra::distributed::Vector<float>, 
                   MGTransferMatrixFree<dim, float>> 
      preconditioner(dof_handler, mg, mg_transfer); 

// 最后我们设置了SolverControl和SolverCG来解决当前牛顿更新的线性化问题。实现SolverCG或SolverGMRES的一个重要事实是，持有线性系统解决方案的向量（这里是 <code>newton_update</code>  ）可以用来传递一个起始值。为了使迭代求解器总是以零向量开始，我们在调用 SolverCG::solve(). 之前明确地重置了 <code>newton_update</code> ，然后我们分配了存储在 <code>constraints</code> 中的Dirichlet边界条件，并为以后的输出存储了迭代的步数。

    SolverControl solver_control(100, 1.e-12); 
    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control); 

    newton_update = 0.0; 

    cg.solve(system_matrix, newton_update, system_rhs, preconditioner); 

    constraints.distribute(newton_update); 

    linear_iterations = solver_control.last_step(); 

// 然后，为了记账，我们将幽灵值清零。

    solution.zero_out_ghost_values(); 
  } 

//  @sect4{GelfandProblem::solve}  

// 现在我们实现非线性问题的实际牛顿求解器。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::solve() 
  { 
    TimerOutput::Scope t(computing_timer, "solve"); 

// 我们定义了牛顿步骤的最大数量和收敛标准的公差。通常情况下，如果有好的起始值，牛顿方法在三到六步内就能收敛，所以最大的十步应该是完全足够的。作为公差，我们使用 $\|F(u^n_h)\|<\text{TOL}_f = 10^{-12}$ 作为残差的规范， $\|s_h^n\| < \text{TOL}_x = 10^{-10}$ 作为牛顿更新的规范。这似乎有点过头了，但我们将看到，对于我们的例子，我们将在几步之后达到这些公差。

    const unsigned int itmax = 10; 
    const double       TOLf  = 1e-12; 
    const double       TOLx  = 1e-10; 

    Timer solver_timer; 
    solver_timer.start(); 

// 现在我们开始实际的牛顿迭代。

    for (unsigned int newton_step = 1; newton_step <= itmax; ++newton_step) 
      { 

// 我们将线性化问题的右侧集合起来，计算牛顿更新。

        assemble_rhs(); 
        compute_update(); 

// 然后，我们计算误差，即牛顿更新的规范和残差。注意，在这一点上，我们可以通过改变compute_residual函数的输入参数 $\alpha$ 来加入牛顿方法的步长控制。然而，在这里我们只是使用 $\alpha$ 等于1来进行普通的牛顿迭代。

        const double ERRx = newton_update.l2_norm(); 
        const double ERRf = compute_residual(1.0); 

// 接下来我们通过将牛顿更新添加到当前的牛顿步骤中来推进牛顿步骤。

        solution.add(1.0, newton_update); 

// 一个简短的输出将告知我们当前的牛顿步数。

        pcout << "   Nstep " << newton_step << ", errf = " << ERRf 
              << ", errx = " << ERRx << ", it = " << linear_iterations 
              << std::endl; 

// 在每个牛顿步骤之后，我们检查收敛标准。如果其中至少有一个得到满足，我们就完成了，并结束循环。如果我们在牛顿迭代的最大数量之后还没有找到一个满意的解决方案，我们就会通知用户这个缺点。

        if (ERRf < TOLf || ERRx < TOLx) 
          { 
            solver_timer.stop(); 

            pcout << "Convergence step " << newton_step << " value " << ERRf 
                  << " (used wall time: " << solver_timer.wall_time() << " s)" 
                  << std::endl; 

            break; 
          } 
        else if (newton_step == itmax) 
          { 
            solver_timer.stop(); 
            pcout << "WARNING: No convergence of Newton's method after " 
                  << newton_step << " steps." << std::endl; 

            break; 
          } 
      } 
  } 

//  @sect4{GelfandProblem::compute_solution_norm}  

// 解的H1-seminorm的计算可以用与 step-59 相同的方法进行。我们更新幽灵值并使用函数  VectorTools::integrate_difference().  最后我们收集所有MPI行列的所有计算，并返回规范。

  template <int dim, int fe_degree> 
  double GelfandProblem<dim, fe_degree>::compute_solution_norm() const 
  { 
    solution.update_ghost_values(); 

    Vector<float> norm_per_cell(triangulation.n_active_cells()); 

    VectorTools::integrate_difference(mapping, 
                                      dof_handler, 
                                      solution, 
                                      Functions::ZeroFunction<dim>(), 
                                      norm_per_cell, 
                                      QGauss<dim>(fe.degree + 2), 
                                      VectorTools::H1_seminorm); 

    solution.zero_out_ghost_values(); 

    return VectorTools::compute_global_error(triangulation, 
                                             norm_per_cell, 
                                             VectorTools::H1_seminorm); 
  } 

//  @sect4{GelfandProblem::output_results}  

// 我们通过调用  DataOut::write_vtu_with_pvtu_record()  函数，以与  step-37  中相同的方式，一次性生成 vtu 格式的图形输出文件和 pvtu 主文件。此外，与  step-40  一样，我们查询每个单元的  types::subdomain_id  并将三角形在MPI行列中的分布写进输出文件。最后，我们通过调用 DataOut::build_patches(). 生成解决方案的补丁。然而，由于我们的计算域有一个弯曲的边界，我们另外传递 <code>mapping</code> 和有限元度作为细分的数量。但这仍然不足以正确表示解决方案，例如在ParaView中，因为我们将TransfiniteInterpolationManifold附在内部单元上，这导致内部的单元是弯曲的。因此，我们将 DataOut::curved_inner_cells 选项作为第三个参数，这样，内部单元也会使用相应的流形描述来构建补丁。

// 注意，我们可以用标志 DataOutBase::VtkFlags::write_higher_order_cells. 来处理高阶元素，但是由于对ParaView以前版本的兼容性有限，而且VisIt也不支持，所以我们把这个选项留给未来的版本。

  template <int dim, int fe_degree> 
  void 
  GelfandProblem<dim, fe_degree>::output_results(const unsigned int cycle) const 
  { 
    if (triangulation.n_global_active_cells() > 1e6) 
      return; 

    solution.update_ghost_values(); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 

    Vector<float> subdomain(triangulation.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      { 
        subdomain(i) = triangulation.locally_owned_subdomain(); 
      } 
    data_out.add_data_vector(subdomain, "subdomain"); 

    data_out.build_patches(mapping, 
                           fe.degree, 
                           DataOut<dim>::curved_inner_cells); 

    DataOutBase::VtkFlags flags; 
    flags.compression_level = DataOutBase::VtkFlags::best_speed; 
    data_out.set_flags(flags); 
    data_out.write_vtu_with_pvtu_record( 
      "./", "solution_" + std::to_string(dim) + "d", cycle, MPI_COMM_WORLD, 3); 

    solution.zero_out_ghost_values(); 
  } 

//  @sect4{GelfandProblem::run}  

// <i>Gelfand
 problem</i>的求解器类的最后一个缺失的函数是运行函数。在开始的时候，我们打印关于系统规格和我们使用的有限元空间的信息。该问题在一个连续细化的网格上被多次求解。

  template <int dim, int fe_degree> 
  void GelfandProblem<dim, fe_degree>::run() 
  { 
    { 
      const unsigned int n_ranks = 
        Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD); 
      const unsigned int n_vect_doubles = VectorizedArray<double>::size(); 
      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles; 

      std::string DAT_header = "START DATE: " + Utilities::System::get_date() + 
                               ", TIME: " + Utilities::System::get_time(); 
      std::string MPI_header = "Running with " + std::to_string(n_ranks) + 
                               " MPI process" + (n_ranks > 1 ? "es" : ""); 
      std::string VEC_header = 
        "Vectorization over " + std::to_string(n_vect_doubles) + 
        " doubles = " + std::to_string(n_vect_bits) + " bits (" + 
        Utilities::System::get_current_vectorization_level() + 
        "), VECTORIZATION_LEVEL=" + 
        std::to_string(DEAL_II_COMPILER_VECTORIZATION_LEVEL); 
      std::string SOL_header = "Finite element space: " + fe.get_name(); 

      pcout << std::string(80, '=') << std::endl; 
      pcout << DAT_header << std::endl; 
      pcout << std::string(80, '-') << std::endl; 

      pcout << MPI_header << std::endl; 
      pcout << VEC_header << std::endl; 
      pcout << SOL_header << std::endl; 

      pcout << std::string(80, '=') << std::endl; 
    } 

    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle) 
      { 
        pcout << std::string(80, '-') << std::endl; 
        pcout << "Cycle " << cycle << std::endl; 
        pcout << std::string(80, '-') << std::endl; 

// 实际解决问题的第一项任务是生成或完善三角图。

        if (cycle == 0) 
          { 
            make_grid(); 
          } 
        else 
          { 
            triangulation.refine_global(1); 
          } 

// 现在我们建立了系统并解决这个问题。这些步骤都伴随着时间测量和文本输出。

        Timer timer; 

        pcout << "Set up system..." << std::endl; 
        setup_system(); 

        pcout << "   Triangulation: " << triangulation.n_global_active_cells() 
              << " cells" << std::endl; 
        pcout << "   DoFHandler:    " << dof_handler.n_dofs() << " DoFs" 
              << std::endl; 
        pcout << std::endl; 

        pcout << "Solve using Newton's method..." << std::endl; 
        solve(); 
        pcout << std::endl; 

        timer.stop(); 
        pcout << "Time for setup+solve (CPU/Wall) " << timer.cpu_time() << "/" 
              << timer.wall_time() << " s" << std::endl; 
        pcout << std::endl; 

// 在问题被解决后，我们计算出解决方案的法线，并生成图形输出文件。

        pcout << "Output results..." << std::endl; 
        const double norm = compute_solution_norm(); 
        output_results(cycle); 

        pcout << "  H1 seminorm: " << norm << std::endl; 
        pcout << std::endl; 

// 最后在每个周期后，我们打印计时信息。

        computing_timer.print_summary(); 
        computing_timer.reset(); 
      } 
  } 
} // namespace Step66 

//  @sect3{The <code>main</code> function}  

// 作为使用MPI并行运行的典型程序，我们设置了MPI框架，并通过限制线程数为1来禁用共享内存并行化。最后，为了运行<i>Gelfand problem</i>的求解器，我们创建一个 <code>GelfandProblem</code> 类的对象并调用运行函数。例如，我们用四阶拉格朗日有限元在二维和三维中各解决一次问题。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace Step66; 

      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1); 

      { 
        GelfandProblem<2, 4> gelfand_problem; 
        gelfand_problem.run(); 
      } 

      { 
        GelfandProblem<3, 4> gelfand_problem; 
        gelfand_problem.run(); 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-67.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2020 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Martin Kronbichler, 2020 
 */ 



// 包含文件与之前的无矩阵教程程序 step-37 、 step-48 和 step-59 相似。
#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/time_stepping.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/vectorization.h> 

#include <deal.II/distributed/tria.h> 

#include <deal.II/dofs/dof_handler.h> 

#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_system.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/tria.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/la_parallel_vector.h> 

#include <deal.II/matrix_free/fe_evaluation.h> 
#include <deal.II/matrix_free/matrix_free.h> 

#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iomanip> 
#include <iostream> 

// 下面的文件包括CellwiseInverseMassMatrix数据结构，我们将在质量矩阵反演中使用它，这是本教程程序中唯一的新包含文件。

#include <deal.II/matrix_free/operators.h> 

namespace Euler_DG 
{ 
  using namespace dealii; 

// 与其他无矩阵教程程序类似，我们在文件的顶部收集所有控制程序执行的参数。除了我们想要运行的维度和多项式程度，我们还指定了我们想要用于欧拉方程中非线性项的高斯正交公式的点数。此外，我们指定了随时间变化的问题的时间间隔，并实现了两个不同的测试案例。第一个是二维的分析解，而第二个是介绍中描述的围绕圆柱体的通道流。根据测试案例，我们还改变了运行模拟的最终时间，以及一个变量`output_tick`，它指定了我们要在哪个时间间隔内写入输出（假设tick大于时间步长）。

  constexpr unsigned int testcase             = 0; 
  constexpr unsigned int dimension            = 2; 
  constexpr unsigned int n_global_refinements = 3; 
  constexpr unsigned int fe_degree            = 5; 
  constexpr unsigned int n_q_points_1d        = fe_degree + 2; 

  using Number = double; 

  constexpr double gamma       = 1.4; 
  constexpr double final_time  = testcase == 0 ? 10 : 2.0; 
  constexpr double output_tick = testcase == 0 ? 1 : 0.05; 

// 接下来是时间积分器的一些细节，即用公式 $\Delta t =
//  \text{Cr} n_\text{stages} \frac{h}{(p+1)^{1.5} (\|\mathbf{u} +
//  c)_\text{max}}$ 来衡量时间步长的库朗数，以及选择一些低存储量的Runge--Kutta方法。我们指定Runge--Kutta方案每级的Courant数，因为这对不同级数的方案给出了一个更实际的数值成本表达。

  const double courant_number = 0.15 / std::pow(fe_degree, 1.5); 
  enum LowStorageRungeKuttaScheme 
  { 
    stage_3_order_3, /* Kennedy, Carpenter, Lewis, 2000 */ 


    stage_5_order_4, /* Kennedy, Carpenter, Lewis, 2000 */ 


    stage_7_order_4, /* Tselios, Simos, 2007 */ 


    stage_9_order_5, /* Kennedy, Carpenter, Lewis, 2000 */ 


  }; 
  constexpr LowStorageRungeKuttaScheme lsrk_scheme = stage_5_order_4; 

// 最终，我们选择了空间离散化的一个细节，即单元间面的数值通量（黎曼求解器）。在这个程序中，我们实现了Lax--Friedrichs通量和Harten--Lax--van Leer(HLL)通量的一个改进版本。

  enum EulerNumericalFlux 
  { 
    lax_friedrichs_modified, 
    harten_lax_vanleer, 
  }; 
  constexpr EulerNumericalFlux numerical_flux_type = lax_friedrichs_modified; 

//  @sect3{Equation data}  

// 我们现在定义了一个带有测试情况0的精确解的类和一个带有测试情况1的通道背景流场的类。鉴于欧拉方程是一个在 $d$ 维度上有 $d+2$ 个方程的问题，我们需要告诉函数基类正确的分量数量。

  template <int dim> 
  class ExactSolution : public Function<dim> 
  { 
  public: 
    ExactSolution(const double time) 
      : Function<dim>(dim + 2, time) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

// 就实际实现的函数而言，分析性测试案例是一个等熵涡旋案例（例如参见Hesthaven和Warburton的书，第209页第6.6节中的例6.1），它满足欧拉方程，右侧的力项为零。考虑到这个定义，我们返回密度、动量或能量，这取决于所要求的成分。请注意，密度的原始定义涉及一些表达式的 $\frac{1}{\gamma -1}$ -次方。由于 `std::pow()` 在某些系统上的实现相当慢，我们用对数和指数（以2为底）来代替它，这在数学上是等价的，但通常优化得更好。与 `std::pow()`, 相比，对于非常小的数字，这个公式可能会在最后一位数字上失去准确性，但我们还是很高兴，因为小数字映射为接近1的数据。

// 对于通道测试案例，我们简单地选择密度为1， $x$ 方向的速度为0.4，其他方向的速度为0，以及对应于背景速度场测量的1.3声速的能量，根据关系 $E = \frac{c^2}{\gamma (\gamma -1)} + \frac 12 \rho \|u\|^2$ 计算得出。

  template <int dim> 
  double ExactSolution<dim>::value(const Point<dim> & x, 
                                   const unsigned int component) const 
  { 
    const double t = this->get_time(); 

    switch (testcase) 
      { 
        case 0: 
          { 
            Assert(dim == 2, ExcNotImplemented()); 
            const double beta = 5; 

            Point<dim> x0; 
            x0[0] = 5.; 
            const double radius_sqr = 
              (x - x0).norm_square() - 2. * (x[0] - x0[0]) * t + t * t; 
            const double factor = 
              beta / (numbers::PI * 2) * std::exp(1. - radius_sqr); 
            const double density_log = std::log2( 
              std::abs(1. - (gamma - 1.) / gamma * 0.25 * factor * factor)); 
            const double density = std::exp2(density_log * (1. / (gamma - 1.))); 
            const double u       = 1. - factor * (x[1] - x0[1]); 
            const double v       = factor * (x[0] - t - x0[0]); 

            if (component == 0) 
              return density; 
            else if (component == 1) 
              return density * u; 
            else if (component == 2) 
              return density * v; 
            else 
              { 
                const double pressure = 
                  std::exp2(density_log * (gamma / (gamma - 1.))); 
                return pressure / (gamma - 1.) + 
                       0.5 * (density * u * u + density * v * v); 
              } 
          } 

        case 1: 
          { 
            if (component == 0) 
              return 1.; 
            else if (component == 1) 
              return 0.4; 
            else if (component == dim + 1) 
              return 3.097857142857143; 
            else 
              return 0.; 
          } 

        default: 
          Assert(false, ExcNotImplemented()); 
          return 0.; 
      } 
  } 

//  @sect3{Low-storage explicit Runge--Kutta time integrators}  

// 接下来的几行实现了一些低存储量的Runge--Kutta方法的变体。这些方法有特定的布彻表，系数为 $b_i$ 和 $a_i$ ，如介绍中所示。如同Runge--Kutta方法的惯例，我们可以从这些系数中推导出时间步骤 $c_i = \sum_{j=1}^{i-2} b_i + a_{i-1}$ 。这种方案的主要优点是每个阶段只需要两个向量，即解的累积部分 $\mathbf{w}$ （在最后一个阶段后的新时间 $t^{n+1}$ 保持解 $\mathbf{w}^{n+1}$ ），在各阶段被评估的更新向量 $\mathbf{r}_i$ ，加上一个向量 $\mathbf{k}_i$ 来保持算子评估。这样的Runge--Kutta设置减少了内存存储和内存访问。由于内存带宽通常是现代硬件上的性能限制因素，当微分算子的评估得到很好的优化时，性能可以比标准的时间积分器得到改善。考虑到传统的Runge--Kutta方案可能允许稍大的时间步长，因为更多的自由参数可以获得更好的稳定性，这一点也是真实的。

// 在本教程中，我们集中讨论Kennedy, Carpenter和Lewis(2000)文章中定义的低存储方案的几个变体，以及Tselios和Simos(2007)描述的一个变体。还有一大系列的其他方案，可以通过额外的系数集或稍微不同的更新公式来解决。

// 我们为这四种积分器定义了一个单一的类，用上述的枚举来区分。对每个方案，我们再将 $b_i$ 和 $a_i$ 的向量填充到类中的给定变量。

  class LowStorageRungeKuttaIntegrator 
  { 
  public: 
    LowStorageRungeKuttaIntegrator(const LowStorageRungeKuttaScheme scheme) 
    { 
      TimeStepping::runge_kutta_method lsrk; 

// 首先是Kennedy等人（2000）提出的三阶方案。虽然它的稳定区域比其他方案小得多，但它只涉及三个阶段，所以在每个阶段的工作方面很有竞争力。

      switch (scheme) 
        { 
          case stage_3_order_3: 
            { 
              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE3_ORDER3; 
              break; 
            } 

// 下一个方案是四阶的五级方案，同样在Kennedy等人（2000）的论文中定义。

          case stage_5_order_4: 
            { 
              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE5_ORDER4; 
              break; 
            } 

// 下面这个七级和四阶的方案已经明确地推导出用于声学问题。它在四阶方案中兼顾了虚特征值的精度，并结合了一个大的稳定区域。由于DG方案在最高频率之间是耗散的，这不一定转化为每级可能的最高时间步长。在本教程方案的背景下，数值通量在耗散中起着至关重要的作用，因此也是最大的稳定时间步长。对于修改后的Lax--Friedrichs通量，如果只考虑稳定性，该方案在每级步长方面与`stage_5_order_4`方案相似，但对于HLL通量来说，效率稍低。

          case stage_7_order_4: 
            { 
              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE7_ORDER4; 
              break; 
            } 

// 这里包括的最后一个方案是Kennedy等人（2000）的五阶九级方案。它是这里使用的方案中最精确的，但是较高的精度牺牲了一些稳定性，所以每级的归一化步长比四阶方案要小。

          case stage_9_order_5: 
            { 
              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE9_ORDER5; 
              break; 
            } 

          default: 
            AssertThrow(false, ExcNotImplemented()); 
        } 
      TimeStepping::LowStorageRungeKutta< 
        LinearAlgebra::distributed::Vector<Number>> 
        rk_integrator(lsrk); 
      rk_integrator.get_coefficients(ai, bi, ci); 
    } 

    unsigned int n_stages() const 
    { 
      return bi.size(); 
    } 

// 时间积分器的主要功能是通过阶段，评估算子，为下一次评估准备  $\mathbf{r}_i$  矢量，并更新解决方案矢量  $\mathbf{w}$  。我们把工作交给所涉及的`pde_operator`，以便能够把Runge--Kutta设置的矢量操作与微分算子的评估合并起来，以获得更好的性能，所以我们在这里所做的就是委托矢量和系数。

// 我们单独调用第一阶段的算子，因为我们需要稍微修改一下那里的参数。我们从旧的解决方案 $\mathbf{w}^n$ 而不是 $\mathbf r_i$ 向量中评估解决方案，所以第一个参数是`solution`。我们在这里让阶段向量 $\mathbf{r}_i$ 也持有评估的临时结果，因为它在其他情况下不会被使用。对于所有后续阶段，我们使用向量`vec_ki`作为第二个向量参数来存储运算符的求值结果。最后，当我们到了最后一个阶段，我们必须跳过对向量 $\mathbf{r}_{s+1}$ 的计算，因为没有系数 $a_s$ 可用（也不会用到）。

    template <typename VectorType, typename Operator> 
    void perform_time_step(const Operator &pde_operator, 
                           const double    current_time, 
                           const double    time_step, 
                           VectorType &    solution, 
                           VectorType &    vec_ri, 
                           VectorType &    vec_ki) const 
    { 
      AssertDimension(ai.size() + 1, bi.size()); 

      pde_operator.perform_stage(current_time, 
                                 bi[0] * time_step, 
                                 ai[0] * time_step, 
                                 solution, 
                                 vec_ri, 
                                 solution, 
                                 vec_ri); 

      for (unsigned int stage = 1; stage < bi.size(); ++stage) 
        { 
          const double c_i = ci[stage]; 
          pde_operator.perform_stage(current_time + c_i * time_step, 
                                     bi[stage] * time_step, 
                                     (stage == bi.size() - 1 ? 
                                        0 : 
                                        ai[stage] * time_step), 
                                     vec_ri, 
                                     vec_ki, 
                                     solution, 
                                     vec_ri); 
        } 
    } 

  private: 
    std::vector<double> bi; 
    std::vector<double> ai; 
    std::vector<double> ci; 
  }; 

//  @sect3{Implementation of point-wise operations of the Euler equations}  

// 在下面的函数中，我们实现了与欧拉方程有关的各种特定问题的运算。每个函数都作用于我们在解向量中持有的守恒变量向量 $[\rho, \rho\mathbf{u}, E]$ ，并计算各种派生量。

// 首先是速度的计算，我们从动量变量 $\rho \mathbf{u}$ 除以 $\rho$ 得出。这里需要注意的是，我们用关键字`DEAL_II_ALWAYS_INLINE`来装饰所有这些函数。这是一个特殊的宏，映射到一个编译器专用的关键字，告诉编译器永远不要为这些函数创建一个函数调用，而是将实现<a href="https:en.wikipedia.org/wiki/Inline_function">inline</a>移到它们被调用的地方。这对性能至关重要，因为我们对其中一些函数的调用达到了几百万甚至几十亿次。例如，我们既使用速度来计算通量，也使用速度来计算压力，而这两个地方都要在每个单元的每个正交点进行评估。确保这些函数是内联的，不仅可以确保处理器不必执行跳转指令进入函数（以及相应的返回跳转），而且编译器可以在调用函数的地方之后的代码中重新使用一个函数的上下文的中间信息。(我们注意到，编译器通常很善于自己找出哪些函数要内联。这里有一个地方，编译器可能是自己想出来的，也可能不是，但我们可以肯定的是，内联是一种胜利。)

// 我们应用的另一个技巧是为反密度设置一个单独的变量  $\frac{1}{\rho}$  。这使得编译器只对通量进行一次除法，尽管除法在多个地方使用。由于除法的费用大约是乘法或加法的10到20倍，避免多余的除法对性能至关重要。我们注意到，由于四舍五入的影响，在浮点运算中，先取反数，后与之相乘并不等同于除法，所以编译器不允许用标准的优化标志来交换一种方式。然而，以正确的方式编写代码也不是特别困难。

// 总而言之，所选择的总是内联和仔细定义昂贵的算术运算的策略使我们能够写出紧凑的代码，而不需要将所有的中间结果传递出去，尽管要确保代码映射到优秀的机器码。

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, dim, Number> 
    euler_velocity(const Tensor<1, dim + 2, Number> &conserved_variables) 
  { 
    const Number inverse_density = Number(1.) / conserved_variables[0]; 

    Tensor<1, dim, Number> velocity; 
    for (unsigned int d = 0; d < dim; ++d) 
      velocity[d] = conserved_variables[1 + d] * inverse_density; 

    return velocity; 
  } 

// 下一个函数从保守变量的矢量中计算压力，使用公式  $p = (\gamma - 1) \left(E - \frac 12 \rho \mathbf{u}\cdot \mathbf{u}\right)$  。如上所述，我们使用来自`euler_velocity()`函数的速度。注意，我们需要在这里指定第一个模板参数`dim`，因为编译器无法从张量的参数中推导出它，而第二个参数（数字类型）可以自动推导出来。

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Number 
    euler_pressure(const Tensor<1, dim + 2, Number> &conserved_variables) 
  { 
    const Tensor<1, dim, Number> velocity = 
      euler_velocity<dim>(conserved_variables); 

    Number rho_u_dot_u = conserved_variables[1] * velocity[0]; 
    for (unsigned int d = 1; d < dim; ++d) 
      rho_u_dot_u += conserved_variables[1 + d] * velocity[d]; 

    return (gamma - 1.) * (conserved_variables[dim + 1] - 0.5 * rho_u_dot_u); 
  } 

// 这里是欧拉通量函数的定义，也就是实际方程的定义。考虑到速度和压力（编译器的优化将确保只做一次），考虑到介绍中所说的方程，这是直截了当的。

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, dim + 2, Tensor<1, dim, Number>> 
    euler_flux(const Tensor<1, dim + 2, Number> &conserved_variables) 
  { 
    const Tensor<1, dim, Number> velocity = 
      euler_velocity<dim>(conserved_variables); 
    const Number pressure = euler_pressure<dim>(conserved_variables); 

    Tensor<1, dim + 2, Tensor<1, dim, Number>> flux; 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        flux[0][d] = conserved_variables[1 + d]; 
        for (unsigned int e = 0; e < dim; ++e) 
          flux[e + 1][d] = conserved_variables[e + 1] * velocity[d]; 
        flux[d + 1][d] += pressure; 
        flux[dim + 1][d] = 
          velocity[d] * (conserved_variables[dim + 1] + pressure); 
      } 

    return flux; 
  } 

// 接下来的这个函数是一个简化数值通量实现的助手，它实现了一个张量的张量（具有大小为`dim + 2`的非标准外维，所以deal.II的张量类提供的标准重载在此不适用）与另一个相同内维的张量的作用，即一个矩阵-向量积。

  template <int n_components, int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, n_components, Number> 
    operator*(const Tensor<1, n_components, Tensor<1, dim, Number>> &matrix, 
              const Tensor<1, dim, Number> &                         vector) 
  { 
    Tensor<1, n_components, Number> result; 
    for (unsigned int d = 0; d < n_components; ++d) 
      result[d] = matrix[d] * vector; 
    return result; 
  } 

// 这个函数实现了数值通量（黎曼求解器）。它从一个界面的两边获得状态，并获得法向量，从解的一边  $\mathbf{w}^-$  向解  $\mathbf{w}^+$  的方向。在依赖片断恒定数据的有限体积方法中，数值通量是核心成分，因为它是唯一输入物理信息的地方。在DG方法中，由于元素内部的多项式和那里使用的物理通量，数值通量就不那么核心了。由于在连续解的极限中，两边的数值一致的高阶插值，数值通量可以被看作是对两边解的跳跃的控制，以弱化连续性。必须认识到，在存在冲击的情况下，仅靠数值通量是无法稳定高阶DG方法的，因此任何DG方法都必须与进一步的冲击捕捉技术相结合，以处理这些情况。在本教程中，我们将重点讨论欧拉方程在没有强不连续的亚声速体系中的波状解，我们的基本方案已经足够了。

// 尽管如此，数值通量对整个方案的数值耗散起着决定性作用，并影响到显式Runge-Kutta方法的可接受的时间步长。我们考虑两种选择，一种是改良的Lax-Friedrichs方案，另一种是广泛使用的Harten-Lax-van Leer（HLL）通量。对于这两种方案，我们首先需要得到界面两边的速度和压力，并评估物理欧拉通量。

// 对于局部Lax--Friedrichs通量，其定义是 $\hat{\mathbf{F}}
//  =\frac{\mathbf{F}(\mathbf{w}^-)+\mathbf{F}(\mathbf{w}^+)}{2} +
//  \frac{\lambda}{2}\left[\mathbf{w}^--\mathbf{w}^+\right]\otimes
//  \mathbf{n^-}$  ，其中因子 $\lambda =
//  \max\left(\|\mathbf{u}^-\|+c^-, \|\mathbf{u}^+\|+c^+\right)$ 给出了最大波速， $c = \sqrt{\gamma p / \rho}$ 是音速。在这里，考虑到通量对解的影响很小，为了计算效率的原因，我们选择了该表达式的两个修改。对于上述因子 $\lambda$ 的定义，我们需要取四个平方根，两个用于两个速度规范，两个用于两侧的声速。因此，第一个修改是宁可使用 $\sqrt{\|\mathbf{u}\|^2+c^2}$ 作为最大速度的估计（如介绍中所示，它与实际最大速度最多相差2倍）。这使我们能够从最大速度中提取平方根，并且只需进行一次平方根计算就可以了。第二个修改是进一步放宽参数 $\lambda$ --它越小，耗散系数就越小（与 $\mathbf{w}$ 的跳跃相乘，最终可能导致耗散变小或变大）。这使得我们可以用更大的时间步长将频谱纳入显式Runge--Kutta积分器的稳定区域。然而，我们不能使耗散太小，因为否则假想的特征值会越来越大。最后，目前的保守公式在 $\lambda\to 0$ 的极限中不是能量稳定的，因为它不是偏斜对称的，在这种情况下需要额外的措施，如分裂形式的DG方案。

// 对于HLL通量，我们遵循文献中的公式，通过一个参数 $s$ 引入Lax--Friedrichs的两个状态的额外加权。它是由欧拉方程的物理传输方向得出的，以当前的速度方向和声速为准。对于速度，我们在此选择一个简单的算术平均数，这对危险情况和材料参数的适度跳跃是足够的。

// 由于数值通量在弱形式下是与法向量相乘的，因此我们对方程中的所有项都用法向量来乘以结果。在这些乘法中，上面定义的 "操作符*"可以实现类似于数学定义的紧凑符号。

// 在这个函数和下面的函数中，我们使用变量后缀`_m`和`_p`来表示从 $\mathbf{w}^-$ 和 $\mathbf{w}^+$ 得出的量，即在观察相邻单元时相对于当前单元的 "这里 "和 "那里 "的数值。

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, dim + 2, Number> 
    euler_numerical_flux(const Tensor<1, dim + 2, Number> &u_m, 
                         const Tensor<1, dim + 2, Number> &u_p, 
                         const Tensor<1, dim, Number> &    normal) 
  { 
    const auto velocity_m = euler_velocity<dim>(u_m); 
    const auto velocity_p = euler_velocity<dim>(u_p); 

    const auto pressure_m = euler_pressure<dim>(u_m); 
    const auto pressure_p = euler_pressure<dim>(u_p); 

    const auto flux_m = euler_flux<dim>(u_m); 
    const auto flux_p = euler_flux<dim>(u_p); 

    switch (numerical_flux_type) 
      { 
        case lax_friedrichs_modified: 
          { 
            const auto lambda = 
              0.5 * std::sqrt(std::max(velocity_p.norm_square() + 
                                         gamma * pressure_p * (1. / u_p[0]), 
                                       velocity_m.norm_square() + 
                                         gamma * pressure_m * (1. / u_m[0]))); 

            return 0.5 * (flux_m * normal + flux_p * normal) + 
                   0.5 * lambda * (u_m - u_p); 
          } 

        case harten_lax_vanleer: 
          { 
            const auto avg_velocity_normal = 
              0.5 * ((velocity_m + velocity_p) * normal); 
            const auto   avg_c = std::sqrt(std::abs( 
              0.5 * gamma * 
              (pressure_p * (1. / u_p[0]) + pressure_m * (1. / u_m[0])))); 
            const Number s_pos = 
              std::max(Number(), avg_velocity_normal + avg_c); 
            const Number s_neg = 
              std::min(Number(), avg_velocity_normal - avg_c); 
            const Number inverse_s = Number(1.) / (s_pos - s_neg); 

            return inverse_s * 
                   ((s_pos * (flux_m * normal) - s_neg * (flux_p * normal)) - 
                    s_pos * s_neg * (u_m - u_p)); 
          } 

        default: 
          { 
            Assert(false, ExcNotImplemented()); 
            return {}; 
          } 
      } 
  } 

// 这个函数和下一个函数是辅助函数，提供紧凑的评估调用，因为多个点通过VectorizedArray参数被分批放在一起（详见 step-37 教程）。这个函数用于亚音速外流边界条件，我们需要将能量分量设置为一个规定值。下一个函数请求所有分量上的解，用于流入边界，其中解的所有分量都被设置。

  template <int dim, typename Number> 
  VectorizedArray<Number> 
  evaluate_function(const Function<dim> &                      function, 
                    const Point<dim, VectorizedArray<Number>> &p_vectorized, 
                    const unsigned int                         component) 
  { 
    VectorizedArray<Number> result; 
    for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v) 
      { 
        Point<dim> p; 
        for (unsigned int d = 0; d < dim; ++d) 
          p[d] = p_vectorized[d][v]; 
        result[v] = function.value(p, component); 
      } 
    return result; 
  } 

  template <int dim, typename Number, int n_components = dim + 2> 
  Tensor<1, n_components, VectorizedArray<Number>> 
  evaluate_function(const Function<dim> &                      function, 
                    const Point<dim, VectorizedArray<Number>> &p_vectorized) 
  { 
    AssertDimension(function.n_components, n_components); 
    Tensor<1, n_components, VectorizedArray<Number>> result; 
    for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v) 
      { 
        Point<dim> p; 
        for (unsigned int d = 0; d < dim; ++d) 
          p[d] = p_vectorized[d][v]; 
        for (unsigned int d = 0; d < n_components; ++d) 
          result[d][v] = function.value(p, d); 
      } 
    return result; 
  } 

//  @sect3{The EulerOperation class}  

// 这个类实现了欧拉问题的评估器，类似于  step-37  或  step-59  的 `LaplaceOperator` 类。由于本算子是非线性的，不需要矩阵接口（交给预处理程序），我们跳过了无矩阵算子中的各种`vmult`函数，只实现了`apply`函数以及`apply`与上述低存储Runge-Kutta时间积分器所需的矢量更新的组合（称为`perform_stage`）。此外，我们还增加了三个涉及无矩阵例程的额外函数，即一个是根据元素中的速度和声速计算时间步长的估计值（与实际时间步长的Courant数相结合），一个是解的投影（专门针对DG情况的 VectorTools::project() ），还有一个是计算与可能的分析解或与某些背景状态的规范的误差。

// 该课的其余部分与其他无矩阵教程相似。正如介绍中所讨论的，我们提供了几个函数，允许用户在由 types::boundary_id 变量标记的领域边界的不同部分传递各种形式的边界条件，以及可能的体力。

  template <int dim, int degree, int n_points_1d> 
  class EulerOperator 
  { 
  public: 
    static constexpr unsigned int n_quadrature_points_1d = n_points_1d; 

    EulerOperator(TimerOutput &timer_output); 

    void reinit(const Mapping<dim> &   mapping, 
                const DoFHandler<dim> &dof_handler); 

    void set_inflow_boundary(const types::boundary_id       boundary_id, 
                             std::unique_ptr<Function<dim>> inflow_function); 

    void set_subsonic_outflow_boundary( 
      const types::boundary_id       boundary_id, 
      std::unique_ptr<Function<dim>> outflow_energy); 

    void set_wall_boundary(const types::boundary_id boundary_id); 

    void set_body_force(std::unique_ptr<Function<dim>> body_force); 

    void apply(const double                                      current_time, 
               const LinearAlgebra::distributed::Vector<Number> &src, 
               LinearAlgebra::distributed::Vector<Number> &      dst) const; 

    void 
    perform_stage(const Number cur_time, 
                  const Number factor_solution, 
                  const Number factor_ai, 
                  const LinearAlgebra::distributed::Vector<Number> &current_ri, 
                  LinearAlgebra::distributed::Vector<Number> &      vec_ki, 
                  LinearAlgebra::distributed::Vector<Number> &      solution, 
                  LinearAlgebra::distributed::Vector<Number> &next_ri) const; 

    void project(const Function<dim> &                       function, 
                 LinearAlgebra::distributed::Vector<Number> &solution) const; 

    std::array<double, 3> compute_errors( 
      const Function<dim> &                             function, 
      const LinearAlgebra::distributed::Vector<Number> &solution) const; 

    double compute_cell_transport_speed( 
      const LinearAlgebra::distributed::Vector<Number> &solution) const; 

    void 
    initialize_vector(LinearAlgebra::distributed::Vector<Number> &vector) const; 

  private: 
    MatrixFree<dim, Number> data; 

    TimerOutput &timer; 

    std::map<types::boundary_id, std::unique_ptr<Function<dim>>> 
      inflow_boundaries; 
    std::map<types::boundary_id, std::unique_ptr<Function<dim>>> 
                                   subsonic_outflow_boundaries; 
    std::set<types::boundary_id>   wall_boundaries; 
    std::unique_ptr<Function<dim>> body_force; 

    void local_apply_inverse_mass_matrix( 
      const MatrixFree<dim, Number> &                   data, 
      LinearAlgebra::distributed::Vector<Number> &      dst, 
      const LinearAlgebra::distributed::Vector<Number> &src, 
      const std::pair<unsigned int, unsigned int> &     cell_range) const; 

    void local_apply_cell( 
      const MatrixFree<dim, Number> &                   data, 
      LinearAlgebra::distributed::Vector<Number> &      dst, 
      const LinearAlgebra::distributed::Vector<Number> &src, 
      const std::pair<unsigned int, unsigned int> &     cell_range) const; 

    void local_apply_face( 
      const MatrixFree<dim, Number> &                   data, 
      LinearAlgebra::distributed::Vector<Number> &      dst, 
      const LinearAlgebra::distributed::Vector<Number> &src, 
      const std::pair<unsigned int, unsigned int> &     face_range) const; 

    void local_apply_boundary_face( 
      const MatrixFree<dim, Number> &                   data, 
      LinearAlgebra::distributed::Vector<Number> &      dst, 
      const LinearAlgebra::distributed::Vector<Number> &src, 
      const std::pair<unsigned int, unsigned int> &     face_range) const; 
  }; 

  template <int dim, int degree, int n_points_1d> 
  EulerOperator<dim, degree, n_points_1d>::EulerOperator(TimerOutput &timer) 
    : timer(timer) 
  {} 

// 对于欧拉算子的初始化，我们设置了类中包含的MatrixFree变量。这可以通过给定一个描述可能的弯曲边界的映射以及一个描述自由度的DoFHandler对象来完成。由于我们在这个教程程序中使用的是不连续的Galerkin离散化，没有对解场施加强烈的约束，所以我们不需要传入AffineConstraints对象，而是使用一个假的来构造。关于正交，我们要选择两种不同的方式来计算基础积分。第一种是灵活的，基于模板参数`n_points_1d`（将被分配到本文件顶部指定的`n_q_points_1d`值）。更精确的积分是必要的，以避免由于欧拉算子中的可变系数而产生的混叠问题。第二个不太精确的正交公式是一个基于`fe_degree+1`的严密公式，需要用于反质量矩阵。虽然该公式只在仿生元素形状上提供了精确的反，而在变形元素上则没有，但它可以通过张量积技术快速反转质量矩阵，这对于确保整体的最佳计算效率是必要的。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::reinit( 
    const Mapping<dim> &   mapping, 
    const DoFHandler<dim> &dof_handler) 
  { 
    const std::vector<const DoFHandler<dim> *> dof_handlers = {&dof_handler}; 
    const AffineConstraints<double>            dummy; 
    const std::vector<const AffineConstraints<double> *> constraints = {&dummy}; 
    const std::vector<Quadrature<1>> quadratures = {QGauss<1>(n_q_points_1d), 
                                                    QGauss<1>(fe_degree + 1)}; 

    typename MatrixFree<dim, Number>::AdditionalData additional_data; 
    additional_data.mapping_update_flags = 
      (update_gradients | update_JxW_values | update_quadrature_points | 
       update_values); 
    additional_data.mapping_update_flags_inner_faces = 
      (update_JxW_values | update_quadrature_points | update_normal_vectors | 
       update_values); 
    additional_data.mapping_update_flags_boundary_faces = 
      (update_JxW_values | update_quadrature_points | update_normal_vectors | 
       update_values); 
    additional_data.tasks_parallel_scheme = 
      MatrixFree<dim, Number>::AdditionalData::none; 

    data.reinit( 
      mapping, dof_handlers, constraints, quadratures, additional_data); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::initialize_vector( 
    LinearAlgebra::distributed::Vector<Number> &vector) const 
  { 
    data.initialize_dof_vector(vector); 
  } 

// 随后的四个成员函数是必须从外部调用的，以指定各种类型的边界。对于一个流入的边界，我们必须以密度  $\rho$  、动量  $\rho \mathbf{u}$  和能量  $E$  来指定所有成分。考虑到这些信息，我们将函数与各自的边界ID一起存储在这个类的地图成员变量中。同样，我们对亚音速外流边界（我们也要求一个函数，用来检索能量）和壁面（无穿透）边界进行处理，在壁面上我们施加零法线速度（不需要函数，所以我们只要求边界ID）。对于目前的DG代码来说，边界条件只作为弱形式的一部分被应用（在时间积分期间），设置边界条件的调用可以出现在对这个类的`reinit()`调用之前或之后。这与连续有限元代码不同，在连续有限元代码中，边界条件决定了被送入MatrixFree初始化的AffineConstraints对象的内容，因此需要在无矩阵数据结构的初始化之前设置。

// 在四个函数中的每一个中添加的检查是用来确保边界条件在边界的各个部分是相互排斥的，也就是说，用户不会意外地将一个边界既指定为流入边界，又指定为亚声速流出边界。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_inflow_boundary( 
    const types::boundary_id       boundary_id, 
    std::unique_ptr<Function<dim>> inflow_function) 
  { 
    AssertThrow(subsonic_outflow_boundaries.find(boundary_id) == 
                    subsonic_outflow_boundaries.end() && 
                  wall_boundaries.find(boundary_id) == wall_boundaries.end(), 
 
 
 
 
 
                ExcMessage("Expected function with dim+2 components")); 

    inflow_boundaries[boundary_id] = std::move(inflow_function); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_subsonic_outflow_boundary( 
    const types::boundary_id       boundary_id, 
    std::unique_ptr<Function<dim>> outflow_function) 
  { 
    AssertThrow(inflow_boundaries.find(boundary_id) == 
                    inflow_boundaries.end() && 
                  wall_boundaries.find(boundary_id) == wall_boundaries.end(), 
                ExcMessage("You already set the boundary with id " + 
                           std::to_string(static_cast<int>(boundary_id)) + 
                           " to another type of boundary before now setting " + 
                           "it as subsonic outflow")); 
    AssertThrow(outflow_function->n_components == dim + 2, 
                ExcMessage("Expected function with dim+2 components")); 

    subsonic_outflow_boundaries[boundary_id] = std::move(outflow_function); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_wall_boundary( 
    const types::boundary_id boundary_id) 
  { 
    AssertThrow(inflow_boundaries.find(boundary_id) == 
                    inflow_boundaries.end() && 
                  subsonic_outflow_boundaries.find(boundary_id) == 
                    subsonic_outflow_boundaries.end(), 
                ExcMessage("You already set the boundary with id " + 
                           std::to_string(static_cast<int>(boundary_id)) + 
                           " to another type of boundary before now setting " + 
                           "it as wall boundary")); 

    wall_boundaries.insert(boundary_id); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_body_force( 
    std::unique_ptr<Function<dim>> body_force) 
  { 
    AssertDimension(body_force->n_components, dim); 

    this->body_force = std::move(body_force); 
  } 

//  @sect4{Local evaluators}  

// 现在我们开始研究欧拉问题的局部评估器。评估器相对简单，遵循  step-37  、  step-48  或  step-59  中提出的内容。第一个显著的区别是，我们使用的是具有非标准正交点数量的FEE评估。以前我们总是将正交点的数量设置为等于多项式度数加1（确保在仿生元素形状上的精确积分），现在我们将正交点的数量设置为一个单独的变量（例如多项式度数加多项式度数的二分之一或三分之一），以更准确地处理非线性项。由于评估器通过模板参数输入了适当的循环长度，并在变量 FEEvaluation::n_q_points, 中保留了整个单元格的正交点数量，所以我们现在自动操作更精确的公式，而无需进一步修改。

// 第二个区别是由于我们现在评估的是一个多分量系统，而不是之前考虑的标量系统。无矩阵框架提供了几种方法来处理多成分的情况。这里显示的变体是利用一个嵌入了多个分量的FEEvaluation对象，由第四个模板参数`dim + 2`指定欧拉系统中的分量。因此， FEEvaluation::get_value() 的返回类型不再是一个标量（这将返回一个VectorizedArray类型，收集几个元素的数据），而是一个`dim+2`组件的张量。该功能与标量的情况类似；它由一个基类的模板专业化处理，称为FEEvaluationAccess。另一个变体是使用几个FEEvaluation对象，一个标量对象用于密度，一个带`dim`分量的矢量值对象用于动量，另一个标量评价器用于能量。为了确保这些分量指向解决方案的正确部分，FEEvaluation的构造函数在所需的MatrixFree字段之后需要三个可选的整数参数，即多DoFHandler系统的DoFHandler编号（默认取第一个），如果有多个Quadrature对象，则取正交点的编号（见下文），以及作为第三个参数的矢量系统中的分量。由于我们有一个单一的矢量来表示所有的分量，我们将使用第三个参数，并将其设置为`0`表示密度，`1`表示矢量值的动量，`dim+1`表示能量槽。然后FEEvaluation在 FEEvaluationBase::read_dof_values() 和 FEEvaluation::distributed_local_to_global() 或更紧凑的 FEEvaluation::gather_evaluate() 和 FEEvaluation::integrate_scatter() 调用中挑选适当的解矢量子范围。

// 当涉及到身体力向量的评估时，为了效率，我们区分了两种情况。如果我们有一个常数函数（源自 Functions::ConstantFunction), ），我们可以在正交点的循环外预先计算出数值，并简单地在所有地方使用该数值。对于一个更通用的函数，我们反而需要调用我们上面提供的`evaluate_function()`方法；这个路径更昂贵，因为我们需要访问与正交点数据有关的内存。

// 其余部分沿用其他教程的程序。由于我们已经在单独的`euler_flux()`函数中实现了欧拉方程的所有物理学，我们在这里所要做的就是给定在正交点评估的当前解，由`phi.get_value(q)`返回，并告诉FEEvaluation对象，通过形状函数的梯度（这是一个外部`dim+2`分量的张量，每个张量持有一个`dim`分量的 $x,y,z$  ] 欧拉通量的分量）。) 最后值得一提的是，在我们得到一个外部函数的情况下，我们通过测试函数`phi.submit_value()`的值来排队测试数据的顺序。我们必须在调用`phi.get_value(q)'之后进行，因为`get_value()'（读取解决方案）和`submit_value()'（排队等待测试函数的乘法和正交点的求和）访问同一个底层数据域。这里很容易实现没有临时变量`w_q`，因为值和梯度之间没有混合。对于更复杂的设置，必须首先复制出例如正交点的值和梯度，然后通过 FEEvaluationBase::submit_value() 和 FEEvaluationBase::submit_gradient(). 再次排列结果。

// 作为最后的说明，我们提到我们没有使用这个函数的第一个MatrixFree参数，这是一个来自 MatrixFree::loop(). 的回调，接口规定了现在的参数列表，但是由于我们在一个成员函数中，MatrixFree对象已经可以作为`data`变量，我们坚持使用，以避免混淆。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::local_apply_cell( 
    const MatrixFree<dim, Number> &, 
    LinearAlgebra::distributed::Vector<Number> &      dst, 
    const LinearAlgebra::distributed::Vector<Number> &src, 
    const std::pair<unsigned int, unsigned int> &     cell_range) const 
  { 
    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data); 

    Tensor<1, dim, VectorizedArray<Number>> constant_body_force; 
    const Functions::ConstantFunction<dim> *constant_function = 
      dynamic_cast<Functions::ConstantFunction<dim> *>(body_force.get()); 

    if (constant_function) 
      constant_body_force = evaluate_function<dim, Number, dim>( 
        *constant_function, Point<dim, VectorizedArray<Number>>()); 

    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        phi.reinit(cell); 
        phi.gather_evaluate(src, EvaluationFlags::values); 

        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            const auto w_q = phi.get_value(q); 
            phi.submit_gradient(euler_flux<dim>(w_q), q); 
            if (body_force.get() != nullptr) 
              { 
                const Tensor<1, dim, VectorizedArray<Number>> force = 
                  constant_function ? constant_body_force : 
                                      evaluate_function<dim, Number, dim>( 
                                        *body_force, phi.quadrature_point(q)); 

                Tensor<1, dim + 2, VectorizedArray<Number>> forcing; 
                for (unsigned int d = 0; d < dim; ++d) 
                  forcing[d + 1] = w_q[0] * force[d]; 
                for (unsigned int d = 0; d < dim; ++d) 
                  forcing[dim + 1] += force[d] * w_q[d + 1]; 

                phi.submit_value(forcing, q); 
              } 
          } 

        phi.integrate_scatter(((body_force.get() != nullptr) ? 
                                 EvaluationFlags::values : 
                                 EvaluationFlags::nothing) | 
                                EvaluationFlags::gradients, 
                              dst); 
      } 
  } 

// 下一个函数涉及到内部面的积分计算，在这里我们需要与面相邻的两个单元的评估器。我们将变量`phi_m`与解分量 $\mathbf{w}^-$ 相关联，将变量`phi_p`与解分量 $\mathbf{w}^+$ 相关联。我们在FEFaceEvaluation的构造函数中通过第二个参数来区分两边，`true`表示内侧，`false`表示外侧，内侧和外侧表示相对于法向量的方向。

// 注意调用 FEFaceEvaluation::gather_evaluate() 和 FEFaceEvaluation::integrate_scatter() 结合了对向量的访问和因式分解部分。这种合并操作不仅节省了一行代码，而且还包含了一个重要的优化。鉴于我们在Gauss-Lobatto正交公式的点上使用拉格朗日多项式的节点基础，在每个面上只有 $(p+1)^{d-1}$ 的基础函数评估为非零。因此，评估器只访问了向量中的必要数据，而跳过了乘以零的部分。如果我们首先读取向量，我们就需要从向量中加载所有的数据，因为孤立的调用不知道后续操作中需要哪些数据。如果随后的 FEFaceEvaluation::evaluate() 调用要求数值和导数，确实需要每个分量的所有 $(p+1)^d$ 向量条目，因为所有基函数的法向导数都是非零的。

// 评价器的参数以及程序与单元评价相似。由于非线性项的存在，我们再次使用更精确的（过度）积分方案，指定为列表中第三个模板参数。在正交点上，我们再去找我们的自由函数来计算数值通量。它从两边（即 $\mathbf{w}^-$ 和 $\mathbf{w}^+$ ）接收在正交点评估的解决方案，以及到减去一边的法向量。正如上面所解释的，数值通量已经乘以来自减法侧的法向量了。我们需要转换符号，因为在引言中得出的弱形式中，边界项带有一个减号。然后，通量被排队在减号和加号上进行测试，由于加号上的法向量与减号上的法向量正好相反，所以要调换符号。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::local_apply_face( 
    const MatrixFree<dim, Number> &, 
    LinearAlgebra::distributed::Vector<Number> &      dst, 
    const LinearAlgebra::distributed::Vector<Number> &src, 
    const std::pair<unsigned int, unsigned int> &     face_range) const 
  { 
    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi_m(data, 
                                                                      true); 
    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi_p(data, 
                                                                      false); 

    for (unsigned int face = face_range.first; face < face_range.second; ++face) 
      { 
        phi_p.reinit(face); 
        phi_p.gather_evaluate(src, EvaluationFlags::values); 

        phi_m.reinit(face); 
        phi_m.gather_evaluate(src, EvaluationFlags::values); 

        for (unsigned int q = 0; q < phi_m.n_q_points; ++q) 
          { 
            const auto numerical_flux = 
              euler_numerical_flux<dim>(phi_m.get_value(q), 
                                        phi_p.get_value(q), 
                                        phi_m.get_normal_vector(q)); 
            phi_m.submit_value(-numerical_flux, q); 
            phi_p.submit_value(numerical_flux, q); 
          } 

        phi_p.integrate_scatter(EvaluationFlags::values, dst); 
        phi_m.integrate_scatter(EvaluationFlags::values, dst); 
      } 
  } 

// 对于位于边界的面，我们需要施加适当的边界条件。在这个教程程序中，我们实现了上述的四种情况。第五种情况，即超音速流出条件，将在下面的 "结果 "部分讨论）。不连续的Galerkin方法对边界条件的施加不是作为约束条件，而只是弱化。因此，各种条件是通过找到一个适当的<i>exterior</i>量 $\mathbf{w}^+$ 来施加的，然后将其交给也用于内部面的数值通量函数。实质上，我们在域外 "假装 "一个状态，如果那是现实，PDE的解将满足我们想要的边界条件。

// 对于墙的边界，我们需要对动量变量施加一个无正态通量的条件，而对于密度和能量，我们使用的是诺伊曼条件  $\rho^+ = \rho^-$  和  $E^+ = E^-$  。为了实现无正态通量条件，我们将外部数值设定为内部数值，并减去墙面法线方向，即法线矢量方向上的速度的2倍。

// 对于流入边界，我们简单地将给定的Dirichlet数据 $\mathbf{w}_\mathrm{D}$ 作为边界值。另一种方法是使用 $\mathbf{w}^+ = -\mathbf{w}^- + 2 \mathbf{w}_\mathrm{D}$  ，即所谓的镜像原理。

// 强加外流本质上是一个诺伊曼条件，即设定  $\mathbf{w}^+ = \mathbf{w}^-$  。对于亚声速流出的情况，我们仍然需要强加一个能量值，我们从各自的函数中得出这个值。对于<i>backflow</i>的情况，即在Neumann部分有动量通入域的情况，需要一个特殊的步骤。根据文献（这一事实可以通过适当的能量论证得出），我们必须切换到流入部分的通量的另一个变体，见Gravemeier, Comerford, Yoshihara, Ismail, Wall, "A novel formulation for Neumann inflow conditions in biomechanics", Int. J. Numer. Meth. 生物医学。Eng., vol. 28 (2012). 这里，动量项需要再次添加，这相当于去除动量变量上的通量贡献。我们在后处理步骤中这样做，而且只适用于我们都处于外流边界且法向量与动量（或等同于速度）之间的点积为负的情况。由于我们在SIMD矢量化中一次处理多个正交点的数据，这里需要明确地在SIMD数组的条目上循环。

// 在下面的实现中，我们在正交点的层面上检查各种类型的边界。当然，我们也可以将决定权移出正交点循环，将整个面孔视为同类，这就避免了在正交点的内循环中进行一些地图/集合的查找。然而，效率的损失并不明显，所以我们在这里选择了更简单的代码。还要注意的是，最后的 "else "子句会捕捉到这样的情况，即边界的某些部分没有通过 `EulerOperator::set_..._boundary(...)`. 分配任何边界条件。
  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::local_apply_boundary_face( 
    const MatrixFree<dim, Number> &, 
    LinearAlgebra::distributed::Vector<Number> &      dst, 
    const LinearAlgebra::distributed::Vector<Number> &src, 
    const std::pair<unsigned int, unsigned int> &     face_range) const 
  { 
    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data, true); 

    for (unsigned int face = face_range.first; face < face_range.second; ++face) 
      { 
        phi.reinit(face); 
        phi.gather_evaluate(src, EvaluationFlags::values); 

        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            const auto w_m    = phi.get_value(q); 
            const auto normal = phi.get_normal_vector(q); 

            auto rho_u_dot_n = w_m[1] * normal[0]; 
            for (unsigned int d = 1; d < dim; ++d) 
              rho_u_dot_n += w_m[1 + d] * normal[d]; 

            bool at_outflow = false; 

            Tensor<1, dim + 2, VectorizedArray<Number>> w_p; 
            const auto boundary_id = data.get_boundary_id(face); 
            if (wall_boundaries.find(boundary_id) != wall_boundaries.end()) 
              { 
                w_p[0] = w_m[0]; 
                for (unsigned int d = 0; d < dim; ++d) 
                  w_p[d + 1] = w_m[d + 1] - 2. * rho_u_dot_n * normal[d]; 
                w_p[dim + 1] = w_m[dim + 1]; 
              } 
            else if (inflow_boundaries.find(boundary_id) != 
                     inflow_boundaries.end()) 
              w_p = 
                evaluate_function(*inflow_boundaries.find(boundary_id)->second, 
                                  phi.quadrature_point(q)); 
            else if (subsonic_outflow_boundaries.find(boundary_id) != 
                     subsonic_outflow_boundaries.end()) 
              { 
                w_p          = w_m; 
                w_p[dim + 1] = evaluate_function( 
                  *subsonic_outflow_boundaries.find(boundary_id)->second, 
                  phi.quadrature_point(q), 
                  dim + 1); 
                at_outflow = true; 
              } 
            else 
              AssertThrow(false, 
                          ExcMessage("Unknown boundary id, did " 
                                     "you set a boundary condition for " 
                                     "this part of the domain boundary?")); 

            auto flux = euler_numerical_flux<dim>(w_m, w_p, normal); 

            if (at_outflow) 
              for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v) 
                { 
                  if (rho_u_dot_n[v] < -1e-12) 
                    for (unsigned int d = 0; d < dim; ++d) 
                      flux[d + 1][v] = 0.; 
                } 

            phi.submit_value(-flux, q); 
          } 

        phi.integrate_scatter(EvaluationFlags::values, dst); 
      } 
  } 

// 下一个函数实现了质量矩阵的逆运算。在介绍中已经广泛讨论了算法和原理，所以我们在这里只讨论 MatrixFreeOperators::CellwiseInverseMassMatrix 类的技术问题。它所做的操作与质量矩阵的正向评估类似，只是使用了不同的插值矩阵，代表逆 $S^{-1}$ 因子。这些代表了从指定的基础（在这种情况下，高斯--洛巴托正交公式点中的拉格朗日基础）到高斯正交公式点中的拉格朗日基础的改变。在后者的基础上，我们可以应用点的逆向`JxW`因子，即正交权重乘以从参考坐标到实坐标的映射的雅各布系数。一旦完成了这一操作，基数将再次变回节点高斯-洛巴托基数。所有这些操作都由下面的 "apply() "函数完成。我们需要提供的是要操作的局部场（我们通过一个FEEvaluation对象从全局向量中提取），并将结果写回质量矩阵操作的目标向量。

// 需要注意的一点是，我们在FEEvaluation的构造函数中添加了两个整数参数（可选），第一个是0（在多DoFHandler系统中选择DoFHandler；在这里，我们只有一个），第二个是1，用于进行正交公式选择。由于我们将正交公式0用于非线性项的过度积分，我们使用公式1与默认的 $p+1$ （或变量名称中的`fe_degree+1`）点用于质量矩阵。这导致了对质量矩阵的平方贡献，并确保了精确的积分，正如介绍中所解释的。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::local_apply_inverse_mass_matrix( 
    const MatrixFree<dim, Number> &, 
    LinearAlgebra::distributed::Vector<Number> &      dst, 
    const LinearAlgebra::distributed::Vector<Number> &src, 
    const std::pair<unsigned int, unsigned int> &     cell_range) const 
  { 
    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1); 
    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, degree, dim + 2, Number> 
      inverse(phi); 

    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell) 
      { 
        phi.reinit(cell); 
        phi.read_dof_values(src); 

        inverse.apply(phi.begin_dof_values(), phi.begin_dof_values()); 

        phi.set_dof_values(dst); 
      } 
  } 

//  @sect4{The apply() and related functions}  

// 我们现在来到实现欧拉算子整体评估的函数，即 $\mathcal M^{-1} \mathcal L(t, \mathbf{w})$  ，调用上面介绍的局部评估器。这些步骤在前面的代码中应该是清楚的。需要注意的一点是，我们需要调整与边界各部分相关的函数中的时间，以便在边界数据与时间相关的情况下与方程一致。然后，我们调用 MatrixFree::loop() 来执行单元和面的积分，包括在`src`向量中进行必要的ghost数据交换。该函数的第七个参数，"true"，指定我们要在开始向其累积积分之前，将 "dst "向量作为循环的一部分归零。这个变体比在循环之前明确调用`dst = 0.;`要好，因为归零操作是在矢量的子范围内完成的，其部分是由附近的积分写入的。这加强了数据的定位，并允许缓存，节省了向量数据到主内存的一次往返，提高了性能。循环的最后两个参数决定了哪些数据被交换：由于我们只访问一个面的形状函数的值，这是典型的一阶双曲问题，并且由于我们有一个节点基础，节点位于参考元素表面，我们只需要交换这些部分。这又节省了宝贵的内存带宽。

// 一旦应用了空间算子 $\mathcal L$ ，我们需要进行第二轮操作，应用反质量矩阵。这里，我们调用 MatrixFree::cell_loop() ，因为只有单元格积分出现。单元循环比全循环更便宜，因为只访问与本地拥有的单元相关的自由度，这只是DG离散化的本地拥有的自由度。因此，这里不需要鬼魂交换。

// 在所有这些函数的周围，我们设置了定时器范围来记录计算时间，以统计各部分的贡献。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::apply( 
    const double                                      current_time, 
    const LinearAlgebra::distributed::Vector<Number> &src, 
    LinearAlgebra::distributed::Vector<Number> &      dst) const 
  { 
    { 
      TimerOutput::Scope t(timer, "apply - integrals"); 

      for (auto &i : inflow_boundaries) 
        i.second->set_time(current_time); 
      for (auto &i : subsonic_outflow_boundaries) 
        i.second->set_time(current_time); 

      data.loop(&EulerOperator::local_apply_cell, 
                &EulerOperator::local_apply_face, 
                &EulerOperator::local_apply_boundary_face, 
                this, 
                dst, 
                src, 
                true, 
                MatrixFree<dim, Number>::DataAccessOnFaces::values, 
                MatrixFree<dim, Number>::DataAccessOnFaces::values); 
    } 

    { 
      TimerOutput::Scope t(timer, "apply - inverse mass"); 

      data.cell_loop(&EulerOperator::local_apply_inverse_mass_matrix, 
                     this, 
                     dst, 
                     dst); 
    } 
  } 

// 让我们转到做Runge--Kutta更新的整个阶段的函数。它调用 EulerOperator::apply() ，然后对向量进行一些更新，即`next_ri = solution + factor_ai * k_i`和`solution += factor_solution * k_i`。与其通过向量接口执行这些步骤，我们在这里提出了一个替代策略，在基于缓存的架构上速度更快。由于向量所消耗的内存往往比缓存所能容纳的要大得多，因此数据必须有效地来自缓慢的RAM内存。这种情况可以通过循环融合来改善，即在一次扫描中对`next_ki`和`solution`进行更新。在这种情况下，我们将读取两个向量`rhs`和`solution`并写入`next_ki`和`solution`，而在基线情况下，至少有4次读取和两次写入。在这里，我们更进一步，当质量矩阵反转在向量的某一部分完成后，立即执行循环。  MatrixFree::cell_loop() 提供了一种机制，在单元格的循环第一次接触到一个向量条目之前，附加一个 `std::function` （我们在这里没有使用，但用于例如向量的归零），以及在循环最后接触到一个条目之后，调用第二个 `std::function` 。回调的形式是给定向量上的一个范围（就MPI宇宙中的本地索引编号而言），可以由`local_element()`函数来处理。

// 对于这个第二个回调，我们创建一个lambda，在一个范围内工作，并在这个范围内写入相应的更新。理想情况下，我们会在本地循环之前添加`DEAL_II_OPENMP_SIMD_PRAGMA`，以建议编译器对这个循环进行SIMD并行化（这意味着在实践中我们要确保在循环内部使用的指针的索引范围之间没有重叠，也称为别名）。事实证明，在写这篇文章的时候，GCC 7.2无法编译lambda函数中的OpenMP pragma，所以我们在下面注释了这个pragma。如果你的编译器比较新，你应该可以再次取消注释这些行。

// 注意，当我们不需要更新`next_ri`向量时，我们为最后的Runge--Kutta阶段选择不同的代码路径。这个策略带来了相当大的速度提升。在40核机器上，默认矢量更新时，逆质量矩阵和矢量更新需要60%以上的计算时间，而在更优化的变体中，这一比例约为35%。换句话说，这是一个大约三分之一的速度提升。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::perform_stage( 
    const Number                                      current_time, 
    const Number                                      factor_solution, 
    const Number                                      factor_ai, 
    const LinearAlgebra::distributed::Vector<Number> &current_ri, 
    LinearAlgebra::distributed::Vector<Number> &      vec_ki, 
    LinearAlgebra::distributed::Vector<Number> &      solution, 
    LinearAlgebra::distributed::Vector<Number> &      next_ri) const 
  { 
    { 
      TimerOutput::Scope t(timer, "rk_stage - integrals L_h"); 

      for (auto &i : inflow_boundaries) 
        i.second->set_time(current_time); 
      for (auto &i : subsonic_outflow_boundaries) 
        i.second->set_time(current_time); 

      data.loop(&EulerOperator::local_apply_cell, 
                &EulerOperator::local_apply_face, 
                &EulerOperator::local_apply_boundary_face, 
                this, 
                vec_ki, 
                current_ri, 
                true, 
                MatrixFree<dim, Number>::DataAccessOnFaces::values, 
                MatrixFree<dim, Number>::DataAccessOnFaces::values); 
    } 

    { 
      TimerOutput::Scope t(timer, "rk_stage - inv mass + vec upd"); 
      data.cell_loop( 
        &EulerOperator::local_apply_inverse_mass_matrix, 
        this, 
        next_ri, 
        vec_ki, 
        std::function<void(const unsigned int, const unsigned int)>(), 
        [&](const unsigned int start_range, const unsigned int end_range) { 
          const Number ai = factor_ai; 
          const Number bi = factor_solution; 
          if (ai == Number()) 
            { 

          /* DEAL_II_OPENMP_SIMD_PRAGMA  */ 
              for (unsigned int i = start_range; i < end_range; ++i) 
                { 
                  const Number k_i          = next_ri.local_element(i); 
                  const Number sol_i        = solution.local_element(i); 
                  solution.local_element(i) = sol_i + bi * k_i; 
                } 
            } 
          else 
            { 

              /* DEAL_II_OPENMP_SIMD_PRAGMA  */ 
              for (unsigned int i = start_range; i < end_range; ++i) 
                { 
                  const Number k_i          = next_ri.local_element(i); 
                  const Number sol_i        = solution.local_element(i); 
                  solution.local_element(i) = sol_i + bi * k_i; 
                  next_ri.local_element(i)  = sol_i + ai * k_i; 
                } 
            } 
        }); 
    } 
  } 

// 在讨论了将解提前一个时间步长的函数的实现后，现在让我们来看看实现其他辅助性操作的函数。具体来说，这些是计算投影、评估误差和计算单元上信息传输速度的函数。

// 这些函数中的第一个基本上等同于 VectorTools::project(), ，只是速度快得多，因为它是专门针对DG元素的，不需要设置和解决线性系统，因为每个元素都有独立的基函数。我们在这里展示代码的原因，除了这个非关键操作的小幅提速之外，还因为它显示了 MatrixFreeOperators::CellwiseInverseMassMatrix. 提供的额外功能。

// 投影操作的工作原理如下。如果我们用 $S$ 表示在正交点评估的形状函数矩阵，那么在单元格 $K$ 上的投影是一个形式为 $\underbrace{S J^K S^\mathrm T}_{\mathcal M^K} \mathbf{w}^K = S J^K \tilde{\mathbf{w}}(\mathbf{x}_q)_{q=1:n_q}$ 的操作，其中 $J^K$ 是包含雅各布系数乘以正交权重（JxW）的对角矩阵， $\mathcal M^K$ 是单元格的质量矩阵， $\tilde{\mathbf{w}}(\mathbf{x}_q)_{q=1:n_q}$ 是要投影到正交点的领域评估。实际上，矩阵 $S$ 通过张量积有额外的结构，如介绍中所解释的）。这个系统现在可以等效地写成 $\mathbf{w}^K = \left(S J^K S^\mathrm T\right)^{-1} S J^K \tilde{\mathbf{w}}(\mathbf{x}_q)_{q=1:n_q} = S^{-\mathrm T} \left(J^K\right)^{-1} S^{-1} S J^K \tilde{\mathbf{w}}(\mathbf{x}_q)_{q=1:n_q}$  。现在，项 $S^{-1} S$ 和 $\left(J^K\right)^{-1} J^K$ 相抵消，导致最后的表达式 $\mathbf{w}^K = S^{-\mathrm T} \tilde{\mathbf{w}}(\mathbf{x}_q)_{q=1:n_q}$  。这个操作由 MatrixFreeOperators::CellwiseInverseMassMatrix::transform_from_q_points_to_basis(). 实现。这个名字来自于这个投影只是乘以 $S^{-\mathrm T}$ ，一个从高斯正交点的节点基到给定的有限元基的基数变化。请注意，我们调用 FEEvaluation::set_dof_values() 将结果写入矢量，覆盖之前的内容，而不是像典型的积分任务那样累积结果--我们可以这样做，因为对于不连续的Galerkin离散，每个矢量条目都只有一个单元的贡献。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::project( 
    const Function<dim> &                       function, 
    LinearAlgebra::distributed::Vector<Number> &solution) const 
  { 
    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1); 
    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, degree, dim + 2, Number> 
      inverse(phi); 
    solution.zero_out_ghost_values(); 
    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          phi.submit_dof_value(evaluate_function(function, 
                                                 phi.quadrature_point(q)), 
                               q); 
        inverse.transform_from_q_points_to_basis(dim + 2, 
                                                 phi.begin_dof_values(), 
                                                 phi.begin_dof_values()); 
        phi.set_dof_values(solution); 
      } 
  } 

// 下一个函数再次重复了同样由deal.II库提供的功能，即 VectorTools::integrate_difference(). 我们在这里展示了明确的代码，以强调跨几个单元的矢量化是如何工作的，以及如何通过该接口累积结果。回顾一下，每个<i>lane</i>的矢量化数组持有来自不同单元的数据。通过对当前MPI进程所拥有的所有单元批的循环，我们就可以填充一个结果的VectorizedArray；为了得到一个全局的总和，我们需要进一步去对SIMD阵列中的条目进行求和。然而，这样的程序并不稳定，因为SIMD数组事实上可能并不持有其所有通道的有效数据。当本地拥有的单元的数量不是SIMD宽度的倍数时，就会发生这种情况。为了避免无效数据，我们必须在访问数据时明确地跳过那些无效的通道。虽然人们可以想象，我们可以通过简单地将空车道设置为零（从而不对总和做出贡献）来使其工作，但情况比这更复杂。如果我们要从动量中计算出一个速度呢？那么，我们就需要除以密度，而密度是零--结果就会是NaN，并污染结果。当我们在单元格批次中循环时，使用函数 MatrixFree::n_active_entries_per_cell_batch() 给我们提供有效数据的通道数，累积有效SIMD范围内的结果，就可以避免这种陷阱。它在大多数单元上等于 VectorizedArray::size() ，但如果单元数与SIMD宽度相比有余数，则在最后一个单元批上可能会更少。

  template <int dim, int degree, int n_points_1d> 
  std::array<double, 3> EulerOperator<dim, degree, n_points_1d>::compute_errors( 
    const Function<dim> &                             function, 
    const LinearAlgebra::distributed::Vector<Number> &solution) const 
  { 
    TimerOutput::Scope t(timer, "compute errors"); 
    double             errors_squared[3] = {}; 
    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data, 0, 0); 

    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        phi.gather_evaluate(solution, EvaluationFlags::values); 
        VectorizedArray<Number> local_errors_squared[3] = {}; 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            const auto error = 
              evaluate_function(function, phi.quadrature_point(q)) - 
              phi.get_value(q); 
            const auto JxW = phi.JxW(q); 

            local_errors_squared[0] += error[0] * error[0] * JxW; 
            for (unsigned int d = 0; d < dim; ++d) 
              local_errors_squared[1] += (error[d + 1] * error[d + 1]) * JxW; 
            local_errors_squared[2] += (error[dim + 1] * error[dim + 1]) * JxW; 
          } 
        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell); 
             ++v) 
          for (unsigned int d = 0; d < 3; ++d) 
            errors_squared[d] += local_errors_squared[d][v]; 
      } 

    Utilities::MPI::sum(errors_squared, MPI_COMM_WORLD, errors_squared); 

    std::array<double, 3> errors; 
    for (unsigned int d = 0; d < 3; ++d) 
      errors[d] = std::sqrt(errors_squared[d]); 

    return errors; 
  } 

// EulerOperator类的最后一个函数是用来估计传输速度的，由网格大小缩放，这与设置显式时间积分器的时间步长有关。在欧拉方程中，有两种传输速度，即对流速度 $\mathbf{u}$ 和相对于以速度 $\mathbf u$ 运动的介质而言，声波的传播速度 $c = \sqrt{\gamma p/\rho}$  。

// 在时间步长的公式中，我们感兴趣的不是这些绝对速度，而是信息穿过一个单元所需的时间量。对于与介质一起传输的信息， $\mathbf u$ 是由网格大小缩放的，所以最大速度的估计可以通过计算 $\|J^{-\mathrm T} \mathbf{u}\|_\infty$  得到，其中 $J$ 是实域到参考域的转换的雅各布。请注意， FEEvaluationBase::inverse_jacobian() 返回的是反转和转置的雅各布，代表从实数到参考坐标的度量项，所以我们不需要再次转置。我们在下面的代码中把这个极限存储在变量`convective_limit`中。

// 声音的传播是各向同性的，所以我们需要考虑到任何方向的网格尺寸。然后，适当的网格大小比例由 $J$ 的最小奇异值给出，或者，等同于 $J^{-1}$ 的最大奇异值。请注意，当忽略弯曲的单元时，可以用单元顶点之间的最小距离来近似这个量。为了得到Jacobian的最大奇异值，一般的策略是使用一些LAPACK函数。由于我们在这里需要的只是一个估计值，所以我们可以避免将一个向量数组的张量分解成几个矩阵的麻烦，并在没有向量的情况下进入一个（昂贵的）特征值函数，而是使用应用于 $J^{-1}J^{-\mathrm T}$ 的幂方法进行几次迭代（在下面的代码中为五次）。这种方法的收敛速度取决于最大特征值与次大特征值的比率以及初始猜测，即所有1的矢量。这可能表明，我们在接近立方体形状的单元上得到缓慢的收敛，在这种情况下，所有的长度几乎都是一样的。然而，这种缓慢的收敛意味着结果将位于两个最大的奇异值之间，而这两个奇异值无论如何都是接近最大值的。在所有其他情况下，收敛将是快速的。因此，我们可以只在这里硬编码5次迭代，并确信结果是好的。

  template <int dim, int degree, int n_points_1d> 
  double EulerOperator<dim, degree, n_points_1d>::compute_cell_transport_speed( 
    const LinearAlgebra::distributed::Vector<Number> &solution) const 
  { 
    TimerOutput::Scope t(timer, "compute transport speed"); 
    Number             max_transport = 0; 
    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1); 

    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        phi.gather_evaluate(solution, EvaluationFlags::values); 
        VectorizedArray<Number> local_max = 0.; 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            const auto solution = phi.get_value(q); 
            const auto velocity = euler_velocity<dim>(solution); 
            const auto pressure = euler_pressure<dim>(solution); 

            const auto inverse_jacobian = phi.inverse_jacobian(q); 
            const auto convective_speed = inverse_jacobian * velocity; 
            VectorizedArray<Number> convective_limit = 0.; 
            for (unsigned int d = 0; d < dim; ++d) 
              convective_limit = 
                std::max(convective_limit, std::abs(convective_speed[d])); 

            const auto speed_of_sound = 
              std::sqrt(gamma * pressure * (1. / solution[0])); 

            Tensor<1, dim, VectorizedArray<Number>> eigenvector; 
            for (unsigned int d = 0; d < dim; ++d) 
              eigenvector[d] = 1.; 
            for (unsigned int i = 0; i < 5; ++i) 
              { 
                eigenvector = transpose(inverse_jacobian) * 
                              (inverse_jacobian * eigenvector); 
                VectorizedArray<Number> eigenvector_norm = 0.; 
                for (unsigned int d = 0; d < dim; ++d) 
                  eigenvector_norm = 
                    std::max(eigenvector_norm, std::abs(eigenvector[d])); 
                eigenvector /= eigenvector_norm; 
              } 
            const auto jac_times_ev   = inverse_jacobian * eigenvector; 
            const auto max_eigenvalue = std::sqrt( 
              (jac_times_ev * jac_times_ev) / (eigenvector * eigenvector)); 
            local_max = 
              std::max(local_max, 
                       max_eigenvalue * speed_of_sound + convective_limit); 
          } 

// 与前面的函数类似，我们必须确保只在一个单元格批次的有效单元格上积累速度。

 
             ++v) 
          for (unsigned int d = 0; d < 3; ++d) 
            max_transport = std::max(max_transport, local_max[v]); 
      } 

    max_transport = Utilities::MPI::max(max_transport, MPI_COMM_WORLD); 

    return max_transport; 
  } 

//  @sect3{The EulerProblem class}  

// 该类将EulerOperator类与时间积分器和通常的全局数据结构（如FiniteElement和DoFHandler）相结合，以实际运行Euler问题的模拟。

// 成员变量是一个三角形、一个有限元、一个映射（用于创建高阶曲面，见 step-10 ），以及一个描述自由度的DoFHandler。此外，我们还保留了上面描述的EulerOperator的实例，它将完成所有积分方面的繁重工作，以及一些时间积分的参数，如当前时间或时间步长。

// 此外，我们使用一个PostProcessor实例来向输出文件写入一些额外的信息，这与  step-33  中的做法类似。DataPostprocessor类的接口很直观，要求我们提供关于需要评估的信息（通常只有解决方案的值，除了Schlieren图，我们只在二维中启用它是有意义的），以及被评估的东西的名称。请注意，也可以通过可视化程序（如ParaView）中的计算器工具来提取大部分信息，但在写输出时就已经做了，这要方便得多。

  template <int dim> 
  class EulerProblem 
  { 
  public: 
    EulerProblem(); 

    void run(); 

  private: 
    void make_grid_and_dofs(); 

    void output_results(const unsigned int result_number); 

    LinearAlgebra::distributed::Vector<Number> solution; 

    ConditionalOStream pcout; 

#ifdef DEAL_II_WITH_P4EST 
    parallel::distributed::Triangulation<dim> triangulation; 
#else 
    Triangulation<dim> triangulation; 
#endif 

    FESystem<dim>        fe; 
    MappingQGeneric<dim> mapping; 
    DoFHandler<dim>      dof_handler; 

    TimerOutput timer; 

    EulerOperator<dim, fe_degree, n_q_points_1d> euler_operator; 

    double time, time_step; 

    class Postprocessor : public DataPostprocessor<dim> 
    { 
    public: 
      Postprocessor(); 

      virtual void evaluate_vector_field( 
        const DataPostprocessorInputs::Vector<dim> &inputs, 
        std::vector<Vector<double>> &computed_quantities) const override; 

      virtual std::vector<std::string> get_names() const override; 

      virtual std::vector< 
        DataComponentInterpretation::DataComponentInterpretation> 
      get_data_component_interpretation() const override; 

      virtual UpdateFlags get_needed_update_flags() const override; 

    private: 
      const bool do_schlieren_plot; 
    }; 
  }; 

  template <int dim> 
  EulerProblem<dim>::Postprocessor::Postprocessor() 
    : do_schlieren_plot(dim == 2) 
  {} 

// 对于字段变量的主要评估，我们首先检查数组的长度是否等于预期值（长度`2*dim+4`或`2*dim+5`来自我们在下面get_names()函数中指定的名字的大小）。然后我们在所有的评估点上循环，填充相应的信息。首先，我们填写密度 $\rho$ 、动量 $\rho \mathbf{u}$ 和能量 $E$ 的原始解变量，然后我们计算得出速度 $\mathbf u$ 、压力 $p$ 、声速 $c=\sqrt{\gamma p / \rho}$ ，以及显示 $s = |\nabla \rho|^2$ 的Schlieren图，如果它被启用。参见 step-69 中另一个创建Schlieren图的例子）。

  template <int dim> 
  void EulerProblem<dim>::Postprocessor::evaluate_vector_field( 
    const DataPostprocessorInputs::Vector<dim> &inputs, 
    std::vector<Vector<double>> &               computed_quantities) const 
  { 
    const unsigned int n_evaluation_points = inputs.solution_values.size(); 

    if (do_schlieren_plot == true) 
      Assert(inputs.solution_gradients.size() == n_evaluation_points, 
             ExcInternalError()); 

    Assert(computed_quantities.size() == n_evaluation_points, 
           ExcInternalError()); 
    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError()); 
    Assert(computed_quantities[0].size() == 
             dim + 2 + (do_schlieren_plot == true ? 1 : 0), 
           ExcInternalError()); 

    for (unsigned int q = 0; q < n_evaluation_points; ++q) 
      { 
        Tensor<1, dim + 2> solution; 
        for (unsigned int d = 0; d < dim + 2; ++d) 
          solution[d] = inputs.solution_values[q](d); 

        const double         density  = solution[0]; 
        const Tensor<1, dim> velocity = euler_velocity<dim>(solution); 
        const double         pressure = euler_pressure<dim>(solution); 

        for (unsigned int d = 0; d < dim; ++d) 
          computed_quantities[q](d) = velocity[d]; 
        computed_quantities[q](dim)     = pressure; 
        computed_quantities[q](dim + 1) = std::sqrt(gamma * pressure / density); 

        if (do_schlieren_plot == true) 
          computed_quantities[q](dim + 2) = 
            inputs.solution_gradients[q][0] * inputs.solution_gradients[q][0]; 
      } 
  } 

  template <int dim> 
  std::vector<std::string> EulerProblem<dim>::Postprocessor::get_names() const 
  { 
    std::vector<std::string> names; 
    for (unsigned int d = 0; d < dim; ++d) 
      names.emplace_back("velocity"); 
    names.emplace_back("pressure"); 
    names.emplace_back("speed_of_sound"); 

    if (do_schlieren_plot == true) 
      names.emplace_back("schlieren_plot"); 

    return names; 
  } 

// 对于量的解释，我们有标量密度、能量、压力、声速和Schlieren图，以及动量和速度的向量。

  template <int dim> 
  std::vector<DataComponentInterpretation::DataComponentInterpretation> 
  EulerProblem<dim>::Postprocessor::get_data_component_interpretation() const 
  { 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      interpretation; 
    for (unsigned int d = 0; d < dim; ++d) 
      interpretation.push_back( 
        DataComponentInterpretation::component_is_part_of_vector); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 

    if (do_schlieren_plot == true) 
      interpretation.push_back( 
        DataComponentInterpretation::component_is_scalar); 

    return interpretation; 
  } 

// 关于必要的更新标志，我们只需要所有数量的值，但Schlieren图除外，它是基于密度梯度的。

  template <int dim> 
  UpdateFlags EulerProblem<dim>::Postprocessor::get_needed_update_flags() const 
  { 
    if (do_schlieren_plot == true) 
      return update_values | update_gradients; 
    else 
      return update_values; 
  } 

// 这个类的构造函数并不令人惊讶。我们设置了一个基于 "MPI_COMM_WORLD "通信器的平行三角形，一个具有 "dim+2 "分量的密度、动量和能量的矢量有限元，一个与底层有限元相同程度的高阶映射，并将时间和时间步长初始化为零。

  template <int dim> 
  EulerProblem<dim>::EulerProblem() 
    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
#ifdef DEAL_II_WITH_P4EST 
    , triangulation(MPI_COMM_WORLD) 
#endif 
    , fe(FE_DGQ<dim>(fe_degree), dim + 2) 
    , mapping(fe_degree) 
    , dof_handler(triangulation) 
    , timer(pcout, TimerOutput::never, TimerOutput::wall_times) 
    , euler_operator(timer) 
    , time(0) 
    , time_step(0) 
  {} 

// 作为一个网格，本教程程序实现了两种选择，取决于全局变量`testcase`。对于分析型变量（`testcase==0`），域是 $(0, 10) \times (-5, 5)$ ，域的四周都有迪里希特边界条件（流入）。对于 "testcase==1"，我们将域设置为矩形箱中的圆柱体，源自Sch&auml;fer和Turek（1996）对不可压缩的粘性流动的圆柱体的流动测试案例。在这里，我们有更多种类的边界。通道左侧的流入部分是给定的流入类型，为此我们选择了一个恒定的流入轮廓，而我们在右侧设置了一个亚声速的流出。对于圆柱体周围的边界（边界id等于2）以及通道壁（边界id等于3），我们使用壁的边界类型，即无正态流。此外，对于三维圆柱体，我们还在垂直方向上增加了一个重力。有了基础网格（包括由 GridGenerator::channel_with_cylinder()), 设置的流形），我们就可以执行指定数量的全局细化，从DoFHandler创建未知的编号，并将DoFHandler和Mapping对象交给EulerOperator的初始化。

  template <int dim> 
  void EulerProblem<dim>::make_grid_and_dofs() 
  { 
    switch (testcase) 
      { 
        case 0: 
          { 
            Point<dim> lower_left; 
            for (unsigned int d = 1; d < dim; ++d) 
              lower_left[d] = -5; 

            Point<dim> upper_right; 
            upper_right[0] = 10; 
            for (unsigned int d = 1; d < dim; ++d) 
              upper_right[d] = 5; 

            GridGenerator::hyper_rectangle(triangulation, 
                                           lower_left, 
                                           upper_right); 
            triangulation.refine_global(2); 

            euler_operator.set_inflow_boundary( 
              0, std::make_unique<ExactSolution<dim>>(0)); 

            break; 
          } 

        case 1: 
          { 
            GridGenerator::channel_with_cylinder( 
              triangulation, 0.03, 1, 0, true); 

            euler_operator.set_inflow_boundary( 
              0, std::make_unique<ExactSolution<dim>>(0)); 
            euler_operator.set_subsonic_outflow_boundary( 
              1, std::make_unique<ExactSolution<dim>>(0)); 

            euler_operator.set_wall_boundary(2); 
            euler_operator.set_wall_boundary(3); 

            if (dim == 3) 
              euler_operator.set_body_force( 
                std::make_unique<Functions::ConstantFunction<dim>>( 
                  std::vector<double>({0., 0., -0.2}))); 

            break; 
          } 

        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    triangulation.refine_global(n_global_refinements); 

    dof_handler.distribute_dofs(fe); 

    euler_operator.reinit(mapping, dof_handler); 
    euler_operator.initialize_vector(solution); 

// 在下文中，我们输出一些关于问题的统计数据。因为我们经常会出现相当多的单元格或自由度，所以我们希望用逗号来分隔每一组的三位数来打印它们。这可以通过 "locales "来实现，尽管这种工作方式不是特别直观。  step-32 对此有稍微详细的解释。

    std::locale s = pcout.get_stream().getloc(); 
    pcout.get_stream().imbue(std::locale("")); 
    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
          << " ( = " << (dim + 2) << " [vars] x " 
          << triangulation.n_global_active_cells() << " [cells] x " 
          << Utilities::pow(fe_degree + 1, dim) << " [dofs/cell/var] )" 
          << std::endl; 
    pcout.get_stream().imbue(s); 
  } 

// 对于输出，我们首先让欧拉算子计算出数值结果的误差。更确切地说，对于分析解的情况，我们计算与分析结果的误差，而对于第二个测试情况，我们计算与密度和能量恒定的背景场以及 $x$ 方向的恒定速度的偏差。

// 下一步是创建输出。这与 step-33 中的做法类似：我们让上面定义的后处理器控制大部分的输出，除了我们直接写的原始场。对于分析解的测试案例，我们还对分析解进行了另一次投影，并打印出该场和数值解之间的差异。一旦我们定义了所有要写的量，我们就建立输出的补丁。与 step-65 类似，我们通过设置适当的标志来创建一个高阶VTK输出，这使我们能够可视化高多项式度的场。最后，我们调用 `DataOutInterface::write_vtu_in_parallel()` 函数，将结果写入给定的文件名。这个函数使用了特殊的MPI并行写设施，与其他大多数教程程序中使用的标准库的 `std::ofstream` 变体相比，它通常对并行文件系统更加优化。`write_vtu_in_parallel()`函数的一个特别好的特点是，它可以将所有MPI行列的输出合并到一个文件中，使得没有必要有一个所有此类文件的中央记录（即 "pvtu "文件）。

// 对于并行程序来说，看一下单元在处理器之间的划分往往是有启发的。为此，我们可以向 DataOut::add_data_vector() 传递一个数字向量，其中包含与当前处理器拥有的活动单元一样多的条目；然后这些数字应该是拥有这些单元的处理器的等级。例如，这样一个向量可以从 GridTools::get_subdomain_association(). 中获得。另一方面，在每个MPI进程中，DataOut将只读取那些对应于本地拥有的单元的条目，这些条目当然都有相同的值：即当前进程的等级。矢量的其余条目中的内容实际上并不重要，因此我们可以用一个廉价的技巧逃脱。我们只是把我们给 DataOut::add_data_vector() 的向量的所有*值都填上当前MPI进程的等级。关键是在每个进程中，只有对应于本地拥有的单元格的条目会被读取，而忽略其他条目中的（错误）值。事实上，每个进程提交的向量中的条目子集是正确的，这就足够了。

  template <int dim> 
  void EulerProblem<dim>::output_results(const unsigned int result_number) 
  { 
    const std::array<double, 3> errors = 
      euler_operator.compute_errors(ExactSolution<dim>(time), solution); 
    const std::string quantity_name = testcase == 0 ? "error" : "norm"; 

    pcout << "Time:" << std::setw(8) << std::setprecision(3) << time 
          << ", dt: " << std::setw(8) << std::setprecision(2) << time_step 
          << ", " << quantity_name << " rho: " << std::setprecision(4) 
          << std::setw(10) << errors[0] << ", rho * u: " << std::setprecision(4) 
          << std::setw(10) << errors[1] << ", energy:" << std::setprecision(4) 
          << std::setw(10) << errors[2] << std::endl; 

    { 
      TimerOutput::Scope t(timer, "output"); 

      Postprocessor postprocessor; 
      DataOut<dim>  data_out; 

      DataOutBase::VtkFlags flags; 
      flags.write_higher_order_cells = true; 
      data_out.set_flags(flags); 

      data_out.attach_dof_handler(dof_handler); 
      { 
        std::vector<std::string> names; 
        names.emplace_back("density"); 
        for (unsigned int d = 0; d < dim; ++d) 
          names.emplace_back("momentum"); 
        names.emplace_back("energy"); 

        std::vector<DataComponentInterpretation::DataComponentInterpretation> 
          interpretation; 
        interpretation.push_back( 
          DataComponentInterpretation::component_is_scalar); 
        for (unsigned int d = 0; d < dim; ++d) 
          interpretation.push_back( 
            DataComponentInterpretation::component_is_part_of_vector); 
        interpretation.push_back( 
          DataComponentInterpretation::component_is_scalar); 

        data_out.add_data_vector(dof_handler, solution, names, interpretation); 
      } 
      data_out.add_data_vector(solution, postprocessor); 

      LinearAlgebra::distributed::Vector<Number> reference; 
      if (testcase == 0 && dim == 2) 
        { 
          reference.reinit(solution); 
          euler_operator.project(ExactSolution<dim>(time), reference); 
          reference.sadd(-1., 1, solution); 
          std::vector<std::string> names; 
          names.emplace_back("error_density"); 
          for (unsigned int d = 0; d < dim; ++d) 
            names.emplace_back("error_momentum"); 
          names.emplace_back("error_energy"); 

          std::vector<DataComponentInterpretation::DataComponentInterpretation> 
            interpretation; 
          interpretation.push_back( 
            DataComponentInterpretation::component_is_scalar); 
          for (unsigned int d = 0; d < dim; ++d) 
            interpretation.push_back( 
              DataComponentInterpretation::component_is_part_of_vector); 
          interpretation.push_back( 
            DataComponentInterpretation::component_is_scalar); 

          data_out.add_data_vector(dof_handler, 
                                   reference, 
                                   names, 
                                   interpretation); 
        } 

      Vector<double> mpi_owner(triangulation.n_active_cells()); 
      mpi_owner = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD); 
      data_out.add_data_vector(mpi_owner, "owner"); 

      data_out.build_patches(mapping, 
                             fe.degree, 
                             DataOut<dim>::curved_inner_cells); 

      const std::string filename = 
        "solution_" + Utilities::int_to_string(result_number, 3) + ".vtu"; 
      data_out.write_vtu_in_parallel(filename, MPI_COMM_WORLD); 
    } 
  } 

//  EulerProblem::run() 函数将所有的部分组合起来。它首先调用创建网格和设置数据结构的函数，然后初始化时间积分器和低存储积分器的两个临时向量。我们称这些向量为`rk_register_1`和`rk_register_2`，并使用第一个向量表示 $\mathbf{r}_i$ ，第二个向量表示 $\mathbf{k}_i$ ，在介绍中概述的Runge--Kutta方案的公式。在我们开始时间循环之前，我们通过 `EulerOperator::compute_cell_transport_speed()` 函数计算时间步长。为了便于比较，我们将那里得到的结果与最小网格尺寸进行比较，并将它们打印到屏幕上。对于像本教程程序中接近于统一的声速和速度，预测的有效网格尺寸将是接近的，但如果缩放比例不同，它们可能会有变化。

  template <int dim> 
  void EulerProblem<dim>::run() 
  { 
    { 
      const unsigned int n_vect_number = VectorizedArray<Number>::size(); 
      const unsigned int n_vect_bits   = 8 * sizeof(Number) * n_vect_number; 

      pcout << "Running with " 
            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) 
            << " MPI processes" << std::endl; 
      pcout << "Vectorization over " << n_vect_number << " " 
            << (std::is_same<Number, double>::value ? "doubles" : "floats") 
            << " = " << n_vect_bits << " bits (" 
            << Utilities::System::get_current_vectorization_level() << ")" 
            << std::endl; 
    } 

    make_grid_and_dofs(); 

    const LowStorageRungeKuttaIntegrator integrator(lsrk_scheme); 

    LinearAlgebra::distributed::Vector<Number> rk_register_1; 
    LinearAlgebra::distributed::Vector<Number> rk_register_2; 
    rk_register_1.reinit(solution); 
    rk_register_2.reinit(solution); 

    euler_operator.project(ExactSolution<dim>(time), solution); 

    double min_vertex_distance = std::numeric_limits<double>::max(); 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        min_vertex_distance = 
          std::min(min_vertex_distance, cell->minimum_vertex_distance()); 
    min_vertex_distance = 
      Utilities::MPI::min(min_vertex_distance, MPI_COMM_WORLD); 

    time_step = courant_number * integrator.n_stages() / 
                euler_operator.compute_cell_transport_speed(solution); 
    pcout << "Time step size: " << time_step 
          << ", minimal h: " << min_vertex_distance 
          << ", initial transport scaling: " 
          << 1. / euler_operator.compute_cell_transport_speed(solution) 
          << std::endl 
          << std::endl; 

    output_results(0); 

// 现在我们准备开始时间循环，我们一直运行到时间达到预期的结束时间。每隔5个时间步长，我们就计算一个新的时间步长估计值--由于解决方案是非线性的，在模拟过程中调整这个值是最有效的。如果Courant数选择得过于激进，模拟通常会在时间步数为NaN时爆炸，所以在这里很容易发现。有一点需要注意的是，由于不同的时间步长选择的相互作用，四舍五入的误差可能会传播到前几位数，从而导致略有不同的解决方案。为了降低这种敏感性，通常的做法是将时间步长四舍五入或截断到几位数，例如在这种情况下是3。如果当前时间接近规定的输出 "刻度 "值（如0.02），我们也会写出输出。在时间循环结束后，我们通过打印一些统计数据来总结计算，这主要由 TimerOutput::print_wall_time_statistics() 函数完成。

    unsigned int timestep_number = 0; 

    while (time < final_time - 1e-12) 
      { 
        ++timestep_number; 
        if (timestep_number % 5 == 0) 
          time_step = 
            courant_number * integrator.n_stages() / 
            Utilities::truncate_to_n_digits( 
              euler_operator.compute_cell_transport_speed(solution), 3); 

        { 
          TimerOutput::Scope t(timer, "rk time stepping total"); 
          integrator.perform_time_step(euler_operator, 
                                       time, 
                                       time_step, 
                                       solution, 
                                       rk_register_1, 
                                       rk_register_2); 
        } 

        time += time_step; 

        if (static_cast<int>(time / output_tick) != 
              static_cast<int>((time - time_step) / output_tick) || 
            time >= final_time - 1e-12) 
          output_results( 
            static_cast<unsigned int>(std::round(time / output_tick))); 
      } 

    timer.print_wall_time_statistics(MPI_COMM_WORLD); 
    pcout << std::endl; 
  } 

} // namespace Euler_DG 

// main()函数并不令人惊讶，它遵循了以前所有MPI程序中的做法。当我们运行一个MPI程序时，我们需要调用`MPI_Init()`和`MPI_Finalize()`，我们通过 Utilities::MPI::MPI_InitFinalize 数据结构来完成。请注意，我们只用MPI来运行程序，并将线程数设置为1。

int main(int argc, char **argv) 
{ 
  using namespace Euler_DG; 
  using namespace dealii; 

  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

  try 
    { 
      deallog.depth_console(0); 

      EulerProblem<dimension> euler_problem; 
      euler_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-68.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2020 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Bruno Blais, Toni El Geitani Nehme, Rene Gassmoeller, Peter Munch 
 */ 


// @sect3{Include files}  
#include <deal.II/base/bounding_box.h> 
#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/discrete_time.h> 
#include <deal.II/base/mpi.h> 
#include <deal.II/base/parameter_acceptor.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/distributed/cell_weights.h> 
#include <deal.II/distributed/solution_transfer.h> 
#include <deal.II/distributed/tria.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_tools.h> 

#include <deal.II/lac/la_parallel_vector.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 从下面的include文件中，我们导入了ParticleHandler类，该类允许你管理漂浮在 Particles::Particle), 类型的粒子集合（代表具有一些附加属性（例如，一个id）的点集合的对象）。 Particles命名空间中的方法和类允许人们轻松实现Particle-In-Cell方法和分布式三角形上的粒子追踪。

#include <deal.II/particles/particle_handler.h> 

// 我们导入粒子发生器，使我们能够插入粒子。在本步骤中，粒子是通过非匹配的超壳三角形全局插入的。

#include <deal.II/particles/generators.h> 

// 由于粒子没有形成三角形，它们有自己特定的DataOut类，这将使我们能够把它们写成常用的并行vtu格式（或其他任何数量的文件格式）。

#include <deal.II/particles/data_out.h> 

#include <cmath> 
#include <iostream> 

namespace Step68 
{ 
  using namespace dealii; 
// @sect3{Run-time parameter handling}  

// 与 step-60 中的做法类似，我们建立了一个持有我们问题的所有参数的类，并从ParameterAcceptor类中派生出来以简化参数文件的管理和创建。

// ParameterAcceptor范式要求所有的参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的bug（比如写成`if (time = 0)`而不是`if(time == 0)`），我们在一个外部类中声明所有的参数，该类在实际的`ParticleTracking`类之前被初始化，并将其作为`const`引用传递给主类。

// 该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了 ParameterHandler::add_parameter() 方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。

  class ParticleTrackingParameters : public ParameterAcceptor 
  { 
  public: 
    ParticleTrackingParameters(); 

// 该类主要由成员变量组成，描述了粒子跟踪模拟及其离散化的细节。下面的参数是关于输出应该写到哪里，速度的空间离散化（默认是 $Q_1$ ），时间步长和输出频率（在我们再次生成图形输出之前应该经过多少时间步长）。

    std::string output_directory = "./"; 

    unsigned int velocity_degree       = 1; 
    double       time_step             = 0.002; 
    double       final_time            = 4.0; 
    unsigned int output_frequency      = 10; 
    unsigned int repartition_frequency = 5; 

// 我们允许每个网格独立地被细化。在本教程中，流体网格上没有解决物理问题，其速度是通过分析计算得出的。

    unsigned int fluid_refinement              = 4; 
    unsigned int particle_insertion_refinement = 3; 
  }; 

// 还有一个任务就是声明我们在输入文件中可以接受哪些运行时参数。由于我们的参数数量非常有限，所有的参数都在同一章节中声明。

  ParticleTrackingParameters::ParticleTrackingParameters() 
    : ParameterAcceptor("Particle Tracking Problem/") 
  { 
    add_parameter( 
      "Velocity degree", velocity_degree, "", prm, Patterns::Integer(1)); 

    add_parameter("Output frequency", 
                  output_frequency, 
                  "Iteration frequency at which output results are written", 
                  prm, 
                  Patterns::Integer(1)); 

    add_parameter("Repartition frequency", 
                  repartition_frequency, 
                  "Iteration frequency at which the mesh is load balanced", 
                  prm, 
                  Patterns::Integer(1)); 

    add_parameter("Output directory", output_directory); 

    add_parameter("Time step", time_step, "", prm, Patterns::Double()); 

    add_parameter("Final time", 
                  final_time, 
                  "End time of the simulation", 
                  prm, 
                  Patterns::Double()); 

    add_parameter("Fluid refinement", 
                  fluid_refinement, 
                  "Refinement level of the fluid domain", 
                  prm, 
                  Patterns::Integer(0)); 

    add_parameter( 
      "Particle insertion refinement", 
      particle_insertion_refinement, 
      "Refinement of the volumetric mesh used to insert the particles", 
      prm, 
      Patterns::Integer(0)); 
  } 

//  @sect3{Velocity profile}  

// 速度曲线是作为一个函数对象提供的。这个函数在例子中是硬编码的。

  template <int dim> 
  class Vortex : public Function<dim> 
  { 
  public: 
    Vortex() 
      : Function<dim>(dim) 
    {} 

    virtual void vector_value(const Point<dim> &point, 
                              Vector<double> &  values) const override; 
  }; 

// Rayleigh-Kothe顶点的速度曲线是随时间变化的。因此，必须从函数对象中收集模拟的当前时间（t）。

  template <int dim> 
  void Vortex<dim>::vector_value(const Point<dim> &point, 
                                 Vector<double> &  values) const 
  { 
    const double T = 4; 
    const double t = this->get_time(); 

    const double px = numbers::PI * point(0); 
    const double py = numbers::PI * point(1); 
    const double pt = numbers::PI / T * t; 

    values[0] = -2 * cos(pt) * pow(sin(px), 2) * sin(py) * cos(py); 
    values[1] = 2 * cos(pt) * pow(sin(py), 2) * sin(px) * cos(px); 
    if (dim == 3) 
      { 
        values[2] = 0; 
      } 
  } 

//  @sect3{The <code>ParticleTracking</code> class declaration}  

// 我们现在准备介绍我们的教程程序的主类。

  template <int dim> 
  class ParticleTracking 
  { 
  public: 
    ParticleTracking(const ParticleTrackingParameters &par, 
                     const bool                        interpolated_velocity); 
    void run(); 

  private: 

// 这个函数负责在背景网格之上初始生成粒子。

    void generate_particles(); 

// 当速度曲线被内插到粒子的位置时，必须首先使用自由度来存储。因此，和其他并行情况一样（例如 step-40 ），我们在背景网格上初始化自由度。

    void setup_background_dofs(); 

// 在其中一个测试案例中，该函数被映射到背景网格上，并使用有限元插值来计算粒子位置的速度。这个函数计算三角形的支持点处的函数值。

    void interpolate_function_to_field(); 

// 下面两个函数分别负责对速度场在粒子位置插值或分析计算的情况下进行显式欧拉时间积分的步骤。

    void euler_step_interpolated(const double dt); 
    void euler_step_analytical(const double dt); 

// `cell_weight()`函数向三角计算表明在这个单元上预计会发生多少计算工作，因此需要对域进行划分，以使每个MPI等级得到大致相等的工作量（可能不是相等的单元数量）。虽然该函数是从外部调用的，但它与该类内部的相应信号相连，因此它可以是 "私有 "的。

    unsigned int cell_weight( 
      const typename parallel::distributed::Triangulation<dim>::cell_iterator 
        &cell, 
      const typename parallel::distributed::Triangulation<dim>::CellStatus 
        status) const; 

// 以下两个函数分别负责输出粒子的模拟结果和背景网格上的速度曲线。

    void output_particles(const unsigned int it); 
    void output_background(const unsigned int it); 

// 该类的私有成员与其他并行deal.II例子相似。参数被存储为`const`成员。值得注意的是，我们保留了`Vortex`类的成员，因为它的时间必须随着模拟的进行而被修改。

    const ParticleTrackingParameters &par; 

    MPI_Comm                                  mpi_communicator; 
    parallel::distributed::Triangulation<dim> background_triangulation; 
    Particles::ParticleHandler<dim>           particle_handler; 

    DoFHandler<dim>                            fluid_dh; 
    FESystem<dim>                              fluid_fe; 
    MappingQ1<dim>                             mapping; 
    LinearAlgebra::distributed::Vector<double> velocity_field; 

    Vortex<dim> velocity; 

    ConditionalOStream pcout; 

    bool interpolated_velocity; 
  }; 

//  @sect3{The <code>PatricleTracking</code> class implementation}  
// @sect4{Constructor}  

// 构造函数和析构函数是相当微不足道的。它们与  step-40  中的做法非常相似。我们将我们要工作的处理器设置为所有可用的机器（`MPI_COMM_WORLD`），并初始化  <code>pcout</code>  变量，只允许处理器0输出任何东西到标准输出。

  template <int dim> 
  ParticleTracking<dim>::ParticleTracking(const ParticleTrackingParameters &par, 
                                          const bool interpolated_velocity) 
    : par(par) 
    , mpi_communicator(MPI_COMM_WORLD) 
    , background_triangulation(mpi_communicator) 
    , fluid_dh(background_triangulation) 
    , fluid_fe(FE_Q<dim>(par.velocity_degree), dim) 
    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0) 
    , interpolated_velocity(interpolated_velocity) 

  {} 

//  @sect4{Cell weight}  

// 这个函数是让我们动态平衡本例中计算负载的关键部分。该函数为每个单元赋予一个权重，代表该单元的计算工作。在这里，大部分的工作预计会发生在粒子上，因此这个函数的返回值（代表 "这个单元的工作"）是根据当前单元中的粒子数量来计算。该函数与三角形内部的cell_weight()信号相连，每一个单元将被调用一次，每当三角形在等级之间重新划分领域时（该连接是在该类的generate_particles()函数中创建的）。

  template <int dim> 
  unsigned int ParticleTracking<dim>::cell_weight( 
    const typename parallel::distributed::Triangulation<dim>::cell_iterator 
      &                                                                  cell, 
    const typename parallel::distributed::Triangulation<dim>::CellStatus status) 
    const 
  { 

// 我们不给我们不拥有的细胞分配任何权重（即人工或幽灵细胞）。

    if (!cell->is_locally_owned()) 
      return 0; 

// 这决定了粒子工作与细胞工作相比有多重要（默认情况下每个细胞的权重为1000）。我们将每个粒子的权重设置得更高，以表明在这个例子中，粒子的负载是唯一对分配单元很重要的。这个数字的最佳值取决于应用，可以从0（廉价的粒子操作，昂贵的单元操作）到远远大于1000（昂贵的粒子操作，廉价的单元操作，像本例中假定的那样）。

    const unsigned int particle_weight = 10000; 

// 这个例子没有使用自适应细化，因此每个单元都应该有`CELL_PERSIST`的状态。然而这个函数也可以用来在细化过程中分配负载，因此我们也考虑细化或粗化的单元。

    if (status == parallel::distributed::Triangulation<dim>::CELL_PERSIST || 
        status == parallel::distributed::Triangulation<dim>::CELL_REFINE) 
      { 
        const unsigned int n_particles_in_cell = 
          particle_handler.n_particles_in_cell(cell); 
        return n_particles_in_cell * particle_weight; 
      } 
    else if (status == parallel::distributed::Triangulation<dim>::CELL_COARSEN) 
      { 
        unsigned int n_particles_in_cell = 0; 

        for (unsigned int child_index = 0; child_index < cell->n_children(); 
             ++child_index) 
          n_particles_in_cell += 
            particle_handler.n_particles_in_cell(cell->child(child_index)); 

        return n_particles_in_cell * particle_weight; 
      } 

    Assert(false, ExcInternalError()); 
    return 0; 
  } 

//  @sect4{Particles generation}  

// 这个函数生成示踪粒子和这些粒子演化的背景三角图。

  template <int dim> 
  void ParticleTracking<dim>::generate_particles() 
  { 

// 我们创建一个超立方体三角形，并对其进行全局细化。这个三角形覆盖了粒子的全部运动轨迹。

    GridGenerator::hyper_cube(background_triangulation, 0, 1); 
    background_triangulation.refine_global(par.fluid_refinement); 

// 为了在重新划分三角形时考虑粒子，该算法需要知道三件事。

// 1.给每个单元分配多少权重（里面有多少粒子）；2.在运送数据之前如何包装粒子；3.在重新分区之后如何拆开粒子。

// 我们将正确的函数附加到信号里面  parallel::distributed::Triangulation.  这些信号将在每次调用repartition()函数时被调用。这些连接只需要创建一次，所以我们不妨在这个类的构造函数中设置它们，但为了这个例子，我们要把粒子相关的指令分组。

    background_triangulation.signals.cell_weight.connect( 
      [&]( 
        const typename parallel::distributed::Triangulation<dim>::cell_iterator 
          &cell, 
        const typename parallel::distributed::Triangulation<dim>::CellStatus 
          status) -> unsigned int { return this->cell_weight(cell, status); }); 

    background_triangulation.signals.pre_distributed_repartition.connect( 
      [this]() { this->particle_handler.register_store_callback_function(); }); 

    background_triangulation.signals.post_distributed_repartition.connect( 
      [&]() { this->particle_handler.register_load_callback_function(false); }); 

// 这将初始化粒子所处的背景三角，以及粒子的属性数量。

    particle_handler.initialize(background_triangulation, mapping, 1 + dim); 

// 我们创建了一个粒子三角图，这个三角图只用来生成将用于插入粒子的点。这个三角形是一个偏离模拟域中心的超壳。这将被用来生成一个充满粒子的圆盘，这将使我们能够很容易地监测由于涡流而产生的运动。

    Point<dim> center; 
    center[0] = 0.5; 
    center[1] = 0.75; 
    if (dim == 3) 
      center[2] = 0.5; 

    const double outer_radius = 0.15; 
    const double inner_radius = 0.01; 

    parallel::distributed::Triangulation<dim> particle_triangulation( 
      MPI_COMM_WORLD); 

    GridGenerator::hyper_shell( 
      particle_triangulation, center, inner_radius, outer_radius, 6); 
    particle_triangulation.refine_global(par.particle_insertion_refinement); 

// 我们为粒子发生器生成必要的边界盒。这些边界框是快速识别插入的粒子位于哪个进程的子域中，以及哪个单元拥有它的必要条件。

    const auto my_bounding_box = GridTools::compute_mesh_predicate_bounding_box( 
      background_triangulation, IteratorFilters::LocallyOwnedCell()); 
    const auto global_bounding_boxes = 
      Utilities::MPI::all_gather(MPI_COMM_WORLD, my_bounding_box); 

// 我们生成一个空的属性向量。一旦粒子生成，我们将把这些属性赋予它们。

    std::vector<std::vector<double>> properties( 
      particle_triangulation.n_locally_owned_active_cells(), 
      std::vector<double>(dim + 1, 0.)); 

// 我们在单点正交的位置生成粒子。因此，在每个单元的中心点将生成一个粒子。

    Particles::Generators::quadrature_points(particle_triangulation, 
                                             QMidpoint<dim>(), 
                                             global_bounding_boxes, 
                                             particle_handler, 
                                             mapping, 
                                             properties); 

    pcout << "Number of particles inserted: " 
          << particle_handler.n_global_particles() << std::endl; 
  } 

//  @sect4{Background DOFs and interpolation}  

// 这个函数设置了用于速度插值的背景自由度，并分配了存储整个速度场解决方案的场向量。

  template <int dim> 
  void ParticleTracking<dim>::setup_background_dofs() 
  { 
    fluid_dh.distribute_dofs(fluid_fe); 
    const IndexSet locally_owned_dofs = fluid_dh.locally_owned_dofs(); 
    IndexSet       locally_relevant_dofs; 
    DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs); 

    velocity_field.reinit(locally_owned_dofs, 
                          locally_relevant_dofs, 
                          mpi_communicator); 
  } 

// 这个函数负责将涡流速度场插值到场矢量上。这可以通过使用 VectorTools::interpolate() 函数相当容易地实现。

  template <int dim> 
  void ParticleTracking<dim>::interpolate_function_to_field() 
  { 
    velocity_field.zero_out_ghost_values(); 
    VectorTools::interpolate(mapping, fluid_dh, velocity, velocity_field); 
    velocity_field.update_ghost_values(); 
  } 

//  @sect4{Time integration of the trajectories}  

// 我们使用分析定义的速度场来整合粒子的轨迹。这展示了粒子的一个相对微不足道的用法。

  template <int dim> 
  void ParticleTracking<dim>::euler_step_analytical(const double dt) 
  { 
    const unsigned int this_mpi_rank = 
      Utilities::MPI::this_mpi_process(mpi_communicator); 
    Vector<double> particle_velocity(dim); 

// 使用粒子迭代器在域中的所有粒子上进行循环操作

    for (auto &particle : particle_handler) 
      { 

// 我们使用粒子的当前位置来计算它们的速度。

        Point<dim> particle_location = particle.get_location(); 
        velocity.vector_value(particle_location, particle_velocity); 

// 这就更新了粒子的位置，并将旧的位置设定为等于粒子的新位置。

        for (int d = 0; d < dim; ++d) 
          particle_location[d] += particle_velocity[d] * dt; 

        particle.set_location(particle_location); 

// 我们在粒子属性中存储处理器ID（标量）和粒子速度（矢量）。在这个例子中，这样做纯粹是为了可视化的目的。

        ArrayView<double> properties = particle.get_properties(); 
        for (int d = 0; d < dim; ++d) 
          properties[d] = particle_velocity[d]; 
        properties[dim] = this_mpi_rank; 
      } 
  } 

// 与前面的函数不同，在这个函数中，我们通过将自由度处的速度场值插值到粒子的位置来积分粒子的轨迹。

  template <int dim> 
  void ParticleTracking<dim>::euler_step_interpolated(const double dt) 
  { 
    Vector<double> local_dof_values(fluid_fe.dofs_per_cell); 

// 我们在所有的本地粒子上循环。虽然这可以直接通过循环所有的单元格来实现，但这将迫使我们循环许多不包含粒子的单元格。相反，我们在所有的粒子上循环，但是，我们得到粒子所在的单元格的引用，然后在该单元格中循环所有的粒子。这使我们能够从 "velocity_field "向量中收集一次速度值，并将其用于该单元中的所有粒子。

    auto particle = particle_handler.begin(); 
    while (particle != particle_handler.end()) 
      { 
        const auto cell = 
          particle->get_surrounding_cell(background_triangulation); 
        const auto dh_cell = 
          typename DoFHandler<dim>::cell_iterator(*cell, &fluid_dh); 

        dh_cell->get_dof_values(velocity_field, local_dof_values); 

// 接下来，通过评估粒子位置的有限元解来计算粒子位置的速度。这基本上是第19步中粒子平流功能的优化版本，但我们不是为每个单元创建正交对象和FEValues对象，而是用手进行评估，这在一定程度上更有效率，而且只对本教程有意义，因为粒子工作是整个程序的主要成本。

        const auto pic = particle_handler.particles_in_cell(cell); 
        Assert(pic.begin() == particle, ExcInternalError()); 
        for (auto &p : pic) 
          { 
            const Point<dim> reference_location = p.get_reference_location(); 
            Tensor<1, dim>   particle_velocity; 
            for (unsigned int j = 0; j < fluid_fe.dofs_per_cell; ++j) 
              { 
                const auto comp_j = fluid_fe.system_to_component_index(j); 

                particle_velocity[comp_j.first] += 
                  fluid_fe.shape_value(j, reference_location) * 
                  local_dof_values[j]; 
              } 

            Point<dim> particle_location = particle->get_location(); 
            for (int d = 0; d < dim; ++d) 
              particle_location[d] += particle_velocity[d] * dt; 
            p.set_location(particle_location); 

// 同样，我们在粒子属性中存储了粒子速度和处理器ID，以便于可视化。

            ArrayView<double> properties = p.get_properties(); 
            for (int d = 0; d < dim; ++d) 
              properties[d] = particle_velocity[d]; 

            properties[dim] = 
              Utilities::MPI::this_mpi_process(mpi_communicator); 

            ++particle; 
          } 
      } 
  } 

//  @sect4{Data output}  

// 接下来的两个函数负责将粒子和背景网格用pvtu记录写入vtu中。这可以确保在并行启动仿真时，仿真结果可以被可视化。

  template <int dim> 
  void ParticleTracking<dim>::output_particles(const unsigned int it) 
  { 
    Particles::DataOut<dim, dim> particle_output; 

    std::vector<std::string> solution_names(dim, "velocity"); 
    solution_names.push_back("process_id"); 

    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    particle_output.build_patches(particle_handler, 
                                  solution_names, 
                                  data_component_interpretation); 
    const std::string output_folder(par.output_directory); 
    const std::string file_name(interpolated_velocity ? 
                                  "interpolated-particles" : 
                                  "analytical-particles"); 

    pcout << "Writing particle output file: " << file_name << "-" << it 
          << std::endl; 

    particle_output.write_vtu_with_pvtu_record( 
      output_folder, file_name, it, mpi_communicator, 6); 
  } 

  template <int dim> 
  void ParticleTracking<dim>::output_background(const unsigned int it) 
  { 
    std::vector<std::string> solution_names(dim, "velocity"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        dim, DataComponentInterpretation::component_is_part_of_vector); 

    DataOut<dim> data_out; 

// 将解决方案的数据附加到data_out对象上

    data_out.attach_dof_handler(fluid_dh); 
    data_out.add_data_vector(velocity_field, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    Vector<float> subdomain(background_triangulation.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      subdomain(i) = background_triangulation.locally_owned_subdomain(); 
    data_out.add_data_vector(subdomain, "subdomain"); 

    data_out.build_patches(mapping); 

    const std::string output_folder(par.output_directory); 
    const std::string file_name("background"); 

    pcout << "Writing background field file: " << file_name << "-" << it 
          << std::endl; 

    data_out.write_vtu_with_pvtu_record( 
      output_folder, file_name, it, mpi_communicator, 6); 
  } 

//  @sect4{Running the simulation}  这个函数协调了整个模拟过程。它与其他时间相关的教程程序非常相似--以 step-21 或 step-26 为例。注意，我们使用DiscreteTime类来监控时间、时间步长和 step- 号。这个函数相对来说是比较简单的。

  template <int dim> 
  void ParticleTracking<dim>::run() 
  { 
    DiscreteTime discrete_time(0, par.final_time, par.time_step); 

    generate_particles(); 

    pcout << "Repartitioning triangulation after particle generation" 
          << std::endl; 
    background_triangulation.repartition(); 

// 我们通过在分析法和插值法的情况下进行时间步长为0的显式欧拉迭代来设置粒子的初始属性。

    if (interpolated_velocity) 
      { 
        setup_background_dofs(); 
        interpolate_function_to_field(); 
        euler_step_interpolated(0.); 
      } 
    else 
      euler_step_analytical(0.); 

    output_particles(discrete_time.get_step_number()); 
    if (interpolated_velocity) 
      output_background(discrete_time.get_step_number()); 

// 粒子通过循环的方式随时间推移而平移。

    while (!discrete_time.is_at_end()) 
      { 
        discrete_time.advance_time(); 
        velocity.set_time(discrete_time.get_previous_time()); 

        if ((discrete_time.get_step_number() % par.repartition_frequency) == 0) 
          { 
            background_triangulation.repartition(); 
            if (interpolated_velocity) 
              setup_background_dofs(); 
          } 

        if (interpolated_velocity) 
          { 
            interpolate_function_to_field(); 
            euler_step_interpolated(discrete_time.get_previous_step_size()); 
          } 
        else 
          euler_step_analytical(discrete_time.get_previous_step_size()); 

// 在粒子被移动之后，有必要确定它们现在所在的单元。这可以通过调用 <code>sort_particles_into_subdomains_and_cells</code> 来实现。
        particle_handler.sort_particles_into_subdomains_and_cells(); 

        if ((discrete_time.get_step_number() % par.output_frequency) == 0) 
          { 
            output_particles(discrete_time.get_step_number()); 
            if (interpolated_velocity) 
              output_background(discrete_time.get_step_number()); 
          } 
      } 
  } 

} // namespace Step68 

//  @sect3{The main() function}  

// 代码的其余部分，即`main()`函数，是标准的。我们注意到，我们用分析速度和插值速度运行粒子跟踪，并产生两种结果

int main(int argc, char *argv[]) 
{ 
  using namespace Step68; 
  using namespace dealii; 
  deallog.depth_console(1); 

  try 
    { 
      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      std::string prm_file; 
      if (argc > 1) 
        prm_file = argv[1]; 
      else 
        prm_file = "parameters.prm"; 

      ParticleTrackingParameters par; 
      ParameterAcceptor::initialize(prm_file); 
      { 
        Step68::ParticleTracking<2> particle_tracking(par, false); 
        particle_tracking.run(); 
      } 
      { 
        Step68::ParticleTracking<2> particle_tracking(par, true); 
        particle_tracking.run(); 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-69.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2019 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Matthias Maier, Texas A&M University; 
 *          Ignacio Tomas, Texas A&M University, Sandia National Laboratories 
 * 
 * Sandia National Laboratories is a multimission laboratory managed and 
 * operated by National Technology & Engineering Solutions of Sandia, LLC, a 
 * wholly owned subsidiary of Honeywell International Inc., for the U.S. 
 * Department of Energy's National Nuclear Security Administration under 
 * contract DE-NA0003525. This document describes objective technical results 
 * and analysis. Any subjective views or opinions that might be expressed in 
 * the paper do not necessarily represent the views of the U.S. Department of 
 * Energy or the United States Government. 
 */ 


// @sect3{Include files}  

// 包含文件的集合是相当标准的。最耐人寻味的部分是，我们将完全依靠deal.II数据结构进行MPI并行化，特别是通过 parallel::distributed::Triangulation 和 LinearAlgebra::distributed::Vector 包含的 <code>distributed/tria.h</code> 和 <code>lac/la_parallel_vector.h</code>  。我们将使用非分布式的  dealii::SparseMatrix  (  <code>lac/sparse_matrix.h</code>  ) 来存储  $\mathbf{c}_{ij}$  、  $\mathbf{n}_{ij}$  和  $d_{ij}$  矩阵的本地部分，而不是 Trilinos 或 PETSc 特定的矩阵类。

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/parallel.h> 
#include <deal.II/base/parameter_acceptor.h> 
#include <deal.II/base/partitioner.h> 
#include <deal.II/base/quadrature.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/work_stream.h> 

#include <deal.II/distributed/tria.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/manifold_lib.h> 

#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/la_parallel_vector.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/sparse_matrix.templates.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/meshworker/scratch_data.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/vector_tools.h> 

// 除了上述deal.II的具体内容外，我们还包括四个提升头文件。前两个是二进制文件，我们将用它来实现检查点和重启机制。

#include <boost/archive/binary_iarchive.hpp> 
#include <boost/archive/binary_oarchive.hpp> 

// 最后两个头文件是用来在整数间隔上创建自定义迭代器范围。

#include <deal.II/base/std_cxx20/iota_view.h> 
#include <boost/range/iterator_range.hpp> 

//用于  std::isnan,  。
// std::isinf,  
// std::ifstream,  
// std::async, 和 std::future  。
#include <cmath> 
#include <fstream> 
#include <future> 
// @sect3{Class template declarations}  

// 我们开始实际的实现，先声明所有的类及其数据结构和方法。与之前的例子步骤相比，我们使用了更精细的概念、数据结构和参数封装到各个类中。因此，一个单一的类通常围绕着一个单一的数据结构（如 <code>Discretization</code> 类中的Triangulation），或者一个单一的方法（如 <code>%TimeStepping</code> 类的 <code>make_one_step()</code> 函数）。我们通常声明参数变量和从头开始的数据对象为`private'，而使其他类使用的方法和数据结构为`public'。

//  @note  一个更简洁的方法是通过<a
//  href="https:en.wikipedia.org/wiki/Mutator_method">getter/setter functions</a>来保护对所有数据结构的访问。为了简洁起见，我们不采用这种方法。

// 我们还注意到，绝大多数的类都是从ParameterAcceptor派生的。这有利于将所有的全局参数归入一个（全局）ParameterHandler。关于从ParameterAcceptor继承作为全局订阅机制的更多解释可以在  step-60  中找到。

namespace Step69 
{ 
  using namespace dealii; 

// 我们首先定义一些 types::boundary_id 常量，用于整个教程步骤。这使得我们可以用一个助记符（如 <code>do_nothing</code>  ）而不是一个数值来指代边界类型。

  namespace Boundaries 
  { 
    constexpr types::boundary_id do_nothing = 0; 
    constexpr types::boundary_id free_slip  = 1; 
    constexpr types::boundary_id dirichlet  = 2; 
  } // namespace Boundaries 
// @sect4{The <code>Discretization</code> class}  

//  <code>Discretization</code> 类包含所有关于问题的网格（三角形）和离散化（映射、有限元、正交）的数据结构。如前所述，我们使用ParameterAcceptor类来自动填充特定问题的参数，如几何信息（ <code>length</code>  等）或来自参数文件的细化水平（ <code>refinement</code>  ）。这就要求我们把数据结构的初始化分成两个函数。我们在构造函数中初始化所有不依赖参数的东西，并将网格的创建推迟到 <code>setup()</code> 方法中，一旦所有参数通过 ParameterAcceptor::initialize(). 读入，就可以调用该方法。
  template <int dim> 
  class Discretization : public ParameterAcceptor 
  { 
  public: 
    Discretization(const MPI_Comm     mpi_communicator, 
                   TimerOutput &      computing_timer, 
                   const std::string &subsection = "Discretization"); 

    void setup(); 

    const MPI_Comm mpi_communicator; 

    parallel::distributed::Triangulation<dim> triangulation; 

    const MappingQ<dim>   mapping; 
    const FE_Q<dim>       finite_element; 
    const QGauss<dim>     quadrature; 
    const QGauss<dim - 1> face_quadrature; 

  private: 
    TimerOutput &computing_timer; 

    double length; 
    double height; 
    double disk_position; 
    double disk_diameter; 

    unsigned int refinement; 
  }; 
// @sect4{The <code>OfflineData</code> class}  

//  <code>OfflineData</code> 类包含了离散化中几乎所有不随时间演变的组件，特别是DoFHandler、SparsityPattern、边界图、块状质量矩阵、 $\mathbf{c}_{ij}$ 和 $\mathbf{n}_{ij}$ 矩阵。这里，术语<i>offline</i>指的是 <code>OfflineData</code> 的所有类成员都有明确定义的值，与当前时间步长无关。这意味着它们可以提前初始化（在<i>time step zero</i>），并且不意味着在任何后来的时间步长中被修改。例如，稀疏模式不应该随着时间的推进而改变（我们在空间上不做任何形式的适应性）。同样地，包络质量矩阵的条目也不应该随着时间的推进而被修改。

// 我们还计算并存储一个 <code>boundary_normal_map</code> ，它包含一个从边界自由度的 types::global_dof_index 类型的全局索引到一个由法向量、边界ID和与自由度相关的位置组成的元组的映射。我们必须在这个类中计算和存储这些几何信息，因为我们在后面的代数循环中无法获得几何（或基于单元）的信息。

// 尽管这个类目前没有任何可以从参数文件中读入的参数，但我们还是从ParameterAcceptor派生出来，并遵循与Discretization类相同的习惯，提供一个 <code>setup()</code> (and <code>assemble()</code>  )方法。

  template <int dim> 
  class OfflineData : public ParameterAcceptor 
  { 
  public: 
    using BoundaryNormalMap = 
      std::map<types::global_dof_index, 
               std::tuple<Tensor<1, dim>, types::boundary_id, Point<dim>>>; 

    OfflineData(const MPI_Comm             mpi_communicator, 
                TimerOutput &              computing_timer, 
                const Discretization<dim> &discretization, 
                const std::string &        subsection = "OfflineData"); 

    void setup(); 
    void assemble(); 

    DoFHandler<dim> dof_handler; 

    std::shared_ptr<const Utilities::MPI::Partitioner> partitioner; 

    unsigned int n_locally_owned; 
    unsigned int n_locally_relevant; 

    SparsityPattern sparsity_pattern; 

    BoundaryNormalMap boundary_normal_map; 

    SparseMatrix<double>                  lumped_mass_matrix; 
    std::array<SparseMatrix<double>, dim> cij_matrix; 
    std::array<SparseMatrix<double>, dim> nij_matrix; 
    SparseMatrix<double>                  norm_matrix; 

  private: 
    const MPI_Comm mpi_communicator; 
    TimerOutput &  computing_timer; 

    SmartPointer<const Discretization<dim>> discretization; 
  }; 
// @sect4{The <code>ProblemDescription</code> class}  

// 该类的成员函数是欧拉方程特有的实用函数和数据结构。

// - 类型别名 <code>state_type</code> 用于状态 $\mathbf{U}_i^n$  。

// - 类型别名  <code>flux_type</code>  用来表示通量  $\mathbb{f}(\mathbf{U}_j^n)$  。

// -  <code>momentum</code> 函数从状态向量 $[\rho,\textbf{m},E]$ 中提取 $\textbf{m}$ 并存储在一个 <code>Tensor<1, dim></code> 中。

// -  <code>internal_energy</code> 函数从给定的状态向量 $[\rho,\textbf{m},E]$ 中计算 $E - \frac{|\textbf{m}|^2}{2\rho}$  。

// 类成员  <code>component_names</code>  ,  <code>pressure</code>, and <code>speed_of_sound</code>  的目的从它们的名字中就可以看出。我们还提供了一个函数  <code>compute_lambda_max()</code>  ，用于计算上面提到的波速估计，  $\lambda_{max}(\mathbf{U},\mathbf{V},\mathbf{n})$  ，用于计算  $d_{ij}$  矩阵。

//  @note   <code>DEAL_II_ALWAYS_INLINE</code> 宏扩展为一个（编译器特定的）pragma，确保这个类中定义的相应函数总是内联的，也就是说，每次调用该函数时，函数体都被放在原位，而不会产生调用（和代码转接）。这比 <code>inline</code> 关键字要强，后者或多或少是对编译器的一个（温和的）建议，即程序员认为内联函数是有益的。  <code>DEAL_II_ALWAYS_INLINE</code> 只应在很少的情况下谨慎使用，比如在这种情况下，我们实际上知道（由于基准测试）内联有关的函数可以提高性能。

// 最后，我们注意到这是本教程步骤中唯一一个与特定的 "物理学 "或 "双曲守恒定律"（本例中为欧拉方程）相关的类。所有其他的类主要是 "离散化 "类，与所求解的特定物理学无关。

  template <int dim> 
  class ProblemDescription 
  { 
  public: 
    static constexpr unsigned int problem_dimension = 2 + dim; 

    using state_type = Tensor<1, problem_dimension>; 
    using flux_type  = Tensor<1, problem_dimension, Tensor<1, dim>>; 

    const static std::array<std::string, problem_dimension> component_names; 

    static constexpr double gamma = 7. / 5.; 

    static DEAL_II_ALWAYS_INLINE inline Tensor<1, dim> 
    momentum(const state_type &U); 

    static DEAL_II_ALWAYS_INLINE inline double 
    internal_energy(const state_type &U); 

    static DEAL_II_ALWAYS_INLINE inline double pressure(const state_type &U); 

    static DEAL_II_ALWAYS_INLINE inline double 
    speed_of_sound(const state_type &U); 

    static DEAL_II_ALWAYS_INLINE inline flux_type flux(const state_type &U); 

    static DEAL_II_ALWAYS_INLINE inline double 
    compute_lambda_max(const state_type &    U_i, 
                       const state_type &    U_j, 
                       const Tensor<1, dim> &n_ij); 
  }; 
// @sect4{The <code>InitialValues</code> class}  

//  <code>InitialValues</code> 类的唯一公共数据属性是一个 std::function 。
// <code>initial_state</code> ，用于计算给定的点和时间的初始状态。这个函数用于填充初始流场，以及在每个时间步长中明确设置迪里切特边界条件（在流入边界）。

// 在这个例子的步骤中，我们简单地实现了一个均匀的流场，其方向和一维原始状态（密度、速度、压力）从参数文件中读取。

// 最好是一次性初始化这个类：初始化/设置参数并定义依赖于这些默认参数的类成员。然而，由于我们不知道参数的实际值，这在一般情况下是毫无意义和不安全的（我们希望有机制来检查输入参数的一致性）。我们没有定义另一个 <code>setup()</code> 方法在调用 ParameterAcceptor::initialize() 后被调用（手动），而是为类成员 <code>parse_parameters_call_back()</code> 提供了一个 "实现"，当调用 ParameterAcceptor::initialize() 时，每个继承自ParameterAceptor的类都会自动调用。

  template <int dim> 
  class InitialValues : public ParameterAcceptor 
  { 
  public: 
    using state_type = typename ProblemDescription<dim>::state_type; 

    InitialValues(const std::string &subsection = "InitialValues"); 

    std::function<state_type(const Point<dim> &point, double t)> initial_state; 

  private: 

// 我们声明一个私有的回调函数，它将与 ParameterAcceptor::parse_parameters_call_back 信号相连接。

    void parse_parameters_callback(); 

    Tensor<1, dim> initial_direction; 
    Tensor<1, 3>   initial_1d_state; 
  }; 
// @sect4{The <code>%TimeStepping</code> class}  

// 有了 <code>OfflineData</code> and <code>ProblemDescription</code> 类在手，我们现在可以实现上面讨论中介绍的显式时间步进方案。 <code>%TimeStepping</code> 类的主要方法是<code>make_one_step(vector_type &U, double t)</code>，它接受对状态向量 <code>U</code> and a time point <code>t</code> 的引用（作为输入参数）计算更新的解决方案，将其存储在向量 <code>temp</code>, swaps its contents with the vector <code>U</code> 中，并返回选择的 step- 大小 $\tau$  。

// 另一个重要的方法是  <code>prepare()</code>  ，主要是为临时向量  <code>temp</code> and the matrix <code>dij_matrix</code>  分别设置适当的分区和稀疏模式。

  template <int dim> 
  class TimeStepping : public ParameterAcceptor 
  { 
  public: 
    static constexpr unsigned int problem_dimension = 
      ProblemDescription<dim>::problem_dimension; 

    using state_type = typename ProblemDescription<dim>::state_type; 
    using flux_type  = typename ProblemDescription<dim>::flux_type; 

    using vector_type = 
      std::array<LinearAlgebra::distributed::Vector<double>, problem_dimension>; 

    TimeStepping(const MPI_Comm            mpi_communicator, 
                 TimerOutput &             computing_timer, 
                 const OfflineData<dim> &  offline_data, 
                 const InitialValues<dim> &initial_values, 
                 const std::string &       subsection = "TimeStepping"); 

    void prepare(); 

    double make_one_step(vector_type &U, double t); 

  private: 
    const MPI_Comm mpi_communicator; 
    TimerOutput &  computing_timer; 

    SmartPointer<const OfflineData<dim>>   offline_data; 
    SmartPointer<const InitialValues<dim>> initial_values; 

    SparseMatrix<double> dij_matrix; 

    vector_type temporary_vector; 

    double cfl_update; 
  }; 
// @sect4{The <code>SchlierenPostprocessor</code> class}  

// 在其核心中，Schlieren类实现了类成员  <code>compute_schlieren()</code>  。这个类成员的主要目的是计算一个辅助的有限元场 <code>schlieren</code>  ，它在每个节点上由\f[ \text{schlieren}[i] = e^{\beta \frac{ |\nabla r_i| - \min_j |\nabla r_j| }{\max_j |\nabla r_j| - \min_j |\nabla r_j| } }, \f]定义，其中 $r$ 原则上可以是任何标量。但在实践中，密度是一个自然的候选量，即 $r \dealcoloneq \rho$  。<a href="https:en.wikipedia.org/wiki/Schlieren">Schlieren</a>后处理是一种标准的方法，用于增强可视化的对比度，其灵感来自实际的实验X射线和可视化的阴影技术。(参见  step-67  另一个例子，我们创建了一个Schlieren图。)

  template <int dim> 
  class SchlierenPostprocessor : public ParameterAcceptor 
  { 
  public: 
    static constexpr unsigned int problem_dimension = 
      ProblemDescription<dim>::problem_dimension; 

    using state_type = typename ProblemDescription<dim>::state_type; 

    using vector_type = 
      std::array<LinearAlgebra::distributed::Vector<double>, problem_dimension>; 

    SchlierenPostprocessor( 
      const MPI_Comm          mpi_communicator, 
      TimerOutput &           computing_timer, 
      const OfflineData<dim> &offline_data, 
      const std::string &     subsection = "SchlierenPostprocessor"); 

    void prepare(); 

    void compute_schlieren(const vector_type &U); 

    LinearAlgebra::distributed::Vector<double> schlieren; 

  private: 
    const MPI_Comm mpi_communicator; 
    TimerOutput &  computing_timer; 

    SmartPointer<const OfflineData<dim>> offline_data; 

    Vector<double> r; 

    unsigned int schlieren_index; 
    double       schlieren_beta; 
  }; 
// @sect4{The <code>MainLoop</code> class}  

// 现在，剩下的就是把 <code>%TimeStepping</code>, <code>InitialValues</code>  , 和  <code>SchlierenPostprocessor</code>  类中实现的方法连在一起。我们在一个单独的类 <code>MainLoop</code> 中做到这一点，该类包含每个类的一个对象，并在ParameterAcceptor类的帮助下再次读入一些参数。

  template <int dim> 
  class MainLoop : public ParameterAcceptor 
  { 
  public: 
    using vector_type = typename TimeStepping<dim>::vector_type; 

    MainLoop(const MPI_Comm mpi_communnicator); 

    void run(); 

  private: 
    vector_type interpolate_initial_values(const double t = 0); 

    void output(const vector_type &U, 
                const std::string &name, 
                double             t, 
                unsigned int       cycle, 
                bool               checkpoint = false); 

    const MPI_Comm     mpi_communicator; 
    std::ostringstream timer_output; 
    TimerOutput        computing_timer; 

    ConditionalOStream pcout; 

    std::string base_name; 
    double      t_final; 
    double      output_granularity; 

    bool asynchronous_writeback; 

    bool resume; 

    Discretization<dim>         discretization; 
    OfflineData<dim>            offline_data; 
    InitialValues<dim>          initial_values; 
    TimeStepping<dim>           time_stepping; 
    SchlierenPostprocessor<dim> schlieren_postprocessor; 

    vector_type output_vector; 

    std::future<void> background_thread_state; 
  }; 
// @sect3{Implementation}  
// @sect4{Grid generation, setup of data structures}  

// 手头的第一个主要任务是典型的网格生成、数据结构的设置和装配这三者。在这个例子的步骤中，一个值得注意的创新是使用ParameterAcceptor类，我们用它来填充参数值：我们首先初始化ParameterAcceptor类，用一个字符串 <code>subsection</code> 表示参数文件中的正确分节，调用它的构造器。然后，在构造函数中，每个参数值都被初始化为一个合理的默认值，并通过调用 ParameterAcceptor::add_parameter(). 向ParameterAcceptor类注册。
  template <int dim> 
  Discretization<dim>::Discretization(const MPI_Comm     mpi_communicator, 
                                      TimerOutput &      computing_timer, 
                                      const std::string &subsection) 
    : ParameterAcceptor(subsection) 
    , mpi_communicator(mpi_communicator) 
    , triangulation(mpi_communicator) 
    , mapping(1) 
    , finite_element(1) 
    , quadrature(3) 
    , face_quadrature(3) 
    , computing_timer(computing_timer) 
  { 
    length = 4.; 
    add_parameter("length", length, "Length of computational domain"); 

    height = 2.; 
    add_parameter("height", height, "Height of computational domain"); 

    disk_position = 0.6; 
    add_parameter("object position", 
                  disk_position, 
                  "x position of immersed disk center point"); 

    disk_diameter = 0.5; 
    add_parameter("object diameter", 
                  disk_diameter, 
                  "Diameter of immersed disk"); 

    refinement = 5; 
    add_parameter("refinement", 
                  refinement, 
                  "Number of refinement steps of the geometry"); 
  } 

// 注意在前面的构造函数中，我们只把MPI通信器传给了 <code>triangulation</code> ，但我们仍然没有初始化底层几何体/网格。如前所述，我们必须将这项任务推迟到 <code>setup()</code> 函数，在 ParameterAcceptor::initialize() 函数用从参数文件中读取的最终值填充所有参数变量后，再调用该函数。

//  <code>setup()</code> 函数是最后一个必须实现的类成员。它创建了实际的三角结构，这是一个基准配置，由一个带有盘状障碍物的通道组成，见  @cite GuermondEtAl2018  。我们通过修改 GridGenerator::hyper_cube_with_cylindrical_hole(). 生成的网格来构建几何体。我们参考 step-49 、 step-53 和 step-54 来了解如何创建高级网格。我们首先创建4个临时的（非分布式的）粗略三角形，用 GridGenerator::merge_triangulation() 函数将其缝合起来。我们在 $(0,0)$ 处将圆盘居中，直径为 <code>disk_diameter</code>  。通道的左下角有坐标（  <code>-disk_position</code>, <code>-height/2</code>  ），右上角有（  <code>length-disk_position</code>  ,  <code>height/2</code>  ）。

  template <int dim> 
  void Discretization<dim>::setup() 
  { 
    TimerOutput::Scope scope(computing_timer, "discretization - setup"); 

    triangulation.clear(); 

    Triangulation<dim> tria1, tria2, tria3, tria4, tria5, tria6; 

    GridGenerator::hyper_cube_with_cylindrical_hole( 
      tria1, disk_diameter / 2., disk_diameter, 0.5, 1, false); 

    GridGenerator::subdivided_hyper_rectangle( 
      tria2, 
      {2, 1}, 
      Point<2>(-disk_diameter, disk_diameter), 
      Point<2>(disk_diameter, height / 2.)); 

    GridGenerator::subdivided_hyper_rectangle( 
      tria3, 
      {2, 1}, 
      Point<2>(-disk_diameter, -disk_diameter), 
      Point<2>(disk_diameter, -height / 2.)); 

    GridGenerator::subdivided_hyper_rectangle( 
      tria4, 
      {6, 2}, 
      Point<2>(disk_diameter, -disk_diameter), 
      Point<2>(length - disk_position, disk_diameter)); 

    GridGenerator::subdivided_hyper_rectangle( 
      tria5, 
      {6, 1}, 
      Point<2>(disk_diameter, disk_diameter), 
      Point<2>(length - disk_position, height / 2.)); 

    GridGenerator::subdivided_hyper_rectangle( 
      tria6, 
      {6, 1}, 
      Point<2>(disk_diameter, -height / 2.), 
      Point<2>(length - disk_position, -disk_diameter)); 

    GridGenerator::merge_triangulations( 
      {&tria1, &tria2, &tria3, &tria4, &tria5, &tria6}, 
      triangulation, 
      1.e-12, 
      true); 

    triangulation.set_manifold(0, PolarManifold<2>(Point<2>())); 

// 我们必须修复目前位于 $x=-$ 的左边缘。
// <code>disk_diameter</code> ，必须移到 $x=-$ 。
// <code>disk_position</code>  . 作为最后一步，边界必须被着色，右边是 <code>Boundaries::do_nothing</code> ， <code>dirichlet</code> on the left and <code>free_slip</code> 是上、下外边界和障碍物。

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        for (const auto v : cell->vertex_indices()) 
          { 
            if (cell->vertex(v)[0] <= -disk_diameter + 1.e-6) 
              cell->vertex(v)[0] = -disk_position; 
          } 
      } 

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        for (const auto f : cell->face_indices()) 
          { 
            const auto face = cell->face(f); 

            if (face->at_boundary()) 
              { 
                const auto center = face->center(); 

                if (center[0] > length - disk_position - 1.e-6) 
                  face->set_boundary_id(Boundaries::do_nothing); 
                else if (center[0] < -disk_position + 1.e-6) 
                  face->set_boundary_id(Boundaries::dirichlet); 
                else 
                  face->set_boundary_id(Boundaries::free_slip); 
              } 
          } 
      } 

    triangulation.refine_global(refinement); 
  } 
// @sect4{Assembly of offline matrices}  

// 在 <code>OfflineData</code> 的构造函数中，除了在初始化列表中初始化相应的类成员外，没有做太多的工作。

  template <int dim> 
  OfflineData<dim>::OfflineData(const MPI_Comm             mpi_communicator, 
                                TimerOutput &              computing_timer, 
                                const Discretization<dim> &discretization, 
                                const std::string &        subsection) 
    : ParameterAcceptor(subsection) 
    , dof_handler(discretization.triangulation) 
    , mpi_communicator(mpi_communicator) 
    , computing_timer(computing_timer) 
    , discretization(&discretization) 
  {} 

// 现在我们可以初始化DoFHandler，为本地拥有的和本地相关的DOF提取IndexSet对象，并初始化一个 Utilities::MPI::Partitioner 对象，这是分布式向量需要的。

  template <int dim> 
  void OfflineData<dim>::setup() 
  { 
    IndexSet locally_owned; 
    IndexSet locally_relevant; 

    { 
      TimerOutput::Scope scope(computing_timer, 
                               "offline_data - distribute dofs"); 

      dof_handler.distribute_dofs(discretization->finite_element); 

      locally_owned   = dof_handler.locally_owned_dofs(); 
      n_locally_owned = locally_owned.n_elements(); 

      DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant); 
      n_locally_relevant = locally_relevant.n_elements(); 

      partitioner = 
        std::make_shared<Utilities::MPI::Partitioner>(locally_owned, 
                                                      locally_relevant, 
                                                      mpi_communicator); 
    } 
// @sect4{Translation to local index ranges}  

// 我们现在可以为我们的矩阵创建稀疏模式了。有相当多的特殊性需要详细解释。我们避免使用分布式矩阵类（例如由Trilinos或PETSc提供的），而是依靠deal.II自己的SparseMatrix对象来存储所有矩阵的局部部分。这一设计决定的动机是：(a)我们实际上从未进行过矩阵-向量乘法，(b)我们总是可以在一个给定的MPI等级上专门组装矩阵的局部部分。相反，我们将计算非线性更新，同时迭代连通性模版的（局部）部分；这是deal.II自己的SparsityPattern专门为之优化的任务。

// 不过，这种设计考虑有一个注意事项。让deal.II SparseMatrix类变得快速的是SparsityPattern中使用的<a
//  href="https:en.wikipedia.org/wiki/Sparse_matrix">compressed row
//  storage (CSR)</a>（见 @ref Sparsity  ）。不幸的是，这与全局分布式索引范围不相称，因为具有CSR的稀疏模式不能在索引范围内包含 "洞"。deal.II提供的分布式矩阵通过将全局索引范围转化为连续的局部索引范围来避免这一点。但这正是我们在迭代模版时想要避免的索引操作类型，因为它产生了可衡量的开销。

//  Utilities::MPI::Partitioner 类已经实现了从全局索引范围到连续的局部（每个MPI等级）索引范围的转换：我们不需要重新发明轮子。我们只需要使用这种转换能力（一次，而且只有一次），以便为连续的索引范围创建一个 "本地 "稀疏模式  $[0,$  。
// <code>n_locally_relevant</code>  
// $)$  . 这种能力可以通过 Utilities::MPI::Partitioner::global_to_local() 函数来调用。一旦使用本地索引创建了稀疏模式，剩下要做的就是确保（在实现我们的scatter和gather辅助函数时）我们总是通过调用 LinearAlgebra::distributed::Vector::local_element(). 来访问分布式向量的元素，这样我们就完全避免了索引转换，并完全使用本地索引进行操作。

    { 
      TimerOutput::Scope scope( 
        computing_timer, 
        "offline_data - create sparsity pattern and set up matrices"); 

// 我们必须手工创建 "本地 "稀疏模式。因此，我们在所有本地拥有的和重影的单元上循环（见  @ref  GlossArtificialCell），并提取与单元DOF相关的（全局）  <code>dof_indices</code>  ，并使用  <code>partitioner->global_to_local(index)</code>  重新编号。

// 在本地拥有的DOF的情况下，这种重新编号包括应用一个移位（即我们减去一个偏移量），这样，现在它们将成为整数区间 $[0,$ 中的一个数字。
// <code>n_locally_owned</code>   $)$  .
//然而，在重影道次的情况下（即不是本地拥有的），情况就完全不同了，因为与重影道次相关的全局指数（一般来说）不会是一个连续的整数集。

      DynamicSparsityPattern dsp(n_locally_relevant, n_locally_relevant); 

      const auto dofs_per_cell = 
        discretization->finite_element.n_dofs_per_cell(); 
      std::vector<types::global_dof_index> dof_indices(dofs_per_cell); 

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        { 
          if (cell->is_artificial()) 
            continue; 

          /* We transform the set of global dof indices on the cell to the
           * corresponding "local" index range on the MPI process: */
          cell->get_dof_indices(dof_indices); 
          std::transform(dof_indices.begin(), 
                         dof_indices.end(), 
                         dof_indices.begin(), 
                         [&](types::global_dof_index index) { 
                           return partitioner->global_to_local(index); 
                         }); 

/* 为每个dof简单地添加一个与所有其他 "本地 "的联接。 */

           /* dofs on the cell: */ 


          for (const auto dof : dof_indices) 
            dsp.add_entries(dof, dof_indices.begin(), dof_indices.end()); 
        } 

      sparsity_pattern.copy_from(dsp); 

      lumped_mass_matrix.reinit(sparsity_pattern); 
      norm_matrix.reinit(sparsity_pattern); 
      for (auto &matrix : cij_matrix) 
        matrix.reinit(sparsity_pattern); 
      for (auto &matrix : nij_matrix) 
        matrix.reinit(sparsity_pattern); 
    } 
  } 

// DoFHandler和SparseMatrix对象的设置到此结束。接下来，我们要组装各种矩阵。我们在一个匿名命名空间中定义了一些辅助函数和数据结构。

  namespace 
  { 
// <code>CopyData</code> 类，将用于使用WorkStream组装离线数据矩阵。它作为一个容器：它只是一个结构，WorkStream在其中存储本地单元的贡献。请注意，它还包含一个类成员 <code>local_boundary_normal_map</code> ，用于存储计算边界法线所需的局部贡献。

    template <int dim> 
    struct CopyData 
    { 
      bool                                         is_artificial; 
      std::vector<types::global_dof_index>         local_dof_indices; 
      typename OfflineData<dim>::BoundaryNormalMap local_boundary_normal_map; 
      FullMatrix<double>                           cell_lumped_mass_matrix; 
      std::array<FullMatrix<double>, dim>          cell_cij_matrix; 
    }; 

// 接下来我们介绍一些辅助函数，它们都是关于读写矩阵和向量条目的。它们的主要动机是提供稍微有效的代码和<a href="https:en.wikipedia.org/wiki/Syntactic_sugar"> syntactic sugar</a>的代码，否则就有些乏味了。

// 我们介绍的第一个函数  <code>get_entry()</code>  ，将用于读取SparsityPattern迭代器  <code>it</code> of <code>matrix</code>  指向的条目所存储的值。该函数绕过了SparseMatrix接口中的一个小缺陷。SparsityPattern关注的是以CRS格式存储的稀疏矩阵的所有索引操作。因此，迭代器已经知道存储在SparseMatrix对象中的低级向量中相应矩阵条目的全局索引。由于SparseMatrix中缺乏直接用SparsityPattern迭代器访问该元素的接口，不幸的是我们必须创建一个临时的SparseMatrix迭代器。我们只需将其隐藏在 <code>get_entry()</code> 函数中。

    template <typename IteratorType> 
    DEAL_II_ALWAYS_INLINE inline SparseMatrix<double>::value_type 
    get_entry(const SparseMatrix<double> &matrix, const IteratorType &it) 
    { 
      const SparseMatrix<double>::const_iterator matrix_iterator( 
        &matrix, it->global_index()); 
      return matrix_iterator->value(); 
    } 

//  <code>set_entry()</code> 帮助器是 <code>get_value()</code> 的逆运算：给定一个迭代器和一个值，它在矩阵中设置迭代器所指向的条目。

    template <typename IteratorType> 
    DEAL_II_ALWAYS_INLINE inline void 
    set_entry(SparseMatrix<double> &           matrix, 
              const IteratorType &             it, 
              SparseMatrix<double>::value_type value) 
    { 
      SparseMatrix<double>::iterator matrix_iterator(&matrix, 
                                                     it->global_index()); 
      matrix_iterator->value() = value; 
    } 
// <code>gather_get_entry()</code>  : 我们注意到 $\mathbf{c}_{ij} \in \mathbb{R}^d$  。如果 $d=2$ ，那么 $\mathbf{c}_{ij} = [\mathbf{c}_{ij}^1,\mathbf{c}_{ij}^2]^\top$  。这基本上意味着我们需要每个空间维度的一个矩阵来存储 $\mathbf{c}_{ij}$ 向量。对于矩阵 $\mathbf{n}_{ij}$ 也有类似的观察。 <code>gather_get_entry()</code> 的目的是检索这些条目并将其存储到 <code>Tensor<1, dim></code> 中，以方便我们使用。

    template <std::size_t k, typename IteratorType> 
    DEAL_II_ALWAYS_INLINE inline Tensor<1, k> 
    gather_get_entry(const std::array<SparseMatrix<double>, k> &c_ij, 
                     const IteratorType                         it) 
    { 
      Tensor<1, k> result; 
      for (unsigned int j = 0; j < k; ++j) 
        result[j] = get_entry(c_ij[j], it); 
      return result; 
    } 
// <code>gather()</code> （第一个接口）：这个第一个函数签名，有三个输入参数，将被用来检索矩阵的各个组成部分 <code>(i,l)</code> 。 <code>gather_get_entry()</code> 和 <code>gather()</code> 的功能非常相同，但它们的背景不同：函数 <code>gather()</code> 不依赖迭代器（实际上知道指向的值），而是依赖条目的索引 <code>(i,l)</code> ，以便检索其实际值。我们应该期望  <code>gather()</code>  比  <code>gather_get_entry()</code>  稍微昂贵一些。 <code>gather()</code> 的使用将限于计算代数粘度 $d_{ij}$ 的任务，在特殊情况下，当 $i$ 和 $j$ 都位于边界时。

//  @note  读者应该知道，访问一个矩阵的任意 <code>(i,l)</code> 条目（例如Trilinos或PETSc矩阵）一般来说是昂贵得不可接受的。在这里，我们可能要注意复杂度：我们希望这个操作有恒定的复杂度，这就是目前使用deal.II矩阵的实现的情况。

    template <std::size_t k> 
    DEAL_II_ALWAYS_INLINE inline Tensor<1, k> 
    gather(const std::array<SparseMatrix<double>, k> &n_ij, 
           const unsigned int                         i, 
           const unsigned int                         j) 
    { 
      Tensor<1, k> result; 
      for (unsigned int l = 0; l < k; ++l) 
        result[l] = n_ij[l](i, j); 
      return result; 
    } 
// <code>gather()</code> （第二个接口）：这个有两个输入参数的第二个函数签名将被用来收集节点 <code>i</code> 的状态，并作为 <code>Tensor<1,problem_dimension></code> 返回，以方便我们使用。

    template <std::size_t k> 
    DEAL_II_ALWAYS_INLINE inline Tensor<1, k> 
    gather(const std::array<LinearAlgebra::distributed::Vector<double>, k> &U, 
           const unsigned int                                               i) 
    { 
      Tensor<1, k> result; 
      for (unsigned int j = 0; j < k; ++j) 
        result[j] = U[j].local_element(i); 
      return result; 
    } 
// <code>scatter()</code>  ：这个函数有三个输入参数，第一个是指一个 "全局对象"（比如一个本地拥有的或本地相关的矢量），第二个参数可以是一个 <code>Tensor<1,problem_dimension></code>  ，最后一个参数代表全局对象的索引。这个函数主要用于将更新的节点值（存储为 <code>Tensor<1,problem_dimension></code> ）写入全局对象中。

    template <std::size_t k, int k2> 
    DEAL_II_ALWAYS_INLINE inline void 
    scatter(std::array<LinearAlgebra::distributed::Vector<double>, k> &U, 
            const Tensor<1, k2> &                                      tensor, 
            const unsigned int                                         i) 
    { 
      static_assert(k == k2, 
                    "The dimensions of the input arguments must agree"); 
      for (unsigned int j = 0; j < k; ++j) 
        U[j].local_element(i) = tensor[j]; 
    } 
  } // namespace 

// 我们现在可以将储存在 <code>OfflineData</code> 中的所有矩阵集合起来：质量分录 $m_i$ ，矢量值矩阵 $\mathbf{c}_{ij}$ 和 $\mathbf{n}_{ij} = \frac{\mathbf{c}_{ij}}{|\mathbf{c}_{ij}|}$ ，以及边界法线 $\boldsymbol{\nu}_i$  。

// 为了利用线程并行化，我们使用了 @ref threads "多处理器的并行计算 "中详述的WorkStream方法来访问共享内存。按照惯例，这需要定义 

// - 抓取数据（即进行计算所需的输入信息）：在这种情况下，它是  <code>scratch_data</code>  。

// - 工作者：在我们的例子中，这是一个 <code>local_assemble_system()</code> 函数，它实际上是从抓取数据中计算出本地（即当前单元）贡献。

// - 拷贝数据：一个包含所有本地装配贡献的结构，在这里是  <code>CopyData<dim>()</code>  。

// - 一个拷贝数据的程序：在这种情况下，它是 <code>copy_local_to_global()</code> ，负责将这些局部贡献实际复制到全局对象（矩阵和/或矢量）中。

// 下面的大部分行是用来定义工作者  <code>local_assemble_system()</code>  和复制数据例程  <code>copy_local_to_global()</code>  的。关于WorkStream框架没有太多可说的，因为绝大多数的想法在  step-9  、  step-13  和  step-32  等文件中都有合理的记载。

// 最后，假设 $\mathbf{x}_i$ 是边界上的一个支持点，（节点）法线定义为。

// 
// @f{align*}
//  \widehat{\boldsymbol{\nu}}_i \dealcoloneq
//   \frac{\int_{\partial\Omega} \phi_i \widehat{\boldsymbol{\nu}} \,
//   \, \mathrm{d}\mathbf{s}}{\big|\int_{\partial\Omega} \phi_i
//   \widehat{\boldsymbol{\nu}} \, \mathrm{d}\mathbf{s}\big|}
//  @f}

// 我们将首先计算这个表达式的分子，并将其存储在  <code>OfflineData<dim>::BoundaryNormalMap</code>  中。我们将在一个后置循环中对这些向量进行归一化处理。

  template <int dim> 
  void OfflineData<dim>::assemble() 
  { 
    lumped_mass_matrix = 0.; 
    norm_matrix        = 0.; 
    for (auto &matrix : cij_matrix) 
      matrix = 0.; 
    for (auto &matrix : nij_matrix) 
      matrix = 0.; 

    unsigned int dofs_per_cell = 
      discretization->finite_element.n_dofs_per_cell(); 
    unsigned int n_q_points = discretization->quadrature.size(); 

// 下面是WorkStream所需的从动数据的初始化过程

    MeshWorker::ScratchData<dim> scratch_data( 
      discretization->mapping, 
      discretization->finite_element, 
      discretization->quadrature, 
      update_values | update_gradients | update_quadrature_points | 
        update_JxW_values, 
      discretization->face_quadrature, 
      update_normal_vectors | update_values | update_JxW_values); 

    { 
      TimerOutput::Scope scope( 
        computing_timer, 
        "offline_data - assemble lumped mass matrix, and c_ij"); 

      const auto local_assemble_system = // 
        [&](const typename DoFHandler<dim>::cell_iterator &cell, 
            MeshWorker::ScratchData<dim> &                 scratch, 
            CopyData<dim> &                                copy) { 
          copy.is_artificial = cell->is_artificial(); 
          if (copy.is_artificial) 
            return; 

          copy.local_boundary_normal_map.clear(); 
          copy.cell_lumped_mass_matrix.reinit(dofs_per_cell, dofs_per_cell); 
          for (auto &matrix : copy.cell_cij_matrix) 
            matrix.reinit(dofs_per_cell, dofs_per_cell); 

          const auto &fe_values = scratch.reinit(cell); 

          copy.local_dof_indices.resize(dofs_per_cell); 
          cell->get_dof_indices(copy.local_dof_indices); 

          std::transform(copy.local_dof_indices.begin(), 
                         copy.local_dof_indices.end(), 
                         copy.local_dof_indices.begin(), 
                         [&](types::global_dof_index index) { 
                           return partitioner->global_to_local(index); 
                         }); 

// 我们以通常的方式计算凑合质量矩阵项 $m_i$ 和向量 $c_{ij}$ 的局部贡献。

          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
            { 
              const auto JxW = fe_values.JxW(q_point); 

              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  const auto value_JxW = 
                    fe_values.shape_value(j, q_point) * JxW; 
                  const auto grad_JxW = fe_values.shape_grad(j, q_point) * JxW; 

                  copy.cell_lumped_mass_matrix(j, j) += value_JxW; 

                  for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                    { 
                      const auto value = fe_values.shape_value(i, q_point); 
                      for (unsigned int d = 0; d < dim; ++d) 
                        copy.cell_cij_matrix[d](i, j) += value * grad_JxW[d]; 

                    } /* i */ 


                }     /* j */ 


            }         /* q */ 



// 现在我们要计算边界法线。请注意，除非该元素在域的边界上有面，否则下面的循环不会有什么作用。

          for (const auto f : cell->face_indices()) 
            { 
              const auto face = cell->face(f); 
              const auto id   = face->boundary_id(); 

              if (!face->at_boundary()) 
                continue; 

              const auto &fe_face_values = scratch.reinit(cell, f); 

              const unsigned int n_face_q_points = 
                fe_face_values.get_quadrature().size(); 

              for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                { 
                  if (!discretization->finite_element.has_support_on_face(j, f)) 
                    continue; 

// 注意，"normal "只代表形状函数phi_j支持下的一个面的贡献。所以我们不能在这里对这个局部贡献进行归一化处理，我们必须 "原封不动 "地接受它，存储它并将它传递给复制数据例程。正确的归一化需要在节点上增加一个循环。这在下面的复制函数中完成。

                  Tensor<1, dim> normal; 
                  if (id == Boundaries::free_slip) 
                    { 
                      for (unsigned int q = 0; q < n_face_q_points; ++q) 
                        normal += fe_face_values.normal_vector(q) * 
                                  fe_face_values.shape_value(j, q); 
                    } 

                  const auto index = copy.local_dof_indices[j]; 

                  Point<dim> position; 
                  for (const auto v : cell->vertex_indices()) 
                    if (cell->vertex_dof_index(v, 0) == 
                        partitioner->local_to_global(index)) 
                      { 
                        position = cell->vertex(v); 
                        break; 
                      } 

                  const auto old_id = 
                    std::get<1>(copy.local_boundary_normal_map[index]); 
                  copy.local_boundary_normal_map[index] = 
                    std::make_tuple(normal, std::max(old_id, id), position); 
                } 
            } 
        }; 

// 最后，我们根据WorkStream的要求，提供一个copy_local_to_global函数

      const auto copy_local_to_global = [&](const CopyData<dim> &copy) { 
        if (copy.is_artificial) 
          return; 

        for (const auto &it : copy.local_boundary_normal_map) 
          { 
            std::get<0>(boundary_normal_map[it.first]) += 
              std::get<0>(it.second); 
            std::get<1>(boundary_normal_map[it.first]) = 
              std::max(std::get<1>(boundary_normal_map[it.first]), 
                       std::get<1>(it.second)); 
            std::get<2>(boundary_normal_map[it.first]) = std::get<2>(it.second); 
          } 

        lumped_mass_matrix.add(copy.local_dof_indices, 
                               copy.cell_lumped_mass_matrix); 

        for (int k = 0; k < dim; ++k) 
          { 
            cij_matrix[k].add(copy.local_dof_indices, copy.cell_cij_matrix[k]); 
            nij_matrix[k].add(copy.local_dof_indices, copy.cell_cij_matrix[k]); 
          } 
      }; 

      WorkStream::run(dof_handler.begin_active(), 
                      dof_handler.end(), 
                      local_assemble_system, 
                      copy_local_to_global, 
                      scratch_data, 
                      CopyData<dim>()); 
    } 

// 此时我们已经完成了 $m_i$ 和 $\mathbf{c}_{ij}$ 的计算，但到目前为止，矩阵 <code>nij_matrix</code> 只包含矩阵 <code>cij_matrix</code> 的一个副本。这不是我们真正想要的：我们必须对其条目进行标准化处理。此外，我们还没有填充矩阵 <code>norm_matrix</code> 的条目，存储在映射 <code>OfflineData<dim>::BoundaryNormalMap</code> 中的向量没有被归一化。

// 原则上，这只是离线数据，过度优化它们的计算并没有什么意义，因为它们的成本会在我们将要使用的许多时间步骤中得到摊销。然而，计算/存储矩阵 <code>norm_matrix</code> and the normalization of <code>nij_matrix</code> 的条目是说明线程并行节点循环的最佳方式。

// 我们要访问网格/稀疏图中的每个节点 $i$ 。

// - 对于每一个这样的节点，我们要访问每一个 $j$ ，以便 $\mathbf{c}_{ij} \not \equiv 0$  。

// 从代数的角度来看，这相当于：访问矩阵中的每一行，并对这些行中的每一行在列上执行循环。节点循环是本教程步骤的一个核心主题（见介绍中的伪代码），会反复出现。这就是为什么现在是介绍它们的恰当时机。

// 我们有线程并行化能力 parallel::apply_to_subranges() ，在某种程度上比WorkStream框架更通用。特别是， parallel::apply_to_subranges() 可以用于我们的节点循环。这个功能需要四个输入参数，我们详细解释一下（针对我们的线程并行节点循环的具体案例）。

// - 迭代器  <code>indices.begin()</code>  指向一个行索引。

// - 迭代器 <code>indices.end()</code> 指向一个数字上更高的行索引。

// - 函数 <code>on_subranges(i1,i2)</code> (where <code>i1</code> 和 <code>i2</code> 在前面两个子弹中定义的end和begin迭代器所跨越的范围内定义了一个子范围）对这个子范围内的每个迭代器应用一个操作。我们也可以把 <code>on_subranges</code> 称为 "工作者"。

// - Grainsize：每个线程处理的最小迭代器（在本例中代表行）的数量。我们决定最小为4096行。

// 一个小的注意事项是，提供给 parallel::apply_to_subranges() 的迭代器 <code>indices.begin()</code> 和 <code>indices.end()</code> 必须是随机访问的迭代器：在内部， parallel::apply_to_subranges() 将把 <code>indices.begin()</code> 和 <code>indices.end()</code> 迭代器定义的范围分成子范围（我们希望能够以恒定的复杂性读取这些子范围的任何条目）。为了提供这样的迭代器，我们求助于 std_cxx20::ranges::iota_view. 。

// 下面这段代码的大部分是用来定义 "工作者" <code>on_subranges</code> ：即在子范围的每一行应用的操作。给定一个固定的 <code>row_index</code> ，我们要访问这一行的每一列/每一个条目。为了执行这样的列-循环，我们使用标准库中的<a href="http:www.cplusplus.com/reference/algorithm/for_each/"> std::for_each</a>，其中。

// -  <code>sparsity_pattern.begin(row_index)</code> 给我们一个迭代器，从该行的第一列开始。

// -  <code>sparsity_pattern.end(row_index)</code> 是一个指向该行最后一列的迭代器。

// -  `std::for_each` 所要求的最后一个参数是应用于该行的每个非零条目（本例中为lambda表达式）的操作。

// 我们注意到， parallel::apply_to_subranges() 将对不相交的行集（子行）进行操作，我们的目标是写入这些行中。由于我们要进行的操作的简单性质（法线的计算和存储，以及条目 $\mathbf{c}_{ij}$ 的规范化），线程在试图写同一个条目时不会发生冲突（我们不需要一个调度器）。

    { 
      TimerOutput::Scope scope(computing_timer, 
                               "offline_data - compute |c_ij|, and n_ij"); 

      const std_cxx20::ranges::iota_view<unsigned int, unsigned int> indices( 
        0, n_locally_relevant); 

      const auto on_subranges = // 
        [&](const auto i1, const auto i2) { 
          for (const auto row_index : 
               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1, 
                                                                        *i2)) 
            { 

// 第一个列循环：我们计算并存储矩阵norm_matrix的条目，并将归一化的条目写入矩阵nij_matrix中。

              std::for_each( 
                sparsity_pattern.begin(row_index), 
                sparsity_pattern.end(row_index), 
                [&](const dealii::SparsityPatternIterators::Accessor &jt) { 
                  const auto   c_ij = gather_get_entry(cij_matrix, &jt); 
                  const double norm = c_ij.norm(); 

                  set_entry(norm_matrix, &jt, norm); 
                  for (unsigned int j = 0; j < dim; ++j) 
                    set_entry(nij_matrix[j], &jt, c_ij[j] / norm); 
                }); 
            } 
        }; 

      parallel::apply_to_subranges(indices.begin(), 
                                   indices.end(), 
                                   on_subranges, 
                                   4096); 

// 最后，我们对存储在  <code>OfflineData<dim>::BoundaryNormalMap</code>  中的向量进行规范化。这个操作没有被线程并行化，因为它既不能说明任何重要的概念，也不能带来任何明显的速度提升。

      for (auto &it : boundary_normal_map) 
        { 
          auto &normal = std::get<0>(it.second); 
          normal /= (normal.norm() + std::numeric_limits<double>::epsilon()); 
        } 
    } 
  } 

// 在这一点上，我们已经很好地完成了与离线数据有关的事情。

//  @sect4{Equation of state and approximate Riemann solver}  

// 在这一节中，我们描述了 <code>ProblemDescription</code> 类的成员的实现。这里的大部分代码都是针对具有理想气体定律的可压缩欧拉方程的。如果我们想把 step-69 重新用于不同的守恒定律（例如：浅水方程），那么这个类的大部分实现就必须改变。但是其他大部分的类（尤其是那些定义循环结构的类）将保持不变。

// 我们首先实现一些小的成员函数来计算 <code>momentum</code>, <code>internal_energy</code> 、 <code>pressure</code>, <code>speed_of_sound</code> 和系统的通量 <code>f</code> 。这些函数中的每一个的功能都可以从它们的名字中不难看出。

  template <int dim> 
  DEAL_II_ALWAYS_INLINE inline Tensor<1, dim> 
  ProblemDescription<dim>::momentum(const state_type &U) 
  { 
    Tensor<1, dim> result; 
    std::copy_n(&U[1], dim, &result[0]); 
    return result; 
  } 

  template <int dim> 
  DEAL_II_ALWAYS_INLINE inline double 
  ProblemDescription<dim>::internal_energy(const state_type &U) 
  { 
    const double &rho = U[0]; 
    const auto    m   = momentum(U); 
    const double &E   = U[dim + 1]; 
    return E - 0.5 * m.norm_square() / rho; 
  } 

  template <int dim> 
  DEAL_II_ALWAYS_INLINE inline double 
  ProblemDescription<dim>::pressure(const state_type &U) 
  { 
    return (gamma - 1.) * internal_energy(U); 
  } 

  template <int dim> 
  DEAL_II_ALWAYS_INLINE inline double 
  ProblemDescription<dim>::speed_of_sound(const state_type &U) 
  { 
    const double &rho = U[0]; 
    const double  p   = pressure(U); 

    return std::sqrt(gamma * p / rho); 
  } 

  template <int dim> 
  DEAL_II_ALWAYS_INLINE inline typename ProblemDescription<dim>::flux_type 
  ProblemDescription<dim>::flux(const state_type &U) 
  { 
    const double &rho = U[0]; 
    const auto    m   = momentum(U); 
    const auto    p   = pressure(U); 
    const double &E   = U[dim + 1]; 

    flux_type result; 

    result[0] = m; 
    for (unsigned int i = 0; i < dim; ++i) 
      { 
        result[1 + i] = m * m[i] / rho; 
        result[1 + i][i] += p; 
      } 
    result[dim + 1] = m / rho * (E + p); 

    return result; 
  } 

// 现在我们讨论  $\lambda_{\text{max}} (\mathbf{U}_i^{n},\mathbf{U}_j^{n}, \textbf{n}_{ij})$  的计算。黎曼问题的最大波速的尖锐上界的分析和推导是一个非常技术性的工作，我们不能在本教程中对其进行高级讨论。在这部分文档中，我们将仅限于简述我们实现函数的主要功能，并指出具体的学术参考文献，以帮助（感兴趣的）读者追溯这些想法的来源（和适当的数学证明）。

// 一般来说，要获得最大波速的尖锐保证上界需要解决一个相当昂贵的标量非线性问题。这通常是通过一个迭代求解器来完成的。为了简化本例中的表述，我们决定不包括这样的迭代方案。相反，我们将只是使用一个初始猜测作为最大波速的上限猜测。更确切地说， @cite GuermondPopov2016b 的方程（2.11）（3.7）、（3.8）和（4.3）足以定义最大波速的保证上限。这个估计值通过调用函数  <code>lambda_max_two_rarefaction()</code>  来返回。在其核心部分，这样一个上界的构造使用了所谓的中间压力的二赖式近似  $p^*$  ，例如，见公式（4.46），在  @cite Toro2009  第128页。

// 由 <code>lambda_max_two_rarefaction()</code> 返回的估计值保证是一个上界，它在一般情况下是相当尖锐的，而且对我们的目的来说总体上是足够的。然而，对于一些特定的情况（特别是当其中一个状态接近真空条件时），这样的估计会过于悲观。这就是为什么我们使用第二个估计来避免这种退化，它将通过调用函数  <code>lambda_max_expansion()</code>  来调用。这里最重要的函数是  <code>compute_lambda_max()</code>  ，它取的是  <code>lambda_max_two_rarefaction()</code>  和  <code>lambda_max_expansion()</code>  所返回的估计值之间的最小值。

// 我们再次开始定义几个辅助函数。

// 第一个函数接收一个状态 <code>U</code> 和一个单位向量 <code>n_ij</code> ，并按照单位向量的方向计算<i>projected</i>一维状态。

  namespace 
  { 
    template <int dim> 
    DEAL_II_ALWAYS_INLINE inline std::array<double, 4> riemann_data_from_state( 
      const typename ProblemDescription<dim>::state_type U, 
      const Tensor<1, dim> &                             n_ij) 
    { 
      Tensor<1, 3> projected_U; 
      projected_U[0] = U[0]; 

// 为此，我们必须将动量改为 $\textbf{m}\cdot n_{ij}$ ，并且必须从总能量中减去垂直部分的动能。

      const auto m   = ProblemDescription<dim>::momentum(U); 
      projected_U[1] = n_ij * m; 

      const auto perpendicular_m = m - projected_U[1] * n_ij; 
      projected_U[2] = U[1 + dim] - 0.5 * perpendicular_m.norm_square() / U[0]; 

// 我们以<i>primitive</i>变量而不是守恒量来返回一维状态。返回数组包括密度  $\rho$  、速度  $u$  、压力  $p$  和局部声速  $a$  。

      return {{projected_U[0], 
               projected_U[1] / projected_U[0], 
               ProblemDescription<1>::pressure(projected_U), 
               ProblemDescription<1>::speed_of_sound(projected_U)}}; 
    } 

// 在这一点上，我们还定义了两个小函数，用来返回一个双数的正负部分。

    DEAL_II_ALWAYS_INLINE inline double positive_part(const double number) 
    { 
      return std::max(number, 0.); 
    } 

    DEAL_II_ALWAYS_INLINE inline double negative_part(const double number) 
    { 
      return -std::min(number, 0.); 
    } 

// 接下来，我们需要两个本地文数，它们是以原始状态 $[\rho, u, p, a]$ 和给定压力 $p^\ast$ 为条件定义的。
// @cite GuermondPopov2016  公式（3.7）。
// @f{align*}
//    \lambda^- = u - a\,\sqrt{1 + \frac{\gamma+1}{2\gamma}
//    \left(\frac{p^\ast-p}{p}\right)_+}
//  @f} 
//  这里， $(\cdot)_{+}$  表示给定参数的正数部分。

    DEAL_II_ALWAYS_INLINE inline double 
    lambda1_minus(const std::array<double, 4> &riemann_data, 
                  const double                 p_star) 
    { 

      /* Implements formula (3.7) in Guermond-Popov-2016 */


      constexpr double gamma = ProblemDescription<1>::gamma; 
      const auto       u     = riemann_data[1]; 
      const auto       p     = riemann_data[2]; 
      const auto       a     = riemann_data[3]; 

      const double factor = (gamma + 1.0) / 2.0 / gamma; 
      const double tmp    = positive_part((p_star - p) / p); 
      return u - a * std::sqrt(1.0 + factor * tmp); 
    } 

// Analougously  @cite GuermondPopov2016  方程（3.8）。
// @f{align*}
//    \lambda^+ = u + a\,\sqrt{1 + \frac{\gamma+1}{2\gamma}
//    \left(\frac{p^\ast-p}{p}\right)_+}
//  @f}

    DEAL_II_ALWAYS_INLINE inline double 
    lambda3_plus(const std::array<double, 4> &riemann_data, const double p_star) 
    { 

      /* Implements formula (3.8) in Guermond-Popov-2016 */

      constexpr double gamma = ProblemDescription<1>::gamma; 
      const auto       u     = riemann_data[1]; 
      const auto       p     = riemann_data[2]; 
      const auto       a     = riemann_data[3]; 

      const double factor = (gamma + 1.0) / 2.0 / gamma; 
      const double tmp    = positive_part((p_star - p) / p); 
      return u + a * std::sqrt(1.0 + factor * tmp); 
    } 

// 剩下的就是计算从左和右原始状态计算出来的 $\lambda^-$ 和 $\lambda^+$ 的最大值（  @cite GuermondPopov2016  公式（2.11）），其中 $p^\ast$ 由 @cite GuermondPopov2016  公式（4.3）给出。

    DEAL_II_ALWAYS_INLINE inline double 
    lambda_max_two_rarefaction(const std::array<double, 4> &riemann_data_i, 
                               const std::array<double, 4> &riemann_data_j) 
    { 
      constexpr double gamma = ProblemDescription<1>::gamma; 
      const auto       u_i   = riemann_data_i[1]; 
      const auto       p_i   = riemann_data_i[2]; 
      const auto       a_i   = riemann_data_i[3]; 
      const auto       u_j   = riemann_data_j[1]; 
      const auto       p_j   = riemann_data_j[2]; 
      const auto       a_j   = riemann_data_j[3]; 

      const double numerator = a_i + a_j - (gamma - 1.) / 2. * (u_j - u_i); 

      const double denominator = 
        a_i * std::pow(p_i / p_j, -1. * (gamma - 1.) / 2. / gamma) + a_j * 1.; 

/* Guermond-Popov-2016 */ 

中的公式（4.3）。
      const double p_star = 
        p_j * std::pow(numerator / denominator, 2. * gamma / (gamma - 1)); 

      const double lambda1 = lambda1_minus(riemann_data_i, p_star); 
      const double lambda3 = lambda3_plus(riemann_data_j, p_star); 

/* Guermond-Popov-2016中的公式（2.11）  */ 

      return std::max(positive_part(lambda3), negative_part(lambda1)); 
    } 

// 我们计算出最大波速的第二个上界，一般来说，它不像二重化估计那样尖锐。但在接近真空的条件下，当二赖子近似值可能达到极端值时，它将挽救一切。
// @f{align*}
//    \lambda_{\text{exp}} = \max(u_i,u_j) + 5. \max(a_i, a_j).
//  @f} 
// @note  常数5.0乘以声速的最大值是<i>neither</i>一个临时的常数，<i>nor</i>一个调整参数。它为任何  $\gamma \in [0,5/3]$  定义了一个上限。请不要玩弄它!

    DEAL_II_ALWAYS_INLINE inline double 
    lambda_max_expansion(const std::array<double, 4> &riemann_data_i, 
                         const std::array<double, 4> &riemann_data_j) 
    { 
      const auto u_i = riemann_data_i[1]; 
      const auto a_i = riemann_data_i[3]; 
      const auto u_j = riemann_data_j[1]; 
      const auto a_j = riemann_data_j[3]; 

      return std::max(std::abs(u_i), std::abs(u_j)) + 5. * std::max(a_i, a_j); 
    } 
  } // namespace 

// 下面是我们要调用的主函数，以计算  $\lambda_{\text{max}} (\mathbf{U}_i^{n},\mathbf{U}_j^{n}, \textbf{n}_{ij})$  。我们简单地计算两个最大的波速估计值并返回最小值。

  template <int dim> 
  DEAL_II_ALWAYS_INLINE inline double 
  ProblemDescription<dim>::compute_lambda_max(const state_type &    U_i, 
                                              const state_type &    U_j, 
                                              const Tensor<1, dim> &n_ij) 
  { 
    const auto riemann_data_i = riemann_data_from_state(U_i, n_ij); 
    const auto riemann_data_j = riemann_data_from_state(U_j, n_ij); 

    const double lambda_1 = 
      lambda_max_two_rarefaction(riemann_data_i, riemann_data_j); 

    const double lambda_2 = 
      lambda_max_expansion(riemann_data_i, riemann_data_j); 

    return std::min(lambda_1, lambda_2); 
  } 

// 我们通过定义静态数组 <code>component_names</code> 来结束本节，这些静态数组包含描述我们的状态向量的组件名称的字符串。我们对维度一、二和三进行了模板特化，这在后面的DataOut中被用来命名相应的组件。

  template <> 
  const std::array<std::string, 3> ProblemDescription<1>::component_names{ 
    {"rho", "m", "E"}}; 

  template <> 
  const std::array<std::string, 4> ProblemDescription<2>::component_names{ 
    {"rho", "m_1", "m_2", "E"}}; 

  template <> 
  const std::array<std::string, 5> ProblemDescription<3>::component_names{ 
    {"rho", "m_1", "m_2", "m_3", "E"}}; 
// @sect4{Initial values}  

// 在我们讨论正向欧拉方案的实现之前，最后一个准备步骤是简单地实现`InitialValues`类。

// 在构造函数中，我们用默认值初始化所有参数，为`参数接受器`类声明所有参数，并将 <code>parse_parameters_call_back</code> 槽连接到相应的信号。

//  <code>parse_parameters_call_back</code> 槽将在调用 ParameterAcceptor::initialize(). 后从ParameterAceptor中调用。 在这方面，它的使用适合于参数必须被后处理（在某种意义上）或必须检查参数之间的某些一致性条件的情况。

  template <int dim> 
  InitialValues<dim>::InitialValues(const std::string &subsection) 
    : ParameterAcceptor(subsection) 
  { 

    /* We wire up the slot InitialValues<dim>::parse_parameters_callback to
       the ParameterAcceptor::parse_parameters_call_back signal: */


    ParameterAcceptor::parse_parameters_call_back.connect( 
      std::bind(&InitialValues<dim>::parse_parameters_callback, this)); 

    initial_direction[0] = 1.; 
    add_parameter("initial direction", 
                  initial_direction, 
                  "Initial direction of the uniform flow field"); 

    initial_1d_state[0] = ProblemDescription<dim>::gamma; 
    initial_1d_state[1] = 3.; 
    initial_1d_state[2] = 1.; 
    add_parameter("initial 1d state", 
                  initial_1d_state, 
                  "Initial 1d state (rho, u, p) of the uniform flow field"); 
  } 

// 到目前为止， <code>InitialValues</code> 的构造函数已经为两个私有成员 <code>initial_direction</code> and <code>initial_1d_state</code> 定义了默认值，并将它们添加到参数列表中。但是我们还没有定义我们真正关心的唯一公共成员的实现，也就是 <code>initial_state()</code> （我们将调用这个函数来实际评估网格节点的初始解）。在该函数的顶部，我们必须确保提供的初始方向不是零矢量。

//  @note  正如所评论的，我们可以避免使用方法  <code>parse_parameters_call_back </code>  并定义一个类成员  <code>setup()</code>  以便定义  <code>initial_state()</code>  的实现。但为了说明问题，我们想在这里记录一种不同的方式，并使用ParameterAcceptor的回调信号。

  template <int dim> 
  void InitialValues<dim>::parse_parameters_callback() 
  { 
    AssertThrow(initial_direction.norm() != 0., 
                ExcMessage( 
                  "Initial shock front direction is set to the zero vector.")); 
    initial_direction /= initial_direction.norm(); 

// 接下来，我们用一个计算均匀流场的lambda函数来实现 <code>initial_state</code> 函数对象。为此，我们必须将给定的原始1d状态（密度 $\rho$ 、速度 $u$ 和压力 $p$ ）转换为保守的n维状态（密度 $\rho$ 、动量 $\mathbf{m}$ 和总能量 $E$  ）。

    initial_state = [this](const Point<dim> & /*point*/, double /*t*/) { 
      const double            rho   = initial_1d_state[0]; 
      const double            u     = initial_1d_state[1]; 
      const double            p     = initial_1d_state[2]; 
      static constexpr double gamma = ProblemDescription<dim>::gamma; 

      state_type state; 

      state[0] = rho; 
      for (unsigned int i = 0; i < dim; ++i) 
        state[1 + i] = rho * u * initial_direction[i]; 

      state[dim + 1] = p / (gamma - 1.) + 0.5 * rho * u * u; 

      return state; 
    }; 
  } 
// @sect4{The Forward Euler step}  

//  <code>%TimeStepping</code> 类的构造函数不包含任何令人惊讶的代码。

  template <int dim> 
  TimeStepping<dim>::TimeStepping( 
    const MPI_Comm            mpi_communicator, 
    TimerOutput &             computing_timer, 
    const OfflineData<dim> &  offline_data, 
    const InitialValues<dim> &initial_values, 
    const std::string &       subsection /*= "TimeStepping"*/) 
    : ParameterAcceptor(subsection) 
    , mpi_communicator(mpi_communicator) 
    , computing_timer(computing_timer) 
    , offline_data(&offline_data) 
    , initial_values(&initial_values) 
  { 
    cfl_update = 0.80; 
    add_parameter("cfl update", 
                  cfl_update, 
                  "Relative CFL constant used for update"); 
  } 

// 在类成员  <code>prepare()</code>  中我们初始化了临时向量  <code>temp</code> and the matrix <code>dij_matrix</code>  。该向量 <code>temp</code> 将在其内容与旧向量交换之前用于临时存储解决方案的更新。

  template <int dim> 
  void TimeStepping<dim>::prepare() 
  { 
    TimerOutput::Scope scope(computing_timer, 
                             "time_stepping - prepare scratch space"); 

    for (auto &it : temporary_vector) 
      it.reinit(offline_data->partitioner); 

    dij_matrix.reinit(offline_data->sparsity_pattern); 
  } 

// 现在是实现正向欧拉步骤的时候了。给出一个在时间 $t$ 的旧状态 <code>U</code> 的（可写引用），我们就地更新状态 <code>U</code> ，并返回所选择的时间步长。我们首先声明一些对各种不同变量和数据结构的只读引用。我们这样做主要是为了有更短的变量名称（例如， <code>sparsity</code> 而不是 <code>offline_data->sparsity_pattern</code> ）。

  template <int dim> 
  double TimeStepping<dim>::make_one_step(vector_type &U, double t) 
  { 
    const auto &n_locally_owned    = offline_data->n_locally_owned; 
    const auto &n_locally_relevant = offline_data->n_locally_relevant; 

    const std_cxx20::ranges::iota_view<unsigned int, unsigned int> 
      indices_owned(0, n_locally_owned); 
    const std_cxx20::ranges::iota_view<unsigned int, unsigned int> 
      indices_relevant(0, n_locally_relevant); 

    const auto &sparsity = offline_data->sparsity_pattern; 

    const auto &lumped_mass_matrix = offline_data->lumped_mass_matrix; 
    const auto &norm_matrix        = offline_data->norm_matrix; 
    const auto &nij_matrix         = offline_data->nij_matrix; 
    const auto &cij_matrix         = offline_data->cij_matrix; 

    const auto &boundary_normal_map = offline_data->boundary_normal_map; 
//<b>Step 1</b>: 计算 $d_{ij}$ 图的粘性矩阵。

// 需要强调的是，粘度矩阵必须是对称的，即  $d_{ij} = d_{ji}$  。在这方面我们注意到， $\int_{\Omega} \nabla \phi_j \phi_i \, \mathrm{d}\mathbf{x}= -
//  \int_{\Omega} \nabla \phi_i \phi_j \, \mathrm{d}\mathbf{x}$ （或等同于 $\mathbf{c}_{ij} = - \mathbf{c}_{ji}$ ）提供了 $\mathbf{x}_i$ 或 $\mathbf{x}_j$ 是一个位于远离边界的支持点。在这种情况下，我们可以通过构造检查出 $\lambda_{\text{max}} (\mathbf{U}_i^{n}, \mathbf{U}_j^{n},
//  \textbf{n}_{ij}) = \lambda_{\text{max}} (\mathbf{U}_j^{n},
//  \mathbf{U}_i^{n},\textbf{n}_{ji})$ ，这保证了 $d_{ij} = d_{ji}$ 的属性。

// 然而，如果两个支持点 $\mathbf{x}_i$ 或 $\mathbf{x}_j$ 恰好都位于边界上，那么，等式 $\mathbf{c}_{ij} =
// - \mathbf{c}_{ji}$ 和 $\lambda_{\text{max}} (\mathbf{U}_i^{n},
//  \mathbf{U}_j^{n}, \textbf{n}_{ij}) = \lambda_{\text{max}}
//  (\mathbf{U}_j^{n}, \mathbf{U}_i^{n}, \textbf{n}_{ji})$ 就不一定成立。对于这个难题，数学上唯一安全的解决方案是计算 $d_{ij}$ 和 $d_{ji}$ ，并取其最大值。

// 总体而言， $d_{ij}$ 的计算是相当昂贵的。为了节省一些计算时间，我们利用了粘度矩阵必须是对称的这一事实（如上所述）：我们只计算 $d_{ij}$ 的上三角条目，并将相应的条目复制到下三角的对应项上。

// 我们再次使用 parallel::apply_to_subranges() 来实现线程并行的for loops。我们在讨论矩阵的组装 <code>norm_matrix</code> 和上面 <code>nij_matrix</code> 的归一化时介绍的几乎所有并行遍历的想法都在这里得到了应用。

// 我们再次定义了一个 "工作者 "函数 <code>on_subranges</code> ，计算列索引子范围[i1, i2]的黏度 $d_{ij}$ 。

    { 
      TimerOutput::Scope scope(computing_timer, 
                               "time_stepping - 1 compute d_ij"); 

      const auto on_subranges = // 
        [&](const auto i1, const auto i2) { 
          for (const auto i : 
               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1, 
                                                                        *i2)) 
            { 
              const auto U_i = gather(U, i); 

// 对于一个给定的列索引i，我们遍历从 <code>sparsity.begin(i)</code> 到 <code>sparsity.end(i)</code> 的稀疏模式的列。

              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt) 
                { 
                  const auto j = jt->column(); 

// 我们只计算 $d_{ij}$ ，如果 $j < i$ （上三角条目），随后将数值复制到 $d_{ji}$  。

                  if (j >= i) 
                    continue; 

                  const auto U_j = gather(U, j); 

                  const auto   n_ij = gather_get_entry(nij_matrix, jt); 
                  const double norm = get_entry(norm_matrix, jt); 

                  const auto lambda_max = 
                    ProblemDescription<dim>::compute_lambda_max(U_i, U_j, n_ij); 

                  double d = norm * lambda_max; 

// 如果两个支持点刚好都在边界上，我们也要计算 $d_{ji}$ ，然后再取 $\max(d_{ij},d_{ji})$  。在这之后，我们可以最终设定上三角和下三角的条目。

                  if (boundary_normal_map.count(i) != 0 && 
                      boundary_normal_map.count(j) != 0) 
                    { 
                      const auto n_ji = gather(nij_matrix, j, i); 
                      const auto lambda_max_2 = 
                        ProblemDescription<dim>::compute_lambda_max(U_j, 
                                                                    U_i, 
                                                                    n_ji); 
                      const double norm_2 = norm_matrix(j, i); 

                      d = std::max(d, norm_2 * lambda_max_2); 
                    } 

                  set_entry(dij_matrix, jt, d); 
                  dij_matrix(j, i) = d; 
                } 
            } 
        }; 

      parallel::apply_to_subranges(indices_relevant.begin(), 
                                   indices_relevant.end(), 
                                   on_subranges, 
                                   4096); 
    } 
//<b>Step 2</b>: 计算对角线项  $d_{ii}$  和  $\tau_{\text{max}}$  。

// 到目前为止，我们已经计算了矩阵 <code>dij_matrix</code> 的所有非对角线项。我们仍然需要填补其对角线项，定义为  $d_{ii}^n = - \sum_{j \in \mathcal{I}(i)\backslash \{i\}} d_{ij}^n$  。我们再次使用 parallel::apply_to_subranges() 来实现这一目的。在计算 $d_{ii}$ s的同时，我们也确定了最大的可接受的时间步长，定义为
// \f[
//    \tau_n \dealcoloneq c_{\text{cfl}}\,\min_{i\in\mathcal{V}}
//    \left(\frac{m_i}{-2\,d_{ii}^{n}}\right) \, .
//  \f] 
//  注意， $\min_{i \in \mathcal{V}}$ 的操作本质上是全局的，它在所有节点上操作：首先我们必须在所有线程（特定节点的）上取最小值，然后我们必须在所有MPI进程上取最小值。在目前的实现中。

// - 我们将 <code>tau_max</code> （每个节点）存储为<a href="http:www.cplusplus.com/reference/atomic/atomic/"><code>std::atomic<double></code></a>。   <code>std::atomic</code> 的内部实现将在一个以上的线程试图同时读取和/或写入 <code>tau_max</code> 时，负责保护任何可能的竞赛条件。

// - 为了取所有MPI进程的最小值，我们使用实用函数  <code>Utilities::MPI::min</code>  。

    std::atomic<double> tau_max{std::numeric_limits<double>::infinity()}; 

    { 
      TimerOutput::Scope scope(computing_timer, 
                               "time_stepping - 2 compute d_ii, and tau_max"); 

// on_subranges()将在每个线程上单独执行。因此，变量 <code>tau_max_on_subrange</code> 被存储在线程本地。

      const auto on_subranges = // 
        [&](const auto i1, const auto i2) { 
          double tau_max_on_subrange = std::numeric_limits<double>::infinity(); 

          for (const auto i : 
               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1, 
                                                                        *i2)) 
            { 
              double d_sum = 0.; 

              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt) 
                { 
                  const auto j = jt->column(); 

                  if (j == i) 
                    continue; 

                  d_sum -= get_entry(dij_matrix, jt); 
                } 

// 我们将d_ij项的负数之和存储在对角线的位置上。

              dij_matrix.diag_element(i) = d_sum; 

// 并计算出最大的局部时间步长  <code>tau</code>  。

              const double mass   = lumped_mass_matrix.diag_element(i); 
              const double tau    = cfl_update * mass / (-2. * d_sum); 
              tau_max_on_subrange = std::min(tau_max_on_subrange, tau); 
            } 
// <code>tau_max_on_subrange</code>  包含为（线程局部）子范围计算的最大可能的时间步长。在这一点上，我们必须在所有线程上同步该值。这就是我们使用<a
//  href="http:www.cplusplus.com/reference/atomic/atomic/"><code>std::atomic<double></code></a> 的原因。
//<i>compare exchange</i> 更新机制。

          double current_tau_max = tau_max.load(); 
          while (current_tau_max > tau_max_on_subrange && 
                 !tau_max.compare_exchange_weak(current_tau_max, 
                                                tau_max_on_subrange)) 
            ; 
        }; 

      parallel::apply_to_subranges(indices_relevant.begin(), 
                                   indices_relevant.end(), 
                                   on_subranges, 
                                   4096); 

// 在所有线程完成后，我们可以简单地在所有MPI进程中同步该值。

      tau_max.store(Utilities::MPI::min(tau_max.load(), mpi_communicator)); 

// 这是一个验证计算出的 <code>tau_max</code> 确实是一个有效浮点数的好时机。

      AssertThrow( 
        !std::isnan(tau_max.load()) && !std::isinf(tau_max.load()) && 
          tau_max.load() > 0., 
        ExcMessage( 
          "I'm sorry, Dave. I'm afraid I can't do that. - We crashed.")); 
    } 
//<b>Step 3</b>: 执行更新。

// 在这一点上，我们已经计算了所有的粘性系数  $d_{ij}$  并且我们知道最大的可接受的时间步长  $\tau_{\text{max}}$  。这意味着我们现在可以计算更新了。

// \f[
   \mathbf{U}_i^{n+1} = \mathbf{U}_i^{n} - \frac{\tau_{\text{max}} }{m_i}
   \sum_{j \in \mathcal{I}(i)} (\mathbb{f}(\mathbf{U}_j^{n}) -
   \mathbb{f}(\mathbf{U}_i^{n})) \cdot \mathbf{c}_{ij} - d_{ij}
   (\mathbf{U}_j^{n} - \mathbf{U}_i^{n})
 \f]

// 这个更新公式与介绍中讨论的略有不同（在伪代码中）。然而，可以证明这两个公式在代数上是等价的（它们将产生相同的数值）。我们更倾向于第二个公式，因为它具有自然的取消属性，可能有助于避免数字上的伪影。

    { 
      TimerOutput::Scope scope(computing_timer, 
                               "time_stepping - 3 perform update"); 

      const auto on_subranges = // 
        [&](const auto i1, const auto i2) { 
          for (const auto i : boost::make_iterator_range(i1, i2)) 
            { 
              Assert(i < n_locally_owned, ExcInternalError()); 

              const auto U_i = gather(U, i); 

              const auto   f_i = ProblemDescription<dim>::flux(U_i); 
              const double m_i = lumped_mass_matrix.diag_element(i); 

              auto U_i_new = U_i; 

              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt) 
                { 
                  const auto j = jt->column(); 

                  const auto U_j = gather(U, j); 
                  const auto f_j = ProblemDescription<dim>::flux(U_j); 

                  const auto c_ij = gather_get_entry(cij_matrix, jt); 
                  const auto d_ij = get_entry(dij_matrix, jt); 

                  for (unsigned int k = 0; k < problem_dimension; ++k) 
                    { 
                      U_i_new[k] += 
                        tau_max / m_i * 
                        (-(f_j[k] - f_i[k]) * c_ij + d_ij * (U_j[k] - U_i[k])); 
                    } 
                } 

              scatter(temporary_vector, U_i_new, i); 
            } 
        }; 

      parallel::apply_to_subranges(indices_owned.begin(), 
                                   indices_owned.end(), 
                                   on_subranges, 
                                   4096); 
    } 
//<b>Step 4</b>: 修复了边界状态。

// 作为正向欧拉方法的最后一步，我们必须修复所有的边界状态。正如在介绍中所讨论的，我们

// 在完全不满足边界条件的情况下进行时间推进。

// -- 在时间步长结束时，在后处理步骤中强力执行边界条件。

// 在这里，我们计算修正\f[
//    \mathbf{m}_i \dealcoloneq \mathbf{m}_i - (\boldsymbol{\nu}_i \cdot
//    \mathbf{m}_i) \boldsymbol{\nu}_i,
//  \f]，它消除了 $\mathbf{m}$ 的法线成分。

    { 
      TimerOutput::Scope scope(computing_timer, 
                               "time_stepping - 4 fix boundary states"); 

      for (auto it : boundary_normal_map) 
        { 
          const auto i = it.first; 

// 我们只对本地拥有的子集进行迭代。

          if (i >= n_locally_owned) 
            continue; 

          const auto &normal   = std::get<0>(it.second); 
          const auto &id       = std::get<1>(it.second); 
          const auto &position = std::get<2>(it.second); 

          auto U_i = gather(temporary_vector, i); 

// 在自由滑移的边界上，我们去除动量的法向分量。

          if (id == Boundaries::free_slip) 
            { 
              auto m = ProblemDescription<dim>::momentum(U_i); 
              m -= (m * normal) * normal; 
              for (unsigned int k = 0; k < dim; ++k) 
                U_i[k + 1] = m[k]; 
            } 

// 在Dirichlet边界上，我们强行执行初始条件。

          else if (id == Boundaries::dirichlet) 
            { 
              U_i = initial_values->initial_state(position, t + tau_max); 
            } 

          scatter(temporary_vector, U_i, i); 
        } 
    } 
//<b>Step 5</b>: 我们现在在所有MPI行列上更新幽灵层，将临时向量与解决方案向量交换  <code>U</code>  （将通过引用返回），并返回选择的时间步长  $\tau_{\text{max}}$  。

    for (auto &it : temporary_vector) 
      it.update_ghost_values(); 

    U.swap(temporary_vector); 

    return tau_max; 
  } 
// @sect4{Schlieren postprocessing}  

// 在不同的时间间隔内，我们将输出解决方案的当前状态 <code>U</code> 以及所谓的Schlieren图。 <code>SchlierenPostprocessor</code> 类的构造函数同样不包含任何惊喜。我们只是提供默认值并注册两个参数。

// - schlieren_beta: 是一个临时的正向放大系数，以增强可视化中的对比度。它的实际值是一个品味问题。

// - schlieren_index: 是一个整数，表示我们将使用状态 $[\rho, \mathbf{m},E]$ 中的哪个组件来生成可视化。

  template <int dim> 
  SchlierenPostprocessor<dim>::SchlierenPostprocessor( 
    const MPI_Comm          mpi_communicator, 
    TimerOutput &           computing_timer, 
    const OfflineData<dim> &offline_data, 
    const std::string &     subsection /*= "SchlierenPostprocessor"*/) 
    : ParameterAcceptor(subsection) 
    , mpi_communicator(mpi_communicator) 
    , computing_timer(computing_timer) 
    , offline_data(&offline_data) 
  { 
    schlieren_beta = 10.; 
    add_parameter("schlieren beta", 
                  schlieren_beta, 
                  "Beta factor used in Schlieren-type postprocessor"); 

    schlieren_index = 0; 
    add_parameter("schlieren index", 
                  schlieren_index, 
                  "Use the corresponding component of the state vector for the " 
                  "schlieren plot"); 
  } 

// 同样， <code>prepare()</code> 函数初始化了两个临时向量（  <code>r</code> and <code>schlieren</code>  ）。

  template <int dim> 
  void SchlierenPostprocessor<dim>::prepare() 
  { 
    TimerOutput::Scope scope(computing_timer, 
                             "schlieren_postprocessor - prepare scratch space"); 

    r.reinit(offline_data->n_locally_relevant); 
    schlieren.reinit(offline_data->partitioner); 
  } 

// 我们现在讨论类成员 <code>SchlierenPostprocessor<dim>::compute_schlieren()</code> 的实现，它基本上是取状态向量 <code>U</code> 的一个分量并计算该分量的Schlieren指标（Schlieren指标的公式可以在类的声明 <code>SchlierenPostprocessor</code> 之前找到）。我们首先注意到这个公式需要 "结点梯度"  $\nabla r_j$  。然而，对于  $\mathcal{C}^0$  有限元函数来说，梯度的节点值并没有定义。更为普遍的是，梯度的点值对于 $W^{1,p}(\Omega)$ 函数没有定义。我们可以用最简单的技术来恢复节点的梯度，即加权平均法。

// \f[ \nabla r_j \dealcoloneq \frac{1}{\int_{S_i} \omega_i(\mathbf{x}) \,
//  \mathrm{d}\mathbf{x}}
//   \int_{S_i} r_h(\mathbf{x}) \omega_i(\mathbf{x}) \, \mathrm{d}\mathbf{x}
//  \ \ \ \ \ \mathbf{(*)} \f]

// 其中 $S_i$ 是形状函数 $\phi_i$ 的支持，而 $\omega_i(\mathbf{x})$ 是权重。权重可以是任何正函数，如 $\omega_i(\mathbf{x}) \equiv 1$ （这将使我们恢复通常的均值概念）。但是像往常一样，我们的目标是尽可能多地重复使用离线数据。在这个意义上，最自然的权重选择是 $\omega_i = \phi_i$  。将这种权重的选择和扩展 $r_h(\mathbf{x}) = \sum_{j \in \mathcal{V}} r_j \phi_j(\mathbf{x})$ 插入 $\mathbf{(*)}$ 中，我们得到:

//  \f[
//  \nabla r_j \dealcoloneq \frac{1}{m_i} \sum_{j \in \mathcal{I}(i)} r_j
// \mathbf{c}_{ij} \ \ \ \ \ \mathbf{(**)} \, . 
//  \f]

// 使用这最后一个公式，我们可以恢复平均的节点梯度，而不需要借助任何形式的正交。这个想法与基于边缘的方案（或代数方案）的整体精神非常吻合，我们希望尽可能直接对矩阵和向量进行操作，以避免使用双线性形式、单元环、正交，或在输入参数（上一时间步的状态）和计算更新所需的实际矩阵和向量之间的任何其他中间结构/操作。

// 第二件要注意的事情是，我们必须计算全局最小和最大  $\max_j |\nabla r_j|$  和  $\min_j |\nabla r_j|$  。按照在类成员 <code>%TimeStepping\<dim>::%step()</code> 中用于计算时间步长的相同思路，我们将 $\max_j |\nabla r_j|$ 和 $\min_j |\nabla r_j|$ 定义为原子双数，以解决线程之间的任何冲突。像往常一样，我们使用 <code>Utilities::MPI::max()</code> 和 <code>Utilities::MPI::min()</code> 来寻找所有MPI进程中的全局最大/最小值。

// 最后，不可能在所有节点上单次循环计算Schlieren指标。整个操作需要在节点上进行两次循环。



// - 第一个循环对网格中所有的 $|\nabla r_i|$ 进行计算，并计算边界 $\max_j |\nabla r_j|$ 和 $\min_j |\nabla r_j|$  。

// - 第二个循环最后用公式计算Schlieren指标

// \f[ \text{schlieren}[i] = e^{\beta \frac{ |\nabla r_i|
//  - \min_j |\nabla r_j| }{\max_j |\nabla r_j| - \min_j |\nabla r_j| } }
//  \, . 
//  \f]

// 这意味着我们将不得不为每一个阶段定义两个工作者 <code>on_subranges</code> 。

  template <int dim> 
  void SchlierenPostprocessor<dim>::compute_schlieren(const vector_type &U) 
  { 
    TimerOutput::Scope scope( 
      computing_timer, "schlieren_postprocessor - compute schlieren plot"); 

    const auto &sparsity            = offline_data->sparsity_pattern; 
    const auto &lumped_mass_matrix  = offline_data->lumped_mass_matrix; 
    const auto &cij_matrix          = offline_data->cij_matrix; 
    const auto &boundary_normal_map = offline_data->boundary_normal_map; 
    const auto &n_locally_owned     = offline_data->n_locally_owned; 

    const auto indices = 
      std_cxx20::ranges::iota_view<unsigned int, unsigned int>(0, 
                                                               n_locally_owned); 

// 我们将当前MPI进程中的r_i_max和r_i_min定义为原子倍数，以避免线程之间的竞赛条件。

    std::atomic<double> r_i_max{0.}; 
    std::atomic<double> r_i_min{std::numeric_limits<double>::infinity()}; 

// 第一个循环：计算每个节点的平均梯度以及梯度的全局最大值和最小值。

    { 
      const auto on_subranges = // 
        [&](const auto i1, const auto i2) { 
          double r_i_max_on_subrange = 0.; 
          double r_i_min_on_subrange = std::numeric_limits<double>::infinity(); 

          for (const auto i : boost::make_iterator_range(i1, i2)) 
            { 
              Assert(i < n_locally_owned, ExcInternalError()); 

              Tensor<1, dim> r_i; 

 
                { 
                  const auto j = jt->column(); 

                  if (i == j) 
                    continue; 

                  const auto U_js = U[schlieren_index].local_element(j); 
                  const auto c_ij = gather_get_entry(cij_matrix, jt); 
                  r_i += c_ij * U_js; 
                } 

// 我们在自由滑移边界固定梯度r_i，类似于我们在正向欧拉步骤中固定边界状态的方式。    这样可以避免在自由滑移边界的Schlieren图中出现尖锐的、人为的梯度，这纯粹是一种外观上的选择。

              const auto bnm_it = boundary_normal_map.find(i); 
              if (bnm_it != boundary_normal_map.end()) 
                { 
                  const auto &normal = std::get<0>(bnm_it->second); 
                  const auto &id     = std::get<1>(bnm_it->second); 

                  if (id == Boundaries::free_slip) 
                    r_i -= 1. * (r_i * normal) * normal; 
                  else 
                    r_i = 0.; 
                } 

// 我们提醒读者，我们对结点梯度本身并不感兴趣。我们只想得到它们的规范，以便计算Schlieren指标（用块状质量矩阵 $m_i$  加权）。

              const double m_i    = lumped_mass_matrix.diag_element(i); 
              r[i]                = r_i.norm() / m_i; 
              r_i_max_on_subrange = std::max(r_i_max_on_subrange, r[i]); 
              r_i_min_on_subrange = std::min(r_i_min_on_subrange, r[i]); 
            } 

// 我们将current_r_i_max和current_r_i_min（在当前子范围内）与r_i_max和r_i_min（对于当前MPI进程）进行比较，并在必要时进行更新。

          double current_r_i_max = r_i_max.load(); 
          while (current_r_i_max < r_i_max_on_subrange && 
                 !r_i_max.compare_exchange_weak(current_r_i_max, 
                                                r_i_max_on_subrange)) 
            ; 

          double current_r_i_min = r_i_min.load(); 
          while (current_r_i_min > r_i_min_on_subrange && 
                 !r_i_min.compare_exchange_weak(current_r_i_min, 
                                                r_i_min_on_subrange)) 
            ; 
        }; 

      parallel::apply_to_subranges(indices.begin(), 
                                   indices.end(), 
                                   on_subranges, 
                                   4096); 
    } 

// 在所有MPI进程中同步 <code>r_i_max</code> and <code>r_i_min</code> 。

    r_i_max.store(Utilities::MPI::max(r_i_max.load(), mpi_communicator)); 
    r_i_min.store(Utilities::MPI::min(r_i_min.load(), mpi_communicator)); 

// 第二个循环：我们现在有了矢量 <code>r</code> 和标量 <code>r_i_max</code> and <code>r_i_min</code> 可以使用。这样我们就可以实际计算Schlieren指标了。

    { 
      const auto on_subranges = // 
        [&](const auto i1, const auto i2) { 
          for (const auto i : boost::make_iterator_range(i1, i2)) 
            { 
              Assert(i < n_locally_owned, ExcInternalError()); 

              schlieren.local_element(i) = 
                1. - std::exp(-schlieren_beta * (r[i] - r_i_min) / 
                              (r_i_max - r_i_min)); 
            } 
        }; 

      parallel::apply_to_subranges(indices.begin(), 
                                   indices.end(), 
                                   on_subranges, 
                                   4096); 
    } 

// 最后，交换幽灵元素。

    schlieren.update_ghost_values(); 
  } 
// @sect4{The main loop}  

// 在实现了所有的类之后，是时候创建一个 <code>Discretization<dim></code>, <code>OfflineData<dim></code> 、 <code>InitialValues<dim></code>, <code>%TimeStepping\<dim></code> 和 <code>SchlierenPostprocessor<dim></code> 的实例，并在一个循环中运行欧拉正步。

// 在 <code>MainLoop<dim></code> 的构造函数中，我们现在初始化所有类的实例，并声明一些控制输出的参数。最值得注意的是，我们声明了一个布尔参数 <code>resume</code> ，它将控制程序是否试图从中断的计算中重新启动。

  template <int dim> 
  MainLoop<dim>::MainLoop(const MPI_Comm mpi_communicator) 
    : ParameterAcceptor("A - MainLoop") 
    , mpi_communicator(mpi_communicator) 
    , computing_timer(mpi_communicator, 
                      timer_output, 
                      TimerOutput::never, 
                      TimerOutput::cpu_and_wall_times) 
    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0) 
    , discretization(mpi_communicator, computing_timer, "B - Discretization") 
    , offline_data(mpi_communicator, 
                   computing_timer, 
                   discretization, 
                   "C - OfflineData") 
    , initial_values("D - InitialValues") 
    , time_stepping(mpi_communicator, 
                    computing_timer, 
                    offline_data, 
                    initial_values, 
                    "E - TimeStepping") 
    , schlieren_postprocessor(mpi_communicator, 
                              computing_timer, 
                              offline_data, 
                              "F - SchlierenPostprocessor") 
  { 
    base_name = "test"; 
    add_parameter("basename", base_name, "Base name for all output files"); 

    t_final = 4.; 
    add_parameter("final time", t_final, "Final time"); 

    output_granularity = 0.02; 
    add_parameter("output granularity", 
                  output_granularity, 
                  "time interval for output"); 

    asynchronous_writeback = true; 
    add_parameter("asynchronous writeback", 
                  asynchronous_writeback, 
                  "Write out solution in a background thread performing IO"); 

    resume = false; 
    add_parameter("resume", resume, "Resume an interrupted computation."); 
  } 

// 我们首先在匿名命名空间中实现一个辅助函数 <code>print_head()</code> ，用来在终端输出带有一些漂亮格式的信息。

  namespace 
  { 
    void print_head(ConditionalOStream &pcout, 
                    const std::string & header, 
                    const std::string & secondary = "") 
    { 
      const auto header_size   = header.size(); 
      const auto padded_header = std::string((34 - header_size) / 2, ' ') + 
                                 header + 
                                 std::string((35 - header_size) / 2, ' '); 

      const auto secondary_size = secondary.size(); 
      const auto padded_secondary = 
        std::string((34 - secondary_size) / 2, ' ') + secondary + 
        std::string((35 - secondary_size) / 2, ' '); 

 /* 关闭clang-format  */ 

      pcout << std::endl; 
      pcout << "    ####################################################" << std::endl; 
      pcout << "    #########                                  #########" << std::endl; 
      pcout << "    #########"     <<  padded_header   <<     "#########" << std::endl; 
      pcout << "    #########"     << padded_secondary <<     "#########" << std::endl; 
      pcout << "    #########                                  #########" << std::endl; 
      pcout << "    ####################################################" << std::endl; 
      pcout << std::endl; 
    /* clang-format on  */ 
    } 
  } // namespace 

// 有了 <code>print_head</code> ，现在是时候实现 <code>MainLoop<dim>::run()</code> 了，它包含了我们程序的主循环。

  template <int dim> 
  void MainLoop<dim>::run() 
  { 

// 我们开始读入参数并初始化所有对象。我们在这里注意到，对 ParameterAcceptor::initialize 的调用是从参数文件（其名称作为一个字符串参数给出）中读入所有参数。ParameterAcceptor处理一个全局的ParameterHandler，它被初始化为所有从ParameterAceptor派生的类实例的子节和参数声明。调用initialize进入每个每个派生类的分节，并设置所有使用 ParameterAcceptor::add_parameter() 添加的变量。
    pcout << "Reading parameters and allocating objects... " << std::flush; 

    ParameterAcceptor::initialize("step-69.prm"); 
    pcout << "done" << std::endl; 

// 接下来我们创建三角形，集合所有的矩阵，设置划痕空间，并初始化DataOut<dim>对象。

    { 
      print_head(pcout, "create triangulation"); 
      discretization.setup(); 

      pcout << "Number of active cells:       " 
            << discretization.triangulation.n_global_active_cells() 
            << std::endl; 

      print_head(pcout, "compute offline data"); 
      offline_data.setup(); 
      offline_data.assemble(); 

      pcout << "Number of degrees of freedom: " 
            << offline_data.dof_handler.n_dofs() << std::endl; 

      print_head(pcout, "set up time step"); 
      time_stepping.prepare(); 
      schlieren_postprocessor.prepare(); 
    } 

// 我们将在变量  <code>t</code> and vector <code>U</code>  中存储当前的时间和状态。

    double       t            = 0.; 
    unsigned int output_cycle = 0; 

    print_head(pcout, "interpolate initial values"); 
    vector_type U = interpolate_initial_values(); 
// @sect5{Resume}  

// 默认情况下，布尔值 <code>resume</code> 被设置为false，也就是说，下面的代码段不会被运行。然而，如果 <code>resume==true</code> ，我们表明我们确实有一个中断的计算，程序应重新启动，从检查点文件中读入由 <code>t</code> 、 <code>output_cycle</code>, and <code>U</code> 组成的旧状态。这些检查点文件将在下面讨论的 <code>output()</code> 程序中创建。

    if (resume) 
      { 
        print_head(pcout, "restore interrupted computation"); 

        const unsigned int i = 
          discretization.triangulation.locally_owned_subdomain(); 

        const std::string name = base_name + "-checkpoint-" + 
                                 Utilities::int_to_string(i, 4) + ".archive"; 
        std::ifstream file(name, std::ios::binary); 

// 我们使用一个 <code>boost::archive</code> 来存储和读入检查点状态的内容。

        boost::archive::binary_iarchive ia(file); 
        ia >> t >> output_cycle; 

        for (auto &it1 : U) 
          { 
// <code>it1</code>  遍历状态向量的所有组件  <code>U</code>  。我们依次读入分量的每一个条目，之后更新ghost层。

            for (auto &it2 : it1) 
              ia >> it2; 
            it1.update_ghost_values(); 
          } 
      } 

// 随着初始状态的建立，或中断状态的恢复，是时候进入主循环了。

    output(U, base_name, t, output_cycle++); 

    print_head(pcout, "enter main loop"); 

    for (unsigned int cycle = 1; t < t_final; ++cycle) 
      { 

// 我们首先打印一个信息性的状态信息

        std::ostringstream head; 
        std::ostringstream secondary; 

        head << "Cycle  " << Utilities::int_to_string(cycle, 6) << "  (" // 
             << std::fixed << std::setprecision(1) << t / t_final * 100  // 
             << "%)"; 
        secondary << "at time t = " << std::setprecision(8) << std::fixed << t; 

        print_head(pcout, head.str(), secondary.str()); 

// 然后执行一个单一的前向欧拉步骤。请注意，状态向量 <code>U</code> 被就地更新， <code>time_stepping.make_one_step()</code> 返回选择的步长。

        t += time_stepping.make_one_step(U, t); 

// 后期处理、生成输出和写出当前状态是一个CPU和IO密集型的任务，我们不能在每个时间步长进行处理

// -- 特别是在显式时间步进中。因此，我们只在超过 <code>output_granularity</code> 设定的阈值时，通过调用 <code>output()</code> 函数安排输出。

        if (t > output_cycle * output_granularity) 
          { 
            output(U, base_name, t, output_cycle, true); 
            ++output_cycle; 
          } 
      } 

// 我们等待任何剩余的后台输出线程完成，然后打印一个摘要并退出。

    if (background_thread_state.valid()) 
      background_thread_state.wait(); 

    computing_timer.print_summary(); 
    pcout << timer_output.str() << std::endl; 
  } 

//  <code>interpolate_initial_values</code> 将初始时间 "t "作为输入参数，并在 <code>InitialValues<dim>::initial_state</code> 对象的帮助下填充状态向量 <code>U</code> 。

  template <int dim> 
  typename MainLoop<dim>::vector_type 
  MainLoop<dim>::interpolate_initial_values(const double t) 
  { 
    pcout << "MainLoop<dim>::interpolate_initial_values(t = " << t << ")" 
          << std::endl; 
    TimerOutput::Scope scope(computing_timer, 
                             "main_loop - setup scratch space"); 

    vector_type U; 

    for (auto &it : U) 
      it.reinit(offline_data.partitioner); 

    constexpr auto problem_dimension = 
      ProblemDescription<dim>::problem_dimension; 

//  <code>InitialValues<dim>::initial_state</code> 的函数签名对于 VectorTools::interpolate(). 来说不太合适。我们通过以下方式来解决这个问题：首先，创建一个lambda函数，对于给定的位置 <code>x</code> 只返回 <code>i</code> 的第三部分的值。在ScalarFunctionFromFunctionObject包装器的帮助下，这个lambda又被转换为一个 dealii::Function 。

    for (unsigned int i = 0; i < problem_dimension; ++i) 
      VectorTools::interpolate(offline_data.dof_handler, 
                               ScalarFunctionFromFunctionObject<dim, double>( 
                                 [&](const Point<dim> &x) { 
                                   return initial_values.initial_state(x, t)[i]; 
                                 }), 
                               U[i]); 

    for (auto &it : U) 
      it.update_ghost_values(); 

    return U; 
  } 
// @sect5{Output and checkpointing}  

// 写出最终的 vtk 文件是一项相当密集的 IO 任务，会让主循环停滞一段时间。为了避免这种情况，我们使用了<a
//  href="https:en.wikipedia.org/wiki/Asynchronous_I/O">asynchronous
//  IO</a>的策略，即创建一个后台线程，在主循环被允许继续的情况下执行IO。为了使其发挥作用，我们必须注意两件事。

// - 在运行  <code>output_worker</code>  线程之前，我们必须创建一个状态向量  <code>U</code>  的副本。我们把它存储在向量  <code>output_vector</code>  中。

// - 我们必须避免在后台线程中进行任何MPI通信，否则程序可能会出现死锁。这意味着我们必须在工作线程之外运行后处理程序。

  template <int dim> 
  void MainLoop<dim>::output(const typename MainLoop<dim>::vector_type &U, 
                             const std::string &                        name, 
                             const double                               t, 
                             const unsigned int                         cycle, 
                             const bool checkpoint) 
  { 
    pcout << "MainLoop<dim>::output(t = " << t 
          << ", checkpoint = " << checkpoint << ")" << std::endl; 

// 如果设置了异步回写选项，我们会启动一个后台线程，执行所有的慢速IO到磁盘。在这种情况下，我们必须确保后台线程确实完成了运行。如果没有，我们必须等待它完成。我们用<a
//  href="https:en.cppreference.com/w/cpp/thread/async"><code>std::async()</code></a>启动上述背景线程，该线程返回<a
//  href="https:en.cppreference.com/w/cpp/thread/future"><code>std::future</code></a>对象。这个 <code>std::future</code> 对象包含了函数的返回值，在我们的例子中就是 <code>void</code>  。

    if (background_thread_state.valid()) 
      { 
        TimerOutput::Scope timer(computing_timer, "main_loop - stalled output"); 
        background_thread_state.wait(); 
      } 

    constexpr auto problem_dimension = 
      ProblemDescription<dim>::problem_dimension; 

// 在这一点上，我们制作一份状态向量的副本，运行schlieren后处理器，并运行 DataOut<dim>::build_patches()  实际输出代码是标准的。我们创建一个DataOut实例，附加所有我们想要输出的数据向量，并调用 DataOut<dim>::build_patches(). ，但是有一个转折。为了在后台线程上执行异步IO，我们将DataOut<dim>对象创建为一个共享指针，传递给工作线程，以确保一旦我们退出这个函数，工作线程完成后，DataOut<dim>对象再次被销毁。

    for (unsigned int i = 0; i < problem_dimension; ++i) 
      { 
        output_vector[i] = U[i]; 
        output_vector[i].update_ghost_values(); 
      } 

    schlieren_postprocessor.compute_schlieren(output_vector); 

    auto data_out = std::make_shared<DataOut<dim>>(); 

    data_out->attach_dof_handler(offline_data.dof_handler); 

    const auto &component_names = ProblemDescription<dim>::component_names; 

    for (unsigned int i = 0; i < problem_dimension; ++i) 
      data_out->add_data_vector(output_vector[i], component_names[i]); 

    data_out->add_data_vector(schlieren_postprocessor.schlieren, 
                              "schlieren_plot"); 

    data_out->build_patches(discretization.mapping, 
                            discretization.finite_element.degree - 1); 

// 接下来我们为后台线程创建一个lambda函数。我们 <a href="https:en.cppreference.com/w/cpp/language/lambda">capture</a>  <code>this</code>  指针以及输出函数的大部分参数的值，这样我们就可以在lambda函数中访问它们。

    const auto output_worker = [this, name, t, cycle, checkpoint, data_out]() { 
      if (checkpoint) 
        { 

// 我们通过对<a href="Resume">resume logic</a>的精确反向操作来检查当前状态。

          const unsigned int i = 
            discretization.triangulation.locally_owned_subdomain(); 
          std::string filename = 
            name + "-checkpoint-" + Utilities::int_to_string(i, 4) + ".archive"; 

          std::ofstream file(filename, std::ios::binary | std::ios::trunc); 

          boost::archive::binary_oarchive oa(file); 
          oa << t << cycle; 
          for (const auto &it1 : output_vector) 
            for (const auto &it2 : it1) 
              oa << it2; 
        } 

      DataOutBase::VtkFlags flags(t, 
                                  cycle, 
                                  true, 
                                  DataOutBase::VtkFlags::best_speed); 
      data_out->set_flags(flags); 

      data_out->write_vtu_with_pvtu_record( 
        "", name + "-solution", cycle, mpi_communicator, 6); 
    }; 

// 如果设置了异步回写选项，我们在<a
//  href="https:en.cppreference.com/w/cpp/thread/async"><code>std::async</code></a>函数的帮助下启动一个新的后台线程。该函数返回一个<a
//  href="https:en.cppreference.com/w/cpp/thread/future"><code>std::future</code></a>对象，我们可以用它来查询后台线程的状态。在这一点上，我们可以从 <code>output()</code> 函数中返回，继续在主循环中进行时间步进

// - 该线程将在后台运行。

    if (asynchronous_writeback) 
      { 
        background_thread_state = std::async(std::launch::async, output_worker); 
      } 
    else 
      { 
        output_worker(); 
      } 
  } 

} // namespace Step69 

// 最后是主函数。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      constexpr int dim = 2; 

      using namespace dealii; 
      using namespace Step69; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv); 

      MPI_Comm      mpi_communicator(MPI_COMM_WORLD); 
      MainLoop<dim> main_loop(mpi_communicator); 

      main_loop.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 
} 


CCTest_file/step-7.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2000 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth and Ralf Hartmann, University of Heidelberg, 2000 
 */ 


// @sect3{Include files}  

// 这些第一个包含文件在前面的例子中都已经处理过了，所以我们不再解释其中的内容。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/data_out.h> 

// 在这个例子中，我们将不使用DoFHandler类默认使用的编号方案，而是使用Cuthill-McKee算法对其进行重新编号。正如在 step-2 中已经解释过的，必要的函数被声明在以下文件中。

#include <deal.II/dofs/dof_renumbering.h> 

// 然后我们将展示一个小技巧，如何确保对象在仍在使用时不被删除。为此，deal.II有一个SmartPointer辅助类，它被声明在这个文件中。

#include <deal.II/base/smartpointer.h> 

// 接下来，我们要使用介绍中提到的函数 VectorTools::integrate_difference() ，我们要使用一个ConvergenceTable，在运行过程中收集所有重要的数据，并在最后以表格形式打印出来。这些来自于以下两个文件。

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/base/convergence_table.h> 

// 最后，我们需要使用FEFaceValues类，它与FEValues类在同一个文件中声明。

#include <deal.II/fe/fe_values.h> 

#include <array> 
#include <fstream> 
#include <iostream> 

// 在我们继续实际执行之前的最后一步是打开一个命名空间 <code>Step7</code> ，我们将把所有的东西放进去，正如在介绍的最后所讨论的，并把命名空间 <code>dealii</code> 的成员导入其中。

namespace Step7 
{ 
  using namespace dealii; 
// @sect3{Equation data}  

// 在实现实际求解的类之前，我们首先声明和定义一些代表右手边和求解类的函数类。由于我们要将数值得到的解与精确的连续解进行比较，我们需要一个代表连续解的函数对象。另一方面，我们需要右手边的函数，而这个函数当然与解共享一些特征。为了减少如果我们必须同时改变两个类中的某些东西而产生的依赖性，我们将两个函数的共同特征移到一个基类中。

// 解（正如介绍中所解释的，我们选择三个指数之和）和右手边的共同特征是：指数的数量，它们的中心，以及它们的半宽。我们在以下类别中声明它们。由于指数的数量是一个编译时的常数，我们使用一个固定长度的 <code>std::array</code> 来存储中心点。

  template <int dim> 
  class SolutionBase 
  { 
  protected: 
    static const std::array<Point<dim>, 3> source_centers; 
    static const double                    width; 
  }; 

// 表示指数中心和宽度的变量刚刚被声明，现在我们还需要给它们赋值。在这里，我们可以展示另一个小小的模板魔法，即我们如何根据维度给这些变量分配不同的值。我们将在程序中只使用2维的情况，但我们展示1维的情况是为了说明一个有用的技术。

// 首先我们为1d情况下的中心赋值，我们将中心等距离地放在-1/3、0和1/3处。这个定义的<code>template &lt;&gt;</code>头显示了一个明确的专业化。这意味着，这个变量属于一个模板，但是我们并没有向编译器提供一个模板，让它通过用一些具体的值来替代 <code>dim</code> 来专门化一个具体的变量，而是自己提供一个专门化，在这个例子中是 <code>dim=1</code>  。如果编译器在模板参数等于1的地方看到了对这个变量的引用，它就知道它不需要通过替换 <code>dim</code> 从模板中生成这个变量，而是可以立即使用下面的定义。

  template <> 
  const std::array<Point<1>, 3> SolutionBase<1>::source_centers = { 
    {Point<1>(-1.0 / 3.0), Point<1>(0.0), Point<1>(+1.0 / 3.0)}}; 

// 同样地，我们可以为 <code>dim=2</code> 提供一个明确的特殊化。我们将2d情况下的中心放置如下。

  template <> 
  const std::array<Point<2>, 3> SolutionBase<2>::source_centers = { 
    {Point<2>(-0.5, +0.5), Point<2>(-0.5, -0.5), Point<2>(+0.5, -0.5)}}; 

// 还需要给指数的半宽指定一个值。我们希望对所有维度使用相同的数值。在这种情况下，我们只需向编译器提供一个模板，它可以通过用一个具体的值替换 <code>dim</code> 来生成一个具体的实例。

  template <int dim> 
  const double SolutionBase<dim>::width = 1. / 8.; 

// 在声明和定义了解和右手的特征后，我们可以声明代表这两者的类。它们都代表连续函数，所以它们都派生于Function&lt;dim&gt;基类，它们也继承了SolutionBase类中定义的特征。

// 实际的类是在下面声明的。请注意，为了计算数值解与连续解在L2和H1（半）准则下的误差，我们必须提供精确解的值和梯度。这比我们在以前的例子中所做的要多，在以前的例子中，我们所提供的只是一个或一列点的值。幸运的是，Function类也有用于梯度的虚拟函数，所以我们可以简单地重载Function基类中各自的虚拟成员函数。请注意，一个函数在 <code>dim</code> 空间维度上的梯度是一个大小为 <code>dim</code> 的向量，即一个等级为1、维度为 <code>dim</code> 的张量。就像其他很多东西一样，该库提供了一个合适的类。这个类的一个新特点是，它明确地使用了张量对象，之前在  step-3  和  step-4  中作为中间词出现。张量是标量（等级为零的张量）、向量（等级为一的张量）和矩阵（等级为二的张量）以及高维对象的概括。张量类需要两个模板参数：张量等级和张量维度。例如，在这里我们使用等级为一的张量（向量），维度为 <code>dim</code> (so they have <code>dim</code> 项）。虽然这比使用Vector的灵活性要差一些，但当编译时知道向量的长度时，编译器可以生成更快的代码。此外，指定一个秩为1、维数为 <code>dim</code> 的张量，可以保证张量具有正确的形状（因为它是内置于对象本身的类型中的），所以编译器可以为我们抓住大多数与尺寸有关的错误。

  template <int dim> 
  class Solution : public Function<dim>, protected SolutionBase<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual Tensor<1, dim> 
    gradient(const Point<dim> & p, 
             const unsigned int component = 0) const override; 
  }; 

//精确解类的值和梯度的实际定义是根据其数学定义，不需要过多解释。

// 唯一值得一提的是，如果我们访问一个依赖模板的基类的元素（在本例中是SolutionBase&lt;dim&gt;的元素），那么C++语言会强迫我们写  <code>this-&gt;source_centers</code>  ，对于基类的其他成员也是如此。如果基类不依赖模板，C++就不需要 <code>this-&gt;</code> 的限定。这一点的原因很复杂，C++书籍会在<i>two-stage (name) lookup</i>这句话下进行解释，在deal.II FAQs中也有很长的描述。

  template <int dim> 
  double Solution<dim>::value(const Point<dim> &p, const unsigned int) const 
  { 
    double return_value = 0; 
    for (const auto &center : this->source_centers) 
      { 
        const Tensor<1, dim> x_minus_xi = p - center; 
        return_value += 
          std::exp(-x_minus_xi.norm_square() / (this->width * this->width)); 
      } 

    return return_value; 
  } 

// 同样，这也是对解的梯度的计算。 为了从指数的贡献中积累梯度，我们分配了一个对象  <code>return_value</code>  ，它表示秩  <code>1</code>  和维  <code>dim</code>  的张量的数学量。它的默认构造函数将其设置为只包含零的向量，所以我们不需要明确关心它的初始化。

// 注意，我们也可以把对象的类型定为Point&lt;dim&gt;，而不是Tensor&lt;1,dim&gt;。等级1的张量和点几乎是可以交换的，而且只有非常细微的数学含义不同。事实上，Point&lt;dim&gt;类是由Tensor&lt;1,dim&gt;类派生出来的，这就弥补了它们的相互交换能力。它们的主要区别在于它们在逻辑上的含义：点是空间中的点，比如我们要评估一个函数的位置（例如，见这个函数的第一个参数的类型）。另一方面，秩1的张量具有相同的变换属性，例如，当我们改变坐标系时，它们需要以某种方式旋转；然而，它们不具有点所具有的相同内涵，只是比坐标方向所跨越的空间更抽象的对象。事实上，梯度生活在 "对等 "的空间中，因为它们的分量的维度不是长度，而是长度上的一个）。

  template <int dim> 
  Tensor<1, dim> Solution<dim>::gradient(const Point<dim> &p, 
                                         const unsigned int) const 
  { 
    Tensor<1, dim> return_value; 

    for (const auto &center : this->source_centers) 
      { 
        const Tensor<1, dim> x_minus_xi = p - center; 

// 对于梯度，注意它的方向是沿着（x-x_i），所以我们把这个距离向量的倍数加起来，其中的因子是由指数给出。

        return_value += 
          (-2. / (this->width * this->width) * 
           std::exp(-x_minus_xi.norm_square() / (this->width * this->width)) * 
           x_minus_xi); 
      } 

    return return_value; 
  } 

// 除了代表精确解的函数外，我们还需要一个函数，在组装离散方程的线性系统时，我们可以将其作为右手。这可以通过下面的类和其函数的定义来实现。请注意，这里我们只需要函数的值，而不是它的梯度或高阶导数。

  template <int dim> 
  class RightHandSide : public Function<dim>, protected SolutionBase<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

// 右手边的值是由解的负拉普拉斯加上解本身给出的，因为我们要解决亥姆霍兹方程的问题。

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> &p, 
                                   const unsigned int) const 
  { 
    double return_value = 0; 
    for (const auto &center : this->source_centers) 
      { 
        const Tensor<1, dim> x_minus_xi = p - center; 

// 第一个贡献是拉普拉斯的。

        return_value += 
          ((2. * dim - 
            4. * x_minus_xi.norm_square() / (this->width * this->width)) / 
           (this->width * this->width) * 
           std::exp(-x_minus_xi.norm_square() / (this->width * this->width))); 

// 而第二个是解决方案本身。

        return_value += 
          std::exp(-x_minus_xi.norm_square() / (this->width * this->width)); 
      } 

    return return_value; 
  } 
// @sect3{The Helmholtz solver class}  

// 然后我们需要做所有工作的类。除了它的名字，它的接口与前面的例子基本相同。

// 其中一个不同点是，我们将在几种模式下使用这个类：用于不同的有限元，以及用于自适应细化和全局细化。全局细化还是自适应细化的决定是通过在类的顶部声明的枚举类型传达给该类的构造函数的。构造函数接收一个有限元对象和细化模式作为参数。

// 除了 <code>process_solution</code> 函数外，其余的成员函数与之前一样。在解被计算出来后，我们对它进行一些分析，比如计算各种规范的误差。为了实现一些输出，它需要细化周期的编号，因此得到它作为一个参数。

  template <int dim> 
  class HelmholtzProblem 
  { 
  public: 
    enum RefinementMode 
    { 
      global_refinement, 
      adaptive_refinement 
    }; 

    HelmholtzProblem(const FiniteElement<dim> &fe, 
                     const RefinementMode      refinement_mode); 

    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void refine_grid(); 
    void process_solution(const unsigned int cycle); 

// 现在是这个类的数据元素。在我们以前的例子中已经使用过的变量中，只有有限元对象不同。这个类的对象所操作的有限元被传递给这个类的构造函数。它必须存储一个指向有限元的指针，供成员函数使用。现在，对于本类来说，这没有什么大不了的，但由于我们想在这些程序中展示技术而不是解决方案，我们将在这里指出一个经常出现的问题--当然也包括正确的解决方案。

// 考虑以下在所有示例程序中出现的情况：我们有一个三角形对象，我们有一个有限元对象，我们还有一个DoFHandler类型的对象，它同时使用前两个对象。这三个对象的寿命与其他大多数对象相比都相当长：它们基本上是在程序开始时或外循环时设置的，并在最后被销毁。问题是：我们能否保证DoFHandler使用的两个对象的寿命至少与它们被使用的时间相同？这意味着DoFHandler必须对其他对象的销毁情况有一定的了解。

// 我们将在这里展示库如何设法找出对一个对象仍有活动的引用，并且从使用对象的角度来看，该对象仍然活着。基本上，该方法是沿着以下思路进行的：所有受到这种潜在危险的指针的对象都来自一个叫做Subscriptor的类。例如，Triangulation、DoFHandler和FiniteElement类的一个基类都派生于Subscriptor。后面这个类并没有提供太多的功能，但是它有一个内置的计数器，我们可以订阅这个计数器，因此这个类的名字就叫 "订阅器"。每当我们初始化一个指向该对象的指针时，我们可以增加它的使用计数器，而当我们移开指针或不再需要它时，我们再减少计数器。这样，我们就可以随时检查有多少个对象还在使用该对象。此外，该类需要知道一个指针，它可以用来告诉订阅对象它的无效性。

// 如果一个从Subscriptor类派生出来的对象被销毁，它也必须调用Subscriptor类的析构函数。在这个析构器中，我们使用存储的指针告诉所有订阅的对象该对象的无效性。当对象出现在移动表达式的右侧时，也会发生同样的情况，也就是说，在操作后它将不再包含有效的内容。在试图访问被订阅的对象之前，订阅类应该检查存储在其相应指针中的值。

// 这正是SmartPointer类正在做的事情。它基本上就像一个指针一样，也就是说，它可以被取消引用，可以被分配给其他指针，等等。除此之外，当我们试图解除引用这个类所代表的指针时，它使用上面描述的机制来找出这个指针是否是悬空的。在这种情况下，会抛出一个异常。

// 在本例程序中，我们希望保护有限元对象，避免因某种原因导致所指向的有限元在使用中被破坏。因此，我们使用了一个指向有限元对象的SmartPointer；由于有限元对象在我们的计算中实际上从未改变，我们传递了一个const FiniteElement&lt;dim&gt;作为SmartPointer类的模板参数。请注意，这样声明的指针是在构造求解对象时被分配的，并在销毁时被销毁，所以对有限元对象销毁的锁定贯穿了这个HelmholtzProblem对象的生命周期。

    Triangulation<dim> triangulation; 
    DoFHandler<dim>    dof_handler; 

    SmartPointer<const FiniteElement<dim>> fe; 

    AffineConstraints<double> hanging_node_constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

// 倒数第二个变量存储了传递给构造函数的细化模式。由于它只在构造函数中设置，我们可以声明这个变量为常数，以避免有人不由自主地设置它（例如在一个 "if "语句中，==偶然被写成=）。

    const RefinementMode refinement_mode; 

// 对于每个细化级别，一些数据（比如单元格的数量，或者数值解的L2误差）将被生成，并在之后打印出来。TableHandler可以用来收集所有这些数据，并在运行结束后以简单文本或LaTeX格式的表格输出。这里我们不仅使用TableHandler，还使用了派生类ConvergenceTable，它还可以评估收敛率。

    ConvergenceTable convergence_table; 
  }; 
// @sect3{The HelmholtzProblem class implementation}  
// @sect4{HelmholtzProblem::HelmholtzProblem constructor}  

// 在这个类的构造函数中，我们只设置作为参数传递的变量，并将DoF处理程序对象与三角形（不过目前是空的）相关联。

  template <int dim> 
  HelmholtzProblem<dim>::HelmholtzProblem(const FiniteElement<dim> &fe, 
                                          const RefinementMode refinement_mode) 
    : dof_handler(triangulation) 
    , fe(&fe) 
    , refinement_mode(refinement_mode) 
  {} 
// @sect4{HelmholtzProblem::setup_system}  

// 下面的函数设置了自由度、矩阵和向量的大小等。它的大部分功能在前面的例子中已经展示过了，唯一不同的是在第一次分配自由度后立即进行重新编号的步骤。

// 重编自由度并不难，只要你使用库中的一种算法。它只需要一行代码。这方面的更多信息可以在  step-2  中找到。

// 但是请注意，当你对自由度进行重新编号时，你必须在分配自由度后立即进行，因为诸如悬空节点、稀疏模式等都取决于重新编号后的绝对数。

// 我们在这里介绍重新编号的原因是，这是一个相对便宜的操作，但往往有一个有利的效果。虽然CG迭代本身与自由度的实际排序无关，但我们将使用SSOR作为一个预处理程序。SSOR会经过所有的自由度，并做一些取决于之前发生的操作；因此，SSOR操作并不独立于自由度的编号，而且众所周知，它的性能会通过使用重新编号技术得到改善。一个小实验表明，确实如此，例如，用这里使用的Q1程序进行自适应细化的第五个细化周期的CG迭代次数，在没有重编号的情况下为40次，而在重编号的情况下为36次。对于这个程序中的所有计算，一般都可以观察到类似的节省。

  template <int dim> 
  void HelmholtzProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(*fe); 
    DoFRenumbering::Cuthill_McKee(dof_handler); 

    hanging_node_constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 
    hanging_node_constraints.condense(dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{HelmholtzProblem::assemble_system}  

// 为手头的问题组装方程组，主要是像之前的例子程序一样。然而，无论如何，有些东西已经改变了，所以我们对这个函数进行了相当广泛的评论。

// 在该函数的顶部，你会发现通常的各种变量声明。与以前的程序相比，重要的是我们希望解决的问题也是双二次元的，因此必须使用足够精确的正交公式。此外，我们需要计算面的积分，即 <code>dim-1</code> 维的对象。那么，面的正交公式的声明就很直接了。

  template <int dim> 
  void HelmholtzProblem<dim>::assemble_system() 
  { 
    QGauss<dim>     quadrature_formula(fe->degree + 1); 
    QGauss<dim - 1> face_quadrature_formula(fe->degree + 1); 

    const unsigned int n_q_points      = quadrature_formula.size(); 
    const unsigned int n_face_q_points = face_quadrature_formula.size(); 

    const unsigned int dofs_per_cell = fe->n_dofs_per_cell(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 然后我们需要一些对象来评估正交点上的形状函数的值、梯度等。虽然看起来用一个对象来做域积分和面积分应该是可行的，但是有一个微妙的区别，因为域积分的权重包括域中单元的度量，而面积分的正交需要低维流形中面的度量。在内部，这两个类都根植于一个共同的基类，它完成了大部分工作，并为域积分和面积分提供了相同的接口。

// 对于亥姆霍兹方程的双线性形式的域积分，我们需要计算值和梯度，以及正交点的权重。此外，我们需要实细胞上的正交点（而不是单位细胞上的正交点）来评估右手边的函数。我们用来获取这些信息的对象是之前讨论过的FEValues类。

// 对于面积分，我们只需要形状函数的值以及权重。我们还需要实心单元上的法向量和正交点，因为我们要从精确解对象中确定Neumann值（见下文）。给我们提供这些信息的类被称为FEFaceValues。

    FEValues<dim> fe_values(*fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    FEFaceValues<dim> fe_face_values(*fe, 
                                     face_quadrature_formula, 
                                     update_values | update_quadrature_points | 
                                       update_normal_vectors | 
                                       update_JxW_values); 

// 然后我们需要一些从以前的例子中已经知道的对象。一个表示右侧函数的对象，它在单元格上正交点的值，单元格矩阵和右侧，以及单元格上自由度的指数。

// 请注意，我们对右手边对象的操作只是查询数据，绝不会改变该对象。因此我们可以声明它  <code>const</code>  。

    const RightHandSide<dim> right_hand_side; 
    std::vector<double>      rhs_values(n_q_points); 

// 最后我们定义一个表示精确解函数的对象。我们将用它来计算边界上的诺伊曼值。通常情况下，我们当然会使用一个单独的对象来计算，特别是由于精确解通常是未知的，而诺伊曼值是规定的。然而，我们将有点偷懒，使用我们已经有的信息。当然，现实生活中的程序会在这里采取其他方式。

    Solution<dim> exact_solution; 

// 现在是所有单元格的主循环。这与之前的例子基本没有变化，所以我们只对有变化的地方进行评论。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0.; 
        cell_rhs    = 0.; 

        fe_values.reinit(cell); 

        right_hand_side.value_list(fe_values.get_quadrature_points(), 
                                   rhs_values); 

        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            { 
              for (unsigned int j = 0; j < dofs_per_cell; ++j) 

// 第一件改变的事情是双线性形式。它现在包含了亥姆霍兹方程的附加项。

                cell_matrix(i, j) += 
                  ((fe_values.shape_grad(i, q_point) *     // grad phi_i(x_q) 
                      fe_values.shape_grad(j, q_point)     // grad phi_j(x_q) 
                    +                                      // 
                    fe_values.shape_value(i, q_point) *    // phi_i(x_q) 
                      fe_values.shape_value(j, q_point)) * // phi_j(x_q) 
                   fe_values.JxW(q_point));                // dx 

              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q) 
                              rhs_values[q_point] *               // f(x_q) 
                              fe_values.JxW(q_point));            // dx 
            } 

// 然后是右手边的第二项，即等高线积分。首先我们要找出这个单元格的面与边界部分Gamma2的交点是否为非零。为此，我们对所有面进行循环，检查其边界指示器是否等于 <code>1</code> ，这是我们在下面的 <code>run()</code> 函数中为组成Gamma2的边界部分指定的值。(边界指示器的默认值是 <code>0</code> ，所以只有在我们明确设置的情况下，面的指示器才能等于 <code>1</code> 。)

        for (const auto &face : cell->face_iterators()) 
          if (face->at_boundary() && (face->boundary_id() == 1)) 
            { 

// 如果我们来到这里，那么我们已经找到了一个属于Gamma2的外部面。接下来，我们必须计算形状函数的值和其他数量，这些都是我们在计算轮廓积分时需要的。这是用 <code>reinit</code> 函数完成的，我们已经从FEValue类中知道了。

              fe_face_values.reinit(cell, face); 

// 然后，我们可以通过在所有的正交点上进行循环来进行积分。        在每个正交点上，我们首先计算法线导数的值。我们使用精确解的梯度和从 <code>fe_face_values</code> 对象中获得的当前正交点处的面的法向量来进行计算。然后用它来计算这个面对右手边的额外贡献。

              for (unsigned int q_point = 0; q_point < n_face_q_points; 
                   ++q_point) 
                { 
                  const double neumann_value = 
                    (exact_solution.gradient( 
                       fe_face_values.quadrature_point(q_point)) * 
                     fe_face_values.normal_vector(q_point)); 

                  for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                    cell_rhs(i) += 
                      (fe_face_values.shape_value(i, q_point) * // phi_i(x_q) 
                       neumann_value *                          // g(x_q) 
                       fe_face_values.JxW(q_point));            // dx 
                } 
            } 

// 现在我们有了本单元的贡献，我们可以把它转移到全局矩阵和右手边的向量，就像之前的例子一样。

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          { 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              system_matrix.add(local_dof_indices[i], 
                                local_dof_indices[j], 
                                cell_matrix(i, j)); 

            system_rhs(local_dof_indices[i]) += cell_rhs(i); 
          } 
      } 

// 同样，对边界值的消除和处理也在前面显示过。

// 然而，我们注意到，现在我们插值边界值的边界指标（由 <code>interpolate_boundary_values</code> 的第二个参数表示）不再代表整个边界了。相反，它是我们没有指定其他指标的那部分边界（见下文）。因此，边界上不属于Gamma1的自由度被排除在边界值的插值之外，就像我们希望的那样。

    hanging_node_constraints.condense(system_matrix); 
    hanging_node_constraints.condense(system_rhs); 

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Solution<dim>(), 
                                             boundary_values); 
    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       solution, 
                                       system_rhs); 
  } 
// @sect4{HelmholtzProblem::solve}  

// 解方程组的方法与之前一样。

  template <int dim> 
  void HelmholtzProblem<dim>::solve() 
  { 
    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    hanging_node_constraints.distribute(solution); 
  } 
// @sect4{HelmholtzProblem::refine_grid}  

// 现在是做网格细化的函数。根据传递给构造函数的细化模式，我们进行全局或适应性细化。

// 全局细化很简单，所以没有什么可评论的。 在适应性细化的情况下，我们使用的函数和类与前面的例子程序相同。请注意，我们可以将诺伊曼边界与迪里切特边界区别对待，事实上在这里也应该这样做，因为我们在部分边界上有诺伊曼边界条件，但是由于我们在这里没有描述诺伊曼值的函数（我们只是在组装矩阵时从精确解中构造这些值），我们省略了这个细节，尽管以严格正确的方式做这些并不难添加。

// 在开关的最后，我们有一个看起来稍微有点奇怪的默认情况：一个 <code>Assert</code> statement with a <code>false</code> 条件。由于 <code>Assert</code> 宏在条件为假的时候会引发一个错误，这意味着只要我们碰到这个语句，程序就会被中止。这是故意的。现在我们只实现了两种细化策略（全局性和适应性），但有人可能想增加第三种策略（例如，具有不同细化标准的适应性），并在决定细化模式的枚举中增加第三个成员。如果不是switch语句的默认情况，这个函数会简单地运行到结束而不做任何事情。这很可能不是原意。因此，在deal.II库中，你会发现一个防御性的编程技术，那就是总是有默认的中止案例，以确保在switch语句中列出案例时没有考虑的值最终被抓住，并迫使程序员添加代码来处理它们。我们还将在下面的其他地方使用同样的技术。

  template <int dim> 
  void HelmholtzProblem<dim>::refine_grid() 
  { 
    switch (refinement_mode) 
      { 
        case global_refinement: 
          { 
            triangulation.refine_global(1); 
            break; 
          } 

        case adaptive_refinement: 
          { 
            Vector<float> estimated_error_per_cell( 
              triangulation.n_active_cells()); 

            KellyErrorEstimator<dim>::estimate( 
              dof_handler, 
              QGauss<dim - 1>(fe->degree + 1), 
              std::map<types::boundary_id, const Function<dim> *>(), 
              solution, 
              estimated_error_per_cell); 

            GridRefinement::refine_and_coarsen_fixed_number( 
              triangulation, estimated_error_per_cell, 0.3, 0.03); 

            triangulation.execute_coarsening_and_refinement(); 

            break; 
          } 

        default: 
          { 
            Assert(false, ExcNotImplemented()); 
          } 
      } 
  } 
// @sect4{HelmholtzProblem::process_solution}  

// 最后，我们想在计算出解决方案后对其进行处理。为此，我们用各种（半）准则对误差进行积分，并生成表格，这些表格以后将被用来以漂亮的格式显示对连续解的收敛情况。

  template <int dim> 
  void HelmholtzProblem<dim>::process_solution(const unsigned int cycle) 
  { 

// 我们的第一个任务是计算误差准则。为了整合计算出的数值解和连续解之间的差异（由本文件顶部定义的Solution类描述），我们首先需要一个向量来保存每个单元的误差准则。由于16位数的精度对这些数量来说并不那么重要，我们通过使用 <code>float</code> 而不是 <code>double</code> 值来节省一些内存。

// 下一步是使用库中的一个函数来计算每个单元的L2准则的误差。 我们必须将DoF处理程序对象、保存数值解的节点值的向量、作为函数对象的连续解、它应将每个单元上的误差规范放入的向量、计算该规范的正交规则，以及要使用的规范类型传递给它。这里，我们使用高斯公式，在每个空间方向上有三个点，并计算L2规范。

// 最后，我们想得到全局L2准则。这当然可以通过对每个单元格上的规范的平方求和，然后取该值的平方根来得到。这相当于取每个单元格上的规范向量的l2（小写 <code>l</code>  ）规范。

    Vector<float> difference_per_cell(triangulation.n_active_cells()); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(fe->degree + 1), 
                                      VectorTools::L2_norm); 
    const double L2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 

// 通过同样的程序，我们可以得到H1半正态。我们重新使用 <code>difference_per_cell</code> 向量，因为在计算了上面的 <code>L2_error</code> 变量后，它不再被使用。全局 $H^1$ 半正态误差的计算方法是：取每个单元格上的误差的平方和，然后取其平方根--这个操作由 VectorTools::compute_global_error. 方便地执行。
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      QGauss<dim>(fe->degree + 1), 
                                      VectorTools::H1_seminorm); 
    const double H1_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::H1_seminorm); 

// 最后，我们计算出最大法线。当然，我们实际上不能计算域中*所有*点上的真正的最大误差，而只能计算有限的评估点上的最大误差，为了方便起见，我们仍然称之为 "正交点"，并用一个正交类型的对象来表示，尽管我们实际上没有进行任何积分。

// 然后是我们想在哪些点上精确地进行评估的问题。事实证明，我们得到的结果相当敏感地取决于所使用的 "正交 "点。还有一个超融合的问题。在某些网格上，对于多项式程度 $k\ge 2$ ，有限元解决方案在节点点以及Gauss-Lobatto点上特别精确，比随机选择的点要精确得多。(参见 @cite Li2019 和第1.2节的讨论和参考文献，以了解更多这方面的信息)。换句话说，如果我们有兴趣找到最大的差值 $u(\mathbf x)-u_h(\mathbf x)$ ，那么我们应该看一下 $\mathbf x$ ，这些点特别不属于这种 "特殊 "的点，而且我们特别不应该用`QGauss(fe->degree+1)`来定义我们评估的地方。相反，我们使用一个特殊的正交规则，该规则是通过梯形规则迭代有限元的度数乘以2再加上每个空间方向的1而得到的。请注意，QIterated类的构造函数需要一个一维正交规则和一个数字，这个数字告诉它在每个空间方向重复这个规则的频率。

// 使用这个特殊的正交规则，我们就可以尝试找到每个单元的最大误差。最后，我们通过调用 VectorTools::compute_global_error. 来计算每个单元上的L无穷大误差的全局L无穷大误差。
    const QTrapezoid<1>  q_trapez; 
    const QIterated<dim> q_iterated(q_trapez, fe->degree * 2 + 1); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      Solution<dim>(), 
                                      difference_per_cell, 
                                      q_iterated, 
                                      VectorTools::Linfty_norm); 
    const double Linfty_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::Linfty_norm); 

// 在所有这些错误被计算出来之后，我们最终写出一些输出。此外，我们通过指定列的键和值将重要的数据添加到TableHandler中。 注意，没有必要事先定义列的键 -- 只需添加值即可，列将按照第一次添加值的顺序被引入到表中。

    const unsigned int n_active_cells = triangulation.n_active_cells(); 
    const unsigned int n_dofs         = dof_handler.n_dofs(); 

    std::cout << "Cycle " << cycle << ':' << std::endl 
              << "   Number of active cells:       " << n_active_cells 
              << std::endl 
              << "   Number of degrees of freedom: " << n_dofs << std::endl; 

    convergence_table.add_value("cycle", cycle); 
    convergence_table.add_value("cells", n_active_cells); 
    convergence_table.add_value("dofs", n_dofs); 
    convergence_table.add_value("L2", L2_error); 
    convergence_table.add_value("H1", H1_error); 
    convergence_table.add_value("Linfty", Linfty_error); 
  } 
// @sect4{HelmholtzProblem::run}  

// 和前面的例子程序一样， <code>run</code> 函数控制执行的流程。基本布局与前面的例子一样：在连续细化的网格上有一个外循环，在这个循环中首先是问题的设置，组装线性系统，求解，和后处理。

// 主循环的第一个任务是创建和细化网格。这和前面的例子一样，唯一的区别是我们想把边界的一部分标记为诺伊曼型，而不是迪里希型。

// 为此，我们将使用以下惯例。属于Gamma1的面将有边界指示器 <code>0</code> （这是默认的，所以我们不需要明确设置），属于Gamma2的面将使用 <code>1</code> 作为边界指示器。 为了设置这些值，我们在所有单元格上循环，然后在给定单元格的所有面上循环，检查它是否是我们想用Gamma2表示的边界的一部分，如果是，则将其边界指示器设置为 <code>1</code>  。在本程序中，我们认为左边和底部的边界是Gamma2。我们通过询问一个面的中点的x或y坐标（即向量分量0和1）是否等于-1来确定一个面是否是该边界的一部分，但我们必须给出一些小的回旋余地，因为比较在中间计算中会有四舍五入的浮点数是不稳定的。

// 值得注意的是，我们必须在这里对所有的单元格进行循环，而不仅仅是活动单元格。原因是在细化时，新创建的面会继承其父面的边界指标。如果我们现在只设置活动面的边界指示器，粗化一些单元并在以后细化它们，它们将再次拥有我们没有修改的父单元的边界指示器，而不是我们想要的那个。因此，我们必须改变Gamma2上所有单元的面的边界指标，无论它们是否处于活动状态。另外，我们当然也可以在最粗的网格上完成这项工作（即在第一个细化步骤之前），之后才细化网格。

  template <int dim> 
  void HelmholtzProblem<dim>::run() 
  { 
    const unsigned int n_cycles = 
      (refinement_mode == global_refinement) ? 5 : 9; 
    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle) 
      { 
        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation, -1., 1.); 
            triangulation.refine_global(3); 

            for (const auto &cell : triangulation.cell_iterators()) 
              for (const auto &face : cell->face_iterators()) 
                { 
                  const auto center = face->center(); 
                  if ((std::fabs(center(0) - (-1.0)) < 1e-12) || 
                      (std::fabs(center(1) - (-1.0)) < 1e-12)) 
                    face->set_boundary_id(1); 
                } 
          } 
        else 
          refine_grid(); 

// 接下来的步骤在前面的例子中已经知道了。这主要是每个有限元程序的基本设置。

        setup_system(); 

        assemble_system(); 
        solve(); 

// 在这一连串的函数调用中，最后一步通常是对自己感兴趣的数量的计算解进行评估。这在下面的函数中完成。由于该函数产生的输出显示了当前细化步骤的编号，我们将这个编号作为一个参数传递。

        process_solution(cycle); 
      } 
// @sect5{Output of graphical data}  

// 在最后一次迭代后，我们在最细的网格上输出解决方案。这是用下面的语句序列完成的，我们在以前的例子中已经讨论过了。第一步是生成一个合适的文件名（这里称为 <code>vtk_filename</code> ，因为我们想以VTK格式输出数据；我们添加前缀以区分该文件名与下面其他输出文件的文件名）。在这里，我们通过网格细化算法来增加名称，和上面一样，我们要确保在增加了另一种细化方法而没有通过下面的switch语句来处理的情况下，中止程序。

    std::string vtk_filename; 
    switch (refinement_mode) 
      { 
        case global_refinement: 
          vtk_filename = "solution-global"; 
          break; 
        case adaptive_refinement: 
          vtk_filename = "solution-adaptive"; 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 

// 我们用一个后缀来增加文件名，表示我们在计算中使用的有限元。为此，有限元基类将每个坐标变量中形状函数的最大多项式程度存储为一个变量 <code>degree</code> ，我们在切换语句中使用（注意，双线性形状函数的多项式程度实际上是2，因为它们包含术语 <code>x*y</code> ；但是，每个坐标变量的多项式程度仍然只有1）。我们再次使用同样的防御性编程技术来防止多项式阶数具有意外值的情况，在switch语句的默认分支中使用 <code>Assert (false, ExcNotImplemented())</code> 这个成语。

    switch (fe->degree) 
      { 
        case 1: 
          vtk_filename += "-q1"; 
          break; 
        case 2: 
          vtk_filename += "-q2"; 
          break; 

        default: 
          Assert(false, ExcNotImplemented()); 
      } 

// 一旦我们有了输出文件的基本名称，我们就为VTK输出添加一个合适的扩展名，打开一个文件，并将解决方案的向量添加到将进行实际输出的对象中。

    vtk_filename += ".vtk"; 
    std::ofstream output(vtk_filename); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "solution"); 

// 现在像以前一样建立中间格式是下一步。我们在这里再介绍一下deal.II的一个特点。其背景如下：在这个函数的一些运行中，我们使用了双二次元的有限元。然而，由于几乎所有的输出格式都只支持双线性数据，所以数据只写成了双线性，信息因此而丢失。 当然，我们不能改变图形程序接受其输入的格式，但我们可以用不同的方式来写数据，这样我们就能更接近于四次方近似中的信息。例如，我们可以把每个单元写成四个子单元，每个子单元都有双线数据，这样我们在三角图中的每个单元都有九个数据点。当然，图形程序显示的这些数据仍然只是双线性的，但至少我们又给出了一些我们拥有的信息。

// 为了允许在每个实际单元中写入多个子单元， <code>build_patches</code> 函数接受一个参数（默认为 <code>1</code>  ，这就是为什么你在之前的例子中没有看到这个参数）。这个参数表示每个空间方向上的每个单元应被细分为多少个子单元来输出。例如，如果你给出  <code>2</code>  ，这将导致二维的4个单元和三维的8个单元。对于二次元元素，每个空间方向的两个子单元显然是正确的选择，所以这就是我们所选择的。一般来说，对于多项式阶的元素 <code>q</code>, we use <code>q</code> 细分，元素的顺序也是按照上述方式确定的。

// 有了这样生成的中间格式，我们就可以实际写入图形输出了。

    data_out.build_patches(fe->degree); 
    data_out.write_vtk(output); 
// @sect5{Output of convergence tables}  

// 在图形输出之后，我们还想从我们在  <code>process_solution</code>  中进行的误差计算中生成表格。在那里，我们用每个细化步骤的单元格数量以及不同规范的误差来填充一个表格对象。

// 为了使这些数据有更好的文本输出，我们可能想设置输出时写入数值的精度。我们使用3位数，这对误差规范来说通常是足够的。默认情况下，数据是以定点符号写入的。然而，对于人们想看到的科学符号的列，另一个函数调用设置了 <code>scientific_flag</code> to <code>true</code>  ，导致数字的浮点表示。

    convergence_table.set_precision("L2", 3); 
    convergence_table.set_precision("H1", 3); 
    convergence_table.set_precision("Linfty", 3); 

    convergence_table.set_scientific("L2", true); 
    convergence_table.set_scientific("H1", true); 
    convergence_table.set_scientific("Linfty", true); 

// 对于输出到LaTeX文件的表格，默认的列的标题是作为参数给 <code>add_value</code> 函数的键。要想拥有不同于默认的TeX标题，你可以通过以下函数调用来指定它们。注意，`\\'被编译器简化为`\'，这样，真正的TeX标题就是，例如，` $L^\infty$  -error'。

    convergence_table.set_tex_caption("cells", "\\# cells"); 
    convergence_table.set_tex_caption("dofs", "\\# dofs"); 
    convergence_table.set_tex_caption("L2", "$L^2$-error"); 
    convergence_table.set_tex_caption("H1", "$H^1$-error"); 
    convergence_table.set_tex_caption("Linfty", "$L^\\infty$-error"); 

// 最后，表格中每一列的默认LaTeX格式是`c'（居中）。要指定一个不同的（如`右'），可以使用以下函数。

    convergence_table.set_tex_format("cells", "r"); 
    convergence_table.set_tex_format("dofs", "r"); 

// 在这之后，我们终于可以把表写到标准输出流 <code>std::cout</code> （在多写一行空行之后，使事情看起来更漂亮）。请注意，文本格式的输出是非常简单的，标题可能不会直接打印在特定的列上面。

    std::cout << std::endl; 
    convergence_table.write_text(std::cout); 

// 该表也可以写成LaTeX文件。 在调用 "latex filename "和例如 "xdvi filename "后，可以查看（很好的）格式化的表格，其中filename是我们现在要写入输出的文件名。我们构建文件名的方法和以前一样，但有一个不同的前缀 "error"。

    std::string error_filename = "error"; 
    switch (refinement_mode) 
      { 
        case global_refinement: 
          error_filename += "-global"; 
          break; 
        case adaptive_refinement: 
          error_filename += "-adaptive"; 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    switch (fe->degree) 
      { 
        case 1: 
          error_filename += "-q1"; 
          break; 
        case 2: 
          error_filename += "-q2"; 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    error_filename += ".tex"; 
    std::ofstream error_table_file(error_filename); 

    convergence_table.write_tex(error_table_file); 
// @sect5{Further table manipulations}  

// 在全局细化的情况下，输出收敛率也可能是有意义的。这可以通过ConvergenceTable提供的比常规TableHandler的功能来实现。然而，我们只为全局细化做这件事，因为对于自适应细化来说，确定像收敛顺序这样的事情是比较麻烦的。在此，我们还展示了一些可以用表来做的其他事情。

    if (refinement_mode == global_refinement) 
      { 

// 第一件事是，人们可以将单个列组合在一起，形成所谓的超级列。从本质上讲，这些列保持不变，但被分组的那些列将得到一个贯穿一组中所有列的标题。例如，让我们把 "周期 "和 "单元格 "两列合并成一个名为 "n单元格 "的超级列。

        convergence_table.add_column_to_supercolumn("cycle", "n cells"); 
        convergence_table.add_column_to_supercolumn("cells", "n cells"); 

// 接下来，没有必要总是输出所有的列，或者按照它们在运行过程中最初添加的顺序。选择和重新排列列的工作方式如下（注意，这包括超级列）。

        std::vector<std::string> new_order; 
        new_order.emplace_back("n cells"); 
        new_order.emplace_back("H1"); 
        new_order.emplace_back("L2"); 
        convergence_table.set_column_order(new_order); 

// 对于在这之前发生在ConvergenceTable上的一切，使用一个简单的TableHandler就足够了。事实上，ConvergenceTable是由TableHandler派生出来的，但它提供了自动评估收敛率的额外功能。例如，下面是我们如何让表计算减少率和收敛率（收敛率是减少率的二进制对数）。

        convergence_table.evaluate_convergence_rates( 
          "L2", ConvergenceTable::reduction_rate); 
        convergence_table.evaluate_convergence_rates( 
          "L2", ConvergenceTable::reduction_rate_log2); 
        convergence_table.evaluate_convergence_rates( 
          "H1", ConvergenceTable::reduction_rate); 
        convergence_table.evaluate_convergence_rates( 
          "H1", ConvergenceTable::reduction_rate_log2); 

// 这些函数的每一次调用都会产生一个额外的列，与原来的列（在我们的例子中是 "L2 "和 "H1 "列）合并成一个超级列。

// 最后，我们想再次写下这个收敛图，首先写到屏幕上，然后以LaTeX格式写到磁盘上。文件名还是按照上面的方法构建。

        std::cout << std::endl; 
        convergence_table.write_text(std::cout); 

        std::string conv_filename = "convergence"; 
        switch (refinement_mode) 
          { 
            case global_refinement: 
              conv_filename += "-global"; 
              break; 
            case adaptive_refinement: 
              conv_filename += "-adaptive"; 
              break; 
            default: 
              Assert(false, ExcNotImplemented()); 
          } 
        switch (fe->degree) 
          { 
            case 1: 
              conv_filename += "-q1"; 
              break; 
            case 2: 
              conv_filename += "-q2"; 
              break; 
            default: 
              Assert(false, ExcNotImplemented()); 
          } 
        conv_filename += ".tex"; 

        std::ofstream table_file(conv_filename); 
        convergence_table.write_tex(table_file); 
      } 
  } 

// 在进入 <code>main()</code> 之前的最后一步是关闭命名空间 <code>Step7</code> ，我们已经把这个程序所需要的一切都放在这个命名空间里。

} // namespace Step7 
// @sect3{Main function}  

// 主函数主要和以前一样。唯一不同的是，我们解了三次，一次是Q1和适应性细化，一次是Q1元素和全局细化，一次是Q2元素和全局细化。

// 由于我们在下面为两个空间维度实例化了几个模板类，我们通过在函数的开头声明一个常数来表示空间维度的数量，使之更加通用。如果你想在1d或2d中运行程序，那么你只需要改变这个实例，而不是下面的所有用法。

int main() 
{ 
  const unsigned int dim = 2; 

  try 
    { 
      using namespace dealii; 
      using namespace Step7; 

// 现在是对主类的三次调用。每个调用都被封锁在大括号中，以便在区块结束时和我们进入下一个运行之前销毁各自的对象（即有限元和HelmholtzProblem对象）。这就避免了变量名称的冲突，也确保了在三次运行中的一次运行结束后立即释放内存，而不是只在 <code>try</code> 块的末尾释放。

      { 
        std::cout << "Solving with Q1 elements, adaptive refinement" 
                  << std::endl 
                  << "=============================================" 
                  << std::endl 
                  << std::endl; 

        FE_Q<dim>             fe(1); 
        HelmholtzProblem<dim> helmholtz_problem_2d( 
          fe, HelmholtzProblem<dim>::adaptive_refinement); 

        helmholtz_problem_2d.run(); 

        std::cout << std::endl; 
      } 

      { 
        std::cout << "Solving with Q1 elements, global refinement" << std::endl 
                  << "===========================================" << std::endl 
                  << std::endl; 

        FE_Q<dim>             fe(1); 
        HelmholtzProblem<dim> helmholtz_problem_2d( 
          fe, HelmholtzProblem<dim>::global_refinement); 

        helmholtz_problem_2d.run(); 

        std::cout << std::endl; 
      } 

      { 
        std::cout << "Solving with Q2 elements, global refinement" << std::endl 
                  << "===========================================" << std::endl 
                  << std::endl; 

        FE_Q<dim>             fe(2); 
        HelmholtzProblem<dim> helmholtz_problem_2d( 
          fe, HelmholtzProblem<dim>::global_refinement); 

        helmholtz_problem_2d.run(); 

        std::cout << std::endl; 
      } 
      { 
        std::cout << "Solving with Q2 elements, adaptive refinement" 
                  << std::endl 
                  << "===========================================" << std::endl 
                  << std::endl; 

        FE_Q<dim>             fe(2); 
        HelmholtzProblem<dim> helmholtz_problem_2d( 
          fe, HelmholtzProblem<dim>::adaptive_refinement); 

        helmholtz_problem_2d.run(); 

        std::cout << std::endl; 
      } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-70.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2020 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020 
 */ 


// @sect3{Include files}  其中大部分已经在其他地方介绍过了，我们只对新的部分进行评论。靠近顶部的开关允许在 PETSc 和 Trilinos 线性代数功能之间进行选择，这与  step-40  和  step-50  中的开关类似。

#include <deal.II/base/function.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/lac/block_linear_operator.h> 
#include <deal.II/lac/generic_linear_algebra.h> 
#include <deal.II/lac/linear_operator.h> 
#include <deal.II/lac/linear_operator_tools.h> 

#define FORCE_USE_OF_TRILINOS 

namespace LA 
{ 
#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \ 
  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS)) 
  using namespace dealii::LinearAlgebraPETSc; 
#  define USE_PETSC_LA 
#elif defined(DEAL_II_WITH_TRILINOS) 
  using namespace dealii::LinearAlgebraTrilinos; 
#else 
#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required 
#endif 
} // namespace LA 

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/index_set.h> 
#include <deal.II/base/parameter_acceptor.h> 
#include <deal.II/base/parsed_function.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/distributed/grid_refinement.h> 
#include <deal.II/distributed/solution_transfer.h> 
#include <deal.II/distributed/tria.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_nothing.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/mapping_fe_field.h> 
#include <deal.II/fe/mapping_q.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_in.h> 
#include <deal.II/grid/grid_tools.h> 
#include <deal.II/grid/manifold_lib.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/petsc_precondition.h> 
#include <deal.II/lac/petsc_solver.h> 
#include <deal.II/lac/petsc_sparse_matrix.h> 
#include <deal.II/lac/petsc_vector.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/solver_minres.h> 
#include <deal.II/lac/sparsity_tools.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/vector_tools.h> 

// 这些是关于  step-60  的唯一新的包含文件。在本教程中，实体和流体之间的非匹配耦合是通过一个中间数据结构来计算的，该结构记录了实体的正交点在流体网格中的位置如何演变。这个数据结构需要跟踪描述实体域的每个单元上的正交点的位置、正交权重，如果实体域是同维度的，还需要跟踪每个点的法向量。

// Deal.II通过ParticleHandler类在Particles命名空间中提供这些设施。ParticleHandler是一个允许你管理粒子集合的类（类型为 Particles::Particle), 的对象，代表具有一些附加属性（如id）的点的集合，漂浮在一个 parallel::distributed::Triangulation. 命名空间中的方法和类允许人们轻松实现Particle-In-Cell方法和在分布式三角形上的粒子追踪。

// 我们 "滥用 "这个数据结构来存储嵌入周围流体网格中的实体正交点的位置信息，包括积分权重，以及可能的表面法线。我们之所以使用这个额外的数据结构，是因为实体网格和流体网格可能是不重叠的，如果我们使用两个独立的三角计算对象，那么它们将独立地分布在并行进程中。

// 为了耦合这两个问题，我们依靠ParticleHandler类，在每个粒子中存储一个实体正交点的位置（一般来说，它不与任何流体正交点对齐），它的权重，以及耦合这两个问题可能需要的任何其他信息。这些位置然后与固体叶轮的（规定）速度一起传播。

// 固体正交点的所有权最初是从固体网格本身的MPI分区中继承的。这样产生的粒子后来通过ParticleHandler类的方法分配到流体网格中。这允许MPI进程之间透明地交换关于流体单元和实体正交点之间的重叠模式的信息。

#include <deal.II/particles/data_out.h> 
#include <deal.II/particles/generators.h> 
#include <deal.II/particles/particle_handler.h> 
#include <deal.II/particles/utilities.h> 

// 在生成网格时，我们允许从文件中读取它，如果deal.II已经建立了OpenCASCADE支持，我们也允许读取CAD文件，并将它们作为网格的流形描述符（参见 step-54 对OpenCASCADE命名空间中的各种流形描述符的详细描述）。

#include <deal.II/opencascade/manifold_lib.h> 
#include <deal.II/opencascade/utilities.h> 
#ifdef DEAL_II_WITH_OPENCASCADE 
#  include <TopoDS.hxx> 
#endif 

#include <cmath> 
#include <fstream> 
#include <iostream> 
#include <memory> 

namespace Step70 
{ 
  using namespace dealii; 
// @sect3{Run-time parameter handling}  

// 与我们在 step-60 中所做的类似，我们建立了一个持有我们问题的所有参数的类，并从ParameterAcceptor类中派生出来以简化参数文件的管理和创建。

// ParameterAcceptor范式要求所有参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的错误（比如写成`time = 0`而不是`time == 0`），我们在一个外部类中声明所有的参数，该类在实际的`StokesImmersedProblem`类之前被初始化，并将其作为`const`引用传递给主类。

// 该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了 ParameterHandler::add_parameter() 方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。

  template <int dim, int spacedim = dim> 
  class StokesImmersedProblemParameters : public ParameterAcceptor 
  { 
  public: 
    StokesImmersedProblemParameters(); 

// 然而，由于这个类将作为一个`const`引用传递给StokesImmersedProblem类，我们必须确保我们仍然可以在这里定义的Function类派生的对象中正确设置时间。为了做到这一点，我们声明 `StokesImmersedProblemParameters::rhs` 和 `StokesImmersedProblemParameters::angular_velocity` 成员都是 "可变 "的，并定义以下的小辅助方法，将它们的时间设置为正确的值。

    void set_time(const double &time) const 
    { 
      rhs.set_time(time); 
      angular_velocity.set_time(time); 
    } 

// 该类的其余部分主要由描述模拟及其离散化细节的成员变量组成。下面的参数是关于输出的位置、空间和时间离散化（默认是 $Q_2\times Q_1$ Taylor-Hood离散化，它使用2度的多项式来计算速度），以及在我们再次生成图形输出之前应该经过多少时间步长。

    std::string output_directory = "."; 

    unsigned int velocity_degree = 2; 

    unsigned int number_of_time_steps = 501; 
    double       final_time           = 1.0; 

    unsigned int output_frequency = 1; 

// 我们允许每个网格独立地被细化。在本教程中，固体网格上没有解决物理问题，其速度被作为基准点给出。然而，在本教程中加入一些弹性模型，并将其转化为一个完全成熟的FSI求解器是相对简单的。

    unsigned int initial_fluid_refinement      = 5; 
    unsigned int initial_solid_refinement      = 5; 
    unsigned int particle_insertion_refinement = 3; 

// 为了提供对流体领域的粗略描述，我们使用extract_rtree_level()方法，该方法适用于流体三角结构中每个局部拥有的单元的边界盒树。树的级别越高，提取的边界盒数量就越多，对流体领域的描述也就越准确。然而，大量的边界盒也意味着巨大的通信成本，因为边界盒的收集是由所有进程收集的。

    unsigned int fluid_rtree_extraction_level = 1; 

// 方程中使用的唯一两个数值参数是流体的粘度，以及Nitsche公式中使用的惩罚项 $\beta$ 。

    double viscosity    = 1.0; 
    double penalty_term = 100; 

// 默认情况下，我们创建一个没有着色的hyper_cube，并且我们使用同质的Dirichlet边界条件。在这个集合中，我们存储了设置边界条件时要使用的边界ID。

    std::list<types::boundary_id> homogeneous_dirichlet_ids{0}; 

// 我们在此说明另一种从参数文件中创建三角形的方法，使用 GridGenerator::generate_from_name_and_arguments(), ，该方法接收GridGenerator命名空间中的函数名称，其参数为一个字符串，代表参数的元组。

// 在 Patterns::Tools::Convert 类中详细解释了将参数从字符串解析成字符串的机制，该类用于将字符串翻译成大多数基本STL类型（向量、映射、图元）和基本deal.II类型（点、张量、BoundingBox等）。

// 一般来说，可以用等级1的统一元素表示的对象（即 std::vector<double>,  Point<dim>,  std::set<int>,  等）是用逗号分开的。额外的等级采取分号，允许你将字符串解析为 `std::vector<std::vector<double>>`, 或例如 `std::vector<Point<dim>>`, 类型的对象，如`0.0, 0.1; 0.1, 0.2`。这个字符串可以被解释为两个Point对象的向量，或者一个双数向量的向量。

// 当条目不统一时，比如在元组的情况下，我们用冒号来分隔各个条目。例如，像`5: 0.1, 0.2`这样的字符串可以用来解析一个类型为 `std::pair<int,  Point<2>>的对象或者一个 `std::tuple<int,  的对象。
// std::vector<double>>`.  

// 在我们的例子中，大多数参数是点对象（代表中心、角、细分元素等）、整数值（细分数量）、双倍值（半径、长度等）或布尔选项（如许多GridGenerator函数采取的`colorize`选项）。

// 在下面的例子中，我们设置了合理的默认值，但这些值可以在运行时通过选择GridGenerator命名空间的任何其他支持的函数来改变。如果GridGenerator函数失败，本程序将把网格的名称解释为vtk网格文件名，把参数解释为从manifold_id到描述域的几何形状的CAD文件的映射。每个CAD文件都将被分析，并根据CAD文件本身的内容生成OpenCASCADE命名空间的Manifold。

// 为了尽可能的通用，我们对每个生成的网格都这样做：流体网格、固体网格，但也包括使用三角法生成的示踪粒子。

    std::string name_of_fluid_grid       = "hyper_cube"; 
    std::string arguments_for_fluid_grid = "-1: 1: false"; 
    std::string name_of_solid_grid       = "hyper_rectangle"; 
    std::string arguments_for_solid_grid = spacedim == 2 ? 
                                             "-.5, -.1: .5, .1: false" : 
                                             "-.5, -.1, -.1: .5, .1, .1: false"; 
    std::string name_of_particle_grid = "hyper_ball"; 
    std::string arguments_for_particle_grid = 
      spacedim == 2 ? "0.3, 0.3: 0.1: false" : "0.3, 0.3, 0.3 : 0.1: false"; 

// 同样地，我们允许不同的局部细化策略。特别是，我们限制了细化水平的最大数量，以控制流体网格的最小尺寸，并保证它与实体网格兼容。细化级数的最小值也得到了控制，以确保在流动的大部分地区有足够的精度。此外，我们根据流体速度场的标准误差估计器进行局部细化。

// 我们允许用户选择两种最常见的细化策略，即 "fixed_number "或 "fixed_fraction"，这两种策略参考了 GridRefinement::refine_and_coarsen_fixed_fraction() 和 GridRefinement::refine_and_coarsen_fixed_number(). 方法。

// 细化可以每隔几个时间步骤进行一次，而不是连续进行，我们通过`细化_频率`参数来控制这个值。

    int          max_level_refinement = 8; 
    int          min_level_refinement = 5; 
    std::string  refinement_strategy  = "fixed_fraction"; 
    double       coarsening_fraction  = 0.3; 
    double       refinement_fraction  = 0.3; 
    unsigned int max_cells            = 20000; 
    int          refinement_frequency = 5; 

// 最后，以下两个函数对象被用来控制斯托克斯流的源项和我们移动固体体的角速度。在一个更现实的模拟中，实体速度或其变形将来自于实体域上的辅助问题的解决。在这个例子中，我们把这部分放在一边，只是在浸没的固体上沿Z轴施加一个固定的旋转速度场，由一个可以在参数文件中指定的函数来控制。

    mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> rhs; 
    mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> 
      angular_velocity; 
  }; 

// 还有一个任务就是声明我们在输入文件中可以接受哪些运行时参数。我们将这些参数分成不同的类别，把它们放在ParameterHandler类的不同部分。我们首先在全局范围内声明StokesImmersedProblem使用的所有全局参数。

  template <int dim, int spacedim> 
  StokesImmersedProblemParameters<dim, 
                                  spacedim>::StokesImmersedProblemParameters() 
    : ParameterAcceptor("Stokes Immersed Problem/") 
    , rhs("Right hand side", spacedim + 1) 
    , angular_velocity("Angular velocity") 
  { 
    add_parameter( 
      "Velocity degree", velocity_degree, "", this->prm, Patterns::Integer(1)); 

    add_parameter("Number of time steps", number_of_time_steps); 
    add_parameter("Output frequency", output_frequency); 

    add_parameter("Output directory", output_directory); 

    add_parameter("Final time", final_time); 

    add_parameter("Viscosity", viscosity); 

    add_parameter("Nitsche penalty term", penalty_term); 

    add_parameter("Initial fluid refinement", 
                  initial_fluid_refinement, 
                  "Initial mesh refinement used for the fluid domain Omega"); 

    add_parameter("Initial solid refinement", 
                  initial_solid_refinement, 
                  "Initial mesh refinement used for the solid domain Gamma"); 

    add_parameter("Fluid bounding boxes extraction level", 
                  fluid_rtree_extraction_level, 
                  "Extraction level of the rtree used to construct global " 
                  "bounding boxes"); 

    add_parameter( 
      "Particle insertion refinement", 
      particle_insertion_refinement, 
      "Refinement of the volumetric mesh used to insert the particles"); 

    add_parameter( 
      "Homogeneous Dirichlet boundary ids", 
      homogeneous_dirichlet_ids, 
      "Boundary Ids over which homogeneous Dirichlet boundary conditions are applied"); 

// 下一节专门介绍用于创建各种网格的参数。我们将需要三种不同的三角形。流体网格 "用于定义流体领域，"固体网格 "用于定义固体领域，"粒子网格 "用于分布一些示踪粒子，这些粒子随速度漂移，只作为被动示踪物使用。

    enter_subsection("Grid generation"); 
    { 
      add_parameter("Fluid grid generator", name_of_fluid_grid); 
      add_parameter("Fluid grid generator arguments", arguments_for_fluid_grid); 

      add_parameter("Solid grid generator", name_of_solid_grid); 
      add_parameter("Solid grid generator arguments", arguments_for_solid_grid); 

 
      add_parameter("Particle grid generator arguments", 
                    arguments_for_particle_grid); 
    } 
    leave_subsection(); 

    enter_subsection("Refinement and remeshing"); 
    { 
      add_parameter("Refinement step frequency", refinement_frequency); 
      add_parameter("Refinement maximal level", max_level_refinement); 
      add_parameter("Refinement minimal level", min_level_refinement); 
      add_parameter("Refinement strategy", 
                    refinement_strategy, 
                    "", 
                    this->prm, 
                    Patterns::Selection("fixed_fraction|fixed_number")); 
      add_parameter("Refinement coarsening fraction", coarsening_fraction); 
      add_parameter("Refinement fraction", refinement_fraction); 
      add_parameter("Maximum number of cells", max_cells); 
    } 
    leave_subsection(); 

// 最后的任务是修正右侧函数的默认尺寸，并定义一个有意义的默认角速度而不是零。

    rhs.declare_parameters_call_back.connect([&]() { 
      Functions::ParsedFunction<spacedim>::declare_parameters(this->prm, 
                                                              spacedim + 1); 
    }); 
    angular_velocity.declare_parameters_call_back.connect([&]() { 
      this->prm.set("Function expression", 
                    "t < .500001 ? 6.283185 : -6.283185"); 
    }); 
  } 

// 一旦角速度被提供为一个函数对象，我们就通过下面这个派生自函数类的类来重建点状实体速度。它通过假设实体以给定的角速度绕原点（或3D中的 $z$ 轴）旋转，提供实体在给定位置的速度值。

  template <int spacedim> 
  class SolidVelocity : public Function<spacedim> 
  { 
  public: 
    static_assert(spacedim > 1, 
                  "Cannot instantiate SolidVelocity for spacedim == 1"); 

    SolidVelocity(const Functions::ParsedFunction<spacedim> &angular_velocity) 
      : angular_velocity(angular_velocity) 
    {} 

    virtual double value(const Point<spacedim> &p, 
                         unsigned int           component = 0) const override 
    { 
      Tensor<1, spacedim> velocity; 

// 我们假设角速度是沿Z轴方向的，也就是说，我们把实际的角速度模拟成二维旋转，而不考虑`spacedim`的实际值。

      const double omega = angular_velocity.value(p); 
      velocity[0]        = -omega * p[1]; 
      velocity[1]        = omega * p[0]; 

      return velocity[component]; 
    } 

  private: 
    const Functions::ParsedFunction<spacedim> &angular_velocity; 
  }; 

// 同样地，我们假设固体的位置可以在每个时间步长明确地计算出来，利用角速度的知识。我们计算固体粒子的确切位置，假定固体的旋转量等于时间步长乘以在`p`点计算的角速度。

  template <int spacedim> 
  class SolidPosition : public Function<spacedim> 
  { 
  public: 
    static_assert(spacedim > 1, 
                  "Cannot instantiate SolidPosition for spacedim == 1"); 

    SolidPosition(const Functions::ParsedFunction<spacedim> &angular_velocity, 
                  const double                               time_step) 
      : Function<spacedim>(spacedim) 
      , angular_velocity(angular_velocity) 
      , time_step(time_step) 
    {} 

    virtual double value(const Point<spacedim> &p, 
                         unsigned int           component = 0) const override 
    { 
      Point<spacedim> new_position = p; 

      double dtheta = angular_velocity.value(p) * time_step; 

      new_position[0] = std::cos(dtheta) * p[0] - std::sin(dtheta) * p[1]; 
      new_position[1] = std::sin(dtheta) * p[0] + std::cos(dtheta) * p[1]; 

      return new_position[component]; 
    } 

    void set_time_step(const double new_time_step) 
    { 
      time_step = new_time_step; 
    } 

  private: 
    const Functions::ParsedFunction<spacedim> &angular_velocity; 
    double                                     time_step; 
  }; 
// @sect3{The StokesImmersedProblem class declaration}  

// 我们现在准备介绍我们的教程程序的主类。像往常一样，除了构造函数外，我们只留下一个公共入口：`run()`方法。其他的都是 "私有 "的，并通过run方法本身进行访问。

  template <int dim, int spacedim = dim> 
  class StokesImmersedProblem 
  { 
  public: 
    StokesImmersedProblem( 
      const StokesImmersedProblemParameters<dim, spacedim> &par); 

    void run(); 

// 接下来的部分包含了该类的`private`成员。第一个方法类似于前一个例子中的方法。然而，它不仅负责生成流体的网格，而且还负责生成固体的网格。第二个方法是计算最大的时间步长，保证每个粒子最多移动一个单元。这对于确保 Particles::ParticleHandler 能够找到粒子最终所在的单元是非常重要的，因为它只能从一个单元看向它的近邻（因为在并行设置中，每个MPI进程只知道它拥有的单元以及它们的近邻）。

  private: 
    void make_grid(); 

    double compute_time_step() const; 

// 接下来的两个函数将初始化这个类中使用的 Particles::ParticleHandler 对象。我们有两个这样的对象。一个代表被动追踪器，用于绘制流体粒子的轨迹，而另一个代表固体的材料粒子，它们被放置在固体网格的正交点上。

    void setup_tracer_particles(); 
    void setup_solid_particles(); 

// 剩下的设置分为两部分。以下两个函数中的第一个创建了每次模拟需要的所有对象，而另一个则设置了所有需要在每个细化步骤中重新初始化的对象。

    void initial_setup(); 
    void setup_dofs(); 

// 装配例程与其他斯托克斯装配例程非常相似，但Nitsche限制部分除外，它利用其中一个粒子处理程序在流体域的非匹配部分进行积分，对应于固体的位置。我们将这两部分分成两个独立的函数。

    void assemble_stokes_system(); 
    void assemble_nitsche_restriction(); 

// 其余的函数求解线性系统（看起来与 step-60 中的线性系统几乎相同），然后对解进行后处理。refine_and_transfer()方法仅在每一个`refinement_frequency`步骤中被调用，以适应网格，并确保所有在细化前的时间步骤中计算的场都正确地转移到新的网格中。这包括矢量场，以及粒子信息。同样地，我们每隔`output_frequency`步就会调用两个输出方法。

    void solve(); 

    void refine_and_transfer(); 

    void output_results(const unsigned int cycle, const double time) const; 
    void output_particles(const Particles::ParticleHandler<spacedim> &particles, 
                          std::string                                 fprefix, 
                          const unsigned int                          iter, 
                          const double time) const; 

//接下来让我们来看看这个类的成员函数。第一个是处理从参数文件中读取的运行时参数。如前所述，我们通过使其成为一个`const`引用来确保我们不能从这个类中修改这个对象。

    const StokesImmersedProblemParameters<dim, spacedim> &par; 

// 然后还有MPI通信器对象，如果程序是并行运行的，我们将用它来让进程在网络上发送信息，还有`pcout`对象和定时器信息，也被 step-40 采用，例如。

    MPI_Comm mpi_communicator; 

    ConditionalOStream pcout; 

    mutable TimerOutput computing_timer; 

// 接下来是关于  step-60  的主要创新点之一。这里我们假设固体和流体都是完全分布的三角形。这使得问题可以扩展到非常大的自由度，代价是要沟通所有非匹配三角形之间的重叠区域。这一点特别棘手，因为我们没有对两个三角形的各个子域的相对位置或分布做出假设。特别是，我们假设每个进程只拥有 "solid_tria "的一部分，以及 "fluid_tria "的一部分，不一定在同一个物理区域，也不一定重叠。

// 我们原则上可以尝试创建初始分区，使每个过程的子域在固体和流体区域之间重叠。然而，这种重叠在模拟过程中会被破坏，我们将不得不一次又一次地重新分配DoF。我们在本教程中采用的方法更加灵活，而且成本也不高。我们在模拟开始时进行两次全对全的通信，以交换每个处理器的几何占用信息（近似）（通过包围盒的集合完成）。

// 这个信息被 Particles::ParticleHandler 类用来交换（使用某对某的通信模式）所有的粒子，因此每个进程都知道生活在它所拥有的流体子域所占区域的粒子。

// 为了把重叠的区域连接起来，我们利用了ParticleHandler类中实现的设施。

    parallel::distributed::Triangulation<spacedim>      fluid_tria; 
    parallel::distributed::Triangulation<dim, spacedim> solid_tria; 

// 接下来是对所使用的有限元的描述，以及适当的正交公式和相应的DoFHandler对象。在目前的实现中，只有`fluid_fe`是真正必要的。为了完整起见，并便于扩展，我们还保留了`solid_fe`，但它被初始化为一个FE_Nothing有限元空间，即没有自由度的空间。

// 我们将这两个有限元空间声明为 `std::unique_ptr` 对象，而不是普通的成员变量，以便在`StokesImmersedProblemParameters'被初始化后生成它们。特别是，它们将在`initial_setup()`方法中被初始化。

    std::unique_ptr<FiniteElement<spacedim>>      fluid_fe; 
    std::unique_ptr<FiniteElement<dim, spacedim>> solid_fe; 

    std::unique_ptr<Quadrature<spacedim>> fluid_quadrature_formula; 
    std::unique_ptr<Quadrature<dim>>      solid_quadrature_formula; 

    DoFHandler<spacedim>      fluid_dh; 
    DoFHandler<dim, spacedim> solid_dh; 

    std::unique_ptr<MappingFEField<dim, spacedim>> solid_mapping; 

// 与 step-22 中的做法类似，我们使用一个块状系统来处理问题的斯托克斯部分，并非常密切地遵循那里的做法。

    std::vector<IndexSet> fluid_owned_dofs; 
    std::vector<IndexSet> solid_owned_dofs; 

    std::vector<IndexSet> fluid_relevant_dofs; 
    std::vector<IndexSet> solid_relevant_dofs; 

// 利用这种自由度的划分，我们就可以定义所有必要的对象来描述有关的线性系统。

    AffineConstraints<double> constraints; 

    LA::MPI::BlockSparseMatrix system_matrix; 
    LA::MPI::BlockSparseMatrix preconditioner_matrix; 

    LA::MPI::BlockVector solution; 
    LA::MPI::BlockVector locally_relevant_solution; 
    LA::MPI::BlockVector system_rhs; 

// 让我们转到这个程序的粒子方面。有两个 Particles::ParticleHandler 对象用于耦合固体和流体，以及描述被动追踪器。在许多方面，这些对象的作用类似于离散化中使用的DoFHandler类，也就是说，它们提供了粒子的枚举，并允许查询每个粒子的信息。

    Particles::ParticleHandler<spacedim> tracer_particle_handler; 
    Particles::ParticleHandler<spacedim> solid_particle_handler; 

// 对于每个追踪器粒子，我们需要计算其当前位置的速度场，并使用离散时间步进方案更新其位置。我们使用分布式线性代数对象来做这件事，这些对象存储了每个粒子的位置或速度的坐标。也就是说，这些向量有`tracer_particle_handler.n_global_particles() * spacedim`项，我们将以一种方式来存储这些向量的一部分，以便在所有进程中进行划分。(隐含地，我们在此假设每个粒子的`spacedim'坐标被存储在向量的连续条目中)。因此，我们需要确定每个向量条目的所有者是谁。我们将这个所有者设定为等于在时间 $t=0$ 产生该粒子的进程。这个信息对每一个进程都存储在`locally_owned_tracer_particle_coordinates`索引集里。

// 一旦粒子被分配到与拥有粒子所在区域的进程相匹配，我们将需要从该进程读取相应的速度场。我们通过填充一个只读的速度矢量场来实现这一目标，该矢量场包含了Ghost条目中的相关信息。这是通过`locally_relevant_tracer_particle_coordinates`索引集实现的，该索引集记录了模拟过程中的变化情况，也就是说，它记录了当前进程拥有的粒子最终出现在哪里，以及谁拥有最终出现在我的子域的粒子。

// 虽然这不是最有效的策略，但我们保持这种方式是为了说明事情在真实的流固耦合（FSI）问题中是如何运作的。如果一个粒子与一个特定的固体自由度相联系，我们就不能自由选择谁拥有它，我们必须把这个信息传达给周围的人。我们在这里说明了这一点，并表明通信模式是点对点的，就算法的总成本而言可以忽略不计。

// 然后，基于这些细分定义的向量被用来存储粒子的速度（只读，有幽灵条目）和它们的位移（读/写，没有幽灵条目）。

    IndexSet locally_owned_tracer_particle_coordinates; 
    IndexSet locally_relevant_tracer_particle_coordinates; 

    LA::MPI::Vector tracer_particle_velocities; 
    LA::MPI::Vector relevant_tracer_particle_displacements; 

// 本教程程序的关键点之一是两个独立的 parallel::distributed::Triangulation 对象之间的耦合，其中一个对象可能相对于另一个对象移动和变形（可能有较大的变形）。当流体和实体的三角形都是 parallel::distributed::Triangulation, 类型时，每个进程只能访问这两个三角形中每个单元的局部拥有的部分。如上所述，一般情况下，本地拥有的域是不重叠的。

// 为了允许在不重叠的 parallel::distributed::Triangulation 对象之间有效地交换信息，该库的一些算法要求用户提供三角形的本地拥有部分所占区域的粗略描述，其形式是每个进程的轴对齐的边界盒集合，这些边界盒提供了域的本地拥有部分的完整覆盖。这种信息就可以用于这样的情况：人们需要向已知位置周围的单元格的所有者发送信息，而不知道这个所有者实际上是谁。但是，如果我们知道每个进程拥有的几何区域或体积的边界盒集合，那么我们就可以确定可能拥有该位置所在单元的所有进程的一个子集：即其边界盒包含该点的所有进程。与其向所有进程发送与该位置相关的信息，不如只向具有点对点通信基元的一小部分进程发送信息。你会注意到，这也允许典型的时间与内存的权衡：我们愿意存储的关于每个进程拥有的区域的数据越多--以更精细的边界框信息的形式--我们必须执行的通信就越少）。

// 我们通过收集一个向量（长度为 Utilities::MPI::n_mpi_processes()) 的BoundingBox对象的向量）来构建这些信息。我们用extract_rtree_level()函数填充这个向量，并允许用户选择要提取的树的哪一级。这个 "级别 "对应的是与边界框重叠的区域应该有多粗/多细。

// 作为一个例子，这是由extract_rtree_level()函数对一个分布在三个过程中的二维超球所提取的结果。每张图片中，绿色显示的是与每个进程上的三角形的本地所有单元相关的边界框，紫色显示的是从rtree中提取的边界框。

//  @image html rtree-process-0.png  
// @image html rtree-process-1.png  
// @image html rtree-process-2.png  

// 我们将这些盒子存储在一个全局成员变量中，在每个细化步骤中都会更新。

    std::vector<std::vector<BoundingBox<spacedim>>> global_fluid_bounding_boxes; 
  }; 

//  @sect3{The StokesImmersedProblem class implementation}  
// @sect4{Object construction and mesh initialization functions}  

// 在构造函数中，我们创建了mpi_communicator，以及流体和实体的三角计算和dof_handler。通过使用mpi_communicator，我们构建了ConditionalOStream和TimerOutput对象。

  template <int dim, int spacedim> 
  StokesImmersedProblem<dim, spacedim>::StokesImmersedProblem( 
    const StokesImmersedProblemParameters<dim, spacedim> &par) 
    : par(par) 
    , mpi_communicator(MPI_COMM_WORLD) 
    , pcout(std::cout, 
            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
    , computing_timer(mpi_communicator, 
                      pcout, 
                      TimerOutput::summary, 
                      TimerOutput::wall_times) 
    , fluid_tria(mpi_communicator, 
                 typename Triangulation<spacedim>::MeshSmoothing( 
                   Triangulation<spacedim>::smoothing_on_refinement | 
                   Triangulation<spacedim>::smoothing_on_coarsening)) 
    , solid_tria(mpi_communicator, 
                 typename Triangulation<dim, spacedim>::MeshSmoothing( 
                   Triangulation<dim, spacedim>::smoothing_on_refinement | 
                   Triangulation<dim, spacedim>::smoothing_on_coarsening)) 
    , fluid_dh(fluid_tria) 
    , solid_dh(solid_tria) 
  {} 

// 为了生成网格，我们首先尝试使用deal.II GridGenerator命名空间中的函数，通过利用 GridGenerator::generate_from_name_and_argument().  如果这个函数失败，那么我们使用以下方法，名称被解释为文件名，参数被解释为从流形ID到CAD文件的映射，并使用OpenCASCADE命名空间设施转换为流形描述符。在顶部，我们把文件读成一个三角图。

  template <int dim, int spacedim> 
  void read_grid_and_cad_files(const std::string &grid_file_name, 
                               const std::string &ids_and_cad_file_names, 
                               Triangulation<dim, spacedim> &tria) 
  { 
    GridIn<dim, spacedim> grid_in; 
    grid_in.attach_triangulation(tria); 
    grid_in.read(grid_file_name); 

// 如果我们走到这一步，那么三角图已经被读取，我们已经准备好将正确的流形描述附加到它上面。只有在deal.II支持OpenCASCADE的情况下，我们才会执行接下来的几行代码。对于地图中的每个条目，我们尝试打开相应的CAD文件，分析它，并根据其内容，选择一个 OpenCASCADE::ArcLengthProjectionLineManifold （如果CAD文件包含一个`TopoDS_Edge'或一个`TopoDS_Wire'）或一个 OpenCASCADE::NURBSPatchManifold, ，如果文件包含一个面。请注意，如果CAD文件不包含单一的线、边或面，在生成Manifold时将会抛出一个断言。

// 我们使用 Patterns::Tools::Convert 类来完成从字符串到歧管ID和文件名之间的映射的转换。

#ifdef DEAL_II_WITH_OPENCASCADE 
    using map_type  = std::map<types::manifold_id, std::string>; 
    using Converter = Patterns::Tools::Convert<map_type>; 

    for (const auto &pair : Converter::to_value(ids_and_cad_file_names)) 
      { 
        const auto &manifold_id   = pair.first; 
        const auto &cad_file_name = pair.second; 

        const auto extension = boost::algorithm::to_lower_copy( 
          cad_file_name.substr(cad_file_name.find_last_of('.') + 1)); 

        TopoDS_Shape shape; 
        if (extension == "iges" || extension == "igs") 
          shape = OpenCASCADE::read_IGES(cad_file_name); 
        else if (extension == "step" || extension == "stp") 
          shape = OpenCASCADE::read_STEP(cad_file_name); 
        else 
          AssertThrow(false, 
                      ExcNotImplemented("We found an extension that we " 
                                        "do not recognize as a CAD file " 
                                        "extension. Bailing out.")); 

// 现在我们检查一下这个 "形状 "中包含了多少个面。OpenCASCADE本质上是三维的，所以如果这个数字是零，我们就把它解释为线状流形，否则就解释为`spacedim`=3中的 OpenCASCADE::NormalToMeshProjectionManifold ，或者`spacedim`=2中的 OpenCASCADE::NURBSPatchManifold 。

        const auto n_elements = OpenCASCADE::count_elements(shape); 
        if ((std::get<0>(n_elements) == 0)) 
          tria.set_manifold( 
            manifold_id, 
            OpenCASCADE::ArclengthProjectionLineManifold<dim, spacedim>(shape)); 
        else if (spacedim == 3) 
          { 

// 我们使用这个技巧，因为 OpenCASCADE::NormalToMeshProjectionManifold 只在spacedim = 3的情况下实现。上面的检查保证了事情的实际运作是正确的。

            const auto t = reinterpret_cast<Triangulation<dim, 3> *>(&tria); 
            t->set_manifold(manifold_id, 
                            OpenCASCADE::NormalToMeshProjectionManifold<dim, 3>( 
                              shape)); 
          } 
        else 

// 我们也允许基于单个NURBS补丁的二维空间的曲面描述。要做到这一点，CAD文件必须包含一个单一的`TopoDS_Face`。

          tria.set_manifold(manifold_id, 
                            OpenCASCADE::NURBSPatchManifold<dim, spacedim>( 
                              TopoDS::Face(shape))); 
      } 
#else 
    (void)ids_and_cad_file_names; 
    AssertThrow(false, ExcNotImplemented("Generation of the grid failed.")); 
#endif 
  } 

// 现在让我们把东西放在一起，并制作所有必要的网格。如上所述，我们首先尝试在内部生成网格，如果我们失败了（即如果我们最终进入了`catch'子句），那么我们就继续执行上述函数。

// 我们对流体和固体网格都重复这个模式。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::make_grid() 
  { 
    try 
      { 
        GridGenerator::generate_from_name_and_arguments( 
          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid); 
      } 
    catch (...) 
      { 
        pcout << "Generating from name and argument failed." << std::endl 
              << "Trying to read from file name." << std::endl; 
        read_grid_and_cad_files(par.name_of_fluid_grid, 
                                par.arguments_for_fluid_grid, 
                                fluid_tria); 
      } 
    fluid_tria.refine_global(par.initial_fluid_refinement); 

    try 
      { 
        GridGenerator::generate_from_name_and_arguments( 
          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid); 
      } 
    catch (...) 
      { 
        read_grid_and_cad_files(par.name_of_solid_grid, 
                                par.arguments_for_solid_grid, 
                                solid_tria); 
      } 

    solid_tria.refine_global(par.initial_solid_refinement); 
  } 
// @sect4{Particle initialization functions}  

// 一旦固体和流体网格被创建，我们就开始填充 Particles::ParticleHandler 对象。我们要处理的第一个对象是用来跟踪流体中的被动追踪器的对象。这些东西只是沿途传送，从某种意义上说，它们的位置并不重要：我们只是想用它们来观察流体被传送的位置。我们可以使用任何我们选择的方式来确定它们的初始位置。一个方便的方法是将初始位置创建为我们所选择的形状的网格顶点，这个选择由参数文件中的一个运行时参数决定。

// 在这个实现中，我们使用FE_Q有限元空间的支持点来创建追踪器，这些支持点定义在一个临时网格上，然后被丢弃。在这个网格中，我们只保留与支撑点相关的 Particles::Particle 对象（存储在 Particles::ParticleHandler 类中）。

//  Particles::ParticleHandler 类提供了插入一组粒子的可能性，这些粒子实际生活在活动过程所拥有的域的一部分。然而，在这种情况下，这个功能是不够的。作为任意网格（与流体网格不匹配）上的FE_Q对象的本地拥有的支持点所产生的粒子没有理由位于流体网格的本地拥有的子域的同一物理区域内。事实上，这种情况几乎不会发生，尤其是我们想要跟踪粒子本身发生了什么。

// 在粒子入室方法（PIC）中，人们通常习惯于将粒子的所有权分配给粒子所在的过程。在本教程中，我们说明了一种不同的方法，如果想跟踪与粒子有关的信息，这种方法是很有用的（例如，如果一个粒子与一个特定的自由度有关，而这个自由度是由一个特定的过程所拥有的，不一定是在任何特定时间拥有该粒子所在的流体单元的同一个过程）。在这里使用的方法中，粒子的所有权在开始时被分配一次，每当原始所有者需要从拥有粒子所在单元的进程中获得信息时，就会发生一对一的通信。我们确保使用初始粒子分布来设置粒子的所有权，并在程序的整个执行过程中保持相同的所有权。

// 有了这个概述，让我们看看这个函数做什么。在顶部，我们创建了一个临时的三角形和DoFHandler对象，我们将从中获取初始粒子位置的节点位置。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::setup_tracer_particles() 
  { 
    parallel::distributed::Triangulation<spacedim> particle_insert_tria( 
      mpi_communicator); 
    GridGenerator::generate_from_name_and_arguments( 
      particle_insert_tria, 
      par.name_of_particle_grid, 
      par.arguments_for_particle_grid); 
    particle_insert_tria.refine_global(par.particle_insertion_refinement); 

    FE_Q<spacedim>       particles_fe(1); 
    DoFHandler<spacedim> particles_dof_handler(particle_insert_tria); 
    particles_dof_handler.distribute_dofs(particles_fe); 

// 这就是事情开始变得复杂的地方。由于我们可能会在并行环境中运行这个程序，每个并行进程现在都会创建这些临时三角形和DoFHandlers。但是，在完全分布式三角形中，活动进程只知道本地拥有的单元，而不知道其他进程是如何分布自己的单元的。这对于上面创建的临时三角形以及我们想嵌入粒子的流体三角形都是如此。另一方面，一般来说，这两个三角形的局部已知部分不会重合。也就是说，我们将从临时网格的节点位置创建的粒子的位置是任意的，并且可能落在当前进程无法访问的流体三角结构的区域内（即流体领域中细胞是人工的区域）。为了了解将这些粒子发送给谁，我们需要对流体网格在处理器中的分布有一个（粗略的）概念。

// 我们通过以下方式来构建这一信息：首先建立一个以本地拥有的单元为边界的盒子的索引树，然后提取该树的第一层中的一个。

    std::vector<BoundingBox<spacedim>> all_boxes; 
    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells()); 
    for (const auto &cell : fluid_tria.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        all_boxes.emplace_back(cell->bounding_box()); 

    const auto tree = pack_rtree(all_boxes); 
    const auto local_boxes = 
      extract_rtree_level(tree, par.fluid_rtree_extraction_level); 

// 每个进程现在都有一个完全包围所有本地拥有的进程的边界盒集合（但可能与其他进程的边界盒相重叠）。然后我们在所有参与的进程之间交换这些信息，这样每个进程都知道所有其他进程的边界盒。

// 有了这些信息，我们就可以将`tracer_particle_handler`初始化到流体网格，并从（临时）tracer particles triangulation的支持点生成粒子。这个函数调用使用了我们刚刚构建的`global_bounding_boxes`对象，以确定将位置来自`particles_dof_handler`的本地拥有部分的粒子发送到何处。在这个调用结束时，每个粒子将被分配到正确的进程（即拥有粒子所在的流体单元的进程）。在这一点上，我们也将他们的编号输出到屏幕上。

    global_fluid_bounding_boxes = 
      Utilities::MPI::all_gather(mpi_communicator, local_boxes); 

    tracer_particle_handler.initialize(fluid_tria, 
                                       StaticMappingQ1<spacedim>::mapping); 

    Particles::Generators::dof_support_points(particles_dof_handler, 
                                              global_fluid_bounding_boxes, 
                                              tracer_particle_handler); 

    pcout << "Tracer particles: " 
          << tracer_particle_handler.n_global_particles() << std::endl; 

// 这样创建的每个粒子都有一个唯一的ID。在下面的算法中的某个时刻，我们将需要包含每个粒子的位置和速度信息的向量。这个向量的大小为`n_particles * // spacedim`，我们需要为每个粒子提供位置和速度信息。
// spacedim`，我们将不得不以一种方式来存储这个向量的元素，以便每个并行进程 "拥有 "与它拥有的粒子的坐标相对应的那些元素。换句话说，我们必须在所有进程中划分0和`n_particles * spacedim`之间的索引空间。我们可以通过查询`tracer_particle_handler`的本地相关粒子的ID来做到这一点，并构建需要的索引，将所有粒子的位置和速度存储在一个（平行分布的）矢量中，其中我们隐含地假设我们将每个位置或速度的坐标存储在`spacedim`连续的矢量元素中（这就是 IndexSet::tensor_priduct() 函数的作用）。

    locally_owned_tracer_particle_coordinates = 
      tracer_particle_handler.locally_owned_particle_ids().tensor_product( 
        complete_index_set(spacedim)); 

// 在模拟开始时，所有粒子都在它们的原始位置。当粒子移动时，它们可能会穿越到另一个进程所拥有的领域的某个部分。如果发生这种情况，当前进程会正式保持对粒子的 "所有权"，但可能需要从粒子落地的进程中读取访问。我们将这一信息保存在另一个索引集中，该索引集存储了当前进程的子域中的所有粒子的索引，不管它们是否一直在这里。

// 保留这个索引集使我们能够利用线性代数类来进行有关粒子位置和速度的所有通信。这模拟了在固体域中解决另一个问题的情况下会发生的情况（如在流体-结构相互作用中。在后一种情况下，实体域上的额外DOFs将被耦合到流体域中发生的情况。

    locally_relevant_tracer_particle_coordinates = 
      locally_owned_tracer_particle_coordinates; 

// 最后，我们要确保在细化时，粒子被正确转移。在进行局部细化或粗化时，粒子会落在另一个单元中。原则上，我们可以在细化后重新分配所有的粒子，但是这将是非常昂贵的。

//  Particles::ParticleHandler 类有一种方法可以在细化时将信息从一个单元转移到它的子单元或它的父单元，而不需要重构整个数据结构。这是通过向三角结构注册两个回调函数来实现的。这些函数将在细化即将发生和刚刚发生时收到一个信号，并将以最小的计算成本将所有信息转移到新的细化网格中。

    fluid_tria.signals.pre_distributed_refinement.connect( 
      [&]() { tracer_particle_handler.register_store_callback_function(); }); 

    fluid_tria.signals.post_distributed_refinement.connect([&]() { 
      tracer_particle_handler.register_load_callback_function(false); 
    }); 
  } 

// 与我们对被动追踪器所做的类似，我们接下来设置追踪实体网格的正交点的粒子。这里的主要区别是，我们还想给每个粒子附加一个权重值（正交点的 "JxW "值），这样我们就可以在不直接访问原始实体网格的情况下计算积分。

// 这是通过利用 Particles::Particle 类的 "属性 "概念实现的。它可以（以一种有效的内存方式）在一个 Particles::ParticleHandler 对象内为每个 Particles::Particle 对象存储任意数量的`双`数字。我们利用这种可能性来存储实体网格的正交点的JxW值。

// 在我们的例子中，我们只需要为每个粒子存储一个属性：实体网格上的积分的JxW值。这将在构造时作为最后一个参数传递给solid_particle_handler对象。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::setup_solid_particles() 
  { 
    QGauss<dim> quadrature(fluid_fe->degree + 1); 

    const unsigned int n_properties = 1; 
    solid_particle_handler.initialize(fluid_tria, 
                                      StaticMappingQ1<spacedim>::mapping, 
                                      n_properties); 

// 我们在本地生成的粒子数等于本地拥有的单元总数乘以每个单元中使用的正交点的数量。我们将所有这些点存储在一个向量中，并将其相应的属性存储在一个向量的向量中。

    std::vector<Point<spacedim>> quadrature_points_vec; 
    quadrature_points_vec.reserve(quadrature.size() * 
                                  solid_tria.n_locally_owned_active_cells()); 

    std::vector<std::vector<double>> properties; 
    properties.reserve(quadrature.size() * 
                       solid_tria.n_locally_owned_active_cells()); 

    FEValues<dim, spacedim> fe_v(*solid_fe, 
                                 quadrature, 
                                 update_JxW_values | update_quadrature_points); 
    for (const auto &cell : solid_dh.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          fe_v.reinit(cell); 
          const auto &points = fe_v.get_quadrature_points(); 
          const auto &JxW    = fe_v.get_JxW_values(); 

          for (unsigned int q = 0; q < points.size(); ++q) 
            { 
              quadrature_points_vec.emplace_back(points[q]); 
              properties.emplace_back( 
                std::vector<double>(n_properties, JxW[q])); 
            } 
        } 

// 我们以处理示踪粒子的同样方式进行，重新使用计算出的边界盒。然而，我们首先检查`global_fluid_bounding_boxes`对象是否已经被填充。这里当然应该是这样的，因为这个方法是在初始化示踪粒子的方法之后调用的。然而，我们要确保，如果将来有人决定（无论出于什么原因）先初始化固体粒子处理程序，或者只复制教程的这一部分，当事情没有按照预期进行时，会抛出一个有意义的异常。

// 由于我们已经存储了正交点的位置，我们可以使用这些位置来直接使用`solid_particle_handler`插入粒子，而不必通过 Particles::Generators 函数。

    Assert(!global_fluid_bounding_boxes.empty(), 
           ExcInternalError( 
             "I was expecting the " 
             "global_fluid_bounding_boxes to be filled at this stage. " 
             "Make sure you fill this vector before trying to use it " 
             "here. Bailing out.")); 

    solid_particle_handler.insert_global_particles(quadrature_points_vec, 
                                                   global_fluid_bounding_boxes, 
                                                   properties); 

// 和前面的函数一样，我们最后要确保在细化时，粒子被正确转移。

    fluid_tria.signals.pre_distributed_refinement.connect( 
      [&]() { solid_particle_handler.register_store_callback_function(); }); 

    fluid_tria.signals.post_distributed_refinement.connect( 
      [&]() { solid_particle_handler.register_load_callback_function(false); }); 

    pcout << "Solid particles: " << solid_particle_handler.n_global_particles() 
          << std::endl; 
  } 

//  @sect4{DoF initialization functions}  

// 我们设置了有限元空间和整个步骤中使用的正交公式。对于流体，我们使用Taylor-Hood元素（例如 $Q_k \times Q_{k-1}$  ）。由于我们没有解决固体领域的任何方程，所以产生了一个空的有限元空间。这个程序的一个自然扩展是解决流体结构的相互作用问题，这就要求`solid_fe`使用更有用的FiniteElement类。

// 和其他许多函数一样，我们在这里存储了进行操作所需的时间。当前的函数把它的时间信息放到一个标签为 "初始设置 "的部分。在不同的函数中对这个定时器进行了许多其他的调用。它们允许监测每个单独函数的绝对和相对成本，以确定瓶颈。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::initial_setup() 
  { 
    TimerOutput::Scope t(computing_timer, "Initial setup"); 

    fluid_fe = 
      std::make_unique<FESystem<spacedim>>(FE_Q<spacedim>(par.velocity_degree), 
                                           spacedim, 
                                           FE_Q<spacedim>(par.velocity_degree - 
                                                          1), 
                                           1); 

    solid_fe = std::make_unique<FE_Nothing<dim, spacedim>>(); 
    solid_dh.distribute_dofs(*solid_fe); 

    fluid_quadrature_formula = 
      std::make_unique<QGauss<spacedim>>(par.velocity_degree + 1); 
    solid_quadrature_formula = 
      std::make_unique<QGauss<dim>>(par.velocity_degree + 1); 
  } 

// 接下来我们构建分布式块状矩阵和向量，用于解决问题中出现的线性方程。这个函数改编自 step-55 ，我们参考这个步骤进行全面解释。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::setup_dofs() 
  { 
    TimerOutput::Scope t(computing_timer, "Setup dofs"); 

    fluid_dh.distribute_dofs(*fluid_fe); 

    std::vector<unsigned int> stokes_sub_blocks(spacedim + 1, 0); 
    stokes_sub_blocks[spacedim] = 1; 
    DoFRenumbering::component_wise(fluid_dh, stokes_sub_blocks); 

    auto dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(fluid_dh, stokes_sub_blocks); 

    const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1]; 

    pcout << "   Number of degrees of freedom: " << fluid_dh.n_dofs() << " (" 
          << n_u << '+' << n_p << " -- " 
          << solid_particle_handler.n_global_particles() << '+' 
          << tracer_particle_handler.n_global_particles() << ')' << std::endl; 

    fluid_owned_dofs.resize(2); 
    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u); 
    fluid_owned_dofs[1] = 
      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p); 

    IndexSet locally_relevant_dofs; 
    DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs); 
    fluid_relevant_dofs.resize(2); 
    fluid_relevant_dofs[0] = locally_relevant_dofs.get_view(0, n_u); 
    fluid_relevant_dofs[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p); 

    { 
      constraints.reinit(locally_relevant_dofs); 

      FEValuesExtractors::Vector velocities(0); 
      DoFTools::make_hanging_node_constraints(fluid_dh, constraints); 
      VectorTools::interpolate_boundary_values( 
        fluid_dh, 
        0, 
        Functions::ZeroFunction<spacedim>(spacedim + 1), 
        constraints, 
        fluid_fe->component_mask(velocities)); 
      constraints.close(); 
    } 

    auto locally_owned_dofs_per_processor = 
      Utilities::MPI::all_gather(mpi_communicator, 
                                 fluid_dh.locally_owned_dofs()); 
    { 
      system_matrix.clear(); 

      Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1); 
      for (unsigned int c = 0; c < spacedim + 1; ++c) 
        for (unsigned int d = 0; d < spacedim + 1; ++d) 
          if (c == spacedim && d == spacedim) 
            coupling[c][d] = DoFTools::none; 
          else if (c == spacedim || d == spacedim || c == d) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block); 

      DoFTools::make_sparsity_pattern( 
        fluid_dh, coupling, dsp, constraints, false); 

      SparsityTools::distribute_sparsity_pattern( 
        dsp, 
        locally_owned_dofs_per_processor, 
        mpi_communicator, 
        locally_relevant_dofs); 

      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator); 
    } 

    { 
      preconditioner_matrix.clear(); 

      Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1); 
      for (unsigned int c = 0; c < spacedim + 1; ++c) 
        for (unsigned int d = 0; d < spacedim + 1; ++d) 
          if (c == spacedim && d == spacedim) 
            coupling[c][d] = DoFTools::always; 
          else 
            coupling[c][d] = DoFTools::none; 

      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block); 

      DoFTools::make_sparsity_pattern( 
        fluid_dh, coupling, dsp, constraints, false); 
      SparsityTools::distribute_sparsity_pattern( 
        dsp, 
        locally_owned_dofs_per_processor, 
        mpi_communicator, 
        locally_relevant_dofs); 
      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator); 
    } 

    locally_relevant_solution.reinit(fluid_owned_dofs, 
                                     fluid_relevant_dofs, 
                                     mpi_communicator); 
    system_rhs.reinit(fluid_owned_dofs, mpi_communicator); 
    solution.reinit(fluid_owned_dofs, mpi_communicator); 
  } 
// @sect4{Assembly functions}  

// 我们将系统矩阵、预处理矩阵和右手边组合起来。这段代码改编自 step-55 ，基本上是 step-27 的内容，如果你知道斯托克斯方程是什么样子的，就会觉得很标准。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::assemble_stokes_system() 
  { 
    system_matrix         = 0; 
    preconditioner_matrix = 0; 
    system_rhs            = 0; 

    TimerOutput::Scope t(computing_timer, "Assemble Stokes terms"); 

    FEValues<spacedim> fe_values(*fluid_fe, 
                                 *fluid_quadrature_formula, 
                                 update_values | update_gradients | 
                                   update_quadrature_points | 
                                   update_JxW_values); 

    const unsigned int dofs_per_cell = fluid_fe->n_dofs_per_cell(); 
    const unsigned int n_q_points    = fluid_quadrature_formula->size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<Vector<double>> rhs_values(n_q_points, 
                                           Vector<double>(spacedim + 1)); 

    std::vector<Tensor<2, spacedim>> grad_phi_u(dofs_per_cell); 
    std::vector<double>              div_phi_u(dofs_per_cell); 
    std::vector<double>              phi_p(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    const FEValuesExtractors::Vector     velocities(0); 
    const FEValuesExtractors::Scalar     pressure(spacedim); 

    for (const auto &cell : fluid_dh.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        { 
          cell_matrix  = 0; 
          cell_matrix2 = 0; 
          cell_rhs     = 0; 

          fe_values.reinit(cell); 
          par.rhs.vector_value_list(fe_values.get_quadrature_points(), 
                                    rhs_values); 
          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 
              for (unsigned int k = 0; k < dofs_per_cell; ++k) 
                { 
                  grad_phi_u[k] = fe_values[velocities].gradient(k, q); 
                  div_phi_u[k]  = fe_values[velocities].divergence(k, q); 
                  phi_p[k]      = fe_values[pressure].value(k, q); 
                } 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    { 
                      cell_matrix(i, j) += 
                        (par.viscosity * 
                           scalar_product(grad_phi_u[i], grad_phi_u[j]) - 
                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) * 
                        fe_values.JxW(q); 

                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] * 
                                            phi_p[j] * fe_values.JxW(q); 
                    } 

                  const unsigned int component_i = 
                    fluid_fe->system_to_component_index(i).first; 
                  cell_rhs(i) += fe_values.shape_value(i, q) * 
                                 rhs_values[q](component_i) * fe_values.JxW(q); 
                } 
            } 

          cell->get_dof_indices(local_dof_indices); 
          constraints.distribute_local_to_global(cell_matrix, 
                                                 cell_rhs, 
                                                 local_dof_indices, 
                                                 system_matrix, 
 

          constraints.distribute_local_to_global(cell_matrix2, 
                                                 local_dof_indices, 
                                                 preconditioner_matrix); 
        } 

    system_matrix.compress(VectorOperation::add); 
    preconditioner_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 
  } 

// 下面的方法是处理因对叶轮施加速度而产生的惩罚项。从某种意义上说，它是本教程的核心，但它相对简单。这里我们利用`solid_particle_handler`来计算Nitsche限制或嵌入域中的惩罚。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::assemble_nitsche_restriction() 
  { 
    TimerOutput::Scope t(computing_timer, "Assemble Nitsche terms"); 

    const FEValuesExtractors::Vector velocities(0); 
    const FEValuesExtractors::Scalar pressure(spacedim); 

    SolidVelocity<spacedim> solid_velocity(par.angular_velocity); 

    std::vector<types::global_dof_index> fluid_dof_indices( 
      fluid_fe->n_dofs_per_cell()); 

    FullMatrix<double>     local_matrix(fluid_fe->n_dofs_per_cell(), 
                                    fluid_fe->n_dofs_per_cell()); 
    dealii::Vector<double> local_rhs(fluid_fe->n_dofs_per_cell()); 

    const auto penalty_parameter = 
      1.0 / GridTools::minimal_cell_diameter(fluid_tria); 

// 我们在所有的本地粒子上循环。虽然这可以直接通过循环所有的单元格来实现，但这将迫使我们循环许多不包含粒子的单元格。因此，我们在所有的粒子上循环，但是，我们得到粒子所在的单元格的参考，然后在该单元格中循环所有的粒子。这使得我们能够跳过不包含粒子的单元格，但又能集合每个单元格的局部矩阵和rhs来应用Nitsche的限制。一旦我们完成了一个单元格上的所有粒子，我们就将`粒子`迭代器推进到当前单元格上的粒子的末端（这是`while`循环体的最后一行）。

    auto particle = solid_particle_handler.begin(); 
    while (particle != solid_particle_handler.end()) 
      { 
        local_matrix = 0; 
        local_rhs    = 0; 

// 我们从粒子本身得到一个通往粒子所在单元的迭代器。然后，我们就可以像通常那样在系统矩阵和右手边组装附加项了。

        const auto &cell = particle->get_surrounding_cell(fluid_tria); 
        const auto &dh_cell = 
          typename DoFHandler<spacedim>::cell_iterator(*cell, &fluid_dh); 
        dh_cell->get_dof_indices(fluid_dof_indices); 
//所以
//然后让我们得到位于这个单元格上的单元格集合，并对它们进行迭代。从每个粒子中，我们收集该粒子的位置和参考位置，以及附加在该粒子上的额外信息。在本例中，这些信息是用于生成粒子的正交点的 "JxW"。

// 利用这些信息，我们可以将正交点的贡献加入到local_matrix和local_rhs中。我们可以利用每个粒子的参考位置，轻松地评估其位置上的形状函数值。

        const auto pic = solid_particle_handler.particles_in_cell(cell); 
        Assert(pic.begin() == particle, ExcInternalError()); 
        for (const auto &p : pic) 
          { 
            const auto &ref_q  = p.get_reference_location(); 
            const auto &real_q = p.get_location(); 
            const auto &JxW    = p.get_properties()[0]; 

            for (unsigned int i = 0; i < fluid_fe->n_dofs_per_cell(); ++i) 
              { 
                const auto comp_i = 
                  fluid_fe->system_to_component_index(i).first; 
                if (comp_i < spacedim) 
                  { 
                    for (unsigned int j = 0; j < fluid_fe->n_dofs_per_cell(); 
                         ++j) 
                      { 
                        const auto comp_j = 
                          fluid_fe->system_to_component_index(j).first; 
                        if (comp_i == comp_j) 
                          local_matrix(i, j) += 
                            penalty_parameter * par.penalty_term * 
                            fluid_fe->shape_value(i, ref_q) * 
                            fluid_fe->shape_value(j, ref_q) * JxW; 
                      } 
                    local_rhs(i) += penalty_parameter * par.penalty_term * 
                                    solid_velocity.value(real_q, comp_i) * 
                                    fluid_fe->shape_value(i, ref_q) * JxW; 
                  } 
              } 
          } 

        constraints.distribute_local_to_global(local_matrix, 
                                               local_rhs, 
                                               fluid_dof_indices, 
                                               system_matrix, 
                                               system_rhs); 
        particle = pic.end(); 
      } 

    system_matrix.compress(VectorOperation::add); 
    system_rhs.compress(VectorOperation::add); 
  } 
// @sect4{Solving the linear system}  

// 这个函数用FGMRES求解线性系统，有一个对角线块的预处理和一个对角线块的代数多重网格（AMG）方法。该预处理程序对 $(0,0)$ （即速度-速度）块应用V循环，对 $(1,1)$ 块应用质量矩阵的CG（这是我们对舒尔补码的近似值：上面组装的压力质量矩阵）。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::solve() 
  { 
    TimerOutput::Scope t(computing_timer, "Solve"); 

    LA::MPI::PreconditionAMG prec_A; 
    { 
      LA::MPI::PreconditionAMG::AdditionalData data; 

#ifdef USE_PETSC_LA 
      data.symmetric_operator = true; 
#endif 
      prec_A.initialize(system_matrix.block(0, 0), data); 
    } 

    LA::MPI::PreconditionAMG prec_S; 
    { 
      LA::MPI::PreconditionAMG::AdditionalData data; 

#ifdef USE_PETSC_LA 
      data.symmetric_operator = true; 
#endif 
      prec_S.initialize(preconditioner_matrix.block(1, 1), data); 
    } 

    const auto A = linear_operator<LA::MPI::Vector>(system_matrix.block(0, 0)); 
    const auto amgA = linear_operator(A, prec_A); 

    const auto S = 
      linear_operator<LA::MPI::Vector>(preconditioner_matrix.block(1, 1)); 
    const auto amgS = linear_operator(S, prec_S); 

    ReductionControl          inner_solver_control(100, 
                                          1e-8 * system_rhs.l2_norm(), 
                                          1.e-2); 
    SolverCG<LA::MPI::Vector> cg(inner_solver_control); 

    const auto invS = inverse_operator(S, cg, amgS); 

    const auto P = block_diagonal_operator<2, LA::MPI::BlockVector>( 
      std::array< 
        dealii::LinearOperator<typename LA::MPI::BlockVector::BlockType>, 
        2>{{amgA, amgS}}); 

    SolverControl solver_control(system_matrix.m(), 
                                 1e-10 * system_rhs.l2_norm()); 

    SolverFGMRES<LA::MPI::BlockVector> solver(solver_control); 

    constraints.set_zero(solution); 

 

    pcout << "   Solved in " << solver_control.last_step() << " iterations." 
          << std::endl; 

    constraints.distribute(solution); 

    locally_relevant_solution = solution; 
    const double mean_pressure = 
      VectorTools::compute_mean_value(fluid_dh, 
                                      QGauss<spacedim>(par.velocity_degree + 2), 
                                      locally_relevant_solution, 
                                      spacedim); 
    solution.block(1).add(-mean_pressure); 
    locally_relevant_solution.block(1) = solution.block(1); 
  } 

//  @sect4{Mesh refinement}  

// 我们以一种完全标准的方式处理网格细化问题。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::refine_and_transfer() 
  { 
    TimerOutput::Scope               t(computing_timer, "Refine"); 
    const FEValuesExtractors::Vector velocity(0); 

    Vector<float> error_per_cell(fluid_tria.n_active_cells()); 
    KellyErrorEstimator<spacedim>::estimate(fluid_dh, 
                                            QGauss<spacedim - 1>( 
                                              par.velocity_degree + 1), 
                                            {}, 
                                            locally_relevant_solution, 
                                            error_per_cell, 
                                            fluid_fe->component_mask(velocity)); 

    if (par.refinement_strategy == "fixed_fraction") 
      { 
        parallel::distributed::GridRefinement:: 
          refine_and_coarsen_fixed_fraction(fluid_tria, 
                                            error_per_cell, 
                                            par.refinement_fraction, 
                                            par.coarsening_fraction); 
      } 
    else if (par.refinement_strategy == "fixed_number") 
      { 
        parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number( 
          fluid_tria, 
          error_per_cell, 
          par.refinement_fraction, 
          par.coarsening_fraction, 
          par.max_cells); 
      } 

    for (const auto &cell : fluid_tria.active_cell_iterators()) 
      { 
        if (cell->refine_flag_set() && 
            cell->level() == par.max_level_refinement) 
          cell->clear_refine_flag(); 
        if (cell->coarsen_flag_set() && 
            cell->level() == par.min_level_refinement) 
          cell->clear_coarsen_flag(); 
      } 

    parallel::distributed::SolutionTransfer<spacedim, LA::MPI::BlockVector> 
      transfer(fluid_dh); 
    fluid_tria.prepare_coarsening_and_refinement(); 
    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution); 
    fluid_tria.execute_coarsening_and_refinement(); 

    setup_dofs(); 

    transfer.interpolate(solution); 
    constraints.distribute(solution); 
    locally_relevant_solution = solution; 
  } 
// @sect4{Creating output for visualization}  

// 我们使用deal.II的标准并行功能在流体域上输出结果（速度和压力）。编写一个压缩的vtu文件，将所有处理器的信息聚集在一起。另外写一个`.pvd`记录，将物理时间与vtu文件联系起来。

  template <int dim, int spacedim> 
  void 
  StokesImmersedProblem<dim, spacedim>::output_results(const unsigned int cycle, 
                                                       double time) const 
  { 
    TimerOutput::Scope t(computing_timer, "Output fluid"); 

    std::vector<std::string> solution_names(spacedim, "velocity"); 
    solution_names.emplace_back("pressure"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        spacedim, DataComponentInterpretation::component_is_part_of_vector); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<spacedim> data_out; 
    data_out.attach_dof_handler(fluid_dh); 
    data_out.add_data_vector(locally_relevant_solution, 
                             solution_names, 
                             DataOut<spacedim>::type_dof_data, 
                             data_component_interpretation); 

    Vector<float> subdomain(fluid_tria.n_active_cells()); 
    for (unsigned int i = 0; i < subdomain.size(); ++i) 
      subdomain(i) = fluid_tria.locally_owned_subdomain(); 
    data_out.add_data_vector(subdomain, "subdomain"); 

    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(cycle) + ".vtu"; 
    data_out.write_vtu_in_parallel(par.output_directory + "/" + filename, 
                                   mpi_communicator); 

    static std::vector<std::pair<double, std::string>> times_and_names; 
    times_and_names.push_back(std::make_pair(time, filename)); 
    std::ofstream ofile(par.output_directory + "/" + "solution.pvd"); 
    DataOutBase::write_pvd_record(ofile, times_and_names); 
  } 

// 同样地，我们通过 Particles::DataOut 对象将粒子（无论是来自实体还是追踪器）写成一个单一的压缩vtu文件。这个简单的对象并不写作为 "属性 "附加到粒子上的额外信息，而只写它们的id--但是，无论如何，我们并不关心这些粒子位置的 "JxW "值，所以我们可能想要可视化的信息并没有丢失。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::output_particles( 
    const Particles::ParticleHandler<spacedim> &particles, 
    std::string                                 fprefix, 
    const unsigned int                          iter, 
    const double                                time) const 
  { 
    Particles::DataOut<spacedim> particles_out; 
    particles_out.build_patches(particles); 
    const std::string filename = 
      (fprefix + "-" + Utilities::int_to_string(iter) + ".vtu"); 
    particles_out.write_vtu_in_parallel(par.output_directory + "/" + filename, 
                                        mpi_communicator); 

    static std::map<std::string, std::vector<std::pair<double, std::string>>> 
      times_and_names; 
    if (times_and_names.find(fprefix) != times_and_names.end()) 
      times_and_names[fprefix].push_back(std::make_pair(time, filename)); 
    else 
      times_and_names[fprefix] = {std::make_pair(time, filename)}; 
    std::ofstream ofile(par.output_directory + "/" + fprefix + ".pvd"); 
    DataOutBase::write_pvd_record(ofile, times_and_names[fprefix]); 
  } 
// @sect4{The "run" function}  

// 这个函数现在负责协调整个模拟过程。它与其他时间相关的教程程序非常相似--以 step-21 或 step-26 为例。在开始的时候，我们会输出一些状态信息，同时将所有的当前参数保存到输出目录下的文件中，以利于重现。

  template <int dim, int spacedim> 
  void StokesImmersedProblem<dim, spacedim>::run() 
  { 
#ifdef USE_PETSC_LA 
    pcout << "Running StokesImmersedProblem<" 
          << Utilities::dim_string(dim, spacedim) << "> using PETSc." 
          << std::endl; 
#else 
    pcout << "Running StokesImmersedProblem<" 
          << Utilities::dim_string(dim, spacedim) << "> using Trilinos." 
          << std::endl; 
#endif 
    par.prm.print_parameters(par.output_directory + "/" + "used_parameters_" + 
                               std::to_string(dim) + std::to_string(spacedim) + 
                               ".prm", 
                             ParameterHandler::Short); 

// 然后我们开始时间循环。我们在第一个循环中初始化模拟的所有元素

    const double time_step    = par.final_time / (par.number_of_time_steps - 1); 
    double       time         = 0; 
    unsigned int output_cycle = 0; 

    for (unsigned int cycle = 0; cycle < par.number_of_time_steps; 
         ++cycle, time += time_step) 
      { 
        par.set_time(time); 
        pcout << "Cycle " << cycle << ':' << std::endl 
              << "Time : " << time << ", time step: " << time_step << std::endl; 

        if (cycle == 0) 
          { 
            make_grid(); 
            initial_setup(); 
            setup_dofs(); 
            setup_tracer_particles(); 
            setup_solid_particles(); 
            tracer_particle_velocities.reinit( 
              locally_owned_tracer_particle_coordinates, mpi_communicator); 
            output_results(output_cycle, time); 
            { 
              TimerOutput::Scope t(computing_timer, "Output tracer particles"); 
              output_particles(tracer_particle_handler, 
                               "tracer", 
                               output_cycle, 
                               time); 
            } 
            { 
              TimerOutput::Scope t(computing_timer, "Output solid particles"); 
              output_particles(solid_particle_handler, 
                               "solid", 
                               output_cycle, 
                               time); 
            } 
          } 

// 在第一个时间步长之后，我们在每个时间步长的开始时对实体进行位移，以考虑到它已经移动的事实。

        else 
          { 
            TimerOutput::Scope t(computing_timer, 
                                 "Set solid particle position"); 

            SolidPosition<spacedim> solid_position(par.angular_velocity, 
                                                   time_step); 
            solid_particle_handler.set_particle_positions(solid_position, 
                                                          false); 
          } 

// 为了更新系统的状态，我们首先对示踪粒子位置的流体速度进行插值，并采用天真的显式欧拉方案对无质量示踪粒子进行漂移。

        { 
          TimerOutput::Scope t(computing_timer, "Set tracer particle motion"); 
          Particles::Utilities::interpolate_field_on_particles( 
            fluid_dh, 
            tracer_particle_handler, 
            locally_relevant_solution, 
            tracer_particle_velocities, 
            fluid_fe->component_mask(FEValuesExtractors::Vector(0))); 

          tracer_particle_velocities *= time_step; 

          locally_relevant_tracer_particle_coordinates = 
            tracer_particle_handler.locally_owned_particle_ids().tensor_product( 
              complete_index_set(spacedim)); 

          relevant_tracer_particle_displacements.reinit( 
            locally_owned_tracer_particle_coordinates, 
            locally_relevant_tracer_particle_coordinates, 
            mpi_communicator); 

          relevant_tracer_particle_displacements = tracer_particle_velocities; 

          tracer_particle_handler.set_particle_positions( 
            relevant_tracer_particle_displacements); 
        } 

// 利用这些新的位置，我们就可以组装斯托克斯系统，并解决它。

        assemble_stokes_system(); 
        assemble_nitsche_restriction(); 
        solve(); 

// 在适当的频率下，我们再将固体粒子、示踪粒子和流体领域的信息写入文件，以便进行可视化，并通过适应网格来结束时间步骤。

        if (cycle % par.output_frequency == 0) 
          { 
            output_results(output_cycle, time); 
            { 
              TimerOutput::Scope t(computing_timer, "Output tracer particles"); 
              output_particles(tracer_particle_handler, 
                               "tracer", 
                               output_cycle, 
                               time); 
            } 
            { 
              TimerOutput::Scope t(computing_timer, "Output solid particles"); 
              output_particles(solid_particle_handler, 
                               "solid", 
                               output_cycle, 
                               time); 
            } 
            ++output_cycle; 
          } 
        if (cycle % par.refinement_frequency == 0 && 
            cycle != par.number_of_time_steps - 1) 
          refine_and_transfer(); 
      } 
  } 

} // namespace Step70 
// @sect3{The main() function}  

// 代码的其余部分，即`main()`函数，是标准的，除了对输入参数文件的处理。我们允许用户指定一个可选的参数文件作为程序的参数。如果没有指定，我们就使用默认文件 "parameters.prm"，如果不存在，我们就创建这个文件。文件名首先被扫描为字符串 "23"，然后是 "3"。如果文件名包含字符串 "23"，问题类将分别以模板参数2和3进行实例化。如果只找到 "3 "这个字符串，那么两个模板参数都被设置为3，否则都被设置为2。

// 如果程序被调用时没有任何命令行参数（即`argc==1`），那么我们就默认使用 "参数.prm"。

int main(int argc, char *argv[]) 
{ 
  using namespace Step70; 
  using namespace dealii; 
  deallog.depth_console(1); 
  try 
    { 
      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      std::string prm_file; 
      if (argc > 1) 
        prm_file = argv[1]; 
      else 
        prm_file = "parameters.prm"; 

      if (prm_file.find("23") != std::string::npos) 
        { 
          StokesImmersedProblemParameters<2, 3> par; 
          ParameterAcceptor::initialize(prm_file); 

          StokesImmersedProblem<2, 3> problem(par); 
          problem.run(); 
        } 
      else if (prm_file.find("3") != std::string::npos) 
        { 
          StokesImmersedProblemParameters<3> par; 
          ParameterAcceptor::initialize(prm_file); 

          StokesImmersedProblem<3> problem(par); 
          problem.run(); 
        } 
      else 
        { 
          StokesImmersedProblemParameters<2> par; 
          ParameterAcceptor::initialize(prm_file); 

          StokesImmersedProblem<2> problem(par); 
          problem.run(); 
        } 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 


CCTest_file/step-71.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Jean-Paul Pelteret, 2021 
 */ 



// 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。这第一个头文件将使我们能够访问一个数据结构，使我们能够在其中存储任意的数据。

#include <deal.II/algorithms/general_data_storage.h> 

// 接下来是一些核心类，包括一个提供时间步进的实现。

#include <deal.II/base/discrete_time.h> 
#include <deal.II/base/numbers.h> 
#include <deal.II/base/parameter_acceptor.h> 
#include <deal.II/base/symmetric_tensor.h> 
#include <deal.II/base/tensor.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/utilities.h> 

// 然后是一些标题，定义了一些有用的坐标变换和运动学关系，这些关系在非线性弹性中经常出现。

#include <deal.II/physics/transformations.h> 
#include <deal.II/physics/elasticity/kinematics.h> 
#include <deal.II/physics/elasticity/standard_tensors.h> 

// 下面两个标头提供了我们进行自动微分所需的所有功能，并使用deal.II可以利用的符号计算机代数系统。所有自动微分和符号微分封装类的头文件，以及任何需要的辅助数据结构，都被收集在这些统一的头文件中。

#include <deal.II/differentiation/ad.h> 
#include <deal.II/differentiation/sd.h> 

// 包括这个头文件使我们有能力将输出写入文件流中。

#include <fstream> 

// 按照惯例，整个教程程序被定义在它自己独特的命名空间中。

namespace Step71 
{ 
  using namespace dealii; 
// @sect3{An introductory example: The fundamentals of automatic and symbolic differentiation}  

// 自动和象征性的区分有一些神奇和神秘的特质。尽管在一个项目中使用它们会因多种原因而受益，但了解如何使用这些框架或如何利用它们的障碍可能会超过试图将它们（可靠地）整合到工作中的开发者的耐心。

// 尽管作者希望能够成功地说明这些工具是如何被整合到有限元建模的工作流程中的，但最好还是先退一步，从基础开始。因此，一开始，我们先看看如何使用这两个框架来区分一个 "简单 "的数学函数，这样就可以牢固地建立和理解基本的操作（包括它们的顺序和功能），并使其复杂程度降到最低。在本教程的第二部分，我们将把这些基本原理付诸实践，并在此基础上进一步发展。

// 伴随着对使用框架的算法步骤的描述，我们将对它们*可能在后台做的事情有一个简化的看法。这种描述在很大程度上是为了帮助理解，我们鼓励读者查看 @ref auto_symb_diff 模块文档，以获得对这些工具实际工作的更正式描述。

//  @sect4{An analytical function}  
  namespace SimpleExample 
  { 

// 为了让读者相信这些工具在实践中确实有用，让我们选择一个函数，用手计算分析导数并不难。只是它的复杂程度足以让你考虑是否真的要去做这个练习，也可能让你怀疑你是否完全确定你对其导数的计算和实现是正确的。当然，问题的关键在于，函数的微分在某种意义上是相对公式化的，应该是计算机擅长的事情--如果我们能在现有的软件基础上理解这些规则，我们就不必费力地自己做了。

// 我们为此选择了双变量三角函数 $f(x,y) = \cos\left(\frac{y}{x}\right)$ 。注意，这个函数是以数字类型为模板的。这样做是因为我们经常（但不总是）可以使用特殊的自动微分和符号类型来替代实数或复数类型，然后这些类型将执行一些基本的计算，例如评估一个函数值及其导数。我们将利用这一特性，确保我们只需要定义一次我们的函数，然后就可以在我们希望对其进行微分操作的任何情况下重新使用。

    template <typename NumberType> 
    NumberType f(const NumberType &x, const NumberType &y) 
    { 
      return std::cos(y / x); 
    } 

// 我们没有立即揭示这个函数的导数，而是向前声明返回导数的函数，并将它们的定义推迟到以后。正如函数名称所暗示的，它们分别返回导数  $\frac{df(x,y)}{dx}$  。

    double df_dx(const double x, const double y); 
// $\frac{df(x,y)}{dy}$  :

    double df_dy(const double x, const double y); 
// $\frac{d^{2}f(x,y)}{dx^{2}}$  :

    double d2f_dx_dx(const double x, const double y); 
// $\frac{d^{2}f(x,y)}{dx dy}$  :

    double d2f_dx_dy(const double x, const double y); 
// $\frac{d^{2}f(x,y)}{dy dx}$  :

    double d2f_dy_dx(const double x, const double y); 

// 最后是  $\frac{d^{2}f(x,y)}{dy^{2}}$  。

    double d2f_dy_dy(const double x, const double y); 
// @sect4{Computing derivatives using automatic differentiation}  

// 首先，我们将使用AD作为工具，为我们自动计算导数。我们将用参数`x`和`y`来评估函数，并期望得到的值和所有的导数都能在给定的公差范围内匹配。

    void 
    run_and_verify_ad(const double x, const double y, const double tol = 1e-12) 
    { 

// 我们的函数 $f(x,y)$ 是一个标量值函数，其参数代表代数计算或张量计算中遇到的典型输入变量。由于这个原因， Differentiation::AD::ScalarFunction 类是合适的包装类，可以用来做我们需要的计算。(作为比较，如果函数参数代表有限元单元的自由度，我们会希望以不同的方式处理它们)。问题的空间维度是不相关的，因为我们没有矢量或张量值的参数需要容纳，所以`dim`模板参数被任意分配为1的值。 第二个模板参数规定了将使用哪个AD框架（deal.II支持几个外部AD框架），以及这个框架提供的基础数字类型将被使用。这个数字类型影响了微分运算的最大顺序，以及用于计算它们的基础算法。鉴于其模板性质，这个选择是一个编译时的决定，因为许多（但不是全部）AD库利用编译时的元编程，以有效的方式实现这些特殊的数字类型。第三个模板参数说明了结果类型是什么；在我们的例子中，我们要处理的是 "双数"。

      constexpr unsigned int                     dim = 1; 
      constexpr Differentiation::AD::NumberTypes ADTypeCode = 
        Differentiation::AD::NumberTypes::sacado_dfad_dfad; 
      using ADHelper = 
        Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>; 

// 我们有必要在我们的 @p ADHelper 类中预先登记函数 $f(x,y)$ 有多少个参数（我们将称之为 "独立变量"）。这些参数是`x`和`y`，所以显然有两个。

      constexpr unsigned int n_independent_variables = 2; 

// 我们现在有足够的信息来创建和初始化一个辅助类的实例。我们还可以得到具体的数字类型，它将在所有后续计算中使用。这很有用，因为我们可以从这里开始通过引用这个类型来编写一切，如果我们想改变使用的框架或数字类型（例如，如果我们需要更多的微分运算），那么我们只需要调整`ADTypeCode`模板参数。

      ADHelper ad_helper(n_independent_variables); 
      using ADNumberType = typename ADHelper::ad_type; 

// 下一步是在辅助类中注册自变量的数值。这样做是因为函数和它的导数将正好针对这些参数进行评估。由于我们按照`{x,y}`的顺序注册它们，变量`x`将被分配到分量号`0`，而`y`将是分量号`1`--这个细节将在接下来的几行中使用。

      ad_helper.register_independent_variables({x, y}); 

// 我们现在要求辅助类向我们提供自变量及其自动区分的表示。这些被称为 "敏感变量"，因为从现在开始，我们对组件`独立变量_ad`所做的任何操作都会被AD框架跟踪和记录，并且在我们要求计算它们的导数时，会被考虑。帮助器返回的是一个可自动微分的 "向量"，但是我们可以确定，第2个元素代表 "x"，第1个元素代表 "y"。为了完全确保这些变量的数字类型没有任何歧义，我们给所有的自动微分变量加上`ad'的后缀。

      const std::vector<ADNumberType> independent_variables_ad = 
        ad_helper.get_sensitive_variables(); 
      const ADNumberType &x_ad = independent_variables_ad[0]; 
      const ADNumberType &y_ad = independent_variables_ad[1]; 

// 我们可以立即将自变量的敏感表示法传递给我们的模板函数，计算出  $f(x,y)$  。这也会返回一个可自动微分的数字。

      const ADNumberType f_ad = f(x_ad, y_ad); 

// 所以现在要问的自然是，我们把这些特殊的`x_ad`和`y_ad`变量传递给函数`f`，而不是原来的`double`变量`x`和`y`，实际上计算了什么？换句话说，这一切与我们想要确定的导数的计算有什么关系？或者，更简洁地说。这个返回的`ADNumberType`对象有什么特别之处，使它有能力神奇地返回导数？

// 从本质上讲，这*可以*做的是以下几点。这个特殊的数字可以被看作是一个数据结构，它存储了函数值，以及规定的导数数量。对于一个期望有两个参数的一次可导数，它可能看起来像这样。

// 
// @code
//  struct ADNumberType
//  {
//    double value; The value of the object
//    double derivatives[2]; Array of derivatives of the object with
//                  respect to x and y
//  };
//  @endcode

// 对于我们的自变量`x_ad`，`x_ad.value`的起始值只是它的赋值（即这个变量代表的实值）。导数`x_ad.derivatives[0]`将被初始化为`1'，因为`x'是第2个独立变量和 $\frac{d(x)}{dx} = 1$  。导数`x.derivatives[1]`将被初始化为零，因为第一个自变量是`y`和 $\frac{d(x)}{dy} = 0$  。

// 为了使函数导数有意义，我们必须假设这个函数不仅在分析意义上是可微的，而且在评估点`x,y`也是可微的。我们可以利用这两个假设：当我们在数学运算中使用这种数字类型时，AD框架可以**的
//重载操作（例如，`%operator+()`, `%operator*()`以及`%sin()`, `%exp()`, 等等），使返回的结果具有预期值。同时，它将通过对被重载的确切函数的了解和对连锁规则的严格应用来计算导数。因此，`%sin()`函数（其参数`a`本身是自变量`x`和`y`的一个函数 *可能*被定义如下。

// 
// @code
// ADNumberType sin(const ADNumberType &a)
// {
//   ADNumberType output;
//
//   // For the input argument "a", "a.value" is simply its value.
//   output.value = sin(a.value);
//
//   // We know that the derivative of sin(a) is cos(a), but we need
//   // to also consider the chain rule and that the input argument
//   // `a` is also differentiable with respect to the original
//   // independent variables `x` and `y`. So `a.derivatives[0]`
//   // and `a.derivatives[1]` respectively represent the partial
//   // derivatives of `a` with respect to its inputs `x` and `y`.
//   output.derivatives[0] = cos(a.value)*a.derivatives[0];
//   output.derivatives[1] = cos(a.value)*a.derivatives[1];
//
//   return output;
// }
// @endcode

// 当然，所有这些也可以用于二阶甚至高阶导数。

// 所以现在很明显，通过上述表示，`ADNumberType`携带了一些额外的数据，这些数据代表了可微调函数相对于原始（敏感）自变量的各种导数。因此应该注意到，使用它们会产生计算开销（因为我们在做导数计算时要计算额外的函数），以及存储这些结果的内存开销。因此，规定的微分运算的级数最好保持在最低水平，以限制计算成本。例如，我们可以自己计算第一级导数，然后使用 Differentiation::AD::VectorFunction 辅助类来确定依赖函数集合的梯度，这将是原始标量函数的第二级导数。

// 还值得注意的是，由于链式规则是无差别应用的，我们只看到计算的起点和终点`{x,y}`  $\rightarrow$  `f(x,y)`，我们永远只能查询到`f`的总导数；部分导数（上例中的`a.导数[0]`和`a.导数[1]`）是中间值，对我们是隐藏的。

// 好的，既然我们现在至少知道了`f_ad'代表什么，以及它的编码是什么，让我们把所有的东西用于实际的用途。为了获得那些隐藏的派生结果，我们将最终结果注册到帮助类中。在这之后，我们不能再改变`f_ad`的值，也不能让这些变化反映在帮助者类返回的结果中。

      ad_helper.register_dependent_variable(f_ad); 

// 下一步是提取导数（特别是函数梯度和Hessian）。为此，我们首先创建一些临时数据结构（结果类型为`double`）来存储导数（注意，所有的导数都是一次性返回的，而不是单独返回）...

      Vector<double>     Df(ad_helper.n_dependent_variables()); 
      FullMatrix<double> D2f(ad_helper.n_dependent_variables(), 
                             ad_helper.n_independent_variables()); 

// ... 然后我们要求助手类计算这些导数，以及函数值本身。就这样了。我们得到了我们想得到的一切。

      const double computed_f = ad_helper.compute_value(); 
      ad_helper.compute_gradient(Df); 
      ad_helper.compute_hessian(D2f); 

// 我们可以通过与分析方案的比较来说服自己，AD框架是正确的。(或者，如果你像作者一样，你会做相反的事情，宁愿验证你对分析方案的实现是正确的！)

      AssertThrow(std::abs(f(x, y) - computed_f) < tol, 
                  ExcMessage(std::string("Incorrect value computed for f. ") + 
                             std::string("Hand-calculated value: ") + 
                             Utilities::to_string(f(x, y)) + 
                             std::string(" ; ") + 
                             std::string("Value computed by AD: ") + 
                             Utilities::to_string(computed_f))); 

// 因为我们知道自变量的排序，所以我们知道梯度的哪个部分与哪个导数有关......。

      const double computed_df_dx = Df[0]; 
      const double computed_df_dy = Df[1]; 

      AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for df/dx. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(df_dx(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_df_dx))); 
      AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for df/dy. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(df_dy(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_df_dy))); 

// .......对于Hessian也是如此。

      const double computed_d2f_dx_dx = D2f[0][0]; 
      const double computed_d2f_dx_dy = D2f[0][1]; 
      const double computed_d2f_dy_dx = D2f[1][0]; 
      const double computed_d2f_dy_dy = D2f[1][1]; 

      AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dx_dx. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dx_dx(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_d2f_dx_dx))); 
      AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dx_dy. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dx_dy(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_d2f_dx_dy))); 
      AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dy_dx. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dy_dx(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_d2f_dy_dx))); 
      AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dy_dy. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dy_dy(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_d2f_dy_dy))); 
    } 

// 这很不错。在计算这个三角函数的二阶导数时并没有太多的工作。

//  @sect4{Hand-calculated derivatives of the analytical solution}  

// 既然我们现在知道了让AD框架为我们计算这些导数需要多少 "执行工作"，让我们把它与手工计算并在几个独立的函数中实现的同样的导数进行比较。

// 这里是 $f(x,y) = \cos\left(\frac{y}{x}\right)$ 的两个一阶导数。

//  $\frac{df(x,y)}{dx} = \frac{y}{x^2} \sin\left(\frac{y}{x}\right)$  
    double df_dx(const double x, const double y) 
    { 
      Assert(x != 0.0, ExcDivideByZero()); 
      return y * std::sin(y / x) / (x * x); 
    } 
// $\frac{df(x,y)}{dx} = -\frac{1}{x} \sin\left(\frac{y}{x}\right)$  
    double df_dy(const double x, const double y) 
    { 
      return -std::sin(y / x) / x; 
    } 

// 这里是 $f(x,y)$ 的四个二次导数。

//  $\frac{d^{2}f(x,y)}{dx^{2}} = -\frac{y}{x^4} (2x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))$  
    double d2f_dx_dx(const double x, const double y) 
    { 
      return -y * (2 * x * std::sin(y / x) + y * std::cos(y / x)) / 
             (x * x * x * x); 
    } 
// $\frac{d^{2}f(x,y)}{dx dy} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))$  
    double d2f_dx_dy(const double x, const double y) 
    { 
      return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x); 
    } 
// $\frac{d^{2}f(x,y)}{dy dx} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))$  （正如预期的那样，根据[施瓦茨定理]（https:en.wikipedia.org/wiki/Symmetry_of_second_derivatives））。

    double d2f_dy_dx(const double x, const double y) 
    { 
      return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x); 
    } 
// $\frac{d^{2}f(x,y)}{dy^{2}} = -\frac{1}{x^2} \cos\left(\frac{y}{x}\right)$  
    double d2f_dy_dy(const double x, const double y) 
    { 
      return -(std::cos(y / x)) / (x * x); 
    } 

// 嗯......上面有很多地方我们可以引入错误，特别是在应用链式规则的时候。虽然它们不是银弹，但至少这些AD框架可以作为一个验证工具，确保我们没有犯任何错误（无论是计算还是执行），从而对我们的结果产生负面影响。

// 当然，这个例子的重点是，我们可能选择了一个相对简单的函数 $f(x,y)$ ，我们可以手工验证AD框架计算的导数是否正确。但是AD框架并不关心这个函数是否简单。它可能是一个复杂得多的表达式，或者取决于两个以上的变量，它仍然能够计算出导数--唯一的区别是，*我们*不能再想出导数来验证AD框架的正确性。

//  @sect4{Computing derivatives using symbolic differentiation}  

// 我们现在要用符号微分法重复同样的练习。术语 "符号微分 "有点误导，因为微分只是计算机代数系统（CAS）（即符号框架）提供的一个工具。然而，在有限元建模和应用的背景下，它是CAS最常见的用途，因此将是我们关注的重点。再一次，我们将提供参数值`x`和`y`来评估我们的函数 $f(x,y) = \cos\left(\frac{y}{x}\right)$ 和它的导数，并提供一个公差来测试返回结果的正确性。

    void 
    run_and_verify_sd(const double x, const double y, const double tol = 1e-12) 
    { 

// 我们需要做的第一步是形成符号变量，代表我们希望对其进行微分的函数参数。同样，这些将是我们问题的独立变量，因此在某种意义上是原始变量，与其他变量没有任何关系。我们通过初始化一个符号类型 Differentiation::SD::Expression, 来创建这些类型的（独立）变量，这个符号类型是对符号框架所使用的一组类的包装，有一个唯一的标识。在这种情况下，这个标识符，一个 `std::string`, 对于 $x$ 的参数来说，是简单的 "x"，同样，对于依赖函数的 $y$ 参数来说，也是 "y"。像以前一样，我们将用`sd`作为符号变量名称的后缀，这样我们就可以清楚地看到哪些变量是符号性的（而不是数字性的）。

      const Differentiation::SD::Expression x_sd("x"); 
      const Differentiation::SD::Expression y_sd("y"); 

// 使用计算 $f(x,y)$ 的模板化函数，我们可以将这些独立变量作为参数传递给该函数。返回的结果将是另一个符号类型，代表用于计算  $\cos\left(\frac{y}{x}\right)$  的操作序列。

      const Differentiation::SD::Expression f_sd = f(x_sd, y_sd); 

// 在这一点上，打印出表达式`f_sd`是合法的，如果我们这样做的话 
// @code
//  std::cout << "f(x,y) = " << f_sd << std::endl;
//  @endcode 
//我们会看到`f(x,y) = cos(y/x)`打印到控制台。

// 你可能会注意到，我们在构建我们的符号函数`f_sd`时，没有说明我们可能要如何使用它。与上面显示的AD方法相比，我们从调用`f(x_sd, y_sd)`返回的不是函数`f`在某个特定点的评价，而实际上是在一个通用的、尚未确定的点的评价的符号表示。这是使符号框架（CAS）不同于自动区分框架的关键点之一。每个变量`x_sd`和`y_sd`，甚至复合依赖函数`f_sd`，在某种意义上分别是数值的 "占位符 "和操作的组合。事实上，用于组成函数的各个组件也是占位符。操作序列被编码成一个树状的数据结构（概念上类似于[抽象语法树](https:en.wikipedia.org/wiki/Abstract_syntax_tree)）。

// 一旦我们形成了这些数据结构，我们就可以把我们可能想对它们进行的任何操作推迟到以后的某个时间。这些占位符中的每一个都代表了一些东西，但我们有机会在任何方便的时间点上定义或重新定义它们所代表的东西。因此，对于这个特定的问题，我们想把 "x "和 "y "与*一些*数值（类型尚未确定）联系起来是有道理的，但我们可以在概念上（如果有意义的话）给 "y/x "这个比率赋值，而不是单独给 "x "和 "y "这些变量赋值。我们还可以将 "x "或 "y "与其他一些符号函数`g(a,b)`联系起来。这些操作中的任何一个都涉及到对所记录的操作树的操作，以及用其他东西替换树上的突出节点（以及该节点的子树）。这里的关键词是 "替换"，事实上，在 Differentiation::SD 命名空间中有许多函数的名称中都有这个词。

// 这种能力使框架完全通用。在有限元模拟的背景下，我们通常会对我们的符号类型进行的操作类型是函数组合、微分、替换（部分或完全）和评估（即符号类型向其数字对应物的转换）。但如果你需要，一个CAS的能力往往不止这些。它可以形成函数的反导数（积分），对形成函数的表达式进行简化（例如，用 $1$ 替换 $(\sin a)^2 + (\cos a)^2$ ；或者，更简单：如果函数做了像`1+2`这样的运算，CAS可以用`3`替换它），等等。变量所代表的*表达式是从函数 $f$ 的实现方式中得到的，但CAS可以对其进行任何功能的操作。

// 具体来说，为了计算因果函数相对于各个自变量的一阶导数的符号表示，我们使用 Differentiation::SD::Expression::differentiate() 函数，自变量作为其参数。每次调用都会导致CAS通过组成`f_sd`的运算树，并对表达式树的每个节点进行相对于给定符号参数的微分。

      const Differentiation::SD::Expression df_dx_sd = f_sd.differentiate(x_sd); 
      const Differentiation::SD::Expression df_dy_sd = f_sd.differentiate(y_sd); 

// 为了计算二阶导数的符号表示，我们只需对自变量的一阶导数进行微分。所以要计算高阶导数，我们首先需要计算低阶导数。由于调用 "differentiate() "的返回类型是一个表达式，我们原则上可以通过将两个调用连在一起，直接从标量上执行双倍微分。但是在这个特殊的情况下，这是不需要的，因为我们手头有中间结果）。)

      const Differentiation::SD::Expression d2f_dx_dx_sd = 
        df_dx_sd.differentiate(x_sd); 
      const Differentiation::SD::Expression d2f_dx_dy_sd = 
        df_dx_sd.differentiate(y_sd); 
      const Differentiation::SD::Expression d2f_dy_dx_sd = 
        df_dy_sd.differentiate(x_sd); 
      const Differentiation::SD::Expression d2f_dy_dy_sd = 
        df_dy_sd.differentiate(y_sd); 

// 使用语句
// @code
//  std::cout << "df_dx_sd: " << df_dx_sd << std::endl;
//  std::cout << "df_dy_sd: " << df_dy_sd << std::endl;
//  std::cout << "d2f_dx_dx_sd: " << d2f_dx_dx_sd << std::endl;
//  std::cout << "d2f_dx_dy_sd: " << d2f_dx_dy_sd << std::endl;
//  std::cout << "d2f_dy_dx_sd: " << d2f_dy_dx_sd << std::endl;
//  std::cout << "d2f_dy_dy_sd: " << d2f_dy_dy_sd << std::endl;
//  @endcode
//  打印由CAS计算的第一和第二导数的表达式，得到以下输出。
//  @code{.sh}
//  df_dx_sd: y*sin(y/x)/x**2
//  df_dy_sd: -sin(y/x)/x
//  d2f_dx_dx_sd: -y**2*cos(y/x)/x**4 - 2*y*sin(y/x)/x**3
//  d2f_dx_dy_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3
//  d2f_dy_dx_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3
//  d2f_dy_dy_sd: -cos(y/x)/x**2
//  @endcode 
//  这与前面介绍的这些导数的分析表达式相比，效果很好。

// 现在我们已经形成了函数及其导数的符号表达式，我们想对函数的主要参数`x`和`y`的数字值进行评估。为了达到这个目的，我们构造了一个*替代图*，它将符号值映射到它们的数字对应值。

      const Differentiation::SD::types::substitution_map substitution_map = 
        Differentiation::SD::make_substitution_map( 
          std::pair<Differentiation::SD::Expression, double>{x_sd, x}, 
          std::pair<Differentiation::SD::Expression, double>{y_sd, y}); 

// 这个过程的最后一步是将所有的符号变量和操作转换成数值，并产生这个操作的数值结果。为了做到这一点，我们在上面已经提到的步骤中，将替换图与符号变量结合起来。"替换"。

// 一旦我们把这个替换图传递给CAS，它就会把符号变量的每个实例（或者更一般的，子表达式）替换成它的数字对应物，然后把这些结果在操作树上传播，如果可能的话，简化树上的每个节点。如果运算树被简化为一个单一的值（也就是说，我们已经将所有的独立变量替换成了它们的数字对应值），那么评估就完成了。

// 由于C++的强类型特性，我们需要指示CAS将其对结果的表示转换为内在的数据类型（本例中为`double'）。这就是 "评估 "步骤，通过模板类型我们定义了这个过程的返回类型。方便的是，如果我们确定我们已经进行了完整的替换，这两个步骤可以一次完成。

      const double computed_f = 
        f_sd.substitute_and_evaluate<double>(substitution_map); 

      AssertThrow(std::abs(f(x, y) - computed_f) < tol, 
                  ExcMessage(std::string("Incorrect value computed for f. ") + 
                             std::string("Hand-calculated value: ") + 
                             Utilities::to_string(f(x, y)) + 
                             std::string(" ; ") + 
                             std::string("Value computed by AD: ") + 
                             Utilities::to_string(computed_f))); 

// 我们可以对第一个导数做同样的处理......

      const double computed_df_dx = 
        df_dx_sd.substitute_and_evaluate<double>(substitution_map); 
      const double computed_df_dy = 
        df_dy_sd.substitute_and_evaluate<double>(substitution_map); 

      AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for df/dx. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(df_dx(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by AD: ") + 
                    Utilities::to_string(computed_df_dx))); 
      AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol, 
 
 
 
 
 
                    Utilities::to_string(computed_df_dy))); 

// ...以及二阶导数。请注意，我们可以在这些操作中重复使用相同的替换图，因为我们希望针对相同的`x`和`y`值评估所有这些函数。修改置换图中的值，就可以得到相同的符号表达式的评估结果，同时给自变量分配不同的值。我们也可以很高兴地让每个变量在一次中代表一个实值，在下一次中代表一个复值。

      const double computed_d2f_dx_dx = 
        d2f_dx_dx_sd.substitute_and_evaluate<double>(substitution_map); 
      const double computed_d2f_dx_dy = 
        d2f_dx_dy_sd.substitute_and_evaluate<double>(substitution_map); 
      const double computed_d2f_dy_dx = 
        d2f_dy_dx_sd.substitute_and_evaluate<double>(substitution_map); 
      const double computed_d2f_dy_dy = 
        d2f_dy_dy_sd.substitute_and_evaluate<double>(substitution_map); 

      AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dx_dx. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dx_dx(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by SD: ") + 
                    Utilities::to_string(computed_d2f_dx_dx))); 
      AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dx_dy. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dx_dy(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by SD: ") + 
                    Utilities::to_string(computed_d2f_dx_dy))); 
      AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dy_dx. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dy_dx(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by SD: ") + 
                    Utilities::to_string(computed_d2f_dy_dx))); 
      AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol, 
                  ExcMessage( 
                    std::string("Incorrect value computed for d2f/dy_dy. ") + 
                    std::string("Hand-calculated value: ") + 
                    Utilities::to_string(d2f_dy_dy(x, y)) + std::string(" ; ") + 
                    std::string("Value computed by SD: ") + 
                    Utilities::to_string(computed_d2f_dy_dy))); 
    } 
// @sect4{The SimpleExample::run() function}  

// 用来驱动这些初始例子的函数是直接的。我们将任意选择一些值来评估该函数（尽管知道`x = 0`是不允许的），然后将这些值传递给使用AD和SD框架的函数。

    void run() 
    { 
      const double x = 1.23; 
      const double y = 0.91; 

      std::cout << "Simple example using automatic differentiation..." 
                << std::endl; 
      run_and_verify_ad(x, y); 
      std::cout << "... all calculations are correct!" << std::endl; 

      std::cout << "Simple example using symbolic differentiation." 
                << std::endl; 
      run_and_verify_sd(x, y); 
      std::cout << "... all calculations are correct!" << std::endl; 
    } 

  } // namespace SimpleExample 
// @sect3{A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points}  

// 现在我们已经介绍了自动分化和符号分化背后的原理，我们将通过制定两个耦合的磁力学构成法将其付诸实施：一个是与速率无关的，另一个则表现为与速率有关的行为。

// 正如你在介绍中记得的那样，我们将考虑的材料构成法则要比上面的简单例子复杂得多。这不仅仅是因为我们将考虑的函数 $\psi_{0}$ 的形式，而且特别是因为 $\psi_{0}$ 不仅仅取决于两个标量变量，而是取决于一大堆*张量，每个张量都有几个组成部分。在某些情况下，这些是*对称*张量，对于这些张量来说，只有一个分量子集实际上是独立的，我们必须考虑计算 $\frac{\partial\psi_{0}}{\partial \mathbf{C}}$ 这样的导数的实际意义，其中 $\mathbf C$ 是一个对称张量。希望这一切将在下面变得清晰。我们也将清楚地看到，用手来做这件事，在最好的情况下，将是非常*繁琐，而在最坏的情况下，充满了难以发现的错误。

  namespace CoupledConstitutiveLaws 
  { 
// @sect4{Constitutive parameters}  

// 我们先描述一下能量函数描述中出现的各种材料参数  $\psi_{0}$  。

// ConstitutiveParameters类被用来保存这些数值。所有参数的值（包括构成参数和流变参数）都来自于  @cite Pelteret2018a  ，并给出了能够产生大致代表真实的、实验室制造的磁活性聚合物的构成响应的值，当然，这里使用的具体数值对本程序的目的没有影响。

// 前四个构成参数分别代表

// 弹性剪切模量 $\mu_{e}$  。

// --磁饱和时的弹性剪切模量  $\mu_{e}^{\infty}$  。

// - 弹性剪切模量的饱和磁场强度  $h_{e}^{\text{sat}}$  ，以及

// 泊松比  $\nu$  。

    class ConstitutiveParameters : public ParameterAcceptor 
    { 
    public: 
      ConstitutiveParameters(); 

      double mu_e       = 30.0e3; 
      double mu_e_inf   = 250.0e3; 
      double mu_e_h_sat = 212.2e3; 
      double nu_e       = 0.49; 

// 接下来的四个，只与速率相关的材料有关，是以下的参数

// - 粘弹性剪切模量  $\mu_{v}$  。

// - 磁饱和时的粘弹性剪切模量  $\mu_{v}^{\infty}$  。

// 粘弹性剪切模量的饱和磁场强度 $h_{v}^{\text{sat}}$  ，以及

// --特征松弛时间  $\tau$  。

      double mu_v       = 20.0e3; 
      double mu_v_inf   = 35.0e3; 
      double mu_v_h_sat = 92.84e3; 
      double tau_v      = 0.6; 

// 最后一个参数是相对磁导率  $\mu_{r}$  。

      double mu_r = 6.0; 

      bool initialized = false; 
    }; 

// 参数是通过ParameterAcceptor框架初始化的，该框架在  step-60  中有详细讨论。

    ConstitutiveParameters::ConstitutiveParameters() 
      : ParameterAcceptor("/Coupled Constitutive Laws/Constitutive Parameters/") 
    { 
      add_parameter("Elastic shear modulus", mu_e); 
      add_parameter("Elastic shear modulus at magnetic saturation", mu_e_inf); 
      add_parameter( 
        "Saturation magnetic field strength for elastic shear modulus", 
        mu_e_h_sat); 
      add_parameter("Poisson ratio", nu_e); 

      add_parameter("Viscoelastic shear modulus", mu_v); 
      add_parameter("Viscoelastic shear modulus at magnetic saturation", 
                    mu_v_inf); 
      add_parameter( 
        "Saturation magnetic field strength for viscoelastic shear modulus", 
        mu_v_h_sat); 
      add_parameter("Characteristic relaxation time", tau_v); 

      add_parameter("Relative magnetic permeability", mu_r); 

      parse_parameters_call_back.connect([&]() { initialized = true; }); 
    } 
// @sect4{Constitutive laws: Base class}  

// 由于我们将为同一类材料制定两种构成法，因此定义一个基类以确保它们有统一的接口是有意义的。

// 类的声明从构造函数开始，它将接受一组构成参数，这些参数与材料定律本身一起决定了材料的响应。

    template <int dim> 
    class Coupled_Magnetomechanical_Constitutive_Law_Base 
    { 
    public: 
      Coupled_Magnetomechanical_Constitutive_Law_Base( 
        const ConstitutiveParameters &constitutive_parameters); 

// 我们将在一个方法中计算和存储这些值，而不是随意计算和返回动力学变量或其线性化。然后这些缓存的结果将在请求时返回。我们将把为什么要这样做的精确解释推迟到以后的阶段。现在重要的是看到这个函数接受所有的场变量，即磁场矢量 $\boldsymbol{\mathbb{H}}$ 和右Cauchy-Green变形张量 $\mathbf{C}$ ，以及时间离散器。除了 @p constitutive_parameters, 之外，这些都是计算材料响应所需的基本量。

      virtual void update_internal_data(const SymmetricTensor<2, dim> &C, 
                                        const Tensor<1, dim> &         H, 
                                        const DiscreteTime &time) = 0; 

// 接下来的几个函数提供了探测材料响应的接口，这些响应是由于施加的变形和磁荷载引起的。

// 由于该类材料可以用自由能 $\psi_{0}$ 来表示，我们可以计算出......

      virtual double get_psi() const = 0; 

// ... 以及两个动力学量。

// 磁感应矢量  $\boldsymbol{\mathbb{B}}$  ，和

// --皮奥拉-基尔霍夫总应力张量 $\mathbf{S}^{\text{tot}}$  。
      virtual Tensor<1, dim> get_B() const = 0; 

      virtual SymmetricTensor<2, dim> get_S() const = 0; 

// .......以及动力学量的线性化，它们是。

// --磁静力学正切张量  $\mathbb{D}$  。

// - 总的参考性磁弹性耦合张量 $\mathfrak{P}^{\text{tot}}$  ，以及

// --总的参考弹性正切张量 $\mathcal{H}^{\text{tot}}$  。

      virtual SymmetricTensor<2, dim> get_DD() const = 0; 

      virtual Tensor<3, dim> get_PP() const = 0; 

      virtual SymmetricTensor<4, dim> get_HH() const = 0; 

// 我们还将定义一个方法，为这个类实例提供一个机制，在进入下一个时间段之前做任何额外的任务。同样，这样做的原因将在稍后变得清晰。

      virtual void update_end_of_timestep() 
      {} 

// 在该类的`保护'部分，我们存储了一个对支配材料响应的构成参数实例的引用。为了方便起见，我们还定义了一些函数来返回各种构成参数（包括明确定义的，以及计算的）。

与材料的弹性响应有关的参数依次是：//。

// - 弹性剪切模量。

// - 饱和磁场下的弹性剪切模量。

// - 弹性剪切模量的饱和磁场强度。

// - 泊松比。

// 泊松比、Lam&eacute;参数，以及

// 体积模量。

    protected: 
      const ConstitutiveParameters &constitutive_parameters; 

      double get_mu_e() const; 

      double get_mu_e_inf() const; 

      double get_mu_e_h_sat() const; 

      double get_nu_e() const; 

      double get_lambda_e() const; 

      double get_kappa_e() const; 

// 与材料的弹性响应有关的参数依次是

// - 粘弹性剪切模量。

// -- 磁饱和时的粘弹性剪切模量。

// - 粘弹性剪切模量的饱和磁场强度，以及

粘弹性剪切模量的饱和磁场强度，和//--特征松弛时间。

      double get_mu_v() const; 

      double get_mu_v_inf() const; 

      double get_mu_v_h_sat() const; 

      double get_tau_v() const; 

// 与材料的磁响应有关的参数依次是：。

// 相对磁导率，以及

// - 磁导率常数 $\mu_{0}$ （其实不是一个材料常数，而是一个普遍的常数，为了简单起见，我们在这里分组）。

// 我们还将实现一个函数，从时间离散性中返回时间步长。

      double get_mu_r() const; 

      constexpr double get_mu_0() const; 
      double           get_delta_t(const DiscreteTime &time) const; 
    }; 

// 在下文中，让我们从实现刚才定义的类的几个相对琐碎的成员函数开始。

    template <int dim> 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>:: 
      Coupled_Magnetomechanical_Constitutive_Law_Base( 
        const ConstitutiveParameters &constitutive_parameters) 
      : constitutive_parameters(constitutive_parameters) 
    { 
      Assert(get_kappa_e() > 0, ExcInternalError()); 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e() const 
    { 
      return constitutive_parameters.mu_e; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_inf() const 
    { 
      return constitutive_parameters.mu_e_inf; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_h_sat() const 
    { 
      return constitutive_parameters.mu_e_h_sat; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_nu_e() const 
    { 
      return constitutive_parameters.nu_e; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_lambda_e() const 
    { 
      return 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e()); 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_kappa_e() const 
    { 
      return (2.0 * get_mu_e() * (1.0 + get_nu_e())) / 
             (3.0 * (1.0 - 2.0 * get_nu_e())); 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v() const 
    { 
      return constitutive_parameters.mu_v; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_inf() const 
    { 
      return constitutive_parameters.mu_v_inf; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_h_sat() const 
    { 
      return constitutive_parameters.mu_v_h_sat; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_tau_v() const 
    { 
      return constitutive_parameters.tau_v; 
    } 

    template <int dim> 
    double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_r() const 
    { 
      return constitutive_parameters.mu_r; 
    } 

    template <int dim> 
    constexpr double 
    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_0() const 
    { 
      return 4.0 * numbers::PI * 1e-7; 
    } 

    template <int dim> 
    double Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_delta_t( 
      const DiscreteTime &time) const 
    { 
      return time.get_previous_step_size(); 
    } 
// @sect4{Magnetoelastic constitutive law (using automatic differentiation)}  

// 我们将首先考虑一种非耗散性材料，即受磁超弹性构成法则支配的材料，在浸入磁场时表现出僵硬。正如介绍中所述，这种材料的储能密度函数可能由
// @f[
//    \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//      \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F}))
//      \right]
//  + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right)
//  - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F})
//      \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//      \boldsymbol{\mathbb{H}} \right]
//  @f]
//  和
//  @f[
//   f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//  = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right]
//      \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//      \boldsymbol{\mathbb{H}}}
//        {\left(h_{e}^{\text{sat}}\right)^{2}} \right) .
//  @f]
//  给出。

// 现在来看看实现这种行为的类。由于我们希望这个类能完全描述一种材料，所以我们将它标记为 "final"，这样继承树就在这里终止了。在类的顶部，我们定义了辅助类型，我们将在标量能量密度函数的AD计算中使用它。请注意，我们希望它能返回 "double "类型的值。我们还必须指定空间维度的数量，`dim'，以便建立矢量、张量和对称张量场与它们所含分量数量之间的联系。用于ADHelper类的具体的`ADTypeCode`将在实际使用该类的时候作为模板参数提供。

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    class Magnetoelastic_Constitutive_Law_AD final 
      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim> 
    { 
      using ADHelper = 
        Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>; 
      using ADNumberType = typename ADHelper::ad_type; 

    public: 
      Magnetoelastic_Constitutive_Law_AD( 
        const ConstitutiveParameters &constitutive_parameters); 

// 由于基类的公共接口是纯 "虚拟 "的，这里我们将声明这个类将覆盖所有这些基类方法。

      virtual void update_internal_data(const SymmetricTensor<2, dim> &C, 
                                        const Tensor<1, dim> &         H, 
                                        const DiscreteTime &) override; 

      virtual double get_psi() const override; 

      virtual Tensor<1, dim> get_B() const override; 

      virtual SymmetricTensor<2, dim> get_S() const override; 

      virtual SymmetricTensor<2, dim> get_DD() const override; 

      virtual Tensor<3, dim> get_PP() const override; 

      virtual SymmetricTensor<4, dim> get_HH() const override; 

// 在这个类的`private`部分，我们需要定义一些提取器，这些提取器将帮助我们设置自变量，随后得到与因变量相关的计算值。如果这个类是在有限元问题的背景下使用，那么这些提取器中的每一个都（很可能）与解场的一个分量（在本例中，位移和磁标势）的梯度有关。正如你现在可能推断的那样，这里 "C "表示右Cauchy-Green张量，"H "表示磁场向量。

    private: 
      const FEValuesExtractors::Vector             H_components; 
      const FEValuesExtractors::SymmetricTensor<2> C_components; 

// 这是一个自动微分助手的实例，我们将设置它来完成与构成法则有关的所有微分计算......

      ADHelper ad_helper; 

// ... 以下三个成员变量将存储来自 @p ad_helper. 的输出。  @p ad_helper 一次性返回关于所有场变量的导数，因此我们将保留完整的梯度向量和Hessian矩阵。我们将从中提取我们真正感兴趣的单个条目。

      double             psi; 
      Vector<double>     Dpsi; 
      FullMatrix<double> D2psi; 
    }; 

// 在设置字段组件提取器时，对于它们的顺序是完全任意的。但重要的是，这些提取器没有重叠的索引。这些提取器的组件总数定义了 @p ad_helper 需要跟踪的独立变量的数量，并且我们将对其进行导数。由此产生的数据结构 @p Dpsi 和 @p D2psi 也必须有相应的大小。一旦 @p ad_helper 被配置好（它的输入参数是 $\mathbf{C}$ 和 $\boldsymbol{\mathbb{H}}$ 的组件总数），我们就可以直接询问它使用多少个独立变量。

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>:: 
      Magnetoelastic_Constitutive_Law_AD( 
        const ConstitutiveParameters &constitutive_parameters) 
      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>( 
          constitutive_parameters) 
      , H_components(0) 
      , C_components(Tensor<1, dim>::n_independent_components) 
      , ad_helper(Tensor<1, dim>::n_independent_components + 
                  SymmetricTensor<2, dim>::n_independent_components) 
      , psi(0.0) 
      , Dpsi(ad_helper.n_independent_variables()) 
      , D2psi(ad_helper.n_independent_variables(), 
              ad_helper.n_independent_variables()) 
    {} 

// 如前所述，由于自动微分库的工作方式， @p ad_helper 将总是同时返回能量密度函数相对于所有场变量的导数。由于这个原因，在函数`get_B()`、`get_S()`等中计算导数是没有意义的，因为我们会做很多额外的计算，然后直接丢弃。因此，处理这个问题的最好方法是用一个单一的函数调用来完成所有的前期计算，然后我们在需要时提取存储的数据。这就是我们在 "update_internal_data() "方法中要做的。由于材料是与速率无关的，我们可以忽略DiscreteTime参数。

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    void 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::update_internal_data( 
      const SymmetricTensor<2, dim> &C, 
      const Tensor<1, dim> &         H, 
      const DiscreteTime &) 
    { 
      Assert(determinant(C) > 0, ExcInternalError()); 

// 由于我们在每个时间步骤中都会重复使用 @p ad_helper 数据结构，所以我们需要在使用前清除它的所有陈旧信息。

      ad_helper.reset(); 

// 下一步是设置所有字段组件的值。这些定义了 "点"，我们将围绕这个点计算函数梯度及其线性化。我们之前创建的提取器提供了字段和 @p ad_helper 中的注册表之间的关联 -- 它们将被反复使用，以确保我们对哪个变量对应于`H`或`C`的哪个分量有正确的解释。

      ad_helper.register_independent_variable(H, H_components); 
      ad_helper.register_independent_variable(C, C_components); 

// 现在我们已经完成了最初的设置，我们可以检索我们字段的AD对应关系。这些是真正的能量函数的独立变量，并且对用它们进行的计算是 "敏感的"。请注意，AD数被视为一种特殊的数字类型，可以在许多模板化的类中使用（在这个例子中，作为Tensor和SymmetricTensor类的标量类型）。

      const Tensor<1, dim, ADNumberType> H_ad = 
        ad_helper.get_sensitive_variables(H_components); 
      const SymmetricTensor<2, dim, ADNumberType> C_ad = 
        ad_helper.get_sensitive_variables(C_components); 

// 我们还可以在许多以标量类型为模板的函数中使用它们。因此，对于我们需要的这些中间值，我们可以进行张量运算和一些数学函数。由此产生的类型也将是一个自动可分的数字，它对这些函数中的操作进行编码。

      const ADNumberType det_F_ad = std::sqrt(determinant(C_ad)); 
      const SymmetricTensor<2, dim, ADNumberType> C_inv_ad = invert(C_ad); 
      AssertThrow(det_F_ad > ADNumberType(0.0), 
                  ExcMessage("Volumetric Jacobian must be positive.")); 

// 接下来我们将计算出在磁场影响下导致剪切模量变化（增加）的比例函数......

      const ADNumberType f_mu_e_ad = 
        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) * 
                std::tanh((2.0 * H_ad * H_ad) / 
                          (this->get_mu_e_h_sat() * this->get_mu_e_h_sat())); 

// ...然后我们就可以定义材料的储能密度函数。我们将在后面看到，这个例子足够复杂，值得使用AD，至少可以验证一个无辅助的实现。

      const ADNumberType psi_ad = 
        0.5 * this->get_mu_e() * f_mu_e_ad * 
          (trace(C_ad) - dim - 2.0 * std::log(det_F_ad))                 // 
        + this->get_lambda_e() * std::log(det_F_ad) * std::log(det_F_ad) // 
        - 0.5 * this->get_mu_0() * this->get_mu_r() * det_F_ad * 
            (H_ad * C_inv_ad * H_ad); // 

// 储存的能量密度函数实际上是这个问题的因变量，所以作为 "配置 "阶段的最后一步，我们用 @p ad_helper. 注册其定义。
      ad_helper.register_dependent_variable(psi_ad); 

// 最后，我们可以检索存储的能量密度函数的结果值，以及它相对于输入字段的梯度和Hessian，并将它们缓存起来。

      psi = ad_helper.compute_value(); 
      ad_helper.compute_gradient(Dpsi); 
      ad_helper.compute_hessian(D2psi); 
    } 

// 下面的几个函数可以查询 $\psi_{0}$ 的存储值，并提取梯度向量和Hessian矩阵的所需成分。我们再次利用提取器来表达我们希望检索的总梯度向量和Hessian矩阵的哪些部分。它们只返回能量函数的导数，所以对于我们的动能变量的定义和它们的线性化，还需要进行一些操作来形成所需的结果。

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    double Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_psi() const 
    { 
      return psi; 
    } 

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    Tensor<1, dim> 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_B() const 
    { 
      const Tensor<1, dim> dpsi_dH = 
        ad_helper.extract_gradient_component(Dpsi, H_components); 
      return -dpsi_dH; 
    } 

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    SymmetricTensor<2, dim> 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_S() const 
    { 
      const SymmetricTensor<2, dim> dpsi_dC = 
        ad_helper.extract_gradient_component(Dpsi, C_components); 
      return 2.0 * dpsi_dC; 
    } 

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    SymmetricTensor<2, dim> 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_DD() const 
    { 
      const Tensor<2, dim> dpsi_dH_dH = 
        ad_helper.extract_hessian_component(D2psi, H_components, H_components); 
      return -symmetrize(dpsi_dH_dH); 
    } 

// 请注意，对于耦合项来说，提取器参数的顺序特别重要，因为它决定了定向导数的提取顺序。因此，如果我们在调用`extract_hessian_component()`时颠倒了提取器的顺序，那么我们实际上是在检索  $\left[ \mathfrak{P}^{\text{tot}} \right]^{T}$  的一部分。

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    Tensor<3, dim> 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_PP() const 
    { 
      const Tensor<3, dim> dpsi_dC_dH = 
        ad_helper.extract_hessian_component(D2psi, C_components, H_components); 
      return -2.0 * dpsi_dC_dH; 
    } 

    template <int dim, Differentiation::AD::NumberTypes ADTypeCode> 
    SymmetricTensor<4, dim> 
    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_HH() const 
    { 
      const SymmetricTensor<4, dim> dpsi_dC_dC = 
        ad_helper.extract_hessian_component(D2psi, C_components, C_components); 
      return 4.0 * dpsi_dC_dC; 
    } 
// @sect4{Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)}  

// 我们要考虑的第二个材料定律将是一个代表具有单一耗散机制的磁涡弹材料。我们将考虑这种材料的自由能密度函数定义为
// @f{align*}{
//    \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}}
//    \right)
//  &= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)
//  \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  &= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}}
//  \right)
//      \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F}))
//      \right]
//  + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right)
//  - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F})
//      \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//      \boldsymbol{\mathbb{H}} \right]
//  \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)
//  &= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//  \right)
//      \left[ \mathbf{C}_{v} : \left[
//        \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//        \mathbf{C} \right] - d - \ln\left(
//        \text{det}\left(\mathbf{C}_{v}\right) \right)  \right]
//  @f}
//  ，其中
//  @f[
//    f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right)
//  = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right]
//      \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//      \boldsymbol{\mathbb{H}}}
//        {\left(h_{e}^{\text{sat}}\right)^{2}} \right)
//  @f]

// @f[
//    f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right)
//  = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right]
//      \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//      \boldsymbol{\mathbb{H}}}
//        {\left(h_{v}^{\text{sat}}\right)^{2}} \right),
//  @f]
//  与内部粘性变量
//  @f[
//  \mathbf{C}_{v}^{(t)}
//  = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[
//      \mathbf{C}_{v}^{(t-1)}
//    + \frac{\Delta t}{\tau_{v}}
//      \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//      \mathbf{C} \right]^{-1}
//    \right]
//  @f]
//  的演化规律相结合，该演化规律采用一阶后向差分近似法进行离散。

// 再一次，让我们看看在一个具体的类中是如何实现的。我们现在将利用SD方法，而不是之前类中使用的AD框架。为了支持这一点，这个类的构造函数不仅接受 @p constitutive_parameters, ，而且还接受两个额外的变量，这些变量将被用来初始化一个 Differentiation::SD::BatchOptimizer. 我们将在后面给出更多的背景。

    template <int dim> 
    class Magnetoviscoelastic_Constitutive_Law_SD final 
      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim> 
    { 
    public: 
      Magnetoviscoelastic_Constitutive_Law_SD( 
        const ConstitutiveParameters &               constitutive_parameters, 
        const Differentiation::SD::OptimizerType     optimizer_type, 
        const Differentiation::SD::OptimizationFlags optimization_flags); 

// 和自动区分助手一样， Differentiation::SD::BatchOptimizer 将一次性返回一个结果集合。因此，为了只做一次，我们将利用与之前类似的方法，在`update_internal_data()`函数中做所有昂贵的计算，并将结果缓存起来，以便分层提取。

      virtual void update_internal_data(const SymmetricTensor<2, dim> &C, 
                                        const Tensor<1, dim> &         H, 
                                        const DiscreteTime &time) override; 

      virtual double get_psi() const override; 

      virtual Tensor<1, dim> get_B() const override; 

      virtual SymmetricTensor<2, dim> get_S() const override; 

      virtual SymmetricTensor<2, dim> get_DD() const override; 

      virtual Tensor<3, dim> get_PP() const override; 

      virtual SymmetricTensor<4, dim> get_HH() const override; 

// 因为我们要处理的是一个与速率有关的材料，所以我们必须在适当的时候更新历史变量。这将是这个函数的目的。

      virtual void update_end_of_timestep() override; 

// 在该类的`private`部分，我们将希望跟踪内部的粘性变形，所以下面两个（实值的，非符号的）成员变量分别持有

// - 内部变量时间步长（如果嵌入非线性求解器框架，则为牛顿步长）的值，以及

// - 内部变量在前一个时间步长的值。

// （我们将这些变量标记为 "Q"，以便于识别；在计算的海洋中，不一定容易将`Cv`或`C_v`与`C`区分开来）。

    private: 
      SymmetricTensor<2, dim> Q_t; 
      SymmetricTensor<2, dim> Q_t1; 

// 由于我们将使用符号类型，我们需要定义一些符号变量，以便与框架一起使用。(它们都以 "SD "为后缀，以方便区分符号类型或表达式与实值类型或标量。) 这可以在前面做一次（甚至有可能作为 "静态 "变量），以尽量减少与创建这些变量相关的开销。为了实现通用编程的终极目标，我们甚至可以用符号来描述构成参数，*有可能*允许一个类的实例在这些值的不同输入下被重复使用。

// 这些是代表弹性、粘性和磁性材料参数的符号标量（定义的顺序与它们在 @p ConstitutiveParameters 类中出现的顺序基本相同）。我们还存储了一个符号表达式， @p delta_t_sd, ，表示时间步长）。)

      const Differentiation::SD::Expression mu_e_sd; 
      const Differentiation::SD::Expression mu_e_inf_sd; 
      const Differentiation::SD::Expression mu_e_h_sat_sd; 
      const Differentiation::SD::Expression lambda_e_sd; 
      const Differentiation::SD::Expression mu_v_sd; 
      const Differentiation::SD::Expression mu_v_inf_sd; 
      const Differentiation::SD::Expression mu_v_h_sat_sd; 
      const Differentiation::SD::Expression tau_v_sd; 
      const Differentiation::SD::Expression delta_t_sd; 
      const Differentiation::SD::Expression mu_r_sd; 

// 接下来我们定义一些代表独立场变量的张量符号变量，在此基础上，能量密度函数被参数化。

      const Tensor<1, dim, Differentiation::SD::Expression>          H_sd; 
      const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_sd; 

// 同样，我们也有内部粘性变量的符号表示（包括它的当前值和它在前一个时间段的值）。

      const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t_sd; 
      const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t1_sd; 

// 我们还应该存储从属表达式的定义。虽然我们只计算一次，但我们需要它们从下面声明的 @p optimizer 中检索数据。此外，当序列化一个像这样的材料类时（不是作为本教程的一部分），我们要么需要把这些表达式也序列化，要么需要在重新加载时重建它们。

      Differentiation::SD::Expression                          psi_sd; 
      Tensor<1, dim, Differentiation::SD::Expression>          B_sd; 
      SymmetricTensor<2, dim, Differentiation::SD::Expression> S_sd; 
      SymmetricTensor<2, dim, Differentiation::SD::Expression> BB_sd; 
      Tensor<3, dim, Differentiation::SD::Expression>          PP_sd; 
      SymmetricTensor<4, dim, Differentiation::SD::Expression> HH_sd; 

// 然后，下一个变量是用于评估从属函数的优化器。更具体地说，它提供了加速评估符号依赖表达式的可能性。这是一个重要的工具，因为对冗长表达式的本地评估（不使用加速方法，而是直接对符号表达式进行评估）会非常慢。 Differentiation::SD::BatchOptimizer 类提供了一种机制，可以将符号表达式树转化为另一种代码路径，例如，在各种从属表达式之间共享中间结果（意味着这些中间值每次评估只计算一次）和/或使用即时编译器编译代码（从而检索评估步骤的接近原生性能）。

// 执行这种代码转换在计算上是非常昂贵的，所以我们存储了优化器，使其在每个类实例中只做一次。这也进一步促使我们决定将构成参数本身变成符号化。这样我们就可以在几种材料（当然是相同的能量函数）和潜在的多个连续体点（如果嵌入到有限元模拟中）中重复使用这个 @p optimizer 的单一实例。

// 正如模板参数所指定的，数值结果将是<tt>double</tt>类型。

      Differentiation::SD::BatchOptimizer<double> optimizer; 

// 在评估阶段，我们必须将符号变量映射到它们的实值对应物。下一个方法将提供这个功能。

// 这个类的最后一个方法将配置  @p optimizer.  。
      Differentiation::SD::types::substitution_map 
      make_substitution_map(const SymmetricTensor<2, dim> &C, 
                            const Tensor<1, dim> &         H, 
                            const double                   delta_t) const; 

      void initialize_optimizer(); 
    }; 

// 由于静止变形状态是材料被认为是完全松弛的状态，内部粘性变量被初始化为同一张量，即  $\mathbf{C}_{v} = \mathbf{I}$  。代表构成参数、时间步长、场和内部变量的各种符号变量都有一个唯一的标识符。优化器被传递给两个参数，这两个参数声明了应该应用哪种优化（加速）技术，以及CAS应该采取哪些额外步骤来帮助提高评估期间的性能。

    template <int dim> 
    Magnetoviscoelastic_Constitutive_Law_SD<dim>:: 
      Magnetoviscoelastic_Constitutive_Law_SD( 
        const ConstitutiveParameters &               constitutive_parameters, 
        const Differentiation::SD::OptimizerType     optimizer_type, 
        const Differentiation::SD::OptimizationFlags optimization_flags) 
      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>( 
          constitutive_parameters) 
      , Q_t(Physics::Elasticity::StandardTensors<dim>::I) 
      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I) 
      , mu_e_sd("mu_e") 
      , mu_e_inf_sd("mu_e_inf") 
      , mu_e_h_sat_sd("mu_e_h_sat") 
      , lambda_e_sd("lambda_e") 
      , mu_v_sd("mu_v") 
      , mu_v_inf_sd("mu_v_inf") 
      , mu_v_h_sat_sd("mu_v_h_sat") 
      , tau_v_sd("tau_v") 
      , delta_t_sd("delta_t") 
      , mu_r_sd("mu_r") 
      , H_sd(Differentiation::SD::make_vector_of_symbols<dim>("H")) 
      , C_sd(Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("C")) 
      , Q_t_sd( 
          Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("Q_t")) 
      , Q_t1_sd( 
          Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("Q_t1")) 
      , optimizer(optimizer_type, optimization_flags) 
    { 
      initialize_optimizer(); 
    } 

// 替换图只是将以下所有数据配对在一起。

// - 构成参数（从基类中获取的值）。

// - 时间步长（从时间离散器中获取其值）。

// 场值（其值由调用该 @p Magnetoviscoelastic_Constitutive_Law_SD 实例的外部函数规定），以及

// 当前和之前的内部粘性变形（其值存储在这个类实例中）。

    template <int dim> 
    Differentiation::SD::types::substitution_map 
    Magnetoviscoelastic_Constitutive_Law_SD<dim>::make_substitution_map( 
      const SymmetricTensor<2, dim> &C, 
      const Tensor<1, dim> &         H, 
      const double                   delta_t) const 
    { 
      return Differentiation::SD::make_substitution_map( 
        std::make_pair(mu_e_sd, this->get_mu_e()), 
        std::make_pair(mu_e_inf_sd, this->get_mu_e_inf()), 
        std::make_pair(mu_e_h_sat_sd, this->get_mu_e_h_sat()), 
        std::make_pair(lambda_e_sd, this->get_lambda_e()), 
        std::make_pair(mu_v_sd, this->get_mu_v()), 
        std::make_pair(mu_v_inf_sd, this->get_mu_v_inf()), 
        std::make_pair(mu_v_h_sat_sd, this->get_mu_v_h_sat()), 
        std::make_pair(tau_v_sd, this->get_tau_v()), 
        std::make_pair(delta_t_sd, delta_t), 
        std::make_pair(mu_r_sd, this->get_mu_r()), 
        std::make_pair(H_sd, H), 
        std::make_pair(C_sd, C), 
        std::make_pair(Q_t_sd, Q_t), 
        std::make_pair(Q_t1_sd, Q_t1)); 
    } 

// 由于符号表达式的 "自然 "使用，配置 @p optimizer 的大部分过程看起来与构建自动区分帮助器的过程非常相似。尽管如此，我们还是要再次详细说明这些步骤，以强调这两个框架的不同之处。

// 该函数从符号化编码变形梯度行列式的表达式开始（用右Cauchy-Green变形张量表示，即我们的主要场变量），以及 $\mathbf{C}$ 本身的逆。

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::initialize_optimizer() 
    { 
      const Differentiation::SD::Expression det_F_sd = 
        std::sqrt(determinant(C_sd)); 
      const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_inv_sd = 
        invert(C_sd); 

// 接下来是自由能密度函数的弹性部分的饱和函数的符号表示，然后是自由能密度函数的磁弹性贡献。这一切都与我们之前看到的结构相同。

      const Differentiation::SD::Expression f_mu_e_sd = 
        1.0 + 
        (mu_e_inf_sd / mu_e_sd - 1.0) * 
          std::tanh((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd)); 

      const Differentiation::SD::Expression psi_ME_sd = 
        0.5 * mu_e_sd * f_mu_e_sd * 
          (trace(C_sd) - dim - 2.0 * std::log(det_F_sd)) + 
        lambda_e_sd * std::log(det_F_sd) * std::log(det_F_sd) - 
        0.5 * this->get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd); 

// 此外，我们还定义了自由能密度函数的磁-粘弹性贡献。实现这一点所需的第一个组件是一个缩放函数，它将使粘性剪切模量在磁场影响下发生变化（增加）（见 @cite Pelteret2018a  ，公式29）。此后，我们可以计算能量密度函数的耗散分量；其表达式见 @cite Pelteret2018a （公式28），这是对 @cite Linder2011a （公式46）中提出的能量密度函数的直接扩展。

      const Differentiation::SD::Expression f_mu_v_sd = 
        1.0 + 
        (mu_v_inf_sd / mu_v_sd - 1.0) * 
          std::tanh((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd)); 

      const Differentiation::SD::Expression psi_MVE_sd = 
        0.5 * mu_v_sd * f_mu_v_sd * 
        (Q_t_sd * (std::pow(det_F_sd, -2.0 / dim) * C_sd) - dim - 
         std::log(determinant(Q_t_sd))); 

// 从这些构件中，我们可以定义材料的总自由能密度函数。

      psi_sd = psi_ME_sd + psi_MVE_sd; 

// 目前，对中科院来说，变量 @p Q_t_sd 似乎是独立于 @p C_sd. 的，我们的张量符号表达式 @p Q_t_sd 只是有一个与之相关的标识符，没有任何东西将其与另一个张量符号表达式 @p C_sd. 联系起来。因此，相对于 @p C_sd 的任何导数将忽略这种内在的依赖关系，正如我们从进化规律可以看到的，实际上是 $\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)$  。这意味着，相对于 $\mathbf{C}$ 推导任何函数 $f = f(\mathbf{C}, \mathbf{Q})$ 将返回部分导数 $\frac{\partial f(\mathbf{C}, \mathbf{Q})}{\partial \mathbf{C}}
//  \Big\vert_{\mathbf{Q}}$ ，而不是总导数 $\frac{d f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}} =
//  \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial
//  \mathbf{C}} \Big\vert_{\mathbf{Q}} + \frac{\partial f(\mathbf{C},
//  \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{Q}}
//  \Big\vert_{\mathbf{C}} : \frac{d \mathbf{Q}(\mathbf{C}))}{d
//  \mathbf{C}}$  。

// 相比之下，在当前的AD库中，总导数将总是被返回。这意味着对于这类材料模型来说，计算出的动能变量是不正确的，这使得AD成为从能量密度函数中推导出（连续点水平）这种耗散性材料的构成法的不正确工具。

// 正是这种特定的控制水平描述了SD和AD框架之间的一个决定性差异。在几行中，我们将对内部变量 @p Q_t_sd 的表达式进行操作，使其产生正确的线性化。
//但是，
//首先，我们将计算动能变量的符号表达式，即磁感应向量和Piola-Kirchhoff应力张量。执行微分的代码相当接近于模仿理论中所述的定义。

      B_sd = -Differentiation::SD::differentiate(psi_sd, H_sd); 
      S_sd = 2.0 * Differentiation::SD::differentiate(psi_sd, C_sd); 

// 因为下一步是对上述内容进行线性化，所以现在是告知CAS  @p Q_t_sd  对  @p C_sd,  的明确依赖性的适当时机，即说明  $\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t\right)$  。这意味着未来所有关于 @p C_sd 的微分运算将考虑到这种依赖关系（即计算总导数）。换句话说，我们将转换一些表达式，使其内在参数化从 $f(\mathbf{C}, \mathbf{Q})$ 变为 $f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))$  .

// 为了做到这一点，我们考虑时间离散的演化规律。由此，我们有了内部变量在其历史上的明确表达，以及主要场变量。这就是它在这个表达式中描述的内容。

      const SymmetricTensor<2, dim, Differentiation::SD::Expression> 
        Q_t_sd_explicit = 
          (1.0 / (1.0 + delta_t_sd / tau_v_sd)) * 
          (Q_t1_sd + 
           (delta_t_sd / tau_v_sd * std::pow(det_F_sd, 2.0 / dim) * C_inv_sd)); 

// 接下来我们产生一个中间替换图，它将在一个表达式中找到 @p Q_t_sd （我们的标识符）的每个实例，并用 @p Q_t_sd_explicit. 中的完整表达式来替换它。
      const Differentiation::SD::types::substitution_map 
        substitution_map_explicit = Differentiation::SD::make_substitution_map( 
          std::make_pair(Q_t_sd, Q_t_sd_explicit)); 

// 我们可以在两个动力学变量上进行这种替换，并立即将替换后的结果与场变量进行区分。(如果你愿意，这可以分成两步进行，中间的结果储存在一个临时变量中)。同样，如果你忽略了代换所产生的 "复杂性"，这些将运动变量线性化并产生三个切向张量的调用与理论中所述的非常相似。

      BB_sd = symmetrize(Differentiation::SD::differentiate( 
        Differentiation::SD::substitute(B_sd, substitution_map_explicit), 
        H_sd)); 
      PP_sd = -Differentiation::SD::differentiate( 
        Differentiation::SD::substitute(S_sd, substitution_map_explicit), H_sd); 
      HH_sd = 
        2.0 * 
        Differentiation::SD::differentiate( 
          Differentiation::SD::substitute(S_sd, substitution_map_explicit), 
          C_sd); 

// 现在我们需要告诉 @p optimizer 我们需要提供哪些条目的数值，以便它能成功地进行计算。这些基本上充当了 @p optimizer 必须评估的所有从属函数的输入参数。它们统称为问题的自变量、历史变量、时间步长和构成参数（因为我们没有在能量密度函数中硬编码它们）。

// 因此，我们真正想要的是为它提供一个符号集合，我们可以这样完成。
// @code
//  optimizer.register_symbols(Differentiation::SD::make_symbol_map(
//    mu_e_sd, mu_e_inf_sd, mu_e_h_sat_sd, lambda_e_sd,
//    mu_v_sd, mu_v_inf_sd, mu_v_h_sat_sd, tau_v_sd,
//    delta_t_sd, mu_r_sd,
//    H_sd, C_sd,
//    Q_t_sd, Q_t1_sd));
//  @endcode 
//  但这实际上都已经被编码为替换图的键。这样做还意味着我们需要在两个地方（这里和构建替换图时）管理这些符号，这很烦人，而且如果这个材料类被修改或扩展，可能会出现错误。由于我们此时对数值不感兴趣，所以如果替换图中与每个键项相关的数值被填入无效的数据也没有关系。所以我们将简单地创建一个假的替换图，并从中提取符号。请注意，任何传递给 @p optimizer 的替换图都必须至少包含这些符号的条目。

      optimizer.register_symbols( 
        Differentiation::SD::Utilities::extract_symbols( 
          make_substitution_map({}, {}, 0))); 

// 然后我们通知优化器我们想要计算哪些数值，在我们的情况下，这包括所有的因变量（即能量密度函数及其各种导数）。

      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd); 

// 最后一步是最终确定优化器。通过这个调用，它将确定一个等价的代码路径，一次性评估所有的从属函数，但计算成本比直接评估符号表达式时要低。注意：这是一个昂贵的调用，所以我们希望尽可能少地执行它。我们在类的构造函数中完成了这一过程，实现了每个类实例只被调用一次的目标。

      optimizer.optimize(); 
    } 

// 由于 @p optimizer 的配置是在前面完成的，所以每次我们想计算动能变量或它们的线性化（导数）时，要做的事情就很少了。

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_internal_data( 
      const SymmetricTensor<2, dim> &C, 
      const Tensor<1, dim> &         H, 
      const DiscreteTime &           time) 
    { 

// 为了更新内部历史变量，我们首先需要计算一些基本量，这一点我们之前已经看到了。我们还可以向时间离散器询问用于从上一个时间步长迭代到当前时间步长的时间步长。

      const double delta_t = this->get_delta_t(time); 

      const double                  det_F = std::sqrt(determinant(C)); 
      const SymmetricTensor<2, dim> C_inv = invert(C); 
      AssertThrow(det_F > 0.0, 
                  ExcMessage("Volumetric Jacobian must be positive.")); 

// 现在，我们可以按照演化规律给出的定义，结合所选择的时间离散化方案，更新（实值）内部粘性变形张量。

      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) * 
            (Q_t1 + (delta_t / this->get_tau_v()) * std::pow(det_F, 2.0 / dim) * 
                      C_inv); 

// 接下来我们向优化器传递我们希望自变量、时间步长和（本调用隐含的）构成参数所代表的数值。

      const auto substitution_map = make_substitution_map(C, H, delta_t); 

// 在进行下一次调用时，用于（数值）评估从属函数的调用路径要比字典替换更快。

      optimizer.substitute(substitution_map); 
    } 

// 在调用了`update_internal_data()`之后，从优化器中提取数据就有效了。在进行评估时，我们需要从优化器中提取数据的确切符号表达式。这意味着我们需要在优化器的生命周期内存储所有因变量的符号表达式（自然，对输入变量也有同样的暗示）。

    template <int dim> 
    double Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_psi() const 
    { 
      return optimizer.evaluate(psi_sd); 
    } 

    template <int dim> 
    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_B() const 
    { 
      return optimizer.evaluate(B_sd); 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> 
    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_S() const 
    { 
      return optimizer.evaluate(S_sd); 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> 
    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_DD() const 
    { 
      return optimizer.evaluate(BB_sd); 
    } 

    template <int dim> 
    Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_PP() const 
    { 
      return optimizer.evaluate(PP_sd); 
    } 

    template <int dim> 
    SymmetricTensor<4, dim> 
    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_HH() const 
    { 
      return optimizer.evaluate(HH_sd); 
    } 

// 当在时间上向前移动时，内部变量的 "当前 "状态瞬间定义了 "前 "时间段的状态。因此，我们记录历史变量的值，作为下一个时间步长的 "过去值 "使用。

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_end_of_timestep() 
    { 
      Q_t1 = Q_t; 
    } 
// @sect3{A more complex example (continued): Parameters and hand-derived material classes}  

// 现在我们已经看到了AD和SD框架如何在定义这些构成法则方面做了大量的工作，为了验证，我们将手工实现相应的类，并对框架与本地实现做一些初步的基准测试。

// 为了保证作者的理智，下面记录的（希望是准确的）是动能变量和它们的切线的完整定义，以及一些中间计算过程。由于构成法则类的结构和设计已经在前面概述过了，我们将略过它，只是在 "update_internal_data() "方法的定义中对各阶段的计算进行划分。将导数计算（及其适度表达的变量名）与出现在类描述中的文档定义联系起来应该是很容易的。然而，我们将借此机会介绍两种实现构成法类的不同范式。第二种将比第一种提供更多的灵活性（从而使其更容易扩展，在作者看来），但要牺牲一些性能。

//  @sect4{Magnetoelastic constitutive law (hand-derived)}  

// 从前面提到的储存能量中，对于这种磁弹性材料，定义为
// @f[
//    \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//      \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F}))
//      \right]
//  + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right)
//  - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F})
//      \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//      \boldsymbol{\mathbb{H}} \right]
//  @f]
//  与
//  @f[
//   f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//  = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right]
//      \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//      \boldsymbol{\mathbb{H}}}
//        {\left(h_{e}^{\text{sat}}\right)^{2}} \right) ,
//  \\ \text{det}(\mathbf{F}) = \sqrt{\text{det}(\mathbf{C})}
//  @f]
//  ，对应于磁感应向量和总Piola-Kirchhoff应力张量的第一导数是
//  @f[
//   \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//   \right)
//  \dealcoloneq - \frac{d \psi_{0}}{d \boldsymbol{\mathbb{H}}}
//  = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln
//  (\text{det}(\mathbf{F}))
//        \right] \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}}
//        \right)}{d \boldsymbol{\mathbb{H}}}
//  + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}}
//      \right]
//  @f] 

// @f{align}
//   \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//   \right)
//  \dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C},
//  \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}}
//  &= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//      \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}}
//      - 2 \frac{1}{\text{det}(\mathbf{F})}
//      \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right]
//  + 4 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right)
//      \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d
//      \mathbf{C}}
//  - \mu_{0} \mu_{r} \left[
//      \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//      \boldsymbol{\mathbb{H}} \right] \frac{d\,\text{det}(\mathbf{F})}{d
//      \mathbf{C}} + \text{det}(\mathbf{F}) \frac{d \left[
//      \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//      \boldsymbol{\mathbb{H}}
//        \right]}{d \mathbf{C}} \right]
//  \\ &= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//      \left[ \mathbf{I} - \mathbf{C}^{-1} \right]
//  + 2 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \mathbf{C}^{-1}
//  - \mu_{0} \mu_{r} \left[
//      \frac{1}{2}  \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1}
//      \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F})
//      \mathbf{C}^{-1}
//  - \text{det}(\mathbf{F})
//      \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes
//        \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]
//        \right]
//  @f} 
//  与
//  @f[
//    \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d
//    \boldsymbol{\mathbb{H}}}
//  = \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right]
//    \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//    \boldsymbol{\mathbb{H}}}
//      {\left(h_{e}^{\text{sat}}\right)^{2}} \right)
//    \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}}
//    \boldsymbol{\mathbb{H}} \right]
//  @f] 。

// @f[
//    \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}}
//  = \mathbf{I}
//  \quad \text{(the second-order identity tensor)}
//  @f] 

// @f[
//    \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}}
//  = \frac{1}{2} \text{det}(\mathbf{F}) \mathbf{C}^{-1}
//  @f] 

// @f[
//  \frac{d C^{-1}_{ab}}{d C_{cd}}
//  = - \text{sym} \left( C^{-1}_{ac} C^{-1}_{bd} \right)
//  = -\frac{1}{2} \left[ C^{-1}_{ac} C^{-1}_{bd} + C^{-1}_{ad} C^{-1}_{bc}
//  \right]
//  @f] 

// @f[
//    \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//    \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}}
//  = - \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes
//    \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]
//  @f] 
//  在上面的一个推导中使用对称算子 $\text{sym} \left( \bullet \right)$ 有助于确保所产生的秩-4张量，由于 $\mathbf{C}$ 的对称性而持有小的对称性，仍然将秩-2对称张量映射为秩-2对称张量。参见SymmetricTensor类文档和 step-44 的介绍，并进一步解释在四阶张量的背景下对称性的含义。

//每个运动学变量相对于其参数的线性化是
// @f[
//  \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}}
//  = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln
//  (\text{det}(\mathbf{F}))
//      \right] \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}}
//      \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}}
//  + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \mathbf{C}^{-1}
//  @f] 

// @f{align}
//  \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//  \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}}
//  &= - \mu_{e}
//      \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}}
//      - 2 \frac{1}{\text{det}(\mathbf{F})}
//      \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right]
//        \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}}
//        \right)}}{d \boldsymbol{\mathbb{H}}}
//  + \mu_{0} \mu_{r} \left[
//      \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \otimes
//        \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//        \boldsymbol{\mathbb{H}}
//          \right]}{d \boldsymbol{\mathbb{H}}} \right]
//  + \text{det}(\mathbf{F})
//      \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1}
//      \cdot \boldsymbol{\mathbb{H}}
//        \right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}}
//  \\ &= - \mu_{e}
//      \left[ \mathbf{I} - \mathbf{C}^{-1} \right] \otimes
//        \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d
//        \boldsymbol{\mathbb{H}}}
//  + \mu_{0} \mu_{r} \left[
//      \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes
//        \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]
//        \right]
//  + \text{det}(\mathbf{F})
//      \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1}
//      \cdot \boldsymbol{\mathbb{H}}
//        \right]}{d \mathbf{C} \otimes \mathbf{C} \boldsymbol{\mathbb{H}}}
//  @f} 


// @f{align}
//  \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//  \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}}
//  &= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//      \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right]
//    + 4 \lambda_{e} \left[ \mathbf{C}^{-1} \otimes \left[
//    \frac{1}{\text{det}(\mathbf{F})} \frac{d \, \text{det}(\mathbf{F})}{d
//    \mathbf{C}} \right] + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d
//    \mathbf{C}^{-1}}{d \mathbf{C}} \right]
//  \\ &- \mu_{0} \mu_{r}  \left[
//   \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \frac{d \left[
//   \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//   \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}}
//  + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}} \right] \mathbf{C}^{-1} \otimes \frac{d \,
//  \text{det}(\mathbf{F})}{d \mathbf{C}}
//  + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d
//  \mathbf{C}^{-1}}{d \mathbf{C}}
//  \right]
//  \\ &+ 2 \mu_{0} \mu_{r} \left[ \left[
//      \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes
//        \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]
//        \right] \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}}
//      - \text{det}(\mathbf{F})
//      \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1}
//      \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d
//      \mathbf{C}}
//  \right]
//  \\ &= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)
//      \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right]
//   + 4 \lambda_{e} \left[ \frac{1}{2} \mathbf{C}^{-1} \otimes
//   \mathbf{C}^{-1} + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d
//   \mathbf{C}^{-1}}{d \mathbf{C}} \right]
//  \\ &- \mu_{0} \mu_{r}  \left[
//   - \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \left[
//   \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes
//    \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right]
//  + \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F})  \mathbf{C}^{-1}
//  \otimes \mathbf{C}^{-1}
//  + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d
//  \mathbf{C}^{-1}}{d \mathbf{C}}
//  \right]
//  \\ &+ 2 \mu_{0} \mu_{r} \left[ \frac{1}{2} \text{det}(\mathbf{F}) \left[
//      \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes
//        \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]
//        \right] \otimes \mathbf{C}^{-1}
//      - \text{det}(\mathbf{F})
//      \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1}
//      \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d
//      \mathbf{C}}
//  \right]
//  @f}
//  与
//  @f[
//   \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d
//   \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}}
//  = -2 \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right]
//    \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//    \boldsymbol{\mathbb{H}}}
//      {\left(h_{e}^{\text{sat}}\right)^{2}} \right)
//    \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//    \boldsymbol{\mathbb{H}}}
//      {\left(h_{e}^{\text{sat}}\right)^{2}} \right)
//    \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \mathbf{I}
//    \right]
//  @f] 

// @f[
//  \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}}
//          \right]}{d \boldsymbol{\mathbb{H}}}
//  = 2 \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}
//  @f] 

// @f[
//  \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d
//  \boldsymbol{\mathbb{H}}} \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e}
//  C^{-1}_{ef} \mathbb{H}_{f}
//        \right]}{d C_{ab} d \mathbb{H}_{c}}
//  = - C^{-1}_{ac} C^{-1}_{be} \mathbb{H}_{e} - C^{-1}_{ae} \mathbb{H}_{e}
//  C^{-1}_{bc}
//  @f] 

// @f{align}
//  \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//  \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}}
//  &= -\frac{d \left[\left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}
//  \right] \otimes
//        \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}
//        \right]\right]}{d \mathbf{C}}
//  \\ \Rightarrow
//  \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f}
//        \right]}{d C_{ab} d C_{cd}}
//  &= \text{sym} \left( C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf}
//  \mathbb{H}_{f} C^{-1}_{bd}
//            + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f}
//            C^{-1}_{ad} \right)
//  \\ &= \frac{1}{2} \left[
//       C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd}
//     + C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{bc}
//     + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad}
//     + C^{-1}_{be} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{ac}
//    \right]
//  @f}

// 好吧，很快就升级了--尽管 $\psi_{0}$ 和 $f_{\mu_e}$ 的定义可能已经给出了一些提示，说明计算动能场和它们的线性化需要一些努力，但最终的定义可能比最初想象的要复杂一些。了解了我们现在所做的，也许可以说我们真的不想计算这些函数相对于其参数的一、二次导数--不管我们在微积分课上做得如何，或者我们可能是多么好的程序员。

// 在最终实现这些的类方法定义中，我们以稍微不同的方式组成这些计算。一些中间步骤也被保留下来，以便从另一个角度说明如何系统地计算导数。此外，一些计算被分解得更少或更进一步，以重用一些中间值，并希望能帮助读者跟随导数的操作。

    template <int dim> 
    class Magnetoelastic_Constitutive_Law final 
      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim> 
    { 
    public: 
      Magnetoelastic_Constitutive_Law( 
        const ConstitutiveParameters &constitutive_parameters); 

      virtual void update_internal_data(const SymmetricTensor<2, dim> &C, 
                                        const Tensor<1, dim> &         H, 
                                        const DiscreteTime &) override; 

      virtual double get_psi() const override; 

      virtual Tensor<1, dim> get_B() const override; 

      virtual SymmetricTensor<2, dim> get_S() const override; 

      virtual SymmetricTensor<2, dim> get_DD() const override; 

      virtual Tensor<3, dim> get_PP() const override; 

      virtual SymmetricTensor<4, dim> get_HH() const override; 

    private: 
      double                  psi; 
      Tensor<1, dim>          B; 
      SymmetricTensor<2, dim> S; 
      SymmetricTensor<2, dim> BB; 
      Tensor<3, dim>          PP; 
      SymmetricTensor<4, dim> HH; 
    }; 

    template <int dim> 
    Magnetoelastic_Constitutive_Law<dim>::Magnetoelastic_Constitutive_Law( 
      const ConstitutiveParameters &constitutive_parameters) 
      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>( 
          constitutive_parameters) 
      , psi(0.0) 
    {} 

// 对于这个类的更新方法，我们将简单地预先计算一个中间值的集合（用于函数求值、导数计算等），并 "手动 "安排它们的顺序，以使其重复使用最大化。这意味着我们必须自己管理，并决定哪些值必须在其他值之前计算，同时保持代码本身的某种秩序或结构的模样。这很有效，但也许有点乏味。它对类的未来扩展也没有太大的帮助，因为所有这些值都是这个单一方法的局部。

// 有趣的是，这种预先计算在多个地方使用的中间表达式的基本技术有一个名字：[共同子表达式消除（CSE）]（https：en.wikipedia.org/wiki/Common_subexpression_elimination）。它是计算机代数系统在承担评估类似表达式的任务时用来减少计算费用的一种策略。

    template <int dim> 
    void Magnetoelastic_Constitutive_Law<dim>::update_internal_data( 
      const SymmetricTensor<2, dim> &C, 
      const Tensor<1, dim> &         H, 
      const DiscreteTime &) 
    { 
      const double                  det_F = std::sqrt(determinant(C)); 
      const SymmetricTensor<2, dim> C_inv = invert(C); 
      AssertThrow(det_F > 0.0, 
                  ExcMessage("Volumetric Jacobian must be positive.")); 

// 磁弹性能的饱和函数。

      const double two_h_dot_h_div_h_sat_squ = 
        (2.0 * H * H) / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()); 
      const double tanh_two_h_dot_h_div_h_sat_squ = 
        std::tanh(two_h_dot_h_div_h_sat_squ); 

      const double f_mu_e = 
        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) * 
                tanh_two_h_dot_h_div_h_sat_squ; 

// 饱和函数的一阶导数，注意到  $\frac{d \tanh(x)}{dx} = \text{sech}^{2}(x)$  。

      const double dtanh_two_h_dot_h_div_h_sat_squ = 
        std::pow(1.0 / std::cosh(two_h_dot_h_div_h_sat_squ), 2.0); 
      const Tensor<1, dim> dtwo_h_dot_h_div_h_sat_squ_dH = 
        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) * H; 

      const Tensor<1, dim> df_mu_e_dH = 
        (this->get_mu_e_inf() / this->get_mu_e() - 1.0) * 
        (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH); 

// 饱和度函数的二阶导数，注意  $\frac{d \text{sech}^{2}(x)}{dx} = -2 \tanh(x) \text{sech}^{2}(x)$  。

      const double d2tanh_two_h_dot_h_div_h_sat_squ = 
        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ; 
      const SymmetricTensor<2, dim> d2two_h_dot_h_div_h_sat_squ_dH_dH = 
        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) * 
        Physics::Elasticity::StandardTensors<dim>::I; 

      const SymmetricTensor<2, dim> d2f_mu_e_dH_dH = 
        (this->get_mu_e_inf() / this->get_mu_e() - 1.0) * 
        (d2tanh_two_h_dot_h_div_h_sat_squ * 
           symmetrize(outer_product(dtwo_h_dot_h_div_h_sat_squ_dH, 
                                    dtwo_h_dot_h_div_h_sat_squ_dH)) + 
         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH); 

// 从场/运动学变量中直接获得的一些中间量。

      const double         log_det_F         = std::log(det_F); 
      const double         tr_C              = trace(C); 
      const Tensor<1, dim> C_inv_dot_H       = C_inv * H; 
      const double         H_dot_C_inv_dot_H = H * C_inv_dot_H; 

// 中间量的一阶导数。

      const SymmetricTensor<2, dim> d_tr_C_dC = 
        Physics::Elasticity::StandardTensors<dim>::I; 
      const SymmetricTensor<2, dim> ddet_F_dC     = 0.5 * det_F * C_inv; 
      const SymmetricTensor<2, dim> dlog_det_F_dC = 0.5 * C_inv; 

      const Tensor<1, dim> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H; 

      SymmetricTensor<4, dim> dC_inv_dC; 
      for (unsigned int A = 0; A < dim; ++A) 
        for (unsigned int B = A; B < dim; ++B) 
          for (unsigned int C = 0; C < dim; ++C) 
            for (unsigned int D = C; D < dim; ++D) 
              dC_inv_dC[A][B][C][D] -=               // 
                0.5 * (C_inv[A][C] * C_inv[B][D]     // 
                       + C_inv[A][D] * C_inv[B][C]); // 

      const SymmetricTensor<2, dim> dH_dot_C_inv_dot_H_dC = 
        -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H)); 

// 中间量的二阶导数。

      const SymmetricTensor<4, dim> d2log_det_F_dC_dC = 0.5 * dC_inv_dC; 

      const SymmetricTensor<4, dim> d2det_F_dC_dC = 
        0.5 * (outer_product(C_inv, ddet_F_dC) + det_F * dC_inv_dC); 

      const SymmetricTensor<2, dim> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv; 

      Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH; 
      for (unsigned int A = 0; A < dim; ++A) 
        for (unsigned int B = 0; B < dim; ++B) 
          for (unsigned int C = 0; C < dim; ++C) 
            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -= 
              C_inv[A][C] * C_inv_dot_H[B] + // 
              C_inv_dot_H[A] * C_inv[B][C];  // 

      SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC; 
      for (unsigned int A = 0; A < dim; ++A) 
        for (unsigned int B = A; B < dim; ++B) 
          for (unsigned int C = 0; C < dim; ++C) 
            for (unsigned int D = C; D < dim; ++D) 
              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] += 
                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] + 
                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] + 
                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] + 
                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]); 

// 储存的能量密度函数。

      psi = 
        (0.5 * this->get_mu_e() * f_mu_e) * 
          (tr_C - dim - 2.0 * std::log(det_F)) + 
        this->get_lambda_e() * (std::log(det_F) * std::log(det_F)) - 
        (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H); 

// 动能量。

      B = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * 
            df_mu_e_dH // 
          + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F * 
              dH_dot_C_inv_dot_H_dH; // 

      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                        // 
            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              // 
          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) // 
          - 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *            // 
              (H_dot_C_inv_dot_H * ddet_F_dC                               // 
               + det_F * dH_dot_C_inv_dot_H_dC);                           // 

// 动能量的线性化。

      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * // 
             d2f_mu_e_dH_dH                                             // 
           + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F * 
               d2H_dot_C_inv_dot_H_dH_dH; // 

      PP = -2.0 * (0.5 * this->get_mu_e()) *                                  // 
             outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   // 
                           df_mu_e_dH)                                        // 
           +                                                                  // 
           2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                // 
             (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) // 
              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           // 

      HH = 
        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) // 
        + 4.0 * this->get_lambda_e() *                                       // 
            (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               // 
             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          // 
        - 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                // 
            (H_dot_C_inv_dot_H * d2det_F_dC_dC                               // 
             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               // 
             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               // 
             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           // 
    } 

    template <int dim> 
    double Magnetoelastic_Constitutive_Law<dim>::get_psi() const 
    { 
      return psi; 
    } 

    template <int dim> 
    Tensor<1, dim> Magnetoelastic_Constitutive_Law<dim>::get_B() const 
    { 
      return B; 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_S() const 
    { 
      return S; 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_DD() const 
    { 
      return BB; 
    } 

    template <int dim> 
    Tensor<3, dim> Magnetoelastic_Constitutive_Law<dim>::get_PP() const 
    { 
      return PP; 
    } 

    template <int dim> 
    SymmetricTensor<4, dim> Magnetoelastic_Constitutive_Law<dim>::get_HH() const 
    { 
      return HH; 
    } 
// @sect4{Magneto-viscoelastic constitutive law (hand-derived)}  

// 如前所述，我们将考虑的具有一种耗散机制的磁涡流材料的自由能密度函数定义为 
// @f[
//    \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}}
//    \right)
//  = \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)
//  @f] 。

// @f[
//    \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  = \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}}
//  \right)
//      \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F}))
//      \right]
//  + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right)
//  - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F})
//      \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot
//      \boldsymbol{\mathbb{H}} \right]
//  @f] 

// @f[
//    \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//    \boldsymbol{\mathbb{H}} \right)
//  = \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//  \right)
//      \left[ \mathbf{C}_{v} : \left[
//        \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//        \mathbf{C} \right] - d - \ln\left(
//        \text{det}\left(\mathbf{C}_{v}\right) \right)  \right]
//  @f]
//  与
//  @f[
//    f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right)
//  = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right]
//      \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//      \boldsymbol{\mathbb{H}}}
//        {\left(h_{e}^{\text{sat}}\right)^{2}} \right)
//  @f]
// 
// @f[
//    f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right)
//  = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right]
//      \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot
//      \boldsymbol{\mathbb{H}}}
//        {\left(h_{v}^{\text{sat}}\right)^{2}} \right)
//  @f]
//  和演变规律
//  @f[
//   \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right)
//  = \frac{1}{\tau} \left[
//        \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//          \mathbf{C}\right]^{-1}
//      - \mathbf{C}_{v} \right]
//  @f] ，
//  其本身是以 $\mathbf{C}$ 为参数的。根据设计，能量 $\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)$ 的磁弹性部分与前面介绍的磁弹性材料的磁弹性部分是相同的。因此，对于源于这部分能量的各种贡献的导数，请参考前面的章节。我们将继续强调来自这些条款的具体贡献，用 $ME$ 对突出的条款进行上标，而来自磁弹性部分的贡献则用 $MVE$ 上标。此外，阻尼项的磁饱和函数 $f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right)$ 具有与弹性项相同的形式（即 $f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right)$ ），因此其导数的结构与之前看到的相同；唯一的变化是三个构成参数，现在与粘性剪切模量 $\mu_{v}$ 而非弹性剪切模量 $\mu_{e}$ 相关。

// 对于这种磁-粘弹性材料，对应于磁感应矢量和Piola-Kirchhoff总应力张量的第一导数是
// @f[
//   \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v},
//   \boldsymbol{\mathbb{H}} \right)
//  \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}}
//  \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} \equiv
//  \boldsymbol{\mathbb{B}}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//  \right)
//  + \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) =  - \frac{d \psi_{0}^{ME} \left(
//  \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}}
//     - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//     \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}}
//  @f] 

// @f[
//   \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v},
//   \boldsymbol{\mathbb{H}} \right)
//  \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}}
//  \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} \equiv
//  \mathbf{S}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//  \right)
//  + \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}}
//      \right)
//  =  2 \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}}
//  \right)}{d \mathbf{C}}
//   + 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//   \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}}
//  @f]
//  ，其中粘性贡献为
//  @f[
//    \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//    \boldsymbol{\mathbb{H}} \right)
//  = - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}}
//  \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} = - \frac{1}{2} \mu_{v}
//      \left[ \mathbf{C}_{v} : \left[
//        \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//        \mathbf{C} \right] - d - \ln\left(
//        \text{det}\left(\mathbf{C}_{v}\right) \right)  \right]
//        \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//        \right)}{\partial \boldsymbol{\mathbb{H}}}
//  @f] 

// @f[
//    \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//    \boldsymbol{\mathbb{H}}
//      \right)
//  = 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}}
//  \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} = \mu_{v}
//  f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)
//         \left[  \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ -
//         \frac{1}{d}
//         \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//         \mathbf{C}^{-1} \right]
//         + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//         \mathbf{C}_{v}
//   \right]
//  @f]
//  和
//  @f[
//  \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//  \right)}{\partial \boldsymbol{\mathbb{H}}} \equiv \frac{d
//  f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d
//  \boldsymbol{\mathbb{H}}} .
//  @f] 
//  时间微缩的演化规律，
//  @f[
//  \mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right)
//  = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[
//      \mathbf{C}_{v}^{(t-1)}
//    + \frac{\Delta t}{\tau_{v}}
//      \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//      \mathbf{C} \right]^{-1}
//    \right]
//  @f]
//  也将决定内部变量相对于场变量的线性化是如何构成的。

// 注意，为了获得这种耗散材料的磁感应矢量和总Piola-Kirchhoff应力张量的*正确表达式，我们必须严格遵守应用Coleman-Noll程序的结果：我们必须取*部分导数*。
//自由能密度函数与场变量的关系。(对于我们的非耗散性磁弹性材料，取部分导数或全部导数都会有同样的结果，所以之前没有必要提请大家注意这一点)。操作的关键部分是冻结内部变量 $\mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right)$ ，同时计算 $\psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v} \left( \mathbf{C} \right), \boldsymbol{\mathbb{H}} \right)$ 相对于 $\mathbf{C}$ 的导数-- $\mathbf{C}_{v}^{(t)}$ 对 $\mathbf{C}$ 的依赖性不被考虑。当决定是使用AD还是SD来执行这个任务时，选择是很清楚的--只有符号框架提供了一个机制来完成这个任务；如前所述，AD只能返回总导数，所以它不适合这个任务。

// 为了对事情进行总结，我们将介绍这种速度依赖性耦合材料的材料切线。两个动能变量相对于其参数的线性化是 
// @f[
//  \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}}
//  \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}}
//  \equiv \mathbb{D}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  + \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}^{ME}}{d
//  \boldsymbol{\mathbb{H}}}
//  + \frac{d \boldsymbol{\mathbb{B}}^{MVE}}{d \boldsymbol{\mathbb{H}}}
//  @f] 
// 
// @f[
//  \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d
//  \boldsymbol{\mathbb{H}}} \equiv \mathfrak{P}^{\text{tot}, ME} \left(
//  \mathbf{C}, \boldsymbol{\mathbb{H}} \right)
//  + \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot},
//  ME}}{d \boldsymbol{\mathbb{H}}}
//  - \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \boldsymbol{\mathbb{H}}}
//  @f] 
// 
// @f[
//  \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d
//  \mathbf{C}} \equiv \mathcal{H}^{\text{tot}, ME} \left( \mathbf{C},
//  \boldsymbol{\mathbb{H}} \right)
//  + \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot},
//  ME}}{d \mathbf{C}}
//  + 2 \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \mathbf{C}}
//  @f] 
//  其中粘性贡献的切线为
//  @f[
//  \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = - \frac{1}{2} \mu_{v}
//      \left[ \mathbf{C}_{v} : \left[
//        \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//        \mathbf{C} \right] - d - \ln\left(
//        \text{det}\left(\mathbf{C}_{v}\right) \right)  \right]
//        \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//        \right)}{\partial \boldsymbol{\mathbb{H}} \otimes
//        d \boldsymbol{\mathbb{H}}}
//  @f] 
// 
// @f[
//  \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right) = - \mu_{v}
//         \left[  \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ -
//         \frac{1}{d}
//         \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//         \mathbf{C}^{-1} \right]
//         + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//         \mathbf{C}_{v}
//   \right] \otimes \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//   \right)}{d \boldsymbol{\mathbb{H}}}
//  @f] 
// 
// @f{align}
//  \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v},
//  \boldsymbol{\mathbb{H}} \right)
//  &= 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)
//    \left[ - \frac{1}{d}
//    \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//    \mathbf{C}^{-1} \right] \otimes
//    \left[ \mathbf{C}_{v} + \mathbf{C} : \frac{d \mathbf{C}_{v}}{d
//    \mathbf{C}} \right]
//  \\ &+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)
//  \left[ \mathbf{C}_{v} : \mathbf{C} \right]
//    \left[
//      \frac{1}{d^{2}}
//      \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//      \mathbf{C}^{-1} \otimes \mathbf{C}^{-1}
//      - \frac{1}{d}
//      \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d
//      \mathbf{C}^{-1}}{d \mathbf{C}}
//    \right]
//  \\ &+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)
//    \left[
//      -\frac{1}{d}
//      \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//      \mathbf{C}_{v} \otimes \mathbf{C}^{-1}
//      + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}}
//      \frac{d \mathbf{C}_{v}}{d \mathbf{C}}
//    \right]
//  @f}
//  与
//  @f[
//  \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}}
//  \right)}{\partial \boldsymbol{\mathbb{H}} \otimes
//  d \boldsymbol{\mathbb{H}}} \equiv \frac{d^{2} f_{\mu_{v}^{MVE}} \left(
//  \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d
//  \boldsymbol{\mathbb{H}}}
//  @f]
//  ，从演化定律来看，
//  @f[
//  \frac{d \mathbf{C}_{v}}{d \mathbf{C}}
//  \equiv \frac{d \mathbf{C}_{v}^{(t)}}{d \mathbf{C}}
//   = \frac{\frac{\Delta t}{\tau_{v}} }{1 + \frac{\Delta t}{\tau_{v}}}
//   \left[
//      \frac{1}{d}
//      \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}}
//      \mathbf{C}^{-1} \otimes \mathbf{C}^{-1}
//     + \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \frac{d
//     \mathbf{C}^{-1}}{d \mathbf{C}}
//    \right] .
//  @f]
//  注意，只是 $\mathcal{H}^{\text{tot}, MVE}$ 的最后一项包含内部变量的切线。这个特殊演化规律的线性化是线性的。关于非线性演化定律的例子，这种线性化必须以迭代的方式求解，见 @cite Koprowski  -Theiss2011a。

    template <int dim> 
    class Magnetoviscoelastic_Constitutive_Law final 
      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim> 
    { 
    public: 
      Magnetoviscoelastic_Constitutive_Law( 
        const ConstitutiveParameters &constitutive_parameters); 

      virtual void update_internal_data(const SymmetricTensor<2, dim> &C, 
                                        const Tensor<1, dim> &         H, 
                                        const DiscreteTime &time) override; 

      virtual double get_psi() const override; 

      virtual Tensor<1, dim> get_B() const override; 

      virtual SymmetricTensor<2, dim> get_S() const override; 

      virtual SymmetricTensor<2, dim> get_DD() const override; 

      virtual Tensor<3, dim> get_PP() const override; 

      virtual SymmetricTensor<4, dim> get_HH() const override; 

      virtual void update_end_of_timestep() override; 

    private: 
      SymmetricTensor<2, dim> Q_t; 
      SymmetricTensor<2, dim> Q_t1; 

      double                  psi; 
      Tensor<1, dim>          B; 
      SymmetricTensor<2, dim> S; 
      SymmetricTensor<2, dim> BB; 
      Tensor<3, dim>          PP; 
      SymmetricTensor<4, dim> HH; 

// 一个用于存储所有中间计算的数据结构。我们很快就会准确地看到如何利用这一点来使我们实际进行计算的那部分代码变得干净和容易（好吧，至少是更容易）遵循和维护。但是现在，我们可以说，它将允许我们把计算中间量的导数的那部分代码从使用它们的地方移开。

      mutable GeneralDataStorage cache; 

// 接下来的两个函数是用来更新场和内部变量的状态的，在我们进行任何详细的计算之前会被调用。

      void set_primary_variables(const SymmetricTensor<2, dim> &C, 
                                 const Tensor<1, dim> &         H) const; 

      void update_internal_variable(const DiscreteTime &time); 

// 该类接口的其余部分专门用于计算自由能密度函数及其所有导数所需的组件的方法。

// 运动学变量，或称场变量。

      const Tensor<1, dim> &get_H() const; 

      const SymmetricTensor<2, dim> &get_C() const; 

// 饱和度函数的一般化表述，所需的构成参数作为参数传递给每个函数。

      double get_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const; 

      double get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const; 

      double get_f_mu(const double mu, 
                      const double mu_inf, 
                      const double mu_h_sat) const; 

// 饱和度函数一阶导数的一般化表述，所需的构成参数作为参数传递给每个函数。

      double get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const; 

      Tensor<1, dim> 
      get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const; 

      Tensor<1, dim> get_df_mu_dH(const double mu, 
                                  const double mu_inf, 
                                  const double mu_h_sat) const; 

// 饱和度函数二阶导数的广义公式，所需的构成参数作为参数传递给每个函数。

      double get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const; 

      SymmetricTensor<2, dim> 
      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const; 

      SymmetricTensor<2, dim> get_d2f_mu_dH_dH(const double mu, 
                                               const double mu_inf, 
                                               const double mu_h_sat) const; 

// 从场/运动学变量中直接获得的中间量。

      const double &get_det_F() const; 

      const SymmetricTensor<2, dim> &get_C_inv() const; 

      const double &get_log_det_F() const; 

 

      const Tensor<1, dim> &get_C_inv_dot_H() const; 

 

// 中间量的一阶导数。

      const SymmetricTensor<4, dim> &get_dC_inv_dC() const; 

      const SymmetricTensor<2, dim> &get_d_tr_C_dC() const; 

      const SymmetricTensor<2, dim> &get_ddet_F_dC() const; 

      const SymmetricTensor<2, dim> &get_dlog_det_F_dC() const; 

 

 

// 内部变量相对于场变量的导数。注意，我们只需要内部变量的这个导数，因为这个变量只是作为动力学变量线性化的一部分而被微分。

      const SymmetricTensor<4, dim> & 
      get_dQ_t_dC(const DiscreteTime &time) const; 

// 中间量的二阶导数。

      const SymmetricTensor<4, dim> &get_d2log_det_F_dC_dC() const; 

      const SymmetricTensor<4, dim> &get_d2det_F_dC_dC() const; 

 

      const Tensor<3, dim> &get_d2H_dot_C_inv_dot_H_dC_dH() const; 

      const SymmetricTensor<4, dim> &get_d2H_dot_C_inv_dot_H_dC_dC() const; 
    }; 

    template <int dim> 
    Magnetoviscoelastic_Constitutive_Law< 
      dim>::Magnetoviscoelastic_Constitutive_Law(const ConstitutiveParameters 
                                                   &constitutive_parameters) 
      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>( 
          constitutive_parameters) 
      , Q_t(Physics::Elasticity::StandardTensors<dim>::I) 
      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I) 
      , psi(0.0) 
    {} 

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_data( 
      const SymmetricTensor<2, dim> &C, 
      const Tensor<1, dim> &         H, 
      const DiscreteTime &           time) 
    { 

// 记录应用的变形状态以及磁载荷。此后，根据新的变形状态更新内部（粘性）变量。

      set_primary_variables(C, H); 
      update_internal_variable(time); 

// 根据当前磁场获取弹性和粘性饱和函数的值...

 
                                     this->get_mu_e_inf(), 
                                     this->get_mu_e_h_sat()); 

      const double f_mu_v = get_f_mu(this->get_mu_v(), 
                                     this->get_mu_v_inf(), 
                                     this->get_mu_v_h_sat()); 

// ... 以及它们的一阶导数...

      const Tensor<1, dim> df_mu_e_dH = get_df_mu_dH(this->get_mu_e(), 
                                                     this->get_mu_e_inf(), 
                                                     this->get_mu_e_h_sat()); 

      const Tensor<1, dim> df_mu_v_dH = get_df_mu_dH(this->get_mu_v(), 
                                                     this->get_mu_v_inf(), 
                                                     this->get_mu_v_h_sat()); 

// ...以及它们的二阶导数。

      const SymmetricTensor<2, dim> d2f_mu_e_dH_dH = 
        get_d2f_mu_dH_dH(this->get_mu_e(), 
                         this->get_mu_e_inf(), 
                         this->get_mu_e_h_sat()); 

      const SymmetricTensor<2, dim> d2f_mu_v_dH_dH = 
        get_d2f_mu_dH_dH(this->get_mu_v(), 
                         this->get_mu_v_inf(), 
                         this->get_mu_v_h_sat()); 

// 中间量。请注意，由于我们是从一个缓存中获取这些值，而这个缓存的寿命比这个函数调用的寿命长，所以我们可以对结果进行别名，而不是从缓存中复制这个值。

      const double &                 det_F = get_det_F(); 
      const SymmetricTensor<2, dim> &C_inv = get_C_inv(); 

      const double &log_det_F         = get_log_det_F(); 
      const double &tr_C              = get_trace_C(); 
      const double &H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H(); 

// 中间值的第一导数，以及内部变量相对于右Cauchy-Green变形张量的那部分。

      const SymmetricTensor<2, dim> &d_tr_C_dC     = get_d_tr_C_dC(); 
      const SymmetricTensor<2, dim> &ddet_F_dC     = get_ddet_F_dC(); 
      const SymmetricTensor<2, dim> &dlog_det_F_dC = get_dlog_det_F_dC(); 

      const SymmetricTensor<4, dim> &dQ_t_dC = get_dQ_t_dC(time); 

      const Tensor<1, dim> &dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH(); 

      const SymmetricTensor<2, dim> &dH_dot_C_inv_dot_H_dC = 
        get_dH_dot_C_inv_dot_H_dC(); 

// 中间值的二阶导数。

      const SymmetricTensor<4, dim> &d2log_det_F_dC_dC = 
        get_d2log_det_F_dC_dC(); 

      const SymmetricTensor<4, dim> &d2det_F_dC_dC = get_d2det_F_dC_dC(); 

      const SymmetricTensor<2, dim> &d2H_dot_C_inv_dot_H_dH_dH = 
        get_d2H_dot_C_inv_dot_H_dH_dH(); 

      const Tensor<3, dim> &d2H_dot_C_inv_dot_H_dC_dH = 
        get_d2H_dot_C_inv_dot_H_dC_dH(); 

      const SymmetricTensor<4, dim> &d2H_dot_C_inv_dot_H_dC_dC = 
        get_d2H_dot_C_inv_dot_H_dC_dC(); 

// 由于线性化的定义变得特别冗长，我们将把自由能密度函数分解成三个相加的部分。

// --类似 "新胡克 "的项。

// -- 与速度有关的项，以及

// --类似于储存在磁场中的能量的项。

// 为了保持一致，这些贡献中的每一个都将被单独加入到我们想要计算的变量中，其顺序也是如此。

// 所以，首先这是能量密度函数本身。

      psi = (0.5 * this->get_mu_e() * f_mu_e) * 
              (tr_C - dim - 2.0 * std::log(det_F)) + 
            this->get_lambda_e() * (std::log(det_F) * std::log(det_F)); 
      psi += (0.5 * this->get_mu_v() * f_mu_v) * 
             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim - 
              std::log(determinant(Q_t))); 
      psi -= 
        (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H); 

// ...然后是磁感应强度和Piola-Kirchhoff应力。

      B = 
        -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH; 
      B -= (0.5 * this->get_mu_v()) * 
           (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim - 
            std::log(determinant(Q_t))) * 
           df_mu_v_dH; 
      B += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F * 
           dH_dot_C_inv_dot_H_dH; 

      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                         // 
            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               // 
          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); // 
      S += 2.0 * (0.5 * this->get_mu_v() * f_mu_v) * 
           ((Q_t * C) * 
              ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) + 
            std::pow(det_F, -2.0 / dim) * Q_t);                // dC/dC = II 
      S -= 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * // 
           (H_dot_C_inv_dot_H * ddet_F_dC                      // 
            + det_F * dH_dot_C_inv_dot_H_dC);                  // 

// ...... 最后是由于动能变量的线性化而产生的切线。

      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * 
           d2f_mu_e_dH_dH; 
      BB -= (0.5 * this->get_mu_v()) * 
            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim - 
             std::log(determinant(Q_t))) * 
            d2f_mu_v_dH_dH; 
      BB += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F * 
            d2H_dot_C_inv_dot_H_dH_dH; 

      PP = -2.0 * (0.5 * this->get_mu_e()) * 
           outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC), 
                         df_mu_e_dH); 
      PP -= 2.0 * (0.5 * this->get_mu_v()) * 
            outer_product(Tensor<2, dim>((Q_t * C) * 
                                           ((-2.0 / dim) * 
                                            std::pow(det_F, -2.0 / dim - 1.0) * 
                                            ddet_F_dC) + 
                                         std::pow(det_F, -2.0 / dim) * Q_t), 
                          df_mu_v_dH); 
      PP += 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * 
            (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) + 
             det_F * d2H_dot_C_inv_dot_H_dC_dH); 

      HH = 
        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) // 
        + 4.0 * this->get_lambda_e() *                                       // 
            (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               // 
             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         // 
      HH += 4.0 * (0.5 * this->get_mu_v() * f_mu_v) * 
            (outer_product((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * 
                             ddet_F_dC, 
                           C * dQ_t_dC + Q_t) + 
             (Q_t * C) * 
               (outer_product(ddet_F_dC, 
                              (-2.0 / dim) * (-2.0 / dim - 1.0) * 
                                std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) + 
                ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * 
                 d2det_F_dC_dC)) + 
             outer_product(Q_t, 
                           (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * 
                             ddet_F_dC) + 
             std::pow(det_F, -2.0 / dim) * dQ_t_dC); 
      HH -= 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * // 
            (H_dot_C_inv_dot_H * d2det_F_dC_dC                  // 
             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  // 
             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  // 
             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              // 

// 现在我们已经用完了存储在缓存中的所有临时变量，我们可以把它清除掉，以释放一些内存。

      cache.reset(); 
    } 

    template <int dim> 
    double Magnetoviscoelastic_Constitutive_Law<dim>::get_psi() const 
    { 
      return psi; 
    } 

    template <int dim> 
    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_B() const 
    { 
      return B; 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_S() const 
    { 
      return S; 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_DD() const 
    { 
      return BB; 
    } 

    template <int dim> 
    Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_PP() const 
    { 
      return PP; 
    } 

    template <int dim> 
    SymmetricTensor<4, dim> 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_HH() const 
    { 
      return HH; 
    } 

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law<dim>::update_end_of_timestep() 
    { 
      Q_t1 = Q_t; 
    } 

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_variable( 
      const DiscreteTime &time) 
    { 
      const double delta_t = this->get_delta_t(time); 

      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) * 
            (Q_t1 + (delta_t / this->get_tau_v()) * 
                      std::pow(get_det_F(), 2.0 / dim) * get_C_inv()); 
    } 

// 接下来的几个函数实现了饱和度函数的广义表述，以及它的各种导数。

    template <int dim> 
    double 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_two_h_dot_h_div_h_sat_squ( 
      const double mu_h_sat) const 
    { 
      const Tensor<1, dim> &H = get_H(); 
      return (2.0 * H * H) / (mu_h_sat * mu_h_sat); 
    } 

    template <int dim> 
    double Magnetoviscoelastic_Constitutive_Law< 
      dim>::get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const 
    { 
      return std::tanh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)); 
    } 

// 一个比例函数，它将使剪切模量在磁场的影响下发生变化（增加）。

 
    double Magnetoviscoelastic_Constitutive_Law<dim>::get_f_mu( 
      const double mu, 
      const double mu_inf, 
      const double mu_h_sat) const 
    { 
      return 1.0 + 
             (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat); 
    } 

// 缩放函数的一阶导数

    template <int dim> 
    double Magnetoviscoelastic_Constitutive_Law< 
      dim>::get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const 
    { 
      return std::pow(1.0 / std::cosh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)), 
                      2.0); 
    } 

    template <int dim> 
    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law< 
      dim>::get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const 
    { 
      return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H(); 
    } 

    template <int dim> 
    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_df_mu_dH( 
      const double mu, 
      const double mu_inf, 
      const double mu_h_sat) const 
  template <int dim> 
      return (mu_inf / mu - 1.0) * 
             (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) * 
              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat)); 
    } 

    template <int dim> 
    double Magnetoviscoelastic_Constitutive_Law< 
      dim>::get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const 
    { 
      return -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) * 
             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat); 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> Magnetoviscoelastic_Constitutive_Law< 
      dim>::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const 
    { 
      return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * 
             Physics::Elasticity::StandardTensors<dim>::I; 
    } 

    template <int dim> 
    SymmetricTensor<2, dim> 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2f_mu_dH_dH( 
      const double mu, 
      const double mu_inf, 
      const double mu_h_sat) const 
    { 
      return (mu_inf / mu - 1.0) * 
             (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) * 
                symmetrize( 
                  outer_product(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat), 
                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) + 
              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) * 
                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat)); 
    } 

// 对于我们为这个材料类采用的缓存计算方法，所有计算的根基是场变量，以及不可改变的辅助数据，如构成参数和时间步长。因此，我们需要以与其他变量不同的方式将它们输入缓存，因为它们是由类本身之外规定的输入。这个函数只是将它们从输入参数中直接添加到缓存中，同时检查那里是否有等效的数据（我们希望每个时间步长或牛顿迭代只调用一次`update_internal_data()`方法）。

    template <int dim> 
    void Magnetoviscoelastic_Constitutive_Law<dim>::set_primary_variables( 
      const SymmetricTensor<2, dim> &C, 
      const Tensor<1, dim> &         H) const 
    { 

// 设置  $\boldsymbol{\mathbb{H}}$  的值。

      const std::string name_H("H"); 
      Assert(!cache.stores_object_with_name(name_H), 
             ExcMessage( 
               "The primary variable has already been added to the cache.")); 
      cache.add_unique_copy(name_H, H); 

// 设置  $\mathbf{C}$  的值。

      const std::string name_C("C"); 
      Assert(!cache.stores_object_with_name(name_C), 
             ExcMessage( 
               "The primary variable has already been added to the cache.")); 
      cache.add_unique_copy(name_C, C); 
    } 

// 此后，我们可以在任何时间点从缓存中获取它们。

    template <int dim> 
    const Tensor<1, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_H() const 
    { 
      const std::string name("H"); 
      Assert(cache.stores_object_with_name(name), 
             ExcMessage("Primary variables must be added to the cache.")); 
      return cache.template get_object_with_name<Tensor<1, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_C() const 
    { 
      const std::string name("C"); 
      Assert(cache.stores_object_with_name(name), 
             ExcMessage("Primary variables must be added to the cache.")); 
      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

// 当我们需要主要变量时，保证它们在缓存中，我们不能从它们中计算出所有的中间值（无论是直接，还是间接）。

// 如果缓存中还没有存储我们要找的值，那么我们就快速计算，把它存储在缓存中，然后返回刚刚存储在缓存中的值。这样我们就可以把它作为一个引用返回，避免复制对象。同样的道理也适用于复合函数可能依赖的任何值。换句话说，如果在我们目前感兴趣的计算之前有一个依赖链，那么在我们继续使用这些值之前，我们可以保证解决这些依赖关系。尽管从缓存中获取数据是有成本的，但 "已解决的依赖关系 "的概念可能足够方便，使其值得看一下这个额外的成本。如果这些材料定律被嵌入到有限元框架中，那么额外的成本甚至可能不会被注意到。

    template <int dim> 
    const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_det_F() const 
    { 
      const std::string name("det_F"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          const double det_F = std::sqrt(determinant(get_C())); 
          AssertThrow(det_F > 0.0, 
                      ExcMessage("Volumetric Jacobian must be positive.")); 
          cache.add_unique_copy(name, det_F); 
        } 

      return cache.template get_object_with_name<double>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv() const 
    { 
      const std::string name("C_inv"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          cache.add_unique_copy(name, invert(get_C())); 
        } 

      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

    template <int dim> 
    const double & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_log_det_F() const 
    { 
      const std::string name("log(det_F)"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, std::log(get_det_F())); 

      return cache.template get_object_with_name<double>(name); 
    } 

    template <int dim> 
    const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_trace_C() const 
    { 
      const std::string name("trace(C)"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, trace(get_C())); 

      return cache.template get_object_with_name<double>(name); 
    } 

    template <int dim> 
    const Tensor<1, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv_dot_H() const 
    { 
      const std::string name("C_inv_dot_H"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, get_C_inv() * get_H()); 

      return cache.template get_object_with_name<Tensor<1, dim>>(name); 
    } 

    template <int dim> 
    const double & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_H_dot_C_inv_dot_H() const 
    { 
      const std::string name("H_dot_C_inv_dot_H"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H()); 

      return cache.template get_object_with_name<double>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<4, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_dQ_t_dC( 
      const DiscreteTime &time) const 
    { 
      const std::string name("dQ_t_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          const double  delta_t = this->get_delta_t(time); 
          const double &det_F   = get_det_F(); 

          const SymmetricTensor<4, dim> dQ_t_dC = 
            (1.0 / (1.0 + delta_t / this->get_tau_v())) * 
            (delta_t / this->get_tau_v()) * 
            ((2.0 / dim) * std::pow(det_F, 2.0 / dim - 1.0) * 
               outer_product(get_C_inv(), get_ddet_F_dC()) + 
             std::pow(det_F, 2.0 / dim) * get_dC_inv_dC()); 

          cache.add_unique_copy(name, dQ_t_dC); 
        } 

      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<4, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_dC_inv_dC() const 
    { 
      const std::string name("dC_inv_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          const SymmetricTensor<2, dim> &C_inv = get_C_inv(); 
          SymmetricTensor<4, dim>        dC_inv_dC; 

          for (unsigned int A = 0; A < dim; ++A) 
            for (unsigned int B = A; B < dim; ++B) 
              for (unsigned int C = 0; C < dim; ++C) 
                for (unsigned int D = C; D < dim; ++D) 
                  dC_inv_dC[A][B][C][D] -=               // 
                    0.5 * (C_inv[A][C] * C_inv[B][D]     // 
                           + C_inv[A][D] * C_inv[B][C]); // 

          cache.add_unique_copy(name, dC_inv_dC); 
        } 

      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d_tr_C_dC() const 
    { 
      const std::string name("d_tr_C_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 
                              Physics::Elasticity::StandardTensors<dim>::I); 

      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_ddet_F_dC() const 
    { 
      const std::string name("ddet_F_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv()); 

      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_dlog_det_F_dC() const 
    { 
      const std::string name("dlog_det_F_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 0.5 * get_C_inv()); 

      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

    template <int dim> 
    const Tensor<1, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dH() const 
    { 
      const std::string name("dH_dot_C_inv_dot_H_dH"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H()); 

      return cache.template get_object_with_name<Tensor<1, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dC() const 
    { 
      const std::string name("dH_dot_C_inv_dot_H_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          const Tensor<1, dim> C_inv_dot_H = get_C_inv_dot_H(); 
          cache.add_unique_copy( 
            name, -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H))); 
        } 

      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<4, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2log_det_F_dC_dC() const 
    { 
      const std::string name("d2log_det_F_dC_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC()); 

      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<4, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2det_F_dC_dC() const 
    { 
      const std::string name("d2det_F_dC_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 
                              0.5 * 
                                (outer_product(get_C_inv(), get_ddet_F_dC()) + 
                                 get_det_F() * get_dC_inv_dC())); 

      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<2, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dH_dH() 
      const 
    { 
      const std::string name("d2H_dot_C_inv_dot_H_dH_dH"); 
      if (cache.stores_object_with_name(name) == false) 
        cache.add_unique_copy(name, 2.0 * get_C_inv()); 

      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name); 
    } 

    template <int dim> 
    const Tensor<3, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dH() 
      const 
    { 
      const std::string name("d2H_dot_C_inv_dot_H_dC_dH"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          const Tensor<1, dim> &         C_inv_dot_H = get_C_inv_dot_H(); 
          const SymmetricTensor<2, dim> &C_inv       = get_C_inv(); 

          Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH; 
          for (unsigned int A = 0; A < dim; ++A) 
            for (unsigned int B = 0; B < dim; ++B) 
              for (unsigned int C = 0; C < dim; ++C) 
                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -= 
                  C_inv[A][C] * C_inv_dot_H[B] + // 
                  C_inv_dot_H[A] * C_inv[B][C];  // 

          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH); 
        } 

      return cache.template get_object_with_name<Tensor<3, dim>>(name); 
    } 

    template <int dim> 
    const SymmetricTensor<4, dim> & 
    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dC() 
      const 
    { 
      const std::string name("d2H_dot_C_inv_dot_H_dC_dC"); 
      if (cache.stores_object_with_name(name) == false) 
        { 
          const Tensor<1, dim> &         C_inv_dot_H = get_C_inv_dot_H(); 
          const SymmetricTensor<2, dim> &C_inv       = get_C_inv(); 

          SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC; 
          for (unsigned int A = 0; A < dim; ++A) 
            for (unsigned int B = A; B < dim; ++B) 
              for (unsigned int C = 0; C < dim; ++C) 
                for (unsigned int D = C; D < dim; ++D) 
                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] += 
                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] + 
                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] + 
                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] + 
                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]); 

          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC); 
        } 

      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name); 
    } 
// @sect4{Rheological experiment parameters}  

//  @p RheologicalExperimentParameters 类是用来驱动数值实验的，这些实验将在我们已经实现了构成法则的耦合材料上进行。

    class RheologicalExperimentParameters : public ParameterAcceptor 
    { 
    public: 
      RheologicalExperimentParameters(); 

// 这些是要模拟的流变学试样的尺寸。它们有效地定义了我们虚拟实验的测量点。

      double sample_radius = 0.01; 
      double sample_height = 0.001; 

// 三个稳态负载参数分别是

// - 轴向拉伸。

// -- 剪切应变振幅，和

// - 轴向磁场强度。

      double lambda_2 = 0.95; 
      double gamma_12 = 0.05; 
      double H_2      = 60.0e3; 

// 此外，随时间变化的流变学负载条件的参数为

// --加载周期的频率。

// - 负载周期的数量，以及

// - 每个周期的离散时间步数。

      double       frequency         = 1.0 / (2.0 * numbers::PI); 
      unsigned int n_cycles          = 5; 
      unsigned int n_steps_per_cycle = 2500; 

// 我们还声明了一些不言自明的参数，这些参数与用速率依赖型和速率非依赖型材料进行的实验所产生的输出数据有关。

      bool        output_data_to_file = true; 
      std::string output_filename_rd = 
        "experimental_results-rate_dependent.csv"; 
      std::string output_filename_ri = 
        "experimental_results-rate_independent.csv"; 

// 接下来的几个函数将计算与时间有关的实验参数...

      double start_time() const; 

      double end_time() const; 

      double delta_t() const; 

// ...... 而下面两个则规定了任何时候的机械和磁力负载......

      Tensor<1, 3> get_H(const double time) const; 

      Tensor<2, 3> get_F(const double time) const; 

// ...... 而这最后一个是将实验的状态输出到控制台。

      bool print_status(const int step_number) const; 

      bool initialized = false; 
    }; 

    RheologicalExperimentParameters::RheologicalExperimentParameters() 
      : ParameterAcceptor("/Coupled Constitutive Laws/Rheological Experiment/") 
    { 
      add_parameter("Experimental sample radius", sample_radius); 
      add_parameter("Experimental sample radius", sample_height); 

      add_parameter("Axial stretch", lambda_2); 
      add_parameter("Shear strain amplitude", gamma_12); 
      add_parameter("Axial magnetic field strength", H_2); 

      add_parameter("Frequency", frequency); 
      add_parameter("Number of loading cycles", n_cycles); 
      add_parameter("Discretisation for each cycle", n_steps_per_cycle); 

      add_parameter("Output experimental results to file", output_data_to_file); 
      add_parameter("Output file name (rate dependent constitutive law)", 
                    output_filename_rd); 
      add_parameter("Output file name (rate independent constitutive law)", 
                    output_filename_ri); 

      parse_parameters_call_back.connect([&]() -> void { initialized = true; }); 
    } 

    double RheologicalExperimentParameters::start_time() const 
    { 
      return 0.0; 
    } 

    double RheologicalExperimentParameters::end_time() const 
    { 
      return n_cycles / frequency; 
    } 

    double RheologicalExperimentParameters::delta_t() const 
    { 
      return (end_time() - start_time()) / (n_steps_per_cycle * n_cycles); 
    } 

    bool 
    RheologicalExperimentParameters::print_status(const int step_number) const 
    { 
      return (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0; 
    } 

// 施加的磁场总是与流变仪转子的旋转轴对齐。

    Tensor<1, 3> RheologicalExperimentParameters::get_H(const double) const 
    { 
      return Tensor<1, 3>({0.0, 0.0, H_2}); 
    } 

// 根据流变仪和样品的几何形状、采样点和实验参数，计算出应用的变形（梯度）。根据介绍中记录的位移曲线，变形梯度可以用直角坐标表示为 
// @f[
//  \mathbf{F} = \begin{bmatrix}
//     \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}}
//  & -\frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}}
//  & -\tau R \sqrt{\lambda_{3}} \sin\left(\Theta + \alpha\right)
//  \\  \frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}}
//  & \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}}
//  & -\tau R \sqrt{\lambda_{3}} \cos\left(\Theta + \alpha\right)
//  \\  0 & 0 & \lambda_{3}
//  \end{bmatrix}
//  @f] 。

    Tensor<2, 3> RheologicalExperimentParameters::get_F(const double time) const 
    { 
      AssertThrow((sample_radius > 0.0 && sample_height > 0.0), 
                  ExcMessage("Non-physical sample dimensions")); 
      AssertThrow(lambda_2 > 0.0, 
                  ExcMessage("Non-physical applied axial stretch")); 

      const double sqrt_lambda_2     = std::sqrt(lambda_2); 
      const double inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2; 

      const double alpha_max = 
        std::atan(std::tan(gamma_12) * sample_height / 
                  sample_radius); // Small strain approximation 
      const double A       = sample_radius * alpha_max; 
      const double w       = 2.0 * numbers::PI * frequency; // in rad /s 
      const double gamma_t = A * std::sin(w * time); 
      const double tau_t = 
        gamma_t / 
        (sample_radius * sample_height); // Torsion angle per unit length 
      const double alpha_t = tau_t * lambda_2 * sample_height; 

      Tensor<2, 3> F; 
      F[0][0] = inv_sqrt_lambda_2 * std::cos(alpha_t); 
      F[0][1] = -inv_sqrt_lambda_2 * std::sin(alpha_t); 
      F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * std::sin(alpha_t); 
      F[1][0] = inv_sqrt_lambda_2 * std::sin(alpha_t); 
      F[1][1] = inv_sqrt_lambda_2 * std::cos(alpha_t); 
      F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * std::cos(alpha_t); 
      F[2][0] = 0.0; 
      F[2][1] = 0.0; 
      F[2][2] = lambda_2; 

      AssertThrow((F[0][0] > 0) && (F[1][1] > 0) && (F[2][2] > 0), 
                  ExcMessage("Non-physical deformation gradient component.")); 
      AssertThrow(std::abs(determinant(F) - 1.0) < 1e-6, 
                  ExcMessage("Volumetric Jacobian is not equal to unity.")); 

      return F; 
    } 
// @sect4{Rheological experiment: Parallel plate rotational rheometer}  

// 这是将驱动数值实验的函数。

    template <int dim> 
    void run_rheological_experiment( 
      const RheologicalExperimentParameters &experimental_parameters, 
      Coupled_Magnetomechanical_Constitutive_Law_Base<dim> 
        &material_hand_calculated, 
      Coupled_Magnetomechanical_Constitutive_Law_Base<dim> 
        &               material_assisted_computation, 
      TimerOutput &     timer, 
      const std::string filename) 
    { 

// 我们可以利用手工实现的构成法，将我们用它达到的结果与用AD或SD得到的结果进行比较。通过这种方式，我们可以验证它们产生了相同的结果（这表明要么两种实现方式都有很大的可能性是正确的，要么就是它们都有相同的缺陷而不正确）。无论哪种方式，对于完全自我实现的变体来说，这都是一个很好的理智检查，当发现结果之间的差异时，当然可以作为一种调试策略）。)

      const auto check_material_class_results = 
        []( 
          const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &to_verify, 
          const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &blessed, 
          const double tol = 1e-6) { 
          (void)to_verify; 
          (void)blessed; 
          (void)tol; 

          Assert(std::abs(blessed.get_psi() - to_verify.get_psi()) < tol, 
                 ExcMessage("No match for psi. Error: " + 
                            Utilities::to_string(std::abs( 
                              blessed.get_psi() - to_verify.get_psi())))); 

          Assert((blessed.get_B() - to_verify.get_B()).norm() < tol, 
                 ExcMessage("No match for B. Error: " + 
                            Utilities::to_string( 
                              (blessed.get_B() - to_verify.get_B()).norm()))); 
          Assert((blessed.get_S() - to_verify.get_S()).norm() < tol, 
                 ExcMessage("No match for S. Error: " + 
                            Utilities::to_string( 
                              (blessed.get_S() - to_verify.get_S()).norm()))); 

          Assert((blessed.get_DD() - to_verify.get_DD()).norm() < tol, 
                 ExcMessage("No match for BB. Error: " + 
                            Utilities::to_string( 
                              (blessed.get_DD() - to_verify.get_DD()).norm()))); 
          Assert((blessed.get_PP() - to_verify.get_PP()).norm() < tol, 
                 ExcMessage("No match for PP. Error: " + 
                            Utilities::to_string( 
                              (blessed.get_PP() - to_verify.get_PP()).norm()))); 
          Assert((blessed.get_HH() - to_verify.get_HH()).norm() < tol, 
                 ExcMessage("No match for HH. Error: " + 
                            Utilities::to_string( 
                              (blessed.get_HH() - to_verify.get_HH()).norm()))); 
        }; 

// 我们将把材料的构成性响应输出到文件中进行后处理，所以在这里我们声明一个`stream`，它将作为这个输出的缓冲区。我们将使用一个简单的CSV格式来输出结果。

      std::ostringstream stream; 
      stream 
        << "Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n"; 

// 使用DiscreteTime类，我们使用一个固定的时间步长来迭代每个时间段。

      for (DiscreteTime time(experimental_parameters.start_time(), 
                             experimental_parameters.end_time() + 
                               experimental_parameters.delta_t(), 
                             experimental_parameters.delta_t()); 
           time.is_at_end() == false; 
           time.advance_time()) 
        { 
          if (experimental_parameters.print_status(time.get_step_number())) 
            std::cout << "Timestep = " << time.get_step_number() 
                      << " @ time = " << time.get_current_time() << "s." 
                      << std::endl; 

// 我们获取并计算在这个时间步长中应用于材料的负载...

          const Tensor<1, dim> H = 
            experimental_parameters.get_H(time.get_current_time()); 
          const Tensor<2, dim> F = 
            experimental_parameters.get_F(time.get_current_time()); 
          const SymmetricTensor<2, dim> C = 
            Physics::Elasticity::Kinematics::C(F); 

// ...然后我们更新材料的状态...

          { 
            TimerOutput::Scope timer_section(timer, "Hand calculated"); 
            material_hand_calculated.update_internal_data(C, H, time); 
            material_hand_calculated.update_end_of_timestep(); 
          } 

          { 
            TimerOutput::Scope timer_section(timer, "Assisted computation"); 
            material_assisted_computation.update_internal_data(C, H, time); 
            material_assisted_computation.update_end_of_timestep(); 
          } 

// ...并测试两者之间的差异。

          check_material_class_results(material_hand_calculated, 
                                       material_assisted_computation); 

          if (experimental_parameters.output_data_to_file) 
            { 

// 接下来我们要做的是收集一些结果进行后处理。所有的数量都在 "当前配置 "中（而不是 "参考配置"，所有由构成法则计算的数量都在这个框架中）。

              const Tensor<1, dim> h = 
                Physics::Transformations::Covariant::push_forward(H, F); 
              const Tensor<1, dim> b = 
                Physics::Transformations::Piola::push_forward( 
                  material_hand_calculated.get_B(), F); 
              const SymmetricTensor<2, dim> sigma = 
                Physics::Transformations::Piola::push_forward( 
                  material_hand_calculated.get_S(), F); 
              stream << time.get_current_time() << ";" << h[2] << ";" << b[2] 
                     << ";" << F[1][2] * 100.0 << ";" << sigma[1][2] << "\n"; 
            } 
        } 

// 最后，我们将应变应力和磁载荷历史输出到文件中。

      if (experimental_parameters.output_data_to_file) 
        { 
          std::ofstream output(filename); 
          output << stream.str(); 
        } 
    } 
// @sect4{The CoupledConstitutiveLaws::run() function}  

// 这个驱动函数的目的是读取文件中的所有参数，并在此基础上创建每个构成法则的代表性实例，并调用函数对其进行流变学实验。

    void run(int argc, char *argv[]) 
    { 
      using namespace dealii; 

      constexpr unsigned int dim = 3; 

      const ConstitutiveParameters          constitutive_parameters; 
      const RheologicalExperimentParameters experimental_parameters; 

      std::string parameter_file; 
      if (argc > 1) 
        parameter_file = argv[1]; 
      else 
        parameter_file = "parameters.prm"; 
      ParameterAcceptor::initialize(parameter_file, "used_parameters.prm"); 

// 我们开始实际工作，使用我们与速率无关的构成法配置和运行实验。这里的自动可微调数类型是硬编码的，但是通过一些巧妙的模板设计，可以在运行时选择使用哪种框架（例如，通过参数文件选择）。我们将同时用完全手工实现的反面材料法进行实验，并检查它与我们的辅助实现的计算结果。

      { 
        TimerOutput timer(std::cout, 
                          TimerOutput::summary, 
                          TimerOutput::wall_times); 
        std::cout 
          << "Coupled magnetoelastic constitutive law using automatic differentiation." 
          << std::endl; 

        constexpr Differentiation::AD::NumberTypes ADTypeCode = 
          Differentiation::AD::NumberTypes::sacado_dfad_dfad; 

        Magnetoelastic_Constitutive_Law<dim> material(constitutive_parameters); 
        Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode> material_ad( 
          constitutive_parameters); 

        run_rheological_experiment(experimental_parameters, 
                                   material, 
                                   material_ad, 
                                   timer, 
                                   experimental_parameters.output_filename_ri); 

        std::cout << "... all calculations are correct!" << std::endl; 
      } 

// 接下来我们对与速率相关的构成法则做同样的处理。如果SymEngine被设置为使用LLVM即时编译器，则默认选择最高性能的选项，该编译器（结合一些积极的编译标志）产生所有可用选项中最快的代码评估路径。作为后备措施，所谓的 "lambda "优化器（它只需要一个兼容C++11的编译器）将被选中。同时，我们将要求CAS进行普通子表达式的消除，以尽量减少评估过程中使用的中间计算的数量。我们将记录在SD实现的构造器内执行 "初始化 "步骤所需的时间，因为这正是上述转换发生的地方。

      { 
        TimerOutput timer(std::cout, 
                          TimerOutput::summary, 
                          TimerOutput::wall_times); 
        std::cout 
          << "Coupled magneto-viscoelastic constitutive law using symbolic differentiation." 
          << std::endl; 

#ifdef DEAL_II_SYMENGINE_WITH_LLVM 
        std::cout << "Using LLVM optimizer." << std::endl; 
        constexpr Differentiation::SD::OptimizerType optimizer_type = 
          Differentiation::SD::OptimizerType::llvm; 
        constexpr Differentiation::SD::OptimizationFlags optimization_flags = 
          Differentiation::SD::OptimizationFlags::optimize_all; 
#else 
        std::cout << "Using lambda optimizer." << std::endl; 
        constexpr Differentiation::SD::OptimizerType optimizer_type = 
          Differentiation::SD::OptimizerType::lambda; 
        constexpr Differentiation::SD::OptimizationFlags optimization_flags = 
          Differentiation::SD::OptimizationFlags::optimize_cse; 
#endif 

        Magnetoviscoelastic_Constitutive_Law<dim> material( 
          constitutive_parameters); 

        timer.enter_subsection("Initialize symbolic CL"); 
        Magnetoviscoelastic_Constitutive_Law_SD<dim> material_sd( 
          constitutive_parameters, optimizer_type, optimization_flags); 
        timer.leave_subsection(); 

        run_rheological_experiment(experimental_parameters, 
                                   material, 
                                   material_sd, 
                                   timer, 
                                   experimental_parameters.output_filename_rd); 

        std::cout << "... all calculations are correct!" << std::endl; 
      } 
    } 

  } // namespace CoupledConstitutiveLaws 

} // namespace Step71 
// @sect3{The main() function}  

// 主函数只调用两组要执行的例子的驱动函数。

int main(int argc, char *argv[]) 
{ 
  Step71::SimpleExample::run(); 
  Step71::CoupledConstitutiveLaws::run(argc, argv); 

  return 0; 
} 

CCTest_file/step-72.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Authors: Jean-Paul Pelteret, 
 *          Wolfgang Bangerth, Colorado State University, 2021. 
 * Based on step-15, authored by Sven Wetterauer, University of Heidelberg, 2012 
 */ 



// 本教程的大部分内容是对  step-15  的完全复制。因此，为了简洁起见，并保持对这里所实现的变化的关注，我们将只记录新的内容，并简单地指出哪些部分的代码是对以前内容的重复。

//  @sect3{Include files}  

// 本教程中包含了几个新的头文件。第一个是提供ParameterAcceptor类的声明的文件。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/parameter_acceptor.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/utilities.h> 

// 这是第二个，这是一个包罗万象的头，它将使我们能够在这段代码中纳入自动区分（AD）功能。

#include <deal.II/differentiation/ad.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_values_extractors.h> 
#include <deal.II/fe/fe_q.h> 

// 而接下来的三个提供了一些使用通用 MeshWorker::mesh_loop() 框架的多线程能力。

#include <deal.II/meshworker/copy_data.h> 
#include <deal.II/meshworker/mesh_loop.h> 
#include <deal.II/meshworker/scratch_data.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

#include <fstream> 
#include <iostream> 

#include <deal.II/numerics/solution_transfer.h> 

// 然后，我们为这个程序打开一个命名空间，像以前的程序一样，将dealii命名空间中的所有东西导入其中。

namespace Step72 
{ 
  using namespace dealii; 
// @sect3{The <code>MinimalSurfaceProblemParameters</code> class}  

// 在本教程中，我们将实现三种不同的方法来组装线性系统。其中一种反映了最初在 step-15 中提供的手工实现，而另外两种则使用作为Trilinos框架的一部分提供的Sacado自动微分库。

// 为了方便在三种实现之间进行切换，我们有这个非常基本的参数类，它只有两个可配置的选项。

  class MinimalSurfaceProblemParameters : public ParameterAcceptor 
  { 
  public: 
    MinimalSurfaceProblemParameters(); 

// 选择要使用的配方和相应的AD框架。

// - formulation = 0 : 无辅助执行（全手工线性化）。

// - 配方 = 1 : 有限元残差的自动线性化。

// - formulation = 2 : 使用变量公式自动计算有限元残差和线性化。

    unsigned int formulation = 0; 

// 线性系统残差的最大可接受公差。我们将看到，一旦我们使用AD框架，装配时间就会变得很明显，所以我们将 step-15 中选择的公差提高了一个数量级。这样，计算就不会花费太长时间来完成。

    double tolerance = 1e-2; 
  }; 

  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters() 
    : ParameterAcceptor("Minimal Surface Problem/") 
  { 
    add_parameter( 
      "Formulation", formulation, "", this->prm, Patterns::Integer(0, 2)); 
    add_parameter("Tolerance", tolerance, "", this->prm, Patterns::Double(0.0)); 
  } 

//  @sect3{The <code>MinimalSurfaceProblem</code> class template}  

// 该类模板与  step-15  中的内容基本相同。该类的唯一功能变化是：。

// - run()函数现在接收两个参数：一个是选择采用哪种装配方式，一个是允许的最终残差的公差，以及

// - 现在有三个不同的装配函数来实现线性系统的三种装配方法。我们将在后面提供关于这些的细节。

  template <int dim> 
  class MinimalSurfaceProblem 
  { 
  public: 
    MinimalSurfaceProblem(); 

    void run(const int formulation, const double tolerance); 

  private: 
    void   setup_system(const bool initial_step); 
    void   assemble_system_unassisted(); 
    void   assemble_system_with_residual_linearization(); 
    void   assemble_system_using_energy_functional(); 
    void   solve(); 
    void   refine_mesh(); 
    void   set_boundary_values(); 
    double compute_residual(const double alpha) const; 
    double determine_step_length() const; 
    void   output_results(const unsigned int refinement_cycle) const; 

    Triangulation<dim> triangulation; 

    DoFHandler<dim> dof_handler; 
    FE_Q<dim>       fe; 
    QGauss<dim>     quadrature_formula; 

    AffineConstraints<double> hanging_node_constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> current_solution; 
    Vector<double> newton_update; 
    Vector<double> system_rhs; 
  }; 
// @sect3{Boundary condition}  

//应用于该问题的边界条件没有变化。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> &p, 
                                    const unsigned int /*component*/) const 
  { 
    return std::sin(2 * numbers::PI * (p[0] + p[1])); 
  } 
// @sect3{The <code>MinimalSurfaceProblem</code> class implementation}  
// @sect4{MinimalSurfaceProblem::MinimalSurfaceProblem}  

// 对类的构造函数没有做任何修改。

  template <int dim> 
  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem() 
    : dof_handler(triangulation) 
    , fe(2) 
    , quadrature_formula(fe.degree + 1) 
  {} 
// @sect4{MinimalSurfaceProblem::setup_system}  

// 设置类数据结构的函数没有任何变化，即DoFHandler、应用于问题的悬挂节点约束以及线性系统。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step) 
  { 
    if (initial_step) 
      { 
        dof_handler.distribute_dofs(fe); 
        current_solution.reinit(dof_handler.n_dofs()); 

        hanging_node_constraints.clear(); 
        DoFTools::make_hanging_node_constraints(dof_handler, 
                                                hanging_node_constraints); 
        hanging_node_constraints.close(); 
      } 

    newton_update.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 

    hanging_node_constraints.condense(dsp); 

    sparsity_pattern.copy_from(dsp); 
    system_matrix.reinit(sparsity_pattern); 
  } 
// @sect4{Assembling the linear system}  
// @sect5{Manual assembly}  

// 汇编函数是本教程的有趣贡献。assemble_system_unassisted()方法实现了与 step-15 中详述的完全相同的装配函数，但在这个例子中，我们使用 MeshWorker::mesh_loop() 函数来多线程装配过程。这样做的原因很简单。当使用自动分化时，我们知道会有一些额外的计算开销产生。为了减轻这种性能损失，我们希望尽可能多地利用（容易获得的）计算资源。 MeshWorker::mesh_loop() 的概念使这成为一个相对简单的任务。同时，为了公平比较，我们需要对在计算残差或其线性化时不使用任何援助的实现做同样的事情。( MeshWorker::mesh_loop() 函数首先在 step-12 和 step-16 中讨论，如果你想阅读它的话。)

// 实现多线程所需的步骤在这三个函数中是相同的，所以我们将利用assemble_system_unassisted()函数的机会，重点讨论多线程本身。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::assemble_system_unassisted() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

//  MeshWorker::mesh_loop() 希望我们提供两个示范性的数据结构。第一个，`ScratchData`，是用来存储所有要在线程间重复使用的大数据。`CopyData`将保存来自每个单元的对线性系统的贡献。这些独立的矩阵-向量对必须按顺序累积到全局线性系统中。由于我们不需要 MeshWorker::ScratchData 和 MeshWorker::CopyData 类已经提供的东西，所以我们使用这些确切的类定义来解决我们的问题。请注意，我们只需要一个局部矩阵、局部右手向量和单元自由度索引向量的单个实例--因此 MeshWorker::CopyData 的三个模板参数都是`1`。

    using ScratchData = MeshWorker::ScratchData<dim>; 
    using CopyData    = MeshWorker::CopyData<1, 1, 1>; 

// 我们还需要知道我们在装配过程中要处理的迭代器的类型。为了简单起见，我们只要求编译器使用decltype()指定器为我们解决这个问题，知道我们将在由  @p dof_handler.  拥有的活动单元上迭代。
    using CellIteratorType = decltype(dof_handler.begin_active()); 

// 在这里我们初始化示例的数据结构。因为我们知道我们需要计算形状函数梯度、加权雅各布和四分位点在实空间的位置，所以我们把这些标志传给类的构造函数。

    const ScratchData sample_scratch_data(fe, 
                                          quadrature_formula, 
                                          update_gradients | 
                                            update_quadrature_points | 
                                            update_JxW_values); 
    const CopyData    sample_copy_data(dofs_per_cell); 

// 现在我们定义一个lambda函数，它将在一个单元格上执行装配。三个参数是由于我们将传递给该最终调用的参数，将被 MeshWorker::mesh_loop(), 所期望的参数。我们还捕获了 @p this 指针，这意味着我们将可以访问 "this"（即当前的`MinimalSurfaceProblem<dim>`）类实例，以及它的私有成员数据（因为lambda函数被定义在MinimalSurfaceProblem<dim>方法中）。

// 在函数的顶部，我们初始化了依赖于正在执行工作的单元的数据结构。请注意，重新初始化的调用实际上返回了一个FEValues对象的实例，该对象被初始化并存储在`scratch_data`对象中（因此，被重复使用）。

// 同样地，我们从 MeshWorker::mesh_loop() 提供的`copy_data`实例中获得本地矩阵、本地RHS向量和本地单元格DoF指数的别名。然后我们初始化单元格的DoF指数，因为我们知道本地矩阵和向量的大小已经正确。

    const auto cell_worker = [this](const CellIteratorType &cell, 
                                    ScratchData &           scratch_data, 
                                    CopyData &              copy_data) { 
      const auto &fe_values = scratch_data.reinit(cell); 

      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0]; 
      Vector<double> &                      cell_rhs    = copy_data.vectors[0]; 
      std::vector<types::global_dof_index> &local_dof_indices = 
        copy_data.local_dof_indices[0]; 
      cell->get_dof_indices(local_dof_indices); 

// 对于牛顿方法，我们需要问题被线性化的那一点的解的梯度。

// 一旦我们有了这个梯度，我们就可以用通常的方法对这个单元进行装配。 与 step-15 的一个小区别是，我们使用了（相当方便的）基于范围的循环来迭代所有的正交点和自由度。

      std::vector<Tensor<1, dim>> old_solution_gradients( 
        fe_values.n_quadrature_points); 
      fe_values.get_function_gradients(current_solution, 
                                       old_solution_gradients); 

      for (const unsigned int q : fe_values.quadrature_point_indices()) 
        { 
          const double coeff = 
            1.0 / std::sqrt(1.0 + old_solution_gradients[q] * 
                                    old_solution_gradients[q]); 

          for (const unsigned int i : fe_values.dof_indices()) 
            { 
              for (const unsigned int j : fe_values.dof_indices()) 
                cell_matrix(i, j) += 
                  (((fe_values.shape_grad(i, q)      // ((\nabla \phi_i 
                     * coeff                         //   * a_n 
                     * fe_values.shape_grad(j, q))   //   * \nabla \phi_j) 
                    -                                //  - 
                    (fe_values.shape_grad(i, q)      //  (\nabla \phi_i 
                     * coeff * coeff * coeff         //   * a_n^3 
                     * (fe_values.shape_grad(j, q)   //   * (\nabla \phi_j 
                        * old_solution_gradients[q]) //      * \nabla u_n) 
                     * old_solution_gradients[q]))   //   * \nabla u_n))) 
                   * fe_values.JxW(q));              // * dx 

              cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \nabla \phi_i 
                              * coeff                     // * a_n 
                              * old_solution_gradients[q] // * u_n 
                              * fe_values.JxW(q));        // * dx 
            } 
        } 
    }; 

//  MeshWorker::mesh_loop() 要求的第二个lambda函数是一个执行累积全局线性系统中的局部贡献的任务。这正是这个函数所做的，实现的细节在前面已经看到过。需要认识的主要一点是，局部贡献被存储在传入该函数的`copy_data`实例中。这个`copy_data`在 @a 对`cell_worker`的一些调用中已经被填满了数据。

    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) { 
      const FullMatrix<double> &cell_matrix = copy_data.matrices[0]; 
      const Vector<double> &    cell_rhs    = copy_data.vectors[0]; 
      const std::vector<types::global_dof_index> &local_dof_indices = 
        copy_data.local_dof_indices[0]; 

      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 

          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
        } 
    }; 

// 我们已经有了所有需要的函数定义，所以现在我们调用 MeshWorker::mesh_loop() 来执行实际的装配。 我们传递一个标志作为最后的参数，说明我们只想对单元格进行装配。在内部， MeshWorker::mesh_loop() 然后将可用的工作分配给不同的线程，有效地利用当今几乎所有的处理器所提供的多核。

    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(), 
                          cell_worker, 
                          copier, 
                          sample_scratch_data, 
                          sample_copy_data, 
                          MeshWorker::assemble_own_cells); 

// 最后，正如在  step-15  中所做的那样，我们从系统中移除悬空的节点，并对定义牛顿更新的线性系统应用零边界值  $\delta u^n$  。

    hanging_node_constraints.condense(system_matrix); 
    hanging_node_constraints.condense(system_rhs); 

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             boundary_values); 
    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       newton_update, 
                                       system_rhs); 
  } 
// @sect5{Assembly via differentiation of the residual vector}  

// 正如介绍中所述，我们需要为第二种方法做的是实现 $F(U)^K$ 单元对残差向量的局部贡献，然后让AD机器处理如何计算它的导数 $J(U)_{ij}^K=\frac{\partial F(U)^K_i}{\partial U_j}$ 。

// 对于下面的内容，请记住，
// @f[
//    F(U)_i^K \dealcoloneq
//    \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla
//    u|^{2}}} \nabla u \right] \, dV ,
//  @f] 
//  其中 $u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)$  。

// 我们来看看这在实践中是如何实现的。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::assemble_system_with_residual_linearization() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

    using ScratchData      = MeshWorker::ScratchData<dim>; 
    using CopyData         = MeshWorker::CopyData<1, 1, 1>; 
    using CellIteratorType = decltype(dof_handler.begin_active()); 

    const ScratchData sample_scratch_data(fe, 
                                          quadrature_formula, 
                                          update_gradients | 
                                            update_quadrature_points | 
                                            update_JxW_values); 
    const CopyData    sample_copy_data(dofs_per_cell); 

// 我们将利用  step-71  中所示的技术，预先定义我们要使用的AD数据结构。在这种情况下，我们选择辅助类，它将使用Sacado向前自动微分类型自动计算有限元残差的线性化。这些数字类型可以只用来计算一阶导数。这正是我们想要的，因为我们知道我们将只对残差进行线性化，这意味着我们只需要计算一阶导数。计算的返回值将是`double`类型。

// 我们还需要一个提取器来检索一些与问题的现场解决方案有关的数据。

    using ADHelper = Differentiation::AD::ResidualLinearization< 
      Differentiation::AD::NumberTypes::sacado_dfad, 
      double>; 
    using ADNumberType = typename ADHelper::ad_type; 

    const FEValuesExtractors::Scalar u_fe(0); 

// 有了这个，让我们定义lambda函数，它将被用来计算单元格对雅各布矩阵和右手边的贡献。

    const auto cell_worker = [&u_fe, this](const CellIteratorType &cell, 
                                           ScratchData &           scratch_data, 
                                           CopyData &              copy_data) { 
      const auto &       fe_values     = scratch_data.reinit(cell); 
      const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell(); 

      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0]; 
      Vector<double> &                      cell_rhs    = copy_data.vectors[0]; 
      std::vector<types::global_dof_index> &local_dof_indices = 
        copy_data.local_dof_indices[0]; 
      cell->get_dof_indices(local_dof_indices); 

// 我们现在要创建并初始化一个AD辅助类的实例。要做到这一点，我们需要指定有多少个自变量和因变量。自变量将是我们的解向量所具有的局部自由度的数量，即离散化解向量 $u (\mathbf{x})|_K = \sum\limits_{j} U^K_i \varphi_j(\mathbf{x})$ 的每元素表示中的数字 $j$ ，它表示每个有限元素有多少个解系数。在deal.II中，这等于 FiniteElement::dofs_per_cell. ，自变量的数量将是我们要形成的局部残差向量的条目数。在这个特定的问题中（就像许多其他采用[标准Galerkin方法](https:en.wikipedia.org/wiki/Galerkin_method)的问题一样），局部求解系数的数量与局部残差方程的数量相符。

      const unsigned int n_independent_variables = local_dof_indices.size(); 
      const unsigned int n_dependent_variables   = dofs_per_cell; 
      ADHelper ad_helper(n_independent_variables, n_dependent_variables); 

// 接下来，我们将解决方案的值告知帮助器，即我们希望线性化的 $U_j$ 的实际值。由于这是在每个元素上单独进行的，我们必须从全局解决方案向量中提取解决方案的系数。换句话说，我们将所有这些系数 $U_j$ （其中 $j$ 是一个局部自由度）定义为进入向量 $F(U)^{K}$ （因果函数）计算的自变量。
//然后，
//我们就得到了由可自动微分的数字表示的自由度值的完整集合。对这些变量进行的操作从这一点开始被AD库跟踪，直到对象超出范围。所以正是这些变量 <em>  </em> ，我们将对其计算残差项的导数。

      ad_helper.register_dof_values(current_solution, local_dof_indices); 

      const std::vector<ADNumberType> &dof_values_ad = 
        ad_helper.get_sensitive_dof_values(); 

// 然后我们做一些特定问题的任务，首先是根据 "敏感 "的AD自由度值计算所有数值、（空间）梯度等。在这个例子中，我们要检索每个正交点的解梯度。请注意，现在解梯度对自由度值很敏感，因为它们使用 @p ADNumberType 作为标量类型， @p dof_values_ad 矢量提供局部自由度值。

      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients( 
        fe_values.n_quadrature_points); 
      fe_values[u_fe].get_function_gradients_from_local_dof_values( 
        dof_values_ad, old_solution_gradients); 

// 我们声明的下一个变量将存储单元格残余向量贡献。这是相当不言自明的，除了一个<b>very important</b>的细节。请注意，向量中的每个条目都是手工初始化的，数值为0。这是一个 <em> 强烈推荐的 </em> 做法，因为一些AD库似乎没有安全地初始化这些数字类型的内部数据结构。不这样做可能会导致一些非常难以理解或检测的错误（感谢这个程序的作者出于一般的坏经验而提到这一点）。因此，出于谨慎考虑，值得明确地将初始值归零。在这之后，除了符号的改变，残差集看起来和我们之前看到的单元格RHS向量差不多。我们在所有正交点上循环，确保系数现在通过使用正确的`ADNumberType'来编码它对（敏感的）有限元DoF值的依赖性，最后我们组装残差向量的组件。为了完全清楚，有限元形状函数（及其梯度等）以及 "JxW "值仍然是标量值，但每个正交点的 @p coeff 和 @p old_solution_gradients 是以独立变量计算的。

      std::vector<ADNumberType> residual_ad(n_dependent_variables, 
                                            ADNumberType(0.0)); 
      for (const unsigned int q : fe_values.quadrature_point_indices()) 
        { 
          const ADNumberType coeff = 
            1.0 / std::sqrt(1.0 + old_solution_gradients[q] * 
                                    old_solution_gradients[q]); 

          for (const unsigned int i : fe_values.dof_indices()) 
            { 
              residual_ad[i] += (fe_values.shape_grad(i, q)   // \nabla \phi_i 
                                 * coeff                      // * a_n 
                                 * old_solution_gradients[q]) // * u_n 
                                * fe_values.JxW(q);           // * dx 
            } 
        } 

// 一旦我们计算出完整的单元格残差向量，我们就可以将其注册到辅助类。

// 此后，我们在评估点计算残差值（基本上是从我们已经计算出来的东西中提取出真实的值）和它们的Jacobian（每个残差分量相对于所有单元DoF的线性化）。为了组装成全局线性系统，我们必须尊重残差和RHS贡献之间的符号差异。对于牛顿方法，右手边的向量需要等于*负的残差向量。

      ad_helper.register_residual_vector(residual_ad); 

      ad_helper.compute_residual(cell_rhs); 
      cell_rhs *= -1.0; 

      ad_helper.compute_linearization(cell_matrix); 
    }; 

// 该函数的剩余部分等于我们之前的内容。

    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) { 
      const FullMatrix<double> &cell_matrix = copy_data.matrices[0]; 
      const Vector<double> &    cell_rhs    = copy_data.vectors[0]; 
      const std::vector<types::global_dof_index> &local_dof_indices = 
        copy_data.local_dof_indices[0]; 

      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 

          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
        } 
    }; 

    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(), 
                          cell_worker, 
                          copier, 
                          sample_scratch_data, 
                          sample_copy_data, 
                          MeshWorker::assemble_own_cells); 

    hanging_node_constraints.condense(system_matrix); 
    hanging_node_constraints.condense(system_rhs); 

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             boundary_values); 
    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       newton_update, 
                                       system_rhs); 
  } 
// @sect5{Assembly via differentiation of the energy functional}  

// 在这第三种方法中，我们将残差和雅各布作为局部能量函数
// @f[
//     E\left( U \right)^K
//      \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV
//      \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left(
//      \mathbf{X}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times
//      W_{q}}_{\text{JxW(q)}}
//  @f]
//  的第一和第二导数来计算，能量密度由
//  @f[
//    \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}} .
//  @f]给出。

// 我们再来看看这是如何做到的。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::assemble_system_using_energy_functional() 
  { 
    system_matrix = 0; 
    system_rhs    = 0; 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 

    using ScratchData      = MeshWorker::ScratchData<dim>; 
    using CopyData         = MeshWorker::CopyData<1, 1, 1>; 
    using CellIteratorType = decltype(dof_handler.begin_active()); 

    const ScratchData sample_scratch_data(fe, 
                                          quadrature_formula, 
                                          update_gradients | 
                                            update_quadrature_points | 
                                            update_JxW_values); 
    const CopyData    sample_copy_data(dofs_per_cell); 

// 在这个装配过程的实现中，我们选择了辅助类，它将使用嵌套的Sacado前向自动微分类型自动计算残差及其从单元贡献到能量函数的线性化。所选的数字类型可以用来计算第一和第二导数。我们需要这样做，因为残差定义为势能对DoF值的敏感性（即其梯度）。然后我们需要将残差线性化，这意味着必须计算势能的二阶导数。你可能想把这与之前函数中使用的 "ADHelper "的定义进行比较，在那里我们使用 `Differentiation::AD::ResidualLinearization<Differentiation::AD::NumberTypes::sacado_dfad,double>`. 。
    using ADHelper = Differentiation::AD::EnergyFunctional< 
      Differentiation::AD::NumberTypes::sacado_dfad_dfad, 
      double>; 
    using ADNumberType = typename ADHelper::ad_type; 

    const FEValuesExtractors::Scalar u_fe(0); 

// 然后让我们再次定义lambda函数，对一个单元进行积分。

// 为了初始化辅助类的实例，我们现在只需要预先知道自变量的数量（即与元素解向量相关的自由度数量）。这是因为由能量函数产生的二阶导数矩阵必然是平方的（顺便说一下，也是对称的）。

    const auto cell_worker = [&u_fe, this](const CellIteratorType &cell, 
                                           ScratchData &           scratch_data, 
                                           CopyData &              copy_data) { 
      const auto &fe_values = scratch_data.reinit(cell); 

      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0]; 
      Vector<double> &                      cell_rhs    = copy_data.vectors[0]; 
      std::vector<types::global_dof_index> &local_dof_indices = 
        copy_data.local_dof_indices[0]; 
      cell->get_dof_indices(local_dof_indices); 

      const unsigned int n_independent_variables = local_dof_indices.size(); 
      ADHelper           ad_helper(n_independent_variables); 

// 再一次，我们将所有的单元格DoFs值注册到帮助器中，然后提取这些值的 "敏感 "变体，用于后续必须区分的操作--其中之一是计算解决方案的梯度。

      ad_helper.register_dof_values(current_solution, local_dof_indices); 

      const std::vector<ADNumberType> &dof_values_ad = 
        ad_helper.get_sensitive_dof_values(); 

      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients( 
        fe_values.n_quadrature_points); 
      fe_values[u_fe].get_function_gradients_from_local_dof_values( 
        dof_values_ad, old_solution_gradients); 

// 我们接下来创建一个变量来存储电池的总能量。我们再一次强调，我们明确地对这个值进行零初始化，从而确保这个起始值的数据的完整性。

// 我们的目的是计算细胞总能量，它是内部能量（由于右手函数，通常是 $U$ 的线性）和外部能量的总和。在这种特殊情况下，我们没有外部能量（例如，来自源项或诺伊曼边界条件），所以我们将关注内部能量部分。

// 事实上，计算 $E(U)^K$ 几乎是微不足道的，只需要以下几行。

      ADNumberType energy_ad = ADNumberType(0.0); 
      for (const unsigned int q : fe_values.quadrature_point_indices()) 
        { 
          const ADNumberType psi = std::sqrt(1.0 + old_solution_gradients[q] * 
                                                     old_solution_gradients[q]); 

          energy_ad += psi * fe_values.JxW(q); 
        } 

// 在我们计算出这个单元的总能量后，我们将把它注册到帮助器上。 在此基础上，我们现在可以计算出所需的数量，即残差值和它们在评估点的雅各布系数。和以前一样，牛顿的右手边需要是残差的负数。

      ad_helper.register_energy_functional(energy_ad); 

      ad_helper.compute_residual(cell_rhs); 
      cell_rhs *= -1.0; 

 
    }; 

// 与前两个函数一样，函数的剩余部分与之前一样。

    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) { 
      const FullMatrix<double> &cell_matrix = copy_data.matrices[0]; 
      const Vector<double> &    cell_rhs    = copy_data.vectors[0]; 
      const std::vector<types::global_dof_index> &local_dof_indices = 
        copy_data.local_dof_indices[0]; 

      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            system_matrix.add(local_dof_indices[i], 
                              local_dof_indices[j], 
                              cell_matrix(i, j)); 

          system_rhs(local_dof_indices[i]) += cell_rhs(i); 
        } 
    }; 

    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(), 
                          cell_worker, 
                          copier, 
                          sample_scratch_data, 
                          sample_copy_data, 
                          MeshWorker::assemble_own_cells); 

    hanging_node_constraints.condense(system_matrix); 
    hanging_node_constraints.condense(system_rhs); 

    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(), 
                                             boundary_values); 
    MatrixTools::apply_boundary_values(boundary_values, 
                                       system_matrix, 
                                       newton_update, 
                                       system_rhs); 
  } 
// @sect4{MinimalSurfaceProblem::solve}  

// 解算函数与  step-15  中使用的相同。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::solve() 
  { 
    SolverControl            solver_control(system_rhs.size(), 
                                 system_rhs.l2_norm() * 1e-6); 
    SolverCG<Vector<double>> solver(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    solver.solve(system_matrix, newton_update, system_rhs, preconditioner); 

    hanging_node_constraints.distribute(newton_update); 

    const double alpha = determine_step_length(); 
    current_solution.add(alpha, newton_update); 
  } 
// @sect4{MinimalSurfaceProblem::refine_mesh}  

//自 step-15 以来，在网格细化程序和适应性网格之间的解决方案的转移方面没有任何变化。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::refine_mesh() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      current_solution, 
      estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 

    triangulation.prepare_coarsening_and_refinement(); 
    SolutionTransfer<dim> solution_transfer(dof_handler); 
    solution_transfer.prepare_for_coarsening_and_refinement(current_solution); 
    triangulation.execute_coarsening_and_refinement(); 

    dof_handler.distribute_dofs(fe); 

    Vector<double> tmp(dof_handler.n_dofs()); 
    solution_transfer.interpolate(current_solution, tmp); 
    current_solution = tmp; 

    hanging_node_constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

    set_boundary_values(); 

 
  } 

//  @sect4{MinimalSurfaceProblem::set_boundary_values}  

// 边界条件的选择仍然与 step-15 相同 ...

  template <int dim> 
  void MinimalSurfaceProblem<dim>::set_boundary_values() 
  { 
    std::map<types::global_dof_index, double> boundary_values; 
  }; 
  template <int dim> 
                                             BoundaryValues<dim>(), 
                                             boundary_values); 
    for (auto &boundary_value : boundary_values) 
      current_solution(boundary_value.first) = boundary_value.second; 

    hanging_node_constraints.distribute(current_solution); 
  } 
// @sect4{MinimalSurfaceProblem::compute_residual}  

// ...就像在求解迭代过程中用来计算残差的函数一样。如果真的需要，我们可以用能量函数的微分来代替它，但是为了简单起见，我们在这里只是简单地复制我们在 step-15 中已经有的东西。

  template <int dim> 
  double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const 
  { 
    Vector<double> residual(dof_handler.n_dofs()); 

    Vector<double> evaluation_point(dof_handler.n_dofs()); 
    evaluation_point = current_solution; 
    evaluation_point.add(alpha, newton_update); 

    const QGauss<dim> quadrature_formula(fe.degree + 1); 
    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_gradients | update_quadrature_points | 
                              update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double>              cell_residual(dofs_per_cell); 
    std::vector<Tensor<1, dim>> gradients(n_q_points); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_residual = 0; 
        fe_values.reinit(cell); 

        fe_values.get_function_gradients(evaluation_point, gradients); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double coeff = 
              1.0 / std::sqrt(1.0 + gradients[q] * gradients[q]); 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_residual(i) -= (fe_values.shape_grad(i, q) // \nabla \phi_i 
                                   * coeff                    // * a_n 
                                   * gradients[q]             // * u_n 
                                   * fe_values.JxW(q));       // * dx 
          } 

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          residual(local_dof_indices[i]) += cell_residual(i); 
      } 

    hanging_node_constraints.condense(residual); 

    for (types::global_dof_index i : 
         DoFTools::extract_boundary_dofs(dof_handler)) 
      residual(i) = 0; 

    return residual.l2_norm(); 
  } 

//  @sect4{MinimalSurfaceProblem::determine_step_length}  

// 非线性迭代程序的步长（或欠松系数）的选择仍然固定在  step-15  中选择和讨论的值。

  template <int dim> 
  double MinimalSurfaceProblem<dim>::determine_step_length() const 
  { 
    return 0.1; 
  } 

//  @sect4{MinimalSurfaceProblem::output_results}  

// 从`run()`调用的最后一个函数以图形形式输出当前的解决方案（和牛顿更新），作为VTU文件。它与之前教程中使用的完全相同。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::output_results( 
    const unsigned int refinement_cycle) const 
  { 
    DataOut<dim> data_out; 

    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(current_solution, "solution"); 
    data_out.add_data_vector(newton_update, "update"); 
    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu"; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 
// @sect4{MinimalSurfaceProblem::run}  

// 在运行函数中，大部分内容与最初在  step-15  中实现的相同。唯一可以观察到的变化是，我们现在可以（通过参数文件）选择系统残差的最终可接受的公差是什么，并且我们可以选择我们希望利用的装配方法。为了使第二个选择明确，我们向控制台输出一些信息，表明选择。由于我们对比较三种方法中每一种的装配时间感兴趣，我们还添加了一个计时器，跟踪装配过程中所花费的时间。我们还跟踪了解决线性系统所需的时间，这样我们就可以将这些数字与通常需要最长时间执行的那部分代码进行对比。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::run(const int    formulation, 
                                       const double tolerance) 
  { 
    std::cout << "******** Assembly approach ********" << std::endl; 
    const std::array<std::string, 3> method_descriptions = { 
      {"Unassisted implementation (full hand linearization).", 
       "Automated linearization of the finite element residual.", 
       "Automated computation of finite element residual and linearization using a variational formulation."}}; 
    AssertIndexRange(formulation, method_descriptions.size()); 
    std::cout << method_descriptions[formulation] << std::endl << std::endl; 

    TimerOutput timer(std::cout, TimerOutput::summary, TimerOutput::wall_times); 

    GridGenerator::hyper_ball(triangulation); 
    triangulation.refine_global(2); 

    setup_system(/*first time=*/true); 
    set_boundary_values(); 

    double       last_residual_norm = std::numeric_limits<double>::max(); 
    unsigned int refinement_cycle   = 0; 
    do 
      { 
        std::cout << "Mesh refinement step " << refinement_cycle << std::endl; 

        if (refinement_cycle != 0) 
          refine_mesh(); 

        std::cout << "  Initial residual: " << compute_residual(0) << std::endl; 

        for (unsigned int inner_iteration = 0; inner_iteration < 5; 
             ++inner_iteration) 
          { 
            { 
              TimerOutput::Scope t(timer, "Assemble"); 

              if (formulation == 0) 
                assemble_system_unassisted(); 
              else if (formulation == 1) 
                assemble_system_with_residual_linearization(); 
              else if (formulation == 2) 
                assemble_system_using_energy_functional(); 
              else 
                AssertThrow(false, ExcNotImplemented()); 
            } 

            last_residual_norm = system_rhs.l2_norm(); 

            { 
              TimerOutput::Scope t(timer, "Solve"); 
              solve(); 
            } 

            std::cout << "  Residual: " << compute_residual(0) << std::endl; 
          } 

        output_results(refinement_cycle); 

        ++refinement_cycle; 
        std::cout << std::endl; 
      } 
    while (last_residual_norm > tolerance); 
  } 
} // namespace Step72 
// @sect4{The main function}  

// 最后是主函数。它遵循大多数其他主函数的方案，但有两个明显的例外。

// - 我们调用 Utilities::MPI::MPI_InitFinalize ，以便（通过一个隐藏的默认参数）设置使用多线程任务执行的线程数。

// - 我们还有几行专门用于读取或初始化用户定义的参数，这些参数将在程序执行过程中被考虑。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace Step72; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv); 

      std::string prm_file; 
      if (argc > 1) 
        prm_file = argv[1]; 
      else 
        prm_file = "parameters.prm"; 

      const MinimalSurfaceProblemParameters parameters; 
      ParameterAcceptor::initialize(prm_file); 

      MinimalSurfaceProblem<2> minimal_surface_problem_2d; 
      minimal_surface_problem_2d.run(parameters.formulation, 
                                     parameters.tolerance); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 

CCTest_file/step-74.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2020 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE at 
 * the top level of the deal.II distribution. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Timo Heister and Jiaqi Zhang, Clemson University, 2020 
 */ 



// 前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/function_lib.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/fe/mapping_q1.h> 

// 这里定义了不连续的有限元和FEInterfaceValues。

#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_interface_values.h> 

#include <deal.II/numerics/derivative_approximation.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/base/convergence_table.h> 

#include <deal.II/meshworker/copy_data.h> 
#include <deal.II/meshworker/mesh_loop.h> 
#include <deal.II/meshworker/scratch_data.h> 

namespace Step74 
{ 
  using namespace dealii; 
// @sect3{Equation data}  这里我们定义了两个测试案例：平滑函数的收敛率和 Functions::LSingularityFunction. 的l_singularity。
  enum class TestCase 
  { 
    convergence_rate, 
    l_singularity 
  }; 

// 用于收敛性测试的平滑解。

  template <int dim> 
  class SmoothSolution : public Function<dim> 
  { 
  public: 
    SmoothSolution() 
      : Function<dim>() 
    {} 

    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int component = 0) const override; 

    virtual Tensor<1, dim> 
    gradient(const Point<dim> & point, 
             const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  void SmoothSolution<dim>::value_list(const std::vector<Point<dim>> &points, 
                                       std::vector<double> &          values, 
                                       const unsigned int /*component*/) const 
  { 
    using numbers::PI; 
    for (unsigned int i = 0; i < values.size(); ++i) 
      values[i] = 
        std::sin(2. * PI * points[i][0]) * std::sin(2. * PI * points[i][1]); 
  } 

  template <int dim> 
  Tensor<1, dim> 
  SmoothSolution<dim>::gradient(const Point<dim> &point, 
                                const unsigned int /*component*/) const 
  { 
    Tensor<1, dim> return_value; 
    using numbers::PI; 
    return_value[0] = 
      2. * PI * std::cos(2. * PI * point[0]) * std::sin(2. * PI * point[1]); 
    return_value[1] = 
      2. * PI * std::sin(2. * PI * point[0]) * std::cos(2. * PI * point[1]); 
    return return_value; 
  } 

// 平滑函数的相应右手边。

  template <int dim> 
  class SmoothRightHandSide : public Function<dim> 
  { 
  public: 
    SmoothRightHandSide() 
      : Function<dim>() 
    {} 

    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int /*component*/) const override; 
  }; 

  template <int dim> 
  void 
  SmoothRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points, 
                                       std::vector<double> &          values, 
                                       const unsigned int /*component*/) const 
  { 
    using numbers::PI; 
    for (unsigned int i = 0; i < values.size(); ++i) 
      values[i] = 8. * PI * PI * std::sin(2. * PI * points[i][0]) * 
                  std::sin(2. * PI * points[i][1]); 
  } 

//对应于函数 Functions::LSingularityFunction, 的右手边，我们假设扩散系数 $\nu = 1$  。

  template <int dim> 
  class SingularRightHandSide : public Function<dim> 
  { 
  public: 
    SingularRightHandSide() 
      : Function<dim>() 
    {} 

    virtual void value_list(const std::vector<Point<dim>> &points, 
                            std::vector<double> &          values, 
                            const unsigned int /*component*/) const override; 

  private: 
    const Functions::LSingularityFunction ref; 
  }; 

  template <int dim> 
  void 
  SingularRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points, 
                                         std::vector<double> &          values, 
                                         const unsigned int /*component*/) const 
  { 
    for (unsigned int i = 0; i < values.size(); ++i) 
      values[i] = -ref.laplacian(points[i]); 
  } 

//  @sect3{Auxiliary functions}  以下两个辅助函数分别用于计算一个面上的 $u_h$ 和 $\nabla u_h$ 的跳转项。

  template <int dim> 
  void get_function_jump(const FEInterfaceValues<dim> &fe_iv, 
                         const Vector<double> &        solution, 
                         std::vector<double> &         jump) 
  { 
    const unsigned int                 n_q = fe_iv.n_quadrature_points; 
    std::array<std::vector<double>, 2> face_values; 
    jump.resize(n_q); 
    for (unsigned int i = 0; i < 2; ++i) 
      { 
        face_values[i].resize(n_q); 
        fe_iv.get_fe_face_values(i).get_function_values(solution, 
                                                        face_values[i]); 
      } 
    for (unsigned int q = 0; q < n_q; ++q) 
      jump[q] = face_values[0][q] - face_values[1][q]; 
  } 

  template <int dim> 
  void get_function_gradient_jump(const FEInterfaceValues<dim> &fe_iv, 
                                  const Vector<double> &        solution, 
                                  std::vector<Tensor<1, dim>> & gradient_jump) 
  { 
    const unsigned int          n_q = fe_iv.n_quadrature_points; 
    std::vector<Tensor<1, dim>> face_gradients[2]; 
    gradient_jump.resize(n_q); 
    for (unsigned int i = 0; i < 2; ++i) 
      { 
        face_gradients[i].resize(n_q); 
        fe_iv.get_fe_face_values(i).get_function_gradients(solution, 
                                                           face_gradients[i]); 
      } 
    for (unsigned int q = 0; q < n_q; ++q) 
      gradient_jump[q] = face_gradients[0][q] - face_gradients[1][q]; 
  } 

// 这个函数计算惩罚  $\sigma$  。

  double get_penalty_factor(const unsigned int fe_degree, 
                            const double       cell_extent_left, 
                            const double       cell_extent_right) 
  { 
    const unsigned int degree = std::max(1U, fe_degree); 
    return degree * (degree + 1.) * 0.5 * 
           (1. / cell_extent_left + 1. / cell_extent_right); 
  } 
// @sect3{The CopyData}  下面，我们为 MeshWorker::mesh_loop(), 定义 "复制 "对象，它与 step-12 本质上是一样的。注意，这里没有定义 "Scratch "对象，因为我们用 MeshWorker::ScratchData<dim> 代替。复制 "和 "抓取 "对象的使用在WorkStream命名空间文档中得到了广泛的解释）。

  struct CopyDataFace 
  { 
    FullMatrix<double>                   cell_matrix; 
    std::vector<types::global_dof_index> joint_dof_indices; 
    std::array<double, 2>                values; 
    std::array<unsigned int, 2>          cell_indices; 
  }; 

  struct CopyData 
  { 
    FullMatrix<double>                   cell_matrix; 
    Vector<double>                       cell_rhs; 
    std::vector<types::global_dof_index> local_dof_indices; 
    std::vector<CopyDataFace>            face_data; 
    double                               value; 
    unsigned int                         cell_index; 

    template <class Iterator> 
    void reinit(const Iterator &cell, const unsigned int dofs_per_cell) 
    { 
      cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 
      cell_rhs.reinit(dofs_per_cell); 
      local_dof_indices.resize(dofs_per_cell); 
      cell->get_dof_indices(local_dof_indices); 
    } 
  }; 

//  @sect3{The SIPGLaplace class}  在这些准备工作之后，我们继续进行本程序的主类，称为`SIPGLaplace`。该类的整体结构与其他许多教程程序一样。主要的区别只出现在组装函数的实现上，因为我们使用FEInterfaceValues来组装面条。

  template <int dim> 
  class SIPGLaplace 
  { 
  public: 
    SIPGLaplace(const TestCase &test_case); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    void   compute_errors(); 
    void   compute_error_estimate(); 
    double compute_energy_norm_error(); 

    Triangulation<dim>    triangulation; 
    const unsigned int    degree; 
    const QGauss<dim>     quadrature; 
    const QGauss<dim - 1> face_quadrature; 
    const QGauss<dim>     quadrature_overintegration; 
    const QGauss<dim - 1> face_quadrature_overintegration; 
    const MappingQ1<dim>  mapping; 

    using ScratchData = MeshWorker::ScratchData<dim>; 

    const FE_DGQ<dim> fe; 
    DoFHandler<dim>   dof_handler; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 
    Vector<double>       solution; 
    Vector<double>       system_rhs; 

// 该类的其余成员用于以下方面。

// - 用于存储每个单元的误差估计方和能量规范方的矢量。

// - 在屏幕上打印收敛率和误差。

// - 扩散系数 $\nu$ 被设置为1。

// - 存储要计算的测试案例信息的成员。

    Vector<double> estimated_error_square_per_cell; 
    Vector<double> energy_norm_square_per_cell; 

    ConvergenceTable convergence_table; 

    const double diffusion_coefficient = 1.; 

    const TestCase                       test_case; 
    std::unique_ptr<const Function<dim>> exact_solution; 
    std::unique_ptr<const Function<dim>> rhs_function; 
  }; 

// 这里的构造函数将测试案例作为输入，然后确定正确的解决方案和右手边的类。其余的成员变量以明显的方式进行初始化。

  template <int dim> 
  SIPGLaplace<dim>::SIPGLaplace(const TestCase &test_case) 
    : degree(3) 
    , quadrature(degree + 1) 
    , face_quadrature(degree + 1) 
    , quadrature_overintegration(degree + 2) 
    , face_quadrature_overintegration(degree + 2) 
    , mapping() 
    , fe(degree) 
    , dof_handler(triangulation) 
    , test_case(test_case) 
  { 
    if (test_case == TestCase::convergence_rate) 
      { 
        exact_solution = std::make_unique<const SmoothSolution<dim>>(); 
        rhs_function   = std::make_unique<const SmoothRightHandSide<dim>>(); 
      } 

    else if (test_case == TestCase::l_singularity) 
      { 
        exact_solution = 
          std::make_unique<const Functions::LSingularityFunction>(); 
        rhs_function = std::make_unique<const SingularRightHandSide<dim>>(); 
      } 
    else 
      AssertThrow(false, ExcNotImplemented()); 
  } 

  template <int dim> 
  void SIPGLaplace<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp); 
    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 

//  @sect3{The assemble_system function}  这里的组装功能与  step-12  和  step-47  中类似。与手工装配不同的是，我们只需要专注于在每个单元格、每个边界面和每个内部面进行装配。单元和面的循环由  MeshWorker::mesh_loop().  自动处理。

// 该函数首先定义了一个局部（lambda）函数，用来整合单元项。

  template <int dim> 
  void SIPGLaplace<dim>::assemble_system() 
  { 
    const auto cell_worker = 
      [&](const auto &cell, auto &scratch_data, auto &copy_data) { 
        const FEValues<dim> &fe_v          = scratch_data.reinit(cell); 
        const unsigned int   dofs_per_cell = fe_v.dofs_per_cell; 
        copy_data.reinit(cell, dofs_per_cell); 

        const auto &       q_points    = scratch_data.get_quadrature_points(); 
        const unsigned int n_q_points  = q_points.size(); 
        const std::vector<double> &JxW = scratch_data.get_JxW_values(); 

        std::vector<double> rhs(n_q_points); 
        rhs_function->value_list(q_points, rhs); 

        for (unsigned int point = 0; point < n_q_points; ++point) 
          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i) 
            { 
              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j) 
                copy_data.cell_matrix(i, j) += 
                  diffusion_coefficient *     // nu 
                  fe_v.shape_grad(i, point) * // grad v_h 
                  fe_v.shape_grad(j, point) * // grad u_h 
                  JxW[point];                 // dx 

              copy_data.cell_rhs(i) += fe_v.shape_value(i, point) * // v_h 
                                       rhs[point] *                 // f 
                                       JxW[point];                  // dx 
            } 
      }; 

// 接下来，我们需要一个在边界上集合面积分的函数。

    const auto boundary_worker = [&](const auto &        cell, 
                                     const unsigned int &face_no, 
                                     auto &              scratch_data, 
                                     auto &              copy_data) { 
      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no); 

      const auto &       q_points      = scratch_data.get_quadrature_points(); 
      const unsigned int n_q_points    = q_points.size(); 
      const unsigned int dofs_per_cell = fe_fv.dofs_per_cell; 

      const std::vector<double> &        JxW = scratch_data.get_JxW_values(); 
      const std::vector<Tensor<1, dim>> &normals = 
        scratch_data.get_normal_vectors(); 

      std::vector<double> g(n_q_points); 
      exact_solution->value_list(q_points, g); 

      const double extent1 = cell->measure() / cell->face(face_no)->measure(); 
      const double penalty = get_penalty_factor(degree, extent1, extent1); 

      for (unsigned int point = 0; point < n_q_points; ++point) 
        { 
          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            for (unsigned int j = 0; j < dofs_per_cell; ++j) 
              copy_data.cell_matrix(i, j) += 
                (-diffusion_coefficient *        // - nu 
                   fe_fv.shape_value(i, point) * // v_h 
                   (fe_fv.shape_grad(j, point) * // (grad u_h . 
                    normals[point])              //  n) 

                 - diffusion_coefficient *         // - nu 
                     (fe_fv.shape_grad(i, point) * // (grad v_h . 
                      normals[point]) *            //  n) 
                     fe_fv.shape_value(j, point)   // u_h 

                 + diffusion_coefficient * penalty * // + nu sigma 
                     fe_fv.shape_value(i, point) *   // v_h 
                     fe_fv.shape_value(j, point)     // u_h 

                 ) * 
                JxW[point]; // dx 

          for (unsigned int i = 0; i < dofs_per_cell; ++i) 
            copy_data.cell_rhs(i) += 
              (-diffusion_coefficient *        // - nu 
                 (fe_fv.shape_grad(i, point) * // (grad v_h . 
                  normals[point]) *            //  n) 
                 g[point]                      // g 

               + diffusion_coefficient * penalty *        // + nu sigma 
                   fe_fv.shape_value(i, point) * g[point] // v_h g 

               ) * 
              JxW[point]; // dx 
        } 
    }; 

// 最后，一个在内部面组装面积分的函数。为了重新初始化FEInterfaceValues，我们需要向FEInterfaceValues的reinit()函数传递单元格、面和子面指数（用于自适应细化）。

    const auto face_worker = [&](const auto &        cell, 
                                 const unsigned int &f, 
                                 const unsigned int &sf, 
                                 const auto &        ncell, 
                                 const unsigned int &nf, 
                                 const unsigned int &nsf, 
                                 auto &              scratch_data, 
                                 auto &              copy_data) { 
      const FEInterfaceValues<dim> &fe_iv = 
        scratch_data.reinit(cell, f, sf, ncell, nf, nsf); 

      const auto &       q_points   = fe_iv.get_quadrature_points(); 
      const unsigned int n_q_points = q_points.size(); 

      copy_data.face_data.emplace_back(); 
      CopyDataFace &     copy_data_face = copy_data.face_data.back(); 
      const unsigned int n_dofs_face    = fe_iv.n_current_interface_dofs(); 
      copy_data_face.joint_dof_indices  = fe_iv.get_interface_dof_indices(); 
      copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face); 

      const std::vector<double> &        JxW     = fe_iv.get_JxW_values(); 
      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors(); 

      const double extent1 = cell->measure() / cell->face(f)->measure(); 
      const double extent2 = ncell->measure() / ncell->face(nf)->measure(); 
      const double penalty = get_penalty_factor(degree, extent1, extent2); 

      for (unsigned int point = 0; point < n_q_points; ++point) 
        { 
          for (unsigned int i = 0; i < n_dofs_face; ++i) 
            for (unsigned int j = 0; j < n_dofs_face; ++j) 
              copy_data_face.cell_matrix(i, j) += 
                (-diffusion_coefficient *              // - nu 
                   fe_iv.jump(i, point) *              // [v_h] 
                   (fe_iv.average_gradient(j, point) * // ({grad u_h} . 
                    normals[point])                    //  n) 

                 - diffusion_coefficient *               // - nu 
                     (fe_iv.average_gradient(i, point) * // (grad v_h . 
                      normals[point]) *                  //  n) 
                     fe_iv.jump(j, point)                // [u_h] 

                 + diffusion_coefficient * penalty * // + nu sigma 
                     fe_iv.jump(i, point) *          // [v_h] 
                     fe_iv.jump(j, point)            // [u_h] 

                 ) * 
                JxW[point]; // dx 
        } 
    }; 

// 下面的lambda函数就会把数据复制到全局矩阵和右侧。 虽然DG离散化中没有悬空节点约束，但我们定义了一个空的AffineConstraints对象，允许我们使用 AffineConstraints::distribute_local_to_global() 功能。

    AffineConstraints<double> constraints; 
    constraints.close(); 
    const auto copier = [&](const auto &c) { 
      constraints.distribute_local_to_global(c.cell_matrix, 
                                             c.cell_rhs, 
                                             c.local_dof_indices, 
                                             system_matrix, 
                                             system_rhs); 

// 将内部面组件的数据复制到全局矩阵中。

      for (auto &cdf : c.face_data) 
        { 
          constraints.distribute_local_to_global(cdf.cell_matrix, 
                                                 cdf.joint_dof_indices, 
                                                 system_matrix); 
        } 
    }; 

// 在定义了装配函数后，我们现在可以创建ScratchData和CopyData对象，并将它们和上面的lambda函数一起传递给 MeshWorker::mesh_loop(). 此外，我们还需要指定我们要在内部面完全装配一次。

    const UpdateFlags cell_flags = update_values | update_gradients | 
                                   update_quadrature_points | update_JxW_values; 
    const UpdateFlags face_flags = update_values | update_gradients | 
                                   update_quadrature_points | 
                                   update_normal_vectors | update_JxW_values; 

    ScratchData scratch_data( 
      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags); 
    CopyData copy_data; 

    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          copy_data, 
                          MeshWorker::assemble_own_cells | 
                            MeshWorker::assemble_boundary_faces | 
                            MeshWorker::assemble_own_interior_faces_once, 
                          boundary_worker, 
                          face_worker); 
  } 

//  @sect3{The solve() and output_results() function}  以下两个函数完全是标准的，没有难度。

  template <int dim> 
  void SIPGLaplace<dim>::solve() 
  { 
    SparseDirectUMFPACK A_direct; 
    A_direct.initialize(system_matrix); 
    A_direct.vmult(solution, system_rhs); 
  } 

  template <int dim> 
  void SIPGLaplace<dim>::output_results(const unsigned int cycle) const 
  { 
    const std::string filename = "sol_Q" + Utilities::int_to_string(degree, 1) + 
                                 "-" + Utilities::int_to_string(cycle, 2) + 
                                 ".vtu"; 
    std::ofstream output(filename); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(solution, "u", DataOut<dim>::type_dof_data); 
    data_out.build_patches(mapping); 
    data_out.write_vtu(output); 
  } 
// @sect3{The compute_error_estimate() function}  这里的误差估计器的装配与全局矩阵和右前侧的装配很相似，可以由 MeshWorker::mesh_loop() 框架处理。为了理解每个局部（lambda）函数的作用，首先回顾一下，局部单元残差的定义为  $h_K^2 \left\| f + \nu \Delta u_h \right\|_K^2$  。

  template <int dim> 
  void SIPGLaplace<dim>::compute_error_estimate() 
  { 
    const auto cell_worker = 
      [&](const auto &cell, auto &scratch_data, auto &copy_data) { 
        const FEValues<dim> &fe_v = scratch_data.reinit(cell); 

        copy_data.cell_index = cell->active_cell_index(); 

        const auto &               q_points   = fe_v.get_quadrature_points(); 
        const unsigned int         n_q_points = q_points.size(); 
        const std::vector<double> &JxW        = fe_v.get_JxW_values(); 

        std::vector<Tensor<2, dim>> hessians(n_q_points); 
        fe_v.get_function_hessians(solution, hessians); 

        std::vector<double> rhs(n_q_points); 
        rhs_function->value_list(q_points, rhs); 

        const double hk                   = cell->diameter(); 
        double       residual_norm_square = 0; 

        for (unsigned int point = 0; point < n_q_points; ++point) 
          { 
            const double residual = 
              rhs[point] + diffusion_coefficient * trace(hessians[point]); 
            residual_norm_square += residual * residual * JxW[point]; 
          } 
        copy_data.value = hk * hk * residual_norm_square; 
      }; 

// 接下来计算边界条款  $\sum_{f\in \partial K \cap \partial \Omega} \sigma \left\| [  u_h-g_D ]  \right\|_f^2  $  。

    const auto boundary_worker = [&](const auto &        cell, 
                                     const unsigned int &face_no, 
                                     auto &              scratch_data, 
                                     auto &              copy_data) { 
      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no); 

      const auto &   q_points   = fe_fv.get_quadrature_points(); 
      const unsigned n_q_points = q_points.size(); 

      const std::vector<double> &JxW = fe_fv.get_JxW_values(); 

      std::vector<double> g(n_q_points); 
      exact_solution->value_list(q_points, g); 

      std::vector<double> sol_u(n_q_points); 
      fe_fv.get_function_values(solution, sol_u); 

      const double extent1 = cell->measure() / cell->face(face_no)->measure(); 
      const double penalty = get_penalty_factor(degree, extent1, extent1); 

      double difference_norm_square = 0.; 
      for (unsigned int point = 0; point < q_points.size(); ++point) 
        { 
          const double diff = (g[point] - sol_u[point]); 
          difference_norm_square += diff * diff * JxW[point]; 
        } 
      copy_data.value += penalty * difference_norm_square; 
    }; 

// 最后是内部面孔条款  $\sum_{f\in \partial K}\lbrace \sigma
//  \left\| [u_h]  \right\|_f^2   +  h_f \left\|  [\nu \nabla u_h \cdot
//  \mathbf n ] \right\|_f^2 \rbrace$  。

    const auto face_worker = [&](const auto &        cell, 
                                 const unsigned int &f, 
                                 const unsigned int &sf, 
                                 const auto &        ncell, 
                                 const unsigned int &nf, 
                                 const unsigned int &nsf, 
                                 auto &              scratch_data, 
                                 auto &              copy_data) { 
      const FEInterfaceValues<dim> &fe_iv = 
        scratch_data.reinit(cell, f, sf, ncell, nf, nsf); 

      copy_data.face_data.emplace_back(); 
      CopyDataFace &copy_data_face = copy_data.face_data.back(); 

      copy_data_face.cell_indices[0] = cell->active_cell_index(); 
      copy_data_face.cell_indices[1] = ncell->active_cell_index(); 

      const std::vector<double> &        JxW     = fe_iv.get_JxW_values(); 
      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors(); 

      const auto &       q_points   = fe_iv.get_quadrature_points(); 
      const unsigned int n_q_points = q_points.size(); 

      std::vector<double> jump(n_q_points); 
      get_function_jump(fe_iv, solution, jump); 

      std::vector<Tensor<1, dim>> grad_jump(n_q_points); 
      get_function_gradient_jump(fe_iv, solution, grad_jump); 

      const double h = cell->face(f)->diameter(); 

      const double extent1 = cell->measure() / cell->face(f)->measure(); 
      const double extent2 = ncell->measure() / ncell->face(nf)->measure(); 
      const double penalty = get_penalty_factor(degree, extent1, extent2); 

      double flux_jump_square = 0; 
      double u_jump_square    = 0; 
      for (unsigned int point = 0; point < n_q_points; ++point) 
        { 
          u_jump_square += jump[point] * jump[point] * JxW[point]; 
          const double flux_jump = grad_jump[point] * normals[point]; 
          flux_jump_square += 
            diffusion_coefficient * flux_jump * flux_jump * JxW[point]; 
        } 
      copy_data_face.values[0] = 
        0.5 * h * (flux_jump_square + penalty * u_jump_square); 
      copy_data_face.values[1] = copy_data_face.values[0]; 
    }; 

// 在计算了每个单元的局部贡献后，我们仍然需要一种方法将这些复制到全局向量中，该向量将保存所有单元的误差估计值。

    const auto copier = [&](const auto &copy_data) { 
      if (copy_data.cell_index != numbers::invalid_unsigned_int) 
        estimated_error_square_per_cell[copy_data.cell_index] += 
          copy_data.value; 
      for (auto &cdf : copy_data.face_data) 
        for (unsigned int j = 0; j < 2; ++j) 
          estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j]; 
    }; 

// 在所有这些设置之后，让我们来做实际的工作。我们调整向量的大小，将结果写入其中，然后用 MeshWorker::mesh_loop() 函数驱动整个过程。

    estimated_error_square_per_cell.reinit(triangulation.n_active_cells()); 

    const UpdateFlags cell_flags = 
      update_hessians | update_quadrature_points | update_JxW_values; 
    const UpdateFlags face_flags = update_values | update_gradients | 
                                   update_quadrature_points | 
                                   update_JxW_values | update_normal_vectors; 

    ScratchData scratch_data( 
      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags); 

    CopyData copy_data; 
    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          copy_data, 
                          MeshWorker::assemble_own_cells | 
                            MeshWorker::assemble_own_interior_faces_once | 
                            MeshWorker::assemble_boundary_faces, 
                          boundary_worker, 
                          face_worker); 
  } 
// @sect3{The compute_energy_norm_error() function}  接下来，我们用能量准则来评估准确性。这个函数类似于上面的误差估计器的集合。这里我们计算由
// @f[
//    \|u \|_{1,h}^2 = \sum_{K \in \Gamma_h} \nu\|\nabla u \|_K^2 +
//    \sum_{f \in F_i} \sigma \| [ u ] \|_f^2 +
//    \sum_{f \in F_b} \sigma  \|u\|_f^2.
//  @f]
//  定义的能量准则的平方 因此，相应的误差是
//  @f[
//    \|u -u_h \|_{1,h}^2 = \sum_{K \in \Gamma_h} \nu\|\nabla (u_h - u)  \|_K^2
//    + \sum_{f \in F_i} \sigma  \|[ u_h ] \|_f^2 + \sum_{f \in F_b}\sigma
//    \|u_h-g_D\|_f^2.
//  @f]

  template <int dim> 
  double SIPGLaplace<dim>::compute_energy_norm_error() 
  { 
    energy_norm_square_per_cell.reinit(triangulation.n_active_cells()); 

// 组装  $\sum_{K \in \Gamma_h} \nu\|\nabla (u_h - u)  \|_K^2 $  。

    const auto cell_worker = 
      [&](const auto &cell, auto &scratch_data, auto &copy_data) { 
        const FEValues<dim> &fe_v = scratch_data.reinit(cell); 

        copy_data.cell_index = cell->active_cell_index(); 

        const auto &               q_points   = fe_v.get_quadrature_points(); 
        const unsigned int         n_q_points = q_points.size(); 
        const std::vector<double> &JxW        = fe_v.get_JxW_values(); 

        std::vector<Tensor<1, dim>> grad_u(n_q_points); 
        fe_v.get_function_gradients(solution, grad_u); 

        std::vector<Tensor<1, dim>> grad_exact(n_q_points); 
        exact_solution->gradient_list(q_points, grad_exact); 

        double norm_square = 0; 
        for (unsigned int point = 0; point < n_q_points; ++point) 
          { 
            norm_square += 
              (grad_u[point] - grad_exact[point]).norm_square() * JxW[point]; 
          } 
        copy_data.value = diffusion_coefficient * norm_square; 
      }; 

// 组装  $\sum_{f \in F_b}\sigma  \|u_h-g_D\|_f^2$  。

    const auto boundary_worker = [&](const auto &        cell, 
                                     const unsigned int &face_no, 
                                     auto &              scratch_data, 
                                     auto &              copy_data) { 
      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no); 

      const auto &   q_points   = fe_fv.get_quadrature_points(); 
      const unsigned n_q_points = q_points.size(); 

      const std::vector<double> &JxW = fe_fv.get_JxW_values(); 

      std::vector<double> g(n_q_points); 
      exact_solution->value_list(q_points, g); 

      std::vector<double> sol_u(n_q_points); 
      fe_fv.get_function_values(solution, sol_u); 

      const double extent1 = cell->measure() / cell->face(face_no)->measure(); 
      const double penalty = get_penalty_factor(degree, extent1, extent1); 

      double difference_norm_square = 0.; 
      for (unsigned int point = 0; point < q_points.size(); ++point) 
        { 
          const double diff = (g[point] - sol_u[point]); 
          difference_norm_square += diff * diff * JxW[point]; 
        } 
      copy_data.value += penalty * difference_norm_square; 
    }; 

// 组装  $\sum_{f \in F_i} \sigma  \| [ u_h ] \|_f^2$  。

    const auto face_worker = [&](const auto &        cell, 
                                 const unsigned int &f, 
                                 const unsigned int &sf, 
                                 const auto &        ncell, 
                                 const unsigned int &nf, 
                                 const unsigned int &nsf, 
                                 auto &              scratch_data, 
                                 auto &              copy_data) { 
      const FEInterfaceValues<dim> &fe_iv = 
        scratch_data.reinit(cell, f, sf, ncell, nf, nsf); 

      copy_data.face_data.emplace_back(); 
      CopyDataFace &copy_data_face = copy_data.face_data.back(); 

      copy_data_face.cell_indices[0] = cell->active_cell_index(); 
      copy_data_face.cell_indices[1] = ncell->active_cell_index(); 

      const std::vector<double> &JxW = fe_iv.get_JxW_values(); 

      const auto &       q_points   = fe_iv.get_quadrature_points(); 
      const unsigned int n_q_points = q_points.size(); 

      std::vector<double> jump(n_q_points); 
      get_function_jump(fe_iv, solution, jump); 

      const double extent1 = cell->measure() / cell->face(f)->measure(); 
      const double extent2 = ncell->measure() / ncell->face(nf)->measure(); 
      const double penalty = get_penalty_factor(degree, extent1, extent2); 

      double u_jump_square = 0; 
      for (unsigned int point = 0; point < n_q_points; ++point) 
        { 
          u_jump_square += jump[point] * jump[point] * JxW[point]; 
        } 
      copy_data_face.values[0] = 0.5 * penalty * u_jump_square; 
      copy_data_face.values[1] = copy_data_face.values[0]; 
    }; 

    const auto copier = [&](const auto &copy_data) { 
      if (copy_data.cell_index != numbers::invalid_unsigned_int) 
        energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value; 
      for (auto &cdf : copy_data.face_data) 
        for (unsigned int j = 0; j < 2; ++j) 
          energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j]; 
    }; 

    const UpdateFlags cell_flags = 
      update_gradients | update_quadrature_points | update_JxW_values; 
    UpdateFlags face_flags = 
      update_values | update_quadrature_points | update_JxW_values; 

    const ScratchData scratch_data(mapping, 
                                   fe, 
                                   quadrature_overintegration, 
                                   cell_flags, 
                                   face_quadrature_overintegration, 
                                   face_flags); 

    CopyData copy_data; 
    MeshWorker::mesh_loop(dof_handler.begin_active(), 
                          dof_handler.end(), 
                          cell_worker, 
                          copier, 
                          scratch_data, 
                          copy_data, 
                          MeshWorker::assemble_own_cells | 
                            MeshWorker::assemble_own_interior_faces_once | 
                            MeshWorker::assemble_boundary_faces, 
                          boundary_worker, 
                          face_worker); 
    const double energy_error = 
      std::sqrt(energy_norm_square_per_cell.l1_norm()); 
    return energy_error; 
  } 

//  @sect3{The refine_grid() function}  
  template <int dim> 
  void SIPGLaplace<dim>::refine_grid() 
  { 
    const double refinement_fraction = 0.1; 

    GridRefinement::refine_and_coarsen_fixed_number( 
      triangulation, estimated_error_square_per_cell, refinement_fraction, 0.); 

    triangulation.execute_coarsening_and_refinement(); 
  } 

//  @sect3{The compute_errors() function}  我们分别计算 $L_2$ 规范、 $H_1$ 半规范和能量规范中的三个误差。这些误差会被打印到屏幕上，同时也会存储在一个表格中，该表格记录了这些误差是如何随着网格细化而衰减的，并且可以在程序结束时一步步输出。

  template <int dim> 
  void SIPGLaplace<dim>::compute_errors() 
  { 
    double L2_error, H1_error, energy_error; 

    { 
      Vector<float> difference_per_cell(triangulation.n_active_cells()); 
      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        *(exact_solution.get()), 
                                        difference_per_cell, 
                                        quadrature_overintegration, 
                                        VectorTools::L2_norm); 

      L2_error = VectorTools::compute_global_error(triangulation, 
                                                   difference_per_cell, 
                                                   VectorTools::L2_norm); 
      convergence_table.add_value("L2", L2_error); 
    } 

    { 
      Vector<float> difference_per_cell(triangulation.n_active_cells()); 
      VectorTools::integrate_difference(mapping, 
                                        dof_handler, 
                                        solution, 
                                        *(exact_solution.get()), 
                                        difference_per_cell, 
                                        quadrature_overintegration, 
                                        VectorTools::H1_seminorm); 

      H1_error = VectorTools::compute_global_error(triangulation, 
                                                   difference_per_cell, 
                                                   VectorTools::H1_seminorm); 
      convergence_table.add_value("H1", H1_error); 
    } 

    { 
      energy_error = compute_energy_norm_error(); 
      convergence_table.add_value("Energy", energy_error); 
    } 

    std::cout << "  Error in the L2 norm         : " << L2_error << std::endl 
              << "  Error in the H1 seminorm     : " << H1_error << std::endl 
              << "  Error in the energy norm     : " << energy_error 
              << std::endl; 
  } 

//  @sect3{The run() function}  
 
  void SIPGLaplace<dim>::run() 
  { 
    const unsigned int max_cycle = 
      (test_case == TestCase::convergence_rate ? 6 : 20); 
    for (unsigned int cycle = 0; cycle < max_cycle; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << std::endl; 

        switch (test_case) 
          { 
            case TestCase::convergence_rate: 
              { 
                if (cycle == 0) 
                  { 
                    GridGenerator::hyper_cube(triangulation); 

                    triangulation.refine_global(2); 
                  } 
                else 
                  { 
                    triangulation.refine_global(1); 
                  } 
                break; 
 

            case TestCase::l_singularity: 
              { 
                if (cycle == 0) 
                  { 
                    GridGenerator::hyper_L(triangulation); 
                    triangulation.refine_global(3); 
                  } 
                else 
                  { 
                    refine_grid(); 
                  } 
                break; 
              } 

            default: 
              { 
                Assert(false, ExcNotImplemented()); 
              } 
          } 

        std::cout << "  Number of active cells       : " 
                  << triangulation.n_active_cells() << std::endl; 
        setup_system(); 

        std::cout << "  Number of degrees of freedom : " << dof_handler.n_dofs() 
                  << std::endl; 

        assemble_system(); 
        solve(); 
        output_results(cycle); 
        { 
          convergence_table.add_value("cycle", cycle); 
          convergence_table.add_value("cells", triangulation.n_active_cells()); 
          convergence_table.add_value("dofs", dof_handler.n_dofs()); 
        } 
        compute_errors(); 

        if (test_case == TestCase::l_singularity) 
          { 
            compute_error_estimate(); 
            std::cout << "  Estimated error              : " 
                      << std::sqrt(estimated_error_square_per_cell.l1_norm()) 
                      << std::endl; 

            convergence_table.add_value( 
              "Estimator", 
              std::sqrt(estimated_error_square_per_cell.l1_norm())); 
          } 
        std::cout << std::endl; 
      } 

// 在运行了所有的计算之后，让我们告诉收敛表如何格式化它的数据并将其输出到屏幕。

    convergence_table.set_precision("L2", 3); 
    convergence_table.set_precision("H1", 3); 
    convergence_table.set_precision("Energy", 3); 

    convergence_table.set_scientific("L2", true); 
    convergence_table.set_scientific("H1", true); 
    convergence_table.set_scientific("Energy", true); 

    if (test_case == TestCase::convergence_rate) 
      { 
        convergence_table.evaluate_convergence_rates( 
          "L2", ConvergenceTable::reduction_rate_log2); 
        convergence_table.evaluate_convergence_rates( 
          "H1", ConvergenceTable::reduction_rate_log2); 
      } 
    if (test_case == TestCase::l_singularity) 
      { 
        convergence_table.set_precision("Estimator", 3); 
        convergence_table.set_scientific("Estimator", true); 
      } 

    std::cout << "degree = " << degree << std::endl; 
    convergence_table.write_text( 
      std::cout, TableHandler::TextOutputFormat::org_mode_table); 
  } 
} // namespace Step74 

//  @sect3{The main() function}  下面的 <code>main</code> 函数与前面的例子也类似，不需要注释。

int main() 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step74; 

      const TestCase test_case = TestCase::l_singularity; 

      SIPGLaplace<2> problem(test_case); 
      problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    }; 

  return 0; 
} 

CCTest_file/step-75.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Marc Fehling, Colorado State University, 2021 
 *         Peter Munch, Technical University of Munich and Helmholtz-Zentrum 
 *                      hereon, 2021 
 *         Wolfgang Bangerth, Colorado State University, 2021 
 */ 


// @sect3{Include files}  

// 在以前的教程程序中，特别是在 step-27 和 step-40 中，已经使用和讨论了以下包含文件。

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/index_set.h> 
#include <deal.II/base/mpi.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/timer.h> 

#include <deal.II/distributed/grid_refinement.h> 
#include <deal.II/distributed/tria.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/grid/grid_generator.h> 

#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_series.h> 

#include <deal.II/hp/fe_collection.h> 
#include <deal.II/hp/refinement.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/trilinos_precondition.h> 
#include <deal.II/lac/trilinos_sparse_matrix.h> 
#include <deal.II/lac/vector.h> 

#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/smoothness_estimator.h> 
#include <deal.II/numerics/vector_tools.h> 

#include <algorithm> 
#include <fstream> 
#include <iostream> 

// 为了实现负载平衡，我们将在单元格上分配单独的权重，为此我们将使用类  parallel::CellWeights.  。
#include <deal.II/distributed/cell_weights.h> 

// 求解函数需要从直角坐标到极坐标的转换。 GeometricUtilities::Coordinates 命名空间提供了必要的工具。

#include <deal.II/base/function.h> 
#include <deal.II/base/geometric_utilities.h> 

// 以下包含的文件将启用MatrixFree功能。

#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/fe_evaluation.h> 
#include <deal.II/matrix_free/tools.h> 

// 我们将使用 LinearAlgebra::distributed::Vector 进行线性代数操作。

#include <deal.II/lac/la_parallel_vector.h> 

// 我们剩下的就是包含多网格求解器所需的文件。

#include <deal.II/multigrid/mg_coarse.h> 
#include <deal.II/multigrid/mg_constrained_dofs.h> 
#include <deal.II/multigrid/mg_matrix.h> 
#include <deal.II/multigrid/mg_smoother.h> 
#include <deal.II/multigrid/mg_tools.h> 
#include <deal.II/multigrid/mg_transfer_global_coarsening.h> 
#include <deal.II/multigrid/multigrid.h> 

namespace Step75 
{ 
  using namespace dealii; 
// @sect3{The <code>Solution</code> class template}  

// 我们有一个分析性的方案可以使用。我们将用这个解来为问题的数值解施加边界条件。解决方案的表述需要转换为极坐标。为了从笛卡尔坐标转换到球面坐标，我们将使用 GeometricUtilities::Coordinates 命名空间的一个辅助函数。这个转换的前两个坐标对应于x-y面的极坐标。

  template <int dim> 
  class Solution : public Function<dim> 
  { 
  public: 
    Solution() 
      : Function<dim>() 
    {} 

    virtual double value(const Point<dim> &p, 
                         const unsigned int /*component*/) const override 
    { 
      const std::array<double, dim> p_sphere = 
        GeometricUtilities::Coordinates::to_spherical(p); 

      constexpr const double alpha = 2. / 3.; 
      return std::pow(p_sphere[0], alpha) * std::sin(alpha * p_sphere[1]); 
    } 
  }; 

//  @sect3{Parameters}  

// 在本教程中，我们将使用一个简化的参数集。这里也可以使用ParameterHandler类，但为了使本教程简短，我们决定使用简单的结构。所有这些参数的实际意图将在接下来的类中描述，在它们各自使用的位置。

// 下面的参数集控制着多网格机制的粗网格求解器、平滑器和网格间传输方案。我们用默认参数来填充它。

  struct MultigridParameters 
  { 
    struct 
    { 
      std::string  type            = "cg_with_amg"; 
      unsigned int maxiter         = 10000; 
      double       abstol          = 1e-20; 
      double       reltol          = 1e-4; 
      unsigned int smoother_sweeps = 1; 
      unsigned int n_cycles        = 1; 
      std::string  smoother_type   = "ILU"; 
    } coarse_solver; 

    struct 
    { 
      std::string  type                = "chebyshev"; 
      double       smoothing_range     = 20; 
      unsigned int degree              = 5; 
      unsigned int eig_cg_n_iterations = 20; 
    } smoother; 

    struct 
    { 
      MGTransferGlobalCoarseningTools::PolynomialCoarseningSequenceType 
        p_sequence = MGTransferGlobalCoarseningTools:: 
          PolynomialCoarseningSequenceType::decrease_by_one; 
      bool perform_h_transfer = true; 
    } transfer; 
  }; 

// 这是该问题类的一般参数结构。你会发现这个结构分为几个类别，包括一般的运行时参数、级别限制、细化和粗化分数，以及单元加权的参数。它还包含一个上述结构的实例，用于多网格参数，这些参数将被传递给多网格算法。

  struct Parameters 
  { 
    unsigned int n_cycles         = 8; 
    double       tolerance_factor = 1e-12; 

    MultigridParameters mg_data; 

    unsigned int min_h_level            = 5; 
    unsigned int max_h_level            = 12; 
    unsigned int min_p_degree           = 2; 
    unsigned int max_p_degree           = 6; 
    unsigned int max_p_level_difference = 1; 

    double refine_fraction    = 0.3; 
    double coarsen_fraction   = 0.03; 
    double p_refine_fraction  = 0.9; 
    double p_coarsen_fraction = 0.9; 

    double weighting_factor   = 1e6; 
    double weighting_exponent = 1.; 
  }; 

//  @sect3{Matrix-free Laplace operator}  

// 这是一个无矩阵的拉普拉斯算子的实现，基本上将接管其他教程中的`assemble_system()`函数的部分。所有成员函数的含义将在后面的定义中解释。

// 我们将使用FEEvaluation类来评估正交点的解向量并进行积分。与其他教程不同的是，模板参数`度数`被设置为  $-1$  ，`一维正交数`被设置为  $0$  。在这种情况下，FEEvaluation会动态地选择正确的多项式度数和正交点的数量。在这里，我们为FEEvaluation引入一个带有正确模板参数的别名，这样我们以后就不用担心这些参数了。

  template <int dim, typename number> 
  class LaplaceOperator : public Subscriptor 
  { 
  public: 
    using VectorType = LinearAlgebra::distributed::Vector<number>; 

    using FECellIntegrator = FEEvaluation<dim, -1, 0, 1, number>; 

    LaplaceOperator() = default; 

    LaplaceOperator(const hp::MappingCollection<dim> &mapping, 
                    const DoFHandler<dim> &           dof_handler, 
                    const hp::QCollection<dim> &      quad, 
                    const AffineConstraints<number> & constraints, 
                    VectorType &                      system_rhs); 

    void reinit(const hp::MappingCollection<dim> &mapping, 
                const DoFHandler<dim> &           dof_handler, 
                const hp::QCollection<dim> &      quad, 
                const AffineConstraints<number> & constraints, 
                VectorType &                      system_rhs); 

    types::global_dof_index m() const; 

    number el(unsigned int, unsigned int) const; 

    void initialize_dof_vector(VectorType &vec) const; 

    void vmult(VectorType &dst, const VectorType &src) const; 

    void Tvmult(VectorType &dst, const VectorType &src) const; 

    const TrilinosWrappers::SparseMatrix &get_system_matrix() const; 

    void compute_inverse_diagonal(VectorType &diagonal) const; 

  private: 
    void do_cell_integral_local(FECellIntegrator &integrator) const; 

    void do_cell_integral_global(FECellIntegrator &integrator, 
                                 VectorType &      dst, 
                                 const VectorType &src) const; 

    void do_cell_integral_range( 
      const MatrixFree<dim, number> &              matrix_free, 
      VectorType &                                 dst, 
      const VectorType &                           src, 
      const std::pair<unsigned int, unsigned int> &range) const; 

    MatrixFree<dim, number> matrix_free; 

// 为了用AMG预处理程序解决最粗层次的方程系统，我们需要一个最粗层次的实际系统矩阵。为此，我们提供了一种机制，可以选择从无矩阵公式中计算出一个矩阵，为此我们引入了一个专门的SparseMatrix对象。在默认情况下，这个矩阵保持为空。一旦`get_system_matrix()`被调用，这个矩阵就会被填充（懒惰分配）。由于这是一个 "const "函数，我们需要在这里使用 "mutable "关键字。我们还需要一个约束对象来构建矩阵。

    AffineConstraints<number>              constraints; 
    mutable TrilinosWrappers::SparseMatrix system_matrix; 
  }; 

// 下面的部分包含了初始化和重新初始化该类的函数。特别是，这些函数初始化了内部的MatrixFree实例。为了简单起见，我们还计算了系统右侧的向量。

  template <int dim, typename number> 
  LaplaceOperator<dim, number>::LaplaceOperator( 
    const hp::MappingCollection<dim> &mapping, 
    const DoFHandler<dim> &           dof_handler, 
    const hp::QCollection<dim> &      quad, 
    const AffineConstraints<number> & constraints, 
    VectorType &                      system_rhs) 
  { 
    this->reinit(mapping, dof_handler, quad, constraints, system_rhs); 
  } 

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::reinit( 
    const hp::MappingCollection<dim> &mapping, 
    const DoFHandler<dim> &           dof_handler, 
    const hp::QCollection<dim> &      quad, 
    const AffineConstraints<number> & constraints, 
    VectorType &                      system_rhs) 
  { 

// 清除内部数据结构（在操作者被重复使用的情况下）。

    this->system_matrix.clear(); 

// 复制约束条件，因为以后在计算系统矩阵时可能需要它们。

    this->constraints.copy_from(constraints); 

// 设置MatrixFree。在正交点，我们只需要评估解的梯度，并用形状函数的梯度进行测试，所以我们只需要设置标志`update_gradients`。

    typename MatrixFree<dim, number>::AdditionalData data; 
    data.mapping_update_flags = update_gradients; 

    matrix_free.reinit(mapping, dof_handler, constraints, quad, data); 

// 计算右手边的向量。为此，我们设置了第二个MatrixFree实例，它使用一个修改过的AffineConstraints，不包含由于Dirichlet-边界条件的约束。这个修改过的算子被应用于一个只设置了迪里希特值的向量。其结果是负的右手边向量。

    { 
      AffineConstraints<number> constraints_without_dbc; 

      IndexSet locally_relevant_dofs; 
      DoFTools::extract_locally_relevant_dofs(dof_handler, 
                                              locally_relevant_dofs); 
      constraints_without_dbc.reinit(locally_relevant_dofs); 

      DoFTools::make_hanging_node_constraints(dof_handler, 
                                              constraints_without_dbc); 
      constraints_without_dbc.close(); 

      VectorType b, x; 

      this->initialize_dof_vector(system_rhs); 

      MatrixFree<dim, number> matrix_free; 
      matrix_free.reinit( 
        mapping, dof_handler, constraints_without_dbc, quad, data); 

      matrix_free.initialize_dof_vector(b); 
      matrix_free.initialize_dof_vector(x); 

      constraints.distribute(x); 

      matrix_free.cell_loop(&LaplaceOperator::do_cell_integral_range, 
                            this, 
                            b, 
                            x); 

      constraints.set_zero(b); 

      system_rhs -= b; 
    } 
  } 

// 以下函数是多网格算法隐含需要的，包括平滑器。

// 由于我们没有矩阵，所以要向DoFHandler查询自由度的数量。

  template <int dim, typename number> 
  types::global_dof_index LaplaceOperator<dim, number>::m() const 
  { 
    return matrix_free.get_dof_handler().n_dofs(); 
  } 

// 访问矩阵中的一个特定元素。这个函数既不需要也没有实现，但是，在编译程序时需要它。

  template <int dim, typename number> 
  number LaplaceOperator<dim, number>::el(unsigned int, unsigned int) const 
  { 
    Assert(false, ExcNotImplemented()); 
    return 0; 
  } 

// 初始化给定的向量。我们只是把这个任务委托给同名的MatrixFree函数。

  template <int dim, typename number> 
  void 
  LaplaceOperator<dim, number>::initialize_dof_vector(VectorType &vec) const 
  { 
    matrix_free.initialize_dof_vector(vec); 
  } 

// 在MatrixFree的帮助下，通过在所有单元中循环进行运算评估，并评估单元积分的效果（参见。`do_cell_integral_local()`和`do_cell_integral_global()`）。)

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::vmult(VectorType &      dst, 
                                           const VectorType &src) const 
  { 
    this->matrix_free.cell_loop( 
      &LaplaceOperator::do_cell_integral_range, this, dst, src, true); 
  } 

// 执行转置的运算符评估。由于我们考虑的是对称的 "矩阵"，这个函数可以简单地将其任务委托给vmult()。

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::Tvmult(VectorType &      dst, 
                                            const VectorType &src) const 
  { 
    this->vmult(dst, src); 
  } 

// 由于我们没有一个系统矩阵，我们不能循环计算矩阵的对角线项。相反，我们通过对单位基向量进行一连串的运算符评估来计算对角线。为此，我们使用了MatrixFreeTools命名空间中的一个优化函数。之后再手动进行反转。

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::compute_inverse_diagonal( 
    VectorType &diagonal) const 
  { 
    MatrixFreeTools::compute_diagonal(matrix_free, 
                                      diagonal, 
                                      &LaplaceOperator::do_cell_integral_local, 
                                      this); 

    for (auto &i : diagonal) 
      i = (std::abs(i) > 1.0e-10) ? (1.0 / i) : 1.0; 
  } 

// 在无矩阵的情况下，在这个类的初始化过程中没有设置系统矩阵。因此，如果需要的话，它必须在这里被计算出来。由于矩阵在本教程中只对线性元素进行计算（在粗略的网格上），这一点是可以接受的。矩阵的条目是通过运算符的评估序列得到的。为此，使用了优化函数 MatrixFreeTools::compute_matrix() 。矩阵只有在尚未设置的情况下才会被计算（懒惰分配）。

  template <int dim, typename number> 
  const TrilinosWrappers::SparseMatrix & 
  LaplaceOperator<dim, number>::get_system_matrix() const 
  { 
    if (system_matrix.m() == 0 && system_matrix.n() == 0) 
      { 
        const auto &dof_handler = this->matrix_free.get_dof_handler(); 

        TrilinosWrappers::SparsityPattern dsp( 
          dof_handler.locally_owned_dofs(), 
          dof_handler.get_triangulation().get_communicator()); 

        DoFTools::make_sparsity_pattern(dof_handler, dsp, this->constraints); 

        dsp.compress(); 
        system_matrix.reinit(dsp); 

        MatrixFreeTools::compute_matrix( 
          matrix_free, 
          constraints, 
          system_matrix, 
          &LaplaceOperator::do_cell_integral_local, 
          this); 
      } 

    return this->system_matrix; 
  } 

// 对一个单元格批处理进行单元格积分，不需要收集和分散数值。MatrixFreeTools函数需要这个函数，因为这些函数直接对FEEvaluation的缓冲区进行操作。

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::do_cell_integral_local( 
    FECellIntegrator &integrator) const 
  { 
    integrator.evaluate(EvaluationFlags::gradients); 

    for (unsigned int q = 0; q < integrator.n_q_points; ++q) 
      integrator.submit_gradient(integrator.get_gradient(q), q); 

    integrator.integrate(EvaluationFlags::gradients); 
  } 

// 与上述相同，但可以访问全局向量。

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::do_cell_integral_global( 
    FECellIntegrator &integrator, 
    VectorType &      dst, 
    const VectorType &src) const 
  { 
    integrator.gather_evaluate(src, EvaluationFlags::gradients); 

    for (unsigned int q = 0; q < integrator.n_q_points; ++q) 
      integrator.submit_gradient(integrator.get_gradient(q), q); 

    integrator.integrate_scatter(EvaluationFlags::gradients, dst); 
  } 

// 这个函数在一个单元格批次范围内的所有单元格批次上循环，并调用上述函数。

  template <int dim, typename number> 
  void LaplaceOperator<dim, number>::do_cell_integral_range( 
    const MatrixFree<dim, number> &              matrix_free, 
    VectorType &                                 dst, 
    const VectorType &                           src, 
    const std::pair<unsigned int, unsigned int> &range) const 
  { 
    FECellIntegrator integrator(matrix_free, range); 

    for (unsigned cell = range.first; cell < range.second; ++cell) 
      { 
        integrator.reinit(cell); 

        do_cell_integral_global(integrator, dst, src); 
      } 
  } 

//  @sect3{Solver and preconditioner}  
// @sect4{Conjugate-gradient solver with multigrid preconditioner}  

// 这个函数用一连串提供的多网格对象来解决方程组。它的目的是为了尽可能的通用，因此有许多模板参数。

  template <typename VectorType, 
            int dim, 
            typename SystemMatrixType, 
            typename LevelMatrixType, 
            typename MGTransferType> 
  static void 
  mg_solve(SolverControl &            solver_control, 
           VectorType &               dst, 
           const VectorType &         src, 
           const MultigridParameters &mg_data, 
           const DoFHandler<dim> &    dof, 
           const SystemMatrixType &   fine_matrix, 
           const MGLevelObject<std::unique_ptr<LevelMatrixType>> &mg_matrices, 
           const MGTransferType &                                 mg_transfer) 
  { 
    AssertThrow(mg_data.coarse_solver.type == "cg_with_amg", 
                ExcNotImplemented()); 
    AssertThrow(mg_data.smoother.type == "chebyshev", ExcNotImplemented()); 

    const unsigned int min_level = mg_matrices.min_level(); 
    const unsigned int max_level = mg_matrices.max_level(); 

    using SmootherPreconditionerType = DiagonalMatrix<VectorType>; 
    using SmootherType               = PreconditionChebyshev<LevelMatrixType, 
                                               VectorType, 
                                               SmootherPreconditionerType>; 
    using PreconditionerType = PreconditionMG<dim, VectorType, MGTransferType>; 

// 我们在这里初始化电平运算符和切比雪夫平滑器。

    mg::Matrix<VectorType> mg_matrix(mg_matrices); 

    MGLevelObject<typename SmootherType::AdditionalData> smoother_data( 
      min_level, max_level); 

    for (unsigned int level = min_level; level <= max_level; level++) 
      { 
        smoother_data[level].preconditioner = 
          std::make_shared<SmootherPreconditionerType>(); 
        mg_matrices[level]->compute_inverse_diagonal( 
          smoother_data[level].preconditioner->get_vector()); 
        smoother_data[level].smoothing_range = mg_data.smoother.smoothing_range; 
        smoother_data[level].degree          = mg_data.smoother.degree; 
        smoother_data[level].eig_cg_n_iterations = 
          mg_data.smoother.eig_cg_n_iterations; 
      } 

    MGSmootherPrecondition<LevelMatrixType, SmootherType, VectorType> 
      mg_smoother; 
    mg_smoother.initialize(mg_matrices, smoother_data); 

// 接下来，我们初始化粗略网格求解器。我们使用共轭梯度法和AMG作为预处理程序。

    ReductionControl coarse_grid_solver_control(mg_data.coarse_solver.maxiter, 
                                                mg_data.coarse_solver.abstol, 
                                                mg_data.coarse_solver.reltol, 
                                                false, 
                                                false); 
    SolverCG<VectorType> coarse_grid_solver(coarse_grid_solver_control); 

    std::unique_ptr<MGCoarseGridBase<VectorType>> mg_coarse; 

    TrilinosWrappers::PreconditionAMG                 precondition_amg; 
    TrilinosWrappers::PreconditionAMG::AdditionalData amg_data; 
    amg_data.smoother_sweeps = mg_data.coarse_solver.smoother_sweeps; 
    amg_data.n_cycles        = mg_data.coarse_solver.n_cycles; 
    amg_data.smoother_type   = mg_data.coarse_solver.smoother_type.c_str(); 

    precondition_amg.initialize(mg_matrices[min_level]->get_system_matrix(), 
                                amg_data); 

    mg_coarse = 
      std::make_unique<MGCoarseGridIterativeSolver<VectorType, 
                                                   SolverCG<VectorType>, 
                                                   LevelMatrixType, 
                                                   decltype(precondition_amg)>>( 
        coarse_grid_solver, *mg_matrices[min_level], precondition_amg); 

// 最后，我们创建Multigrid对象，将其转换为预处理程序，并在共轭梯度求解器中使用它来解决线性方程组。

    Multigrid<VectorType> mg( 
      mg_matrix, *mg_coarse, mg_transfer, mg_smoother, mg_smoother); 

    PreconditionerType preconditioner(dof, mg, mg_transfer); 

    SolverCG<VectorType>(solver_control) 
      .solve(fine_matrix, dst, src, preconditioner); 
  } 

//  @sect4{Hybrid polynomial/geometric-global-coarsening multigrid preconditioner}  

// 上述函数处理给定的多网格对象序列的实际解决方案。这个函数创建了实际的多重网格层次，特别是运算符，以及作为MGTransferGlobalCoarsening对象的转移运算符。

  template <typename VectorType, typename OperatorType, int dim> 
  void solve_with_gmg(SolverControl &                  solver_control, 
                      const OperatorType &             system_matrix, 
                      VectorType &                     dst, 
                      const VectorType &               src, 
                      const MultigridParameters &      mg_data, 
                      const hp::MappingCollection<dim> mapping_collection, 
                      const DoFHandler<dim> &          dof_handler, 
                      const hp::QCollection<dim> &     quadrature_collection) 
  { 

// 为每个多网格层次创建一个DoFHandler和操作符，以及，创建转移操作符。为了能够设置运算符，我们需要一组DoFHandler，通过p或h的全局粗化来创建。

// 如果没有要求h-transfer，我们为`emplace_back()`函数提供一个空的删除器，因为我们的DoFHandler的Triangulation是一个外部字段，其析构器在其他地方被调用。

    MGLevelObject<DoFHandler<dim>>                     dof_handlers; 
    MGLevelObject<std::unique_ptr<OperatorType>>       operators; 
    MGLevelObject<MGTwoLevelTransfer<dim, VectorType>> transfers; 

    std::vector<std::shared_ptr<const Triangulation<dim>>> 
      coarse_grid_triangulations; 
    if (mg_data.transfer.perform_h_transfer) 
      coarse_grid_triangulations = 
        MGTransferGlobalCoarseningTools::create_geometric_coarsening_sequence( 
          dof_handler.get_triangulation()); 
    else 
      coarse_grid_triangulations.emplace_back( 
        const_cast<Triangulation<dim> *>(&(dof_handler.get_triangulation())), 
        [](auto &) {}); 

// 确定多栅格操作的总层数，并为所有层数分配足够的内存。

    const unsigned int n_h_levels = coarse_grid_triangulations.size() - 1; 

    const auto get_max_active_fe_degree = [&](const auto &dof_handler) { 
      unsigned int max = 0; 

      for (auto &cell : dof_handler.active_cell_iterators()) 
        if (cell->is_locally_owned()) 
          max = 
            std::max(max, dof_handler.get_fe(cell->active_fe_index()).degree); 

      return Utilities::MPI::max(max, MPI_COMM_WORLD); 
    }; 

    const unsigned int n_p_levels = 
      MGTransferGlobalCoarseningTools::create_polynomial_coarsening_sequence( 
        get_max_active_fe_degree(dof_handler), mg_data.transfer.p_sequence) 
        .size(); 

    std::map<unsigned int, unsigned int> fe_index_for_degree; 
    for (unsigned int i = 0; i < dof_handler.get_fe_collection().size(); ++i) 
      { 
        const unsigned int degree = dof_handler.get_fe(i).degree; 
        Assert(fe_index_for_degree.find(degree) == fe_index_for_degree.end(), 
               ExcMessage("FECollection does not contain unique degrees.")); 
        fe_index_for_degree[degree] = i; 
      } 

    unsigned int minlevel   = 0; 
    unsigned int minlevel_p = n_h_levels; 
    unsigned int maxlevel   = n_h_levels + n_p_levels - 1; 

    dof_handlers.resize(minlevel, maxlevel); 
    operators.resize(minlevel, maxlevel); 
    transfers.resize(minlevel, maxlevel); 

// 从最小（最粗）到最大（最细）级别的循环，并相应地设置DoFHandler。我们从h层开始，在这里我们分布在越来越细的网格上的线性元素。

    for (unsigned int l = 0; l < n_h_levels; ++l) 
      { 
        dof_handlers[l].reinit(*coarse_grid_triangulations[l]); 
        dof_handlers[l].distribute_dofs(dof_handler.get_fe_collection()); 
      } 

// 在我们达到最细的网格后，我们将调整每一层的多项式度数。我们反向迭代我们的数据结构，从包含所有活动FE指数信息的最细网格开始。然后我们逐级降低每个单元的多项式度数。

    for (unsigned int i = 0, l = maxlevel; i < n_p_levels; ++i, --l) 
      { 
        dof_handlers[l].reinit(dof_handler.get_triangulation()); 

        if (l == maxlevel) // finest level 
          { 
            auto &dof_handler_mg = dof_handlers[l]; 

            auto cell_other = dof_handler.begin_active(); 
            for (auto &cell : dof_handler_mg.active_cell_iterators()) 
              { 
                if (cell->is_locally_owned()) 
                  cell->set_active_fe_index(cell_other->active_fe_index()); 
                cell_other++; 
              } 
          } 
        else // coarse level 
          { 
            auto &dof_handler_fine   = dof_handlers[l + 1]; 
            auto &dof_handler_coarse = dof_handlers[l + 0]; 

            auto cell_other = dof_handler_fine.begin_active(); 
            for (auto &cell : dof_handler_coarse.active_cell_iterators()) 
              { 
                if (cell->is_locally_owned()) 
                  { 
                    const unsigned int next_degree = 
                      MGTransferGlobalCoarseningTools:: 
                        create_next_polynomial_coarsening_degree( 
                          cell_other->get_fe().degree, 
                          mg_data.transfer.p_sequence); 
                    Assert(fe_index_for_degree.find(next_degree) != 
                             fe_index_for_degree.end(), 
                           ExcMessage("Next polynomial degree in sequence " 
                                      "does not exist in FECollection.")); 

                    cell->set_active_fe_index(fe_index_for_degree[next_degree]); 
                  } 
                cell_other++; 
              } 
          } 

        dof_handlers[l].distribute_dofs(dof_handler.get_fe_collection()); 
      } 

// 接下来，我们将在每个多重网格层面上创建所有额外需要的数据结构。这涉及到确定具有同质Dirichlet边界条件的约束，并像在活动层上一样建立运算器。

    MGLevelObject<AffineConstraints<typename VectorType::value_type>> 
      constraints(minlevel, maxlevel); 

    for (unsigned int level = minlevel; level <= maxlevel; ++level) 
      { 
        const auto &dof_handler = dof_handlers[level]; 
        auto &      constraint  = constraints[level]; 

        IndexSet locally_relevant_dofs; 
        DoFTools::extract_locally_relevant_dofs(dof_handler, 
                                                locally_relevant_dofs); 
        constraint.reinit(locally_relevant_dofs); 

        DoFTools::make_hanging_node_constraints(dof_handler, constraint); 
        VectorTools::interpolate_boundary_values(mapping_collection, 
                                                 dof_handler, 
                                                 0, 
                                                 Functions::ZeroFunction<dim>(), 
                                                 constraint); 
        constraint.close(); 

        VectorType dummy; 

        operators[level] = std::make_unique<OperatorType>(mapping_collection, 
                                                          dof_handler, 
                                                          quadrature_collection, 
                                                          constraint, 
                                                          dummy); 
      } 

//根据多网格求解器类的需要，在单个算子中设置网格间算子和收集转移算子。

    for (unsigned int level = minlevel; level < minlevel_p; ++level) 
      transfers[level + 1].reinit_geometric_transfer(dof_handlers[level + 1], 
                                                     dof_handlers[level], 
                                                     constraints[level + 1], 
                                                     constraints[level]); 

    for (unsigned int level = minlevel_p; level < maxlevel; ++level) 
      transfers[level + 1].reinit_polynomial_transfer(dof_handlers[level + 1], 
                                                      dof_handlers[level], 
                                                      constraints[level + 1], 
                                                      constraints[level]); 

    MGTransferGlobalCoarsening<dim, VectorType> transfer( 
      transfers, [&](const auto l, auto &vec) { 
        operators[l]->initialize_dof_vector(vec); 
      }); 

// 最后，继续用多网格法解决问题。

    mg_solve(solver_control, 
             dst, 
             src, 
             mg_data, 
             dof_handler, 
             system_matrix, 
             operators, 
             transfer); 
  } 

//  @sect3{The <code>LaplaceProblem</code> class template}  

// 现在，我们将最后声明这个程序的主类，它在随后的精炼函数空间上求解拉普拉斯方程。它的结构看起来很熟悉，因为它与  step-27  和  step-40  的主类类似。基本上只增加了两个。

// - 持有系统矩阵的SparseMatrix对象已经被MatrixFree公式中的LaplaceOperator类对象所取代。

// - 加入了一个 parallel::CellWeights, 的对象，它将帮助我们实现负载平衡。

  template <int dim> 
  class LaplaceProblem 
  { 
  public: 
    LaplaceProblem(const Parameters &parameters); 

    void run(); 

  private: 
    void initialize_grid(); 
    void setup_system(); 
    void print_diagnostics(); 
    void solve_system(); 
    void compute_indicators(); 
    void adapt_resolution(); 
    void output_results(const unsigned int cycle); 

    MPI_Comm mpi_communicator; 

    const Parameters prm; 

    parallel::distributed::Triangulation<dim> triangulation; 
    DoFHandler<dim>                           dof_handler; 

    hp::MappingCollection<dim> mapping_collection; 
    hp::FECollection<dim>      fe_collection; 
    hp::QCollection<dim>       quadrature_collection; 
    hp::QCollection<dim - 1>   face_quadrature_collection; 

    IndexSet locally_owned_dofs; 
    IndexSet locally_relevant_dofs; 

    AffineConstraints<double> constraints; 

    LaplaceOperator<dim, double>               laplace_operator; 
    LinearAlgebra::distributed::Vector<double> locally_relevant_solution; 
    LinearAlgebra::distributed::Vector<double> system_rhs; 

    std::unique_ptr<FESeries::Legendre<dim>>    legendre; 
    std::unique_ptr<parallel::CellWeights<dim>> cell_weights; 

    Vector<float> estimated_error_per_cell; 
    Vector<float> hp_decision_indicators; 

    ConditionalOStream pcout; 
    TimerOutput        computing_timer; 
  }; 

//  @sect3{The <code>LaplaceProblem</code> class implementation}  
// @sect4{Constructor}  

// 构造函数以一个初始化器列表开始，该列表看起来与  step-40  的列表相似。我们再次准备好ConditionalOStream对象，只允许第一个进程在控制台输出任何东西，并正确初始化计算计时器。

  template <int dim> 
  LaplaceProblem<dim>::LaplaceProblem(const Parameters &parameters) 
    : mpi_communicator(MPI_COMM_WORLD) 
    , prm(parameters) 
    , triangulation(mpi_communicator) 
    , dof_handler(triangulation) 
    , pcout(std::cout, 
            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)) 
    , computing_timer(mpi_communicator, 
                      pcout, 
                      TimerOutput::summary, 
                      TimerOutput::wall_times) 
  { 
    Assert(prm.min_h_level <= prm.max_h_level, 
           ExcMessage( 
             "Triangulation level limits have been incorrectly set up.")); 
    Assert(prm.min_p_degree <= prm.max_p_degree, 
           ExcMessage("FECollection degrees have been incorrectly set up.")); 

// 我们需要在构造函数的实际主体中为hp-functionality准备数据结构，并在参数结构的指定范围内为每个度数创建相应的对象。由于我们只处理非扭曲的矩形单元，在这种情况下，一个线性映射对象就足够了。

// 在参数结构中，我们为函数空间以合理的分辨率运行的层级提供范围。多网格算法需要在最粗的层次上使用线性元素。所以我们从最低的多项式度数开始，用连续的高度数填充集合，直到达到用户指定的最大值。

    mapping_collection.push_back(MappingQ1<dim>()); 

    for (unsigned int degree = 1; degree <= prm.max_p_degree; ++degree) 
      { 
        fe_collection.push_back(FE_Q<dim>(degree)); 
        quadrature_collection.push_back(QGauss<dim>(degree + 1)); 
        face_quadrature_collection.push_back(QGauss<dim - 1>(degree + 1)); 
      } 

// 由于我们的FECollection包含的有限元比我们想用于求解的有限元近似值要多，我们想限制活动FE指数可以操作的范围。为此，FECollection类允许注册一个层次结构，在p-精简和p-粗化的情况下，分别决定后续的和前面的有限元。 hp::Refinement 命名空间中的所有函数都会参考这个层次结构来确定未来的FE指数。我们将注册这样一个层次结构，它只对建议范围内的多项式程度的有限元起作用  <code>[min_p_degree, max_p_degree]</code>  。

    const unsigned int min_fe_index = prm.min_p_degree - 1; 
    fe_collection.set_hierarchy( 

   /*下一个_index=  */ 
      [](const typename hp::FECollection<dim> &fe_collection, 
         const unsigned int                    fe_index) -> unsigned int { 
        return ((fe_index + 1) < fe_collection.size()) ? fe_index + 1 : 
                                                         fe_index; 
      }, 
    /*上一页_index=  */ 
      [min_fe_index](const typename hp::FECollection<dim> &, 
                     const unsigned int fe_index) -> unsigned int { 
        Assert(fe_index >= min_fe_index, 
               ExcMessage("Finite element is not part of hierarchy!")); 
        return (fe_index > min_fe_index) ? fe_index - 1 : fe_index; 
      }); 

// 我们以默认配置初始化 FESeries::Legendre 对象，以便进行平滑度估计。

    legendre = std::make_unique<FESeries::Legendre<dim>>( 
      SmoothnessEstimator::Legendre::default_fe_series(fe_collection)); 

// 接下来的部分会很棘手。在执行细化的过程中，有几个hp-算法需要干扰三角形对象上的实际细化过程。我们通过将几个函数连接到 Triangulation::Signals: 信号，在实际细化过程中的不同阶段被调用，并触发所有连接的函数来做到这一点。我们需要这个功能来实现负载平衡和限制相邻单元的多项式度数。

// 对于前者，我们希望给每个单元分配一个权重，这个权重与它未来的有限元的自由度数成正比。该库提供了一个类 parallel::CellWeights ，允许在细化过程中的正确位置轻松地附加单个权重，即在所有细化和粗化标志被正确设置为hp-adaptation之后，以及在即将发生的负载平衡的重新划分之前。可以注册一些函数，这些函数将以  $a (n_\text{dofs})^b$  提供的一对参数的形式附加权重  $(a,b)$  。我们在下文中注册了这样一个函数。每个单元在创建时将被赋予一个恒定的权重，这个值是1000（见  Triangulation::Signals::cell_weight).  ）。

// 为了实现负载平衡，像我们使用的高效求解器应该与拥有的自由度数量成线性比例。此外，为了增加我们想要附加的权重的影响，确保单个权重将超过这个基础权重的数量级。我们相应地设置单元加权的参数。大的加权系数为 $10^6$ ，指数为 $1$  。

    cell_weights = std::make_unique<parallel::CellWeights<dim>>( 
      dof_handler, 
      parallel::CellWeights<dim>::ndofs_weighting( 
        {prm.weighting_factor, prm.weighting_exponent})); 

// 在h-adaptive应用中，我们通过限制相邻单元的细化水平的差异为1来确保2:1的网格平衡。通过下面代码片段中的第二个调用，我们将确保相邻单元的p级数也是如此：未来有限元的级数不允许相差超过指定的差值。函数 hp::Refinement::limit_p_level_difference 可以处理这个问题，但需要与并行环境中的一个非常特殊的信号相连。问题是，我们需要知道网格的实际细化情况，以便相应地设置未来的FE指数。由于我们要求p4est神谕进行细化，我们需要确保Triangulation已经先用神谕的适应标志进行了更新。 parallel::distributed::TemporarilyMatchRefineFlags 的实例化在其生命期内正是如此。因此，我们将在限制p级差之前创建这个类的对象，并将相应的lambda函数连接到信号 Triangulation::Signals::post_p4est_refinement, 上，该信号将在神谕被完善之后，但在三角法被完善之前被触发。此外，我们指定这个函数将被连接到信号的前面，以确保修改在连接到同一信号的任何其他函数之前进行。

    triangulation.signals.post_p4est_refinement.connect( 
      [&, min_fe_index]() { 
        const parallel::distributed::TemporarilyMatchRefineFlags<dim> 
          refine_modifier(triangulation); 
        hp::Refinement::limit_p_level_difference(dof_handler, 
                                                 prm.max_p_level_difference, 
                                                 /*包含=  */ min_fe_index);
      }, 
      boost::signals2::at_front); 
  } 

//  @sect4{LaplaceProblem::initialize_grid}  

// 对于L型域，我们可以使用 GridGenerator::hyper_L() 这个函数，如 step-50 中所演示的。然而在二维的情况下，该函数只去除第一象限，而在我们的方案中我们需要去除第四象限。因此，我们将使用一个不同的函数 GridGenerator::subdivided_hyper_L() ，它给我们更多的选择来创建网格。此外，我们在制定该函数时，也会生成一个三维网格：二维L型域基本上会在正Z方向上拉长1。

// 我们首先假装建立一个  GridGenerator::subdivided_hyper_rectangle().  我们需要提供的参数是左下角和右上角的点对象，以及基本网格在每个方向的重复次数。我们为前两个维度提供这些参数，对更高的第三维度单独处理。

// 为了创建一个L型域，我们需要去除多余的单元。为此，我们相应地指定 <code>cells_to_remove</code> 。我们希望从负方向的每一个单元格中移除一个单元格，但从正的x方向移除一个。

// 最后，我们提供与所提供的最小网格细化水平相对应的初始细化数。此外，我们相应地设置初始活动FE指数。

  template <int dim> 
  void LaplaceProblem<dim>::initialize_grid() 
  { 
    TimerOutput::Scope t(computing_timer, "initialize grid"); 

    std::vector<unsigned int> repetitions(dim); 
    Point<dim>                bottom_left, top_right; 
    for (unsigned int d = 0; d < dim; ++d) 
      if (d < 2) 
        { 
          repetitions[d] = 2; 
          bottom_left[d] = -1.; 
          top_right[d]   = 1.; 
        } 
      else 
        { 
          repetitions[d] = 1; 
          bottom_left[d] = 0.; 
          top_right[d]   = 1.; 
        } 

    std::vector<int> cells_to_remove(dim, 1); 
    cells_to_remove[0] = -1; 

    GridGenerator::subdivided_hyper_L( 
      triangulation, repetitions, bottom_left, top_right, cells_to_remove); 

    triangulation.refine_global(prm.min_h_level); 

    const unsigned int min_fe_index = prm.min_p_degree - 1; 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        cell->set_active_fe_index(min_fe_index); 
  } 

//  @sect4{LaplaceProblem::setup_system}  

// 这个函数看起来和 step-40 的函数完全一样，但是你会注意到没有系统矩阵以及围绕它的脚手架。相反，我们将在这里初始化 <code>laplace_operator</code> 中的MatrixFree公式。对于边界条件，我们将使用本教程前面介绍的Solution类。

  template <int dim> 
  void LaplaceProblem<dim>::setup_system() 
  { 
    TimerOutput::Scope t(computing_timer, "setup system"); 

    dof_handler.distribute_dofs(fe_collection); 

    locally_owned_dofs = dof_handler.locally_owned_dofs(); 
    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs); 

    locally_relevant_solution.reinit(locally_owned_dofs, 
                                     locally_relevant_dofs, 
                                     mpi_communicator); 
    system_rhs.reinit(locally_owned_dofs, mpi_communicator); 

    constraints.clear(); 
    constraints.reinit(locally_relevant_dofs); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    VectorTools::interpolate_boundary_values( 
      mapping_collection, dof_handler, 0, Solution<dim>(), constraints); 
    constraints.close(); 

    laplace_operator.reinit(mapping_collection, 
                            dof_handler, 
                            quadrature_collection, 
                            constraints, 
                            system_rhs); 
  } 

//  @sect4{LaplaceProblem::print_diagnostics}  

// 这是一个打印关于方程组及其划分的额外诊断的函数。除了通常的全局活动单元数和自由度外，我们还输出它们的局部等价物。为了规范输出，我们将用 Utilities::MPI::gather 操作将局部数量传达给第一个进程，然后由该进程输出所有信息。本地量的输出只限于前8个进程，以避免终端的杂乱。

// 此外，我们想打印数值离散化中的多项式度数的频率。由于这些信息只存储在本地，我们将计算本地拥有的单元上的有限元，随后通过 Utilities::MPI::sum. 进行交流。
  template <int dim> 
  void LaplaceProblem<dim>::print_diagnostics() 
  { 
    const unsigned int first_n_processes = 
      std::min<unsigned int>(8, 
                             Utilities::MPI::n_mpi_processes(mpi_communicator)); 
    const bool output_cropped = 
      first_n_processes < Utilities::MPI::n_mpi_processes(mpi_communicator); 

    { 
      pcout << "   Number of active cells:       " 
            << triangulation.n_global_active_cells() << std::endl 
            << "     by partition:              "; 

      std::vector<unsigned int> n_active_cells_per_subdomain = 
        Utilities::MPI::gather(mpi_communicator, 
                               triangulation.n_locally_owned_active_cells()); 
      for (unsigned int i = 0; i < first_n_processes; ++i) 
        pcout << ' ' << n_active_cells_per_subdomain[i]; 
      if (output_cropped) 
        pcout << " ..."; 
      pcout << std::endl; 
    } 

    { 
      pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
            << std::endl 
            << "     by partition:              "; 

      std::vector<types::global_dof_index> n_dofs_per_subdomain = 
        Utilities::MPI::gather(mpi_communicator, 
                               dof_handler.n_locally_owned_dofs()); 
      for (unsigned int i = 0; i < first_n_processes; ++i) 
        pcout << ' ' << n_dofs_per_subdomain[i]; 
      if (output_cropped) 
        pcout << " ..."; 
      pcout << std::endl; 
    } 

    { 
      std::vector<types::global_dof_index> n_constraints_per_subdomain = 
        Utilities::MPI::gather(mpi_communicator, constraints.n_constraints()); 

      pcout << "   Number of constraints:        " 
            << std::accumulate(n_constraints_per_subdomain.begin(), 
                               n_constraints_per_subdomain.end(), 
                               0) 
            << std::endl 
            << "     by partition:              "; 
      for (unsigned int i = 0; i < first_n_processes; ++i) 
        pcout << ' ' << n_constraints_per_subdomain[i]; 
      if (output_cropped) 
        pcout << " ..."; 
      pcout << std::endl; 
    } 

    { 
      std::vector<unsigned int> n_fe_indices(fe_collection.size(), 0); 
      for (const auto &cell : dof_handler.active_cell_iterators()) 
        if (cell->is_locally_owned()) 
          n_fe_indices[cell->active_fe_index()]++; 

      Utilities::MPI::sum(n_fe_indices, mpi_communicator, n_fe_indices); 

      pcout << "   Frequencies of poly. degrees:"; 
      for (unsigned int i = 0; i < fe_collection.size(); ++i) 
        if (n_fe_indices[i] > 0) 
          pcout << ' ' << fe_collection[i].degree << ":" << n_fe_indices[i]; 
      pcout << std::endl; 
    } 
  } 

//  @sect4{LaplaceProblem::solve_system}  

// 围绕解决方案的脚手架与  step-40  的类似。我们准备一个符合MatrixFree要求的向量，并收集本地相关的自由度，我们解决了方程系统。解决方法是通过前面介绍的函数进行的。

  template <int dim> 
  void LaplaceProblem<dim>::solve_system() 
  { 
    TimerOutput::Scope t(computing_timer, "solve system"); 

    LinearAlgebra::distributed::Vector<double> completely_distributed_solution; 
    laplace_operator.initialize_dof_vector(completely_distributed_solution); 

    SolverControl solver_control(system_rhs.size(), 
                                 prm.tolerance_factor * system_rhs.l2_norm()); 

    solve_with_gmg(solver_control, 
                   laplace_operator, 
                   completely_distributed_solution, 
                   system_rhs, 
                   prm.mg_data, 
                   mapping_collection, 
                   dof_handler, 
                   quadrature_collection); 

    pcout << "   Solved in " << solver_control.last_step() << " iterations." 
          << std::endl; 

    constraints.distribute(completely_distributed_solution); 

    locally_relevant_solution.copy_locally_owned_data_from( 
      completely_distributed_solution); 
    locally_relevant_solution.update_ghost_values(); 
  } 

//  @sect4{LaplaceProblem::compute_indicators}  

// 这个函数只包含其他教程中典型的 <code>refine_grid</code> 函数的一部分，在这个意义上是新的。在这里，我们将只计算与实际细化网格相适应的所有指标。我们这样做的目的是将所有的指标写到文件系统中，以便为以后储存。

// 由于我们处理的是一个椭圆问题，我们将再次利用KellyErrorEstimator，但有一点不同。修改底层面积分的缩放系数，使其取决于相邻元素的实际多项式程度，这对hp-adaptive应用是有利的  @cite davydov2017hp  。我们可以通过指定你所注意到的附加参数中的最后一个参数来做到这一点。其他的实际上只是默认的。

// 为了hp-adaptation的目的，我们将用教程介绍中的策略来计算平滑度估计，并使用 SmoothnessEstimator::Legendre. 中的实现 在参数结构中，我们将最小多项式度数设置为2，因为似乎平滑度估计算法在处理线性元素时有问题。

  template <int dim> 
  void LaplaceProblem<dim>::compute_indicators() 
  { 
    TimerOutput::Scope t(computing_timer, "compute indicators"); 

    estimated_error_per_cell.grow_or_shrink(triangulation.n_active_cells()); 
    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      face_quadrature_collection, 
      std::map<types::boundary_id, const Function<dim> *>(), 
      locally_relevant_solution, 
      estimated_error_per_cell, 
      /*component_mask=  */ 
      ComponentMask(), 
      /*coefficients=  */ 
      nullptr, 
      /*n_threads=*/
      numbers::invalid_unsigned_int,  
      /*subdomain_id=*/ 
      numbers::invalid_subdomain_id,  
      /*material_id=*/ 
      numbers::invalid_material_id,  
      /*策略=  */ 
      KellyErrorEstimator<dim>::Strategy::face_diameter_over_twice_max_degree); 

    hp_decision_indicators.grow_or_shrink(triangulation.n_active_cells()); 
    SmoothnessEstimator::Legendre::coefficient_decay(*legendre, 
                                                     dof_handler, 
                                                     locally_relevant_solution, 
                                                     hp_decision_indicators); 
  } 

//  @sect4{LaplaceProblem::adapt_resolution}  

// 有了之前计算出的指标，我们最终将标记所有单元进行适应，同时在这个函数中执行细化。和以前的教程一样，我们将使用 "固定数字 "策略，但现在是针对hp-adaptation。

  template <int dim> 
  void LaplaceProblem<dim>::adapt_resolution() 
  { 
    TimerOutput::Scope t(computing_timer, "adapt resolution"); 

// 首先，我们将根据每个单元的误差估计值来设置细化和粗化标志。这里没有什么新东西。

// 我们将使用在其他deal.II教程中阐述过的一般细化和粗化比例：使用固定数字策略，我们将标记所有单元中的30%进行细化，3%进行粗化，如参数结构中提供的。

    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number( 
      triangulation, 
      estimated_error_per_cell, 
      prm.refine_fraction, 
      prm.coarsen_fraction); 

// 接下来，我们将对hp-adaptation进行所有调整。我们想细化和粗化那些在上一步中被标记的单元，但需要决定是通过调整网格分辨率还是调整多项式程度来实现。

// 下一个函数调用根据之前计算的平滑度指标设置未来的FE指数，作为p-adaptation指标。这些指数将只设置在那些分配了细化或粗化标志的单元上。

// 对于p-adaptation分数，我们将采取一个有根据的猜测。由于我们只期望在我们的方案中出现一个单一的奇点，即在域的原点，而在其他任何地方都有一个平滑的解决方案，所以我们希望强烈倾向于使用p-adaptation而不是h-adaptation。这反映在我们对p-精简和p-粗化都选择了90%的分数。

    hp::Refinement::p_adaptivity_fixed_number(dof_handler, 
                                              hp_decision_indicators, 
                                              prm.p_refine_fraction, 
                                              prm.p_coarsen_fraction); 

// 在这个阶段，我们既有未来的FE指数，也有经典的细化和粗化标志，后者将由 Triangulation::execute_coarsening_and_refinement() 解释为h-适应性。我们希望只对细胞施加一种适应，这就是下一个函数将为我们解决的问题。简而言之，在分配有两种类型指标的单元格上，我们将倾向于p-适应的那一种，并删除h-适应的那一种。

    hp::Refinement::choose_p_over_h(dof_handler); 

// 设置完所有指标后，我们将删除那些超过参数结构中提供的水平范围的指定限制的指标。由于提供的有限元数量有限，这种限制自然会出现在p-adaptation中。此外，我们在构造函数中为p-adaptation注册了一个自定义层次结构。现在，我们需要像  step-31  中那样，在h-adaptive的上下文中手动完成。

// 我们将遍历指定的最小和最大层次上的所有单元格，并删除相应的标志。作为一种选择，我们也可以通过相应地设置未来的FE指数来标记这些单元的p适应性，而不是简单地清除细化和粗化的标志。

    Assert(triangulation.n_levels() >= prm.min_h_level + 1 && 
             triangulation.n_levels() <= prm.max_h_level + 1, 
           ExcInternalError()); 

    if (triangulation.n_levels() > prm.max_h_level) 
      for (const auto &cell : 
           triangulation.active_cell_iterators_on_level(prm.max_h_level)) 
        cell->clear_refine_flag(); 

    for (const auto &cell : 
         triangulation.active_cell_iterators_on_level(prm.min_h_level)) 
      cell->clear_coarsen_flag(); 

// 最后，我们就剩下执行粗化和细化了。在这里，不仅网格会被更新，而且所有以前的未来FE指数也会变得活跃。

// 记得我们在构造函数中为三角化信号附加了函数，将在这个函数调用中被触发。所以会有更多的事情发生：加权重新分区将被执行以确保负载平衡，以及我们将限制相邻单元之间的p级差。

    triangulation.execute_coarsening_and_refinement(); 
  } 

//  @sect4{LaplaceProblem::output_results}  

// 在并行应用中向文件系统写入结果的工作方式与  step-40  中完全相同。除了我们在整个教程中准备的数据容器外，我们还想写出网格上每个有限元的多项式程度，以及每个单元所属的子域。我们在这个函数的范围内为此准备必要的容器。

  template <int dim> 
  void LaplaceProblem<dim>::output_results(const unsigned int cycle) 
  { 
    TimerOutput::Scope t(computing_timer, "output results"); 

    Vector<float> fe_degrees(triangulation.n_active_cells()); 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        fe_degrees(cell->active_cell_index()) = cell->get_fe().degree; 

    Vector<float> subdomain(triangulation.n_active_cells()); 
    for (auto &subd : subdomain) 
      subd = triangulation.locally_owned_subdomain(); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(locally_relevant_solution, "solution"); 
    data_out.add_data_vector(fe_degrees, "fe_degree"); 
    data_out.add_data_vector(subdomain, "subdomain"); 
    data_out.add_data_vector(estimated_error_per_cell, "error"); 
    data_out.add_data_vector(hp_decision_indicators, "hp_indicator"); 
    data_out.build_patches(mapping_collection); 

    data_out.write_vtu_with_pvtu_record( 
      "./", "solution", cycle, mpi_communicator, 2, 1); 
  } 

//  @sect4{LaplaceProblem::run}  

// 实际的运行函数看起来又和  step-40  非常相似。唯一增加的是实际循环之前的括号内的部分。在这里，我们将预先计算Legendre变换矩阵。一般来说，每当需要某个矩阵时，这些矩阵将通过懒惰分配的方式进行实时计算。然而，出于计时的目的，我们希望在实际的时间测量开始之前，一次性地计算它们。因此，我们将把它们的计算指定为自己的范围。

  template <int dim> 
  void LaplaceProblem<dim>::run() 
  { 
    pcout << "Running with Trilinos on " 
          << Utilities::MPI::n_mpi_processes(mpi_communicator) 
          << " MPI rank(s)..." << std::endl; 

    { 
      pcout << "Calculating transformation matrices..." << std::endl; 
      TimerOutput::Scope t(computing_timer, "calculate transformation"); 
      legendre->precalculate_all_transformation_matrices(); 
    } 

    for (unsigned int cycle = 0; cycle < prm.n_cycles; ++cycle) 
      { 
        pcout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          initialize_grid(); 
        else 
          adapt_resolution(); 

        setup_system(); 

        print_diagnostics(); 

        solve_system(); 

        compute_indicators(); 

        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32) 
          output_results(cycle); 

        computing_timer.print_summary(); 
        computing_timer.reset(); 

        pcout << std::endl; 
      } 
  } 
} // namespace Step75 

//  @sect4{main()}  

// 最后一个函数是 <code>main</code> 函数，它将最终创建并运行一个LaplaceOperator实例。它的结构与其他大多数教程程序相似。

int main(int argc, char *argv[]) 
{ 
  try 
    { 
      using namespace dealii; 
      using namespace Step75; 

      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

      Parameters        prm; 
      LaplaceProblem<2> laplace_problem(prm); 
      laplace_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-76.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2020 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Martin Kronbichler, Peter Munch, David Schneider, 2020 
 */ 


// @sect3{Parameters and utility functions}  

//包括与 step-67 中相同的内容。

#include <deal.II/base/conditional_ostream.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/time_stepping.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/base/vectorization.h> 

#include <deal.II/distributed/tria.h> 

#include <deal.II/dofs/dof_handler.h> 

 
#include <deal.II/fe/fe_system.h> 

#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/tria_accessor.h> 
#include <deal.II/grid/tria_iterator.h> 

#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/la_parallel_vector.h> 

#include <deal.II/matrix_free/fe_evaluation.h> 
#include <deal.II/matrix_free/matrix_free.h> 
#include <deal.II/matrix_free/operators.h> 

#include <deal.II/numerics/data_out.h> 

#include <fstream> 
#include <iomanip> 
#include <iostream> 

// 一个新的包含，用于根据其边界ID对单元格进行分类。

#include <deal.II/matrix_free/tools.h> 

namespace Euler_DG 
{ 
  using namespace dealii; 

// 与  step-67  中的输入参数相同。

  constexpr unsigned int testcase             = 1; 
  constexpr unsigned int dimension            = 2; 
  constexpr unsigned int n_global_refinements = 2; 
  constexpr unsigned int fe_degree            = 5; 
  constexpr unsigned int n_q_points_1d        = fe_degree + 2; 

// 这个参数指定共享内存组的大小。目前，只有1和 numbers::invalid_unsigned_int 的值是可能的，这导致了内存功能可以被关闭，或者所有访问同一共享内存域的进程被分组。

  constexpr unsigned int group_size = numbers::invalid_unsigned_int; 

  using Number = double; 

// 这里，数据结构的类型被选择为矢量化。在默认情况下，使用VectorizedArray<Number>，也就是说，在给定的硬件上使用最高的指令集架构扩展，具有最大数量的向量通道。然而，人们可能会减少填充通道的数量，例如，通过编写 <code>using VectorizedArrayType = VectorizedArray<Number, 4></code> ，只处理4个单元。

  using VectorizedArrayType = VectorizedArray<Number>; 

// 以下参数没有改变。

  constexpr double gamma       = 1.4; 
  constexpr double final_time  = testcase == 0 ? 10 : 2.0; 
  constexpr double output_tick = testcase == 0 ? 1 : 0.05; 

  const double courant_number = 0.15 / std::pow(fe_degree, 1.5); 

// 指定对性能研究有用的最大时间步骤数。

  constexpr unsigned int max_time_steps = numbers::invalid_unsigned_int; 

// 与Runge-Kutta有关的函数从 step-67 复制过来，并稍作修改，以尽量减少全局矢量访问。

  enum LowStorageRungeKuttaScheme 
  { 
    stage_3_order_3, 
    stage_5_order_4, 
    stage_7_order_4, 
    stage_9_order_5, 
  }; 
  constexpr LowStorageRungeKuttaScheme lsrk_scheme = stage_5_order_4; 

  class LowStorageRungeKuttaIntegrator 
  { 
  public: 
    LowStorageRungeKuttaIntegrator(const LowStorageRungeKuttaScheme scheme) 
    { 
      TimeStepping::runge_kutta_method lsrk; 
      switch (scheme) 
        { 
          case stage_3_order_3: 
            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE3_ORDER3; 
            break; 
          case stage_5_order_4: 
            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE5_ORDER4; 
            break; 
          case stage_7_order_4: 
            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE7_ORDER4; 
            break; 
          case stage_9_order_5: 
            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE9_ORDER5; 
            break; 

          default: 
            AssertThrow(false, ExcNotImplemented()); 
        } 
      TimeStepping::LowStorageRungeKutta< 
        LinearAlgebra::distributed::Vector<Number>> 
                          rk_integrator(lsrk); 
      std::vector<double> ci; // not used 
      rk_integrator.get_coefficients(ai, bi, ci); 
    } 

    unsigned int n_stages() const 
    { 
      return bi.size(); 
    } 

    template <typename VectorType, typename Operator> 
    void perform_time_step(const Operator &pde_operator, 
                           const double    current_time, 
                           const double    time_step, 
                           VectorType &    solution, 
                           VectorType &    vec_ri, 
                           VectorType &    vec_ki) const 
    { 
      AssertDimension(ai.size() + 1, bi.size()); 

      vec_ki.swap(solution); 

      double sum_previous_bi = 0; 
      for (unsigned int stage = 0; stage < bi.size(); ++stage) 
        { 
          const double c_i = stage == 0 ? 0 : sum_previous_bi + ai[stage - 1]; 

          pde_operator.perform_stage(stage, 
                                     current_time + c_i * time_step, 
                                     bi[stage] * time_step, 
                                     (stage == bi.size() - 1 ? 
                                        0 : 
                                        ai[stage] * time_step), 
                                     (stage % 2 == 0 ? vec_ki : vec_ri), 
                                     (stage % 2 == 0 ? vec_ri : vec_ki), 
                                     solution); 

          if (stage > 0) 
            sum_previous_bi += bi[stage - 1]; 
        } 
    } 

  private: 
    std::vector<double> bi; 
    std::vector<double> ai; 
  }; 

// 来自  step-67  的欧拉特定实用函数。

  enum EulerNumericalFlux 
  { 
    lax_friedrichs_modified, 
    harten_lax_vanleer, 
  }; 
  constexpr EulerNumericalFlux numerical_flux_type = lax_friedrichs_modified; 

  template <int dim> 
  class ExactSolution : public Function<dim> 
  { 
  public: 
    ExactSolution(const double time) 
      : Function<dim>(dim + 2, time) 
    {} 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double ExactSolution<dim>::value(const Point<dim> & x, 
                                   const unsigned int component) const 
  { 
    const double t = this->get_time(); 

    switch (testcase) 
      { 
        case 0: 
          { 
            Assert(dim == 2, ExcNotImplemented()); 
            const double beta = 5; 

            Point<dim> x0; 
            x0[0] = 5.; 
            const double radius_sqr = 
              (x - x0).norm_square() - 2. * (x[0] - x0[0]) * t + t * t; 
            const double factor = 
              beta / (numbers::PI * 2) * std::exp(1. - radius_sqr); 
            const double density_log = std::log2( 
              std::abs(1. - (gamma - 1.) / gamma * 0.25 * factor * factor)); 
            const double density = std::exp2(density_log * (1. / (gamma - 1.))); 
            const double u       = 1. - factor * (x[1] - x0[1]); 
            const double v       = factor * (x[0] - t - x0[0]); 

            if (component == 0) 
              return density; 
            else if (component == 1) 
              return density * u; 
            else if (component == 2) 
              return density * v; 
            else 
              { 
                const double pressure = 
                  std::exp2(density_log * (gamma / (gamma - 1.))); 
                return pressure / (gamma - 1.) + 
                       0.5 * (density * u * u + density * v * v); 
              } 
          } 

        case 1: 
          { 
            if (component == 0) 
              return 1.; 
            else if (component == 1) 
              return 0.4; 
            else if (component == dim + 1) 
              return 3.097857142857143; 
            else 
              return 0.; 
          } 

        default: 
          Assert(false, ExcNotImplemented()); 
          return 0.; 
      } 
  } 

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, dim, Number> 
    euler_velocity(const Tensor<1, dim + 2, Number> &conserved_variables) 
  { 
    const Number inverse_density = Number(1.) / conserved_variables[0]; 

    Tensor<1, dim, Number> velocity; 
    for (unsigned int d = 0; d < dim; ++d) 
      velocity[d] = conserved_variables[1 + d] * inverse_density; 

    return velocity; 
  } 

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Number 
    euler_pressure(const Tensor<1, dim + 2, Number> &conserved_variables) 
  { 
    const Tensor<1, dim, Number> velocity = 
      euler_velocity<dim>(conserved_variables); 

    Number rho_u_dot_u = conserved_variables[1] * velocity[0]; 
    for (unsigned int d = 1; d < dim; ++d) 
      rho_u_dot_u += conserved_variables[1 + d] * velocity[d]; 

    return (gamma - 1.) * (conserved_variables[dim + 1] - 0.5 * rho_u_dot_u); 
  } 

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, dim + 2, Tensor<1, dim, Number>> 
    euler_flux(const Tensor<1, dim + 2, Number> &conserved_variables) 
  { 
    const Tensor<1, dim, Number> velocity = 
      euler_velocity<dim>(conserved_variables); 
    const Number pressure = euler_pressure<dim>(conserved_variables); 

    Tensor<1, dim + 2, Tensor<1, dim, Number>> flux; 
    for (unsigned int d = 0; d < dim; ++d) 
      { 
        flux[0][d] = conserved_variables[1 + d]; 
        for (unsigned int e = 0; e < dim; ++e) 
          flux[e + 1][d] = conserved_variables[e + 1] * velocity[d]; 
        flux[d + 1][d] += pressure; 
        flux[dim + 1][d] = 
          velocity[d] * (conserved_variables[dim + 1] + pressure); 
      } 

    return flux; 
  } 

  template <int n_components, int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, n_components, Number> 
    operator*(const Tensor<1, n_components, Tensor<1, dim, Number>> &matrix, 
              const Tensor<1, dim, Number> &                         vector) 
  { 
    Tensor<1, n_components, Number> result; 
    for (unsigned int d = 0; d < n_components; ++d) 
      result[d] = matrix[d] * vector; 
    return result; 
  } 

  template <int dim, typename Number> 
  inline DEAL_II_ALWAYS_INLINE // 
    Tensor<1, dim + 2, Number> 
    euler_numerical_flux(const Tensor<1, dim + 2, Number> &u_m, 
                         const Tensor<1, dim + 2, Number> &u_p, 
                         const Tensor<1, dim, Number> &    normal) 
  { 
    const auto velocity_m = euler_velocity<dim>(u_m); 
    const auto velocity_p = euler_velocity<dim>(u_p); 

    const auto pressure_m = euler_pressure<dim>(u_m); 
    const auto pressure_p = euler_pressure<dim>(u_p); 

    const auto flux_m = euler_flux<dim>(u_m); 
    const auto flux_p = euler_flux<dim>(u_p); 

    switch (numerical_flux_type) 
      { 
        case lax_friedrichs_modified: 
          { 
            const auto lambda = 
              0.5 * std::sqrt(std::max(velocity_p.norm_square() + 
                                         gamma * pressure_p * (1. / u_p[0]), 
                                       velocity_m.norm_square() + 
                                         gamma * pressure_m * (1. / u_m[0]))); 

            return 0.5 * (flux_m * normal + flux_p * normal) + 
                   0.5 * lambda * (u_m - u_p); 
          } 

        case harten_lax_vanleer: 
          { 
            const auto avg_velocity_normal = 
              0.5 * ((velocity_m + velocity_p) * normal); 
            const auto   avg_c = std::sqrt(std::abs( 
              0.5 * gamma * 
              (pressure_p * (1. / u_p[0]) + pressure_m * (1. / u_m[0])))); 
            const Number s_pos = 
              std::max(Number(), avg_velocity_normal + avg_c); 
            const Number s_neg = 
              std::min(Number(), avg_velocity_normal - avg_c); 
            const Number inverse_s = Number(1.) / (s_pos - s_neg); 

            return inverse_s * 
                   ((s_pos * (flux_m * normal) - s_neg * (flux_p * normal)) - 
                    s_pos * s_neg * (u_m - u_p)); 
          } 

        default: 
          { 
            Assert(false, ExcNotImplemented()); 
            return {}; 
          } 
      } 
  } 

// 来自  step-67  的通用实用函数。

  template <int dim, typename VectorizedArrayType> 
  VectorizedArrayType 
  evaluate_function(const Function<dim> &                  function, 
                    const Point<dim, VectorizedArrayType> &p_vectorized, 
                    const unsigned int                     component) 
  { 
    VectorizedArrayType result; 
    for (unsigned int v = 0; v < VectorizedArrayType::size(); ++v) 
      { 
        Point<dim> p; 
        for (unsigned int d = 0; d < dim; ++d) 
          p[d] = p_vectorized[d][v]; 
        result[v] = function.value(p, component); 
      } 
    return result; 
  } 

  template <int dim, typename VectorizedArrayType, int n_components = dim + 2> 
  Tensor<1, n_components, VectorizedArrayType> 
  evaluate_function(const Function<dim> &                  function, 
                    const Point<dim, VectorizedArrayType> &p_vectorized) 
  { 
    AssertDimension(function.n_components, n_components); 
    Tensor<1, n_components, VectorizedArrayType> result; 
    for (unsigned int v = 0; v < VectorizedArrayType::size(); ++v) 
      { 
        Point<dim> p; 
        for (unsigned int d = 0; d < dim; ++d) 
          p[d] = p_vectorized[d][v]; 
        for (unsigned int d = 0; d < n_components; ++d) 
          result[d][v] = function.value(p, d); 
      } 
    return result; 
  } 
// @sect3{Euler operator using a cell-centric loop and MPI-3.0 shared memory}  

//来自 step-67 的欧拉算子，有一些变化，详见下文。

  template <int dim, int degree, int n_points_1d> 
  class EulerOperator 
  { 
  public: 
    static constexpr unsigned int n_quadrature_points_1d = n_points_1d; 

    EulerOperator(TimerOutput &timer_output); 

    ~EulerOperator(); 

    void reinit(const Mapping<dim> &   mapping, 
                const DoFHandler<dim> &dof_handler); 

    void set_inflow_boundary(const types::boundary_id       boundary_id, 
                             std::unique_ptr<Function<dim>> inflow_function); 

    void set_subsonic_outflow_boundary( 
      const types::boundary_id       boundary_id, 
      std::unique_ptr<Function<dim>> outflow_energy); 

    void set_wall_boundary(const types::boundary_id boundary_id); 

    void set_body_force(std::unique_ptr<Function<dim>> body_force); 

    void 
    perform_stage(const unsigned int                                stage, 
                  const Number                                      cur_time, 
                  const Number                                      bi, 
                  const Number                                      ai, 
                  const LinearAlgebra::distributed::Vector<Number> &current_ri, 
                  LinearAlgebra::distributed::Vector<Number> &      vec_ki, 
                  LinearAlgebra::distributed::Vector<Number> &solution) const; 

    void project(const Function<dim> &                       function, 
                 LinearAlgebra::distributed::Vector<Number> &solution) const; 

    std::array<double, 3> compute_errors( 
      const Function<dim> &                             function, 
      const LinearAlgebra::distributed::Vector<Number> &solution) const; 

    double compute_cell_transport_speed( 
      const LinearAlgebra::distributed::Vector<Number> &solution) const; 

    void 
    initialize_vector(LinearAlgebra::distributed::Vector<Number> &vector) const; 

  private: 

// 包含子通信器的SubCommunicatorWrapper实例，我们需要将其传递给 MatrixFree::reinit() ，以便能够利用MPI-3.0的共享内存功能。

    MPI_Comm subcommunicator; 

    MatrixFree<dim, Number, VectorizedArrayType> data; 

    TimerOutput &timer; 

    std::map<types::boundary_id, std::unique_ptr<Function<dim>>> 
      inflow_boundaries; 
    std::map<types::boundary_id, std::unique_ptr<Function<dim>>> 
                                   subsonic_outflow_boundaries; 
    std::set<types::boundary_id>   wall_boundaries; 
    std::unique_ptr<Function<dim>> body_force; 
  }; 

// 新的构造函数，可以创建一个子通信器。用户可以通过全局参数group_size指定子通信器的大小。如果大小被设置为-1，一个共享内存域的所有MPI进程将被合并为一个组。指定的大小对于MatrixFree的共享内存能力的好处是决定性的，因此，设置为 <code>size</code> to <code>-1</code> 是一个合理的选择。通过设置 <code>1</code> ，用户明确地禁用了MatrixFree的MPI-3.0共享内存功能，而完全依赖MPI-2.0功能，如 <code>MPI_Isend</code> 和 <code>MPI_Irecv</code>  。

  template <int dim, int degree, int n_points_1d> 
  EulerOperator<dim, degree, n_points_1d>::EulerOperator(TimerOutput &timer) 
    : timer(timer) 
  { 
#if DEAL_II_MPI_VERSION_GTE(3, 0) 
    if (group_size == 1) 
      { 
        this->subcommunicator = MPI_COMM_SELF; 
      } 
    else if (group_size == numbers::invalid_unsigned_int) 
      { 
        const auto rank = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD); 

        MPI_Comm_split_type(MPI_COMM_WORLD, 
                            MPI_COMM_TYPE_SHARED, 
                            rank, 
                            MPI_INFO_NULL, 
                            &subcommunicator); 
      } 
    else 
      { 
        Assert(false, ExcNotImplemented()); 
      } 
#else 
    (void)subcommunicator; 
    (void)group_size; 
    this->subcommunicator = MPI_COMM_SELF; 
#endif 
  } 

// 新增负责释放子通信器的析构器。

  template <int dim, int degree, int n_points_1d> 
  EulerOperator<dim, degree, n_points_1d>::~EulerOperator() 
  { 
#ifdef DEAL_II_WITH_MPI 
    if (this->subcommunicator != MPI_COMM_SELF) 
      MPI_Comm_free(&subcommunicator); 
#endif 
  } 

// 修改了 reinit() 函数，以设置 MatrixFree 中的内部数据结构，使其可以被以单元为中心的循环使用，并使用 MPI-3.0 的共享内存功能。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::reinit( 
    const Mapping<dim> &   mapping, 
    const DoFHandler<dim> &dof_handler) 
  { 
    const std::vector<const DoFHandler<dim> *> dof_handlers = {&dof_handler}; 
    const AffineConstraints<double>            dummy; 
    const std::vector<const AffineConstraints<double> *> constraints = {&dummy}; 
    const std::vector<Quadrature<1>> quadratures = {QGauss<1>(n_q_points_1d), 
                                                    QGauss<1>(fe_degree + 1)}; 

    typename MatrixFree<dim, Number, VectorizedArrayType>::AdditionalData 
      additional_data; 
    additional_data.mapping_update_flags = 
      (update_gradients | update_JxW_values | update_quadrature_points | 
       update_values); 
    additional_data.mapping_update_flags_inner_faces = 
      (update_JxW_values | update_quadrature_points | update_normal_vectors | 
       update_values); 
    additional_data.mapping_update_flags_boundary_faces = 
      (update_JxW_values | update_quadrature_points | update_normal_vectors | 
       update_values); 
    additional_data.tasks_parallel_scheme = 
      MatrixFree<dim, Number, VectorizedArrayType>::AdditionalData::none; 

// 对单元格进行分类，使所有车道的每个面都有相同的边界ID。这在严格意义上是没有必要的，但是，可以在 EulerOperator::perform_stage() 中写出更简单的代码，不需要屏蔽，因为可以保证所有分组的单元格（在一个VectorizedArray中）也要对面进行完全相同的操作。

    MatrixFreeTools::categorize_by_boundary_ids(dof_handler.get_triangulation(), 
                                                additional_data); 

// 通过提供子通信器在MatrixFree中启用MPI-3.0共享内存功能。

    additional_data.communicator_sm = subcommunicator; 

    data.reinit( 
      mapping, dof_handlers, constraints, quadratures, additional_data); 
  } 

// 下面这个函数是做Runge--Kutta更新的整个阶段，并且是

// - 旁边的设置稍作修改

与 step-67 相比，本教程的核心内容是// --。

// 与 step-67 相比，我们没有依次执行平流步骤（使用 MatrixFree::loop()) 和反质量矩阵步骤（使用 MatrixFree::cell_loop()) ），而是在 MatrixFree::loop_cell_centric(). 中一次性评估所有内容。 这个函数期望在每个本地拥有的（宏）单元上执行一个单独的函数作为参数，这样我们就需要在该单元的所有面上循环，自行执行需要的积分步骤。

// 以下函数在很大程度上包含了 step-67 中的以下函数的副本，所以这里跳过了与弱形式的评估有关的评论。

// -  <code>EulerDG::EulerOperator::local_apply_cell</code>  

// -  <code>EulerDG::EulerOperator::local_apply_face</code>  

// -  <code>EulerDG::EulerOperator::local_apply_boundary_face</code>  

// -  <code>EulerDG::EulerOperator::local_apply_inverse_mass_matrix</code>  
  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::perform_stage( 
    const unsigned int                                stage, 
    const Number                                      current_time, 
    const Number                                      bi, 
    const Number                                      ai, 
    const LinearAlgebra::distributed::Vector<Number> &current_ri, 
    LinearAlgebra::distributed::Vector<Number> &      vec_ki, 
    LinearAlgebra::distributed::Vector<Number> &      solution) const 
  { 
    for (auto &i : inflow_boundaries) 
      i.second->set_time(current_time); 
    for (auto &i : subsonic_outflow_boundaries) 
      i.second->set_time(current_time); 

// 通过调用 MatrixFree::loop_cell_centric() 并提供一个包含单元、面和边界-面积分效果的lambda来运行以单元为中心的循环。

    data.template loop_cell_centric<LinearAlgebra::distributed::Vector<Number>, 
                                    LinearAlgebra::distributed::Vector<Number>>( 
      [&](const auto &data, auto &dst, const auto &src, const auto cell_range) { 
        using FECellIntegral = FEEvaluation<dim, 
                                            degree, 
                                            n_points_1d, 
                                            dim + 2, 
                                            Number, 
                                            VectorizedArrayType>; 
        using FEFaceIntegral = FEFaceEvaluation<dim, 
                                                degree, 
                                                n_points_1d, 
                                                dim + 2, 
                                                Number, 
                                                VectorizedArrayType>; 

        FECellIntegral phi(data); 
        FECellIntegral phi_temp(data); 
        FEFaceIntegral phi_m(data, true); 
        FEFaceIntegral phi_p(data, false); 

        Tensor<1, dim, VectorizedArrayType>     constant_body_force; 
        const Functions::ConstantFunction<dim> *constant_function = 
          dynamic_cast<Functions::ConstantFunction<dim> *>(body_force.get()); 

        if (constant_function) 
          constant_body_force = 
            evaluate_function<dim, VectorizedArrayType, dim>( 
              *constant_function, Point<dim, VectorizedArrayType>()); 

        const dealii::internal::EvaluatorTensorProduct< 
          dealii::internal::EvaluatorVariant::evaluate_evenodd, 
          dim, 
          n_points_1d, 
          n_points_1d, 
          VectorizedArrayType> 
          eval(AlignedVector<VectorizedArrayType>(), 
               data.get_shape_info().data[0].shape_gradients_collocation_eo, 
               AlignedVector<VectorizedArrayType>()); 

        AlignedVector<VectorizedArrayType> buffer(phi.static_n_q_points * 
                                                  phi.n_components); 

// 在所有单元格批次上循环。

        for (unsigned int cell = cell_range.first; cell < cell_range.second; 
             ++cell) 
          { 
            phi.reinit(cell); 

            if (ai != Number()) 
              phi_temp.reinit(cell); 

// 从全局矢量中读取数值并计算正交点的数值。

            if (ai != Number() && stage == 0) 
              { 
                phi.read_dof_values(src); 

                for (unsigned int i = 0; 
                     i < phi.static_dofs_per_component * (dim + 2); 
                     ++i) 
                  phi_temp.begin_dof_values()[i] = phi.begin_dof_values()[i]; 

                phi.evaluate(EvaluationFlags::values); 
              } 
            else 
              { 
                phi.gather_evaluate(src, EvaluationFlags::values); 
              } 

// 缓冲正交点的计算值，因为这些值在下一步被 FEEvaluation::submit_value() 所覆盖，但是，在后面的面积分中需要。

            for (unsigned int i = 0; i < phi.static_n_q_points * (dim + 2); ++i) 
              buffer[i] = phi.begin_values()[i]; 

// 在单元格正交点上应用单元格积分。也可参见来自  step-67  的函数  <code>EulerOperator::local_apply_cell()</code>  。

            for (unsigned int q = 0; q < phi.n_q_points; ++q) 
              { 
                const auto w_q = phi.get_value(q); 
                phi.submit_gradient(euler_flux<dim>(w_q), q); 
                if (body_force.get() != nullptr) 
                  { 
                    const Tensor<1, dim, VectorizedArrayType> force = 
                      constant_function ? 
                        constant_body_force : 
                        evaluate_function<dim, VectorizedArrayType, dim>( 
                          *body_force, phi.quadrature_point(q)); 

                    Tensor<1, dim + 2, VectorizedArrayType> forcing; 
                    for (unsigned int d = 0; d < dim; ++d) 
                      forcing[d + 1] = w_q[0] * force[d]; 
                    for (unsigned int d = 0; d < dim; ++d) 
                      forcing[dim + 1] += force[d] * w_q[d + 1]; 

                    phi.submit_value(forcing, q); 
                  } 
              } 

// 用正交点中的测试函数的梯度进行测试。我们跳过插值回到元素的支持点，因为我们首先收集单元格正交点的所有贡献，只在最后一步进行插值。

            { 
              auto *values_ptr   = phi.begin_values(); 
              auto *gradient_ptr = phi.begin_gradients(); 

              for (unsigned int c = 0; c < dim + 2; ++c) 
                { 
                  if (dim >= 1 && body_force.get() == nullptr) 
                    eval.template gradients<0, false, false>( 
                      gradient_ptr + phi.static_n_q_points * 0, values_ptr); 
                  else if (dim >= 1) 
                    eval.template gradients<0, false, true>( 
                      gradient_ptr + phi.static_n_q_points * 0, values_ptr); 
                  if (dim >= 2) 
                    eval.template gradients<1, false, true>( 
                      gradient_ptr + phi.static_n_q_points * 1, values_ptr); 
                  if (dim >= 3) 
                    eval.template gradients<2, false, true>( 
                      gradient_ptr + phi.static_n_q_points * 2, values_ptr); 

                  values_ptr += phi.static_n_q_points; 
                  gradient_ptr += phi.static_n_q_points * dim; 
                } 
            } 

// 在当前单元格的所有面上进行循环。

            for (unsigned int face = 0; 
                 face < GeometryInfo<dim>::faces_per_cell; 
                 ++face) 
              { 

// 确定当前面的边界ID。由于我们在设置MatrixFree时，保证了所有填充的车道都有相同的边界ID，我们可以选择第一个车道的边界ID。

                const auto boundary_ids = 
                  data.get_faces_by_cells_boundary_id(cell, face); 

                Assert(std::equal(boundary_ids.begin(), 
                                  boundary_ids.begin() + 
                                    data.n_active_entries_per_cell_batch(cell), 
                                  boundary_ids.begin()), 
                       ExcMessage("Boundary IDs of lanes differ.")); 

                const auto boundary_id = boundary_ids[0]; 

                phi_m.reinit(cell, face); 

// 通过简单的一维插值，将单元格正交点的值插到当前面的正交点上。

                internal::FEFaceNormalEvaluationImpl<dim, 
                                                     n_points_1d - 1, 
                                                     VectorizedArrayType>:: 
                  template interpolate_quadrature<true, false>( 
                    dim + 2, 
                    data.get_shape_info(), 
                    buffer.data(), 
                    phi_m.begin_values(), 
                    false, 
                    face); 

// 检查该面是内部面还是边界面，并根据这一信息选择不同的代码路径。

                if (boundary_id == numbers::internal_face_boundary_id) 
                  { 

// 处理和内部面。以下几行代码是对 step-67 中 <code>EulerDG::EulerOperator::local_apply_face</code> 函数的复制。

                    phi_p.reinit(cell, face); 
                    phi_p.gather_evaluate(src, EvaluationFlags::values); 

                    for (unsigned int q = 0; q < phi_m.n_q_points; ++q) 
                      { 
                        const auto numerical_flux = 
                          euler_numerical_flux<dim>(phi_m.get_value(q), 
                                                    phi_p.get_value(q), 
                                                    phi_m.get_normal_vector(q)); 
                        phi_m.submit_value(-numerical_flux, q); 
                      } 
                  } 
                else 
                  { 

// 处理一个边界面。下面这几行代码是对 step-67 中 <code>EulerDG::EulerOperator::local_apply_boundary_face</code> 函数的复制。

                    for (unsigned int q = 0; q < phi_m.n_q_points; ++q) 
                      { 
                        const auto w_m    = phi_m.get_value(q); 
                        const auto normal = phi_m.get_normal_vector(q); 

                        auto rho_u_dot_n = w_m[1] * normal[0]; 
                        for (unsigned int d = 1; d < dim; ++d) 
                          rho_u_dot_n += w_m[1 + d] * normal[d]; 

                        bool at_outflow = false; 

                        Tensor<1, dim + 2, VectorizedArrayType> w_p; 

                        if (wall_boundaries.find(boundary_id) != 
                            wall_boundaries.end()) 
                          { 
                            w_p[0] = w_m[0]; 
                            for (unsigned int d = 0; d < dim; ++d) 
                              w_p[d + 1] = 
                                w_m[d + 1] - 2. * rho_u_dot_n * normal[d]; 
                            w_p[dim + 1] = w_m[dim + 1]; 
                          } 
                        else if (inflow_boundaries.find(boundary_id) != 
                                 inflow_boundaries.end()) 
                          w_p = evaluate_function( 
                            *inflow_boundaries.find(boundary_id)->second, 
                            phi_m.quadrature_point(q)); 
                        else if (subsonic_outflow_boundaries.find( 
                                   boundary_id) != 
                                 subsonic_outflow_boundaries.end()) 
                          { 
                            w_p = w_m; 
                            w_p[dim + 1] = 
                              evaluate_function(*subsonic_outflow_boundaries 
                                                   .find(boundary_id) 
                                                   ->second, 
                                                phi_m.quadrature_point(q), 
                                                dim + 1); 
                            at_outflow = true; 
                          } 
                        else 
                          AssertThrow(false, 
                                      ExcMessage( 
                                        "Unknown boundary id, did " 
                                        "you set a boundary condition for " 
                                        "this part of the domain boundary?")); 

                        auto flux = euler_numerical_flux<dim>(w_m, w_p, normal); 

                        if (at_outflow) 
                          for (unsigned int v = 0; 
                               v < VectorizedArrayType::size(); 
                               ++v) 
                            { 
                              if (rho_u_dot_n[v] < -1e-12) 
                                for (unsigned int d = 0; d < dim; ++d) 
                                  flux[d + 1][v] = 0.; 
                            } 

                        phi_m.submit_value(-flux, q); 
                      } 
                  } 

// 通过正交评估与单元相关的局部积分，并通过简单的一维插值加入到单元贡献中。

                internal::FEFaceNormalEvaluationImpl<dim, 
                                                     n_points_1d - 1, 
                                                     VectorizedArrayType>:: 
                  template interpolate_quadrature<false, true>( 
                    dim + 2, 
                    data.get_shape_info(), 
                    phi_m.begin_values(), 
                    phi.begin_values(), 
                    false, 
                    face); 
              } 

//在单元格正交点中应用反质量矩阵。也请参见来自  <code>EulerDG::EulerOperator::local_apply_inverse_mass_matrix()</code>  的函数  step-67  。

            for (unsigned int q = 0; q < phi.static_n_q_points; ++q) 
              { 
                const auto factor = VectorizedArrayType(1.0) / phi.JxW(q); 
                for (unsigned int c = 0; c < dim + 2; ++c) 
                  phi.begin_values()[c * phi.static_n_q_points + q] = 
                    phi.begin_values()[c * phi.static_n_q_points + q] * factor; 
              } 

// 将数值从配位空间转换到原始高斯-洛巴托空间。

            internal::FEEvaluationImplBasisChange< 
              dealii::internal::EvaluatorVariant::evaluate_evenodd, 
              internal::EvaluatorQuantity::hessian, 
              dim, 
              degree + 1, 
              n_points_1d, 
              VectorizedArrayType, 
              VectorizedArrayType>::do_backward(dim + 2, 
                                                data.get_shape_info() 
                                                  .data[0] 
                                                  .inverse_shape_values_eo, 
                                                false, 
                                                phi.begin_values(), 
                                                phi.begin_dof_values()); 

// 执行Runge-Kutta更新并将结果写回全局向量。

            if (ai == Number()) 
              { 
                for (unsigned int q = 0; q < phi.static_dofs_per_cell; ++q) 
                  phi.begin_dof_values()[q] = bi * phi.begin_dof_values()[q]; 
                phi.distribute_local_to_global(solution); 
              } 
            else 
              { 
                if (stage != 0) 
                  phi_temp.read_dof_values(solution); 

                for (unsigned int q = 0; q < phi.static_dofs_per_cell; ++q) 
                  { 
                    const auto K_i = phi.begin_dof_values()[q]; 

                    phi.begin_dof_values()[q] = 
                      phi_temp.begin_dof_values()[q] + (ai * K_i); 

                    phi_temp.begin_dof_values()[q] += bi * K_i; 
                  } 
                phi.set_dof_values(dst); 
                phi_temp.set_dof_values(solution); 
              } 
          } 
      }, 
      vec_ki, 
      current_ri, 
      true, 
      MatrixFree<dim, Number, VectorizedArrayType>::DataAccessOnFaces::values); 
  } 

// 从这里开始， step-67 的代码没有改变。

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::initialize_vector( 
    LinearAlgebra::distributed::Vector<Number> &vector) const 
  { 
    data.initialize_dof_vector(vector); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_inflow_boundary( 
    const types::boundary_id       boundary_id, 
    std::unique_ptr<Function<dim>> inflow_function) 
  { 
    AssertThrow(subsonic_outflow_boundaries.find(boundary_id) == 
                    subsonic_outflow_boundaries.end() && 
                  wall_boundaries.find(boundary_id) == wall_boundaries.end(), 
                ExcMessage("You already set the boundary with id " + 
                           std::to_string(static_cast<int>(boundary_id)) + 
                           " to another type of boundary before now setting " + 
                           "it as inflow")); 
    AssertThrow(inflow_function->n_components == dim + 2, 
                ExcMessage("Expected function with dim+2 components")); 

    inflow_boundaries[boundary_id] = std::move(inflow_function); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_subsonic_outflow_boundary( 
    const types::boundary_id       boundary_id, 
    std::unique_ptr<Function<dim>> outflow_function) 
  { 
    AssertThrow(inflow_boundaries.find(boundary_id) == 
                    inflow_boundaries.end() && 
                  wall_boundaries.find(boundary_id) == wall_boundaries.end(), 
                ExcMessage("You already set the boundary with id " + 
                           std::to_string(static_cast<int>(boundary_id)) + 
                           " to another type of boundary before now setting " + 
                           "it as subsonic outflow")); 
    AssertThrow(outflow_function->n_components == dim + 2, 
                ExcMessage("Expected function with dim+2 components")); 

    subsonic_outflow_boundaries[boundary_id] = std::move(outflow_function); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_wall_boundary( 
    const types::boundary_id boundary_id) 
  { 
    AssertThrow(inflow_boundaries.find(boundary_id) == 
                    inflow_boundaries.end() && 
                  subsonic_outflow_boundaries.find(boundary_id) == 
                    subsonic_outflow_boundaries.end(), 
                ExcMessage("You already set the boundary with id " + 
                           std::to_string(static_cast<int>(boundary_id)) + 
                           " to another type of boundary before now setting " + 
                           "it as wall boundary")); 

    wall_boundaries.insert(boundary_id); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::set_body_force( 
    std::unique_ptr<Function<dim>> body_force) 
  { 
    AssertDimension(body_force->n_components, dim); 

    this->body_force = std::move(body_force); 
  } 

  template <int dim, int degree, int n_points_1d> 
  void EulerOperator<dim, degree, n_points_1d>::project( 
    const Function<dim> &                       function, 
    LinearAlgebra::distributed::Vector<Number> &solution) const 
  { 
    FEEvaluation<dim, degree, degree + 1, dim + 2, Number, VectorizedArrayType> 
      phi(data, 0, 1); 
    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, 
                                                   degree, 
                                                   dim + 2, 
                                                   Number, 
                                                   VectorizedArrayType> 
      inverse(phi); 
    solution.zero_out_ghost_values(); 
    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          phi.submit_dof_value(evaluate_function(function, 
                                                 phi.quadrature_point(q)), 
                               q); 
        inverse.transform_from_q_points_to_basis(dim + 2, 
                                                 phi.begin_dof_values(), 
                                                 phi.begin_dof_values()); 
        phi.set_dof_values(solution); 
      } 
  } 

  template <int dim, int degree, int n_points_1d> 
  std::array<double, 3> EulerOperator<dim, degree, n_points_1d>::compute_errors( 
    const Function<dim> &                             function, 
    const LinearAlgebra::distributed::Vector<Number> &solution) const 
  { 
    TimerOutput::Scope t(timer, "compute errors"); 
    double             errors_squared[3] = {}; 
    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number, VectorizedArrayType> 
      phi(data, 0, 0); 

    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        phi.gather_evaluate(solution, EvaluationFlags::values); 
        VectorizedArrayType local_errors_squared[3] = {}; 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            const auto error = 
              evaluate_function(function, phi.quadrature_point(q)) - 
              phi.get_value(q); 
            const auto JxW = phi.JxW(q); 

            local_errors_squared[0] += error[0] * error[0] * JxW; 
            for (unsigned int d = 0; d < dim; ++d) 
              local_errors_squared[1] += (error[d + 1] * error[d + 1]) * JxW; 
            local_errors_squared[2] += (error[dim + 1] * error[dim + 1]) * JxW; 
          } 
        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell); 
             ++v) 
          for (unsigned int d = 0; d < 3; ++d) 
            errors_squared[d] += local_errors_squared[d][v]; 
      } 

    Utilities::MPI::sum(errors_squared, MPI_COMM_WORLD, errors_squared); 

    std::array<double, 3> errors; 
    for (unsigned int d = 0; d < 3; ++d) 
      errors[d] = std::sqrt(errors_squared[d]); 

    return errors; 
  } 

  template <int dim, int degree, int n_points_1d> 
  double EulerOperator<dim, degree, n_points_1d>::compute_cell_transport_speed( 
    const LinearAlgebra::distributed::Vector<Number> &solution) const 
  { 
    TimerOutput::Scope t(timer, "compute transport speed"); 
    Number             max_transport = 0; 
    FEEvaluation<dim, degree, degree + 1, dim + 2, Number, VectorizedArrayType> 
      phi(data, 0, 1); 

    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell) 
      { 
        phi.reinit(cell); 
        phi.gather_evaluate(solution, EvaluationFlags::values); 
        VectorizedArrayType local_max = 0.; 
        for (unsigned int q = 0; q < phi.n_q_points; ++q) 
          { 
            const auto solution = phi.get_value(q); 
            const auto velocity = euler_velocity<dim>(solution); 
            const auto pressure = euler_pressure<dim>(solution); 

            const auto          inverse_jacobian = phi.inverse_jacobian(q); 
            const auto          convective_speed = inverse_jacobian * velocity; 
            VectorizedArrayType convective_limit = 0.; 
            for (unsigned int d = 0; d < dim; ++d) 
              convective_limit = 
                std::max(convective_limit, std::abs(convective_speed[d])); 

            const auto speed_of_sound = 
              std::sqrt(gamma * pressure * (1. / solution[0])); 

            Tensor<1, dim, VectorizedArrayType> eigenvector; 
            for (unsigned int d = 0; d < dim; ++d) 
              eigenvector[d] = 1.; 
            for (unsigned int i = 0; i < 5; ++i) 
              { 
                eigenvector = transpose(inverse_jacobian) * 
                              (inverse_jacobian * eigenvector); 
                VectorizedArrayType eigenvector_norm = 0.; 
                for (unsigned int d = 0; d < dim; ++d) 
                  eigenvector_norm = 
                    std::max(eigenvector_norm, std::abs(eigenvector[d])); 
                eigenvector /= eigenvector_norm; 
              } 
            const auto jac_times_ev   = inverse_jacobian * eigenvector; 
            const auto max_eigenvalue = std::sqrt( 
              (jac_times_ev * jac_times_ev) / (eigenvector * eigenvector)); 
            local_max = 
              std::max(local_max, 
                       max_eigenvalue * speed_of_sound + convective_limit); 
          } 

        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell); 
             ++v) 
          for (unsigned int d = 0; d < 3; ++d) 
            max_transport = std::max(max_transport, local_max[v]); 
      } 

    max_transport = Utilities::MPI::max(max_transport, MPI_COMM_WORLD); 

    return max_transport; 
  } 

 
  class EulerProblem 
  { 
  public: 
    EulerProblem(); 

    void run(); 

  private: 
    void make_grid_and_dofs(); 

    void output_results(const unsigned int result_number); 

    LinearAlgebra::distributed::Vector<Number> solution; 

 

#ifdef DEAL_II_WITH_P4EST 
    parallel::distributed::Triangulation<dim> triangulation; 
#else 
    Triangulation<dim> triangulation; 
#endif 

    FESystem<dim>        fe; 
    MappingQGeneric<dim> mapping; 
    DoFHandler<dim>      dof_handler; 

    TimerOutput timer; 

    EulerOperator<dim, fe_degree, n_q_points_1d> euler_operator; 

    double time, time_step; 

    class Postprocessor : public DataPostprocessor<dim> 
    { 
    public: 
      Postprocessor(); 

      virtual void evaluate_vector_field( 
        const DataPostprocessorInputs::Vector<dim> &inputs, 
        std::vector<Vector<double>> &computed_quantities) const override; 

      virtual std::vector<std::string> get_names() const override; 

      virtual std::vector< 
        DataComponentInterpretation::DataComponentInterpretation> 
      get_data_component_interpretation() const override; 

      virtual UpdateFlags get_needed_update_flags() const override; 

    private: 
      const bool do_schlieren_plot; 
    }; 
  }; 

  template <int dim> 
  EulerProblem<dim>::Postprocessor::Postprocessor() 
    : do_schlieren_plot(dim == 2) 
  {} 

  template <int dim> 
  void EulerProblem<dim>::Postprocessor::evaluate_vector_field( 
    const DataPostprocessorInputs::Vector<dim> &inputs, 
    std::vector<Vector<double>> &               computed_quantities) const 
  { 
    const unsigned int n_evaluation_points = inputs.solution_values.size(); 

    if (do_schlieren_plot == true) 
      Assert(inputs.solution_gradients.size() == n_evaluation_points, 
             ExcInternalError()); 

    Assert(computed_quantities.size() == n_evaluation_points, 
           ExcInternalError()); 
    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError()); 
    Assert(computed_quantities[0].size() == 
             dim + 2 + (do_schlieren_plot == true ? 1 : 0), 
           ExcInternalError()); 

    for (unsigned int q = 0; q < n_evaluation_points; ++q) 
      { 
        Tensor<1, dim + 2> solution; 
        for (unsigned int d = 0; d < dim + 2; ++d) 
          solution[d] = inputs.solution_values[q](d); 

        const double         density  = solution[0]; 
        const Tensor<1, dim> velocity = euler_velocity<dim>(solution); 
        const double         pressure = euler_pressure<dim>(solution); 

        for (unsigned int d = 0; d < dim; ++d) 
          computed_quantities[q](d) = velocity[d]; 
        computed_quantities[q](dim)     = pressure; 
        computed_quantities[q](dim + 1) = std::sqrt(gamma * pressure / density); 

        if (do_schlieren_plot == true) 
          computed_quantities[q](dim + 2) = 
            inputs.solution_gradients[q][0] * inputs.solution_gradients[q][0]; 
      } 
  } 

  template <int dim> 
  std::vector<std::string> EulerProblem<dim>::Postprocessor::get_names() const 
  { 
    std::vector<std::string> names; 
    for (unsigned int d = 0; d < dim; ++d) 
      names.emplace_back("velocity"); 
    names.emplace_back("pressure"); 
    names.emplace_back("speed_of_sound"); 

    if (do_schlieren_plot == true) 
      names.emplace_back("schlieren_plot"); 

    return names; 
  } 

  template <int dim> 
  std::vector<DataComponentInterpretation::DataComponentInterpretation> 
  EulerProblem<dim>::Postprocessor::get_data_component_interpretation() const 
  { 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      interpretation; 
    for (unsigned int d = 0; d < dim; ++d) 
      interpretation.push_back( 
        DataComponentInterpretation::component_is_part_of_vector); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 
    interpretation.push_back(DataComponentInterpretation::component_is_scalar); 

    if (do_schlieren_plot == true) 
      interpretation.push_back( 
        DataComponentInterpretation::component_is_scalar); 

    return interpretation; 
  } 

  template <int dim> 
  UpdateFlags EulerProblem<dim>::Postprocessor::get_needed_update_flags() const 
  { 
    if (do_schlieren_plot == true) 
      return update_values | update_gradients; 
    else 
      return update_values; 
  } 

  template <int dim> 
  EulerProblem<dim>::EulerProblem() 
    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0) 
#ifdef DEAL_II_WITH_P4EST 
    , triangulation(MPI_COMM_WORLD) 
#endif 
    , fe(FE_DGQ<dim>(fe_degree), dim + 2) 
    , mapping(fe_degree) 
    , dof_handler(triangulation) 
    , timer(pcout, TimerOutput::never, TimerOutput::wall_times) 
    , euler_operator(timer) 
    , time(0) 
    , time_step(0) 
  {} 

  template <int dim> 
  void EulerProblem<dim>::make_grid_and_dofs() 
  { 
    switch (testcase) 
      { 
        case 0: 
          { 
            Point<dim> lower_left; 
            for (unsigned int d = 1; d < dim; ++d) 
              lower_left[d] = -5; 

            Point<dim> upper_right; 
            upper_right[0] = 10; 
            for (unsigned int d = 1; d < dim; ++d) 
              upper_right[d] = 5; 

            GridGenerator::hyper_rectangle(triangulation, 
                                           lower_left, 
                                           upper_right); 
            triangulation.refine_global(2); 

            euler_operator.set_inflow_boundary( 
              0, std::make_unique<ExactSolution<dim>>(0)); 

            break; 
          } 

        case 1: 
          { 
            GridGenerator::channel_with_cylinder( 
              triangulation, 0.03, 1, 0, true); 

            euler_operator.set_inflow_boundary( 
              0, std::make_unique<ExactSolution<dim>>(0)); 
            euler_operator.set_subsonic_outflow_boundary( 
              1, std::make_unique<ExactSolution<dim>>(0)); 

            euler_operator.set_wall_boundary(2); 
            euler_operator.set_wall_boundary(3); 

            if (dim == 3) 
              euler_operator.set_body_force( 
                std::make_unique<Functions::ConstantFunction<dim>>( 
                  std::vector<double>({0., 0., -0.2}))); 

            break; 
          } 

        default: 
          Assert(false, ExcNotImplemented()); 
      } 

    triangulation.refine_global(n_global_refinements); 

    dof_handler.distribute_dofs(fe); 

    euler_operator.reinit(mapping, dof_handler); 
    euler_operator.initialize_vector(solution); 

    std::locale s = pcout.get_stream().getloc(); 
    pcout.get_stream().imbue(std::locale("")); 
    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs() 
          << " ( = " << (dim + 2) << " [vars] x " 
          << triangulation.n_global_active_cells() << " [cells] x " 
          << Utilities::pow(fe_degree + 1, dim) << " [dofs/cell/var] )" 
          << std::endl; 
    pcout.get_stream().imbue(s); 
  } 

  template <int dim> 
  void EulerProblem<dim>::output_results(const unsigned int result_number) 
  { 
    const std::array<double, 3> errors = 
      euler_operator.compute_errors(ExactSolution<dim>(time), solution); 
    const std::string quantity_name = testcase == 0 ? "error" : "norm"; 

    pcout << "Time:" << std::setw(8) << std::setprecision(3) << time 
          << ", dt: " << std::setw(8) << std::setprecision(2) << time_step 
          << ", " << quantity_name << " rho: " << std::setprecision(4) 
          << std::setw(10) << errors[0] << ", rho * u: " << std::setprecision(4) 
          << std::setw(10) << errors[1] << ", energy:" << std::setprecision(4) 
          << std::setw(10) << errors[2] << std::endl; 

    { 
      TimerOutput::Scope t(timer, "output"); 

      Postprocessor postprocessor; 
      DataOut<dim>  data_out; 

      DataOutBase::VtkFlags flags; 
      flags.write_higher_order_cells = true; 
      data_out.set_flags(flags); 

      data_out.attach_dof_handler(dof_handler); 
      { 
        std::vector<std::string> names; 
        names.emplace_back("density"); 
        for (unsigned int d = 0; d < dim; ++d) 
          names.emplace_back("momentum"); 
        names.emplace_back("energy"); 

        std::vector<DataComponentInterpretation::DataComponentInterpretation> 
          interpretation; 
        interpretation.push_back( 
          DataComponentInterpretation::component_is_scalar); 
        for (unsigned int d = 0; d < dim; ++d) 
          interpretation.push_back( 
            DataComponentInterpretation::component_is_part_of_vector); 
        interpretation.push_back( 
          DataComponentInterpretation::component_is_scalar); 

        data_out.add_data_vector(dof_handler, solution, names, interpretation); 
      } 
      data_out.add_data_vector(solution, postprocessor); 

      LinearAlgebra::distributed::Vector<Number> reference; 
      if (testcase == 0 && dim == 2) 
        { 
          reference.reinit(solution); 
          euler_operator.project(ExactSolution<dim>(time), reference); 
          reference.sadd(-1., 1, solution); 
          std::vector<std::string> names; 
          names.emplace_back("error_density"); 
          for (unsigned int d = 0; d < dim; ++d) 
            names.emplace_back("error_momentum"); 
          names.emplace_back("error_energy"); 

          std::vector<DataComponentInterpretation::DataComponentInterpretation> 
            interpretation; 
          interpretation.push_back( 
            DataComponentInterpretation::component_is_scalar); 
          for (unsigned int d = 0; d < dim; ++d) 
            interpretation.push_back( 
              DataComponentInterpretation::component_is_part_of_vector); 
          interpretation.push_back( 
            DataComponentInterpretation::component_is_scalar); 

          data_out.add_data_vector(dof_handler, 
                                   reference, 
                                   names, 
                                   interpretation); 
        } 

      Vector<double> mpi_owner(triangulation.n_active_cells()); 
      mpi_owner = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD); 
      data_out.add_data_vector(mpi_owner, "owner"); 

      data_out.build_patches(mapping, 
                             fe.degree, 
                             DataOut<dim>::curved_inner_cells); 

      const std::string filename = 
        "solution_" + Utilities::int_to_string(result_number, 3) + ".vtu"; 
      data_out.write_vtu_in_parallel(filename, MPI_COMM_WORLD); 
    } 
  } 

  template <int dim> 
  void EulerProblem<dim>::run() 
  { 
    { 
      const unsigned int n_vect_number = VectorizedArrayType::size(); 
      const unsigned int n_vect_bits   = 8 * sizeof(Number) * n_vect_number; 

      pcout << "Running with " 
            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) 
            << " MPI processes" << std::endl; 
      pcout << "Vectorization over " << n_vect_number << " " 
            << (std::is_same<Number, double>::value ? "doubles" : "floats") 
            << " = " << n_vect_bits << " bits (" 
            << Utilities::System::get_current_vectorization_level() << ")" 
            << std::endl; 
    } 

    make_grid_and_dofs(); 

    const LowStorageRungeKuttaIntegrator integrator(lsrk_scheme); 

    LinearAlgebra::distributed::Vector<Number> rk_register_1; 
    LinearAlgebra::distributed::Vector<Number> rk_register_2; 
    rk_register_1.reinit(solution); 
    rk_register_2.reinit(solution); 

    euler_operator.project(ExactSolution<dim>(time), solution); 

    double min_vertex_distance = std::numeric_limits<double>::max(); 
    for (const auto &cell : triangulation.active_cell_iterators()) 
      if (cell->is_locally_owned()) 
        min_vertex_distance = 
          std::min(min_vertex_distance, cell->minimum_vertex_distance()); 
    min_vertex_distance = 
      Utilities::MPI::min(min_vertex_distance, MPI_COMM_WORLD); 

    time_step = courant_number * integrator.n_stages() / 
                euler_operator.compute_cell_transport_speed(solution); 
    pcout << "Time step size: " << time_step 
          << ", minimal h: " << min_vertex_distance 
          << ", initial transport scaling: " 
          << 1. / euler_operator.compute_cell_transport_speed(solution) 
          << std::endl 
          << std::endl; 

    output_results(0); 

    unsigned int timestep_number = 0; 

    while (time < final_time - 1e-12 && timestep_number < max_time_steps) 
      { 
        ++timestep_number; 
        if (timestep_number % 5 == 0) 
          time_step = 
            courant_number * integrator.n_stages() / 
            Utilities::truncate_to_n_digits( 
              euler_operator.compute_cell_transport_speed(solution), 3); 

        { 
          TimerOutput::Scope t(timer, "rk time stepping total"); 
          integrator.perform_time_step(euler_operator, 
                                       time, 
                                       time_step, 
                                       solution, 
                                       rk_register_1, 
                                       rk_register_2); 
        } 

        time += time_step; 

        if (static_cast<int>(time / output_tick) != 
              static_cast<int>((time - time_step) / output_tick) || 
            time >= final_time - 1e-12) 
          output_results( 
            static_cast<unsigned int>(std::round(time / output_tick))); 
      } 

    timer.print_wall_time_statistics(MPI_COMM_WORLD); 
    pcout << std::endl; 
  } 

} // namespace Euler_DG 

int main(int argc, char **argv) 
{ 
  using namespace Euler_DG; 
  using namespace dealii; 

  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1); 

  try 
    { 
      deallog.depth_console(0); 

      EulerProblem<dimension> euler_problem; 
      euler_problem.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-77.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, Colorado State University, 2021. 
 * Based on step-15 by Sven Wetterauer, University of Heidelberg, 2012. 
 */ 


// @sect3{Include files}  

// 这个程序开始时和其他大多数程序一样，有众所周知的包含文件。与 step-15 程序相比，我们在这里所做的大部分工作都是从该程序中复制的，唯一不同的是包括头文件，我们从该文件中导入了SparseDirectUMFPACK类和KINSOL的实际接口。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/utilities.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/sparse_direct.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_accessor.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_q.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/solution_transfer.h> 

#include <deal.II/sundials/kinsol.h> 

#include <fstream> 
#include <iostream> 

namespace Step77 
{ 
  using namespace dealii; 
// @sect3{The <code>MinimalSurfaceProblem</code> class template}  

// 同样地，这个程序的主类基本上是  step-15  中的一个副本。然而，该类确实将雅各布（系统）矩阵（以及使用直接求解器对其进行因式分解）和残差的计算分成了不同的函数，原因已在介绍中列出。出于同样的原因，该类也有一个指向雅各布矩阵因式分解的指针，该指针在我们每次更新雅各布矩阵时被重置。

// （如果你想知道为什么程序对雅各布矩阵使用直接对象，而对因式分解使用指针。每次KINSOL要求更新雅各布矩阵时，我们可以简单地写`jacobian_matrix=0;`将其重置为一个空矩阵，然后我们可以再次填充。另一方面，SparseDirectUMFPACK类没有办法扔掉它的内容或用新的因式分解来替换它，所以我们使用一个指针。我们只是扔掉整个对象，并在我们有新的雅各布矩阵需要分解时创建一个新的对象。)

// 最后，该类有一个定时器变量，我们将用它来评估程序的不同部分需要多长时间，这样我们就可以评估KINSOL的不重建矩阵及其因式分解的倾向是否合理。我们将在下面的 "结果 "部分讨论这个问题。

  template <int dim> 
  class MinimalSurfaceProblem 
  { 
  public: 
    MinimalSurfaceProblem(); 
    void run(); 

  private: 
    void setup_system(const bool initial_step); 
    void solve(const Vector<double> &rhs, 
               Vector<double> &      solution, 
               const double          tolerance); 
    void refine_mesh(); 
    void output_results(const unsigned int refinement_cycle); 
    void set_boundary_values(); 
    void compute_and_factorize_jacobian(const Vector<double> &evaluation_point); 
    void compute_residual(const Vector<double> &evaluation_point, 
                          Vector<double> &      residual); 

    Triangulation<dim> triangulation; 

    DoFHandler<dim> dof_handler; 
    FE_Q<dim>       fe; 

    AffineConstraints<double> hanging_node_constraints; 

    SparsityPattern                      sparsity_pattern; 
    SparseMatrix<double>                 jacobian_matrix; 
    std::unique_ptr<SparseDirectUMFPACK> jacobian_matrix_factorization; 

    Vector<double> current_solution; 

    TimerOutput computing_timer; 
  }; 

//  @sect3{Boundary condition}  

// 实现边界值的类是对  step-15  的复制。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> &p, 
                                    const unsigned int /*component*/) const 
  { 
    return std::sin(2 * numbers::PI * (p[0] + p[1])); 
  } 
// @sect3{The <code>MinimalSurfaceProblem</code> class implementation}  
// @sect4{Constructor and set up functions}  

// 下面的几个函数也基本上是复制了 step-15 已经做的事情，所以没有什么可讨论的。

  template <int dim> 
  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem() 
    : dof_handler(triangulation) 
    , fe(1) 
    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times) 
  {} 

  template <int dim> 
  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step) 
  { 
    TimerOutput::Scope t(computing_timer, "set up"); 

    if (initial_step) 
      { 
        dof_handler.distribute_dofs(fe); 
        current_solution.reinit(dof_handler.n_dofs()); 

        hanging_node_constraints.clear(); 
        DoFTools::make_hanging_node_constraints(dof_handler, 
                                                hanging_node_constraints); 
        hanging_node_constraints.close(); 
      } 

    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, dsp); 

    hanging_node_constraints.condense(dsp); 

    sparsity_pattern.copy_from(dsp); 
    jacobian_matrix.reinit(sparsity_pattern); 
    jacobian_matrix_factorization.reset(); 
  } 

//  @sect4{Assembling and factorizing the Jacobian matrix}  

// 然后，下面的函数负责对雅各布矩阵进行组装和因子化。该函数的前半部分实质上是 step-15 的`assemble_system()`函数，只是它没有处理同时形成右手边的向量（即残差），因为我们并不总是要同时做这些操作。

// 我们把整个装配功能放在一个由大括号包围的代码块中，这样我们就可以用一个 TimerOutput::Scope 变量来衡量在这个代码块中花费了多少时间，不包括在这个函数中发生在匹配的闭合括号`}`之后的一切。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::compute_and_factorize_jacobian( 
    const Vector<double> &evaluation_point) 
  { 
    { 
      TimerOutput::Scope t(computing_timer, "assembling the Jacobian"); 

      std::cout << "  Computing Jacobian matrix" << std::endl; 

      const QGauss<dim> quadrature_formula(fe.degree + 1); 

      jacobian_matrix = 0; 

      FEValues<dim> fe_values(fe, 
                              quadrature_formula, 
                              update_gradients | update_quadrature_points | 
                                update_JxW_values); 

      const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
      const unsigned int n_q_points    = quadrature_formula.size(); 

      FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 

      std::vector<Tensor<1, dim>> evaluation_point_gradients(n_q_points); 

      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        { 
          cell_matrix = 0; 

          fe_values.reinit(cell); 

          fe_values.get_function_gradients(evaluation_point, 
                                           evaluation_point_gradients); 

          for (unsigned int q = 0; q < n_q_points; ++q) 
            { 
              const double coeff = 
                1.0 / std::sqrt(1 + evaluation_point_gradients[q] * 
                                      evaluation_point_gradients[q]); 

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    cell_matrix(i, j) += 
                      (((fe_values.shape_grad(i, q)    // ((\nabla \phi_i 
                         * coeff                       //   * a_n 
                         * fe_values.shape_grad(j, q)) //   * \nabla \phi_j) 
                        -                              //  - 
                        (fe_values.shape_grad(i, q)    //  (\nabla \phi_i 
                         * coeff * coeff * coeff       //   * a_n^3 
                         * 
                         (fe_values.shape_grad(j, q)       //   * (\nabla \phi_j 
                          * evaluation_point_gradients[q]) //      * \nabla u_n) 
                         * evaluation_point_gradients[q])) //   * \nabla u_n))) 
                       * fe_values.JxW(q));                // * dx 
                } 
            } 

          cell->get_dof_indices(local_dof_indices); 
          hanging_node_constraints.distribute_local_to_global(cell_matrix, 
                                                              local_dof_indices, 
                                                              jacobian_matrix); 
        } 

      std::map<types::global_dof_index, double> boundary_values; 
      VectorTools::interpolate_boundary_values(dof_handler, 
                                               0, 
                                               Functions::ZeroFunction<dim>(), 
                                               boundary_values); 
      Vector<double> dummy_solution(dof_handler.n_dofs()); 
      Vector<double> dummy_rhs(dof_handler.n_dofs()); 
      MatrixTools::apply_boundary_values(boundary_values, 
                                         jacobian_matrix, 
                                         dummy_solution, 
                                         dummy_rhs); 
    } 

// 该函数的后半部分是对计算出的矩阵进行因数分解。为此，我们首先创建一个新的SparseDirectUMFPACK对象，并将其分配给成员变量`jacobian_matrix_factorization`，同时销毁该指针之前指向的任何对象（如果有）。然后我们告诉该对象对雅各布系数进行分解。

// 如上所述，我们把这段代码放在大括号里，用一个计时器来评估这部分程序所需的时间。

// (严格来说，我们在这里完成后实际上不再需要矩阵了，我们可以把矩阵对象扔掉。一个旨在提高内存效率的代码会这样做，并且只在这个函数中创建矩阵对象，而不是作为周围类的成员变量。我们在这里省略了这一步，因为使用与以前的教程程序相同的编码风格可以培养对通用风格的熟悉，并有助于使这些教程程序更容易阅读)。

    { 
      TimerOutput::Scope t(computing_timer, "factorizing the Jacobian"); 

      std::cout << "  Factorizing Jacobian matrix" << std::endl; 

      jacobian_matrix_factorization = std::make_unique<SparseDirectUMFPACK>(); 
      jacobian_matrix_factorization->factorize(jacobian_matrix); 
    } 
  } 

//  @sect4{Computing the residual vector}  

// `assemble_system()`在 step-15 中用来做的第二部分是计算残差向量，也就是牛顿线性系统的右手向量。我们把这一点从前面的函数中分解出来，但如果你理解了 step-15 中`assemble_system()`的作用，下面的函数就会很容易理解。然而，重要的是，我们需要计算的残差不是围绕当前解向量线性化的，而是我们从KINSOL得到的任何东西。这对于诸如直线搜索这样的操作是必要的，我们想知道在不同的 $\alpha_k$ 值下，残差 $F(U^k + \alpha_k \delta U^K)$ 是多少；在这些情况下，KINSOL只是给我们函数 $F$ 的参数，然后我们在这时计算残差 $F(\cdot)$ 。

// 该函数在最后打印出如此计算的残差的规范，作为我们跟踪程序进展的一种方式。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::compute_residual( 
    const Vector<double> &evaluation_point, 
    Vector<double> &      residual) 
  { 
    TimerOutput::Scope t(computing_timer, "assembling the residual"); 

    std::cout << "  Computing residual vector..." << std::flush; 

    const QGauss<dim> quadrature_formula(fe.degree + 1); 
    FEValues<dim>     fe_values(fe, 
                            quadrature_formula, 
                            update_gradients | update_quadrature_points | 
                              update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double>              cell_residual(dofs_per_cell); 
    std::vector<Tensor<1, dim>> evaluation_point_gradients(n_q_points); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_residual = 0; 
        fe_values.reinit(cell); 

        fe_values.get_function_gradients(evaluation_point, 
                                         evaluation_point_gradients); 

        for (unsigned int q = 0; q < n_q_points; ++q) 
          { 
            const double coeff = 
              1.0 / std::sqrt(1 + evaluation_point_gradients[q] * 
                                    evaluation_point_gradients[q]); 

            for (unsigned int i = 0; i < dofs_per_cell; ++i) 
              cell_residual(i) = (fe_values.shape_grad(i, q) // \nabla \phi_i 
                                  * coeff                    // * a_n 
                                  * evaluation_point_gradients[q] // * u_n 
                                  * fe_values.JxW(q));            // * dx 
          } 

        cell->get_dof_indices(local_dof_indices); 
        for (unsigned int i = 0; i < dofs_per_cell; ++i) 
          residual(local_dof_indices[i]) += cell_residual(i); 
      } 

    hanging_node_constraints.condense(residual); 

    for (const types::global_dof_index i : 
         DoFTools::extract_boundary_dofs(dof_handler)) 
      residual(i) = 0; 

    for (const types::global_dof_index i : 
         DoFTools::extract_hanging_node_dofs(dof_handler)) 
      residual(i) = 0; 

    std::cout << " norm=" << residual.l2_norm() << std::endl; 
  } 

//  @sect4{Solving linear systems with the Jacobian matrix}  

// 接下来是实现用雅各布矩阵解线性系统的函数。由于我们在建立矩阵时已经对矩阵进行了因式分解，所以解决线性系统的方法就是将逆矩阵应用于给定的右侧向量。这就是我们在这里使用的 SparseDirectUMFPACK::vmult() 函数的作用。在这之后，我们必须确保我们也能解决解向量中的悬空节点的值，而这是用 AffineConstraints::distribute(). 来完成的。

// 该函数需要一个额外的，但未使用的参数`tolerance`，它表示我们必须解决线性系统的精确程度。这个参数的含义在介绍中结合 "Eisenstat Walker技巧 "进行了讨论，但由于我们使用的是直接求解器而不是迭代求解器，所以我们并没有利用这个机会只求解线性系统的不精确性。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::solve(const Vector<double> &rhs, 
                                         Vector<double> &      solution, 
                                         const double /*tolerance*/) 
  { 
    TimerOutput::Scope t(computing_timer, "linear system solve"); 

    std::cout << "  Solving linear system" << std::endl; 

    jacobian_matrix_factorization->vmult(solution, rhs); 

    hanging_node_constraints.distribute(solution); 
  } 

//  @sect4{Refining the mesh, setting boundary values, and generating graphical output}  

// 以下三个函数又是对  step-15  中的函数的简单复制。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::refine_mesh() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate( 
      dof_handler, 
      QGauss<dim - 1>(fe.degree + 1), 
      std::map<types::boundary_id, const Function<dim> *>(), 
      current_solution, 
      estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 

    triangulation.prepare_coarsening_and_refinement(); 

    SolutionTransfer<dim> solution_transfer(dof_handler); 
    solution_transfer.prepare_for_coarsening_and_refinement(current_solution); 

    triangulation.execute_coarsening_and_refinement(); 

    dof_handler.distribute_dofs(fe); 

    Vector<double> tmp(dof_handler.n_dofs()); 
    solution_transfer.interpolate(current_solution, tmp); 
    current_solution = std::move(tmp); 

    hanging_node_constraints.clear(); 

    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

    hanging_node_constraints.distribute(current_solution); 

    set_boundary_values(); 

    setup_system(/*initial_step=*/false); 
  } 

  template <int dim> 
  void MinimalSurfaceProblem<dim>::set_boundary_values() 
  { 
    std::map<types::global_dof_index, double> boundary_values; 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             BoundaryValues<dim>(), 
                                             boundary_values); 
    for (const auto &boundary_value : boundary_values) 
      current_solution(boundary_value.first) = boundary_value.second; 

    hanging_node_constraints.distribute(current_solution); 
  } 

  template <int dim> 
  void MinimalSurfaceProblem<dim>::output_results( 
    const unsigned int refinement_cycle) 
  { 
    TimerOutput::Scope t(computing_timer, "graphical output"); 

    DataOut<dim> data_out; 

 
    data_out.add_data_vector(current_solution, "solution"); 
    data_out.build_patches(); 

    const std::string filename = 
      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu"; 
    std::ofstream output(filename); 
    data_out.write_vtu(output); 
  } 

//  @sect4{The run() function and the overall logic of the program}  

// 这个程序中唯一**有趣的函数是驱动整个算法的函数，即从一个粗大的网格开始，做一些网格细化循环，并在每个网格上使用KINSOL来寻找我们从这个网格上离散化得到的非线性代数方程的解。上面的`refine_mesh()`函数可以确保一个网格上的解被用作下一个网格的起始猜测。我们还使用一个TimerOutput对象来测量每个网格上的每一次操作所花费的时间，并在每个周期开始时重置该计时器。

// 正如在介绍中所讨论的，没有必要特别精确地解决粗略网格上的问题，因为这些问题只能作为下一个网格的起始猜测来解决。因此，我们将在 $k$ 个网格细化周期中使用 $\tau=10^{-3} \frac{1}{10^k}$ 的目标公差。

// 所有这些都在这个函数的第一部分进行了编码。

  template <int dim> 
  void MinimalSurfaceProblem<dim>::run() 
  { 
    GridGenerator::hyper_ball(triangulation); 
    triangulation.refine_global(2); 

    setup_system(/*initial_step=*/true); 
    set_boundary_values(); 

    for (unsigned int refinement_cycle = 0; refinement_cycle < 6; 
         ++refinement_cycle) 
      { 
        computing_timer.reset(); 
        std::cout << "Mesh refinement step " << refinement_cycle << std::endl; 

        if (refinement_cycle != 0) 
          refine_mesh(); 

        const double target_tolerance = 1e-3 * std::pow(0.1, refinement_cycle); 
        std::cout << "  Target_tolerance: " << target_tolerance << std::endl 
                  << std::endl; 

// 这就是有趣的开始。在顶部，我们创建了KINSOL求解器对象，并给它提供了一个对象，该对象编码了一些额外的具体情况（其中我们只改变了我们想要达到的非线性容忍度；但你可能想看看 SUNDIALS::KINSOL::AdditionalData 类有哪些其他成员，并与它们一起玩）。

        { 
          typename SUNDIALS::KINSOL<Vector<double>>::AdditionalData 
            additional_data; 
          additional_data.function_tolerance = target_tolerance; 

          SUNDIALS::KINSOL<Vector<double>> nonlinear_solver(additional_data); 

// 然后，我们必须描述在介绍中已经提到的操作。从本质上讲，我们必须教KINSOL如何(i)将一个向量调整到正确的大小，(ii)计算残差向量，(iii)计算雅各布矩阵（在这期间我们也计算其因式分解），以及(iv)用雅各布矩阵解一个线性系统。

// 所有这四种操作都由 SUNDIALS::KINSOL 类的成员变量表示，这些成员变量的类型是 `std::function`, ，即它们是我们可以分配给一个函数的指针的对象，或者像我们在这里做的那样，一个 "lambda函数"，它接受相应的参数并返回相应的信息。按照惯例，KINSOL希望做一些不重要的事情的函数返回一个整数，其中0表示成功。事实证明，我们只需用25行代码就可以完成所有这些工作。

// 如果你不知道什么是 "lambda函数"，可以看看 step-12 或[wikipedia页面](https:en.wikipedia.org/wiki/Anonymous_function)关于这个问题。lambda函数的想法是，人们想用一组参数来定义一个函数，但(i)不使它成为一个命名的函数，因为通常情况下，该函数只在一个地方使用，似乎没有必要给它一个全局名称；(ii)该函数可以访问存在于定义它的地方的一些变量，包括成员变量。lambda函数的语法很笨拙，但最终还是很有用的）。)

// 在代码块的最后，我们告诉KINSOL去工作，解决我们的问题。从'residual'、'setup_jacobian'和'solve_jacobian_system'函数中调用的成员函数将向屏幕打印输出，使我们能够跟踪程序的进展情况。

          nonlinear_solver.reinit_vector = [&](Vector<double> &x) { 
            x.reinit(dof_handler.n_dofs()); 
          }; 

          nonlinear_solver.residual = 
            [&](const Vector<double> &evaluation_point, 
                Vector<double> &      residual) { 
              compute_residual(evaluation_point, residual); 

              return 0; 
            }; 

          nonlinear_solver.setup_jacobian = 
            [&](const Vector<double> &current_u, 
                const Vector<double> & /*current_f*/) { 
              compute_and_factorize_jacobian(current_u); 

              return 0; 
            }; 

          nonlinear_solver.solve_with_jacobian = [&](const Vector<double> &rhs, 
                                                     Vector<double> &      dst, 
                                                     const double tolerance) { 
            this->solve(rhs, dst, tolerance); 

            return 0; 
          }; 

          nonlinear_solver.solve(current_solution); 
        } 

// 剩下的就只是内务整理了。将数据写入文件，以便进行可视化，并显示收集到的时间摘要，以便我们可以解释每个操作花了多长时间，执行的频率如何，等等。

        output_results(refinement_cycle); 

        computing_timer.print_summary(); 

        std::cout << std::endl; 
      } 
  } 
} // namespace Step77 

int main() 
{ 
  try 
    { 
      using namespace Step77; 

      MinimalSurfaceProblem<2> laplace_problem_2d; 
      laplace_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 

CCTest_file/step-78.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Tyler Anderson, Colorado State University, 2021 
 */ 


// @sect3{Include files}  

// 程序以通常的包含文件开始，所有这些文件你现在应该都见过了。

#include <deal.II/base/convergence_table.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/utilities.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_accessor.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/grid/grid_out.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/tria_accessor.h> 
#include <deal.II/grid/tria_iterator.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/data_out_stack.h> 
#include <deal.II/numerics/error_estimator.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/solution_transfer.h> 
#include <deal.II/numerics/vector_tools.h> 

#include <fstream> 
#include <iostream> 

// 然后照例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入到我们将要工作的命名空间中。我们还定义了一个标识符，以便在 <code>MMS</code> 被定义时可以运行MMS代码。否则，该程序就会解决原来的问题。

namespace BlackScholesSolver 
{ 
  using namespace dealii; 

#define MMS 
// @sect3{Solution Class}  

// 在使用MMS进行测试时，这部分为已知的解决方案创建一个类。这里我们使用 $v(\tau,S) = -\tau^2 -S^2 + 6$ 作为解决方案。我们需要包括求解方程和梯度，以便进行H1半规范计算。

  template <int dim> 
  class Solution : public Function<dim> 
  { 
  public: 
    Solution(const double maturity_time); 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

    virtual Tensor<1, dim> 
    gradient(const Point<dim> & p, 
             const unsigned int component = 0) const override; 

  private: 
    const double maturity_time; 
  }; 

  template <int dim> 
  Solution<dim>::Solution(const double maturity_time) 
    : maturity_time(maturity_time) 
  { 
    Assert(dim == 1, ExcNotImplemented()); 
  } 

  template <int dim> 
  double Solution<dim>::value(const Point<dim> & p, 
                              const unsigned int component) const 
  { 
    return -Utilities::fixed_power<2, double>(p(component)) - 
           Utilities::fixed_power<2, double>(this->get_time()) + 6; 
  } 

  template <int dim> 
  Tensor<1, dim> Solution<dim>::gradient(const Point<dim> & p, 
                                         const unsigned int component) const 
  { 
    return Point<dim>(-2 * p(component)); 
  } 

//  @sect3{Equation Data}  

// 在下面的类和函数中，我们实现了定义这个问题的右手边和边界值，为此我们需要函数对象。右手边的选择是在介绍的最后讨论的。

// 首先，我们处理初始条件。

  template <int dim> 
  class InitialConditions : public Function<dim> 
  { 
  public: 
    InitialConditions(const double strike_price); 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

  private: 
    const double strike_price; 
  }; 

  template <int dim> 
  InitialConditions<dim>::InitialConditions(const double strike_price) 
    : strike_price(strike_price) 
  {} 

  template <int dim> 
  double InitialConditions<dim>::value(const Point<dim> & p, 
                                       const unsigned int component) const 
  { 
#ifdef MMS 
    return -Utilities::fixed_power<2, double>(p(component)) + 6; 
#else 
    return std::max(p(component) - strike_price, 0.); 
#endif 
  } 

// 接下来，我们处理左边的边界条件。

  template <int dim> 
  class LeftBoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double LeftBoundaryValues<dim>::value(const Point<dim> &, 
                                        const unsigned int /*component*/) const 
  { 
#ifdef MMS 
    return -Utilities::fixed_power<2, double>(this->get_time()) + 6; 
#else 
    return 0.; 
#endif 
  } 

// 然后，我们处理右边的边界条件。

  template <int dim> 
  class RightBoundaryValues : public Function<dim> 
  { 
  public: 
    RightBoundaryValues(const double strike_price, const double interest_rate); 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

  private: 
    const double strike_price; 
    const double interest_rate; 
  }; 

  template <int dim> 
  RightBoundaryValues<dim>::RightBoundaryValues(const double strike_price, 
                                                const double interest_rate) 
    : strike_price(strike_price) 
    , interest_rate(interest_rate) 
  {} 

  template <int dim> 
  double RightBoundaryValues<dim>::value(const Point<dim> & p, 
                                         const unsigned int component) const 
  { 
#ifdef MMS 
    return -Utilities::fixed_power<2, double>(p(component)) - 
           Utilities::fixed_power<2, double>(this->get_time()) + 6; 
#else 
    return (p(component) - strike_price) * 
           exp((-interest_rate) * (this->get_time())); 
#endif 
  } 

// 最后，我们处理右边的问题。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    RightHandSide(const double asset_volatility, const double interest_rate); 

    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

  private: 
    const double asset_volatility; 
    const double interest_rate; 
  }; 

  template <int dim> 
  RightHandSide<dim>::RightHandSide(const double asset_volatility, 
                                    const double interest_rate) 
    : asset_volatility(asset_volatility) 
    , interest_rate(interest_rate) 
  {} 

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & p, 
                                   const unsigned int component) const 
  { 
#ifdef MMS 
    return 2 * (this->get_time()) - 
           Utilities::fixed_power<2, double>(asset_volatility * p(component)) - 
           2 * interest_rate * Utilities::fixed_power<2, double>(p(component)) - 
           interest_rate * 
             (-Utilities::fixed_power<2, double>(p(component)) - 
              Utilities::fixed_power<2, double>(this->get_time()) + 6); 
#else 
    (void)p; 
    (void)component; 
    return 0.0; 
#endif 
  } 

//  @sect3{The <code>BlackScholes</code> Class}  

// 下一块是这个程序的主类的声明。这与 Step-26 的教程非常相似，只是做了一些修改。必须添加新的矩阵来计算A和B矩阵，以及介绍中提到的 $V_{diff}$ 向量。我们还定义了问题中使用的参数。



// -  <code>maximum_stock_price</code>  ：空间域的强加上限。这是允许的最大股票价格。

// -  <code>maturity_time</code>  ：时间域的上限。这是期权到期的时间。

// -  <code>asset_volatility</code>  ：股票价格的波动率。

// -  <code>interest_rate</code>  : 无风险利率。

// -  <code>strike_price</code>  ：买方在到期时可以选择购买股票的约定价格。

// 本程序与 step-26 之间的一些细微差别是创建了 <code>a_matrix</code> and the <code>b_matrix</code>  ，这在介绍中已经说明。然后，我们还需要存储当前时间、时间步长和当前时间步长的数字。接下来，我们将把输出存储到一个 <code>DataOutStack</code> 的变量中，因为我们将把每个时间的解分层在上面，以创建解流形。然后，我们有一个变量来存储当前的周期和我们在计算解决方案时将运行的周期数。循环是给定一个网格的一个完整的解决方案计算。我们在每个周期之间细化一次网格，以展示我们程序的收敛特性。最后，我们将收敛数据存储到一个收敛表中。

// 就成员函数而言，我们有一个函数可以计算每个周期的收敛信息，称为  <code>process_solution</code>  。这就像在  step-7  中所做的那样。

  template <int dim> 
  class BlackScholes 
  { 
  public: 
    BlackScholes(); 

    void run(); 

  private: 
    void setup_system(); 
    void solve_time_step(); 
    void refine_grid(); 
    void process_solution(); 
    void add_results_for_output(); 
    void write_convergence_table(); 

    const double maximum_stock_price; 
    const double maturity_time; 
    const double asset_volatility; 
    const double interest_rate; 
    const double strike_price; 

    Triangulation<dim> triangulation; 
    FE_Q<dim>          fe; 
    DoFHandler<dim>    dof_handler; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> mass_matrix; 
    SparseMatrix<double> laplace_matrix; 
    SparseMatrix<double> a_matrix; 
    SparseMatrix<double> b_matrix; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 

    double time; 
    double time_step; 

 
 
    const unsigned int n_time_steps; 

    DataOutStack<dim>        data_out_stack; 
    std::vector<std::string> solution_names; 

    ConvergenceTable convergence_table; 
  }; 
// @sect3{The <code>BlackScholes</code> Implementation}  

// 现在，我们进入主类的实现阶段。我们将为问题中使用的各种参数设置数值。选择这些是因为它们是这些参数的相当正常的值。尽管股票价格在现实中没有上限（事实上是无限的），但我们规定了一个上限，即行权价格的两倍。两倍于行权价的选择有些武断，但它足够大，可以看到解决方案的有趣部分。

  template <int dim> 
  BlackScholes<dim>::BlackScholes() 
    : maximum_stock_price(1.) 
    , maturity_time(1.) 
    , asset_volatility(.2) 
    , interest_rate(0.05) 
    , strike_price(0.5) 
    , fe(1) 
    , dof_handler(triangulation) 
    , time(0.0) 
    , theta(0.5) 
    , n_cycles(4) 
    , n_time_steps(5000) 
  { 
    Assert(dim == 1, ExcNotImplemented()); 
  } 
// @sect4{<code>BlackScholes::setup_system</code>}  

// 下一个函数设置了DoFHandler对象，计算了约束条件，并将线性代数对象设置为正确的大小。我们还在这里通过调用库中的一个函数来计算质量矩阵。接下来我们将计算其他三个矩阵，因为这些矩阵需要 "手工 "计算。

// 注意，时间步长在这里被初始化，因为计算时间步长需要成熟的时间。

  template <int dim> 
  void BlackScholes<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 

    time_step = maturity_time / n_time_steps; 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    constraints.close(); 
    DynamicSparsityPattern dsp(dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    constraints, 
                                    /*keep_constrained_dofs =  */ true);

    sparsity_pattern.copy_from(dsp); 

    mass_matrix.reinit(sparsity_pattern); 
    laplace_matrix.reinit(sparsity_pattern); 
    a_matrix.reinit(sparsity_pattern); 
    b_matrix.reinit(sparsity_pattern); 
    system_matrix.reinit(sparsity_pattern); 

    MatrixCreator::create_mass_matrix(dof_handler, 
                                      QGauss<dim>(fe.degree + 1), 
                                      mass_matrix); 

// 下面是创建非恒定系数的拉普拉斯矩阵的代码。这与介绍中的矩阵D相对应。这个非恒定系数在 <code>current_coefficient</code> 变量中表示。

    const unsigned int dofs_per_cell = fe.dofs_per_cell; 
    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    QGauss<dim>        quadrature_formula(fe.degree + 1); 
    FEValues<dim>      fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0.; 
        fe_values.reinit(cell); 
        for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
          { 
            const double current_coefficient = 
              fe_values.quadrature_point(q_index).square(); 
            for (const unsigned int i : fe_values.dof_indices()) 
              { 
                for (const unsigned int j : fe_values.dof_indices()) 
                  cell_matrix(i, j) += 
                    (current_coefficient *              // (x_q)^2 
                     fe_values.shape_grad(i, q_index) * // grad phi_i(x_q) 
                     fe_values.shape_grad(j, q_index) * // grad phi_j(x_q) 
                     fe_values.JxW(q_index));           // dx 
              } 
          } 
        cell->get_dof_indices(local_dof_indices); 
        for (const unsigned int i : fe_values.dof_indices()) 
          { 
            for (const unsigned int j : fe_values.dof_indices()) 
              laplace_matrix.add(local_dof_indices[i], 
                                 local_dof_indices[j], 
                                 cell_matrix(i, j)); 
          } 
      } 

// 现在我们将创建A矩阵。下面是创建矩阵A的代码，在介绍中已经讨论过。非恒定系数再次用 <code>current_coefficient</code> 这个变量表示。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0.; 
        fe_values.reinit(cell); 
        for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
          { 
            const Tensor<1, dim> current_coefficient = 
              fe_values.quadrature_point(q_index); 
            for (const unsigned int i : fe_values.dof_indices()) 
              { 
                for (const unsigned int j : fe_values.dof_indices()) 
                  { 
                    cell_matrix(i, j) += 
                      (current_coefficient *               // x_q 
                       fe_values.shape_grad(i, q_index) *  // grad phi_i(x_q) 
                       fe_values.shape_value(j, q_index) * // phi_j(x_q) 
                       fe_values.JxW(q_index));            // dx 
                  } 
              } 
          } 
        cell->get_dof_indices(local_dof_indices); 
        for (const unsigned int i : fe_values.dof_indices()) 
          { 
            for (const unsigned int j : fe_values.dof_indices()) 
              a_matrix.add(local_dof_indices[i], 
                           local_dof_indices[j], 
                           cell_matrix(i, j)); 
          } 
      } 

// 最后我们将创建矩阵B。下面是创建矩阵B的代码，在介绍中已经讨论过。非恒定系数再次用 <code>current_coefficient</code> 这个变量表示。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0.; 
        fe_values.reinit(cell); 
        for (const unsigned int q_index : fe_values.quadrature_point_indices()) 
          { 
            const Tensor<1, dim> current_coefficient = 
              fe_values.quadrature_point(q_index); 
            for (const unsigned int i : fe_values.dof_indices()) 
              { 
                for (const unsigned int j : fe_values.dof_indices()) 
                  cell_matrix(i, j) += 
                    (current_coefficient *               // x_q 
                     fe_values.shape_value(i, q_index) * // phi_i(x_q) 
                     fe_values.shape_grad(j, q_index) *  // grad phi_j(x_q) 
                     fe_values.JxW(q_index));            // dx 
              } 
          } 
        cell->get_dof_indices(local_dof_indices); 
        for (const unsigned int i : fe_values.dof_indices()) 
          { 
            for (const unsigned int j : fe_values.dof_indices()) 
              b_matrix.add(local_dof_indices[i], 
                           local_dof_indices[j], 
                           cell_matrix(i, j)); 
          } 
      } 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 
// @sect4{<code>BlackScholes::solve_time_step</code>}  

// 下一个函数是解决单个时间步长的实际线性系统的函数。这里唯一有趣的是，我们建立的矩阵是对称正定的，所以我们可以使用共轭梯度法。

  template <int dim> 
  void BlackScholes<dim>::solve_time_step() 
  { 
    SolverControl                          solver_control(1000, 1e-12); 
    SolverCG<Vector<double>>               cg(solver_control); 
    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.0); 
    cg.solve(system_matrix, solution, system_rhs, preconditioner); 
    constraints.distribute(solution); 
  } 
// @sect4{<code>BlackScholes::add_results_for_output</code>}  

// 这是简单地将解决方案的碎片拼接起来的功能。为此，我们在每个时间段创建一个新的层，然后添加该时间段的解决方案向量。然后，该函数使用'build_patches'将其与旧的解决方案缝合在一起。

  template <int dim> 
  void BlackScholes<dim>::add_results_for_output() 
  { 
    data_out_stack.new_parameter_value(time, time_step); 
    data_out_stack.attach_dof_handler(dof_handler); 
    data_out_stack.add_data_vector(solution, solution_names); 
    data_out_stack.build_patches(2); 
    data_out_stack.finish_parameter_value(); 
  } 
// @sect4{<code>BlackScholes::refine_grid</code>}  

// 对于我们所做的全局细化来说，有一个函数是有些不必要的。之所以有这个函数，是为了允许以后有可能进行适应性细化。

  template <int dim> 
  void BlackScholes<dim>::refine_grid() 
  { 
    triangulation.refine_global(1); 
  } 
// @sect4{<code>BlackScholes::process_solution</code>}  

// 这就是我们计算收敛和误差数据的地方，以评估程序的有效性。在这里，我们计算 $L^2$  、 $H^1$  和 $L^{\infty}$ 的准则。

  template <int dim> 
  void BlackScholes<dim>::process_solution() 
  { 
    Solution<dim> sol(maturity_time); 
    sol.set_time(time); 
    Vector<float> difference_per_cell(triangulation.n_active_cells()); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      sol, 
                                      difference_per_cell, 
                                      QGauss<dim>(fe.degree + 1), 
                                      VectorTools::L2_norm); 
    const double L2_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::L2_norm); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      sol, 
                                      difference_per_cell, 
                                      QGauss<dim>(fe.degree + 1), 
                                      VectorTools::H1_seminorm); 
    const double H1_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::H1_seminorm); 
    const QTrapezoid<1>  q_trapezoid; 
    const QIterated<dim> q_iterated(q_trapezoid, fe.degree * 2 + 1); 
    VectorTools::integrate_difference(dof_handler, 
                                      solution, 
                                      sol, 
                                      difference_per_cell, 
                                      q_iterated, 
                                      VectorTools::Linfty_norm); 
    const double Linfty_error = 
      VectorTools::compute_global_error(triangulation, 
                                        difference_per_cell, 
                                        VectorTools::Linfty_norm); 
    const unsigned int n_active_cells = triangulation.n_active_cells(); 
    const unsigned int n_dofs         = dof_handler.n_dofs(); 
    convergence_table.add_value("cells", n_active_cells); 
    convergence_table.add_value("dofs", n_dofs); 
    convergence_table.add_value("L2", L2_error); 
    convergence_table.add_value("H1", H1_error); 
    convergence_table.add_value("Linfty", Linfty_error); 
  } 
// @sect4{<code>BlackScholes::write_convergence_table</code> }  

// 接下来的部分是建立收敛和误差表。通过这个，我们需要设置如何输出在  <code>BlackScholes::process_solution</code>  期间计算的数据。首先，我们将创建标题并正确设置单元格。在这期间，我们还将规定结果的精度。然后，我们将根据  $L^2$  、  $H^1$  和  $L^{\infty}$  规范把计算出来的误差写到控制台和错误的LaTeX文件中。

  template <int dim> 
  void BlackScholes<dim>::write_convergence_table() 
  { 
    convergence_table.set_precision("L2", 3); 
    convergence_table.set_precision("H1", 3); 
    convergence_table.set_precision("Linfty", 3); 
    convergence_table.set_scientific("L2", true); 
    convergence_table.set_scientific("H1", true); 
    convergence_table.set_scientific("Linfty", true); 
    convergence_table.set_tex_caption("cells", "\\# cells"); 
    convergence_table.set_tex_caption("dofs", "\\# dofs"); 
    convergence_table.set_tex_caption("L2", "@f$L^2@f$-error"); 
    convergence_table.set_tex_caption("H1", "@f$H^1@f$-error"); 
    convergence_table.set_tex_caption("Linfty", "@f$L^\\infty@f$-error"); 
    convergence_table.set_tex_format("cells", "r"); 
    convergence_table.set_tex_format("dofs", "r"); 
    std::cout << std::endl; 
    convergence_table.write_text(std::cout); 
    std::string error_filename = "error"; 
    error_filename += "-global"; 
    error_filename += ".tex"; 
    std::ofstream error_table_file(error_filename); 
    convergence_table.write_tex(error_table_file); 

// 接下来，我们将制作收敛表。我们将再次把它写到控制台和收敛LaTeX文件中。

    convergence_table.add_column_to_supercolumn("cells", "n cells"); 
    std::vector<std::string> new_order; 
    new_order.emplace_back("n cells"); 
    new_order.emplace_back("H1"); 
    new_order.emplace_back("L2"); 
    convergence_table.set_column_order(new_order); 
    convergence_table.evaluate_convergence_rates( 
      "L2", ConvergenceTable::reduction_rate); 
    convergence_table.evaluate_convergence_rates( 
      "L2", ConvergenceTable::reduction_rate_log2); 
    convergence_table.evaluate_convergence_rates( 
      "H1", ConvergenceTable::reduction_rate); 
    convergence_table.evaluate_convergence_rates( 
      "H1", ConvergenceTable::reduction_rate_log2); 
    std::cout << std::endl; 
    convergence_table.write_text(std::cout); 
    std::string conv_filename = "convergence"; 
    conv_filename += "-global"; 
    switch (fe.degree) 
      { 
        case 1: 
          conv_filename += "-q1"; 
          break; 
        case 2: 
          conv_filename += "-q2"; 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 
    conv_filename += ".tex"; 
    std::ofstream table_file(conv_filename); 
    convergence_table.write_tex(table_file); 
  } 
// @sect4{<code>BlackScholes::run</code>}  

// 现在我们进入了程序的主要驱动部分。在这里我们要做的是在时间步数中循环往复，并在每次计算解向量的工作。在这里的顶部，我们设置初始细化值，然后创建一个网格。然后我们对这个网格进行一次细化。接下来，我们设置了data_out_stack对象来存储我们的解决方案。最后，我们启动一个for循环来循环处理这些循环。这让我们为每一个连续的网格细化重新计算出一个解决方案。在每次迭代开始时，我们需要重新设置时间和时间步长。我们引入一个if语句来完成这个任务，因为我们不想在第一次迭代时就这样做。

  template <int dim> 
  void BlackScholes<dim>::run() 
  { 
    GridGenerator::hyper_cube(triangulation, 0.0, maximum_stock_price, true); 
    triangulation.refine_global(0); 

    solution_names.emplace_back("u"); 
    data_out_stack.declare_data_vector(solution_names, 
                                       DataOutStack<dim>::dof_vector); 

    Vector<double> vmult_result; 
    Vector<double> forcing_terms; 

    for (unsigned int cycle = 0; cycle < n_cycles; cycle++) 
      { 
        if (cycle != 0) 
          { 
            refine_grid(); 
            time = 0.0; 
          } 

        setup_system(); 

        std::cout << std::endl 
                  << "===========================================" << std::endl 
                  << "Cycle " << cycle << ':' << std::endl 
                  << "Number of active cells: " 
                  << triangulation.n_active_cells() << std::endl 
                  << "Number of degrees of freedom: " << dof_handler.n_dofs() 
                  << std::endl 
                  << std::endl; 

        VectorTools::interpolate(dof_handler, 
                                 InitialConditions<dim>(strike_price), 
                                 solution); 

        if (cycle == (n_cycles - 1)) 
          { 
            add_results_for_output(); 
          } 

// 接下来，我们运行主循环，该循环一直运行到超过成熟时间。我们首先计算方程的右侧，这在介绍中有所描述。回顾一下，它包含术语 $\left[-\frac{1}{4}k_n\sigma^2\mathbf{D}-k_nr\mathbf{M}+k_n\sigma^2 \mathbf{B}-k_nr\mathbf{A}+\mathbf{M}\right]V^{n-1}$  。我们把这些项放到变量system_rhs中，借助于一个临时向量。

        vmult_result.reinit(dof_handler.n_dofs()); 
        forcing_terms.reinit(dof_handler.n_dofs()); 
        for (unsigned int timestep_number = 0; timestep_number < n_time_steps; 
             ++timestep_number) 
          { 
            time += time_step; 

            if (timestep_number % 1000 == 0) 
              std::cout << "Time step " << timestep_number << " at t=" << time 
                        << std::endl; 

            mass_matrix.vmult(system_rhs, solution); 

            laplace_matrix.vmult(vmult_result, solution); 
            system_rhs.add( 
              (-1) * (1 - theta) * time_step * 
                Utilities::fixed_power<2, double>(asset_volatility) * 0.5, 
              vmult_result); 
            mass_matrix.vmult(vmult_result, solution); 

            system_rhs.add((-1) * (1 - theta) * time_step * interest_rate * 2, 
                           vmult_result); 

            a_matrix.vmult(vmult_result, solution); 
            system_rhs.add((-1) * time_step * interest_rate, vmult_result); 

            b_matrix.vmult(vmult_result, solution); 
            system_rhs.add( 
              (-1) * Utilities::fixed_power<2, double>(asset_volatility) * 
                time_step * 1, 
              vmult_result); 

// 第二块是计算源项的贡献。这与术语  $-k_n\left[\frac{1}{2}F^{n-1} +\frac{1}{2}F^n\right]$  相对应。下面的代码调用  VectorTools::create_right_hand_side  来计算向量  $F$  ，在这里我们在评估之前设置了右侧（源）函数的时间。这一切的结果最终都在forcing_terms变量中。

            RightHandSide<dim> rhs_function(asset_volatility, interest_rate); 
            rhs_function.set_time(time); 
            VectorTools::create_right_hand_side(dof_handler, 
                                                QGauss<dim>(fe.degree + 1), 
                                                rhs_function, 
                                                forcing_terms); 
            forcing_terms *= time_step * theta; 
            system_rhs -= forcing_terms; 

            rhs_function.set_time(time - time_step); 
            VectorTools::create_right_hand_side(dof_handler, 
                                                QGauss<dim>(fe.degree + 1), 
                                                rhs_function, 
                                                forcing_terms); 
            forcing_terms *= time_step * (1 - theta); 
            system_rhs -= forcing_terms; 

// 接下来，我们将强迫项添加到来自时间步长的强迫项中，同时建立矩阵 $\left[\mathbf{M}+ \frac{1}{4}k_n\sigma^2\mathbf{D}+k_nr\mathbf{M}\right]$ ，我们必须在每个时间步长中进行反转。这些操作的最后一块是消除线性系统中悬挂的节点约束自由度。

            system_matrix.copy_from(mass_matrix); 
            system_matrix.add( 
              (theta)*time_step * 
                Utilities::fixed_power<2, double>(asset_volatility) * 0.5, 
              laplace_matrix); 
            system_matrix.add((time_step)*interest_rate * theta * (1 + 1), 
                              mass_matrix); 

            constraints.condense(system_matrix, system_rhs); 

// 在解决这个问题之前，我们还需要做一个操作：边界值。为此，我们创建一个边界值对象，将适当的时间设置为当前时间步长的时间，并像以前多次那样对其进行评估。其结果也被用来在线性系统中设置正确的边界值。

            { 
              RightBoundaryValues<dim> right_boundary_function(strike_price, 
                                                               interest_rate); 
              LeftBoundaryValues<dim>  left_boundary_function; 
              right_boundary_function.set_time(time); 
              left_boundary_function.set_time(time); 
              std::map<types::global_dof_index, double> boundary_values; 
              VectorTools::interpolate_boundary_values(dof_handler, 
                                                       0, 
                                                       left_boundary_function, 
                                                       boundary_values); 
              VectorTools::interpolate_boundary_values(dof_handler, 
                                                       1, 
                                                       right_boundary_function, 
                                                       boundary_values); 
              MatrixTools::apply_boundary_values(boundary_values, 
                                                 system_matrix, 
                                                 solution, 
                                                 system_rhs); 
            } 

// 解决了这个问题，我们要做的就是求解系统，生成最后一个周期的图形数据，并创建收敛表数据。

            solve_time_step(); 

            if (cycle == (n_cycles - 1)) 
              { 
                add_results_for_output(); 
              } 
          } 
#ifdef MMS 
        process_solution(); 
#endif 
      } 

    const std::string filename = "solution.vtk"; 
    std::ofstream     output(filename); 
    data_out_stack.write_vtk(output); 

#ifdef MMS 
    write_convergence_table(); 
#endif 
  } 

} // namespace BlackScholesSolver 
// @sect3{The <code>main</code> Function}  

// 走到这一步，这个程序的主函数又没有什么好讨论的了：看起来自 step-6 以来的所有此类函数。

int main() 
{ 
  try 
    { 
      using namespace BlackScholesSolver; 

      BlackScholes<1> black_scholes_solver; 
      black_scholes_solver.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  return 0; 
} 

CCTest_file/step-79.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Justin O'Connor, Colorado State University, 2021. 
 */ 


// @sect3{Preliminaries}  
#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/tensor.h> 
#include <deal.II/base/timer.h> 
#include <deal.II/base/signaling_nan.h> 

#include <deal.II/lac/block_vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/block_sparse_matrix.h> 
#include <deal.II/lac/linear_operator.h> 
#include <deal.II/lac/packaged_operation.h> 
#include <deal.II/lac/sparse_direct.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_renumbering.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_values.h> 
#include <deal.II/fe/fe_dgq.h> 
#include <deal.II/fe/fe_system.h> 
#include <deal.II/fe/fe_q.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 

#include <iostream> 
#include <fstream> 
#include <algorithm> 

// 以上是相当常见的包含文件。这些文件还包括稀疏直接类的文件 SparseDirectUMFPACK。这不是解决大型线性问题的最有效的方法，但现在可以了。

// 像往常一样，我们把所有的东西都放到一个共同的命名空间里。然后，我们开始声明一些常数的符号名称，这些常数将在本教程中使用。具体来说，我们在这个程序中有*多的变量（当然是密度和位移，但也有未过滤的密度和相当多的拉格朗日乘数）。我们很容易忘记这些变量在求解向量中的哪个位置，而且试图用数字来表示这些向量分量是一个错误的处方。相反，我们定义的静态变量可以在所有这些地方使用，而且只需初始化一次。在实践中，这将导致一些冗长的表达式，但它们更具可读性，而且不太可能出错。

// 一个类似的问题出现在系统矩阵和向量中块的排序上。矩阵中有 $9\times 9$ 块，而且很难记住哪个是哪个。对这些块也使用符号名称要容易得多。

// 最后，我们为我们将要使用的边界指标引入符号名称，与  step-19  中的精神相同。

// 在所有这些情况下，我们将这些变量声明为命名空间中的成员。在求解组件的情况下，这些变量的具体数值取决于空间维度，因此我们使用[模板变量](https:en.cppreference.com/w/cpp/language/variable_template)来使变量的数值取决于模板参数，就像我们经常使用模板函数一样。

namespace SAND 
{ 
  using namespace dealii; 

// 这个命名空间记录了我们的有限元系统中与每个变量相对应的第一个组件。

  namespace SolutionComponents 
  { 
    template <int dim> 
    constexpr unsigned int density = 0; 
    template <int dim> 
    constexpr unsigned int displacement = 1; 
    template <int dim> 
    constexpr unsigned int unfiltered_density = 1 + dim; 
    template <int dim> 
    constexpr unsigned int displacement_multiplier = 2 + dim; 
    template <int dim> 
    constexpr unsigned int unfiltered_density_multiplier = 2 + 2 * dim; 
    template <int dim> 
    constexpr unsigned int density_lower_slack = 3 + 2 * dim; 
    template <int dim> 
    constexpr unsigned int density_lower_slack_multiplier = 4 + 2 * dim; 
    template <int dim> 
    constexpr unsigned int density_upper_slack = 5 + 2 * dim; 
    template <int dim> 
    constexpr unsigned int density_upper_slack_multiplier = 6 + 2 * dim; 
  } // namespace SolutionComponents 

// 这是一个命名空间，它记录了哪个区块对应于哪个变量。

  namespace SolutionBlocks 
  { 
    constexpr unsigned int density                        = 0; 
    constexpr unsigned int displacement                   = 1; 
    constexpr unsigned int unfiltered_density             = 2; 
    constexpr unsigned int displacement_multiplier        = 3; 
    constexpr unsigned int unfiltered_density_multiplier  = 4; 
    constexpr unsigned int density_lower_slack            = 5; 
    constexpr unsigned int density_lower_slack_multiplier = 6; 
    constexpr unsigned int density_upper_slack            = 7; 
    constexpr unsigned int density_upper_slack_multiplier = 8; 
  } // namespace SolutionBlocks 

  namespace BoundaryIds 
  { 
    constexpr types::boundary_id down_force = 101; 
    constexpr types::boundary_id no_force   = 102; 
  } // namespace BoundaryIds 

  namespace ValueExtractors 
  { 
    template <int dim> 
    const FEValuesExtractors::Scalar 
      densities(SolutionComponents::density<dim>); 
    template <int dim> 
    const FEValuesExtractors::Vector 
      displacements(SolutionComponents::displacement<dim>); 
    template <int dim> 
    const FEValuesExtractors::Scalar 
      unfiltered_densities(SolutionComponents::unfiltered_density<dim>); 
    template <int dim> 
    const FEValuesExtractors::Vector displacement_multipliers( 
      SolutionComponents::displacement_multiplier<dim>); 
    template <int dim> 
    const FEValuesExtractors::Scalar unfiltered_density_multipliers( 
      SolutionComponents::unfiltered_density_multiplier<dim>); 
    template <int dim> 
    const FEValuesExtractors::Scalar 
      density_lower_slacks(SolutionComponents::density_lower_slack<dim>); 
    template <int dim> 
    const FEValuesExtractors::Scalar density_lower_slack_multipliers( 
      SolutionComponents::density_lower_slack_multiplier<dim>); 
    template <int dim> 
    const FEValuesExtractors::Scalar 
      density_upper_slacks(SolutionComponents::density_upper_slack<dim>); 
    template <int dim> 
    const FEValuesExtractors::Scalar density_upper_slack_multipliers( 
      SolutionComponents::density_upper_slack_multiplier<dim>); 
  } // namespace ValueExtractors 
// @sect3{The SANDTopOpt main class}  

// 接下来是这个问题的主类。大多数函数都遵循教程程序的常规命名方式，不过有几个函数因为长度问题被从通常称为`setup_system()`的函数中分离出来，还有一些函数是处理优化算法的各个方面的。

// 作为额外的奖励，该程序将计算出的设计写成STL文件，例如，可以将其发送给3D打印机。

  template <int dim> 
  class SANDTopOpt 
  { 
  public: 
    SANDTopOpt(); 

    void run(); 

  private: 
    void create_triangulation(); 

    void setup_boundary_values(); 

    void setup_block_system(); 

    void setup_filter_matrix(); 

    void assemble_system(); 

    BlockVector<double> solve(); 

    std::pair<double, double> 
    calculate_max_step_size(const BlockVector<double> &state, 
                            const BlockVector<double> &step) const; 

    BlockVector<double> 
    calculate_test_rhs(const BlockVector<double> &test_solution) const; 

    double calculate_exact_merit(const BlockVector<double> &test_solution); 

    BlockVector<double> find_max_step(); 

    BlockVector<double> compute_scaled_step(const BlockVector<double> &state, 
                                            const BlockVector<double> &step, 
                                            const double descent_requirement); 

    bool check_convergence(const BlockVector<double> &state); 

    void output_results(const unsigned int j) const; 

    void write_as_stl(); 

    std::set<typename Triangulation<dim>::cell_iterator> 
    find_relevant_neighbors( 
      typename Triangulation<dim>::cell_iterator cell) const; 

// 大部分的成员变量也是标准的。但是，有一些变量是专门与优化算法有关的（比如下面的各种标量因子），以及过滤器矩阵，以确保设计保持平稳。

    Triangulation<dim>        triangulation; 
    FESystem<dim>             fe; 
    DoFHandler<dim>           dof_handler; 
    AffineConstraints<double> constraints; 

    std::map<types::global_dof_index, double> boundary_values; 

    BlockSparsityPattern      sparsity_pattern; 
    BlockSparseMatrix<double> system_matrix; 

    SparsityPattern      filter_sparsity_pattern; 
    SparseMatrix<double> filter_matrix; 

    BlockVector<double> system_rhs; 
    BlockVector<double> nonlinear_solution; 

    const double density_ratio; 
    const double density_penalty_exponent; 
    const double filter_r; 
    double       penalty_multiplier; 
    double       barrier_size; 

    TimerOutput timer; 
  }; 
// @sect3{Constructor and set-up functions}  

// 我们初始化一个由2  $\times$  dim `FE_Q(1)`元素组成的FES系统，用于位移变量及其拉格朗日乘数，以及7 `FE_DGQ(0)`元素。 这些片状常数函数用于与密度相关的变量：密度本身、未过滤的密度、用于未过滤的密度的下限和上限的松弛变量，然后是用于过滤和未过滤的密度之间的连接以及不等式约束的拉格朗日乘子。

// 这些元素出现的顺序在上面有记载。

  template <int dim> 
  SANDTopOpt<dim>::SANDTopOpt() 
    : fe(FE_DGQ<dim>(0), 
         1, 
         (FESystem<dim>(FE_Q<dim>(1) ^ dim)), 
         1, 
         FE_DGQ<dim>(0), 
         1, 
         (FESystem<dim>(FE_Q<dim>(1) ^ dim)), 
         1, 
         FE_DGQ<dim>(0), 
         5) 
    , dof_handler(triangulation) 
    , density_ratio(.5) 
    , density_penalty_exponent(3) 
    , filter_r(.251) 
    , penalty_multiplier(1) 
    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times) 
  { 
    Assert(dim > 1, ExcNotImplemented()); 
  } 

// 然后，第一步是创建与介绍中的问题描述相匹配的三角形--一个6乘1的矩形（或者一个6乘1乘1的3D盒子），在这个盒子的顶部中心将施加一个力。然后，这个三角形被均匀地细化若干次。

// 与本程序的其他部分相比，这个函数特别假定我们是在2D中，如果我们想转到3D模拟，就需要进行修改。我们通过函数顶部的断言来确保没有人试图不经修改就意外地在三维中运行。

  template <int dim> 
  void SANDTopOpt<dim>::create_triangulation() 
  { 
    Assert(dim == 2, ExcNotImplemented()); 
    GridGenerator::subdivided_hyper_rectangle(triangulation, 
                                              {6, 1}, 
                                              Point<dim>(0, 0), 
                                              Point<dim>(6, 1)); 

    triangulation.refine_global(3); 

// 第二步是将边界指标应用于边界的一部分。下面的代码分别为盒子的底部、顶部、左侧和右侧的边界分配了边界指示器。顶部边界的中心区域被赋予一个单独的边界指示器。这就是我们要施加向下力的地方。

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        for (const auto &face : cell->face_iterators()) 
          { 
            if (face->at_boundary()) 
              { 
                const auto center = face->center(); 
                if (std::fabs(center(1) - 1) < 1e-12) 
                  { 
                    if ((std::fabs(center(0) - 3) < .3)) 
                      face->set_boundary_id(BoundaryIds::down_force); 
                    else 
                      face->set_boundary_id(BoundaryIds::no_force); 
                  } 
                else 
                  face->set_boundary_id(BoundaryIds::no_force); 
              } 
          } 
      } 
  } 

// 接下来，确定由于边界值而产生的约束。 域的底角在 $y$ 方向保持不变--左下角也在 $x$ 方向。deal.II通常认为边界值是附着在边界的片段上的，即面，而不是单个顶点。的确，从数学上讲，对于无穷大的偏微分方程，我们不能把边界值分配给单个点。但是，由于我们试图重现一个广泛使用的基准，我们还是要这样做，并牢记我们有一个有限维的问题，在单个节点上施加边界条件是有效的。

  template <int dim> 
  void SANDTopOpt<dim>::setup_boundary_values() 
  { 
    boundary_values.clear(); 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        for (const auto &face : cell->face_iterators()) 
          { 
            if (face->at_boundary()) 
              { 
                const auto center = face->center(); 

// 检查当前面是否在底层边界上，如果是，则检查其顶点之一是否可能是左底层或右底层顶点。

                if (std::fabs(center(1) - 0) < 1e-12) 
                  { 
                    for (const auto vertex_number : cell->vertex_indices()) 
                      { 
                        const auto vert = cell->vertex(vertex_number); 

                        if (std::fabs(vert(0) - 0) < 1e-12 && 
                            std::fabs(vert(1) - 0) < 1e-12) 
                          { 
                            types::global_dof_index x_displacement = 
                              cell->vertex_dof_index(vertex_number, 0); 
                            types::global_dof_index y_displacement = 
                              cell->vertex_dof_index(vertex_number, 1); 
                            types::global_dof_index x_displacement_multiplier = 
                              cell->vertex_dof_index(vertex_number, 2); 
                            types::global_dof_index y_displacement_multiplier = 
                              cell->vertex_dof_index(vertex_number, 3); 

                            boundary_values[x_displacement]            = 0; 
                            boundary_values[y_displacement]            = 0; 
                            boundary_values[x_displacement_multiplier] = 0; 
                            boundary_values[y_displacement_multiplier] = 0; 
                          } 

                        else if (std::fabs(vert(0) - 6) < 1e-12 && 
                                 std::fabs(vert(1) - 0) < 1e-12) 
                          { 
                            types::global_dof_index y_displacement = 
                              cell->vertex_dof_index(vertex_number, 1); 
                            types::global_dof_index y_displacement_multiplier = 
                              cell->vertex_dof_index(vertex_number, 3); 

                            boundary_values[y_displacement]            = 0; 
                            boundary_values[y_displacement_multiplier] = 0; 
                          } 
                      } 
                  } 
              } 
          } 
      } 
  } 
// @sect3{Setting up block matrices and vectors}  

// 下一个函数制作了一个巨大的9乘9的块状矩阵，并且还设置了必要的块状向量。 这个矩阵的稀疏度模式包括滤波矩阵的稀疏度模式。它还初始化了我们将使用的任何块向量。

// 设置块本身并不复杂，并且遵循诸如  step-22  等程序中已经完成的工作，例如。

  template <int dim> 
  void SANDTopOpt<dim>::setup_block_system() 
  { 
    std::vector<unsigned int> block_component(9, 2); 
    block_component[0] = 0; 
    block_component[1] = 1; 
    const std::vector<types::global_dof_index> dofs_per_block = 
      DoFTools::count_dofs_per_fe_block(dof_handler, block_component); 

    const types::global_dof_index                     n_p = dofs_per_block[0]; 
    const types::global_dof_index                     n_u = dofs_per_block[1]; 
    const std::vector<BlockVector<double>::size_type> block_sizes = { 
      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p}; 

    BlockDynamicSparsityPattern dsp(9, 9); 
    for (unsigned int k = 0; k < 9; ++k) 
      for (unsigned int j = 0; j < 9; ++j) 
        dsp.block(j, k).reinit(block_sizes[j], block_sizes[k]); 
    dsp.collect_sizes(); 

// 该函数的大部分内容是设置这些块中哪些将实际包含任何内容，即哪些变量与哪些其他变量相耦合。这很麻烦，但也是必要的，以确保我们不会为我们的矩阵分配大量的条目，而这些条目最终会变成零。

// 你在下面看到的具体模式可能需要在纸上画一次，但是从我们在每次非线性迭代中必须组装的双线性形式的许多项来看，它是相对直接的方式。

// 使用命名空间 "SolutionComponents "中定义的符号名称有助于理解下面每个项所对应的内容，但它也使表达式变得冗长而不流畅。像 `coupling[SolutionComponents::density_upper_slack_multiplier<dim>][SolutionComponents::density<dim>]` 这样的术语读起来就不太顺口，要么必须分成几行，要么几乎跑到每个屏幕的右边缘。因此，我们打开了一个大括号封闭的代码块，在这个代码块中，我们通过说 "使用命名空间SolutionComponents"，暂时使命名空间`SolutionComponents'中的名字可用，而不需要命名空间修饰语。

    Table<2, DoFTools::Coupling> coupling(2 * dim + 7, 2 * dim + 7); 
    { 
      using namespace SolutionComponents; 

      coupling[density<dim>][density<dim>] = DoFTools::always; 

      for (unsigned int i = 0; i < dim; ++i) 
        { 
          coupling[density<dim>][displacement<dim> + i] = DoFTools::always; 
          coupling[displacement<dim> + i][density<dim>] = DoFTools::always; 
        } 

      for (unsigned int i = 0; i < dim; ++i) 
        { 
          coupling[density<dim>][displacement_multiplier<dim> + i] = 
            DoFTools::always; 
          coupling[displacement_multiplier<dim> + i][density<dim>] = 
            DoFTools::always; 
        } 

      coupling[density<dim>][unfiltered_density_multiplier<dim>] = 
        DoFTools::always; 
      coupling[unfiltered_density_multiplier<dim>][density<dim>] = 
        DoFTools::always; 
      /*位移的联结  */ 
      for (unsigned int i = 0; i < dim; ++i) 
        { 
          for (unsigned int k = 0; k < dim; ++k) 
            { 
              coupling[displacement<dim> + i] 
                      [displacement_multiplier<dim> + k] = DoFTools::always; 
              coupling[displacement_multiplier<dim> + k] 
                      [displacement<dim> + i] = DoFTools::always; 
            } 
        } 
      /*松弛变量的耦合 */ 
      coupling[density_lower_slack<dim>][density_lower_slack<dim>] = 
        DoFTools::always; 
      coupling[density_lower_slack<dim>][density_upper_slack<dim>] = 
        DoFTools::always; 
      coupling[density_upper_slack<dim>][density_lower_slack<dim>] = 
        DoFTools::always; 

      coupling[density_lower_slack_multiplier<dim>] 
              [density_lower_slack_multiplier<dim>] = DoFTools::always; 
      coupling[density_lower_slack_multiplier<dim>] 
              [density_upper_slack_multiplier<dim>] = DoFTools::always; 
      coupling[density_upper_slack_multiplier<dim>] 
              [density_lower_slack_multiplier<dim>] = DoFTools::always; 
    } 

// 在创建稀疏模式之前，我们还必须设置约束。由于这个程序没有自适应地细化网格，我们唯一的约束是将所有的密度变量耦合在一起，强制执行体积约束。这将最终导致矩阵的密集子块，但我们对此没有什么办法。

    const ComponentMask density_mask = 
      fe.component_mask(ValueExtractors::densities<dim>); 
    const IndexSet density_dofs = 
      DoFTools::extract_dofs(dof_handler, density_mask); 

    types::global_dof_index last_density_dof = 
      density_dofs.nth_index_in_set(density_dofs.n_elements() - 1); 
    constraints.clear(); 
    constraints.add_line(last_density_dof); 
    for (unsigned int i = 0; i < density_dofs.n_elements() - 1; ++i) 
      constraints.add_entry(last_density_dof, 
                            density_dofs.nth_index_in_set(i), 
                            -1); 
    constraints.set_inhomogeneity(last_density_dof, 0); 

    constraints.close(); 

// 现在我们终于可以为矩阵创建稀疏模式了，考虑到哪些变量与哪些其他变量耦合，以及我们对密度的约束。

    DoFTools::make_sparsity_pattern(dof_handler, coupling, dsp, constraints); 

// 矩阵中唯一没有处理的部分是过滤矩阵和它的转置。这些都是非局部（积分）运算符，目前deal.II还没有相关的函数。我们最终需要做的是遍历所有单元，并将此单元上的未过滤密度与小于阈值距离的相邻单元的所有过滤密度联系起来，反之亦然；目前，我们只关心建立与这种矩阵相对应的稀疏模式，所以我们执行等效循环，以后我们将写进矩阵的一个条目，现在我们只需向稀疏矩阵添加一个条目。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        const unsigned int i = cell->active_cell_index(); 
        for (const auto &check_cell : find_relevant_neighbors(cell)) 
          { 
            const double distance = 
              cell->center().distance(check_cell->center()); 
            if (distance < filter_r) 
              { 
                dsp 
                  .block(SolutionBlocks::unfiltered_density, 
                         SolutionBlocks::unfiltered_density_multiplier) 
                  .add(i, check_cell->active_cell_index()); 
                dsp 
                  .block(SolutionBlocks::unfiltered_density_multiplier, 
                         SolutionBlocks::unfiltered_density) 
                  .add(i, check_cell->active_cell_index()); 
              } 
          } 
      } 

// 在生成了 "动态 "稀疏度模式之后，我们终于可以将其复制到用于将矩阵与稀疏度模式联系起来的结构中。由于稀疏模式很大很复杂，我们还将其输出到一个自己的文件中，以达到可视化的目的--换句话说，是为了 "可视化调试"。

    sparsity_pattern.copy_from(dsp); 

    std::ofstream out("sparsity.plt"); 
    sparsity_pattern.print_gnuplot(out); 

    system_matrix.reinit(sparsity_pattern); 

// 剩下的就是正确确定各种向量及其块的大小，以及为（非线性）解向量的一些分量设置初始猜测。我们在这里使用解向量各个区块的符号分量名称，为了简洁起见，使用与上面的 "使用命名空间 "相同的技巧。

    nonlinear_solution.reinit(block_sizes); 
    system_rhs.reinit(block_sizes); 

    { 
      using namespace SolutionBlocks; 
      nonlinear_solution.block(density).add(density_ratio); 
      nonlinear_solution.block(unfiltered_density).add(density_ratio); 
      nonlinear_solution.block(unfiltered_density_multiplier) 
        .add(density_ratio); 
      nonlinear_solution.block(density_lower_slack).add(density_ratio); 
      nonlinear_solution.block(density_lower_slack_multiplier).add(50); 
      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio); 
      nonlinear_solution.block(density_upper_slack_multiplier).add(50); 
    } 
  } 
// @sect3{Creating the filter matrix}  

// 接下来是一个在程序开始时使用一次的函数。它创建了一个矩阵 $H$ ，使过滤后的密度向量等于 $H$ 乘以未过滤的密度。 这个矩阵的创建是非同小可的，它在每次迭代中都会被使用，因此，与其像我们对牛顿矩阵那样对其进行改造，不如只做一次并单独存储。

// 这个矩阵的计算方式遵循上面已经使用过的大纲，以形成其稀疏模式。我们在这里对这个单独形成的矩阵的稀疏性模式重复这个过程，然后实际建立矩阵本身。你可能想看看本程序介绍中关于这个矩阵的定义。

  template <int dim> 
  void SANDTopOpt<dim>::setup_filter_matrix() 
  { 

// 滤波器的稀疏模式已经在setup_system()函数中确定并实现。我们从相应的块中复制该结构，并在这里再次使用它。

    filter_sparsity_pattern.copy_from( 
      sparsity_pattern.block(SolutionBlocks::unfiltered_density, 
                             SolutionBlocks::unfiltered_density_multiplier)); 
    filter_matrix.reinit(filter_sparsity_pattern); 

// 在建立了稀疏模式之后，现在我们重新做所有这些循环，以实际计算矩阵项的必要值。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        const unsigned int i = cell->active_cell_index(); 
        for (const auto &check_cell : find_relevant_neighbors(cell)) 
          { 
            const double distance = 
              cell->center().distance(check_cell->center()); 
            if (distance < filter_r) 
              { 
                filter_matrix.add(i, 
                                  check_cell->active_cell_index(), 
                                  filter_r - distance); 

//      

              } 
          } 
      } 

// 最后一步是对矩阵进行标准化处理，使每一行的条目之和等于1。

    for (unsigned int i = 0; i < filter_matrix.m(); ++i) 
      { 
        double denominator = 0; 
        for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i); 
             iter != filter_matrix.end(i); 
             iter++) 
          denominator = denominator + iter->value(); 
        for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i); 
             iter != filter_matrix.end(i); 
             iter++) 
          iter->value() = iter->value() / denominator; 
      } 
  } 

// 这个函数用于建立过滤矩阵。我们创建一个输入单元的一定半径内的所有单元迭代器的集合。这些是与过滤器有关的邻近单元。

  template <int dim> 
  std::set<typename Triangulation<dim>::cell_iterator> 
  SANDTopOpt<dim>::find_relevant_neighbors( 
    typename Triangulation<dim>::cell_iterator cell) const 
  { 
    std::set<unsigned int>                               neighbor_ids; 
    std::set<typename Triangulation<dim>::cell_iterator> cells_to_check; 

    neighbor_ids.insert(cell->active_cell_index()); 
    cells_to_check.insert(cell); 

    bool new_neighbors_found; 
    do 
      { 
        new_neighbors_found = false; 
        for (const auto &check_cell : 
             std::vector<typename Triangulation<dim>::cell_iterator>( 
               cells_to_check.begin(), cells_to_check.end())) 
          { 
            for (const auto n : check_cell->face_indices()) 
              { 
                if (!(check_cell->face(n)->at_boundary())) 
                  { 
                    const auto & neighbor = check_cell->neighbor(n); 
                    const double distance = 
                      cell->center().distance(neighbor->center()); 
                    if ((distance < filter_r) && 
                        !(neighbor_ids.count(neighbor->active_cell_index()))) 
                      { 
                        cells_to_check.insert(neighbor); 
                        neighbor_ids.insert(neighbor->active_cell_index()); 
                        new_neighbors_found = true; 
                      } 
                  } 
              } 
          } 
      } 
    while (new_neighbors_found); 
    return cells_to_check; 
  } 
// @sect3{Assembling the Newton matrix}  

// setup_filter_matrix函数建立了一个只要网格不改变就不变的矩阵（在这个程序中我们反正不改变），而下一个函数建立了每次迭代都要解决的矩阵。这就是奇迹发生的地方。描述牛顿求解KKT条件的方法的线性方程组的组成部分在这里实现。

// 这个函数的顶部与大多数此类函数一样，只是设置了实际装配所需的各种变量，包括一大堆提取器。如果你以前看过  step-22  ，整个设置应该看起来很熟悉，尽管有些冗长。

  template <int dim> 
  void SANDTopOpt<dim>::assemble_system() 
  { 
    TimerOutput::Scope t(timer, "assembly"); 

    system_matrix = 0; 
    system_rhs    = 0; 

    MappingQGeneric<dim> mapping(1); 
    QGauss<dim>          quadrature_formula(fe.degree + 1); 
    QGauss<dim - 1>      face_quadrature_formula(fe.degree + 1); 
    FEValues<dim>        fe_values(mapping, 
                            fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    FEFaceValues<dim>    fe_face_values(mapping, 
                                     fe, 
                                     face_quadrature_formula, 
                                     update_values | update_quadrature_points | 
                                       update_normal_vectors | 
                                       update_JxW_values); 

    const unsigned int dofs_per_cell = fe.dofs_per_cell; 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     dummy_cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    std::vector<double>                    lambda_values(n_q_points); 
    std::vector<double>                    mu_values(n_q_points); 
    const Functions::ConstantFunction<dim> lambda(1.); 
    const Functions::ConstantFunction<dim> mu(1.); 
    std::vector<Tensor<1, dim>>            rhs_values(n_q_points); 

// 在这一点上，我们对未过滤的密度进行过滤，并对未过滤的密度乘法器进行邻接（转置）操作，都是对当前非线性解决方案的最佳猜测。后来我们用它来告诉我们，我们过滤的密度与应用于未过滤密度的过滤器有多大的偏差。这是因为在非线性问题的解中，我们有 $\rho=H\varrho$ ，但在中间迭代中，我们一般有 $\rho^k\neq H\varrho^k$ ，然后 "残差" $\rho^k-H\varrho^k$ 将出现在我们下面计算的牛顿更新方程中的右边。

    BlockVector<double> filtered_unfiltered_density_solution = 
      nonlinear_solution; 
    BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution = 
      nonlinear_solution; 

    filter_matrix.vmult(filtered_unfiltered_density_solution.block( 
                          SolutionBlocks::unfiltered_density), 
                        nonlinear_solution.block( 
                          SolutionBlocks::unfiltered_density)); 
    filter_matrix.Tvmult( 
      filter_adjoint_unfiltered_density_multiplier_solution.block( 
        SolutionBlocks::unfiltered_density_multiplier), 
      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier)); 

    std::vector<double>                  old_density_values(n_q_points); 
    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points); 
    std::vector<double>                  old_displacement_divs(n_q_points); 
    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points); 
    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points); 
    std::vector<double>         old_displacement_multiplier_divs(n_q_points); 
    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads( 
      n_q_points); 
    std::vector<double> old_lower_slack_multiplier_values(n_q_points); 
    std::vector<double> old_upper_slack_multiplier_values(n_q_points); 
    std::vector<double> old_lower_slack_values(n_q_points); 
    std::vector<double> old_upper_slack_values(n_q_points); 
    std::vector<double> old_unfiltered_density_values(n_q_points); 
    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points); 
    std::vector<double> filtered_unfiltered_density_values(n_q_points); 
    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values( 
      n_q_points); 

    using namespace ValueExtractors; 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0; 

        cell->get_dof_indices(local_dof_indices); 

        fe_values.reinit(cell); 

        lambda.value_list(fe_values.get_quadrature_points(), lambda_values); 
        mu.value_list(fe_values.get_quadrature_points(), mu_values); 

// 作为构建系统矩阵的一部分，我们需要从我们目前对解决方案的猜测中获取数值。以下几行代码将检索出所需的值。

        fe_values[densities<dim>].get_function_values(nonlinear_solution, 
                                                      old_density_values); 
        fe_values[displacements<dim>].get_function_values( 
          nonlinear_solution, old_displacement_values); 
        fe_values[displacements<dim>].get_function_divergences( 
          nonlinear_solution, old_displacement_divs); 
        fe_values[displacements<dim>].get_function_symmetric_gradients( 
          nonlinear_solution, old_displacement_symmgrads); 
        fe_values[displacement_multipliers<dim>].get_function_values( 
          nonlinear_solution, old_displacement_multiplier_values); 
        fe_values[displacement_multipliers<dim>].get_function_divergences( 
          nonlinear_solution, old_displacement_multiplier_divs); 
        fe_values[displacement_multipliers<dim>] 
          .get_function_symmetric_gradients( 
            nonlinear_solution, old_displacement_multiplier_symmgrads); 
        fe_values[density_lower_slacks<dim>].get_function_values( 
          nonlinear_solution, old_lower_slack_values); 
        fe_values[density_lower_slack_multipliers<dim>].get_function_values( 
          nonlinear_solution, old_lower_slack_multiplier_values); 
        fe_values[density_upper_slacks<dim>].get_function_values( 
          nonlinear_solution, old_upper_slack_values); 
        fe_values[density_upper_slack_multipliers<dim>].get_function_values( 
          nonlinear_solution, old_upper_slack_multiplier_values); 
        fe_values[unfiltered_densities<dim>].get_function_values( 
          nonlinear_solution, old_unfiltered_density_values); 
        fe_values[unfiltered_density_multipliers<dim>].get_function_values( 
          nonlinear_solution, old_unfiltered_density_multiplier_values); 
        fe_values[unfiltered_densities<dim>].get_function_values( 
          filtered_unfiltered_density_solution, 
          filtered_unfiltered_density_values); 
        fe_values[unfiltered_density_multipliers<dim>].get_function_values( 
          filter_adjoint_unfiltered_density_multiplier_solution, 
          filter_adjoint_unfiltered_density_multiplier_values); 

        for (const auto q_point : fe_values.quadrature_point_indices()) 
          { 

// 我们还需要几个与来自拉格朗日的第一导数的测试函数相对应的数值，也就是 $d_{\bullet}$ 函数。这些都是在这里计算的。

            for (const auto i : fe_values.dof_indices()) 
              { 
                const SymmetricTensor<2, dim> displacement_phi_i_symmgrad = 
                  fe_values[displacements<dim>].symmetric_gradient(i, q_point); 
                const double displacement_phi_i_div = 
                  fe_values[displacements<dim>].divergence(i, q_point); 

                const SymmetricTensor<2, dim> 
                  displacement_multiplier_phi_i_symmgrad = 
                    fe_values[displacement_multipliers<dim>].symmetric_gradient( 
                      i, q_point); 
                const double displacement_multiplier_phi_i_div = 
                  fe_values[displacement_multipliers<dim>].divergence(i, 
                                                                      q_point); 

                const double density_phi_i = 
                  fe_values[densities<dim>].value(i, q_point); 
                const double unfiltered_density_phi_i = 
                  fe_values[unfiltered_densities<dim>].value(i, q_point); 
                const double unfiltered_density_multiplier_phi_i = 
                  fe_values[unfiltered_density_multipliers<dim>].value(i, 
                                                                       q_point); 

                const double lower_slack_multiplier_phi_i = 
                  fe_values[density_lower_slack_multipliers<dim>].value( 
                    i, q_point); 

                const double lower_slack_phi_i = 
                  fe_values[density_lower_slacks<dim>].value(i, q_point); 

                const double upper_slack_phi_i = 
                  fe_values[density_upper_slacks<dim>].value(i, q_point); 

                const double upper_slack_multiplier_phi_i = 
                  fe_values[density_upper_slack_multipliers<dim>].value( 
                    i, q_point); 

                for (const auto j : fe_values.dof_indices()) 
                  { 

// 最后，我们需要来自拉格朗日的第二轮导数的数值，即 $c_{\bullet}$ 函数。这些是在这里计算的。

                    const SymmetricTensor<2, dim> displacement_phi_j_symmgrad = 
                      fe_values[displacements<dim>].symmetric_gradient(j, 
                                                                       q_point); 
                    const double displacement_phi_j_div = 
                      fe_values[displacements<dim>].divergence(j, q_point); 

                    const SymmetricTensor<2, dim> 
                      displacement_multiplier_phi_j_symmgrad = 
                        fe_values[displacement_multipliers<dim>] 
                          .symmetric_gradient(j, q_point); 
                    const double displacement_multiplier_phi_j_div = 
                      fe_values[displacement_multipliers<dim>].divergence( 
                        j, q_point); 

                    const double density_phi_j = 
                      fe_values[densities<dim>].value(j, q_point); 

                    const double unfiltered_density_phi_j = 
                      fe_values[unfiltered_densities<dim>].value(j, q_point); 
                    const double unfiltered_density_multiplier_phi_j = 
                      fe_values[unfiltered_density_multipliers<dim>].value( 
                        j, q_point); 

                    const double lower_slack_phi_j = 
                      fe_values[density_lower_slacks<dim>].value(j, q_point); 

                    const double upper_slack_phi_j = 
                      fe_values[density_upper_slacks<dim>].value(j, q_point); 

                    const double lower_slack_multiplier_phi_j = 
                      fe_values[density_lower_slack_multipliers<dim>].value( 
                        j, q_point); 

                    const double upper_slack_multiplier_phi_j = 
                      fe_values[density_upper_slack_multipliers<dim>].value( 
                        j, q_point); 

// 这就是实际工作的开始。在下文中，我们将建立矩阵的所有项--它们数量众多，而且不完全是不言自明的，也取决于之前的解和它的导数（我们已经在上面评估了这些导数，并将其放入名为`old_*`的变量中）。为了理解这些条款的每一个对应的内容，你要看一下上面介绍中这些条款的明确形式。                    被驱动到0的方程的右边给出了寻找局部最小值的所有KKT条件--每个单独方程的描述都是随着右边的计算给出的。

                    /* 方程1  */ 
                    cell_matrix(i, j) += 
                      fe_values.JxW(q_point) * 
                      ( 
                        -density_phi_i * unfiltered_density_multiplier_phi_j 
                        + density_penalty_exponent * 
                            (density_penalty_exponent - 1) * 
                            std::pow(old_density_values[q_point], 
                                     density_penalty_exponent - 2) * 
                            density_phi_i * density_phi_j * 
                            (old_displacement_multiplier_divs[q_point] * 
                               old_displacement_divs[q_point] * 
                               lambda_values[q_point] + 
                             2 * mu_values[q_point] * 
                               (old_displacement_symmgrads[q_point] * 
                                old_displacement_multiplier_symmgrads[q_point])) 
                        + density_penalty_exponent * 
                            std::pow(old_density_values[q_point], 
                                     density_penalty_exponent - 1) * 
                            density_phi_i * 
                            (displacement_multiplier_phi_j_div * 
                               old_displacement_divs[q_point] * 
                               lambda_values[q_point] + 
                             2 * mu_values[q_point] * 
                               (old_displacement_symmgrads[q_point] * 
                                displacement_multiplier_phi_j_symmgrad)) 
                        + density_penalty_exponent * 
                            std::pow(old_density_values[q_point], 
                                     density_penalty_exponent - 1) * 
                            density_phi_i * 
                            (displacement_phi_j_div * 
                               old_displacement_multiplier_divs[q_point] * 
                               lambda_values[q_point] + 
                             2 * mu_values[q_point] * 
                               (old_displacement_multiplier_symmgrads[q_point] * 
                                displacement_phi_j_symmgrad))); 
                   
                    /* 方程2  */ 
                    cell_matrix(i, j) += 
                      fe_values.JxW(q_point) * 
                      (density_penalty_exponent * 
                         std::pow(old_density_values[q_point], 
                                  density_penalty_exponent - 1) * 
                         density_phi_j * 
                         (old_displacement_multiplier_divs[q_point] * 
                            displacement_phi_i_div * lambda_values[q_point] + 
                          2 * mu_values[q_point] * 
                            (old_displacement_multiplier_symmgrads[q_point] * 
                             displacement_phi_i_symmgrad)) 
                       + std::pow(old_density_values[q_point], 
                                  density_penalty_exponent) * 
                           (displacement_multiplier_phi_j_div * 
                              displacement_phi_i_div * lambda_values[q_point] + 
                            2 * mu_values[q_point] * 
                              (displacement_multiplier_phi_j_symmgrad * 
                               displacement_phi_i_symmgrad)) 
                      ); 

                   /*方程3，这与过滤器有关 */ 
                    cell_matrix(i, j) += 
                      fe_values.JxW(q_point) * 
                      (-1 * unfiltered_density_phi_i * 
                         lower_slack_multiplier_phi_j + 
                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j); 

                     /* 方程4：原始可行性  */ 
                    cell_matrix(i, j) += 
                      fe_values.JxW(q_point) * 
                      ( 
                        density_penalty_exponent * 
                          std::pow(old_density_values[q_point], 
                                   density_penalty_exponent - 1) * 
                          density_phi_j * 
                          (old_displacement_divs[q_point] * 
                             displacement_multiplier_phi_i_div * 
                             lambda_values[q_point] + 
                           2 * mu_values[q_point] * 
                             (old_displacement_symmgrads[q_point] * 
                              displacement_multiplier_phi_i_symmgrad)) 

                        + std::pow(old_density_values[q_point], 
                                   density_penalty_exponent) * 
                            (displacement_phi_j_div * 
                               displacement_multiplier_phi_i_div * 
                               lambda_values[q_point] + 
                             2 * mu_values[q_point] * 
                               (displacement_phi_j_symmgrad * 
                                displacement_multiplier_phi_i_symmgrad))); 

                   /*等式5：原始可行性  */ 
                    cell_matrix(i, j) += 
                      -1 * fe_values.JxW(q_point) * 
                      lower_slack_multiplier_phi_i * 
                      (unfiltered_density_phi_j - lower_slack_phi_j); 
                  /* 等式6：原始可行性  */ 
                    cell_matrix(i, j) += 
                      -1 * fe_values.JxW(q_point) * 
                      upper_slack_multiplier_phi_i * 
                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j); 
                    /* Equation 7: Primal feasibility - the part with the filter
                     * is added later */
                    cell_matrix(i, j) += -1 * fe_values.JxW(q_point) * 
                                         unfiltered_density_multiplier_phi_i * 
                                         (density_phi_j); 
                    /* Equation 8: Complementary slackness */
                    cell_matrix(i, j) += 
                      fe_values.JxW(q_point) * 
                      (lower_slack_phi_i * lower_slack_multiplier_phi_j 

                       + lower_slack_phi_i * lower_slack_phi_j * 
                           old_lower_slack_multiplier_values[q_point] / 
                           old_lower_slack_values[q_point]); 
                    /* Equation 9: Complementary slackness */
                    cell_matrix(i, j) += 
                      fe_values.JxW(q_point) * 
                      (upper_slack_phi_i * upper_slack_multiplier_phi_j 

                       + upper_slack_phi_i * upper_slack_phi_j * 
                           old_upper_slack_multiplier_values[q_point] / 
                           old_upper_slack_values[q_point]); 
                  } 
              } 
          } 

// 现在我们已经把所有的东西都组装好了，我们要做的就是处理（Dirichlet）边界条件的影响和其他约束。我们将前者与当前单元的贡献结合在一起，然后让AffineConstraint类来处理后者，同时将当前单元的贡献复制到全局线性系统中。

        MatrixTools::local_apply_boundary_values(boundary_values, 
                                                 local_dof_indices, 
                                                 cell_matrix, 
                                                 dummy_cell_rhs, 
                                                 true); 

        constraints.distribute_local_to_global(cell_matrix, 
                                               local_dof_indices, 
                                               system_matrix); 
      } 

// 在积累了所有属于牛顿矩阵的项之后，我们现在还必须计算右手边的项（即负残差）。我们已经在另一个函数中做了这个工作，所以我们在这里调用它。

    system_rhs = calculate_test_rhs(nonlinear_solution); 

// 这里我们使用我们已经构建好的过滤器矩阵。我们只需要整合这个应用于测试函数的过滤器，它是片状常数，所以整合变成了简单的乘以单元格的度量。 遍历预制的过滤器矩阵可以让我们使用哪些单元格在过滤器中或不在过滤器中的信息，而不需要再次重复检查邻居单元格。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        const unsigned int i = cell->active_cell_index(); 
        for (typename SparseMatrix<double>::iterator iter = 
               filter_matrix.begin(i); 
             iter != filter_matrix.end(i); 
             ++iter) 
          { 
            const unsigned int j     = iter->column(); 
            const double       value = iter->value() * cell->measure(); 

            system_matrix 
              .block(SolutionBlocks::unfiltered_density_multiplier, 
                     SolutionBlocks::unfiltered_density) 
              .add(i, j, value); 
            system_matrix 
              .block(SolutionBlocks::unfiltered_density, 
                     SolutionBlocks::unfiltered_density_multiplier) 
              .add(j, i, value); 
          } 
      } 
  } 
// @sect3{Solving the Newton linear system}  

// 我们将需要在每次迭代中解决一个线性系统。我们暂时使用一个直接求解器--对于一个有这么多非零值的矩阵来说，这显然不是一个有效的选择，而且它不会扩展到任何有趣的地方。对于 "真正的 "应用，我们将需要一个迭代求解器，但系统的复杂性意味着一个迭代求解器的算法将需要大量的工作。因为这不是当前程序的重点，所以我们简单地坚持使用我们在这里的直接求解器--该函数遵循与 step-29 中使用的相同结构。

  template <int dim> 
  BlockVector<double> SANDTopOpt<dim>::solve() 
  { 
    TimerOutput::Scope t(timer, "solver"); 

    BlockVector<double> linear_solution; 
    linear_solution.reinit(nonlinear_solution); 

    SparseDirectUMFPACK A_direct; 
    A_direct.initialize(system_matrix); 
    A_direct.vmult(linear_solution, system_rhs); 

    constraints.distribute(linear_solution); 

    return linear_solution; 
  } 
// @sect3{Details of the optimization algorithm}  

// 接下来的几个函数处理优化算法的具体部分，最主要的是决定通过求解线性化（牛顿）系统计算出的方向是否可行，如果可行，我们要在这个方向上走多远。

//  @sect4{Computing step lengths}  

// 我们先用一个函数进行二进制搜索，找出符合对偶可行性的最大步骤--也就是说，我们能走多远，使  $s>0$  和  $z>0$  。该函数返回一对数值，分别代表 $s$ 和 $z$ 的松弛变量。

  template <int dim> 
  std::pair<double, double> SANDTopOpt<dim>::calculate_max_step_size( 
    const BlockVector<double> &state, 
    const BlockVector<double> &step) const 
  { 
    double       fraction_to_boundary; 
    const double min_fraction_to_boundary = .8; 
    const double max_fraction_to_boundary = 1. - 1e-5; 

    if (min_fraction_to_boundary < 1 - barrier_size) 
      { 
        if (1 - barrier_size < max_fraction_to_boundary) 
          fraction_to_boundary = 1 - barrier_size; 
        else 
          fraction_to_boundary = max_fraction_to_boundary; 
      } 
    else 
      fraction_to_boundary = min_fraction_to_boundary; 

    double step_size_s_low  = 0; 
    double step_size_z_low  = 0; 
    double step_size_s_high = 1; 
    double step_size_z_high = 1; 
    double step_size_s, step_size_z; 

    const int max_bisection_method_steps = 50; 
    for (unsigned int k = 0; k < max_bisection_method_steps; ++k) 
      { 
        step_size_s = (step_size_s_low + step_size_s_high) / 2; 
        step_size_z = (step_size_z_low + step_size_z_high) / 2; 

        const BlockVector<double> state_test_s = 
          (fraction_to_boundary * state) + (step_size_s * step); 

        const BlockVector<double> state_test_z = 
          (fraction_to_boundary * state) + (step_size_z * step); 

        const bool accept_s = 
          (state_test_s.block(SolutionBlocks::density_lower_slack) 
             .is_non_negative()) && 
          (state_test_s.block(SolutionBlocks::density_upper_slack) 
             .is_non_negative()); 
        const bool accept_z = 
          (state_test_z.block(SolutionBlocks::density_lower_slack_multiplier) 
             .is_non_negative()) && 
          (state_test_z.block(SolutionBlocks::density_upper_slack_multiplier) 
             .is_non_negative()); 

        if (accept_s) 
          step_size_s_low = step_size_s; 
        else 
          step_size_s_high = step_size_s; 

        if (accept_z) 
          step_size_z_low = step_size_z; 
        else 
          step_size_z_high = step_size_z; 
      } 

    return {step_size_s_low, step_size_z_low}; 
  } 
// @sect4{Computing residuals}  

// 下一个函数计算一个围绕 "测试解向量 "线性化的右手向量，我们可以用它来观察KKT条件的大小。 然后，这将用于在缩小障碍大小之前测试收敛性，以及计算 $l_1$ 的优点。

// 这个函数冗长而复杂，但它实际上只是复制了上面`assemble_system()`函数的右侧部分的内容。

  template <int dim> 
  BlockVector<double> SANDTopOpt<dim>::calculate_test_rhs( 
    const BlockVector<double> &test_solution) const 
  { 

// 我们首先创建一个零向量，其大小和阻塞为system_rhs

    BlockVector<double> test_rhs; 
    test_rhs.reinit(system_rhs); 

    MappingQGeneric<dim>  mapping(1); 
    const QGauss<dim>     quadrature_formula(fe.degree + 1); 
    const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1); 
    FEValues<dim>         fe_values(mapping, 
                            fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 
    FEFaceValues<dim>     fe_face_values(mapping, 
                                     fe, 
                                     face_quadrature_formula, 
                                     update_values | update_quadrature_points | 
                                       update_normal_vectors | 
                                       update_JxW_values); 

    const unsigned int dofs_per_cell = fe.dofs_per_cell; 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    Vector<double>     cell_rhs(dofs_per_cell); 
    FullMatrix<double> dummy_cell_matrix(dofs_per_cell, dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

    std::vector<double> lambda_values(n_q_points); 
    std::vector<double> mu_values(n_q_points); 

    const Functions::ConstantFunction<dim> lambda(1.), mu(1.); 
    std::vector<Tensor<1, dim>>            rhs_values(n_q_points); 

    BlockVector<double> filtered_unfiltered_density_solution = test_solution; 
    BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution = 
      test_solution; 
    filtered_unfiltered_density_solution.block( 
      SolutionBlocks::unfiltered_density) = 0; 
    filter_adjoint_unfiltered_density_multiplier_solution.block( 
      SolutionBlocks::unfiltered_density_multiplier) = 0; 

    filter_matrix.vmult(filtered_unfiltered_density_solution.block( 
                          SolutionBlocks::unfiltered_density), 
                        test_solution.block( 
                          SolutionBlocks::unfiltered_density)); 
    filter_matrix.Tvmult( 
      filter_adjoint_unfiltered_density_multiplier_solution.block( 
        SolutionBlocks::unfiltered_density_multiplier), 
      test_solution.block(SolutionBlocks::unfiltered_density_multiplier)); 

    std::vector<double>                  old_density_values(n_q_points); 
    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points); 
    std::vector<double>                  old_displacement_divs(n_q_points); 
    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points); 
    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points); 
    std::vector<double>         old_displacement_multiplier_divs(n_q_points); 
    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads( 
      n_q_points); 
    std::vector<double> old_lower_slack_multiplier_values(n_q_points); 
    std::vector<double> old_upper_slack_multiplier_values(n_q_points); 
    std::vector<double> old_lower_slack_values(n_q_points); 
    std::vector<double> old_upper_slack_values(n_q_points); 
    std::vector<double> old_unfiltered_density_values(n_q_points); 
    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points); 
    std::vector<double> filtered_unfiltered_density_values(n_q_points); 
    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values( 
      n_q_points); 

    using namespace ValueExtractors; 
    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_rhs = 0; 

        cell->get_dof_indices(local_dof_indices); 

        fe_values.reinit(cell); 

 
        mu.value_list(fe_values.get_quadrature_points(), mu_values); 

        fe_values[densities<dim>].get_function_values(test_solution, 
                                                      old_density_values); 
        fe_values[displacements<dim>].get_function_values( 
          test_solution, old_displacement_values); 
        fe_values[displacements<dim>].get_function_divergences( 
          test_solution, old_displacement_divs); 
        fe_values[displacements<dim>].get_function_symmetric_gradients( 
          test_solution, old_displacement_symmgrads); 
        fe_values[displacement_multipliers<dim>].get_function_values( 
          test_solution, old_displacement_multiplier_values); 
        fe_values[displacement_multipliers<dim>].get_function_divergences( 
          test_solution, old_displacement_multiplier_divs); 
        fe_values[displacement_multipliers<dim>] 
          .get_function_symmetric_gradients( 
            test_solution, old_displacement_multiplier_symmgrads); 
        fe_values[density_lower_slacks<dim>].get_function_values( 
          test_solution, old_lower_slack_values); 
        fe_values[density_lower_slack_multipliers<dim>].get_function_values( 
          test_solution, old_lower_slack_multiplier_values); 
        fe_values[density_upper_slacks<dim>].get_function_values( 
          test_solution, old_upper_slack_values); 
        fe_values[density_upper_slack_multipliers<dim>].get_function_values( 
          test_solution, old_upper_slack_multiplier_values); 
        fe_values[unfiltered_densities<dim>].get_function_values( 
          test_solution, old_unfiltered_density_values); 
        fe_values[unfiltered_density_multipliers<dim>].get_function_values( 
          test_solution, old_unfiltered_density_multiplier_values); 
        fe_values[unfiltered_densities<dim>].get_function_values( 
          filtered_unfiltered_density_solution, 
          filtered_unfiltered_density_values); 
        fe_values[unfiltered_density_multipliers<dim>].get_function_values( 
          filter_adjoint_unfiltered_density_multiplier_solution, 
          filter_adjoint_unfiltered_density_multiplier_values); 

        for (const auto q_point : fe_values.quadrature_point_indices()) 
          { 
            for (const auto i : fe_values.dof_indices()) 
              { 
                const SymmetricTensor<2, dim> displacement_phi_i_symmgrad = 
                  fe_values[displacements<dim>].symmetric_gradient(i, q_point); 
                const double displacement_phi_i_div = 
                  fe_values[displacements<dim>].divergence(i, q_point); 

                const SymmetricTensor<2, dim> 
                  displacement_multiplier_phi_i_symmgrad = 
                    fe_values[displacement_multipliers<dim>].symmetric_gradient( 
                      i, q_point); 
                const double displacement_multiplier_phi_i_div = 
                  fe_values[displacement_multipliers<dim>].divergence(i, 
                                                                      q_point); 

                const double density_phi_i = 
                  fe_values[densities<dim>].value(i, q_point); 
                const double unfiltered_density_phi_i = 
                  fe_values[unfiltered_densities<dim>].value(i, q_point); 
                const double unfiltered_density_multiplier_phi_i = 
                  fe_values[unfiltered_density_multipliers<dim>].value(i, 
                                                                       q_point); 

                const double lower_slack_multiplier_phi_i = 
                  fe_values[density_lower_slack_multipliers<dim>].value( 
                    i, q_point); 

                const double lower_slack_phi_i = 
                  fe_values[density_lower_slacks<dim>].value(i, q_point); 

                const double upper_slack_phi_i = 
                  fe_values[density_upper_slacks<dim>].value(i, q_point); 

                const double upper_slack_multiplier_phi_i = 
                  fe_values[density_upper_slack_multipliers<dim>].value( 
                    i, q_point); 

                /* 方程1：这个方程以及方程
                 * 2 and 3, are the variational derivatives of the 
                 * Lagrangian with respect to the decision 
                 * variables - the density, displacement, and 
                 * unfiltered density. */ 


                cell_rhs(i) += 
                  -1 * fe_values.JxW(q_point) * 
                  (density_penalty_exponent * 
                     std::pow(old_density_values[q_point], 
                              density_penalty_exponent - 1) * 
                     density_phi_i * 
                     (old_displacement_multiplier_divs[q_point] * 
                        old_displacement_divs[q_point] * 
                        lambda_values[q_point] + 
                      2 * mu_values[q_point] * 
                        (old_displacement_symmgrads[q_point] * 
                         old_displacement_multiplier_symmgrads[q_point])) - 
                   density_phi_i * 
                     old_unfiltered_density_multiplier_values[q_point]); 

                /*方程2；边界项将被进一步添加。
                 * below. */ 


                cell_rhs(i) += 
                  -1 * fe_values.JxW(q_point) * 
                  (std::pow(old_density_values[q_point], 
                            density_penalty_exponent) * 
                   (old_displacement_multiplier_divs[q_point] * 
                      displacement_phi_i_div * lambda_values[q_point] + 
                    2 * mu_values[q_point] * 
                      (old_displacement_multiplier_symmgrads[q_point] * 
                       displacement_phi_i_symmgrad))); 
//           
               /* 方程3  */ 
                cell_rhs(i) += 
                  -1 * fe_values.JxW(q_point) * 
                  (unfiltered_density_phi_i * 
                     filter_adjoint_unfiltered_density_multiplier_values 
                       [q_point] + 
                   unfiltered_density_phi_i * 
                     old_upper_slack_multiplier_values[q_point] + 
                   -1 * unfiltered_density_phi_i * 
                     old_lower_slack_multiplier_values[q_point]); 

               /* 方程4；边界项将再次被处理。with below. 
                * This equation being driven to 0 ensures that the elasticity 
                * equation is met as a constraint. */ 
                cell_rhs(i) += -1 * fe_values.JxW(q_point) * 
                               (std::pow(old_density_values[q_point], 
                                         density_penalty_exponent) * 
                                (old_displacement_divs[q_point] * 
                                   displacement_multiplier_phi_i_div * 
                                   lambda_values[q_point] + 
                                 2 * mu_values[q_point] * 
                                   (displacement_multiplier_phi_i_symmgrad * 
                                    old_displacement_symmgrads[q_point]))); 

              /* 方程5：该方程设定了下限的松弛量， giving a minimum density of 0. */ 
                cell_rhs(i) += fe_values.JxW(q_point) * 
                               (lower_slack_multiplier_phi_i * 
                                (old_unfiltered_density_values[q_point] - 
                                 old_lower_slack_values[q_point])); 

/* 方程6：该方程设定了上层松弛量variable equal to one minus the unfiltered density. */ 


                cell_rhs(i) += fe_values.JxW(q_point) * 
                               (upper_slack_multiplier_phi_i * 
                                (1 - old_unfiltered_density_values[q_point] - 
                                 old_upper_slack_values[q_point])); 

                /*等式7：这是在
                 * density and the filter applied to the 
                 * unfiltered density. This being driven to 0 by 
                 * the Newton steps ensures that the filter is 
                 * applied correctly. */ 


                cell_rhs(i) += fe_values.JxW(q_point) * 
                               (unfiltered_density_multiplier_phi_i * 
                                (old_density_values[q_point] - 
                                 filtered_unfiltered_density_values[q_point])); 

                /*方程8：这与方程9一起给出了
                 * requirement that $s*z = \alpha$ for the barrier 
                 * size alpha, and gives complementary slackness 
                 * from KKT conditions when $\alpha$ goes to 0. */ 


                cell_rhs(i) += 
                  -1 * fe_values.JxW(q_point) * 
                  (lower_slack_phi_i * 
                   (old_lower_slack_multiplier_values[q_point] - 
                    barrier_size / old_lower_slack_values[q_point])); 

                /*方程9  */ 
                 cell_rhs(i) += 
                cell_rhs(i) += 
                  -1 * fe_values.JxW(q_point) * 
                  (upper_slack_phi_i * 
                   (old_upper_slack_multiplier_values[q_point] - 
                    barrier_size / old_upper_slack_values[q_point])); 
              } 
          } 

        for (const auto &face : cell->face_iterators()) 
          { 
            if (face->at_boundary() && 
                face->boundary_id() == BoundaryIds::down_force) 
              { 
                fe_face_values.reinit(cell, face); 

                for (const auto face_q_point : 
                     fe_face_values.quadrature_point_indices()) 
                  { 
                    for (const auto i : fe_face_values.dof_indices()) 
                      { 
                        Tensor<1, dim> traction; 
                        traction[1] = -1.; 

                        cell_rhs(i) += 
                          -1 * 
                          (traction * fe_face_values[displacements<dim>].value( 
                                        i, face_q_point)) * 
                          fe_face_values.JxW(face_q_point); 

                        cell_rhs(i) += 
                          (traction * 
                           fe_face_values[displacement_multipliers<dim>].value( 
                             i, face_q_point)) * 
                          fe_face_values.JxW(face_q_point); 
                      } 
                  } 
              } 
          } 

        MatrixTools::local_apply_boundary_values(boundary_values, 
                                                 local_dof_indices, 
                                                 dummy_cell_matrix, 
                                                 cell_rhs, 
                                                 true); 

        constraints.distribute_local_to_global(cell_rhs, 
                                               local_dof_indices, 
                                               test_rhs); 
      } 

    return test_rhs; 
  } 
// @sect4{Computing the merit function}  

// 我们在这里使用的算法使用一个 "看门狗 "策略来确定从当前迭代的位置和程度。 我们将看门狗策略建立在一个精确的 $l_1$ 功绩函数上。这个函数计算一个给定的、假定的、下一个迭代的精确 $l_1$ 功绩。

//优点函数由目标函数的总和（简单来说就是外力的积分（在域的边界上）乘以测试解的位移值（通常是当前解加上牛顿更新的某个倍数），以及残差向量的拉格朗日乘数分量的 $l_1$ 准则组成。下面的代码依次计算这些部分。

  template <int dim> 
  double SANDTopOpt<dim>::calculate_exact_merit( 
    const BlockVector<double> &test_solution) 
  { 
    TimerOutput::Scope t(timer, "merit function"); 

// 从计算目标函数开始。

    double objective_function_merit = 0; 
    { 
      MappingQGeneric<dim>  mapping(1); 
      const QGauss<dim>     quadrature_formula(fe.degree + 1); 
      const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1); 
      FEValues<dim>         fe_values(mapping, 
                              fe, 
                              quadrature_formula, 
                              update_values | update_gradients | 
                                update_quadrature_points | update_JxW_values); 
      FEFaceValues<dim>     fe_face_values(mapping, 
                                       fe, 
                                       face_quadrature_formula, 
                                       update_values | 
                                         update_quadrature_points | 
                                         update_normal_vectors | 
                                         update_JxW_values); 

      const unsigned int n_face_q_points = face_quadrature_formula.size(); 

      std::vector<Tensor<1, dim>> displacement_face_values(n_face_q_points); 

      for (const auto &cell : dof_handler.active_cell_iterators()) 
        { 
          for (const auto &face : cell->face_iterators()) 
            { 
              if (face->at_boundary() && 
                  face->boundary_id() == BoundaryIds::down_force) 
                { 
                  fe_face_values.reinit(cell, face); 
                  fe_face_values[ValueExtractors::displacements<dim>] 
                    .get_function_values(test_solution, 
                                         displacement_face_values); 
                  for (unsigned int face_q_point = 0; 
                       face_q_point < n_face_q_points; 
                       ++face_q_point) 
                    { 
                      Tensor<1, dim> traction; 
                      traction[1] = -1.; 

                      objective_function_merit += 
                        (traction * displacement_face_values[face_q_point]) * 
                        fe_face_values.JxW(face_q_point); 
                    } 
                } 
            } 
        } 
    } 

    for (const auto &cell : triangulation.active_cell_iterators()) 
      { 
        objective_function_merit = 
          objective_function_merit - 
          barrier_size * cell->measure() * 
            std::log(test_solution.block( 
              SolutionBlocks::density_lower_slack)[cell->active_cell_index()]); 
        objective_function_merit = 
          objective_function_merit - 
          barrier_size * cell->measure() * 
            std::log(test_solution.block( 
              SolutionBlocks::density_upper_slack)[cell->active_cell_index()]); 
      } 
//然后
//计算残差，并取对应于拉格朗日多边形的组件的 $l_1$ 准则。我们把这些加到上面计算的目标函数中，并在底部返回总和。

    const BlockVector<double> test_rhs = calculate_test_rhs(test_solution); 

    const double elasticity_constraint_merit = 
      penalty_multiplier * 
      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm(); 
    const double filter_constraint_merit = 
      penalty_multiplier * 
      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm(); 
    const double lower_slack_merit = 
      penalty_multiplier * 
      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm(); 
    const double upper_slack_merit = 
      penalty_multiplier * 
      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm(); 

    const double total_merit = 
      objective_function_merit + elasticity_constraint_merit + 
      filter_constraint_merit + lower_slack_merit + upper_slack_merit; 
    return total_merit; 
  } 

//  @sect4{Finding a search direction}  

// 接下来是实际计算从当前状态（作为第一个参数传递）开始的搜索方向并返回结果向量的函数。为此，该函数首先调用与牛顿系统相对应的线性系统的组合函数，并对其进行求解。

// 这个函数还更新了优点函数中的惩罚乘数，然后返回最大比例的可行步骤。它使用`calculate_max_step_sizes()`函数来找到满足  $s>0$  和  $z>0$  的最大可行步骤。

  template <int dim> 
  BlockVector<double> SANDTopOpt<dim>::find_max_step() 
  { 
    assemble_system(); 
    BlockVector<double> step = solve(); 

// 接下来我们要更新punice_multiplier。 从本质上讲，更大的惩罚乘数使我们更多考虑约束条件。 观察与我们的决策变量有关的Hessian和梯度，并将其与我们的约束误差的规范相比较，可以确保我们的优点函数是 "精确的"

// 也就是说，它在与目标函数相同的位置有一个最小值。 由于我们的优点函数对任何超过某个最小值的惩罚乘数都是精确的，所以我们只保留计算值，如果它增加了惩罚乘数。

    const std::vector<unsigned int> decision_variables = { 
      SolutionBlocks::density, 
      SolutionBlocks::displacement, 
      SolutionBlocks::unfiltered_density, 
      SolutionBlocks::density_upper_slack, 
      SolutionBlocks::density_lower_slack}; 
    double hess_part = 0; 
    double grad_part = 0; 
    for (const unsigned int decision_variable_i : decision_variables) 
      { 
        for (const unsigned int decision_variable_j : decision_variables) 
          { 
            Vector<double> temp_vector(step.block(decision_variable_i).size()); 
            system_matrix.block(decision_variable_i, decision_variable_j) 
              .vmult(temp_vector, step.block(decision_variable_j)); 
            hess_part += step.block(decision_variable_i) * temp_vector; 
          } 
        grad_part -= system_rhs.block(decision_variable_i) * 
                     step.block(decision_variable_i); 
      } 

    const std::vector<unsigned int> equality_constraint_multipliers = { 
      SolutionBlocks::displacement_multiplier, 
      SolutionBlocks::unfiltered_density_multiplier, 
      SolutionBlocks::density_lower_slack_multiplier, 
      SolutionBlocks::density_upper_slack_multiplier}; 
    double constraint_norm = 0; 
    for (unsigned int multiplier_i : equality_constraint_multipliers) 
      constraint_norm += system_rhs.block(multiplier_i).linfty_norm(); 

    double test_penalty_multiplier; 
    if (hess_part > 0) 
      test_penalty_multiplier = 
        (grad_part + .5 * hess_part) / (.05 * constraint_norm); 
    else 
      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm); 

    penalty_multiplier = std::max(penalty_multiplier, test_penalty_multiplier); 

// 基于所有这些，我们现在可以计算出原始变量和对偶变量（拉格朗日乘数）的步长。一旦我们有了这些，我们就可以对解向量的分量进行缩放，这就是这个函数的回报。

    const std::pair<double, double> max_step_sizes = 
      calculate_max_step_size(nonlinear_solution, step); 
    const double step_size_s = max_step_sizes.first; 
    const double step_size_z = max_step_sizes.second; 

    step.block(SolutionBlocks::density) *= step_size_s; 
    step.block(SolutionBlocks::displacement) *= step_size_s; 
    step.block(SolutionBlocks::unfiltered_density) *= step_size_s; 
    step.block(SolutionBlocks::displacement_multiplier) *= step_size_z; 
    step.block(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z; 
    step.block(SolutionBlocks::density_lower_slack) *= step_size_s; 
    step.block(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z; 
    step.block(SolutionBlocks::density_upper_slack) *= step_size_s; 
    step.block(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z; 

    return step; 
  } 

//  @sect4{Computing a scaled step}  

// 下一个函数接着实现了直线搜索的反向跟踪算法。它不断缩小步长，直到找到一个优点减少的步长，然后根据当前的状态向量，以及要进入的方向，乘以步长，返回新的位置。

  template <int dim> 
  BlockVector<double> 
  SANDTopOpt<dim>::compute_scaled_step(const BlockVector<double> &state, 
                                       const BlockVector<double> &max_step, 
                                       const double descent_requirement) 
  { 
    const double merit_derivative = 
      (calculate_exact_merit(state + 1e-4 * max_step) - 
       calculate_exact_merit(state)) / 
      1e-4; 
    double       step_size                 = 1; 
    unsigned int max_linesearch_iterations = 10; 
    for (unsigned int k = 0; k < max_linesearch_iterations; ++k) 
      { 
        if (calculate_exact_merit(state + step_size * max_step) < 
            calculate_exact_merit(state) + 
              step_size * descent_requirement * merit_derivative) 
          break; 
        else 
          step_size = step_size / 2; 
      } 
    return state + (step_size * max_step); 
  } 
// @sect4{Checking for convergence}  

// 本块中的最后一个辅助函数是检查是否充分满足KKT条件，以便整个算法可以降低障碍物的大小。它通过计算残差的 $l_1$ 准则来实现，这就是`calculate_test_rhs()`的计算。

  template <int dim> 
  bool SANDTopOpt<dim>::check_convergence(const BlockVector<double> &state) 
  { 
    const BlockVector<double> test_rhs      = calculate_test_rhs(state); 
    const double              test_rhs_norm = test_rhs.l1_norm(); 

    const double convergence_condition = 1e-2; 
    const double target_norm           = convergence_condition * barrier_size; 

    std::cout << "    Checking convergence. Current rhs norm is " 
              << test_rhs_norm << ", target is " << target_norm << std::endl; 

    return (test_rhs_norm < target_norm); 
  } 
// @sect3{Postprocessing the solution}  

// 后处理函数中的第一个函数在VTU文件中输出信息，用于可视化。它看起来很长，但实际上与  step-22  中所做的一样，例如，只是增加了（很多）解决方案的变量。

  template <int dim> 
  void SANDTopOpt<dim>::output_results(const unsigned int iteration) const 
  { 
    std::vector<std::string> solution_names(1, "density"); 
    std::vector<DataComponentInterpretation::DataComponentInterpretation> 
      data_component_interpretation( 
        1, DataComponentInterpretation::component_is_scalar); 
    for (unsigned int i = 0; i < dim; ++i) 
      { 
        solution_names.emplace_back("displacement"); 
        data_component_interpretation.push_back( 
          DataComponentInterpretation::component_is_part_of_vector); 
      } 
    solution_names.emplace_back("unfiltered_density"); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    for (unsigned int i = 0; i < dim; ++i) 
      { 
        solution_names.emplace_back("displacement_multiplier"); 
        data_component_interpretation.push_back( 
          DataComponentInterpretation::component_is_part_of_vector); 
      } 
    solution_names.emplace_back("unfiltered_density_multiplier"); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    solution_names.emplace_back("low_slack"); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    solution_names.emplace_back("low_slack_multiplier"); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    solution_names.emplace_back("high_slack"); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 
    solution_names.emplace_back("high_slack_multiplier"); 
    data_component_interpretation.push_back( 
      DataComponentInterpretation::component_is_scalar); 

    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 
    data_out.add_data_vector(nonlinear_solution, 
                             solution_names, 
                             DataOut<dim>::type_dof_data, 
                             data_component_interpretation); 
    data_out.build_patches(); 

    std::ofstream output("solution" + std::to_string(iteration) + ".vtu"); 
    data_out.write_vtu(output); 
  } 

// 其中第二个函数将解决方案输出为`.stl`文件，用于3D打印。STL](https:en.wikipedia.org/wiki/STL_(file_format))文件是由三角形和法线向量组成的，我们将用它来显示所有那些密度值大于0的单元，首先将网格从 $z$ 值挤出到 $z=0.25$  ，然后为密度值足够大的单元的每个面生成两个三角形。当从外面看时，三角形节点必须逆时针走，法向量必须是指向外部的单位向量，这需要进行一些检查。

  template <int dim> 
  void SANDTopOpt<dim>::write_as_stl() 
  { 
    static_assert(dim == 2, 
                  "This function is not implemented for anything " 
                  "other than the 2d case."); 

    std::ofstream stlfile; 
    stlfile.open("bridge.stl"); 

    stlfile << "solid bridge\n" << std::scientific; 
    double height = .25; 

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        if (nonlinear_solution.block( 
              SolutionBlocks::density)[cell->active_cell_index()] > 0.5) 
          { 

// 我们现在已经找到了一个密度值大于0的单元。让我们先写出底部和顶部的面。由于上面提到的排序问题，我们必须确保了解一个单元的坐标系是右旋的还是左旋的。我们通过询问从顶点0开始的两条边的方向以及它们是否形成一个右手坐标系来做到这一点。

            const Tensor<1, dim> edge_directions[2] = {cell->vertex(1) - 
                                                         cell->vertex(0), 
                                                       cell->vertex(2) - 
                                                         cell->vertex(0)}; 
            const Tensor<2, dim> edge_tensor( 
              {{edge_directions[0][0], edge_directions[0][1]}, 
               {edge_directions[1][0], edge_directions[1][1]}}); 
            const bool is_right_handed_cell = (determinant(edge_tensor) > 0); 

            if (is_right_handed_cell) 
              { 

               /*在z=0处写出一个边。  */ 

               /*写出一个边 */
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << -1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(0)[0] << " " 
                        << cell->vertex(0)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << -1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(3)[0] << " " 
                        << cell->vertex(3)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
               /*在z=高度处写下一个边。  */  
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << 1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(0)[0] << " " 
                        << cell->vertex(0)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << height << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << 1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(3)[0] << " " 
                        << cell->vertex(3)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << height << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
              } 
            else /* The cell has a left-handed set up */ 
              { 
               /* 在z=0处写出一边。  */ 
                stlfile << "   facet normal " << 0.000000e+00 << " "
                        << 0.000000e+00 << " " << -1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(0)[0] << " " 
                        << cell->vertex(0)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << -1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(3)[0] << " " 
                        << cell->vertex(3)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 

               /*在z=高度处写出一个边。  */ 
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << 1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(0)[0] << " " 
                        << cell->vertex(0)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << height << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
                stlfile << "   facet normal " << 0.000000e+00 << " " 
                        << 0.000000e+00 << " " << 1.000000e+00 << "\n"; 
                stlfile << "      outer loop\n"; 
                stlfile << "         vertex " << cell->vertex(1)[0] << " " 
                        << cell->vertex(1)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(2)[0] << " " 
                        << cell->vertex(2)[1] << " " << height << "\n"; 
                stlfile << "         vertex " << cell->vertex(3)[0] << " " 
                        << cell->vertex(3)[1] << " " << height << "\n"; 
                stlfile << "      endloop\n"; 
                stlfile << "   endfacet\n"; 
              } 

// 接下来我们需要处理单元格的四个面，扩展到 $z$ 方向。然而，我们只需要写这些面，如果该面在域的边界上，或者它是密度大于0.5的单元和密度小于0.5的单元之间的界面。

            for (unsigned int face_number = 0; 
                 face_number < GeometryInfo<dim>::faces_per_cell; 
                 ++face_number) 
              { 
                const typename DoFHandler<dim>::face_iterator face = 
                  cell->face(face_number); 

                if ((face->at_boundary()) || 
                    (!face->at_boundary() && 
                     (nonlinear_solution.block( 
                        0)[cell->neighbor(face_number)->active_cell_index()] < 
                      0.5))) 
                  { 
                    const Tensor<1, dim> normal_vector = 
                      (face->center() - cell->center()); 
                    const double normal_norm = normal_vector.norm(); 
                    if ((face->vertex(0)[0] - face->vertex(0)[0]) * 
                            (face->vertex(1)[1] - face->vertex(0)[1]) * 
                            0.000000e+00 + 
                          (face->vertex(0)[1] - face->vertex(0)[1]) * (0 - 0) * 
                            normal_vector[0] + 
                          (height - 0) * 
                            (face->vertex(1)[0] - face->vertex(0)[0]) * 
                            normal_vector[1] - 
                          (face->vertex(0)[0] - face->vertex(0)[0]) * (0 - 0) * 
                            normal_vector[1] - 
                          (face->vertex(0)[1] - face->vertex(0)[1]) * 
                            (face->vertex(1)[0] - face->vertex(0)[0]) * 
                            normal_vector[0] - 
                          (height - 0) * 
                            (face->vertex(1)[1] - face->vertex(0)[1]) * 0 > 
                        0) 
                      { 
                        stlfile << "   facet normal " 
                                << normal_vector[0] / normal_norm << " " 
                                << normal_vector[1] / normal_norm << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "      outer loop\n"; 
                        stlfile << "         vertex " << face->vertex(0)[0] 
                                << " " << face->vertex(0)[1] << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "         vertex " << face->vertex(0)[0] 
                                << " " << face->vertex(0)[1] << " " << height 
                                << "\n"; 
                        stlfile << "         vertex " << face->vertex(1)[0] 
                                << " " << face->vertex(1)[1] << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "      endloop\n"; 
                        stlfile << "   endfacet\n"; 
                        stlfile << "   facet normal " 
                                << normal_vector[0] / normal_norm << " " 
                                << normal_vector[1] / normal_norm << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "      outer loop\n"; 
                        stlfile << "         vertex " << face->vertex(0)[0] 
                                << " " << face->vertex(0)[1] << " " << height 
                                << "\n"; 
                        stlfile << "         vertex " << face->vertex(1)[0] 
                                << " " << face->vertex(1)[1] << " " << height 
                                << "\n"; 
                        stlfile << "         vertex " << face->vertex(1)[0] 
                                << " " << face->vertex(1)[1] << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "      endloop\n"; 
                        stlfile << "   endfacet\n"; 
                      } 
                    else 
                      { 
                        stlfile << "   facet normal " 
                                << normal_vector[0] / normal_norm << " " 
                                << normal_vector[1] / normal_norm << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "      outer loop\n"; 
                        stlfile << "         vertex " << face->vertex(0)[0] 
                                << " " << face->vertex(0)[1] << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "         vertex " << face->vertex(1)[0] 
                                << " " << face->vertex(1)[1] << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "         vertex " << face->vertex(0)[0] 
                                << " " << face->vertex(0)[1] << " " << height 
                                << "\n"; 
                        stlfile << "      endloop\n"; 
                        stlfile << "   endfacet\n"; 
                        stlfile << "   facet normal " 
                                << normal_vector[0] / normal_norm << " " 
                                << normal_vector[1] / normal_norm << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "      outer loop\n"; 
                        stlfile << "         vertex " << face->vertex(0)[0] 
                                << " " << face->vertex(0)[1] << " " << height 
                                << "\n"; 
                        stlfile << "         vertex " << face->vertex(1)[0] 
                                << " " << face->vertex(1)[1] << " " 
                                << 0.000000e+00 << "\n"; 
                        stlfile << "         vertex " << face->vertex(1)[0] 
                                << " " << face->vertex(1)[1] << " " << height 
                                << "\n"; 
                        stlfile << "      endloop\n"; 
                        stlfile << "   endfacet\n"; 
                      } 
                  } 
              } 
          } 
      } 
    stlfile << "endsolid bridge"; 
  } 

//  @sect3{The run() function driving the overall algorithm}  

// 这个函数最终提供了整体的驱动逻辑。从总体上看，这是一个相当复杂的函数，主要是因为优化算法很困难：它不仅仅是像 step-15 中那样找到一个牛顿方向，然后在这个方向上再走一个固定的距离，而是要（i）确定当前步骤中的最佳对数障碍惩罚参数应该是什么，（ii）通过复杂的算法来确定我们要走多远，还有其他成分。让我们看看如何在下面的文件中把它分解成小块。

// 该函数一开始就很简单，首先设置了网格、DoFHandler，然后是下面所需的各种线性代数对象。

  template <int dim> 
  void SANDTopOpt<dim>::run() 
  { 
    std::cout << "filter r is: " << filter_r << std::endl; 

    { 
      TimerOutput::Scope t(timer, "setup"); 

      create_triangulation(); 

      dof_handler.distribute_dofs(fe); 
      DoFRenumbering::component_wise(dof_handler); 

      setup_boundary_values(); 
      setup_block_system(); 
      setup_filter_matrix(); 
    } 

// 然后，我们设置一些影响优化算法的对数屏障和直线搜索部分的参数。

    barrier_size                  = 25; 
    const double min_barrier_size = .0005; 

    const unsigned int max_uphill_steps    = 8; 
    const double       descent_requirement = .0001; 

// 现在开始进行主迭代。整个算法通过使用一个外循环来工作，在这个外循环中，我们一直循环到（i）对数障碍参数变得足够小，或者（ii）我们已经达到收敛。在任何情况下，如果最终的迭代次数过多，我们就会终止。这个整体结构被编码为一个 "do{ ... } while (...)`循环，其中收敛条件在底部。

    unsigned int       iteration_number = 0; 
    const unsigned int max_iterations   = 10000; 

    do 
      { 
        std::cout << "Starting outer step in iteration " << iteration_number 
                  << " with barrier parameter " << barrier_size << std::endl; 

// 在这个外循环中，我们有一个内循环，在这个内循环中，我们试图使用介绍中描述的看门狗算法找到一个更新方向。

// 看门狗算法本身的总体思路是这样的。对于最大的`max_uphill_steps`（即上述 "内循环 "中的一个循环）的尝试，我们使用`find_max_step()`来计算牛顿更新步骤，并在`nonlinear_solution`向量中加上这些。 在每一次尝试中（从上一次尝试结束时到达的地方开始），我们检查我们是否已经达到了上述优点函数的目标值。目标值是根据本算法的起始位置（看门狗循环开始时的`nonlinear_solution'，保存为`看门狗_state'）和本循环第一个回合中`find_max_step()'提供的第一个建议方向（`k=0'情况）计算的。

        do 
          { 
            std::cout << "  Starting inner step in iteration " 
                      << iteration_number 
                      << " with merit function penalty multiplier " 
                      << penalty_multiplier << std::endl; 

            bool watchdog_step_found = false; 

            const BlockVector<double> watchdog_state = nonlinear_solution; 
            BlockVector<double>       first_step; 
            double target_merit     = numbers::signaling_nan<double>(); 
            double merit_derivative = numbers::signaling_nan<double>(); 

            for (unsigned int k = 0; k < max_uphill_steps; ++k) 
              { 
                ++iteration_number; 
                const BlockVector<double> update_step = find_max_step(); 

                if (k == 0) 
                  { 
                    first_step = update_step; 
                    merit_derivative = 
                      ((calculate_exact_merit(watchdog_state + 
                                              .0001 * first_step) - 
                        calculate_exact_merit(watchdog_state)) / 
                       .0001); 
                    target_merit = calculate_exact_merit(watchdog_state) + 
                                   descent_requirement * merit_derivative; 
                  } 

                nonlinear_solution += update_step; 
                const double current_merit = 
                  calculate_exact_merit(nonlinear_solution); 

                std::cout << "    current watchdog state merit is: " 
                          << current_merit << "; target merit is " 
                          << target_merit << std::endl; 

                if (current_merit < target_merit) 
                  { 
                    watchdog_step_found = true; 
                    std::cout << "    found workable step after " << k + 1 
                              << " iterations" << std::endl; 
                    break; 
                  } 
              } 
//然后
//算法的下一部分取决于上面的看门狗循环是否成功。如果成功了，那么我们就满意了，不需要进一步的行动。我们只是停留在原地。然而，如果我们在上面的循环中采取了最大数量的不成功的步骤，那么我们就需要做一些别的事情，这就是下面的代码块所做的。    具体来说，从上述循环的最后（不成功的）状态开始，我们再寻找一个更新方向，并采取所谓的 "伸展步骤"。如果该拉伸状态满足涉及优点函数的条件，那么我们就去那里。另一方面，如果拉伸状态也是不可接受的（就像上面所有的看门狗步骤一样），那么我们就放弃上面所有的看门狗步骤，在我们开始看门狗迭代的地方重新开始--那个地方被存储在上面的`看门狗_状态`变量中。更具体地说，下面的条件首先测试我们是否从`看门狗_state`方向的`first_step`走了一步，或者我们是否可以从拉伸状态再做一次更新来找到一个新的地方。有可能这两种情况实际上都不比我们在看门狗算法开始时的状态好，但即使是这样，那个地方显然是个困难的地方，离开后从另一个地方开始下一次迭代可能是一个有用的策略，最终收敛。    我们不断重复上面的看门狗步骤以及下面的逻辑，直到这个内部迭代最终收敛（或者如果我们遇到最大的迭代次数--在这里我们把线性求解的次数算作迭代次数，并在每次调用`find_max_step()`时增加计数器，因为这就是线性求解实际发生的地方）。在任何情况下，在这些内部迭代的每一次结束时，我们也会以适合可视化的形式输出解决方案。

            if (watchdog_step_found == false) 
              { 
                ++iteration_number; 
                const BlockVector<double> update_step = find_max_step(); 
                const BlockVector<double> stretch_state = 
                  compute_scaled_step(nonlinear_solution, 
                                      update_step, 
                                      descent_requirement); 

// 如果我们没有得到一个成功的看门狗步骤，我们现在需要决定是回到我们开始的地方，还是使用最终状态。 我们比较这两个位置的优劣，然后从哪个位置取一个按比例的步长。 由于按比例的步长可以保证降低优点，所以我们最终会保留这两个位置中的一个。

                if ((calculate_exact_merit(nonlinear_solution) < 
                     calculate_exact_merit(watchdog_state)) || 
                    (calculate_exact_merit(stretch_state) < target_merit)) 
                  { 
                    std::cout << "    Taking scaled step from end of watchdog" 
                              << std::endl; 
                    nonlinear_solution = stretch_state; 
                  } 
                else 
                  { 
                    std::cout 
                      << "    Taking scaled step from beginning of watchdog" 
                      << std::endl; 
                    if (calculate_exact_merit(stretch_state) > 
                        calculate_exact_merit(watchdog_state)) 
                      { 
                        nonlinear_solution = 
                          compute_scaled_step(watchdog_state, 
                                              first_step, 
                                              descent_requirement); 
                      } 
                    else 
                      { 
                        ++iteration_number; 
                        nonlinear_solution = stretch_state; 
                        const BlockVector<double> stretch_step = 
                          find_max_step(); 
                        nonlinear_solution = 
                          compute_scaled_step(nonlinear_solution, 
                                              stretch_step, 
                                              descent_requirement); 
                      } 
                  } 
              } 

            output_results(iteration_number); 
          } 
        while ((iteration_number < max_iterations) && 
               (check_convergence(nonlinear_solution) == false)); 

// 在外循环结束时，我们必须更新屏障参数，为此我们使用以下公式。该函数的其余部分只是检查外循环的收敛条件，如果我们决定终止计算，就把最终的 "设计 "写成STL文件，用于3D打印，并输出一些时间信息。

        const double barrier_size_multiplier = .8; 
        const double barrier_size_exponent   = 1.2; 

        barrier_size = 
          std::max(std::min(barrier_size * barrier_size_multiplier, 
                            std::pow(barrier_size, barrier_size_exponent)), 
                   min_barrier_size); 

        std::cout << std::endl; 
      } 
    while (((barrier_size > min_barrier_size) || 
            (check_convergence(nonlinear_solution) == false)) && 
           (iteration_number < max_iterations)); 

    write_as_stl(); 
    timer.print_summary(); 
  } 
} // namespace SAND 
// @sect3{The main function}  

// 余下的代码，即`main()`函数，和平常一样。

int main() 
{ 
  try 
    { 
      SAND::SANDTopOpt<2> elastic_problem_2d; 
      elastic_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
 
 
 
 
 
} 


CCTest_file/step-8.cc

/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2000 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 2000 
 */ 


// @sect3{Include files}  

// 像往常一样，前几个include文件已经知道了，所以我们将不再评论它们。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/tensor.h> 

#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_cg.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 

#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 

#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 

#include <deal.II/fe/fe_values.h> 

#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/numerics/error_estimator.h> 

// 在这个例子中，我们需要矢量值的有限元。对这些的支持可以在下面的include文件中找到。

#include <deal.II/fe/fe_system.h> 

// 我们将用常规的Q1元素组成矢量值的有限元素，这些元素可以在这里找到，像往常一样。

#include <deal.II/fe/fe_q.h> 

// 这又是C++语言。

#include <fstream> 
#include <iostream> 

// 最后一步和以前的程序一样。特别是，就像在 step-7 中一样，我们把这个程序所特有的一切都打包到一个自己的命名空间中。

namespace Step8 
{ 
  using namespace dealii; 
// @sect3{The <code>ElasticProblem</code> class template}  

// 主类除了名称外，与 step-6 的例子相比几乎没有变化。

// 唯一的变化是为 <code>fe</code> 变量使用了一个不同的类。我们现在使用的不是FE_Q这样具体的有限元类，而是一个更通用的类，FESystem。事实上，FESystem本身并不是一个真正的有限元，因为它没有实现自己的形状函数。相反，它是一个可以用来将其他几个元素堆叠在一起形成一个矢量值的有限元的类。在我们的例子中，我们将组成 <code>FE_Q(1)</code> 对象的矢量值元素，如下所示，在这个类的构造函数中。

  template <int dim> 
  class ElasticProblem 
  { 
  public: 
    ElasticProblem(); 
    void run(); 

  private: 
    void setup_system(); 
    void assemble_system(); 
    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim> triangulation; 
    DoFHandler<dim>    dof_handler; 

    FESystem<dim> fe; 

    AffineConstraints<double> constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 
  }; 
// @sect3{Right hand side values}  

// 在进入主类的实现之前，我们声明并定义描述右手边的函数。这一次，右手边是向量值，解决方案也是如此，所以我们将更详细地描述为此所需的变化。

// 为了防止出现返回向量没有被设置成正确大小的情况，我们对这种情况进行了测试，否则将在函数的开始部分抛出一个异常。请注意，强制输出参数已经具有正确的大小是deal.II中的一个惯例，并且几乎在所有地方都强制执行。原因是，否则我们将不得不在函数开始时检查，并可能改变输出向量的大小。这很昂贵，而且几乎总是不必要的（对函数的第一次调用会将向量设置为正确的大小，随后的调用只需要做多余的检查）。此外，如果我们不能依赖向量已经具有正确大小的假设，那么检查和可能调整向量大小的操作是不能被删除的；这与Assert调用是一个契约，如果程序在优化模式下编译，Assert调用将被完全删除。

// 同样，如果由于某种意外，有人试图在只有一个空间维度的情况下编译和运行程序（在这种情况下，弹性方程没有什么意义，因为它们还原为普通的拉普拉斯方程），我们在第二个断言中终止程序。然而，该程序在三维空间中也能正常工作。

  template <int dim> 
  void right_hand_side(const std::vector<Point<dim>> &points, 
                       std::vector<Tensor<1, dim>> &  values) 
  { 
    Assert(values.size() == points.size(), 
           ExcDimensionMismatch(values.size(), points.size())); 
    Assert(dim >= 2, ExcNotImplemented()); 

// 该函数的其余部分实现了计算力值。我们将使用一个位于(0.5,0)和(-0.5,0)点周围的两个小圆圈（或球体，在3D中）的X方向的恒定（单位）力，以及位于原点周围的Y方向的力；在3D中，这些中心的Z分量也是零。

// 为此，让我们首先定义两个对象，表示这些区域的中心。请注意，在构建点对象时，所有的分量都被设置为零。

    Point<dim> point_1, point_2; 
    point_1(0) = 0.5; 
    point_2(0) = -0.5; 

    for (unsigned int point_n = 0; point_n < points.size(); ++point_n) 
      { 

// 如果 <code>points[point_n]</code> 处于围绕这些点之一的半径为0.2的圆（球）中，那么将X方向的力设置为1，否则为0。

        if (((points[point_n] - point_1).norm_square() < 0.2 * 0.2) || 
            ((points[point_n] - point_2).norm_square() < 0.2 * 0.2)) 
          values[point_n][0] = 1.0; 
        else 
          values[point_n][0] = 0.0; 

// 同样地，如果 <code>points[point_n]</code> 在原点附近，那么将y力设置为1，否则为0。

        if (points[point_n].norm_square() < 0.2 * 0.2) 
          values[point_n][1] = 1.0; 
        else 
          values[point_n][1] = 0.0; 
      } 
  } 

//  @sect3{The <code>ElasticProblem</code> class implementation}  
// @sect4{ElasticProblem::ElasticProblem constructor}  

// 下面是主类的构造函数。如前所述，我们想构造一个由多个标量有限元组成的矢量值有限元（即，我们想构造矢量值元素，使其每个矢量成分都由一个标量元素的形状函数组成）。当然，我们想堆叠在一起的标量有限元的数量等于解函数的分量数量，由于我们考虑每个空间方向上的位移，所以是 <code>dim</code> 。FESystem类可以处理这个问题：我们传递给它我们想组成系统的有限元，以及它的重复频率。

  template <int dim> 
  ElasticProblem<dim>::ElasticProblem() 
    : dof_handler(triangulation) 
    , fe(FE_Q<dim>(1), dim) 
  {} 

// 事实上，FESystem类还有几个构造函数，可以进行更复杂的操作，而不仅仅是将几个相同类型的标量有限元堆叠在一起；我们将在后面的例子中了解这些可能性。

//  @sect4{ElasticProblem::setup_system}  

// 设置方程组与 step-6 例子中使用的函数相同。DoFHandler类和这里使用的所有其他类都完全知道我们要使用的有限元是矢量值的，并且照顾到了有限元本身的矢量值。(事实上，它们不知道，但这不需要困扰你：因为它们只需要知道每个顶点、直线和单元有多少个自由度，它们不问它们代表什么，也就是说，考虑的有限元是矢量值的，还是例如在每个顶点上有几个自由度的标量Hermite元)。

  template <int dim> 
  void ElasticProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 

    constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, constraints); 
    VectorTools::interpolate_boundary_values(dof_handler, 
                                             0, 
                                             Functions::ZeroFunction<dim>(dim), 
                                             constraints); 
    constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    constraints, 
                                    /*keep_constrained_dofs =  */ false);

    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 
  } 
// @sect4{ElasticProblem::assemble_system}  

// 这个程序中最大的变化是创建矩阵和右手边，因为它们是取决于问题的。我们将一步一步地完成这个过程  step-  ，因为它比以前的例子要复杂一些。

// 然而，这个函数的前几部分和以前一样：设置一个合适的正交公式，为我们使用的（矢量值）有限元以及正交对象初始化一个FEValues对象，并声明了一些辅助数组。此外，我们还声明了永远相同的两个缩写。  <code>n_q_points</code>  和  <code>dofs_per_cell</code>  。每个单元的自由度数量，我们现在显然是从组成的有限元中询问，而不是从底层的标量Q1元中询问。在这里，它是 <code>dim</code> 乘以Q1元素的每个单元的自由度数，尽管这不是我们需要关心的明确知识。

  template <int dim> 
  void ElasticProblem<dim>::assemble_system() 
  { 
    QGauss<dim> quadrature_formula(fe.degree + 1); 

    FEValues<dim> fe_values(fe, 
                            quadrature_formula, 
                            update_values | update_gradients | 
                              update_quadrature_points | update_JxW_values); 

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points    = quadrature_formula.size(); 

    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell); 
    Vector<double>     cell_rhs(dofs_per_cell); 

    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell); 

// 正如前面的例子所示，我们需要一个地方来存储单元格上所有正交点的系数值。在目前的情况下，我们有两个系数，lambda和mu。

    std::vector<double> lambda_values(n_q_points); 
    std::vector<double> mu_values(n_q_points); 

// 好吧，我们也可以省略上面的两个数组，因为我们将对lambda和mu使用常数系数，可以这样声明。它们都代表函数总是返回常量值1.0。尽管我们可以在矩阵的组合中省略各自的系数，但为了演示，我们在这里使用它们。

    Functions::ConstantFunction<dim> lambda(1.), mu(1.); 

// 和上面的两个常量函数一样，我们将在每个单元格中只调用一次函数right_hand_side，以使事情更简单。

    std::vector<Tensor<1, dim>> rhs_values(n_q_points); 

// 现在我们可以开始对所有单元格进行循环。

    for (const auto &cell : dof_handler.active_cell_iterators()) 
      { 
        cell_matrix = 0; 
        cell_rhs    = 0; 

        fe_values.reinit(cell); 

// 接下来我们得到正交点的系数值。同样，对于右手边也是如此。

        lambda.value_list(fe_values.get_quadrature_points(), lambda_values); 
        mu.value_list(fe_values.get_quadrature_points(), mu_values); 
        right_hand_side(fe_values.get_quadrature_points(), rhs_values); 

// 然后将局部刚度矩阵的条目和右手边的向量组合起来。这几乎是一对一地遵循本例介绍中描述的模式。 在位的几个评论之一是，我们可以计算数字  <code>comp(i)</code>  ，即使用下面的  <code>fe.system_to_component_index(i).first</code>  函数调用形状函数  <code>i</code>  的唯一非零向量成分的索引。

//（通过访问 <code>system_to_component_index</code> 函数返回值的 <code>first</code> 变量，你可能已经猜到其中还有更多的内容。事实上，该函数返回一个 <code>std::pair@<unsigned int，无符号int @></code>, ，其中第一个元素是 <code>comp(i)</code> ，第二个元素是介绍中也指出的值 <code>base(i)</code> ，即这个形状函数在这个组件中所有非零的形状函数中的索引，即介绍中的字典 <code>base(i)</code> 。不过，这不是我们通常感兴趣的数字）。)

// 有了这些知识，我们就可以把局部矩阵的贡献集合起来。

        for (const unsigned int i : fe_values.dof_indices()) 
          { 
            const unsigned int component_i = 
              fe.system_to_component_index(i).first; 

            for (const unsigned int j : fe_values.dof_indices()) 
              { 
                const unsigned int component_j = 
                  fe.system_to_component_index(j).first; 

                for (const unsigned int q_point : 
                     fe_values.quadrature_point_indices()) 
                  { 
                    cell_matrix(i, j) += 

// 第一个项是  $\lambda \partial_i u_i, \partial_j v_j) + (\mu \partial_i u_j, \partial_j v_i)$  。注意， <code>shape_grad(i,q_point)</code> 返回正交点q_point处第i个形状函数的唯一非零分量的梯度。梯度的分量 <code>comp(i)</code> 是第i个形状函数的唯一非零矢量分量相对于comp(i)th坐标的导数，由附加的括号访问。

                      (                                                  // 
                        (fe_values.shape_grad(i, q_point)[component_i] * // 
                         fe_values.shape_grad(j, q_point)[component_j] * // 
                         lambda_values[q_point])                         // 
                        +                                                // 
                        (fe_values.shape_grad(i, q_point)[component_j] * // 
                         fe_values.shape_grad(j, q_point)[component_i] * // 
                         mu_values[q_point])                             // 
                        +                                                // 

// 第二个项是  $(\mu \nabla u_i, \nabla v_j)$  。我们不需要访问梯度的具体分量，因为我们只需要计算两个梯度的标量乘积，这个问题由<tt>operator*</tt>的重载版本来负责，就像前面的例子一样。                            注意，通过使用<tt>?:</tt>操作符，我们只在<tt>component_i</tt>等于<tt>component_j</tt>时才这样做，否则会加上一个零（编译器会将其优化掉）。

                        ((component_i == component_j) ?        // 
                           (fe_values.shape_grad(i, q_point) * // 
                            fe_values.shape_grad(j, q_point) * // 
                            mu_values[q_point]) :              // 
                           0)                                  // 
                        ) *                                    // 
                      fe_values.JxW(q_point);                  // 
                  } 
              } 
          } 

// 组装右手边也和介绍中讨论的一样。

        for (const unsigned int i : fe_values.dof_indices()) 
          { 
            const unsigned int component_i = 
              fe.system_to_component_index(i).first; 

            for (const unsigned int q_point : 
                 fe_values.quadrature_point_indices()) 
              cell_rhs(i) += fe_values.shape_value(i, q_point) * 
                             rhs_values[q_point][component_i] * 
                             fe_values.JxW(q_point); 
          } 

// 从局部自由度到全局矩阵和右手向量的转移不取决于所考虑的方程，因此与之前所有的例子相同。

        cell->get_dof_indices(local_dof_indices); 
        constraints.distribute_local_to_global( 
          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); 
      } 
  } 

//  @sect4{ElasticProblem::solve}  

// 解算器并不关心方程组的来源，只要它保持正定和对称（这是使用CG解算器的要求），而这个方程组确实是这样。因此，我们不需要改变任何东西。

  template <int dim> 
  void ElasticProblem<dim>::solve() 
  { 
    SolverControl            solver_control(1000, 1e-12); 
    SolverCG<Vector<double>> cg(solver_control); 

    PreconditionSSOR<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.2); 

    cg.solve(system_matrix, solution, system_rhs, preconditioner); 

    constraints.distribute(solution); 
  } 
// @sect4{ElasticProblem::refine_grid}  

// 对网格进行细化的函数与 step-6 的例子相同。正交公式再次适应了线性元素。请注意，误差估计器默认情况下是将从有限元解的所有分量中得到的估计值相加，也就是说，它使用所有方向的位移，权重相同。如果我们希望网格只适应x方向的位移，我们可以给函数传递一个额外的参数，告诉它这样做，而不考虑其他所有方向的位移作为误差指标。然而，对于目前的问题，似乎应该考虑所有的位移分量，而且权重相同。

  template <int dim> 
  void ElasticProblem<dim>::refine_grid() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    KellyErrorEstimator<dim>::estimate(dof_handler, 
                                       QGauss<dim - 1>(fe.degree + 1), 
                                       {}, 
                                       solution, 
                                       estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 

    triangulation.execute_coarsening_and_refinement(); 
  } 
// @sect4{ElasticProblem::output_results}  

// 输出的情况与之前的例子中已经显示过的差不多了。唯一的区别是，求解函数是矢量值的。DataOut类会自动处理这个问题，但我们必须给求解向量的每个分量一个不同的名字。

// 为了做到这一点， DataOut::add_vector() 函数想要一个字符串的向量。由于分量的数量与我们工作的维数相同，我们使用下面的 <code>switch</code> 语句。

// 我们注意到，一些图形程序对变量名称中允许的字符有限制。因此，deal.II只支持所有程序都支持的这些字符的最小子集。基本上，这些字符是字母、数字、下划线和其他一些字符，但特别是没有空格和减号/横线。否则该库将抛出一个异常，至少在调试模式下是这样。

// 在列出了1d、2d和3d的情况后，如果我们遇到一个我们没有考虑到的情况，让程序死亡是一种很好的风格。请记住，如果第一个参数中的条件没有得到满足，Assert宏会产生一个异常。当然，条件 <code>false</code> 永远不可能被满足，所以只要程序运行到默认语句，就会中止。

  template <int dim> 
  void ElasticProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    DataOut<dim> data_out; 
    data_out.attach_dof_handler(dof_handler); 

    std::vector<std::string> solution_names; 
    switch (dim) 
      { 
        case 1: 
          solution_names.emplace_back("displacement"); 
          break; 
        case 2: 
          solution_names.emplace_back("x_displacement"); 
          solution_names.emplace_back("y_displacement"); 
          break; 
        case 3: 
          solution_names.emplace_back("x_displacement"); 
          solution_names.emplace_back("y_displacement"); 
          solution_names.emplace_back("z_displacement"); 
          break; 
        default: 
          Assert(false, ExcNotImplemented()); 
      } 

// 在为解向量的不同组成部分设置了名称之后，我们可以将解向量添加到计划输出的数据向量列表中。请注意，下面的函数需要一个字符串向量作为第二个参数，而我们在以前所有例子中使用的函数在那里接受一个字符串。(事实上，我们之前使用的函数会将单个字符串转换成只有一个元素的向量，并将其转发给另一个函数)。

    data_out.add_data_vector(solution, solution_names); 
    data_out.build_patches(); 

    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk"); 
    data_out.write_vtk(output); 
  } 

//  @sect4{ElasticProblem::run}  

//  <code>run</code> 函数所做的事情与 step-6 中的相同，比如说。这一次，我们使用平方[-1,1]^d作为域，在开始第一次迭代之前，我们在全局上对其进行了四次细化。

// 细化的原因有点意外：我们使用QGauss正交公式，在每个方向上有两个点用于整合右手边；这意味着每个单元上有四个正交点（在二维）。如果我们只对初始网格进行一次全局细化，那么在域上每个方向上就只有四个正交点。然而，右侧函数被选择为相当局部的，在这种情况下，纯属偶然，恰好所有的正交点都位于右侧函数为零的点上（用数学术语来说，正交点恰好在右侧函数的<i>support</i>之外的点上）。这样一来，用正交计算的右手向量将只包含零（尽管如果我们完全用积分计算右手向量的话，它当然会是非零的），方程组的解就是零向量，也就是一个处处为零的有限元函数。从某种意义上说，我们不应该对这种情况的发生感到惊讶，因为我们选择了一个完全不适合手头问题的初始网格。

// 不幸的是，如果离散解是常数，那么KellyErrorEstimator类计算的误差指标对每个单元来说也是零，对 Triangulation::refine_and_coarsen_fixed_number() 的调用将不会标记任何单元进行细化（如果每个单元的指示误差是零，为什么要这样做？因此，下一次迭代中的网格也将只由四个单元组成，同样的问题再次发生。

// 结论是：虽然我们当然不会把初始网格选择得非常适合问题的精确解决，但我们至少必须选择它，使它有机会捕捉到解决方案的重要特征。在这种情况下，它需要能够看到右手边的情况。因此，我们进行了四次全局细化。(任何更大的全局细化步骤当然也可以。)

  template <int dim> 
  void ElasticProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 8; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation, -1, 1); 
            triangulation.refine_global(4); 
          } 
        else 
          refine_grid(); 

        std::cout << "   Number of active cells:       " 
                  << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs() 
                  << std::endl; 

        assemble_system(); 
        solve(); 
        output_results(cycle); 
      } 
  } 
} // namespace Step8 
// @sect3{The <code>main</code> function}  

// 在上面最后一行关闭了 <code>Step8</code> 命名空间后，下面是程序的主要功能，又和 step-6 中一模一样（当然，除了改变了类名）。

int main() 
{ 
  try 
    { 
      Step8::ElasticProblem<2> elastic_problem_2d; 
      elastic_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 

      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

CCTest_file/step-9.cc


/* --------------------------------------------------------------------- 
 * 
 * Copyright (C) 2000 - 2021 by the deal.II authors 
 * 
 * This file is part of the deal.II library. 
 * 
 * The deal.II library is free software; you can use it, redistribute 
 * it, and/or modify it under the terms of the GNU Lesser General 
 * Public License as published by the Free Software Foundation; either 
 * version 2.1 of the License, or (at your option) any later version. 
 * The full text of the license can be found in the file LICENSE.md at 
 * the top level directory of deal.II. 
 * 
 * --------------------------------------------------------------------- 
 * 
 * Author: Wolfgang Bangerth, University of Heidelberg, 2000 
 */ 



// 就像以前的例子一样，我们必须包括几个文件，其中的含义已经讨论过了。

#include <deal.II/base/quadrature_lib.h> 
#include <deal.II/base/function.h> 
#include <deal.II/base/logstream.h> 
#include <deal.II/lac/vector.h> 
#include <deal.II/lac/full_matrix.h> 
#include <deal.II/lac/sparse_matrix.h> 
#include <deal.II/lac/dynamic_sparsity_pattern.h> 
#include <deal.II/lac/solver_gmres.h> 
#include <deal.II/lac/precondition.h> 
#include <deal.II/lac/affine_constraints.h> 
#include <deal.II/grid/tria.h> 
#include <deal.II/grid/grid_generator.h> 
#include <deal.II/grid/grid_refinement.h> 
#include <deal.II/dofs/dof_handler.h> 
#include <deal.II/dofs/dof_tools.h> 
#include <deal.II/fe/fe_values.h> 
#include <deal.II/numerics/vector_tools.h> 
#include <deal.II/numerics/matrix_tools.h> 
#include <deal.II/numerics/data_out.h> 
#include <deal.II/fe/fe_q.h> 
#include <deal.II/grid/grid_out.h> 

// 下面两个文件提供了多线程程序的类和信息。在第一个文件中，声明了我们需要做并行装配的类和函数（即 <code>WorkStream</code> 命名空间）。第二个文件有一个类MultithreadInfo，可以用来查询系统中的处理器数量，这在决定启动多少个并行线程时通常很有用。

#include <deal.II/base/work_stream.h> 
#include <deal.II/base/multithread_info.h> 

// 下一个新的include文件声明了一个基类 <code>TensorFunction</code> ，与 <code>Function</code> 类不一样，但不同的是 TensorFunction::value 返回一个张量而不是一个标量。

#include <deal.II/base/tensor_function.h> 

#include <deal.II/numerics/error_estimator.h> 

// 这是C++，因为我们想把一些输出写入磁盘。

#include <fstream> 
#include <iostream> 

// 最后一步和以前的程序一样。

namespace Step9 
{ 
  using namespace dealii; 
// @sect3{Equation data declaration}  

// 接下来我们声明一个描述平流场的类。当然，这是一个矢量场，有多少分量就有多少空间维度。现在我们可以使用一个从 <code>Function</code> 基类派生出来的类，就像我们在前面的例子中对边界值和系数所做的那样，但是在库中还有另一种可能性，即一个描述张量值函数的基类。这比重写 Function::value() 知道多个函数成分的方法更方便：最后我们需要一个张量，所以我们不妨直接使用一个返回张量的类。

  template <int dim> 
  class AdvectionField : public TensorFunction<1, dim> 
  { 
  public: 
    virtual Tensor<1, dim> value(const Point<dim> &p) const override; 

// 在前面的例子中，我们已经在多个地方使用了抛出异常的断言。但是，我们还没有看到如何声明这种异常。这可以这样做。

    DeclException2(ExcDimensionMismatch, 
                   unsigned int, 
                   unsigned int, 
                   << "The vector has size " << arg1 << " but should have " 
                   << arg2 << " elements."); 

// 语法可能看起来有点奇怪，但很合理。其格式基本如下：使用其中一个宏的名称  <code>DeclExceptionN</code>, where <code>N</code>  表示异常对象应采取的附加参数的数量。在本例中，由于我们想在两个向量的大小不同时抛出异常，我们需要两个参数，所以我们使用  <code>DeclException2</code>  。第一个参数描述了异常的名称，而下面的参数则声明了参数的数据类型。最后一个参数是一连串的输出指令，这些指令将被输送到  <code>std::cerr</code>  对象中，因此出现了奇怪的格式，前面是  <code>@<@<</code>  操作符之类的。注意，我们可以通过使用名称  <code>arg1</code> through <code>argN</code>  来访问在构造时（即在  <code>Assert</code>  调用中）传递给异常的参数，其中  <code>N</code>  是通过使用各自的宏  <code>DeclExceptionN</code>  来定义的参数数。

// 要了解预处理器如何将这个宏扩展为实际代码，请参考异常类的文档。简而言之，这个宏调用声明并定义了一个继承自 ExceptionBase 的类  <code>ExcDimensionMismatch</code>  ，它实现了所有必要的错误输出功能。

  }; 

// 下面的两个函数实现了上述的接口。第一个简单地实现了介绍中所描述的函数，而第二个使用了同样的技巧来避免调用虚拟函数，在前面的例子程序中已经介绍过了。注意第二个函数中对参数的正确大小的检查，这种检查应该始终存在于这类函数中；根据我们的经验，许多甚至大多数编程错误都是由不正确的初始化数组、不兼容的函数参数等造成的；像本例中那样使用断言可以消除许多这样的问题。

  template <int dim> 
  Tensor<1, dim> AdvectionField<dim>::value(const Point<dim> &p) const 
  { 
    Tensor<1, dim> value; 
    value[0] = 2; 
    for (unsigned int i = 1; i < dim; ++i) 
      value[i] = 1 + 0.8 * std::sin(8. * numbers::PI * p[0]); 

    return value; 
  } 

// 除了平流场，我们还需要两个描述源项（  <code>right hand side</code>  ）和边界值的函数。如介绍中所述，源是一个源点附近的常数函数，我们用常数静态变量  <code>center_point</code>  表示。我们使用与我们在 step-7 示例程序中所示相同的模板技巧来设置这个中心的值。剩下的就很简单了，之前已经展示过了。

  template <int dim> 
  class RightHandSide : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 

  private: 
    static const Point<dim> center_point; 
  }; 

  template <> 
  const Point<1> RightHandSide<1>::center_point = Point<1>(-0.75); 

  template <> 
  const Point<2> RightHandSide<2>::center_point = Point<2>(-0.75, -0.75); 

  template <> 
  const Point<3> RightHandSide<3>::center_point = Point<3>(-0.75, -0.75, -0.75); 

// 这里唯一的新东西是我们检查 <code>component</code> 参数的值。由于这是一个标量函数，很明显，只有当所需分量的索引为0时才有意义，所以我们断言这确实是这样的。  <code>ExcIndexRange</code> 是一个全局预定义的异常（可能是最经常使用的异常，因此我们让它成为全局的，而不是某个类的局部），它需要三个参数：超出允许范围的索引，有效范围的第一个元素和超过最后一个的元素（即又是C++标准库中经常使用的半开放区间）。

  template <int dim> 
  double RightHandSide<dim>::value(const Point<dim> & p, 
                                   const unsigned int component) const 
  { 
    (void)component; 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 
    const double diameter = 0.1; 
    return ((p - center_point).norm_square() < diameter * diameter ? 
              0.1 / std::pow(diameter, dim) : 
              0.0); 
  } 

// 最后是边界值，这只是从 <code>Function</code> 基类派生的另一个类。

  template <int dim> 
  class BoundaryValues : public Function<dim> 
  { 
  public: 
    virtual double value(const Point<dim> & p, 
                         const unsigned int component = 0) const override; 
  }; 

  template <int dim> 
  double BoundaryValues<dim>::value(const Point<dim> & p, 
                                    const unsigned int component) const 
  { 
    (void)component; 
    Assert(component == 0, ExcIndexRange(component, 0, 1)); 

    const double sine_term = std::sin(16. * numbers::PI * p.norm_square()); 
    const double weight    = std::exp(5. * (1. - p.norm_square())); 
    return weight * sine_term; 
  } 
// @sect3{AdvectionProblem class declaration}  

// 这里是这个程序的主类。它和前面的例子中的主类非常相似，所以我们再次只对其不同之处进行评论。

  template <int dim> 
  class AdvectionProblem 
  { 
  public: 
    AdvectionProblem(); 
    void run(); 

  private: 
    void setup_system(); 

// 下一组函数将被用来组装矩阵。然而，与前面的例子不同， <code>assemble_system()</code> 函数不会自己做这些工作，而是将实际的装配工作委托给辅助函数  <code>assemble_local_system()</code>  和  <code>copy_local_to_global()</code>  。其原理是，矩阵组装可以很好地并行化，因为每个单元的局部贡献的计算完全独立于其他单元，我们只需要在将一个单元的贡献添加到全局矩阵中时进行同步。

// 我们在这里选择的并行化策略是文档中 @ref threads 模块中详细提及的可能性之一。具体来说，我们将使用那里讨论的WorkStream方法。由于这个模块有很多文档，我们不会在这里重复设计选择的理由（例如，如果你读完上面提到的模块，你会明白 <code>AssemblyScratchData</code> 和 <code>AssemblyCopyData</code> 结构的目的是什么）。相反，我们将只讨论具体的实现。

// 如果你阅读了上面提到的页面，你会发现为了使汇编并行化，我们需要两个数据结构--一个对应于我们在局部集成过程中需要的数据（"scratch data"，即我们只需要作为临时存储的东西），另一个是将信息从局部集成携带到函数中，然后将局部贡献添加到全局矩阵的相应元素中。其中前者通常包含FEValues和FEFaceValues对象，而后者则有局部矩阵、局部右手边，以及关于哪些自由度生活在我们正在组装局部贡献的单元上的信息。有了这些信息，下面的内容应该是相对不言自明的。

    struct AssemblyScratchData 
    { 
      AssemblyScratchData(const FiniteElement<dim> &fe); 
      AssemblyScratchData(const AssemblyScratchData &scratch_data); 

// FEValues和FEFaceValues是很昂贵的设置对象，所以我们把它们包含在scratch对象中，以便尽可能多的数据在单元格之间被重复使用。

      FEValues<dim>     fe_values; 
      FEFaceValues<dim> fe_face_values; 

// 我们还存储了一些向量，我们将在每个单元格上填充数值。在通常情况下，设置这些对象是很便宜的；但是，它们需要内存分配，这在多线程应用程序中可能很昂贵。因此，我们把它们保存在这里，这样在一个单元格上的计算就不需要新的分配。

      std::vector<double>         rhs_values; 
      std::vector<Tensor<1, dim>> advection_directions; 
      std::vector<double>         face_boundary_values; 
      std::vector<Tensor<1, dim>> face_advection_directions; 

// 最后，我们需要描述该问题数据的对象。

      AdvectionField<dim> advection_field; 
      RightHandSide<dim>  right_hand_side; 
      BoundaryValues<dim> boundary_values; 
    }; 

    struct AssemblyCopyData 
    { 
      FullMatrix<double>                   cell_matrix; 
      Vector<double>                       cell_rhs; 
      std::vector<types::global_dof_index> local_dof_indices; 
    }; 

    void assemble_system(); 
    void local_assemble_system( 
      const typename DoFHandler<dim>::active_cell_iterator &cell, 
      AssemblyScratchData &                                 scratch, 
      AssemblyCopyData &                                    copy_data); 
    void copy_local_to_global(const AssemblyCopyData &copy_data); 

// 下面的函数又和前面的例子一样，后面的变量也是一样的。

    void solve(); 
    void refine_grid(); 
    void output_results(const unsigned int cycle) const; 

    Triangulation<dim> triangulation; 
    DoFHandler<dim>    dof_handler; 

    FE_Q<dim> fe; 

    AffineConstraints<double> hanging_node_constraints; 

    SparsityPattern      sparsity_pattern; 
    SparseMatrix<double> system_matrix; 

    Vector<double> solution; 
    Vector<double> system_rhs; 
  }; 

//  @sect3{GradientEstimation class declaration}  

// 现在，最后，这里有一个类，它将计算每个单元上梯度的差分近似值，并以网格大小的幂数进行权衡，如介绍中所述。这个类是库中 <code>DerivativeApproximation</code> 类的一个简单版本，它使用类似的技术来获得有限元场的梯度的有限差分近似值，或者更高导数。

// 该类有一个公共静态函数 <code>estimate</code> ，被调用来计算误差指标的向量，还有一些私有函数，在所有活动单元上做实际工作。在库的其他部分，我们遵循一个非正式的惯例，使用浮点数向量作为误差指标，而不是常见的双数向量，因为对于估计值来说，额外的精度是没有必要的。

// 除了这两个函数，该类还声明了两个异常，当一个单元在每个空间方向上都没有邻居时（在这种情况下，介绍中描述的矩阵将是奇异的，不能被倒置），而另一个异常用于更常见的函数参数无效的情况，即一个大小错误的向量。

// 还有两点意见：首先，这个类没有非静态成员函数或变量，所以这不是一个真正的类，而是起到了C++中 <code>namespace</code> 的作用。我们选择类而不是命名空间的原因是，这种方式我们可以声明私有的函数。如果在命名空间的头文件中声明一些函数，并在实现文件中实现这些函数和其他函数，这也可以用命名空间来实现。没有在头文件中声明的函数仍然在名字空间中，但不能从外部调用。然而，由于我们这里只有一个文件，在目前的情况下不可能隐藏函数。

// 第二个意见是，维度模板参数被附在函数上，而不是附在类本身。这样，你就不必像其他大多数情况下那样自己指定模板参数，而是编译器可以从作为第一个参数传递的DoFHandler对象的尺寸中自行计算出其值。

// 在开始实施之前，让我们也来评论一下并行化策略。我们已经在上面这个程序的主类的声明中介绍了使用WorkStream概念的必要框架。我们将在这里再次使用它。在目前的情况下，这意味着我们必须定义 <ol>  。
// <li> 类，用于抓取和复制对象， </li>  。
// <li>  一个在一个单元上进行局部计算的函数，以及 </li>  
// <li>  一个将本地结果复制到全局对象的函数。 </li>  
// </ol>  鉴于这个总体框架，我们将稍微偏离它。特别是，WorkStream一般是为这样的情况而发明的，即每个单元上的局部计算<i>adds</i>到一个全局对象--例如，在组装线性系统时，我们将局部贡献添加到全局矩阵和右手边中。WorkStream的设计是为了处理多个线程试图同时进行这种添加的潜在冲突，因此必须提供一些方法来确保每次只有一个线程可以做这个。然而，这里的情况略有不同：我们单独计算每个单元的贡献，但随后我们需要做的是将它们放入每个单元独有的输出向量中的一个元素。因此，不存在来自两个单元的写操作可能发生冲突的风险，也没有必要使用WorkStream的复杂机制来避免冲突的写操作。因此，我们要做的就是这样。我们仍然需要一个持有例如 FEValues 对象的 scratch 对象。但是，我们只创建一个假的、空的拷贝数据结构。同样，我们确实需要计算本地贡献的函数，但由于它已经可以把结果放到最终位置，我们不需要一个从本地到全球的拷贝函数，而是给 WorkStream::run() 函数一个空函数对象--相当于一个NULL函数指针。

  class GradientEstimation 
  { 
  public: 
    template <int dim> 
    static void estimate(const DoFHandler<dim> &dof, 
                         const Vector<double> & solution, 
                         Vector<float> &        error_per_cell); 

    DeclException2(ExcInvalidVectorLength, 
                   int, 
                   int, 
                   << "Vector has length " << arg1 << ", but should have " 
                   << arg2); 
    DeclException0(ExcInsufficientDirections); 

  private: 
    template <int dim> 
    struct EstimateScratchData 
    { 
      EstimateScratchData(const FiniteElement<dim> &fe, 
                          const Vector<double> &    solution, 
                          Vector<float> &           error_per_cell); 
      EstimateScratchData(const EstimateScratchData &data); 

      FEValues<dim> fe_midpoint_value; 
      std::vector<typename DoFHandler<dim>::active_cell_iterator> 
        active_neighbors; 

      const Vector<double> &solution; 
      Vector<float> &       error_per_cell; 

      std::vector<double> cell_midpoint_value; 
      std::vector<double> neighbor_midpoint_value; 
    }; 

    struct EstimateCopyData 
    {}; 

    template <int dim> 
    static void 
    estimate_cell(const typename DoFHandler<dim>::active_cell_iterator &cell, 
                  EstimateScratchData<dim> &scratch_data, 
                  const EstimateCopyData &  copy_data); 
  }; 

//  @sect3{AdvectionProblem class implementation}  

// 现在是主类的实现。构造器、析构器和函数 <code>setup_system</code> 遵循之前使用的模式，所以我们不需要对这三个函数进行评论。

  template <int dim> 
  AdvectionProblem<dim>::AdvectionProblem() 
    : dof_handler(triangulation) 
    , fe(5) 
  {} 

  template <int dim> 
  void AdvectionProblem<dim>::setup_system() 
  { 
    dof_handler.distribute_dofs(fe); 
    hanging_node_constraints.clear(); 
    DoFTools::make_hanging_node_constraints(dof_handler, 
                                            hanging_node_constraints); 
    hanging_node_constraints.close(); 

    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); 
    DoFTools::make_sparsity_pattern(dof_handler, 
                                    dsp, 
                                    hanging_node_constraints, 
                                    /*keep_constrained_dofs =  */ false);

    sparsity_pattern.copy_from(dsp); 

    system_matrix.reinit(sparsity_pattern); 

    solution.reinit(dof_handler.n_dofs()); 
    system_rhs.reinit(dof_handler.n_dofs()); 
  } 

// 在下面的函数中，矩阵和右手被组装起来。正如上面main类的文档所述，它本身并不做这个，而是委托给接下来的函数，利用 @ref threads 中讨论的WorkStream概念。

// 如果你看了 @ref threads 模块，你会发现并行装配并不需要大量的额外代码，只要你认真地描述什么是从头开始和复制数据对象，如果你为本地装配和从本地贡献到全局对象的复制操作定义了合适的函数。完成这些工作后，下面将完成所有繁重的工作，使这些操作在多个线程上完成，只要你的系统有多少个内核。

  template <int dim> 
  void AdvectionProblem<dim>::assemble_system() 
  { 
    WorkStream::run(dof_handler.begin_active(), 
                    dof_handler.end(), 
                    *this, 
                    &AdvectionProblem::local_assemble_system, 
                    &AdvectionProblem::copy_local_to_global, 
                    AssemblyScratchData(fe), 
                    AssemblyCopyData()); 
  } 

// 正如上面已经提到的，我们需要有抓取对象来进行局部贡献的并行计算。这些对象包含FEValues和FEFaceValues对象（以及一些数组），因此我们需要有构造函数和复制构造函数，以便我们能够创建它们。对于单元项，我们需要形状函数的值和梯度、正交点以确定给定点的源密度和平流场，以及正交点的权重乘以这些点的雅各布系数的行列式。相反，对于边界积分，我们不需要梯度，而是需要单元的法向量。这决定了我们必须将哪些更新标志传递给类的成员的构造函数。

  template <int dim> 
  AdvectionProblem<dim>::AssemblyScratchData::AssemblyScratchData( 
    const FiniteElement<dim> &fe) 
    : fe_values(fe, 
                QGauss<dim>(fe.degree + 1), 
                update_values | update_gradients | update_quadrature_points | 
                  update_JxW_values) 
    , fe_face_values(fe, 
                     QGauss<dim - 1>(fe.degree + 1), 
                     update_values | update_quadrature_points | 
                       update_JxW_values | update_normal_vectors) 
    , rhs_values(fe_values.get_quadrature().size()) 
    , advection_directions(fe_values.get_quadrature().size()) 
    , face_boundary_values(fe_face_values.get_quadrature().size()) 
    , face_advection_directions(fe_face_values.get_quadrature().size()) 
  {} 

  template <int dim> 
  AdvectionProblem<dim>::AssemblyScratchData::AssemblyScratchData( 
    const AssemblyScratchData &scratch_data) 
    : fe_values(scratch_data.fe_values.get_fe(), 
                scratch_data.fe_values.get_quadrature(), 
                update_values | update_gradients | update_quadrature_points | 
                  update_JxW_values) 
    , fe_face_values(scratch_data.fe_face_values.get_fe(), 
                     scratch_data.fe_face_values.get_quadrature(), 
                     update_values | update_quadrature_points | 
                       update_JxW_values | update_normal_vectors) 
    , rhs_values(scratch_data.rhs_values.size()) 
    , advection_directions(scratch_data.advection_directions.size()) 
    , face_boundary_values(scratch_data.face_boundary_values.size()) 
    , face_advection_directions(scratch_data.face_advection_directions.size()) 
  {} 

// 现在，这就是做实际工作的函数。它与前面例子程序中的 <code>assemble_system</code> 函数没有什么不同，所以我们将再次只对其不同之处进行评论。数学上的东西紧跟我们在介绍中所说的。

// 不过，这里有一些值得一提的地方。首先，我们把FEValues和FEFaceValues对象移到了ScratchData对象中。我们这样做是因为我们每次进入这个函数时都要简单地创建一个，也就是在每个单元格上。现在发现，FEValues类的编写目标很明确，就是将所有从单元格到单元格保持不变的东西都移到对象的构造中，每当我们移到一个新单元格时，只在 FEValues::reinit() 做尽可能少的工作。这意味着在这个函数中创建一个这样的新对象是非常昂贵的，因为我们必须为每一个单元格都这样做--这正是我们想通过FEValues类来避免的事情。相反，我们所做的是在抓取对象中只创建一次（或少数几次），然后尽可能多地重复使用它。

// 这就引出了一个问题：我们在这个函数中创建的其他对象，与它的使用相比，其创建成本很高。事实上，在函数的顶部，我们声明了各种各样的对象。 <code>AdvectionField</code>  ,  <code>RightHandSide</code> and <code>BoundaryValues</code> 的创建成本并不高，所以这里没有什么危害。然而，在创建 <code>rhs_values</code> 和下面类似的变量时，分配内存通常要花费大量的时间，而只是访问我们存储在其中的（临时）值。因此，这些将是移入 <code>AssemblyScratchData</code> 类的候选者。我们将把这作为一个练习。

  template <int dim> 
  void AdvectionProblem<dim>::local_assemble_system( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    AssemblyScratchData &                                 scratch_data, 
    AssemblyCopyData &                                    copy_data) 
  { 

// 我们定义一些缩写，以避免不必要的长行。

    const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); 
    const unsigned int n_q_points = 
      scratch_data.fe_values.get_quadrature().size(); 
    const unsigned int n_face_q_points = 
      scratch_data.fe_face_values.get_quadrature().size(); 

// 我们声明单元格矩阵和单元格右侧...

    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell); 
    copy_data.cell_rhs.reinit(dofs_per_cell); 

// ...一个数组，用于保存我们目前正在处理的单元格的自由度的全局索引...

    copy_data.local_dof_indices.resize(dofs_per_cell); 

// ...然后初始化 <code>FEValues</code> 对象...

    scratch_data.fe_values.reinit(cell); 

// ... 获得正交点的右手边和平流方向的数值...

    scratch_data.advection_field.value_list( 
      scratch_data.fe_values.get_quadrature_points(), 
      scratch_data.advection_directions); 
    scratch_data.right_hand_side.value_list( 
      scratch_data.fe_values.get_quadrature_points(), scratch_data.rhs_values); 

// ... 设置流线扩散参数的值，如介绍中所述...

    const double delta = 0.1 * cell->diameter(); 

// ...... 并按照上面的讨论，集合对系统矩阵和右手边的局部贡献。

    for (unsigned int q_point = 0; q_point < n_q_points; ++q_point) 
      for (unsigned int i = 0; i < dofs_per_cell; ++i) 
        { 

// 别名AssemblyScratchData对象，以防止行数过长。

          const auto &sd = scratch_data; 
          for (unsigned int j = 0; j < dofs_per_cell; ++j) 
            copy_data.cell_matrix(i, j) += 
              ((sd.fe_values.shape_value(i, q_point) +           // (phi_i + 
                delta * (sd.advection_directions[q_point] *      // delta beta 
                         sd.fe_values.shape_grad(i, q_point))) * // grad phi_i) 
               sd.advection_directions[q_point] *                // beta 
               sd.fe_values.shape_grad(j, q_point)) *            // grad phi_j 
              sd.fe_values.JxW(q_point);                         // dx 

          copy_data.cell_rhs(i) += 
            (sd.fe_values.shape_value(i, q_point) +           // (phi_i + 
             delta * (sd.advection_directions[q_point] *      // delta beta 
                      sd.fe_values.shape_grad(i, q_point))) * // grad phi_i) 
            sd.rhs_values[q_point] *                          // f 
            sd.fe_values.JxW(q_point);                        // dx 
        } 

// 除了我们现在建立的单元项，本问题的双线性形式还包含域的边界上的项。因此，我们必须检查这个单元的任何一个面是否在域的边界上，如果是的话，也要把这个面的贡献集合起来。当然，双线性形式只包含来自边界 <code>inflow</code> 部分的贡献，但要找出本单元的某个面是否属于流入边界的一部分，我们必须有关于正交点的确切位置和该点的流动方向的信息；我们使用FEFaceValues对象获得这些信息，并只在主循环中决定某个正交点是否在流入边界上。

    for (const auto &face : cell->face_iterators()) 
      if (face->at_boundary()) 
        { 

// 好的，当前单元格的这个面是在域的边界上。就像我们在前面的例子和上面的例子中使用的通常的FEValues对象一样，我们必须重新初始化当前面的FEFaceValues对象。

          scratch_data.fe_face_values.reinit(cell, face); 

// 对于手头的正交点，我们要求提供流入函数的值和流动方向。

          scratch_data.boundary_values.value_list( 
            scratch_data.fe_face_values.get_quadrature_points(), 
            scratch_data.face_boundary_values); 
          scratch_data.advection_field.value_list( 
            scratch_data.fe_face_values.get_quadrature_points(), 
            scratch_data.face_advection_directions); 

// 现在循环所有正交点，看看这个面是在边界的流入还是流出部分。法向量指向单元外：由于该面处于边界，法向量指向域外，所以如果平流方向指向域内，其与法向量的标量乘积一定是负的（要知道为什么会这样，请考虑使用余弦的标量乘积定义）。

          for (unsigned int q_point = 0; q_point < n_face_q_points; ++q_point) 
            if (scratch_data.fe_face_values.normal_vector(q_point) * 
                  scratch_data.face_advection_directions[q_point] < 
                0.) 

// 如果该面是流入边界的一部分，则使用从FEFaceValues对象中获得的值和介绍中讨论的公式，计算该面对全局矩阵和右侧的贡献。

              for (unsigned int i = 0; i < dofs_per_cell; ++i) 
                { 
                  for (unsigned int j = 0; j < dofs_per_cell; ++j) 
                    copy_data.cell_matrix(i, j) -= 
                      (scratch_data.face_advection_directions[q_point] * 
                       scratch_data.fe_face_values.normal_vector(q_point) * 
                       scratch_data.fe_face_values.shape_value(i, q_point) * 
                       scratch_data.fe_face_values.shape_value(j, q_point) * 
                       scratch_data.fe_face_values.JxW(q_point)); 

                  copy_data.cell_rhs(i) -= 
                    (scratch_data.face_advection_directions[q_point] * 
                     scratch_data.fe_face_values.normal_vector(q_point) * 
                     scratch_data.face_boundary_values[q_point] * 
                     scratch_data.fe_face_values.shape_value(i, q_point) * 
                     scratch_data.fe_face_values.JxW(q_point)); 
                } 
        } 

// 复制程序需要的最后一条信息是这个单元上自由度的全局索引，所以我们最后把它们写到本地数组中。

    cell->get_dof_indices(copy_data.local_dof_indices); 
  } 

// 我们需要写的第二个函数是将前一个函数计算出的本地贡献（并放入AssemblyCopyData对象）复制到全局矩阵和右侧向量对象。这基本上就是我们在每个单元上装配东西时，一直作为最后一块代码的内容。因此，下面的内容应该是很明显的。

  template <int dim> 
  void 
  AdvectionProblem<dim>::copy_local_to_global(const AssemblyCopyData &copy_data) 
  { 
    hanging_node_constraints.distribute_local_to_global( 
      copy_data.cell_matrix, 
      copy_data.cell_rhs, 
      copy_data.local_dof_indices, 
      system_matrix, 
      system_rhs); 
  } 

// 这里是线性求解程序。由于系统不再像以前的例子那样是对称正定的，我们不能再使用共轭梯度法。相反，我们使用一个更通用的，不依赖矩阵的任何特殊属性的求解器：GMRES方法。GMRES和共轭梯度法一样，需要一个合适的预处理程序：我们在这里使用一个雅可比预处理程序，它对这个问题来说足够好。

  template <int dim> 
  void AdvectionProblem<dim>::solve() 
  { 
    SolverControl               solver_control(std::max<std::size_t>(1000, 
                                                       system_rhs.size() / 10), 
                                 1e-10 * system_rhs.l2_norm()); 
    SolverGMRES<Vector<double>> solver(solver_control); 
    PreconditionJacobi<SparseMatrix<double>> preconditioner; 
    preconditioner.initialize(system_matrix, 1.0); 
    solver.solve(system_matrix, solution, system_rhs, preconditioner); 

    Vector<double> residual(dof_handler.n_dofs()); 

    system_matrix.vmult(residual, solution); 
    residual -= system_rhs; 
    std::cout << "   Iterations required for convergence: " 
              << solver_control.last_step() << '\n' 
              << "   Max norm of residual:                " 
              << residual.linfty_norm() << '\n'; 

    hanging_node_constraints.distribute(solution); 
  } 

// 下面的函数根据介绍中描述的数量来细化网格。各自的计算是在类  <code>GradientEstimation</code>  中进行的。

  template <int dim> 
  void AdvectionProblem<dim>::refine_grid() 
  { 
    Vector<float> estimated_error_per_cell(triangulation.n_active_cells()); 

    GradientEstimation::estimate(dof_handler, 
                                 solution, 
                                 estimated_error_per_cell); 

    GridRefinement::refine_and_coarsen_fixed_number(triangulation, 
                                                    estimated_error_per_cell, 
                                                    0.3, 
                                                    0.03); 

    triangulation.execute_coarsening_and_refinement(); 
  } 

// 这个函数与第6步中的函数类似，但由于我们使用的是高阶有限元，所以我们以不同的方式保存解决方案。像VisIt和Paraview这样的可视化程序通常只能理解与节点相关的数据：它们不能绘制五度基函数，这导致我们计算的解的图片非常不准确。为了解决这个问题，我们为每个单元保存了多个 <em> 补丁 </em> ：在二维中，我们为每个单元在VTU文件中保存64个双线性 "单元"，在三维中，我们保存512个。最终的结果是，可视化程序将使用立方体基础函数的片状线性插值：这捕捉到了解决方案的细节，并且在大多数屏幕分辨率下，看起来很平滑。我们在一个单独的步骤中保存网格，没有额外的补丁，这样我们就有了细胞面的视觉表现。

//9.1版本的deal.II获得了编写更高程度多项式（即为我们的片状二项式解决方案编写片状二项式可视化数据）VTK和VTU输出的能力：然而，并非所有最新版本的ParaView和Viscit（截至2018年）都能读取这种格式，所以我们在这里使用更古老、更通用（但效率较低）的方法。

  template <int dim> 
  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const 
  { 
    { 
      GridOut       grid_out; 
      std::ofstream output("grid-" + std::to_string(cycle) + ".vtu"); 
      grid_out.write_vtu(triangulation, output); 
    } 

    { 
      DataOut<dim> data_out; 
      data_out.attach_dof_handler(dof_handler); 
      data_out.add_data_vector(solution, "solution"); 
      data_out.build_patches(8); 

// VTU输出可能很昂贵，无论是计算还是写入磁盘。这里我们要求ZLib，一个压缩库，以最大限度地提高吞吐量的方式来压缩数据。

      DataOutBase::VtkFlags vtk_flags; 
      vtk_flags.compression_level = 
        DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed; 
      data_out.set_flags(vtk_flags); 

      std::ofstream output("solution-" + std::to_string(cycle) + ".vtu"); 
      data_out.write_vtu(output); 
    } 
  } 

// ... 如同主循环（设置-求解-细化）一样，除了循环次数和初始网格之外。

  template <int dim> 
  void AdvectionProblem<dim>::run() 
  { 
    for (unsigned int cycle = 0; cycle < 10; ++cycle) 
      { 
        std::cout << "Cycle " << cycle << ':' << std::endl; 

        if (cycle == 0) 
          { 
            GridGenerator::hyper_cube(triangulation, -1, 1); 
            triangulation.refine_global(3); 
          } 
        else 
          { 
            refine_grid(); 
          } 

        std::cout << "   Number of active cells:              " 
                  << triangulation.n_active_cells() << std::endl; 

        setup_system(); 

        std::cout << "   Number of degrees of freedom:        " 
                  << dof_handler.n_dofs() << std::endl; 

        assemble_system(); 
        solve(); 
        output_results(cycle); 
      } 
  } 

//  @sect3{GradientEstimation class implementation}  

// 现在是 <code>GradientEstimation</code> 类的实现。让我们先为 <code>estimate_cell()</code> 函数所使用的 <code>EstimateScratchData</code> 类定义构造函数。

  template <int dim> 
  GradientEstimation::EstimateScratchData<dim>::EstimateScratchData( 
    const FiniteElement<dim> &fe, 
    const Vector<double> &    solution, 
    Vector<float> &           error_per_cell) 
    : fe_midpoint_value(fe, 
                        QMidpoint<dim>(), 
                        update_values | update_quadrature_points) 
    , solution(solution) 
    , error_per_cell(error_per_cell) 
 
 
 

// 我们分配一个向量来保存一个单元的所有活动邻居的迭代器。我们保留活动邻居的最大数量，以避免以后的重新分配。注意这个最大的活动邻居数是如何计算出来的。

    active_neighbors.reserve(GeometryInfo<dim>::faces_per_cell * 
                             GeometryInfo<dim>::max_children_per_face); 
  } 

  template <int dim> 
  GradientEstimation::EstimateScratchData<dim>::EstimateScratchData( 
    const EstimateScratchData &scratch_data) 
    : fe_midpoint_value(scratch_data.fe_midpoint_value.get_fe(), 
                        scratch_data.fe_midpoint_value.get_quadrature(), 
                        update_values | update_quadrature_points) 
    , solution(scratch_data.solution) 
    , error_per_cell(scratch_data.error_per_cell) 
    , cell_midpoint_value(1) 
    , neighbor_midpoint_value(1) 
  {} 

// 接下来是对 <code>GradientEstimation</code> 类的实现。第一个函数除了将工作委托给另一个函数外，并没有做什么，但在顶部有一点设置。

// 在开始工作之前，我们要检查写入结果的向量是否有正确的大小。在编程中，忘记在调用处正确确定参数大小的错误是很常见的。因为没有发现这种错误所造成的损失往往是微妙的（例如，内存中某个地方的数据损坏，或者是无法重现的结果），所以非常值得努力去检查这些东西。

  template <int dim> 
  void GradientEstimation::estimate(const DoFHandler<dim> &dof_handler, 
                                    const Vector<double> & solution, 
                                    Vector<float> &        error_per_cell) 
  { 
    Assert( 
      error_per_cell.size() == dof_handler.get_triangulation().n_active_cells(), 
      ExcInvalidVectorLength(error_per_cell.size(), 
                             dof_handler.get_triangulation().n_active_cells())); 

    WorkStream::run(dof_handler.begin_active(), 
                    dof_handler.end(), 
                    &GradientEstimation::template estimate_cell<dim>, 
                    std::function<void(const EstimateCopyData &)>(), 
                    EstimateScratchData<dim>(dof_handler.get_fe(), 
                                             solution, 
                                             error_per_cell), 
                    EstimateCopyData()); 
  } 

// 这里是通过计算梯度的有限差分近似值来估计局部误差的函数。该函数首先计算当前单元的活动邻居列表，然后为每个邻居计算介绍中描述的数量。之所以有这样的顺序，是因为在局部细化网格的情况下，要找到一个给定的邻居并不是一蹴而就的事情。原则上，一个优化的实现可以在一个步骤中找到邻域和取决于它们的量，而不是先建立一个邻域列表，然后在第二步中找到它们的贡献，但是我们很乐意将此作为一个练习。正如之前所讨论的，传递给 WorkStream::run 的工作者函数是在保留所有临时对象的 "scratch "对象上工作。这样，我们就不需要在每次为给定单元调用工作的函数内创建和初始化那些昂贵的对象了。这样的参数被作为第二个参数传递。第三个参数是一个 "copy-data "对象（更多信息见 @ref threads ），但我们在这里实际上没有使用这些对象。由于 WorkStream::run() 坚持传递三个参数，我们声明这个函数有三个参数，但简单地忽略了最后一个参数。

// （从美学角度看，这是不令人满意的。它可以通过使用一个匿名（lambda）函数来避免。如果你允许的话，让我们在这里展示一下如何做。首先，假设我们已经声明这个函数只接受两个参数，省略了未使用的最后一个参数。现在， WorkStream::run 仍然想用三个参数来调用这个函数，所以我们需要找到一种方法来 "忘记 "调用中的第三个参数。简单地像上面那样把指针传给 WorkStream::run 这个函数是做不到的--编译器会抱怨一个声明为有两个参数的函数在调用时有三个参数。然而，我们可以通过将以下内容作为第三个参数传递给 WorkStream::run(): 来做到这一点 
// @code
//  [](const typename DoFHandler<dim>::active_cell_iterator &cell,
//     EstimateScratchData<dim> &                            scratch_data,
//     EstimateCopyData &)
//  {
//    GradientEstimation::estimate_cell<dim>(cell, scratch_data);
//  }
//  @endcode 
//  这并不比下面实现的解决方案好多少：要么例程本身必须带三个参数，要么它必须被带三个参数的东西包起来。我们不使用这种方法，因为在开始时添加未使用的参数更简单。

// 现在来看看细节。

  template <int dim> 
  void GradientEstimation::estimate_cell( 
    const typename DoFHandler<dim>::active_cell_iterator &cell, 
    EstimateScratchData<dim> &                            scratch_data, 
    const EstimateCopyData &) 
  { 

// 我们需要为张量 <code>Y</code> 提供空间，它是Y向量的外积之和。

    Tensor<2, dim> Y; 

// 首先初始化  <code>FEValues</code>  对象，以及  <code>Y</code>  张量。

    scratch_data.fe_midpoint_value.reinit(cell); 

// 现在，在我们继续之前，我们首先计算当前单元的所有活动邻居的列表。我们首先在所有面上进行循环，看那里的邻居是否处于活动状态，如果它与本单元在同一级别或更粗一级，就会出现这种情况（注意，一个邻居只能比本单元粗一次，因为我们在deal.II中只允许在一个面上有一个最大的细化差）。另外，邻居也可能在同一级别，并被进一步细化；那么我们必须找到它的哪些子单元与当前单元相邻，并选择这些子单元（注意，如果一个活动单元的邻居的一个子单元与这个活动单元相邻，那么它本身就必须是活动的，这是由于上面提到的一个细化规则）。

// 在一个空间维度上，情况略有不同，因为在那里不存在单一细化规则：相邻的活动单元可以在任意多的细化级别上有所不同。在这种情况下，计算变得有点困难，但我们将在下面解释。

// 在开始对当前单元的所有邻域进行循环之前，我们当然要清除存储活动邻域的迭代器的数组。

    scratch_data.active_neighbors.clear(); 
    for (const auto face_n : cell->face_indices()) 
      if (!cell->at_boundary(face_n)) 
        { 

// 首先定义面的迭代器和邻居的缩写

          const auto face     = cell->face(face_n); 
          const auto neighbor = cell->neighbor(face_n); 

// 然后检查邻居是否是活动的。如果是，那么它就在同一层或更粗的一层（如果我们不是在1D中），而且我们在任何情况下都会对它感兴趣。

          if (neighbor->is_active()) 
            scratch_data.active_neighbors.push_back(neighbor); 
          else 
            { 

// 如果邻居没有活动，则检查其子女。

              if (dim == 1) 
                { 

// 要找到与本单元相邻的子单元，如果我们在本单元的左边（n==0），则依次去找其右边的子单元，如果我们在右边（n==1），则依次去找左边的子单元，直到找到一个活动单元。

                  auto neighbor_child = neighbor; 
                  while (neighbor_child->has_children()) 
                    neighbor_child = neighbor_child->child(face_n == 0 ? 1 : 0); 

// 由于这使用了一些非微妙的几何直觉，我们可能想检查一下我们是否做对了，也就是说，检查我们找到的单元格的邻居是否确实是我们目前正在处理的单元。像这样的检查通常是有用的，并且经常发现像上面这一行的算法（不由自主地交换 <code>n==1</code> for <code>n==0</code> 或类似的算法是很简单的）和库中的错误（上面的算法所依据的假设可能是错误的，记录错误，或者由于库中的错误而被违反）。原则上，我们可以在程序运行一段时间后删除这样的检查，但是无论如何留下它来检查库中或上述算法中的变化可能是一件好事。                请注意，如果这个检查失败了，那么这肯定是一个无法恢复的错误，而且很可能被称为内部错误。因此我们在这里使用一个预定义的异常类来抛出。

                  Assert(neighbor_child->neighbor(face_n == 0 ? 1 : 0) == cell, 
                         ExcInternalError()); 

// 如果检查成功，我们就把刚刚发现的活动邻居推到我们保留的堆栈中。

                  scratch_data.active_neighbors.push_back(neighbor_child); 
                } 
              else 

// 如果我们不在1d中，我们收集所有 "在 "当前面的子面后面的邻居孩子，然后继续前进。

                for (unsigned int subface_n = 0; subface_n < face->n_children(); 
                     ++subface_n) 
                  scratch_data.active_neighbors.push_back( 
                    cell->neighbor_child_on_subface(face_n, subface_n)); 
            } 
        } 

// 好了，现在我们有了所有的邻居，让我们开始对他们每个人进行计算。首先，我们做一些预备工作：找出当前单元格的中心和该点的解决方案。后者是以正交点的函数值向量的形式得到的，当然，正交点只有一个。同样地，中心的位置是实空间中第一个（也是唯一的）正交点的位置。

    const Point<dim> this_center = 
      scratch_data.fe_midpoint_value.quadrature_point(0); 

    scratch_data.fe_midpoint_value.get_function_values( 
      scratch_data.solution, scratch_data.cell_midpoint_value); 

// 现在在所有活动邻居上循环，收集我们需要的数据。

    Tensor<1, dim> projected_gradient; 
    for (const auto &neighbor : scratch_data.active_neighbors) 
      { 

// 然后得到邻近单元的中心和该点的有限元函数值。注意，为了获得这些信息，我们必须重新初始化相邻单元的 <code>FEValues</code> 对象。

        scratch_data.fe_midpoint_value.reinit(neighbor); 
        const Point<dim> neighbor_center = 
          scratch_data.fe_midpoint_value.quadrature_point(0); 

        scratch_data.fe_midpoint_value.get_function_values( 
          scratch_data.solution, scratch_data.neighbor_midpoint_value); 

// 计算连接两个单元格中心的向量 <code>y</code> 。注意，与介绍不同，我们用 <code>y</code> 表示归一化的差分向量，因为这是在计算中随处可见的数量。

        Tensor<1, dim> y        = neighbor_center - this_center; 
        const double   distance = y.norm(); 
        y /= distance; 

// 然后把这个单元格对Y矩阵的贡献加起来...

        for (unsigned int i = 0; i < dim; ++i) 
          for (unsigned int j = 0; j < dim; ++j) 
            Y[i][j] += y[i] * y[j]; 

// ...并更新差额商数之和。

        projected_gradient += (scratch_data.neighbor_midpoint_value[0] - 
                               scratch_data.cell_midpoint_value[0]) / 
                              distance * y; 
      } 

// 如果现在，在收集了来自邻居的所有信息后，我们可以确定当前单元的梯度的近似值，那么我们需要经过跨越整个空间的向量 <code>y</code> ，否则我们就不会有梯度的所有成分。这可以通过矩阵的可逆性来说明。

// 如果矩阵不可逆，那么当前单元的活动邻居数量不足。与之前所有的情况（我们提出了异常）相比，这不是一个编程错误：这是一个运行时错误，即使在调试模式下运行良好，也可能在优化模式下发生，所以在优化模式下尝试捕捉这个错误是合理的。对于这种情况，有一个 <code>AssertThrow</code> 宏：它像 <code>Assert</code> 宏一样检查条件，但不仅仅是在调试模式下；然后输出一个错误信息，但不是像 <code>Assert</code> 宏那样中止程序，而是使用C++的 <code>throw</code> 命令抛出异常。这样，人们就有可能捕捉到这个错误，并采取合理的应对措施。其中一个措施是在全局范围内细化网格，因为如果初始网格的每个单元都至少被细化过一次，就不会出现方向不足的情况。

    AssertThrow(determinant(Y) != 0, ExcInsufficientDirections()); 

// 如果另一方面，矩阵是可反转的，那么就反转它，用它乘以其他数量，然后用这个数量和正确的网格宽度的幂来计算估计误差。

    const Tensor<2, dim> Y_inverse = invert(Y); 

    const Tensor<1, dim> gradient = Y_inverse * projected_gradient; 

// 这个函数的最后一部分是将我们刚刚计算出来的内容写入输出向量的元素中。这个向量的地址已经存储在Scratch数据对象中，我们所要做的就是知道如何在这个向量中获得正确的元素--但我们可以问一下我们所在的单元格是第多少个活动单元。

    scratch_data.error_per_cell(cell->active_cell_index()) = 
      (std::pow(cell->diameter(), 1 + 1.0 * dim / 2) * gradient.norm()); 
  } 
} // namespace Step9 
// @sect3{Main function}  

//  <code>main</code> 函数与前面的例子类似。主要区别是我们使用MultithreadInfo来设置最大的线程数（更多信息请参见文档模块  @ref threads  "多处理器访问共享内存的并行计算"）。使用的线程数是环境变量DEAL_II_NUM_THREADS和  <code>set_thread_limit</code>  的参数的最小值。如果没有给  <code>set_thread_limit</code>  的值，则使用英特尔线程构建块（TBB）库的默认值。如果省略了对  <code>set_thread_limit</code>  的调用，线程的数量将由 TBB 选择，与 DEAL_II_NUM_THREADS无关。

int main() 
{ 
  using namespace dealii; 
  try 
    {
      MultithreadInfo::set_thread_limit(); 

      Step9::AdvectionProblem<2> advection_problem_2d; 
      advection_problem_2d.run(); 
    } 
  catch (std::exception &exc) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Exception on processing: " << std::endl 
                << exc.what() << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 
  catch (...) 
    { 
      std::cerr << std::endl 
                << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      std::cerr << "Unknown exception!" << std::endl 
                << "Aborting!" << std::endl 
                << "----------------------------------------------------" 
                << std::endl; 
      return 1; 
    } 

  return 0; 
} 

//