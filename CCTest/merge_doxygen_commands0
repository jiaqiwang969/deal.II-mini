(lp0
S'/* ---------------------------------------------------------------------'
p1
aS' *'
p2
aS' * Copyright (C) 1999 - 2021 by the deal.II authors'
p3
aS' *'
p4
aS' * This file is part of the deal.II library.'
p5
aS' *'
p6
aS' * The deal.II library is free software; you can use it, redistribute'
p7
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p8
aS' * Public License as published by the Free Software Foundation; either'
p9
aS' * version 2.1 of the License, or (at your option) any later version.'
p10
aS' * The full text of the license can be found in the file LICENSE.md at'
p11
aS' * the top level directory of deal.II.'
p12
aS' *'
p13
aS' * ---------------------------------------------------------------------'
p14
aS' */'
p15
aS'#include <deal.II/grid/tria.h>'
p16
aS'#include <deal.II/grid/grid_generator.h>'
p17
aS'#include <deal.II/grid/grid_out.h>'
p18
aS'#include <iostream>'
p19
aS'#include <fstream>'
p20
aS'#include <cmath>'
p21
aS'using namespace dealii;'
p22
aS'void first_grid()'
p23
aS'{'
p24
aS'  Triangulation<2> triangulation;'
p25
aS'  GridGenerator::hyper_cube(triangulation);'
p26
aS'  triangulation.refine_global(4);'
p27
aS'  std::ofstream out("grid-1.svg");'
p28
aS'  GridOut       grid_out;'
p29
aS'  grid_out.write_svg(triangulation, out);'
p30
aS'  std::cout << "Grid written to grid-1.svg" << std::endl;'
p31
aS'}'
p32
aS'void second_grid()'
p33
ag24
aS'  Triangulation<2> triangulation;'
p34
aS'  const Point<2> center(1, 0);'
p35
aS'  const double   inner_radius = 0.5, outer_radius = 1.0;'
p36
aS'  GridGenerator::hyper_shell('
p37
aS'    triangulation, center, inner_radius, outer_radius, 10);'
p38
aS'  for (unsigned int step = 0; step < 5; ++step)'
p39
aS'    {'
p40
aS'      for (auto &cell : triangulation.active_cell_iterators())'
p41
aS'        {'
p42
aS'          for (const auto v : cell->vertex_indices())'
p43
aS'            {'
p44
aS'              const double distance_from_center ='
p45
aS'                center.distance(cell->vertex(v));'
p46
aS'              if (std::fabs(distance_from_center - inner_radius) <='
p47
aS'                  1e-6 * inner_radius)'
p48
aS'                {'
p49
aS'                  cell->set_refine_flag();'
p50
aS'                  break;'
p51
aS'                }'
p52
aS'            }'
p53
aS'        }'
p54
aS'      triangulation.execute_coarsening_and_refinement();'
p55
aS'    }'
p56
aS'  std::ofstream out("grid-2.svg");'
p57
aS'  GridOut       grid_out;'
p58
aS'  grid_out.write_svg(triangulation, out);'
p59
aS'  std::cout << "Grid written to grid-2.svg" << std::endl;'
p60
ag32
aS'int main()'
p61
ag24
aS'  first_grid();'
p62
aS'  second_grid();'
p63
ag32
aS'/* ---------------------------------------------------------------------'
p64
aS' *'
p65
aS' * Copyright (C) 2001 - 2021 by the deal.II authors'
p66
aS' *'
p67
aS' * This file is part of the deal.II library.'
p68
aS' *'
p69
aS' * The deal.II library is free software; you can use it, redistribute'
p70
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p71
aS' * Public License as published by the Free Software Foundation; either'
p72
aS' * version 2.1 of the License, or (at your option) any later version.'
p73
aS' * The full text of the license can be found in the file LICENSE.md at'
p74
aS' * the top level directory of deal.II.'
p75
aS' *'
p76
aS' * ---------------------------------------------------------------------'
p77
aS' *'
p78
aS' * Authors: Wolfgang Bangerth, Ralf Hartmann, University of Heidelberg, 2001'
p79
aS' */'
p80
aS'#include <deal.II/base/quadrature_lib.h>'
p81
aS'#include <deal.II/base/convergence_table.h>'
p82
aS'#include <deal.II/grid/grid_generator.h>'
p83
aS'#include <deal.II/grid/manifold_lib.h>'
p84
aS'#include <deal.II/grid/tria.h>'
p85
aS'#include <deal.II/grid/grid_out.h>'
p86
aS'#include <deal.II/dofs/dof_handler.h>'
p87
aS'#include <deal.II/fe/fe_values.h>'
p88
aS'#include <deal.II/fe/fe_nothing.h>'
p89
aS'#include <deal.II/fe/mapping_q.h>'
p90
aS'#include <iostream>'
p91
aS'#include <fstream>'
p92
aS'#include <cmath>'
p93
aS'namespace Step10'
p94
ag24
aS'  using namespace dealii;'
p95
aS'  const long double pi = 3.141592653589793238462643L;'
p96
aS'  template <int dim>'
p97
aS'  void gnuplot_output()'
p98
aS'  {'
p99
aS'    std::cout << "Output of grids into gnuplot files:" << std::endl'
p100
aS'              << "===================================" << std::endl;'
p101
aS'    Triangulation<dim> triangulation;'
p102
aS'    GridGenerator::hyper_ball(triangulation);'
p103
aS'    for (unsigned int refinement = 0; refinement < 2; ++refinement)'
p104
aS'      {'
p105
aS'        std::cout << "Refinement level: " << refinement << std::endl;'
p106
aS'        std::string filename_base = "ball_" + std::to_string(refinement);'
p107
aS'        for (unsigned int degree = 1; degree < 4; ++degree)'
p108
aS'          {'
p109
aS'            std::cout << "Degree = " << degree << std::endl;'
p110
aS'            const MappingQ<dim> mapping(degree);'
p111
aS'            GridOut               grid_out;'
p112
aS'            GridOutFlags::Gnuplot gnuplot_flags(false, 60);'
p113
aS'            grid_out.set_flags(gnuplot_flags);'
p114
aS'            std::string filename ='
p115
aS'              filename_base + "_mapping_q_" + std::to_string(degree) + ".dat";'
p116
aS'            std::ofstream gnuplot_file(filename);'
p117
aS'            grid_out.write_gnuplot(triangulation, gnuplot_file, &mapping);'
p118
aS'          }'
p119
aS'        std::cout << std::endl;'
p120
aS'        triangulation.refine_global();'
p121
aS'      }'
p122
aS'  }'
p123
aS'  template <int dim>'
p124
aS'  void compute_pi_by_area()'
p125
aS'  {'
p126
aS'    std::cout << "Computation of Pi by the area:" << std::endl'
p127
aS'              << "==============================" << std::endl;'
p128
aS'    const QGauss<dim> quadrature(4);'
p129
aS'    for (unsigned int degree = 1; degree < 5; ++degree)'
p130
aS'      {'
p131
aS'        std::cout << "Degree = " << degree << std::endl;'
p132
aS'        Triangulation<dim> triangulation;'
p133
aS'        GridGenerator::hyper_ball(triangulation);'
p134
aS'        const MappingQ<dim> mapping(degree);'
p135
aS'        const FE_Nothing<dim> fe;'
p136
aS'        DoFHandler<dim> dof_handler(triangulation);'
p137
aS'        FEValues<dim> fe_values(mapping, fe, quadrature, update_JxW_values);'
p138
aS'        ConvergenceTable table;'
p139
aS'        for (unsigned int refinement = 0; refinement < 6;'
p140
aS'             ++refinement, triangulation.refine_global(1))'
p141
aS'          {'
p142
aS'            table.add_value("cells", triangulation.n_active_cells());'
p143
aS'            dof_handler.distribute_dofs(fe);'
p144
aS'            long double area = 0;'
p145
aS'            for (const auto &cell : dof_handler.active_cell_iterators())'
p146
aS'              {'
p147
aS'                fe_values.reinit(cell);'
p148
aS'                for (unsigned int i = 0; i < fe_values.n_quadrature_points; ++i)'
p149
aS'                  area += static_cast<long double>(fe_values.JxW(i));'
p150
aS'              }'
p151
aS'            table.add_value("eval.pi", static_cast<double>(area));'
p152
aS'            table.add_value("error", static_cast<double>(std::fabs(area - pi)));'
p153
aS'          }'
p154
aS'        table.omit_column_from_convergence_rate_evaluation("cells");'
p155
aS'        table.omit_column_from_convergence_rate_evaluation("eval.pi");'
p156
aS'        table.evaluate_all_convergence_rates('
p157
aS'                                    ConvergenceTable::reduction_rate_log2);'
p158
aS'        table.set_precision("eval.pi", 16);'
p159
aS'        table.set_scientific("error", true);'
p160
aS'        table.write_text(std::cout);'
p161
aS'        std::cout << std::endl;'
p162
aS'      }'
p163
aS'  }'
p164
aS'  template <int dim>'
p165
aS'  void compute_pi_by_perimeter()'
p166
aS'  {'
p167
aS'    std::cout << "Computation of Pi by the perimeter:" << std::endl'
p168
aS'              << "===================================" << std::endl;'
p169
aS'    const QGauss<dim - 1> quadrature(4);'
p170
aS'    for (unsigned int degree = 1; degree < 5; ++degree)'
p171
aS'      {'
p172
aS'        std::cout << "Degree = " << degree << std::endl;'
p173
aS'        Triangulation<dim> triangulation;'
p174
aS'        GridGenerator::hyper_ball(triangulation);'
p175
aS'        const MappingQ<dim>   mapping(degree);'
p176
aS'        const FE_Nothing<dim> fe;'
p177
aS'        DoFHandler<dim> dof_handler(triangulation);'
p178
aS'        FEFaceValues<dim> fe_face_values(mapping,'
p179
aS'                                         fe,'
p180
aS'                                         quadrature,'
p181
aS'                                         update_JxW_values);'
p182
aS'        ConvergenceTable  table;'
p183
aS'        for (unsigned int refinement = 0; refinement < 6;'
p184
aS'             ++refinement, triangulation.refine_global(1))'
p185
aS'          {'
p186
aS'            table.add_value("cells", triangulation.n_active_cells());'
p187
aS'            dof_handler.distribute_dofs(fe);'
p188
aS'            long double perimeter = 0;'
p189
aS'            for (const auto &cell : dof_handler.active_cell_iterators())'
p190
aS'              for (const auto &face : cell->face_iterators())'
p191
aS'                if (face->at_boundary())'
p192
aS'                  {'
p193
aS'                    fe_face_values.reinit(cell, face);'
p194
aS'                    for (unsigned int i = 0;'
p195
aS'                         i < fe_face_values.n_quadrature_points;'
p196
aS'                         ++i)'
p197
aS'                      perimeter +='
p198
aS'                        static_cast<long double>(fe_face_values.JxW(i));'
p199
aS'                  }'
p200
aS'            table.add_value("eval.pi", static_cast<double>(perimeter / 2.0L));'
p201
aS'            table.add_value('
p202
aS'              "error", static_cast<double>(std::fabs(perimeter / 2.0L - pi)));'
p203
aS'          }'
p204
aS'        table.omit_column_from_convergence_rate_evaluation("cells");'
p205
aS'        table.omit_column_from_convergence_rate_evaluation("eval.pi");'
p206
aS'        table.evaluate_all_convergence_rates('
p207
aS'          ConvergenceTable::reduction_rate_log2);'
p208
aS'        table.set_precision("eval.pi", 16);'
p209
aS'        table.set_scientific("error", true);'
p210
aS'        table.write_text(std::cout);'
p211
aS'        std::cout << std::endl;'
p212
aS'      }'
p213
aS'  }'
p214
aS'} // namespace Step10'
p215
aS'int main()'
p216
ag24
aS'  try'
p217
aS'    {'
p218
aS'      std::cout.precision(16);'
p219
aS'      const unsigned int dim = 2;'
p220
aS'      Step10::gnuplot_output<dim>();'
p221
aS'      Step10::compute_pi_by_area<dim>();'
p222
aS'      Step10::compute_pi_by_perimeter<dim>();'
p223
aS'    }'
p224
aS'  catch (std::exception &exc)'
p225
aS'    {'
p226
aS'      std::cerr << std::endl'
p227
aS'                << std::endl'
p228
aS'                << "----------------------------------------------------"'
p229
aS'                << std::endl;'
p230
aS'      std::cerr << "Exception on processing: " << std::endl'
p231
aS'                << exc.what() << std::endl'
p232
aS'                << "Aborting!" << std::endl'
p233
aS'                << "----------------------------------------------------"'
p234
aS'                << std::endl;'
p235
aS'      return 1;'
p236
aS'    }'
p237
aS'  catch (...)'
p238
aS'    {'
p239
aS'      std::cerr << std::endl'
p240
aS'                << std::endl'
p241
aS'                << "----------------------------------------------------"'
p242
aS'                << std::endl;'
p243
aS'      std::cerr << "Unknown exception!" << std::endl'
p244
aS'                << "Aborting!" << std::endl'
p245
aS'                << "----------------------------------------------------"'
p246
aS'                << std::endl;'
p247
aS'      return 1;'
p248
aS'    }'
p249
aS'  return 0;'
p250
ag32
aS'/* ---------------------------------------------------------------------'
p251
aS' *'
p252
aS' * Copyright (C) 2001 - 2021 by the deal.II authors'
p253
aS' *'
p254
aS' * This file is part of the deal.II library.'
p255
aS' *'
p256
aS' * The deal.II library is free software; you can use it, redistribute'
p257
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p258
aS' * Public License as published by the Free Software Foundation; either'
p259
aS' * version 2.1 of the License, or (at your option) any later version.'
p260
aS' * The full text of the license can be found in the file LICENSE.md at'
p261
aS' * the top level directory of deal.II.'
p262
aS' *'
p263
aS' * ---------------------------------------------------------------------'
p264
aS' *'
p265
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 2001'
p266
aS' */'
p267
aS'#include <deal.II/base/quadrature_lib.h>'
p268
aS'#include <deal.II/base/function.h>'
p269
aS'#include <deal.II/base/logstream.h>'
p270
aS'#include <deal.II/base/table_handler.h>'
p271
aS'#include <deal.II/lac/vector.h>'
p272
aS'#include <deal.II/lac/sparse_matrix.h>'
p273
aS'#include <deal.II/lac/solver_cg.h>'
p274
aS'#include <deal.II/lac/precondition.h>'
p275
aS'#include <deal.II/lac/affine_constraints.h>'
p276
aS'#include <deal.II/grid/tria.h>'
p277
aS'#include <deal.II/grid/grid_generator.h>'
p278
aS'#include <deal.II/dofs/dof_handler.h>'
p279
aS'#include <deal.II/dofs/dof_tools.h>'
p280
aS'#include <deal.II/fe/fe_q.h>'
p281
aS'#include <deal.II/fe/fe_values.h>'
p282
aS'#include <deal.II/fe/mapping_q.h>'
p283
aS'#include <deal.II/numerics/vector_tools.h>'
p284
aS'#include <deal.II/numerics/matrix_tools.h>'
p285
aS'#include <deal.II/numerics/data_out.h>'
p286
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p287
aS'#include <algorithm>'
p288
aS'#include <iostream>'
p289
aS'#include <iomanip>'
p290
aS'#include <cmath>'
p291
aS'namespace Step11'
p292
ag24
aS'  using namespace dealii;'
p293
aS'  template <int dim>'
p294
aS'  class LaplaceProblem'
p295
aS'  {'
p296
aS'  public:'
p297
aS'    LaplaceProblem(const unsigned int mapping_degree);'
p298
aS'    void run();'
p299
aS'  private:'
p300
aS'    void setup_system();'
p301
aS'    void assemble_and_solve();'
p302
aS'    void solve();'
p303
aS'    void write_high_order_mesh(const unsigned cycle);'
p304
aS'    Triangulation<dim> triangulation;'
p305
aS'    FE_Q<dim>          fe;'
p306
aS'    DoFHandler<dim>    dof_handler;'
p307
aS'    MappingQ<dim>      mapping;'
p308
aS'    SparsityPattern           sparsity_pattern;'
p309
aS'    SparseMatrix<double>      system_matrix;'
p310
aS'    AffineConstraints<double> mean_value_constraints;'
p311
aS'    Vector<double> solution;'
p312
aS'    Vector<double> system_rhs;'
p313
aS'    TableHandler output_table;'
p314
aS'  };'
p315
aS'  template <int dim>'
p316
aS'  LaplaceProblem<dim>::LaplaceProblem(const unsigned int mapping_degree)'
p317
aS'    : fe(1)'
p318
aS'    , dof_handler(triangulation)'
p319
aS'    , mapping(mapping_degree)'
p320
aS'  {'
p321
aS'    std::cout << "Using mapping with degree " << mapping_degree << ":"'
p322
aS'              << std::endl'
p323
aS'              << "============================" << std::endl;'
p324
aS'  }'
p325
aS'  template <int dim>'
p326
aS'  void LaplaceProblem<dim>::setup_system()'
p327
aS'  {'
p328
aS'    dof_handler.distribute_dofs(fe);'
p329
aS'    solution.reinit(dof_handler.n_dofs());'
p330
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p331
aS'    const IndexSet boundary_dofs = DoFTools::extract_boundary_dofs(dof_handler);'
p332
aS'    const types::global_dof_index first_boundary_dof ='
p333
aS'      boundary_dofs.nth_index_in_set(0);'
p334
aS'    mean_value_constraints.clear();'
p335
aS'    mean_value_constraints.add_line(first_boundary_dof);'
p336
aS'    for (types::global_dof_index i : boundary_dofs)'
p337
aS'      if (i != first_boundary_dof)'
p338
aS'        mean_value_constraints.add_entry(first_boundary_dof, i, -1);'
p339
aS'    mean_value_constraints.close();'
p340
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p341
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p342
aS'    mean_value_constraints.condense(dsp);'
p343
aS'    sparsity_pattern.copy_from(dsp);'
p344
aS'    system_matrix.reinit(sparsity_pattern);'
p345
aS'  }'
p346
aS'  template <int dim>'
p347
aS'  void LaplaceProblem<dim>::assemble_and_solve()'
p348
aS'  {'
p349
aS'    const unsigned int gauss_degree ='
p350
aS'      std::max(static_cast<unsigned int>('
p351
aS'                 std::ceil(1. * (mapping.get_degree() + 1) / 2)),'
p352
aS'               2U);'
p353
aS'    MatrixTools::create_laplace_matrix(mapping,'
p354
aS'                                       dof_handler,'
p355
aS'                                       QGauss<dim>(gauss_degree),'
p356
aS'                                       system_matrix);'
p357
aS'    VectorTools::create_right_hand_side(mapping,'
p358
aS'                                        dof_handler,'
p359
aS'                                        QGauss<dim>(gauss_degree),'
p360
aS'                                        Functions::ConstantFunction<dim>(-2),'
p361
aS'                                        system_rhs);'
p362
aS'    Vector<double> tmp(system_rhs.size());'
p363
aS'    VectorTools::create_boundary_right_hand_side('
p364
aS'      mapping,'
p365
aS'      dof_handler,'
p366
aS'      QGauss<dim - 1>(gauss_degree),'
p367
aS'      Functions::ConstantFunction<dim>(1),'
p368
aS'      tmp);'
p369
aS'    system_rhs += tmp;'
p370
aS'    mean_value_constraints.condense(system_matrix);'
p371
aS'    mean_value_constraints.condense(system_rhs);'
p372
aS'    solve();'
p373
aS'    mean_value_constraints.distribute(solution);'
p374
aS'    Vector<float> norm_per_cell(triangulation.n_active_cells());'
p375
aS'    VectorTools::integrate_difference(mapping,'
p376
aS'                                      dof_handler,'
p377
aS'                                      solution,'
p378
aS'                                      Functions::ZeroFunction<dim>(),'
p379
aS'                                      norm_per_cell,'
p380
aS'                                      QGauss<dim>(gauss_degree + 1),'
p381
aS'                                      VectorTools::H1_seminorm);'
p382
aS'    const double norm ='
p383
aS'      VectorTools::compute_global_error(triangulation,'
p384
aS'                                        norm_per_cell,'
p385
aS'                                        VectorTools::H1_seminorm);'
p386
aS'    output_table.add_value("cells", triangulation.n_active_cells());'
p387
aS'    output_table.add_value("|u|_1", norm);'
p388
aS'    output_table.add_value("error",'
p389
aS'                           std::fabs(norm - std::sqrt(3.14159265358 / 2)));'
p390
aS'  }'
p391
aS'  template <int dim>'
p392
aS'  void LaplaceProblem<dim>::solve()'
p393
aS'  {'
p394
aS'    SolverControl            solver_control(1000, 1e-12);'
p395
aS'    SolverCG<Vector<double>> cg(solver_control);'
p396
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p397
aS'    preconditioner.initialize(system_matrix, 1.2);'
p398
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p399
aS'  }'
p400
aS'  template <int dim>'
p401
aS'  void LaplaceProblem<dim>::write_high_order_mesh(const unsigned cycle)'
p402
aS'  {'
p403
aS'    DataOut<dim> data_out;'
p404
aS'    DataOutBase::VtkFlags flags;'
p405
aS'    flags.write_higher_order_cells = true;'
p406
aS'    data_out.set_flags(flags);'
p407
aS'    data_out.attach_dof_handler(dof_handler);'
p408
aS'    data_out.add_data_vector(solution, "solution");'
p409
aS'    data_out.build_patches(mapping,'
p410
aS'                           mapping.get_degree(),'
p411
aS'                           DataOut<dim>::curved_inner_cells);'
p412
aS'    std::ofstream file("solution-c=" + std::to_string(cycle) +'
p413
aS'                       ".p=" + std::to_string(mapping.get_degree()) + ".vtu");'
p414
aS'    data_out.write_vtu(file);'
p415
aS'  }'
p416
aS'  template <int dim>'
p417
aS'  void LaplaceProblem<dim>::run()'
p418
aS'  {'
p419
aS'    GridGenerator::hyper_ball(triangulation);'
p420
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p421
aS'      {'
p422
aS'        setup_system();'
p423
aS'        assemble_and_solve();'
p424
aS'        write_high_order_mesh(cycle);'
p425
aS'        triangulation.refine_global();'
p426
aS'      }'
p427
aS'    output_table.set_precision("|u|_1", 6);'
p428
aS'    output_table.set_precision("error", 6);'
p429
aS'    output_table.write_text(std::cout);'
p430
aS'    std::cout << std::endl;'
p431
aS'  }'
p432
aS'} // namespace Step11'
p433
aS'int main()'
p434
ag24
aS'  try'
p435
aS'    {'
p436
aS'      std::cout.precision(5);'
p437
aS'      for (unsigned int mapping_degree = 1; mapping_degree <= 3;'
p438
aS'           ++mapping_degree)'
p439
aS'        Step11::LaplaceProblem<2>(mapping_degree).run();'
p440
aS'    }'
p441
aS'  catch (std::exception &exc)'
p442
aS'    {'
p443
aS'      std::cerr << std::endl'
p444
aS'                << std::endl'
p445
aS'                << "----------------------------------------------------"'
p446
aS'                << std::endl;'
p447
aS'      std::cerr << "Exception on processing: " << std::endl'
p448
aS'                << exc.what() << std::endl'
p449
aS'                << "Aborting!" << std::endl'
p450
aS'                << "----------------------------------------------------"'
p451
aS'                << std::endl;'
p452
aS'      return 1;'
p453
aS'    }'
p454
aS'  catch (...)'
p455
aS'    {'
p456
aS'      std::cerr << std::endl'
p457
aS'                << std::endl'
p458
aS'                << "----------------------------------------------------"'
p459
aS'                << std::endl;'
p460
aS'      std::cerr << "Unknown exception!" << std::endl'
p461
aS'                << "Aborting!" << std::endl'
p462
aS'                << "----------------------------------------------------"'
p463
aS'                << std::endl;'
p464
aS'      return 1;'
p465
aS'    };'
p466
aS'  return 0;'
p467
ag32
aS'/* ---------------------------------------------------------------------'
p468
aS' *'
p469
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p470
aS' *'
p471
aS' * This file is part of the deal.II library.'
p472
aS' *'
p473
aS' * The deal.II library is free software; you can use it, redistribute'
p474
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p475
aS' * Public License as published by the Free Software Foundation; either'
p476
aS' * version 2.1 of the License, or (at your option) any later version.'
p477
aS' * The full text of the license can be found in the file LICENSE.md at'
p478
aS' * the top level directory of deal.II.'
p479
aS' *'
p480
aS' * ---------------------------------------------------------------------'
p481
aS' *'
p482
aS' * Author: Guido Kanschat, Texas A&M University, 2009'
p483
aS' *         Timo Heister, Clemson University, 2019'
p484
aS' */'
p485
aS'#include <deal.II/base/quadrature_lib.h>'
p486
aS'#include <deal.II/base/function.h>'
p487
aS'#include <deal.II/lac/vector.h>'
p488
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p489
aS'#include <deal.II/lac/sparse_matrix.h>'
p490
aS'#include <deal.II/grid/tria.h>'
p491
aS'#include <deal.II/grid/grid_generator.h>'
p492
aS'#include <deal.II/grid/grid_out.h>'
p493
aS'#include <deal.II/grid/grid_refinement.h>'
p494
aS'#include <deal.II/fe/fe_values.h>'
p495
aS'#include <deal.II/dofs/dof_handler.h>'
p496
aS'#include <deal.II/numerics/vector_tools.h>'
p497
aS'#include <deal.II/dofs/dof_tools.h>'
p498
aS'#include <deal.II/numerics/data_out.h>'
p499
aS'#include <deal.II/fe/mapping_q1.h>'
p500
aS'#include <deal.II/fe/fe_dgq.h>'
p501
aS'#include <deal.II/fe/fe_interface_values.h>'
p502
aS'#include <deal.II/lac/solver_richardson.h>'
p503
aS'#include <deal.II/lac/precondition_block.h>'
p504
aS'#include <deal.II/numerics/derivative_approximation.h>'
p505
aS'#include <deal.II/meshworker/mesh_loop.h>'
p506
aS'#include <iostream>'
p507
aS'#include <fstream>'
p508
aS'namespace Step12'
p509
ag24
aS'  using namespace dealii;'
p510
aS'  template <int dim>'
p511
aS'  class BoundaryValues : public Function<dim>'
p512
aS'  {'
p513
aS'  public:'
p514
aS'    BoundaryValues() = default;'
p515
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p516
aS'                            std::vector<double> &          values,'
p517
aS'                            const unsigned int component = 0) const override;'
p518
aS'  };'
p519
aS'  template <int dim>'
p520
aS'  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,'
p521
aS'                                       std::vector<double> &          values,'
p522
aS'                                       const unsigned int component) const'
p523
aS'  {'
p524
aS'    (void)component;'
p525
aS'    AssertIndexRange(component, 1);'
p526
aS'    Assert(values.size() == points.size(),'
p527
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p528
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p529
aS'      {'
p530
aS'        if (points[i](0) < 0.5)'
p531
aS'          values[i] = 1.;'
p532
aS'        else'
p533
aS'          values[i] = 0.;'
p534
aS'      }'
p535
aS'  }'
p536
aS'  template <int dim>'
p537
aS'  Tensor<1, dim> beta(const Point<dim> &p)'
p538
aS'  {'
p539
aS'    Assert(dim >= 2, ExcNotImplemented());'
p540
aS'    Tensor<1, dim> wind_field;'
p541
aS'    wind_field[0] = -p[1];'
p542
aS'    wind_field[1] = p[0];'
p543
aS'    if (wind_field.norm() > 1e-10)'
p544
aS'      wind_field /= wind_field.norm();'
p545
aS'    return wind_field;'
p546
aS'  }'
p547
aS'  template <int dim>'
p548
aS'  struct ScratchData'
p549
aS'  {'
p550
aS'    ScratchData(const Mapping<dim> &       mapping,'
p551
aS'                const FiniteElement<dim> & fe,'
p552
aS'                const Quadrature<dim> &    quadrature,'
p553
aS'                const Quadrature<dim - 1> &quadrature_face,'
p554
aS'                const UpdateFlags          update_flags = update_values |'
p555
aS'                                                 update_gradients |'
p556
aS'                                                 update_quadrature_points |'
p557
aS'                                                 update_JxW_values,'
p558
aS'                const UpdateFlags interface_update_flags ='
p559
aS'                  update_values | update_gradients | update_quadrature_points |'
p560
aS'                  update_JxW_values | update_normal_vectors)'
p561
aS'      : fe_values(mapping, fe, quadrature, update_flags)'
p562
aS'      , fe_interface_values(mapping,'
p563
aS'                            fe,'
p564
aS'                            quadrature_face,'
p565
aS'                            interface_update_flags)'
p566
aS'    {}'
p567
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p568
aS'      : fe_values(scratch_data.fe_values.get_mapping(),'
p569
aS'                  scratch_data.fe_values.get_fe(),'
p570
aS'                  scratch_data.fe_values.get_quadrature(),'
p571
aS'                  scratch_data.fe_values.get_update_flags())'
p572
aS'      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),'
p573
aS'                            scratch_data.fe_interface_values.get_fe(),'
p574
aS'                            scratch_data.fe_interface_values.get_quadrature(),'
p575
aS'                            scratch_data.fe_interface_values.get_update_flags())'
p576
aS'    {}'
p577
aS'    FEValues<dim>          fe_values;'
p578
aS'    FEInterfaceValues<dim> fe_interface_values;'
p579
aS'  };'
p580
aS'  struct CopyDataFace'
p581
aS'  {'
p582
aS'    FullMatrix<double>                   cell_matrix;'
p583
aS'    std::vector<types::global_dof_index> joint_dof_indices;'
p584
aS'  };'
p585
aS'  struct CopyData'
p586
aS'  {'
p587
aS'    FullMatrix<double>                   cell_matrix;'
p588
aS'    Vector<double>                       cell_rhs;'
p589
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p590
aS'    std::vector<CopyDataFace>            face_data;'
p591
aS'    template <class Iterator>'
p592
aS'    void reinit(const Iterator &cell, unsigned int dofs_per_cell)'
p593
aS'    {'
p594
aS'      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p595
aS'      cell_rhs.reinit(dofs_per_cell);'
p596
aS'      local_dof_indices.resize(dofs_per_cell);'
p597
aS'      cell->get_dof_indices(local_dof_indices);'
p598
aS'    }'
p599
aS'  };'
p600
aS'  template <int dim>'
p601
aS'  class AdvectionProblem'
p602
aS'  {'
p603
aS'  public:'
p604
aS'    AdvectionProblem();'
p605
aS'    void run();'
p606
aS'  private:'
p607
aS'    void setup_system();'
p608
aS'    void assemble_system();'
p609
aS'    void solve();'
p610
aS'    void refine_grid();'
p611
aS'    void output_results(const unsigned int cycle) const;'
p612
aS'    Triangulation<dim>   triangulation;'
p613
aS'    const MappingQ1<dim> mapping;'
p614
aS'    const FE_DGQ<dim> fe;'
p615
aS'    DoFHandler<dim>   dof_handler;'
p616
aS'    const QGauss<dim>     quadrature;'
p617
aS'    const QGauss<dim - 1> quadrature_face;'
p618
aS'    SparsityPattern      sparsity_pattern;'
p619
aS'    SparseMatrix<double> system_matrix;'
p620
aS'    Vector<double> solution;'
p621
aS'    Vector<double> right_hand_side;'
p622
aS'  };'
p623
aS'  template <int dim>'
p624
aS'  AdvectionProblem<dim>::AdvectionProblem()'
p625
aS'    : mapping()'
p626
aS'    , fe(1)'
p627
aS'    , dof_handler(triangulation)'
p628
aS'    , quadrature(fe.tensor_degree() + 1)'
p629
aS'    , quadrature_face(fe.tensor_degree() + 1)'
p630
aS'  {}'
p631
aS'  template <int dim>'
p632
aS'  void AdvectionProblem<dim>::setup_system()'
p633
aS'  {'
p634
aS'    dof_handler.distribute_dofs(fe);'
p635
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p636
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p637
aS'    sparsity_pattern.copy_from(dsp);'
p638
aS'    system_matrix.reinit(sparsity_pattern);'
p639
aS'    solution.reinit(dof_handler.n_dofs());'
p640
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p641
aS'  }'
p642
aS'  template <int dim>'
p643
aS'  void AdvectionProblem<dim>::assemble_system()'
p644
aS'  {'
p645
aS'    using Iterator = typename DoFHandler<dim>::active_cell_iterator;'
p646
aS'    const BoundaryValues<dim> boundary_function;'
p647
aS'    const auto cell_worker = [&](const Iterator &  cell,'
p648
aS'                                 ScratchData<dim> &scratch_data,'
p649
aS'                                 CopyData &        copy_data) {'
p650
aS'      const unsigned int n_dofs ='
p651
aS'        scratch_data.fe_values.get_fe().n_dofs_per_cell();'
p652
aS'      copy_data.reinit(cell, n_dofs);'
p653
aS'      scratch_data.fe_values.reinit(cell);'
p654
aS'      const auto &q_points = scratch_data.fe_values.get_quadrature_points();'
p655
aS'      const FEValues<dim> &      fe_v = scratch_data.fe_values;'
p656
aS'      const std::vector<double> &JxW  = fe_v.get_JxW_values();'
p657
aS'      for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p658
aS'        {'
p659
aS'          auto beta_q = beta(q_points[point]);'
p660
aS'          for (unsigned int i = 0; i < n_dofs; ++i)'
p661
aS'            for (unsigned int j = 0; j < n_dofs; ++j)'
p662
aS'              {'
p663
aS'                copy_data.cell_matrix(i, j) +='
p664
aS'                  -beta_q                      // -\\beta'
p665
aS'                  * fe_v.shape_grad(i, point)  // \\nabla \\phi_i'
p666
aS'                  * fe_v.shape_value(j, point) // \\phi_j'
p667
aS'                  * JxW[point];                // dx'
p668
aS'              }'
p669
aS'        }'
p670
aS'    };'
p671
aS'    const auto boundary_worker = [&](const Iterator &    cell,'
p672
aS'                                     const unsigned int &face_no,'
p673
aS'                                     ScratchData<dim> &  scratch_data,'
p674
aS'                                     CopyData &          copy_data) {'
p675
aS'      scratch_data.fe_interface_values.reinit(cell, face_no);'
p676
aS'      const FEFaceValuesBase<dim> &fe_face ='
p677
aS'        scratch_data.fe_interface_values.get_fe_face_values(0);'
p678
aS'      const auto &q_points = fe_face.get_quadrature_points();'
p679
aS'      const unsigned int n_facet_dofs = fe_face.get_fe().n_dofs_per_cell();'
p680
aS'      const std::vector<double> &        JxW     = fe_face.get_JxW_values();'
p681
aS'      const std::vector<Tensor<1, dim>> &normals = fe_face.get_normal_vectors();'
p682
aS'      std::vector<double> g(q_points.size());'
p683
aS'      boundary_function.value_list(q_points, g);'
p684
aS'      for (unsigned int point = 0; point < q_points.size(); ++point)'
p685
aS'        {'
p686
aS'          const double beta_dot_n = beta(q_points[point]) * normals[point];'
p687
aS'          if (beta_dot_n > 0)'
p688
aS'            {'
p689
aS'              for (unsigned int i = 0; i < n_facet_dofs; ++i)'
p690
aS'                for (unsigned int j = 0; j < n_facet_dofs; ++j)'
p691
aS'                  copy_data.cell_matrix(i, j) +='
p692
aS'                    fe_face.shape_value(i, point)   // \\phi_i'
p693
aS'                    * fe_face.shape_value(j, point) // \\phi_j'
p694
aS'                    * beta_dot_n                    // \\beta . n'
p695
aS'                    * JxW[point];                   // dx'
p696
aS'            }'
p697
aS'          else'
p698
aS'            for (unsigned int i = 0; i < n_facet_dofs; ++i)'
p699
aS'              copy_data.cell_rhs(i) += -fe_face.shape_value(i, point) // \\phi_i'
p700
aS'                                       * g[point]                     // g'
p701
aS'                                       * beta_dot_n  // \\beta . n'
p702
aS'                                       * JxW[point]; // dx'
p703
aS'        }'
p704
aS'    };'
p705
aS'    const auto face_worker = [&](const Iterator &    cell,'
p706
aS'                                 const unsigned int &f,'
p707
aS'                                 const unsigned int &sf,'
p708
aS'                                 const Iterator &    ncell,'
p709
aS'                                 const unsigned int &nf,'
p710
aS'                                 const unsigned int &nsf,'
p711
aS'                                 ScratchData<dim> &  scratch_data,'
p712
aS'                                 CopyData &          copy_data) {'
p713
aS'      FEInterfaceValues<dim> &fe_iv = scratch_data.fe_interface_values;'
p714
aS'      fe_iv.reinit(cell, f, sf, ncell, nf, nsf);'
p715
aS'      const auto &q_points = fe_iv.get_quadrature_points();'
p716
aS'      copy_data.face_data.emplace_back();'
p717
aS'      CopyDataFace &copy_data_face = copy_data.face_data.back();'
p718
aS'      const unsigned int n_dofs        = fe_iv.n_current_interface_dofs();'
p719
aS'      copy_data_face.joint_dof_indices = fe_iv.get_interface_dof_indices();'
p720
aS'      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);'
p721
aS'      const std::vector<double> &        JxW     = fe_iv.get_JxW_values();'
p722
aS'      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();'
p723
aS'      for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint)'
p724
aS'        {'
p725
aS'          const double beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];'
p726
aS'          for (unsigned int i = 0; i < n_dofs; ++i)'
p727
aS'            for (unsigned int j = 0; j < n_dofs; ++j)'
p728
aS'              copy_data_face.cell_matrix(i, j) +='
p729
aS'                fe_iv.jump(i, qpoint) // [\\phi_i]'
p730
aS'                *'
p731
aS'                fe_iv.shape_value((beta_dot_n > 0), j, qpoint) // phi_j^{upwind}'
p732
aS'                * beta_dot_n                                   // (\\beta . n)'
p733
aS'                * JxW[qpoint];                                 // dx'
p734
aS'        }'
p735
aS'    };'
p736
aS'    const AffineConstraints<double> constraints;'
p737
aS'    const auto copier = [&](const CopyData &c) {'
p738
aS'      constraints.distribute_local_to_global(c.cell_matrix,'
p739
aS'                                             c.cell_rhs,'
p740
aS'                                             c.local_dof_indices,'
p741
aS'                                             system_matrix,'
p742
aS'                                             right_hand_side);'
p743
aS'      for (auto &cdf : c.face_data)'
p744
aS'        {'
p745
aS'          constraints.distribute_local_to_global(cdf.cell_matrix,'
p746
aS'                                                 cdf.joint_dof_indices,'
p747
aS'                                                 system_matrix);'
p748
aS'        }'
p749
aS'    };'
p750
aS'    ScratchData<dim> scratch_data(mapping, fe, quadrature, quadrature_face);'
p751
aS'    CopyData         copy_data;'
p752
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p753
aS'                          dof_handler.end(),'
p754
aS'                          cell_worker,'
p755
aS'                          copier,'
p756
aS'                          scratch_data,'
p757
aS'                          copy_data,'
p758
aS'                          MeshWorker::assemble_own_cells |'
p759
aS'                            MeshWorker::assemble_boundary_faces |'
p760
aS'                            MeshWorker::assemble_own_interior_faces_once,'
p761
aS'                          boundary_worker,'
p762
aS'                          face_worker);'
p763
aS'  }'
p764
aS'  template <int dim>'
p765
aS'  void AdvectionProblem<dim>::solve()'
p766
aS'  {'
p767
aS'    SolverControl                    solver_control(1000, 1e-12);'
p768
aS'    SolverRichardson<Vector<double>> solver(solver_control);'
p769
aS'    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;'
p770
aS'    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());'
p771
aS'    solver.solve(system_matrix, solution, right_hand_side, preconditioner);'
p772
aS'    std::cout << "  Solver converged in " << solver_control.last_step()'
p773
aS'              << " iterations." << std::endl;'
p774
aS'  }'
p775
aS'  template <int dim>'
p776
aS'  void AdvectionProblem<dim>::refine_grid()'
p777
aS'  {'
p778
aS'    Vector<float> gradient_indicator(triangulation.n_active_cells());'
p779
aS'    DerivativeApproximation::approximate_gradient(mapping,'
p780
aS'                                                  dof_handler,'
p781
aS'                                                  solution,'
p782
aS'                                                  gradient_indicator);'
p783
aS'    unsigned int cell_no = 0;'
p784
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p785
aS'      gradient_indicator(cell_no++) *='
p786
aS'        std::pow(cell->diameter(), 1 + 1.0 * dim / 2);'
p787
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p788
aS'                                                    gradient_indicator,'
p789
aS'                                                    0.3,'
p790
aS'                                                    0.1);'
p791
aS'    triangulation.execute_coarsening_and_refinement();'
p792
aS'  }'
p793
aS'  template <int dim>'
p794
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p795
aS'  {'
p796
aS'    const std::string filename = "solution-" + std::to_string(cycle) + ".vtk";'
p797
aS'    std::cout << "  Writing solution to <" << filename << ">" << std::endl;'
p798
aS'    std::ofstream output(filename);'
p799
aS'    DataOut<dim> data_out;'
p800
aS'    data_out.attach_dof_handler(dof_handler);'
p801
aS'    data_out.add_data_vector(solution, "u", DataOut<dim>::type_dof_data);'
p802
aS'    data_out.build_patches(mapping);'
p803
aS'    data_out.write_vtk(output);'
p804
aS'    {'
p805
aS'      Vector<float> values(triangulation.n_active_cells());'
p806
aS'      VectorTools::integrate_difference(mapping,'
p807
aS'                                        dof_handler,'
p808
aS'                                        solution,'
p809
aS'                                        Functions::ZeroFunction<dim>(),'
p810
aS'                                        values,'
p811
aS'                                        quadrature,'
p812
aS'                                        VectorTools::Linfty_norm);'
p813
aS'      const double l_infty ='
p814
aS'        VectorTools::compute_global_error(triangulation,'
p815
aS'                                          values,'
p816
aS'                                          VectorTools::Linfty_norm);'
p817
aS'      std::cout << "  L-infinity norm: " << l_infty << std::endl;'
p818
aS'    }'
p819
aS'  }'
p820
aS'  template <int dim>'
p821
aS'  void AdvectionProblem<dim>::run()'
p822
aS'  {'
p823
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p824
aS'      {'
p825
aS'        std::cout << "Cycle " << cycle << std::endl;'
p826
aS'        if (cycle == 0)'
p827
aS'          {'
p828
aS'            GridGenerator::hyper_cube(triangulation);'
p829
aS'            triangulation.refine_global(3);'
p830
aS'          }'
p831
aS'        else'
p832
aS'          refine_grid();'
p833
aS'        std::cout << "  Number of active cells:       "'
p834
aS'                  << triangulation.n_active_cells() << std::endl;'
p835
aS'        setup_system();'
p836
aS'        std::cout << "  Number of degrees of freedom: " << dof_handler.n_dofs()'
p837
aS'                  << std::endl;'
p838
aS'        assemble_system();'
p839
aS'        solve();'
p840
aS'        output_results(cycle);'
p841
aS'      }'
p842
aS'  }'
p843
aS'} // namespace Step12'
p844
aS'int main()'
p845
ag24
aS'  try'
p846
aS'    {'
p847
aS'      Step12::AdvectionProblem<2> dgmethod;'
p848
aS'      dgmethod.run();'
p849
aS'    }'
p850
aS'  catch (std::exception &exc)'
p851
aS'    {'
p852
aS'      std::cerr << std::endl'
p853
aS'                << std::endl'
p854
aS'                << "----------------------------------------------------"'
p855
aS'                << std::endl;'
p856
aS'      std::cerr << "Exception on processing: " << std::endl'
p857
aS'                << exc.what() << std::endl'
p858
aS'                << "Aborting!" << std::endl'
p859
aS'                << "----------------------------------------------------"'
p860
aS'                << std::endl;'
p861
aS'      return 1;'
p862
aS'    }'
p863
aS'  catch (...)'
p864
aS'    {'
p865
aS'      std::cerr << std::endl'
p866
aS'                << std::endl'
p867
aS'                << "----------------------------------------------------"'
p868
aS'                << std::endl;'
p869
aS'      std::cerr << "Unknown exception!" << std::endl'
p870
aS'                << "Aborting!" << std::endl'
p871
aS'                << "----------------------------------------------------"'
p872
aS'                << std::endl;'
p873
aS'      return 1;'
p874
aS'    }'
p875
aS'  return 0;'
p876
ag32
aS'/* ---------------------------------------------------------------------'
p877
aS' *'
p878
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p879
aS' *'
p880
aS' * This file is part of the deal.II library.'
p881
aS' *'
p882
aS' * The deal.II library is free software; you can use it, redistribute'
p883
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p884
aS' * Public License as published by the Free Software Foundation; either'
p885
aS' * version 2.1 of the License, or (at your option) any later version.'
p886
aS' * The full text of the license can be found in the file LICENSE.md at'
p887
aS' * the top level directory of deal.II.'
p888
aS' *'
p889
aS' * ---------------------------------------------------------------------'
p890
aS' *'
p891
aS' * Author: Guido Kanschat, Texas A&M University, 2009'
p892
aS' */'
p893
aS'#include <deal.II/base/quadrature_lib.h>'
p894
aS'#include <deal.II/base/function.h>'
p895
aS'#include <deal.II/lac/vector.h>'
p896
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p897
aS'#include <deal.II/lac/sparse_matrix.h>'
p898
aS'#include <deal.II/grid/tria.h>'
p899
aS'#include <deal.II/grid/grid_generator.h>'
p900
aS'#include <deal.II/grid/grid_out.h>'
p901
aS'#include <deal.II/grid/grid_refinement.h>'
p902
aS'#include <deal.II/fe/fe_values.h>'
p903
aS'#include <deal.II/dofs/dof_handler.h>'
p904
aS'#include <deal.II/dofs/dof_tools.h>'
p905
aS'#include <deal.II/numerics/data_out.h>'
p906
aS'#include <deal.II/fe/mapping_q1.h>'
p907
aS'#include <deal.II/fe/fe_dgq.h>'
p908
aS'#include <deal.II/lac/solver_richardson.h>'
p909
aS'#include <deal.II/lac/precondition_block.h>'
p910
aS'#include <deal.II/numerics/derivative_approximation.h>'
p911
aS'#include <deal.II/meshworker/dof_info.h>'
p912
aS'#include <deal.II/meshworker/integration_info.h>'
p913
aS'#include <deal.II/meshworker/simple.h>'
p914
aS'#include <deal.II/meshworker/loop.h>'
p915
aS'#include <iostream>'
p916
aS'#include <fstream>'
p917
aS'namespace Step12'
p918
ag24
aS'  using namespace dealii;'
p919
aS'  template <int dim>'
p920
aS'  class BoundaryValues : public Function<dim>'
p921
aS'  {'
p922
aS'  public:'
p923
aS'    BoundaryValues() = default;'
p924
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p925
aS'                            std::vector<double> &          values,'
p926
aS'                            const unsigned int component = 0) const override;'
p927
aS'  };'
p928
aS'  template <int dim>'
p929
aS'  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,'
p930
aS'                                       std::vector<double> &          values,'
p931
aS'                                       const unsigned int component) const'
p932
aS'  {'
p933
aS'    (void)component;'
p934
aS'    AssertIndexRange(component, 1);'
p935
aS'    Assert(values.size() == points.size(),'
p936
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p937
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p938
aS'      {'
p939
aS'        if (points[i](0) < 0.5)'
p940
aS'          values[i] = 1.;'
p941
aS'        else'
p942
aS'          values[i] = 0.;'
p943
aS'      }'
p944
aS'  }'
p945
aS'  template <int dim>'
p946
aS'  Tensor<1, dim> beta(const Point<dim> &p)'
p947
aS'  {'
p948
aS'    Assert(dim >= 2, ExcNotImplemented());'
p949
aS'    Tensor<1, dim> wind_field;'
p950
aS'    wind_field[0] = -p[1];'
p951
aS'    wind_field[1] = p[0];'
p952
aS'    wind_field /= wind_field.norm();'
p953
aS'    return wind_field;'
p954
aS'  }'
p955
aS'  template <int dim>'
p956
aS'  class AdvectionProblem'
p957
aS'  {'
p958
aS'  public:'
p959
aS'    AdvectionProblem();'
p960
aS'    void run();'
p961
aS'  private:'
p962
aS'    void setup_system();'
p963
aS'    void assemble_system();'
p964
aS'    void solve(Vector<double> &solution);'
p965
aS'    void refine_grid();'
p966
aS'    void output_results(const unsigned int cycle) const;'
p967
aS'    Triangulation<dim>   triangulation;'
p968
aS'    const MappingQ1<dim> mapping;'
p969
aS'    FE_DGQ<dim>     fe;'
p970
aS'    DoFHandler<dim> dof_handler;'
p971
aS'    SparsityPattern      sparsity_pattern;'
p972
aS'    SparseMatrix<double> system_matrix;'
p973
aS'    Vector<double> solution;'
p974
aS'    Vector<double> right_hand_side;'
p975
aS'    using DoFInfo  = MeshWorker::DoFInfo<dim>;'
p976
aS'    using CellInfo = MeshWorker::IntegrationInfo<dim>;'
p977
aS'    static void integrate_cell_term(DoFInfo &dinfo, CellInfo &info);'
p978
aS'    static void integrate_boundary_term(DoFInfo &dinfo, CellInfo &info);'
p979
aS'    static void integrate_face_term(DoFInfo & dinfo1,'
p980
aS'                                    DoFInfo & dinfo2,'
p981
aS'                                    CellInfo &info1,'
p982
aS'                                    CellInfo &info2);'
p983
aS'  };'
p984
aS'  template <int dim>'
p985
aS'  AdvectionProblem<dim>::AdvectionProblem()'
p986
aS'    : mapping()'
p987
aS'    , fe(1)'
p988
aS'    , dof_handler(triangulation)'
p989
aS'  {}'
p990
aS'  template <int dim>'
p991
aS'  void AdvectionProblem<dim>::setup_system()'
p992
aS'  {'
p993
aS'    dof_handler.distribute_dofs(fe);'
p994
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p995
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p996
aS'    sparsity_pattern.copy_from(dsp);'
p997
aS'    system_matrix.reinit(sparsity_pattern);'
p998
aS'    solution.reinit(dof_handler.n_dofs());'
p999
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p1000
aS'  }'
p1001
aS'  template <int dim>'
p1002
aS'  void AdvectionProblem<dim>::assemble_system()'
p1003
aS'  {'
p1004
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p1005
aS'    const unsigned int n_gauss_points = dof_handler.get_fe().degree + 1;'
p1006
aS'    info_box.initialize_gauss_quadrature(n_gauss_points,'
p1007
aS'                                         n_gauss_points,'
p1008
aS'                                         n_gauss_points);'
p1009
aS'    info_box.initialize_update_flags();'
p1010
aS'    UpdateFlags update_flags ='
p1011
aS'      update_quadrature_points | update_values | update_gradients;'
p1012
aS'    info_box.add_update_flags(update_flags, true, true, true, true);'
p1013
aS'    info_box.initialize(fe, mapping);'
p1014
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p1015
aS'    MeshWorker::Assembler::SystemSimple<SparseMatrix<double>, Vector<double>>'
p1016
aS'      assembler;'
p1017
aS'    assembler.initialize(system_matrix, right_hand_side);'
p1018
aS'    MeshWorker::loop<dim,'
p1019
aS'                     dim,'
p1020
aS'                     MeshWorker::DoFInfo<dim>,'
p1021
aS'                     MeshWorker::IntegrationInfoBox<dim>>('
p1022
aS'      dof_handler.begin_active(),'
p1023
aS'      dof_handler.end(),'
p1024
aS'      dof_info,'
p1025
aS'      info_box,'
p1026
aS'      &AdvectionProblem<dim>::integrate_cell_term,'
p1027
aS'      &AdvectionProblem<dim>::integrate_boundary_term,'
p1028
aS'      &AdvectionProblem<dim>::integrate_face_term,'
p1029
aS'      assembler);'
p1030
aS'  }'
p1031
aS'  template <int dim>'
p1032
aS'  void AdvectionProblem<dim>::integrate_cell_term(DoFInfo & dinfo,'
p1033
aS'                                                  CellInfo &info)'
p1034
aS'  {'
p1035
aS'    const FEValuesBase<dim> &  fe_values    = info.fe_values();'
p1036
aS'    FullMatrix<double> &       local_matrix = dinfo.matrix(0).matrix;'
p1037
aS'    const std::vector<double> &JxW          = fe_values.get_JxW_values();'
p1038
aS'    for (unsigned int point = 0; point < fe_values.n_quadrature_points; ++point)'
p1039
aS'      {'
p1040
aS'        const Tensor<1, dim> beta_at_q_point ='
p1041
aS'          beta(fe_values.quadrature_point(point));'
p1042
aS'        for (unsigned int i = 0; i < fe_values.dofs_per_cell; ++i)'
p1043
aS'          for (unsigned int j = 0; j < fe_values.dofs_per_cell; ++j)'
p1044
aS'            local_matrix(i, j) += -beta_at_q_point *                //'
p1045
aS'                                  fe_values.shape_grad(i, point) *  //'
p1046
aS'                                  fe_values.shape_value(j, point) * //'
p1047
aS'                                  JxW[point];'
p1048
aS'      }'
p1049
aS'  }'
p1050
aS'  template <int dim>'
p1051
aS'  void AdvectionProblem<dim>::integrate_boundary_term(DoFInfo & dinfo,'
p1052
aS'                                                      CellInfo &info)'
p1053
aS'  {'
p1054
aS'    const FEValuesBase<dim> &fe_face_values = info.fe_values();'
p1055
aS'    FullMatrix<double> &     local_matrix   = dinfo.matrix(0).matrix;'
p1056
aS'    Vector<double> &         local_vector   = dinfo.vector(0).block(0);'
p1057
aS'    const std::vector<double> &        JxW = fe_face_values.get_JxW_values();'
p1058
aS'    const std::vector<Tensor<1, dim>> &normals ='
p1059
aS'      fe_face_values.get_normal_vectors();'
p1060
aS'    std::vector<double> g(fe_face_values.n_quadrature_points);'
p1061
aS'    static BoundaryValues<dim> boundary_function;'
p1062
aS'    boundary_function.value_list(fe_face_values.get_quadrature_points(), g);'
p1063
aS'    for (unsigned int point = 0; point < fe_face_values.n_quadrature_points;'
p1064
aS'         ++point)'
p1065
aS'      {'
p1066
aS'        const double beta_dot_n ='
p1067
aS'          beta(fe_face_values.quadrature_point(point)) * normals[point];'
p1068
aS'        if (beta_dot_n > 0)'
p1069
aS'          for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i)'
p1070
aS'            for (unsigned int j = 0; j < fe_face_values.dofs_per_cell; ++j)'
p1071
aS'              local_matrix(i, j) += beta_dot_n *                           //'
p1072
aS'                                    fe_face_values.shape_value(j, point) * //'
p1073
aS'                                    fe_face_values.shape_value(i, point) * //'
p1074
aS'                                    JxW[point];'
p1075
aS'        else'
p1076
aS'          for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i)'
p1077
aS'            local_vector(i) += -beta_dot_n *                          //'
p1078
aS'                               g[point] *                             //'
p1079
aS'                               fe_face_values.shape_value(i, point) * //'
p1080
aS'                               JxW[point];'
p1081
aS'      }'
p1082
aS'  }'
p1083
aS'  template <int dim>'
p1084
aS'  void AdvectionProblem<dim>::integrate_face_term(DoFInfo & dinfo1,'
p1085
aS'                                                  DoFInfo & dinfo2,'
p1086
aS'                                                  CellInfo &info1,'
p1087
aS'                                                  CellInfo &info2)'
p1088
aS'  {'
p1089
aS'    const FEValuesBase<dim> &fe_face_values = info1.fe_values();'
p1090
aS'    const unsigned int       dofs_per_cell  = fe_face_values.dofs_per_cell;'
p1091
aS'    const FEValuesBase<dim> &fe_face_values_neighbor = info2.fe_values();'
p1092
aS'    const unsigned int       neighbor_dofs_per_cell ='
p1093
aS'      fe_face_values_neighbor.dofs_per_cell;'
p1094
aS'    FullMatrix<double> &u1_v1_matrix = dinfo1.matrix(0, false).matrix;'
p1095
aS'    FullMatrix<double> &u2_v1_matrix = dinfo1.matrix(0, true).matrix;'
p1096
aS'    FullMatrix<double> &u1_v2_matrix = dinfo2.matrix(0, true).matrix;'
p1097
aS'    FullMatrix<double> &u2_v2_matrix = dinfo2.matrix(0, false).matrix;'
p1098
aS'    const std::vector<double> &        JxW = fe_face_values.get_JxW_values();'
p1099
aS'    const std::vector<Tensor<1, dim>> &normals ='
p1100
aS'      fe_face_values.get_normal_vectors();'
p1101
aS'    for (unsigned int point = 0; point < fe_face_values.n_quadrature_points;'
p1102
aS'         ++point)'
p1103
aS'      {'
p1104
aS'        const double beta_dot_n ='
p1105
aS'          beta(fe_face_values.quadrature_point(point)) * normals[point];'
p1106
aS'        if (beta_dot_n > 0)'
p1107
aS'          {'
p1108
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1109
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p1110
aS'                u1_v1_matrix(i, j) += beta_dot_n *                           //'
p1111
aS'                                      fe_face_values.shape_value(j, point) * //'
p1112
aS'                                      fe_face_values.shape_value(i, point) * //'
p1113
aS'                                      JxW[point];'
p1114
aS'            for (unsigned int k = 0; k < neighbor_dofs_per_cell; ++k)'
p1115
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p1116
aS'                u1_v2_matrix(k, j) +='
p1117
aS'                  -beta_dot_n *                                   //'
p1118
aS'                  fe_face_values.shape_value(j, point) *          //'
p1119
aS'                  fe_face_values_neighbor.shape_value(k, point) * //'
p1120
aS'                  JxW[point];'
p1121
aS'          }'
p1122
aS'        else'
p1123
aS'          {'
p1124
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1125
aS'              for (unsigned int l = 0; l < neighbor_dofs_per_cell; ++l)'
p1126
aS'                u2_v1_matrix(i, l) +='
p1127
aS'                  beta_dot_n *                                    //'
p1128
aS'                  fe_face_values_neighbor.shape_value(l, point) * //'
p1129
aS'                  fe_face_values.shape_value(i, point) *          //'
p1130
aS'                  JxW[point];'
p1131
aS'            for (unsigned int k = 0; k < neighbor_dofs_per_cell; ++k)'
p1132
aS'              for (unsigned int l = 0; l < neighbor_dofs_per_cell; ++l)'
p1133
aS'                u2_v2_matrix(k, l) +='
p1134
aS'                  -beta_dot_n *                                   //'
p1135
aS'                  fe_face_values_neighbor.shape_value(l, point) * //'
p1136
aS'                  fe_face_values_neighbor.shape_value(k, point) * //'
p1137
aS'                  JxW[point];'
p1138
aS'          }'
p1139
aS'      }'
p1140
aS'  }'
p1141
aS'  template <int dim>'
p1142
aS'  void AdvectionProblem<dim>::solve(Vector<double> &solution)'
p1143
aS'  {'
p1144
aS'    SolverControl                    solver_control(1000, 1e-12);'
p1145
aS'    SolverRichardson<Vector<double>> solver(solver_control);'
p1146
aS'    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;'
p1147
aS'    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());'
p1148
aS'    solver.solve(system_matrix, solution, right_hand_side, preconditioner);'
p1149
aS'  }'
p1150
aS'  template <int dim>'
p1151
aS'  void AdvectionProblem<dim>::refine_grid()'
p1152
aS'  {'
p1153
aS'    Vector<float> gradient_indicator(triangulation.n_active_cells());'
p1154
aS'    DerivativeApproximation::approximate_gradient(mapping,'
p1155
aS'                                                  dof_handler,'
p1156
aS'                                                  solution,'
p1157
aS'                                                  gradient_indicator);'
p1158
aS'    unsigned int cell_no = 0;'
p1159
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p1160
aS'      gradient_indicator(cell_no++) *='
p1161
aS'        std::pow(cell->diameter(), 1 + 1.0 * dim / 2);'
p1162
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p1163
aS'                                                    gradient_indicator,'
p1164
aS'                                                    0.3,'
p1165
aS'                                                    0.1);'
p1166
aS'    triangulation.execute_coarsening_and_refinement();'
p1167
aS'  }'
p1168
aS'  template <int dim>'
p1169
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p1170
aS'  {'
p1171
aS'    {'
p1172
aS'      const std::string filename = "grid-" + std::to_string(cycle) + ".eps";'
p1173
aS'      deallog << "Writing grid to <" << filename << ">" << std::endl;'
p1174
aS'      std::ofstream eps_output(filename);'
p1175
aS'      GridOut grid_out;'
p1176
aS'      grid_out.write_eps(triangulation, eps_output);'
p1177
aS'    }'
p1178
aS'    {'
p1179
aS'      const std::string filename = "sol-" + std::to_string(cycle) + ".gnuplot";'
p1180
aS'      deallog << "Writing solution to <" << filename << ">" << std::endl;'
p1181
aS'      std::ofstream gnuplot_output(filename);'
p1182
aS'      DataOut<dim> data_out;'
p1183
aS'      data_out.attach_dof_handler(dof_handler);'
p1184
aS'      data_out.add_data_vector(solution, "u");'
p1185
aS'      data_out.build_patches();'
p1186
aS'      data_out.write_gnuplot(gnuplot_output);'
p1187
aS'    }'
p1188
aS'  }'
p1189
aS'  template <int dim>'
p1190
aS'  void AdvectionProblem<dim>::run()'
p1191
aS'  {'
p1192
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p1193
aS'      {'
p1194
aS'        deallog << "Cycle " << cycle << std::endl;'
p1195
aS'        if (cycle == 0)'
p1196
aS'          {'
p1197
aS'            GridGenerator::hyper_cube(triangulation);'
p1198
aS'            triangulation.refine_global(3);'
p1199
aS'          }'
p1200
aS'        else'
p1201
aS'          refine_grid();'
p1202
aS'        deallog << "Number of active cells:       "'
p1203
aS'                << triangulation.n_active_cells() << std::endl;'
p1204
aS'        setup_system();'
p1205
aS'        deallog << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p1206
aS'                << std::endl;'
p1207
aS'        assemble_system();'
p1208
aS'        solve(solution);'
p1209
aS'        output_results(cycle);'
p1210
aS'      }'
p1211
aS'  }'
p1212
aS'} // namespace Step12'
p1213
aS'int main()'
p1214
ag24
aS'  try'
p1215
aS'    {'
p1216
aS'      dealii::deallog.depth_console(5);'
p1217
aS'      Step12::AdvectionProblem<2> dgmethod;'
p1218
aS'      dgmethod.run();'
p1219
aS'    }'
p1220
aS'  catch (std::exception &exc)'
p1221
aS'    {'
p1222
aS'      std::cerr << std::endl'
p1223
aS'                << std::endl'
p1224
aS'                << "----------------------------------------------------"'
p1225
aS'                << std::endl;'
p1226
aS'      std::cerr << "Exception on processing: " << std::endl'
p1227
aS'                << exc.what() << std::endl'
p1228
aS'                << "Aborting!" << std::endl'
p1229
aS'                << "----------------------------------------------------"'
p1230
aS'                << std::endl;'
p1231
aS'      return 1;'
p1232
aS'    }'
p1233
aS'  catch (...)'
p1234
aS'    {'
p1235
aS'      std::cerr << std::endl'
p1236
aS'                << std::endl'
p1237
aS'                << "----------------------------------------------------"'
p1238
aS'                << std::endl;'
p1239
aS'      std::cerr << "Unknown exception!" << std::endl'
p1240
aS'                << "Aborting!" << std::endl'
p1241
aS'                << "----------------------------------------------------"'
p1242
aS'                << std::endl;'
p1243
aS'      return 1;'
p1244
aS'    }'
p1245
aS'  return 0;'
p1246
ag32
aS'/* ---------------------------------------------------------------------'
p1247
aS' *'
p1248
aS' * Copyright (C) 2001 - 2021 by the deal.II authors'
p1249
aS' *'
p1250
aS' * This file is part of the deal.II library.'
p1251
aS' *'
p1252
aS' * The deal.II library is free software; you can use it, redistribute'
p1253
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p1254
aS' * Public License as published by the Free Software Foundation; either'
p1255
aS' * version 2.1 of the License, or (at your option) any later version.'
p1256
aS' * The full text of the license can be found in the file LICENSE.md at'
p1257
aS' * the top level directory of deal.II.'
p1258
aS' *'
p1259
aS' * ---------------------------------------------------------------------'
p1260
aS' *'
p1261
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002'
p1262
aS' */'
p1263
aS'#include <deal.II/base/quadrature_lib.h>'
p1264
aS'#include <deal.II/base/function.h>'
p1265
aS'#include <deal.II/base/logstream.h>'
p1266
aS'#include <deal.II/base/table_handler.h>'
p1267
aS'#include <deal.II/base/thread_management.h>'
p1268
aS'#include <deal.II/base/work_stream.h>'
p1269
aS'#include <deal.II/lac/vector.h>'
p1270
aS'#include <deal.II/lac/full_matrix.h>'
p1271
aS'#include <deal.II/lac/sparse_matrix.h>'
p1272
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p1273
aS'#include <deal.II/lac/solver_cg.h>'
p1274
aS'#include <deal.II/lac/precondition.h>'
p1275
aS'#include <deal.II/lac/affine_constraints.h>'
p1276
aS'#include <deal.II/grid/tria.h>'
p1277
aS'#include <deal.II/grid/grid_generator.h>'
p1278
aS'#include <deal.II/grid/grid_refinement.h>'
p1279
aS'#include <deal.II/dofs/dof_handler.h>'
p1280
aS'#include <deal.II/dofs/dof_tools.h>'
p1281
aS'#include <deal.II/fe/fe_q.h>'
p1282
aS'#include <deal.II/fe/fe_values.h>'
p1283
aS'#include <deal.II/numerics/vector_tools.h>'
p1284
aS'#include <deal.II/numerics/matrix_tools.h>'
p1285
aS'#include <deal.II/numerics/data_out.h>'
p1286
aS'#include <deal.II/numerics/error_estimator.h>'
p1287
aS'#include <iostream>'
p1288
aS'#include <fstream>'
p1289
aS'#include <list>'
p1290
aS'namespace Step13'
p1291
ag24
aS'  using namespace dealii;'
p1292
aS'  namespace Evaluation'
p1293
aS'  {'
p1294
aS'    template <int dim>'
p1295
aS'    class EvaluationBase'
p1296
aS'    {'
p1297
aS'    public:'
p1298
aS'      virtual ~EvaluationBase() = default;'
p1299
aS'      void set_refinement_cycle(const unsigned int refinement_cycle);'
p1300
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1301
aS'                              const Vector<double> & solution) const = 0;'
p1302
aS'    protected:'
p1303
aS'      unsigned int refinement_cycle;'
p1304
aS'    };'
p1305
aS'    template <int dim>'
p1306
aS'    void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)'
p1307
aS'    {'
p1308
aS'      refinement_cycle = step;'
p1309
aS'    }'
p1310
aS'    template <int dim>'
p1311
aS'    class PointValueEvaluation : public EvaluationBase<dim>'
p1312
aS'    {'
p1313
aS'    public:'
p1314
aS'      PointValueEvaluation(const Point<dim> &evaluation_point,'
p1315
aS'                           TableHandler &    results_table);'
p1316
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1317
aS'                              const Vector<double> & solution) const override;'
p1318
aS'      DeclException1('
p1319
aS'        ExcEvaluationPointNotFound,'
p1320
aS'        Point<dim>,'
p1321
aS'        << "The evaluation point " << arg1'
p1322
aS'        << " was not found among the vertices of the present grid.");'
p1323
aS'    private:'
p1324
aS'      const Point<dim> evaluation_point;'
p1325
aS'      TableHandler &   results_table;'
p1326
aS'    };'
p1327
aS'    template <int dim>'
p1328
aS'    PointValueEvaluation<dim>::PointValueEvaluation('
p1329
aS'      const Point<dim> &evaluation_point,'
p1330
aS'      TableHandler &    results_table)'
p1331
aS'      : evaluation_point(evaluation_point)'
p1332
aS'      , results_table(results_table)'
p1333
aS'    {}'
p1334
aS'    template <int dim>'
p1335
aS'    void PointValueEvaluation<dim>::'
p1336
aS'         operator()(const DoFHandler<dim> &dof_handler,'
p1337
aS'               const Vector<double> & solution) const'
p1338
aS'    {'
p1339
aS'      double point_value = 1e20;'
p1340
aS'      bool evaluation_point_found = false;'
p1341
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p1342
aS'        if (!evaluation_point_found)'
p1343
aS'          for (const auto vertex : cell->vertex_indices())'
p1344
aS'            if (cell->vertex(vertex) == evaluation_point)'
p1345
aS'              {'
p1346
aS'                point_value = solution(cell->vertex_dof_index(vertex, 0));'
p1347
aS'                evaluation_point_found = true;'
p1348
aS'                break;'
p1349
aS'              };'
p1350
aS'      AssertThrow(evaluation_point_found,'
p1351
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p1352
aS'      results_table.add_value("DoFs", dof_handler.n_dofs());'
p1353
aS'      results_table.add_value("u(x_0)", point_value);'
p1354
aS'    }'
p1355
aS'    template <int dim>'
p1356
aS'    class SolutionOutput : public EvaluationBase<dim>'
p1357
aS'    {'
p1358
aS'    public:'
p1359
aS'      SolutionOutput(const std::string &             output_name_base,'
p1360
aS'                     const DataOutBase::OutputFormat output_format);'
p1361
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1362
aS'                              const Vector<double> & solution) const override;'
p1363
aS'    private:'
p1364
aS'      const std::string               output_name_base;'
p1365
aS'      const DataOutBase::OutputFormat output_format;'
p1366
aS'    };'
p1367
aS'    template <int dim>'
p1368
aS'    SolutionOutput<dim>::SolutionOutput('
p1369
aS'      const std::string &             output_name_base,'
p1370
aS'      const DataOutBase::OutputFormat output_format)'
p1371
aS'      : output_name_base(output_name_base)'
p1372
aS'      , output_format(output_format)'
p1373
aS'    {}'
p1374
aS'    template <int dim>'
p1375
aS'    void SolutionOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,'
p1376
aS'                                         const Vector<double> & solution) const'
p1377
aS'    {'
p1378
aS'      DataOut<dim> data_out;'
p1379
aS'      data_out.attach_dof_handler(dof_handler);'
p1380
aS'      data_out.add_data_vector(solution, "solution");'
p1381
aS'      data_out.build_patches();'
p1382
aS'      std::ofstream out(output_name_base + "-" +'
p1383
aS'                        std::to_string(this->refinement_cycle) +'
p1384
aS'                        data_out.default_suffix(output_format));'
p1385
aS'      data_out.write(out, output_format);'
p1386
aS'    }'
p1387
aS'  } // namespace Evaluation'
p1388
aS'  namespace LaplaceSolver'
p1389
aS'  {'
p1390
aS'    template <int dim>'
p1391
aS'    class Base'
p1392
aS'    {'
p1393
aS'    public:'
p1394
aS'      Base(Triangulation<dim> &coarse_grid);'
p1395
aS'      virtual ~Base() = default;'
p1396
aS'      virtual void solve_problem() = 0;'
p1397
aS'      virtual void postprocess('
p1398
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;'
p1399
aS'      virtual void         refine_grid()                            = 0;'
p1400
aS'      virtual unsigned int n_dofs() const                           = 0;'
p1401
aS'    protected:'
p1402
aS'      const SmartPointer<Triangulation<dim>> triangulation;'
p1403
aS'    };'
p1404
aS'    template <int dim>'
p1405
aS'    Base<dim>::Base(Triangulation<dim> &coarse_grid)'
p1406
aS'      : triangulation(&coarse_grid)'
p1407
aS'    {}'
p1408
aS'    template <int dim>'
p1409
aS'    class Solver : public virtual Base<dim>'
p1410
aS'    {'
p1411
aS'    public:'
p1412
aS'      Solver(Triangulation<dim> &      triangulation,'
p1413
aS'             const FiniteElement<dim> &fe,'
p1414
aS'             const Quadrature<dim> &   quadrature,'
p1415
aS'             const Function<dim> &     boundary_values);'
p1416
aS'      virtual ~Solver() override;'
p1417
aS'      virtual void solve_problem() override;'
p1418
aS'      virtual void postprocess('
p1419
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const override;'
p1420
aS'      virtual unsigned int n_dofs() const override;'
p1421
aS'    protected:'
p1422
aS'      const SmartPointer<const FiniteElement<dim>> fe;'
p1423
aS'      const SmartPointer<const Quadrature<dim>>    quadrature;'
p1424
aS'      DoFHandler<dim>                              dof_handler;'
p1425
aS'      Vector<double>                               solution;'
p1426
aS'      const SmartPointer<const Function<dim>>      boundary_values;'
p1427
aS'      virtual void assemble_rhs(Vector<double> &rhs) const = 0;'
p1428
aS'    private:'
p1429
aS'      struct LinearSystem'
p1430
aS'      {'
p1431
aS'        LinearSystem(const DoFHandler<dim> &dof_handler);'
p1432
aS'        void solve(Vector<double> &solution) const;'
p1433
aS'        AffineConstraints<double> hanging_node_constraints;'
p1434
aS'        SparsityPattern           sparsity_pattern;'
p1435
aS'        SparseMatrix<double>      matrix;'
p1436
aS'        Vector<double>            rhs;'
p1437
aS'      };'
p1438
aS'      struct AssemblyScratchData'
p1439
aS'      {'
p1440
aS'        AssemblyScratchData(const FiniteElement<dim> &fe,'
p1441
aS'                            const Quadrature<dim> &   quadrature);'
p1442
aS'        AssemblyScratchData(const AssemblyScratchData &scratch_data);'
p1443
aS'        FEValues<dim> fe_values;'
p1444
aS'      };'
p1445
aS'      struct AssemblyCopyData'
p1446
aS'      {'
p1447
aS'        FullMatrix<double>                   cell_matrix;'
p1448
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p1449
aS'      };'
p1450
aS'      void assemble_linear_system(LinearSystem &linear_system);'
p1451
aS'      void local_assemble_matrix('
p1452
aS'        const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1453
aS'        AssemblyScratchData &                                 scratch_data,'
p1454
aS'        AssemblyCopyData &                                    copy_data) const;'
p1455
aS'      void copy_local_to_global(const AssemblyCopyData &copy_data,'
p1456
aS'                                LinearSystem &          linear_system) const;'
p1457
aS'    };'
p1458
aS'    template <int dim>'
p1459
aS'    Solver<dim>::Solver(Triangulation<dim> &      triangulation,'
p1460
aS'                        const FiniteElement<dim> &fe,'
p1461
aS'                        const Quadrature<dim> &   quadrature,'
p1462
aS'                        const Function<dim> &     boundary_values)'
p1463
aS'      : Base<dim>(triangulation)'
p1464
aS'      , fe(&fe)'
p1465
aS'      , quadrature(&quadrature)'
p1466
aS'      , dof_handler(triangulation)'
p1467
aS'      , boundary_values(&boundary_values)'
p1468
aS'    {}'
p1469
aS'    template <int dim>'
p1470
aS'    Solver<dim>::~Solver()'
p1471
aS'    {'
p1472
aS'      dof_handler.clear();'
p1473
aS'    }'
p1474
aS'    template <int dim>'
p1475
aS'    void Solver<dim>::solve_problem()'
p1476
aS'    {'
p1477
aS'      dof_handler.distribute_dofs(*fe);'
p1478
aS'      solution.reinit(dof_handler.n_dofs());'
p1479
aS'      LinearSystem linear_system(dof_handler);'
p1480
aS'      assemble_linear_system(linear_system);'
p1481
aS'      linear_system.solve(solution);'
p1482
aS'    }'
p1483
aS'    template <int dim>'
p1484
aS'    void Solver<dim>::postprocess('
p1485
aS'      const Evaluation::EvaluationBase<dim> &postprocessor) const'
p1486
aS'    {'
p1487
aS'      postprocessor(dof_handler, solution);'
p1488
aS'    }'
p1489
aS'    template <int dim>'
p1490
aS'    unsigned int Solver<dim>::n_dofs() const'
p1491
aS'    {'
p1492
aS'      return dof_handler.n_dofs();'
p1493
aS'    }'
p1494
aS'    template <int dim>'
p1495
aS'    void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)'
p1496
aS'    {'
p1497
aS'      Threads::Task<void> rhs_task ='
p1498
aS'        Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);'
p1499
aS'      auto worker ='
p1500
aS'        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1501
aS'               AssemblyScratchData &scratch_data,'
p1502
aS'               AssemblyCopyData &   copy_data) {'
p1503
aS'          this->local_assemble_matrix(cell, scratch_data, copy_data);'
p1504
aS'        };'
p1505
aS'      auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {'
p1506
aS'        this->copy_local_to_global(copy_data, linear_system);'
p1507
aS'      };'
p1508
aS'      WorkStream::run(dof_handler.begin_active(),'
p1509
aS'                      dof_handler.end(),'
p1510
aS'                      worker,'
p1511
aS'                      copier,'
p1512
aS'                      AssemblyScratchData(*fe, *quadrature),'
p1513
aS'                      AssemblyCopyData());'
p1514
aS'      linear_system.hanging_node_constraints.condense(linear_system.matrix);'
p1515
aS'      std::map<types::global_dof_index, double> boundary_value_map;'
p1516
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p1517
aS'                                               0,'
p1518
aS'                                               *boundary_values,'
p1519
aS'                                               boundary_value_map);'
p1520
aS'      rhs_task.join();'
p1521
aS'      linear_system.hanging_node_constraints.condense(linear_system.rhs);'
p1522
aS'      MatrixTools::apply_boundary_values(boundary_value_map,'
p1523
aS'                                         linear_system.matrix,'
p1524
aS'                                         solution,'
p1525
aS'                                         linear_system.rhs);'
p1526
aS'    }'
p1527
aS'    template <int dim>'
p1528
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p1529
aS'      const FiniteElement<dim> &fe,'
p1530
aS'      const Quadrature<dim> &   quadrature)'
p1531
aS'      : fe_values(fe, quadrature, update_gradients | update_JxW_values)'
p1532
aS'    {}'
p1533
aS'    template <int dim>'
p1534
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p1535
aS'      const AssemblyScratchData &scratch_data)'
p1536
aS'      : fe_values(scratch_data.fe_values.get_fe(),'
p1537
aS'                  scratch_data.fe_values.get_quadrature(),'
p1538
aS'                  update_gradients | update_JxW_values)'
p1539
aS'    {}'
p1540
aS'    template <int dim>'
p1541
aS'    void Solver<dim>::local_assemble_matrix('
p1542
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1543
aS'      AssemblyScratchData &                                 scratch_data,'
p1544
aS'      AssemblyCopyData &                                    copy_data) const'
p1545
aS'    {'
p1546
aS'      const unsigned int dofs_per_cell = fe->n_dofs_per_cell();'
p1547
aS'      const unsigned int n_q_points    = quadrature->size();'
p1548
aS'      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p1549
aS'      copy_data.local_dof_indices.resize(dofs_per_cell);'
p1550
aS'      scratch_data.fe_values.reinit(cell);'
p1551
aS'      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p1552
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1553
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p1554
aS'            copy_data.cell_matrix(i, j) +='
p1555
aS'              (scratch_data.fe_values.shape_grad(i, q_point) *'
p1556
aS'               scratch_data.fe_values.shape_grad(j, q_point) *'
p1557
aS'               scratch_data.fe_values.JxW(q_point));'
p1558
aS'      cell->get_dof_indices(copy_data.local_dof_indices);'
p1559
aS'    }'
p1560
aS'    template <int dim>'
p1561
aS'    void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,'
p1562
aS'                                           LinearSystem &linear_system) const'
p1563
aS'    {'
p1564
aS'      for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)'
p1565
aS'        for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)'
p1566
aS'          linear_system.matrix.add(copy_data.local_dof_indices[i],'
p1567
aS'                                   copy_data.local_dof_indices[j],'
p1568
aS'                                   copy_data.cell_matrix(i, j));'
p1569
aS'    }'
p1570
aS'    template <int dim>'
p1571
aS'    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)'
p1572
aS'    {'
p1573
aS'      hanging_node_constraints.clear();'
p1574
aS'      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) ='
p1575
aS'        &DoFTools::make_hanging_node_constraints;'
p1576
aS'      Threads::Task<void> side_task ='
p1577
aS'        Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);'
p1578
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p1579
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p1580
aS'      side_task.join();'
p1581
aS'      hanging_node_constraints.close();'
p1582
aS'      hanging_node_constraints.condense(dsp);'
p1583
aS'      sparsity_pattern.copy_from(dsp);'
p1584
aS'      matrix.reinit(sparsity_pattern);'
p1585
aS'      rhs.reinit(dof_handler.n_dofs());'
p1586
aS'    }'
p1587
aS'    template <int dim>'
p1588
aS'    void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const'
p1589
aS'    {'
p1590
aS'      SolverControl            solver_control(1000, 1e-12);'
p1591
aS'      SolverCG<Vector<double>> cg(solver_control);'
p1592
aS'      PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p1593
aS'      preconditioner.initialize(matrix, 1.2);'
p1594
aS'      cg.solve(matrix, solution, rhs, preconditioner);'
p1595
aS'      hanging_node_constraints.distribute(solution);'
p1596
aS'    }'
p1597
aS'    template <int dim>'
p1598
aS'    class PrimalSolver : public Solver<dim>'
p1599
aS'    {'
p1600
aS'    public:'
p1601
aS'      PrimalSolver(Triangulation<dim> &      triangulation,'
p1602
aS'                   const FiniteElement<dim> &fe,'
p1603
aS'                   const Quadrature<dim> &   quadrature,'
p1604
aS'                   const Function<dim> &     rhs_function,'
p1605
aS'                   const Function<dim> &     boundary_values);'
p1606
aS'    protected:'
p1607
aS'      const SmartPointer<const Function<dim>> rhs_function;'
p1608
aS'      virtual void assemble_rhs(Vector<double> &rhs) const override;'
p1609
aS'    };'
p1610
aS'    template <int dim>'
p1611
aS'    PrimalSolver<dim>::PrimalSolver(Triangulation<dim> &      triangulation,'
p1612
aS'                                    const FiniteElement<dim> &fe,'
p1613
aS'                                    const Quadrature<dim> &   quadrature,'
p1614
aS'                                    const Function<dim> &     rhs_function,'
p1615
aS'                                    const Function<dim> &     boundary_values)'
p1616
aS'      : Base<dim>(triangulation)'
p1617
aS'      , Solver<dim>(triangulation, fe, quadrature, boundary_values)'
p1618
aS'      , rhs_function(&rhs_function)'
p1619
aS'    {}'
p1620
aS'    template <int dim>'
p1621
aS'    void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const'
p1622
aS'    {'
p1623
aS'      FEValues<dim> fe_values(*this->fe,'
p1624
aS'                              *this->quadrature,'
p1625
aS'                              update_values | update_quadrature_points |'
p1626
aS'                                update_JxW_values);'
p1627
aS'      const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();'
p1628
aS'      const unsigned int n_q_points    = this->quadrature->size();'
p1629
aS'      Vector<double>                       cell_rhs(dofs_per_cell);'
p1630
aS'      std::vector<double>                  rhs_values(n_q_points);'
p1631
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p1632
aS'      for (const auto &cell : this->dof_handler.active_cell_iterators())'
p1633
aS'        {'
p1634
aS'          cell_rhs = 0;'
p1635
aS'          fe_values.reinit(cell);'
p1636
aS'          rhs_function->value_list(fe_values.get_quadrature_points(),'
p1637
aS'                                   rhs_values);'
p1638
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p1639
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1640
aS'              cell_rhs(i) += fe_values.shape_value(i, q_point) * //'
p1641
aS'                             rhs_values[q_point] *               //'
p1642
aS'                             fe_values.JxW(q_point);'
p1643
aS'          cell->get_dof_indices(local_dof_indices);'
p1644
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1645
aS'            rhs(local_dof_indices[i]) += cell_rhs(i);'
p1646
aS'        };'
p1647
aS'    }'
p1648
aS'    template <int dim>'
p1649
aS'    class RefinementGlobal : public PrimalSolver<dim>'
p1650
aS'    {'
p1651
aS'    public:'
p1652
aS'      RefinementGlobal(Triangulation<dim> &      coarse_grid,'
p1653
aS'                       const FiniteElement<dim> &fe,'
p1654
aS'                       const Quadrature<dim> &   quadrature,'
p1655
aS'                       const Function<dim> &     rhs_function,'
p1656
aS'                       const Function<dim> &     boundary_values);'
p1657
aS'      virtual void refine_grid() override;'
p1658
aS'    };'
p1659
aS'    template <int dim>'
p1660
aS'    RefinementGlobal<dim>::RefinementGlobal('
p1661
aS'      Triangulation<dim> &      coarse_grid,'
p1662
aS'      const FiniteElement<dim> &fe,'
p1663
aS'      const Quadrature<dim> &   quadrature,'
p1664
aS'      const Function<dim> &     rhs_function,'
p1665
aS'      const Function<dim> &     boundary_values)'
p1666
aS'      : Base<dim>(coarse_grid)'
p1667
aS'      , PrimalSolver<dim>(coarse_grid,'
p1668
aS'                          fe,'
p1669
aS'                          quadrature,'
p1670
aS'                          rhs_function,'
p1671
aS'                          boundary_values)'
p1672
aS'    {}'
p1673
aS'    template <int dim>'
p1674
aS'    void RefinementGlobal<dim>::refine_grid()'
p1675
aS'    {'
p1676
aS'      this->triangulation->refine_global(1);'
p1677
aS'    }'
p1678
aS'    template <int dim>'
p1679
aS'    class RefinementKelly : public PrimalSolver<dim>'
p1680
aS'    {'
p1681
aS'    public:'
p1682
aS'      RefinementKelly(Triangulation<dim> &      coarse_grid,'
p1683
aS'                      const FiniteElement<dim> &fe,'
p1684
aS'                      const Quadrature<dim> &   quadrature,'
p1685
aS'                      const Function<dim> &     rhs_function,'
p1686
aS'                      const Function<dim> &     boundary_values);'
p1687
aS'      virtual void refine_grid() override;'
p1688
aS'    };'
p1689
aS'    template <int dim>'
p1690
aS'    RefinementKelly<dim>::RefinementKelly(Triangulation<dim> &      coarse_grid,'
p1691
aS'                                          const FiniteElement<dim> &fe,'
p1692
aS'                                          const Quadrature<dim> &   quadrature,'
p1693
aS'                                          const Function<dim> &rhs_function,'
p1694
aS'                                          const Function<dim> &boundary_values)'
p1695
aS'      : Base<dim>(coarse_grid)'
p1696
aS'      , PrimalSolver<dim>(coarse_grid,'
p1697
aS'                          fe,'
p1698
aS'                          quadrature,'
p1699
aS'                          rhs_function,'
p1700
aS'                          boundary_values)'
p1701
aS'    {}'
p1702
aS'    template <int dim>'
p1703
aS'    void RefinementKelly<dim>::refine_grid()'
p1704
aS'    {'
p1705
aS'      Vector<float> estimated_error_per_cell('
p1706
aS'        this->triangulation->n_active_cells());'
p1707
aS'      KellyErrorEstimator<dim>::estimate('
p1708
aS'        this->dof_handler,'
p1709
aS'        QGauss<dim - 1>(this->fe->degree + 1),'
p1710
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p1711
aS'        this->solution,'
p1712
aS'        estimated_error_per_cell);'
p1713
aS'      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,'
p1714
aS'                                                      estimated_error_per_cell,'
p1715
aS'                                                      0.3,'
p1716
aS'                                                      0.03);'
p1717
aS'      this->triangulation->execute_coarsening_and_refinement();'
p1718
aS'    }'
p1719
aS'  } // namespace LaplaceSolver'
p1720
aS'  template <int dim>'
p1721
aS'  class Solution : public Function<dim>'
p1722
aS'  {'
p1723
aS'  public:'
p1724
aS'    virtual double value(const Point<dim> & p,'
p1725
aS'                         const unsigned int component) const override;'
p1726
aS'  };'
p1727
aS'  template <int dim>'
p1728
aS'  double Solution<dim>::value(const Point<dim> & p,'
p1729
aS'                              const unsigned int component) const'
p1730
aS'  {'
p1731
aS'    (void)component;'
p1732
aS'    AssertIndexRange(component, 1);'
p1733
aS'    double q = p(0);'
p1734
aS'    for (unsigned int i = 1; i < dim; ++i)'
p1735
aS'      q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p1736
aS'    const double exponential = std::exp(q);'
p1737
aS'    return exponential;'
p1738
aS'  }'
p1739
aS'  template <int dim>'
p1740
aS'  class RightHandSide : public Function<dim>'
p1741
aS'  {'
p1742
aS'  public:'
p1743
aS'    virtual double value(const Point<dim> & p,'
p1744
aS'                         const unsigned int component) const override;'
p1745
aS'  };'
p1746
aS'  template <int dim>'
p1747
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p1748
aS'                                   const unsigned int component) const'
p1749
aS'  {'
p1750
aS'    (void)component;'
p1751
aS'    AssertIndexRange(component, 1);'
p1752
aS'    double q = p(0);'
p1753
aS'    for (unsigned int i = 1; i < dim; ++i)'
p1754
aS'      q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p1755
aS'    const double u  = std::exp(q);'
p1756
aS'    double       t1 = 1, t2 = 0, t3 = 0;'
p1757
aS'    for (unsigned int i = 1; i < dim; ++i)'
p1758
aS'      {'
p1759
aS'        t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);'
p1760
aS'        t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p1761
aS'              100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);'
p1762
aS'        t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) *'
p1763
aS'                std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p1764
aS'              100 * std::sin(10 * p(i) + 5 * p(0) * p(0));'
p1765
aS'      };'
p1766
aS'    t1 = t1 * t1;'
p1767
aS'    return -u * (t1 + t2 + t3);'
p1768
aS'  }'
p1769
aS'  template <int dim>'
p1770
aS'  void run_simulation('
p1771
aS'    LaplaceSolver::Base<dim> &                          solver,'
p1772
aS'    const std::list<Evaluation::EvaluationBase<dim> *> &postprocessor_list)'
p1773
aS'  {'
p1774
aS'    std::cout << "Refinement cycle: ";'
p1775
aS'    for (unsigned int step = 0; true; ++step)'
p1776
aS'      {'
p1777
aS'        std::cout << step << " " << std::flush;'
p1778
aS'        solver.solve_problem();'
p1779
aS'        for (const auto &postprocessor : postprocessor_list)'
p1780
aS'          {'
p1781
aS'            postprocessor->set_refinement_cycle(step);'
p1782
aS'            solver.postprocess(*postprocessor);'
p1783
aS'          };'
p1784
aS'        if (solver.n_dofs() < 20000)'
p1785
aS'          solver.refine_grid();'
p1786
aS'        else'
p1787
aS'          break;'
p1788
aS'      };'
p1789
aS'    std::cout << std::endl;'
p1790
aS'  }'
p1791
aS'  template <int dim>'
p1792
aS'  void solve_problem(const std::string &solver_name)'
p1793
aS'  {'
p1794
aS'    const std::string header ='
p1795
aS'      "Running tests with \\"" + solver_name + "\\" refinement criterion:";'
p1796
aS'    std::cout << header << std::endl'
p1797
aS"              << std::string(header.size(), '-') << std::endl;"
p1798
aS'    Triangulation<dim> triangulation;'
p1799
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p1800
aS'    triangulation.refine_global(2);'
p1801
aS'    const FE_Q<dim>    fe(1);'
p1802
aS'    const QGauss<dim>  quadrature(4);'
p1803
aS'    RightHandSide<dim> rhs_function;'
p1804
aS'    Solution<dim>      boundary_values;'
p1805
aS'    std::unique_ptr<LaplaceSolver::Base<dim>> solver;'
p1806
aS'    if (solver_name == "global")'
p1807
aS'      solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>('
p1808
aS'        triangulation, fe, quadrature, rhs_function, boundary_values);'
p1809
aS'    else if (solver_name == "kelly")'
p1810
aS'      solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>('
p1811
aS'        triangulation, fe, quadrature, rhs_function, boundary_values);'
p1812
aS'    else'
p1813
aS'      AssertThrow(false, ExcNotImplemented());'
p1814
aS'    TableHandler                          results_table;'
p1815
aS'    Evaluation::PointValueEvaluation<dim> postprocessor1(Point<dim>(0.5, 0.5),'
p1816
aS'                                                         results_table);'
p1817
aS'    Evaluation::SolutionOutput<dim> postprocessor2(std::string("solution-") +'
p1818
aS'                                                     solver_name,'
p1819
aS'                                                   DataOutBase::gnuplot);'
p1820
aS'    std::list<Evaluation::EvaluationBase<dim> *> postprocessor_list;'
p1821
aS'    postprocessor_list.push_back(&postprocessor1);'
p1822
aS'    postprocessor_list.push_back(&postprocessor2);'
p1823
aS'    run_simulation(*solver, postprocessor_list);'
p1824
aS'    results_table.write_text(std::cout);'
p1825
aS'    std::cout << std::endl;'
p1826
aS'  }'
p1827
aS'} // namespace Step13'
p1828
aS'int main()'
p1829
ag24
aS'  try'
p1830
aS'    {'
p1831
aS'      Step13::solve_problem<2>("global");'
p1832
aS'      Step13::solve_problem<2>("kelly");'
p1833
aS'    }'
p1834
aS'  catch (std::exception &exc)'
p1835
aS'    {'
p1836
aS'      std::cerr << std::endl'
p1837
aS'                << std::endl'
p1838
aS'                << "----------------------------------------------------"'
p1839
aS'                << std::endl;'
p1840
aS'      std::cerr << "Exception on processing: " << std::endl'
p1841
aS'                << exc.what() << std::endl'
p1842
aS'                << "Aborting!" << std::endl'
p1843
aS'                << "----------------------------------------------------"'
p1844
aS'                << std::endl;'
p1845
aS'      return 1;'
p1846
aS'    }'
p1847
aS'  catch (...)'
p1848
aS'    {'
p1849
aS'      std::cerr << std::endl'
p1850
aS'                << std::endl'
p1851
aS'                << "----------------------------------------------------"'
p1852
aS'                << std::endl;'
p1853
aS'      std::cerr << "Unknown exception!" << std::endl'
p1854
aS'                << "Aborting!" << std::endl'
p1855
aS'                << "----------------------------------------------------"'
p1856
aS'                << std::endl;'
p1857
aS'      return 1;'
p1858
aS'    };'
p1859
aS'  return 0;'
p1860
ag32
aS'/* ---------------------------------------------------------------------'
p1861
aS' *'
p1862
aS' * Copyright (C) 2002 - 2021 by the deal.II authors'
p1863
aS' *'
p1864
aS' * This file is part of the deal.II library.'
p1865
aS' *'
p1866
aS' * The deal.II library is free software; you can use it, redistribute'
p1867
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p1868
aS' * Public License as published by the Free Software Foundation; either'
p1869
aS' * version 2.1 of the License, or (at your option) any later version.'
p1870
aS' * The full text of the license can be found in the file LICENSE.md at'
p1871
aS' * the top level directory of deal.II.'
p1872
aS' *'
p1873
aS' * ---------------------------------------------------------------------'
p1874
aS' *'
p1875
aS' * Author: Wolfgang Bangerth, ETH Zurich, 2002'
p1876
aS' */'
p1877
aS'#include <deal.II/base/quadrature_lib.h>'
p1878
aS'#include <deal.II/base/function.h>'
p1879
aS'#include <deal.II/base/logstream.h>'
p1880
aS'#include <deal.II/base/thread_management.h>'
p1881
aS'#include <deal.II/base/work_stream.h>'
p1882
aS'#include <deal.II/lac/vector.h>'
p1883
aS'#include <deal.II/lac/full_matrix.h>'
p1884
aS'#include <deal.II/lac/sparse_matrix.h>'
p1885
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p1886
aS'#include <deal.II/lac/solver_cg.h>'
p1887
aS'#include <deal.II/lac/precondition.h>'
p1888
aS'#include <deal.II/lac/affine_constraints.h>'
p1889
aS'#include <deal.II/grid/tria.h>'
p1890
aS'#include <deal.II/grid/grid_generator.h>'
p1891
aS'#include <deal.II/grid/grid_out.h>'
p1892
aS'#include <deal.II/grid/grid_refinement.h>'
p1893
aS'#include <deal.II/dofs/dof_handler.h>'
p1894
aS'#include <deal.II/dofs/dof_tools.h>'
p1895
aS'#include <deal.II/fe/fe_q.h>'
p1896
aS'#include <deal.II/fe/fe_values.h>'
p1897
aS'#include <deal.II/fe/fe_tools.h>'
p1898
aS'#include <deal.II/numerics/vector_tools.h>'
p1899
aS'#include <deal.II/numerics/matrix_tools.h>'
p1900
aS'#include <deal.II/numerics/data_out.h>'
p1901
aS'#include <deal.II/numerics/error_estimator.h>'
p1902
aS'#include <algorithm>'
p1903
aS'#include <fstream>'
p1904
aS'#include <iostream>'
p1905
aS'#include <list>'
p1906
aS'#include <memory>'
p1907
aS'#include <numeric>'
p1908
aS'namespace Step14'
p1909
ag24
aS'  using namespace dealii;'
p1910
aS'  namespace Evaluation'
p1911
aS'  {'
p1912
aS'    template <int dim>'
p1913
aS'    class EvaluationBase'
p1914
aS'    {'
p1915
aS'    public:'
p1916
aS'      virtual ~EvaluationBase() = default;'
p1917
aS'      void set_refinement_cycle(const unsigned int refinement_cycle);'
p1918
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1919
aS'                              const Vector<double> & solution) const = 0;'
p1920
aS'    protected:'
p1921
aS'      unsigned int refinement_cycle;'
p1922
aS'    };'
p1923
aS'    template <int dim>'
p1924
aS'    void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)'
p1925
aS'    {'
p1926
aS'      refinement_cycle = step;'
p1927
aS'    }'
p1928
aS'    template <int dim>'
p1929
aS'    class PointValueEvaluation : public EvaluationBase<dim>'
p1930
aS'    {'
p1931
aS'    public:'
p1932
aS'      PointValueEvaluation(const Point<dim> &evaluation_point);'
p1933
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1934
aS'                              const Vector<double> & solution) const override;'
p1935
aS'      DeclException1('
p1936
aS'        ExcEvaluationPointNotFound,'
p1937
aS'        Point<dim>,'
p1938
aS'        << "The evaluation point " << arg1'
p1939
aS'        << " was not found among the vertices of the present grid.");'
p1940
aS'    private:'
p1941
aS'      const Point<dim> evaluation_point;'
p1942
aS'    };'
p1943
aS'    template <int dim>'
p1944
aS'    PointValueEvaluation<dim>::PointValueEvaluation('
p1945
aS'      const Point<dim> &evaluation_point)'
p1946
aS'      : evaluation_point(evaluation_point)'
p1947
aS'    {}'
p1948
aS'    template <int dim>'
p1949
aS'    void PointValueEvaluation<dim>::'
p1950
aS'         operator()(const DoFHandler<dim> &dof_handler,'
p1951
aS'               const Vector<double> & solution) const'
p1952
aS'    {'
p1953
aS'      double point_value = 1e20;'
p1954
aS'      bool evaluation_point_found = false;'
p1955
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p1956
aS'        if (!evaluation_point_found)'
p1957
aS'          for (const auto vertex : cell->vertex_indices())'
p1958
aS'            if (cell->vertex(vertex).distance(evaluation_point) <'
p1959
aS'                cell->diameter() * 1e-8)'
p1960
aS'              {'
p1961
aS'                point_value = solution(cell->vertex_dof_index(vertex, 0));'
p1962
aS'                evaluation_point_found = true;'
p1963
aS'                break;'
p1964
aS'              }'
p1965
aS'      AssertThrow(evaluation_point_found,'
p1966
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p1967
aS'      std::cout << "   Point value=" << point_value << std::endl;'
p1968
aS'    }'
p1969
aS'    template <int dim>'
p1970
aS'    class PointXDerivativeEvaluation : public EvaluationBase<dim>'
p1971
aS'    {'
p1972
aS'    public:'
p1973
aS'      PointXDerivativeEvaluation(const Point<dim> &evaluation_point);'
p1974
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1975
aS'                              const Vector<double> & solution) const;'
p1976
aS'      DeclException1('
p1977
aS'        ExcEvaluationPointNotFound,'
p1978
aS'        Point<dim>,'
p1979
aS'        << "The evaluation point " << arg1'
p1980
aS'        << " was not found among the vertices of the present grid.");'
p1981
aS'    private:'
p1982
aS'      const Point<dim> evaluation_point;'
p1983
aS'    };'
p1984
aS'    template <int dim>'
p1985
aS'    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation('
p1986
aS'      const Point<dim> &evaluation_point)'
p1987
aS'      : evaluation_point(evaluation_point)'
p1988
aS'    {}'
p1989
aS'    template <int dim>'
p1990
aS'    void PointXDerivativeEvaluation<dim>::'
p1991
aS'         operator()(const DoFHandler<dim> &dof_handler,'
p1992
aS'               const Vector<double> & solution) const'
p1993
aS'    {'
p1994
aS'      double point_derivative = 0;'
p1995
aS'      QTrapezoid<dim>             vertex_quadrature;'
p1996
aS'      FEValues<dim>               fe_values(dof_handler.get_fe(),'
p1997
aS'                              vertex_quadrature,'
p1998
aS'                              update_gradients | update_quadrature_points);'
p1999
aS'      std::vector<Tensor<1, dim>> solution_gradients(vertex_quadrature.size());'
p2000
aS'      unsigned int evaluation_point_hits = 0;'
p2001
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p2002
aS'        for (const auto vertex : cell->vertex_indices())'
p2003
aS'          if (cell->vertex(vertex) == evaluation_point)'
p2004
aS'            {'
p2005
aS'              fe_values.reinit(cell);'
p2006
aS'              fe_values.get_function_gradients(solution, solution_gradients);'
p2007
aS'              unsigned int q_point = 0;'
p2008
aS'              for (; q_point < solution_gradients.size(); ++q_point)'
p2009
aS'                if (fe_values.quadrature_point(q_point) == evaluation_point)'
p2010
aS'                  break;'
p2011
aS'              Assert(q_point < solution_gradients.size(), ExcInternalError());'
p2012
aS'              point_derivative += solution_gradients[q_point][0];'
p2013
aS'              ++evaluation_point_hits;'
p2014
aS'              break;'
p2015
aS'            }'
p2016
aS'      AssertThrow(evaluation_point_hits > 0,'
p2017
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p2018
aS'      point_derivative /= evaluation_point_hits;'
p2019
aS'      std::cout << "   Point x-derivative=" << point_derivative << std::endl;'
p2020
aS'    }'
p2021
aS'    template <int dim>'
p2022
aS'    class GridOutput : public EvaluationBase<dim>'
p2023
aS'    {'
p2024
aS'    public:'
p2025
aS'      GridOutput(const std::string &output_name_base);'
p2026
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p2027
aS'                              const Vector<double> & solution) const override;'
p2028
aS'    private:'
p2029
aS'      const std::string output_name_base;'
p2030
aS'    };'
p2031
aS'    template <int dim>'
p2032
aS'    GridOutput<dim>::GridOutput(const std::string &output_name_base)'
p2033
aS'      : output_name_base(output_name_base)'
p2034
aS'    {}'
p2035
aS'    template <int dim>'
p2036
aS'    void GridOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,'
p2037
aS'                                     const Vector<double> & /*solution*/) const'
p2038
aS'    {'
p2039
aS'      std::ofstream out(output_name_base + "-" +'
p2040
aS'                        std::to_string(this->refinement_cycle) + ".svg");'
p2041
aS'      GridOut().write_svg(dof_handler.get_triangulation(), out);'
p2042
aS'    }'
p2043
aS'  } // namespace Evaluation'
p2044
aS'  namespace LaplaceSolver'
p2045
aS'  {'
p2046
aS'    template <int dim>'
p2047
aS'    class Base'
p2048
aS'    {'
p2049
aS'    public:'
p2050
aS'      Base(Triangulation<dim> &coarse_grid);'
p2051
aS'      virtual ~Base() = default;'
p2052
aS'      virtual void solve_problem() = 0;'
p2053
aS'      virtual void postprocess('
p2054
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;'
p2055
aS'      virtual void         refine_grid()                            = 0;'
p2056
aS'      virtual unsigned int n_dofs() const                           = 0;'
p2057
aS'      virtual void set_refinement_cycle(const unsigned int cycle);'
p2058
aS'      virtual void output_solution() const = 0;'
p2059
aS'    protected:'
p2060
aS'      const SmartPointer<Triangulation<dim>> triangulation;'
p2061
aS'      unsigned int refinement_cycle;'
p2062
aS'    };'
p2063
aS'    template <int dim>'
p2064
aS'    Base<dim>::Base(Triangulation<dim> &coarse_grid)'
p2065
aS'      : triangulation(&coarse_grid)'
p2066
aS'      , refinement_cycle(numbers::invalid_unsigned_int)'
p2067
aS'    {}'
p2068
aS'    template <int dim>'
p2069
aS'    void Base<dim>::set_refinement_cycle(const unsigned int cycle)'
p2070
aS'    {'
p2071
aS'      refinement_cycle = cycle;'
p2072
aS'    }'
p2073
aS'    template <int dim>'
p2074
aS'    class Solver : public virtual Base<dim>'
p2075
aS'    {'
p2076
aS'    public:'
p2077
aS'      Solver(Triangulation<dim> &       triangulation,'
p2078
aS'             const FiniteElement<dim> & fe,'
p2079
aS'             const Quadrature<dim> &    quadrature,'
p2080
aS'             const Quadrature<dim - 1> &face_quadrature,'
p2081
aS'             const Function<dim> &      boundary_values);'
p2082
aS'      virtual ~Solver() override;'
p2083
aS'      virtual void solve_problem() override;'
p2084
aS'      virtual void postprocess('
p2085
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const override;'
p2086
aS'      virtual unsigned int n_dofs() const override;'
p2087
aS'    protected:'
p2088
aS'      const SmartPointer<const FiniteElement<dim>>  fe;'
p2089
aS'      const SmartPointer<const Quadrature<dim>>     quadrature;'
p2090
aS'      const SmartPointer<const Quadrature<dim - 1>> face_quadrature;'
p2091
aS'      DoFHandler<dim>                               dof_handler;'
p2092
aS'      Vector<double>                                solution;'
p2093
aS'      const SmartPointer<const Function<dim>>       boundary_values;'
p2094
aS'      virtual void assemble_rhs(Vector<double> &rhs) const = 0;'
p2095
aS'    private:'
p2096
aS'      struct LinearSystem'
p2097
aS'      {'
p2098
aS'        LinearSystem(const DoFHandler<dim> &dof_handler);'
p2099
aS'        void solve(Vector<double> &solution) const;'
p2100
aS'        AffineConstraints<double> hanging_node_constraints;'
p2101
aS'        SparsityPattern           sparsity_pattern;'
p2102
aS'        SparseMatrix<double>      matrix;'
p2103
aS'        Vector<double>            rhs;'
p2104
aS'      };'
p2105
aS'      struct AssemblyScratchData'
p2106
aS'      {'
p2107
aS'        AssemblyScratchData(const FiniteElement<dim> &fe,'
p2108
aS'                            const Quadrature<dim> &   quadrature);'
p2109
aS'        AssemblyScratchData(const AssemblyScratchData &scratch_data);'
p2110
aS'        FEValues<dim> fe_values;'
p2111
aS'      };'
p2112
aS'      struct AssemblyCopyData'
p2113
aS'      {'
p2114
aS'        FullMatrix<double>                   cell_matrix;'
p2115
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p2116
aS'      };'
p2117
aS'      void assemble_linear_system(LinearSystem &linear_system);'
p2118
aS'      void local_assemble_matrix('
p2119
aS'        const typename DoFHandler<dim>::active_cell_iterator &cell,'
p2120
aS'        AssemblyScratchData &                                 scratch_data,'
p2121
aS'        AssemblyCopyData &                                    copy_data) const;'
p2122
aS'      void copy_local_to_global(const AssemblyCopyData &copy_data,'
p2123
aS'                                LinearSystem &          linear_system) const;'
p2124
aS'    };'
p2125
aS'    template <int dim>'
p2126
aS'    Solver<dim>::Solver(Triangulation<dim> &       triangulation,'
p2127
aS'                        const FiniteElement<dim> & fe,'
p2128
aS'                        const Quadrature<dim> &    quadrature,'
p2129
aS'                        const Quadrature<dim - 1> &face_quadrature,'
p2130
aS'                        const Function<dim> &      boundary_values)'
p2131
aS'      : Base<dim>(triangulation)'
p2132
aS'      , fe(&fe)'
p2133
aS'      , quadrature(&quadrature)'
p2134
aS'      , face_quadrature(&face_quadrature)'
p2135
aS'      , dof_handler(triangulation)'
p2136
aS'      , boundary_values(&boundary_values)'
p2137
aS'    {}'
p2138
aS'    template <int dim>'
p2139
aS'    Solver<dim>::~Solver()'
p2140
aS'    {'
p2141
aS'      dof_handler.clear();'
p2142
aS'    }'
p2143
aS'    template <int dim>'
p2144
aS'    void Solver<dim>::solve_problem()'
p2145
aS'    {'
p2146
aS'      dof_handler.distribute_dofs(*fe);'
p2147
aS'      solution.reinit(dof_handler.n_dofs());'
p2148
aS'      LinearSystem linear_system(dof_handler);'
p2149
aS'      assemble_linear_system(linear_system);'
p2150
aS'      linear_system.solve(solution);'
p2151
aS'    }'
p2152
aS'    template <int dim>'
p2153
aS'    void Solver<dim>::postprocess('
p2154
aS'      const Evaluation::EvaluationBase<dim> &postprocessor) const'
p2155
aS'    {'
p2156
aS'      postprocessor(dof_handler, solution);'
p2157
aS'    }'
p2158
aS'    template <int dim>'
p2159
aS'    unsigned int Solver<dim>::n_dofs() const'
p2160
aS'    {'
p2161
aS'      return dof_handler.n_dofs();'
p2162
aS'    }'
p2163
aS'    template <int dim>'
p2164
aS'    void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)'
p2165
aS'    {'
p2166
aS'      Threads::Task<void> rhs_task ='
p2167
aS'        Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);'
p2168
aS'      auto worker ='
p2169
aS'        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p2170
aS'               AssemblyScratchData &scratch_data,'
p2171
aS'               AssemblyCopyData &   copy_data) {'
p2172
aS'          this->local_assemble_matrix(cell, scratch_data, copy_data);'
p2173
aS'        };'
p2174
aS'      auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {'
p2175
aS'        this->copy_local_to_global(copy_data, linear_system);'
p2176
aS'      };'
p2177
aS'      WorkStream::run(dof_handler.begin_active(),'
p2178
aS'                      dof_handler.end(),'
p2179
aS'                      worker,'
p2180
aS'                      copier,'
p2181
aS'                      AssemblyScratchData(*fe, *quadrature),'
p2182
aS'                      AssemblyCopyData());'
p2183
aS'      linear_system.hanging_node_constraints.condense(linear_system.matrix);'
p2184
aS'      std::map<types::global_dof_index, double> boundary_value_map;'
p2185
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p2186
aS'                                               0,'
p2187
aS'                                               *boundary_values,'
p2188
aS'                                               boundary_value_map);'
p2189
aS'      rhs_task.join();'
p2190
aS'      linear_system.hanging_node_constraints.condense(linear_system.rhs);'
p2191
aS'      MatrixTools::apply_boundary_values(boundary_value_map,'
p2192
aS'                                         linear_system.matrix,'
p2193
aS'                                         solution,'
p2194
aS'                                         linear_system.rhs);'
p2195
aS'    }'
p2196
aS'    template <int dim>'
p2197
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p2198
aS'      const FiniteElement<dim> &fe,'
p2199
aS'      const Quadrature<dim> &   quadrature)'
p2200
aS'      : fe_values(fe, quadrature, update_gradients | update_JxW_values)'
p2201
aS'    {}'
p2202
aS'    template <int dim>'
p2203
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p2204
aS'      const AssemblyScratchData &scratch_data)'
p2205
aS'      : fe_values(scratch_data.fe_values.get_fe(),'
p2206
aS'                  scratch_data.fe_values.get_quadrature(),'
p2207
aS'                  update_gradients | update_JxW_values)'
p2208
aS'    {}'
p2209
aS'    template <int dim>'
p2210
aS'    void Solver<dim>::local_assemble_matrix('
p2211
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p2212
aS'      AssemblyScratchData &                                 scratch_data,'
p2213
aS'      AssemblyCopyData &                                    copy_data) const'
p2214
aS'    {'
p2215
aS'      const unsigned int dofs_per_cell = fe->n_dofs_per_cell();'
p2216
aS'      const unsigned int n_q_points    = quadrature->size();'
p2217
aS'      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p2218
aS'      copy_data.local_dof_indices.resize(dofs_per_cell);'
p2219
aS'      scratch_data.fe_values.reinit(cell);'
p2220
aS'      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p2221
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2222
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p2223
aS'            copy_data.cell_matrix(i, j) +='
p2224
aS'              (scratch_data.fe_values.shape_grad(i, q_point) *'
p2225
aS'               scratch_data.fe_values.shape_grad(j, q_point) *'
p2226
aS'               scratch_data.fe_values.JxW(q_point));'
p2227
aS'      cell->get_dof_indices(copy_data.local_dof_indices);'
p2228
aS'    }'
p2229
aS'    template <int dim>'
p2230
aS'    void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,'
p2231
aS'                                           LinearSystem &linear_system) const'
p2232
aS'    {'
p2233
aS'      for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)'
p2234
aS'        for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)'
p2235
aS'          linear_system.matrix.add(copy_data.local_dof_indices[i],'
p2236
aS'                                   copy_data.local_dof_indices[j],'
p2237
aS'                                   copy_data.cell_matrix(i, j));'
p2238
aS'    }'
p2239
aS'    template <int dim>'
p2240
aS'    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)'
p2241
aS'    {'
p2242
aS'      hanging_node_constraints.clear();'
p2243
aS'      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) ='
p2244
aS'        &DoFTools::make_hanging_node_constraints;'
p2245
aS'      Threads::Task<void> side_task ='
p2246
aS'        Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);'
p2247
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p2248
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p2249
aS'      side_task.join();'
p2250
aS'      hanging_node_constraints.close();'
p2251
aS'      hanging_node_constraints.condense(dsp);'
p2252
aS'      sparsity_pattern.copy_from(dsp);'
p2253
aS'      matrix.reinit(sparsity_pattern);'
p2254
aS'      rhs.reinit(dof_handler.n_dofs());'
p2255
aS'    }'
p2256
aS'    template <int dim>'
p2257
aS'    void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const'
p2258
aS'    {'
p2259
aS'      SolverControl            solver_control(5000, 1e-12);'
p2260
aS'      SolverCG<Vector<double>> cg(solver_control);'
p2261
aS'      PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p2262
aS'      preconditioner.initialize(matrix, 1.2);'
p2263
aS'      cg.solve(matrix, solution, rhs, preconditioner);'
p2264
aS'      hanging_node_constraints.distribute(solution);'
p2265
aS'    }'
p2266
aS'    template <int dim>'
p2267
aS'    class PrimalSolver : public Solver<dim>'
p2268
aS'    {'
p2269
aS'    public:'
p2270
aS'      PrimalSolver(Triangulation<dim> &       triangulation,'
p2271
aS'                   const FiniteElement<dim> & fe,'
p2272
aS'                   const Quadrature<dim> &    quadrature,'
p2273
aS'                   const Quadrature<dim - 1> &face_quadrature,'
p2274
aS'                   const Function<dim> &      rhs_function,'
p2275
aS'                   const Function<dim> &      boundary_values);'
p2276
aS'      virtual void output_solution() const override;'
p2277
aS'    protected:'
p2278
aS'      const SmartPointer<const Function<dim>> rhs_function;'
p2279
aS'      virtual void assemble_rhs(Vector<double> &rhs) const override;'
p2280
aS'    };'
p2281
aS'    template <int dim>'
p2282
aS'    PrimalSolver<dim>::PrimalSolver(Triangulation<dim> &       triangulation,'
p2283
aS'                                    const FiniteElement<dim> & fe,'
p2284
aS'                                    const Quadrature<dim> &    quadrature,'
p2285
aS'                                    const Quadrature<dim - 1> &face_quadrature,'
p2286
aS'                                    const Function<dim> &      rhs_function,'
p2287
aS'                                    const Function<dim> &      boundary_values)'
p2288
aS'      : Base<dim>(triangulation)'
p2289
aS'      , Solver<dim>(triangulation,'
p2290
aS'                    fe,'
p2291
aS'                    quadrature,'
p2292
aS'                    face_quadrature,'
p2293
aS'                    boundary_values)'
p2294
aS'      , rhs_function(&rhs_function)'
p2295
aS'    {}'
p2296
aS'    template <int dim>'
p2297
aS'    void PrimalSolver<dim>::output_solution() const'
p2298
aS'    {'
p2299
aS'      DataOut<dim> data_out;'
p2300
aS'      data_out.attach_dof_handler(this->dof_handler);'
p2301
aS'      data_out.add_data_vector(this->solution, "solution");'
p2302
aS'      data_out.build_patches();'
p2303
aS'      std::ofstream out("solution-" + std::to_string(this->refinement_cycle) +'
p2304
aS'                        ".vtu");'
p2305
aS'      data_out.write(out, DataOutBase::vtu);'
p2306
aS'    }'
p2307
aS'    template <int dim>'
p2308
aS'    void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const'
p2309
aS'    {'
p2310
aS'      FEValues<dim> fe_values(*this->fe,'
p2311
aS'                              *this->quadrature,'
p2312
aS'                              update_values | update_quadrature_points |'
p2313
aS'                                update_JxW_values);'
p2314
aS'      const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();'
p2315
aS'      const unsigned int n_q_points    = this->quadrature->size();'
p2316
aS'      Vector<double>                       cell_rhs(dofs_per_cell);'
p2317
aS'      std::vector<double>                  rhs_values(n_q_points);'
p2318
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p2319
aS'      for (const auto &cell : this->dof_handler.active_cell_iterators())'
p2320
aS'        {'
p2321
aS'          cell_rhs = 0;'
p2322
aS'          fe_values.reinit(cell);'
p2323
aS'          rhs_function->value_list(fe_values.get_quadrature_points(),'
p2324
aS'                                   rhs_values);'
p2325
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p2326
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2327
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)'
p2328
aS'                              rhs_values[q_point] *               // f((x_q)'
p2329
aS'                              fe_values.JxW(q_point));            // dx'
p2330
aS'          cell->get_dof_indices(local_dof_indices);'
p2331
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2332
aS'            rhs(local_dof_indices[i]) += cell_rhs(i);'
p2333
aS'        }'
p2334
aS'    }'
p2335
aS'    template <int dim>'
p2336
aS'    class RefinementGlobal : public PrimalSolver<dim>'
p2337
aS'    {'
p2338
aS'    public:'
p2339
aS'      RefinementGlobal(Triangulation<dim> &       coarse_grid,'
p2340
aS'                       const FiniteElement<dim> & fe,'
p2341
aS'                       const Quadrature<dim> &    quadrature,'
p2342
aS'                       const Quadrature<dim - 1> &face_quadrature,'
p2343
aS'                       const Function<dim> &      rhs_function,'
p2344
aS'                       const Function<dim> &      boundary_values);'
p2345
aS'      virtual void refine_grid() override;'
p2346
aS'    };'
p2347
aS'    template <int dim>'
p2348
aS'    RefinementGlobal<dim>::RefinementGlobal('
p2349
aS'      Triangulation<dim> &       coarse_grid,'
p2350
aS'      const FiniteElement<dim> & fe,'
p2351
aS'      const Quadrature<dim> &    quadrature,'
p2352
aS'      const Quadrature<dim - 1> &face_quadrature,'
p2353
aS'      const Function<dim> &      rhs_function,'
p2354
aS'      const Function<dim> &      boundary_values)'
p2355
aS'      : Base<dim>(coarse_grid)'
p2356
aS'      , PrimalSolver<dim>(coarse_grid,'
p2357
aS'                          fe,'
p2358
aS'                          quadrature,'
p2359
aS'                          face_quadrature,'
p2360
aS'                          rhs_function,'
p2361
aS'                          boundary_values)'
p2362
aS'    {}'
p2363
aS'    template <int dim>'
p2364
aS'    void RefinementGlobal<dim>::refine_grid()'
p2365
aS'    {'
p2366
aS'      this->triangulation->refine_global(1);'
p2367
aS'    }'
p2368
aS'    template <int dim>'
p2369
aS'    class RefinementKelly : public PrimalSolver<dim>'
p2370
aS'    {'
p2371
aS'    public:'
p2372
aS'      RefinementKelly(Triangulation<dim> &       coarse_grid,'
p2373
aS'                      const FiniteElement<dim> & fe,'
p2374
aS'                      const Quadrature<dim> &    quadrature,'
p2375
aS'                      const Quadrature<dim - 1> &face_quadrature,'
p2376
aS'                      const Function<dim> &      rhs_function,'
p2377
aS'                      const Function<dim> &      boundary_values);'
p2378
aS'      virtual void refine_grid() override;'
p2379
aS'    };'
p2380
aS'    template <int dim>'
p2381
aS'    RefinementKelly<dim>::RefinementKelly('
p2382
aS'      Triangulation<dim> &       coarse_grid,'
p2383
aS'      const FiniteElement<dim> & fe,'
p2384
aS'      const Quadrature<dim> &    quadrature,'
p2385
aS'      const Quadrature<dim - 1> &face_quadrature,'
p2386
aS'      const Function<dim> &      rhs_function,'
p2387
aS'      const Function<dim> &      boundary_values)'
p2388
aS'      : Base<dim>(coarse_grid)'
p2389
aS'      , PrimalSolver<dim>(coarse_grid,'
p2390
aS'                          fe,'
p2391
aS'                          quadrature,'
p2392
aS'                          face_quadrature,'
p2393
aS'                          rhs_function,'
p2394
aS'                          boundary_values)'
p2395
aS'    {}'
p2396
aS'    template <int dim>'
p2397
aS'    void RefinementKelly<dim>::refine_grid()'
p2398
aS'    {'
p2399
aS'      Vector<float> estimated_error_per_cell('
p2400
aS'        this->triangulation->n_active_cells());'
p2401
aS'      KellyErrorEstimator<dim>::estimate('
p2402
aS'        this->dof_handler,'
p2403
aS'        QGauss<dim - 1>(this->fe->degree + 1),'
p2404
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p2405
aS'        this->solution,'
p2406
aS'        estimated_error_per_cell);'
p2407
aS'      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,'
p2408
aS'                                                      estimated_error_per_cell,'
p2409
aS'                                                      0.3,'
p2410
aS'                                                      0.03);'
p2411
aS'      this->triangulation->execute_coarsening_and_refinement();'
p2412
aS'    }'
p2413
aS'    template <int dim>'
p2414
aS'    class RefinementWeightedKelly : public PrimalSolver<dim>'
p2415
aS'    {'
p2416
aS'    public:'
p2417
aS'      RefinementWeightedKelly(Triangulation<dim> &       coarse_grid,'
p2418
aS'                              const FiniteElement<dim> & fe,'
p2419
aS'                              const Quadrature<dim> &    quadrature,'
p2420
aS'                              const Quadrature<dim - 1> &face_quadrature,'
p2421
aS'                              const Function<dim> &      rhs_function,'
p2422
aS'                              const Function<dim> &      boundary_values,'
p2423
aS'                              const Function<dim> &      weighting_function);'
p2424
aS'      virtual void refine_grid() override;'
p2425
aS'    private:'
p2426
aS'      const SmartPointer<const Function<dim>> weighting_function;'
p2427
aS'    };'
p2428
aS'    template <int dim>'
p2429
aS'    RefinementWeightedKelly<dim>::RefinementWeightedKelly('
p2430
aS'      Triangulation<dim> &       coarse_grid,'
p2431
aS'      const FiniteElement<dim> & fe,'
p2432
aS'      const Quadrature<dim> &    quadrature,'
p2433
aS'      const Quadrature<dim - 1> &face_quadrature,'
p2434
aS'      const Function<dim> &      rhs_function,'
p2435
aS'      const Function<dim> &      boundary_values,'
p2436
aS'      const Function<dim> &      weighting_function)'
p2437
aS'      : Base<dim>(coarse_grid)'
p2438
aS'      , PrimalSolver<dim>(coarse_grid,'
p2439
aS'                          fe,'
p2440
aS'                          quadrature,'
p2441
aS'                          face_quadrature,'
p2442
aS'                          rhs_function,'
p2443
aS'                          boundary_values)'
p2444
aS'      , weighting_function(&weighting_function)'
p2445
aS'    {}'
p2446
aS'    template <int dim>'
p2447
aS'    void RefinementWeightedKelly<dim>::refine_grid()'
p2448
aS'    {'
p2449
aS'      Vector<float> estimated_error_per_cell('
p2450
aS'        this->triangulation->n_active_cells());'
p2451
aS'      std::map<types::boundary_id, const Function<dim> *> dummy_function_map;'
p2452
aS'      KellyErrorEstimator<dim>::estimate(this->dof_handler,'
p2453
aS'                                         *this->face_quadrature,'
p2454
aS'                                         dummy_function_map,'
p2455
aS'                                         this->solution,'
p2456
aS'                                         estimated_error_per_cell);'
p2457
aS'      for (const auto &cell : this->dof_handler.active_cell_iterators())'
p2458
aS'        estimated_error_per_cell(cell->active_cell_index()) *='
p2459
aS'          weighting_function->value(cell->center());'
p2460
aS'      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,'
p2461
aS'                                                      estimated_error_per_cell,'
p2462
aS'                                                      0.3,'
p2463
aS'                                                      0.03);'
p2464
aS'      this->triangulation->execute_coarsening_and_refinement();'
p2465
aS'    }'
p2466
aS'  } // namespace LaplaceSolver'
p2467
aS'  namespace Data'
p2468
aS'  {'
p2469
aS'    template <int dim>'
p2470
aS'    struct SetUpBase : public Subscriptor'
p2471
aS'    {'
p2472
aS'      virtual const Function<dim> &get_boundary_values() const = 0;'
p2473
aS'      virtual const Function<dim> &get_right_hand_side() const = 0;'
p2474
aS'      virtual void'
p2475
aS'      create_coarse_grid(Triangulation<dim> &coarse_grid) const = 0;'
p2476
aS'    };'
p2477
aS'    template <class Traits, int dim>'
p2478
aS'    struct SetUp : public SetUpBase<dim>'
p2479
aS'    {'
p2480
aS'      virtual const Function<dim> &get_boundary_values() const override;'
p2481
aS'      virtual const Function<dim> &get_right_hand_side() const override;'
p2482
aS'      virtual void'
p2483
aS'      create_coarse_grid(Triangulation<dim> &coarse_grid) const override;'
p2484
aS'    private:'
p2485
aS'      static const typename Traits::BoundaryValues boundary_values;'
p2486
aS'      static const typename Traits::RightHandSide  right_hand_side;'
p2487
aS'    };'
p2488
aS'    template <class Traits, int dim>'
p2489
aS'    const typename Traits::BoundaryValues SetUp<Traits, dim>::boundary_values;'
p2490
aS'    template <class Traits, int dim>'
p2491
aS'    const typename Traits::RightHandSide SetUp<Traits, dim>::right_hand_side;'
p2492
aS'    template <class Traits, int dim>'
p2493
aS'    const Function<dim> &SetUp<Traits, dim>::get_boundary_values() const'
p2494
aS'    {'
p2495
aS'      return boundary_values;'
p2496
aS'    }'
p2497
aS'    template <class Traits, int dim>'
p2498
aS'    const Function<dim> &SetUp<Traits, dim>::get_right_hand_side() const'
p2499
aS'    {'
p2500
aS'      return right_hand_side;'
p2501
aS'    }'
p2502
aS'    template <class Traits, int dim>'
p2503
aS'    void SetUp<Traits, dim>::create_coarse_grid('
p2504
aS'      Triangulation<dim> &coarse_grid) const'
p2505
aS'    {'
p2506
aS'      Traits::create_coarse_grid(coarse_grid);'
p2507
aS'    }'
p2508
aS'    template <int dim>'
p2509
aS'    struct CurvedRidges'
p2510
aS'    {'
p2511
aS'      class BoundaryValues : public Function<dim>'
p2512
aS'      {'
p2513
aS'      public:'
p2514
aS'        virtual double value(const Point<dim> & p,'
p2515
aS'                             const unsigned int component) const;'
p2516
aS'      };'
p2517
aS'      class RightHandSide : public Function<dim>'
p2518
aS'      {'
p2519
aS'      public:'
p2520
aS'        virtual double value(const Point<dim> & p,'
p2521
aS'                             const unsigned int component) const;'
p2522
aS'      };'
p2523
aS'      static void create_coarse_grid(Triangulation<dim> &coarse_grid);'
p2524
aS'    };'
p2525
aS'    template <int dim>'
p2526
aS'    double CurvedRidges<dim>::BoundaryValues::value('
p2527
aS'      const Point<dim> &p,'
p2528
aS'      const unsigned int /*component*/) const'
p2529
aS'    {'
p2530
aS'      double q = p(0);'
p2531
aS'      for (unsigned int i = 1; i < dim; ++i)'
p2532
aS'        q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p2533
aS'      const double exponential = std::exp(q);'
p2534
aS'      return exponential;'
p2535
aS'    }'
p2536
aS'    template <int dim>'
p2537
aS'    double CurvedRidges<dim>::RightHandSide::value('
p2538
aS'      const Point<dim> &p,'
p2539
aS'      const unsigned int /*component*/) const'
p2540
aS'    {'
p2541
aS'      double q = p(0);'
p2542
aS'      for (unsigned int i = 1; i < dim; ++i)'
p2543
aS'        q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p2544
aS'      const double u  = std::exp(q);'
p2545
aS'      double       t1 = 1, t2 = 0, t3 = 0;'
p2546
aS'      for (unsigned int i = 1; i < dim; ++i)'
p2547
aS'        {'
p2548
aS'          t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);'
p2549
aS'          t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p2550
aS'                100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);'
p2551
aS'          t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) *'
p2552
aS'                  std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p2553
aS'                100 * std::sin(10 * p(i) + 5 * p(0) * p(0));'
p2554
aS'        }'
p2555
aS'      t1 = t1 * t1;'
p2556
aS'      return -u * (t1 + t2 + t3);'
p2557
aS'    }'
p2558
aS'    template <int dim>'
p2559
aS'    void CurvedRidges<dim>::create_coarse_grid(Triangulation<dim> &coarse_grid)'
p2560
aS'    {'
p2561
aS'      GridGenerator::hyper_cube(coarse_grid, -1, 1);'
p2562
aS'      coarse_grid.refine_global(2);'
p2563
aS'    }'
p2564
aS'    template <int dim>'
p2565
aS'    struct Exercise_2_3'
p2566
aS'    {'
p2567
aS'      using BoundaryValues = Functions::ZeroFunction<dim>;'
p2568
aS'      class RightHandSide : public Functions::ConstantFunction<dim>'
p2569
aS'      {'
p2570
aS'      public:'
p2571
aS'        RightHandSide()'
p2572
aS'          : Functions::ConstantFunction<dim>(1.)'
p2573
aS'        {}'
p2574
aS'      };'
p2575
aS'      static void create_coarse_grid(Triangulation<dim> &coarse_grid);'
p2576
aS'    };'
p2577
aS'    template <>'
p2578
aS'    void Exercise_2_3<2>::create_coarse_grid(Triangulation<2> &coarse_grid)'
p2579
aS'    {'
p2580
aS'      const unsigned int dim = 2;'
p2581
aS'      const std::vector<Point<2>> vertices = {'
p2582
aS'        {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, //'
p2583
aS'        {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, //'
p2584
aS'        {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               //'
p2585
aS'        {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, //'
p2586
aS'        {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}};'
p2587
aS'      const std::vector<std::array<int, GeometryInfo<dim>::vertices_per_cell>>'
p2588
aS'        cell_vertices = {{{0, 1, 5, 6}},'
p2589
aS'                         {{1, 2, 6, 7}},'
p2590
aS'                         {{2, 3, 7, 8}},'
p2591
aS'                         {{3, 4, 8, 9}},'
p2592
aS'                         {{5, 6, 10, 11}},'
p2593
aS'                         {{8, 9, 12, 13}},'
p2594
aS'                         {{10, 11, 14, 15}},'
p2595
aS'                         {{12, 13, 17, 18}},'
p2596
aS'                         {{14, 15, 19, 20}},'
p2597
aS'                         {{15, 16, 20, 21}},'
p2598
aS'                         {{16, 17, 21, 22}},'
p2599
aS'                         {{17, 18, 22, 23}}};'
p2600
aS'      const unsigned int n_cells = cell_vertices.size();'
p2601
aS'      std::vector<CellData<dim>> cells(n_cells, CellData<dim>());'
p2602
aS'      for (unsigned int i = 0; i < n_cells; ++i)'
p2603
aS'        {'
p2604
aS'          for (unsigned int j = 0; j < cell_vertices[i].size(); ++j)'
p2605
aS'            cells[i].vertices[j] = cell_vertices[i][j];'
p2606
aS'          cells[i].material_id = 0;'
p2607
aS'        }'
p2608
aS'      coarse_grid.create_triangulation(vertices, cells, SubCellData());'
p2609
aS'      coarse_grid.refine_global(1);'
p2610
aS'    }'
p2611
aS'  } // namespace Data'
p2612
aS'  namespace DualFunctional'
p2613
aS'  {'
p2614
aS'    template <int dim>'
p2615
aS'    class DualFunctionalBase : public Subscriptor'
p2616
aS'    {'
p2617
aS'    public:'
p2618
aS'      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2619
aS'                                Vector<double> &       rhs) const = 0;'
p2620
aS'    };'
p2621
aS'    template <int dim>'
p2622
aS'    class PointValueEvaluation : public DualFunctionalBase<dim>'
p2623
aS'    {'
p2624
aS'    public:'
p2625
aS'      PointValueEvaluation(const Point<dim> &evaluation_point);'
p2626
aS'      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2627
aS'                                Vector<double> &       rhs) const override;'
p2628
aS'      DeclException1('
p2629
aS'        ExcEvaluationPointNotFound,'
p2630
aS'        Point<dim>,'
p2631
aS'        << "The evaluation point " << arg1'
p2632
aS'        << " was not found among the vertices of the present grid.");'
p2633
aS'    protected:'
p2634
aS'      const Point<dim> evaluation_point;'
p2635
aS'    };'
p2636
aS'    template <int dim>'
p2637
aS'    PointValueEvaluation<dim>::PointValueEvaluation('
p2638
aS'      const Point<dim> &evaluation_point)'
p2639
aS'      : evaluation_point(evaluation_point)'
p2640
aS'    {}'
p2641
aS'    template <int dim>'
p2642
aS'    void'
p2643
aS'    PointValueEvaluation<dim>::assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2644
aS'                                            Vector<double> &       rhs) const'
p2645
aS'    {'
p2646
aS'      rhs.reinit(dof_handler.n_dofs());'
p2647
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p2648
aS'        for (const auto vertex : cell->vertex_indices())'
p2649
aS'          if (cell->vertex(vertex).distance(evaluation_point) <'
p2650
aS'              cell->diameter() * 1e-8)'
p2651
aS'            {'
p2652
aS'              rhs(cell->vertex_dof_index(vertex, 0)) = 1;'
p2653
aS'              return;'
p2654
aS'            }'
p2655
aS'      AssertThrow(false, ExcEvaluationPointNotFound(evaluation_point));'
p2656
aS'    }'
p2657
aS'    template <int dim>'
p2658
aS'    class PointXDerivativeEvaluation : public DualFunctionalBase<dim>'
p2659
aS'    {'
p2660
aS'    public:'
p2661
aS'      PointXDerivativeEvaluation(const Point<dim> &evaluation_point);'
p2662
aS'      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2663
aS'                                Vector<double> &       rhs) const;'
p2664
aS'      DeclException1('
p2665
aS'        ExcEvaluationPointNotFound,'
p2666
aS'        Point<dim>,'
p2667
aS'        << "The evaluation point " << arg1'
p2668
aS'        << " was not found among the vertices of the present grid.");'
p2669
aS'    protected:'
p2670
aS'      const Point<dim> evaluation_point;'
p2671
aS'    };'
p2672
aS'    template <int dim>'
p2673
aS'    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation('
p2674
aS'      const Point<dim> &evaluation_point)'
p2675
aS'      : evaluation_point(evaluation_point)'
p2676
aS'    {}'
p2677
aS'    template <int dim>'
p2678
aS'    void PointXDerivativeEvaluation<dim>::assemble_rhs('
p2679
aS'      const DoFHandler<dim> &dof_handler,'
p2680
aS'      Vector<double> &       rhs) const'
p2681
aS'    {'
p2682
aS'      rhs.reinit(dof_handler.n_dofs());'
p2683
aS'      QGauss<dim>        quadrature(dof_handler.get_fe().degree + 1);'
p2684
aS'      FEValues<dim>      fe_values(dof_handler.get_fe(),'
p2685
aS'                              quadrature,'
p2686
aS'                              update_gradients | update_quadrature_points |'
p2687
aS'                                update_JxW_values);'
p2688
aS'      const unsigned int n_q_points    = fe_values.n_quadrature_points;'
p2689
aS'      const unsigned int dofs_per_cell = dof_handler.get_fe().dofs_per_cell;'
p2690
aS'      Vector<double>            cell_rhs(dofs_per_cell);'
p2691
aS'      std::vector<unsigned int> local_dof_indices(dofs_per_cell);'
p2692
aS'      double total_volume = 0;'
p2693
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p2694
aS'        if (cell->center().distance(evaluation_point) <= cell->diameter())'
p2695
aS'          {'
p2696
aS'            fe_values.reinit(cell);'
p2697
aS'            cell_rhs = 0;'
p2698
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p2699
aS'              {'
p2700
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2701
aS'                  cell_rhs(i) +='
p2702
aS'                    fe_values.shape_grad(i, q)[0] // (d/dx phi_i(x_q))'
p2703
aS'                    * fe_values.JxW(q);           // * dx'
p2704
aS'                total_volume += fe_values.JxW(q);'
p2705
aS'              }'
p2706
aS'            cell->get_dof_indices(local_dof_indices);'
p2707
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2708
aS'              rhs(local_dof_indices[i]) += cell_rhs(i);'
p2709
aS'          }'
p2710
aS'      AssertThrow(total_volume > 0,'
p2711
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p2712
aS'      rhs /= total_volume;'
p2713
aS'    }'
p2714
aS'  } // namespace DualFunctional'
p2715
aS'  namespace LaplaceSolver'
p2716
aS'  {'
p2717
aS'    template <int dim>'
p2718
aS'    class DualSolver : public Solver<dim>'
p2719
aS'    {'
p2720
aS'    public:'
p2721
aS'      DualSolver('
p2722
aS'        Triangulation<dim> &                           triangulation,'
p2723
aS'        const FiniteElement<dim> &                     fe,'
p2724
aS'        const Quadrature<dim> &                        quadrature,'
p2725
aS'        const Quadrature<dim - 1> &                    face_quadrature,'
p2726
aS'        const DualFunctional::DualFunctionalBase<dim> &dual_functional);'
p2727
aS'    protected:'
p2728
aS'      const SmartPointer<const DualFunctional::DualFunctionalBase<dim>>'
p2729
aS'                   dual_functional;'
p2730
aS'      virtual void assemble_rhs(Vector<double> &rhs) const override;'
p2731
aS'      static const Functions::ZeroFunction<dim> boundary_values;'
p2732
aS'    };'
p2733
aS'    template <int dim>'
p2734
aS'    const Functions::ZeroFunction<dim> DualSolver<dim>::boundary_values;'
p2735
aS'    template <int dim>'
p2736
aS'    DualSolver<dim>::DualSolver('
p2737
aS'      Triangulation<dim> &                           triangulation,'
p2738
aS'      const FiniteElement<dim> &                     fe,'
p2739
aS'      const Quadrature<dim> &                        quadrature,'
p2740
aS'      const Quadrature<dim - 1> &                    face_quadrature,'
p2741
aS'      const DualFunctional::DualFunctionalBase<dim> &dual_functional)'
p2742
aS'      : Base<dim>(triangulation)'
p2743
aS'      , Solver<dim>(triangulation,'
p2744
aS'                    fe,'
p2745
aS'                    quadrature,'
p2746
aS'                    face_quadrature,'
p2747
aS'                    boundary_values)'
p2748
aS'      , dual_functional(&dual_functional)'
p2749
aS'    {}'
p2750
aS'    template <int dim>'
p2751
aS'    void DualSolver<dim>::assemble_rhs(Vector<double> &rhs) const'
p2752
aS'    {'
p2753
aS'      dual_functional->assemble_rhs(this->dof_handler, rhs);'
p2754
aS'    }'
p2755
aS'    template <int dim>'
p2756
aS'    class WeightedResidual : public PrimalSolver<dim>, public DualSolver<dim>'
p2757
aS'    {'
p2758
aS'    public:'
p2759
aS'      WeightedResidual('
p2760
aS'        Triangulation<dim> &                           coarse_grid,'
p2761
aS'        const FiniteElement<dim> &                     primal_fe,'
p2762
aS'        const FiniteElement<dim> &                     dual_fe,'
p2763
aS'        const Quadrature<dim> &                        quadrature,'
p2764
aS'        const Quadrature<dim - 1> &                    face_quadrature,'
p2765
aS'        const Function<dim> &                          rhs_function,'
p2766
aS'        const Function<dim> &                          boundary_values,'
p2767
aS'        const DualFunctional::DualFunctionalBase<dim> &dual_functional);'
p2768
aS'      virtual void solve_problem() override;'
p2769
aS'      virtual void postprocess('
p2770
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const override;'
p2771
aS'      virtual unsigned int n_dofs() const override;'
p2772
aS'      virtual void refine_grid() override;'
p2773
aS'      virtual void output_solution() const override;'
p2774
aS'    private:'
p2775
aS'      void solve_primal_problem();'
p2776
aS'      void solve_dual_problem();'
p2777
aS'      using active_cell_iterator ='
p2778
aS'        typename DoFHandler<dim>::active_cell_iterator;'
p2779
aS'      using FaceIntegrals ='
p2780
aS'        typename std::map<typename DoFHandler<dim>::face_iterator, double>;'
p2781
aS'      struct CellData'
p2782
aS'      {'
p2783
aS'        FEValues<dim>                           fe_values;'
p2784
aS'        const SmartPointer<const Function<dim>> right_hand_side;'
p2785
aS'        std::vector<double> cell_residual;'
p2786
aS'        std::vector<double> rhs_values;'
p2787
aS'        std::vector<double> dual_weights;'
p2788
aS'        std::vector<double> cell_laplacians;'
p2789
aS'        CellData(const FiniteElement<dim> &fe,'
p2790
aS'                 const Quadrature<dim> &   quadrature,'
p2791
aS'                 const Function<dim> &     right_hand_side);'
p2792
aS'        CellData(const CellData &cell_data);'
p2793
aS'      };'
p2794
aS'      struct FaceData'
p2795
aS'      {'
p2796
aS'        FEFaceValues<dim>    fe_face_values_cell;'
p2797
aS'        FEFaceValues<dim>    fe_face_values_neighbor;'
p2798
aS'        FESubfaceValues<dim> fe_subface_values_cell;'
p2799
aS'        std::vector<double>                  jump_residual;'
p2800
aS'        std::vector<double>                  dual_weights;'
p2801
aS'        typename std::vector<Tensor<1, dim>> cell_grads;'
p2802
aS'        typename std::vector<Tensor<1, dim>> neighbor_grads;'
p2803
aS'        FaceData(const FiniteElement<dim> & fe,'
p2804
aS'                 const Quadrature<dim - 1> &face_quadrature);'
p2805
aS'        FaceData(const FaceData &face_data);'
p2806
aS'      };'
p2807
aS'      struct WeightedResidualScratchData'
p2808
aS'      {'
p2809
aS'        WeightedResidualScratchData('
p2810
aS'          const FiniteElement<dim> & primal_fe,'
p2811
aS'          const Quadrature<dim> &    primal_quadrature,'
p2812
aS'          const Quadrature<dim - 1> &primal_face_quadrature,'
p2813
aS'          const Function<dim> &      rhs_function,'
p2814
aS'          const Vector<double> &     primal_solution,'
p2815
aS'          const Vector<double> &     dual_weights);'
p2816
aS'        WeightedResidualScratchData('
p2817
aS'          const WeightedResidualScratchData &scratch_data);'
p2818
aS'        CellData       cell_data;'
p2819
aS'        FaceData       face_data;'
p2820
aS'        Vector<double> primal_solution;'
p2821
aS'        Vector<double> dual_weights;'
p2822
aS'      };'
p2823
aS'      struct WeightedResidualCopyData'
p2824
aS'      {};'
p2825
aS'      void estimate_error(Vector<float> &error_indicators) const;'
p2826
aS'      void estimate_on_one_cell(const active_cell_iterator & cell,'
p2827
aS'                                WeightedResidualScratchData &scratch_data,'
p2828
aS'                                WeightedResidualCopyData &   copy_data,'
p2829
aS'                                Vector<float> &              error_indicators,'
p2830
aS'                                FaceIntegrals &face_integrals) const;'
p2831
aS'      void integrate_over_cell(const active_cell_iterator &cell,'
p2832
aS'                               const Vector<double> &      primal_solution,'
p2833
aS'                               const Vector<double> &      dual_weights,'
p2834
aS'                               CellData &                  cell_data,'
p2835
aS'                               Vector<float> &error_indicators) const;'
p2836
aS'      void integrate_over_regular_face(const active_cell_iterator &cell,'
p2837
aS'                                       const unsigned int          face_no,'
p2838
aS'                                       const Vector<double> &primal_solution,'
p2839
aS'                                       const Vector<double> &dual_weights,'
p2840
aS'                                       FaceData &            face_data,'
p2841
aS'                                       FaceIntegrals &face_integrals) const;'
p2842
aS'      void integrate_over_irregular_face(const active_cell_iterator &cell,'
p2843
aS'                                         const unsigned int          face_no,'
p2844
aS'                                         const Vector<double> &primal_solution,'
p2845
aS'                                         const Vector<double> &dual_weights,'
p2846
aS'                                         FaceData &            face_data,'
p2847
aS'                                         FaceIntegrals &face_integrals) const;'
p2848
aS'    };'
p2849
aS'    template <int dim>'
p2850
aS'    WeightedResidual<dim>::CellData::CellData('
p2851
aS'      const FiniteElement<dim> &fe,'
p2852
aS'      const Quadrature<dim> &   quadrature,'
p2853
aS'      const Function<dim> &     right_hand_side)'
p2854
aS'      : fe_values(fe,'
p2855
aS'                  quadrature,'
p2856
aS'                  update_values | update_hessians | update_quadrature_points |'
p2857
aS'                    update_JxW_values)'
p2858
aS'      , right_hand_side(&right_hand_side)'
p2859
aS'      , cell_residual(quadrature.size())'
p2860
aS'      , rhs_values(quadrature.size())'
p2861
aS'      , dual_weights(quadrature.size())'
p2862
aS'      , cell_laplacians(quadrature.size())'
p2863
aS'    {}'
p2864
aS'    template <int dim>'
p2865
aS'    WeightedResidual<dim>::CellData::CellData(const CellData &cell_data)'
p2866
aS'      : fe_values(cell_data.fe_values.get_fe(),'
p2867
aS'                  cell_data.fe_values.get_quadrature(),'
p2868
aS'                  update_values | update_hessians | update_quadrature_points |'
p2869
aS'                    update_JxW_values)'
p2870
aS'      , right_hand_side(cell_data.right_hand_side)'
p2871
aS'      , cell_residual(cell_data.cell_residual)'
p2872
aS'      , rhs_values(cell_data.rhs_values)'
p2873
aS'      , dual_weights(cell_data.dual_weights)'
p2874
aS'      , cell_laplacians(cell_data.cell_laplacians)'
p2875
aS'    {}'
p2876
aS'    template <int dim>'
p2877
aS'    WeightedResidual<dim>::FaceData::FaceData('
p2878
aS'      const FiniteElement<dim> & fe,'
p2879
aS'      const Quadrature<dim - 1> &face_quadrature)'
p2880
aS'      : fe_face_values_cell(fe,'
p2881
aS'                            face_quadrature,'
p2882
aS'                            update_values | update_gradients |'
p2883
aS'                              update_JxW_values | update_normal_vectors)'
p2884
aS'      , fe_face_values_neighbor(fe,'
p2885
aS'                                face_quadrature,'
p2886
aS'                                update_values | update_gradients |'
p2887
aS'                                  update_JxW_values | update_normal_vectors)'
p2888
aS'      , fe_subface_values_cell(fe, face_quadrature, update_gradients)'
p2889
aS'    {'
p2890
aS'      const unsigned int n_face_q_points = face_quadrature.size();'
p2891
aS'      jump_residual.resize(n_face_q_points);'
p2892
aS'      dual_weights.resize(n_face_q_points);'
p2893
aS'      cell_grads.resize(n_face_q_points);'
p2894
aS'      neighbor_grads.resize(n_face_q_points);'
p2895
aS'    }'
p2896
aS'    template <int dim>'
p2897
aS'    WeightedResidual<dim>::FaceData::FaceData(const FaceData &face_data)'
p2898
aS'      : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(),'
p2899
aS'                            face_data.fe_face_values_cell.get_quadrature(),'
p2900
aS'                            update_values | update_gradients |'
p2901
aS'                              update_JxW_values | update_normal_vectors)'
p2902
aS'      , fe_face_values_neighbor('
p2903
aS'          face_data.fe_face_values_neighbor.get_fe(),'
p2904
aS'          face_data.fe_face_values_neighbor.get_quadrature(),'
p2905
aS'          update_values | update_gradients | update_JxW_values |'
p2906
aS'            update_normal_vectors)'
p2907
aS'      , fe_subface_values_cell('
p2908
aS'          face_data.fe_subface_values_cell.get_fe(),'
p2909
aS'          face_data.fe_subface_values_cell.get_quadrature(),'
p2910
aS'          update_gradients)'
p2911
aS'      , jump_residual(face_data.jump_residual)'
p2912
aS'      , dual_weights(face_data.dual_weights)'
p2913
aS'      , cell_grads(face_data.cell_grads)'
p2914
aS'      , neighbor_grads(face_data.neighbor_grads)'
p2915
aS'    {}'
p2916
aS'    template <int dim>'
p2917
aS'    WeightedResidual<dim>::WeightedResidualScratchData::'
p2918
aS'      WeightedResidualScratchData('
p2919
aS'        const FiniteElement<dim> & primal_fe,'
p2920
aS'        const Quadrature<dim> &    primal_quadrature,'
p2921
aS'        const Quadrature<dim - 1> &primal_face_quadrature,'
p2922
aS'        const Function<dim> &      rhs_function,'
p2923
aS'        const Vector<double> &     primal_solution,'
p2924
aS'        const Vector<double> &     dual_weights)'
p2925
aS'      : cell_data(primal_fe, primal_quadrature, rhs_function)'
p2926
aS'      , face_data(primal_fe, primal_face_quadrature)'
p2927
aS'      , primal_solution(primal_solution)'
p2928
aS'      , dual_weights(dual_weights)'
p2929
aS'    {}'
p2930
aS'    template <int dim>'
p2931
aS'    WeightedResidual<dim>::WeightedResidualScratchData::'
p2932
aS'      WeightedResidualScratchData('
p2933
aS'        const WeightedResidualScratchData &scratch_data)'
p2934
aS'      : cell_data(scratch_data.cell_data)'
p2935
aS'      , face_data(scratch_data.face_data)'
p2936
aS'      , primal_solution(scratch_data.primal_solution)'
p2937
aS'      , dual_weights(scratch_data.dual_weights)'
p2938
aS'    {}'
p2939
aS'    template <int dim>'
p2940
aS'    WeightedResidual<dim>::WeightedResidual('
p2941
aS'      Triangulation<dim> &                           coarse_grid,'
p2942
aS'      const FiniteElement<dim> &                     primal_fe,'
p2943
aS'      const FiniteElement<dim> &                     dual_fe,'
p2944
aS'      const Quadrature<dim> &                        quadrature,'
p2945
aS'      const Quadrature<dim - 1> &                    face_quadrature,'
p2946
aS'      const Function<dim> &                          rhs_function,'
p2947
aS'      const Function<dim> &                          bv,'
p2948
aS'      const DualFunctional::DualFunctionalBase<dim> &dual_functional)'
p2949
aS'      : Base<dim>(coarse_grid)'
p2950
aS'      , PrimalSolver<dim>(coarse_grid,'
p2951
aS'                          primal_fe,'
p2952
aS'                          quadrature,'
p2953
aS'                          face_quadrature,'
p2954
aS'                          rhs_function,'
p2955
aS'                          bv)'
p2956
aS'      , DualSolver<dim>(coarse_grid,'
p2957
aS'                        dual_fe,'
p2958
aS'                        quadrature,'
p2959
aS'                        face_quadrature,'
p2960
aS'                        dual_functional)'
p2961
aS'    {}'
p2962
aS'    template <int dim>'
p2963
aS'    void WeightedResidual<dim>::solve_problem()'
p2964
aS'    {'
p2965
aS'      Threads::TaskGroup<void> tasks;'
p2966
aS'      tasks +='
p2967
aS'        Threads::new_task(&WeightedResidual<dim>::solve_primal_problem, *this);'
p2968
aS'      tasks +='
p2969
aS'        Threads::new_task(&WeightedResidual<dim>::solve_dual_problem, *this);'
p2970
aS'      tasks.join_all();'
p2971
aS'    }'
p2972
aS'    template <int dim>'
p2973
aS'    void WeightedResidual<dim>::solve_primal_problem()'
p2974
aS'    {'
p2975
aS'      PrimalSolver<dim>::solve_problem();'
p2976
aS'    }'
p2977
aS'    template <int dim>'
p2978
aS'    void WeightedResidual<dim>::solve_dual_problem()'
p2979
aS'    {'
p2980
aS'      DualSolver<dim>::solve_problem();'
p2981
aS'    }'
p2982
aS'    template <int dim>'
p2983
aS'    void WeightedResidual<dim>::postprocess('
p2984
aS'      const Evaluation::EvaluationBase<dim> &postprocessor) const'
p2985
aS'    {'
p2986
aS'      PrimalSolver<dim>::postprocess(postprocessor);'
p2987
aS'    }'
p2988
aS'    template <int dim>'
p2989
aS'    unsigned int WeightedResidual<dim>::n_dofs() const'
p2990
aS'    {'
p2991
aS'      return PrimalSolver<dim>::n_dofs();'
p2992
aS'    }'
p2993
aS'    template <int dim>'
p2994
aS'    void WeightedResidual<dim>::refine_grid()'
p2995
aS'    {'
p2996
aS'      Vector<float> error_indicators(this->triangulation->n_active_cells());'
p2997
aS'      estimate_error(error_indicators);'
p2998
aS'      for (float &error_indicator : error_indicators)'
p2999
aS'        error_indicator = std::fabs(error_indicator);'
p3000
aS'      GridRefinement::refine_and_coarsen_fixed_fraction(*this->triangulation,'
p3001
aS'                                                        error_indicators,'
p3002
aS'                                                        0.8,'
p3003
aS'                                                        0.02);'
p3004
aS'      this->triangulation->execute_coarsening_and_refinement();'
p3005
aS'    }'
p3006
aS'    template <int dim>'
p3007
aS'    void WeightedResidual<dim>::output_solution() const'
p3008
aS'    {'
p3009
aS'      AffineConstraints<double> primal_hanging_node_constraints;'
p3010
aS'      DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,'
p3011
aS'                                              primal_hanging_node_constraints);'
p3012
aS'      primal_hanging_node_constraints.close();'
p3013
aS'      Vector<double> dual_solution(PrimalSolver<dim>::dof_handler.n_dofs());'
p3014
aS'      FETools::interpolate(DualSolver<dim>::dof_handler,'
p3015
aS'                           DualSolver<dim>::solution,'
p3016
aS'                           PrimalSolver<dim>::dof_handler,'
p3017
aS'                           primal_hanging_node_constraints,'
p3018
aS'                           dual_solution);'
p3019
aS'      DataOut<dim> data_out;'
p3020
aS'      data_out.attach_dof_handler(PrimalSolver<dim>::dof_handler);'
p3021
aS'      data_out.add_data_vector(PrimalSolver<dim>::solution, "primal_solution");'
p3022
aS'      data_out.add_data_vector(dual_solution, "dual_solution");'
p3023
aS'      data_out.build_patches();'
p3024
aS'      std::ofstream out("solution-" + std::to_string(this->refinement_cycle) +'
p3025
aS'                        ".vtu");'
p3026
aS'      data_out.write(out, DataOutBase::vtu);'
p3027
aS'    }'
p3028
aS'    template <int dim>'
p3029
aS'    void'
p3030
aS'    WeightedResidual<dim>::estimate_error(Vector<float> &error_indicators) const'
p3031
aS'    {'
p3032
aS'      AffineConstraints<double> dual_hanging_node_constraints;'
p3033
aS'      DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler,'
p3034
aS'                                              dual_hanging_node_constraints);'
p3035
aS'      dual_hanging_node_constraints.close();'
p3036
aS'      Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs());'
p3037
aS'      FETools::interpolate(PrimalSolver<dim>::dof_handler,'
p3038
aS'                           PrimalSolver<dim>::solution,'
p3039
aS'                           DualSolver<dim>::dof_handler,'
p3040
aS'                           dual_hanging_node_constraints,'
p3041
aS'                           primal_solution);'
p3042
aS'      AffineConstraints<double> primal_hanging_node_constraints;'
p3043
aS'      DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,'
p3044
aS'                                              primal_hanging_node_constraints);'
p3045
aS'      primal_hanging_node_constraints.close();'
p3046
aS'      Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs());'
p3047
aS'      FETools::interpolation_difference(DualSolver<dim>::dof_handler,'
p3048
aS'                                        dual_hanging_node_constraints,'
p3049
aS'                                        DualSolver<dim>::solution,'
p3050
aS'                                        PrimalSolver<dim>::dof_handler,'
p3051
aS'                                        primal_hanging_node_constraints,'
p3052
aS'                                        dual_weights);'
p3053
aS'      FaceIntegrals face_integrals;'
p3054
aS'      for (const auto &cell :'
p3055
aS'           DualSolver<dim>::dof_handler.active_cell_iterators())'
p3056
aS'        for (const auto &face : cell->face_iterators())'
p3057
aS'          face_integrals[face] = -1e20;'
p3058
aS'      auto worker = [this,'
p3059
aS'                     &error_indicators,'
p3060
aS'                     &face_integrals](const active_cell_iterator & cell,'
p3061
aS'                                      WeightedResidualScratchData &scratch_data,'
p3062
aS'                                      WeightedResidualCopyData &   copy_data) {'
p3063
aS'        this->estimate_on_one_cell('
p3064
aS'          cell, scratch_data, copy_data, error_indicators, face_integrals);'
p3065
aS'      };'
p3066
aS'      auto do_nothing_copier ='
p3067
aS'        std::function<void(const WeightedResidualCopyData &)>();'
p3068
aS'      WorkStream::run('
p3069
aS'        DualSolver<dim>::dof_handler.begin_active(),'
p3070
aS'        DualSolver<dim>::dof_handler.end(),'
p3071
aS'        worker,'
p3072
aS'        do_nothing_copier,'
p3073
aS'        WeightedResidualScratchData(*DualSolver<dim>::fe,'
p3074
aS'                                    *DualSolver<dim>::quadrature,'
p3075
aS'                                    *DualSolver<dim>::face_quadrature,'
p3076
aS'                                    *this->rhs_function,'
p3077
aS'                                    primal_solution,'
p3078
aS'                                    dual_weights),'
p3079
aS'        WeightedResidualCopyData());'
p3080
aS'      unsigned int present_cell = 0;'
p3081
aS'      for (const auto &cell :'
p3082
aS'           DualSolver<dim>::dof_handler.active_cell_iterators())'
p3083
aS'        {'
p3084
aS'          for (const auto &face : cell->face_iterators())'
p3085
aS'            {'
p3086
aS'              Assert(face_integrals.find(face) != face_integrals.end(),'
p3087
aS'                     ExcInternalError());'
p3088
aS'              error_indicators(present_cell) -= 0.5 * face_integrals[face];'
p3089
aS'            }'
p3090
aS'          ++present_cell;'
p3091
aS'        }'
p3092
aS'      std::cout << "   Estimated error="'
p3093
aS'                << std::accumulate(error_indicators.begin(),'
p3094
aS'                                   error_indicators.end(),'
p3095
aS'                                   0.)'
p3096
aS'                << std::endl;'
p3097
aS'    }'
p3098
aS'    template <int dim>'
p3099
aS'    void WeightedResidual<dim>::estimate_on_one_cell('
p3100
aS'      const active_cell_iterator & cell,'
p3101
aS'      WeightedResidualScratchData &scratch_data,'
p3102
aS'      WeightedResidualCopyData &   copy_data,'
p3103
aS'      Vector<float> &              error_indicators,'
p3104
aS'      FaceIntegrals &              face_integrals) const'
p3105
aS'    {'
p3106
aS'      (void)copy_data;'
p3107
aS'      integrate_over_cell(cell,'
p3108
aS'                          scratch_data.primal_solution,'
p3109
aS'                          scratch_data.dual_weights,'
p3110
aS'                          scratch_data.cell_data,'
p3111
aS'                          error_indicators);'
p3112
aS'      for (const auto face_no : cell->face_indices())'
p3113
aS'        {'
p3114
aS'          if (cell->face(face_no)->at_boundary())'
p3115
aS'            {'
p3116
aS'              face_integrals[cell->face(face_no)] = 0;'
p3117
aS'              continue;'
p3118
aS'            }'
p3119
aS'          if ((cell->neighbor(face_no)->has_children() == false) &&'
p3120
aS'              (cell->neighbor(face_no)->level() == cell->level()) &&'
p3121
aS'              (cell->neighbor(face_no)->index() < cell->index()))'
p3122
aS'            continue;'
p3123
aS'          if (cell->at_boundary(face_no) == false)'
p3124
aS'            if (cell->neighbor(face_no)->level() < cell->level())'
p3125
aS'              continue;'
p3126
aS'          if (cell->face(face_no)->has_children() == false)'
p3127
aS'            integrate_over_regular_face(cell,'
p3128
aS'                                        face_no,'
p3129
aS'                                        scratch_data.primal_solution,'
p3130
aS'                                        scratch_data.dual_weights,'
p3131
aS'                                        scratch_data.face_data,'
p3132
aS'                                        face_integrals);'
p3133
aS'          else'
p3134
aS'            integrate_over_irregular_face(cell,'
p3135
aS'                                          face_no,'
p3136
aS'                                          scratch_data.primal_solution,'
p3137
aS'                                          scratch_data.dual_weights,'
p3138
aS'                                          scratch_data.face_data,'
p3139
aS'                                          face_integrals);'
p3140
aS'        }'
p3141
aS'    }'
p3142
aS'    template <int dim>'
p3143
aS'    void WeightedResidual<dim>::integrate_over_cell('
p3144
aS'      const active_cell_iterator &cell,'
p3145
aS'      const Vector<double> &      primal_solution,'
p3146
aS'      const Vector<double> &      dual_weights,'
p3147
aS'      CellData &                  cell_data,'
p3148
aS'      Vector<float> &             error_indicators) const'
p3149
aS'    {'
p3150
aS'      cell_data.fe_values.reinit(cell);'
p3151
aS'      cell_data.right_hand_side->value_list('
p3152
aS'        cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);'
p3153
aS'      cell_data.fe_values.get_function_laplacians(primal_solution,'
p3154
aS'                                                  cell_data.cell_laplacians);'
p3155
aS'      cell_data.fe_values.get_function_values(dual_weights,'
p3156
aS'                                              cell_data.dual_weights);'
p3157
aS'      double sum = 0;'
p3158
aS'      for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p)'
p3159
aS'        sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) *'
p3160
aS'                cell_data.dual_weights[p] * cell_data.fe_values.JxW(p));'
p3161
aS'      error_indicators(cell->active_cell_index()) += sum;'
p3162
aS'    }'
p3163
aS'    template <int dim>'
p3164
aS'    void WeightedResidual<dim>::integrate_over_regular_face('
p3165
aS'      const active_cell_iterator &cell,'
p3166
aS'      const unsigned int          face_no,'
p3167
aS'      const Vector<double> &      primal_solution,'
p3168
aS'      const Vector<double> &      dual_weights,'
p3169
aS'      FaceData &                  face_data,'
p3170
aS'      FaceIntegrals &             face_integrals) const'
p3171
aS'    {'
p3172
aS'      const unsigned int n_q_points ='
p3173
aS'        face_data.fe_face_values_cell.n_quadrature_points;'
p3174
aS'      face_data.fe_face_values_cell.reinit(cell, face_no);'
p3175
aS'      face_data.fe_face_values_cell.get_function_gradients('
p3176
aS'        primal_solution, face_data.cell_grads);'
p3177
aS'      Assert(cell->neighbor(face_no).state() == IteratorState::valid,'
p3178
aS'             ExcInternalError());'
p3179
aS'      const unsigned int neighbor_neighbor ='
p3180
aS'        cell->neighbor_of_neighbor(face_no);'
p3181
aS'      const active_cell_iterator neighbor = cell->neighbor(face_no);'
p3182
aS'      face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);'
p3183
aS'      face_data.fe_face_values_neighbor.get_function_gradients('
p3184
aS'        primal_solution, face_data.neighbor_grads);'
p3185
aS'      for (unsigned int p = 0; p < n_q_points; ++p)'
p3186
aS'        face_data.jump_residual[p] ='
p3187
aS'          ((face_data.cell_grads[p] - face_data.neighbor_grads[p]) *'
p3188
aS'           face_data.fe_face_values_cell.normal_vector(p));'
p3189
aS'      face_data.fe_face_values_cell.get_function_values(dual_weights,'
p3190
aS'                                                        face_data.dual_weights);'
p3191
aS'      double face_integral = 0;'
p3192
aS'      for (unsigned int p = 0; p < n_q_points; ++p)'
p3193
aS'        face_integral +='
p3194
aS'          (face_data.jump_residual[p] * face_data.dual_weights[p] *'
p3195
aS'           face_data.fe_face_values_cell.JxW(p));'
p3196
aS'      Assert(face_integrals.find(cell->face(face_no)) != face_integrals.end(),'
p3197
aS'             ExcInternalError());'
p3198
aS'      Assert(face_integrals[cell->face(face_no)] == -1e20, ExcInternalError());'
p3199
aS'      face_integrals[cell->face(face_no)] = face_integral;'
p3200
aS'    }'
p3201
aS'    template <int dim>'
p3202
aS'    void WeightedResidual<dim>::integrate_over_irregular_face('
p3203
aS'      const active_cell_iterator &cell,'
p3204
aS'      const unsigned int          face_no,'
p3205
aS'      const Vector<double> &      primal_solution,'
p3206
aS'      const Vector<double> &      dual_weights,'
p3207
aS'      FaceData &                  face_data,'
p3208
aS'      FaceIntegrals &             face_integrals) const'
p3209
aS'    {'
p3210
aS'      const unsigned int n_q_points ='
p3211
aS'        face_data.fe_face_values_cell.n_quadrature_points;'
p3212
aS'      const typename DoFHandler<dim>::face_iterator face = cell->face(face_no);'
p3213
aS'      const typename DoFHandler<dim>::cell_iterator neighbor ='
p3214
aS'        cell->neighbor(face_no);'
p3215
aS'      Assert(neighbor.state() == IteratorState::valid, ExcInternalError());'
p3216
aS'      Assert(neighbor->has_children(), ExcInternalError());'
p3217
aS'      (void)neighbor;'
p3218
aS'      const unsigned int neighbor_neighbor ='
p3219
aS'        cell->neighbor_of_neighbor(face_no);'
p3220
aS'      for (unsigned int subface_no = 0; subface_no < face->n_children();'
p3221
aS'           ++subface_no)'
p3222
aS'        {'
p3223
aS'          const active_cell_iterator neighbor_child ='
p3224
aS'            cell->neighbor_child_on_subface(face_no, subface_no);'
p3225
aS'          Assert(neighbor_child->face(neighbor_neighbor) =='
p3226
aS'                   cell->face(face_no)->child(subface_no),'
p3227
aS'                 ExcInternalError());'
p3228
aS'          face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no);'
p3229
aS'          face_data.fe_subface_values_cell.get_function_gradients('
p3230
aS'            primal_solution, face_data.cell_grads);'
p3231
aS'          face_data.fe_face_values_neighbor.reinit(neighbor_child,'
p3232
aS'                                                   neighbor_neighbor);'
p3233
aS'          face_data.fe_face_values_neighbor.get_function_gradients('
p3234
aS'            primal_solution, face_data.neighbor_grads);'
p3235
aS'          for (unsigned int p = 0; p < n_q_points; ++p)'
p3236
aS'            face_data.jump_residual[p] ='
p3237
aS'              ((face_data.neighbor_grads[p] - face_data.cell_grads[p]) *'
p3238
aS'               face_data.fe_face_values_neighbor.normal_vector(p));'
p3239
aS'          face_data.fe_face_values_neighbor.get_function_values('
p3240
aS'            dual_weights, face_data.dual_weights);'
p3241
aS'          double face_integral = 0;'
p3242
aS'          for (unsigned int p = 0; p < n_q_points; ++p)'
p3243
aS'            face_integral +='
p3244
aS'              (face_data.jump_residual[p] * face_data.dual_weights[p] *'
p3245
aS'               face_data.fe_face_values_neighbor.JxW(p));'
p3246
aS'          face_integrals[neighbor_child->face(neighbor_neighbor)] ='
p3247
aS'            face_integral;'
p3248
aS'        }'
p3249
aS'      double sum = 0;'
p3250
aS'      for (unsigned int subface_no = 0; subface_no < face->n_children();'
p3251
aS'           ++subface_no)'
p3252
aS'        {'
p3253
aS'          Assert(face_integrals.find(face->child(subface_no)) !='
p3254
aS'                   face_integrals.end(),'
p3255
aS'                 ExcInternalError());'
p3256
aS'          Assert(face_integrals[face->child(subface_no)] != -1e20,'
p3257
aS'                 ExcInternalError());'
p3258
aS'          sum += face_integrals[face->child(subface_no)];'
p3259
aS'        }'
p3260
aS'      face_integrals[face] = sum;'
p3261
aS'    }'
p3262
aS'  } // namespace LaplaceSolver'
p3263
aS'  template <int dim>'
p3264
aS'  struct Framework'
p3265
aS'  {'
p3266
aS'  public:'
p3267
aS'    using Evaluator     = Evaluation::EvaluationBase<dim>;'
p3268
aS'    using EvaluatorList = std::list<Evaluator *>;'
p3269
aS'    struct ProblemDescription'
p3270
aS'    {'
p3271
aS'      unsigned int primal_fe_degree;'
p3272
aS'      unsigned int dual_fe_degree;'
p3273
aS'      std::unique_ptr<const Data::SetUpBase<dim>> data;'
p3274
aS'      enum RefinementCriterion'
p3275
aS'      {'
p3276
aS'        dual_weighted_error_estimator,'
p3277
aS'        global_refinement,'
p3278
aS'        kelly_indicator,'
p3279
aS'        weighted_kelly_indicator'
p3280
aS'      };'
p3281
aS'      RefinementCriterion refinement_criterion;'
p3282
aS'      std::unique_ptr<const DualFunctional::DualFunctionalBase<dim>>'
p3283
aS'        dual_functional;'
p3284
aS'      EvaluatorList evaluator_list;'
p3285
aS'      std::unique_ptr<const Function<dim>> kelly_weight;'
p3286
aS'      unsigned int max_degrees_of_freedom;'
p3287
aS'      ProblemDescription();'
p3288
aS'    };'
p3289
aS'    static void run(const ProblemDescription &descriptor);'
p3290
aS'  };'
p3291
aS'  template <int dim>'
p3292
aS'  Framework<dim>::ProblemDescription::ProblemDescription()'
p3293
aS'    : primal_fe_degree(1)'
p3294
aS'    , dual_fe_degree(2)'
p3295
aS'    , refinement_criterion(dual_weighted_error_estimator)'
p3296
aS'    , max_degrees_of_freedom(20000)'
p3297
aS'  {}'
p3298
aS'  template <int dim>'
p3299
aS'  void Framework<dim>::run(const ProblemDescription &descriptor)'
p3300
aS'  {'
p3301
aS'    Triangulation<dim> triangulation('
p3302
aS'      Triangulation<dim>::smoothing_on_refinement);'
p3303
aS'    descriptor.data->create_coarse_grid(triangulation);'
p3304
aS'    const FE_Q<dim>       primal_fe(descriptor.primal_fe_degree);'
p3305
aS'    const FE_Q<dim>       dual_fe(descriptor.dual_fe_degree);'
p3306
aS'    const QGauss<dim>     quadrature(descriptor.dual_fe_degree + 1);'
p3307
aS'    const QGauss<dim - 1> face_quadrature(descriptor.dual_fe_degree + 1);'
p3308
aS'    std::unique_ptr<LaplaceSolver::Base<dim>> solver;'
p3309
aS'    switch (descriptor.refinement_criterion)'
p3310
aS'      {'
p3311
aS'        case ProblemDescription::dual_weighted_error_estimator:'
p3312
aS'          {'
p3313
aS'            solver = std::make_unique<LaplaceSolver::WeightedResidual<dim>>('
p3314
aS'              triangulation,'
p3315
aS'              primal_fe,'
p3316
aS'              dual_fe,'
p3317
aS'              quadrature,'
p3318
aS'              face_quadrature,'
p3319
aS'              descriptor.data->get_right_hand_side(),'
p3320
aS'              descriptor.data->get_boundary_values(),'
p3321
aS'              *descriptor.dual_functional);'
p3322
aS'            break;'
p3323
aS'          }'
p3324
aS'        case ProblemDescription::global_refinement:'
p3325
aS'          {'
p3326
aS'            solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>('
p3327
aS'              triangulation,'
p3328
aS'              primal_fe,'
p3329
aS'              quadrature,'
p3330
aS'              face_quadrature,'
p3331
aS'              descriptor.data->get_right_hand_side(),'
p3332
aS'              descriptor.data->get_boundary_values());'
p3333
aS'            break;'
p3334
aS'          }'
p3335
aS'        case ProblemDescription::kelly_indicator:'
p3336
aS'          {'
p3337
aS'            solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>('
p3338
aS'              triangulation,'
p3339
aS'              primal_fe,'
p3340
aS'              quadrature,'
p3341
aS'              face_quadrature,'
p3342
aS'              descriptor.data->get_right_hand_side(),'
p3343
aS'              descriptor.data->get_boundary_values());'
p3344
aS'            break;'
p3345
aS'          }'
p3346
aS'        case ProblemDescription::weighted_kelly_indicator:'
p3347
aS'          {'
p3348
aS'            solver ='
p3349
aS'              std::make_unique<LaplaceSolver::RefinementWeightedKelly<dim>>('
p3350
aS'                triangulation,'
p3351
aS'                primal_fe,'
p3352
aS'                quadrature,'
p3353
aS'                face_quadrature,'
p3354
aS'                descriptor.data->get_right_hand_side(),'
p3355
aS'                descriptor.data->get_boundary_values(),'
p3356
aS'                *descriptor.kelly_weight);'
p3357
aS'            break;'
p3358
aS'          }'
p3359
aS'        default:'
p3360
aS'          AssertThrow(false, ExcInternalError());'
p3361
aS'      }'
p3362
aS'    for (unsigned int step = 0; true; ++step)'
p3363
aS'      {'
p3364
aS'        std::cout << "Refinement cycle: " << step << std::endl;'
p3365
aS'        solver->set_refinement_cycle(step);'
p3366
aS'        solver->solve_problem();'
p3367
aS'        solver->output_solution();'
p3368
aS'        std::cout << "   Number of degrees of freedom=" << solver->n_dofs()'
p3369
aS'                  << std::endl;'
p3370
aS'        for (const auto &evaluator : descriptor.evaluator_list)'
p3371
aS'          {'
p3372
aS'            evaluator->set_refinement_cycle(step);'
p3373
aS'            solver->postprocess(*evaluator);'
p3374
aS'          }'
p3375
aS'        if (solver->n_dofs() < descriptor.max_degrees_of_freedom)'
p3376
aS'          solver->refine_grid();'
p3377
aS'        else'
p3378
aS'          break;'
p3379
aS'      }'
p3380
aS'    std::cout << std::endl;'
p3381
aS'  }'
p3382
aS'} // namespace Step14'
p3383
aS'int main()'
p3384
ag24
aS'  try'
p3385
aS'    {'
p3386
aS'      using namespace Step14;'
p3387
aS'      const unsigned int                 dim = 2;'
p3388
aS'      Framework<dim>::ProblemDescription descriptor;'
p3389
aS'      descriptor.refinement_criterion ='
p3390
aS'        Framework<dim>::ProblemDescription::dual_weighted_error_estimator;'
p3391
aS'      descriptor.primal_fe_degree = 1;'
p3392
aS'      descriptor.dual_fe_degree   = 2;'
p3393
aS'      descriptor.data ='
p3394
aS'        std::make_unique<Data::SetUp<Data::Exercise_2_3<dim>, dim>>();'
p3395
aS'      const Point<dim> evaluation_point(0.75, 0.75);'
p3396
aS'      descriptor.dual_functional ='
p3397
aS'        std::make_unique<DualFunctional::PointValueEvaluation<dim>>('
p3398
aS'          evaluation_point);'
p3399
aS'      Evaluation::PointValueEvaluation<dim> postprocessor1(evaluation_point);'
p3400
aS'      Evaluation::GridOutput<dim>           postprocessor2("grid");'
p3401
aS'      descriptor.evaluator_list.push_back(&postprocessor1);'
p3402
aS'      descriptor.evaluator_list.push_back(&postprocessor2);'
p3403
aS'      descriptor.max_degrees_of_freedom = 20000;'
p3404
aS'      Framework<dim>::run(descriptor);'
p3405
aS'    }'
p3406
aS'  catch (std::exception &exc)'
p3407
aS'    {'
p3408
aS'      std::cerr << std::endl'
p3409
aS'                << std::endl'
p3410
aS'                << "----------------------------------------------------"'
p3411
aS'                << std::endl;'
p3412
aS'      std::cerr << "Exception on processing: " << std::endl'
p3413
aS'                << exc.what() << std::endl'
p3414
aS'                << "Aborting!" << std::endl'
p3415
aS'                << "----------------------------------------------------"'
p3416
aS'                << std::endl;'
p3417
aS'      return 1;'
p3418
aS'    }'
p3419
aS'  catch (...)'
p3420
aS'    {'
p3421
aS'      std::cerr << std::endl'
p3422
aS'                << std::endl'
p3423
aS'                << "----------------------------------------------------"'
p3424
aS'                << std::endl;'
p3425
aS'      std::cerr << "Unknown exception!" << std::endl'
p3426
aS'                << "Aborting!" << std::endl'
p3427
aS'                << "----------------------------------------------------"'
p3428
aS'                << std::endl;'
p3429
aS'      return 1;'
p3430
aS'    }'
p3431
aS'  return 0;'
p3432
ag32
aS'/* ---------------------------------------------------------------------'
p3433
aS' *'
p3434
aS' * Copyright (C) 2012 - 2021 by the deal.II authors'
p3435
aS' *'
p3436
aS' * This file is part of the deal.II library.'
p3437
aS' *'
p3438
aS' * The deal.II library is free software; you can use it, redistribute'
p3439
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p3440
aS' * Public License as published by the Free Software Foundation; either'
p3441
aS' * version 2.1 of the License, or (at your option) any later version.'
p3442
aS' * The full text of the license can be found in the file LICENSE.md at'
p3443
aS' * the top level directory of deal.II.'
p3444
aS' *'
p3445
aS' * ---------------------------------------------------------------------'
p3446
aS' *'
p3447
aS' * Author: Sven Wetterauer, University of Heidelberg, 2012'
p3448
aS' */'
p3449
aS'#include <deal.II/base/quadrature_lib.h>'
p3450
aS'#include <deal.II/base/function.h>'
p3451
aS'#include <deal.II/base/utilities.h>'
p3452
aS'#include <deal.II/lac/vector.h>'
p3453
aS'#include <deal.II/lac/full_matrix.h>'
p3454
aS'#include <deal.II/lac/sparse_matrix.h>'
p3455
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p3456
aS'#include <deal.II/lac/solver_cg.h>'
p3457
aS'#include <deal.II/lac/precondition.h>'
p3458
aS'#include <deal.II/lac/affine_constraints.h>'
p3459
aS'#include <deal.II/grid/tria.h>'
p3460
aS'#include <deal.II/grid/grid_generator.h>'
p3461
aS'#include <deal.II/grid/grid_refinement.h>'
p3462
aS'#include <deal.II/dofs/dof_handler.h>'
p3463
aS'#include <deal.II/dofs/dof_tools.h>'
p3464
aS'#include <deal.II/fe/fe_values.h>'
p3465
aS'#include <deal.II/fe/fe_q.h>'
p3466
aS'#include <deal.II/numerics/vector_tools.h>'
p3467
aS'#include <deal.II/numerics/matrix_tools.h>'
p3468
aS'#include <deal.II/numerics/data_out.h>'
p3469
aS'#include <deal.II/numerics/error_estimator.h>'
p3470
aS'#include <fstream>'
p3471
aS'#include <iostream>'
p3472
aS'#include <deal.II/numerics/solution_transfer.h>'
p3473
aS'namespace Step15'
p3474
ag24
aS'  using namespace dealii;'
p3475
aS'  template <int dim>'
p3476
aS'  class MinimalSurfaceProblem'
p3477
aS'  {'
p3478
aS'  public:'
p3479
aS'    MinimalSurfaceProblem();'
p3480
aS'    void run();'
p3481
aS'  private:'
p3482
aS'    void   setup_system(const bool initial_step);'
p3483
aS'    void   assemble_system();'
p3484
aS'    void   solve();'
p3485
aS'    void   refine_mesh();'
p3486
aS'    void   set_boundary_values();'
p3487
aS'    double compute_residual(const double alpha) const;'
p3488
aS'    double determine_step_length() const;'
p3489
aS'    void   output_results(const unsigned int refinement_cycle) const;'
p3490
aS'    Triangulation<dim> triangulation;'
p3491
aS'    DoFHandler<dim> dof_handler;'
p3492
aS'    FE_Q<dim>       fe;'
p3493
aS'    AffineConstraints<double> hanging_node_constraints;'
p3494
aS'    SparsityPattern      sparsity_pattern;'
p3495
aS'    SparseMatrix<double> system_matrix;'
p3496
aS'    Vector<double> current_solution;'
p3497
aS'    Vector<double> newton_update;'
p3498
aS'    Vector<double> system_rhs;'
p3499
aS'  };'
p3500
aS'  template <int dim>'
p3501
aS'  class BoundaryValues : public Function<dim>'
p3502
aS'  {'
p3503
aS'  public:'
p3504
aS'    virtual double value(const Point<dim> & p,'
p3505
aS'                         const unsigned int component = 0) const override;'
p3506
aS'  };'
p3507
aS'  template <int dim>'
p3508
aS'  double BoundaryValues<dim>::value(const Point<dim> &p,'
p3509
aS'                                    const unsigned int /*component*/) const'
p3510
aS'  {'
p3511
aS'    return std::sin(2 * numbers::PI * (p[0] + p[1]));'
p3512
aS'  }'
p3513
aS'  template <int dim>'
p3514
aS'  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()'
p3515
aS'    : dof_handler(triangulation)'
p3516
aS'    , fe(2)'
p3517
aS'  {}'
p3518
aS'  template <int dim>'
p3519
aS'  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step)'
p3520
aS'  {'
p3521
aS'    if (initial_step)'
p3522
aS'      {'
p3523
aS'        dof_handler.distribute_dofs(fe);'
p3524
aS'        current_solution.reinit(dof_handler.n_dofs());'
p3525
aS'        hanging_node_constraints.clear();'
p3526
aS'        DoFTools::make_hanging_node_constraints(dof_handler,'
p3527
aS'                                                hanging_node_constraints);'
p3528
aS'        hanging_node_constraints.close();'
p3529
aS'      }'
p3530
aS'    newton_update.reinit(dof_handler.n_dofs());'
p3531
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p3532
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p3533
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p3534
aS'    hanging_node_constraints.condense(dsp);'
p3535
aS'    sparsity_pattern.copy_from(dsp);'
p3536
aS'    system_matrix.reinit(sparsity_pattern);'
p3537
aS'  }'
p3538
aS'  template <int dim>'
p3539
aS'  void MinimalSurfaceProblem<dim>::assemble_system()'
p3540
aS'  {'
p3541
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p3542
aS'    system_matrix = 0;'
p3543
aS'    system_rhs    = 0;'
p3544
aS'    FEValues<dim> fe_values(fe,'
p3545
aS'                            quadrature_formula,'
p3546
aS'                            update_gradients | update_quadrature_points |'
p3547
aS'                              update_JxW_values);'
p3548
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p3549
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p3550
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p3551
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p3552
aS'    std::vector<Tensor<1, dim>> old_solution_gradients(n_q_points);'
p3553
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p3554
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p3555
aS'      {'
p3556
aS'        cell_matrix = 0;'
p3557
aS'        cell_rhs    = 0;'
p3558
aS'        fe_values.reinit(cell);'
p3559
aS'        fe_values.get_function_gradients(current_solution,'
p3560
aS'                                         old_solution_gradients);'
p3561
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p3562
aS'          {'
p3563
aS'            const double coeff ='
p3564
aS'              1.0 / std::sqrt(1 + old_solution_gradients[q] *'
p3565
aS'                                    old_solution_gradients[q]);'
p3566
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3567
aS'              {'
p3568
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3569
aS'                  cell_matrix(i, j) +='
p3570
aS'                    (((fe_values.shape_grad(i, q)      // ((\\nabla \\phi_i'
p3571
aS'                       * coeff                         //   * a_n'
p3572
aS'                       * fe_values.shape_grad(j, q))   //   * \\nabla \\phi_j)'
p3573
aS'                      -                                //  -'
p3574
aS'                      (fe_values.shape_grad(i, q)      //  (\\nabla \\phi_i'
p3575
aS'                       * coeff * coeff * coeff         //   * a_n^3'
p3576
aS'                       * (fe_values.shape_grad(j, q)   //   * (\\nabla \\phi_j'
p3577
aS'                          * old_solution_gradients[q]) //      * \\nabla u_n)'
p3578
aS'                       * old_solution_gradients[q]))   //   * \\nabla u_n)))'
p3579
aS'                     * fe_values.JxW(q));              // * dx'
p3580
aS'                cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \\nabla \\phi_i'
p3581
aS'                                * coeff                     // * a_n'
p3582
aS'                                * old_solution_gradients[q] // * u_n'
p3583
aS'                                * fe_values.JxW(q));        // * dx'
p3584
aS'              }'
p3585
aS'          }'
p3586
aS'        cell->get_dof_indices(local_dof_indices);'
p3587
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3588
aS'          {'
p3589
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3590
aS'              system_matrix.add(local_dof_indices[i],'
p3591
aS'                                local_dof_indices[j],'
p3592
aS'                                cell_matrix(i, j));'
p3593
aS'            system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p3594
aS'          }'
p3595
aS'      }'
p3596
aS'    hanging_node_constraints.condense(system_matrix);'
p3597
aS'    hanging_node_constraints.condense(system_rhs);'
p3598
aS'    std::map<types::global_dof_index, double> boundary_values;'
p3599
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p3600
aS'                                             0,'
p3601
aS'                                             Functions::ZeroFunction<dim>(),'
p3602
aS'                                             boundary_values);'
p3603
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p3604
aS'                                       system_matrix,'
p3605
aS'                                       newton_update,'
p3606
aS'                                       system_rhs);'
p3607
aS'  }'
p3608
aS'  template <int dim>'
p3609
aS'  void MinimalSurfaceProblem<dim>::solve()'
p3610
aS'  {'
p3611
aS'    SolverControl            solver_control(system_rhs.size(),'
p3612
aS'                                 system_rhs.l2_norm() * 1e-6);'
p3613
aS'    SolverCG<Vector<double>> solver(solver_control);'
p3614
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p3615
aS'    preconditioner.initialize(system_matrix, 1.2);'
p3616
aS'    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p3617
aS'    hanging_node_constraints.distribute(newton_update);'
p3618
aS'    const double alpha = determine_step_length();'
p3619
aS'    current_solution.add(alpha, newton_update);'
p3620
aS'  }'
p3621
aS'  template <int dim>'
p3622
aS'  void MinimalSurfaceProblem<dim>::refine_mesh()'
p3623
aS'  {'
p3624
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p3625
aS'    KellyErrorEstimator<dim>::estimate('
p3626
aS'      dof_handler,'
p3627
aS'      QGauss<dim - 1>(fe.degree + 1),'
p3628
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p3629
aS'      current_solution,'
p3630
aS'      estimated_error_per_cell);'
p3631
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p3632
aS'                                                    estimated_error_per_cell,'
p3633
aS'                                                    0.3,'
p3634
aS'                                                    0.03);'
p3635
aS'    triangulation.prepare_coarsening_and_refinement();'
p3636
aS'    SolutionTransfer<dim> solution_transfer(dof_handler);'
p3637
aS'    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);'
p3638
aS'    triangulation.execute_coarsening_and_refinement();'
p3639
aS'    dof_handler.distribute_dofs(fe);'
p3640
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p3641
aS'    solution_transfer.interpolate(current_solution, tmp);'
p3642
aS'    current_solution = tmp;'
p3643
aS'    hanging_node_constraints.clear();'
p3644
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p3645
aS'                                            hanging_node_constraints);'
p3646
aS'    hanging_node_constraints.close();'
p3647
aS'    set_boundary_values();'
p3648
aS'    setup_system(false);'
p3649
aS'  }'
p3650
aS'  template <int dim>'
p3651
aS'  void MinimalSurfaceProblem<dim>::set_boundary_values()'
p3652
aS'  {'
p3653
aS'    std::map<types::global_dof_index, double> boundary_values;'
p3654
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p3655
aS'                                             0,'
p3656
aS'                                             BoundaryValues<dim>(),'
p3657
aS'                                             boundary_values);'
p3658
aS'    for (auto &boundary_value : boundary_values)'
p3659
aS'      current_solution(boundary_value.first) = boundary_value.second;'
p3660
aS'    hanging_node_constraints.distribute(current_solution);'
p3661
aS'  }'
p3662
aS'  template <int dim>'
p3663
aS'  double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const'
p3664
aS'  {'
p3665
aS'    Vector<double> residual(dof_handler.n_dofs());'
p3666
aS'    Vector<double> evaluation_point(dof_handler.n_dofs());'
p3667
aS'    evaluation_point = current_solution;'
p3668
aS'    evaluation_point.add(alpha, newton_update);'
p3669
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p3670
aS'    FEValues<dim>     fe_values(fe,'
p3671
aS'                            quadrature_formula,'
p3672
aS'                            update_gradients | update_quadrature_points |'
p3673
aS'                              update_JxW_values);'
p3674
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p3675
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p3676
aS'    Vector<double>              cell_residual(dofs_per_cell);'
p3677
aS'    std::vector<Tensor<1, dim>> gradients(n_q_points);'
p3678
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p3679
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p3680
aS'      {'
p3681
aS'        cell_residual = 0;'
p3682
aS'        fe_values.reinit(cell);'
p3683
aS'        fe_values.get_function_gradients(evaluation_point, gradients);'
p3684
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p3685
aS'          {'
p3686
aS'            const double coeff ='
p3687
aS'              1. / std::sqrt(1 + gradients[q] * gradients[q]);'
p3688
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3689
aS'              cell_residual(i) -= (fe_values.shape_grad(i, q) // \\nabla \\phi_i'
p3690
aS'                                   * coeff                    // * a_n'
p3691
aS'                                   * gradients[q]             // * u_n'
p3692
aS'                                   * fe_values.JxW(q));       // * dx'
p3693
aS'          }'
p3694
aS'        cell->get_dof_indices(local_dof_indices);'
p3695
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3696
aS'          residual(local_dof_indices[i]) += cell_residual(i);'
p3697
aS'      }'
p3698
aS'    hanging_node_constraints.condense(residual);'
p3699
aS'    for (types::global_dof_index i :'
p3700
aS'         DoFTools::extract_boundary_dofs(dof_handler))'
p3701
aS'      residual(i) = 0;'
p3702
aS'    return residual.l2_norm();'
p3703
aS'  }'
p3704
aS'  template <int dim>'
p3705
aS'  double MinimalSurfaceProblem<dim>::determine_step_length() const'
p3706
aS'  {'
p3707
aS'    return 0.1;'
p3708
aS'  }'
p3709
aS'  template <int dim>'
p3710
aS'  void MinimalSurfaceProblem<dim>::output_results('
p3711
aS'    const unsigned int refinement_cycle) const'
p3712
aS'  {'
p3713
aS'    DataOut<dim> data_out;'
p3714
aS'    data_out.attach_dof_handler(dof_handler);'
p3715
aS'    data_out.add_data_vector(current_solution, "solution");'
p3716
aS'    data_out.add_data_vector(newton_update, "update");'
p3717
aS'    data_out.build_patches();'
p3718
aS'    const std::string filename ='
p3719
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu";'
p3720
aS'    std::ofstream output(filename);'
p3721
aS'    data_out.write_vtu(output);'
p3722
aS'  }'
p3723
aS'  template <int dim>'
p3724
aS'  void MinimalSurfaceProblem<dim>::run()'
p3725
aS'  {'
p3726
aS'    GridGenerator::hyper_ball(triangulation);'
p3727
aS'    triangulation.refine_global(2);'
p3728
aS'    setup_system(/*first time=*/true);'
p3729
aS'    set_boundary_values();'
p3730
aS'    double       last_residual_norm = std::numeric_limits<double>::max();'
p3731
aS'    unsigned int refinement_cycle   = 0;'
p3732
aS'    do'
p3733
aS'      {'
p3734
aS'        std::cout << "Mesh refinement step " << refinement_cycle << std::endl;'
p3735
aS'        if (refinement_cycle != 0)'
p3736
aS'          refine_mesh();'
p3737
aS'        std::cout << "  Initial residual: " << compute_residual(0) << std::endl;'
p3738
aS'        for (unsigned int inner_iteration = 0; inner_iteration < 5;'
p3739
aS'             ++inner_iteration)'
p3740
aS'          {'
p3741
aS'            assemble_system();'
p3742
aS'            last_residual_norm = system_rhs.l2_norm();'
p3743
aS'            solve();'
p3744
aS'            std::cout << "  Residual: " << compute_residual(0) << std::endl;'
p3745
aS'          }'
p3746
aS'        output_results(refinement_cycle);'
p3747
aS'        ++refinement_cycle;'
p3748
aS'        std::cout << std::endl;'
p3749
aS'      }'
p3750
aS'    while (last_residual_norm > 1e-3);'
p3751
aS'  }'
p3752
aS'} // namespace Step15'
p3753
aS'int main()'
p3754
ag24
aS'  try'
p3755
aS'    {'
p3756
aS'      using namespace Step15;'
p3757
aS'      MinimalSurfaceProblem<2> laplace_problem_2d;'
p3758
aS'      laplace_problem_2d.run();'
p3759
aS'    }'
p3760
aS'  catch (std::exception &exc)'
p3761
aS'    {'
p3762
aS'      std::cerr << std::endl'
p3763
aS'                << std::endl'
p3764
aS'                << "----------------------------------------------------"'
p3765
aS'                << std::endl;'
p3766
aS'      std::cerr << "Exception on processing: " << std::endl'
p3767
aS'                << exc.what() << std::endl'
p3768
aS'                << "Aborting!" << std::endl'
p3769
aS'                << "----------------------------------------------------"'
p3770
aS'                << std::endl;'
p3771
aS'      return 1;'
p3772
aS'    }'
p3773
aS'  catch (...)'
p3774
aS'    {'
p3775
aS'      std::cerr << std::endl'
p3776
aS'                << std::endl'
p3777
aS'                << "----------------------------------------------------"'
p3778
aS'                << std::endl;'
p3779
aS'      std::cerr << "Unknown exception!" << std::endl'
p3780
aS'                << "Aborting!" << std::endl'
p3781
aS'                << "----------------------------------------------------"'
p3782
aS'                << std::endl;'
p3783
aS'      return 1;'
p3784
aS'    }'
p3785
aS'  return 0;'
p3786
ag32
aS'/* ---------------------------------------------------------------------'
p3787
aS' *'
p3788
aS' * Copyright (C) 2003 - 2021 by the deal.II authors'
p3789
aS' *'
p3790
aS' * This file is part of the deal.II library.'
p3791
aS' *'
p3792
aS' * The deal.II library is free software; you can use it, redistribute'
p3793
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p3794
aS' * Public License as published by the Free Software Foundation; either'
p3795
aS' * version 2.1 of the License, or (at your option) any later version.'
p3796
aS' * The full text of the license can be found in the file LICENSE.md at'
p3797
aS' * the top level directory of deal.II.'
p3798
aS' *'
p3799
aS' * ---------------------------------------------------------------------'
p3800
aS' *'
p3801
aS' * Authors: Guido Kanschat, University of Heidelberg, 2003'
p3802
aS' *          Baerbel Janssen, University of Heidelberg, 2010'
p3803
aS' *          Wolfgang Bangerth, Texas A&M University, 2010'
p3804
aS' *          Timo Heister, Clemson University, 2018'
p3805
aS' */'
p3806
aS'#include <deal.II/base/quadrature_lib.h>'
p3807
aS'#include <deal.II/base/function.h>'
p3808
aS'#include <deal.II/base/logstream.h>'
p3809
aS'#include <deal.II/base/utilities.h>'
p3810
aS'#include <deal.II/lac/affine_constraints.h>'
p3811
aS'#include <deal.II/lac/vector.h>'
p3812
aS'#include <deal.II/lac/full_matrix.h>'
p3813
aS'#include <deal.II/lac/sparse_matrix.h>'
p3814
aS'#include <deal.II/lac/solver_cg.h>'
p3815
aS'#include <deal.II/lac/precondition.h>'
p3816
aS'#include <deal.II/grid/tria.h>'
p3817
aS'#include <deal.II/grid/grid_generator.h>'
p3818
aS'#include <deal.II/grid/grid_refinement.h>'
p3819
aS'#include <deal.II/dofs/dof_tools.h>'
p3820
aS'#include <deal.II/fe/fe_q.h>'
p3821
aS'#include <deal.II/fe/fe_values.h>'
p3822
aS'#include <deal.II/numerics/vector_tools.h>'
p3823
aS'#include <deal.II/numerics/data_out.h>'
p3824
aS'#include <deal.II/numerics/error_estimator.h>'
p3825
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p3826
aS'#include <deal.II/multigrid/multigrid.h>'
p3827
aS'#include <deal.II/multigrid/mg_transfer.h>'
p3828
aS'#include <deal.II/multigrid/mg_tools.h>'
p3829
aS'#include <deal.II/multigrid/mg_coarse.h>'
p3830
aS'#include <deal.II/multigrid/mg_smoother.h>'
p3831
aS'#include <deal.II/multigrid/mg_matrix.h>'
p3832
aS'#include <deal.II/meshworker/mesh_loop.h>'
p3833
aS'#include <iostream>'
p3834
aS'#include <fstream>'
p3835
aS'using namespace dealii;'
p3836
aS'namespace Step16'
p3837
ag24
aS'  template <int dim>'
p3838
aS'  struct ScratchData'
p3839
aS'  {'
p3840
aS'    ScratchData(const Mapping<dim> &      mapping,'
p3841
aS'                const FiniteElement<dim> &fe,'
p3842
aS'                const unsigned int        quadrature_degree,'
p3843
aS'                const UpdateFlags         update_flags)'
p3844
aS'      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)'
p3845
aS'    {}'
p3846
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p3847
aS'      : fe_values(scratch_data.fe_values.get_mapping(),'
p3848
aS'                  scratch_data.fe_values.get_fe(),'
p3849
aS'                  scratch_data.fe_values.get_quadrature(),'
p3850
aS'                  scratch_data.fe_values.get_update_flags())'
p3851
aS'    {}'
p3852
aS'    FEValues<dim> fe_values;'
p3853
aS'  };'
p3854
aS'  struct CopyData'
p3855
aS'  {'
p3856
aS'    unsigned int                         level;'
p3857
aS'    FullMatrix<double>                   cell_matrix;'
p3858
aS'    Vector<double>                       cell_rhs;'
p3859
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p3860
aS'    template <class Iterator>'
p3861
aS'    void reinit(const Iterator &cell, unsigned int dofs_per_cell)'
p3862
aS'    {'
p3863
aS'      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p3864
aS'      cell_rhs.reinit(dofs_per_cell);'
p3865
aS'      local_dof_indices.resize(dofs_per_cell);'
p3866
aS'      cell->get_active_or_mg_dof_indices(local_dof_indices);'
p3867
aS'      level = cell->level();'
p3868
aS'    }'
p3869
aS'  };'
p3870
aS'  template <int dim>'
p3871
aS'  class LaplaceProblem'
p3872
aS'  {'
p3873
aS'  public:'
p3874
aS'    LaplaceProblem(const unsigned int degree);'
p3875
aS'    void run();'
p3876
aS'  private:'
p3877
aS'    template <class Iterator>'
p3878
aS'    void cell_worker(const Iterator &  cell,'
p3879
aS'                     ScratchData<dim> &scratch_data,'
p3880
aS'                     CopyData &        copy_data);'
p3881
aS'    void setup_system();'
p3882
aS'    void assemble_system();'
p3883
aS'    void assemble_multigrid();'
p3884
aS'    void solve();'
p3885
aS'    void refine_grid();'
p3886
aS'    void output_results(const unsigned int cycle) const;'
p3887
aS'    Triangulation<dim> triangulation;'
p3888
aS'    FE_Q<dim>          fe;'
p3889
aS'    DoFHandler<dim>    dof_handler;'
p3890
aS'    SparsityPattern      sparsity_pattern;'
p3891
aS'    SparseMatrix<double> system_matrix;'
p3892
aS'    AffineConstraints<double> constraints;'
p3893
aS'    Vector<double> solution;'
p3894
aS'    Vector<double> system_rhs;'
p3895
aS'    const unsigned int degree;'
p3896
aS'    MGLevelObject<SparsityPattern> mg_sparsity_patterns;'
p3897
aS'    MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;'
p3898
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p3899
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_matrices;'
p3900
aS'    MGConstrainedDoFs                   mg_constrained_dofs;'
p3901
aS'  };'
p3902
aS'  template <int dim>'
p3903
aS'  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree)'
p3904
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p3905
aS'    , fe(degree)'
p3906
aS'    , dof_handler(triangulation)'
p3907
aS'    , degree(degree)'
p3908
aS'  {}'
p3909
aS'  template <int dim>'
p3910
aS'  void LaplaceProblem<dim>::setup_system()'
p3911
aS'  {'
p3912
aS'    dof_handler.distribute_dofs(fe);'
p3913
aS'    dof_handler.distribute_mg_dofs();'
p3914
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p3915
aS'              << " (by level: ";'
p3916
aS'    for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p3917
aS'      std::cout << dof_handler.n_dofs(level)'
p3918
aS'                << (level == triangulation.n_levels() - 1 ? ")" : ", ");'
p3919
aS'    std::cout << std::endl;'
p3920
aS'    solution.reinit(dof_handler.n_dofs());'
p3921
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p3922
aS'    constraints.clear();'
p3923
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p3924
aS'    std::set<types::boundary_id> dirichlet_boundary_ids = {0};'
p3925
aS'    Functions::ZeroFunction<dim> homogeneous_dirichlet_bc;'
p3926
aS'    const std::map<types::boundary_id, const Function<dim> *>'
p3927
aS'      dirichlet_boundary_functions = {'
p3928
aS'        {types::boundary_id(0), &homogeneous_dirichlet_bc}};'
p3929
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p3930
aS'                                             dirichlet_boundary_functions,'
p3931
aS'                                             constraints);'
p3932
aS'    constraints.close();'
p3933
aS'    {'
p3934
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p3935
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p3936
aS'      sparsity_pattern.copy_from(dsp);'
p3937
aS'    }'
p3938
aS'    system_matrix.reinit(sparsity_pattern);'
p3939
aS'    mg_constrained_dofs.clear();'
p3940
aS'    mg_constrained_dofs.initialize(dof_handler);'
p3941
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p3942
aS'                                                       dirichlet_boundary_ids);'
p3943
aS'    const unsigned int n_levels = triangulation.n_levels();'
p3944
aS'    mg_interface_matrices.resize(0, n_levels - 1);'
p3945
aS'    mg_matrices.resize(0, n_levels - 1);'
p3946
aS'    mg_sparsity_patterns.resize(0, n_levels - 1);'
p3947
aS'    mg_interface_sparsity_patterns.resize(0, n_levels - 1);'
p3948
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p3949
aS'      {'
p3950
aS'        {'
p3951
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p3952
aS'                                     dof_handler.n_dofs(level));'
p3953
aS'          MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p3954
aS'          mg_sparsity_patterns[level].copy_from(dsp);'
p3955
aS'          mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p3956
aS'        }'
p3957
aS'        {'
p3958
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p3959
aS'                                     dof_handler.n_dofs(level));'
p3960
aS'          MGTools::make_interface_sparsity_pattern(dof_handler,'
p3961
aS'                                                   mg_constrained_dofs,'
p3962
aS'                                                   dsp,'
p3963
aS'                                                   level);'
p3964
aS'          mg_interface_sparsity_patterns[level].copy_from(dsp);'
p3965
aS'          mg_interface_matrices[level].reinit('
p3966
aS'            mg_interface_sparsity_patterns[level]);'
p3967
aS'        }'
p3968
aS'      }'
p3969
aS'  }'
p3970
aS'  template <int dim>'
p3971
aS'  template <class Iterator>'
p3972
aS'  void LaplaceProblem<dim>::cell_worker(const Iterator &  cell,'
p3973
aS'                                        ScratchData<dim> &scratch_data,'
p3974
aS'                                        CopyData &        copy_data)'
p3975
aS'  {'
p3976
aS'    FEValues<dim> &fe_values = scratch_data.fe_values;'
p3977
aS'    fe_values.reinit(cell);'
p3978
aS'    const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();'
p3979
aS'    const unsigned int n_q_points    = fe_values.get_quadrature().size();'
p3980
aS'    copy_data.reinit(cell, dofs_per_cell);'
p3981
aS'    const std::vector<double> &JxW = fe_values.get_JxW_values();'
p3982
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p3983
aS'      {'
p3984
aS'        const double coefficient ='
p3985
aS'          (fe_values.get_quadrature_points()[q][0] < 0.0) ? 1.0 : 0.1;'
p3986
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3987
aS'          {'
p3988
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3989
aS'              {'
p3990
aS'                copy_data.cell_matrix(i, j) +='
p3991
aS'                  coefficient *'
p3992
aS'                  (fe_values.shape_grad(i, q) * fe_values.shape_grad(j, q)) *'
p3993
aS'                  JxW[q];'
p3994
aS'              }'
p3995
aS'            copy_data.cell_rhs(i) += 1.0 * fe_values.shape_value(i, q) * JxW[q];'
p3996
aS'          }'
p3997
aS'      }'
p3998
aS'  }'
p3999
aS'  template <int dim>'
p4000
aS'  void LaplaceProblem<dim>::assemble_system()'
p4001
aS'  {'
p4002
aS'    MappingQ1<dim> mapping;'
p4003
aS'    auto cell_worker ='
p4004
aS'      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p4005
aS'          ScratchData<dim> &                                    scratch_data,'
p4006
aS'          CopyData &                                            copy_data) {'
p4007
aS'        this->cell_worker(cell, scratch_data, copy_data);'
p4008
aS'      };'
p4009
aS'    auto copier = [&](const CopyData &cd) {'
p4010
aS'      this->constraints.distribute_local_to_global(cd.cell_matrix,'
p4011
aS'                                                   cd.cell_rhs,'
p4012
aS'                                                   cd.local_dof_indices,'
p4013
aS'                                                   system_matrix,'
p4014
aS'                                                   system_rhs);'
p4015
aS'    };'
p4016
aS'    const unsigned int n_gauss_points = degree + 1;'
p4017
aS'    ScratchData<dim> scratch_data(mapping,'
p4018
aS'                                  fe,'
p4019
aS'                                  n_gauss_points,'
p4020
aS'                                  update_values | update_gradients |'
p4021
aS'                                    update_JxW_values |'
p4022
aS'                                    update_quadrature_points);'
p4023
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p4024
aS'                          dof_handler.end(),'
p4025
aS'                          cell_worker,'
p4026
aS'                          copier,'
p4027
aS'                          scratch_data,'
p4028
aS'                          CopyData(),'
p4029
aS'                          MeshWorker::assemble_own_cells);'
p4030
aS'  }'
p4031
aS'  template <int dim>'
p4032
aS'  void LaplaceProblem<dim>::assemble_multigrid()'
p4033
aS'  {'
p4034
aS'    MappingQ1<dim>     mapping;'
p4035
aS'    const unsigned int n_levels = triangulation.n_levels();'
p4036
aS'    std::vector<AffineConstraints<double>> boundary_constraints(n_levels);'
p4037
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p4038
aS'      {'
p4039
aS'        IndexSet dofset;'
p4040
aS'        DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p4041
aS'                                                      level,'
p4042
aS'                                                      dofset);'
p4043
aS'        boundary_constraints[level].reinit(dofset);'
p4044
aS'        boundary_constraints[level].add_lines('
p4045
aS'          mg_constrained_dofs.get_refinement_edge_indices(level));'
p4046
aS'        boundary_constraints[level].add_lines('
p4047
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p4048
aS'        boundary_constraints[level].close();'
p4049
aS'      }'
p4050
aS'    auto cell_worker ='
p4051
aS'      [&](const typename DoFHandler<dim>::level_cell_iterator &cell,'
p4052
aS'          ScratchData<dim> &                                   scratch_data,'
p4053
aS'          CopyData &                                           copy_data) {'
p4054
aS'        this->cell_worker(cell, scratch_data, copy_data);'
p4055
aS'      };'
p4056
aS'    auto copier = [&](const CopyData &cd) {'
p4057
aS'      boundary_constraints[cd.level].distribute_local_to_global('
p4058
aS'        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);'
p4059
aS'      const unsigned int dofs_per_cell = cd.local_dof_indices.size();'
p4060
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p4061
aS'        for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p4062
aS'          if (mg_constrained_dofs.is_interface_matrix_entry('
p4063
aS'                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))'
p4064
aS'            {'
p4065
aS'              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],'
p4066
aS'                                                  cd.local_dof_indices[j],'
p4067
aS'                                                  cd.cell_matrix(i, j));'
p4068
aS'            }'
p4069
aS'    };'
p4070
aS'    const unsigned int n_gauss_points = degree + 1;'
p4071
aS'    ScratchData<dim> scratch_data(mapping,'
p4072
aS'                                  fe,'
p4073
aS'                                  n_gauss_points,'
p4074
aS'                                  update_values | update_gradients |'
p4075
aS'                                    update_JxW_values |'
p4076
aS'                                    update_quadrature_points);'
p4077
aS'    MeshWorker::mesh_loop(dof_handler.begin_mg(),'
p4078
aS'                          dof_handler.end_mg(),'
p4079
aS'                          cell_worker,'
p4080
aS'                          copier,'
p4081
aS'                          scratch_data,'
p4082
aS'                          CopyData(),'
p4083
aS'                          MeshWorker::assemble_own_cells);'
p4084
aS'  }'
p4085
aS'  template <int dim>'
p4086
aS'  void LaplaceProblem<dim>::solve()'
p4087
aS'  {'
p4088
aS'    MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);'
p4089
aS'    mg_transfer.build(dof_handler);'
p4090
aS'    FullMatrix<double> coarse_matrix;'
p4091
aS'    coarse_matrix.copy_from(mg_matrices[0]);'
p4092
aS'    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p4093
aS'    coarse_grid_solver.initialize(coarse_matrix);'
p4094
aS'    using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p4095
aS'    mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;'
p4096
aS'    mg_smoother.initialize(mg_matrices);'
p4097
aS'    mg_smoother.set_steps(2);'
p4098
aS'    mg_smoother.set_symmetric(true);'
p4099
aS'    mg::Matrix<Vector<double>> mg_matrix(mg_matrices);'
p4100
aS'    mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);'
p4101
aS'    mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);'
p4102
aS'    Multigrid<Vector<double>> mg('
p4103
aS'      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);'
p4104
aS'    mg.set_edge_matrices(mg_interface_down, mg_interface_up);'
p4105
aS'    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p4106
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p4107
aS'    SolverControl            solver_control(1000, 1e-12);'
p4108
aS'    SolverCG<Vector<double>> solver(solver_control);'
p4109
aS'    solution = 0;'
p4110
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p4111
aS'    std::cout << "   Number of CG iterations: " << solver_control.last_step()'
p4112
aS'              << "\\n"'
p4113
aS'              << std::endl;'
p4114
aS'    constraints.distribute(solution);'
p4115
aS'  }'
p4116
aS'  template <int dim>'
p4117
aS'  void LaplaceProblem<dim>::refine_grid()'
p4118
aS'  {'
p4119
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p4120
aS'    KellyErrorEstimator<dim>::estimate('
p4121
aS'      dof_handler,'
p4122
aS'      QGauss<dim - 1>(degree + 2),'
p4123
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p4124
aS'      solution,'
p4125
aS'      estimated_error_per_cell);'
p4126
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p4127
aS'                                                    estimated_error_per_cell,'
p4128
aS'                                                    0.3,'
p4129
aS'                                                    0.03);'
p4130
aS'    triangulation.execute_coarsening_and_refinement();'
p4131
aS'  }'
p4132
aS'  template <int dim>'
p4133
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p4134
aS'  {'
p4135
aS'    DataOut<dim> data_out;'
p4136
aS'    data_out.attach_dof_handler(dof_handler);'
p4137
aS'    data_out.add_data_vector(solution, "solution");'
p4138
aS'    data_out.build_patches();'
p4139
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p4140
aS'    data_out.write_vtk(output);'
p4141
aS'  }'
p4142
aS'  template <int dim>'
p4143
aS'  void LaplaceProblem<dim>::run()'
p4144
aS'  {'
p4145
aS'    for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p4146
aS'      {'
p4147
aS'        std::cout << "Cycle " << cycle << std::endl;'
p4148
aS'        if (cycle == 0)'
p4149
aS'          {'
p4150
aS'            GridGenerator::hyper_ball(triangulation);'
p4151
aS'            triangulation.refine_global(2);'
p4152
aS'          }'
p4153
aS'        else'
p4154
aS'          refine_grid();'
p4155
aS'        std::cout << "   Number of active cells:       "'
p4156
aS'                  << triangulation.n_active_cells() << std::endl;'
p4157
aS'        setup_system();'
p4158
aS'        assemble_system();'
p4159
aS'        assemble_multigrid();'
p4160
aS'        solve();'
p4161
aS'        output_results(cycle);'
p4162
aS'      }'
p4163
aS'  }'
p4164
aS'} // namespace Step16'
p4165
aS'int main()'
p4166
ag24
aS'  try'
p4167
aS'    {'
p4168
aS'      using namespace Step16;'
p4169
aS'      LaplaceProblem<2> laplace_problem(1);'
p4170
aS'      laplace_problem.run();'
p4171
aS'    }'
p4172
aS'  catch (std::exception &exc)'
p4173
aS'    {'
p4174
aS'      std::cerr << std::endl'
p4175
aS'                << std::endl'
p4176
aS'                << "----------------------------------------------------"'
p4177
aS'                << std::endl;'
p4178
aS'      std::cerr << "Exception on processing: " << std::endl'
p4179
aS'                << exc.what() << std::endl'
p4180
aS'                << "Aborting!" << std::endl'
p4181
aS'                << "----------------------------------------------------"'
p4182
aS'                << std::endl;'
p4183
aS'      return 1;'
p4184
aS'    }'
p4185
aS'  catch (...)'
p4186
aS'    {'
p4187
aS'      std::cerr << std::endl'
p4188
aS'                << std::endl'
p4189
aS'                << "----------------------------------------------------"'
p4190
aS'                << std::endl;'
p4191
aS'      std::cerr << "Unknown exception!" << std::endl'
p4192
aS'                << "Aborting!" << std::endl'
p4193
aS'                << "----------------------------------------------------"'
p4194
aS'                << std::endl;'
p4195
aS'      return 1;'
p4196
aS'    }'
p4197
aS'  return 0;'
p4198
ag32
aS'/* ---------------------------------------------------------------------'
p4199
aS' *'
p4200
aS' * Copyright (C) 2003 - 2021 by the deal.II authors'
p4201
aS' *'
p4202
aS' * This file is part of the deal.II library.'
p4203
aS' *'
p4204
aS' * The deal.II library is free software; you can use it, redistribute'
p4205
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p4206
aS' * Public License as published by the Free Software Foundation; either'
p4207
aS' * version 2.1 of the License, or (at your option) any later version.'
p4208
aS' * The full text of the license can be found in the file LICENSE.md at'
p4209
aS' * the top level directory of deal.II.'
p4210
aS' *'
p4211
aS' * ---------------------------------------------------------------------'
p4212
aS' *'
p4213
aS' * Authors: Guido Kanschat, University of Heidelberg, 2003'
p4214
aS' *          Baerbel Janssen, University of Heidelberg, 2010'
p4215
aS' *          Wolfgang Bangerth, Texas A&M University, 2010'
p4216
aS' */'
p4217
aS'#include <deal.II/base/quadrature_lib.h>'
p4218
aS'#include <deal.II/base/function.h>'
p4219
aS'#include <deal.II/base/logstream.h>'
p4220
aS'#include <deal.II/base/utilities.h>'
p4221
aS'#include <deal.II/lac/affine_constraints.h>'
p4222
aS'#include <deal.II/lac/vector.h>'
p4223
aS'#include <deal.II/lac/full_matrix.h>'
p4224
aS'#include <deal.II/lac/sparse_matrix.h>'
p4225
aS'#include <deal.II/lac/solver_cg.h>'
p4226
aS'#include <deal.II/lac/precondition.h>'
p4227
aS'#include <deal.II/grid/tria.h>'
p4228
aS'#include <deal.II/grid/grid_generator.h>'
p4229
aS'#include <deal.II/grid/grid_refinement.h>'
p4230
aS'#include <deal.II/dofs/dof_tools.h>'
p4231
aS'#include <deal.II/fe/fe_q.h>'
p4232
aS'#include <deal.II/fe/fe_values.h>'
p4233
aS'#include <deal.II/numerics/vector_tools.h>'
p4234
aS'#include <deal.II/numerics/data_out.h>'
p4235
aS'#include <deal.II/numerics/error_estimator.h>'
p4236
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p4237
aS'#include <deal.II/multigrid/multigrid.h>'
p4238
aS'#include <deal.II/multigrid/mg_transfer.h>'
p4239
aS'#include <deal.II/multigrid/mg_tools.h>'
p4240
aS'#include <deal.II/multigrid/mg_coarse.h>'
p4241
aS'#include <deal.II/multigrid/mg_smoother.h>'
p4242
aS'#include <deal.II/multigrid/mg_matrix.h>'
p4243
aS'#include <deal.II/meshworker/dof_info.h>'
p4244
aS'#include <deal.II/meshworker/integration_info.h>'
p4245
aS'#include <deal.II/meshworker/simple.h>'
p4246
aS'#include <deal.II/meshworker/output.h>'
p4247
aS'#include <deal.II/meshworker/loop.h>'
p4248
aS'#include <deal.II/integrators/laplace.h>'
p4249
aS'#include <deal.II/integrators/l2.h>'
p4250
aS'#include <iostream>'
p4251
aS'#include <fstream>'
p4252
aS'using namespace dealii;'
p4253
aS'namespace Step16'
p4254
ag24
aS'  template <int dim>'
p4255
aS'  class LaplaceIntegrator : public MeshWorker::LocalIntegrator<dim>'
p4256
aS'  {'
p4257
aS'  public:'
p4258
aS'    LaplaceIntegrator();'
p4259
aS'    virtual void cell(MeshWorker::DoFInfo<dim> &        dinfo,'
p4260
aS'                      MeshWorker::IntegrationInfo<dim> &info) const override;'
p4261
aS'  };'
p4262
aS'  template <int dim>'
p4263
aS'  LaplaceIntegrator<dim>::LaplaceIntegrator()'
p4264
aS'    : MeshWorker::LocalIntegrator<dim>(true, false, false)'
p4265
aS'  {}'
p4266
aS'  template <int dim>'
p4267
aS'  void'
p4268
aS'  LaplaceIntegrator<dim>::cell(MeshWorker::DoFInfo<dim> &        dinfo,'
p4269
aS'                               MeshWorker::IntegrationInfo<dim> &info) const'
p4270
aS'  {'
p4271
aS'    AssertDimension(dinfo.n_matrices(), 1);'
p4272
aS'    const double coefficient = (dinfo.cell->center()(0) > 0.) ? .1 : 1.;'
p4273
aS'    LocalIntegrators::Laplace::cell_matrix(dinfo.matrix(0, false).matrix,'
p4274
aS'                                           info.fe_values(0),'
p4275
aS'                                           coefficient);'
p4276
aS'    if (dinfo.n_vectors() > 0)'
p4277
aS'      {'
p4278
aS'        std::vector<double> rhs(info.fe_values(0).n_quadrature_points, 1.);'
p4279
aS'        LocalIntegrators::L2::L2(dinfo.vector(0).block(0),'
p4280
aS'                                 info.fe_values(0),'
p4281
aS'                                 rhs);'
p4282
aS'      }'
p4283
aS'  }'
p4284
aS'  template <int dim>'
p4285
aS'  class LaplaceProblem'
p4286
aS'  {'
p4287
aS'  public:'
p4288
aS'    LaplaceProblem(const unsigned int degree);'
p4289
aS'    void run();'
p4290
aS'  private:'
p4291
aS'    void setup_system();'
p4292
aS'    void assemble_system();'
p4293
aS'    void assemble_multigrid();'
p4294
aS'    void solve();'
p4295
aS'    void refine_grid();'
p4296
aS'    void output_results(const unsigned int cycle) const;'
p4297
aS'    Triangulation<dim> triangulation;'
p4298
aS'    FE_Q<dim>          fe;'
p4299
aS'    DoFHandler<dim>    dof_handler;'
p4300
aS'    SparsityPattern      sparsity_pattern;'
p4301
aS'    SparseMatrix<double> system_matrix;'
p4302
aS'    AffineConstraints<double> constraints;'
p4303
aS'    Vector<double> solution;'
p4304
aS'    Vector<double> system_rhs;'
p4305
aS'    const unsigned int degree;'
p4306
aS'    MGLevelObject<SparsityPattern>      mg_sparsity_patterns;'
p4307
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p4308
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_in;'
p4309
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_out;'
p4310
aS'    MGConstrainedDoFs                   mg_constrained_dofs;'
p4311
aS'  };'
p4312
aS'  template <int dim>'
p4313
aS'  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree)'
p4314
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p4315
aS'    , fe(degree)'
p4316
aS'    , dof_handler(triangulation)'
p4317
aS'    , degree(degree)'
p4318
aS'  {}'
p4319
aS'  template <int dim>'
p4320
aS'  void LaplaceProblem<dim>::setup_system()'
p4321
aS'  {'
p4322
aS'    dof_handler.distribute_dofs(fe);'
p4323
aS'    dof_handler.distribute_mg_dofs();'
p4324
aS'    deallog << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p4325
aS'            << " (by level: ";'
p4326
aS'    for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p4327
aS'      deallog << dof_handler.n_dofs(level)'
p4328
aS'              << (level == triangulation.n_levels() - 1 ? ")" : ", ");'
p4329
aS'    deallog << std::endl;'
p4330
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p4331
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p4332
aS'    solution.reinit(dof_handler.n_dofs());'
p4333
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p4334
aS'    constraints.clear();'
p4335
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p4336
aS'    std::set<types::boundary_id> dirichlet_boundary_ids = {0};'
p4337
aS'    Functions::ZeroFunction<dim> homogeneous_dirichlet_bc;'
p4338
aS'    const std::map<types::boundary_id, const Function<dim> *>'
p4339
aS'      dirichlet_boundary_functions = {'
p4340
aS'        {types::boundary_id(0), &homogeneous_dirichlet_bc}};'
p4341
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p4342
aS'                                             dirichlet_boundary_functions,'
p4343
aS'                                             constraints);'
p4344
aS'    constraints.close();'
p4345
aS'    constraints.condense(dsp);'
p4346
aS'    sparsity_pattern.copy_from(dsp);'
p4347
aS'    system_matrix.reinit(sparsity_pattern);'
p4348
aS'    mg_constrained_dofs.clear();'
p4349
aS'    mg_constrained_dofs.initialize(dof_handler);'
p4350
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p4351
aS'                                                       dirichlet_boundary_ids);'
p4352
aS'    const unsigned int n_levels = triangulation.n_levels();'
p4353
aS'    mg_interface_in.resize(0, n_levels - 1);'
p4354
aS'    mg_interface_in.clear_elements();'
p4355
aS'    mg_interface_out.resize(0, n_levels - 1);'
p4356
aS'    mg_interface_out.clear_elements();'
p4357
aS'    mg_matrices.resize(0, n_levels - 1);'
p4358
aS'    mg_matrices.clear_elements();'
p4359
aS'    mg_sparsity_patterns.resize(0, n_levels - 1);'
p4360
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p4361
aS'      {'
p4362
aS'        DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p4363
aS'                                   dof_handler.n_dofs(level));'
p4364
aS'        MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p4365
aS'        mg_sparsity_patterns[level].copy_from(dsp);'
p4366
aS'        mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p4367
aS'        mg_interface_in[level].reinit(mg_sparsity_patterns[level]);'
p4368
aS'        mg_interface_out[level].reinit(mg_sparsity_patterns[level]);'
p4369
aS'      }'
p4370
aS'  }'
p4371
aS'  template <int dim>'
p4372
aS'  void LaplaceProblem<dim>::assemble_system()'
p4373
aS'  {'
p4374
aS'    MappingQ1<dim>                      mapping;'
p4375
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p4376
aS'    UpdateFlags                         update_flags ='
p4377
aS'      update_values | update_gradients | update_hessians;'
p4378
aS'    info_box.add_update_flags_all(update_flags);'
p4379
aS'    info_box.initialize(fe, mapping);'
p4380
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p4381
aS'    MeshWorker::Assembler::SystemSimple<SparseMatrix<double>, Vector<double>>'
p4382
aS'      assembler;'
p4383
aS'    assembler.initialize(constraints);'
p4384
aS'    assembler.initialize(system_matrix, system_rhs);'
p4385
aS'    LaplaceIntegrator<dim> matrix_integrator;'
p4386
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p4387
aS'                                           dof_handler.end(),'
p4388
aS'                                           dof_info,'
p4389
aS'                                           info_box,'
p4390
aS'                                           matrix_integrator,'
p4391
aS'                                           assembler);'
p4392
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p4393
aS'      if (constraints.is_constrained(i))'
p4394
aS'        system_matrix.set(i, i, 1.);'
p4395
aS'  }'
p4396
aS'  template <int dim>'
p4397
aS'  void LaplaceProblem<dim>::assemble_multigrid()'
p4398
aS'  {'
p4399
aS'    MappingQ1<dim>                      mapping;'
p4400
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p4401
aS'    UpdateFlags                         update_flags ='
p4402
aS'      update_values | update_gradients | update_hessians;'
p4403
aS'    info_box.add_update_flags_all(update_flags);'
p4404
aS'    info_box.initialize(fe, mapping);'
p4405
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p4406
aS'    MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler;'
p4407
aS'    assembler.initialize(mg_constrained_dofs);'
p4408
aS'    assembler.initialize(mg_matrices);'
p4409
aS'    assembler.initialize_interfaces(mg_interface_in, mg_interface_out);'
p4410
aS'    LaplaceIntegrator<dim> matrix_integrator;'
p4411
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_mg(),'
p4412
aS'                                           dof_handler.end_mg(),'
p4413
aS'                                           dof_info,'
p4414
aS'                                           info_box,'
p4415
aS'                                           matrix_integrator,'
p4416
aS'                                           assembler);'
p4417
aS'    const unsigned int nlevels = triangulation.n_levels();'
p4418
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p4419
aS'      {'
p4420
aS'        for (unsigned int i = 0; i < dof_handler.n_dofs(level); ++i)'
p4421
aS'          if (mg_constrained_dofs.is_boundary_index(level, i) ||'
p4422
aS'              mg_constrained_dofs.at_refinement_edge(level, i))'
p4423
aS'            mg_matrices[level].set(i, i, 1.);'
p4424
aS'      }'
p4425
aS'  }'
p4426
aS'  template <int dim>'
p4427
aS'  void LaplaceProblem<dim>::solve()'
p4428
aS'  {'
p4429
aS'    MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);'
p4430
aS'    mg_transfer.build(dof_handler);'
p4431
aS'    FullMatrix<double> coarse_matrix;'
p4432
aS'    coarse_matrix.copy_from(mg_matrices[0]);'
p4433
aS'    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p4434
aS'    coarse_grid_solver.initialize(coarse_matrix);'
p4435
aS'    using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p4436
aS'    mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;'
p4437
aS'    mg_smoother.initialize(mg_matrices);'
p4438
aS'    mg_smoother.set_steps(2);'
p4439
aS'    mg_smoother.set_symmetric(true);'
p4440
aS'    mg::Matrix<Vector<double>> mg_matrix(mg_matrices);'
p4441
aS'    mg::Matrix<Vector<double>> mg_interface_up(mg_interface_in);'
p4442
aS'    mg::Matrix<Vector<double>> mg_interface_down(mg_interface_out);'
p4443
aS'    Multigrid<Vector<double>> mg('
p4444
aS'      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);'
p4445
aS'    mg.set_edge_matrices(mg_interface_down, mg_interface_up);'
p4446
aS'    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p4447
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p4448
aS'    SolverControl            solver_control(1000, 1e-12);'
p4449
aS'    SolverCG<Vector<double>> solver(solver_control);'
p4450
aS'    solution = 0;'
p4451
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p4452
aS'    constraints.distribute(solution);'
p4453
aS'  }'
p4454
aS'  template <int dim>'
p4455
aS'  void LaplaceProblem<dim>::refine_grid()'
p4456
aS'  {'
p4457
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p4458
aS'    KellyErrorEstimator<dim>::estimate('
p4459
aS'      dof_handler,'
p4460
aS'      QGauss<dim - 1>(fe.degree + 1),'
p4461
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p4462
aS'      solution,'
p4463
aS'      estimated_error_per_cell);'
p4464
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p4465
aS'                                                    estimated_error_per_cell,'
p4466
aS'                                                    0.3,'
p4467
aS'                                                    0.03);'
p4468
aS'    triangulation.execute_coarsening_and_refinement();'
p4469
aS'  }'
p4470
aS'  template <int dim>'
p4471
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p4472
aS'  {'
p4473
aS'    DataOut<dim> data_out;'
p4474
aS'    data_out.attach_dof_handler(dof_handler);'
p4475
aS'    data_out.add_data_vector(solution, "solution");'
p4476
aS'    data_out.build_patches();'
p4477
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p4478
aS'    data_out.write_vtk(output);'
p4479
aS'  }'
p4480
aS'  template <int dim>'
p4481
aS'  void LaplaceProblem<dim>::run()'
p4482
aS'  {'
p4483
aS'    for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p4484
aS'      {'
p4485
aS'        deallog << "Cycle " << cycle << std::endl;'
p4486
aS'        if (cycle == 0)'
p4487
aS'          {'
p4488
aS'            GridGenerator::hyper_ball(triangulation);'
p4489
aS'            triangulation.refine_global(1);'
p4490
aS'          }'
p4491
aS'        else'
p4492
aS'          refine_grid();'
p4493
aS'        deallog << "   Number of active cells:       "'
p4494
aS'                << triangulation.n_active_cells() << std::endl;'
p4495
aS'        setup_system();'
p4496
aS'        assemble_system();'
p4497
aS'        assemble_multigrid();'
p4498
aS'        solve();'
p4499
aS'        output_results(cycle);'
p4500
aS'      }'
p4501
aS'  }'
p4502
aS'} // namespace Step16'
p4503
aS'int main()'
p4504
ag24
aS'  try'
p4505
aS'    {'
p4506
aS'      using namespace Step16;'
p4507
aS'      deallog.depth_console(2);'
p4508
aS'      LaplaceProblem<2> laplace_problem(1);'
p4509
aS'      laplace_problem.run();'
p4510
aS'    }'
p4511
aS'  catch (std::exception &exc)'
p4512
aS'    {'
p4513
aS'      std::cerr << std::endl'
p4514
aS'                << std::endl'
p4515
aS'                << "----------------------------------------------------"'
p4516
aS'                << std::endl;'
p4517
aS'      std::cerr << "Exception on processing: " << std::endl'
p4518
aS'                << exc.what() << std::endl'
p4519
aS'                << "Aborting!" << std::endl'
p4520
aS'                << "----------------------------------------------------"'
p4521
aS'                << std::endl;'
p4522
aS'      return 1;'
p4523
aS'    }'
p4524
aS'  catch (...)'
p4525
aS'    {'
p4526
aS'      std::cerr << std::endl'
p4527
aS'                << std::endl'
p4528
aS'                << "----------------------------------------------------"'
p4529
aS'                << std::endl;'
p4530
aS'      std::cerr << "Unknown exception!" << std::endl'
p4531
aS'                << "Aborting!" << std::endl'
p4532
aS'                << "----------------------------------------------------"'
p4533
aS'                << std::endl;'
p4534
aS'      return 1;'
p4535
aS'    }'
p4536
aS'  return 0;'
p4537
ag32
aS'/* ---------------------------------------------------------------------'
p4538
aS' *'
p4539
aS' * Copyright (C) 2000 - 2021 by the deal.II authors'
p4540
aS' *'
p4541
aS' * This file is part of the deal.II library.'
p4542
aS' *'
p4543
aS' * The deal.II library is free software; you can use it, redistribute'
p4544
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p4545
aS' * Public License as published by the Free Software Foundation; either'
p4546
aS' * version 2.1 of the License, or (at your option) any later version.'
p4547
aS' * The full text of the license can be found in the file LICENSE.md at'
p4548
aS' * the top level directory of deal.II.'
p4549
aS' *'
p4550
aS' * ---------------------------------------------------------------------'
p4551
aS' *'
p4552
aS' * Author: Wolfgang Bangerth, University of Texas at Austin, 2000, 2004'
p4553
aS' *         Wolfgang Bangerth, Texas A&M University, 2016'
p4554
aS' */'
p4555
aS'#include <deal.II/base/quadrature_lib.h>'
p4556
aS'#include <deal.II/base/function.h>'
p4557
aS'#include <deal.II/base/logstream.h>'
p4558
aS'#include <deal.II/base/multithread_info.h>'
p4559
aS'#include <deal.II/lac/vector.h>'
p4560
aS'#include <deal.II/lac/full_matrix.h>'
p4561
aS'#include <deal.II/lac/affine_constraints.h>'
p4562
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p4563
aS'#include <deal.II/lac/sparsity_tools.h>'
p4564
aS'#include <deal.II/grid/tria.h>'
p4565
aS'#include <deal.II/grid/grid_generator.h>'
p4566
aS'#include <deal.II/grid/grid_refinement.h>'
p4567
aS'#include <deal.II/dofs/dof_handler.h>'
p4568
aS'#include <deal.II/dofs/dof_tools.h>'
p4569
aS'#include <deal.II/fe/fe_values.h>'
p4570
aS'#include <deal.II/fe/fe_system.h>'
p4571
aS'#include <deal.II/fe/fe_q.h>'
p4572
aS'#include <deal.II/numerics/vector_tools.h>'
p4573
aS'#include <deal.II/numerics/matrix_tools.h>'
p4574
aS'#include <deal.II/numerics/data_out.h>'
p4575
aS'#include <deal.II/numerics/error_estimator.h>'
p4576
aS'#include <deal.II/base/conditional_ostream.h>'
p4577
aS'#include <deal.II/base/mpi.h>'
p4578
aS'#include <deal.II/lac/petsc_vector.h>'
p4579
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p4580
aS'#include <deal.II/lac/petsc_solver.h>'
p4581
aS'#include <deal.II/lac/petsc_precondition.h>'
p4582
aS'#include <deal.II/grid/grid_tools.h>'
p4583
aS'#include <deal.II/dofs/dof_renumbering.h>'
p4584
aS'#include <fstream>'
p4585
aS'#include <iostream>'
p4586
aS'namespace Step17'
p4587
ag24
aS'  using namespace dealii;'
p4588
aS'  template <int dim>'
p4589
aS'  class ElasticProblem'
p4590
aS'  {'
p4591
aS'  public:'
p4592
aS'    ElasticProblem();'
p4593
aS'    void run();'
p4594
aS'  private:'
p4595
aS'    void         setup_system();'
p4596
aS'    void         assemble_system();'
p4597
aS'    unsigned int solve();'
p4598
aS'    void         refine_grid();'
p4599
aS'    void         output_results(const unsigned int cycle) const;'
p4600
aS'    MPI_Comm mpi_communicator;'
p4601
aS'    const unsigned int n_mpi_processes;'
p4602
aS'    const unsigned int this_mpi_process;'
p4603
aS'    ConditionalOStream pcout;'
p4604
aS'    Triangulation<dim> triangulation;'
p4605
aS'    FESystem<dim>      fe;'
p4606
aS'    DoFHandler<dim>    dof_handler;'
p4607
aS'    AffineConstraints<double> hanging_node_constraints;'
p4608
aS'    PETScWrappers::MPI::SparseMatrix system_matrix;'
p4609
aS'    PETScWrappers::MPI::Vector solution;'
p4610
aS'    PETScWrappers::MPI::Vector system_rhs;'
p4611
aS'  };'
p4612
aS'  template <int dim>'
p4613
aS'  class RightHandSide : public Function<dim>'
p4614
aS'  {'
p4615
aS'  public:'
p4616
aS'    virtual void vector_value(const Point<dim> &p,'
p4617
aS'                              Vector<double> &  values) const override'
p4618
aS'    {'
p4619
aS'      Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim));'
p4620
aS'      Assert(dim >= 2, ExcInternalError());'
p4621
aS'      Point<dim> point_1, point_2;'
p4622
aS'      point_1(0) = 0.5;'
p4623
aS'      point_2(0) = -0.5;'
p4624
aS'      if (((p - point_1).norm_square() < 0.2 * 0.2) ||'
p4625
aS'          ((p - point_2).norm_square() < 0.2 * 0.2))'
p4626
aS'        values(0) = 1;'
p4627
aS'      else'
p4628
aS'        values(0) = 0;'
p4629
aS'      if (p.square() < 0.2 * 0.2)'
p4630
aS'        values(1) = 1;'
p4631
aS'      else'
p4632
aS'        values(1) = 0;'
p4633
aS'    }'
p4634
aS'    virtual void'
p4635
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p4636
aS'                      std::vector<Vector<double>> &  value_list) const override'
p4637
aS'    {'
p4638
aS'      const unsigned int n_points = points.size();'
p4639
aS'      Assert(value_list.size() == n_points,'
p4640
aS'             ExcDimensionMismatch(value_list.size(), n_points));'
p4641
aS'      for (unsigned int p = 0; p < n_points; ++p)'
p4642
aS'        RightHandSide<dim>::vector_value(points[p], value_list[p]);'
p4643
aS'    }'
p4644
aS'  };'
p4645
aS'  template <int dim>'
p4646
aS'  ElasticProblem<dim>::ElasticProblem()'
p4647
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p4648
aS'    , n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator))'
p4649
aS'    , this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator))'
p4650
aS'    , pcout(std::cout, (this_mpi_process == 0))'
p4651
aS'    , fe(FE_Q<dim>(1), dim)'
p4652
aS'    , dof_handler(triangulation)'
p4653
aS'  {}'
p4654
aS'  template <int dim>'
p4655
aS'  void ElasticProblem<dim>::setup_system()'
p4656
aS'  {'
p4657
aS'    GridTools::partition_triangulation(n_mpi_processes, triangulation);'
p4658
aS'    dof_handler.distribute_dofs(fe);'
p4659
aS'    DoFRenumbering::subdomain_wise(dof_handler);'
p4660
aS'    hanging_node_constraints.clear();'
p4661
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p4662
aS'                                            hanging_node_constraints);'
p4663
aS'    hanging_node_constraints.close();'
p4664
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p4665
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p4666
aS'                                    dsp,'
p4667
aS'                                    hanging_node_constraints,'
p4668
aS'                                    false);'
p4669
aS'    const std::vector<IndexSet> locally_owned_dofs_per_proc ='
p4670
aS'      DoFTools::locally_owned_dofs_per_subdomain(dof_handler);'
p4671
aS'    const IndexSet locally_owned_dofs ='
p4672
aS'      locally_owned_dofs_per_proc[this_mpi_process];'
p4673
aS'    system_matrix.reinit(locally_owned_dofs,'
p4674
aS'                         locally_owned_dofs,'
p4675
aS'                         dsp,'
p4676
aS'                         mpi_communicator);'
p4677
aS'    solution.reinit(locally_owned_dofs, mpi_communicator);'
p4678
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p4679
aS'  }'
p4680
aS'  template <int dim>'
p4681
aS'  void ElasticProblem<dim>::assemble_system()'
p4682
aS'  {'
p4683
aS'    QGauss<dim>   quadrature_formula(fe.degree + 1);'
p4684
aS'    FEValues<dim> fe_values(fe,'
p4685
aS'                            quadrature_formula,'
p4686
aS'                            update_values | update_gradients |'
p4687
aS'                              update_quadrature_points | update_JxW_values);'
p4688
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p4689
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p4690
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p4691
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p4692
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p4693
aS'    std::vector<double> lambda_values(n_q_points);'
p4694
aS'    std::vector<double> mu_values(n_q_points);'
p4695
aS'    Functions::ConstantFunction<dim> lambda(1.), mu(1.);'
p4696
aS'    RightHandSide<dim>          right_hand_side;'
p4697
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim));'
p4698
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p4699
aS'      if (cell->subdomain_id() == this_mpi_process)'
p4700
aS'        {'
p4701
aS'          cell_matrix = 0;'
p4702
aS'          cell_rhs    = 0;'
p4703
aS'          fe_values.reinit(cell);'
p4704
aS'          lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p4705
aS'          mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p4706
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p4707
aS'            {'
p4708
aS'              const unsigned int component_i ='
p4709
aS'                fe.system_to_component_index(i).first;'
p4710
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p4711
aS'                {'
p4712
aS'                  const unsigned int component_j ='
p4713
aS'                    fe.system_to_component_index(j).first;'
p4714
aS'                  for (unsigned int q_point = 0; q_point < n_q_points;'
p4715
aS'                       ++q_point)'
p4716
aS'                    {'
p4717
aS'                      cell_matrix(i, j) +='
p4718
aS'                        ((fe_values.shape_grad(i, q_point)[component_i] *'
p4719
aS'                          fe_values.shape_grad(j, q_point)[component_j] *'
p4720
aS'                          lambda_values[q_point]) +'
p4721
aS'                         (fe_values.shape_grad(i, q_point)[component_j] *'
p4722
aS'                          fe_values.shape_grad(j, q_point)[component_i] *'
p4723
aS'                          mu_values[q_point]) +'
p4724
aS'                         ((component_i == component_j) ?'
p4725
aS'                            (fe_values.shape_grad(i, q_point) *'
p4726
aS'                             fe_values.shape_grad(j, q_point) *'
p4727
aS'                             mu_values[q_point]) :'
p4728
aS'                            0)) *'
p4729
aS'                        fe_values.JxW(q_point);'
p4730
aS'                    }'
p4731
aS'                }'
p4732
aS'            }'
p4733
aS'          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p4734
aS'                                            rhs_values);'
p4735
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p4736
aS'            {'
p4737
aS'              const unsigned int component_i ='
p4738
aS'                fe.system_to_component_index(i).first;'
p4739
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p4740
aS'                cell_rhs(i) += fe_values.shape_value(i, q_point) *'
p4741
aS'                               rhs_values[q_point](component_i) *'
p4742
aS'                               fe_values.JxW(q_point);'
p4743
aS'            }'
p4744
aS'          cell->get_dof_indices(local_dof_indices);'
p4745
aS'          hanging_node_constraints.distribute_local_to_global(cell_matrix,'
p4746
aS'                                                              cell_rhs,'
p4747
aS'                                                              local_dof_indices,'
p4748
aS'                                                              system_matrix,'
p4749
aS'                                                              system_rhs);'
p4750
aS'        }'
p4751
aS'    system_matrix.compress(VectorOperation::add);'
p4752
aS'    system_rhs.compress(VectorOperation::add);'
p4753
aS'    std::map<types::global_dof_index, double> boundary_values;'
p4754
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p4755
aS'                                             0,'
p4756
aS'                                             Functions::ZeroFunction<dim>(dim),'
p4757
aS'                                             boundary_values);'
p4758
aS'    MatrixTools::apply_boundary_values('
p4759
aS'      boundary_values, system_matrix, solution, system_rhs, false);'
p4760
aS'  }'
p4761
aS'  template <int dim>'
p4762
aS'  unsigned int ElasticProblem<dim>::solve()'
p4763
aS'  {'
p4764
aS'    SolverControl solver_control(solution.size(), 1e-8 * system_rhs.l2_norm());'
p4765
aS'    PETScWrappers::SolverCG cg(solver_control, mpi_communicator);'
p4766
aS'    PETScWrappers::PreconditionBlockJacobi preconditioner(system_matrix);'
p4767
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p4768
aS'    Vector<double> localized_solution(solution);'
p4769
aS'    hanging_node_constraints.distribute(localized_solution);'
p4770
aS'    solution = localized_solution;'
p4771
aS'    return solver_control.last_step();'
p4772
aS'  }'
p4773
aS'  template <int dim>'
p4774
aS'  void ElasticProblem<dim>::refine_grid()'
p4775
aS'  {'
p4776
aS'    const Vector<double> localized_solution(solution);'
p4777
aS'    Vector<float> local_error_per_cell(triangulation.n_active_cells());'
p4778
aS'    KellyErrorEstimator<dim>::estimate(dof_handler,'
p4779
aS'                                       QGauss<dim - 1>(fe.degree + 1),'
p4780
aS'                                       {},'
p4781
aS'                                       localized_solution,'
p4782
aS'                                       local_error_per_cell,'
p4783
aS'                                       ComponentMask(),'
p4784
aS'                                       nullptr,'
p4785
aS'                                       MultithreadInfo::n_threads(),'
p4786
aS'                                       this_mpi_process);'
p4787
aS'    const unsigned int n_local_cells ='
p4788
aS'      GridTools::count_cells_with_subdomain_association(triangulation,'
p4789
aS'                                                        this_mpi_process);'
p4790
aS'    PETScWrappers::MPI::Vector distributed_all_errors('
p4791
aS'      mpi_communicator, triangulation.n_active_cells(), n_local_cells);'
p4792
aS'    for (unsigned int i = 0; i < local_error_per_cell.size(); ++i)'
p4793
aS'      if (local_error_per_cell(i) != 0)'
p4794
aS'        distributed_all_errors(i) = local_error_per_cell(i);'
p4795
aS'    distributed_all_errors.compress(VectorOperation::insert);'
p4796
aS'    const Vector<float> localized_all_errors(distributed_all_errors);'
p4797
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p4798
aS'                                                    localized_all_errors,'
p4799
aS'                                                    0.3,'
p4800
aS'                                                    0.03);'
p4801
aS'    triangulation.execute_coarsening_and_refinement();'
p4802
aS'  }'
p4803
aS'  template <int dim>'
p4804
aS'  void ElasticProblem<dim>::output_results(const unsigned int cycle) const'
p4805
aS'  {'
p4806
aS'    const Vector<double> localized_solution(solution);'
p4807
aS'    if (this_mpi_process == 0)'
p4808
aS'      {'
p4809
aS'        std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p4810
aS'        DataOut<dim> data_out;'
p4811
aS'        data_out.attach_dof_handler(dof_handler);'
p4812
aS'        std::vector<std::string> solution_names;'
p4813
aS'        switch (dim)'
p4814
aS'          {'
p4815
aS'            case 1:'
p4816
aS'              solution_names.emplace_back("displacement");'
p4817
aS'              break;'
p4818
aS'            case 2:'
p4819
aS'              solution_names.emplace_back("x_displacement");'
p4820
aS'              solution_names.emplace_back("y_displacement");'
p4821
aS'              break;'
p4822
aS'            case 3:'
p4823
aS'              solution_names.emplace_back("x_displacement");'
p4824
aS'              solution_names.emplace_back("y_displacement");'
p4825
aS'              solution_names.emplace_back("z_displacement");'
p4826
aS'              break;'
p4827
aS'            default:'
p4828
aS'              Assert(false, ExcInternalError());'
p4829
aS'          }'
p4830
aS'        data_out.add_data_vector(localized_solution, solution_names);'
p4831
aS'        std::vector<unsigned int> partition_int(triangulation.n_active_cells());'
p4832
aS'        GridTools::get_subdomain_association(triangulation, partition_int);'
p4833
aS'        const Vector<double> partitioning(partition_int.begin(),'
p4834
aS'                                          partition_int.end());'
p4835
aS'        data_out.add_data_vector(partitioning, "partitioning");'
p4836
aS'        data_out.build_patches();'
p4837
aS'        data_out.write_vtk(output);'
p4838
aS'      }'
p4839
aS'  }'
p4840
aS'  template <int dim>'
p4841
aS'  void ElasticProblem<dim>::run()'
p4842
aS'  {'
p4843
aS'    for (unsigned int cycle = 0; cycle < 10; ++cycle)'
p4844
aS'      {'
p4845
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p4846
aS'        if (cycle == 0)'
p4847
aS'          {'
p4848
aS'            GridGenerator::hyper_cube(triangulation, -1, 1);'
p4849
aS'            triangulation.refine_global(3);'
p4850
aS'          }'
p4851
aS'        else'
p4852
aS'          refine_grid();'
p4853
aS'        pcout << "   Number of active cells:       "'
p4854
aS'              << triangulation.n_active_cells() << std::endl;'
p4855
aS'        setup_system();'
p4856
aS'        pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p4857
aS'              << " (by partition:";'
p4858
aS'        for (unsigned int p = 0; p < n_mpi_processes; ++p)'
p4859
aS"          pcout << (p == 0 ? ' ' : '+')"
p4860
aS'                << (DoFTools::count_dofs_with_subdomain_association(dof_handler,'
p4861
aS'                                                                    p));'
p4862
aS'        pcout << ")" << std::endl;'
p4863
aS'        assemble_system();'
p4864
aS'        const unsigned int n_iterations = solve();'
p4865
aS'        pcout << "   Solver converged in " << n_iterations << " iterations."'
p4866
aS'              << std::endl;'
p4867
aS'        output_results(cycle);'
p4868
aS'      }'
p4869
aS'  }'
p4870
aS'} // namespace Step17'
p4871
aS'int main(int argc, char **argv)'
p4872
ag24
aS'  try'
p4873
aS'    {'
p4874
aS'      using namespace dealii;'
p4875
aS'      using namespace Step17;'
p4876
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p4877
aS'      ElasticProblem<2> elastic_problem;'
p4878
aS'      elastic_problem.run();'
p4879
aS'    }'
p4880
aS'  catch (std::exception &exc)'
p4881
aS'    {'
p4882
aS'      std::cerr << std::endl'
p4883
aS'                << std::endl'
p4884
aS'                << "----------------------------------------------------"'
p4885
aS'                << std::endl;'
p4886
aS'      std::cerr << "Exception on processing: " << std::endl'
p4887
aS'                << exc.what() << std::endl'
p4888
aS'                << "Aborting!" << std::endl'
p4889
aS'                << "----------------------------------------------------"'
p4890
aS'                << std::endl;'
p4891
aS'      return 1;'
p4892
aS'    }'
p4893
aS'  catch (...)'
p4894
aS'    {'
p4895
aS'      std::cerr << std::endl'
p4896
aS'                << std::endl'
p4897
aS'                << "----------------------------------------------------"'
p4898
aS'                << std::endl;'
p4899
aS'      std::cerr << "Unknown exception!" << std::endl'
p4900
aS'                << "Aborting!" << std::endl'
p4901
aS'                << "----------------------------------------------------"'
p4902
aS'                << std::endl;'
p4903
aS'      return 1;'
p4904
aS'    }'
p4905
aS'  return 0;'
p4906
ag32
aS'/* ---------------------------------------------------------------------'
p4907
aS' *'
p4908
aS' * Copyright (C) 2000 - 2021 by the deal.II authors'
p4909
aS' *'
p4910
aS' * This file is part of the deal.II library.'
p4911
aS' *'
p4912
aS' * The deal.II library is free software; you can use it, redistribute'
p4913
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p4914
aS' * Public License as published by the Free Software Foundation; either'
p4915
aS' * version 2.1 of the License, or (at your option) any later version.'
p4916
aS' * The full text of the license can be found in the file LICENSE.md at'
p4917
aS' * the top level directory of deal.II.'
p4918
aS' *'
p4919
aS' * ---------------------------------------------------------------------'
p4920
aS' *'
p4921
aS' * Author: Wolfgang Bangerth, University of Texas at Austin, 2000, 2004, 2005,'
p4922
aS' * Timo Heister, 2013'
p4923
aS' */'
p4924
aS'#include <deal.II/base/quadrature_lib.h>'
p4925
aS'#include <deal.II/base/function.h>'
p4926
aS'#include <deal.II/base/logstream.h>'
p4927
aS'#include <deal.II/base/multithread_info.h>'
p4928
aS'#include <deal.II/base/conditional_ostream.h>'
p4929
aS'#include <deal.II/base/utilities.h>'
p4930
aS'#include <deal.II/lac/vector.h>'
p4931
aS'#include <deal.II/lac/full_matrix.h>'
p4932
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p4933
aS'#include <deal.II/lac/petsc_vector.h>'
p4934
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p4935
aS'#include <deal.II/lac/petsc_solver.h>'
p4936
aS'#include <deal.II/lac/petsc_precondition.h>'
p4937
aS'#include <deal.II/lac/affine_constraints.h>'
p4938
aS'#include <deal.II/lac/sparsity_tools.h>'
p4939
aS'#include <deal.II/distributed/shared_tria.h>'
p4940
aS'#include <deal.II/grid/tria.h>'
p4941
aS'#include <deal.II/grid/grid_generator.h>'
p4942
aS'#include <deal.II/grid/grid_refinement.h>'
p4943
aS'#include <deal.II/grid/manifold_lib.h>'
p4944
aS'#include <deal.II/grid/grid_tools.h>'
p4945
aS'#include <deal.II/dofs/dof_handler.h>'
p4946
aS'#include <deal.II/dofs/dof_tools.h>'
p4947
aS'#include <deal.II/dofs/dof_renumbering.h>'
p4948
aS'#include <deal.II/fe/fe_values.h>'
p4949
aS'#include <deal.II/fe/fe_system.h>'
p4950
aS'#include <deal.II/fe/fe_q.h>'
p4951
aS'#include <deal.II/numerics/vector_tools.h>'
p4952
aS'#include <deal.II/numerics/matrix_tools.h>'
p4953
aS'#include <deal.II/numerics/data_out.h>'
p4954
aS'#include <deal.II/numerics/error_estimator.h>'
p4955
aS'#include <deal.II/base/symmetric_tensor.h>'
p4956
aS'#include <deal.II/physics/transformations.h>'
p4957
aS'#include <fstream>'
p4958
aS'#include <iostream>'
p4959
aS'#include <iomanip>'
p4960
aS'namespace Step18'
p4961
ag24
aS'  using namespace dealii;'
p4962
aS'  template <int dim>'
p4963
aS'  struct PointHistory'
p4964
aS'  {'
p4965
aS'    SymmetricTensor<2, dim> old_stress;'
p4966
aS'  };'
p4967
aS'  template <int dim>'
p4968
aS'  SymmetricTensor<4, dim> get_stress_strain_tensor(const double lambda,'
p4969
aS'                                                   const double mu)'
p4970
aS'  {'
p4971
aS'    SymmetricTensor<4, dim> tmp;'
p4972
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4973
aS'      for (unsigned int j = 0; j < dim; ++j)'
p4974
aS'        for (unsigned int k = 0; k < dim; ++k)'
p4975
aS'          for (unsigned int l = 0; l < dim; ++l)'
p4976
aS'            tmp[i][j][k][l] = (((i == k) && (j == l) ? mu : 0.0) +'
p4977
aS'                               ((i == l) && (j == k) ? mu : 0.0) +'
p4978
aS'                               ((i == j) && (k == l) ? lambda : 0.0));'
p4979
aS'    return tmp;'
p4980
aS'  }'
p4981
aS'  template <int dim>'
p4982
aS'  inline SymmetricTensor<2, dim> get_strain(const FEValues<dim> &fe_values,'
p4983
aS'                                            const unsigned int   shape_func,'
p4984
aS'                                            const unsigned int   q_point)'
p4985
aS'  {'
p4986
aS'    SymmetricTensor<2, dim> tmp;'
p4987
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4988
aS'      tmp[i][i] = fe_values.shape_grad_component(shape_func, q_point, i)[i];'
p4989
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4990
aS'      for (unsigned int j = i + 1; j < dim; ++j)'
p4991
aS'        tmp[i][j] ='
p4992
aS'          (fe_values.shape_grad_component(shape_func, q_point, i)[j] +'
p4993
aS'           fe_values.shape_grad_component(shape_func, q_point, j)[i]) /'
p4994
aS'          2;'
p4995
aS'    return tmp;'
p4996
aS'  }'
p4997
aS'  template <int dim>'
p4998
aS'  inline SymmetricTensor<2, dim>'
p4999
aS'  get_strain(const std::vector<Tensor<1, dim>> &grad)'
p5000
aS'  {'
p5001
aS'    Assert(grad.size() == dim, ExcInternalError());'
p5002
aS'    SymmetricTensor<2, dim> strain;'
p5003
aS'    for (unsigned int i = 0; i < dim; ++i)'
p5004
aS'      strain[i][i] = grad[i][i];'
p5005
aS'    for (unsigned int i = 0; i < dim; ++i)'
p5006
aS'      for (unsigned int j = i + 1; j < dim; ++j)'
p5007
aS'        strain[i][j] = (grad[i][j] + grad[j][i]) / 2;'
p5008
aS'    return strain;'
p5009
aS'  }'
p5010
aS'  Tensor<2, 2> get_rotation_matrix(const std::vector<Tensor<1, 2>> &grad_u)'
p5011
aS'  {'
p5012
aS'    const double curl = (grad_u[1][0] - grad_u[0][1]);'
p5013
aS'    const double angle = std::atan(curl);'
p5014
aS'    return Physics::Transformations::Rotations::rotation_matrix_2d(-angle);'
p5015
aS'  }'
p5016
aS'  Tensor<2, 3> get_rotation_matrix(const std::vector<Tensor<1, 3>> &grad_u)'
p5017
aS'  {'
p5018
aS'    const Point<3> curl(grad_u[2][1] - grad_u[1][2],'
p5019
aS'                        grad_u[0][2] - grad_u[2][0],'
p5020
aS'                        grad_u[1][0] - grad_u[0][1]);'
p5021
aS'    const double tan_angle = std::sqrt(curl * curl);'
p5022
aS'    const double angle     = std::atan(tan_angle);'
p5023
aS'    if (std::abs(angle) < 1e-9)'
p5024
aS'      {'
p5025
aS'        static const double rotation[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};'
p5026
aS'        static const Tensor<2, 3> rot(rotation);'
p5027
aS'        return rot;'
p5028
aS'      }'
p5029
aS'    const Point<3> axis = curl / tan_angle;'
p5030
aS'    return Physics::Transformations::Rotations::rotation_matrix_3d(axis,'
p5031
aS'                                                                   -angle);'
p5032
aS'  }'
p5033
aS'  template <int dim>'
p5034
aS'  class TopLevel'
p5035
aS'  {'
p5036
aS'  public:'
p5037
aS'    TopLevel();'
p5038
aS'    ~TopLevel();'
p5039
aS'    void run();'
p5040
aS'  private:'
p5041
aS'    void create_coarse_grid();'
p5042
aS'    void setup_system();'
p5043
aS'    void assemble_system();'
p5044
aS'    void solve_timestep();'
p5045
aS'    unsigned int solve_linear_problem();'
p5046
aS'    void output_results() const;'
p5047
aS'    void do_initial_timestep();'
p5048
aS'    void do_timestep();'
p5049
aS'    void refine_initial_grid();'
p5050
aS'    void move_mesh();'
p5051
aS'    void setup_quadrature_point_history();'
p5052
aS'    void update_quadrature_point_history();'
p5053
aS'    parallel::shared::Triangulation<dim> triangulation;'
p5054
aS'    FESystem<dim> fe;'
p5055
aS'    DoFHandler<dim> dof_handler;'
p5056
aS'    AffineConstraints<double> hanging_node_constraints;'
p5057
aS'    const QGauss<dim> quadrature_formula;'
p5058
aS'    std::vector<PointHistory<dim>> quadrature_point_history;'
p5059
aS'    PETScWrappers::MPI::SparseMatrix system_matrix;'
p5060
aS'    PETScWrappers::MPI::Vector system_rhs;'
p5061
aS'    Vector<double> incremental_displacement;'
p5062
aS'    double       present_time;'
p5063
aS'    double       present_timestep;'
p5064
aS'    double       end_time;'
p5065
aS'    unsigned int timestep_no;'
p5066
aS'    MPI_Comm mpi_communicator;'
p5067
aS'    const unsigned int n_mpi_processes;'
p5068
aS'    const unsigned int this_mpi_process;'
p5069
aS'    ConditionalOStream pcout;'
p5070
aS'    IndexSet locally_owned_dofs;'
p5071
aS'    IndexSet locally_relevant_dofs;'
p5072
aS'    static const SymmetricTensor<4, dim> stress_strain_tensor;'
p5073
aS'  };'
p5074
aS'  template <int dim>'
p5075
aS'  class BodyForce : public Function<dim>'
p5076
aS'  {'
p5077
aS'  public:'
p5078
aS'    BodyForce();'
p5079
aS'    virtual void vector_value(const Point<dim> &p,'
p5080
aS'                              Vector<double> &  values) const override;'
p5081
aS'    virtual void'
p5082
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p5083
aS'                      std::vector<Vector<double>> &  value_list) const override;'
p5084
aS'  };'
p5085
aS'  template <int dim>'
p5086
aS'  BodyForce<dim>::BodyForce()'
p5087
aS'    : Function<dim>(dim)'
p5088
aS'  {}'
p5089
aS'  template <int dim>'
p5090
aS'  inline void BodyForce<dim>::vector_value(const Point<dim> & /*p*/,'
p5091
aS'                                           Vector<double> &values) const'
p5092
aS'  {'
p5093
aS'    Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim));'
p5094
aS'    const double g   = 9.81;'
p5095
aS'    const double rho = 7700;'
p5096
aS'    values          = 0;'
p5097
aS'    values(dim - 1) = -rho * g;'
p5098
aS'  }'
p5099
aS'  template <int dim>'
p5100
aS'  void BodyForce<dim>::vector_value_list('
p5101
aS'    const std::vector<Point<dim>> &points,'
p5102
aS'    std::vector<Vector<double>> &  value_list) const'
p5103
aS'  {'
p5104
aS'    const unsigned int n_points = points.size();'
p5105
aS'    Assert(value_list.size() == n_points,'
p5106
aS'           ExcDimensionMismatch(value_list.size(), n_points));'
p5107
aS'    for (unsigned int p = 0; p < n_points; ++p)'
p5108
aS'      BodyForce<dim>::vector_value(points[p], value_list[p]);'
p5109
aS'  }'
p5110
aS'  template <int dim>'
p5111
aS'  class IncrementalBoundaryValues : public Function<dim>'
p5112
aS'  {'
p5113
aS'  public:'
p5114
aS'    IncrementalBoundaryValues(const double present_time,'
p5115
aS'                              const double present_timestep);'
p5116
aS'    virtual void vector_value(const Point<dim> &p,'
p5117
aS'                              Vector<double> &  values) const override;'
p5118
aS'    virtual void'
p5119
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p5120
aS'                      std::vector<Vector<double>> &  value_list) const override;'
p5121
aS'  private:'
p5122
aS'    const double velocity;'
p5123
aS'    const double present_time;'
p5124
aS'    const double present_timestep;'
p5125
aS'  };'
p5126
aS'  template <int dim>'
p5127
aS'  IncrementalBoundaryValues<dim>::IncrementalBoundaryValues('
p5128
aS'    const double present_time,'
p5129
aS'    const double present_timestep)'
p5130
aS'    : Function<dim>(dim)'
p5131
aS'    , velocity(.08)'
p5132
aS'    , present_time(present_time)'
p5133
aS'    , present_timestep(present_timestep)'
p5134
aS'  {}'
p5135
aS'  template <int dim>'
p5136
aS'  void'
p5137
aS'  IncrementalBoundaryValues<dim>::vector_value(const Point<dim> & /*p*/,'
p5138
aS'                                               Vector<double> &values) const'
p5139
aS'  {'
p5140
aS'    Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim));'
p5141
aS'    values    = 0;'
p5142
aS'    values(2) = -present_timestep * velocity;'
p5143
aS'  }'
p5144
aS'  template <int dim>'
p5145
aS'  void IncrementalBoundaryValues<dim>::vector_value_list('
p5146
aS'    const std::vector<Point<dim>> &points,'
p5147
aS'    std::vector<Vector<double>> &  value_list) const'
p5148
aS'  {'
p5149
aS'    const unsigned int n_points = points.size();'
p5150
aS'    Assert(value_list.size() == n_points,'
p5151
aS'           ExcDimensionMismatch(value_list.size(), n_points));'
p5152
aS'    for (unsigned int p = 0; p < n_points; ++p)'
p5153
aS'      IncrementalBoundaryValues<dim>::vector_value(points[p], value_list[p]);'
p5154
aS'  }'
p5155
aS'  template <int dim>'
p5156
aS'  const SymmetricTensor<4, dim> TopLevel<dim>::stress_strain_tensor ='
p5157
aS'    get_stress_strain_tensor<dim>(/*lambda = */ 9.695e10,'
p5158
aS'  template <int dim>'
p5159
aS'  TopLevel<dim>::TopLevel()'
p5160
aS'    : triangulation(MPI_COMM_WORLD)'
p5161
aS'    , fe(FE_Q<dim>(1), dim)'
p5162
aS'    , dof_handler(triangulation)'
p5163
aS'    , quadrature_formula(fe.degree + 1)'
p5164
aS'    , present_time(0.0)'
p5165
aS'    , present_timestep(1.0)'
p5166
aS'    , end_time(10.0)'
p5167
aS'    , timestep_no(0)'
p5168
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p5169
aS'    , n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator))'
p5170
aS'    , this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator))'
p5171
aS'    , pcout(std::cout, this_mpi_process == 0)'
p5172
aS'  {}'
p5173
aS'  template <int dim>'
p5174
aS'  TopLevel<dim>::~TopLevel()'
p5175
aS'  {'
p5176
aS'    dof_handler.clear();'
p5177
aS'  }'
p5178
aS'  template <int dim>'
p5179
aS'  void TopLevel<dim>::run()'
p5180
aS'  {'
p5181
aS'    do_initial_timestep();'
p5182
aS'    while (present_time < end_time)'
p5183
aS'      do_timestep();'
p5184
aS'  }'
p5185
aS'  template <int dim>'
p5186
aS'  void TopLevel<dim>::create_coarse_grid()'
p5187
aS'  {'
p5188
aS'    const double inner_radius = 0.8, outer_radius = 1;'
p5189
aS'    GridGenerator::cylinder_shell(triangulation, 3, inner_radius, outer_radius);'
p5190
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p5191
aS'      for (const auto &face : cell->face_iterators())'
p5192
aS'        if (face->at_boundary())'
p5193
aS'          {'
p5194
aS'            const Point<dim> face_center = face->center();'
p5195
aS'            if (face_center[2] == 0)'
p5196
aS'              face->set_boundary_id(0);'
p5197
aS'            else if (face_center[2] == 3)'
p5198
aS'              face->set_boundary_id(1);'
p5199
aS'            else if (std::sqrt(face_center[0] * face_center[0] +'
p5200
aS'                               face_center[1] * face_center[1]) <'
p5201
aS'                     (inner_radius + outer_radius) / 2)'
p5202
aS'              face->set_boundary_id(2);'
p5203
aS'            else'
p5204
aS'              face->set_boundary_id(3);'
p5205
aS'          }'
p5206
aS'    triangulation.refine_global(1);'
p5207
aS'    setup_quadrature_point_history();'
p5208
aS'  }'
p5209
aS'  template <int dim>'
p5210
aS'  void TopLevel<dim>::setup_system()'
p5211
aS'  {'
p5212
aS'    dof_handler.distribute_dofs(fe);'
p5213
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p5214
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p5215
aS'    hanging_node_constraints.clear();'
p5216
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p5217
aS'                                            hanging_node_constraints);'
p5218
aS'    hanging_node_constraints.close();'
p5219
aS'    DynamicSparsityPattern sparsity_pattern(locally_relevant_dofs);'
p5220
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p5221
aS'                                    sparsity_pattern,'
p5222
aS'                                    hanging_node_constraints,'
p5223
aS'    SparsityTools::distribute_sparsity_pattern(sparsity_pattern,'
p5224
aS'                                               locally_owned_dofs,'
p5225
aS'                                               mpi_communicator,'
p5226
aS'                                               locally_relevant_dofs);'
p5227
aS'    system_matrix.reinit(locally_owned_dofs,'
p5228
aS'                         locally_owned_dofs,'
p5229
aS'                         sparsity_pattern,'
p5230
aS'                         mpi_communicator);'
p5231
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p5232
aS'    incremental_displacement.reinit(dof_handler.n_dofs());'
p5233
aS'  }'
p5234
aS'  template <int dim>'
p5235
aS'  void TopLevel<dim>::assemble_system()'
p5236
aS'  {'
p5237
aS'    system_rhs    = 0;'
p5238
aS'    system_matrix = 0;'
p5239
aS'    FEValues<dim> fe_values(fe,'
p5240
aS'                            quadrature_formula,'
p5241
aS'                            update_values | update_gradients |'
p5242
aS'                              update_quadrature_points | update_JxW_values);'
p5243
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p5244
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p5245
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p5246
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p5247
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p5248
aS'    BodyForce<dim>              body_force;'
p5249
aS'    std::vector<Vector<double>> body_force_values(n_q_points,'
p5250
aS'                                                  Vector<double>(dim));'
p5251
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5252
aS'      if (cell->is_locally_owned())'
p5253
aS'        {'
p5254
aS'          cell_matrix = 0;'
p5255
aS'          cell_rhs    = 0;'
p5256
aS'          fe_values.reinit(cell);'
p5257
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p5258
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p5259
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p5260
aS'                {'
p5261
aS'                  const SymmetricTensor<2, dim>'
p5262
aS'                    eps_phi_i = get_strain(fe_values, i, q_point),'
p5263
aS'                    eps_phi_j = get_strain(fe_values, j, q_point);'
p5264
aS'                  cell_matrix(i, j) += (eps_phi_i *            //'
p5265
aS'                                        stress_strain_tensor * //'
p5266
aS'                                        eps_phi_j              //'
p5267
aS'                                        ) *                    //'
p5268
aS'                                       fe_values.JxW(q_point); //'
p5269
aS'                }'
p5270
aS'          const PointHistory<dim> *local_quadrature_points_data ='
p5271
aS'            reinterpret_cast<PointHistory<dim> *>(cell->user_pointer());'
p5272
aS'          body_force.vector_value_list(fe_values.get_quadrature_points(),'
p5273
aS'                                       body_force_values);'
p5274
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p5275
aS'            {'
p5276
aS'              const unsigned int component_i ='
p5277
aS'                fe.system_to_component_index(i).first;'
p5278
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p5279
aS'                {'
p5280
aS'                  const SymmetricTensor<2, dim> &old_stress ='
p5281
aS'                    local_quadrature_points_data[q_point].old_stress;'
p5282
aS'                  cell_rhs(i) +='
p5283
aS'                    (body_force_values[q_point](component_i) *'
p5284
aS'                       fe_values.shape_value(i, q_point) -'
p5285
aS'                     old_stress * get_strain(fe_values, i, q_point)) *'
p5286
aS'                    fe_values.JxW(q_point);'
p5287
aS'                }'
p5288
aS'            }'
p5289
aS'          cell->get_dof_indices(local_dof_indices);'
p5290
aS'          hanging_node_constraints.distribute_local_to_global(cell_matrix,'
p5291
aS'                                                              cell_rhs,'
p5292
aS'                                                              local_dof_indices,'
p5293
aS'                                                              system_matrix,'
p5294
aS'                                                              system_rhs);'
p5295
aS'        }'
p5296
aS'    system_matrix.compress(VectorOperation::add);'
p5297
aS'    system_rhs.compress(VectorOperation::add);'
p5298
aS'    FEValuesExtractors::Scalar                z_component(dim - 1);'
p5299
aS'    std::map<types::global_dof_index, double> boundary_values;'
p5300
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5301
aS'                                             0,'
p5302
aS'                                             Functions::ZeroFunction<dim>(dim),'
p5303
aS'                                             boundary_values);'
p5304
aS'    VectorTools::interpolate_boundary_values('
p5305
aS'      dof_handler,'
p5306
aS'      1,'
p5307
aS'      IncrementalBoundaryValues<dim>(present_time, present_timestep),'
p5308
aS'      boundary_values,'
p5309
aS'      fe.component_mask(z_component));'
p5310
aS'    PETScWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator);'
p5311
aS'    MatrixTools::apply_boundary_values('
p5312
aS'      boundary_values, system_matrix, tmp, system_rhs, false);'
p5313
aS'    incremental_displacement = tmp;'
p5314
aS'  }'
p5315
aS'  template <int dim>'
p5316
aS'  void TopLevel<dim>::solve_timestep()'
p5317
aS'  {'
p5318
aS'    pcout << "    Assembling system..." << std::flush;'
p5319
aS'    assemble_system();'
p5320
aS'    pcout << " norm of rhs is " << system_rhs.l2_norm() << std::endl;'
p5321
aS'    const unsigned int n_iterations = solve_linear_problem();'
p5322
aS'    pcout << "    Solver converged in " << n_iterations << " iterations."'
p5323
aS'          << std::endl;'
p5324
aS'    pcout << "    Updating quadrature point data..." << std::flush;'
p5325
aS'    update_quadrature_point_history();'
p5326
aS'    pcout << std::endl;'
p5327
aS'  }'
p5328
aS'  template <int dim>'
p5329
aS'  unsigned int TopLevel<dim>::solve_linear_problem()'
p5330
aS'  {'
p5331
aS'    PETScWrappers::MPI::Vector distributed_incremental_displacement('
p5332
aS'      locally_owned_dofs, mpi_communicator);'
p5333
aS'    distributed_incremental_displacement = incremental_displacement;'
p5334
aS'    SolverControl solver_control(dof_handler.n_dofs(),'
p5335
aS'                                 1e-16 * system_rhs.l2_norm());'
p5336
aS'    PETScWrappers::SolverCG cg(solver_control, mpi_communicator);'
p5337
aS'    PETScWrappers::PreconditionBlockJacobi preconditioner(system_matrix);'
p5338
aS'    cg.solve(system_matrix,'
p5339
aS'             distributed_incremental_displacement,'
p5340
aS'             system_rhs,'
p5341
aS'             preconditioner);'
p5342
aS'    incremental_displacement = distributed_incremental_displacement;'
p5343
aS'    hanging_node_constraints.distribute(incremental_displacement);'
p5344
aS'    return solver_control.last_step();'
p5345
aS'  }'
p5346
aS'  template <int dim>'
p5347
aS'  void TopLevel<dim>::output_results() const'
p5348
aS'  {'
p5349
aS'    DataOut<dim> data_out;'
p5350
aS'    data_out.attach_dof_handler(dof_handler);'
p5351
aS'    std::vector<std::string> solution_names;'
p5352
aS'    switch (dim)'
p5353
aS'      {'
p5354
aS'        case 1:'
p5355
aS'          solution_names.emplace_back("delta_x");'
p5356
aS'          break;'
p5357
aS'        case 2:'
p5358
aS'          solution_names.emplace_back("delta_x");'
p5359
aS'          solution_names.emplace_back("delta_y");'
p5360
aS'          break;'
p5361
aS'        case 3:'
p5362
aS'          solution_names.emplace_back("delta_x");'
p5363
aS'          solution_names.emplace_back("delta_y");'
p5364
aS'          solution_names.emplace_back("delta_z");'
p5365
aS'          break;'
p5366
aS'        default:'
p5367
aS'          Assert(false, ExcNotImplemented());'
p5368
aS'      }'
p5369
aS'    data_out.add_data_vector(incremental_displacement, solution_names);'
p5370
aS'    Vector<double> norm_of_stress(triangulation.n_active_cells());'
p5371
aS'    {'
p5372
aS'      for (auto &cell : triangulation.active_cell_iterators())'
p5373
aS'        if (cell->is_locally_owned())'
p5374
aS'          {'
p5375
aS'            SymmetricTensor<2, dim> accumulated_stress;'
p5376
aS'            for (unsigned int q = 0; q < quadrature_formula.size(); ++q)'
p5377
aS'              accumulated_stress +='
p5378
aS'                reinterpret_cast<PointHistory<dim> *>(cell->user_pointer())[q]'
p5379
aS'                  .old_stress;'
p5380
aS'            norm_of_stress(cell->active_cell_index()) ='
p5381
aS'              (accumulated_stress / quadrature_formula.size()).norm();'
p5382
aS'          }'
p5383
aS'        else'
p5384
aS'          norm_of_stress(cell->active_cell_index()) = -1e+20;'
p5385
aS'    }'
p5386
aS'    data_out.add_data_vector(norm_of_stress, "norm_of_stress");'
p5387
aS'    std::vector<types::subdomain_id> partition_int('
p5388
aS'      triangulation.n_active_cells());'
p5389
aS'    GridTools::get_subdomain_association(triangulation, partition_int);'
p5390
aS'    const Vector<double> partitioning(partition_int.begin(),'
p5391
aS'                                      partition_int.end());'
p5392
aS'    data_out.add_data_vector(partitioning, "partitioning");'
p5393
aS'    data_out.build_patches();'
p5394
aS'    const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record('
p5395
aS'      "./", "solution", timestep_no, mpi_communicator, 4);'
p5396
aS'    if (this_mpi_process == 0)'
p5397
aS'      {'
p5398
aS'        static std::vector<std::pair<double, std::string>> times_and_names;'
p5399
aS'        times_and_names.push_back('
p5400
aS'          std::pair<double, std::string>(present_time, pvtu_filename));'
p5401
aS'        std::ofstream pvd_output("solution.pvd");'
p5402
aS'        DataOutBase::write_pvd_record(pvd_output, times_and_names);'
p5403
aS'      }'
p5404
aS'  }'
p5405
aS'  template <int dim>'
p5406
aS'  void TopLevel<dim>::do_initial_timestep()'
p5407
aS'  {'
p5408
aS'    present_time += present_timestep;'
p5409
aS'    ++timestep_no;'
p5410
aS'    pcout << "Timestep " << timestep_no << " at time " << present_time'
p5411
aS'          << std::endl;'
p5412
aS'    for (unsigned int cycle = 0; cycle < 2; ++cycle)'
p5413
aS'      {'
p5414
aS'        pcout << "  Cycle " << cycle << \':\' << std::endl;'
p5415
aS'        if (cycle == 0)'
p5416
aS'          create_coarse_grid();'
p5417
aS'        else'
p5418
aS'          refine_initial_grid();'
p5419
aS'        pcout << "    Number of active cells:       "'
p5420
aS'              << triangulation.n_active_cells() << " (by partition:";'
p5421
aS'        for (unsigned int p = 0; p < n_mpi_processes; ++p)'
p5422
aS"          pcout << (p == 0 ? ' ' : '+')"
p5423
aS'                << (GridTools::count_cells_with_subdomain_association('
p5424
aS'                     triangulation, p));'
p5425
aS'        pcout << ")" << std::endl;'
p5426
aS'        setup_system();'
p5427
aS'        pcout << "    Number of degrees of freedom: " << dof_handler.n_dofs()'
p5428
aS'              << " (by partition:";'
p5429
aS'        for (unsigned int p = 0; p < n_mpi_processes; ++p)'
p5430
aS"          pcout << (p == 0 ? ' ' : '+')"
p5431
aS'                << (DoFTools::count_dofs_with_subdomain_association(dof_handler,'
p5432
aS'                                                                    p));'
p5433
aS'        pcout << ")" << std::endl;'
p5434
aS'        solve_timestep();'
p5435
aS'      }'
p5436
aS'    move_mesh();'
p5437
aS'    output_results();'
p5438
aS'    pcout << std::endl;'
p5439
aS'  }'
p5440
aS'  template <int dim>'
p5441
aS'  void TopLevel<dim>::do_timestep()'
p5442
aS'  {'
p5443
aS'    present_time += present_timestep;'
p5444
aS'    ++timestep_no;'
p5445
aS'    pcout << "Timestep " << timestep_no << " at time " << present_time'
p5446
aS'          << std::endl;'
p5447
aS'    if (present_time > end_time)'
p5448
aS'      {'
p5449
aS'        present_timestep -= (present_time - end_time);'
p5450
aS'        present_time = end_time;'
p5451
aS'      }'
p5452
aS'    solve_timestep();'
p5453
aS'    move_mesh();'
p5454
aS'    output_results();'
p5455
aS'    pcout << std::endl;'
p5456
aS'  }'
p5457
aS'  template <int dim>'
p5458
aS'  void TopLevel<dim>::refine_initial_grid()'
p5459
aS'  {'
p5460
aS'    Vector<float> error_per_cell(triangulation.n_active_cells());'
p5461
aS'    KellyErrorEstimator<dim>::estimate('
p5462
aS'      dof_handler,'
p5463
aS'      QGauss<dim - 1>(fe.degree + 1),'
p5464
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p5465
aS'      incremental_displacement,'
p5466
aS'      error_per_cell,'
p5467
aS'      ComponentMask(),'
p5468
aS'      nullptr,'
p5469
aS'      MultithreadInfo::n_threads(),'
p5470
aS'      this_mpi_process);'
p5471
aS'    const unsigned int n_local_cells ='
p5472
aS'      triangulation.n_locally_owned_active_cells();'
p5473
aS'    PETScWrappers::MPI::Vector distributed_error_per_cell('
p5474
aS'      mpi_communicator, triangulation.n_active_cells(), n_local_cells);'
p5475
aS'    for (unsigned int i = 0; i < error_per_cell.size(); ++i)'
p5476
aS'      if (error_per_cell(i) != 0)'
p5477
aS'        distributed_error_per_cell(i) = error_per_cell(i);'
p5478
aS'    distributed_error_per_cell.compress(VectorOperation::insert);'
p5479
aS'    error_per_cell = distributed_error_per_cell;'
p5480
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p5481
aS'                                                    error_per_cell,'
p5482
aS'                                                    0.35,'
p5483
aS'                                                    0.03);'
p5484
aS'    triangulation.execute_coarsening_and_refinement();'
p5485
aS'    setup_quadrature_point_history();'
p5486
aS'  }'
p5487
aS'  template <int dim>'
p5488
aS'  void TopLevel<dim>::move_mesh()'
p5489
aS'  {'
p5490
aS'    pcout << "    Moving mesh..." << std::endl;'
p5491
aS'    std::vector<bool> vertex_touched(triangulation.n_vertices(), false);'
p5492
aS'    for (auto &cell : dof_handler.active_cell_iterators())'
p5493
aS'      for (const auto v : cell->vertex_indices())'
p5494
aS'        if (vertex_touched[cell->vertex_index(v)] == false)'
p5495
aS'          {'
p5496
aS'            vertex_touched[cell->vertex_index(v)] = true;'
p5497
aS'            Point<dim> vertex_displacement;'
p5498
aS'            for (unsigned int d = 0; d < dim; ++d)'
p5499
aS'              vertex_displacement[d] ='
p5500
aS'                incremental_displacement(cell->vertex_dof_index(v, d));'
p5501
aS'            cell->vertex(v) += vertex_displacement;'
p5502
aS'          }'
p5503
aS'  }'
p5504
aS'  template <int dim>'
p5505
aS'  void TopLevel<dim>::setup_quadrature_point_history()'
p5506
aS'  {'
p5507
aS'    triangulation.clear_user_data();'
p5508
aS'    {'
p5509
aS'      std::vector<PointHistory<dim>> tmp;'
p5510
aS'      quadrature_point_history.swap(tmp);'
p5511
aS'    }'
p5512
aS'    quadrature_point_history.resize('
p5513
aS'      triangulation.n_locally_owned_active_cells() * quadrature_formula.size());'
p5514
aS'    unsigned int history_index = 0;'
p5515
aS'    for (auto &cell : triangulation.active_cell_iterators())'
p5516
aS'      if (cell->is_locally_owned())'
p5517
aS'        {'
p5518
aS'          cell->set_user_pointer(&quadrature_point_history[history_index]);'
p5519
aS'          history_index += quadrature_formula.size();'
p5520
aS'        }'
p5521
aS'    Assert(history_index == quadrature_point_history.size(),'
p5522
aS'           ExcInternalError());'
p5523
aS'  }'
p5524
aS'  template <int dim>'
p5525
aS'  void TopLevel<dim>::update_quadrature_point_history()'
p5526
aS'  {'
p5527
aS'    FEValues<dim> fe_values(fe,'
p5528
aS'                            quadrature_formula,'
p5529
aS'                            update_values | update_gradients);'
p5530
aS'    std::vector<std::vector<Tensor<1, dim>>> displacement_increment_grads('
p5531
aS'      quadrature_formula.size(), std::vector<Tensor<1, dim>>(dim));'
p5532
aS'    for (auto &cell : dof_handler.active_cell_iterators())'
p5533
aS'      if (cell->is_locally_owned())'
p5534
aS'        {'
p5535
aS'          PointHistory<dim> *local_quadrature_points_history ='
p5536
aS'            reinterpret_cast<PointHistory<dim> *>(cell->user_pointer());'
p5537
aS'          Assert(local_quadrature_points_history >='
p5538
aS'                   &quadrature_point_history.front(),'
p5539
aS'                 ExcInternalError());'
p5540
aS'          Assert(local_quadrature_points_history <='
p5541
aS'                   &quadrature_point_history.back(),'
p5542
aS'                 ExcInternalError());'
p5543
aS'          fe_values.reinit(cell);'
p5544
aS'          fe_values.get_function_gradients(incremental_displacement,'
p5545
aS'                                           displacement_increment_grads);'
p5546
aS'          for (unsigned int q = 0; q < quadrature_formula.size(); ++q)'
p5547
aS'            {'
p5548
aS'              const SymmetricTensor<2, dim> new_stress ='
p5549
aS'                (local_quadrature_points_history[q].old_stress +'
p5550
aS'                 (stress_strain_tensor *'
p5551
aS'                  get_strain(displacement_increment_grads[q])));'
p5552
aS'              const Tensor<2, dim> rotation ='
p5553
aS'                get_rotation_matrix(displacement_increment_grads[q]);'
p5554
aS'              const SymmetricTensor<2, dim> rotated_new_stress ='
p5555
aS'                symmetrize(transpose(rotation) *'
p5556
aS'                           static_cast<Tensor<2, dim>>(new_stress) * rotation);'
p5557
aS'              local_quadrature_points_history[q].old_stress ='
p5558
aS'                rotated_new_stress;'
p5559
aS'            }'
p5560
aS'        }'
p5561
aS'  }'
p5562
aS'} // namespace Step18'
p5563
aS'int main(int argc, char **argv)'
p5564
ag24
aS'  try'
p5565
aS'    {'
p5566
aS'      using namespace dealii;'
p5567
aS'      using namespace Step18;'
p5568
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p5569
aS'      TopLevel<3> elastic_problem;'
p5570
aS'      elastic_problem.run();'
p5571
aS'    }'
p5572
aS'  catch (std::exception &exc)'
p5573
aS'    {'
p5574
aS'      std::cerr << std::endl'
p5575
aS'                << std::endl'
p5576
aS'                << "----------------------------------------------------"'
p5577
aS'                << std::endl;'
p5578
aS'      std::cerr << "Exception on processing: " << std::endl'
p5579
aS'                << exc.what() << std::endl'
p5580
aS'                << "Aborting!" << std::endl'
p5581
aS'                << "----------------------------------------------------"'
p5582
aS'                << std::endl;'
p5583
aS'      return 1;'
p5584
aS'    }'
p5585
aS'  catch (...)'
p5586
aS'    {'
p5587
aS'      std::cerr << std::endl'
p5588
aS'                << std::endl'
p5589
aS'                << "----------------------------------------------------"'
p5590
aS'                << std::endl;'
p5591
aS'      std::cerr << "Unknown exception!" << std::endl'
p5592
aS'                << "Aborting!" << std::endl'
p5593
aS'                << "----------------------------------------------------"'
p5594
aS'                << std::endl;'
p5595
aS'      return 1;'
p5596
aS'    }'
p5597
aS'  return 0;'
p5598
ag32
aS'/* ---------------------------------------------------------------------'
p5599
aS' *'
p5600
aS' * Copyright (C) 2020 - 2021 by the deal.II authors'
p5601
aS' *'
p5602
aS' * This file is part of the deal.II library.'
p5603
aS' *'
p5604
aS' * The deal.II library is free software; you can use it, redistribute'
p5605
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p5606
aS' * Public License as published by the Free Software Foundation; either'
p5607
aS' * version 2.1 of the License, or (at your option) any later version.'
p5608
aS' * The full text of the license can be found in the file LICENSE.md at'
p5609
aS' * the top level directory of deal.II.'
p5610
aS' *'
p5611
aS' * ---------------------------------------------------------------------'
p5612
aS' *'
p5613
aS' * Authors: Wolfgang Bangerth, Rene Gassmoeller, Peter Munch, 2020.'
p5614
aS' */'
p5615
aS'#include <deal.II/base/quadrature_lib.h>'
p5616
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p5617
aS'#include <deal.II/lac/full_matrix.h>'
p5618
aS'#include <deal.II/lac/precondition.h>'
p5619
aS'#include <deal.II/lac/solver_cg.h>'
p5620
aS'#include <deal.II/lac/sparse_matrix.h>'
p5621
aS'#include <deal.II/lac/vector.h>'
p5622
aS'#include <deal.II/lac/affine_constraints.h>'
p5623
aS'#include <deal.II/grid/tria.h>'
p5624
aS'#include <deal.II/grid/grid_refinement.h>'
p5625
aS'#include <deal.II/fe/mapping_q.h>'
p5626
aS'#include <deal.II/matrix_free/fe_point_evaluation.h>'
p5627
aS'#include <deal.II/fe/fe_q.h>'
p5628
aS'#include <deal.II/fe/fe_values.h>'
p5629
aS'#include <deal.II/dofs/dof_handler.h>'
p5630
aS'#include <deal.II/dofs/dof_tools.h>'
p5631
aS'#include <deal.II/numerics/data_out.h>'
p5632
aS'#include <deal.II/numerics/vector_tools.h>'
p5633
aS'#include <deal.II/numerics/error_estimator.h>'
p5634
aS'#include <deal.II/base/discrete_time.h>'
p5635
aS'#include <deal.II/particles/particle_handler.h>'
p5636
aS'#include <deal.II/particles/data_out.h>'
p5637
aS'#include <fstream>'
p5638
aS'using namespace dealii;'
p5639
aS'namespace Step19'
p5640
ag24
aS'  namespace BoundaryIds'
p5641
aS'  {'
p5642
aS'    constexpr types::boundary_id open          = 101;'
p5643
aS'    constexpr types::boundary_id cathode       = 102;'
p5644
aS'    constexpr types::boundary_id focus_element = 103;'
p5645
aS'    constexpr types::boundary_id anode         = 104;'
p5646
aS'  } // namespace BoundaryIds'
p5647
aS'  namespace Constants'
p5648
aS'  {'
p5649
aS'    constexpr double electron_mass   = 9.1093837015e-31;'
p5650
aS'    constexpr double electron_charge = 1.602176634e-19;'
p5651
aS'    constexpr double V0 = 1;'
p5652
aS'    constexpr double E_threshold = 0.05;'
p5653
aS'    constexpr double electrons_per_particle = 3e15;'
p5654
aS'  } // namespace Constants'
p5655
aS'  template <int dim>'
p5656
aS'  class CathodeRaySimulator'
p5657
aS'  {'
p5658
aS'  public:'
p5659
aS'    CathodeRaySimulator();'
p5660
aS'    void run();'
p5661
aS'  private:'
p5662
aS'    void make_grid();'
p5663
aS'    void setup_system();'
p5664
aS'    void assemble_system();'
p5665
aS'    void solve_field();'
p5666
aS'    void refine_grid();'
p5667
aS'    void create_particles();'
p5668
aS'    void move_particles();'
p5669
aS'    void track_lost_particle('
p5670
aS'      const typename Particles::ParticleIterator<dim> &        particle,'
p5671
aS'      const typename Triangulation<dim>::active_cell_iterator &cell);'
p5672
aS'    void update_timestep_size();'
p5673
aS'    void output_results() const;'
p5674
aS'    Triangulation<dim>        triangulation;'
p5675
aS'    MappingQGeneric<dim>      mapping;'
p5676
aS'    FE_Q<dim>                 fe;'
p5677
aS'    DoFHandler<dim>           dof_handler;'
p5678
aS'    AffineConstraints<double> constraints;'
p5679
aS'    SparseMatrix<double> system_matrix;'
p5680
aS'    SparsityPattern      sparsity_pattern;'
p5681
aS'    Vector<double> solution;'
p5682
aS'    Vector<double> system_rhs;'
p5683
aS'    Particles::ParticleHandler<dim> particle_handler;'
p5684
aS'    types::particle_index           next_unused_particle_id;'
p5685
aS'    types::particle_index           n_recently_lost_particles;'
p5686
aS'    types::particle_index           n_total_lost_particles;'
p5687
aS'    types::particle_index           n_particles_lost_through_anode;'
p5688
aS'    DiscreteTime time;'
p5689
aS'  };'
p5690
aS'  template <int dim>'
p5691
aS'  CathodeRaySimulator<dim>::CathodeRaySimulator()'
p5692
aS'    : mapping(1)'
p5693
aS'    , fe(2)'
p5694
aS'    , dof_handler(triangulation)'
p5695
aS'    , particle_handler(triangulation, mapping, /*n_properties=*/dim)'
p5696
aS'    , next_unused_particle_id(0)'
p5697
aS'    , n_recently_lost_particles(0)'
p5698
aS'    , n_total_lost_particles(0)'
p5699
aS'    , n_particles_lost_through_anode(0)'
p5700
aS'    , time(0, 1e-4)'
p5701
aS'  {'
p5702
aS'    particle_handler.signals.particle_lost.connect('
p5703
aS'      [this](const typename Particles::ParticleIterator<dim> &        particle,'
p5704
aS'             const typename Triangulation<dim>::active_cell_iterator &cell) {'
p5705
aS'        this->track_lost_particle(particle, cell);'
p5706
aS'      });'
p5707
aS'  }'
p5708
aS'  template <int dim>'
p5709
aS'  void CathodeRaySimulator<dim>::make_grid()'
p5710
aS'  {'
p5711
aS'    static_assert(dim == 2,'
p5712
aS'                  "This function is currently only implemented for 2d.");'
p5713
aS'    const double       delta = 0.5;'
p5714
aS'    const unsigned int nx    = 5;'
p5715
aS'    const unsigned int ny    = 3;'
p5716
aS'    const std::vector<Point<dim>> vertices //'
p5717
aS'      = {{0, 0},'
p5718
aS'         {1, 0},'
p5719
aS'         {2, 0},'
p5720
aS'         {3, 0},'
p5721
aS'         {4, 0},'
p5722
aS'         {delta, 1},'
p5723
aS'         {1, 1},'
p5724
aS'         {2, 1},'
p5725
aS'         {3, 1},'
p5726
aS'         {4, 1},'
p5727
aS'         {0, 2},'
p5728
aS'         {1, 2},'
p5729
aS'         {2, 2},'
p5730
aS'         {3, 2},'
p5731
aS'         {4, 2}};'
p5732
aS'    AssertDimension(vertices.size(), nx * ny);'
p5733
aS'    const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = {'
p5734
aS'      {0, 1, nx + 0, nx + 1},'
p5735
aS'      {1, 2, nx + 1, nx + 2},'
p5736
aS'      {2, 3, nx + 2, nx + 3},'
p5737
aS'      {3, 4, nx + 3, nx + 4},'
p5738
aS'      {5, nx + 1, 2 * nx + 0, 2 * nx + 1},'
p5739
aS'      {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2},'
p5740
aS'      {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3},'
p5741
aS'      {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}};'
p5742
aS'    std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>());'
p5743
aS'    for (unsigned int i = 0; i < cells.size(); ++i)'
p5744
aS'      {'
p5745
aS'        cells[i].vertices    = cell_vertices[i];'
p5746
aS'        cells[i].material_id = 0;'
p5747
aS'      }'
p5748
aS'    triangulation.create_triangulation('
p5749
aS'      vertices,'
p5750
aS'      cells,'
p5751
aS'      SubCellData()); // No boundary information'
p5752
aS'    triangulation.refine_global(2);'
p5753
aS'    for (auto &cell : triangulation.active_cell_iterators())'
p5754
aS'      for (auto &face : cell->face_iterators())'
p5755
aS'        if (face->at_boundary())'
p5756
aS'          {'
p5757
aS'            if ((face->center()[0] > 0) && (face->center()[0] < 0.5) &&'
p5758
aS'                (face->center()[1] > 0) && (face->center()[1] < 2))'
p5759
aS'              face->set_boundary_id(BoundaryIds::cathode);'
p5760
aS'            else if ((face->center()[0] > 0) && (face->center()[0] < 2))'
p5761
aS'              face->set_boundary_id(BoundaryIds::focus_element);'
p5762
aS'            else if ((face->center()[0] > 4 - 1e-12) &&'
p5763
aS'                     ((face->center()[1] > 1.5) || (face->center()[1] < 0.5)))'
p5764
aS'              face->set_boundary_id(BoundaryIds::anode);'
p5765
aS'            else'
p5766
aS'              face->set_boundary_id(BoundaryIds::open);'
p5767
aS'          }'
p5768
aS'    triangulation.refine_global(1);'
p5769
aS'  }'
p5770
aS'  template <int dim>'
p5771
aS'  void CathodeRaySimulator<dim>::setup_system()'
p5772
aS'  {'
p5773
aS'    dof_handler.distribute_dofs(fe);'
p5774
aS'    solution.reinit(dof_handler.n_dofs());'
p5775
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p5776
aS'    constraints.clear();'
p5777
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p5778
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5779
aS'                                             BoundaryIds::cathode,'
p5780
aS'                                             Functions::ConstantFunction<dim>('
p5781
aS'                                               -Constants::V0),'
p5782
aS'                                             constraints);'
p5783
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5784
aS'                                             BoundaryIds::focus_element,'
p5785
aS'                                             Functions::ConstantFunction<dim>('
p5786
aS'                                               -Constants::V0),'
p5787
aS'                                             constraints);'
p5788
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5789
aS'                                             BoundaryIds::anode,'
p5790
aS'                                             Functions::ConstantFunction<dim>('
p5791
aS'                                               +Constants::V0),'
p5792
aS'                                             constraints);'
p5793
aS'    constraints.close();'
p5794
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p5795
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p5796
aS'                                    dsp,'
p5797
aS'                                    constraints,'
p5798
aS'    sparsity_pattern.copy_from(dsp);'
p5799
aS'    system_matrix.reinit(sparsity_pattern);'
p5800
aS'  }'
p5801
aS'  template <int dim>'
p5802
aS'  void CathodeRaySimulator<dim>::assemble_system()'
p5803
aS'  {'
p5804
aS'    system_matrix = 0;'
p5805
aS'    system_rhs    = 0;'
p5806
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p5807
aS'    FEValues<dim> fe_values(fe,'
p5808
aS'                            quadrature_formula,'
p5809
aS'                            update_values | update_gradients |'
p5810
aS'                              update_quadrature_points | update_JxW_values);'
p5811
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p5812
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p5813
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p5814
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p5815
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5816
aS'      {'
p5817
aS'        cell_matrix = 0;'
p5818
aS'        cell_rhs    = 0;'
p5819
aS'        fe_values.reinit(cell);'
p5820
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p5821
aS'          for (const unsigned int i : fe_values.dof_indices())'
p5822
aS'            {'
p5823
aS'              for (const unsigned int j : fe_values.dof_indices())'
p5824
aS'                cell_matrix(i, j) +='
p5825
aS'                  (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p5826
aS'                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p5827
aS'                   fe_values.JxW(q_index));           // dx'
p5828
aS'            }'
p5829
aS'        if (particle_handler.n_particles_in_cell(cell) > 0)'
p5830
aS'          for (const auto &particle : particle_handler.particles_in_cell(cell))'
p5831
aS'            {'
p5832
aS'              const Point<dim> &reference_location ='
p5833
aS'                particle.get_reference_location();'
p5834
aS'              for (const unsigned int i : fe_values.dof_indices())'
p5835
aS'                cell_rhs(i) +='
p5836
aS'                  (fe.shape_value(i, reference_location) * // phi_i(x_p)'
p5837
aS'                   (-Constants::electrons_per_particle *   // N'
p5838
aS'                    Constants::electron_charge));          // e'
p5839
aS'            }'
p5840
aS'        cell->get_dof_indices(local_dof_indices);'
p5841
aS'        constraints.distribute_local_to_global('
p5842
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p5843
aS'      }'
p5844
aS'  }'
p5845
aS'  template <int dim>'
p5846
aS'  void CathodeRaySimulator<dim>::solve_field()'
p5847
aS'  {'
p5848
aS'    SolverControl            solver_control(1000, 1e-12);'
p5849
aS'    SolverCG<Vector<double>> solver(solver_control);'
p5850
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p5851
aS'    preconditioner.initialize(system_matrix, 1.2);'
p5852
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p5853
aS'    constraints.distribute(solution);'
p5854
aS'  }'
p5855
aS'  template <int dim>'
p5856
aS'  void CathodeRaySimulator<dim>::refine_grid()'
p5857
aS'  {'
p5858
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p5859
aS'    KellyErrorEstimator<dim>::estimate(dof_handler,'
p5860
aS'                                       QGauss<dim - 1>(fe.degree + 1),'
p5861
aS'                                       {},'
p5862
aS'                                       solution,'
p5863
aS'                                       estimated_error_per_cell);'
p5864
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p5865
aS'                                                    estimated_error_per_cell,'
p5866
aS'                                                    0.1,'
p5867
aS'                                                    0.03);'
p5868
aS'    triangulation.execute_coarsening_and_refinement();'
p5869
aS'  }'
p5870
aS'  template <int dim>'
p5871
aS'  void CathodeRaySimulator<dim>::create_particles()'
p5872
aS'  {'
p5873
aS'    FEFaceValues<dim> fe_face_values(fe,'
p5874
aS'                                     QMidpoint<dim - 1>(),'
p5875
aS'                                     update_quadrature_points |'
p5876
aS'                                       update_gradients |'
p5877
aS'                                       update_normal_vectors);'
p5878
aS'    std::vector<Tensor<1, dim>> solution_gradients('
p5879
aS'      fe_face_values.n_quadrature_points);'
p5880
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5881
aS'      for (const auto &face : cell->face_iterators())'
p5882
aS'        if (face->at_boundary() &&'
p5883
aS'            (face->boundary_id() == BoundaryIds::cathode))'
p5884
aS'          {'
p5885
aS'            fe_face_values.reinit(cell, face);'
p5886
aS'            const FEValuesExtractors::Scalar electric_potential(0);'
p5887
aS'            fe_face_values[electric_potential].get_function_gradients('
p5888
aS'              solution, solution_gradients);'
p5889
aS'            for (const unsigned int q_point :'
p5890
aS'                 fe_face_values.quadrature_point_indices())'
p5891
aS'              {'
p5892
aS'                const Tensor<1, dim> E = solution_gradients[q_point];'
p5893
aS'                if ((E * fe_face_values.normal_vector(q_point) < 0) &&'
p5894
aS'                    (E.norm() > Constants::E_threshold))'
p5895
aS'                  {'
p5896
aS'                    const Point<dim> &location ='
p5897
aS'                      fe_face_values.quadrature_point(q_point);'
p5898
aS'                    Particles::Particle<dim> new_particle;'
p5899
aS'                    new_particle.set_location(location);'
p5900
aS'                    new_particle.set_reference_location('
p5901
aS'                      mapping.transform_real_to_unit_cell(cell, location));'
p5902
aS'                    new_particle.set_id(next_unused_particle_id);'
p5903
aS'                    particle_handler.insert_particle(new_particle, cell);'
p5904
aS'                    ++next_unused_particle_id;'
p5905
aS'                  }'
p5906
aS'              }'
p5907
aS'          }'
p5908
aS'    particle_handler.update_cached_numbers();'
p5909
aS'  }'
p5910
aS'  template <int dim>'
p5911
aS'  void CathodeRaySimulator<dim>::move_particles()'
p5912
aS'  {'
p5913
aS'    const double dt = time.get_next_step_size();'
p5914
aS'    Vector<double>            solution_values(fe.n_dofs_per_cell());'
p5915
aS'    FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients);'
p5916
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5917
aS'      if (particle_handler.n_particles_in_cell(cell) > 0)'
p5918
aS'        {'
p5919
aS'          const typename Particles::ParticleHandler<'
p5920
aS'            dim>::particle_iterator_range particles_in_cell ='
p5921
aS'            particle_handler.particles_in_cell(cell);'
p5922
aS'          std::vector<Point<dim>> particle_positions;'
p5923
aS'          for (const auto &particle : particles_in_cell)'
p5924
aS'            particle_positions.push_back(particle.get_reference_location());'
p5925
aS'          cell->get_dof_values(solution, solution_values);'
p5926
aS'          evaluator.reinit(cell, particle_positions);'
p5927
aS'          evaluator.evaluate(make_array_view(solution_values),'
p5928
aS'                             EvaluationFlags::gradients);'
p5929
aS'          {'
p5930
aS'            typename Particles::ParticleHandler<dim>::particle_iterator'
p5931
aS'              particle = particles_in_cell.begin();'
p5932
aS'            for (unsigned int particle_index = 0;'
p5933
aS'                 particle != particles_in_cell.end();'
p5934
aS'                 ++particle, ++particle_index)'
p5935
aS'              {'
p5936
aS'                const Tensor<1, dim> &E ='
p5937
aS'                  evaluator.get_gradient(particle_index);'
p5938
aS'                const Tensor<1, dim> old_velocity(particle->get_properties());'
p5939
aS'                const Tensor<1, dim> acceleration ='
p5940
aS'                  Constants::electron_charge / Constants::electron_mass * E;'
p5941
aS'                const Tensor<1, dim> new_velocity ='
p5942
aS'                  old_velocity + acceleration * dt;'
p5943
aS'                particle->set_properties(make_array_view(new_velocity));'
p5944
aS'                const Point<dim> new_location ='
p5945
aS'                  particle->get_location() + dt * new_velocity;'
p5946
aS'                particle->set_location(new_location);'
p5947
aS'              }'
p5948
aS'          }'
p5949
aS'        }'
p5950
aS'    particle_handler.sort_particles_into_subdomains_and_cells();'
p5951
aS'  }'
p5952
aS'  template <int dim>'
p5953
aS'  void CathodeRaySimulator<dim>::track_lost_particle('
p5954
aS'    const typename Particles::ParticleIterator<dim> &        particle,'
p5955
aS'    const typename Triangulation<dim>::active_cell_iterator &cell)'
p5956
aS'  {'
p5957
aS'    ++n_recently_lost_particles;'
p5958
aS'    ++n_total_lost_particles;'
p5959
aS'    const Point<dim> current_location              = particle->get_location();'
p5960
aS'    const Point<dim> approximate_previous_location = cell->center();'
p5961
aS'    if ((approximate_previous_location[0] < 4) && (current_location[0] > 4))'
p5962
aS'      {'
p5963
aS'        const Tensor<1, dim> direction ='
p5964
aS'          (current_location - approximate_previous_location) /'
p5965
aS'          (current_location[0] - approximate_previous_location[0]);'
p5966
aS'        const double right_boundary_intercept ='
p5967
aS'          approximate_previous_location[1] +'
p5968
aS'          (4 - approximate_previous_location[0]) * direction[1];'
p5969
aS'        if ((right_boundary_intercept > 0.5) &&'
p5970
aS'            (right_boundary_intercept < 1.5))'
p5971
aS'          ++n_particles_lost_through_anode;'
p5972
aS'      }'
p5973
aS'  }'
p5974
aS'  template <int dim>'
p5975
aS'  void CathodeRaySimulator<dim>::update_timestep_size()'
p5976
aS'  {'
p5977
aS'    if (time.get_step_number() > 0)'
p5978
aS'      {'
p5979
aS'        double min_cell_size_over_velocity = std::numeric_limits<double>::max();'
p5980
aS'        for (const auto &cell : dof_handler.active_cell_iterators())'
p5981
aS'          if (particle_handler.n_particles_in_cell(cell) > 0)'
p5982
aS'            {'
p5983
aS'              const double cell_size = cell->minimum_vertex_distance();'
p5984
aS'              double max_particle_velocity(0.0);'
p5985
aS'              for (const auto &particle :'
p5986
aS'                   particle_handler.particles_in_cell(cell))'
p5987
aS'                {'
p5988
aS'                  const Tensor<1, dim> velocity(particle.get_properties());'
p5989
aS'                  max_particle_velocity ='
p5990
aS'                    std::max(max_particle_velocity, velocity.norm());'
p5991
aS'                }'
p5992
aS'              if (max_particle_velocity > 0)'
p5993
aS'                min_cell_size_over_velocity ='
p5994
aS'                  std::min(min_cell_size_over_velocity,'
p5995
aS'                           cell_size / max_particle_velocity);'
p5996
aS'            }'
p5997
aS'        constexpr double c_safety = 0.5;'
p5998
aS'        time.set_desired_next_step_size(c_safety * 0.5 *'
p5999
aS'                                        min_cell_size_over_velocity);'
p6000
aS'      }'
p6001
aS'    else'
p6002
aS'      {'
p6003
aS'        const QTrapezoid<dim> vertex_quadrature;'
p6004
aS'        FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients);'
p6005
aS'        std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size());'
p6006
aS'        double min_timestep = std::numeric_limits<double>::max();'
p6007
aS'        for (const auto &cell : dof_handler.active_cell_iterators())'
p6008
aS'          if (particle_handler.n_particles_in_cell(cell) > 0)'
p6009
aS'            {'
p6010
aS'              const double cell_size = cell->minimum_vertex_distance();'
p6011
aS'              fe_values.reinit(cell);'
p6012
aS'              fe_values.get_function_gradients(solution, field_gradients);'
p6013
aS'              double max_E = 0;'
p6014
aS'              for (const auto q_point : fe_values.quadrature_point_indices())'
p6015
aS'                max_E = std::max(max_E, field_gradients[q_point].norm());'
p6016
aS'              if (max_E > 0)'
p6017
aS'                min_timestep ='
p6018
aS'                  std::min(min_timestep,'
p6019
aS'                           std::sqrt(0.5 * cell_size *'
p6020
aS'                                     Constants::electron_mass /'
p6021
aS'                                     Constants::electron_charge / max_E));'
p6022
aS'            }'
p6023
aS'        time.set_desired_next_step_size(min_timestep);'
p6024
aS'      }'
p6025
aS'  }'
p6026
aS'  template <int dim>'
p6027
aS'  class ElectricFieldPostprocessor : public DataPostprocessorVector<dim>'
p6028
aS'  {'
p6029
aS'  public:'
p6030
aS'    ElectricFieldPostprocessor()'
p6031
aS'      : DataPostprocessorVector<dim>("electric_field", update_gradients)'
p6032
aS'    {}'
p6033
aS'    virtual void evaluate_scalar_field('
p6034
aS'      const DataPostprocessorInputs::Scalar<dim> &input_data,'
p6035
aS'      std::vector<Vector<double>> &computed_quantities) const override'
p6036
aS'    {'
p6037
aS'      AssertDimension(input_data.solution_gradients.size(),'
p6038
aS'                      computed_quantities.size());'
p6039
aS'      for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p)'
p6040
aS'        {'
p6041
aS'          AssertDimension(computed_quantities[p].size(), dim);'
p6042
aS'          for (unsigned int d = 0; d < dim; ++d)'
p6043
aS'            computed_quantities[p][d] = input_data.solution_gradients[p][d];'
p6044
aS'        }'
p6045
aS'    }'
p6046
aS'  };'
p6047
aS'  template <int dim>'
p6048
aS'  void CathodeRaySimulator<dim>::output_results() const'
p6049
aS'  {'
p6050
aS'    {'
p6051
aS'      ElectricFieldPostprocessor<dim> electric_field;'
p6052
aS'      DataOut<dim>                    data_out;'
p6053
aS'      data_out.attach_dof_handler(dof_handler);'
p6054
aS'      data_out.add_data_vector(solution, "electric_potential");'
p6055
aS'      data_out.add_data_vector(solution, electric_field);'
p6056
aS'      data_out.build_patches();'
p6057
aS'      data_out.set_flags('
p6058
aS'        DataOutBase::VtkFlags(time.get_current_time(), time.get_step_number()));'
p6059
aS'      std::ofstream output("solution-" +'
p6060
aS'                           Utilities::int_to_string(time.get_step_number(), 4) +'
p6061
aS'                           ".vtu");'
p6062
aS'      data_out.write_vtu(output);'
p6063
aS'    }'
p6064
aS'    {'
p6065
aS'      Particles::DataOut<dim, dim> particle_out;'
p6066
aS'      particle_out.build_patches('
p6067
aS'        particle_handler,'
p6068
aS'        std::vector<std::string>(dim, "velocity"),'
p6069
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>('
p6070
aS'          dim, DataComponentInterpretation::component_is_part_of_vector));'
p6071
aS'      particle_out.set_flags('
p6072
aS'        DataOutBase::VtkFlags(time.get_current_time(), time.get_step_number()));'
p6073
aS'      std::ofstream output("particles-" +'
p6074
aS'                           Utilities::int_to_string(time.get_step_number(), 4) +'
p6075
aS'                           ".vtu");'
p6076
aS'      particle_out.write_vtu(output);'
p6077
aS'    }'
p6078
aS'  }'
p6079
aS'  template <int dim>'
p6080
aS'  void CathodeRaySimulator<dim>::run()'
p6081
aS'  {'
p6082
aS'    make_grid();'
p6083
aS'    const unsigned int n_pre_refinement_cycles = 3;'
p6084
aS'    for (unsigned int refinement_cycle = 0;'
p6085
aS'         refinement_cycle < n_pre_refinement_cycles;'
p6086
aS'         ++refinement_cycle)'
p6087
aS'      {'
p6088
aS'        setup_system();'
p6089
aS'        assemble_system();'
p6090
aS'        solve_field();'
p6091
aS'        refine_grid();'
p6092
aS'      }'
p6093
aS'    setup_system();'
p6094
aS'    do'
p6095
aS'      {'
p6096
aS'        std::cout << "Timestep " << time.get_step_number() + 1 << std::endl;'
p6097
aS'        std::cout << "  Field degrees of freedom:                 "'
p6098
aS'                  << dof_handler.n_dofs() << std::endl;'
p6099
aS'        assemble_system();'
p6100
aS'        solve_field();'
p6101
aS'        create_particles();'
p6102
aS'        std::cout << "  Total number of particles in simulation:  "'
p6103
aS'                  << particle_handler.n_global_particles() << std::endl;'
p6104
aS'        n_recently_lost_particles = 0;'
p6105
aS'        update_timestep_size();'
p6106
aS'        move_particles();'
p6107
aS'        time.advance_time();'
p6108
aS'        output_results();'
p6109
aS'        std::cout << "  Number of particles lost this time step:  "'
p6110
aS'                  << n_recently_lost_particles << std::endl;'
p6111
aS'        if (n_total_lost_particles > 0)'
p6112
aS'          std::cout << "  Fraction of particles lost through anode: "'
p6113
aS'                    << 1. * n_particles_lost_through_anode /'
p6114
aS'                         n_total_lost_particles'
p6115
aS'                    << std::endl;'
p6116
aS'        std::cout << std::endl'
p6117
aS'                  << "  Now at t=" << time.get_current_time()'
p6118
aS'                  << ", dt=" << time.get_previous_step_size() << \'.\''
p6119
aS'                  << std::endl'
p6120
aS'                  << std::endl;'
p6121
aS'      }'
p6122
aS'    while (time.is_at_end() == false);'
p6123
aS'  }'
p6124
aS'} // namespace Step19'
p6125
aS'int main()'
p6126
ag24
aS'  try'
p6127
aS'    {'
p6128
aS'      Step19::CathodeRaySimulator<2> cathode_ray_simulator_2d;'
p6129
aS'      cathode_ray_simulator_2d.run();'
p6130
aS'    }'
p6131
aS'  catch (std::exception &exc)'
p6132
aS'    {'
p6133
aS'      std::cerr << std::endl'
p6134
aS'                << std::endl'
p6135
aS'                << "----------------------------------------------------"'
p6136
aS'                << std::endl;'
p6137
aS'      std::cerr << "Exception on processing: " << std::endl'
p6138
aS'                << exc.what() << std::endl'
p6139
aS'                << "Aborting!" << std::endl'
p6140
aS'                << "----------------------------------------------------"'
p6141
aS'                << std::endl;'
p6142
aS'      return 1;'
p6143
aS'    }'
p6144
aS'  catch (...)'
p6145
aS'    {'
p6146
aS'      std::cerr << std::endl'
p6147
aS'                << std::endl'
p6148
aS'                << "----------------------------------------------------"'
p6149
aS'                << std::endl;'
p6150
aS'      std::cerr << "Unknown exception!" << std::endl'
p6151
aS'                << "Aborting!" << std::endl'
p6152
aS'                << "----------------------------------------------------"'
p6153
aS'                << std::endl;'
p6154
aS'      return 1;'
p6155
aS'    }'
p6156
aS'  return 0;'
p6157
ag32
aS'/* ---------------------------------------------------------------------'
p6158
aS' *'
p6159
aS' * Copyright (C) 1999 - 2021 by the deal.II authors'
p6160
aS' *'
p6161
aS' * This file is part of the deal.II library.'
p6162
aS' *'
p6163
aS' * The deal.II library is free software; you can use it, redistribute'
p6164
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p6165
aS' * Public License as published by the Free Software Foundation; either'
p6166
aS' * version 2.1 of the License, or (at your option) any later version.'
p6167
aS' * The full text of the license can be found in the file LICENSE.md at'
p6168
aS' * the top level directory of deal.II.'
p6169
aS' *'
p6170
aS' * ---------------------------------------------------------------------'
p6171
aS' *'
p6172
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 1999'
p6173
aS' */'
p6174
aS'#include <deal.II/grid/tria.h>'
p6175
aS'#include <deal.II/grid/grid_generator.h>'
p6176
aS'#include <deal.II/dofs/dof_handler.h>'
p6177
aS'#include <deal.II/fe/fe_q.h>'
p6178
aS'#include <deal.II/dofs/dof_tools.h>'
p6179
aS'#include <deal.II/lac/sparse_matrix.h>'
p6180
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p6181
aS'#include <deal.II/dofs/dof_renumbering.h>'
p6182
aS'#include <fstream>'
p6183
aS'using namespace dealii;'
p6184
aS'void make_grid(Triangulation<2> &triangulation)'
p6185
ag24
aS'  const Point<2> center(1, 0);'
p6186
aS'  const double   inner_radius = 0.5, outer_radius = 1.0;'
p6187
aS'  GridGenerator::hyper_shell('
p6188
aS'    triangulation, center, inner_radius, outer_radius, 5);'
p6189
aS'  for (unsigned int step = 0; step < 3; ++step)'
p6190
aS'    {'
p6191
aS'      for (auto &cell : triangulation.active_cell_iterators())'
p6192
aS'        for (const auto v : cell->vertex_indices())'
p6193
aS'          {'
p6194
aS'            const double distance_from_center ='
p6195
aS'              center.distance(cell->vertex(v));'
p6196
aS'            if (std::fabs(distance_from_center - inner_radius) <='
p6197
aS'                1e-6 * inner_radius)'
p6198
aS'              {'
p6199
aS'                cell->set_refine_flag();'
p6200
aS'                break;'
p6201
aS'              }'
p6202
aS'          }'
p6203
aS'      triangulation.execute_coarsening_and_refinement();'
p6204
aS'    }'
p6205
ag32
aS'void distribute_dofs(DoFHandler<2> &dof_handler)'
p6206
ag24
aS'  const FE_Q<2> finite_element(1);'
p6207
aS'  dof_handler.distribute_dofs(finite_element);'
p6208
aS'  DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),'
p6209
aS'                                                  dof_handler.n_dofs());'
p6210
aS'  DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);'
p6211
aS'  SparsityPattern sparsity_pattern;'
p6212
aS'  sparsity_pattern.copy_from(dynamic_sparsity_pattern);'
p6213
aS'  std::ofstream out("sparsity_pattern1.svg");'
p6214
aS'  sparsity_pattern.print_svg(out);'
p6215
ag32
aS'void renumber_dofs(DoFHandler<2> &dof_handler)'
p6216
ag24
aS'  DoFRenumbering::Cuthill_McKee(dof_handler);'
p6217
aS'  DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),'
p6218
aS'                                                  dof_handler.n_dofs());'
p6219
aS'  DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);'
p6220
aS'  SparsityPattern sparsity_pattern;'
p6221
aS'  sparsity_pattern.copy_from(dynamic_sparsity_pattern);'
p6222
aS'  std::ofstream out("sparsity_pattern2.svg");'
p6223
aS'  sparsity_pattern.print_svg(out);'
p6224
ag32
aS'int main()'
p6225
ag24
aS'  Triangulation<2> triangulation;'
p6226
aS'  make_grid(triangulation);'
p6227
aS'  DoFHandler<2> dof_handler(triangulation);'
p6228
aS'  distribute_dofs(dof_handler);'
p6229
aS'  renumber_dofs(dof_handler);'
p6230
ag32
aS'/* ---------------------------------------------------------------------'
p6231
aS' *'
p6232
aS' * Copyright (C) 2005 - 2021 by the deal.II authors'
p6233
aS' *'
p6234
aS' * This file is part of the deal.II library.'
p6235
aS' *'
p6236
aS' * The deal.II library is free software; you can use it, redistribute'
p6237
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p6238
aS' * Public License as published by the Free Software Foundation; either'
p6239
aS' * version 2.1 of the License, or (at your option) any later version.'
p6240
aS' * The full text of the license can be found in the file LICENSE.md at'
p6241
aS' * the top level directory of deal.II.'
p6242
aS' *'
p6243
aS' * ---------------------------------------------------------------------'
p6244
aS' */'
p6245
aS'#include <deal.II/base/quadrature_lib.h>'
p6246
aS'#include <deal.II/base/logstream.h>'
p6247
aS'#include <deal.II/base/function.h>'
p6248
aS'#include <deal.II/lac/block_vector.h>'
p6249
aS'#include <deal.II/lac/full_matrix.h>'
p6250
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p6251
aS'#include <deal.II/lac/solver_cg.h>'
p6252
aS'#include <deal.II/lac/precondition.h>'
p6253
aS'#include <deal.II/lac/linear_operator.h>'
p6254
aS'#include <deal.II/lac/packaged_operation.h>'
p6255
aS'#include <deal.II/grid/tria.h>'
p6256
aS'#include <deal.II/grid/grid_generator.h>'
p6257
aS'#include <deal.II/dofs/dof_handler.h>'
p6258
aS'#include <deal.II/dofs/dof_renumbering.h>'
p6259
aS'#include <deal.II/dofs/dof_tools.h>'
p6260
aS'#include <deal.II/fe/fe_dgq.h>'
p6261
aS'#include <deal.II/fe/fe_system.h>'
p6262
aS'#include <deal.II/fe/fe_values.h>'
p6263
aS'#include <deal.II/numerics/vector_tools.h>'
p6264
aS'#include <deal.II/numerics/matrix_tools.h>'
p6265
aS'#include <deal.II/numerics/data_out.h>'
p6266
aS'#include <fstream>'
p6267
aS'#include <iostream>'
p6268
aS'#include <deal.II/fe/fe_raviart_thomas.h>'
p6269
aS'#include <deal.II/base/tensor_function.h>'
p6270
aS'namespace Step20'
p6271
ag24
aS'  using namespace dealii;'
p6272
aS'  template <int dim>'
p6273
aS'  class MixedLaplaceProblem'
p6274
aS'  {'
p6275
aS'  public:'
p6276
aS'    MixedLaplaceProblem(const unsigned int degree);'
p6277
aS'    void run();'
p6278
aS'  private:'
p6279
aS'    void make_grid_and_dofs();'
p6280
aS'    void assemble_system();'
p6281
aS'    void solve();'
p6282
aS'    void compute_errors() const;'
p6283
aS'    void output_results() const;'
p6284
aS'    const unsigned int degree;'
p6285
aS'    Triangulation<dim> triangulation;'
p6286
aS'    FESystem<dim>      fe;'
p6287
aS'    DoFHandler<dim>    dof_handler;'
p6288
aS'    BlockSparsityPattern      sparsity_pattern;'
p6289
aS'    BlockSparseMatrix<double> system_matrix;'
p6290
aS'    BlockVector<double> solution;'
p6291
aS'    BlockVector<double> system_rhs;'
p6292
aS'  };'
p6293
aS'  namespace PrescribedSolution'
p6294
aS'  {'
p6295
aS'    constexpr double alpha = 0.3;'
p6296
aS'    constexpr double beta  = 1;'
p6297
aS'    template <int dim>'
p6298
aS'    class RightHandSide : public Function<dim>'
p6299
aS'    {'
p6300
aS'    public:'
p6301
aS'      RightHandSide()'
p6302
aS'        : Function<dim>(1)'
p6303
aS'      {}'
p6304
aS'      virtual double value(const Point<dim> & p,'
p6305
aS'                           const unsigned int component = 0) const override;'
p6306
aS'    };'
p6307
aS'    template <int dim>'
p6308
aS'    class PressureBoundaryValues : public Function<dim>'
p6309
aS'    {'
p6310
aS'    public:'
p6311
aS'      PressureBoundaryValues()'
p6312
aS'        : Function<dim>(1)'
p6313
aS'      {}'
p6314
aS'      virtual double value(const Point<dim> & p,'
p6315
aS'                           const unsigned int component = 0) const override;'
p6316
aS'    };'
p6317
aS'    template <int dim>'
p6318
aS'    class ExactSolution : public Function<dim>'
p6319
aS'    {'
p6320
aS'    public:'
p6321
aS'      ExactSolution()'
p6322
aS'        : Function<dim>(dim + 1)'
p6323
aS'      {}'
p6324
aS'      virtual void vector_value(const Point<dim> &p,'
p6325
aS'                                Vector<double> &  value) const override;'
p6326
aS'    };'
p6327
aS'    template <int dim>'
p6328
aS'    double RightHandSide<dim>::value(const Point<dim> & /*p*/,'
p6329
aS'                                     const unsigned int /*component*/) const'
p6330
aS'    {'
p6331
aS'      return 0;'
p6332
aS'    }'
p6333
aS'    template <int dim>'
p6334
aS'    double'
p6335
aS'    PressureBoundaryValues<dim>::value(const Point<dim> &p,'
p6336
aS'                                       const unsigned int /*component*/) const'
p6337
aS'    {'
p6338
aS'      return -(alpha * p[0] * p[1] * p[1] / 2 + beta * p[0] -'
p6339
aS'               alpha * p[0] * p[0] * p[0] / 6);'
p6340
aS'    }'
p6341
aS'    template <int dim>'
p6342
aS'    void ExactSolution<dim>::vector_value(const Point<dim> &p,'
p6343
aS'                                          Vector<double> &  values) const'
p6344
aS'    {'
p6345
aS'      Assert(values.size() == dim + 1,'
p6346
aS'             ExcDimensionMismatch(values.size(), dim + 1));'
p6347
aS'      values(0) = alpha * p[1] * p[1] / 2 + beta - alpha * p[0] * p[0] / 2;'
p6348
aS'      values(1) = alpha * p[0] * p[1];'
p6349
aS'      values(2) = -(alpha * p[0] * p[1] * p[1] / 2 + beta * p[0] -'
p6350
aS'                    alpha * p[0] * p[0] * p[0] / 6);'
p6351
aS'    }'
p6352
aS'    template <int dim>'
p6353
aS'    class KInverse : public TensorFunction<2, dim>'
p6354
aS'    {'
p6355
aS'    public:'
p6356
aS'      KInverse()'
p6357
aS'        : TensorFunction<2, dim>()'
p6358
aS'      {}'
p6359
aS'      virtual void'
p6360
aS'      value_list(const std::vector<Point<dim>> &points,'
p6361
aS'                 std::vector<Tensor<2, dim>> &  values) const override;'
p6362
aS'    };'
p6363
aS'    template <int dim>'
p6364
aS'    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,'
p6365
aS'                                   std::vector<Tensor<2, dim>> &  values) const'
p6366
aS'    {'
p6367
aS'      (void)points;'
p6368
aS'      AssertDimension(points.size(), values.size());'
p6369
aS'      for (auto &value : values)'
p6370
aS'        value = unit_symmetric_tensor<dim>();'
p6371
aS'    }'
p6372
aS'  } // namespace PrescribedSolution'
p6373
aS'  template <int dim>'
p6374
aS'  MixedLaplaceProblem<dim>::MixedLaplaceProblem(const unsigned int degree)'
p6375
aS'    : degree(degree)'
p6376
aS'    , fe(FE_RaviartThomas<dim>(degree), 1, FE_DGQ<dim>(degree), 1)'
p6377
aS'    , dof_handler(triangulation)'
p6378
aS'  {}'
p6379
aS'  template <int dim>'
p6380
aS'  void MixedLaplaceProblem<dim>::make_grid_and_dofs()'
p6381
aS'  {'
p6382
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p6383
aS'    triangulation.refine_global(5);'
p6384
aS'    dof_handler.distribute_dofs(fe);'
p6385
aS'    DoFRenumbering::component_wise(dof_handler);'
p6386
aS'    const std::vector<types::global_dof_index> dofs_per_component ='
p6387
aS'      DoFTools::count_dofs_per_fe_component(dof_handler);'
p6388
aS'    const unsigned int n_u = dofs_per_component[0],'
p6389
aS'                       n_p = dofs_per_component[dim];'
p6390
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p6391
aS'              << std::endl'
p6392
aS'              << "Total number of cells: " << triangulation.n_cells()'
p6393
aS'              << std::endl'
p6394
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p6395
aS'              << " (" << n_u << \'+\' << n_p << \')\' << std::endl;'
p6396
aS'    BlockDynamicSparsityPattern dsp(2, 2);'
p6397
aS'    dsp.block(0, 0).reinit(n_u, n_u);'
p6398
aS'    dsp.block(1, 0).reinit(n_p, n_u);'
p6399
aS'    dsp.block(0, 1).reinit(n_u, n_p);'
p6400
aS'    dsp.block(1, 1).reinit(n_p, n_p);'
p6401
aS'    dsp.collect_sizes();'
p6402
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p6403
aS'    sparsity_pattern.copy_from(dsp);'
p6404
aS'    system_matrix.reinit(sparsity_pattern);'
p6405
aS'    solution.reinit(2);'
p6406
aS'    solution.block(0).reinit(n_u);'
p6407
aS'    solution.block(1).reinit(n_p);'
p6408
aS'    solution.collect_sizes();'
p6409
aS'    system_rhs.reinit(2);'
p6410
aS'    system_rhs.block(0).reinit(n_u);'
p6411
aS'    system_rhs.block(1).reinit(n_p);'
p6412
aS'    system_rhs.collect_sizes();'
p6413
aS'  }'
p6414
aS'  template <int dim>'
p6415
aS'  void MixedLaplaceProblem<dim>::assemble_system()'
p6416
aS'  {'
p6417
aS'    QGauss<dim>     quadrature_formula(degree + 2);'
p6418
aS'    QGauss<dim - 1> face_quadrature_formula(degree + 2);'
p6419
aS'    FEValues<dim>     fe_values(fe,'
p6420
aS'                            quadrature_formula,'
p6421
aS'                            update_values | update_gradients |'
p6422
aS'                              update_quadrature_points | update_JxW_values);'
p6423
aS'    FEFaceValues<dim> fe_face_values(fe,'
p6424
aS'                                     face_quadrature_formula,'
p6425
aS'                                     update_values | update_normal_vectors |'
p6426
aS'                                       update_quadrature_points |'
p6427
aS'                                       update_JxW_values);'
p6428
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p6429
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p6430
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p6431
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p6432
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p6433
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p6434
aS'    const PrescribedSolution::RightHandSide<dim> right_hand_side;'
p6435
aS'    const PrescribedSolution::PressureBoundaryValues<dim>'
p6436
aS'                                            pressure_boundary_values;'
p6437
aS'    const PrescribedSolution::KInverse<dim> k_inverse;'
p6438
aS'    std::vector<double>         rhs_values(n_q_points);'
p6439
aS'    std::vector<double>         boundary_values(n_face_q_points);'
p6440
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p6441
aS'    const FEValuesExtractors::Vector velocities(0);'
p6442
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p6443
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p6444
aS'      {'
p6445
aS'        fe_values.reinit(cell);'
p6446
aS'        local_matrix = 0;'
p6447
aS'        local_rhs    = 0;'
p6448
aS'        right_hand_side.value_list(fe_values.get_quadrature_points(),'
p6449
aS'                                   rhs_values);'
p6450
aS'        k_inverse.value_list(fe_values.get_quadrature_points(),'
p6451
aS'                             k_inverse_values);'
p6452
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p6453
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6454
aS'            {'
p6455
aS'              const Tensor<1, dim> phi_i_u = fe_values[velocities].value(i, q);'
p6456
aS'              const double div_phi_i_u = fe_values[velocities].divergence(i, q);'
p6457
aS'              const double phi_i_p     = fe_values[pressure].value(i, q);'
p6458
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p6459
aS'                {'
p6460
aS'                  const Tensor<1, dim> phi_j_u ='
p6461
aS'                    fe_values[velocities].value(j, q);'
p6462
aS'                  const double div_phi_j_u ='
p6463
aS'                    fe_values[velocities].divergence(j, q);'
p6464
aS'                  const double phi_j_p = fe_values[pressure].value(j, q);'
p6465
aS'                  local_matrix(i, j) +='
p6466
aS'                    (phi_i_u * k_inverse_values[q] * phi_j_u //'
p6467
aS'                     - phi_i_p * div_phi_j_u                 //'
p6468
aS'                     - div_phi_i_u * phi_j_p)                //'
p6469
aS'                    * fe_values.JxW(q);'
p6470
aS'                }'
p6471
aS'              local_rhs(i) += -phi_i_p * rhs_values[q] * fe_values.JxW(q);'
p6472
aS'            }'
p6473
aS'        for (const auto &face : cell->face_iterators())'
p6474
aS'          if (face->at_boundary())'
p6475
aS'            {'
p6476
aS'              fe_face_values.reinit(cell, face);'
p6477
aS'              pressure_boundary_values.value_list('
p6478
aS'                fe_face_values.get_quadrature_points(), boundary_values);'
p6479
aS'              for (unsigned int q = 0; q < n_face_q_points; ++q)'
p6480
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6481
aS'                  local_rhs(i) += -(fe_face_values[velocities].value(i, q) * //'
p6482
aS'                                    fe_face_values.normal_vector(q) *        //'
p6483
aS'                                    boundary_values[q] *                     //'
p6484
aS'                                    fe_face_values.JxW(q));'
p6485
aS'            }'
p6486
aS'        cell->get_dof_indices(local_dof_indices);'
p6487
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6488
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p6489
aS'            system_matrix.add(local_dof_indices[i],'
p6490
aS'                              local_dof_indices[j],'
p6491
aS'                              local_matrix(i, j));'
p6492
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6493
aS'          system_rhs(local_dof_indices[i]) += local_rhs(i);'
p6494
aS'      }'
p6495
aS'  }'
p6496
aS'  template <int dim>'
p6497
aS'  void MixedLaplaceProblem<dim>::solve()'
p6498
aS'  {'
p6499
aS'    const auto &M = system_matrix.block(0, 0);'
p6500
aS'    const auto &B = system_matrix.block(0, 1);'
p6501
aS'    const auto &F = system_rhs.block(0);'
p6502
aS'    const auto &G = system_rhs.block(1);'
p6503
aS'    auto &U = solution.block(0);'
p6504
aS'    auto &P = solution.block(1);'
p6505
aS'    const auto op_M = linear_operator(M);'
p6506
aS'    const auto op_B = linear_operator(B);'
p6507
aS'    ReductionControl         reduction_control_M(2000, 1.0e-18, 1.0e-10);'
p6508
aS'    SolverCG<Vector<double>> solver_M(reduction_control_M);'
p6509
aS'    PreconditionJacobi<SparseMatrix<double>> preconditioner_M;'
p6510
aS'    preconditioner_M.initialize(M);'
p6511
aS'    const auto op_M_inv = inverse_operator(op_M, solver_M, preconditioner_M);'
p6512
aS'    const auto op_S = transpose_operator(op_B) * op_M_inv * op_B;'
p6513
aS'    const auto op_aS ='
p6514
aS'      transpose_operator(op_B) * linear_operator(preconditioner_M) * op_B;'
p6515
aS'    IterationNumberControl   iteration_number_control_aS(30, 1.e-18);'
p6516
aS'    SolverCG<Vector<double>> solver_aS(iteration_number_control_aS);'
p6517
aS'    const auto preconditioner_S ='
p6518
aS'      inverse_operator(op_aS, solver_aS, PreconditionIdentity());'
p6519
aS'    const auto schur_rhs = transpose_operator(op_B) * op_M_inv * F - G;'
p6520
aS'    SolverControl            solver_control_S(2000, 1.e-12);'
p6521
aS'    SolverCG<Vector<double>> solver_S(solver_control_S);'
p6522
aS'    const auto op_S_inv = inverse_operator(op_S, solver_S, preconditioner_S);'
p6523
aS'    P = op_S_inv * schur_rhs;'
p6524
aS'    std::cout << solver_control_S.last_step()'
p6525
aS'              << " CG Schur complement iterations to obtain convergence."'
p6526
aS'              << std::endl;'
p6527
aS'    U = op_M_inv * (F - op_B * P);'
p6528
aS'  }'
p6529
aS'  template <int dim>'
p6530
aS'  void MixedLaplaceProblem<dim>::compute_errors() const'
p6531
aS'  {'
p6532
aS'    const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);'
p6533
aS'    const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),'
p6534
aS'                                                     dim + 1);'
p6535
aS'    PrescribedSolution::ExactSolution<dim> exact_solution;'
p6536
aS'    Vector<double> cellwise_errors(triangulation.n_active_cells());'
p6537
aS'    QTrapezoid<1>  q_trapez;'
p6538
aS'    QIterated<dim> quadrature(q_trapez, degree + 2);'
p6539
aS'    VectorTools::integrate_difference(dof_handler,'
p6540
aS'                                      solution,'
p6541
aS'                                      exact_solution,'
p6542
aS'                                      cellwise_errors,'
p6543
aS'                                      quadrature,'
p6544
aS'                                      VectorTools::L2_norm,'
p6545
aS'                                      &pressure_mask);'
p6546
aS'    const double p_l2_error ='
p6547
aS'      VectorTools::compute_global_error(triangulation,'
p6548
aS'                                        cellwise_errors,'
p6549
aS'                                        VectorTools::L2_norm);'
p6550
aS'    VectorTools::integrate_difference(dof_handler,'
p6551
aS'                                      solution,'
p6552
aS'                                      exact_solution,'
p6553
aS'                                      cellwise_errors,'
p6554
aS'                                      quadrature,'
p6555
aS'                                      VectorTools::L2_norm,'
p6556
aS'                                      &velocity_mask);'
p6557
aS'    const double u_l2_error ='
p6558
aS'      VectorTools::compute_global_error(triangulation,'
p6559
aS'                                        cellwise_errors,'
p6560
aS'                                        VectorTools::L2_norm);'
p6561
aS'    std::cout << "Errors: ||e_p||_L2 = " << p_l2_error'
p6562
aS'              << ",   ||e_u||_L2 = " << u_l2_error << std::endl;'
p6563
aS'  }'
p6564
aS'  template <int dim>'
p6565
aS'  void MixedLaplaceProblem<dim>::output_results() const'
p6566
aS'  {'
p6567
aS'    std::vector<std::string> solution_names(dim, "u");'
p6568
aS'    solution_names.emplace_back("p");'
p6569
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p6570
aS'      interpretation(dim,'
p6571
aS'                     DataComponentInterpretation::component_is_part_of_vector);'
p6572
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p6573
aS'    DataOut<dim> data_out;'
p6574
aS'    data_out.add_data_vector(dof_handler,'
p6575
aS'                             solution,'
p6576
aS'                             solution_names,'
p6577
aS'                             interpretation);'
p6578
aS'    data_out.build_patches(degree + 1);'
p6579
aS'    std::ofstream output("solution.vtu");'
p6580
aS'    data_out.write_vtu(output);'
p6581
aS'  }'
p6582
aS'  template <int dim>'
p6583
aS'  void MixedLaplaceProblem<dim>::run()'
p6584
aS'  {'
p6585
aS'    make_grid_and_dofs();'
p6586
aS'    assemble_system();'
p6587
aS'    solve();'
p6588
aS'    compute_errors();'
p6589
aS'    output_results();'
p6590
aS'  }'
p6591
aS'} // namespace Step20'
p6592
aS'int main()'
p6593
ag24
aS'  try'
p6594
aS'    {'
p6595
aS'      using namespace Step20;'
p6596
aS'      const unsigned int     fe_degree = 0;'
p6597
aS'      MixedLaplaceProblem<2> mixed_laplace_problem(fe_degree);'
p6598
aS'      mixed_laplace_problem.run();'
p6599
aS'    }'
p6600
aS'  catch (std::exception &exc)'
p6601
aS'    {'
p6602
aS'      std::cerr << std::endl'
p6603
aS'                << std::endl'
p6604
aS'                << "----------------------------------------------------"'
p6605
aS'                << std::endl;'
p6606
aS'      std::cerr << "Exception on processing: " << std::endl'
p6607
aS'                << exc.what() << std::endl'
p6608
aS'                << "Aborting!" << std::endl'
p6609
aS'                << "----------------------------------------------------"'
p6610
aS'                << std::endl;'
p6611
aS'      return 1;'
p6612
aS'    }'
p6613
aS'  catch (...)'
p6614
aS'    {'
p6615
aS'      std::cerr << std::endl'
p6616
aS'                << std::endl'
p6617
aS'                << "----------------------------------------------------"'
p6618
aS'                << std::endl;'
p6619
aS'      std::cerr << "Unknown exception!" << std::endl'
p6620
aS'                << "Aborting!" << std::endl'
p6621
aS'                << "----------------------------------------------------"'
p6622
aS'                << std::endl;'
p6623
aS'      return 1;'
p6624
aS'    }'
p6625
aS'  return 0;'
p6626
ag32
aS'/* ---------------------------------------------------------------------'
p6627
aS' *'
p6628
aS' * Copyright (C) 2006 - 2021 by the deal.II authors'
p6629
aS' *'
p6630
aS' * This file is part of the deal.II library.'
p6631
aS' *'
p6632
aS' * The deal.II library is free software; you can use it, redistribute'
p6633
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p6634
aS' * Public License as published by the Free Software Foundation; either'
p6635
aS' * version 2.1 of the License, or (at your option) any later version.'
p6636
aS' * The full text of the license can be found in the file LICENSE.md at'
p6637
aS' * the top level directory of deal.II.'
p6638
aS' *'
p6639
aS' * ---------------------------------------------------------------------'
p6640
aS' *'
p6641
aS' * Authors: Yan Li, Wolfgang Bangerth, Texas A&M University, 2006'
p6642
aS' */'
p6643
aS'#include <deal.II/base/quadrature_lib.h>'
p6644
aS'#include <deal.II/base/logstream.h>'
p6645
aS'#include <deal.II/base/function.h>'
p6646
aS'#include <deal.II/lac/block_vector.h>'
p6647
aS'#include <deal.II/lac/full_matrix.h>'
p6648
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p6649
aS'#include <deal.II/lac/solver_cg.h>'
p6650
aS'#include <deal.II/lac/precondition.h>'
p6651
aS'#include <deal.II/lac/affine_constraints.h>'
p6652
aS'#include <deal.II/grid/tria.h>'
p6653
aS'#include <deal.II/grid/grid_generator.h>'
p6654
aS'#include <deal.II/grid/grid_tools.h>'
p6655
aS'#include <deal.II/dofs/dof_handler.h>'
p6656
aS'#include <deal.II/dofs/dof_renumbering.h>'
p6657
aS'#include <deal.II/dofs/dof_tools.h>'
p6658
aS'#include <deal.II/fe/fe_raviart_thomas.h>'
p6659
aS'#include <deal.II/fe/fe_dgq.h>'
p6660
aS'#include <deal.II/fe/fe_system.h>'
p6661
aS'#include <deal.II/fe/fe_values.h>'
p6662
aS'#include <deal.II/numerics/vector_tools.h>'
p6663
aS'#include <deal.II/numerics/matrix_tools.h>'
p6664
aS'#include <deal.II/numerics/data_out.h>'
p6665
aS'#include <iostream>'
p6666
aS'#include <fstream>'
p6667
aS'#include <deal.II/base/tensor_function.h>'
p6668
aS'#include <deal.II/base/discrete_time.h>'
p6669
aS'namespace Step21'
p6670
ag24
aS'  using namespace dealii;'
p6671
aS'  template <int dim>'
p6672
aS'  class TwoPhaseFlowProblem'
p6673
aS'  {'
p6674
aS'  public:'
p6675
aS'    TwoPhaseFlowProblem(const unsigned int degree);'
p6676
aS'    void run();'
p6677
aS'  private:'
p6678
aS'    void   make_grid_and_dofs();'
p6679
aS'    void   assemble_system();'
p6680
aS'    void   assemble_rhs_S();'
p6681
aS'    double get_maximal_velocity() const;'
p6682
aS'    void   solve();'
p6683
aS'    void   project_back_saturation();'
p6684
aS'    void   output_results() const;'
p6685
aS'    const unsigned int degree;'
p6686
aS'    Triangulation<dim> triangulation;'
p6687
aS'    FESystem<dim>      fe;'
p6688
aS'    DoFHandler<dim>    dof_handler;'
p6689
aS'    BlockSparsityPattern      sparsity_pattern;'
p6690
aS'    BlockSparseMatrix<double> system_matrix;'
p6691
aS'    const unsigned int n_refinement_steps;'
p6692
aS'    DiscreteTime time;'
p6693
aS'    double       viscosity;'
p6694
aS'    BlockVector<double> solution;'
p6695
aS'    BlockVector<double> old_solution;'
p6696
aS'    BlockVector<double> system_rhs;'
p6697
aS'  };'
p6698
aS'  template <int dim>'
p6699
aS'  class PressureRightHandSide : public Function<dim>'
p6700
aS'  {'
p6701
aS'  public:'
p6702
aS'    PressureRightHandSide()'
p6703
aS'      : Function<dim>(1)'
p6704
aS'    {}'
p6705
aS'    virtual double value(const Point<dim> & /*p*/,'
p6706
aS'                         const unsigned int /*component*/ = 0) const override'
p6707
aS'    {'
p6708
aS'      return 0;'
p6709
aS'    }'
p6710
aS'  };'
p6711
aS'  template <int dim>'
p6712
aS'  class PressureBoundaryValues : public Function<dim>'
p6713
aS'  {'
p6714
aS'  public:'
p6715
aS'    PressureBoundaryValues()'
p6716
aS'      : Function<dim>(1)'
p6717
aS'    {}'
p6718
aS'    virtual double value(const Point<dim> &p,'
p6719
aS'                         const unsigned int /*component*/ = 0) const override'
p6720
aS'    {'
p6721
aS'      return 1 - p[0];'
p6722
aS'    }'
p6723
aS'  };'
p6724
aS'  template <int dim>'
p6725
aS'  class SaturationBoundaryValues : public Function<dim>'
p6726
aS'  {'
p6727
aS'  public:'
p6728
aS'    SaturationBoundaryValues()'
p6729
aS'      : Function<dim>(1)'
p6730
aS'    {}'
p6731
aS'    virtual double value(const Point<dim> &p,'
p6732
aS'                         const unsigned int /*component*/ = 0) const override'
p6733
aS'    {'
p6734
aS'      if (p[0] == 0)'
p6735
aS'        return 1;'
p6736
aS'      else'
p6737
aS'        return 0;'
p6738
aS'    }'
p6739
aS'  };'
p6740
aS'  template <int dim>'
p6741
aS'  class InitialValues : public Function<dim>'
p6742
aS'  {'
p6743
aS'  public:'
p6744
aS'    InitialValues()'
p6745
aS'      : Function<dim>(dim + 2)'
p6746
aS'    {}'
p6747
aS'    virtual double value(const Point<dim> & p,'
p6748
aS'                         const unsigned int component = 0) const override'
p6749
aS'    {'
p6750
aS'      return Functions::ZeroFunction<dim>(dim + 2).value(p, component);'
p6751
aS'    }'
p6752
aS'    virtual void vector_value(const Point<dim> &p,'
p6753
aS'                              Vector<double> &  values) const override'
p6754
aS'    {'
p6755
aS'      Functions::ZeroFunction<dim>(dim + 2).vector_value(p, values);'
p6756
aS'    }'
p6757
aS'  };'
p6758
aS'  namespace SingleCurvingCrack'
p6759
aS'  {'
p6760
aS'    template <int dim>'
p6761
aS'    class KInverse : public TensorFunction<2, dim>'
p6762
aS'    {'
p6763
aS'    public:'
p6764
aS'      KInverse()'
p6765
aS'        : TensorFunction<2, dim>()'
p6766
aS'      {}'
p6767
aS'      virtual void'
p6768
aS'      value_list(const std::vector<Point<dim>> &points,'
p6769
aS'                 std::vector<Tensor<2, dim>> &  values) const override'
p6770
aS'      {'
p6771
aS'        Assert(points.size() == values.size(),'
p6772
aS'               ExcDimensionMismatch(points.size(), values.size()));'
p6773
aS'        for (unsigned int p = 0; p < points.size(); ++p)'
p6774
aS'          {'
p6775
aS'            values[p].clear();'
p6776
aS'            const double distance_to_flowline ='
p6777
aS'              std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));'
p6778
aS'            const double permeability ='
p6779
aS'              std::max(std::exp(-(distance_to_flowline * distance_to_flowline) /'
p6780
aS'                                (0.1 * 0.1)),'
p6781
aS'                       0.01);'
p6782
aS'            for (unsigned int d = 0; d < dim; ++d)'
p6783
aS'              values[p][d][d] = 1. / permeability;'
p6784
aS'          }'
p6785
aS'      }'
p6786
aS'    };'
p6787
aS'  } // namespace SingleCurvingCrack'
p6788
aS'  namespace RandomMedium'
p6789
aS'  {'
p6790
aS'    template <int dim>'
p6791
aS'    class KInverse : public TensorFunction<2, dim>'
p6792
aS'    {'
p6793
aS'    public:'
p6794
aS'      KInverse()'
p6795
aS'        : TensorFunction<2, dim>()'
p6796
aS'      {}'
p6797
aS'      virtual void'
p6798
aS'      value_list(const std::vector<Point<dim>> &points,'
p6799
aS'                 std::vector<Tensor<2, dim>> &  values) const override'
p6800
aS'      {'
p6801
aS'        Assert(points.size() == values.size(),'
p6802
aS'               ExcDimensionMismatch(points.size(), values.size()));'
p6803
aS'        for (unsigned int p = 0; p < points.size(); ++p)'
p6804
aS'          {'
p6805
aS'            values[p].clear();'
p6806
aS'            double permeability = 0;'
p6807
aS'            for (unsigned int i = 0; i < centers.size(); ++i)'
p6808
aS'              permeability += std::exp(-(points[p] - centers[i]).norm_square() /'
p6809
aS'                                       (0.05 * 0.05));'
p6810
aS'            const double normalized_permeability ='
p6811
aS'              std::min(std::max(permeability, 0.01), 4.);'
p6812
aS'            for (unsigned int d = 0; d < dim; ++d)'
p6813
aS'              values[p][d][d] = 1. / normalized_permeability;'
p6814
aS'          }'
p6815
aS'      }'
p6816
aS'    private:'
p6817
aS'      static std::vector<Point<dim>> centers;'
p6818
aS'      static std::vector<Point<dim>> get_centers()'
p6819
aS'      {'
p6820
aS'        const unsigned int N ='
p6821
aS'          (dim == 2 ? 40 : (dim == 3 ? 100 : throw ExcNotImplemented()));'
p6822
aS'        std::vector<Point<dim>> centers_list(N);'
p6823
aS'        for (unsigned int i = 0; i < N; ++i)'
p6824
aS'          for (unsigned int d = 0; d < dim; ++d)'
p6825
aS'            centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX;'
p6826
aS'        return centers_list;'
p6827
aS'      }'
p6828
aS'    };'
p6829
aS'    template <int dim>'
p6830
aS'    std::vector<Point<dim>>'
p6831
aS'      KInverse<dim>::centers = KInverse<dim>::get_centers();'
p6832
aS'  } // namespace RandomMedium'
p6833
aS'  double mobility_inverse(const double S, const double viscosity)'
p6834
aS'  {'
p6835
aS'    return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));'
p6836
aS'  }'
p6837
aS'  double fractional_flow(const double S, const double viscosity)'
p6838
aS'  {'
p6839
aS'    return S * S / (S * S + viscosity * (1 - S) * (1 - S));'
p6840
aS'  }'
p6841
aS'  template <class MatrixType>'
p6842
aS'  class InverseMatrix : public Subscriptor'
p6843
aS'  {'
p6844
aS'  public:'
p6845
aS'    InverseMatrix(const MatrixType &m)'
p6846
aS'      : matrix(&m)'
p6847
aS'    {}'
p6848
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const'
p6849
aS'    {'
p6850
aS'      SolverControl solver_control(std::max<unsigned int>(src.size(), 200),'
p6851
aS'                                   1e-8 * src.l2_norm());'
p6852
aS'      SolverCG<Vector<double>> cg(solver_control);'
p6853
aS'      dst = 0;'
p6854
aS'      cg.solve(*matrix, dst, src, PreconditionIdentity());'
p6855
aS'    }'
p6856
aS'  private:'
p6857
aS'    const SmartPointer<const MatrixType> matrix;'
p6858
aS'  };'
p6859
aS'  class SchurComplement : public Subscriptor'
p6860
aS'  {'
p6861
aS'  public:'
p6862
aS'    SchurComplement(const BlockSparseMatrix<double> &          A,'
p6863
aS'                    const InverseMatrix<SparseMatrix<double>> &Minv)'
p6864
aS'      : system_matrix(&A)'
p6865
aS'      , m_inverse(&Minv)'
p6866
aS'      , tmp1(A.block(0, 0).m())'
p6867
aS'      , tmp2(A.block(0, 0).m())'
p6868
aS'    {}'
p6869
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const'
p6870
aS'    {'
p6871
aS'      system_matrix->block(0, 1).vmult(tmp1, src);'
p6872
aS'      m_inverse->vmult(tmp2, tmp1);'
p6873
aS'      system_matrix->block(1, 0).vmult(dst, tmp2);'
p6874
aS'    }'
p6875
aS'  private:'
p6876
aS'    const SmartPointer<const BlockSparseMatrix<double>>           system_matrix;'
p6877
aS'    const SmartPointer<const InverseMatrix<SparseMatrix<double>>> m_inverse;'
p6878
aS'    mutable Vector<double> tmp1, tmp2;'
p6879
aS'  };'
p6880
aS'  class ApproximateSchurComplement : public Subscriptor'
p6881
aS'  {'
p6882
aS'  public:'
p6883
aS'    ApproximateSchurComplement(const BlockSparseMatrix<double> &A)'
p6884
aS'      : system_matrix(&A)'
p6885
aS'      , tmp1(A.block(0, 0).m())'
p6886
aS'      , tmp2(A.block(0, 0).m())'
p6887
aS'    {}'
p6888
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const'
p6889
aS'    {'
p6890
aS'      system_matrix->block(0, 1).vmult(tmp1, src);'
p6891
aS'      system_matrix->block(0, 0).precondition_Jacobi(tmp2, tmp1);'
p6892
aS'      system_matrix->block(1, 0).vmult(dst, tmp2);'
p6893
aS'    }'
p6894
aS'  private:'
p6895
aS'    const SmartPointer<const BlockSparseMatrix<double>> system_matrix;'
p6896
aS'    mutable Vector<double> tmp1, tmp2;'
p6897
aS'  };'
p6898
aS'  template <int dim>'
p6899
aS'  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree)'
p6900
aS'    : degree(degree)'
p6901
aS'    , fe(FE_RaviartThomas<dim>(degree),'
p6902
aS'         1,'
p6903
aS'         FE_DGQ<dim>(degree),'
p6904
aS'         1,'
p6905
aS'         FE_DGQ<dim>(degree),'
p6906
aS'         1)'
p6907
aS'    , dof_handler(triangulation)'
p6908
aS'    , n_refinement_steps(5)'
p6909
aS'    , time(/*start time*/ 0., /*end time*/ 1.)'
p6910
aS'    , viscosity(0.2)'
p6911
aS'  {}'
p6912
aS'  template <int dim>'
p6913
aS'  void TwoPhaseFlowProblem<dim>::make_grid_and_dofs()'
p6914
aS'  {'
p6915
aS'    GridGenerator::hyper_cube(triangulation, 0, 1);'
p6916
aS'    triangulation.refine_global(n_refinement_steps);'
p6917
aS'    dof_handler.distribute_dofs(fe);'
p6918
aS'    DoFRenumbering::component_wise(dof_handler);'
p6919
aS'    const std::vector<types::global_dof_index> dofs_per_component ='
p6920
aS'      DoFTools::count_dofs_per_fe_component(dof_handler);'
p6921
aS'    const unsigned int n_u = dofs_per_component[0],'
p6922
aS'                       n_p = dofs_per_component[dim],'
p6923
aS'                       n_s = dofs_per_component[dim + 1];'
p6924
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p6925
aS'              << std::endl'
p6926
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p6927
aS'              << " (" << n_u << \'+\' << n_p << \'+\' << n_s << \')\' << std::endl'
p6928
aS'              << std::endl;'
p6929
aS'    const unsigned int n_couplings = dof_handler.max_couplings_between_dofs();'
p6930
aS'    sparsity_pattern.reinit(3, 3);'
p6931
aS'    sparsity_pattern.block(0, 0).reinit(n_u, n_u, n_couplings);'
p6932
aS'    sparsity_pattern.block(1, 0).reinit(n_p, n_u, n_couplings);'
p6933
aS'    sparsity_pattern.block(2, 0).reinit(n_s, n_u, n_couplings);'
p6934
aS'    sparsity_pattern.block(0, 1).reinit(n_u, n_p, n_couplings);'
p6935
aS'    sparsity_pattern.block(1, 1).reinit(n_p, n_p, n_couplings);'
p6936
aS'    sparsity_pattern.block(2, 1).reinit(n_s, n_p, n_couplings);'
p6937
aS'    sparsity_pattern.block(0, 2).reinit(n_u, n_s, n_couplings);'
p6938
aS'    sparsity_pattern.block(1, 2).reinit(n_p, n_s, n_couplings);'
p6939
aS'    sparsity_pattern.block(2, 2).reinit(n_s, n_s, n_couplings);'
p6940
aS'    sparsity_pattern.collect_sizes();'
p6941
aS'    DoFTools::make_sparsity_pattern(dof_handler, sparsity_pattern);'
p6942
aS'    sparsity_pattern.compress();'
p6943
aS'    system_matrix.reinit(sparsity_pattern);'
p6944
aS'    solution.reinit(3);'
p6945
aS'    solution.block(0).reinit(n_u);'
p6946
aS'    solution.block(1).reinit(n_p);'
p6947
aS'    solution.block(2).reinit(n_s);'
p6948
aS'    solution.collect_sizes();'
p6949
aS'    old_solution.reinit(3);'
p6950
aS'    old_solution.block(0).reinit(n_u);'
p6951
aS'    old_solution.block(1).reinit(n_p);'
p6952
aS'    old_solution.block(2).reinit(n_s);'
p6953
aS'    old_solution.collect_sizes();'
p6954
aS'    system_rhs.reinit(3);'
p6955
aS'    system_rhs.block(0).reinit(n_u);'
p6956
aS'    system_rhs.block(1).reinit(n_p);'
p6957
aS'    system_rhs.block(2).reinit(n_s);'
p6958
aS'    system_rhs.collect_sizes();'
p6959
aS'  }'
p6960
aS'  template <int dim>'
p6961
aS'  void TwoPhaseFlowProblem<dim>::assemble_system()'
p6962
aS'  {'
p6963
aS'    system_matrix = 0;'
p6964
aS'    system_rhs    = 0;'
p6965
aS'    QGauss<dim>     quadrature_formula(degree + 2);'
p6966
aS'    QGauss<dim - 1> face_quadrature_formula(degree + 2);'
p6967
aS'    FEValues<dim>     fe_values(fe,'
p6968
aS'                            quadrature_formula,'
p6969
aS'                            update_values | update_gradients |'
p6970
aS'                              update_quadrature_points | update_JxW_values);'
p6971
aS'    FEFaceValues<dim> fe_face_values(fe,'
p6972
aS'                                     face_quadrature_formula,'
p6973
aS'                                     update_values | update_normal_vectors |'
p6974
aS'                                       update_quadrature_points |'
p6975
aS'                                       update_JxW_values);'
p6976
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p6977
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p6978
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p6979
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p6980
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p6981
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p6982
aS'    const PressureRightHandSide<dim>  pressure_right_hand_side;'
p6983
aS'    const PressureBoundaryValues<dim> pressure_boundary_values;'
p6984
aS'    const RandomMedium::KInverse<dim> k_inverse;'
p6985
aS'    std::vector<double>         pressure_rhs_values(n_q_points);'
p6986
aS'    std::vector<double>         boundary_values(n_face_q_points);'
p6987
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p6988
aS'    std::vector<Vector<double>>              old_solution_values(n_q_points,'
p6989
aS'                                                                 Vector<double>(dim + 2));'
p6990
aS'    std::vector<std::vector<Tensor<1, dim>>> old_solution_grads('
p6991
aS'      n_q_points, std::vector<Tensor<1, dim>>(dim + 2));'
p6992
aS'    const FEValuesExtractors::Vector velocities(0);'
p6993
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p6994
aS'    const FEValuesExtractors::Scalar saturation(dim + 1);'
p6995
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p6996
aS'      {'
p6997
aS'        fe_values.reinit(cell);'
p6998
aS'        local_matrix = 0;'
p6999
aS'        local_rhs    = 0;'
p7000
aS'        fe_values.get_function_values(old_solution, old_solution_values);'
p7001
aS'        pressure_right_hand_side.value_list(fe_values.get_quadrature_points(),'
p7002
aS'                                            pressure_rhs_values);'
p7003
aS'        k_inverse.value_list(fe_values.get_quadrature_points(),'
p7004
aS'                             k_inverse_values);'
p7005
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p7006
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7007
aS'            {'
p7008
aS'              const double old_s = old_solution_values[q](dim + 1);'
p7009
aS'              const Tensor<1, dim> phi_i_u = fe_values[velocities].value(i, q);'
p7010
aS'              const double div_phi_i_u = fe_values[velocities].divergence(i, q);'
p7011
aS'              const double phi_i_p     = fe_values[pressure].value(i, q);'
p7012
aS'              const double phi_i_s     = fe_values[saturation].value(i, q);'
p7013
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p7014
aS'                {'
p7015
aS'                  const Tensor<1, dim> phi_j_u ='
p7016
aS'                    fe_values[velocities].value(j, q);'
p7017
aS'                  const double div_phi_j_u ='
p7018
aS'                    fe_values[velocities].divergence(j, q);'
p7019
aS'                  const double phi_j_p = fe_values[pressure].value(j, q);'
p7020
aS'                  const double phi_j_s = fe_values[saturation].value(j, q);'
p7021
aS'                  local_matrix(i, j) +='
p7022
aS'                    (phi_i_u * k_inverse_values[q] *'
p7023
aS'                       mobility_inverse(old_s, viscosity) * phi_j_u -'
p7024
aS'                     div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +'
p7025
aS'                     phi_i_s * phi_j_s) *'
p7026
aS'                    fe_values.JxW(q);'
p7027
aS'                }'
p7028
aS'              local_rhs(i) +='
p7029
aS'                (-phi_i_p * pressure_rhs_values[q]) * fe_values.JxW(q);'
p7030
aS'            }'
p7031
aS'        for (const auto &face : cell->face_iterators())'
p7032
aS'          if (face->at_boundary())'
p7033
aS'            {'
p7034
aS'              fe_face_values.reinit(cell, face);'
p7035
aS'              pressure_boundary_values.value_list('
p7036
aS'                fe_face_values.get_quadrature_points(), boundary_values);'
p7037
aS'              for (unsigned int q = 0; q < n_face_q_points; ++q)'
p7038
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7039
aS'                  {'
p7040
aS'                    const Tensor<1, dim> phi_i_u ='
p7041
aS'                      fe_face_values[velocities].value(i, q);'
p7042
aS'                    local_rhs(i) +='
p7043
aS'                      -(phi_i_u * fe_face_values.normal_vector(q) *'
p7044
aS'                        boundary_values[q] * fe_face_values.JxW(q));'
p7045
aS'                  }'
p7046
aS'            }'
p7047
aS'        cell->get_dof_indices(local_dof_indices);'
p7048
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7049
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p7050
aS'            system_matrix.add(local_dof_indices[i],'
p7051
aS'                              local_dof_indices[j],'
p7052
aS'                              local_matrix(i, j));'
p7053
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7054
aS'          system_rhs(local_dof_indices[i]) += local_rhs(i);'
p7055
aS'      }'
p7056
aS'  }'
p7057
aS'  template <int dim>'
p7058
aS'  void TwoPhaseFlowProblem<dim>::assemble_rhs_S()'
p7059
aS'  {'
p7060
aS'    QGauss<dim>       quadrature_formula(degree + 2);'
p7061
aS'    QGauss<dim - 1>   face_quadrature_formula(degree + 2);'
p7062
aS'    FEValues<dim>     fe_values(fe,'
p7063
aS'                            quadrature_formula,'
p7064
aS'                            update_values | update_gradients |'
p7065
aS'                              update_quadrature_points | update_JxW_values);'
p7066
aS'    FEFaceValues<dim> fe_face_values(fe,'
p7067
aS'                                     face_quadrature_formula,'
p7068
aS'                                     update_values | update_normal_vectors |'
p7069
aS'                                       update_quadrature_points |'
p7070
aS'                                       update_JxW_values);'
p7071
aS'    FEFaceValues<dim> fe_face_values_neighbor(fe,'
p7072
aS'                                              face_quadrature_formula,'
p7073
aS'                                              update_values);'
p7074
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p7075
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p7076
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p7077
aS'    Vector<double> local_rhs(dofs_per_cell);'
p7078
aS'    std::vector<Vector<double>> old_solution_values(n_q_points,'
p7079
aS'                                                    Vector<double>(dim + 2));'
p7080
aS'    std::vector<Vector<double>> old_solution_values_face(n_face_q_points,'
p7081
aS'                                                         Vector<double>(dim +'
p7082
aS'                                                                        2));'
p7083
aS'    std::vector<Vector<double>> old_solution_values_face_neighbor('
p7084
aS'      n_face_q_points, Vector<double>(dim + 2));'
p7085
aS'    std::vector<Vector<double>> present_solution_values(n_q_points,'
p7086
aS'                                                        Vector<double>(dim +'
p7087
aS'                                                                       2));'
p7088
aS'    std::vector<Vector<double>> present_solution_values_face('
p7089
aS'      n_face_q_points, Vector<double>(dim + 2));'
p7090
aS'    std::vector<double>                  neighbor_saturation(n_face_q_points);'
p7091
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p7092
aS'    SaturationBoundaryValues<dim> saturation_boundary_values;'
p7093
aS'    const FEValuesExtractors::Scalar saturation(dim + 1);'
p7094
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p7095
aS'      {'
p7096
aS'        local_rhs = 0;'
p7097
aS'        fe_values.reinit(cell);'
p7098
aS'        fe_values.get_function_values(old_solution, old_solution_values);'
p7099
aS'        fe_values.get_function_values(solution, present_solution_values);'
p7100
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p7101
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7102
aS'            {'
p7103
aS'              const double   old_s = old_solution_values[q](dim + 1);'
p7104
aS'              Tensor<1, dim> present_u;'
p7105
aS'              for (unsigned int d = 0; d < dim; ++d)'
p7106
aS'                present_u[d] = present_solution_values[q](d);'
p7107
aS'              const double         phi_i_s = fe_values[saturation].value(i, q);'
p7108
aS'              const Tensor<1, dim> grad_phi_i_s ='
p7109
aS'                fe_values[saturation].gradient(i, q);'
p7110
aS'              local_rhs(i) +='
p7111
aS'                (time.get_next_step_size() * fractional_flow(old_s, viscosity) *'
p7112
aS'                   present_u * grad_phi_i_s +'
p7113
aS'                 old_s * phi_i_s) *'
p7114
aS'                fe_values.JxW(q);'
p7115
aS'            }'
p7116
aS'        for (const auto face_no : cell->face_indices())'
p7117
aS'          {'
p7118
aS'            fe_face_values.reinit(cell, face_no);'
p7119
aS'            fe_face_values.get_function_values(old_solution,'
p7120
aS'                                               old_solution_values_face);'
p7121
aS'            fe_face_values.get_function_values(solution,'
p7122
aS'                                               present_solution_values_face);'
p7123
aS'            if (cell->at_boundary(face_no))'
p7124
aS'              saturation_boundary_values.value_list('
p7125
aS'                fe_face_values.get_quadrature_points(), neighbor_saturation);'
p7126
aS'            else'
p7127
aS'              {'
p7128
aS'                const auto         neighbor = cell->neighbor(face_no);'
p7129
aS'                const unsigned int neighbor_face ='
p7130
aS'                  cell->neighbor_of_neighbor(face_no);'
p7131
aS'                fe_face_values_neighbor.reinit(neighbor, neighbor_face);'
p7132
aS'                fe_face_values_neighbor.get_function_values('
p7133
aS'                  old_solution, old_solution_values_face_neighbor);'
p7134
aS'                for (unsigned int q = 0; q < n_face_q_points; ++q)'
p7135
aS'                  neighbor_saturation[q] ='
p7136
aS'                    old_solution_values_face_neighbor[q](dim + 1);'
p7137
aS'              }'
p7138
aS'            for (unsigned int q = 0; q < n_face_q_points; ++q)'
p7139
aS'              {'
p7140
aS'                Tensor<1, dim> present_u_face;'
p7141
aS'                for (unsigned int d = 0; d < dim; ++d)'
p7142
aS'                  present_u_face[d] = present_solution_values_face[q](d);'
p7143
aS'                const double normal_flux ='
p7144
aS'                  present_u_face * fe_face_values.normal_vector(q);'
p7145
aS'                const bool is_outflow_q_point = (normal_flux >= 0);'
p7146
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7147
aS'                  local_rhs(i) -='
p7148
aS'                    time.get_next_step_size() * normal_flux *'
p7149
aS'                    fractional_flow((is_outflow_q_point == true ?'
p7150
aS'                                       old_solution_values_face[q](dim + 1) :'
p7151
aS'                                       neighbor_saturation[q]),'
p7152
aS'                                    viscosity) *'
p7153
aS'                    fe_face_values[saturation].value(i, q) *'
p7154
aS'                    fe_face_values.JxW(q);'
p7155
aS'              }'
p7156
aS'          }'
p7157
aS'        cell->get_dof_indices(local_dof_indices);'
p7158
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7159
aS'          system_rhs(local_dof_indices[i]) += local_rhs(i);'
p7160
aS'      }'
p7161
aS'  }'
p7162
aS'  template <int dim>'
p7163
aS'  void TwoPhaseFlowProblem<dim>::solve()'
p7164
aS'  {'
p7165
aS'    const InverseMatrix<SparseMatrix<double>> m_inverse('
p7166
aS'      system_matrix.block(0, 0));'
p7167
aS'    Vector<double> tmp(solution.block(0).size());'
p7168
aS'    Vector<double> schur_rhs(solution.block(1).size());'
p7169
aS'    Vector<double> tmp2(solution.block(2).size());'
p7170
aS'    {'
p7171
aS'      m_inverse.vmult(tmp, system_rhs.block(0));'
p7172
aS'      system_matrix.block(1, 0).vmult(schur_rhs, tmp);'
p7173
aS'      schur_rhs -= system_rhs.block(1);'
p7174
aS'      SchurComplement schur_complement(system_matrix, m_inverse);'
p7175
aS'      ApproximateSchurComplement approximate_schur_complement(system_matrix);'
p7176
aS'      InverseMatrix<ApproximateSchurComplement> preconditioner('
p7177
aS'        approximate_schur_complement);'
p7178
aS'      SolverControl            solver_control(solution.block(1).size(),'
p7179
aS'                                   1e-12 * schur_rhs.l2_norm());'
p7180
aS'      SolverCG<Vector<double>> cg(solver_control);'
p7181
aS'      cg.solve(schur_complement, solution.block(1), schur_rhs, preconditioner);'
p7182
aS'      std::cout << "   " << solver_control.last_step()'
p7183
aS'                << " CG Schur complement iterations for pressure." << std::endl;'
p7184
aS'    }'
p7185
aS'    {'
p7186
aS'      system_matrix.block(0, 1).vmult(tmp, solution.block(1));'
p7187
aS'      tmp *= -1;'
p7188
aS'      tmp += system_rhs.block(0);'
p7189
aS'      m_inverse.vmult(solution.block(0), tmp);'
p7190
aS'    }'
p7191
aS'    time.set_desired_next_step_size(std::pow(0.5, double(n_refinement_steps)) /'
p7192
aS'                                    get_maximal_velocity());'
p7193
aS'    assemble_rhs_S();'
p7194
aS'    {'
p7195
aS'      SolverControl            solver_control(system_matrix.block(2, 2).m(),'
p7196
aS'                                   1e-8 * system_rhs.block(2).l2_norm());'
p7197
aS'      SolverCG<Vector<double>> cg(solver_control);'
p7198
aS'      cg.solve(system_matrix.block(2, 2),'
p7199
aS'               solution.block(2),'
p7200
aS'               system_rhs.block(2),'
p7201
aS'               PreconditionIdentity());'
p7202
aS'      project_back_saturation();'
p7203
aS'      std::cout << "   " << solver_control.last_step()'
p7204
aS'                << " CG iterations for saturation." << std::endl;'
p7205
aS'    }'
p7206
aS'    old_solution = solution;'
p7207
aS'  }'
p7208
aS'  template <int dim>'
p7209
aS'  void TwoPhaseFlowProblem<dim>::output_results() const'
p7210
aS'  {'
p7211
aS'    if (time.get_step_number() % 5 != 0)'
p7212
aS'      return;'
p7213
aS'    std::vector<std::string> solution_names;'
p7214
aS'    switch (dim)'
p7215
aS'      {'
p7216
aS'        case 2:'
p7217
aS'          solution_names = {"u", "v", "p", "S"};'
p7218
aS'          break;'
p7219
aS'        case 3:'
p7220
aS'          solution_names = {"u", "v", "w", "p", "S"};'
p7221
aS'          break;'
p7222
aS'        default:'
p7223
aS'          Assert(false, ExcNotImplemented());'
p7224
aS'      }'
p7225
aS'    DataOut<dim> data_out;'
p7226
aS'    data_out.attach_dof_handler(dof_handler);'
p7227
aS'    data_out.add_data_vector(solution, solution_names);'
p7228
aS'    data_out.build_patches(degree + 1);'
p7229
aS'    std::ofstream output("solution-" +'
p7230
aS'                         Utilities::int_to_string(time.get_step_number(), 4) +'
p7231
aS'                         ".vtk");'
p7232
aS'    data_out.write_vtk(output);'
p7233
aS'  }'
p7234
aS'  template <int dim>'
p7235
aS'  void TwoPhaseFlowProblem<dim>::project_back_saturation()'
p7236
aS'  {'
p7237
aS'    for (unsigned int i = 0; i < solution.block(2).size(); ++i)'
p7238
aS'      if (solution.block(2)(i) < 0)'
p7239
aS'        solution.block(2)(i) = 0;'
p7240
aS'      else if (solution.block(2)(i) > 1)'
p7241
aS'        solution.block(2)(i) = 1;'
p7242
aS'  }'
p7243
aS'  template <int dim>'
p7244
aS'  double TwoPhaseFlowProblem<dim>::get_maximal_velocity() const'
p7245
aS'  {'
p7246
aS'    QGauss<dim>        quadrature_formula(degree + 2);'
p7247
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p7248
aS'    FEValues<dim> fe_values(fe, quadrature_formula, update_values);'
p7249
aS'    std::vector<Vector<double>> solution_values(n_q_points,'
p7250
aS'                                                Vector<double>(dim + 2));'
p7251
aS'    double                      max_velocity = 0;'
p7252
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p7253
aS'      {'
p7254
aS'        fe_values.reinit(cell);'
p7255
aS'        fe_values.get_function_values(solution, solution_values);'
p7256
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p7257
aS'          {'
p7258
aS'            Tensor<1, dim> velocity;'
p7259
aS'            for (unsigned int i = 0; i < dim; ++i)'
p7260
aS'              velocity[i] = solution_values[q](i);'
p7261
aS'            max_velocity = std::max(max_velocity, velocity.norm());'
p7262
aS'          }'
p7263
aS'      }'
p7264
aS'    return max_velocity;'
p7265
aS'  }'
p7266
aS'  template <int dim>'
p7267
aS'  void TwoPhaseFlowProblem<dim>::run()'
p7268
aS'  {'
p7269
aS'    make_grid_and_dofs();'
p7270
aS'    {'
p7271
aS'      AffineConstraints<double> constraints;'
p7272
aS'      constraints.close();'
p7273
aS'      VectorTools::project(dof_handler,'
p7274
aS'                           constraints,'
p7275
aS'                           QGauss<dim>(degree + 2),'
p7276
aS'                           InitialValues<dim>(),'
p7277
aS'                           old_solution);'
p7278
aS'    }'
p7279
aS'    do'
p7280
aS'      {'
p7281
aS'        std::cout << "Timestep " << time.get_step_number() + 1 << std::endl;'
p7282
aS'        assemble_system();'
p7283
aS'        solve();'
p7284
aS'        output_results();'
p7285
aS'        time.advance_time();'
p7286
aS'        std::cout << "   Now at t=" << time.get_current_time()'
p7287
aS'                  << ", dt=" << time.get_previous_step_size() << \'.\''
p7288
aS'                  << std::endl'
p7289
aS'                  << std::endl;'
p7290
aS'      }'
p7291
aS'    while (time.is_at_end() == false);'
p7292
aS'  }'
p7293
aS'} // namespace Step21'
p7294
aS'int main()'
p7295
ag24
aS'  try'
p7296
aS'    {'
p7297
aS'      using namespace Step21;'
p7298
aS'      TwoPhaseFlowProblem<2> two_phase_flow_problem(0);'
p7299
aS'      two_phase_flow_problem.run();'
p7300
aS'    }'
p7301
aS'  catch (std::exception &exc)'
p7302
aS'    {'
p7303
aS'      std::cerr << std::endl'
p7304
aS'                << std::endl'
p7305
aS'                << "----------------------------------------------------"'
p7306
aS'                << std::endl;'
p7307
aS'      std::cerr << "Exception on processing: " << std::endl'
p7308
aS'                << exc.what() << std::endl'
p7309
aS'                << "Aborting!" << std::endl'
p7310
aS'                << "----------------------------------------------------"'
p7311
aS'                << std::endl;'
p7312
aS'      return 1;'
p7313
aS'    }'
p7314
aS'  catch (...)'
p7315
aS'    {'
p7316
aS'      std::cerr << std::endl'
p7317
aS'                << std::endl'
p7318
aS'                << "----------------------------------------------------"'
p7319
aS'                << std::endl;'
p7320
aS'      std::cerr << "Unknown exception!" << std::endl'
p7321
aS'                << "Aborting!" << std::endl'
p7322
aS'                << "----------------------------------------------------"'
p7323
aS'                << std::endl;'
p7324
aS'      return 1;'
p7325
aS'    }'
p7326
aS'  return 0;'
p7327
ag32
aS'/* ---------------------------------------------------------------------'
p7328
aS' *'
p7329
aS' * Copyright (C) 2008 - 2021 by the deal.II authors'
p7330
aS' *'
p7331
aS' * This file is part of the deal.II library.'
p7332
aS' *'
p7333
aS' * The deal.II library is free software; you can use it, redistribute'
p7334
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p7335
aS' * Public License as published by the Free Software Foundation; either'
p7336
aS' * version 2.1 of the License, or (at your option) any later version.'
p7337
aS' * The full text of the license can be found in the file LICENSE.md at'
p7338
aS' * the top level directory of deal.II.'
p7339
aS' *'
p7340
aS' * ---------------------------------------------------------------------'
p7341
aS' *'
p7342
aS' * Author: Wolfgang Bangerth, Texas A&M University, 2008'
p7343
aS' */'
p7344
aS'#include <deal.II/base/quadrature_lib.h>'
p7345
aS'#include <deal.II/base/logstream.h>'
p7346
aS'#include <deal.II/base/function.h>'
p7347
aS'#include <deal.II/base/utilities.h>'
p7348
aS'#include <deal.II/lac/block_vector.h>'
p7349
aS'#include <deal.II/lac/full_matrix.h>'
p7350
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p7351
aS'#include <deal.II/lac/solver_cg.h>'
p7352
aS'#include <deal.II/lac/precondition.h>'
p7353
aS'#include <deal.II/lac/affine_constraints.h>'
p7354
aS'#include <deal.II/grid/tria.h>'
p7355
aS'#include <deal.II/grid/grid_generator.h>'
p7356
aS'#include <deal.II/grid/grid_tools.h>'
p7357
aS'#include <deal.II/grid/grid_refinement.h>'
p7358
aS'#include <deal.II/dofs/dof_handler.h>'
p7359
aS'#include <deal.II/dofs/dof_renumbering.h>'
p7360
aS'#include <deal.II/dofs/dof_tools.h>'
p7361
aS'#include <deal.II/fe/fe_q.h>'
p7362
aS'#include <deal.II/fe/fe_system.h>'
p7363
aS'#include <deal.II/fe/fe_values.h>'
p7364
aS'#include <deal.II/numerics/vector_tools.h>'
p7365
aS'#include <deal.II/numerics/matrix_tools.h>'
p7366
aS'#include <deal.II/numerics/data_out.h>'
p7367
aS'#include <deal.II/numerics/error_estimator.h>'
p7368
aS'#include <deal.II/lac/sparse_direct.h>'
p7369
aS'#include <deal.II/lac/sparse_ilu.h>'
p7370
aS'#include <iostream>'
p7371
aS'#include <fstream>'
p7372
aS'#include <memory>'
p7373
aS'namespace Step22'
p7374
ag24
aS'  using namespace dealii;'
p7375
aS'  template <int dim>'
p7376
aS'  struct InnerPreconditioner;'
p7377
aS'  template <>'
p7378
aS'  struct InnerPreconditioner<2>'
p7379
aS'  {'
p7380
aS'    using type = SparseDirectUMFPACK;'
p7381
aS'  };'
p7382
aS'  template <>'
p7383
aS'  struct InnerPreconditioner<3>'
p7384
aS'  {'
p7385
aS'    using type = SparseILU<double>;'
p7386
aS'  };'
p7387
aS'  template <int dim>'
p7388
aS'  class StokesProblem'
p7389
aS'  {'
p7390
aS'  public:'
p7391
aS'    StokesProblem(const unsigned int degree);'
p7392
aS'    void run();'
p7393
aS'  private:'
p7394
aS'    void setup_dofs();'
p7395
aS'    void assemble_system();'
p7396
aS'    void solve();'
p7397
aS'    void output_results(const unsigned int refinement_cycle) const;'
p7398
aS'    void refine_mesh();'
p7399
aS'    const unsigned int degree;'
p7400
aS'    Triangulation<dim> triangulation;'
p7401
aS'    FESystem<dim>      fe;'
p7402
aS'    DoFHandler<dim>    dof_handler;'
p7403
aS'    AffineConstraints<double> constraints;'
p7404
aS'    BlockSparsityPattern      sparsity_pattern;'
p7405
aS'    BlockSparseMatrix<double> system_matrix;'
p7406
aS'    BlockSparsityPattern      preconditioner_sparsity_pattern;'
p7407
aS'    BlockSparseMatrix<double> preconditioner_matrix;'
p7408
aS'    BlockVector<double> solution;'
p7409
aS'    BlockVector<double> system_rhs;'
p7410
aS'    std::shared_ptr<typename InnerPreconditioner<dim>::type> A_preconditioner;'
p7411
aS'  };'
p7412
aS'  template <int dim>'
p7413
aS'  class BoundaryValues : public Function<dim>'
p7414
aS'  {'
p7415
aS'  public:'
p7416
aS'    BoundaryValues()'
p7417
aS'      : Function<dim>(dim + 1)'
p7418
aS'    {}'
p7419
aS'    virtual double value(const Point<dim> & p,'
p7420
aS'                         const unsigned int component = 0) const override;'
p7421
aS'    virtual void vector_value(const Point<dim> &p,'
p7422
aS'                              Vector<double> &  value) const override;'
p7423
aS'  };'
p7424
aS'  template <int dim>'
p7425
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p7426
aS'                                    const unsigned int component) const'
p7427
aS'  {'
p7428
aS'    Assert(component < this->n_components,'
p7429
aS'           ExcIndexRange(component, 0, this->n_components));'
p7430
aS'    if (component == 0)'
p7431
aS'      return (p[0] < 0 ? -1 : (p[0] > 0 ? 1 : 0));'
p7432
aS'    return 0;'
p7433
aS'  }'
p7434
aS'  template <int dim>'
p7435
aS'  void BoundaryValues<dim>::vector_value(const Point<dim> &p,'
p7436
aS'                                         Vector<double> &  values) const'
p7437
aS'  {'
p7438
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p7439
aS'      values(c) = BoundaryValues<dim>::value(p, c);'
p7440
aS'  }'
p7441
aS'  template <int dim>'
p7442
aS'  class RightHandSide : public Function<dim>'
p7443
aS'  {'
p7444
aS'  public:'
p7445
aS'    RightHandSide()'
p7446
aS'      : Function<dim>(dim + 1)'
p7447
aS'    {}'
p7448
aS'    virtual double value(const Point<dim> & p,'
p7449
aS'                         const unsigned int component = 0) const override;'
p7450
aS'    virtual void vector_value(const Point<dim> &p,'
p7451
aS'                              Vector<double> &  value) const override;'
p7452
aS'  };'
p7453
aS'  template <int dim>'
p7454
aS'  double RightHandSide<dim>::value(const Point<dim> & /*p*/,'
p7455
aS'                                   const unsigned int /*component*/) const'
p7456
aS'  {'
p7457
aS'    return 0;'
p7458
aS'  }'
p7459
aS'  template <int dim>'
p7460
aS'  void RightHandSide<dim>::vector_value(const Point<dim> &p,'
p7461
aS'                                        Vector<double> &  values) const'
p7462
aS'  {'
p7463
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p7464
aS'      values(c) = RightHandSide<dim>::value(p, c);'
p7465
aS'  }'
p7466
aS'  template <class MatrixType, class PreconditionerType>'
p7467
aS'  class InverseMatrix : public Subscriptor'
p7468
aS'  {'
p7469
aS'  public:'
p7470
aS'    InverseMatrix(const MatrixType &        m,'
p7471
aS'                  const PreconditionerType &preconditioner);'
p7472
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const;'
p7473
aS'  private:'
p7474
aS'    const SmartPointer<const MatrixType>         matrix;'
p7475
aS'    const SmartPointer<const PreconditionerType> preconditioner;'
p7476
aS'  };'
p7477
aS'  template <class MatrixType, class PreconditionerType>'
p7478
aS'  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p7479
aS'    const MatrixType &        m,'
p7480
aS'    const PreconditionerType &preconditioner)'
p7481
aS'    : matrix(&m)'
p7482
aS'    , preconditioner(&preconditioner)'
p7483
aS'  {}'
p7484
aS'  template <class MatrixType, class PreconditionerType>'
p7485
aS'  void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p7486
aS'    Vector<double> &      dst,'
p7487
aS'    const Vector<double> &src) const'
p7488
aS'  {'
p7489
aS'    SolverControl            solver_control(src.size(), 1e-6 * src.l2_norm());'
p7490
aS'    SolverCG<Vector<double>> cg(solver_control);'
p7491
aS'    dst = 0;'
p7492
aS'    cg.solve(*matrix, dst, src, *preconditioner);'
p7493
aS'  }'
p7494
aS'  template <class PreconditionerType>'
p7495
aS'  class SchurComplement : public Subscriptor'
p7496
aS'  {'
p7497
aS'  public:'
p7498
aS'    SchurComplement('
p7499
aS'      const BlockSparseMatrix<double> &system_matrix,'
p7500
aS'      const InverseMatrix<SparseMatrix<double>, PreconditionerType> &A_inverse);'
p7501
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const;'
p7502
aS'  private:'
p7503
aS'    const SmartPointer<const BlockSparseMatrix<double>> system_matrix;'
p7504
aS'    const SmartPointer<'
p7505
aS'      const InverseMatrix<SparseMatrix<double>, PreconditionerType>>'
p7506
aS'      A_inverse;'
p7507
aS'    mutable Vector<double> tmp1, tmp2;'
p7508
aS'  };'
p7509
aS'  template <class PreconditionerType>'
p7510
aS'  SchurComplement<PreconditionerType>::SchurComplement('
p7511
aS'    const BlockSparseMatrix<double> &system_matrix,'
p7512
aS'    const InverseMatrix<SparseMatrix<double>, PreconditionerType> &A_inverse)'
p7513
aS'    : system_matrix(&system_matrix)'
p7514
aS'    , A_inverse(&A_inverse)'
p7515
aS'    , tmp1(system_matrix.block(0, 0).m())'
p7516
aS'    , tmp2(system_matrix.block(0, 0).m())'
p7517
aS'  {}'
p7518
aS'  template <class PreconditionerType>'
p7519
aS'  void'
p7520
aS'  SchurComplement<PreconditionerType>::vmult(Vector<double> &      dst,'
p7521
aS'                                             const Vector<double> &src) const'
p7522
aS'  {'
p7523
aS'    system_matrix->block(0, 1).vmult(tmp1, src);'
p7524
aS'    A_inverse->vmult(tmp2, tmp1);'
p7525
aS'    system_matrix->block(1, 0).vmult(dst, tmp2);'
p7526
aS'  }'
p7527
aS'  template <int dim>'
p7528
aS'  StokesProblem<dim>::StokesProblem(const unsigned int degree)'
p7529
aS'    : degree(degree)'
p7530
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p7531
aS'    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1)'
p7532
aS'    , dof_handler(triangulation)'
p7533
aS'  {}'
p7534
aS'  template <int dim>'
p7535
aS'  void StokesProblem<dim>::setup_dofs()'
p7536
aS'  {'
p7537
aS'    A_preconditioner.reset();'
p7538
aS'    system_matrix.clear();'
p7539
aS'    preconditioner_matrix.clear();'
p7540
aS'    dof_handler.distribute_dofs(fe);'
p7541
aS'    DoFRenumbering::Cuthill_McKee(dof_handler);'
p7542
aS'    std::vector<unsigned int> block_component(dim + 1, 0);'
p7543
aS'    block_component[dim] = 1;'
p7544
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p7545
aS'    {'
p7546
aS'      constraints.clear();'
p7547
aS'      FEValuesExtractors::Vector velocities(0);'
p7548
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p7549
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p7550
aS'                                               1,'
p7551
aS'                                               BoundaryValues<dim>(),'
p7552
aS'                                               constraints,'
p7553
aS'                                               fe.component_mask(velocities));'
p7554
aS'    }'
p7555
aS'    constraints.close();'
p7556
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p7557
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p7558
aS'    const unsigned int n_u = dofs_per_block[0];'
p7559
aS'    const unsigned int n_p = dofs_per_block[1];'
p7560
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p7561
aS'              << std::endl'
p7562
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p7563
aS'              << " (" << n_u << \'+\' << n_p << \')\' << std::endl;'
p7564
aS'    {'
p7565
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p7566
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p7567
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p7568
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p7569
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p7570
aS'      dsp.collect_sizes();'
p7571
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p7572
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p7573
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p7574
aS'          if (!((c == dim) && (d == dim)))'
p7575
aS'            coupling[c][d] = DoFTools::always;'
p7576
aS'          else'
p7577
aS'            coupling[c][d] = DoFTools::none;'
p7578
aS'      DoFTools::make_sparsity_pattern('
p7579
aS'        dof_handler, coupling, dsp, constraints, false);'
p7580
aS'      sparsity_pattern.copy_from(dsp);'
p7581
aS'    }'
p7582
aS'    {'
p7583
aS'      BlockDynamicSparsityPattern preconditioner_dsp(2, 2);'
p7584
aS'      preconditioner_dsp.block(0, 0).reinit(n_u, n_u);'
p7585
aS'      preconditioner_dsp.block(1, 0).reinit(n_p, n_u);'
p7586
aS'      preconditioner_dsp.block(0, 1).reinit(n_u, n_p);'
p7587
aS'      preconditioner_dsp.block(1, 1).reinit(n_p, n_p);'
p7588
aS'      preconditioner_dsp.collect_sizes();'
p7589
aS'      Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1);'
p7590
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p7591
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p7592
aS'          if (((c == dim) && (d == dim)))'
p7593
aS'            preconditioner_coupling[c][d] = DoFTools::always;'
p7594
aS'          else'
p7595
aS'            preconditioner_coupling[c][d] = DoFTools::none;'
p7596
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p7597
aS'                                      preconditioner_coupling,'
p7598
aS'                                      preconditioner_dsp,'
p7599
aS'                                      constraints,'
p7600
aS'                                      false);'
p7601
aS'      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);'
p7602
aS'    }'
p7603
aS'    system_matrix.reinit(sparsity_pattern);'
p7604
aS'    preconditioner_matrix.reinit(preconditioner_sparsity_pattern);'
p7605
aS'    solution.reinit(2);'
p7606
aS'    solution.block(0).reinit(n_u);'
p7607
aS'    solution.block(1).reinit(n_p);'
p7608
aS'    solution.collect_sizes();'
p7609
aS'    system_rhs.reinit(2);'
p7610
aS'    system_rhs.block(0).reinit(n_u);'
p7611
aS'    system_rhs.block(1).reinit(n_p);'
p7612
aS'    system_rhs.collect_sizes();'
p7613
aS'  }'
p7614
aS'  template <int dim>'
p7615
aS'  void StokesProblem<dim>::assemble_system()'
p7616
aS'  {'
p7617
aS'    system_matrix         = 0;'
p7618
aS'    system_rhs            = 0;'
p7619
aS'    preconditioner_matrix = 0;'
p7620
aS'    QGauss<dim> quadrature_formula(degree + 2);'
p7621
aS'    FEValues<dim> fe_values(fe,'
p7622
aS'                            quadrature_formula,'
p7623
aS'                            update_values | update_quadrature_points |'
p7624
aS'                              update_JxW_values | update_gradients);'
p7625
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p7626
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p7627
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p7628
aS'    FullMatrix<double> local_preconditioner_matrix(dofs_per_cell,'
p7629
aS'                                                   dofs_per_cell);'
p7630
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p7631
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p7632
aS'    const RightHandSide<dim>    right_hand_side;'
p7633
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p7634
aS'    const FEValuesExtractors::Vector velocities(0);'
p7635
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p7636
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p7637
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p7638
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p7639
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p7640
aS'      {'
p7641
aS'        fe_values.reinit(cell);'
p7642
aS'        local_matrix                = 0;'
p7643
aS'        local_preconditioner_matrix = 0;'
p7644
aS'        local_rhs                   = 0;'
p7645
aS'        right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p7646
aS'                                          rhs_values);'
p7647
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p7648
aS'          {'
p7649
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p7650
aS'              {'
p7651
aS'                symgrad_phi_u[k] ='
p7652
aS'                  fe_values[velocities].symmetric_gradient(k, q);'
p7653
aS'                div_phi_u[k] = fe_values[velocities].divergence(k, q);'
p7654
aS'                phi_p[k]     = fe_values[pressure].value(k, q);'
p7655
aS'              }'
p7656
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7657
aS'              {'
p7658
aS'                for (unsigned int j = 0; j <= i; ++j)'
p7659
aS'                  {'
p7660
aS'                    local_matrix(i, j) +='
p7661
aS'                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) // (1)'
p7662
aS'                       - div_phi_u[i] * phi_p[j]                 // (2)'
p7663
aS'                       - phi_p[i] * div_phi_u[j])                // (3)'
p7664
aS'                      * fe_values.JxW(q);                        // * dx'
p7665
aS'                    local_preconditioner_matrix(i, j) +='
p7666
aS'                      (phi_p[i] * phi_p[j]) // (4)'
p7667
aS'                      * fe_values.JxW(q);   // * dx'
p7668
aS'                  }'
p7669
aS'                const unsigned int component_i ='
p7670
aS'                  fe.system_to_component_index(i).first;'
p7671
aS'                local_rhs(i) += (fe_values.shape_value(i, q)   // (phi_u_i(x_q)'
p7672
aS'                                 * rhs_values[q](component_i)) // * f(x_q))'
p7673
aS'                                * fe_values.JxW(q);            // * dx'
p7674
aS'              }'
p7675
aS'          }'
p7676
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7677
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p7678
aS'            {'
p7679
aS'              local_matrix(i, j) = local_matrix(j, i);'
p7680
aS'              local_preconditioner_matrix(i, j) ='
p7681
aS'                local_preconditioner_matrix(j, i);'
p7682
aS'            }'
p7683
aS'        cell->get_dof_indices(local_dof_indices);'
p7684
aS'        constraints.distribute_local_to_global(local_matrix,'
p7685
aS'                                               local_rhs,'
p7686
aS'                                               local_dof_indices,'
p7687
aS'                                               system_matrix,'
p7688
aS'                                               system_rhs);'
p7689
aS'        constraints.distribute_local_to_global(local_preconditioner_matrix,'
p7690
aS'                                               local_dof_indices,'
p7691
aS'                                               preconditioner_matrix);'
p7692
aS'      }'
p7693
aS'    std::cout << "   Computing preconditioner..." << std::endl << std::flush;'
p7694
aS'    A_preconditioner ='
p7695
aS'      std::make_shared<typename InnerPreconditioner<dim>::type>();'
p7696
aS'    A_preconditioner->initialize('
p7697
aS'      system_matrix.block(0, 0),'
p7698
aS'      typename InnerPreconditioner<dim>::type::AdditionalData());'
p7699
aS'  }'
p7700
aS'  template <int dim>'
p7701
aS'  void StokesProblem<dim>::solve()'
p7702
aS'  {'
p7703
aS'    const InverseMatrix<SparseMatrix<double>,'
p7704
aS'                        typename InnerPreconditioner<dim>::type>'
p7705
aS'                   A_inverse(system_matrix.block(0, 0), *A_preconditioner);'
p7706
aS'    Vector<double> tmp(solution.block(0).size());'
p7707
aS'    {'
p7708
aS'      Vector<double> schur_rhs(solution.block(1).size());'
p7709
aS'      A_inverse.vmult(tmp, system_rhs.block(0));'
p7710
aS'      system_matrix.block(1, 0).vmult(schur_rhs, tmp);'
p7711
aS'      schur_rhs -= system_rhs.block(1);'
p7712
aS'      SchurComplement<typename InnerPreconditioner<dim>::type> schur_complement('
p7713
aS'        system_matrix, A_inverse);'
p7714
aS'      SolverControl            solver_control(solution.block(1).size(),'
p7715
aS'                                   1e-6 * schur_rhs.l2_norm());'
p7716
aS'      SolverCG<Vector<double>> cg(solver_control);'
p7717
aS'      SparseILU<double> preconditioner;'
p7718
aS'      preconditioner.initialize(preconditioner_matrix.block(1, 1),'
p7719
aS'                                SparseILU<double>::AdditionalData());'
p7720
aS'      InverseMatrix<SparseMatrix<double>, SparseILU<double>> m_inverse('
p7721
aS'        preconditioner_matrix.block(1, 1), preconditioner);'
p7722
aS'      cg.solve(schur_complement, solution.block(1), schur_rhs, m_inverse);'
p7723
aS'      constraints.distribute(solution);'
p7724
aS'      std::cout << "  " << solver_control.last_step()'
p7725
aS'                << " outer CG Schur complement iterations for pressure"'
p7726
aS'                << std::endl;'
p7727
aS'    }'
p7728
aS'    {'
p7729
aS'      system_matrix.block(0, 1).vmult(tmp, solution.block(1));'
p7730
aS'      tmp *= -1;'
p7731
aS'      tmp += system_rhs.block(0);'
p7732
aS'      A_inverse.vmult(solution.block(0), tmp);'
p7733
aS'      constraints.distribute(solution);'
p7734
aS'    }'
p7735
aS'  }'
p7736
aS'  template <int dim>'
p7737
aS'  void'
p7738
aS'  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const'
p7739
aS'  {'
p7740
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p7741
aS'    solution_names.emplace_back("pressure");'
p7742
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p7743
aS'      data_component_interpretation('
p7744
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p7745
aS'    data_component_interpretation.push_back('
p7746
aS'      DataComponentInterpretation::component_is_scalar);'
p7747
aS'    DataOut<dim> data_out;'
p7748
aS'    data_out.attach_dof_handler(dof_handler);'
p7749
aS'    data_out.add_data_vector(solution,'
p7750
aS'                             solution_names,'
p7751
aS'                             DataOut<dim>::type_dof_data,'
p7752
aS'                             data_component_interpretation);'
p7753
aS'    data_out.build_patches();'
p7754
aS'    std::ofstream output('
p7755
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk");'
p7756
aS'    data_out.write_vtk(output);'
p7757
aS'  }'
p7758
aS'  template <int dim>'
p7759
aS'  void StokesProblem<dim>::refine_mesh()'
p7760
aS'  {'
p7761
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p7762
aS'    FEValuesExtractors::Scalar pressure(dim);'
p7763
aS'    KellyErrorEstimator<dim>::estimate('
p7764
aS'      dof_handler,'
p7765
aS'      QGauss<dim - 1>(degree + 1),'
p7766
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p7767
aS'      solution,'
p7768
aS'      estimated_error_per_cell,'
p7769
aS'      fe.component_mask(pressure));'
p7770
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p7771
aS'                                                    estimated_error_per_cell,'
p7772
aS'                                                    0.3,'
p7773
aS'                                                    0.0);'
p7774
aS'    triangulation.execute_coarsening_and_refinement();'
p7775
aS'  }'
p7776
aS'  template <int dim>'
p7777
aS'  void StokesProblem<dim>::run()'
p7778
aS'  {'
p7779
aS'    {'
p7780
aS'      std::vector<unsigned int> subdivisions(dim, 1);'
p7781
aS'      subdivisions[0] = 4;'
p7782
aS'      const Point<dim> bottom_left = (dim == 2 ?                //'
p7783
aS'                                        Point<dim>(-2, -1) :    // 2d case'
p7784
aS'                                        Point<dim>(-2, 0, -1)); // 3d case'
p7785
aS'      const Point<dim> top_right = (dim == 2 ?              //'
p7786
aS'                                      Point<dim>(2, 0) :    // 2d case'
p7787
aS'                                      Point<dim>(2, 1, 0)); // 3d case'
p7788
aS'      GridGenerator::subdivided_hyper_rectangle(triangulation,'
p7789
aS'                                                subdivisions,'
p7790
aS'                                                bottom_left,'
p7791
aS'                                                top_right);'
p7792
aS'    }'
p7793
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p7794
aS'      for (const auto &face : cell->face_iterators())'
p7795
aS'        if (face->center()[dim - 1] == 0)'
p7796
aS'          face->set_all_boundary_ids(1);'
p7797
aS'    triangulation.refine_global(4 - dim);'
p7798
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 6;'
p7799
aS'         ++refinement_cycle)'
p7800
aS'      {'
p7801
aS'        std::cout << "Refinement cycle " << refinement_cycle << std::endl;'
p7802
aS'        if (refinement_cycle > 0)'
p7803
aS'          refine_mesh();'
p7804
aS'        setup_dofs();'
p7805
aS'        std::cout << "   Assembling..." << std::endl << std::flush;'
p7806
aS'        assemble_system();'
p7807
aS'        std::cout << "   Solving..." << std::flush;'
p7808
aS'        solve();'
p7809
aS'        output_results(refinement_cycle);'
p7810
aS'        std::cout << std::endl;'
p7811
aS'      }'
p7812
aS'  }'
p7813
aS'} // namespace Step22'
p7814
aS'int main()'
p7815
ag24
aS'  try'
p7816
aS'    {'
p7817
aS'      using namespace Step22;'
p7818
aS'      StokesProblem<2> flow_problem(1);'
p7819
aS'      flow_problem.run();'
p7820
aS'    }'
p7821
aS'  catch (std::exception &exc)'
p7822
aS'    {'
p7823
aS'      std::cerr << std::endl'
p7824
aS'                << std::endl'
p7825
aS'                << "----------------------------------------------------"'
p7826
aS'                << std::endl;'
p7827
aS'      std::cerr << "Exception on processing: " << std::endl'
p7828
aS'                << exc.what() << std::endl'
p7829
aS'                << "Aborting!" << std::endl'
p7830
aS'                << "----------------------------------------------------"'
p7831
aS'                << std::endl;'
p7832
aS'      return 1;'
p7833
aS'    }'
p7834
aS'  catch (...)'
p7835
aS'    {'
p7836
aS'      std::cerr << std::endl'
p7837
aS'                << std::endl'
p7838
aS'                << "----------------------------------------------------"'
p7839
aS'                << std::endl;'
p7840
aS'      std::cerr << "Unknown exception!" << std::endl'
p7841
aS'                << "Aborting!" << std::endl'
p7842
aS'                << "----------------------------------------------------"'
p7843
aS'                << std::endl;'
p7844
aS'      return 1;'
p7845
aS'    }'
p7846
aS'  return 0;'
p7847
ag32
aS'/* ---------------------------------------------------------------------'
p7848
aS' *'
p7849
aS' * Copyright (C) 2006 - 2020 by the deal.II authors'
p7850
aS' *'
p7851
aS' * This file is part of the deal.II library.'
p7852
aS' *'
p7853
aS' * The deal.II library is free software; you can use it, redistribute'
p7854
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p7855
aS' * Public License as published by the Free Software Foundation; either'
p7856
aS' * version 2.1 of the License, or (at your option) any later version.'
p7857
aS' * The full text of the license can be found in the file LICENSE.md at'
p7858
aS' * the top level directory of deal.II.'
p7859
aS' *'
p7860
aS' * ---------------------------------------------------------------------'
p7861
aS' *'
p7862
aS' * Author: Wolfgang Bangerth, Texas A&M University, 2006'
p7863
aS' */'
p7864
aS'#include <deal.II/base/quadrature_lib.h>'
p7865
aS'#include <deal.II/base/function.h>'
p7866
aS'#include <deal.II/lac/vector.h>'
p7867
aS'#include <deal.II/lac/sparse_matrix.h>'
p7868
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p7869
aS'#include <deal.II/lac/solver_cg.h>'
p7870
aS'#include <deal.II/lac/precondition.h>'
p7871
aS'#include <deal.II/lac/affine_constraints.h>'
p7872
aS'#include <deal.II/grid/tria.h>'
p7873
aS'#include <deal.II/grid/grid_generator.h>'
p7874
aS'#include <deal.II/dofs/dof_handler.h>'
p7875
aS'#include <deal.II/dofs/dof_tools.h>'
p7876
aS'#include <deal.II/fe/fe_q.h>'
p7877
aS'#include <deal.II/numerics/data_out.h>'
p7878
aS'#include <fstream>'
p7879
aS'#include <iostream>'
p7880
aS'#include <deal.II/numerics/vector_tools.h>'
p7881
aS'#include <deal.II/numerics/matrix_tools.h>'
p7882
aS'#include <deal.II/base/utilities.h>'
p7883
aS'namespace Step23'
p7884
ag24
aS'  using namespace dealii;'
p7885
aS'  template <int dim>'
p7886
aS'  class WaveEquation'
p7887
aS'  {'
p7888
aS'  public:'
p7889
aS'    WaveEquation();'
p7890
aS'    void run();'
p7891
aS'  private:'
p7892
aS'    void setup_system();'
p7893
aS'    void solve_u();'
p7894
aS'    void solve_v();'
p7895
aS'    void output_results() const;'
p7896
aS'    Triangulation<dim> triangulation;'
p7897
aS'    FE_Q<dim>          fe;'
p7898
aS'    DoFHandler<dim>    dof_handler;'
p7899
aS'    AffineConstraints<double> constraints;'
p7900
aS'    SparsityPattern      sparsity_pattern;'
p7901
aS'    SparseMatrix<double> mass_matrix;'
p7902
aS'    SparseMatrix<double> laplace_matrix;'
p7903
aS'    SparseMatrix<double> matrix_u;'
p7904
aS'    SparseMatrix<double> matrix_v;'
p7905
aS'    Vector<double> solution_u, solution_v;'
p7906
aS'    Vector<double> old_solution_u, old_solution_v;'
p7907
aS'    Vector<double> system_rhs;'
p7908
aS'    double       time_step;'
p7909
aS'    double       time;'
p7910
aS'    unsigned int timestep_number;'
p7911
aS'    const double theta;'
p7912
aS'  };'
p7913
aS'  template <int dim>'
p7914
aS'  class InitialValuesU : public Function<dim>'
p7915
aS'  {'
p7916
aS'  public:'
p7917
aS'    virtual double value(const Point<dim> & /*p*/,'
p7918
aS'                         const unsigned int component = 0) const override'
p7919
aS'    {'
p7920
aS'      (void)component;'
p7921
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7922
aS'      return 0;'
p7923
aS'    }'
p7924
aS'  };'
p7925
aS'  template <int dim>'
p7926
aS'  class InitialValuesV : public Function<dim>'
p7927
aS'  {'
p7928
aS'  public:'
p7929
aS'    virtual double value(const Point<dim> & /*p*/,'
p7930
aS'                         const unsigned int component = 0) const override'
p7931
aS'    {'
p7932
aS'      (void)component;'
p7933
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7934
aS'      return 0;'
p7935
aS'    }'
p7936
aS'  };'
p7937
aS'  template <int dim>'
p7938
aS'  class RightHandSide : public Function<dim>'
p7939
aS'  {'
p7940
aS'  public:'
p7941
aS'    virtual double value(const Point<dim> & /*p*/,'
p7942
aS'                         const unsigned int component = 0) const override'
p7943
aS'    {'
p7944
aS'      (void)component;'
p7945
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7946
aS'      return 0;'
p7947
aS'    }'
p7948
aS'  };'
p7949
aS'  template <int dim>'
p7950
aS'  class BoundaryValuesU : public Function<dim>'
p7951
aS'  {'
p7952
aS'  public:'
p7953
aS'    virtual double value(const Point<dim> & p,'
p7954
aS'                         const unsigned int component = 0) const override'
p7955
aS'    {'
p7956
aS'      (void)component;'
p7957
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7958
aS'      if ((this->get_time() <= 0.5) && (p[0] < 0) && (p[1] < 1. / 3) &&'
p7959
aS'          (p[1] > -1. / 3))'
p7960
aS'        return std::sin(this->get_time() * 4 * numbers::PI);'
p7961
aS'      else'
p7962
aS'        return 0;'
p7963
aS'    }'
p7964
aS'  };'
p7965
aS'  template <int dim>'
p7966
aS'  class BoundaryValuesV : public Function<dim>'
p7967
aS'  {'
p7968
aS'  public:'
p7969
aS'    virtual double value(const Point<dim> & p,'
p7970
aS'                         const unsigned int component = 0) const override'
p7971
aS'    {'
p7972
aS'      (void)component;'
p7973
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7974
aS'      if ((this->get_time() <= 0.5) && (p[0] < 0) && (p[1] < 1. / 3) &&'
p7975
aS'          (p[1] > -1. / 3))'
p7976
aS'        return (std::cos(this->get_time() * 4 * numbers::PI) * 4 * numbers::PI);'
p7977
aS'      else'
p7978
aS'        return 0;'
p7979
aS'    }'
p7980
aS'  };'
p7981
aS'  template <int dim>'
p7982
aS'  WaveEquation<dim>::WaveEquation()'
p7983
aS'    : fe(1)'
p7984
aS'    , dof_handler(triangulation)'
p7985
aS'    , time_step(1. / 64)'
p7986
aS'    , time(time_step)'
p7987
aS'    , timestep_number(1)'
p7988
aS'    , theta(0.5)'
p7989
aS'  {}'
p7990
aS'  template <int dim>'
p7991
aS'  void WaveEquation<dim>::setup_system()'
p7992
aS'  {'
p7993
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p7994
aS'    triangulation.refine_global(7);'
p7995
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p7996
aS'              << std::endl;'
p7997
aS'    dof_handler.distribute_dofs(fe);'
p7998
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p7999
aS'              << std::endl'
p8000
aS'              << std::endl;'
p8001
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p8002
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p8003
aS'    sparsity_pattern.copy_from(dsp);'
p8004
aS'    mass_matrix.reinit(sparsity_pattern);'
p8005
aS'    laplace_matrix.reinit(sparsity_pattern);'
p8006
aS'    matrix_u.reinit(sparsity_pattern);'
p8007
aS'    matrix_v.reinit(sparsity_pattern);'
p8008
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p8009
aS'                                      QGauss<dim>(fe.degree + 1),'
p8010
aS'                                      mass_matrix);'
p8011
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p8012
aS'                                         QGauss<dim>(fe.degree + 1),'
p8013
aS'                                         laplace_matrix);'
p8014
aS'    solution_u.reinit(dof_handler.n_dofs());'
p8015
aS'    solution_v.reinit(dof_handler.n_dofs());'
p8016
aS'    old_solution_u.reinit(dof_handler.n_dofs());'
p8017
aS'    old_solution_v.reinit(dof_handler.n_dofs());'
p8018
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p8019
aS'    constraints.close();'
p8020
aS'  }'
p8021
aS'  template <int dim>'
p8022
aS'  void WaveEquation<dim>::solve_u()'
p8023
aS'  {'
p8024
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p8025
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8026
aS'    cg.solve(matrix_u, solution_u, system_rhs, PreconditionIdentity());'
p8027
aS'    std::cout << "   u-equation: " << solver_control.last_step()'
p8028
aS'              << " CG iterations." << std::endl;'
p8029
aS'  }'
p8030
aS'  template <int dim>'
p8031
aS'  void WaveEquation<dim>::solve_v()'
p8032
aS'  {'
p8033
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p8034
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8035
aS'    cg.solve(matrix_v, solution_v, system_rhs, PreconditionIdentity());'
p8036
aS'    std::cout << "   v-equation: " << solver_control.last_step()'
p8037
aS'              << " CG iterations." << std::endl;'
p8038
aS'  }'
p8039
aS'  template <int dim>'
p8040
aS'  void WaveEquation<dim>::output_results() const'
p8041
aS'  {'
p8042
aS'    DataOut<dim> data_out;'
p8043
aS'    data_out.attach_dof_handler(dof_handler);'
p8044
aS'    data_out.add_data_vector(solution_u, "U");'
p8045
aS'    data_out.add_data_vector(solution_v, "V");'
p8046
aS'    data_out.build_patches();'
p8047
aS'    const std::string filename ='
p8048
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p8049
aS'    DataOutBase::VtkFlags vtk_flags;'
p8050
aS'    vtk_flags.compression_level ='
p8051
aS'      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p8052
aS'    data_out.set_flags(vtk_flags);'
p8053
aS'    std::ofstream output(filename);'
p8054
aS'    data_out.write_vtu(output);'
p8055
aS'  }'
p8056
aS'  template <int dim>'
p8057
aS'  void WaveEquation<dim>::run()'
p8058
aS'  {'
p8059
aS'    setup_system();'
p8060
aS'    VectorTools::project(dof_handler,'
p8061
aS'                         constraints,'
p8062
aS'                         QGauss<dim>(fe.degree + 1),'
p8063
aS'                         InitialValuesU<dim>(),'
p8064
aS'                         old_solution_u);'
p8065
aS'    VectorTools::project(dof_handler,'
p8066
aS'                         constraints,'
p8067
aS'                         QGauss<dim>(fe.degree + 1),'
p8068
aS'                         InitialValuesV<dim>(),'
p8069
aS'                         old_solution_v);'
p8070
aS'    Vector<double> tmp(solution_u.size());'
p8071
aS'    Vector<double> forcing_terms(solution_u.size());'
p8072
aS'    for (; time <= 5; time += time_step, ++timestep_number)'
p8073
aS'      {'
p8074
aS'        std::cout << "Time step " << timestep_number << " at t=" << time'
p8075
aS'                  << std::endl;'
p8076
aS'        mass_matrix.vmult(system_rhs, old_solution_u);'
p8077
aS'        mass_matrix.vmult(tmp, old_solution_v);'
p8078
aS'        system_rhs.add(time_step, tmp);'
p8079
aS'        laplace_matrix.vmult(tmp, old_solution_u);'
p8080
aS'        system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);'
p8081
aS'        RightHandSide<dim> rhs_function;'
p8082
aS'        rhs_function.set_time(time);'
p8083
aS'        VectorTools::create_right_hand_side(dof_handler,'
p8084
aS'                                            QGauss<dim>(fe.degree + 1),'
p8085
aS'                                            rhs_function,'
p8086
aS'                                            tmp);'
p8087
aS'        forcing_terms = tmp;'
p8088
aS'        forcing_terms *= theta * time_step;'
p8089
aS'        rhs_function.set_time(time - time_step);'
p8090
aS'        VectorTools::create_right_hand_side(dof_handler,'
p8091
aS'                                            QGauss<dim>(fe.degree + 1),'
p8092
aS'                                            rhs_function,'
p8093
aS'                                            tmp);'
p8094
aS'        forcing_terms.add((1 - theta) * time_step, tmp);'
p8095
aS'        system_rhs.add(theta * time_step, forcing_terms);'
p8096
aS'        {'
p8097
aS'          BoundaryValuesU<dim> boundary_values_u_function;'
p8098
aS'          boundary_values_u_function.set_time(time);'
p8099
aS'          std::map<types::global_dof_index, double> boundary_values;'
p8100
aS'          VectorTools::interpolate_boundary_values(dof_handler,'
p8101
aS'                                                   0,'
p8102
aS'                                                   boundary_values_u_function,'
p8103
aS'                                                   boundary_values);'
p8104
aS'          matrix_u.copy_from(mass_matrix);'
p8105
aS'          matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);'
p8106
aS'          MatrixTools::apply_boundary_values(boundary_values,'
p8107
aS'                                             matrix_u,'
p8108
aS'                                             solution_u,'
p8109
aS'                                             system_rhs);'
p8110
aS'        }'
p8111
aS'        solve_u();'
p8112
aS'        laplace_matrix.vmult(system_rhs, solution_u);'
p8113
aS'        system_rhs *= -theta * time_step;'
p8114
aS'        mass_matrix.vmult(tmp, old_solution_v);'
p8115
aS'        system_rhs += tmp;'
p8116
aS'        laplace_matrix.vmult(tmp, old_solution_u);'
p8117
aS'        system_rhs.add(-time_step * (1 - theta), tmp);'
p8118
aS'        system_rhs += forcing_terms;'
p8119
aS'        {'
p8120
aS'          BoundaryValuesV<dim> boundary_values_v_function;'
p8121
aS'          boundary_values_v_function.set_time(time);'
p8122
aS'          std::map<types::global_dof_index, double> boundary_values;'
p8123
aS'          VectorTools::interpolate_boundary_values(dof_handler,'
p8124
aS'                                                   0,'
p8125
aS'                                                   boundary_values_v_function,'
p8126
aS'                                                   boundary_values);'
p8127
aS'          matrix_v.copy_from(mass_matrix);'
p8128
aS'          MatrixTools::apply_boundary_values(boundary_values,'
p8129
aS'                                             matrix_v,'
p8130
aS'                                             solution_v,'
p8131
aS'                                             system_rhs);'
p8132
aS'        }'
p8133
aS'        solve_v();'
p8134
aS'        output_results();'
p8135
aS'        std::cout << "   Total energy: "'
p8136
aS'                  << (mass_matrix.matrix_norm_square(solution_v) +'
p8137
aS'                      laplace_matrix.matrix_norm_square(solution_u)) /'
p8138
aS'                       2'
p8139
aS'                  << std::endl;'
p8140
aS'        old_solution_u = solution_u;'
p8141
aS'        old_solution_v = solution_v;'
p8142
aS'      }'
p8143
aS'  }'
p8144
aS'} // namespace Step23'
p8145
aS'int main()'
p8146
ag24
aS'  try'
p8147
aS'    {'
p8148
aS'      using namespace Step23;'
p8149
aS'      WaveEquation<2> wave_equation_solver;'
p8150
aS'      wave_equation_solver.run();'
p8151
aS'    }'
p8152
aS'  catch (std::exception &exc)'
p8153
aS'    {'
p8154
aS'      std::cerr << std::endl'
p8155
aS'                << std::endl'
p8156
aS'                << "----------------------------------------------------"'
p8157
aS'                << std::endl;'
p8158
aS'      std::cerr << "Exception on processing: " << std::endl'
p8159
aS'                << exc.what() << std::endl'
p8160
aS'                << "Aborting!" << std::endl'
p8161
aS'                << "----------------------------------------------------"'
p8162
aS'                << std::endl;'
p8163
aS'      return 1;'
p8164
aS'    }'
p8165
aS'  catch (...)'
p8166
aS'    {'
p8167
aS'      std::cerr << std::endl'
p8168
aS'                << std::endl'
p8169
aS'                << "----------------------------------------------------"'
p8170
aS'                << std::endl;'
p8171
aS'      std::cerr << "Unknown exception!" << std::endl'
p8172
aS'                << "Aborting!" << std::endl'
p8173
aS'                << "----------------------------------------------------"'
p8174
aS'                << std::endl;'
p8175
aS'      return 1;'
p8176
aS'    }'
p8177
aS'  return 0;'
p8178
ag32
aS'/* ---------------------------------------------------------------------'
p8179
aS' *'
p8180
aS' * Copyright (C) 2006 - 2021 by the deal.II authors'
p8181
aS' *'
p8182
aS' * This file is part of the deal.II library.'
p8183
aS' *'
p8184
aS' * The deal.II library is free software; you can use it, redistribute'
p8185
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p8186
aS' * Public License as published by the Free Software Foundation; either'
p8187
aS' * version 2.1 of the License, or (at your option) any later version.'
p8188
aS' * The full text of the license can be found in the file LICENSE.md at'
p8189
aS' * the top level directory of deal.II.'
p8190
aS' *'
p8191
aS' * ---------------------------------------------------------------------'
p8192
aS' *'
p8193
aS' * Author: Xing Jin, Wolfgang Bangerth, Texas A&M University, 2006'
p8194
aS' */'
p8195
aS'#include <deal.II/base/quadrature_lib.h>'
p8196
aS'#include <deal.II/base/function.h>'
p8197
aS'#include <deal.II/base/logstream.h>'
p8198
aS'#include <deal.II/base/utilities.h>'
p8199
aS'#include <deal.II/lac/vector.h>'
p8200
aS'#include <deal.II/lac/full_matrix.h>'
p8201
aS'#include <deal.II/lac/sparse_matrix.h>'
p8202
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p8203
aS'#include <deal.II/lac/solver_cg.h>'
p8204
aS'#include <deal.II/lac/precondition.h>'
p8205
aS'#include <deal.II/lac/affine_constraints.h>'
p8206
aS'#include <deal.II/grid/tria.h>'
p8207
aS'#include <deal.II/grid/grid_generator.h>'
p8208
aS'#include <deal.II/dofs/dof_handler.h>'
p8209
aS'#include <deal.II/dofs/dof_tools.h>'
p8210
aS'#include <deal.II/fe/fe_q.h>'
p8211
aS'#include <deal.II/fe/fe_values.h>'
p8212
aS'#include <deal.II/numerics/data_out.h>'
p8213
aS'#include <deal.II/numerics/matrix_tools.h>'
p8214
aS'#include <deal.II/numerics/vector_tools.h>'
p8215
aS'#include <fstream>'
p8216
aS'#include <iostream>'
p8217
aS'#include <deal.II/grid/grid_tools.h>'
p8218
aS'namespace Step24'
p8219
ag24
aS'  using namespace dealii;'
p8220
aS'  template <int dim>'
p8221
aS'  class TATForwardProblem'
p8222
aS'  {'
p8223
aS'  public:'
p8224
aS'    TATForwardProblem();'
p8225
aS'    void run();'
p8226
aS'  private:'
p8227
aS'    void setup_system();'
p8228
aS'    void solve_p();'
p8229
aS'    void solve_v();'
p8230
aS'    void output_results() const;'
p8231
aS'    Triangulation<dim> triangulation;'
p8232
aS'    FE_Q<dim>          fe;'
p8233
aS'    DoFHandler<dim>    dof_handler;'
p8234
aS'    AffineConstraints<double> constraints;'
p8235
aS'    SparsityPattern      sparsity_pattern;'
p8236
aS'    SparseMatrix<double> system_matrix;'
p8237
aS'    SparseMatrix<double> mass_matrix;'
p8238
aS'    SparseMatrix<double> laplace_matrix;'
p8239
aS'    Vector<double> solution_p, solution_v;'
p8240
aS'    Vector<double> old_solution_p, old_solution_v;'
p8241
aS'    Vector<double> system_rhs_p, system_rhs_v;'
p8242
aS'    double       time_step, time;'
p8243
aS'    unsigned int timestep_number;'
p8244
aS'    const double theta;'
p8245
aS'    SparseMatrix<double> boundary_matrix;'
p8246
aS'    const double         wave_speed;'
p8247
aS'    std::vector<Point<dim>> detector_locations;'
p8248
aS'  };'
p8249
aS'  template <int dim>'
p8250
aS'  class InitialValuesP : public Function<dim>'
p8251
aS'  {'
p8252
aS'  public:'
p8253
aS'    virtual double value(const Point<dim> &p,'
p8254
aS'                         const unsigned int /*component*/ = 0) const override'
p8255
aS'    {'
p8256
aS'      static const std::array<Source, 5> sources{'
p8257
aS'        {Source(Point<dim>(0, 0), 0.025),'
p8258
aS'         Source(Point<dim>(-0.135, 0), 0.05),'
p8259
aS'         Source(Point<dim>(0.17, 0), 0.03),'
p8260
aS'         Source(Point<dim>(-0.25, 0), 0.02),'
p8261
aS'         Source(Point<dim>(-0.05, -0.15), 0.015)}};'
p8262
aS'      for (const auto &source : sources)'
p8263
aS'        if (p.distance(source.location) < source.radius)'
p8264
aS'          return 1;'
p8265
aS'      return 0;'
p8266
aS'    }'
p8267
aS'  private:'
p8268
aS'    struct Source'
p8269
aS'    {'
p8270
aS'      Source(const Point<dim> &l, const double r)'
p8271
aS'        : location(l)'
p8272
aS'        , radius(r)'
p8273
aS'      {}'
p8274
aS'      const Point<dim> location;'
p8275
aS'      const double     radius;'
p8276
aS'    };'
p8277
aS'  };'
p8278
aS'  template <int dim>'
p8279
aS'  TATForwardProblem<dim>::TATForwardProblem()'
p8280
aS'    : fe(1)'
p8281
aS'    , dof_handler(triangulation)'
p8282
aS'    , time_step(std::numeric_limits<double>::quiet_NaN())'
p8283
aS'    , time(time_step)'
p8284
aS'    , timestep_number(1)'
p8285
aS'    , theta(0.5)'
p8286
aS'    , wave_speed(1.437)'
p8287
aS'  {'
p8288
aS'    Assert(dim == 2, ExcNotImplemented());'
p8289
aS'    const double detector_step_angle = 2.25;'
p8290
aS'    const double detector_radius     = 0.5;'
p8291
aS'    for (double detector_angle = 2 * numbers::PI; detector_angle >= 0;'
p8292
aS'         detector_angle -= detector_step_angle / 360 * 2 * numbers::PI)'
p8293
aS'      detector_locations.push_back('
p8294
aS'        Point<dim>(std::cos(detector_angle), std::sin(detector_angle)) *'
p8295
aS'        detector_radius);'
p8296
aS'  }'
p8297
aS'  template <int dim>'
p8298
aS'  void TATForwardProblem<dim>::setup_system()'
p8299
aS'  {'
p8300
aS'    const Point<dim> center;'
p8301
aS'    GridGenerator::hyper_ball(triangulation, center, 1.);'
p8302
aS'    triangulation.refine_global(7);'
p8303
aS'    time_step = GridTools::minimal_cell_diameter(triangulation) / wave_speed /'
p8304
aS'                std::sqrt(1. * dim);'
p8305
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p8306
aS'              << std::endl;'
p8307
aS'    dof_handler.distribute_dofs(fe);'
p8308
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p8309
aS'              << std::endl'
p8310
aS'              << std::endl;'
p8311
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p8312
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p8313
aS'    sparsity_pattern.copy_from(dsp);'
p8314
aS'    system_matrix.reinit(sparsity_pattern);'
p8315
aS'    mass_matrix.reinit(sparsity_pattern);'
p8316
aS'    laplace_matrix.reinit(sparsity_pattern);'
p8317
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p8318
aS'                                      QGauss<dim>(fe.degree + 1),'
p8319
aS'                                      mass_matrix);'
p8320
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p8321
aS'                                         QGauss<dim>(fe.degree + 1),'
p8322
aS'                                         laplace_matrix);'
p8323
aS'    boundary_matrix.reinit(sparsity_pattern);'
p8324
aS'    {'
p8325
aS'      const QGauss<dim - 1> quadrature_formula(fe.degree + 1);'
p8326
aS'      FEFaceValues<dim>     fe_values(fe,'
p8327
aS'                                  quadrature_formula,'
p8328
aS'                                  update_values | update_JxW_values);'
p8329
aS'      const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p8330
aS'      const unsigned int n_q_points    = quadrature_formula.size();'
p8331
aS'      FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p8332
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p8333
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p8334
aS'        for (const auto &face : cell->face_iterators())'
p8335
aS'          if (face->at_boundary())'
p8336
aS'            {'
p8337
aS'              cell_matrix = 0;'
p8338
aS'              fe_values.reinit(cell, face);'
p8339
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p8340
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8341
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8342
aS'                    cell_matrix(i, j) += (fe_values.shape_value(i, q_point) *'
p8343
aS'                                          fe_values.shape_value(j, q_point) *'
p8344
aS'                                          fe_values.JxW(q_point));'
p8345
aS'              cell->get_dof_indices(local_dof_indices);'
p8346
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8347
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8348
aS'                  boundary_matrix.add(local_dof_indices[i],'
p8349
aS'                                      local_dof_indices[j],'
p8350
aS'                                      cell_matrix(i, j));'
p8351
aS'            }'
p8352
aS'    }'
p8353
aS'    system_matrix.copy_from(mass_matrix);'
p8354
aS'    system_matrix.add(time_step * time_step * theta * theta * wave_speed *'
p8355
aS'                        wave_speed,'
p8356
aS'                      laplace_matrix);'
p8357
aS'    system_matrix.add(wave_speed * theta * time_step, boundary_matrix);'
p8358
aS'    solution_p.reinit(dof_handler.n_dofs());'
p8359
aS'    old_solution_p.reinit(dof_handler.n_dofs());'
p8360
aS'    system_rhs_p.reinit(dof_handler.n_dofs());'
p8361
aS'    solution_v.reinit(dof_handler.n_dofs());'
p8362
aS'    old_solution_v.reinit(dof_handler.n_dofs());'
p8363
aS'    system_rhs_v.reinit(dof_handler.n_dofs());'
p8364
aS'    constraints.close();'
p8365
aS'  }'
p8366
aS'  template <int dim>'
p8367
aS'  void TATForwardProblem<dim>::solve_p()'
p8368
aS'  {'
p8369
aS'    SolverControl solver_control(1000, 1e-8 * system_rhs_p.l2_norm());'
p8370
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8371
aS'    cg.solve(system_matrix, solution_p, system_rhs_p, PreconditionIdentity());'
p8372
aS'    std::cout << "   p-equation: " << solver_control.last_step()'
p8373
aS'              << " CG iterations." << std::endl;'
p8374
aS'  }'
p8375
aS'  template <int dim>'
p8376
aS'  void TATForwardProblem<dim>::solve_v()'
p8377
aS'  {'
p8378
aS'    SolverControl solver_control(1000, 1e-8 * system_rhs_v.l2_norm());'
p8379
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8380
aS'    cg.solve(mass_matrix, solution_v, system_rhs_v, PreconditionIdentity());'
p8381
aS'    std::cout << "   v-equation: " << solver_control.last_step()'
p8382
aS'              << " CG iterations." << std::endl;'
p8383
aS'  }'
p8384
aS'  template <int dim>'
p8385
aS'  void TATForwardProblem<dim>::output_results() const'
p8386
aS'  {'
p8387
aS'    DataOut<dim> data_out;'
p8388
aS'    data_out.attach_dof_handler(dof_handler);'
p8389
aS'    data_out.add_data_vector(solution_p, "P");'
p8390
aS'    data_out.add_data_vector(solution_v, "V");'
p8391
aS'    data_out.build_patches();'
p8392
aS'    const std::string filename ='
p8393
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p8394
aS'    DataOutBase::VtkFlags vtk_flags;'
p8395
aS'    vtk_flags.compression_level ='
p8396
aS'      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p8397
aS'    std::ofstream output(filename);'
p8398
aS'    data_out.write_vtu(output);'
p8399
aS'  }'
p8400
aS'  template <int dim>'
p8401
aS'  void TATForwardProblem<dim>::run()'
p8402
aS'  {'
p8403
aS'    setup_system();'
p8404
aS'    VectorTools::project(dof_handler,'
p8405
aS'                         constraints,'
p8406
aS'                         QGauss<dim>(fe.degree + 1),'
p8407
aS'                         InitialValuesP<dim>(),'
p8408
aS'                         old_solution_p);'
p8409
aS'    old_solution_v = 0;'
p8410
aS'    std::ofstream detector_data("detectors.dat");'
p8411
aS'    Vector<double> tmp(solution_p.size());'
p8412
aS'    Vector<double> G1(solution_p.size());'
p8413
aS'    Vector<double> G2(solution_v.size());'
p8414
aS'    const double end_time = 0.7;'
p8415
aS'    for (time = time_step; time <= end_time;'
p8416
aS'         time += time_step, ++timestep_number)'
p8417
aS'      {'
p8418
aS'        std::cout << std::endl;'
p8419
aS'        std::cout << "time_step " << timestep_number << " @ t=" << time'
p8420
aS'                  << std::endl;'
p8421
aS'        mass_matrix.vmult(G1, old_solution_p);'
p8422
aS'        mass_matrix.vmult(tmp, old_solution_v);'
p8423
aS'        G1.add(time_step * (1 - theta), tmp);'
p8424
aS'        mass_matrix.vmult(G2, old_solution_v);'
p8425
aS'        laplace_matrix.vmult(tmp, old_solution_p);'
p8426
aS'        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);'
p8427
aS'        boundary_matrix.vmult(tmp, old_solution_p);'
p8428
aS'        G2.add(wave_speed, tmp);'
p8429
aS'        system_rhs_p = G1;'
p8430
aS'        system_rhs_p.add(time_step * theta, G2);'
p8431
aS'        solve_p();'
p8432
aS'        system_rhs_v = G2;'
p8433
aS'        laplace_matrix.vmult(tmp, solution_p);'
p8434
aS'        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);'
p8435
aS'        boundary_matrix.vmult(tmp, solution_p);'
p8436
aS'        system_rhs_v.add(-wave_speed, tmp);'
p8437
aS'        solve_v();'
p8438
aS'        output_results();'
p8439
aS'        detector_data << time;'
p8440
aS'        for (unsigned int i = 0; i < detector_locations.size(); ++i)'
p8441
aS'          detector_data << " "'
p8442
aS'                        << VectorTools::point_value(dof_handler,'
p8443
aS'                                                    solution_p,'
p8444
aS'                                                    detector_locations[i])'
p8445
aS'                        << " ";'
p8446
aS'        detector_data << std::endl;'
p8447
aS'        old_solution_p = solution_p;'
p8448
aS'        old_solution_v = solution_v;'
p8449
aS'      }'
p8450
aS'  }'
p8451
aS'} // namespace Step24'
p8452
aS'int main()'
p8453
ag24
aS'  try'
p8454
aS'    {'
p8455
aS'      using namespace Step24;'
p8456
aS'      TATForwardProblem<2> forward_problem_solver;'
p8457
aS'      forward_problem_solver.run();'
p8458
aS'    }'
p8459
aS'  catch (std::exception &exc)'
p8460
aS'    {'
p8461
aS'      std::cerr << std::endl'
p8462
aS'                << std::endl'
p8463
aS'                << "----------------------------------------------------"'
p8464
aS'                << std::endl;'
p8465
aS'      std::cerr << "Exception on processing: " << std::endl'
p8466
aS'                << exc.what() << std::endl'
p8467
aS'                << "Aborting!" << std::endl'
p8468
aS'                << "----------------------------------------------------"'
p8469
aS'                << std::endl;'
p8470
aS'      return 1;'
p8471
aS'    }'
p8472
aS'  catch (...)'
p8473
aS'    {'
p8474
aS'      std::cerr << std::endl'
p8475
aS'                << std::endl'
p8476
aS'                << "----------------------------------------------------"'
p8477
aS'                << std::endl;'
p8478
aS'      std::cerr << "Unknown exception!" << std::endl'
p8479
aS'                << "Aborting!" << std::endl'
p8480
aS'                << "----------------------------------------------------"'
p8481
aS'                << std::endl;'
p8482
aS'      return 1;'
p8483
aS'    }'
p8484
aS'  return 0;'
p8485
ag32
aS'/* ---------------------------------------------------------------------'
p8486
aS' *'
p8487
aS' * Copyright (C) 2006 - 2020 by the deal.II authors'
p8488
aS' *'
p8489
aS' * This file is part of the deal.II library.'
p8490
aS' *'
p8491
aS' * The deal.II library is free software; you can use it, redistribute'
p8492
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p8493
aS' * Public License as published by the Free Software Foundation; either'
p8494
aS' * version 2.1 of the License, or (at your option) any later version.'
p8495
aS' * The full text of the license can be found in the file LICENSE.md at'
p8496
aS' * the top level directory of deal.II.'
p8497
aS' *'
p8498
aS' * ---------------------------------------------------------------------'
p8499
aS' *'
p8500
aS' * Author: Ivan Christov, Wolfgang Bangerth, Texas A&M University, 2006'
p8501
aS' */'
p8502
aS'#include <deal.II/base/quadrature_lib.h>'
p8503
aS'#include <deal.II/base/function.h>'
p8504
aS'#include <deal.II/base/utilities.h>'
p8505
aS'#include <deal.II/lac/vector.h>'
p8506
aS'#include <deal.II/lac/full_matrix.h>'
p8507
aS'#include <deal.II/lac/sparse_matrix.h>'
p8508
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p8509
aS'#include <deal.II/lac/solver_cg.h>'
p8510
aS'#include <deal.II/lac/precondition.h>'
p8511
aS'#include <deal.II/lac/affine_constraints.h>'
p8512
aS'#include <deal.II/grid/tria.h>'
p8513
aS'#include <deal.II/grid/grid_generator.h>'
p8514
aS'#include <deal.II/dofs/dof_handler.h>'
p8515
aS'#include <deal.II/dofs/dof_tools.h>'
p8516
aS'#include <deal.II/fe/fe_q.h>'
p8517
aS'#include <deal.II/fe/fe_values.h>'
p8518
aS'#include <deal.II/numerics/vector_tools.h>'
p8519
aS'#include <deal.II/numerics/matrix_tools.h>'
p8520
aS'#include <deal.II/numerics/data_out.h>'
p8521
aS'#include <fstream>'
p8522
aS'#include <iostream>'
p8523
aS'namespace Step25'
p8524
ag24
aS'  using namespace dealii;'
p8525
aS'  template <int dim>'
p8526
aS'  class SineGordonProblem'
p8527
aS'  {'
p8528
aS'  public:'
p8529
aS'    SineGordonProblem();'
p8530
aS'    void run();'
p8531
aS'  private:'
p8532
aS'    void         make_grid_and_dofs();'
p8533
aS'    void         assemble_system();'
p8534
aS'    void         compute_nl_term(const Vector<double> &old_data,'
p8535
aS'                                 const Vector<double> &new_data,'
p8536
aS'                                 Vector<double> &      nl_term) const;'
p8537
aS'    void         compute_nl_matrix(const Vector<double> &old_data,'
p8538
aS'                                   const Vector<double> &new_data,'
p8539
aS'                                   SparseMatrix<double> &nl_matrix) const;'
p8540
aS'    unsigned int solve();'
p8541
aS'    void         output_results(const unsigned int timestep_number) const;'
p8542
aS'    Triangulation<dim> triangulation;'
p8543
aS'    FE_Q<dim>          fe;'
p8544
aS'    DoFHandler<dim>    dof_handler;'
p8545
aS'    SparsityPattern      sparsity_pattern;'
p8546
aS'    SparseMatrix<double> system_matrix;'
p8547
aS'    SparseMatrix<double> mass_matrix;'
p8548
aS'    SparseMatrix<double> laplace_matrix;'
p8549
aS'    const unsigned int n_global_refinements;'
p8550
aS'    double       time;'
p8551
aS'    const double final_time, time_step;'
p8552
aS'    const double theta;'
p8553
aS'    Vector<double> solution, solution_update, old_solution;'
p8554
aS'    Vector<double> M_x_velocity;'
p8555
aS'    Vector<double> system_rhs;'
p8556
aS'    const unsigned int output_timestep_skip;'
p8557
aS'  };'
p8558
aS'  template <int dim>'
p8559
aS'  class ExactSolution : public Function<dim>'
p8560
aS'  {'
p8561
aS'  public:'
p8562
aS'    ExactSolution(const unsigned int n_components = 1, const double time = 0.)'
p8563
aS'      : Function<dim>(n_components, time)'
p8564
aS'    {}'
p8565
aS'    virtual double value(const Point<dim> &p,'
p8566
aS'                         const unsigned int /*component*/ = 0) const override'
p8567
aS'    {'
p8568
aS'      const double t = this->get_time();'
p8569
aS'      switch (dim)'
p8570
aS'        {'
p8571
aS'          case 1:'
p8572
aS'            {'
p8573
aS'              const double m  = 0.5;'
p8574
aS'              const double c1 = 0.;'
p8575
aS'              const double c2 = 0.;'
p8576
aS'              return -4. * std::atan(m / std::sqrt(1. - m * m) *'
p8577
aS'                                     std::sin(std::sqrt(1. - m * m) * t + c2) /'
p8578
aS'                                     std::cosh(m * p[0] + c1));'
p8579
aS'            }'
p8580
aS'          case 2:'
p8581
aS'            {'
p8582
aS'              const double theta  = numbers::PI / 4.;'
p8583
aS'              const double lambda = 1.;'
p8584
aS'              const double a0     = 1.;'
p8585
aS'              const double s      = 1.;'
p8586
aS'              const double arg    = p[0] * std::cos(theta) +'
p8587
aS'                                 std::sin(theta) * (p[1] * std::cosh(lambda) +'
p8588
aS'                                                    t * std::sinh(lambda));'
p8589
aS'              return 4. * std::atan(a0 * std::exp(s * arg));'
p8590
aS'            }'
p8591
aS'          case 3:'
p8592
aS'            {'
p8593
aS'              const double theta = numbers::PI / 4;'
p8594
aS'              const double phi   = numbers::PI / 4;'
p8595
aS'              const double tau   = 1.;'
p8596
aS'              const double c0    = 1.;'
p8597
aS'              const double s     = 1.;'
p8598
aS'              const double arg   = p[0] * std::cos(theta) +'
p8599
aS'                                 p[1] * std::sin(theta) * std::cos(phi) +'
p8600
aS'                                 std::sin(theta) * std::sin(phi) *'
p8601
aS'                                   (p[2] * std::cosh(tau) + t * std::sinh(tau));'
p8602
aS'              return 4. * std::atan(c0 * std::exp(s * arg));'
p8603
aS'            }'
p8604
aS'          default:'
p8605
aS'            Assert(false, ExcNotImplemented());'
p8606
aS'            return -1e8;'
p8607
aS'        }'
p8608
aS'    }'
p8609
aS'  };'
p8610
aS'  template <int dim>'
p8611
aS'  class InitialValues : public Function<dim>'
p8612
aS'  {'
p8613
aS'  public:'
p8614
aS'    InitialValues(const unsigned int n_components = 1, const double time = 0.)'
p8615
aS'      : Function<dim>(n_components, time)'
p8616
aS'    {}'
p8617
aS'    virtual double value(const Point<dim> & p,'
p8618
aS'                         const unsigned int component = 0) const override'
p8619
aS'    {'
p8620
aS'      return ExactSolution<dim>(1, this->get_time()).value(p, component);'
p8621
aS'    }'
p8622
aS'  };'
p8623
aS'  template <int dim>'
p8624
aS'  SineGordonProblem<dim>::SineGordonProblem()'
p8625
aS'    : fe(1)'
p8626
aS'    , dof_handler(triangulation)'
p8627
aS'    , n_global_refinements(6)'
p8628
aS'    , time(-5.4414)'
p8629
aS'    , final_time(2.7207)'
p8630
aS'    , time_step(10 * 1. / std::pow(2., 1. * n_global_refinements))'
p8631
aS'    , theta(0.5)'
p8632
aS'    , output_timestep_skip(1)'
p8633
aS'  {}'
p8634
aS'  template <int dim>'
p8635
aS'  void SineGordonProblem<dim>::make_grid_and_dofs()'
p8636
aS'  {'
p8637
aS'    GridGenerator::hyper_cube(triangulation, -10, 10);'
p8638
aS'    triangulation.refine_global(n_global_refinements);'
p8639
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p8640
aS'              << std::endl'
p8641
aS'              << "   Total number of cells: " << triangulation.n_cells()'
p8642
aS'              << std::endl;'
p8643
aS'    dof_handler.distribute_dofs(fe);'
p8644
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p8645
aS'              << std::endl;'
p8646
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p8647
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p8648
aS'    sparsity_pattern.copy_from(dsp);'
p8649
aS'    system_matrix.reinit(sparsity_pattern);'
p8650
aS'    mass_matrix.reinit(sparsity_pattern);'
p8651
aS'    laplace_matrix.reinit(sparsity_pattern);'
p8652
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p8653
aS'                                      QGauss<dim>(fe.degree + 1),'
p8654
aS'                                      mass_matrix);'
p8655
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p8656
aS'                                         QGauss<dim>(fe.degree + 1),'
p8657
aS'                                         laplace_matrix);'
p8658
aS'    solution.reinit(dof_handler.n_dofs());'
p8659
aS'    solution_update.reinit(dof_handler.n_dofs());'
p8660
aS'    old_solution.reinit(dof_handler.n_dofs());'
p8661
aS'    M_x_velocity.reinit(dof_handler.n_dofs());'
p8662
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p8663
aS'  }'
p8664
aS'  template <int dim>'
p8665
aS'  void SineGordonProblem<dim>::assemble_system()'
p8666
aS'  {'
p8667
aS'    system_matrix.copy_from(mass_matrix);'
p8668
aS'    system_matrix.add(std::pow(time_step * theta, 2), laplace_matrix);'
p8669
aS'    SparseMatrix<double> tmp_matrix(sparsity_pattern);'
p8670
aS'    compute_nl_matrix(old_solution, solution, tmp_matrix);'
p8671
aS'    system_matrix.add(std::pow(time_step * theta, 2), tmp_matrix);'
p8672
aS'    system_rhs = 0.;'
p8673
aS'    Vector<double> tmp_vector(solution.size());'
p8674
aS'    mass_matrix.vmult(system_rhs, solution);'
p8675
aS'    laplace_matrix.vmult(tmp_vector, solution);'
p8676
aS'    system_rhs.add(std::pow(time_step * theta, 2), tmp_vector);'
p8677
aS'    mass_matrix.vmult(tmp_vector, old_solution);'
p8678
aS'    system_rhs.add(-1.0, tmp_vector);'
p8679
aS'    laplace_matrix.vmult(tmp_vector, old_solution);'
p8680
aS'    system_rhs.add(std::pow(time_step, 2) * theta * (1 - theta), tmp_vector);'
p8681
aS'    system_rhs.add(-time_step, M_x_velocity);'
p8682
aS'    compute_nl_term(old_solution, solution, tmp_vector);'
p8683
aS'    system_rhs.add(std::pow(time_step, 2) * theta, tmp_vector);'
p8684
aS'    system_rhs *= -1.;'
p8685
aS'  }'
p8686
aS'  template <int dim>'
p8687
aS'  void SineGordonProblem<dim>::compute_nl_term(const Vector<double> &old_data,'
p8688
aS'                                               const Vector<double> &new_data,'
p8689
aS'                                               Vector<double> &nl_term) const'
p8690
aS'  {'
p8691
aS'    nl_term = 0;'
p8692
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p8693
aS'    FEValues<dim>     fe_values(fe,'
p8694
aS'                            quadrature_formula,'
p8695
aS'                            update_values | update_JxW_values |'
p8696
aS'                              update_quadrature_points);'
p8697
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p8698
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p8699
aS'    Vector<double>                       local_nl_term(dofs_per_cell);'
p8700
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p8701
aS'    std::vector<double>                  old_data_values(n_q_points);'
p8702
aS'    std::vector<double>                  new_data_values(n_q_points);'
p8703
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p8704
aS'      {'
p8705
aS'        local_nl_term = 0;'
p8706
aS'        fe_values.reinit(cell);'
p8707
aS'        fe_values.get_function_values(old_data, old_data_values);'
p8708
aS'        fe_values.get_function_values(new_data, new_data_values);'
p8709
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p8710
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8711
aS'            local_nl_term(i) +='
p8712
aS'              (std::sin(theta * new_data_values[q_point] +'
p8713
aS'                        (1 - theta) * old_data_values[q_point]) *'
p8714
aS'               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));'
p8715
aS'        cell->get_dof_indices(local_dof_indices);'
p8716
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8717
aS'          nl_term(local_dof_indices[i]) += local_nl_term(i);'
p8718
aS'      }'
p8719
aS'  }'
p8720
aS'  template <int dim>'
p8721
aS'  void SineGordonProblem<dim>::compute_nl_matrix('
p8722
aS'    const Vector<double> &old_data,'
p8723
aS'    const Vector<double> &new_data,'
p8724
aS'    SparseMatrix<double> &nl_matrix) const'
p8725
aS'  {'
p8726
aS'    QGauss<dim>   quadrature_formula(fe.degree + 1);'
p8727
aS'    FEValues<dim> fe_values(fe,'
p8728
aS'                            quadrature_formula,'
p8729
aS'                            update_values | update_JxW_values |'
p8730
aS'                              update_quadrature_points);'
p8731
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p8732
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p8733
aS'    FullMatrix<double> local_nl_matrix(dofs_per_cell, dofs_per_cell);'
p8734
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p8735
aS'    std::vector<double>                  old_data_values(n_q_points);'
p8736
aS'    std::vector<double>                  new_data_values(n_q_points);'
p8737
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p8738
aS'      {'
p8739
aS'        local_nl_matrix = 0;'
p8740
aS'        fe_values.reinit(cell);'
p8741
aS'        fe_values.get_function_values(old_data, old_data_values);'
p8742
aS'        fe_values.get_function_values(new_data, new_data_values);'
p8743
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p8744
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8745
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8746
aS'              local_nl_matrix(i, j) +='
p8747
aS'                (std::cos(theta * new_data_values[q_point] +'
p8748
aS'                          (1 - theta) * old_data_values[q_point]) *'
p8749
aS'                 fe_values.shape_value(i, q_point) *'
p8750
aS'                 fe_values.shape_value(j, q_point) * fe_values.JxW(q_point));'
p8751
aS'        cell->get_dof_indices(local_dof_indices);'
p8752
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8753
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8754
aS'            nl_matrix.add(local_dof_indices[i],'
p8755
aS'                          local_dof_indices[j],'
p8756
aS'                          local_nl_matrix(i, j));'
p8757
aS'      }'
p8758
aS'  }'
p8759
aS'  template <int dim>'
p8760
aS'  unsigned int SineGordonProblem<dim>::solve()'
p8761
aS'  {'
p8762
aS'    SolverControl            solver_control(1000, 1e-12 * system_rhs.l2_norm());'
p8763
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8764
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p8765
aS'    preconditioner.initialize(system_matrix, 1.2);'
p8766
aS'    cg.solve(system_matrix, solution_update, system_rhs, preconditioner);'
p8767
aS'    return solver_control.last_step();'
p8768
aS'  }'
p8769
aS'  template <int dim>'
p8770
aS'  void SineGordonProblem<dim>::output_results('
p8771
aS'    const unsigned int timestep_number) const'
p8772
aS'  {'
p8773
aS'    DataOut<dim> data_out;'
p8774
aS'    data_out.attach_dof_handler(dof_handler);'
p8775
aS'    data_out.add_data_vector(solution, "u");'
p8776
aS'    data_out.build_patches();'
p8777
aS'    const std::string filename ='
p8778
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p8779
aS'    DataOutBase::VtkFlags vtk_flags;'
p8780
aS'    vtk_flags.compression_level ='
p8781
aS'      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p8782
aS'    data_out.set_flags(vtk_flags);'
p8783
aS'    std::ofstream output(filename);'
p8784
aS'    data_out.write_vtu(output);'
p8785
aS'  }'
p8786
aS'  template <int dim>'
p8787
aS'  void SineGordonProblem<dim>::run()'
p8788
aS'  {'
p8789
aS'    make_grid_and_dofs();'
p8790
aS'    {'
p8791
aS'      AffineConstraints<double> constraints;'
p8792
aS'      constraints.close();'
p8793
aS'      VectorTools::project(dof_handler,'
p8794
aS'                           constraints,'
p8795
aS'                           QGauss<dim>(fe.degree + 1),'
p8796
aS'                           InitialValues<dim>(1, time),'
p8797
aS'                           solution);'
p8798
aS'    }'
p8799
aS'    output_results(0);'
p8800
aS'    unsigned int timestep_number = 1;'
p8801
aS'    for (time += time_step; time <= final_time;'
p8802
aS'         time += time_step, ++timestep_number)'
p8803
aS'      {'
p8804
aS'        old_solution = solution;'
p8805
aS'        std::cout << std::endl'
p8806
aS'                  << "Time step #" << timestep_number << "; "'
p8807
aS'                  << "advancing to t = " << time << "." << std::endl;'
p8808
aS'        double initial_rhs_norm = 0.;'
p8809
aS'        bool   first_iteration  = true;'
p8810
aS'        do'
p8811
aS'          {'
p8812
aS'            assemble_system();'
p8813
aS'            if (first_iteration == true)'
p8814
aS'              initial_rhs_norm = system_rhs.l2_norm();'
p8815
aS'            const unsigned int n_iterations = solve();'
p8816
aS'            solution += solution_update;'
p8817
aS'            if (first_iteration == true)'
p8818
aS'              std::cout << "    " << n_iterations;'
p8819
aS'            else'
p8820
aS"              std::cout << '+' << n_iterations;"
p8821
aS'            first_iteration = false;'
p8822
aS'          }'
p8823
aS'        while (system_rhs.l2_norm() > 1e-6 * initial_rhs_norm);'
p8824
aS'        std::cout << " CG iterations per nonlinear step." << std::endl;'
p8825
aS'        Vector<double> tmp_vector(solution.size());'
p8826
aS'        laplace_matrix.vmult(tmp_vector, solution);'
p8827
aS'        M_x_velocity.add(-time_step * theta, tmp_vector);'
p8828
aS'        laplace_matrix.vmult(tmp_vector, old_solution);'
p8829
aS'        M_x_velocity.add(-time_step * (1 - theta), tmp_vector);'
p8830
aS'        compute_nl_term(old_solution, solution, tmp_vector);'
p8831
aS'        M_x_velocity.add(-time_step, tmp_vector);'
p8832
aS'        if (timestep_number % output_timestep_skip == 0)'
p8833
aS'          output_results(timestep_number);'
p8834
aS'      }'
p8835
aS'  }'
p8836
aS'} // namespace Step25'
p8837
aS'int main()'
p8838
ag24
aS'  try'
p8839
aS'    {'
p8840
aS'      using namespace Step25;'
p8841
aS'      SineGordonProblem<1> sg_problem;'
p8842
aS'      sg_problem.run();'
p8843
aS'    }'
p8844
aS'  catch (std::exception &exc)'
p8845
aS'    {'
p8846
aS'      std::cerr << std::endl'
p8847
aS'                << std::endl'
p8848
aS'                << "----------------------------------------------------"'
p8849
aS'                << std::endl;'
p8850
aS'      std::cerr << "Exception on processing: " << std::endl'
p8851
aS'                << exc.what() << std::endl'
p8852
aS'                << "Aborting!" << std::endl'
p8853
aS'                << "----------------------------------------------------"'
p8854
aS'                << std::endl;'
p8855
aS'      return 1;'
p8856
aS'    }'
p8857
aS'  catch (...)'
p8858
aS'    {'
p8859
aS'      std::cerr << std::endl'
p8860
aS'                << std::endl'
p8861
aS'                << "----------------------------------------------------"'
p8862
aS'                << std::endl;'
p8863
aS'      std::cerr << "Unknown exception!" << std::endl'
p8864
aS'                << "Aborting!" << std::endl'
p8865
aS'                << "----------------------------------------------------"'
p8866
aS'                << std::endl;'
p8867
aS'      return 1;'
p8868
aS'    }'
p8869
aS'  return 0;'
p8870
ag32
aS'/* ---------------------------------------------------------------------'
p8871
aS' *'
p8872
aS' * Copyright (C) 2013 - 2021 by the deal.II authors'
p8873
aS' *'
p8874
aS' * This file is part of the deal.II library.'
p8875
aS' *'
p8876
aS' * The deal.II library is free software; you can use it, redistribute'
p8877
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p8878
aS' * Public License as published by the Free Software Foundation; either'
p8879
aS' * version 2.1 of the License, or (at your option) any later version.'
p8880
aS' * The full text of the license can be found in the file LICENSE.md at'
p8881
aS' * the top level directory of deal.II.'
p8882
aS' *'
p8883
aS' * ---------------------------------------------------------------------'
p8884
aS' *'
p8885
aS' * Author: Wolfgang Bangerth, Texas A&M University, 2013'
p8886
aS' */'
p8887
aS'#include <deal.II/base/utilities.h>'
p8888
aS'#include <deal.II/base/quadrature_lib.h>'
p8889
aS'#include <deal.II/base/function.h>'
p8890
aS'#include <deal.II/base/logstream.h>'
p8891
aS'#include <deal.II/lac/vector.h>'
p8892
aS'#include <deal.II/lac/full_matrix.h>'
p8893
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p8894
aS'#include <deal.II/lac/sparse_matrix.h>'
p8895
aS'#include <deal.II/lac/solver_cg.h>'
p8896
aS'#include <deal.II/lac/precondition.h>'
p8897
aS'#include <deal.II/lac/affine_constraints.h>'
p8898
aS'#include <deal.II/grid/tria.h>'
p8899
aS'#include <deal.II/grid/grid_generator.h>'
p8900
aS'#include <deal.II/grid/grid_refinement.h>'
p8901
aS'#include <deal.II/grid/grid_out.h>'
p8902
aS'#include <deal.II/dofs/dof_handler.h>'
p8903
aS'#include <deal.II/dofs/dof_tools.h>'
p8904
aS'#include <deal.II/fe/fe_q.h>'
p8905
aS'#include <deal.II/fe/fe_values.h>'
p8906
aS'#include <deal.II/numerics/data_out.h>'
p8907
aS'#include <deal.II/numerics/vector_tools.h>'
p8908
aS'#include <deal.II/numerics/error_estimator.h>'
p8909
aS'#include <deal.II/numerics/solution_transfer.h>'
p8910
aS'#include <deal.II/numerics/matrix_tools.h>'
p8911
aS'#include <fstream>'
p8912
aS'#include <iostream>'
p8913
aS'namespace Step26'
p8914
ag24
aS'  using namespace dealii;'
p8915
aS'  template <int dim>'
p8916
aS'  class HeatEquation'
p8917
aS'  {'
p8918
aS'  public:'
p8919
aS'    HeatEquation();'
p8920
aS'    void run();'
p8921
aS'  private:'
p8922
aS'    void setup_system();'
p8923
aS'    void solve_time_step();'
p8924
aS'    void output_results() const;'
p8925
aS'    void refine_mesh(const unsigned int min_grid_level,'
p8926
aS'                     const unsigned int max_grid_level);'
p8927
aS'    Triangulation<dim> triangulation;'
p8928
aS'    FE_Q<dim>          fe;'
p8929
aS'    DoFHandler<dim>    dof_handler;'
p8930
aS'    AffineConstraints<double> constraints;'
p8931
aS'    SparsityPattern      sparsity_pattern;'
p8932
aS'    SparseMatrix<double> mass_matrix;'
p8933
aS'    SparseMatrix<double> laplace_matrix;'
p8934
aS'    SparseMatrix<double> system_matrix;'
p8935
aS'    Vector<double> solution;'
p8936
aS'    Vector<double> old_solution;'
p8937
aS'    Vector<double> system_rhs;'
p8938
aS'    double       time;'
p8939
aS'    double       time_step;'
p8940
aS'    unsigned int timestep_number;'
p8941
aS'    const double theta;'
p8942
aS'  };'
p8943
aS'  template <int dim>'
p8944
aS'  class RightHandSide : public Function<dim>'
p8945
aS'  {'
p8946
aS'  public:'
p8947
aS'    RightHandSide()'
p8948
aS'      : Function<dim>()'
p8949
aS'      , period(0.2)'
p8950
aS'    {}'
p8951
aS'    virtual double value(const Point<dim> & p,'
p8952
aS'                         const unsigned int component = 0) const override;'
p8953
aS'  private:'
p8954
aS'    const double period;'
p8955
aS'  };'
p8956
aS'  template <int dim>'
p8957
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p8958
aS'                                   const unsigned int component) const'
p8959
aS'  {'
p8960
aS'    (void)component;'
p8961
aS'    AssertIndexRange(component, 1);'
p8962
aS'    Assert(dim == 2, ExcNotImplemented());'
p8963
aS'    const double time = this->get_time();'
p8964
aS'    const double point_within_period ='
p8965
aS'      (time / period - std::floor(time / period));'
p8966
aS'    if ((point_within_period >= 0.0) && (point_within_period <= 0.2))'
p8967
aS'      {'
p8968
aS'        if ((p[0] > 0.5) && (p[1] > -0.5))'
p8969
aS'          return 1;'
p8970
aS'        else'
p8971
aS'          return 0;'
p8972
aS'      }'
p8973
aS'    else if ((point_within_period >= 0.5) && (point_within_period <= 0.7))'
p8974
aS'      {'
p8975
aS'        if ((p[0] > -0.5) && (p[1] > 0.5))'
p8976
aS'          return 1;'
p8977
aS'        else'
p8978
aS'          return 0;'
p8979
aS'      }'
p8980
aS'    else'
p8981
aS'      return 0;'
p8982
aS'  }'
p8983
aS'  template <int dim>'
p8984
aS'  class BoundaryValues : public Function<dim>'
p8985
aS'  {'
p8986
aS'  public:'
p8987
aS'    virtual double value(const Point<dim> & p,'
p8988
aS'                         const unsigned int component = 0) const override;'
p8989
aS'  };'
p8990
aS'  template <int dim>'
p8991
aS'  double BoundaryValues<dim>::value(const Point<dim> & /*p*/,'
p8992
aS'                                    const unsigned int component) const'
p8993
aS'  {'
p8994
aS'    (void)component;'
p8995
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p8996
aS'    return 0;'
p8997
aS'  }'
p8998
aS'  template <int dim>'
p8999
aS'  HeatEquation<dim>::HeatEquation()'
p9000
aS'    : fe(1)'
p9001
aS'    , dof_handler(triangulation)'
p9002
aS'    , time_step(1. / 500)'
p9003
aS'    , theta(0.5)'
p9004
aS'  {}'
p9005
aS'  template <int dim>'
p9006
aS'  void HeatEquation<dim>::setup_system()'
p9007
aS'  {'
p9008
aS'    dof_handler.distribute_dofs(fe);'
p9009
aS'    std::cout << std::endl'
p9010
aS'              << "===========================================" << std::endl'
p9011
aS'              << "Number of active cells: " << triangulation.n_active_cells()'
p9012
aS'              << std::endl'
p9013
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p9014
aS'              << std::endl'
p9015
aS'              << std::endl;'
p9016
aS'    constraints.clear();'
p9017
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p9018
aS'    constraints.close();'
p9019
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p9020
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p9021
aS'                                    dsp,'
p9022
aS'                                    constraints,'
p9023
aS'    sparsity_pattern.copy_from(dsp);'
p9024
aS'    mass_matrix.reinit(sparsity_pattern);'
p9025
aS'    laplace_matrix.reinit(sparsity_pattern);'
p9026
aS'    system_matrix.reinit(sparsity_pattern);'
p9027
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p9028
aS'                                      QGauss<dim>(fe.degree + 1),'
p9029
aS'                                      mass_matrix);'
p9030
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p9031
aS'                                         QGauss<dim>(fe.degree + 1),'
p9032
aS'                                         laplace_matrix);'
p9033
aS'    solution.reinit(dof_handler.n_dofs());'
p9034
aS'    old_solution.reinit(dof_handler.n_dofs());'
p9035
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p9036
aS'  }'
p9037
aS'  template <int dim>'
p9038
aS'  void HeatEquation<dim>::solve_time_step()'
p9039
aS'  {'
p9040
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p9041
aS'    SolverCG<Vector<double>> cg(solver_control);'
p9042
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p9043
aS'    preconditioner.initialize(system_matrix, 1.0);'
p9044
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p9045
aS'    constraints.distribute(solution);'
p9046
aS'    std::cout << "     " << solver_control.last_step() << " CG iterations."'
p9047
aS'              << std::endl;'
p9048
aS'  }'
p9049
aS'  template <int dim>'
p9050
aS'  void HeatEquation<dim>::output_results() const'
p9051
aS'  {'
p9052
aS'    DataOut<dim> data_out;'
p9053
aS'    data_out.attach_dof_handler(dof_handler);'
p9054
aS'    data_out.add_data_vector(solution, "U");'
p9055
aS'    data_out.build_patches();'
p9056
aS'    data_out.set_flags(DataOutBase::VtkFlags(time, timestep_number));'
p9057
aS'    const std::string filename ='
p9058
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtk";'
p9059
aS'    std::ofstream output(filename);'
p9060
aS'    data_out.write_vtk(output);'
p9061
aS'  }'
p9062
aS'  template <int dim>'
p9063
aS'  void HeatEquation<dim>::refine_mesh(const unsigned int min_grid_level,'
p9064
aS'                                      const unsigned int max_grid_level)'
p9065
aS'  {'
p9066
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p9067
aS'    KellyErrorEstimator<dim>::estimate('
p9068
aS'      dof_handler,'
p9069
aS'      QGauss<dim - 1>(fe.degree + 1),'
p9070
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p9071
aS'      solution,'
p9072
aS'      estimated_error_per_cell);'
p9073
aS'    GridRefinement::refine_and_coarsen_fixed_fraction(triangulation,'
p9074
aS'                                                      estimated_error_per_cell,'
p9075
aS'                                                      0.6,'
p9076
aS'                                                      0.4);'
p9077
aS'    if (triangulation.n_levels() > max_grid_level)'
p9078
aS'      for (const auto &cell :'
p9079
aS'           triangulation.active_cell_iterators_on_level(max_grid_level))'
p9080
aS'        cell->clear_refine_flag();'
p9081
aS'    for (const auto &cell :'
p9082
aS'         triangulation.active_cell_iterators_on_level(min_grid_level))'
p9083
aS'      cell->clear_coarsen_flag();'
p9084
aS'    SolutionTransfer<dim> solution_trans(dof_handler);'
p9085
aS'    Vector<double> previous_solution;'
p9086
aS'    previous_solution = solution;'
p9087
aS'    triangulation.prepare_coarsening_and_refinement();'
p9088
aS'    solution_trans.prepare_for_coarsening_and_refinement(previous_solution);'
p9089
aS'    triangulation.execute_coarsening_and_refinement();'
p9090
aS'    setup_system();'
p9091
aS'    solution_trans.interpolate(previous_solution, solution);'
p9092
aS'    constraints.distribute(solution);'
p9093
aS'  }'
p9094
aS'  template <int dim>'
p9095
aS'  void HeatEquation<dim>::run()'
p9096
aS'  {'
p9097
aS'    const unsigned int initial_global_refinement       = 2;'
p9098
aS'    const unsigned int n_adaptive_pre_refinement_steps = 4;'
p9099
aS'    GridGenerator::hyper_L(triangulation);'
p9100
aS'    triangulation.refine_global(initial_global_refinement);'
p9101
aS'    setup_system();'
p9102
aS'    unsigned int pre_refinement_step = 0;'
p9103
aS'    Vector<double> tmp;'
p9104
aS'    Vector<double> forcing_terms;'
p9105
aS'  start_time_iteration:'
p9106
aS'    time            = 0.0;'
p9107
aS'    timestep_number = 0;'
p9108
aS'    tmp.reinit(solution.size());'
p9109
aS'    forcing_terms.reinit(solution.size());'
p9110
aS'    VectorTools::interpolate(dof_handler,'
p9111
aS'                             Functions::ZeroFunction<dim>(),'
p9112
aS'                             old_solution);'
p9113
aS'    solution = old_solution;'
p9114
aS'    output_results();'
p9115
aS'    while (time <= 0.5)'
p9116
aS'      {'
p9117
aS'        time += time_step;'
p9118
aS'        ++timestep_number;'
p9119
aS'        std::cout << "Time step " << timestep_number << " at t=" << time'
p9120
aS'                  << std::endl;'
p9121
aS'        mass_matrix.vmult(system_rhs, old_solution);'
p9122
aS'        laplace_matrix.vmult(tmp, old_solution);'
p9123
aS'        system_rhs.add(-(1 - theta) * time_step, tmp);'
p9124
aS'        RightHandSide<dim> rhs_function;'
p9125
aS'        rhs_function.set_time(time);'
p9126
aS'        VectorTools::create_right_hand_side(dof_handler,'
p9127
aS'                                            QGauss<dim>(fe.degree + 1),'
p9128
aS'                                            rhs_function,'
p9129
aS'                                            tmp);'
p9130
aS'        forcing_terms = tmp;'
p9131
aS'        forcing_terms *= time_step * theta;'
p9132
aS'        rhs_function.set_time(time - time_step);'
p9133
aS'        VectorTools::create_right_hand_side(dof_handler,'
p9134
aS'                                            QGauss<dim>(fe.degree + 1),'
p9135
aS'                                            rhs_function,'
p9136
aS'                                            tmp);'
p9137
aS'        forcing_terms.add(time_step * (1 - theta), tmp);'
p9138
aS'        system_rhs += forcing_terms;'
p9139
aS'        system_matrix.copy_from(mass_matrix);'
p9140
aS'        system_matrix.add(theta * time_step, laplace_matrix);'
p9141
aS'        constraints.condense(system_matrix, system_rhs);'
p9142
aS'        {'
p9143
aS'          BoundaryValues<dim> boundary_values_function;'
p9144
aS'          boundary_values_function.set_time(time);'
p9145
aS'          std::map<types::global_dof_index, double> boundary_values;'
p9146
aS'          VectorTools::interpolate_boundary_values(dof_handler,'
p9147
aS'                                                   0,'
p9148
aS'                                                   boundary_values_function,'
p9149
aS'                                                   boundary_values);'
p9150
aS'          MatrixTools::apply_boundary_values(boundary_values,'
p9151
aS'                                             system_matrix,'
p9152
aS'                                             solution,'
p9153
aS'                                             system_rhs);'
p9154
aS'        }'
p9155
aS'        solve_time_step();'
p9156
aS'        output_results();'
p9157
aS'        if ((timestep_number == 1) &&'
p9158
aS'            (pre_refinement_step < n_adaptive_pre_refinement_steps))'
p9159
aS'          {'
p9160
aS'            refine_mesh(initial_global_refinement,'
p9161
aS'                        initial_global_refinement +'
p9162
aS'                          n_adaptive_pre_refinement_steps);'
p9163
aS'            ++pre_refinement_step;'
p9164
aS'            tmp.reinit(solution.size());'
p9165
aS'            forcing_terms.reinit(solution.size());'
p9166
aS'            std::cout << std::endl;'
p9167
aS'            goto start_time_iteration;'
p9168
aS'          }'
p9169
aS'        else if ((timestep_number > 0) && (timestep_number % 5 == 0))'
p9170
aS'          {'
p9171
aS'            refine_mesh(initial_global_refinement,'
p9172
aS'                        initial_global_refinement +'
p9173
aS'                          n_adaptive_pre_refinement_steps);'
p9174
aS'            tmp.reinit(solution.size());'
p9175
aS'            forcing_terms.reinit(solution.size());'
p9176
aS'          }'
p9177
aS'        old_solution = solution;'
p9178
aS'      }'
p9179
aS'  }'
p9180
aS'} // namespace Step26'
p9181
aS'int main()'
p9182
ag24
aS'  try'
p9183
aS'    {'
p9184
aS'      using namespace Step26;'
p9185
aS'      HeatEquation<2> heat_equation_solver;'
p9186
aS'      heat_equation_solver.run();'
p9187
aS'    }'
p9188
aS'  catch (std::exception &exc)'
p9189
aS'    {'
p9190
aS'      std::cerr << std::endl'
p9191
aS'                << std::endl'
p9192
aS'                << "----------------------------------------------------"'
p9193
aS'                << std::endl;'
p9194
aS'      std::cerr << "Exception on processing: " << std::endl'
p9195
aS'                << exc.what() << std::endl'
p9196
aS'                << "Aborting!" << std::endl'
p9197
aS'                << "----------------------------------------------------"'
p9198
aS'                << std::endl;'
p9199
aS'      return 1;'
p9200
aS'    }'
p9201
aS'  catch (...)'
p9202
aS'    {'
p9203
aS'      std::cerr << std::endl'
p9204
aS'                << std::endl'
p9205
aS'                << "----------------------------------------------------"'
p9206
aS'                << std::endl;'
p9207
aS'      std::cerr << "Unknown exception!" << std::endl'
p9208
aS'                << "Aborting!" << std::endl'
p9209
aS'                << "----------------------------------------------------"'
p9210
aS'                << std::endl;'
p9211
aS'      return 1;'
p9212
aS'    }'
p9213
aS'  return 0;'
p9214
ag32
aS'/* ---------------------------------------------------------------------'
p9215
aS' *'
p9216
aS' * Copyright (C) 2006 - 2021 by the deal.II authors'
p9217
aS' *'
p9218
aS' * This file is part of the deal.II library.'
p9219
aS' *'
p9220
aS' * The deal.II library is free software; you can use it, redistribute'
p9221
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p9222
aS' * Public License as published by the Free Software Foundation; either'
p9223
aS' * version 2.1 of the License, or (at your option) any later version.'
p9224
aS' * The full text of the license can be found in the file LICENSE.md at'
p9225
aS' * the top level directory of deal.II.'
p9226
aS' *'
p9227
aS' * ---------------------------------------------------------------------'
p9228
aS' *'
p9229
aS' * Authors: Wolfgang Bangerth, Texas A&M University, 2006, 2007;'
p9230
aS' *          Denis Davydov, University of Erlangen-Nuremberg, 2016;'
p9231
aS' *          Marc Fehling, Colorado State University, 2020.'
p9232
aS' */'
p9233
aS'#include <deal.II/base/quadrature_lib.h>'
p9234
aS'#include <deal.II/base/function.h>'
p9235
aS'#include <deal.II/base/logstream.h>'
p9236
aS'#include <deal.II/base/utilities.h>'
p9237
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p9238
aS'#include <deal.II/lac/vector.h>'
p9239
aS'#include <deal.II/lac/full_matrix.h>'
p9240
aS'#include <deal.II/lac/sparse_matrix.h>'
p9241
aS'#include <deal.II/lac/solver_cg.h>'
p9242
aS'#include <deal.II/lac/precondition.h>'
p9243
aS'#include <deal.II/lac/affine_constraints.h>'
p9244
aS'#include <deal.II/grid/tria.h>'
p9245
aS'#include <deal.II/grid/grid_generator.h>'
p9246
aS'#include <deal.II/grid/grid_refinement.h>'
p9247
aS'#include <deal.II/dofs/dof_tools.h>'
p9248
aS'#include <deal.II/fe/fe_q.h>'
p9249
aS'#include <deal.II/numerics/vector_tools.h>'
p9250
aS'#include <deal.II/numerics/matrix_tools.h>'
p9251
aS'#include <deal.II/numerics/data_out.h>'
p9252
aS'#include <deal.II/numerics/error_estimator.h>'
p9253
aS'#include <deal.II/hp/fe_collection.h>'
p9254
aS'#include <deal.II/hp/fe_values.h>'
p9255
aS'#include <deal.II/hp/refinement.h>'
p9256
aS'#include <deal.II/fe/fe_series.h>'
p9257
aS'#include <deal.II/numerics/smoothness_estimator.h>'
p9258
aS'#include <fstream>'
p9259
aS'#include <iostream>'
p9260
aS'namespace Step27'
p9261
ag24
aS'  using namespace dealii;'
p9262
aS'  template <int dim>'
p9263
aS'  class LaplaceProblem'
p9264
aS'  {'
p9265
aS'  public:'
p9266
aS'    LaplaceProblem();'
p9267
aS'    ~LaplaceProblem();'
p9268
aS'    void run();'
p9269
aS'  private:'
p9270
aS'    void setup_system();'
p9271
aS'    void assemble_system();'
p9272
aS'    void solve();'
p9273
aS'    void create_coarse_grid();'
p9274
aS'    void postprocess(const unsigned int cycle);'
p9275
aS'    Triangulation<dim> triangulation;'
p9276
aS'    DoFHandler<dim>          dof_handler;'
p9277
aS'    hp::FECollection<dim>    fe_collection;'
p9278
aS'    hp::QCollection<dim>     quadrature_collection;'
p9279
aS'    hp::QCollection<dim - 1> face_quadrature_collection;'
p9280
aS'    AffineConstraints<double> constraints;'
p9281
aS'    SparsityPattern      sparsity_pattern;'
p9282
aS'    SparseMatrix<double> system_matrix;'
p9283
aS'    Vector<double> solution;'
p9284
aS'    Vector<double> system_rhs;'
p9285
aS'    const unsigned int max_degree;'
p9286
aS'  };'
p9287
aS'  template <int dim>'
p9288
aS'  class RightHandSide : public Function<dim>'
p9289
aS'  {'
p9290
aS'  public:'
p9291
aS'    virtual double value(const Point<dim> & p,'
p9292
aS'                         const unsigned int component) const override;'
p9293
aS'  };'
p9294
aS'  template <int dim>'
p9295
aS'  double RightHandSide<dim>::value(const Point<dim> &p,'
p9296
aS'                                   const unsigned int /*component*/) const'
p9297
aS'  {'
p9298
aS'    double product = 1;'
p9299
aS'    for (unsigned int d = 0; d < dim; ++d)'
p9300
aS'      product *= (p[d] + 1);'
p9301
aS'    return product;'
p9302
aS'  }'
p9303
aS'  template <int dim>'
p9304
aS'  LaplaceProblem<dim>::LaplaceProblem()'
p9305
aS'    : dof_handler(triangulation)'
p9306
aS'    , max_degree(dim <= 2 ? 7 : 5)'
p9307
aS'  {'
p9308
aS'    for (unsigned int degree = 2; degree <= max_degree; ++degree)'
p9309
aS'      {'
p9310
aS'        fe_collection.push_back(FE_Q<dim>(degree));'
p9311
aS'        quadrature_collection.push_back(QGauss<dim>(degree + 1));'
p9312
aS'        face_quadrature_collection.push_back(QGauss<dim - 1>(degree + 1));'
p9313
aS'      }'
p9314
aS'  }'
p9315
aS'  template <int dim>'
p9316
aS'  LaplaceProblem<dim>::~LaplaceProblem()'
p9317
aS'  {'
p9318
aS'    dof_handler.clear();'
p9319
aS'  }'
p9320
aS'  template <int dim>'
p9321
aS'  void LaplaceProblem<dim>::setup_system()'
p9322
aS'  {'
p9323
aS'    dof_handler.distribute_dofs(fe_collection);'
p9324
aS'    solution.reinit(dof_handler.n_dofs());'
p9325
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p9326
aS'    constraints.clear();'
p9327
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p9328
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p9329
aS'                                             0,'
p9330
aS'                                             Functions::ZeroFunction<dim>(),'
p9331
aS'                                             constraints);'
p9332
aS'    constraints.close();'
p9333
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p9334
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p9335
aS'    sparsity_pattern.copy_from(dsp);'
p9336
aS'    system_matrix.reinit(sparsity_pattern);'
p9337
aS'  }'
p9338
aS'  template <int dim>'
p9339
aS'  void LaplaceProblem<dim>::assemble_system()'
p9340
aS'  {'
p9341
aS'    hp::FEValues<dim> hp_fe_values(fe_collection,'
p9342
aS'                                   quadrature_collection,'
p9343
aS'                                   update_values | update_gradients |'
p9344
aS'                                     update_quadrature_points |'
p9345
aS'                                     update_JxW_values);'
p9346
aS'    RightHandSide<dim> rhs_function;'
p9347
aS'    FullMatrix<double> cell_matrix;'
p9348
aS'    Vector<double>     cell_rhs;'
p9349
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p9350
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9351
aS'      {'
p9352
aS'        const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();'
p9353
aS'        cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p9354
aS'        cell_matrix = 0;'
p9355
aS'        cell_rhs.reinit(dofs_per_cell);'
p9356
aS'        cell_rhs = 0;'
p9357
aS'        hp_fe_values.reinit(cell);'
p9358
aS'        const FEValues<dim> &fe_values = hp_fe_values.get_present_fe_values();'
p9359
aS'        std::vector<double> rhs_values(fe_values.n_quadrature_points);'
p9360
aS'        rhs_function.value_list(fe_values.get_quadrature_points(), rhs_values);'
p9361
aS'        for (unsigned int q_point = 0; q_point < fe_values.n_quadrature_points;'
p9362
aS'             ++q_point)'
p9363
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9364
aS'            {'
p9365
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p9366
aS'                cell_matrix(i, j) +='
p9367
aS'                  (fe_values.shape_grad(i, q_point) * // grad phi_i(x_q)'
p9368
aS'                   fe_values.shape_grad(j, q_point) * // grad phi_j(x_q)'
p9369
aS'                   fe_values.JxW(q_point));           // dx'
p9370
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)'
p9371
aS'                              rhs_values[q_point] *               // f(x_q)'
p9372
aS'                              fe_values.JxW(q_point));            // dx'
p9373
aS'            }'
p9374
aS'        local_dof_indices.resize(dofs_per_cell);'
p9375
aS'        cell->get_dof_indices(local_dof_indices);'
p9376
aS'        constraints.distribute_local_to_global('
p9377
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p9378
aS'      }'
p9379
aS'  }'
p9380
aS'  template <int dim>'
p9381
aS'  void LaplaceProblem<dim>::solve()'
p9382
aS'  {'
p9383
aS'    SolverControl            solver_control(system_rhs.size(),'
p9384
aS'                                 1e-12 * system_rhs.l2_norm());'
p9385
aS'    SolverCG<Vector<double>> cg(solver_control);'
p9386
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p9387
aS'    preconditioner.initialize(system_matrix, 1.2);'
p9388
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p9389
aS'    constraints.distribute(solution);'
p9390
aS'  }'
p9391
aS'  template <int dim>'
p9392
aS'  void LaplaceProblem<dim>::postprocess(const unsigned int cycle)'
p9393
aS'  {'
p9394
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p9395
aS'    KellyErrorEstimator<dim>::estimate('
p9396
aS'      dof_handler,'
p9397
aS'      face_quadrature_collection,'
p9398
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p9399
aS'      solution,'
p9400
aS'      estimated_error_per_cell);'
p9401
aS'    Vector<float> smoothness_indicators(triangulation.n_active_cells());'
p9402
aS'    FESeries::Fourier<dim> fourier ='
p9403
aS'      SmoothnessEstimator::Fourier::default_fe_series(fe_collection);'
p9404
aS'    SmoothnessEstimator::Fourier::coefficient_decay(fourier,'
p9405
aS'                                                    dof_handler,'
p9406
aS'                                                    solution,'
p9407
aS'                                                    smoothness_indicators);'
p9408
aS'    {'
p9409
aS'      Vector<float> fe_degrees(triangulation.n_active_cells());'
p9410
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p9411
aS'        fe_degrees(cell->active_cell_index()) ='
p9412
aS'          fe_collection[cell->active_fe_index()].degree;'
p9413
aS'      DataOut<dim> data_out;'
p9414
aS'      data_out.attach_dof_handler(dof_handler);'
p9415
aS'      data_out.add_data_vector(solution, "solution");'
p9416
aS'      data_out.add_data_vector(estimated_error_per_cell, "error");'
p9417
aS'      data_out.add_data_vector(smoothness_indicators, "smoothness");'
p9418
aS'      data_out.add_data_vector(fe_degrees, "fe_degree");'
p9419
aS'      data_out.build_patches();'
p9420
aS'      const std::string filename ='
p9421
aS'        "solution-" + Utilities::int_to_string(cycle, 2) + ".vtk";'
p9422
aS'      std::ofstream output(filename);'
p9423
aS'      data_out.write_vtk(output);'
p9424
aS'    }'
p9425
aS'    {'
p9426
aS'      GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p9427
aS'                                                      estimated_error_per_cell,'
p9428
aS'                                                      0.3,'
p9429
aS'                                                      0.03);'
p9430
aS'      hp::Refinement::p_adaptivity_from_relative_threshold('
p9431
aS'        dof_handler, smoothness_indicators, 0.2, 0.2);'
p9432
aS'      hp::Refinement::choose_p_over_h(dof_handler);'
p9433
aS'      triangulation.prepare_coarsening_and_refinement();'
p9434
aS'      hp::Refinement::limit_p_level_difference(dof_handler);'
p9435
aS'      triangulation.execute_coarsening_and_refinement();'
p9436
aS'    }'
p9437
aS'  }'
p9438
aS'  template <int dim>'
p9439
aS'  void LaplaceProblem<dim>::create_coarse_grid()'
p9440
aS'  {'
p9441
aS'    Triangulation<dim> cube;'
p9442
aS'    GridGenerator::subdivided_hyper_cube(cube, 4, -1., 1.);'
p9443
aS'    std::set<typename Triangulation<dim>::active_cell_iterator> cells_to_remove;'
p9444
aS'    for (const auto &cell : cube.active_cell_iterators())'
p9445
aS'      for (unsigned int v = 0; v < GeometryInfo<dim>::vertices_per_cell; ++v)'
p9446
aS'        if (cell->vertex(v).square() < .1)'
p9447
aS'          cells_to_remove.insert(cell);'
p9448
aS'    GridGenerator::create_triangulation_with_removed_cells(cube,'
p9449
aS'                                                           cells_to_remove,'
p9450
aS'                                                           triangulation);'
p9451
aS'    triangulation.refine_global(3);'
p9452
aS'  }'
p9453
aS'  template <int dim>'
p9454
aS'  void LaplaceProblem<dim>::run()'
p9455
aS'  {'
p9456
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p9457
aS'      {'
p9458
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p9459
aS'        if (cycle == 0)'
p9460
aS'          create_coarse_grid();'
p9461
aS'        setup_system();'
p9462
aS'        std::cout << "   Number of active cells      : "'
p9463
aS'                  << triangulation.n_active_cells() << std::endl'
p9464
aS'                  << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p9465
aS'                  << std::endl'
p9466
aS'                  << "   Number of constraints       : "'
p9467
aS'                  << constraints.n_constraints() << std::endl;'
p9468
aS'        assemble_system();'
p9469
aS'        solve();'
p9470
aS'        postprocess(cycle);'
p9471
aS'      }'
p9472
aS'  }'
p9473
aS'} // namespace Step27'
p9474
aS'int main()'
p9475
ag24
aS'  try'
p9476
aS'    {'
p9477
aS'      using namespace Step27;'
p9478
aS'      LaplaceProblem<2> laplace_problem;'
p9479
aS'      laplace_problem.run();'
p9480
aS'    }'
p9481
aS'  catch (std::exception &exc)'
p9482
aS'    {'
p9483
aS'      std::cerr << std::endl'
p9484
aS'                << std::endl'
p9485
aS'                << "----------------------------------------------------"'
p9486
aS'                << std::endl;'
p9487
aS'      std::cerr << "Exception on processing: " << std::endl'
p9488
aS'                << exc.what() << std::endl'
p9489
aS'                << "Aborting!" << std::endl'
p9490
aS'                << "----------------------------------------------------"'
p9491
aS'                << std::endl;'
p9492
aS'      return 1;'
p9493
aS'    }'
p9494
aS'  catch (...)'
p9495
aS'    {'
p9496
aS'      std::cerr << std::endl'
p9497
aS'                << std::endl'
p9498
aS'                << "----------------------------------------------------"'
p9499
aS'                << std::endl;'
p9500
aS'      std::cerr << "Unknown exception!" << std::endl'
p9501
aS'                << "Aborting!" << std::endl'
p9502
aS'                << "----------------------------------------------------"'
p9503
aS'                << std::endl;'
p9504
aS'      return 1;'
p9505
aS'    }'
p9506
aS'  return 0;'
p9507
ag32
aS'/* ---------------------------------------------------------------------'
p9508
aS' *'
p9509
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p9510
aS' *'
p9511
aS' * This file is part of the deal.II library.'
p9512
aS' *'
p9513
aS' * The deal.II library is free software; you can use it, redistribute'
p9514
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p9515
aS' * Public License as published by the Free Software Foundation; either'
p9516
aS' * version 2.1 of the License, or (at your option) any later version.'
p9517
aS' * The full text of the license can be found in the file LICENSE.md at'
p9518
aS' * the top level directory of deal.II.'
p9519
aS' *'
p9520
aS' * ---------------------------------------------------------------------'
p9521
aS' *'
p9522
aS' * Author: Yaqi Wang, Texas A&M University, 2009, 2010'
p9523
aS' */'
p9524
aS'#include <deal.II/base/timer.h>'
p9525
aS'#include <deal.II/base/quadrature_lib.h>'
p9526
aS'#include <deal.II/base/function.h>'
p9527
aS'#include <deal.II/base/parameter_handler.h>'
p9528
aS'#include <deal.II/base/thread_management.h>'
p9529
aS'#include <deal.II/base/utilities.h>'
p9530
aS'#include <deal.II/lac/vector.h>'
p9531
aS'#include <deal.II/lac/full_matrix.h>'
p9532
aS'#include <deal.II/lac/sparsity_pattern.h>'
p9533
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p9534
aS'#include <deal.II/lac/sparse_matrix.h>'
p9535
aS'#include <deal.II/lac/solver_cg.h>'
p9536
aS'#include <deal.II/lac/precondition.h>'
p9537
aS'#include <deal.II/lac/affine_constraints.h>'
p9538
aS'#include <deal.II/grid/tria.h>'
p9539
aS'#include <deal.II/grid/grid_refinement.h>'
p9540
aS'#include <deal.II/grid/grid_out.h>'
p9541
aS'#include <deal.II/grid/grid_generator.h>'
p9542
aS'#include <deal.II/dofs/dof_handler.h>'
p9543
aS'#include <deal.II/dofs/dof_tools.h>'
p9544
aS'#include <deal.II/fe/fe_q.h>'
p9545
aS'#include <deal.II/fe/fe_values.h>'
p9546
aS'#include <deal.II/numerics/vector_tools.h>'
p9547
aS'#include <deal.II/numerics/matrix_tools.h>'
p9548
aS'#include <deal.II/numerics/data_out.h>'
p9549
aS'#include <deal.II/numerics/error_estimator.h>'
p9550
aS'#include <fstream>'
p9551
aS'#include <iostream>'
p9552
aS'#include <deal.II/lac/block_vector.h>'
p9553
aS'#include <deal.II/numerics/solution_transfer.h>'
p9554
aS'#include <deal.II/grid/grid_tools.h>'
p9555
aS'#include <boost/io/ios_state.hpp>'
p9556
aS'#include <list>'
p9557
aS'#include <iomanip>'
p9558
aS'namespace Step28'
p9559
ag24
aS'  using namespace dealii;'
p9560
aS'  class MaterialData'
p9561
aS'  {'
p9562
aS'  public:'
p9563
aS'    MaterialData(const unsigned int n_groups);'
p9564
aS'    double get_diffusion_coefficient(const unsigned int group,'
p9565
aS'                                     const unsigned int material_id) const;'
p9566
aS'    double get_removal_XS(const unsigned int group,'
p9567
aS'                          const unsigned int material_id) const;'
p9568
aS'    double get_fission_XS(const unsigned int group,'
p9569
aS'                          const unsigned int material_id) const;'
p9570
aS'    double get_fission_dist_XS(const unsigned int group_1,'
p9571
aS'                               const unsigned int group_2,'
p9572
aS'                               const unsigned int material_id) const;'
p9573
aS'    double get_scattering_XS(const unsigned int group_1,'
p9574
aS'                             const unsigned int group_2,'
p9575
aS'                             const unsigned int material_id) const;'
p9576
aS'    double get_fission_spectrum(const unsigned int group,'
p9577
aS'                                const unsigned int material_id) const;'
p9578
aS'  private:'
p9579
aS'    const unsigned int n_groups;'
p9580
aS'    const unsigned int n_materials;'
p9581
aS'    Table<2, double> diffusion;'
p9582
aS'    Table<2, double> sigma_r;'
p9583
aS'    Table<2, double> nu_sigma_f;'
p9584
aS'    Table<3, double> sigma_s;'
p9585
aS'    Table<2, double> chi;'
p9586
aS'  };'
p9587
aS'  MaterialData::MaterialData(const unsigned int n_groups)'
p9588
aS'    : n_groups(n_groups)'
p9589
aS'    , n_materials(8)'
p9590
aS'    , diffusion(n_materials, n_groups)'
p9591
aS'    , sigma_r(n_materials, n_groups)'
p9592
aS'    , nu_sigma_f(n_materials, n_groups)'
p9593
aS'    , sigma_s(n_materials, n_groups, n_groups)'
p9594
aS'    , chi(n_materials, n_groups)'
p9595
aS'  {'
p9596
aS'    switch (this->n_groups)'
p9597
aS'      {'
p9598
aS'        case 2:'
p9599
aS'          {'
p9600
aS'            for (unsigned int m = 0; m < n_materials; ++m)'
p9601
aS'              {'
p9602
aS'                diffusion[m][0] = 1.2;'
p9603
aS'                diffusion[m][1] = 0.4;'
p9604
aS'                chi[m][0]       = 1.0;'
p9605
aS'                chi[m][1]       = 0.0;'
p9606
aS'                sigma_r[m][0]   = 0.03;'
p9607
aS'                for (unsigned int group_1 = 0; group_1 < n_groups; ++group_1)'
p9608
aS'                  for (unsigned int group_2 = 0; group_2 < n_groups; ++group_2)'
p9609
aS'                    sigma_s[m][group_1][group_2] = 0.0;'
p9610
aS'              }'
p9611
aS'            diffusion[5][1] = 0.2;'
p9612
aS'            sigma_r[4][0] = 0.026;'
p9613
aS'            sigma_r[5][0] = 0.051;'
p9614
aS'            sigma_r[6][0] = 0.026;'
p9615
aS'            sigma_r[7][0] = 0.050;'
p9616
aS'            sigma_r[0][1] = 0.100;'
p9617
aS'            sigma_r[1][1] = 0.200;'
p9618
aS'            sigma_r[2][1] = 0.250;'
p9619
aS'            sigma_r[3][1] = 0.300;'
p9620
aS'            sigma_r[4][1] = 0.020;'
p9621
aS'            sigma_r[5][1] = 0.040;'
p9622
aS'            sigma_r[6][1] = 0.020;'
p9623
aS'            sigma_r[7][1] = 0.800;'
p9624
aS'            nu_sigma_f[0][0] = 0.0050;'
p9625
aS'            nu_sigma_f[1][0] = 0.0075;'
p9626
aS'            nu_sigma_f[2][0] = 0.0075;'
p9627
aS'            nu_sigma_f[3][0] = 0.0075;'
p9628
aS'            nu_sigma_f[4][0] = 0.000;'
p9629
aS'            nu_sigma_f[5][0] = 0.000;'
p9630
aS'            nu_sigma_f[6][0] = 1e-7;'
p9631
aS'            nu_sigma_f[7][0] = 0.00;'
p9632
aS'            nu_sigma_f[0][1] = 0.125;'
p9633
aS'            nu_sigma_f[1][1] = 0.300;'
p9634
aS'            nu_sigma_f[2][1] = 0.375;'
p9635
aS'            nu_sigma_f[3][1] = 0.450;'
p9636
aS'            nu_sigma_f[4][1] = 0.000;'
p9637
aS'            nu_sigma_f[5][1] = 0.000;'
p9638
aS'            nu_sigma_f[6][1] = 3e-6;'
p9639
aS'            nu_sigma_f[7][1] = 0.00;'
p9640
aS'            sigma_s[0][0][1] = 0.020;'
p9641
aS'            sigma_s[1][0][1] = 0.015;'
p9642
aS'            sigma_s[2][0][1] = 0.015;'
p9643
aS'            sigma_s[3][0][1] = 0.015;'
p9644
aS'            sigma_s[4][0][1] = 0.025;'
p9645
aS'            sigma_s[5][0][1] = 0.050;'
p9646
aS'            sigma_s[6][0][1] = 0.025;'
p9647
aS'            sigma_s[7][0][1] = 0.010;'
p9648
aS'            break;'
p9649
aS'          }'
p9650
aS'        default:'
p9651
aS'          Assert(false,'
p9652
aS'                 ExcMessage('
p9653
aS'                   "Presently, only data for 2 groups is implemented"));'
p9654
aS'      }'
p9655
aS'  }'
p9656
aS'  double'
p9657
aS'  MaterialData::get_diffusion_coefficient(const unsigned int group,'
p9658
aS'                                          const unsigned int material_id) const'
p9659
aS'  {'
p9660
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9661
aS'    Assert(material_id < n_materials,'
p9662
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9663
aS'    return diffusion[material_id][group];'
p9664
aS'  }'
p9665
aS'  double MaterialData::get_removal_XS(const unsigned int group,'
p9666
aS'                                      const unsigned int material_id) const'
p9667
aS'  {'
p9668
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9669
aS'    Assert(material_id < n_materials,'
p9670
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9671
aS'    return sigma_r[material_id][group];'
p9672
aS'  }'
p9673
aS'  double MaterialData::get_fission_XS(const unsigned int group,'
p9674
aS'                                      const unsigned int material_id) const'
p9675
aS'  {'
p9676
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9677
aS'    Assert(material_id < n_materials,'
p9678
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9679
aS'    return nu_sigma_f[material_id][group];'
p9680
aS'  }'
p9681
aS'  double MaterialData::get_scattering_XS(const unsigned int group_1,'
p9682
aS'                                         const unsigned int group_2,'
p9683
aS'                                         const unsigned int material_id) const'
p9684
aS'  {'
p9685
aS'    Assert(group_1 < n_groups, ExcIndexRange(group_1, 0, n_groups));'
p9686
aS'    Assert(group_2 < n_groups, ExcIndexRange(group_2, 0, n_groups));'
p9687
aS'    Assert(material_id < n_materials,'
p9688
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9689
aS'    return sigma_s[material_id][group_1][group_2];'
p9690
aS'  }'
p9691
aS'  double'
p9692
aS'  MaterialData::get_fission_spectrum(const unsigned int group,'
p9693
aS'                                     const unsigned int material_id) const'
p9694
aS'  {'
p9695
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9696
aS'    Assert(material_id < n_materials,'
p9697
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9698
aS'    return chi[material_id][group];'
p9699
aS'  }'
p9700
aS'  double MaterialData::get_fission_dist_XS(const unsigned int group_1,'
p9701
aS'                                           const unsigned int group_2,'
p9702
aS'                                           const unsigned int material_id) const'
p9703
aS'  {'
p9704
aS'    return (get_fission_spectrum(group_1, material_id) *'
p9705
aS'            get_fission_XS(group_2, material_id));'
p9706
aS'  }'
p9707
aS'  template <int dim>'
p9708
aS'  class EnergyGroup'
p9709
aS'  {'
p9710
aS'  public:'
p9711
aS'    EnergyGroup(const unsigned int        group,'
p9712
aS'                const MaterialData &      material_data,'
p9713
aS'                const Triangulation<dim> &coarse_grid,'
p9714
aS'                const FiniteElement<dim> &fe);'
p9715
aS'    void setup_linear_system();'
p9716
aS'    unsigned int n_active_cells() const;'
p9717
aS'    unsigned int n_dofs() const;'
p9718
aS'    void assemble_system_matrix();'
p9719
aS'    void assemble_ingroup_rhs(const Function<dim> &extraneous_source);'
p9720
aS'    void assemble_cross_group_rhs(const EnergyGroup<dim> &g_prime);'
p9721
aS'    void solve();'
p9722
aS'    double get_fission_source() const;'
p9723
aS'    void output_results(const unsigned int cycle) const;'
p9724
aS'    void estimate_errors(Vector<float> &error_indicators) const;'
p9725
aS'    void refine_grid(const Vector<float> &error_indicators,'
p9726
aS'                     const double         refine_threshold,'
p9727
aS'                     const double         coarsen_threshold);'
p9728
aS'  public:'
p9729
aS'    Vector<double> solution;'
p9730
aS'    Vector<double> solution_old;'
p9731
aS'  private:'
p9732
aS'    const unsigned int  group;'
p9733
aS'    const MaterialData &material_data;'
p9734
aS'    Triangulation<dim>        triangulation;'
p9735
aS'    const FiniteElement<dim> &fe;'
p9736
aS'    DoFHandler<dim>           dof_handler;'
p9737
aS'    SparsityPattern      sparsity_pattern;'
p9738
aS'    SparseMatrix<double> system_matrix;'
p9739
aS'    Vector<double> system_rhs;'
p9740
aS'    std::map<types::global_dof_index, double> boundary_values;'
p9741
aS'    AffineConstraints<double>                 hanging_node_constraints;'
p9742
aS'  private:'
p9743
aS'    void assemble_cross_group_rhs_recursive('
p9744
aS'      const EnergyGroup<dim> &                       g_prime,'
p9745
aS'      const typename DoFHandler<dim>::cell_iterator &cell_g,'
p9746
aS'      const typename DoFHandler<dim>::cell_iterator &cell_g_prime,'
p9747
aS'      const FullMatrix<double> &                     prolongation_matrix);'
p9748
aS'  };'
p9749
aS'  template <int dim>'
p9750
aS'  EnergyGroup<dim>::EnergyGroup(const unsigned int        group,'
p9751
aS'                                const MaterialData &      material_data,'
p9752
aS'                                const Triangulation<dim> &coarse_grid,'
p9753
aS'                                const FiniteElement<dim> &fe)'
p9754
aS'    : group(group)'
p9755
aS'    , material_data(material_data)'
p9756
aS'    , fe(fe)'
p9757
aS'    , dof_handler(triangulation)'
p9758
aS'  {'
p9759
aS'    triangulation.copy_triangulation(coarse_grid);'
p9760
aS'    dof_handler.distribute_dofs(fe);'
p9761
aS'  }'
p9762
aS'  template <int dim>'
p9763
aS'  unsigned int EnergyGroup<dim>::n_active_cells() const'
p9764
aS'  {'
p9765
aS'    return triangulation.n_active_cells();'
p9766
aS'  }'
p9767
aS'  template <int dim>'
p9768
aS'  unsigned int EnergyGroup<dim>::n_dofs() const'
p9769
aS'  {'
p9770
aS'    return dof_handler.n_dofs();'
p9771
aS'  }'
p9772
aS'  template <int dim>'
p9773
aS'  void EnergyGroup<dim>::setup_linear_system()'
p9774
aS'  {'
p9775
aS'    const unsigned int n_dofs = dof_handler.n_dofs();'
p9776
aS'    hanging_node_constraints.clear();'
p9777
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p9778
aS'                                            hanging_node_constraints);'
p9779
aS'    hanging_node_constraints.close();'
p9780
aS'    system_matrix.clear();'
p9781
aS'    DynamicSparsityPattern dsp(n_dofs, n_dofs);'
p9782
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p9783
aS'    hanging_node_constraints.condense(dsp);'
p9784
aS'    sparsity_pattern.copy_from(dsp);'
p9785
aS'    system_matrix.reinit(sparsity_pattern);'
p9786
aS'    system_rhs.reinit(n_dofs);'
p9787
aS'    if (solution.size() == 0)'
p9788
aS'      {'
p9789
aS'        solution.reinit(n_dofs);'
p9790
aS'        solution_old.reinit(n_dofs);'
p9791
aS'        solution_old = 1.0;'
p9792
aS'        solution     = solution_old;'
p9793
aS'      }'
p9794
aS'    boundary_values.clear();'
p9795
aS'    for (unsigned int i = 0; i < dim; ++i)'
p9796
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p9797
aS'                                               2 * i + 1,'
p9798
aS'                                               Functions::ZeroFunction<dim>(),'
p9799
aS'                                               boundary_values);'
p9800
aS'  }'
p9801
aS'  template <int dim>'
p9802
aS'  void EnergyGroup<dim>::assemble_system_matrix()'
p9803
aS'  {'
p9804
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p9805
aS'    FEValues<dim> fe_values(fe,'
p9806
aS'                            quadrature_formula,'
p9807
aS'                            update_values | update_gradients |'
p9808
aS'                              update_JxW_values);'
p9809
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p9810
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p9811
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p9812
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p9813
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p9814
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9815
aS'      {'
p9816
aS'        cell_matrix = 0;'
p9817
aS'        fe_values.reinit(cell);'
p9818
aS'        const double diffusion_coefficient ='
p9819
aS'          material_data.get_diffusion_coefficient(group, cell->material_id());'
p9820
aS'        const double removal_XS ='
p9821
aS'          material_data.get_removal_XS(group, cell->material_id());'
p9822
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9823
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9824
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p9825
aS'              cell_matrix(i, j) +='
p9826
aS'                ((diffusion_coefficient * fe_values.shape_grad(i, q_point) *'
p9827
aS'                    fe_values.shape_grad(j, q_point) +'
p9828
aS'                  removal_XS * fe_values.shape_value(i, q_point) *'
p9829
aS'                    fe_values.shape_value(j, q_point)) *'
p9830
aS'                 fe_values.JxW(q_point));'
p9831
aS'        cell->get_dof_indices(local_dof_indices);'
p9832
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9833
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p9834
aS'            system_matrix.add(local_dof_indices[i],'
p9835
aS'                              local_dof_indices[j],'
p9836
aS'                              cell_matrix(i, j));'
p9837
aS'      }'
p9838
aS'    hanging_node_constraints.condense(system_matrix);'
p9839
aS'  }'
p9840
aS'  template <int dim>'
p9841
aS'  void'
p9842
aS'  EnergyGroup<dim>::assemble_ingroup_rhs(const Function<dim> &extraneous_source)'
p9843
aS'  {'
p9844
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p9845
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p9846
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p9847
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p9848
aS'    FEValues<dim> fe_values(fe,'
p9849
aS'                            quadrature_formula,'
p9850
aS'                            update_values | update_quadrature_points |'
p9851
aS'                              update_JxW_values);'
p9852
aS'    Vector<double>      cell_rhs(dofs_per_cell);'
p9853
aS'    std::vector<double> extraneous_source_values(n_q_points);'
p9854
aS'    std::vector<double> solution_old_values(n_q_points);'
p9855
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p9856
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9857
aS'      {'
p9858
aS'        cell_rhs = 0;'
p9859
aS'        fe_values.reinit(cell);'
p9860
aS'        const double fission_dist_XS ='
p9861
aS'          material_data.get_fission_dist_XS(group, group, cell->material_id());'
p9862
aS'        extraneous_source.value_list(fe_values.get_quadrature_points(),'
p9863
aS'                                     extraneous_source_values);'
p9864
aS'        fe_values.get_function_values(solution_old, solution_old_values);'
p9865
aS'        cell->get_dof_indices(local_dof_indices);'
p9866
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9867
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9868
aS'            cell_rhs(i) +='
p9869
aS'              ((extraneous_source_values[q_point] +'
p9870
aS'                fission_dist_XS * solution_old_values[q_point]) *'
p9871
aS'               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));'
p9872
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9873
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p9874
aS'      }'
p9875
aS'  }'
p9876
aS'  template <int dim>'
p9877
aS'  void'
p9878
aS'  EnergyGroup<dim>::assemble_cross_group_rhs(const EnergyGroup<dim> &g_prime)'
p9879
aS'  {'
p9880
aS'    if (group == g_prime.group)'
p9881
aS'      return;'
p9882
aS'    const std::list<std::pair<typename DoFHandler<dim>::cell_iterator,'
p9883
aS'                              typename DoFHandler<dim>::cell_iterator>>'
p9884
aS'      cell_list ='
p9885
aS'        GridTools::get_finest_common_cells(dof_handler, g_prime.dof_handler);'
p9886
aS'    for (const auto &cell_pair : cell_list)'
p9887
aS'      {'
p9888
aS'        FullMatrix<double> unit_matrix(fe.n_dofs_per_cell());'
p9889
aS'        for (unsigned int i = 0; i < unit_matrix.m(); ++i)'
p9890
aS'          unit_matrix(i, i) = 1;'
p9891
aS'        assemble_cross_group_rhs_recursive(g_prime,'
p9892
aS'                                           cell_pair.first,'
p9893
aS'                                           cell_pair.second,'
p9894
aS'                                           unit_matrix);'
p9895
aS'      }'
p9896
aS'  }'
p9897
aS'  template <int dim>'
p9898
aS'  void EnergyGroup<dim>::assemble_cross_group_rhs_recursive('
p9899
aS'    const EnergyGroup<dim> &                       g_prime,'
p9900
aS'    const typename DoFHandler<dim>::cell_iterator &cell_g,'
p9901
aS'    const typename DoFHandler<dim>::cell_iterator &cell_g_prime,'
p9902
aS'    const FullMatrix<double> &                     prolongation_matrix)'
p9903
aS'  {'
p9904
aS'    if (!cell_g->has_children() && !cell_g_prime->has_children())'
p9905
aS'      {'
p9906
aS'        const QGauss<dim>  quadrature_formula(fe.degree + 1);'
p9907
aS'        const unsigned int n_q_points = quadrature_formula.size();'
p9908
aS'        FEValues<dim> fe_values(fe,'
p9909
aS'                                quadrature_formula,'
p9910
aS'                                update_values | update_JxW_values);'
p9911
aS'        if (cell_g->level() > cell_g_prime->level())'
p9912
aS'          fe_values.reinit(cell_g);'
p9913
aS'        else'
p9914
aS'          fe_values.reinit(cell_g_prime);'
p9915
aS'        const double fission_dist_XS ='
p9916
aS'          material_data.get_fission_dist_XS(group,'
p9917
aS'                                            g_prime.group,'
p9918
aS'                                            cell_g_prime->material_id());'
p9919
aS'        const double scattering_XS ='
p9920
aS'          material_data.get_scattering_XS(g_prime.group,'
p9921
aS'                                          group,'
p9922
aS'                                          cell_g_prime->material_id());'
p9923
aS'        FullMatrix<double> local_mass_matrix_f(fe.n_dofs_per_cell(),'
p9924
aS'                                               fe.n_dofs_per_cell());'
p9925
aS'        FullMatrix<double> local_mass_matrix_g(fe.n_dofs_per_cell(),'
p9926
aS'                                               fe.n_dofs_per_cell());'
p9927
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9928
aS'          for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p9929
aS'            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p9930
aS'              {'
p9931
aS'                local_mass_matrix_f(i, j) +='
p9932
aS'                  (fission_dist_XS * fe_values.shape_value(i, q_point) *'
p9933
aS'                   fe_values.shape_value(j, q_point) * fe_values.JxW(q_point));'
p9934
aS'                local_mass_matrix_g(i, j) +='
p9935
aS'                  (scattering_XS * fe_values.shape_value(i, q_point) *'
p9936
aS'                   fe_values.shape_value(j, q_point) * fe_values.JxW(q_point));'
p9937
aS'              }'
p9938
aS'        Vector<double> g_prime_new_values(fe.n_dofs_per_cell());'
p9939
aS'        Vector<double> g_prime_old_values(fe.n_dofs_per_cell());'
p9940
aS'        cell_g_prime->get_dof_values(g_prime.solution_old, g_prime_old_values);'
p9941
aS'        cell_g_prime->get_dof_values(g_prime.solution, g_prime_new_values);'
p9942
aS'        Vector<double> cell_rhs(fe.n_dofs_per_cell());'
p9943
aS'        Vector<double> tmp(fe.n_dofs_per_cell());'
p9944
aS'        if (cell_g->level() > cell_g_prime->level())'
p9945
aS'          {'
p9946
aS'            prolongation_matrix.vmult(tmp, g_prime_old_values);'
p9947
aS'            local_mass_matrix_f.vmult(cell_rhs, tmp);'
p9948
aS'            prolongation_matrix.vmult(tmp, g_prime_new_values);'
p9949
aS'            local_mass_matrix_g.vmult_add(cell_rhs, tmp);'
p9950
aS'          }'
p9951
aS'        else'
p9952
aS'          {'
p9953
aS'            local_mass_matrix_f.vmult(tmp, g_prime_old_values);'
p9954
aS'            prolongation_matrix.Tvmult(cell_rhs, tmp);'
p9955
aS'            local_mass_matrix_g.vmult(tmp, g_prime_new_values);'
p9956
aS'            prolongation_matrix.Tvmult_add(cell_rhs, tmp);'
p9957
aS'          }'
p9958
aS'        std::vector<types::global_dof_index> local_dof_indices('
p9959
aS'          fe.n_dofs_per_cell());'
p9960
aS'        cell_g->get_dof_indices(local_dof_indices);'
p9961
aS'        for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p9962
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p9963
aS'      }'
p9964
aS'    else'
p9965
aS'      for (unsigned int child = 0;'
p9966
aS'           child < GeometryInfo<dim>::max_children_per_cell;'
p9967
aS'           ++child)'
p9968
aS'        {'
p9969
aS'          FullMatrix<double> new_matrix(fe.n_dofs_per_cell(),'
p9970
aS'                                        fe.n_dofs_per_cell());'
p9971
aS'          fe.get_prolongation_matrix(child).mmult(new_matrix,'
p9972
aS'                                                  prolongation_matrix);'
p9973
aS'          if (cell_g->has_children())'
p9974
aS'            assemble_cross_group_rhs_recursive(g_prime,'
p9975
aS'                                               cell_g->child(child),'
p9976
aS'                                               cell_g_prime,'
p9977
aS'                                               new_matrix);'
p9978
aS'          else'
p9979
aS'            assemble_cross_group_rhs_recursive(g_prime,'
p9980
aS'                                               cell_g,'
p9981
aS'                                               cell_g_prime->child(child),'
p9982
aS'                                               new_matrix);'
p9983
aS'        }'
p9984
aS'  }'
p9985
aS'  template <int dim>'
p9986
aS'  double EnergyGroup<dim>::get_fission_source() const'
p9987
aS'  {'
p9988
aS'    const QGauss<dim>  quadrature_formula(fe.degree + 1);'
p9989
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p9990
aS'    FEValues<dim> fe_values(fe,'
p9991
aS'                            quadrature_formula,'
p9992
aS'                            update_values | update_JxW_values);'
p9993
aS'    std::vector<double> solution_values(n_q_points);'
p9994
aS'    double fission_source = 0;'
p9995
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9996
aS'      {'
p9997
aS'        fe_values.reinit(cell);'
p9998
aS'        const double fission_XS ='
p9999
aS'          material_data.get_fission_XS(group, cell->material_id());'
p10000
aS'        fe_values.get_function_values(solution, solution_values);'
p10001
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p10002
aS'          fission_source +='
p10003
aS'            (fission_XS * solution_values[q_point] * fe_values.JxW(q_point));'
p10004
aS'      }'
p10005
aS'    return fission_source;'
p10006
aS'  }'
p10007
aS'  template <int dim>'
p10008
aS'  void EnergyGroup<dim>::solve()'
p10009
aS'  {'
p10010
aS'    hanging_node_constraints.condense(system_rhs);'
p10011
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p10012
aS'                                       system_matrix,'
p10013
aS'                                       solution,'
p10014
aS'                                       system_rhs);'
p10015
aS'    SolverControl            solver_control(system_matrix.m(),'
p10016
aS'                                 1e-12 * system_rhs.l2_norm());'
p10017
aS'    SolverCG<Vector<double>> cg(solver_control);'
p10018
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p10019
aS'    preconditioner.initialize(system_matrix, 1.2);'
p10020
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p10021
aS'    hanging_node_constraints.distribute(solution);'
p10022
aS'  }'
p10023
aS'  template <int dim>'
p10024
aS'  void EnergyGroup<dim>::estimate_errors(Vector<float> &error_indicators) const'
p10025
aS'  {'
p10026
aS'    KellyErrorEstimator<dim>::estimate('
p10027
aS'      dof_handler,'
p10028
aS'      QGauss<dim - 1>(fe.degree + 1),'
p10029
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p10030
aS'      solution,'
p10031
aS'      error_indicators);'
p10032
aS'    error_indicators /= solution.linfty_norm();'
p10033
aS'  }'
p10034
aS'  template <int dim>'
p10035
aS'  void EnergyGroup<dim>::refine_grid(const Vector<float> &error_indicators,'
p10036
aS'                                     const double         refine_threshold,'
p10037
aS'                                     const double         coarsen_threshold)'
p10038
aS'  {'
p10039
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p10040
aS'      if (error_indicators(cell->active_cell_index()) > refine_threshold)'
p10041
aS'        cell->set_refine_flag();'
p10042
aS'      else if (error_indicators(cell->active_cell_index()) < coarsen_threshold)'
p10043
aS'        cell->set_coarsen_flag();'
p10044
aS'    SolutionTransfer<dim> soltrans(dof_handler);'
p10045
aS'    triangulation.prepare_coarsening_and_refinement();'
p10046
aS'    soltrans.prepare_for_coarsening_and_refinement(solution);'
p10047
aS'    triangulation.execute_coarsening_and_refinement();'
p10048
aS'    dof_handler.distribute_dofs(fe);'
p10049
aS'    setup_linear_system();'
p10050
aS'    solution.reinit(dof_handler.n_dofs());'
p10051
aS'    soltrans.interpolate(solution_old, solution);'
p10052
aS'    hanging_node_constraints.distribute(solution);'
p10053
aS'    solution_old.reinit(dof_handler.n_dofs());'
p10054
aS'    solution_old = solution;'
p10055
aS'  }'
p10056
aS'  template <int dim>'
p10057
aS'  void EnergyGroup<dim>::output_results(const unsigned int cycle) const'
p10058
aS'  {'
p10059
aS'    const std::string filename = std::string("solution-") +'
p10060
aS'                                 Utilities::int_to_string(group, 2) + "." +'
p10061
aS'                                 Utilities::int_to_string(cycle, 2) + ".vtu";'
p10062
aS'    DataOut<dim> data_out;'
p10063
aS'    data_out.attach_dof_handler(dof_handler);'
p10064
aS'    data_out.add_data_vector(solution, "solution");'
p10065
aS'    data_out.build_patches();'
p10066
aS'    std::ofstream output(filename);'
p10067
aS'    data_out.write_vtu(output);'
p10068
aS'  }'
p10069
aS'  template <int dim>'
p10070
aS'  class NeutronDiffusionProblem'
p10071
aS'  {'
p10072
aS'  public:'
p10073
aS'    class Parameters'
p10074
aS'    {'
p10075
aS'    public:'
p10076
aS'      Parameters();'
p10077
aS'      static void declare_parameters(ParameterHandler &prm);'
p10078
aS'      void        get_parameters(ParameterHandler &prm);'
p10079
aS'      unsigned int n_groups;'
p10080
aS'      unsigned int n_refinement_cycles;'
p10081
aS'      unsigned int fe_degree;'
p10082
aS'      double convergence_tolerance;'
p10083
aS'    };'
p10084
aS'    NeutronDiffusionProblem(const Parameters &parameters);'
p10085
aS'    void run();'
p10086
aS'  private:'
p10087
aS'    void initialize_problem();'
p10088
aS'    void refine_grid();'
p10089
aS'    double get_total_fission_source() const;'
p10090
aS'    const Parameters & parameters;'
p10091
aS'    const MaterialData material_data;'
p10092
aS'    FE_Q<dim>          fe;'
p10093
aS'    double k_eff;'
p10094
aS'    std::vector<std::unique_ptr<EnergyGroup<dim>>> energy_groups;'
p10095
aS'    std::ofstream convergence_table_stream;'
p10096
aS'  };'
p10097
aS'  template <int dim>'
p10098
aS'  NeutronDiffusionProblem<dim>::Parameters::Parameters()'
p10099
aS'    : n_groups(2)'
p10100
aS'    , n_refinement_cycles(5)'
p10101
aS'    , fe_degree(2)'
p10102
aS'    , convergence_tolerance(1e-12)'
p10103
aS'  {}'
p10104
aS'  template <int dim>'
p10105
aS'  void NeutronDiffusionProblem<dim>::Parameters::declare_parameters('
p10106
aS'    ParameterHandler &prm)'
p10107
aS'  {'
p10108
aS'    prm.declare_entry("Number of energy groups",'
p10109
aS'                      "2",'
p10110
aS'                      Patterns::Integer(),'
p10111
aS'                      "The number of energy different groups considered");'
p10112
aS'    prm.declare_entry("Refinement cycles",'
p10113
aS'                      "5",'
p10114
aS'                      Patterns::Integer(),'
p10115
aS'                      "Number of refinement cycles to be performed");'
p10116
aS'    prm.declare_entry("Finite element degree",'
p10117
aS'                      "2",'
p10118
aS'                      Patterns::Integer(),'
p10119
aS'                      "Polynomial degree of the finite element to be used");'
p10120
aS'    prm.declare_entry('
p10121
aS'      "Power iteration tolerance",'
p10122
aS'      "1e-12",'
p10123
aS'      Patterns::Double(),'
p10124
aS'      "Inner power iterations are stopped when the change in k_eff falls "'
p10125
aS'      "below this tolerance");'
p10126
aS'  }'
p10127
aS'  template <int dim>'
p10128
aS'  void NeutronDiffusionProblem<dim>::Parameters::get_parameters('
p10129
aS'    ParameterHandler &prm)'
p10130
aS'  {'
p10131
aS'    n_groups              = prm.get_integer("Number of energy groups");'
p10132
aS'    n_refinement_cycles   = prm.get_integer("Refinement cycles");'
p10133
aS'    fe_degree             = prm.get_integer("Finite element degree");'
p10134
aS'    convergence_tolerance = prm.get_double("Power iteration tolerance");'
p10135
aS'  }'
p10136
aS'  template <int dim>'
p10137
aS'  NeutronDiffusionProblem<dim>::NeutronDiffusionProblem('
p10138
aS'    const Parameters &parameters)'
p10139
aS'    : parameters(parameters)'
p10140
aS'    , material_data(parameters.n_groups)'
p10141
aS'    , fe(parameters.fe_degree)'
p10142
aS'    , k_eff(std::numeric_limits<double>::quiet_NaN())'
p10143
aS'  {}'
p10144
aS'  template <int dim>'
p10145
aS'  void NeutronDiffusionProblem<dim>::initialize_problem()'
p10146
aS'  {'
p10147
aS'    const unsigned int rods_per_assembly_x = 17, rods_per_assembly_y = 17;'
p10148
aS'    const double       pin_pitch_x = 1.26, pin_pitch_y = 1.26;'
p10149
aS'    const double       assembly_height = 200;'
p10150
aS'    const unsigned int assemblies_x = 2, assemblies_y = 2, assemblies_z = 1;'
p10151
aS'    const Point<dim> bottom_left = Point<dim>();'
p10152
aS'    const Point<dim> upper_right ='
p10153
aS'      (dim == 2 ? Point<dim>(assemblies_x * rods_per_assembly_x * pin_pitch_x,'
p10154
aS'                             assemblies_y * rods_per_assembly_y * pin_pitch_y) :'
p10155
aS'                  Point<dim>(assemblies_x * rods_per_assembly_x * pin_pitch_x,'
p10156
aS'                             assemblies_y * rods_per_assembly_y * pin_pitch_y,'
p10157
aS'                             assemblies_z * assembly_height));'
p10158
aS'    std::vector<unsigned int> n_subdivisions;'
p10159
aS'    n_subdivisions.push_back(assemblies_x * rods_per_assembly_x);'
p10160
aS'    if (dim >= 2)'
p10161
aS'      n_subdivisions.push_back(assemblies_y * rods_per_assembly_y);'
p10162
aS'    if (dim >= 3)'
p10163
aS'      n_subdivisions.push_back(assemblies_z);'
p10164
aS'    Triangulation<dim> coarse_grid;'
p10165
aS'    GridGenerator::subdivided_hyper_rectangle('
p10166
aS'      coarse_grid, n_subdivisions, bottom_left, upper_right, true);'
p10167
aS'    const unsigned int n_assemblies = 4;'
p10168
aS'    const unsigned int assembly_materials'
p10169
aS'      [n_assemblies][rods_per_assembly_x][rods_per_assembly_y] = {'
p10170
aS'        {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10171
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10172
aS'         {1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1},'
p10173
aS'         {1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1},'
p10174
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10175
aS'         {1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1},'
p10176
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10177
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10178
aS'         {1, 1, 5, 1, 1, 5, 1, 1, 7, 1, 1, 5, 1, 1, 5, 1, 1},'
p10179
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10180
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10181
aS'         {1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1},'
p10182
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10183
aS'         {1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1},'
p10184
aS'         {1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1},'
p10185
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10186
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},'
p10187
aS'        {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10188
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10189
aS'         {1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1},'
p10190
aS'         {1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1},'
p10191
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10192
aS'         {1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1},'
p10193
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10194
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10195
aS'         {1, 1, 8, 1, 1, 8, 1, 1, 7, 1, 1, 8, 1, 1, 8, 1, 1},'
p10196
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10197
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10198
aS'         {1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1},'
p10199
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10200
aS'         {1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1},'
p10201
aS'         {1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1},'
p10202
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p10203
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},'
p10204
aS'        {{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2},'
p10205
aS'         {2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2},'
p10206
aS'         {2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2},'
p10207
aS'         {2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2},'
p10208
aS'         {2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2},'
p10209
aS'         {2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2},'
p10210
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p10211
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p10212
aS'         {2, 3, 5, 4, 4, 5, 4, 4, 7, 4, 4, 5, 4, 4, 5, 3, 2},'
p10213
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p10214
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p10215
aS'         {2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2},'
p10216
aS'         {2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2},'
p10217
aS'         {2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2},'
p10218
aS'         {2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2},'
p10219
aS'         {2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2},'
p10220
aS'         {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}},'
p10221
aS'        {{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10222
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10223
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10224
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10225
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10226
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10227
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10228
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10229
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10230
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10231
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10232
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10233
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10234
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10235
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10236
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p10237
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}}};'
p10238
aS'    const unsigned int core[assemblies_x][assemblies_y][assemblies_z] = {'
p10239
aS'      {{0}, {2}}, {{2}, {0}}};'
p10240
aS'    for (auto &cell : coarse_grid.active_cell_iterators())'
p10241
aS'      {'
p10242
aS'        const Point<dim> cell_center = cell->center();'
p10243
aS'        const unsigned int tmp_x = int(cell_center[0] / pin_pitch_x);'
p10244
aS'        const unsigned int ax    = tmp_x / rods_per_assembly_x;'
p10245
aS'        const unsigned int cx    = tmp_x - ax * rods_per_assembly_x;'
p10246
aS'        const unsigned     tmp_y = int(cell_center[1] / pin_pitch_y);'
p10247
aS'        const unsigned int ay    = tmp_y / rods_per_assembly_y;'
p10248
aS'        const unsigned int cy    = tmp_y - ay * rods_per_assembly_y;'
p10249
aS'        const unsigned int az ='
p10250
aS'          (dim == 2 ? 0 : int(cell_center[dim - 1] / assembly_height));'
p10251
aS'        Assert(ax < assemblies_x, ExcInternalError());'
p10252
aS'        Assert(ay < assemblies_y, ExcInternalError());'
p10253
aS'        Assert(az < assemblies_z, ExcInternalError());'
p10254
aS'        Assert(core[ax][ay][az] < n_assemblies, ExcInternalError());'
p10255
aS'        Assert(cx < rods_per_assembly_x, ExcInternalError());'
p10256
aS'        Assert(cy < rods_per_assembly_y, ExcInternalError());'
p10257
aS'        cell->set_material_id(assembly_materials[core[ax][ay][az]][cx][cy] - 1);'
p10258
aS'      }'
p10259
aS'    for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10260
aS'      energy_groups.emplace_back(std::make_unique<EnergyGroup<dim>>('
p10261
aS'        group, material_data, coarse_grid, fe));'
p10262
aS'    convergence_table_stream.open("convergence_table");'
p10263
aS'    convergence_table_stream.precision(12);'
p10264
aS'  }'
p10265
aS'  template <int dim>'
p10266
aS'  double NeutronDiffusionProblem<dim>::get_total_fission_source() const'
p10267
aS'  {'
p10268
aS'    std::vector<double>  fission_sources(parameters.n_groups);'
p10269
aS'    Threads::TaskGroup<> tasks;'
p10270
aS'    for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10271
aS'      tasks += Threads::new_task<>([&, group]() {'
p10272
aS'        fission_sources[group] = energy_groups[group]->get_fission_source();'
p10273
aS'      });'
p10274
aS'    tasks.join_all();'
p10275
aS'    return std::accumulate(fission_sources.begin(), fission_sources.end(), 0.0);'
p10276
aS'  }'
p10277
aS'  template <int dim>'
p10278
aS'  void NeutronDiffusionProblem<dim>::refine_grid()'
p10279
aS'  {'
p10280
aS'    std::vector<types::global_dof_index> n_cells(parameters.n_groups);'
p10281
aS'    for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10282
aS'      n_cells[group] = energy_groups[group]->n_active_cells();'
p10283
aS'    BlockVector<float> group_error_indicators(n_cells);'
p10284
aS'    {'
p10285
aS'      Threads::TaskGroup<> tasks;'
p10286
aS'      for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10287
aS'        tasks += Threads::new_task([&, group]() {'
p10288
aS'          energy_groups[group]->estimate_errors('
p10289
aS'            group_error_indicators.block(group));'
p10290
aS'        });'
p10291
aS'    }'
p10292
aS'    const float max_error         = group_error_indicators.linfty_norm();'
p10293
aS'    const float refine_threshold  = 0.3 * max_error;'
p10294
aS'    const float coarsen_threshold = 0.01 * max_error;'
p10295
aS'    {'
p10296
aS'      Threads::TaskGroup<void> tasks;'
p10297
aS'      for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10298
aS'        tasks += Threads::new_task([&, group]() {'
p10299
aS'          energy_groups[group]->refine_grid(group_error_indicators.block(group),'
p10300
aS'                                            refine_threshold,'
p10301
aS'                                            coarsen_threshold);'
p10302
aS'        });'
p10303
aS'    }'
p10304
aS'  }'
p10305
aS'  template <int dim>'
p10306
aS'  void NeutronDiffusionProblem<dim>::run()'
p10307
aS'  {'
p10308
aS'    boost::io::ios_flags_saver restore_flags(std::cout);'
p10309
aS'    std::cout << std::setprecision(12) << std::fixed;'
p10310
aS'    double k_eff_old = 0.0;'
p10311
aS'    for (unsigned int cycle = 0; cycle < parameters.n_refinement_cycles;'
p10312
aS'         ++cycle)'
p10313
aS'      {'
p10314
aS'        Timer timer;'
p10315
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p10316
aS'        if (cycle == 0)'
p10317
aS'          {'
p10318
aS'            initialize_problem();'
p10319
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10320
aS'              energy_groups[group]->setup_linear_system();'
p10321
aS'          }'
p10322
aS'        else'
p10323
aS'          {'
p10324
aS'            refine_grid();'
p10325
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10326
aS'              energy_groups[group]->solution *= k_eff;'
p10327
aS'          }'
p10328
aS'        std::cout << "   Numbers of active cells:       ";'
p10329
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10330
aS"          std::cout << energy_groups[group]->n_active_cells() << ' ';"
p10331
aS'        std::cout << std::endl;'
p10332
aS'        std::cout << "   Numbers of degrees of freedom: ";'
p10333
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10334
aS"          std::cout << energy_groups[group]->n_dofs() << ' ';"
p10335
aS'        std::cout << std::endl << std::endl;'
p10336
aS'        Threads::TaskGroup<> tasks;'
p10337
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10338
aS'          tasks += Threads::new_task('
p10339
aS'            [&, group]() { energy_groups[group]->assemble_system_matrix(); });'
p10340
aS'        tasks.join_all();'
p10341
aS'        double       error;'
p10342
aS'        unsigned int iteration = 1;'
p10343
aS'        do'
p10344
aS'          {'
p10345
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10346
aS'              {'
p10347
aS'                energy_groups[group]->assemble_ingroup_rhs('
p10348
aS'                  Functions::ZeroFunction<dim>());'
p10349
aS'                for (unsigned int bgroup = 0; bgroup < parameters.n_groups;'
p10350
aS'                     ++bgroup)'
p10351
aS'                  energy_groups[group]->assemble_cross_group_rhs('
p10352
aS'                    *energy_groups[bgroup]);'
p10353
aS'                energy_groups[group]->solve();'
p10354
aS'              }'
p10355
aS'            k_eff = get_total_fission_source();'
p10356
aS'            error = std::abs(k_eff - k_eff_old) / std::abs(k_eff);'
p10357
aS'            const double flux_ratio = energy_groups[0]->solution.linfty_norm() /'
p10358
aS'                                      energy_groups[1]->solution.linfty_norm();'
p10359
aS'            const double max_thermal = energy_groups[1]->solution.linfty_norm();'
p10360
aS'            std::cout << "Iter number:" << std::setw(2) << std::right'
p10361
aS'                      << iteration << " k_eff=" << k_eff'
p10362
aS'                      << " flux_ratio=" << flux_ratio'
p10363
aS'                      << " max_thermal=" << max_thermal << std::endl;'
p10364
aS'            k_eff_old = k_eff;'
p10365
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10366
aS'              {'
p10367
aS'                energy_groups[group]->solution_old ='
p10368
aS'                  energy_groups[group]->solution;'
p10369
aS'                energy_groups[group]->solution_old /= k_eff;'
p10370
aS'              }'
p10371
aS'            ++iteration;'
p10372
aS'          }'
p10373
aS'        while ((error > parameters.convergence_tolerance) && (iteration < 500));'
p10374
aS'        convergence_table_stream << cycle << " " << energy_groups[0]->n_dofs()'
p10375
aS'                                 << " " << energy_groups[1]->n_dofs() << " "'
p10376
aS'                                 << k_eff << " "'
p10377
aS'                                 << energy_groups[0]->solution.linfty_norm() /'
p10378
aS'                                      energy_groups[1]->solution.linfty_norm()'
p10379
aS"                                 << '\\n';"
p10380
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p10381
aS'          energy_groups[group]->output_results(cycle);'
p10382
aS'        std::cout << std::endl;'
p10383
aS'        std::cout << "   Cycle=" << cycle << ", n_dofs="'
p10384
aS'                  << energy_groups[0]->n_dofs() + energy_groups[1]->n_dofs()'
p10385
aS'                  << ",  k_eff=" << k_eff << ", time=" << timer.cpu_time()'
p10386
aS'                  << std::endl;'
p10387
aS'        std::cout << std::endl << std::endl;'
p10388
aS'      }'
p10389
aS'  }'
p10390
aS'} // namespace Step28'
p10391
aS'int main(int argc, char **argv)'
p10392
ag24
aS'  try'
p10393
aS'    {'
p10394
aS'      using namespace dealii;'
p10395
aS'      using namespace Step28;'
p10396
aS'      std::string filename;'
p10397
aS'      if (argc < 2)'
p10398
aS'        filename = "project.prm";'
p10399
aS'      else'
p10400
aS'        filename = argv[1];'
p10401
aS'      const unsigned int dim = 2;'
p10402
aS'      ParameterHandler parameter_handler;'
p10403
aS'      NeutronDiffusionProblem<dim>::Parameters parameters;'
p10404
aS'      parameters.declare_parameters(parameter_handler);'
p10405
aS'      parameter_handler.parse_input(filename);'
p10406
aS'      parameters.get_parameters(parameter_handler);'
p10407
aS'      NeutronDiffusionProblem<dim> neutron_diffusion_problem(parameters);'
p10408
aS'      neutron_diffusion_problem.run();'
p10409
aS'    }'
p10410
aS'  catch (std::exception &exc)'
p10411
aS'    {'
p10412
aS'      std::cerr << std::endl'
p10413
aS'                << std::endl'
p10414
aS'                << "----------------------------------------------------"'
p10415
aS'                << std::endl;'
p10416
aS'      std::cerr << "Exception on processing: " << std::endl'
p10417
aS'                << exc.what() << std::endl'
p10418
aS'                << "Aborting!" << std::endl'
p10419
aS'                << "----------------------------------------------------"'
p10420
aS'                << std::endl;'
p10421
aS'      return 1;'
p10422
aS'    }'
p10423
aS'  catch (...)'
p10424
aS'    {'
p10425
aS'      std::cerr << std::endl'
p10426
aS'                << std::endl'
p10427
aS'                << "----------------------------------------------------"'
p10428
aS'                << std::endl;'
p10429
aS'      std::cerr << "Unknown exception!" << std::endl'
p10430
aS'                << "Aborting!" << std::endl'
p10431
aS'                << "----------------------------------------------------"'
p10432
aS'                << std::endl;'
p10433
aS'      return 1;'
p10434
aS'    }'
p10435
aS'  return 0;'
p10436
ag32
aS'/* ---------------------------------------------------------------------'
p10437
aS' *'
p10438
aS' * Copyright (C) 2007 - 2021 by the deal.II authors'
p10439
aS' *'
p10440
aS' * This file is part of the deal.II library.'
p10441
aS' *'
p10442
aS' * The deal.II library is free software; you can use it, redistribute'
p10443
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p10444
aS' * Public License as published by the Free Software Foundation; either'
p10445
aS' * version 2.1 of the License, or (at your option) any later version.'
p10446
aS' * The full text of the license can be found in the file LICENSE.md at'
p10447
aS' * the top level directory of deal.II.'
p10448
aS' *'
p10449
aS' * ---------------------------------------------------------------------'
p10450
aS' *'
p10451
aS' * Author: Moritz Allmaras, Texas A&M University, 2007'
p10452
aS' */'
p10453
aS'#include <deal.II/base/quadrature_lib.h>'
p10454
aS'#include <deal.II/base/function.h>'
p10455
aS'#include <deal.II/base/logstream.h>'
p10456
aS'#include <deal.II/lac/vector.h>'
p10457
aS'#include <deal.II/lac/full_matrix.h>'
p10458
aS'#include <deal.II/lac/sparse_matrix.h>'
p10459
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p10460
aS'#include <deal.II/grid/tria.h>'
p10461
aS'#include <deal.II/grid/grid_generator.h>'
p10462
aS'#include <deal.II/grid/manifold_lib.h>'
p10463
aS'#include <deal.II/dofs/dof_handler.h>'
p10464
aS'#include <deal.II/dofs/dof_tools.h>'
p10465
aS'#include <deal.II/fe/fe_q.h>'
p10466
aS'#include <deal.II/fe/fe_values.h>'
p10467
aS'#include <deal.II/numerics/matrix_tools.h>'
p10468
aS'#include <deal.II/numerics/data_out.h>'
p10469
aS'#include <deal.II/numerics/vector_tools.h>'
p10470
aS'#include <iostream>'
p10471
aS'#include <fstream>'
p10472
aS'#include <deal.II/base/parameter_handler.h>'
p10473
aS'#include <deal.II/lac/sparse_direct.h>'
p10474
aS'#include <deal.II/fe/fe_system.h>'
p10475
aS'#include <deal.II/base/timer.h>'
p10476
aS'namespace Step29'
p10477
ag24
aS'  using namespace dealii;'
p10478
aS'  template <int dim>'
p10479
aS'  class DirichletBoundaryValues : public Function<dim>'
p10480
aS'  {'
p10481
aS'  public:'
p10482
aS'    DirichletBoundaryValues()'
p10483
aS'      : Function<dim>(2)'
p10484
aS'    {}'
p10485
aS'    virtual void vector_value(const Point<dim> & /*p*/,'
p10486
aS'                              Vector<double> &values) const override'
p10487
aS'    {'
p10488
aS'      Assert(values.size() == 2, ExcDimensionMismatch(values.size(), 2));'
p10489
aS'      values(0) = 1;'
p10490
aS'      values(1) = 0;'
p10491
aS'    }'
p10492
aS'    virtual void'
p10493
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p10494
aS'                      std::vector<Vector<double>> &  value_list) const override'
p10495
aS'    {'
p10496
aS'      Assert(value_list.size() == points.size(),'
p10497
aS'             ExcDimensionMismatch(value_list.size(), points.size()));'
p10498
aS'      for (unsigned int p = 0; p < points.size(); ++p)'
p10499
aS'        DirichletBoundaryValues<dim>::vector_value(points[p], value_list[p]);'
p10500
aS'    }'
p10501
aS'  };'
p10502
aS'  class ParameterReader : public Subscriptor'
p10503
aS'  {'
p10504
aS'  public:'
p10505
aS'    ParameterReader(ParameterHandler &);'
p10506
aS'    void read_parameters(const std::string &);'
p10507
aS'  private:'
p10508
aS'    void              declare_parameters();'
p10509
aS'    ParameterHandler &prm;'
p10510
aS'  };'
p10511
aS'  ParameterReader::ParameterReader(ParameterHandler &paramhandler)'
p10512
aS'    : prm(paramhandler)'
p10513
aS'  {}'
p10514
aS'  void ParameterReader::declare_parameters()'
p10515
aS'  {'
p10516
aS'    prm.enter_subsection("Mesh & geometry parameters");'
p10517
aS'    {'
p10518
aS'      prm.declare_entry("Number of refinements",'
p10519
aS'                        "6",'
p10520
aS'                        Patterns::Integer(0),'
p10521
aS'                        "Number of global mesh refinement steps "'
p10522
aS'                        "applied to initial coarse grid");'
p10523
aS'      prm.declare_entry("Focal distance",'
p10524
aS'                        "0.3",'
p10525
aS'                        Patterns::Double(0),'
p10526
aS'                        "Distance of the focal point of the lens "'
p10527
aS'                        "to the x-axis");'
p10528
aS'    }'
p10529
aS'    prm.leave_subsection();'
p10530
aS'    prm.enter_subsection("Physical constants");'
p10531
aS'    {'
p10532
aS'      prm.declare_entry("c", "1.5e5", Patterns::Double(0), "Wave speed");'
p10533
aS'      prm.declare_entry("omega", "5.0e7", Patterns::Double(0), "Frequency");'
p10534
aS'    }'
p10535
aS'    prm.leave_subsection();'
p10536
aS'    prm.enter_subsection("Output parameters");'
p10537
aS'    {'
p10538
aS'      prm.declare_entry("Output filename",'
p10539
aS'                        "solution",'
p10540
aS'                        Patterns::Anything(),'
p10541
aS'                        "Name of the output file (without extension)");'
p10542
aS'      DataOutInterface<1>::declare_parameters(prm);'
p10543
aS'    }'
p10544
aS'    prm.leave_subsection();'
p10545
aS'  }'
p10546
aS'  void ParameterReader::read_parameters(const std::string &parameter_file)'
p10547
aS'  {'
p10548
aS'    declare_parameters();'
p10549
aS'    prm.parse_input(parameter_file);'
p10550
aS'  }'
p10551
aS'  template <int dim>'
p10552
aS'  class ComputeIntensity : public DataPostprocessorScalar<dim>'
p10553
aS'  {'
p10554
aS'  public:'
p10555
aS'    ComputeIntensity();'
p10556
aS'    virtual void evaluate_vector_field('
p10557
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p10558
aS'      std::vector<Vector<double>> &computed_quantities) const override;'
p10559
aS'  };'
p10560
aS'  template <int dim>'
p10561
aS'  ComputeIntensity<dim>::ComputeIntensity()'
p10562
aS'    : DataPostprocessorScalar<dim>("Intensity", update_values)'
p10563
aS'  {}'
p10564
aS'  template <int dim>'
p10565
aS'  void ComputeIntensity<dim>::evaluate_vector_field('
p10566
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p10567
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p10568
aS'  {'
p10569
aS'    Assert(computed_quantities.size() == inputs.solution_values.size(),'
p10570
aS'           ExcDimensionMismatch(computed_quantities.size(),'
p10571
aS'                                inputs.solution_values.size()));'
p10572
aS'    for (unsigned int i = 0; i < computed_quantities.size(); i++)'
p10573
aS'      {'
p10574
aS'        Assert(computed_quantities[i].size() == 1,'
p10575
aS'               ExcDimensionMismatch(computed_quantities[i].size(), 1));'
p10576
aS'        Assert(inputs.solution_values[i].size() == 2,'
p10577
aS'               ExcDimensionMismatch(inputs.solution_values[i].size(), 2));'
p10578
aS'        const std::complex<double> u(inputs.solution_values[i](0),'
p10579
aS'                                     inputs.solution_values[i](1));'
p10580
aS'        computed_quantities[i](0) = std::abs(u);'
p10581
aS'      }'
p10582
aS'  }'
p10583
aS'  template <int dim>'
p10584
aS'  class UltrasoundProblem'
p10585
aS'  {'
p10586
aS'  public:'
p10587
aS'    UltrasoundProblem(ParameterHandler &);'
p10588
aS'    void run();'
p10589
aS'  private:'
p10590
aS'    void make_grid();'
p10591
aS'    void setup_system();'
p10592
aS'    void assemble_system();'
p10593
aS'    void solve();'
p10594
aS'    void output_results() const;'
p10595
aS'    ParameterHandler &prm;'
p10596
aS'    Triangulation<dim> triangulation;'
p10597
aS'    DoFHandler<dim>    dof_handler;'
p10598
aS'    FESystem<dim>      fe;'
p10599
aS'    SparsityPattern      sparsity_pattern;'
p10600
aS'    SparseMatrix<double> system_matrix;'
p10601
aS'    Vector<double>       solution, system_rhs;'
p10602
aS'  };'
p10603
aS'  template <int dim>'
p10604
aS'  UltrasoundProblem<dim>::UltrasoundProblem(ParameterHandler &param)'
p10605
aS'    : prm(param)'
p10606
aS'    , dof_handler(triangulation)'
p10607
aS'    , fe(FE_Q<dim>(1), 2)'
p10608
aS'  {}'
p10609
aS'  template <int dim>'
p10610
aS'  void UltrasoundProblem<dim>::make_grid()'
p10611
aS'  {'
p10612
aS'    std::cout << "Generating grid... ";'
p10613
aS'    Timer timer;'
p10614
aS'    prm.enter_subsection("Mesh & geometry parameters");'
p10615
aS'    const double       focal_distance = prm.get_double("Focal distance");'
p10616
aS'    const unsigned int n_refinements = prm.get_integer("Number of refinements");'
p10617
aS'    prm.leave_subsection();'
p10618
aS'    const Point<dim> transducer ='
p10619
aS'      (dim == 2) ? Point<dim>(0.5, 0.0) : Point<dim>(0.5, 0.5, 0.0);'
p10620
aS'    const Point<dim> focal_point = (dim == 2) ?'
p10621
aS'                                     Point<dim>(0.5, focal_distance) :'
p10622
aS'                                     Point<dim>(0.5, 0.5, focal_distance);'
p10623
aS'    GridGenerator::subdivided_hyper_cube(triangulation, 5, 0, 1);'
p10624
aS'    for (auto &cell : triangulation.cell_iterators())'
p10625
aS'      for (const auto &face : cell->face_iterators())'
p10626
aS'        if (face->at_boundary() &&'
p10627
aS'            ((face->center() - transducer).norm_square() < 0.01))'
p10628
aS'          {'
p10629
aS'            face->set_boundary_id(1);'
p10630
aS'            face->set_manifold_id(1);'
p10631
aS'          }'
p10632
aS'    triangulation.set_manifold(1, SphericalManifold<dim>(focal_point));'
p10633
aS'    triangulation.refine_global(n_refinements);'
p10634
aS'    timer.stop();'
p10635
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10636
aS'    std::cout << "  Number of active cells:  " << triangulation.n_active_cells()'
p10637
aS'              << std::endl;'
p10638
aS'  }'
p10639
aS'  template <int dim>'
p10640
aS'  void UltrasoundProblem<dim>::setup_system()'
p10641
aS'  {'
p10642
aS'    std::cout << "Setting up system... ";'
p10643
aS'    Timer timer;'
p10644
aS'    dof_handler.distribute_dofs(fe);'
p10645
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p10646
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p10647
aS'    sparsity_pattern.copy_from(dsp);'
p10648
aS'    system_matrix.reinit(sparsity_pattern);'
p10649
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p10650
aS'    solution.reinit(dof_handler.n_dofs());'
p10651
aS'    timer.stop();'
p10652
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10653
aS'    std::cout << "  Number of degrees of freedom: " << dof_handler.n_dofs()'
p10654
aS'              << std::endl;'
p10655
aS'  }'
p10656
aS'  template <int dim>'
p10657
aS'  void UltrasoundProblem<dim>::assemble_system()'
p10658
aS'  {'
p10659
aS'    std::cout << "Assembling system matrix... ";'
p10660
aS'    Timer timer;'
p10661
aS'    prm.enter_subsection("Physical constants");'
p10662
aS'    const double omega = prm.get_double("omega"), c = prm.get_double("c");'
p10663
aS'    prm.leave_subsection();'
p10664
aS'    QGauss<dim>     quadrature_formula(fe.degree + 1);'
p10665
aS'    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p10666
aS'    const unsigned int n_q_points      = quadrature_formula.size(),'
p10667
aS'                       n_face_q_points = face_quadrature_formula.size(),'
p10668
aS'                       dofs_per_cell   = fe.n_dofs_per_cell();'
p10669
aS'    FEValues<dim> fe_values(fe,'
p10670
aS'                            quadrature_formula,'
p10671
aS'                            update_values | update_gradients |'
p10672
aS'                              update_JxW_values);'
p10673
aS'    FEFaceValues<dim> fe_face_values(fe,'
p10674
aS'                                     face_quadrature_formula,'
p10675
aS'                                     update_values | update_JxW_values);'
p10676
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p10677
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p10678
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p10679
aS'      {'
p10680
aS'        cell_matrix = 0;'
p10681
aS'        fe_values.reinit(cell);'
p10682
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10683
aS'          {'
p10684
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10685
aS'              {'
p10686
aS'                if (fe.system_to_component_index(i).first =='
p10687
aS'                    fe.system_to_component_index(j).first)'
p10688
aS'                  {'
p10689
aS'                    for (unsigned int q_point = 0; q_point < n_q_points;'
p10690
aS'                         ++q_point)'
p10691
aS'                      cell_matrix(i, j) +='
p10692
aS'                        (((fe_values.shape_value(i, q_point) *'
p10693
aS'                           fe_values.shape_value(j, q_point)) *'
p10694
aS'                            (-omega * omega) +'
p10695
aS'                          (fe_values.shape_grad(i, q_point) *'
p10696
aS'                           fe_values.shape_grad(j, q_point)) *'
p10697
aS'                            c * c) *'
p10698
aS'                         fe_values.JxW(q_point));'
p10699
aS'                  }'
p10700
aS'              }'
p10701
aS'          }'
p10702
aS'        for (const auto face_no : cell->face_indices())'
p10703
aS'          if (cell->face(face_no)->at_boundary() &&'
p10704
aS'              (cell->face(face_no)->boundary_id() == 0))'
p10705
aS'            {'
p10706
aS'              fe_face_values.reinit(cell, face_no);'
p10707
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10708
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10709
aS'                  if ((fe.system_to_component_index(i).first !='
p10710
aS'                       fe.system_to_component_index(j).first) &&'
p10711
aS'                      fe.has_support_on_face(i, face_no) &&'
p10712
aS'                      fe.has_support_on_face(j, face_no))'
p10713
aS'                    for (unsigned int q_point = 0; q_point < n_face_q_points;'
p10714
aS'                         ++q_point)'
p10715
aS'                      cell_matrix(i, j) +='
p10716
aS'                        ((fe.system_to_component_index(i).first == 0) ? -1 :'
p10717
aS'                                                                        1) *'
p10718
aS'                        fe_face_values.shape_value(i, q_point) *'
p10719
aS'                        fe_face_values.shape_value(j, q_point) * c * omega *'
p10720
aS'                        fe_face_values.JxW(q_point);'
p10721
aS'            }'
p10722
aS'        cell->get_dof_indices(local_dof_indices);'
p10723
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10724
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10725
aS'            system_matrix.add(local_dof_indices[i],'
p10726
aS'                              local_dof_indices[j],'
p10727
aS'                              cell_matrix(i, j));'
p10728
aS'      }'
p10729
aS'    std::map<types::global_dof_index, double> boundary_values;'
p10730
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p10731
aS'                                             1,'
p10732
aS'                                             DirichletBoundaryValues<dim>(),'
p10733
aS'                                             boundary_values);'
p10734
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p10735
aS'                                       system_matrix,'
p10736
aS'                                       solution,'
p10737
aS'                                       system_rhs);'
p10738
aS'    timer.stop();'
p10739
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10740
aS'  }'
p10741
aS'  template <int dim>'
p10742
aS'  void UltrasoundProblem<dim>::solve()'
p10743
aS'  {'
p10744
aS'    std::cout << "Solving linear system... ";'
p10745
aS'    Timer timer;'
p10746
aS'    SparseDirectUMFPACK A_direct;'
p10747
aS'    A_direct.initialize(system_matrix);'
p10748
aS'    A_direct.vmult(solution, system_rhs);'
p10749
aS'    timer.stop();'
p10750
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10751
aS'  }'
p10752
aS'  template <int dim>'
p10753
aS'  void UltrasoundProblem<dim>::output_results() const'
p10754
aS'  {'
p10755
aS'    std::cout << "Generating output... ";'
p10756
aS'    Timer timer;'
p10757
aS'    ComputeIntensity<dim> intensities;'
p10758
aS'    DataOut<dim>          data_out;'
p10759
aS'    data_out.attach_dof_handler(dof_handler);'
p10760
aS'    prm.enter_subsection("Output parameters");'
p10761
aS'    const std::string output_filename = prm.get("Output filename");'
p10762
aS'    data_out.parse_parameters(prm);'
p10763
aS'    prm.leave_subsection();'
p10764
aS'    const std::string filename = output_filename + data_out.default_suffix();'
p10765
aS'    std::ofstream output(filename);'
p10766
aS'    std::vector<std::string> solution_names;'
p10767
aS'    solution_names.emplace_back("Re_u");'
p10768
aS'    solution_names.emplace_back("Im_u");'
p10769
aS'    data_out.add_data_vector(solution, solution_names);'
p10770
aS'    data_out.add_data_vector(solution, intensities);'
p10771
aS'    data_out.build_patches();'
p10772
aS'    data_out.write(output);'
p10773
aS'    timer.stop();'
p10774
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10775
aS'  }'
p10776
aS'  template <int dim>'
p10777
aS'  void UltrasoundProblem<dim>::run()'
p10778
aS'  {'
p10779
aS'    make_grid();'
p10780
aS'    setup_system();'
p10781
aS'    assemble_system();'
p10782
aS'    solve();'
p10783
aS'    output_results();'
p10784
aS'  }'
p10785
aS'} // namespace Step29'
p10786
aS'int main()'
p10787
ag24
aS'  try'
p10788
aS'    {'
p10789
aS'      using namespace dealii;'
p10790
aS'      using namespace Step29;'
p10791
aS'      ParameterHandler prm;'
p10792
aS'      ParameterReader  param(prm);'
p10793
aS'      param.read_parameters("step-29.prm");'
p10794
aS'      UltrasoundProblem<2> ultrasound_problem(prm);'
p10795
aS'      ultrasound_problem.run();'
p10796
aS'    }'
p10797
aS'  catch (std::exception &exc)'
p10798
aS'    {'
p10799
aS'      std::cerr << std::endl'
p10800
aS'                << std::endl'
p10801
aS'                << "----------------------------------------------------"'
p10802
aS'                << std::endl;'
p10803
aS'      std::cerr << "Exception on processing: " << std::endl'
p10804
aS'                << exc.what() << std::endl'
p10805
aS'                << "Aborting!" << std::endl'
p10806
aS'                << "----------------------------------------------------"'
p10807
aS'                << std::endl;'
p10808
aS'      return 1;'
p10809
aS'    }'
p10810
aS'  catch (...)'
p10811
aS'    {'
p10812
aS'      std::cerr << std::endl'
p10813
aS'                << std::endl'
p10814
aS'                << "----------------------------------------------------"'
p10815
aS'                << std::endl;'
p10816
aS'      std::cerr << "Unknown exception!" << std::endl'
p10817
aS'                << "Aborting!" << std::endl'
p10818
aS'                << "----------------------------------------------------"'
p10819
aS'                << std::endl;'
p10820
aS'      return 1;'
p10821
aS'    }'
p10822
aS'  return 0;'
p10823
ag32
aS'/* ---------------------------------------------------------------------'
p10824
aS' *'
p10825
aS' * Copyright (C) 1999 - 2021 by the deal.II authors'
p10826
aS' *'
p10827
aS' * This file is part of the deal.II library.'
p10828
aS' *'
p10829
aS' * The deal.II library is free software; you can use it, redistribute'
p10830
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p10831
aS' * Public License as published by the Free Software Foundation; either'
p10832
aS' * version 2.1 of the License, or (at your option) any later version.'
p10833
aS' * The full text of the license can be found in the file LICENSE.md at'
p10834
aS' * the top level directory of deal.II.'
p10835
aS' *'
p10836
aS' * ---------------------------------------------------------------------'
p10837
aS' *'
p10838
aS' * Authors: Wolfgang Bangerth, 1999,'
p10839
aS' *          Guido Kanschat, 2011'
p10840
aS' */'
p10841
aS'#include <deal.II/grid/tria.h>'
p10842
aS'#include <deal.II/dofs/dof_handler.h>'
p10843
aS'#include <deal.II/grid/grid_generator.h>'
p10844
aS'#include <deal.II/fe/fe_q.h>'
p10845
aS'#include <deal.II/dofs/dof_tools.h>'
p10846
aS'#include <deal.II/fe/fe_values.h>'
p10847
aS'#include <deal.II/base/quadrature_lib.h>'
p10848
aS'#include <deal.II/base/function.h>'
p10849
aS'#include <deal.II/numerics/vector_tools.h>'
p10850
aS'#include <deal.II/numerics/matrix_tools.h>'
p10851
aS'#include <deal.II/lac/vector.h>'
p10852
aS'#include <deal.II/lac/full_matrix.h>'
p10853
aS'#include <deal.II/lac/sparse_matrix.h>'
p10854
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p10855
aS'#include <deal.II/lac/solver_cg.h>'
p10856
aS'#include <deal.II/lac/precondition.h>'
p10857
aS'#include <deal.II/numerics/data_out.h>'
p10858
aS'#include <fstream>'
p10859
aS'#include <iostream>'
p10860
aS'using namespace dealii;'
p10861
aS'class Step3'
p10862
ag24
aS'public:'
p10863
aS'  Step3();'
p10864
aS'  void run();'
p10865
aS'private:'
p10866
aS'  void make_grid();'
p10867
aS'  void setup_system();'
p10868
aS'  void assemble_system();'
p10869
aS'  void solve();'
p10870
aS'  void output_results() const;'
p10871
aS'  Triangulation<2> triangulation;'
p10872
aS'  FE_Q<2>          fe;'
p10873
aS'  DoFHandler<2>    dof_handler;'
p10874
aS'  SparsityPattern      sparsity_pattern;'
p10875
aS'  SparseMatrix<double> system_matrix;'
p10876
aS'  Vector<double> solution;'
p10877
aS'  Vector<double> system_rhs;'
p10878
aS'};'
p10879
aS'Step3::Step3()'
p10880
aS'  : fe(1)'
p10881
aS'  , dof_handler(triangulation)'
p10882
aS'{}'
p10883
aS'void Step3::make_grid()'
p10884
ag24
aS'  GridGenerator::hyper_cube(triangulation, -1, 1);'
p10885
aS'  triangulation.refine_global(5);'
p10886
aS'  std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p10887
aS'            << std::endl;'
p10888
ag32
aS'void Step3::setup_system()'
p10889
ag24
aS'  dof_handler.distribute_dofs(fe);'
p10890
aS'  std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p10891
aS'            << std::endl;'
p10892
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p10893
aS'  DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p10894
aS'  sparsity_pattern.copy_from(dsp);'
p10895
aS'  system_matrix.reinit(sparsity_pattern);'
p10896
aS'  solution.reinit(dof_handler.n_dofs());'
p10897
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p10898
ag32
aS'void Step3::assemble_system()'
p10899
ag24
aS'  QGauss<2> quadrature_formula(fe.degree + 1);'
p10900
aS'  FEValues<2> fe_values(fe,'
p10901
aS'                        quadrature_formula,'
p10902
aS'                        update_values | update_gradients | update_JxW_values);'
p10903
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p10904
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p10905
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p10906
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p10907
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p10908
aS'    {'
p10909
aS'      fe_values.reinit(cell);'
p10910
aS'      cell_matrix = 0;'
p10911
aS'      cell_rhs    = 0;'
p10912
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p10913
aS'        {'
p10914
aS'          for (const unsigned int i : fe_values.dof_indices())'
p10915
aS'            for (const unsigned int j : fe_values.dof_indices())'
p10916
aS'              cell_matrix(i, j) +='
p10917
aS'                (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p10918
aS'                 fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p10919
aS'                 fe_values.JxW(q_index));           // dx'
p10920
aS'          for (const unsigned int i : fe_values.dof_indices())'
p10921
aS'            cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p10922
aS'                            1. *                                // f(x_q)'
p10923
aS'                            fe_values.JxW(q_index));            // dx'
p10924
aS'        }'
p10925
aS'      cell->get_dof_indices(local_dof_indices);'
p10926
aS'      for (const unsigned int i : fe_values.dof_indices())'
p10927
aS'        for (const unsigned int j : fe_values.dof_indices())'
p10928
aS'          system_matrix.add(local_dof_indices[i],'
p10929
aS'                            local_dof_indices[j],'
p10930
aS'                            cell_matrix(i, j));'
p10931
aS'      for (const unsigned int i : fe_values.dof_indices())'
p10932
aS'        system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p10933
aS'    }'
p10934
aS'  std::map<types::global_dof_index, double> boundary_values;'
p10935
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p10936
aS'                                           0,'
p10937
aS'                                           Functions::ZeroFunction<2>(),'
p10938
aS'                                           boundary_values);'
p10939
aS'  MatrixTools::apply_boundary_values(boundary_values,'
p10940
aS'                                     system_matrix,'
p10941
aS'                                     solution,'
p10942
aS'                                     system_rhs);'
p10943
ag32
aS'void Step3::solve()'
p10944
ag24
aS'  SolverControl solver_control(1000, 1e-12);'
p10945
aS'  SolverCG<Vector<double>> solver(solver_control);'
p10946
aS'  solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p10947
ag32
aS'void Step3::output_results() const'
p10948
ag24
aS'  DataOut<2> data_out;'
p10949
aS'  data_out.attach_dof_handler(dof_handler);'
p10950
aS'  data_out.add_data_vector(solution, "solution");'
p10951
aS'  data_out.build_patches();'
p10952
aS'  std::ofstream output("solution.vtk");'
p10953
aS'  data_out.write_vtk(output);'
p10954
ag32
aS'void Step3::run()'
p10955
ag24
aS'  make_grid();'
p10956
aS'  setup_system();'
p10957
aS'  assemble_system();'
p10958
aS'  solve();'
p10959
aS'  output_results();'
p10960
ag32
aS'int main()'
p10961
ag24
aS'  deallog.depth_console(2);'
p10962
aS'  Step3 laplace_problem;'
p10963
aS'  laplace_problem.run();'
p10964
aS'  return 0;'
p10965
ag32
aS'/* ---------------------------------------------------------------------'
p10966
aS' *'
p10967
aS' * Copyright (C) 2007 - 2021 by the deal.II authors'
p10968
aS' *'
p10969
aS' * This file is part of the deal.II library.'
p10970
aS' *'
p10971
aS' * The deal.II library is free software; you can use it, redistribute'
p10972
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p10973
aS' * Public License as published by the Free Software Foundation; either'
p10974
aS' * version 2.1 of the License, or (at your option) any later version.'
p10975
aS' * The full text of the license can be found in the file LICENSE.md at'
p10976
aS' * the top level directory of deal.II.'
p10977
aS' *'
p10978
aS' * ---------------------------------------------------------------------'
p10979
aS' *'
p10980
aS' * Author: Tobias Leicht, 2007'
p10981
aS' */'
p10982
aS'#include <deal.II/base/function.h>'
p10983
aS'#include <deal.II/base/quadrature_lib.h>'
p10984
aS'#include <deal.II/base/timer.h>'
p10985
aS'#include <deal.II/lac/precondition_block.h>'
p10986
aS'#include <deal.II/lac/solver_richardson.h>'
p10987
aS'#include <deal.II/lac/sparse_matrix.h>'
p10988
aS'#include <deal.II/lac/vector.h>'
p10989
aS'#include <deal.II/grid/tria.h>'
p10990
aS'#include <deal.II/grid/grid_generator.h>'
p10991
aS'#include <deal.II/grid/grid_out.h>'
p10992
aS'#include <deal.II/grid/grid_refinement.h>'
p10993
aS'#include <deal.II/dofs/dof_handler.h>'
p10994
aS'#include <deal.II/dofs/dof_tools.h>'
p10995
aS'#include <deal.II/fe/fe_values.h>'
p10996
aS'#include <deal.II/fe/mapping_q1.h>'
p10997
aS'#include <deal.II/fe/fe_dgq.h>'
p10998
aS'#include <deal.II/numerics/data_out.h>'
p10999
aS'#include <deal.II/numerics/derivative_approximation.h>'
p11000
aS'#include <array>'
p11001
aS'#include <iostream>'
p11002
aS'#include <fstream>'
p11003
aS'namespace Step30'
p11004
ag24
aS'  using namespace dealii;'
p11005
aS'  template <int dim>'
p11006
aS'  class RHS : public Function<dim>'
p11007
aS'  {'
p11008
aS'  public:'
p11009
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p11010
aS'                            std::vector<double> &          values,'
p11011
aS'                            const unsigned int /*component*/ = 0) const override'
p11012
aS'    {'
p11013
aS'      (void)points;'
p11014
aS'      Assert(values.size() == points.size(),'
p11015
aS'             ExcDimensionMismatch(values.size(), points.size()));'
p11016
aS'      std::fill(values.begin(), values.end(), 0.);'
p11017
aS'    }'
p11018
aS'  };'
p11019
aS'  template <int dim>'
p11020
aS'  class BoundaryValues : public Function<dim>'
p11021
aS'  {'
p11022
aS'  public:'
p11023
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p11024
aS'                            std::vector<double> &          values,'
p11025
aS'                            const unsigned int /*component*/ = 0) const override'
p11026
aS'    {'
p11027
aS'      Assert(values.size() == points.size(),'
p11028
aS'             ExcDimensionMismatch(values.size(), points.size()));'
p11029
aS'      for (unsigned int i = 0; i < values.size(); ++i)'
p11030
aS'        {'
p11031
aS'          if (points[i](0) < 0.5)'
p11032
aS'            values[i] = 1.;'
p11033
aS'          else'
p11034
aS'            values[i] = 0.;'
p11035
aS'        }'
p11036
aS'    }'
p11037
aS'  };'
p11038
aS'  template <int dim>'
p11039
aS'  class Beta'
p11040
aS'  {'
p11041
aS'  public:'
p11042
aS'    void value_list(const std::vector<Point<dim>> &points,'
p11043
aS'                    std::vector<Point<dim>> &      values) const'
p11044
aS'    {'
p11045
aS'      Assert(values.size() == points.size(),'
p11046
aS'             ExcDimensionMismatch(values.size(), points.size()));'
p11047
aS'      for (unsigned int i = 0; i < points.size(); ++i)'
p11048
aS'        {'
p11049
aS'          if (points[i](0) > 0)'
p11050
aS'            {'
p11051
aS'              values[i](0) = -points[i](1);'
p11052
aS'              values[i](1) = points[i](0);'
p11053
aS'            }'
p11054
aS'          else'
p11055
aS'            {'
p11056
aS'              values[i]    = Point<dim>();'
p11057
aS'              values[i](0) = -points[i](1);'
p11058
aS'            }'
p11059
aS'        }'
p11060
aS'    }'
p11061
aS'  };'
p11062
aS'  template <int dim>'
p11063
aS'  class DGTransportEquation'
p11064
aS'  {'
p11065
aS'  public:'
p11066
aS'    DGTransportEquation();'
p11067
aS'    void assemble_cell_term(const FEValues<dim> &fe_v,'
p11068
aS'                            FullMatrix<double> & ui_vi_matrix,'
p11069
aS'                            Vector<double> &     cell_vector) const;'
p11070
aS'    void assemble_boundary_term(const FEFaceValues<dim> &fe_v,'
p11071
aS'                                FullMatrix<double> &     ui_vi_matrix,'
p11072
aS'                                Vector<double> &         cell_vector) const;'
p11073
aS'    void assemble_face_term(const FEFaceValuesBase<dim> &fe_v,'
p11074
aS'                            const FEFaceValuesBase<dim> &fe_v_neighbor,'
p11075
aS'                            FullMatrix<double> &         ui_vi_matrix,'
p11076
aS'                            FullMatrix<double> &         ue_vi_matrix,'
p11077
aS'                            FullMatrix<double> &         ui_ve_matrix,'
p11078
aS'                            FullMatrix<double> &         ue_ve_matrix) const;'
p11079
aS'  private:'
p11080
aS'    const Beta<dim>           beta_function;'
p11081
aS'    const RHS<dim>            rhs_function;'
p11082
aS'    const BoundaryValues<dim> boundary_function;'
p11083
aS'  };'
p11084
aS'  template <int dim>'
p11085
aS'  DGTransportEquation<dim>::DGTransportEquation()'
p11086
aS'    : beta_function()'
p11087
aS'    , rhs_function()'
p11088
aS'    , boundary_function()'
p11089
aS'  {}'
p11090
aS'  template <int dim>'
p11091
aS'  void DGTransportEquation<dim>::assemble_cell_term('
p11092
aS'    const FEValues<dim> &fe_v,'
p11093
aS'    FullMatrix<double> & ui_vi_matrix,'
p11094
aS'    Vector<double> &     cell_vector) const'
p11095
aS'  {'
p11096
aS'    const std::vector<double> &JxW = fe_v.get_JxW_values();'
p11097
aS'    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);'
p11098
aS'    std::vector<double>     rhs(fe_v.n_quadrature_points);'
p11099
aS'    beta_function.value_list(fe_v.get_quadrature_points(), beta);'
p11100
aS'    rhs_function.value_list(fe_v.get_quadrature_points(), rhs);'
p11101
aS'    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p11102
aS'      for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p11103
aS'        {'
p11104
aS'          for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p11105
aS'            ui_vi_matrix(i, j) -= beta[point] * fe_v.shape_grad(i, point) *'
p11106
aS'                                  fe_v.shape_value(j, point) * JxW[point];'
p11107
aS'          cell_vector(i) +='
p11108
aS'            rhs[point] * fe_v.shape_value(i, point) * JxW[point];'
p11109
aS'        }'
p11110
aS'  }'
p11111
aS'  template <int dim>'
p11112
aS'  void DGTransportEquation<dim>::assemble_boundary_term('
p11113
aS'    const FEFaceValues<dim> &fe_v,'
p11114
aS'    FullMatrix<double> &     ui_vi_matrix,'
p11115
aS'    Vector<double> &         cell_vector) const'
p11116
aS'  {'
p11117
aS'    const std::vector<double> &        JxW     = fe_v.get_JxW_values();'
p11118
aS'    const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p11119
aS'    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);'
p11120
aS'    std::vector<double>     g(fe_v.n_quadrature_points);'
p11121
aS'    beta_function.value_list(fe_v.get_quadrature_points(), beta);'
p11122
aS'    boundary_function.value_list(fe_v.get_quadrature_points(), g);'
p11123
aS'    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p11124
aS'      {'
p11125
aS'        const double beta_n = beta[point] * normals[point];'
p11126
aS'        if (beta_n > 0)'
p11127
aS'          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p11128
aS'            for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p11129
aS'              ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *'
p11130
aS'                                    fe_v.shape_value(i, point) * JxW[point];'
p11131
aS'        else'
p11132
aS'          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p11133
aS'            cell_vector(i) -='
p11134
aS'              beta_n * g[point] * fe_v.shape_value(i, point) * JxW[point];'
p11135
aS'      }'
p11136
aS'  }'
p11137
aS'  template <int dim>'
p11138
aS'  void DGTransportEquation<dim>::assemble_face_term('
p11139
aS'    const FEFaceValuesBase<dim> &fe_v,'
p11140
aS'    const FEFaceValuesBase<dim> &fe_v_neighbor,'
p11141
aS'    FullMatrix<double> &         ui_vi_matrix,'
p11142
aS'    FullMatrix<double> &         ue_vi_matrix,'
p11143
aS'    FullMatrix<double> &         ui_ve_matrix,'
p11144
aS'    FullMatrix<double> &         ue_ve_matrix) const'
p11145
aS'  {'
p11146
aS'    const std::vector<double> &        JxW     = fe_v.get_JxW_values();'
p11147
aS'    const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p11148
aS'    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);'
p11149
aS'    beta_function.value_list(fe_v.get_quadrature_points(), beta);'
p11150
aS'    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p11151
aS'      {'
p11152
aS'        const double beta_n = beta[point] * normals[point];'
p11153
aS'        if (beta_n > 0)'
p11154
aS'          {'
p11155
aS'            for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p11156
aS'              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p11157
aS'                ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *'
p11158
aS'                                      fe_v.shape_value(i, point) * JxW[point];'
p11159
aS'            for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)'
p11160
aS'              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p11161
aS'                ui_ve_matrix(k, j) -= beta_n * fe_v.shape_value(j, point) *'
p11162
aS'                                      fe_v_neighbor.shape_value(k, point) *'
p11163
aS'                                      JxW[point];'
p11164
aS'          }'
p11165
aS'        else'
p11166
aS'          {'
p11167
aS'            for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p11168
aS'              for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)'
p11169
aS'                ue_vi_matrix(i, l) += beta_n *'
p11170
aS'                                      fe_v_neighbor.shape_value(l, point) *'
p11171
aS'                                      fe_v.shape_value(i, point) * JxW[point];'
p11172
aS'            for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)'
p11173
aS'              for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)'
p11174
aS'                ue_ve_matrix(k, l) -='
p11175
aS'                  beta_n * fe_v_neighbor.shape_value(l, point) *'
p11176
aS'                  fe_v_neighbor.shape_value(k, point) * JxW[point];'
p11177
aS'          }'
p11178
aS'      }'
p11179
aS'  }'
p11180
aS'  template <int dim>'
p11181
aS'  class DGMethod'
p11182
aS'  {'
p11183
aS'  public:'
p11184
aS'    DGMethod(const bool anisotropic);'
p11185
aS'    void run();'
p11186
aS'  private:'
p11187
aS'    void setup_system();'
p11188
aS'    void assemble_system();'
p11189
aS'    void solve(Vector<double> &solution);'
p11190
aS'    void refine_grid();'
p11191
aS'    void set_anisotropic_flags();'
p11192
aS'    void output_results(const unsigned int cycle) const;'
p11193
aS'    Triangulation<dim>   triangulation;'
p11194
aS'    const MappingQ1<dim> mapping;'
p11195
aS'    const unsigned int degree;'
p11196
aS'    FE_DGQ<dim>        fe;'
p11197
aS'    DoFHandler<dim>    dof_handler;'
p11198
aS'    SparsityPattern      sparsity_pattern;'
p11199
aS'    SparseMatrix<double> system_matrix;'
p11200
aS'    const double anisotropic_threshold_ratio;'
p11201
aS'    const bool anisotropic;'
p11202
aS'    const QGauss<dim>     quadrature;'
p11203
aS'    const QGauss<dim - 1> face_quadrature;'
p11204
aS'    Vector<double> solution2;'
p11205
aS'    Vector<double> right_hand_side;'
p11206
aS'    const DGTransportEquation<dim> dg;'
p11207
aS'  };'
p11208
aS'  template <int dim>'
p11209
aS'  DGMethod<dim>::DGMethod(const bool anisotropic)'
p11210
aS'    : mapping()'
p11211
aS'    ,'
p11212
aS'    degree(1)'
p11213
aS'    , fe(degree)'
p11214
aS'    , dof_handler(triangulation)'
p11215
aS'    , anisotropic_threshold_ratio(3.)'
p11216
aS'    , anisotropic(anisotropic)'
p11217
aS'    ,'
p11218
aS'    quadrature(degree + 1)'
p11219
aS'    , face_quadrature(degree + 1)'
p11220
aS'    , dg()'
p11221
aS'  {}'
p11222
aS'  template <int dim>'
p11223
aS'  void DGMethod<dim>::setup_system()'
p11224
aS'  {'
p11225
aS'    dof_handler.distribute_dofs(fe);'
p11226
aS'    sparsity_pattern.reinit(dof_handler.n_dofs(),'
p11227
aS'                            dof_handler.n_dofs(),'
p11228
aS'                            (GeometryInfo<dim>::faces_per_cell *'
p11229
aS'                               GeometryInfo<dim>::max_children_per_face +'
p11230
aS'                             1) *'
p11231
aS'                              fe.n_dofs_per_cell());'
p11232
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, sparsity_pattern);'
p11233
aS'    sparsity_pattern.compress();'
p11234
aS'    system_matrix.reinit(sparsity_pattern);'
p11235
aS'    solution2.reinit(dof_handler.n_dofs());'
p11236
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p11237
aS'  }'
p11238
aS'  template <int dim>'
p11239
aS'  void DGMethod<dim>::assemble_system()'
p11240
aS'  {'
p11241
aS'    const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();'
p11242
aS'    std::vector<types::global_dof_index> dofs(dofs_per_cell);'
p11243
aS'    std::vector<types::global_dof_index> dofs_neighbor(dofs_per_cell);'
p11244
aS'    const UpdateFlags update_flags = update_values | update_gradients |'
p11245
aS'                                     update_quadrature_points |'
p11246
aS'                                     update_JxW_values;'
p11247
aS'    const UpdateFlags face_update_flags ='
p11248
aS'      update_values | update_quadrature_points | update_JxW_values |'
p11249
aS'      update_normal_vectors;'
p11250
aS'    const UpdateFlags neighbor_face_update_flags = update_values;'
p11251
aS'    FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);'
p11252
aS'    FEFaceValues<dim>    fe_v_face(mapping,'
p11253
aS'                                fe,'
p11254
aS'                                face_quadrature,'
p11255
aS'                                face_update_flags);'
p11256
aS'    FESubfaceValues<dim> fe_v_subface(mapping,'
p11257
aS'                                      fe,'
p11258
aS'                                      face_quadrature,'
p11259
aS'                                      face_update_flags);'
p11260
aS'    FEFaceValues<dim>    fe_v_face_neighbor(mapping,'
p11261
aS'                                         fe,'
p11262
aS'                                         face_quadrature,'
p11263
aS'                                         neighbor_face_update_flags);'
p11264
aS'    FullMatrix<double> ui_vi_matrix(dofs_per_cell, dofs_per_cell);'
p11265
aS'    FullMatrix<double> ue_vi_matrix(dofs_per_cell, dofs_per_cell);'
p11266
aS'    FullMatrix<double> ui_ve_matrix(dofs_per_cell, dofs_per_cell);'
p11267
aS'    FullMatrix<double> ue_ve_matrix(dofs_per_cell, dofs_per_cell);'
p11268
aS'    Vector<double> cell_vector(dofs_per_cell);'
p11269
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p11270
aS'      {'
p11271
aS'        ui_vi_matrix = 0;'
p11272
aS'        cell_vector  = 0;'
p11273
aS'        fe_v.reinit(cell);'
p11274
aS'        dg.assemble_cell_term(fe_v, ui_vi_matrix, cell_vector);'
p11275
aS'        cell->get_dof_indices(dofs);'
p11276
aS'        for (const auto face_no : cell->face_indices())'
p11277
aS'          {'
p11278
aS'            const auto face = cell->face(face_no);'
p11279
aS'            if (face->at_boundary())'
p11280
aS'              {'
p11281
aS'                fe_v_face.reinit(cell, face_no);'
p11282
aS'                dg.assemble_boundary_term(fe_v_face, ui_vi_matrix, cell_vector);'
p11283
aS'              }'
p11284
aS'            else'
p11285
aS'              {'
p11286
aS'                Assert(cell->neighbor(face_no).state() == IteratorState::valid,'
p11287
aS'                       ExcInternalError());'
p11288
aS'                const auto neighbor = cell->neighbor(face_no);'
p11289
aS'                if (face->has_children())'
p11290
aS'                  {'
p11291
aS'                    const unsigned int neighbor2 ='
p11292
aS'                      cell->neighbor_face_no(face_no);'
p11293
aS'                    for (unsigned int subface_no = 0;'
p11294
aS'                         subface_no < face->n_active_descendants();'
p11295
aS'                         ++subface_no)'
p11296
aS'                      {'
p11297
aS'                        const auto neighbor_child ='
p11298
aS'                          cell->neighbor_child_on_subface(face_no, subface_no);'
p11299
aS'                        Assert(!neighbor_child->has_children(),'
p11300
aS'                               ExcInternalError());'
p11301
aS'                        ue_vi_matrix = 0;'
p11302
aS'                        ui_ve_matrix = 0;'
p11303
aS'                        ue_ve_matrix = 0;'
p11304
aS'                        fe_v_subface.reinit(cell, face_no, subface_no);'
p11305
aS'                        fe_v_face_neighbor.reinit(neighbor_child, neighbor2);'
p11306
aS'                        dg.assemble_face_term(fe_v_subface,'
p11307
aS'                                              fe_v_face_neighbor,'
p11308
aS'                                              ui_vi_matrix,'
p11309
aS'                                              ue_vi_matrix,'
p11310
aS'                                              ui_ve_matrix,'
p11311
aS'                                              ue_ve_matrix);'
p11312
aS'                        neighbor_child->get_dof_indices(dofs_neighbor);'
p11313
aS'                        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11314
aS'                          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p11315
aS'                            {'
p11316
aS'                              system_matrix.add(dofs[i],'
p11317
aS'                                                dofs_neighbor[j],'
p11318
aS'                                                ue_vi_matrix(i, j));'
p11319
aS'                              system_matrix.add(dofs_neighbor[i],'
p11320
aS'                                                dofs[j],'
p11321
aS'                                                ui_ve_matrix(i, j));'
p11322
aS'                              system_matrix.add(dofs_neighbor[i],'
p11323
aS'                                                dofs_neighbor[j],'
p11324
aS'                                                ue_ve_matrix(i, j));'
p11325
aS'                            }'
p11326
aS'                      }'
p11327
aS'                  }'
p11328
aS'                else'
p11329
aS'                  {'
p11330
aS'                    if (dim > 1 && cell->neighbor_is_coarser(face_no))'
p11331
aS'                      continue;'
p11332
aS'                    if (((dim > 1) && (cell->index() < neighbor->index())) ||'
p11333
aS'                        ((dim == 1) && ((cell->level() < neighbor->level()) ||'
p11334
aS'                                        ((cell->level() == neighbor->level()) &&'
p11335
aS'                                         (cell->index() < neighbor->index())))))'
p11336
aS'                      {'
p11337
aS'                        const unsigned int neighbor2 ='
p11338
aS'                          cell->neighbor_of_neighbor(face_no);'
p11339
aS'                        ue_vi_matrix = 0;'
p11340
aS'                        ui_ve_matrix = 0;'
p11341
aS'                        ue_ve_matrix = 0;'
p11342
aS'                        fe_v_face.reinit(cell, face_no);'
p11343
aS'                        fe_v_face_neighbor.reinit(neighbor, neighbor2);'
p11344
aS'                        dg.assemble_face_term(fe_v_face,'
p11345
aS'                                              fe_v_face_neighbor,'
p11346
aS'                                              ui_vi_matrix,'
p11347
aS'                                              ue_vi_matrix,'
p11348
aS'                                              ui_ve_matrix,'
p11349
aS'                                              ue_ve_matrix);'
p11350
aS'                        neighbor->get_dof_indices(dofs_neighbor);'
p11351
aS'                        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11352
aS'                          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p11353
aS'                            {'
p11354
aS'                              system_matrix.add(dofs[i],'
p11355
aS'                                                dofs_neighbor[j],'
p11356
aS'                                                ue_vi_matrix(i, j));'
p11357
aS'                              system_matrix.add(dofs_neighbor[i],'
p11358
aS'                                                dofs[j],'
p11359
aS'                                                ui_ve_matrix(i, j));'
p11360
aS'                              system_matrix.add(dofs_neighbor[i],'
p11361
aS'                                                dofs_neighbor[j],'
p11362
aS'                                                ue_ve_matrix(i, j));'
p11363
aS'                            }'
p11364
aS'                      }'
p11365
aS'                  }'
p11366
aS'              }'
p11367
aS'          }'
p11368
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11369
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p11370
aS'            system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i, j));'
p11371
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11372
aS'          right_hand_side(dofs[i]) += cell_vector(i);'
p11373
aS'      }'
p11374
aS'  }'
p11375
aS'  template <int dim>'
p11376
aS'  void DGMethod<dim>::solve(Vector<double> &solution)'
p11377
aS'  {'
p11378
aS'    SolverControl                    solver_control(1000, 1e-12, false, false);'
p11379
aS'    SolverRichardson<Vector<double>> solver(solver_control);'
p11380
aS'    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;'
p11381
aS'    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());'
p11382
aS'    solver.solve(system_matrix, solution, right_hand_side, preconditioner);'
p11383
aS'  }'
p11384
aS'  template <int dim>'
p11385
aS'  void DGMethod<dim>::refine_grid()'
p11386
aS'  {'
p11387
aS'    Vector<float> gradient_indicator(triangulation.n_active_cells());'
p11388
aS'    DerivativeApproximation::approximate_gradient(mapping,'
p11389
aS'                                                  dof_handler,'
p11390
aS'                                                  solution2,'
p11391
aS'                                                  gradient_indicator);'
p11392
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p11393
aS'      gradient_indicator[cell->active_cell_index()] *='
p11394
aS'        std::pow(cell->diameter(), 1 + 1.0 * dim / 2);'
p11395
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p11396
aS'                                                    gradient_indicator,'
p11397
aS'                                                    0.3,'
p11398
aS'                                                    0.1);'
p11399
aS'    if (anisotropic)'
p11400
aS'      set_anisotropic_flags();'
p11401
aS'    triangulation.execute_coarsening_and_refinement();'
p11402
aS'  }'
p11403
aS'  template <int dim>'
p11404
aS'  void DGMethod<dim>::set_anisotropic_flags()'
p11405
aS'  {'
p11406
aS'    UpdateFlags face_update_flags ='
p11407
aS'      UpdateFlags(update_values | update_JxW_values);'
p11408
aS'    FEFaceValues<dim>    fe_v_face(mapping,'
p11409
aS'                                fe,'
p11410
aS'                                face_quadrature,'
p11411
aS'                                face_update_flags);'
p11412
aS'    FESubfaceValues<dim> fe_v_subface(mapping,'
p11413
aS'                                      fe,'
p11414
aS'                                      face_quadrature,'
p11415
aS'                                      face_update_flags);'
p11416
aS'    FEFaceValues<dim>    fe_v_face_neighbor(mapping,'
p11417
aS'                                         fe,'
p11418
aS'                                         face_quadrature,'
p11419
aS'                                         update_values);'
p11420
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p11421
aS'      if (cell->refine_flag_set())'
p11422
aS'        {'
p11423
aS'          Point<dim> jump;'
p11424
aS'          Point<dim> area;'
p11425
aS'          for (const auto face_no : cell->face_indices())'
p11426
aS'            {'
p11427
aS'              const auto face = cell->face(face_no);'
p11428
aS'              if (!face->at_boundary())'
p11429
aS'                {'
p11430
aS'                  Assert(cell->neighbor(face_no).state() =='
p11431
aS'                           IteratorState::valid,'
p11432
aS'                         ExcInternalError());'
p11433
aS'                  const auto neighbor = cell->neighbor(face_no);'
p11434
aS'                  std::vector<double> u(fe_v_face.n_quadrature_points);'
p11435
aS'                  std::vector<double> u_neighbor(fe_v_face.n_quadrature_points);'
p11436
aS'                  if (face->has_children())'
p11437
aS'                    {'
p11438
aS'                      unsigned int neighbor2 = cell->neighbor_face_no(face_no);'
p11439
aS'                      for (unsigned int subface_no = 0;'
p11440
aS'                           subface_no < face->n_active_descendants();'
p11441
aS'                           ++subface_no)'
p11442
aS'                        {'
p11443
aS'                          const auto neighbor_child ='
p11444
aS'                            cell->neighbor_child_on_subface(face_no,'
p11445
aS'                                                            subface_no);'
p11446
aS'                          Assert(!neighbor_child->has_children(),'
p11447
aS'                                 ExcInternalError());'
p11448
aS'                          fe_v_subface.reinit(cell, face_no, subface_no);'
p11449
aS'                          fe_v_face_neighbor.reinit(neighbor_child, neighbor2);'
p11450
aS'                          fe_v_subface.get_function_values(solution2, u);'
p11451
aS'                          fe_v_face_neighbor.get_function_values(solution2,'
p11452
aS'                                                                 u_neighbor);'
p11453
aS'                          const std::vector<double> &JxW ='
p11454
aS'                            fe_v_subface.get_JxW_values();'
p11455
aS'                          for (unsigned int x = 0;'
p11456
aS'                               x < fe_v_subface.n_quadrature_points;'
p11457
aS'                               ++x)'
p11458
aS'                            {'
p11459
aS'                              jump[face_no / 2] +='
p11460
aS'                                std::abs(u[x] - u_neighbor[x]) * JxW[x];'
p11461
aS'                              area[face_no / 2] += JxW[x];'
p11462
aS'                            }'
p11463
aS'                        }'
p11464
aS'                    }'
p11465
aS'                  else'
p11466
aS'                    {'
p11467
aS'                      if (!cell->neighbor_is_coarser(face_no))'
p11468
aS'                        {'
p11469
aS'                          unsigned int neighbor2 ='
p11470
aS'                            cell->neighbor_of_neighbor(face_no);'
p11471
aS'                          fe_v_face.reinit(cell, face_no);'
p11472
aS'                          fe_v_face_neighbor.reinit(neighbor, neighbor2);'
p11473
aS'                          fe_v_face.get_function_values(solution2, u);'
p11474
aS'                          fe_v_face_neighbor.get_function_values(solution2,'
p11475
aS'                                                                 u_neighbor);'
p11476
aS'                          const std::vector<double> &JxW ='
p11477
aS'                            fe_v_face.get_JxW_values();'
p11478
aS'                          for (unsigned int x = 0;'
p11479
aS'                               x < fe_v_face.n_quadrature_points;'
p11480
aS'                               ++x)'
p11481
aS'                            {'
p11482
aS'                              jump[face_no / 2] +='
p11483
aS'                                std::abs(u[x] - u_neighbor[x]) * JxW[x];'
p11484
aS'                              area[face_no / 2] += JxW[x];'
p11485
aS'                            }'
p11486
aS'                        }'
p11487
aS'                      else // i.e. neighbor is coarser than cell'
p11488
aS'                        {'
p11489
aS'                          std::pair<unsigned int, unsigned int>'
p11490
aS'                            neighbor_face_subface ='
p11491
aS'                              cell->neighbor_of_coarser_neighbor(face_no);'
p11492
aS'                          Assert(neighbor_face_subface.first < cell->n_faces(),'
p11493
aS'                                 ExcInternalError());'
p11494
aS'                          Assert(neighbor_face_subface.second <'
p11495
aS'                                   neighbor->face(neighbor_face_subface.first)'
p11496
aS'                                     ->n_active_descendants(),'
p11497
aS'                                 ExcInternalError());'
p11498
aS'                          Assert(neighbor->neighbor_child_on_subface('
p11499
aS'                                   neighbor_face_subface.first,'
p11500
aS'                                   neighbor_face_subface.second) == cell,'
p11501
aS'                                 ExcInternalError());'
p11502
aS'                          fe_v_face.reinit(cell, face_no);'
p11503
aS'                          fe_v_subface.reinit(neighbor,'
p11504
aS'                                              neighbor_face_subface.first,'
p11505
aS'                                              neighbor_face_subface.second);'
p11506
aS'                          fe_v_face.get_function_values(solution2, u);'
p11507
aS'                          fe_v_subface.get_function_values(solution2,'
p11508
aS'                                                           u_neighbor);'
p11509
aS'                          const std::vector<double> &JxW ='
p11510
aS'                            fe_v_face.get_JxW_values();'
p11511
aS'                          for (unsigned int x = 0;'
p11512
aS'                               x < fe_v_face.n_quadrature_points;'
p11513
aS'                               ++x)'
p11514
aS'                            {'
p11515
aS'                              jump[face_no / 2] +='
p11516
aS'                                std::abs(u[x] - u_neighbor[x]) * JxW[x];'
p11517
aS'                              area[face_no / 2] += JxW[x];'
p11518
aS'                            }'
p11519
aS'                        }'
p11520
aS'                    }'
p11521
aS'                }'
p11522
aS'            }'
p11523
aS'          std::array<double, dim> average_jumps;'
p11524
aS'          double                  sum_of_average_jumps = 0.;'
p11525
aS'          for (unsigned int i = 0; i < dim; ++i)'
p11526
aS'            {'
p11527
aS'              average_jumps[i] = jump(i) / area(i);'
p11528
aS'              sum_of_average_jumps += average_jumps[i];'
p11529
aS'            }'
p11530
aS'          for (unsigned int i = 0; i < dim; ++i)'
p11531
aS'            if (average_jumps[i] > anisotropic_threshold_ratio *'
p11532
aS'                                     (sum_of_average_jumps - average_jumps[i]))'
p11533
aS'              cell->set_refine_flag(RefinementCase<dim>::cut_axis(i));'
p11534
aS'        }'
p11535
aS'  }'
p11536
aS'  template <int dim>'
p11537
aS'  void DGMethod<dim>::output_results(const unsigned int cycle) const'
p11538
aS'  {'
p11539
aS'    std::string refine_type;'
p11540
aS'    if (anisotropic)'
p11541
aS'      refine_type = ".aniso";'
p11542
aS'    else'
p11543
aS'      refine_type = ".iso";'
p11544
aS'    {'
p11545
aS'      const std::string filename ='
p11546
aS'        "grid-" + std::to_string(cycle) + refine_type + ".svg";'
p11547
aS'      std::cout << "   Writing grid to <" << filename << ">..." << std::endl;'
p11548
aS'      std::ofstream svg_output(filename);'
p11549
aS'      GridOut grid_out;'
p11550
aS'      grid_out.write_svg(triangulation, svg_output);'
p11551
aS'    }'
p11552
aS'    {'
p11553
aS'      const std::string filename ='
p11554
aS'        "sol-" + std::to_string(cycle) + refine_type + ".vtu";'
p11555
aS'      std::cout << "   Writing solution to <" << filename << ">..."'
p11556
aS'                << std::endl;'
p11557
aS'      std::ofstream gnuplot_output(filename);'
p11558
aS'      DataOut<dim> data_out;'
p11559
aS'      data_out.attach_dof_handler(dof_handler);'
p11560
aS'      data_out.add_data_vector(solution2, "u");'
p11561
aS'      data_out.build_patches(degree);'
p11562
aS'      data_out.write_vtu(gnuplot_output);'
p11563
aS'    }'
p11564
aS'  }'
p11565
aS'  template <int dim>'
p11566
aS'  void DGMethod<dim>::run()'
p11567
aS'  {'
p11568
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p11569
aS'      {'
p11570
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p11571
aS'        if (cycle == 0)'
p11572
aS'          {'
p11573
aS'            Point<dim> p1, p2;'
p11574
aS'            p1(0) = 0;'
p11575
aS'            p1(0) = -1;'
p11576
aS'            for (unsigned int i = 0; i < dim; ++i)'
p11577
aS'              p2(i) = 1.;'
p11578
aS'            std::vector<unsigned int> repetitions(dim, 1);'
p11579
aS'            repetitions[0] = 2;'
p11580
aS'            GridGenerator::subdivided_hyper_rectangle(triangulation,'
p11581
aS'                                                      repetitions,'
p11582
aS'                                                      p1,'
p11583
aS'                                                      p2);'
p11584
aS'            triangulation.refine_global(5 - dim);'
p11585
aS'          }'
p11586
aS'        else'
p11587
aS'          refine_grid();'
p11588
aS'        std::cout << "   Number of active cells:       "'
p11589
aS'                  << triangulation.n_active_cells() << std::endl;'
p11590
aS'        setup_system();'
p11591
aS'        std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p11592
aS'                  << std::endl;'
p11593
aS'        Timer assemble_timer;'
p11594
aS'        assemble_system();'
p11595
aS'        std::cout << "   Time of assemble_system: " << assemble_timer.cpu_time()'
p11596
aS'                  << std::endl;'
p11597
aS'        solve(solution2);'
p11598
aS'        output_results(cycle);'
p11599
aS'        std::cout << std::endl;'
p11600
aS'      }'
p11601
aS'  }'
p11602
aS'} // namespace Step30'
p11603
aS'int main()'
p11604
ag24
aS'  try'
p11605
aS'    {'
p11606
aS'      using namespace Step30;'
p11607
aS'      const unsigned int dim = 2;'
p11608
aS'      {'
p11609
aS'        std::cout << "Performing a " << dim'
p11610
aS'                  << "D run with isotropic refinement..." << std::endl'
p11611
aS'                  << "------------------------------------------------"'
p11612
aS'                  << std::endl;'
p11613
aS'        DGMethod<dim> dgmethod_iso(false);'
p11614
aS'        dgmethod_iso.run();'
p11615
aS'      }'
p11616
aS'      {'
p11617
aS'        std::cout << std::endl'
p11618
aS'                  << "Performing a " << dim'
p11619
aS'                  << "D run with anisotropic refinement..." << std::endl'
p11620
aS'                  << "--------------------------------------------------"'
p11621
aS'                  << std::endl;'
p11622
aS'        DGMethod<dim> dgmethod_aniso(true);'
p11623
aS'        dgmethod_aniso.run();'
p11624
aS'      }'
p11625
aS'    }'
p11626
aS'  catch (std::exception &exc)'
p11627
aS'    {'
p11628
aS'      std::cerr << std::endl'
p11629
aS'                << std::endl'
p11630
aS'                << "----------------------------------------------------"'
p11631
aS'                << std::endl;'
p11632
aS'      std::cerr << "Exception on processing: " << std::endl'
p11633
aS'                << exc.what() << std::endl'
p11634
aS'                << "Aborting!" << std::endl'
p11635
aS'                << "----------------------------------------------------"'
p11636
aS'                << std::endl;'
p11637
aS'      return 1;'
p11638
aS'    }'
p11639
aS'  catch (...)'
p11640
aS'    {'
p11641
aS'      std::cerr << std::endl'
p11642
aS'                << std::endl'
p11643
aS'                << "----------------------------------------------------"'
p11644
aS'                << std::endl;'
p11645
aS'      std::cerr << "Unknown exception!" << std::endl'
p11646
aS'                << "Aborting!" << std::endl'
p11647
aS'                << "----------------------------------------------------"'
p11648
aS'                << std::endl;'
p11649
aS'      return 1;'
p11650
aS'    };'
p11651
aS'  return 0;'
p11652
ag32
aS'/* ---------------------------------------------------------------------'
p11653
aS' *'
p11654
aS' * Copyright (C) 2007 - 2021 by the deal.II authors'
p11655
aS' *'
p11656
aS' * This file is part of the deal.II library.'
p11657
aS' *'
p11658
aS' * The deal.II library is free software; you can use it, redistribute'
p11659
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p11660
aS' * Public License as published by the Free Software Foundation; either'
p11661
aS' * version 2.1 of the License, or (at your option) any later version.'
p11662
aS' * The full text of the license can be found in the file LICENSE.md at'
p11663
aS' * the top level directory of deal.II.'
p11664
aS' *'
p11665
aS' * ---------------------------------------------------------------------'
p11666
aS' *'
p11667
aS' * Authors: Martin Kronbichler, Uppsala University,'
p11668
aS' *          Wolfgang Bangerth, Texas A&M University 2007, 2008'
p11669
aS' */'
p11670
aS'#include <deal.II/base/quadrature_lib.h>'
p11671
aS'#include <deal.II/base/logstream.h>'
p11672
aS'#include <deal.II/base/utilities.h>'
p11673
aS'#include <deal.II/lac/full_matrix.h>'
p11674
aS'#include <deal.II/lac/solver_gmres.h>'
p11675
aS'#include <deal.II/lac/solver_cg.h>'
p11676
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p11677
aS'#include <deal.II/lac/affine_constraints.h>'
p11678
aS'#include <deal.II/grid/tria.h>'
p11679
aS'#include <deal.II/grid/grid_generator.h>'
p11680
aS'#include <deal.II/grid/grid_tools.h>'
p11681
aS'#include <deal.II/grid/grid_refinement.h>'
p11682
aS'#include <deal.II/dofs/dof_handler.h>'
p11683
aS'#include <deal.II/dofs/dof_renumbering.h>'
p11684
aS'#include <deal.II/dofs/dof_tools.h>'
p11685
aS'#include <deal.II/fe/fe_q.h>'
p11686
aS'#include <deal.II/fe/fe_system.h>'
p11687
aS'#include <deal.II/fe/fe_values.h>'
p11688
aS'#include <deal.II/numerics/vector_tools.h>'
p11689
aS'#include <deal.II/numerics/data_out.h>'
p11690
aS'#include <deal.II/numerics/error_estimator.h>'
p11691
aS'#include <deal.II/numerics/solution_transfer.h>'
p11692
aS'#include <deal.II/base/index_set.h>'
p11693
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p11694
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p11695
aS'#include <deal.II/lac/trilinos_vector.h>'
p11696
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p11697
aS'#include <deal.II/lac/trilinos_precondition.h>'
p11698
aS'#include <iostream>'
p11699
aS'#include <fstream>'
p11700
aS'#include <memory>'
p11701
aS'#include <limits>'
p11702
aS'namespace Step31'
p11703
ag24
aS'  using namespace dealii;'
p11704
aS'  namespace EquationData'
p11705
aS'  {'
p11706
aS'    constexpr double eta     = 1;'
p11707
aS'    constexpr double kappa   = 1e-6;'
p11708
aS'    constexpr double beta    = 10;'
p11709
aS'    constexpr double density = 1;'
p11710
aS'    template <int dim>'
p11711
aS'    class TemperatureInitialValues : public Function<dim>'
p11712
aS'    {'
p11713
aS'    public:'
p11714
aS'      TemperatureInitialValues()'
p11715
aS'        : Function<dim>(1)'
p11716
aS'      {}'
p11717
aS'      virtual double value(const Point<dim> & /*p*/,'
p11718
aS'                           const unsigned int /*component*/ = 0) const override'
p11719
aS'      {'
p11720
aS'        return 0;'
p11721
aS'      }'
p11722
aS'      virtual void vector_value(const Point<dim> &p,'
p11723
aS'                                Vector<double> &  value) const override'
p11724
aS'      {'
p11725
aS'        for (unsigned int c = 0; c < this->n_components; ++c)'
p11726
aS'          value(c) = TemperatureInitialValues<dim>::value(p, c);'
p11727
aS'      }'
p11728
aS'    };'
p11729
aS'    template <int dim>'
p11730
aS'    class TemperatureRightHandSide : public Function<dim>'
p11731
aS'    {'
p11732
aS'    public:'
p11733
aS'      TemperatureRightHandSide()'
p11734
aS'        : Function<dim>(1)'
p11735
aS'      {}'
p11736
aS'      virtual double value(const Point<dim> & p,'
p11737
aS'                           const unsigned int component = 0) const override'
p11738
aS'      {'
p11739
aS'        (void)component;'
p11740
aS'        Assert(component == 0,'
p11741
aS'               ExcMessage("Invalid operation for a scalar function."));'
p11742
aS'        Assert((dim == 2) || (dim == 3), ExcNotImplemented());'
p11743
aS'        static const Point<dim> source_centers[3] = {'
p11744
aS'          (dim == 2 ? Point<dim>(.3, .1) : Point<dim>(.3, .5, .1)),'
p11745
aS'          (dim == 2 ? Point<dim>(.45, .1) : Point<dim>(.45, .5, .1)),'
p11746
aS'          (dim == 2 ? Point<dim>(.75, .1) : Point<dim>(.75, .5, .1))};'
p11747
aS'        static const double source_radius = (dim == 2 ? 1. / 32 : 1. / 8);'
p11748
aS'        return ((source_centers[0].distance(p) < source_radius) ||'
p11749
aS'                    (source_centers[1].distance(p) < source_radius) ||'
p11750
aS'                    (source_centers[2].distance(p) < source_radius) ?'
p11751
aS'                  1 :'
p11752
aS'                  0);'
p11753
aS'      }'
p11754
aS'      virtual void vector_value(const Point<dim> &p,'
p11755
aS'                                Vector<double> &  value) const override'
p11756
aS'      {'
p11757
aS'        for (unsigned int c = 0; c < this->n_components; ++c)'
p11758
aS'          value(c) = TemperatureRightHandSide<dim>::value(p, c);'
p11759
aS'      }'
p11760
aS'    };'
p11761
aS'  } // namespace EquationData'
p11762
aS'  namespace LinearSolvers'
p11763
aS'  {'
p11764
aS'    template <class MatrixType, class PreconditionerType>'
p11765
aS'    class InverseMatrix : public Subscriptor'
p11766
aS'    {'
p11767
aS'    public:'
p11768
aS'      InverseMatrix(const MatrixType &        m,'
p11769
aS'                    const PreconditionerType &preconditioner);'
p11770
aS'      template <typename VectorType>'
p11771
aS'      void vmult(VectorType &dst, const VectorType &src) const;'
p11772
aS'    private:'
p11773
aS'      const SmartPointer<const MatrixType> matrix;'
p11774
aS'      const PreconditionerType &           preconditioner;'
p11775
aS'    };'
p11776
aS'    template <class MatrixType, class PreconditionerType>'
p11777
aS'    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p11778
aS'      const MatrixType &        m,'
p11779
aS'      const PreconditionerType &preconditioner)'
p11780
aS'      : matrix(&m)'
p11781
aS'      , preconditioner(preconditioner)'
p11782
aS'    {}'
p11783
aS'    template <class MatrixType, class PreconditionerType>'
p11784
aS'    template <typename VectorType>'
p11785
aS'    void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p11786
aS'      VectorType &      dst,'
p11787
aS'      const VectorType &src) const'
p11788
aS'    {'
p11789
aS'      SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm());'
p11790
aS'      SolverCG<VectorType> cg(solver_control);'
p11791
aS'      dst = 0;'
p11792
aS'      try'
p11793
aS'        {'
p11794
aS'          cg.solve(*matrix, dst, src, preconditioner);'
p11795
aS'        }'
p11796
aS'      catch (std::exception &e)'
p11797
aS'        {'
p11798
aS'          Assert(false, ExcMessage(e.what()));'
p11799
aS'        }'
p11800
aS'    }'
p11801
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p11802
aS'    class BlockSchurPreconditioner : public Subscriptor'
p11803
aS'    {'
p11804
aS'    public:'
p11805
aS'      BlockSchurPreconditioner('
p11806
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p11807
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11808
aS'                            PreconditionerTypeMp> &Mpinv,'
p11809
aS'        const PreconditionerTypeA &                Apreconditioner);'
p11810
aS'      void vmult(TrilinosWrappers::MPI::BlockVector &      dst,'
p11811
aS'                 const TrilinosWrappers::MPI::BlockVector &src) const;'
p11812
aS'    private:'
p11813
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p11814
aS'        stokes_matrix;'
p11815
aS'      const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11816
aS'                                             PreconditionerTypeMp>>'
p11817
aS'                                 m_inverse;'
p11818
aS'      const PreconditionerTypeA &a_preconditioner;'
p11819
aS'      mutable TrilinosWrappers::MPI::Vector tmp;'
p11820
aS'    };'
p11821
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p11822
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::'
p11823
aS'      BlockSchurPreconditioner('
p11824
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p11825
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11826
aS'                            PreconditionerTypeMp> &Mpinv,'
p11827
aS'        const PreconditionerTypeA &                Apreconditioner)'
p11828
aS'      : stokes_matrix(&S)'
p11829
aS'      , m_inverse(&Mpinv)'
p11830
aS'      , a_preconditioner(Apreconditioner)'
p11831
aS'      , tmp(complete_index_set(stokes_matrix->block(1, 1).m()))'
p11832
aS'    {}'
p11833
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p11834
aS'    void'
p11835
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult('
p11836
aS'      TrilinosWrappers::MPI::BlockVector &      dst,'
p11837
aS'      const TrilinosWrappers::MPI::BlockVector &src) const'
p11838
aS'    {'
p11839
aS'      a_preconditioner.vmult(dst.block(0), src.block(0));'
p11840
aS'      stokes_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1));'
p11841
aS'      tmp *= -1;'
p11842
aS'      m_inverse->vmult(dst.block(1), tmp);'
p11843
aS'    }'
p11844
aS'  } // namespace LinearSolvers'
p11845
aS'  template <int dim>'
p11846
aS'  class BoussinesqFlowProblem'
p11847
aS'  {'
p11848
aS'  public:'
p11849
aS'    BoussinesqFlowProblem();'
p11850
aS'    void run();'
p11851
aS'  private:'
p11852
aS'    void   setup_dofs();'
p11853
aS'    void   assemble_stokes_preconditioner();'
p11854
aS'    void   build_stokes_preconditioner();'
p11855
aS'    void   assemble_stokes_system();'
p11856
aS'    void   assemble_temperature_system(const double maximal_velocity);'
p11857
aS'    void   assemble_temperature_matrix();'
p11858
aS'    double get_maximal_velocity() const;'
p11859
aS'    std::pair<double, double> get_extrapolated_temperature_range() const;'
p11860
aS'    void                      solve();'
p11861
aS'    void                      output_results() const;'
p11862
aS'    void                      refine_mesh(const unsigned int max_grid_level);'
p11863
aS'    double compute_viscosity('
p11864
aS'      const std::vector<double> &        old_temperature,'
p11865
aS'      const std::vector<double> &        old_old_temperature,'
p11866
aS'      const std::vector<Tensor<1, dim>> &old_temperature_grads,'
p11867
aS'      const std::vector<Tensor<1, dim>> &old_old_temperature_grads,'
p11868
aS'      const std::vector<double> &        old_temperature_laplacians,'
p11869
aS'      const std::vector<double> &        old_old_temperature_laplacians,'
p11870
aS'      const std::vector<Tensor<1, dim>> &old_velocity_values,'
p11871
aS'      const std::vector<Tensor<1, dim>> &old_old_velocity_values,'
p11872
aS'      const std::vector<double> &        gamma_values,'
p11873
aS'      const double                       global_u_infty,'
p11874
aS'      const double                       global_T_variation,'
p11875
aS'      const double                       cell_diameter) const;'
p11876
aS'    Triangulation<dim> triangulation;'
p11877
aS'    double             global_Omega_diameter;'
p11878
aS'    const unsigned int        stokes_degree;'
p11879
aS'    FESystem<dim>             stokes_fe;'
p11880
aS'    DoFHandler<dim>           stokes_dof_handler;'
p11881
aS'    AffineConstraints<double> stokes_constraints;'
p11882
aS'    std::vector<IndexSet>               stokes_partitioning;'
p11883
aS'    TrilinosWrappers::BlockSparseMatrix stokes_matrix;'
p11884
aS'    TrilinosWrappers::BlockSparseMatrix stokes_preconditioner_matrix;'
p11885
aS'    TrilinosWrappers::MPI::BlockVector stokes_solution;'
p11886
aS'    TrilinosWrappers::MPI::BlockVector old_stokes_solution;'
p11887
aS'    TrilinosWrappers::MPI::BlockVector stokes_rhs;'
p11888
aS'    const unsigned int        temperature_degree;'
p11889
aS'    FE_Q<dim>                 temperature_fe;'
p11890
aS'    DoFHandler<dim>           temperature_dof_handler;'
p11891
aS'    AffineConstraints<double> temperature_constraints;'
p11892
aS'    TrilinosWrappers::SparseMatrix temperature_mass_matrix;'
p11893
aS'    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;'
p11894
aS'    TrilinosWrappers::SparseMatrix temperature_matrix;'
p11895
aS'    TrilinosWrappers::MPI::Vector temperature_solution;'
p11896
aS'    TrilinosWrappers::MPI::Vector old_temperature_solution;'
p11897
aS'    TrilinosWrappers::MPI::Vector old_old_temperature_solution;'
p11898
aS'    TrilinosWrappers::MPI::Vector temperature_rhs;'
p11899
aS'    double       time_step;'
p11900
aS'    double       old_time_step;'
p11901
aS'    unsigned int timestep_number;'
p11902
aS'    std::shared_ptr<TrilinosWrappers::PreconditionAMG> Amg_preconditioner;'
p11903
aS'    std::shared_ptr<TrilinosWrappers::PreconditionIC>  Mp_preconditioner;'
p11904
aS'    bool rebuild_stokes_matrix;'
p11905
aS'    bool rebuild_temperature_matrices;'
p11906
aS'    bool rebuild_stokes_preconditioner;'
p11907
aS'  };'
p11908
aS'  template <int dim>'
p11909
aS'  BoussinesqFlowProblem<dim>::BoussinesqFlowProblem()'
p11910
aS'    : triangulation(Triangulation<dim>::maximum_smoothing)'
p11911
aS'    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN())'
p11912
aS'    , stokes_degree(1)'
p11913
aS'    , stokes_fe(FE_Q<dim>(stokes_degree + 1), dim, FE_Q<dim>(stokes_degree), 1)'
p11914
aS'    , stokes_dof_handler(triangulation)'
p11915
aS'    ,'
p11916
aS'    temperature_degree(2)'
p11917
aS'    , temperature_fe(temperature_degree)'
p11918
aS'    , temperature_dof_handler(triangulation)'
p11919
aS'    ,'
p11920
aS'    time_step(0)'
p11921
aS'    , old_time_step(0)'
p11922
aS'    , timestep_number(0)'
p11923
aS'    , rebuild_stokes_matrix(true)'
p11924
aS'    , rebuild_temperature_matrices(true)'
p11925
aS'    , rebuild_stokes_preconditioner(true)'
p11926
aS'  {}'
p11927
aS'  template <int dim>'
p11928
aS'  double BoussinesqFlowProblem<dim>::get_maximal_velocity() const'
p11929
aS'  {'
p11930
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), stokes_degree + 1);'
p11931
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p11932
aS'    FEValues<dim> fe_values(stokes_fe, quadrature_formula, update_values);'
p11933
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points);'
p11934
aS'    double                      max_velocity = 0;'
p11935
aS'    const FEValuesExtractors::Vector velocities(0);'
p11936
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p11937
aS'      {'
p11938
aS'        fe_values.reinit(cell);'
p11939
aS'        fe_values[velocities].get_function_values(stokes_solution,'
p11940
aS'                                                  velocity_values);'
p11941
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p11942
aS'          max_velocity = std::max(max_velocity, velocity_values[q].norm());'
p11943
aS'      }'
p11944
aS'    return max_velocity;'
p11945
aS'  }'
p11946
aS'  template <int dim>'
p11947
aS'  std::pair<double, double>'
p11948
aS'  BoussinesqFlowProblem<dim>::get_extrapolated_temperature_range() const'
p11949
aS'  {'
p11950
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p11951
aS'                                            temperature_degree);'
p11952
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p11953
aS'    FEValues<dim> fe_values(temperature_fe, quadrature_formula, update_values);'
p11954
aS'    std::vector<double> old_temperature_values(n_q_points);'
p11955
aS'    std::vector<double> old_old_temperature_values(n_q_points);'
p11956
aS'    if (timestep_number != 0)'
p11957
aS'      {'
p11958
aS'        double min_temperature = std::numeric_limits<double>::max(),'
p11959
aS'               max_temperature = -std::numeric_limits<double>::max();'
p11960
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p11961
aS'          {'
p11962
aS'            fe_values.reinit(cell);'
p11963
aS'            fe_values.get_function_values(old_temperature_solution,'
p11964
aS'                                          old_temperature_values);'
p11965
aS'            fe_values.get_function_values(old_old_temperature_solution,'
p11966
aS'                                          old_old_temperature_values);'
p11967
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p11968
aS'              {'
p11969
aS'                const double temperature ='
p11970
aS'                  (1. + time_step / old_time_step) * old_temperature_values[q] -'
p11971
aS'                  time_step / old_time_step * old_old_temperature_values[q];'
p11972
aS'                min_temperature = std::min(min_temperature, temperature);'
p11973
aS'                max_temperature = std::max(max_temperature, temperature);'
p11974
aS'              }'
p11975
aS'          }'
p11976
aS'        return std::make_pair(min_temperature, max_temperature);'
p11977
aS'      }'
p11978
aS'    else'
p11979
aS'      {'
p11980
aS'        double min_temperature = std::numeric_limits<double>::max(),'
p11981
aS'               max_temperature = -std::numeric_limits<double>::max();'
p11982
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p11983
aS'          {'
p11984
aS'            fe_values.reinit(cell);'
p11985
aS'            fe_values.get_function_values(old_temperature_solution,'
p11986
aS'                                          old_temperature_values);'
p11987
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p11988
aS'              {'
p11989
aS'                const double temperature = old_temperature_values[q];'
p11990
aS'                min_temperature = std::min(min_temperature, temperature);'
p11991
aS'                max_temperature = std::max(max_temperature, temperature);'
p11992
aS'              }'
p11993
aS'          }'
p11994
aS'        return std::make_pair(min_temperature, max_temperature);'
p11995
aS'      }'
p11996
aS'  }'
p11997
aS'  template <int dim>'
p11998
aS'  double BoussinesqFlowProblem<dim>::compute_viscosity('
p11999
aS'    const std::vector<double> &        old_temperature,'
p12000
aS'    const std::vector<double> &        old_old_temperature,'
p12001
aS'    const std::vector<Tensor<1, dim>> &old_temperature_grads,'
p12002
aS'    const std::vector<Tensor<1, dim>> &old_old_temperature_grads,'
p12003
aS'    const std::vector<double> &        old_temperature_laplacians,'
p12004
aS'    const std::vector<double> &        old_old_temperature_laplacians,'
p12005
aS'    const std::vector<Tensor<1, dim>> &old_velocity_values,'
p12006
aS'    const std::vector<Tensor<1, dim>> &old_old_velocity_values,'
p12007
aS'    const std::vector<double> &        gamma_values,'
p12008
aS'    const double                       global_u_infty,'
p12009
aS'    const double                       global_T_variation,'
p12010
aS'    const double                       cell_diameter) const'
p12011
aS'  {'
p12012
aS'    constexpr double beta  = 0.017 * dim;'
p12013
aS'    constexpr double alpha = 1.0;'
p12014
aS'    if (global_u_infty == 0)'
p12015
aS'      return 5e-3 * cell_diameter;'
p12016
aS'    const unsigned int n_q_points = old_temperature.size();'
p12017
aS'    double max_residual = 0;'
p12018
aS'    double max_velocity = 0;'
p12019
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p12020
aS'      {'
p12021
aS'        const Tensor<1, dim> u ='
p12022
aS'          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;'
p12023
aS'        const double dT_dt ='
p12024
aS'          (old_temperature[q] - old_old_temperature[q]) / old_time_step;'
p12025
aS'        const double u_grad_T ='
p12026
aS'          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;'
p12027
aS'        const double kappa_Delta_T ='
p12028
aS'          EquationData::kappa *'
p12029
aS'          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /'
p12030
aS'          2;'
p12031
aS'        const double residual ='
p12032
aS'          std::abs((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *'
p12033
aS'                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2,'
p12034
aS'                            alpha - 1.));'
p12035
aS'        max_residual = std::max(residual, max_residual);'
p12036
aS'        max_velocity = std::max(std::sqrt(u * u), max_velocity);'
p12037
aS'      }'
p12038
aS'    const double c_R            = std::pow(2., (4. - 2 * alpha) / dim);'
p12039
aS'    const double global_scaling = c_R * global_u_infty * global_T_variation *'
p12040
aS'                                  std::pow(global_Omega_diameter, alpha - 2.);'
p12041
aS'    return ('
p12042
aS'      beta * max_velocity *'
p12043
aS'      std::min(cell_diameter,'
p12044
aS'               std::pow(cell_diameter, alpha) * max_residual / global_scaling));'
p12045
aS'  }'
p12046
aS'  template <int dim>'
p12047
aS'  void BoussinesqFlowProblem<dim>::setup_dofs()'
p12048
aS'  {'
p12049
aS'    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0);'
p12050
aS'    stokes_sub_blocks[dim] = 1;'
p12051
aS'    {'
p12052
aS'      stokes_dof_handler.distribute_dofs(stokes_fe);'
p12053
aS'      DoFRenumbering::component_wise(stokes_dof_handler, stokes_sub_blocks);'
p12054
aS'      stokes_constraints.clear();'
p12055
aS'      DoFTools::make_hanging_node_constraints(stokes_dof_handler,'
p12056
aS'                                              stokes_constraints);'
p12057
aS'      std::set<types::boundary_id> no_normal_flux_boundaries;'
p12058
aS'      no_normal_flux_boundaries.insert(0);'
p12059
aS'      VectorTools::compute_no_normal_flux_constraints(stokes_dof_handler,'
p12060
aS'                                                      0,'
p12061
aS'                                                      no_normal_flux_boundaries,'
p12062
aS'                                                      stokes_constraints);'
p12063
aS'      stokes_constraints.close();'
p12064
aS'    }'
p12065
aS'    {'
p12066
aS'      temperature_dof_handler.distribute_dofs(temperature_fe);'
p12067
aS'      temperature_constraints.clear();'
p12068
aS'      DoFTools::make_hanging_node_constraints(temperature_dof_handler,'
p12069
aS'                                              temperature_constraints);'
p12070
aS'      temperature_constraints.close();'
p12071
aS'    }'
p12072
aS'    const std::vector<types::global_dof_index> stokes_dofs_per_block ='
p12073
aS'      DoFTools::count_dofs_per_fe_block(stokes_dof_handler, stokes_sub_blocks);'
p12074
aS'    const unsigned int n_u = stokes_dofs_per_block[0],'
p12075
aS'                       n_p = stokes_dofs_per_block[1],'
p12076
aS'                       n_T = temperature_dof_handler.n_dofs();'
p12077
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p12078
aS'              << " (on " << triangulation.n_levels() << " levels)" << std::endl'
p12079
aS'              << "Number of degrees of freedom: " << n_u + n_p + n_T << " ("'
p12080
aS"              << n_u << '+' << n_p << '+' << n_T << ')' << std::endl"
p12081
aS'              << std::endl;'
p12082
aS'    stokes_partitioning.resize(2);'
p12083
aS'    stokes_partitioning[0] = complete_index_set(n_u);'
p12084
aS'    stokes_partitioning[1] = complete_index_set(n_p);'
p12085
aS'    {'
p12086
aS'      stokes_matrix.clear();'
p12087
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p12088
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p12089
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p12090
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p12091
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p12092
aS'      dsp.collect_sizes();'
p12093
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p12094
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p12095
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p12096
aS'          if (!((c == dim) && (d == dim)))'
p12097
aS'            coupling[c][d] = DoFTools::always;'
p12098
aS'          else'
p12099
aS'            coupling[c][d] = DoFTools::none;'
p12100
aS'      DoFTools::make_sparsity_pattern('
p12101
aS'        stokes_dof_handler, coupling, dsp, stokes_constraints, false);'
p12102
aS'      stokes_matrix.reinit(dsp);'
p12103
aS'    }'
p12104
aS'    {'
p12105
aS'      Amg_preconditioner.reset();'
p12106
aS'      Mp_preconditioner.reset();'
p12107
aS'      stokes_preconditioner_matrix.clear();'
p12108
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p12109
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p12110
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p12111
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p12112
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p12113
aS'      dsp.collect_sizes();'
p12114
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p12115
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p12116
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p12117
aS'          if (c == d)'
p12118
aS'            coupling[c][d] = DoFTools::always;'
p12119
aS'          else'
p12120
aS'            coupling[c][d] = DoFTools::none;'
p12121
aS'      DoFTools::make_sparsity_pattern('
p12122
aS'        stokes_dof_handler, coupling, dsp, stokes_constraints, false);'
p12123
aS'      stokes_preconditioner_matrix.reinit(dsp);'
p12124
aS'    }'
p12125
aS'    {'
p12126
aS'      temperature_mass_matrix.clear();'
p12127
aS'      temperature_stiffness_matrix.clear();'
p12128
aS'      temperature_matrix.clear();'
p12129
aS'      DynamicSparsityPattern dsp(n_T, n_T);'
p12130
aS'      DoFTools::make_sparsity_pattern(temperature_dof_handler,'
p12131
aS'                                      dsp,'
p12132
aS'                                      temperature_constraints,'
p12133
aS'                                      false);'
p12134
aS'      temperature_matrix.reinit(dsp);'
p12135
aS'      temperature_mass_matrix.reinit(temperature_matrix);'
p12136
aS'      temperature_stiffness_matrix.reinit(temperature_matrix);'
p12137
aS'    }'
p12138
aS'    IndexSet temperature_partitioning = complete_index_set(n_T);'
p12139
aS'    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);'
p12140
aS'    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);'
p12141
aS'    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);'
p12142
aS'    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);'
p12143
aS'    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);'
p12144
aS'    old_old_temperature_solution.reinit(temperature_partitioning,'
p12145
aS'                                        MPI_COMM_WORLD);'
p12146
aS'    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);'
p12147
aS'  }'
p12148
aS'  template <int dim>'
p12149
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_preconditioner()'
p12150
aS'  {'
p12151
aS'    stokes_preconditioner_matrix = 0;'
p12152
aS'    const QGauss<dim> quadrature_formula(stokes_degree + 2);'
p12153
aS'    FEValues<dim>     stokes_fe_values(stokes_fe,'
p12154
aS'                                   quadrature_formula,'
p12155
aS'                                   update_JxW_values | update_values |'
p12156
aS'                                     update_gradients);'
p12157
aS'    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p12158
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p12159
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p12160
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p12161
aS'    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);'
p12162
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p12163
aS'    const FEValuesExtractors::Vector velocities(0);'
p12164
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p12165
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p12166
aS'      {'
p12167
aS'        stokes_fe_values.reinit(cell);'
p12168
aS'        local_matrix = 0;'
p12169
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p12170
aS'          {'
p12171
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p12172
aS'              {'
p12173
aS'                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);'
p12174
aS'                phi_p[k]      = stokes_fe_values[pressure].value(k, q);'
p12175
aS'              }'
p12176
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p12177
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p12178
aS'                local_matrix(i, j) +='
p12179
aS'                  (EquationData::eta *'
p12180
aS'                     scalar_product(grad_phi_u[i], grad_phi_u[j]) +'
p12181
aS'                   (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *'
p12182
aS'                  stokes_fe_values.JxW(q);'
p12183
aS'          }'
p12184
aS'        cell->get_dof_indices(local_dof_indices);'
p12185
aS'        stokes_constraints.distribute_local_to_global('
p12186
aS'          local_matrix, local_dof_indices, stokes_preconditioner_matrix);'
p12187
aS'      }'
p12188
aS'  }'
p12189
aS'  template <int dim>'
p12190
aS'  void BoussinesqFlowProblem<dim>::build_stokes_preconditioner()'
p12191
aS'  {'
p12192
aS'    if (rebuild_stokes_preconditioner == false)'
p12193
aS'      return;'
p12194
aS'    std::cout << "   Rebuilding Stokes preconditioner..." << std::flush;'
p12195
aS'    assemble_stokes_preconditioner();'
p12196
aS'    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionAMG>();'
p12197
aS'    std::vector<std::vector<bool>> constant_modes;'
p12198
aS'    FEValuesExtractors::Vector     velocity_components(0);'
p12199
aS'    DoFTools::extract_constant_modes(stokes_dof_handler,'
p12200
aS'                                     stokes_fe.component_mask('
p12201
aS'                                       velocity_components),'
p12202
aS'                                     constant_modes);'
p12203
aS'    TrilinosWrappers::PreconditionAMG::AdditionalData amg_data;'
p12204
aS'    amg_data.constant_modes = constant_modes;'
p12205
aS'    amg_data.elliptic              = true;'
p12206
aS'    amg_data.higher_order_elements = true;'
p12207
aS'    amg_data.smoother_sweeps       = 2;'
p12208
aS'    amg_data.aggregation_threshold = 0.02;'
p12209
aS'    Amg_preconditioner->initialize(stokes_preconditioner_matrix.block(0, 0),'
p12210
aS'                                   amg_data);'
p12211
aS'    Mp_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>();'
p12212
aS'    Mp_preconditioner->initialize(stokes_preconditioner_matrix.block(1, 1));'
p12213
aS'    std::cout << std::endl;'
p12214
aS'    rebuild_stokes_preconditioner = false;'
p12215
aS'  }'
p12216
aS'  template <int dim>'
p12217
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_system()'
p12218
aS'  {'
p12219
aS'    std::cout << "   Assembling..." << std::flush;'
p12220
aS'    if (rebuild_stokes_matrix == true)'
p12221
aS'      stokes_matrix = 0;'
p12222
aS'    stokes_rhs = 0;'
p12223
aS'    const QGauss<dim> quadrature_formula(stokes_degree + 2);'
p12224
aS'    FEValues<dim>     stokes_fe_values('
p12225
aS'      stokes_fe,'
p12226
aS'      quadrature_formula,'
p12227
aS'      update_values | update_quadrature_points | update_JxW_values |'
p12228
aS'        (rebuild_stokes_matrix == true ? update_gradients : UpdateFlags(0)));'
p12229
aS'    FEValues<dim> temperature_fe_values(temperature_fe,'
p12230
aS'                                        quadrature_formula,'
p12231
aS'                                        update_values);'
p12232
aS'    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p12233
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p12234
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p12235
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p12236
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p12237
aS'    std::vector<double> old_temperature_values(n_q_points);'
p12238
aS'    std::vector<Tensor<1, dim>>          phi_u(dofs_per_cell);'
p12239
aS'    std::vector<SymmetricTensor<2, dim>> grads_phi_u(dofs_per_cell);'
p12240
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p12241
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p12242
aS'    const FEValuesExtractors::Vector velocities(0);'
p12243
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p12244
aS'    auto       cell             = stokes_dof_handler.begin_active();'
p12245
aS'    const auto endc             = stokes_dof_handler.end();'
p12246
aS'    auto       temperature_cell = temperature_dof_handler.begin_active();'
p12247
aS'    for (; cell != endc; ++cell, ++temperature_cell)'
p12248
aS'      {'
p12249
aS'        stokes_fe_values.reinit(cell);'
p12250
aS'        temperature_fe_values.reinit(temperature_cell);'
p12251
aS'        local_matrix = 0;'
p12252
aS'        local_rhs    = 0;'
p12253
aS'        temperature_fe_values.get_function_values(old_temperature_solution,'
p12254
aS'                                                  old_temperature_values);'
p12255
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p12256
aS'          {'
p12257
aS'            const double old_temperature = old_temperature_values[q];'
p12258
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p12259
aS'              {'
p12260
aS'                phi_u[k] = stokes_fe_values[velocities].value(k, q);'
p12261
aS'                if (rebuild_stokes_matrix)'
p12262
aS'                  {'
p12263
aS'                    grads_phi_u[k] ='
p12264
aS'                      stokes_fe_values[velocities].symmetric_gradient(k, q);'
p12265
aS'                    div_phi_u[k] ='
p12266
aS'                      stokes_fe_values[velocities].divergence(k, q);'
p12267
aS'                    phi_p[k] = stokes_fe_values[pressure].value(k, q);'
p12268
aS'                  }'
p12269
aS'              }'
p12270
aS'            if (rebuild_stokes_matrix)'
p12271
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p12272
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p12273
aS'                  local_matrix(i, j) +='
p12274
aS'                    (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -'
p12275
aS'                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p12276
aS'                    stokes_fe_values.JxW(q);'
p12277
aS'            const Point<dim> gravity ='
p12278
aS'              -((dim == 2) ? (Point<dim>(0, 1)) : (Point<dim>(0, 0, 1)));'
p12279
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p12280
aS'              local_rhs(i) += (-EquationData::density * EquationData::beta *'
p12281
aS'                               gravity * phi_u[i] * old_temperature) *'
p12282
aS'                              stokes_fe_values.JxW(q);'
p12283
aS'          }'
p12284
aS'        cell->get_dof_indices(local_dof_indices);'
p12285
aS'        if (rebuild_stokes_matrix == true)'
p12286
aS'          stokes_constraints.distribute_local_to_global(local_matrix,'
p12287
aS'                                                        local_rhs,'
p12288
aS'                                                        local_dof_indices,'
p12289
aS'                                                        stokes_matrix,'
p12290
aS'                                                        stokes_rhs);'
p12291
aS'        else'
p12292
aS'          stokes_constraints.distribute_local_to_global(local_rhs,'
p12293
aS'                                                        local_dof_indices,'
p12294
aS'                                                        stokes_rhs);'
p12295
aS'      }'
p12296
aS'    rebuild_stokes_matrix = false;'
p12297
aS'    std::cout << std::endl;'
p12298
aS'  }'
p12299
aS'  template <int dim>'
p12300
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_matrix()'
p12301
aS'  {'
p12302
aS'    if (rebuild_temperature_matrices == false)'
p12303
aS'      return;'
p12304
aS'    temperature_mass_matrix      = 0;'
p12305
aS'    temperature_stiffness_matrix = 0;'
p12306
aS'    QGauss<dim>   quadrature_formula(temperature_degree + 2);'
p12307
aS'    FEValues<dim> temperature_fe_values(temperature_fe,'
p12308
aS'                                        quadrature_formula,'
p12309
aS'                                        update_values | update_gradients |'
p12310
aS'                                          update_JxW_values);'
p12311
aS'    const unsigned int dofs_per_cell = temperature_fe.n_dofs_per_cell();'
p12312
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p12313
aS'    FullMatrix<double> local_mass_matrix(dofs_per_cell, dofs_per_cell);'
p12314
aS'    FullMatrix<double> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);'
p12315
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p12316
aS'    std::vector<double>         phi_T(dofs_per_cell);'
p12317
aS'    std::vector<Tensor<1, dim>> grad_phi_T(dofs_per_cell);'
p12318
aS'    for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p12319
aS'      {'
p12320
aS'        local_mass_matrix      = 0;'
p12321
aS'        local_stiffness_matrix = 0;'
p12322
aS'        temperature_fe_values.reinit(cell);'
p12323
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p12324
aS'          {'
p12325
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p12326
aS'              {'
p12327
aS'                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);'
p12328
aS'                phi_T[k]      = temperature_fe_values.shape_value(k, q);'
p12329
aS'              }'
p12330
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p12331
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p12332
aS'                {'
p12333
aS'                  local_mass_matrix(i, j) +='
p12334
aS'                    (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));'
p12335
aS'                  local_stiffness_matrix(i, j) +='
p12336
aS'                    (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *'
p12337
aS'                     temperature_fe_values.JxW(q));'
p12338
aS'                }'
p12339
aS'          }'
p12340
aS'        cell->get_dof_indices(local_dof_indices);'
p12341
aS'        temperature_constraints.distribute_local_to_global('
p12342
aS'          local_mass_matrix, local_dof_indices, temperature_mass_matrix);'
p12343
aS'        temperature_constraints.distribute_local_to_global('
p12344
aS'          local_stiffness_matrix,'
p12345
aS'          local_dof_indices,'
p12346
aS'          temperature_stiffness_matrix);'
p12347
aS'      }'
p12348
aS'    rebuild_temperature_matrices = false;'
p12349
aS'  }'
p12350
aS'  template <int dim>'
p12351
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_system('
p12352
aS'    const double maximal_velocity)'
p12353
aS'  {'
p12354
aS'    const bool use_bdf2_scheme = (timestep_number != 0);'
p12355
aS'    if (use_bdf2_scheme == true)'
p12356
aS'      {'
p12357
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p12358
aS'        temperature_matrix *='
p12359
aS'          (2 * time_step + old_time_step) / (time_step + old_time_step);'
p12360
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p12361
aS'      }'
p12362
aS'    else'
p12363
aS'      {'
p12364
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p12365
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p12366
aS'      }'
p12367
aS'    temperature_rhs = 0;'
p12368
aS'    const QGauss<dim> quadrature_formula(temperature_degree + 2);'
p12369
aS'    FEValues<dim>     temperature_fe_values(temperature_fe,'
p12370
aS'                                        quadrature_formula,'
p12371
aS'                                        update_values | update_gradients |'
p12372
aS'                                          update_hessians |'
p12373
aS'                                          update_quadrature_points |'
p12374
aS'                                          update_JxW_values);'
p12375
aS'    FEValues<dim>     stokes_fe_values(stokes_fe,'
p12376
aS'                                   quadrature_formula,'
p12377
aS'                                   update_values);'
p12378
aS'    const unsigned int dofs_per_cell = temperature_fe.n_dofs_per_cell();'
p12379
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p12380
aS'    Vector<double> local_rhs(dofs_per_cell);'
p12381
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p12382
aS'    std::vector<Tensor<1, dim>> old_velocity_values(n_q_points);'
p12383
aS'    std::vector<Tensor<1, dim>> old_old_velocity_values(n_q_points);'
p12384
aS'    std::vector<double>         old_temperature_values(n_q_points);'
p12385
aS'    std::vector<double>         old_old_temperature_values(n_q_points);'
p12386
aS'    std::vector<Tensor<1, dim>> old_temperature_grads(n_q_points);'
p12387
aS'    std::vector<Tensor<1, dim>> old_old_temperature_grads(n_q_points);'
p12388
aS'    std::vector<double>         old_temperature_laplacians(n_q_points);'
p12389
aS'    std::vector<double>         old_old_temperature_laplacians(n_q_points);'
p12390
aS'    EquationData::TemperatureRightHandSide<dim> temperature_right_hand_side;'
p12391
aS'    std::vector<double>                         gamma_values(n_q_points);'
p12392
aS'    std::vector<double>         phi_T(dofs_per_cell);'
p12393
aS'    std::vector<Tensor<1, dim>> grad_phi_T(dofs_per_cell);'
p12394
aS'    const std::pair<double, double> global_T_range ='
p12395
aS'      get_extrapolated_temperature_range();'
p12396
aS'    const FEValuesExtractors::Vector velocities(0);'
p12397
aS'    auto       cell        = temperature_dof_handler.begin_active();'
p12398
aS'    const auto endc        = temperature_dof_handler.end();'
p12399
aS'    auto       stokes_cell = stokes_dof_handler.begin_active();'
p12400
aS'    for (; cell != endc; ++cell, ++stokes_cell)'
p12401
aS'      {'
p12402
aS'        local_rhs = 0;'
p12403
aS'        temperature_fe_values.reinit(cell);'
p12404
aS'        stokes_fe_values.reinit(stokes_cell);'
p12405
aS'        temperature_fe_values.get_function_values(old_temperature_solution,'
p12406
aS'                                                  old_temperature_values);'
p12407
aS'        temperature_fe_values.get_function_values(old_old_temperature_solution,'
p12408
aS'                                                  old_old_temperature_values);'
p12409
aS'        temperature_fe_values.get_function_gradients(old_temperature_solution,'
p12410
aS'                                                     old_temperature_grads);'
p12411
aS'        temperature_fe_values.get_function_gradients('
p12412
aS'          old_old_temperature_solution, old_old_temperature_grads);'
p12413
aS'        temperature_fe_values.get_function_laplacians('
p12414
aS'          old_temperature_solution, old_temperature_laplacians);'
p12415
aS'        temperature_fe_values.get_function_laplacians('
p12416
aS'          old_old_temperature_solution, old_old_temperature_laplacians);'
p12417
aS'        temperature_right_hand_side.value_list('
p12418
aS'          temperature_fe_values.get_quadrature_points(), gamma_values);'
p12419
aS'        stokes_fe_values[velocities].get_function_values(stokes_solution,'
p12420
aS'                                                         old_velocity_values);'
p12421
aS'        stokes_fe_values[velocities].get_function_values('
p12422
aS'          old_stokes_solution, old_old_velocity_values);'
p12423
aS'        const double nu ='
p12424
aS'          compute_viscosity(old_temperature_values,'
p12425
aS'                            old_old_temperature_values,'
p12426
aS'                            old_temperature_grads,'
p12427
aS'                            old_old_temperature_grads,'
p12428
aS'                            old_temperature_laplacians,'
p12429
aS'                            old_old_temperature_laplacians,'
p12430
aS'                            old_velocity_values,'
p12431
aS'                            old_old_velocity_values,'
p12432
aS'                            gamma_values,'
p12433
aS'                            maximal_velocity,'
p12434
aS'                            global_T_range.second - global_T_range.first,'
p12435
aS'                            cell->diameter());'
p12436
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p12437
aS'          {'
p12438
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p12439
aS'              {'
p12440
aS'                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);'
p12441
aS'                phi_T[k]      = temperature_fe_values.shape_value(k, q);'
p12442
aS'              }'
p12443
aS'            const double T_term_for_rhs ='
p12444
aS'              (use_bdf2_scheme ?'
p12445
aS'                 (old_temperature_values[q] * (1 + time_step / old_time_step) -'
p12446
aS'                  old_old_temperature_values[q] * (time_step * time_step) /'
p12447
aS'                    (old_time_step * (time_step + old_time_step))) :'
p12448
aS'                 old_temperature_values[q]);'
p12449
aS'            const Tensor<1, dim> ext_grad_T ='
p12450
aS'              (use_bdf2_scheme ?'
p12451
aS'                 (old_temperature_grads[q] * (1 + time_step / old_time_step) -'
p12452
aS'                  old_old_temperature_grads[q] * time_step / old_time_step) :'
p12453
aS'                 old_temperature_grads[q]);'
p12454
aS'            const Tensor<1, dim> extrapolated_u ='
p12455
aS'              (use_bdf2_scheme ?'
p12456
aS'                 (old_velocity_values[q] * (1 + time_step / old_time_step) -'
p12457
aS'                  old_old_velocity_values[q] * time_step / old_time_step) :'
p12458
aS'                 old_velocity_values[q]);'
p12459
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p12460
aS'              local_rhs(i) +='
p12461
aS'                (T_term_for_rhs * phi_T[i] -'
p12462
aS'                 time_step * extrapolated_u * ext_grad_T * phi_T[i] -'
p12463
aS'                 time_step * nu * ext_grad_T * grad_phi_T[i] +'
p12464
aS'                 time_step * gamma_values[q] * phi_T[i]) *'
p12465
aS'                temperature_fe_values.JxW(q);'
p12466
aS'          }'
p12467
aS'        cell->get_dof_indices(local_dof_indices);'
p12468
aS'        temperature_constraints.distribute_local_to_global(local_rhs,'
p12469
aS'                                                           local_dof_indices,'
p12470
aS'                                                           temperature_rhs);'
p12471
aS'      }'
p12472
aS'  }'
p12473
aS'  template <int dim>'
p12474
aS'  void BoussinesqFlowProblem<dim>::solve()'
p12475
aS'  {'
p12476
aS'    std::cout << "   Solving..." << std::endl;'
p12477
aS'    {'
p12478
aS'      const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix,'
p12479
aS'                                         TrilinosWrappers::PreconditionIC>'
p12480
aS'        mp_inverse(stokes_preconditioner_matrix.block(1, 1),'
p12481
aS'                   *Mp_preconditioner);'
p12482
aS'      const LinearSolvers::BlockSchurPreconditioner<'
p12483
aS'        TrilinosWrappers::PreconditionAMG,'
p12484
aS'        TrilinosWrappers::PreconditionIC>'
p12485
aS'        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);'
p12486
aS'      SolverControl solver_control(stokes_matrix.m(),'
p12487
aS'                                   1e-6 * stokes_rhs.l2_norm());'
p12488
aS'      SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres('
p12489
aS'        solver_control,'
p12490
aS'        SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData(100));'
p12491
aS'      for (unsigned int i = 0; i < stokes_solution.size(); ++i)'
p12492
aS'        if (stokes_constraints.is_constrained(i))'
p12493
aS'          stokes_solution(i) = 0;'
p12494
aS'      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);'
p12495
aS'      stokes_constraints.distribute(stokes_solution);'
p12496
aS'      std::cout << "   " << solver_control.last_step()'
p12497
aS'                << " GMRES iterations for Stokes subsystem." << std::endl;'
p12498
aS'    }'
p12499
aS'    old_time_step                 = time_step;'
p12500
aS'    const double maximal_velocity = get_maximal_velocity();'
p12501
aS'    if (maximal_velocity >= 0.01)'
p12502
aS'      time_step = 1. / (1.7 * dim * std::sqrt(1. * dim)) / temperature_degree *'
p12503
aS'                  GridTools::minimal_cell_diameter(triangulation) /'
p12504
aS'                  maximal_velocity;'
p12505
aS'    else'
p12506
aS'      time_step = 1. / (1.7 * dim * std::sqrt(1. * dim)) / temperature_degree *'
p12507
aS'                  GridTools::minimal_cell_diameter(triangulation) / .01;'
p12508
aS'    std::cout << "   "'
p12509
aS'              << "Time step: " << time_step << std::endl;'
p12510
aS'    temperature_solution = old_temperature_solution;'
p12511
aS'    assemble_temperature_system(maximal_velocity);'
p12512
aS'    {'
p12513
aS'      SolverControl solver_control(temperature_matrix.m(),'
p12514
aS'                                   1e-8 * temperature_rhs.l2_norm());'
p12515
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p12516
aS'      TrilinosWrappers::PreconditionIC preconditioner;'
p12517
aS'      preconditioner.initialize(temperature_matrix);'
p12518
aS'      cg.solve(temperature_matrix,'
p12519
aS'               temperature_solution,'
p12520
aS'               temperature_rhs,'
p12521
aS'               preconditioner);'
p12522
aS'      temperature_constraints.distribute(temperature_solution);'
p12523
aS'      std::cout << "   " << solver_control.last_step()'
p12524
aS'                << " CG iterations for temperature." << std::endl;'
p12525
aS'      double min_temperature = temperature_solution(0),'
p12526
aS'             max_temperature = temperature_solution(0);'
p12527
aS'      for (unsigned int i = 0; i < temperature_solution.size(); ++i)'
p12528
aS'        {'
p12529
aS'          min_temperature ='
p12530
aS'            std::min<double>(min_temperature, temperature_solution(i));'
p12531
aS'          max_temperature ='
p12532
aS'            std::max<double>(max_temperature, temperature_solution(i));'
p12533
aS'        }'
p12534
aS'      std::cout << "   Temperature range: " << min_temperature << \' \''
p12535
aS'                << max_temperature << std::endl;'
p12536
aS'    }'
p12537
aS'  }'
p12538
aS'  template <int dim>'
p12539
aS'  void BoussinesqFlowProblem<dim>::output_results() const'
p12540
aS'  {'
p12541
aS'    if (timestep_number % 10 != 0)'
p12542
aS'      return;'
p12543
aS'    std::vector<std::string> stokes_names(dim, "velocity");'
p12544
aS'    stokes_names.emplace_back("p");'
p12545
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p12546
aS'      stokes_component_interpretation('
p12547
aS'        dim + 1, DataComponentInterpretation::component_is_scalar);'
p12548
aS'    for (unsigned int i = 0; i < dim; ++i)'
p12549
aS'      stokes_component_interpretation[i] ='
p12550
aS'        DataComponentInterpretation::component_is_part_of_vector;'
p12551
aS'    DataOut<dim> data_out;'
p12552
aS'    data_out.add_data_vector(stokes_dof_handler,'
p12553
aS'                             stokes_solution,'
p12554
aS'                             stokes_names,'
p12555
aS'                             stokes_component_interpretation);'
p12556
aS'    data_out.add_data_vector(temperature_dof_handler,'
p12557
aS'                             temperature_solution,'
p12558
aS'                             "T");'
p12559
aS'    data_out.build_patches(std::min(stokes_degree, temperature_degree));'
p12560
aS'    std::ofstream output("solution-" +'
p12561
aS'                         Utilities::int_to_string(timestep_number, 4) + ".vtk");'
p12562
aS'    data_out.write_vtk(output);'
p12563
aS'  }'
p12564
aS'  template <int dim>'
p12565
aS'  void'
p12566
aS'  BoussinesqFlowProblem<dim>::refine_mesh(const unsigned int max_grid_level)'
p12567
aS'  {'
p12568
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p12569
aS'    KellyErrorEstimator<dim>::estimate(temperature_dof_handler,'
p12570
aS'                                       QGauss<dim - 1>(temperature_degree + 1),'
p12571
aS'                                       {},'
p12572
aS'                                       temperature_solution,'
p12573
aS'                                       estimated_error_per_cell);'
p12574
aS'    GridRefinement::refine_and_coarsen_fixed_fraction(triangulation,'
p12575
aS'                                                      estimated_error_per_cell,'
p12576
aS'                                                      0.8,'
p12577
aS'                                                      0.1);'
p12578
aS'    if (triangulation.n_levels() > max_grid_level)'
p12579
aS'      for (auto &cell :'
p12580
aS'           triangulation.active_cell_iterators_on_level(max_grid_level))'
p12581
aS'        cell->clear_refine_flag();'
p12582
aS'    std::vector<TrilinosWrappers::MPI::Vector> x_temperature(2);'
p12583
aS'    x_temperature[0]                            = temperature_solution;'
p12584
aS'    x_temperature[1]                            = old_temperature_solution;'
p12585
aS'    TrilinosWrappers::MPI::BlockVector x_stokes = stokes_solution;'
p12586
aS'    SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> temperature_trans('
p12587
aS'      temperature_dof_handler);'
p12588
aS'    SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> stokes_trans('
p12589
aS'      stokes_dof_handler);'
p12590
aS'    triangulation.prepare_coarsening_and_refinement();'
p12591
aS'    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);'
p12592
aS'    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);'
p12593
aS'    triangulation.execute_coarsening_and_refinement();'
p12594
aS'    setup_dofs();'
p12595
aS'    std::vector<TrilinosWrappers::MPI::Vector> tmp(2);'
p12596
aS'    tmp[0].reinit(temperature_solution);'
p12597
aS'    tmp[1].reinit(temperature_solution);'
p12598
aS'    temperature_trans.interpolate(x_temperature, tmp);'
p12599
aS'    temperature_solution     = tmp[0];'
p12600
aS'    old_temperature_solution = tmp[1];'
p12601
aS'    temperature_constraints.distribute(temperature_solution);'
p12602
aS'    temperature_constraints.distribute(old_temperature_solution);'
p12603
aS'    stokes_trans.interpolate(x_stokes, stokes_solution);'
p12604
aS'    stokes_constraints.distribute(stokes_solution);'
p12605
aS'    rebuild_stokes_matrix         = true;'
p12606
aS'    rebuild_temperature_matrices  = true;'
p12607
aS'    rebuild_stokes_preconditioner = true;'
p12608
aS'  }'
p12609
aS'  template <int dim>'
p12610
aS'  void BoussinesqFlowProblem<dim>::run()'
p12611
aS'  {'
p12612
aS'    const unsigned int initial_refinement     = (dim == 2 ? 4 : 2);'
p12613
aS'    const unsigned int n_pre_refinement_steps = (dim == 2 ? 4 : 3);'
p12614
aS'    GridGenerator::hyper_cube(triangulation);'
p12615
aS'    global_Omega_diameter = GridTools::diameter(triangulation);'
p12616
aS'    triangulation.refine_global(initial_refinement);'
p12617
aS'    setup_dofs();'
p12618
aS'    unsigned int pre_refinement_step = 0;'
p12619
aS'  start_time_iteration:'
p12620
aS'    VectorTools::project(temperature_dof_handler,'
p12621
aS'                         temperature_constraints,'
p12622
aS'                         QGauss<dim>(temperature_degree + 2),'
p12623
aS'                         EquationData::TemperatureInitialValues<dim>(),'
p12624
aS'                         old_temperature_solution);'
p12625
aS'    timestep_number = 0;'
p12626
aS'    time_step = old_time_step = 0;'
p12627
aS'    double time = 0;'
p12628
aS'    do'
p12629
aS'      {'
p12630
aS'        std::cout << "Timestep " << timestep_number << ":  t=" << time'
p12631
aS'                  << std::endl;'
p12632
aS'        assemble_stokes_system();'
p12633
aS'        build_stokes_preconditioner();'
p12634
aS'        assemble_temperature_matrix();'
p12635
aS'        solve();'
p12636
aS'        output_results();'
p12637
aS'        std::cout << std::endl;'
p12638
aS'        if ((timestep_number == 0) &&'
p12639
aS'            (pre_refinement_step < n_pre_refinement_steps))'
p12640
aS'          {'
p12641
aS'            refine_mesh(initial_refinement + n_pre_refinement_steps);'
p12642
aS'            ++pre_refinement_step;'
p12643
aS'            goto start_time_iteration;'
p12644
aS'          }'
p12645
aS'        else if ((timestep_number > 0) && (timestep_number % 5 == 0))'
p12646
aS'          refine_mesh(initial_refinement + n_pre_refinement_steps);'
p12647
aS'        time += time_step;'
p12648
aS'        ++timestep_number;'
p12649
aS'        old_stokes_solution          = stokes_solution;'
p12650
aS'        old_old_temperature_solution = old_temperature_solution;'
p12651
aS'        old_temperature_solution     = temperature_solution;'
p12652
aS'      }'
p12653
aS'    while (time <= 100);'
p12654
aS'  }'
p12655
aS'} // namespace Step31'
p12656
aS'int main(int argc, char *argv[])'
p12657
ag24
aS'  try'
p12658
aS'    {'
p12659
aS'      using namespace dealii;'
p12660
aS'      using namespace Step31;'
p12661
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p12662
aS'        argc, argv, numbers::invalid_unsigned_int);'
p12663
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p12664
aS'                  ExcMessage('
p12665
aS'                    "This program can only be run in serial, use ./step-31"));'
p12666
aS'      BoussinesqFlowProblem<2> flow_problem;'
p12667
aS'      flow_problem.run();'
p12668
aS'    }'
p12669
aS'  catch (std::exception &exc)'
p12670
aS'    {'
p12671
aS'      std::cerr << std::endl'
p12672
aS'                << std::endl'
p12673
aS'                << "----------------------------------------------------"'
p12674
aS'                << std::endl;'
p12675
aS'      std::cerr << "Exception on processing: " << std::endl'
p12676
aS'                << exc.what() << std::endl'
p12677
aS'                << "Aborting!" << std::endl'
p12678
aS'                << "----------------------------------------------------"'
p12679
aS'                << std::endl;'
p12680
aS'      return 1;'
p12681
aS'    }'
p12682
aS'  catch (...)'
p12683
aS'    {'
p12684
aS'      std::cerr << std::endl'
p12685
aS'                << std::endl'
p12686
aS'                << "----------------------------------------------------"'
p12687
aS'                << std::endl;'
p12688
aS'      std::cerr << "Unknown exception!" << std::endl'
p12689
aS'                << "Aborting!" << std::endl'
p12690
aS'                << "----------------------------------------------------"'
p12691
aS'                << std::endl;'
p12692
aS'      return 1;'
p12693
aS'    }'
p12694
aS'  return 0;'
p12695
ag32
aS'/* ---------------------------------------------------------------------'
p12696
aS' *'
p12697
aS' * Copyright (C) 2008 - 2021 by the deal.II authors'
p12698
aS' *'
p12699
aS' * This file is part of the deal.II library.'
p12700
aS' *'
p12701
aS' * The deal.II library is free software; you can use it, redistribute'
p12702
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p12703
aS' * Public License as published by the Free Software Foundation; either'
p12704
aS' * version 2.1 of the License, or (at your option) any later version.'
p12705
aS' * The full text of the license can be found in the file LICENSE.md at'
p12706
aS' * the top level directory of deal.II.'
p12707
aS' *'
p12708
aS' * ---------------------------------------------------------------------'
p12709
aS' *'
p12710
aS' * Authors: Martin Kronbichler, Uppsala University,'
p12711
aS' *          Wolfgang Bangerth, Texas A&M University,'
p12712
aS' *          Timo Heister, University of Goettingen, 2008-2011'
p12713
aS' */'
p12714
aS'#include <deal.II/base/quadrature_lib.h>'
p12715
aS'#include <deal.II/base/logstream.h>'
p12716
aS'#include <deal.II/base/function.h>'
p12717
aS'#include <deal.II/base/utilities.h>'
p12718
aS'#include <deal.II/base/conditional_ostream.h>'
p12719
aS'#include <deal.II/base/work_stream.h>'
p12720
aS'#include <deal.II/base/timer.h>'
p12721
aS'#include <deal.II/base/parameter_handler.h>'
p12722
aS'#include <deal.II/lac/full_matrix.h>'
p12723
aS'#include <deal.II/lac/solver_bicgstab.h>'
p12724
aS'#include <deal.II/lac/solver_cg.h>'
p12725
aS'#include <deal.II/lac/solver_gmres.h>'
p12726
aS'#include <deal.II/lac/affine_constraints.h>'
p12727
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p12728
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p12729
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p12730
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p12731
aS'#include <deal.II/lac/trilinos_precondition.h>'
p12732
aS'#include <deal.II/lac/trilinos_solver.h>'
p12733
aS'#include <deal.II/grid/tria.h>'
p12734
aS'#include <deal.II/grid/grid_generator.h>'
p12735
aS'#include <deal.II/grid/filtered_iterator.h>'
p12736
aS'#include <deal.II/grid/manifold_lib.h>'
p12737
aS'#include <deal.II/grid/grid_tools.h>'
p12738
aS'#include <deal.II/grid/grid_refinement.h>'
p12739
aS'#include <deal.II/dofs/dof_handler.h>'
p12740
aS'#include <deal.II/dofs/dof_renumbering.h>'
p12741
aS'#include <deal.II/dofs/dof_tools.h>'
p12742
aS'#include <deal.II/fe/fe_q.h>'
p12743
aS'#include <deal.II/fe/fe_dgq.h>'
p12744
aS'#include <deal.II/fe/fe_dgp.h>'
p12745
aS'#include <deal.II/fe/fe_system.h>'
p12746
aS'#include <deal.II/fe/fe_values.h>'
p12747
aS'#include <deal.II/fe/mapping_q.h>'
p12748
aS'#include <deal.II/numerics/vector_tools.h>'
p12749
aS'#include <deal.II/numerics/matrix_tools.h>'
p12750
aS'#include <deal.II/numerics/data_out.h>'
p12751
aS'#include <deal.II/numerics/error_estimator.h>'
p12752
aS'#include <deal.II/numerics/solution_transfer.h>'
p12753
aS'#include <fstream>'
p12754
aS'#include <iostream>'
p12755
aS'#include <limits>'
p12756
aS'#include <locale>'
p12757
aS'#include <string>'
p12758
aS'#include <deal.II/distributed/solution_transfer.h>'
p12759
aS'#include <deal.II/base/index_set.h>'
p12760
aS'#include <deal.II/distributed/tria.h>'
p12761
aS'#include <deal.II/distributed/grid_refinement.h>'
p12762
aS'namespace Step32'
p12763
ag24
aS'  using namespace dealii;'
p12764
aS'  namespace EquationData'
p12765
aS'  {'
p12766
aS'    constexpr double eta                   = 1e21;    /* Pa s       */'
p12767
aS'    constexpr double kappa                 = 1e-6;    /* m^2 / s    */'
p12768
aS'    constexpr double reference_density     = 3300;    /* kg / m^3   */'
p12769
aS'    constexpr double reference_temperature = 293;     /* K          */'
p12770
aS'    constexpr double expansion_coefficient = 2e-5;    /* 1/K        */'
p12771
aS'    constexpr double specific_heat         = 1250;    /* J / K / kg */'
p12772
aS'    constexpr double radiogenic_heating    = 7.4e-12; /* W / kg     */'
p12773
aS'    constexpr double R0 = 6371000. - 2890000.; /* m          */'
p12774
aS'    constexpr double R1 = 6371000. - 35000.;   /* m          */'
p12775
aS'    constexpr double T0 = 4000 + 273; /* K          */'
p12776
aS'    constexpr double T1 = 700 + 273;  /* K          */'
p12777
aS'    double density(const double temperature)'
p12778
aS'    {'
p12779
aS'      return ('
p12780
aS'        reference_density *'
p12781
aS'        (1 - expansion_coefficient * (temperature - reference_temperature)));'
p12782
aS'    }'
p12783
aS'    template <int dim>'
p12784
aS'    Tensor<1, dim> gravity_vector(const Point<dim> &p)'
p12785
aS'    {'
p12786
aS'      const double r = p.norm();'
p12787
aS'      return -(1.245e-6 * r + 7.714e13 / r / r) * p / r;'
p12788
aS'    }'
p12789
aS'    template <int dim>'
p12790
aS'    class TemperatureInitialValues : public Function<dim>'
p12791
aS'    {'
p12792
aS'    public:'
p12793
aS'      TemperatureInitialValues()'
p12794
aS'        : Function<dim>(1)'
p12795
aS'      {}'
p12796
aS'      virtual double value(const Point<dim> & p,'
p12797
aS'                           const unsigned int component = 0) const override;'
p12798
aS'      virtual void vector_value(const Point<dim> &p,'
p12799
aS'                                Vector<double> &  value) const override;'
p12800
aS'    };'
p12801
aS'    template <int dim>'
p12802
aS'    double TemperatureInitialValues<dim>::value(const Point<dim> &p,'
p12803
aS'                                                const unsigned int) const'
p12804
aS'    {'
p12805
aS'      const double r = p.norm();'
p12806
aS'      const double h = R1 - R0;'
p12807
aS'      const double s = (r - R0) / h;'
p12808
aS'      const double q ='
p12809
aS'        (dim == 3) ? std::max(0.0, cos(numbers::PI * abs(p(2) / R1))) : 1.0;'
p12810
aS'      const double phi = std::atan2(p(0), p(1));'
p12811
aS'      const double tau = s + 0.2 * s * (1 - s) * std::sin(6 * phi) * q;'
p12812
aS'      return T0 * (1.0 - tau) + T1 * tau;'
p12813
aS'    }'
p12814
aS'    template <int dim>'
p12815
aS'    void'
p12816
aS'    TemperatureInitialValues<dim>::vector_value(const Point<dim> &p,'
p12817
aS'                                                Vector<double> &  values) const'
p12818
aS'    {'
p12819
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p12820
aS'        values(c) = TemperatureInitialValues<dim>::value(p, c);'
p12821
aS'    }'
p12822
aS'    constexpr double pressure_scaling = eta / 10000;'
p12823
aS'    const double year_in_seconds = 60 * 60 * 24 * 365.2425;'
p12824
aS'  } // namespace EquationData'
p12825
aS'  namespace LinearSolvers'
p12826
aS'  {'
p12827
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p12828
aS'    class BlockSchurPreconditioner : public Subscriptor'
p12829
aS'    {'
p12830
aS'    public:'
p12831
aS'      BlockSchurPreconditioner(const TrilinosWrappers::BlockSparseMatrix &S,'
p12832
aS'                               const TrilinosWrappers::BlockSparseMatrix &Spre,'
p12833
aS'                               const PreconditionerTypeMp &Mppreconditioner,'
p12834
aS'                               const PreconditionerTypeA & Apreconditioner,'
p12835
aS'                               const bool                  do_solve_A)'
p12836
aS'        : stokes_matrix(&S)'
p12837
aS'        , stokes_preconditioner_matrix(&Spre)'
p12838
aS'        , mp_preconditioner(Mppreconditioner)'
p12839
aS'        , a_preconditioner(Apreconditioner)'
p12840
aS'        , do_solve_A(do_solve_A)'
p12841
aS'      {}'
p12842
aS'      void vmult(TrilinosWrappers::MPI::BlockVector &      dst,'
p12843
aS'                 const TrilinosWrappers::MPI::BlockVector &src) const'
p12844
aS'      {'
p12845
aS'        TrilinosWrappers::MPI::Vector utmp(src.block(0));'
p12846
aS'        {'
p12847
aS'          SolverControl solver_control(5000, 1e-6 * src.block(1).l2_norm());'
p12848
aS'          SolverCG<TrilinosWrappers::MPI::Vector> solver(solver_control);'
p12849
aS'          solver.solve(stokes_preconditioner_matrix->block(1, 1),'
p12850
aS'                       dst.block(1),'
p12851
aS'                       src.block(1),'
p12852
aS'                       mp_preconditioner);'
p12853
aS'          dst.block(1) *= -1.0;'
p12854
aS'        }'
p12855
aS'        {'
p12856
aS'          stokes_matrix->block(0, 1).vmult(utmp, dst.block(1));'
p12857
aS'          utmp *= -1.0;'
p12858
aS'          utmp.add(src.block(0));'
p12859
aS'        }'
p12860
aS'        if (do_solve_A == true)'
p12861
aS'          {'
p12862
aS'            SolverControl solver_control(5000, utmp.l2_norm() * 1e-2);'
p12863
aS'            TrilinosWrappers::SolverCG solver(solver_control);'
p12864
aS'            solver.solve(stokes_matrix->block(0, 0),'
p12865
aS'                         dst.block(0),'
p12866
aS'                         utmp,'
p12867
aS'                         a_preconditioner);'
p12868
aS'          }'
p12869
aS'        else'
p12870
aS'          a_preconditioner.vmult(dst.block(0), utmp);'
p12871
aS'      }'
p12872
aS'    private:'
p12873
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p12874
aS'        stokes_matrix;'
p12875
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p12876
aS'                                  stokes_preconditioner_matrix;'
p12877
aS'      const PreconditionerTypeMp &mp_preconditioner;'
p12878
aS'      const PreconditionerTypeA & a_preconditioner;'
p12879
aS'      const bool                  do_solve_A;'
p12880
aS'    };'
p12881
aS'  } // namespace LinearSolvers'
p12882
aS'  namespace Assembly'
p12883
aS'  {'
p12884
aS'    namespace Scratch'
p12885
aS'    {'
p12886
aS'      template <int dim>'
p12887
aS'      struct StokesPreconditioner'
p12888
aS'      {'
p12889
aS'        StokesPreconditioner(const FiniteElement<dim> &stokes_fe,'
p12890
aS'                             const Quadrature<dim> &   stokes_quadrature,'
p12891
aS'                             const Mapping<dim> &      mapping,'
p12892
aS'                             const UpdateFlags         update_flags);'
p12893
aS'        StokesPreconditioner(const StokesPreconditioner &data);'
p12894
aS'        FEValues<dim> stokes_fe_values;'
p12895
aS'        std::vector<Tensor<2, dim>> grad_phi_u;'
p12896
aS'        std::vector<double>         phi_p;'
p12897
aS'      };'
p12898
aS'      template <int dim>'
p12899
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p12900
aS'        const FiniteElement<dim> &stokes_fe,'
p12901
aS'        const Quadrature<dim> &   stokes_quadrature,'
p12902
aS'        const Mapping<dim> &      mapping,'
p12903
aS'        const UpdateFlags         update_flags)'
p12904
aS'        : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags)'
p12905
aS'        , grad_phi_u(stokes_fe.n_dofs_per_cell())'
p12906
aS'        , phi_p(stokes_fe.n_dofs_per_cell())'
p12907
aS'      {}'
p12908
aS'      template <int dim>'
p12909
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p12910
aS'        const StokesPreconditioner &scratch)'
p12911
aS'        : stokes_fe_values(scratch.stokes_fe_values.get_mapping(),'
p12912
aS'                           scratch.stokes_fe_values.get_fe(),'
p12913
aS'                           scratch.stokes_fe_values.get_quadrature(),'
p12914
aS'                           scratch.stokes_fe_values.get_update_flags())'
p12915
aS'        , grad_phi_u(scratch.grad_phi_u)'
p12916
aS'        , phi_p(scratch.phi_p)'
p12917
aS'      {}'
p12918
aS'      template <int dim>'
p12919
aS'      struct StokesSystem : public StokesPreconditioner<dim>'
p12920
aS'      {'
p12921
aS'        StokesSystem(const FiniteElement<dim> &stokes_fe,'
p12922
aS'                     const Mapping<dim> &      mapping,'
p12923
aS'                     const Quadrature<dim> &   stokes_quadrature,'
p12924
aS'                     const UpdateFlags         stokes_update_flags,'
p12925
aS'                     const FiniteElement<dim> &temperature_fe,'
p12926
aS'                     const UpdateFlags         temperature_update_flags);'
p12927
aS'        StokesSystem(const StokesSystem<dim> &data);'
p12928
aS'        FEValues<dim> temperature_fe_values;'
p12929
aS'        std::vector<Tensor<1, dim>>          phi_u;'
p12930
aS'        std::vector<SymmetricTensor<2, dim>> grads_phi_u;'
p12931
aS'        std::vector<double>                  div_phi_u;'
p12932
aS'        std::vector<double> old_temperature_values;'
p12933
aS'      };'
p12934
aS'      template <int dim>'
p12935
aS'      StokesSystem<dim>::StokesSystem('
p12936
aS'        const FiniteElement<dim> &stokes_fe,'
p12937
aS'        const Mapping<dim> &      mapping,'
p12938
aS'        const Quadrature<dim> &   stokes_quadrature,'
p12939
aS'        const UpdateFlags         stokes_update_flags,'
p12940
aS'        const FiniteElement<dim> &temperature_fe,'
p12941
aS'        const UpdateFlags         temperature_update_flags)'
p12942
aS'        : StokesPreconditioner<dim>(stokes_fe,'
p12943
aS'                                    stokes_quadrature,'
p12944
aS'                                    mapping,'
p12945
aS'                                    stokes_update_flags)'
p12946
aS'        , temperature_fe_values(mapping,'
p12947
aS'                                temperature_fe,'
p12948
aS'                                stokes_quadrature,'
p12949
aS'                                temperature_update_flags)'
p12950
aS'        , phi_u(stokes_fe.n_dofs_per_cell())'
p12951
aS'        , grads_phi_u(stokes_fe.n_dofs_per_cell())'
p12952
aS'        , div_phi_u(stokes_fe.n_dofs_per_cell())'
p12953
aS'        , old_temperature_values(stokes_quadrature.size())'
p12954
aS'      {}'
p12955
aS'      template <int dim>'
p12956
aS'      StokesSystem<dim>::StokesSystem(const StokesSystem<dim> &scratch)'
p12957
aS'        : StokesPreconditioner<dim>(scratch)'
p12958
aS'        , temperature_fe_values('
p12959
aS'            scratch.temperature_fe_values.get_mapping(),'
p12960
aS'            scratch.temperature_fe_values.get_fe(),'
p12961
aS'            scratch.temperature_fe_values.get_quadrature(),'
p12962
aS'            scratch.temperature_fe_values.get_update_flags())'
p12963
aS'        , phi_u(scratch.phi_u)'
p12964
aS'        , grads_phi_u(scratch.grads_phi_u)'
p12965
aS'        , div_phi_u(scratch.div_phi_u)'
p12966
aS'        , old_temperature_values(scratch.old_temperature_values)'
p12967
aS'      {}'
p12968
aS'      template <int dim>'
p12969
aS'      struct TemperatureMatrix'
p12970
aS'      {'
p12971
aS'        TemperatureMatrix(const FiniteElement<dim> &temperature_fe,'
p12972
aS'                          const Mapping<dim> &      mapping,'
p12973
aS'                          const Quadrature<dim> &   temperature_quadrature);'
p12974
aS'        TemperatureMatrix(const TemperatureMatrix &data);'
p12975
aS'        FEValues<dim> temperature_fe_values;'
p12976
aS'        std::vector<double>         phi_T;'
p12977
aS'        std::vector<Tensor<1, dim>> grad_phi_T;'
p12978
aS'      };'
p12979
aS'      template <int dim>'
p12980
aS'      TemperatureMatrix<dim>::TemperatureMatrix('
p12981
aS'        const FiniteElement<dim> &temperature_fe,'
p12982
aS'        const Mapping<dim> &      mapping,'
p12983
aS'        const Quadrature<dim> &   temperature_quadrature)'
p12984
aS'        : temperature_fe_values(mapping,'
p12985
aS'                                temperature_fe,'
p12986
aS'                                temperature_quadrature,'
p12987
aS'                                update_values | update_gradients |'
p12988
aS'                                  update_JxW_values)'
p12989
aS'        , phi_T(temperature_fe.n_dofs_per_cell())'
p12990
aS'        , grad_phi_T(temperature_fe.n_dofs_per_cell())'
p12991
aS'      {}'
p12992
aS'      template <int dim>'
p12993
aS'      TemperatureMatrix<dim>::TemperatureMatrix('
p12994
aS'        const TemperatureMatrix &scratch)'
p12995
aS'        : temperature_fe_values('
p12996
aS'            scratch.temperature_fe_values.get_mapping(),'
p12997
aS'            scratch.temperature_fe_values.get_fe(),'
p12998
aS'            scratch.temperature_fe_values.get_quadrature(),'
p12999
aS'            scratch.temperature_fe_values.get_update_flags())'
p13000
aS'        , phi_T(scratch.phi_T)'
p13001
aS'        , grad_phi_T(scratch.grad_phi_T)'
p13002
aS'      {}'
p13003
aS'      template <int dim>'
p13004
aS'      struct TemperatureRHS'
p13005
aS'      {'
p13006
aS'        TemperatureRHS(const FiniteElement<dim> &temperature_fe,'
p13007
aS'                       const FiniteElement<dim> &stokes_fe,'
p13008
aS'                       const Mapping<dim> &      mapping,'
p13009
aS'                       const Quadrature<dim> &   quadrature);'
p13010
aS'        TemperatureRHS(const TemperatureRHS &data);'
p13011
aS'        FEValues<dim> temperature_fe_values;'
p13012
aS'        FEValues<dim> stokes_fe_values;'
p13013
aS'        std::vector<double>         phi_T;'
p13014
aS'        std::vector<Tensor<1, dim>> grad_phi_T;'
p13015
aS'        std::vector<Tensor<1, dim>> old_velocity_values;'
p13016
aS'        std::vector<Tensor<1, dim>> old_old_velocity_values;'
p13017
aS'        std::vector<SymmetricTensor<2, dim>> old_strain_rates;'
p13018
aS'        std::vector<SymmetricTensor<2, dim>> old_old_strain_rates;'
p13019
aS'        std::vector<double>         old_temperature_values;'
p13020
aS'        std::vector<double>         old_old_temperature_values;'
p13021
aS'        std::vector<Tensor<1, dim>> old_temperature_grads;'
p13022
aS'        std::vector<Tensor<1, dim>> old_old_temperature_grads;'
p13023
aS'        std::vector<double>         old_temperature_laplacians;'
p13024
aS'        std::vector<double>         old_old_temperature_laplacians;'
p13025
aS'      };'
p13026
aS'      template <int dim>'
p13027
aS'      TemperatureRHS<dim>::TemperatureRHS('
p13028
aS'        const FiniteElement<dim> &temperature_fe,'
p13029
aS'        const FiniteElement<dim> &stokes_fe,'
p13030
aS'        const Mapping<dim> &      mapping,'
p13031
aS'        const Quadrature<dim> &   quadrature)'
p13032
aS'        : temperature_fe_values(mapping,'
p13033
aS'                                temperature_fe,'
p13034
aS'                                quadrature,'
p13035
aS'                                update_values | update_gradients |'
p13036
aS'                                  update_hessians | update_quadrature_points |'
p13037
aS'                                  update_JxW_values)'
p13038
aS'        , stokes_fe_values(mapping,'
p13039
aS'                           stokes_fe,'
p13040
aS'                           quadrature,'
p13041
aS'                           update_values | update_gradients)'
p13042
aS'        , phi_T(temperature_fe.n_dofs_per_cell())'
p13043
aS'        , grad_phi_T(temperature_fe.n_dofs_per_cell())'
p13044
aS'        ,'
p13045
aS'        old_velocity_values(quadrature.size())'
p13046
aS'        , old_old_velocity_values(quadrature.size())'
p13047
aS'        , old_strain_rates(quadrature.size())'
p13048
aS'        , old_old_strain_rates(quadrature.size())'
p13049
aS'        ,'
p13050
aS'        old_temperature_values(quadrature.size())'
p13051
aS'        , old_old_temperature_values(quadrature.size())'
p13052
aS'        , old_temperature_grads(quadrature.size())'
p13053
aS'        , old_old_temperature_grads(quadrature.size())'
p13054
aS'        , old_temperature_laplacians(quadrature.size())'
p13055
aS'        , old_old_temperature_laplacians(quadrature.size())'
p13056
aS'      {}'
p13057
aS'      template <int dim>'
p13058
aS'      TemperatureRHS<dim>::TemperatureRHS(const TemperatureRHS &scratch)'
p13059
aS'        : temperature_fe_values('
p13060
aS'            scratch.temperature_fe_values.get_mapping(),'
p13061
aS'            scratch.temperature_fe_values.get_fe(),'
p13062
aS'            scratch.temperature_fe_values.get_quadrature(),'
p13063
aS'            scratch.temperature_fe_values.get_update_flags())'
p13064
aS'        , stokes_fe_values(scratch.stokes_fe_values.get_mapping(),'
p13065
aS'                           scratch.stokes_fe_values.get_fe(),'
p13066
aS'                           scratch.stokes_fe_values.get_quadrature(),'
p13067
aS'                           scratch.stokes_fe_values.get_update_flags())'
p13068
aS'        , phi_T(scratch.phi_T)'
p13069
aS'        , grad_phi_T(scratch.grad_phi_T)'
p13070
aS'        ,'
p13071
aS'        old_velocity_values(scratch.old_velocity_values)'
p13072
aS'        , old_old_velocity_values(scratch.old_old_velocity_values)'
p13073
aS'        , old_strain_rates(scratch.old_strain_rates)'
p13074
aS'        , old_old_strain_rates(scratch.old_old_strain_rates)'
p13075
aS'        ,'
p13076
aS'        old_temperature_values(scratch.old_temperature_values)'
p13077
aS'        , old_old_temperature_values(scratch.old_old_temperature_values)'
p13078
aS'        , old_temperature_grads(scratch.old_temperature_grads)'
p13079
aS'        , old_old_temperature_grads(scratch.old_old_temperature_grads)'
p13080
aS'        , old_temperature_laplacians(scratch.old_temperature_laplacians)'
p13081
aS'        , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians)'
p13082
aS'      {}'
p13083
aS'    } // namespace Scratch'
p13084
aS'    namespace CopyData'
p13085
aS'    {'
p13086
aS'      template <int dim>'
p13087
aS'      struct StokesPreconditioner'
p13088
aS'      {'
p13089
aS'        StokesPreconditioner(const FiniteElement<dim> &stokes_fe);'
p13090
aS'        StokesPreconditioner(const StokesPreconditioner &data);'
p13091
aS'        StokesPreconditioner &operator=(const StokesPreconditioner &) = default;'
p13092
aS'        FullMatrix<double>                   local_matrix;'
p13093
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p13094
aS'      };'
p13095
aS'      template <int dim>'
p13096
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p13097
aS'        const FiniteElement<dim> &stokes_fe)'
p13098
aS'        : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell())'
p13099
aS'        , local_dof_indices(stokes_fe.n_dofs_per_cell())'
p13100
aS'      {}'
p13101
aS'      template <int dim>'
p13102
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p13103
aS'        const StokesPreconditioner &data)'
p13104
aS'        : local_matrix(data.local_matrix)'
p13105
aS'        , local_dof_indices(data.local_dof_indices)'
p13106
aS'      {}'
p13107
aS'      template <int dim>'
p13108
aS'      struct StokesSystem : public StokesPreconditioner<dim>'
p13109
aS'      {'
p13110
aS'        StokesSystem(const FiniteElement<dim> &stokes_fe);'
p13111
aS'        Vector<double> local_rhs;'
p13112
aS'      };'
p13113
aS'      template <int dim>'
p13114
aS'      StokesSystem<dim>::StokesSystem(const FiniteElement<dim> &stokes_fe)'
p13115
aS'        : StokesPreconditioner<dim>(stokes_fe)'
p13116
aS'        , local_rhs(stokes_fe.n_dofs_per_cell())'
p13117
aS'      {}'
p13118
aS'      template <int dim>'
p13119
aS'      struct TemperatureMatrix'
p13120
aS'      {'
p13121
aS'        TemperatureMatrix(const FiniteElement<dim> &temperature_fe);'
p13122
aS'        FullMatrix<double>                   local_mass_matrix;'
p13123
aS'        FullMatrix<double>                   local_stiffness_matrix;'
p13124
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p13125
aS'      };'
p13126
aS'      template <int dim>'
p13127
aS'      TemperatureMatrix<dim>::TemperatureMatrix('
p13128
aS'        const FiniteElement<dim> &temperature_fe)'
p13129
aS'        : local_mass_matrix(temperature_fe.n_dofs_per_cell(),'
p13130
aS'                            temperature_fe.n_dofs_per_cell())'
p13131
aS'        , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(),'
p13132
aS'                                 temperature_fe.n_dofs_per_cell())'
p13133
aS'        , local_dof_indices(temperature_fe.n_dofs_per_cell())'
p13134
aS'      {}'
p13135
aS'      template <int dim>'
p13136
aS'      struct TemperatureRHS'
p13137
aS'      {'
p13138
aS'        TemperatureRHS(const FiniteElement<dim> &temperature_fe);'
p13139
aS'        Vector<double>                       local_rhs;'
p13140
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p13141
aS'        FullMatrix<double>                   matrix_for_bc;'
p13142
aS'      };'
p13143
aS'      template <int dim>'
p13144
aS'      TemperatureRHS<dim>::TemperatureRHS('
p13145
aS'        const FiniteElement<dim> &temperature_fe)'
p13146
aS'        : local_rhs(temperature_fe.n_dofs_per_cell())'
p13147
aS'        , local_dof_indices(temperature_fe.n_dofs_per_cell())'
p13148
aS'        , matrix_for_bc(temperature_fe.n_dofs_per_cell(),'
p13149
aS'                        temperature_fe.n_dofs_per_cell())'
p13150
aS'      {}'
p13151
aS'    } // namespace CopyData'
p13152
aS'  }   // namespace Assembly'
p13153
aS'  template <int dim>'
p13154
aS'  class BoussinesqFlowProblem'
p13155
aS'  {'
p13156
aS'  public:'
p13157
aS'    struct Parameters;'
p13158
aS'    BoussinesqFlowProblem(Parameters &parameters);'
p13159
aS'    void run();'
p13160
aS'  private:'
p13161
aS'    void   setup_dofs();'
p13162
aS'    void   assemble_stokes_preconditioner();'
p13163
aS'    void   build_stokes_preconditioner();'
p13164
aS'    void   assemble_stokes_system();'
p13165
aS'    void   assemble_temperature_matrix();'
p13166
aS'    void   assemble_temperature_system(const double maximal_velocity);'
p13167
aS'    double get_maximal_velocity() const;'
p13168
aS'    double get_cfl_number() const;'
p13169
aS'    double get_entropy_variation(const double average_temperature) const;'
p13170
aS'    std::pair<double, double> get_extrapolated_temperature_range() const;'
p13171
aS'    void                      solve();'
p13172
aS'    void                      output_results();'
p13173
aS'    void                      refine_mesh(const unsigned int max_grid_level);'
p13174
aS'    double compute_viscosity('
p13175
aS'      const std::vector<double> &        old_temperature,'
p13176
aS'      const std::vector<double> &        old_old_temperature,'
p13177
aS'      const std::vector<Tensor<1, dim>> &old_temperature_grads,'
p13178
aS'      const std::vector<Tensor<1, dim>> &old_old_temperature_grads,'
p13179
aS'      const std::vector<double> &        old_temperature_laplacians,'
p13180
aS'      const std::vector<double> &        old_old_temperature_laplacians,'
p13181
aS'      const std::vector<Tensor<1, dim>> &old_velocity_values,'
p13182
aS'      const std::vector<Tensor<1, dim>> &old_old_velocity_values,'
p13183
aS'      const std::vector<SymmetricTensor<2, dim>> &old_strain_rates,'
p13184
aS'      const std::vector<SymmetricTensor<2, dim>> &old_old_strain_rates,'
p13185
aS'      const double                                global_u_infty,'
p13186
aS'      const double                                global_T_variation,'
p13187
aS'      const double                                average_temperature,'
p13188
aS'      const double                                global_entropy_variation,'
p13189
aS'      const double                                cell_diameter) const;'
p13190
aS'  public:'
p13191
aS'    struct Parameters'
p13192
aS'    {'
p13193
aS'      Parameters(const std::string &parameter_filename);'
p13194
aS'      static void declare_parameters(ParameterHandler &prm);'
p13195
aS'      void        parse_parameters(ParameterHandler &prm);'
p13196
aS'      double end_time;'
p13197
aS'      unsigned int initial_global_refinement;'
p13198
aS'      unsigned int initial_adaptive_refinement;'
p13199
aS'      bool         generate_graphical_output;'
p13200
aS'      unsigned int graphical_output_interval;'
p13201
aS'      unsigned int adaptive_refinement_interval;'
p13202
aS'      double stabilization_alpha;'
p13203
aS'      double stabilization_c_R;'
p13204
aS'      double stabilization_beta;'
p13205
aS'      unsigned int stokes_velocity_degree;'
p13206
aS'      bool         use_locally_conservative_discretization;'
p13207
aS'      unsigned int temperature_degree;'
p13208
aS'    };'
p13209
aS'  private:'
p13210
aS'    Parameters &parameters;'
p13211
aS'    ConditionalOStream pcout;'
p13212
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p13213
aS'    double                                    global_Omega_diameter;'
p13214
aS'    const MappingQ<dim> mapping;'
p13215
aS'    const FESystem<dim>       stokes_fe;'
p13216
aS'    DoFHandler<dim>           stokes_dof_handler;'
p13217
aS'    AffineConstraints<double> stokes_constraints;'
p13218
aS'    TrilinosWrappers::BlockSparseMatrix stokes_matrix;'
p13219
aS'    TrilinosWrappers::BlockSparseMatrix stokes_preconditioner_matrix;'
p13220
aS'    TrilinosWrappers::MPI::BlockVector stokes_solution;'
p13221
aS'    TrilinosWrappers::MPI::BlockVector old_stokes_solution;'
p13222
aS'    TrilinosWrappers::MPI::BlockVector stokes_rhs;'
p13223
aS'    FE_Q<dim>                 temperature_fe;'
p13224
aS'    DoFHandler<dim>           temperature_dof_handler;'
p13225
aS'    AffineConstraints<double> temperature_constraints;'
p13226
aS'    TrilinosWrappers::SparseMatrix temperature_mass_matrix;'
p13227
aS'    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;'
p13228
aS'    TrilinosWrappers::SparseMatrix temperature_matrix;'
p13229
aS'    TrilinosWrappers::MPI::Vector temperature_solution;'
p13230
aS'    TrilinosWrappers::MPI::Vector old_temperature_solution;'
p13231
aS'    TrilinosWrappers::MPI::Vector old_old_temperature_solution;'
p13232
aS'    TrilinosWrappers::MPI::Vector temperature_rhs;'
p13233
aS'    double       time_step;'
p13234
aS'    double       old_time_step;'
p13235
aS'    unsigned int timestep_number;'
p13236
aS'    std::shared_ptr<TrilinosWrappers::PreconditionAMG>    Amg_preconditioner;'
p13237
aS'    std::shared_ptr<TrilinosWrappers::PreconditionJacobi> Mp_preconditioner;'
p13238
aS'    std::shared_ptr<TrilinosWrappers::PreconditionJacobi> T_preconditioner;'
p13239
aS'    bool rebuild_stokes_matrix;'
p13240
aS'    bool rebuild_stokes_preconditioner;'
p13241
aS'    bool rebuild_temperature_matrices;'
p13242
aS'    bool rebuild_temperature_preconditioner;'
p13243
aS'    TimerOutput computing_timer;'
p13244
aS'    void setup_stokes_matrix('
p13245
aS'      const std::vector<IndexSet> &stokes_partitioning,'
p13246
aS'      const std::vector<IndexSet> &stokes_relevant_partitioning);'
p13247
aS'    void setup_stokes_preconditioner('
p13248
aS'      const std::vector<IndexSet> &stokes_partitioning,'
p13249
aS'      const std::vector<IndexSet> &stokes_relevant_partitioning);'
p13250
aS'    void setup_temperature_matrices('
p13251
aS'      const IndexSet &temperature_partitioning,'
p13252
aS'      const IndexSet &temperature_relevant_partitioning);'
p13253
aS'    void local_assemble_stokes_preconditioner('
p13254
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13255
aS'      Assembly::Scratch::StokesPreconditioner<dim> &        scratch,'
p13256
aS'      Assembly::CopyData::StokesPreconditioner<dim> &       data);'
p13257
aS'    void copy_local_to_global_stokes_preconditioner('
p13258
aS'      const Assembly::CopyData::StokesPreconditioner<dim> &data);'
p13259
aS'    void local_assemble_stokes_system('
p13260
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13261
aS'      Assembly::Scratch::StokesSystem<dim> &                scratch,'
p13262
aS'      Assembly::CopyData::StokesSystem<dim> &               data);'
p13263
aS'    void copy_local_to_global_stokes_system('
p13264
aS'      const Assembly::CopyData::StokesSystem<dim> &data);'
p13265
aS'    void local_assemble_temperature_matrix('
p13266
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13267
aS'      Assembly::Scratch::TemperatureMatrix<dim> &           scratch,'
p13268
aS'      Assembly::CopyData::TemperatureMatrix<dim> &          data);'
p13269
aS'    void copy_local_to_global_temperature_matrix('
p13270
aS'      const Assembly::CopyData::TemperatureMatrix<dim> &data);'
p13271
aS'    void local_assemble_temperature_rhs('
p13272
aS'      const std::pair<double, double> global_T_range,'
p13273
aS'      const double                    global_max_velocity,'
p13274
aS'      const double                    global_entropy_variation,'
p13275
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13276
aS'      Assembly::Scratch::TemperatureRHS<dim> &              scratch,'
p13277
aS'      Assembly::CopyData::TemperatureRHS<dim> &             data);'
p13278
aS'    void copy_local_to_global_temperature_rhs('
p13279
aS'      const Assembly::CopyData::TemperatureRHS<dim> &data);'
p13280
aS'    class Postprocessor;'
p13281
aS'  };'
p13282
aS'  template <int dim>'
p13283
aS'  BoussinesqFlowProblem<dim>::Parameters::Parameters('
p13284
aS'    const std::string &parameter_filename)'
p13285
aS'    : end_time(1e8)'
p13286
aS'    , initial_global_refinement(2)'
p13287
aS'    , initial_adaptive_refinement(2)'
p13288
aS'    , adaptive_refinement_interval(10)'
p13289
aS'    , stabilization_alpha(2)'
p13290
aS'    , stabilization_c_R(0.11)'
p13291
aS'    , stabilization_beta(0.078)'
p13292
aS'    , stokes_velocity_degree(2)'
p13293
aS'    , use_locally_conservative_discretization(true)'
p13294
aS'    , temperature_degree(2)'
p13295
aS'  {'
p13296
aS'    ParameterHandler prm;'
p13297
aS'    BoussinesqFlowProblem<dim>::Parameters::declare_parameters(prm);'
p13298
aS'    std::ifstream parameter_file(parameter_filename);'
p13299
aS'    if (!parameter_file)'
p13300
aS'      {'
p13301
aS'        parameter_file.close();'
p13302
aS'        std::ofstream parameter_out(parameter_filename);'
p13303
aS'        prm.print_parameters(parameter_out, ParameterHandler::Text);'
p13304
aS'        AssertThrow('
p13305
aS'          false,'
p13306
aS'          ExcMessage('
p13307
aS'            "Input parameter file <" + parameter_filename +'
p13308
aS'            "> not found. Creating a template file of the same name."));'
p13309
aS'      }'
p13310
aS'    prm.parse_input(parameter_file);'
p13311
aS'    parse_parameters(prm);'
p13312
aS'  }'
p13313
aS'  template <int dim>'
p13314
aS'  void BoussinesqFlowProblem<dim>::Parameters::declare_parameters('
p13315
aS'    ParameterHandler &prm)'
p13316
aS'  {'
p13317
aS'    prm.declare_entry("End time",'
p13318
aS'                      "1e8",'
p13319
aS'                      Patterns::Double(0),'
p13320
aS'                      "The end time of the simulation in years.");'
p13321
aS'    prm.declare_entry("Initial global refinement",'
p13322
aS'                      "2",'
p13323
aS'                      Patterns::Integer(0),'
p13324
aS'                      "The number of global refinement steps performed on "'
p13325
aS'                      "the initial coarse mesh, before the problem is first "'
p13326
aS'                      "solved there.");'
p13327
aS'    prm.declare_entry("Initial adaptive refinement",'
p13328
aS'                      "2",'
p13329
aS'                      Patterns::Integer(0),'
p13330
aS'                      "The number of adaptive refinement steps performed after "'
p13331
aS'                      "initial global refinement.");'
p13332
aS'    prm.declare_entry("Time steps between mesh refinement",'
p13333
aS'                      "10",'
p13334
aS'                      Patterns::Integer(1),'
p13335
aS'                      "The number of time steps after which the mesh is to be "'
p13336
aS'                      "adapted based on computed error indicators.");'
p13337
aS'    prm.declare_entry("Generate graphical output",'
p13338
aS'                      "false",'
p13339
aS'                      Patterns::Bool(),'
p13340
aS'                      "Whether graphical output is to be generated or not. "'
p13341
aS'                      "You may not want to get graphical output if the number "'
p13342
aS'                      "of processors is large.");'
p13343
aS'    prm.declare_entry("Time steps between graphical output",'
p13344
aS'                      "50",'
p13345
aS'                      Patterns::Integer(1),'
p13346
aS'                      "The number of time steps between each generation of "'
p13347
aS'                      "graphical output files.");'
p13348
aS'    prm.enter_subsection("Stabilization parameters");'
p13349
aS'    {'
p13350
aS'      prm.declare_entry("alpha",'
p13351
aS'                        "2",'
p13352
aS'                        Patterns::Double(1, 2),'
p13353
aS'                        "The exponent in the entropy viscosity stabilization.");'
p13354
aS'      prm.declare_entry("c_R",'
p13355
aS'                        "0.11",'
p13356
aS'                        Patterns::Double(0),'
p13357
aS'                        "The c_R factor in the entropy viscosity "'
p13358
aS'                        "stabilization.");'
p13359
aS'      prm.declare_entry("beta",'
p13360
aS'                        "0.078",'
p13361
aS'                        Patterns::Double(0),'
p13362
aS'                        "The beta factor in the artificial viscosity "'
p13363
aS'                        "stabilization. An appropriate value for 2d is 0.052 "'
p13364
aS'                        "and 0.078 for 3d.");'
p13365
aS'    }'
p13366
aS'    prm.leave_subsection();'
p13367
aS'    prm.enter_subsection("Discretization");'
p13368
aS'    {'
p13369
aS'      prm.declare_entry('
p13370
aS'        "Stokes velocity polynomial degree",'
p13371
aS'        "2",'
p13372
aS'        Patterns::Integer(1),'
p13373
aS'        "The polynomial degree to use for the velocity variables "'
p13374
aS'        "in the Stokes system.");'
p13375
aS'      prm.declare_entry('
p13376
aS'        "Temperature polynomial degree",'
p13377
aS'        "2",'
p13378
aS'        Patterns::Integer(1),'
p13379
aS'        "The polynomial degree to use for the temperature variable.");'
p13380
aS'      prm.declare_entry('
p13381
aS'        "Use locally conservative discretization",'
p13382
aS'        "true",'
p13383
aS'        Patterns::Bool(),'
p13384
aS'        "Whether to use a Stokes discretization that is locally "'
p13385
aS'        "conservative at the expense of a larger number of degrees "'
p13386
aS'        "of freedom, or to go with a cheaper discretization "'
p13387
aS'        "that does not locally conserve mass (although it is "'
p13388
aS'        "globally conservative.");'
p13389
aS'    }'
p13390
aS'    prm.leave_subsection();'
p13391
aS'  }'
p13392
aS'  template <int dim>'
p13393
aS'  void BoussinesqFlowProblem<dim>::Parameters::parse_parameters('
p13394
aS'    ParameterHandler &prm)'
p13395
aS'  {'
p13396
aS'    end_time                  = prm.get_double("End time");'
p13397
aS'    initial_global_refinement = prm.get_integer("Initial global refinement");'
p13398
aS'    initial_adaptive_refinement ='
p13399
aS'      prm.get_integer("Initial adaptive refinement");'
p13400
aS'    adaptive_refinement_interval ='
p13401
aS'      prm.get_integer("Time steps between mesh refinement");'
p13402
aS'    generate_graphical_output = prm.get_bool("Generate graphical output");'
p13403
aS'    graphical_output_interval ='
p13404
aS'      prm.get_integer("Time steps between graphical output");'
p13405
aS'    prm.enter_subsection("Stabilization parameters");'
p13406
aS'    {'
p13407
aS'      stabilization_alpha = prm.get_double("alpha");'
p13408
aS'      stabilization_c_R   = prm.get_double("c_R");'
p13409
aS'      stabilization_beta  = prm.get_double("beta");'
p13410
aS'    }'
p13411
aS'    prm.leave_subsection();'
p13412
aS'    prm.enter_subsection("Discretization");'
p13413
aS'    {'
p13414
aS'      stokes_velocity_degree ='
p13415
aS'        prm.get_integer("Stokes velocity polynomial degree");'
p13416
aS'      temperature_degree = prm.get_integer("Temperature polynomial degree");'
p13417
aS'      use_locally_conservative_discretization ='
p13418
aS'        prm.get_bool("Use locally conservative discretization");'
p13419
aS'    }'
p13420
aS'    prm.leave_subsection();'
p13421
aS'  }'
p13422
aS'  template <int dim>'
p13423
aS'  BoussinesqFlowProblem<dim>::BoussinesqFlowProblem(Parameters &parameters_)'
p13424
aS'    : parameters(parameters_)'
p13425
aS'    , pcout(std::cout, (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0))'
p13426
aS'    ,'
p13427
aS'    triangulation(MPI_COMM_WORLD,'
p13428
aS'                  typename Triangulation<dim>::MeshSmoothing('
p13429
aS'                    Triangulation<dim>::smoothing_on_refinement |'
p13430
aS'                    Triangulation<dim>::smoothing_on_coarsening))'
p13431
aS'    ,'
p13432
aS'    global_Omega_diameter(0.)'
p13433
aS'    ,'
p13434
aS'    mapping(4)'
p13435
aS'    ,'
p13436
aS'    stokes_fe(FE_Q<dim>(parameters.stokes_velocity_degree),'
p13437
aS'              dim,'
p13438
aS'              (parameters.use_locally_conservative_discretization ?'
p13439
aS'                 static_cast<const FiniteElement<dim> &>('
p13440
aS'                   FE_DGP<dim>(parameters.stokes_velocity_degree - 1)) :'
p13441
aS'                 static_cast<const FiniteElement<dim> &>('
p13442
aS'                   FE_Q<dim>(parameters.stokes_velocity_degree - 1))),'
p13443
aS'              1)'
p13444
aS'    ,'
p13445
aS'    stokes_dof_handler(triangulation)'
p13446
aS'    ,'
p13447
aS'    temperature_fe(parameters.temperature_degree)'
p13448
aS'    , temperature_dof_handler(triangulation)'
p13449
aS'    ,'
p13450
aS'    time_step(0)'
p13451
aS'    , old_time_step(0)'
p13452
aS'    , timestep_number(0)'
p13453
aS'    , rebuild_stokes_matrix(true)'
p13454
aS'    , rebuild_stokes_preconditioner(true)'
p13455
aS'    , rebuild_temperature_matrices(true)'
p13456
aS'    , rebuild_temperature_preconditioner(true)'
p13457
aS'    ,'
p13458
aS'    computing_timer(MPI_COMM_WORLD,'
p13459
aS'                    pcout,'
p13460
aS'                    TimerOutput::summary,'
p13461
aS'                    TimerOutput::wall_times)'
p13462
aS'  {}'
p13463
aS'  template <int dim>'
p13464
aS'  double BoussinesqFlowProblem<dim>::get_maximal_velocity() const'
p13465
aS'  {'
p13466
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p13467
aS'                                            parameters.stokes_velocity_degree);'
p13468
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p13469
aS'    FEValues<dim>               fe_values(mapping,'
p13470
aS'                            stokes_fe,'
p13471
aS'                            quadrature_formula,'
p13472
aS'                            update_values);'
p13473
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points);'
p13474
aS'    const FEValuesExtractors::Vector velocities(0);'
p13475
aS'    double max_local_velocity = 0;'
p13476
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p13477
aS'      if (cell->is_locally_owned())'
p13478
aS'        {'
p13479
aS'          fe_values.reinit(cell);'
p13480
aS'          fe_values[velocities].get_function_values(stokes_solution,'
p13481
aS'                                                    velocity_values);'
p13482
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p13483
aS'            max_local_velocity ='
p13484
aS'              std::max(max_local_velocity, velocity_values[q].norm());'
p13485
aS'        }'
p13486
aS'    return Utilities::MPI::max(max_local_velocity, MPI_COMM_WORLD);'
p13487
aS'  }'
p13488
aS'  template <int dim>'
p13489
aS'  double BoussinesqFlowProblem<dim>::get_cfl_number() const'
p13490
aS'  {'
p13491
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p13492
aS'                                            parameters.stokes_velocity_degree);'
p13493
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p13494
aS'    FEValues<dim>               fe_values(mapping,'
p13495
aS'                            stokes_fe,'
p13496
aS'                            quadrature_formula,'
p13497
aS'                            update_values);'
p13498
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points);'
p13499
aS'    const FEValuesExtractors::Vector velocities(0);'
p13500
aS'    double max_local_cfl = 0;'
p13501
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p13502
aS'      if (cell->is_locally_owned())'
p13503
aS'        {'
p13504
aS'          fe_values.reinit(cell);'
p13505
aS'          fe_values[velocities].get_function_values(stokes_solution,'
p13506
aS'                                                    velocity_values);'
p13507
aS'          double max_local_velocity = 1e-10;'
p13508
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p13509
aS'            max_local_velocity ='
p13510
aS'              std::max(max_local_velocity, velocity_values[q].norm());'
p13511
aS'          max_local_cfl ='
p13512
aS'            std::max(max_local_cfl, max_local_velocity / cell->diameter());'
p13513
aS'        }'
p13514
aS'    return Utilities::MPI::max(max_local_cfl, MPI_COMM_WORLD);'
p13515
aS'  }'
p13516
aS'  template <int dim>'
p13517
aS'  double BoussinesqFlowProblem<dim>::get_entropy_variation('
p13518
aS'    const double average_temperature) const'
p13519
aS'  {'
p13520
aS'    if (parameters.stabilization_alpha != 2)'
p13521
aS'      return 1.;'
p13522
aS'    const QGauss<dim>  quadrature_formula(parameters.temperature_degree + 1);'
p13523
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p13524
aS'    FEValues<dim>       fe_values(temperature_fe,'
p13525
aS'                            quadrature_formula,'
p13526
aS'                            update_values | update_JxW_values);'
p13527
aS'    std::vector<double> old_temperature_values(n_q_points);'
p13528
aS'    std::vector<double> old_old_temperature_values(n_q_points);'
p13529
aS'    double min_entropy = std::numeric_limits<double>::max(),'
p13530
aS'           max_entropy = -std::numeric_limits<double>::max(), area = 0,'
p13531
aS'           entropy_integrated = 0;'
p13532
aS'    for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p13533
aS'      if (cell->is_locally_owned())'
p13534
aS'        {'
p13535
aS'          fe_values.reinit(cell);'
p13536
aS'          fe_values.get_function_values(old_temperature_solution,'
p13537
aS'                                        old_temperature_values);'
p13538
aS'          fe_values.get_function_values(old_old_temperature_solution,'
p13539
aS'                                        old_old_temperature_values);'
p13540
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p13541
aS'            {'
p13542
aS'              const double T ='
p13543
aS'                (old_temperature_values[q] + old_old_temperature_values[q]) / 2;'
p13544
aS'              const double entropy ='
p13545
aS'                ((T - average_temperature) * (T - average_temperature));'
p13546
aS'              min_entropy = std::min(min_entropy, entropy);'
p13547
aS'              max_entropy = std::max(max_entropy, entropy);'
p13548
aS'              area += fe_values.JxW(q);'
p13549
aS'              entropy_integrated += fe_values.JxW(q) * entropy;'
p13550
aS'            }'
p13551
aS'        }'
p13552
aS'    const double local_sums[2]   = {entropy_integrated, area},'
p13553
aS'                 local_maxima[2] = {-min_entropy, max_entropy};'
p13554
aS'    double global_sums[2], global_maxima[2];'
p13555
aS'    Utilities::MPI::sum(local_sums, MPI_COMM_WORLD, global_sums);'
p13556
aS'    Utilities::MPI::max(local_maxima, MPI_COMM_WORLD, global_maxima);'
p13557
aS'    const double average_entropy = global_sums[0] / global_sums[1];'
p13558
aS'    const double entropy_diff    = std::max(global_maxima[1] - average_entropy,'
p13559
aS'                                         average_entropy - (-global_maxima[0]));'
p13560
aS'    return entropy_diff;'
p13561
aS'  }'
p13562
aS'  template <int dim>'
p13563
aS'  std::pair<double, double>'
p13564
aS'  BoussinesqFlowProblem<dim>::get_extrapolated_temperature_range() const'
p13565
aS'  {'
p13566
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p13567
aS'                                            parameters.temperature_degree);'
p13568
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p13569
aS'    FEValues<dim>       fe_values(mapping,'
p13570
aS'                            temperature_fe,'
p13571
aS'                            quadrature_formula,'
p13572
aS'                            update_values);'
p13573
aS'    std::vector<double> old_temperature_values(n_q_points);'
p13574
aS'    std::vector<double> old_old_temperature_values(n_q_points);'
p13575
aS'    double min_local_temperature = std::numeric_limits<double>::max(),'
p13576
aS'           max_local_temperature = -std::numeric_limits<double>::max();'
p13577
aS'    if (timestep_number != 0)'
p13578
aS'      {'
p13579
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p13580
aS'          if (cell->is_locally_owned())'
p13581
aS'            {'
p13582
aS'              fe_values.reinit(cell);'
p13583
aS'              fe_values.get_function_values(old_temperature_solution,'
p13584
aS'                                            old_temperature_values);'
p13585
aS'              fe_values.get_function_values(old_old_temperature_solution,'
p13586
aS'                                            old_old_temperature_values);'
p13587
aS'              for (unsigned int q = 0; q < n_q_points; ++q)'
p13588
aS'                {'
p13589
aS'                  const double temperature ='
p13590
aS'                    (1. + time_step / old_time_step) *'
p13591
aS'                      old_temperature_values[q] -'
p13592
aS'                    time_step / old_time_step * old_old_temperature_values[q];'
p13593
aS'                  min_local_temperature ='
p13594
aS'                    std::min(min_local_temperature, temperature);'
p13595
aS'                  max_local_temperature ='
p13596
aS'                    std::max(max_local_temperature, temperature);'
p13597
aS'                }'
p13598
aS'            }'
p13599
aS'      }'
p13600
aS'    else'
p13601
aS'      {'
p13602
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p13603
aS'          if (cell->is_locally_owned())'
p13604
aS'            {'
p13605
aS'              fe_values.reinit(cell);'
p13606
aS'              fe_values.get_function_values(old_temperature_solution,'
p13607
aS'                                            old_temperature_values);'
p13608
aS'              for (unsigned int q = 0; q < n_q_points; ++q)'
p13609
aS'                {'
p13610
aS'                  const double temperature = old_temperature_values[q];'
p13611
aS'                  min_local_temperature ='
p13612
aS'                    std::min(min_local_temperature, temperature);'
p13613
aS'                  max_local_temperature ='
p13614
aS'                    std::max(max_local_temperature, temperature);'
p13615
aS'                }'
p13616
aS'            }'
p13617
aS'      }'
p13618
aS'    double local_extrema[2] = {-min_local_temperature, max_local_temperature};'
p13619
aS'    double global_extrema[2];'
p13620
aS'    Utilities::MPI::max(local_extrema, MPI_COMM_WORLD, global_extrema);'
p13621
aS'    return std::make_pair(-global_extrema[0], global_extrema[1]);'
p13622
aS'  }'
p13623
aS'  template <int dim>'
p13624
aS'  double BoussinesqFlowProblem<dim>::compute_viscosity('
p13625
aS'    const std::vector<double> &                 old_temperature,'
p13626
aS'    const std::vector<double> &                 old_old_temperature,'
p13627
aS'    const std::vector<Tensor<1, dim>> &         old_temperature_grads,'
p13628
aS'    const std::vector<Tensor<1, dim>> &         old_old_temperature_grads,'
p13629
aS'    const std::vector<double> &                 old_temperature_laplacians,'
p13630
aS'    const std::vector<double> &                 old_old_temperature_laplacians,'
p13631
aS'    const std::vector<Tensor<1, dim>> &         old_velocity_values,'
p13632
aS'    const std::vector<Tensor<1, dim>> &         old_old_velocity_values,'
p13633
aS'    const std::vector<SymmetricTensor<2, dim>> &old_strain_rates,'
p13634
aS'    const std::vector<SymmetricTensor<2, dim>> &old_old_strain_rates,'
p13635
aS'    const double                                global_u_infty,'
p13636
aS'    const double                                global_T_variation,'
p13637
aS'    const double                                average_temperature,'
p13638
aS'    const double                                global_entropy_variation,'
p13639
aS'    const double                                cell_diameter) const'
p13640
aS'  {'
p13641
aS'    if (global_u_infty == 0)'
p13642
aS'      return 5e-3 * cell_diameter;'
p13643
aS'    const unsigned int n_q_points = old_temperature.size();'
p13644
aS'    double max_residual = 0;'
p13645
aS'    double max_velocity = 0;'
p13646
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13647
aS'      {'
p13648
aS'        const Tensor<1, dim> u ='
p13649
aS'          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;'
p13650
aS'        const SymmetricTensor<2, dim> strain_rate ='
p13651
aS'          (old_strain_rates[q] + old_old_strain_rates[q]) / 2;'
p13652
aS'        const double T = (old_temperature[q] + old_old_temperature[q]) / 2;'
p13653
aS'        const double dT_dt ='
p13654
aS'          (old_temperature[q] - old_old_temperature[q]) / old_time_step;'
p13655
aS'        const double u_grad_T ='
p13656
aS'          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;'
p13657
aS'        const double kappa_Delta_T ='
p13658
aS'          EquationData::kappa *'
p13659
aS'          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /'
p13660
aS'          2;'
p13661
aS'        const double gamma ='
p13662
aS'          ((EquationData::radiogenic_heating * EquationData::density(T) +'
p13663
aS'            2 * EquationData::eta * strain_rate * strain_rate) /'
p13664
aS'           (EquationData::density(T) * EquationData::specific_heat));'
p13665
aS'        double residual = std::abs(dT_dt + u_grad_T - kappa_Delta_T - gamma);'
p13666
aS'        if (parameters.stabilization_alpha == 2)'
p13667
aS'          residual *= std::abs(T - average_temperature);'
p13668
aS'        max_residual = std::max(residual, max_residual);'
p13669
aS'        max_velocity = std::max(std::sqrt(u * u), max_velocity);'
p13670
aS'      }'
p13671
aS'    const double max_viscosity ='
p13672
aS'      (parameters.stabilization_beta * max_velocity * cell_diameter);'
p13673
aS'    if (timestep_number == 0)'
p13674
aS'      return max_viscosity;'
p13675
aS'    else'
p13676
aS'      {'
p13677
aS'        Assert(old_time_step > 0, ExcInternalError());'
p13678
aS'        double entropy_viscosity;'
p13679
aS'        if (parameters.stabilization_alpha == 2)'
p13680
aS'          entropy_viscosity ='
p13681
aS'            (parameters.stabilization_c_R * cell_diameter * cell_diameter *'
p13682
aS'             max_residual / global_entropy_variation);'
p13683
aS'        else'
p13684
aS'          entropy_viscosity ='
p13685
aS'            (parameters.stabilization_c_R * cell_diameter *'
p13686
aS'             global_Omega_diameter * max_velocity * max_residual /'
p13687
aS'             (global_u_infty * global_T_variation));'
p13688
aS'        return std::min(max_viscosity, entropy_viscosity);'
p13689
aS'      }'
p13690
aS'  }'
p13691
aS'  template <int dim>'
p13692
aS'  void BoussinesqFlowProblem<dim>::setup_stokes_matrix('
p13693
aS'    const std::vector<IndexSet> &stokes_partitioning,'
p13694
aS'    const std::vector<IndexSet> &stokes_relevant_partitioning)'
p13695
aS'  {'
p13696
aS'    stokes_matrix.clear();'
p13697
aS'    TrilinosWrappers::BlockSparsityPattern sp(stokes_partitioning,'
p13698
aS'                                              stokes_partitioning,'
p13699
aS'                                              stokes_relevant_partitioning,'
p13700
aS'                                              MPI_COMM_WORLD);'
p13701
aS'    Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p13702
aS'    for (unsigned int c = 0; c < dim + 1; ++c)'
p13703
aS'      for (unsigned int d = 0; d < dim + 1; ++d)'
p13704
aS'        if (!((c == dim) && (d == dim)))'
p13705
aS'          coupling[c][d] = DoFTools::always;'
p13706
aS'        else'
p13707
aS'          coupling[c][d] = DoFTools::none;'
p13708
aS'    DoFTools::make_sparsity_pattern(stokes_dof_handler,'
p13709
aS'                                    coupling,'
p13710
aS'                                    sp,'
p13711
aS'                                    stokes_constraints,'
p13712
aS'                                    false,'
p13713
aS'                                    Utilities::MPI::this_mpi_process('
p13714
aS'                                      MPI_COMM_WORLD));'
p13715
aS'    sp.compress();'
p13716
aS'    stokes_matrix.reinit(sp);'
p13717
aS'  }'
p13718
aS'  template <int dim>'
p13719
aS'  void BoussinesqFlowProblem<dim>::setup_stokes_preconditioner('
p13720
aS'    const std::vector<IndexSet> &stokes_partitioning,'
p13721
aS'    const std::vector<IndexSet> &stokes_relevant_partitioning)'
p13722
aS'  {'
p13723
aS'    Amg_preconditioner.reset();'
p13724
aS'    Mp_preconditioner.reset();'
p13725
aS'    stokes_preconditioner_matrix.clear();'
p13726
aS'    TrilinosWrappers::BlockSparsityPattern sp(stokes_partitioning,'
p13727
aS'                                              stokes_partitioning,'
p13728
aS'                                              stokes_relevant_partitioning,'
p13729
aS'                                              MPI_COMM_WORLD);'
p13730
aS'    Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p13731
aS'    for (unsigned int c = 0; c < dim + 1; ++c)'
p13732
aS'      for (unsigned int d = 0; d < dim + 1; ++d)'
p13733
aS'        if (c == d)'
p13734
aS'          coupling[c][d] = DoFTools::always;'
p13735
aS'        else'
p13736
aS'          coupling[c][d] = DoFTools::none;'
p13737
aS'    DoFTools::make_sparsity_pattern(stokes_dof_handler,'
p13738
aS'                                    coupling,'
p13739
aS'                                    sp,'
p13740
aS'                                    stokes_constraints,'
p13741
aS'                                    false,'
p13742
aS'                                    Utilities::MPI::this_mpi_process('
p13743
aS'                                      MPI_COMM_WORLD));'
p13744
aS'    sp.compress();'
p13745
aS'    stokes_preconditioner_matrix.reinit(sp);'
p13746
aS'  }'
p13747
aS'  template <int dim>'
p13748
aS'  void BoussinesqFlowProblem<dim>::setup_temperature_matrices('
p13749
aS'    const IndexSet &temperature_partitioner,'
p13750
aS'    const IndexSet &temperature_relevant_partitioner)'
p13751
aS'  {'
p13752
aS'    T_preconditioner.reset();'
p13753
aS'    temperature_mass_matrix.clear();'
p13754
aS'    temperature_stiffness_matrix.clear();'
p13755
aS'    temperature_matrix.clear();'
p13756
aS'    TrilinosWrappers::SparsityPattern sp(temperature_partitioner,'
p13757
aS'                                         temperature_partitioner,'
p13758
aS'                                         temperature_relevant_partitioner,'
p13759
aS'                                         MPI_COMM_WORLD);'
p13760
aS'    DoFTools::make_sparsity_pattern(temperature_dof_handler,'
p13761
aS'                                    sp,'
p13762
aS'                                    temperature_constraints,'
p13763
aS'                                    false,'
p13764
aS'                                    Utilities::MPI::this_mpi_process('
p13765
aS'                                      MPI_COMM_WORLD));'
p13766
aS'    sp.compress();'
p13767
aS'    temperature_matrix.reinit(sp);'
p13768
aS'    temperature_mass_matrix.reinit(sp);'
p13769
aS'    temperature_stiffness_matrix.reinit(sp);'
p13770
aS'  }'
p13771
aS'  template <int dim>'
p13772
aS'  void BoussinesqFlowProblem<dim>::setup_dofs()'
p13773
aS'  {'
p13774
aS'    TimerOutput::Scope timing_section(computing_timer, "Setup dof systems");'
p13775
aS'    stokes_dof_handler.distribute_dofs(stokes_fe);'
p13776
aS'    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0);'
p13777
aS'    stokes_sub_blocks[dim] = 1;'
p13778
aS'    DoFRenumbering::component_wise(stokes_dof_handler, stokes_sub_blocks);'
p13779
aS'    temperature_dof_handler.distribute_dofs(temperature_fe);'
p13780
aS'    const std::vector<types::global_dof_index> stokes_dofs_per_block ='
p13781
aS'      DoFTools::count_dofs_per_fe_block(stokes_dof_handler, stokes_sub_blocks);'
p13782
aS'    const unsigned int n_u = stokes_dofs_per_block[0],'
p13783
aS'                       n_p = stokes_dofs_per_block[1],'
p13784
aS'                       n_T = temperature_dof_handler.n_dofs();'
p13785
aS'    std::locale s = pcout.get_stream().getloc();'
p13786
aS'    pcout.get_stream().imbue(std::locale(""));'
p13787
aS'    pcout << "Number of active cells: " << triangulation.n_global_active_cells()'
p13788
aS'          << " (on " << triangulation.n_levels() << " levels)" << std::endl'
p13789
aS'          << "Number of degrees of freedom: " << n_u + n_p + n_T << " (" << n_u'
p13790
aS"          << '+' << n_p << '+' << n_T << ')' << std::endl"
p13791
aS'          << std::endl;'
p13792
aS'    pcout.get_stream().imbue(s);'
p13793
aS'    std::vector<IndexSet> stokes_partitioning, stokes_relevant_partitioning;'
p13794
aS'    IndexSet              temperature_partitioning(n_T),'
p13795
aS'      temperature_relevant_partitioning(n_T);'
p13796
aS'    IndexSet stokes_relevant_set;'
p13797
aS'    {'
p13798
aS'      IndexSet stokes_index_set = stokes_dof_handler.locally_owned_dofs();'
p13799
aS'      stokes_partitioning.push_back(stokes_index_set.get_view(0, n_u));'
p13800
aS'      stokes_partitioning.push_back(stokes_index_set.get_view(n_u, n_u + n_p));'
p13801
aS'      DoFTools::extract_locally_relevant_dofs(stokes_dof_handler,'
p13802
aS'                                              stokes_relevant_set);'
p13803
aS'      stokes_relevant_partitioning.push_back('
p13804
aS'        stokes_relevant_set.get_view(0, n_u));'
p13805
aS'      stokes_relevant_partitioning.push_back('
p13806
aS'        stokes_relevant_set.get_view(n_u, n_u + n_p));'
p13807
aS'      temperature_partitioning = temperature_dof_handler.locally_owned_dofs();'
p13808
aS'      DoFTools::extract_locally_relevant_dofs('
p13809
aS'        temperature_dof_handler, temperature_relevant_partitioning);'
p13810
aS'    }'
p13811
aS'    {'
p13812
aS'      stokes_constraints.clear();'
p13813
aS'      stokes_constraints.reinit(stokes_relevant_set);'
p13814
aS'      DoFTools::make_hanging_node_constraints(stokes_dof_handler,'
p13815
aS'                                              stokes_constraints);'
p13816
aS'      FEValuesExtractors::Vector velocity_components(0);'
p13817
aS'      VectorTools::interpolate_boundary_values('
p13818
aS'        stokes_dof_handler,'
p13819
aS'        0,'
p13820
aS'        Functions::ZeroFunction<dim>(dim + 1),'
p13821
aS'        stokes_constraints,'
p13822
aS'        stokes_fe.component_mask(velocity_components));'
p13823
aS'      std::set<types::boundary_id> no_normal_flux_boundaries;'
p13824
aS'      no_normal_flux_boundaries.insert(1);'
p13825
aS'      VectorTools::compute_no_normal_flux_constraints(stokes_dof_handler,'
p13826
aS'                                                      0,'
p13827
aS'                                                      no_normal_flux_boundaries,'
p13828
aS'                                                      stokes_constraints,'
p13829
aS'                                                      mapping);'
p13830
aS'      stokes_constraints.close();'
p13831
aS'    }'
p13832
aS'    {'
p13833
aS'      temperature_constraints.clear();'
p13834
aS'      temperature_constraints.reinit(temperature_relevant_partitioning);'
p13835
aS'      DoFTools::make_hanging_node_constraints(temperature_dof_handler,'
p13836
aS'                                              temperature_constraints);'
p13837
aS'      VectorTools::interpolate_boundary_values('
p13838
aS'        temperature_dof_handler,'
p13839
aS'        0,'
p13840
aS'        EquationData::TemperatureInitialValues<dim>(),'
p13841
aS'        temperature_constraints);'
p13842
aS'      VectorTools::interpolate_boundary_values('
p13843
aS'        temperature_dof_handler,'
p13844
aS'        1,'
p13845
aS'        EquationData::TemperatureInitialValues<dim>(),'
p13846
aS'        temperature_constraints);'
p13847
aS'      temperature_constraints.close();'
p13848
aS'    }'
p13849
aS'    setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning);'
p13850
aS'    setup_stokes_preconditioner(stokes_partitioning,'
p13851
aS'                                stokes_relevant_partitioning);'
p13852
aS'    setup_temperature_matrices(temperature_partitioning,'
p13853
aS'                               temperature_relevant_partitioning);'
p13854
aS'    stokes_rhs.reinit(stokes_partitioning,'
p13855
aS'                      stokes_relevant_partitioning,'
p13856
aS'                      MPI_COMM_WORLD,'
p13857
aS'                      true);'
p13858
aS'    stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD);'
p13859
aS'    old_stokes_solution.reinit(stokes_solution);'
p13860
aS'    temperature_rhs.reinit(temperature_partitioning,'
p13861
aS'                           temperature_relevant_partitioning,'
p13862
aS'                           MPI_COMM_WORLD,'
p13863
aS'                           true);'
p13864
aS'    temperature_solution.reinit(temperature_relevant_partitioning,'
p13865
aS'                                MPI_COMM_WORLD);'
p13866
aS'    old_temperature_solution.reinit(temperature_solution);'
p13867
aS'    old_old_temperature_solution.reinit(temperature_solution);'
p13868
aS'    rebuild_stokes_matrix              = true;'
p13869
aS'    rebuild_stokes_preconditioner      = true;'
p13870
aS'    rebuild_temperature_matrices       = true;'
p13871
aS'    rebuild_temperature_preconditioner = true;'
p13872
aS'  }'
p13873
aS'  template <int dim>'
p13874
aS'  void BoussinesqFlowProblem<dim>::local_assemble_stokes_preconditioner('
p13875
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13876
aS'    Assembly::Scratch::StokesPreconditioner<dim> &        scratch,'
p13877
aS'    Assembly::CopyData::StokesPreconditioner<dim> &       data)'
p13878
aS'  {'
p13879
aS'    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p13880
aS'    const unsigned int n_q_points ='
p13881
aS'      scratch.stokes_fe_values.n_quadrature_points;'
p13882
aS'    const FEValuesExtractors::Vector velocities(0);'
p13883
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p13884
aS'    scratch.stokes_fe_values.reinit(cell);'
p13885
aS'    cell->get_dof_indices(data.local_dof_indices);'
p13886
aS'    data.local_matrix = 0;'
p13887
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13888
aS'      {'
p13889
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p13890
aS'          {'
p13891
aS'            scratch.grad_phi_u[k] ='
p13892
aS'              scratch.stokes_fe_values[velocities].gradient(k, q);'
p13893
aS'            scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q);'
p13894
aS'          }'
p13895
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p13896
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p13897
aS'            data.local_matrix(i, j) +='
p13898
aS'              (EquationData::eta *'
p13899
aS'                 scalar_product(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) +'
p13900
aS'               (1. / EquationData::eta) * EquationData::pressure_scaling *'
p13901
aS'                 EquationData::pressure_scaling *'
p13902
aS'                 (scratch.phi_p[i] * scratch.phi_p[j])) *'
p13903
aS'              scratch.stokes_fe_values.JxW(q);'
p13904
aS'      }'
p13905
aS'  }'
p13906
aS'  template <int dim>'
p13907
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_stokes_preconditioner('
p13908
aS'    const Assembly::CopyData::StokesPreconditioner<dim> &data)'
p13909
aS'  {'
p13910
aS'    stokes_constraints.distribute_local_to_global(data.local_matrix,'
p13911
aS'                                                  data.local_dof_indices,'
p13912
aS'                                                  stokes_preconditioner_matrix);'
p13913
aS'  }'
p13914
aS'  template <int dim>'
p13915
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_preconditioner()'
p13916
aS'  {'
p13917
aS'    stokes_preconditioner_matrix = 0;'
p13918
aS'    const QGauss<dim> quadrature_formula(parameters.stokes_velocity_degree + 1);'
p13919
aS'    using CellFilter ='
p13920
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p13921
aS'    auto worker ='
p13922
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13923
aS'             Assembly::Scratch::StokesPreconditioner<dim> &        scratch,'
p13924
aS'             Assembly::CopyData::StokesPreconditioner<dim> &       data) {'
p13925
aS'        this->local_assemble_stokes_preconditioner(cell, scratch, data);'
p13926
aS'      };'
p13927
aS'    auto copier ='
p13928
aS'      [this](const Assembly::CopyData::StokesPreconditioner<dim> &data) {'
p13929
aS'        this->copy_local_to_global_stokes_preconditioner(data);'
p13930
aS'      };'
p13931
aS'    WorkStream::run(CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13932
aS'                               stokes_dof_handler.begin_active()),'
p13933
aS'                    CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13934
aS'                               stokes_dof_handler.end()),'
p13935
aS'                    worker,'
p13936
aS'                    copier,'
p13937
aS'                    Assembly::Scratch::StokesPreconditioner<dim>('
p13938
aS'                      stokes_fe,'
p13939
aS'                      quadrature_formula,'
p13940
aS'                      mapping,'
p13941
aS'                      update_JxW_values | update_values | update_gradients),'
p13942
aS'                    Assembly::CopyData::StokesPreconditioner<dim>(stokes_fe));'
p13943
aS'    stokes_preconditioner_matrix.compress(VectorOperation::add);'
p13944
aS'  }'
p13945
aS'  template <int dim>'
p13946
aS'  void BoussinesqFlowProblem<dim>::build_stokes_preconditioner()'
p13947
aS'  {'
p13948
aS'    if (rebuild_stokes_preconditioner == false)'
p13949
aS'      return;'
p13950
aS'    TimerOutput::Scope timer_section(computing_timer,'
p13951
aS'                                     "   Build Stokes preconditioner");'
p13952
aS'    pcout << "   Rebuilding Stokes preconditioner..." << std::flush;'
p13953
aS'    assemble_stokes_preconditioner();'
p13954
aS'    std::vector<std::vector<bool>> constant_modes;'
p13955
aS'    FEValuesExtractors::Vector     velocity_components(0);'
p13956
aS'    DoFTools::extract_constant_modes(stokes_dof_handler,'
p13957
aS'                                     stokes_fe.component_mask('
p13958
aS'                                       velocity_components),'
p13959
aS'                                     constant_modes);'
p13960
aS'    Mp_preconditioner ='
p13961
aS'      std::make_shared<TrilinosWrappers::PreconditionJacobi>();'
p13962
aS'    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionAMG>();'
p13963
aS'    TrilinosWrappers::PreconditionAMG::AdditionalData Amg_data;'
p13964
aS'    Amg_data.constant_modes        = constant_modes;'
p13965
aS'    Amg_data.elliptic              = true;'
p13966
aS'    Amg_data.higher_order_elements = true;'
p13967
aS'    Amg_data.smoother_sweeps       = 2;'
p13968
aS'    Amg_data.aggregation_threshold = 0.02;'
p13969
aS'    Mp_preconditioner->initialize(stokes_preconditioner_matrix.block(1, 1));'
p13970
aS'    Amg_preconditioner->initialize(stokes_preconditioner_matrix.block(0, 0),'
p13971
aS'                                   Amg_data);'
p13972
aS'    rebuild_stokes_preconditioner = false;'
p13973
aS'    pcout << std::endl;'
p13974
aS'  }'
p13975
aS'  template <int dim>'
p13976
aS'  void BoussinesqFlowProblem<dim>::local_assemble_stokes_system('
p13977
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13978
aS'    Assembly::Scratch::StokesSystem<dim> &                scratch,'
p13979
aS'    Assembly::CopyData::StokesSystem<dim> &               data)'
p13980
aS'  {'
p13981
aS'    const unsigned int dofs_per_cell ='
p13982
aS'      scratch.stokes_fe_values.get_fe().n_dofs_per_cell();'
p13983
aS'    const unsigned int n_q_points ='
p13984
aS'      scratch.stokes_fe_values.n_quadrature_points;'
p13985
aS'    const FEValuesExtractors::Vector velocities(0);'
p13986
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p13987
aS'    scratch.stokes_fe_values.reinit(cell);'
p13988
aS'    typename DoFHandler<dim>::active_cell_iterator temperature_cell('
p13989
aS'      &triangulation, cell->level(), cell->index(), &temperature_dof_handler);'
p13990
aS'    scratch.temperature_fe_values.reinit(temperature_cell);'
p13991
aS'    if (rebuild_stokes_matrix)'
p13992
aS'      data.local_matrix = 0;'
p13993
aS'    data.local_rhs = 0;'
p13994
aS'    scratch.temperature_fe_values.get_function_values('
p13995
aS'      old_temperature_solution, scratch.old_temperature_values);'
p13996
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13997
aS'      {'
p13998
aS'        const double old_temperature = scratch.old_temperature_values[q];'
p13999
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p14000
aS'          {'
p14001
aS'            scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q);'
p14002
aS'            if (rebuild_stokes_matrix)'
p14003
aS'              {'
p14004
aS'                scratch.grads_phi_u[k] ='
p14005
aS'                  scratch.stokes_fe_values[velocities].symmetric_gradient(k, q);'
p14006
aS'                scratch.div_phi_u[k] ='
p14007
aS'                  scratch.stokes_fe_values[velocities].divergence(k, q);'
p14008
aS'                scratch.phi_p[k] ='
p14009
aS'                  scratch.stokes_fe_values[pressure].value(k, q);'
p14010
aS'              }'
p14011
aS'          }'
p14012
aS'        if (rebuild_stokes_matrix == true)'
p14013
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p14014
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p14015
aS'              data.local_matrix(i, j) +='
p14016
aS'                (EquationData::eta * 2 *'
p14017
aS'                   (scratch.grads_phi_u[i] * scratch.grads_phi_u[j]) -'
p14018
aS'                 (EquationData::pressure_scaling * scratch.div_phi_u[i] *'
p14019
aS'                  scratch.phi_p[j]) -'
p14020
aS'                 (EquationData::pressure_scaling * scratch.phi_p[i] *'
p14021
aS'                  scratch.div_phi_u[j])) *'
p14022
aS'                scratch.stokes_fe_values.JxW(q);'
p14023
aS'        const Tensor<1, dim> gravity = EquationData::gravity_vector('
p14024
aS'          scratch.stokes_fe_values.quadrature_point(q));'
p14025
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p14026
aS'          data.local_rhs(i) += (EquationData::density(old_temperature) *'
p14027
aS'                                gravity * scratch.phi_u[i]) *'
p14028
aS'                               scratch.stokes_fe_values.JxW(q);'
p14029
aS'      }'
p14030
aS'    cell->get_dof_indices(data.local_dof_indices);'
p14031
aS'  }'
p14032
aS'  template <int dim>'
p14033
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_stokes_system('
p14034
aS'    const Assembly::CopyData::StokesSystem<dim> &data)'
p14035
aS'  {'
p14036
aS'    if (rebuild_stokes_matrix == true)'
p14037
aS'      stokes_constraints.distribute_local_to_global(data.local_matrix,'
p14038
aS'                                                    data.local_rhs,'
p14039
aS'                                                    data.local_dof_indices,'
p14040
aS'                                                    stokes_matrix,'
p14041
aS'                                                    stokes_rhs);'
p14042
aS'    else'
p14043
aS'      stokes_constraints.distribute_local_to_global(data.local_rhs,'
p14044
aS'                                                    data.local_dof_indices,'
p14045
aS'                                                    stokes_rhs);'
p14046
aS'  }'
p14047
aS'  template <int dim>'
p14048
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_system()'
p14049
aS'  {'
p14050
aS'    TimerOutput::Scope timer_section(computing_timer,'
p14051
aS'                                     "   Assemble Stokes system");'
p14052
aS'    if (rebuild_stokes_matrix == true)'
p14053
aS'      stokes_matrix = 0;'
p14054
aS'    stokes_rhs = 0;'
p14055
aS'    const QGauss<dim> quadrature_formula(parameters.stokes_velocity_degree + 1);'
p14056
aS'    using CellFilter ='
p14057
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p14058
aS'    WorkStream::run('
p14059
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(),'
p14060
aS'                 stokes_dof_handler.begin_active()),'
p14061
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(), stokes_dof_handler.end()),'
p14062
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p14063
aS'             Assembly::Scratch::StokesSystem<dim> &                scratch,'
p14064
aS'             Assembly::CopyData::StokesSystem<dim> &               data) {'
p14065
aS'        this->local_assemble_stokes_system(cell, scratch, data);'
p14066
aS'      },'
p14067
aS'      [this](const Assembly::CopyData::StokesSystem<dim> &data) {'
p14068
aS'        this->copy_local_to_global_stokes_system(data);'
p14069
aS'      },'
p14070
aS'      Assembly::Scratch::StokesSystem<dim>('
p14071
aS'        stokes_fe,'
p14072
aS'        mapping,'
p14073
aS'        quadrature_formula,'
p14074
aS'        (update_values | update_quadrature_points | update_JxW_values |'
p14075
aS'         (rebuild_stokes_matrix == true ? update_gradients : UpdateFlags(0))),'
p14076
aS'        temperature_fe,'
p14077
aS'        update_values),'
p14078
aS'      Assembly::CopyData::StokesSystem<dim>(stokes_fe));'
p14079
aS'    if (rebuild_stokes_matrix == true)'
p14080
aS'      stokes_matrix.compress(VectorOperation::add);'
p14081
aS'    stokes_rhs.compress(VectorOperation::add);'
p14082
aS'    rebuild_stokes_matrix = false;'
p14083
aS'    pcout << std::endl;'
p14084
aS'  }'
p14085
aS'  template <int dim>'
p14086
aS'  void BoussinesqFlowProblem<dim>::local_assemble_temperature_matrix('
p14087
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p14088
aS'    Assembly::Scratch::TemperatureMatrix<dim> &           scratch,'
p14089
aS'    Assembly::CopyData::TemperatureMatrix<dim> &          data)'
p14090
aS'  {'
p14091
aS'    const unsigned int dofs_per_cell ='
p14092
aS'      scratch.temperature_fe_values.get_fe().n_dofs_per_cell();'
p14093
aS'    const unsigned int n_q_points ='
p14094
aS'      scratch.temperature_fe_values.n_quadrature_points;'
p14095
aS'    scratch.temperature_fe_values.reinit(cell);'
p14096
aS'    cell->get_dof_indices(data.local_dof_indices);'
p14097
aS'    data.local_mass_matrix      = 0;'
p14098
aS'    data.local_stiffness_matrix = 0;'
p14099
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p14100
aS'      {'
p14101
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p14102
aS'          {'
p14103
aS'            scratch.grad_phi_T[k] ='
p14104
aS'              scratch.temperature_fe_values.shape_grad(k, q);'
p14105
aS'            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);'
p14106
aS'          }'
p14107
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p14108
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p14109
aS'            {'
p14110
aS'              data.local_mass_matrix(i, j) +='
p14111
aS'                (scratch.phi_T[i] * scratch.phi_T[j] *'
p14112
aS'                 scratch.temperature_fe_values.JxW(q));'
p14113
aS'              data.local_stiffness_matrix(i, j) +='
p14114
aS'                (EquationData::kappa * scratch.grad_phi_T[i] *'
p14115
aS'                 scratch.grad_phi_T[j] * scratch.temperature_fe_values.JxW(q));'
p14116
aS'            }'
p14117
aS'      }'
p14118
aS'  }'
p14119
aS'  template <int dim>'
p14120
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_temperature_matrix('
p14121
aS'    const Assembly::CopyData::TemperatureMatrix<dim> &data)'
p14122
aS'  {'
p14123
aS'    temperature_constraints.distribute_local_to_global(data.local_mass_matrix,'
p14124
aS'                                                       data.local_dof_indices,'
p14125
aS'                                                       temperature_mass_matrix);'
p14126
aS'    temperature_constraints.distribute_local_to_global('
p14127
aS'      data.local_stiffness_matrix,'
p14128
aS'      data.local_dof_indices,'
p14129
aS'      temperature_stiffness_matrix);'
p14130
aS'  }'
p14131
aS'  template <int dim>'
p14132
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_matrix()'
p14133
aS'  {'
p14134
aS'    if (rebuild_temperature_matrices == false)'
p14135
aS'      return;'
p14136
aS'    TimerOutput::Scope timer_section(computing_timer,'
p14137
aS'                                     "   Assemble temperature matrices");'
p14138
aS'    temperature_mass_matrix      = 0;'
p14139
aS'    temperature_stiffness_matrix = 0;'
p14140
aS'    const QGauss<dim> quadrature_formula(parameters.temperature_degree + 2);'
p14141
aS'    using CellFilter ='
p14142
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p14143
aS'    WorkStream::run('
p14144
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(),'
p14145
aS'                 temperature_dof_handler.begin_active()),'
p14146
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(),'
p14147
aS'                 temperature_dof_handler.end()),'
p14148
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p14149
aS'             Assembly::Scratch::TemperatureMatrix<dim> &           scratch,'
p14150
aS'             Assembly::CopyData::TemperatureMatrix<dim> &          data) {'
p14151
aS'        this->local_assemble_temperature_matrix(cell, scratch, data);'
p14152
aS'      },'
p14153
aS'      [this](const Assembly::CopyData::TemperatureMatrix<dim> &data) {'
p14154
aS'        this->copy_local_to_global_temperature_matrix(data);'
p14155
aS'      },'
p14156
aS'      Assembly::Scratch::TemperatureMatrix<dim>(temperature_fe,'
p14157
aS'                                                mapping,'
p14158
aS'                                                quadrature_formula),'
p14159
aS'      Assembly::CopyData::TemperatureMatrix<dim>(temperature_fe));'
p14160
aS'    temperature_mass_matrix.compress(VectorOperation::add);'
p14161
aS'    temperature_stiffness_matrix.compress(VectorOperation::add);'
p14162
aS'    rebuild_temperature_matrices       = false;'
p14163
aS'    rebuild_temperature_preconditioner = true;'
p14164
aS'  }'
p14165
aS'  template <int dim>'
p14166
aS'  void BoussinesqFlowProblem<dim>::local_assemble_temperature_rhs('
p14167
aS'    const std::pair<double, double> global_T_range,'
p14168
aS'    const double                    global_max_velocity,'
p14169
aS'    const double                    global_entropy_variation,'
p14170
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p14171
aS'    Assembly::Scratch::TemperatureRHS<dim> &              scratch,'
p14172
aS'    Assembly::CopyData::TemperatureRHS<dim> &             data)'
p14173
aS'  {'
p14174
aS'    const bool use_bdf2_scheme = (timestep_number != 0);'
p14175
aS'    const unsigned int dofs_per_cell ='
p14176
aS'      scratch.temperature_fe_values.get_fe().n_dofs_per_cell();'
p14177
aS'    const unsigned int n_q_points ='
p14178
aS'      scratch.temperature_fe_values.n_quadrature_points;'
p14179
aS'    const FEValuesExtractors::Vector velocities(0);'
p14180
aS'    data.local_rhs     = 0;'
p14181
aS'    data.matrix_for_bc = 0;'
p14182
aS'    cell->get_dof_indices(data.local_dof_indices);'
p14183
aS'    scratch.temperature_fe_values.reinit(cell);'
p14184
aS'    typename DoFHandler<dim>::active_cell_iterator stokes_cell('
p14185
aS'      &triangulation, cell->level(), cell->index(), &stokes_dof_handler);'
p14186
aS'    scratch.stokes_fe_values.reinit(stokes_cell);'
p14187
aS'    scratch.temperature_fe_values.get_function_values('
p14188
aS'      old_temperature_solution, scratch.old_temperature_values);'
p14189
aS'    scratch.temperature_fe_values.get_function_values('
p14190
aS'      old_old_temperature_solution, scratch.old_old_temperature_values);'
p14191
aS'    scratch.temperature_fe_values.get_function_gradients('
p14192
aS'      old_temperature_solution, scratch.old_temperature_grads);'
p14193
aS'    scratch.temperature_fe_values.get_function_gradients('
p14194
aS'      old_old_temperature_solution, scratch.old_old_temperature_grads);'
p14195
aS'    scratch.temperature_fe_values.get_function_laplacians('
p14196
aS'      old_temperature_solution, scratch.old_temperature_laplacians);'
p14197
aS'    scratch.temperature_fe_values.get_function_laplacians('
p14198
aS'      old_old_temperature_solution, scratch.old_old_temperature_laplacians);'
p14199
aS'    scratch.stokes_fe_values[velocities].get_function_values('
p14200
aS'      stokes_solution, scratch.old_velocity_values);'
p14201
aS'    scratch.stokes_fe_values[velocities].get_function_values('
p14202
aS'      old_stokes_solution, scratch.old_old_velocity_values);'
p14203
aS'    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients('
p14204
aS'      stokes_solution, scratch.old_strain_rates);'
p14205
aS'    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients('
p14206
aS'      old_stokes_solution, scratch.old_old_strain_rates);'
p14207
aS'    const double nu ='
p14208
aS'      compute_viscosity(scratch.old_temperature_values,'
p14209
aS'                        scratch.old_old_temperature_values,'
p14210
aS'                        scratch.old_temperature_grads,'
p14211
aS'                        scratch.old_old_temperature_grads,'
p14212
aS'                        scratch.old_temperature_laplacians,'
p14213
aS'                        scratch.old_old_temperature_laplacians,'
p14214
aS'                        scratch.old_velocity_values,'
p14215
aS'                        scratch.old_old_velocity_values,'
p14216
aS'                        scratch.old_strain_rates,'
p14217
aS'                        scratch.old_old_strain_rates,'
p14218
aS'                        global_max_velocity,'
p14219
aS'                        global_T_range.second - global_T_range.first,'
p14220
aS'                        0.5 * (global_T_range.second + global_T_range.first),'
p14221
aS'                        global_entropy_variation,'
p14222
aS'                        cell->diameter());'
p14223
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p14224
aS'      {'
p14225
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p14226
aS'          {'
p14227
aS'            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);'
p14228
aS'            scratch.grad_phi_T[k] ='
p14229
aS'              scratch.temperature_fe_values.shape_grad(k, q);'
p14230
aS'          }'
p14231
aS'        const double T_term_for_rhs ='
p14232
aS'          (use_bdf2_scheme ?'
p14233
aS'             (scratch.old_temperature_values[q] *'
p14234
aS'                (1 + time_step / old_time_step) -'
p14235
aS'              scratch.old_old_temperature_values[q] * (time_step * time_step) /'
p14236
aS'                (old_time_step * (time_step + old_time_step))) :'
p14237
aS'             scratch.old_temperature_values[q]);'
p14238
aS'        const double ext_T ='
p14239
aS'          (use_bdf2_scheme ? (scratch.old_temperature_values[q] *'
p14240
aS'                                (1 + time_step / old_time_step) -'
p14241
aS'                              scratch.old_old_temperature_values[q] *'
p14242
aS'                                time_step / old_time_step) :'
p14243
aS'                             scratch.old_temperature_values[q]);'
p14244
aS'        const Tensor<1, dim> ext_grad_T ='
p14245
aS'          (use_bdf2_scheme ? (scratch.old_temperature_grads[q] *'
p14246
aS'                                (1 + time_step / old_time_step) -'
p14247
aS'                              scratch.old_old_temperature_grads[q] * time_step /'
p14248
aS'                                old_time_step) :'
p14249
aS'                             scratch.old_temperature_grads[q]);'
p14250
aS'        const Tensor<1, dim> extrapolated_u ='
p14251
aS'          (use_bdf2_scheme ?'
p14252
aS'             (scratch.old_velocity_values[q] * (1 + time_step / old_time_step) -'
p14253
aS'              scratch.old_old_velocity_values[q] * time_step / old_time_step) :'
p14254
aS'             scratch.old_velocity_values[q]);'
p14255
aS'        const SymmetricTensor<2, dim> extrapolated_strain_rate ='
p14256
aS'          (use_bdf2_scheme ?'
p14257
aS'             (scratch.old_strain_rates[q] * (1 + time_step / old_time_step) -'
p14258
aS'              scratch.old_old_strain_rates[q] * time_step / old_time_step) :'
p14259
aS'             scratch.old_strain_rates[q]);'
p14260
aS'        const double gamma ='
p14261
aS'          ((EquationData::radiogenic_heating * EquationData::density(ext_T) +'
p14262
aS'            2 * EquationData::eta * extrapolated_strain_rate *'
p14263
aS'              extrapolated_strain_rate) /'
p14264
aS'           (EquationData::density(ext_T) * EquationData::specific_heat));'
p14265
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p14266
aS'          {'
p14267
aS'            data.local_rhs(i) +='
p14268
aS'              (T_term_for_rhs * scratch.phi_T[i] -'
p14269
aS'               time_step * extrapolated_u * ext_grad_T * scratch.phi_T[i] -'
p14270
aS'               time_step * nu * ext_grad_T * scratch.grad_phi_T[i] +'
p14271
aS'               time_step * gamma * scratch.phi_T[i]) *'
p14272
aS'              scratch.temperature_fe_values.JxW(q);'
p14273
aS'            if (temperature_constraints.is_inhomogeneously_constrained('
p14274
aS'                  data.local_dof_indices[i]))'
p14275
aS'              {'
p14276
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p14277
aS'                  data.matrix_for_bc(j, i) +='
p14278
aS'                    (scratch.phi_T[i] * scratch.phi_T[j] *'
p14279
aS'                       (use_bdf2_scheme ? ((2 * time_step + old_time_step) /'
p14280
aS'                                           (time_step + old_time_step)) :'
p14281
aS'                                          1.) +'
p14282
aS'                     scratch.grad_phi_T[i] * scratch.grad_phi_T[j] *'
p14283
aS'                       EquationData::kappa * time_step) *'
p14284
aS'                    scratch.temperature_fe_values.JxW(q);'
p14285
aS'              }'
p14286
aS'          }'
p14287
aS'      }'
p14288
aS'  }'
p14289
aS'  template <int dim>'
p14290
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_temperature_rhs('
p14291
aS'    const Assembly::CopyData::TemperatureRHS<dim> &data)'
p14292
aS'  {'
p14293
aS'    temperature_constraints.distribute_local_to_global(data.local_rhs,'
p14294
aS'                                                       data.local_dof_indices,'
p14295
aS'                                                       temperature_rhs,'
p14296
aS'                                                       data.matrix_for_bc);'
p14297
aS'  }'
p14298
aS'  template <int dim>'
p14299
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_system('
p14300
aS'    const double maximal_velocity)'
p14301
aS'  {'
p14302
aS'    const bool use_bdf2_scheme = (timestep_number != 0);'
p14303
aS'    if (use_bdf2_scheme == true)'
p14304
aS'      {'
p14305
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p14306
aS'        temperature_matrix *='
p14307
aS'          (2 * time_step + old_time_step) / (time_step + old_time_step);'
p14308
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p14309
aS'      }'
p14310
aS'    else'
p14311
aS'      {'
p14312
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p14313
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p14314
aS'      }'
p14315
aS'    if (rebuild_temperature_preconditioner == true)'
p14316
aS'      {'
p14317
aS'        T_preconditioner ='
p14318
aS'          std::make_shared<TrilinosWrappers::PreconditionJacobi>();'
p14319
aS'        T_preconditioner->initialize(temperature_matrix);'
p14320
aS'        rebuild_temperature_preconditioner = false;'
p14321
aS'      }'
p14322
aS'    temperature_rhs = 0;'
p14323
aS'    const QGauss<dim> quadrature_formula(parameters.temperature_degree + 2);'
p14324
aS'    const std::pair<double, double> global_T_range ='
p14325
aS'      get_extrapolated_temperature_range();'
p14326
aS'    const double average_temperature ='
p14327
aS'      0.5 * (global_T_range.first + global_T_range.second);'
p14328
aS'    const double global_entropy_variation ='
p14329
aS'      get_entropy_variation(average_temperature);'
p14330
aS'    using CellFilter ='
p14331
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p14332
aS'    auto worker ='
p14333
aS'      [this, global_T_range, maximal_velocity, global_entropy_variation]('
p14334
aS'        const typename DoFHandler<dim>::active_cell_iterator &cell,'
p14335
aS'        Assembly::Scratch::TemperatureRHS<dim> &              scratch,'
p14336
aS'        Assembly::CopyData::TemperatureRHS<dim> &             data) {'
p14337
aS'        this->local_assemble_temperature_rhs(global_T_range,'
p14338
aS'                                             maximal_velocity,'
p14339
aS'                                             global_entropy_variation,'
p14340
aS'                                             cell,'
p14341
aS'                                             scratch,'
p14342
aS'                                             data);'
p14343
aS'      };'
p14344
aS'    auto copier = [this](const Assembly::CopyData::TemperatureRHS<dim> &data) {'
p14345
aS'      this->copy_local_to_global_temperature_rhs(data);'
p14346
aS'    };'
p14347
aS'    WorkStream::run(CellFilter(IteratorFilters::LocallyOwnedCell(),'
p14348
aS'                               temperature_dof_handler.begin_active()),'
p14349
aS'                    CellFilter(IteratorFilters::LocallyOwnedCell(),'
p14350
aS'                               temperature_dof_handler.end()),'
p14351
aS'                    worker,'
p14352
aS'                    copier,'
p14353
aS'                    Assembly::Scratch::TemperatureRHS<dim>('
p14354
aS'                      temperature_fe, stokes_fe, mapping, quadrature_formula),'
p14355
aS'                    Assembly::CopyData::TemperatureRHS<dim>(temperature_fe));'
p14356
aS'    temperature_rhs.compress(VectorOperation::add);'
p14357
aS'  }'
p14358
aS'  template <int dim>'
p14359
aS'  void BoussinesqFlowProblem<dim>::solve()'
p14360
aS'  {'
p14361
aS'    {'
p14362
aS'      TimerOutput::Scope timer_section(computing_timer,'
p14363
aS'                                       "   Solve Stokes system");'
p14364
aS'      pcout << "   Solving Stokes system... " << std::flush;'
p14365
aS'      TrilinosWrappers::MPI::BlockVector distributed_stokes_solution('
p14366
aS'        stokes_rhs);'
p14367
aS'      distributed_stokes_solution = stokes_solution;'
p14368
aS'      distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;'
p14369
aS'      const unsigned int'
p14370
aS'        start = (distributed_stokes_solution.block(0).size() +'
p14371
aS'                 distributed_stokes_solution.block(1).local_range().first),'
p14372
aS'        end   = (distributed_stokes_solution.block(0).size() +'
p14373
aS'               distributed_stokes_solution.block(1).local_range().second);'
p14374
aS'      for (unsigned int i = start; i < end; ++i)'
p14375
aS'        if (stokes_constraints.is_constrained(i))'
p14376
aS'          distributed_stokes_solution(i) = 0;'
p14377
aS'      PrimitiveVectorMemory<TrilinosWrappers::MPI::BlockVector> mem;'
p14378
aS'      unsigned int  n_iterations     = 0;'
p14379
aS'      const double  solver_tolerance = 1e-8 * stokes_rhs.l2_norm();'
p14380
aS'      SolverControl solver_control(30, solver_tolerance);'
p14381
aS'      try'
p14382
aS'        {'
p14383
aS'          const LinearSolvers::BlockSchurPreconditioner<'
p14384
aS'            TrilinosWrappers::PreconditionAMG,'
p14385
aS'            TrilinosWrappers::PreconditionJacobi>'
p14386
aS'            preconditioner(stokes_matrix,'
p14387
aS'                           stokes_preconditioner_matrix,'
p14388
aS'                           *Mp_preconditioner,'
p14389
aS'                           *Amg_preconditioner,'
p14390
aS'                           false);'
p14391
aS'          SolverFGMRES<TrilinosWrappers::MPI::BlockVector> solver('
p14392
aS'            solver_control,'
p14393
aS'            mem,'
p14394
aS'            SolverFGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData('
p14395
aS'              30));'
p14396
aS'          solver.solve(stokes_matrix,'
p14397
aS'                       distributed_stokes_solution,'
p14398
aS'                       stokes_rhs,'
p14399
aS'                       preconditioner);'
p14400
aS'          n_iterations = solver_control.last_step();'
p14401
aS'        }'
p14402
aS'      catch (SolverControl::NoConvergence &)'
p14403
aS'        {'
p14404
aS'          const LinearSolvers::BlockSchurPreconditioner<'
p14405
aS'            TrilinosWrappers::PreconditionAMG,'
p14406
aS'            TrilinosWrappers::PreconditionJacobi>'
p14407
aS'            preconditioner(stokes_matrix,'
p14408
aS'                           stokes_preconditioner_matrix,'
p14409
aS'                           *Mp_preconditioner,'
p14410
aS'                           *Amg_preconditioner,'
p14411
aS'                           true);'
p14412
aS'          SolverControl solver_control_refined(stokes_matrix.m(),'
p14413
aS'                                               solver_tolerance);'
p14414
aS'          SolverFGMRES<TrilinosWrappers::MPI::BlockVector> solver('
p14415
aS'            solver_control_refined,'
p14416
aS'            mem,'
p14417
aS'            SolverFGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData('
p14418
aS'              50));'
p14419
aS'          solver.solve(stokes_matrix,'
p14420
aS'                       distributed_stokes_solution,'
p14421
aS'                       stokes_rhs,'
p14422
aS'                       preconditioner);'
p14423
aS'          n_iterations ='
p14424
aS'            (solver_control.last_step() + solver_control_refined.last_step());'
p14425
aS'        }'
p14426
aS'      stokes_constraints.distribute(distributed_stokes_solution);'
p14427
aS'      distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;'
p14428
aS'      stokes_solution = distributed_stokes_solution;'
p14429
aS'      pcout << n_iterations << " iterations." << std::endl;'
p14430
aS'    }'
p14431
aS'    {'
p14432
aS'      TimerOutput::Scope timer_section(computing_timer,'
p14433
aS'                                       "   Assemble temperature rhs");'
p14434
aS'      old_time_step = time_step;'
p14435
aS'      const double scaling = (dim == 3 ? 0.25 : 1.0);'
p14436
aS'      time_step            = (scaling / (2.1 * dim * std::sqrt(1. * dim)) /'
p14437
aS'                   (parameters.temperature_degree * get_cfl_number()));'
p14438
aS'      const double maximal_velocity = get_maximal_velocity();'
p14439
aS'      pcout << "   Maximal velocity: "'
p14440
aS'            << maximal_velocity * EquationData::year_in_seconds * 100'
p14441
aS'            << " cm/year" << std::endl;'
p14442
aS'      pcout << "   "'
p14443
aS'            << "Time step: " << time_step / EquationData::year_in_seconds'
p14444
aS'            << " years" << std::endl;'
p14445
aS'      temperature_solution = old_temperature_solution;'
p14446
aS'      assemble_temperature_system(maximal_velocity);'
p14447
aS'    }'
p14448
aS'    {'
p14449
aS'      TimerOutput::Scope timer_section(computing_timer,'
p14450
aS'                                       "   Solve temperature system");'
p14451
aS'      SolverControl solver_control(temperature_matrix.m(),'
p14452
aS'                                   1e-12 * temperature_rhs.l2_norm());'
p14453
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p14454
aS'      TrilinosWrappers::MPI::Vector distributed_temperature_solution('
p14455
aS'        temperature_rhs);'
p14456
aS'      distributed_temperature_solution = temperature_solution;'
p14457
aS'      cg.solve(temperature_matrix,'
p14458
aS'               distributed_temperature_solution,'
p14459
aS'               temperature_rhs,'
p14460
aS'               *T_preconditioner);'
p14461
aS'      temperature_constraints.distribute(distributed_temperature_solution);'
p14462
aS'      temperature_solution = distributed_temperature_solution;'
p14463
aS'      pcout << "   " << solver_control.last_step()'
p14464
aS'            << " CG iterations for temperature" << std::endl;'
p14465
aS'      double temperature[2] = {std::numeric_limits<double>::max(),'
p14466
aS'                               -std::numeric_limits<double>::max()};'
p14467
aS'      double global_temperature[2];'
p14468
aS'      for (unsigned int i ='
p14469
aS'             distributed_temperature_solution.local_range().first;'
p14470
aS'           i < distributed_temperature_solution.local_range().second;'
p14471
aS'           ++i)'
p14472
aS'        {'
p14473
aS'          temperature[0] ='
p14474
aS'            std::min<double>(temperature[0],'
p14475
aS'                             distributed_temperature_solution(i));'
p14476
aS'          temperature[1] ='
p14477
aS'            std::max<double>(temperature[1],'
p14478
aS'                             distributed_temperature_solution(i));'
p14479
aS'        }'
p14480
aS'      temperature[0] *= -1.0;'
p14481
aS'      Utilities::MPI::max(temperature, MPI_COMM_WORLD, global_temperature);'
p14482
aS'      global_temperature[0] *= -1.0;'
p14483
aS'      pcout << "   Temperature range: " << global_temperature[0] << \' \''
p14484
aS'            << global_temperature[1] << std::endl;'
p14485
aS'    }'
p14486
aS'  }'
p14487
aS'  template <int dim>'
p14488
aS'  class BoussinesqFlowProblem<dim>::Postprocessor'
p14489
aS'    : public DataPostprocessor<dim>'
p14490
aS'  {'
p14491
aS'  public:'
p14492
aS'    Postprocessor(const unsigned int partition, const double minimal_pressure);'
p14493
aS'    virtual void evaluate_vector_field('
p14494
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p14495
aS'      std::vector<Vector<double>> &computed_quantities) const override;'
p14496
aS'    virtual std::vector<std::string> get_names() const override;'
p14497
aS'    virtual std::vector<'
p14498
aS'      DataComponentInterpretation::DataComponentInterpretation>'
p14499
aS'    get_data_component_interpretation() const override;'
p14500
aS'    virtual UpdateFlags get_needed_update_flags() const override;'
p14501
aS'  private:'
p14502
aS'    const unsigned int partition;'
p14503
aS'    const double       minimal_pressure;'
p14504
aS'  };'
p14505
aS'  template <int dim>'
p14506
aS'  BoussinesqFlowProblem<dim>::Postprocessor::Postprocessor('
p14507
aS'    const unsigned int partition,'
p14508
aS'    const double       minimal_pressure)'
p14509
aS'    : partition(partition)'
p14510
aS'    , minimal_pressure(minimal_pressure)'
p14511
aS'  {}'
p14512
aS'  template <int dim>'
p14513
aS'  std::vector<std::string>'
p14514
aS'  BoussinesqFlowProblem<dim>::Postprocessor::get_names() const'
p14515
aS'  {'
p14516
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p14517
aS'    solution_names.emplace_back("p");'
p14518
aS'    solution_names.emplace_back("T");'
p14519
aS'    solution_names.emplace_back("friction_heating");'
p14520
aS'    solution_names.emplace_back("partition");'
p14521
aS'    return solution_names;'
p14522
aS'  }'
p14523
aS'  template <int dim>'
p14524
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14525
aS'  BoussinesqFlowProblem<dim>::Postprocessor::get_data_component_interpretation()'
p14526
aS'    const'
p14527
aS'  {'
p14528
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14529
aS'      interpretation(dim,'
p14530
aS'                     DataComponentInterpretation::component_is_part_of_vector);'
p14531
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p14532
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p14533
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p14534
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p14535
aS'    return interpretation;'
p14536
aS'  }'
p14537
aS'  template <int dim>'
p14538
aS'  UpdateFlags'
p14539
aS'  BoussinesqFlowProblem<dim>::Postprocessor::get_needed_update_flags() const'
p14540
aS'  {'
p14541
aS'    return update_values | update_gradients | update_quadrature_points;'
p14542
aS'  }'
p14543
aS'  template <int dim>'
p14544
aS'  void BoussinesqFlowProblem<dim>::Postprocessor::evaluate_vector_field('
p14545
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p14546
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p14547
aS'  {'
p14548
aS'    const unsigned int n_quadrature_points = inputs.solution_values.size();'
p14549
aS'    Assert(inputs.solution_gradients.size() == n_quadrature_points,'
p14550
aS'           ExcInternalError());'
p14551
aS'    Assert(computed_quantities.size() == n_quadrature_points,'
p14552
aS'           ExcInternalError());'
p14553
aS'    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError());'
p14554
aS'    for (unsigned int q = 0; q < n_quadrature_points; ++q)'
p14555
aS'      {'
p14556
aS'        for (unsigned int d = 0; d < dim; ++d)'
p14557
aS'          computed_quantities[q](d) = (inputs.solution_values[q](d) *'
p14558
aS'                                       EquationData::year_in_seconds * 100);'
p14559
aS'        const double pressure ='
p14560
aS'          (inputs.solution_values[q](dim) - minimal_pressure);'
p14561
aS'        computed_quantities[q](dim) = pressure;'
p14562
aS'        const double temperature        = inputs.solution_values[q](dim + 1);'
p14563
aS'        computed_quantities[q](dim + 1) = temperature;'
p14564
aS'        Tensor<2, dim> grad_u;'
p14565
aS'        for (unsigned int d = 0; d < dim; ++d)'
p14566
aS'          grad_u[d] = inputs.solution_gradients[q][d];'
p14567
aS'        const SymmetricTensor<2, dim> strain_rate = symmetrize(grad_u);'
p14568
aS'        computed_quantities[q](dim + 2) ='
p14569
aS'          2 * EquationData::eta * strain_rate * strain_rate;'
p14570
aS'        computed_quantities[q](dim + 3) = partition;'
p14571
aS'      }'
p14572
aS'  }'
p14573
aS'  template <int dim>'
p14574
aS'  void BoussinesqFlowProblem<dim>::output_results()'
p14575
aS'  {'
p14576
aS'    TimerOutput::Scope timer_section(computing_timer, "Postprocessing");'
p14577
aS'    const FESystem<dim> joint_fe(stokes_fe, 1, temperature_fe, 1);'
p14578
aS'    DoFHandler<dim> joint_dof_handler(triangulation);'
p14579
aS'    joint_dof_handler.distribute_dofs(joint_fe);'
p14580
aS'    Assert(joint_dof_handler.n_dofs() =='
p14581
aS'             stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),'
p14582
aS'           ExcInternalError());'
p14583
aS'    TrilinosWrappers::MPI::Vector joint_solution;'
p14584
aS'    joint_solution.reinit(joint_dof_handler.locally_owned_dofs(),'
p14585
aS'                          MPI_COMM_WORLD);'
p14586
aS'    {'
p14587
aS'      std::vector<types::global_dof_index> local_joint_dof_indices('
p14588
aS'        joint_fe.n_dofs_per_cell());'
p14589
aS'      std::vector<types::global_dof_index> local_stokes_dof_indices('
p14590
aS'        stokes_fe.n_dofs_per_cell());'
p14591
aS'      std::vector<types::global_dof_index> local_temperature_dof_indices('
p14592
aS'        temperature_fe.n_dofs_per_cell());'
p14593
aS'      typename DoFHandler<dim>::active_cell_iterator'
p14594
aS'        joint_cell       = joint_dof_handler.begin_active(),'
p14595
aS'        joint_endc       = joint_dof_handler.end(),'
p14596
aS'        stokes_cell      = stokes_dof_handler.begin_active(),'
p14597
aS'        temperature_cell = temperature_dof_handler.begin_active();'
p14598
aS'      for (; joint_cell != joint_endc;'
p14599
aS'           ++joint_cell, ++stokes_cell, ++temperature_cell)'
p14600
aS'        if (joint_cell->is_locally_owned())'
p14601
aS'          {'
p14602
aS'            joint_cell->get_dof_indices(local_joint_dof_indices);'
p14603
aS'            stokes_cell->get_dof_indices(local_stokes_dof_indices);'
p14604
aS'            temperature_cell->get_dof_indices(local_temperature_dof_indices);'
p14605
aS'            for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)'
p14606
aS'              if (joint_fe.system_to_base_index(i).first.first == 0)'
p14607
aS'                {'
p14608
aS'                  Assert(joint_fe.system_to_base_index(i).second <'
p14609
aS'                           local_stokes_dof_indices.size(),'
p14610
aS'                         ExcInternalError());'
p14611
aS'                  joint_solution(local_joint_dof_indices[i]) = stokes_solution('
p14612
aS'                    local_stokes_dof_indices[joint_fe.system_to_base_index(i)'
p14613
aS'                                               .second]);'
p14614
aS'                }'
p14615
aS'              else'
p14616
aS'                {'
p14617
aS'                  Assert(joint_fe.system_to_base_index(i).first.first == 1,'
p14618
aS'                         ExcInternalError());'
p14619
aS'                  Assert(joint_fe.system_to_base_index(i).second <'
p14620
aS'                           local_temperature_dof_indices.size(),'
p14621
aS'                         ExcInternalError());'
p14622
aS'                  joint_solution(local_joint_dof_indices[i]) ='
p14623
aS'                    temperature_solution('
p14624
aS'                      local_temperature_dof_indices'
p14625
aS'                        [joint_fe.system_to_base_index(i).second]);'
p14626
aS'                }'
p14627
aS'          }'
p14628
aS'    }'
p14629
aS'    joint_solution.compress(VectorOperation::insert);'
p14630
aS'    IndexSet locally_relevant_joint_dofs(joint_dof_handler.n_dofs());'
p14631
aS'    DoFTools::extract_locally_relevant_dofs(joint_dof_handler,'
p14632
aS'                                            locally_relevant_joint_dofs);'
p14633
aS'    TrilinosWrappers::MPI::Vector locally_relevant_joint_solution;'
p14634
aS'    locally_relevant_joint_solution.reinit(locally_relevant_joint_dofs,'
p14635
aS'                                           MPI_COMM_WORLD);'
p14636
aS'    locally_relevant_joint_solution = joint_solution;'
p14637
aS'    Postprocessor postprocessor(Utilities::MPI::this_mpi_process('
p14638
aS'                                  MPI_COMM_WORLD),'
p14639
aS'                                stokes_solution.block(1).min());'
p14640
aS'    DataOut<dim> data_out;'
p14641
aS'    data_out.attach_dof_handler(joint_dof_handler);'
p14642
aS'    data_out.add_data_vector(locally_relevant_joint_solution, postprocessor);'
p14643
aS'    data_out.build_patches();'
p14644
aS'    static int out_index = 0;'
p14645
aS'    data_out.write_vtu_with_pvtu_record('
p14646
aS'      "./", "solution", out_index, MPI_COMM_WORLD, 5);'
p14647
aS'    out_index++;'
p14648
aS'  }'
p14649
aS'  template <int dim>'
p14650
aS'  void'
p14651
aS'  BoussinesqFlowProblem<dim>::refine_mesh(const unsigned int max_grid_level)'
p14652
aS'  {'
p14653
aS'    parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector>'
p14654
aS'      temperature_trans(temperature_dof_handler);'
p14655
aS'    parallel::distributed::SolutionTransfer<dim,'
p14656
aS'                                            TrilinosWrappers::MPI::BlockVector>'
p14657
aS'      stokes_trans(stokes_dof_handler);'
p14658
aS'    {'
p14659
aS'      TimerOutput::Scope timer_section(computing_timer,'
p14660
aS'                                       "Refine mesh structure, part 1");'
p14661
aS'      Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p14662
aS'      KellyErrorEstimator<dim>::estimate('
p14663
aS'        temperature_dof_handler,'
p14664
aS'        QGauss<dim - 1>(parameters.temperature_degree + 1),'
p14665
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p14666
aS'        temperature_solution,'
p14667
aS'        estimated_error_per_cell,'
p14668
aS'        ComponentMask(),'
p14669
aS'        nullptr,'
p14670
aS'        0,'
p14671
aS'        triangulation.locally_owned_subdomain());'
p14672
aS'      parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction('
p14673
aS'        triangulation, estimated_error_per_cell, 0.3, 0.1);'
p14674
aS'      if (triangulation.n_levels() > max_grid_level)'
p14675
aS'        for (typename Triangulation<dim>::active_cell_iterator cell ='
p14676
aS'               triangulation.begin_active(max_grid_level);'
p14677
aS'             cell != triangulation.end();'
p14678
aS'             ++cell)'
p14679
aS'          cell->clear_refine_flag();'
p14680
aS'      std::vector<const TrilinosWrappers::MPI::Vector *> x_temperature(2);'
p14681
aS'      x_temperature[0] = &temperature_solution;'
p14682
aS'      x_temperature[1] = &old_temperature_solution;'
p14683
aS'      std::vector<const TrilinosWrappers::MPI::BlockVector *> x_stokes(2);'
p14684
aS'      x_stokes[0] = &stokes_solution;'
p14685
aS'      x_stokes[1] = &old_stokes_solution;'
p14686
aS'      triangulation.prepare_coarsening_and_refinement();'
p14687
aS'      temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);'
p14688
aS'      stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);'
p14689
aS'      triangulation.execute_coarsening_and_refinement();'
p14690
aS'    }'
p14691
aS'    setup_dofs();'
p14692
aS'    {'
p14693
aS'      TimerOutput::Scope timer_section(computing_timer,'
p14694
aS'                                       "Refine mesh structure, part 2");'
p14695
aS'      {'
p14696
aS'        TrilinosWrappers::MPI::Vector distributed_temp1(temperature_rhs);'
p14697
aS'        TrilinosWrappers::MPI::Vector distributed_temp2(temperature_rhs);'
p14698
aS'        std::vector<TrilinosWrappers::MPI::Vector *> tmp(2);'
p14699
aS'        tmp[0] = &(distributed_temp1);'
p14700
aS'        tmp[1] = &(distributed_temp2);'
p14701
aS'        temperature_trans.interpolate(tmp);'
p14702
aS'        temperature_constraints.distribute(distributed_temp1);'
p14703
aS'        temperature_constraints.distribute(distributed_temp2);'
p14704
aS'        temperature_solution     = distributed_temp1;'
p14705
aS'        old_temperature_solution = distributed_temp2;'
p14706
aS'      }'
p14707
aS'      {'
p14708
aS'        TrilinosWrappers::MPI::BlockVector distributed_stokes(stokes_rhs);'
p14709
aS'        TrilinosWrappers::MPI::BlockVector old_distributed_stokes(stokes_rhs);'
p14710
aS'        std::vector<TrilinosWrappers::MPI::BlockVector *> stokes_tmp(2);'
p14711
aS'        stokes_tmp[0] = &(distributed_stokes);'
p14712
aS'        stokes_tmp[1] = &(old_distributed_stokes);'
p14713
aS'        stokes_trans.interpolate(stokes_tmp);'
p14714
aS'        stokes_constraints.distribute(distributed_stokes);'
p14715
aS'        stokes_constraints.distribute(old_distributed_stokes);'
p14716
aS'        stokes_solution     = distributed_stokes;'
p14717
aS'        old_stokes_solution = old_distributed_stokes;'
p14718
aS'      }'
p14719
aS'    }'
p14720
aS'  }'
p14721
aS'  template <int dim>'
p14722
aS'  void BoussinesqFlowProblem<dim>::run()'
p14723
aS'  {'
p14724
aS'    GridGenerator::hyper_shell(triangulation,'
p14725
aS'                               Point<dim>(),'
p14726
aS'                               EquationData::R0,'
p14727
aS'                               EquationData::R1,'
p14728
aS'                               (dim == 3) ? 96 : 12,'
p14729
aS'                               true);'
p14730
aS'    global_Omega_diameter = GridTools::diameter(triangulation);'
p14731
aS'    triangulation.refine_global(parameters.initial_global_refinement);'
p14732
aS'    setup_dofs();'
p14733
aS'    unsigned int pre_refinement_step = 0;'
p14734
aS'  start_time_iteration:'
p14735
aS'    {'
p14736
aS'      TrilinosWrappers::MPI::Vector solution('
p14737
aS'        temperature_dof_handler.locally_owned_dofs());'
p14738
aS'      VectorTools::project(temperature_dof_handler,'
p14739
aS'                           temperature_constraints,'
p14740
aS'                           QGauss<dim>(parameters.temperature_degree + 2),'
p14741
aS'                           EquationData::TemperatureInitialValues<dim>(),'
p14742
aS'                           solution);'
p14743
aS'      temperature_solution         = solution;'
p14744
aS'      old_temperature_solution     = solution;'
p14745
aS'      old_old_temperature_solution = solution;'
p14746
aS'    }'
p14747
aS'    timestep_number = 0;'
p14748
aS'    time_step = old_time_step = 0;'
p14749
aS'    double time = 0;'
p14750
aS'    do'
p14751
aS'      {'
p14752
aS'        pcout << "Timestep " << timestep_number'
p14753
aS'              << ":  t=" << time / EquationData::year_in_seconds << " years"'
p14754
aS'              << std::endl;'
p14755
aS'        assemble_stokes_system();'
p14756
aS'        build_stokes_preconditioner();'
p14757
aS'        assemble_temperature_matrix();'
p14758
aS'        solve();'
p14759
aS'        pcout << std::endl;'
p14760
aS'        if ((timestep_number == 0) &&'
p14761
aS'            (pre_refinement_step < parameters.initial_adaptive_refinement))'
p14762
aS'          {'
p14763
aS'            refine_mesh(parameters.initial_global_refinement +'
p14764
aS'                        parameters.initial_adaptive_refinement);'
p14765
aS'            ++pre_refinement_step;'
p14766
aS'            goto start_time_iteration;'
p14767
aS'          }'
p14768
aS'        else if ((timestep_number > 0) &&'
p14769
aS'                 (timestep_number % parameters.adaptive_refinement_interval =='
p14770
aS'                  0))'
p14771
aS'          refine_mesh(parameters.initial_global_refinement +'
p14772
aS'                      parameters.initial_adaptive_refinement);'
p14773
aS'        if ((parameters.generate_graphical_output == true) &&'
p14774
aS'            (timestep_number % parameters.graphical_output_interval == 0))'
p14775
aS'          output_results();'
p14776
aS'        if (time > parameters.end_time * EquationData::year_in_seconds)'
p14777
aS'          break;'
p14778
aS'        TrilinosWrappers::MPI::BlockVector old_old_stokes_solution;'
p14779
aS'        old_old_stokes_solution      = old_stokes_solution;'
p14780
aS'        old_stokes_solution          = stokes_solution;'
p14781
aS'        old_old_temperature_solution = old_temperature_solution;'
p14782
aS'        old_temperature_solution     = temperature_solution;'
p14783
aS'        if (old_time_step > 0)'
p14784
aS'          {'
p14785
aS'            {'
p14786
aS'              TrilinosWrappers::MPI::BlockVector distr_solution(stokes_rhs);'
p14787
aS'              distr_solution = stokes_solution;'
p14788
aS'              TrilinosWrappers::MPI::BlockVector distr_old_solution(stokes_rhs);'
p14789
aS'              distr_old_solution = old_old_stokes_solution;'
p14790
aS'              distr_solution.sadd(1. + time_step / old_time_step,'
p14791
aS'                                  -time_step / old_time_step,'
p14792
aS'                                  distr_old_solution);'
p14793
aS'              stokes_solution = distr_solution;'
p14794
aS'            }'
p14795
aS'            {'
p14796
aS'              TrilinosWrappers::MPI::Vector distr_solution(temperature_rhs);'
p14797
aS'              distr_solution = temperature_solution;'
p14798
aS'              TrilinosWrappers::MPI::Vector distr_old_solution(temperature_rhs);'
p14799
aS'              distr_old_solution = old_old_temperature_solution;'
p14800
aS'              distr_solution.sadd(1. + time_step / old_time_step,'
p14801
aS'                                  -time_step / old_time_step,'
p14802
aS'                                  distr_old_solution);'
p14803
aS'              temperature_solution = distr_solution;'
p14804
aS'            }'
p14805
aS'          }'
p14806
aS'        if ((timestep_number > 0) && (timestep_number % 100 == 0))'
p14807
aS'          computing_timer.print_summary();'
p14808
aS'        time += time_step;'
p14809
aS'        ++timestep_number;'
p14810
aS'      }'
p14811
aS'    while (true);'
p14812
aS'    if ((parameters.generate_graphical_output == true) &&'
p14813
aS'        !((timestep_number - 1) % parameters.graphical_output_interval == 0))'
p14814
aS'      output_results();'
p14815
aS'  }'
p14816
aS'} // namespace Step32'
p14817
aS'int main(int argc, char *argv[])'
p14818
ag24
aS'  try'
p14819
aS'    {'
p14820
aS'      using namespace Step32;'
p14821
aS'      using namespace dealii;'
p14822
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p14823
aS'        argc, argv, numbers::invalid_unsigned_int);'
p14824
aS'      std::string parameter_filename;'
p14825
aS'      if (argc >= 2)'
p14826
aS'        parameter_filename = argv[1];'
p14827
aS'      else'
p14828
aS'        parameter_filename = "step-32.prm";'
p14829
aS'      const int                              dim = 2;'
p14830
aS'      BoussinesqFlowProblem<dim>::Parameters parameters(parameter_filename);'
p14831
aS'      BoussinesqFlowProblem<dim>             flow_problem(parameters);'
p14832
aS'      flow_problem.run();'
p14833
aS'    }'
p14834
aS'  catch (std::exception &exc)'
p14835
aS'    {'
p14836
aS'      std::cerr << std::endl'
p14837
aS'                << std::endl'
p14838
aS'                << "----------------------------------------------------"'
p14839
aS'                << std::endl;'
p14840
aS'      std::cerr << "Exception on processing: " << std::endl'
p14841
aS'                << exc.what() << std::endl'
p14842
aS'                << "Aborting!" << std::endl'
p14843
aS'                << "----------------------------------------------------"'
p14844
aS'                << std::endl;'
p14845
aS'      return 1;'
p14846
aS'    }'
p14847
aS'  catch (...)'
p14848
aS'    {'
p14849
aS'      std::cerr << std::endl'
p14850
aS'                << std::endl'
p14851
aS'                << "----------------------------------------------------"'
p14852
aS'                << std::endl;'
p14853
aS'      std::cerr << "Unknown exception!" << std::endl'
p14854
aS'                << "Aborting!" << std::endl'
p14855
aS'                << "----------------------------------------------------"'
p14856
aS'                << std::endl;'
p14857
aS'      return 1;'
p14858
aS'    }'
p14859
aS'  return 0;'
p14860
ag32
aS'/* ---------------------------------------------------------------------'
p14861
aS' *'
p14862
aS' * Copyright (C) 2007 - 2021 by the deal.II authors'
p14863
aS' *'
p14864
aS' * This file is part of the deal.II library.'
p14865
aS' *'
p14866
aS' * The deal.II library is free software; you can use it, redistribute'
p14867
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p14868
aS' * Public License as published by the Free Software Foundation; either'
p14869
aS' * version 2.1 of the License, or (at your option) any later version.'
p14870
aS' * The full text of the license can be found in the file LICENSE.md at'
p14871
aS' * the top level directory of deal.II.'
p14872
aS' *'
p14873
aS' * ---------------------------------------------------------------------'
p14874
aS' *'
p14875
aS' * Author: David Neckels, Boulder, Colorado, 2007, 2008'
p14876
aS' */'
p14877
aS'#include <deal.II/base/quadrature_lib.h>'
p14878
aS'#include <deal.II/base/function.h>'
p14879
aS'#include <deal.II/base/parameter_handler.h>'
p14880
aS'#include <deal.II/base/function_parser.h>'
p14881
aS'#include <deal.II/base/utilities.h>'
p14882
aS'#include <deal.II/base/conditional_ostream.h>'
p14883
aS'#include <deal.II/lac/vector.h>'
p14884
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p14885
aS'#include <deal.II/grid/tria.h>'
p14886
aS'#include <deal.II/grid/grid_generator.h>'
p14887
aS'#include <deal.II/grid/grid_out.h>'
p14888
aS'#include <deal.II/grid/grid_refinement.h>'
p14889
aS'#include <deal.II/grid/grid_in.h>'
p14890
aS'#include <deal.II/dofs/dof_handler.h>'
p14891
aS'#include <deal.II/dofs/dof_tools.h>'
p14892
aS'#include <deal.II/fe/fe_values.h>'
p14893
aS'#include <deal.II/fe/fe_system.h>'
p14894
aS'#include <deal.II/fe/mapping_q1.h>'
p14895
aS'#include <deal.II/fe/fe_q.h>'
p14896
aS'#include <deal.II/numerics/data_out.h>'
p14897
aS'#include <deal.II/numerics/vector_tools.h>'
p14898
aS'#include <deal.II/numerics/solution_transfer.h>'
p14899
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p14900
aS'#include <deal.II/lac/trilinos_precondition.h>'
p14901
aS'#include <deal.II/lac/trilinos_solver.h>'
p14902
aS'#include <Sacado.hpp>'
p14903
aS'#include <iostream>'
p14904
aS'#include <fstream>'
p14905
aS'#include <vector>'
p14906
aS'#include <memory>'
p14907
aS'#include <array>'
p14908
aS'namespace Step33'
p14909
ag24
aS'  using namespace dealii;'
p14910
aS'  template <int dim>'
p14911
aS'  struct EulerEquations'
p14912
aS'  {'
p14913
aS'    static const unsigned int n_components             = dim + 2;'
p14914
aS'    static const unsigned int first_momentum_component = 0;'
p14915
aS'    static const unsigned int density_component        = dim;'
p14916
aS'    static const unsigned int energy_component         = dim + 1;'
p14917
aS'    static std::vector<std::string> component_names()'
p14918
aS'    {'
p14919
aS'      std::vector<std::string> names(dim, "momentum");'
p14920
aS'      names.emplace_back("density");'
p14921
aS'      names.emplace_back("energy_density");'
p14922
aS'      return names;'
p14923
aS'    }'
p14924
aS'    static std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14925
aS'    component_interpretation()'
p14926
aS'    {'
p14927
aS'      std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14928
aS'        data_component_interpretation('
p14929
aS'          dim, DataComponentInterpretation::component_is_part_of_vector);'
p14930
aS'      data_component_interpretation.push_back('
p14931
aS'        DataComponentInterpretation::component_is_scalar);'
p14932
aS'      data_component_interpretation.push_back('
p14933
aS'        DataComponentInterpretation::component_is_scalar);'
p14934
aS'      return data_component_interpretation;'
p14935
aS'    }'
p14936
aS'    static const double gas_gamma;'
p14937
aS'    template <typename InputVector>'
p14938
aS'    static typename InputVector::value_type'
p14939
aS'    compute_kinetic_energy(const InputVector &W)'
p14940
aS'    {'
p14941
aS'      typename InputVector::value_type kinetic_energy = 0;'
p14942
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14943
aS'        kinetic_energy +='
p14944
aS'          W[first_momentum_component + d] * W[first_momentum_component + d];'
p14945
aS'      kinetic_energy *= 1. / (2 * W[density_component]);'
p14946
aS'      return kinetic_energy;'
p14947
aS'    }'
p14948
aS'    template <typename InputVector>'
p14949
aS'    static typename InputVector::value_type'
p14950
aS'    compute_pressure(const InputVector &W)'
p14951
aS'    {'
p14952
aS'      return ((gas_gamma - 1.0) *'
p14953
aS'              (W[energy_component] - compute_kinetic_energy(W)));'
p14954
aS'    }'
p14955
aS'    template <typename InputVector>'
p14956
aS'    static void compute_flux_matrix(const InputVector &W,'
p14957
aS'                                    ndarray<typename InputVector::value_type,'
p14958
aS'                                            EulerEquations<dim>::n_components,'
p14959
aS'                                            dim> &     flux)'
p14960
aS'    {'
p14961
aS'      const typename InputVector::value_type pressure = compute_pressure(W);'
p14962
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14963
aS'        {'
p14964
aS'          for (unsigned int e = 0; e < dim; ++e)'
p14965
aS'            flux[first_momentum_component + d][e] ='
p14966
aS'              W[first_momentum_component + d] *'
p14967
aS'              W[first_momentum_component + e] / W[density_component];'
p14968
aS'          flux[first_momentum_component + d][d] += pressure;'
p14969
aS'        }'
p14970
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14971
aS'        flux[density_component][d] = W[first_momentum_component + d];'
p14972
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14973
aS'        flux[energy_component][d] = W[first_momentum_component + d] /'
p14974
aS'                                    W[density_component] *'
p14975
aS'                                    (W[energy_component] + pressure);'
p14976
aS'    }'
p14977
aS'    template <typename InputVector>'
p14978
aS'    static void numerical_normal_flux('
p14979
aS'      const Tensor<1, dim> &                                      normal,'
p14980
aS'      const InputVector &                                         Wplus,'
p14981
aS'      const InputVector &                                         Wminus,'
p14982
aS'      const double                                                alpha,'
p14983
aS'      std::array<typename InputVector::value_type, n_components> &normal_flux)'
p14984
aS'    {'
p14985
aS'      ndarray<typename InputVector::value_type,'
p14986
aS'              EulerEquations<dim>::n_components,'
p14987
aS'              dim>'
p14988
aS'        iflux, oflux;'
p14989
aS'      compute_flux_matrix(Wplus, iflux);'
p14990
aS'      compute_flux_matrix(Wminus, oflux);'
p14991
aS'      for (unsigned int di = 0; di < n_components; ++di)'
p14992
aS'        {'
p14993
aS'          normal_flux[di] = 0;'
p14994
aS'          for (unsigned int d = 0; d < dim; ++d)'
p14995
aS'            normal_flux[di] += 0.5 * (iflux[di][d] + oflux[di][d]) * normal[d];'
p14996
aS'          normal_flux[di] += 0.5 * alpha * (Wplus[di] - Wminus[di]);'
p14997
aS'        }'
p14998
aS'    }'
p14999
aS'    template <typename InputVector>'
p15000
aS'    static void compute_forcing_vector('
p15001
aS'      const InputVector &                                         W,'
p15002
aS'      std::array<typename InputVector::value_type, n_components> &forcing)'
p15003
aS'    {'
p15004
aS'      const double gravity = -1.0;'
p15005
aS'      for (unsigned int c = 0; c < n_components; ++c)'
p15006
aS'        switch (c)'
p15007
aS'          {'
p15008
aS'            case first_momentum_component + dim - 1:'
p15009
aS'              forcing[c] = gravity * W[density_component];'
p15010
aS'              break;'
p15011
aS'            case energy_component:'
p15012
aS'              forcing[c] = gravity * W[first_momentum_component + dim - 1];'
p15013
aS'              break;'
p15014
aS'            default:'
p15015
aS'              forcing[c] = 0;'
p15016
aS'          }'
p15017
aS'    }'
p15018
aS'    enum BoundaryKind'
p15019
aS'    {'
p15020
aS'      inflow_boundary,'
p15021
aS'      outflow_boundary,'
p15022
aS'      no_penetration_boundary,'
p15023
aS'      pressure_boundary'
p15024
aS'    };'
p15025
aS'    template <typename DataVector>'
p15026
aS'    static void'
p15027
aS'    compute_Wminus(const std::array<BoundaryKind, n_components> &boundary_kind,'
p15028
aS'                   const Tensor<1, dim> &                        normal_vector,'
p15029
aS'                   const DataVector &                            Wplus,'
p15030
aS'                   const Vector<double> &boundary_values,'
p15031
aS'                   const DataVector &    Wminus)'
p15032
aS'    {'
p15033
aS'      for (unsigned int c = 0; c < n_components; c++)'
p15034
aS'        switch (boundary_kind[c])'
p15035
aS'          {'
p15036
aS'            case inflow_boundary:'
p15037
aS'              {'
p15038
aS'                Wminus[c] = boundary_values(c);'
p15039
aS'                break;'
p15040
aS'              }'
p15041
aS'            case outflow_boundary:'
p15042
aS'              {'
p15043
aS'                Wminus[c] = Wplus[c];'
p15044
aS'                break;'
p15045
aS'              }'
p15046
aS'            case pressure_boundary:'
p15047
aS'              {'
p15048
aS'                const typename DataVector::value_type density ='
p15049
aS'                  (boundary_kind[density_component] == inflow_boundary ?'
p15050
aS'                     boundary_values(density_component) :'
p15051
aS'                     Wplus[density_component]);'
p15052
aS'                typename DataVector::value_type kinetic_energy = 0;'
p15053
aS'                for (unsigned int d = 0; d < dim; ++d)'
p15054
aS'                  if (boundary_kind[d] == inflow_boundary)'
p15055
aS'                    kinetic_energy += boundary_values(d) * boundary_values(d);'
p15056
aS'                  else'
p15057
aS'                    kinetic_energy += Wplus[d] * Wplus[d];'
p15058
aS'                kinetic_energy *= 1. / 2. / density;'
p15059
aS'                Wminus[c] ='
p15060
aS'                  boundary_values(c) / (gas_gamma - 1.0) + kinetic_energy;'
p15061
aS'                break;'
p15062
aS'              }'
p15063
aS'            case no_penetration_boundary:'
p15064
aS'              {'
p15065
aS'                typename DataVector::value_type vdotn = 0;'
p15066
aS'                for (unsigned int d = 0; d < dim; d++)'
p15067
aS'                  {'
p15068
aS'                    vdotn += Wplus[d] * normal_vector[d];'
p15069
aS'                  }'
p15070
aS'                Wminus[c] = Wplus[c] - 2.0 * vdotn * normal_vector[c];'
p15071
aS'                break;'
p15072
aS'              }'
p15073
aS'            default:'
p15074
aS'              Assert(false, ExcNotImplemented());'
p15075
aS'          }'
p15076
aS'    }'
p15077
aS'    static void'
p15078
aS'    compute_refinement_indicators(const DoFHandler<dim> &dof_handler,'
p15079
aS'                                  const Mapping<dim> &   mapping,'
p15080
aS'                                  const Vector<double> & solution,'
p15081
aS'                                  Vector<double> &       refinement_indicators)'
p15082
aS'    {'
p15083
aS'      const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();'
p15084
aS'      std::vector<unsigned int> dofs(dofs_per_cell);'
p15085
aS'      const QMidpoint<dim> quadrature_formula;'
p15086
aS'      const UpdateFlags    update_flags = update_gradients;'
p15087
aS'      FEValues<dim>        fe_v(mapping,'
p15088
aS'                         dof_handler.get_fe(),'
p15089
aS'                         quadrature_formula,'
p15090
aS'                         update_flags);'
p15091
aS'      std::vector<std::vector<Tensor<1, dim>>> dU('
p15092
aS'        1, std::vector<Tensor<1, dim>>(n_components));'
p15093
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p15094
aS'        {'
p15095
aS'          const unsigned int cell_no = cell->active_cell_index();'
p15096
aS'          fe_v.reinit(cell);'
p15097
aS'          fe_v.get_function_gradients(solution, dU);'
p15098
aS'          refinement_indicators(cell_no) = std::log('
p15099
aS'            1 + std::sqrt(dU[0][density_component] * dU[0][density_component]));'
p15100
aS'        }'
p15101
aS'    }'
p15102
aS'    class Postprocessor : public DataPostprocessor<dim>'
p15103
aS'    {'
p15104
aS'    public:'
p15105
aS'      Postprocessor(const bool do_schlieren_plot);'
p15106
aS'      virtual void evaluate_vector_field('
p15107
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p15108
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p15109
aS'      virtual std::vector<std::string> get_names() const override;'
p15110
aS'      virtual std::vector<'
p15111
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p15112
aS'      get_data_component_interpretation() const override;'
p15113
aS'      virtual UpdateFlags get_needed_update_flags() const override;'
p15114
aS'    private:'
p15115
aS'      const bool do_schlieren_plot;'
p15116
aS'    };'
p15117
aS'  };'
p15118
aS'  template <int dim>'
p15119
aS'  const double EulerEquations<dim>::gas_gamma = 1.4;'
p15120
aS'  template <int dim>'
p15121
aS'  EulerEquations<dim>::Postprocessor::Postprocessor('
p15122
aS'    const bool do_schlieren_plot)'
p15123
aS'    : do_schlieren_plot(do_schlieren_plot)'
p15124
aS'  {}'
p15125
aS'  template <int dim>'
p15126
aS'  void EulerEquations<dim>::Postprocessor::evaluate_vector_field('
p15127
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p15128
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p15129
aS'  {'
p15130
aS'    const unsigned int n_quadrature_points = inputs.solution_values.size();'
p15131
aS'    if (do_schlieren_plot == true)'
p15132
aS'      Assert(inputs.solution_gradients.size() == n_quadrature_points,'
p15133
aS'             ExcInternalError());'
p15134
aS'    Assert(computed_quantities.size() == n_quadrature_points,'
p15135
aS'           ExcInternalError());'
p15136
aS'    Assert(inputs.solution_values[0].size() == n_components,'
p15137
aS'           ExcInternalError());'
p15138
aS'    if (do_schlieren_plot == true)'
p15139
aS'      {'
p15140
aS'        Assert(computed_quantities[0].size() == dim + 2, ExcInternalError());'
p15141
aS'      }'
p15142
aS'    else'
p15143
aS'      {'
p15144
aS'        Assert(computed_quantities[0].size() == dim + 1, ExcInternalError());'
p15145
aS'      }'
p15146
aS'    for (unsigned int q = 0; q < n_quadrature_points; ++q)'
p15147
aS'      {'
p15148
aS'        const double density = inputs.solution_values[q](density_component);'
p15149
aS'        for (unsigned int d = 0; d < dim; ++d)'
p15150
aS'          computed_quantities[q](d) ='
p15151
aS'            inputs.solution_values[q](first_momentum_component + d) / density;'
p15152
aS'        computed_quantities[q](dim) ='
p15153
aS'          compute_pressure(inputs.solution_values[q]);'
p15154
aS'        if (do_schlieren_plot == true)'
p15155
aS'          computed_quantities[q](dim + 1) ='
p15156
aS'            inputs.solution_gradients[q][density_component] *'
p15157
aS'            inputs.solution_gradients[q][density_component];'
p15158
aS'      }'
p15159
aS'  }'
p15160
aS'  template <int dim>'
p15161
aS'  std::vector<std::string> EulerEquations<dim>::Postprocessor::get_names() const'
p15162
aS'  {'
p15163
aS'    std::vector<std::string> names;'
p15164
aS'    for (unsigned int d = 0; d < dim; ++d)'
p15165
aS'      names.emplace_back("velocity");'
p15166
aS'    names.emplace_back("pressure");'
p15167
aS'    if (do_schlieren_plot == true)'
p15168
aS'      names.emplace_back("schlieren_plot");'
p15169
aS'    return names;'
p15170
aS'  }'
p15171
aS'  template <int dim>'
p15172
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p15173
aS'  EulerEquations<dim>::Postprocessor::get_data_component_interpretation() const'
p15174
aS'  {'
p15175
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p15176
aS'      interpretation(dim,'
p15177
aS'                     DataComponentInterpretation::component_is_part_of_vector);'
p15178
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p15179
aS'    if (do_schlieren_plot == true)'
p15180
aS'      interpretation.push_back('
p15181
aS'        DataComponentInterpretation::component_is_scalar);'
p15182
aS'    return interpretation;'
p15183
aS'  }'
p15184
aS'  template <int dim>'
p15185
aS'  UpdateFlags'
p15186
aS'  EulerEquations<dim>::Postprocessor::get_needed_update_flags() const'
p15187
aS'  {'
p15188
aS'    if (do_schlieren_plot == true)'
p15189
aS'      return update_values | update_gradients;'
p15190
aS'    else'
p15191
aS'      return update_values;'
p15192
aS'  }'
p15193
aS'  namespace Parameters'
p15194
aS'  {'
p15195
aS'    struct Solver'
p15196
aS'    {'
p15197
aS'      enum SolverType'
p15198
aS'      {'
p15199
aS'        gmres,'
p15200
aS'        direct'
p15201
aS'      };'
p15202
aS'      SolverType solver;'
p15203
aS'      enum OutputType'
p15204
aS'      {'
p15205
aS'        quiet,'
p15206
aS'        verbose'
p15207
aS'      };'
p15208
aS'      OutputType output;'
p15209
aS'      double linear_residual;'
p15210
aS'      int    max_iterations;'
p15211
aS'      double ilut_fill;'
p15212
aS'      double ilut_atol;'
p15213
aS'      double ilut_rtol;'
p15214
aS'      double ilut_drop;'
p15215
aS'      static void declare_parameters(ParameterHandler &prm);'
p15216
aS'      void        parse_parameters(ParameterHandler &prm);'
p15217
aS'    };'
p15218
aS'    void Solver::declare_parameters(ParameterHandler &prm)'
p15219
aS'    {'
p15220
aS'      prm.enter_subsection("linear solver");'
p15221
aS'      {'
p15222
aS'        prm.declare_entry('
p15223
aS'          "output",'
p15224
aS'          "quiet",'
p15225
aS'          Patterns::Selection("quiet|verbose"),'
p15226
aS'          "State whether output from solver runs should be printed. "'
p15227
aS'          "Choices are <quiet|verbose>.");'
p15228
aS'        prm.declare_entry("method",'
p15229
aS'                          "gmres",'
p15230
aS'                          Patterns::Selection("gmres|direct"),'
p15231
aS'                          "The kind of solver for the linear system. "'
p15232
aS'                          "Choices are <gmres|direct>.");'
p15233
aS'        prm.declare_entry("residual",'
p15234
aS'                          "1e-10",'
p15235
aS'                          Patterns::Double(),'
p15236
aS'                          "Linear solver residual");'
p15237
aS'        prm.declare_entry("max iters",'
p15238
aS'                          "300",'
p15239
aS'                          Patterns::Integer(),'
p15240
aS'                          "Maximum solver iterations");'
p15241
aS'        prm.declare_entry("ilut fill",'
p15242
aS'                          "2",'
p15243
aS'                          Patterns::Double(),'
p15244
aS'                          "Ilut preconditioner fill");'
p15245
aS'        prm.declare_entry("ilut absolute tolerance",'
p15246
aS'                          "1e-9",'
p15247
aS'                          Patterns::Double(),'
p15248
aS'                          "Ilut preconditioner tolerance");'
p15249
aS'        prm.declare_entry("ilut relative tolerance",'
p15250
aS'                          "1.1",'
p15251
aS'                          Patterns::Double(),'
p15252
aS'                          "Ilut relative tolerance");'
p15253
aS'        prm.declare_entry("ilut drop tolerance",'
p15254
aS'                          "1e-10",'
p15255
aS'                          Patterns::Double(),'
p15256
aS'                          "Ilut drop tolerance");'
p15257
aS'      }'
p15258
aS'      prm.leave_subsection();'
p15259
aS'    }'
p15260
aS'    void Solver::parse_parameters(ParameterHandler &prm)'
p15261
aS'    {'
p15262
aS'      prm.enter_subsection("linear solver");'
p15263
aS'      {'
p15264
aS'        const std::string op = prm.get("output");'
p15265
aS'        if (op == "verbose")'
p15266
aS'          output = verbose;'
p15267
aS'        if (op == "quiet")'
p15268
aS'          output = quiet;'
p15269
aS'        const std::string sv = prm.get("method");'
p15270
aS'        if (sv == "direct")'
p15271
aS'          solver = direct;'
p15272
aS'        else if (sv == "gmres")'
p15273
aS'          solver = gmres;'
p15274
aS'        linear_residual = prm.get_double("residual");'
p15275
aS'        max_iterations  = prm.get_integer("max iters");'
p15276
aS'        ilut_fill       = prm.get_double("ilut fill");'
p15277
aS'        ilut_atol       = prm.get_double("ilut absolute tolerance");'
p15278
aS'        ilut_rtol       = prm.get_double("ilut relative tolerance");'
p15279
aS'        ilut_drop       = prm.get_double("ilut drop tolerance");'
p15280
aS'      }'
p15281
aS'      prm.leave_subsection();'
p15282
aS'    }'
p15283
aS'    struct Refinement'
p15284
aS'    {'
p15285
aS'      bool   do_refine;'
p15286
aS'      double shock_val;'
p15287
aS'      double shock_levels;'
p15288
aS'      static void declare_parameters(ParameterHandler &prm);'
p15289
aS'      void        parse_parameters(ParameterHandler &prm);'
p15290
aS'    };'
p15291
aS'    void Refinement::declare_parameters(ParameterHandler &prm)'
p15292
aS'    {'
p15293
aS'      prm.enter_subsection("refinement");'
p15294
aS'      {'
p15295
aS'        prm.declare_entry("refinement",'
p15296
aS'                          "true",'
p15297
aS'                          Patterns::Bool(),'
p15298
aS'                          "Whether to perform mesh refinement or not");'
p15299
aS'        prm.declare_entry("refinement fraction",'
p15300
aS'                          "0.1",'
p15301
aS'                          Patterns::Double(),'
p15302
aS'                          "Fraction of high refinement");'
p15303
aS'        prm.declare_entry("unrefinement fraction",'
p15304
aS'                          "0.1",'
p15305
aS'                          Patterns::Double(),'
p15306
aS'                          "Fraction of low unrefinement");'
p15307
aS'        prm.declare_entry("max elements",'
p15308
aS'                          "1000000",'
p15309
aS'                          Patterns::Double(),'
p15310
aS'                          "maximum number of elements");'
p15311
aS'        prm.declare_entry("shock value",'
p15312
aS'                          "4.0",'
p15313
aS'                          Patterns::Double(),'
p15314
aS'                          "value for shock indicator");'
p15315
aS'        prm.declare_entry("shock levels",'
p15316
aS'                          "3.0",'
p15317
aS'                          Patterns::Double(),'
p15318
aS'                          "number of shock refinement levels");'
p15319
aS'      }'
p15320
aS'      prm.leave_subsection();'
p15321
aS'    }'
p15322
aS'    void Refinement::parse_parameters(ParameterHandler &prm)'
p15323
aS'    {'
p15324
aS'      prm.enter_subsection("refinement");'
p15325
aS'      {'
p15326
aS'        do_refine    = prm.get_bool("refinement");'
p15327
aS'        shock_val    = prm.get_double("shock value");'
p15328
aS'        shock_levels = prm.get_double("shock levels");'
p15329
aS'      }'
p15330
aS'      prm.leave_subsection();'
p15331
aS'    }'
p15332
aS'    struct Flux'
p15333
aS'    {'
p15334
aS'      enum StabilizationKind'
p15335
aS'      {'
p15336
aS'        constant,'
p15337
aS'        mesh_dependent'
p15338
aS'      };'
p15339
aS'      StabilizationKind stabilization_kind;'
p15340
aS'      double stabilization_value;'
p15341
aS'      static void declare_parameters(ParameterHandler &prm);'
p15342
aS'      void        parse_parameters(ParameterHandler &prm);'
p15343
aS'    };'
p15344
aS'    void Flux::declare_parameters(ParameterHandler &prm)'
p15345
aS'    {'
p15346
aS'      prm.enter_subsection("flux");'
p15347
aS'      {'
p15348
aS'        prm.declare_entry('
p15349
aS'          "stab",'
p15350
aS'          "mesh",'
p15351
aS'          Patterns::Selection("constant|mesh"),'
p15352
aS'          "Whether to use a constant stabilization parameter or "'
p15353
aS'          "a mesh-dependent one");'
p15354
aS'        prm.declare_entry("stab value",'
p15355
aS'                          "1",'
p15356
aS'                          Patterns::Double(),'
p15357
aS'                          "alpha stabilization");'
p15358
aS'      }'
p15359
aS'      prm.leave_subsection();'
p15360
aS'    }'
p15361
aS'    void Flux::parse_parameters(ParameterHandler &prm)'
p15362
aS'    {'
p15363
aS'      prm.enter_subsection("flux");'
p15364
aS'      {'
p15365
aS'        const std::string stab = prm.get("stab");'
p15366
aS'        if (stab == "constant")'
p15367
aS'          stabilization_kind = constant;'
p15368
aS'        else if (stab == "mesh")'
p15369
aS'          stabilization_kind = mesh_dependent;'
p15370
aS'        else'
p15371
aS'          AssertThrow(false, ExcNotImplemented());'
p15372
aS'        stabilization_value = prm.get_double("stab value");'
p15373
aS'      }'
p15374
aS'      prm.leave_subsection();'
p15375
aS'    }'
p15376
aS'    struct Output'
p15377
aS'    {'
p15378
aS'      bool   schlieren_plot;'
p15379
aS'      double output_step;'
p15380
aS'      static void declare_parameters(ParameterHandler &prm);'
p15381
aS'      void        parse_parameters(ParameterHandler &prm);'
p15382
aS'    };'
p15383
aS'    void Output::declare_parameters(ParameterHandler &prm)'
p15384
aS'    {'
p15385
aS'      prm.enter_subsection("output");'
p15386
aS'      {'
p15387
aS'        prm.declare_entry("schlieren plot",'
p15388
aS'                          "true",'
p15389
aS'                          Patterns::Bool(),'
p15390
aS'                          "Whether or not to produce schlieren plots");'
p15391
aS'        prm.declare_entry("step",'
p15392
aS'                          "-1",'
p15393
aS'                          Patterns::Double(),'
p15394
aS'                          "Output once per this period");'
p15395
aS'      }'
p15396
aS'      prm.leave_subsection();'
p15397
aS'    }'
p15398
aS'    void Output::parse_parameters(ParameterHandler &prm)'
p15399
aS'    {'
p15400
aS'      prm.enter_subsection("output");'
p15401
aS'      {'
p15402
aS'        schlieren_plot = prm.get_bool("schlieren plot");'
p15403
aS'        output_step    = prm.get_double("step");'
p15404
aS'      }'
p15405
aS'      prm.leave_subsection();'
p15406
aS'    }'
p15407
aS'    template <int dim>'
p15408
aS'    struct AllParameters : public Solver,'
p15409
aS'                           public Refinement,'
p15410
aS'                           public Flux,'
p15411
aS'                           public Output'
p15412
aS'    {'
p15413
aS'      static const unsigned int max_n_boundaries = 10;'
p15414
aS'      struct BoundaryConditions'
p15415
aS'      {'
p15416
aS'        std::array<typename EulerEquations<dim>::BoundaryKind,'
p15417
aS'                   EulerEquations<dim>::n_components>'
p15418
aS'          kind;'
p15419
aS'        FunctionParser<dim> values;'
p15420
aS'        BoundaryConditions();'
p15421
aS'      };'
p15422
aS'      AllParameters();'
p15423
aS'      double diffusion_power;'
p15424
aS'      double time_step, final_time;'
p15425
aS'      double theta;'
p15426
aS'      bool   is_stationary;'
p15427
aS'      std::string mesh_filename;'
p15428
aS'      FunctionParser<dim> initial_conditions;'
p15429
aS'      BoundaryConditions  boundary_conditions[max_n_boundaries];'
p15430
aS'      static void declare_parameters(ParameterHandler &prm);'
p15431
aS'      void        parse_parameters(ParameterHandler &prm);'
p15432
aS'    };'
p15433
aS'    template <int dim>'
p15434
aS'    AllParameters<dim>::BoundaryConditions::BoundaryConditions()'
p15435
aS'      : values(EulerEquations<dim>::n_components)'
p15436
aS'    {'
p15437
aS'      std::fill(kind.begin(),'
p15438
aS'                kind.end(),'
p15439
aS'                EulerEquations<dim>::no_penetration_boundary);'
p15440
aS'    }'
p15441
aS'    template <int dim>'
p15442
aS'    AllParameters<dim>::AllParameters()'
p15443
aS'      : diffusion_power(0.)'
p15444
aS'      , time_step(1.)'
p15445
aS'      , final_time(1.)'
p15446
aS'      , theta(.5)'
p15447
aS'      , is_stationary(true)'
p15448
aS'      , initial_conditions(EulerEquations<dim>::n_components)'
p15449
aS'    {}'
p15450
aS'    template <int dim>'
p15451
aS'    void AllParameters<dim>::declare_parameters(ParameterHandler &prm)'
p15452
aS'    {'
p15453
aS'      prm.declare_entry("mesh",'
p15454
aS'                        "grid.inp",'
p15455
aS'                        Patterns::Anything(),'
p15456
aS'                        "input file name");'
p15457
aS'      prm.declare_entry("diffusion power",'
p15458
aS'                        "2.0",'
p15459
aS'                        Patterns::Double(),'
p15460
aS'                        "power of mesh size for diffusion");'
p15461
aS'      prm.enter_subsection("time stepping");'
p15462
aS'      {'
p15463
aS'        prm.declare_entry("time step",'
p15464
aS'                          "0.1",'
p15465
aS'                          Patterns::Double(0),'
p15466
aS'                          "simulation time step");'
p15467
aS'        prm.declare_entry("final time",'
p15468
aS'                          "10.0",'
p15469
aS'                          Patterns::Double(0),'
p15470
aS'                          "simulation end time");'
p15471
aS'        prm.declare_entry("theta scheme value",'
p15472
aS'                          "0.5",'
p15473
aS'                          Patterns::Double(0, 1),'
p15474
aS'                          "value for theta that interpolated between explicit "'
p15475
aS'                          "Euler (theta=0), Crank-Nicolson (theta=0.5), and "'
p15476
aS'                          "implicit Euler (theta=1).");'
p15477
aS'      }'
p15478
aS'      prm.leave_subsection();'
p15479
aS'      for (unsigned int b = 0; b < max_n_boundaries; ++b)'
p15480
aS'        {'
p15481
aS'          prm.enter_subsection("boundary_" + Utilities::int_to_string(b));'
p15482
aS'          {'
p15483
aS'            prm.declare_entry("no penetration",'
p15484
aS'                              "false",'
p15485
aS'                              Patterns::Bool(),'
p15486
aS'                              "whether the named boundary allows gas to "'
p15487
aS'                              "penetrate or is a rigid wall");'
p15488
aS'            for (unsigned int di = 0; di < EulerEquations<dim>::n_components;'
p15489
aS'                 ++di)'
p15490
aS'              {'
p15491
aS'                prm.declare_entry("w_" + Utilities::int_to_string(di),'
p15492
aS'                                  "outflow",'
p15493
aS'                                  Patterns::Selection('
p15494
aS'                                    "inflow|outflow|pressure"),'
p15495
aS'                                  "<inflow|outflow|pressure>");'
p15496
aS'                prm.declare_entry("w_" + Utilities::int_to_string(di) +'
p15497
aS'                                    " value",'
p15498
aS'                                  "0.0",'
p15499
aS'                                  Patterns::Anything(),'
p15500
aS'                                  "expression in x,y,z");'
p15501
aS'              }'
p15502
aS'          }'
p15503
aS'          prm.leave_subsection();'
p15504
aS'        }'
p15505
aS'      prm.enter_subsection("initial condition");'
p15506
aS'      {'
p15507
aS'        for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di)'
p15508
aS'          prm.declare_entry("w_" + Utilities::int_to_string(di) + " value",'
p15509
aS'                            "0.0",'
p15510
aS'                            Patterns::Anything(),'
p15511
aS'                            "expression in x,y,z");'
p15512
aS'      }'
p15513
aS'      prm.leave_subsection();'
p15514
aS'      Parameters::Solver::declare_parameters(prm);'
p15515
aS'      Parameters::Refinement::declare_parameters(prm);'
p15516
aS'      Parameters::Flux::declare_parameters(prm);'
p15517
aS'      Parameters::Output::declare_parameters(prm);'
p15518
aS'    }'
p15519
aS'    template <int dim>'
p15520
aS'    void AllParameters<dim>::parse_parameters(ParameterHandler &prm)'
p15521
aS'    {'
p15522
aS'      mesh_filename   = prm.get("mesh");'
p15523
aS'      diffusion_power = prm.get_double("diffusion power");'
p15524
aS'      prm.enter_subsection("time stepping");'
p15525
aS'      {'
p15526
aS'        time_step = prm.get_double("time step");'
p15527
aS'        if (time_step == 0)'
p15528
aS'          {'
p15529
aS'            is_stationary = true;'
p15530
aS'            time_step     = 1.0;'
p15531
aS'            final_time    = 1.0;'
p15532
aS'          }'
p15533
aS'        else'
p15534
aS'          is_stationary = false;'
p15535
aS'        final_time = prm.get_double("final time");'
p15536
aS'        theta      = prm.get_double("theta scheme value");'
p15537
aS'      }'
p15538
aS'      prm.leave_subsection();'
p15539
aS'      for (unsigned int boundary_id = 0; boundary_id < max_n_boundaries;'
p15540
aS'           ++boundary_id)'
p15541
aS'        {'
p15542
aS'          prm.enter_subsection("boundary_" +'
p15543
aS'                               Utilities::int_to_string(boundary_id));'
p15544
aS'          {'
p15545
aS'            std::vector<std::string> expressions('
p15546
aS'              EulerEquations<dim>::n_components, "0.0");'
p15547
aS'            const bool no_penetration = prm.get_bool("no penetration");'
p15548
aS'            for (unsigned int di = 0; di < EulerEquations<dim>::n_components;'
p15549
aS'                 ++di)'
p15550
aS'              {'
p15551
aS'                const std::string boundary_type ='
p15552
aS'                  prm.get("w_" + Utilities::int_to_string(di));'
p15553
aS'                if ((di < dim) && (no_penetration == true))'
p15554
aS'                  boundary_conditions[boundary_id].kind[di] ='
p15555
aS'                    EulerEquations<dim>::no_penetration_boundary;'
p15556
aS'                else if (boundary_type == "inflow")'
p15557
aS'                  boundary_conditions[boundary_id].kind[di] ='
p15558
aS'                    EulerEquations<dim>::inflow_boundary;'
p15559
aS'                else if (boundary_type == "pressure")'
p15560
aS'                  boundary_conditions[boundary_id].kind[di] ='
p15561
aS'                    EulerEquations<dim>::pressure_boundary;'
p15562
aS'                else if (boundary_type == "outflow")'
p15563
aS'                  boundary_conditions[boundary_id].kind[di] ='
p15564
aS'                    EulerEquations<dim>::outflow_boundary;'
p15565
aS'                else'
p15566
aS'                  AssertThrow(false, ExcNotImplemented());'
p15567
aS'                expressions[di] ='
p15568
aS'                  prm.get("w_" + Utilities::int_to_string(di) + " value");'
p15569
aS'              }'
p15570
aS'            boundary_conditions[boundary_id].values.initialize('
p15571
aS'              FunctionParser<dim>::default_variable_names(),'
p15572
aS'              expressions,'
p15573
aS'              std::map<std::string, double>());'
p15574
aS'          }'
p15575
aS'          prm.leave_subsection();'
p15576
aS'        }'
p15577
aS'      prm.enter_subsection("initial condition");'
p15578
aS'      {'
p15579
aS'        std::vector<std::string> expressions(EulerEquations<dim>::n_components,'
p15580
aS'                                             "0.0");'
p15581
aS'        for (unsigned int di = 0; di < EulerEquations<dim>::n_components; di++)'
p15582
aS'          expressions[di] ='
p15583
aS'            prm.get("w_" + Utilities::int_to_string(di) + " value");'
p15584
aS'        initial_conditions.initialize('
p15585
aS'          FunctionParser<dim>::default_variable_names(),'
p15586
aS'          expressions,'
p15587
aS'          std::map<std::string, double>());'
p15588
aS'      }'
p15589
aS'      prm.leave_subsection();'
p15590
aS'      Parameters::Solver::parse_parameters(prm);'
p15591
aS'      Parameters::Refinement::parse_parameters(prm);'
p15592
aS'      Parameters::Flux::parse_parameters(prm);'
p15593
aS'      Parameters::Output::parse_parameters(prm);'
p15594
aS'    }'
p15595
aS'  } // namespace Parameters'
p15596
aS'  template <int dim>'
p15597
aS'  class ConservationLaw'
p15598
aS'  {'
p15599
aS'  public:'
p15600
aS'    ConservationLaw(const char *input_filename);'
p15601
aS'    void run();'
p15602
aS'  private:'
p15603
aS'    void setup_system();'
p15604
aS'    void assemble_system();'
p15605
aS'    void assemble_cell_term(const FEValues<dim> &                       fe_v,'
p15606
aS'                            const std::vector<types::global_dof_index> &dofs);'
p15607
aS'    void assemble_face_term('
p15608
aS'      const unsigned int                          face_no,'
p15609
aS'      const FEFaceValuesBase<dim> &               fe_v,'
p15610
aS'      const FEFaceValuesBase<dim> &               fe_v_neighbor,'
p15611
aS'      const std::vector<types::global_dof_index> &dofs,'
p15612
aS'      const std::vector<types::global_dof_index> &dofs_neighbor,'
p15613
aS'      const bool                                  external_face,'
p15614
aS'      const unsigned int                          boundary_id,'
p15615
aS'      const double                                face_diameter);'
p15616
aS'    std::pair<unsigned int, double> solve(Vector<double> &solution);'
p15617
aS'    void compute_refinement_indicators(Vector<double> &indicator) const;'
p15618
aS'    void refine_grid(const Vector<double> &indicator);'
p15619
aS'    void output_results() const;'
p15620
aS'    Triangulation<dim>   triangulation;'
p15621
aS'    const MappingQ1<dim> mapping;'
p15622
aS'    const FESystem<dim> fe;'
p15623
aS'    DoFHandler<dim>     dof_handler;'
p15624
aS'    const QGauss<dim>     quadrature;'
p15625
aS'    const QGauss<dim - 1> face_quadrature;'
p15626
aS'    Vector<double> old_solution;'
p15627
aS'    Vector<double> current_solution;'
p15628
aS'    Vector<double> predictor;'
p15629
aS'    Vector<double> right_hand_side;'
p15630
aS'    TrilinosWrappers::SparseMatrix system_matrix;'
p15631
aS'    Parameters::AllParameters<dim> parameters;'
p15632
aS'    ConditionalOStream             verbose_cout;'
p15633
aS'  };'
p15634
aS'  template <int dim>'
p15635
aS'  ConservationLaw<dim>::ConservationLaw(const char *input_filename)'
p15636
aS'    : mapping()'
p15637
aS'    , fe(FE_Q<dim>(1), EulerEquations<dim>::n_components)'
p15638
aS'    , dof_handler(triangulation)'
p15639
aS'    , quadrature(fe.degree + 1)'
p15640
aS'    , face_quadrature(fe.degree + 1)'
p15641
aS'    , verbose_cout(std::cout, false)'
p15642
aS'  {'
p15643
aS'    ParameterHandler prm;'
p15644
aS'    Parameters::AllParameters<dim>::declare_parameters(prm);'
p15645
aS'    prm.parse_input(input_filename);'
p15646
aS'    parameters.parse_parameters(prm);'
p15647
aS'    verbose_cout.set_condition(parameters.output =='
p15648
aS'                               Parameters::Solver::verbose);'
p15649
aS'  }'
p15650
aS'  template <int dim>'
p15651
aS'  void ConservationLaw<dim>::setup_system()'
p15652
aS'  {'
p15653
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p15654
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p15655
aS'    system_matrix.reinit(dsp);'
p15656
aS'  }'
p15657
aS'  template <int dim>'
p15658
aS'  void ConservationLaw<dim>::assemble_system()'
p15659
aS'  {'
p15660
aS'    const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();'
p15661
aS'    std::vector<types::global_dof_index> dof_indices(dofs_per_cell);'
p15662
aS'    std::vector<types::global_dof_index> dof_indices_neighbor(dofs_per_cell);'
p15663
aS'    const UpdateFlags update_flags = update_values | update_gradients |'
p15664
aS'                                     update_quadrature_points |'
p15665
aS'                                     update_JxW_values,'
p15666
aS'                      face_update_flags ='
p15667
aS'                        update_values | update_quadrature_points |'
p15668
aS'                        update_JxW_values | update_normal_vectors,'
p15669
aS'                      neighbor_face_update_flags = update_values;'
p15670
aS'    FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);'
p15671
aS'    FEFaceValues<dim>    fe_v_face(mapping,'
p15672
aS'                                fe,'
p15673
aS'                                face_quadrature,'
p15674
aS'                                face_update_flags);'
p15675
aS'    FESubfaceValues<dim> fe_v_subface(mapping,'
p15676
aS'                                      fe,'
p15677
aS'                                      face_quadrature,'
p15678
aS'                                      face_update_flags);'
p15679
aS'    FEFaceValues<dim>    fe_v_face_neighbor(mapping,'
p15680
aS'                                         fe,'
p15681
aS'                                         face_quadrature,'
p15682
aS'                                         neighbor_face_update_flags);'
p15683
aS'    FESubfaceValues<dim> fe_v_subface_neighbor(mapping,'
p15684
aS'                                               fe,'
p15685
aS'                                               face_quadrature,'
p15686
aS'                                               neighbor_face_update_flags);'
p15687
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p15688
aS'      {'
p15689
aS'        fe_v.reinit(cell);'
p15690
aS'        cell->get_dof_indices(dof_indices);'
p15691
aS'        assemble_cell_term(fe_v, dof_indices);'
p15692
aS'        for (const auto face_no : cell->face_indices())'
p15693
aS'          if (cell->at_boundary(face_no))'
p15694
aS'            {'
p15695
aS'              fe_v_face.reinit(cell, face_no);'
p15696
aS'              assemble_face_term(face_no,'
p15697
aS'                                 fe_v_face,'
p15698
aS'                                 fe_v_face,'
p15699
aS'                                 dof_indices,'
p15700
aS'                                 std::vector<types::global_dof_index>(),'
p15701
aS'                                 true,'
p15702
aS'                                 cell->face(face_no)->boundary_id(),'
p15703
aS'                                 cell->face(face_no)->diameter());'
p15704
aS'            }'
p15705
aS'          else'
p15706
aS'            {'
p15707
aS'              if (cell->neighbor(face_no)->has_children())'
p15708
aS'                {'
p15709
aS'                  const unsigned int neighbor2 ='
p15710
aS'                    cell->neighbor_of_neighbor(face_no);'
p15711
aS'                  for (unsigned int subface_no = 0;'
p15712
aS'                       subface_no < cell->face(face_no)->n_children();'
p15713
aS'                       ++subface_no)'
p15714
aS'                    {'
p15715
aS'                      const typename DoFHandler<dim>::active_cell_iterator'
p15716
aS'                        neighbor_child ='
p15717
aS'                          cell->neighbor_child_on_subface(face_no, subface_no);'
p15718
aS'                      Assert(neighbor_child->face(neighbor2) =='
p15719
aS'                               cell->face(face_no)->child(subface_no),'
p15720
aS'                             ExcInternalError());'
p15721
aS'                      Assert(neighbor_child->is_active(), ExcInternalError());'
p15722
aS'                      fe_v_subface.reinit(cell, face_no, subface_no);'
p15723
aS'                      fe_v_face_neighbor.reinit(neighbor_child, neighbor2);'
p15724
aS'                      neighbor_child->get_dof_indices(dof_indices_neighbor);'
p15725
aS'                      assemble_face_term('
p15726
aS'                        face_no,'
p15727
aS'                        fe_v_subface,'
p15728
aS'                        fe_v_face_neighbor,'
p15729
aS'                        dof_indices,'
p15730
aS'                        dof_indices_neighbor,'
p15731
aS'                        false,'
p15732
aS'                        numbers::invalid_unsigned_int,'
p15733
aS'                        neighbor_child->face(neighbor2)->diameter());'
p15734
aS'                    }'
p15735
aS'                }'
p15736
aS'              else if (cell->neighbor(face_no)->level() != cell->level())'
p15737
aS'                {'
p15738
aS'                  const typename DoFHandler<dim>::cell_iterator neighbor ='
p15739
aS'                    cell->neighbor(face_no);'
p15740
aS'                  Assert(neighbor->level() == cell->level() - 1,'
p15741
aS'                         ExcInternalError());'
p15742
aS'                  neighbor->get_dof_indices(dof_indices_neighbor);'
p15743
aS'                  const std::pair<unsigned int, unsigned int> faceno_subfaceno ='
p15744
aS'                    cell->neighbor_of_coarser_neighbor(face_no);'
p15745
aS'                  const unsigned int neighbor_face_no = faceno_subfaceno.first,'
p15746
aS'                                     neighbor_subface_no ='
p15747
aS'                                       faceno_subfaceno.second;'
p15748
aS'                  Assert(neighbor->neighbor_child_on_subface('
p15749
aS'                           neighbor_face_no, neighbor_subface_no) == cell,'
p15750
aS'                         ExcInternalError());'
p15751
aS'                  fe_v_face.reinit(cell, face_no);'
p15752
aS'                  fe_v_subface_neighbor.reinit(neighbor,'
p15753
aS'                                               neighbor_face_no,'
p15754
aS'                                               neighbor_subface_no);'
p15755
aS'                  assemble_face_term(face_no,'
p15756
aS'                                     fe_v_face,'
p15757
aS'                                     fe_v_subface_neighbor,'
p15758
aS'                                     dof_indices,'
p15759
aS'                                     dof_indices_neighbor,'
p15760
aS'                                     false,'
p15761
aS'                                     numbers::invalid_unsigned_int,'
p15762
aS'                                     cell->face(face_no)->diameter());'
p15763
aS'                }'
p15764
aS'            }'
p15765
aS'      }'
p15766
aS'  }'
p15767
aS'  template <int dim>'
p15768
aS'  void ConservationLaw<dim>::assemble_cell_term('
p15769
aS'    const FEValues<dim> &                       fe_v,'
p15770
aS'    const std::vector<types::global_dof_index> &dof_indices)'
p15771
aS'  {'
p15772
aS'    const unsigned int dofs_per_cell = fe_v.dofs_per_cell;'
p15773
aS'    const unsigned int n_q_points    = fe_v.n_quadrature_points;'
p15774
aS'    Table<2, Sacado::Fad::DFad<double>> W(n_q_points,'
p15775
aS'                                          EulerEquations<dim>::n_components);'
p15776
aS'    Table<2, double> W_old(n_q_points, EulerEquations<dim>::n_components);'
p15777
aS'    Table<3, Sacado::Fad::DFad<double>> grad_W('
p15778
aS'      n_q_points, EulerEquations<dim>::n_components, dim);'
p15779
aS'    Table<3, double> grad_W_old(n_q_points,'
p15780
aS'                                EulerEquations<dim>::n_components,'
p15781
aS'                                dim);'
p15782
aS'    std::vector<double> residual_derivatives(dofs_per_cell);'
p15783
aS'    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values('
p15784
aS'      dofs_per_cell);'
p15785
aS'    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15786
aS'      independent_local_dof_values[i] = current_solution(dof_indices[i]);'
p15787
aS'    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15788
aS'      independent_local_dof_values[i].diff(i, dofs_per_cell);'
p15789
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15790
aS'      for (unsigned int c = 0; c < EulerEquations<dim>::n_components; ++c)'
p15791
aS'        {'
p15792
aS'          W[q][c]     = 0;'
p15793
aS'          W_old[q][c] = 0;'
p15794
aS'          for (unsigned int d = 0; d < dim; ++d)'
p15795
aS'            {'
p15796
aS'              grad_W[q][c][d]     = 0;'
p15797
aS'              grad_W_old[q][c][d] = 0;'
p15798
aS'            }'
p15799
aS'        }'
p15800
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15801
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15802
aS'        {'
p15803
aS'          const unsigned int c ='
p15804
aS'            fe_v.get_fe().system_to_component_index(i).first;'
p15805
aS'          W[q][c] += independent_local_dof_values[i] *'
p15806
aS'                     fe_v.shape_value_component(i, q, c);'
p15807
aS'          W_old[q][c] +='
p15808
aS'            old_solution(dof_indices[i]) * fe_v.shape_value_component(i, q, c);'
p15809
aS'          for (unsigned int d = 0; d < dim; d++)'
p15810
aS'            {'
p15811
aS'              grad_W[q][c][d] += independent_local_dof_values[i] *'
p15812
aS'                                 fe_v.shape_grad_component(i, q, c)[d];'
p15813
aS'              grad_W_old[q][c][d] += old_solution(dof_indices[i]) *'
p15814
aS'                                     fe_v.shape_grad_component(i, q, c)[d];'
p15815
aS'            }'
p15816
aS'        }'
p15817
aS'    std::vector<ndarray<Sacado::Fad::DFad<double>,'
p15818
aS'                        EulerEquations<dim>::n_components,'
p15819
aS'                        dim>>'
p15820
aS'      flux(n_q_points);'
p15821
aS'    std::vector<ndarray<double, EulerEquations<dim>::n_components, dim>>'
p15822
aS'      flux_old(n_q_points);'
p15823
aS'    std::vector<'
p15824
aS'      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>'
p15825
aS'      forcing(n_q_points);'
p15826
aS'    std::vector<std::array<double, EulerEquations<dim>::n_components>>'
p15827
aS'      forcing_old(n_q_points);'
p15828
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15829
aS'      {'
p15830
aS'        EulerEquations<dim>::compute_flux_matrix(W_old[q], flux_old[q]);'
p15831
aS'        EulerEquations<dim>::compute_forcing_vector(W_old[q], forcing_old[q]);'
p15832
aS'        EulerEquations<dim>::compute_flux_matrix(W[q], flux[q]);'
p15833
aS'        EulerEquations<dim>::compute_forcing_vector(W[q], forcing[q]);'
p15834
aS'      }'
p15835
aS'    for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p15836
aS'      {'
p15837
aS'        Sacado::Fad::DFad<double> R_i = 0;'
p15838
aS'        const unsigned int component_i ='
p15839
aS'          fe_v.get_fe().system_to_component_index(i).first;'
p15840
aS'        for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p15841
aS'          {'
p15842
aS'            if (parameters.is_stationary == false)'
p15843
aS'              R_i += 1.0 / parameters.time_step *'
p15844
aS'                     (W[point][component_i] - W_old[point][component_i]) *'
p15845
aS'                     fe_v.shape_value_component(i, point, component_i) *'
p15846
aS'                     fe_v.JxW(point);'
p15847
aS'            for (unsigned int d = 0; d < dim; d++)'
p15848
aS'              R_i -='
p15849
aS'                (parameters.theta * flux[point][component_i][d] +'
p15850
aS'                 (1.0 - parameters.theta) * flux_old[point][component_i][d]) *'
p15851
aS'                fe_v.shape_grad_component(i, point, component_i)[d] *'
p15852
aS'                fe_v.JxW(point);'
p15853
aS'            for (unsigned int d = 0; d < dim; d++)'
p15854
aS'              R_i +='
p15855
aS'                1.0 *'
p15856
aS'                std::pow(fe_v.get_cell()->diameter(),'
p15857
aS'                         parameters.diffusion_power) *'
p15858
aS'                (parameters.theta * grad_W[point][component_i][d] +'
p15859
aS'                 (1.0 - parameters.theta) * grad_W_old[point][component_i][d]) *'
p15860
aS'                fe_v.shape_grad_component(i, point, component_i)[d] *'
p15861
aS'                fe_v.JxW(point);'
p15862
aS'            R_i -='
p15863
aS'              (parameters.theta * forcing[point][component_i] +'
p15864
aS'               (1.0 - parameters.theta) * forcing_old[point][component_i]) *'
p15865
aS'              fe_v.shape_value_component(i, point, component_i) *'
p15866
aS'              fe_v.JxW(point);'
p15867
aS'          }'
p15868
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p15869
aS'          residual_derivatives[k] = R_i.fastAccessDx(k);'
p15870
aS'        system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);'
p15871
aS'        right_hand_side(dof_indices[i]) -= R_i.val();'
p15872
aS'      }'
p15873
aS'  }'
p15874
aS'  template <int dim>'
p15875
aS'  void ConservationLaw<dim>::assemble_face_term('
p15876
aS'    const unsigned int                          face_no,'
p15877
aS'    const FEFaceValuesBase<dim> &               fe_v,'
p15878
aS'    const FEFaceValuesBase<dim> &               fe_v_neighbor,'
p15879
aS'    const std::vector<types::global_dof_index> &dof_indices,'
p15880
aS'    const std::vector<types::global_dof_index> &dof_indices_neighbor,'
p15881
aS'    const bool                                  external_face,'
p15882
aS'    const unsigned int                          boundary_id,'
p15883
aS'    const double                                face_diameter)'
p15884
aS'  {'
p15885
aS'    const unsigned int n_q_points    = fe_v.n_quadrature_points;'
p15886
aS'    const unsigned int dofs_per_cell = fe_v.dofs_per_cell;'
p15887
aS'    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values('
p15888
aS'      dofs_per_cell),'
p15889
aS'      independent_neighbor_dof_values(external_face == false ? dofs_per_cell :'
p15890
aS'                                                               0);'
p15891
aS'    const unsigned int n_independent_variables ='
p15892
aS'      (external_face == false ? 2 * dofs_per_cell : dofs_per_cell);'
p15893
aS'    for (unsigned int i = 0; i < dofs_per_cell; i++)'
p15894
aS'      {'
p15895
aS'        independent_local_dof_values[i] = current_solution(dof_indices[i]);'
p15896
aS'        independent_local_dof_values[i].diff(i, n_independent_variables);'
p15897
aS'      }'
p15898
aS'    if (external_face == false)'
p15899
aS'      for (unsigned int i = 0; i < dofs_per_cell; i++)'
p15900
aS'        {'
p15901
aS'          independent_neighbor_dof_values[i] ='
p15902
aS'            current_solution(dof_indices_neighbor[i]);'
p15903
aS'          independent_neighbor_dof_values[i].diff(i + dofs_per_cell,'
p15904
aS'                                                  n_independent_variables);'
p15905
aS'        }'
p15906
aS'    Table<2, Sacado::Fad::DFad<double>> Wplus('
p15907
aS'      n_q_points, EulerEquations<dim>::n_components),'
p15908
aS'      Wminus(n_q_points, EulerEquations<dim>::n_components);'
p15909
aS'    Table<2, double> Wplus_old(n_q_points, EulerEquations<dim>::n_components),'
p15910
aS'      Wminus_old(n_q_points, EulerEquations<dim>::n_components);'
p15911
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15912
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15913
aS'        {'
p15914
aS'          const unsigned int component_i ='
p15915
aS'            fe_v.get_fe().system_to_component_index(i).first;'
p15916
aS'          Wplus[q][component_i] +='
p15917
aS'            independent_local_dof_values[i] *'
p15918
aS'            fe_v.shape_value_component(i, q, component_i);'
p15919
aS'          Wplus_old[q][component_i] +='
p15920
aS'            old_solution(dof_indices[i]) *'
p15921
aS'            fe_v.shape_value_component(i, q, component_i);'
p15922
aS'        }'
p15923
aS'    if (external_face == false)'
p15924
aS'      {'
p15925
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p15926
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15927
aS'            {'
p15928
aS'              const unsigned int component_i ='
p15929
aS'                fe_v_neighbor.get_fe().system_to_component_index(i).first;'
p15930
aS'              Wminus[q][component_i] +='
p15931
aS'                independent_neighbor_dof_values[i] *'
p15932
aS'                fe_v_neighbor.shape_value_component(i, q, component_i);'
p15933
aS'              Wminus_old[q][component_i] +='
p15934
aS'                old_solution(dof_indices_neighbor[i]) *'
p15935
aS'                fe_v_neighbor.shape_value_component(i, q, component_i);'
p15936
aS'            }'
p15937
aS'      }'
p15938
aS'    else'
p15939
aS'      {'
p15940
aS'        Assert(boundary_id < Parameters::AllParameters<dim>::max_n_boundaries,'
p15941
aS'               ExcIndexRange(boundary_id,'
p15942
aS'                             0,'
p15943
aS'                             Parameters::AllParameters<dim>::max_n_boundaries));'
p15944
aS'        std::vector<Vector<double>> boundary_values('
p15945
aS'          n_q_points, Vector<double>(EulerEquations<dim>::n_components));'
p15946
aS'        parameters.boundary_conditions[boundary_id].values.vector_value_list('
p15947
aS'          fe_v.get_quadrature_points(), boundary_values);'
p15948
aS'        for (unsigned int q = 0; q < n_q_points; q++)'
p15949
aS'          {'
p15950
aS'            EulerEquations<dim>::compute_Wminus('
p15951
aS'              parameters.boundary_conditions[boundary_id].kind,'
p15952
aS'              fe_v.normal_vector(q),'
p15953
aS'              Wplus[q],'
p15954
aS'              boundary_values[q],'
p15955
aS'              Wminus[q]);'
p15956
aS'            EulerEquations<dim>::compute_Wminus('
p15957
aS'              parameters.boundary_conditions[boundary_id].kind,'
p15958
aS'              fe_v.normal_vector(q),'
p15959
aS'              Wplus_old[q],'
p15960
aS'              boundary_values[q],'
p15961
aS'              Wminus_old[q]);'
p15962
aS'          }'
p15963
aS'      }'
p15964
aS'    std::vector<'
p15965
aS'      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>'
p15966
aS'      normal_fluxes(n_q_points);'
p15967
aS'    std::vector<std::array<double, EulerEquations<dim>::n_components>>'
p15968
aS'      normal_fluxes_old(n_q_points);'
p15969
aS'    double alpha;'
p15970
aS'    switch (parameters.stabilization_kind)'
p15971
aS'      {'
p15972
aS'        case Parameters::Flux::constant:'
p15973
aS'          alpha = parameters.stabilization_value;'
p15974
aS'          break;'
p15975
aS'        case Parameters::Flux::mesh_dependent:'
p15976
aS'          alpha = face_diameter / (2.0 * parameters.time_step);'
p15977
aS'          break;'
p15978
aS'        default:'
p15979
aS'          Assert(false, ExcNotImplemented());'
p15980
aS'          alpha = 1;'
p15981
aS'      }'
p15982
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15983
aS'      {'
p15984
aS'        EulerEquations<dim>::numerical_normal_flux('
p15985
aS'          fe_v.normal_vector(q), Wplus[q], Wminus[q], alpha, normal_fluxes[q]);'
p15986
aS'        EulerEquations<dim>::numerical_normal_flux(fe_v.normal_vector(q),'
p15987
aS'                                                   Wplus_old[q],'
p15988
aS'                                                   Wminus_old[q],'
p15989
aS'                                                   alpha,'
p15990
aS'                                                   normal_fluxes_old[q]);'
p15991
aS'      }'
p15992
aS'    std::vector<double> residual_derivatives(dofs_per_cell);'
p15993
aS'    for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p15994
aS'      if (fe_v.get_fe().has_support_on_face(i, face_no) == true)'
p15995
aS'        {'
p15996
aS'          Sacado::Fad::DFad<double> R_i = 0;'
p15997
aS'          for (unsigned int point = 0; point < n_q_points; ++point)'
p15998
aS'            {'
p15999
aS'              const unsigned int component_i ='
p16000
aS'                fe_v.get_fe().system_to_component_index(i).first;'
p16001
aS'              R_i += (parameters.theta * normal_fluxes[point][component_i] +'
p16002
aS'                      (1.0 - parameters.theta) *'
p16003
aS'                        normal_fluxes_old[point][component_i]) *'
p16004
aS'                     fe_v.shape_value_component(i, point, component_i) *'
p16005
aS'                     fe_v.JxW(point);'
p16006
aS'            }'
p16007
aS'          for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p16008
aS'            residual_derivatives[k] = R_i.fastAccessDx(k);'
p16009
aS'          system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);'
p16010
aS'          if (external_face == false)'
p16011
aS'            {'
p16012
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p16013
aS'                residual_derivatives[k] = R_i.fastAccessDx(dofs_per_cell + k);'
p16014
aS'              system_matrix.add(dof_indices[i],'
p16015
aS'                                dof_indices_neighbor,'
p16016
aS'                                residual_derivatives);'
p16017
aS'            }'
p16018
aS'          right_hand_side(dof_indices[i]) -= R_i.val();'
p16019
aS'        }'
p16020
aS'  }'
p16021
aS'  template <int dim>'
p16022
aS'  std::pair<unsigned int, double>'
p16023
aS'  ConservationLaw<dim>::solve(Vector<double> &newton_update)'
p16024
aS'  {'
p16025
aS'    switch (parameters.solver)'
p16026
aS'      {'
p16027
aS'        case Parameters::Solver::direct:'
p16028
aS'          {'
p16029
aS'            SolverControl                                  solver_control(1, 0);'
p16030
aS'            TrilinosWrappers::SolverDirect::AdditionalData data('
p16031
aS'              parameters.output == Parameters::Solver::verbose);'
p16032
aS'            TrilinosWrappers::SolverDirect direct(solver_control, data);'
p16033
aS'            direct.solve(system_matrix, newton_update, right_hand_side);'
p16034
aS'            return {solver_control.last_step(), solver_control.last_value()};'
p16035
aS'          }'
p16036
aS'        case Parameters::Solver::gmres:'
p16037
aS'          {'
p16038
aS'            Epetra_Vector x(View,'
p16039
aS'                            system_matrix.trilinos_matrix().DomainMap(),'
p16040
aS'                            newton_update.begin());'
p16041
aS'            Epetra_Vector b(View,'
p16042
aS'                            system_matrix.trilinos_matrix().RangeMap(),'
p16043
aS'                            right_hand_side.begin());'
p16044
aS'            AztecOO solver;'
p16045
aS'            solver.SetAztecOption('
p16046
aS'              AZ_output,'
p16047
aS'              (parameters.output == Parameters::Solver::quiet ? AZ_none :'
p16048
aS'                                                                AZ_all));'
p16049
aS'            solver.SetAztecOption(AZ_solver, AZ_gmres);'
p16050
aS'            solver.SetRHS(&b);'
p16051
aS'            solver.SetLHS(&x);'
p16052
aS'            solver.SetAztecOption(AZ_precond, AZ_dom_decomp);'
p16053
aS'            solver.SetAztecOption(AZ_subdomain_solve, AZ_ilut);'
p16054
aS'            solver.SetAztecOption(AZ_overlap, 0);'
p16055
aS'            solver.SetAztecOption(AZ_reorder, 0);'
p16056
aS'            solver.SetAztecParam(AZ_drop, parameters.ilut_drop);'
p16057
aS'            solver.SetAztecParam(AZ_ilut_fill, parameters.ilut_fill);'
p16058
aS'            solver.SetAztecParam(AZ_athresh, parameters.ilut_atol);'
p16059
aS'            solver.SetAztecParam(AZ_rthresh, parameters.ilut_rtol);'
p16060
aS'            solver.SetUserMatrix('
p16061
aS'              const_cast<Epetra_CrsMatrix *>(&system_matrix.trilinos_matrix()));'
p16062
aS'            solver.Iterate(parameters.max_iterations,'
p16063
aS'                           parameters.linear_residual);'
p16064
aS'            return {solver.NumIters(), solver.TrueResidual()};'
p16065
aS'          }'
p16066
aS'      }'
p16067
aS'    Assert(false, ExcNotImplemented());'
p16068
aS'    return {0, 0};'
p16069
aS'  }'
p16070
aS'  template <int dim>'
p16071
aS'  void ConservationLaw<dim>::compute_refinement_indicators('
p16072
aS'    Vector<double> &refinement_indicators) const'
p16073
aS'  {'
p16074
aS'    EulerEquations<dim>::compute_refinement_indicators(dof_handler,'
p16075
aS'                                                       mapping,'
p16076
aS'                                                       predictor,'
p16077
aS'                                                       refinement_indicators);'
p16078
aS'  }'
p16079
aS'  template <int dim>'
p16080
aS'  void'
p16081
aS'  ConservationLaw<dim>::refine_grid(const Vector<double> &refinement_indicators)'
p16082
aS'  {'
p16083
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p16084
aS'      {'
p16085
aS'        const unsigned int cell_no = cell->active_cell_index();'
p16086
aS'        cell->clear_coarsen_flag();'
p16087
aS'        cell->clear_refine_flag();'
p16088
aS'        if ((cell->level() < parameters.shock_levels) &&'
p16089
aS'            (std::fabs(refinement_indicators(cell_no)) > parameters.shock_val))'
p16090
aS'          cell->set_refine_flag();'
p16091
aS'        else if ((cell->level() > 0) &&'
p16092
aS'                 (std::fabs(refinement_indicators(cell_no)) <'
p16093
aS'                  0.75 * parameters.shock_val))'
p16094
aS'          cell->set_coarsen_flag();'
p16095
aS'      }'
p16096
aS'    std::vector<Vector<double>> transfer_in;'
p16097
aS'    std::vector<Vector<double>> transfer_out;'
p16098
aS'    transfer_in.push_back(old_solution);'
p16099
aS'    transfer_in.push_back(predictor);'
p16100
aS'    triangulation.prepare_coarsening_and_refinement();'
p16101
aS'    SolutionTransfer<dim> soltrans(dof_handler);'
p16102
aS'    soltrans.prepare_for_coarsening_and_refinement(transfer_in);'
p16103
aS'    triangulation.execute_coarsening_and_refinement();'
p16104
aS'    dof_handler.clear();'
p16105
aS'    dof_handler.distribute_dofs(fe);'
p16106
aS'    {'
p16107
aS'      Vector<double> new_old_solution(1);'
p16108
aS'      Vector<double> new_predictor(1);'
p16109
aS'      transfer_out.push_back(new_old_solution);'
p16110
aS'      transfer_out.push_back(new_predictor);'
p16111
aS'      transfer_out[0].reinit(dof_handler.n_dofs());'
p16112
aS'      transfer_out[1].reinit(dof_handler.n_dofs());'
p16113
aS'    }'
p16114
aS'    soltrans.interpolate(transfer_in, transfer_out);'
p16115
aS'    old_solution.reinit(transfer_out[0].size());'
p16116
aS'    old_solution = transfer_out[0];'
p16117
aS'    predictor.reinit(transfer_out[1].size());'
p16118
aS'    predictor = transfer_out[1];'
p16119
aS'    current_solution.reinit(dof_handler.n_dofs());'
p16120
aS'    current_solution = old_solution;'
p16121
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p16122
aS'  }'
p16123
aS'  template <int dim>'
p16124
aS'  void ConservationLaw<dim>::output_results() const'
p16125
aS'  {'
p16126
aS'    typename EulerEquations<dim>::Postprocessor postprocessor('
p16127
aS'      parameters.schlieren_plot);'
p16128
aS'    DataOut<dim> data_out;'
p16129
aS'    data_out.attach_dof_handler(dof_handler);'
p16130
aS'    data_out.add_data_vector(current_solution,'
p16131
aS'                             EulerEquations<dim>::component_names(),'
p16132
aS'                             DataOut<dim>::type_dof_data,'
p16133
aS'                             EulerEquations<dim>::component_interpretation());'
p16134
aS'    data_out.add_data_vector(current_solution, postprocessor);'
p16135
aS'    data_out.build_patches();'
p16136
aS'    static unsigned int output_file_number = 0;'
p16137
aS'    std::string         filename ='
p16138
aS'      "solution-" + Utilities::int_to_string(output_file_number, 3) + ".vtk";'
p16139
aS'    std::ofstream output(filename);'
p16140
aS'    data_out.write_vtk(output);'
p16141
aS'    ++output_file_number;'
p16142
aS'  }'
p16143
aS'  template <int dim>'
p16144
aS'  void ConservationLaw<dim>::run()'
p16145
aS'  {'
p16146
aS'    {'
p16147
aS'      GridIn<dim> grid_in;'
p16148
aS'      grid_in.attach_triangulation(triangulation);'
p16149
aS'      std::ifstream input_file(parameters.mesh_filename);'
p16150
aS'      Assert(input_file, ExcFileNotOpen(parameters.mesh_filename.c_str()));'
p16151
aS'      grid_in.read_ucd(input_file);'
p16152
aS'    }'
p16153
aS'    dof_handler.clear();'
p16154
aS'    dof_handler.distribute_dofs(fe);'
p16155
aS'    old_solution.reinit(dof_handler.n_dofs());'
p16156
aS'    current_solution.reinit(dof_handler.n_dofs());'
p16157
aS'    predictor.reinit(dof_handler.n_dofs());'
p16158
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p16159
aS'    setup_system();'
p16160
aS'    VectorTools::interpolate(dof_handler,'
p16161
aS'                             parameters.initial_conditions,'
p16162
aS'                             old_solution);'
p16163
aS'    current_solution = old_solution;'
p16164
aS'    predictor        = old_solution;'
p16165
aS'    if (parameters.do_refine == true)'
p16166
aS'      for (unsigned int i = 0; i < parameters.shock_levels; ++i)'
p16167
aS'        {'
p16168
aS'          Vector<double> refinement_indicators(triangulation.n_active_cells());'
p16169
aS'          compute_refinement_indicators(refinement_indicators);'
p16170
aS'          refine_grid(refinement_indicators);'
p16171
aS'          setup_system();'
p16172
aS'          VectorTools::interpolate(dof_handler,'
p16173
aS'                                   parameters.initial_conditions,'
p16174
aS'                                   old_solution);'
p16175
aS'          current_solution = old_solution;'
p16176
aS'          predictor        = old_solution;'
p16177
aS'        }'
p16178
aS'    output_results();'
p16179
aS'    Vector<double> newton_update(dof_handler.n_dofs());'
p16180
aS'    double time        = 0;'
p16181
aS'    double next_output = time + parameters.output_step;'
p16182
aS'    predictor = old_solution;'
p16183
aS'    while (time < parameters.final_time)'
p16184
aS'      {'
p16185
aS'        std::cout << "T=" << time << std::endl'
p16186
aS'                  << "   Number of active cells:       "'
p16187
aS'                  << triangulation.n_active_cells() << std::endl'
p16188
aS'                  << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p16189
aS'                  << std::endl'
p16190
aS'                  << std::endl;'
p16191
aS'        std::cout << "   NonLin Res     Lin Iter       Lin Res" << std::endl'
p16192
aS'                  << "   _____________________________________" << std::endl;'
p16193
aS'        unsigned int nonlin_iter = 0;'
p16194
aS'        current_solution         = predictor;'
p16195
aS'        while (true)'
p16196
aS'          {'
p16197
aS'            system_matrix = 0;'
p16198
aS'            right_hand_side = 0;'
p16199
aS'            assemble_system();'
p16200
aS'            const double res_norm = right_hand_side.l2_norm();'
p16201
aS'            if (std::fabs(res_norm) < 1e-10)'
p16202
aS'              {'
p16203
aS'                std::printf("   %-16.3e (converged)\\n\\n", res_norm);'
p16204
aS'                break;'
p16205
aS'              }'
p16206
aS'            else'
p16207
aS'              {'
p16208
aS'                newton_update = 0;'
p16209
aS'                std::pair<unsigned int, double> convergence ='
p16210
aS'                  solve(newton_update);'
p16211
aS'                current_solution += newton_update;'
p16212
aS'                std::printf("   %-16.3e %04d        %-5.2e\\n",'
p16213
aS'                            res_norm,'
p16214
aS'                            convergence.first,'
p16215
aS'                            convergence.second);'
p16216
aS'              }'
p16217
aS'            ++nonlin_iter;'
p16218
aS'            AssertThrow(nonlin_iter <= 10,'
p16219
aS'                        ExcMessage("No convergence in nonlinear solver"));'
p16220
aS'          }'
p16221
aS'        time += parameters.time_step;'
p16222
aS'        if (parameters.output_step < 0)'
p16223
aS'          output_results();'
p16224
aS'        else if (time >= next_output)'
p16225
aS'          {'
p16226
aS'            output_results();'
p16227
aS'            next_output += parameters.output_step;'
p16228
aS'          }'
p16229
aS'        predictor = current_solution;'
p16230
aS'        predictor.sadd(2.0, -1.0, old_solution);'
p16231
aS'        old_solution = current_solution;'
p16232
aS'        if (parameters.do_refine == true)'
p16233
aS'          {'
p16234
aS'            Vector<double> refinement_indicators('
p16235
aS'              triangulation.n_active_cells());'
p16236
aS'            compute_refinement_indicators(refinement_indicators);'
p16237
aS'            refine_grid(refinement_indicators);'
p16238
aS'            setup_system();'
p16239
aS'            newton_update.reinit(dof_handler.n_dofs());'
p16240
aS'          }'
p16241
aS'      }'
p16242
aS'  }'
p16243
aS'} // namespace Step33'
p16244
aS'int main(int argc, char *argv[])'
p16245
ag24
aS'  try'
p16246
aS'    {'
p16247
aS'      using namespace dealii;'
p16248
aS'      using namespace Step33;'
p16249
aS'      if (argc != 2)'
p16250
aS'        {'
p16251
aS'          std::cout << "Usage:" << argv[0] << " input_file" << std::endl;'
p16252
aS'          std::exit(1);'
p16253
aS'        }'
p16254
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p16255
aS'        argc, argv, dealii::numbers::invalid_unsigned_int);'
p16256
aS'      ConservationLaw<2> cons(argv[1]);'
p16257
aS'      cons.run();'
p16258
aS'    }'
p16259
aS'  catch (std::exception &exc)'
p16260
aS'    {'
p16261
aS'      std::cerr << std::endl'
p16262
aS'                << std::endl'
p16263
aS'                << "----------------------------------------------------"'
p16264
aS'                << std::endl;'
p16265
aS'      std::cerr << "Exception on processing: " << std::endl'
p16266
aS'                << exc.what() << std::endl'
p16267
aS'                << "Aborting!" << std::endl'
p16268
aS'                << "----------------------------------------------------"'
p16269
aS'                << std::endl;'
p16270
aS'      return 1;'
p16271
aS'    }'
p16272
aS'  catch (...)'
p16273
aS'    {'
p16274
aS'      std::cerr << std::endl'
p16275
aS'                << std::endl'
p16276
aS'                << "----------------------------------------------------"'
p16277
aS'                << std::endl;'
p16278
aS'      std::cerr << "Unknown exception!" << std::endl'
p16279
aS'                << "Aborting!" << std::endl'
p16280
aS'                << "----------------------------------------------------"'
p16281
aS'                << std::endl;'
p16282
aS'      return 1;'
p16283
aS'    };'
p16284
aS'  return 0;'
p16285
ag32
aS'/* ---------------------------------------------------------------------'
p16286
aS' *'
p16287
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p16288
aS' *'
p16289
aS' * This file is part of the deal.II library.'
p16290
aS' *'
p16291
aS' * The deal.II library is free software; you can use it, redistribute'
p16292
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p16293
aS' * Public License as published by the Free Software Foundation; either'
p16294
aS' * version 2.1 of the License, or (at your option) any later version.'
p16295
aS' * The full text of the license can be found in the file LICENSE.md at'
p16296
aS' * the top level directory of deal.II.'
p16297
aS' *'
p16298
aS' * ---------------------------------------------------------------------'
p16299
aS' *'
p16300
aS' * Author: Luca Heltai, Cataldo Manigrasso, 2009'
p16301
aS' */'
p16302
aS'#include <deal.II/base/smartpointer.h>'
p16303
aS'#include <deal.II/base/convergence_table.h>'
p16304
aS'#include <deal.II/base/quadrature_lib.h>'
p16305
aS'#include <deal.II/base/quadrature_selector.h>'
p16306
aS'#include <deal.II/base/parsed_function.h>'
p16307
aS'#include <deal.II/base/utilities.h>'
p16308
aS'#include <deal.II/lac/full_matrix.h>'
p16309
aS'#include <deal.II/lac/vector.h>'
p16310
aS'#include <deal.II/lac/solver_control.h>'
p16311
aS'#include <deal.II/lac/solver_gmres.h>'
p16312
aS'#include <deal.II/lac/precondition.h>'
p16313
aS'#include <deal.II/grid/tria.h>'
p16314
aS'#include <deal.II/grid/grid_generator.h>'
p16315
aS'#include <deal.II/grid/grid_in.h>'
p16316
aS'#include <deal.II/grid/grid_out.h>'
p16317
aS'#include <deal.II/grid/manifold_lib.h>'
p16318
aS'#include <deal.II/dofs/dof_handler.h>'
p16319
aS'#include <deal.II/dofs/dof_tools.h>'
p16320
aS'#include <deal.II/fe/fe_q.h>'
p16321
aS'#include <deal.II/fe/fe_values.h>'
p16322
aS'#include <deal.II/fe/mapping_q.h>'
p16323
aS'#include <deal.II/numerics/data_out.h>'
p16324
aS'#include <deal.II/numerics/vector_tools.h>'
p16325
aS'#include <cmath>'
p16326
aS'#include <iostream>'
p16327
aS'#include <fstream>'
p16328
aS'#include <string>'
p16329
aS'namespace Step34'
p16330
ag24
aS'  using namespace dealii;'
p16331
aS'  namespace LaplaceKernel'
p16332
aS'  {'
p16333
aS'    template <int dim>'
p16334
aS'    double single_layer(const Tensor<1, dim> &R)'
p16335
aS'    {'
p16336
aS'      switch (dim)'
p16337
aS'        {'
p16338
aS'          case 2:'
p16339
aS'            return (-std::log(R.norm()) / (2 * numbers::PI));'
p16340
aS'          case 3:'
p16341
aS'            return (1. / (R.norm() * 4 * numbers::PI));'
p16342
aS'          default:'
p16343
aS'            Assert(false, ExcInternalError());'
p16344
aS'            return 0.;'
p16345
aS'        }'
p16346
aS'    }'
p16347
aS'    template <int dim>'
p16348
aS'    Tensor<1, dim> double_layer(const Tensor<1, dim> &R)'
p16349
aS'    {'
p16350
aS'      switch (dim)'
p16351
aS'        {'
p16352
aS'          case 2:'
p16353
aS'            return R / (-2 * numbers::PI * R.norm_square());'
p16354
aS'          case 3:'
p16355
aS'            return R / (-4 * numbers::PI * R.norm_square() * R.norm());'
p16356
aS'          default:'
p16357
aS'            Assert(false, ExcInternalError());'
p16358
aS'            return Tensor<1, dim>();'
p16359
aS'        }'
p16360
aS'    }'
p16361
aS'  } // namespace LaplaceKernel'
p16362
aS'  template <int dim>'
p16363
aS'  class BEMProblem'
p16364
aS'  {'
p16365
aS'  public:'
p16366
aS'    BEMProblem(const unsigned int fe_degree      = 1,'
p16367
aS'               const unsigned int mapping_degree = 1);'
p16368
aS'    void run();'
p16369
aS'  private:'
p16370
aS'    void read_parameters(const std::string &filename);'
p16371
aS'    void read_domain();'
p16372
aS'    void refine_and_resize();'
p16373
aS'    void assemble_system();'
p16374
aS'    void solve_system();'
p16375
aS'    void compute_errors(const unsigned int cycle);'
p16376
aS'    void compute_exterior_solution();'
p16377
aS'    void output_results(const unsigned int cycle);'
p16378
aS'    const Quadrature<dim - 1> &get_singular_quadrature('
p16379
aS'      const typename DoFHandler<dim - 1, dim>::active_cell_iterator &cell,'
p16380
aS'      const unsigned int index) const;'
p16381
aS'    Triangulation<dim - 1, dim> tria;'
p16382
aS'    FE_Q<dim - 1, dim>          fe;'
p16383
aS'    DoFHandler<dim - 1, dim>    dof_handler;'
p16384
aS'    MappingQ<dim - 1, dim>      mapping;'
p16385
aS'    FullMatrix<double> system_matrix;'
p16386
aS'    Vector<double>     system_rhs;'
p16387
aS'    Vector<double> phi;'
p16388
aS'    Vector<double> alpha;'
p16389
aS'    ConvergenceTable convergence_table;'
p16390
aS'    Functions::ParsedFunction<dim> wind;'
p16391
aS'    Functions::ParsedFunction<dim> exact_solution;'
p16392
aS'    unsigned int                         singular_quadrature_order;'
p16393
aS'    std::shared_ptr<Quadrature<dim - 1>> quadrature;'
p16394
aS'    SolverControl solver_control;'
p16395
aS'    unsigned int n_cycles;'
p16396
aS'    unsigned int external_refinement;'
p16397
aS'    bool run_in_this_dimension;'
p16398
aS'    bool extend_solution;'
p16399
aS'  };'
p16400
aS'  template <int dim>'
p16401
aS'  BEMProblem<dim>::BEMProblem(const unsigned int fe_degree,'
p16402
aS'                              const unsigned int mapping_degree)'
p16403
aS'    : fe(fe_degree)'
p16404
aS'    , dof_handler(tria)'
p16405
aS'    , mapping(mapping_degree, true)'
p16406
aS'    , wind(dim)'
p16407
aS'    , singular_quadrature_order(5)'
p16408
aS'    , n_cycles(4)'
p16409
aS'    , external_refinement(5)'
p16410
aS'    , run_in_this_dimension(true)'
p16411
aS'    , extend_solution(true)'
p16412
aS'  {}'
p16413
aS'  template <int dim>'
p16414
aS'  void BEMProblem<dim>::read_parameters(const std::string &filename)'
p16415
aS'  {'
p16416
aS'    deallog << std::endl'
p16417
aS'            << "Parsing parameter file " << filename << std::endl'
p16418
aS'            << "for a " << dim << " dimensional simulation. " << std::endl;'
p16419
aS'    ParameterHandler prm;'
p16420
aS'    prm.declare_entry("Number of cycles", "4", Patterns::Integer());'
p16421
aS'    prm.declare_entry("External refinement", "5", Patterns::Integer());'
p16422
aS'    prm.declare_entry("Extend solution on the -2,2 box",'
p16423
aS'                      "true",'
p16424
aS'                      Patterns::Bool());'
p16425
aS'    prm.declare_entry("Run 2d simulation", "true", Patterns::Bool());'
p16426
aS'    prm.declare_entry("Run 3d simulation", "true", Patterns::Bool());'
p16427
aS'    prm.enter_subsection("Quadrature rules");'
p16428
aS'    {'
p16429
aS'      prm.declare_entry('
p16430
aS'        "Quadrature type",'
p16431
aS'        "gauss",'
p16432
aS'        Patterns::Selection('
p16433
aS'          QuadratureSelector<(dim - 1)>::get_quadrature_names()));'
p16434
aS'      prm.declare_entry("Quadrature order", "4", Patterns::Integer());'
p16435
aS'      prm.declare_entry("Singular quadrature order", "5", Patterns::Integer());'
p16436
aS'    }'
p16437
aS'    prm.leave_subsection();'
p16438
aS'    prm.enter_subsection("Wind function 2d");'
p16439
aS'    {'
p16440
aS'      Functions::ParsedFunction<2>::declare_parameters(prm, 2);'
p16441
aS'      prm.set("Function expression", "1; 1");'
p16442
aS'    }'
p16443
aS'    prm.leave_subsection();'
p16444
aS'    prm.enter_subsection("Wind function 3d");'
p16445
aS'    {'
p16446
aS'      Functions::ParsedFunction<3>::declare_parameters(prm, 3);'
p16447
aS'      prm.set("Function expression", "1; 1; 1");'
p16448
aS'    }'
p16449
aS'    prm.leave_subsection();'
p16450
aS'    prm.enter_subsection("Exact solution 2d");'
p16451
aS'    {'
p16452
aS'      Functions::ParsedFunction<2>::declare_parameters(prm);'
p16453
aS'      prm.set("Function expression", "x+y");'
p16454
aS'    }'
p16455
aS'    prm.leave_subsection();'
p16456
aS'    prm.enter_subsection("Exact solution 3d");'
p16457
aS'    {'
p16458
aS'      Functions::ParsedFunction<3>::declare_parameters(prm);'
p16459
aS'      prm.set("Function expression", "x+y+z");'
p16460
aS'    }'
p16461
aS'    prm.leave_subsection();'
p16462
aS'    prm.enter_subsection("Solver");'
p16463
aS'    SolverControl::declare_parameters(prm);'
p16464
aS'    prm.leave_subsection();'
p16465
aS'    prm.parse_input(filename);'
p16466
aS'    n_cycles            = prm.get_integer("Number of cycles");'
p16467
aS'    external_refinement = prm.get_integer("External refinement");'
p16468
aS'    extend_solution     = prm.get_bool("Extend solution on the -2,2 box");'
p16469
aS'    prm.enter_subsection("Quadrature rules");'
p16470
aS'    {'
p16471
aS'      quadrature = std::shared_ptr<Quadrature<dim - 1>>('
p16472
aS'        new QuadratureSelector<dim - 1>(prm.get("Quadrature type"),'
p16473
aS'                                        prm.get_integer("Quadrature order")));'
p16474
aS'      singular_quadrature_order = prm.get_integer("Singular quadrature order");'
p16475
aS'    }'
p16476
aS'    prm.leave_subsection();'
p16477
aS'    prm.enter_subsection("Wind function " + std::to_string(dim) + "d");'
p16478
aS'    {'
p16479
aS'      wind.parse_parameters(prm);'
p16480
aS'    }'
p16481
aS'    prm.leave_subsection();'
p16482
aS'    prm.enter_subsection("Exact solution " + std::to_string(dim) + "d");'
p16483
aS'    {'
p16484
aS'      exact_solution.parse_parameters(prm);'
p16485
aS'    }'
p16486
aS'    prm.leave_subsection();'
p16487
aS'    prm.enter_subsection("Solver");'
p16488
aS'    solver_control.parse_parameters(prm);'
p16489
aS'    prm.leave_subsection();'
p16490
aS'    run_in_this_dimension ='
p16491
aS'      prm.get_bool("Run " + std::to_string(dim) + "d simulation");'
p16492
aS'  }'
p16493
aS'  template <int dim>'
p16494
aS'  void BEMProblem<dim>::read_domain()'
p16495
aS'  {'
p16496
aS'    const Point<dim>                      center = Point<dim>();'
p16497
aS'    const SphericalManifold<dim - 1, dim> manifold(center);'
p16498
aS'    std::ifstream in;'
p16499
aS'    switch (dim)'
p16500
aS'      {'
p16501
aS'        case 2:'
p16502
aS'          in.open("coarse_circle.inp");'
p16503
aS'          break;'
p16504
aS'        case 3:'
p16505
aS'          in.open("coarse_sphere.inp");'
p16506
aS'          break;'
p16507
aS'        default:'
p16508
aS'          Assert(false, ExcNotImplemented());'
p16509
aS'      }'
p16510
aS'    GridIn<dim - 1, dim> gi;'
p16511
aS'    gi.attach_triangulation(tria);'
p16512
aS'    gi.read_ucd(in);'
p16513
aS'    tria.set_all_manifold_ids(1);'
p16514
aS'    tria.set_manifold(1, manifold);'
p16515
aS'  }'
p16516
aS'  template <int dim>'
p16517
aS'  void BEMProblem<dim>::refine_and_resize()'
p16518
aS'  {'
p16519
aS'    tria.refine_global(1);'
p16520
aS'    dof_handler.distribute_dofs(fe);'
p16521
aS'    const unsigned int n_dofs = dof_handler.n_dofs();'
p16522
aS'    system_matrix.reinit(n_dofs, n_dofs);'
p16523
aS'    system_rhs.reinit(n_dofs);'
p16524
aS'    phi.reinit(n_dofs);'
p16525
aS'    alpha.reinit(n_dofs);'
p16526
aS'  }'
p16527
aS'  template <int dim>'
p16528
aS'  void BEMProblem<dim>::assemble_system()'
p16529
aS'  {'
p16530
aS'    FEValues<dim - 1, dim> fe_v(mapping,'
p16531
aS'                                fe,'
p16532
aS'                                *quadrature,'
p16533
aS'                                update_values | update_normal_vectors |'
p16534
aS'                                  update_quadrature_points | update_JxW_values);'
p16535
aS'    const unsigned int n_q_points = fe_v.n_quadrature_points;'
p16536
aS'    std::vector<types::global_dof_index> local_dof_indices('
p16537
aS'      fe.n_dofs_per_cell());'
p16538
aS'    std::vector<Vector<double>> cell_wind(n_q_points, Vector<double>(dim));'
p16539
aS'    double                      normal_wind;'
p16540
aS'    Vector<double> local_matrix_row_i(fe.n_dofs_per_cell());'
p16541
aS'    std::vector<Point<dim>> support_points(dof_handler.n_dofs());'
p16542
aS'    DoFTools::map_dofs_to_support_points<dim - 1, dim>(mapping,'
p16543
aS'                                                       dof_handler,'
p16544
aS'                                                       support_points);'
p16545
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p16546
aS'      {'
p16547
aS'        fe_v.reinit(cell);'
p16548
aS'        cell->get_dof_indices(local_dof_indices);'
p16549
aS'        const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();'
p16550
aS'        const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p16551
aS'        wind.vector_value_list(q_points, cell_wind);'
p16552
aS'        for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p16553
aS'          {'
p16554
aS'            local_matrix_row_i = 0;'
p16555
aS'            bool         is_singular    = false;'
p16556
aS'            unsigned int singular_index = numbers::invalid_unsigned_int;'
p16557
aS'            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p16558
aS'              if (local_dof_indices[j] == i)'
p16559
aS'                {'
p16560
aS'                  singular_index = j;'
p16561
aS'                  is_singular    = true;'
p16562
aS'                  break;'
p16563
aS'                }'
p16564
aS'            if (is_singular == false)'
p16565
aS'              {'
p16566
aS'                for (unsigned int q = 0; q < n_q_points; ++q)'
p16567
aS'                  {'
p16568
aS'                    normal_wind = 0;'
p16569
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p16570
aS'                      normal_wind += normals[q][d] * cell_wind[q](d);'
p16571
aS'                    const Tensor<1, dim> R = q_points[q] - support_points[i];'
p16572
aS'                    system_rhs(i) += (LaplaceKernel::single_layer(R) *'
p16573
aS'                                      normal_wind * fe_v.JxW(q));'
p16574
aS'                    for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p16575
aS'                      local_matrix_row_i(j) -='
p16576
aS'                        ((LaplaceKernel::double_layer(R) * normals[q]) *'
p16577
aS'                         fe_v.shape_value(j, q) * fe_v.JxW(q));'
p16578
aS'                  }'
p16579
aS'              }'
p16580
aS'            else'
p16581
aS'              {'
p16582
aS'                Assert(singular_index != numbers::invalid_unsigned_int,'
p16583
aS'                       ExcInternalError());'
p16584
aS'                const Quadrature<dim - 1> &singular_quadrature ='
p16585
aS'                  get_singular_quadrature(cell, singular_index);'
p16586
aS'                FEValues<dim - 1, dim> fe_v_singular('
p16587
aS'                  mapping,'
p16588
aS'                  fe,'
p16589
aS'                  singular_quadrature,'
p16590
aS'                  update_jacobians | update_values | update_normal_vectors |'
p16591
aS'                    update_quadrature_points);'
p16592
aS'                fe_v_singular.reinit(cell);'
p16593
aS'                std::vector<Vector<double>> singular_cell_wind('
p16594
aS'                  singular_quadrature.size(), Vector<double>(dim));'
p16595
aS'                const std::vector<Tensor<1, dim>> &singular_normals ='
p16596
aS'                  fe_v_singular.get_normal_vectors();'
p16597
aS'                const std::vector<Point<dim>> &singular_q_points ='
p16598
aS'                  fe_v_singular.get_quadrature_points();'
p16599
aS'                wind.vector_value_list(singular_q_points, singular_cell_wind);'
p16600
aS'                for (unsigned int q = 0; q < singular_quadrature.size(); ++q)'
p16601
aS'                  {'
p16602
aS'                    const Tensor<1, dim> R ='
p16603
aS'                      singular_q_points[q] - support_points[i];'
p16604
aS'                    double normal_wind = 0;'
p16605
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p16606
aS'                      normal_wind +='
p16607
aS'                        (singular_cell_wind[q](d) * singular_normals[q][d]);'
p16608
aS'                    system_rhs(i) += (LaplaceKernel::single_layer(R) *'
p16609
aS'                                      normal_wind * fe_v_singular.JxW(q));'
p16610
aS'                    for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p16611
aS'                      {'
p16612
aS'                        local_matrix_row_i(j) -='
p16613
aS'                          ((LaplaceKernel::double_layer(R) *'
p16614
aS'                            singular_normals[q]) *'
p16615
aS'                           fe_v_singular.shape_value(j, q) *'
p16616
aS'                           fe_v_singular.JxW(q));'
p16617
aS'                      }'
p16618
aS'                  }'
p16619
aS'              }'
p16620
aS'            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p16621
aS'              system_matrix(i, local_dof_indices[j]) += local_matrix_row_i(j);'
p16622
aS'          }'
p16623
aS'      }'
p16624
aS'    Vector<double> ones(dof_handler.n_dofs());'
p16625
aS'    ones.add(-1.);'
p16626
aS'    system_matrix.vmult(alpha, ones);'
p16627
aS'    alpha.add(1);'
p16628
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p16629
aS'      system_matrix(i, i) += alpha(i);'
p16630
aS'  }'
p16631
aS'  template <int dim>'
p16632
aS'  void BEMProblem<dim>::solve_system()'
p16633
aS'  {'
p16634
aS'    SolverGMRES<Vector<double>> solver(solver_control);'
p16635
aS'    solver.solve(system_matrix, phi, system_rhs, PreconditionIdentity());'
p16636
aS'  }'
p16637
aS'  template <int dim>'
p16638
aS'  void BEMProblem<dim>::compute_errors(const unsigned int cycle)'
p16639
aS'  {'
p16640
aS'    Vector<float> difference_per_cell(tria.n_active_cells());'
p16641
aS'    VectorTools::integrate_difference(mapping,'
p16642
aS'                                      dof_handler,'
p16643
aS'                                      phi,'
p16644
aS'                                      exact_solution,'
p16645
aS'                                      difference_per_cell,'
p16646
aS'                                      QGauss<(dim - 1)>(2 * fe.degree + 1),'
p16647
aS'                                      VectorTools::L2_norm);'
p16648
aS'    const double L2_error ='
p16649
aS'      VectorTools::compute_global_error(tria,'
p16650
aS'                                        difference_per_cell,'
p16651
aS'                                        VectorTools::L2_norm);'
p16652
aS'    Vector<double> difference_per_node(alpha);'
p16653
aS'    difference_per_node.add(-.5);'
p16654
aS'    const double       alpha_error    = difference_per_node.linfty_norm();'
p16655
aS'    const unsigned int n_active_cells = tria.n_active_cells();'
p16656
aS'    const unsigned int n_dofs         = dof_handler.n_dofs();'
p16657
aS'    deallog << "Cycle " << cycle << \':\' << std::endl'
p16658
aS'            << "   Number of active cells:       " << n_active_cells'
p16659
aS'            << std::endl'
p16660
aS'            << "   Number of degrees of freedom: " << n_dofs << std::endl;'
p16661
aS'    convergence_table.add_value("cycle", cycle);'
p16662
aS'    convergence_table.add_value("cells", n_active_cells);'
p16663
aS'    convergence_table.add_value("dofs", n_dofs);'
p16664
aS'    convergence_table.add_value("L2(phi)", L2_error);'
p16665
aS'    convergence_table.add_value("Linfty(alpha)", alpha_error);'
p16666
aS'  }'
p16667
aS'  template <>'
p16668
aS'  const Quadrature<2> &BEMProblem<3>::get_singular_quadrature('
p16669
aS'    const DoFHandler<2, 3>::active_cell_iterator &,'
p16670
aS'    const unsigned int index) const'
p16671
aS'  {'
p16672
aS'    Assert(index < fe.n_dofs_per_cell(),'
p16673
aS'           ExcIndexRange(0, fe.n_dofs_per_cell(), index));'
p16674
aS'    static std::vector<QGaussOneOverR<2>> quadratures;'
p16675
aS'    if (quadratures.size() == 0)'
p16676
aS'      for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p16677
aS'        quadratures.emplace_back(singular_quadrature_order,'
p16678
aS'                                 fe.get_unit_support_points()[i],'
p16679
aS'                                 true);'
p16680
aS'    return quadratures[index];'
p16681
aS'  }'
p16682
aS'  template <>'
p16683
aS'  const Quadrature<1> &BEMProblem<2>::get_singular_quadrature('
p16684
aS'    const DoFHandler<1, 2>::active_cell_iterator &cell,'
p16685
aS'    const unsigned int                            index) const'
p16686
aS'  {'
p16687
aS'    Assert(index < fe.n_dofs_per_cell(),'
p16688
aS'           ExcIndexRange(0, fe.n_dofs_per_cell(), index));'
p16689
aS'    static Quadrature<1> *q_pointer = nullptr;'
p16690
aS'    if (q_pointer)'
p16691
aS'      delete q_pointer;'
p16692
aS'    q_pointer = new QGaussLogR<1>(singular_quadrature_order,'
p16693
aS'                                  fe.get_unit_support_points()[index],'
p16694
aS'                                  1. / cell->measure(),'
p16695
aS'                                  true);'
p16696
aS'    return (*q_pointer);'
p16697
aS'  }'
p16698
aS'  template <int dim>'
p16699
aS'  void BEMProblem<dim>::compute_exterior_solution()'
p16700
aS'  {'
p16701
aS'    Triangulation<dim> external_tria;'
p16702
aS'    GridGenerator::hyper_cube(external_tria, -2, 2);'
p16703
aS'    FE_Q<dim>       external_fe(1);'
p16704
aS'    DoFHandler<dim> external_dh(external_tria);'
p16705
aS'    Vector<double>  external_phi;'
p16706
aS'    external_tria.refine_global(external_refinement);'
p16707
aS'    external_dh.distribute_dofs(external_fe);'
p16708
aS'    external_phi.reinit(external_dh.n_dofs());'
p16709
aS'    FEValues<dim - 1, dim> fe_v(mapping,'
p16710
aS'                                fe,'
p16711
aS'                                *quadrature,'
p16712
aS'                                update_values | update_normal_vectors |'
p16713
aS'                                  update_quadrature_points | update_JxW_values);'
p16714
aS'    const unsigned int n_q_points = fe_v.n_quadrature_points;'
p16715
aS'    std::vector<types::global_dof_index> dofs(fe.n_dofs_per_cell());'
p16716
aS'    std::vector<double>         local_phi(n_q_points);'
p16717
aS'    std::vector<double>         normal_wind(n_q_points);'
p16718
aS'    std::vector<Vector<double>> local_wind(n_q_points, Vector<double>(dim));'
p16719
aS'    std::vector<Point<dim>> external_support_points(external_dh.n_dofs());'
p16720
aS'    DoFTools::map_dofs_to_support_points<dim>(StaticMappingQ1<dim>::mapping,'
p16721
aS'                                              external_dh,'
p16722
aS'                                              external_support_points);'
p16723
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p16724
aS'      {'
p16725
aS'        fe_v.reinit(cell);'
p16726
aS'        const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();'
p16727
aS'        const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p16728
aS'        cell->get_dof_indices(dofs);'
p16729
aS'        fe_v.get_function_values(phi, local_phi);'
p16730
aS'        wind.vector_value_list(q_points, local_wind);'
p16731
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p16732
aS'          {'
p16733
aS'            normal_wind[q] = 0;'
p16734
aS'            for (unsigned int d = 0; d < dim; ++d)'
p16735
aS'              normal_wind[q] += normals[q][d] * local_wind[q](d);'
p16736
aS'          }'
p16737
aS'        for (unsigned int i = 0; i < external_dh.n_dofs(); ++i)'
p16738
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p16739
aS'            {'
p16740
aS'              const Tensor<1, dim> R = q_points[q] - external_support_points[i];'
p16741
aS'              external_phi(i) +='
p16742
aS'                ((LaplaceKernel::single_layer(R) * normal_wind[q] +'
p16743
aS'                  (LaplaceKernel::double_layer(R) * normals[q]) *'
p16744
aS'                    local_phi[q]) *'
p16745
aS'                 fe_v.JxW(q));'
p16746
aS'            }'
p16747
aS'      }'
p16748
aS'    DataOut<dim> data_out;'
p16749
aS'    data_out.attach_dof_handler(external_dh);'
p16750
aS'    data_out.add_data_vector(external_phi, "external_phi");'
p16751
aS'    data_out.build_patches();'
p16752
aS'    const std::string filename = std::to_string(dim) + "d_external.vtk";'
p16753
aS'    std::ofstream     file(filename);'
p16754
aS'    data_out.write_vtk(file);'
p16755
aS'  }'
p16756
aS'  template <int dim>'
p16757
aS'  void BEMProblem<dim>::output_results(const unsigned int cycle)'
p16758
aS'  {'
p16759
aS'    DataOut<dim - 1, dim> dataout;'
p16760
aS'    dataout.attach_dof_handler(dof_handler);'
p16761
aS'    dataout.add_data_vector(phi, "phi", DataOut<dim - 1, dim>::type_dof_data);'
p16762
aS'    dataout.add_data_vector(alpha,'
p16763
aS'                            "alpha",'
p16764
aS'                            DataOut<dim - 1, dim>::type_dof_data);'
p16765
aS'    dataout.build_patches(mapping,'
p16766
aS'                          mapping.get_degree(),'
p16767
aS'                          DataOut<dim - 1, dim>::curved_inner_cells);'
p16768
aS'    const std::string filename = std::to_string(dim) + "d_boundary_solution_" +'
p16769
aS'                                 std::to_string(cycle) + ".vtk";'
p16770
aS'    std::ofstream file(filename);'
p16771
aS'    dataout.write_vtk(file);'
p16772
aS'    if (cycle == n_cycles - 1)'
p16773
aS'      {'
p16774
aS'        convergence_table.set_precision("L2(phi)", 3);'
p16775
aS'        convergence_table.set_precision("Linfty(alpha)", 3);'
p16776
aS'        convergence_table.set_scientific("L2(phi)", true);'
p16777
aS'        convergence_table.set_scientific("Linfty(alpha)", true);'
p16778
aS'        convergence_table.evaluate_convergence_rates('
p16779
aS'          "L2(phi)", ConvergenceTable::reduction_rate_log2);'
p16780
aS'        convergence_table.evaluate_convergence_rates('
p16781
aS'          "Linfty(alpha)", ConvergenceTable::reduction_rate_log2);'
p16782
aS'        deallog << std::endl;'
p16783
aS'        convergence_table.write_text(std::cout);'
p16784
aS'      }'
p16785
aS'  }'
p16786
aS'  template <int dim>'
p16787
aS'  void BEMProblem<dim>::run()'
p16788
aS'  {'
p16789
aS'    read_parameters("parameters.prm");'
p16790
aS'    if (run_in_this_dimension == false)'
p16791
aS'      {'
p16792
aS'        deallog << "Run in dimension " << dim'
p16793
aS'                << " explicitly disabled in parameter file. " << std::endl;'
p16794
aS'        return;'
p16795
aS'      }'
p16796
aS'    read_domain();'
p16797
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p16798
aS'      {'
p16799
aS'        refine_and_resize();'
p16800
aS'        assemble_system();'
p16801
aS'        solve_system();'
p16802
aS'        compute_errors(cycle);'
p16803
aS'        output_results(cycle);'
p16804
aS'      }'
p16805
aS'    if (extend_solution == true)'
p16806
aS'      compute_exterior_solution();'
p16807
aS'  }'
p16808
aS'} // namespace Step34'
p16809
aS'int main()'
p16810
ag24
aS'  try'
p16811
aS'    {'
p16812
aS'      using namespace Step34;'
p16813
aS'      const unsigned int degree         = 1;'
p16814
aS'      const unsigned int mapping_degree = 1;'
p16815
aS'      deallog.depth_console(3);'
p16816
aS'      BEMProblem<2> laplace_problem_2d(degree, mapping_degree);'
p16817
aS'      laplace_problem_2d.run();'
p16818
aS'      BEMProblem<3> laplace_problem_3d(degree, mapping_degree);'
p16819
aS'      laplace_problem_3d.run();'
p16820
aS'    }'
p16821
aS'  catch (std::exception &exc)'
p16822
aS'    {'
p16823
aS'      std::cerr << std::endl'
p16824
aS'                << std::endl'
p16825
aS'                << "----------------------------------------------------"'
p16826
aS'                << std::endl;'
p16827
aS'      std::cerr << "Exception on processing: " << std::endl'
p16828
aS'                << exc.what() << std::endl'
p16829
aS'                << "Aborting!" << std::endl'
p16830
aS'                << "----------------------------------------------------"'
p16831
aS'                << std::endl;'
p16832
aS'      return 1;'
p16833
aS'    }'
p16834
aS'  catch (...)'
p16835
aS'    {'
p16836
aS'      std::cerr << std::endl'
p16837
aS'                << std::endl'
p16838
aS'                << "----------------------------------------------------"'
p16839
aS'                << std::endl;'
p16840
aS'      std::cerr << "Unknown exception!" << std::endl'
p16841
aS'                << "Aborting!" << std::endl'
p16842
aS'                << "----------------------------------------------------"'
p16843
aS'                << std::endl;'
p16844
aS'      return 1;'
p16845
aS'    }'
p16846
aS'  return 0;'
p16847
ag32
aS'/* ---------------------------------------------------------------------'
p16848
aS' *'
p16849
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p16850
aS' *'
p16851
aS' * This file is part of the deal.II library.'
p16852
aS' *'
p16853
aS' * The deal.II library is free software; you can use it, redistribute'
p16854
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p16855
aS' * Public License as published by the Free Software Foundation; either'
p16856
aS' * version 2.1 of the License, or (at your option) any later version.'
p16857
aS' * The full text of the license can be found in the file LICENSE.md at'
p16858
aS' * the top level directory of deal.II.'
p16859
aS' *'
p16860
aS' * ---------------------------------------------------------------------'
p16861
aS' *'
p16862
aS' * Author: Abner Salgado, Texas A&M University 2009'
p16863
aS' */'
p16864
aS'#include <deal.II/base/parameter_handler.h>'
p16865
aS'#include <deal.II/base/point.h>'
p16866
aS'#include <deal.II/base/function.h>'
p16867
aS'#include <deal.II/base/quadrature_lib.h>'
p16868
aS'#include <deal.II/base/multithread_info.h>'
p16869
aS'#include <deal.II/base/thread_management.h>'
p16870
aS'#include <deal.II/base/work_stream.h>'
p16871
aS'#include <deal.II/base/parallel.h>'
p16872
aS'#include <deal.II/base/utilities.h>'
p16873
aS'#include <deal.II/base/conditional_ostream.h>'
p16874
aS'#include <deal.II/lac/vector.h>'
p16875
aS'#include <deal.II/lac/sparse_matrix.h>'
p16876
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p16877
aS'#include <deal.II/lac/solver_cg.h>'
p16878
aS'#include <deal.II/lac/precondition.h>'
p16879
aS'#include <deal.II/lac/solver_gmres.h>'
p16880
aS'#include <deal.II/lac/sparse_ilu.h>'
p16881
aS'#include <deal.II/lac/sparse_direct.h>'
p16882
aS'#include <deal.II/lac/affine_constraints.h>'
p16883
aS'#include <deal.II/grid/tria.h>'
p16884
aS'#include <deal.II/grid/grid_generator.h>'
p16885
aS'#include <deal.II/grid/grid_refinement.h>'
p16886
aS'#include <deal.II/grid/grid_in.h>'
p16887
aS'#include <deal.II/dofs/dof_handler.h>'
p16888
aS'#include <deal.II/dofs/dof_tools.h>'
p16889
aS'#include <deal.II/dofs/dof_renumbering.h>'
p16890
aS'#include <deal.II/fe/fe_q.h>'
p16891
aS'#include <deal.II/fe/fe_values.h>'
p16892
aS'#include <deal.II/fe/fe_tools.h>'
p16893
aS'#include <deal.II/fe/fe_system.h>'
p16894
aS'#include <deal.II/numerics/matrix_tools.h>'
p16895
aS'#include <deal.II/numerics/vector_tools.h>'
p16896
aS'#include <deal.II/numerics/data_out.h>'
p16897
aS'#include <fstream>'
p16898
aS'#include <cmath>'
p16899
aS'#include <iostream>'
p16900
aS'namespace Step35'
p16901
ag24
aS'  using namespace dealii;'
p16902
aS'  namespace RunTimeParameters'
p16903
aS'  {'
p16904
aS'    enum class Method'
p16905
aS'    {'
p16906
aS'      standard,'
p16907
aS'      rotational'
p16908
aS'    };'
p16909
aS'    class Data_Storage'
p16910
aS'    {'
p16911
aS'    public:'
p16912
aS'      Data_Storage();'
p16913
aS'      void read_data(const std::string &filename);'
p16914
aS'      Method form;'
p16915
aS'      double dt;'
p16916
aS'      double initial_time;'
p16917
aS'      double final_time;'
p16918
aS'      double Reynolds;'
p16919
aS'      unsigned int n_global_refines;'
p16920
aS'      unsigned int pressure_degree;'
p16921
aS'      unsigned int vel_max_iterations;'
p16922
aS'      unsigned int vel_Krylov_size;'
p16923
aS'      unsigned int vel_off_diagonals;'
p16924
aS'      unsigned int vel_update_prec;'
p16925
aS'      double       vel_eps;'
p16926
aS'      double       vel_diag_strength;'
p16927
aS'      bool         verbose;'
p16928
aS'      unsigned int output_interval;'
p16929
aS'    protected:'
p16930
aS'      ParameterHandler prm;'
p16931
aS'    };'
p16932
aS'    Data_Storage::Data_Storage()'
p16933
aS'      : form(Method::rotational)'
p16934
aS'      , dt(5e-4)'
p16935
aS'      , initial_time(0.)'
p16936
aS'      , final_time(1.)'
p16937
aS'      , Reynolds(1.)'
p16938
aS'      , n_global_refines(0)'
p16939
aS'      , pressure_degree(1)'
p16940
aS'      , vel_max_iterations(1000)'
p16941
aS'      , vel_Krylov_size(30)'
p16942
aS'      , vel_off_diagonals(60)'
p16943
aS'      , vel_update_prec(15)'
p16944
aS'      , vel_eps(1e-12)'
p16945
aS'      , vel_diag_strength(0.01)'
p16946
aS'      , verbose(true)'
p16947
aS'      , output_interval(15)'
p16948
aS'    {'
p16949
aS'      prm.declare_entry("Method_Form",'
p16950
aS'                        "rotational",'
p16951
aS'                        Patterns::Selection("rotational|standard"),'
p16952
aS'                        " Used to select the type of method that we are going "'
p16953
aS'                        "to use. ");'
p16954
aS'      prm.enter_subsection("Physical data");'
p16955
aS'      {'
p16956
aS'        prm.declare_entry("initial_time",'
p16957
aS'                          "0.",'
p16958
aS'                          Patterns::Double(0.),'
p16959
aS'                          " The initial time of the simulation. ");'
p16960
aS'        prm.declare_entry("final_time",'
p16961
aS'                          "1.",'
p16962
aS'                          Patterns::Double(0.),'
p16963
aS'                          " The final time of the simulation. ");'
p16964
aS'        prm.declare_entry("Reynolds",'
p16965
aS'                          "1.",'
p16966
aS'                          Patterns::Double(0.),'
p16967
aS'                          " The Reynolds number. ");'
p16968
aS'      }'
p16969
aS'      prm.leave_subsection();'
p16970
aS'      prm.enter_subsection("Time step data");'
p16971
aS'      {'
p16972
aS'        prm.declare_entry("dt",'
p16973
aS'                          "5e-4",'
p16974
aS'                          Patterns::Double(0.),'
p16975
aS'                          " The time step size. ");'
p16976
aS'      }'
p16977
aS'      prm.leave_subsection();'
p16978
aS'      prm.enter_subsection("Space discretization");'
p16979
aS'      {'
p16980
aS'        prm.declare_entry("n_of_refines",'
p16981
aS'                          "0",'
p16982
aS'                          Patterns::Integer(0, 15),'
p16983
aS'                          " The number of global refines we do on the mesh. ");'
p16984
aS'        prm.declare_entry("pressure_fe_degree",'
p16985
aS'                          "1",'
p16986
aS'                          Patterns::Integer(1, 5),'
p16987
aS'                          " The polynomial degree for the pressure space. ");'
p16988
aS'      }'
p16989
aS'      prm.leave_subsection();'
p16990
aS'      prm.enter_subsection("Data solve velocity");'
p16991
aS'      {'
p16992
aS'        prm.declare_entry('
p16993
aS'          "max_iterations",'
p16994
aS'          "1000",'
p16995
aS'          Patterns::Integer(1, 1000),'
p16996
aS'          " The maximal number of iterations GMRES must make. ");'
p16997
aS'        prm.declare_entry("eps",'
p16998
aS'                          "1e-12",'
p16999
aS'                          Patterns::Double(0.),'
p17000
aS'                          " The stopping criterion. ");'
p17001
aS'        prm.declare_entry("Krylov_size",'
p17002
aS'                          "30",'
p17003
aS'                          Patterns::Integer(1),'
p17004
aS'                          " The size of the Krylov subspace to be used. ");'
p17005
aS'        prm.declare_entry("off_diagonals",'
p17006
aS'                          "60",'
p17007
aS'                          Patterns::Integer(0),'
p17008
aS'                          " The number of off-diagonal elements ILU must "'
p17009
aS'                          "compute. ");'
p17010
aS'        prm.declare_entry("diag_strength",'
p17011
aS'                          "0.01",'
p17012
aS'                          Patterns::Double(0.),'
p17013
aS'                          " Diagonal strengthening coefficient. ");'
p17014
aS'        prm.declare_entry("update_prec",'
p17015
aS'                          "15",'
p17016
aS'                          Patterns::Integer(1),'
p17017
aS'                          " This number indicates how often we need to "'
p17018
aS'                          "update the preconditioner");'
p17019
aS'      }'
p17020
aS'      prm.leave_subsection();'
p17021
aS'      prm.declare_entry("verbose",'
p17022
aS'                        "true",'
p17023
aS'                        Patterns::Bool(),'
p17024
aS'                        " This indicates whether the output of the solution "'
p17025
aS'                        "process should be verbose. ");'
p17026
aS'      prm.declare_entry("output_interval",'
p17027
aS'                        "1",'
p17028
aS'                        Patterns::Integer(1),'
p17029
aS'                        " This indicates between how many time steps we print "'
p17030
aS'                        "the solution. ");'
p17031
aS'    }'
p17032
aS'    void Data_Storage::read_data(const std::string &filename)'
p17033
aS'    {'
p17034
aS'      std::ifstream file(filename);'
p17035
aS'      AssertThrow(file, ExcFileNotOpen(filename));'
p17036
aS'      prm.parse_input(file);'
p17037
aS'      if (prm.get("Method_Form") == std::string("rotational"))'
p17038
aS'        form = Method::rotational;'
p17039
aS'      else'
p17040
aS'        form = Method::standard;'
p17041
aS'      prm.enter_subsection("Physical data");'
p17042
aS'      {'
p17043
aS'        initial_time = prm.get_double("initial_time");'
p17044
aS'        final_time   = prm.get_double("final_time");'
p17045
aS'        Reynolds     = prm.get_double("Reynolds");'
p17046
aS'      }'
p17047
aS'      prm.leave_subsection();'
p17048
aS'      prm.enter_subsection("Time step data");'
p17049
aS'      {'
p17050
aS'        dt = prm.get_double("dt");'
p17051
aS'      }'
p17052
aS'      prm.leave_subsection();'
p17053
aS'      prm.enter_subsection("Space discretization");'
p17054
aS'      {'
p17055
aS'        n_global_refines = prm.get_integer("n_of_refines");'
p17056
aS'        pressure_degree  = prm.get_integer("pressure_fe_degree");'
p17057
aS'      }'
p17058
aS'      prm.leave_subsection();'
p17059
aS'      prm.enter_subsection("Data solve velocity");'
p17060
aS'      {'
p17061
aS'        vel_max_iterations = prm.get_integer("max_iterations");'
p17062
aS'        vel_eps            = prm.get_double("eps");'
p17063
aS'        vel_Krylov_size    = prm.get_integer("Krylov_size");'
p17064
aS'        vel_off_diagonals  = prm.get_integer("off_diagonals");'
p17065
aS'        vel_diag_strength  = prm.get_double("diag_strength");'
p17066
aS'        vel_update_prec    = prm.get_integer("update_prec");'
p17067
aS'      }'
p17068
aS'      prm.leave_subsection();'
p17069
aS'      verbose = prm.get_bool("verbose");'
p17070
aS'      output_interval = prm.get_integer("output_interval");'
p17071
aS'    }'
p17072
aS'  } // namespace RunTimeParameters'
p17073
aS'  namespace EquationData'
p17074
aS'  {'
p17075
aS'    template <int dim>'
p17076
aS'    class MultiComponentFunction : public Function<dim>'
p17077
aS'    {'
p17078
aS'    public:'
p17079
aS'      MultiComponentFunction(const double initial_time = 0.);'
p17080
aS'      void set_component(const unsigned int d);'
p17081
aS'    protected:'
p17082
aS'      unsigned int comp;'
p17083
aS'    };'
p17084
aS'    template <int dim>'
p17085
aS'    MultiComponentFunction<dim>::MultiComponentFunction('
p17086
aS'      const double initial_time)'
p17087
aS'      : Function<dim>(1, initial_time)'
p17088
aS'      , comp(0)'
p17089
aS'    {}'
p17090
aS'    template <int dim>'
p17091
aS'    void MultiComponentFunction<dim>::set_component(const unsigned int d)'
p17092
aS'    {'
p17093
aS'      Assert(d < dim, ExcIndexRange(d, 0, dim));'
p17094
aS'      comp = d;'
p17095
aS'    }'
p17096
aS'    template <int dim>'
p17097
aS'    class Velocity : public MultiComponentFunction<dim>'
p17098
aS'    {'
p17099
aS'    public:'
p17100
aS'      Velocity(const double initial_time = 0.0);'
p17101
aS'      virtual double value(const Point<dim> & p,'
p17102
aS'                           const unsigned int component = 0) const override;'
p17103
aS'      virtual void value_list(const std::vector<Point<dim>> &points,'
p17104
aS'                              std::vector<double> &          values,'
p17105
aS'                              const unsigned int component = 0) const override;'
p17106
aS'    };'
p17107
aS'    template <int dim>'
p17108
aS'    Velocity<dim>::Velocity(const double initial_time)'
p17109
aS'      : MultiComponentFunction<dim>(initial_time)'
p17110
aS'    {}'
p17111
aS'    template <int dim>'
p17112
aS'    void Velocity<dim>::value_list(const std::vector<Point<dim>> &points,'
p17113
aS'                                   std::vector<double> &          values,'
p17114
aS'                                   const unsigned int) const'
p17115
aS'    {'
p17116
aS'      const unsigned int n_points = points.size();'
p17117
aS'      Assert(values.size() == n_points,'
p17118
aS'             ExcDimensionMismatch(values.size(), n_points));'
p17119
aS'      for (unsigned int i = 0; i < n_points; ++i)'
p17120
aS'        values[i] = Velocity<dim>::value(points[i]);'
p17121
aS'    }'
p17122
aS'    template <int dim>'
p17123
aS'    double Velocity<dim>::value(const Point<dim> &p, const unsigned int) const'
p17124
aS'    {'
p17125
aS'      if (this->comp == 0)'
p17126
aS'        {'
p17127
aS'          const double Um = 1.5;'
p17128
aS'          const double H  = 4.1;'
p17129
aS'          return 4. * Um * p(1) * (H - p(1)) / (H * H);'
p17130
aS'        }'
p17131
aS'      else'
p17132
aS'        return 0.;'
p17133
aS'    }'
p17134
aS'    template <int dim>'
p17135
aS'    class Pressure : public Function<dim>'
p17136
aS'    {'
p17137
aS'    public:'
p17138
aS'      Pressure(const double initial_time = 0.0);'
p17139
aS'      virtual double value(const Point<dim> & p,'
p17140
aS'                           const unsigned int component = 0) const override;'
p17141
aS'      virtual void value_list(const std::vector<Point<dim>> &points,'
p17142
aS'                              std::vector<double> &          values,'
p17143
aS'                              const unsigned int component = 0) const override;'
p17144
aS'    };'
p17145
aS'    template <int dim>'
p17146
aS'    Pressure<dim>::Pressure(const double initial_time)'
p17147
aS'      : Function<dim>(1, initial_time)'
p17148
aS'    {}'
p17149
aS'    template <int dim>'
p17150
aS'    double Pressure<dim>::value(const Point<dim> & p,'
p17151
aS'                                const unsigned int component) const'
p17152
aS'    {'
p17153
aS'      (void)component;'
p17154
aS'      AssertIndexRange(component, 1);'
p17155
aS'      return 25. - p(0);'
p17156
aS'    }'
p17157
aS'    template <int dim>'
p17158
aS'    void Pressure<dim>::value_list(const std::vector<Point<dim>> &points,'
p17159
aS'                                   std::vector<double> &          values,'
p17160
aS'                                   const unsigned int component) const'
p17161
aS'    {'
p17162
aS'      (void)component;'
p17163
aS'      AssertIndexRange(component, 1);'
p17164
aS'      const unsigned int n_points = points.size();'
p17165
aS'      Assert(values.size() == n_points,'
p17166
aS'             ExcDimensionMismatch(values.size(), n_points));'
p17167
aS'      for (unsigned int i = 0; i < n_points; ++i)'
p17168
aS'        values[i] = Pressure<dim>::value(points[i]);'
p17169
aS'    }'
p17170
aS'  } // namespace EquationData'
p17171
aS'  template <int dim>'
p17172
aS'  class NavierStokesProjection'
p17173
aS'  {'
p17174
aS'  public:'
p17175
aS'    NavierStokesProjection(const RunTimeParameters::Data_Storage &data);'
p17176
aS'    void run(const bool verbose = false, const unsigned int n_plots = 10);'
p17177
aS'  protected:'
p17178
aS'    RunTimeParameters::Method type;'
p17179
aS'    const unsigned int deg;'
p17180
aS'    const double       dt;'
p17181
aS'    const double       t_0;'
p17182
aS'    const double       T;'
p17183
aS'    const double       Re;'
p17184
aS'    EquationData::Velocity<dim>               vel_exact;'
p17185
aS'    std::map<types::global_dof_index, double> boundary_values;'
p17186
aS'    std::vector<types::boundary_id>           boundary_ids;'
p17187
aS'    Triangulation<dim> triangulation;'
p17188
aS'    FE_Q<dim> fe_velocity;'
p17189
aS'    FE_Q<dim> fe_pressure;'
p17190
aS'    DoFHandler<dim> dof_handler_velocity;'
p17191
aS'    DoFHandler<dim> dof_handler_pressure;'
p17192
aS'    QGauss<dim> quadrature_pressure;'
p17193
aS'    QGauss<dim> quadrature_velocity;'
p17194
aS'    SparsityPattern sparsity_pattern_velocity;'
p17195
aS'    SparsityPattern sparsity_pattern_pressure;'
p17196
aS'    SparsityPattern sparsity_pattern_pres_vel;'
p17197
aS'    SparseMatrix<double> vel_Laplace_plus_Mass;'
p17198
aS'    SparseMatrix<double> vel_it_matrix[dim];'
p17199
aS'    SparseMatrix<double> vel_Mass;'
p17200
aS'    SparseMatrix<double> vel_Laplace;'
p17201
aS'    SparseMatrix<double> vel_Advection;'
p17202
aS'    SparseMatrix<double> pres_Laplace;'
p17203
aS'    SparseMatrix<double> pres_Mass;'
p17204
aS'    SparseMatrix<double> pres_Diff[dim];'
p17205
aS'    SparseMatrix<double> pres_iterative;'
p17206
aS'    Vector<double> pres_n;'
p17207
aS'    Vector<double> pres_n_minus_1;'
p17208
aS'    Vector<double> phi_n;'
p17209
aS'    Vector<double> phi_n_minus_1;'
p17210
aS'    Vector<double> u_n[dim];'
p17211
aS'    Vector<double> u_n_minus_1[dim];'
p17212
aS'    Vector<double> u_star[dim];'
p17213
aS'    Vector<double> force[dim];'
p17214
aS'    Vector<double> v_tmp;'
p17215
aS'    Vector<double> pres_tmp;'
p17216
aS'    Vector<double> rot_u;'
p17217
aS'    SparseILU<double>   prec_velocity[dim];'
p17218
aS'    SparseILU<double>   prec_pres_Laplace;'
p17219
aS'    SparseDirectUMFPACK prec_mass;'
p17220
aS'    SparseDirectUMFPACK prec_vel_mass;'
p17221
aS'    DeclException2(ExcInvalidTimeStep,'
p17222
aS'                   double,'
p17223
aS'                   double,'
p17224
aS'                   << " The time step " << arg1 << " is out of range."'
p17225
aS'                   << std::endl'
p17226
aS'                   << " The permitted range is (0," << arg2 << "]");'
p17227
aS'    void create_triangulation_and_dofs(const unsigned int n_refines);'
p17228
aS'    void initialize();'
p17229
aS'    void interpolate_velocity();'
p17230
aS'    void diffusion_step(const bool reinit_prec);'
p17231
aS'    void projection_step(const bool reinit_prec);'
p17232
aS'    void update_pressure(const bool reinit_prec);'
p17233
aS'  private:'
p17234
aS'    unsigned int vel_max_its;'
p17235
aS'    unsigned int vel_Krylov_size;'
p17236
aS'    unsigned int vel_off_diagonals;'
p17237
aS'    unsigned int vel_update_prec;'
p17238
aS'    double       vel_eps;'
p17239
aS'    double       vel_diag_strength;'
p17240
aS'    void initialize_velocity_matrices();'
p17241
aS'    void initialize_pressure_matrices();'
p17242
aS'    using IteratorTuple ='
p17243
aS'      std::tuple<typename DoFHandler<dim>::active_cell_iterator,'
p17244
aS'                 typename DoFHandler<dim>::active_cell_iterator>;'
p17245
aS'    using IteratorPair = SynchronousIterators<IteratorTuple>;'
p17246
aS'    void initialize_gradient_operator();'
p17247
aS'    struct InitGradPerTaskData'
p17248
aS'    {'
p17249
aS'      unsigned int                         d;'
p17250
aS'      unsigned int                         vel_dpc;'
p17251
aS'      unsigned int                         pres_dpc;'
p17252
aS'      FullMatrix<double>                   local_grad;'
p17253
aS'      std::vector<types::global_dof_index> vel_local_dof_indices;'
p17254
aS'      std::vector<types::global_dof_index> pres_local_dof_indices;'
p17255
aS'      InitGradPerTaskData(const unsigned int dd,'
p17256
aS'                          const unsigned int vdpc,'
p17257
aS'                          const unsigned int pdpc)'
p17258
aS'        : d(dd)'
p17259
aS'        , vel_dpc(vdpc)'
p17260
aS'        , pres_dpc(pdpc)'
p17261
aS'        , local_grad(vdpc, pdpc)'
p17262
aS'        , vel_local_dof_indices(vdpc)'
p17263
aS'        , pres_local_dof_indices(pdpc)'
p17264
aS'      {}'
p17265
aS'    };'
p17266
aS'    struct InitGradScratchData'
p17267
aS'    {'
p17268
aS'      unsigned int  nqp;'
p17269
aS'      FEValues<dim> fe_val_vel;'
p17270
aS'      FEValues<dim> fe_val_pres;'
p17271
aS'      InitGradScratchData(const FE_Q<dim> &  fe_v,'
p17272
aS'                          const FE_Q<dim> &  fe_p,'
p17273
aS'                          const QGauss<dim> &quad,'
p17274
aS'                          const UpdateFlags  flags_v,'
p17275
aS'                          const UpdateFlags  flags_p)'
p17276
aS'        : nqp(quad.size())'
p17277
aS'        , fe_val_vel(fe_v, quad, flags_v)'
p17278
aS'        , fe_val_pres(fe_p, quad, flags_p)'
p17279
aS'      {}'
p17280
aS'      InitGradScratchData(const InitGradScratchData &data)'
p17281
aS'        : nqp(data.nqp)'
p17282
aS'        , fe_val_vel(data.fe_val_vel.get_fe(),'
p17283
aS'                     data.fe_val_vel.get_quadrature(),'
p17284
aS'                     data.fe_val_vel.get_update_flags())'
p17285
aS'        , fe_val_pres(data.fe_val_pres.get_fe(),'
p17286
aS'                      data.fe_val_pres.get_quadrature(),'
p17287
aS'                      data.fe_val_pres.get_update_flags())'
p17288
aS'      {}'
p17289
aS'    };'
p17290
aS'    void assemble_one_cell_of_gradient(const IteratorPair & SI,'
p17291
aS'                                       InitGradScratchData &scratch,'
p17292
aS'                                       InitGradPerTaskData &data);'
p17293
aS'    void copy_gradient_local_to_global(const InitGradPerTaskData &data);'
p17294
aS'    void assemble_advection_term();'
p17295
aS'    struct AdvectionPerTaskData'
p17296
aS'    {'
p17297
aS'      FullMatrix<double>                   local_advection;'
p17298
aS'      std::vector<types::global_dof_index> local_dof_indices;'
p17299
aS'      AdvectionPerTaskData(const unsigned int dpc)'
p17300
aS'        : local_advection(dpc, dpc)'
p17301
aS'        , local_dof_indices(dpc)'
p17302
aS'      {}'
p17303
aS'    };'
p17304
aS'    struct AdvectionScratchData'
p17305
aS'    {'
p17306
aS'      unsigned int                nqp;'
p17307
aS'      unsigned int                dpc;'
p17308
aS'      std::vector<Point<dim>>     u_star_local;'
p17309
aS'      std::vector<Tensor<1, dim>> grad_u_star;'
p17310
aS'      std::vector<double>         u_star_tmp;'
p17311
aS'      FEValues<dim>               fe_val;'
p17312
aS'      AdvectionScratchData(const FE_Q<dim> &  fe,'
p17313
aS'                           const QGauss<dim> &quad,'
p17314
aS'                           const UpdateFlags  flags)'
p17315
aS'        : nqp(quad.size())'
p17316
aS'        , dpc(fe.n_dofs_per_cell())'
p17317
aS'        , u_star_local(nqp)'
p17318
aS'        , grad_u_star(nqp)'
p17319
aS'        , u_star_tmp(nqp)'
p17320
aS'        , fe_val(fe, quad, flags)'
p17321
aS'      {}'
p17322
aS'      AdvectionScratchData(const AdvectionScratchData &data)'
p17323
aS'        : nqp(data.nqp)'
p17324
aS'        , dpc(data.dpc)'
p17325
aS'        , u_star_local(nqp)'
p17326
aS'        , grad_u_star(nqp)'
p17327
aS'        , u_star_tmp(nqp)'
p17328
aS'        , fe_val(data.fe_val.get_fe(),'
p17329
aS'                 data.fe_val.get_quadrature(),'
p17330
aS'                 data.fe_val.get_update_flags())'
p17331
aS'      {}'
p17332
aS'    };'
p17333
aS'    void assemble_one_cell_of_advection('
p17334
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p17335
aS'      AdvectionScratchData &                                scratch,'
p17336
aS'      AdvectionPerTaskData &                                data);'
p17337
aS'    void copy_advection_local_to_global(const AdvectionPerTaskData &data);'
p17338
aS'    void diffusion_component_solve(const unsigned int d);'
p17339
aS'    void output_results(const unsigned int step);'
p17340
aS'    void assemble_vorticity(const bool reinit_prec);'
p17341
aS'  };'
p17342
aS'  template <int dim>'
p17343
aS'  NavierStokesProjection<dim>::NavierStokesProjection('
p17344
aS'    const RunTimeParameters::Data_Storage &data)'
p17345
aS'    : type(data.form)'
p17346
aS'    , deg(data.pressure_degree)'
p17347
aS'    , dt(data.dt)'
p17348
aS'    , t_0(data.initial_time)'
p17349
aS'    , T(data.final_time)'
p17350
aS'    , Re(data.Reynolds)'
p17351
aS'    , vel_exact(data.initial_time)'
p17352
aS'    , fe_velocity(deg + 1)'
p17353
aS'    , fe_pressure(deg)'
p17354
aS'    , dof_handler_velocity(triangulation)'
p17355
aS'    , dof_handler_pressure(triangulation)'
p17356
aS'    , quadrature_pressure(deg + 1)'
p17357
aS'    , quadrature_velocity(deg + 2)'
p17358
aS'    , vel_max_its(data.vel_max_iterations)'
p17359
aS'    , vel_Krylov_size(data.vel_Krylov_size)'
p17360
aS'    , vel_off_diagonals(data.vel_off_diagonals)'
p17361
aS'    , vel_update_prec(data.vel_update_prec)'
p17362
aS'    , vel_eps(data.vel_eps)'
p17363
aS'    , vel_diag_strength(data.vel_diag_strength)'
p17364
aS'  {'
p17365
aS'    if (deg < 1)'
p17366
aS'      std::cout'
p17367
aS'        << " WARNING: The chosen pair of finite element spaces is not stable."'
p17368
aS'        << std::endl'
p17369
aS'        << " The obtained results will be nonsense" << std::endl;'
p17370
aS'    AssertThrow(!((dt <= 0.) || (dt > .5 * T)), ExcInvalidTimeStep(dt, .5 * T));'
p17371
aS'    create_triangulation_and_dofs(data.n_global_refines);'
p17372
aS'    initialize();'
p17373
aS'  }'
p17374
aS'  template <int dim>'
p17375
aS'  void NavierStokesProjection<dim>::create_triangulation_and_dofs('
p17376
aS'    const unsigned int n_refines)'
p17377
aS'  {'
p17378
aS'    GridIn<dim> grid_in;'
p17379
aS'    grid_in.attach_triangulation(triangulation);'
p17380
aS'    {'
p17381
aS'      std::string   filename = "nsbench2.inp";'
p17382
aS'      std::ifstream file(filename);'
p17383
aS'      Assert(file, ExcFileNotOpen(filename.c_str()));'
p17384
aS'      grid_in.read_ucd(file);'
p17385
aS'    }'
p17386
aS'    std::cout << "Number of refines = " << n_refines << std::endl;'
p17387
aS'    triangulation.refine_global(n_refines);'
p17388
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p17389
aS'              << std::endl;'
p17390
aS'    boundary_ids = triangulation.get_boundary_ids();'
p17391
aS'    dof_handler_velocity.distribute_dofs(fe_velocity);'
p17392
aS'    DoFRenumbering::boost::Cuthill_McKee(dof_handler_velocity);'
p17393
aS'    dof_handler_pressure.distribute_dofs(fe_pressure);'
p17394
aS'    DoFRenumbering::boost::Cuthill_McKee(dof_handler_pressure);'
p17395
aS'    initialize_velocity_matrices();'
p17396
aS'    initialize_pressure_matrices();'
p17397
aS'    initialize_gradient_operator();'
p17398
aS'    pres_n.reinit(dof_handler_pressure.n_dofs());'
p17399
aS'    pres_n_minus_1.reinit(dof_handler_pressure.n_dofs());'
p17400
aS'    phi_n.reinit(dof_handler_pressure.n_dofs());'
p17401
aS'    phi_n_minus_1.reinit(dof_handler_pressure.n_dofs());'
p17402
aS'    pres_tmp.reinit(dof_handler_pressure.n_dofs());'
p17403
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17404
aS'      {'
p17405
aS'        u_n[d].reinit(dof_handler_velocity.n_dofs());'
p17406
aS'        u_n_minus_1[d].reinit(dof_handler_velocity.n_dofs());'
p17407
aS'        u_star[d].reinit(dof_handler_velocity.n_dofs());'
p17408
aS'        force[d].reinit(dof_handler_velocity.n_dofs());'
p17409
aS'      }'
p17410
aS'    v_tmp.reinit(dof_handler_velocity.n_dofs());'
p17411
aS'    rot_u.reinit(dof_handler_velocity.n_dofs());'
p17412
aS'    std::cout << "dim (X_h) = " << (dof_handler_velocity.n_dofs() * dim) //'
p17413
aS'              << std::endl                                               //'
p17414
aS'              << "dim (M_h) = " << dof_handler_pressure.n_dofs()         //'
p17415
aS'              << std::endl                                               //'
p17416
aS'              << "Re        = " << Re << std::endl                       //'
p17417
aS'              << std::endl;'
p17418
aS'  }'
p17419
aS'  template <int dim>'
p17420
aS'  void NavierStokesProjection<dim>::initialize()'
p17421
aS'  {'
p17422
aS'    vel_Laplace_plus_Mass = 0.;'
p17423
aS'    vel_Laplace_plus_Mass.add(1. / Re, vel_Laplace);'
p17424
aS'    vel_Laplace_plus_Mass.add(1.5 / dt, vel_Mass);'
p17425
aS'    EquationData::Pressure<dim> pres(t_0);'
p17426
aS'    VectorTools::interpolate(dof_handler_pressure, pres, pres_n_minus_1);'
p17427
aS'    pres.advance_time(dt);'
p17428
aS'    VectorTools::interpolate(dof_handler_pressure, pres, pres_n);'
p17429
aS'    phi_n         = 0.;'
p17430
aS'    phi_n_minus_1 = 0.;'
p17431
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17432
aS'      {'
p17433
aS'        vel_exact.set_time(t_0);'
p17434
aS'        vel_exact.set_component(d);'
p17435
aS'        VectorTools::interpolate(dof_handler_velocity,'
p17436
aS'                                 vel_exact,'
p17437
aS'                                 u_n_minus_1[d]);'
p17438
aS'        vel_exact.advance_time(dt);'
p17439
aS'        VectorTools::interpolate(dof_handler_velocity, vel_exact, u_n[d]);'
p17440
aS'      }'
p17441
aS'  }'
p17442
aS'  template <int dim>'
p17443
aS'  void NavierStokesProjection<dim>::initialize_velocity_matrices()'
p17444
aS'  {'
p17445
aS'    {'
p17446
aS'      DynamicSparsityPattern dsp(dof_handler_velocity.n_dofs(),'
p17447
aS'                                 dof_handler_velocity.n_dofs());'
p17448
aS'      DoFTools::make_sparsity_pattern(dof_handler_velocity, dsp);'
p17449
aS'      sparsity_pattern_velocity.copy_from(dsp);'
p17450
aS'    }'
p17451
aS'    vel_Laplace_plus_Mass.reinit(sparsity_pattern_velocity);'
p17452
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17453
aS'      vel_it_matrix[d].reinit(sparsity_pattern_velocity);'
p17454
aS'    vel_Mass.reinit(sparsity_pattern_velocity);'
p17455
aS'    vel_Laplace.reinit(sparsity_pattern_velocity);'
p17456
aS'    vel_Advection.reinit(sparsity_pattern_velocity);'
p17457
aS'    MatrixCreator::create_mass_matrix(dof_handler_velocity,'
p17458
aS'                                      quadrature_velocity,'
p17459
aS'                                      vel_Mass);'
p17460
aS'    MatrixCreator::create_laplace_matrix(dof_handler_velocity,'
p17461
aS'                                         quadrature_velocity,'
p17462
aS'                                         vel_Laplace);'
p17463
aS'  }'
p17464
aS'  template <int dim>'
p17465
aS'  void NavierStokesProjection<dim>::initialize_pressure_matrices()'
p17466
aS'  {'
p17467
aS'    {'
p17468
aS'      DynamicSparsityPattern dsp(dof_handler_pressure.n_dofs(),'
p17469
aS'                                 dof_handler_pressure.n_dofs());'
p17470
aS'      DoFTools::make_sparsity_pattern(dof_handler_pressure, dsp);'
p17471
aS'      sparsity_pattern_pressure.copy_from(dsp);'
p17472
aS'    }'
p17473
aS'    pres_Laplace.reinit(sparsity_pattern_pressure);'
p17474
aS'    pres_iterative.reinit(sparsity_pattern_pressure);'
p17475
aS'    pres_Mass.reinit(sparsity_pattern_pressure);'
p17476
aS'    MatrixCreator::create_laplace_matrix(dof_handler_pressure,'
p17477
aS'                                         quadrature_pressure,'
p17478
aS'                                         pres_Laplace);'
p17479
aS'    MatrixCreator::create_mass_matrix(dof_handler_pressure,'
p17480
aS'                                      quadrature_pressure,'
p17481
aS'                                      pres_Mass);'
p17482
aS'  }'
p17483
aS'  template <int dim>'
p17484
aS'  void NavierStokesProjection<dim>::initialize_gradient_operator()'
p17485
aS'  {'
p17486
aS'    {'
p17487
aS'      DynamicSparsityPattern dsp(dof_handler_velocity.n_dofs(),'
p17488
aS'                                 dof_handler_pressure.n_dofs());'
p17489
aS'      DoFTools::make_sparsity_pattern(dof_handler_velocity,'
p17490
aS'                                      dof_handler_pressure,'
p17491
aS'                                      dsp);'
p17492
aS'      sparsity_pattern_pres_vel.copy_from(dsp);'
p17493
aS'    }'
p17494
aS'    InitGradPerTaskData per_task_data(0,'
p17495
aS'                                      fe_velocity.n_dofs_per_cell(),'
p17496
aS'                                      fe_pressure.n_dofs_per_cell());'
p17497
aS'    InitGradScratchData scratch_data(fe_velocity,'
p17498
aS'                                     fe_pressure,'
p17499
aS'                                     quadrature_velocity,'
p17500
aS'                                     update_gradients | update_JxW_values,'
p17501
aS'                                     update_values);'
p17502
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17503
aS'      {'
p17504
aS'        pres_Diff[d].reinit(sparsity_pattern_pres_vel);'
p17505
aS'        per_task_data.d = d;'
p17506
aS'        WorkStream::run('
p17507
aS'          IteratorPair(IteratorTuple(dof_handler_velocity.begin_active(),'
p17508
aS'                                     dof_handler_pressure.begin_active())),'
p17509
aS'          IteratorPair(IteratorTuple(dof_handler_velocity.end(),'
p17510
aS'                                     dof_handler_pressure.end())),'
p17511
aS'          *this,'
p17512
aS'          &NavierStokesProjection<dim>::assemble_one_cell_of_gradient,'
p17513
aS'          &NavierStokesProjection<dim>::copy_gradient_local_to_global,'
p17514
aS'          scratch_data,'
p17515
aS'          per_task_data);'
p17516
aS'      }'
p17517
aS'  }'
p17518
aS'  template <int dim>'
p17519
aS'  void NavierStokesProjection<dim>::assemble_one_cell_of_gradient('
p17520
aS'    const IteratorPair & SI,'
p17521
aS'    InitGradScratchData &scratch,'
p17522
aS'    InitGradPerTaskData &data)'
p17523
aS'  {'
p17524
aS'    scratch.fe_val_vel.reinit(std::get<0>(*SI));'
p17525
aS'    scratch.fe_val_pres.reinit(std::get<1>(*SI));'
p17526
aS'    std::get<0>(*SI)->get_dof_indices(data.vel_local_dof_indices);'
p17527
aS'    std::get<1>(*SI)->get_dof_indices(data.pres_local_dof_indices);'
p17528
aS'    data.local_grad = 0.;'
p17529
aS'    for (unsigned int q = 0; q < scratch.nqp; ++q)'
p17530
aS'      {'
p17531
aS'        for (unsigned int i = 0; i < data.vel_dpc; ++i)'
p17532
aS'          for (unsigned int j = 0; j < data.pres_dpc; ++j)'
p17533
aS'            data.local_grad(i, j) +='
p17534
aS'              -scratch.fe_val_vel.JxW(q) *'
p17535
aS'              scratch.fe_val_vel.shape_grad(i, q)[data.d] *'
p17536
aS'              scratch.fe_val_pres.shape_value(j, q);'
p17537
aS'      }'
p17538
aS'  }'
p17539
aS'  template <int dim>'
p17540
aS'  void NavierStokesProjection<dim>::copy_gradient_local_to_global('
p17541
aS'    const InitGradPerTaskData &data)'
p17542
aS'  {'
p17543
aS'    for (unsigned int i = 0; i < data.vel_dpc; ++i)'
p17544
aS'      for (unsigned int j = 0; j < data.pres_dpc; ++j)'
p17545
aS'        pres_Diff[data.d].add(data.vel_local_dof_indices[i],'
p17546
aS'                              data.pres_local_dof_indices[j],'
p17547
aS'                              data.local_grad(i, j));'
p17548
aS'  }'
p17549
aS'  template <int dim>'
p17550
aS'  void NavierStokesProjection<dim>::run(const bool         verbose,'
p17551
aS'                                        const unsigned int output_interval)'
p17552
aS'  {'
p17553
aS'    ConditionalOStream verbose_cout(std::cout, verbose);'
p17554
aS'    const auto n_steps = static_cast<unsigned int>((T - t_0) / dt);'
p17555
aS'    vel_exact.set_time(2. * dt);'
p17556
aS'    output_results(1);'
p17557
aS'    for (unsigned int n = 2; n <= n_steps; ++n)'
p17558
aS'      {'
p17559
aS'        if (n % output_interval == 0)'
p17560
aS'          {'
p17561
aS'            verbose_cout << "Plotting Solution" << std::endl;'
p17562
aS'            output_results(n);'
p17563
aS'          }'
p17564
aS'        std::cout << "Step = " << n << " Time = " << (n * dt) << std::endl;'
p17565
aS'        verbose_cout << "  Interpolating the velocity " << std::endl;'
p17566
aS'        interpolate_velocity();'
p17567
aS'        verbose_cout << "  Diffusion Step" << std::endl;'
p17568
aS'        if (n % vel_update_prec == 0)'
p17569
aS'          verbose_cout << "    With reinitialization of the preconditioner"'
p17570
aS'                       << std::endl;'
p17571
aS'        diffusion_step((n % vel_update_prec == 0) || (n == 2));'
p17572
aS'        verbose_cout << "  Projection Step" << std::endl;'
p17573
aS'        projection_step((n == 2));'
p17574
aS'        verbose_cout << "  Updating the Pressure" << std::endl;'
p17575
aS'        update_pressure((n == 2));'
p17576
aS'        vel_exact.advance_time(dt);'
p17577
aS'      }'
p17578
aS'    output_results(n_steps);'
p17579
aS'  }'
p17580
aS'  template <int dim>'
p17581
aS'  void NavierStokesProjection<dim>::interpolate_velocity()'
p17582
aS'  {'
p17583
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17584
aS'      {'
p17585
aS'        u_star[d].equ(2., u_n[d]);'
p17586
aS'        u_star[d] -= u_n_minus_1[d];'
p17587
aS'      }'
p17588
aS'  }'
p17589
aS'  template <int dim>'
p17590
aS'  void NavierStokesProjection<dim>::diffusion_step(const bool reinit_prec)'
p17591
aS'  {'
p17592
aS'    pres_tmp.equ(-1., pres_n);'
p17593
aS'    pres_tmp.add(-4. / 3., phi_n, 1. / 3., phi_n_minus_1);'
p17594
aS'    assemble_advection_term();'
p17595
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17596
aS'      {'
p17597
aS'        force[d] = 0.;'
p17598
aS'        v_tmp.equ(2. / dt, u_n[d]);'
p17599
aS'        v_tmp.add(-.5 / dt, u_n_minus_1[d]);'
p17600
aS'        vel_Mass.vmult_add(force[d], v_tmp);'
p17601
aS'        pres_Diff[d].vmult_add(force[d], pres_tmp);'
p17602
aS'        u_n_minus_1[d] = u_n[d];'
p17603
aS'        vel_it_matrix[d].copy_from(vel_Laplace_plus_Mass);'
p17604
aS'        vel_it_matrix[d].add(1., vel_Advection);'
p17605
aS'        vel_exact.set_component(d);'
p17606
aS'        boundary_values.clear();'
p17607
aS'        for (const auto &boundary_id : boundary_ids)'
p17608
aS'          {'
p17609
aS'            switch (boundary_id)'
p17610
aS'              {'
p17611
aS'                case 1:'
p17612
aS'                  VectorTools::interpolate_boundary_values('
p17613
aS'                    dof_handler_velocity,'
p17614
aS'                    boundary_id,'
p17615
aS'                    Functions::ZeroFunction<dim>(),'
p17616
aS'                    boundary_values);'
p17617
aS'                  break;'
p17618
aS'                case 2:'
p17619
aS'                  VectorTools::interpolate_boundary_values(dof_handler_velocity,'
p17620
aS'                                                           boundary_id,'
p17621
aS'                                                           vel_exact,'
p17622
aS'                                                           boundary_values);'
p17623
aS'                  break;'
p17624
aS'                case 3:'
p17625
aS'                  if (d != 0)'
p17626
aS'                    VectorTools::interpolate_boundary_values('
p17627
aS'                      dof_handler_velocity,'
p17628
aS'                      boundary_id,'
p17629
aS'                      Functions::ZeroFunction<dim>(),'
p17630
aS'                      boundary_values);'
p17631
aS'                  break;'
p17632
aS'                case 4:'
p17633
aS'                  VectorTools::interpolate_boundary_values('
p17634
aS'                    dof_handler_velocity,'
p17635
aS'                    boundary_id,'
p17636
aS'                    Functions::ZeroFunction<dim>(),'
p17637
aS'                    boundary_values);'
p17638
aS'                  break;'
p17639
aS'                default:'
p17640
aS'                  Assert(false, ExcNotImplemented());'
p17641
aS'              }'
p17642
aS'          }'
p17643
aS'        MatrixTools::apply_boundary_values(boundary_values,'
p17644
aS'                                           vel_it_matrix[d],'
p17645
aS'                                           u_n[d],'
p17646
aS'                                           force[d]);'
p17647
aS'      }'
p17648
aS'    Threads::TaskGroup<void> tasks;'
p17649
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17650
aS'      {'
p17651
aS'        if (reinit_prec)'
p17652
aS'          prec_velocity[d].initialize(vel_it_matrix[d],'
p17653
aS'                                      SparseILU<double>::AdditionalData('
p17654
aS'                                        vel_diag_strength, vel_off_diagonals));'
p17655
aS'        tasks += Threads::new_task('
p17656
aS'          &NavierStokesProjection<dim>::diffusion_component_solve, *this, d);'
p17657
aS'      }'
p17658
aS'    tasks.join_all();'
p17659
aS'  }'
p17660
aS'  template <int dim>'
p17661
aS'  void'
p17662
aS'  NavierStokesProjection<dim>::diffusion_component_solve(const unsigned int d)'
p17663
aS'  {'
p17664
aS'    SolverControl solver_control(vel_max_its, vel_eps * force[d].l2_norm());'
p17665
aS'    SolverGMRES<Vector<double>> gmres('
p17666
aS'      solver_control,'
p17667
aS'      SolverGMRES<Vector<double>>::AdditionalData(vel_Krylov_size));'
p17668
aS'    gmres.solve(vel_it_matrix[d], u_n[d], force[d], prec_velocity[d]);'
p17669
aS'  }'
p17670
aS'  template <int dim>'
p17671
aS'  void NavierStokesProjection<dim>::assemble_advection_term()'
p17672
aS'  {'
p17673
aS'    vel_Advection = 0.;'
p17674
aS'    AdvectionPerTaskData data(fe_velocity.n_dofs_per_cell());'
p17675
aS'    AdvectionScratchData scratch(fe_velocity,'
p17676
aS'                                 quadrature_velocity,'
p17677
aS'                                 update_values | update_JxW_values |'
p17678
aS'                                   update_gradients);'
p17679
aS'    WorkStream::run('
p17680
aS'      dof_handler_velocity.begin_active(),'
p17681
aS'      dof_handler_velocity.end(),'
p17682
aS'      *this,'
p17683
aS'      &NavierStokesProjection<dim>::assemble_one_cell_of_advection,'
p17684
aS'      &NavierStokesProjection<dim>::copy_advection_local_to_global,'
p17685
aS'      scratch,'
p17686
aS'      data);'
p17687
aS'  }'
p17688
aS'  template <int dim>'
p17689
aS'  void NavierStokesProjection<dim>::assemble_one_cell_of_advection('
p17690
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p17691
aS'    AdvectionScratchData &                                scratch,'
p17692
aS'    AdvectionPerTaskData &                                data)'
p17693
aS'  {'
p17694
aS'    scratch.fe_val.reinit(cell);'
p17695
aS'    cell->get_dof_indices(data.local_dof_indices);'
p17696
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17697
aS'      {'
p17698
aS'        scratch.fe_val.get_function_values(u_star[d], scratch.u_star_tmp);'
p17699
aS'        for (unsigned int q = 0; q < scratch.nqp; ++q)'
p17700
aS'          scratch.u_star_local[q](d) = scratch.u_star_tmp[q];'
p17701
aS'      }'
p17702
aS'    for (unsigned int d = 0; d < dim; ++d)'
p17703
aS'      {'
p17704
aS'        scratch.fe_val.get_function_gradients(u_star[d], scratch.grad_u_star);'
p17705
aS'        for (unsigned int q = 0; q < scratch.nqp; ++q)'
p17706
aS'          {'
p17707
aS'            if (d == 0)'
p17708
aS'              scratch.u_star_tmp[q] = 0.;'
p17709
aS'            scratch.u_star_tmp[q] += scratch.grad_u_star[q][d];'
p17710
aS'          }'
p17711
aS'      }'
p17712
aS'    data.local_advection = 0.;'
p17713
aS'    for (unsigned int q = 0; q < scratch.nqp; ++q)'
p17714
aS'      for (unsigned int i = 0; i < scratch.dpc; ++i)'
p17715
aS'        for (unsigned int j = 0; j < scratch.dpc; ++j)'
p17716
aS'          data.local_advection(i, j) += (scratch.u_star_local[q] *            //'
p17717
aS'                                           scratch.fe_val.shape_grad(j, q) *  //'
p17718
aS'                                           scratch.fe_val.shape_value(i, q)   //'
p17719
aS'                                         +                                    //'
p17720
aS'                                         0.5 *                                //'
p17721
aS'                                           scratch.u_star_tmp[q] *            //'
p17722
aS'                                           scratch.fe_val.shape_value(i, q) * //'
p17723
aS'                                           scratch.fe_val.shape_value(j, q))  //'
p17724
aS'                                        * scratch.fe_val.JxW(q);'
p17725
aS'  }'
p17726
aS'  template <int dim>'
p17727
aS'  void NavierStokesProjection<dim>::copy_advection_local_to_global('
p17728
aS'    const AdvectionPerTaskData &data)'
p17729
aS'  {'
p17730
aS'    for (unsigned int i = 0; i < fe_velocity.n_dofs_per_cell(); ++i)'
p17731
aS'      for (unsigned int j = 0; j < fe_velocity.n_dofs_per_cell(); ++j)'
p17732
aS'        vel_Advection.add(data.local_dof_indices[i],'
p17733
aS'                          data.local_dof_indices[j],'
p17734
aS'                          data.local_advection(i, j));'
p17735
aS'  }'
p17736
aS'  template <int dim>'
p17737
aS'  void NavierStokesProjection<dim>::projection_step(const bool reinit_prec)'
p17738
aS'  {'
p17739
aS'    pres_iterative.copy_from(pres_Laplace);'
p17740
aS'    pres_tmp = 0.;'
p17741
aS'    for (unsigned d = 0; d < dim; ++d)'
p17742
aS'      pres_Diff[d].Tvmult_add(pres_tmp, u_n[d]);'
p17743
aS'    phi_n_minus_1 = phi_n;'
p17744
aS'    static std::map<types::global_dof_index, double> bval;'
p17745
aS'    if (reinit_prec)'
p17746
aS'      VectorTools::interpolate_boundary_values(dof_handler_pressure,'
p17747
aS'                                               3,'
p17748
aS'                                               Functions::ZeroFunction<dim>(),'
p17749
aS'                                               bval);'
p17750
aS'    MatrixTools::apply_boundary_values(bval, pres_iterative, phi_n, pres_tmp);'
p17751
aS'    if (reinit_prec)'
p17752
aS'      prec_pres_Laplace.initialize(pres_iterative,'
p17753
aS'                                   SparseILU<double>::AdditionalData('
p17754
aS'                                     vel_diag_strength, vel_off_diagonals));'
p17755
aS'    SolverControl solvercontrol(vel_max_its, vel_eps * pres_tmp.l2_norm());'
p17756
aS'    SolverCG<Vector<double>> cg(solvercontrol);'
p17757
aS'    cg.solve(pres_iterative, phi_n, pres_tmp, prec_pres_Laplace);'
p17758
aS'    phi_n *= 1.5 / dt;'
p17759
aS'  }'
p17760
aS'  template <int dim>'
p17761
aS'  void NavierStokesProjection<dim>::update_pressure(const bool reinit_prec)'
p17762
aS'  {'
p17763
aS'    pres_n_minus_1 = pres_n;'
p17764
aS'    switch (type)'
p17765
aS'      {'
p17766
aS'        case RunTimeParameters::Method::standard:'
p17767
aS'          pres_n += phi_n;'
p17768
aS'          break;'
p17769
aS'        case RunTimeParameters::Method::rotational:'
p17770
aS'          if (reinit_prec)'
p17771
aS'            prec_mass.initialize(pres_Mass);'
p17772
aS'          pres_n = pres_tmp;'
p17773
aS'          prec_mass.solve(pres_n);'
p17774
aS'          pres_n.sadd(1. / Re, 1., pres_n_minus_1);'
p17775
aS'          pres_n += phi_n;'
p17776
aS'          break;'
p17777
aS'        default:'
p17778
aS'          Assert(false, ExcNotImplemented());'
p17779
aS'      };'
p17780
aS'  }'
p17781
aS'  template <int dim>'
p17782
aS'  void NavierStokesProjection<dim>::output_results(const unsigned int step)'
p17783
aS'  {'
p17784
aS'    assemble_vorticity((step == 1));'
p17785
aS'    const FESystem<dim> joint_fe('
p17786
aS'      fe_velocity, dim, fe_pressure, 1, fe_velocity, 1);'
p17787
aS'    DoFHandler<dim> joint_dof_handler(triangulation);'
p17788
aS'    joint_dof_handler.distribute_dofs(joint_fe);'
p17789
aS'    Assert(joint_dof_handler.n_dofs() =='
p17790
aS'             ((dim + 1) * dof_handler_velocity.n_dofs() +'
p17791
aS'              dof_handler_pressure.n_dofs()),'
p17792
aS'           ExcInternalError());'
p17793
aS'    Vector<double> joint_solution(joint_dof_handler.n_dofs());'
p17794
aS'    std::vector<types::global_dof_index> loc_joint_dof_indices('
p17795
aS'      joint_fe.n_dofs_per_cell()),'
p17796
aS'      loc_vel_dof_indices(fe_velocity.n_dofs_per_cell()),'
p17797
aS'      loc_pres_dof_indices(fe_pressure.n_dofs_per_cell());'
p17798
aS'    typename DoFHandler<dim>::active_cell_iterator'
p17799
aS'      joint_cell = joint_dof_handler.begin_active(),'
p17800
aS'      joint_endc = joint_dof_handler.end(),'
p17801
aS'      vel_cell   = dof_handler_velocity.begin_active(),'
p17802
aS'      pres_cell  = dof_handler_pressure.begin_active();'
p17803
aS'    for (; joint_cell != joint_endc; ++joint_cell, ++vel_cell, ++pres_cell)'
p17804
aS'      {'
p17805
aS'        joint_cell->get_dof_indices(loc_joint_dof_indices);'
p17806
aS'        vel_cell->get_dof_indices(loc_vel_dof_indices);'
p17807
aS'        pres_cell->get_dof_indices(loc_pres_dof_indices);'
p17808
aS'        for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)'
p17809
aS'          switch (joint_fe.system_to_base_index(i).first.first)'
p17810
aS'            {'
p17811
aS'              case 0:'
p17812
aS'                Assert(joint_fe.system_to_base_index(i).first.second < dim,'
p17813
aS'                       ExcInternalError());'
p17814
aS'                joint_solution(loc_joint_dof_indices[i]) ='
p17815
aS'                  u_n[joint_fe.system_to_base_index(i).first.second]('
p17816
aS'                    loc_vel_dof_indices[joint_fe.system_to_base_index(i)'
p17817
aS'                                          .second]);'
p17818
aS'                break;'
p17819
aS'              case 1:'
p17820
aS'                Assert(joint_fe.system_to_base_index(i).first.second == 0,'
p17821
aS'                       ExcInternalError());'
p17822
aS'                joint_solution(loc_joint_dof_indices[i]) ='
p17823
aS'                  pres_n(loc_pres_dof_indices[joint_fe.system_to_base_index(i)'
p17824
aS'                                                .second]);'
p17825
aS'                break;'
p17826
aS'              case 2:'
p17827
aS'                Assert(joint_fe.system_to_base_index(i).first.second == 0,'
p17828
aS'                       ExcInternalError());'
p17829
aS'                joint_solution(loc_joint_dof_indices[i]) = rot_u('
p17830
aS'                  loc_vel_dof_indices[joint_fe.system_to_base_index(i).second]);'
p17831
aS'                break;'
p17832
aS'              default:'
p17833
aS'                Assert(false, ExcInternalError());'
p17834
aS'            }'
p17835
aS'      }'
p17836
aS'    std::vector<std::string> joint_solution_names(dim, "v");'
p17837
aS'    joint_solution_names.emplace_back("p");'
p17838
aS'    joint_solution_names.emplace_back("rot_u");'
p17839
aS'    DataOut<dim> data_out;'
p17840
aS'    data_out.attach_dof_handler(joint_dof_handler);'
p17841
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p17842
aS'      component_interpretation('
p17843
aS'        dim + 2, DataComponentInterpretation::component_is_part_of_vector);'
p17844
aS'    component_interpretation[dim] ='
p17845
aS'      DataComponentInterpretation::component_is_scalar;'
p17846
aS'    component_interpretation[dim + 1] ='
p17847
aS'      DataComponentInterpretation::component_is_scalar;'
p17848
aS'    data_out.add_data_vector(joint_solution,'
p17849
aS'                             joint_solution_names,'
p17850
aS'                             DataOut<dim>::type_dof_data,'
p17851
aS'                             component_interpretation);'
p17852
aS'    data_out.build_patches(deg + 1);'
p17853
aS'    std::ofstream output("solution-" + Utilities::int_to_string(step, 5) +'
p17854
aS'                         ".vtk");'
p17855
aS'    data_out.write_vtk(output);'
p17856
aS'  }'
p17857
aS'  template <int dim>'
p17858
aS'  void NavierStokesProjection<dim>::assemble_vorticity(const bool reinit_prec)'
p17859
aS'  {'
p17860
aS'    Assert(dim == 2, ExcNotImplemented());'
p17861
aS'    if (reinit_prec)'
p17862
aS'      prec_vel_mass.initialize(vel_Mass);'
p17863
aS'    FEValues<dim>      fe_val_vel(fe_velocity,'
p17864
aS'                             quadrature_velocity,'
p17865
aS'                             update_gradients | update_JxW_values |'
p17866
aS'                               update_values);'
p17867
aS'    const unsigned int dpc = fe_velocity.n_dofs_per_cell(),'
p17868
aS'                       nqp = quadrature_velocity.size();'
p17869
aS'    std::vector<types::global_dof_index> ldi(dpc);'
p17870
aS'    Vector<double>                       loc_rot(dpc);'
p17871
aS'    std::vector<Tensor<1, dim>> grad_u1(nqp), grad_u2(nqp);'
p17872
aS'    rot_u = 0.;'
p17873
aS'    for (const auto &cell : dof_handler_velocity.active_cell_iterators())'
p17874
aS'      {'
p17875
aS'        fe_val_vel.reinit(cell);'
p17876
aS'        cell->get_dof_indices(ldi);'
p17877
aS'        fe_val_vel.get_function_gradients(u_n[0], grad_u1);'
p17878
aS'        fe_val_vel.get_function_gradients(u_n[1], grad_u2);'
p17879
aS'        loc_rot = 0.;'
p17880
aS'        for (unsigned int q = 0; q < nqp; ++q)'
p17881
aS'          for (unsigned int i = 0; i < dpc; ++i)'
p17882
aS'            loc_rot(i) += (grad_u2[q][0] - grad_u1[q][1]) * //'
p17883
aS'                          fe_val_vel.shape_value(i, q) *    //'
p17884
aS'                          fe_val_vel.JxW(q);'
p17885
aS'        for (unsigned int i = 0; i < dpc; ++i)'
p17886
aS'          rot_u(ldi[i]) += loc_rot(i);'
p17887
aS'      }'
p17888
aS'    prec_vel_mass.solve(rot_u);'
p17889
aS'  }'
p17890
aS'} // namespace Step35'
p17891
aS'int main()'
p17892
ag24
aS'  try'
p17893
aS'    {'
p17894
aS'      using namespace Step35;'
p17895
aS'      RunTimeParameters::Data_Storage data;'
p17896
aS'      data.read_data("parameter-file.prm");'
p17897
aS'      deallog.depth_console(data.verbose ? 2 : 0);'
p17898
aS'      NavierStokesProjection<2> test(data);'
p17899
aS'      test.run(data.verbose, data.output_interval);'
p17900
aS'    }'
p17901
aS'  catch (std::exception &exc)'
p17902
aS'    {'
p17903
aS'      std::cerr << std::endl'
p17904
aS'                << std::endl'
p17905
aS'                << "----------------------------------------------------"'
p17906
aS'                << std::endl;'
p17907
aS'      std::cerr << "Exception on processing: " << std::endl'
p17908
aS'                << exc.what() << std::endl'
p17909
aS'                << "Aborting!" << std::endl'
p17910
aS'                << "----------------------------------------------------"'
p17911
aS'                << std::endl;'
p17912
aS'      return 1;'
p17913
aS'    }'
p17914
aS'  catch (...)'
p17915
aS'    {'
p17916
aS'      std::cerr << std::endl'
p17917
aS'                << std::endl'
p17918
aS'                << "----------------------------------------------------"'
p17919
aS'                << std::endl;'
p17920
aS'      std::cerr << "Unknown exception!" << std::endl'
p17921
aS'                << "Aborting!" << std::endl'
p17922
aS'                << "----------------------------------------------------"'
p17923
aS'                << std::endl;'
p17924
aS'      return 1;'
p17925
aS'    }'
p17926
aS'  std::cout << "----------------------------------------------------"'
p17927
aS'            << std::endl'
p17928
aS'            << "Apparently everything went fine!" << std::endl'
p17929
aS'            << "Don\'t forget to brush your teeth :-)" << std::endl'
p17930
aS'            << std::endl;'
p17931
aS'  return 0;'
p17932
ag32
aS'/* ---------------------------------------------------------------------'
p17933
aS' *'
p17934
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p17935
aS' *'
p17936
aS' * This file is part of the deal.II library.'
p17937
aS' *'
p17938
aS' * The deal.II library is free software; you can use it, redistribute'
p17939
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p17940
aS' * Public License as published by the Free Software Foundation; either'
p17941
aS' * version 2.1 of the License, or (at your option) any later version.'
p17942
aS' * The full text of the license can be found in the file LICENSE.md at'
p17943
aS' * the top level directory of deal.II.'
p17944
aS' *'
p17945
aS' * ---------------------------------------------------------------------'
p17946
aS' *'
p17947
aS' * Authors: Toby D. Young, Polish Academy of Sciences,'
p17948
aS' *          Wolfgang Bangerth, Texas A&M University'
p17949
aS' */'
p17950
aS'#include <deal.II/base/logstream.h>'
p17951
aS'#include <deal.II/base/quadrature_lib.h>'
p17952
aS'#include <deal.II/base/function.h>'
p17953
aS'#include <deal.II/base/function_parser.h>'
p17954
aS'#include <deal.II/base/parameter_handler.h>'
p17955
aS'#include <deal.II/base/utilities.h>'
p17956
aS'#include <deal.II/grid/tria.h>'
p17957
aS'#include <deal.II/grid/grid_generator.h>'
p17958
aS'#include <deal.II/dofs/dof_handler.h>'
p17959
aS'#include <deal.II/dofs/dof_tools.h>'
p17960
aS'#include <deal.II/fe/fe_q.h>'
p17961
aS'#include <deal.II/fe/fe_values.h>'
p17962
aS'#include <deal.II/numerics/vector_tools.h>'
p17963
aS'#include <deal.II/numerics/matrix_tools.h>'
p17964
aS'#include <deal.II/numerics/data_out.h>'
p17965
aS'#include <deal.II/lac/affine_constraints.h>'
p17966
aS'#include <deal.II/lac/full_matrix.h>'
p17967
aS'#include <deal.II/base/index_set.h>'
p17968
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p17969
aS'#include <deal.II/lac/petsc_vector.h>'
p17970
aS'#include <deal.II/lac/slepc_solver.h>'
p17971
aS'#include <fstream>'
p17972
aS'#include <iostream>'
p17973
aS'namespace Step36'
p17974
ag24
aS'  using namespace dealii;'
p17975
aS'  template <int dim>'
p17976
aS'  class EigenvalueProblem'
p17977
aS'  {'
p17978
aS'  public:'
p17979
aS'    EigenvalueProblem(const std::string &prm_file);'
p17980
aS'    void run();'
p17981
aS'  private:'
p17982
aS'    void         make_grid_and_dofs();'
p17983
aS'    void         assemble_system();'
p17984
aS'    unsigned int solve();'
p17985
aS'    void         output_results() const;'
p17986
aS'    Triangulation<dim> triangulation;'
p17987
aS'    FE_Q<dim>          fe;'
p17988
aS'    DoFHandler<dim>    dof_handler;'
p17989
aS'    PETScWrappers::SparseMatrix             stiffness_matrix, mass_matrix;'
p17990
aS'    std::vector<PETScWrappers::MPI::Vector> eigenfunctions;'
p17991
aS'    std::vector<double>                     eigenvalues;'
p17992
aS'    ParameterHandler parameters;'
p17993
aS'    AffineConstraints<double> constraints;'
p17994
aS'  };'
p17995
aS'  template <int dim>'
p17996
aS'  EigenvalueProblem<dim>::EigenvalueProblem(const std::string &prm_file)'
p17997
aS'    : fe(1)'
p17998
aS'    , dof_handler(triangulation)'
p17999
aS'  {'
p18000
aS'    parameters.declare_entry('
p18001
aS'      "Global mesh refinement steps",'
p18002
aS'      "5",'
p18003
aS'      Patterns::Integer(0, 20),'
p18004
aS'      "The number of times the 1-cell coarse mesh should "'
p18005
aS'      "be refined globally for our computations.");'
p18006
aS'    parameters.declare_entry("Number of eigenvalues/eigenfunctions",'
p18007
aS'                             "5",'
p18008
aS'                             Patterns::Integer(0, 100),'
p18009
aS'                             "The number of eigenvalues/eigenfunctions "'
p18010
aS'                             "to be computed.");'
p18011
aS'    parameters.declare_entry("Potential",'
p18012
aS'                             "0",'
p18013
aS'                             Patterns::Anything(),'
p18014
aS'                             "A functional description of the potential.");'
p18015
aS'    parameters.parse_input(prm_file);'
p18016
aS'  }'
p18017
aS'  template <int dim>'
p18018
aS'  void EigenvalueProblem<dim>::make_grid_and_dofs()'
p18019
aS'  {'
p18020
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p18021
aS'    triangulation.refine_global('
p18022
aS'      parameters.get_integer("Global mesh refinement steps"));'
p18023
aS'    dof_handler.distribute_dofs(fe);'
p18024
aS'    DoFTools::make_zero_boundary_constraints(dof_handler, constraints);'
p18025
aS'    constraints.close();'
p18026
aS'    stiffness_matrix.reinit(dof_handler.n_dofs(),'
p18027
aS'                            dof_handler.n_dofs(),'
p18028
aS'                            dof_handler.max_couplings_between_dofs());'
p18029
aS'    mass_matrix.reinit(dof_handler.n_dofs(),'
p18030
aS'                       dof_handler.n_dofs(),'
p18031
aS'                       dof_handler.max_couplings_between_dofs());'
p18032
aS'    IndexSet eigenfunction_index_set = dof_handler.locally_owned_dofs();'
p18033
aS'    eigenfunctions.resize('
p18034
aS'      parameters.get_integer("Number of eigenvalues/eigenfunctions"));'
p18035
aS'    for (unsigned int i = 0; i < eigenfunctions.size(); ++i)'
p18036
aS'      eigenfunctions[i].reinit(eigenfunction_index_set, MPI_COMM_WORLD);'
p18037
aS'    eigenvalues.resize(eigenfunctions.size());'
p18038
aS'  }'
p18039
aS'  template <int dim>'
p18040
aS'  void EigenvalueProblem<dim>::assemble_system()'
p18041
aS'  {'
p18042
aS'    QGauss<dim> quadrature_formula(fe.degree + 1);'
p18043
aS'    FEValues<dim> fe_values(fe,'
p18044
aS'                            quadrature_formula,'
p18045
aS'                            update_values | update_gradients |'
p18046
aS'                              update_quadrature_points | update_JxW_values);'
p18047
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p18048
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p18049
aS'    FullMatrix<double> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);'
p18050
aS'    FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);'
p18051
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p18052
aS'    FunctionParser<dim> potential;'
p18053
aS'    potential.initialize(FunctionParser<dim>::default_variable_names(),'
p18054
aS'                         parameters.get("Potential"),'
p18055
aS'                         typename FunctionParser<dim>::ConstMap());'
p18056
aS'    std::vector<double> potential_values(n_q_points);'
p18057
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p18058
aS'      {'
p18059
aS'        fe_values.reinit(cell);'
p18060
aS'        cell_stiffness_matrix = 0;'
p18061
aS'        cell_mass_matrix      = 0;'
p18062
aS'        potential.value_list(fe_values.get_quadrature_points(),'
p18063
aS'                             potential_values);'
p18064
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p18065
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18066
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p18067
aS'              {'
p18068
aS'                cell_stiffness_matrix(i, j) +=           //'
p18069
aS'                  (fe_values.shape_grad(i, q_point) *    //'
p18070
aS'                     fe_values.shape_grad(j, q_point)    //'
p18071
aS'                   +                                     //'
p18072
aS'                   potential_values[q_point] *           //'
p18073
aS'                     fe_values.shape_value(i, q_point) * //'
p18074
aS'                     fe_values.shape_value(j, q_point)   //'
p18075
aS'                   ) *                                   //'
p18076
aS'                  fe_values.JxW(q_point);                //'
p18077
aS'                cell_mass_matrix(i, j) +=              //'
p18078
aS'                  (fe_values.shape_value(i, q_point) * //'
p18079
aS'                   fe_values.shape_value(j, q_point)   //'
p18080
aS'                   ) *                                 //'
p18081
aS'                  fe_values.JxW(q_point);              //'
p18082
aS'              }'
p18083
aS'        cell->get_dof_indices(local_dof_indices);'
p18084
aS'        constraints.distribute_local_to_global(cell_stiffness_matrix,'
p18085
aS'                                               local_dof_indices,'
p18086
aS'                                               stiffness_matrix);'
p18087
aS'        constraints.distribute_local_to_global(cell_mass_matrix,'
p18088
aS'                                               local_dof_indices,'
p18089
aS'                                               mass_matrix);'
p18090
aS'      }'
p18091
aS'    stiffness_matrix.compress(VectorOperation::add);'
p18092
aS'    mass_matrix.compress(VectorOperation::add);'
p18093
aS'    double min_spurious_eigenvalue = std::numeric_limits<double>::max(),'
p18094
aS'           max_spurious_eigenvalue = -std::numeric_limits<double>::max();'
p18095
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p18096
aS'      if (constraints.is_constrained(i))'
p18097
aS'        {'
p18098
aS'          const double ev         = stiffness_matrix(i, i) / mass_matrix(i, i);'
p18099
aS'          min_spurious_eigenvalue = std::min(min_spurious_eigenvalue, ev);'
p18100
aS'          max_spurious_eigenvalue = std::max(max_spurious_eigenvalue, ev);'
p18101
aS'        }'
p18102
aS'    std::cout << "   Spurious eigenvalues are all in the interval "'
p18103
aS'              << "[" << min_spurious_eigenvalue << ","'
p18104
aS'              << max_spurious_eigenvalue << "]" << std::endl;'
p18105
aS'  }'
p18106
aS'  template <int dim>'
p18107
aS'  unsigned int EigenvalueProblem<dim>::solve()'
p18108
aS'  {'
p18109
aS'    SolverControl                    solver_control(dof_handler.n_dofs(), 1e-9);'
p18110
aS'    SLEPcWrappers::SolverKrylovSchur eigensolver(solver_control);'
p18111
aS'    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);'
p18112
aS'    eigensolver.set_problem_type(EPS_GHEP);'
p18113
aS'    eigensolver.solve(stiffness_matrix,'
p18114
aS'                      mass_matrix,'
p18115
aS'                      eigenvalues,'
p18116
aS'                      eigenfunctions,'
p18117
aS'                      eigenfunctions.size());'
p18118
aS'    for (unsigned int i = 0; i < eigenfunctions.size(); ++i)'
p18119
aS'      eigenfunctions[i] /= eigenfunctions[i].linfty_norm();'
p18120
aS'    return solver_control.last_step();'
p18121
aS'  }'
p18122
aS'  template <int dim>'
p18123
aS'  void EigenvalueProblem<dim>::output_results() const'
p18124
aS'  {'
p18125
aS'    DataOut<dim> data_out;'
p18126
aS'    data_out.attach_dof_handler(dof_handler);'
p18127
aS'    for (unsigned int i = 0; i < eigenfunctions.size(); ++i)'
p18128
aS'      data_out.add_data_vector(eigenfunctions[i],'
p18129
aS'                               std::string("eigenfunction_") +'
p18130
aS'                                 Utilities::int_to_string(i));'
p18131
aS'    Vector<double> projected_potential(dof_handler.n_dofs());'
p18132
aS'    {'
p18133
aS'      FunctionParser<dim> potential;'
p18134
aS'      potential.initialize(FunctionParser<dim>::default_variable_names(),'
p18135
aS'                           parameters.get("Potential"),'
p18136
aS'                           typename FunctionParser<dim>::ConstMap());'
p18137
aS'      VectorTools::interpolate(dof_handler, potential, projected_potential);'
p18138
aS'    }'
p18139
aS'    data_out.add_data_vector(projected_potential, "interpolated_potential");'
p18140
aS'    data_out.build_patches();'
p18141
aS'    std::ofstream output("eigenvectors.vtk");'
p18142
aS'    data_out.write_vtk(output);'
p18143
aS'  }'
p18144
aS'  template <int dim>'
p18145
aS'  void EigenvalueProblem<dim>::run()'
p18146
aS'  {'
p18147
aS'    make_grid_and_dofs();'
p18148
aS'    std::cout << "   Number of active cells:       "'
p18149
aS'              << triangulation.n_active_cells() << std::endl'
p18150
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p18151
aS'              << std::endl;'
p18152
aS'    assemble_system();'
p18153
aS'    const unsigned int n_iterations = solve();'
p18154
aS'    std::cout << "   Solver converged in " << n_iterations << " iterations."'
p18155
aS'              << std::endl;'
p18156
aS'    output_results();'
p18157
aS'    std::cout << std::endl;'
p18158
aS'    for (unsigned int i = 0; i < eigenvalues.size(); ++i)'
p18159
aS'      std::cout << "      Eigenvalue " << i << " : " << eigenvalues[i]'
p18160
aS'                << std::endl;'
p18161
aS'  }'
p18162
aS'} // namespace Step36'
p18163
aS'int main(int argc, char **argv)'
p18164
ag24
aS'  try'
p18165
aS'    {'
p18166
aS'      using namespace dealii;'
p18167
aS'      using namespace Step36;'
p18168
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p18169
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p18170
aS'                  ExcMessage('
p18171
aS'                    "This program can only be run in serial, use ./step-36"));'
p18172
aS'      EigenvalueProblem<2> problem("step-36.prm");'
p18173
aS'      problem.run();'
p18174
aS'    }'
p18175
aS'  catch (std::exception &exc)'
p18176
aS'    {'
p18177
aS'      std::cerr << std::endl'
p18178
aS'                << std::endl'
p18179
aS'                << "----------------------------------------------------"'
p18180
aS'                << std::endl;'
p18181
aS'      std::cerr << "Exception on processing: " << std::endl'
p18182
aS'                << exc.what() << std::endl'
p18183
aS'                << "Aborting!" << std::endl'
p18184
aS'                << "----------------------------------------------------"'
p18185
aS'                << std::endl;'
p18186
aS'      return 1;'
p18187
aS'    }'
p18188
aS'  catch (...)'
p18189
aS'    {'
p18190
aS'      std::cerr << std::endl'
p18191
aS'                << std::endl'
p18192
aS'                << "----------------------------------------------------"'
p18193
aS'                << std::endl;'
p18194
aS'      std::cerr << "Unknown exception!" << std::endl'
p18195
aS'                << "Aborting!" << std::endl'
p18196
aS'                << "----------------------------------------------------"'
p18197
aS'                << std::endl;'
p18198
aS'      return 1;'
p18199
aS'    }'
p18200
aS'  std::cout << std::endl << "   Job done." << std::endl;'
p18201
aS'  return 0;'
p18202
ag32
aS'/* ---------------------------------------------------------------------'
p18203
aS' *'
p18204
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p18205
aS' *'
p18206
aS' * This file is part of the deal.II library.'
p18207
aS' *'
p18208
aS' * The deal.II library is free software; you can use it, redistribute'
p18209
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p18210
aS' * Public License as published by the Free Software Foundation; either'
p18211
aS' * version 2.1 of the License, or (at your option) any later version.'
p18212
aS' * The full text of the license can be found in the file LICENSE.md at'
p18213
aS' * the top level directory of deal.II.'
p18214
aS' *'
p18215
aS' * ---------------------------------------------------------------------'
p18216
aS' *'
p18217
aS' * Authors: Katharina Kormann, Martin Kronbichler, Uppsala University,'
p18218
aS' * 2009-2012, updated to MPI version with parallel vectors in 2016'
p18219
aS' */'
p18220
aS'#include <deal.II/base/quadrature_lib.h>'
p18221
aS'#include <deal.II/base/function.h>'
p18222
aS'#include <deal.II/base/timer.h>'
p18223
aS'#include <deal.II/lac/affine_constraints.h>'
p18224
aS'#include <deal.II/lac/solver_cg.h>'
p18225
aS'#include <deal.II/lac/la_parallel_vector.h>'
p18226
aS'#include <deal.II/lac/precondition.h>'
p18227
aS'#include <deal.II/fe/fe_q.h>'
p18228
aS'#include <deal.II/grid/tria.h>'
p18229
aS'#include <deal.II/grid/grid_generator.h>'
p18230
aS'#include <deal.II/multigrid/multigrid.h>'
p18231
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p18232
aS'#include <deal.II/multigrid/mg_tools.h>'
p18233
aS'#include <deal.II/multigrid/mg_coarse.h>'
p18234
aS'#include <deal.II/multigrid/mg_smoother.h>'
p18235
aS'#include <deal.II/multigrid/mg_matrix.h>'
p18236
aS'#include <deal.II/numerics/data_out.h>'
p18237
aS'#include <deal.II/numerics/vector_tools.h>'
p18238
aS'#include <deal.II/matrix_free/matrix_free.h>'
p18239
aS'#include <deal.II/matrix_free/operators.h>'
p18240
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p18241
aS'#include <iostream>'
p18242
aS'#include <fstream>'
p18243
aS'namespace Step37'
p18244
ag24
aS'  using namespace dealii;'
p18245
aS'  const unsigned int degree_finite_element = 2;'
p18246
aS'  const unsigned int dimension             = 3;'
p18247
aS'  template <int dim>'
p18248
aS'  class Coefficient : public Function<dim>'
p18249
aS'  {'
p18250
aS'  public:'
p18251
aS'    virtual double value(const Point<dim> & p,'
p18252
aS'                         const unsigned int component = 0) const override;'
p18253
aS'    template <typename number>'
p18254
aS'    number value(const Point<dim, number> &p,'
p18255
aS'                 const unsigned int        component = 0) const;'
p18256
aS'  };'
p18257
aS'  template <int dim>'
p18258
aS'  template <typename number>'
p18259
aS'  number Coefficient<dim>::value(const Point<dim, number> &p,'
p18260
aS'                                 const unsigned int /*component*/) const'
p18261
aS'  {'
p18262
aS'    return 1. / (0.05 + 2. * p.square());'
p18263
aS'  }'
p18264
aS'  template <int dim>'
p18265
aS'  double Coefficient<dim>::value(const Point<dim> & p,'
p18266
aS'                                 const unsigned int component) const'
p18267
aS'  {'
p18268
aS'    return value<double>(p, component);'
p18269
aS'  }'
p18270
aS'  template <int dim, int fe_degree, typename number>'
p18271
aS'  class LaplaceOperator'
p18272
aS'    : public MatrixFreeOperators::'
p18273
aS'        Base<dim, LinearAlgebra::distributed::Vector<number>>'
p18274
aS'  {'
p18275
aS'  public:'
p18276
aS'    using value_type = number;'
p18277
aS'    LaplaceOperator();'
p18278
aS'    void clear() override;'
p18279
aS'    void evaluate_coefficient(const Coefficient<dim> &coefficient_function);'
p18280
aS'    virtual void compute_diagonal() override;'
p18281
aS'  private:'
p18282
aS'    virtual void apply_add('
p18283
aS'      LinearAlgebra::distributed::Vector<number> &      dst,'
p18284
aS'      const LinearAlgebra::distributed::Vector<number> &src) const override;'
p18285
aS'    void'
p18286
aS'    local_apply(const MatrixFree<dim, number> &                   data,'
p18287
aS'                LinearAlgebra::distributed::Vector<number> &      dst,'
p18288
aS'                const LinearAlgebra::distributed::Vector<number> &src,'
p18289
aS'                const std::pair<unsigned int, unsigned int> &cell_range) const;'
p18290
aS'    void local_compute_diagonal('
p18291
aS'      const MatrixFree<dim, number> &              data,'
p18292
aS'      LinearAlgebra::distributed::Vector<number> & dst,'
p18293
aS'      const unsigned int &                         dummy,'
p18294
aS'      const std::pair<unsigned int, unsigned int> &cell_range) const;'
p18295
aS'    Table<2, VectorizedArray<number>> coefficient;'
p18296
aS'  };'
p18297
aS'  template <int dim, int fe_degree, typename number>'
p18298
aS'  LaplaceOperator<dim, fe_degree, number>::LaplaceOperator()'
p18299
aS'    : MatrixFreeOperators::Base<dim,'
p18300
aS'                                LinearAlgebra::distributed::Vector<number>>()'
p18301
aS'  {}'
p18302
aS'  template <int dim, int fe_degree, typename number>'
p18303
aS'  void LaplaceOperator<dim, fe_degree, number>::clear()'
p18304
aS'  {'
p18305
aS'    coefficient.reinit(0, 0);'
p18306
aS'    MatrixFreeOperators::Base<dim, LinearAlgebra::distributed::Vector<number>>::'
p18307
aS'      clear();'
p18308
aS'  }'
p18309
aS'  template <int dim, int fe_degree, typename number>'
p18310
aS'  void LaplaceOperator<dim, fe_degree, number>::evaluate_coefficient('
p18311
aS'    const Coefficient<dim> &coefficient_function)'
p18312
aS'  {'
p18313
aS'    const unsigned int n_cells = this->data->n_cell_batches();'
p18314
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*this->data);'
p18315
aS'    coefficient.reinit(n_cells, phi.n_q_points);'
p18316
aS'    for (unsigned int cell = 0; cell < n_cells; ++cell)'
p18317
aS'      {'
p18318
aS'        phi.reinit(cell);'
p18319
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p18320
aS'          coefficient(cell, q) ='
p18321
aS'            coefficient_function.value(phi.quadrature_point(q));'
p18322
aS'      }'
p18323
aS'  }'
p18324
aS'  template <int dim, int fe_degree, typename number>'
p18325
aS'  void LaplaceOperator<dim, fe_degree, number>::local_apply('
p18326
aS'    const MatrixFree<dim, number> &                   data,'
p18327
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p18328
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p18329
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p18330
aS'  {'
p18331
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data);'
p18332
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p18333
aS'      {'
p18334
aS'        AssertDimension(coefficient.size(0), data.n_cell_batches());'
p18335
aS'        AssertDimension(coefficient.size(1), phi.n_q_points);'
p18336
aS'        phi.reinit(cell);'
p18337
aS'        phi.read_dof_values(src);'
p18338
aS'        phi.evaluate(EvaluationFlags::gradients);'
p18339
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p18340
aS'          phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);'
p18341
aS'        phi.integrate(EvaluationFlags::gradients);'
p18342
aS'        phi.distribute_local_to_global(dst);'
p18343
aS'      }'
p18344
aS'  }'
p18345
aS'  template <int dim, int fe_degree, typename number>'
p18346
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_add('
p18347
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p18348
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p18349
aS'  {'
p18350
aS'    this->data->cell_loop(&LaplaceOperator::local_apply, this, dst, src);'
p18351
aS'  }'
p18352
aS'  template <int dim, int fe_degree, typename number>'
p18353
aS'  void LaplaceOperator<dim, fe_degree, number>::compute_diagonal()'
p18354
aS'  {'
p18355
aS'    this->inverse_diagonal_entries.reset('
p18356
aS'      new DiagonalMatrix<LinearAlgebra::distributed::Vector<number>>());'
p18357
aS'    LinearAlgebra::distributed::Vector<number> &inverse_diagonal ='
p18358
aS'      this->inverse_diagonal_entries->get_vector();'
p18359
aS'    this->data->initialize_dof_vector(inverse_diagonal);'
p18360
aS'    unsigned int dummy = 0;'
p18361
aS'    this->data->cell_loop(&LaplaceOperator::local_compute_diagonal,'
p18362
aS'                          this,'
p18363
aS'                          inverse_diagonal,'
p18364
aS'                          dummy);'
p18365
aS'    this->set_constrained_entries_to_one(inverse_diagonal);'
p18366
aS'    for (unsigned int i = 0; i < inverse_diagonal.locally_owned_size(); ++i)'
p18367
aS'      {'
p18368
aS'        Assert(inverse_diagonal.local_element(i) > 0.,'
p18369
aS'               ExcMessage("No diagonal entry in a positive definite operator "'
p18370
aS'                          "should be zero"));'
p18371
aS'        inverse_diagonal.local_element(i) ='
p18372
aS'          1. / inverse_diagonal.local_element(i);'
p18373
aS'      }'
p18374
aS'  }'
p18375
aS'  template <int dim, int fe_degree, typename number>'
p18376
aS'  void LaplaceOperator<dim, fe_degree, number>::local_compute_diagonal('
p18377
aS'    const MatrixFree<dim, number> &             data,'
p18378
aS'    LinearAlgebra::distributed::Vector<number> &dst,'
p18379
aS'    const unsigned int &,'
p18380
aS'    const std::pair<unsigned int, unsigned int> &cell_range) const'
p18381
aS'  {'
p18382
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data);'
p18383
aS'    AlignedVector<VectorizedArray<number>> diagonal(phi.dofs_per_cell);'
p18384
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p18385
aS'      {'
p18386
aS'        AssertDimension(coefficient.size(0), data.n_cell_batches());'
p18387
aS'        AssertDimension(coefficient.size(1), phi.n_q_points);'
p18388
aS'        phi.reinit(cell);'
p18389
aS'        for (unsigned int i = 0; i < phi.dofs_per_cell; ++i)'
p18390
aS'          {'
p18391
aS'            for (unsigned int j = 0; j < phi.dofs_per_cell; ++j)'
p18392
aS'              phi.submit_dof_value(VectorizedArray<number>(), j);'
p18393
aS'            phi.submit_dof_value(make_vectorized_array<number>(1.), i);'
p18394
aS'            phi.evaluate(EvaluationFlags::gradients);'
p18395
aS'            for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p18396
aS'              phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),'
p18397
aS'                                  q);'
p18398
aS'            phi.integrate(EvaluationFlags::gradients);'
p18399
aS'            diagonal[i] = phi.get_dof_value(i);'
p18400
aS'          }'
p18401
aS'        for (unsigned int i = 0; i < phi.dofs_per_cell; ++i)'
p18402
aS'          phi.submit_dof_value(diagonal[i], i);'
p18403
aS'        phi.distribute_local_to_global(dst);'
p18404
aS'      }'
p18405
aS'  }'
p18406
aS'  template <int dim>'
p18407
aS'  class LaplaceProblem'
p18408
aS'  {'
p18409
aS'  public:'
p18410
aS'    LaplaceProblem();'
p18411
aS'    void run();'
p18412
aS'  private:'
p18413
aS'    void setup_system();'
p18414
aS'    void assemble_rhs();'
p18415
aS'    void solve();'
p18416
aS'    void output_results(const unsigned int cycle) const;'
p18417
aS'#ifdef DEAL_II_WITH_P4EST'
p18418
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p18419
aS'#else'
p18420
aS'    Triangulation<dim> triangulation;'
p18421
aS'#endif'
p18422
aS'    FE_Q<dim>       fe;'
p18423
aS'    DoFHandler<dim> dof_handler;'
p18424
aS'    MappingQ1<dim> mapping;'
p18425
aS'    AffineConstraints<double> constraints;'
p18426
aS'    using SystemMatrixType ='
p18427
aS'      LaplaceOperator<dim, degree_finite_element, double>;'
p18428
aS'    SystemMatrixType system_matrix;'
p18429
aS'    MGConstrainedDoFs mg_constrained_dofs;'
p18430
aS'    using LevelMatrixType = LaplaceOperator<dim, degree_finite_element, float>;'
p18431
aS'    MGLevelObject<LevelMatrixType> mg_matrices;'
p18432
aS'    LinearAlgebra::distributed::Vector<double> solution;'
p18433
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p18434
aS'    double             setup_time;'
p18435
aS'    ConditionalOStream pcout;'
p18436
aS'    ConditionalOStream time_details;'
p18437
aS'  };'
p18438
aS'  template <int dim>'
p18439
aS'  LaplaceProblem<dim>::LaplaceProblem()'
p18440
aS'    :'
p18441
aS'#ifdef DEAL_II_WITH_P4EST'
p18442
aS'    triangulation('
p18443
aS'      MPI_COMM_WORLD,'
p18444
aS'      Triangulation<dim>::limit_level_difference_at_vertices,'
p18445
aS'      parallel::distributed::Triangulation<dim>::construct_multigrid_hierarchy)'
p18446
aS'    ,'
p18447
aS'#else'
p18448
aS'    triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p18449
aS'    ,'
p18450
aS'#endif'
p18451
aS'    fe(degree_finite_element)'
p18452
aS'    , dof_handler(triangulation)'
p18453
aS'    , setup_time(0.)'
p18454
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p18455
aS'    ,'
p18456
aS'    time_details(std::cout,'
p18457
aS'                 false && Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p18458
aS'  {}'
p18459
aS'  template <int dim>'
p18460
aS'  void LaplaceProblem<dim>::setup_system()'
p18461
aS'  {'
p18462
aS'    Timer time;'
p18463
aS'    setup_time = 0;'
p18464
aS'    system_matrix.clear();'
p18465
aS'    mg_matrices.clear_elements();'
p18466
aS'    dof_handler.distribute_dofs(fe);'
p18467
aS'    dof_handler.distribute_mg_dofs();'
p18468
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p18469
aS'          << std::endl;'
p18470
aS'    IndexSet locally_relevant_dofs;'
p18471
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p18472
aS'    constraints.clear();'
p18473
aS'    constraints.reinit(locally_relevant_dofs);'
p18474
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p18475
aS'    VectorTools::interpolate_boundary_values('
p18476
aS'      mapping, dof_handler, 0, Functions::ZeroFunction<dim>(), constraints);'
p18477
aS'    constraints.close();'
p18478
aS'    setup_time += time.wall_time();'
p18479
aS'    time_details << "Distribute DoFs & B.C.     (CPU/wall) " << time.cpu_time()'
p18480
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p18481
aS'    time.restart();'
p18482
aS'    {'
p18483
aS'      typename MatrixFree<dim, double>::AdditionalData additional_data;'
p18484
aS'      additional_data.tasks_parallel_scheme ='
p18485
aS'        MatrixFree<dim, double>::AdditionalData::none;'
p18486
aS'      additional_data.mapping_update_flags ='
p18487
aS'        (update_gradients | update_JxW_values | update_quadrature_points);'
p18488
aS'      std::shared_ptr<MatrixFree<dim, double>> system_mf_storage('
p18489
aS'        new MatrixFree<dim, double>());'
p18490
aS'      system_mf_storage->reinit(mapping,'
p18491
aS'                                dof_handler,'
p18492
aS'                                constraints,'
p18493
aS'                                QGauss<1>(fe.degree + 1),'
p18494
aS'                                additional_data);'
p18495
aS'      system_matrix.initialize(system_mf_storage);'
p18496
aS'    }'
p18497
aS'    system_matrix.evaluate_coefficient(Coefficient<dim>());'
p18498
aS'    system_matrix.initialize_dof_vector(solution);'
p18499
aS'    system_matrix.initialize_dof_vector(system_rhs);'
p18500
aS'    setup_time += time.wall_time();'
p18501
aS'    time_details << "Setup matrix-free system   (CPU/wall) " << time.cpu_time()'
p18502
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p18503
aS'    time.restart();'
p18504
aS'    const unsigned int nlevels = triangulation.n_global_levels();'
p18505
aS'    mg_matrices.resize(0, nlevels - 1);'
p18506
aS'    std::set<types::boundary_id> dirichlet_boundary;'
p18507
aS'    dirichlet_boundary.insert(0);'
p18508
aS'    mg_constrained_dofs.initialize(dof_handler);'
p18509
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p18510
aS'                                                       dirichlet_boundary);'
p18511
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p18512
aS'      {'
p18513
aS'        IndexSet relevant_dofs;'
p18514
aS'        DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p18515
aS'                                                      level,'
p18516
aS'                                                      relevant_dofs);'
p18517
aS'        AffineConstraints<double> level_constraints;'
p18518
aS'        level_constraints.reinit(relevant_dofs);'
p18519
aS'        level_constraints.add_lines('
p18520
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p18521
aS'        level_constraints.close();'
p18522
aS'        typename MatrixFree<dim, float>::AdditionalData additional_data;'
p18523
aS'        additional_data.tasks_parallel_scheme ='
p18524
aS'          MatrixFree<dim, float>::AdditionalData::none;'
p18525
aS'        additional_data.mapping_update_flags ='
p18526
aS'          (update_gradients | update_JxW_values | update_quadrature_points);'
p18527
aS'        additional_data.mg_level = level;'
p18528
aS'        std::shared_ptr<MatrixFree<dim, float>> mg_mf_storage_level('
p18529
aS'          new MatrixFree<dim, float>());'
p18530
aS'        mg_mf_storage_level->reinit(mapping,'
p18531
aS'                                    dof_handler,'
p18532
aS'                                    level_constraints,'
p18533
aS'                                    QGauss<1>(fe.degree + 1),'
p18534
aS'                                    additional_data);'
p18535
aS'        mg_matrices[level].initialize(mg_mf_storage_level,'
p18536
aS'                                      mg_constrained_dofs,'
p18537
aS'                                      level);'
p18538
aS'        mg_matrices[level].evaluate_coefficient(Coefficient<dim>());'
p18539
aS'      }'
p18540
aS'    setup_time += time.wall_time();'
p18541
aS'    time_details << "Setup matrix-free levels   (CPU/wall) " << time.cpu_time()'
p18542
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p18543
aS'  }'
p18544
aS'  template <int dim>'
p18545
aS'  void LaplaceProblem<dim>::assemble_rhs()'
p18546
aS'  {'
p18547
aS'    Timer time;'
p18548
aS'    system_rhs = 0;'
p18549
aS'    FEEvaluation<dim, degree_finite_element> phi('
p18550
aS'      *system_matrix.get_matrix_free());'
p18551
aS'    for (unsigned int cell = 0;'
p18552
aS'         cell < system_matrix.get_matrix_free()->n_cell_batches();'
p18553
aS'         ++cell)'
p18554
aS'      {'
p18555
aS'        phi.reinit(cell);'
p18556
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p18557
aS'          phi.submit_value(make_vectorized_array<double>(1.0), q);'
p18558
aS'        phi.integrate(EvaluationFlags::values);'
p18559
aS'        phi.distribute_local_to_global(system_rhs);'
p18560
aS'      }'
p18561
aS'    system_rhs.compress(VectorOperation::add);'
p18562
aS'    setup_time += time.wall_time();'
p18563
aS'    time_details << "Assemble right hand side   (CPU/wall) " << time.cpu_time()'
p18564
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p18565
aS'  }'
p18566
aS'  template <int dim>'
p18567
aS'  void LaplaceProblem<dim>::solve()'
p18568
aS'  {'
p18569
aS'    Timer                            time;'
p18570
aS'    MGTransferMatrixFree<dim, float> mg_transfer(mg_constrained_dofs);'
p18571
aS'    mg_transfer.build(dof_handler);'
p18572
aS'    setup_time += time.wall_time();'
p18573
aS'    time_details << "MG build transfer time     (CPU/wall) " << time.cpu_time()'
p18574
aS'                 << "s/" << time.wall_time() << "s\\n";'
p18575
aS'    time.restart();'
p18576
aS'    using SmootherType ='
p18577
aS'      PreconditionChebyshev<LevelMatrixType,'
p18578
aS'                            LinearAlgebra::distributed::Vector<float>>;'
p18579
aS'    mg::SmootherRelaxation<SmootherType,'
p18580
aS'                           LinearAlgebra::distributed::Vector<float>>'
p18581
aS'                                                         mg_smoother;'
p18582
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data;'
p18583
aS'    smoother_data.resize(0, triangulation.n_global_levels() - 1);'
p18584
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p18585
aS'         ++level)'
p18586
aS'      {'
p18587
aS'        if (level > 0)'
p18588
aS'          {'
p18589
aS'            smoother_data[level].smoothing_range     = 15.;'
p18590
aS'            smoother_data[level].degree              = 5;'
p18591
aS'            smoother_data[level].eig_cg_n_iterations = 10;'
p18592
aS'          }'
p18593
aS'        else'
p18594
aS'          {'
p18595
aS'            smoother_data[0].smoothing_range = 1e-3;'
p18596
aS'            smoother_data[0].degree          = numbers::invalid_unsigned_int;'
p18597
aS'            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();'
p18598
aS'          }'
p18599
aS'        mg_matrices[level].compute_diagonal();'
p18600
aS'        smoother_data[level].preconditioner ='
p18601
aS'          mg_matrices[level].get_matrix_diagonal_inverse();'
p18602
aS'      }'
p18603
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p18604
aS'    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>>'
p18605
aS'      mg_coarse;'
p18606
aS'    mg_coarse.initialize(mg_smoother);'
p18607
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix('
p18608
aS'      mg_matrices);'
p18609
aS'    MGLevelObject<MatrixFreeOperators::MGInterfaceOperator<LevelMatrixType>>'
p18610
aS'      mg_interface_matrices;'
p18611
aS'    mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1);'
p18612
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p18613
aS'         ++level)'
p18614
aS'      mg_interface_matrices[level].initialize(mg_matrices[level]);'
p18615
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_interface('
p18616
aS'      mg_interface_matrices);'
p18617
aS'    Multigrid<LinearAlgebra::distributed::Vector<float>> mg('
p18618
aS'      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p18619
aS'    mg.set_edge_matrices(mg_interface, mg_interface);'
p18620
aS'    PreconditionMG<dim,'
p18621
aS'                   LinearAlgebra::distributed::Vector<float>,'
p18622
aS'                   MGTransferMatrixFree<dim, float>>'
p18623
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p18624
aS'    SolverControl solver_control(100, 1e-12 * system_rhs.l2_norm());'
p18625
aS'    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control);'
p18626
aS'    setup_time += time.wall_time();'
p18627
aS'    time_details << "MG build smoother time     (CPU/wall) " << time.cpu_time()'
p18628
aS'                 << "s/" << time.wall_time() << "s\\n";'
p18629
aS'    pcout << "Total setup time               (wall) " << setup_time << "s\\n";'
p18630
aS'    time.reset();'
p18631
aS'    time.start();'
p18632
aS'    constraints.set_zero(solution);'
p18633
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p18634
aS'    constraints.distribute(solution);'
p18635
aS'    pcout << "Time solve (" << solver_control.last_step() << " iterations)"'
p18636
aS'          << (solver_control.last_step() < 10 ? "  " : " ") << "(CPU/wall) "'
p18637
aS'          << time.cpu_time() << "s/" << time.wall_time() << "s\\n";'
p18638
aS'  }'
p18639
aS'  template <int dim>'
p18640
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p18641
aS'  {'
p18642
aS'    Timer time;'
p18643
aS'    if (triangulation.n_global_active_cells() > 1000000)'
p18644
aS'      return;'
p18645
aS'    DataOut<dim> data_out;'
p18646
aS'    solution.update_ghost_values();'
p18647
aS'    data_out.attach_dof_handler(dof_handler);'
p18648
aS'    data_out.add_data_vector(solution, "solution");'
p18649
aS'    data_out.build_patches(mapping);'
p18650
aS'    DataOutBase::VtkFlags flags;'
p18651
aS'    flags.compression_level = DataOutBase::VtkFlags::best_speed;'
p18652
aS'    data_out.set_flags(flags);'
p18653
aS'    data_out.write_vtu_with_pvtu_record('
p18654
aS'      "./", "solution", cycle, MPI_COMM_WORLD, 3);'
p18655
aS'    time_details << "Time write output          (CPU/wall) " << time.cpu_time()'
p18656
aS'                 << "s/" << time.wall_time() << "s\\n";'
p18657
aS'  }'
p18658
aS'  template <int dim>'
p18659
aS'  void LaplaceProblem<dim>::run()'
p18660
aS'  {'
p18661
aS'    {'
p18662
aS'      const unsigned int n_vect_doubles = VectorizedArray<double>::size();'
p18663
aS'      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles;'
p18664
aS'      pcout << "Vectorization over " << n_vect_doubles'
p18665
aS'            << " doubles = " << n_vect_bits << " bits ("'
p18666
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p18667
aS'            << std::endl;'
p18668
aS'    }'
p18669
aS'    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle)'
p18670
aS'      {'
p18671
aS'        pcout << "Cycle " << cycle << std::endl;'
p18672
aS'        if (cycle == 0)'
p18673
aS'          {'
p18674
aS'            GridGenerator::hyper_cube(triangulation, 0., 1.);'
p18675
aS'            triangulation.refine_global(3 - dim);'
p18676
aS'          }'
p18677
aS'        triangulation.refine_global(1);'
p18678
aS'        setup_system();'
p18679
aS'        assemble_rhs();'
p18680
aS'        solve();'
p18681
aS'        output_results(cycle);'
p18682
aS'        pcout << std::endl;'
p18683
aS'      };'
p18684
aS'  }'
p18685
aS'} // namespace Step37'
p18686
aS'int main(int argc, char *argv[])'
p18687
ag24
aS'  try'
p18688
aS'    {'
p18689
aS'      using namespace Step37;'
p18690
aS'      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);'
p18691
aS'      LaplaceProblem<dimension> laplace_problem;'
p18692
aS'      laplace_problem.run();'
p18693
aS'    }'
p18694
aS'  catch (std::exception &exc)'
p18695
aS'    {'
p18696
aS'      std::cerr << std::endl'
p18697
aS'                << std::endl'
p18698
aS'                << "----------------------------------------------------"'
p18699
aS'                << std::endl;'
p18700
aS'      std::cerr << "Exception on processing: " << std::endl'
p18701
aS'                << exc.what() << std::endl'
p18702
aS'                << "Aborting!" << std::endl'
p18703
aS'                << "----------------------------------------------------"'
p18704
aS'                << std::endl;'
p18705
aS'      return 1;'
p18706
aS'    }'
p18707
aS'  catch (...)'
p18708
aS'    {'
p18709
aS'      std::cerr << std::endl'
p18710
aS'                << std::endl'
p18711
aS'                << "----------------------------------------------------"'
p18712
aS'                << std::endl;'
p18713
aS'      std::cerr << "Unknown exception!" << std::endl'
p18714
aS'                << "Aborting!" << std::endl'
p18715
aS'                << "----------------------------------------------------"'
p18716
aS'                << std::endl;'
p18717
aS'      return 1;'
p18718
aS'    }'
p18719
aS'  return 0;'
p18720
ag32
aS'/* ---------------------------------------------------------------------'
p18721
aS' *'
p18722
aS' * Copyright (C) 2010 - 2021 by the deal.II authors'
p18723
aS' *'
p18724
aS' * This file is part of the deal.II library.'
p18725
aS' *'
p18726
aS' * The deal.II library is free software; you can use it, redistribute'
p18727
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p18728
aS' * Public License as published by the Free Software Foundation; either'
p18729
aS' * version 2.1 of the License, or (at your option) any later version.'
p18730
aS' * The full text of the license can be found in the file LICENSE.md at'
p18731
aS' * the top level directory of deal.II.'
p18732
aS' *'
p18733
aS' * ---------------------------------------------------------------------'
p18734
aS' *'
p18735
aS' * Authors: Andrea Bonito, Sebastian Pauletti.'
p18736
aS' */'
p18737
aS'#include <deal.II/base/quadrature_lib.h>'
p18738
aS'#include <deal.II/base/function.h>'
p18739
aS'#include <deal.II/lac/full_matrix.h>'
p18740
aS'#include <deal.II/lac/vector.h>'
p18741
aS'#include <deal.II/lac/solver_control.h>'
p18742
aS'#include <deal.II/lac/solver_cg.h>'
p18743
aS'#include <deal.II/lac/precondition.h>'
p18744
aS'#include <deal.II/lac/sparse_matrix.h>'
p18745
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p18746
aS'#include <deal.II/grid/tria.h>'
p18747
aS'#include <deal.II/grid/manifold_lib.h>'
p18748
aS'#include <deal.II/grid/grid_generator.h>'
p18749
aS'#include <deal.II/dofs/dof_handler.h>'
p18750
aS'#include <deal.II/dofs/dof_tools.h>'
p18751
aS'#include <deal.II/fe/fe_q.h>'
p18752
aS'#include <deal.II/fe/fe_values.h>'
p18753
aS'#include <deal.II/fe/mapping_q.h>'
p18754
aS'#include <deal.II/numerics/data_out.h>'
p18755
aS'#include <deal.II/numerics/vector_tools.h>'
p18756
aS'#include <deal.II/numerics/matrix_tools.h>'
p18757
aS'#include <fstream>'
p18758
aS'#include <iostream>'
p18759
aS'namespace Step38'
p18760
ag24
aS'  using namespace dealii;'
p18761
aS'  template <int spacedim>'
p18762
aS'  class LaplaceBeltramiProblem'
p18763
aS'  {'
p18764
aS'  public:'
p18765
aS'    LaplaceBeltramiProblem(const unsigned degree = 2);'
p18766
aS'    void run();'
p18767
aS'  private:'
p18768
aS'    static constexpr unsigned int dim = spacedim - 1;'
p18769
aS'    void make_grid_and_dofs();'
p18770
aS'    void assemble_system();'
p18771
aS'    void solve();'
p18772
aS'    void output_results() const;'
p18773
aS'    void compute_error() const;'
p18774
aS'    Triangulation<dim, spacedim> triangulation;'
p18775
aS'    FE_Q<dim, spacedim>          fe;'
p18776
aS'    DoFHandler<dim, spacedim>    dof_handler;'
p18777
aS'    MappingQ<dim, spacedim>      mapping;'
p18778
aS'    SparsityPattern      sparsity_pattern;'
p18779
aS'    SparseMatrix<double> system_matrix;'
p18780
aS'    Vector<double> solution;'
p18781
aS'    Vector<double> system_rhs;'
p18782
aS'  };'
p18783
aS'  template <int dim>'
p18784
aS'  class Solution : public Function<dim>'
p18785
aS'  {'
p18786
aS'  public:'
p18787
aS'    virtual double value(const Point<dim> & p,'
p18788
aS'                         const unsigned int component = 0) const override;'
p18789
aS'    virtual Tensor<1, dim>'
p18790
aS'    gradient(const Point<dim> & p,'
p18791
aS'             const unsigned int component = 0) const override;'
p18792
aS'  };'
p18793
aS'  template <>'
p18794
aS'  double Solution<2>::value(const Point<2> &p, const unsigned int) const'
p18795
aS'  {'
p18796
aS'    return (-2. * p(0) * p(1));'
p18797
aS'  }'
p18798
aS'  template <>'
p18799
aS'  Tensor<1, 2> Solution<2>::gradient(const Point<2> &p,'
p18800
aS'                                     const unsigned int) const'
p18801
aS'  {'
p18802
aS'    Tensor<1, 2> return_value;'
p18803
aS'    return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));'
p18804
aS'    return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));'
p18805
aS'    return return_value;'
p18806
aS'  }'
p18807
aS'  template <>'
p18808
aS'  double Solution<3>::value(const Point<3> &p, const unsigned int) const'
p18809
aS'  {'
p18810
aS'    return (std::sin(numbers::PI * p(0)) * std::cos(numbers::PI * p(1)) *'
p18811
aS'            exp(p(2)));'
p18812
aS'  }'
p18813
aS'  template <>'
p18814
aS'  Tensor<1, 3> Solution<3>::gradient(const Point<3> &p,'
p18815
aS'                                     const unsigned int) const'
p18816
aS'  {'
p18817
aS'    using numbers::PI;'
p18818
aS'    Tensor<1, 3> return_value;'
p18819
aS'    return_value[0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18820
aS'    return_value[1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18821
aS'    return_value[2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18822
aS'    return return_value;'
p18823
aS'  }'
p18824
aS'  template <int dim>'
p18825
aS'  class RightHandSide : public Function<dim>'
p18826
aS'  {'
p18827
aS'  public:'
p18828
aS'    virtual double value(const Point<dim> & p,'
p18829
aS'                         const unsigned int component = 0) const override;'
p18830
aS'  };'
p18831
aS'  template <>'
p18832
aS'  double RightHandSide<2>::value(const Point<2> &p,'
p18833
aS'                                 const unsigned int /*component*/) const'
p18834
aS'  {'
p18835
aS'    return (-8. * p(0) * p(1));'
p18836
aS'  }'
p18837
aS'  template <>'
p18838
aS'  double RightHandSide<3>::value(const Point<3> &p,'
p18839
aS'                                 const unsigned int /*component*/) const'
p18840
aS'  {'
p18841
aS'    using numbers::PI;'
p18842
aS'    Tensor<2, 3> hessian;'
p18843
aS'    hessian[0][0] = -PI * PI * sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18844
aS'    hessian[1][1] = -PI * PI * sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18845
aS'    hessian[2][2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18846
aS'    hessian[0][1] = -PI * PI * cos(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18847
aS'    hessian[1][0] = -PI * PI * cos(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18848
aS'    hessian[0][2] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18849
aS'    hessian[2][0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18850
aS'    hessian[1][2] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18851
aS'    hessian[2][1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18852
aS'    Tensor<1, 3> gradient;'
p18853
aS'    gradient[0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18854
aS'    gradient[1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18855
aS'    gradient[2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18856
aS'    Point<3> normal = p;'
p18857
aS'    normal /= p.norm();'
p18858
aS'    return (-trace(hessian) + 2 * (gradient * normal) +'
p18859
aS'            (hessian * normal) * normal);'
p18860
aS'  }'
p18861
aS'  template <int spacedim>'
p18862
aS'  LaplaceBeltramiProblem<spacedim>::LaplaceBeltramiProblem('
p18863
aS'    const unsigned degree)'
p18864
aS'    : fe(degree)'
p18865
aS'    , dof_handler(triangulation)'
p18866
aS'    , mapping(degree)'
p18867
aS'  {}'
p18868
aS'  template <int spacedim>'
p18869
aS'  void LaplaceBeltramiProblem<spacedim>::make_grid_and_dofs()'
p18870
aS'  {'
p18871
aS'    {'
p18872
aS'      Triangulation<spacedim> volume_mesh;'
p18873
aS'      GridGenerator::half_hyper_ball(volume_mesh);'
p18874
aS'      std::set<types::boundary_id> boundary_ids;'
p18875
aS'      boundary_ids.insert(0);'
p18876
aS'      GridGenerator::extract_boundary_mesh(volume_mesh,'
p18877
aS'                                           triangulation,'
p18878
aS'                                           boundary_ids);'
p18879
aS'    }'
p18880
aS'    triangulation.set_all_manifold_ids(0);'
p18881
aS'    triangulation.set_manifold(0, SphericalManifold<dim, spacedim>());'
p18882
aS'    triangulation.refine_global(4);'
p18883
aS'    std::cout << "Surface mesh has " << triangulation.n_active_cells()'
p18884
aS'              << " cells." << std::endl;'
p18885
aS'    dof_handler.distribute_dofs(fe);'
p18886
aS'    std::cout << "Surface mesh has " << dof_handler.n_dofs()'
p18887
aS'              << " degrees of freedom." << std::endl;'
p18888
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p18889
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p18890
aS'    sparsity_pattern.copy_from(dsp);'
p18891
aS'    system_matrix.reinit(sparsity_pattern);'
p18892
aS'    solution.reinit(dof_handler.n_dofs());'
p18893
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p18894
aS'  }'
p18895
aS'  template <int spacedim>'
p18896
aS'  void LaplaceBeltramiProblem<spacedim>::assemble_system()'
p18897
aS'  {'
p18898
aS'    system_matrix = 0;'
p18899
aS'    system_rhs    = 0;'
p18900
aS'    const QGauss<dim>       quadrature_formula(2 * fe.degree);'
p18901
aS'    FEValues<dim, spacedim> fe_values(mapping,'
p18902
aS'                                      fe,'
p18903
aS'                                      quadrature_formula,'
p18904
aS'                                      update_values | update_gradients |'
p18905
aS'                                        update_quadrature_points |'
p18906
aS'                                        update_JxW_values);'
p18907
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p18908
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p18909
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p18910
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p18911
aS'    std::vector<double>                  rhs_values(n_q_points);'
p18912
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p18913
aS'    RightHandSide<spacedim> rhs;'
p18914
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p18915
aS'      {'
p18916
aS'        cell_matrix = 0;'
p18917
aS'        cell_rhs    = 0;'
p18918
aS'        fe_values.reinit(cell);'
p18919
aS'        rhs.value_list(fe_values.get_quadrature_points(), rhs_values);'
p18920
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18921
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p18922
aS'            for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p18923
aS'              cell_matrix(i, j) += fe_values.shape_grad(i, q_point) *'
p18924
aS'                                   fe_values.shape_grad(j, q_point) *'
p18925
aS'                                   fe_values.JxW(q_point);'
p18926
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18927
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p18928
aS'            cell_rhs(i) += fe_values.shape_value(i, q_point) *'
p18929
aS'                           rhs_values[q_point] * fe_values.JxW(q_point);'
p18930
aS'        cell->get_dof_indices(local_dof_indices);'
p18931
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18932
aS'          {'
p18933
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p18934
aS'              system_matrix.add(local_dof_indices[i],'
p18935
aS'                                local_dof_indices[j],'
p18936
aS'                                cell_matrix(i, j));'
p18937
aS'            system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p18938
aS'          }'
p18939
aS'      }'
p18940
aS'    std::map<types::global_dof_index, double> boundary_values;'
p18941
aS'    VectorTools::interpolate_boundary_values('
p18942
aS'      mapping, dof_handler, 0, Solution<spacedim>(), boundary_values);'
p18943
aS'    MatrixTools::apply_boundary_values('
p18944
aS'      boundary_values, system_matrix, solution, system_rhs, false);'
p18945
aS'  }'
p18946
aS'  template <int spacedim>'
p18947
aS'  void LaplaceBeltramiProblem<spacedim>::solve()'
p18948
aS'  {'
p18949
aS'    SolverControl solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());'
p18950
aS'    SolverCG<Vector<double>> cg(solver_control);'
p18951
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p18952
aS'    preconditioner.initialize(system_matrix, 1.2);'
p18953
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p18954
aS'  }'
p18955
aS'  template <int spacedim>'
p18956
aS'  void LaplaceBeltramiProblem<spacedim>::output_results() const'
p18957
aS'  {'
p18958
aS'    DataOut<dim, spacedim> data_out;'
p18959
aS'    data_out.attach_dof_handler(dof_handler);'
p18960
aS'    data_out.add_data_vector(solution,'
p18961
aS'                             "solution",'
p18962
aS'                             DataOut<dim, spacedim>::type_dof_data);'
p18963
aS'    data_out.build_patches(mapping, mapping.get_degree());'
p18964
aS'    const std::string filename ='
p18965
aS'      "solution-" + std::to_string(spacedim) + "d.vtk";'
p18966
aS'    std::ofstream output(filename);'
p18967
aS'    data_out.write_vtk(output);'
p18968
aS'  }'
p18969
aS'  template <int spacedim>'
p18970
aS'  void LaplaceBeltramiProblem<spacedim>::compute_error() const'
p18971
aS'  {'
p18972
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p18973
aS'    VectorTools::integrate_difference(mapping,'
p18974
aS'                                      dof_handler,'
p18975
aS'                                      solution,'
p18976
aS'                                      Solution<spacedim>(),'
p18977
aS'                                      difference_per_cell,'
p18978
aS'                                      QGauss<dim>(2 * fe.degree + 1),'
p18979
aS'                                      VectorTools::H1_norm);'
p18980
aS'    double h1_error = VectorTools::compute_global_error(triangulation,'
p18981
aS'                                                        difference_per_cell,'
p18982
aS'                                                        VectorTools::H1_norm);'
p18983
aS'    std::cout << "H1 error = " << h1_error << std::endl;'
p18984
aS'  }'
p18985
aS'  template <int spacedim>'
p18986
aS'  void LaplaceBeltramiProblem<spacedim>::run()'
p18987
aS'  {'
p18988
aS'    make_grid_and_dofs();'
p18989
aS'    assemble_system();'
p18990
aS'    solve();'
p18991
aS'    output_results();'
p18992
aS'    compute_error();'
p18993
aS'  }'
p18994
aS'} // namespace Step38'
p18995
aS'int main()'
p18996
ag24
aS'  try'
p18997
aS'    {'
p18998
aS'      using namespace Step38;'
p18999
aS'      LaplaceBeltramiProblem<3> laplace_beltrami;'
p19000
aS'      laplace_beltrami.run();'
p19001
aS'    }'
p19002
aS'  catch (std::exception &exc)'
p19003
aS'    {'
p19004
aS'      std::cerr << std::endl'
p19005
aS'                << std::endl'
p19006
aS'                << "----------------------------------------------------"'
p19007
aS'                << std::endl;'
p19008
aS'      std::cerr << "Exception on processing: " << std::endl'
p19009
aS'                << exc.what() << std::endl'
p19010
aS'                << "Aborting!" << std::endl'
p19011
aS'                << "----------------------------------------------------"'
p19012
aS'                << std::endl;'
p19013
aS'      return 1;'
p19014
aS'    }'
p19015
aS'  catch (...)'
p19016
aS'    {'
p19017
aS'      std::cerr << std::endl'
p19018
aS'                << std::endl'
p19019
aS'                << "----------------------------------------------------"'
p19020
aS'                << std::endl;'
p19021
aS'      std::cerr << "Unknown exception!" << std::endl'
p19022
aS'                << "Aborting!" << std::endl'
p19023
aS'                << "----------------------------------------------------"'
p19024
aS'                << std::endl;'
p19025
aS'      return 1;'
p19026
aS'    }'
p19027
aS'  return 0;'
p19028
ag32
aS'/* ---------------------------------------------------------------------'
p19029
aS' *'
p19030
aS' * Copyright (C) 2010 - 2020 by the deal.II authors'
p19031
aS' *'
p19032
aS' * This file is part of the deal.II library.'
p19033
aS' *'
p19034
aS' * The deal.II library is free software; you can use it, redistribute'
p19035
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p19036
aS' * Public License as published by the Free Software Foundation; either'
p19037
aS' * version 2.1 of the License, or (at your option) any later version.'
p19038
aS' * The full text of the license can be found in the file LICENSE.md at'
p19039
aS' * the top level directory of deal.II.'
p19040
aS' *'
p19041
aS' * ---------------------------------------------------------------------'
p19042
aS' *'
p19043
aS' * Author: Guido Kanschat, Texas A&M University, 2009'
p19044
aS' */'
p19045
aS'#include <deal.II/lac/sparse_matrix.h>'
p19046
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p19047
aS'#include <deal.II/lac/solver_cg.h>'
p19048
aS'#include <deal.II/lac/precondition.h>'
p19049
aS'#include <deal.II/lac/precondition_block.h>'
p19050
aS'#include <deal.II/lac/block_vector.h>'
p19051
aS'#include <deal.II/grid/grid_generator.h>'
p19052
aS'#include <deal.II/grid/grid_refinement.h>'
p19053
aS'#include <deal.II/fe/fe_q.h>'
p19054
aS'#include <deal.II/fe/fe_dgp.h>'
p19055
aS'#include <deal.II/fe/fe_dgq.h>'
p19056
aS'#include <deal.II/dofs/dof_tools.h>'
p19057
aS'#include <deal.II/meshworker/dof_info.h>'
p19058
aS'#include <deal.II/meshworker/integration_info.h>'
p19059
aS'#include <deal.II/meshworker/assembler.h>'
p19060
aS'#include <deal.II/meshworker/loop.h>'
p19061
aS'#include <deal.II/integrators/laplace.h>'
p19062
aS'#include <deal.II/multigrid/mg_tools.h>'
p19063
aS'#include <deal.II/multigrid/multigrid.h>'
p19064
aS'#include <deal.II/multigrid/mg_matrix.h>'
p19065
aS'#include <deal.II/multigrid/mg_transfer.h>'
p19066
aS'#include <deal.II/multigrid/mg_coarse.h>'
p19067
aS'#include <deal.II/multigrid/mg_smoother.h>'
p19068
aS'#include <deal.II/base/function_lib.h>'
p19069
aS'#include <deal.II/base/quadrature_lib.h>'
p19070
aS'#include <deal.II/numerics/vector_tools.h>'
p19071
aS'#include <deal.II/numerics/data_out.h>'
p19072
aS'#include <iostream>'
p19073
aS'#include <fstream>'
p19074
aS'namespace Step39'
p19075
ag24
aS'  using namespace dealii;'
p19076
aS'  Functions::SlitSingularityFunction<2> exact_solution;'
p19077
aS'  template <int dim>'
p19078
aS'  class MatrixIntegrator : public MeshWorker::LocalIntegrator<dim>'
p19079
aS'  {'
p19080
aS'  public:'
p19081
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19082
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19083
aS'    void'
p19084
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19085
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19086
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19087
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19088
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p19089
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p19090
aS'  };'
p19091
aS'  template <int dim>'
p19092
aS'  void MatrixIntegrator<dim>::cell('
p19093
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p19094
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p19095
aS'  {'
p19096
aS'    LocalIntegrators::Laplace::cell_matrix(dinfo.matrix(0, false).matrix,'
p19097
aS'                                           info.fe_values());'
p19098
aS'  }'
p19099
aS'  template <int dim>'
p19100
aS'  void MatrixIntegrator<dim>::boundary('
p19101
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p19102
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p19103
aS'  {'
p19104
aS'    const unsigned int degree = info.fe_values(0).get_fe().tensor_degree();'
p19105
aS'    LocalIntegrators::Laplace::nitsche_matrix('
p19106
aS'      dinfo.matrix(0, false).matrix,'
p19107
aS'      info.fe_values(0),'
p19108
aS'      LocalIntegrators::Laplace::compute_penalty(dinfo, dinfo, degree, degree));'
p19109
aS'  }'
p19110
aS'  template <int dim>'
p19111
aS'  void MatrixIntegrator<dim>::face('
p19112
aS'    MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19113
aS'    MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19114
aS'    typename MeshWorker::IntegrationInfo<dim> &info1,'
p19115
aS'    typename MeshWorker::IntegrationInfo<dim> &info2) const'
p19116
aS'  {'
p19117
aS'    const unsigned int degree = info1.fe_values(0).get_fe().tensor_degree();'
p19118
aS'    LocalIntegrators::Laplace::ip_matrix('
p19119
aS'      dinfo1.matrix(0, false).matrix,'
p19120
aS'      dinfo1.matrix(0, true).matrix,'
p19121
aS'      dinfo2.matrix(0, true).matrix,'
p19122
aS'      dinfo2.matrix(0, false).matrix,'
p19123
aS'      info1.fe_values(0),'
p19124
aS'      info2.fe_values(0),'
p19125
aS'      LocalIntegrators::Laplace::compute_penalty('
p19126
aS'        dinfo1, dinfo2, degree, degree));'
p19127
aS'  }'
p19128
aS'  template <int dim>'
p19129
aS'  class RHSIntegrator : public MeshWorker::LocalIntegrator<dim>'
p19130
aS'  {'
p19131
aS'  public:'
p19132
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19133
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19134
aS'    void'
p19135
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19136
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19137
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19138
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19139
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p19140
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p19141
aS'  };'
p19142
aS'  template <int dim>'
p19143
aS'  void'
p19144
aS'  RHSIntegrator<dim>::cell(MeshWorker::DoFInfo<dim> &,'
p19145
aS'                           typename MeshWorker::IntegrationInfo<dim> &) const'
p19146
aS'  {}'
p19147
aS'  template <int dim>'
p19148
aS'  void RHSIntegrator<dim>::boundary('
p19149
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p19150
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p19151
aS'  {'
p19152
aS'    const FEValuesBase<dim> &fe           = info.fe_values();'
p19153
aS'    Vector<double> &         local_vector = dinfo.vector(0).block(0);'
p19154
aS'    std::vector<double> boundary_values(fe.n_quadrature_points);'
p19155
aS'    exact_solution.value_list(fe.get_quadrature_points(), boundary_values);'
p19156
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p19157
aS'    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() /'
p19158
aS'                           dinfo.cell->measure();'
p19159
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19160
aS'      for (unsigned int i = 0; i < fe.dofs_per_cell; ++i)'
p19161
aS'        local_vector(i) +='
p19162
aS'          (-penalty * fe.shape_value(i, k)              // (-sigma * v_i(x_k)'
p19163
aS'           + fe.normal_vector(k) * fe.shape_grad(i, k)) // + n * grad v_i(x_k))'
p19164
aS'          * boundary_values[k] * fe.JxW(k);             // u^D(x_k) * dx'
p19165
aS'  }'
p19166
aS'  template <int dim>'
p19167
aS'  void'
p19168
aS'  RHSIntegrator<dim>::face(MeshWorker::DoFInfo<dim> &,'
p19169
aS'                           MeshWorker::DoFInfo<dim> &,'
p19170
aS'                           typename MeshWorker::IntegrationInfo<dim> &,'
p19171
aS'                           typename MeshWorker::IntegrationInfo<dim> &) const'
p19172
aS'  {}'
p19173
aS'  template <int dim>'
p19174
aS'  class Estimator : public MeshWorker::LocalIntegrator<dim>'
p19175
aS'  {'
p19176
aS'  public:'
p19177
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19178
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19179
aS'    void'
p19180
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19181
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19182
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19183
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19184
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p19185
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p19186
aS'  };'
p19187
aS'  template <int dim>'
p19188
aS'  void'
p19189
aS'  Estimator<dim>::cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19190
aS'                       typename MeshWorker::IntegrationInfo<dim> &info) const'
p19191
aS'  {'
p19192
aS'    const FEValuesBase<dim> &fe = info.fe_values();'
p19193
aS'    const std::vector<Tensor<2, dim>> &DDuh = info.hessians[0][0];'
p19194
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19195
aS'      {'
p19196
aS'        const double t = dinfo.cell->diameter() * trace(DDuh[k]);'
p19197
aS'        dinfo.value(0) += t * t * fe.JxW(k);'
p19198
aS'      }'
p19199
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p19200
aS'  }'
p19201
aS'  template <int dim>'
p19202
aS'  void Estimator<dim>::boundary('
p19203
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p19204
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p19205
aS'  {'
p19206
aS'    const FEValuesBase<dim> &fe = info.fe_values();'
p19207
aS'    std::vector<double> boundary_values(fe.n_quadrature_points);'
p19208
aS'    exact_solution.value_list(fe.get_quadrature_points(), boundary_values);'
p19209
aS'    const std::vector<double> &uh = info.values[0][0];'
p19210
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p19211
aS'    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() /'
p19212
aS'                           dinfo.cell->measure();'
p19213
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19214
aS'      {'
p19215
aS'        const double diff = boundary_values[k] - uh[k];'
p19216
aS'        dinfo.value(0) += penalty * diff * diff * fe.JxW(k);'
p19217
aS'      }'
p19218
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p19219
aS'  }'
p19220
aS'  template <int dim>'
p19221
aS'  void'
p19222
aS'  Estimator<dim>::face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19223
aS'                       MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19224
aS'                       typename MeshWorker::IntegrationInfo<dim> &info1,'
p19225
aS'                       typename MeshWorker::IntegrationInfo<dim> &info2) const'
p19226
aS'  {'
p19227
aS'    const FEValuesBase<dim> &          fe   = info1.fe_values();'
p19228
aS'    const std::vector<double> &        uh1  = info1.values[0][0];'
p19229
aS'    const std::vector<double> &        uh2  = info2.values[0][0];'
p19230
aS'    const std::vector<Tensor<1, dim>> &Duh1 = info1.gradients[0][0];'
p19231
aS'    const std::vector<Tensor<1, dim>> &Duh2 = info2.gradients[0][0];'
p19232
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p19233
aS'    const double       penalty1 ='
p19234
aS'      degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();'
p19235
aS'    const double penalty2 ='
p19236
aS'      degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();'
p19237
aS'    const double penalty = penalty1 + penalty2;'
p19238
aS'    const double h       = dinfo1.face->measure();'
p19239
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19240
aS'      {'
p19241
aS'        const double diff1 = uh1[k] - uh2[k];'
p19242
aS'        const double diff2 ='
p19243
aS'          fe.normal_vector(k) * Duh1[k] - fe.normal_vector(k) * Duh2[k];'
p19244
aS'        dinfo1.value(0) +='
p19245
aS'          (penalty * diff1 * diff1 + h * diff2 * diff2) * fe.JxW(k);'
p19246
aS'      }'
p19247
aS'    dinfo1.value(0) = std::sqrt(dinfo1.value(0));'
p19248
aS'    dinfo2.value(0) = dinfo1.value(0);'
p19249
aS'  }'
p19250
aS'  template <int dim>'
p19251
aS'  class ErrorIntegrator : public MeshWorker::LocalIntegrator<dim>'
p19252
aS'  {'
p19253
aS'  public:'
p19254
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19255
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19256
aS'    void'
p19257
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p19258
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p19259
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19260
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19261
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p19262
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p19263
aS'  };'
p19264
aS'  template <int dim>'
p19265
aS'  void ErrorIntegrator<dim>::cell('
p19266
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p19267
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p19268
aS'  {'
p19269
aS'    const FEValuesBase<dim> &   fe = info.fe_values();'
p19270
aS'    std::vector<Tensor<1, dim>> exact_gradients(fe.n_quadrature_points);'
p19271
aS'    std::vector<double>         exact_values(fe.n_quadrature_points);'
p19272
aS'    exact_solution.gradient_list(fe.get_quadrature_points(), exact_gradients);'
p19273
aS'    exact_solution.value_list(fe.get_quadrature_points(), exact_values);'
p19274
aS'    const std::vector<Tensor<1, dim>> &Duh = info.gradients[0][0];'
p19275
aS'    const std::vector<double> &        uh  = info.values[0][0];'
p19276
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19277
aS'      {'
p19278
aS'        double sum = 0;'
p19279
aS'        for (unsigned int d = 0; d < dim; ++d)'
p19280
aS'          {'
p19281
aS'            const double diff = exact_gradients[k][d] - Duh[k][d];'
p19282
aS'            sum += diff * diff;'
p19283
aS'          }'
p19284
aS'        const double diff = exact_values[k] - uh[k];'
p19285
aS'        dinfo.value(0) += sum * fe.JxW(k);'
p19286
aS'        dinfo.value(1) += diff * diff * fe.JxW(k);'
p19287
aS'      }'
p19288
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p19289
aS'    dinfo.value(1) = std::sqrt(dinfo.value(1));'
p19290
aS'  }'
p19291
aS'  template <int dim>'
p19292
aS'  void ErrorIntegrator<dim>::boundary('
p19293
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p19294
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p19295
aS'  {'
p19296
aS'    const FEValuesBase<dim> &fe = info.fe_values();'
p19297
aS'    std::vector<double> exact_values(fe.n_quadrature_points);'
p19298
aS'    exact_solution.value_list(fe.get_quadrature_points(), exact_values);'
p19299
aS'    const std::vector<double> &uh = info.values[0][0];'
p19300
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p19301
aS'    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() /'
p19302
aS'                           dinfo.cell->measure();'
p19303
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19304
aS'      {'
p19305
aS'        const double diff = exact_values[k] - uh[k];'
p19306
aS'        dinfo.value(0) += penalty * diff * diff * fe.JxW(k);'
p19307
aS'      }'
p19308
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p19309
aS'  }'
p19310
aS'  template <int dim>'
p19311
aS'  void ErrorIntegrator<dim>::face('
p19312
aS'    MeshWorker::DoFInfo<dim> &                 dinfo1,'
p19313
aS'    MeshWorker::DoFInfo<dim> &                 dinfo2,'
p19314
aS'    typename MeshWorker::IntegrationInfo<dim> &info1,'
p19315
aS'    typename MeshWorker::IntegrationInfo<dim> &info2) const'
p19316
aS'  {'
p19317
aS'    const FEValuesBase<dim> &  fe  = info1.fe_values();'
p19318
aS'    const std::vector<double> &uh1 = info1.values[0][0];'
p19319
aS'    const std::vector<double> &uh2 = info2.values[0][0];'
p19320
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p19321
aS'    const double       penalty1 ='
p19322
aS'      degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();'
p19323
aS'    const double penalty2 ='
p19324
aS'      degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();'
p19325
aS'    const double penalty = penalty1 + penalty2;'
p19326
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p19327
aS'      {'
p19328
aS'        const double diff = uh1[k] - uh2[k];'
p19329
aS'        dinfo1.value(0) += (penalty * diff * diff) * fe.JxW(k);'
p19330
aS'      }'
p19331
aS'    dinfo1.value(0) = std::sqrt(dinfo1.value(0));'
p19332
aS'    dinfo2.value(0) = dinfo1.value(0);'
p19333
aS'  }'
p19334
aS'  template <int dim>'
p19335
aS'  class InteriorPenaltyProblem'
p19336
aS'  {'
p19337
aS'  public:'
p19338
aS'    using CellInfo = MeshWorker::IntegrationInfo<dim>;'
p19339
aS'    InteriorPenaltyProblem(const FiniteElement<dim> &fe);'
p19340
aS'    void run(unsigned int n_steps);'
p19341
aS'  private:'
p19342
aS'    void   setup_system();'
p19343
aS'    void   assemble_matrix();'
p19344
aS'    void   assemble_mg_matrix();'
p19345
aS'    void   assemble_right_hand_side();'
p19346
aS'    void   error();'
p19347
aS'    double estimate();'
p19348
aS'    void   solve();'
p19349
aS'    void   output_results(const unsigned int cycle) const;'
p19350
aS'    Triangulation<dim>        triangulation;'
p19351
aS'    const MappingQ1<dim>      mapping;'
p19352
aS'    const FiniteElement<dim> &fe;'
p19353
aS'    DoFHandler<dim>           dof_handler;'
p19354
aS'    SparsityPattern      sparsity;'
p19355
aS'    SparseMatrix<double> matrix;'
p19356
aS'    Vector<double>       solution;'
p19357
aS'    Vector<double>       right_hand_side;'
p19358
aS'    BlockVector<double>  estimates;'
p19359
aS'    MGLevelObject<SparsityPattern>      mg_sparsity;'
p19360
aS'    MGLevelObject<SparseMatrix<double>> mg_matrix;'
p19361
aS'    MGLevelObject<SparsityPattern> mg_sparsity_dg_interface;'
p19362
aS'    MGLevelObject<SparseMatrix<double>> mg_matrix_dg_down;'
p19363
aS'    MGLevelObject<SparseMatrix<double>> mg_matrix_dg_up;'
p19364
aS'  };'
p19365
aS'  template <int dim>'
p19366
aS'  InteriorPenaltyProblem<dim>::InteriorPenaltyProblem('
p19367
aS'    const FiniteElement<dim> &fe)'
p19368
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p19369
aS'    , mapping()'
p19370
aS'    , fe(fe)'
p19371
aS'    , dof_handler(triangulation)'
p19372
aS'    , estimates(1)'
p19373
aS'  {'
p19374
aS'    GridGenerator::hyper_cube_slit(triangulation, -1, 1);'
p19375
aS'  }'
p19376
aS'  template <int dim>'
p19377
aS'  void InteriorPenaltyProblem<dim>::setup_system()'
p19378
aS'  {'
p19379
aS'    dof_handler.distribute_dofs(fe);'
p19380
aS'    dof_handler.distribute_mg_dofs();'
p19381
aS'    unsigned int n_dofs = dof_handler.n_dofs();'
p19382
aS'    solution.reinit(n_dofs);'
p19383
aS'    right_hand_side.reinit(n_dofs);'
p19384
aS'    DynamicSparsityPattern dsp(n_dofs);'
p19385
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p19386
aS'    sparsity.copy_from(dsp);'
p19387
aS'    matrix.reinit(sparsity);'
p19388
aS'    const unsigned int n_levels = triangulation.n_levels();'
p19389
aS'    mg_matrix.resize(0, n_levels - 1);'
p19390
aS'    mg_matrix.clear_elements();'
p19391
aS'    mg_matrix_dg_up.resize(0, n_levels - 1);'
p19392
aS'    mg_matrix_dg_up.clear_elements();'
p19393
aS'    mg_matrix_dg_down.resize(0, n_levels - 1);'
p19394
aS'    mg_matrix_dg_down.clear_elements();'
p19395
aS'    mg_sparsity.resize(0, n_levels - 1);'
p19396
aS'    mg_sparsity_dg_interface.resize(0, n_levels - 1);'
p19397
aS'    for (unsigned int level = mg_sparsity.min_level();'
p19398
aS'         level <= mg_sparsity.max_level();'
p19399
aS'         ++level)'
p19400
aS'      {'
p19401
aS'        DynamicSparsityPattern dsp(dof_handler.n_dofs(level));'
p19402
aS'        MGTools::make_flux_sparsity_pattern(dof_handler, dsp, level);'
p19403
aS'        mg_sparsity[level].copy_from(dsp);'
p19404
aS'        mg_matrix[level].reinit(mg_sparsity[level]);'
p19405
aS'        if (level > 0)'
p19406
aS'          {'
p19407
aS'            DynamicSparsityPattern dsp;'
p19408
aS'            dsp.reinit(dof_handler.n_dofs(level - 1),'
p19409
aS'                       dof_handler.n_dofs(level));'
p19410
aS'            MGTools::make_flux_sparsity_pattern_edge(dof_handler, dsp, level);'
p19411
aS'            mg_sparsity_dg_interface[level].copy_from(dsp);'
p19412
aS'            mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]);'
p19413
aS'            mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]);'
p19414
aS'          }'
p19415
aS'      }'
p19416
aS'  }'
p19417
aS'  template <int dim>'
p19418
aS'  void InteriorPenaltyProblem<dim>::assemble_matrix()'
p19419
aS'  {'
p19420
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p19421
aS'    UpdateFlags update_flags = update_values | update_gradients;'
p19422
aS'    info_box.add_update_flags_all(update_flags);'
p19423
aS'    info_box.initialize(fe, mapping);'
p19424
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p19425
aS'    MeshWorker::Assembler::MatrixSimple<SparseMatrix<double>> assembler;'
p19426
aS'    assembler.initialize(matrix);'
p19427
aS'    MatrixIntegrator<dim> integrator;'
p19428
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p19429
aS'                                           dof_handler.end(),'
p19430
aS'                                           dof_info,'
p19431
aS'                                           info_box,'
p19432
aS'                                           integrator,'
p19433
aS'                                           assembler);'
p19434
aS'  }'
p19435
aS'  template <int dim>'
p19436
aS'  void InteriorPenaltyProblem<dim>::assemble_mg_matrix()'
p19437
aS'  {'
p19438
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p19439
aS'    UpdateFlags update_flags = update_values | update_gradients;'
p19440
aS'    info_box.add_update_flags_all(update_flags);'
p19441
aS'    info_box.initialize(fe, mapping);'
p19442
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p19443
aS'    MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler;'
p19444
aS'    assembler.initialize(mg_matrix);'
p19445
aS'    assembler.initialize_fluxes(mg_matrix_dg_up, mg_matrix_dg_down);'
p19446
aS'    MatrixIntegrator<dim> integrator;'
p19447
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_mg(),'
p19448
aS'                                           dof_handler.end_mg(),'
p19449
aS'                                           dof_info,'
p19450
aS'                                           info_box,'
p19451
aS'                                           integrator,'
p19452
aS'                                           assembler);'
p19453
aS'  }'
p19454
aS'  template <int dim>'
p19455
aS'  void InteriorPenaltyProblem<dim>::assemble_right_hand_side()'
p19456
aS'  {'
p19457
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p19458
aS'    UpdateFlags                         update_flags ='
p19459
aS'      update_quadrature_points | update_values | update_gradients;'
p19460
aS'    info_box.add_update_flags_all(update_flags);'
p19461
aS'    info_box.initialize(fe, mapping);'
p19462
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p19463
aS'    MeshWorker::Assembler::ResidualSimple<Vector<double>> assembler;'
p19464
aS'    AnyData                                               data;'
p19465
aS'    data.add<Vector<double> *>(&right_hand_side, "RHS");'
p19466
aS'    assembler.initialize(data);'
p19467
aS'    RHSIntegrator<dim> integrator;'
p19468
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p19469
aS'                                           dof_handler.end(),'
p19470
aS'                                           dof_info,'
p19471
aS'                                           info_box,'
p19472
aS'                                           integrator,'
p19473
aS'                                           assembler);'
p19474
aS'    right_hand_side *= -1.;'
p19475
aS'  }'
p19476
aS'  template <int dim>'
p19477
aS'  void InteriorPenaltyProblem<dim>::solve()'
p19478
aS'  {'
p19479
aS'    SolverControl            control(1000, 1.e-12);'
p19480
aS'    SolverCG<Vector<double>> solver(control);'
p19481
aS'    MGTransferPrebuilt<Vector<double>> mg_transfer;'
p19482
aS'    mg_transfer.build(dof_handler);'
p19483
aS'    FullMatrix<double> coarse_matrix;'
p19484
aS'    coarse_matrix.copy_from(mg_matrix[0]);'
p19485
aS'    MGCoarseGridHouseholder<double, Vector<double>> mg_coarse;'
p19486
aS'    mg_coarse.initialize(coarse_matrix);'
p19487
aS'    GrowingVectorMemory<Vector<double>> mem;'
p19488
aS'    using RELAXATION = PreconditionSOR<SparseMatrix<double>>;'
p19489
aS'    mg::SmootherRelaxation<RELAXATION, Vector<double>> mg_smoother;'
p19490
aS'    RELAXATION::AdditionalData                         smoother_data(1.);'
p19491
aS'    mg_smoother.initialize(mg_matrix, smoother_data);'
p19492
aS'    mg_smoother.set_steps(2);'
p19493
aS'    mg_smoother.set_symmetric(true);'
p19494
aS'    mg_smoother.set_variable(false);'
p19495
aS'    mg::Matrix<Vector<double>> mgmatrix(mg_matrix);'
p19496
aS'    mg::Matrix<Vector<double>> mgdown(mg_matrix_dg_down);'
p19497
aS'    mg::Matrix<Vector<double>> mgup(mg_matrix_dg_up);'
p19498
aS'    Multigrid<Vector<double>> mg('
p19499
aS'      mgmatrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p19500
aS'    mg.set_edge_flux_matrices(mgdown, mgup);'
p19501
aS'    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p19502
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p19503
aS'    solver.solve(matrix, solution, right_hand_side, preconditioner);'
p19504
aS'  }'
p19505
aS'  template <int dim>'
p19506
aS'  double InteriorPenaltyProblem<dim>::estimate()'
p19507
aS'  {'
p19508
aS'    std::vector<unsigned int> old_user_indices;'
p19509
aS'    triangulation.save_user_indices(old_user_indices);'
p19510
aS'    estimates.block(0).reinit(triangulation.n_active_cells());'
p19511
aS'    unsigned int i = 0;'
p19512
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p19513
aS'      cell->set_user_index(i++);'
p19514
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p19515
aS'    const unsigned int                  n_gauss_points ='
p19516
aS'      dof_handler.get_fe().tensor_degree() + 1;'
p19517
aS'    info_box.initialize_gauss_quadrature(n_gauss_points,'
p19518
aS'                                         n_gauss_points + 1,'
p19519
aS'                                         n_gauss_points);'
p19520
aS'    AnyData solution_data;'
p19521
aS'    solution_data.add<const Vector<double> *>(&solution, "solution");'
p19522
aS'    info_box.cell_selector.add("solution", false, false, true);'
p19523
aS'    info_box.boundary_selector.add("solution", true, true, false);'
p19524
aS'    info_box.face_selector.add("solution", true, true, false);'
p19525
aS'    info_box.add_update_flags_boundary(update_quadrature_points);'
p19526
aS'    info_box.initialize(fe, mapping, solution_data, solution);'
p19527
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p19528
aS'    MeshWorker::Assembler::CellsAndFaces<double> assembler;'
p19529
aS'    AnyData                                      out_data;'
p19530
aS'    out_data.add<BlockVector<double> *>(&estimates, "cells");'
p19531
aS'    assembler.initialize(out_data, false);'
p19532
aS'    Estimator<dim> integrator;'
p19533
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p19534
aS'                                           dof_handler.end(),'
p19535
aS'                                           dof_info,'
p19536
aS'                                           info_box,'
p19537
aS'                                           integrator,'
p19538
aS'                                           assembler);'
p19539
aS'    triangulation.load_user_indices(old_user_indices);'
p19540
aS'    return estimates.block(0).l2_norm();'
p19541
aS'  }'
p19542
aS'  template <int dim>'
p19543
aS'  void InteriorPenaltyProblem<dim>::error()'
p19544
aS'  {'
p19545
aS'    BlockVector<double> errors(2);'
p19546
aS'    errors.block(0).reinit(triangulation.n_active_cells());'
p19547
aS'    errors.block(1).reinit(triangulation.n_active_cells());'
p19548
aS'    std::vector<unsigned int> old_user_indices;'
p19549
aS'    triangulation.save_user_indices(old_user_indices);'
p19550
aS'    unsigned int i = 0;'
p19551
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p19552
aS'      cell->set_user_index(i++);'
p19553
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p19554
aS'    const unsigned int                  n_gauss_points ='
p19555
aS'      dof_handler.get_fe().tensor_degree() + 1;'
p19556
aS'    info_box.initialize_gauss_quadrature(n_gauss_points,'
p19557
aS'                                         n_gauss_points + 1,'
p19558
aS'                                         n_gauss_points);'
p19559
aS'    AnyData solution_data;'
p19560
aS'    solution_data.add<Vector<double> *>(&solution, "solution");'
p19561
aS'    info_box.cell_selector.add("solution", true, true, false);'
p19562
aS'    info_box.boundary_selector.add("solution", true, false, false);'
p19563
aS'    info_box.face_selector.add("solution", true, false, false);'
p19564
aS'    info_box.add_update_flags_cell(update_quadrature_points);'
p19565
aS'    info_box.add_update_flags_boundary(update_quadrature_points);'
p19566
aS'    info_box.initialize(fe, mapping, solution_data, solution);'
p19567
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p19568
aS'    MeshWorker::Assembler::CellsAndFaces<double> assembler;'
p19569
aS'    AnyData                                      out_data;'
p19570
aS'    out_data.add<BlockVector<double> *>(&errors, "cells");'
p19571
aS'    assembler.initialize(out_data, false);'
p19572
aS'    ErrorIntegrator<dim> integrator;'
p19573
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p19574
aS'                                           dof_handler.end(),'
p19575
aS'                                           dof_info,'
p19576
aS'                                           info_box,'
p19577
aS'                                           integrator,'
p19578
aS'                                           assembler);'
p19579
aS'    triangulation.load_user_indices(old_user_indices);'
p19580
aS'    deallog << "energy-error: " << errors.block(0).l2_norm() << std::endl;'
p19581
aS'    deallog << "L2-error:     " << errors.block(1).l2_norm() << std::endl;'
p19582
aS'  }'
p19583
aS'  template <int dim>'
p19584
aS'  void'
p19585
aS'  InteriorPenaltyProblem<dim>::output_results(const unsigned int cycle) const'
p19586
aS'  {'
p19587
aS'    const std::string filename ='
p19588
aS'      "sol-" + Utilities::int_to_string(cycle, 2) + ".gnuplot";'
p19589
aS'    deallog << "Writing solution to <" << filename << ">..." << std::endl'
p19590
aS'            << std::endl;'
p19591
aS'    std::ofstream gnuplot_output(filename);'
p19592
aS'    DataOut<dim> data_out;'
p19593
aS'    data_out.attach_dof_handler(dof_handler);'
p19594
aS'    data_out.add_data_vector(solution, "u");'
p19595
aS'    data_out.add_data_vector(estimates.block(0), "est");'
p19596
aS'    data_out.build_patches();'
p19597
aS'    data_out.write_gnuplot(gnuplot_output);'
p19598
aS'  }'
p19599
aS'  template <int dim>'
p19600
aS'  void InteriorPenaltyProblem<dim>::run(unsigned int n_steps)'
p19601
aS'  {'
p19602
aS'    deallog << "Element: " << fe.get_name() << std::endl;'
p19603
aS'    for (unsigned int s = 0; s < n_steps; ++s)'
p19604
aS'      {'
p19605
aS'        deallog << "Step " << s << std::endl;'
p19606
aS'        if (estimates.block(0).size() == 0)'
p19607
aS'          triangulation.refine_global(1);'
p19608
aS'        else'
p19609
aS'          {'
p19610
aS'            GridRefinement::refine_and_coarsen_fixed_fraction('
p19611
aS'              triangulation, estimates.block(0), 0.5, 0.0);'
p19612
aS'            triangulation.execute_coarsening_and_refinement();'
p19613
aS'          }'
p19614
aS'        deallog << "Triangulation " << triangulation.n_active_cells()'
p19615
aS'                << " cells, " << triangulation.n_levels() << " levels"'
p19616
aS'                << std::endl;'
p19617
aS'        setup_system();'
p19618
aS'        deallog << "DoFHandler " << dof_handler.n_dofs() << " dofs, level dofs";'
p19619
aS'        for (unsigned int l = 0; l < triangulation.n_levels(); ++l)'
p19620
aS"          deallog << ' ' << dof_handler.n_dofs(l);"
p19621
aS'        deallog << std::endl;'
p19622
aS'        deallog << "Assemble matrix" << std::endl;'
p19623
aS'        assemble_matrix();'
p19624
aS'        deallog << "Assemble multilevel matrix" << std::endl;'
p19625
aS'        assemble_mg_matrix();'
p19626
aS'        deallog << "Assemble right hand side" << std::endl;'
p19627
aS'        assemble_right_hand_side();'
p19628
aS'        deallog << "Solve" << std::endl;'
p19629
aS'        solve();'
p19630
aS'        error();'
p19631
aS'        deallog << "Estimate " << estimate() << std::endl;'
p19632
aS'        output_results(s);'
p19633
aS'      }'
p19634
aS'  }'
p19635
aS'} // namespace Step39'
p19636
aS'int main()'
p19637
ag24
aS'  try'
p19638
aS'    {'
p19639
aS'      using namespace dealii;'
p19640
aS'      using namespace Step39;'
p19641
aS'      deallog.depth_console(2);'
p19642
aS'      std::ofstream logfile("deallog");'
p19643
aS'      deallog.attach(logfile);'
p19644
aS'      FE_DGQ<2>                 fe1(3);'
p19645
aS'      InteriorPenaltyProblem<2> test1(fe1);'
p19646
aS'      test1.run(12);'
p19647
aS'    }'
p19648
aS'  catch (std::exception &exc)'
p19649
aS'    {'
p19650
aS'      std::cerr << std::endl'
p19651
aS'                << std::endl'
p19652
aS'                << "----------------------------------------------------"'
p19653
aS'                << std::endl;'
p19654
aS'      std::cerr << "Exception on processing: " << std::endl'
p19655
aS'                << exc.what() << std::endl'
p19656
aS'                << "Aborting!" << std::endl'
p19657
aS'                << "----------------------------------------------------"'
p19658
aS'                << std::endl;'
p19659
aS'      return 1;'
p19660
aS'    }'
p19661
aS'  catch (...)'
p19662
aS'    {'
p19663
aS'      std::cerr << std::endl'
p19664
aS'                << std::endl'
p19665
aS'                << "----------------------------------------------------"'
p19666
aS'                << std::endl;'
p19667
aS'      std::cerr << "Unknown exception!" << std::endl'
p19668
aS'                << "Aborting!" << std::endl'
p19669
aS'                << "----------------------------------------------------"'
p19670
aS'                << std::endl;'
p19671
aS'      return 1;'
p19672
aS'    }'
p19673
aS'  return 0;'
p19674
ag32
aS'/* ---------------------------------------------------------------------'
p19675
aS' *'
p19676
aS' * Copyright (C) 1999 - 2021 by the deal.II authors'
p19677
aS' *'
p19678
aS' * This file is part of the deal.II library.'
p19679
aS' *'
p19680
aS' * The deal.II library is free software; you can use it, redistribute'
p19681
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p19682
aS' * Public License as published by the Free Software Foundation; either'
p19683
aS' * version 2.1 of the License, or (at your option) any later version.'
p19684
aS' * The full text of the license can be found in the file LICENSE.md at'
p19685
aS' * the top level directory of deal.II.'
p19686
aS' *'
p19687
aS' * ---------------------------------------------------------------------'
p19688
aS' *'
p19689
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 1999'
p19690
aS' */'
p19691
aS'#include <deal.II/grid/tria.h>'
p19692
aS'#include <deal.II/dofs/dof_handler.h>'
p19693
aS'#include <deal.II/grid/grid_generator.h>'
p19694
aS'#include <deal.II/fe/fe_q.h>'
p19695
aS'#include <deal.II/dofs/dof_tools.h>'
p19696
aS'#include <deal.II/fe/fe_values.h>'
p19697
aS'#include <deal.II/base/quadrature_lib.h>'
p19698
aS'#include <deal.II/base/function.h>'
p19699
aS'#include <deal.II/numerics/vector_tools.h>'
p19700
aS'#include <deal.II/numerics/matrix_tools.h>'
p19701
aS'#include <deal.II/lac/vector.h>'
p19702
aS'#include <deal.II/lac/full_matrix.h>'
p19703
aS'#include <deal.II/lac/sparse_matrix.h>'
p19704
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p19705
aS'#include <deal.II/lac/solver_cg.h>'
p19706
aS'#include <deal.II/lac/precondition.h>'
p19707
aS'#include <deal.II/numerics/data_out.h>'
p19708
aS'#include <fstream>'
p19709
aS'#include <iostream>'
p19710
aS'#include <deal.II/base/logstream.h>'
p19711
aS'using namespace dealii;'
p19712
aS'template <int dim>'
p19713
aS'class Step4'
p19714
ag24
aS'public:'
p19715
aS'  Step4();'
p19716
aS'  void run();'
p19717
aS'private:'
p19718
aS'  void make_grid();'
p19719
aS'  void setup_system();'
p19720
aS'  void assemble_system();'
p19721
aS'  void solve();'
p19722
aS'  void output_results() const;'
p19723
aS'  Triangulation<dim> triangulation;'
p19724
aS'  FE_Q<dim>          fe;'
p19725
aS'  DoFHandler<dim>    dof_handler;'
p19726
aS'  SparsityPattern      sparsity_pattern;'
p19727
aS'  SparseMatrix<double> system_matrix;'
p19728
aS'  Vector<double> solution;'
p19729
aS'  Vector<double> system_rhs;'
p19730
aS'};'
p19731
aS'template <int dim>'
p19732
aS'class RightHandSide : public Function<dim>'
p19733
ag24
aS'public:'
p19734
aS'  virtual double value(const Point<dim> & p,'
p19735
aS'                       const unsigned int component = 0) const override;'
p19736
aS'};'
p19737
aS'template <int dim>'
p19738
aS'class BoundaryValues : public Function<dim>'
p19739
ag24
aS'public:'
p19740
aS'  virtual double value(const Point<dim> & p,'
p19741
aS'                       const unsigned int component = 0) const override;'
p19742
aS'};'
p19743
aS'template <int dim>'
p19744
aS'double RightHandSide<dim>::value(const Point<dim> &p,'
p19745
aS'                                 const unsigned int /*component*/) const'
p19746
ag24
aS'  double return_value = 0.0;'
p19747
aS'  for (unsigned int i = 0; i < dim; ++i)'
p19748
aS'    return_value += 4.0 * std::pow(p(i), 4.0);'
p19749
aS'  return return_value;'
p19750
ag32
aS'template <int dim>'
p19751
aS'double BoundaryValues<dim>::value(const Point<dim> &p,'
p19752
aS'                                  const unsigned int /*component*/) const'
p19753
ag24
aS'  return p.square();'
p19754
ag32
aS'template <int dim>'
p19755
aS'Step4<dim>::Step4()'
p19756
aS'  : fe(1)'
p19757
aS'  , dof_handler(triangulation)'
p19758
aS'{}'
p19759
aS'template <int dim>'
p19760
aS'void Step4<dim>::make_grid()'
p19761
ag24
aS'  GridGenerator::hyper_cube(triangulation, -1, 1);'
p19762
aS'  triangulation.refine_global(4);'
p19763
aS'  std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p19764
aS'            << std::endl'
p19765
aS'            << "   Total number of cells: " << triangulation.n_cells()'
p19766
aS'            << std::endl;'
p19767
ag32
aS'template <int dim>'
p19768
aS'void Step4<dim>::setup_system()'
p19769
ag24
aS'  dof_handler.distribute_dofs(fe);'
p19770
aS'  std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p19771
aS'            << std::endl;'
p19772
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p19773
aS'  DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p19774
aS'  sparsity_pattern.copy_from(dsp);'
p19775
aS'  system_matrix.reinit(sparsity_pattern);'
p19776
aS'  solution.reinit(dof_handler.n_dofs());'
p19777
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p19778
ag32
aS'template <int dim>'
p19779
aS'void Step4<dim>::assemble_system()'
p19780
ag24
aS'  QGauss<dim> quadrature_formula(fe.degree + 1);'
p19781
aS'  RightHandSide<dim> right_hand_side;'
p19782
aS'  FEValues<dim> fe_values(fe,'
p19783
aS'                          quadrature_formula,'
p19784
aS'                          update_values | update_gradients |'
p19785
aS'                            update_quadrature_points | update_JxW_values);'
p19786
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p19787
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p19788
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p19789
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p19790
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p19791
aS'    {'
p19792
aS'      fe_values.reinit(cell);'
p19793
aS'      cell_matrix = 0;'
p19794
aS'      cell_rhs    = 0;'
p19795
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p19796
aS'        for (const unsigned int i : fe_values.dof_indices())'
p19797
aS'          {'
p19798
aS'            for (const unsigned int j : fe_values.dof_indices())'
p19799
aS'              cell_matrix(i, j) +='
p19800
aS'                (fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p19801
aS'                 fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p19802
aS'                 fe_values.JxW(q_index));           // dx'
p19803
aS'            const auto &x_q = fe_values.quadrature_point(q_index);'
p19804
aS'            cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p19805
aS'                            right_hand_side.value(x_q) *        // f(x_q)'
p19806
aS'                            fe_values.JxW(q_index));            // dx'
p19807
aS'          }'
p19808
aS'      cell->get_dof_indices(local_dof_indices);'
p19809
aS'      for (const unsigned int i : fe_values.dof_indices())'
p19810
aS'        {'
p19811
aS'          for (const unsigned int j : fe_values.dof_indices())'
p19812
aS'            system_matrix.add(local_dof_indices[i],'
p19813
aS'                              local_dof_indices[j],'
p19814
aS'                              cell_matrix(i, j));'
p19815
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p19816
aS'        }'
p19817
aS'    }'
p19818
aS'  std::map<types::global_dof_index, double> boundary_values;'
p19819
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p19820
aS'                                           0,'
p19821
aS'                                           BoundaryValues<dim>(),'
p19822
aS'                                           boundary_values);'
p19823
aS'  MatrixTools::apply_boundary_values(boundary_values,'
p19824
aS'                                     system_matrix,'
p19825
aS'                                     solution,'
p19826
aS'                                     system_rhs);'
p19827
ag32
aS'template <int dim>'
p19828
aS'void Step4<dim>::solve()'
p19829
ag24
aS'  SolverControl            solver_control(1000, 1e-12);'
p19830
aS'  SolverCG<Vector<double>> solver(solver_control);'
p19831
aS'  solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p19832
aS'  std::cout << "   " << solver_control.last_step()'
p19833
aS'            << " CG iterations needed to obtain convergence." << std::endl;'
p19834
ag32
aS'template <int dim>'
p19835
aS'void Step4<dim>::output_results() const'
p19836
ag24
aS'  DataOut<dim> data_out;'
p19837
aS'  data_out.attach_dof_handler(dof_handler);'
p19838
aS'  data_out.add_data_vector(solution, "solution");'
p19839
aS'  data_out.build_patches();'
p19840
aS'  std::ofstream output(dim == 2 ? "solution-2d.vtk" : "solution-3d.vtk");'
p19841
aS'  data_out.write_vtk(output);'
p19842
ag32
aS'template <int dim>'
p19843
aS'void Step4<dim>::run()'
p19844
ag24
aS'  std::cout << "Solving problem in " << dim << " space dimensions."'
p19845
aS'            << std::endl;'
p19846
aS'  make_grid();'
p19847
aS'  setup_system();'
p19848
aS'  assemble_system();'
p19849
aS'  solve();'
p19850
aS'  output_results();'
p19851
ag32
aS'int main()'
p19852
ag24
aS'  {'
p19853
aS'    Step4<2> laplace_problem_2d;'
p19854
aS'    laplace_problem_2d.run();'
p19855
aS'  }'
p19856
aS'  {'
p19857
aS'    Step4<3> laplace_problem_3d;'
p19858
aS'    laplace_problem_3d.run();'
p19859
aS'  }'
p19860
aS'  return 0;'
p19861
ag32
aS'/* ---------------------------------------------------------------------'
p19862
aS' *'
p19863
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p19864
aS' *'
p19865
aS' * This file is part of the deal.II library.'
p19866
aS' *'
p19867
aS' * The deal.II library is free software; you can use it, redistribute'
p19868
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p19869
aS' * Public License as published by the Free Software Foundation; either'
p19870
aS' * version 2.1 of the License, or (at your option) any later version.'
p19871
aS' * The full text of the license can be found in the file LICENSE.md at'
p19872
aS' * the top level directory of deal.II.'
p19873
aS' *'
p19874
aS' * ---------------------------------------------------------------------'
p19875
aS' *'
p19876
aS' * Author: Wolfgang Bangerth, Texas A&M University, 2009, 2010'
p19877
aS' *         Timo Heister, University of Goettingen, 2009, 2010'
p19878
aS' */'
p19879
aS'#include <deal.II/base/quadrature_lib.h>'
p19880
aS'#include <deal.II/base/function.h>'
p19881
aS'#include <deal.II/base/timer.h>'
p19882
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p19883
aS'namespace LA'
p19884
ag24
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p19885
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p19886
aS'  using namespace dealii::LinearAlgebraPETSc;'
p19887
aS'#  define USE_PETSC_LA'
p19888
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p19889
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p19890
aS'#else'
p19891
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p19892
aS'#endif'
p19893
aS'} // namespace LA'
p19894
aS'#include <deal.II/lac/vector.h>'
p19895
aS'#include <deal.II/lac/full_matrix.h>'
p19896
aS'#include <deal.II/lac/solver_cg.h>'
p19897
aS'#include <deal.II/lac/affine_constraints.h>'
p19898
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p19899
aS'#include <deal.II/grid/grid_generator.h>'
p19900
aS'#include <deal.II/dofs/dof_handler.h>'
p19901
aS'#include <deal.II/dofs/dof_tools.h>'
p19902
aS'#include <deal.II/fe/fe_values.h>'
p19903
aS'#include <deal.II/fe/fe_q.h>'
p19904
aS'#include <deal.II/numerics/vector_tools.h>'
p19905
aS'#include <deal.II/numerics/data_out.h>'
p19906
aS'#include <deal.II/numerics/error_estimator.h>'
p19907
aS'#include <deal.II/base/utilities.h>'
p19908
aS'#include <deal.II/base/conditional_ostream.h>'
p19909
aS'#include <deal.II/base/index_set.h>'
p19910
aS'#include <deal.II/lac/sparsity_tools.h>'
p19911
aS'#include <deal.II/distributed/tria.h>'
p19912
aS'#include <deal.II/distributed/grid_refinement.h>'
p19913
aS'#include <fstream>'
p19914
aS'#include <iostream>'
p19915
aS'namespace Step40'
p19916
ag24
aS'  using namespace dealii;'
p19917
aS'  template <int dim>'
p19918
aS'  class LaplaceProblem'
p19919
aS'  {'
p19920
aS'  public:'
p19921
aS'    LaplaceProblem();'
p19922
aS'    void run();'
p19923
aS'  private:'
p19924
aS'    void setup_system();'
p19925
aS'    void assemble_system();'
p19926
aS'    void solve();'
p19927
aS'    void refine_grid();'
p19928
aS'    void output_results(const unsigned int cycle) const;'
p19929
aS'    MPI_Comm mpi_communicator;'
p19930
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p19931
aS'    FE_Q<dim>       fe;'
p19932
aS'    DoFHandler<dim> dof_handler;'
p19933
aS'    IndexSet locally_owned_dofs;'
p19934
aS'    IndexSet locally_relevant_dofs;'
p19935
aS'    AffineConstraints<double> constraints;'
p19936
aS'    LA::MPI::SparseMatrix system_matrix;'
p19937
aS'    LA::MPI::Vector       locally_relevant_solution;'
p19938
aS'    LA::MPI::Vector       system_rhs;'
p19939
aS'    ConditionalOStream pcout;'
p19940
aS'    TimerOutput        computing_timer;'
p19941
aS'  };'
p19942
aS'  template <int dim>'
p19943
aS'  LaplaceProblem<dim>::LaplaceProblem()'
p19944
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p19945
aS'    , triangulation(mpi_communicator,'
p19946
aS'                    typename Triangulation<dim>::MeshSmoothing('
p19947
aS'                      Triangulation<dim>::smoothing_on_refinement |'
p19948
aS'                      Triangulation<dim>::smoothing_on_coarsening))'
p19949
aS'    , fe(2)'
p19950
aS'    , dof_handler(triangulation)'
p19951
aS'    , pcout(std::cout,'
p19952
aS'            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p19953
aS'    , computing_timer(mpi_communicator,'
p19954
aS'                      pcout,'
p19955
aS'                      TimerOutput::summary,'
p19956
aS'                      TimerOutput::wall_times)'
p19957
aS'  {}'
p19958
aS'  template <int dim>'
p19959
aS'  void LaplaceProblem<dim>::setup_system()'
p19960
aS'  {'
p19961
aS'    TimerOutput::Scope t(computing_timer, "setup");'
p19962
aS'    dof_handler.distribute_dofs(fe);'
p19963
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p19964
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p19965
aS'    locally_relevant_solution.reinit(locally_owned_dofs,'
p19966
aS'                                     locally_relevant_dofs,'
p19967
aS'                                     mpi_communicator);'
p19968
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p19969
aS'    constraints.clear();'
p19970
aS'    constraints.reinit(locally_relevant_dofs);'
p19971
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p19972
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p19973
aS'                                             0,'
p19974
aS'                                             Functions::ZeroFunction<dim>(),'
p19975
aS'                                             constraints);'
p19976
aS'    constraints.close();'
p19977
aS'    DynamicSparsityPattern dsp(locally_relevant_dofs);'
p19978
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p19979
aS'    SparsityTools::distribute_sparsity_pattern(dsp,'
p19980
aS'                                               dof_handler.locally_owned_dofs(),'
p19981
aS'                                               mpi_communicator,'
p19982
aS'                                               locally_relevant_dofs);'
p19983
aS'    system_matrix.reinit(locally_owned_dofs,'
p19984
aS'                         locally_owned_dofs,'
p19985
aS'                         dsp,'
p19986
aS'                         mpi_communicator);'
p19987
aS'  }'
p19988
aS'  template <int dim>'
p19989
aS'  void LaplaceProblem<dim>::assemble_system()'
p19990
aS'  {'
p19991
aS'    TimerOutput::Scope t(computing_timer, "assembly");'
p19992
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p19993
aS'    FEValues<dim> fe_values(fe,'
p19994
aS'                            quadrature_formula,'
p19995
aS'                            update_values | update_gradients |'
p19996
aS'                              update_quadrature_points | update_JxW_values);'
p19997
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p19998
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p19999
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p20000
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p20001
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p20002
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20003
aS'      if (cell->is_locally_owned())'
p20004
aS'        {'
p20005
aS'          cell_matrix = 0.;'
p20006
aS'          cell_rhs    = 0.;'
p20007
aS'          fe_values.reinit(cell);'
p20008
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p20009
aS'            {'
p20010
aS'              const double rhs_value ='
p20011
aS'                (fe_values.quadrature_point(q_point)[1] >'
p20012
aS'                     0.5 +'
p20013
aS'                       0.25 * std::sin(4.0 * numbers::PI *'
p20014
aS'                                       fe_values.quadrature_point(q_point)[0]) ?'
p20015
aS'                   1. :'
p20016
aS'                   -1.);'
p20017
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20018
aS'                {'
p20019
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p20020
aS'                    cell_matrix(i, j) += fe_values.shape_grad(i, q_point) *'
p20021
aS'                                         fe_values.shape_grad(j, q_point) *'
p20022
aS'                                         fe_values.JxW(q_point);'
p20023
aS'                  cell_rhs(i) += rhs_value *                         //'
p20024
aS'                                 fe_values.shape_value(i, q_point) * //'
p20025
aS'                                 fe_values.JxW(q_point);'
p20026
aS'                }'
p20027
aS'            }'
p20028
aS'          cell->get_dof_indices(local_dof_indices);'
p20029
aS'          constraints.distribute_local_to_global(cell_matrix,'
p20030
aS'                                                 cell_rhs,'
p20031
aS'                                                 local_dof_indices,'
p20032
aS'                                                 system_matrix,'
p20033
aS'                                                 system_rhs);'
p20034
aS'        }'
p20035
aS'    system_matrix.compress(VectorOperation::add);'
p20036
aS'    system_rhs.compress(VectorOperation::add);'
p20037
aS'  }'
p20038
aS'  template <int dim>'
p20039
aS'  void LaplaceProblem<dim>::solve()'
p20040
aS'  {'
p20041
aS'    TimerOutput::Scope t(computing_timer, "solve");'
p20042
aS'    LA::MPI::Vector    completely_distributed_solution(locally_owned_dofs,'
p20043
aS'                                                    mpi_communicator);'
p20044
aS'    SolverControl solver_control(dof_handler.n_dofs(), 1e-12);'
p20045
aS'#ifdef USE_PETSC_LA'
p20046
aS'    LA::SolverCG solver(solver_control, mpi_communicator);'
p20047
aS'#else'
p20048
aS'    LA::SolverCG solver(solver_control);'
p20049
aS'#endif'
p20050
aS'    LA::MPI::PreconditionAMG preconditioner;'
p20051
aS'    LA::MPI::PreconditionAMG::AdditionalData data;'
p20052
aS'#ifdef USE_PETSC_LA'
p20053
aS'    data.symmetric_operator = true;'
p20054
aS'#else'
p20055
aS'#endif'
p20056
aS'    preconditioner.initialize(system_matrix, data);'
p20057
aS'    solver.solve(system_matrix,'
p20058
aS'                 completely_distributed_solution,'
p20059
aS'                 system_rhs,'
p20060
aS'                 preconditioner);'
p20061
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p20062
aS'          << std::endl;'
p20063
aS'    constraints.distribute(completely_distributed_solution);'
p20064
aS'    locally_relevant_solution = completely_distributed_solution;'
p20065
aS'  }'
p20066
aS'  template <int dim>'
p20067
aS'  void LaplaceProblem<dim>::refine_grid()'
p20068
aS'  {'
p20069
aS'    TimerOutput::Scope t(computing_timer, "refine");'
p20070
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p20071
aS'    KellyErrorEstimator<dim>::estimate('
p20072
aS'      dof_handler,'
p20073
aS'      QGauss<dim - 1>(fe.degree + 1),'
p20074
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p20075
aS'      locally_relevant_solution,'
p20076
aS'      estimated_error_per_cell);'
p20077
aS'    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p20078
aS'      triangulation, estimated_error_per_cell, 0.3, 0.03);'
p20079
aS'    triangulation.execute_coarsening_and_refinement();'
p20080
aS'  }'
p20081
aS'  template <int dim>'
p20082
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p20083
aS'  {'
p20084
aS'    DataOut<dim> data_out;'
p20085
aS'    data_out.attach_dof_handler(dof_handler);'
p20086
aS'    data_out.add_data_vector(locally_relevant_solution, "u");'
p20087
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p20088
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p20089
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p20090
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p20091
aS'    data_out.build_patches();'
p20092
aS'    data_out.write_vtu_with_pvtu_record('
p20093
aS'      "./", "solution", cycle, mpi_communicator, 2, 8);'
p20094
aS'  }'
p20095
aS'  template <int dim>'
p20096
aS'  void LaplaceProblem<dim>::run()'
p20097
aS'  {'
p20098
aS'    pcout << "Running with "'
p20099
aS'#ifdef USE_PETSC_LA'
p20100
aS'          << "PETSc"'
p20101
aS'#else'
p20102
aS'          << "Trilinos"'
p20103
aS'#endif'
p20104
aS'          << " on " << Utilities::MPI::n_mpi_processes(mpi_communicator)'
p20105
aS'          << " MPI rank(s)..." << std::endl;'
p20106
aS'    const unsigned int n_cycles = 8;'
p20107
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p20108
aS'      {'
p20109
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p20110
aS'        if (cycle == 0)'
p20111
aS'          {'
p20112
aS'            GridGenerator::hyper_cube(triangulation);'
p20113
aS'            triangulation.refine_global(5);'
p20114
aS'          }'
p20115
aS'        else'
p20116
aS'          refine_grid();'
p20117
aS'        setup_system();'
p20118
aS'        pcout << "   Number of active cells:       "'
p20119
aS'              << triangulation.n_global_active_cells() << std::endl'
p20120
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p20121
aS'              << std::endl;'
p20122
aS'        assemble_system();'
p20123
aS'        solve();'
p20124
aS'        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32)'
p20125
aS'          {'
p20126
aS'            TimerOutput::Scope t(computing_timer, "output");'
p20127
aS'            output_results(cycle);'
p20128
aS'          }'
p20129
aS'        computing_timer.print_summary();'
p20130
aS'        computing_timer.reset();'
p20131
aS'        pcout << std::endl;'
p20132
aS'      }'
p20133
aS'  }'
p20134
aS'} // namespace Step40'
p20135
aS'int main(int argc, char *argv[])'
p20136
ag24
aS'  try'
p20137
aS'    {'
p20138
aS'      using namespace dealii;'
p20139
aS'      using namespace Step40;'
p20140
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p20141
aS'      LaplaceProblem<2> laplace_problem_2d;'
p20142
aS'      laplace_problem_2d.run();'
p20143
aS'    }'
p20144
aS'  catch (std::exception &exc)'
p20145
aS'    {'
p20146
aS'      std::cerr << std::endl'
p20147
aS'                << std::endl'
p20148
aS'                << "----------------------------------------------------"'
p20149
aS'                << std::endl;'
p20150
aS'      std::cerr << "Exception on processing: " << std::endl'
p20151
aS'                << exc.what() << std::endl'
p20152
aS'                << "Aborting!" << std::endl'
p20153
aS'                << "----------------------------------------------------"'
p20154
aS'                << std::endl;'
p20155
aS'      return 1;'
p20156
aS'    }'
p20157
aS'  catch (...)'
p20158
aS'    {'
p20159
aS'      std::cerr << std::endl'
p20160
aS'                << std::endl'
p20161
aS'                << "----------------------------------------------------"'
p20162
aS'                << std::endl;'
p20163
aS'      std::cerr << "Unknown exception!" << std::endl'
p20164
aS'                << "Aborting!" << std::endl'
p20165
aS'                << "----------------------------------------------------"'
p20166
aS'                << std::endl;'
p20167
aS'      return 1;'
p20168
aS'    }'
p20169
aS'  return 0;'
p20170
ag32
aS'/* ---------------------------------------------------------------------'
p20171
aS' *'
p20172
aS' * Copyright (C) 2011 - 2021 by the deal.II authors'
p20173
aS' *'
p20174
aS' * This file is part of the deal.II library.'
p20175
aS' *'
p20176
aS' * The deal.II library is free software; you can use it, redistribute'
p20177
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p20178
aS' * Public License as published by the Free Software Foundation; either'
p20179
aS' * version 2.1 of the License, or (at your option) any later version.'
p20180
aS' * The full text of the license can be found in the file LICENSE.md at'
p20181
aS' * the top level directory of deal.II.'
p20182
aS' *'
p20183
aS' * ---------------------------------------------------------------------'
p20184
aS' *'
p20185
aS' * Authors: Joerg Frohne, Texas A&M University and'
p20186
aS' *                        University of Siegen, 2011, 2012'
p20187
aS' *          Wolfgang Bangerth, Texas A&M University, 2012'
p20188
aS' */'
p20189
aS'#include <deal.II/base/quadrature_lib.h>'
p20190
aS'#include <deal.II/base/function.h>'
p20191
aS'#include <deal.II/base/index_set.h>'
p20192
aS'#include <deal.II/lac/affine_constraints.h>'
p20193
aS'#include <deal.II/lac/vector.h>'
p20194
aS'#include <deal.II/lac/full_matrix.h>'
p20195
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p20196
aS'#include <deal.II/lac/solver_cg.h>'
p20197
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p20198
aS'#include <deal.II/lac/trilinos_vector.h>'
p20199
aS'#include <deal.II/lac/trilinos_precondition.h>'
p20200
aS'#include <deal.II/grid/tria.h>'
p20201
aS'#include <deal.II/grid/grid_generator.h>'
p20202
aS'#include <deal.II/fe/fe_q.h>'
p20203
aS'#include <deal.II/fe/fe_values.h>'
p20204
aS'#include <deal.II/dofs/dof_handler.h>'
p20205
aS'#include <deal.II/dofs/dof_tools.h>'
p20206
aS'#include <deal.II/numerics/vector_tools.h>'
p20207
aS'#include <deal.II/numerics/data_out.h>'
p20208
aS'#include <fstream>'
p20209
aS'#include <iostream>'
p20210
aS'namespace Step41'
p20211
ag24
aS'  using namespace dealii;'
p20212
aS'  template <int dim>'
p20213
aS'  class ObstacleProblem'
p20214
aS'  {'
p20215
aS'  public:'
p20216
aS'    ObstacleProblem();'
p20217
aS'    void run();'
p20218
aS'  private:'
p20219
aS'    void make_grid();'
p20220
aS'    void setup_system();'
p20221
aS'    void assemble_system();'
p20222
aS'    void'
p20223
aS'         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);'
p20224
aS'    void update_solution_and_constraints();'
p20225
aS'    void solve();'
p20226
aS'    void output_results(const unsigned int iteration) const;'
p20227
aS'    Triangulation<dim>        triangulation;'
p20228
aS'    FE_Q<dim>                 fe;'
p20229
aS'    DoFHandler<dim>           dof_handler;'
p20230
aS'    AffineConstraints<double> constraints;'
p20231
aS'    IndexSet                  active_set;'
p20232
aS'    TrilinosWrappers::SparseMatrix system_matrix;'
p20233
aS'    TrilinosWrappers::SparseMatrix complete_system_matrix;'
p20234
aS'    TrilinosWrappers::MPI::Vector solution;'
p20235
aS'    TrilinosWrappers::MPI::Vector system_rhs;'
p20236
aS'    TrilinosWrappers::MPI::Vector complete_system_rhs;'
p20237
aS'    TrilinosWrappers::MPI::Vector diagonal_of_mass_matrix;'
p20238
aS'    TrilinosWrappers::MPI::Vector contact_force;'
p20239
aS'  };'
p20240
aS'  template <int dim>'
p20241
aS'  class RightHandSide : public Function<dim>'
p20242
aS'  {'
p20243
aS'  public:'
p20244
aS'    virtual double value(const Point<dim> & /*p*/,'
p20245
aS'                         const unsigned int component = 0) const override'
p20246
aS'    {'
p20247
aS'      (void)component;'
p20248
aS'      AssertIndexRange(component, 1);'
p20249
aS'      return -10;'
p20250
aS'    }'
p20251
aS'  };'
p20252
aS'  template <int dim>'
p20253
aS'  class BoundaryValues : public Function<dim>'
p20254
aS'  {'
p20255
aS'  public:'
p20256
aS'    virtual double value(const Point<dim> & /*p*/,'
p20257
aS'                         const unsigned int component = 0) const override'
p20258
aS'    {'
p20259
aS'      (void)component;'
p20260
aS'      AssertIndexRange(component, 1);'
p20261
aS'      return 0;'
p20262
aS'    }'
p20263
aS'  };'
p20264
aS'  template <int dim>'
p20265
aS'  class Obstacle : public Function<dim>'
p20266
aS'  {'
p20267
aS'  public:'
p20268
aS'    virtual double value(const Point<dim> & p,'
p20269
aS'                         const unsigned int component = 0) const override'
p20270
aS'    {'
p20271
aS'      (void)component;'
p20272
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p20273
aS'      if (p(0) < -0.5)'
p20274
aS'        return -0.2;'
p20275
aS'      else if (p(0) >= -0.5 && p(0) < 0.0)'
p20276
aS'        return -0.4;'
p20277
aS'      else if (p(0) >= 0.0 && p(0) < 0.5)'
p20278
aS'        return -0.6;'
p20279
aS'      else'
p20280
aS'        return -0.8;'
p20281
aS'    }'
p20282
aS'  };'
p20283
aS'  template <int dim>'
p20284
aS'  ObstacleProblem<dim>::ObstacleProblem()'
p20285
aS'    : fe(1)'
p20286
aS'    , dof_handler(triangulation)'
p20287
aS'  {}'
p20288
aS'  template <int dim>'
p20289
aS'  void ObstacleProblem<dim>::make_grid()'
p20290
aS'  {'
p20291
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p20292
aS'    triangulation.refine_global(7);'
p20293
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p20294
aS'              << std::endl'
p20295
aS'              << "Total number of cells: " << triangulation.n_cells()'
p20296
aS'              << std::endl;'
p20297
aS'  }'
p20298
aS'  template <int dim>'
p20299
aS'  void ObstacleProblem<dim>::setup_system()'
p20300
aS'  {'
p20301
aS'    dof_handler.distribute_dofs(fe);'
p20302
aS'    active_set.set_size(dof_handler.n_dofs());'
p20303
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p20304
aS'              << std::endl'
p20305
aS'              << std::endl;'
p20306
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p20307
aS'                                             0,'
p20308
aS'                                             BoundaryValues<dim>(),'
p20309
aS'                                             constraints);'
p20310
aS'    constraints.close();'
p20311
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p20312
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p20313
aS'    system_matrix.reinit(dsp);'
p20314
aS'    complete_system_matrix.reinit(dsp);'
p20315
aS'    IndexSet solution_index_set = dof_handler.locally_owned_dofs();'
p20316
aS'    solution.reinit(solution_index_set, MPI_COMM_WORLD);'
p20317
aS'    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);'
p20318
aS'    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);'
p20319
aS'    contact_force.reinit(solution_index_set, MPI_COMM_WORLD);'
p20320
aS'    TrilinosWrappers::SparseMatrix mass_matrix;'
p20321
aS'    mass_matrix.reinit(dsp);'
p20322
aS'    assemble_mass_matrix_diagonal(mass_matrix);'
p20323
aS'    diagonal_of_mass_matrix.reinit(solution_index_set);'
p20324
aS'    for (unsigned int j = 0; j < solution.size(); j++)'
p20325
aS'      diagonal_of_mass_matrix(j) = mass_matrix.diag_element(j);'
p20326
aS'  }'
p20327
aS'  template <int dim>'
p20328
aS'  void ObstacleProblem<dim>::assemble_system()'
p20329
aS'  {'
p20330
aS'    std::cout << "   Assembling system..." << std::endl;'
p20331
aS'    system_matrix = 0;'
p20332
aS'    system_rhs    = 0;'
p20333
aS'    const QGauss<dim>  quadrature_formula(fe.degree + 1);'
p20334
aS'    RightHandSide<dim> right_hand_side;'
p20335
aS'    FEValues<dim> fe_values(fe,'
p20336
aS'                            quadrature_formula,'
p20337
aS'                            update_values | update_gradients |'
p20338
aS'                              update_quadrature_points | update_JxW_values);'
p20339
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p20340
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p20341
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p20342
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p20343
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p20344
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20345
aS'      {'
p20346
aS'        fe_values.reinit(cell);'
p20347
aS'        cell_matrix = 0;'
p20348
aS'        cell_rhs    = 0;'
p20349
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p20350
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20351
aS'            {'
p20352
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p20353
aS'                cell_matrix(i, j) +='
p20354
aS'                  (fe_values.shape_grad(i, q_point) *'
p20355
aS'                   fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point));'
p20356
aS'              cell_rhs(i) +='
p20357
aS'                (fe_values.shape_value(i, q_point) *'
p20358
aS'                 right_hand_side.value(fe_values.quadrature_point(q_point)) *'
p20359
aS'                 fe_values.JxW(q_point));'
p20360
aS'            }'
p20361
aS'        cell->get_dof_indices(local_dof_indices);'
p20362
aS'        constraints.distribute_local_to_global(cell_matrix,'
p20363
aS'                                               cell_rhs,'
p20364
aS'                                               local_dof_indices,'
p20365
aS'                                               system_matrix,'
p20366
aS'                                               system_rhs,'
p20367
aS'                                               true);'
p20368
aS'      }'
p20369
aS'  }'
p20370
aS'  template <int dim>'
p20371
aS'  void ObstacleProblem<dim>::assemble_mass_matrix_diagonal('
p20372
aS'    TrilinosWrappers::SparseMatrix &mass_matrix)'
p20373
aS'  {'
p20374
aS'    Assert(fe.degree == 1, ExcNotImplemented());'
p20375
aS'    const QTrapezoid<dim> quadrature_formula;'
p20376
aS'    FEValues<dim>         fe_values(fe,'
p20377
aS'                            quadrature_formula,'
p20378
aS'                            update_values | update_JxW_values);'
p20379
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p20380
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p20381
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p20382
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p20383
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20384
aS'      {'
p20385
aS'        fe_values.reinit(cell);'
p20386
aS'        cell_matrix = 0;'
p20387
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p20388
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20389
aS'            cell_matrix(i, i) +='
p20390
aS'              (fe_values.shape_value(i, q_point) *'
p20391
aS'               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));'
p20392
aS'        cell->get_dof_indices(local_dof_indices);'
p20393
aS'        constraints.distribute_local_to_global(cell_matrix,'
p20394
aS'                                               local_dof_indices,'
p20395
aS'                                               mass_matrix);'
p20396
aS'      }'
p20397
aS'  }'
p20398
aS'  template <int dim>'
p20399
aS'  void ObstacleProblem<dim>::update_solution_and_constraints()'
p20400
aS'  {'
p20401
aS'    std::cout << "   Updating active set..." << std::endl;'
p20402
aS'    const double penalty_parameter = 100.0;'
p20403
aS'    TrilinosWrappers::MPI::Vector lambda('
p20404
aS'      complete_index_set(dof_handler.n_dofs()));'
p20405
aS'    complete_system_matrix.residual(lambda, solution, complete_system_rhs);'
p20406
aS'    contact_force = lambda;'
p20407
aS'    contact_force.scale(diagonal_of_mass_matrix);'
p20408
aS'    contact_force *= -1;'
p20409
aS'    constraints.clear();'
p20410
aS'    active_set.clear();'
p20411
aS'    const Obstacle<dim> obstacle;'
p20412
aS'    std::vector<bool>   dof_touched(dof_handler.n_dofs(), false);'
p20413
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20414
aS'      for (const auto v : cell->vertex_indices())'
p20415
aS'        {'
p20416
aS'          Assert(dof_handler.get_fe().n_dofs_per_cell() == cell->n_vertices(),'
p20417
aS'                 ExcNotImplemented());'
p20418
aS'          const unsigned int dof_index = cell->vertex_dof_index(v, 0);'
p20419
aS'          if (dof_touched[dof_index] == false)'
p20420
aS'            dof_touched[dof_index] = true;'
p20421
aS'          else'
p20422
aS'            continue;'
p20423
aS'          const double obstacle_value = obstacle.value(cell->vertex(v));'
p20424
aS'          const double solution_value = solution(dof_index);'
p20425
aS'          if (lambda(dof_index) + penalty_parameter *'
p20426
aS'                                    diagonal_of_mass_matrix(dof_index) *'
p20427
aS'                                    (solution_value - obstacle_value) <'
p20428
aS'              0)'
p20429
aS'            {'
p20430
aS'              active_set.add_index(dof_index);'
p20431
aS'              constraints.add_line(dof_index);'
p20432
aS'              constraints.set_inhomogeneity(dof_index, obstacle_value);'
p20433
aS'              solution(dof_index) = obstacle_value;'
p20434
aS'              lambda(dof_index) = 0;'
p20435
aS'            }'
p20436
aS'        }'
p20437
aS'    std::cout << "      Size of active set: " << active_set.n_elements()'
p20438
aS'              << std::endl;'
p20439
aS'    std::cout << "   Residual of the non-contact part of the system: "'
p20440
aS'              << lambda.l2_norm() << std::endl;'
p20441
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p20442
aS'                                             0,'
p20443
aS'                                             BoundaryValues<dim>(),'
p20444
aS'                                             constraints);'
p20445
aS'    constraints.close();'
p20446
aS'  }'
p20447
aS'  template <int dim>'
p20448
aS'  void ObstacleProblem<dim>::solve()'
p20449
aS'  {'
p20450
aS'    std::cout << "   Solving system..." << std::endl;'
p20451
aS'    ReductionControl                        reduction_control(100, 1e-12, 1e-3);'
p20452
aS'    SolverCG<TrilinosWrappers::MPI::Vector> solver(reduction_control);'
p20453
aS'    TrilinosWrappers::PreconditionAMG       precondition;'
p20454
aS'    precondition.initialize(system_matrix);'
p20455
aS'    solver.solve(system_matrix, solution, system_rhs, precondition);'
p20456
aS'    constraints.distribute(solution);'
p20457
aS'    std::cout << "      Error: " << reduction_control.initial_value() << " -> "'
p20458
aS'              << reduction_control.last_value() << " in "'
p20459
aS'              << reduction_control.last_step() << " CG iterations."'
p20460
aS'              << std::endl;'
p20461
aS'  }'
p20462
aS'  template <int dim>'
p20463
aS'  void ObstacleProblem<dim>::output_results(const unsigned int iteration) const'
p20464
aS'  {'
p20465
aS'    std::cout << "   Writing graphical output..." << std::endl;'
p20466
aS'    TrilinosWrappers::MPI::Vector active_set_vector('
p20467
aS'      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);'
p20468
aS'    for (const auto index : active_set)'
p20469
aS'      active_set_vector[index] = 1.;'
p20470
aS'    DataOut<dim> data_out;'
p20471
aS'    data_out.attach_dof_handler(dof_handler);'
p20472
aS'    data_out.add_data_vector(solution, "displacement");'
p20473
aS'    data_out.add_data_vector(active_set_vector, "active_set");'
p20474
aS'    data_out.add_data_vector(contact_force, "lambda");'
p20475
aS'    data_out.build_patches();'
p20476
aS'    std::ofstream output_vtk("output_" +'
p20477
aS'                             Utilities::int_to_string(iteration, 3) + ".vtk");'
p20478
aS'    data_out.write_vtk(output_vtk);'
p20479
aS'  }'
p20480
aS'  template <int dim>'
p20481
aS'  void ObstacleProblem<dim>::run()'
p20482
aS'  {'
p20483
aS'    make_grid();'
p20484
aS'    setup_system();'
p20485
aS'    IndexSet active_set_old(active_set);'
p20486
aS'    for (unsigned int iteration = 0; iteration <= solution.size(); ++iteration)'
p20487
aS'      {'
p20488
aS'        std::cout << "Newton iteration " << iteration << std::endl;'
p20489
aS'        assemble_system();'
p20490
aS'        if (iteration == 0)'
p20491
aS'          {'
p20492
aS'            complete_system_matrix.copy_from(system_matrix);'
p20493
aS'            complete_system_rhs = system_rhs;'
p20494
aS'          }'
p20495
aS'        solve();'
p20496
aS'        update_solution_and_constraints();'
p20497
aS'        output_results(iteration);'
p20498
aS'        if (active_set == active_set_old)'
p20499
aS'          break;'
p20500
aS'        active_set_old = active_set;'
p20501
aS'        std::cout << std::endl;'
p20502
aS'      }'
p20503
aS'  }'
p20504
aS'} // namespace Step41'
p20505
aS'int main(int argc, char *argv[])'
p20506
ag24
aS'  try'
p20507
aS'    {'
p20508
aS'      using namespace dealii;'
p20509
aS'      using namespace Step41;'
p20510
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p20511
aS'        argc, argv, numbers::invalid_unsigned_int);'
p20512
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p20513
aS'                  ExcMessage('
p20514
aS'                    "This program can only be run in serial, use ./step-41"));'
p20515
aS'      ObstacleProblem<2> obstacle_problem;'
p20516
aS'      obstacle_problem.run();'
p20517
aS'    }'
p20518
aS'  catch (std::exception &exc)'
p20519
aS'    {'
p20520
aS'      std::cerr << std::endl'
p20521
aS'                << std::endl'
p20522
aS'                << "----------------------------------------------------"'
p20523
aS'                << std::endl;'
p20524
aS'      std::cerr << "Exception on processing: " << std::endl'
p20525
aS'                << exc.what() << std::endl'
p20526
aS'                << "Aborting!" << std::endl'
p20527
aS'                << "----------------------------------------------------"'
p20528
aS'                << std::endl;'
p20529
aS'      return 1;'
p20530
aS'    }'
p20531
aS'  catch (...)'
p20532
aS'    {'
p20533
aS'      std::cerr << std::endl'
p20534
aS'                << std::endl'
p20535
aS'                << "----------------------------------------------------"'
p20536
aS'                << std::endl;'
p20537
aS'      std::cerr << "Unknown exception!" << std::endl'
p20538
aS'                << "Aborting!" << std::endl'
p20539
aS'                << "----------------------------------------------------"'
p20540
aS'                << std::endl;'
p20541
aS'      return 1;'
p20542
aS'    }'
p20543
aS'  return 0;'
p20544
ag32
aS'/* ---------------------------------------------------------------------'
p20545
aS' *'
p20546
aS' * Copyright (C) 2012 - 2021 by the deal.II authors'
p20547
aS' *'
p20548
aS' * This file is part of the deal.II library.'
p20549
aS' *'
p20550
aS' * The deal.II library is free software; you can use it, redistribute'
p20551
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p20552
aS' * Public License as published by the Free Software Foundation; either'
p20553
aS' * version 2.1 of the License, or (at your option) any later version.'
p20554
aS' * The full text of the license can be found in the file LICENSE.md at'
p20555
aS' * the top level directory of deal.II.'
p20556
aS' *'
p20557
aS' * ---------------------------------------------------------------------'
p20558
aS' *'
p20559
aS' * Authors: Joerg Frohne, Texas A&M University and'
p20560
aS' *                        University of Siegen, 2012, 2013'
p20561
aS' *          Wolfgang Bangerth, Texas A&M University, 2012, 2013'
p20562
aS' *          Timo Heister, Texas A&M University, 2013'
p20563
aS' */'
p20564
aS'#include <deal.II/base/conditional_ostream.h>'
p20565
aS'#include <deal.II/base/parameter_handler.h>'
p20566
aS'#include <deal.II/base/utilities.h>'
p20567
aS'#include <deal.II/base/index_set.h>'
p20568
aS'#include <deal.II/base/quadrature_lib.h>'
p20569
aS'#include <deal.II/base/function.h>'
p20570
aS'#include <deal.II/base/timer.h>'
p20571
aS'#include <deal.II/lac/vector.h>'
p20572
aS'#include <deal.II/lac/full_matrix.h>'
p20573
aS'#include <deal.II/lac/sparsity_tools.h>'
p20574
aS'#include <deal.II/lac/sparse_matrix.h>'
p20575
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p20576
aS'#include <deal.II/lac/solver_bicgstab.h>'
p20577
aS'#include <deal.II/lac/precondition.h>'
p20578
aS'#include <deal.II/lac/affine_constraints.h>'
p20579
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p20580
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p20581
aS'#include <deal.II/lac/trilinos_vector.h>'
p20582
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p20583
aS'#include <deal.II/lac/trilinos_precondition.h>'
p20584
aS'#include <deal.II/lac/trilinos_solver.h>'
p20585
aS'#include <deal.II/grid/tria.h>'
p20586
aS'#include <deal.II/grid/grid_generator.h>'
p20587
aS'#include <deal.II/grid/grid_tools.h>'
p20588
aS'#include <deal.II/grid/manifold_lib.h>'
p20589
aS'#include <deal.II/distributed/tria.h>'
p20590
aS'#include <deal.II/distributed/grid_refinement.h>'
p20591
aS'#include <deal.II/distributed/solution_transfer.h>'
p20592
aS'#include <deal.II/dofs/dof_handler.h>'
p20593
aS'#include <deal.II/dofs/dof_renumbering.h>'
p20594
aS'#include <deal.II/dofs/dof_tools.h>'
p20595
aS'#include <deal.II/fe/fe_q.h>'
p20596
aS'#include <deal.II/fe/fe_system.h>'
p20597
aS'#include <deal.II/fe/fe_values.h>'
p20598
aS'#include <deal.II/numerics/vector_tools.h>'
p20599
aS'#include <deal.II/numerics/matrix_tools.h>'
p20600
aS'#include <deal.II/numerics/data_out.h>'
p20601
aS'#include <deal.II/numerics/error_estimator.h>'
p20602
aS'#include <deal.II/numerics/fe_field_function.h>'
p20603
aS'#include <fstream>'
p20604
aS'#include <iostream>'
p20605
aS'#include <sys/stat.h>'
p20606
aS'#include <cerrno>'
p20607
aS'namespace Step42'
p20608
ag24
aS'  using namespace dealii;'
p20609
aS'  template <int dim>'
p20610
aS'  class ConstitutiveLaw'
p20611
aS'  {'
p20612
aS'  public:'
p20613
aS'    ConstitutiveLaw(const double E,'
p20614
aS'                    const double nu,'
p20615
aS'                    const double sigma_0,'
p20616
aS'                    const double gamma);'
p20617
aS'    void set_sigma_0(double sigma_zero);'
p20618
aS'    bool get_stress_strain_tensor('
p20619
aS'      const SymmetricTensor<2, dim> &strain_tensor,'
p20620
aS'      SymmetricTensor<4, dim> &      stress_strain_tensor) const;'
p20621
aS'    void get_linearized_stress_strain_tensors('
p20622
aS'      const SymmetricTensor<2, dim> &strain_tensor,'
p20623
aS'      SymmetricTensor<4, dim> &      stress_strain_tensor_linearized,'
p20624
aS'      SymmetricTensor<4, dim> &      stress_strain_tensor) const;'
p20625
aS'  private:'
p20626
aS'    const double kappa;'
p20627
aS'    const double mu;'
p20628
aS'    double       sigma_0;'
p20629
aS'    const double gamma;'
p20630
aS'    const SymmetricTensor<4, dim> stress_strain_tensor_kappa;'
p20631
aS'    const SymmetricTensor<4, dim> stress_strain_tensor_mu;'
p20632
aS'  };'
p20633
aS'  template <int dim>'
p20634
aS'  ConstitutiveLaw<dim>::ConstitutiveLaw(double E,'
p20635
aS'                                        double nu,'
p20636
aS'                                        double sigma_0,'
p20637
aS'                                        double gamma)'
p20638
aS'    : kappa(E / (3 * (1 - 2 * nu)))'
p20639
aS'    , mu(E / (2 * (1 + nu)))'
p20640
aS'    , sigma_0(sigma_0)'
p20641
aS'    , gamma(gamma)'
p20642
aS'    , stress_strain_tensor_kappa(kappa *'
p20643
aS'                                 outer_product(unit_symmetric_tensor<dim>(),'
p20644
aS'                                               unit_symmetric_tensor<dim>()))'
p20645
aS'    , stress_strain_tensor_mu('
p20646
aS'        2 * mu *'
p20647
aS'        (identity_tensor<dim>() - outer_product(unit_symmetric_tensor<dim>(),'
p20648
aS'                                                unit_symmetric_tensor<dim>()) /'
p20649
aS'                                    3.0))'
p20650
aS'  {}'
p20651
aS'  template <int dim>'
p20652
aS'  void ConstitutiveLaw<dim>::set_sigma_0(double sigma_zero)'
p20653
aS'  {'
p20654
aS'    sigma_0 = sigma_zero;'
p20655
aS'  }'
p20656
aS'  template <int dim>'
p20657
aS'  bool ConstitutiveLaw<dim>::get_stress_strain_tensor('
p20658
aS'    const SymmetricTensor<2, dim> &strain_tensor,'
p20659
aS'    SymmetricTensor<4, dim> &      stress_strain_tensor) const'
p20660
aS'  {'
p20661
aS'    Assert(dim == 3, ExcNotImplemented());'
p20662
aS'    SymmetricTensor<2, dim> stress_tensor;'
p20663
aS'    stress_tensor ='
p20664
aS'      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;'
p20665
aS'    const SymmetricTensor<2, dim> deviator_stress_tensor ='
p20666
aS'      deviator(stress_tensor);'
p20667
aS'    const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();'
p20668
aS'    stress_strain_tensor = stress_strain_tensor_mu;'
p20669
aS'    if (deviator_stress_tensor_norm > sigma_0)'
p20670
aS'      {'
p20671
aS'        const double beta = sigma_0 / deviator_stress_tensor_norm;'
p20672
aS'        stress_strain_tensor *= (gamma + (1 - gamma) * beta);'
p20673
aS'      }'
p20674
aS'    stress_strain_tensor += stress_strain_tensor_kappa;'
p20675
aS'    return (deviator_stress_tensor_norm > sigma_0);'
p20676
aS'  }'
p20677
aS'  template <int dim>'
p20678
aS'  void ConstitutiveLaw<dim>::get_linearized_stress_strain_tensors('
p20679
aS'    const SymmetricTensor<2, dim> &strain_tensor,'
p20680
aS'    SymmetricTensor<4, dim> &      stress_strain_tensor_linearized,'
p20681
aS'    SymmetricTensor<4, dim> &      stress_strain_tensor) const'
p20682
aS'  {'
p20683
aS'    Assert(dim == 3, ExcNotImplemented());'
p20684
aS'    SymmetricTensor<2, dim> stress_tensor;'
p20685
aS'    stress_tensor ='
p20686
aS'      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;'
p20687
aS'    stress_strain_tensor            = stress_strain_tensor_mu;'
p20688
aS'    stress_strain_tensor_linearized = stress_strain_tensor_mu;'
p20689
aS'    SymmetricTensor<2, dim> deviator_stress_tensor = deviator(stress_tensor);'
p20690
aS'    const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();'
p20691
aS'    if (deviator_stress_tensor_norm > sigma_0)'
p20692
aS'      {'
p20693
aS'        const double beta = sigma_0 / deviator_stress_tensor_norm;'
p20694
aS'        stress_strain_tensor *= (gamma + (1 - gamma) * beta);'
p20695
aS'        stress_strain_tensor_linearized *= (gamma + (1 - gamma) * beta);'
p20696
aS'        deviator_stress_tensor /= deviator_stress_tensor_norm;'
p20697
aS'        stress_strain_tensor_linearized -='
p20698
aS'          (1 - gamma) * beta * 2 * mu *'
p20699
aS'          outer_product(deviator_stress_tensor, deviator_stress_tensor);'
p20700
aS'      }'
p20701
aS'    stress_strain_tensor += stress_strain_tensor_kappa;'
p20702
aS'    stress_strain_tensor_linearized += stress_strain_tensor_kappa;'
p20703
aS'  }'
p20704
aS'  namespace EquationData'
p20705
aS'  {'
p20706
aS'    template <int dim>'
p20707
aS'    class BoundaryForce : public Function<dim>'
p20708
aS'    {'
p20709
aS'    public:'
p20710
aS'      BoundaryForce();'
p20711
aS'      virtual double value(const Point<dim> & p,'
p20712
aS'                           const unsigned int component = 0) const override;'
p20713
aS'      virtual void vector_value(const Point<dim> &p,'
p20714
aS'                                Vector<double> &  values) const override;'
p20715
aS'    };'
p20716
aS'    template <int dim>'
p20717
aS'    BoundaryForce<dim>::BoundaryForce()'
p20718
aS'      : Function<dim>(dim)'
p20719
aS'    {}'
p20720
aS'    template <int dim>'
p20721
aS'    double BoundaryForce<dim>::value(const Point<dim> &,'
p20722
aS'                                     const unsigned int) const'
p20723
aS'    {'
p20724
aS'      return 0.;'
p20725
aS'    }'
p20726
aS'    template <int dim>'
p20727
aS'    void BoundaryForce<dim>::vector_value(const Point<dim> &p,'
p20728
aS'                                          Vector<double> &  values) const'
p20729
aS'    {'
p20730
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p20731
aS'        values(c) = BoundaryForce<dim>::value(p, c);'
p20732
aS'    }'
p20733
aS'    template <int dim>'
p20734
aS'    class BoundaryValues : public Function<dim>'
p20735
aS'    {'
p20736
aS'    public:'
p20737
aS'      BoundaryValues();'
p20738
aS'      virtual double value(const Point<dim> & p,'
p20739
aS'                           const unsigned int component = 0) const override;'
p20740
aS'    };'
p20741
aS'    template <int dim>'
p20742
aS'    BoundaryValues<dim>::BoundaryValues()'
p20743
aS'      : Function<dim>(dim)'
p20744
aS'    {}'
p20745
aS'    template <int dim>'
p20746
aS'    double BoundaryValues<dim>::value(const Point<dim> &,'
p20747
aS'                                      const unsigned int) const'
p20748
aS'    {'
p20749
aS'      return 0.;'
p20750
aS'    }'
p20751
aS'    template <int dim>'
p20752
aS'    class SphereObstacle : public Function<dim>'
p20753
aS'    {'
p20754
aS'    public:'
p20755
aS'      SphereObstacle(const double z_surface);'
p20756
aS'      virtual double value(const Point<dim> & p,'
p20757
aS'                           const unsigned int component = 0) const override;'
p20758
aS'      virtual void vector_value(const Point<dim> &p,'
p20759
aS'                                Vector<double> &  values) const override;'
p20760
aS'    private:'
p20761
aS'      const double z_surface;'
p20762
aS'    };'
p20763
aS'    template <int dim>'
p20764
aS'    SphereObstacle<dim>::SphereObstacle(const double z_surface)'
p20765
aS'      : Function<dim>(dim)'
p20766
aS'      , z_surface(z_surface)'
p20767
aS'    {}'
p20768
aS'    template <int dim>'
p20769
aS'    double SphereObstacle<dim>::value(const Point<dim> & p,'
p20770
aS'                                      const unsigned int component) const'
p20771
aS'    {'
p20772
aS'      if (component == 0)'
p20773
aS'        return p(0);'
p20774
aS'      else if (component == 1)'
p20775
aS'        return p(1);'
p20776
aS'      else if (component == 2)'
p20777
aS'        {'
p20778
aS'          if ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) < 0.36)'
p20779
aS'            return (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -'
p20780
aS'                               (p(1) - 0.5) * (p(1) - 0.5)) +'
p20781
aS'                    z_surface + 0.59);'
p20782
aS'          else'
p20783
aS'            return 1000;'
p20784
aS'        }'
p20785
aS'      Assert(false, ExcNotImplemented());'
p20786
aS'      return 1e9; // an unreasonable value; ignored in debug mode because of the'
p20787
aS'    }'
p20788
aS'    template <int dim>'
p20789
aS'    void SphereObstacle<dim>::vector_value(const Point<dim> &p,'
p20790
aS'                                           Vector<double> &  values) const'
p20791
aS'    {'
p20792
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p20793
aS'        values(c) = SphereObstacle<dim>::value(p, c);'
p20794
aS'    }'
p20795
aS'    template <int dim>'
p20796
aS'    class BitmapFile'
p20797
aS'    {'
p20798
aS'    public:'
p20799
aS'      BitmapFile(const std::string &name);'
p20800
aS'      double get_value(const double x, const double y) const;'
p20801
aS'    private:'
p20802
aS'      std::vector<double> obstacle_data;'
p20803
aS'      double              hx, hy;'
p20804
aS'      int                 nx, ny;'
p20805
aS'      double get_pixel_value(const int i, const int j) const;'
p20806
aS'    };'
p20807
aS'    template <int dim>'
p20808
aS'    BitmapFile<dim>::BitmapFile(const std::string &name)'
p20809
aS'      : obstacle_data(0)'
p20810
aS'      , hx(0)'
p20811
aS'      , hy(0)'
p20812
aS'      , nx(0)'
p20813
aS'      , ny(0)'
p20814
aS'    {'
p20815
aS'      std::ifstream f(name);'
p20816
aS'      AssertThrow(f,'
p20817
aS'                  ExcMessage(std::string("Can\'t read from file <") + name +'
p20818
aS'                             ">!"));'
p20819
aS'      std::string temp;'
p20820
aS'      f >> temp >> nx >> ny;'
p20821
aS'      AssertThrow(nx > 0 && ny > 0, ExcMessage("Invalid file format."));'
p20822
aS'      for (int k = 0; k < nx * ny; ++k)'
p20823
aS'        {'
p20824
aS'          double val;'
p20825
aS'          f >> val;'
p20826
aS'          obstacle_data.push_back(val);'
p20827
aS'        }'
p20828
aS'      hx = 1.0 / (nx - 1);'
p20829
aS'      hy = 1.0 / (ny - 1);'
p20830
aS'      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p20831
aS'        std::cout << "Read obstacle from file <" << name << ">" << std::endl'
p20832
aS'                  << "Resolution of the scanned obstacle picture: " << nx'
p20833
aS'                  << " x " << ny << std::endl;'
p20834
aS'    }'
p20835
aS'    template <int dim>'
p20836
aS'    double BitmapFile<dim>::get_pixel_value(const int i, const int j) const'
p20837
aS'    {'
p20838
aS'      assert(i >= 0 && i < nx);'
p20839
aS'      assert(j >= 0 && j < ny);'
p20840
aS'      return obstacle_data[nx * (ny - 1 - j) + i];'
p20841
aS'    }'
p20842
aS'    template <int dim>'
p20843
aS'    double BitmapFile<dim>::get_value(const double x, const double y) const'
p20844
aS'    {'
p20845
aS'      const int ix = std::min(std::max(static_cast<int>(x / hx), 0), nx - 2);'
p20846
aS'      const int iy = std::min(std::max(static_cast<int>(y / hy), 0), ny - 2);'
p20847
aS'      const double xi  = std::min(std::max((x - ix * hx) / hx, 1.), 0.);'
p20848
aS'      const double eta = std::min(std::max((y - iy * hy) / hy, 1.), 0.);'
p20849
aS'      return ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +'
p20850
aS'              xi * (1 - eta) * get_pixel_value(ix + 1, iy) +'
p20851
aS'              (1 - xi) * eta * get_pixel_value(ix, iy + 1) +'
p20852
aS'              xi * eta * get_pixel_value(ix + 1, iy + 1));'
p20853
aS'    }'
p20854
aS'    template <int dim>'
p20855
aS'    class ChineseObstacle : public Function<dim>'
p20856
aS'    {'
p20857
aS'    public:'
p20858
aS'      ChineseObstacle(const std::string &filename, const double z_surface);'
p20859
aS'      virtual double value(const Point<dim> & p,'
p20860
aS'                           const unsigned int component = 0) const override;'
p20861
aS'      virtual void vector_value(const Point<dim> &p,'
p20862
aS'                                Vector<double> &  values) const override;'
p20863
aS'    private:'
p20864
aS'      const BitmapFile<dim> input_obstacle;'
p20865
aS'      double                z_surface;'
p20866
aS'    };'
p20867
aS'    template <int dim>'
p20868
aS'    ChineseObstacle<dim>::ChineseObstacle(const std::string &filename,'
p20869
aS'                                          const double       z_surface)'
p20870
aS'      : Function<dim>(dim)'
p20871
aS'      , input_obstacle(filename)'
p20872
aS'      , z_surface(z_surface)'
p20873
aS'    {}'
p20874
aS'    template <int dim>'
p20875
aS'    double ChineseObstacle<dim>::value(const Point<dim> & p,'
p20876
aS'                                       const unsigned int component) const'
p20877
aS'    {'
p20878
aS'      if (component == 0)'
p20879
aS'        return p(0);'
p20880
aS'      if (component == 1)'
p20881
aS'        return p(1);'
p20882
aS'      else if (component == 2)'
p20883
aS'        {'
p20884
aS'          if (p(0) >= 0.0 && p(0) <= 1.0 && p(1) >= 0.0 && p(1) <= 1.0)'
p20885
aS'            return z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));'
p20886
aS'        }'
p20887
aS'      Assert(false, ExcNotImplemented());'
p20888
aS'      return 1e9; // an unreasonable value; ignored in debug mode because of the'
p20889
aS'    }'
p20890
aS'    template <int dim>'
p20891
aS'    void ChineseObstacle<dim>::vector_value(const Point<dim> &p,'
p20892
aS'                                            Vector<double> &  values) const'
p20893
aS'    {'
p20894
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p20895
aS'        values(c) = ChineseObstacle<dim>::value(p, c);'
p20896
aS'    }'
p20897
aS'  } // namespace EquationData'
p20898
aS'  template <int dim>'
p20899
aS'  class PlasticityContactProblem'
p20900
aS'  {'
p20901
aS'  public:'
p20902
aS'    PlasticityContactProblem(const ParameterHandler &prm);'
p20903
aS'    void run();'
p20904
aS'    static void declare_parameters(ParameterHandler &prm);'
p20905
aS'  private:'
p20906
aS'    void make_grid();'
p20907
aS'    void setup_system();'
p20908
aS'    void compute_dirichlet_constraints();'
p20909
aS'    void update_solution_and_constraints();'
p20910
aS'    void'
p20911
aS'         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);'
p20912
aS'    void assemble_newton_system('
p20913
aS'      const TrilinosWrappers::MPI::Vector &linearization_point);'
p20914
aS'    void compute_nonlinear_residual('
p20915
aS'      const TrilinosWrappers::MPI::Vector &linearization_point);'
p20916
aS'    void solve_newton_system();'
p20917
aS'    void solve_newton();'
p20918
aS'    void refine_grid();'
p20919
aS'    void move_mesh(const TrilinosWrappers::MPI::Vector &displacement) const;'
p20920
aS'    void output_results(const unsigned int current_refinement_cycle);'
p20921
aS'    void output_contact_force() const;'
p20922
aS'    MPI_Comm           mpi_communicator;'
p20923
aS'    ConditionalOStream pcout;'
p20924
aS'    TimerOutput        computing_timer;'
p20925
aS'    const unsigned int                        n_initial_global_refinements;'
p20926
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p20927
aS'    const unsigned int fe_degree;'
p20928
aS'    FESystem<dim>      fe;'
p20929
aS'    DoFHandler<dim>    dof_handler;'
p20930
aS'    IndexSet locally_owned_dofs;'
p20931
aS'    IndexSet locally_relevant_dofs;'
p20932
aS'    AffineConstraints<double> constraints_hanging_nodes;'
p20933
aS'    AffineConstraints<double> constraints_dirichlet_and_hanging_nodes;'
p20934
aS'    AffineConstraints<double> all_constraints;'
p20935
aS'    IndexSet      active_set;'
p20936
aS'    Vector<float> fraction_of_plastic_q_points_per_cell;'
p20937
aS'    TrilinosWrappers::SparseMatrix newton_matrix;'
p20938
aS'    TrilinosWrappers::MPI::Vector solution;'
p20939
aS'    TrilinosWrappers::MPI::Vector newton_rhs;'
p20940
aS'    TrilinosWrappers::MPI::Vector newton_rhs_uncondensed;'
p20941
aS'    TrilinosWrappers::MPI::Vector diag_mass_matrix_vector;'
p20942
aS'    const double         e_modulus, nu, gamma, sigma_0;'
p20943
aS'    ConstitutiveLaw<dim> constitutive_law;'
p20944
aS'    const std::string                          base_mesh;'
p20945
aS'    const std::shared_ptr<const Function<dim>> obstacle;'
p20946
aS'    struct RefinementStrategy'
p20947
aS'    {'
p20948
aS'      enum value'
p20949
aS'      {'
p20950
aS'        refine_global,'
p20951
aS'        refine_percentage,'
p20952
aS'        refine_fix_dofs'
p20953
aS'      };'
p20954
aS'    };'
p20955
aS'    typename RefinementStrategy::value refinement_strategy;'
p20956
aS'    const bool         transfer_solution;'
p20957
aS'    std::string        output_dir;'
p20958
aS'    const unsigned int n_refinement_cycles;'
p20959
aS'    unsigned int       current_refinement_cycle;'
p20960
aS'  };'
p20961
aS'  template <int dim>'
p20962
aS'  void PlasticityContactProblem<dim>::declare_parameters(ParameterHandler &prm)'
p20963
aS'  {'
p20964
aS'    prm.declare_entry('
p20965
aS'      "polynomial degree",'
p20966
aS'      "1",'
p20967
aS'      Patterns::Integer(),'
p20968
aS'      "Polynomial degree of the FE_Q finite element space, typically 1 or 2.");'
p20969
aS'    prm.declare_entry("number of initial refinements",'
p20970
aS'                      "2",'
p20971
aS'                      Patterns::Integer(),'
p20972
aS'                      "Number of initial global mesh refinement steps before "'
p20973
aS'                      "the first computation.");'
p20974
aS'    prm.declare_entry('
p20975
aS'      "refinement strategy",'
p20976
aS'      "percentage",'
p20977
aS'      Patterns::Selection("global|percentage"),'
p20978
aS'      "Mesh refinement strategy:\\n"'
p20979
aS'      " global: one global refinement\\n"'
p20980
aS'      " percentage: a fixed percentage of cells gets refined using the Kelly estimator.");'
p20981
aS'    prm.declare_entry("number of cycles",'
p20982
aS'                      "5",'
p20983
aS'                      Patterns::Integer(),'
p20984
aS'                      "Number of adaptive mesh refinement cycles to run.");'
p20985
aS'    prm.declare_entry('
p20986
aS'      "obstacle",'
p20987
aS'      "sphere",'
p20988
aS'      Patterns::Selection("sphere|read from file"),'
p20989
aS'      "The name of the obstacle to use. This may either be \'sphere\' if we should "'
p20990
aS'      "use a spherical obstacle, or \'read from file\' in which case the obstacle "'
p20991
aS'      "will be read from a file named \'obstacle.pbm\' that is supposed to be in "'
p20992
aS'      "ASCII PBM format.");'
p20993
aS'    prm.declare_entry('
p20994
aS'      "output directory",'
p20995
aS'      "",'
p20996
aS'      Patterns::Anything(),'
p20997
aS'      "Directory for output files (graphical output and benchmark "'
p20998
aS'      "statistics). If empty, use the current directory.");'
p20999
aS'    prm.declare_entry('
p21000
aS'      "transfer solution",'
p21001
aS'      "false",'
p21002
aS'      Patterns::Bool(),'
p21003
aS'      "Whether the solution should be used as a starting guess "'
p21004
aS'      "for the next finer mesh. If false, then the iteration starts at "'
p21005
aS'      "zero on every mesh.");'
p21006
aS'    prm.declare_entry("base mesh",'
p21007
aS'                      "box",'
p21008
aS'                      Patterns::Selection("box|half sphere"),'
p21009
aS'                      "Select the shape of the domain: \'box\' or \'half sphere\'");'
p21010
aS'  }'
p21011
aS'  template <int dim>'
p21012
aS'  PlasticityContactProblem<dim>::PlasticityContactProblem('
p21013
aS'    const ParameterHandler &prm)'
p21014
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p21015
aS'    , pcout(std::cout,'
p21016
aS'            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p21017
aS'    , computing_timer(MPI_COMM_WORLD,'
p21018
aS'                      pcout,'
p21019
aS'                      TimerOutput::never,'
p21020
aS'                      TimerOutput::wall_times)'
p21021
aS'    , n_initial_global_refinements('
p21022
aS'        prm.get_integer("number of initial refinements"))'
p21023
aS'    , triangulation(mpi_communicator)'
p21024
aS'    , fe_degree(prm.get_integer("polynomial degree"))'
p21025
aS'    , fe(FE_Q<dim>(QGaussLobatto<1>(fe_degree + 1)), dim)'
p21026
aS'    , dof_handler(triangulation)'
p21027
aS'    , e_modulus(200000)'
p21028
aS'    , nu(0.3)'
p21029
aS'    , gamma(0.01)'
p21030
aS'    , sigma_0(400.0)'
p21031
aS'    , constitutive_law(e_modulus, nu, sigma_0, gamma)'
p21032
aS'    , base_mesh(prm.get("base mesh"))'
p21033
aS'    , obstacle(prm.get("obstacle") == "read from file" ?'
p21034
aS'                 static_cast<const Function<dim> *>('
p21035
aS'                   new EquationData::ChineseObstacle<dim>('
p21036
aS'                     "obstacle.pbm",'
p21037
aS'                     (base_mesh == "box" ? 1.0 : 0.5))) :'
p21038
aS'                 static_cast<const Function<dim> *>('
p21039
aS'                   new EquationData::SphereObstacle<dim>('
p21040
aS'                     base_mesh == "box" ? 1.0 : 0.5)))'
p21041
aS'    , transfer_solution(prm.get_bool("transfer solution"))'
p21042
aS'    , n_refinement_cycles(prm.get_integer("number of cycles"))'
p21043
aS'    , current_refinement_cycle(0)'
p21044
aS'  {'
p21045
aS'    std::string strat = prm.get("refinement strategy");'
p21046
aS'    if (strat == "global")'
p21047
aS'      refinement_strategy = RefinementStrategy::refine_global;'
p21048
aS'    else if (strat == "percentage")'
p21049
aS'      refinement_strategy = RefinementStrategy::refine_percentage;'
p21050
aS'    else'
p21051
aS'      AssertThrow(false, ExcNotImplemented());'
p21052
aS'    output_dir = prm.get("output directory");'
p21053
aS'    if (output_dir != "" && *(output_dir.rbegin()) != \'/\')'
p21054
aS'      output_dir += "/";'
p21055
aS'    if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p21056
aS'      {'
p21057
aS'        const int ierr = mkdir(output_dir.c_str(), 0777);'
p21058
aS'        AssertThrow(ierr == 0 || errno == EEXIST, ExcIO());'
p21059
aS'      }'
p21060
aS'    pcout << "    Using output directory \'" << output_dir << "\'" << std::endl;'
p21061
aS'    pcout << "    FE degree " << fe_degree << std::endl;'
p21062
aS'    pcout << "    transfer solution " << (transfer_solution ? "true" : "false")'
p21063
aS'          << std::endl;'
p21064
aS'  }'
p21065
aS'  Point<3> rotate_half_sphere(const Point<3> &in)'
p21066
aS'  {'
p21067
aS'    return {in(2), in(1), -in(0)};'
p21068
aS'  }'
p21069
aS'  template <int dim>'
p21070
aS'  void PlasticityContactProblem<dim>::make_grid()'
p21071
aS'  {'
p21072
aS'    if (base_mesh == "half sphere")'
p21073
aS'      {'
p21074
aS'        const Point<dim> center(0, 0, 0);'
p21075
aS'        const double     radius = 0.8;'
p21076
aS'        GridGenerator::half_hyper_ball(triangulation, center, radius);'
p21077
aS'        triangulation.reset_all_manifolds();'
p21078
aS'        GridTools::transform(&rotate_half_sphere, triangulation);'
p21079
aS'        GridTools::shift(Point<dim>(0.5, 0.5, 0.5), triangulation);'
p21080
aS'        SphericalManifold<dim> manifold_description(Point<dim>(0.5, 0.5, 0.5));'
p21081
aS'        GridTools::copy_boundary_to_manifold_id(triangulation);'
p21082
aS'        triangulation.set_manifold(0, manifold_description);'
p21083
aS'      }'
p21084
aS'    else'
p21085
aS'      {'
p21086
aS'        const Point<dim> p1(0, 0, 0);'
p21087
aS'        const Point<dim> p2(1.0, 1.0, 1.0);'
p21088
aS'        GridGenerator::hyper_rectangle(triangulation, p1, p2);'
p21089
aS'        for (const auto &cell : triangulation.active_cell_iterators())'
p21090
aS'          for (const auto &face : cell->face_iterators())'
p21091
aS'            if (face->at_boundary())'
p21092
aS'              {'
p21093
aS'                if (std::fabs(face->center()[2] - p2[2]) < 1e-12)'
p21094
aS'                  face->set_boundary_id(1);'
p21095
aS'                if (std::fabs(face->center()[0] - p1[0]) < 1e-12 ||'
p21096
aS'                    std::fabs(face->center()[0] - p2[0]) < 1e-12 ||'
p21097
aS'                    std::fabs(face->center()[1] - p1[1]) < 1e-12 ||'
p21098
aS'                    std::fabs(face->center()[1] - p2[1]) < 1e-12)'
p21099
aS'                  face->set_boundary_id(8);'
p21100
aS'                if (std::fabs(face->center()[2] - p1[2]) < 1e-12)'
p21101
aS'                  face->set_boundary_id(6);'
p21102
aS'              }'
p21103
aS'      }'
p21104
aS'    triangulation.refine_global(n_initial_global_refinements);'
p21105
aS'  }'
p21106
aS'  template <int dim>'
p21107
aS'  void PlasticityContactProblem<dim>::setup_system()'
p21108
aS'  {'
p21109
aS'    {'
p21110
aS'      TimerOutput::Scope t(computing_timer, "Setup: distribute DoFs");'
p21111
aS'      dof_handler.distribute_dofs(fe);'
p21112
aS'      locally_owned_dofs = dof_handler.locally_owned_dofs();'
p21113
aS'      locally_relevant_dofs.clear();'
p21114
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler,'
p21115
aS'                                              locally_relevant_dofs);'
p21116
aS'    }'
p21117
aS'    {'
p21118
aS'      TimerOutput::Scope t(computing_timer, "Setup: constraints");'
p21119
aS'      constraints_hanging_nodes.reinit(locally_relevant_dofs);'
p21120
aS'      DoFTools::make_hanging_node_constraints(dof_handler,'
p21121
aS'                                              constraints_hanging_nodes);'
p21122
aS'      constraints_hanging_nodes.close();'
p21123
aS'      pcout << "   Number of active cells: "'
p21124
aS'            << triangulation.n_global_active_cells() << std::endl'
p21125
aS'            << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p21126
aS'            << std::endl;'
p21127
aS'      compute_dirichlet_constraints();'
p21128
aS'    }'
p21129
aS'    {'
p21130
aS'      TimerOutput::Scope t(computing_timer, "Setup: vectors");'
p21131
aS'      solution.reinit(locally_relevant_dofs, mpi_communicator);'
p21132
aS'      newton_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p21133
aS'      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);'
p21134
aS'      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);'
p21135
aS'      fraction_of_plastic_q_points_per_cell.reinit('
p21136
aS'        triangulation.n_active_cells());'
p21137
aS'      active_set.clear();'
p21138
aS'      active_set.set_size(dof_handler.n_dofs());'
p21139
aS'    }'
p21140
aS'    {'
p21141
aS'      TimerOutput::Scope                t(computing_timer, "Setup: matrix");'
p21142
aS'      TrilinosWrappers::SparsityPattern sp(locally_owned_dofs,'
p21143
aS'                                           mpi_communicator);'
p21144
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p21145
aS'                                      sp,'
p21146
aS'                                      constraints_dirichlet_and_hanging_nodes,'
p21147
aS'                                      false,'
p21148
aS'                                      Utilities::MPI::this_mpi_process('
p21149
aS'                                        mpi_communicator));'
p21150
aS'      sp.compress();'
p21151
aS'      newton_matrix.reinit(sp);'
p21152
aS'      TrilinosWrappers::SparseMatrix &mass_matrix = newton_matrix;'
p21153
aS'      assemble_mass_matrix_diagonal(mass_matrix);'
p21154
aS'      const unsigned int start = (newton_rhs.local_range().first),'
p21155
aS'                         end   = (newton_rhs.local_range().second);'
p21156
aS'      for (unsigned int j = start; j < end; ++j)'
p21157
aS'        diag_mass_matrix_vector(j) = mass_matrix.diag_element(j);'
p21158
aS'      diag_mass_matrix_vector.compress(VectorOperation::insert);'
p21159
aS'      mass_matrix = 0;'
p21160
aS'    }'
p21161
aS'  }'
p21162
aS'  template <int dim>'
p21163
aS'  void PlasticityContactProblem<dim>::compute_dirichlet_constraints()'
p21164
aS'  {'
p21165
aS'    constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs);'
p21166
aS'    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);'
p21167
aS'    if (base_mesh == "box")'
p21168
aS'      {'
p21169
aS'        VectorTools::interpolate_boundary_values('
p21170
aS'          dof_handler,'
p21171
aS'          6,'
p21172
aS'          EquationData::BoundaryValues<dim>(),'
p21173
aS'          constraints_dirichlet_and_hanging_nodes,'
p21174
aS'          ComponentMask());'
p21175
aS'        const FEValuesExtractors::Scalar x_displacement(0);'
p21176
aS'        const FEValuesExtractors::Scalar y_displacement(1);'
p21177
aS'        VectorTools::interpolate_boundary_values('
p21178
aS'          dof_handler,'
p21179
aS'          8,'
p21180
aS'          EquationData::BoundaryValues<dim>(),'
p21181
aS'          constraints_dirichlet_and_hanging_nodes,'
p21182
aS'          (fe.component_mask(x_displacement) |'
p21183
aS'           fe.component_mask(y_displacement)));'
p21184
aS'      }'
p21185
aS'    else'
p21186
aS'      VectorTools::interpolate_boundary_values('
p21187
aS'        dof_handler,'
p21188
aS'        0,'
p21189
aS'        EquationData::BoundaryValues<dim>(),'
p21190
aS'        constraints_dirichlet_and_hanging_nodes,'
p21191
aS'        ComponentMask());'
p21192
aS'    constraints_dirichlet_and_hanging_nodes.close();'
p21193
aS'  }'
p21194
aS'  template <int dim>'
p21195
aS'  void PlasticityContactProblem<dim>::assemble_mass_matrix_diagonal('
p21196
aS'    TrilinosWrappers::SparseMatrix &mass_matrix)'
p21197
aS'  {'
p21198
aS'    QGaussLobatto<dim - 1> face_quadrature_formula(fe.degree + 1);'
p21199
aS'    FEFaceValues<dim> fe_values_face(fe,'
p21200
aS'                                     face_quadrature_formula,'
p21201
aS'                                     update_values | update_JxW_values);'
p21202
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p21203
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p21204
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p21205
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21206
aS'    const FEValuesExtractors::Vector displacement(0);'
p21207
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p21208
aS'      if (cell->is_locally_owned())'
p21209
aS'        for (const auto &face : cell->face_iterators())'
p21210
aS'          if (face->at_boundary() && face->boundary_id() == 1)'
p21211
aS'            {'
p21212
aS'              fe_values_face.reinit(cell, face);'
p21213
aS'              cell_matrix = 0;'
p21214
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p21215
aS'                   ++q_point)'
p21216
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21217
aS'                  cell_matrix(i, i) +='
p21218
aS'                    (fe_values_face[displacement].value(i, q_point) *'
p21219
aS'                     fe_values_face[displacement].value(i, q_point) *'
p21220
aS'                     fe_values_face.JxW(q_point));'
p21221
aS'              cell->get_dof_indices(local_dof_indices);'
p21222
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21223
aS'                mass_matrix.add(local_dof_indices[i],'
p21224
aS'                                local_dof_indices[i],'
p21225
aS'                                cell_matrix(i, i));'
p21226
aS'            }'
p21227
aS'    mass_matrix.compress(VectorOperation::add);'
p21228
aS'  }'
p21229
aS'  template <int dim>'
p21230
aS'  void PlasticityContactProblem<dim>::update_solution_and_constraints()'
p21231
aS'  {'
p21232
aS'    std::vector<bool> dof_touched(dof_handler.n_dofs(), false);'
p21233
aS'    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p21234
aS'                                                       mpi_communicator);'
p21235
aS'    distributed_solution = solution;'
p21236
aS'    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,'
p21237
aS'                                         mpi_communicator);'
p21238
aS'    lambda = newton_rhs_uncondensed;'
p21239
aS'    TrilinosWrappers::MPI::Vector diag_mass_matrix_vector_relevant('
p21240
aS'      locally_relevant_dofs, mpi_communicator);'
p21241
aS'    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;'
p21242
aS'    all_constraints.reinit(locally_relevant_dofs);'
p21243
aS'    active_set.clear();'
p21244
aS'    Quadrature<dim - 1> face_quadrature(fe.get_unit_face_support_points());'
p21245
aS'    FEFaceValues<dim>   fe_values_face(fe,'
p21246
aS'                                     face_quadrature,'
p21247
aS'                                     update_quadrature_points);'
p21248
aS'    const unsigned int dofs_per_face   = fe.n_dofs_per_face();'
p21249
aS'    const unsigned int n_face_q_points = face_quadrature.size();'
p21250
aS'    std::vector<types::global_dof_index> dof_indices(dofs_per_face);'
p21251
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p21252
aS'      if (!cell->is_artificial())'
p21253
aS'        for (const auto &face : cell->face_iterators())'
p21254
aS'          if (face->at_boundary() && face->boundary_id() == 1)'
p21255
aS'            {'
p21256
aS'              fe_values_face.reinit(cell, face);'
p21257
aS'              face->get_dof_indices(dof_indices);'
p21258
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p21259
aS'                   ++q_point)'
p21260
aS'                {'
p21261
aS'                  const unsigned int component ='
p21262
aS'                    fe.face_system_to_component_index(q_point).first;'
p21263
aS'                  const unsigned int index_z = dof_indices[q_point];'
p21264
aS'                  if ((component == 2) && (dof_touched[index_z] == false))'
p21265
aS'                    {'
p21266
aS'                      dof_touched[index_z] = true;'
p21267
aS'                      const Point<dim> this_support_point ='
p21268
aS'                        fe_values_face.quadrature_point(q_point);'
p21269
aS'                      const double obstacle_value ='
p21270
aS'                        obstacle->value(this_support_point, 2);'
p21271
aS'                      const double solution_here = solution(index_z);'
p21272
aS'                      const double undeformed_gap ='
p21273
aS'                        obstacle_value - this_support_point(2);'
p21274
aS'                      const double c = 100.0 * e_modulus;'
p21275
aS'                      if ((lambda(index_z) /'
p21276
aS'                               diag_mass_matrix_vector_relevant(index_z) +'
p21277
aS'                             c * (solution_here - undeformed_gap) >'
p21278
aS'                           0) &&'
p21279
aS'                          !constraints_hanging_nodes.is_constrained(index_z))'
p21280
aS'                        {'
p21281
aS'                          all_constraints.add_line(index_z);'
p21282
aS'                          all_constraints.set_inhomogeneity(index_z,'
p21283
aS'                                                            undeformed_gap);'
p21284
aS'                          distributed_solution(index_z) = undeformed_gap;'
p21285
aS'                          active_set.add_index(index_z);'
p21286
aS'                        }'
p21287
aS'                    }'
p21288
aS'                }'
p21289
aS'            }'
p21290
aS'    distributed_solution.compress(VectorOperation::insert);'
p21291
aS'    solution = distributed_solution;'
p21292
aS'    all_constraints.close();'
p21293
aS'    all_constraints.merge(constraints_dirichlet_and_hanging_nodes);'
p21294
aS'    pcout << "         Size of active set: "'
p21295
aS'          << Utilities::MPI::sum((active_set & locally_owned_dofs).n_elements(),'
p21296
aS'                                 mpi_communicator)'
p21297
aS'          << std::endl;'
p21298
aS'  }'
p21299
aS'  template <int dim>'
p21300
aS'  void PlasticityContactProblem<dim>::assemble_newton_system('
p21301
aS'    const TrilinosWrappers::MPI::Vector &linearization_point)'
p21302
aS'  {'
p21303
aS'    TimerOutput::Scope t(computing_timer, "Assembling");'
p21304
aS'    QGauss<dim>     quadrature_formula(fe.degree + 1);'
p21305
aS'    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p21306
aS'    FEValues<dim> fe_values(fe,'
p21307
aS'                            quadrature_formula,'
p21308
aS'                            update_values | update_gradients |'
p21309
aS'                              update_JxW_values);'
p21310
aS'    FEFaceValues<dim> fe_values_face(fe,'
p21311
aS'                                     face_quadrature_formula,'
p21312
aS'                                     update_values | update_quadrature_points |'
p21313
aS'                                       update_JxW_values);'
p21314
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p21315
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p21316
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p21317
aS'    const EquationData::BoundaryForce<dim> boundary_force;'
p21318
aS'    std::vector<Vector<double>> boundary_force_values(n_face_q_points,'
p21319
aS'                                                      Vector<double>(dim));'
p21320
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p21321
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p21322
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21323
aS'    const FEValuesExtractors::Vector displacement(0);'
p21324
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p21325
aS'      if (cell->is_locally_owned())'
p21326
aS'        {'
p21327
aS'          fe_values.reinit(cell);'
p21328
aS'          cell_matrix = 0;'
p21329
aS'          cell_rhs    = 0;'
p21330
aS'          std::vector<SymmetricTensor<2, dim>> strain_tensor(n_q_points);'
p21331
aS'          fe_values[displacement].get_function_symmetric_gradients('
p21332
aS'            linearization_point, strain_tensor);'
p21333
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p21334
aS'            {'
p21335
aS'              SymmetricTensor<4, dim> stress_strain_tensor_linearized;'
p21336
aS'              SymmetricTensor<4, dim> stress_strain_tensor;'
p21337
aS'              constitutive_law.get_linearized_stress_strain_tensors('
p21338
aS'                strain_tensor[q_point],'
p21339
aS'                stress_strain_tensor_linearized,'
p21340
aS'                stress_strain_tensor);'
p21341
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21342
aS'                {'
p21343
aS'                  const SymmetricTensor<2, dim> stress_phi_i ='
p21344
aS'                    stress_strain_tensor_linearized *'
p21345
aS'                    fe_values[displacement].symmetric_gradient(i, q_point);'
p21346
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p21347
aS'                    cell_matrix(i, j) +='
p21348
aS'                      (stress_phi_i *'
p21349
aS'                       fe_values[displacement].symmetric_gradient(j, q_point) *'
p21350
aS'                       fe_values.JxW(q_point));'
p21351
aS'                  cell_rhs(i) +='
p21352
aS'                    ((stress_phi_i -'
p21353
aS'                      stress_strain_tensor *'
p21354
aS'                        fe_values[displacement].symmetric_gradient(i,'
p21355
aS'                                                                   q_point)) *'
p21356
aS'                     strain_tensor[q_point] * fe_values.JxW(q_point));'
p21357
aS'                }'
p21358
aS'            }'
p21359
aS'          for (const auto &face : cell->face_iterators())'
p21360
aS'            if (face->at_boundary() && face->boundary_id() == 1)'
p21361
aS'              {'
p21362
aS'                fe_values_face.reinit(cell, face);'
p21363
aS'                boundary_force.vector_value_list('
p21364
aS'                  fe_values_face.get_quadrature_points(),'
p21365
aS'                  boundary_force_values);'
p21366
aS'                for (unsigned int q_point = 0; q_point < n_face_q_points;'
p21367
aS'                     ++q_point)'
p21368
aS'                  {'
p21369
aS'                    Tensor<1, dim> rhs_values;'
p21370
aS'                    rhs_values[2] = boundary_force_values[q_point][2];'
p21371
aS'                    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21372
aS'                      cell_rhs(i) +='
p21373
aS'                        (fe_values_face[displacement].value(i, q_point) *'
p21374
aS'                         rhs_values * fe_values_face.JxW(q_point));'
p21375
aS'                  }'
p21376
aS'              }'
p21377
aS'          cell->get_dof_indices(local_dof_indices);'
p21378
aS'          all_constraints.distribute_local_to_global(cell_matrix,'
p21379
aS'                                                     cell_rhs,'
p21380
aS'                                                     local_dof_indices,'
p21381
aS'                                                     newton_matrix,'
p21382
aS'                                                     newton_rhs,'
p21383
aS'                                                     true);'
p21384
aS'        }'
p21385
aS'    newton_matrix.compress(VectorOperation::add);'
p21386
aS'    newton_rhs.compress(VectorOperation::add);'
p21387
aS'  }'
p21388
aS'  template <int dim>'
p21389
aS'  void PlasticityContactProblem<dim>::compute_nonlinear_residual('
p21390
aS'    const TrilinosWrappers::MPI::Vector &linearization_point)'
p21391
aS'  {'
p21392
aS'    QGauss<dim>     quadrature_formula(fe.degree + 1);'
p21393
aS'    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p21394
aS'    FEValues<dim> fe_values(fe,'
p21395
aS'                            quadrature_formula,'
p21396
aS'                            update_values | update_gradients |'
p21397
aS'                              update_JxW_values);'
p21398
aS'    FEFaceValues<dim> fe_values_face(fe,'
p21399
aS'                                     face_quadrature_formula,'
p21400
aS'                                     update_values | update_quadrature_points |'
p21401
aS'                                       update_JxW_values);'
p21402
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p21403
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p21404
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p21405
aS'    const EquationData::BoundaryForce<dim> boundary_force;'
p21406
aS'    std::vector<Vector<double>> boundary_force_values(n_face_q_points,'
p21407
aS'                                                      Vector<double>(dim));'
p21408
aS'    Vector<double> cell_rhs(dofs_per_cell);'
p21409
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21410
aS'    const FEValuesExtractors::Vector displacement(0);'
p21411
aS'    newton_rhs             = 0;'
p21412
aS'    newton_rhs_uncondensed = 0;'
p21413
aS'    fraction_of_plastic_q_points_per_cell = 0;'
p21414
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p21415
aS'      if (cell->is_locally_owned())'
p21416
aS'        {'
p21417
aS'          fe_values.reinit(cell);'
p21418
aS'          cell_rhs = 0;'
p21419
aS'          std::vector<SymmetricTensor<2, dim>> strain_tensors(n_q_points);'
p21420
aS'          fe_values[displacement].get_function_symmetric_gradients('
p21421
aS'            linearization_point, strain_tensors);'
p21422
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p21423
aS'            {'
p21424
aS'              SymmetricTensor<4, dim> stress_strain_tensor;'
p21425
aS'              const bool              q_point_is_plastic ='
p21426
aS'                constitutive_law.get_stress_strain_tensor('
p21427
aS'                  strain_tensors[q_point], stress_strain_tensor);'
p21428
aS'              if (q_point_is_plastic)'
p21429
aS'                ++fraction_of_plastic_q_points_per_cell('
p21430
aS'                  cell->active_cell_index());'
p21431
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21432
aS'                {'
p21433
aS'                  cell_rhs(i) -='
p21434
aS'                    (strain_tensors[q_point] * stress_strain_tensor *'
p21435
aS'                     fe_values[displacement].symmetric_gradient(i, q_point) *'
p21436
aS'                     fe_values.JxW(q_point));'
p21437
aS'                  Tensor<1, dim> rhs_values;'
p21438
aS'                  rhs_values = 0;'
p21439
aS'                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) *'
p21440
aS'                                  rhs_values * fe_values.JxW(q_point));'
p21441
aS'                }'
p21442
aS'            }'
p21443
aS'          for (const auto &face : cell->face_iterators())'
p21444
aS'            if (face->at_boundary() && face->boundary_id() == 1)'
p21445
aS'              {'
p21446
aS'                fe_values_face.reinit(cell, face);'
p21447
aS'                boundary_force.vector_value_list('
p21448
aS'                  fe_values_face.get_quadrature_points(),'
p21449
aS'                  boundary_force_values);'
p21450
aS'                for (unsigned int q_point = 0; q_point < n_face_q_points;'
p21451
aS'                     ++q_point)'
p21452
aS'                  {'
p21453
aS'                    Tensor<1, dim> rhs_values;'
p21454
aS'                    rhs_values[2] = boundary_force_values[q_point][2];'
p21455
aS'                    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21456
aS'                      cell_rhs(i) +='
p21457
aS'                        (fe_values_face[displacement].value(i, q_point) *'
p21458
aS'                         rhs_values * fe_values_face.JxW(q_point));'
p21459
aS'                  }'
p21460
aS'              }'
p21461
aS'          cell->get_dof_indices(local_dof_indices);'
p21462
aS'          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global('
p21463
aS'            cell_rhs, local_dof_indices, newton_rhs);'
p21464
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21465
aS'            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);'
p21466
aS'        }'
p21467
aS'    fraction_of_plastic_q_points_per_cell /= quadrature_formula.size();'
p21468
aS'    newton_rhs.compress(VectorOperation::add);'
p21469
aS'    newton_rhs_uncondensed.compress(VectorOperation::add);'
p21470
aS'  }'
p21471
aS'  template <int dim>'
p21472
aS'  void PlasticityContactProblem<dim>::solve_newton_system()'
p21473
aS'  {'
p21474
aS'    TimerOutput::Scope t(computing_timer, "Solve");'
p21475
aS'    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p21476
aS'                                                       mpi_communicator);'
p21477
aS'    distributed_solution = solution;'
p21478
aS'    constraints_hanging_nodes.set_zero(distributed_solution);'
p21479
aS'    constraints_hanging_nodes.set_zero(newton_rhs);'
p21480
aS'    TrilinosWrappers::PreconditionAMG preconditioner;'
p21481
aS'    {'
p21482
aS'      TimerOutput::Scope t(computing_timer, "Solve: setup preconditioner");'
p21483
aS'      std::vector<std::vector<bool>> constant_modes;'
p21484
aS'      DoFTools::extract_constant_modes(dof_handler,'
p21485
aS'                                       ComponentMask(),'
p21486
aS'                                       constant_modes);'
p21487
aS'      TrilinosWrappers::PreconditionAMG::AdditionalData additional_data;'
p21488
aS'      additional_data.constant_modes        = constant_modes;'
p21489
aS'      additional_data.elliptic              = true;'
p21490
aS'      additional_data.n_cycles              = 1;'
p21491
aS'      additional_data.w_cycle               = false;'
p21492
aS'      additional_data.output_details        = false;'
p21493
aS'      additional_data.smoother_sweeps       = 2;'
p21494
aS'      additional_data.aggregation_threshold = 1e-2;'
p21495
aS'      preconditioner.initialize(newton_matrix, additional_data);'
p21496
aS'    }'
p21497
aS'    {'
p21498
aS'      TimerOutput::Scope t(computing_timer, "Solve: iterate");'
p21499
aS'      TrilinosWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator);'
p21500
aS'      const double relative_accuracy = 1e-8;'
p21501
aS'      const double solver_tolerance ='
p21502
aS'        relative_accuracy *'
p21503
aS'        newton_matrix.residual(tmp, distributed_solution, newton_rhs);'
p21504
aS'      SolverControl solver_control(newton_matrix.m(), solver_tolerance);'
p21505
aS'      SolverBicgstab<TrilinosWrappers::MPI::Vector> solver(solver_control);'
p21506
aS'      solver.solve(newton_matrix,'
p21507
aS'                   distributed_solution,'
p21508
aS'                   newton_rhs,'
p21509
aS'                   preconditioner);'
p21510
aS'      pcout << "         Error: " << solver_control.initial_value() << " -> "'
p21511
aS'            << solver_control.last_value() << " in "'
p21512
aS'            << solver_control.last_step() << " Bicgstab iterations."'
p21513
aS'            << std::endl;'
p21514
aS'    }'
p21515
aS'    all_constraints.distribute(distributed_solution);'
p21516
aS'    solution = distributed_solution;'
p21517
aS'  }'
p21518
aS'  template <int dim>'
p21519
aS'  void PlasticityContactProblem<dim>::solve_newton()'
p21520
aS'  {'
p21521
aS'    TrilinosWrappers::MPI::Vector old_solution(locally_owned_dofs,'
p21522
aS'                                               mpi_communicator);'
p21523
aS'    TrilinosWrappers::MPI::Vector residual(locally_owned_dofs,'
p21524
aS'                                           mpi_communicator);'
p21525
aS'    TrilinosWrappers::MPI::Vector tmp_vector(locally_owned_dofs,'
p21526
aS'                                             mpi_communicator);'
p21527
aS'    TrilinosWrappers::MPI::Vector locally_relevant_tmp_vector('
p21528
aS'      locally_relevant_dofs, mpi_communicator);'
p21529
aS'    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p21530
aS'                                                       mpi_communicator);'
p21531
aS'    double residual_norm;'
p21532
aS'    double previous_residual_norm = -std::numeric_limits<double>::max();'
p21533
aS'    const double correct_sigma = sigma_0;'
p21534
aS'    IndexSet old_active_set(active_set);'
p21535
aS'    for (unsigned int newton_step = 1; newton_step <= 100; ++newton_step)'
p21536
aS'      {'
p21537
aS'        if (newton_step == 1 &&'
p21538
aS'            ((transfer_solution && current_refinement_cycle == 0) ||'
p21539
aS'             !transfer_solution))'
p21540
aS'          constitutive_law.set_sigma_0(1e+10);'
p21541
aS'        else if (newton_step == 2 || current_refinement_cycle > 0 ||'
p21542
aS'                 !transfer_solution)'
p21543
aS'          constitutive_law.set_sigma_0(correct_sigma);'
p21544
aS'        pcout << " " << std::endl;'
p21545
aS'        pcout << "   Newton iteration " << newton_step << std::endl;'
p21546
aS'        pcout << "      Updating active set..." << std::endl;'
p21547
aS'        {'
p21548
aS'          TimerOutput::Scope t(computing_timer, "update active set");'
p21549
aS'          update_solution_and_constraints();'
p21550
aS'        }'
p21551
aS'        pcout << "      Assembling system... " << std::endl;'
p21552
aS'        newton_matrix = 0;'
p21553
aS'        newton_rhs    = 0;'
p21554
aS'        assemble_newton_system(solution);'
p21555
aS'        pcout << "      Solving system... " << std::endl;'
p21556
aS'        solve_newton_system();'
p21557
aS'        if ((newton_step == 1) ||'
p21558
aS'            (transfer_solution && newton_step == 2 &&'
p21559
aS'             current_refinement_cycle == 0) ||'
p21560
aS'            (!transfer_solution && newton_step == 2))'
p21561
aS'          {'
p21562
aS'            compute_nonlinear_residual(solution);'
p21563
aS'            old_solution = solution;'
p21564
aS'            residual                     = newton_rhs;'
p21565
aS'            const unsigned int start_res = (residual.local_range().first),'
p21566
aS'                               end_res   = (residual.local_range().second);'
p21567
aS'            for (unsigned int n = start_res; n < end_res; ++n)'
p21568
aS'              if (all_constraints.is_inhomogeneously_constrained(n))'
p21569
aS'                residual(n) = 0;'
p21570
aS'            residual.compress(VectorOperation::insert);'
p21571
aS'            residual_norm = residual.l2_norm();'
p21572
aS'            pcout << "      Accepting Newton solution with residual: "'
p21573
aS'                  << residual_norm << std::endl;'
p21574
aS'          }'
p21575
aS'        else'
p21576
aS'          {'
p21577
aS'            for (unsigned int i = 0; i < 5; ++i)'
p21578
aS'              {'
p21579
aS'                distributed_solution = solution;'
p21580
aS'                const double alpha = std::pow(0.5, static_cast<double>(i));'
p21581
aS'                tmp_vector         = old_solution;'
p21582
aS'                tmp_vector.sadd(1 - alpha, alpha, distributed_solution);'
p21583
aS'                TimerOutput::Scope t(computing_timer, "Residual and lambda");'
p21584
aS'                locally_relevant_tmp_vector = tmp_vector;'
p21585
aS'                compute_nonlinear_residual(locally_relevant_tmp_vector);'
p21586
aS'                residual = newton_rhs;'
p21587
aS'                const unsigned int start_res = (residual.local_range().first),'
p21588
aS'                                   end_res   = (residual.local_range().second);'
p21589
aS'                for (unsigned int n = start_res; n < end_res; ++n)'
p21590
aS'                  if (all_constraints.is_inhomogeneously_constrained(n))'
p21591
aS'                    residual(n) = 0;'
p21592
aS'                residual.compress(VectorOperation::insert);'
p21593
aS'                residual_norm = residual.l2_norm();'
p21594
aS'                pcout'
p21595
aS'                  << "      Residual of the non-contact part of the system: "'
p21596
aS'                  << residual_norm << std::endl'
p21597
aS'                  << "         with a damping parameter alpha = " << alpha'
p21598
aS'                  << std::endl;'
p21599
aS'                if (residual_norm < previous_residual_norm)'
p21600
aS'                  break;'
p21601
aS'              }'
p21602
aS'            solution     = tmp_vector;'
p21603
aS'            old_solution = solution;'
p21604
aS'          }'
p21605
aS'        previous_residual_norm = residual_norm;'
p21606
aS'        if (Utilities::MPI::sum((active_set == old_active_set) ? 0 : 1,'
p21607
aS'                                mpi_communicator) == 0)'
p21608
aS'          {'
p21609
aS'            pcout << "      Active set did not change!" << std::endl;'
p21610
aS'            if (residual_norm < 1e-10)'
p21611
aS'              break;'
p21612
aS'          }'
p21613
aS'        old_active_set = active_set;'
p21614
aS'      }'
p21615
aS'  }'
p21616
aS'  template <int dim>'
p21617
aS'  void PlasticityContactProblem<dim>::refine_grid()'
p21618
aS'  {'
p21619
aS'    if (refinement_strategy == RefinementStrategy::refine_global)'
p21620
aS'      {'
p21621
aS'        for (typename Triangulation<dim>::active_cell_iterator cell ='
p21622
aS'               triangulation.begin_active();'
p21623
aS'             cell != triangulation.end();'
p21624
aS'             ++cell)'
p21625
aS'          if (cell->is_locally_owned())'
p21626
aS'            cell->set_refine_flag();'
p21627
aS'      }'
p21628
aS'    else'
p21629
aS'      {'
p21630
aS'        Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p21631
aS'        KellyErrorEstimator<dim>::estimate('
p21632
aS'          dof_handler,'
p21633
aS'          QGauss<dim - 1>(fe.degree + 2),'
p21634
aS'          std::map<types::boundary_id, const Function<dim> *>(),'
p21635
aS'          solution,'
p21636
aS'          estimated_error_per_cell);'
p21637
aS'        parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number('
p21638
aS'          triangulation, estimated_error_per_cell, 0.3, 0.03);'
p21639
aS'      }'
p21640
aS'    triangulation.prepare_coarsening_and_refinement();'
p21641
aS'    parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector>'
p21642
aS'      solution_transfer(dof_handler);'
p21643
aS'    if (transfer_solution)'
p21644
aS'      solution_transfer.prepare_for_coarsening_and_refinement(solution);'
p21645
aS'    triangulation.execute_coarsening_and_refinement();'
p21646
aS'    setup_system();'
p21647
aS'    if (transfer_solution)'
p21648
aS'      {'
p21649
aS'        TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p21650
aS'                                                           mpi_communicator);'
p21651
aS'        solution_transfer.interpolate(distributed_solution);'
p21652
aS'        constraints_hanging_nodes.distribute(distributed_solution);'
p21653
aS'        solution = distributed_solution;'
p21654
aS'        compute_nonlinear_residual(solution);'
p21655
aS'      }'
p21656
aS'  }'
p21657
aS'  template <int dim>'
p21658
aS'  void PlasticityContactProblem<dim>::move_mesh('
p21659
aS'    const TrilinosWrappers::MPI::Vector &displacement) const'
p21660
aS'  {'
p21661
aS'    std::vector<bool> vertex_touched(triangulation.n_vertices(), false);'
p21662
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p21663
aS'      if (cell->is_locally_owned())'
p21664
aS'        for (const auto v : cell->vertex_indices())'
p21665
aS'          if (vertex_touched[cell->vertex_index(v)] == false)'
p21666
aS'            {'
p21667
aS'              vertex_touched[cell->vertex_index(v)] = true;'
p21668
aS'              Point<dim> vertex_displacement;'
p21669
aS'              for (unsigned int d = 0; d < dim; ++d)'
p21670
aS'                vertex_displacement[d] ='
p21671
aS'                  displacement(cell->vertex_dof_index(v, d));'
p21672
aS'              cell->vertex(v) += vertex_displacement;'
p21673
aS'            }'
p21674
aS'  }'
p21675
aS'  template <int dim>'
p21676
aS'  void PlasticityContactProblem<dim>::output_results('
p21677
aS'    const unsigned int current_refinement_cycle)'
p21678
aS'  {'
p21679
aS'    TimerOutput::Scope t(computing_timer, "Graphical output");'
p21680
aS'    pcout << "      Writing graphical output... " << std::flush;'
p21681
aS'    move_mesh(solution);'
p21682
aS'    TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,'
p21683
aS'                                                     mpi_communicator);'
p21684
aS'    const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),'
p21685
aS'                       end_res = (newton_rhs_uncondensed.local_range().second);'
p21686
aS'    for (unsigned int n = start_res; n < end_res; ++n)'
p21687
aS'      if (all_constraints.is_inhomogeneously_constrained(n))'
p21688
aS'        distributed_lambda(n) ='
p21689
aS'          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);'
p21690
aS'    distributed_lambda.compress(VectorOperation::insert);'
p21691
aS'    constraints_hanging_nodes.distribute(distributed_lambda);'
p21692
aS'    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,'
p21693
aS'                                         mpi_communicator);'
p21694
aS'    lambda = distributed_lambda;'
p21695
aS'    TrilinosWrappers::MPI::Vector distributed_active_set_vector('
p21696
aS'      locally_owned_dofs, mpi_communicator);'
p21697
aS'    distributed_active_set_vector = 0.;'
p21698
aS'    for (const auto index : active_set)'
p21699
aS'      distributed_active_set_vector[index] = 1.;'
p21700
aS'    distributed_lambda.compress(VectorOperation::insert);'
p21701
aS'    TrilinosWrappers::MPI::Vector active_set_vector(locally_relevant_dofs,'
p21702
aS'                                                    mpi_communicator);'
p21703
aS'    active_set_vector = distributed_active_set_vector;'
p21704
aS'    DataOut<dim> data_out;'
p21705
aS'    data_out.attach_dof_handler(dof_handler);'
p21706
aS'    const std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p21707
aS'      data_component_interpretation('
p21708
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p21709
aS'    data_out.add_data_vector(solution,'
p21710
aS'                             std::vector<std::string>(dim, "displacement"),'
p21711
aS'                             DataOut<dim>::type_dof_data,'
p21712
aS'                             data_component_interpretation);'
p21713
aS'    data_out.add_data_vector(lambda,'
p21714
aS'                             std::vector<std::string>(dim, "contact_force"),'
p21715
aS'                             DataOut<dim>::type_dof_data,'
p21716
aS'                             data_component_interpretation);'
p21717
aS'    data_out.add_data_vector(active_set_vector,'
p21718
aS'                             std::vector<std::string>(dim, "active_set"),'
p21719
aS'                             DataOut<dim>::type_dof_data,'
p21720
aS'                             data_component_interpretation);'
p21721
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p21722
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p21723
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p21724
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p21725
aS'    data_out.add_data_vector(fraction_of_plastic_q_points_per_cell,'
p21726
aS'                             "fraction_of_plastic_q_points");'
p21727
aS'    data_out.build_patches();'
p21728
aS'    const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record('
p21729
aS'      output_dir, "solution", current_refinement_cycle, mpi_communicator, 2);'
p21730
aS'    pcout << pvtu_filename << std::endl;'
p21731
aS'    TrilinosWrappers::MPI::Vector tmp(solution);'
p21732
aS'    tmp *= -1;'
p21733
aS'    move_mesh(tmp);'
p21734
aS'  }'
p21735
aS'  template <int dim>'
p21736
aS'  void PlasticityContactProblem<dim>::output_contact_force() const'
p21737
aS'  {'
p21738
aS'    TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,'
p21739
aS'                                                     mpi_communicator);'
p21740
aS'    const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),'
p21741
aS'                       end_res = (newton_rhs_uncondensed.local_range().second);'
p21742
aS'    for (unsigned int n = start_res; n < end_res; ++n)'
p21743
aS'      if (all_constraints.is_inhomogeneously_constrained(n))'
p21744
aS'        distributed_lambda(n) ='
p21745
aS'          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);'
p21746
aS'      else'
p21747
aS'        distributed_lambda(n) = 0;'
p21748
aS'    distributed_lambda.compress(VectorOperation::insert);'
p21749
aS'    constraints_hanging_nodes.distribute(distributed_lambda);'
p21750
aS'    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,'
p21751
aS'                                         mpi_communicator);'
p21752
aS'    lambda = distributed_lambda;'
p21753
aS'    double contact_force = 0.0;'
p21754
aS'    QGauss<dim - 1>   face_quadrature_formula(fe.degree + 1);'
p21755
aS'    FEFaceValues<dim> fe_values_face(fe,'
p21756
aS'                                     face_quadrature_formula,'
p21757
aS'                                     update_values | update_JxW_values);'
p21758
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p21759
aS'    const FEValuesExtractors::Vector displacement(0);'
p21760
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p21761
aS'      if (cell->is_locally_owned())'
p21762
aS'        for (const auto &face : cell->face_iterators())'
p21763
aS'          if (face->at_boundary() && face->boundary_id() == 1)'
p21764
aS'            {'
p21765
aS'              fe_values_face.reinit(cell, face);'
p21766
aS'              std::vector<Tensor<1, dim>> lambda_values(n_face_q_points);'
p21767
aS'              fe_values_face[displacement].get_function_values(lambda,'
p21768
aS'                                                               lambda_values);'
p21769
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p21770
aS'                   ++q_point)'
p21771
aS'                contact_force +='
p21772
aS'                  lambda_values[q_point][2] * fe_values_face.JxW(q_point);'
p21773
aS'            }'
p21774
aS'    contact_force = Utilities::MPI::sum(contact_force, MPI_COMM_WORLD);'
p21775
aS'    pcout << "Contact force = " << contact_force << std::endl;'
p21776
aS'  }'
p21777
aS'  template <int dim>'
p21778
aS'  void PlasticityContactProblem<dim>::run()'
p21779
aS'  {'
p21780
aS'    computing_timer.reset();'
p21781
aS'    for (; current_refinement_cycle < n_refinement_cycles;'
p21782
aS'         ++current_refinement_cycle)'
p21783
aS'      {'
p21784
aS'        {'
p21785
aS'          TimerOutput::Scope t(computing_timer, "Setup");'
p21786
aS'          pcout << std::endl;'
p21787
aS'          pcout << "Cycle " << current_refinement_cycle << \':\' << std::endl;'
p21788
aS'          if (current_refinement_cycle == 0)'
p21789
aS'            {'
p21790
aS'              make_grid();'
p21791
aS'              setup_system();'
p21792
aS'            }'
p21793
aS'          else'
p21794
aS'            {'
p21795
aS'              TimerOutput::Scope t(computing_timer, "Setup: refine mesh");'
p21796
aS'              refine_grid();'
p21797
aS'            }'
p21798
aS'        }'
p21799
aS'        solve_newton();'
p21800
aS'        output_results(current_refinement_cycle);'
p21801
aS'        computing_timer.print_summary();'
p21802
aS'        computing_timer.reset();'
p21803
aS'        Utilities::System::MemoryStats stats;'
p21804
aS'        Utilities::System::get_memory_stats(stats);'
p21805
aS'        pcout << "Peak virtual memory used, resident in kB: " << stats.VmSize'
p21806
aS'              << " " << stats.VmRSS << std::endl;'
p21807
aS'        if (base_mesh == "box")'
p21808
aS'          output_contact_force();'
p21809
aS'      }'
p21810
aS'  }'
p21811
aS'} // namespace Step42'
p21812
aS'int main(int argc, char *argv[])'
p21813
ag24
aS'  using namespace dealii;'
p21814
aS'  using namespace Step42;'
p21815
aS'  try'
p21816
aS'    {'
p21817
aS'      ParameterHandler prm;'
p21818
aS'      PlasticityContactProblem<3>::declare_parameters(prm);'
p21819
aS'      if (argc != 2)'
p21820
aS'        {'
p21821
aS'          std::cerr << "*** Call this program as <./step-42 input.prm>"'
p21822
aS'                    << std::endl;'
p21823
aS'          return 1;'
p21824
aS'        }'
p21825
aS'      prm.parse_input(argv[1]);'
p21826
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p21827
aS'        argc, argv, numbers::invalid_unsigned_int);'
p21828
aS'      {'
p21829
aS'        PlasticityContactProblem<3> problem(prm);'
p21830
aS'        problem.run();'
p21831
aS'      }'
p21832
aS'    }'
p21833
aS'  catch (std::exception &exc)'
p21834
aS'    {'
p21835
aS'      std::cerr << std::endl'
p21836
aS'                << std::endl'
p21837
aS'                << "----------------------------------------------------"'
p21838
aS'                << std::endl;'
p21839
aS'      std::cerr << "Exception on processing: " << std::endl'
p21840
aS'                << exc.what() << std::endl'
p21841
aS'                << "Aborting!" << std::endl'
p21842
aS'                << "----------------------------------------------------"'
p21843
aS'                << std::endl;'
p21844
aS'      return 1;'
p21845
aS'    }'
p21846
aS'  catch (...)'
p21847
aS'    {'
p21848
aS'      std::cerr << std::endl'
p21849
aS'                << std::endl'
p21850
aS'                << "----------------------------------------------------"'
p21851
aS'                << std::endl;'
p21852
aS'      std::cerr << "Unknown exception!" << std::endl'
p21853
aS'                << "Aborting!" << std::endl'
p21854
aS'                << "----------------------------------------------------"'
p21855
aS'                << std::endl;'
p21856
aS'      return 1;'
p21857
aS'    }'
p21858
aS'  return 0;'
p21859
ag32
aS'/* ---------------------------------------------------------------------'
p21860
aS' *'
p21861
aS' * Copyright (C) 2010 - 2021 by the deal.II authors'
p21862
aS' *'
p21863
aS' * This file is part of the deal.II library.'
p21864
aS' *'
p21865
aS' * The deal.II library is free software; you can use it, redistribute'
p21866
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p21867
aS' * Public License as published by the Free Software Foundation; either'
p21868
aS' * version 2.1 of the License, or (at your option) any later version.'
p21869
aS' * The full text of the license can be found in the file LICENSE.md at'
p21870
aS' * the top level directory of deal.II.'
p21871
aS' *'
p21872
aS' * ---------------------------------------------------------------------'
p21873
aS' *'
p21874
aS' * Authors: Chih-Che Chueh, University of Victoria, 2010'
p21875
aS' *          Wolfgang Bangerth, Texas A&M University, 2010'
p21876
aS' */'
p21877
aS'#include <deal.II/base/quadrature_lib.h>'
p21878
aS'#include <deal.II/base/logstream.h>'
p21879
aS'#include <deal.II/base/utilities.h>'
p21880
aS'#include <deal.II/base/function.h>'
p21881
aS'#include <deal.II/base/tensor_function.h>'
p21882
aS'#include <deal.II/base/index_set.h>'
p21883
aS'#include <deal.II/lac/full_matrix.h>'
p21884
aS'#include <deal.II/lac/solver_gmres.h>'
p21885
aS'#include <deal.II/lac/solver_cg.h>'
p21886
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p21887
aS'#include <deal.II/lac/affine_constraints.h>'
p21888
aS'#include <deal.II/grid/tria.h>'
p21889
aS'#include <deal.II/grid/grid_generator.h>'
p21890
aS'#include <deal.II/grid/grid_tools.h>'
p21891
aS'#include <deal.II/dofs/dof_handler.h>'
p21892
aS'#include <deal.II/dofs/dof_renumbering.h>'
p21893
aS'#include <deal.II/dofs/dof_tools.h>'
p21894
aS'#include <deal.II/fe/fe_q.h>'
p21895
aS'#include <deal.II/fe/fe_system.h>'
p21896
aS'#include <deal.II/fe/fe_values.h>'
p21897
aS'#include <deal.II/numerics/vector_tools.h>'
p21898
aS'#include <deal.II/numerics/data_out.h>'
p21899
aS'#include <deal.II/numerics/solution_transfer.h>'
p21900
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p21901
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p21902
aS'#include <deal.II/lac/trilinos_vector.h>'
p21903
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p21904
aS'#include <deal.II/lac/trilinos_precondition.h>'
p21905
aS'#include <iostream>'
p21906
aS'#include <fstream>'
p21907
aS'#include <memory>'
p21908
aS'namespace Step43'
p21909
ag24
aS'  using namespace dealii;'
p21910
aS'  template <int dim>'
p21911
aS'  class PressureBoundaryValues : public Function<dim>'
p21912
aS'  {'
p21913
aS'  public:'
p21914
aS'    PressureBoundaryValues()'
p21915
aS'      : Function<dim>(1)'
p21916
aS'    {}'
p21917
aS'    virtual double value(const Point<dim> & p,'
p21918
aS'                         const unsigned int component = 0) const override;'
p21919
aS'  };'
p21920
aS'  template <int dim>'
p21921
aS'  double'
p21922
aS'  PressureBoundaryValues<dim>::value(const Point<dim> &p,'
p21923
aS'                                     const unsigned int /*component*/) const'
p21924
aS'  {'
p21925
aS'    return 1 - p[0];'
p21926
aS'  }'
p21927
aS'  template <int dim>'
p21928
aS'  class SaturationBoundaryValues : public Function<dim>'
p21929
aS'  {'
p21930
aS'  public:'
p21931
aS'    SaturationBoundaryValues()'
p21932
aS'      : Function<dim>(1)'
p21933
aS'    {}'
p21934
aS'    virtual double value(const Point<dim> & p,'
p21935
aS'                         const unsigned int component = 0) const override;'
p21936
aS'  };'
p21937
aS'  template <int dim>'
p21938
aS'  double'
p21939
aS'  SaturationBoundaryValues<dim>::value(const Point<dim> &p,'
p21940
aS'                                       const unsigned int /*component*/) const'
p21941
aS'  {'
p21942
aS'    if (p[0] == 0)'
p21943
aS'      return 1;'
p21944
aS'    else'
p21945
aS'      return 0;'
p21946
aS'  }'
p21947
aS'  template <int dim>'
p21948
aS'  class SaturationInitialValues : public Function<dim>'
p21949
aS'  {'
p21950
aS'  public:'
p21951
aS'    SaturationInitialValues()'
p21952
aS'      : Function<dim>(1)'
p21953
aS'    {}'
p21954
aS'    virtual double value(const Point<dim> & p,'
p21955
aS'                         const unsigned int component = 0) const override;'
p21956
aS'    virtual void vector_value(const Point<dim> &p,'
p21957
aS'                              Vector<double> &  value) const override;'
p21958
aS'  };'
p21959
aS'  template <int dim>'
p21960
aS'  double'
p21961
aS'  SaturationInitialValues<dim>::value(const Point<dim> & /*p*/,'
p21962
aS'                                      const unsigned int /*component*/) const'
p21963
aS'  {'
p21964
aS'    return 0.2;'
p21965
aS'  }'
p21966
aS'  template <int dim>'
p21967
aS'  void SaturationInitialValues<dim>::vector_value(const Point<dim> &p,'
p21968
aS'                                                  Vector<double> &values) const'
p21969
aS'  {'
p21970
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p21971
aS'      values(c) = SaturationInitialValues<dim>::value(p, c);'
p21972
aS'  }'
p21973
aS'  namespace SingleCurvingCrack'
p21974
aS'  {'
p21975
aS'    template <int dim>'
p21976
aS'    class KInverse : public TensorFunction<2, dim>'
p21977
aS'    {'
p21978
aS'    public:'
p21979
aS'      KInverse()'
p21980
aS'        : TensorFunction<2, dim>()'
p21981
aS'      {}'
p21982
aS'      virtual void'
p21983
aS'      value_list(const std::vector<Point<dim>> &points,'
p21984
aS'                 std::vector<Tensor<2, dim>> &  values) const override;'
p21985
aS'    };'
p21986
aS'    template <int dim>'
p21987
aS'    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,'
p21988
aS'                                   std::vector<Tensor<2, dim>> &  values) const'
p21989
aS'    {'
p21990
aS'      Assert(points.size() == values.size(),'
p21991
aS'             ExcDimensionMismatch(points.size(), values.size()));'
p21992
aS'      for (unsigned int p = 0; p < points.size(); ++p)'
p21993
aS'        {'
p21994
aS'          values[p].clear();'
p21995
aS'          const double distance_to_flowline ='
p21996
aS'            std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));'
p21997
aS'          const double permeability ='
p21998
aS'            std::max(std::exp(-(distance_to_flowline * distance_to_flowline) /'
p21999
aS'                              (0.1 * 0.1)),'
p22000
aS'                     0.01);'
p22001
aS'          for (unsigned int d = 0; d < dim; ++d)'
p22002
aS'            values[p][d][d] = 1. / permeability;'
p22003
aS'        }'
p22004
aS'    }'
p22005
aS'  } // namespace SingleCurvingCrack'
p22006
aS'  namespace RandomMedium'
p22007
aS'  {'
p22008
aS'    template <int dim>'
p22009
aS'    class KInverse : public TensorFunction<2, dim>'
p22010
aS'    {'
p22011
aS'    public:'
p22012
aS'      KInverse()'
p22013
aS'        : TensorFunction<2, dim>()'
p22014
aS'      {}'
p22015
aS'      virtual void'
p22016
aS'      value_list(const std::vector<Point<dim>> &points,'
p22017
aS'                 std::vector<Tensor<2, dim>> &  values) const override;'
p22018
aS'    private:'
p22019
aS'      static std::vector<Point<dim>> centers;'
p22020
aS'    };'
p22021
aS'    template <int dim>'
p22022
aS'    std::vector<Point<dim>> KInverse<dim>::centers = []() {'
p22023
aS'      const unsigned int N ='
p22024
aS'        (dim == 2 ? 40 : (dim == 3 ? 100 : throw ExcNotImplemented()));'
p22025
aS'      std::vector<Point<dim>> centers_list(N);'
p22026
aS'      for (unsigned int i = 0; i < N; ++i)'
p22027
aS'        for (unsigned int d = 0; d < dim; ++d)'
p22028
aS'          centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX;'
p22029
aS'      return centers_list;'
p22030
aS'    }();'
p22031
aS'    template <int dim>'
p22032
aS'    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,'
p22033
aS'                                   std::vector<Tensor<2, dim>> &  values) const'
p22034
aS'    {'
p22035
aS'      AssertDimension(points.size(), values.size());'
p22036
aS'      for (unsigned int p = 0; p < points.size(); ++p)'
p22037
aS'        {'
p22038
aS'          values[p].clear();'
p22039
aS'          double permeability = 0;'
p22040
aS'          for (unsigned int i = 0; i < centers.size(); ++i)'
p22041
aS'            permeability +='
p22042
aS'              std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));'
p22043
aS'          const double normalized_permeability ='
p22044
aS'            std::min(std::max(permeability, 0.01), 4.);'
p22045
aS'          for (unsigned int d = 0; d < dim; ++d)'
p22046
aS'            values[p][d][d] = 1. / normalized_permeability;'
p22047
aS'        }'
p22048
aS'    }'
p22049
aS'  } // namespace RandomMedium'
p22050
aS'  double mobility_inverse(const double S, const double viscosity)'
p22051
aS'  {'
p22052
aS'    return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));'
p22053
aS'  }'
p22054
aS'  double fractional_flow(const double S, const double viscosity)'
p22055
aS'  {'
p22056
aS'    Assert((S >= 0) && (S <= 1),'
p22057
aS'           ExcMessage("Saturation is outside its physically valid range."));'
p22058
aS'    return S * S / (S * S + viscosity * (1 - S) * (1 - S));'
p22059
aS'  }'
p22060
aS'  double fractional_flow_derivative(const double S, const double viscosity)'
p22061
aS'  {'
p22062
aS'    Assert((S >= 0) && (S <= 1),'
p22063
aS'           ExcMessage("Saturation is outside its physically valid range."));'
p22064
aS'    const double temp = (S * S + viscosity * (1 - S) * (1 - S));'
p22065
aS'    const double numerator ='
p22066
aS'      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));'
p22067
aS'    const double denominator = std::pow(temp, 2.0);'
p22068
aS'    const double F_prime = numerator / denominator;'
p22069
aS'    Assert(F_prime >= 0, ExcInternalError());'
p22070
aS'    return F_prime;'
p22071
aS'  }'
p22072
aS'  namespace LinearSolvers'
p22073
aS'  {'
p22074
aS'    template <class MatrixType, class PreconditionerType>'
p22075
aS'    class InverseMatrix : public Subscriptor'
p22076
aS'    {'
p22077
aS'    public:'
p22078
aS'      InverseMatrix(const MatrixType &        m,'
p22079
aS'                    const PreconditionerType &preconditioner);'
p22080
aS'      template <typename VectorType>'
p22081
aS'      void vmult(VectorType &dst, const VectorType &src) const;'
p22082
aS'    private:'
p22083
aS'      const SmartPointer<const MatrixType> matrix;'
p22084
aS'      const PreconditionerType &           preconditioner;'
p22085
aS'    };'
p22086
aS'    template <class MatrixType, class PreconditionerType>'
p22087
aS'    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p22088
aS'      const MatrixType &        m,'
p22089
aS'      const PreconditionerType &preconditioner)'
p22090
aS'      : matrix(&m)'
p22091
aS'      , preconditioner(preconditioner)'
p22092
aS'    {}'
p22093
aS'    template <class MatrixType, class PreconditionerType>'
p22094
aS'    template <typename VectorType>'
p22095
aS'    void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p22096
aS'      VectorType &      dst,'
p22097
aS'      const VectorType &src) const'
p22098
aS'    {'
p22099
aS'      SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm());'
p22100
aS'      SolverCG<VectorType> cg(solver_control);'
p22101
aS'      dst = 0;'
p22102
aS'      try'
p22103
aS'        {'
p22104
aS'          cg.solve(*matrix, dst, src, preconditioner);'
p22105
aS'        }'
p22106
aS'      catch (std::exception &e)'
p22107
aS'        {'
p22108
aS'          Assert(false, ExcMessage(e.what()));'
p22109
aS'        }'
p22110
aS'    }'
p22111
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p22112
aS'    class BlockSchurPreconditioner : public Subscriptor'
p22113
aS'    {'
p22114
aS'    public:'
p22115
aS'      BlockSchurPreconditioner('
p22116
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p22117
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p22118
aS'                            PreconditionerTypeMp> &Mpinv,'
p22119
aS'        const PreconditionerTypeA &                Apreconditioner);'
p22120
aS'      void vmult(TrilinosWrappers::MPI::BlockVector &      dst,'
p22121
aS'                 const TrilinosWrappers::MPI::BlockVector &src) const;'
p22122
aS'    private:'
p22123
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p22124
aS'        darcy_matrix;'
p22125
aS'      const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p22126
aS'                                             PreconditionerTypeMp>>'
p22127
aS'                                 m_inverse;'
p22128
aS'      const PreconditionerTypeA &a_preconditioner;'
p22129
aS'      mutable TrilinosWrappers::MPI::Vector tmp;'
p22130
aS'    };'
p22131
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p22132
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::'
p22133
aS'      BlockSchurPreconditioner('
p22134
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p22135
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p22136
aS'                            PreconditionerTypeMp> &Mpinv,'
p22137
aS'        const PreconditionerTypeA &                Apreconditioner)'
p22138
aS'      : darcy_matrix(&S)'
p22139
aS'      , m_inverse(&Mpinv)'
p22140
aS'      , a_preconditioner(Apreconditioner)'
p22141
aS'      , tmp(complete_index_set(darcy_matrix->block(1, 1).m()))'
p22142
aS'    {}'
p22143
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p22144
aS'    void'
p22145
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult('
p22146
aS'      TrilinosWrappers::MPI::BlockVector &      dst,'
p22147
aS'      const TrilinosWrappers::MPI::BlockVector &src) const'
p22148
aS'    {'
p22149
aS'      a_preconditioner.vmult(dst.block(0), src.block(0));'
p22150
aS'      darcy_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1));'
p22151
aS'      tmp *= -1;'
p22152
aS'      m_inverse->vmult(dst.block(1), tmp);'
p22153
aS'    }'
p22154
aS'  } // namespace LinearSolvers'
p22155
aS'  template <int dim>'
p22156
aS'  class TwoPhaseFlowProblem'
p22157
aS'  {'
p22158
aS'  public:'
p22159
aS'    TwoPhaseFlowProblem(const unsigned int degree);'
p22160
aS'    void run();'
p22161
aS'  private:'
p22162
aS'    void setup_dofs();'
p22163
aS'    void assemble_darcy_preconditioner();'
p22164
aS'    void build_darcy_preconditioner();'
p22165
aS'    void assemble_darcy_system();'
p22166
aS'    void assemble_saturation_system();'
p22167
aS'    void assemble_saturation_matrix();'
p22168
aS'    void assemble_saturation_rhs();'
p22169
aS'    void assemble_saturation_rhs_cell_term('
p22170
aS'      const FEValues<dim> &                       saturation_fe_values,'
p22171
aS'      const FEValues<dim> &                       darcy_fe_values,'
p22172
aS'      const double                                global_max_u_F_prime,'
p22173
aS'      const double                                global_S_variation,'
p22174
aS'      const std::vector<types::global_dof_index> &local_dof_indices);'
p22175
aS'    void assemble_saturation_rhs_boundary_term('
p22176
aS'      const FEFaceValues<dim> &                   saturation_fe_face_values,'
p22177
aS'      const FEFaceValues<dim> &                   darcy_fe_face_values,'
p22178
aS'      const std::vector<types::global_dof_index> &local_dof_indices);'
p22179
aS'    void solve();'
p22180
aS'    void refine_mesh(const unsigned int min_grid_level,'
p22181
aS'                     const unsigned int max_grid_level);'
p22182
aS'    void output_results() const;'
p22183
aS'    double                    get_max_u_F_prime() const;'
p22184
aS'    std::pair<double, double> get_extrapolated_saturation_range() const;'
p22185
aS'    bool   determine_whether_to_solve_for_pressure_and_velocity() const;'
p22186
aS'    void   project_back_saturation();'
p22187
aS'    double compute_viscosity('
p22188
aS'      const std::vector<double> &        old_saturation,'
p22189
aS'      const std::vector<double> &        old_old_saturation,'
p22190
aS'      const std::vector<Tensor<1, dim>> &old_saturation_grads,'
p22191
aS'      const std::vector<Tensor<1, dim>> &old_old_saturation_grads,'
p22192
aS'      const std::vector<Vector<double>> &present_darcy_values,'
p22193
aS'      const double                       global_max_u_F_prime,'
p22194
aS'      const double                       global_S_variation,'
p22195
aS'      const double                       cell_diameter) const;'
p22196
aS'    Triangulation<dim> triangulation;'
p22197
aS'    double             global_Omega_diameter;'
p22198
aS'    const unsigned int degree;'
p22199
aS'    const unsigned int        darcy_degree;'
p22200
aS'    FESystem<dim>             darcy_fe;'
p22201
aS'    DoFHandler<dim>           darcy_dof_handler;'
p22202
aS'    AffineConstraints<double> darcy_constraints;'
p22203
aS'    AffineConstraints<double> darcy_preconditioner_constraints;'
p22204
aS'    TrilinosWrappers::BlockSparseMatrix darcy_matrix;'
p22205
aS'    TrilinosWrappers::BlockSparseMatrix darcy_preconditioner_matrix;'
p22206
aS'    TrilinosWrappers::MPI::BlockVector darcy_solution;'
p22207
aS'    TrilinosWrappers::MPI::BlockVector darcy_rhs;'
p22208
aS'    TrilinosWrappers::MPI::BlockVector last_computed_darcy_solution;'
p22209
aS'    TrilinosWrappers::MPI::BlockVector second_last_computed_darcy_solution;'
p22210
aS'    const unsigned int        saturation_degree;'
p22211
aS'    FE_Q<dim>                 saturation_fe;'
p22212
aS'    DoFHandler<dim>           saturation_dof_handler;'
p22213
aS'    AffineConstraints<double> saturation_constraints;'
p22214
aS'    TrilinosWrappers::SparseMatrix saturation_matrix;'
p22215
aS'    TrilinosWrappers::MPI::Vector saturation_solution;'
p22216
aS'    TrilinosWrappers::MPI::Vector old_saturation_solution;'
p22217
aS'    TrilinosWrappers::MPI::Vector old_old_saturation_solution;'
p22218
aS'    TrilinosWrappers::MPI::Vector saturation_rhs;'
p22219
aS'    TrilinosWrappers::MPI::Vector'
p22220
aS'      saturation_matching_last_computed_darcy_solution;'
p22221
aS'    const double saturation_refinement_threshold;'
p22222
aS'    double       time;'
p22223
aS'    const double end_time;'
p22224
aS'    double current_macro_time_step;'
p22225
aS'    double old_macro_time_step;'
p22226
aS'    double       time_step;'
p22227
aS'    double       old_time_step;'
p22228
aS'    unsigned int timestep_number;'
p22229
aS'    const double viscosity;'
p22230
aS'    const double porosity;'
p22231
aS'    const double AOS_threshold;'
p22232
aS'    std::shared_ptr<TrilinosWrappers::PreconditionIC> Amg_preconditioner;'
p22233
aS'    std::shared_ptr<TrilinosWrappers::PreconditionIC> Mp_preconditioner;'
p22234
aS'    bool rebuild_saturation_matrix;'
p22235
aS'    const RandomMedium::KInverse<dim> k_inverse;'
p22236
aS'  };'
p22237
aS'  template <int dim>'
p22238
aS'  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree)'
p22239
aS'    : triangulation(Triangulation<dim>::maximum_smoothing)'
p22240
aS'    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN())'
p22241
aS'    , degree(degree)'
p22242
aS'    , darcy_degree(degree)'
p22243
aS'    , darcy_fe(FE_Q<dim>(darcy_degree + 1), dim, FE_Q<dim>(darcy_degree), 1)'
p22244
aS'    , darcy_dof_handler(triangulation)'
p22245
aS'    ,'
p22246
aS'    saturation_degree(degree + 1)'
p22247
aS'    , saturation_fe(saturation_degree)'
p22248
aS'    , saturation_dof_handler(triangulation)'
p22249
aS'    ,'
p22250
aS'    saturation_refinement_threshold(0.5)'
p22251
aS'    ,'
p22252
aS'    time(0)'
p22253
aS'    , end_time(10)'
p22254
aS'    ,'
p22255
aS'    current_macro_time_step(0)'
p22256
aS'    , old_macro_time_step(0)'
p22257
aS'    ,'
p22258
aS'    time_step(0)'
p22259
aS'    , old_time_step(0)'
p22260
aS'    , timestep_number(0)'
p22261
aS'    , viscosity(0.2)'
p22262
aS'    , porosity(1.0)'
p22263
aS'    , AOS_threshold(3.0)'
p22264
aS'    ,'
p22265
aS'    rebuild_saturation_matrix(true)'
p22266
aS'  {}'
p22267
aS'  template <int dim>'
p22268
aS'  void TwoPhaseFlowProblem<dim>::setup_dofs()'
p22269
aS'  {'
p22270
aS'    std::vector<unsigned int> darcy_block_component(dim + 1, 0);'
p22271
aS'    darcy_block_component[dim] = 1;'
p22272
aS'    {'
p22273
aS'      darcy_dof_handler.distribute_dofs(darcy_fe);'
p22274
aS'      DoFRenumbering::Cuthill_McKee(darcy_dof_handler);'
p22275
aS'      DoFRenumbering::component_wise(darcy_dof_handler, darcy_block_component);'
p22276
aS'      darcy_constraints.clear();'
p22277
aS'      DoFTools::make_hanging_node_constraints(darcy_dof_handler,'
p22278
aS'                                              darcy_constraints);'
p22279
aS'      darcy_constraints.close();'
p22280
aS'    }'
p22281
aS'    {'
p22282
aS'      saturation_dof_handler.distribute_dofs(saturation_fe);'
p22283
aS'      saturation_constraints.clear();'
p22284
aS'      DoFTools::make_hanging_node_constraints(saturation_dof_handler,'
p22285
aS'                                              saturation_constraints);'
p22286
aS'      saturation_constraints.close();'
p22287
aS'    }'
p22288
aS'    {'
p22289
aS'      darcy_preconditioner_constraints.clear();'
p22290
aS'      FEValuesExtractors::Scalar pressure(dim);'
p22291
aS'      DoFTools::make_hanging_node_constraints(darcy_dof_handler,'
p22292
aS'                                              darcy_preconditioner_constraints);'
p22293
aS'      DoFTools::make_zero_boundary_constraints(darcy_dof_handler,'
p22294
aS'                                               darcy_preconditioner_constraints,'
p22295
aS'                                               darcy_fe.component_mask('
p22296
aS'                                                 pressure));'
p22297
aS'      darcy_preconditioner_constraints.close();'
p22298
aS'    }'
p22299
aS'    const std::vector<types::global_dof_index> darcy_dofs_per_block ='
p22300
aS'      DoFTools::count_dofs_per_fe_block(darcy_dof_handler,'
p22301
aS'                                        darcy_block_component);'
p22302
aS'    const unsigned int n_u = darcy_dofs_per_block[0],'
p22303
aS'                       n_p = darcy_dofs_per_block[1],'
p22304
aS'                       n_s = saturation_dof_handler.n_dofs();'
p22305
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p22306
aS'              << " (on " << triangulation.n_levels() << " levels)" << std::endl'
p22307
aS'              << "Number of degrees of freedom: " << n_u + n_p + n_s << " ("'
p22308
aS"              << n_u << '+' << n_p << '+' << n_s << ')' << std::endl"
p22309
aS'              << std::endl;'
p22310
aS'    {'
p22311
aS'      darcy_matrix.clear();'
p22312
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p22313
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p22314
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p22315
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p22316
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p22317
aS'      dsp.collect_sizes();'
p22318
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p22319
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p22320
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p22321
aS'          if (!((c == dim) && (d == dim)))'
p22322
aS'            coupling[c][d] = DoFTools::always;'
p22323
aS'          else'
p22324
aS'            coupling[c][d] = DoFTools::none;'
p22325
aS'      DoFTools::make_sparsity_pattern('
p22326
aS'        darcy_dof_handler, coupling, dsp, darcy_constraints, false);'
p22327
aS'      darcy_matrix.reinit(dsp);'
p22328
aS'    }'
p22329
aS'    {'
p22330
aS'      Amg_preconditioner.reset();'
p22331
aS'      Mp_preconditioner.reset();'
p22332
aS'      darcy_preconditioner_matrix.clear();'
p22333
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p22334
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p22335
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p22336
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p22337
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p22338
aS'      dsp.collect_sizes();'
p22339
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p22340
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p22341
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p22342
aS'          if (c == d)'
p22343
aS'            coupling[c][d] = DoFTools::always;'
p22344
aS'          else'
p22345
aS'            coupling[c][d] = DoFTools::none;'
p22346
aS'      DoFTools::make_sparsity_pattern('
p22347
aS'        darcy_dof_handler, coupling, dsp, darcy_constraints, false);'
p22348
aS'      darcy_preconditioner_matrix.reinit(dsp);'
p22349
aS'    }'
p22350
aS'    {'
p22351
aS'      saturation_matrix.clear();'
p22352
aS'      DynamicSparsityPattern dsp(n_s, n_s);'
p22353
aS'      DoFTools::make_sparsity_pattern(saturation_dof_handler,'
p22354
aS'                                      dsp,'
p22355
aS'                                      saturation_constraints,'
p22356
aS'                                      false);'
p22357
aS'      saturation_matrix.reinit(dsp);'
p22358
aS'    }'
p22359
aS'    std::vector<IndexSet> darcy_partitioning(2);'
p22360
aS'    darcy_partitioning[0] = complete_index_set(n_u);'
p22361
aS'    darcy_partitioning[1] = complete_index_set(n_p);'
p22362
aS'    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);'
p22363
aS'    darcy_solution.collect_sizes();'
p22364
aS'    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);'
p22365
aS'    last_computed_darcy_solution.collect_sizes();'
p22366
aS'    second_last_computed_darcy_solution.reinit(darcy_partitioning,'
p22367
aS'                                               MPI_COMM_WORLD);'
p22368
aS'    second_last_computed_darcy_solution.collect_sizes();'
p22369
aS'    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);'
p22370
aS'    darcy_rhs.collect_sizes();'
p22371
aS'    IndexSet saturation_partitioning = complete_index_set(n_s);'
p22372
aS'    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p22373
aS'    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p22374
aS'    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p22375
aS'    saturation_matching_last_computed_darcy_solution.reinit('
p22376
aS'      saturation_partitioning, MPI_COMM_WORLD);'
p22377
aS'    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p22378
aS'  }'
p22379
aS'  template <int dim>'
p22380
aS'  void TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner()'
p22381
aS'  {'
p22382
aS'    std::cout << "   Rebuilding darcy preconditioner..." << std::endl;'
p22383
aS'    darcy_preconditioner_matrix = 0;'
p22384
aS'    const QGauss<dim> quadrature_formula(darcy_degree + 2);'
p22385
aS'    FEValues<dim>     darcy_fe_values(darcy_fe,'
p22386
aS'                                  quadrature_formula,'
p22387
aS'                                  update_JxW_values | update_values |'
p22388
aS'                                    update_gradients |'
p22389
aS'                                    update_quadrature_points);'
p22390
aS'    FEValues<dim>     saturation_fe_values(saturation_fe,'
p22391
aS'                                       quadrature_formula,'
p22392
aS'                                       update_values);'
p22393
aS'    const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();'
p22394
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p22395
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p22396
aS'    std::vector<double> old_saturation_values(n_q_points);'
p22397
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p22398
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p22399
aS'    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);'
p22400
aS'    std::vector<Tensor<1, dim>> grad_phi_p(dofs_per_cell);'
p22401
aS'    const FEValuesExtractors::Vector velocities(0);'
p22402
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p22403
aS'    auto       cell            = darcy_dof_handler.begin_active();'
p22404
aS'    const auto endc            = darcy_dof_handler.end();'
p22405
aS'    auto       saturation_cell = saturation_dof_handler.begin_active();'
p22406
aS'    for (; cell != endc; ++cell, ++saturation_cell)'
p22407
aS'      {'
p22408
aS'        darcy_fe_values.reinit(cell);'
p22409
aS'        saturation_fe_values.reinit(saturation_cell);'
p22410
aS'        local_matrix = 0;'
p22411
aS'        saturation_fe_values.get_function_values(old_saturation_solution,'
p22412
aS'                                                 old_saturation_values);'
p22413
aS'        k_inverse.value_list(darcy_fe_values.get_quadrature_points(),'
p22414
aS'                             k_inverse_values);'
p22415
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p22416
aS'          {'
p22417
aS'            const double old_s = old_saturation_values[q];'
p22418
aS'            const double inverse_mobility = mobility_inverse(old_s, viscosity);'
p22419
aS'            const double mobility         = 1.0 / inverse_mobility;'
p22420
aS'            const Tensor<2, dim> permeability = invert(k_inverse_values[q]);'
p22421
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p22422
aS'              {'
p22423
aS'                phi_u[k]      = darcy_fe_values[velocities].value(k, q);'
p22424
aS'                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);'
p22425
aS'              }'
p22426
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22427
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p22428
aS'                {'
p22429
aS'                  local_matrix(i, j) +='
p22430
aS'                    (k_inverse_values[q] * inverse_mobility * phi_u[i] *'
p22431
aS'                       phi_u[j] +'
p22432
aS'                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *'
p22433
aS'                    darcy_fe_values.JxW(q);'
p22434
aS'                }'
p22435
aS'          }'
p22436
aS'        cell->get_dof_indices(local_dof_indices);'
p22437
aS'        darcy_preconditioner_constraints.distribute_local_to_global('
p22438
aS'          local_matrix, local_dof_indices, darcy_preconditioner_matrix);'
p22439
aS'      }'
p22440
aS'  }'
p22441
aS'  template <int dim>'
p22442
aS'  void TwoPhaseFlowProblem<dim>::build_darcy_preconditioner()'
p22443
aS'  {'
p22444
aS'    assemble_darcy_preconditioner();'
p22445
aS'    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>();'
p22446
aS'    Amg_preconditioner->initialize(darcy_preconditioner_matrix.block(0, 0));'
p22447
aS'    Mp_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>();'
p22448
aS'    Mp_preconditioner->initialize(darcy_preconditioner_matrix.block(1, 1));'
p22449
aS'  }'
p22450
aS'  template <int dim>'
p22451
aS'  void TwoPhaseFlowProblem<dim>::assemble_darcy_system()'
p22452
aS'  {'
p22453
aS'    darcy_matrix = 0;'
p22454
aS'    darcy_rhs    = 0;'
p22455
aS'    QGauss<dim>     quadrature_formula(darcy_degree + 2);'
p22456
aS'    QGauss<dim - 1> face_quadrature_formula(darcy_degree + 2);'
p22457
aS'    FEValues<dim> darcy_fe_values(darcy_fe,'
p22458
aS'                                  quadrature_formula,'
p22459
aS'                                  update_values | update_gradients |'
p22460
aS'                                    update_quadrature_points |'
p22461
aS'                                    update_JxW_values);'
p22462
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p22463
aS'                                       quadrature_formula,'
p22464
aS'                                       update_values);'
p22465
aS'    FEFaceValues<dim> darcy_fe_face_values(darcy_fe,'
p22466
aS'                                           face_quadrature_formula,'
p22467
aS'                                           update_values |'
p22468
aS'                                             update_normal_vectors |'
p22469
aS'                                             update_quadrature_points |'
p22470
aS'                                             update_JxW_values);'
p22471
aS'    const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();'
p22472
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p22473
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p22474
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p22475
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p22476
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p22477
aS'    const Functions::ZeroFunction<dim> pressure_right_hand_side;'
p22478
aS'    const PressureBoundaryValues<dim>  pressure_boundary_values;'
p22479
aS'    std::vector<double>         pressure_rhs_values(n_q_points);'
p22480
aS'    std::vector<double>         boundary_values(n_face_q_points);'
p22481
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p22482
aS'    std::vector<double> old_saturation_values(n_q_points);'
p22483
aS'    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);'
p22484
aS'    std::vector<double>         div_phi_u(dofs_per_cell);'
p22485
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p22486
aS'    const FEValuesExtractors::Vector velocities(0);'
p22487
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p22488
aS'    auto       cell            = darcy_dof_handler.begin_active();'
p22489
aS'    const auto endc            = darcy_dof_handler.end();'
p22490
aS'    auto       saturation_cell = saturation_dof_handler.begin_active();'
p22491
aS'    for (; cell != endc; ++cell, ++saturation_cell)'
p22492
aS'      {'
p22493
aS'        darcy_fe_values.reinit(cell);'
p22494
aS'        saturation_fe_values.reinit(saturation_cell);'
p22495
aS'        local_matrix = 0;'
p22496
aS'        local_rhs    = 0;'
p22497
aS'        saturation_fe_values.get_function_values(old_saturation_solution,'
p22498
aS'                                                 old_saturation_values);'
p22499
aS'        pressure_right_hand_side.value_list('
p22500
aS'          darcy_fe_values.get_quadrature_points(), pressure_rhs_values);'
p22501
aS'        k_inverse.value_list(darcy_fe_values.get_quadrature_points(),'
p22502
aS'                             k_inverse_values);'
p22503
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p22504
aS'          {'
p22505
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p22506
aS'              {'
p22507
aS'                phi_u[k]     = darcy_fe_values[velocities].value(k, q);'
p22508
aS'                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);'
p22509
aS'                phi_p[k]     = darcy_fe_values[pressure].value(k, q);'
p22510
aS'              }'
p22511
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22512
aS'              {'
p22513
aS'                const double old_s = old_saturation_values[q];'
p22514
aS'                for (unsigned int j = 0; j <= i; ++j)'
p22515
aS'                  {'
p22516
aS'                    local_matrix(i, j) +='
p22517
aS'                      (phi_u[i] * k_inverse_values[q] *'
p22518
aS'                         mobility_inverse(old_s, viscosity) * phi_u[j] -'
p22519
aS'                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p22520
aS'                      darcy_fe_values.JxW(q);'
p22521
aS'                  }'
p22522
aS'                local_rhs(i) +='
p22523
aS'                  (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.JxW(q);'
p22524
aS'              }'
p22525
aS'          }'
p22526
aS'        for (const auto &face : cell->face_iterators())'
p22527
aS'          if (face->at_boundary())'
p22528
aS'            {'
p22529
aS'              darcy_fe_face_values.reinit(cell, face);'
p22530
aS'              pressure_boundary_values.value_list('
p22531
aS'                darcy_fe_face_values.get_quadrature_points(), boundary_values);'
p22532
aS'              for (unsigned int q = 0; q < n_face_q_points; ++q)'
p22533
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22534
aS'                  {'
p22535
aS'                    const Tensor<1, dim> phi_i_u ='
p22536
aS'                      darcy_fe_face_values[velocities].value(i, q);'
p22537
aS'                    local_rhs(i) +='
p22538
aS'                      -(phi_i_u * darcy_fe_face_values.normal_vector(q) *'
p22539
aS'                        boundary_values[q] * darcy_fe_face_values.JxW(q));'
p22540
aS'                  }'
p22541
aS'            }'
p22542
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22543
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p22544
aS'            local_matrix(i, j) = local_matrix(j, i);'
p22545
aS'        cell->get_dof_indices(local_dof_indices);'
p22546
aS'        darcy_constraints.distribute_local_to_global('
p22547
aS'          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);'
p22548
aS'      }'
p22549
aS'  }'
p22550
aS'  template <int dim>'
p22551
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_system()'
p22552
aS'  {'
p22553
aS'    if (rebuild_saturation_matrix == true)'
p22554
aS'      {'
p22555
aS'        saturation_matrix = 0;'
p22556
aS'        assemble_saturation_matrix();'
p22557
aS'      }'
p22558
aS'    saturation_rhs = 0;'
p22559
aS'    assemble_saturation_rhs();'
p22560
aS'  }'
p22561
aS'  template <int dim>'
p22562
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_matrix()'
p22563
aS'  {'
p22564
aS'    QGauss<dim> quadrature_formula(saturation_degree + 2);'
p22565
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p22566
aS'                                       quadrature_formula,'
p22567
aS'                                       update_values | update_JxW_values);'
p22568
aS'    const unsigned int dofs_per_cell = saturation_fe.n_dofs_per_cell();'
p22569
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p22570
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p22571
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p22572
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p22573
aS'    for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p22574
aS'      {'
p22575
aS'        saturation_fe_values.reinit(cell);'
p22576
aS'        local_matrix = 0;'
p22577
aS'        local_rhs    = 0;'
p22578
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p22579
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22580
aS'            {'
p22581
aS'              const double phi_i_s = saturation_fe_values.shape_value(i, q);'
p22582
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p22583
aS'                {'
p22584
aS'                  const double phi_j_s = saturation_fe_values.shape_value(j, q);'
p22585
aS'                  local_matrix(i, j) +='
p22586
aS'                    porosity * phi_i_s * phi_j_s * saturation_fe_values.JxW(q);'
p22587
aS'                }'
p22588
aS'            }'
p22589
aS'        cell->get_dof_indices(local_dof_indices);'
p22590
aS'        saturation_constraints.distribute_local_to_global(local_matrix,'
p22591
aS'                                                          local_dof_indices,'
p22592
aS'                                                          saturation_matrix);'
p22593
aS'      }'
p22594
aS'  }'
p22595
aS'  template <int dim>'
p22596
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs()'
p22597
aS'  {'
p22598
aS'    QGauss<dim>     quadrature_formula(saturation_degree + 2);'
p22599
aS'    QGauss<dim - 1> face_quadrature_formula(saturation_degree + 2);'
p22600
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p22601
aS'                                       quadrature_formula,'
p22602
aS'                                       update_values | update_gradients |'
p22603
aS'                                         update_quadrature_points |'
p22604
aS'                                         update_JxW_values);'
p22605
aS'    FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);'
p22606
aS'    FEFaceValues<dim> saturation_fe_face_values(saturation_fe,'
p22607
aS'                                                face_quadrature_formula,'
p22608
aS'                                                update_values |'
p22609
aS'                                                  update_normal_vectors |'
p22610
aS'                                                  update_quadrature_points |'
p22611
aS'                                                  update_JxW_values);'
p22612
aS'    FEFaceValues<dim> darcy_fe_face_values(darcy_fe,'
p22613
aS'                                           face_quadrature_formula,'
p22614
aS'                                           update_values);'
p22615
aS'    FEFaceValues<dim> saturation_fe_face_values_neighbor('
p22616
aS'      saturation_fe, face_quadrature_formula, update_values);'
p22617
aS'    const unsigned int dofs_per_cell ='
p22618
aS'      saturation_dof_handler.get_fe().n_dofs_per_cell();'
p22619
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p22620
aS'    const double                    global_max_u_F_prime = get_max_u_F_prime();'
p22621
aS'    const std::pair<double, double> global_S_range ='
p22622
aS'      get_extrapolated_saturation_range();'
p22623
aS'    const double global_S_variation ='
p22624
aS'      global_S_range.second - global_S_range.first;'
p22625
aS'    auto       cell       = saturation_dof_handler.begin_active();'
p22626
aS'    const auto endc       = saturation_dof_handler.end();'
p22627
aS'    auto       darcy_cell = darcy_dof_handler.begin_active();'
p22628
aS'    for (; cell != endc; ++cell, ++darcy_cell)'
p22629
aS'      {'
p22630
aS'        saturation_fe_values.reinit(cell);'
p22631
aS'        darcy_fe_values.reinit(darcy_cell);'
p22632
aS'        cell->get_dof_indices(local_dof_indices);'
p22633
aS'        assemble_saturation_rhs_cell_term(saturation_fe_values,'
p22634
aS'                                          darcy_fe_values,'
p22635
aS'                                          global_max_u_F_prime,'
p22636
aS'                                          global_S_variation,'
p22637
aS'                                          local_dof_indices);'
p22638
aS'        for (const auto &face : cell->face_iterators())'
p22639
aS'          if (face->at_boundary())'
p22640
aS'            {'
p22641
aS'              darcy_fe_face_values.reinit(darcy_cell, face);'
p22642
aS'              saturation_fe_face_values.reinit(cell, face);'
p22643
aS'              assemble_saturation_rhs_boundary_term(saturation_fe_face_values,'
p22644
aS'                                                    darcy_fe_face_values,'
p22645
aS'                                                    local_dof_indices);'
p22646
aS'            }'
p22647
aS'      }'
p22648
aS'  }'
p22649
aS'  template <int dim>'
p22650
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term('
p22651
aS'    const FEValues<dim> &                       saturation_fe_values,'
p22652
aS'    const FEValues<dim> &                       darcy_fe_values,'
p22653
aS'    const double                                global_max_u_F_prime,'
p22654
aS'    const double                                global_S_variation,'
p22655
aS'    const std::vector<types::global_dof_index> &local_dof_indices)'
p22656
aS'  {'
p22657
aS'    const unsigned int dofs_per_cell = saturation_fe_values.dofs_per_cell;'
p22658
aS'    const unsigned int n_q_points    = saturation_fe_values.n_quadrature_points;'
p22659
aS'    std::vector<double>         old_saturation_solution_values(n_q_points);'
p22660
aS'    std::vector<double>         old_old_saturation_solution_values(n_q_points);'
p22661
aS'    std::vector<Tensor<1, dim>> old_grad_saturation_solution_values(n_q_points);'
p22662
aS'    std::vector<Tensor<1, dim>> old_old_grad_saturation_solution_values('
p22663
aS'      n_q_points);'
p22664
aS'    std::vector<Vector<double>> present_darcy_solution_values('
p22665
aS'      n_q_points, Vector<double>(dim + 1));'
p22666
aS'    saturation_fe_values.get_function_values(old_saturation_solution,'
p22667
aS'                                             old_saturation_solution_values);'
p22668
aS'    saturation_fe_values.get_function_values('
p22669
aS'      old_old_saturation_solution, old_old_saturation_solution_values);'
p22670
aS'    saturation_fe_values.get_function_gradients('
p22671
aS'      old_saturation_solution, old_grad_saturation_solution_values);'
p22672
aS'    saturation_fe_values.get_function_gradients('
p22673
aS'      old_old_saturation_solution, old_old_grad_saturation_solution_values);'
p22674
aS'    darcy_fe_values.get_function_values(darcy_solution,'
p22675
aS'                                        present_darcy_solution_values);'
p22676
aS'    const double nu ='
p22677
aS'      compute_viscosity(old_saturation_solution_values,'
p22678
aS'                        old_old_saturation_solution_values,'
p22679
aS'                        old_grad_saturation_solution_values,'
p22680
aS'                        old_old_grad_saturation_solution_values,'
p22681
aS'                        present_darcy_solution_values,'
p22682
aS'                        global_max_u_F_prime,'
p22683
aS'                        global_S_variation,'
p22684
aS'                        saturation_fe_values.get_cell()->diameter());'
p22685
aS'    Vector<double> local_rhs(dofs_per_cell);'
p22686
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p22687
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22688
aS'        {'
p22689
aS'          const double   old_s = old_saturation_solution_values[q];'
p22690
aS'          Tensor<1, dim> present_u;'
p22691
aS'          for (unsigned int d = 0; d < dim; ++d)'
p22692
aS'            present_u[d] = present_darcy_solution_values[q](d);'
p22693
aS'          const double         phi_i_s = saturation_fe_values.shape_value(i, q);'
p22694
aS'          const Tensor<1, dim> grad_phi_i_s ='
p22695
aS'            saturation_fe_values.shape_grad(i, q);'
p22696
aS'          local_rhs(i) +='
p22697
aS'            (time_step * fractional_flow(old_s, viscosity) * present_u *'
p22698
aS'               grad_phi_i_s -'
p22699
aS'             time_step * nu * old_grad_saturation_solution_values[q] *'
p22700
aS'               grad_phi_i_s +'
p22701
aS'             porosity * old_s * phi_i_s) *'
p22702
aS'            saturation_fe_values.JxW(q);'
p22703
aS'        }'
p22704
aS'    saturation_constraints.distribute_local_to_global(local_rhs,'
p22705
aS'                                                      local_dof_indices,'
p22706
aS'                                                      saturation_rhs);'
p22707
aS'  }'
p22708
aS'  template <int dim>'
p22709
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term('
p22710
aS'    const FEFaceValues<dim> &                   saturation_fe_face_values,'
p22711
aS'    const FEFaceValues<dim> &                   darcy_fe_face_values,'
p22712
aS'    const std::vector<types::global_dof_index> &local_dof_indices)'
p22713
aS'  {'
p22714
aS'    const unsigned int dofs_per_cell = saturation_fe_face_values.dofs_per_cell;'
p22715
aS'    const unsigned int n_face_q_points ='
p22716
aS'      saturation_fe_face_values.n_quadrature_points;'
p22717
aS'    Vector<double> local_rhs(dofs_per_cell);'
p22718
aS'    std::vector<double> old_saturation_solution_values_face(n_face_q_points);'
p22719
aS'    std::vector<Vector<double>> present_darcy_solution_values_face('
p22720
aS'      n_face_q_points, Vector<double>(dim + 1));'
p22721
aS'    std::vector<double> neighbor_saturation(n_face_q_points);'
p22722
aS'    saturation_fe_face_values.get_function_values('
p22723
aS'      old_saturation_solution, old_saturation_solution_values_face);'
p22724
aS'    darcy_fe_face_values.get_function_values('
p22725
aS'      darcy_solution, present_darcy_solution_values_face);'
p22726
aS'    SaturationBoundaryValues<dim> saturation_boundary_values;'
p22727
aS'    saturation_boundary_values.value_list('
p22728
aS'      saturation_fe_face_values.get_quadrature_points(), neighbor_saturation);'
p22729
aS'    for (unsigned int q = 0; q < n_face_q_points; ++q)'
p22730
aS'      {'
p22731
aS'        Tensor<1, dim> present_u_face;'
p22732
aS'        for (unsigned int d = 0; d < dim; ++d)'
p22733
aS'          present_u_face[d] = present_darcy_solution_values_face[q](d);'
p22734
aS'        const double normal_flux ='
p22735
aS'          present_u_face * saturation_fe_face_values.normal_vector(q);'
p22736
aS'        const bool is_outflow_q_point = (normal_flux >= 0);'
p22737
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p22738
aS'          local_rhs(i) -='
p22739
aS'            time_step * normal_flux *'
p22740
aS'            fractional_flow((is_outflow_q_point == true ?'
p22741
aS'                               old_saturation_solution_values_face[q] :'
p22742
aS'                               neighbor_saturation[q]),'
p22743
aS'                            viscosity) *'
p22744
aS'            saturation_fe_face_values.shape_value(i, q) *'
p22745
aS'            saturation_fe_face_values.JxW(q);'
p22746
aS'      }'
p22747
aS'    saturation_constraints.distribute_local_to_global(local_rhs,'
p22748
aS'                                                      local_dof_indices,'
p22749
aS'                                                      saturation_rhs);'
p22750
aS'  }'
p22751
aS'  template <int dim>'
p22752
aS'  void TwoPhaseFlowProblem<dim>::solve()'
p22753
aS'  {'
p22754
aS'    const bool solve_for_pressure_and_velocity ='
p22755
aS'      determine_whether_to_solve_for_pressure_and_velocity();'
p22756
aS'    if (solve_for_pressure_and_velocity == true)'
p22757
aS'      {'
p22758
aS'        std::cout << "   Solving Darcy (pressure-velocity) system..."'
p22759
aS'                  << std::endl;'
p22760
aS'        assemble_darcy_system();'
p22761
aS'        build_darcy_preconditioner();'
p22762
aS'        {'
p22763
aS'          const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix,'
p22764
aS'                                             TrilinosWrappers::PreconditionIC>'
p22765
aS'            mp_inverse(darcy_preconditioner_matrix.block(1, 1),'
p22766
aS'                       *Mp_preconditioner);'
p22767
aS'          const LinearSolvers::BlockSchurPreconditioner<'
p22768
aS'            TrilinosWrappers::PreconditionIC,'
p22769
aS'            TrilinosWrappers::PreconditionIC>'
p22770
aS'            preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);'
p22771
aS'          SolverControl solver_control(darcy_matrix.m(),'
p22772
aS'                                       1e-16 * darcy_rhs.l2_norm());'
p22773
aS'          SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres('
p22774
aS'            solver_control,'
p22775
aS'            SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData('
p22776
aS'              100));'
p22777
aS'          for (unsigned int i = 0; i < darcy_solution.size(); ++i)'
p22778
aS'            if (darcy_constraints.is_constrained(i))'
p22779
aS'              darcy_solution(i) = 0;'
p22780
aS'          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);'
p22781
aS'          darcy_constraints.distribute(darcy_solution);'
p22782
aS'          std::cout << "        ..." << solver_control.last_step()'
p22783
aS'                    << " GMRES iterations." << std::endl;'
p22784
aS'        }'
p22785
aS'        {'
p22786
aS'          second_last_computed_darcy_solution = last_computed_darcy_solution;'
p22787
aS'          last_computed_darcy_solution        = darcy_solution;'
p22788
aS'          saturation_matching_last_computed_darcy_solution ='
p22789
aS'            saturation_solution;'
p22790
aS'        }'
p22791
aS'      }'
p22792
aS'    else'
p22793
aS'      {'
p22794
aS'        darcy_solution = last_computed_darcy_solution;'
p22795
aS'        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,'
p22796
aS'                            -current_macro_time_step / old_macro_time_step,'
p22797
aS'                            second_last_computed_darcy_solution);'
p22798
aS'      }'
p22799
aS'    {'
p22800
aS'      old_time_step = time_step;'
p22801
aS'      const double max_u_F_prime = get_max_u_F_prime();'
p22802
aS'      if (max_u_F_prime > 0)'
p22803
aS'        time_step = porosity * GridTools::minimal_cell_diameter(triangulation) /'
p22804
aS'                    saturation_degree / max_u_F_prime / 50;'
p22805
aS'      else'
p22806
aS'        time_step = end_time - time;'
p22807
aS'    }'
p22808
aS'    if (solve_for_pressure_and_velocity == true)'
p22809
aS'      {'
p22810
aS'        old_macro_time_step     = current_macro_time_step;'
p22811
aS'        current_macro_time_step = time_step;'
p22812
aS'      }'
p22813
aS'    else'
p22814
aS'      current_macro_time_step += time_step;'
p22815
aS'    {'
p22816
aS'      std::cout << "   Solving saturation transport equation..." << std::endl;'
p22817
aS'      assemble_saturation_system();'
p22818
aS'      SolverControl solver_control(saturation_matrix.m(),'
p22819
aS'                                   1e-16 * saturation_rhs.l2_norm());'
p22820
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p22821
aS'      TrilinosWrappers::PreconditionIC preconditioner;'
p22822
aS'      preconditioner.initialize(saturation_matrix);'
p22823
aS'      cg.solve(saturation_matrix,'
p22824
aS'               saturation_solution,'
p22825
aS'               saturation_rhs,'
p22826
aS'               preconditioner);'
p22827
aS'      saturation_constraints.distribute(saturation_solution);'
p22828
aS'      project_back_saturation();'
p22829
aS'      std::cout << "        ..." << solver_control.last_step()'
p22830
aS'                << " CG iterations." << std::endl;'
p22831
aS'    }'
p22832
aS'  }'
p22833
aS'  template <int dim>'
p22834
aS'  void TwoPhaseFlowProblem<dim>::refine_mesh(const unsigned int min_grid_level,'
p22835
aS'                                             const unsigned int max_grid_level)'
p22836
aS'  {'
p22837
aS'    Vector<double> refinement_indicators(triangulation.n_active_cells());'
p22838
aS'    {'
p22839
aS'      const QMidpoint<dim>        quadrature_formula;'
p22840
aS'      FEValues<dim>               fe_values(saturation_fe,'
p22841
aS'                              quadrature_formula,'
p22842
aS'                              update_gradients);'
p22843
aS'      std::vector<Tensor<1, dim>> grad_saturation(1);'
p22844
aS'      TrilinosWrappers::MPI::Vector extrapolated_saturation_solution('
p22845
aS'        saturation_solution);'
p22846
aS'      if (timestep_number != 0)'
p22847
aS'        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),'
p22848
aS'                                              time_step / old_time_step,'
p22849
aS'                                              old_saturation_solution);'
p22850
aS'      for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p22851
aS'        {'
p22852
aS'          const unsigned int cell_no = cell->active_cell_index();'
p22853
aS'          fe_values.reinit(cell);'
p22854
aS'          fe_values.get_function_gradients(extrapolated_saturation_solution,'
p22855
aS'                                           grad_saturation);'
p22856
aS'          refinement_indicators(cell_no) = grad_saturation[0].norm();'
p22857
aS'        }'
p22858
aS'    }'
p22859
aS'    {'
p22860
aS'      for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p22861
aS'        {'
p22862
aS'          const unsigned int cell_no = cell->active_cell_index();'
p22863
aS'          cell->clear_coarsen_flag();'
p22864
aS'          cell->clear_refine_flag();'
p22865
aS'          if ((static_cast<unsigned int>(cell->level()) < max_grid_level) &&'
p22866
aS'              (std::fabs(refinement_indicators(cell_no)) >'
p22867
aS'               saturation_refinement_threshold))'
p22868
aS'            cell->set_refine_flag();'
p22869
aS'          else if ((static_cast<unsigned int>(cell->level()) >'
p22870
aS'                    min_grid_level) &&'
p22871
aS'                   (std::fabs(refinement_indicators(cell_no)) <'
p22872
aS'                    0.5 * saturation_refinement_threshold))'
p22873
aS'            cell->set_coarsen_flag();'
p22874
aS'        }'
p22875
aS'    }'
p22876
aS'    triangulation.prepare_coarsening_and_refinement();'
p22877
aS'    {'
p22878
aS'      std::vector<TrilinosWrappers::MPI::Vector> x_saturation(3);'
p22879
aS'      x_saturation[0] = saturation_solution;'
p22880
aS'      x_saturation[1] = old_saturation_solution;'
p22881
aS'      x_saturation[2] = saturation_matching_last_computed_darcy_solution;'
p22882
aS'      std::vector<TrilinosWrappers::MPI::BlockVector> x_darcy(2);'
p22883
aS'      x_darcy[0] = last_computed_darcy_solution;'
p22884
aS'      x_darcy[1] = second_last_computed_darcy_solution;'
p22885
aS'      SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> saturation_soltrans('
p22886
aS'        saturation_dof_handler);'
p22887
aS'      SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> darcy_soltrans('
p22888
aS'        darcy_dof_handler);'
p22889
aS'      triangulation.prepare_coarsening_and_refinement();'
p22890
aS'      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);'
p22891
aS'      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);'
p22892
aS'      triangulation.execute_coarsening_and_refinement();'
p22893
aS'      setup_dofs();'
p22894
aS'      std::vector<TrilinosWrappers::MPI::Vector> tmp_saturation(3);'
p22895
aS'      tmp_saturation[0].reinit(saturation_solution);'
p22896
aS'      tmp_saturation[1].reinit(saturation_solution);'
p22897
aS'      tmp_saturation[2].reinit(saturation_solution);'
p22898
aS'      saturation_soltrans.interpolate(x_saturation, tmp_saturation);'
p22899
aS'      saturation_solution                              = tmp_saturation[0];'
p22900
aS'      old_saturation_solution                          = tmp_saturation[1];'
p22901
aS'      saturation_matching_last_computed_darcy_solution = tmp_saturation[2];'
p22902
aS'      saturation_constraints.distribute(saturation_solution);'
p22903
aS'      saturation_constraints.distribute(old_saturation_solution);'
p22904
aS'      saturation_constraints.distribute('
p22905
aS'        saturation_matching_last_computed_darcy_solution);'
p22906
aS'      std::vector<TrilinosWrappers::MPI::BlockVector> tmp_darcy(2);'
p22907
aS'      tmp_darcy[0].reinit(darcy_solution);'
p22908
aS'      tmp_darcy[1].reinit(darcy_solution);'
p22909
aS'      darcy_soltrans.interpolate(x_darcy, tmp_darcy);'
p22910
aS'      last_computed_darcy_solution        = tmp_darcy[0];'
p22911
aS'      second_last_computed_darcy_solution = tmp_darcy[1];'
p22912
aS'      darcy_constraints.distribute(last_computed_darcy_solution);'
p22913
aS'      darcy_constraints.distribute(second_last_computed_darcy_solution);'
p22914
aS'      rebuild_saturation_matrix = true;'
p22915
aS'    }'
p22916
aS'  }'
p22917
aS'  template <int dim>'
p22918
aS'  void TwoPhaseFlowProblem<dim>::output_results() const'
p22919
aS'  {'
p22920
aS'    const FESystem<dim> joint_fe(darcy_fe, 1, saturation_fe, 1);'
p22921
aS'    DoFHandler<dim>     joint_dof_handler(triangulation);'
p22922
aS'    joint_dof_handler.distribute_dofs(joint_fe);'
p22923
aS'    Assert(joint_dof_handler.n_dofs() =='
p22924
aS'             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),'
p22925
aS'           ExcInternalError());'
p22926
aS'    Vector<double> joint_solution(joint_dof_handler.n_dofs());'
p22927
aS'    {'
p22928
aS'      std::vector<types::global_dof_index> local_joint_dof_indices('
p22929
aS'        joint_fe.n_dofs_per_cell());'
p22930
aS'      std::vector<types::global_dof_index> local_darcy_dof_indices('
p22931
aS'        darcy_fe.n_dofs_per_cell());'
p22932
aS'      std::vector<types::global_dof_index> local_saturation_dof_indices('
p22933
aS'        saturation_fe.n_dofs_per_cell());'
p22934
aS'      auto       joint_cell      = joint_dof_handler.begin_active();'
p22935
aS'      const auto joint_endc      = joint_dof_handler.end();'
p22936
aS'      auto       darcy_cell      = darcy_dof_handler.begin_active();'
p22937
aS'      auto       saturation_cell = saturation_dof_handler.begin_active();'
p22938
aS'      for (; joint_cell != joint_endc;'
p22939
aS'           ++joint_cell, ++darcy_cell, ++saturation_cell)'
p22940
aS'        {'
p22941
aS'          joint_cell->get_dof_indices(local_joint_dof_indices);'
p22942
aS'          darcy_cell->get_dof_indices(local_darcy_dof_indices);'
p22943
aS'          saturation_cell->get_dof_indices(local_saturation_dof_indices);'
p22944
aS'          for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)'
p22945
aS'            if (joint_fe.system_to_base_index(i).first.first == 0)'
p22946
aS'              {'
p22947
aS'                Assert(joint_fe.system_to_base_index(i).second <'
p22948
aS'                         local_darcy_dof_indices.size(),'
p22949
aS'                       ExcInternalError());'
p22950
aS'                joint_solution(local_joint_dof_indices[i]) = darcy_solution('
p22951
aS'                  local_darcy_dof_indices[joint_fe.system_to_base_index(i)'
p22952
aS'                                            .second]);'
p22953
aS'              }'
p22954
aS'            else'
p22955
aS'              {'
p22956
aS'                Assert(joint_fe.system_to_base_index(i).first.first == 1,'
p22957
aS'                       ExcInternalError());'
p22958
aS'                Assert(joint_fe.system_to_base_index(i).second <'
p22959
aS'                         local_darcy_dof_indices.size(),'
p22960
aS'                       ExcInternalError());'
p22961
aS'                joint_solution(local_joint_dof_indices[i]) ='
p22962
aS'                  saturation_solution('
p22963
aS'                    local_saturation_dof_indices'
p22964
aS'                      [joint_fe.system_to_base_index(i).second]);'
p22965
aS'              }'
p22966
aS'        }'
p22967
aS'    }'
p22968
aS'    std::vector<std::string> joint_solution_names(dim, "velocity");'
p22969
aS'    joint_solution_names.emplace_back("pressure");'
p22970
aS'    joint_solution_names.emplace_back("saturation");'
p22971
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p22972
aS'      data_component_interpretation('
p22973
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p22974
aS'    data_component_interpretation.push_back('
p22975
aS'      DataComponentInterpretation::component_is_scalar);'
p22976
aS'    data_component_interpretation.push_back('
p22977
aS'      DataComponentInterpretation::component_is_scalar);'
p22978
aS'    DataOut<dim> data_out;'
p22979
aS'    data_out.attach_dof_handler(joint_dof_handler);'
p22980
aS'    data_out.add_data_vector(joint_solution,'
p22981
aS'                             joint_solution_names,'
p22982
aS'                             DataOut<dim>::type_dof_data,'
p22983
aS'                             data_component_interpretation);'
p22984
aS'    data_out.build_patches();'
p22985
aS'    std::string filename ='
p22986
aS'      "solution-" + Utilities::int_to_string(timestep_number, 5) + ".vtu";'
p22987
aS'    std::ofstream output(filename);'
p22988
aS'    data_out.write_vtu(output);'
p22989
aS'  }'
p22990
aS'  template <int dim>'
p22991
aS'  bool TwoPhaseFlowProblem<'
p22992
aS'    dim>::determine_whether_to_solve_for_pressure_and_velocity() const'
p22993
aS'  {'
p22994
aS'    if (timestep_number <= 2)'
p22995
aS'      return true;'
p22996
aS'    const QGauss<dim>  quadrature_formula(saturation_degree + 2);'
p22997
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p22998
aS'    FEValues<dim> fe_values(saturation_fe,'
p22999
aS'                            quadrature_formula,'
p23000
aS'                            update_values | update_quadrature_points);'
p23001
aS'    std::vector<double> old_saturation_after_solving_pressure(n_q_points);'
p23002
aS'    std::vector<double> present_saturation(n_q_points);'
p23003
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p23004
aS'    double max_global_aop_indicator = 0.0;'
p23005
aS'    for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p23006
aS'      {'
p23007
aS'        double max_local_mobility_reciprocal_difference = 0.0;'
p23008
aS'        double max_local_permeability_inverse_l1_norm   = 0.0;'
p23009
aS'        fe_values.reinit(cell);'
p23010
aS'        fe_values.get_function_values('
p23011
aS'          saturation_matching_last_computed_darcy_solution,'
p23012
aS'          old_saturation_after_solving_pressure);'
p23013
aS'        fe_values.get_function_values(saturation_solution, present_saturation);'
p23014
aS'        k_inverse.value_list(fe_values.get_quadrature_points(),'
p23015
aS'                             k_inverse_values);'
p23016
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p23017
aS'          {'
p23018
aS'            const double mobility_reciprocal_difference = std::fabs('
p23019
aS'              mobility_inverse(present_saturation[q], viscosity) -'
p23020
aS'              mobility_inverse(old_saturation_after_solving_pressure[q],'
p23021
aS'                               viscosity));'
p23022
aS'            max_local_mobility_reciprocal_difference ='
p23023
aS'              std::max(max_local_mobility_reciprocal_difference,'
p23024
aS'                       mobility_reciprocal_difference);'
p23025
aS'            max_local_permeability_inverse_l1_norm ='
p23026
aS'              std::max(max_local_permeability_inverse_l1_norm,'
p23027
aS'                       l1_norm(k_inverse_values[q]));'
p23028
aS'          }'
p23029
aS'        max_global_aop_indicator ='
p23030
aS'          std::max(max_global_aop_indicator,'
p23031
aS'                   (max_local_mobility_reciprocal_difference *'
p23032
aS'                    max_local_permeability_inverse_l1_norm));'
p23033
aS'      }'
p23034
aS'    return (max_global_aop_indicator > AOS_threshold);'
p23035
aS'  }'
p23036
aS'  template <int dim>'
p23037
aS'  void TwoPhaseFlowProblem<dim>::project_back_saturation()'
p23038
aS'  {'
p23039
aS'    for (unsigned int i = 0; i < saturation_solution.size(); ++i)'
p23040
aS'      if (saturation_solution(i) < 0.2)'
p23041
aS'        saturation_solution(i) = 0.2;'
p23042
aS'      else if (saturation_solution(i) > 1)'
p23043
aS'        saturation_solution(i) = 1;'
p23044
aS'  }'
p23045
aS'  template <int dim>'
p23046
aS'  double TwoPhaseFlowProblem<dim>::get_max_u_F_prime() const'
p23047
aS'  {'
p23048
aS'    const QGauss<dim>  quadrature_formula(darcy_degree + 2);'
p23049
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p23050
aS'    FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);'
p23051
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p23052
aS'                                       quadrature_formula,'
p23053
aS'                                       update_values);'
p23054
aS'    std::vector<Vector<double>> darcy_solution_values(n_q_points,'
p23055
aS'                                                      Vector<double>(dim + 1));'
p23056
aS'    std::vector<double>         saturation_values(n_q_points);'
p23057
aS'    double max_velocity_times_dF_dS = 0;'
p23058
aS'    auto       cell            = darcy_dof_handler.begin_active();'
p23059
aS'    const auto endc            = darcy_dof_handler.end();'
p23060
aS'    auto       saturation_cell = saturation_dof_handler.begin_active();'
p23061
aS'    for (; cell != endc; ++cell, ++saturation_cell)'
p23062
aS'      {'
p23063
aS'        darcy_fe_values.reinit(cell);'
p23064
aS'        saturation_fe_values.reinit(saturation_cell);'
p23065
aS'        darcy_fe_values.get_function_values(darcy_solution,'
p23066
aS'                                            darcy_solution_values);'
p23067
aS'        saturation_fe_values.get_function_values(old_saturation_solution,'
p23068
aS'                                                 saturation_values);'
p23069
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p23070
aS'          {'
p23071
aS'            Tensor<1, dim> velocity;'
p23072
aS'            for (unsigned int i = 0; i < dim; ++i)'
p23073
aS'              velocity[i] = darcy_solution_values[q](i);'
p23074
aS'            const double dF_dS ='
p23075
aS'              fractional_flow_derivative(saturation_values[q], viscosity);'
p23076
aS'            max_velocity_times_dF_dS ='
p23077
aS'              std::max(max_velocity_times_dF_dS, velocity.norm() * dF_dS);'
p23078
aS'          }'
p23079
aS'      }'
p23080
aS'    return max_velocity_times_dF_dS;'
p23081
aS'  }'
p23082
aS'  template <int dim>'
p23083
aS'  std::pair<double, double>'
p23084
aS'  TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range() const'
p23085
aS'  {'
p23086
aS'    const QGauss<dim>  quadrature_formula(saturation_degree + 2);'
p23087
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p23088
aS'    FEValues<dim> fe_values(saturation_fe, quadrature_formula, update_values);'
p23089
aS'    std::vector<double> old_saturation_values(n_q_points);'
p23090
aS'    std::vector<double> old_old_saturation_values(n_q_points);'
p23091
aS'    if (timestep_number != 0)'
p23092
aS'      {'
p23093
aS'        double min_saturation = std::numeric_limits<double>::max(),'
p23094
aS'               max_saturation = -std::numeric_limits<double>::max();'
p23095
aS'        for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p23096
aS'          {'
p23097
aS'            fe_values.reinit(cell);'
p23098
aS'            fe_values.get_function_values(old_saturation_solution,'
p23099
aS'                                          old_saturation_values);'
p23100
aS'            fe_values.get_function_values(old_old_saturation_solution,'
p23101
aS'                                          old_old_saturation_values);'
p23102
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p23103
aS'              {'
p23104
aS'                const double saturation ='
p23105
aS'                  (1. + time_step / old_time_step) * old_saturation_values[q] -'
p23106
aS'                  time_step / old_time_step * old_old_saturation_values[q];'
p23107
aS'                min_saturation = std::min(min_saturation, saturation);'
p23108
aS'                max_saturation = std::max(max_saturation, saturation);'
p23109
aS'              }'
p23110
aS'          }'
p23111
aS'        return std::make_pair(min_saturation, max_saturation);'
p23112
aS'      }'
p23113
aS'    else'
p23114
aS'      {'
p23115
aS'        double min_saturation = std::numeric_limits<double>::max(),'
p23116
aS'               max_saturation = -std::numeric_limits<double>::max();'
p23117
aS'        for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p23118
aS'          {'
p23119
aS'            fe_values.reinit(cell);'
p23120
aS'            fe_values.get_function_values(old_saturation_solution,'
p23121
aS'                                          old_saturation_values);'
p23122
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p23123
aS'              {'
p23124
aS'                const double saturation = old_saturation_values[q];'
p23125
aS'                min_saturation = std::min(min_saturation, saturation);'
p23126
aS'                max_saturation = std::max(max_saturation, saturation);'
p23127
aS'              }'
p23128
aS'          }'
p23129
aS'        return std::make_pair(min_saturation, max_saturation);'
p23130
aS'      }'
p23131
aS'  }'
p23132
aS'  template <int dim>'
p23133
aS'  double TwoPhaseFlowProblem<dim>::compute_viscosity('
p23134
aS'    const std::vector<double> &        old_saturation,'
p23135
aS'    const std::vector<double> &        old_old_saturation,'
p23136
aS'    const std::vector<Tensor<1, dim>> &old_saturation_grads,'
p23137
aS'    const std::vector<Tensor<1, dim>> &old_old_saturation_grads,'
p23138
aS'    const std::vector<Vector<double>> &present_darcy_values,'
p23139
aS'    const double                       global_max_u_F_prime,'
p23140
aS'    const double                       global_S_variation,'
p23141
aS'    const double                       cell_diameter) const'
p23142
aS'  {'
p23143
aS'    const double beta  = .4 * dim;'
p23144
aS'    const double alpha = 1;'
p23145
aS'    if (global_max_u_F_prime == 0)'
p23146
aS'      return 5e-3 * cell_diameter;'
p23147
aS'    const unsigned int n_q_points = old_saturation.size();'
p23148
aS'    double max_residual             = 0;'
p23149
aS'    double max_velocity_times_dF_dS = 0;'
p23150
aS'    const bool use_dF_dS = true;'
p23151
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p23152
aS'      {'
p23153
aS'        Tensor<1, dim> u;'
p23154
aS'        for (unsigned int d = 0; d < dim; ++d)'
p23155
aS'          u[d] = present_darcy_values[q](d);'
p23156
aS'        const double dS_dt = porosity *'
p23157
aS'                             (old_saturation[q] - old_old_saturation[q]) /'
p23158
aS'                             old_time_step;'
p23159
aS'        const double dF_dS = fractional_flow_derivative('
p23160
aS'          (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);'
p23161
aS'        const double u_grad_S ='
p23162
aS'          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /'
p23163
aS'          2.0;'
p23164
aS'        const double residual ='
p23165
aS'          std::abs((dS_dt + u_grad_S) *'
p23166
aS'                   std::pow((old_saturation[q] + old_old_saturation[q]) / 2,'
p23167
aS'                            alpha - 1.));'
p23168
aS'        max_residual = std::max(residual, max_residual);'
p23169
aS'        max_velocity_times_dF_dS ='
p23170
aS'          std::max(std::sqrt(u * u) * (use_dF_dS ? std::max(dF_dS, 1.) : 1),'
p23171
aS'                   max_velocity_times_dF_dS);'
p23172
aS'      }'
p23173
aS'    const double c_R            = 1.0;'
p23174
aS'    const double global_scaling = c_R * porosity *'
p23175
aS'                                  (global_max_u_F_prime)*global_S_variation /'
p23176
aS'                                  std::pow(global_Omega_diameter, alpha - 2.);'
p23177
aS'    return (beta *'
p23178
aS'            (max_velocity_times_dF_dS)*std::min(cell_diameter,'
p23179
aS'                                                std::pow(cell_diameter, alpha) *'
p23180
aS'                                                  max_residual /'
p23181
aS'                                                  global_scaling));'
p23182
aS'  }'
p23183
aS'  template <int dim>'
p23184
aS'  void TwoPhaseFlowProblem<dim>::run()'
p23185
aS'  {'
p23186
aS'    const unsigned int initial_refinement     = (dim == 2 ? 5 : 2);'
p23187
aS'    const unsigned int n_pre_refinement_steps = (dim == 2 ? 3 : 2);'
p23188
aS'    GridGenerator::hyper_cube(triangulation, 0, 1);'
p23189
aS'    triangulation.refine_global(initial_refinement);'
p23190
aS'    global_Omega_diameter = GridTools::diameter(triangulation);'
p23191
aS'    setup_dofs();'
p23192
aS'    unsigned int pre_refinement_step = 0;'
p23193
aS'  start_time_iteration:'
p23194
aS'    VectorTools::project(saturation_dof_handler,'
p23195
aS'                         saturation_constraints,'
p23196
aS'                         QGauss<dim>(saturation_degree + 2),'
p23197
aS'                         SaturationInitialValues<dim>(),'
p23198
aS'                         old_saturation_solution);'
p23199
aS'    time_step = old_time_step = 0;'
p23200
aS'    current_macro_time_step = old_macro_time_step = 0;'
p23201
aS'    time = 0;'
p23202
aS'    do'
p23203
aS'      {'
p23204
aS'        std::cout << "Timestep " << timestep_number << ":  t=" << time'
p23205
aS'                  << ", dt=" << time_step << std::endl;'
p23206
aS'        solve();'
p23207
aS'        std::cout << std::endl;'
p23208
aS'        if (timestep_number % 200 == 0)'
p23209
aS'          output_results();'
p23210
aS'        if (timestep_number % 25 == 0)'
p23211
aS'          refine_mesh(initial_refinement,'
p23212
aS'                      initial_refinement + n_pre_refinement_steps);'
p23213
aS'        if ((timestep_number == 0) &&'
p23214
aS'            (pre_refinement_step < n_pre_refinement_steps))'
p23215
aS'          {'
p23216
aS'            ++pre_refinement_step;'
p23217
aS'            goto start_time_iteration;'
p23218
aS'          }'
p23219
aS'        time += time_step;'
p23220
aS'        ++timestep_number;'
p23221
aS'        old_old_saturation_solution = old_saturation_solution;'
p23222
aS'        old_saturation_solution     = saturation_solution;'
p23223
aS'      }'
p23224
aS'    while (time <= end_time);'
p23225
aS'  }'
p23226
aS'} // namespace Step43'
p23227
aS'int main(int argc, char *argv[])'
p23228
ag24
aS'  try'
p23229
aS'    {'
p23230
aS'      using namespace dealii;'
p23231
aS'      using namespace Step43;'
p23232
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p23233
aS'        argc, argv, numbers::invalid_unsigned_int);'
p23234
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p23235
aS'                  ExcMessage('
p23236
aS'                    "This program can only be run in serial, use ./step-43"));'
p23237
aS'      TwoPhaseFlowProblem<2> two_phase_flow_problem(1);'
p23238
aS'      two_phase_flow_problem.run();'
p23239
aS'    }'
p23240
aS'  catch (std::exception &exc)'
p23241
aS'    {'
p23242
aS'      std::cerr << std::endl'
p23243
aS'                << std::endl'
p23244
aS'                << "----------------------------------------------------"'
p23245
aS'                << std::endl;'
p23246
aS'      std::cerr << "Exception on processing: " << std::endl'
p23247
aS'                << exc.what() << std::endl'
p23248
aS'                << "Aborting!" << std::endl'
p23249
aS'                << "----------------------------------------------------"'
p23250
aS'                << std::endl;'
p23251
aS'      return 1;'
p23252
aS'    }'
p23253
aS'  catch (...)'
p23254
aS'    {'
p23255
aS'      std::cerr << std::endl'
p23256
aS'                << std::endl'
p23257
aS'                << "----------------------------------------------------"'
p23258
aS'                << std::endl;'
p23259
aS'      std::cerr << "Unknown exception!" << std::endl'
p23260
aS'                << "Aborting!" << std::endl'
p23261
aS'                << "----------------------------------------------------"'
p23262
aS'                << std::endl;'
p23263
aS'      return 1;'
p23264
aS'    }'
p23265
aS'  return 0;'
p23266
ag32
aS'/* ---------------------------------------------------------------------'
p23267
aS' *'
p23268
aS' * Copyright (C) 2010 - 2020 by the deal.II authors and'
p23269
aS' *                              & Jean-Paul Pelteret and Andrew McBride'
p23270
aS' *'
p23271
aS' * This file is part of the deal.II library.'
p23272
aS' *'
p23273
aS' * The deal.II library is free software; you can use it, redistribute'
p23274
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p23275
aS' * Public License as published by the Free Software Foundation; either'
p23276
aS' * version 2.1 of the License, or (at your option) any later version.'
p23277
aS' * The full text of the license can be found in the file LICENSE.md at'
p23278
aS' * the top level directory of deal.II.'
p23279
aS' *'
p23280
aS' * ---------------------------------------------------------------------'
p23281
aS' *'
p23282
aS' * Authors: Jean-Paul Pelteret, University of Cape Town,'
p23283
aS' *          Andrew McBride, University of Erlangen-Nuremberg, 2010'
p23284
aS' */'
p23285
aS'#include <deal.II/base/function.h>'
p23286
aS'#include <deal.II/base/parameter_handler.h>'
p23287
aS'#include <deal.II/base/point.h>'
p23288
aS'#include <deal.II/base/quadrature_lib.h>'
p23289
aS'#include <deal.II/base/symmetric_tensor.h>'
p23290
aS'#include <deal.II/base/tensor.h>'
p23291
aS'#include <deal.II/base/timer.h>'
p23292
aS'#include <deal.II/base/work_stream.h>'
p23293
aS'#include <deal.II/dofs/dof_renumbering.h>'
p23294
aS'#include <deal.II/dofs/dof_tools.h>'
p23295
aS'#include <deal.II/base/quadrature_point_data.h>'
p23296
aS'#include <deal.II/grid/grid_generator.h>'
p23297
aS'#include <deal.II/grid/grid_tools.h>'
p23298
aS'#include <deal.II/grid/grid_in.h>'
p23299
aS'#include <deal.II/grid/tria.h>'
p23300
aS'#include <deal.II/fe/fe_dgp_monomial.h>'
p23301
aS'#include <deal.II/fe/fe_q.h>'
p23302
aS'#include <deal.II/fe/fe_system.h>'
p23303
aS'#include <deal.II/fe/fe_tools.h>'
p23304
aS'#include <deal.II/fe/fe_values.h>'
p23305
aS'#include <deal.II/fe/mapping_q_eulerian.h>'
p23306
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p23307
aS'#include <deal.II/lac/block_vector.h>'
p23308
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p23309
aS'#include <deal.II/lac/full_matrix.h>'
p23310
aS'#include <deal.II/lac/precondition_selector.h>'
p23311
aS'#include <deal.II/lac/solver_cg.h>'
p23312
aS'#include <deal.II/lac/solver_selector.h>'
p23313
aS'#include <deal.II/lac/sparse_direct.h>'
p23314
aS'#include <deal.II/lac/affine_constraints.h>'
p23315
aS'#include <deal.II/lac/linear_operator.h>'
p23316
aS'#include <deal.II/lac/packaged_operation.h>'
p23317
aS'#include <deal.II/numerics/data_out.h>'
p23318
aS'#include <deal.II/numerics/vector_tools.h>'
p23319
aS'#include <deal.II/physics/elasticity/kinematics.h>'
p23320
aS'#include <deal.II/physics/elasticity/standard_tensors.h>'
p23321
aS'#include <iostream>'
p23322
aS'#include <fstream>'
p23323
aS'namespace Step44'
p23324
ag24
aS'  using namespace dealii;'
p23325
aS'  namespace Parameters'
p23326
aS'  {'
p23327
aS'    struct FESystem'
p23328
aS'    {'
p23329
aS'      unsigned int poly_degree;'
p23330
aS'      unsigned int quad_order;'
p23331
aS'      static void declare_parameters(ParameterHandler &prm);'
p23332
aS'      void parse_parameters(ParameterHandler &prm);'
p23333
aS'    };'
p23334
aS'    void FESystem::declare_parameters(ParameterHandler &prm)'
p23335
aS'    {'
p23336
aS'      prm.enter_subsection("Finite element system");'
p23337
aS'      {'
p23338
aS'        prm.declare_entry("Polynomial degree",'
p23339
aS'                          "2",'
p23340
aS'                          Patterns::Integer(0),'
p23341
aS'                          "Displacement system polynomial order");'
p23342
aS'        prm.declare_entry("Quadrature order",'
p23343
aS'                          "3",'
p23344
aS'                          Patterns::Integer(0),'
p23345
aS'                          "Gauss quadrature order");'
p23346
aS'      }'
p23347
aS'      prm.leave_subsection();'
p23348
aS'    }'
p23349
aS'    void FESystem::parse_parameters(ParameterHandler &prm)'
p23350
aS'    {'
p23351
aS'      prm.enter_subsection("Finite element system");'
p23352
aS'      {'
p23353
aS'        poly_degree = prm.get_integer("Polynomial degree");'
p23354
aS'        quad_order  = prm.get_integer("Quadrature order");'
p23355
aS'      }'
p23356
aS'      prm.leave_subsection();'
p23357
aS'    }'
p23358
aS'    struct Geometry'
p23359
aS'    {'
p23360
aS'      unsigned int global_refinement;'
p23361
aS'      double       scale;'
p23362
aS'      double       p_p0;'
p23363
aS'      static void declare_parameters(ParameterHandler &prm);'
p23364
aS'      void parse_parameters(ParameterHandler &prm);'
p23365
aS'    };'
p23366
aS'    void Geometry::declare_parameters(ParameterHandler &prm)'
p23367
aS'    {'
p23368
aS'      prm.enter_subsection("Geometry");'
p23369
aS'      {'
p23370
aS'        prm.declare_entry("Global refinement",'
p23371
aS'                          "2",'
p23372
aS'                          Patterns::Integer(0),'
p23373
aS'                          "Global refinement level");'
p23374
aS'        prm.declare_entry("Grid scale",'
p23375
aS'                          "1e-3",'
p23376
aS'                          Patterns::Double(0.0),'
p23377
aS'                          "Global grid scaling factor");'
p23378
aS'        prm.declare_entry("Pressure ratio p/p0",'
p23379
aS'                          "100",'
p23380
aS'                          Patterns::Selection("20|40|60|80|100"),'
p23381
aS'                          "Ratio of applied pressure to reference pressure");'
p23382
aS'      }'
p23383
aS'      prm.leave_subsection();'
p23384
aS'    }'
p23385
aS'    void Geometry::parse_parameters(ParameterHandler &prm)'
p23386
aS'    {'
p23387
aS'      prm.enter_subsection("Geometry");'
p23388
aS'      {'
p23389
aS'        global_refinement = prm.get_integer("Global refinement");'
p23390
aS'        scale             = prm.get_double("Grid scale");'
p23391
aS'        p_p0              = prm.get_double("Pressure ratio p/p0");'
p23392
aS'      }'
p23393
aS'      prm.leave_subsection();'
p23394
aS'    }'
p23395
aS'    struct Materials'
p23396
aS'    {'
p23397
aS'      double nu;'
p23398
aS'      double mu;'
p23399
aS'      static void declare_parameters(ParameterHandler &prm);'
p23400
aS'      void parse_parameters(ParameterHandler &prm);'
p23401
aS'    };'
p23402
aS'    void Materials::declare_parameters(ParameterHandler &prm)'
p23403
aS'    {'
p23404
aS'      prm.enter_subsection("Material properties");'
p23405
aS'      {'
p23406
aS'        prm.declare_entry("Poisson\'s ratio",'
p23407
aS'                          "0.4999",'
p23408
aS'                          Patterns::Double(-1.0, 0.5),'
p23409
aS'                          "Poisson\'s ratio");'
p23410
aS'        prm.declare_entry("Shear modulus",'
p23411
aS'                          "80.194e6",'
p23412
aS'                          Patterns::Double(),'
p23413
aS'                          "Shear modulus");'
p23414
aS'      }'
p23415
aS'      prm.leave_subsection();'
p23416
aS'    }'
p23417
aS'    void Materials::parse_parameters(ParameterHandler &prm)'
p23418
aS'    {'
p23419
aS'      prm.enter_subsection("Material properties");'
p23420
aS'      {'
p23421
aS'        nu = prm.get_double("Poisson\'s ratio");'
p23422
aS'        mu = prm.get_double("Shear modulus");'
p23423
aS'      }'
p23424
aS'      prm.leave_subsection();'
p23425
aS'    }'
p23426
aS'    struct LinearSolver'
p23427
aS'    {'
p23428
aS'      std::string type_lin;'
p23429
aS'      double      tol_lin;'
p23430
aS'      double      max_iterations_lin;'
p23431
aS'      bool        use_static_condensation;'
p23432
aS'      std::string preconditioner_type;'
p23433
aS'      double      preconditioner_relaxation;'
p23434
aS'      static void declare_parameters(ParameterHandler &prm);'
p23435
aS'      void parse_parameters(ParameterHandler &prm);'
p23436
aS'    };'
p23437
aS'    void LinearSolver::declare_parameters(ParameterHandler &prm)'
p23438
aS'    {'
p23439
aS'      prm.enter_subsection("Linear solver");'
p23440
aS'      {'
p23441
aS'        prm.declare_entry("Solver type",'
p23442
aS'                          "CG",'
p23443
aS'                          Patterns::Selection("CG|Direct"),'
p23444
aS'                          "Type of solver used to solve the linear system");'
p23445
aS'        prm.declare_entry("Residual",'
p23446
aS'                          "1e-6",'
p23447
aS'                          Patterns::Double(0.0),'
p23448
aS'                          "Linear solver residual (scaled by residual norm)");'
p23449
aS'        prm.declare_entry('
p23450
aS'          "Max iteration multiplier",'
p23451
aS'          "1",'
p23452
aS'          Patterns::Double(0.0),'
p23453
aS'          "Linear solver iterations (multiples of the system matrix size)");'
p23454
aS'        prm.declare_entry("Use static condensation",'
p23455
aS'                          "true",'
p23456
aS'                          Patterns::Bool(),'
p23457
aS'                          "Solve the full block system or a reduced problem");'
p23458
aS'        prm.declare_entry("Preconditioner type",'
p23459
aS'                          "ssor",'
p23460
aS'                          Patterns::Selection("jacobi|ssor"),'
p23461
aS'                          "Type of preconditioner");'
p23462
aS'        prm.declare_entry("Preconditioner relaxation",'
p23463
aS'                          "0.65",'
p23464
aS'                          Patterns::Double(0.0),'
p23465
aS'                          "Preconditioner relaxation value");'
p23466
aS'      }'
p23467
aS'      prm.leave_subsection();'
p23468
aS'    }'
p23469
aS'    void LinearSolver::parse_parameters(ParameterHandler &prm)'
p23470
aS'    {'
p23471
aS'      prm.enter_subsection("Linear solver");'
p23472
aS'      {'
p23473
aS'        type_lin                  = prm.get("Solver type");'
p23474
aS'        tol_lin                   = prm.get_double("Residual");'
p23475
aS'        max_iterations_lin        = prm.get_double("Max iteration multiplier");'
p23476
aS'        use_static_condensation   = prm.get_bool("Use static condensation");'
p23477
aS'        preconditioner_type       = prm.get("Preconditioner type");'
p23478
aS'        preconditioner_relaxation = prm.get_double("Preconditioner relaxation");'
p23479
aS'      }'
p23480
aS'      prm.leave_subsection();'
p23481
aS'    }'
p23482
aS'    struct NonlinearSolver'
p23483
aS'    {'
p23484
aS'      unsigned int max_iterations_NR;'
p23485
aS'      double       tol_f;'
p23486
aS'      double       tol_u;'
p23487
aS'      static void declare_parameters(ParameterHandler &prm);'
p23488
aS'      void parse_parameters(ParameterHandler &prm);'
p23489
aS'    };'
p23490
aS'    void NonlinearSolver::declare_parameters(ParameterHandler &prm)'
p23491
aS'    {'
p23492
aS'      prm.enter_subsection("Nonlinear solver");'
p23493
aS'      {'
p23494
aS'        prm.declare_entry("Max iterations Newton-Raphson",'
p23495
aS'                          "10",'
p23496
aS'                          Patterns::Integer(0),'
p23497
aS'                          "Number of Newton-Raphson iterations allowed");'
p23498
aS'        prm.declare_entry("Tolerance force",'
p23499
aS'                          "1.0e-9",'
p23500
aS'                          Patterns::Double(0.0),'
p23501
aS'                          "Force residual tolerance");'
p23502
aS'        prm.declare_entry("Tolerance displacement",'
p23503
aS'                          "1.0e-6",'
p23504
aS'                          Patterns::Double(0.0),'
p23505
aS'                          "Displacement error tolerance");'
p23506
aS'      }'
p23507
aS'      prm.leave_subsection();'
p23508
aS'    }'
p23509
aS'    void NonlinearSolver::parse_parameters(ParameterHandler &prm)'
p23510
aS'    {'
p23511
aS'      prm.enter_subsection("Nonlinear solver");'
p23512
aS'      {'
p23513
aS'        max_iterations_NR = prm.get_integer("Max iterations Newton-Raphson");'
p23514
aS'        tol_f             = prm.get_double("Tolerance force");'
p23515
aS'        tol_u             = prm.get_double("Tolerance displacement");'
p23516
aS'      }'
p23517
aS'      prm.leave_subsection();'
p23518
aS'    }'
p23519
aS'    struct Time'
p23520
aS'    {'
p23521
aS'      double delta_t;'
p23522
aS'      double end_time;'
p23523
aS'      static void declare_parameters(ParameterHandler &prm);'
p23524
aS'      void parse_parameters(ParameterHandler &prm);'
p23525
aS'    };'
p23526
aS'    void Time::declare_parameters(ParameterHandler &prm)'
p23527
aS'    {'
p23528
aS'      prm.enter_subsection("Time");'
p23529
aS'      {'
p23530
aS'        prm.declare_entry("End time", "1", Patterns::Double(), "End time");'
p23531
aS'        prm.declare_entry("Time step size",'
p23532
aS'                          "0.1",'
p23533
aS'                          Patterns::Double(),'
p23534
aS'                          "Time step size");'
p23535
aS'      }'
p23536
aS'      prm.leave_subsection();'
p23537
aS'    }'
p23538
aS'    void Time::parse_parameters(ParameterHandler &prm)'
p23539
aS'    {'
p23540
aS'      prm.enter_subsection("Time");'
p23541
aS'      {'
p23542
aS'        end_time = prm.get_double("End time");'
p23543
aS'        delta_t  = prm.get_double("Time step size");'
p23544
aS'      }'
p23545
aS'      prm.leave_subsection();'
p23546
aS'    }'
p23547
aS'    struct AllParameters : public FESystem,'
p23548
aS'                           public Geometry,'
p23549
aS'                           public Materials,'
p23550
aS'                           public LinearSolver,'
p23551
aS'                           public NonlinearSolver,'
p23552
aS'                           public Time'
p23553
aS'    {'
p23554
aS'      AllParameters(const std::string &input_file);'
p23555
aS'      static void declare_parameters(ParameterHandler &prm);'
p23556
aS'      void parse_parameters(ParameterHandler &prm);'
p23557
aS'    };'
p23558
aS'    AllParameters::AllParameters(const std::string &input_file)'
p23559
aS'    {'
p23560
aS'      ParameterHandler prm;'
p23561
aS'      declare_parameters(prm);'
p23562
aS'      prm.parse_input(input_file);'
p23563
aS'      parse_parameters(prm);'
p23564
aS'    }'
p23565
aS'    void AllParameters::declare_parameters(ParameterHandler &prm)'
p23566
aS'    {'
p23567
aS'      FESystem::declare_parameters(prm);'
p23568
aS'      Geometry::declare_parameters(prm);'
p23569
aS'      Materials::declare_parameters(prm);'
p23570
aS'      LinearSolver::declare_parameters(prm);'
p23571
aS'      NonlinearSolver::declare_parameters(prm);'
p23572
aS'      Time::declare_parameters(prm);'
p23573
aS'    }'
p23574
aS'    void AllParameters::parse_parameters(ParameterHandler &prm)'
p23575
aS'    {'
p23576
aS'      FESystem::parse_parameters(prm);'
p23577
aS'      Geometry::parse_parameters(prm);'
p23578
aS'      Materials::parse_parameters(prm);'
p23579
aS'      LinearSolver::parse_parameters(prm);'
p23580
aS'      NonlinearSolver::parse_parameters(prm);'
p23581
aS'      Time::parse_parameters(prm);'
p23582
aS'    }'
p23583
aS'  } // namespace Parameters'
p23584
aS'  class Time'
p23585
aS'  {'
p23586
aS'  public:'
p23587
aS'    Time(const double time_end, const double delta_t)'
p23588
aS'      : timestep(0)'
p23589
aS'      , time_current(0.0)'
p23590
aS'      , time_end(time_end)'
p23591
aS'      , delta_t(delta_t)'
p23592
aS'    {}'
p23593
aS'    virtual ~Time() = default;'
p23594
aS'    double current() const'
p23595
aS'    {'
p23596
aS'      return time_current;'
p23597
aS'    }'
p23598
aS'    double end() const'
p23599
aS'    {'
p23600
aS'      return time_end;'
p23601
aS'    }'
p23602
aS'    double get_delta_t() const'
p23603
aS'    {'
p23604
aS'      return delta_t;'
p23605
aS'    }'
p23606
aS'    unsigned int get_timestep() const'
p23607
aS'    {'
p23608
aS'      return timestep;'
p23609
aS'    }'
p23610
aS'    void increment()'
p23611
aS'    {'
p23612
aS'      time_current += delta_t;'
p23613
aS'      ++timestep;'
p23614
aS'    }'
p23615
aS'  private:'
p23616
aS'    unsigned int timestep;'
p23617
aS'    double       time_current;'
p23618
aS'    const double time_end;'
p23619
aS'    const double delta_t;'
p23620
aS'  };'
p23621
aS'  template <int dim>'
p23622
aS'  class Material_Compressible_Neo_Hook_Three_Field'
p23623
aS'  {'
p23624
aS'  public:'
p23625
aS'    Material_Compressible_Neo_Hook_Three_Field(const double mu, const double nu)'
p23626
aS'      : kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu)))'
p23627
aS'      , c_1(mu / 2.0)'
p23628
aS'      , det_F(1.0)'
p23629
aS'      , p_tilde(0.0)'
p23630
aS'      , J_tilde(1.0)'
p23631
aS'      , b_bar(Physics::Elasticity::StandardTensors<dim>::I)'
p23632
aS'    {'
p23633
aS'      Assert(kappa > 0, ExcInternalError());'
p23634
aS'    }'
p23635
aS'    void update_material_data(const Tensor<2, dim> &F,'
p23636
aS'                              const double          p_tilde_in,'
p23637
aS'                              const double          J_tilde_in)'
p23638
aS'    {'
p23639
aS'      det_F                      = determinant(F);'
p23640
aS'      const Tensor<2, dim> F_bar = Physics::Elasticity::Kinematics::F_iso(F);'
p23641
aS'      b_bar                      = Physics::Elasticity::Kinematics::b(F_bar);'
p23642
aS'      p_tilde                    = p_tilde_in;'
p23643
aS'      J_tilde                    = J_tilde_in;'
p23644
aS'      Assert(det_F > 0, ExcInternalError());'
p23645
aS'    }'
p23646
aS'    SymmetricTensor<2, dim> get_tau()'
p23647
aS'    {'
p23648
aS'      return get_tau_iso() + get_tau_vol();'
p23649
aS'    }'
p23650
aS'    SymmetricTensor<4, dim> get_Jc() const'
p23651
aS'    {'
p23652
aS'      return get_Jc_vol() + get_Jc_iso();'
p23653
aS'    }'
p23654
aS'    double get_dPsi_vol_dJ() const'
p23655
aS'    {'
p23656
aS'      return (kappa / 2.0) * (J_tilde - 1.0 / J_tilde);'
p23657
aS'    }'
p23658
aS'    double get_d2Psi_vol_dJ2() const'
p23659
aS'    {'
p23660
aS'      return ((kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde)));'
p23661
aS'    }'
p23662
aS'    double get_det_F() const'
p23663
aS'    {'
p23664
aS'      return det_F;'
p23665
aS'    }'
p23666
aS'    double get_p_tilde() const'
p23667
aS'    {'
p23668
aS'      return p_tilde;'
p23669
aS'    }'
p23670
aS'    double get_J_tilde() const'
p23671
aS'    {'
p23672
aS'      return J_tilde;'
p23673
aS'    }'
p23674
aS'  protected:'
p23675
aS'    const double kappa;'
p23676
aS'    const double c_1;'
p23677
aS'    double                  det_F;'
p23678
aS'    double                  p_tilde;'
p23679
aS'    double                  J_tilde;'
p23680
aS'    SymmetricTensor<2, dim> b_bar;'
p23681
aS'    SymmetricTensor<2, dim> get_tau_vol() const'
p23682
aS'    {'
p23683
aS'      return p_tilde * det_F * Physics::Elasticity::StandardTensors<dim>::I;'
p23684
aS'    }'
p23685
aS'    SymmetricTensor<2, dim> get_tau_iso() const'
p23686
aS'    {'
p23687
aS'      return Physics::Elasticity::StandardTensors<dim>::dev_P * get_tau_bar();'
p23688
aS'    }'
p23689
aS'    SymmetricTensor<2, dim> get_tau_bar() const'
p23690
aS'    {'
p23691
aS'      return 2.0 * c_1 * b_bar;'
p23692
aS'    }'
p23693
aS'    SymmetricTensor<4, dim> get_Jc_vol() const'
p23694
aS'    {'
p23695
aS'      return p_tilde * det_F *'
p23696
aS'             (Physics::Elasticity::StandardTensors<dim>::IxI -'
p23697
aS'              (2.0 * Physics::Elasticity::StandardTensors<dim>::S));'
p23698
aS'    }'
p23699
aS'    SymmetricTensor<4, dim> get_Jc_iso() const'
p23700
aS'    {'
p23701
aS'      const SymmetricTensor<2, dim> tau_bar = get_tau_bar();'
p23702
aS'      const SymmetricTensor<2, dim> tau_iso = get_tau_iso();'
p23703
aS'      const SymmetricTensor<4, dim> tau_iso_x_I ='
p23704
aS'        outer_product(tau_iso, Physics::Elasticity::StandardTensors<dim>::I);'
p23705
aS'      const SymmetricTensor<4, dim> I_x_tau_iso ='
p23706
aS'        outer_product(Physics::Elasticity::StandardTensors<dim>::I, tau_iso);'
p23707
aS'      const SymmetricTensor<4, dim> c_bar = get_c_bar();'
p23708
aS'      return (2.0 / dim) * trace(tau_bar) *'
p23709
aS'               Physics::Elasticity::StandardTensors<dim>::dev_P -'
p23710
aS'             (2.0 / dim) * (tau_iso_x_I + I_x_tau_iso) +'
p23711
aS'             Physics::Elasticity::StandardTensors<dim>::dev_P * c_bar *'
p23712
aS'               Physics::Elasticity::StandardTensors<dim>::dev_P;'
p23713
aS'    }'
p23714
aS'    SymmetricTensor<4, dim> get_c_bar() const'
p23715
aS'    {'
p23716
aS'      return SymmetricTensor<4, dim>();'
p23717
aS'    }'
p23718
aS'  };'
p23719
aS'  template <int dim>'
p23720
aS'  class PointHistory'
p23721
aS'  {'
p23722
aS'  public:'
p23723
aS'    PointHistory()'
p23724
aS'      : F_inv(Physics::Elasticity::StandardTensors<dim>::I)'
p23725
aS'      , tau(SymmetricTensor<2, dim>())'
p23726
aS'      , d2Psi_vol_dJ2(0.0)'
p23727
aS'      , dPsi_vol_dJ(0.0)'
p23728
aS'      , Jc(SymmetricTensor<4, dim>())'
p23729
aS'    {}'
p23730
aS'    virtual ~PointHistory() = default;'
p23731
aS'    void setup_lqp(const Parameters::AllParameters &parameters)'
p23732
aS'    {'
p23733
aS'      material ='
p23734
aS'        std::make_shared<Material_Compressible_Neo_Hook_Three_Field<dim>>('
p23735
aS'          parameters.mu, parameters.nu);'
p23736
aS'      update_values(Tensor<2, dim>(), 0.0, 1.0);'
p23737
aS'    }'
p23738
aS'    void update_values(const Tensor<2, dim> &Grad_u_n,'
p23739
aS'                       const double          p_tilde,'
p23740
aS'                       const double          J_tilde)'
p23741
aS'    {'
p23742
aS'      const Tensor<2, dim> F = Physics::Elasticity::Kinematics::F(Grad_u_n);'
p23743
aS'      material->update_material_data(F, p_tilde, J_tilde);'
p23744
aS'      F_inv         = invert(F);'
p23745
aS'      tau           = material->get_tau();'
p23746
aS'      Jc            = material->get_Jc();'
p23747
aS'      dPsi_vol_dJ   = material->get_dPsi_vol_dJ();'
p23748
aS'      d2Psi_vol_dJ2 = material->get_d2Psi_vol_dJ2();'
p23749
aS'    }'
p23750
aS'    double get_J_tilde() const'
p23751
aS'    {'
p23752
aS'      return material->get_J_tilde();'
p23753
aS'    }'
p23754
aS'    double get_det_F() const'
p23755
aS'    {'
p23756
aS'      return material->get_det_F();'
p23757
aS'    }'
p23758
aS'    const Tensor<2, dim> &get_F_inv() const'
p23759
aS'    {'
p23760
aS'      return F_inv;'
p23761
aS'    }'
p23762
aS'    double get_p_tilde() const'
p23763
aS'    {'
p23764
aS'      return material->get_p_tilde();'
p23765
aS'    }'
p23766
aS'    const SymmetricTensor<2, dim> &get_tau() const'
p23767
aS'    {'
p23768
aS'      return tau;'
p23769
aS'    }'
p23770
aS'    double get_dPsi_vol_dJ() const'
p23771
aS'    {'
p23772
aS'      return dPsi_vol_dJ;'
p23773
aS'    }'
p23774
aS'    double get_d2Psi_vol_dJ2() const'
p23775
aS'    {'
p23776
aS'      return d2Psi_vol_dJ2;'
p23777
aS'    }'
p23778
aS'    const SymmetricTensor<4, dim> &get_Jc() const'
p23779
aS'    {'
p23780
aS'      return Jc;'
p23781
aS'    }'
p23782
aS'  private:'
p23783
aS'    std::shared_ptr<Material_Compressible_Neo_Hook_Three_Field<dim>> material;'
p23784
aS'    Tensor<2, dim> F_inv;'
p23785
aS'    SymmetricTensor<2, dim> tau;'
p23786
aS'    double                  d2Psi_vol_dJ2;'
p23787
aS'    double                  dPsi_vol_dJ;'
p23788
aS'    SymmetricTensor<4, dim> Jc;'
p23789
aS'  };'
p23790
aS'  template <int dim>'
p23791
aS'  class Solid'
p23792
aS'  {'
p23793
aS'  public:'
p23794
aS'    Solid(const std::string &input_file);'
p23795
aS'    void run();'
p23796
aS'  private:'
p23797
aS'    struct PerTaskData_ASM;'
p23798
aS'    struct ScratchData_ASM;'
p23799
aS'    struct PerTaskData_SC;'
p23800
aS'    struct ScratchData_SC;'
p23801
aS'    struct PerTaskData_UQPH;'
p23802
aS'    struct ScratchData_UQPH;'
p23803
aS'    void make_grid();'
p23804
aS'    void system_setup();'
p23805
aS'    void determine_component_extractors();'
p23806
aS'    void make_constraints(const int it_nr);'
p23807
aS'    void assemble_system();'
p23808
aS'    void assemble_system_one_cell('
p23809
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23810
aS'      ScratchData_ASM &                                     scratch,'
p23811
aS'      PerTaskData_ASM &                                     data) const;'
p23812
aS'    void assemble_sc();'
p23813
aS'    void assemble_sc_one_cell('
p23814
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23815
aS'      ScratchData_SC &                                      scratch,'
p23816
aS'      PerTaskData_SC &                                      data);'
p23817
aS'    void copy_local_to_global_sc(const PerTaskData_SC &data);'
p23818
aS'    void setup_qph();'
p23819
aS'    void update_qph_incremental(const BlockVector<double> &solution_delta);'
p23820
aS'    void update_qph_incremental_one_cell('
p23821
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23822
aS'      ScratchData_UQPH &                                    scratch,'
p23823
aS'      PerTaskData_UQPH &                                    data);'
p23824
aS'    void copy_local_to_global_UQPH(const PerTaskData_UQPH & /*data*/)'
p23825
aS'    {}'
p23826
aS'    void solve_nonlinear_timestep(BlockVector<double> &solution_delta);'
p23827
aS'    std::pair<unsigned int, double>'
p23828
aS'    solve_linear_system(BlockVector<double> &newton_update);'
p23829
aS'    BlockVector<double>'
p23830
aS'    get_total_solution(const BlockVector<double> &solution_delta) const;'
p23831
aS'    void output_results() const;'
p23832
aS'    Parameters::AllParameters parameters;'
p23833
aS'    double vol_reference;'
p23834
aS'    Triangulation<dim> triangulation;'
p23835
aS'    Time                time;'
p23836
aS'    mutable TimerOutput timer;'
p23837
aS'    CellDataStorage<typename Triangulation<dim>::cell_iterator,'
p23838
aS'                    PointHistory<dim>>'
p23839
aS'      quadrature_point_history;'
p23840
aS'    const unsigned int               degree;'
p23841
aS'    const FESystem<dim>              fe;'
p23842
aS'    DoFHandler<dim>                  dof_handler;'
p23843
aS'    const unsigned int               dofs_per_cell;'
p23844
aS'    const FEValuesExtractors::Vector u_fe;'
p23845
aS'    const FEValuesExtractors::Scalar p_fe;'
p23846
aS'    const FEValuesExtractors::Scalar J_fe;'
p23847
aS'    static const unsigned int n_blocks          = 3;'
p23848
aS'    static const unsigned int n_components      = dim + 2;'
p23849
aS'    static const unsigned int first_u_component = 0;'
p23850
aS'    static const unsigned int p_component       = dim;'
p23851
aS'    static const unsigned int J_component       = dim + 1;'
p23852
aS'    enum'
p23853
aS'    {'
p23854
aS'      u_dof = 0,'
p23855
aS'      p_dof = 1,'
p23856
aS'      J_dof = 2'
p23857
aS'    };'
p23858
aS'    std::vector<types::global_dof_index> dofs_per_block;'
p23859
aS'    std::vector<types::global_dof_index> element_indices_u;'
p23860
aS'    std::vector<types::global_dof_index> element_indices_p;'
p23861
aS'    std::vector<types::global_dof_index> element_indices_J;'
p23862
aS'    const QGauss<dim>     qf_cell;'
p23863
aS'    const QGauss<dim - 1> qf_face;'
p23864
aS'    const unsigned int    n_q_points;'
p23865
aS'    const unsigned int    n_q_points_f;'
p23866
aS'    AffineConstraints<double> constraints;'
p23867
aS'    BlockSparsityPattern      sparsity_pattern;'
p23868
aS'    BlockSparseMatrix<double> tangent_matrix;'
p23869
aS'    BlockVector<double>       system_rhs;'
p23870
aS'    BlockVector<double>       solution_n;'
p23871
aS'    struct Errors'
p23872
aS'    {'
p23873
aS'      Errors()'
p23874
aS'        : norm(1.0)'
p23875
aS'        , u(1.0)'
p23876
aS'        , p(1.0)'
p23877
aS'        , J(1.0)'
p23878
aS'      {}'
p23879
aS'      void reset()'
p23880
aS'      {'
p23881
aS'        norm = 1.0;'
p23882
aS'        u    = 1.0;'
p23883
aS'        p    = 1.0;'
p23884
aS'        J    = 1.0;'
p23885
aS'      }'
p23886
aS'      void normalize(const Errors &rhs)'
p23887
aS'      {'
p23888
aS'        if (rhs.norm != 0.0)'
p23889
aS'          norm /= rhs.norm;'
p23890
aS'        if (rhs.u != 0.0)'
p23891
aS'          u /= rhs.u;'
p23892
aS'        if (rhs.p != 0.0)'
p23893
aS'          p /= rhs.p;'
p23894
aS'        if (rhs.J != 0.0)'
p23895
aS'          J /= rhs.J;'
p23896
aS'      }'
p23897
aS'      double norm, u, p, J;'
p23898
aS'    };'
p23899
aS'    Errors error_residual, error_residual_0, error_residual_norm, error_update,'
p23900
aS'      error_update_0, error_update_norm;'
p23901
aS'    void get_error_residual(Errors &error_residual);'
p23902
aS'    void get_error_update(const BlockVector<double> &newton_update,'
p23903
aS'                          Errors &                   error_update);'
p23904
aS'    std::pair<double, double> get_error_dilation() const;'
p23905
aS'    double compute_vol_current() const;'
p23906
aS'    static void print_conv_header();'
p23907
aS'    void print_conv_footer();'
p23908
aS'  };'
p23909
aS'  template <int dim>'
p23910
aS'  Solid<dim>::Solid(const std::string &input_file)'
p23911
aS'    : parameters(input_file)'
p23912
aS'    , vol_reference(0.)'
p23913
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p23914
aS'    , time(parameters.end_time, parameters.delta_t)'
p23915
aS'    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)'
p23916
aS'    , degree(parameters.poly_degree)'
p23917
aS'    ,'
p23918
aS'    fe(FE_Q<dim>(parameters.poly_degree),'
p23919
aS'       dim, // displacement'
p23920
aS'       FE_DGPMonomial<dim>(parameters.poly_degree - 1),'
p23921
aS'       1, // pressure'
p23922
aS'       FE_DGPMonomial<dim>(parameters.poly_degree - 1),'
p23923
aS'       1)'
p23924
aS'    , // dilatation'
p23925
aS'    dof_handler(triangulation)'
p23926
aS'    , dofs_per_cell(fe.n_dofs_per_cell())'
p23927
aS'    , u_fe(first_u_component)'
p23928
aS'    , p_fe(p_component)'
p23929
aS'    , J_fe(J_component)'
p23930
aS'    , dofs_per_block(n_blocks)'
p23931
aS'    , qf_cell(parameters.quad_order)'
p23932
aS'    , qf_face(parameters.quad_order)'
p23933
aS'    , n_q_points(qf_cell.size())'
p23934
aS'    , n_q_points_f(qf_face.size())'
p23935
aS'  {'
p23936
aS'    Assert(dim == 2 || dim == 3,'
p23937
aS'           ExcMessage("This problem only works in 2 or 3 space dimensions."));'
p23938
aS'    determine_component_extractors();'
p23939
aS'  }'
p23940
aS'  template <int dim>'
p23941
aS'  void Solid<dim>::run()'
p23942
aS'  {'
p23943
aS'    make_grid();'
p23944
aS'    system_setup();'
p23945
aS'    {'
p23946
aS'      AffineConstraints<double> constraints;'
p23947
aS'      constraints.close();'
p23948
aS'      const ComponentSelectFunction<dim> J_mask(J_component, n_components);'
p23949
aS'      VectorTools::project('
p23950
aS'        dof_handler, constraints, QGauss<dim>(degree + 2), J_mask, solution_n);'
p23951
aS'    }'
p23952
aS'    output_results();'
p23953
aS'    time.increment();'
p23954
aS'    BlockVector<double> solution_delta(dofs_per_block);'
p23955
aS'    while (time.current() < time.end())'
p23956
aS'      {'
p23957
aS'        solution_delta = 0.0;'
p23958
aS'        solve_nonlinear_timestep(solution_delta);'
p23959
aS'        solution_n += solution_delta;'
p23960
aS'        output_results();'
p23961
aS'        time.increment();'
p23962
aS'      }'
p23963
aS'  }'
p23964
aS'  template <int dim>'
p23965
aS'  struct Solid<dim>::PerTaskData_ASM'
p23966
aS'  {'
p23967
aS'    FullMatrix<double>                   cell_matrix;'
p23968
aS'    Vector<double>                       cell_rhs;'
p23969
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p23970
aS'    PerTaskData_ASM(const unsigned int dofs_per_cell)'
p23971
aS'      : cell_matrix(dofs_per_cell, dofs_per_cell)'
p23972
aS'      , cell_rhs(dofs_per_cell)'
p23973
aS'      , local_dof_indices(dofs_per_cell)'
p23974
aS'    {}'
p23975
aS'    void reset()'
p23976
aS'    {'
p23977
aS'      cell_matrix = 0.0;'
p23978
aS'      cell_rhs    = 0.0;'
p23979
aS'    }'
p23980
aS'  };'
p23981
aS'  template <int dim>'
p23982
aS'  struct Solid<dim>::ScratchData_ASM'
p23983
aS'  {'
p23984
aS'    FEValues<dim>     fe_values;'
p23985
aS'    FEFaceValues<dim> fe_face_values;'
p23986
aS'    std::vector<std::vector<double>>                  Nx;'
p23987
aS'    std::vector<std::vector<Tensor<2, dim>>>          grad_Nx;'
p23988
aS'    std::vector<std::vector<SymmetricTensor<2, dim>>> symm_grad_Nx;'
p23989
aS'    ScratchData_ASM(const FiniteElement<dim> &fe_cell,'
p23990
aS'                    const QGauss<dim> &       qf_cell,'
p23991
aS'                    const UpdateFlags         uf_cell,'
p23992
aS'                    const QGauss<dim - 1> &   qf_face,'
p23993
aS'                    const UpdateFlags         uf_face)'
p23994
aS'      : fe_values(fe_cell, qf_cell, uf_cell)'
p23995
aS'      , fe_face_values(fe_cell, qf_face, uf_face)'
p23996
aS'      , Nx(qf_cell.size(), std::vector<double>(fe_cell.n_dofs_per_cell()))'
p23997
aS'      , grad_Nx(qf_cell.size(),'
p23998
aS'                std::vector<Tensor<2, dim>>(fe_cell.n_dofs_per_cell()))'
p23999
aS'      , symm_grad_Nx(qf_cell.size(),'
p24000
aS'                     std::vector<SymmetricTensor<2, dim>>('
p24001
aS'                       fe_cell.n_dofs_per_cell()))'
p24002
aS'    {}'
p24003
aS'    ScratchData_ASM(const ScratchData_ASM &rhs)'
p24004
aS'      : fe_values(rhs.fe_values.get_fe(),'
p24005
aS'                  rhs.fe_values.get_quadrature(),'
p24006
aS'                  rhs.fe_values.get_update_flags())'
p24007
aS'      , fe_face_values(rhs.fe_face_values.get_fe(),'
p24008
aS'                       rhs.fe_face_values.get_quadrature(),'
p24009
aS'                       rhs.fe_face_values.get_update_flags())'
p24010
aS'      , Nx(rhs.Nx)'
p24011
aS'      , grad_Nx(rhs.grad_Nx)'
p24012
aS'      , symm_grad_Nx(rhs.symm_grad_Nx)'
p24013
aS'    {}'
p24014
aS'    void reset()'
p24015
aS'    {'
p24016
aS'      const unsigned int n_q_points      = Nx.size();'
p24017
aS'      const unsigned int n_dofs_per_cell = Nx[0].size();'
p24018
aS'      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p24019
aS'        {'
p24020
aS'          Assert(Nx[q_point].size() == n_dofs_per_cell, ExcInternalError());'
p24021
aS'          Assert(grad_Nx[q_point].size() == n_dofs_per_cell,'
p24022
aS'                 ExcInternalError());'
p24023
aS'          Assert(symm_grad_Nx[q_point].size() == n_dofs_per_cell,'
p24024
aS'                 ExcInternalError());'
p24025
aS'          for (unsigned int k = 0; k < n_dofs_per_cell; ++k)'
p24026
aS'            {'
p24027
aS'              Nx[q_point][k]           = 0.0;'
p24028
aS'              grad_Nx[q_point][k]      = 0.0;'
p24029
aS'              symm_grad_Nx[q_point][k] = 0.0;'
p24030
aS'            }'
p24031
aS'        }'
p24032
aS'    }'
p24033
aS'  };'
p24034
aS'  template <int dim>'
p24035
aS'  struct Solid<dim>::PerTaskData_SC'
p24036
aS'  {'
p24037
aS'    FullMatrix<double>                   cell_matrix;'
p24038
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p24039
aS'    FullMatrix<double> k_orig;'
p24040
aS'    FullMatrix<double> k_pu;'
p24041
aS'    FullMatrix<double> k_pJ;'
p24042
aS'    FullMatrix<double> k_JJ;'
p24043
aS'    FullMatrix<double> k_pJ_inv;'
p24044
aS'    FullMatrix<double> k_bbar;'
p24045
aS'    FullMatrix<double> A;'
p24046
aS'    FullMatrix<double> B;'
p24047
aS'    FullMatrix<double> C;'
p24048
aS'    PerTaskData_SC(const unsigned int dofs_per_cell,'
p24049
aS'                   const unsigned int n_u,'
p24050
aS'                   const unsigned int n_p,'
p24051
aS'                   const unsigned int n_J)'
p24052
aS'      : cell_matrix(dofs_per_cell, dofs_per_cell)'
p24053
aS'      , local_dof_indices(dofs_per_cell)'
p24054
aS'      , k_orig(dofs_per_cell, dofs_per_cell)'
p24055
aS'      , k_pu(n_p, n_u)'
p24056
aS'      , k_pJ(n_p, n_J)'
p24057
aS'      , k_JJ(n_J, n_J)'
p24058
aS'      , k_pJ_inv(n_p, n_J)'
p24059
aS'      , k_bbar(n_u, n_u)'
p24060
aS'      , A(n_J, n_u)'
p24061
aS'      , B(n_J, n_u)'
p24062
aS'      , C(n_p, n_u)'
p24063
aS'    {}'
p24064
aS'    void reset()'
p24065
aS'    {}'
p24066
aS'  };'
p24067
aS'  template <int dim>'
p24068
aS'  struct Solid<dim>::ScratchData_SC'
p24069
aS'  {'
p24070
aS'    void reset()'
p24071
aS'    {}'
p24072
aS'  };'
p24073
aS'  template <int dim>'
p24074
aS'  struct Solid<dim>::PerTaskData_UQPH'
p24075
aS'  {'
p24076
aS'    void reset()'
p24077
aS'    {}'
p24078
aS'  };'
p24079
aS'  template <int dim>'
p24080
aS'  struct Solid<dim>::ScratchData_UQPH'
p24081
aS'  {'
p24082
aS'    const BlockVector<double> &solution_total;'
p24083
aS'    std::vector<Tensor<2, dim>> solution_grads_u_total;'
p24084
aS'    std::vector<double>         solution_values_p_total;'
p24085
aS'    std::vector<double>         solution_values_J_total;'
p24086
aS'    FEValues<dim> fe_values;'
p24087
aS'    ScratchData_UQPH(const FiniteElement<dim> & fe_cell,'
p24088
aS'                     const QGauss<dim> &        qf_cell,'
p24089
aS'                     const UpdateFlags          uf_cell,'
p24090
aS'                     const BlockVector<double> &solution_total)'
p24091
aS'      : solution_total(solution_total)'
p24092
aS'      , solution_grads_u_total(qf_cell.size())'
p24093
aS'      , solution_values_p_total(qf_cell.size())'
p24094
aS'      , solution_values_J_total(qf_cell.size())'
p24095
aS'      , fe_values(fe_cell, qf_cell, uf_cell)'
p24096
aS'    {}'
p24097
aS'    ScratchData_UQPH(const ScratchData_UQPH &rhs)'
p24098
aS'      : solution_total(rhs.solution_total)'
p24099
aS'      , solution_grads_u_total(rhs.solution_grads_u_total)'
p24100
aS'      , solution_values_p_total(rhs.solution_values_p_total)'
p24101
aS'      , solution_values_J_total(rhs.solution_values_J_total)'
p24102
aS'      , fe_values(rhs.fe_values.get_fe(),'
p24103
aS'                  rhs.fe_values.get_quadrature(),'
p24104
aS'                  rhs.fe_values.get_update_flags())'
p24105
aS'    {}'
p24106
aS'    void reset()'
p24107
aS'    {'
p24108
aS'      const unsigned int n_q_points = solution_grads_u_total.size();'
p24109
aS'      for (unsigned int q = 0; q < n_q_points; ++q)'
p24110
aS'        {'
p24111
aS'          solution_grads_u_total[q]  = 0.0;'
p24112
aS'          solution_values_p_total[q] = 0.0;'
p24113
aS'          solution_values_J_total[q] = 0.0;'
p24114
aS'        }'
p24115
aS'    }'
p24116
aS'  };'
p24117
aS'  template <int dim>'
p24118
aS'  void Solid<dim>::make_grid()'
p24119
aS'  {'
p24120
aS'    GridGenerator::hyper_rectangle('
p24121
aS'      triangulation,'
p24122
aS'      (dim == 3 ? Point<dim>(0.0, 0.0, 0.0) : Point<dim>(0.0, 0.0)),'
p24123
aS'      (dim == 3 ? Point<dim>(1.0, 1.0, 1.0) : Point<dim>(1.0, 1.0)),'
p24124
aS'      true);'
p24125
aS'    GridTools::scale(parameters.scale, triangulation);'
p24126
aS'    triangulation.refine_global(std::max(1U, parameters.global_refinement));'
p24127
aS'    vol_reference = GridTools::volume(triangulation);'
p24128
aS'    std::cout << "Grid:\\n\\t Reference volume: " << vol_reference << std::endl;'
p24129
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p24130
aS'      for (const auto &face : cell->face_iterators())'
p24131
aS'        {'
p24132
aS'          if (face->at_boundary() == true &&'
p24133
aS'              face->center()[1] == 1.0 * parameters.scale)'
p24134
aS'            {'
p24135
aS'              if (dim == 3)'
p24136
aS'                {'
p24137
aS'                  if (face->center()[0] < 0.5 * parameters.scale &&'
p24138
aS'                      face->center()[2] < 0.5 * parameters.scale)'
p24139
aS'                    face->set_boundary_id(6);'
p24140
aS'                }'
p24141
aS'              else'
p24142
aS'                {'
p24143
aS'                  if (face->center()[0] < 0.5 * parameters.scale)'
p24144
aS'                    face->set_boundary_id(6);'
p24145
aS'                }'
p24146
aS'            }'
p24147
aS'        }'
p24148
aS'  }'
p24149
aS'  template <int dim>'
p24150
aS'  void Solid<dim>::system_setup()'
p24151
aS'  {'
p24152
aS'    timer.enter_subsection("Setup system");'
p24153
aS'    std::vector<unsigned int> block_component(n_components,'
p24154
aS'                                              u_dof); // Displacement'
p24155
aS'    block_component[p_component] = p_dof;             // Pressure'
p24156
aS'    block_component[J_component] = J_dof;             // Dilatation'
p24157
aS'    dof_handler.distribute_dofs(fe);'
p24158
aS'    DoFRenumbering::Cuthill_McKee(dof_handler);'
p24159
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p24160
aS'    dofs_per_block ='
p24161
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p24162
aS'    std::cout << "Triangulation:"'
p24163
aS'              << "\\n\\t Number of active cells: "'
p24164
aS'              << triangulation.n_active_cells()'
p24165
aS'              << "\\n\\t Number of degrees of freedom: " << dof_handler.n_dofs()'
p24166
aS'              << std::endl;'
p24167
aS'    tangent_matrix.clear();'
p24168
aS'    {'
p24169
aS'      const types::global_dof_index n_dofs_u = dofs_per_block[u_dof];'
p24170
aS'      const types::global_dof_index n_dofs_p = dofs_per_block[p_dof];'
p24171
aS'      const types::global_dof_index n_dofs_J = dofs_per_block[J_dof];'
p24172
aS'      BlockDynamicSparsityPattern dsp(n_blocks, n_blocks);'
p24173
aS'      dsp.block(u_dof, u_dof).reinit(n_dofs_u, n_dofs_u);'
p24174
aS'      dsp.block(u_dof, p_dof).reinit(n_dofs_u, n_dofs_p);'
p24175
aS'      dsp.block(u_dof, J_dof).reinit(n_dofs_u, n_dofs_J);'
p24176
aS'      dsp.block(p_dof, u_dof).reinit(n_dofs_p, n_dofs_u);'
p24177
aS'      dsp.block(p_dof, p_dof).reinit(n_dofs_p, n_dofs_p);'
p24178
aS'      dsp.block(p_dof, J_dof).reinit(n_dofs_p, n_dofs_J);'
p24179
aS'      dsp.block(J_dof, u_dof).reinit(n_dofs_J, n_dofs_u);'
p24180
aS'      dsp.block(J_dof, p_dof).reinit(n_dofs_J, n_dofs_p);'
p24181
aS'      dsp.block(J_dof, J_dof).reinit(n_dofs_J, n_dofs_J);'
p24182
aS'      dsp.collect_sizes();'
p24183
aS'      Table<2, DoFTools::Coupling> coupling(n_components, n_components);'
p24184
aS'      for (unsigned int ii = 0; ii < n_components; ++ii)'
p24185
aS'        for (unsigned int jj = 0; jj < n_components; ++jj)'
p24186
aS'          if (((ii < p_component) && (jj == J_component)) ||'
p24187
aS'              ((ii == J_component) && (jj < p_component)) ||'
p24188
aS'              ((ii == p_component) && (jj == p_component)))'
p24189
aS'            coupling[ii][jj] = DoFTools::none;'
p24190
aS'          else'
p24191
aS'            coupling[ii][jj] = DoFTools::always;'
p24192
aS'      DoFTools::make_sparsity_pattern('
p24193
aS'        dof_handler, coupling, dsp, constraints, false);'
p24194
aS'      sparsity_pattern.copy_from(dsp);'
p24195
aS'    }'
p24196
aS'    tangent_matrix.reinit(sparsity_pattern);'
p24197
aS'    system_rhs.reinit(dofs_per_block);'
p24198
aS'    system_rhs.collect_sizes();'
p24199
aS'    solution_n.reinit(dofs_per_block);'
p24200
aS'    solution_n.collect_sizes();'
p24201
aS'    setup_qph();'
p24202
aS'    timer.leave_subsection();'
p24203
aS'  }'
p24204
aS'  template <int dim>'
p24205
aS'  void Solid<dim>::determine_component_extractors()'
p24206
aS'  {'
p24207
aS'    element_indices_u.clear();'
p24208
aS'    element_indices_p.clear();'
p24209
aS'    element_indices_J.clear();'
p24210
aS'    for (unsigned int k = 0; k < fe.n_dofs_per_cell(); ++k)'
p24211
aS'      {'
p24212
aS'        const unsigned int k_group = fe.system_to_base_index(k).first.first;'
p24213
aS'        if (k_group == u_dof)'
p24214
aS'          element_indices_u.push_back(k);'
p24215
aS'        else if (k_group == p_dof)'
p24216
aS'          element_indices_p.push_back(k);'
p24217
aS'        else if (k_group == J_dof)'
p24218
aS'          element_indices_J.push_back(k);'
p24219
aS'        else'
p24220
aS'          {'
p24221
aS'            Assert(k_group <= J_dof, ExcInternalError());'
p24222
aS'          }'
p24223
aS'      }'
p24224
aS'  }'
p24225
aS'  template <int dim>'
p24226
aS'  void Solid<dim>::setup_qph()'
p24227
aS'  {'
p24228
aS'    std::cout << "    Setting up quadrature point data..." << std::endl;'
p24229
aS'    quadrature_point_history.initialize(triangulation.begin_active(),'
p24230
aS'                                        triangulation.end(),'
p24231
aS'                                        n_q_points);'
p24232
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p24233
aS'      {'
p24234
aS'        const std::vector<std::shared_ptr<PointHistory<dim>>> lqph ='
p24235
aS'          quadrature_point_history.get_data(cell);'
p24236
aS'        Assert(lqph.size() == n_q_points, ExcInternalError());'
p24237
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p24238
aS'          lqph[q_point]->setup_lqp(parameters);'
p24239
aS'      }'
p24240
aS'  }'
p24241
aS'  template <int dim>'
p24242
aS'  void'
p24243
aS'  Solid<dim>::update_qph_incremental(const BlockVector<double> &solution_delta)'
p24244
aS'  {'
p24245
aS'    timer.enter_subsection("Update QPH data");'
p24246
aS'    std::cout << " UQPH " << std::flush;'
p24247
aS'    const BlockVector<double> solution_total('
p24248
aS'      get_total_solution(solution_delta));'
p24249
aS'    const UpdateFlags uf_UQPH(update_values | update_gradients);'
p24250
aS'    PerTaskData_UQPH  per_task_data_UQPH;'
p24251
aS'    ScratchData_UQPH  scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);'
p24252
aS'    WorkStream::run(dof_handler.active_cell_iterators(),'
p24253
aS'                    *this,'
p24254
aS'                    &Solid::update_qph_incremental_one_cell,'
p24255
aS'                    &Solid::copy_local_to_global_UQPH,'
p24256
aS'                    scratch_data_UQPH,'
p24257
aS'                    per_task_data_UQPH);'
p24258
aS'    timer.leave_subsection();'
p24259
aS'  }'
p24260
aS'  template <int dim>'
p24261
aS'  void Solid<dim>::update_qph_incremental_one_cell('
p24262
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p24263
aS'    ScratchData_UQPH &                                    scratch,'
p24264
aS'    PerTaskData_UQPH & /*data*/)'
p24265
aS'  {'
p24266
aS'    const std::vector<std::shared_ptr<PointHistory<dim>>> lqph ='
p24267
aS'      quadrature_point_history.get_data(cell);'
p24268
aS'    Assert(lqph.size() == n_q_points, ExcInternalError());'
p24269
aS'    Assert(scratch.solution_grads_u_total.size() == n_q_points,'
p24270
aS'           ExcInternalError());'
p24271
aS'    Assert(scratch.solution_values_p_total.size() == n_q_points,'
p24272
aS'           ExcInternalError());'
p24273
aS'    Assert(scratch.solution_values_J_total.size() == n_q_points,'
p24274
aS'           ExcInternalError());'
p24275
aS'    scratch.reset();'
p24276
aS'    scratch.fe_values.reinit(cell);'
p24277
aS'    scratch.fe_values[u_fe].get_function_gradients('
p24278
aS'      scratch.solution_total, scratch.solution_grads_u_total);'
p24279
aS'    scratch.fe_values[p_fe].get_function_values('
p24280
aS'      scratch.solution_total, scratch.solution_values_p_total);'
p24281
aS'    scratch.fe_values[J_fe].get_function_values('
p24282
aS'      scratch.solution_total, scratch.solution_values_J_total);'
p24283
aS'    for (const unsigned int q_point :'
p24284
aS'         scratch.fe_values.quadrature_point_indices())'
p24285
aS'      lqph[q_point]->update_values(scratch.solution_grads_u_total[q_point],'
p24286
aS'                                   scratch.solution_values_p_total[q_point],'
p24287
aS'                                   scratch.solution_values_J_total[q_point]);'
p24288
aS'  }'
p24289
aS'  template <int dim>'
p24290
aS'  void Solid<dim>::solve_nonlinear_timestep(BlockVector<double> &solution_delta)'
p24291
aS'  {'
p24292
aS'    std::cout << std::endl'
p24293
aS'              << "Timestep " << time.get_timestep() << " @ " << time.current()'
p24294
aS'              << "s" << std::endl;'
p24295
aS'    BlockVector<double> newton_update(dofs_per_block);'
p24296
aS'    error_residual.reset();'
p24297
aS'    error_residual_0.reset();'
p24298
aS'    error_residual_norm.reset();'
p24299
aS'    error_update.reset();'
p24300
aS'    error_update_0.reset();'
p24301
aS'    error_update_norm.reset();'
p24302
aS'    print_conv_header();'
p24303
aS'    unsigned int newton_iteration = 0;'
p24304
aS'    for (; newton_iteration < parameters.max_iterations_NR; ++newton_iteration)'
p24305
aS'      {'
p24306
aS'        std::cout << " " << std::setw(2) << newton_iteration << " "'
p24307
aS'                  << std::flush;'
p24308
aS'        make_constraints(newton_iteration);'
p24309
aS'        assemble_system();'
p24310
aS'        get_error_residual(error_residual);'
p24311
aS'        if (newton_iteration == 0)'
p24312
aS'          error_residual_0 = error_residual;'
p24313
aS'        error_residual_norm = error_residual;'
p24314
aS'        error_residual_norm.normalize(error_residual_0);'
p24315
aS'        if (newton_iteration > 0 && error_update_norm.u <= parameters.tol_u &&'
p24316
aS'            error_residual_norm.u <= parameters.tol_f)'
p24317
aS'          {'
p24318
aS'            std::cout << " CONVERGED! " << std::endl;'
p24319
aS'            print_conv_footer();'
p24320
aS'            break;'
p24321
aS'          }'
p24322
aS'        const std::pair<unsigned int, double> lin_solver_output ='
p24323
aS'          solve_linear_system(newton_update);'
p24324
aS'        get_error_update(newton_update, error_update);'
p24325
aS'        if (newton_iteration == 0)'
p24326
aS'          error_update_0 = error_update;'
p24327
aS'        error_update_norm = error_update;'
p24328
aS'        error_update_norm.normalize(error_update_0);'
p24329
aS'        solution_delta += newton_update;'
p24330
aS'        update_qph_incremental(solution_delta);'
p24331
aS'        std::cout << " | " << std::fixed << std::setprecision(3) << std::setw(7)'
p24332
aS'                  << std::scientific << lin_solver_output.first << "  "'
p24333
aS'                  << lin_solver_output.second << "  "'
p24334
aS'                  << error_residual_norm.norm << "  " << error_residual_norm.u'
p24335
aS'                  << "  " << error_residual_norm.p << "  "'
p24336
aS'                  << error_residual_norm.J << "  " << error_update_norm.norm'
p24337
aS'                  << "  " << error_update_norm.u << "  " << error_update_norm.p'
p24338
aS'                  << "  " << error_update_norm.J << "  " << std::endl;'
p24339
aS'      }'
p24340
aS'    AssertThrow(newton_iteration < parameters.max_iterations_NR,'
p24341
aS'                ExcMessage("No convergence in nonlinear solver!"));'
p24342
aS'  }'
p24343
aS'  template <int dim>'
p24344
aS'  void Solid<dim>::print_conv_header()'
p24345
aS'  {'
p24346
aS'    static const unsigned int l_width = 150;'
p24347
aS'    for (unsigned int i = 0; i < l_width; ++i)'
p24348
aS'      std::cout << "_";'
p24349
aS'    std::cout << std::endl;'
p24350
aS'    std::cout << "               SOLVER STEP               "'
p24351
aS'              << " |  LIN_IT   LIN_RES    RES_NORM    "'
p24352
aS'              << " RES_U     RES_P      RES_J     NU_NORM     "'
p24353
aS'              << " NU_U       NU_P       NU_J " << std::endl;'
p24354
aS'    for (unsigned int i = 0; i < l_width; ++i)'
p24355
aS'      std::cout << "_";'
p24356
aS'    std::cout << std::endl;'
p24357
aS'  }'
p24358
aS'  template <int dim>'
p24359
aS'  void Solid<dim>::print_conv_footer()'
p24360
aS'  {'
p24361
aS'    static const unsigned int l_width = 150;'
p24362
aS'    for (unsigned int i = 0; i < l_width; ++i)'
p24363
aS'      std::cout << "_";'
p24364
aS'    std::cout << std::endl;'
p24365
aS'    const std::pair<double, double> error_dil = get_error_dilation();'
p24366
aS'    std::cout << "Relative errors:" << std::endl'
p24367
aS'              << "Displacement:\\t" << error_update.u / error_update_0.u'
p24368
aS'              << std::endl'
p24369
aS'              << "Force: \\t\\t" << error_residual.u / error_residual_0.u'
p24370
aS'              << std::endl'
p24371
aS'              << "Dilatation:\\t" << error_dil.first << std::endl'
p24372
aS'              << "v / V_0:\\t" << error_dil.second * vol_reference << " / "'
p24373
aS'              << vol_reference << " = " << error_dil.second << std::endl;'
p24374
aS'  }'
p24375
aS'  template <int dim>'
p24376
aS'  double Solid<dim>::compute_vol_current() const'
p24377
aS'  {'
p24378
aS'    double vol_current = 0.0;'
p24379
aS'    FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);'
p24380
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p24381
aS'      {'
p24382
aS'        fe_values.reinit(cell);'
p24383
aS'        const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph ='
p24384
aS'          quadrature_point_history.get_data(cell);'
p24385
aS'        Assert(lqph.size() == n_q_points, ExcInternalError());'
p24386
aS'        for (const unsigned int q_point : fe_values.quadrature_point_indices())'
p24387
aS'          {'
p24388
aS'            const double det_F_qp = lqph[q_point]->get_det_F();'
p24389
aS'            const double JxW      = fe_values.JxW(q_point);'
p24390
aS'            vol_current += det_F_qp * JxW;'
p24391
aS'          }'
p24392
aS'      }'
p24393
aS'    Assert(vol_current > 0.0, ExcInternalError());'
p24394
aS'    return vol_current;'
p24395
aS'  }'
p24396
aS'  template <int dim>'
p24397
aS'  std::pair<double, double> Solid<dim>::get_error_dilation() const'
p24398
aS'  {'
p24399
aS'    double dil_L2_error = 0.0;'
p24400
aS'    FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);'
p24401
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p24402
aS'      {'
p24403
aS'        fe_values.reinit(cell);'
p24404
aS'        const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph ='
p24405
aS'          quadrature_point_history.get_data(cell);'
p24406
aS'        Assert(lqph.size() == n_q_points, ExcInternalError());'
p24407
aS'        for (const unsigned int q_point : fe_values.quadrature_point_indices())'
p24408
aS'          {'
p24409
aS'            const double det_F_qp   = lqph[q_point]->get_det_F();'
p24410
aS'            const double J_tilde_qp = lqph[q_point]->get_J_tilde();'
p24411
aS'            const double the_error_qp_squared ='
p24412
aS'              std::pow((det_F_qp - J_tilde_qp), 2);'
p24413
aS'            const double JxW = fe_values.JxW(q_point);'
p24414
aS'            dil_L2_error += the_error_qp_squared * JxW;'
p24415
aS'          }'
p24416
aS'      }'
p24417
aS'    return std::make_pair(std::sqrt(dil_L2_error),'
p24418
aS'                          compute_vol_current() / vol_reference);'
p24419
aS'  }'
p24420
aS'  template <int dim>'
p24421
aS'  void Solid<dim>::get_error_residual(Errors &error_residual)'
p24422
aS'  {'
p24423
aS'    BlockVector<double> error_res(dofs_per_block);'
p24424
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p24425
aS'      if (!constraints.is_constrained(i))'
p24426
aS'        error_res(i) = system_rhs(i);'
p24427
aS'    error_residual.norm = error_res.l2_norm();'
p24428
aS'    error_residual.u    = error_res.block(u_dof).l2_norm();'
p24429
aS'    error_residual.p    = error_res.block(p_dof).l2_norm();'
p24430
aS'    error_residual.J    = error_res.block(J_dof).l2_norm();'
p24431
aS'  }'
p24432
aS'  template <int dim>'
p24433
aS'  void Solid<dim>::get_error_update(const BlockVector<double> &newton_update,'
p24434
aS'                                    Errors &                   error_update)'
p24435
aS'  {'
p24436
aS'    BlockVector<double> error_ud(dofs_per_block);'
p24437
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p24438
aS'      if (!constraints.is_constrained(i))'
p24439
aS'        error_ud(i) = newton_update(i);'
p24440
aS'    error_update.norm = error_ud.l2_norm();'
p24441
aS'    error_update.u    = error_ud.block(u_dof).l2_norm();'
p24442
aS'    error_update.p    = error_ud.block(p_dof).l2_norm();'
p24443
aS'    error_update.J    = error_ud.block(J_dof).l2_norm();'
p24444
aS'  }'
p24445
aS'  template <int dim>'
p24446
aS'  BlockVector<double> Solid<dim>::get_total_solution('
p24447
aS'    const BlockVector<double> &solution_delta) const'
p24448
aS'  {'
p24449
aS'    BlockVector<double> solution_total(solution_n);'
p24450
aS'    solution_total += solution_delta;'
p24451
aS'    return solution_total;'
p24452
aS'  }'
p24453
aS'  template <int dim>'
p24454
aS'  void Solid<dim>::assemble_system()'
p24455
aS'  {'
p24456
aS'    timer.enter_subsection("Assemble system");'
p24457
aS'    std::cout << " ASM_SYS " << std::flush;'
p24458
aS'    tangent_matrix = 0.0;'
p24459
aS'    system_rhs     = 0.0;'
p24460
aS'    const UpdateFlags uf_cell(update_values | update_gradients |'
p24461
aS'                              update_JxW_values);'
p24462
aS'    const UpdateFlags uf_face(update_values | update_normal_vectors |'
p24463
aS'                              update_JxW_values);'
p24464
aS'    PerTaskData_ASM per_task_data(dofs_per_cell);'
p24465
aS'    ScratchData_ASM scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);'
p24466
aS'    WorkStream::run('
p24467
aS'      dof_handler.active_cell_iterators(),'
p24468
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p24469
aS'             ScratchData_ASM &                                     scratch,'
p24470
aS'             PerTaskData_ASM &                                     data) {'
p24471
aS'        this->assemble_system_one_cell(cell, scratch, data);'
p24472
aS'      },'
p24473
aS'      [this](const PerTaskData_ASM &data) {'
p24474
aS'        this->constraints.distribute_local_to_global(data.cell_matrix,'
p24475
aS'                                                     data.cell_rhs,'
p24476
aS'                                                     data.local_dof_indices,'
p24477
aS'                                                     tangent_matrix,'
p24478
aS'                                                     system_rhs);'
p24479
aS'      },'
p24480
aS'      scratch_data,'
p24481
aS'      per_task_data);'
p24482
aS'    timer.leave_subsection();'
p24483
aS'  }'
p24484
aS'  template <int dim>'
p24485
aS'  void Solid<dim>::assemble_system_one_cell('
p24486
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p24487
aS'    ScratchData_ASM &                                     scratch,'
p24488
aS'    PerTaskData_ASM &                                     data) const'
p24489
aS'  {'
p24490
aS'    data.reset();'
p24491
aS'    scratch.reset();'
p24492
aS'    scratch.fe_values.reinit(cell);'
p24493
aS'    cell->get_dof_indices(data.local_dof_indices);'
p24494
aS'    const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph ='
p24495
aS'      quadrature_point_history.get_data(cell);'
p24496
aS'    Assert(lqph.size() == n_q_points, ExcInternalError());'
p24497
aS'    for (const unsigned int q_point :'
p24498
aS'         scratch.fe_values.quadrature_point_indices())'
p24499
aS'      {'
p24500
aS'        const Tensor<2, dim> F_inv = lqph[q_point]->get_F_inv();'
p24501
aS'        for (const unsigned int k : scratch.fe_values.dof_indices())'
p24502
aS'          {'
p24503
aS'            const unsigned int k_group = fe.system_to_base_index(k).first.first;'
p24504
aS'            if (k_group == u_dof)'
p24505
aS'              {'
p24506
aS'                scratch.grad_Nx[q_point][k] ='
p24507
aS'                  scratch.fe_values[u_fe].gradient(k, q_point) * F_inv;'
p24508
aS'                scratch.symm_grad_Nx[q_point][k] ='
p24509
aS'                  symmetrize(scratch.grad_Nx[q_point][k]);'
p24510
aS'              }'
p24511
aS'            else if (k_group == p_dof)'
p24512
aS'              scratch.Nx[q_point][k] ='
p24513
aS'                scratch.fe_values[p_fe].value(k, q_point);'
p24514
aS'            else if (k_group == J_dof)'
p24515
aS'              scratch.Nx[q_point][k] ='
p24516
aS'                scratch.fe_values[J_fe].value(k, q_point);'
p24517
aS'            else'
p24518
aS'              Assert(k_group <= J_dof, ExcInternalError());'
p24519
aS'          }'
p24520
aS'      }'
p24521
aS'    for (const unsigned int q_point :'
p24522
aS'         scratch.fe_values.quadrature_point_indices())'
p24523
aS'      {'
p24524
aS'        const SymmetricTensor<2, dim> tau     = lqph[q_point]->get_tau();'
p24525
aS'        const Tensor<2, dim>          tau_ns  = lqph[q_point]->get_tau();'
p24526
aS'        const SymmetricTensor<4, dim> Jc      = lqph[q_point]->get_Jc();'
p24527
aS'        const double                  det_F   = lqph[q_point]->get_det_F();'
p24528
aS'        const double                  p_tilde = lqph[q_point]->get_p_tilde();'
p24529
aS'        const double                  J_tilde = lqph[q_point]->get_J_tilde();'
p24530
aS'        const double dPsi_vol_dJ   = lqph[q_point]->get_dPsi_vol_dJ();'
p24531
aS'        const double d2Psi_vol_dJ2 = lqph[q_point]->get_d2Psi_vol_dJ2();'
p24532
aS'        const SymmetricTensor<2, dim> &I ='
p24533
aS'          Physics::Elasticity::StandardTensors<dim>::I;'
p24534
aS'        SymmetricTensor<2, dim> symm_grad_Nx_i_x_Jc;'
p24535
aS'        Tensor<1, dim>          grad_Nx_i_comp_i_x_tau;'
p24536
aS'        const std::vector<double> &                 N = scratch.Nx[q_point];'
p24537
aS'        const std::vector<SymmetricTensor<2, dim>> &symm_grad_Nx ='
p24538
aS'          scratch.symm_grad_Nx[q_point];'
p24539
aS'        const std::vector<Tensor<2, dim>> &grad_Nx = scratch.grad_Nx[q_point];'
p24540
aS'        const double                       JxW = scratch.fe_values.JxW(q_point);'
p24541
aS'        for (const unsigned int i : scratch.fe_values.dof_indices())'
p24542
aS'          {'
p24543
aS'            const unsigned int component_i ='
p24544
aS'              fe.system_to_component_index(i).first;'
p24545
aS'            const unsigned int i_group = fe.system_to_base_index(i).first.first;'
p24546
aS'            if (i_group == u_dof)'
p24547
aS'              data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;'
p24548
aS'            else if (i_group == p_dof)'
p24549
aS'              data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW;'
p24550
aS'            else if (i_group == J_dof)'
p24551
aS'              data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW;'
p24552
aS'            else'
p24553
aS'              Assert(i_group <= J_dof, ExcInternalError());'
p24554
aS'            if (i_group == u_dof)'
p24555
aS'              {'
p24556
aS'                symm_grad_Nx_i_x_Jc    = symm_grad_Nx[i] * Jc;'
p24557
aS'                grad_Nx_i_comp_i_x_tau = grad_Nx[i][component_i] * tau_ns;'
p24558
aS'              }'
p24559
aS'            for (const unsigned int j :'
p24560
aS'                 scratch.fe_values.dof_indices_ending_at(i))'
p24561
aS'              {'
p24562
aS'                const unsigned int component_j ='
p24563
aS'                  fe.system_to_component_index(j).first;'
p24564
aS'                const unsigned int j_group ='
p24565
aS'                  fe.system_to_base_index(j).first.first;'
p24566
aS'                if ((i_group == j_group) && (i_group == u_dof))'
p24567
aS'                  {'
p24568
aS'                    data.cell_matrix(i, j) += symm_grad_Nx_i_x_Jc *  //'
p24569
aS'                                              symm_grad_Nx[j] * JxW; //'
p24570
aS'                    if (component_i == component_j)'
p24571
aS'                      data.cell_matrix(i, j) +='
p24572
aS'                        grad_Nx_i_comp_i_x_tau * grad_Nx[j][component_j] * JxW;'
p24573
aS'                  }'
p24574
aS'                else if ((i_group == p_dof) && (j_group == u_dof))'
p24575
aS'                  {'
p24576
aS'                    data.cell_matrix(i, j) += N[i] * det_F *               //'
p24577
aS'                                              (symm_grad_Nx[j] * I) * JxW; //'
p24578
aS'                  }'
p24579
aS'                else if ((i_group == J_dof) && (j_group == p_dof))'
p24580
aS'                  data.cell_matrix(i, j) -= N[i] * N[j] * JxW;'
p24581
aS'                else if ((i_group == j_group) && (i_group == J_dof))'
p24582
aS'                  data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW;'
p24583
aS'                else'
p24584
aS'                  Assert((i_group <= J_dof) && (j_group <= J_dof),'
p24585
aS'                         ExcInternalError());'
p24586
aS'              }'
p24587
aS'          }'
p24588
aS'      }'
p24589
aS'    for (const auto &face : cell->face_iterators())'
p24590
aS'      if (face->at_boundary() && face->boundary_id() == 6)'
p24591
aS'        {'
p24592
aS'          scratch.fe_face_values.reinit(cell, face);'
p24593
aS'          for (const unsigned int f_q_point :'
p24594
aS'               scratch.fe_face_values.quadrature_point_indices())'
p24595
aS'            {'
p24596
aS'              const Tensor<1, dim> &N ='
p24597
aS'                scratch.fe_face_values.normal_vector(f_q_point);'
p24598
aS'              static const double p0 ='
p24599
aS'                -4.0 / (parameters.scale * parameters.scale);'
p24600
aS'              const double         time_ramp = (time.current() / time.end());'
p24601
aS'              const double         pressure  = p0 * parameters.p_p0 * time_ramp;'
p24602
aS'              const Tensor<1, dim> traction  = pressure * N;'
p24603
aS'              for (const unsigned int i : scratch.fe_values.dof_indices())'
p24604
aS'                {'
p24605
aS'                  const unsigned int i_group ='
p24606
aS'                    fe.system_to_base_index(i).first.first;'
p24607
aS'                  if (i_group == u_dof)'
p24608
aS'                    {'
p24609
aS'                      const unsigned int component_i ='
p24610
aS'                        fe.system_to_component_index(i).first;'
p24611
aS'                      const double Ni ='
p24612
aS'                        scratch.fe_face_values.shape_value(i, f_q_point);'
p24613
aS'                      const double JxW = scratch.fe_face_values.JxW(f_q_point);'
p24614
aS'                      data.cell_rhs(i) += (Ni * traction[component_i]) * JxW;'
p24615
aS'                    }'
p24616
aS'                }'
p24617
aS'            }'
p24618
aS'        }'
p24619
aS'    for (const unsigned int i : scratch.fe_values.dof_indices())'
p24620
aS'      for (const unsigned int j :'
p24621
aS'           scratch.fe_values.dof_indices_starting_at(i + 1))'
p24622
aS'        data.cell_matrix(i, j) = data.cell_matrix(j, i);'
p24623
aS'  }'
p24624
aS'  template <int dim>'
p24625
aS'  void Solid<dim>::make_constraints(const int it_nr)'
p24626
aS'  {'
p24627
aS'    const bool apply_dirichlet_bc = (it_nr == 0);'
p24628
aS'    if (it_nr > 1)'
p24629
aS'      {'
p24630
aS'        std::cout << " --- " << std::flush;'
p24631
aS'        return;'
p24632
aS'      }'
p24633
aS'    std::cout << " CST " << std::flush;'
p24634
aS'    if (apply_dirichlet_bc)'
p24635
aS'      {'
p24636
aS'        constraints.clear();'
p24637
aS'        const FEValuesExtractors::Scalar x_displacement(0);'
p24638
aS'        const FEValuesExtractors::Scalar y_displacement(1);'
p24639
aS'        {'
p24640
aS'          const int boundary_id = 0;'
p24641
aS'          VectorTools::interpolate_boundary_values('
p24642
aS'            dof_handler,'
p24643
aS'            boundary_id,'
p24644
aS'            Functions::ZeroFunction<dim>(n_components),'
p24645
aS'            constraints,'
p24646
aS'            fe.component_mask(x_displacement));'
p24647
aS'        }'
p24648
aS'        {'
p24649
aS'          const int boundary_id = 2;'
p24650
aS'          VectorTools::interpolate_boundary_values('
p24651
aS'            dof_handler,'
p24652
aS'            boundary_id,'
p24653
aS'            Functions::ZeroFunction<dim>(n_components),'
p24654
aS'            constraints,'
p24655
aS'            fe.component_mask(y_displacement));'
p24656
aS'        }'
p24657
aS'        if (dim == 3)'
p24658
aS'          {'
p24659
aS'            const FEValuesExtractors::Scalar z_displacement(2);'
p24660
aS'            {'
p24661
aS'              const int boundary_id = 3;'
p24662
aS'              VectorTools::interpolate_boundary_values('
p24663
aS'                dof_handler,'
p24664
aS'                boundary_id,'
p24665
aS'                Functions::ZeroFunction<dim>(n_components),'
p24666
aS'                constraints,'
p24667
aS'                (fe.component_mask(x_displacement) |'
p24668
aS'                 fe.component_mask(z_displacement)));'
p24669
aS'            }'
p24670
aS'            {'
p24671
aS'              const int boundary_id = 4;'
p24672
aS'              VectorTools::interpolate_boundary_values('
p24673
aS'                dof_handler,'
p24674
aS'                boundary_id,'
p24675
aS'                Functions::ZeroFunction<dim>(n_components),'
p24676
aS'                constraints,'
p24677
aS'                fe.component_mask(z_displacement));'
p24678
aS'            }'
p24679
aS'            {'
p24680
aS'              const int boundary_id = 6;'
p24681
aS'              VectorTools::interpolate_boundary_values('
p24682
aS'                dof_handler,'
p24683
aS'                boundary_id,'
p24684
aS'                Functions::ZeroFunction<dim>(n_components),'
p24685
aS'                constraints,'
p24686
aS'                (fe.component_mask(x_displacement) |'
p24687
aS'                 fe.component_mask(z_displacement)));'
p24688
aS'            }'
p24689
aS'          }'
p24690
aS'        else'
p24691
aS'          {'
p24692
aS'            {'
p24693
aS'              const int boundary_id = 3;'
p24694
aS'              VectorTools::interpolate_boundary_values('
p24695
aS'                dof_handler,'
p24696
aS'                boundary_id,'
p24697
aS'                Functions::ZeroFunction<dim>(n_components),'
p24698
aS'                constraints,'
p24699
aS'                (fe.component_mask(x_displacement)));'
p24700
aS'            }'
p24701
aS'            {'
p24702
aS'              const int boundary_id = 6;'
p24703
aS'              VectorTools::interpolate_boundary_values('
p24704
aS'                dof_handler,'
p24705
aS'                boundary_id,'
p24706
aS'                Functions::ZeroFunction<dim>(n_components),'
p24707
aS'                constraints,'
p24708
aS'                (fe.component_mask(x_displacement)));'
p24709
aS'            }'
p24710
aS'          }'
p24711
aS'      }'
p24712
aS'    else'
p24713
aS'      {'
p24714
aS'        if (constraints.has_inhomogeneities())'
p24715
aS'          {'
p24716
aS'            AffineConstraints<double> homogeneous_constraints(constraints);'
p24717
aS'            for (unsigned int dof = 0; dof != dof_handler.n_dofs(); ++dof)'
p24718
aS'              if (homogeneous_constraints.is_inhomogeneously_constrained(dof))'
p24719
aS'                homogeneous_constraints.set_inhomogeneity(dof, 0.0);'
p24720
aS'            constraints.clear();'
p24721
aS'            constraints.copy_from(homogeneous_constraints);'
p24722
aS'          }'
p24723
aS'      }'
p24724
aS'    constraints.close();'
p24725
aS'  }'
p24726
aS'  template <int dim>'
p24727
aS'  void Solid<dim>::assemble_sc()'
p24728
aS'  {'
p24729
aS'    timer.enter_subsection("Perform static condensation");'
p24730
aS'    std::cout << " ASM_SC " << std::flush;'
p24731
aS'    PerTaskData_SC per_task_data(dofs_per_cell,'
p24732
aS'                                 element_indices_u.size(),'
p24733
aS'                                 element_indices_p.size(),'
p24734
aS'                                 element_indices_J.size());'
p24735
aS'    ScratchData_SC scratch_data;'
p24736
aS'    WorkStream::run(dof_handler.active_cell_iterators(),'
p24737
aS'                    *this,'
p24738
aS'                    &Solid::assemble_sc_one_cell,'
p24739
aS'                    &Solid::copy_local_to_global_sc,'
p24740
aS'                    scratch_data,'
p24741
aS'                    per_task_data);'
p24742
aS'    timer.leave_subsection();'
p24743
aS'  }'
p24744
aS'  template <int dim>'
p24745
aS'  void Solid<dim>::copy_local_to_global_sc(const PerTaskData_SC &data)'
p24746
aS'  {'
p24747
aS'    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p24748
aS'      for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p24749
aS'        tangent_matrix.add(data.local_dof_indices[i],'
p24750
aS'                           data.local_dof_indices[j],'
p24751
aS'                           data.cell_matrix(i, j));'
p24752
aS'  }'
p24753
aS'  template <int dim>'
p24754
aS'  void Solid<dim>::assemble_sc_one_cell('
p24755
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p24756
aS'    ScratchData_SC &                                      scratch,'
p24757
aS'    PerTaskData_SC &                                      data)'
p24758
aS'  {'
p24759
aS'    data.reset();'
p24760
aS'    scratch.reset();'
p24761
aS'    cell->get_dof_indices(data.local_dof_indices);'
p24762
aS'    data.k_orig.extract_submatrix_from(tangent_matrix,'
p24763
aS'                                       data.local_dof_indices,'
p24764
aS'                                       data.local_dof_indices);'
p24765
aS'    data.k_pu.extract_submatrix_from(data.k_orig,'
p24766
aS'                                     element_indices_p,'
p24767
aS'                                     element_indices_u);'
p24768
aS'    data.k_pJ.extract_submatrix_from(data.k_orig,'
p24769
aS'                                     element_indices_p,'
p24770
aS'                                     element_indices_J);'
p24771
aS'    data.k_JJ.extract_submatrix_from(data.k_orig,'
p24772
aS'                                     element_indices_J,'
p24773
aS'                                     element_indices_J);'
p24774
aS'    data.k_pJ_inv.invert(data.k_pJ);'
p24775
aS'    data.k_pJ_inv.mmult(data.A, data.k_pu);'
p24776
aS'    data.k_JJ.mmult(data.B, data.A);'
p24777
aS'    data.k_pJ_inv.Tmmult(data.C, data.B);'
p24778
aS'    data.k_pu.Tmmult(data.k_bbar, data.C);'
p24779
aS'    data.k_bbar.scatter_matrix_to(element_indices_u,'
p24780
aS'                                  element_indices_u,'
p24781
aS'                                  data.cell_matrix);'
p24782
aS'    data.k_pJ_inv.add(-1.0, data.k_pJ);'
p24783
aS'    data.k_pJ_inv.scatter_matrix_to(element_indices_p,'
p24784
aS'                                    element_indices_J,'
p24785
aS'                                    data.cell_matrix);'
p24786
aS'  }'
p24787
aS'  template <int dim>'
p24788
aS'  std::pair<unsigned int, double>'
p24789
aS'  Solid<dim>::solve_linear_system(BlockVector<double> &newton_update)'
p24790
aS'  {'
p24791
aS'    unsigned int lin_it  = 0;'
p24792
aS'    double       lin_res = 0.0;'
p24793
aS'    if (parameters.use_static_condensation == true)'
p24794
aS'      {'
p24795
aS'        BlockVector<double> A(dofs_per_block);'
p24796
aS'        BlockVector<double> B(dofs_per_block);'
p24797
aS'        {'
p24798
aS'          assemble_sc();'
p24799
aS'          tangent_matrix.block(p_dof, J_dof)'
p24800
aS'            .vmult(A.block(J_dof), system_rhs.block(p_dof));'
p24801
aS'          tangent_matrix.block(J_dof, J_dof)'
p24802
aS'            .vmult(B.block(J_dof), A.block(J_dof));'
p24803
aS'          A.block(J_dof) = system_rhs.block(J_dof);'
p24804
aS'          A.block(J_dof) -= B.block(J_dof);'
p24805
aS'          tangent_matrix.block(p_dof, J_dof)'
p24806
aS'            .Tvmult(A.block(p_dof), A.block(J_dof));'
p24807
aS'          tangent_matrix.block(u_dof, p_dof)'
p24808
aS'            .vmult(A.block(u_dof), A.block(p_dof));'
p24809
aS'          system_rhs.block(u_dof) -= A.block(u_dof);'
p24810
aS'          timer.enter_subsection("Linear solver");'
p24811
aS'          std::cout << " SLV " << std::flush;'
p24812
aS'          if (parameters.type_lin == "CG")'
p24813
aS'            {'
p24814
aS'              const auto solver_its = static_cast<unsigned int>('
p24815
aS'                tangent_matrix.block(u_dof, u_dof).m() *'
p24816
aS'                parameters.max_iterations_lin);'
p24817
aS'              const double tol_sol ='
p24818
aS'                parameters.tol_lin * system_rhs.block(u_dof).l2_norm();'
p24819
aS'              SolverControl solver_control(solver_its, tol_sol);'
p24820
aS'              GrowingVectorMemory<Vector<double>> GVM;'
p24821
aS'              SolverCG<Vector<double>> solver_CG(solver_control, GVM);'
p24822
aS'              PreconditionSelector<SparseMatrix<double>, Vector<double>>'
p24823
aS'                preconditioner(parameters.preconditioner_type,'
p24824
aS'                               parameters.preconditioner_relaxation);'
p24825
aS'              preconditioner.use_matrix(tangent_matrix.block(u_dof, u_dof));'
p24826
aS'              solver_CG.solve(tangent_matrix.block(u_dof, u_dof),'
p24827
aS'                              newton_update.block(u_dof),'
p24828
aS'                              system_rhs.block(u_dof),'
p24829
aS'                              preconditioner);'
p24830
aS'              lin_it  = solver_control.last_step();'
p24831
aS'              lin_res = solver_control.last_value();'
p24832
aS'            }'
p24833
aS'          else if (parameters.type_lin == "Direct")'
p24834
aS'            {'
p24835
aS'              SparseDirectUMFPACK A_direct;'
p24836
aS'              A_direct.initialize(tangent_matrix.block(u_dof, u_dof));'
p24837
aS'              A_direct.vmult(newton_update.block(u_dof),'
p24838
aS'                             system_rhs.block(u_dof));'
p24839
aS'              lin_it  = 1;'
p24840
aS'              lin_res = 0.0;'
p24841
aS'            }'
p24842
aS'          else'
p24843
aS'            Assert(false, ExcMessage("Linear solver type not implemented"));'
p24844
aS'          timer.leave_subsection();'
p24845
aS'        }'
p24846
aS'        constraints.distribute(newton_update);'
p24847
aS'        timer.enter_subsection("Linear solver postprocessing");'
p24848
aS'        std::cout << " PP " << std::flush;'
p24849
aS'        {'
p24850
aS'          tangent_matrix.block(p_dof, u_dof)'
p24851
aS'            .vmult(A.block(p_dof), newton_update.block(u_dof));'
p24852
aS'          A.block(p_dof) *= -1.0;'
p24853
aS'          A.block(p_dof) += system_rhs.block(p_dof);'
p24854
aS'          tangent_matrix.block(p_dof, J_dof)'
p24855
aS'            .vmult(newton_update.block(J_dof), A.block(p_dof));'
p24856
aS'        }'
p24857
aS'        constraints.distribute(newton_update);'
p24858
aS'        {'
p24859
aS'          tangent_matrix.block(J_dof, J_dof)'
p24860
aS'            .vmult(A.block(J_dof), newton_update.block(J_dof));'
p24861
aS'          A.block(J_dof) *= -1.0;'
p24862
aS'          A.block(J_dof) += system_rhs.block(J_dof);'
p24863
aS'          tangent_matrix.block(p_dof, J_dof)'
p24864
aS'            .Tvmult(newton_update.block(p_dof), A.block(J_dof));'
p24865
aS'        }'
p24866
aS'        constraints.distribute(newton_update);'
p24867
aS'        timer.leave_subsection();'
p24868
aS'      }'
p24869
aS'    else'
p24870
aS'      {'
p24871
aS'        std::cout << " ------ " << std::flush;'
p24872
aS'        timer.enter_subsection("Linear solver");'
p24873
aS'        std::cout << " SLV " << std::flush;'
p24874
aS'        if (parameters.type_lin == "CG")'
p24875
aS'          {'
p24876
aS'            const Vector<double> &f_u = system_rhs.block(u_dof);'
p24877
aS'            const Vector<double> &f_p = system_rhs.block(p_dof);'
p24878
aS'            const Vector<double> &f_J = system_rhs.block(J_dof);'
p24879
aS'            Vector<double> &d_u = newton_update.block(u_dof);'
p24880
aS'            Vector<double> &d_p = newton_update.block(p_dof);'
p24881
aS'            Vector<double> &d_J = newton_update.block(J_dof);'
p24882
aS'            const auto K_uu ='
p24883
aS'              linear_operator(tangent_matrix.block(u_dof, u_dof));'
p24884
aS'            const auto K_up ='
p24885
aS'              linear_operator(tangent_matrix.block(u_dof, p_dof));'
p24886
aS'            const auto K_pu ='
p24887
aS'              linear_operator(tangent_matrix.block(p_dof, u_dof));'
p24888
aS'            const auto K_Jp ='
p24889
aS'              linear_operator(tangent_matrix.block(J_dof, p_dof));'
p24890
aS'            const auto K_JJ ='
p24891
aS'              linear_operator(tangent_matrix.block(J_dof, J_dof));'
p24892
aS'            PreconditionSelector<SparseMatrix<double>, Vector<double>>'
p24893
aS'              preconditioner_K_Jp_inv("jacobi");'
p24894
aS'            preconditioner_K_Jp_inv.use_matrix('
p24895
aS'              tangent_matrix.block(J_dof, p_dof));'
p24896
aS'            ReductionControl solver_control_K_Jp_inv('
p24897
aS'              static_cast<unsigned int>(tangent_matrix.block(J_dof, p_dof).m() *'
p24898
aS'                                        parameters.max_iterations_lin),'
p24899
aS'              1.0e-30,'
p24900
aS'              parameters.tol_lin);'
p24901
aS'            SolverSelector<Vector<double>> solver_K_Jp_inv;'
p24902
aS'            solver_K_Jp_inv.select("cg");'
p24903
aS'            solver_K_Jp_inv.set_control(solver_control_K_Jp_inv);'
p24904
aS'            const auto K_Jp_inv ='
p24905
aS'              inverse_operator(K_Jp, solver_K_Jp_inv, preconditioner_K_Jp_inv);'
p24906
aS'            const auto K_pJ_inv     = transpose_operator(K_Jp_inv);'
p24907
aS'            const auto K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv;'
p24908
aS'            const auto K_uu_bar_bar = K_up * K_pp_bar * K_pu;'
p24909
aS'            const auto K_uu_con     = K_uu + K_uu_bar_bar;'
p24910
aS'            PreconditionSelector<SparseMatrix<double>, Vector<double>>'
p24911
aS'              preconditioner_K_con_inv(parameters.preconditioner_type,'
p24912
aS'                                       parameters.preconditioner_relaxation);'
p24913
aS'            preconditioner_K_con_inv.use_matrix('
p24914
aS'              tangent_matrix.block(u_dof, u_dof));'
p24915
aS'            ReductionControl solver_control_K_con_inv('
p24916
aS'              static_cast<unsigned int>(tangent_matrix.block(u_dof, u_dof).m() *'
p24917
aS'                                        parameters.max_iterations_lin),'
p24918
aS'              1.0e-30,'
p24919
aS'              parameters.tol_lin);'
p24920
aS'            SolverSelector<Vector<double>> solver_K_con_inv;'
p24921
aS'            solver_K_con_inv.select("cg");'
p24922
aS'            solver_K_con_inv.set_control(solver_control_K_con_inv);'
p24923
aS'            const auto K_uu_con_inv ='
p24924
aS'              inverse_operator(K_uu_con,'
p24925
aS'                               solver_K_con_inv,'
p24926
aS'                               preconditioner_K_con_inv);'
p24927
aS'            d_u ='
p24928
aS'              K_uu_con_inv * (f_u - K_up * (K_Jp_inv * f_J - K_pp_bar * f_p));'
p24929
aS'            timer.leave_subsection();'
p24930
aS'            timer.enter_subsection("Linear solver postprocessing");'
p24931
aS'            std::cout << " PP " << std::flush;'
p24932
aS'            d_J = K_pJ_inv * (f_p - K_pu * d_u);'
p24933
aS'            d_p = K_Jp_inv * (f_J - K_JJ * d_J);'
p24934
aS'            lin_it  = solver_control_K_con_inv.last_step();'
p24935
aS'            lin_res = solver_control_K_con_inv.last_value();'
p24936
aS'          }'
p24937
aS'        else if (parameters.type_lin == "Direct")'
p24938
aS'          {'
p24939
aS'            SparseDirectUMFPACK A_direct;'
p24940
aS'            A_direct.initialize(tangent_matrix);'
p24941
aS'            A_direct.vmult(newton_update, system_rhs);'
p24942
aS'            lin_it  = 1;'
p24943
aS'            lin_res = 0.0;'
p24944
aS'            std::cout << " -- " << std::flush;'
p24945
aS'          }'
p24946
aS'        else'
p24947
aS'          Assert(false, ExcMessage("Linear solver type not implemented"));'
p24948
aS'        timer.leave_subsection();'
p24949
aS'        constraints.distribute(newton_update);'
p24950
aS'      }'
p24951
aS'    return std::make_pair(lin_it, lin_res);'
p24952
aS'  }'
p24953
aS'  template <int dim>'
p24954
aS'  void Solid<dim>::output_results() const'
p24955
aS'  {'
p24956
aS'    DataOut<dim> data_out;'
p24957
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p24958
aS'      data_component_interpretation('
p24959
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p24960
aS'    data_component_interpretation.push_back('
p24961
aS'      DataComponentInterpretation::component_is_scalar);'
p24962
aS'    data_component_interpretation.push_back('
p24963
aS'      DataComponentInterpretation::component_is_scalar);'
p24964
aS'    std::vector<std::string> solution_name(dim, "displacement");'
p24965
aS'    solution_name.emplace_back("pressure");'
p24966
aS'    solution_name.emplace_back("dilatation");'
p24967
aS'    DataOutBase::VtkFlags output_flags;'
p24968
aS'    output_flags.write_higher_order_cells = true;'
p24969
aS'    data_out.set_flags(output_flags);'
p24970
aS'    data_out.attach_dof_handler(dof_handler);'
p24971
aS'    data_out.add_data_vector(solution_n,'
p24972
aS'                             solution_name,'
p24973
aS'                             DataOut<dim>::type_dof_data,'
p24974
aS'                             data_component_interpretation);'
p24975
aS'    Vector<double> soln(solution_n.size());'
p24976
aS'    for (unsigned int i = 0; i < soln.size(); ++i)'
p24977
aS'      soln(i) = solution_n(i);'
p24978
aS'    MappingQEulerian<dim> q_mapping(degree, dof_handler, soln);'
p24979
aS'    data_out.build_patches(q_mapping, degree);'
p24980
aS'    std::ofstream output("solution-" + std::to_string(dim) + "d-" +'
p24981
aS'                         std::to_string(time.get_timestep()) + ".vtu");'
p24982
aS'    data_out.write_vtu(output);'
p24983
aS'  }'
p24984
aS'} // namespace Step44'
p24985
aS'int main()'
p24986
ag24
aS'  using namespace Step44;'
p24987
aS'  try'
p24988
aS'    {'
p24989
aS'      const unsigned int dim = 3;'
p24990
aS'      Solid<dim>         solid("parameters.prm");'
p24991
aS'      solid.run();'
p24992
aS'    }'
p24993
aS'  catch (std::exception &exc)'
p24994
aS'    {'
p24995
aS'      std::cerr << std::endl'
p24996
aS'                << std::endl'
p24997
aS'                << "----------------------------------------------------"'
p24998
aS'                << std::endl;'
p24999
aS'      std::cerr << "Exception on processing: " << std::endl'
p25000
aS'                << exc.what() << std::endl'
p25001
aS'                << "Aborting!" << std::endl'
p25002
aS'                << "----------------------------------------------------"'
p25003
aS'                << std::endl;'
p25004
aS'      return 1;'
p25005
aS'    }'
p25006
aS'  catch (...)'
p25007
aS'    {'
p25008
aS'      std::cerr << std::endl'
p25009
aS'                << std::endl'
p25010
aS'                << "----------------------------------------------------"'
p25011
aS'                << std::endl;'
p25012
aS'      std::cerr << "Unknown exception!" << std::endl'
p25013
aS'                << "Aborting!" << std::endl'
p25014
aS'                << "----------------------------------------------------"'
p25015
aS'                << std::endl;'
p25016
aS'      return 1;'
p25017
aS'    }'
p25018
aS'  return 0;'
p25019
ag32
aS'/* ---------------------------------------------------------------------'
p25020
aS' *'
p25021
aS' * Copyright (C) 2008 - 2020 by the deal.II authors'
p25022
aS' *'
p25023
aS' * This file is part of the deal.II library.'
p25024
aS' *'
p25025
aS' * The deal.II library is free software; you can use it, redistribute'
p25026
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p25027
aS' * Public License as published by the Free Software Foundation; either'
p25028
aS' * version 2.1 of the License, or (at your option) any later version.'
p25029
aS' * The full text of the license can be found in the file LICENSE.md at'
p25030
aS' * the top level directory of deal.II.'
p25031
aS' *'
p25032
aS' * ---------------------------------------------------------------------'
p25033
aS' *'
p25034
aS' * Author: Daniel Arndt, Matthias Maier, 2015'
p25035
aS' *'
p25036
aS' * Based on step-22 by Wolfgang Bangerth and Martin Kronbichler'
p25037
aS' */'
p25038
aS'#include <deal.II/base/conditional_ostream.h>'
p25039
aS'#include <deal.II/distributed/grid_refinement.h>'
p25040
aS'#include <deal.II/lac/solver_cg.h>'
p25041
aS'#include <deal.II/lac/affine_constraints.h>'
p25042
aS'#include <deal.II/lac/trilinos_solver.h>'
p25043
aS'#include <deal.II/lac/trilinos_precondition.h>'
p25044
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p25045
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p25046
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p25047
aS'#include <deal.II/grid/grid_generator.h>'
p25048
aS'#include <deal.II/grid/grid_tools.h>'
p25049
aS'#include <deal.II/dofs/dof_renumbering.h>'
p25050
aS'#include <deal.II/dofs/dof_tools.h>'
p25051
aS'#include <deal.II/fe/fe_q.h>'
p25052
aS'#include <deal.II/fe/fe_system.h>'
p25053
aS'#include <deal.II/fe/mapping_q.h>'
p25054
aS'#include <deal.II/numerics/vector_tools.h>'
p25055
aS'#include <deal.II/numerics/data_out.h>'
p25056
aS'#include <deal.II/numerics/error_estimator.h>'
p25057
aS'namespace Step45'
p25058
ag24
aS'  using namespace dealii;'
p25059
aS'  template <int dim>'
p25060
aS'  class StokesProblem'
p25061
aS'  {'
p25062
aS'  public:'
p25063
aS'    StokesProblem(const unsigned int degree);'
p25064
aS'    void run();'
p25065
aS'  private:'
p25066
aS'    void create_mesh();'
p25067
aS'    void setup_dofs();'
p25068
aS'    void assemble_system();'
p25069
aS'    void solve();'
p25070
aS'    void output_results(const unsigned int refinement_cycle) const;'
p25071
aS'    void refine_mesh();'
p25072
aS'    const unsigned int degree;'
p25073
aS'    MPI_Comm mpi_communicator;'
p25074
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p25075
aS'    FESystem<dim>                             fe;'
p25076
aS'    DoFHandler<dim>                           dof_handler;'
p25077
aS'    AffineConstraints<double> constraints;'
p25078
aS'    std::vector<IndexSet>     owned_partitioning;'
p25079
aS'    std::vector<IndexSet>     relevant_partitioning;'
p25080
aS'    TrilinosWrappers::BlockSparseMatrix system_matrix;'
p25081
aS'    TrilinosWrappers::BlockSparseMatrix preconditioner_matrix;'
p25082
aS'    TrilinosWrappers::MPI::BlockVector solution;'
p25083
aS'    TrilinosWrappers::MPI::BlockVector system_rhs;'
p25084
aS'    ConditionalOStream pcout;'
p25085
aS'    MappingQ<dim> mapping;'
p25086
aS'  };'
p25087
aS'  template <int dim>'
p25088
aS'  class BoundaryValues : public Function<dim>'
p25089
aS'  {'
p25090
aS'  public:'
p25091
aS'    BoundaryValues()'
p25092
aS'      : Function<dim>(dim + 1)'
p25093
aS'    {}'
p25094
aS'    virtual double value(const Point<dim> & p,'
p25095
aS'                         const unsigned int component = 0) const override;'
p25096
aS'    virtual void vector_value(const Point<dim> &p,'
p25097
aS'                              Vector<double> &  value) const override;'
p25098
aS'  };'
p25099
aS'  template <int dim>'
p25100
aS'  double BoundaryValues<dim>::value(const Point<dim> & /*p*/,'
p25101
aS'                                    const unsigned int component) const'
p25102
aS'  {'
p25103
aS'    (void)component;'
p25104
aS'    Assert(component < this->n_components,'
p25105
aS'           ExcIndexRange(component, 0, this->n_components));'
p25106
aS'    return 0;'
p25107
aS'  }'
p25108
aS'  template <int dim>'
p25109
aS'  void BoundaryValues<dim>::vector_value(const Point<dim> &p,'
p25110
aS'                                         Vector<double> &  values) const'
p25111
aS'  {'
p25112
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p25113
aS'      values(c) = BoundaryValues<dim>::value(p, c);'
p25114
aS'  }'
p25115
aS'  template <int dim>'
p25116
aS'  class RightHandSide : public Function<dim>'
p25117
aS'  {'
p25118
aS'  public:'
p25119
aS'    RightHandSide()'
p25120
aS'      : Function<dim>(dim + 1)'
p25121
aS'    {}'
p25122
aS'    virtual double value(const Point<dim> & p,'
p25123
aS'                         const unsigned int component = 0) const override;'
p25124
aS'    virtual void vector_value(const Point<dim> &p,'
p25125
aS'                              Vector<double> &  value) const override;'
p25126
aS'  };'
p25127
aS'  template <int dim>'
p25128
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p25129
aS'                                   const unsigned int component) const'
p25130
aS'  {'
p25131
aS'    const Point<dim> center(0.75, 0.1);'
p25132
aS'    const double     r = (p - center).norm();'
p25133
aS'    if (component == 0)'
p25134
aS'      return std::exp(-100. * r * r);'
p25135
aS'    return 0;'
p25136
aS'  }'
p25137
aS'  template <int dim>'
p25138
aS'  void RightHandSide<dim>::vector_value(const Point<dim> &p,'
p25139
aS'                                        Vector<double> &  values) const'
p25140
aS'  {'
p25141
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p25142
aS'      values(c) = RightHandSide<dim>::value(p, c);'
p25143
aS'  }'
p25144
aS'  template <class MatrixType, class PreconditionerType>'
p25145
aS'  class InverseMatrix : public Subscriptor'
p25146
aS'  {'
p25147
aS'  public:'
p25148
aS'    InverseMatrix(const MatrixType &        m,'
p25149
aS'                  const PreconditionerType &preconditioner,'
p25150
aS'                  const IndexSet &          locally_owned,'
p25151
aS'                  const MPI_Comm &          mpi_communicator);'
p25152
aS'    void vmult(TrilinosWrappers::MPI::Vector &      dst,'
p25153
aS'               const TrilinosWrappers::MPI::Vector &src) const;'
p25154
aS'  private:'
p25155
aS'    const SmartPointer<const MatrixType>         matrix;'
p25156
aS'    const SmartPointer<const PreconditionerType> preconditioner;'
p25157
aS'    const MPI_Comm *                      mpi_communicator;'
p25158
aS'    mutable TrilinosWrappers::MPI::Vector tmp;'
p25159
aS'  };'
p25160
aS'  template <class MatrixType, class PreconditionerType>'
p25161
aS'  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p25162
aS'    const MatrixType &        m,'
p25163
aS'    const PreconditionerType &preconditioner,'
p25164
aS'    const IndexSet &          locally_owned,'
p25165
aS'    const MPI_Comm &          mpi_communicator)'
p25166
aS'    : matrix(&m)'
p25167
aS'    , preconditioner(&preconditioner)'
p25168
aS'    , mpi_communicator(&mpi_communicator)'
p25169
aS'    , tmp(locally_owned, mpi_communicator)'
p25170
aS'  {}'
p25171
aS'  template <class MatrixType, class PreconditionerType>'
p25172
aS'  void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p25173
aS'    TrilinosWrappers::MPI::Vector &      dst,'
p25174
aS'    const TrilinosWrappers::MPI::Vector &src) const'
p25175
aS'  {'
p25176
aS'    SolverControl              solver_control(src.size(), 1e-6 * src.l2_norm());'
p25177
aS'    TrilinosWrappers::SolverCG cg(solver_control,'
p25178
aS'                                  TrilinosWrappers::SolverCG::AdditionalData());'
p25179
aS'    tmp = 0.;'
p25180
aS'    cg.solve(*matrix, tmp, src, *preconditioner);'
p25181
aS'    dst = tmp;'
p25182
aS'  }'
p25183
aS'  template <class PreconditionerType>'
p25184
aS'  class SchurComplement : public TrilinosWrappers::SparseMatrix'
p25185
aS'  {'
p25186
aS'  public:'
p25187
aS'    SchurComplement(const TrilinosWrappers::BlockSparseMatrix &system_matrix,'
p25188
aS'                    const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p25189
aS'                                        PreconditionerType> &  A_inverse,'
p25190
aS'                    const IndexSet &                           owned_pres,'
p25191
aS'                    const MPI_Comm &mpi_communicator);'
p25192
aS'    void vmult(TrilinosWrappers::MPI::Vector &      dst,'
p25193
aS'               const TrilinosWrappers::MPI::Vector &src) const;'
p25194
aS'  private:'
p25195
aS'    const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> system_matrix;'
p25196
aS'    const SmartPointer<'
p25197
aS'      const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>>'
p25198
aS'                                          A_inverse;'
p25199
aS'    mutable TrilinosWrappers::MPI::Vector tmp1, tmp2;'
p25200
aS'  };'
p25201
aS'  template <class PreconditionerType>'
p25202
aS'  SchurComplement<PreconditionerType>::SchurComplement('
p25203
aS'    const TrilinosWrappers::BlockSparseMatrix &system_matrix,'
p25204
aS'    const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>'
p25205
aS'      &             A_inverse,'
p25206
aS'    const IndexSet &owned_vel,'
p25207
aS'    const MPI_Comm &mpi_communicator)'
p25208
aS'    : system_matrix(&system_matrix)'
p25209
aS'    , A_inverse(&A_inverse)'
p25210
aS'    , tmp1(owned_vel, mpi_communicator)'
p25211
aS'    , tmp2(tmp1)'
p25212
aS'  {}'
p25213
aS'  template <class PreconditionerType>'
p25214
aS'  void SchurComplement<PreconditionerType>::vmult('
p25215
aS'    TrilinosWrappers::MPI::Vector &      dst,'
p25216
aS'    const TrilinosWrappers::MPI::Vector &src) const'
p25217
aS'  {'
p25218
aS'    system_matrix->block(0, 1).vmult(tmp1, src);'
p25219
aS'    A_inverse->vmult(tmp2, tmp1);'
p25220
aS'    system_matrix->block(1, 0).vmult(dst, tmp2);'
p25221
aS'  }'
p25222
aS'  template <int dim>'
p25223
aS'  StokesProblem<dim>::StokesProblem(const unsigned int degree)'
p25224
aS'    : degree(degree)'
p25225
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p25226
aS'    , triangulation(mpi_communicator)'
p25227
aS'    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1)'
p25228
aS'    , dof_handler(triangulation)'
p25229
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p25230
aS'    , mapping(degree + 1)'
p25231
aS'  {}'
p25232
aS'  template <int dim>'
p25233
aS'  void StokesProblem<dim>::create_mesh()'
p25234
aS'  {'
p25235
aS'    Point<dim>   center;'
p25236
aS'    const double inner_radius = .5;'
p25237
aS'    const double outer_radius = 1.;'
p25238
aS'    GridGenerator::quarter_hyper_shell('
p25239
aS'      triangulation, center, inner_radius, outer_radius, 0, true);'
p25240
aS'    std::vector<GridTools::PeriodicFacePair<'
p25241
aS'      typename parallel::distributed::Triangulation<dim>::cell_iterator>>'
p25242
aS'      periodicity_vector;'
p25243
aS'    FullMatrix<double> rotation_matrix(dim);'
p25244
aS'    rotation_matrix[0][1] = 1.;'
p25245
aS'    rotation_matrix[1][0] = -1.;'
p25246
aS'    GridTools::collect_periodic_faces(triangulation,'
p25247
aS'                                      2,'
p25248
aS'                                      3,'
p25249
aS'                                      1,'
p25250
aS'                                      periodicity_vector,'
p25251
aS'                                      Tensor<1, dim>(),'
p25252
aS'                                      rotation_matrix);'
p25253
aS'    triangulation.add_periodicity(periodicity_vector);'
p25254
aS'    triangulation.refine_global(4 - dim);'
p25255
aS'  }'
p25256
aS'  template <int dim>'
p25257
aS'  void StokesProblem<dim>::setup_dofs()'
p25258
aS'  {'
p25259
aS'    dof_handler.distribute_dofs(fe);'
p25260
aS'    std::vector<unsigned int> block_component(dim + 1, 0);'
p25261
aS'    block_component[dim] = 1;'
p25262
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p25263
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p25264
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p25265
aS'    const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];'
p25266
aS'    {'
p25267
aS'      owned_partitioning.clear();'
p25268
aS'      IndexSet locally_owned_dofs = dof_handler.locally_owned_dofs();'
p25269
aS'      owned_partitioning.push_back(locally_owned_dofs.get_view(0, n_u));'
p25270
aS'      owned_partitioning.push_back(locally_owned_dofs.get_view(n_u, n_u + n_p));'
p25271
aS'      relevant_partitioning.clear();'
p25272
aS'      IndexSet locally_relevant_dofs;'
p25273
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler,'
p25274
aS'                                              locally_relevant_dofs);'
p25275
aS'      relevant_partitioning.push_back(locally_relevant_dofs.get_view(0, n_u));'
p25276
aS'      relevant_partitioning.push_back('
p25277
aS'        locally_relevant_dofs.get_view(n_u, n_u + n_p));'
p25278
aS'      constraints.clear();'
p25279
aS'      constraints.reinit(locally_relevant_dofs);'
p25280
aS'      FEValuesExtractors::Vector velocities(0);'
p25281
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p25282
aS'      VectorTools::interpolate_boundary_values(mapping,'
p25283
aS'                                               dof_handler,'
p25284
aS'                                               0,'
p25285
aS'                                               BoundaryValues<dim>(),'
p25286
aS'                                               constraints,'
p25287
aS'                                               fe.component_mask(velocities));'
p25288
aS'      VectorTools::interpolate_boundary_values(mapping,'
p25289
aS'                                               dof_handler,'
p25290
aS'                                               1,'
p25291
aS'                                               BoundaryValues<dim>(),'
p25292
aS'                                               constraints,'
p25293
aS'                                               fe.component_mask(velocities));'
p25294
aS'      FullMatrix<double> rotation_matrix(dim);'
p25295
aS'      rotation_matrix[0][1] = 1.;'
p25296
aS'      rotation_matrix[1][0] = -1.;'
p25297
aS'      Tensor<1, dim> offset;'
p25298
aS'      std::vector<'
p25299
aS'        GridTools::PeriodicFacePair<typename DoFHandler<dim>::cell_iterator>>'
p25300
aS'        periodicity_vector;'
p25301
aS'      const unsigned int direction = 1;'
p25302
aS'      GridTools::collect_periodic_faces(dof_handler,'
p25303
aS'                                        2,'
p25304
aS'                                        3,'
p25305
aS'                                        direction,'
p25306
aS'                                        periodicity_vector,'
p25307
aS'                                        offset,'
p25308
aS'                                        rotation_matrix);'
p25309
aS'      std::vector<unsigned int> first_vector_components;'
p25310
aS'      first_vector_components.push_back(0);'
p25311
aS'      DoFTools::make_periodicity_constraints<dim, dim>(periodicity_vector,'
p25312
aS'                                                       constraints,'
p25313
aS'                                                       fe.component_mask('
p25314
aS'                                                         velocities),'
p25315
aS'                                                       first_vector_components);'
p25316
aS'      VectorTools::interpolate_boundary_values(mapping,'
p25317
aS'                                               dof_handler,'
p25318
aS'                                               0,'
p25319
aS'                                               BoundaryValues<dim>(),'
p25320
aS'                                               constraints,'
p25321
aS'                                               fe.component_mask(velocities));'
p25322
aS'      VectorTools::interpolate_boundary_values(mapping,'
p25323
aS'                                               dof_handler,'
p25324
aS'                                               1,'
p25325
aS'                                               BoundaryValues<dim>(),'
p25326
aS'                                               constraints,'
p25327
aS'                                               fe.component_mask(velocities));'
p25328
aS'    }'
p25329
aS'    constraints.close();'
p25330
aS'    {'
p25331
aS'      TrilinosWrappers::BlockSparsityPattern bsp(owned_partitioning,'
p25332
aS'                                                 owned_partitioning,'
p25333
aS'                                                 relevant_partitioning,'
p25334
aS'                                                 mpi_communicator);'
p25335
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p25336
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p25337
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p25338
aS'          if (!((c == dim) && (d == dim)))'
p25339
aS'            coupling[c][d] = DoFTools::always;'
p25340
aS'          else'
p25341
aS'            coupling[c][d] = DoFTools::none;'
p25342
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p25343
aS'                                      coupling,'
p25344
aS'                                      bsp,'
p25345
aS'                                      constraints,'
p25346
aS'                                      false,'
p25347
aS'                                      Utilities::MPI::this_mpi_process('
p25348
aS'                                        mpi_communicator));'
p25349
aS'      bsp.compress();'
p25350
aS'      system_matrix.reinit(bsp);'
p25351
aS'    }'
p25352
aS'    {'
p25353
aS'      TrilinosWrappers::BlockSparsityPattern preconditioner_bsp('
p25354
aS'        owned_partitioning,'
p25355
aS'        owned_partitioning,'
p25356
aS'        relevant_partitioning,'
p25357
aS'        mpi_communicator);'
p25358
aS'      Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1);'
p25359
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p25360
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p25361
aS'          if ((c == dim) && (d == dim))'
p25362
aS'            preconditioner_coupling[c][d] = DoFTools::always;'
p25363
aS'          else'
p25364
aS'            preconditioner_coupling[c][d] = DoFTools::none;'
p25365
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p25366
aS'                                      preconditioner_coupling,'
p25367
aS'                                      preconditioner_bsp,'
p25368
aS'                                      constraints,'
p25369
aS'                                      false,'
p25370
aS'                                      Utilities::MPI::this_mpi_process('
p25371
aS'                                        mpi_communicator));'
p25372
aS'      preconditioner_bsp.compress();'
p25373
aS'      preconditioner_matrix.reinit(preconditioner_bsp);'
p25374
aS'    }'
p25375
aS'    system_rhs.reinit(owned_partitioning, mpi_communicator);'
p25376
aS'    solution.reinit(owned_partitioning,'
p25377
aS'                    relevant_partitioning,'
p25378
aS'                    mpi_communicator);'
p25379
aS'  }'
p25380
aS'  template <int dim>'
p25381
aS'  void StokesProblem<dim>::assemble_system()'
p25382
aS'  {'
p25383
aS'    system_matrix         = 0.;'
p25384
aS'    system_rhs            = 0.;'
p25385
aS'    preconditioner_matrix = 0.;'
p25386
aS'    QGauss<dim> quadrature_formula(degree + 2);'
p25387
aS'    FEValues<dim> fe_values(mapping,'
p25388
aS'                            fe,'
p25389
aS'                            quadrature_formula,'
p25390
aS'                            update_values | update_quadrature_points |'
p25391
aS'                              update_JxW_values | update_gradients);'
p25392
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p25393
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p25394
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p25395
aS'    FullMatrix<double> local_preconditioner_matrix(dofs_per_cell,'
p25396
aS'                                                   dofs_per_cell);'
p25397
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p25398
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p25399
aS'    const RightHandSide<dim>    right_hand_side;'
p25400
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p25401
aS'    const FEValuesExtractors::Vector velocities(0);'
p25402
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p25403
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p25404
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p25405
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p25406
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p25407
aS'      if (cell->is_locally_owned())'
p25408
aS'        {'
p25409
aS'          fe_values.reinit(cell);'
p25410
aS'          local_matrix                = 0;'
p25411
aS'          local_preconditioner_matrix = 0;'
p25412
aS'          local_rhs                   = 0;'
p25413
aS'          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p25414
aS'                                            rhs_values);'
p25415
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p25416
aS'            {'
p25417
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p25418
aS'                {'
p25419
aS'                  symgrad_phi_u[k] ='
p25420
aS'                    fe_values[velocities].symmetric_gradient(k, q);'
p25421
aS'                  div_phi_u[k] = fe_values[velocities].divergence(k, q);'
p25422
aS'                  phi_p[k]     = fe_values[pressure].value(k, q);'
p25423
aS'                }'
p25424
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p25425
aS'                {'
p25426
aS'                  for (unsigned int j = 0; j <= i; ++j)'
p25427
aS'                    {'
p25428
aS'                      local_matrix(i, j) +='
p25429
aS'                        (symgrad_phi_u[i] * symgrad_phi_u[j] // diffusion'
p25430
aS'                         - div_phi_u[i] * phi_p[j]           // pressure force'
p25431
aS'                         - phi_p[i] * div_phi_u[j])          // divergence'
p25432
aS'                        * fe_values.JxW(q);'
p25433
aS'                      local_preconditioner_matrix(i, j) +='
p25434
aS'                        (phi_p[i] * phi_p[j]) * fe_values.JxW(q);'
p25435
aS'                    }'
p25436
aS'                  const unsigned int component_i ='
p25437
aS'                    fe.system_to_component_index(i).first;'
p25438
aS'                  local_rhs(i) += fe_values.shape_value(i, q)  //'
p25439
aS'                                  * rhs_values[q](component_i) //'
p25440
aS'                                  * fe_values.JxW(q);'
p25441
aS'                }'
p25442
aS'            }'
p25443
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p25444
aS'            for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p25445
aS'              {'
p25446
aS'                local_matrix(i, j) = local_matrix(j, i);'
p25447
aS'                local_preconditioner_matrix(i, j) ='
p25448
aS'                  local_preconditioner_matrix(j, i);'
p25449
aS'              }'
p25450
aS'          cell->get_dof_indices(local_dof_indices);'
p25451
aS'          constraints.distribute_local_to_global(local_matrix,'
p25452
aS'                                                 local_rhs,'
p25453
aS'                                                 local_dof_indices,'
p25454
aS'                                                 system_matrix,'
p25455
aS'                                                 system_rhs);'
p25456
aS'          constraints.distribute_local_to_global(local_preconditioner_matrix,'
p25457
aS'                                                 local_dof_indices,'
p25458
aS'                                                 preconditioner_matrix);'
p25459
aS'        }'
p25460
aS'    system_matrix.compress(VectorOperation::add);'
p25461
aS'    system_rhs.compress(VectorOperation::add);'
p25462
aS'    pcout << "   Computing preconditioner..." << std::endl << std::flush;'
p25463
aS'  }'
p25464
aS'  template <int dim>'
p25465
aS'  void StokesProblem<dim>::solve()'
p25466
aS'  {'
p25467
aS'    TrilinosWrappers::PreconditionJacobi A_preconditioner;'
p25468
aS'    A_preconditioner.initialize(system_matrix.block(0, 0));'
p25469
aS'    const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p25470
aS'                        TrilinosWrappers::PreconditionJacobi>'
p25471
aS'      A_inverse(system_matrix.block(0, 0),'
p25472
aS'                A_preconditioner,'
p25473
aS'                owned_partitioning[0],'
p25474
aS'                mpi_communicator);'
p25475
aS'    TrilinosWrappers::MPI::BlockVector tmp(owned_partitioning,'
p25476
aS'                                           mpi_communicator);'
p25477
aS'    {'
p25478
aS'      TrilinosWrappers::MPI::Vector schur_rhs(owned_partitioning[1],'
p25479
aS'                                              mpi_communicator);'
p25480
aS'      A_inverse.vmult(tmp.block(0), system_rhs.block(0));'
p25481
aS'      system_matrix.block(1, 0).vmult(schur_rhs, tmp.block(0));'
p25482
aS'      schur_rhs -= system_rhs.block(1);'
p25483
aS'      SchurComplement<TrilinosWrappers::PreconditionJacobi> schur_complement('
p25484
aS'        system_matrix, A_inverse, owned_partitioning[0], mpi_communicator);'
p25485
aS'      SolverControl solver_control(solution.block(1).size(),'
p25486
aS'                                   1e-6 * schur_rhs.l2_norm());'
p25487
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p25488
aS'      TrilinosWrappers::PreconditionAMG preconditioner;'
p25489
aS'      preconditioner.initialize(preconditioner_matrix.block(1, 1));'
p25490
aS'      InverseMatrix<TrilinosWrappers::SparseMatrix,'
p25491
aS'                    TrilinosWrappers::PreconditionAMG>'
p25492
aS'        m_inverse(preconditioner_matrix.block(1, 1),'
p25493
aS'                  preconditioner,'
p25494
aS'                  owned_partitioning[1],'
p25495
aS'                  mpi_communicator);'
p25496
aS'      cg.solve(schur_complement, tmp.block(1), schur_rhs, preconditioner);'
p25497
aS'      constraints.distribute(tmp);'
p25498
aS'      solution.block(1) = tmp.block(1);'
p25499
aS'    }'
p25500
aS'    {'
p25501
aS'      system_matrix.block(0, 1).vmult(tmp.block(0), tmp.block(1));'
p25502
aS'      tmp.block(0) *= -1;'
p25503
aS'      tmp.block(0) += system_rhs.block(0);'
p25504
aS'      A_inverse.vmult(tmp.block(0), tmp.block(0));'
p25505
aS'      constraints.distribute(tmp);'
p25506
aS'      solution.block(0) = tmp.block(0);'
p25507
aS'    }'
p25508
aS'  }'
p25509
aS'  template <int dim>'
p25510
aS'  void'
p25511
aS'  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const'
p25512
aS'  {'
p25513
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p25514
aS'    solution_names.emplace_back("pressure");'
p25515
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p25516
aS'      data_component_interpretation('
p25517
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p25518
aS'    data_component_interpretation.push_back('
p25519
aS'      DataComponentInterpretation::component_is_scalar);'
p25520
aS'    DataOut<dim> data_out;'
p25521
aS'    data_out.attach_dof_handler(dof_handler);'
p25522
aS'    data_out.add_data_vector(solution,'
p25523
aS'                             solution_names,'
p25524
aS'                             DataOut<dim>::type_dof_data,'
p25525
aS'                             data_component_interpretation);'
p25526
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p25527
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p25528
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p25529
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p25530
aS'    data_out.build_patches(mapping, degree + 1);'
p25531
aS'    data_out.write_vtu_with_pvtu_record('
p25532
aS'      "./", "solution", refinement_cycle, MPI_COMM_WORLD, 2);'
p25533
aS'  }'
p25534
aS'  template <int dim>'
p25535
aS'  void StokesProblem<dim>::refine_mesh()'
p25536
aS'  {'
p25537
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p25538
aS'    FEValuesExtractors::Scalar pressure(dim);'
p25539
aS'    KellyErrorEstimator<dim>::estimate('
p25540
aS'      dof_handler,'
p25541
aS'      QGauss<dim - 1>(degree + 1),'
p25542
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p25543
aS'      solution,'
p25544
aS'      estimated_error_per_cell,'
p25545
aS'      fe.component_mask(pressure));'
p25546
aS'    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p25547
aS'      triangulation, estimated_error_per_cell, 0.3, 0.0);'
p25548
aS'    triangulation.execute_coarsening_and_refinement();'
p25549
aS'  }'
p25550
aS'  template <int dim>'
p25551
aS'  void StokesProblem<dim>::run()'
p25552
aS'  {'
p25553
aS'    create_mesh();'
p25554
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 9;'
p25555
aS'         ++refinement_cycle)'
p25556
aS'      {'
p25557
aS'        pcout << "Refinement cycle " << refinement_cycle << std::endl;'
p25558
aS'        if (refinement_cycle > 0)'
p25559
aS'          refine_mesh();'
p25560
aS'        setup_dofs();'
p25561
aS'        pcout << "   Assembling..." << std::endl << std::flush;'
p25562
aS'        assemble_system();'
p25563
aS'        pcout << "   Solving..." << std::flush;'
p25564
aS'        solve();'
p25565
aS'        output_results(refinement_cycle);'
p25566
aS'        pcout << std::endl;'
p25567
aS'      }'
p25568
aS'  }'
p25569
aS'} // namespace Step45'
p25570
aS'int main(int argc, char *argv[])'
p25571
ag24
aS'  try'
p25572
aS'    {'
p25573
aS'      using namespace dealii;'
p25574
aS'      using namespace Step45;'
p25575
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p25576
aS'      StokesProblem<2>                 flow_problem(1);'
p25577
aS'      flow_problem.run();'
p25578
aS'    }'
p25579
aS'  catch (std::exception &exc)'
p25580
aS'    {'
p25581
aS'      std::cerr << std::endl'
p25582
aS'                << std::endl'
p25583
aS'                << "----------------------------------------------------"'
p25584
aS'                << std::endl;'
p25585
aS'      std::cerr << "Exception on processing: " << std::endl'
p25586
aS'                << exc.what() << std::endl'
p25587
aS'                << "Aborting!" << std::endl'
p25588
aS'                << "----------------------------------------------------"'
p25589
aS'                << std::endl;'
p25590
aS'      return 1;'
p25591
aS'    }'
p25592
aS'  catch (...)'
p25593
aS'    {'
p25594
aS'      std::cerr << std::endl'
p25595
aS'                << std::endl'
p25596
aS'                << "----------------------------------------------------"'
p25597
aS'                << std::endl;'
p25598
aS'      std::cerr << "Unknown exception!" << std::endl'
p25599
aS'                << "Aborting!" << std::endl'
p25600
aS'                << "----------------------------------------------------"'
p25601
aS'                << std::endl;'
p25602
aS'      return 1;'
p25603
aS'    }'
p25604
aS'  return 0;'
p25605
ag32
aS'/* ---------------------------------------------------------------------'
p25606
aS' *'
p25607
aS' * Copyright (C) 2011 - 2021 by the deal.II authors'
p25608
aS' *'
p25609
aS' * This file is part of the deal.II library.'
p25610
aS' *'
p25611
aS' * The deal.II library is free software; you can use it, redistribute'
p25612
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p25613
aS' * Public License as published by the Free Software Foundation; either'
p25614
aS' * version 2.1 of the License, or (at your option) any later version.'
p25615
aS' * The full text of the license can be found in the file LICENSE.md at'
p25616
aS' * the top level directory of deal.II.'
p25617
aS' *'
p25618
aS' * ---------------------------------------------------------------------'
p25619
aS' *'
p25620
aS' * Author: Wolfgang Bangerth, Texas A&M University, 2011'
p25621
aS' */'
p25622
aS'#include <deal.II/base/quadrature_lib.h>'
p25623
aS'#include <deal.II/base/logstream.h>'
p25624
aS'#include <deal.II/base/function.h>'
p25625
aS'#include <deal.II/base/utilities.h>'
p25626
aS'#include <deal.II/lac/vector.h>'
p25627
aS'#include <deal.II/lac/full_matrix.h>'
p25628
aS'#include <deal.II/lac/sparse_matrix.h>'
p25629
aS'#include <deal.II/lac/sparse_direct.h>'
p25630
aS'#include <deal.II/lac/affine_constraints.h>'
p25631
aS'#include <deal.II/grid/tria.h>'
p25632
aS'#include <deal.II/grid/grid_generator.h>'
p25633
aS'#include <deal.II/grid/grid_refinement.h>'
p25634
aS'#include <deal.II/dofs/dof_tools.h>'
p25635
aS'#include <deal.II/fe/fe_q.h>'
p25636
aS'#include <deal.II/fe/fe_nothing.h>'
p25637
aS'#include <deal.II/fe/fe_system.h>'
p25638
aS'#include <deal.II/fe/fe_values.h>'
p25639
aS'#include <deal.II/hp/fe_collection.h>'
p25640
aS'#include <deal.II/hp/fe_values.h>'
p25641
aS'#include <deal.II/numerics/vector_tools.h>'
p25642
aS'#include <deal.II/numerics/data_out.h>'
p25643
aS'#include <deal.II/numerics/error_estimator.h>'
p25644
aS'#include <iostream>'
p25645
aS'#include <fstream>'
p25646
aS'namespace Step46'
p25647
ag24
aS'  using namespace dealii;'
p25648
aS'  template <int dim>'
p25649
aS'  class FluidStructureProblem'
p25650
aS'  {'
p25651
aS'  public:'
p25652
aS'    FluidStructureProblem(const unsigned int stokes_degree,'
p25653
aS'                          const unsigned int elasticity_degree);'
p25654
aS'    void run();'
p25655
aS'  private:'
p25656
aS'    enum'
p25657
aS'    {'
p25658
aS'      fluid_domain_id,'
p25659
aS'      solid_domain_id'
p25660
aS'    };'
p25661
aS'    static bool cell_is_in_fluid_domain('
p25662
aS'      const typename DoFHandler<dim>::cell_iterator &cell);'
p25663
aS'    static bool cell_is_in_solid_domain('
p25664
aS'      const typename DoFHandler<dim>::cell_iterator &cell);'
p25665
aS'    void make_grid();'
p25666
aS'    void set_active_fe_indices();'
p25667
aS'    void setup_dofs();'
p25668
aS'    void assemble_system();'
p25669
aS'    void assemble_interface_term('
p25670
aS'      const FEFaceValuesBase<dim> &         elasticity_fe_face_values,'
p25671
aS'      const FEFaceValuesBase<dim> &         stokes_fe_face_values,'
p25672
aS'      std::vector<Tensor<1, dim>> &         elasticity_phi,'
p25673
aS'      std::vector<SymmetricTensor<2, dim>> &stokes_symgrad_phi_u,'
p25674
aS'      std::vector<double> &                 stokes_phi_p,'
p25675
aS'      FullMatrix<double> &                  local_interface_matrix) const;'
p25676
aS'    void solve();'
p25677
aS'    void output_results(const unsigned int refinement_cycle) const;'
p25678
aS'    void refine_mesh();'
p25679
aS'    const unsigned int stokes_degree;'
p25680
aS'    const unsigned int elasticity_degree;'
p25681
aS'    Triangulation<dim>    triangulation;'
p25682
aS'    FESystem<dim>         stokes_fe;'
p25683
aS'    FESystem<dim>         elasticity_fe;'
p25684
aS'    hp::FECollection<dim> fe_collection;'
p25685
aS'    DoFHandler<dim>       dof_handler;'
p25686
aS'    AffineConstraints<double> constraints;'
p25687
aS'    SparsityPattern      sparsity_pattern;'
p25688
aS'    SparseMatrix<double> system_matrix;'
p25689
aS'    Vector<double> solution;'
p25690
aS'    Vector<double> system_rhs;'
p25691
aS'    const double viscosity;'
p25692
aS'    const double lambda;'
p25693
aS'    const double mu;'
p25694
aS'  };'
p25695
aS'  template <int dim>'
p25696
aS'  class StokesBoundaryValues : public Function<dim>'
p25697
aS'  {'
p25698
aS'  public:'
p25699
aS'    StokesBoundaryValues()'
p25700
aS'      : Function<dim>(dim + 1 + dim)'
p25701
aS'    {}'
p25702
aS'    virtual double value(const Point<dim> & p,'
p25703
aS'                         const unsigned int component = 0) const override;'
p25704
aS'    virtual void vector_value(const Point<dim> &p,'
p25705
aS'                              Vector<double> &  value) const override;'
p25706
aS'  };'
p25707
aS'  template <int dim>'
p25708
aS'  double StokesBoundaryValues<dim>::value(const Point<dim> & p,'
p25709
aS'                                          const unsigned int component) const'
p25710
aS'  {'
p25711
aS'    Assert(component < this->n_components,'
p25712
aS'           ExcIndexRange(component, 0, this->n_components));'
p25713
aS'    if (component == dim - 1)'
p25714
aS'      switch (dim)'
p25715
aS'        {'
p25716
aS'          case 2:'
p25717
aS'            return std::sin(numbers::PI * p[0]);'
p25718
aS'          case 3:'
p25719
aS'            return std::sin(numbers::PI * p[0]) * std::sin(numbers::PI * p[1]);'
p25720
aS'          default:'
p25721
aS'            Assert(false, ExcNotImplemented());'
p25722
aS'        }'
p25723
aS'    return 0;'
p25724
aS'  }'
p25725
aS'  template <int dim>'
p25726
aS'  void StokesBoundaryValues<dim>::vector_value(const Point<dim> &p,'
p25727
aS'                                               Vector<double> &  values) const'
p25728
aS'  {'
p25729
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p25730
aS'      values(c) = StokesBoundaryValues<dim>::value(p, c);'
p25731
aS'  }'
p25732
aS'  template <int dim>'
p25733
aS'  FluidStructureProblem<dim>::FluidStructureProblem('
p25734
aS'    const unsigned int stokes_degree,'
p25735
aS'    const unsigned int elasticity_degree)'
p25736
aS'    : stokes_degree(stokes_degree)'
p25737
aS'    , elasticity_degree(elasticity_degree)'
p25738
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p25739
aS'    , stokes_fe(FE_Q<dim>(stokes_degree + 1),'
p25740
aS'                dim,'
p25741
aS'                FE_Q<dim>(stokes_degree),'
p25742
aS'                1,'
p25743
aS'                FE_Nothing<dim>(),'
p25744
aS'                dim)'
p25745
aS'    , elasticity_fe(FE_Nothing<dim>(),'
p25746
aS'                    dim,'
p25747
aS'                    FE_Nothing<dim>(),'
p25748
aS'                    1,'
p25749
aS'                    FE_Q<dim>(elasticity_degree),'
p25750
aS'                    dim)'
p25751
aS'    , dof_handler(triangulation)'
p25752
aS'    , viscosity(2)'
p25753
aS'    , lambda(1)'
p25754
aS'    , mu(1)'
p25755
aS'  {'
p25756
aS'    fe_collection.push_back(stokes_fe);'
p25757
aS'    fe_collection.push_back(elasticity_fe);'
p25758
aS'  }'
p25759
aS'  template <int dim>'
p25760
aS'  bool FluidStructureProblem<dim>::cell_is_in_fluid_domain('
p25761
aS'    const typename DoFHandler<dim>::cell_iterator &cell)'
p25762
aS'  {'
p25763
aS'    return (cell->material_id() == fluid_domain_id);'
p25764
aS'  }'
p25765
aS'  template <int dim>'
p25766
aS'  bool FluidStructureProblem<dim>::cell_is_in_solid_domain('
p25767
aS'    const typename DoFHandler<dim>::cell_iterator &cell)'
p25768
aS'  {'
p25769
aS'    return (cell->material_id() == solid_domain_id);'
p25770
aS'  }'
p25771
aS'  template <int dim>'
p25772
aS'  void FluidStructureProblem<dim>::make_grid()'
p25773
aS'  {'
p25774
aS'    GridGenerator::subdivided_hyper_cube(triangulation, 8, -1, 1);'
p25775
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p25776
aS'      for (const auto &face : cell->face_iterators())'
p25777
aS'        if (face->at_boundary() && (face->center()[dim - 1] == 1))'
p25778
aS'          face->set_all_boundary_ids(1);'
p25779
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p25780
aS'      if (((std::fabs(cell->center()[0]) < 0.25) &&'
p25781
aS'           (cell->center()[dim - 1] > 0.5)) ||'
p25782
aS'          ((std::fabs(cell->center()[0]) >= 0.25) &&'
p25783
aS'           (cell->center()[dim - 1] > -0.5)))'
p25784
aS'        cell->set_material_id(fluid_domain_id);'
p25785
aS'      else'
p25786
aS'        cell->set_material_id(solid_domain_id);'
p25787
aS'  }'
p25788
aS'  template <int dim>'
p25789
aS'  void FluidStructureProblem<dim>::set_active_fe_indices()'
p25790
aS'  {'
p25791
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p25792
aS'      {'
p25793
aS'        if (cell_is_in_fluid_domain(cell))'
p25794
aS'          cell->set_active_fe_index(0);'
p25795
aS'        else if (cell_is_in_solid_domain(cell))'
p25796
aS'          cell->set_active_fe_index(1);'
p25797
aS'        else'
p25798
aS'          Assert(false, ExcNotImplemented());'
p25799
aS'      }'
p25800
aS'  }'
p25801
aS'  template <int dim>'
p25802
aS'  void FluidStructureProblem<dim>::setup_dofs()'
p25803
aS'  {'
p25804
aS'    set_active_fe_indices();'
p25805
aS'    dof_handler.distribute_dofs(fe_collection);'
p25806
aS'    {'
p25807
aS'      constraints.clear();'
p25808
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p25809
aS'      const FEValuesExtractors::Vector velocities(0);'
p25810
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p25811
aS'                                               1,'
p25812
aS'                                               StokesBoundaryValues<dim>(),'
p25813
aS'                                               constraints,'
p25814
aS'                                               fe_collection.component_mask('
p25815
aS'                                                 velocities));'
p25816
aS'      const FEValuesExtractors::Vector displacements(dim + 1);'
p25817
aS'      VectorTools::interpolate_boundary_values('
p25818
aS'        dof_handler,'
p25819
aS'        0,'
p25820
aS'        Functions::ZeroFunction<dim>(dim + 1 + dim),'
p25821
aS'        constraints,'
p25822
aS'        fe_collection.component_mask(displacements));'
p25823
aS'    }'
p25824
aS'    {'
p25825
aS'      std::vector<types::global_dof_index> local_face_dof_indices('
p25826
aS'        stokes_fe.n_dofs_per_face());'
p25827
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p25828
aS'        if (cell_is_in_fluid_domain(cell))'
p25829
aS'          for (const auto face_no : cell->face_indices())'
p25830
aS'            if (cell->face(face_no)->at_boundary() == false)'
p25831
aS'              {'
p25832
aS'                bool face_is_on_interface = false;'
p25833
aS'                if ((cell->neighbor(face_no)->has_children() == false) &&'
p25834
aS'                    (cell_is_in_solid_domain(cell->neighbor(face_no))))'
p25835
aS'                  face_is_on_interface = true;'
p25836
aS'                else if (cell->neighbor(face_no)->has_children() == true)'
p25837
aS'                  {'
p25838
aS'                    for (unsigned int sf = 0;'
p25839
aS'                         sf < cell->face(face_no)->n_children();'
p25840
aS'                         ++sf)'
p25841
aS'                      if (cell_is_in_solid_domain('
p25842
aS'                            cell->neighbor_child_on_subface(face_no, sf)))'
p25843
aS'                        {'
p25844
aS'                          face_is_on_interface = true;'
p25845
aS'                          break;'
p25846
aS'                        }'
p25847
aS'                  }'
p25848
aS'                if (face_is_on_interface)'
p25849
aS'                  {'
p25850
aS'                    cell->face(face_no)->get_dof_indices(local_face_dof_indices,'
p25851
aS'                                                         0);'
p25852
aS'                    for (unsigned int i = 0; i < local_face_dof_indices.size();'
p25853
aS'                         ++i)'
p25854
aS'                      if (stokes_fe.face_system_to_component_index(i).first <'
p25855
aS'                          dim)'
p25856
aS'                        constraints.add_line(local_face_dof_indices[i]);'
p25857
aS'                  }'
p25858
aS'              }'
p25859
aS'    }'
p25860
aS'    constraints.close();'
p25861
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p25862
aS'              << std::endl'
p25863
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p25864
aS'              << std::endl;'
p25865
aS'    {'
p25866
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p25867
aS'      Table<2, DoFTools::Coupling> cell_coupling(fe_collection.n_components(),'
p25868
aS'                                                 fe_collection.n_components());'
p25869
aS'      Table<2, DoFTools::Coupling> face_coupling(fe_collection.n_components(),'
p25870
aS'                                                 fe_collection.n_components());'
p25871
aS'      for (unsigned int c = 0; c < fe_collection.n_components(); ++c)'
p25872
aS'        for (unsigned int d = 0; d < fe_collection.n_components(); ++d)'
p25873
aS'          {'
p25874
aS'            if (((c < dim + 1) && (d < dim + 1) &&'
p25875
aS'                 !((c == dim) && (d == dim))) ||'
p25876
aS'                ((c >= dim + 1) && (d >= dim + 1)))'
p25877
aS'              cell_coupling[c][d] = DoFTools::always;'
p25878
aS'            if ((c >= dim + 1) && (d < dim + 1))'
p25879
aS'              face_coupling[c][d] = DoFTools::always;'
p25880
aS'          }'
p25881
aS'      DoFTools::make_flux_sparsity_pattern(dof_handler,'
p25882
aS'                                           dsp,'
p25883
aS'                                           cell_coupling,'
p25884
aS'                                           face_coupling);'
p25885
aS'      constraints.condense(dsp);'
p25886
aS'      sparsity_pattern.copy_from(dsp);'
p25887
aS'    }'
p25888
aS'    system_matrix.reinit(sparsity_pattern);'
p25889
aS'    solution.reinit(dof_handler.n_dofs());'
p25890
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p25891
aS'  }'
p25892
aS'  template <int dim>'
p25893
aS'  void FluidStructureProblem<dim>::assemble_system()'
p25894
aS'  {'
p25895
aS'    system_matrix = 0;'
p25896
aS'    system_rhs    = 0;'
p25897
aS'    const QGauss<dim> stokes_quadrature(stokes_degree + 2);'
p25898
aS'    const QGauss<dim> elasticity_quadrature(elasticity_degree + 2);'
p25899
aS'    hp::QCollection<dim> q_collection;'
p25900
aS'    q_collection.push_back(stokes_quadrature);'
p25901
aS'    q_collection.push_back(elasticity_quadrature);'
p25902
aS'    hp::FEValues<dim> hp_fe_values(fe_collection,'
p25903
aS'                                   q_collection,'
p25904
aS'                                   update_values | update_quadrature_points |'
p25905
aS'                                     update_JxW_values | update_gradients);'
p25906
aS'    const QGauss<dim - 1> common_face_quadrature('
p25907
aS'      std::max(stokes_degree + 2, elasticity_degree + 2));'
p25908
aS'    FEFaceValues<dim>    stokes_fe_face_values(stokes_fe,'
p25909
aS'                                            common_face_quadrature,'
p25910
aS'                                            update_JxW_values |'
p25911
aS'                                              update_gradients | update_values);'
p25912
aS'    FEFaceValues<dim>    elasticity_fe_face_values(elasticity_fe,'
p25913
aS'                                                common_face_quadrature,'
p25914
aS'                                                update_normal_vectors |'
p25915
aS'                                                  update_values);'
p25916
aS'    FESubfaceValues<dim> stokes_fe_subface_values(stokes_fe,'
p25917
aS'                                                  common_face_quadrature,'
p25918
aS'                                                  update_JxW_values |'
p25919
aS'                                                    update_gradients |'
p25920
aS'                                                    update_values);'
p25921
aS'    FESubfaceValues<dim> elasticity_fe_subface_values(elasticity_fe,'
p25922
aS'                                                      common_face_quadrature,'
p25923
aS'                                                      update_normal_vectors |'
p25924
aS'                                                        update_values);'
p25925
aS'    const unsigned int stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p25926
aS'    const unsigned int elasticity_dofs_per_cell ='
p25927
aS'      elasticity_fe.n_dofs_per_cell();'
p25928
aS'    FullMatrix<double> local_matrix;'
p25929
aS'    FullMatrix<double> local_interface_matrix(elasticity_dofs_per_cell,'
p25930
aS'                                              stokes_dofs_per_cell);'
p25931
aS'    Vector<double>     local_rhs;'
p25932
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p25933
aS'    std::vector<types::global_dof_index> neighbor_dof_indices('
p25934
aS'      stokes_dofs_per_cell);'
p25935
aS'    const Functions::ZeroFunction<dim> right_hand_side(dim + 1);'
p25936
aS'    const FEValuesExtractors::Vector velocities(0);'
p25937
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p25938
aS'    const FEValuesExtractors::Vector displacements(dim + 1);'
p25939
aS'    std::vector<SymmetricTensor<2, dim>> stokes_symgrad_phi_u('
p25940
aS'      stokes_dofs_per_cell);'
p25941
aS'    std::vector<double> stokes_div_phi_u(stokes_dofs_per_cell);'
p25942
aS'    std::vector<double> stokes_phi_p(stokes_dofs_per_cell);'
p25943
aS'    std::vector<Tensor<2, dim>> elasticity_grad_phi(elasticity_dofs_per_cell);'
p25944
aS'    std::vector<double>         elasticity_div_phi(elasticity_dofs_per_cell);'
p25945
aS'    std::vector<Tensor<1, dim>> elasticity_phi(elasticity_dofs_per_cell);'
p25946
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p25947
aS'      {'
p25948
aS'        hp_fe_values.reinit(cell);'
p25949
aS'        const FEValues<dim> &fe_values = hp_fe_values.get_present_fe_values();'
p25950
aS'        local_matrix.reinit(cell->get_fe().n_dofs_per_cell(),'
p25951
aS'                            cell->get_fe().n_dofs_per_cell());'
p25952
aS'        local_rhs.reinit(cell->get_fe().n_dofs_per_cell());'
p25953
aS'        if (cell_is_in_fluid_domain(cell))'
p25954
aS'          {'
p25955
aS'            const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();'
p25956
aS'            Assert(dofs_per_cell == stokes_dofs_per_cell, ExcInternalError());'
p25957
aS'            for (unsigned int q = 0; q < fe_values.n_quadrature_points; ++q)'
p25958
aS'              {'
p25959
aS'                for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p25960
aS'                  {'
p25961
aS'                    stokes_symgrad_phi_u[k] ='
p25962
aS'                      fe_values[velocities].symmetric_gradient(k, q);'
p25963
aS'                    stokes_div_phi_u[k] ='
p25964
aS'                      fe_values[velocities].divergence(k, q);'
p25965
aS'                    stokes_phi_p[k] = fe_values[pressure].value(k, q);'
p25966
aS'                  }'
p25967
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p25968
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p25969
aS'                    local_matrix(i, j) +='
p25970
aS'                      (2 * viscosity * stokes_symgrad_phi_u[i] *'
p25971
aS'                         stokes_symgrad_phi_u[j] -'
p25972
aS'                       stokes_div_phi_u[i] * stokes_phi_p[j] -'
p25973
aS'                       stokes_phi_p[i] * stokes_div_phi_u[j]) *'
p25974
aS'                      fe_values.JxW(q);'
p25975
aS'              }'
p25976
aS'          }'
p25977
aS'        else'
p25978
aS'          {'
p25979
aS'            const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();'
p25980
aS'            Assert(dofs_per_cell == elasticity_dofs_per_cell,'
p25981
aS'                   ExcInternalError());'
p25982
aS'            for (unsigned int q = 0; q < fe_values.n_quadrature_points; ++q)'
p25983
aS'              {'
p25984
aS'                for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p25985
aS'                  {'
p25986
aS'                    elasticity_grad_phi[k] ='
p25987
aS'                      fe_values[displacements].gradient(k, q);'
p25988
aS'                    elasticity_div_phi[k] ='
p25989
aS'                      fe_values[displacements].divergence(k, q);'
p25990
aS'                  }'
p25991
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p25992
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p25993
aS'                    {'
p25994
aS'                      local_matrix(i, j) +='
p25995
aS'                        (lambda * elasticity_div_phi[i] *'
p25996
aS'                           elasticity_div_phi[j] +'
p25997
aS'                         mu * scalar_product(elasticity_grad_phi[i],'
p25998
aS'                                             elasticity_grad_phi[j]) +'
p25999
aS'                         mu *'
p26000
aS'                           scalar_product(elasticity_grad_phi[i],'
p26001
aS'                                          transpose(elasticity_grad_phi[j]))) *'
p26002
aS'                        fe_values.JxW(q);'
p26003
aS'                    }'
p26004
aS'              }'
p26005
aS'          }'
p26006
aS'        local_dof_indices.resize(cell->get_fe().n_dofs_per_cell());'
p26007
aS'        cell->get_dof_indices(local_dof_indices);'
p26008
aS'        constraints.distribute_local_to_global(local_matrix,'
p26009
aS'                                               local_rhs,'
p26010
aS'                                               local_dof_indices,'
p26011
aS'                                               system_matrix,'
p26012
aS'                                               system_rhs);'
p26013
aS'        if (cell_is_in_solid_domain(cell))'
p26014
aS'          for (const auto f : cell->face_indices())'
p26015
aS'            if (cell->face(f)->at_boundary() == false)'
p26016
aS'              {'
p26017
aS'                if ((cell->neighbor(f)->level() == cell->level()) &&'
p26018
aS'                    (cell->neighbor(f)->has_children() == false) &&'
p26019
aS'                    cell_is_in_fluid_domain(cell->neighbor(f)))'
p26020
aS'                  {'
p26021
aS'                    elasticity_fe_face_values.reinit(cell, f);'
p26022
aS'                    stokes_fe_face_values.reinit(cell->neighbor(f),'
p26023
aS'                                                 cell->neighbor_of_neighbor(f));'
p26024
aS'                    assemble_interface_term(elasticity_fe_face_values,'
p26025
aS'                                            stokes_fe_face_values,'
p26026
aS'                                            elasticity_phi,'
p26027
aS'                                            stokes_symgrad_phi_u,'
p26028
aS'                                            stokes_phi_p,'
p26029
aS'                                            local_interface_matrix);'
p26030
aS'                    cell->neighbor(f)->get_dof_indices(neighbor_dof_indices);'
p26031
aS'                    constraints.distribute_local_to_global('
p26032
aS'                      local_interface_matrix,'
p26033
aS'                      local_dof_indices,'
p26034
aS'                      neighbor_dof_indices,'
p26035
aS'                      system_matrix);'
p26036
aS'                  }'
p26037
aS'                else if ((cell->neighbor(f)->level() == cell->level()) &&'
p26038
aS'                         (cell->neighbor(f)->has_children() == true))'
p26039
aS'                  {'
p26040
aS'                    for (unsigned int subface = 0;'
p26041
aS'                         subface < cell->face(f)->n_children();'
p26042
aS'                         ++subface)'
p26043
aS'                      if (cell_is_in_fluid_domain('
p26044
aS'                            cell->neighbor_child_on_subface(f, subface)))'
p26045
aS'                        {'
p26046
aS'                          elasticity_fe_subface_values.reinit(cell, f, subface);'
p26047
aS'                          stokes_fe_face_values.reinit('
p26048
aS'                            cell->neighbor_child_on_subface(f, subface),'
p26049
aS'                            cell->neighbor_of_neighbor(f));'
p26050
aS'                          assemble_interface_term(elasticity_fe_subface_values,'
p26051
aS'                                                  stokes_fe_face_values,'
p26052
aS'                                                  elasticity_phi,'
p26053
aS'                                                  stokes_symgrad_phi_u,'
p26054
aS'                                                  stokes_phi_p,'
p26055
aS'                                                  local_interface_matrix);'
p26056
aS'                          cell->neighbor_child_on_subface(f, subface)'
p26057
aS'                            ->get_dof_indices(neighbor_dof_indices);'
p26058
aS'                          constraints.distribute_local_to_global('
p26059
aS'                            local_interface_matrix,'
p26060
aS'                            local_dof_indices,'
p26061
aS'                            neighbor_dof_indices,'
p26062
aS'                            system_matrix);'
p26063
aS'                        }'
p26064
aS'                  }'
p26065
aS'                else if (cell->neighbor_is_coarser(f) &&'
p26066
aS'                         cell_is_in_fluid_domain(cell->neighbor(f)))'
p26067
aS'                  {'
p26068
aS'                    elasticity_fe_face_values.reinit(cell, f);'
p26069
aS'                    stokes_fe_subface_values.reinit('
p26070
aS'                      cell->neighbor(f),'
p26071
aS'                      cell->neighbor_of_coarser_neighbor(f).first,'
p26072
aS'                      cell->neighbor_of_coarser_neighbor(f).second);'
p26073
aS'                    assemble_interface_term(elasticity_fe_face_values,'
p26074
aS'                                            stokes_fe_subface_values,'
p26075
aS'                                            elasticity_phi,'
p26076
aS'                                            stokes_symgrad_phi_u,'
p26077
aS'                                            stokes_phi_p,'
p26078
aS'                                            local_interface_matrix);'
p26079
aS'                    cell->neighbor(f)->get_dof_indices(neighbor_dof_indices);'
p26080
aS'                    constraints.distribute_local_to_global('
p26081
aS'                      local_interface_matrix,'
p26082
aS'                      local_dof_indices,'
p26083
aS'                      neighbor_dof_indices,'
p26084
aS'                      system_matrix);'
p26085
aS'                  }'
p26086
aS'              }'
p26087
aS'      }'
p26088
aS'  }'
p26089
aS'  template <int dim>'
p26090
aS'  void FluidStructureProblem<dim>::assemble_interface_term('
p26091
aS'    const FEFaceValuesBase<dim> &         elasticity_fe_face_values,'
p26092
aS'    const FEFaceValuesBase<dim> &         stokes_fe_face_values,'
p26093
aS'    std::vector<Tensor<1, dim>> &         elasticity_phi,'
p26094
aS'    std::vector<SymmetricTensor<2, dim>> &stokes_symgrad_phi_u,'
p26095
aS'    std::vector<double> &                 stokes_phi_p,'
p26096
aS'    FullMatrix<double> &                  local_interface_matrix) const'
p26097
aS'  {'
p26098
aS'    Assert(stokes_fe_face_values.n_quadrature_points =='
p26099
aS'             elasticity_fe_face_values.n_quadrature_points,'
p26100
aS'           ExcInternalError());'
p26101
aS'    const unsigned int n_face_quadrature_points ='
p26102
aS'      elasticity_fe_face_values.n_quadrature_points;'
p26103
aS'    const FEValuesExtractors::Vector velocities(0);'
p26104
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p26105
aS'    const FEValuesExtractors::Vector displacements(dim + 1);'
p26106
aS'    local_interface_matrix = 0;'
p26107
aS'    for (unsigned int q = 0; q < n_face_quadrature_points; ++q)'
p26108
aS'      {'
p26109
aS'        const Tensor<1, dim> normal_vector ='
p26110
aS'          elasticity_fe_face_values.normal_vector(q);'
p26111
aS'        for (unsigned int k = 0; k < stokes_fe_face_values.dofs_per_cell; ++k)'
p26112
aS'          {'
p26113
aS'            stokes_symgrad_phi_u[k] ='
p26114
aS'              stokes_fe_face_values[velocities].symmetric_gradient(k, q);'
p26115
aS'            stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);'
p26116
aS'          }'
p26117
aS'        for (unsigned int k = 0; k < elasticity_fe_face_values.dofs_per_cell;'
p26118
aS'             ++k)'
p26119
aS'          elasticity_phi[k] ='
p26120
aS'            elasticity_fe_face_values[displacements].value(k, q);'
p26121
aS'        for (unsigned int i = 0; i < elasticity_fe_face_values.dofs_per_cell;'
p26122
aS'             ++i)'
p26123
aS'          for (unsigned int j = 0; j < stokes_fe_face_values.dofs_per_cell; ++j)'
p26124
aS'            local_interface_matrix(i, j) +='
p26125
aS'              -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -'
p26126
aS'                 stokes_phi_p[j] * normal_vector) *'
p26127
aS'                elasticity_phi[i] * stokes_fe_face_values.JxW(q));'
p26128
aS'      }'
p26129
aS'  }'
p26130
aS'  template <int dim>'
p26131
aS'  void FluidStructureProblem<dim>::solve()'
p26132
aS'  {'
p26133
aS'    SparseDirectUMFPACK direct_solver;'
p26134
aS'    direct_solver.initialize(system_matrix);'
p26135
aS'    direct_solver.vmult(solution, system_rhs);'
p26136
aS'    constraints.distribute(solution);'
p26137
aS'  }'
p26138
aS'  template <int dim>'
p26139
aS'  void FluidStructureProblem<dim>::output_results('
p26140
aS'    const unsigned int refinement_cycle) const'
p26141
aS'  {'
p26142
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p26143
aS'    solution_names.emplace_back("pressure");'
p26144
aS'    for (unsigned int d = 0; d < dim; ++d)'
p26145
aS'      solution_names.emplace_back("displacement");'
p26146
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p26147
aS'      data_component_interpretation('
p26148
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p26149
aS'    data_component_interpretation.push_back('
p26150
aS'      DataComponentInterpretation::component_is_scalar);'
p26151
aS'    for (unsigned int d = 0; d < dim; ++d)'
p26152
aS'      data_component_interpretation.push_back('
p26153
aS'        DataComponentInterpretation::component_is_part_of_vector);'
p26154
aS'    DataOut<dim> data_out;'
p26155
aS'    data_out.attach_dof_handler(dof_handler);'
p26156
aS'    data_out.add_data_vector(solution,'
p26157
aS'                             solution_names,'
p26158
aS'                             DataOut<dim>::type_dof_data,'
p26159
aS'                             data_component_interpretation);'
p26160
aS'    data_out.build_patches();'
p26161
aS'    std::ofstream output('
p26162
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk");'
p26163
aS'    data_out.write_vtk(output);'
p26164
aS'  }'
p26165
aS'  template <int dim>'
p26166
aS'  void FluidStructureProblem<dim>::refine_mesh()'
p26167
aS'  {'
p26168
aS'    Vector<float> stokes_estimated_error_per_cell('
p26169
aS'      triangulation.n_active_cells());'
p26170
aS'    Vector<float> elasticity_estimated_error_per_cell('
p26171
aS'      triangulation.n_active_cells());'
p26172
aS'    const QGauss<dim - 1> stokes_face_quadrature(stokes_degree + 2);'
p26173
aS'    const QGauss<dim - 1> elasticity_face_quadrature(elasticity_degree + 2);'
p26174
aS'    hp::QCollection<dim - 1> face_q_collection;'
p26175
aS'    face_q_collection.push_back(stokes_face_quadrature);'
p26176
aS'    face_q_collection.push_back(elasticity_face_quadrature);'
p26177
aS'    const FEValuesExtractors::Vector velocities(0);'
p26178
aS'    KellyErrorEstimator<dim>::estimate('
p26179
aS'      dof_handler,'
p26180
aS'      face_q_collection,'
p26181
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p26182
aS'      solution,'
p26183
aS'      stokes_estimated_error_per_cell,'
p26184
aS'      fe_collection.component_mask(velocities));'
p26185
aS'    const FEValuesExtractors::Vector displacements(dim + 1);'
p26186
aS'    KellyErrorEstimator<dim>::estimate('
p26187
aS'      dof_handler,'
p26188
aS'      face_q_collection,'
p26189
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p26190
aS'      solution,'
p26191
aS'      elasticity_estimated_error_per_cell,'
p26192
aS'      fe_collection.component_mask(displacements));'
p26193
aS'    stokes_estimated_error_per_cell *='
p26194
aS'      4. / stokes_estimated_error_per_cell.l2_norm();'
p26195
aS'    elasticity_estimated_error_per_cell *='
p26196
aS'      1. / elasticity_estimated_error_per_cell.l2_norm();'
p26197
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p26198
aS'    estimated_error_per_cell += stokes_estimated_error_per_cell;'
p26199
aS'    estimated_error_per_cell += elasticity_estimated_error_per_cell;'
p26200
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p26201
aS'      for (const auto f : cell->face_indices())'
p26202
aS'        if (cell_is_in_solid_domain(cell))'
p26203
aS'          {'
p26204
aS'            if ((cell->at_boundary(f) == false) &&'
p26205
aS'                (((cell->neighbor(f)->level() == cell->level()) &&'
p26206
aS'                  (cell->neighbor(f)->has_children() == false) &&'
p26207
aS'                  cell_is_in_fluid_domain(cell->neighbor(f))) ||'
p26208
aS'                 ((cell->neighbor(f)->level() == cell->level()) &&'
p26209
aS'                  (cell->neighbor(f)->has_children() == true) &&'
p26210
aS'                  (cell_is_in_fluid_domain('
p26211
aS'                    cell->neighbor_child_on_subface(f, 0)))) ||'
p26212
aS'                 (cell->neighbor_is_coarser(f) &&'
p26213
aS'                  cell_is_in_fluid_domain(cell->neighbor(f)))))'
p26214
aS'              estimated_error_per_cell(cell->active_cell_index()) = 0;'
p26215
aS'          }'
p26216
aS'        else'
p26217
aS'          {'
p26218
aS'            if ((cell->at_boundary(f) == false) &&'
p26219
aS'                (((cell->neighbor(f)->level() == cell->level()) &&'
p26220
aS'                  (cell->neighbor(f)->has_children() == false) &&'
p26221
aS'                  cell_is_in_solid_domain(cell->neighbor(f))) ||'
p26222
aS'                 ((cell->neighbor(f)->level() == cell->level()) &&'
p26223
aS'                  (cell->neighbor(f)->has_children() == true) &&'
p26224
aS'                  (cell_is_in_solid_domain('
p26225
aS'                    cell->neighbor_child_on_subface(f, 0)))) ||'
p26226
aS'                 (cell->neighbor_is_coarser(f) &&'
p26227
aS'                  cell_is_in_solid_domain(cell->neighbor(f)))))'
p26228
aS'              estimated_error_per_cell(cell->active_cell_index()) = 0;'
p26229
aS'          }'
p26230
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p26231
aS'                                                    estimated_error_per_cell,'
p26232
aS'                                                    0.3,'
p26233
aS'                                                    0.0);'
p26234
aS'    triangulation.execute_coarsening_and_refinement();'
p26235
aS'  }'
p26236
aS'  template <int dim>'
p26237
aS'  void FluidStructureProblem<dim>::run()'
p26238
aS'  {'
p26239
aS'    make_grid();'
p26240
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 10 - 2 * dim;'
p26241
aS'         ++refinement_cycle)'
p26242
aS'      {'
p26243
aS'        std::cout << "Refinement cycle " << refinement_cycle << std::endl;'
p26244
aS'        if (refinement_cycle > 0)'
p26245
aS'          refine_mesh();'
p26246
aS'        setup_dofs();'
p26247
aS'        std::cout << "   Assembling..." << std::endl;'
p26248
aS'        assemble_system();'
p26249
aS'        std::cout << "   Solving..." << std::endl;'
p26250
aS'        solve();'
p26251
aS'        std::cout << "   Writing output..." << std::endl;'
p26252
aS'        output_results(refinement_cycle);'
p26253
aS'        std::cout << std::endl;'
p26254
aS'      }'
p26255
aS'  }'
p26256
aS'} // namespace Step46'
p26257
aS'int main()'
p26258
ag24
aS'  try'
p26259
aS'    {'
p26260
aS'      using namespace Step46;'
p26261
aS'      FluidStructureProblem<2> flow_problem(1, 1);'
p26262
aS'      flow_problem.run();'
p26263
aS'    }'
p26264
aS'  catch (std::exception &exc)'
p26265
aS'    {'
p26266
aS'      std::cerr << std::endl'
p26267
aS'                << std::endl'
p26268
aS'                << "----------------------------------------------------"'
p26269
aS'                << std::endl;'
p26270
aS'      std::cerr << "Exception on processing: " << std::endl'
p26271
aS'                << exc.what() << std::endl'
p26272
aS'                << "Aborting!" << std::endl'
p26273
aS'                << "----------------------------------------------------"'
p26274
aS'                << std::endl;'
p26275
aS'      return 1;'
p26276
aS'    }'
p26277
aS'  catch (...)'
p26278
aS'    {'
p26279
aS'      std::cerr << std::endl'
p26280
aS'                << std::endl'
p26281
aS'                << "----------------------------------------------------"'
p26282
aS'                << std::endl;'
p26283
aS'      std::cerr << "Unknown exception!" << std::endl'
p26284
aS'                << "Aborting!" << std::endl'
p26285
aS'                << "----------------------------------------------------"'
p26286
aS'                << std::endl;'
p26287
aS'      return 1;'
p26288
aS'    }'
p26289
aS'  return 0;'
p26290
ag32
aS'/* ---------------------------------------------------------------------'
p26291
aS' *'
p26292
aS' * Copyright (C) 2019 - 2021 by the deal.II authors'
p26293
aS' *'
p26294
aS' * This file is part of the deal.II library.'
p26295
aS' *'
p26296
aS' * The deal.II library is free software; you can use it, redistribute'
p26297
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p26298
aS' * Public License as published by the Free Software Foundation; either'
p26299
aS' * version 2.1 of the License, or (at your option) any later version.'
p26300
aS' * The full text of the license can be found in the file LICENSE.md at'
p26301
aS' * the top level directory of deal.II.'
p26302
aS' *'
p26303
aS' * ---------------------------------------------------------------------'
p26304
aS' *'
p26305
aS' * Authors: Natasha Sharma, University of Texas at El Paso,'
p26306
aS' *          Guido Kanschat, University of Heidelberg'
p26307
aS' *          Timo Heister, Clemson University'
p26308
aS' *          Wolfgang Bangerth, Colorado State University'
p26309
aS' *          Zhuroan Wang, Colorado State University'
p26310
aS' */'
p26311
aS'#include <deal.II/base/quadrature_lib.h>'
p26312
aS'#include <deal.II/base/function.h>'
p26313
aS'#include <deal.II/lac/vector.h>'
p26314
aS'#include <deal.II/lac/full_matrix.h>'
p26315
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p26316
aS'#include <deal.II/lac/solver_cg.h>'
p26317
aS'#include <deal.II/lac/sparse_matrix.h>'
p26318
aS'#include <deal.II/lac/sparse_direct.h>'
p26319
aS'#include <deal.II/grid/tria.h>'
p26320
aS'#include <deal.II/grid/grid_generator.h>'
p26321
aS'#include <deal.II/fe/fe_q.h>'
p26322
aS'#include <deal.II/fe/fe_values.h>'
p26323
aS'#include <deal.II/fe/mapping_q.h>'
p26324
aS'#include <deal.II/dofs/dof_handler.h>'
p26325
aS'#include <deal.II/dofs/dof_tools.h>'
p26326
aS'#include <deal.II/numerics/vector_tools.h>'
p26327
aS'#include <deal.II/numerics/data_out.h>'
p26328
aS'#include <deal.II/fe/fe_interface_values.h>'
p26329
aS'#include <deal.II/meshworker/mesh_loop.h>'
p26330
aS'#include <fstream>'
p26331
aS'#include <iostream>'
p26332
aS'#include <cmath>'
p26333
aS'namespace Step47'
p26334
ag24
aS'  using namespace dealii;'
p26335
aS'  namespace ExactSolution'
p26336
aS'  {'
p26337
aS'    using numbers::PI;'
p26338
aS'    template <int dim>'
p26339
aS'    class Solution : public Function<dim>'
p26340
aS'    {'
p26341
aS'    public:'
p26342
aS'      static_assert(dim == 2, "Only dim==2 is implemented.");'
p26343
aS'      virtual double value(const Point<dim> &p,'
p26344
aS'                           const unsigned int /*component*/ = 0) const override'
p26345
aS'      {'
p26346
aS'        return std::sin(PI * p[0]) * std::sin(PI * p[1]);'
p26347
aS'      }'
p26348
aS'      virtual Tensor<1, dim>'
p26349
aS'      gradient(const Point<dim> &p,'
p26350
aS'               const unsigned int /*component*/ = 0) const override'
p26351
aS'      {'
p26352
aS'        Tensor<1, dim> r;'
p26353
aS'        r[0] = PI * std::cos(PI * p[0]) * std::sin(PI * p[1]);'
p26354
aS'        r[1] = PI * std::cos(PI * p[1]) * std::sin(PI * p[0]);'
p26355
aS'        return r;'
p26356
aS'      }'
p26357
aS'      virtual void'
p26358
aS'      hessian_list(const std::vector<Point<dim>> &       points,'
p26359
aS'                   std::vector<SymmetricTensor<2, dim>> &hessians,'
p26360
aS'                   const unsigned int /*component*/ = 0) const override'
p26361
aS'      {'
p26362
aS'        for (unsigned i = 0; i < points.size(); ++i)'
p26363
aS'          {'
p26364
aS'            const double x = points[i][0];'
p26365
aS'            const double y = points[i][1];'
p26366
aS'            hessians[i][0][0] = -PI * PI * std::sin(PI * x) * std::sin(PI * y);'
p26367
aS'            hessians[i][0][1] = PI * PI * std::cos(PI * x) * std::cos(PI * y);'
p26368
aS'            hessians[i][1][1] = -PI * PI * std::sin(PI * x) * std::sin(PI * y);'
p26369
aS'          }'
p26370
aS'      }'
p26371
aS'    };'
p26372
aS'    template <int dim>'
p26373
aS'    class RightHandSide : public Function<dim>'
p26374
aS'    {'
p26375
aS'    public:'
p26376
aS'      static_assert(dim == 2, "Only dim==2 is implemented");'
p26377
aS'      virtual double value(const Point<dim> &p,'
p26378
aS'                           const unsigned int /*component*/ = 0) const override'
p26379
aS'      {'
p26380
aS'        return 4 * std::pow(PI, 4.0) * std::sin(PI * p[0]) *'
p26381
aS'               std::sin(PI * p[1]);'
p26382
aS'      }'
p26383
aS'    };'
p26384
aS'  } // namespace ExactSolution'
p26385
aS'  template <int dim>'
p26386
aS'  class BiharmonicProblem'
p26387
aS'  {'
p26388
aS'  public:'
p26389
aS'    BiharmonicProblem(const unsigned int fe_degree);'
p26390
aS'    void run();'
p26391
aS'  private:'
p26392
aS'    void make_grid();'
p26393
aS'    void setup_system();'
p26394
aS'    void assemble_system();'
p26395
aS'    void solve();'
p26396
aS'    void compute_errors();'
p26397
aS'    void output_results(const unsigned int iteration) const;'
p26398
aS'    Triangulation<dim> triangulation;'
p26399
aS'    MappingQ<dim> mapping;'
p26400
aS'    FE_Q<dim>                 fe;'
p26401
aS'    DoFHandler<dim>           dof_handler;'
p26402
aS'    AffineConstraints<double> constraints;'
p26403
aS'    SparsityPattern      sparsity_pattern;'
p26404
aS'    SparseMatrix<double> system_matrix;'
p26405
aS'    Vector<double> solution;'
p26406
aS'    Vector<double> system_rhs;'
p26407
aS'  };'
p26408
aS'  template <int dim>'
p26409
aS'  BiharmonicProblem<dim>::BiharmonicProblem(const unsigned int fe_degree)'
p26410
aS'    : mapping(1)'
p26411
aS'    , fe(fe_degree)'
p26412
aS'    , dof_handler(triangulation)'
p26413
aS'  {}'
p26414
aS'  template <int dim>'
p26415
aS'  void BiharmonicProblem<dim>::make_grid()'
p26416
aS'  {'
p26417
aS'    GridGenerator::hyper_cube(triangulation, 0., 1.);'
p26418
aS'    triangulation.refine_global(1);'
p26419
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p26420
aS'              << std::endl'
p26421
aS'              << "Total number of cells: " << triangulation.n_cells()'
p26422
aS'              << std::endl;'
p26423
aS'  }'
p26424
aS'  template <int dim>'
p26425
aS'  void BiharmonicProblem<dim>::setup_system()'
p26426
aS'  {'
p26427
aS'    dof_handler.distribute_dofs(fe);'
p26428
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p26429
aS'              << std::endl;'
p26430
aS'    constraints.clear();'
p26431
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p26432
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p26433
aS'                                             0,'
p26434
aS'                                             ExactSolution::Solution<dim>(),'
p26435
aS'                                             constraints);'
p26436
aS'    constraints.close();'
p26437
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p26438
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp, constraints, true);'
p26439
aS'    sparsity_pattern.copy_from(dsp);'
p26440
aS'    system_matrix.reinit(sparsity_pattern);'
p26441
aS'    solution.reinit(dof_handler.n_dofs());'
p26442
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p26443
aS'  }'
p26444
aS'  template <int dim>'
p26445
aS'  struct ScratchData'
p26446
aS'  {'
p26447
aS'    ScratchData(const Mapping<dim> &      mapping,'
p26448
aS'                const FiniteElement<dim> &fe,'
p26449
aS'                const unsigned int        quadrature_degree,'
p26450
aS'                const UpdateFlags         update_flags,'
p26451
aS'                const UpdateFlags         interface_update_flags)'
p26452
aS'      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)'
p26453
aS'      , fe_interface_values(mapping,'
p26454
aS'                            fe,'
p26455
aS'                            QGauss<dim - 1>(quadrature_degree),'
p26456
aS'                            interface_update_flags)'
p26457
aS'    {}'
p26458
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p26459
aS'      : fe_values(scratch_data.fe_values.get_mapping(),'
p26460
aS'                  scratch_data.fe_values.get_fe(),'
p26461
aS'                  scratch_data.fe_values.get_quadrature(),'
p26462
aS'                  scratch_data.fe_values.get_update_flags())'
p26463
aS'      , fe_interface_values(scratch_data.fe_values.get_mapping(),'
p26464
aS'                            scratch_data.fe_values.get_fe(),'
p26465
aS'                            scratch_data.fe_interface_values.get_quadrature(),'
p26466
aS'                            scratch_data.fe_interface_values.get_update_flags())'
p26467
aS'    {}'
p26468
aS'    FEValues<dim>          fe_values;'
p26469
aS'    FEInterfaceValues<dim> fe_interface_values;'
p26470
aS'  };'
p26471
aS'  struct CopyData'
p26472
aS'  {'
p26473
aS'    CopyData(const unsigned int dofs_per_cell)'
p26474
aS'      : cell_matrix(dofs_per_cell, dofs_per_cell)'
p26475
aS'      , cell_rhs(dofs_per_cell)'
p26476
aS'      , local_dof_indices(dofs_per_cell)'
p26477
aS'    {}'
p26478
aS'    CopyData(const CopyData &) = default;'
p26479
aS'    CopyData(CopyData &&) = default;'
p26480
aS'    ~CopyData() = default;'
p26481
aS'    CopyData &operator=(const CopyData &) = default;'
p26482
aS'    CopyData &operator=(CopyData &&) = default;'
p26483
aS'    struct FaceData'
p26484
aS'    {'
p26485
aS'      FullMatrix<double>                   cell_matrix;'
p26486
aS'      std::vector<types::global_dof_index> joint_dof_indices;'
p26487
aS'    };'
p26488
aS'    FullMatrix<double>                   cell_matrix;'
p26489
aS'    Vector<double>                       cell_rhs;'
p26490
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p26491
aS'    std::vector<FaceData>                face_data;'
p26492
aS'  };'
p26493
aS'  template <int dim>'
p26494
aS'  void BiharmonicProblem<dim>::assemble_system()'
p26495
aS'  {'
p26496
aS'    using Iterator = typename DoFHandler<dim>::active_cell_iterator;'
p26497
aS'    auto cell_worker = [&](const Iterator &  cell,'
p26498
aS'                           ScratchData<dim> &scratch_data,'
p26499
aS'                           CopyData &        copy_data) {'
p26500
aS'      copy_data.cell_matrix = 0;'
p26501
aS'      copy_data.cell_rhs    = 0;'
p26502
aS'      FEValues<dim> &fe_values = scratch_data.fe_values;'
p26503
aS'      fe_values.reinit(cell);'
p26504
aS'      cell->get_dof_indices(copy_data.local_dof_indices);'
p26505
aS'      const ExactSolution::RightHandSide<dim> right_hand_side;'
p26506
aS'      const unsigned int dofs_per_cell ='
p26507
aS'        scratch_data.fe_values.get_fe().n_dofs_per_cell();'
p26508
aS'      for (unsigned int qpoint = 0; qpoint < fe_values.n_quadrature_points;'
p26509
aS'           ++qpoint)'
p26510
aS'        {'
p26511
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p26512
aS'            {'
p26513
aS'              const Tensor<2, dim> &hessian_i ='
p26514
aS'                fe_values.shape_hessian(i, qpoint);'
p26515
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p26516
aS'                {'
p26517
aS'                  const Tensor<2, dim> &hessian_j ='
p26518
aS'                    fe_values.shape_hessian(j, qpoint);'
p26519
aS'                  copy_data.cell_matrix(i, j) +='
p26520
aS'                    scalar_product(hessian_i,   // nabla^2 phi_i(x)'
p26521
aS'                                   hessian_j) * // nabla^2 phi_j(x)'
p26522
aS'                    fe_values.JxW(qpoint);      // dx'
p26523
aS'                }'
p26524
aS'              copy_data.cell_rhs(i) +='
p26525
aS'                fe_values.shape_value(i, qpoint) * // phi_i(x)'
p26526
aS'                right_hand_side.value('
p26527
aS'                  fe_values.quadrature_point(qpoint)) * // f(x)'
p26528
aS'                fe_values.JxW(qpoint);                  // dx'
p26529
aS'            }'
p26530
aS'        }'
p26531
aS'    };'
p26532
aS'    auto face_worker = [&](const Iterator &    cell,'
p26533
aS'                           const unsigned int &f,'
p26534
aS'                           const unsigned int &sf,'
p26535
aS'                           const Iterator &    ncell,'
p26536
aS'                           const unsigned int &nf,'
p26537
aS'                           const unsigned int &nsf,'
p26538
aS'                           ScratchData<dim> &  scratch_data,'
p26539
aS'                           CopyData &          copy_data) {'
p26540
aS'      FEInterfaceValues<dim> &fe_interface_values ='
p26541
aS'        scratch_data.fe_interface_values;'
p26542
aS'      fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf);'
p26543
aS'      copy_data.face_data.emplace_back();'
p26544
aS'      CopyData::FaceData &copy_data_face = copy_data.face_data.back();'
p26545
aS'      copy_data_face.joint_dof_indices ='
p26546
aS'        fe_interface_values.get_interface_dof_indices();'
p26547
aS'      const unsigned int n_interface_dofs ='
p26548
aS'        fe_interface_values.n_current_interface_dofs();'
p26549
aS'      copy_data_face.cell_matrix.reinit(n_interface_dofs, n_interface_dofs);'
p26550
aS'      const unsigned int p = fe.degree;'
p26551
aS'      const double       gamma_over_h ='
p26552
aS'        std::max((1.0 * p * (p + 1) /'
p26553
aS'                  cell->extent_in_direction('
p26554
aS'                    GeometryInfo<dim>::unit_normal_direction[f])),'
p26555
aS'                 (1.0 * p * (p + 1) /'
p26556
aS'                  ncell->extent_in_direction('
p26557
aS'                    GeometryInfo<dim>::unit_normal_direction[nf])));'
p26558
aS'      for (unsigned int qpoint = 0;'
p26559
aS'           qpoint < fe_interface_values.n_quadrature_points;'
p26560
aS'           ++qpoint)'
p26561
aS'        {'
p26562
aS'          const auto &n = fe_interface_values.normal(qpoint);'
p26563
aS'          for (unsigned int i = 0; i < n_interface_dofs; ++i)'
p26564
aS'            {'
p26565
aS'              const double av_hessian_i_dot_n_dot_n ='
p26566
aS'                (fe_interface_values.average_hessian(i, qpoint) * n * n);'
p26567
aS'              const double jump_grad_i_dot_n ='
p26568
aS'                (fe_interface_values.jump_gradient(i, qpoint) * n);'
p26569
aS'              for (unsigned int j = 0; j < n_interface_dofs; ++j)'
p26570
aS'                {'
p26571
aS'                  const double av_hessian_j_dot_n_dot_n ='
p26572
aS'                    (fe_interface_values.average_hessian(j, qpoint) * n * n);'
p26573
aS'                  const double jump_grad_j_dot_n ='
p26574
aS'                    (fe_interface_values.jump_gradient(j, qpoint) * n);'
p26575
aS'                  copy_data_face.cell_matrix(i, j) +='
p26576
aS'                    (-av_hessian_i_dot_n_dot_n       // - {grad^2 v n n }'
p26577
aS'                       * jump_grad_j_dot_n           // [grad u n]'
p26578
aS'                     - av_hessian_j_dot_n_dot_n      // - {grad^2 u n n }'
p26579
aS'                         * jump_grad_i_dot_n         // [grad v n]'
p26580
aS'                     +                               // +'
p26581
aS'                     gamma_over_h *                  // gamma/h'
p26582
aS'                       jump_grad_i_dot_n *           // [grad v n]'
p26583
aS'                       jump_grad_j_dot_n) *          // [grad u n]'
p26584
aS'                    fe_interface_values.JxW(qpoint); // dx'
p26585
aS'                }'
p26586
aS'            }'
p26587
aS'        }'
p26588
aS'    };'
p26589
aS'    auto boundary_worker = [&](const Iterator &    cell,'
p26590
aS'                               const unsigned int &face_no,'
p26591
aS'                               ScratchData<dim> &  scratch_data,'
p26592
aS'                               CopyData &          copy_data) {'
p26593
aS'      FEInterfaceValues<dim> &fe_interface_values ='
p26594
aS'        scratch_data.fe_interface_values;'
p26595
aS'      fe_interface_values.reinit(cell, face_no);'
p26596
aS'      const auto &q_points = fe_interface_values.get_quadrature_points();'
p26597
aS'      copy_data.face_data.emplace_back();'
p26598
aS'      CopyData::FaceData &copy_data_face = copy_data.face_data.back();'
p26599
aS'      const unsigned int n_dofs ='
p26600
aS'        fe_interface_values.n_current_interface_dofs();'
p26601
aS'      copy_data_face.joint_dof_indices ='
p26602
aS'        fe_interface_values.get_interface_dof_indices();'
p26603
aS'      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);'
p26604
aS'      const std::vector<double> &JxW = fe_interface_values.get_JxW_values();'
p26605
aS'      const std::vector<Tensor<1, dim>> &normals ='
p26606
aS'        fe_interface_values.get_normal_vectors();'
p26607
aS'      const ExactSolution::Solution<dim> exact_solution;'
p26608
aS'      std::vector<Tensor<1, dim>>        exact_gradients(q_points.size());'
p26609
aS'      exact_solution.gradient_list(q_points, exact_gradients);'
p26610
aS'      const unsigned int p = fe.degree;'
p26611
aS'      const double       gamma_over_h ='
p26612
aS'        (1.0 * p * (p + 1) /'
p26613
aS'         cell->extent_in_direction('
p26614
aS'           GeometryInfo<dim>::unit_normal_direction[face_no]));'
p26615
aS'      for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint)'
p26616
aS'        {'
p26617
aS'          const auto &n = normals[qpoint];'
p26618
aS'          for (unsigned int i = 0; i < n_dofs; ++i)'
p26619
aS'            {'
p26620
aS'              const double av_hessian_i_dot_n_dot_n ='
p26621
aS'                (fe_interface_values.average_hessian(i, qpoint) * n * n);'
p26622
aS'              const double jump_grad_i_dot_n ='
p26623
aS'                (fe_interface_values.jump_gradient(i, qpoint) * n);'
p26624
aS'              for (unsigned int j = 0; j < n_dofs; ++j)'
p26625
aS'                {'
p26626
aS'                  const double av_hessian_j_dot_n_dot_n ='
p26627
aS'                    (fe_interface_values.average_hessian(j, qpoint) * n * n);'
p26628
aS'                  const double jump_grad_j_dot_n ='
p26629
aS'                    (fe_interface_values.jump_gradient(j, qpoint) * n);'
p26630
aS'                  copy_data_face.cell_matrix(i, j) +='
p26631
aS'                    (-av_hessian_i_dot_n_dot_n  // - {grad^2 v n n}'
p26632
aS'                       * jump_grad_j_dot_n      //   [grad u n]'
p26633
aS'                     - av_hessian_j_dot_n_dot_n // - {grad^2 u n n}'
p26634
aS'                         * jump_grad_i_dot_n    //   [grad v n]'
p26635
aS'                     + gamma_over_h             //  gamma/h'
p26636
aS'                         * jump_grad_i_dot_n    // [grad v n]'
p26637
aS'                         * jump_grad_j_dot_n    // [grad u n]'
p26638
aS'                     ) *'
p26639
aS'                    JxW[qpoint]; // dx'
p26640
aS'                }'
p26641
aS'              copy_data.cell_rhs(i) +='
p26642
aS'                (-av_hessian_i_dot_n_dot_n *       // - {grad^2 v n n }'
p26643
aS'                   (exact_gradients[qpoint] * n)   //   (grad u_exact . n)'
p26644
aS'                 +                                 // +'
p26645
aS'                 gamma_over_h                      //  gamma/h'
p26646
aS'                   * jump_grad_i_dot_n             // [grad v n]'
p26647
aS'                   * (exact_gradients[qpoint] * n) // (grad u_exact . n)'
p26648
aS'                 ) *'
p26649
aS'                JxW[qpoint]; // dx'
p26650
aS'            }'
p26651
aS'        }'
p26652
aS'    };'
p26653
aS'    auto copier = [&](const CopyData &copy_data) {'
p26654
aS'      constraints.distribute_local_to_global(copy_data.cell_matrix,'
p26655
aS'                                             copy_data.cell_rhs,'
p26656
aS'                                             copy_data.local_dof_indices,'
p26657
aS'                                             system_matrix,'
p26658
aS'                                             system_rhs);'
p26659
aS'      for (auto &cdf : copy_data.face_data)'
p26660
aS'        {'
p26661
aS'          constraints.distribute_local_to_global(cdf.cell_matrix,'
p26662
aS'                                                 cdf.joint_dof_indices,'
p26663
aS'                                                 system_matrix);'
p26664
aS'        }'
p26665
aS'    };'
p26666
aS'    const unsigned int n_gauss_points = dof_handler.get_fe().degree + 1;'
p26667
aS'    ScratchData<dim>   scratch_data(mapping,'
p26668
aS'                                  fe,'
p26669
aS'                                  n_gauss_points,'
p26670
aS'                                  update_values | update_gradients |'
p26671
aS'                                    update_hessians | update_quadrature_points |'
p26672
aS'                                    update_JxW_values,'
p26673
aS'                                  update_values | update_gradients |'
p26674
aS'                                    update_hessians | update_quadrature_points |'
p26675
aS'                                    update_JxW_values | update_normal_vectors);'
p26676
aS'    CopyData           copy_data(dof_handler.get_fe().n_dofs_per_cell());'
p26677
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p26678
aS'                          dof_handler.end(),'
p26679
aS'                          cell_worker,'
p26680
aS'                          copier,'
p26681
aS'                          scratch_data,'
p26682
aS'                          copy_data,'
p26683
aS'                          MeshWorker::assemble_own_cells |'
p26684
aS'                            MeshWorker::assemble_boundary_faces |'
p26685
aS'                            MeshWorker::assemble_own_interior_faces_once,'
p26686
aS'                          boundary_worker,'
p26687
aS'                          face_worker);'
p26688
aS'  }'
p26689
aS'  template <int dim>'
p26690
aS'  void BiharmonicProblem<dim>::solve()'
p26691
aS'  {'
p26692
aS'    std::cout << "   Solving system..." << std::endl;'
p26693
aS'    SparseDirectUMFPACK A_direct;'
p26694
aS'    A_direct.initialize(system_matrix);'
p26695
aS'    A_direct.vmult(solution, system_rhs);'
p26696
aS'    constraints.distribute(solution);'
p26697
aS'  }'
p26698
aS'  template <int dim>'
p26699
aS'  void BiharmonicProblem<dim>::compute_errors()'
p26700
aS'  {'
p26701
aS'    {'
p26702
aS'      Vector<float> norm_per_cell(triangulation.n_active_cells());'
p26703
aS'      VectorTools::integrate_difference(mapping,'
p26704
aS'                                        dof_handler,'
p26705
aS'                                        solution,'
p26706
aS'                                        ExactSolution::Solution<dim>(),'
p26707
aS'                                        norm_per_cell,'
p26708
aS'                                        QGauss<dim>(fe.degree + 2),'
p26709
aS'                                        VectorTools::L2_norm);'
p26710
aS'      const double error_norm ='
p26711
aS'        VectorTools::compute_global_error(triangulation,'
p26712
aS'                                          norm_per_cell,'
p26713
aS'                                          VectorTools::L2_norm);'
p26714
aS'      std::cout << "   Error in the L2 norm           :     " << error_norm'
p26715
aS'                << std::endl;'
p26716
aS'    }'
p26717
aS'    {'
p26718
aS'      Vector<float> norm_per_cell(triangulation.n_active_cells());'
p26719
aS'      VectorTools::integrate_difference(mapping,'
p26720
aS'                                        dof_handler,'
p26721
aS'                                        solution,'
p26722
aS'                                        ExactSolution::Solution<dim>(),'
p26723
aS'                                        norm_per_cell,'
p26724
aS'                                        QGauss<dim>(fe.degree + 2),'
p26725
aS'                                        VectorTools::H1_seminorm);'
p26726
aS'      const double error_norm ='
p26727
aS'        VectorTools::compute_global_error(triangulation,'
p26728
aS'                                          norm_per_cell,'
p26729
aS'                                          VectorTools::H1_seminorm);'
p26730
aS'      std::cout << "   Error in the H1 seminorm       : " << error_norm'
p26731
aS'                << std::endl;'
p26732
aS'    }'
p26733
aS'    {'
p26734
aS'      const QGauss<dim>            quadrature_formula(fe.degree + 2);'
p26735
aS'      ExactSolution::Solution<dim> exact_solution;'
p26736
aS'      Vector<double> error_per_cell(triangulation.n_active_cells());'
p26737
aS'      FEValues<dim> fe_values(mapping,'
p26738
aS'                              fe,'
p26739
aS'                              quadrature_formula,'
p26740
aS'                              update_values | update_hessians |'
p26741
aS'                                update_quadrature_points | update_JxW_values);'
p26742
aS'      FEValuesExtractors::Scalar scalar(0);'
p26743
aS'      const unsigned int         n_q_points = quadrature_formula.size();'
p26744
aS'      std::vector<SymmetricTensor<2, dim>> exact_hessians(n_q_points);'
p26745
aS'      std::vector<Tensor<2, dim>>          hessians(n_q_points);'
p26746
aS'      for (auto &cell : dof_handler.active_cell_iterators())'
p26747
aS'        {'
p26748
aS'          fe_values.reinit(cell);'
p26749
aS'          fe_values[scalar].get_function_hessians(solution, hessians);'
p26750
aS'          exact_solution.hessian_list(fe_values.get_quadrature_points(),'
p26751
aS'                                      exact_hessians);'
p26752
aS'          double local_error = 0;'
p26753
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p26754
aS'            {'
p26755
aS'              local_error +='
p26756
aS'                ((exact_hessians[q_point] - hessians[q_point]).norm_square() *'
p26757
aS'                 fe_values.JxW(q_point));'
p26758
aS'            }'
p26759
aS'          error_per_cell[cell->active_cell_index()] = std::sqrt(local_error);'
p26760
aS'        }'
p26761
aS'      const double error_norm = error_per_cell.l2_norm();'
p26762
aS'      std::cout << "   Error in the broken H2 seminorm: " << error_norm'
p26763
aS'                << std::endl;'
p26764
aS'    }'
p26765
aS'  }'
p26766
aS'  template <int dim>'
p26767
aS'  void'
p26768
aS'  BiharmonicProblem<dim>::output_results(const unsigned int iteration) const'
p26769
aS'  {'
p26770
aS'    std::cout << "   Writing graphical output..." << std::endl;'
p26771
aS'    DataOut<dim> data_out;'
p26772
aS'    data_out.attach_dof_handler(dof_handler);'
p26773
aS'    data_out.add_data_vector(solution, "solution");'
p26774
aS'    data_out.build_patches();'
p26775
aS'    const std::string filename ='
p26776
aS'      ("output_" + Utilities::int_to_string(iteration, 6) + ".vtu");'
p26777
aS'    std::ofstream output_vtu(filename);'
p26778
aS'    data_out.write_vtu(output_vtu);'
p26779
aS'  }'
p26780
aS'  template <int dim>'
p26781
aS'  void BiharmonicProblem<dim>::run()'
p26782
aS'  {'
p26783
aS'    make_grid();'
p26784
aS'    const unsigned int n_cycles = 4;'
p26785
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p26786
aS'      {'
p26787
aS'        std::cout << "Cycle " << cycle << " of " << n_cycles << std::endl;'
p26788
aS'        triangulation.refine_global(1);'
p26789
aS'        setup_system();'
p26790
aS'        assemble_system();'
p26791
aS'        solve();'
p26792
aS'        output_results(cycle);'
p26793
aS'        compute_errors();'
p26794
aS'        std::cout << std::endl;'
p26795
aS'      }'
p26796
aS'  }'
p26797
aS'} // namespace Step47'
p26798
aS'int main()'
p26799
ag24
aS'  try'
p26800
aS'    {'
p26801
aS'      using namespace dealii;'
p26802
aS'      using namespace Step47;'
p26803
aS'      const unsigned int fe_degree = 2;'
p26804
aS'      Assert(fe_degree >= 2,'
p26805
aS'             ExcMessage("The C0IP formulation for the biharmonic problem "'
p26806
aS'                        "only works if one uses elements of polynomial "'
p26807
aS'                        "degree at least 2."));'
p26808
aS'      BiharmonicProblem<2> biharmonic_problem(fe_degree);'
p26809
aS'      biharmonic_problem.run();'
p26810
aS'    }'
p26811
aS'  catch (std::exception &exc)'
p26812
aS'    {'
p26813
aS'      std::cerr << std::endl'
p26814
aS'                << std::endl'
p26815
aS'                << "----------------------------------------------------"'
p26816
aS'                << std::endl;'
p26817
aS'      std::cerr << "Exception on processing: " << std::endl'
p26818
aS'                << exc.what() << std::endl'
p26819
aS'                << "Aborting!" << std::endl'
p26820
aS'                << "----------------------------------------------------"'
p26821
aS'                << std::endl;'
p26822
aS'      return 1;'
p26823
aS'    }'
p26824
aS'  catch (...)'
p26825
aS'    {'
p26826
aS'      std::cerr << std::endl'
p26827
aS'                << std::endl'
p26828
aS'                << "----------------------------------------------------"'
p26829
aS'                << std::endl;'
p26830
aS'      std::cerr << "Unknown exception!" << std::endl'
p26831
aS'                << "Aborting!" << std::endl'
p26832
aS'                << "----------------------------------------------------"'
p26833
aS'                << std::endl;'
p26834
aS'      return 1;'
p26835
aS'    }'
p26836
aS'  return 0;'
p26837
ag32
aS'/* ---------------------------------------------------------------------'
p26838
aS' *'
p26839
aS' * Copyright (C) 2011 - 2021 by the deal.II authors'
p26840
aS' *'
p26841
aS' * This file is part of the deal.II library.'
p26842
aS' *'
p26843
aS' * The deal.II library is free software; you can use it, redistribute'
p26844
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p26845
aS' * Public License as published by the Free Software Foundation; either'
p26846
aS' * version 2.1 of the License, or (at your option) any later version.'
p26847
aS' * The full text of the license can be found in the file LICENSE.md at'
p26848
aS' * the top level directory of deal.II.'
p26849
aS' *'
p26850
aS' * ---------------------------------------------------------------------'
p26851
aS' *'
p26852
aS' * Author: Katharina Kormann, Martin Kronbichler, Uppsala University, 2011-2012'
p26853
aS' */'
p26854
aS'#include <deal.II/base/logstream.h>'
p26855
aS'#include <deal.II/base/utilities.h>'
p26856
aS'#include <deal.II/base/function.h>'
p26857
aS'#include <deal.II/base/conditional_ostream.h>'
p26858
aS'#include <deal.II/base/timer.h>'
p26859
aS'#include <deal.II/lac/vector.h>'
p26860
aS'#include <deal.II/grid/tria.h>'
p26861
aS'#include <deal.II/grid/grid_generator.h>'
p26862
aS'#include <deal.II/dofs/dof_tools.h>'
p26863
aS'#include <deal.II/dofs/dof_handler.h>'
p26864
aS'#include <deal.II/lac/affine_constraints.h>'
p26865
aS'#include <deal.II/fe/fe_q.h>'
p26866
aS'#include <deal.II/fe/fe_values.h>'
p26867
aS'#include <deal.II/numerics/vector_tools.h>'
p26868
aS'#include <deal.II/numerics/data_out.h>'
p26869
aS'#include <deal.II/distributed/tria.h>'
p26870
aS'#include <deal.II/lac/la_parallel_vector.h>'
p26871
aS'#include <deal.II/matrix_free/matrix_free.h>'
p26872
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p26873
aS'#include <fstream>'
p26874
aS'#include <iostream>'
p26875
aS'#include <iomanip>'
p26876
aS'namespace Step48'
p26877
ag24
aS'  using namespace dealii;'
p26878
aS'  const unsigned int dimension = 2;'
p26879
aS'  const unsigned int fe_degree = 4;'
p26880
aS'  template <int dim, int fe_degree>'
p26881
aS'  class SineGordonOperation'
p26882
aS'  {'
p26883
aS'  public:'
p26884
aS'    SineGordonOperation(const MatrixFree<dim, double> &data_in,'
p26885
aS'                        const double                   time_step);'
p26886
aS'    void apply(LinearAlgebra::distributed::Vector<double> &dst,'
p26887
aS'               const std::vector<LinearAlgebra::distributed::Vector<double> *>'
p26888
aS'                 &src) const;'
p26889
aS'  private:'
p26890
aS'    const MatrixFree<dim, double> &            data;'
p26891
aS'    const VectorizedArray<double>              delta_t_sqr;'
p26892
aS'    LinearAlgebra::distributed::Vector<double> inv_mass_matrix;'
p26893
aS'    void local_apply('
p26894
aS'      const MatrixFree<dim, double> &                                  data,'
p26895
aS'      LinearAlgebra::distributed::Vector<double> &                     dst,'
p26896
aS'      const std::vector<LinearAlgebra::distributed::Vector<double> *> &src,'
p26897
aS'      const std::pair<unsigned int, unsigned int> &cell_range) const;'
p26898
aS'  };'
p26899
aS'  template <int dim, int fe_degree>'
p26900
aS'  SineGordonOperation<dim, fe_degree>::SineGordonOperation('
p26901
aS'    const MatrixFree<dim, double> &data_in,'
p26902
aS'    const double                   time_step)'
p26903
aS'    : data(data_in)'
p26904
aS'    , delta_t_sqr(make_vectorized_array(time_step * time_step))'
p26905
aS'  {'
p26906
aS'    data.initialize_dof_vector(inv_mass_matrix);'
p26907
aS'    FEEvaluation<dim, fe_degree> fe_eval(data);'
p26908
aS'    const unsigned int           n_q_points = fe_eval.n_q_points;'
p26909
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p26910
aS'      {'
p26911
aS'        fe_eval.reinit(cell);'
p26912
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p26913
aS'          fe_eval.submit_value(make_vectorized_array(1.), q);'
p26914
aS'        fe_eval.integrate(EvaluationFlags::values);'
p26915
aS'        fe_eval.distribute_local_to_global(inv_mass_matrix);'
p26916
aS'      }'
p26917
aS'    inv_mass_matrix.compress(VectorOperation::add);'
p26918
aS'    for (unsigned int k = 0; k < inv_mass_matrix.locally_owned_size(); ++k)'
p26919
aS'      if (inv_mass_matrix.local_element(k) > 1e-15)'
p26920
aS'        inv_mass_matrix.local_element(k) ='
p26921
aS'          1. / inv_mass_matrix.local_element(k);'
p26922
aS'      else'
p26923
aS'        inv_mass_matrix.local_element(k) = 1;'
p26924
aS'  }'
p26925
aS'  template <int dim, int fe_degree>'
p26926
aS'  void SineGordonOperation<dim, fe_degree>::local_apply('
p26927
aS'    const MatrixFree<dim> &                                          data,'
p26928
aS'    LinearAlgebra::distributed::Vector<double> &                     dst,'
p26929
aS'    const std::vector<LinearAlgebra::distributed::Vector<double> *> &src,'
p26930
aS'    const std::pair<unsigned int, unsigned int> &cell_range) const'
p26931
aS'  {'
p26932
aS'    AssertDimension(src.size(), 2);'
p26933
aS'    FEEvaluation<dim, fe_degree> current(data), old(data);'
p26934
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p26935
aS'      {'
p26936
aS'        current.reinit(cell);'
p26937
aS'        old.reinit(cell);'
p26938
aS'        current.read_dof_values(*src[0]);'
p26939
aS'        old.read_dof_values(*src[1]);'
p26940
aS'        current.evaluate(EvaluationFlags::values | EvaluationFlags::gradients);'
p26941
aS'        old.evaluate(EvaluationFlags::values);'
p26942
aS'        for (unsigned int q = 0; q < current.n_q_points; ++q)'
p26943
aS'          {'
p26944
aS'            const VectorizedArray<double> current_value = current.get_value(q);'
p26945
aS'            const VectorizedArray<double> old_value     = old.get_value(q);'
p26946
aS'            current.submit_value(2. * current_value - old_value -'
p26947
aS'                                   delta_t_sqr * std::sin(current_value),'
p26948
aS'                                 q);'
p26949
aS'            current.submit_gradient(-delta_t_sqr * current.get_gradient(q), q);'
p26950
aS'          }'
p26951
aS'        current.integrate(EvaluationFlags::values | EvaluationFlags::gradients);'
p26952
aS'        current.distribute_local_to_global(dst);'
p26953
aS'      }'
p26954
aS'  }'
p26955
aS'  template <int dim, int fe_degree>'
p26956
aS'  void SineGordonOperation<dim, fe_degree>::apply('
p26957
aS'    LinearAlgebra::distributed::Vector<double> &                     dst,'
p26958
aS'    const std::vector<LinearAlgebra::distributed::Vector<double> *> &src) const'
p26959
aS'  {'
p26960
aS'    data.cell_loop('
p26961
aS'      &SineGordonOperation<dim, fe_degree>::local_apply, this, dst, src, true);'
p26962
aS'    dst.scale(inv_mass_matrix);'
p26963
aS'  }'
p26964
aS'  template <int dim>'
p26965
aS'  class InitialCondition : public Function<dim>'
p26966
aS'  {'
p26967
aS'  public:'
p26968
aS'    InitialCondition(const unsigned int n_components = 1,'
p26969
aS'                     const double       time         = 0.)'
p26970
aS'      : Function<dim>(n_components, time)'
p26971
aS'    {}'
p26972
aS'    virtual double value(const Point<dim> &p,'
p26973
aS'                         const unsigned int /*component*/) const override'
p26974
aS'    {'
p26975
aS'      double t = this->get_time();'
p26976
aS'      const double m  = 0.5;'
p26977
aS'      const double c1 = 0.;'
p26978
aS'      const double c2 = 0.;'
p26979
aS'      const double factor ='
p26980
aS'        (m / std::sqrt(1. - m * m) * std::sin(std::sqrt(1. - m * m) * t + c2));'
p26981
aS'      double result = 1.;'
p26982
aS'      for (unsigned int d = 0; d < dim; ++d)'
p26983
aS'        result *= -4. * std::atan(factor / std::cosh(m * p[d] + c1));'
p26984
aS'      return result;'
p26985
aS'    }'
p26986
aS'  };'
p26987
aS'  template <int dim>'
p26988
aS'  class SineGordonProblem'
p26989
aS'  {'
p26990
aS'  public:'
p26991
aS'    SineGordonProblem();'
p26992
aS'    void run();'
p26993
aS'  private:'
p26994
aS'    ConditionalOStream pcout;'
p26995
aS'    void make_grid_and_dofs();'
p26996
aS'    void output_results(const unsigned int timestep_number);'
p26997
aS'#ifdef DEAL_II_WITH_P4EST'
p26998
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p26999
aS'#else'
p27000
aS'    Triangulation<dim> triangulation;'
p27001
aS'#endif'
p27002
aS'    FE_Q<dim>       fe;'
p27003
aS'    DoFHandler<dim> dof_handler;'
p27004
aS'    MappingQ1<dim> mapping;'
p27005
aS'    AffineConstraints<double> constraints;'
p27006
aS'    IndexSet                  locally_relevant_dofs;'
p27007
aS'    MatrixFree<dim, double> matrix_free_data;'
p27008
aS'    LinearAlgebra::distributed::Vector<double> solution, old_solution,'
p27009
aS'      old_old_solution;'
p27010
aS'    const unsigned int n_global_refinements;'
p27011
aS'    double             time, time_step;'
p27012
aS'    const double       final_time;'
p27013
aS'    const double       cfl_number;'
p27014
aS'    const unsigned int output_timestep_skip;'
p27015
aS'  };'
p27016
aS'  template <int dim>'
p27017
aS'  SineGordonProblem<dim>::SineGordonProblem()'
p27018
aS'    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p27019
aS'    ,'
p27020
aS'#ifdef DEAL_II_WITH_P4EST'
p27021
aS'    triangulation(MPI_COMM_WORLD)'
p27022
aS'    ,'
p27023
aS'#endif'
p27024
aS'    fe(QGaussLobatto<1>(fe_degree + 1))'
p27025
aS'    , dof_handler(triangulation)'
p27026
aS'    , n_global_refinements(10 - 2 * dim)'
p27027
aS'    , time(-10)'
p27028
aS'    , time_step(10.)'
p27029
aS'    , final_time(10.)'
p27030
aS'    , cfl_number(.1 / fe_degree)'
p27031
aS'    , output_timestep_skip(200)'
p27032
aS'  {}'
p27033
aS'  template <int dim>'
p27034
aS'  void SineGordonProblem<dim>::make_grid_and_dofs()'
p27035
aS'  {'
p27036
aS'    GridGenerator::hyper_cube(triangulation, -15, 15);'
p27037
aS'    triangulation.refine_global(n_global_refinements);'
p27038
aS'    {'
p27039
aS'      typename Triangulation<dim>::active_cell_iterator'
p27040
aS'        cell     = triangulation.begin_active(),'
p27041
aS'        end_cell = triangulation.end();'
p27042
aS'      for (; cell != end_cell; ++cell)'
p27043
aS'        if (cell->is_locally_owned())'
p27044
aS'          if (cell->center().norm() < 11)'
p27045
aS'            cell->set_refine_flag();'
p27046
aS'      triangulation.execute_coarsening_and_refinement();'
p27047
aS'      cell     = triangulation.begin_active();'
p27048
aS'      end_cell = triangulation.end();'
p27049
aS'      for (; cell != end_cell; ++cell)'
p27050
aS'        if (cell->is_locally_owned())'
p27051
aS'          if (cell->center().norm() < 6)'
p27052
aS'            cell->set_refine_flag();'
p27053
aS'      triangulation.execute_coarsening_and_refinement();'
p27054
aS'    }'
p27055
aS'    pcout << "   Number of global active cells: "'
p27056
aS'#ifdef DEAL_II_WITH_P4EST'
p27057
aS'          << triangulation.n_global_active_cells()'
p27058
aS'#else'
p27059
aS'          << triangulation.n_active_cells()'
p27060
aS'#endif'
p27061
aS'          << std::endl;'
p27062
aS'    dof_handler.distribute_dofs(fe);'
p27063
aS'    pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p27064
aS'          << std::endl;'
p27065
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p27066
aS'    constraints.clear();'
p27067
aS'    constraints.reinit(locally_relevant_dofs);'
p27068
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p27069
aS'    constraints.close();'
p27070
aS'    typename MatrixFree<dim>::AdditionalData additional_data;'
p27071
aS'    additional_data.tasks_parallel_scheme ='
p27072
aS'      MatrixFree<dim>::AdditionalData::TasksParallelScheme::partition_partition;'
p27073
aS'    matrix_free_data.reinit(mapping,'
p27074
aS'                            dof_handler,'
p27075
aS'                            constraints,'
p27076
aS'                            QGaussLobatto<1>(fe_degree + 1),'
p27077
aS'                            additional_data);'
p27078
aS'    matrix_free_data.initialize_dof_vector(solution);'
p27079
aS'    old_solution.reinit(solution);'
p27080
aS'    old_old_solution.reinit(solution);'
p27081
aS'  }'
p27082
aS'  template <int dim>'
p27083
aS'  void'
p27084
aS'  SineGordonProblem<dim>::output_results(const unsigned int timestep_number)'
p27085
aS'  {'
p27086
aS'    constraints.distribute(solution);'
p27087
aS'    Vector<float> norm_per_cell(triangulation.n_active_cells());'
p27088
aS'    solution.update_ghost_values();'
p27089
aS'    VectorTools::integrate_difference(mapping,'
p27090
aS'                                      dof_handler,'
p27091
aS'                                      solution,'
p27092
aS'                                      Functions::ZeroFunction<dim>(),'
p27093
aS'                                      norm_per_cell,'
p27094
aS'                                      QGauss<dim>(fe_degree + 1),'
p27095
aS'                                      VectorTools::L2_norm);'
p27096
aS'    const double solution_norm ='
p27097
aS'      VectorTools::compute_global_error(triangulation,'
p27098
aS'                                        norm_per_cell,'
p27099
aS'                                        VectorTools::L2_norm);'
p27100
aS'    pcout << "   Time:" << std::setw(8) << std::setprecision(3) << time'
p27101
aS'          << ", solution norm: " << std::setprecision(5) << std::setw(7)'
p27102
aS'          << solution_norm << std::endl;'
p27103
aS'    DataOut<dim> data_out;'
p27104
aS'    data_out.attach_dof_handler(dof_handler);'
p27105
aS'    data_out.add_data_vector(solution, "solution");'
p27106
aS'    data_out.build_patches(mapping);'
p27107
aS'    data_out.write_vtu_with_pvtu_record('
p27108
aS'      "./", "solution", timestep_number, MPI_COMM_WORLD, 3);'
p27109
aS'    solution.zero_out_ghost_values();'
p27110
aS'  }'
p27111
aS'  template <int dim>'
p27112
aS'  void SineGordonProblem<dim>::run()'
p27113
aS'  {'
p27114
aS'    {'
p27115
aS'      pcout << "Number of MPI ranks:            "'
p27116
aS'            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) << std::endl;'
p27117
aS'      pcout << "Number of threads on each rank: "'
p27118
aS'            << MultithreadInfo::n_threads() << std::endl;'
p27119
aS'      const unsigned int n_vect_doubles = VectorizedArray<double>::size();'
p27120
aS'      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles;'
p27121
aS'      pcout << "Vectorization over " << n_vect_doubles'
p27122
aS'            << " doubles = " << n_vect_bits << " bits ("'
p27123
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p27124
aS'            << std::endl'
p27125
aS'            << std::endl;'
p27126
aS'    }'
p27127
aS'    make_grid_and_dofs();'
p27128
aS'    const double local_min_cell_diameter ='
p27129
aS'      triangulation.last()->diameter() / std::sqrt(dim);'
p27130
aS'    const double global_min_cell_diameter ='
p27131
aS'      -Utilities::MPI::max(-local_min_cell_diameter, MPI_COMM_WORLD);'
p27132
aS'    time_step = cfl_number * global_min_cell_diameter;'
p27133
aS'    time_step = (final_time - time) / (int((final_time - time) / time_step));'
p27134
aS'    pcout << "   Time step size: " << time_step'
p27135
aS'          << ", finest cell: " << global_min_cell_diameter << std::endl'
p27136
aS'          << std::endl;'
p27137
aS'    VectorTools::interpolate(mapping,'
p27138
aS'                             dof_handler,'
p27139
aS'                             InitialCondition<dim>(1, time),'
p27140
aS'                             solution);'
p27141
aS'    VectorTools::interpolate(mapping,'
p27142
aS'                             dof_handler,'
p27143
aS'                             InitialCondition<dim>(1, time - time_step),'
p27144
aS'                             old_solution);'
p27145
aS'    output_results(0);'
p27146
aS'    std::vector<LinearAlgebra::distributed::Vector<double> *>'
p27147
aS'      previous_solutions({&old_solution, &old_old_solution});'
p27148
aS'    SineGordonOperation<dim, fe_degree> sine_gordon_op(matrix_free_data,'
p27149
aS'                                                       time_step);'
p27150
aS'    unsigned int timestep_number = 1;'
p27151
aS'    Timer  timer;'
p27152
aS'    double wtime       = 0;'
p27153
aS'    double output_time = 0;'
p27154
aS'    for (time += time_step; time <= final_time;'
p27155
aS'         time += time_step, ++timestep_number)'
p27156
aS'      {'
p27157
aS'        timer.restart();'
p27158
aS'        old_old_solution.swap(old_solution);'
p27159
aS'        old_solution.swap(solution);'
p27160
aS'        sine_gordon_op.apply(solution, previous_solutions);'
p27161
aS'        wtime += timer.wall_time();'
p27162
aS'        timer.restart();'
p27163
aS'        if (timestep_number % output_timestep_skip == 0)'
p27164
aS'          output_results(timestep_number / output_timestep_skip);'
p27165
aS'        output_time += timer.wall_time();'
p27166
aS'      }'
p27167
aS'    timer.restart();'
p27168
aS'    output_results(timestep_number / output_timestep_skip + 1);'
p27169
aS'    output_time += timer.wall_time();'
p27170
aS'    pcout << std::endl'
p27171
aS'          << "   Performed " << timestep_number << " time steps." << std::endl;'
p27172
aS'    pcout << "   Average wallclock time per time step: "'
p27173
aS'          << wtime / timestep_number << "s" << std::endl;'
p27174
aS'    pcout << "   Spent " << output_time << "s on output and " << wtime'
p27175
aS'          << "s on computations." << std::endl;'
p27176
aS'  }'
p27177
aS'} // namespace Step48'
p27178
aS'int main(int argc, char **argv)'
p27179
ag24
aS'  using namespace Step48;'
p27180
aS'  using namespace dealii;'
p27181
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization('
p27182
aS'    argc, argv, numbers::invalid_unsigned_int);'
p27183
aS'  try'
p27184
aS'    {'
p27185
aS'      SineGordonProblem<dimension> sg_problem;'
p27186
aS'      sg_problem.run();'
p27187
aS'    }'
p27188
aS'  catch (std::exception &exc)'
p27189
aS'    {'
p27190
aS'      std::cerr << std::endl'
p27191
aS'                << std::endl'
p27192
aS'                << "----------------------------------------------------"'
p27193
aS'                << std::endl;'
p27194
aS'      std::cerr << "Exception on processing: " << std::endl'
p27195
aS'                << exc.what() << std::endl'
p27196
aS'                << "Aborting!" << std::endl'
p27197
aS'                << "----------------------------------------------------"'
p27198
aS'                << std::endl;'
p27199
aS'      return 1;'
p27200
aS'    }'
p27201
aS'  catch (...)'
p27202
aS'    {'
p27203
aS'      std::cerr << std::endl'
p27204
aS'                << std::endl'
p27205
aS'                << "----------------------------------------------------"'
p27206
aS'                << std::endl;'
p27207
aS'      std::cerr << "Unknown exception!" << std::endl'
p27208
aS'                << "Aborting!" << std::endl'
p27209
aS'                << "----------------------------------------------------"'
p27210
aS'                << std::endl;'
p27211
aS'      return 1;'
p27212
aS'    }'
p27213
aS'  return 0;'
p27214
ag32
aS'/* ---------------------------------------------------------------------'
p27215
aS' *'
p27216
aS' * Copyright (C) 2013 - 2021 by the deal.II authors'
p27217
aS' *'
p27218
aS' * This file is part of the deal.II library.'
p27219
aS' *'
p27220
aS' * The deal.II library is free software; you can use it, redistribute'
p27221
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p27222
aS' * Public License as published by the Free Software Foundation; either'
p27223
aS' * version 2.1 of the License, or (at your option) any later version.'
p27224
aS' * The full text of the license can be found in the file LICENSE.md at'
p27225
aS' * the top level directory of deal.II.'
p27226
aS' *'
p27227
aS' * ---------------------------------------------------------------------'
p27228
aS' *'
p27229
aS' * Author: Timo Heister, Texas A&M University, 2013'
p27230
aS' */'
p27231
aS'#include <deal.II/grid/tria.h>'
p27232
aS'#include <deal.II/grid/grid_generator.h>'
p27233
aS'#include <deal.II/grid/grid_tools.h>'
p27234
aS'#include <deal.II/grid/manifold_lib.h>'
p27235
aS'#include <deal.II/grid/grid_out.h>'
p27236
aS'#include <deal.II/grid/grid_in.h>'
p27237
aS'#include <iostream>'
p27238
aS'#include <fstream>'
p27239
aS'#include <map>'
p27240
aS'using namespace dealii;'
p27241
aS'template <int dim>'
p27242
aS'void print_mesh_info(const Triangulation<dim> &triangulation,'
p27243
aS'                     const std::string &       filename)'
p27244
ag24
aS'  std::cout << "Mesh info:" << std::endl'
p27245
aS'            << " dimension: " << dim << std::endl'
p27246
aS'            << " no. of cells: " << triangulation.n_active_cells() << std::endl;'
p27247
aS'  {'
p27248
aS'    std::map<types::boundary_id, unsigned int> boundary_count;'
p27249
aS'    for (const auto &face : triangulation.active_face_iterators())'
p27250
aS'      if (face->at_boundary())'
p27251
aS'        boundary_count[face->boundary_id()]++;'
p27252
aS'    std::cout << " boundary indicators: ";'
p27253
aS'    for (const std::pair<const types::boundary_id, unsigned int> &pair :'
p27254
aS'         boundary_count)'
p27255
aS'      {'
p27256
aS'        std::cout << pair.first << "(" << pair.second << " times) ";'
p27257
aS'      }'
p27258
aS'    std::cout << std::endl;'
p27259
aS'  }'
p27260
aS'  std::ofstream out(filename);'
p27261
aS'  GridOut       grid_out;'
p27262
aS'  grid_out.write_vtu(triangulation, out);'
p27263
aS'  std::cout << " written to " << filename << std::endl << std::endl;'
p27264
ag32
aS'void grid_1()'
p27265
ag24
aS'  Triangulation<2> triangulation;'
p27266
aS'  GridIn<2> gridin;'
p27267
aS'  gridin.attach_triangulation(triangulation);'
p27268
aS'  std::ifstream f("example.msh");'
p27269
aS'  gridin.read_msh(f);'
p27270
aS'  print_mesh_info(triangulation, "grid-1.vtu");'
p27271
ag32
aS'void grid_2()'
p27272
ag24
aS'  Triangulation<2> tria1;'
p27273
aS'  GridGenerator::hyper_cube_with_cylindrical_hole(tria1, 0.25, 1.0);'
p27274
aS'  Triangulation<2>          tria2;'
p27275
aS'  std::vector<unsigned int> repetitions(2);'
p27276
aS'  repetitions[0] = 3;'
p27277
aS'  repetitions[1] = 2;'
p27278
aS'  GridGenerator::subdivided_hyper_rectangle(tria2,'
p27279
aS'                                            repetitions,'
p27280
aS'                                            Point<2>(1.0, -1.0),'
p27281
aS'                                            Point<2>(4.0, 1.0));'
p27282
aS'  Triangulation<2> triangulation;'
p27283
aS'  GridGenerator::merge_triangulations(tria1, tria2, triangulation);'
p27284
aS'  print_mesh_info(triangulation, "grid-2.vtu");'
p27285
ag32
aS'void grid_3()'
p27286
ag24
aS'  Triangulation<2> triangulation;'
p27287
aS'  GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 0.25, 1.0);'
p27288
aS'  for (const auto &cell : triangulation.active_cell_iterators())'
p27289
aS'    {'
p27290
aS'      for (const auto i : cell->vertex_indices())'
p27291
aS'        {'
p27292
aS'          Point<2> &v = cell->vertex(i);'
p27293
aS'          if (std::abs(v(1) - 1.0) < 1e-5)'
p27294
aS'            v(1) += 0.5;'
p27295
aS'        }'
p27296
aS'    }'
p27297
aS'  triangulation.refine_global(2);'
p27298
aS'  print_mesh_info(triangulation, "grid-3.vtu");'
p27299
ag32
aS'void grid_4()'
p27300
ag24
aS'  Triangulation<2> triangulation;'
p27301
aS'  Triangulation<3> out;'
p27302
aS'  GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 0.25, 1.0);'
p27303
aS'  GridGenerator::extrude_triangulation(triangulation, 3, 2.0, out);'
p27304
aS'  print_mesh_info(out, "grid-4.vtu");'
p27305
ag32
aS'void grid_5()'
p27306
ag24
aS'  Triangulation<2>          triangulation;'
p27307
aS'  std::vector<unsigned int> repetitions(2);'
p27308
aS'  repetitions[0] = 14;'
p27309
aS'  repetitions[1] = 2;'
p27310
aS'  GridGenerator::subdivided_hyper_rectangle(triangulation,'
p27311
aS'                                            repetitions,'
p27312
aS'                                            Point<2>(0.0, 0.0),'
p27313
aS'                                            Point<2>(10.0, 1.0));'
p27314
aS'  GridTools::transform('
p27315
aS'    [](const Point<2> &in) {'
p27316
aS'      return Point<2>(in[0], in[1] + std::sin(numbers::PI * in[0] / 5.0));'
p27317
aS'    },'
p27318
aS'    triangulation);'
p27319
aS'  print_mesh_info(triangulation, "grid-5.vtu");'
p27320
ag32
aS'struct Grid6Func'
p27321
ag24
aS'  double trans(const double y) const'
p27322
aS'  {'
p27323
aS'    return std::tanh(2 * y) / tanh(2);'
p27324
aS'  }'
p27325
aS'  Point<2> operator()(const Point<2> &in) const'
p27326
aS'  {'
p27327
aS'    return {in(0), trans(in(1))};'
p27328
aS'  }'
p27329
aS'};'
p27330
aS'void grid_6()'
p27331
ag24
aS'  Triangulation<2>          triangulation;'
p27332
aS'  std::vector<unsigned int> repetitions(2);'
p27333
aS'  repetitions[0] = repetitions[1] = 40;'
p27334
aS'  GridGenerator::subdivided_hyper_rectangle(triangulation,'
p27335
aS'                                            repetitions,'
p27336
aS'                                            Point<2>(0.0, 0.0),'
p27337
aS'                                            Point<2>(1.0, 1.0));'
p27338
aS'  GridTools::transform(Grid6Func(), triangulation);'
p27339
aS'  print_mesh_info(triangulation, "grid-6.vtu");'
p27340
ag32
aS'void grid_7()'
p27341
ag24
aS'  Triangulation<2>          triangulation;'
p27342
aS'  std::vector<unsigned int> repetitions(2);'
p27343
aS'  repetitions[0] = repetitions[1] = 16;'
p27344
aS'  GridGenerator::subdivided_hyper_rectangle(triangulation,'
p27345
aS'                                            repetitions,'
p27346
aS'                                            Point<2>(0.0, 0.0),'
p27347
aS'                                            Point<2>(1.0, 1.0));'
p27348
aS'  GridTools::distort_random(0.3, triangulation, true);'
p27349
aS'  print_mesh_info(triangulation, "grid-7.vtu");'
p27350
ag32
aS'int main()'
p27351
ag24
aS'  try'
p27352
aS'    {'
p27353
aS'      grid_1();'
p27354
aS'      grid_2();'
p27355
aS'      grid_3();'
p27356
aS'      grid_4();'
p27357
aS'      grid_5();'
p27358
aS'      grid_6();'
p27359
aS'      grid_7();'
p27360
aS'    }'
p27361
aS'  catch (std::exception &exc)'
p27362
aS'    {'
p27363
aS'      std::cerr << std::endl'
p27364
aS'                << std::endl'
p27365
aS'                << "----------------------------------------------------"'
p27366
aS'                << std::endl;'
p27367
aS'      std::cerr << "Exception on processing: " << std::endl'
p27368
aS'                << exc.what() << std::endl'
p27369
aS'                << "Aborting!" << std::endl'
p27370
aS'                << "----------------------------------------------------"'
p27371
aS'                << std::endl;'
p27372
aS'      return 1;'
p27373
aS'    }'
p27374
aS'  catch (...)'
p27375
aS'    {'
p27376
aS'      std::cerr << std::endl'
p27377
aS'                << std::endl'
p27378
aS'                << "----------------------------------------------------"'
p27379
aS'                << std::endl;'
p27380
aS'      std::cerr << "Unknown exception!" << std::endl'
p27381
aS'                << "Aborting!" << std::endl'
p27382
aS'                << "----------------------------------------------------"'
p27383
aS'                << std::endl;'
p27384
aS'      return 1;'
p27385
aS'    }'
p27386
ag32
aS'/* ---------------------------------------------------------------------'
p27387
aS' *'
p27388
aS' * Copyright (C) 1999 - 2021 by the deal.II authors'
p27389
aS' *'
p27390
aS' * This file is part of the deal.II library.'
p27391
aS' *'
p27392
aS' * The deal.II library is free software; you can use it, redistribute'
p27393
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p27394
aS' * Public License as published by the Free Software Foundation; either'
p27395
aS' * version 2.1 of the License, or (at your option) any later version.'
p27396
aS' * The full text of the license can be found in the file LICENSE.md at'
p27397
aS' * the top level directory of deal.II.'
p27398
aS' *'
p27399
aS' * ---------------------------------------------------------------------'
p27400
aS' *'
p27401
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 1999'
p27402
aS' */'
p27403
aS'#include <deal.II/base/quadrature_lib.h>'
p27404
aS'#include <deal.II/base/function.h>'
p27405
aS'#include <deal.II/base/logstream.h>'
p27406
aS'#include <deal.II/lac/vector.h>'
p27407
aS'#include <deal.II/lac/full_matrix.h>'
p27408
aS'#include <deal.II/lac/sparse_matrix.h>'
p27409
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p27410
aS'#include <deal.II/lac/solver_cg.h>'
p27411
aS'#include <deal.II/lac/precondition.h>'
p27412
aS'#include <deal.II/grid/tria.h>'
p27413
aS'#include <deal.II/dofs/dof_handler.h>'
p27414
aS'#include <deal.II/dofs/dof_tools.h>'
p27415
aS'#include <deal.II/fe/fe_q.h>'
p27416
aS'#include <deal.II/fe/fe_values.h>'
p27417
aS'#include <deal.II/numerics/vector_tools.h>'
p27418
aS'#include <deal.II/numerics/matrix_tools.h>'
p27419
aS'#include <deal.II/numerics/data_out.h>'
p27420
aS'#include <deal.II/grid/grid_in.h>'
p27421
aS'#include <deal.II/grid/manifold_lib.h>'
p27422
aS'#include <fstream>'
p27423
aS'#include <iostream>'
p27424
aS'using namespace dealii;'
p27425
aS'template <int dim>'
p27426
aS'class Step5'
p27427
ag24
aS'public:'
p27428
aS'  Step5();'
p27429
aS'  void run();'
p27430
aS'private:'
p27431
aS'  void setup_system();'
p27432
aS'  void assemble_system();'
p27433
aS'  void solve();'
p27434
aS'  void output_results(const unsigned int cycle) const;'
p27435
aS'  Triangulation<dim> triangulation;'
p27436
aS'  FE_Q<dim>          fe;'
p27437
aS'  DoFHandler<dim>    dof_handler;'
p27438
aS'  SparsityPattern      sparsity_pattern;'
p27439
aS'  SparseMatrix<double> system_matrix;'
p27440
aS'  Vector<double> solution;'
p27441
aS'  Vector<double> system_rhs;'
p27442
aS'};'
p27443
aS'template <int dim>'
p27444
aS'double coefficient(const Point<dim> &p)'
p27445
ag24
aS'  if (p.square() < 0.5 * 0.5)'
p27446
aS'    return 20;'
p27447
aS'  else'
p27448
aS'    return 1;'
p27449
ag32
aS'template <int dim>'
p27450
aS'Step5<dim>::Step5()'
p27451
aS'  : fe(1)'
p27452
aS'  , dof_handler(triangulation)'
p27453
aS'{}'
p27454
aS'template <int dim>'
p27455
aS'void Step5<dim>::setup_system()'
p27456
ag24
aS'  dof_handler.distribute_dofs(fe);'
p27457
aS'  std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p27458
aS'            << std::endl;'
p27459
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p27460
aS'  DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p27461
aS'  sparsity_pattern.copy_from(dsp);'
p27462
aS'  system_matrix.reinit(sparsity_pattern);'
p27463
aS'  solution.reinit(dof_handler.n_dofs());'
p27464
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p27465
ag32
aS'template <int dim>'
p27466
aS'void Step5<dim>::assemble_system()'
p27467
ag24
aS'  QGauss<dim> quadrature_formula(fe.degree + 1);'
p27468
aS'  FEValues<dim> fe_values(fe,'
p27469
aS'                          quadrature_formula,'
p27470
aS'                          update_values | update_gradients |'
p27471
aS'                            update_quadrature_points | update_JxW_values);'
p27472
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p27473
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p27474
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p27475
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p27476
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p27477
aS'    {'
p27478
aS'      cell_matrix = 0.;'
p27479
aS'      cell_rhs    = 0.;'
p27480
aS'      fe_values.reinit(cell);'
p27481
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p27482
aS'        {'
p27483
aS'          const double current_coefficient ='
p27484
aS'            coefficient(fe_values.quadrature_point(q_index));'
p27485
aS'          for (const unsigned int i : fe_values.dof_indices())'
p27486
aS'            {'
p27487
aS'              for (const unsigned int j : fe_values.dof_indices())'
p27488
aS'                cell_matrix(i, j) +='
p27489
aS'                  (current_coefficient *              // a(x_q)'
p27490
aS'                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p27491
aS'                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p27492
aS'                   fe_values.JxW(q_index));           // dx'
p27493
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p27494
aS'                              1.0 *                               // f(x_q)'
p27495
aS'                              fe_values.JxW(q_index));            // dx'
p27496
aS'            }'
p27497
aS'        }'
p27498
aS'      cell->get_dof_indices(local_dof_indices);'
p27499
aS'      for (const unsigned int i : fe_values.dof_indices())'
p27500
aS'        {'
p27501
aS'          for (const unsigned int j : fe_values.dof_indices())'
p27502
aS'            system_matrix.add(local_dof_indices[i],'
p27503
aS'                              local_dof_indices[j],'
p27504
aS'                              cell_matrix(i, j));'
p27505
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p27506
aS'        }'
p27507
aS'    }'
p27508
aS'  std::map<types::global_dof_index, double> boundary_values;'
p27509
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p27510
aS'                                           0,'
p27511
aS'                                           Functions::ZeroFunction<dim>(),'
p27512
aS'                                           boundary_values);'
p27513
aS'  MatrixTools::apply_boundary_values(boundary_values,'
p27514
aS'                                     system_matrix,'
p27515
aS'                                     solution,'
p27516
aS'                                     system_rhs);'
p27517
ag32
aS'template <int dim>'
p27518
aS'void Step5<dim>::solve()'
p27519
ag24
aS'  SolverControl            solver_control(1000, 1e-12);'
p27520
aS'  SolverCG<Vector<double>> solver(solver_control);'
p27521
aS'  PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p27522
aS'  preconditioner.initialize(system_matrix, 1.2);'
p27523
aS'  solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p27524
aS'  std::cout << "   " << solver_control.last_step()'
p27525
aS'            << " CG iterations needed to obtain convergence." << std::endl;'
p27526
ag32
aS'template <int dim>'
p27527
aS'void Step5<dim>::output_results(const unsigned int cycle) const'
p27528
ag24
aS'  DataOut<dim> data_out;'
p27529
aS'  data_out.attach_dof_handler(dof_handler);'
p27530
aS'  data_out.add_data_vector(solution, "solution");'
p27531
aS'  data_out.build_patches();'
p27532
aS'  std::ofstream output("solution-" + std::to_string(cycle) + ".vtu");'
p27533
aS'  data_out.write_vtu(output);'
p27534
ag32
aS'template <int dim>'
p27535
aS'void Step5<dim>::run()'
p27536
ag24
aS'  GridIn<dim> grid_in;'
p27537
aS'  grid_in.attach_triangulation(triangulation);'
p27538
aS'  std::ifstream input_file("circle-grid.inp");'
p27539
aS'  Assert(dim == 2, ExcInternalError());'
p27540
aS'  grid_in.read_ucd(input_file);'
p27541
aS'  const SphericalManifold<dim> boundary;'
p27542
aS'  triangulation.set_all_manifold_ids_on_boundary(0);'
p27543
aS'  triangulation.set_manifold(0, boundary);'
p27544
aS'  for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p27545
aS'    {'
p27546
aS'      std::cout << "Cycle " << cycle << \':\' << std::endl;'
p27547
aS'      if (cycle != 0)'
p27548
aS'        triangulation.refine_global(1);'
p27549
aS'      std::cout << "   Number of active cells: "  //'
p27550
aS'                << triangulation.n_active_cells() //'
p27551
aS'                << std::endl                      //'
p27552
aS'                << "   Total number of cells: "   //'
p27553
aS'                << triangulation.n_cells()        //'
p27554
aS'                << std::endl;'
p27555
aS'      setup_system();'
p27556
aS'      assemble_system();'
p27557
aS'      solve();'
p27558
aS'      output_results(cycle);'
p27559
aS'    }'
p27560
ag32
aS'int main()'
p27561
ag24
aS'  Step5<2> laplace_problem_2d;'
p27562
aS'  laplace_problem_2d.run();'
p27563
aS'  return 0;'
p27564
ag32
aS'/* ---------------------------------------------------------------------'
p27565
aS' *'
p27566
aS' * Copyright (C) 2019 - 2021 by the deal.II authors'
p27567
aS' *'
p27568
aS' * This file is part of the deal.II library.'
p27569
aS' *'
p27570
aS' * The deal.II library is free software; you can use it, redistribute'
p27571
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p27572
aS' * Public License as published by the Free Software Foundation; either'
p27573
aS' * version 2.1 of the License, or (at your option) any later version.'
p27574
aS' * The full text of the license can be found in the file LICENSE.md at'
p27575
aS' * the top level directory of deal.II.'
p27576
aS' *'
p27577
aS' * ---------------------------------------------------------------------'
p27578
aS' *'
p27579
aS' * Author: Thomas C. Clevenger, Clemson University'
p27580
aS' *         Timo Heister, Clemson University'
p27581
aS' *         Guido Kanschat, Heidelberg University'
p27582
aS' *         Martin Kronbichler, Technical University of Munich'
p27583
aS' */'
p27584
aS'#include <deal.II/base/conditional_ostream.h>'
p27585
aS'#include <deal.II/base/data_out_base.h>'
p27586
aS'#include <deal.II/base/index_set.h>'
p27587
aS'#include <deal.II/base/logstream.h>'
p27588
aS'#include <deal.II/base/quadrature_lib.h>'
p27589
aS'#include <deal.II/base/timer.h>'
p27590
aS'#include <deal.II/base/parameter_handler.h>'
p27591
aS'#include <deal.II/distributed/grid_refinement.h>'
p27592
aS'#include <deal.II/distributed/tria.h>'
p27593
aS'#include <deal.II/dofs/dof_tools.h>'
p27594
aS'#include <deal.II/fe/fe_q.h>'
p27595
aS'#include <deal.II/fe/fe_values.h>'
p27596
aS'#include <deal.II/grid/grid_generator.h>'
p27597
aS'#include <deal.II/grid/grid_refinement.h>'
p27598
aS'#include <deal.II/grid/tria.h>'
p27599
aS'#include <deal.II/lac/affine_constraints.h>'
p27600
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p27601
aS'#include <deal.II/lac/solver_cg.h>'
p27602
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p27603
aS'#define FORCE_USE_OF_TRILINOS'
p27604
aS'namespace LA'
p27605
ag24
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p27606
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p27607
aS'  using namespace dealii::LinearAlgebraPETSc;'
p27608
aS'#  define USE_PETSC_LA'
p27609
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p27610
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p27611
aS'#else'
p27612
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p27613
aS'#endif'
p27614
aS'} // namespace LA'
p27615
aS'#include <deal.II/matrix_free/matrix_free.h>'
p27616
aS'#include <deal.II/matrix_free/operators.h>'
p27617
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p27618
aS'#include <deal.II/multigrid/mg_coarse.h>'
p27619
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p27620
aS'#include <deal.II/multigrid/mg_matrix.h>'
p27621
aS'#include <deal.II/multigrid/mg_smoother.h>'
p27622
aS'#include <deal.II/multigrid/mg_tools.h>'
p27623
aS'#include <deal.II/multigrid/mg_transfer.h>'
p27624
aS'#include <deal.II/multigrid/multigrid.h>'
p27625
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p27626
aS'#include <deal.II/numerics/data_out.h>'
p27627
aS'#include <deal.II/numerics/vector_tools.h>'
p27628
aS'#include <deal.II/fe/fe_interface_values.h>'
p27629
aS'#include <deal.II/meshworker/mesh_loop.h>'
p27630
aS'using namespace dealii;'
p27631
aS'namespace ChangeVectorTypes'
p27632
ag24
aS'  template <typename number>'
p27633
aS'  void copy(LA::MPI::Vector &                                         out,'
p27634
aS'            const dealii::LinearAlgebra::distributed::Vector<number> &in)'
p27635
aS'  {'
p27636
aS'    dealii::LinearAlgebra::ReadWriteVector<double> rwv('
p27637
aS'      out.locally_owned_elements());'
p27638
aS'    rwv.import(in, VectorOperation::insert);'
p27639
aS'#ifdef USE_PETSC_LA'
p27640
aS'    AssertThrow(false,'
p27641
aS'                ExcMessage("CopyVectorTypes::copy() not implemented for "'
p27642
aS'                           "PETSc vector types."));'
p27643
aS'#else'
p27644
aS'    out.import(rwv, VectorOperation::insert);'
p27645
aS'#endif'
p27646
aS'  }'
p27647
aS'  template <typename number>'
p27648
aS'  void copy(dealii::LinearAlgebra::distributed::Vector<number> &out,'
p27649
aS'            const LA::MPI::Vector &                             in)'
p27650
aS'  {'
p27651
aS'    dealii::LinearAlgebra::ReadWriteVector<double> rwv;'
p27652
aS'#ifdef USE_PETSC_LA'
p27653
aS'    (void)in;'
p27654
aS'    AssertThrow(false,'
p27655
aS'                ExcMessage("CopyVectorTypes::copy() not implemented for "'
p27656
aS'                           "PETSc vector types."));'
p27657
aS'#else'
p27658
aS'    rwv.reinit(in);'
p27659
aS'#endif'
p27660
aS'    out.import(rwv, VectorOperation::insert);'
p27661
aS'  }'
p27662
aS'} // namespace ChangeVectorTypes'
p27663
aS'template <int dim>'
p27664
aS'class RightHandSide : public Function<dim>'
p27665
ag24
aS'public:'
p27666
aS'  virtual double value(const Point<dim> & /*p*/,'
p27667
aS'                       const unsigned int /*component*/ = 0) const override'
p27668
aS'  {'
p27669
aS'    return 1.0;'
p27670
aS'  }'
p27671
aS'  template <typename number>'
p27672
aS'  VectorizedArray<number>'
p27673
aS'  value(const Point<dim, VectorizedArray<number>> & /*p*/,'
p27674
aS'        const unsigned int /*component*/ = 0) const'
p27675
aS'  {'
p27676
aS'    return VectorizedArray<number>(1.0);'
p27677
aS'  }'
p27678
aS'};'
p27679
aS'template <int dim>'
p27680
aS'class Coefficient : public Function<dim>'
p27681
ag24
aS'public:'
p27682
aS'  virtual double value(const Point<dim> &p,'
p27683
aS'                       const unsigned int /*component*/ = 0) const override;'
p27684
aS'  template <typename number>'
p27685
aS'  VectorizedArray<number> value(const Point<dim, VectorizedArray<number>> &p,'
p27686
aS'                                const unsigned int /*component*/ = 0) const;'
p27687
aS'  template <typename number>'
p27688
aS'  number average_value(const std::vector<Point<dim, number>> &points) const;'
p27689
aS'  template <typename number>'
p27690
aS'  std::shared_ptr<Table<2, VectorizedArray<number>>> make_coefficient_table('
p27691
aS'    const MatrixFree<dim, number, VectorizedArray<number>> &mf_storage) const;'
p27692
aS'};'
p27693
aS'template <int dim>'
p27694
aS'double Coefficient<dim>::value(const Point<dim> &p, const unsigned int) const'
p27695
ag24
aS'  for (int d = 0; d < dim; ++d)'
p27696
aS'    {'
p27697
aS'      if (p[d] < -0.5)'
p27698
aS'        return 100.0;'
p27699
aS'    }'
p27700
aS'  return 1.0;'
p27701
ag32
aS'template <int dim>'
p27702
aS'template <typename number>'
p27703
aS'VectorizedArray<number>'
p27704
aS'Coefficient<dim>::value(const Point<dim, VectorizedArray<number>> &p,'
p27705
aS'                        const unsigned int) const'
p27706
ag24
aS'  VectorizedArray<number> return_value = VectorizedArray<number>(1.0);'
p27707
aS'  for (unsigned int i = 0; i < VectorizedArray<number>::size(); ++i)'
p27708
aS'    {'
p27709
aS'      for (int d = 0; d < dim; ++d)'
p27710
aS'        if (p[d][i] < -0.5)'
p27711
aS'          {'
p27712
aS'            return_value[i] = 100.0;'
p27713
aS'            break;'
p27714
aS'          }'
p27715
aS'    }'
p27716
aS'  return return_value;'
p27717
ag32
aS'template <int dim>'
p27718
aS'template <typename number>'
p27719
aS'number Coefficient<dim>::average_value('
p27720
aS'  const std::vector<Point<dim, number>> &points) const'
p27721
ag24
aS'  number average(0);'
p27722
aS'  for (unsigned int i = 0; i < points.size(); ++i)'
p27723
aS'    average += value(points[i]);'
p27724
aS'  average /= points.size();'
p27725
aS'  return average;'
p27726
ag32
aS'template <int dim>'
p27727
aS'template <typename number>'
p27728
aS'std::shared_ptr<Table<2, VectorizedArray<number>>>'
p27729
aS'Coefficient<dim>::make_coefficient_table('
p27730
aS'  const MatrixFree<dim, number, VectorizedArray<number>> &mf_storage) const'
p27731
ag24
aS'  auto coefficient_table ='
p27732
aS'    std::make_shared<Table<2, VectorizedArray<number>>>();'
p27733
aS'  FEEvaluation<dim, -1, 0, 1, number> fe_eval(mf_storage);'
p27734
aS'  const unsigned int n_cells    = mf_storage.n_cell_batches();'
p27735
aS'  const unsigned int n_q_points = fe_eval.n_q_points;'
p27736
aS'  coefficient_table->reinit(n_cells, 1);'
p27737
aS'  for (unsigned int cell = 0; cell < n_cells; ++cell)'
p27738
aS'    {'
p27739
aS'      fe_eval.reinit(cell);'
p27740
aS'      VectorizedArray<number> average_value = 0.;'
p27741
aS'      for (unsigned int q = 0; q < n_q_points; ++q)'
p27742
aS'        average_value += value(fe_eval.quadrature_point(q));'
p27743
aS'      average_value /= n_q_points;'
p27744
aS'      (*coefficient_table)(cell, 0) = average_value;'
p27745
aS'    }'
p27746
aS'  return coefficient_table;'
p27747
ag32
aS'struct Settings'
p27748
ag24
aS'  bool try_parse(const std::string &prm_filename);'
p27749
aS'  enum SolverType'
p27750
aS'  {'
p27751
aS'    gmg_mb,'
p27752
aS'    gmg_mf,'
p27753
aS'    amg'
p27754
aS'  };'
p27755
aS'  SolverType solver;'
p27756
aS'  int          dimension;'
p27757
aS'  double       smoother_dampen;'
p27758
aS'  unsigned int smoother_steps;'
p27759
aS'  unsigned int n_steps;'
p27760
aS'  bool         output;'
p27761
aS'};'
p27762
aS'bool Settings::try_parse(const std::string &prm_filename)'
p27763
ag24
aS'  ParameterHandler prm;'
p27764
aS'  prm.declare_entry("dim", "2", Patterns::Integer(), "The problem dimension.");'
p27765
aS'  prm.declare_entry("n_steps",'
p27766
aS'                    "10",'
p27767
aS'                    Patterns::Integer(0),'
p27768
aS'                    "Number of adaptive refinement steps.");'
p27769
aS'  prm.declare_entry("smoother dampen",'
p27770
aS'                    "1.0",'
p27771
aS'                    Patterns::Double(0.0),'
p27772
aS'                    "Dampen factor for the smoother.");'
p27773
aS'  prm.declare_entry("smoother steps",'
p27774
aS'                    "1",'
p27775
aS'                    Patterns::Integer(1),'
p27776
aS'                    "Number of smoother steps.");'
p27777
aS'  prm.declare_entry("solver",'
p27778
aS'                    "MF",'
p27779
aS'                    Patterns::Selection("MF|MB|AMG"),'
p27780
aS'                    "Switch between matrix-free GMG, "'
p27781
aS'                    "matrix-based GMG, and AMG.");'
p27782
aS'  prm.declare_entry("output",'
p27783
aS'                    "false",'
p27784
aS'                    Patterns::Bool(),'
p27785
aS'                    "Output graphical results.");'
p27786
aS'  if (prm_filename.size() == 0)'
p27787
aS'    {'
p27788
aS'      std::cout << "****  Error: No input file provided!\\n"'
p27789
aS'                << "****  Error: Call this program as \'./step-50 input.prm\\n"'
p27790
aS'                << "\\n"'
p27791
aS'                << "****  You may want to use one of the input files in this\\n"'
p27792
aS'                << "****  directory, or use the following default values\\n"'
p27793
aS'                << "****  to create an input file:\\n";'
p27794
aS'      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p27795
aS'        prm.print_parameters(std::cout, ParameterHandler::Text);'
p27796
aS'      return false;'
p27797
aS'    }'
p27798
aS'  try'
p27799
aS'    {'
p27800
aS'      prm.parse_input(prm_filename);'
p27801
aS'    }'
p27802
aS'  catch (std::exception &e)'
p27803
aS'    {'
p27804
aS'      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p27805
aS'        std::cerr << e.what() << std::endl;'
p27806
aS'      return false;'
p27807
aS'    }'
p27808
aS'  if (prm.get("solver") == "MF")'
p27809
aS'    this->solver = gmg_mf;'
p27810
aS'  else if (prm.get("solver") == "MB")'
p27811
aS'    this->solver = gmg_mb;'
p27812
aS'  else if (prm.get("solver") == "AMG")'
p27813
aS'    this->solver = amg;'
p27814
aS'  else'
p27815
aS'    AssertThrow(false, ExcNotImplemented());'
p27816
aS'  this->dimension       = prm.get_integer("dim");'
p27817
aS'  this->n_steps         = prm.get_integer("n_steps");'
p27818
aS'  this->smoother_dampen = prm.get_double("smoother dampen");'
p27819
aS'  this->smoother_steps  = prm.get_integer("smoother steps");'
p27820
aS'  this->output          = prm.get_bool("output");'
p27821
aS'  return true;'
p27822
ag32
aS'template <int dim, int degree>'
p27823
aS'class LaplaceProblem'
p27824
ag24
aS'public:'
p27825
aS'  LaplaceProblem(const Settings &settings);'
p27826
aS'  void run();'
p27827
aS'private:'
p27828
aS'  using MatrixType         = LA::MPI::SparseMatrix;'
p27829
aS'  using VectorType         = LA::MPI::Vector;'
p27830
aS'  using PreconditionAMG    = LA::MPI::PreconditionAMG;'
p27831
aS'  using PreconditionJacobi = LA::MPI::PreconditionJacobi;'
p27832
aS'  using MatrixFreeLevelMatrix = MatrixFreeOperators::LaplaceOperator<'
p27833
aS'    dim,'
p27834
aS'    degree,'
p27835
aS'    degree + 1,'
p27836
aS'    1,'
p27837
aS'    LinearAlgebra::distributed::Vector<float>>;'
p27838
aS'  using MatrixFreeActiveMatrix = MatrixFreeOperators::LaplaceOperator<'
p27839
aS'    dim,'
p27840
aS'    degree,'
p27841
aS'    degree + 1,'
p27842
aS'    1,'
p27843
aS'    LinearAlgebra::distributed::Vector<double>>;'
p27844
aS'  using MatrixFreeLevelVector  = LinearAlgebra::distributed::Vector<float>;'
p27845
aS'  using MatrixFreeActiveVector = LinearAlgebra::distributed::Vector<double>;'
p27846
aS'  void setup_system();'
p27847
aS'  void setup_multigrid();'
p27848
aS'  void assemble_system();'
p27849
aS'  void assemble_multigrid();'
p27850
aS'  void assemble_rhs();'
p27851
aS'  void solve();'
p27852
aS'  void estimate();'
p27853
aS'  void refine_grid();'
p27854
aS'  void output_results(const unsigned int cycle);'
p27855
aS'  Settings settings;'
p27856
aS'  MPI_Comm           mpi_communicator;'
p27857
aS'  ConditionalOStream pcout;'
p27858
aS'  parallel::distributed::Triangulation<dim> triangulation;'
p27859
aS'  const MappingQ1<dim>                      mapping;'
p27860
aS'  FE_Q<dim>                                 fe;'
p27861
aS'  DoFHandler<dim> dof_handler;'
p27862
aS'  IndexSet                  locally_owned_dofs;'
p27863
aS'  IndexSet                  locally_relevant_dofs;'
p27864
aS'  AffineConstraints<double> constraints;'
p27865
aS'  MatrixType             system_matrix;'
p27866
aS'  MatrixFreeActiveMatrix mf_system_matrix;'
p27867
aS'  VectorType             solution;'
p27868
aS'  VectorType             right_hand_side;'
p27869
aS'  Vector<double>         estimated_error_square_per_cell;'
p27870
aS'  MGLevelObject<MatrixType> mg_matrix;'
p27871
aS'  MGLevelObject<MatrixType> mg_interface_in;'
p27872
aS'  MGConstrainedDoFs         mg_constrained_dofs;'
p27873
aS'  MGLevelObject<MatrixFreeLevelMatrix> mf_mg_matrix;'
p27874
aS'  TimerOutput computing_timer;'
p27875
aS'};'
p27876
aS'template <int dim, int degree>'
p27877
aS'LaplaceProblem<dim, degree>::LaplaceProblem(const Settings &settings)'
p27878
aS'  : settings(settings)'
p27879
aS'  , mpi_communicator(MPI_COMM_WORLD)'
p27880
aS'  , pcout(std::cout, (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p27881
aS'  , triangulation(mpi_communicator,'
p27882
aS'                  Triangulation<dim>::limit_level_difference_at_vertices,'
p27883
aS'                  (settings.solver == Settings::amg) ?'
p27884
aS'                    parallel::distributed::Triangulation<dim>::default_setting :'
p27885
aS'                    parallel::distributed::Triangulation<'
p27886
aS'                      dim>::construct_multigrid_hierarchy)'
p27887
aS'  , mapping()'
p27888
aS'  , fe(degree)'
p27889
aS'  , dof_handler(triangulation)'
p27890
aS'  , computing_timer(pcout, TimerOutput::never, TimerOutput::wall_times)'
p27891
ag24
aS'  GridGenerator::hyper_L(triangulation, -1., 1., /*colorize*/ false);'
p27892
aS'  triangulation.refine_global(1);'
p27893
ag32
aS'template <int dim, int degree>'
p27894
aS'void LaplaceProblem<dim, degree>::setup_system()'
p27895
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Setup");'
p27896
aS'  dof_handler.distribute_dofs(fe);'
p27897
aS'  DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p27898
aS'  locally_owned_dofs = dof_handler.locally_owned_dofs();'
p27899
aS'  solution.reinit(locally_owned_dofs, mpi_communicator);'
p27900
aS'  right_hand_side.reinit(locally_owned_dofs, mpi_communicator);'
p27901
aS'  constraints.reinit(locally_relevant_dofs);'
p27902
aS'  DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p27903
aS'  VectorTools::interpolate_boundary_values('
p27904
aS'    mapping, dof_handler, 0, Functions::ZeroFunction<dim>(), constraints);'
p27905
aS'  constraints.close();'
p27906
aS'  switch (settings.solver)'
p27907
aS'    {'
p27908
aS'      case Settings::gmg_mf:'
p27909
aS'        {'
p27910
aS'          typename MatrixFree<dim, double>::AdditionalData additional_data;'
p27911
aS'          additional_data.tasks_parallel_scheme ='
p27912
aS'            MatrixFree<dim, double>::AdditionalData::none;'
p27913
aS'          additional_data.mapping_update_flags ='
p27914
aS'            (update_gradients | update_JxW_values | update_quadrature_points);'
p27915
aS'          std::shared_ptr<MatrixFree<dim, double>> mf_storage ='
p27916
aS'            std::make_shared<MatrixFree<dim, double>>();'
p27917
aS'          mf_storage->reinit(mapping,'
p27918
aS'                             dof_handler,'
p27919
aS'                             constraints,'
p27920
aS'                             QGauss<1>(degree + 1),'
p27921
aS'                             additional_data);'
p27922
aS'          mf_system_matrix.initialize(mf_storage);'
p27923
aS'          const Coefficient<dim> coefficient;'
p27924
aS'          mf_system_matrix.set_coefficient('
p27925
aS'            coefficient.make_coefficient_table(*mf_storage));'
p27926
aS'          break;'
p27927
aS'        }'
p27928
aS'      case Settings::gmg_mb:'
p27929
aS'      case Settings::amg:'
p27930
aS'        {'
p27931
aS'#ifdef USE_PETSC_LA'
p27932
aS'          DynamicSparsityPattern dsp(locally_relevant_dofs);'
p27933
aS'          DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p27934
aS'          SparsityTools::distribute_sparsity_pattern(dsp,'
p27935
aS'                                                     locally_owned_dofs,'
p27936
aS'                                                     mpi_communicator,'
p27937
aS'                                                     locally_relevant_dofs);'
p27938
aS'          system_matrix.reinit(locally_owned_dofs,'
p27939
aS'                               locally_owned_dofs,'
p27940
aS'                               dsp,'
p27941
aS'                               mpi_communicator);'
p27942
aS'#else'
p27943
aS'          TrilinosWrappers::SparsityPattern dsp(locally_owned_dofs,'
p27944
aS'                                                locally_owned_dofs,'
p27945
aS'                                                locally_relevant_dofs,'
p27946
aS'                                                mpi_communicator);'
p27947
aS'          DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p27948
aS'          dsp.compress();'
p27949
aS'          system_matrix.reinit(dsp);'
p27950
aS'#endif'
p27951
aS'          break;'
p27952
aS'        }'
p27953
aS'      default:'
p27954
aS'        Assert(false, ExcNotImplemented());'
p27955
aS'    }'
p27956
ag32
aS'template <int dim, int degree>'
p27957
aS'void LaplaceProblem<dim, degree>::setup_multigrid()'
p27958
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Setup multigrid");'
p27959
aS'  dof_handler.distribute_mg_dofs();'
p27960
aS'  mg_constrained_dofs.clear();'
p27961
aS'  mg_constrained_dofs.initialize(dof_handler);'
p27962
aS'  const std::set<types::boundary_id> boundary_ids = {types::boundary_id(0)};'
p27963
aS'  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, boundary_ids);'
p27964
aS'  const unsigned int n_levels = triangulation.n_global_levels();'
p27965
aS'  switch (settings.solver)'
p27966
aS'    {'
p27967
aS'      case Settings::gmg_mf:'
p27968
aS'        {'
p27969
aS'          mf_mg_matrix.resize(0, n_levels - 1);'
p27970
aS'          for (unsigned int level = 0; level < n_levels; ++level)'
p27971
aS'            {'
p27972
aS'              IndexSet relevant_dofs;'
p27973
aS'              DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p27974
aS'                                                            level,'
p27975
aS'                                                            relevant_dofs);'
p27976
aS'              AffineConstraints<double> level_constraints;'
p27977
aS'              level_constraints.reinit(relevant_dofs);'
p27978
aS'              level_constraints.add_lines('
p27979
aS'                mg_constrained_dofs.get_boundary_indices(level));'
p27980
aS'              level_constraints.close();'
p27981
aS'              typename MatrixFree<dim, float>::AdditionalData additional_data;'
p27982
aS'              additional_data.tasks_parallel_scheme ='
p27983
aS'                MatrixFree<dim, float>::AdditionalData::none;'
p27984
aS'              additional_data.mapping_update_flags ='
p27985
aS'                (update_gradients | update_JxW_values |'
p27986
aS'                 update_quadrature_points);'
p27987
aS'              additional_data.mg_level = level;'
p27988
aS'              std::shared_ptr<MatrixFree<dim, float>> mf_storage_level('
p27989
aS'                new MatrixFree<dim, float>());'
p27990
aS'              mf_storage_level->reinit(mapping,'
p27991
aS'                                       dof_handler,'
p27992
aS'                                       level_constraints,'
p27993
aS'                                       QGauss<1>(degree + 1),'
p27994
aS'                                       additional_data);'
p27995
aS'              mf_mg_matrix[level].initialize(mf_storage_level,'
p27996
aS'                                             mg_constrained_dofs,'
p27997
aS'                                             level);'
p27998
aS'              const Coefficient<dim> coefficient;'
p27999
aS'              mf_mg_matrix[level].set_coefficient('
p28000
aS'                coefficient.make_coefficient_table(*mf_storage_level));'
p28001
aS'              mf_mg_matrix[level].compute_diagonal();'
p28002
aS'            }'
p28003
aS'          break;'
p28004
aS'        }'
p28005
aS'      case Settings::gmg_mb:'
p28006
aS'        {'
p28007
aS'          mg_matrix.resize(0, n_levels - 1);'
p28008
aS'          mg_matrix.clear_elements();'
p28009
aS'          mg_interface_in.resize(0, n_levels - 1);'
p28010
aS'          mg_interface_in.clear_elements();'
p28011
aS'          for (unsigned int level = 0; level < n_levels; ++level)'
p28012
aS'            {'
p28013
aS'              IndexSet dof_set;'
p28014
aS'              DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p28015
aS'                                                            level,'
p28016
aS'                                                            dof_set);'
p28017
aS'              {'
p28018
aS'#ifdef USE_PETSC_LA'
p28019
aS'                DynamicSparsityPattern dsp(dof_set);'
p28020
aS'                MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p28021
aS'                dsp.compress();'
p28022
aS'                SparsityTools::distribute_sparsity_pattern('
p28023
aS'                  dsp,'
p28024
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28025
aS'                  mpi_communicator,'
p28026
aS'                  dof_set);'
p28027
aS'                mg_matrix[level].reinit('
p28028
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28029
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28030
aS'                  dsp,'
p28031
aS'                  mpi_communicator);'
p28032
aS'#else'
p28033
aS'                TrilinosWrappers::SparsityPattern dsp('
p28034
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28035
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28036
aS'                  dof_set,'
p28037
aS'                  mpi_communicator);'
p28038
aS'                MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p28039
aS'                dsp.compress();'
p28040
aS'                mg_matrix[level].reinit(dsp);'
p28041
aS'#endif'
p28042
aS'              }'
p28043
aS'              {'
p28044
aS'#ifdef USE_PETSC_LA'
p28045
aS'                DynamicSparsityPattern dsp(dof_set);'
p28046
aS'                MGTools::make_interface_sparsity_pattern(dof_handler,'
p28047
aS'                                                         mg_constrained_dofs,'
p28048
aS'                                                         dsp,'
p28049
aS'                                                         level);'
p28050
aS'                dsp.compress();'
p28051
aS'                SparsityTools::distribute_sparsity_pattern('
p28052
aS'                  dsp,'
p28053
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28054
aS'                  mpi_communicator,'
p28055
aS'                  dof_set);'
p28056
aS'                mg_interface_in[level].reinit('
p28057
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28058
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28059
aS'                  dsp,'
p28060
aS'                  mpi_communicator);'
p28061
aS'#else'
p28062
aS'                TrilinosWrappers::SparsityPattern dsp('
p28063
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28064
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p28065
aS'                  dof_set,'
p28066
aS'                  mpi_communicator);'
p28067
aS'                MGTools::make_interface_sparsity_pattern(dof_handler,'
p28068
aS'                                                         mg_constrained_dofs,'
p28069
aS'                                                         dsp,'
p28070
aS'                                                         level);'
p28071
aS'                dsp.compress();'
p28072
aS'                mg_interface_in[level].reinit(dsp);'
p28073
aS'#endif'
p28074
aS'              }'
p28075
aS'            }'
p28076
aS'          break;'
p28077
aS'        }'
p28078
aS'      default:'
p28079
aS'        Assert(false, ExcNotImplemented());'
p28080
aS'    }'
p28081
ag32
aS'template <int dim, int degree>'
p28082
aS'void LaplaceProblem<dim, degree>::assemble_system()'
p28083
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Assemble");'
p28084
aS'  const QGauss<dim> quadrature_formula(degree + 1);'
p28085
aS'  FEValues<dim> fe_values(fe,'
p28086
aS'                          quadrature_formula,'
p28087
aS'                          update_values | update_gradients |'
p28088
aS'                            update_quadrature_points | update_JxW_values);'
p28089
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p28090
aS'  const unsigned int n_q_points    = quadrature_formula.size();'
p28091
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p28092
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p28093
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p28094
aS'  const Coefficient<dim> coefficient;'
p28095
aS'  RightHandSide<dim>     rhs;'
p28096
aS'  std::vector<double>    rhs_values(n_q_points);'
p28097
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p28098
aS'    if (cell->is_locally_owned())'
p28099
aS'      {'
p28100
aS'        cell_matrix = 0;'
p28101
aS'        cell_rhs    = 0;'
p28102
aS'        fe_values.reinit(cell);'
p28103
aS'        const double coefficient_value ='
p28104
aS'          coefficient.average_value(fe_values.get_quadrature_points());'
p28105
aS'        rhs.value_list(fe_values.get_quadrature_points(), rhs_values);'
p28106
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p28107
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p28108
aS'            {'
p28109
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p28110
aS'                cell_matrix(i, j) +='
p28111
aS'                  coefficient_value *                // epsilon(x)'
p28112
aS'                  fe_values.shape_grad(i, q_point) * // * grad phi_i(x)'
p28113
aS'                  fe_values.shape_grad(j, q_point) * // * grad phi_j(x)'
p28114
aS'                  fe_values.JxW(q_point);            // * dx'
p28115
aS'              cell_rhs(i) +='
p28116
aS'                fe_values.shape_value(i, q_point) * // grad phi_i(x)'
p28117
aS'                rhs_values[q_point] *               // * f(x)'
p28118
aS'                fe_values.JxW(q_point);             // * dx'
p28119
aS'            }'
p28120
aS'        cell->get_dof_indices(local_dof_indices);'
p28121
aS'        constraints.distribute_local_to_global(cell_matrix,'
p28122
aS'                                               cell_rhs,'
p28123
aS'                                               local_dof_indices,'
p28124
aS'                                               system_matrix,'
p28125
aS'                                               right_hand_side);'
p28126
aS'      }'
p28127
aS'  system_matrix.compress(VectorOperation::add);'
p28128
aS'  right_hand_side.compress(VectorOperation::add);'
p28129
ag32
aS'template <int dim, int degree>'
p28130
aS'void LaplaceProblem<dim, degree>::assemble_multigrid()'
p28131
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Assemble multigrid");'
p28132
aS'  QGauss<dim> quadrature_formula(degree + 1);'
p28133
aS'  FEValues<dim> fe_values(fe,'
p28134
aS'                          quadrature_formula,'
p28135
aS'                          update_values | update_gradients |'
p28136
aS'                            update_quadrature_points | update_JxW_values);'
p28137
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p28138
aS'  const unsigned int n_q_points    = quadrature_formula.size();'
p28139
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p28140
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p28141
aS'  const Coefficient<dim> coefficient;'
p28142
aS'  std::vector<AffineConstraints<double>> boundary_constraints('
p28143
aS'    triangulation.n_global_levels());'
p28144
aS'  for (unsigned int level = 0; level < triangulation.n_global_levels(); ++level)'
p28145
aS'    {'
p28146
aS'      IndexSet dof_set;'
p28147
aS'      DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p28148
aS'                                                    level,'
p28149
aS'                                                    dof_set);'
p28150
aS'      boundary_constraints[level].reinit(dof_set);'
p28151
aS'      boundary_constraints[level].add_lines('
p28152
aS'        mg_constrained_dofs.get_refinement_edge_indices(level));'
p28153
aS'      boundary_constraints[level].add_lines('
p28154
aS'        mg_constrained_dofs.get_boundary_indices(level));'
p28155
aS'      boundary_constraints[level].close();'
p28156
aS'    }'
p28157
aS'  for (const auto &cell : dof_handler.cell_iterators())'
p28158
aS'    if (cell->level_subdomain_id() == triangulation.locally_owned_subdomain())'
p28159
aS'      {'
p28160
aS'        cell_matrix = 0;'
p28161
aS'        fe_values.reinit(cell);'
p28162
aS'        const double coefficient_value ='
p28163
aS'          coefficient.average_value(fe_values.get_quadrature_points());'
p28164
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p28165
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p28166
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p28167
aS'              cell_matrix(i, j) +='
p28168
aS'                coefficient_value * fe_values.shape_grad(i, q_point) *'
p28169
aS'                fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point);'
p28170
aS'        cell->get_mg_dof_indices(local_dof_indices);'
p28171
aS'        boundary_constraints[cell->level()].distribute_local_to_global('
p28172
aS'          cell_matrix, local_dof_indices, mg_matrix[cell->level()]);'
p28173
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p28174
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p28175
aS'            if (mg_constrained_dofs.is_interface_matrix_entry('
p28176
aS'                  cell->level(), local_dof_indices[i], local_dof_indices[j]))'
p28177
aS'              mg_interface_in[cell->level()].add(local_dof_indices[i],'
p28178
aS'                                                 local_dof_indices[j],'
p28179
aS'                                                 cell_matrix(i, j));'
p28180
aS'      }'
p28181
aS'  for (unsigned int i = 0; i < triangulation.n_global_levels(); ++i)'
p28182
aS'    {'
p28183
aS'      mg_matrix[i].compress(VectorOperation::add);'
p28184
aS'      mg_interface_in[i].compress(VectorOperation::add);'
p28185
aS'    }'
p28186
ag32
aS'template <int dim, int degree>'
p28187
aS'void LaplaceProblem<dim, degree>::assemble_rhs()'
p28188
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Assemble right-hand side");'
p28189
aS'  MatrixFreeActiveVector solution_copy;'
p28190
aS'  MatrixFreeActiveVector right_hand_side_copy;'
p28191
aS'  mf_system_matrix.initialize_dof_vector(solution_copy);'
p28192
aS'  mf_system_matrix.initialize_dof_vector(right_hand_side_copy);'
p28193
aS'  solution_copy = 0.;'
p28194
aS'  constraints.distribute(solution_copy);'
p28195
aS'  solution_copy.update_ghost_values();'
p28196
aS'  right_hand_side_copy = 0;'
p28197
aS'  const Table<2, VectorizedArray<double>> &coefficient ='
p28198
aS'    *(mf_system_matrix.get_coefficient());'
p28199
aS'  RightHandSide<dim> right_hand_side_function;'
p28200
aS'  FEEvaluation<dim, degree, degree + 1, 1, double> phi('
p28201
aS'    *mf_system_matrix.get_matrix_free());'
p28202
aS'  for (unsigned int cell = 0;'
p28203
aS'       cell < mf_system_matrix.get_matrix_free()->n_cell_batches();'
p28204
aS'       ++cell)'
p28205
aS'    {'
p28206
aS'      phi.reinit(cell);'
p28207
aS'      phi.read_dof_values_plain(solution_copy);'
p28208
aS'      phi.evaluate(EvaluationFlags::gradients);'
p28209
aS'      for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p28210
aS'        {'
p28211
aS'          phi.submit_gradient(-1.0 *'
p28212
aS'                                (coefficient(cell, 0) * phi.get_gradient(q)),'
p28213
aS'                              q);'
p28214
aS'          phi.submit_value('
p28215
aS'            right_hand_side_function.value(phi.quadrature_point(q)), q);'
p28216
aS'        }'
p28217
aS'      phi.integrate_scatter(EvaluationFlags::values |'
p28218
aS'                              EvaluationFlags::gradients,'
p28219
aS'                            right_hand_side_copy);'
p28220
aS'    }'
p28221
aS'  right_hand_side_copy.compress(VectorOperation::add);'
p28222
aS'  ChangeVectorTypes::copy(right_hand_side, right_hand_side_copy);'
p28223
ag32
aS'template <int dim, int degree>'
p28224
aS'void LaplaceProblem<dim, degree>::solve()'
p28225
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Solve");'
p28226
aS'  SolverControl solver_control(1000, 1.e-10 * right_hand_side.l2_norm());'
p28227
aS'  solver_control.enable_history_data();'
p28228
aS'  solution = 0.;'
p28229
aS'  switch (settings.solver)'
p28230
aS'    {'
p28231
aS'      case Settings::gmg_mf:'
p28232
aS'        {'
p28233
aS'          computing_timer.enter_subsection("Solve: Preconditioner setup");'
p28234
aS'          MGTransferMatrixFree<dim, float> mg_transfer(mg_constrained_dofs);'
p28235
aS'          mg_transfer.build(dof_handler);'
p28236
aS'          SolverControl coarse_solver_control(1000, 1e-12, false, false);'
p28237
aS'          SolverCG<MatrixFreeLevelVector> coarse_solver(coarse_solver_control);'
p28238
aS'          PreconditionIdentity            identity;'
p28239
aS'          MGCoarseGridIterativeSolver<MatrixFreeLevelVector,'
p28240
aS'                                      SolverCG<MatrixFreeLevelVector>,'
p28241
aS'                                      MatrixFreeLevelMatrix,'
p28242
aS'                                      PreconditionIdentity>'
p28243
aS'            coarse_grid_solver(coarse_solver, mf_mg_matrix[0], identity);'
p28244
aS'          using Smoother = dealii::PreconditionJacobi<MatrixFreeLevelMatrix>;'
p28245
aS'          MGSmootherPrecondition<MatrixFreeLevelMatrix,'
p28246
aS'                                 Smoother,'
p28247
aS'                                 MatrixFreeLevelVector>'
p28248
aS'            smoother;'
p28249
aS'          smoother.initialize(mf_mg_matrix,'
p28250
aS'                              typename Smoother::AdditionalData('
p28251
aS'                                settings.smoother_dampen));'
p28252
aS'          smoother.set_steps(settings.smoother_steps);'
p28253
aS'          mg::Matrix<MatrixFreeLevelVector> mg_m(mf_mg_matrix);'
p28254
aS'          MGLevelObject<'
p28255
aS'            MatrixFreeOperators::MGInterfaceOperator<MatrixFreeLevelMatrix>>'
p28256
aS'            mg_interface_matrices;'
p28257
aS'          mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1);'
p28258
aS'          for (unsigned int level = 0; level < triangulation.n_global_levels();'
p28259
aS'               ++level)'
p28260
aS'            mg_interface_matrices[level].initialize(mf_mg_matrix[level]);'
p28261
aS'          mg::Matrix<MatrixFreeLevelVector> mg_interface(mg_interface_matrices);'
p28262
aS'          Multigrid<MatrixFreeLevelVector> mg('
p28263
aS'            mg_m, coarse_grid_solver, mg_transfer, smoother, smoother);'
p28264
aS'          mg.set_edge_matrices(mg_interface, mg_interface);'
p28265
aS'          PreconditionMG<dim,'
p28266
aS'                         MatrixFreeLevelVector,'
p28267
aS'                         MGTransferMatrixFree<dim, float>>'
p28268
aS'            preconditioner(dof_handler, mg, mg_transfer);'
p28269
aS'          MatrixFreeActiveVector solution_copy;'
p28270
aS'          MatrixFreeActiveVector right_hand_side_copy;'
p28271
aS'          mf_system_matrix.initialize_dof_vector(solution_copy);'
p28272
aS'          mf_system_matrix.initialize_dof_vector(right_hand_side_copy);'
p28273
aS'          ChangeVectorTypes::copy(solution_copy, solution);'
p28274
aS'          ChangeVectorTypes::copy(right_hand_side_copy, right_hand_side);'
p28275
aS'          computing_timer.leave_subsection("Solve: Preconditioner setup");'
p28276
aS'          {'
p28277
aS'            TimerOutput::Scope timing(computing_timer,'
p28278
aS'                                      "Solve: 1 multigrid V-cycle");'
p28279
aS'            preconditioner.vmult(solution_copy, right_hand_side_copy);'
p28280
aS'          }'
p28281
aS'          solution_copy = 0.;'
p28282
aS'          {'
p28283
aS'            SolverCG<MatrixFreeActiveVector> solver(solver_control);'
p28284
aS'            TimerOutput::Scope timing(computing_timer, "Solve: CG");'
p28285
aS'            solver.solve(mf_system_matrix,'
p28286
aS'                         solution_copy,'
p28287
aS'                         right_hand_side_copy,'
p28288
aS'                         preconditioner);'
p28289
aS'          }'
p28290
aS'          solution_copy.update_ghost_values();'
p28291
aS'          ChangeVectorTypes::copy(solution, solution_copy);'
p28292
aS'          constraints.distribute(solution);'
p28293
aS'          break;'
p28294
aS'        }'
p28295
aS'      case Settings::gmg_mb:'
p28296
aS'        {'
p28297
aS'          computing_timer.enter_subsection("Solve: Preconditioner setup");'
p28298
aS'          MGTransferPrebuilt<VectorType> mg_transfer(mg_constrained_dofs);'
p28299
aS'          mg_transfer.build(dof_handler);'
p28300
aS'          SolverControl        coarse_solver_control(1000, 1e-12, false, false);'
p28301
aS'          SolverCG<VectorType> coarse_solver(coarse_solver_control);'
p28302
aS'          PreconditionIdentity identity;'
p28303
aS'          MGCoarseGridIterativeSolver<VectorType,'
p28304
aS'                                      SolverCG<VectorType>,'
p28305
aS'                                      MatrixType,'
p28306
aS'                                      PreconditionIdentity>'
p28307
aS'            coarse_grid_solver(coarse_solver, mg_matrix[0], identity);'
p28308
aS'          using Smoother = LA::MPI::PreconditionJacobi;'
p28309
aS'          MGSmootherPrecondition<MatrixType, Smoother, VectorType> smoother;'
p28310
aS'#ifdef USE_PETSC_LA'
p28311
aS'          smoother.initialize(mg_matrix);'
p28312
aS'          Assert('
p28313
aS'            settings.smoother_dampen == 1.0,'
p28314
aS'            ExcNotImplemented('
p28315
aS'              "PETSc\'s PreconditionJacobi has no support for a damping parameter."));'
p28316
aS'#else'
p28317
aS'          smoother.initialize(mg_matrix, settings.smoother_dampen);'
p28318
aS'#endif'
p28319
aS'          smoother.set_steps(settings.smoother_steps);'
p28320
aS'          mg::Matrix<VectorType> mg_m(mg_matrix);'
p28321
aS'          mg::Matrix<VectorType> mg_in(mg_interface_in);'
p28322
aS'          mg::Matrix<VectorType> mg_out(mg_interface_in);'
p28323
aS'          Multigrid<VectorType> mg('
p28324
aS'            mg_m, coarse_grid_solver, mg_transfer, smoother, smoother);'
p28325
aS'          mg.set_edge_matrices(mg_out, mg_in);'
p28326
aS'          PreconditionMG<dim, VectorType, MGTransferPrebuilt<VectorType>>'
p28327
aS'            preconditioner(dof_handler, mg, mg_transfer);'
p28328
aS'          computing_timer.leave_subsection("Solve: Preconditioner setup");'
p28329
aS'          {'
p28330
aS'            TimerOutput::Scope timing(computing_timer,'
p28331
aS'                                      "Solve: 1 multigrid V-cycle");'
p28332
aS'            preconditioner.vmult(solution, right_hand_side);'
p28333
aS'          }'
p28334
aS'          solution = 0.;'
p28335
aS'          {'
p28336
aS'            SolverCG<VectorType> solver(solver_control);'
p28337
aS'            TimerOutput::Scope timing(computing_timer, "Solve: CG");'
p28338
aS'            solver.solve(system_matrix,'
p28339
aS'                         solution,'
p28340
aS'                         right_hand_side,'
p28341
aS'                         preconditioner);'
p28342
aS'          }'
p28343
aS'          constraints.distribute(solution);'
p28344
aS'          break;'
p28345
aS'        }'
p28346
aS'      case Settings::amg:'
p28347
aS'        {'
p28348
aS'          computing_timer.enter_subsection("Solve: Preconditioner setup");'
p28349
aS'          PreconditionAMG                 preconditioner;'
p28350
aS'          PreconditionAMG::AdditionalData Amg_data;'
p28351
aS'#ifdef USE_PETSC_LA'
p28352
aS'          Amg_data.symmetric_operator = true;'
p28353
aS'#else'
p28354
aS'          Amg_data.elliptic              = true;'
p28355
aS'          Amg_data.smoother_type         = "Jacobi";'
p28356
aS'          Amg_data.higher_order_elements = true;'
p28357
aS'          Amg_data.smoother_sweeps       = settings.smoother_steps;'
p28358
aS'          Amg_data.aggregation_threshold = 0.02;'
p28359
aS'#endif'
p28360
aS'          Amg_data.output_details = false;'
p28361
aS'          preconditioner.initialize(system_matrix, Amg_data);'
p28362
aS'          computing_timer.leave_subsection("Solve: Preconditioner setup");'
p28363
aS'          {'
p28364
aS'            TimerOutput::Scope timing(computing_timer,'
p28365
aS'                                      "Solve: 1 multigrid V-cycle");'
p28366
aS'            preconditioner.vmult(solution, right_hand_side);'
p28367
aS'          }'
p28368
aS'          solution = 0.;'
p28369
aS'          {'
p28370
aS'            SolverCG<VectorType> solver(solver_control);'
p28371
aS'            TimerOutput::Scope timing(computing_timer, "Solve: CG");'
p28372
aS'            solver.solve(system_matrix,'
p28373
aS'                         solution,'
p28374
aS'                         right_hand_side,'
p28375
aS'                         preconditioner);'
p28376
aS'          }'
p28377
aS'          constraints.distribute(solution);'
p28378
aS'          break;'
p28379
aS'        }'
p28380
aS'      default:'
p28381
aS'        Assert(false, ExcInternalError());'
p28382
aS'    }'
p28383
aS'  pcout << "   Number of CG iterations:      " << solver_control.last_step()'
p28384
aS'        << std::endl;'
p28385
ag32
aS'template <int dim>'
p28386
aS'struct ScratchData'
p28387
ag24
aS'  ScratchData(const Mapping<dim> &      mapping,'
p28388
aS'              const FiniteElement<dim> &fe,'
p28389
aS'              const unsigned int        quadrature_degree,'
p28390
aS'              const UpdateFlags         update_flags,'
p28391
aS'              const UpdateFlags         interface_update_flags)'
p28392
aS'    : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)'
p28393
aS'    , fe_interface_values(mapping,'
p28394
aS'                          fe,'
p28395
aS'                          QGauss<dim - 1>(quadrature_degree),'
p28396
aS'                          interface_update_flags)'
p28397
aS'  {}'
p28398
aS'  ScratchData(const ScratchData<dim> &scratch_data)'
p28399
aS'    : fe_values(scratch_data.fe_values.get_mapping(),'
p28400
aS'                scratch_data.fe_values.get_fe(),'
p28401
aS'                scratch_data.fe_values.get_quadrature(),'
p28402
aS'                scratch_data.fe_values.get_update_flags())'
p28403
aS'    , fe_interface_values(scratch_data.fe_values.get_mapping(),'
p28404
aS'                          scratch_data.fe_values.get_fe(),'
p28405
aS'                          scratch_data.fe_interface_values.get_quadrature(),'
p28406
aS'                          scratch_data.fe_interface_values.get_update_flags())'
p28407
aS'  {}'
p28408
aS'  FEValues<dim>          fe_values;'
p28409
aS'  FEInterfaceValues<dim> fe_interface_values;'
p28410
aS'};'
p28411
aS'struct CopyData'
p28412
ag24
aS'  CopyData()'
p28413
aS'    : cell_index(numbers::invalid_unsigned_int)'
p28414
aS'    , value(0.)'
p28415
aS'  {}'
p28416
aS'  CopyData(const CopyData &) = default;'
p28417
aS'  struct FaceData'
p28418
aS'  {'
p28419
aS'    unsigned int cell_indices[2];'
p28420
aS'    double       values[2];'
p28421
aS'  };'
p28422
aS'  unsigned int          cell_index;'
p28423
aS'  double                value;'
p28424
aS'  std::vector<FaceData> face_data;'
p28425
aS'};'
p28426
aS'template <int dim, int degree>'
p28427
aS'void LaplaceProblem<dim, degree>::estimate()'
p28428
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Estimate");'
p28429
aS'  VectorType temp_solution;'
p28430
aS'  temp_solution.reinit(locally_owned_dofs,'
p28431
aS'                       locally_relevant_dofs,'
p28432
aS'                       mpi_communicator);'
p28433
aS'  temp_solution = solution;'
p28434
aS'  const Coefficient<dim> coefficient;'
p28435
aS'  estimated_error_square_per_cell.reinit(triangulation.n_active_cells());'
p28436
aS'  using Iterator = typename DoFHandler<dim>::active_cell_iterator;'
p28437
aS'  auto cell_worker = [&](const Iterator &  cell,'
p28438
aS'                         ScratchData<dim> &scratch_data,'
p28439
aS'                         CopyData &        copy_data) {'
p28440
aS'    FEValues<dim> &fe_values = scratch_data.fe_values;'
p28441
aS'    fe_values.reinit(cell);'
p28442
aS'    RightHandSide<dim> rhs;'
p28443
aS'    const double       rhs_value = rhs.value(cell->center());'
p28444
aS'    const double nu = coefficient.value(cell->center());'
p28445
aS'    std::vector<Tensor<2, dim>> hessians(fe_values.n_quadrature_points);'
p28446
aS'    fe_values.get_function_hessians(temp_solution, hessians);'
p28447
aS'    copy_data.cell_index = cell->active_cell_index();'
p28448
aS'    double residual_norm_square = 0.;'
p28449
aS'    for (unsigned k = 0; k < fe_values.n_quadrature_points; ++k)'
p28450
aS'      {'
p28451
aS'        const double residual = (rhs_value + nu * trace(hessians[k]));'
p28452
aS'        residual_norm_square += residual * residual * fe_values.JxW(k);'
p28453
aS'      }'
p28454
aS'    copy_data.value ='
p28455
aS'      cell->diameter() * cell->diameter() * residual_norm_square;'
p28456
aS'  };'
p28457
aS'  auto face_worker = [&](const Iterator &    cell,'
p28458
aS'                         const unsigned int &f,'
p28459
aS'                         const unsigned int &sf,'
p28460
aS'                         const Iterator &    ncell,'
p28461
aS'                         const unsigned int &nf,'
p28462
aS'                         const unsigned int &nsf,'
p28463
aS'                         ScratchData<dim> &  scratch_data,'
p28464
aS'                         CopyData &          copy_data) {'
p28465
aS'    FEInterfaceValues<dim> &fe_interface_values ='
p28466
aS'      scratch_data.fe_interface_values;'
p28467
aS'    fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf);'
p28468
aS'    copy_data.face_data.emplace_back();'
p28469
aS'    CopyData::FaceData &copy_data_face = copy_data.face_data.back();'
p28470
aS'    copy_data_face.cell_indices[0] = cell->active_cell_index();'
p28471
aS'    copy_data_face.cell_indices[1] = ncell->active_cell_index();'
p28472
aS'    const double coeff1 = coefficient.value(cell->center());'
p28473
aS'    const double coeff2 = coefficient.value(ncell->center());'
p28474
aS'    std::vector<Tensor<1, dim>> grad_u[2];'
p28475
aS'    for (unsigned int i = 0; i < 2; ++i)'
p28476
aS'      {'
p28477
aS'        grad_u[i].resize(fe_interface_values.n_quadrature_points);'
p28478
aS'        fe_interface_values.get_fe_face_values(i).get_function_gradients('
p28479
aS'          temp_solution, grad_u[i]);'
p28480
aS'      }'
p28481
aS'    double jump_norm_square = 0.;'
p28482
aS'    for (unsigned int qpoint = 0;'
p28483
aS'         qpoint < fe_interface_values.n_quadrature_points;'
p28484
aS'         ++qpoint)'
p28485
aS'      {'
p28486
aS'        const double jump ='
p28487
aS'          coeff1 * grad_u[0][qpoint] * fe_interface_values.normal(qpoint) -'
p28488
aS'          coeff2 * grad_u[1][qpoint] * fe_interface_values.normal(qpoint);'
p28489
aS'        jump_norm_square += jump * jump * fe_interface_values.JxW(qpoint);'
p28490
aS'      }'
p28491
aS'    const double h           = cell->face(f)->measure();'
p28492
aS'    copy_data_face.values[0] = 0.5 * h * jump_norm_square;'
p28493
aS'    copy_data_face.values[1] = copy_data_face.values[0];'
p28494
aS'  };'
p28495
aS'  auto copier = [&](const CopyData &copy_data) {'
p28496
aS'    if (copy_data.cell_index != numbers::invalid_unsigned_int)'
p28497
aS'      estimated_error_square_per_cell[copy_data.cell_index] += copy_data.value;'
p28498
aS'    for (auto &cdf : copy_data.face_data)'
p28499
aS'      for (unsigned int j = 0; j < 2; ++j)'
p28500
aS'        estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];'
p28501
aS'  };'
p28502
aS'  const unsigned int n_gauss_points = degree + 1;'
p28503
aS'  ScratchData<dim>   scratch_data(mapping,'
p28504
aS'                                fe,'
p28505
aS'                                n_gauss_points,'
p28506
aS'                                update_hessians | update_quadrature_points |'
p28507
aS'                                  update_JxW_values,'
p28508
aS'                                update_values | update_gradients |'
p28509
aS'                                  update_JxW_values | update_normal_vectors);'
p28510
aS'  CopyData           copy_data;'
p28511
aS'  MeshWorker::mesh_loop(dof_handler.begin_active(),'
p28512
aS'                        dof_handler.end(),'
p28513
aS'                        cell_worker,'
p28514
aS'                        copier,'
p28515
aS'                        scratch_data,'
p28516
aS'                        copy_data,'
p28517
aS'                        MeshWorker::assemble_own_cells |'
p28518
aS'                          MeshWorker::assemble_ghost_faces_both |'
p28519
aS'                          MeshWorker::assemble_own_interior_faces_once,'
p28520
aS'                        face_worker);'
p28521
aS'  const double global_error_estimate ='
p28522
aS'    std::sqrt(Utilities::MPI::sum(estimated_error_square_per_cell.l1_norm(),'
p28523
aS'                                  mpi_communicator));'
p28524
aS'  pcout << "   Global error estimate:        " << global_error_estimate'
p28525
aS'        << std::endl;'
p28526
ag32
aS'template <int dim, int degree>'
p28527
aS'void LaplaceProblem<dim, degree>::refine_grid()'
p28528
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Refine grid");'
p28529
aS'  const double refinement_fraction = 1. / (std::pow(2.0, dim) - 1.);'
p28530
aS'  parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p28531
aS'    triangulation, estimated_error_square_per_cell, refinement_fraction, 0.0);'
p28532
aS'  triangulation.execute_coarsening_and_refinement();'
p28533
ag32
aS'template <int dim, int degree>'
p28534
aS'void LaplaceProblem<dim, degree>::output_results(const unsigned int cycle)'
p28535
ag24
aS'  TimerOutput::Scope timing(computing_timer, "Output results");'
p28536
aS'  VectorType temp_solution;'
p28537
aS'  temp_solution.reinit(locally_owned_dofs,'
p28538
aS'                       locally_relevant_dofs,'
p28539
aS'                       mpi_communicator);'
p28540
aS'  temp_solution = solution;'
p28541
aS'  DataOut<dim> data_out;'
p28542
aS'  data_out.attach_dof_handler(dof_handler);'
p28543
aS'  data_out.add_data_vector(temp_solution, "solution");'
p28544
aS'  Vector<float> subdomain(triangulation.n_active_cells());'
p28545
aS'  for (unsigned int i = 0; i < subdomain.size(); ++i)'
p28546
aS'    subdomain(i) = triangulation.locally_owned_subdomain();'
p28547
aS'  data_out.add_data_vector(subdomain, "subdomain");'
p28548
aS'  Vector<float> level(triangulation.n_active_cells());'
p28549
aS'  for (const auto &cell : triangulation.active_cell_iterators())'
p28550
aS'    level(cell->active_cell_index()) = cell->level();'
p28551
aS'  data_out.add_data_vector(level, "level");'
p28552
aS'  if (estimated_error_square_per_cell.size() > 0)'
p28553
aS'    data_out.add_data_vector(estimated_error_square_per_cell,'
p28554
aS'                             "estimated_error_square_per_cell");'
p28555
aS'  data_out.build_patches();'
p28556
aS'  const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record('
p28557
aS'    "", "solution", cycle, mpi_communicator, 2 /*n_digits*/, 1 /*n_groups*/);'
p28558
aS'  pcout << "   Wrote " << pvtu_filename << std::endl;'
p28559
ag32
aS'template <int dim, int degree>'
p28560
aS'void LaplaceProblem<dim, degree>::run()'
p28561
ag24
aS'  for (unsigned int cycle = 0; cycle < settings.n_steps; ++cycle)'
p28562
aS'    {'
p28563
aS'      pcout << "Cycle " << cycle << \':\' << std::endl;'
p28564
aS'      if (cycle > 0)'
p28565
aS'        refine_grid();'
p28566
aS'      pcout << "   Number of active cells:       "'
p28567
aS'            << triangulation.n_global_active_cells();'
p28568
aS'      if (settings.solver == Settings::gmg_mf ||'
p28569
aS'          settings.solver == Settings::gmg_mb)'
p28570
aS'        pcout << " (" << triangulation.n_global_levels() << " global levels)"'
p28571
aS'              << std::endl'
p28572
aS'              << "   Partition efficiency:         "'
p28573
aS'              << 1.0 / MGTools::workload_imbalance(triangulation);'
p28574
aS'      pcout << std::endl;'
p28575
aS'      setup_system();'
p28576
aS'      if (settings.solver == Settings::gmg_mf ||'
p28577
aS'          settings.solver == Settings::gmg_mb)'
p28578
aS'        setup_multigrid();'
p28579
aS'      pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs();'
p28580
aS'      if (settings.solver == Settings::gmg_mf ||'
p28581
aS'          settings.solver == Settings::gmg_mb)'
p28582
aS'        {'
p28583
aS'          pcout << " (by level: ";'
p28584
aS'          for (unsigned int level = 0; level < triangulation.n_global_levels();'
p28585
aS'               ++level)'
p28586
aS'            pcout << dof_handler.n_dofs(level)'
p28587
aS'                  << (level == triangulation.n_global_levels() - 1 ? ")" :'
p28588
aS'                                                                     ", ");'
p28589
aS'        }'
p28590
aS'      pcout << std::endl;'
p28591
aS'      if (settings.solver == Settings::gmg_mf)'
p28592
aS'        assemble_rhs();'
p28593
aS'      else /*gmg_mb or amg*/'
p28594
aS'        {'
p28595
aS'          assemble_system();'
p28596
aS'          if (settings.solver == Settings::gmg_mb)'
p28597
aS'            assemble_multigrid();'
p28598
aS'        }'
p28599
aS'      solve();'
p28600
aS'      estimate();'
p28601
aS'      if (settings.output)'
p28602
aS'        output_results(cycle);'
p28603
aS'      computing_timer.print_summary();'
p28604
aS'      computing_timer.reset();'
p28605
aS'    }'
p28606
ag32
aS'int main(int argc, char *argv[])'
p28607
ag24
aS'  using namespace dealii;'
p28608
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p28609
aS'  Settings settings;'
p28610
aS'  if (!settings.try_parse((argc > 1) ? (argv[1]) : ""))'
p28611
aS'    return 0;'
p28612
aS'  try'
p28613
aS'    {'
p28614
aS'      constexpr unsigned int fe_degree = 2;'
p28615
aS'      switch (settings.dimension)'
p28616
aS'        {'
p28617
aS'          case 2:'
p28618
aS'            {'
p28619
aS'              LaplaceProblem<2, fe_degree> test(settings);'
p28620
aS'              test.run();'
p28621
aS'              break;'
p28622
aS'            }'
p28623
aS'          case 3:'
p28624
aS'            {'
p28625
aS'              LaplaceProblem<3, fe_degree> test(settings);'
p28626
aS'              test.run();'
p28627
aS'              break;'
p28628
aS'            }'
p28629
aS'          default:'
p28630
aS'            Assert(false, ExcMessage("This program only works in 2d and 3d."));'
p28631
aS'        }'
p28632
aS'    }'
p28633
aS'  catch (std::exception &exc)'
p28634
aS'    {'
p28635
aS'      std::cerr << std::endl'
p28636
aS'                << std::endl'
p28637
aS'                << "----------------------------------------------------"'
p28638
aS'                << std::endl;'
p28639
aS'      std::cerr << "Exception on processing: " << std::endl'
p28640
aS'                << exc.what() << std::endl'
p28641
aS'                << "Aborting!" << std::endl'
p28642
aS'                << "----------------------------------------------------"'
p28643
aS'                << std::endl;'
p28644
aS'      MPI_Abort(MPI_COMM_WORLD, 1);'
p28645
aS'      return 1;'
p28646
aS'    }'
p28647
aS'  catch (...)'
p28648
aS'    {'
p28649
aS'      std::cerr << std::endl'
p28650
aS'                << std::endl'
p28651
aS'                << "----------------------------------------------------"'
p28652
aS'                << std::endl;'
p28653
aS'      std::cerr << "Unknown exception!" << std::endl'
p28654
aS'                << "Aborting!" << std::endl'
p28655
aS'                << "----------------------------------------------------"'
p28656
aS'                << std::endl;'
p28657
aS'      MPI_Abort(MPI_COMM_WORLD, 2);'
p28658
aS'      return 1;'
p28659
aS'    }'
p28660
aS'  return 0;'
p28661
ag32
aS'/* ---------------------------------------------------------------------'
p28662
aS' *'
p28663
aS' * Copyright (C) 2013 - 2021 by the deal.II authors'
p28664
aS' *'
p28665
aS' * This file is part of the deal.II library.'
p28666
aS' *'
p28667
aS' * The deal.II library is free software; you can use it, redistribute'
p28668
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p28669
aS' * Public License as published by the Free Software Foundation; either'
p28670
aS' * version 2.1 of the License, or (at your option) any later version.'
p28671
aS' * The full text of the license can be found in the file LICENSE.md at'
p28672
aS' * the top level directory of deal.II.'
p28673
aS' *'
p28674
aS' * ---------------------------------------------------------------------'
p28675
aS' *'
p28676
aS' * Author: Martin Kronbichler, Technische Universit\xc3\xa4t M\xc3\xbcnchen,'
p28677
aS' *         Scott T. Miller, The Pennsylvania State University, 2013'
p28678
aS' */'
p28679
aS'#include <deal.II/base/quadrature_lib.h>'
p28680
aS'#include <deal.II/base/function.h>'
p28681
aS'#include <deal.II/base/tensor_function.h>'
p28682
aS'#include <deal.II/base/exceptions.h>'
p28683
aS'#include <deal.II/base/logstream.h>'
p28684
aS'#include <deal.II/base/work_stream.h>'
p28685
aS'#include <deal.II/base/convergence_table.h>'
p28686
aS'#include <deal.II/lac/vector.h>'
p28687
aS'#include <deal.II/lac/affine_constraints.h>'
p28688
aS'#include <deal.II/lac/full_matrix.h>'
p28689
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p28690
aS'#include <deal.II/lac/solver_bicgstab.h>'
p28691
aS'#include <deal.II/lac/precondition.h>'
p28692
aS'#include <deal.II/grid/tria.h>'
p28693
aS'#include <deal.II/grid/grid_generator.h>'
p28694
aS'#include <deal.II/grid/grid_refinement.h>'
p28695
aS'#include <deal.II/dofs/dof_handler.h>'
p28696
aS'#include <deal.II/dofs/dof_renumbering.h>'
p28697
aS'#include <deal.II/dofs/dof_tools.h>'
p28698
aS'#include <deal.II/fe/fe_dgq.h>'
p28699
aS'#include <deal.II/fe/fe_system.h>'
p28700
aS'#include <deal.II/fe/fe_values.h>'
p28701
aS'#include <deal.II/numerics/vector_tools.h>'
p28702
aS'#include <deal.II/numerics/error_estimator.h>'
p28703
aS'#include <deal.II/numerics/matrix_tools.h>'
p28704
aS'#include <deal.II/numerics/data_out.h>'
p28705
aS'#include <deal.II/fe/fe_face.h>'
p28706
aS'#include <deal.II/lac/chunk_sparse_matrix.h>'
p28707
aS'#include <deal.II/numerics/data_out_faces.h>'
p28708
aS'#include <iostream>'
p28709
aS'namespace Step51'
p28710
ag24
aS'  using namespace dealii;'
p28711
aS'  template <int dim>'
p28712
aS'  class SolutionBase'
p28713
aS'  {'
p28714
aS'  protected:'
p28715
aS'    static const unsigned int n_source_centers = 3;'
p28716
aS'    static const Point<dim>   source_centers[n_source_centers];'
p28717
aS'    static const double       width;'
p28718
aS'  };'
p28719
aS'  template <>'
p28720
aS'  const Point<1>'
p28721
aS'    SolutionBase<1>::source_centers[SolutionBase<1>::n_source_centers] ='
p28722
aS'      {Point<1>(-1.0 / 3.0), Point<1>(0.0), Point<1>(+1.0 / 3.0)};'
p28723
aS'  template <>'
p28724
aS'  const Point<2>'
p28725
aS'    SolutionBase<2>::source_centers[SolutionBase<2>::n_source_centers] ='
p28726
aS'      {Point<2>(-0.5, +0.5), Point<2>(-0.5, -0.5), Point<2>(+0.5, -0.5)};'
p28727
aS'  template <>'
p28728
aS'  const Point<3>'
p28729
aS'    SolutionBase<3>::source_centers[SolutionBase<3>::n_source_centers] = {'
p28730
aS'      Point<3>(-0.5, +0.5, 0.25),'
p28731
aS'      Point<3>(-0.6, -0.5, -0.125),'
p28732
aS'      Point<3>(+0.5, -0.5, 0.5)};'
p28733
aS'  template <int dim>'
p28734
aS'  const double SolutionBase<dim>::width = 1. / 5.;'
p28735
aS'  template <int dim>'
p28736
aS'  class Solution : public Function<dim>, protected SolutionBase<dim>'
p28737
aS'  {'
p28738
aS'  public:'
p28739
aS'    virtual double value(const Point<dim> &p,'
p28740
aS'                         const unsigned int /*component*/ = 0) const override'
p28741
aS'    {'
p28742
aS'      double sum = 0;'
p28743
aS'      for (unsigned int i = 0; i < this->n_source_centers; ++i)'
p28744
aS'        {'
p28745
aS'          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i];'
p28746
aS'          sum +='
p28747
aS'            std::exp(-x_minus_xi.norm_square() / (this->width * this->width));'
p28748
aS'        }'
p28749
aS'      return sum /'
p28750
aS'             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.);'
p28751
aS'    }'
p28752
aS'    virtual Tensor<1, dim>'
p28753
aS'    gradient(const Point<dim> &p,'
p28754
aS'             const unsigned int /*component*/ = 0) const override'
p28755
aS'    {'
p28756
aS'      Tensor<1, dim> sum;'
p28757
aS'      for (unsigned int i = 0; i < this->n_source_centers; ++i)'
p28758
aS'        {'
p28759
aS'          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i];'
p28760
aS'          sum +='
p28761
aS'            (-2 / (this->width * this->width) *'
p28762
aS'             std::exp(-x_minus_xi.norm_square() / (this->width * this->width)) *'
p28763
aS'             x_minus_xi);'
p28764
aS'        }'
p28765
aS'      return sum /'
p28766
aS'             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.);'
p28767
aS'    }'
p28768
aS'  };'
p28769
aS'  template <int dim>'
p28770
aS'  class SolutionAndGradient : public Function<dim>, protected SolutionBase<dim>'
p28771
aS'  {'
p28772
aS'  public:'
p28773
aS'    SolutionAndGradient()'
p28774
aS'      : Function<dim>(dim + 1)'
p28775
aS'    {}'
p28776
aS'    virtual void vector_value(const Point<dim> &p,'
p28777
aS'                              Vector<double> &  v) const override'
p28778
aS'    {'
p28779
aS'      AssertDimension(v.size(), dim + 1);'
p28780
aS'      Solution<dim>  solution;'
p28781
aS'      Tensor<1, dim> grad = solution.gradient(p);'
p28782
aS'      for (unsigned int d = 0; d < dim; ++d)'
p28783
aS'        v[d] = -grad[d];'
p28784
aS'      v[dim] = solution.value(p);'
p28785
aS'    }'
p28786
aS'  };'
p28787
aS'  template <int dim>'
p28788
aS'  class ConvectionVelocity : public TensorFunction<1, dim>'
p28789
aS'  {'
p28790
aS'  public:'
p28791
aS'    ConvectionVelocity()'
p28792
aS'      : TensorFunction<1, dim>()'
p28793
aS'    {}'
p28794
aS'    virtual Tensor<1, dim> value(const Point<dim> &p) const override'
p28795
aS'    {'
p28796
aS'      Tensor<1, dim> convection;'
p28797
aS'      switch (dim)'
p28798
aS'        {'
p28799
aS'          case 1:'
p28800
aS'            convection[0] = 1;'
p28801
aS'            break;'
p28802
aS'          case 2:'
p28803
aS'            convection[0] = p[1];'
p28804
aS'            convection[1] = -p[0];'
p28805
aS'            break;'
p28806
aS'          case 3:'
p28807
aS'            convection[0] = p[1];'
p28808
aS'            convection[1] = -p[0];'
p28809
aS'            convection[2] = 1;'
p28810
aS'            break;'
p28811
aS'          default:'
p28812
aS'            Assert(false, ExcNotImplemented());'
p28813
aS'        }'
p28814
aS'      return convection;'
p28815
aS'    }'
p28816
aS'  };'
p28817
aS'  template <int dim>'
p28818
aS'  class RightHandSide : public Function<dim>, protected SolutionBase<dim>'
p28819
aS'  {'
p28820
aS'  public:'
p28821
aS'    virtual double value(const Point<dim> &p,'
p28822
aS'                         const unsigned int /*component*/ = 0) const override'
p28823
aS'    {'
p28824
aS'      ConvectionVelocity<dim> convection_velocity;'
p28825
aS'      Tensor<1, dim>          convection = convection_velocity.value(p);'
p28826
aS'      double                  sum        = 0;'
p28827
aS'      for (unsigned int i = 0; i < this->n_source_centers; ++i)'
p28828
aS'        {'
p28829
aS'          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i];'
p28830
aS'          sum +='
p28831
aS'            ((2 * dim - 2 * convection * x_minus_xi -'
p28832
aS'              4 * x_minus_xi.norm_square() / (this->width * this->width)) /'
p28833
aS'             (this->width * this->width) *'
p28834
aS'             std::exp(-x_minus_xi.norm_square() / (this->width * this->width)));'
p28835
aS'        }'
p28836
aS'      return sum /'
p28837
aS'             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.);'
p28838
aS'    }'
p28839
aS'  };'
p28840
aS'  template <int dim>'
p28841
aS'  class HDG'
p28842
aS'  {'
p28843
aS'  public:'
p28844
aS'    enum RefinementMode'
p28845
aS'    {'
p28846
aS'      global_refinement,'
p28847
aS'      adaptive_refinement'
p28848
aS'    };'
p28849
aS'    HDG(const unsigned int degree, const RefinementMode refinement_mode);'
p28850
aS'    void run();'
p28851
aS'  private:'
p28852
aS'    void setup_system();'
p28853
aS'    void assemble_system(const bool reconstruct_trace = false);'
p28854
aS'    void solve();'
p28855
aS'    void postprocess();'
p28856
aS'    void refine_grid(const unsigned int cycle);'
p28857
aS'    void output_results(const unsigned int cycle);'
p28858
aS'    struct PerTaskData;'
p28859
aS'    struct ScratchData;'
p28860
aS'    struct PostProcessScratchData;'
p28861
aS'    void assemble_system_one_cell('
p28862
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p28863
aS'      ScratchData &                                         scratch,'
p28864
aS'      PerTaskData &                                         task_data);'
p28865
aS'    void copy_local_to_global(const PerTaskData &data);'
p28866
aS'    void postprocess_one_cell('
p28867
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p28868
aS'      PostProcessScratchData &                              scratch,'
p28869
aS'      unsigned int &                                        empty_data);'
p28870
aS'    Triangulation<dim> triangulation;'
p28871
aS'    FESystem<dim>   fe_local;'
p28872
aS'    DoFHandler<dim> dof_handler_local;'
p28873
aS'    Vector<double>  solution_local;'
p28874
aS'    FE_FaceQ<dim>   fe;'
p28875
aS'    DoFHandler<dim> dof_handler;'
p28876
aS'    Vector<double>  solution;'
p28877
aS'    Vector<double>  system_rhs;'
p28878
aS'    FE_DGQ<dim>     fe_u_post;'
p28879
aS'    DoFHandler<dim> dof_handler_u_post;'
p28880
aS'    Vector<double>  solution_u_post;'
p28881
aS'    AffineConstraints<double> constraints;'
p28882
aS'    ChunkSparsityPattern      sparsity_pattern;'
p28883
aS'    ChunkSparseMatrix<double> system_matrix;'
p28884
aS'    const RefinementMode refinement_mode;'
p28885
aS'    ConvergenceTable     convergence_table;'
p28886
aS'  };'
p28887
aS'  template <int dim>'
p28888
aS'  HDG<dim>::HDG(const unsigned int degree, const RefinementMode refinement_mode)'
p28889
aS'    : fe_local(FE_DGQ<dim>(degree), dim, FE_DGQ<dim>(degree), 1)'
p28890
aS'    , dof_handler_local(triangulation)'
p28891
aS'    , fe(degree)'
p28892
aS'    , dof_handler(triangulation)'
p28893
aS'    , fe_u_post(degree + 1)'
p28894
aS'    , dof_handler_u_post(triangulation)'
p28895
aS'    , refinement_mode(refinement_mode)'
p28896
aS'  {}'
p28897
aS'  template <int dim>'
p28898
aS'  void HDG<dim>::setup_system()'
p28899
aS'  {'
p28900
aS'    dof_handler_local.distribute_dofs(fe_local);'
p28901
aS'    dof_handler.distribute_dofs(fe);'
p28902
aS'    dof_handler_u_post.distribute_dofs(fe_u_post);'
p28903
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p28904
aS'              << std::endl;'
p28905
aS'    solution.reinit(dof_handler.n_dofs());'
p28906
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p28907
aS'    solution_local.reinit(dof_handler_local.n_dofs());'
p28908
aS'    solution_u_post.reinit(dof_handler_u_post.n_dofs());'
p28909
aS'    constraints.clear();'
p28910
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p28911
aS'    std::map<types::boundary_id, const Function<dim> *> boundary_functions;'
p28912
aS'    Solution<dim>                                       solution_function;'
p28913
aS'    boundary_functions[0] = &solution_function;'
p28914
aS'    VectorTools::project_boundary_values(dof_handler,'
p28915
aS'                                         boundary_functions,'
p28916
aS'                                         QGauss<dim - 1>(fe.degree + 1),'
p28917
aS'                                         constraints);'
p28918
aS'    constraints.close();'
p28919
aS'    {'
p28920
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p28921
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p28922
aS'      sparsity_pattern.copy_from(dsp, fe.n_dofs_per_face());'
p28923
aS'    }'
p28924
aS'    system_matrix.reinit(sparsity_pattern);'
p28925
aS'  }'
p28926
aS'  template <int dim>'
p28927
aS'  struct HDG<dim>::PerTaskData'
p28928
aS'  {'
p28929
aS'    FullMatrix<double>                   cell_matrix;'
p28930
aS'    Vector<double>                       cell_vector;'
p28931
aS'    std::vector<types::global_dof_index> dof_indices;'
p28932
aS'    bool trace_reconstruct;'
p28933
aS'    PerTaskData(const unsigned int n_dofs, const bool trace_reconstruct)'
p28934
aS'      : cell_matrix(n_dofs, n_dofs)'
p28935
aS'      , cell_vector(n_dofs)'
p28936
aS'      , dof_indices(n_dofs)'
p28937
aS'      , trace_reconstruct(trace_reconstruct)'
p28938
aS'    {}'
p28939
aS'  };'
p28940
aS'  template <int dim>'
p28941
aS'  struct HDG<dim>::ScratchData'
p28942
aS'  {'
p28943
aS'    FEValues<dim>     fe_values_local;'
p28944
aS'    FEFaceValues<dim> fe_face_values_local;'
p28945
aS'    FEFaceValues<dim> fe_face_values;'
p28946
aS'    FullMatrix<double> ll_matrix;'
p28947
aS'    FullMatrix<double> lf_matrix;'
p28948
aS'    FullMatrix<double> fl_matrix;'
p28949
aS'    FullMatrix<double> tmp_matrix;'
p28950
aS'    Vector<double>     l_rhs;'
p28951
aS'    Vector<double>     tmp_rhs;'
p28952
aS'    std::vector<Tensor<1, dim>> q_phi;'
p28953
aS'    std::vector<double>         q_phi_div;'
p28954
aS'    std::vector<double>         u_phi;'
p28955
aS'    std::vector<Tensor<1, dim>> u_phi_grad;'
p28956
aS'    std::vector<double>         tr_phi;'
p28957
aS'    std::vector<double>         trace_values;'
p28958
aS'    std::vector<std::vector<unsigned int>> fe_local_support_on_face;'
p28959
aS'    std::vector<std::vector<unsigned int>> fe_support_on_face;'
p28960
aS'    ConvectionVelocity<dim> convection_velocity;'
p28961
aS'    RightHandSide<dim>      right_hand_side;'
p28962
aS'    const Solution<dim>     exact_solution;'
p28963
aS'    ScratchData(const FiniteElement<dim> &fe,'
p28964
aS'                const FiniteElement<dim> &fe_local,'
p28965
aS'                const QGauss<dim> &       quadrature_formula,'
p28966
aS'                const QGauss<dim - 1> &   face_quadrature_formula,'
p28967
aS'                const UpdateFlags         local_flags,'
p28968
aS'                const UpdateFlags         local_face_flags,'
p28969
aS'                const UpdateFlags         flags)'
p28970
aS'      : fe_values_local(fe_local, quadrature_formula, local_flags)'
p28971
aS'      , fe_face_values_local(fe_local,'
p28972
aS'                             face_quadrature_formula,'
p28973
aS'                             local_face_flags)'
p28974
aS'      , fe_face_values(fe, face_quadrature_formula, flags)'
p28975
aS'      , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())'
p28976
aS'      , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())'
p28977
aS'      , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())'
p28978
aS'      , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())'
p28979
aS'      , l_rhs(fe_local.n_dofs_per_cell())'
p28980
aS'      , tmp_rhs(fe_local.n_dofs_per_cell())'
p28981
aS'      , q_phi(fe_local.n_dofs_per_cell())'
p28982
aS'      , q_phi_div(fe_local.n_dofs_per_cell())'
p28983
aS'      , u_phi(fe_local.n_dofs_per_cell())'
p28984
aS'      , u_phi_grad(fe_local.n_dofs_per_cell())'
p28985
aS'      , tr_phi(fe.n_dofs_per_cell())'
p28986
aS'      , trace_values(face_quadrature_formula.size())'
p28987
aS'      , fe_local_support_on_face(GeometryInfo<dim>::faces_per_cell)'
p28988
aS'      , fe_support_on_face(GeometryInfo<dim>::faces_per_cell)'
p28989
aS'      , exact_solution()'
p28990
aS'    {'
p28991
aS'      for (unsigned int face_no : GeometryInfo<dim>::face_indices())'
p28992
aS'        for (unsigned int i = 0; i < fe_local.n_dofs_per_cell(); ++i)'
p28993
aS'          {'
p28994
aS'            if (fe_local.has_support_on_face(i, face_no))'
p28995
aS'              fe_local_support_on_face[face_no].push_back(i);'
p28996
aS'          }'
p28997
aS'      for (unsigned int face_no : GeometryInfo<dim>::face_indices())'
p28998
aS'        for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p28999
aS'          {'
p29000
aS'            if (fe.has_support_on_face(i, face_no))'
p29001
aS'              fe_support_on_face[face_no].push_back(i);'
p29002
aS'          }'
p29003
aS'    }'
p29004
aS'    ScratchData(const ScratchData &sd)'
p29005
aS'      : fe_values_local(sd.fe_values_local.get_fe(),'
p29006
aS'                        sd.fe_values_local.get_quadrature(),'
p29007
aS'                        sd.fe_values_local.get_update_flags())'
p29008
aS'      , fe_face_values_local(sd.fe_face_values_local.get_fe(),'
p29009
aS'                             sd.fe_face_values_local.get_quadrature(),'
p29010
aS'                             sd.fe_face_values_local.get_update_flags())'
p29011
aS'      , fe_face_values(sd.fe_face_values.get_fe(),'
p29012
aS'                       sd.fe_face_values.get_quadrature(),'
p29013
aS'                       sd.fe_face_values.get_update_flags())'
p29014
aS'      , ll_matrix(sd.ll_matrix)'
p29015
aS'      , lf_matrix(sd.lf_matrix)'
p29016
aS'      , fl_matrix(sd.fl_matrix)'
p29017
aS'      , tmp_matrix(sd.tmp_matrix)'
p29018
aS'      , l_rhs(sd.l_rhs)'
p29019
aS'      , tmp_rhs(sd.tmp_rhs)'
p29020
aS'      , q_phi(sd.q_phi)'
p29021
aS'      , q_phi_div(sd.q_phi_div)'
p29022
aS'      , u_phi(sd.u_phi)'
p29023
aS'      , u_phi_grad(sd.u_phi_grad)'
p29024
aS'      , tr_phi(sd.tr_phi)'
p29025
aS'      , trace_values(sd.trace_values)'
p29026
aS'      , fe_local_support_on_face(sd.fe_local_support_on_face)'
p29027
aS'      , fe_support_on_face(sd.fe_support_on_face)'
p29028
aS'      , exact_solution()'
p29029
aS'    {}'
p29030
aS'  };'
p29031
aS'  template <int dim>'
p29032
aS'  struct HDG<dim>::PostProcessScratchData'
p29033
aS'  {'
p29034
aS'    FEValues<dim> fe_values_local;'
p29035
aS'    FEValues<dim> fe_values;'
p29036
aS'    std::vector<double>         u_values;'
p29037
aS'    std::vector<Tensor<1, dim>> u_gradients;'
p29038
aS'    FullMatrix<double>          cell_matrix;'
p29039
aS'    Vector<double> cell_rhs;'
p29040
aS'    Vector<double> cell_sol;'
p29041
aS'    PostProcessScratchData(const FiniteElement<dim> &fe,'
p29042
aS'                           const FiniteElement<dim> &fe_local,'
p29043
aS'                           const QGauss<dim> &       quadrature_formula,'
p29044
aS'                           const UpdateFlags         local_flags,'
p29045
aS'                           const UpdateFlags         flags)'
p29046
aS'      : fe_values_local(fe_local, quadrature_formula, local_flags)'
p29047
aS'      , fe_values(fe, quadrature_formula, flags)'
p29048
aS'      , u_values(quadrature_formula.size())'
p29049
aS'      , u_gradients(quadrature_formula.size())'
p29050
aS'      , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())'
p29051
aS'      , cell_rhs(fe.n_dofs_per_cell())'
p29052
aS'      , cell_sol(fe.n_dofs_per_cell())'
p29053
aS'    {}'
p29054
aS'    PostProcessScratchData(const PostProcessScratchData &sd)'
p29055
aS'      : fe_values_local(sd.fe_values_local.get_fe(),'
p29056
aS'                        sd.fe_values_local.get_quadrature(),'
p29057
aS'                        sd.fe_values_local.get_update_flags())'
p29058
aS'      , fe_values(sd.fe_values.get_fe(),'
p29059
aS'                  sd.fe_values.get_quadrature(),'
p29060
aS'                  sd.fe_values.get_update_flags())'
p29061
aS'      , u_values(sd.u_values)'
p29062
aS'      , u_gradients(sd.u_gradients)'
p29063
aS'      , cell_matrix(sd.cell_matrix)'
p29064
aS'      , cell_rhs(sd.cell_rhs)'
p29065
aS'      , cell_sol(sd.cell_sol)'
p29066
aS'    {}'
p29067
aS'  };'
p29068
aS'  template <int dim>'
p29069
aS'  void HDG<dim>::assemble_system(const bool trace_reconstruct)'
p29070
aS'  {'
p29071
aS'    const QGauss<dim>     quadrature_formula(fe.degree + 1);'
p29072
aS'    const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p29073
aS'    const UpdateFlags local_flags(update_values | update_gradients |'
p29074
aS'                                  update_JxW_values | update_quadrature_points);'
p29075
aS'    const UpdateFlags local_face_flags(update_values);'
p29076
aS'    const UpdateFlags flags(update_values | update_normal_vectors |'
p29077
aS'                            update_quadrature_points | update_JxW_values);'
p29078
aS'    PerTaskData task_data(fe.n_dofs_per_cell(), trace_reconstruct);'
p29079
aS'    ScratchData scratch(fe,'
p29080
aS'                        fe_local,'
p29081
aS'                        quadrature_formula,'
p29082
aS'                        face_quadrature_formula,'
p29083
aS'                        local_flags,'
p29084
aS'                        local_face_flags,'
p29085
aS'                        flags);'
p29086
aS'    WorkStream::run(dof_handler.begin_active(),'
p29087
aS'                    dof_handler.end(),'
p29088
aS'                    *this,'
p29089
aS'                    &HDG<dim>::assemble_system_one_cell,'
p29090
aS'                    &HDG<dim>::copy_local_to_global,'
p29091
aS'                    scratch,'
p29092
aS'                    task_data);'
p29093
aS'  }'
p29094
aS'  template <int dim>'
p29095
aS'  void HDG<dim>::assemble_system_one_cell('
p29096
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p29097
aS'    ScratchData &                                         scratch,'
p29098
aS'    PerTaskData &                                         task_data)'
p29099
aS'  {'
p29100
aS'    typename DoFHandler<dim>::active_cell_iterator loc_cell(&triangulation,'
p29101
aS'                                                            cell->level(),'
p29102
aS'                                                            cell->index(),'
p29103
aS'                                                            &dof_handler_local);'
p29104
aS'    const unsigned int n_q_points ='
p29105
aS'      scratch.fe_values_local.get_quadrature().size();'
p29106
aS'    const unsigned int n_face_q_points ='
p29107
aS'      scratch.fe_face_values_local.get_quadrature().size();'
p29108
aS'    const unsigned int loc_dofs_per_cell ='
p29109
aS'      scratch.fe_values_local.get_fe().n_dofs_per_cell();'
p29110
aS'    const FEValuesExtractors::Vector fluxes(0);'
p29111
aS'    const FEValuesExtractors::Scalar scalar(dim);'
p29112
aS'    scratch.ll_matrix = 0;'
p29113
aS'    scratch.l_rhs     = 0;'
p29114
aS'    if (!task_data.trace_reconstruct)'
p29115
aS'      {'
p29116
aS'        scratch.lf_matrix     = 0;'
p29117
aS'        scratch.fl_matrix     = 0;'
p29118
aS'        task_data.cell_matrix = 0;'
p29119
aS'        task_data.cell_vector = 0;'
p29120
aS'      }'
p29121
aS'    scratch.fe_values_local.reinit(loc_cell);'
p29122
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p29123
aS'      {'
p29124
aS'        const double rhs_value = scratch.right_hand_side.value('
p29125
aS'          scratch.fe_values_local.quadrature_point(q));'
p29126
aS'        const Tensor<1, dim> convection = scratch.convection_velocity.value('
p29127
aS'          scratch.fe_values_local.quadrature_point(q));'
p29128
aS'        const double JxW = scratch.fe_values_local.JxW(q);'
p29129
aS'        for (unsigned int k = 0; k < loc_dofs_per_cell; ++k)'
p29130
aS'          {'
p29131
aS'            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);'
p29132
aS'            scratch.q_phi_div[k] ='
p29133
aS'              scratch.fe_values_local[fluxes].divergence(k, q);'
p29134
aS'            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);'
p29135
aS'            scratch.u_phi_grad[k] ='
p29136
aS'              scratch.fe_values_local[scalar].gradient(k, q);'
p29137
aS'          }'
p29138
aS'        for (unsigned int i = 0; i < loc_dofs_per_cell; ++i)'
p29139
aS'          {'
p29140
aS'            for (unsigned int j = 0; j < loc_dofs_per_cell; ++j)'
p29141
aS'              scratch.ll_matrix(i, j) +='
p29142
aS'                (scratch.q_phi[i] * scratch.q_phi[j] -'
p29143
aS'                 scratch.q_phi_div[i] * scratch.u_phi[j] +'
p29144
aS'                 scratch.u_phi[i] * scratch.q_phi_div[j] -'
p29145
aS'                 (scratch.u_phi_grad[i] * convection) * scratch.u_phi[j]) *'
p29146
aS'                JxW;'
p29147
aS'            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;'
p29148
aS'          }'
p29149
aS'      }'
p29150
aS'    for (const auto face_no : cell->face_indices())'
p29151
aS'      {'
p29152
aS'        scratch.fe_face_values_local.reinit(loc_cell, face_no);'
p29153
aS'        scratch.fe_face_values.reinit(cell, face_no);'
p29154
aS'        if (task_data.trace_reconstruct)'
p29155
aS'          scratch.fe_face_values.get_function_values(solution,'
p29156
aS'                                                     scratch.trace_values);'
p29157
aS'        for (unsigned int q = 0; q < n_face_q_points; ++q)'
p29158
aS'          {'
p29159
aS'            const double     JxW = scratch.fe_face_values.JxW(q);'
p29160
aS'            const Point<dim> quadrature_point ='
p29161
aS'              scratch.fe_face_values.quadrature_point(q);'
p29162
aS'            const Tensor<1, dim> normal ='
p29163
aS'              scratch.fe_face_values.normal_vector(q);'
p29164
aS'            const Tensor<1, dim> convection ='
p29165
aS'              scratch.convection_velocity.value(quadrature_point);'
p29166
aS'            const double tau_stab = (5. + std::abs(convection * normal));'
p29167
aS'            for (unsigned int k = 0;'
p29168
aS'                 k < scratch.fe_local_support_on_face[face_no].size();'
p29169
aS'                 ++k)'
p29170
aS'              {'
p29171
aS'                const unsigned int kk ='
p29172
aS'                  scratch.fe_local_support_on_face[face_no][k];'
p29173
aS'                scratch.q_phi[k] ='
p29174
aS'                  scratch.fe_face_values_local[fluxes].value(kk, q);'
p29175
aS'                scratch.u_phi[k] ='
p29176
aS'                  scratch.fe_face_values_local[scalar].value(kk, q);'
p29177
aS'              }'
p29178
aS'            if (!task_data.trace_reconstruct)'
p29179
aS'              {'
p29180
aS'                for (unsigned int k = 0;'
p29181
aS'                     k < scratch.fe_support_on_face[face_no].size();'
p29182
aS'                     ++k)'
p29183
aS'                  scratch.tr_phi[k] = scratch.fe_face_values.shape_value('
p29184
aS'                    scratch.fe_support_on_face[face_no][k], q);'
p29185
aS'                for (unsigned int i = 0;'
p29186
aS'                     i < scratch.fe_local_support_on_face[face_no].size();'
p29187
aS'                     ++i)'
p29188
aS'                  for (unsigned int j = 0;'
p29189
aS'                       j < scratch.fe_support_on_face[face_no].size();'
p29190
aS'                       ++j)'
p29191
aS'                    {'
p29192
aS'                      const unsigned int ii ='
p29193
aS'                        scratch.fe_local_support_on_face[face_no][i];'
p29194
aS'                      const unsigned int jj ='
p29195
aS'                        scratch.fe_support_on_face[face_no][j];'
p29196
aS'                      scratch.lf_matrix(ii, jj) +='
p29197
aS'                        ((scratch.q_phi[i] * normal +'
p29198
aS'                          (convection * normal - tau_stab) * scratch.u_phi[i]) *'
p29199
aS'                         scratch.tr_phi[j]) *'
p29200
aS'                        JxW;'
p29201
aS'                      scratch.fl_matrix(jj, ii) -='
p29202
aS'                        ((scratch.q_phi[i] * normal +'
p29203
aS'                          tau_stab * scratch.u_phi[i]) *'
p29204
aS'                         scratch.tr_phi[j]) *'
p29205
aS'                        JxW;'
p29206
aS'                    }'
p29207
aS'                for (unsigned int i = 0;'
p29208
aS'                     i < scratch.fe_support_on_face[face_no].size();'
p29209
aS'                     ++i)'
p29210
aS'                  for (unsigned int j = 0;'
p29211
aS'                       j < scratch.fe_support_on_face[face_no].size();'
p29212
aS'                       ++j)'
p29213
aS'                    {'
p29214
aS'                      const unsigned int ii ='
p29215
aS'                        scratch.fe_support_on_face[face_no][i];'
p29216
aS'                      const unsigned int jj ='
p29217
aS'                        scratch.fe_support_on_face[face_no][j];'
p29218
aS'                      task_data.cell_matrix(ii, jj) +='
p29219
aS'                        ((convection * normal - tau_stab) * scratch.tr_phi[i] *'
p29220
aS'                         scratch.tr_phi[j]) *'
p29221
aS'                        JxW;'
p29222
aS'                    }'
p29223
aS'                if (cell->face(face_no)->at_boundary() &&'
p29224
aS'                    (cell->face(face_no)->boundary_id() == 1))'
p29225
aS'                  {'
p29226
aS'                    const double neumann_value ='
p29227
aS'                      -scratch.exact_solution.gradient(quadrature_point) *'
p29228
aS'                        normal +'
p29229
aS'                      convection * normal *'
p29230
aS'                        scratch.exact_solution.value(quadrature_point);'
p29231
aS'                    for (unsigned int i = 0;'
p29232
aS'                         i < scratch.fe_support_on_face[face_no].size();'
p29233
aS'                         ++i)'
p29234
aS'                      {'
p29235
aS'                        const unsigned int ii ='
p29236
aS'                          scratch.fe_support_on_face[face_no][i];'
p29237
aS'                        task_data.cell_vector(ii) +='
p29238
aS'                          scratch.tr_phi[i] * neumann_value * JxW;'
p29239
aS'                      }'
p29240
aS'                  }'
p29241
aS'              }'
p29242
aS'            for (unsigned int i = 0;'
p29243
aS'                 i < scratch.fe_local_support_on_face[face_no].size();'
p29244
aS'                 ++i)'
p29245
aS'              for (unsigned int j = 0;'
p29246
aS'                   j < scratch.fe_local_support_on_face[face_no].size();'
p29247
aS'                   ++j)'
p29248
aS'                {'
p29249
aS'                  const unsigned int ii ='
p29250
aS'                    scratch.fe_local_support_on_face[face_no][i];'
p29251
aS'                  const unsigned int jj ='
p29252
aS'                    scratch.fe_local_support_on_face[face_no][j];'
p29253
aS'                  scratch.ll_matrix(ii, jj) +='
p29254
aS'                    tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;'
p29255
aS'                }'
p29256
aS'            if (task_data.trace_reconstruct)'
p29257
aS'              for (unsigned int i = 0;'
p29258
aS'                   i < scratch.fe_local_support_on_face[face_no].size();'
p29259
aS'                   ++i)'
p29260
aS'                {'
p29261
aS'                  const unsigned int ii ='
p29262
aS'                    scratch.fe_local_support_on_face[face_no][i];'
p29263
aS'                  scratch.l_rhs(ii) -='
p29264
aS'                    (scratch.q_phi[i] * normal +'
p29265
aS'                     scratch.u_phi[i] * (convection * normal - tau_stab)) *'
p29266
aS'                    scratch.trace_values[q] * JxW;'
p29267
aS'                }'
p29268
aS'          }'
p29269
aS'      }'
p29270
aS'    scratch.ll_matrix.gauss_jordan();'
p29271
aS'    if (task_data.trace_reconstruct == false)'
p29272
aS'      {'
p29273
aS'        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);'
p29274
aS'        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);'
p29275
aS'        scratch.tmp_matrix.mmult(task_data.cell_matrix,'
p29276
aS'                                 scratch.lf_matrix,'
p29277
aS'                                 true);'
p29278
aS'        cell->get_dof_indices(task_data.dof_indices);'
p29279
aS'      }'
p29280
aS'    else'
p29281
aS'      {'
p29282
aS'        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);'
p29283
aS'        loc_cell->set_dof_values(scratch.tmp_rhs, solution_local);'
p29284
aS'      }'
p29285
aS'  }'
p29286
aS'  template <int dim>'
p29287
aS'  void HDG<dim>::copy_local_to_global(const PerTaskData &data)'
p29288
aS'  {'
p29289
aS'    if (data.trace_reconstruct == false)'
p29290
aS'      constraints.distribute_local_to_global(data.cell_matrix,'
p29291
aS'                                             data.cell_vector,'
p29292
aS'                                             data.dof_indices,'
p29293
aS'                                             system_matrix,'
p29294
aS'                                             system_rhs);'
p29295
aS'  }'
p29296
aS'  template <int dim>'
p29297
aS'  void HDG<dim>::solve()'
p29298
aS'  {'
p29299
aS'    SolverControl                  solver_control(system_matrix.m() * 10,'
p29300
aS'                                 1e-11 * system_rhs.l2_norm());'
p29301
aS'    SolverBicgstab<Vector<double>> solver(solver_control);'
p29302
aS'    solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p29303
aS'    std::cout << "   Number of BiCGStab iterations: "'
p29304
aS'              << solver_control.last_step() << std::endl;'
p29305
aS'    system_matrix.clear();'
p29306
aS'    sparsity_pattern.reinit(0, 0, 0, 1);'
p29307
aS'    constraints.distribute(solution);'
p29308
aS'    assemble_system(true);'
p29309
aS'  }'
p29310
aS'  template <int dim>'
p29311
aS'  void HDG<dim>::postprocess()'
p29312
aS'  {'
p29313
aS'    {'
p29314
aS'      const QGauss<dim> quadrature_formula(fe_u_post.degree + 1);'
p29315
aS'      const UpdateFlags local_flags(update_values);'
p29316
aS'      const UpdateFlags flags(update_values | update_gradients |'
p29317
aS'                              update_JxW_values);'
p29318
aS'      PostProcessScratchData scratch('
p29319
aS'        fe_u_post, fe_local, quadrature_formula, local_flags, flags);'
p29320
aS'      WorkStream::run('
p29321
aS'        dof_handler_u_post.begin_active(),'
p29322
aS'        dof_handler_u_post.end(),'
p29323
aS'        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p29324
aS'               PostProcessScratchData &                              scratch,'
p29325
aS'               unsigned int &                                        data) {'
p29326
aS'          this->postprocess_one_cell(cell, scratch, data);'
p29327
aS'        },'
p29328
aS'        std::function<void(const unsigned int &)>(),'
p29329
aS'        scratch,'
p29330
aS'        0U);'
p29331
aS'    }'
p29332
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p29333
aS'    ComponentSelectFunction<dim> value_select(dim, dim + 1);'
p29334
aS'    VectorTools::integrate_difference(dof_handler_local,'
p29335
aS'                                      solution_local,'
p29336
aS'                                      SolutionAndGradient<dim>(),'
p29337
aS'                                      difference_per_cell,'
p29338
aS'                                      QGauss<dim>(fe.degree + 2),'
p29339
aS'                                      VectorTools::L2_norm,'
p29340
aS'                                      &value_select);'
p29341
aS'    const double L2_error ='
p29342
aS'      VectorTools::compute_global_error(triangulation,'
p29343
aS'                                        difference_per_cell,'
p29344
aS'                                        VectorTools::L2_norm);'
p29345
aS'    ComponentSelectFunction<dim> gradient_select('
p29346
aS'      std::pair<unsigned int, unsigned int>(0, dim), dim + 1);'
p29347
aS'    VectorTools::integrate_difference(dof_handler_local,'
p29348
aS'                                      solution_local,'
p29349
aS'                                      SolutionAndGradient<dim>(),'
p29350
aS'                                      difference_per_cell,'
p29351
aS'                                      QGauss<dim>(fe.degree + 2),'
p29352
aS'                                      VectorTools::L2_norm,'
p29353
aS'                                      &gradient_select);'
p29354
aS'    const double grad_error ='
p29355
aS'      VectorTools::compute_global_error(triangulation,'
p29356
aS'                                        difference_per_cell,'
p29357
aS'                                        VectorTools::L2_norm);'
p29358
aS'    VectorTools::integrate_difference(dof_handler_u_post,'
p29359
aS'                                      solution_u_post,'
p29360
aS'                                      Solution<dim>(),'
p29361
aS'                                      difference_per_cell,'
p29362
aS'                                      QGauss<dim>(fe.degree + 3),'
p29363
aS'                                      VectorTools::L2_norm);'
p29364
aS'    const double post_error ='
p29365
aS'      VectorTools::compute_global_error(triangulation,'
p29366
aS'                                        difference_per_cell,'
p29367
aS'                                        VectorTools::L2_norm);'
p29368
aS'    convergence_table.add_value("cells", triangulation.n_active_cells());'
p29369
aS'    convergence_table.add_value("dofs", dof_handler.n_dofs());'
p29370
aS'    convergence_table.add_value("val L2", L2_error);'
p29371
aS'    convergence_table.set_scientific("val L2", true);'
p29372
aS'    convergence_table.set_precision("val L2", 3);'
p29373
aS'    convergence_table.add_value("grad L2", grad_error);'
p29374
aS'    convergence_table.set_scientific("grad L2", true);'
p29375
aS'    convergence_table.set_precision("grad L2", 3);'
p29376
aS'    convergence_table.add_value("val L2-post", post_error);'
p29377
aS'    convergence_table.set_scientific("val L2-post", true);'
p29378
aS'    convergence_table.set_precision("val L2-post", 3);'
p29379
aS'  }'
p29380
aS'  template <int dim>'
p29381
aS'  void HDG<dim>::postprocess_one_cell('
p29382
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p29383
aS'    PostProcessScratchData &                              scratch,'
p29384
aS'    unsigned int &)'
p29385
aS'  {'
p29386
aS'    typename DoFHandler<dim>::active_cell_iterator loc_cell(&triangulation,'
p29387
aS'                                                            cell->level(),'
p29388
aS'                                                            cell->index(),'
p29389
aS'                                                            &dof_handler_local);'
p29390
aS'    scratch.fe_values_local.reinit(loc_cell);'
p29391
aS'    scratch.fe_values.reinit(cell);'
p29392
aS'    FEValuesExtractors::Vector fluxes(0);'
p29393
aS'    FEValuesExtractors::Scalar scalar(dim);'
p29394
aS'    const unsigned int n_q_points = scratch.fe_values.get_quadrature().size();'
p29395
aS'    const unsigned int dofs_per_cell = scratch.fe_values.dofs_per_cell;'
p29396
aS'    scratch.fe_values_local[scalar].get_function_values(solution_local,'
p29397
aS'                                                        scratch.u_values);'
p29398
aS'    scratch.fe_values_local[fluxes].get_function_values(solution_local,'
p29399
aS'                                                        scratch.u_gradients);'
p29400
aS'    double sum = 0;'
p29401
aS'    for (unsigned int i = 1; i < dofs_per_cell; ++i)'
p29402
aS'      {'
p29403
aS'        for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p29404
aS'          {'
p29405
aS'            sum = 0;'
p29406
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p29407
aS'              sum += (scratch.fe_values.shape_grad(i, q) *'
p29408
aS'                      scratch.fe_values.shape_grad(j, q)) *'
p29409
aS'                     scratch.fe_values.JxW(q);'
p29410
aS'            scratch.cell_matrix(i, j) = sum;'
p29411
aS'          }'
p29412
aS'        sum = 0;'
p29413
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p29414
aS'          sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *'
p29415
aS'                 scratch.fe_values.JxW(q);'
p29416
aS'        scratch.cell_rhs(i) = sum;'
p29417
aS'      }'
p29418
aS'    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p29419
aS'      {'
p29420
aS'        sum = 0;'
p29421
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p29422
aS'          sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);'
p29423
aS'        scratch.cell_matrix(0, j) = sum;'
p29424
aS'      }'
p29425
aS'    {'
p29426
aS'      sum = 0;'
p29427
aS'      for (unsigned int q = 0; q < n_q_points; ++q)'
p29428
aS'        sum += scratch.u_values[q] * scratch.fe_values.JxW(q);'
p29429
aS'      scratch.cell_rhs(0) = sum;'
p29430
aS'    }'
p29431
aS'    scratch.cell_matrix.gauss_jordan();'
p29432
aS'    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);'
p29433
aS'    cell->distribute_local_to_global(scratch.cell_sol, solution_u_post);'
p29434
aS'  }'
p29435
aS'  template <int dim>'
p29436
aS'  void HDG<dim>::output_results(const unsigned int cycle)'
p29437
aS'  {'
p29438
aS'    std::string filename;'
p29439
aS'    switch (refinement_mode)'
p29440
aS'      {'
p29441
aS'        case global_refinement:'
p29442
aS'          filename = "solution-global";'
p29443
aS'          break;'
p29444
aS'        case adaptive_refinement:'
p29445
aS'          filename = "solution-adaptive";'
p29446
aS'          break;'
p29447
aS'        default:'
p29448
aS'          Assert(false, ExcNotImplemented());'
p29449
aS'      }'
p29450
aS'    std::string face_out(filename);'
p29451
aS'    face_out += "-face";'
p29452
aS'    filename += "-q" + Utilities::int_to_string(fe.degree, 1);'
p29453
aS'    filename += "-" + Utilities::int_to_string(cycle, 2);'
p29454
aS'    filename += ".vtk";'
p29455
aS'    std::ofstream output(filename);'
p29456
aS'    DataOut<dim> data_out;'
p29457
aS'    std::vector<std::string> names(dim, "gradient");'
p29458
aS'    names.emplace_back("solution");'
p29459
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p29460
aS'      component_interpretation('
p29461
aS'        dim + 1, DataComponentInterpretation::component_is_part_of_vector);'
p29462
aS'    component_interpretation[dim] ='
p29463
aS'      DataComponentInterpretation::component_is_scalar;'
p29464
aS'    data_out.add_data_vector(dof_handler_local,'
p29465
aS'                             solution_local,'
p29466
aS'                             names,'
p29467
aS'                             component_interpretation);'
p29468
aS'    std::vector<std::string> post_name(1, "u_post");'
p29469
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p29470
aS'      post_comp_type(1, DataComponentInterpretation::component_is_scalar);'
p29471
aS'    data_out.add_data_vector(dof_handler_u_post,'
p29472
aS'                             solution_u_post,'
p29473
aS'                             post_name,'
p29474
aS'                             post_comp_type);'
p29475
aS'    data_out.build_patches(fe.degree);'
p29476
aS'    data_out.write_vtk(output);'
p29477
aS'    face_out += "-q" + Utilities::int_to_string(fe.degree, 1);'
p29478
aS'    face_out += "-" + Utilities::int_to_string(cycle, 2);'
p29479
aS'    face_out += ".vtk";'
p29480
aS'    std::ofstream face_output(face_out);'
p29481
aS'    DataOutFaces<dim>        data_out_face(false);'
p29482
aS'    std::vector<std::string> face_name(1, "u_hat");'
p29483
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p29484
aS'      face_component_type(1, DataComponentInterpretation::component_is_scalar);'
p29485
aS'    data_out_face.add_data_vector(dof_handler,'
p29486
aS'                                  solution,'
p29487
aS'                                  face_name,'
p29488
aS'                                  face_component_type);'
p29489
aS'    data_out_face.build_patches(fe.degree);'
p29490
aS'    data_out_face.write_vtk(face_output);'
p29491
aS'  }'
p29492
aS'  template <int dim>'
p29493
aS'  void HDG<dim>::refine_grid(const unsigned int cycle)'
p29494
aS'  {'
p29495
aS'    if (cycle == 0)'
p29496
aS'      {'
p29497
aS'        GridGenerator::subdivided_hyper_cube(triangulation, 2, -1, 1);'
p29498
aS'        triangulation.refine_global(3 - dim);'
p29499
aS'      }'
p29500
aS'    else'
p29501
aS'      switch (refinement_mode)'
p29502
aS'        {'
p29503
aS'          case global_refinement:'
p29504
aS'            {'
p29505
aS'              triangulation.clear();'
p29506
aS'              GridGenerator::subdivided_hyper_cube(triangulation,'
p29507
aS'                                                   2 + (cycle % 2),'
p29508
aS'                                                   -1,'
p29509
aS'                                                   1);'
p29510
aS'              triangulation.refine_global(3 - dim + cycle / 2);'
p29511
aS'              break;'
p29512
aS'            }'
p29513
aS'          case adaptive_refinement:'
p29514
aS'            {'
p29515
aS'              Vector<float> estimated_error_per_cell('
p29516
aS'                triangulation.n_active_cells());'
p29517
aS'              FEValuesExtractors::Scalar scalar(dim);'
p29518
aS'              std::map<types::boundary_id, const Function<dim> *>'
p29519
aS'                neumann_boundary;'
p29520
aS'              KellyErrorEstimator<dim>::estimate(dof_handler_local,'
p29521
aS'                                                 QGauss<dim - 1>(fe.degree + 1),'
p29522
aS'                                                 neumann_boundary,'
p29523
aS'                                                 solution_local,'
p29524
aS'                                                 estimated_error_per_cell,'
p29525
aS'                                                 fe_local.component_mask('
p29526
aS'                                                   scalar));'
p29527
aS'              GridRefinement::refine_and_coarsen_fixed_number('
p29528
aS'                triangulation, estimated_error_per_cell, 0.3, 0.);'
p29529
aS'              triangulation.execute_coarsening_and_refinement();'
p29530
aS'              break;'
p29531
aS'            }'
p29532
aS'          default:'
p29533
aS'            {'
p29534
aS'              Assert(false, ExcNotImplemented());'
p29535
aS'            }'
p29536
aS'        }'
p29537
aS'    for (const auto &cell : triangulation.cell_iterators())'
p29538
aS'      for (const auto &face : cell->face_iterators())'
p29539
aS'        if (face->at_boundary())'
p29540
aS'          if ((std::fabs(face->center()(0) - (-1)) < 1e-12) ||'
p29541
aS'              (std::fabs(face->center()(1) - (-1)) < 1e-12))'
p29542
aS'            face->set_boundary_id(1);'
p29543
aS'  }'
p29544
aS'  template <int dim>'
p29545
aS'  void HDG<dim>::run()'
p29546
aS'  {'
p29547
aS'    for (unsigned int cycle = 0; cycle < 10; ++cycle)'
p29548
aS'      {'
p29549
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p29550
aS'        refine_grid(cycle);'
p29551
aS'        setup_system();'
p29552
aS'        assemble_system(false);'
p29553
aS'        solve();'
p29554
aS'        postprocess();'
p29555
aS'        output_results(cycle);'
p29556
aS'      }'
p29557
aS'    if (refinement_mode == global_refinement)'
p29558
aS'      {'
p29559
aS'        convergence_table.evaluate_convergence_rates('
p29560
aS'          "val L2", "cells", ConvergenceTable::reduction_rate_log2, dim);'
p29561
aS'        convergence_table.evaluate_convergence_rates('
p29562
aS'          "grad L2", "cells", ConvergenceTable::reduction_rate_log2, dim);'
p29563
aS'        convergence_table.evaluate_convergence_rates('
p29564
aS'          "val L2-post", "cells", ConvergenceTable::reduction_rate_log2, dim);'
p29565
aS'      }'
p29566
aS'    convergence_table.write_text(std::cout);'
p29567
aS'  }'
p29568
aS'} // end of namespace Step51'
p29569
aS'int main()'
p29570
ag24
aS'  const unsigned int dim = 2;'
p29571
aS'  try'
p29572
aS'    {'
p29573
aS'      {'
p29574
aS'        std::cout << "Solving with Q1 elements, adaptive refinement"'
p29575
aS'                  << std::endl'
p29576
aS'                  << "============================================="'
p29577
aS'                  << std::endl'
p29578
aS'                  << std::endl;'
p29579
aS'        Step51::HDG<dim> hdg_problem(1, Step51::HDG<dim>::adaptive_refinement);'
p29580
aS'        hdg_problem.run();'
p29581
aS'        std::cout << std::endl;'
p29582
aS'      }'
p29583
aS'      {'
p29584
aS'        std::cout << "Solving with Q1 elements, global refinement" << std::endl'
p29585
aS'                  << "===========================================" << std::endl'
p29586
aS'                  << std::endl;'
p29587
aS'        Step51::HDG<dim> hdg_problem(1, Step51::HDG<dim>::global_refinement);'
p29588
aS'        hdg_problem.run();'
p29589
aS'        std::cout << std::endl;'
p29590
aS'      }'
p29591
aS'      {'
p29592
aS'        std::cout << "Solving with Q3 elements, global refinement" << std::endl'
p29593
aS'                  << "===========================================" << std::endl'
p29594
aS'                  << std::endl;'
p29595
aS'        Step51::HDG<dim> hdg_problem(3, Step51::HDG<dim>::global_refinement);'
p29596
aS'        hdg_problem.run();'
p29597
aS'        std::cout << std::endl;'
p29598
aS'      }'
p29599
aS'    }'
p29600
aS'  catch (std::exception &exc)'
p29601
aS'    {'
p29602
aS'      std::cerr << std::endl'
p29603
aS'                << std::endl'
p29604
aS'                << "----------------------------------------------------"'
p29605
aS'                << std::endl;'
p29606
aS'      std::cerr << "Exception on processing: " << std::endl'
p29607
aS'                << exc.what() << std::endl'
p29608
aS'                << "Aborting!" << std::endl'
p29609
aS'                << "----------------------------------------------------"'
p29610
aS'                << std::endl;'
p29611
aS'      return 1;'
p29612
aS'    }'
p29613
aS'  catch (...)'
p29614
aS'    {'
p29615
aS'      std::cerr << std::endl'
p29616
aS'                << std::endl'
p29617
aS'                << "----------------------------------------------------"'
p29618
aS'                << std::endl;'
p29619
aS'      std::cerr << "Unknown exception!" << std::endl'
p29620
aS'                << "Aborting!" << std::endl'
p29621
aS'                << "----------------------------------------------------"'
p29622
aS'                << std::endl;'
p29623
aS'      return 1;'
p29624
aS'    }'
p29625
aS'  return 0;'
p29626
ag32
aS'/* ---------------------------------------------------------------------'
p29627
aS' *'
p29628
aS' * Copyright (C) 2014 - 2021 by the deal.II authors'
p29629
aS' *'
p29630
aS' * This file is part of the deal.II library.'
p29631
aS' *'
p29632
aS' * The deal.II library is free software; you can use it, redistribute'
p29633
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p29634
aS' * Public License as published by the Free Software Foundation; either'
p29635
aS' * version 2.1 of the License, or (at your option) any later version.'
p29636
aS' * The full text of the license can be found in the file LICENSE.md at'
p29637
aS' * the top level directory of deal.II.'
p29638
aS' *'
p29639
aS' * ---------------------------------------------------------------------'
p29640
aS' *'
p29641
aS' * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014'
p29642
aS' */'
p29643
aS'#include <deal.II/base/discrete_time.h>'
p29644
aS'#include <deal.II/base/function.h>'
p29645
aS'#include <deal.II/base/quadrature_lib.h>'
p29646
aS'#include <deal.II/grid/grid_generator.h>'
p29647
aS'#include <deal.II/grid/tria.h>'
p29648
aS'#include <deal.II/grid/grid_out.h>'
p29649
aS'#include <deal.II/dofs/dof_handler.h>'
p29650
aS'#include <deal.II/dofs/dof_tools.h>'
p29651
aS'#include <deal.II/fe/fe_q.h>'
p29652
aS'#include <deal.II/fe/fe_values.h>'
p29653
aS'#include <deal.II/lac/affine_constraints.h>'
p29654
aS'#include <deal.II/lac/sparse_direct.h>'
p29655
aS'#include <deal.II/numerics/vector_tools.h>'
p29656
aS'#include <deal.II/numerics/data_out.h>'
p29657
aS'#include <fstream>'
p29658
aS'#include <iostream>'
p29659
aS'#include <cmath>'
p29660
aS'#include <map>'
p29661
aS'#include <deal.II/base/time_stepping.h>'
p29662
aS'namespace Step52'
p29663
ag24
aS'  using namespace dealii;'
p29664
aS'  class Diffusion'
p29665
aS'  {'
p29666
aS'  public:'
p29667
aS'    Diffusion();'
p29668
aS'    void run();'
p29669
aS'  private:'
p29670
aS'    void setup_system();'
p29671
aS'    void assemble_system();'
p29672
aS'    double get_source(const double time, const Point<2> &point) const;'
p29673
aS'    Vector<double> evaluate_diffusion(const double          time,'
p29674
aS'                                      const Vector<double> &y) const;'
p29675
aS'    Vector<double> id_minus_tau_J_inverse(const double          time,'
p29676
aS'                                          const double          tau,'
p29677
aS'                                          const Vector<double> &y);'
p29678
aS'    void output_results(const double                     time,'
p29679
aS'                        const unsigned int               time_step,'
p29680
aS'                        TimeStepping::runge_kutta_method method) const;'
p29681
aS'    void explicit_method(const TimeStepping::runge_kutta_method method,'
p29682
aS'                         const unsigned int                     n_time_steps,'
p29683
aS'                         const double                           initial_time,'
p29684
aS'                         const double                           final_time);'
p29685
aS'    void implicit_method(const TimeStepping::runge_kutta_method method,'
p29686
aS'                         const unsigned int                     n_time_steps,'
p29687
aS'                         const double                           initial_time,'
p29688
aS'                         const double                           final_time);'
p29689
aS'    unsigned int'
p29690
aS'    embedded_explicit_method(const TimeStepping::runge_kutta_method method,'
p29691
aS'                             const unsigned int n_time_steps,'
p29692
aS'                             const double       initial_time,'
p29693
aS'                             const double       final_time);'
p29694
aS'    const unsigned int fe_degree;'
p29695
aS'    const double diffusion_coefficient;'
p29696
aS'    const double absorption_cross_section;'
p29697
aS'    Triangulation<2> triangulation;'
p29698
aS'    const FE_Q<2> fe;'
p29699
aS'    DoFHandler<2> dof_handler;'
p29700
aS'    AffineConstraints<double> constraint_matrix;'
p29701
aS'    SparsityPattern sparsity_pattern;'
p29702
aS'    SparseMatrix<double> system_matrix;'
p29703
aS'    SparseMatrix<double> mass_matrix;'
p29704
aS'    SparseMatrix<double> mass_minus_tau_Jacobian;'
p29705
aS'    SparseDirectUMFPACK inverse_mass_matrix;'
p29706
aS'    Vector<double> solution;'
p29707
aS'  };'
p29708
aS'  Diffusion::Diffusion()'
p29709
aS'    : fe_degree(2)'
p29710
aS'    , diffusion_coefficient(1. / 30.)'
p29711
aS'    , absorption_cross_section(1.)'
p29712
aS'    , fe(fe_degree)'
p29713
aS'    , dof_handler(triangulation)'
p29714
aS'  {}'
p29715
aS'  void Diffusion::setup_system()'
p29716
aS'  {'
p29717
aS'    dof_handler.distribute_dofs(fe);'
p29718
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p29719
aS'                                             1,'
p29720
aS'                                             Functions::ZeroFunction<2>(),'
p29721
aS'                                             constraint_matrix);'
p29722
aS'    constraint_matrix.close();'
p29723
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p29724
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraint_matrix);'
p29725
aS'    sparsity_pattern.copy_from(dsp);'
p29726
aS'    system_matrix.reinit(sparsity_pattern);'
p29727
aS'    mass_matrix.reinit(sparsity_pattern);'
p29728
aS'    mass_minus_tau_Jacobian.reinit(sparsity_pattern);'
p29729
aS'    solution.reinit(dof_handler.n_dofs());'
p29730
aS'  }'
p29731
aS'  void Diffusion::assemble_system()'
p29732
aS'  {'
p29733
aS'    system_matrix = 0.;'
p29734
aS'    mass_matrix   = 0.;'
p29735
aS'    const QGauss<2> quadrature_formula(fe_degree + 1);'
p29736
aS'    FEValues<2> fe_values(fe,'
p29737
aS'                          quadrature_formula,'
p29738
aS'                          update_values | update_gradients | update_JxW_values);'
p29739
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p29740
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p29741
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p29742
aS'    FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);'
p29743
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p29744
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p29745
aS'      {'
p29746
aS'        cell_matrix      = 0.;'
p29747
aS'        cell_mass_matrix = 0.;'
p29748
aS'        fe_values.reinit(cell);'
p29749
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p29750
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p29751
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p29752
aS'              {'
p29753
aS'                cell_matrix(i, j) +='
p29754
aS'                  ((-diffusion_coefficient *                // (-D'
p29755
aS'                      fe_values.shape_grad(i, q_point) *    //  * grad phi_i'
p29756
aS'                      fe_values.shape_grad(j, q_point)      //  * grad phi_j'
p29757
aS'                    - absorption_cross_section *            //  -Sigma'
p29758
aS'                        fe_values.shape_value(i, q_point) * //  * phi_i'
p29759
aS'                        fe_values.shape_value(j, q_point))  //  * phi_j)'
p29760
aS'                   * fe_values.JxW(q_point));               // * dx'
p29761
aS'                cell_mass_matrix(i, j) += fe_values.shape_value(i, q_point) *'
p29762
aS'                                          fe_values.shape_value(j, q_point) *'
p29763
aS'                                          fe_values.JxW(q_point);'
p29764
aS'              }'
p29765
aS'        cell->get_dof_indices(local_dof_indices);'
p29766
aS'        constraint_matrix.distribute_local_to_global(cell_matrix,'
p29767
aS'                                                     local_dof_indices,'
p29768
aS'                                                     system_matrix);'
p29769
aS'        constraint_matrix.distribute_local_to_global(cell_mass_matrix,'
p29770
aS'                                                     local_dof_indices,'
p29771
aS'                                                     mass_matrix);'
p29772
aS'      }'
p29773
aS'    inverse_mass_matrix.initialize(mass_matrix);'
p29774
aS'  }'
p29775
aS'  double Diffusion::get_source(const double time, const Point<2> &point) const'
p29776
aS'  {'
p29777
aS'    const double intensity = 10.;'
p29778
aS'    const double frequency = numbers::PI / 10.;'
p29779
aS'    const double b         = 5.;'
p29780
aS'    const double x         = point(0);'
p29781
aS'    return intensity *'
p29782
aS'           (frequency * std::cos(frequency * time) * (b * x - x * x) +'
p29783
aS'            std::sin(frequency * time) *'
p29784
aS'              (absorption_cross_section * (b * x - x * x) +'
p29785
aS'               2. * diffusion_coefficient));'
p29786
aS'  }'
p29787
aS'  Vector<double> Diffusion::evaluate_diffusion(const double          time,'
p29788
aS'                                               const Vector<double> &y) const'
p29789
aS'  {'
p29790
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p29791
aS'    tmp = 0.;'
p29792
aS'    system_matrix.vmult(tmp, y);'
p29793
aS'    const QGauss<2> quadrature_formula(fe_degree + 1);'
p29794
aS'    FEValues<2> fe_values(fe,'
p29795
aS'                          quadrature_formula,'
p29796
aS'                          update_values | update_quadrature_points |'
p29797
aS'                            update_JxW_values);'
p29798
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p29799
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p29800
aS'    Vector<double> cell_source(dofs_per_cell);'
p29801
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p29802
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p29803
aS'      {'
p29804
aS'        cell_source = 0.;'
p29805
aS'        fe_values.reinit(cell);'
p29806
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p29807
aS'          {'
p29808
aS'            const double source ='
p29809
aS'              get_source(time, fe_values.quadrature_point(q_point));'
p29810
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p29811
aS'              cell_source(i) += fe_values.shape_value(i, q_point) * // phi_i(x)'
p29812
aS'                                source *                            // * S(x)'
p29813
aS'                                fe_values.JxW(q_point);             // * dx'
p29814
aS'          }'
p29815
aS'        cell->get_dof_indices(local_dof_indices);'
p29816
aS'        constraint_matrix.distribute_local_to_global(cell_source,'
p29817
aS'                                                     local_dof_indices,'
p29818
aS'                                                     tmp);'
p29819
aS'      }'
p29820
aS'    Vector<double> value(dof_handler.n_dofs());'
p29821
aS'    inverse_mass_matrix.vmult(value, tmp);'
p29822
aS'    return value;'
p29823
aS'  }'
p29824
aS'  Vector<double> Diffusion::id_minus_tau_J_inverse(const double /*time*/,'
p29825
aS'                                                   const double          tau,'
p29826
aS'                                                   const Vector<double> &y)'
p29827
aS'  {'
p29828
aS'    SparseDirectUMFPACK inverse_mass_minus_tau_Jacobian;'
p29829
aS'    mass_minus_tau_Jacobian.copy_from(mass_matrix);'
p29830
aS'    mass_minus_tau_Jacobian.add(-tau, system_matrix);'
p29831
aS'    inverse_mass_minus_tau_Jacobian.initialize(mass_minus_tau_Jacobian);'
p29832
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p29833
aS'    mass_matrix.vmult(tmp, y);'
p29834
aS'    Vector<double> result(y);'
p29835
aS'    inverse_mass_minus_tau_Jacobian.vmult(result, tmp);'
p29836
aS'    return result;'
p29837
aS'  }'
p29838
aS'  void Diffusion::output_results(const double                     time,'
p29839
aS'                                 const unsigned int               time_step,'
p29840
aS'                                 TimeStepping::runge_kutta_method method) const'
p29841
aS'  {'
p29842
aS'    std::string method_name;'
p29843
aS'    switch (method)'
p29844
aS'      {'
p29845
aS'        case TimeStepping::FORWARD_EULER:'
p29846
aS'          {'
p29847
aS'            method_name = "forward_euler";'
p29848
aS'            break;'
p29849
aS'          }'
p29850
aS'        case TimeStepping::RK_THIRD_ORDER:'
p29851
aS'          {'
p29852
aS'            method_name = "rk3";'
p29853
aS'            break;'
p29854
aS'          }'
p29855
aS'        case TimeStepping::RK_CLASSIC_FOURTH_ORDER:'
p29856
aS'          {'
p29857
aS'            method_name = "rk4";'
p29858
aS'            break;'
p29859
aS'          }'
p29860
aS'        case TimeStepping::BACKWARD_EULER:'
p29861
aS'          {'
p29862
aS'            method_name = "backward_euler";'
p29863
aS'            break;'
p29864
aS'          }'
p29865
aS'        case TimeStepping::IMPLICIT_MIDPOINT:'
p29866
aS'          {'
p29867
aS'            method_name = "implicit_midpoint";'
p29868
aS'            break;'
p29869
aS'          }'
p29870
aS'        case TimeStepping::SDIRK_TWO_STAGES:'
p29871
aS'          {'
p29872
aS'            method_name = "sdirk";'
p29873
aS'            break;'
p29874
aS'          }'
p29875
aS'        case TimeStepping::HEUN_EULER:'
p29876
aS'          {'
p29877
aS'            method_name = "heun_euler";'
p29878
aS'            break;'
p29879
aS'          }'
p29880
aS'        case TimeStepping::BOGACKI_SHAMPINE:'
p29881
aS'          {'
p29882
aS'            method_name = "bocacki_shampine";'
p29883
aS'            break;'
p29884
aS'          }'
p29885
aS'        case TimeStepping::DOPRI:'
p29886
aS'          {'
p29887
aS'            method_name = "dopri";'
p29888
aS'            break;'
p29889
aS'          }'
p29890
aS'        case TimeStepping::FEHLBERG:'
p29891
aS'          {'
p29892
aS'            method_name = "fehlberg";'
p29893
aS'            break;'
p29894
aS'          }'
p29895
aS'        case TimeStepping::CASH_KARP:'
p29896
aS'          {'
p29897
aS'            method_name = "cash_karp";'
p29898
aS'            break;'
p29899
aS'          }'
p29900
aS'        default:'
p29901
aS'          {'
p29902
aS'            break;'
p29903
aS'          }'
p29904
aS'      }'
p29905
aS'    DataOut<2> data_out;'
p29906
aS'    data_out.attach_dof_handler(dof_handler);'
p29907
aS'    data_out.add_data_vector(solution, "solution");'
p29908
aS'    data_out.build_patches();'
p29909
aS'    data_out.set_flags(DataOutBase::VtkFlags(time, time_step));'
p29910
aS'    const std::string filename = "solution_" + method_name + "-" +'
p29911
aS'                                 Utilities::int_to_string(time_step, 3) +'
p29912
aS'                                 ".vtu";'
p29913
aS'    std::ofstream output(filename);'
p29914
aS'    data_out.write_vtu(output);'
p29915
aS'    static std::vector<std::pair<double, std::string>> times_and_names;'
p29916
aS'    static std::string method_name_prev = "";'
p29917
aS'    static std::string pvd_filename;'
p29918
aS'    if (method_name_prev != method_name)'
p29919
aS'      {'
p29920
aS'        times_and_names.clear();'
p29921
aS'        method_name_prev = method_name;'
p29922
aS'        pvd_filename     = "solution_" + method_name + ".pvd";'
p29923
aS'      }'
p29924
aS'    times_and_names.emplace_back(time, filename);'
p29925
aS'    std::ofstream pvd_output(pvd_filename);'
p29926
aS'    DataOutBase::write_pvd_record(pvd_output, times_and_names);'
p29927
aS'  }'
p29928
aS'  void Diffusion::explicit_method(const TimeStepping::runge_kutta_method method,'
p29929
aS'                                  const unsigned int n_time_steps,'
p29930
aS'                                  const double       initial_time,'
p29931
aS'                                  const double       final_time)'
p29932
aS'  {'
p29933
aS'    const double time_step ='
p29934
aS'      (final_time - initial_time) / static_cast<double>(n_time_steps);'
p29935
aS'    solution = 0.;'
p29936
aS'    constraint_matrix.distribute(solution);'
p29937
aS'    TimeStepping::ExplicitRungeKutta<Vector<double>> explicit_runge_kutta('
p29938
aS'      method);'
p29939
aS'    output_results(initial_time, 0, method);'
p29940
aS'    DiscreteTime time(initial_time, final_time, time_step);'
p29941
aS'    while (time.is_at_end() == false)'
p29942
aS'      {'
p29943
aS'        explicit_runge_kutta.evolve_one_time_step('
p29944
aS'          [this](const double time, const Vector<double> &y) {'
p29945
aS'            return this->evaluate_diffusion(time, y);'
p29946
aS'          },'
p29947
aS'          time.get_current_time(),'
p29948
aS'          time.get_next_step_size(),'
p29949
aS'          solution);'
p29950
aS'        time.advance_time();'
p29951
aS'        constraint_matrix.distribute(solution);'
p29952
aS'        if (time.get_step_number() % 10 == 0)'
p29953
aS'          output_results(time.get_current_time(),'
p29954
aS'                         time.get_step_number(),'
p29955
aS'                         method);'
p29956
aS'      }'
p29957
aS'  }'
p29958
aS'  void Diffusion::implicit_method(const TimeStepping::runge_kutta_method method,'
p29959
aS'                                  const unsigned int n_time_steps,'
p29960
aS'                                  const double       initial_time,'
p29961
aS'                                  const double       final_time)'
p29962
aS'  {'
p29963
aS'    const double time_step ='
p29964
aS'      (final_time - initial_time) / static_cast<double>(n_time_steps);'
p29965
aS'    solution = 0.;'
p29966
aS'    constraint_matrix.distribute(solution);'
p29967
aS'    TimeStepping::ImplicitRungeKutta<Vector<double>> implicit_runge_kutta('
p29968
aS'      method);'
p29969
aS'    output_results(initial_time, 0, method);'
p29970
aS'    DiscreteTime time(initial_time, final_time, time_step);'
p29971
aS'    while (time.is_at_end() == false)'
p29972
aS'      {'
p29973
aS'        implicit_runge_kutta.evolve_one_time_step('
p29974
aS'          [this](const double time, const Vector<double> &y) {'
p29975
aS'            return this->evaluate_diffusion(time, y);'
p29976
aS'          },'
p29977
aS'          [this](const double time, const double tau, const Vector<double> &y) {'
p29978
aS'            return this->id_minus_tau_J_inverse(time, tau, y);'
p29979
aS'          },'
p29980
aS'          time.get_current_time(),'
p29981
aS'          time.get_next_step_size(),'
p29982
aS'          solution);'
p29983
aS'        time.advance_time();'
p29984
aS'        constraint_matrix.distribute(solution);'
p29985
aS'        if (time.get_step_number() % 10 == 0)'
p29986
aS'          output_results(time.get_current_time(),'
p29987
aS'                         time.get_step_number(),'
p29988
aS'                         method);'
p29989
aS'      }'
p29990
aS'  }'
p29991
aS'  unsigned int Diffusion::embedded_explicit_method('
p29992
aS'    const TimeStepping::runge_kutta_method method,'
p29993
aS'    const unsigned int                     n_time_steps,'
p29994
aS'    const double                           initial_time,'
p29995
aS'    const double                           final_time)'
p29996
aS'  {'
p29997
aS'    const double time_step ='
p29998
aS'      (final_time - initial_time) / static_cast<double>(n_time_steps);'
p29999
aS'    const double coarsen_param = 1.2;'
p30000
aS'    const double refine_param  = 0.8;'
p30001
aS'    const double min_delta     = 1e-8;'
p30002
aS'    const double max_delta     = 10 * time_step;'
p30003
aS'    const double refine_tol    = 1e-1;'
p30004
aS'    const double coarsen_tol   = 1e-5;'
p30005
aS'    solution = 0.;'
p30006
aS'    constraint_matrix.distribute(solution);'
p30007
aS'    TimeStepping::EmbeddedExplicitRungeKutta<Vector<double>>'
p30008
aS'      embedded_explicit_runge_kutta(method,'
p30009
aS'                                    coarsen_param,'
p30010
aS'                                    refine_param,'
p30011
aS'                                    min_delta,'
p30012
aS'                                    max_delta,'
p30013
aS'                                    refine_tol,'
p30014
aS'                                    coarsen_tol);'
p30015
aS'    output_results(initial_time, 0, method);'
p30016
aS'    DiscreteTime time(initial_time, final_time, time_step);'
p30017
aS'    while (time.is_at_end() == false)'
p30018
aS'      {'
p30019
aS'        const double new_time ='
p30020
aS'          embedded_explicit_runge_kutta.evolve_one_time_step('
p30021
aS'            [this](const double time, const Vector<double> &y) {'
p30022
aS'              return this->evaluate_diffusion(time, y);'
p30023
aS'            },'
p30024
aS'            time.get_current_time(),'
p30025
aS'            time.get_next_step_size(),'
p30026
aS'            solution);'
p30027
aS'        time.set_next_step_size(new_time - time.get_current_time());'
p30028
aS'        time.advance_time();'
p30029
aS'        constraint_matrix.distribute(solution);'
p30030
aS'        if (time.get_step_number() % 10 == 0)'
p30031
aS'          output_results(time.get_current_time(),'
p30032
aS'                         time.get_step_number(),'
p30033
aS'                         method);'
p30034
aS'        time.set_desired_next_step_size('
p30035
aS'          embedded_explicit_runge_kutta.get_status().delta_t_guess);'
p30036
aS'      }'
p30037
aS'    return time.get_step_number();'
p30038
aS'  }'
p30039
aS'  void Diffusion::run()'
p30040
aS'  {'
p30041
aS'    GridGenerator::hyper_cube(triangulation, 0., 5.);'
p30042
aS'    triangulation.refine_global(4);'
p30043
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p30044
aS'      for (const auto &face : cell->face_iterators())'
p30045
aS'        if (face->at_boundary())'
p30046
aS'          {'
p30047
aS'            if ((face->center()[0] == 0.) || (face->center()[0] == 5.))'
p30048
aS'              face->set_boundary_id(1);'
p30049
aS'            else'
p30050
aS'              face->set_boundary_id(0);'
p30051
aS'          }'
p30052
aS'    setup_system();'
p30053
aS'    assemble_system();'
p30054
aS'    unsigned int       n_steps      = 0;'
p30055
aS'    const unsigned int n_time_steps = 200;'
p30056
aS'    const double       initial_time = 0.;'
p30057
aS'    const double       final_time   = 10.;'
p30058
aS'    std::cout << "Explicit methods:" << std::endl;'
p30059
aS'    explicit_method(TimeStepping::FORWARD_EULER,'
p30060
aS'                    n_time_steps,'
p30061
aS'                    initial_time,'
p30062
aS'                    final_time);'
p30063
aS'    std::cout << "   Forward Euler:            error=" << solution.l2_norm()'
p30064
aS'              << std::endl;'
p30065
aS'    explicit_method(TimeStepping::RK_THIRD_ORDER,'
p30066
aS'                    n_time_steps,'
p30067
aS'                    initial_time,'
p30068
aS'                    final_time);'
p30069
aS'    std::cout << "   Third order Runge-Kutta:  error=" << solution.l2_norm()'
p30070
aS'              << std::endl;'
p30071
aS'    explicit_method(TimeStepping::RK_CLASSIC_FOURTH_ORDER,'
p30072
aS'                    n_time_steps,'
p30073
aS'                    initial_time,'
p30074
aS'                    final_time);'
p30075
aS'    std::cout << "   Fourth order Runge-Kutta: error=" << solution.l2_norm()'
p30076
aS'              << std::endl;'
p30077
aS'    std::cout << std::endl;'
p30078
aS'    std::cout << "Implicit methods:" << std::endl;'
p30079
aS'    implicit_method(TimeStepping::BACKWARD_EULER,'
p30080
aS'                    n_time_steps,'
p30081
aS'                    initial_time,'
p30082
aS'                    final_time);'
p30083
aS'    std::cout << "   Backward Euler:           error=" << solution.l2_norm()'
p30084
aS'              << std::endl;'
p30085
aS'    implicit_method(TimeStepping::IMPLICIT_MIDPOINT,'
p30086
aS'                    n_time_steps,'
p30087
aS'                    initial_time,'
p30088
aS'                    final_time);'
p30089
aS'    std::cout << "   Implicit Midpoint:        error=" << solution.l2_norm()'
p30090
aS'              << std::endl;'
p30091
aS'    implicit_method(TimeStepping::CRANK_NICOLSON,'
p30092
aS'                    n_time_steps,'
p30093
aS'                    initial_time,'
p30094
aS'                    final_time);'
p30095
aS'    std::cout << "   Crank-Nicolson:           error=" << solution.l2_norm()'
p30096
aS'              << std::endl;'
p30097
aS'    implicit_method(TimeStepping::SDIRK_TWO_STAGES,'
p30098
aS'                    n_time_steps,'
p30099
aS'                    initial_time,'
p30100
aS'                    final_time);'
p30101
aS'    std::cout << "   SDIRK:                    error=" << solution.l2_norm()'
p30102
aS'              << std::endl;'
p30103
aS'    std::cout << std::endl;'
p30104
aS'    std::cout << "Embedded explicit methods:" << std::endl;'
p30105
aS'    n_steps = embedded_explicit_method(TimeStepping::HEUN_EULER,'
p30106
aS'                                       n_time_steps,'
p30107
aS'                                       initial_time,'
p30108
aS'                                       final_time);'
p30109
aS'    std::cout << "   Heun-Euler:               error=" << solution.l2_norm()'
p30110
aS'              << std::endl;'
p30111
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p30112
aS'    n_steps = embedded_explicit_method(TimeStepping::BOGACKI_SHAMPINE,'
p30113
aS'                                       n_time_steps,'
p30114
aS'                                       initial_time,'
p30115
aS'                                       final_time);'
p30116
aS'    std::cout << "   Bogacki-Shampine:         error=" << solution.l2_norm()'
p30117
aS'              << std::endl;'
p30118
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p30119
aS'    n_steps = embedded_explicit_method(TimeStepping::DOPRI,'
p30120
aS'                                       n_time_steps,'
p30121
aS'                                       initial_time,'
p30122
aS'                                       final_time);'
p30123
aS'    std::cout << "   Dopri:                    error=" << solution.l2_norm()'
p30124
aS'              << std::endl;'
p30125
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p30126
aS'    n_steps = embedded_explicit_method(TimeStepping::FEHLBERG,'
p30127
aS'                                       n_time_steps,'
p30128
aS'                                       initial_time,'
p30129
aS'                                       final_time);'
p30130
aS'    std::cout << "   Fehlberg:                 error=" << solution.l2_norm()'
p30131
aS'              << std::endl;'
p30132
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p30133
aS'    n_steps = embedded_explicit_method(TimeStepping::CASH_KARP,'
p30134
aS'                                       n_time_steps,'
p30135
aS'                                       initial_time,'
p30136
aS'                                       final_time);'
p30137
aS'    std::cout << "   Cash-Karp:                error=" << solution.l2_norm()'
p30138
aS'              << std::endl;'
p30139
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p30140
aS'  }'
p30141
aS'} // namespace Step52'
p30142
aS'int main()'
p30143
ag24
aS'  try'
p30144
aS'    {'
p30145
aS'      Step52::Diffusion diffusion;'
p30146
aS'      diffusion.run();'
p30147
aS'    }'
p30148
aS'  catch (std::exception &exc)'
p30149
aS'    {'
p30150
aS'      std::cerr << std::endl'
p30151
aS'                << std::endl'
p30152
aS'                << "----------------------------------------------------"'
p30153
aS'                << std::endl;'
p30154
aS'      std::cerr << "Exception on processing: " << std::endl'
p30155
aS'                << exc.what() << std::endl'
p30156
aS'                << "Aborting!" << std::endl'
p30157
aS'                << "----------------------------------------------------"'
p30158
aS'                << std::endl;'
p30159
aS'      return 1;'
p30160
aS'    }'
p30161
aS'  catch (...)'
p30162
aS'    {'
p30163
aS'      std::cerr << std::endl'
p30164
aS'                << std::endl'
p30165
aS'                << "----------------------------------------------------"'
p30166
aS'                << std::endl;'
p30167
aS'      std::cerr << "Unknown exception!" << std::endl'
p30168
aS'                << "Aborting!" << std::endl'
p30169
aS'                << "----------------------------------------------------"'
p30170
aS'                << std::endl;'
p30171
aS'      return 1;'
p30172
aS'    };'
p30173
aS'  return 0;'
p30174
ag32
aS'/* ---------------------------------------------------------------------'
p30175
aS' *'
p30176
aS' * Copyright (C) 2014 - 2020 by the deal.II authors'
p30177
aS' *'
p30178
aS' * This file is part of the deal.II library.'
p30179
aS' *'
p30180
aS' * The deal.II library is free software; you can use it, redistribute'
p30181
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p30182
aS' * Public License as published by the Free Software Foundation; either'
p30183
aS' * version 2.1 of the License, or (at your option) any later version.'
p30184
aS' * The full text of the license can be found in the file LICENSE.md at'
p30185
aS' * the top level directory of deal.II.'
p30186
aS' *'
p30187
aS' * ---------------------------------------------------------------------'
p30188
aS' *'
p30189
aS' * Authors: Wolfgang Bangerth, Texas A&M University, 2014'
p30190
aS' *          Luca Heltai, SISSA, 2014'
p30191
aS' *          D. Sarah Stamps, MIT, 2014'
p30192
aS' */'
p30193
aS'#include <deal.II/grid/tria.h>'
p30194
aS'#include <deal.II/grid/grid_generator.h>'
p30195
aS'#include <deal.II/grid/grid_out.h>'
p30196
aS'#include <deal.II/grid/manifold.h>'
p30197
aS'#include <deal.II/grid/grid_tools.h>'
p30198
aS'#include <deal.II/base/function_lib.h>'
p30199
aS'#include <boost/iostreams/filtering_stream.hpp>'
p30200
aS'#include <boost/iostreams/filter/gzip.hpp>'
p30201
aS'#include <boost/iostreams/device/file.hpp>'
p30202
aS'#include <fstream>'
p30203
aS'#include <iostream>'
p30204
aS'#include <memory>'
p30205
aS'namespace Step53'
p30206
ag24
aS'  using namespace dealii;'
p30207
aS'  class AfricaTopography'
p30208
aS'  {'
p30209
aS'  public:'
p30210
aS'    AfricaTopography();'
p30211
aS'    double value(const double lon, const double lat) const;'
p30212
aS'  private:'
p30213
aS'    const Functions::InterpolatedUniformGridData<2> topography_data;'
p30214
aS'    static std::vector<double> get_data();'
p30215
aS'  };'
p30216
aS'  AfricaTopography::AfricaTopography()'
p30217
aS'    : topography_data({{std::make_pair(-6.983333, 11.966667),'
p30218
aS'                        std::make_pair(25, 35.95)}},'
p30219
aS'                      {{379, 219}},'
p30220
aS'                      Table<2, double>(380, 220, get_data().begin()))'
p30221
aS'  {}'
p30222
aS'  double AfricaTopography::value(const double lon, const double lat) const'
p30223
aS'  {'
p30224
aS'    return topography_data.value('
p30225
aS'      Point<2>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI));'
p30226
aS'  }'
p30227
aS'  std::vector<double> AfricaTopography::get_data()'
p30228
aS'  {'
p30229
aS'    std::vector<double> data;'
p30230
aS'    boost::iostreams::filtering_istream in;'
p30231
aS'    in.push(boost::iostreams::basic_gzip_decompressor<>());'
p30232
aS'    in.push(boost::iostreams::file_source("topography.txt.gz"));'
p30233
aS'    for (unsigned int line = 0; line < 83600; ++line)'
p30234
aS'      {'
p30235
aS'        try'
p30236
aS'          {'
p30237
aS'            double lat, lon, elevation;'
p30238
aS'            in >> lat >> lon >> elevation;'
p30239
aS'            data.push_back(elevation);'
p30240
aS'          }'
p30241
aS'        catch (...)'
p30242
aS'          {'
p30243
aS'            AssertThrow(false,'
p30244
aS'                        ExcMessage("Could not read all 83,600 data points "'
p30245
aS'                                   "from the file <topography.txt.gz>!"));'
p30246
aS'          }'
p30247
aS'      }'
p30248
aS'    return data;'
p30249
aS'  }'
p30250
aS'  class AfricaGeometry : public ChartManifold<3, 3>'
p30251
aS'  {'
p30252
aS'  public:'
p30253
aS'    virtual Point<3> pull_back(const Point<3> &space_point) const override;'
p30254
aS'    virtual Point<3> push_forward(const Point<3> &chart_point) const override;'
p30255
aS'    virtual std::unique_ptr<Manifold<3, 3>> clone() const override;'
p30256
aS'  private:'
p30257
aS'    static const double R;'
p30258
aS'    static const double ellipticity;'
p30259
aS'    const AfricaTopography topography;'
p30260
aS'    Point<3> push_forward_wgs84(const Point<3> &phi_theta_d) const;'
p30261
aS'    Point<3> pull_back_wgs84(const Point<3> &x) const;'
p30262
aS'    Point<3> push_forward_topo(const Point<3> &phi_theta_d_hat) const;'
p30263
aS'    Point<3> pull_back_topo(const Point<3> &phi_theta_d) const;'
p30264
aS'  };'
p30265
aS'  const double AfricaGeometry::R           = 6378137;'
p30266
aS'  const double AfricaGeometry::ellipticity = 8.1819190842622e-2;'
p30267
aS'  Point<3> AfricaGeometry::pull_back(const Point<3> &space_point) const'
p30268
aS'  {'
p30269
aS'    return pull_back_topo(pull_back_wgs84(space_point));'
p30270
aS'  }'
p30271
aS'  Point<3> AfricaGeometry::push_forward(const Point<3> &chart_point) const'
p30272
aS'  {'
p30273
aS'    return push_forward_wgs84(push_forward_topo(chart_point));'
p30274
aS'  }'
p30275
aS'  std::unique_ptr<Manifold<3, 3>> AfricaGeometry::clone() const'
p30276
aS'  {'
p30277
aS'    return std::make_unique<AfricaGeometry>();'
p30278
aS'  }'
p30279
aS'  Point<3> AfricaGeometry::push_forward_wgs84(const Point<3> &phi_theta_d) const'
p30280
aS'  {'
p30281
aS'    const double phi   = phi_theta_d[0];'
p30282
aS'    const double theta = phi_theta_d[1];'
p30283
aS'    const double d     = phi_theta_d[2];'
p30284
aS'    const double R_bar = R / std::sqrt(1 - (ellipticity * ellipticity *'
p30285
aS'                                            std::sin(theta) * std::sin(theta)));'
p30286
aS'    return {(R_bar + d) * std::cos(phi) * std::cos(theta),'
p30287
aS'            (R_bar + d) * std::sin(phi) * std::cos(theta),'
p30288
aS'            ((1 - ellipticity * ellipticity) * R_bar + d) * std::sin(theta)};'
p30289
aS'  }'
p30290
aS'  Point<3> AfricaGeometry::pull_back_wgs84(const Point<3> &x) const'
p30291
aS'  {'
p30292
aS'    const double b   = std::sqrt(R * R * (1 - ellipticity * ellipticity));'
p30293
aS'    const double ep  = std::sqrt((R * R - b * b) / (b * b));'
p30294
aS'    const double p   = std::sqrt(x(0) * x(0) + x(1) * x(1));'
p30295
aS'    const double th  = std::atan2(R * x(2), b * p);'
p30296
aS'    const double phi = std::atan2(x(1), x(0));'
p30297
aS'    const double theta ='
p30298
aS'      std::atan2(x(2) + ep * ep * b * std::pow(std::sin(th), 3),'
p30299
aS'                 (p -'
p30300
aS'                  (ellipticity * ellipticity * R * std::pow(std::cos(th), 3))));'
p30301
aS'    const double R_bar ='
p30302
aS'      R / (std::sqrt(1 - ellipticity * ellipticity * std::sin(theta) *'
p30303
aS'                           std::sin(theta)));'
p30304
aS'    const double R_plus_d = p / std::cos(theta);'
p30305
aS'    Point<3> phi_theta_d;'
p30306
aS'    if (phi < 0)'
p30307
aS'      phi_theta_d[0] = phi + 2 * numbers::PI;'
p30308
aS'    else if (phi > 2 * numbers::PI)'
p30309
aS'      phi_theta_d[0] = phi - 2 * numbers::PI;'
p30310
aS'    else'
p30311
aS'      phi_theta_d[0] = phi;'
p30312
aS'    phi_theta_d[1] = theta;'
p30313
aS'    phi_theta_d[2] = R_plus_d - R_bar;'
p30314
aS'    return phi_theta_d;'
p30315
aS'  }'
p30316
aS'  Point<3>'
p30317
aS'  AfricaGeometry::push_forward_topo(const Point<3> &phi_theta_d_hat) const'
p30318
aS'  {'
p30319
aS'    const double d_hat = phi_theta_d_hat[2];'
p30320
aS'    const double h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);'
p30321
aS'    const double d = d_hat + (d_hat + 500000) / 500000 * h;'
p30322
aS'    return {phi_theta_d_hat[0], phi_theta_d_hat[1], d};'
p30323
aS'  }'
p30324
aS'  Point<3> AfricaGeometry::pull_back_topo(const Point<3> &phi_theta_d) const'
p30325
aS'  {'
p30326
aS'    const double d     = phi_theta_d[2];'
p30327
aS'    const double h     = topography.value(phi_theta_d[0], phi_theta_d[1]);'
p30328
aS'    const double d_hat = 500000 * (d - h) / (500000 + h);'
p30329
aS'    return {phi_theta_d[0], phi_theta_d[1], d_hat};'
p30330
aS'  }'
p30331
aS'  void run()'
p30332
aS'  {'
p30333
aS'    AfricaGeometry   geometry;'
p30334
aS'    Triangulation<3> triangulation;'
p30335
aS'    {'
p30336
aS'      const Point<3> corner_points[2] = {'
p30337
aS'        Point<3>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),'
p30338
aS'        Point<3>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};'
p30339
aS'      std::vector<unsigned int> subdivisions(3);'
p30340
aS'      subdivisions[0] = 1;'
p30341
aS'      subdivisions[1] = 2;'
p30342
aS'      subdivisions[2] = 1;'
p30343
aS'      GridGenerator::subdivided_hyper_rectangle('
p30344
aS'        triangulation, subdivisions, corner_points[0], corner_points[1], true);'
p30345
aS'      GridTools::transform('
p30346
aS'        [&geometry](const Point<3> &chart_point) {'
p30347
aS'          return geometry.push_forward(chart_point);'
p30348
aS'        },'
p30349
aS'        triangulation);'
p30350
aS'    }'
p30351
aS'    triangulation.set_manifold(0, geometry);'
p30352
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p30353
aS'      cell->set_all_manifold_ids(0);'
p30354
aS'    for (unsigned int i = 0; i < 6; ++i)'
p30355
aS'      {'
p30356
aS'        for (const auto &cell : triangulation.active_cell_iterators())'
p30357
aS'          for (const auto &face : cell->face_iterators())'
p30358
aS'            if (face->boundary_id() == 5)'
p30359
aS'              {'
p30360
aS'                cell->set_refine_flag();'
p30361
aS'                break;'
p30362
aS'              }'
p30363
aS'        triangulation.execute_coarsening_and_refinement();'
p30364
aS'        std::cout << "Refinement step " << i + 1 << ": "'
p30365
aS'                  << triangulation.n_active_cells() << " cells, "'
p30366
aS'                  << GridTools::minimal_cell_diameter(triangulation) / 1000'
p30367
aS'                  << "km minimal cell diameter" << std::endl;'
p30368
aS'      }'
p30369
aS'    const std::string filename = "mesh.vtu";'
p30370
aS'    std::ofstream     out(filename);'
p30371
aS'    GridOut           grid_out;'
p30372
aS'    grid_out.write_vtu(triangulation, out);'
p30373
aS'  }'
p30374
aS'} // namespace Step53'
p30375
aS'int main()'
p30376
ag24
aS'  try'
p30377
aS'    {'
p30378
aS'      Step53::run();'
p30379
aS'    }'
p30380
aS'  catch (std::exception &exc)'
p30381
aS'    {'
p30382
aS'      std::cerr << std::endl'
p30383
aS'                << std::endl'
p30384
aS'                << "----------------------------------------------------"'
p30385
aS'                << std::endl;'
p30386
aS'      std::cerr << "Exception on processing: " << std::endl'
p30387
aS'                << exc.what() << std::endl'
p30388
aS'                << "Aborting!" << std::endl'
p30389
aS'                << "----------------------------------------------------"'
p30390
aS'                << std::endl;'
p30391
aS'      return 1;'
p30392
aS'    }'
p30393
aS'  catch (...)'
p30394
aS'    {'
p30395
aS'      std::cerr << std::endl'
p30396
aS'                << std::endl'
p30397
aS'                << "----------------------------------------------------"'
p30398
aS'                << std::endl;'
p30399
aS'      std::cerr << "Unknown exception!" << std::endl'
p30400
aS'                << "Aborting!" << std::endl'
p30401
aS'                << "----------------------------------------------------"'
p30402
aS'                << std::endl;'
p30403
aS'      return 1;'
p30404
aS'    }'
p30405
ag32
aS'/* ---------------------------------------------------------------------'
p30406
aS' *'
p30407
aS' * Copyright (C) 2009 - 2021 by the deal.II authors'
p30408
aS' *'
p30409
aS' * This file is part of the deal.II library.'
p30410
aS' *'
p30411
aS' * The deal.II library is free software; you can use it, redistribute'
p30412
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p30413
aS' * Public License as published by the Free Software Foundation; either'
p30414
aS' * version 2.1 of the License, or (at your option) any later version.'
p30415
aS' * The full text of the license can be found in the file LICENSE.md at'
p30416
aS' * the top level directory of deal.II.'
p30417
aS' *'
p30418
aS' * ---------------------------------------------------------------------'
p30419
aS' *  Authors: Andrea Mola, Luca Heltai, 2014'
p30420
aS' */'
p30421
aS'#include <deal.II/grid/tria.h>'
p30422
aS'#include <deal.II/grid/grid_generator.h>'
p30423
aS'#include <deal.II/grid/grid_in.h>'
p30424
aS'#include <deal.II/grid/grid_out.h>'
p30425
aS'#include <deal.II/numerics/data_out.h>'
p30426
aS'#include <deal.II/numerics/vector_tools.h>'
p30427
aS'#include <deal.II/opencascade/manifold_lib.h>'
p30428
aS'#include <deal.II/opencascade/utilities.h>'
p30429
aS'#include <cmath>'
p30430
aS'#include <iostream>'
p30431
aS'#include <fstream>'
p30432
aS'#include <string>'
p30433
aS'namespace Step54'
p30434
ag24
aS'  using namespace dealii;'
p30435
aS'  class TriangulationOnCAD'
p30436
aS'  {'
p30437
aS'  public:'
p30438
aS'    enum ProjectionType'
p30439
aS'    {'
p30440
aS'      NormalProjection       = 0,'
p30441
aS'      DirectionalProjection  = 1,'
p30442
aS'      NormalToMeshProjection = 2'
p30443
aS'    };'
p30444
aS'    TriangulationOnCAD('
p30445
aS'      const std::string &  initial_mesh_filename,'
p30446
aS'      const std::string &  cad_file_name,'
p30447
aS'      const std::string &  output_filename,'
p30448
aS'      const ProjectionType surface_projection_kind = NormalProjection);'
p30449
aS'    void run();'
p30450
aS'  private:'
p30451
aS'    void read_domain();'
p30452
aS'    void refine_mesh();'
p30453
aS'    void output_results(const unsigned int cycle);'
p30454
aS'    Triangulation<2, 3> tria;'
p30455
aS'    const std::string initial_mesh_filename;'
p30456
aS'    const std::string cad_file_name;'
p30457
aS'    const std::string output_filename;'
p30458
aS'    const ProjectionType surface_projection_kind;'
p30459
aS'  };'
p30460
aS'  TriangulationOnCAD::TriangulationOnCAD('
p30461
aS'    const std::string &  initial_mesh_filename,'
p30462
aS'    const std::string &  cad_file_name,'
p30463
aS'    const std::string &  output_filename,'
p30464
aS'    const ProjectionType surface_projection_kind)'
p30465
aS'    : initial_mesh_filename(initial_mesh_filename)'
p30466
aS'    , cad_file_name(cad_file_name)'
p30467
aS'    , output_filename(output_filename)'
p30468
aS'    , surface_projection_kind(surface_projection_kind)'
p30469
aS'  {}'
p30470
aS'  void TriangulationOnCAD::read_domain()'
p30471
aS'  {'
p30472
aS'    TopoDS_Shape bow_surface = OpenCASCADE::read_IGES(cad_file_name, 1e-3);'
p30473
aS'    const double tolerance = OpenCASCADE::get_shape_tolerance(bow_surface) * 5;'
p30474
aS'    std::vector<TopoDS_Compound>  compounds;'
p30475
aS'    std::vector<TopoDS_CompSolid> compsolids;'
p30476
aS'    std::vector<TopoDS_Solid>     solids;'
p30477
aS'    std::vector<TopoDS_Shell>     shells;'
p30478
aS'    std::vector<TopoDS_Wire>      wires;'
p30479
aS'    OpenCASCADE::extract_compound_shapes('
p30480
aS'      bow_surface, compounds, compsolids, solids, shells, wires);'
p30481
aS'    std::ifstream in;'
p30482
aS'    in.open(initial_mesh_filename);'
p30483
aS'    GridIn<2, 3> gi;'
p30484
aS'    gi.attach_triangulation(tria);'
p30485
aS'    gi.read_vtk(in);'
p30486
aS'    output_results(0);'
p30487
aS'    Triangulation<2, 3>::active_cell_iterator cell = tria.begin_active();'
p30488
aS'    cell->set_manifold_id(1);'
p30489
aS'    for (const auto &face : cell->face_iterators())'
p30490
aS'      face->set_manifold_id(2);'
p30491
aS'    Assert('
p30492
aS'      wires.size() > 0,'
p30493
aS'      ExcMessage('
p30494
aS'        "I could not find any wire in the CAD file you gave me. Bailing out."));'
p30495
aS'    OpenCASCADE::ArclengthProjectionLineManifold<2, 3> line_projector('
p30496
aS'      wires[0], tolerance);'
p30497
aS'    tria.set_manifold(2, line_projector);'
p30498
aS'    switch (surface_projection_kind)'
p30499
aS'      {'
p30500
aS'        case NormalProjection:'
p30501
aS'          {'
p30502
aS'            OpenCASCADE::NormalProjectionManifold<2, 3> normal_projector('
p30503
aS'              bow_surface, tolerance);'
p30504
aS'            tria.set_manifold(1, normal_projector);'
p30505
aS'            break;'
p30506
aS'          }'
p30507
aS'        case DirectionalProjection:'
p30508
aS'          {'
p30509
aS'            OpenCASCADE::DirectionalProjectionManifold<2, 3>'
p30510
aS'              directional_projector(bow_surface,'
p30511
aS'                                    Point<3>(0.0, 1.0, 0.0),'
p30512
aS'                                    tolerance);'
p30513
aS'            tria.set_manifold(1, directional_projector);'
p30514
aS'            break;'
p30515
aS'          }'
p30516
aS'        case NormalToMeshProjection:'
p30517
aS'          {'
p30518
aS'            OpenCASCADE::NormalToMeshProjectionManifold<2, 3>'
p30519
aS'              normal_to_mesh_projector(bow_surface, tolerance);'
p30520
aS'            tria.set_manifold(1, normal_to_mesh_projector);'
p30521
aS'            break;'
p30522
aS'          }'
p30523
aS'        default:'
p30524
aS'          AssertThrow(false, ExcInternalError());'
p30525
aS'      }'
p30526
aS'  }'
p30527
aS'  void TriangulationOnCAD::refine_mesh()'
p30528
aS'  {'
p30529
aS'    tria.refine_global(1);'
p30530
aS'  }'
p30531
aS'  void TriangulationOnCAD::output_results(const unsigned int cycle)'
p30532
aS'  {'
p30533
aS'    const std::string filename ='
p30534
aS'      (output_filename + "_" + Utilities::int_to_string(cycle) + ".vtk");'
p30535
aS'    std::ofstream logfile(filename);'
p30536
aS'    GridOut       grid_out;'
p30537
aS'    grid_out.write_vtk(tria, logfile);'
p30538
aS'  }'
p30539
aS'  void TriangulationOnCAD::run()'
p30540
aS'  {'
p30541
aS'    read_domain();'
p30542
aS'    const unsigned int n_cycles = 5;'
p30543
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p30544
aS'      {'
p30545
aS'        refine_mesh();'
p30546
aS'        output_results(cycle + 1);'
p30547
aS'      }'
p30548
aS'  }'
p30549
aS'} // namespace Step54'
p30550
aS'int main()'
p30551
ag24
aS'  try'
p30552
aS'    {'
p30553
aS'      using namespace Step54;'
p30554
aS'      const std::string in_mesh_filename = "input/initial_mesh_3d.vtk";'
p30555
aS'      const std::string cad_file_name    = "input/DTMB-5415_bulbous_bow.iges";'
p30556
aS'      std::cout << "----------------------------------------------------------"'
p30557
aS'                << std::endl;'
p30558
aS'      std::cout << "Testing projection in direction normal to CAD surface"'
p30559
aS'                << std::endl;'
p30560
aS'      std::cout << "----------------------------------------------------------"'
p30561
aS'                << std::endl;'
p30562
aS'      std::string        out_mesh_filename = ("3d_mesh_normal_projection");'
p30563
aS'      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,'
p30564
aS'                                          cad_file_name,'
p30565
aS'                                          out_mesh_filename,'
p30566
aS'                                          TriangulationOnCAD::NormalProjection);'
p30567
aS'      tria_on_cad_norm.run();'
p30568
aS'      std::cout << "----------------------------------------------------------"'
p30569
aS'                << std::endl;'
p30570
aS'      std::cout << std::endl;'
p30571
aS'      std::cout << std::endl;'
p30572
aS'      std::cout << "----------------------------------------------------------"'
p30573
aS'                << std::endl;'
p30574
aS'      std::cout << "Testing projection in y-axis direction" << std::endl;'
p30575
aS'      std::cout << "----------------------------------------------------------"'
p30576
aS'                << std::endl;'
p30577
aS'      out_mesh_filename = ("3d_mesh_directional_projection");'
p30578
aS'      TriangulationOnCAD tria_on_cad_dir('
p30579
aS'        in_mesh_filename,'
p30580
aS'        cad_file_name,'
p30581
aS'        out_mesh_filename,'
p30582
aS'        TriangulationOnCAD::DirectionalProjection);'
p30583
aS'      tria_on_cad_dir.run();'
p30584
aS'      std::cout << "----------------------------------------------------------"'
p30585
aS'                << std::endl;'
p30586
aS'      std::cout << std::endl;'
p30587
aS'      std::cout << std::endl;'
p30588
aS'      std::cout << "----------------------------------------------------------"'
p30589
aS'                << std::endl;'
p30590
aS'      std::cout << "Testing projection in direction normal to mesh elements"'
p30591
aS'                << std::endl;'
p30592
aS'      std::cout << "----------------------------------------------------------"'
p30593
aS'                << std::endl;'
p30594
aS'      out_mesh_filename = ("3d_mesh_normal_to_mesh_projection");'
p30595
aS'      TriangulationOnCAD tria_on_cad_norm_to_mesh('
p30596
aS'        in_mesh_filename,'
p30597
aS'        cad_file_name,'
p30598
aS'        out_mesh_filename,'
p30599
aS'        TriangulationOnCAD::NormalToMeshProjection);'
p30600
aS'      tria_on_cad_norm_to_mesh.run();'
p30601
aS'      std::cout << "----------------------------------------------------------"'
p30602
aS'                << std::endl;'
p30603
aS'      std::cout << std::endl;'
p30604
aS'      std::cout << std::endl;'
p30605
aS'    }'
p30606
aS'  catch (std::exception &exc)'
p30607
aS'    {'
p30608
aS'      std::cerr << std::endl'
p30609
aS'                << std::endl'
p30610
aS'                << "----------------------------------------------------"'
p30611
aS'                << std::endl;'
p30612
aS'      std::cerr << "Exception on processing: " << std::endl'
p30613
aS'                << exc.what() << std::endl'
p30614
aS'                << "Aborting!" << std::endl'
p30615
aS'                << "----------------------------------------------------"'
p30616
aS'                << std::endl;'
p30617
aS'      return 1;'
p30618
aS'    }'
p30619
aS'  catch (...)'
p30620
aS'    {'
p30621
aS'      std::cerr << std::endl'
p30622
aS'                << std::endl'
p30623
aS'                << "----------------------------------------------------"'
p30624
aS'                << std::endl;'
p30625
aS'      std::cerr << "Unknown exception!" << std::endl'
p30626
aS'                << "Aborting!" << std::endl'
p30627
aS'                << "----------------------------------------------------"'
p30628
aS'                << std::endl;'
p30629
aS'      return 1;'
p30630
aS'    }'
p30631
aS'  return 0;'
p30632
ag32
aS'/* ---------------------------------------------------------------------'
p30633
aS' *'
p30634
aS' * Copyright (C) 2016 - 2021 by the deal.II authors'
p30635
aS' *'
p30636
aS' * This file is part of the deal.II library.'
p30637
aS' *'
p30638
aS' * The deal.II library is free software; you can use it, redistribute'
p30639
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p30640
aS' * Public License as published by the Free Software Foundation; either'
p30641
aS' * version 2.1 of the License, or (at your option) any later version.'
p30642
aS' * The full text of the license can be found in the file LICENSE.md at'
p30643
aS' * the top level directory of deal.II.'
p30644
aS' *'
p30645
aS' * ---------------------------------------------------------------------'
p30646
aS' *'
p30647
aS' * Author: Timo Heister, Clemson University, 2016'
p30648
aS' */'
p30649
aS'#include <deal.II/base/quadrature_lib.h>'
p30650
aS'#include <deal.II/base/function.h>'
p30651
aS'#include <deal.II/base/timer.h>'
p30652
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p30653
aS'/* #define FORCE_USE_OF_TRILINOS */'
p30654
aS'namespace LA'
p30655
ag24
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p30656
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p30657
aS'  using namespace dealii::LinearAlgebraPETSc;'
p30658
aS'#  define USE_PETSC_LA'
p30659
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p30660
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p30661
aS'#else'
p30662
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p30663
aS'#endif'
p30664
aS'} // namespace LA'
p30665
aS'#include <deal.II/lac/vector.h>'
p30666
aS'#include <deal.II/lac/full_matrix.h>'
p30667
aS'#include <deal.II/lac/solver_cg.h>'
p30668
aS'#include <deal.II/lac/solver_gmres.h>'
p30669
aS'#include <deal.II/lac/solver_minres.h>'
p30670
aS'#include <deal.II/lac/affine_constraints.h>'
p30671
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p30672
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p30673
aS'#include <deal.II/lac/petsc_vector.h>'
p30674
aS'#include <deal.II/lac/petsc_solver.h>'
p30675
aS'#include <deal.II/lac/petsc_precondition.h>'
p30676
aS'#include <deal.II/grid/grid_generator.h>'
p30677
aS'#include <deal.II/grid/manifold_lib.h>'
p30678
aS'#include <deal.II/grid/grid_tools.h>'
p30679
aS'#include <deal.II/dofs/dof_handler.h>'
p30680
aS'#include <deal.II/dofs/dof_renumbering.h>'
p30681
aS'#include <deal.II/dofs/dof_tools.h>'
p30682
aS'#include <deal.II/fe/fe_values.h>'
p30683
aS'#include <deal.II/fe/fe_q.h>'
p30684
aS'#include <deal.II/fe/fe_system.h>'
p30685
aS'#include <deal.II/numerics/vector_tools.h>'
p30686
aS'#include <deal.II/numerics/data_out.h>'
p30687
aS'#include <deal.II/numerics/error_estimator.h>'
p30688
aS'#include <deal.II/base/utilities.h>'
p30689
aS'#include <deal.II/base/conditional_ostream.h>'
p30690
aS'#include <deal.II/base/index_set.h>'
p30691
aS'#include <deal.II/lac/sparsity_tools.h>'
p30692
aS'#include <deal.II/distributed/tria.h>'
p30693
aS'#include <deal.II/distributed/grid_refinement.h>'
p30694
aS'#include <cmath>'
p30695
aS'#include <fstream>'
p30696
aS'#include <iostream>'
p30697
aS'namespace Step55'
p30698
ag24
aS'  using namespace dealii;'
p30699
aS'  namespace LinearSolvers'
p30700
aS'  {'
p30701
aS'    template <class Matrix, class Preconditioner>'
p30702
aS'    class InverseMatrix : public Subscriptor'
p30703
aS'    {'
p30704
aS'    public:'
p30705
aS'      InverseMatrix(const Matrix &m, const Preconditioner &preconditioner);'
p30706
aS'      template <typename VectorType>'
p30707
aS'      void vmult(VectorType &dst, const VectorType &src) const;'
p30708
aS'    private:'
p30709
aS'      const SmartPointer<const Matrix> matrix;'
p30710
aS'      const Preconditioner &           preconditioner;'
p30711
aS'    };'
p30712
aS'    template <class Matrix, class Preconditioner>'
p30713
aS'    InverseMatrix<Matrix, Preconditioner>::InverseMatrix('
p30714
aS'      const Matrix &        m,'
p30715
aS'      const Preconditioner &preconditioner)'
p30716
aS'      : matrix(&m)'
p30717
aS'      , preconditioner(preconditioner)'
p30718
aS'    {}'
p30719
aS'    template <class Matrix, class Preconditioner>'
p30720
aS'    template <typename VectorType>'
p30721
aS'    void'
p30722
aS'    InverseMatrix<Matrix, Preconditioner>::vmult(VectorType &      dst,'
p30723
aS'                                                 const VectorType &src) const'
p30724
aS'    {'
p30725
aS'      SolverControl solver_control(src.size(), 1e-8 * src.l2_norm());'
p30726
aS'      SolverCG<LA::MPI::Vector> cg(solver_control);'
p30727
aS'      dst = 0;'
p30728
aS'      try'
p30729
aS'        {'
p30730
aS'          cg.solve(*matrix, dst, src, preconditioner);'
p30731
aS'        }'
p30732
aS'      catch (std::exception &e)'
p30733
aS'        {'
p30734
aS'          Assert(false, ExcMessage(e.what()));'
p30735
aS'        }'
p30736
aS'    }'
p30737
aS'    template <class PreconditionerA, class PreconditionerS>'
p30738
aS'    class BlockDiagonalPreconditioner : public Subscriptor'
p30739
aS'    {'
p30740
aS'    public:'
p30741
aS'      BlockDiagonalPreconditioner(const PreconditionerA &preconditioner_A,'
p30742
aS'                                  const PreconditionerS &preconditioner_S);'
p30743
aS'      void vmult(LA::MPI::BlockVector &      dst,'
p30744
aS'                 const LA::MPI::BlockVector &src) const;'
p30745
aS'    private:'
p30746
aS'      const PreconditionerA &preconditioner_A;'
p30747
aS'      const PreconditionerS &preconditioner_S;'
p30748
aS'    };'
p30749
aS'    template <class PreconditionerA, class PreconditionerS>'
p30750
aS'    BlockDiagonalPreconditioner<PreconditionerA, PreconditionerS>::'
p30751
aS'      BlockDiagonalPreconditioner(const PreconditionerA &preconditioner_A,'
p30752
aS'                                  const PreconditionerS &preconditioner_S)'
p30753
aS'      : preconditioner_A(preconditioner_A)'
p30754
aS'      , preconditioner_S(preconditioner_S)'
p30755
aS'    {}'
p30756
aS'    template <class PreconditionerA, class PreconditionerS>'
p30757
aS'    void BlockDiagonalPreconditioner<PreconditionerA, PreconditionerS>::vmult('
p30758
aS'      LA::MPI::BlockVector &      dst,'
p30759
aS'      const LA::MPI::BlockVector &src) const'
p30760
aS'    {'
p30761
aS'      preconditioner_A.vmult(dst.block(0), src.block(0));'
p30762
aS'      preconditioner_S.vmult(dst.block(1), src.block(1));'
p30763
aS'    }'
p30764
aS'  } // namespace LinearSolvers'
p30765
aS'  template <int dim>'
p30766
aS'  class RightHandSide : public Function<dim>'
p30767
aS'  {'
p30768
aS'  public:'
p30769
aS'    RightHandSide()'
p30770
aS'      : Function<dim>(dim + 1)'
p30771
aS'    {}'
p30772
aS'    virtual void vector_value(const Point<dim> &p,'
p30773
aS'                              Vector<double> &  value) const override;'
p30774
aS'  };'
p30775
aS'  template <int dim>'
p30776
aS'  void RightHandSide<dim>::vector_value(const Point<dim> &p,'
p30777
aS'                                        Vector<double> &  values) const'
p30778
aS'  {'
p30779
aS'    const double R_x = p[0];'
p30780
aS'    const double R_y = p[1];'
p30781
aS'    const double pi  = numbers::PI;'
p30782
aS'    const double pi2 = pi * pi;'
p30783
aS'    values[0] ='
p30784
aS'      -1.0L / 2.0L * (-2 * sqrt(25.0 + 4 * pi2) + 10.0) *'
p30785
aS'        exp(R_x * (-2 * sqrt(25.0 + 4 * pi2) + 10.0)) -'
p30786
aS'      0.4 * pi2 * exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi) +'
p30787
aS'      0.1 * pow(-sqrt(25.0 + 4 * pi2) + 5.0, 2) *'
p30788
aS'        exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi);'
p30789
aS'    values[1] = 0.2 * pi * (-sqrt(25.0 + 4 * pi2) + 5.0) *'
p30790
aS'                  exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) -'
p30791
aS'                0.05 * pow(-sqrt(25.0 + 4 * pi2) + 5.0, 3) *'
p30792
aS'                  exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) /'
p30793
aS'                  pi;'
p30794
aS'    values[2] = 0;'
p30795
aS'  }'
p30796
aS'  template <int dim>'
p30797
aS'  class ExactSolution : public Function<dim>'
p30798
aS'  {'
p30799
aS'  public:'
p30800
aS'    ExactSolution()'
p30801
aS'      : Function<dim>(dim + 1)'
p30802
aS'    {}'
p30803
aS'    virtual void vector_value(const Point<dim> &p,'
p30804
aS'                              Vector<double> &  value) const override;'
p30805
aS'  };'
p30806
aS'  template <int dim>'
p30807
aS'  void ExactSolution<dim>::vector_value(const Point<dim> &p,'
p30808
aS'                                        Vector<double> &  values) const'
p30809
aS'  {'
p30810
aS'    const double R_x = p[0];'
p30811
aS'    const double R_y = p[1];'
p30812
aS'    const double pi  = numbers::PI;'
p30813
aS'    const double pi2 = pi * pi;'
p30814
aS'    values[0] ='
p30815
aS'      -exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi) + 1;'
p30816
aS'    values[1] = (1.0L / 2.0L) * (-sqrt(25.0 + 4 * pi2) + 5.0) *'
p30817
aS'                exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) /'
p30818
aS'                pi;'
p30819
aS'    values[2] ='
p30820
aS'      -1.0L / 2.0L * exp(R_x * (-2 * sqrt(25.0 + 4 * pi2) + 10.0)) -'
p30821
aS'      2.0 *'
p30822
aS'        (-6538034.74494422 +'
p30823
aS'         0.0134758939981709 * exp(4 * sqrt(25.0 + 4 * pi2))) /'
p30824
aS'        (-80.0 * exp(3 * sqrt(25.0 + 4 * pi2)) +'
p30825
aS'         16.0 * sqrt(25.0 + 4 * pi2) * exp(3 * sqrt(25.0 + 4 * pi2))) -'
p30826
aS'      1634508.68623606 * exp(-3.0 * sqrt(25.0 + 4 * pi2)) /'
p30827
aS'        (-10.0 + 2.0 * sqrt(25.0 + 4 * pi2)) +'
p30828
aS'      (-0.00673794699908547 * exp(sqrt(25.0 + 4 * pi2)) +'
p30829
aS'       3269017.37247211 * exp(-3 * sqrt(25.0 + 4 * pi2))) /'
p30830
aS'        (-8 * sqrt(25.0 + 4 * pi2) + 40.0) +'
p30831
aS'      0.00336897349954273 * exp(1.0 * sqrt(25.0 + 4 * pi2)) /'
p30832
aS'        (-10.0 + 2.0 * sqrt(25.0 + 4 * pi2));'
p30833
aS'  }'
p30834
aS'  template <int dim>'
p30835
aS'  class StokesProblem'
p30836
aS'  {'
p30837
aS'  public:'
p30838
aS'    StokesProblem(unsigned int velocity_degree);'
p30839
aS'    void run();'
p30840
aS'  private:'
p30841
aS'    void make_grid();'
p30842
aS'    void setup_system();'
p30843
aS'    void assemble_system();'
p30844
aS'    void solve();'
p30845
aS'    void refine_grid();'
p30846
aS'    void output_results(const unsigned int cycle) const;'
p30847
aS'    unsigned int velocity_degree;'
p30848
aS'    double       viscosity;'
p30849
aS'    MPI_Comm     mpi_communicator;'
p30850
aS'    FESystem<dim>                             fe;'
p30851
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p30852
aS'    DoFHandler<dim>                           dof_handler;'
p30853
aS'    std::vector<IndexSet> owned_partitioning;'
p30854
aS'    std::vector<IndexSet> relevant_partitioning;'
p30855
aS'    AffineConstraints<double> constraints;'
p30856
aS'    LA::MPI::BlockSparseMatrix system_matrix;'
p30857
aS'    LA::MPI::BlockSparseMatrix preconditioner_matrix;'
p30858
aS'    LA::MPI::BlockVector       locally_relevant_solution;'
p30859
aS'    LA::MPI::BlockVector       system_rhs;'
p30860
aS'    ConditionalOStream pcout;'
p30861
aS'    TimerOutput        computing_timer;'
p30862
aS'  };'
p30863
aS'  template <int dim>'
p30864
aS'  StokesProblem<dim>::StokesProblem(unsigned int velocity_degree)'
p30865
aS'    : velocity_degree(velocity_degree)'
p30866
aS'    , viscosity(0.1)'
p30867
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p30868
aS'    , fe(FE_Q<dim>(velocity_degree), dim, FE_Q<dim>(velocity_degree - 1), 1)'
p30869
aS'    , triangulation(mpi_communicator,'
p30870
aS'                    typename Triangulation<dim>::MeshSmoothing('
p30871
aS'                      Triangulation<dim>::smoothing_on_refinement |'
p30872
aS'                      Triangulation<dim>::smoothing_on_coarsening))'
p30873
aS'    , dof_handler(triangulation)'
p30874
aS'    , pcout(std::cout,'
p30875
aS'            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p30876
aS'    , computing_timer(mpi_communicator,'
p30877
aS'                      pcout,'
p30878
aS'                      TimerOutput::summary,'
p30879
aS'                      TimerOutput::wall_times)'
p30880
aS'  {}'
p30881
aS'  template <int dim>'
p30882
aS'  void StokesProblem<dim>::make_grid()'
p30883
aS'  {'
p30884
aS'    GridGenerator::hyper_cube(triangulation, -0.5, 1.5);'
p30885
aS'    triangulation.refine_global(3);'
p30886
aS'  }'
p30887
aS'  template <int dim>'
p30888
aS'  void StokesProblem<dim>::setup_system()'
p30889
aS'  {'
p30890
aS'    TimerOutput::Scope t(computing_timer, "setup");'
p30891
aS'    dof_handler.distribute_dofs(fe);'
p30892
aS'    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0);'
p30893
aS'    stokes_sub_blocks[dim] = 1;'
p30894
aS'    DoFRenumbering::component_wise(dof_handler, stokes_sub_blocks);'
p30895
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p30896
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, stokes_sub_blocks);'
p30897
aS'    const unsigned int n_u = dofs_per_block[0];'
p30898
aS'    const unsigned int n_p = dofs_per_block[1];'
p30899
aS'    pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs() << " ("'
p30900
aS"          << n_u << '+' << n_p << ')' << std::endl;"
p30901
aS'    owned_partitioning.resize(2);'
p30902
aS'    owned_partitioning[0] = dof_handler.locally_owned_dofs().get_view(0, n_u);'
p30903
aS'    owned_partitioning[1] ='
p30904
aS'      dof_handler.locally_owned_dofs().get_view(n_u, n_u + n_p);'
p30905
aS'    IndexSet locally_relevant_dofs;'
p30906
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p30907
aS'    relevant_partitioning.resize(2);'
p30908
aS'    relevant_partitioning[0] = locally_relevant_dofs.get_view(0, n_u);'
p30909
aS'    relevant_partitioning[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);'
p30910
aS'    {'
p30911
aS'      constraints.reinit(locally_relevant_dofs);'
p30912
aS'      FEValuesExtractors::Vector velocities(0);'
p30913
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p30914
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p30915
aS'                                               0,'
p30916
aS'                                               ExactSolution<dim>(),'
p30917
aS'                                               constraints,'
p30918
aS'                                               fe.component_mask(velocities));'
p30919
aS'      constraints.close();'
p30920
aS'    }'
p30921
aS'    {'
p30922
aS'      system_matrix.clear();'
p30923
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p30924
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p30925
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p30926
aS'          if (c == dim && d == dim)'
p30927
aS'            coupling[c][d] = DoFTools::none;'
p30928
aS'          else if (c == dim || d == dim || c == d)'
p30929
aS'            coupling[c][d] = DoFTools::always;'
p30930
aS'          else'
p30931
aS'            coupling[c][d] = DoFTools::none;'
p30932
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p30933
aS'      DoFTools::make_sparsity_pattern('
p30934
aS'        dof_handler, coupling, dsp, constraints, false);'
p30935
aS'      SparsityTools::distribute_sparsity_pattern('
p30936
aS'        dsp,'
p30937
aS'        dof_handler.locally_owned_dofs(),'
p30938
aS'        mpi_communicator,'
p30939
aS'        locally_relevant_dofs);'
p30940
aS'      system_matrix.reinit(owned_partitioning, dsp, mpi_communicator);'
p30941
aS'    }'
p30942
aS'    {'
p30943
aS'      preconditioner_matrix.clear();'
p30944
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p30945
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p30946
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p30947
aS'          if (c == dim && d == dim)'
p30948
aS'            coupling[c][d] = DoFTools::always;'
p30949
aS'          else'
p30950
aS'            coupling[c][d] = DoFTools::none;'
p30951
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p30952
aS'      DoFTools::make_sparsity_pattern('
p30953
aS'        dof_handler, coupling, dsp, constraints, false);'
p30954
aS'      SparsityTools::distribute_sparsity_pattern('
p30955
aS'        dsp,'
p30956
aS'        Utilities::MPI::all_gather(mpi_communicator,'
p30957
aS'                                   dof_handler.locally_owned_dofs()),'
p30958
aS'        mpi_communicator,'
p30959
aS'        locally_relevant_dofs);'
p30960
aS'      preconditioner_matrix.reinit(owned_partitioning,'
p30961
aS'                                   dsp,'
p30962
aS'                                   mpi_communicator);'
p30963
aS'    }'
p30964
aS'    locally_relevant_solution.reinit(owned_partitioning,'
p30965
aS'                                     relevant_partitioning,'
p30966
aS'                                     mpi_communicator);'
p30967
aS'    system_rhs.reinit(owned_partitioning, mpi_communicator);'
p30968
aS'  }'
p30969
aS'  template <int dim>'
p30970
aS'  void StokesProblem<dim>::assemble_system()'
p30971
aS'  {'
p30972
aS'    TimerOutput::Scope t(computing_timer, "assembly");'
p30973
aS'    system_matrix         = 0;'
p30974
aS'    preconditioner_matrix = 0;'
p30975
aS'    system_rhs            = 0;'
p30976
aS'    const QGauss<dim> quadrature_formula(velocity_degree + 1);'
p30977
aS'    FEValues<dim> fe_values(fe,'
p30978
aS'                            quadrature_formula,'
p30979
aS'                            update_values | update_gradients |'
p30980
aS'                              update_quadrature_points | update_JxW_values);'
p30981
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p30982
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p30983
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p30984
aS'    FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell);'
p30985
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p30986
aS'    const RightHandSide<dim>    right_hand_side;'
p30987
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p30988
aS'    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);'
p30989
aS'    std::vector<double>         div_phi_u(dofs_per_cell);'
p30990
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p30991
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p30992
aS'    const FEValuesExtractors::Vector     velocities(0);'
p30993
aS'    const FEValuesExtractors::Scalar     pressure(dim);'
p30994
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p30995
aS'      if (cell->is_locally_owned())'
p30996
aS'        {'
p30997
aS'          cell_matrix  = 0;'
p30998
aS'          cell_matrix2 = 0;'
p30999
aS'          cell_rhs     = 0;'
p31000
aS'          fe_values.reinit(cell);'
p31001
aS'          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p31002
aS'                                            rhs_values);'
p31003
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p31004
aS'            {'
p31005
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p31006
aS'                {'
p31007
aS'                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);'
p31008
aS'                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);'
p31009
aS'                  phi_p[k]      = fe_values[pressure].value(k, q);'
p31010
aS'                }'
p31011
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p31012
aS'                {'
p31013
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p31014
aS'                    {'
p31015
aS'                      cell_matrix(i, j) +='
p31016
aS'                        (viscosity *'
p31017
aS'                           scalar_product(grad_phi_u[i], grad_phi_u[j]) -'
p31018
aS'                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p31019
aS'                        fe_values.JxW(q);'
p31020
aS'                      cell_matrix2(i, j) += 1.0 / viscosity * phi_p[i] *'
p31021
aS'                                            phi_p[j] * fe_values.JxW(q);'
p31022
aS'                    }'
p31023
aS'                  const unsigned int component_i ='
p31024
aS'                    fe.system_to_component_index(i).first;'
p31025
aS'                  cell_rhs(i) += fe_values.shape_value(i, q) *'
p31026
aS'                                 rhs_values[q](component_i) * fe_values.JxW(q);'
p31027
aS'                }'
p31028
aS'            }'
p31029
aS'          cell->get_dof_indices(local_dof_indices);'
p31030
aS'          constraints.distribute_local_to_global(cell_matrix,'
p31031
aS'                                                 cell_rhs,'
p31032
aS'                                                 local_dof_indices,'
p31033
aS'                                                 system_matrix,'
p31034
aS'                                                 system_rhs);'
p31035
aS'          constraints.distribute_local_to_global(cell_matrix2,'
p31036
aS'                                                 local_dof_indices,'
p31037
aS'                                                 preconditioner_matrix);'
p31038
aS'        }'
p31039
aS'    system_matrix.compress(VectorOperation::add);'
p31040
aS'    preconditioner_matrix.compress(VectorOperation::add);'
p31041
aS'    system_rhs.compress(VectorOperation::add);'
p31042
aS'  }'
p31043
aS'  template <int dim>'
p31044
aS'  void StokesProblem<dim>::solve()'
p31045
aS'  {'
p31046
aS'    TimerOutput::Scope t(computing_timer, "solve");'
p31047
aS'    LA::MPI::PreconditionAMG prec_A;'
p31048
aS'    {'
p31049
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p31050
aS'#ifdef USE_PETSC_LA'
p31051
aS'      data.symmetric_operator = true;'
p31052
aS'#endif'
p31053
aS'      prec_A.initialize(system_matrix.block(0, 0), data);'
p31054
aS'    }'
p31055
aS'    LA::MPI::PreconditionAMG prec_S;'
p31056
aS'    {'
p31057
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p31058
aS'#ifdef USE_PETSC_LA'
p31059
aS'      data.symmetric_operator = true;'
p31060
aS'#endif'
p31061
aS'      prec_S.initialize(preconditioner_matrix.block(1, 1), data);'
p31062
aS'    }'
p31063
aS'    using mp_inverse_t = LinearSolvers::InverseMatrix<LA::MPI::SparseMatrix,'
p31064
aS'                                                      LA::MPI::PreconditionAMG>;'
p31065
aS'    const mp_inverse_t mp_inverse(preconditioner_matrix.block(1, 1), prec_S);'
p31066
aS'    const LinearSolvers::BlockDiagonalPreconditioner<LA::MPI::PreconditionAMG,'
p31067
aS'                                                     mp_inverse_t>'
p31068
aS'      preconditioner(prec_A, mp_inverse);'
p31069
aS'    SolverControl solver_control(system_matrix.m(),'
p31070
aS'                                 1e-10 * system_rhs.l2_norm());'
p31071
aS'    SolverMinRes<LA::MPI::BlockVector> solver(solver_control);'
p31072
aS'    LA::MPI::BlockVector distributed_solution(owned_partitioning,'
p31073
aS'                                              mpi_communicator);'
p31074
aS'    constraints.set_zero(distributed_solution);'
p31075
aS'    solver.solve(system_matrix,'
p31076
aS'                 distributed_solution,'
p31077
aS'                 system_rhs,'
p31078
aS'                 preconditioner);'
p31079
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p31080
aS'          << std::endl;'
p31081
aS'    constraints.distribute(distributed_solution);'
p31082
aS'    locally_relevant_solution = distributed_solution;'
p31083
aS'    const double mean_pressure ='
p31084
aS'      VectorTools::compute_mean_value(dof_handler,'
p31085
aS'                                      QGauss<dim>(velocity_degree + 2),'
p31086
aS'                                      locally_relevant_solution,'
p31087
aS'                                      dim);'
p31088
aS'    distributed_solution.block(1).add(-mean_pressure);'
p31089
aS'    locally_relevant_solution.block(1) = distributed_solution.block(1);'
p31090
aS'  }'
p31091
aS'  template <int dim>'
p31092
aS'  void StokesProblem<dim>::refine_grid()'
p31093
aS'  {'
p31094
aS'    TimerOutput::Scope t(computing_timer, "refine");'
p31095
aS'    triangulation.refine_global();'
p31096
aS'  }'
p31097
aS'  template <int dim>'
p31098
aS'  void StokesProblem<dim>::output_results(const unsigned int cycle) const'
p31099
aS'  {'
p31100
aS'    {'
p31101
aS'      const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);'
p31102
aS'      const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),'
p31103
aS'                                                       dim + 1);'
p31104
aS'      Vector<double> cellwise_errors(triangulation.n_active_cells());'
p31105
aS'      QGauss<dim>    quadrature(velocity_degree + 2);'
p31106
aS'      VectorTools::integrate_difference(dof_handler,'
p31107
aS'                                        locally_relevant_solution,'
p31108
aS'                                        ExactSolution<dim>(),'
p31109
aS'                                        cellwise_errors,'
p31110
aS'                                        quadrature,'
p31111
aS'                                        VectorTools::L2_norm,'
p31112
aS'                                        &velocity_mask);'
p31113
aS'      const double error_u_l2 ='
p31114
aS'        VectorTools::compute_global_error(triangulation,'
p31115
aS'                                          cellwise_errors,'
p31116
aS'                                          VectorTools::L2_norm);'
p31117
aS'      VectorTools::integrate_difference(dof_handler,'
p31118
aS'                                        locally_relevant_solution,'
p31119
aS'                                        ExactSolution<dim>(),'
p31120
aS'                                        cellwise_errors,'
p31121
aS'                                        quadrature,'
p31122
aS'                                        VectorTools::L2_norm,'
p31123
aS'                                        &pressure_mask);'
p31124
aS'      const double error_p_l2 ='
p31125
aS'        VectorTools::compute_global_error(triangulation,'
p31126
aS'                                          cellwise_errors,'
p31127
aS'                                          VectorTools::L2_norm);'
p31128
aS'      pcout << "error: u_0: " << error_u_l2 << " p_0: " << error_p_l2'
p31129
aS'            << std::endl;'
p31130
aS'    }'
p31131
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p31132
aS'    solution_names.emplace_back("pressure");'
p31133
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p31134
aS'      data_component_interpretation('
p31135
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p31136
aS'    data_component_interpretation.push_back('
p31137
aS'      DataComponentInterpretation::component_is_scalar);'
p31138
aS'    DataOut<dim> data_out;'
p31139
aS'    data_out.attach_dof_handler(dof_handler);'
p31140
aS'    data_out.add_data_vector(locally_relevant_solution,'
p31141
aS'                             solution_names,'
p31142
aS'                             DataOut<dim>::type_dof_data,'
p31143
aS'                             data_component_interpretation);'
p31144
aS'    LA::MPI::BlockVector interpolated;'
p31145
aS'    interpolated.reinit(owned_partitioning, MPI_COMM_WORLD);'
p31146
aS'    VectorTools::interpolate(dof_handler, ExactSolution<dim>(), interpolated);'
p31147
aS'    LA::MPI::BlockVector interpolated_relevant(owned_partitioning,'
p31148
aS'                                               relevant_partitioning,'
p31149
aS'                                               MPI_COMM_WORLD);'
p31150
aS'    interpolated_relevant = interpolated;'
p31151
aS'    {'
p31152
aS'      std::vector<std::string> solution_names(dim, "ref_u");'
p31153
aS'      solution_names.emplace_back("ref_p");'
p31154
aS'      data_out.add_data_vector(interpolated_relevant,'
p31155
aS'                               solution_names,'
p31156
aS'                               DataOut<dim>::type_dof_data,'
p31157
aS'                               data_component_interpretation);'
p31158
aS'    }'
p31159
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p31160
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p31161
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p31162
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p31163
aS'    data_out.build_patches();'
p31164
aS'    data_out.write_vtu_with_pvtu_record('
p31165
aS'      "./", "solution", cycle, mpi_communicator, 2);'
p31166
aS'  }'
p31167
aS'  template <int dim>'
p31168
aS'  void StokesProblem<dim>::run()'
p31169
aS'  {'
p31170
aS'#ifdef USE_PETSC_LA'
p31171
aS'    pcout << "Running using PETSc." << std::endl;'
p31172
aS'#else'
p31173
aS'    pcout << "Running using Trilinos." << std::endl;'
p31174
aS'#endif'
p31175
aS'    const unsigned int n_cycles = 5;'
p31176
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p31177
aS'      {'
p31178
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p31179
aS'        if (cycle == 0)'
p31180
aS'          make_grid();'
p31181
aS'        else'
p31182
aS'          refine_grid();'
p31183
aS'        setup_system();'
p31184
aS'        assemble_system();'
p31185
aS'        solve();'
p31186
aS'        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32)'
p31187
aS'          {'
p31188
aS'            TimerOutput::Scope t(computing_timer, "output");'
p31189
aS'            output_results(cycle);'
p31190
aS'          }'
p31191
aS'        computing_timer.print_summary();'
p31192
aS'        computing_timer.reset();'
p31193
aS'        pcout << std::endl;'
p31194
aS'      }'
p31195
aS'  }'
p31196
aS'} // namespace Step55'
p31197
aS'int main(int argc, char *argv[])'
p31198
ag24
aS'  try'
p31199
aS'    {'
p31200
aS'      using namespace dealii;'
p31201
aS'      using namespace Step55;'
p31202
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p31203
aS'      StokesProblem<2> problem(2);'
p31204
aS'      problem.run();'
p31205
aS'    }'
p31206
aS'  catch (std::exception &exc)'
p31207
aS'    {'
p31208
aS'      std::cerr << std::endl'
p31209
aS'                << std::endl'
p31210
aS'                << "----------------------------------------------------"'
p31211
aS'                << std::endl;'
p31212
aS'      std::cerr << "Exception on processing: " << std::endl'
p31213
aS'                << exc.what() << std::endl'
p31214
aS'                << "Aborting!" << std::endl'
p31215
aS'                << "----------------------------------------------------"'
p31216
aS'                << std::endl;'
p31217
aS'      return 1;'
p31218
aS'    }'
p31219
aS'  catch (...)'
p31220
aS'    {'
p31221
aS'      std::cerr << std::endl'
p31222
aS'                << std::endl'
p31223
aS'                << "----------------------------------------------------"'
p31224
aS'                << std::endl;'
p31225
aS'      std::cerr << "Unknown exception!" << std::endl'
p31226
aS'                << "Aborting!" << std::endl'
p31227
aS'                << "----------------------------------------------------"'
p31228
aS'                << std::endl;'
p31229
aS'      return 1;'
p31230
aS'    }'
p31231
aS'  return 0;'
p31232
ag32
aS'/* ---------------------------------------------------------------------'
p31233
aS' *'
p31234
aS' * Copyright (C) 2016 - 2021 by the deal.II authors'
p31235
aS' *'
p31236
aS' * This file is part of the deal.II library.'
p31237
aS' *'
p31238
aS' * The deal.II library is free software; you can use it, redistribute'
p31239
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p31240
aS' * Public License as published by the Free Software Foundation; either'
p31241
aS' * version 2.1 of the License, or (at your option) any later version.'
p31242
aS' * The full text of the license can be found in the file LICENSE.md at'
p31243
aS' * the top level directory of deal.II.'
p31244
aS' *'
p31245
aS' * ---------------------------------------------------------------------'
p31246
aS' * Author: Ryan Grove, Clemson University'
p31247
aS' *         Timo Heister, Clemson University'
p31248
aS' */'
p31249
aS'#include <deal.II/base/quadrature_lib.h>'
p31250
aS'#include <deal.II/base/logstream.h>'
p31251
aS'#include <deal.II/base/function.h>'
p31252
aS'#include <deal.II/base/utilities.h>'
p31253
aS'#include <deal.II/lac/block_vector.h>'
p31254
aS'#include <deal.II/lac/full_matrix.h>'
p31255
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p31256
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p31257
aS'#include <deal.II/lac/solver_cg.h>'
p31258
aS'#include <deal.II/lac/precondition.h>'
p31259
aS'#include <deal.II/lac/affine_constraints.h>'
p31260
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p31261
aS'#include <deal.II/lac/solver_gmres.h>'
p31262
aS'#include <deal.II/grid/tria.h>'
p31263
aS'#include <deal.II/grid/grid_generator.h>'
p31264
aS'#include <deal.II/grid/grid_tools.h>'
p31265
aS'#include <deal.II/grid/grid_refinement.h>'
p31266
aS'#include <deal.II/dofs/dof_handler.h>'
p31267
aS'#include <deal.II/dofs/dof_renumbering.h>'
p31268
aS'#include <deal.II/dofs/dof_tools.h>'
p31269
aS'#include <deal.II/fe/fe_q.h>'
p31270
aS'#include <deal.II/fe/fe_system.h>'
p31271
aS'#include <deal.II/fe/fe_values.h>'
p31272
aS'#include <deal.II/numerics/vector_tools.h>'
p31273
aS'#include <deal.II/numerics/matrix_tools.h>'
p31274
aS'#include <deal.II/numerics/data_out.h>'
p31275
aS'#include <deal.II/numerics/error_estimator.h>'
p31276
aS'#include <deal.II/lac/sparse_direct.h>'
p31277
aS'#include <deal.II/lac/sparse_ilu.h>'
p31278
aS'#include <deal.II/grid/grid_out.h>'
p31279
aS'#include <deal.II/base/timer.h>'
p31280
aS'#include <deal.II/multigrid/multigrid.h>'
p31281
aS'#include <deal.II/multigrid/mg_transfer.h>'
p31282
aS'#include <deal.II/multigrid/mg_tools.h>'
p31283
aS'#include <deal.II/multigrid/mg_coarse.h>'
p31284
aS'#include <deal.II/multigrid/mg_smoother.h>'
p31285
aS'#include <deal.II/multigrid/mg_matrix.h>'
p31286
aS'#include <iostream>'
p31287
aS'#include <fstream>'
p31288
aS'namespace Step56'
p31289
ag24
aS'  using namespace dealii;'
p31290
aS'  enum class SolverType'
p31291
aS'  {'
p31292
aS'    FGMRES_ILU,'
p31293
aS'    FGMRES_GMG,'
p31294
aS'    UMFPACK'
p31295
aS'  };'
p31296
aS'  template <int dim>'
p31297
aS'  class Solution : public Function<dim>'
p31298
aS'  {'
p31299
aS'  public:'
p31300
aS'    Solution()'
p31301
aS'      : Function<dim>(dim + 1)'
p31302
aS'    {}'
p31303
aS'    virtual double value(const Point<dim> & p,'
p31304
aS'                         const unsigned int component = 0) const override;'
p31305
aS'    virtual Tensor<1, dim>'
p31306
aS'    gradient(const Point<dim> & p,'
p31307
aS'             const unsigned int component = 0) const override;'
p31308
aS'  };'
p31309
aS'  template <>'
p31310
aS'  double Solution<2>::value(const Point<2> &   p,'
p31311
aS'                            const unsigned int component) const'
p31312
aS'  {'
p31313
aS'    Assert(component <= 2 + 1, ExcIndexRange(component, 0, 2 + 1));'
p31314
aS'    using numbers::PI;'
p31315
aS'    const double x = p(0);'
p31316
aS'    const double y = p(1);'
p31317
aS'    if (component == 0)'
p31318
aS'      return sin(PI * x);'
p31319
aS'    if (component == 1)'
p31320
aS'      return -PI * y * cos(PI * x);'
p31321
aS'    if (component == 2)'
p31322
aS'      return sin(PI * x) * cos(PI * y);'
p31323
aS'    return 0;'
p31324
aS'  }'
p31325
aS'  template <>'
p31326
aS'  double Solution<3>::value(const Point<3> &   p,'
p31327
aS'                            const unsigned int component) const'
p31328
aS'  {'
p31329
aS'    Assert(component <= 3 + 1, ExcIndexRange(component, 0, 3 + 1));'
p31330
aS'    using numbers::PI;'
p31331
aS'    const double x = p(0);'
p31332
aS'    const double y = p(1);'
p31333
aS'    const double z = p(2);'
p31334
aS'    if (component == 0)'
p31335
aS'      return 2.0 * sin(PI * x);'
p31336
aS'    if (component == 1)'
p31337
aS'      return -PI * y * cos(PI * x);'
p31338
aS'    if (component == 2)'
p31339
aS'      return -PI * z * cos(PI * x);'
p31340
aS'    if (component == 3)'
p31341
aS'      return sin(PI * x) * cos(PI * y) * sin(PI * z);'
p31342
aS'    return 0;'
p31343
aS'  }'
p31344
aS'  template <>'
p31345
aS'  Tensor<1, 2> Solution<2>::gradient(const Point<2> &   p,'
p31346
aS'                                     const unsigned int component) const'
p31347
aS'  {'
p31348
aS'    Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));'
p31349
aS'    using numbers::PI;'
p31350
aS'    const double x = p(0);'
p31351
aS'    const double y = p(1);'
p31352
aS'    Tensor<1, 2> return_value;'
p31353
aS'    if (component == 0)'
p31354
aS'      {'
p31355
aS'        return_value[0] = PI * cos(PI * x);'
p31356
aS'        return_value[1] = 0.0;'
p31357
aS'      }'
p31358
aS'    else if (component == 1)'
p31359
aS'      {'
p31360
aS'        return_value[0] = y * PI * PI * sin(PI * x);'
p31361
aS'        return_value[1] = -PI * cos(PI * x);'
p31362
aS'      }'
p31363
aS'    else if (component == 2)'
p31364
aS'      {'
p31365
aS'        return_value[0] = PI * cos(PI * x) * cos(PI * y);'
p31366
aS'        return_value[1] = -PI * sin(PI * x) * sin(PI * y);'
p31367
aS'      }'
p31368
aS'    return return_value;'
p31369
aS'  }'
p31370
aS'  template <>'
p31371
aS'  Tensor<1, 3> Solution<3>::gradient(const Point<3> &   p,'
p31372
aS'                                     const unsigned int component) const'
p31373
aS'  {'
p31374
aS'    Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));'
p31375
aS'    using numbers::PI;'
p31376
aS'    const double x = p(0);'
p31377
aS'    const double y = p(1);'
p31378
aS'    const double z = p(2);'
p31379
aS'    Tensor<1, 3> return_value;'
p31380
aS'    if (component == 0)'
p31381
aS'      {'
p31382
aS'        return_value[0] = 2 * PI * cos(PI * x);'
p31383
aS'        return_value[1] = 0.0;'
p31384
aS'        return_value[2] = 0.0;'
p31385
aS'      }'
p31386
aS'    else if (component == 1)'
p31387
aS'      {'
p31388
aS'        return_value[0] = y * PI * PI * sin(PI * x);'
p31389
aS'        return_value[1] = -PI * cos(PI * x);'
p31390
aS'        return_value[2] = 0.0;'
p31391
aS'      }'
p31392
aS'    else if (component == 2)'
p31393
aS'      {'
p31394
aS'        return_value[0] = z * PI * PI * sin(PI * x);'
p31395
aS'        return_value[1] = 0.0;'
p31396
aS'        return_value[2] = -PI * cos(PI * x);'
p31397
aS'      }'
p31398
aS'    else if (component == 3)'
p31399
aS'      {'
p31400
aS'        return_value[0] = PI * cos(PI * x) * cos(PI * y) * sin(PI * z);'
p31401
aS'        return_value[1] = -PI * sin(PI * x) * sin(PI * y) * sin(PI * z);'
p31402
aS'        return_value[2] = PI * sin(PI * x) * cos(PI * y) * cos(PI * z);'
p31403
aS'      }'
p31404
aS'    return return_value;'
p31405
aS'  }'
p31406
aS'  template <int dim>'
p31407
aS'  class RightHandSide : public Function<dim>'
p31408
aS'  {'
p31409
aS'  public:'
p31410
aS'    RightHandSide()'
p31411
aS'      : Function<dim>(dim + 1)'
p31412
aS'    {}'
p31413
aS'    virtual double value(const Point<dim> & p,'
p31414
aS'                         const unsigned int component = 0) const override;'
p31415
aS'  };'
p31416
aS'  template <>'
p31417
aS'  double RightHandSide<2>::value(const Point<2> &   p,'
p31418
aS'                                 const unsigned int component) const'
p31419
aS'  {'
p31420
aS'    Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));'
p31421
aS'    using numbers::PI;'
p31422
aS'    double x = p(0);'
p31423
aS'    double y = p(1);'
p31424
aS'    if (component == 0)'
p31425
aS'      return PI * PI * sin(PI * x) + PI * cos(PI * x) * cos(PI * y);'
p31426
aS'    if (component == 1)'
p31427
aS'      return -PI * PI * PI * y * cos(PI * x) - PI * sin(PI * y) * sin(PI * x);'
p31428
aS'    if (component == 2)'
p31429
aS'      return 0;'
p31430
aS'    return 0;'
p31431
aS'  }'
p31432
aS'  template <>'
p31433
aS'  double RightHandSide<3>::value(const Point<3> &   p,'
p31434
aS'                                 const unsigned int component) const'
p31435
aS'  {'
p31436
aS'    Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));'
p31437
aS'    using numbers::PI;'
p31438
aS'    double x = p(0);'
p31439
aS'    double y = p(1);'
p31440
aS'    double z = p(2);'
p31441
aS'    if (component == 0)'
p31442
aS'      return 2 * PI * PI * sin(PI * x) +'
p31443
aS'             PI * cos(PI * x) * cos(PI * y) * sin(PI * z);'
p31444
aS'    if (component == 1)'
p31445
aS'      return -PI * PI * PI * y * cos(PI * x) +'
p31446
aS'             PI * (-1) * sin(PI * y) * sin(PI * x) * sin(PI * z);'
p31447
aS'    if (component == 2)'
p31448
aS'      return -PI * PI * PI * z * cos(PI * x) +'
p31449
aS'             PI * cos(PI * z) * sin(PI * x) * cos(PI * y);'
p31450
aS'    if (component == 3)'
p31451
aS'      return 0;'
p31452
aS'    return 0;'
p31453
aS'  }'
p31454
aS'  template <class PreconditionerAType, class PreconditionerSType>'
p31455
aS'  class BlockSchurPreconditioner : public Subscriptor'
p31456
aS'  {'
p31457
aS'  public:'
p31458
aS'    BlockSchurPreconditioner('
p31459
aS'      const BlockSparseMatrix<double> &system_matrix,'
p31460
aS'      const SparseMatrix<double> &     schur_complement_matrix,'
p31461
aS'      const PreconditionerAType &      preconditioner_A,'
p31462
aS'      const PreconditionerSType &      preconditioner_S,'
p31463
aS'      const bool                       do_solve_A);'
p31464
aS'    void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;'
p31465
aS'    mutable unsigned int n_iterations_A;'
p31466
aS'    mutable unsigned int n_iterations_S;'
p31467
aS'  private:'
p31468
aS'    const BlockSparseMatrix<double> &system_matrix;'
p31469
aS'    const SparseMatrix<double> &     schur_complement_matrix;'
p31470
aS'    const PreconditionerAType &      preconditioner_A;'
p31471
aS'    const PreconditionerSType &      preconditioner_S;'
p31472
aS'    const bool do_solve_A;'
p31473
aS'  };'
p31474
aS'  template <class PreconditionerAType, class PreconditionerSType>'
p31475
aS'  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::'
p31476
aS'    BlockSchurPreconditioner('
p31477
aS'      const BlockSparseMatrix<double> &system_matrix,'
p31478
aS'      const SparseMatrix<double> &     schur_complement_matrix,'
p31479
aS'      const PreconditionerAType &      preconditioner_A,'
p31480
aS'      const PreconditionerSType &      preconditioner_S,'
p31481
aS'      const bool                       do_solve_A)'
p31482
aS'    : n_iterations_A(0)'
p31483
aS'    , n_iterations_S(0)'
p31484
aS'    , system_matrix(system_matrix)'
p31485
aS'    , schur_complement_matrix(schur_complement_matrix)'
p31486
aS'    , preconditioner_A(preconditioner_A)'
p31487
aS'    , preconditioner_S(preconditioner_S)'
p31488
aS'    , do_solve_A(do_solve_A)'
p31489
aS'  {}'
p31490
aS'  template <class PreconditionerAType, class PreconditionerSType>'
p31491
aS'  void'
p31492
aS'  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::vmult('
p31493
aS'    BlockVector<double> &      dst,'
p31494
aS'    const BlockVector<double> &src) const'
p31495
aS'  {'
p31496
aS'    Vector<double> utmp(src.block(0));'
p31497
aS'    {'
p31498
aS'      SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());'
p31499
aS'      SolverCG<Vector<double>> cg(solver_control);'
p31500
aS'      dst.block(1) = 0.0;'
p31501
aS'      cg.solve(schur_complement_matrix,'
p31502
aS'               dst.block(1),'
p31503
aS'               src.block(1),'
p31504
aS'               preconditioner_S);'
p31505
aS'      n_iterations_S += solver_control.last_step();'
p31506
aS'      dst.block(1) *= -1.0;'
p31507
aS'    }'
p31508
aS'    {'
p31509
aS'      system_matrix.block(0, 1).vmult(utmp, dst.block(1));'
p31510
aS'      utmp *= -1.0;'
p31511
aS'      utmp += src.block(0);'
p31512
aS'    }'
p31513
aS'    if (do_solve_A == true)'
p31514
aS'      {'
p31515
aS'        SolverControl            solver_control(10000, utmp.l2_norm() * 1e-4);'
p31516
aS'        SolverCG<Vector<double>> cg(solver_control);'
p31517
aS'        dst.block(0) = 0.0;'
p31518
aS'        cg.solve(system_matrix.block(0, 0),'
p31519
aS'                 dst.block(0),'
p31520
aS'                 utmp,'
p31521
aS'                 preconditioner_A);'
p31522
aS'        n_iterations_A += solver_control.last_step();'
p31523
aS'      }'
p31524
aS'    else'
p31525
aS'      {'
p31526
aS'        preconditioner_A.vmult(dst.block(0), utmp);'
p31527
aS'        n_iterations_A += 1;'
p31528
aS'      }'
p31529
aS'  }'
p31530
aS'  template <int dim>'
p31531
aS'  class StokesProblem'
p31532
aS'  {'
p31533
aS'  public:'
p31534
aS'    StokesProblem(const unsigned int pressure_degree,'
p31535
aS'                  const SolverType   solver_type);'
p31536
aS'    void run();'
p31537
aS'  private:'
p31538
aS'    void setup_dofs();'
p31539
aS'    void assemble_system();'
p31540
aS'    void assemble_multigrid();'
p31541
aS'    void solve();'
p31542
aS'    void compute_errors();'
p31543
aS'    void output_results(const unsigned int refinement_cycle) const;'
p31544
aS'    const unsigned int pressure_degree;'
p31545
aS'    const SolverType   solver_type;'
p31546
aS'    Triangulation<dim> triangulation;'
p31547
aS'    FESystem<dim>      velocity_fe;'
p31548
aS'    FESystem<dim>      fe;'
p31549
aS'    DoFHandler<dim>    dof_handler;'
p31550
aS'    DoFHandler<dim>    velocity_dof_handler;'
p31551
aS'    AffineConstraints<double> constraints;'
p31552
aS'    BlockSparsityPattern      sparsity_pattern;'
p31553
aS'    BlockSparseMatrix<double> system_matrix;'
p31554
aS'    SparseMatrix<double>      pressure_mass_matrix;'
p31555
aS'    BlockVector<double> solution;'
p31556
aS'    BlockVector<double> system_rhs;'
p31557
aS'    MGLevelObject<SparsityPattern>      mg_sparsity_patterns;'
p31558
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p31559
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_matrices;'
p31560
aS'    MGConstrainedDoFs                   mg_constrained_dofs;'
p31561
aS'    TimerOutput computing_timer;'
p31562
aS'  };'
p31563
aS'  template <int dim>'
p31564
aS'  StokesProblem<dim>::StokesProblem(const unsigned int pressure_degree,'
p31565
aS'                                    const SolverType   solver_type)'
p31566
aS'    : pressure_degree(pressure_degree)'
p31567
aS'    , solver_type(solver_type)'
p31568
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p31569
aS'    ,'
p31570
aS'    velocity_fe(FE_Q<dim>(pressure_degree + 1), dim)'
p31571
aS'    ,'
p31572
aS'    fe(velocity_fe, 1, FE_Q<dim>(pressure_degree), 1)'
p31573
aS'    , dof_handler(triangulation)'
p31574
aS'    , velocity_dof_handler(triangulation)'
p31575
aS'    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times)'
p31576
aS'  {}'
p31577
aS'  template <int dim>'
p31578
aS'  void StokesProblem<dim>::setup_dofs()'
p31579
aS'  {'
p31580
aS'    TimerOutput::Scope scope(computing_timer, "Setup");'
p31581
aS'    system_matrix.clear();'
p31582
aS'    pressure_mass_matrix.clear();'
p31583
aS'    dof_handler.distribute_dofs(fe);'
p31584
aS'    std::vector<unsigned int> block_component(2);'
p31585
aS'    block_component[0] = 0;'
p31586
aS'    block_component[1] = 1;'
p31587
aS'    const FEValuesExtractors::Vector velocities(0);'
p31588
aS'    if (solver_type == SolverType::FGMRES_ILU)'
p31589
aS'      {'
p31590
aS'        TimerOutput::Scope ilu_specific(computing_timer, "(ILU specific)");'
p31591
aS'        DoFRenumbering::Cuthill_McKee(dof_handler);'
p31592
aS'      }'
p31593
aS'    DoFRenumbering::block_wise(dof_handler);'
p31594
aS'    if (solver_type == SolverType::FGMRES_GMG)'
p31595
aS'      {'
p31596
aS'        TimerOutput::Scope multigrid_specific(computing_timer,'
p31597
aS'                                              "(Multigrid specific)");'
p31598
aS'        TimerOutput::Scope setup_multigrid(computing_timer,'
p31599
aS'                                           "Setup - Multigrid");'
p31600
aS'        velocity_dof_handler.distribute_dofs(velocity_fe);'
p31601
aS'        velocity_dof_handler.distribute_mg_dofs();'
p31602
aS'        std::set<types::boundary_id> zero_boundary_ids;'
p31603
aS'        zero_boundary_ids.insert(0);'
p31604
aS'        mg_constrained_dofs.clear();'
p31605
aS'        mg_constrained_dofs.initialize(velocity_dof_handler);'
p31606
aS'        mg_constrained_dofs.make_zero_boundary_constraints(velocity_dof_handler,'
p31607
aS'                                                           zero_boundary_ids);'
p31608
aS'        const unsigned int n_levels = triangulation.n_levels();'
p31609
aS'        mg_interface_matrices.resize(0, n_levels - 1);'
p31610
aS'        mg_matrices.resize(0, n_levels - 1);'
p31611
aS'        mg_sparsity_patterns.resize(0, n_levels - 1);'
p31612
aS'        for (unsigned int level = 0; level < n_levels; ++level)'
p31613
aS'          {'
p31614
aS'            DynamicSparsityPattern csp(velocity_dof_handler.n_dofs(level),'
p31615
aS'                                       velocity_dof_handler.n_dofs(level));'
p31616
aS'            MGTools::make_sparsity_pattern(velocity_dof_handler, csp, level);'
p31617
aS'            mg_sparsity_patterns[level].copy_from(csp);'
p31618
aS'            mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p31619
aS'            mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]);'
p31620
aS'          }'
p31621
aS'      }'
p31622
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p31623
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p31624
aS'    const unsigned int n_u = dofs_per_block[0];'
p31625
aS'    const unsigned int n_p = dofs_per_block[1];'
p31626
aS'    {'
p31627
aS'      constraints.clear();'
p31628
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p31629
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p31630
aS'                                               0,'
p31631
aS'                                               Solution<dim>(),'
p31632
aS'                                               constraints,'
p31633
aS'                                               fe.component_mask(velocities));'
p31634
aS'      if (solver_type == SolverType::UMFPACK)'
p31635
aS'        constraints.add_line(n_u);'
p31636
aS'      constraints.close();'
p31637
aS'    }'
p31638
aS'    std::cout << "\\tNumber of active cells: " << triangulation.n_active_cells()'
p31639
aS'              << std::endl'
p31640
aS'              << "\\tNumber of degrees of freedom: " << dof_handler.n_dofs()'
p31641
aS'              << " (" << n_u << \'+\' << n_p << \')\' << std::endl;'
p31642
aS'    {'
p31643
aS'      BlockDynamicSparsityPattern csp(dofs_per_block, dofs_per_block);'
p31644
aS'      DoFTools::make_sparsity_pattern(dof_handler, csp, constraints, false);'
p31645
aS'      sparsity_pattern.copy_from(csp);'
p31646
aS'    }'
p31647
aS'    system_matrix.reinit(sparsity_pattern);'
p31648
aS'    solution.reinit(dofs_per_block);'
p31649
aS'    system_rhs.reinit(dofs_per_block);'
p31650
aS'  }'
p31651
aS'  template <int dim>'
p31652
aS'  void StokesProblem<dim>::assemble_system()'
p31653
aS'  {'
p31654
aS'    TimerOutput::Scope assemble(computing_timer, "Assemble");'
p31655
aS'    system_matrix = 0;'
p31656
aS'    system_rhs    = 0;'
p31657
aS'    const bool assemble_pressure_mass_matrix ='
p31658
aS'      (solver_type == SolverType::UMFPACK) ? false : true;'
p31659
aS'    QGauss<dim> quadrature_formula(pressure_degree + 2);'
p31660
aS'    FEValues<dim> fe_values(fe,'
p31661
aS'                            quadrature_formula,'
p31662
aS'                            update_values | update_quadrature_points |'
p31663
aS'                              update_JxW_values | update_gradients);'
p31664
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p31665
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p31666
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p31667
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p31668
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p31669
aS'    const RightHandSide<dim>    right_hand_side;'
p31670
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p31671
aS'    const FEValuesExtractors::Vector velocities(0);'
p31672
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p31673
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p31674
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p31675
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p31676
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p31677
aS'      {'
p31678
aS'        fe_values.reinit(cell);'
p31679
aS'        local_matrix = 0;'
p31680
aS'        local_rhs    = 0;'
p31681
aS'        right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p31682
aS'                                          rhs_values);'
p31683
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p31684
aS'          {'
p31685
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p31686
aS'              {'
p31687
aS'                symgrad_phi_u[k] ='
p31688
aS'                  fe_values[velocities].symmetric_gradient(k, q);'
p31689
aS'                div_phi_u[k] = fe_values[velocities].divergence(k, q);'
p31690
aS'                phi_p[k]     = fe_values[pressure].value(k, q);'
p31691
aS'              }'
p31692
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p31693
aS'              {'
p31694
aS'                for (unsigned int j = 0; j <= i; ++j)'
p31695
aS'                  {'
p31696
aS'                    local_matrix(i, j) +='
p31697
aS'                      (2 * (symgrad_phi_u[i] * symgrad_phi_u[j]) -'
p31698
aS'                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +'
p31699
aS'                       (assemble_pressure_mass_matrix ? phi_p[i] * phi_p[j] :'
p31700
aS'                                                        0)) *'
p31701
aS'                      fe_values.JxW(q);'
p31702
aS'                  }'
p31703
aS'                const unsigned int component_i ='
p31704
aS'                  fe.system_to_component_index(i).first;'
p31705
aS'                local_rhs(i) += fe_values.shape_value(i, q) *'
p31706
aS'                                rhs_values[q](component_i) * fe_values.JxW(q);'
p31707
aS'              }'
p31708
aS'          }'
p31709
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p31710
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p31711
aS'            local_matrix(i, j) = local_matrix(j, i);'
p31712
aS'        cell->get_dof_indices(local_dof_indices);'
p31713
aS'        constraints.distribute_local_to_global(local_matrix,'
p31714
aS'                                               local_rhs,'
p31715
aS'                                               local_dof_indices,'
p31716
aS'                                               system_matrix,'
p31717
aS'                                               system_rhs);'
p31718
aS'      }'
p31719
aS'    if (solver_type != SolverType::UMFPACK)'
p31720
aS'      {'
p31721
aS'        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));'
p31722
aS'        pressure_mass_matrix.copy_from(system_matrix.block(1, 1));'
p31723
aS'        system_matrix.block(1, 1) = 0;'
p31724
aS'      }'
p31725
aS'  }'
p31726
aS'  template <int dim>'
p31727
aS'  void StokesProblem<dim>::assemble_multigrid()'
p31728
aS'  {'
p31729
aS'    TimerOutput::Scope multigrid_specific(computing_timer,'
p31730
aS'                                          "(Multigrid specific)");'
p31731
aS'    TimerOutput::Scope assemble_multigrid(computing_timer,'
p31732
aS'                                          "Assemble Multigrid");'
p31733
aS'    mg_matrices = 0.;'
p31734
aS'    QGauss<dim> quadrature_formula(pressure_degree + 2);'
p31735
aS'    FEValues<dim> fe_values(velocity_fe,'
p31736
aS'                            quadrature_formula,'
p31737
aS'                            update_values | update_quadrature_points |'
p31738
aS'                              update_JxW_values | update_gradients);'
p31739
aS'    const unsigned int dofs_per_cell = velocity_fe.n_dofs_per_cell();'
p31740
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p31741
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p31742
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p31743
aS'    const FEValuesExtractors::Vector velocities(0);'
p31744
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p31745
aS'    std::vector<AffineConstraints<double>> boundary_constraints('
p31746
aS'      triangulation.n_levels());'
p31747
aS'    std::vector<AffineConstraints<double>> boundary_interface_constraints('
p31748
aS'      triangulation.n_levels());'
p31749
aS'    for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p31750
aS'      {'
p31751
aS'        boundary_constraints[level].add_lines('
p31752
aS'          mg_constrained_dofs.get_refinement_edge_indices(level));'
p31753
aS'        boundary_constraints[level].add_lines('
p31754
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p31755
aS'        boundary_constraints[level].close();'
p31756
aS'        IndexSet idx = mg_constrained_dofs.get_refinement_edge_indices(level) &'
p31757
aS'                       mg_constrained_dofs.get_boundary_indices(level);'
p31758
aS'        boundary_interface_constraints[level].add_lines(idx);'
p31759
aS'        boundary_interface_constraints[level].close();'
p31760
aS'      }'
p31761
aS'    for (const auto &cell : velocity_dof_handler.cell_iterators())'
p31762
aS'      {'
p31763
aS'        fe_values.reinit(cell);'
p31764
aS'        cell_matrix = 0;'
p31765
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p31766
aS'          {'
p31767
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p31768
aS'              symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient(k, q);'
p31769
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p31770
aS'              for (unsigned int j = 0; j <= i; ++j)'
p31771
aS'                {'
p31772
aS'                  cell_matrix(i, j) +='
p31773
aS'                    (symgrad_phi_u[i] * symgrad_phi_u[j]) * fe_values.JxW(q);'
p31774
aS'                }'
p31775
aS'          }'
p31776
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p31777
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p31778
aS'            cell_matrix(i, j) = cell_matrix(j, i);'
p31779
aS'        cell->get_mg_dof_indices(local_dof_indices);'
p31780
aS'        boundary_constraints[cell->level()].distribute_local_to_global('
p31781
aS'          cell_matrix, local_dof_indices, mg_matrices[cell->level()]);'
p31782
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p31783
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p31784
aS'            if (!mg_constrained_dofs.at_refinement_edge(cell->level(),'
p31785
aS'                                                        local_dof_indices[i]) ||'
p31786
aS'                mg_constrained_dofs.at_refinement_edge(cell->level(),'
p31787
aS'                                                       local_dof_indices[j]))'
p31788
aS'              cell_matrix(i, j) = 0;'
p31789
aS'        boundary_interface_constraints[cell->level()]'
p31790
aS'          .distribute_local_to_global(cell_matrix,'
p31791
aS'                                      local_dof_indices,'
p31792
aS'                                      mg_interface_matrices[cell->level()]);'
p31793
aS'      }'
p31794
aS'  }'
p31795
aS'  template <int dim>'
p31796
aS'  void StokesProblem<dim>::solve()'
p31797
aS'  {'
p31798
aS'    TimerOutput::Scope solve(computing_timer, "Solve");'
p31799
aS'    constraints.set_zero(solution);'
p31800
aS'    if (solver_type == SolverType::UMFPACK)'
p31801
aS'      {'
p31802
aS'        computing_timer.enter_subsection("(UMFPACK specific)");'
p31803
aS'        computing_timer.enter_subsection("Solve - Initialize");'
p31804
aS'        SparseDirectUMFPACK A_direct;'
p31805
aS'        A_direct.initialize(system_matrix);'
p31806
aS'        computing_timer.leave_subsection();'
p31807
aS'        computing_timer.leave_subsection();'
p31808
aS'        {'
p31809
aS'          TimerOutput::Scope solve_backslash(computing_timer,'
p31810
aS'                                             "Solve - Backslash");'
p31811
aS'          A_direct.vmult(solution, system_rhs);'
p31812
aS'        }'
p31813
aS'        constraints.distribute(solution);'
p31814
aS'        return;'
p31815
aS'      }'
p31816
aS'    SolverControl solver_control(system_matrix.m(),'
p31817
aS'                                 1e-10 * system_rhs.l2_norm());'
p31818
aS'    unsigned int  n_iterations_A;'
p31819
aS'    unsigned int  n_iterations_S;'
p31820
aS'    const bool use_expensive = true;'
p31821
aS'    SolverFGMRES<BlockVector<double>> solver(solver_control);'
p31822
aS'    if (solver_type == SolverType::FGMRES_ILU)'
p31823
aS'      {'
p31824
aS'        computing_timer.enter_subsection("(ILU specific)");'
p31825
aS'        computing_timer.enter_subsection("Solve - Set-up Preconditioner");'
p31826
aS'        std::cout << "   Computing preconditioner..." << std::endl'
p31827
aS'                  << std::flush;'
p31828
aS'        SparseILU<double> A_preconditioner;'
p31829
aS'        A_preconditioner.initialize(system_matrix.block(0, 0));'
p31830
aS'        SparseILU<double> S_preconditioner;'
p31831
aS'        S_preconditioner.initialize(pressure_mass_matrix);'
p31832
aS'        const BlockSchurPreconditioner<SparseILU<double>, SparseILU<double>>'
p31833
aS'          preconditioner(system_matrix,'
p31834
aS'                         pressure_mass_matrix,'
p31835
aS'                         A_preconditioner,'
p31836
aS'                         S_preconditioner,'
p31837
aS'                         use_expensive);'
p31838
aS'        computing_timer.leave_subsection();'
p31839
aS'        computing_timer.leave_subsection();'
p31840
aS'        {'
p31841
aS'          TimerOutput::Scope solve_fmgres(computing_timer, "Solve - FGMRES");'
p31842
aS'          solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p31843
aS'          n_iterations_A = preconditioner.n_iterations_A;'
p31844
aS'          n_iterations_S = preconditioner.n_iterations_S;'
p31845
aS'        }'
p31846
aS'      }'
p31847
aS'    else'
p31848
aS'      {'
p31849
aS'        computing_timer.enter_subsection("(Multigrid specific)");'
p31850
aS'        computing_timer.enter_subsection("Solve - Set-up Preconditioner");'
p31851
aS'        MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);'
p31852
aS'        mg_transfer.build(velocity_dof_handler);'
p31853
aS'        FullMatrix<double> coarse_matrix;'
p31854
aS'        coarse_matrix.copy_from(mg_matrices[0]);'
p31855
aS'        MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p31856
aS'        coarse_grid_solver.initialize(coarse_matrix);'
p31857
aS'        using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p31858
aS'        mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;'
p31859
aS'        mg_smoother.initialize(mg_matrices);'
p31860
aS'        mg_smoother.set_steps(2);'
p31861
aS'        mg_smoother.set_symmetric(true);'
p31862
aS'        mg::Matrix<Vector<double>> mg_matrix(mg_matrices);'
p31863
aS'        mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);'
p31864
aS'        mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);'
p31865
aS'        Multigrid<Vector<double>> mg('
p31866
aS'          mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);'
p31867
aS'        mg.set_edge_matrices(mg_interface_down, mg_interface_up);'
p31868
aS'        PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p31869
aS'          A_Multigrid(velocity_dof_handler, mg, mg_transfer);'
p31870
aS'        SparseILU<double> S_preconditioner;'
p31871
aS'        S_preconditioner.initialize(pressure_mass_matrix,'
p31872
aS'                                    SparseILU<double>::AdditionalData());'
p31873
aS'        const BlockSchurPreconditioner<'
p31874
aS'          PreconditionMG<dim,'
p31875
aS'                         Vector<double>,'
p31876
aS'                         MGTransferPrebuilt<Vector<double>>>,'
p31877
aS'          SparseILU<double>>'
p31878
aS'          preconditioner(system_matrix,'
p31879
aS'                         pressure_mass_matrix,'
p31880
aS'                         A_Multigrid,'
p31881
aS'                         S_preconditioner,'
p31882
aS'                         use_expensive);'
p31883
aS'        computing_timer.leave_subsection();'
p31884
aS'        computing_timer.leave_subsection();'
p31885
aS'        {'
p31886
aS'          TimerOutput::Scope solve_fmgres(computing_timer, "Solve - FGMRES");'
p31887
aS'          solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p31888
aS'          n_iterations_A = preconditioner.n_iterations_A;'
p31889
aS'          n_iterations_S = preconditioner.n_iterations_S;'
p31890
aS'        }'
p31891
aS'      }'
p31892
aS'    constraints.distribute(solution);'
p31893
aS'    std::cout'
p31894
aS'      << std::endl'
p31895
aS'      << "\\tNumber of FGMRES iterations: " << solver_control.last_step()'
p31896
aS'      << std::endl'
p31897
aS'      << "\\tTotal number of iterations used for approximation of A inverse: "'
p31898
aS'      << n_iterations_A << std::endl'
p31899
aS'      << "\\tTotal number of iterations used for approximation of S inverse: "'
p31900
aS'      << n_iterations_S << std::endl'
p31901
aS'      << std::endl;'
p31902
aS'  }'
p31903
aS'  template <int dim>'
p31904
aS'  void StokesProblem<dim>::compute_errors()'
p31905
aS'  {'
p31906
aS'    const double mean_pressure = VectorTools::compute_mean_value('
p31907
aS'      dof_handler, QGauss<dim>(pressure_degree + 2), solution, dim);'
p31908
aS'    solution.block(1).add(-mean_pressure);'
p31909
aS'    std::cout << "   Note: The mean value was adjusted by " << -mean_pressure'
p31910
aS'              << std::endl;'
p31911
aS'    const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);'
p31912
aS'    const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),'
p31913
aS'                                                     dim + 1);'
p31914
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p31915
aS'    VectorTools::integrate_difference(dof_handler,'
p31916
aS'                                      solution,'
p31917
aS'                                      Solution<dim>(),'
p31918
aS'                                      difference_per_cell,'
p31919
aS'                                      QGauss<dim>(pressure_degree + 2),'
p31920
aS'                                      VectorTools::L2_norm,'
p31921
aS'                                      &velocity_mask);'
p31922
aS'    const double Velocity_L2_error ='
p31923
aS'      VectorTools::compute_global_error(triangulation,'
p31924
aS'                                        difference_per_cell,'
p31925
aS'                                        VectorTools::L2_norm);'
p31926
aS'    VectorTools::integrate_difference(dof_handler,'
p31927
aS'                                      solution,'
p31928
aS'                                      Solution<dim>(),'
p31929
aS'                                      difference_per_cell,'
p31930
aS'                                      QGauss<dim>(pressure_degree + 2),'
p31931
aS'                                      VectorTools::L2_norm,'
p31932
aS'                                      &pressure_mask);'
p31933
aS'    const double Pressure_L2_error ='
p31934
aS'      VectorTools::compute_global_error(triangulation,'
p31935
aS'                                        difference_per_cell,'
p31936
aS'                                        VectorTools::L2_norm);'
p31937
aS'    VectorTools::integrate_difference(dof_handler,'
p31938
aS'                                      solution,'
p31939
aS'                                      Solution<dim>(),'
p31940
aS'                                      difference_per_cell,'
p31941
aS'                                      QGauss<dim>(pressure_degree + 2),'
p31942
aS'                                      VectorTools::H1_norm,'
p31943
aS'                                      &velocity_mask);'
p31944
aS'    const double Velocity_H1_error ='
p31945
aS'      VectorTools::compute_global_error(triangulation,'
p31946
aS'                                        difference_per_cell,'
p31947
aS'                                        VectorTools::H1_norm);'
p31948
aS'    std::cout << std::endl'
p31949
aS'              << "   Velocity L2 Error: " << Velocity_L2_error << std::endl'
p31950
aS'              << "   Pressure L2 Error: " << Pressure_L2_error << std::endl'
p31951
aS'              << "   Velocity H1 Error: " << Velocity_H1_error << std::endl;'
p31952
aS'  }'
p31953
aS'  template <int dim>'
p31954
aS'  void'
p31955
aS'  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const'
p31956
aS'  {'
p31957
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p31958
aS'    solution_names.emplace_back("pressure");'
p31959
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p31960
aS'      data_component_interpretation('
p31961
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p31962
aS'    data_component_interpretation.push_back('
p31963
aS'      DataComponentInterpretation::component_is_scalar);'
p31964
aS'    DataOut<dim> data_out;'
p31965
aS'    data_out.attach_dof_handler(dof_handler);'
p31966
aS'    data_out.add_data_vector(solution,'
p31967
aS'                             solution_names,'
p31968
aS'                             DataOut<dim>::type_dof_data,'
p31969
aS'                             data_component_interpretation);'
p31970
aS'    data_out.build_patches();'
p31971
aS'    std::ofstream output('
p31972
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk");'
p31973
aS'    data_out.write_vtk(output);'
p31974
aS'  }'
p31975
aS'  template <int dim>'
p31976
aS'  void StokesProblem<dim>::run()'
p31977
aS'  {'
p31978
aS'    GridGenerator::hyper_cube(triangulation);'
p31979
aS'    triangulation.refine_global(6 - dim);'
p31980
aS'    if (solver_type == SolverType::FGMRES_ILU)'
p31981
aS'      std::cout << "Now running with ILU" << std::endl;'
p31982
aS'    else if (solver_type == SolverType::FGMRES_GMG)'
p31983
aS'      std::cout << "Now running with Multigrid" << std::endl;'
p31984
aS'    else'
p31985
aS'      std::cout << "Now running with UMFPACK" << std::endl;'
p31986
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 3;'
p31987
aS'         ++refinement_cycle)'
p31988
aS'      {'
p31989
aS'        std::cout << "Refinement cycle " << refinement_cycle << std::endl;'
p31990
aS'        if (refinement_cycle > 0)'
p31991
aS'          triangulation.refine_global(1);'
p31992
aS'        std::cout << "   Set-up..." << std::endl;'
p31993
aS'        setup_dofs();'
p31994
aS'        std::cout << "   Assembling..." << std::endl;'
p31995
aS'        assemble_system();'
p31996
aS'        if (solver_type == SolverType::FGMRES_GMG)'
p31997
aS'          {'
p31998
aS'            std::cout << "   Assembling Multigrid..." << std::endl;'
p31999
aS'            assemble_multigrid();'
p32000
aS'          }'
p32001
aS'        std::cout << "   Solving..." << std::flush;'
p32002
aS'        solve();'
p32003
aS'        compute_errors();'
p32004
aS'        output_results(refinement_cycle);'
p32005
aS'        Utilities::System::MemoryStats mem;'
p32006
aS'        Utilities::System::get_memory_stats(mem);'
p32007
aS'        std::cout << "   VM Peak: " << mem.VmPeak << std::endl;'
p32008
aS'        computing_timer.print_summary();'
p32009
aS'        computing_timer.reset();'
p32010
aS'      }'
p32011
aS'  }'
p32012
aS'} // namespace Step56'
p32013
aS'int main()'
p32014
ag24
aS'  try'
p32015
aS'    {'
p32016
aS'      using namespace Step56;'
p32017
aS'      const int degree = 1;'
p32018
aS'      const int dim    = 3;'
p32019
aS'      StokesProblem<dim> flow_problem(degree, SolverType::FGMRES_GMG);'
p32020
aS'      flow_problem.run();'
p32021
aS'    }'
p32022
aS'  catch (std::exception &exc)'
p32023
aS'    {'
p32024
aS'      std::cerr << std::endl'
p32025
aS'                << std::endl'
p32026
aS'                << "----------------------------------------------------"'
p32027
aS'                << std::endl;'
p32028
aS'      std::cerr << "Exception on processing: " << std::endl'
p32029
aS'                << exc.what() << std::endl'
p32030
aS'                << "Aborting!" << std::endl'
p32031
aS'                << "----------------------------------------------------"'
p32032
aS'                << std::endl;'
p32033
aS'      return 1;'
p32034
aS'    }'
p32035
aS'  catch (...)'
p32036
aS'    {'
p32037
aS'      std::cerr << std::endl'
p32038
aS'                << std::endl'
p32039
aS'                << "----------------------------------------------------"'
p32040
aS'                << std::endl;'
p32041
aS'      std::cerr << "Unknown exception!" << std::endl'
p32042
aS'                << "Aborting!" << std::endl'
p32043
aS'                << "----------------------------------------------------"'
p32044
aS'                << std::endl;'
p32045
aS'      return 1;'
p32046
aS'    }'
p32047
aS'  return 0;'
p32048
ag32
aS'/* ---------------------------------------------------------------------'
p32049
aS' *'
p32050
aS' * Copyright (C) 2008 - 2020 by the deal.II authors'
p32051
aS' *'
p32052
aS' * This file is part of the deal.II library.'
p32053
aS' *'
p32054
aS' * The deal.II library is free software; you can use it, redistribute'
p32055
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p32056
aS' * Public License as published by the Free Software Foundation; either'
p32057
aS' * version 2.1 of the License, or (at your option) any later version.'
p32058
aS' * The full text of the license can be found in the file LICENSE.md at'
p32059
aS' * the top level directory of deal.II.'
p32060
aS' *'
p32061
aS' * ---------------------------------------------------------------------'
p32062
aS' *'
p32063
aS' * Author: Liang Zhao and Timo Heister, Clemson University, 2016'
p32064
aS' */'
p32065
aS'#include <deal.II/base/quadrature_lib.h>'
p32066
aS'#include <deal.II/base/function.h>'
p32067
aS'#include <deal.II/base/utilities.h>'
p32068
aS'#include <deal.II/base/tensor.h>'
p32069
aS'#include <deal.II/lac/block_vector.h>'
p32070
aS'#include <deal.II/lac/full_matrix.h>'
p32071
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p32072
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p32073
aS'#include <deal.II/lac/solver_cg.h>'
p32074
aS'#include <deal.II/lac/solver_gmres.h>'
p32075
aS'#include <deal.II/lac/precondition.h>'
p32076
aS'#include <deal.II/lac/affine_constraints.h>'
p32077
aS'#include <deal.II/grid/tria.h>'
p32078
aS'#include <deal.II/grid/grid_generator.h>'
p32079
aS'#include <deal.II/grid/grid_refinement.h>'
p32080
aS'#include <deal.II/grid/grid_tools.h>'
p32081
aS'#include <deal.II/dofs/dof_handler.h>'
p32082
aS'#include <deal.II/dofs/dof_renumbering.h>'
p32083
aS'#include <deal.II/dofs/dof_tools.h>'
p32084
aS'#include <deal.II/fe/fe_q.h>'
p32085
aS'#include <deal.II/fe/fe_system.h>'
p32086
aS'#include <deal.II/fe/fe_values.h>'
p32087
aS'#include <deal.II/numerics/vector_tools.h>'
p32088
aS'#include <deal.II/numerics/matrix_tools.h>'
p32089
aS'#include <deal.II/numerics/data_out.h>'
p32090
aS'#include <deal.II/numerics/error_estimator.h>'
p32091
aS'#include <deal.II/numerics/solution_transfer.h>'
p32092
aS'#include <deal.II/lac/sparse_direct.h>'
p32093
aS'#include <deal.II/lac/sparse_ilu.h>'
p32094
aS'#include <fstream>'
p32095
aS'#include <iostream>'
p32096
aS'namespace Step57'
p32097
ag24
aS'  using namespace dealii;'
p32098
aS'  template <int dim>'
p32099
aS'  class StationaryNavierStokes'
p32100
aS'  {'
p32101
aS'  public:'
p32102
aS'    StationaryNavierStokes(const unsigned int degree);'
p32103
aS'    void run(const unsigned int refinement);'
p32104
aS'  private:'
p32105
aS'    void setup_dofs();'
p32106
aS'    void initialize_system();'
p32107
aS'    void assemble(const bool initial_step, const bool assemble_matrix);'
p32108
aS'    void assemble_system(const bool initial_step);'
p32109
aS'    void assemble_rhs(const bool initial_step);'
p32110
aS'    void solve(const bool initial_step);'
p32111
aS'    void refine_mesh();'
p32112
aS'    void process_solution(unsigned int refinement);'
p32113
aS'    void output_results(const unsigned int refinement_cycle) const;'
p32114
aS'    void newton_iteration(const double       tolerance,'
p32115
aS'                          const unsigned int max_n_line_searches,'
p32116
aS'                          const unsigned int max_n_refinements,'
p32117
aS'                          const bool         is_initial_step,'
p32118
aS'                          const bool         output_result);'
p32119
aS'    void compute_initial_guess(double step_size);'
p32120
aS'    double                               viscosity;'
p32121
aS'    double                               gamma;'
p32122
aS'    const unsigned int                   degree;'
p32123
aS'    std::vector<types::global_dof_index> dofs_per_block;'
p32124
aS'    Triangulation<dim> triangulation;'
p32125
aS'    FESystem<dim>      fe;'
p32126
aS'    DoFHandler<dim>    dof_handler;'
p32127
aS'    AffineConstraints<double> zero_constraints;'
p32128
aS'    AffineConstraints<double> nonzero_constraints;'
p32129
aS'    BlockSparsityPattern      sparsity_pattern;'
p32130
aS'    BlockSparseMatrix<double> system_matrix;'
p32131
aS'    SparseMatrix<double>      pressure_mass_matrix;'
p32132
aS'    BlockVector<double> present_solution;'
p32133
aS'    BlockVector<double> newton_update;'
p32134
aS'    BlockVector<double> system_rhs;'
p32135
aS'    BlockVector<double> evaluation_point;'
p32136
aS'  };'
p32137
aS'  template <int dim>'
p32138
aS'  class BoundaryValues : public Function<dim>'
p32139
aS'  {'
p32140
aS'  public:'
p32141
aS'    BoundaryValues()'
p32142
aS'      : Function<dim>(dim + 1)'
p32143
aS'    {}'
p32144
aS'    virtual double value(const Point<dim> & p,'
p32145
aS'                         const unsigned int component) const override;'
p32146
aS'  };'
p32147
aS'  template <int dim>'
p32148
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p32149
aS'                                    const unsigned int component) const'
p32150
aS'  {'
p32151
aS'    Assert(component < this->n_components,'
p32152
aS'           ExcIndexRange(component, 0, this->n_components));'
p32153
aS'    if (component == 0 && std::abs(p[dim - 1] - 1.0) < 1e-10)'
p32154
aS'      return 1.0;'
p32155
aS'    return 0;'
p32156
aS'  }'
p32157
aS'  template <class PreconditionerMp>'
p32158
aS'  class BlockSchurPreconditioner : public Subscriptor'
p32159
aS'  {'
p32160
aS'  public:'
p32161
aS'    BlockSchurPreconditioner(double                           gamma,'
p32162
aS'                             double                           viscosity,'
p32163
aS'                             const BlockSparseMatrix<double> &S,'
p32164
aS'                             const SparseMatrix<double> &     P,'
p32165
aS'                             const PreconditionerMp &         Mppreconditioner);'
p32166
aS'    void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;'
p32167
aS'  private:'
p32168
aS'    const double                     gamma;'
p32169
aS'    const double                     viscosity;'
p32170
aS'    const BlockSparseMatrix<double> &stokes_matrix;'
p32171
aS'    const SparseMatrix<double> &     pressure_mass_matrix;'
p32172
aS'    const PreconditionerMp &         mp_preconditioner;'
p32173
aS'    SparseDirectUMFPACK              A_inverse;'
p32174
aS'  };'
p32175
aS'  template <class PreconditionerMp>'
p32176
aS'  BlockSchurPreconditioner<PreconditionerMp>::BlockSchurPreconditioner('
p32177
aS'    double                           gamma,'
p32178
aS'    double                           viscosity,'
p32179
aS'    const BlockSparseMatrix<double> &S,'
p32180
aS'    const SparseMatrix<double> &     P,'
p32181
aS'    const PreconditionerMp &         Mppreconditioner)'
p32182
aS'    : gamma(gamma)'
p32183
aS'    , viscosity(viscosity)'
p32184
aS'    , stokes_matrix(S)'
p32185
aS'    , pressure_mass_matrix(P)'
p32186
aS'    , mp_preconditioner(Mppreconditioner)'
p32187
aS'  {'
p32188
aS'    A_inverse.initialize(stokes_matrix.block(0, 0));'
p32189
aS'  }'
p32190
aS'  template <class PreconditionerMp>'
p32191
aS'  void BlockSchurPreconditioner<PreconditionerMp>::vmult('
p32192
aS'    BlockVector<double> &      dst,'
p32193
aS'    const BlockVector<double> &src) const'
p32194
aS'  {'
p32195
aS'    Vector<double> utmp(src.block(0));'
p32196
aS'    {'
p32197
aS'      SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());'
p32198
aS'      SolverCG<Vector<double>> cg(solver_control);'
p32199
aS'      dst.block(1) = 0.0;'
p32200
aS'      cg.solve(pressure_mass_matrix,'
p32201
aS'               dst.block(1),'
p32202
aS'               src.block(1),'
p32203
aS'               mp_preconditioner);'
p32204
aS'      dst.block(1) *= -(viscosity + gamma);'
p32205
aS'    }'
p32206
aS'    {'
p32207
aS'      stokes_matrix.block(0, 1).vmult(utmp, dst.block(1));'
p32208
aS'      utmp *= -1.0;'
p32209
aS'      utmp += src.block(0);'
p32210
aS'    }'
p32211
aS'    A_inverse.vmult(dst.block(0), utmp);'
p32212
aS'  }'
p32213
aS'  template <int dim>'
p32214
aS'  StationaryNavierStokes<dim>::StationaryNavierStokes(const unsigned int degree)'
p32215
aS'    : viscosity(1.0 / 7500.0)'
p32216
aS'    , gamma(1.0)'
p32217
aS'    , degree(degree)'
p32218
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p32219
aS'    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1)'
p32220
aS'    , dof_handler(triangulation)'
p32221
aS'  {}'
p32222
aS'  template <int dim>'
p32223
aS'  void StationaryNavierStokes<dim>::setup_dofs()'
p32224
aS'  {'
p32225
aS'    system_matrix.clear();'
p32226
aS'    pressure_mass_matrix.clear();'
p32227
aS'    dof_handler.distribute_dofs(fe);'
p32228
aS'    std::vector<unsigned int> block_component(dim + 1, 0);'
p32229
aS'    block_component[dim] = 1;'
p32230
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p32231
aS'    dofs_per_block ='
p32232
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p32233
aS'    unsigned int dof_u = dofs_per_block[0];'
p32234
aS'    unsigned int dof_p = dofs_per_block[1];'
p32235
aS'    FEValuesExtractors::Vector velocities(0);'
p32236
aS'    {'
p32237
aS'      nonzero_constraints.clear();'
p32238
aS'      DoFTools::make_hanging_node_constraints(dof_handler, nonzero_constraints);'
p32239
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p32240
aS'                                               0,'
p32241
aS'                                               BoundaryValues<dim>(),'
p32242
aS'                                               nonzero_constraints,'
p32243
aS'                                               fe.component_mask(velocities));'
p32244
aS'    }'
p32245
aS'    nonzero_constraints.close();'
p32246
aS'    {'
p32247
aS'      zero_constraints.clear();'
p32248
aS'      DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints);'
p32249
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p32250
aS'                                               0,'
p32251
aS'                                               Functions::ZeroFunction<dim>('
p32252
aS'                                                 dim + 1),'
p32253
aS'                                               zero_constraints,'
p32254
aS'                                               fe.component_mask(velocities));'
p32255
aS'    }'
p32256
aS'    zero_constraints.close();'
p32257
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p32258
aS'              << std::endl'
p32259
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p32260
aS'              << " (" << dof_u << " + " << dof_p << \')\' << std::endl;'
p32261
aS'  }'
p32262
aS'  template <int dim>'
p32263
aS'  void StationaryNavierStokes<dim>::initialize_system()'
p32264
aS'  {'
p32265
aS'    {'
p32266
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p32267
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp, nonzero_constraints);'
p32268
aS'      sparsity_pattern.copy_from(dsp);'
p32269
aS'    }'
p32270
aS'    system_matrix.reinit(sparsity_pattern);'
p32271
aS'    present_solution.reinit(dofs_per_block);'
p32272
aS'    newton_update.reinit(dofs_per_block);'
p32273
aS'    system_rhs.reinit(dofs_per_block);'
p32274
aS'  }'
p32275
aS'  template <int dim>'
p32276
aS'  void StationaryNavierStokes<dim>::assemble(const bool initial_step,'
p32277
aS'                                             const bool assemble_matrix)'
p32278
aS'  {'
p32279
aS'    if (assemble_matrix)'
p32280
aS'      system_matrix = 0;'
p32281
aS'    system_rhs = 0;'
p32282
aS'    QGauss<dim> quadrature_formula(degree + 2);'
p32283
aS'    FEValues<dim> fe_values(fe,'
p32284
aS'                            quadrature_formula,'
p32285
aS'                            update_values | update_quadrature_points |'
p32286
aS'                              update_JxW_values | update_gradients);'
p32287
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p32288
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p32289
aS'    const FEValuesExtractors::Vector velocities(0);'
p32290
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p32291
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p32292
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p32293
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p32294
aS'    std::vector<Tensor<1, dim>> present_velocity_values(n_q_points);'
p32295
aS'    std::vector<Tensor<2, dim>> present_velocity_gradients(n_q_points);'
p32296
aS'    std::vector<double>         present_pressure_values(n_q_points);'
p32297
aS'    std::vector<double>         div_phi_u(dofs_per_cell);'
p32298
aS'    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);'
p32299
aS'    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);'
p32300
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p32301
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p32302
aS'      {'
p32303
aS'        fe_values.reinit(cell);'
p32304
aS'        local_matrix = 0;'
p32305
aS'        local_rhs    = 0;'
p32306
aS'        fe_values[velocities].get_function_values(evaluation_point,'
p32307
aS'                                                  present_velocity_values);'
p32308
aS'        fe_values[velocities].get_function_gradients('
p32309
aS'          evaluation_point, present_velocity_gradients);'
p32310
aS'        fe_values[pressure].get_function_values(evaluation_point,'
p32311
aS'                                                present_pressure_values);'
p32312
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p32313
aS'          {'
p32314
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p32315
aS'              {'
p32316
aS'                div_phi_u[k]  = fe_values[velocities].divergence(k, q);'
p32317
aS'                grad_phi_u[k] = fe_values[velocities].gradient(k, q);'
p32318
aS'                phi_u[k]      = fe_values[velocities].value(k, q);'
p32319
aS'                phi_p[k]      = fe_values[pressure].value(k, q);'
p32320
aS'              }'
p32321
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p32322
aS'              {'
p32323
aS'                if (assemble_matrix)'
p32324
aS'                  {'
p32325
aS'                    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p32326
aS'                      {'
p32327
aS'                        local_matrix(i, j) +='
p32328
aS'                          (viscosity *'
p32329
aS'                             scalar_product(grad_phi_u[j], grad_phi_u[i]) +'
p32330
aS'                           present_velocity_gradients[q] * phi_u[j] * phi_u[i] +'
p32331
aS'                           grad_phi_u[j] * present_velocity_values[q] *'
p32332
aS'                             phi_u[i] -'
p32333
aS'                           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +'
p32334
aS'                           gamma * div_phi_u[j] * div_phi_u[i] +'
p32335
aS'                           phi_p[i] * phi_p[j]) *'
p32336
aS'                          fe_values.JxW(q);'
p32337
aS'                      }'
p32338
aS'                  }'
p32339
aS'                double present_velocity_divergence ='
p32340
aS'                  trace(present_velocity_gradients[q]);'
p32341
aS'                local_rhs(i) +='
p32342
aS'                  (-viscosity * scalar_product(present_velocity_gradients[q],'
p32343
aS'                                               grad_phi_u[i]) -'
p32344
aS'                   present_velocity_gradients[q] * present_velocity_values[q] *'
p32345
aS'                     phi_u[i] +'
p32346
aS'                   present_pressure_values[q] * div_phi_u[i] +'
p32347
aS'                   present_velocity_divergence * phi_p[i] -'
p32348
aS'                   gamma * present_velocity_divergence * div_phi_u[i]) *'
p32349
aS'                  fe_values.JxW(q);'
p32350
aS'              }'
p32351
aS'          }'
p32352
aS'        cell->get_dof_indices(local_dof_indices);'
p32353
aS'        const AffineConstraints<double> &constraints_used ='
p32354
aS'          initial_step ? nonzero_constraints : zero_constraints;'
p32355
aS'        if (assemble_matrix)'
p32356
aS'          {'
p32357
aS'            constraints_used.distribute_local_to_global(local_matrix,'
p32358
aS'                                                        local_rhs,'
p32359
aS'                                                        local_dof_indices,'
p32360
aS'                                                        system_matrix,'
p32361
aS'                                                        system_rhs);'
p32362
aS'          }'
p32363
aS'        else'
p32364
aS'          {'
p32365
aS'            constraints_used.distribute_local_to_global(local_rhs,'
p32366
aS'                                                        local_dof_indices,'
p32367
aS'                                                        system_rhs);'
p32368
aS'          }'
p32369
aS'      }'
p32370
aS'    if (assemble_matrix)'
p32371
aS'      {'
p32372
aS'        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));'
p32373
aS'        pressure_mass_matrix.copy_from(system_matrix.block(1, 1));'
p32374
aS'        system_matrix.block(1, 1) = 0;'
p32375
aS'      }'
p32376
aS'  }'
p32377
aS'  template <int dim>'
p32378
aS'  void StationaryNavierStokes<dim>::assemble_system(const bool initial_step)'
p32379
aS'  {'
p32380
aS'    assemble(initial_step, true);'
p32381
aS'  }'
p32382
aS'  template <int dim>'
p32383
aS'  void StationaryNavierStokes<dim>::assemble_rhs(const bool initial_step)'
p32384
aS'  {'
p32385
aS'    assemble(initial_step, false);'
p32386
aS'  }'
p32387
aS'  template <int dim>'
p32388
aS'  void StationaryNavierStokes<dim>::solve(const bool initial_step)'
p32389
aS'  {'
p32390
aS'    const AffineConstraints<double> &constraints_used ='
p32391
aS'      initial_step ? nonzero_constraints : zero_constraints;'
p32392
aS'    SolverControl solver_control(system_matrix.m(),'
p32393
aS'                                 1e-4 * system_rhs.l2_norm(),'
p32394
aS'                                 true);'
p32395
aS'    SolverFGMRES<BlockVector<double>> gmres(solver_control);'
p32396
aS'    SparseILU<double>                 pmass_preconditioner;'
p32397
aS'    pmass_preconditioner.initialize(pressure_mass_matrix,'
p32398
aS'                                    SparseILU<double>::AdditionalData());'
p32399
aS'    const BlockSchurPreconditioner<SparseILU<double>> preconditioner('
p32400
aS'      gamma,'
p32401
aS'      viscosity,'
p32402
aS'      system_matrix,'
p32403
aS'      pressure_mass_matrix,'
p32404
aS'      pmass_preconditioner);'
p32405
aS'    gmres.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p32406
aS'    std::cout << "FGMRES steps: " << solver_control.last_step() << std::endl;'
p32407
aS'    constraints_used.distribute(newton_update);'
p32408
aS'  }'
p32409
aS'  template <int dim>'
p32410
aS'  void StationaryNavierStokes<dim>::refine_mesh()'
p32411
aS'  {'
p32412
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p32413
aS'    FEValuesExtractors::Vector velocity(0);'
p32414
aS'    KellyErrorEstimator<dim>::estimate('
p32415
aS'      dof_handler,'
p32416
aS'      QGauss<dim - 1>(degree + 1),'
p32417
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p32418
aS'      present_solution,'
p32419
aS'      estimated_error_per_cell,'
p32420
aS'      fe.component_mask(velocity));'
p32421
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p32422
aS'                                                    estimated_error_per_cell,'
p32423
aS'                                                    0.3,'
p32424
aS'                                                    0.0);'
p32425
aS'    triangulation.prepare_coarsening_and_refinement();'
p32426
aS'    SolutionTransfer<dim, BlockVector<double>> solution_transfer(dof_handler);'
p32427
aS'    solution_transfer.prepare_for_coarsening_and_refinement(present_solution);'
p32428
aS'    triangulation.execute_coarsening_and_refinement();'
p32429
aS'    setup_dofs();'
p32430
aS'    BlockVector<double> tmp(dofs_per_block);'
p32431
aS'    solution_transfer.interpolate(present_solution, tmp);'
p32432
aS'    nonzero_constraints.distribute(tmp);'
p32433
aS'    initialize_system();'
p32434
aS'    present_solution = tmp;'
p32435
aS'  }'
p32436
aS'  template <int dim>'
p32437
aS'  void StationaryNavierStokes<dim>::newton_iteration('
p32438
aS'    const double       tolerance,'
p32439
aS'    const unsigned int max_n_line_searches,'
p32440
aS'    const unsigned int max_n_refinements,'
p32441
aS'    const bool         is_initial_step,'
p32442
aS'    const bool         output_result)'
p32443
aS'  {'
p32444
aS'    bool first_step = is_initial_step;'
p32445
aS'    for (unsigned int refinement_n = 0; refinement_n < max_n_refinements + 1;'
p32446
aS'         ++refinement_n)'
p32447
aS'      {'
p32448
aS'        unsigned int line_search_n = 0;'
p32449
aS'        double       last_res      = 1.0;'
p32450
aS'        double       current_res   = 1.0;'
p32451
aS'        std::cout << "grid refinements: " << refinement_n << std::endl'
p32452
aS'                  << "viscosity: " << viscosity << std::endl;'
p32453
aS'        while ((first_step || (current_res > tolerance)) &&'
p32454
aS'               line_search_n < max_n_line_searches)'
p32455
aS'          {'
p32456
aS'            if (first_step)'
p32457
aS'              {'
p32458
aS'                setup_dofs();'
p32459
aS'                initialize_system();'
p32460
aS'                evaluation_point = present_solution;'
p32461
aS'                assemble_system(first_step);'
p32462
aS'                solve(first_step);'
p32463
aS'                present_solution = newton_update;'
p32464
aS'                nonzero_constraints.distribute(present_solution);'
p32465
aS'                first_step       = false;'
p32466
aS'                evaluation_point = present_solution;'
p32467
aS'                assemble_rhs(first_step);'
p32468
aS'                current_res = system_rhs.l2_norm();'
p32469
aS'                std::cout << "The residual of initial guess is " << current_res'
p32470
aS'                          << std::endl;'
p32471
aS'                last_res = current_res;'
p32472
aS'              }'
p32473
aS'            else'
p32474
aS'              {'
p32475
aS'                evaluation_point = present_solution;'
p32476
aS'                assemble_system(first_step);'
p32477
aS'                solve(first_step);'
p32478
aS'                for (double alpha = 1.0; alpha > 1e-5; alpha *= 0.5)'
p32479
aS'                  {'
p32480
aS'                    evaluation_point = present_solution;'
p32481
aS'                    evaluation_point.add(alpha, newton_update);'
p32482
aS'                    nonzero_constraints.distribute(evaluation_point);'
p32483
aS'                    assemble_rhs(first_step);'
p32484
aS'                    current_res = system_rhs.l2_norm();'
p32485
aS'                    std::cout << "  alpha: " << std::setw(10) << alpha'
p32486
aS'                              << std::setw(0) << "  residual: " << current_res'
p32487
aS'                              << std::endl;'
p32488
aS'                    if (current_res < last_res)'
p32489
aS'                      break;'
p32490
aS'                  }'
p32491
aS'                {'
p32492
aS'                  present_solution = evaluation_point;'
p32493
aS'                  std::cout << "  number of line searches: " << line_search_n'
p32494
aS'                            << "  residual: " << current_res << std::endl;'
p32495
aS'                  last_res = current_res;'
p32496
aS'                }'
p32497
aS'                ++line_search_n;'
p32498
aS'              }'
p32499
aS'            if (output_result)'
p32500
aS'              {'
p32501
aS'                output_results(max_n_line_searches * refinement_n +'
p32502
aS'                               line_search_n);'
p32503
aS'                if (current_res <= tolerance)'
p32504
aS'                  process_solution(refinement_n);'
p32505
aS'              }'
p32506
aS'          }'
p32507
aS'        if (refinement_n < max_n_refinements)'
p32508
aS'          {'
p32509
aS'            refine_mesh();'
p32510
aS'          }'
p32511
aS'      }'
p32512
aS'  }'
p32513
aS'  template <int dim>'
p32514
aS'  void StationaryNavierStokes<dim>::compute_initial_guess(double step_size)'
p32515
aS'  {'
p32516
aS'    const double target_Re = 1.0 / viscosity;'
p32517
aS'    bool is_initial_step = true;'
p32518
aS'    for (double Re = 1000.0; Re < target_Re;'
p32519
aS'         Re        = std::min(Re + step_size, target_Re))'
p32520
aS'      {'
p32521
aS'        viscosity = 1.0 / Re;'
p32522
aS'        std::cout << "Searching for initial guess with Re = " << Re'
p32523
aS'                  << std::endl;'
p32524
aS'        newton_iteration(1e-12, 50, 0, is_initial_step, false);'
p32525
aS'        is_initial_step = false;'
p32526
aS'      }'
p32527
aS'  }'
p32528
aS'  template <int dim>'
p32529
aS'  void StationaryNavierStokes<dim>::output_results('
p32530
aS'    const unsigned int output_index) const'
p32531
aS'  {'
p32532
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p32533
aS'    solution_names.emplace_back("pressure");'
p32534
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p32535
aS'      data_component_interpretation('
p32536
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p32537
aS'    data_component_interpretation.push_back('
p32538
aS'      DataComponentInterpretation::component_is_scalar);'
p32539
aS'    DataOut<dim> data_out;'
p32540
aS'    data_out.attach_dof_handler(dof_handler);'
p32541
aS'    data_out.add_data_vector(present_solution,'
p32542
aS'                             solution_names,'
p32543
aS'                             DataOut<dim>::type_dof_data,'
p32544
aS'                             data_component_interpretation);'
p32545
aS'    data_out.build_patches();'
p32546
aS'    std::ofstream output(std::to_string(1.0 / viscosity) + "-solution-" +'
p32547
aS'                         Utilities::int_to_string(output_index, 4) + ".vtk");'
p32548
aS'    data_out.write_vtk(output);'
p32549
aS'  }'
p32550
aS'  template <int dim>'
p32551
aS'  void StationaryNavierStokes<dim>::process_solution(unsigned int refinement)'
p32552
aS'  {'
p32553
aS'    std::ofstream f(std::to_string(1.0 / viscosity) + "-line-" +'
p32554
aS'                    std::to_string(refinement) + ".txt");'
p32555
aS'    f << "# y u_x u_y" << std::endl;'
p32556
aS'    Point<dim> p;'
p32557
aS'    p(0) = 0.5;'
p32558
aS'    p(1) = 0.5;'
p32559
aS'    f << std::scientific;'
p32560
aS'    for (unsigned int i = 0; i <= 100; ++i)'
p32561
aS'      {'
p32562
aS'        p(dim - 1) = i / 100.0;'
p32563
aS'        Vector<double> tmp_vector(dim + 1);'
p32564
aS'        VectorTools::point_value(dof_handler, present_solution, p, tmp_vector);'
p32565
aS'        f << p(dim - 1);'
p32566
aS'        for (int j = 0; j < dim; j++)'
p32567
aS'          f << " " << tmp_vector(j);'
p32568
aS'        f << std::endl;'
p32569
aS'      }'
p32570
aS'  }'
p32571
aS'  template <int dim>'
p32572
aS'  void StationaryNavierStokes<dim>::run(const unsigned int refinement)'
p32573
aS'  {'
p32574
aS'    GridGenerator::hyper_cube(triangulation);'
p32575
aS'    triangulation.refine_global(5);'
p32576
aS'    const double Re = 1.0 / viscosity;'
p32577
aS'    if (Re > 1000.0)'
p32578
aS'      {'
p32579
aS'        std::cout << "Searching for initial guess ..." << std::endl;'
p32580
aS'        const double step_size = 2000.0;'
p32581
aS'        compute_initial_guess(step_size);'
p32582
aS'        std::cout << "Found initial guess." << std::endl;'
p32583
aS'        std::cout << "Computing solution with target Re = " << Re << std::endl;'
p32584
aS'        viscosity = 1.0 / Re;'
p32585
aS'        newton_iteration(1e-12, 50, refinement, false, true);'
p32586
aS'      }'
p32587
aS'    else'
p32588
aS'      {'
p32589
aS'        newton_iteration(1e-12, 50, refinement, true, true);'
p32590
aS'      }'
p32591
aS'  }'
p32592
aS'} // namespace Step57'
p32593
aS'int main()'
p32594
ag24
aS'  try'
p32595
aS'    {'
p32596
aS'      using namespace Step57;'
p32597
aS'      StationaryNavierStokes<2> flow(/* degree = */ 1);'
p32598
aS'      flow.run(4);'
p32599
aS'    }'
p32600
aS'  catch (std::exception &exc)'
p32601
aS'    {'
p32602
aS'      std::cerr << std::endl'
p32603
aS'                << std::endl'
p32604
aS'                << "----------------------------------------------------"'
p32605
aS'                << std::endl;'
p32606
aS'      std::cerr << "Exception on processing: " << std::endl'
p32607
aS'                << exc.what() << std::endl'
p32608
aS'                << "Aborting!" << std::endl'
p32609
aS'                << "----------------------------------------------------"'
p32610
aS'                << std::endl;'
p32611
aS'      return 1;'
p32612
aS'    }'
p32613
aS'  catch (...)'
p32614
aS'    {'
p32615
aS'      std::cerr << std::endl'
p32616
aS'                << std::endl'
p32617
aS'                << "----------------------------------------------------"'
p32618
aS'                << std::endl;'
p32619
aS'      std::cerr << "Unknown exception!" << std::endl'
p32620
aS'                << "Aborting!" << std::endl'
p32621
aS'                << "----------------------------------------------------"'
p32622
aS'                << std::endl;'
p32623
aS'      return 1;'
p32624
aS'    }'
p32625
aS'  return 0;'
p32626
ag32
aS'/* ---------------------------------------------------------------------'
p32627
aS' *'
p32628
aS' * Copyright (C) 2018 - 2021 by the deal.II authors'
p32629
aS' *'
p32630
aS' * This file is part of the deal.II library.'
p32631
aS' *'
p32632
aS' * The deal.II library is free software; you can use it, redistribute'
p32633
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p32634
aS' * Public License as published by the Free Software Foundation; either'
p32635
aS' * version 2.1 of the License, or (at your option) any later version.'
p32636
aS' * The full text of the license can be found in the file LICENSE at'
p32637
aS' * the top level of the deal.II distribution.'
p32638
aS' *'
p32639
aS' * ---------------------------------------------------------------------'
p32640
aS' *'
p32641
aS' * Author: Wolfgang Bangerth, Colorado State University'
p32642
aS' *         Yong-Yong Cai, Beijing Computational Science Research Center'
p32643
aS' */'
p32644
aS'#include <deal.II/base/logstream.h>'
p32645
aS'#include <deal.II/lac/vector.h>'
p32646
aS'#include <deal.II/lac/full_matrix.h>'
p32647
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p32648
aS'#include <deal.II/lac/sparse_matrix.h>'
p32649
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p32650
aS'#include <deal.II/lac/block_vector.h>'
p32651
aS'#include <deal.II/lac/affine_constraints.h>'
p32652
aS'#include <deal.II/lac/sparse_direct.h>'
p32653
aS'#include <deal.II/grid/tria.h>'
p32654
aS'#include <deal.II/grid/grid_generator.h>'
p32655
aS'#include <deal.II/grid/grid_refinement.h>'
p32656
aS'#include <deal.II/dofs/dof_handler.h>'
p32657
aS'#include <deal.II/dofs/dof_tools.h>'
p32658
aS'#include <deal.II/fe/fe_q.h>'
p32659
aS'#include <deal.II/fe/fe_values.h>'
p32660
aS'#include <deal.II/numerics/data_out.h>'
p32661
aS'#include <deal.II/numerics/vector_tools.h>'
p32662
aS'#include <deal.II/numerics/error_estimator.h>'
p32663
aS'#include <deal.II/numerics/matrix_tools.h>'
p32664
aS'#include <fstream>'
p32665
aS'#include <iostream>'
p32666
aS'namespace Step58'
p32667
ag24
aS'  using namespace dealii;'
p32668
aS'  template <int dim>'
p32669
aS'  class NonlinearSchroedingerEquation'
p32670
aS'  {'
p32671
aS'  public:'
p32672
aS'    NonlinearSchroedingerEquation();'
p32673
aS'    void run();'
p32674
aS'  private:'
p32675
aS'    void setup_system();'
p32676
aS'    void assemble_matrices();'
p32677
aS'    void do_half_phase_step();'
p32678
aS'    void do_full_spatial_step();'
p32679
aS'    void output_results() const;'
p32680
aS'    Triangulation<dim> triangulation;'
p32681
aS'    FE_Q<dim>          fe;'
p32682
aS'    DoFHandler<dim>    dof_handler;'
p32683
aS'    AffineConstraints<std::complex<double>> constraints;'
p32684
aS'    SparsityPattern                    sparsity_pattern;'
p32685
aS'    SparseMatrix<std::complex<double>> system_matrix;'
p32686
aS'    SparseMatrix<std::complex<double>> rhs_matrix;'
p32687
aS'    Vector<std::complex<double>> solution;'
p32688
aS'    Vector<std::complex<double>> system_rhs;'
p32689
aS'    double       time;'
p32690
aS'    double       time_step;'
p32691
aS'    unsigned int timestep_number;'
p32692
aS'    double kappa;'
p32693
aS'  };'
p32694
aS'  template <int dim>'
p32695
aS'  class InitialValues : public Function<dim, std::complex<double>>'
p32696
aS'  {'
p32697
aS'  public:'
p32698
aS'    InitialValues()'
p32699
aS'      : Function<dim, std::complex<double>>(1)'
p32700
aS'    {}'
p32701
aS'    virtual std::complex<double>'
p32702
aS'    value(const Point<dim> &p, const unsigned int component = 0) const override;'
p32703
aS'  };'
p32704
aS'  template <int dim>'
p32705
aS'  std::complex<double>'
p32706
aS'  InitialValues<dim>::value(const Point<dim> & p,'
p32707
aS'                            const unsigned int component) const'
p32708
aS'  {'
p32709
aS'    static_assert(dim == 2, "This initial condition only works in 2d.");'
p32710
aS'    (void)component;'
p32711
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p32712
aS'    const std::vector<Point<dim>> vortex_centers = {{0, -0.3},'
p32713
aS'                                                    {0, +0.3},'
p32714
aS'                                                    {+0.3, 0},'
p32715
aS'                                                    {-0.3, 0}};'
p32716
aS'    const double R = 0.1;'
p32717
aS'    const double alpha ='
p32718
aS'      1. / (std::pow(R, dim) * std::pow(numbers::PI, dim / 2.));'
p32719
aS'    double sum = 0;'
p32720
aS'    for (const auto &vortex_center : vortex_centers)'
p32721
aS'      {'
p32722
aS'        const Tensor<1, dim> distance = p - vortex_center;'
p32723
aS'        const double         r        = distance.norm();'
p32724
aS'        sum += alpha * std::exp(-(r * r) / (R * R));'
p32725
aS'      }'
p32726
aS'    return {std::sqrt(sum), 0.};'
p32727
aS'  }'
p32728
aS'  template <int dim>'
p32729
aS'  class Potential : public Function<dim>'
p32730
aS'  {'
p32731
aS'  public:'
p32732
aS'    Potential() = default;'
p32733
aS'    virtual double value(const Point<dim> & p,'
p32734
aS'                         const unsigned int component = 0) const override;'
p32735
aS'  };'
p32736
aS'  template <int dim>'
p32737
aS'  double Potential<dim>::value(const Point<dim> & p,'
p32738
aS'                               const unsigned int component) const'
p32739
aS'  {'
p32740
aS'    (void)component;'
p32741
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p32742
aS'    return (Point<dim>().distance(p) > 0.7 ? 1000 : 0);'
p32743
aS'  }'
p32744
aS'  template <int dim>'
p32745
aS'  NonlinearSchroedingerEquation<dim>::NonlinearSchroedingerEquation()'
p32746
aS'    : fe(2)'
p32747
aS'    , dof_handler(triangulation)'
p32748
aS'    , time(0)'
p32749
aS'    , time_step(1. / 128)'
p32750
aS'    , timestep_number(0)'
p32751
aS'    , kappa(1)'
p32752
aS'  {}'
p32753
aS'  template <int dim>'
p32754
aS'  void NonlinearSchroedingerEquation<dim>::setup_system()'
p32755
aS'  {'
p32756
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p32757
aS'    triangulation.refine_global(6);'
p32758
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p32759
aS'              << std::endl;'
p32760
aS'    dof_handler.distribute_dofs(fe);'
p32761
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p32762
aS'              << std::endl'
p32763
aS'              << std::endl;'
p32764
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p32765
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p32766
aS'    sparsity_pattern.copy_from(dsp);'
p32767
aS'    system_matrix.reinit(sparsity_pattern);'
p32768
aS'    rhs_matrix.reinit(sparsity_pattern);'
p32769
aS'    solution.reinit(dof_handler.n_dofs());'
p32770
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p32771
aS'    constraints.close();'
p32772
aS'  }'
p32773
aS'  template <int dim>'
p32774
aS'  void NonlinearSchroedingerEquation<dim>::assemble_matrices()'
p32775
aS'  {'
p32776
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p32777
aS'    FEValues<dim> fe_values(fe,'
p32778
aS'                            quadrature_formula,'
p32779
aS'                            update_values | update_gradients |'
p32780
aS'                              update_quadrature_points | update_JxW_values);'
p32781
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p32782
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p32783
aS'    FullMatrix<std::complex<double>> cell_matrix_lhs(dofs_per_cell,'
p32784
aS'                                                     dofs_per_cell);'
p32785
aS'    FullMatrix<std::complex<double>> cell_matrix_rhs(dofs_per_cell,'
p32786
aS'                                                     dofs_per_cell);'
p32787
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p32788
aS'    std::vector<double>                  potential_values(n_q_points);'
p32789
aS'    const Potential<dim>                 potential;'
p32790
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p32791
aS'      {'
p32792
aS'        cell_matrix_lhs = std::complex<double>(0.);'
p32793
aS'        cell_matrix_rhs = std::complex<double>(0.);'
p32794
aS'        fe_values.reinit(cell);'
p32795
aS'        potential.value_list(fe_values.get_quadrature_points(),'
p32796
aS'                             potential_values);'
p32797
aS'        for (unsigned int q_index = 0; q_index < n_q_points; ++q_index)'
p32798
aS'          {'
p32799
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p32800
aS'              {'
p32801
aS'                for (unsigned int l = 0; l < dofs_per_cell; ++l)'
p32802
aS'                  {'
p32803
aS'                    const std::complex<double> i = {0, 1};'
p32804
aS'                    cell_matrix_lhs(k, l) +='
p32805
aS'                      (-i * fe_values.shape_value(k, q_index) *'
p32806
aS'                         fe_values.shape_value(l, q_index) +'
p32807
aS'                       time_step / 4 * fe_values.shape_grad(k, q_index) *'
p32808
aS'                         fe_values.shape_grad(l, q_index) +'
p32809
aS'                       time_step / 2 * potential_values[q_index] *'
p32810
aS'                         fe_values.shape_value(k, q_index) *'
p32811
aS'                         fe_values.shape_value(l, q_index)) *'
p32812
aS'                      fe_values.JxW(q_index);'
p32813
aS'                    cell_matrix_rhs(k, l) +='
p32814
aS'                      (-i * fe_values.shape_value(k, q_index) *'
p32815
aS'                         fe_values.shape_value(l, q_index) -'
p32816
aS'                       time_step / 4 * fe_values.shape_grad(k, q_index) *'
p32817
aS'                         fe_values.shape_grad(l, q_index) -'
p32818
aS'                       time_step / 2 * potential_values[q_index] *'
p32819
aS'                         fe_values.shape_value(k, q_index) *'
p32820
aS'                         fe_values.shape_value(l, q_index)) *'
p32821
aS'                      fe_values.JxW(q_index);'
p32822
aS'                  }'
p32823
aS'              }'
p32824
aS'          }'
p32825
aS'        cell->get_dof_indices(local_dof_indices);'
p32826
aS'        constraints.distribute_local_to_global(cell_matrix_lhs,'
p32827
aS'                                               local_dof_indices,'
p32828
aS'                                               system_matrix);'
p32829
aS'        constraints.distribute_local_to_global(cell_matrix_rhs,'
p32830
aS'                                               local_dof_indices,'
p32831
aS'                                               rhs_matrix);'
p32832
aS'      }'
p32833
aS'  }'
p32834
aS'  template <int dim>'
p32835
aS'  void NonlinearSchroedingerEquation<dim>::do_half_phase_step()'
p32836
aS'  {'
p32837
aS'    for (auto &value : solution)'
p32838
aS'      {'
p32839
aS'        const std::complex<double> i         = {0, 1};'
p32840
aS'        const double               magnitude = std::abs(value);'
p32841
aS'        value = std::exp(-i * kappa * magnitude * magnitude * (time_step / 2)) *'
p32842
aS'                value;'
p32843
aS'      }'
p32844
aS'  }'
p32845
aS'  template <int dim>'
p32846
aS'  void NonlinearSchroedingerEquation<dim>::do_full_spatial_step()'
p32847
aS'  {'
p32848
aS'    rhs_matrix.vmult(system_rhs, solution);'
p32849
aS'    SparseDirectUMFPACK direct_solver;'
p32850
aS'    direct_solver.solve(system_matrix, system_rhs);'
p32851
aS'    solution = system_rhs;'
p32852
aS'  }'
p32853
aS'  namespace DataPostprocessors'
p32854
aS'  {'
p32855
aS'    template <int dim>'
p32856
aS'    class ComplexAmplitude : public DataPostprocessorScalar<dim>'
p32857
aS'    {'
p32858
aS'    public:'
p32859
aS'      ComplexAmplitude();'
p32860
aS'      virtual void evaluate_vector_field('
p32861
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p32862
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p32863
aS'    };'
p32864
aS'    template <int dim>'
p32865
aS'    ComplexAmplitude<dim>::ComplexAmplitude()'
p32866
aS'      : DataPostprocessorScalar<dim>("Amplitude", update_values)'
p32867
aS'    {}'
p32868
aS'    template <int dim>'
p32869
aS'    void ComplexAmplitude<dim>::evaluate_vector_field('
p32870
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p32871
aS'      std::vector<Vector<double>> &               computed_quantities) const'
p32872
aS'    {'
p32873
aS'      Assert(computed_quantities.size() == inputs.solution_values.size(),'
p32874
aS'             ExcDimensionMismatch(computed_quantities.size(),'
p32875
aS'                                  inputs.solution_values.size()));'
p32876
aS'      for (unsigned int q = 0; q < computed_quantities.size(); ++q)'
p32877
aS'        {'
p32878
aS'          Assert(computed_quantities[q].size() == 1,'
p32879
aS'                 ExcDimensionMismatch(computed_quantities[q].size(), 1));'
p32880
aS'          Assert(inputs.solution_values[q].size() == 2,'
p32881
aS'                 ExcDimensionMismatch(inputs.solution_values[q].size(), 2));'
p32882
aS'          const std::complex<double> psi(inputs.solution_values[q](0),'
p32883
aS'                                         inputs.solution_values[q](1));'
p32884
aS'          computed_quantities[q](0) = std::norm(psi);'
p32885
aS'        }'
p32886
aS'    }'
p32887
aS'    template <int dim>'
p32888
aS'    class ComplexPhase : public DataPostprocessorScalar<dim>'
p32889
aS'    {'
p32890
aS'    public:'
p32891
aS'      ComplexPhase();'
p32892
aS'      virtual void evaluate_vector_field('
p32893
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p32894
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p32895
aS'    };'
p32896
aS'    template <int dim>'
p32897
aS'    ComplexPhase<dim>::ComplexPhase()'
p32898
aS'      : DataPostprocessorScalar<dim>("Phase", update_values)'
p32899
aS'    {}'
p32900
aS'    template <int dim>'
p32901
aS'    void ComplexPhase<dim>::evaluate_vector_field('
p32902
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p32903
aS'      std::vector<Vector<double>> &               computed_quantities) const'
p32904
aS'    {'
p32905
aS'      Assert(computed_quantities.size() == inputs.solution_values.size(),'
p32906
aS'             ExcDimensionMismatch(computed_quantities.size(),'
p32907
aS'                                  inputs.solution_values.size()));'
p32908
aS'      double max_phase = -numbers::PI;'
p32909
aS'      for (unsigned int q = 0; q < computed_quantities.size(); ++q)'
p32910
aS'        {'
p32911
aS'          Assert(computed_quantities[q].size() == 1,'
p32912
aS'                 ExcDimensionMismatch(computed_quantities[q].size(), 1));'
p32913
aS'          Assert(inputs.solution_values[q].size() == 2,'
p32914
aS'                 ExcDimensionMismatch(inputs.solution_values[q].size(), 2));'
p32915
aS'          max_phase ='
p32916
aS'            std::max(max_phase,'
p32917
aS'                     std::arg('
p32918
aS'                       std::complex<double>(inputs.solution_values[q](0),'
p32919
aS'                                            inputs.solution_values[q](1))));'
p32920
aS'        }'
p32921
aS'      for (auto &output : computed_quantities)'
p32922
aS'        output(0) = max_phase;'
p32923
aS'    }'
p32924
aS'  } // namespace DataPostprocessors'
p32925
aS'  template <int dim>'
p32926
aS'  void NonlinearSchroedingerEquation<dim>::output_results() const'
p32927
aS'  {'
p32928
aS'    const DataPostprocessors::ComplexAmplitude<dim> complex_magnitude;'
p32929
aS'    const DataPostprocessors::ComplexPhase<dim>     complex_phase;'
p32930
aS'    DataOut<dim> data_out;'
p32931
aS'    data_out.attach_dof_handler(dof_handler);'
p32932
aS'    data_out.add_data_vector(solution, "Psi");'
p32933
aS'    data_out.add_data_vector(solution, complex_magnitude);'
p32934
aS'    data_out.add_data_vector(solution, complex_phase);'
p32935
aS'    data_out.build_patches();'
p32936
aS'    data_out.set_flags(DataOutBase::VtkFlags(time, timestep_number));'
p32937
aS'    const std::string filename ='
p32938
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p32939
aS'    std::ofstream output(filename);'
p32940
aS'    data_out.write_vtu(output);'
p32941
aS'  }'
p32942
aS'  template <int dim>'
p32943
aS'  void NonlinearSchroedingerEquation<dim>::run()'
p32944
aS'  {'
p32945
aS'    setup_system();'
p32946
aS'    assemble_matrices();'
p32947
aS'    time = 0;'
p32948
aS'    VectorTools::interpolate(dof_handler, InitialValues<dim>(), solution);'
p32949
aS'    output_results();'
p32950
aS'    const double end_time = 1;'
p32951
aS'    for (; time <= end_time; time += time_step)'
p32952
aS'      {'
p32953
aS'        ++timestep_number;'
p32954
aS'        std::cout << "Time step " << timestep_number << " at t=" << time'
p32955
aS'                  << std::endl;'
p32956
aS'        do_half_phase_step();'
p32957
aS'        do_full_spatial_step();'
p32958
aS'        do_half_phase_step();'
p32959
aS'        if (timestep_number % 1 == 0)'
p32960
aS'          output_results();'
p32961
aS'      }'
p32962
aS'  }'
p32963
aS'} // namespace Step58'
p32964
aS'int main()'
p32965
ag24
aS'  try'
p32966
aS'    {'
p32967
aS'      using namespace Step58;'
p32968
aS'      NonlinearSchroedingerEquation<2> nse;'
p32969
aS'      nse.run();'
p32970
aS'    }'
p32971
aS'  catch (std::exception &exc)'
p32972
aS'    {'
p32973
aS'      std::cerr << std::endl'
p32974
aS'                << std::endl'
p32975
aS'                << "----------------------------------------------------"'
p32976
aS'                << std::endl;'
p32977
aS'      std::cerr << "Exception on processing: " << std::endl'
p32978
aS'                << exc.what() << std::endl'
p32979
aS'                << "Aborting!" << std::endl'
p32980
aS'                << "----------------------------------------------------"'
p32981
aS'                << std::endl;'
p32982
aS'      return 1;'
p32983
aS'    }'
p32984
aS'  catch (...)'
p32985
aS'    {'
p32986
aS'      std::cerr << std::endl'
p32987
aS'                << std::endl'
p32988
aS'                << "----------------------------------------------------"'
p32989
aS'                << std::endl;'
p32990
aS'      std::cerr << "Unknown exception!" << std::endl'
p32991
aS'                << "Aborting!" << std::endl'
p32992
aS'                << "----------------------------------------------------"'
p32993
aS'                << std::endl;'
p32994
aS'      return 1;'
p32995
aS'    }'
p32996
aS'  return 0;'
p32997
ag32
aS'/* ---------------------------------------------------------------------'
p32998
aS' *'
p32999
aS' * Copyright (C) 2018 - 2021 by the deal.II authors'
p33000
aS' *'
p33001
aS' * This file is part of the deal.II library.'
p33002
aS' *'
p33003
aS' * The deal.II library is free software; you can use it, redistribute'
p33004
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p33005
aS' * Public License as published by the Free Software Foundation; either'
p33006
aS' * version 2.1 of the License, or (at your option) any later version.'
p33007
aS' * The full text of the license can be found in the file LICENSE.md at'
p33008
aS' * the top level directory of deal.II.'
p33009
aS' *'
p33010
aS' * ---------------------------------------------------------------------'
p33011
aS' *'
p33012
aS' * Authors: Katharina Kormann, Martin Kronbichler, 2018'
p33013
aS' */'
p33014
aS'#include <deal.II/base/quadrature_lib.h>'
p33015
aS'#include <deal.II/base/function.h>'
p33016
aS'#include <deal.II/base/logstream.h>'
p33017
aS'#include <deal.II/base/timer.h>'
p33018
aS'#include <deal.II/lac/affine_constraints.h>'
p33019
aS'#include <deal.II/lac/full_matrix.h>'
p33020
aS'#include <deal.II/lac/solver_cg.h>'
p33021
aS'#include <deal.II/lac/la_parallel_vector.h>'
p33022
aS'#include <deal.II/lac/precondition.h>'
p33023
aS'#include <deal.II/lac/tensor_product_matrix.h>'
p33024
aS'#include <deal.II/fe/fe_dgq.h>'
p33025
aS'#include <deal.II/fe/fe_tools.h>'
p33026
aS'#include <deal.II/grid/tria.h>'
p33027
aS'#include <deal.II/grid/grid_generator.h>'
p33028
aS'#include <deal.II/grid/grid_tools.h>'
p33029
aS'#include <deal.II/multigrid/multigrid.h>'
p33030
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p33031
aS'#include <deal.II/multigrid/mg_tools.h>'
p33032
aS'#include <deal.II/multigrid/mg_coarse.h>'
p33033
aS'#include <deal.II/multigrid/mg_smoother.h>'
p33034
aS'#include <deal.II/multigrid/mg_matrix.h>'
p33035
aS'#include <deal.II/numerics/vector_tools.h>'
p33036
aS'#include <deal.II/matrix_free/matrix_free.h>'
p33037
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p33038
aS'#include <iostream>'
p33039
aS'#include <fstream>'
p33040
aS'namespace Step59'
p33041
ag24
aS'  using namespace dealii;'
p33042
aS'  const unsigned int degree_finite_element = 8;'
p33043
aS'  const unsigned int dimension             = 3;'
p33044
aS'  template <int dim>'
p33045
aS'  class Solution : public Function<dim>'
p33046
aS'  {'
p33047
aS'  public:'
p33048
aS'    virtual double value(const Point<dim> &p,'
p33049
aS'                         const unsigned int = 0) const override final'
p33050
aS'    {'
p33051
aS'      double val = 1.;'
p33052
aS'      for (unsigned int d = 0; d < dim; ++d)'
p33053
aS'        val *= std::cos(numbers::PI * 2.4 * p[d]);'
p33054
aS'      return val;'
p33055
aS'    }'
p33056
aS'    virtual Tensor<1, dim> gradient(const Point<dim> &p,'
p33057
aS'                                    const unsigned int = 0) const override final'
p33058
aS'    {'
p33059
aS'      const double   arg = numbers::PI * 2.4;'
p33060
aS'      Tensor<1, dim> grad;'
p33061
aS'      for (unsigned int d = 0; d < dim; ++d)'
p33062
aS'        {'
p33063
aS'          grad[d] = 1.;'
p33064
aS'          for (unsigned int e = 0; e < dim; ++e)'
p33065
aS'            if (d == e)'
p33066
aS'              grad[d] *= -arg * std::sin(arg * p[e]);'
p33067
aS'            else'
p33068
aS'              grad[d] *= std::cos(arg * p[e]);'
p33069
aS'        }'
p33070
aS'      return grad;'
p33071
aS'    }'
p33072
aS'  };'
p33073
aS'  template <int dim>'
p33074
aS'  class RightHandSide : public Function<dim>'
p33075
aS'  {'
p33076
aS'  public:'
p33077
aS'    virtual double value(const Point<dim> &p,'
p33078
aS'                         const unsigned int = 0) const override final'
p33079
aS'    {'
p33080
aS'      const double arg = numbers::PI * 2.4;'
p33081
aS'      double       val = 1.;'
p33082
aS'      for (unsigned int d = 0; d < dim; ++d)'
p33083
aS'        val *= std::cos(arg * p[d]);'
p33084
aS'      return dim * arg * arg * val;'
p33085
aS'    }'
p33086
aS'  };'
p33087
aS'  template <int dim, int fe_degree, typename number>'
p33088
aS'  class LaplaceOperator : public Subscriptor'
p33089
aS'  {'
p33090
aS'  public:'
p33091
aS'    using value_type = number;'
p33092
aS'    LaplaceOperator() = default;'
p33093
aS'    void initialize(std::shared_ptr<const MatrixFree<dim, number>> data);'
p33094
aS'    void clear();'
p33095
aS'    types::global_dof_index m() const;'
p33096
aS'    void initialize_dof_vector('
p33097
aS'      LinearAlgebra::distributed::Vector<number> &vec) const;'
p33098
aS'    std::shared_ptr<const MatrixFree<dim, number>> get_matrix_free() const;'
p33099
aS'    void vmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p33100
aS'               const LinearAlgebra::distributed::Vector<number> &src) const;'
p33101
aS'    void Tvmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p33102
aS'                const LinearAlgebra::distributed::Vector<number> &src) const;'
p33103
aS'    number get_penalty_factor() const'
p33104
aS'    {'
p33105
aS'      return 1.0 * fe_degree * (fe_degree + 1);'
p33106
aS'    }'
p33107
aS'  private:'
p33108
aS'    void'
p33109
aS'    apply_cell(const MatrixFree<dim, number> &                   data,'
p33110
aS'               LinearAlgebra::distributed::Vector<number> &      dst,'
p33111
aS'               const LinearAlgebra::distributed::Vector<number> &src,'
p33112
aS'               const std::pair<unsigned int, unsigned int> &cell_range) const;'
p33113
aS'    void'
p33114
aS'    apply_face(const MatrixFree<dim, number> &                   data,'
p33115
aS'               LinearAlgebra::distributed::Vector<number> &      dst,'
p33116
aS'               const LinearAlgebra::distributed::Vector<number> &src,'
p33117
aS'               const std::pair<unsigned int, unsigned int> &face_range) const;'
p33118
aS'    void apply_boundary('
p33119
aS'      const MatrixFree<dim, number> &                   data,'
p33120
aS'      LinearAlgebra::distributed::Vector<number> &      dst,'
p33121
aS'      const LinearAlgebra::distributed::Vector<number> &src,'
p33122
aS'      const std::pair<unsigned int, unsigned int> &     face_range) const;'
p33123
aS'    std::shared_ptr<const MatrixFree<dim, number>> data;'
p33124
aS'  };'
p33125
aS'  template <int dim, int fe_degree, typename number>'
p33126
aS'  class PreconditionBlockJacobi'
p33127
aS'  {'
p33128
aS'  public:'
p33129
aS'    using value_type = number;'
p33130
aS'    void clear()'
p33131
aS'    {'
p33132
aS'      cell_matrices.clear();'
p33133
aS'    }'
p33134
aS'    void initialize(const LaplaceOperator<dim, fe_degree, number> &op);'
p33135
aS'    void vmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p33136
aS'               const LinearAlgebra::distributed::Vector<number> &src) const;'
p33137
aS'    void Tvmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p33138
aS'                const LinearAlgebra::distributed::Vector<number> &src) const'
p33139
aS'    {'
p33140
aS'      vmult(dst, src);'
p33141
aS'    }'
p33142
aS'  private:'
p33143
aS'    std::shared_ptr<const MatrixFree<dim, number>> data;'
p33144
aS'    std::vector<TensorProductMatrixSymmetricSum<dim,'
p33145
aS'                                                VectorizedArray<number>,'
p33146
aS'                                                fe_degree + 1>>'
p33147
aS'      cell_matrices;'
p33148
aS'  };'
p33149
aS'  template <int dim, typename number>'
p33150
aS'  void adjust_ghost_range_if_necessary('
p33151
aS'    const MatrixFree<dim, number> &                   data,'
p33152
aS'    const LinearAlgebra::distributed::Vector<number> &vec)'
p33153
aS'  {'
p33154
aS'    if (vec.get_partitioner().get() =='
p33155
aS'        data.get_dof_info(0).vector_partitioner.get())'
p33156
aS'      return;'
p33157
aS'    LinearAlgebra::distributed::Vector<number> copy_vec(vec);'
p33158
aS'    const_cast<LinearAlgebra::distributed::Vector<number> &>(vec).reinit('
p33159
aS'      data.get_dof_info(0).vector_partitioner);'
p33160
aS'    const_cast<LinearAlgebra::distributed::Vector<number> &>(vec)'
p33161
aS'      .copy_locally_owned_data_from(copy_vec);'
p33162
aS'  }'
p33163
aS'  template <int dim, int fe_degree, typename number>'
p33164
aS'  void LaplaceOperator<dim, fe_degree, number>::clear()'
p33165
aS'  {'
p33166
aS'    data.reset();'
p33167
aS'  }'
p33168
aS'  template <int dim, int fe_degree, typename number>'
p33169
aS'  void LaplaceOperator<dim, fe_degree, number>::initialize('
p33170
aS'    std::shared_ptr<const MatrixFree<dim, number>> data)'
p33171
aS'  {'
p33172
aS'    this->data = data;'
p33173
aS'  }'
p33174
aS'  template <int dim, int fe_degree, typename number>'
p33175
aS'  std::shared_ptr<const MatrixFree<dim, number>>'
p33176
aS'  LaplaceOperator<dim, fe_degree, number>::get_matrix_free() const'
p33177
aS'  {'
p33178
aS'    return data;'
p33179
aS'  }'
p33180
aS'  template <int dim, int fe_degree, typename number>'
p33181
aS'  void LaplaceOperator<dim, fe_degree, number>::initialize_dof_vector('
p33182
aS'    LinearAlgebra::distributed::Vector<number> &vec) const'
p33183
aS'  {'
p33184
aS'    data->initialize_dof_vector(vec);'
p33185
aS'  }'
p33186
aS'  template <int dim, int fe_degree, typename number>'
p33187
aS'  types::global_dof_index LaplaceOperator<dim, fe_degree, number>::m() const'
p33188
aS'  {'
p33189
aS'    Assert(data.get() != nullptr, ExcNotInitialized());'
p33190
aS'    return data->get_dof_handler().n_dofs();'
p33191
aS'  }'
p33192
aS'  template <int dim, int fe_degree, typename number>'
p33193
aS'  void LaplaceOperator<dim, fe_degree, number>::vmult('
p33194
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p33195
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p33196
aS'  {'
p33197
aS'    adjust_ghost_range_if_necessary(*data, dst);'
p33198
aS'    adjust_ghost_range_if_necessary(*data, src);'
p33199
aS'    data->loop(&LaplaceOperator::apply_cell,'
p33200
aS'               &LaplaceOperator::apply_face,'
p33201
aS'               &LaplaceOperator::apply_boundary,'
p33202
aS'               this,'
p33203
aS'               dst,'
p33204
aS'               src,'
p33205
aS'               MatrixFree<dim, number>::DataAccessOnFaces::gradients,'
p33206
aS'               MatrixFree<dim, number>::DataAccessOnFaces::gradients);'
p33207
aS'  }'
p33208
aS'  template <int dim, int fe_degree, typename number>'
p33209
aS'  void LaplaceOperator<dim, fe_degree, number>::Tvmult('
p33210
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p33211
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p33212
aS'  {'
p33213
aS'    vmult(dst, src);'
p33214
aS'  }'
p33215
aS'  template <int dim, int fe_degree, typename number>'
p33216
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_cell('
p33217
aS'    const MatrixFree<dim, number> &                   data,'
p33218
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p33219
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p33220
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p33221
aS'  {'
p33222
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data);'
p33223
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p33224
aS'      {'
p33225
aS'        phi.reinit(cell);'
p33226
aS'        phi.gather_evaluate(src, EvaluationFlags::gradients);'
p33227
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p33228
aS'          phi.submit_gradient(phi.get_gradient(q), q);'
p33229
aS'        phi.integrate_scatter(EvaluationFlags::gradients, dst);'
p33230
aS'      }'
p33231
aS'  }'
p33232
aS'  template <int dim, int fe_degree, typename number>'
p33233
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_face('
p33234
aS'    const MatrixFree<dim, number> &                   data,'
p33235
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p33236
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p33237
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p33238
aS'  {'
p33239
aS'    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_inner(data,'
p33240
aS'                                                                         true);'
p33241
aS'    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_outer(data,'
p33242
aS'                                                                         false);'
p33243
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p33244
aS'      {'
p33245
aS'        phi_inner.reinit(face);'
p33246
aS'        phi_inner.gather_evaluate(src,'
p33247
aS'                                  EvaluationFlags::values |'
p33248
aS'                                    EvaluationFlags::gradients);'
p33249
aS'        phi_outer.reinit(face);'
p33250
aS'        phi_outer.gather_evaluate(src,'
p33251
aS'                                  EvaluationFlags::values |'
p33252
aS'                                    EvaluationFlags::gradients);'
p33253
aS'        const VectorizedArray<number> inverse_length_normal_to_face ='
p33254
aS'          0.5 * (std::abs((phi_inner.get_normal_vector(0) *'
p33255
aS'                           phi_inner.inverse_jacobian(0))[dim - 1]) +'
p33256
aS'                 std::abs((phi_outer.get_normal_vector(0) *'
p33257
aS'                           phi_outer.inverse_jacobian(0))[dim - 1]));'
p33258
aS'        const VectorizedArray<number> sigma ='
p33259
aS'          inverse_length_normal_to_face * get_penalty_factor();'
p33260
aS'        for (unsigned int q = 0; q < phi_inner.n_q_points; ++q)'
p33261
aS'          {'
p33262
aS'            const VectorizedArray<number> solution_jump ='
p33263
aS'              (phi_inner.get_value(q) - phi_outer.get_value(q));'
p33264
aS'            const VectorizedArray<number> average_normal_derivative ='
p33265
aS'              (phi_inner.get_normal_derivative(q) +'
p33266
aS'               phi_outer.get_normal_derivative(q)) *'
p33267
aS'              number(0.5);'
p33268
aS'            const VectorizedArray<number> test_by_value ='
p33269
aS'              solution_jump * sigma - average_normal_derivative;'
p33270
aS'            phi_inner.submit_value(test_by_value, q);'
p33271
aS'            phi_outer.submit_value(-test_by_value, q);'
p33272
aS'            phi_inner.submit_normal_derivative(-solution_jump * number(0.5), q);'
p33273
aS'            phi_outer.submit_normal_derivative(-solution_jump * number(0.5), q);'
p33274
aS'          }'
p33275
aS'        phi_inner.integrate_scatter(EvaluationFlags::values |'
p33276
aS'                                      EvaluationFlags::gradients,'
p33277
aS'                                    dst);'
p33278
aS'        phi_outer.integrate_scatter(EvaluationFlags::values |'
p33279
aS'                                      EvaluationFlags::gradients,'
p33280
aS'                                    dst);'
p33281
aS'      }'
p33282
aS'  }'
p33283
aS'  template <int dim, int fe_degree, typename number>'
p33284
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_boundary('
p33285
aS'    const MatrixFree<dim, number> &                   data,'
p33286
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p33287
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p33288
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p33289
aS'  {'
p33290
aS'    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_inner(data,'
p33291
aS'                                                                         true);'
p33292
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p33293
aS'      {'
p33294
aS'        phi_inner.reinit(face);'
p33295
aS'        phi_inner.gather_evaluate(src,'
p33296
aS'                                  EvaluationFlags::values |'
p33297
aS'                                    EvaluationFlags::gradients);'
p33298
aS'        const VectorizedArray<number> inverse_length_normal_to_face ='
p33299
aS'          std::abs((phi_inner.get_normal_vector(0) *'
p33300
aS'                    phi_inner.inverse_jacobian(0))[dim - 1]);'
p33301
aS'        const VectorizedArray<number> sigma ='
p33302
aS'          inverse_length_normal_to_face * get_penalty_factor();'
p33303
aS'        const bool is_dirichlet = (data.get_boundary_id(face) == 0);'
p33304
aS'        for (unsigned int q = 0; q < phi_inner.n_q_points; ++q)'
p33305
aS'          {'
p33306
aS'            const VectorizedArray<number> u_inner = phi_inner.get_value(q);'
p33307
aS'            const VectorizedArray<number> u_outer ='
p33308
aS'              is_dirichlet ? -u_inner : u_inner;'
p33309
aS'            const VectorizedArray<number> normal_derivative_inner ='
p33310
aS'              phi_inner.get_normal_derivative(q);'
p33311
aS'            const VectorizedArray<number> normal_derivative_outer ='
p33312
aS'              is_dirichlet ? normal_derivative_inner : -normal_derivative_inner;'
p33313
aS'            const VectorizedArray<number> solution_jump = (u_inner - u_outer);'
p33314
aS'            const VectorizedArray<number> average_normal_derivative ='
p33315
aS'              (normal_derivative_inner + normal_derivative_outer) * number(0.5);'
p33316
aS'            const VectorizedArray<number> test_by_value ='
p33317
aS'              solution_jump * sigma - average_normal_derivative;'
p33318
aS'            phi_inner.submit_normal_derivative(-solution_jump * number(0.5), q);'
p33319
aS'            phi_inner.submit_value(test_by_value, q);'
p33320
aS'          }'
p33321
aS'        phi_inner.integrate_scatter(EvaluationFlags::values |'
p33322
aS'                                      EvaluationFlags::gradients,'
p33323
aS'                                    dst);'
p33324
aS'      }'
p33325
aS'  }'
p33326
aS'  template <int dim, int fe_degree, typename number>'
p33327
aS'  void PreconditionBlockJacobi<dim, fe_degree, number>::initialize('
p33328
aS'    const LaplaceOperator<dim, fe_degree, number> &op)'
p33329
aS'  {'
p33330
aS'    data = op.get_matrix_free();'
p33331
aS'    std::string name = data->get_dof_handler().get_fe().get_name();'
p33332
aS'    name.replace(name.find(\'<\') + 1, 1, "1");'
p33333
aS'    std::unique_ptr<FiniteElement<1>> fe_1d = FETools::get_fe_by_name<1>(name);'
p33334
aS'    const unsigned int                                 N = fe_degree + 1;'
p33335
aS'    FullMatrix<double>                                 laplace_unscaled(N, N);'
p33336
aS'    std::array<Table<2, VectorizedArray<number>>, dim> mass_matrices;'
p33337
aS'    std::array<Table<2, VectorizedArray<number>>, dim> laplace_matrices;'
p33338
aS'    for (unsigned int d = 0; d < dim; ++d)'
p33339
aS'      {'
p33340
aS'        mass_matrices[d].reinit(N, N);'
p33341
aS'        laplace_matrices[d].reinit(N, N);'
p33342
aS'      }'
p33343
aS'    QGauss<1> quadrature(N);'
p33344
aS'    for (unsigned int i = 0; i < N; ++i)'
p33345
aS'      for (unsigned int j = 0; j < N; ++j)'
p33346
aS'        {'
p33347
aS'          double sum_mass = 0, sum_laplace = 0;'
p33348
aS'          for (unsigned int q = 0; q < quadrature.size(); ++q)'
p33349
aS'            {'
p33350
aS'              sum_mass += (fe_1d->shape_value(i, quadrature.point(q)) *'
p33351
aS'                           fe_1d->shape_value(j, quadrature.point(q))) *'
p33352
aS'                          quadrature.weight(q);'
p33353
aS'              sum_laplace += (fe_1d->shape_grad(i, quadrature.point(q))[0] *'
p33354
aS'                              fe_1d->shape_grad(j, quadrature.point(q))[0]) *'
p33355
aS'                             quadrature.weight(q);'
p33356
aS'            }'
p33357
aS'          for (unsigned int d = 0; d < dim; ++d)'
p33358
aS'            mass_matrices[d](i, j) = sum_mass;'
p33359
aS'          sum_laplace +='
p33360
aS'            (1. * fe_1d->shape_value(i, Point<1>()) *'
p33361
aS'               fe_1d->shape_value(j, Point<1>()) * op.get_penalty_factor() +'
p33362
aS'             0.5 * fe_1d->shape_grad(i, Point<1>())[0] *'
p33363
aS'               fe_1d->shape_value(j, Point<1>()) +'
p33364
aS'             0.5 * fe_1d->shape_grad(j, Point<1>())[0] *'
p33365
aS'               fe_1d->shape_value(i, Point<1>()));'
p33366
aS'          sum_laplace +='
p33367
aS'            (1. * fe_1d->shape_value(i, Point<1>(1.0)) *'
p33368
aS'               fe_1d->shape_value(j, Point<1>(1.0)) * op.get_penalty_factor() -'
p33369
aS'             0.5 * fe_1d->shape_grad(i, Point<1>(1.0))[0] *'
p33370
aS'               fe_1d->shape_value(j, Point<1>(1.0)) -'
p33371
aS'             0.5 * fe_1d->shape_grad(j, Point<1>(1.0))[0] *'
p33372
aS'               fe_1d->shape_value(i, Point<1>(1.0)));'
p33373
aS'          laplace_unscaled(i, j) = sum_laplace;'
p33374
aS'        }'
p33375
aS'    cell_matrices.clear();'
p33376
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*data);'
p33377
aS'    unsigned int old_mapping_data_index = numbers::invalid_unsigned_int;'
p33378
aS'    for (unsigned int cell = 0; cell < data->n_cell_batches(); ++cell)'
p33379
aS'      {'
p33380
aS'        phi.reinit(cell);'
p33381
aS'        if (phi.get_mapping_data_index_offset() == old_mapping_data_index)'
p33382
aS'          continue;'
p33383
aS'        Tensor<2, dim, VectorizedArray<number>> inverse_jacobian ='
p33384
aS'          phi.inverse_jacobian(0);'
p33385
aS'        for (unsigned int d = 0; d < dim; ++d)'
p33386
aS'          for (unsigned int e = 0; e < dim; ++e)'
p33387
aS'            if (d != e)'
p33388
aS'              for (unsigned int v = 0; v < VectorizedArray<number>::size(); ++v)'
p33389
aS'                AssertThrow(inverse_jacobian[d][e][v] == 0.,'
p33390
aS'                            ExcNotImplemented());'
p33391
aS'        VectorizedArray<number> jacobian_determinant = inverse_jacobian[0][0];'
p33392
aS'        for (unsigned int e = 1; e < dim; ++e)'
p33393
aS'          jacobian_determinant *= inverse_jacobian[e][e];'
p33394
aS'        jacobian_determinant = 1. / jacobian_determinant;'
p33395
aS'        for (unsigned int d = 0; d < dim; ++d)'
p33396
aS'          {'
p33397
aS'            const VectorizedArray<number> scaling_factor ='
p33398
aS'              inverse_jacobian[d][d] * inverse_jacobian[d][d] *'
p33399
aS'              jacobian_determinant;'
p33400
aS'            for (unsigned int i = 0; i < N; ++i)'
p33401
aS'              for (unsigned int j = 0; j < N; ++j)'
p33402
aS'                laplace_matrices[d](i, j) ='
p33403
aS'                  scaling_factor * laplace_unscaled(i, j);'
p33404
aS'          }'
p33405
aS'        if (cell_matrices.size() <= phi.get_mapping_data_index_offset())'
p33406
aS'          cell_matrices.resize(phi.get_mapping_data_index_offset() + 1);'
p33407
aS'        cell_matrices[phi.get_mapping_data_index_offset()].reinit('
p33408
aS'          mass_matrices, laplace_matrices);'
p33409
aS'      }'
p33410
aS'  }'
p33411
aS'  template <int dim, int fe_degree, typename number>'
p33412
aS'  void PreconditionBlockJacobi<dim, fe_degree, number>::vmult('
p33413
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p33414
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p33415
aS'  {'
p33416
aS'    adjust_ghost_range_if_necessary(*data, dst);'
p33417
aS'    adjust_ghost_range_if_necessary(*data, src);'
p33418
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*data);'
p33419
aS'    for (unsigned int cell = 0; cell < data->n_cell_batches(); ++cell)'
p33420
aS'      {'
p33421
aS'        phi.reinit(cell);'
p33422
aS'        phi.read_dof_values(src);'
p33423
aS'        cell_matrices[phi.get_mapping_data_index_offset()].apply_inverse('
p33424
aS'          ArrayView<VectorizedArray<number>>(phi.begin_dof_values(),'
p33425
aS'                                             phi.dofs_per_cell),'
p33426
aS'          ArrayView<const VectorizedArray<number>>(phi.begin_dof_values(),'
p33427
aS'                                                   phi.dofs_per_cell));'
p33428
aS'        phi.set_dof_values(dst);'
p33429
aS'      }'
p33430
aS'  }'
p33431
aS'  template <int dim, int fe_degree>'
p33432
aS'  class LaplaceProblem'
p33433
aS'  {'
p33434
aS'  public:'
p33435
aS'    LaplaceProblem();'
p33436
aS'    void run();'
p33437
aS'  private:'
p33438
aS'    void setup_system();'
p33439
aS'    void compute_rhs();'
p33440
aS'    void solve();'
p33441
aS'    void analyze_results() const;'
p33442
aS'#ifdef DEAL_II_WITH_P4EST'
p33443
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p33444
aS'#else'
p33445
aS'    Triangulation<dim> triangulation;'
p33446
aS'#endif'
p33447
aS'    FE_DGQHermite<dim> fe;'
p33448
aS'    DoFHandler<dim>    dof_handler;'
p33449
aS'    MappingQ1<dim> mapping;'
p33450
aS'    using SystemMatrixType = LaplaceOperator<dim, fe_degree, double>;'
p33451
aS'    SystemMatrixType system_matrix;'
p33452
aS'    using LevelMatrixType = LaplaceOperator<dim, fe_degree, float>;'
p33453
aS'    MGLevelObject<LevelMatrixType> mg_matrices;'
p33454
aS'    LinearAlgebra::distributed::Vector<double> solution;'
p33455
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p33456
aS'    double             setup_time;'
p33457
aS'    ConditionalOStream pcout;'
p33458
aS'    ConditionalOStream time_details;'
p33459
aS'  };'
p33460
aS'  template <int dim, int fe_degree>'
p33461
aS'  LaplaceProblem<dim, fe_degree>::LaplaceProblem()'
p33462
aS'    :'
p33463
aS'#ifdef DEAL_II_WITH_P4EST'
p33464
aS'    triangulation('
p33465
aS'      MPI_COMM_WORLD,'
p33466
aS'      Triangulation<dim>::limit_level_difference_at_vertices,'
p33467
aS'      parallel::distributed::Triangulation<dim>::construct_multigrid_hierarchy)'
p33468
aS'    ,'
p33469
aS'#else'
p33470
aS'    triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p33471
aS'    ,'
p33472
aS'#endif'
p33473
aS'    fe(fe_degree)'
p33474
aS'    , dof_handler(triangulation)'
p33475
aS'    , setup_time(0.)'
p33476
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p33477
aS'    , time_details(std::cout,'
p33478
aS'                   false &&'
p33479
aS'                     Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p33480
aS'  {}'
p33481
aS'  template <int dim, int fe_degree>'
p33482
aS'  void LaplaceProblem<dim, fe_degree>::setup_system()'
p33483
aS'  {'
p33484
aS'    Timer time;'
p33485
aS'    setup_time = 0;'
p33486
aS'    system_matrix.clear();'
p33487
aS'    mg_matrices.clear_elements();'
p33488
aS'    dof_handler.distribute_dofs(fe);'
p33489
aS'    dof_handler.distribute_mg_dofs();'
p33490
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p33491
aS'          << std::endl;'
p33492
aS'    setup_time += time.wall_time();'
p33493
aS'    time_details << "Distribute DoFs               " << time.wall_time() << " s"'
p33494
aS'                 << std::endl;'
p33495
aS'    time.restart();'
p33496
aS'    AffineConstraints<double> dummy;'
p33497
aS'    dummy.close();'
p33498
aS'    {'
p33499
aS'      typename MatrixFree<dim, double>::AdditionalData additional_data;'
p33500
aS'      additional_data.tasks_parallel_scheme ='
p33501
aS'        MatrixFree<dim, double>::AdditionalData::none;'
p33502
aS'      additional_data.mapping_update_flags ='
p33503
aS'        (update_gradients | update_JxW_values | update_quadrature_points);'
p33504
aS'      additional_data.mapping_update_flags_inner_faces ='
p33505
aS'        (update_gradients | update_JxW_values | update_normal_vectors);'
p33506
aS'      additional_data.mapping_update_flags_boundary_faces ='
p33507
aS'        (update_gradients | update_JxW_values | update_normal_vectors |'
p33508
aS'         update_quadrature_points);'
p33509
aS'      const auto system_mf_storage ='
p33510
aS'        std::make_shared<MatrixFree<dim, double>>();'
p33511
aS'      system_mf_storage->reinit('
p33512
aS'        mapping, dof_handler, dummy, QGauss<1>(fe.degree + 1), additional_data);'
p33513
aS'      system_matrix.initialize(system_mf_storage);'
p33514
aS'    }'
p33515
aS'    system_matrix.initialize_dof_vector(solution);'
p33516
aS'    system_matrix.initialize_dof_vector(system_rhs);'
p33517
aS'    setup_time += time.wall_time();'
p33518
aS'    time_details << "Setup matrix-free system      " << time.wall_time() << " s"'
p33519
aS'                 << std::endl;'
p33520
aS'    time.restart();'
p33521
aS'    const unsigned int nlevels = triangulation.n_global_levels();'
p33522
aS'    mg_matrices.resize(0, nlevels - 1);'
p33523
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p33524
aS'      {'
p33525
aS'        typename MatrixFree<dim, float>::AdditionalData additional_data;'
p33526
aS'        additional_data.tasks_parallel_scheme ='
p33527
aS'          MatrixFree<dim, float>::AdditionalData::none;'
p33528
aS'        additional_data.mapping_update_flags ='
p33529
aS'          (update_gradients | update_JxW_values);'
p33530
aS'        additional_data.mapping_update_flags_inner_faces ='
p33531
aS'          (update_gradients | update_JxW_values);'
p33532
aS'        additional_data.mapping_update_flags_boundary_faces ='
p33533
aS'          (update_gradients | update_JxW_values);'
p33534
aS'        additional_data.mg_level = level;'
p33535
aS'        const auto mg_mf_storage_level ='
p33536
aS'          std::make_shared<MatrixFree<dim, float>>();'
p33537
aS'        mg_mf_storage_level->reinit(mapping,'
p33538
aS'                                    dof_handler,'
p33539
aS'                                    dummy,'
p33540
aS'                                    QGauss<1>(fe.degree + 1),'
p33541
aS'                                    additional_data);'
p33542
aS'        mg_matrices[level].initialize(mg_mf_storage_level);'
p33543
aS'      }'
p33544
aS'    setup_time += time.wall_time();'
p33545
aS'    time_details << "Setup matrix-free levels      " << time.wall_time() << " s"'
p33546
aS'                 << std::endl;'
p33547
aS'  }'
p33548
aS'  template <int dim, int fe_degree>'
p33549
aS'  void LaplaceProblem<dim, fe_degree>::compute_rhs()'
p33550
aS'  {'
p33551
aS'    Timer time;'
p33552
aS'    system_rhs                          = 0;'
p33553
aS'    const MatrixFree<dim, double> &data = *system_matrix.get_matrix_free();'
p33554
aS'    FEEvaluation<dim, fe_degree>   phi(data);'
p33555
aS'    RightHandSide<dim>             rhs_func;'
p33556
aS'    Solution<dim>                  exact_solution;'
p33557
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p33558
aS'      {'
p33559
aS'        phi.reinit(cell);'
p33560
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p33561
aS'          {'
p33562
aS'            VectorizedArray<double> rhs_val = VectorizedArray<double>();'
p33563
aS'            Point<dim, VectorizedArray<double>> point_batch ='
p33564
aS'              phi.quadrature_point(q);'
p33565
aS'            for (unsigned int v = 0; v < VectorizedArray<double>::size(); ++v)'
p33566
aS'              {'
p33567
aS'                Point<dim> single_point;'
p33568
aS'                for (unsigned int d = 0; d < dim; ++d)'
p33569
aS'                  single_point[d] = point_batch[d][v];'
p33570
aS'                rhs_val[v] = rhs_func.value(single_point);'
p33571
aS'              }'
p33572
aS'            phi.submit_value(rhs_val, q);'
p33573
aS'          }'
p33574
aS'        phi.integrate_scatter(EvaluationFlags::values, system_rhs);'
p33575
aS'      }'
p33576
aS'    FEFaceEvaluation<dim, fe_degree> phi_face(data, true);'
p33577
aS'    for (unsigned int face = data.n_inner_face_batches();'
p33578
aS'         face < data.n_inner_face_batches() + data.n_boundary_face_batches();'
p33579
aS'         ++face)'
p33580
aS'      {'
p33581
aS'        phi_face.reinit(face);'
p33582
aS'        const VectorizedArray<double> inverse_length_normal_to_face ='
p33583
aS'          std::abs((phi_face.get_normal_vector(0) *'
p33584
aS'                    phi_face.inverse_jacobian(0))[dim - 1]);'
p33585
aS'        const VectorizedArray<double> sigma ='
p33586
aS'          inverse_length_normal_to_face * system_matrix.get_penalty_factor();'
p33587
aS'        for (unsigned int q = 0; q < phi_face.n_q_points; ++q)'
p33588
aS'          {'
p33589
aS'            VectorizedArray<double> test_value = VectorizedArray<double>(),'
p33590
aS'                                    test_normal_derivative ='
p33591
aS'                                      VectorizedArray<double>();'
p33592
aS'            Point<dim, VectorizedArray<double>> point_batch ='
p33593
aS'              phi_face.quadrature_point(q);'
p33594
aS'            for (unsigned int v = 0; v < VectorizedArray<double>::size(); ++v)'
p33595
aS'              {'
p33596
aS'                Point<dim> single_point;'
p33597
aS'                for (unsigned int d = 0; d < dim; ++d)'
p33598
aS'                  single_point[d] = point_batch[d][v];'
p33599
aS'                if (data.get_boundary_id(face) == 0)'
p33600
aS'                  test_value[v] = 2.0 * exact_solution.value(single_point);'
p33601
aS'                else'
p33602
aS'                  {'
p33603
aS'                    Tensor<1, dim> normal;'
p33604
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p33605
aS'                      normal[d] = phi_face.get_normal_vector(q)[d][v];'
p33606
aS'                    test_normal_derivative[v] ='
p33607
aS'                      -normal * exact_solution.gradient(single_point);'
p33608
aS'                  }'
p33609
aS'              }'
p33610
aS'            phi_face.submit_value(test_value * sigma - test_normal_derivative,'
p33611
aS'                                  q);'
p33612
aS'            phi_face.submit_normal_derivative(-0.5 * test_value, q);'
p33613
aS'          }'
p33614
aS'        phi_face.integrate_scatter(EvaluationFlags::values |'
p33615
aS'                                     EvaluationFlags::gradients,'
p33616
aS'                                   system_rhs);'
p33617
aS'      }'
p33618
aS'    system_rhs.compress(VectorOperation::add);'
p33619
aS'    setup_time += time.wall_time();'
p33620
aS'    time_details << "Compute right hand side       " << time.wall_time()'
p33621
aS'                 << " s\\n";'
p33622
aS'  }'
p33623
aS'  template <int dim, int fe_degree>'
p33624
aS'  void LaplaceProblem<dim, fe_degree>::solve()'
p33625
aS'  {'
p33626
aS'    Timer                            time;'
p33627
aS'    MGTransferMatrixFree<dim, float> mg_transfer;'
p33628
aS'    mg_transfer.build(dof_handler);'
p33629
aS'    setup_time += time.wall_time();'
p33630
aS'    time_details << "MG build transfer time        " << time.wall_time()'
p33631
aS'                 << " s\\n";'
p33632
aS'    time.restart();'
p33633
aS'    using SmootherType ='
p33634
aS'      PreconditionChebyshev<LevelMatrixType,'
p33635
aS'                            LinearAlgebra::distributed::Vector<float>,'
p33636
aS'                            PreconditionBlockJacobi<dim, fe_degree, float>>;'
p33637
aS'    mg::SmootherRelaxation<SmootherType,'
p33638
aS'                           LinearAlgebra::distributed::Vector<float>>'
p33639
aS'                                                         mg_smoother;'
p33640
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data;'
p33641
aS'    smoother_data.resize(0, triangulation.n_global_levels() - 1);'
p33642
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p33643
aS'         ++level)'
p33644
aS'      {'
p33645
aS'        if (level > 0)'
p33646
aS'          {'
p33647
aS'            smoother_data[level].smoothing_range     = 15.;'
p33648
aS'            smoother_data[level].degree              = 3;'
p33649
aS'            smoother_data[level].eig_cg_n_iterations = 10;'
p33650
aS'          }'
p33651
aS'        else'
p33652
aS'          {'
p33653
aS'            smoother_data[0].smoothing_range = 2e-2;'
p33654
aS'            smoother_data[0].degree          = numbers::invalid_unsigned_int;'
p33655
aS'            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();'
p33656
aS'          }'
p33657
aS'        smoother_data[level].preconditioner ='
p33658
aS'          std::make_shared<PreconditionBlockJacobi<dim, fe_degree, float>>();'
p33659
aS'        smoother_data[level].preconditioner->initialize(mg_matrices[level]);'
p33660
aS'      }'
p33661
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p33662
aS'    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>>'
p33663
aS'      mg_coarse;'
p33664
aS'    mg_coarse.initialize(mg_smoother);'
p33665
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix('
p33666
aS'      mg_matrices);'
p33667
aS'    Multigrid<LinearAlgebra::distributed::Vector<float>> mg('
p33668
aS'      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p33669
aS'    PreconditionMG<dim,'
p33670
aS'                   LinearAlgebra::distributed::Vector<float>,'
p33671
aS'                   MGTransferMatrixFree<dim, float>>'
p33672
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p33673
aS'    SolverControl solver_control(10000, 1e-12 * system_rhs.l2_norm());'
p33674
aS'    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control);'
p33675
aS'    setup_time += time.wall_time();'
p33676
aS'    time_details << "MG build smoother time        " << time.wall_time()'
p33677
aS'                 << "s\\n";'
p33678
aS'    pcout << "Total setup time              " << setup_time << " s\\n";'
p33679
aS'    time.reset();'
p33680
aS'    time.start();'
p33681
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p33682
aS'    pcout << "Time solve (" << solver_control.last_step() << " iterations)    "'
p33683
aS'          << time.wall_time() << " s" << std::endl;'
p33684
aS'  }'
p33685
aS'  template <int dim, int fe_degree>'
p33686
aS'  void LaplaceProblem<dim, fe_degree>::analyze_results() const'
p33687
aS'  {'
p33688
aS'    Vector<float> error_per_cell(triangulation.n_active_cells());'
p33689
aS'    VectorTools::integrate_difference(mapping,'
p33690
aS'                                      dof_handler,'
p33691
aS'                                      solution,'
p33692
aS'                                      Solution<dim>(),'
p33693
aS'                                      error_per_cell,'
p33694
aS'                                      QGauss<dim>(fe.degree + 2),'
p33695
aS'                                      VectorTools::L2_norm);'
p33696
aS'    pcout << "Verification via L2 error:    "'
p33697
aS'          << std::sqrt('
p33698
aS'               Utilities::MPI::sum(error_per_cell.norm_sqr(), MPI_COMM_WORLD))'
p33699
aS'          << std::endl;'
p33700
aS'  }'
p33701
aS'  template <int dim, int fe_degree>'
p33702
aS'  void LaplaceProblem<dim, fe_degree>::run()'
p33703
aS'  {'
p33704
aS'    const unsigned int n_ranks ='
p33705
aS'      Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD);'
p33706
aS'    pcout << "Running with " << n_ranks << " MPI process"'
p33707
aS'          << (n_ranks > 1 ? "es" : "") << ", element " << fe.get_name()'
p33708
aS'          << std::endl'
p33709
aS'          << std::endl;'
p33710
aS'    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle)'
p33711
aS'      {'
p33712
aS'        pcout << "Cycle " << cycle << std::endl;'
p33713
aS'        if (cycle == 0)'
p33714
aS'          {'
p33715
aS'            Point<dim> upper_right;'
p33716
aS'            upper_right[0] = 2.5;'
p33717
aS'            for (unsigned int d = 1; d < dim; ++d)'
p33718
aS'              upper_right[d] = 2.8;'
p33719
aS'            GridGenerator::hyper_rectangle(triangulation,'
p33720
aS'                                           Point<dim>(),'
p33721
aS'                                           upper_right);'
p33722
aS'            triangulation.begin_active()->face(0)->set_boundary_id(10);'
p33723
aS'            triangulation.begin_active()->face(1)->set_boundary_id(11);'
p33724
aS'            triangulation.begin_active()->face(2)->set_boundary_id(0);'
p33725
aS'            for (unsigned int f = 3;'
p33726
aS'                 f < triangulation.begin_active()->n_faces();'
p33727
aS'                 ++f)'
p33728
aS'              triangulation.begin_active()->face(f)->set_boundary_id(1);'
p33729
aS'            std::vector<GridTools::PeriodicFacePair<'
p33730
aS'              typename Triangulation<dim>::cell_iterator>>'
p33731
aS'              periodic_faces;'
p33732
aS'            GridTools::collect_periodic_faces('
p33733
aS'              triangulation, 10, 11, 0, periodic_faces);'
p33734
aS'            triangulation.add_periodicity(periodic_faces);'
p33735
aS'            triangulation.refine_global(6 - 2 * dim);'
p33736
aS'          }'
p33737
aS'        triangulation.refine_global(1);'
p33738
aS'        setup_system();'
p33739
aS'        compute_rhs();'
p33740
aS'        solve();'
p33741
aS'        analyze_results();'
p33742
aS'        pcout << std::endl;'
p33743
aS'      };'
p33744
aS'  }'
p33745
aS'} // namespace Step59'
p33746
aS'int main(int argc, char *argv[])'
p33747
ag24
aS'  try'
p33748
aS'    {'
p33749
aS'      using namespace Step59;'
p33750
aS'      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);'
p33751
aS'      LaplaceProblem<dimension, degree_finite_element> laplace_problem;'
p33752
aS'      laplace_problem.run();'
p33753
aS'    }'
p33754
aS'  catch (std::exception &exc)'
p33755
aS'    {'
p33756
aS'      std::cerr << std::endl'
p33757
aS'                << std::endl'
p33758
aS'                << "----------------------------------------------------"'
p33759
aS'                << std::endl;'
p33760
aS'      std::cerr << "Exception on processing: " << std::endl'
p33761
aS'                << exc.what() << std::endl'
p33762
aS'                << "Aborting!" << std::endl'
p33763
aS'                << "----------------------------------------------------"'
p33764
aS'                << std::endl;'
p33765
aS'      return 1;'
p33766
aS'    }'
p33767
aS'  catch (...)'
p33768
aS'    {'
p33769
aS'      std::cerr << std::endl'
p33770
aS'                << std::endl'
p33771
aS'                << "----------------------------------------------------"'
p33772
aS'                << std::endl;'
p33773
aS'      std::cerr << "Unknown exception!" << std::endl'
p33774
aS'                << "Aborting!" << std::endl'
p33775
aS'                << "----------------------------------------------------"'
p33776
aS'                << std::endl;'
p33777
aS'      return 1;'
p33778
aS'    }'
p33779
aS'  return 0;'
p33780
ag32
aS'/* ---------------------------------------------------------------------'
p33781
aS' *'
p33782
aS' * Copyright (C) 2000 - 2020 by the deal.II authors'
p33783
aS' *'
p33784
aS' * This file is part of the deal.II library.'
p33785
aS' *'
p33786
aS' * The deal.II library is free software; you can use it, redistribute'
p33787
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p33788
aS' * Public License as published by the Free Software Foundation; either'
p33789
aS' * version 2.1 of the License, or (at your option) any later version.'
p33790
aS' * The full text of the license can be found in the file LICENSE.md at'
p33791
aS' * the top level directory of deal.II.'
p33792
aS' *'
p33793
aS' * ---------------------------------------------------------------------'
p33794
aS' *'
p33795
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 2000'
p33796
aS' */'
p33797
aS'#include <deal.II/base/quadrature_lib.h>'
p33798
aS'#include <deal.II/dofs/dof_handler.h>'
p33799
aS'#include <deal.II/dofs/dof_tools.h>'
p33800
aS'#include <deal.II/fe/fe_values.h>'
p33801
aS'#include <deal.II/grid/tria.h>'
p33802
aS'#include <deal.II/grid/grid_generator.h>'
p33803
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p33804
aS'#include <deal.II/lac/full_matrix.h>'
p33805
aS'#include <deal.II/lac/precondition.h>'
p33806
aS'#include <deal.II/lac/solver_cg.h>'
p33807
aS'#include <deal.II/lac/sparse_matrix.h>'
p33808
aS'#include <deal.II/lac/vector.h>'
p33809
aS'#include <deal.II/numerics/data_out.h>'
p33810
aS'#include <deal.II/numerics/vector_tools.h>'
p33811
aS'#include <fstream>'
p33812
aS'#include <deal.II/fe/fe_q.h>'
p33813
aS'#include <deal.II/grid/grid_out.h>'
p33814
aS'#include <deal.II/lac/affine_constraints.h>'
p33815
aS'#include <deal.II/grid/grid_refinement.h>'
p33816
aS'#include <deal.II/numerics/error_estimator.h>'
p33817
aS'using namespace dealii;'
p33818
aS'template <int dim>'
p33819
aS'class Step6'
p33820
ag24
aS'public:'
p33821
aS'  Step6();'
p33822
aS'  void run();'
p33823
aS'private:'
p33824
aS'  void setup_system();'
p33825
aS'  void assemble_system();'
p33826
aS'  void solve();'
p33827
aS'  void refine_grid();'
p33828
aS'  void output_results(const unsigned int cycle) const;'
p33829
aS'  Triangulation<dim> triangulation;'
p33830
aS'  FE_Q<dim>       fe;'
p33831
aS'  DoFHandler<dim> dof_handler;'
p33832
aS'  AffineConstraints<double> constraints;'
p33833
aS'  SparseMatrix<double> system_matrix;'
p33834
aS'  SparsityPattern      sparsity_pattern;'
p33835
aS'  Vector<double> solution;'
p33836
aS'  Vector<double> system_rhs;'
p33837
aS'};'
p33838
aS'template <int dim>'
p33839
aS'double coefficient(const Point<dim> &p)'
p33840
ag24
aS'  if (p.square() < 0.5 * 0.5)'
p33841
aS'    return 20;'
p33842
aS'  else'
p33843
aS'    return 1;'
p33844
ag32
aS'template <int dim>'
p33845
aS'Step6<dim>::Step6()'
p33846
aS'  : fe(2)'
p33847
aS'  , dof_handler(triangulation)'
p33848
aS'{}'
p33849
aS'template <int dim>'
p33850
aS'void Step6<dim>::setup_system()'
p33851
ag24
aS'  dof_handler.distribute_dofs(fe);'
p33852
aS'  solution.reinit(dof_handler.n_dofs());'
p33853
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p33854
aS'  constraints.clear();'
p33855
aS'  DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p33856
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p33857
aS'                                           0,'
p33858
aS'                                           Functions::ZeroFunction<dim>(),'
p33859
aS'                                           constraints);'
p33860
aS'  constraints.close();'
p33861
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p33862
aS'  DoFTools::make_sparsity_pattern(dof_handler,'
p33863
aS'                                  dsp,'
p33864
aS'                                  constraints,'
p33865
aS'  sparsity_pattern.copy_from(dsp);'
p33866
aS'  system_matrix.reinit(sparsity_pattern);'
p33867
ag32
aS'template <int dim>'
p33868
aS'void Step6<dim>::assemble_system()'
p33869
ag24
aS'  const QGauss<dim> quadrature_formula(fe.degree + 1);'
p33870
aS'  FEValues<dim> fe_values(fe,'
p33871
aS'                          quadrature_formula,'
p33872
aS'                          update_values | update_gradients |'
p33873
aS'                            update_quadrature_points | update_JxW_values);'
p33874
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p33875
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p33876
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p33877
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p33878
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p33879
aS'    {'
p33880
aS'      cell_matrix = 0;'
p33881
aS'      cell_rhs    = 0;'
p33882
aS'      fe_values.reinit(cell);'
p33883
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p33884
aS'        {'
p33885
aS'          const double current_coefficient ='
p33886
aS'            coefficient(fe_values.quadrature_point(q_index));'
p33887
aS'          for (const unsigned int i : fe_values.dof_indices())'
p33888
aS'            {'
p33889
aS'              for (const unsigned int j : fe_values.dof_indices())'
p33890
aS'                cell_matrix(i, j) +='
p33891
aS'                  (current_coefficient *              // a(x_q)'
p33892
aS'                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p33893
aS'                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p33894
aS'                   fe_values.JxW(q_index));           // dx'
p33895
aS'              cell_rhs(i) += (1.0 *                               // f(x)'
p33896
aS'                              fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p33897
aS'                              fe_values.JxW(q_index));            // dx'
p33898
aS'            }'
p33899
aS'        }'
p33900
aS'      cell->get_dof_indices(local_dof_indices);'
p33901
aS'      constraints.distribute_local_to_global('
p33902
aS'        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p33903
aS'    }'
p33904
ag32
aS'template <int dim>'
p33905
aS'void Step6<dim>::solve()'
p33906
ag24
aS'  SolverControl            solver_control(1000, 1e-12);'
p33907
aS'  SolverCG<Vector<double>> solver(solver_control);'
p33908
aS'  PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p33909
aS'  preconditioner.initialize(system_matrix, 1.2);'
p33910
aS'  solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p33911
aS'  constraints.distribute(solution);'
p33912
ag32
aS'template <int dim>'
p33913
aS'void Step6<dim>::refine_grid()'
p33914
ag24
aS'  Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p33915
aS'  KellyErrorEstimator<dim>::estimate(dof_handler,'
p33916
aS'                                     QGauss<dim - 1>(fe.degree + 1),'
p33917
aS'                                     {},'
p33918
aS'                                     solution,'
p33919
aS'                                     estimated_error_per_cell);'
p33920
aS'  GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p33921
aS'                                                  estimated_error_per_cell,'
p33922
aS'                                                  0.3,'
p33923
aS'                                                  0.03);'
p33924
aS'  triangulation.execute_coarsening_and_refinement();'
p33925
ag32
aS'template <int dim>'
p33926
aS'void Step6<dim>::output_results(const unsigned int cycle) const'
p33927
ag24
aS'  {'
p33928
aS'    GridOut               grid_out;'
p33929
aS'    std::ofstream         output("grid-" + std::to_string(cycle) + ".gnuplot");'
p33930
aS'    GridOutFlags::Gnuplot gnuplot_flags(false, 5);'
p33931
aS'    grid_out.set_flags(gnuplot_flags);'
p33932
aS'    MappingQGeneric<dim> mapping(3);'
p33933
aS'    grid_out.write_gnuplot(triangulation, output, &mapping);'
p33934
aS'  }'
p33935
aS'  {'
p33936
aS'    DataOut<dim> data_out;'
p33937
aS'    data_out.attach_dof_handler(dof_handler);'
p33938
aS'    data_out.add_data_vector(solution, "solution");'
p33939
aS'    data_out.build_patches();'
p33940
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtu");'
p33941
aS'    data_out.write_vtu(output);'
p33942
aS'  }'
p33943
ag32
aS'template <int dim>'
p33944
aS'void Step6<dim>::run()'
p33945
ag24
aS'  for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p33946
aS'    {'
p33947
aS'      std::cout << "Cycle " << cycle << \':\' << std::endl;'
p33948
aS'      if (cycle == 0)'
p33949
aS'        {'
p33950
aS'          GridGenerator::hyper_ball(triangulation);'
p33951
aS'          triangulation.refine_global(1);'
p33952
aS'        }'
p33953
aS'      else'
p33954
aS'        refine_grid();'
p33955
aS'      std::cout << "   Number of active cells:       "'
p33956
aS'                << triangulation.n_active_cells() << std::endl;'
p33957
aS'      setup_system();'
p33958
aS'      std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p33959
aS'                << std::endl;'
p33960
aS'      assemble_system();'
p33961
aS'      solve();'
p33962
aS'      output_results(cycle);'
p33963
aS'    }'
p33964
ag32
aS'int main()'
p33965
ag24
aS'  try'
p33966
aS'    {'
p33967
aS'      Step6<2> laplace_problem_2d;'
p33968
aS'      laplace_problem_2d.run();'
p33969
aS'    }'
p33970
aS'  catch (std::exception &exc)'
p33971
aS'    {'
p33972
aS'      std::cerr << std::endl'
p33973
aS'                << std::endl'
p33974
aS'                << "----------------------------------------------------"'
p33975
aS'                << std::endl;'
p33976
aS'      std::cerr << "Exception on processing: " << std::endl'
p33977
aS'                << exc.what() << std::endl'
p33978
aS'                << "Aborting!" << std::endl'
p33979
aS'                << "----------------------------------------------------"'
p33980
aS'                << std::endl;'
p33981
aS'      return 1;'
p33982
aS'    }'
p33983
aS'  catch (...)'
p33984
aS'    {'
p33985
aS'      std::cerr << std::endl'
p33986
aS'                << std::endl'
p33987
aS'                << "----------------------------------------------------"'
p33988
aS'                << std::endl;'
p33989
aS'      std::cerr << "Unknown exception!" << std::endl'
p33990
aS'                << "Aborting!" << std::endl'
p33991
aS'                << "----------------------------------------------------"'
p33992
aS'                << std::endl;'
p33993
aS'      return 1;'
p33994
aS'    }'
p33995
aS'  return 0;'
p33996
ag32
aS'/* ---------------------------------------------------------------------'
p33997
aS' *'
p33998
aS' * Copyright (C) 2018 - 2020 by the deal.II authors'
p33999
aS' *'
p34000
aS' * This file is part of the deal.II library.'
p34001
aS' *'
p34002
aS' * The deal.II library is free software; you can use it, redistribute'
p34003
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p34004
aS' * Public License as published by the Free Software Foundation; either'
p34005
aS' * version 2.1 of the License, or (at your option) any later version.'
p34006
aS' * The full text of the license can be found in the file LICENSE.md at'
p34007
aS' * the top level directory of deal.II.'
p34008
aS' *'
p34009
aS' * ---------------------------------------------------------------------'
p34010
aS' *'
p34011
aS' * Authors: Luca Heltai, Giovanni Alzetta,'
p34012
aS' * International School for Advanced Studies, Trieste, 2018'
p34013
aS' */'
p34014
aS'#include <deal.II/base/logstream.h>'
p34015
aS'#include <deal.II/base/utilities.h>'
p34016
aS'#include <deal.II/base/timer.h>'
p34017
aS'#include <deal.II/base/parameter_acceptor.h>'
p34018
aS'#include <deal.II/grid/tria.h>'
p34019
aS'#include <deal.II/grid/grid_generator.h>'
p34020
aS'#include <deal.II/grid/grid_tools.h>'
p34021
aS'#include <deal.II/grid/grid_tools_cache.h>'
p34022
aS'#include <deal.II/fe/fe.h>'
p34023
aS'#include <deal.II/fe/fe_q.h>'
p34024
aS'#include <deal.II/fe/fe_system.h>'
p34025
aS'#include <deal.II/fe/mapping_q_eulerian.h>'
p34026
aS'#include <deal.II/fe/mapping_fe_field.h>'
p34027
aS'#include <deal.II/dofs/dof_tools.h>'
p34028
aS'#include <deal.II/base/parsed_function.h>'
p34029
aS'#include <deal.II/numerics/data_out.h>'
p34030
aS'#include <deal.II/numerics/vector_tools.h>'
p34031
aS'#include <deal.II/numerics/matrix_tools.h>'
p34032
aS'#include <deal.II/non_matching/coupling.h>'
p34033
aS'#include <deal.II/lac/affine_constraints.h>'
p34034
aS'#include <deal.II/lac/sparse_matrix.h>'
p34035
aS'#include <deal.II/lac/vector.h>'
p34036
aS'#include <deal.II/lac/sparse_direct.h>'
p34037
aS'#include <deal.II/lac/solver_cg.h>'
p34038
aS'#include <deal.II/lac/precondition.h>'
p34039
aS'#include <deal.II/lac/linear_operator.h>'
p34040
aS'#include <deal.II/lac/linear_operator_tools.h>'
p34041
aS'#include <iostream>'
p34042
aS'#include <fstream>'
p34043
aS'namespace Step60'
p34044
ag24
aS'  using namespace dealii;'
p34045
aS'  template <int dim, int spacedim = dim>'
p34046
aS'  class DistributedLagrangeProblem'
p34047
aS'  {'
p34048
aS'  public:'
p34049
aS'    class Parameters : public ParameterAcceptor'
p34050
aS'    {'
p34051
aS'    public:'
p34052
aS'      Parameters();'
p34053
aS'      unsigned int initial_refinement = 4;'
p34054
aS'      unsigned int delta_refinement = 3;'
p34055
aS'      unsigned int initial_embedded_refinement = 8;'
p34056
aS'      std::list<types::boundary_id> homogeneous_dirichlet_ids{0, 1, 2, 3};'
p34057
aS'      unsigned int embedding_space_finite_element_degree = 1;'
p34058
aS'      unsigned int embedded_space_finite_element_degree = 1;'
p34059
aS'      unsigned int embedded_configuration_finite_element_degree = 1;'
p34060
aS'      unsigned int coupling_quadrature_order = 3;'
p34061
aS'      bool use_displacement = false;'
p34062
aS'      unsigned int verbosity_level = 10;'
p34063
aS'      bool initialized = false;'
p34064
aS'    };'
p34065
aS'    DistributedLagrangeProblem(const Parameters &parameters);'
p34066
aS'    void run();'
p34067
aS'  private:'
p34068
aS'    const Parameters &parameters;'
p34069
aS'    void setup_grids_and_dofs();'
p34070
aS'    void setup_embedding_dofs();'
p34071
aS'    void setup_embedded_dofs();'
p34072
aS'    void setup_coupling();'
p34073
aS'    void assemble_system();'
p34074
aS'    void solve();'
p34075
aS'    void output_results();'
p34076
aS'    std::unique_ptr<Triangulation<spacedim>> space_grid;'
p34077
aS'    std::unique_ptr<GridTools::Cache<spacedim, spacedim>>'
p34078
aS'                                             space_grid_tools_cache;'
p34079
aS'    std::unique_ptr<FiniteElement<spacedim>> space_fe;'
p34080
aS'    std::unique_ptr<DoFHandler<spacedim>>    space_dh;'
p34081
aS'    std::unique_ptr<Triangulation<dim, spacedim>> embedded_grid;'
p34082
aS'    std::unique_ptr<FiniteElement<dim, spacedim>> embedded_fe;'
p34083
aS'    std::unique_ptr<DoFHandler<dim, spacedim>>    embedded_dh;'
p34084
aS'    std::unique_ptr<FiniteElement<dim, spacedim>> embedded_configuration_fe;'
p34085
aS'    std::unique_ptr<DoFHandler<dim, spacedim>>    embedded_configuration_dh;'
p34086
aS'    Vector<double>                                embedded_configuration;'
p34087
aS'    ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>'
p34088
aS'      embedded_configuration_function;'
p34089
aS'    std::unique_ptr<Mapping<dim, spacedim>> embedded_mapping;'
p34090
aS'    ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>'
p34091
aS'      embedded_value_function;'
p34092
aS'    ParameterAcceptorProxy<ReductionControl> schur_solver_control;'
p34093
aS'    SparsityPattern stiffness_sparsity;'
p34094
aS'    SparsityPattern coupling_sparsity;'
p34095
aS'    SparseMatrix<double> stiffness_matrix;'
p34096
aS'    SparseMatrix<double> coupling_matrix;'
p34097
aS'    AffineConstraints<double> constraints;'
p34098
aS'    Vector<double> solution;'
p34099
aS'    Vector<double> rhs;'
p34100
aS'    Vector<double> lambda;'
p34101
aS'    Vector<double> embedded_rhs;'
p34102
aS'    Vector<double> embedded_value;'
p34103
aS'    TimerOutput monitor;'
p34104
aS'  };'
p34105
aS'  template <int dim, int spacedim>'
p34106
aS'  DistributedLagrangeProblem<dim, spacedim>::Parameters::Parameters()'
p34107
aS'    : ParameterAcceptor("/Distributed Lagrange<" +'
p34108
aS'                        Utilities::int_to_string(dim) + "," +'
p34109
aS'                        Utilities::int_to_string(spacedim) + ">/")'
p34110
aS'  {'
p34111
aS'    add_parameter("Initial embedding space refinement", initial_refinement);'
p34112
aS'    add_parameter("Initial embedded space refinement",'
p34113
aS'                  initial_embedded_refinement);'
p34114
aS'    add_parameter("Local refinements steps near embedded domain",'
p34115
aS'                  delta_refinement);'
p34116
aS'    add_parameter("Homogeneous Dirichlet boundary ids",'
p34117
aS'                  homogeneous_dirichlet_ids);'
p34118
aS'    add_parameter("Use displacement in embedded interface", use_displacement);'
p34119
aS'    add_parameter("Embedding space finite element degree",'
p34120
aS'                  embedding_space_finite_element_degree);'
p34121
aS'    add_parameter("Embedded space finite element degree",'
p34122
aS'                  embedded_space_finite_element_degree);'
p34123
aS'    add_parameter("Embedded configuration finite element degree",'
p34124
aS'                  embedded_configuration_finite_element_degree);'
p34125
aS'    add_parameter("Coupling quadrature order", coupling_quadrature_order);'
p34126
aS'    add_parameter("Verbosity level", verbosity_level);'
p34127
aS'    parse_parameters_call_back.connect([&]() -> void { initialized = true; });'
p34128
aS'  }'
p34129
aS'  template <int dim, int spacedim>'
p34130
aS'  DistributedLagrangeProblem<dim, spacedim>::DistributedLagrangeProblem('
p34131
aS'    const Parameters &parameters)'
p34132
aS'    : parameters(parameters)'
p34133
aS'    , embedded_configuration_function("Embedded configuration", spacedim)'
p34134
aS'    , embedded_value_function("Embedded value")'
p34135
aS'    , schur_solver_control("Schur solver control")'
p34136
aS'    , monitor(std::cout, TimerOutput::summary, TimerOutput::cpu_and_wall_times)'
p34137
aS'  {'
p34138
aS'    embedded_configuration_function.declare_parameters_call_back.connect('
p34139
aS'      []() -> void {'
p34140
aS'        ParameterAcceptor::prm.set("Function constants", "R=.3, Cx=.4, Cy=.4");'
p34141
aS'        ParameterAcceptor::prm.set("Function expression",'
p34142
aS'                                   "R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy");'
p34143
aS'      });'
p34144
aS'    embedded_value_function.declare_parameters_call_back.connect('
p34145
aS'      []() -> void { ParameterAcceptor::prm.set("Function expression", "1"); });'
p34146
aS'    schur_solver_control.declare_parameters_call_back.connect([]() -> void {'
p34147
aS'      ParameterAcceptor::prm.set("Max steps", "1000");'
p34148
aS'      ParameterAcceptor::prm.set("Reduction", "1.e-12");'
p34149
aS'      ParameterAcceptor::prm.set("Tolerance", "1.e-12");'
p34150
aS'    });'
p34151
aS'  }'
p34152
aS'  template <int dim, int spacedim>'
p34153
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_grids_and_dofs()'
p34154
aS'  {'
p34155
aS'    TimerOutput::Scope timer_section(monitor, "Setup grids and dofs");'
p34156
aS'    space_grid = std::make_unique<Triangulation<spacedim>>();'
p34157
aS'    GridGenerator::hyper_cube(*space_grid, 0, 1, true);'
p34158
aS'    space_grid->refine_global(parameters.initial_refinement);'
p34159
aS'    space_grid_tools_cache ='
p34160
aS'      std::make_unique<GridTools::Cache<spacedim, spacedim>>(*space_grid);'
p34161
aS'    embedded_grid = std::make_unique<Triangulation<dim, spacedim>>();'
p34162
aS'    GridGenerator::hyper_cube(*embedded_grid);'
p34163
aS'    embedded_grid->refine_global(parameters.initial_embedded_refinement);'
p34164
aS'    embedded_configuration_fe = std::make_unique<FESystem<dim, spacedim>>('
p34165
aS'      FE_Q<dim, spacedim>('
p34166
aS'        parameters.embedded_configuration_finite_element_degree),'
p34167
aS'      spacedim);'
p34168
aS'    embedded_configuration_dh ='
p34169
aS'      std::make_unique<DoFHandler<dim, spacedim>>(*embedded_grid);'
p34170
aS'    embedded_configuration_dh->distribute_dofs(*embedded_configuration_fe);'
p34171
aS'    embedded_configuration.reinit(embedded_configuration_dh->n_dofs());'
p34172
aS'    VectorTools::interpolate(*embedded_configuration_dh,'
p34173
aS'                             embedded_configuration_function,'
p34174
aS'                             embedded_configuration);'
p34175
aS'    if (parameters.use_displacement == true)'
p34176
aS'      embedded_mapping ='
p34177
aS'        std::make_unique<MappingQEulerian<dim, Vector<double>, spacedim>>('
p34178
aS'          parameters.embedded_configuration_finite_element_degree,'
p34179
aS'          *embedded_configuration_dh,'
p34180
aS'          embedded_configuration);'
p34181
aS'    else'
p34182
aS'      embedded_mapping ='
p34183
aS'        std::make_unique<MappingFEField<dim, spacedim, Vector<double>>>('
p34184
aS'          *embedded_configuration_dh, embedded_configuration);'
p34185
aS'    setup_embedded_dofs();'
p34186
aS'    std::vector<Point<spacedim>> support_points(embedded_dh->n_dofs());'
p34187
aS'    if (parameters.delta_refinement != 0)'
p34188
aS'      DoFTools::map_dofs_to_support_points(*embedded_mapping,'
p34189
aS'                                           *embedded_dh,'
p34190
aS'                                           support_points);'
p34191
aS'    for (unsigned int i = 0; i < parameters.delta_refinement; ++i)'
p34192
aS'      {'
p34193
aS'        const auto point_locations ='
p34194
aS'          GridTools::compute_point_locations(*space_grid_tools_cache,'
p34195
aS'                                             support_points);'
p34196
aS'        const auto &cells = std::get<0>(point_locations);'
p34197
aS'        for (auto &cell : cells)'
p34198
aS'          {'
p34199
aS'            cell->set_refine_flag();'
p34200
aS'            for (const auto face_no : cell->face_indices())'
p34201
aS'              if (!cell->at_boundary(face_no))'
p34202
aS'                cell->neighbor(face_no)->set_refine_flag();'
p34203
aS'          }'
p34204
aS'        space_grid->execute_coarsening_and_refinement();'
p34205
aS'      }'
p34206
aS'    const double embedded_space_maximal_diameter ='
p34207
aS'      GridTools::maximal_cell_diameter(*embedded_grid, *embedded_mapping);'
p34208
aS'    double embedding_space_minimal_diameter ='
p34209
aS'      GridTools::minimal_cell_diameter(*space_grid);'
p34210
aS'    deallog << "Embedding minimal diameter: "'
p34211
aS'            << embedding_space_minimal_diameter'
p34212
aS'            << ", embedded maximal diameter: "'
p34213
aS'            << embedded_space_maximal_diameter << ", ratio: "'
p34214
aS'            << embedded_space_maximal_diameter /'
p34215
aS'                 embedding_space_minimal_diameter'
p34216
aS'            << std::endl;'
p34217
aS'    AssertThrow(embedded_space_maximal_diameter <'
p34218
aS'                  embedding_space_minimal_diameter,'
p34219
aS'                ExcMessage('
p34220
aS'                  "The embedding grid is too refined (or the embedded grid "'
p34221
aS'                  "is too coarse). Adjust the parameters so that the minimal "'
p34222
aS'                  "grid size of the embedding grid is larger "'
p34223
aS'                  "than the maximal grid size of the embedded grid."));'
p34224
aS'    setup_embedding_dofs();'
p34225
aS'  }'
p34226
aS'  template <int dim, int spacedim>'
p34227
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_embedding_dofs()'
p34228
aS'  {'
p34229
aS'    space_dh = std::make_unique<DoFHandler<spacedim>>(*space_grid);'
p34230
aS'    space_fe = std::make_unique<FE_Q<spacedim>>('
p34231
aS'      parameters.embedding_space_finite_element_degree);'
p34232
aS'    space_dh->distribute_dofs(*space_fe);'
p34233
aS'    DoFTools::make_hanging_node_constraints(*space_dh, constraints);'
p34234
aS'    for (auto id : parameters.homogeneous_dirichlet_ids)'
p34235
aS'      {'
p34236
aS'        VectorTools::interpolate_boundary_values('
p34237
aS'          *space_dh, id, Functions::ZeroFunction<spacedim>(), constraints);'
p34238
aS'      }'
p34239
aS'    constraints.close();'
p34240
aS'    DynamicSparsityPattern dsp(space_dh->n_dofs(), space_dh->n_dofs());'
p34241
aS'    DoFTools::make_sparsity_pattern(*space_dh, dsp, constraints);'
p34242
aS'    stiffness_sparsity.copy_from(dsp);'
p34243
aS'    stiffness_matrix.reinit(stiffness_sparsity);'
p34244
aS'    solution.reinit(space_dh->n_dofs());'
p34245
aS'    rhs.reinit(space_dh->n_dofs());'
p34246
aS'    deallog << "Embedding dofs: " << space_dh->n_dofs() << std::endl;'
p34247
aS'  }'
p34248
aS'  template <int dim, int spacedim>'
p34249
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_embedded_dofs()'
p34250
aS'  {'
p34251
aS'    embedded_dh = std::make_unique<DoFHandler<dim, spacedim>>(*embedded_grid);'
p34252
aS'    embedded_fe = std::make_unique<FE_Q<dim, spacedim>>('
p34253
aS'      parameters.embedded_space_finite_element_degree);'
p34254
aS'    embedded_dh->distribute_dofs(*embedded_fe);'
p34255
aS'    lambda.reinit(embedded_dh->n_dofs());'
p34256
aS'    embedded_rhs.reinit(embedded_dh->n_dofs());'
p34257
aS'    embedded_value.reinit(embedded_dh->n_dofs());'
p34258
aS'    deallog << "Embedded dofs: " << embedded_dh->n_dofs() << std::endl;'
p34259
aS'  }'
p34260
aS'  template <int dim, int spacedim>'
p34261
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_coupling()'
p34262
aS'  {'
p34263
aS'    TimerOutput::Scope timer_section(monitor, "Setup coupling");'
p34264
aS'    QGauss<dim> quad(parameters.coupling_quadrature_order);'
p34265
aS'    DynamicSparsityPattern dsp(space_dh->n_dofs(), embedded_dh->n_dofs());'
p34266
aS'    NonMatching::create_coupling_sparsity_pattern(*space_grid_tools_cache,'
p34267
aS'                                                  *space_dh,'
p34268
aS'                                                  *embedded_dh,'
p34269
aS'                                                  quad,'
p34270
aS'                                                  dsp,'
p34271
aS'                                                  AffineConstraints<double>(),'
p34272
aS'                                                  ComponentMask(),'
p34273
aS'                                                  ComponentMask(),'
p34274
aS'                                                  *embedded_mapping);'
p34275
aS'    coupling_sparsity.copy_from(dsp);'
p34276
aS'    coupling_matrix.reinit(coupling_sparsity);'
p34277
aS'  }'
p34278
aS'  template <int dim, int spacedim>'
p34279
aS'  void DistributedLagrangeProblem<dim, spacedim>::assemble_system()'
p34280
aS'  {'
p34281
aS'    {'
p34282
aS'      TimerOutput::Scope timer_section(monitor, "Assemble system");'
p34283
aS'      MatrixTools::create_laplace_matrix('
p34284
aS'        *space_dh,'
p34285
aS'        QGauss<spacedim>(2 * space_fe->degree + 1),'
p34286
aS'        stiffness_matrix,'
p34287
aS'        static_cast<const Function<spacedim> *>(nullptr),'
p34288
aS'        constraints);'
p34289
aS'      VectorTools::create_right_hand_side(*embedded_mapping,'
p34290
aS'                                          *embedded_dh,'
p34291
aS'                                          QGauss<dim>(2 * embedded_fe->degree +'
p34292
aS'                                                      1),'
p34293
aS'                                          embedded_value_function,'
p34294
aS'                                          embedded_rhs);'
p34295
aS'    }'
p34296
aS'    {'
p34297
aS'      TimerOutput::Scope timer_section(monitor, "Assemble coupling system");'
p34298
aS'      QGauss<dim> quad(parameters.coupling_quadrature_order);'
p34299
aS'      NonMatching::create_coupling_mass_matrix(*space_grid_tools_cache,'
p34300
aS'                                               *space_dh,'
p34301
aS'                                               *embedded_dh,'
p34302
aS'                                               quad,'
p34303
aS'                                               coupling_matrix,'
p34304
aS'                                               AffineConstraints<double>(),'
p34305
aS'                                               ComponentMask(),'
p34306
aS'                                               ComponentMask(),'
p34307
aS'                                               *embedded_mapping);'
p34308
aS'      VectorTools::interpolate(*embedded_mapping,'
p34309
aS'                               *embedded_dh,'
p34310
aS'                               embedded_value_function,'
p34311
aS'                               embedded_value);'
p34312
aS'    }'
p34313
aS'  }'
p34314
aS'  template <int dim, int spacedim>'
p34315
aS'  void DistributedLagrangeProblem<dim, spacedim>::solve()'
p34316
aS'  {'
p34317
aS'    TimerOutput::Scope timer_section(monitor, "Solve system");'
p34318
aS'    SparseDirectUMFPACK K_inv_umfpack;'
p34319
aS'    K_inv_umfpack.initialize(stiffness_matrix);'
p34320
aS'    auto K  = linear_operator(stiffness_matrix);'
p34321
aS'    auto Ct = linear_operator(coupling_matrix);'
p34322
aS'    auto C  = transpose_operator(Ct);'
p34323
aS'    auto K_inv = linear_operator(K, K_inv_umfpack);'
p34324
aS'    auto                     S = C * K_inv * Ct;'
p34325
aS'    SolverCG<Vector<double>> solver_cg(schur_solver_control);'
p34326
aS'    auto S_inv = inverse_operator(S, solver_cg, PreconditionIdentity());'
p34327
aS'    lambda = S_inv * embedded_rhs;'
p34328
aS'    solution = K_inv * Ct * lambda;'
p34329
aS'    constraints.distribute(solution);'
p34330
aS'  }'
p34331
aS'  template <int dim, int spacedim>'
p34332
aS'  void DistributedLagrangeProblem<dim, spacedim>::output_results()'
p34333
aS'  {'
p34334
aS'    TimerOutput::Scope timer_section(monitor, "Output results");'
p34335
aS'    DataOut<spacedim> embedding_out;'
p34336
aS'    std::ofstream embedding_out_file("embedding.vtu");'
p34337
aS'    embedding_out.attach_dof_handler(*space_dh);'
p34338
aS'    embedding_out.add_data_vector(solution, "solution");'
p34339
aS'    embedding_out.build_patches('
p34340
aS'      parameters.embedding_space_finite_element_degree);'
p34341
aS'    embedding_out.write_vtu(embedding_out_file);'
p34342
aS'    DataOut<dim, spacedim> embedded_out;'
p34343
aS'    std::ofstream embedded_out_file("embedded.vtu");'
p34344
aS'    embedded_out.attach_dof_handler(*embedded_dh);'
p34345
aS'    embedded_out.add_data_vector(lambda, "lambda");'
p34346
aS'    embedded_out.add_data_vector(embedded_value, "g");'
p34347
aS'    embedded_out.build_patches(*embedded_mapping,'
p34348
aS'                               parameters.embedded_space_finite_element_degree);'
p34349
aS'    embedded_out.write_vtu(embedded_out_file);'
p34350
aS'  }'
p34351
aS'  template <int dim, int spacedim>'
p34352
aS'  void DistributedLagrangeProblem<dim, spacedim>::run()'
p34353
aS'  {'
p34354
aS'    AssertThrow(parameters.initialized, ExcNotInitialized());'
p34355
aS'    deallog.depth_console(parameters.verbosity_level);'
p34356
aS'    setup_grids_and_dofs();'
p34357
aS'    setup_coupling();'
p34358
aS'    assemble_system();'
p34359
aS'    solve();'
p34360
aS'    output_results();'
p34361
aS'  }'
p34362
aS'} // namespace Step60'
p34363
aS'int main(int argc, char **argv)'
p34364
ag24
aS'  try'
p34365
aS'    {'
p34366
aS'      using namespace dealii;'
p34367
aS'      using namespace Step60;'
p34368
aS'      const unsigned int dim = 1, spacedim = 2;'
p34369
aS'      DistributedLagrangeProblem<dim, spacedim>::Parameters parameters;'
p34370
aS'      DistributedLagrangeProblem<dim, spacedim>             problem(parameters);'
p34371
aS'      std::string parameter_file;'
p34372
aS'      if (argc > 1)'
p34373
aS'        parameter_file = argv[1];'
p34374
aS'      else'
p34375
aS'        parameter_file = "parameters.prm";'
p34376
aS'      ParameterAcceptor::initialize(parameter_file, "used_parameters.prm");'
p34377
aS'      problem.run();'
p34378
aS'    }'
p34379
aS'  catch (std::exception &exc)'
p34380
aS'    {'
p34381
aS'      std::cerr << std::endl'
p34382
aS'                << std::endl'
p34383
aS'                << "----------------------------------------------------"'
p34384
aS'                << std::endl;'
p34385
aS'      std::cerr << "Exception on processing: " << std::endl'
p34386
aS'                << exc.what() << std::endl'
p34387
aS'                << "Aborting!" << std::endl'
p34388
aS'                << "----------------------------------------------------"'
p34389
aS'                << std::endl;'
p34390
aS'      return 1;'
p34391
aS'    }'
p34392
aS'  catch (...)'
p34393
aS'    {'
p34394
aS'      std::cerr << std::endl'
p34395
aS'                << std::endl'
p34396
aS'                << "----------------------------------------------------"'
p34397
aS'                << std::endl;'
p34398
aS'      std::cerr << "Unknown exception!" << std::endl'
p34399
aS'                << "Aborting!" << std::endl'
p34400
aS'                << "----------------------------------------------------"'
p34401
aS'                << std::endl;'
p34402
aS'      return 1;'
p34403
aS'    }'
p34404
aS'  return 0;'
p34405
ag32
aS'/* ---------------------------------------------------------------------'
p34406
aS' *'
p34407
aS' * Copyright (C) 2018 - 2021 by the deal.II authors'
p34408
aS' *'
p34409
aS' * This file is part of the deal.II library.'
p34410
aS' *'
p34411
aS' * The deal.II library is free software; you can use it, redistribute'
p34412
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p34413
aS' * Public License as published by the Free Software Foundation; either'
p34414
aS' * version 2.1 of the License, or (at your option) any later version.'
p34415
aS' * The full text of the license can be found in the file LICENSE.md at'
p34416
aS' * the top level directory of deal.II.'
p34417
aS' *'
p34418
aS' * ---------------------------------------------------------------------'
p34419
aS' *      Author: Zhuoran Wang, Colorado State University, 2018'
p34420
aS' */'
p34421
aS'#include <deal.II/base/quadrature.h>'
p34422
aS'#include <deal.II/base/quadrature_lib.h>'
p34423
aS'#include <deal.II/base/tensor_function.h>'
p34424
aS'#include <deal.II/base/logstream.h>'
p34425
aS'#include <deal.II/base/function.h>'
p34426
aS'#include <deal.II/base/point.h>'
p34427
aS'#include <deal.II/lac/block_vector.h>'
p34428
aS'#include <deal.II/lac/vector.h>'
p34429
aS'#include <deal.II/lac/full_matrix.h>'
p34430
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p34431
aS'#include <deal.II/lac/sparse_matrix.h>'
p34432
aS'#include <deal.II/lac/solver_cg.h>'
p34433
aS'#include <deal.II/lac/precondition.h>'
p34434
aS'#include <deal.II/lac/affine_constraints.h>'
p34435
aS'#include <deal.II/grid/tria.h>'
p34436
aS'#include <deal.II/grid/grid_generator.h>'
p34437
aS'#include <deal.II/dofs/dof_handler.h>'
p34438
aS'#include <deal.II/dofs/dof_tools.h>'
p34439
aS'#include <deal.II/fe/fe_dgq.h>'
p34440
aS'#include <deal.II/fe/fe_raviart_thomas.h>'
p34441
aS'#include <deal.II/fe/fe_dg_vector.h>'
p34442
aS'#include <deal.II/fe/fe_system.h>'
p34443
aS'#include <deal.II/fe/fe_values.h>'
p34444
aS'#include <deal.II/fe/fe_face.h>'
p34445
aS'#include <deal.II/fe/component_mask.h>'
p34446
aS'#include <deal.II/numerics/vector_tools.h>'
p34447
aS'#include <deal.II/numerics/data_out.h>'
p34448
aS'#include <deal.II/numerics/data_out_faces.h>'
p34449
aS'#include <fstream>'
p34450
aS'#include <iostream>'
p34451
aS'namespace Step61'
p34452
ag24
aS'  using namespace dealii;'
p34453
aS'  template <int dim>'
p34454
aS'  class WGDarcyEquation'
p34455
aS'  {'
p34456
aS'  public:'
p34457
aS'    WGDarcyEquation(const unsigned int degree);'
p34458
aS'    void run();'
p34459
aS'  private:'
p34460
aS'    void make_grid();'
p34461
aS'    void setup_system();'
p34462
aS'    void assemble_system();'
p34463
aS'    void solve();'
p34464
aS'    void compute_postprocessed_velocity();'
p34465
aS'    void compute_velocity_errors();'
p34466
aS'    void compute_pressure_error();'
p34467
aS'    void output_results() const;'
p34468
aS'    Triangulation<dim> triangulation;'
p34469
aS'    FESystem<dim>   fe;'
p34470
aS'    DoFHandler<dim> dof_handler;'
p34471
aS'    AffineConstraints<double> constraints;'
p34472
aS'    SparsityPattern      sparsity_pattern;'
p34473
aS'    SparseMatrix<double> system_matrix;'
p34474
aS'    Vector<double> solution;'
p34475
aS'    Vector<double> system_rhs;'
p34476
aS'    FE_DGRaviartThomas<dim> fe_dgrt;'
p34477
aS'    DoFHandler<dim>         dof_handler_dgrt;'
p34478
aS'    Vector<double>          darcy_velocity;'
p34479
aS'  };'
p34480
aS'  template <int dim>'
p34481
aS'  class Coefficient : public TensorFunction<2, dim>'
p34482
aS'  {'
p34483
aS'  public:'
p34484
aS'    Coefficient()'
p34485
aS'      : TensorFunction<2, dim>()'
p34486
aS'    {}'
p34487
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p34488
aS'                            std::vector<Tensor<2, dim>> &values) const override;'
p34489
aS'  };'
p34490
aS'  template <int dim>'
p34491
aS'  void Coefficient<dim>::value_list(const std::vector<Point<dim>> &points,'
p34492
aS'                                    std::vector<Tensor<2, dim>> &  values) const'
p34493
aS'  {'
p34494
aS'    Assert(points.size() == values.size(),'
p34495
aS'           ExcDimensionMismatch(points.size(), values.size()));'
p34496
aS'    for (unsigned int p = 0; p < points.size(); ++p)'
p34497
aS'      values[p] = unit_symmetric_tensor<dim>();'
p34498
aS'  }'
p34499
aS'  template <int dim>'
p34500
aS'  class BoundaryValues : public Function<dim>'
p34501
aS'  {'
p34502
aS'  public:'
p34503
aS'    BoundaryValues()'
p34504
aS'      : Function<dim>(2)'
p34505
aS'    {}'
p34506
aS'    virtual double value(const Point<dim> & p,'
p34507
aS'                         const unsigned int component = 0) const override;'
p34508
aS'  };'
p34509
aS'  template <int dim>'
p34510
aS'  double BoundaryValues<dim>::value(const Point<dim> & /*p*/,'
p34511
aS'                                    const unsigned int /*component*/) const'
p34512
aS'  {'
p34513
aS'    return 0;'
p34514
aS'  }'
p34515
aS'  template <int dim>'
p34516
aS'  class RightHandSide : public Function<dim>'
p34517
aS'  {'
p34518
aS'  public:'
p34519
aS'    virtual double value(const Point<dim> & p,'
p34520
aS'                         const unsigned int component = 0) const override;'
p34521
aS'  };'
p34522
aS'  template <int dim>'
p34523
aS'  double RightHandSide<dim>::value(const Point<dim> &p,'
p34524
aS'                                   const unsigned int /*component*/) const'
p34525
aS'  {'
p34526
aS'    return (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *'
p34527
aS'            std::sin(numbers::PI * p[1]));'
p34528
aS'  }'
p34529
aS'  template <int dim>'
p34530
aS'  class ExactPressure : public Function<dim>'
p34531
aS'  {'
p34532
aS'  public:'
p34533
aS'    ExactPressure()'
p34534
aS'      : Function<dim>(2)'
p34535
aS'    {}'
p34536
aS'    virtual double value(const Point<dim> & p,'
p34537
aS'                         const unsigned int component) const override;'
p34538
aS'  };'
p34539
aS'  template <int dim>'
p34540
aS'  double ExactPressure<dim>::value(const Point<dim> &p,'
p34541
aS'                                   const unsigned int /*component*/) const'
p34542
aS'  {'
p34543
aS'    return std::sin(numbers::PI * p[0]) * std::sin(numbers::PI * p[1]);'
p34544
aS'  }'
p34545
aS'  template <int dim>'
p34546
aS'  class ExactVelocity : public TensorFunction<1, dim>'
p34547
aS'  {'
p34548
aS'  public:'
p34549
aS'    ExactVelocity()'
p34550
aS'      : TensorFunction<1, dim>()'
p34551
aS'    {}'
p34552
aS'    virtual Tensor<1, dim> value(const Point<dim> &p) const override;'
p34553
aS'  };'
p34554
aS'  template <int dim>'
p34555
aS'  Tensor<1, dim> ExactVelocity<dim>::value(const Point<dim> &p) const'
p34556
aS'  {'
p34557
aS'    Tensor<1, dim> return_value;'
p34558
aS'    return_value[0] = -numbers::PI * std::cos(numbers::PI * p[0]) *'
p34559
aS'                      std::sin(numbers::PI * p[1]);'
p34560
aS'    return_value[1] = -numbers::PI * std::sin(numbers::PI * p[0]) *'
p34561
aS'                      std::cos(numbers::PI * p[1]);'
p34562
aS'    return return_value;'
p34563
aS'  }'
p34564
aS'  template <int dim>'
p34565
aS'  WGDarcyEquation<dim>::WGDarcyEquation(const unsigned int degree)'
p34566
aS'    : fe(FE_DGQ<dim>(degree), 1, FE_FaceQ<dim>(degree), 1)'
p34567
aS'    , dof_handler(triangulation)'
p34568
aS'    , fe_dgrt(degree)'
p34569
aS'    , dof_handler_dgrt(triangulation)'
p34570
aS'  {}'
p34571
aS'  template <int dim>'
p34572
aS'  void WGDarcyEquation<dim>::make_grid()'
p34573
aS'  {'
p34574
aS'    GridGenerator::hyper_cube(triangulation, 0, 1);'
p34575
aS'    triangulation.refine_global(5);'
p34576
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p34577
aS'              << std::endl'
p34578
aS'              << "   Total number of cells: " << triangulation.n_cells()'
p34579
aS'              << std::endl;'
p34580
aS'  }'
p34581
aS'  template <int dim>'
p34582
aS'  void WGDarcyEquation<dim>::setup_system()'
p34583
aS'  {'
p34584
aS'    dof_handler.distribute_dofs(fe);'
p34585
aS'    dof_handler_dgrt.distribute_dofs(fe_dgrt);'
p34586
aS'    std::cout << "   Number of pressure degrees of freedom: "'
p34587
aS'              << dof_handler.n_dofs() << std::endl;'
p34588
aS'    solution.reinit(dof_handler.n_dofs());'
p34589
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p34590
aS'    {'
p34591
aS'      constraints.clear();'
p34592
aS'      const FEValuesExtractors::Scalar interface_pressure(1);'
p34593
aS'      const ComponentMask              interface_pressure_mask ='
p34594
aS'        fe.component_mask(interface_pressure);'
p34595
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p34596
aS'                                               0,'
p34597
aS'                                               BoundaryValues<dim>(),'
p34598
aS'                                               constraints,'
p34599
aS'                                               interface_pressure_mask);'
p34600
aS'      constraints.close();'
p34601
aS'    }'
p34602
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p34603
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p34604
aS'    sparsity_pattern.copy_from(dsp);'
p34605
aS'    system_matrix.reinit(sparsity_pattern);'
p34606
aS'  }'
p34607
aS'  template <int dim>'
p34608
aS'  void WGDarcyEquation<dim>::assemble_system()'
p34609
aS'  {'
p34610
aS'    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1);'
p34611
aS'    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1);'
p34612
aS'    FEValues<dim>     fe_values(fe,'
p34613
aS'                            quadrature_formula,'
p34614
aS'                            update_values | update_quadrature_points |'
p34615
aS'                              update_JxW_values);'
p34616
aS'    FEFaceValues<dim> fe_face_values(fe,'
p34617
aS'                                     face_quadrature_formula,'
p34618
aS'                                     update_values | update_normal_vectors |'
p34619
aS'                                       update_quadrature_points |'
p34620
aS'                                       update_JxW_values);'
p34621
aS'    FEValues<dim>     fe_values_dgrt(fe_dgrt,'
p34622
aS'                                 quadrature_formula,'
p34623
aS'                                 update_values | update_gradients |'
p34624
aS'                                   update_quadrature_points |'
p34625
aS'                                   update_JxW_values);'
p34626
aS'    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt,'
p34627
aS'                                          face_quadrature_formula,'
p34628
aS'                                          update_values |'
p34629
aS'                                            update_normal_vectors |'
p34630
aS'                                            update_quadrature_points |'
p34631
aS'                                            update_JxW_values);'
p34632
aS'    const unsigned int dofs_per_cell      = fe.n_dofs_per_cell();'
p34633
aS'    const unsigned int dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();'
p34634
aS'    const unsigned int n_q_points      = fe_values.get_quadrature().size();'
p34635
aS'    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();'
p34636
aS'    const unsigned int n_face_q_points = fe_face_values.get_quadrature().size();'
p34637
aS'    RightHandSide<dim>  right_hand_side;'
p34638
aS'    std::vector<double> right_hand_side_values(n_q_points);'
p34639
aS'    const Coefficient<dim>      coefficient;'
p34640
aS'    std::vector<Tensor<2, dim>> coefficient_values(n_q_points);'
p34641
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p34642
aS'    FullMatrix<double> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p34643
aS'    FullMatrix<double> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);'
p34644
aS'    FullMatrix<double> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);'
p34645
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p34646
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p34647
aS'    Vector<double>     cell_solution(dofs_per_cell);'
p34648
aS'    const FEValuesExtractors::Vector velocities(0);'
p34649
aS'    const FEValuesExtractors::Scalar pressure_interior(0);'
p34650
aS'    const FEValuesExtractors::Scalar pressure_face(1);'
p34651
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p34652
aS'      {'
p34653
aS'        fe_values.reinit(cell);'
p34654
aS'        const typename Triangulation<dim>::active_cell_iterator cell_dgrt ='
p34655
aS'          cell;'
p34656
aS'        fe_values_dgrt.reinit(cell_dgrt);'
p34657
aS'        right_hand_side.value_list(fe_values.get_quadrature_points(),'
p34658
aS'                                   right_hand_side_values);'
p34659
aS'        coefficient.value_list(fe_values.get_quadrature_points(),'
p34660
aS'                               coefficient_values);'
p34661
aS'        cell_matrix_M = 0;'
p34662
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p34663
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p34664
aS'            {'
p34665
aS'              const Tensor<1, dim> v_i = fe_values_dgrt[velocities].value(i, q);'
p34666
aS'              for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p34667
aS'                {'
p34668
aS'                  const Tensor<1, dim> v_k ='
p34669
aS'                    fe_values_dgrt[velocities].value(k, q);'
p34670
aS'                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));'
p34671
aS'                }'
p34672
aS'            }'
p34673
aS'        cell_matrix_M.gauss_jordan();'
p34674
aS'        cell_matrix_G = 0;'
p34675
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p34676
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p34677
aS'            {'
p34678
aS'              const double div_v_i ='
p34679
aS'                fe_values_dgrt[velocities].divergence(i, q);'
p34680
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34681
aS'                {'
p34682
aS'                  const double phi_j_interior ='
p34683
aS'                    fe_values[pressure_interior].value(j, q);'
p34684
aS'                  cell_matrix_G(i, j) -='
p34685
aS'                    (div_v_i * phi_j_interior * fe_values.JxW(q));'
p34686
aS'                }'
p34687
aS'            }'
p34688
aS'        for (const auto &face : cell->face_iterators())'
p34689
aS'          {'
p34690
aS'            fe_face_values.reinit(cell, face);'
p34691
aS'            fe_face_values_dgrt.reinit(cell_dgrt, face);'
p34692
aS'            for (unsigned int q = 0; q < n_face_q_points; ++q)'
p34693
aS'              {'
p34694
aS'                const Tensor<1, dim> &normal = fe_face_values.normal_vector(q);'
p34695
aS'                for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p34696
aS'                  {'
p34697
aS'                    const Tensor<1, dim> v_i ='
p34698
aS'                      fe_face_values_dgrt[velocities].value(i, q);'
p34699
aS'                    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34700
aS'                      {'
p34701
aS'                        const double phi_j_face ='
p34702
aS'                          fe_face_values[pressure_face].value(j, q);'
p34703
aS'                        cell_matrix_G(i, j) +='
p34704
aS'                          ((v_i * normal) * phi_j_face * fe_face_values.JxW(q));'
p34705
aS'                      }'
p34706
aS'                  }'
p34707
aS'              }'
p34708
aS'          }'
p34709
aS'        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);'
p34710
aS'        local_matrix = 0;'
p34711
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p34712
aS'          {'
p34713
aS'            for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p34714
aS'              {'
p34715
aS'                const Tensor<1, dim> v_k ='
p34716
aS'                  fe_values_dgrt[velocities].value(k, q);'
p34717
aS'                for (unsigned int l = 0; l < dofs_per_cell_dgrt; ++l)'
p34718
aS'                  {'
p34719
aS'                    const Tensor<1, dim> v_l ='
p34720
aS'                      fe_values_dgrt[velocities].value(l, q);'
p34721
aS'                    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34722
aS'                      for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34723
aS'                        local_matrix(i, j) +='
p34724
aS'                          (coefficient_values[q] * cell_matrix_C[i][k] * v_k) *'
p34725
aS'                          cell_matrix_C[j][l] * v_l * fe_values_dgrt.JxW(q);'
p34726
aS'                  }'
p34727
aS'              }'
p34728
aS'          }'
p34729
aS'        cell_rhs = 0;'
p34730
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p34731
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34732
aS'            {'
p34733
aS'              cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *'
p34734
aS'                              right_hand_side_values[q] * fe_values.JxW(q));'
p34735
aS'            }'
p34736
aS'        cell->get_dof_indices(local_dof_indices);'
p34737
aS'        constraints.distribute_local_to_global('
p34738
aS'          local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p34739
aS'      }'
p34740
aS'  }'
p34741
aS'  template <int dim>'
p34742
aS'  void WGDarcyEquation<dim>::solve()'
p34743
aS'  {'
p34744
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p34745
aS'    SolverCG<Vector<double>> solver(solver_control);'
p34746
aS'    solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p34747
aS'    constraints.distribute(solution);'
p34748
aS'  }'
p34749
aS'  template <int dim>'
p34750
aS'  void WGDarcyEquation<dim>::compute_postprocessed_velocity()'
p34751
aS'  {'
p34752
aS'    darcy_velocity.reinit(dof_handler_dgrt.n_dofs());'
p34753
aS'    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1);'
p34754
aS'    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1);'
p34755
aS'    FEValues<dim> fe_values(fe,'
p34756
aS'                            quadrature_formula,'
p34757
aS'                            update_values | update_quadrature_points |'
p34758
aS'                              update_JxW_values);'
p34759
aS'    FEFaceValues<dim> fe_face_values(fe,'
p34760
aS'                                     face_quadrature_formula,'
p34761
aS'                                     update_values | update_normal_vectors |'
p34762
aS'                                       update_quadrature_points |'
p34763
aS'                                       update_JxW_values);'
p34764
aS'    FEValues<dim> fe_values_dgrt(fe_dgrt,'
p34765
aS'                                 quadrature_formula,'
p34766
aS'                                 update_values | update_gradients |'
p34767
aS'                                   update_quadrature_points |'
p34768
aS'                                   update_JxW_values);'
p34769
aS'    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt,'
p34770
aS'                                          face_quadrature_formula,'
p34771
aS'                                          update_values |'
p34772
aS'                                            update_normal_vectors |'
p34773
aS'                                            update_quadrature_points |'
p34774
aS'                                            update_JxW_values);'
p34775
aS'    const unsigned int dofs_per_cell      = fe.n_dofs_per_cell();'
p34776
aS'    const unsigned int dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();'
p34777
aS'    const unsigned int n_q_points      = fe_values.get_quadrature().size();'
p34778
aS'    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();'
p34779
aS'    const unsigned int n_face_q_points = fe_face_values.get_quadrature().size();'
p34780
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p34781
aS'    std::vector<types::global_dof_index> local_dof_indices_dgrt('
p34782
aS'      dofs_per_cell_dgrt);'
p34783
aS'    FullMatrix<double> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p34784
aS'    FullMatrix<double> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);'
p34785
aS'    FullMatrix<double> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);'
p34786
aS'    FullMatrix<double> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p34787
aS'    FullMatrix<double> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p34788
aS'    Vector<double> cell_solution(dofs_per_cell);'
p34789
aS'    Vector<double> cell_velocity(dofs_per_cell_dgrt);'
p34790
aS'    const Coefficient<dim>      coefficient;'
p34791
aS'    std::vector<Tensor<2, dim>> coefficient_values(n_q_points_dgrt);'
p34792
aS'    const FEValuesExtractors::Vector velocities(0);'
p34793
aS'    const FEValuesExtractors::Scalar pressure_interior(0);'
p34794
aS'    const FEValuesExtractors::Scalar pressure_face(1);'
p34795
aS'    typename DoFHandler<dim>::active_cell_iterator'
p34796
aS'      cell = dof_handler.begin_active(),'
p34797
aS'      endc = dof_handler.end(), cell_dgrt = dof_handler_dgrt.begin_active();'
p34798
aS'    for (; cell != endc; ++cell, ++cell_dgrt)'
p34799
aS'      {'
p34800
aS'        fe_values.reinit(cell);'
p34801
aS'        fe_values_dgrt.reinit(cell_dgrt);'
p34802
aS'        coefficient.value_list(fe_values_dgrt.get_quadrature_points(),'
p34803
aS'                               coefficient_values);'
p34804
aS'        cell_matrix_M = 0;'
p34805
aS'        cell_matrix_E = 0;'
p34806
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p34807
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p34808
aS'            {'
p34809
aS'              const Tensor<1, dim> v_i = fe_values_dgrt[velocities].value(i, q);'
p34810
aS'              for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p34811
aS'                {'
p34812
aS'                  const Tensor<1, dim> v_k ='
p34813
aS'                    fe_values_dgrt[velocities].value(k, q);'
p34814
aS'                  cell_matrix_E(i, k) +='
p34815
aS'                    (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q));'
p34816
aS'                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));'
p34817
aS'                }'
p34818
aS'            }'
p34819
aS'        cell_matrix_M.gauss_jordan();'
p34820
aS'        cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);'
p34821
aS'        cell_matrix_G = 0;'
p34822
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p34823
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p34824
aS'            {'
p34825
aS'              const double div_v_i ='
p34826
aS'                fe_values_dgrt[velocities].divergence(i, q);'
p34827
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34828
aS'                {'
p34829
aS'                  const double phi_j_interior ='
p34830
aS'                    fe_values[pressure_interior].value(j, q);'
p34831
aS'                  cell_matrix_G(i, j) -='
p34832
aS'                    (div_v_i * phi_j_interior * fe_values.JxW(q));'
p34833
aS'                }'
p34834
aS'            }'
p34835
aS'        for (const auto &face : cell->face_iterators())'
p34836
aS'          {'
p34837
aS'            fe_face_values.reinit(cell, face);'
p34838
aS'            fe_face_values_dgrt.reinit(cell_dgrt, face);'
p34839
aS'            for (unsigned int q = 0; q < n_face_q_points; ++q)'
p34840
aS'              {'
p34841
aS'                const Tensor<1, dim> &normal = fe_face_values.normal_vector(q);'
p34842
aS'                for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p34843
aS'                  {'
p34844
aS'                    const Tensor<1, dim> v_i ='
p34845
aS'                      fe_face_values_dgrt[velocities].value(i, q);'
p34846
aS'                    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34847
aS'                      {'
p34848
aS'                        const double phi_j_face ='
p34849
aS'                          fe_face_values[pressure_face].value(j, q);'
p34850
aS'                        cell_matrix_G(i, j) +='
p34851
aS'                          ((v_i * normal) * phi_j_face * fe_face_values.JxW(q));'
p34852
aS'                      }'
p34853
aS'                  }'
p34854
aS'              }'
p34855
aS'          }'
p34856
aS'        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);'
p34857
aS'        cell->get_dof_values(solution, cell_solution);'
p34858
aS'        cell_velocity = 0;'
p34859
aS'        for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p34860
aS'          for (unsigned int j = 0; j < dofs_per_cell_dgrt; ++j)'
p34861
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34862
aS'              cell_velocity(k) +='
p34863
aS'                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));'
p34864
aS'        cell_dgrt->get_dof_indices(local_dof_indices_dgrt);'
p34865
aS'        for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p34866
aS'          for (unsigned int j = 0; j < dofs_per_cell_dgrt; ++j)'
p34867
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34868
aS'              darcy_velocity(local_dof_indices_dgrt[k]) +='
p34869
aS'                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));'
p34870
aS'      }'
p34871
aS'  }'
p34872
aS'  template <int dim>'
p34873
aS'  void WGDarcyEquation<dim>::compute_pressure_error()'
p34874
aS'  {'
p34875
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p34876
aS'    const ComponentSelectFunction<dim> select_interior_pressure(0, 2);'
p34877
aS'    VectorTools::integrate_difference(dof_handler,'
p34878
aS'                                      solution,'
p34879
aS'                                      ExactPressure<dim>(),'
p34880
aS'                                      difference_per_cell,'
p34881
aS'                                      QGauss<dim>(fe.degree + 2),'
p34882
aS'                                      VectorTools::L2_norm,'
p34883
aS'                                      &select_interior_pressure);'
p34884
aS'    const double L2_error = difference_per_cell.l2_norm();'
p34885
aS'    std::cout << "L2_error_pressure " << L2_error << std::endl;'
p34886
aS'  }'
p34887
aS'  template <int dim>'
p34888
aS'  void WGDarcyEquation<dim>::compute_velocity_errors()'
p34889
aS'  {'
p34890
aS'    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1);'
p34891
aS'    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1);'
p34892
aS'    FEValues<dim> fe_values_dgrt(fe_dgrt,'
p34893
aS'                                 quadrature_formula,'
p34894
aS'                                 update_values | update_gradients |'
p34895
aS'                                   update_quadrature_points |'
p34896
aS'                                   update_JxW_values);'
p34897
aS'    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt,'
p34898
aS'                                          face_quadrature_formula,'
p34899
aS'                                          update_values |'
p34900
aS'                                            update_normal_vectors |'
p34901
aS'                                            update_quadrature_points |'
p34902
aS'                                            update_JxW_values);'
p34903
aS'    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();'
p34904
aS'    const unsigned int n_face_q_points_dgrt ='
p34905
aS'      fe_face_values_dgrt.get_quadrature().size();'
p34906
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points_dgrt);'
p34907
aS'    std::vector<Tensor<1, dim>> velocity_face_values(n_face_q_points_dgrt);'
p34908
aS'    const FEValuesExtractors::Vector velocities(0);'
p34909
aS'    const ExactVelocity<dim> exact_velocity;'
p34910
aS'    double L2_err_velocity_cell_sqr_global = 0;'
p34911
aS'    double L2_err_flux_sqr                 = 0;'
p34912
aS'    for (const auto &cell_dgrt : dof_handler_dgrt.active_cell_iterators())'
p34913
aS'      {'
p34914
aS'        fe_values_dgrt.reinit(cell_dgrt);'
p34915
aS'        fe_values_dgrt[velocities].get_function_values(darcy_velocity,'
p34916
aS'                                                       velocity_values);'
p34917
aS'        double L2_err_velocity_cell_sqr_local = 0;'
p34918
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p34919
aS'          {'
p34920
aS'            const Tensor<1, dim> velocity = velocity_values[q];'
p34921
aS'            const Tensor<1, dim> true_velocity ='
p34922
aS'              exact_velocity.value(fe_values_dgrt.quadrature_point(q));'
p34923
aS'            L2_err_velocity_cell_sqr_local +='
p34924
aS'              ((velocity - true_velocity) * (velocity - true_velocity) *'
p34925
aS'               fe_values_dgrt.JxW(q));'
p34926
aS'          }'
p34927
aS'        L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;'
p34928
aS'        const double cell_area = cell_dgrt->measure();'
p34929
aS'        for (const auto &face_dgrt : cell_dgrt->face_iterators())'
p34930
aS'          {'
p34931
aS'            const double face_length = face_dgrt->measure();'
p34932
aS'            fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);'
p34933
aS'            fe_face_values_dgrt[velocities].get_function_values('
p34934
aS'              darcy_velocity, velocity_face_values);'
p34935
aS'            double L2_err_flux_face_sqr_local = 0;'
p34936
aS'            for (unsigned int q = 0; q < n_face_q_points_dgrt; ++q)'
p34937
aS'              {'
p34938
aS'                const Tensor<1, dim> velocity = velocity_face_values[q];'
p34939
aS'                const Tensor<1, dim> true_velocity ='
p34940
aS'                  exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));'
p34941
aS'                const Tensor<1, dim> &normal ='
p34942
aS'                  fe_face_values_dgrt.normal_vector(q);'
p34943
aS'                L2_err_flux_face_sqr_local +='
p34944
aS'                  ((velocity * normal - true_velocity * normal) *'
p34945
aS'                   (velocity * normal - true_velocity * normal) *'
p34946
aS'                   fe_face_values_dgrt.JxW(q));'
p34947
aS'              }'
p34948
aS'            const double err_flux_each_face ='
p34949
aS'              L2_err_flux_face_sqr_local / face_length * cell_area;'
p34950
aS'            L2_err_flux_sqr += err_flux_each_face;'
p34951
aS'          }'
p34952
aS'      }'
p34953
aS'    const double L2_err_velocity_cell ='
p34954
aS'      std::sqrt(L2_err_velocity_cell_sqr_global);'
p34955
aS'    const double L2_err_flux_face = std::sqrt(L2_err_flux_sqr);'
p34956
aS'    std::cout << "L2_error_vel:  " << L2_err_velocity_cell << std::endl'
p34957
aS'              << "L2_error_flux: " << L2_err_flux_face << std::endl;'
p34958
aS'  }'
p34959
aS'  template <int dim>'
p34960
aS'  void WGDarcyEquation<dim>::output_results() const'
p34961
aS'  {'
p34962
aS'    {'
p34963
aS'      DataOut<dim> data_out;'
p34964
aS'      const std::vector<std::string> solution_names = {"interior_pressure",'
p34965
aS'                                                       "interface_pressure"};'
p34966
aS'      data_out.add_data_vector(dof_handler, solution, solution_names);'
p34967
aS'      const std::vector<std::string> velocity_names(dim, "velocity");'
p34968
aS'      const std::vector<'
p34969
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p34970
aS'        velocity_component_interpretation('
p34971
aS'          dim, DataComponentInterpretation::component_is_part_of_vector);'
p34972
aS'      data_out.add_data_vector(dof_handler_dgrt,'
p34973
aS'                               darcy_velocity,'
p34974
aS'                               velocity_names,'
p34975
aS'                               velocity_component_interpretation);'
p34976
aS'      data_out.build_patches(fe.degree);'
p34977
aS'      std::ofstream output("solution_interior.vtu");'
p34978
aS'      data_out.write_vtu(output);'
p34979
aS'    }'
p34980
aS'    {'
p34981
aS'      DataOutFaces<dim> data_out_faces(false);'
p34982
aS'      data_out_faces.attach_dof_handler(dof_handler);'
p34983
aS'      data_out_faces.add_data_vector(solution, "Pressure_Face");'
p34984
aS'      data_out_faces.build_patches(fe.degree);'
p34985
aS'      std::ofstream face_output("solution_interface.vtu");'
p34986
aS'      data_out_faces.write_vtu(face_output);'
p34987
aS'    }'
p34988
aS'  }'
p34989
aS'  template <int dim>'
p34990
aS'  void WGDarcyEquation<dim>::run()'
p34991
aS'  {'
p34992
aS'    std::cout << "Solving problem in " << dim << " space dimensions."'
p34993
aS'              << std::endl;'
p34994
aS'    make_grid();'
p34995
aS'    setup_system();'
p34996
aS'    assemble_system();'
p34997
aS'    solve();'
p34998
aS'    compute_postprocessed_velocity();'
p34999
aS'    compute_pressure_error();'
p35000
aS'    compute_velocity_errors();'
p35001
aS'    output_results();'
p35002
aS'  }'
p35003
aS'} // namespace Step61'
p35004
aS'int main()'
p35005
ag24
aS'  try'
p35006
aS'    {'
p35007
aS'      Step61::WGDarcyEquation<2> wg_darcy(0);'
p35008
aS'      wg_darcy.run();'
p35009
aS'    }'
p35010
aS'  catch (std::exception &exc)'
p35011
aS'    {'
p35012
aS'      std::cerr << std::endl'
p35013
aS'                << std::endl'
p35014
aS'                << "----------------------------------------------------"'
p35015
aS'                << std::endl;'
p35016
aS'      std::cerr << "Exception on processing: " << std::endl'
p35017
aS'                << exc.what() << std::endl'
p35018
aS'                << "Aborting!" << std::endl'
p35019
aS'                << "----------------------------------------------------"'
p35020
aS'                << std::endl;'
p35021
aS'      return 1;'
p35022
aS'    }'
p35023
aS'  catch (...)'
p35024
aS'    {'
p35025
aS'      std::cerr << std::endl'
p35026
aS'                << std::endl'
p35027
aS'                << "----------------------------------------------------"'
p35028
aS'                << std::endl;'
p35029
aS'      std::cerr << "Unknown exception!" << std::endl'
p35030
aS'                << "Aborting!" << std::endl'
p35031
aS'                << "----------------------------------------------------"'
p35032
aS'                << std::endl;'
p35033
aS'      return 1;'
p35034
aS'    }'
p35035
aS'  return 0;'
p35036
ag32
aS'/* ---------------------------------------------------------------------'
p35037
aS' *'
p35038
aS' * Copyright (C) 2018 - 2021 by the deal.II authors'
p35039
aS' *'
p35040
aS' * This file is part of the deal.II library.'
p35041
aS' *'
p35042
aS' * The deal.II library is free software; you can use it, redistribute'
p35043
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p35044
aS' * Public License as published by the Free Software Foundation; either'
p35045
aS' * version 2.1 of the License, or (at your option) any later version.'
p35046
aS' * The full text of the license can be found in the file LICENSE at'
p35047
aS' * the top level of the deal.II distribution.'
p35048
aS' *'
p35049
aS' * ---------------------------------------------------------------------'
p35050
aS' *'
p35051
aS' * Author: Daniel Garcia-Sanchez, CNRS, 2019'
p35052
aS' */'
p35053
aS'#include <deal.II/base/conditional_ostream.h>'
p35054
aS'#include <deal.II/base/function.h>'
p35055
aS'#include <deal.II/base/index_set.h>'
p35056
aS'#include <deal.II/base/quadrature_lib.h>'
p35057
aS'#include <deal.II/base/timer.h>'
p35058
aS'#include <deal.II/base/utilities.h>'
p35059
aS'#include <deal.II/dofs/dof_handler.h>'
p35060
aS'#include <deal.II/dofs/dof_tools.h>'
p35061
aS'#include <deal.II/fe/fe_q.h>'
p35062
aS'#include <deal.II/fe/fe_system.h>'
p35063
aS'#include <deal.II/fe/fe_values.h>'
p35064
aS'#include <deal.II/grid/grid_generator.h>'
p35065
aS'#include <deal.II/grid/grid_refinement.h>'
p35066
aS'#include <deal.II/lac/affine_constraints.h>'
p35067
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p35068
aS'#include <deal.II/lac/full_matrix.h>'
p35069
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p35070
aS'#include <deal.II/lac/petsc_solver.h>'
p35071
aS'#include <deal.II/lac/vector.h>'
p35072
aS'#include <deal.II/numerics/data_out.h>'
p35073
aS'#include <deal.II/numerics/error_estimator.h>'
p35074
aS'#include <fstream>'
p35075
aS'#include <iostream>'
p35076
aS'#include <deal.II/base/tensor.h>'
p35077
aS'#include <deal.II/base/hdf5.h>'
p35078
aS'#include <deal.II/numerics/vector_tools.h>'
p35079
aS'#include <deal.II/grid/grid_tools.h>'
p35080
aS'#include <deal.II/grid/grid_tools_cache.h>'
p35081
aS'namespace step62'
p35082
ag24
aS'  using namespace dealii;'
p35083
aS'  template <int dim>'
p35084
aS'  class RightHandSide : public Function<dim>'
p35085
aS'  {'
p35086
aS'  public:'
p35087
aS'    RightHandSide(HDF5::Group &data);'
p35088
aS'    virtual double value(const Point<dim> & p,'
p35089
aS'                         const unsigned int component) const override;'
p35090
aS'  private:'
p35091
aS'    HDF5::Group data;'
p35092
aS'    const double     max_force_amplitude;'
p35093
aS'    const double     force_sigma_x;'
p35094
aS'    const double     force_sigma_y;'
p35095
aS'    const double     max_force_width_x;'
p35096
aS'    const double     max_force_width_y;'
p35097
aS'    const Point<dim> force_center;'
p35098
aS'  public:'
p35099
aS'    const unsigned int force_component = 0;'
p35100
aS'  };'
p35101
aS'  template <int dim>'
p35102
aS'  class PML : public Function<dim, std::complex<double>>'
p35103
aS'  {'
p35104
aS'  public:'
p35105
aS'    PML(HDF5::Group &data);'
p35106
aS'    virtual std::complex<double>'
p35107
aS'    value(const Point<dim> &p, const unsigned int component) const override;'
p35108
aS'  private:'
p35109
aS'    HDF5::Group data;'
p35110
aS'    const double pml_coeff;'
p35111
aS'    const int    pml_coeff_degree;'
p35112
aS'    const double dimension_x;'
p35113
aS'    const double dimension_y;'
p35114
aS'    const bool   pml_x;'
p35115
aS'    const bool   pml_y;'
p35116
aS'    const double pml_width_x;'
p35117
aS'    const double pml_width_y;'
p35118
aS'    const double a_coeff_x;'
p35119
aS'    const double a_coeff_y;'
p35120
aS'  };'
p35121
aS'  template <int dim>'
p35122
aS'  class Rho : public Function<dim>'
p35123
aS'  {'
p35124
aS'  public:'
p35125
aS'    Rho(HDF5::Group &data);'
p35126
aS'    virtual double value(const Point<dim> & p,'
p35127
aS'                         const unsigned int component = 0) const override;'
p35128
aS'  private:'
p35129
aS'    HDF5::Group data;'
p35130
aS'    const double       lambda;'
p35131
aS'    const double       mu;'
p35132
aS'    const double       material_a_rho;'
p35133
aS'    const double       material_b_rho;'
p35134
aS'    const double       cavity_resonance_frequency;'
p35135
aS'    const unsigned int nb_mirror_pairs;'
p35136
aS'    const double       dimension_y;'
p35137
aS'    const unsigned int grid_level;'
p35138
aS'    double             average_rho_width;'
p35139
aS'  };'
p35140
aS'  template <int dim>'
p35141
aS'  class Parameters'
p35142
aS'  {'
p35143
aS'  public:'
p35144
aS'    Parameters(HDF5::Group &data);'
p35145
aS'    HDF5::Group data;'
p35146
aS'    const std::string        simulation_name;'
p35147
aS'    const bool               save_vtu_files;'
p35148
aS'    const double             start_frequency;'
p35149
aS'    const double             stop_frequency;'
p35150
aS'    const unsigned int       nb_frequency_points;'
p35151
aS'    const double             lambda;'
p35152
aS'    const double             mu;'
p35153
aS'    const double             dimension_x;'
p35154
aS'    const double             dimension_y;'
p35155
aS'    const unsigned int       nb_probe_points;'
p35156
aS'    const unsigned int       grid_level;'
p35157
aS'    const Point<dim>         probe_start_point;'
p35158
aS'    const Point<dim>         probe_stop_point;'
p35159
aS'    const RightHandSide<dim> right_hand_side;'
p35160
aS'    const PML<dim>           pml;'
p35161
aS'    const Rho<dim>           rho;'
p35162
aS'  private:'
p35163
aS'    const double comparison_float_constant = 1e-12;'
p35164
aS'  };'
p35165
aS'  template <int dim>'
p35166
aS'  class QuadratureCache'
p35167
aS'  {'
p35168
aS'  public:'
p35169
aS'    QuadratureCache(const unsigned int dofs_per_cell);'
p35170
aS'  private:'
p35171
aS'    unsigned int dofs_per_cell;'
p35172
aS'  public:'
p35173
aS'    FullMatrix<std::complex<double>>  mass_coefficient;'
p35174
aS'    FullMatrix<std::complex<double>>  stiffness_coefficient;'
p35175
aS'    std::vector<std::complex<double>> right_hand_side;'
p35176
aS'    double                            JxW;'
p35177
aS'  };'
p35178
aS'  template <int dim>'
p35179
aS'  SymmetricTensor<4, dim> get_stiffness_tensor(const double lambda,'
p35180
aS'                                               const double mu)'
p35181
aS'  {'
p35182
aS'    SymmetricTensor<4, dim> stiffness_tensor;'
p35183
aS'    for (unsigned int i = 0; i < dim; ++i)'
p35184
aS'      for (unsigned int j = 0; j < dim; ++j)'
p35185
aS'        for (unsigned int k = 0; k < dim; ++k)'
p35186
aS'          for (unsigned int l = 0; l < dim; ++l)'
p35187
aS'            stiffness_tensor[i][j][k][l] ='
p35188
aS'              (((i == k) && (j == l) ? mu : 0.0) +'
p35189
aS'               ((i == l) && (j == k) ? mu : 0.0) +'
p35190
aS'               ((i == j) && (k == l) ? lambda : 0.0));'
p35191
aS'    return stiffness_tensor;'
p35192
aS'  }'
p35193
aS'  template <int dim>'
p35194
aS'  class ElasticWave'
p35195
aS'  {'
p35196
aS'  public:'
p35197
aS'    ElasticWave(const Parameters<dim> &parameters);'
p35198
aS'    void run();'
p35199
aS'  private:'
p35200
aS'    void setup_system();'
p35201
aS'    void assemble_system(const double omega,'
p35202
aS'                         const bool   calculate_quadrature_data);'
p35203
aS'    void solve();'
p35204
aS'    void initialize_probe_positions_vector();'
p35205
aS'    void store_frequency_step_data(const unsigned int frequency_idx);'
p35206
aS'    void output_results();'
p35207
aS'    void setup_quadrature_cache();'
p35208
aS'    void frequency_sweep();'
p35209
aS'    Parameters<dim> parameters;'
p35210
aS'    MPI_Comm mpi_communicator;'
p35211
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p35212
aS'    QGauss<dim> quadrature_formula;'
p35213
aS'    std::vector<QuadratureCache<dim>> quadrature_cache;'
p35214
aS'    FESystem<dim>   fe;'
p35215
aS'    DoFHandler<dim> dof_handler;'
p35216
aS'    IndexSet locally_owned_dofs;'
p35217
aS'    IndexSet locally_relevant_dofs;'
p35218
aS'    AffineConstraints<std::complex<double>> constraints;'
p35219
aS'    LinearAlgebraPETSc::MPI::SparseMatrix system_matrix;'
p35220
aS'    LinearAlgebraPETSc::MPI::Vector       locally_relevant_solution;'
p35221
aS'    LinearAlgebraPETSc::MPI::Vector       system_rhs;'
p35222
aS'    std::vector<double> frequency;'
p35223
aS'    FullMatrix<double> probe_positions;'
p35224
aS'    HDF5::DataSet frequency_dataset;'
p35225
aS'    HDF5::DataSet probe_positions_dataset;'
p35226
aS'    HDF5::DataSet displacement;'
p35227
aS'    ConditionalOStream pcout;'
p35228
aS'    TimerOutput        computing_timer;'
p35229
aS'  };'
p35230
aS'  template <int dim>'
p35231
aS'  RightHandSide<dim>::RightHandSide(HDF5::Group &data)'
p35232
aS'    : Function<dim>(dim)'
p35233
aS'    , data(data)'
p35234
aS'    , max_force_amplitude(data.get_attribute<double>("max_force_amplitude"))'
p35235
aS'    , force_sigma_x(data.get_attribute<double>("force_sigma_x"))'
p35236
aS'    , force_sigma_y(data.get_attribute<double>("force_sigma_y"))'
p35237
aS'    , max_force_width_x(data.get_attribute<double>("max_force_width_x"))'
p35238
aS'    , max_force_width_y(data.get_attribute<double>("max_force_width_y"))'
p35239
aS'    , force_center(Point<dim>(data.get_attribute<double>("force_x_pos"),'
p35240
aS'                              data.get_attribute<double>("force_y_pos")))'
p35241
aS'  {}'
p35242
aS'  template <int dim>'
p35243
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p35244
aS'                                   const unsigned int component) const'
p35245
aS'  {'
p35246
aS'    if (component == force_component)'
p35247
aS'      {'
p35248
aS'        if (std::abs(p[0] - force_center[0]) < max_force_width_x / 2 &&'
p35249
aS'            std::abs(p[1] - force_center[1]) < max_force_width_y / 2)'
p35250
aS'          {'
p35251
aS'            return max_force_amplitude *'
p35252
aS'                   std::exp(-(std::pow(p[0] - force_center[0], 2) /'
p35253
aS'                                (2 * std::pow(force_sigma_x, 2)) +'
p35254
aS'                              std::pow(p[1] - force_center[1], 2) /'
p35255
aS'                                (2 * std::pow(force_sigma_y, 2))));'
p35256
aS'          }'
p35257
aS'        else'
p35258
aS'          {'
p35259
aS'            return 0;'
p35260
aS'          }'
p35261
aS'      }'
p35262
aS'    else'
p35263
aS'      {'
p35264
aS'        return 0;'
p35265
aS'      }'
p35266
aS'  }'
p35267
aS'  template <int dim>'
p35268
aS'  PML<dim>::PML(HDF5::Group &data)'
p35269
aS'    : Function<dim, std::complex<double>>(dim)'
p35270
aS'    , data(data)'
p35271
aS'    , pml_coeff(data.get_attribute<double>("pml_coeff"))'
p35272
aS'    , pml_coeff_degree(data.get_attribute<int>("pml_coeff_degree"))'
p35273
aS'    , dimension_x(data.get_attribute<double>("dimension_x"))'
p35274
aS'    , dimension_y(data.get_attribute<double>("dimension_y"))'
p35275
aS'    , pml_x(data.get_attribute<bool>("pml_x"))'
p35276
aS'    , pml_y(data.get_attribute<bool>("pml_y"))'
p35277
aS'    , pml_width_x(data.get_attribute<double>("pml_width_x"))'
p35278
aS'    , pml_width_y(data.get_attribute<double>("pml_width_y"))'
p35279
aS'    , a_coeff_x(pml_coeff / std::pow(pml_width_x, pml_coeff_degree))'
p35280
aS'    , a_coeff_y(pml_coeff / std::pow(pml_width_y, pml_coeff_degree))'
p35281
aS'  {}'
p35282
aS'  template <int dim>'
p35283
aS'  std::complex<double> PML<dim>::value(const Point<dim> & p,'
p35284
aS'                                       const unsigned int component) const'
p35285
aS'  {'
p35286
aS'    double calculated_pml_x_coeff = 0;'
p35287
aS'    double calculated_pml_y_coeff = 0;'
p35288
aS'    if ((component == 0) && pml_x)'
p35289
aS'      {'
p35290
aS'        const double pml_x_start_position = dimension_x / 2 - pml_width_x;'
p35291
aS'        if (std::abs(p[0]) > pml_x_start_position)'
p35292
aS'          {'
p35293
aS'            const double x_prime = std::abs(p[0]) - pml_x_start_position;'
p35294
aS'            calculated_pml_x_coeff ='
p35295
aS'              a_coeff_x * std::pow(x_prime, pml_coeff_degree);'
p35296
aS'          }'
p35297
aS'      }'
p35298
aS'    if ((component == 1) && pml_y)'
p35299
aS'      {'
p35300
aS'        const double pml_y_start_position = dimension_y / 2 - pml_width_y;'
p35301
aS'        if (std::abs(p[1]) > pml_y_start_position)'
p35302
aS'          {'
p35303
aS'            const double y_prime = std::abs(p[1]) - pml_y_start_position;'
p35304
aS'            calculated_pml_y_coeff ='
p35305
aS'              a_coeff_y * std::pow(y_prime, pml_coeff_degree);'
p35306
aS'          }'
p35307
aS'      }'
p35308
aS'    return 1. + std::max(calculated_pml_x_coeff, calculated_pml_y_coeff) *'
p35309
aS'                  std::complex<double>(0., 1.);'
p35310
aS'  }'
p35311
aS'  template <int dim>'
p35312
aS'  Rho<dim>::Rho(HDF5::Group &data)'
p35313
aS'    : Function<dim>(1)'
p35314
aS'    , data(data)'
p35315
aS'    , lambda(data.get_attribute<double>("lambda"))'
p35316
aS'    , mu(data.get_attribute<double>("mu"))'
p35317
aS'    , material_a_rho(data.get_attribute<double>("material_a_rho"))'
p35318
aS'    , material_b_rho(data.get_attribute<double>("material_b_rho"))'
p35319
aS'    , cavity_resonance_frequency('
p35320
aS'        data.get_attribute<double>("cavity_resonance_frequency"))'
p35321
aS'    , nb_mirror_pairs(data.get_attribute<int>("nb_mirror_pairs"))'
p35322
aS'    , dimension_y(data.get_attribute<double>("dimension_y"))'
p35323
aS'    , grid_level(data.get_attribute<int>("grid_level"))'
p35324
aS'  {'
p35325
aS'    average_rho_width = dimension_y / (std::pow(2.0, grid_level));'
p35326
aS'    data.set_attribute("average_rho_width", average_rho_width);'
p35327
aS'  }'
p35328
aS'  template <int dim>'
p35329
aS'  double Rho<dim>::value(const Point<dim> &p,'
p35330
aS'                         const unsigned int /*component*/) const'
p35331
aS'  {'
p35332
aS'    double elastic_constant;'
p35333
aS'    if (dim == 2)'
p35334
aS'      {'
p35335
aS'        elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu);'
p35336
aS'      }'
p35337
aS'    else if (dim == 3)'
p35338
aS'      {'
p35339
aS'        elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu);'
p35340
aS'      }'
p35341
aS'    else'
p35342
aS'      {'
p35343
aS'        Assert(false, ExcInternalError());'
p35344
aS'      }'
p35345
aS'    const double material_a_speed_of_sound ='
p35346
aS'      std::sqrt(elastic_constant / material_a_rho);'
p35347
aS'    const double material_a_wavelength ='
p35348
aS'      material_a_speed_of_sound / cavity_resonance_frequency;'
p35349
aS'    const double material_b_speed_of_sound ='
p35350
aS'      std::sqrt(elastic_constant / material_b_rho);'
p35351
aS'    const double material_b_wavelength ='
p35352
aS'      material_b_speed_of_sound / cavity_resonance_frequency;'
p35353
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p35354
aS'      {'
p35355
aS'        const double layer_transition_center ='
p35356
aS'          material_a_wavelength / 2 +'
p35357
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4);'
p35358
aS'        if (std::abs(p[0]) >='
p35359
aS'              (layer_transition_center - average_rho_width / 2) &&'
p35360
aS'            std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))'
p35361
aS'          {'
p35362
aS'            const double coefficient ='
p35363
aS'              (std::abs(p[0]) -'
p35364
aS'               (layer_transition_center - average_rho_width / 2)) /'
p35365
aS'              average_rho_width;'
p35366
aS'            return (1 - coefficient) * material_a_rho +'
p35367
aS'                   coefficient * material_b_rho;'
p35368
aS'          }'
p35369
aS'      }'
p35370
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p35371
aS'      {'
p35372
aS'        const double layer_transition_center ='
p35373
aS'          material_a_wavelength / 2 +'
p35374
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +'
p35375
aS'          material_b_wavelength / 4;'
p35376
aS'        if (std::abs(p[0]) >='
p35377
aS'              (layer_transition_center - average_rho_width / 2) &&'
p35378
aS'            std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))'
p35379
aS'          {'
p35380
aS'            const double coefficient ='
p35381
aS'              (std::abs(p[0]) -'
p35382
aS'               (layer_transition_center - average_rho_width / 2)) /'
p35383
aS'              average_rho_width;'
p35384
aS'            return (1 - coefficient) * material_b_rho +'
p35385
aS'                   coefficient * material_a_rho;'
p35386
aS'          }'
p35387
aS'      }'
p35388
aS'    if (std::abs(p[0]) <= material_a_wavelength / 2)'
p35389
aS'      {'
p35390
aS'        return material_a_rho;'
p35391
aS'      }'
p35392
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p35393
aS'      {'
p35394
aS'        const double layer_center ='
p35395
aS'          material_a_wavelength / 2 +'
p35396
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +'
p35397
aS'          material_b_wavelength / 4 + material_a_wavelength / 8;'
p35398
aS'        const double layer_width = material_a_wavelength / 4;'
p35399
aS'        if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&'
p35400
aS'            std::abs(p[0]) <= (layer_center + layer_width / 2))'
p35401
aS'          {'
p35402
aS'            return material_a_rho;'
p35403
aS'          }'
p35404
aS'      }'
p35405
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p35406
aS'      {'
p35407
aS'        const double layer_center ='
p35408
aS'          material_a_wavelength / 2 +'
p35409
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +'
p35410
aS'          material_b_wavelength / 8;'
p35411
aS'        const double layer_width = material_b_wavelength / 4;'
p35412
aS'        if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&'
p35413
aS'            std::abs(p[0]) <= (layer_center + layer_width / 2))'
p35414
aS'          {'
p35415
aS'            return material_b_rho;'
p35416
aS'          }'
p35417
aS'      }'
p35418
aS'    return material_a_rho;'
p35419
aS'  }'
p35420
aS'  template <int dim>'
p35421
aS'  Parameters<dim>::Parameters(HDF5::Group &data)'
p35422
aS'    : data(data)'
p35423
aS'    , simulation_name(data.get_attribute<std::string>("simulation_name"))'
p35424
aS'    , save_vtu_files(data.get_attribute<bool>("save_vtu_files"))'
p35425
aS'    , start_frequency(data.get_attribute<double>("start_frequency"))'
p35426
aS'    , stop_frequency(data.get_attribute<double>("stop_frequency"))'
p35427
aS'    , nb_frequency_points(data.get_attribute<int>("nb_frequency_points"))'
p35428
aS'    , lambda(data.get_attribute<double>("lambda"))'
p35429
aS'    , mu(data.get_attribute<double>("mu"))'
p35430
aS'    , dimension_x(data.get_attribute<double>("dimension_x"))'
p35431
aS'    , dimension_y(data.get_attribute<double>("dimension_y"))'
p35432
aS'    , nb_probe_points(data.get_attribute<int>("nb_probe_points"))'
p35433
aS'    , grid_level(data.get_attribute<int>("grid_level"))'
p35434
aS'    , probe_start_point(data.get_attribute<double>("probe_pos_x"),'
p35435
aS'                        data.get_attribute<double>("probe_pos_y") -'
p35436
aS'                          data.get_attribute<double>("probe_width_y") / 2)'
p35437
aS'    , probe_stop_point(data.get_attribute<double>("probe_pos_x"),'
p35438
aS'                       data.get_attribute<double>("probe_pos_y") +'
p35439
aS'                         data.get_attribute<double>("probe_width_y") / 2)'
p35440
aS'    , right_hand_side(data)'
p35441
aS'    , pml(data)'
p35442
aS'    , rho(data)'
p35443
aS'  {}'
p35444
aS'  template <int dim>'
p35445
aS'  QuadratureCache<dim>::QuadratureCache(const unsigned int dofs_per_cell)'
p35446
aS'    : dofs_per_cell(dofs_per_cell)'
p35447
aS'    , mass_coefficient(dofs_per_cell, dofs_per_cell)'
p35448
aS'    , stiffness_coefficient(dofs_per_cell, dofs_per_cell)'
p35449
aS'    , right_hand_side(dofs_per_cell)'
p35450
aS'  {}'
p35451
aS'  template <int dim>'
p35452
aS'  ElasticWave<dim>::ElasticWave(const Parameters<dim> &parameters)'
p35453
aS'    : parameters(parameters)'
p35454
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p35455
aS'    , triangulation(mpi_communicator,'
p35456
aS'                    typename Triangulation<dim>::MeshSmoothing('
p35457
aS'                      Triangulation<dim>::smoothing_on_refinement |'
p35458
aS'                      Triangulation<dim>::smoothing_on_coarsening))'
p35459
aS'    , quadrature_formula(2)'
p35460
aS'    , fe(FE_Q<dim>(1), dim)'
p35461
aS'    , dof_handler(triangulation)'
p35462
aS'    , frequency(parameters.nb_frequency_points)'
p35463
aS'    , probe_positions(parameters.nb_probe_points, dim)'
p35464
aS'    , frequency_dataset(parameters.data.template create_dataset<double>('
p35465
aS'        "frequency",'
p35466
aS'        std::vector<hsize_t>{parameters.nb_frequency_points}))'
p35467
aS'    , probe_positions_dataset(parameters.data.template create_dataset<double>('
p35468
aS'        "position",'
p35469
aS'        std::vector<hsize_t>{parameters.nb_probe_points, dim}))'
p35470
aS'    , displacement('
p35471
aS'        parameters.data.template create_dataset<std::complex<double>>('
p35472
aS'          "displacement",'
p35473
aS'          std::vector<hsize_t>{parameters.nb_probe_points,'
p35474
aS'                               parameters.nb_frequency_points}))'
p35475
aS'    , pcout(std::cout,'
p35476
aS'            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p35477
aS'    , computing_timer(mpi_communicator,'
p35478
aS'                      pcout,'
p35479
aS'                      TimerOutput::summary,'
p35480
aS'                      TimerOutput::wall_times)'
p35481
aS'  {}'
p35482
aS'  template <int dim>'
p35483
aS'  void ElasticWave<dim>::setup_system()'
p35484
aS'  {'
p35485
aS'    TimerOutput::Scope t(computing_timer, "setup");'
p35486
aS'    dof_handler.distribute_dofs(fe);'
p35487
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p35488
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p35489
aS'    locally_relevant_solution.reinit(locally_owned_dofs,'
p35490
aS'                                     locally_relevant_dofs,'
p35491
aS'                                     mpi_communicator);'
p35492
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p35493
aS'    constraints.clear();'
p35494
aS'    constraints.reinit(locally_relevant_dofs);'
p35495
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p35496
aS'    constraints.close();'
p35497
aS'    DynamicSparsityPattern dsp(locally_relevant_dofs);'
p35498
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p35499
aS'    SparsityTools::distribute_sparsity_pattern(dsp,'
p35500
aS'                                               locally_owned_dofs,'
p35501
aS'                                               mpi_communicator,'
p35502
aS'                                               locally_relevant_dofs);'
p35503
aS'    system_matrix.reinit(locally_owned_dofs,'
p35504
aS'                         locally_owned_dofs,'
p35505
aS'                         dsp,'
p35506
aS'                         mpi_communicator);'
p35507
aS'  }'
p35508
aS'  template <int dim>'
p35509
aS'  void ElasticWave<dim>::assemble_system(const double omega,'
p35510
aS'                                         const bool   calculate_quadrature_data)'
p35511
aS'  {'
p35512
aS'    TimerOutput::Scope t(computing_timer, "assembly");'
p35513
aS'    FEValues<dim>      fe_values(fe,'
p35514
aS'                            quadrature_formula,'
p35515
aS'                            update_values | update_gradients |'
p35516
aS'                              update_quadrature_points | update_JxW_values);'
p35517
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p35518
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p35519
aS'    FullMatrix<std::complex<double>> cell_matrix(dofs_per_cell, dofs_per_cell);'
p35520
aS'    Vector<std::complex<double>>     cell_rhs(dofs_per_cell);'
p35521
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p35522
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim));'
p35523
aS'    std::vector<double>         rho_values(n_q_points);'
p35524
aS'    std::vector<Vector<std::complex<double>>> pml_values('
p35525
aS'      n_q_points, Vector<std::complex<double>>(dim));'
p35526
aS'    const SymmetricTensor<4, dim> stiffness_tensor ='
p35527
aS'      get_stiffness_tensor<dim>(parameters.lambda, parameters.mu);'
p35528
aS'    const FEValuesExtractors::Vector displacement(0);'
p35529
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p35530
aS'      if (cell->is_locally_owned())'
p35531
aS'        {'
p35532
aS'          cell_matrix = 0;'
p35533
aS'          cell_rhs    = 0;'
p35534
aS'          if (calculate_quadrature_data)'
p35535
aS'            {'
p35536
aS'              fe_values.reinit(cell);'
p35537
aS'              parameters.right_hand_side.vector_value_list('
p35538
aS'                fe_values.get_quadrature_points(), rhs_values);'
p35539
aS'              parameters.rho.value_list(fe_values.get_quadrature_points(),'
p35540
aS'                                        rho_values);'
p35541
aS'              parameters.pml.vector_value_list('
p35542
aS'                fe_values.get_quadrature_points(), pml_values);'
p35543
aS'            }'
p35544
aS'          QuadratureCache<dim> *local_quadrature_points_data ='
p35545
aS'            reinterpret_cast<QuadratureCache<dim> *>(cell->user_pointer());'
p35546
aS'          Assert(local_quadrature_points_data >= &quadrature_cache.front(),'
p35547
aS'                 ExcInternalError());'
p35548
aS'          Assert(local_quadrature_points_data <= &quadrature_cache.back(),'
p35549
aS'                 ExcInternalError());'
p35550
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p35551
aS'            {'
p35552
aS'              QuadratureCache<dim> &quadrature_data ='
p35553
aS'                local_quadrature_points_data[q];'
p35554
aS'              Tensor<1, dim>                       force;'
p35555
aS'              Tensor<1, dim, std::complex<double>> s;'
p35556
aS'              std::complex<double>                 xi(1, 0);'
p35557
aS'              if (calculate_quadrature_data)'
p35558
aS'                {'
p35559
aS'                  quadrature_data.JxW = fe_values.JxW(q);'
p35560
aS'                  for (unsigned int component = 0; component < dim; ++component)'
p35561
aS'                    {'
p35562
aS'                      force[component] = rhs_values[q][component];'
p35563
aS'                      s[component]     = pml_values[q][component];'
p35564
aS'                      xi *= s[component];'
p35565
aS'                    }'
p35566
aS'                  Tensor<4, dim, std::complex<double>> alpha;'
p35567
aS'                  Tensor<4, dim, std::complex<double>> beta;'
p35568
aS'                  for (unsigned int m = 0; m < dim; ++m)'
p35569
aS'                    for (unsigned int n = 0; n < dim; ++n)'
p35570
aS'                      for (unsigned int k = 0; k < dim; ++k)'
p35571
aS'                        for (unsigned int l = 0; l < dim; ++l)'
p35572
aS'                          {'
p35573
aS'                            alpha[m][n][k][l] = xi *'
p35574
aS'                                                stiffness_tensor[m][n][k][l] /'
p35575
aS'                                                (2.0 * s[n] * s[k]);'
p35576
aS'                            beta[m][n][k][l] = xi *'
p35577
aS'                                               stiffness_tensor[m][n][k][l] /'
p35578
aS'                                               (2.0 * s[n] * s[l]);'
p35579
aS'                          }'
p35580
aS'                  for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p35581
aS'                    {'
p35582
aS'                      const Tensor<1, dim> phi_i ='
p35583
aS'                        fe_values[displacement].value(i, q);'
p35584
aS'                      const Tensor<2, dim> grad_phi_i ='
p35585
aS'                        fe_values[displacement].gradient(i, q);'
p35586
aS'                      for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p35587
aS'                        {'
p35588
aS'                          const Tensor<1, dim> phi_j ='
p35589
aS'                            fe_values[displacement].value(j, q);'
p35590
aS'                          const Tensor<2, dim> grad_phi_j ='
p35591
aS'                            fe_values[displacement].gradient(j, q);'
p35592
aS'                          quadrature_data.mass_coefficient[i][j] ='
p35593
aS'                            rho_values[q] * xi * phi_i * phi_j;'
p35594
aS'                          std::complex<double> stiffness_coefficient = 0;'
p35595
aS'                          for (unsigned int m = 0; m < dim; ++m)'
p35596
aS'                            for (unsigned int n = 0; n < dim; ++n)'
p35597
aS'                              for (unsigned int k = 0; k < dim; ++k)'
p35598
aS'                                for (unsigned int l = 0; l < dim; ++l)'
p35599
aS'                                  {'
p35600
aS'                                    stiffness_coefficient +='
p35601
aS'                                      grad_phi_i[m][n] *'
p35602
aS'                                      (alpha[m][n][k][l] * grad_phi_j[l][k] +'
p35603
aS'                                       beta[m][n][k][l] * grad_phi_j[k][l]);'
p35604
aS'                                  }'
p35605
aS'                          quadrature_data.stiffness_coefficient[i][j] ='
p35606
aS'                            stiffness_coefficient;'
p35607
aS'                        }'
p35608
aS'                      quadrature_data.right_hand_side[i] ='
p35609
aS'                        phi_i * force * fe_values.JxW(q);'
p35610
aS'                    }'
p35611
aS'                }'
p35612
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p35613
aS'                {'
p35614
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p35615
aS'                    {'
p35616
aS'                      std::complex<double> matrix_sum = 0;'
p35617
aS'                      matrix_sum += -std::pow(omega, 2) *'
p35618
aS'                                    quadrature_data.mass_coefficient[i][j];'
p35619
aS'                      matrix_sum += quadrature_data.stiffness_coefficient[i][j];'
p35620
aS'                      cell_matrix(i, j) += matrix_sum * quadrature_data.JxW;'
p35621
aS'                    }'
p35622
aS'                  cell_rhs(i) += quadrature_data.right_hand_side[i];'
p35623
aS'                }'
p35624
aS'            }'
p35625
aS'          cell->get_dof_indices(local_dof_indices);'
p35626
aS'          constraints.distribute_local_to_global(cell_matrix,'
p35627
aS'                                                 cell_rhs,'
p35628
aS'                                                 local_dof_indices,'
p35629
aS'                                                 system_matrix,'
p35630
aS'                                                 system_rhs);'
p35631
aS'        }'
p35632
aS'    system_matrix.compress(VectorOperation::add);'
p35633
aS'    system_rhs.compress(VectorOperation::add);'
p35634
aS'  }'
p35635
aS'  template <int dim>'
p35636
aS'  void ElasticWave<dim>::solve()'
p35637
aS'  {'
p35638
aS'    TimerOutput::Scope              t(computing_timer, "solve");'
p35639
aS'    LinearAlgebraPETSc::MPI::Vector completely_distributed_solution('
p35640
aS'      locally_owned_dofs, mpi_communicator);'
p35641
aS'    SolverControl                    solver_control;'
p35642
aS'    PETScWrappers::SparseDirectMUMPS solver(solver_control, mpi_communicator);'
p35643
aS'    solver.solve(system_matrix, completely_distributed_solution, system_rhs);'
p35644
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p35645
aS'          << std::endl;'
p35646
aS'    constraints.distribute(completely_distributed_solution);'
p35647
aS'    locally_relevant_solution = completely_distributed_solution;'
p35648
aS'  }'
p35649
aS'  template <int dim>'
p35650
aS'  void ElasticWave<dim>::initialize_probe_positions_vector()'
p35651
aS'  {'
p35652
aS'    for (unsigned int position_idx = 0;'
p35653
aS'         position_idx < parameters.nb_probe_points;'
p35654
aS'         ++position_idx)'
p35655
aS'      {'
p35656
aS'        const Point<dim> p ='
p35657
aS'          (position_idx / ((double)(parameters.nb_probe_points - 1))) *'
p35658
aS'            (parameters.probe_stop_point + (-parameters.probe_start_point)) +'
p35659
aS'          parameters.probe_start_point;'
p35660
aS'        probe_positions[position_idx][0] = p[0];'
p35661
aS'        probe_positions[position_idx][1] = p[1];'
p35662
aS'        if (dim == 3)'
p35663
aS'          {'
p35664
aS'            probe_positions[position_idx][2] = p[2];'
p35665
aS'          }'
p35666
aS'      }'
p35667
aS'  }'
p35668
aS'  template <int dim>'
p35669
aS'  void'
p35670
aS'  ElasticWave<dim>::store_frequency_step_data(const unsigned int frequency_idx)'
p35671
aS'  {'
p35672
aS'    TimerOutput::Scope t(computing_timer, "store_frequency_step_data");'
p35673
aS'    const unsigned int probe_displacement_component = 0;'
p35674
aS'    std::vector<hsize_t>              coordinates;'
p35675
aS'    std::vector<std::complex<double>> displacement_data;'
p35676
aS'    const auto &mapping = get_default_linear_mapping(triangulation);'
p35677
aS'    GridTools::Cache<dim, dim> cache(triangulation, mapping);'
p35678
aS'    typename Triangulation<dim, dim>::active_cell_iterator cell_hint{};'
p35679
aS'    std::vector<bool>                                      marked_vertices = {};'
p35680
aS'    const double                                           tolerance = 1.e-10;'
p35681
aS'    for (unsigned int position_idx = 0;'
p35682
aS'         position_idx < parameters.nb_probe_points;'
p35683
aS'         ++position_idx)'
p35684
aS'      {'
p35685
aS'        Point<dim> point;'
p35686
aS'        for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p35687
aS'          {'
p35688
aS'            point[dim_idx] = probe_positions[position_idx][dim_idx];'
p35689
aS'          }'
p35690
aS'        bool point_in_locally_owned_cell = false;'
p35691
aS'        {'
p35692
aS'          auto cell_and_ref_point = GridTools::find_active_cell_around_point('
p35693
aS'            cache, point, cell_hint, marked_vertices, tolerance);'
p35694
aS'          if (cell_and_ref_point.first.state() == IteratorState::valid)'
p35695
aS'            {'
p35696
aS'              cell_hint = cell_and_ref_point.first;'
p35697
aS'              point_in_locally_owned_cell ='
p35698
aS'                cell_and_ref_point.first->is_locally_owned();'
p35699
aS'            }'
p35700
aS'        }'
p35701
aS'        if (point_in_locally_owned_cell)'
p35702
aS'          {'
p35703
aS'            Vector<std::complex<double>> tmp_vector(dim);'
p35704
aS'            VectorTools::point_value(dof_handler,'
p35705
aS'                                     locally_relevant_solution,'
p35706
aS'                                     point,'
p35707
aS'                                     tmp_vector);'
p35708
aS'            coordinates.emplace_back(position_idx);'
p35709
aS'            coordinates.emplace_back(frequency_idx);'
p35710
aS'            displacement_data.emplace_back('
p35711
aS'              tmp_vector(probe_displacement_component));'
p35712
aS'          }'
p35713
aS'      }'
p35714
aS'    if (coordinates.size() > 0)'
p35715
aS'      {'
p35716
aS'        displacement.write_selection(displacement_data, coordinates);'
p35717
aS'      }'
p35718
aS'    else'
p35719
aS'      {'
p35720
aS'        displacement.write_none<std::complex<double>>();'
p35721
aS'      }'
p35722
aS'    if (parameters.save_vtu_files)'
p35723
aS'      {'
p35724
aS'        std::vector<std::string> solution_names(dim, "displacement");'
p35725
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p35726
aS'          interpretation('
p35727
aS'            dim, DataComponentInterpretation::component_is_part_of_vector);'
p35728
aS'        DataOut<dim> data_out;'
p35729
aS'        data_out.add_data_vector(dof_handler,'
p35730
aS'                                 locally_relevant_solution,'
p35731
aS'                                 solution_names,'
p35732
aS'                                 interpretation);'
p35733
aS'        Vector<float> subdomain(triangulation.n_active_cells());'
p35734
aS'        for (unsigned int i = 0; i < subdomain.size(); ++i)'
p35735
aS'          subdomain(i) = triangulation.locally_owned_subdomain();'
p35736
aS'        data_out.add_data_vector(subdomain, "subdomain");'
p35737
aS'        std::vector<Vector<double>> force('
p35738
aS'          dim, Vector<double>(triangulation.n_active_cells()));'
p35739
aS'        std::vector<Vector<double>> pml('
p35740
aS'          dim, Vector<double>(triangulation.n_active_cells()));'
p35741
aS'        Vector<double> rho(triangulation.n_active_cells());'
p35742
aS'        for (auto &cell : triangulation.active_cell_iterators())'
p35743
aS'          {'
p35744
aS'            if (cell->is_locally_owned())'
p35745
aS'              {'
p35746
aS'                for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p35747
aS'                  {'
p35748
aS'                    force[dim_idx](cell->active_cell_index()) ='
p35749
aS'                      parameters.right_hand_side.value(cell->center(), dim_idx);'
p35750
aS'                    pml[dim_idx](cell->active_cell_index()) ='
p35751
aS'                      parameters.pml.value(cell->center(), dim_idx).imag();'
p35752
aS'                  }'
p35753
aS'                rho(cell->active_cell_index()) ='
p35754
aS'                  parameters.rho.value(cell->center());'
p35755
aS'              }'
p35756
aS'            else'
p35757
aS'              {'
p35758
aS'                for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p35759
aS'                  {'
p35760
aS'                    force[dim_idx](cell->active_cell_index()) = -1e+20;'
p35761
aS'                    pml[dim_idx](cell->active_cell_index())   = -1e+20;'
p35762
aS'                  }'
p35763
aS'                rho(cell->active_cell_index()) = -1e+20;'
p35764
aS'              }'
p35765
aS'          }'
p35766
aS'        for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p35767
aS'          {'
p35768
aS'            data_out.add_data_vector(force[dim_idx],'
p35769
aS'                                     "force_" + std::to_string(dim_idx));'
p35770
aS'            data_out.add_data_vector(pml[dim_idx],'
p35771
aS'                                     "pml_" + std::to_string(dim_idx));'
p35772
aS'          }'
p35773
aS'        data_out.add_data_vector(rho, "rho");'
p35774
aS'        data_out.build_patches();'
p35775
aS'        std::stringstream  frequency_idx_stream;'
p35776
aS'        const unsigned int nb_number_positions ='
p35777
aS'          ((unsigned int)std::log10(parameters.nb_frequency_points)) + 1;'
p35778
aS'        frequency_idx_stream << std::setw(nb_number_positions)'
p35779
aS"                             << std::setfill('0') << frequency_idx;"
p35780
aS'        std::string filename = (parameters.simulation_name + "_" +'
p35781
aS'                                frequency_idx_stream.str() + ".vtu");'
p35782
aS'        data_out.write_vtu_in_parallel(filename.c_str(), mpi_communicator);'
p35783
aS'      }'
p35784
aS'  }'
p35785
aS'  template <int dim>'
p35786
aS'  void ElasticWave<dim>::output_results()'
p35787
aS'  {'
p35788
aS'    if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p35789
aS'      {'
p35790
aS'        frequency_dataset.write(frequency);'
p35791
aS'        probe_positions_dataset.write(probe_positions);'
p35792
aS'      }'
p35793
aS'    else'
p35794
aS'      {'
p35795
aS'        frequency_dataset.write_none<double>();'
p35796
aS'        probe_positions_dataset.write_none<double>();'
p35797
aS'      }'
p35798
aS'  }'
p35799
aS'  template <int dim>'
p35800
aS'  void ElasticWave<dim>::setup_quadrature_cache()'
p35801
aS'  {'
p35802
aS'    triangulation.clear_user_data();'
p35803
aS'    {'
p35804
aS'      std::vector<QuadratureCache<dim>> tmp;'
p35805
aS'      quadrature_cache.swap(tmp);'
p35806
aS'    }'
p35807
aS'    quadrature_cache.resize(triangulation.n_locally_owned_active_cells() *'
p35808
aS'                              quadrature_formula.size(),'
p35809
aS'                            QuadratureCache<dim>(fe.n_dofs_per_cell()));'
p35810
aS'    unsigned int cache_index = 0;'
p35811
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p35812
aS'      if (cell->is_locally_owned())'
p35813
aS'        {'
p35814
aS'          cell->set_user_pointer(&quadrature_cache[cache_index]);'
p35815
aS'          cache_index += quadrature_formula.size();'
p35816
aS'        }'
p35817
aS'    Assert(cache_index == quadrature_cache.size(), ExcInternalError());'
p35818
aS'  }'
p35819
aS'  template <int dim>'
p35820
aS'  void ElasticWave<dim>::frequency_sweep()'
p35821
aS'  {'
p35822
aS'    for (unsigned int frequency_idx = 0;'
p35823
aS'         frequency_idx < parameters.nb_frequency_points;'
p35824
aS'         ++frequency_idx)'
p35825
aS'      {'
p35826
aS'        pcout << parameters.simulation_name + " frequency idx: "'
p35827
aS"              << frequency_idx << '/' << parameters.nb_frequency_points - 1"
p35828
aS'              << std::endl;'
p35829
aS'        setup_system();'
p35830
aS'        if (frequency_idx == 0)'
p35831
aS'          {'
p35832
aS'            pcout << "   Number of active cells :       "'
p35833
aS'                  << triangulation.n_active_cells() << std::endl;'
p35834
aS'            pcout << "   Number of degrees of freedom : "'
p35835
aS'                  << dof_handler.n_dofs() << std::endl;'
p35836
aS'          }'
p35837
aS'        if (frequency_idx == 0)'
p35838
aS'          {'
p35839
aS'            parameters.data.set_attribute("active_cells",'
p35840
aS'                                          triangulation.n_active_cells());'
p35841
aS'            parameters.data.set_attribute("degrees_of_freedom",'
p35842
aS'                                          dof_handler.n_dofs());'
p35843
aS'          }'
p35844
aS'        const double current_loop_frequency ='
p35845
aS'          (parameters.start_frequency +'
p35846
aS'           frequency_idx *'
p35847
aS'             (parameters.stop_frequency - parameters.start_frequency) /'
p35848
aS'             (parameters.nb_frequency_points - 1));'
p35849
aS'        const double current_loop_omega ='
p35850
aS'          2 * numbers::PI * current_loop_frequency;'
p35851
aS'        assemble_system(current_loop_omega,'
p35852
aS'                        (frequency_idx == 0) ? true : false);'
p35853
aS'        solve();'
p35854
aS'        frequency[frequency_idx] = current_loop_frequency;'
p35855
aS'        store_frequency_step_data(frequency_idx);'
p35856
aS'        computing_timer.print_summary();'
p35857
aS'        computing_timer.reset();'
p35858
aS'        pcout << std::endl;'
p35859
aS'      }'
p35860
aS'  }'
p35861
aS'  template <int dim>'
p35862
aS'  void ElasticWave<dim>::run()'
p35863
aS'  {'
p35864
aS'#ifdef DEBUG'
p35865
aS'    pcout << "Debug mode" << std::endl;'
p35866
aS'#else'
p35867
aS'    pcout << "Release mode" << std::endl;'
p35868
aS'#endif'
p35869
aS'    {'
p35870
aS'      Point<dim> p1;'
p35871
aS'      p1(0) = -parameters.dimension_x / 2;'
p35872
aS'      p1(1) = -parameters.dimension_y / 2;'
p35873
aS'      if (dim == 3)'
p35874
aS'        {'
p35875
aS'          p1(2) = -parameters.dimension_y / 2;'
p35876
aS'        }'
p35877
aS'      Point<dim> p2;'
p35878
aS'      p2(0) = parameters.dimension_x / 2;'
p35879
aS'      p2(1) = parameters.dimension_y / 2;'
p35880
aS'      if (dim == 3)'
p35881
aS'        {'
p35882
aS'          p2(2) = parameters.dimension_y / 2;'
p35883
aS'        }'
p35884
aS'      std::vector<unsigned int> divisions(dim);'
p35885
aS'      divisions[0] = int(parameters.dimension_x / parameters.dimension_y);'
p35886
aS'      divisions[1] = 1;'
p35887
aS'      if (dim == 3)'
p35888
aS'        {'
p35889
aS'          divisions[2] = 1;'
p35890
aS'        }'
p35891
aS'      GridGenerator::subdivided_hyper_rectangle(triangulation,'
p35892
aS'                                                divisions,'
p35893
aS'                                                p1,'
p35894
aS'                                                p2);'
p35895
aS'    }'
p35896
aS'    triangulation.refine_global(parameters.grid_level);'
p35897
aS'    setup_quadrature_cache();'
p35898
aS'    initialize_probe_positions_vector();'
p35899
aS'    frequency_sweep();'
p35900
aS'    output_results();'
p35901
aS'  }'
p35902
aS'} // namespace step62'
p35903
aS'int main(int argc, char *argv[])'
p35904
ag24
aS'  try'
p35905
aS'    {'
p35906
aS'      using namespace dealii;'
p35907
aS'      const unsigned int dim = 2;'
p35908
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p35909
aS'      HDF5::File data_file("results.h5",'
p35910
aS'                           HDF5::File::FileAccessMode::create,'
p35911
aS'                           MPI_COMM_WORLD);'
p35912
aS'      auto       data = data_file.create_group("data");'
p35913
aS'      const std::vector<std::string> group_names = {"displacement",'
p35914
aS'                                                    "calibration"};'
p35915
aS'      for (auto group_name : group_names)'
p35916
aS'        {'
p35917
aS'          auto group = data.create_group(group_name);'
p35918
aS'          group.set_attribute<double>("dimension_x", 2e-5);'
p35919
aS'          group.set_attribute<double>("dimension_y", 2e-8);'
p35920
aS'          group.set_attribute<double>("probe_pos_x", 8e-6);'
p35921
aS'          group.set_attribute<double>("probe_pos_y", 0);'
p35922
aS'          group.set_attribute<double>("probe_width_y", 2e-08);'
p35923
aS'          group.set_attribute<unsigned int>("nb_probe_points", 5);'
p35924
aS'          group.set_attribute<unsigned int>("grid_level", 1);'
p35925
aS'          group.set_attribute<double>("cavity_resonance_frequency", 20e9);'
p35926
aS'          group.set_attribute<unsigned int>("nb_mirror_pairs", 15);'
p35927
aS'          group.set_attribute<double>("poissons_ratio", 0.27);'
p35928
aS'          group.set_attribute<double>("youngs_modulus", 270000000000.0);'
p35929
aS'          group.set_attribute<double>("material_a_rho", 3200);'
p35930
aS'          if (group_name == std::string("displacement"))'
p35931
aS'            group.set_attribute<double>("material_b_rho", 2000);'
p35932
aS'          else'
p35933
aS'            group.set_attribute<double>("material_b_rho", 3200);'
p35934
aS'          group.set_attribute('
p35935
aS'            "lambda",'
p35936
aS'            group.get_attribute<double>("youngs_modulus") *'
p35937
aS'              group.get_attribute<double>("poissons_ratio") /'
p35938
aS'              ((1 + group.get_attribute<double>("poissons_ratio")) *'
p35939
aS'               (1 - 2 * group.get_attribute<double>("poissons_ratio"))));'
p35940
aS'          group.set_attribute("mu",'
p35941
aS'                              group.get_attribute<double>("youngs_modulus") /'
p35942
aS'                                (2 * (1 + group.get_attribute<double>('
p35943
aS'                                            "poissons_ratio"))));'
p35944
aS'          group.set_attribute<double>("max_force_amplitude", 1e26);'
p35945
aS'          group.set_attribute<double>("force_sigma_x", 1e-7);'
p35946
aS'          group.set_attribute<double>("force_sigma_y", 1);'
p35947
aS'          group.set_attribute<double>("max_force_width_x", 3e-7);'
p35948
aS'          group.set_attribute<double>("max_force_width_y", 2e-8);'
p35949
aS'          group.set_attribute<double>("force_x_pos", -8e-6);'
p35950
aS'          group.set_attribute<double>("force_y_pos", 0);'
p35951
aS'          group.set_attribute<bool>("pml_x", true);'
p35952
aS'          group.set_attribute<bool>("pml_y", false);'
p35953
aS'          group.set_attribute<double>("pml_width_x", 1.8e-6);'
p35954
aS'          group.set_attribute<double>("pml_width_y", 5e-7);'
p35955
aS'          group.set_attribute<double>("pml_coeff", 1.6);'
p35956
aS'          group.set_attribute<unsigned int>("pml_coeff_degree", 2);'
p35957
aS'          group.set_attribute<double>("center_frequency", 20e9);'
p35958
aS'          group.set_attribute<double>("frequency_range", 0.5e9);'
p35959
aS'          group.set_attribute<double>('
p35960
aS'            "start_frequency",'
p35961
aS'            group.get_attribute<double>("center_frequency") -'
p35962
aS'              group.get_attribute<double>("frequency_range") / 2);'
p35963
aS'          group.set_attribute<double>('
p35964
aS'            "stop_frequency",'
p35965
aS'            group.get_attribute<double>("center_frequency") +'
p35966
aS'              group.get_attribute<double>("frequency_range") / 2);'
p35967
aS'          group.set_attribute<unsigned int>("nb_frequency_points", 400);'
p35968
aS'          if (group_name == std::string("displacement"))'
p35969
aS'            group.set_attribute<std::string>('
p35970
aS'              "simulation_name", std::string("phononic_cavity_displacement"));'
p35971
aS'          else'
p35972
aS'            group.set_attribute<std::string>('
p35973
aS'              "simulation_name", std::string("phononic_cavity_calibration"));'
p35974
aS'          group.set_attribute<bool>("save_vtu_files", false);'
p35975
aS'        }'
p35976
aS'      {'
p35977
aS'        auto                    displacement = data.open_group("displacement");'
p35978
aS'        step62::Parameters<dim> parameters(displacement);'
p35979
aS'        step62::ElasticWave<dim> elastic_problem(parameters);'
p35980
aS'        elastic_problem.run();'
p35981
aS'      }'
p35982
aS'      {'
p35983
aS'        auto                    calibration = data.open_group("calibration");'
p35984
aS'        step62::Parameters<dim> parameters(calibration);'
p35985
aS'        step62::ElasticWave<dim> elastic_problem(parameters);'
p35986
aS'        elastic_problem.run();'
p35987
aS'      }'
p35988
aS'    }'
p35989
aS'  catch (std::exception &exc)'
p35990
aS'    {'
p35991
aS'      std::cerr << std::endl'
p35992
aS'                << std::endl'
p35993
aS'                << "----------------------------------------------------"'
p35994
aS'                << std::endl;'
p35995
aS'      std::cerr << "Exception on processing: " << std::endl'
p35996
aS'                << exc.what() << std::endl'
p35997
aS'                << "Aborting!" << std::endl'
p35998
aS'                << "----------------------------------------------------"'
p35999
aS'                << std::endl;'
p36000
aS'      return 1;'
p36001
aS'    }'
p36002
aS'  catch (...)'
p36003
aS'    {'
p36004
aS'      std::cerr << std::endl'
p36005
aS'                << std::endl'
p36006
aS'                << "----------------------------------------------------"'
p36007
aS'                << std::endl;'
p36008
aS'      std::cerr << "Unknown exception!" << std::endl'
p36009
aS'                << "Aborting!" << std::endl'
p36010
aS'                << "----------------------------------------------------"'
p36011
aS'                << std::endl;'
p36012
aS'      return 1;'
p36013
aS'    }'
p36014
aS'  return 0;'
p36015
ag32
aS'/* ---------------------------------------------------------------------'
p36016
aS' *'
p36017
aS' * Copyright (C) 2018 - 2021 by the deal.II authors'
p36018
aS' *'
p36019
aS' * This file is part of the deal.II library.'
p36020
aS' *'
p36021
aS' * The deal.II library is free software; you can use it, redistribute'
p36022
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p36023
aS' * Public License as published by the Free Software Foundation; either'
p36024
aS' * version 2.1 of the License, or (at your option) any later version.'
p36025
aS' * The full text of the license can be found in the file LICENSE.md at'
p36026
aS' * the top level directory of deal.II.'
p36027
aS' *'
p36028
aS' * ---------------------------------------------------------------------'
p36029
aS' *'
p36030
aS' * Authors: Thomas C. Clevenger, Clemson University'
p36031
aS' *          Timo Heister, Clemson University and University of Utah'
p36032
aS' */'
p36033
aS'#include <deal.II/base/tensor_function.h>'
p36034
aS'#include <deal.II/base/quadrature_lib.h>'
p36035
aS'#include <deal.II/base/function.h>'
p36036
aS'#include <deal.II/base/timer.h>'
p36037
aS'#include <deal.II/base/parameter_handler.h>'
p36038
aS'#include <deal.II/lac/affine_constraints.h>'
p36039
aS'#include <deal.II/lac/vector.h>'
p36040
aS'#include <deal.II/lac/full_matrix.h>'
p36041
aS'#include <deal.II/lac/sparse_matrix.h>'
p36042
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p36043
aS'#include <deal.II/lac/solver_gmres.h>'
p36044
aS'#include <deal.II/lac/precondition.h>'
p36045
aS'#include <deal.II/lac/relaxation_block.h>'
p36046
aS'#include <deal.II/grid/tria.h>'
p36047
aS'#include <deal.II/grid/grid_generator.h>'
p36048
aS'#include <deal.II/grid/grid_refinement.h>'
p36049
aS'#include <deal.II/grid/manifold_lib.h>'
p36050
aS'#include <deal.II/grid/grid_out.h>'
p36051
aS'#include <deal.II/dofs/dof_handler.h>'
p36052
aS'#include <deal.II/dofs/dof_renumbering.h>'
p36053
aS'#include <deal.II/dofs/dof_tools.h>'
p36054
aS'#include <deal.II/fe/fe_q.h>'
p36055
aS'#include <deal.II/fe/mapping_q.h>'
p36056
aS'#include <deal.II/fe/fe_values.h>'
p36057
aS'#include <deal.II/numerics/vector_tools.h>'
p36058
aS'#include <deal.II/numerics/matrix_tools.h>'
p36059
aS'#include <deal.II/numerics/data_out.h>'
p36060
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p36061
aS'#include <deal.II/multigrid/multigrid.h>'
p36062
aS'#include <deal.II/multigrid/mg_transfer.h>'
p36063
aS'#include <deal.II/multigrid/mg_tools.h>'
p36064
aS'#include <deal.II/multigrid/mg_coarse.h>'
p36065
aS'#include <deal.II/multigrid/mg_smoother.h>'
p36066
aS'#include <deal.II/multigrid/mg_matrix.h>'
p36067
aS'#include <algorithm>'
p36068
aS'#include <fstream>'
p36069
aS'#include <iostream>'
p36070
aS'#include <random>'
p36071
aS'#include <deal.II/meshworker/mesh_loop.h>'
p36072
aS'namespace Step63'
p36073
ag24
aS'  using namespace dealii;'
p36074
aS'  template <int dim>'
p36075
aS'  struct ScratchData'
p36076
aS'  {'
p36077
aS'    ScratchData(const FiniteElement<dim> &fe,'
p36078
aS'                const unsigned int        quadrature_degree)'
p36079
aS'      : fe_values(fe,'
p36080
aS'                  QGauss<dim>(quadrature_degree),'
p36081
aS'                  update_values | update_gradients | update_hessians |'
p36082
aS'                    update_quadrature_points | update_JxW_values)'
p36083
aS'    {}'
p36084
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p36085
aS'      : fe_values(scratch_data.fe_values.get_fe(),'
p36086
aS'                  scratch_data.fe_values.get_quadrature(),'
p36087
aS'                  update_values | update_gradients | update_hessians |'
p36088
aS'                    update_quadrature_points | update_JxW_values)'
p36089
aS'    {}'
p36090
aS'    FEValues<dim> fe_values;'
p36091
aS'  };'
p36092
aS'  struct CopyData'
p36093
aS'  {'
p36094
aS'    CopyData() = default;'
p36095
aS'    unsigned int level;'
p36096
aS'    unsigned int dofs_per_cell;'
p36097
aS'    FullMatrix<double>                   cell_matrix;'
p36098
aS'    Vector<double>                       cell_rhs;'
p36099
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p36100
aS'  };'
p36101
aS'  struct Settings'
p36102
aS'  {'
p36103
aS'    enum DoFRenumberingStrategy'
p36104
aS'    {'
p36105
aS'      none,'
p36106
aS'      downstream,'
p36107
aS'      upstream,'
p36108
aS'      random'
p36109
aS'    };'
p36110
aS'    void get_parameters(const std::string &prm_filename);'
p36111
aS'    double                 epsilon;'
p36112
aS'    unsigned int           fe_degree;'
p36113
aS'    std::string            smoother_type;'
p36114
aS'    unsigned int           smoothing_steps;'
p36115
aS'    DoFRenumberingStrategy dof_renumbering;'
p36116
aS'    bool                   with_streamline_diffusion;'
p36117
aS'    bool                   output;'
p36118
aS'  };'
p36119
aS'  void Settings::get_parameters(const std::string &prm_filename)'
p36120
aS'  {'
p36121
aS'    ParameterHandler prm;'
p36122
aS'    prm.declare_entry("Epsilon",'
p36123
aS'                      "0.005",'
p36124
aS'                      Patterns::Double(0),'
p36125
aS'                      "Diffusion parameter");'
p36126
aS'    prm.declare_entry("Fe degree",'
p36127
aS'                      "1",'
p36128
aS'                      Patterns::Integer(1),'
p36129
aS'                      "Finite Element degree");'
p36130
aS'    prm.declare_entry("Smoother type",'
p36131
aS'                      "block SOR",'
p36132
aS'                      Patterns::Selection("SOR|Jacobi|block SOR|block Jacobi"),'
p36133
aS'                      "Select smoother: SOR|Jacobi|block SOR|block Jacobi");'
p36134
aS'    prm.declare_entry("Smoothing steps",'
p36135
aS'                      "2",'
p36136
aS'                      Patterns::Integer(1),'
p36137
aS'                      "Number of smoothing steps");'
p36138
aS'    prm.declare_entry('
p36139
aS'      "DoF renumbering",'
p36140
aS'      "downstream",'
p36141
aS'      Patterns::Selection("none|downstream|upstream|random"),'
p36142
aS'      "Select DoF renumbering: none|downstream|upstream|random");'
p36143
aS'    prm.declare_entry("With streamline diffusion",'
p36144
aS'                      "true",'
p36145
aS'                      Patterns::Bool(),'
p36146
aS'                      "Enable streamline diffusion stabilization: true|false");'
p36147
aS'    prm.declare_entry("Output",'
p36148
aS'                      "true",'
p36149
aS'                      Patterns::Bool(),'
p36150
aS'                      "Generate graphical output: true|false");'
p36151
aS'    if (prm_filename.empty())'
p36152
aS'      {'
p36153
aS'        prm.print_parameters(std::cout, ParameterHandler::Text);'
p36154
aS'        AssertThrow('
p36155
aS'          false, ExcMessage("Please pass a .prm file as the first argument!"));'
p36156
aS'      }'
p36157
aS'    prm.parse_input(prm_filename);'
p36158
aS'    epsilon         = prm.get_double("Epsilon");'
p36159
aS'    fe_degree       = prm.get_integer("Fe degree");'
p36160
aS'    smoother_type   = prm.get("Smoother type");'
p36161
aS'    smoothing_steps = prm.get_integer("Smoothing steps");'
p36162
aS'    const std::string renumbering = prm.get("DoF renumbering");'
p36163
aS'    if (renumbering == "none")'
p36164
aS'      dof_renumbering = DoFRenumberingStrategy::none;'
p36165
aS'    else if (renumbering == "downstream")'
p36166
aS'      dof_renumbering = DoFRenumberingStrategy::downstream;'
p36167
aS'    else if (renumbering == "upstream")'
p36168
aS'      dof_renumbering = DoFRenumberingStrategy::upstream;'
p36169
aS'    else if (renumbering == "random")'
p36170
aS'      dof_renumbering = DoFRenumberingStrategy::random;'
p36171
aS'    else'
p36172
aS'      AssertThrow(false,'
p36173
aS'                  ExcMessage("The <DoF renumbering> parameter has "'
p36174
aS'                             "an invalid value."));'
p36175
aS'    with_streamline_diffusion = prm.get_bool("With streamline diffusion");'
p36176
aS'    output                    = prm.get_bool("Output");'
p36177
aS'  }'
p36178
aS'  template <int dim>'
p36179
aS'  std::vector<unsigned int>'
p36180
aS'  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,'
p36181
aS'                                  const Tensor<1, dim>   direction,'
p36182
aS'                                  const unsigned int     level)'
p36183
aS'  {'
p36184
aS'    std::vector<typename DoFHandler<dim>::level_cell_iterator> ordered_cells;'
p36185
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));'
p36186
aS'    for (const auto &cell : dof_handler.cell_iterators_on_level(level))'
p36187
aS'      ordered_cells.push_back(cell);'
p36188
aS'    const DoFRenumbering::'
p36189
aS'      CompareDownstream<typename DoFHandler<dim>::level_cell_iterator, dim>'
p36190
aS'        comparator(direction);'
p36191
aS'    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);'
p36192
aS'    std::vector<unsigned> ordered_indices;'
p36193
aS'    ordered_indices.reserve(dof_handler.get_triangulation().n_cells(level));'
p36194
aS'    for (const auto &cell : ordered_cells)'
p36195
aS'      ordered_indices.push_back(cell->index());'
p36196
aS'    return ordered_indices;'
p36197
aS'  }'
p36198
aS'  template <int dim>'
p36199
aS'  std::vector<unsigned int>'
p36200
aS'  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,'
p36201
aS'                                  const Tensor<1, dim>   direction)'
p36202
aS'  {'
p36203
aS'    std::vector<typename DoFHandler<dim>::active_cell_iterator> ordered_cells;'
p36204
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());'
p36205
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p36206
aS'      ordered_cells.push_back(cell);'
p36207
aS'    const DoFRenumbering::'
p36208
aS'      CompareDownstream<typename DoFHandler<dim>::active_cell_iterator, dim>'
p36209
aS'        comparator(direction);'
p36210
aS'    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);'
p36211
aS'    std::vector<unsigned int> ordered_indices;'
p36212
aS'    ordered_indices.reserve(dof_handler.get_triangulation().n_active_cells());'
p36213
aS'    for (const auto &cell : ordered_cells)'
p36214
aS'      ordered_indices.push_back(cell->index());'
p36215
aS'    return ordered_indices;'
p36216
aS'  }'
p36217
aS'  template <int dim>'
p36218
aS'  std::vector<unsigned int>'
p36219
aS'  create_random_cell_ordering(const DoFHandler<dim> &dof_handler,'
p36220
aS'                              const unsigned int     level)'
p36221
aS'  {'
p36222
aS'    std::vector<unsigned int> ordered_cells;'
p36223
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));'
p36224
aS'    for (const auto &cell : dof_handler.cell_iterators_on_level(level))'
p36225
aS'      ordered_cells.push_back(cell->index());'
p36226
aS'    std::mt19937 random_number_generator;'
p36227
aS'    std::shuffle(ordered_cells.begin(),'
p36228
aS'                 ordered_cells.end(),'
p36229
aS'                 random_number_generator);'
p36230
aS'    return ordered_cells;'
p36231
aS'  }'
p36232
aS'  template <int dim>'
p36233
aS'  std::vector<unsigned int>'
p36234
aS'  create_random_cell_ordering(const DoFHandler<dim> &dof_handler)'
p36235
aS'  {'
p36236
aS'    std::vector<unsigned int> ordered_cells;'
p36237
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());'
p36238
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p36239
aS'      ordered_cells.push_back(cell->index());'
p36240
aS'    std::mt19937 random_number_generator;'
p36241
aS'    std::shuffle(ordered_cells.begin(),'
p36242
aS'                 ordered_cells.end(),'
p36243
aS'                 random_number_generator);'
p36244
aS'    return ordered_cells;'
p36245
aS'  }'
p36246
aS'  template <int dim>'
p36247
aS'  class RightHandSide : public Function<dim>'
p36248
aS'  {'
p36249
aS'  public:'
p36250
aS'    virtual double value(const Point<dim> & p,'
p36251
aS'                         const unsigned int component = 0) const override;'
p36252
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p36253
aS'                            std::vector<double> &          values,'
p36254
aS'                            const unsigned int component = 0) const override;'
p36255
aS'  };'
p36256
aS'  template <int dim>'
p36257
aS'  double RightHandSide<dim>::value(const Point<dim> &,'
p36258
aS'                                   const unsigned int component) const'
p36259
aS'  {'
p36260
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p36261
aS'    (void)component;'
p36262
aS'    return 0.0;'
p36263
aS'  }'
p36264
aS'  template <int dim>'
p36265
aS'  void RightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,'
p36266
aS'                                      std::vector<double> &          values,'
p36267
aS'                                      const unsigned int component) const'
p36268
aS'  {'
p36269
aS'    Assert(values.size() == points.size(),'
p36270
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p36271
aS'    for (unsigned int i = 0; i < points.size(); ++i)'
p36272
aS'      values[i] = RightHandSide<dim>::value(points[i], component);'
p36273
aS'  }'
p36274
aS'  template <int dim>'
p36275
aS'  class BoundaryValues : public Function<dim>'
p36276
aS'  {'
p36277
aS'  public:'
p36278
aS'    virtual double value(const Point<dim> & p,'
p36279
aS'                         const unsigned int component = 0) const override;'
p36280
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p36281
aS'                            std::vector<double> &          values,'
p36282
aS'                            const unsigned int component = 0) const override;'
p36283
aS'  };'
p36284
aS'  template <int dim>'
p36285
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p36286
aS'                                    const unsigned int component) const'
p36287
aS'  {'
p36288
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p36289
aS'    (void)component;'
p36290
aS'    if (std::fabs(p[0] - 1) < 1e-8 ||'
p36291
aS'        (std::fabs(p[1] + 1) < 1e-8 && p[0] >= 0.5))'
p36292
aS'      {'
p36293
aS'        return 1.0;'
p36294
aS'      }'
p36295
aS'    else'
p36296
aS'      {'
p36297
aS'        return 0.0;'
p36298
aS'      }'
p36299
aS'  }'
p36300
aS'  template <int dim>'
p36301
aS'  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,'
p36302
aS'                                       std::vector<double> &          values,'
p36303
aS'                                       const unsigned int component) const'
p36304
aS'  {'
p36305
aS'    Assert(values.size() == points.size(),'
p36306
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p36307
aS'    for (unsigned int i = 0; i < points.size(); ++i)'
p36308
aS'      values[i] = BoundaryValues<dim>::value(points[i], component);'
p36309
aS'  }'
p36310
aS'  template <int dim>'
p36311
aS'  double compute_stabilization_delta(const double         hk,'
p36312
aS'                                     const double         eps,'
p36313
aS'                                     const Tensor<1, dim> dir,'
p36314
aS'                                     const double         pk)'
p36315
aS'  {'
p36316
aS'    const double Peclet = dir.norm() * hk / (2.0 * eps * pk);'
p36317
aS'    const double coth ='
p36318
aS'      (1.0 + std::exp(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));'
p36319
aS'    return hk / (2.0 * dir.norm() * pk) * (coth - 1.0 / Peclet);'
p36320
aS'  }'
p36321
aS'  template <int dim>'
p36322
aS'  class AdvectionProblem'
p36323
aS'  {'
p36324
aS'  public:'
p36325
aS'    AdvectionProblem(const Settings &settings);'
p36326
aS'    void run();'
p36327
aS'  private:'
p36328
aS'    void setup_system();'
p36329
aS'    template <class IteratorType>'
p36330
aS'    void assemble_cell(const IteratorType &cell,'
p36331
aS'                       ScratchData<dim> &  scratch_data,'
p36332
aS'                       CopyData &          copy_data);'
p36333
aS'    void assemble_system_and_multigrid();'
p36334
aS'    void setup_smoother();'
p36335
aS'    void solve();'
p36336
aS'    void refine_grid();'
p36337
aS'    void output_results(const unsigned int cycle) const;'
p36338
aS'    Triangulation<dim> triangulation;'
p36339
aS'    DoFHandler<dim>    dof_handler;'
p36340
aS'    const FE_Q<dim>     fe;'
p36341
aS'    const MappingQ<dim> mapping;'
p36342
aS'    AffineConstraints<double> constraints;'
p36343
aS'    SparsityPattern      sparsity_pattern;'
p36344
aS'    SparseMatrix<double> system_matrix;'
p36345
aS'    Vector<double> solution;'
p36346
aS'    Vector<double> system_rhs;'
p36347
aS'    MGLevelObject<SparsityPattern> mg_sparsity_patterns;'
p36348
aS'    MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;'
p36349
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p36350
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_in;'
p36351
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_out;'
p36352
aS'    mg::Matrix<Vector<double>> mg_matrix;'
p36353
aS'    mg::Matrix<Vector<double>> mg_interface_matrix_in;'
p36354
aS'    mg::Matrix<Vector<double>> mg_interface_matrix_out;'
p36355
aS'    std::unique_ptr<MGSmoother<Vector<double>>> mg_smoother;'
p36356
aS'    using SmootherType ='
p36357
aS'      RelaxationBlock<SparseMatrix<double>, double, Vector<double>>;'
p36358
aS'    using SmootherAdditionalDataType = SmootherType::AdditionalData;'
p36359
aS'    MGLevelObject<SmootherAdditionalDataType> smoother_data;'
p36360
aS'    MGConstrainedDoFs mg_constrained_dofs;'
p36361
aS'    Tensor<1, dim> advection_direction;'
p36362
aS'    const Settings settings;'
p36363
aS'  };'
p36364
aS'  template <int dim>'
p36365
aS'  AdvectionProblem<dim>::AdvectionProblem(const Settings &settings)'
p36366
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p36367
aS'    , dof_handler(triangulation)'
p36368
aS'    , fe(settings.fe_degree)'
p36369
aS'    , mapping(settings.fe_degree)'
p36370
aS'    , settings(settings)'
p36371
aS'  {'
p36372
aS'    advection_direction[0] = -std::sin(numbers::PI / 6.0);'
p36373
aS'    if (dim >= 2)'
p36374
aS'      advection_direction[1] = std::cos(numbers::PI / 6.0);'
p36375
aS'    if (dim >= 3)'
p36376
aS'      AssertThrow(false, ExcNotImplemented());'
p36377
aS'  }'
p36378
aS'  template <int dim>'
p36379
aS'  void AdvectionProblem<dim>::setup_system()'
p36380
aS'  {'
p36381
aS'    const unsigned int n_levels = triangulation.n_levels();'
p36382
aS'    dof_handler.distribute_dofs(fe);'
p36383
aS'    solution.reinit(dof_handler.n_dofs());'
p36384
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p36385
aS'    constraints.clear();'
p36386
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p36387
aS'    VectorTools::interpolate_boundary_values('
p36388
aS'      mapping, dof_handler, 0, BoundaryValues<dim>(), constraints);'
p36389
aS'    VectorTools::interpolate_boundary_values('
p36390
aS'      mapping, dof_handler, 1, BoundaryValues<dim>(), constraints);'
p36391
aS'    constraints.close();'
p36392
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p36393
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p36394
aS'                                    dsp,'
p36395
aS'                                    constraints,'
p36396
aS'    sparsity_pattern.copy_from(dsp);'
p36397
aS'    system_matrix.reinit(sparsity_pattern);'
p36398
aS'    dof_handler.distribute_mg_dofs();'
p36399
aS'    if (settings.smoother_type == "SOR" || settings.smoother_type == "Jacobi")'
p36400
aS'      {'
p36401
aS'        if (settings.dof_renumbering =='
p36402
aS'              Settings::DoFRenumberingStrategy::downstream ||'
p36403
aS'            settings.dof_renumbering =='
p36404
aS'              Settings::DoFRenumberingStrategy::upstream)'
p36405
aS'          {'
p36406
aS'            const Tensor<1, dim> direction ='
p36407
aS'              (settings.dof_renumbering =='
p36408
aS'                   Settings::DoFRenumberingStrategy::upstream ?'
p36409
aS'                 -1.0 :'
p36410
aS'                 1.0) *'
p36411
aS'              advection_direction;'
p36412
aS'            for (unsigned int level = 0; level < n_levels; ++level)'
p36413
aS'              DoFRenumbering::downstream(dof_handler,'
p36414
aS'                                         level,'
p36415
aS'                                         direction,'
p36416
aS'          }'
p36417
aS'        else if (settings.dof_renumbering =='
p36418
aS'                 Settings::DoFRenumberingStrategy::random)'
p36419
aS'          {'
p36420
aS'            for (unsigned int level = 0; level < n_levels; ++level)'
p36421
aS'              DoFRenumbering::random(dof_handler, level);'
p36422
aS'          }'
p36423
aS'        else'
p36424
aS'          Assert(false, ExcNotImplemented());'
p36425
aS'      }'
p36426
aS'    mg_constrained_dofs.clear();'
p36427
aS'    mg_constrained_dofs.initialize(dof_handler);'
p36428
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});'
p36429
aS'    mg_matrices.resize(0, n_levels - 1);'
p36430
aS'    mg_matrices.clear_elements();'
p36431
aS'    mg_interface_in.resize(0, n_levels - 1);'
p36432
aS'    mg_interface_in.clear_elements();'
p36433
aS'    mg_interface_out.resize(0, n_levels - 1);'
p36434
aS'    mg_interface_out.clear_elements();'
p36435
aS'    mg_sparsity_patterns.resize(0, n_levels - 1);'
p36436
aS'    mg_interface_sparsity_patterns.resize(0, n_levels - 1);'
p36437
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p36438
aS'      {'
p36439
aS'        {'
p36440
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p36441
aS'                                     dof_handler.n_dofs(level));'
p36442
aS'          MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p36443
aS'          mg_sparsity_patterns[level].copy_from(dsp);'
p36444
aS'          mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p36445
aS'        }'
p36446
aS'        {'
p36447
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p36448
aS'                                     dof_handler.n_dofs(level));'
p36449
aS'          MGTools::make_interface_sparsity_pattern(dof_handler,'
p36450
aS'                                                   mg_constrained_dofs,'
p36451
aS'                                                   dsp,'
p36452
aS'                                                   level);'
p36453
aS'          mg_interface_sparsity_patterns[level].copy_from(dsp);'
p36454
aS'          mg_interface_in[level].reinit(mg_interface_sparsity_patterns[level]);'
p36455
aS'          mg_interface_out[level].reinit(mg_interface_sparsity_patterns[level]);'
p36456
aS'        }'
p36457
aS'      }'
p36458
aS'  }'
p36459
aS'  template <int dim>'
p36460
aS'  template <class IteratorType>'
p36461
aS'  void AdvectionProblem<dim>::assemble_cell(const IteratorType &cell,'
p36462
aS'                                            ScratchData<dim> &  scratch_data,'
p36463
aS'                                            CopyData &          copy_data)'
p36464
aS'  {'
p36465
aS'    copy_data.level = cell->level();'
p36466
aS'    const unsigned int dofs_per_cell ='
p36467
aS'      scratch_data.fe_values.get_fe().n_dofs_per_cell();'
p36468
aS'    copy_data.dofs_per_cell = dofs_per_cell;'
p36469
aS'    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p36470
aS'    const unsigned int n_q_points ='
p36471
aS'      scratch_data.fe_values.get_quadrature().size();'
p36472
aS'    if (cell->is_level_cell() == false)'
p36473
aS'      copy_data.cell_rhs.reinit(dofs_per_cell);'
p36474
aS'    copy_data.local_dof_indices.resize(dofs_per_cell);'
p36475
aS'    cell->get_active_or_mg_dof_indices(copy_data.local_dof_indices);'
p36476
aS'    scratch_data.fe_values.reinit(cell);'
p36477
aS'    RightHandSide<dim>  right_hand_side;'
p36478
aS'    std::vector<double> rhs_values(n_q_points);'
p36479
aS'    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),'
p36480
aS'                               rhs_values);'
p36481
aS'    const double delta = (settings.with_streamline_diffusion ?'
p36482
aS'                            compute_stabilization_delta(cell->diameter(),'
p36483
aS'                                                        settings.epsilon,'
p36484
aS'                                                        advection_direction,'
p36485
aS'                                                        settings.fe_degree) :'
p36486
aS'                            0.0);'
p36487
aS'    for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p36488
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p36489
aS'        {'
p36490
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p36491
aS'            {'
p36492
aS'              copy_data.cell_matrix(i, j) +='
p36493
aS'                (settings.epsilon *'
p36494
aS'                 scratch_data.fe_values.shape_grad(i, q_point) *'
p36495
aS'                 scratch_data.fe_values.shape_grad(j, q_point) *'
p36496
aS'                 scratch_data.fe_values.JxW(q_point)) +'
p36497
aS'                (scratch_data.fe_values.shape_value(i, q_point) *'
p36498
aS'                 (advection_direction *'
p36499
aS'                  scratch_data.fe_values.shape_grad(j, q_point)) *'
p36500
aS'                 scratch_data.fe_values.JxW(q_point))'
p36501
aS'                + delta *'
p36502
aS'                    (advection_direction *'
p36503
aS'                     scratch_data.fe_values.shape_grad(j, q_point)) *'
p36504
aS'                    (advection_direction *'
p36505
aS'                     scratch_data.fe_values.shape_grad(i, q_point)) *'
p36506
aS'                    scratch_data.fe_values.JxW(q_point) -'
p36507
aS'                delta * settings.epsilon *'
p36508
aS'                  trace(scratch_data.fe_values.shape_hessian(j, q_point)) *'
p36509
aS'                  (advection_direction *'
p36510
aS'                   scratch_data.fe_values.shape_grad(i, q_point)) *'
p36511
aS'                  scratch_data.fe_values.JxW(q_point);'
p36512
aS'            }'
p36513
aS'          if (cell->is_level_cell() == false)'
p36514
aS'            {'
p36515
aS'              copy_data.cell_rhs(i) +='
p36516
aS'                scratch_data.fe_values.shape_value(i, q_point) *'
p36517
aS'                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)'
p36518
aS'                + delta * rhs_values[q_point] * advection_direction *'
p36519
aS'                    scratch_data.fe_values.shape_grad(i, q_point) *'
p36520
aS'                    scratch_data.fe_values.JxW(q_point);'
p36521
aS'            }'
p36522
aS'        }'
p36523
aS'  }'
p36524
aS'  template <int dim>'
p36525
aS'  void AdvectionProblem<dim>::assemble_system_and_multigrid()'
p36526
aS'  {'
p36527
aS'    const auto cell_worker_active ='
p36528
aS'      [&](const decltype(dof_handler.begin_active()) &cell,'
p36529
aS'          ScratchData<dim> &                          scratch_data,'
p36530
aS'          CopyData &                                  copy_data) {'
p36531
aS'        this->assemble_cell(cell, scratch_data, copy_data);'
p36532
aS'      };'
p36533
aS'    const auto copier_active = [&](const CopyData &copy_data) {'
p36534
aS'      constraints.distribute_local_to_global(copy_data.cell_matrix,'
p36535
aS'                                             copy_data.cell_rhs,'
p36536
aS'                                             copy_data.local_dof_indices,'
p36537
aS'                                             system_matrix,'
p36538
aS'                                             system_rhs);'
p36539
aS'    };'
p36540
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p36541
aS'                          dof_handler.end(),'
p36542
aS'                          cell_worker_active,'
p36543
aS'                          copier_active,'
p36544
aS'                          ScratchData<dim>(fe, fe.degree + 1),'
p36545
aS'                          CopyData(),'
p36546
aS'                          MeshWorker::assemble_own_cells);'
p36547
aS'    std::vector<AffineConstraints<double>> boundary_constraints('
p36548
aS'      triangulation.n_global_levels());'
p36549
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p36550
aS'         ++level)'
p36551
aS'      {'
p36552
aS'        IndexSet locally_owned_level_dof_indices;'
p36553
aS'        DoFTools::extract_locally_relevant_level_dofs('
p36554
aS'          dof_handler, level, locally_owned_level_dof_indices);'
p36555
aS'        boundary_constraints[level].reinit(locally_owned_level_dof_indices);'
p36556
aS'        boundary_constraints[level].add_lines('
p36557
aS'          mg_constrained_dofs.get_refinement_edge_indices(level));'
p36558
aS'        boundary_constraints[level].add_lines('
p36559
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p36560
aS'        boundary_constraints[level].close();'
p36561
aS'      }'
p36562
aS'    const auto cell_worker_mg ='
p36563
aS'      [&](const decltype(dof_handler.begin_mg()) &cell,'
p36564
aS'          ScratchData<dim> &                      scratch_data,'
p36565
aS'          CopyData &                              copy_data) {'
p36566
aS'        this->assemble_cell(cell, scratch_data, copy_data);'
p36567
aS'      };'
p36568
aS'    const auto copier_mg = [&](const CopyData &copy_data) {'
p36569
aS'      boundary_constraints[copy_data.level].distribute_local_to_global('
p36570
aS'        copy_data.cell_matrix,'
p36571
aS'        copy_data.local_dof_indices,'
p36572
aS'        mg_matrices[copy_data.level]);'
p36573
aS'      for (unsigned int i = 0; i < copy_data.dofs_per_cell; ++i)'
p36574
aS'        for (unsigned int j = 0; j < copy_data.dofs_per_cell; ++j)'
p36575
aS'          if (mg_constrained_dofs.is_interface_matrix_entry('
p36576
aS'                copy_data.level,'
p36577
aS'                copy_data.local_dof_indices[i],'
p36578
aS'                copy_data.local_dof_indices[j]))'
p36579
aS'            {'
p36580
aS'              mg_interface_out[copy_data.level].add('
p36581
aS'                copy_data.local_dof_indices[i],'
p36582
aS'                copy_data.local_dof_indices[j],'
p36583
aS'                copy_data.cell_matrix(i, j));'
p36584
aS'              mg_interface_in[copy_data.level].add('
p36585
aS'                copy_data.local_dof_indices[i],'
p36586
aS'                copy_data.local_dof_indices[j],'
p36587
aS'                copy_data.cell_matrix(j, i));'
p36588
aS'            }'
p36589
aS'    };'
p36590
aS'    MeshWorker::mesh_loop(dof_handler.begin_mg(),'
p36591
aS'                          dof_handler.end_mg(),'
p36592
aS'                          cell_worker_mg,'
p36593
aS'                          copier_mg,'
p36594
aS'                          ScratchData<dim>(fe, fe.degree + 1),'
p36595
aS'                          CopyData(),'
p36596
aS'                          MeshWorker::assemble_own_cells);'
p36597
aS'  }'
p36598
aS'  template <int dim>'
p36599
aS'  void AdvectionProblem<dim>::setup_smoother()'
p36600
aS'  {'
p36601
aS'    if (settings.smoother_type == "SOR")'
p36602
aS'      {'
p36603
aS'        using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p36604
aS'        auto smoother ='
p36605
aS'          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,'
p36606
aS'                                                  Smoother,'
p36607
aS'                                                  Vector<double>>>();'
p36608
aS'        smoother->initialize(mg_matrices,'
p36609
aS'                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 :'
p36610
aS'                                                                       0.62));'
p36611
aS'        smoother->set_steps(settings.smoothing_steps);'
p36612
aS'        mg_smoother = std::move(smoother);'
p36613
aS'      }'
p36614
aS'    else if (settings.smoother_type == "Jacobi")'
p36615
aS'      {'
p36616
aS'        using Smoother = PreconditionJacobi<SparseMatrix<double>>;'
p36617
aS'        auto smoother ='
p36618
aS'          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,'
p36619
aS'                                                  Smoother,'
p36620
aS'                                                  Vector<double>>>();'
p36621
aS'        smoother->initialize(mg_matrices,'
p36622
aS'                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :'
p36623
aS'                                                                       0.47));'
p36624
aS'        smoother->set_steps(settings.smoothing_steps);'
p36625
aS'        mg_smoother = std::move(smoother);'
p36626
aS'      }'
p36627
aS'    else if (settings.smoother_type == "block SOR" ||'
p36628
aS'             settings.smoother_type == "block Jacobi")'
p36629
aS'      {'
p36630
aS'        smoother_data.resize(0, triangulation.n_levels() - 1);'
p36631
aS'        for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p36632
aS'          {'
p36633
aS'            DoFTools::make_cell_patches(smoother_data[level].block_list,'
p36634
aS'                                        dof_handler,'
p36635
aS'                                        level);'
p36636
aS'            smoother_data[level].relaxation ='
p36637
aS'              (settings.smoother_type == "block SOR" ? 1.0 : 0.25);'
p36638
aS'            smoother_data[level].inversion = PreconditionBlockBase<double>::svd;'
p36639
aS'            std::vector<unsigned int> ordered_indices;'
p36640
aS'            switch (settings.dof_renumbering)'
p36641
aS'              {'
p36642
aS'                case Settings::DoFRenumberingStrategy::downstream:'
p36643
aS'                  ordered_indices ='
p36644
aS'                    create_downstream_cell_ordering(dof_handler,'
p36645
aS'                                                    advection_direction,'
p36646
aS'                                                    level);'
p36647
aS'                  break;'
p36648
aS'                case Settings::DoFRenumberingStrategy::upstream:'
p36649
aS'                  ordered_indices ='
p36650
aS'                    create_downstream_cell_ordering(dof_handler,'
p36651
aS'                                                    -1.0 * advection_direction,'
p36652
aS'                                                    level);'
p36653
aS'                  break;'
p36654
aS'                case Settings::DoFRenumberingStrategy::random:'
p36655
aS'                  ordered_indices ='
p36656
aS'                    create_random_cell_ordering(dof_handler, level);'
p36657
aS'                  break;'
p36658
aS'                case Settings::DoFRenumberingStrategy::none:'
p36659
aS'                  break;'
p36660
aS'                default:'
p36661
aS'                  AssertThrow(false, ExcNotImplemented());'
p36662
aS'                  break;'
p36663
aS'              }'
p36664
aS'            smoother_data[level].order ='
p36665
aS'              std::vector<std::vector<unsigned int>>(1, ordered_indices);'
p36666
aS'          }'
p36667
aS'        if (settings.smoother_type == "block SOR")'
p36668
aS'          {'
p36669
aS'            auto smoother = std::make_unique<MGSmootherPrecondition<'
p36670
aS'              SparseMatrix<double>,'
p36671
aS'              RelaxationBlockSOR<SparseMatrix<double>, double, Vector<double>>,'
p36672
aS'              Vector<double>>>();'
p36673
aS'            smoother->initialize(mg_matrices, smoother_data);'
p36674
aS'            smoother->set_steps(settings.smoothing_steps);'
p36675
aS'            mg_smoother = std::move(smoother);'
p36676
aS'          }'
p36677
aS'        else if (settings.smoother_type == "block Jacobi")'
p36678
aS'          {'
p36679
aS'            auto smoother = std::make_unique<'
p36680
aS'              MGSmootherPrecondition<SparseMatrix<double>,'
p36681
aS'                                     RelaxationBlockJacobi<SparseMatrix<double>,'
p36682
aS'                                                           double,'
p36683
aS'                                                           Vector<double>>,'
p36684
aS'                                     Vector<double>>>();'
p36685
aS'            smoother->initialize(mg_matrices, smoother_data);'
p36686
aS'            smoother->set_steps(settings.smoothing_steps);'
p36687
aS'            mg_smoother = std::move(smoother);'
p36688
aS'          }'
p36689
aS'      }'
p36690
aS'    else'
p36691
aS'      AssertThrow(false, ExcNotImplemented());'
p36692
aS'  }'
p36693
aS'  template <int dim>'
p36694
aS'  void AdvectionProblem<dim>::solve()'
p36695
aS'  {'
p36696
aS'    const unsigned int max_iters       = 200;'
p36697
aS'    const double       solve_tolerance = 1e-8 * system_rhs.l2_norm();'
p36698
aS'    SolverControl      solver_control(max_iters, solve_tolerance, true, true);'
p36699
aS'    solver_control.enable_history_data();'
p36700
aS'    using Transfer = MGTransferPrebuilt<Vector<double>>;'
p36701
aS'    Transfer mg_transfer(mg_constrained_dofs);'
p36702
aS'    mg_transfer.build(dof_handler);'
p36703
aS'    FullMatrix<double> coarse_matrix;'
p36704
aS'    coarse_matrix.copy_from(mg_matrices[0]);'
p36705
aS'    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p36706
aS'    coarse_grid_solver.initialize(coarse_matrix);'
p36707
aS'    setup_smoother();'
p36708
aS'    mg_matrix.initialize(mg_matrices);'
p36709
aS'    mg_interface_matrix_in.initialize(mg_interface_in);'
p36710
aS'    mg_interface_matrix_out.initialize(mg_interface_out);'
p36711
aS'    Multigrid<Vector<double>> mg('
p36712
aS'      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);'
p36713
aS'    mg.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);'
p36714
aS'    PreconditionMG<dim, Vector<double>, Transfer> preconditioner(dof_handler,'
p36715
aS'                                                                 mg,'
p36716
aS'                                                                 mg_transfer);'
p36717
aS'    std::cout << "     Solving with GMRES to tol " << solve_tolerance << "..."'
p36718
aS'              << std::endl;'
p36719
aS'    SolverGMRES<Vector<double>> solver('
p36720
aS'      solver_control, SolverGMRES<Vector<double>>::AdditionalData(50, true));'
p36721
aS'    Timer time;'
p36722
aS'    time.start();'
p36723
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p36724
aS'    time.stop();'
p36725
aS'    std::cout << "          converged in " << solver_control.last_step()'
p36726
aS'              << " iterations"'
p36727
aS'              << " in " << time.last_wall_time() << " seconds " << std::endl;'
p36728
aS'    constraints.distribute(solution);'
p36729
aS'    mg_smoother.release();'
p36730
aS'  }'
p36731
aS'  template <int dim>'
p36732
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p36733
aS'  {'
p36734
aS'    const unsigned int n_active_cells = triangulation.n_active_cells();'
p36735
aS'    Vector<double>     cell_indices(n_active_cells);'
p36736
aS'    {'
p36737
aS'      std::vector<unsigned int> ordered_indices;'
p36738
aS'      switch (settings.dof_renumbering)'
p36739
aS'        {'
p36740
aS'          case Settings::DoFRenumberingStrategy::downstream:'
p36741
aS'            ordered_indices ='
p36742
aS'              create_downstream_cell_ordering(dof_handler, advection_direction);'
p36743
aS'            break;'
p36744
aS'          case Settings::DoFRenumberingStrategy::upstream:'
p36745
aS'            ordered_indices ='
p36746
aS'              create_downstream_cell_ordering(dof_handler,'
p36747
aS'                                              -1.0 * advection_direction);'
p36748
aS'            break;'
p36749
aS'          case Settings::DoFRenumberingStrategy::random:'
p36750
aS'            ordered_indices = create_random_cell_ordering(dof_handler);'
p36751
aS'            break;'
p36752
aS'          case Settings::DoFRenumberingStrategy::none:'
p36753
aS'            ordered_indices.resize(n_active_cells);'
p36754
aS'            for (unsigned int i = 0; i < n_active_cells; ++i)'
p36755
aS'              ordered_indices[i] = i;'
p36756
aS'            break;'
p36757
aS'          default:'
p36758
aS'            AssertThrow(false, ExcNotImplemented());'
p36759
aS'            break;'
p36760
aS'        }'
p36761
aS'      for (unsigned int i = 0; i < n_active_cells; ++i)'
p36762
aS'        cell_indices(ordered_indices[i]) = static_cast<double>(i);'
p36763
aS'    }'
p36764
aS'    DataOut<dim> data_out;'
p36765
aS'    data_out.attach_dof_handler(dof_handler);'
p36766
aS'    data_out.add_data_vector(solution, "solution");'
p36767
aS'    data_out.add_data_vector(cell_indices, "cell_index");'
p36768
aS'    data_out.build_patches();'
p36769
aS'    const std::string filename ='
p36770
aS'      "solution-" + Utilities::int_to_string(cycle) + ".vtu";'
p36771
aS'    std::ofstream output(filename.c_str());'
p36772
aS'    data_out.write_vtu(output);'
p36773
aS'  }'
p36774
aS'  template <int dim>'
p36775
aS'  void AdvectionProblem<dim>::run()'
p36776
aS'  {'
p36777
aS'    for (unsigned int cycle = 0; cycle < (settings.fe_degree == 1 ? 7 : 5);'
p36778
aS'         ++cycle)'
p36779
aS'      {'
p36780
aS'        std::cout << "  Cycle " << cycle << \':\' << std::endl;'
p36781
aS'        if (cycle == 0)'
p36782
aS'          {'
p36783
aS'            GridGenerator::hyper_cube_with_cylindrical_hole(triangulation,'
p36784
aS'                                                            0.3,'
p36785
aS'                                                            1.0);'
p36786
aS'            const SphericalManifold<dim> manifold_description(Point<dim>(0, 0));'
p36787
aS'            triangulation.set_manifold(1, manifold_description);'
p36788
aS'          }'
p36789
aS'        triangulation.refine_global();'
p36790
aS'        setup_system();'
p36791
aS'        std::cout << "     Number of active cells:       "'
p36792
aS'                  << triangulation.n_active_cells() << " ("'
p36793
aS'                  << triangulation.n_levels() << " levels)" << std::endl;'
p36794
aS'        std::cout << "     Number of degrees of freedom: "'
p36795
aS'                  << dof_handler.n_dofs() << std::endl;'
p36796
aS'        assemble_system_and_multigrid();'
p36797
aS'        solve();'
p36798
aS'        if (settings.output)'
p36799
aS'          output_results(cycle);'
p36800
aS'        std::cout << std::endl;'
p36801
aS'      }'
p36802
aS'  }'
p36803
aS'} // namespace Step63'
p36804
aS'int main(int argc, char *argv[])'
p36805
ag24
aS'  try'
p36806
aS'    {'
p36807
aS'      Step63::Settings settings;'
p36808
aS'      settings.get_parameters((argc > 1) ? (argv[1]) : "");'
p36809
aS'      Step63::AdvectionProblem<2> advection_problem_2d(settings);'
p36810
aS'      advection_problem_2d.run();'
p36811
aS'    }'
p36812
aS'  catch (std::exception &exc)'
p36813
aS'    {'
p36814
aS'      std::cerr << std::endl'
p36815
aS'                << std::endl'
p36816
aS'                << "----------------------------------------------------"'
p36817
aS'                << std::endl;'
p36818
aS'      std::cerr << "Exception on processing: " << std::endl'
p36819
aS'                << exc.what() << std::endl'
p36820
aS'                << "Aborting!" << std::endl'
p36821
aS'                << "----------------------------------------------------"'
p36822
aS'                << std::endl;'
p36823
aS'      return 1;'
p36824
aS'    }'
p36825
aS'  catch (...)'
p36826
aS'    {'
p36827
aS'      std::cerr << std::endl'
p36828
aS'                << std::endl'
p36829
aS'                << "----------------------------------------------------"'
p36830
aS'                << std::endl;'
p36831
aS'      std::cerr << "Unknown exception!" << std::endl'
p36832
aS'                << "Aborting!" << std::endl'
p36833
aS'                << "----------------------------------------------------"'
p36834
aS'                << std::endl;'
p36835
aS'      return 1;'
p36836
aS'    }'
p36837
aS'  return 0;'
p36838
ag32
aS'/* ---------------------------------------------------------------------'
p36839
aS' *'
p36840
aS' * Copyright (C) 2019 - 2021 by the deal.II authors'
p36841
aS' *'
p36842
aS' * This file is part of the deal.II library.'
p36843
aS' *'
p36844
aS' * The deal.II library is free software; you can use it, redistribute'
p36845
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p36846
aS' * Public License as published by the Free Software Foundation; either'
p36847
aS' * version 2.1 of the License, or (at your option) any later version.'
p36848
aS' * The full text of the license can be found in the file LICENSE.md at'
p36849
aS' * the top level directory of deal.II.'
p36850
aS' *'
p36851
aS' * ---------------------------------------------------------------------'
p36852
aS' * This tutorial program was contributed by Martin Kronbichler'
p36853
aS' */'
p36854
aS'#include <deal.II/base/timer.h>'
p36855
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p36856
aS'#include <deal.II/lac/precondition.h>'
p36857
aS'#include <deal.II/lac/solver_cg.h>'
p36858
aS'#include <deal.II/lac/sparse_matrix.h>'
p36859
aS'#include <deal.II/lac/vector.h>'
p36860
aS'#include <deal.II/grid/tria.h>'
p36861
aS'#include <deal.II/grid/grid_generator.h>'
p36862
aS'#include <deal.II/grid/grid_refinement.h>'
p36863
aS'#include <deal.II/grid/manifold_lib.h>'
p36864
aS'#include <deal.II/fe/fe_q.h>'
p36865
aS'#include <deal.II/fe/fe_values.h>'
p36866
aS'#include <deal.II/fe/mapping_q_generic.h>'
p36867
aS'#include <deal.II/dofs/dof_handler.h>'
p36868
aS'#include <deal.II/dofs/dof_tools.h>'
p36869
aS'#include <deal.II/numerics/data_out.h>'
p36870
aS'#include <deal.II/numerics/error_estimator.h>'
p36871
aS'#include <deal.II/numerics/vector_tools.h>'
p36872
aS'#include <fstream>'
p36873
aS'#include <deal.II/fe/mapping_q_cache.h>'
p36874
aS'namespace Step65'
p36875
ag24
aS'  using namespace dealii;'
p36876
aS'  template <int dim>'
p36877
aS'  class ExactSolution : public Function<dim>'
p36878
aS'  {'
p36879
aS'  public:'
p36880
aS'    virtual double value(const Point<dim> &p,'
p36881
aS'                         const unsigned int /*component*/ = 0) const override'
p36882
aS'    {'
p36883
aS'      if (p.norm_square() < 0.25)'
p36884
aS'        return p.norm_square();'
p36885
aS'      else'
p36886
aS'        return 0.1 * p.norm_square() + (0.25 - 0.025);'
p36887
aS'    }'
p36888
aS'    virtual Tensor<1, dim>'
p36889
aS'    gradient(const Point<dim> &p,'
p36890
aS'             const unsigned int /*component*/ = 0) const override'
p36891
aS'    {'
p36892
aS'      if (p.norm_square() < 0.25)'
p36893
aS'        return 2. * p;'
p36894
aS'      else'
p36895
aS'        return 0.2 * p;'
p36896
aS'    }'
p36897
aS'  };'
p36898
aS'  template <int dim>'
p36899
aS'  double coefficient(const Point<dim> &p)'
p36900
aS'  {'
p36901
aS'    if (p.norm_square() < 0.25)'
p36902
aS'      return 0.5;'
p36903
aS'    else'
p36904
aS'      return 5.0;'
p36905
aS'  }'
p36906
aS'  template <int dim>'
p36907
aS'  class PoissonProblem'
p36908
aS'  {'
p36909
aS'  public:'
p36910
aS'    PoissonProblem();'
p36911
aS'    void run();'
p36912
aS'  private:'
p36913
aS'    void create_grid();'
p36914
aS'    void setup_system(const Mapping<dim> &mapping);'
p36915
aS'    void assemble_system(const Mapping<dim> &mapping);'
p36916
aS'    void solve();'
p36917
aS'    void postprocess(const Mapping<dim> &mapping);'
p36918
aS'    Triangulation<dim> triangulation;'
p36919
aS'    FE_Q<dim>          fe;'
p36920
aS'    DoFHandler<dim>    dof_handler;'
p36921
aS'    AffineConstraints<double> constraints;'
p36922
aS'    SparsityPattern           sparsity_pattern;'
p36923
aS'    SparseMatrix<double>      system_matrix;'
p36924
aS'    Vector<double>            solution;'
p36925
aS'    Vector<double>            system_rhs;'
p36926
aS'    TimerOutput timer;'
p36927
aS'  };'
p36928
aS'  template <int dim>'
p36929
aS'  PoissonProblem<dim>::PoissonProblem()'
p36930
aS'    : fe(3)'
p36931
aS'    , dof_handler(triangulation)'
p36932
aS'    , timer(std::cout, TimerOutput::never, TimerOutput::wall_times)'
p36933
aS'  {}'
p36934
aS'  template <int dim>'
p36935
aS'  void PoissonProblem<dim>::create_grid()'
p36936
aS'  {'
p36937
aS'    Triangulation<dim> tria_inner;'
p36938
aS'    GridGenerator::hyper_ball(tria_inner, Point<dim>(), 0.5);'
p36939
aS'    Triangulation<dim> tria_outer;'
p36940
aS'    GridGenerator::hyper_shell('
p36941
aS'      tria_outer, Point<dim>(), 0.5, std::sqrt(dim), 2 * dim);'
p36942
aS'    GridGenerator::merge_triangulations(tria_inner, tria_outer, triangulation);'
p36943
aS'    triangulation.reset_all_manifolds();'
p36944
aS'    triangulation.set_all_manifold_ids(0);'
p36945
aS'    for (const auto &cell : triangulation.cell_iterators())'
p36946
aS'      {'
p36947
aS'        for (const auto &face : cell->face_iterators())'
p36948
aS'          {'
p36949
aS'            bool face_at_sphere_boundary = true;'
p36950
aS'            for (const auto v : face->vertex_indices())'
p36951
aS'              {'
p36952
aS'                if (std::abs(face->vertex(v).norm_square() - 0.25) > 1e-12)'
p36953
aS'                  face_at_sphere_boundary = false;'
p36954
aS'              }'
p36955
aS'            if (face_at_sphere_boundary)'
p36956
aS'              face->set_all_manifold_ids(1);'
p36957
aS'          }'
p36958
aS'        if (cell->center().norm_square() < 0.25)'
p36959
aS'          cell->set_material_id(1);'
p36960
aS'        else'
p36961
aS'          cell->set_material_id(0);'
p36962
aS'      }'
p36963
aS'    triangulation.set_manifold(1, SphericalManifold<dim>());'
p36964
aS'    TransfiniteInterpolationManifold<dim> transfinite_manifold;'
p36965
aS'    transfinite_manifold.initialize(triangulation);'
p36966
aS'    triangulation.set_manifold(0, transfinite_manifold);'
p36967
aS'    triangulation.refine_global(9 - 2 * dim);'
p36968
aS'  }'
p36969
aS'  template <int dim>'
p36970
aS'  void PoissonProblem<dim>::setup_system(const Mapping<dim> &mapping)'
p36971
aS'  {'
p36972
aS'    dof_handler.distribute_dofs(fe);'
p36973
aS'    std::cout << "   Number of active cells:       "'
p36974
aS'              << triangulation.n_global_active_cells() << std::endl;'
p36975
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p36976
aS'              << std::endl;'
p36977
aS'    {'
p36978
aS'      TimerOutput::Scope scope(timer, "Compute constraints");'
p36979
aS'      constraints.clear();'
p36980
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p36981
aS'      VectorTools::interpolate_boundary_values('
p36982
aS'        mapping, dof_handler, 0, ExactSolution<dim>(), constraints);'
p36983
aS'      constraints.close();'
p36984
aS'    }'
p36985
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p36986
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p36987
aS'    sparsity_pattern.copy_from(dsp);'
p36988
aS'    system_matrix.reinit(sparsity_pattern);'
p36989
aS'    solution.reinit(dof_handler.n_dofs());'
p36990
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p36991
aS'  }'
p36992
aS'  template <int dim>'
p36993
aS'  void PoissonProblem<dim>::assemble_system(const Mapping<dim> &mapping)'
p36994
aS'  {'
p36995
aS'    TimerOutput::Scope scope(timer, "Assemble linear system");'
p36996
aS'    const QGauss<dim> quadrature_formula(fe.degree + 2);'
p36997
aS'    FEValues<dim>     fe_values(mapping,'
p36998
aS'                            fe,'
p36999
aS'                            quadrature_formula,'
p37000
aS'                            update_values | update_gradients |'
p37001
aS'                              update_quadrature_points | update_JxW_values);'
p37002
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p37003
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p37004
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p37005
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p37006
aS'    FullMatrix<double> partial_matrix(dofs_per_cell, dim * n_q_points);'
p37007
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p37008
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p37009
aS'      {'
p37010
aS'        cell_rhs = 0.;'
p37011
aS'        fe_values.reinit(cell);'
p37012
aS'        for (unsigned int q_index = 0; q_index < n_q_points; ++q_index)'
p37013
aS'          {'
p37014
aS'            const double current_coefficient ='
p37015
aS'              coefficient(fe_values.quadrature_point(q_index));'
p37016
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p37017
aS'              {'
p37018
aS'                for (unsigned int d = 0; d < dim; ++d)'
p37019
aS'                  partial_matrix(i, q_index * dim + d) ='
p37020
aS'                    std::sqrt(fe_values.JxW(q_index) * current_coefficient) *'
p37021
aS'                    fe_values.shape_grad(i, q_index)[d];'
p37022
aS'                cell_rhs(i) +='
p37023
aS'                  (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p37024
aS'                   (-dim) *                            // f(x_q)'
p37025
aS'                   fe_values.JxW(q_index));            // dx'
p37026
aS'              }'
p37027
aS'          }'
p37028
aS'        partial_matrix.mTmult(cell_matrix, partial_matrix);'
p37029
aS'        cell->get_dof_indices(local_dof_indices);'
p37030
aS'        constraints.distribute_local_to_global('
p37031
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p37032
aS'      }'
p37033
aS'  }'
p37034
aS'  template <int dim>'
p37035
aS'  void PoissonProblem<dim>::solve()'
p37036
aS'  {'
p37037
aS'    TimerOutput::Scope scope(timer, "Solve linear system");'
p37038
aS'    SolverControl            solver_control(1000, 1e-12);'
p37039
aS'    SolverCG<Vector<double>> solver(solver_control);'
p37040
aS'    PreconditionJacobi<SparseMatrix<double>> preconditioner;'
p37041
aS'    preconditioner.initialize(system_matrix);'
p37042
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p37043
aS'    constraints.distribute(solution);'
p37044
aS'    std::cout << "   Number of solver iterations:  "'
p37045
aS'              << solver_control.last_step() << std::endl;'
p37046
aS'  }'
p37047
aS'  template <int dim>'
p37048
aS'  void PoissonProblem<dim>::postprocess(const Mapping<dim> &mapping)'
p37049
aS'  {'
p37050
aS'    {'
p37051
aS'      TimerOutput::Scope scope(timer, "Write output");'
p37052
aS'      DataOut<dim> data_out;'
p37053
aS'      DataOutBase::VtkFlags flags;'
p37054
aS'      flags.write_higher_order_cells = true;'
p37055
aS'      data_out.set_flags(flags);'
p37056
aS'      data_out.attach_dof_handler(dof_handler);'
p37057
aS'      data_out.add_data_vector(solution, "solution");'
p37058
aS'      Vector<double> material_ids(triangulation.n_active_cells());'
p37059
aS'      for (const auto &cell : triangulation.active_cell_iterators())'
p37060
aS'        material_ids[cell->active_cell_index()] = cell->material_id();'
p37061
aS'      data_out.add_data_vector(material_ids, "material_ids");'
p37062
aS'      data_out.build_patches(mapping,'
p37063
aS'                             fe.degree,'
p37064
aS'                             DataOut<dim>::curved_inner_cells);'
p37065
aS'      std::ofstream file('
p37066
aS'        ("solution-" +'
p37067
aS'         std::to_string(triangulation.n_global_levels() - 10 + 2 * dim) +'
p37068
aS'         ".vtu")'
p37069
aS'          .c_str());'
p37070
aS'      data_out.write_vtu(file);'
p37071
aS'    }'
p37072
aS'    {'
p37073
aS'      TimerOutput::Scope scope(timer, "Compute error norms");'
p37074
aS'      Vector<double> norm_per_cell_p(triangulation.n_active_cells());'
p37075
aS'      VectorTools::integrate_difference(mapping,'
p37076
aS'                                        dof_handler,'
p37077
aS'                                        solution,'
p37078
aS'                                        ExactSolution<dim>(),'
p37079
aS'                                        norm_per_cell_p,'
p37080
aS'                                        QGauss<dim>(fe.degree + 2),'
p37081
aS'                                        VectorTools::L2_norm);'
p37082
aS'      std::cout << "   L2 error vs exact solution:   "'
p37083
aS'                << norm_per_cell_p.l2_norm() << std::endl;'
p37084
aS'      VectorTools::integrate_difference(mapping,'
p37085
aS'                                        dof_handler,'
p37086
aS'                                        solution,'
p37087
aS'                                        ExactSolution<dim>(),'
p37088
aS'                                        norm_per_cell_p,'
p37089
aS'                                        QGauss<dim>(fe.degree + 2),'
p37090
aS'                                        VectorTools::H1_norm);'
p37091
aS'      std::cout << "   H1 error vs exact solution:   "'
p37092
aS'                << norm_per_cell_p.l2_norm() << std::endl;'
p37093
aS'    }'
p37094
aS'    {'
p37095
aS'      TimerOutput::Scope scope(timer, "Compute error estimator");'
p37096
aS'      Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p37097
aS'      KellyErrorEstimator<dim>::estimate('
p37098
aS'        mapping,'
p37099
aS'        dof_handler,'
p37100
aS'        QGauss<dim - 1>(fe.degree + 1),'
p37101
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p37102
aS'        solution,'
p37103
aS'        estimated_error_per_cell);'
p37104
aS'      std::cout << "   Max cell-wise error estimate: "'
p37105
aS'                << estimated_error_per_cell.linfty_norm() << std::endl;'
p37106
aS'    }'
p37107
aS'  }'
p37108
aS'  template <int dim>'
p37109
aS'  void PoissonProblem<dim>::run()'
p37110
aS'  {'
p37111
aS'    create_grid();'
p37112
aS'    {'
p37113
aS'      std::cout << std::endl'
p37114
aS'                << "====== Running with the basic MappingQGeneric class ====== "'
p37115
aS'                << std::endl'
p37116
aS'                << std::endl;'
p37117
aS'      MappingQGeneric<dim> mapping(fe.degree + 1);'
p37118
aS'      setup_system(mapping);'
p37119
aS'      assemble_system(mapping);'
p37120
aS'      solve();'
p37121
aS'      postprocess(mapping);'
p37122
aS'      timer.print_summary();'
p37123
aS'      timer.reset();'
p37124
aS'    }'
p37125
aS'    {'
p37126
aS'      std::cout'
p37127
aS'        << "====== Running with the optimized MappingQCache class ====== "'
p37128
aS'        << std::endl'
p37129
aS'        << std::endl;'
p37130
aS'      MappingQCache<dim> mapping(fe.degree + 1);'
p37131
aS'      {'
p37132
aS'        TimerOutput::Scope scope(timer, "Initialize mapping cache");'
p37133
aS'        mapping.initialize(MappingQGeneric<dim>(fe.degree + 1), triangulation);'
p37134
aS'      }'
p37135
aS'      std::cout << "   Memory consumption cache:     "'
p37136
aS'                << 1e-6 * mapping.memory_consumption() << " MB" << std::endl;'
p37137
aS'      setup_system(mapping);'
p37138
aS'      assemble_system(mapping);'
p37139
aS'      solve();'
p37140
aS'      postprocess(mapping);'
p37141
aS'      timer.print_summary();'
p37142
aS'    }'
p37143
aS'  }'
p37144
aS'} // namespace Step65'
p37145
aS'int main()'
p37146
ag24
aS'  Step65::PoissonProblem<3> test_program;'
p37147
aS'  test_program.run();'
p37148
aS'  return 0;'
p37149
ag32
aS'/* ---------------------------------------------------------------------'
p37150
aS' *'
p37151
aS' * Copyright (C) 2021 by the deal.II authors'
p37152
aS' *'
p37153
aS' * This file is part of the deal.II library.'
p37154
aS' *'
p37155
aS' * The deal.II library is free software; you can use it, redistribute'
p37156
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p37157
aS' * Public License as published by the Free Software Foundation; either'
p37158
aS' * version 2.1 of the License, or (at your option) any later version.'
p37159
aS' * The full text of the license can be found in the file LICENSE.md at'
p37160
aS' * the top level directory of deal.II.'
p37161
aS' *'
p37162
aS' * ---------------------------------------------------------------------'
p37163
aS' *'
p37164
aS' * Authors: Fabian Castelli, Karlsruhe Institute of Technology (KIT)'
p37165
aS' */'
p37166
aS'#include <deal.II/base/function.h>'
p37167
aS'#include <deal.II/base/quadrature_lib.h>'
p37168
aS'#include <deal.II/base/timer.h>'
p37169
aS'#include <deal.II/base/vectorization.h>'
p37170
aS'#include <deal.II/dofs/dof_accessor.h>'
p37171
aS'#include <deal.II/dofs/dof_handler.h>'
p37172
aS'#include <deal.II/dofs/dof_tools.h>'
p37173
aS'#include <deal.II/fe/fe_q.h>'
p37174
aS'#include <deal.II/fe/mapping_q_generic.h>'
p37175
aS'#include <deal.II/grid/grid_generator.h>'
p37176
aS'#include <deal.II/grid/grid_out.h>'
p37177
aS'#include <deal.II/grid/manifold_lib.h>'
p37178
aS'#include <deal.II/grid/tria.h>'
p37179
aS'#include <deal.II/grid/tria_accessor.h>'
p37180
aS'#include <deal.II/grid/tria_iterator.h>'
p37181
aS'#include <deal.II/lac/affine_constraints.h>'
p37182
aS'#include <deal.II/lac/precondition.h>'
p37183
aS'#include <deal.II/lac/solver_cg.h>'
p37184
aS'#include <deal.II/lac/vector.h>'
p37185
aS'#include <deal.II/numerics/data_out.h>'
p37186
aS'#include <deal.II/numerics/vector_tools.h>'
p37187
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p37188
aS'#include <deal.II/matrix_free/matrix_free.h>'
p37189
aS'#include <deal.II/matrix_free/operators.h>'
p37190
aS'#include <deal.II/matrix_free/tools.h>'
p37191
aS'#include <deal.II/multigrid/mg_coarse.h>'
p37192
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p37193
aS'#include <deal.II/multigrid/mg_matrix.h>'
p37194
aS'#include <deal.II/multigrid/mg_smoother.h>'
p37195
aS'#include <deal.II/multigrid/mg_tools.h>'
p37196
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p37197
aS'#include <deal.II/multigrid/multigrid.h>'
p37198
aS'#include <fstream>'
p37199
aS'#include <iostream>'
p37200
aS'namespace Step66'
p37201
ag24
aS'  using namespace dealii;'
p37202
aS'  template <int dim, int fe_degree, typename number>'
p37203
aS'  class JacobianOperator'
p37204
aS'    : public MatrixFreeOperators::'
p37205
aS'        Base<dim, LinearAlgebra::distributed::Vector<number>>'
p37206
aS'  {'
p37207
aS'  public:'
p37208
aS'    using value_type = number;'
p37209
aS'    using FECellIntegrator ='
p37210
aS'      FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number>;'
p37211
aS'    JacobianOperator();'
p37212
aS'    virtual void clear() override;'
p37213
aS'    void evaluate_newton_step('
p37214
aS'      const LinearAlgebra::distributed::Vector<number> &newton_step);'
p37215
aS'    virtual void compute_diagonal() override;'
p37216
aS'  private:'
p37217
aS'    virtual void apply_add('
p37218
aS'      LinearAlgebra::distributed::Vector<number> &      dst,'
p37219
aS'      const LinearAlgebra::distributed::Vector<number> &src) const override;'
p37220
aS'    void'
p37221
aS'    local_apply(const MatrixFree<dim, number> &                   data,'
p37222
aS'                LinearAlgebra::distributed::Vector<number> &      dst,'
p37223
aS'                const LinearAlgebra::distributed::Vector<number> &src,'
p37224
aS'                const std::pair<unsigned int, unsigned int> &cell_range) const;'
p37225
aS'    void local_compute_diagonal(FECellIntegrator &integrator) const;'
p37226
aS'    Table<2, VectorizedArray<number>> nonlinear_values;'
p37227
aS'  };'
p37228
aS'  template <int dim, int fe_degree, typename number>'
p37229
aS'  JacobianOperator<dim, fe_degree, number>::JacobianOperator()'
p37230
aS'    : MatrixFreeOperators::Base<dim,'
p37231
aS'                                LinearAlgebra::distributed::Vector<number>>()'
p37232
aS'  {}'
p37233
aS'  template <int dim, int fe_degree, typename number>'
p37234
aS'  void JacobianOperator<dim, fe_degree, number>::clear()'
p37235
aS'  {'
p37236
aS'    nonlinear_values.reinit(0, 0);'
p37237
aS'    MatrixFreeOperators::Base<dim, LinearAlgebra::distributed::Vector<number>>::'
p37238
aS'      clear();'
p37239
aS'  }'
p37240
aS'  template <int dim, int fe_degree, typename number>'
p37241
aS'  void JacobianOperator<dim, fe_degree, number>::evaluate_newton_step('
p37242
aS'    const LinearAlgebra::distributed::Vector<number> &newton_step)'
p37243
aS'  {'
p37244
aS'    const unsigned int n_cells = this->data->n_cell_batches();'
p37245
aS'    FECellIntegrator   phi(*this->data);'
p37246
aS'    nonlinear_values.reinit(n_cells, phi.n_q_points);'
p37247
aS'    for (unsigned int cell = 0; cell < n_cells; ++cell)'
p37248
aS'      {'
p37249
aS'        phi.reinit(cell);'
p37250
aS'        phi.read_dof_values_plain(newton_step);'
p37251
aS'        phi.evaluate(EvaluationFlags::values);'
p37252
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p37253
aS'          {'
p37254
aS'            nonlinear_values(cell, q) = std::exp(phi.get_value(q));'
p37255
aS'          }'
p37256
aS'      }'
p37257
aS'  }'
p37258
aS'  template <int dim, int fe_degree, typename number>'
p37259
aS'  void JacobianOperator<dim, fe_degree, number>::local_apply('
p37260
aS'    const MatrixFree<dim, number> &                   data,'
p37261
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p37262
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p37263
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p37264
aS'  {'
p37265
aS'    FECellIntegrator phi(data);'
p37266
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p37267
aS'      {'
p37268
aS'        AssertDimension(nonlinear_values.size(0),'
p37269
aS'                        phi.get_matrix_free().n_cell_batches());'
p37270
aS'        AssertDimension(nonlinear_values.size(1), phi.n_q_points);'
p37271
aS'        phi.reinit(cell);'
p37272
aS'        phi.gather_evaluate(src,'
p37273
aS'                            EvaluationFlags::values |'
p37274
aS'                              EvaluationFlags::gradients);'
p37275
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p37276
aS'          {'
p37277
aS'            phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);'
p37278
aS'            phi.submit_gradient(phi.get_gradient(q), q);'
p37279
aS'          }'
p37280
aS'        phi.integrate_scatter(EvaluationFlags::values |'
p37281
aS'                                EvaluationFlags::gradients,'
p37282
aS'                              dst);'
p37283
aS'      }'
p37284
aS'  }'
p37285
aS'  template <int dim, int fe_degree, typename number>'
p37286
aS'  void JacobianOperator<dim, fe_degree, number>::apply_add('
p37287
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p37288
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p37289
aS'  {'
p37290
aS'    this->data->cell_loop(&JacobianOperator::local_apply, this, dst, src);'
p37291
aS'  }'
p37292
aS'  template <int dim, int fe_degree, typename number>'
p37293
aS'  void JacobianOperator<dim, fe_degree, number>::local_compute_diagonal('
p37294
aS'    FECellIntegrator &phi) const'
p37295
aS'  {'
p37296
aS'    AssertDimension(nonlinear_values.size(0),'
p37297
aS'                    phi.get_matrix_free().n_cell_batches());'
p37298
aS'    AssertDimension(nonlinear_values.size(1), phi.n_q_points);'
p37299
aS'    const unsigned int cell = phi.get_current_cell_index();'
p37300
aS'    phi.evaluate(EvaluationFlags::values | EvaluationFlags::gradients);'
p37301
aS'    for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p37302
aS'      {'
p37303
aS'        phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);'
p37304
aS'        phi.submit_gradient(phi.get_gradient(q), q);'
p37305
aS'      }'
p37306
aS'    phi.integrate(EvaluationFlags::values | EvaluationFlags::gradients);'
p37307
aS'  }'
p37308
aS'  template <int dim, int fe_degree, typename number>'
p37309
aS'  void JacobianOperator<dim, fe_degree, number>::compute_diagonal()'
p37310
aS'  {'
p37311
aS'    this->inverse_diagonal_entries.reset('
p37312
aS'      new DiagonalMatrix<LinearAlgebra::distributed::Vector<number>>());'
p37313
aS'    LinearAlgebra::distributed::Vector<number> &inverse_diagonal ='
p37314
aS'      this->inverse_diagonal_entries->get_vector();'
p37315
aS'    this->data->initialize_dof_vector(inverse_diagonal);'
p37316
aS'    MatrixFreeTools::compute_diagonal(*this->data,'
p37317
aS'                                      inverse_diagonal,'
p37318
aS'                                      &JacobianOperator::local_compute_diagonal,'
p37319
aS'                                      this);'
p37320
aS'    for (auto &diagonal_element : inverse_diagonal)'
p37321
aS'      {'
p37322
aS'        diagonal_element = (std::abs(diagonal_element) > 1.0e-10) ?'
p37323
aS'                             (1.0 / diagonal_element) :'
p37324
aS'                             1.0;'
p37325
aS'      }'
p37326
aS'  }'
p37327
aS'  template <int dim, int fe_degree>'
p37328
aS'  class GelfandProblem'
p37329
aS'  {'
p37330
aS'  public:'
p37331
aS'    GelfandProblem();'
p37332
aS'    void run();'
p37333
aS'  private:'
p37334
aS'    void make_grid();'
p37335
aS'    void setup_system();'
p37336
aS'    void evaluate_residual('
p37337
aS'      LinearAlgebra::distributed::Vector<double> &      dst,'
p37338
aS'      const LinearAlgebra::distributed::Vector<double> &src) const;'
p37339
aS'    void local_evaluate_residual('
p37340
aS'      const MatrixFree<dim, double> &                   data,'
p37341
aS'      LinearAlgebra::distributed::Vector<double> &      dst,'
p37342
aS'      const LinearAlgebra::distributed::Vector<double> &src,'
p37343
aS'      const std::pair<unsigned int, unsigned int> &     cell_range) const;'
p37344
aS'    void assemble_rhs();'
p37345
aS'    double compute_residual(const double alpha);'
p37346
aS'    void compute_update();'
p37347
aS'    void solve();'
p37348
aS'    double compute_solution_norm() const;'
p37349
aS'    void output_results(const unsigned int cycle) const;'
p37350
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p37351
aS'    const MappingQGeneric<dim>                mapping;'
p37352
aS'    FE_Q<dim>       fe;'
p37353
aS'    DoFHandler<dim> dof_handler;'
p37354
aS'    AffineConstraints<double> constraints;'
p37355
aS'    using SystemMatrixType = JacobianOperator<dim, fe_degree, double>;'
p37356
aS'    SystemMatrixType system_matrix;'
p37357
aS'    MGConstrainedDoFs mg_constrained_dofs;'
p37358
aS'    using LevelMatrixType = JacobianOperator<dim, fe_degree, float>;'
p37359
aS'    MGLevelObject<LevelMatrixType>                           mg_matrices;'
p37360
aS'    MGLevelObject<LinearAlgebra::distributed::Vector<float>> mg_solution;'
p37361
aS'    MGTransferMatrixFree<dim, float>                         mg_transfer;'
p37362
aS'    LinearAlgebra::distributed::Vector<double> solution;'
p37363
aS'    LinearAlgebra::distributed::Vector<double> newton_update;'
p37364
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p37365
aS'    unsigned int linear_iterations;'
p37366
aS'    ConditionalOStream pcout;'
p37367
aS'    TimerOutput computing_timer;'
p37368
aS'  };'
p37369
aS'  template <int dim, int fe_degree>'
p37370
aS'  GelfandProblem<dim, fe_degree>::GelfandProblem()'
p37371
aS'    : triangulation(MPI_COMM_WORLD,'
p37372
aS'                    Triangulation<dim>::limit_level_difference_at_vertices,'
p37373
aS'                    parallel::distributed::Triangulation<'
p37374
aS'                      dim>::construct_multigrid_hierarchy)'
p37375
aS'    , mapping(fe_degree)'
p37376
aS'    , fe(fe_degree)'
p37377
aS'    , dof_handler(triangulation)'
p37378
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p37379
aS'    , computing_timer(MPI_COMM_WORLD,'
p37380
aS'                      pcout,'
p37381
aS'                      TimerOutput::never,'
p37382
aS'                      TimerOutput::wall_times)'
p37383
aS'  {}'
p37384
aS'  template <int dim, int fe_degree>'
p37385
aS'  void GelfandProblem<dim, fe_degree>::make_grid()'
p37386
aS'  {'
p37387
aS'    TimerOutput::Scope t(computing_timer, "make grid");'
p37388
aS'    SphericalManifold<dim>                boundary_manifold;'
p37389
aS'    TransfiniteInterpolationManifold<dim> inner_manifold;'
p37390
aS'    GridGenerator::hyper_ball(triangulation);'
p37391
aS'    triangulation.set_all_manifold_ids(1);'
p37392
aS'    triangulation.set_all_manifold_ids_on_boundary(0);'
p37393
aS'    triangulation.set_manifold(0, boundary_manifold);'
p37394
aS'    inner_manifold.initialize(triangulation);'
p37395
aS'    triangulation.set_manifold(1, inner_manifold);'
p37396
aS'    triangulation.refine_global(3 - dim);'
p37397
aS'  }'
p37398
aS'  template <int dim, int fe_degree>'
p37399
aS'  void GelfandProblem<dim, fe_degree>::setup_system()'
p37400
aS'  {'
p37401
aS'    TimerOutput::Scope t(computing_timer, "setup system");'
p37402
aS'    system_matrix.clear();'
p37403
aS'    mg_matrices.clear_elements();'
p37404
aS'    dof_handler.distribute_dofs(fe);'
p37405
aS'    dof_handler.distribute_mg_dofs();'
p37406
aS'    IndexSet locally_relevant_dofs;'
p37407
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p37408
aS'    constraints.clear();'
p37409
aS'    constraints.reinit(locally_relevant_dofs);'
p37410
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p37411
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p37412
aS'                                             0,'
p37413
aS'                                             Functions::ZeroFunction<dim>(),'
p37414
aS'                                             constraints);'
p37415
aS'    constraints.close();'
p37416
aS'    {'
p37417
aS'      typename MatrixFree<dim, double>::AdditionalData additional_data;'
p37418
aS'      additional_data.tasks_parallel_scheme ='
p37419
aS'        MatrixFree<dim, double>::AdditionalData::partition_color;'
p37420
aS'      additional_data.mapping_update_flags ='
p37421
aS'        (update_values | update_gradients | update_JxW_values |'
p37422
aS'         update_quadrature_points);'
p37423
aS'      auto system_mf_storage = std::make_shared<MatrixFree<dim, double>>();'
p37424
aS'      system_mf_storage->reinit(mapping,'
p37425
aS'                                dof_handler,'
p37426
aS'                                constraints,'
p37427
aS'                                QGauss<1>(fe.degree + 1),'
p37428
aS'                                additional_data);'
p37429
aS'      system_matrix.initialize(system_mf_storage);'
p37430
aS'    }'
p37431
aS'    system_matrix.initialize_dof_vector(solution);'
p37432
aS'    system_matrix.initialize_dof_vector(newton_update);'
p37433
aS'    system_matrix.initialize_dof_vector(system_rhs);'
p37434
aS'    const unsigned int nlevels = triangulation.n_global_levels();'
p37435
aS'    mg_matrices.resize(0, nlevels - 1);'
p37436
aS'    mg_solution.resize(0, nlevels - 1);'
p37437
aS'    std::set<types::boundary_id> dirichlet_boundary;'
p37438
aS'    dirichlet_boundary.insert(0);'
p37439
aS'    mg_constrained_dofs.initialize(dof_handler);'
p37440
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p37441
aS'                                                       dirichlet_boundary);'
p37442
aS'    mg_transfer.initialize_constraints(mg_constrained_dofs);'
p37443
aS'    mg_transfer.build(dof_handler);'
p37444
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p37445
aS'      {'
p37446
aS'        IndexSet relevant_dofs;'
p37447
aS'        DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p37448
aS'                                                      level,'
p37449
aS'                                                      relevant_dofs);'
p37450
aS'        AffineConstraints<double> level_constraints;'
p37451
aS'        level_constraints.reinit(relevant_dofs);'
p37452
aS'        level_constraints.add_lines('
p37453
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p37454
aS'        level_constraints.close();'
p37455
aS'        typename MatrixFree<dim, float>::AdditionalData additional_data;'
p37456
aS'        additional_data.tasks_parallel_scheme ='
p37457
aS'          MatrixFree<dim, float>::AdditionalData::partition_color;'
p37458
aS'        additional_data.mapping_update_flags ='
p37459
aS'          (update_values | update_gradients | update_JxW_values |'
p37460
aS'           update_quadrature_points);'
p37461
aS'        additional_data.mg_level = level;'
p37462
aS'        auto mg_mf_storage_level = std::make_shared<MatrixFree<dim, float>>();'
p37463
aS'        mg_mf_storage_level->reinit(mapping,'
p37464
aS'                                    dof_handler,'
p37465
aS'                                    level_constraints,'
p37466
aS'                                    QGauss<1>(fe.degree + 1),'
p37467
aS'                                    additional_data);'
p37468
aS'        mg_matrices[level].initialize(mg_mf_storage_level,'
p37469
aS'                                      mg_constrained_dofs,'
p37470
aS'                                      level);'
p37471
aS'        mg_matrices[level].initialize_dof_vector(mg_solution[level]);'
p37472
aS'      }'
p37473
aS'  }'
p37474
aS'  template <int dim, int fe_degree>'
p37475
aS'  void GelfandProblem<dim, fe_degree>::evaluate_residual('
p37476
aS'    LinearAlgebra::distributed::Vector<double> &      dst,'
p37477
aS'    const LinearAlgebra::distributed::Vector<double> &src) const'
p37478
aS'  {'
p37479
aS'    auto matrix_free = system_matrix.get_matrix_free();'
p37480
aS'    matrix_free->cell_loop('
p37481
aS'      &GelfandProblem::local_evaluate_residual, this, dst, src, true);'
p37482
aS'  }'
p37483
aS'  template <int dim, int fe_degree>'
p37484
aS'  void GelfandProblem<dim, fe_degree>::local_evaluate_residual('
p37485
aS'    const MatrixFree<dim, double> &                   data,'
p37486
aS'    LinearAlgebra::distributed::Vector<double> &      dst,'
p37487
aS'    const LinearAlgebra::distributed::Vector<double> &src,'
p37488
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p37489
aS'  {'
p37490
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, double> phi(data);'
p37491
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p37492
aS'      {'
p37493
aS'        phi.reinit(cell);'
p37494
aS'        phi.read_dof_values_plain(src);'
p37495
aS'        phi.evaluate(EvaluationFlags::values | EvaluationFlags::gradients);'
p37496
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p37497
aS'          {'
p37498
aS'            phi.submit_value(-std::exp(phi.get_value(q)), q);'
p37499
aS'            phi.submit_gradient(phi.get_gradient(q), q);'
p37500
aS'          }'
p37501
aS'        phi.integrate_scatter(EvaluationFlags::values |'
p37502
aS'                                EvaluationFlags::gradients,'
p37503
aS'                              dst);'
p37504
aS'      }'
p37505
aS'  }'
p37506
aS'  template <int dim, int fe_degree>'
p37507
aS'  void GelfandProblem<dim, fe_degree>::assemble_rhs()'
p37508
aS'  {'
p37509
aS'    TimerOutput::Scope t(computing_timer, "assemble right hand side");'
p37510
aS'    evaluate_residual(system_rhs, solution);'
p37511
aS'    system_rhs *= -1.0;'
p37512
aS'  }'
p37513
aS'  template <int dim, int fe_degree>'
p37514
aS'  double GelfandProblem<dim, fe_degree>::compute_residual(const double alpha)'
p37515
aS'  {'
p37516
aS'    TimerOutput::Scope t(computing_timer, "compute residual");'
p37517
aS'    LinearAlgebra::distributed::Vector<double> residual;'
p37518
aS'    LinearAlgebra::distributed::Vector<double> evaluation_point;'
p37519
aS'    system_matrix.initialize_dof_vector(residual);'
p37520
aS'    system_matrix.initialize_dof_vector(evaluation_point);'
p37521
aS'    evaluation_point = solution;'
p37522
aS'    if (alpha > 1e-12)'
p37523
aS'      {'
p37524
aS'        evaluation_point.add(alpha, newton_update);'
p37525
aS'      }'
p37526
aS'    evaluate_residual(residual, evaluation_point);'
p37527
aS'    return residual.l2_norm();'
p37528
aS'  }'
p37529
aS'  template <int dim, int fe_degree>'
p37530
aS'  void GelfandProblem<dim, fe_degree>::compute_update()'
p37531
aS'  {'
p37532
aS'    TimerOutput::Scope t(computing_timer, "compute update");'
p37533
aS'    solution.update_ghost_values();'
p37534
aS'    system_matrix.evaluate_newton_step(solution);'
p37535
aS'    mg_transfer.interpolate_to_mg(dof_handler, mg_solution, solution);'
p37536
aS'    using SmootherType ='
p37537
aS'      PreconditionChebyshev<LevelMatrixType,'
p37538
aS'                            LinearAlgebra::distributed::Vector<float>>;'
p37539
aS'    mg::SmootherRelaxation<SmootherType,'
p37540
aS'                           LinearAlgebra::distributed::Vector<float>>'
p37541
aS'                                                         mg_smoother;'
p37542
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data;'
p37543
aS'    smoother_data.resize(0, triangulation.n_global_levels() - 1);'
p37544
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p37545
aS'         ++level)'
p37546
aS'      {'
p37547
aS'        if (level > 0)'
p37548
aS'          {'
p37549
aS'            smoother_data[level].smoothing_range     = 15.;'
p37550
aS'            smoother_data[level].degree              = 4;'
p37551
aS'            smoother_data[level].eig_cg_n_iterations = 10;'
p37552
aS'          }'
p37553
aS'        else'
p37554
aS'          {'
p37555
aS'            smoother_data[0].smoothing_range = 1e-3;'
p37556
aS'            smoother_data[0].degree          = numbers::invalid_unsigned_int;'
p37557
aS'            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();'
p37558
aS'          }'
p37559
aS'        mg_matrices[level].evaluate_newton_step(mg_solution[level]);'
p37560
aS'        mg_matrices[level].compute_diagonal();'
p37561
aS'        smoother_data[level].preconditioner ='
p37562
aS'          mg_matrices[level].get_matrix_diagonal_inverse();'
p37563
aS'      }'
p37564
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p37565
aS'    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>>'
p37566
aS'      mg_coarse;'
p37567
aS'    mg_coarse.initialize(mg_smoother);'
p37568
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix('
p37569
aS'      mg_matrices);'
p37570
aS'    MGLevelObject<MatrixFreeOperators::MGInterfaceOperator<LevelMatrixType>>'
p37571
aS'      mg_interface_matrices;'
p37572
aS'    mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1);'
p37573
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p37574
aS'         ++level)'
p37575
aS'      {'
p37576
aS'        mg_interface_matrices[level].initialize(mg_matrices[level]);'
p37577
aS'      }'
p37578
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_interface('
p37579
aS'      mg_interface_matrices);'
p37580
aS'    Multigrid<LinearAlgebra::distributed::Vector<float>> mg('
p37581
aS'      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p37582
aS'    mg.set_edge_matrices(mg_interface, mg_interface);'
p37583
aS'    PreconditionMG<dim,'
p37584
aS'                   LinearAlgebra::distributed::Vector<float>,'
p37585
aS'                   MGTransferMatrixFree<dim, float>>'
p37586
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p37587
aS'    SolverControl solver_control(100, 1.e-12);'
p37588
aS'    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control);'
p37589
aS'    newton_update = 0.0;'
p37590
aS'    cg.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p37591
aS'    constraints.distribute(newton_update);'
p37592
aS'    linear_iterations = solver_control.last_step();'
p37593
aS'    solution.zero_out_ghost_values();'
p37594
aS'  }'
p37595
aS'  template <int dim, int fe_degree>'
p37596
aS'  void GelfandProblem<dim, fe_degree>::solve()'
p37597
aS'  {'
p37598
aS'    TimerOutput::Scope t(computing_timer, "solve");'
p37599
aS'    const unsigned int itmax = 10;'
p37600
aS'    const double       TOLf  = 1e-12;'
p37601
aS'    const double       TOLx  = 1e-10;'
p37602
aS'    Timer solver_timer;'
p37603
aS'    solver_timer.start();'
p37604
aS'    for (unsigned int newton_step = 1; newton_step <= itmax; ++newton_step)'
p37605
aS'      {'
p37606
aS'        assemble_rhs();'
p37607
aS'        compute_update();'
p37608
aS'        const double ERRx = newton_update.l2_norm();'
p37609
aS'        const double ERRf = compute_residual(1.0);'
p37610
aS'        solution.add(1.0, newton_update);'
p37611
aS'        pcout << "   Nstep " << newton_step << ", errf = " << ERRf'
p37612
aS'              << ", errx = " << ERRx << ", it = " << linear_iterations'
p37613
aS'              << std::endl;'
p37614
aS'        if (ERRf < TOLf || ERRx < TOLx)'
p37615
aS'          {'
p37616
aS'            solver_timer.stop();'
p37617
aS'            pcout << "Convergence step " << newton_step << " value " << ERRf'
p37618
aS'                  << " (used wall time: " << solver_timer.wall_time() << " s)"'
p37619
aS'                  << std::endl;'
p37620
aS'            break;'
p37621
aS'          }'
p37622
aS'        else if (newton_step == itmax)'
p37623
aS'          {'
p37624
aS'            solver_timer.stop();'
p37625
aS'            pcout << "WARNING: No convergence of Newton\'s method after "'
p37626
aS'                  << newton_step << " steps." << std::endl;'
p37627
aS'            break;'
p37628
aS'          }'
p37629
aS'      }'
p37630
aS'  }'
p37631
aS'  template <int dim, int fe_degree>'
p37632
aS'  double GelfandProblem<dim, fe_degree>::compute_solution_norm() const'
p37633
aS'  {'
p37634
aS'    solution.update_ghost_values();'
p37635
aS'    Vector<float> norm_per_cell(triangulation.n_active_cells());'
p37636
aS'    VectorTools::integrate_difference(mapping,'
p37637
aS'                                      dof_handler,'
p37638
aS'                                      solution,'
p37639
aS'                                      Functions::ZeroFunction<dim>(),'
p37640
aS'                                      norm_per_cell,'
p37641
aS'                                      QGauss<dim>(fe.degree + 2),'
p37642
aS'                                      VectorTools::H1_seminorm);'
p37643
aS'    solution.zero_out_ghost_values();'
p37644
aS'    return VectorTools::compute_global_error(triangulation,'
p37645
aS'                                             norm_per_cell,'
p37646
aS'                                             VectorTools::H1_seminorm);'
p37647
aS'  }'
p37648
aS'  template <int dim, int fe_degree>'
p37649
aS'  void'
p37650
aS'  GelfandProblem<dim, fe_degree>::output_results(const unsigned int cycle) const'
p37651
aS'  {'
p37652
aS'    if (triangulation.n_global_active_cells() > 1e6)'
p37653
aS'      return;'
p37654
aS'    solution.update_ghost_values();'
p37655
aS'    DataOut<dim> data_out;'
p37656
aS'    data_out.attach_dof_handler(dof_handler);'
p37657
aS'    data_out.add_data_vector(solution, "solution");'
p37658
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p37659
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p37660
aS'      {'
p37661
aS'        subdomain(i) = triangulation.locally_owned_subdomain();'
p37662
aS'      }'
p37663
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p37664
aS'    data_out.build_patches(mapping,'
p37665
aS'                           fe.degree,'
p37666
aS'                           DataOut<dim>::curved_inner_cells);'
p37667
aS'    DataOutBase::VtkFlags flags;'
p37668
aS'    flags.compression_level = DataOutBase::VtkFlags::best_speed;'
p37669
aS'    data_out.set_flags(flags);'
p37670
aS'    data_out.write_vtu_with_pvtu_record('
p37671
aS'      "./", "solution_" + std::to_string(dim) + "d", cycle, MPI_COMM_WORLD, 3);'
p37672
aS'    solution.zero_out_ghost_values();'
p37673
aS'  }'
p37674
aS'  template <int dim, int fe_degree>'
p37675
aS'  void GelfandProblem<dim, fe_degree>::run()'
p37676
aS'  {'
p37677
aS'    {'
p37678
aS'      const unsigned int n_ranks ='
p37679
aS'        Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD);'
p37680
aS'      const unsigned int n_vect_doubles = VectorizedArray<double>::size();'
p37681
aS'      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles;'
p37682
aS'      std::string DAT_header = "START DATE: " + Utilities::System::get_date() +'
p37683
aS'                               ", TIME: " + Utilities::System::get_time();'
p37684
aS'      std::string MPI_header = "Running with " + std::to_string(n_ranks) +'
p37685
aS'                               " MPI process" + (n_ranks > 1 ? "es" : "");'
p37686
aS'      std::string VEC_header ='
p37687
aS'        "Vectorization over " + std::to_string(n_vect_doubles) +'
p37688
aS'        " doubles = " + std::to_string(n_vect_bits) + " bits (" +'
p37689
aS'        Utilities::System::get_current_vectorization_level() +'
p37690
aS'        "), VECTORIZATION_LEVEL=" +'
p37691
aS'        std::to_string(DEAL_II_COMPILER_VECTORIZATION_LEVEL);'
p37692
aS'      std::string SOL_header = "Finite element space: " + fe.get_name();'
p37693
aS"      pcout << std::string(80, '=') << std::endl;"
p37694
aS'      pcout << DAT_header << std::endl;'
p37695
aS"      pcout << std::string(80, '-') << std::endl;"
p37696
aS'      pcout << MPI_header << std::endl;'
p37697
aS'      pcout << VEC_header << std::endl;'
p37698
aS'      pcout << SOL_header << std::endl;'
p37699
aS"      pcout << std::string(80, '=') << std::endl;"
p37700
aS'    }'
p37701
aS'    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle)'
p37702
aS'      {'
p37703
aS"        pcout << std::string(80, '-') << std::endl;"
p37704
aS'        pcout << "Cycle " << cycle << std::endl;'
p37705
aS"        pcout << std::string(80, '-') << std::endl;"
p37706
aS'        if (cycle == 0)'
p37707
aS'          {'
p37708
aS'            make_grid();'
p37709
aS'          }'
p37710
aS'        else'
p37711
aS'          {'
p37712
aS'            triangulation.refine_global(1);'
p37713
aS'          }'
p37714
aS'        Timer timer;'
p37715
aS'        pcout << "Set up system..." << std::endl;'
p37716
aS'        setup_system();'
p37717
aS'        pcout << "   Triangulation: " << triangulation.n_global_active_cells()'
p37718
aS'              << " cells" << std::endl;'
p37719
aS'        pcout << "   DoFHandler:    " << dof_handler.n_dofs() << " DoFs"'
p37720
aS'              << std::endl;'
p37721
aS'        pcout << std::endl;'
p37722
aS'        pcout << "Solve using Newton\'s method..." << std::endl;'
p37723
aS'        solve();'
p37724
aS'        pcout << std::endl;'
p37725
aS'        timer.stop();'
p37726
aS'        pcout << "Time for setup+solve (CPU/Wall) " << timer.cpu_time() << "/"'
p37727
aS'              << timer.wall_time() << " s" << std::endl;'
p37728
aS'        pcout << std::endl;'
p37729
aS'        pcout << "Output results..." << std::endl;'
p37730
aS'        const double norm = compute_solution_norm();'
p37731
aS'        output_results(cycle);'
p37732
aS'        pcout << "  H1 seminorm: " << norm << std::endl;'
p37733
aS'        pcout << std::endl;'
p37734
aS'        computing_timer.print_summary();'
p37735
aS'        computing_timer.reset();'
p37736
aS'      }'
p37737
aS'  }'
p37738
aS'} // namespace Step66'
p37739
aS'int main(int argc, char *argv[])'
p37740
ag24
aS'  try'
p37741
aS'    {'
p37742
aS'      using namespace Step66;'
p37743
aS'      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);'
p37744
aS'      {'
p37745
aS'        GelfandProblem<2, 4> gelfand_problem;'
p37746
aS'        gelfand_problem.run();'
p37747
aS'      }'
p37748
aS'      {'
p37749
aS'        GelfandProblem<3, 4> gelfand_problem;'
p37750
aS'        gelfand_problem.run();'
p37751
aS'      }'
p37752
aS'    }'
p37753
aS'  catch (std::exception &exc)'
p37754
aS'    {'
p37755
aS'      std::cerr << std::endl'
p37756
aS'                << std::endl'
p37757
aS'                << "----------------------------------------------------"'
p37758
aS'                << std::endl;'
p37759
aS'      std::cerr << "Exception on processing: " << std::endl'
p37760
aS'                << exc.what() << std::endl'
p37761
aS'                << "Aborting!" << std::endl'
p37762
aS'                << "----------------------------------------------------"'
p37763
aS'                << std::endl;'
p37764
aS'      return 1;'
p37765
aS'    }'
p37766
aS'  catch (...)'
p37767
aS'    {'
p37768
aS'      std::cerr << std::endl'
p37769
aS'                << std::endl'
p37770
aS'                << "----------------------------------------------------"'
p37771
aS'                << std::endl;'
p37772
aS'      std::cerr << "Unknown exception!" << std::endl'
p37773
aS'                << "Aborting!" << std::endl'
p37774
aS'                << "----------------------------------------------------"'
p37775
aS'                << std::endl;'
p37776
aS'      return 1;'
p37777
aS'    }'
p37778
aS'  return 0;'
p37779
ag32
aS'/* ---------------------------------------------------------------------'
p37780
aS' *'
p37781
aS' * Copyright (C) 2020 - 2021 by the deal.II authors'
p37782
aS' *'
p37783
aS' * This file is part of the deal.II library.'
p37784
aS' *'
p37785
aS' * The deal.II library is free software; you can use it, redistribute'
p37786
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p37787
aS' * Public License as published by the Free Software Foundation; either'
p37788
aS' * version 2.1 of the License, or (at your option) any later version.'
p37789
aS' * The full text of the license can be found in the file LICENSE.md at'
p37790
aS' * the top level directory of deal.II.'
p37791
aS' *'
p37792
aS' * ---------------------------------------------------------------------'
p37793
aS' *'
p37794
aS' * Author: Martin Kronbichler, 2020'
p37795
aS' */'
p37796
aS'#include <deal.II/base/conditional_ostream.h>'
p37797
aS'#include <deal.II/base/function.h>'
p37798
aS'#include <deal.II/base/logstream.h>'
p37799
aS'#include <deal.II/base/timer.h>'
p37800
aS'#include <deal.II/base/time_stepping.h>'
p37801
aS'#include <deal.II/base/utilities.h>'
p37802
aS'#include <deal.II/base/vectorization.h>'
p37803
aS'#include <deal.II/distributed/tria.h>'
p37804
aS'#include <deal.II/dofs/dof_handler.h>'
p37805
aS'#include <deal.II/fe/fe_dgq.h>'
p37806
aS'#include <deal.II/fe/fe_system.h>'
p37807
aS'#include <deal.II/grid/grid_generator.h>'
p37808
aS'#include <deal.II/grid/tria.h>'
p37809
aS'#include <deal.II/lac/affine_constraints.h>'
p37810
aS'#include <deal.II/lac/la_parallel_vector.h>'
p37811
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p37812
aS'#include <deal.II/matrix_free/matrix_free.h>'
p37813
aS'#include <deal.II/numerics/data_out.h>'
p37814
aS'#include <fstream>'
p37815
aS'#include <iomanip>'
p37816
aS'#include <iostream>'
p37817
aS'#include <deal.II/matrix_free/operators.h>'
p37818
aS'namespace Euler_DG'
p37819
ag24
aS'  using namespace dealii;'
p37820
aS'  constexpr unsigned int testcase             = 0;'
p37821
aS'  constexpr unsigned int dimension            = 2;'
p37822
aS'  constexpr unsigned int n_global_refinements = 3;'
p37823
aS'  constexpr unsigned int fe_degree            = 5;'
p37824
aS'  constexpr unsigned int n_q_points_1d        = fe_degree + 2;'
p37825
aS'  using Number = double;'
p37826
aS'  constexpr double gamma       = 1.4;'
p37827
aS'  constexpr double final_time  = testcase == 0 ? 10 : 2.0;'
p37828
aS'  constexpr double output_tick = testcase == 0 ? 1 : 0.05;'
p37829
aS'  const double courant_number = 0.15 / std::pow(fe_degree, 1.5);'
p37830
aS'  enum LowStorageRungeKuttaScheme'
p37831
aS'  {'
p37832
aS'    stage_3_order_3, /* Kennedy, Carpenter, Lewis, 2000 */'
p37833
aS'    stage_5_order_4, /* Kennedy, Carpenter, Lewis, 2000 */'
p37834
aS'    stage_7_order_4, /* Tselios, Simos, 2007 */'
p37835
aS'    stage_9_order_5, /* Kennedy, Carpenter, Lewis, 2000 */'
p37836
aS'  };'
p37837
aS'  constexpr LowStorageRungeKuttaScheme lsrk_scheme = stage_5_order_4;'
p37838
aS'  enum EulerNumericalFlux'
p37839
aS'  {'
p37840
aS'    lax_friedrichs_modified,'
p37841
aS'    harten_lax_vanleer,'
p37842
aS'  };'
p37843
aS'  constexpr EulerNumericalFlux numerical_flux_type = lax_friedrichs_modified;'
p37844
aS'  template <int dim>'
p37845
aS'  class ExactSolution : public Function<dim>'
p37846
aS'  {'
p37847
aS'  public:'
p37848
aS'    ExactSolution(const double time)'
p37849
aS'      : Function<dim>(dim + 2, time)'
p37850
aS'    {}'
p37851
aS'    virtual double value(const Point<dim> & p,'
p37852
aS'                         const unsigned int component = 0) const override;'
p37853
aS'  };'
p37854
aS'  template <int dim>'
p37855
aS'  double ExactSolution<dim>::value(const Point<dim> & x,'
p37856
aS'                                   const unsigned int component) const'
p37857
aS'  {'
p37858
aS'    const double t = this->get_time();'
p37859
aS'    switch (testcase)'
p37860
aS'      {'
p37861
aS'        case 0:'
p37862
aS'          {'
p37863
aS'            Assert(dim == 2, ExcNotImplemented());'
p37864
aS'            const double beta = 5;'
p37865
aS'            Point<dim> x0;'
p37866
aS'            x0[0] = 5.;'
p37867
aS'            const double radius_sqr ='
p37868
aS'              (x - x0).norm_square() - 2. * (x[0] - x0[0]) * t + t * t;'
p37869
aS'            const double factor ='
p37870
aS'              beta / (numbers::PI * 2) * std::exp(1. - radius_sqr);'
p37871
aS'            const double density_log = std::log2('
p37872
aS'              std::abs(1. - (gamma - 1.) / gamma * 0.25 * factor * factor));'
p37873
aS'            const double density = std::exp2(density_log * (1. / (gamma - 1.)));'
p37874
aS'            const double u       = 1. - factor * (x[1] - x0[1]);'
p37875
aS'            const double v       = factor * (x[0] - t - x0[0]);'
p37876
aS'            if (component == 0)'
p37877
aS'              return density;'
p37878
aS'            else if (component == 1)'
p37879
aS'              return density * u;'
p37880
aS'            else if (component == 2)'
p37881
aS'              return density * v;'
p37882
aS'            else'
p37883
aS'              {'
p37884
aS'                const double pressure ='
p37885
aS'                  std::exp2(density_log * (gamma / (gamma - 1.)));'
p37886
aS'                return pressure / (gamma - 1.) +'
p37887
aS'                       0.5 * (density * u * u + density * v * v);'
p37888
aS'              }'
p37889
aS'          }'
p37890
aS'        case 1:'
p37891
aS'          {'
p37892
aS'            if (component == 0)'
p37893
aS'              return 1.;'
p37894
aS'            else if (component == 1)'
p37895
aS'              return 0.4;'
p37896
aS'            else if (component == dim + 1)'
p37897
aS'              return 3.097857142857143;'
p37898
aS'            else'
p37899
aS'              return 0.;'
p37900
aS'          }'
p37901
aS'        default:'
p37902
aS'          Assert(false, ExcNotImplemented());'
p37903
aS'          return 0.;'
p37904
aS'      }'
p37905
aS'  }'
p37906
aS'  class LowStorageRungeKuttaIntegrator'
p37907
aS'  {'
p37908
aS'  public:'
p37909
aS'    LowStorageRungeKuttaIntegrator(const LowStorageRungeKuttaScheme scheme)'
p37910
aS'    {'
p37911
aS'      TimeStepping::runge_kutta_method lsrk;'
p37912
aS'      switch (scheme)'
p37913
aS'        {'
p37914
aS'          case stage_3_order_3:'
p37915
aS'            {'
p37916
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE3_ORDER3;'
p37917
aS'              break;'
p37918
aS'            }'
p37919
aS'          case stage_5_order_4:'
p37920
aS'            {'
p37921
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE5_ORDER4;'
p37922
aS'              break;'
p37923
aS'            }'
p37924
aS'          case stage_7_order_4:'
p37925
aS'            {'
p37926
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE7_ORDER4;'
p37927
aS'              break;'
p37928
aS'            }'
p37929
aS'          case stage_9_order_5:'
p37930
aS'            {'
p37931
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE9_ORDER5;'
p37932
aS'              break;'
p37933
aS'            }'
p37934
aS'          default:'
p37935
aS'            AssertThrow(false, ExcNotImplemented());'
p37936
aS'        }'
p37937
aS'      TimeStepping::LowStorageRungeKutta<'
p37938
aS'        LinearAlgebra::distributed::Vector<Number>>'
p37939
aS'        rk_integrator(lsrk);'
p37940
aS'      rk_integrator.get_coefficients(ai, bi, ci);'
p37941
aS'    }'
p37942
aS'    unsigned int n_stages() const'
p37943
aS'    {'
p37944
aS'      return bi.size();'
p37945
aS'    }'
p37946
aS'    template <typename VectorType, typename Operator>'
p37947
aS'    void perform_time_step(const Operator &pde_operator,'
p37948
aS'                           const double    current_time,'
p37949
aS'                           const double    time_step,'
p37950
aS'                           VectorType &    solution,'
p37951
aS'                           VectorType &    vec_ri,'
p37952
aS'                           VectorType &    vec_ki) const'
p37953
aS'    {'
p37954
aS'      AssertDimension(ai.size() + 1, bi.size());'
p37955
aS'      pde_operator.perform_stage(current_time,'
p37956
aS'                                 bi[0] * time_step,'
p37957
aS'                                 ai[0] * time_step,'
p37958
aS'                                 solution,'
p37959
aS'                                 vec_ri,'
p37960
aS'                                 solution,'
p37961
aS'                                 vec_ri);'
p37962
aS'      for (unsigned int stage = 1; stage < bi.size(); ++stage)'
p37963
aS'        {'
p37964
aS'          const double c_i = ci[stage];'
p37965
aS'          pde_operator.perform_stage(current_time + c_i * time_step,'
p37966
aS'                                     bi[stage] * time_step,'
p37967
aS'                                     (stage == bi.size() - 1 ?'
p37968
aS'                                        0 :'
p37969
aS'                                        ai[stage] * time_step),'
p37970
aS'                                     vec_ri,'
p37971
aS'                                     vec_ki,'
p37972
aS'                                     solution,'
p37973
aS'                                     vec_ri);'
p37974
aS'        }'
p37975
aS'    }'
p37976
aS'  private:'
p37977
aS'    std::vector<double> bi;'
p37978
aS'    std::vector<double> ai;'
p37979
aS'    std::vector<double> ci;'
p37980
aS'  };'
p37981
aS'  template <int dim, typename Number>'
p37982
aS'  inline DEAL_II_ALWAYS_INLINE //'
p37983
aS'    Tensor<1, dim, Number>'
p37984
aS'    euler_velocity(const Tensor<1, dim + 2, Number> &conserved_variables)'
p37985
aS'  {'
p37986
aS'    const Number inverse_density = Number(1.) / conserved_variables[0];'
p37987
aS'    Tensor<1, dim, Number> velocity;'
p37988
aS'    for (unsigned int d = 0; d < dim; ++d)'
p37989
aS'      velocity[d] = conserved_variables[1 + d] * inverse_density;'
p37990
aS'    return velocity;'
p37991
aS'  }'
p37992
aS'  template <int dim, typename Number>'
p37993
aS'  inline DEAL_II_ALWAYS_INLINE //'
p37994
aS'    Number'
p37995
aS'    euler_pressure(const Tensor<1, dim + 2, Number> &conserved_variables)'
p37996
aS'  {'
p37997
aS'    const Tensor<1, dim, Number> velocity ='
p37998
aS'      euler_velocity<dim>(conserved_variables);'
p37999
aS'    Number rho_u_dot_u = conserved_variables[1] * velocity[0];'
p38000
aS'    for (unsigned int d = 1; d < dim; ++d)'
p38001
aS'      rho_u_dot_u += conserved_variables[1 + d] * velocity[d];'
p38002
aS'    return (gamma - 1.) * (conserved_variables[dim + 1] - 0.5 * rho_u_dot_u);'
p38003
aS'  }'
p38004
aS'  template <int dim, typename Number>'
p38005
aS'  inline DEAL_II_ALWAYS_INLINE //'
p38006
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>>'
p38007
aS'    euler_flux(const Tensor<1, dim + 2, Number> &conserved_variables)'
p38008
aS'  {'
p38009
aS'    const Tensor<1, dim, Number> velocity ='
p38010
aS'      euler_velocity<dim>(conserved_variables);'
p38011
aS'    const Number pressure = euler_pressure<dim>(conserved_variables);'
p38012
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>> flux;'
p38013
aS'    for (unsigned int d = 0; d < dim; ++d)'
p38014
aS'      {'
p38015
aS'        flux[0][d] = conserved_variables[1 + d];'
p38016
aS'        for (unsigned int e = 0; e < dim; ++e)'
p38017
aS'          flux[e + 1][d] = conserved_variables[e + 1] * velocity[d];'
p38018
aS'        flux[d + 1][d] += pressure;'
p38019
aS'        flux[dim + 1][d] ='
p38020
aS'          velocity[d] * (conserved_variables[dim + 1] + pressure);'
p38021
aS'      }'
p38022
aS'    return flux;'
p38023
aS'  }'
p38024
aS'  template <int n_components, int dim, typename Number>'
p38025
aS'  inline DEAL_II_ALWAYS_INLINE //'
p38026
aS'    Tensor<1, n_components, Number>'
p38027
aS'    operator*(const Tensor<1, n_components, Tensor<1, dim, Number>> &matrix,'
p38028
aS'              const Tensor<1, dim, Number> &                         vector)'
p38029
aS'  {'
p38030
aS'    Tensor<1, n_components, Number> result;'
p38031
aS'    for (unsigned int d = 0; d < n_components; ++d)'
p38032
aS'      result[d] = matrix[d] * vector;'
p38033
aS'    return result;'
p38034
aS'  }'
p38035
aS'  template <int dim, typename Number>'
p38036
aS'  inline DEAL_II_ALWAYS_INLINE //'
p38037
aS'    Tensor<1, dim + 2, Number>'
p38038
aS'    euler_numerical_flux(const Tensor<1, dim + 2, Number> &u_m,'
p38039
aS'                         const Tensor<1, dim + 2, Number> &u_p,'
p38040
aS'                         const Tensor<1, dim, Number> &    normal)'
p38041
aS'  {'
p38042
aS'    const auto velocity_m = euler_velocity<dim>(u_m);'
p38043
aS'    const auto velocity_p = euler_velocity<dim>(u_p);'
p38044
aS'    const auto pressure_m = euler_pressure<dim>(u_m);'
p38045
aS'    const auto pressure_p = euler_pressure<dim>(u_p);'
p38046
aS'    const auto flux_m = euler_flux<dim>(u_m);'
p38047
aS'    const auto flux_p = euler_flux<dim>(u_p);'
p38048
aS'    switch (numerical_flux_type)'
p38049
aS'      {'
p38050
aS'        case lax_friedrichs_modified:'
p38051
aS'          {'
p38052
aS'            const auto lambda ='
p38053
aS'              0.5 * std::sqrt(std::max(velocity_p.norm_square() +'
p38054
aS'                                         gamma * pressure_p * (1. / u_p[0]),'
p38055
aS'                                       velocity_m.norm_square() +'
p38056
aS'                                         gamma * pressure_m * (1. / u_m[0])));'
p38057
aS'            return 0.5 * (flux_m * normal + flux_p * normal) +'
p38058
aS'                   0.5 * lambda * (u_m - u_p);'
p38059
aS'          }'
p38060
aS'        case harten_lax_vanleer:'
p38061
aS'          {'
p38062
aS'            const auto avg_velocity_normal ='
p38063
aS'              0.5 * ((velocity_m + velocity_p) * normal);'
p38064
aS'            const auto   avg_c = std::sqrt(std::abs('
p38065
aS'              0.5 * gamma *'
p38066
aS'              (pressure_p * (1. / u_p[0]) + pressure_m * (1. / u_m[0]))));'
p38067
aS'            const Number s_pos ='
p38068
aS'              std::max(Number(), avg_velocity_normal + avg_c);'
p38069
aS'            const Number s_neg ='
p38070
aS'              std::min(Number(), avg_velocity_normal - avg_c);'
p38071
aS'            const Number inverse_s = Number(1.) / (s_pos - s_neg);'
p38072
aS'            return inverse_s *'
p38073
aS'                   ((s_pos * (flux_m * normal) - s_neg * (flux_p * normal)) -'
p38074
aS'                    s_pos * s_neg * (u_m - u_p));'
p38075
aS'          }'
p38076
aS'        default:'
p38077
aS'          {'
p38078
aS'            Assert(false, ExcNotImplemented());'
p38079
aS'            return {};'
p38080
aS'          }'
p38081
aS'      }'
p38082
aS'  }'
p38083
aS'  template <int dim, typename Number>'
p38084
aS'  VectorizedArray<Number>'
p38085
aS'  evaluate_function(const Function<dim> &                      function,'
p38086
aS'                    const Point<dim, VectorizedArray<Number>> &p_vectorized,'
p38087
aS'                    const unsigned int                         component)'
p38088
aS'  {'
p38089
aS'    VectorizedArray<Number> result;'
p38090
aS'    for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v)'
p38091
aS'      {'
p38092
aS'        Point<dim> p;'
p38093
aS'        for (unsigned int d = 0; d < dim; ++d)'
p38094
aS'          p[d] = p_vectorized[d][v];'
p38095
aS'        result[v] = function.value(p, component);'
p38096
aS'      }'
p38097
aS'    return result;'
p38098
aS'  }'
p38099
aS'  template <int dim, typename Number, int n_components = dim + 2>'
p38100
aS'  Tensor<1, n_components, VectorizedArray<Number>>'
p38101
aS'  evaluate_function(const Function<dim> &                      function,'
p38102
aS'                    const Point<dim, VectorizedArray<Number>> &p_vectorized)'
p38103
aS'  {'
p38104
aS'    AssertDimension(function.n_components, n_components);'
p38105
aS'    Tensor<1, n_components, VectorizedArray<Number>> result;'
p38106
aS'    for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v)'
p38107
aS'      {'
p38108
aS'        Point<dim> p;'
p38109
aS'        for (unsigned int d = 0; d < dim; ++d)'
p38110
aS'          p[d] = p_vectorized[d][v];'
p38111
aS'        for (unsigned int d = 0; d < n_components; ++d)'
p38112
aS'          result[d][v] = function.value(p, d);'
p38113
aS'      }'
p38114
aS'    return result;'
p38115
aS'  }'
p38116
aS'  template <int dim, int degree, int n_points_1d>'
p38117
aS'  class EulerOperator'
p38118
aS'  {'
p38119
aS'  public:'
p38120
aS'    static constexpr unsigned int n_quadrature_points_1d = n_points_1d;'
p38121
aS'    EulerOperator(TimerOutput &timer_output);'
p38122
aS'    void reinit(const Mapping<dim> &   mapping,'
p38123
aS'                const DoFHandler<dim> &dof_handler);'
p38124
aS'    void set_inflow_boundary(const types::boundary_id       boundary_id,'
p38125
aS'                             std::unique_ptr<Function<dim>> inflow_function);'
p38126
aS'    void set_subsonic_outflow_boundary('
p38127
aS'      const types::boundary_id       boundary_id,'
p38128
aS'      std::unique_ptr<Function<dim>> outflow_energy);'
p38129
aS'    void set_wall_boundary(const types::boundary_id boundary_id);'
p38130
aS'    void set_body_force(std::unique_ptr<Function<dim>> body_force);'
p38131
aS'    void apply(const double                                      current_time,'
p38132
aS'               const LinearAlgebra::distributed::Vector<Number> &src,'
p38133
aS'               LinearAlgebra::distributed::Vector<Number> &      dst) const;'
p38134
aS'    void'
p38135
aS'    perform_stage(const Number cur_time,'
p38136
aS'                  const Number factor_solution,'
p38137
aS'                  const Number factor_ai,'
p38138
aS'                  const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p38139
aS'                  LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p38140
aS'                  LinearAlgebra::distributed::Vector<Number> &      solution,'
p38141
aS'                  LinearAlgebra::distributed::Vector<Number> &next_ri) const;'
p38142
aS'    void project(const Function<dim> &                       function,'
p38143
aS'                 LinearAlgebra::distributed::Vector<Number> &solution) const;'
p38144
aS'    std::array<double, 3> compute_errors('
p38145
aS'      const Function<dim> &                             function,'
p38146
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p38147
aS'    double compute_cell_transport_speed('
p38148
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p38149
aS'    void'
p38150
aS'    initialize_vector(LinearAlgebra::distributed::Vector<Number> &vector) const;'
p38151
aS'  private:'
p38152
aS'    MatrixFree<dim, Number> data;'
p38153
aS'    TimerOutput &timer;'
p38154
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p38155
aS'      inflow_boundaries;'
p38156
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p38157
aS'                                   subsonic_outflow_boundaries;'
p38158
aS'    std::set<types::boundary_id>   wall_boundaries;'
p38159
aS'    std::unique_ptr<Function<dim>> body_force;'
p38160
aS'    void local_apply_inverse_mass_matrix('
p38161
aS'      const MatrixFree<dim, Number> &                   data,'
p38162
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p38163
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p38164
aS'      const std::pair<unsigned int, unsigned int> &     cell_range) const;'
p38165
aS'    void local_apply_cell('
p38166
aS'      const MatrixFree<dim, Number> &                   data,'
p38167
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p38168
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p38169
aS'      const std::pair<unsigned int, unsigned int> &     cell_range) const;'
p38170
aS'    void local_apply_face('
p38171
aS'      const MatrixFree<dim, Number> &                   data,'
p38172
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p38173
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p38174
aS'      const std::pair<unsigned int, unsigned int> &     face_range) const;'
p38175
aS'    void local_apply_boundary_face('
p38176
aS'      const MatrixFree<dim, Number> &                   data,'
p38177
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p38178
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p38179
aS'      const std::pair<unsigned int, unsigned int> &     face_range) const;'
p38180
aS'  };'
p38181
aS'  template <int dim, int degree, int n_points_1d>'
p38182
aS'  EulerOperator<dim, degree, n_points_1d>::EulerOperator(TimerOutput &timer)'
p38183
aS'    : timer(timer)'
p38184
aS'  {}'
p38185
aS'  template <int dim, int degree, int n_points_1d>'
p38186
aS'  void EulerOperator<dim, degree, n_points_1d>::reinit('
p38187
aS'    const Mapping<dim> &   mapping,'
p38188
aS'    const DoFHandler<dim> &dof_handler)'
p38189
aS'  {'
p38190
aS'    const std::vector<const DoFHandler<dim> *> dof_handlers = {&dof_handler};'
p38191
aS'    const AffineConstraints<double>            dummy;'
p38192
aS'    const std::vector<const AffineConstraints<double> *> constraints = {&dummy};'
p38193
aS'    const std::vector<Quadrature<1>> quadratures = {QGauss<1>(n_q_points_1d),'
p38194
aS'                                                    QGauss<1>(fe_degree + 1)};'
p38195
aS'    typename MatrixFree<dim, Number>::AdditionalData additional_data;'
p38196
aS'    additional_data.mapping_update_flags ='
p38197
aS'      (update_gradients | update_JxW_values | update_quadrature_points |'
p38198
aS'       update_values);'
p38199
aS'    additional_data.mapping_update_flags_inner_faces ='
p38200
aS'      (update_JxW_values | update_quadrature_points | update_normal_vectors |'
p38201
aS'       update_values);'
p38202
aS'    additional_data.mapping_update_flags_boundary_faces ='
p38203
aS'      (update_JxW_values | update_quadrature_points | update_normal_vectors |'
p38204
aS'       update_values);'
p38205
aS'    additional_data.tasks_parallel_scheme ='
p38206
aS'      MatrixFree<dim, Number>::AdditionalData::none;'
p38207
aS'    data.reinit('
p38208
aS'      mapping, dof_handlers, constraints, quadratures, additional_data);'
p38209
aS'  }'
p38210
aS'  template <int dim, int degree, int n_points_1d>'
p38211
aS'  void EulerOperator<dim, degree, n_points_1d>::initialize_vector('
p38212
aS'    LinearAlgebra::distributed::Vector<Number> &vector) const'
p38213
aS'  {'
p38214
aS'    data.initialize_dof_vector(vector);'
p38215
aS'  }'
p38216
aS'  template <int dim, int degree, int n_points_1d>'
p38217
aS'  void EulerOperator<dim, degree, n_points_1d>::set_inflow_boundary('
p38218
aS'    const types::boundary_id       boundary_id,'
p38219
aS'    std::unique_ptr<Function<dim>> inflow_function)'
p38220
aS'  {'
p38221
aS'    AssertThrow(subsonic_outflow_boundaries.find(boundary_id) =='
p38222
aS'                    subsonic_outflow_boundaries.end() &&'
p38223
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p38224
aS'                ExcMessage("You already set the boundary with id " +'
p38225
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p38226
aS'                           " to another type of boundary before now setting " +'
p38227
aS'                           "it as inflow"));'
p38228
aS'    AssertThrow(inflow_function->n_components == dim + 2,'
p38229
aS'                ExcMessage("Expected function with dim+2 components"));'
p38230
aS'    inflow_boundaries[boundary_id] = std::move(inflow_function);'
p38231
aS'  }'
p38232
aS'  template <int dim, int degree, int n_points_1d>'
p38233
aS'  void EulerOperator<dim, degree, n_points_1d>::set_subsonic_outflow_boundary('
p38234
aS'    const types::boundary_id       boundary_id,'
p38235
aS'    std::unique_ptr<Function<dim>> outflow_function)'
p38236
aS'  {'
p38237
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p38238
aS'                    inflow_boundaries.end() &&'
p38239
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p38240
aS'                ExcMessage("You already set the boundary with id " +'
p38241
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p38242
aS'                           " to another type of boundary before now setting " +'
p38243
aS'                           "it as subsonic outflow"));'
p38244
aS'    AssertThrow(outflow_function->n_components == dim + 2,'
p38245
aS'                ExcMessage("Expected function with dim+2 components"));'
p38246
aS'    subsonic_outflow_boundaries[boundary_id] = std::move(outflow_function);'
p38247
aS'  }'
p38248
aS'  template <int dim, int degree, int n_points_1d>'
p38249
aS'  void EulerOperator<dim, degree, n_points_1d>::set_wall_boundary('
p38250
aS'    const types::boundary_id boundary_id)'
p38251
aS'  {'
p38252
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p38253
aS'                    inflow_boundaries.end() &&'
p38254
aS'                  subsonic_outflow_boundaries.find(boundary_id) =='
p38255
aS'                    subsonic_outflow_boundaries.end(),'
p38256
aS'                ExcMessage("You already set the boundary with id " +'
p38257
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p38258
aS'                           " to another type of boundary before now setting " +'
p38259
aS'                           "it as wall boundary"));'
p38260
aS'    wall_boundaries.insert(boundary_id);'
p38261
aS'  }'
p38262
aS'  template <int dim, int degree, int n_points_1d>'
p38263
aS'  void EulerOperator<dim, degree, n_points_1d>::set_body_force('
p38264
aS'    std::unique_ptr<Function<dim>> body_force)'
p38265
aS'  {'
p38266
aS'    AssertDimension(body_force->n_components, dim);'
p38267
aS'    this->body_force = std::move(body_force);'
p38268
aS'  }'
p38269
aS'  template <int dim, int degree, int n_points_1d>'
p38270
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_cell('
p38271
aS'    const MatrixFree<dim, Number> &,'
p38272
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p38273
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p38274
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p38275
aS'  {'
p38276
aS'    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data);'
p38277
aS'    Tensor<1, dim, VectorizedArray<Number>> constant_body_force;'
p38278
aS'    const Functions::ConstantFunction<dim> *constant_function ='
p38279
aS'      dynamic_cast<Functions::ConstantFunction<dim> *>(body_force.get());'
p38280
aS'    if (constant_function)'
p38281
aS'      constant_body_force = evaluate_function<dim, Number, dim>('
p38282
aS'        *constant_function, Point<dim, VectorizedArray<Number>>());'
p38283
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p38284
aS'      {'
p38285
aS'        phi.reinit(cell);'
p38286
aS'        phi.gather_evaluate(src, EvaluationFlags::values);'
p38287
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p38288
aS'          {'
p38289
aS'            const auto w_q = phi.get_value(q);'
p38290
aS'            phi.submit_gradient(euler_flux<dim>(w_q), q);'
p38291
aS'            if (body_force.get() != nullptr)'
p38292
aS'              {'
p38293
aS'                const Tensor<1, dim, VectorizedArray<Number>> force ='
p38294
aS'                  constant_function ? constant_body_force :'
p38295
aS'                                      evaluate_function<dim, Number, dim>('
p38296
aS'                                        *body_force, phi.quadrature_point(q));'
p38297
aS'                Tensor<1, dim + 2, VectorizedArray<Number>> forcing;'
p38298
aS'                for (unsigned int d = 0; d < dim; ++d)'
p38299
aS'                  forcing[d + 1] = w_q[0] * force[d];'
p38300
aS'                for (unsigned int d = 0; d < dim; ++d)'
p38301
aS'                  forcing[dim + 1] += force[d] * w_q[d + 1];'
p38302
aS'                phi.submit_value(forcing, q);'
p38303
aS'              }'
p38304
aS'          }'
p38305
aS'        phi.integrate_scatter(((body_force.get() != nullptr) ?'
p38306
aS'                                 EvaluationFlags::values :'
p38307
aS'                                 EvaluationFlags::nothing) |'
p38308
aS'                                EvaluationFlags::gradients,'
p38309
aS'                              dst);'
p38310
aS'      }'
p38311
aS'  }'
p38312
aS'  template <int dim, int degree, int n_points_1d>'
p38313
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_face('
p38314
aS'    const MatrixFree<dim, Number> &,'
p38315
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p38316
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p38317
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p38318
aS'  {'
p38319
aS'    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi_m(data,'
p38320
aS'                                                                      true);'
p38321
aS'    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi_p(data,'
p38322
aS'                                                                      false);'
p38323
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p38324
aS'      {'
p38325
aS'        phi_p.reinit(face);'
p38326
aS'        phi_p.gather_evaluate(src, EvaluationFlags::values);'
p38327
aS'        phi_m.reinit(face);'
p38328
aS'        phi_m.gather_evaluate(src, EvaluationFlags::values);'
p38329
aS'        for (unsigned int q = 0; q < phi_m.n_q_points; ++q)'
p38330
aS'          {'
p38331
aS'            const auto numerical_flux ='
p38332
aS'              euler_numerical_flux<dim>(phi_m.get_value(q),'
p38333
aS'                                        phi_p.get_value(q),'
p38334
aS'                                        phi_m.get_normal_vector(q));'
p38335
aS'            phi_m.submit_value(-numerical_flux, q);'
p38336
aS'            phi_p.submit_value(numerical_flux, q);'
p38337
aS'          }'
p38338
aS'        phi_p.integrate_scatter(EvaluationFlags::values, dst);'
p38339
aS'        phi_m.integrate_scatter(EvaluationFlags::values, dst);'
p38340
aS'      }'
p38341
aS'  }'
p38342
aS'  template <int dim, int degree, int n_points_1d>'
p38343
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_boundary_face('
p38344
aS'    const MatrixFree<dim, Number> &,'
p38345
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p38346
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p38347
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p38348
aS'  {'
p38349
aS'    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data, true);'
p38350
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p38351
aS'      {'
p38352
aS'        phi.reinit(face);'
p38353
aS'        phi.gather_evaluate(src, EvaluationFlags::values);'
p38354
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p38355
aS'          {'
p38356
aS'            const auto w_m    = phi.get_value(q);'
p38357
aS'            const auto normal = phi.get_normal_vector(q);'
p38358
aS'            auto rho_u_dot_n = w_m[1] * normal[0];'
p38359
aS'            for (unsigned int d = 1; d < dim; ++d)'
p38360
aS'              rho_u_dot_n += w_m[1 + d] * normal[d];'
p38361
aS'            bool at_outflow = false;'
p38362
aS'            Tensor<1, dim + 2, VectorizedArray<Number>> w_p;'
p38363
aS'            const auto boundary_id = data.get_boundary_id(face);'
p38364
aS'            if (wall_boundaries.find(boundary_id) != wall_boundaries.end())'
p38365
aS'              {'
p38366
aS'                w_p[0] = w_m[0];'
p38367
aS'                for (unsigned int d = 0; d < dim; ++d)'
p38368
aS'                  w_p[d + 1] = w_m[d + 1] - 2. * rho_u_dot_n * normal[d];'
p38369
aS'                w_p[dim + 1] = w_m[dim + 1];'
p38370
aS'              }'
p38371
aS'            else if (inflow_boundaries.find(boundary_id) !='
p38372
aS'                     inflow_boundaries.end())'
p38373
aS'              w_p ='
p38374
aS'                evaluate_function(*inflow_boundaries.find(boundary_id)->second,'
p38375
aS'                                  phi.quadrature_point(q));'
p38376
aS'            else if (subsonic_outflow_boundaries.find(boundary_id) !='
p38377
aS'                     subsonic_outflow_boundaries.end())'
p38378
aS'              {'
p38379
aS'                w_p          = w_m;'
p38380
aS'                w_p[dim + 1] = evaluate_function('
p38381
aS'                  *subsonic_outflow_boundaries.find(boundary_id)->second,'
p38382
aS'                  phi.quadrature_point(q),'
p38383
aS'                  dim + 1);'
p38384
aS'                at_outflow = true;'
p38385
aS'              }'
p38386
aS'            else'
p38387
aS'              AssertThrow(false,'
p38388
aS'                          ExcMessage("Unknown boundary id, did "'
p38389
aS'                                     "you set a boundary condition for "'
p38390
aS'                                     "this part of the domain boundary?"));'
p38391
aS'            auto flux = euler_numerical_flux<dim>(w_m, w_p, normal);'
p38392
aS'            if (at_outflow)'
p38393
aS'              for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v)'
p38394
aS'                {'
p38395
aS'                  if (rho_u_dot_n[v] < -1e-12)'
p38396
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p38397
aS'                      flux[d + 1][v] = 0.;'
p38398
aS'                }'
p38399
aS'            phi.submit_value(-flux, q);'
p38400
aS'          }'
p38401
aS'        phi.integrate_scatter(EvaluationFlags::values, dst);'
p38402
aS'      }'
p38403
aS'  }'
p38404
aS'  template <int dim, int degree, int n_points_1d>'
p38405
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_inverse_mass_matrix('
p38406
aS'    const MatrixFree<dim, Number> &,'
p38407
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p38408
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p38409
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p38410
aS'  {'
p38411
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1);'
p38412
aS'    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, degree, dim + 2, Number>'
p38413
aS'      inverse(phi);'
p38414
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p38415
aS'      {'
p38416
aS'        phi.reinit(cell);'
p38417
aS'        phi.read_dof_values(src);'
p38418
aS'        inverse.apply(phi.begin_dof_values(), phi.begin_dof_values());'
p38419
aS'        phi.set_dof_values(dst);'
p38420
aS'      }'
p38421
aS'  }'
p38422
aS'  template <int dim, int degree, int n_points_1d>'
p38423
aS'  void EulerOperator<dim, degree, n_points_1d>::apply('
p38424
aS'    const double                                      current_time,'
p38425
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p38426
aS'    LinearAlgebra::distributed::Vector<Number> &      dst) const'
p38427
aS'  {'
p38428
aS'    {'
p38429
aS'      TimerOutput::Scope t(timer, "apply - integrals");'
p38430
aS'      for (auto &i : inflow_boundaries)'
p38431
aS'        i.second->set_time(current_time);'
p38432
aS'      for (auto &i : subsonic_outflow_boundaries)'
p38433
aS'        i.second->set_time(current_time);'
p38434
aS'      data.loop(&EulerOperator::local_apply_cell,'
p38435
aS'                &EulerOperator::local_apply_face,'
p38436
aS'                &EulerOperator::local_apply_boundary_face,'
p38437
aS'                this,'
p38438
aS'                dst,'
p38439
aS'                src,'
p38440
aS'                true,'
p38441
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values,'
p38442
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values);'
p38443
aS'    }'
p38444
aS'    {'
p38445
aS'      TimerOutput::Scope t(timer, "apply - inverse mass");'
p38446
aS'      data.cell_loop(&EulerOperator::local_apply_inverse_mass_matrix,'
p38447
aS'                     this,'
p38448
aS'                     dst,'
p38449
aS'                     dst);'
p38450
aS'    }'
p38451
aS'  }'
p38452
aS'  template <int dim, int degree, int n_points_1d>'
p38453
aS'  void EulerOperator<dim, degree, n_points_1d>::perform_stage('
p38454
aS'    const Number                                      current_time,'
p38455
aS'    const Number                                      factor_solution,'
p38456
aS'    const Number                                      factor_ai,'
p38457
aS'    const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p38458
aS'    LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p38459
aS'    LinearAlgebra::distributed::Vector<Number> &      solution,'
p38460
aS'    LinearAlgebra::distributed::Vector<Number> &      next_ri) const'
p38461
aS'  {'
p38462
aS'    {'
p38463
aS'      TimerOutput::Scope t(timer, "rk_stage - integrals L_h");'
p38464
aS'      for (auto &i : inflow_boundaries)'
p38465
aS'        i.second->set_time(current_time);'
p38466
aS'      for (auto &i : subsonic_outflow_boundaries)'
p38467
aS'        i.second->set_time(current_time);'
p38468
aS'      data.loop(&EulerOperator::local_apply_cell,'
p38469
aS'                &EulerOperator::local_apply_face,'
p38470
aS'                &EulerOperator::local_apply_boundary_face,'
p38471
aS'                this,'
p38472
aS'                vec_ki,'
p38473
aS'                current_ri,'
p38474
aS'                true,'
p38475
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values,'
p38476
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values);'
p38477
aS'    }'
p38478
aS'    {'
p38479
aS'      TimerOutput::Scope t(timer, "rk_stage - inv mass + vec upd");'
p38480
aS'      data.cell_loop('
p38481
aS'        &EulerOperator::local_apply_inverse_mass_matrix,'
p38482
aS'        this,'
p38483
aS'        next_ri,'
p38484
aS'        vec_ki,'
p38485
aS'        std::function<void(const unsigned int, const unsigned int)>(),'
p38486
aS'        [&](const unsigned int start_range, const unsigned int end_range) {'
p38487
aS'          const Number ai = factor_ai;'
p38488
aS'          const Number bi = factor_solution;'
p38489
aS'          if (ai == Number())'
p38490
aS'            {'
p38491
aS'              for (unsigned int i = start_range; i < end_range; ++i)'
p38492
aS'                {'
p38493
aS'                  const Number k_i          = next_ri.local_element(i);'
p38494
aS'                  const Number sol_i        = solution.local_element(i);'
p38495
aS'                  solution.local_element(i) = sol_i + bi * k_i;'
p38496
aS'                }'
p38497
aS'            }'
p38498
aS'          else'
p38499
aS'            {'
p38500
aS'              for (unsigned int i = start_range; i < end_range; ++i)'
p38501
aS'                {'
p38502
aS'                  const Number k_i          = next_ri.local_element(i);'
p38503
aS'                  const Number sol_i        = solution.local_element(i);'
p38504
aS'                  solution.local_element(i) = sol_i + bi * k_i;'
p38505
aS'                  next_ri.local_element(i)  = sol_i + ai * k_i;'
p38506
aS'                }'
p38507
aS'            }'
p38508
aS'        });'
p38509
aS'    }'
p38510
aS'  }'
p38511
aS'  template <int dim, int degree, int n_points_1d>'
p38512
aS'  void EulerOperator<dim, degree, n_points_1d>::project('
p38513
aS'    const Function<dim> &                       function,'
p38514
aS'    LinearAlgebra::distributed::Vector<Number> &solution) const'
p38515
aS'  {'
p38516
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1);'
p38517
aS'    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, degree, dim + 2, Number>'
p38518
aS'      inverse(phi);'
p38519
aS'    solution.zero_out_ghost_values();'
p38520
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p38521
aS'      {'
p38522
aS'        phi.reinit(cell);'
p38523
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p38524
aS'          phi.submit_dof_value(evaluate_function(function,'
p38525
aS'                                                 phi.quadrature_point(q)),'
p38526
aS'                               q);'
p38527
aS'        inverse.transform_from_q_points_to_basis(dim + 2,'
p38528
aS'                                                 phi.begin_dof_values(),'
p38529
aS'                                                 phi.begin_dof_values());'
p38530
aS'        phi.set_dof_values(solution);'
p38531
aS'      }'
p38532
aS'  }'
p38533
aS'  template <int dim, int degree, int n_points_1d>'
p38534
aS'  std::array<double, 3> EulerOperator<dim, degree, n_points_1d>::compute_errors('
p38535
aS'    const Function<dim> &                             function,'
p38536
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p38537
aS'  {'
p38538
aS'    TimerOutput::Scope t(timer, "compute errors");'
p38539
aS'    double             errors_squared[3] = {};'
p38540
aS'    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data, 0, 0);'
p38541
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p38542
aS'      {'
p38543
aS'        phi.reinit(cell);'
p38544
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p38545
aS'        VectorizedArray<Number> local_errors_squared[3] = {};'
p38546
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p38547
aS'          {'
p38548
aS'            const auto error ='
p38549
aS'              evaluate_function(function, phi.quadrature_point(q)) -'
p38550
aS'              phi.get_value(q);'
p38551
aS'            const auto JxW = phi.JxW(q);'
p38552
aS'            local_errors_squared[0] += error[0] * error[0] * JxW;'
p38553
aS'            for (unsigned int d = 0; d < dim; ++d)'
p38554
aS'              local_errors_squared[1] += (error[d + 1] * error[d + 1]) * JxW;'
p38555
aS'            local_errors_squared[2] += (error[dim + 1] * error[dim + 1]) * JxW;'
p38556
aS'          }'
p38557
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p38558
aS'             ++v)'
p38559
aS'          for (unsigned int d = 0; d < 3; ++d)'
p38560
aS'            errors_squared[d] += local_errors_squared[d][v];'
p38561
aS'      }'
p38562
aS'    Utilities::MPI::sum(errors_squared, MPI_COMM_WORLD, errors_squared);'
p38563
aS'    std::array<double, 3> errors;'
p38564
aS'    for (unsigned int d = 0; d < 3; ++d)'
p38565
aS'      errors[d] = std::sqrt(errors_squared[d]);'
p38566
aS'    return errors;'
p38567
aS'  }'
p38568
aS'  template <int dim, int degree, int n_points_1d>'
p38569
aS'  double EulerOperator<dim, degree, n_points_1d>::compute_cell_transport_speed('
p38570
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p38571
aS'  {'
p38572
aS'    TimerOutput::Scope t(timer, "compute transport speed");'
p38573
aS'    Number             max_transport = 0;'
p38574
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1);'
p38575
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p38576
aS'      {'
p38577
aS'        phi.reinit(cell);'
p38578
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p38579
aS'        VectorizedArray<Number> local_max = 0.;'
p38580
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p38581
aS'          {'
p38582
aS'            const auto solution = phi.get_value(q);'
p38583
aS'            const auto velocity = euler_velocity<dim>(solution);'
p38584
aS'            const auto pressure = euler_pressure<dim>(solution);'
p38585
aS'            const auto inverse_jacobian = phi.inverse_jacobian(q);'
p38586
aS'            const auto convective_speed = inverse_jacobian * velocity;'
p38587
aS'            VectorizedArray<Number> convective_limit = 0.;'
p38588
aS'            for (unsigned int d = 0; d < dim; ++d)'
p38589
aS'              convective_limit ='
p38590
aS'                std::max(convective_limit, std::abs(convective_speed[d]));'
p38591
aS'            const auto speed_of_sound ='
p38592
aS'              std::sqrt(gamma * pressure * (1. / solution[0]));'
p38593
aS'            Tensor<1, dim, VectorizedArray<Number>> eigenvector;'
p38594
aS'            for (unsigned int d = 0; d < dim; ++d)'
p38595
aS'              eigenvector[d] = 1.;'
p38596
aS'            for (unsigned int i = 0; i < 5; ++i)'
p38597
aS'              {'
p38598
aS'                eigenvector = transpose(inverse_jacobian) *'
p38599
aS'                              (inverse_jacobian * eigenvector);'
p38600
aS'                VectorizedArray<Number> eigenvector_norm = 0.;'
p38601
aS'                for (unsigned int d = 0; d < dim; ++d)'
p38602
aS'                  eigenvector_norm ='
p38603
aS'                    std::max(eigenvector_norm, std::abs(eigenvector[d]));'
p38604
aS'                eigenvector /= eigenvector_norm;'
p38605
aS'              }'
p38606
aS'            const auto jac_times_ev   = inverse_jacobian * eigenvector;'
p38607
aS'            const auto max_eigenvalue = std::sqrt('
p38608
aS'              (jac_times_ev * jac_times_ev) / (eigenvector * eigenvector));'
p38609
aS'            local_max ='
p38610
aS'              std::max(local_max,'
p38611
aS'                       max_eigenvalue * speed_of_sound + convective_limit);'
p38612
aS'          }'
p38613
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p38614
aS'             ++v)'
p38615
aS'          for (unsigned int d = 0; d < 3; ++d)'
p38616
aS'            max_transport = std::max(max_transport, local_max[v]);'
p38617
aS'      }'
p38618
aS'    max_transport = Utilities::MPI::max(max_transport, MPI_COMM_WORLD);'
p38619
aS'    return max_transport;'
p38620
aS'  }'
p38621
aS'  template <int dim>'
p38622
aS'  class EulerProblem'
p38623
aS'  {'
p38624
aS'  public:'
p38625
aS'    EulerProblem();'
p38626
aS'    void run();'
p38627
aS'  private:'
p38628
aS'    void make_grid_and_dofs();'
p38629
aS'    void output_results(const unsigned int result_number);'
p38630
aS'    LinearAlgebra::distributed::Vector<Number> solution;'
p38631
aS'    ConditionalOStream pcout;'
p38632
aS'#ifdef DEAL_II_WITH_P4EST'
p38633
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p38634
aS'#else'
p38635
aS'    Triangulation<dim> triangulation;'
p38636
aS'#endif'
p38637
aS'    FESystem<dim>        fe;'
p38638
aS'    MappingQGeneric<dim> mapping;'
p38639
aS'    DoFHandler<dim>      dof_handler;'
p38640
aS'    TimerOutput timer;'
p38641
aS'    EulerOperator<dim, fe_degree, n_q_points_1d> euler_operator;'
p38642
aS'    double time, time_step;'
p38643
aS'    class Postprocessor : public DataPostprocessor<dim>'
p38644
aS'    {'
p38645
aS'    public:'
p38646
aS'      Postprocessor();'
p38647
aS'      virtual void evaluate_vector_field('
p38648
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p38649
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p38650
aS'      virtual std::vector<std::string> get_names() const override;'
p38651
aS'      virtual std::vector<'
p38652
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p38653
aS'      get_data_component_interpretation() const override;'
p38654
aS'      virtual UpdateFlags get_needed_update_flags() const override;'
p38655
aS'    private:'
p38656
aS'      const bool do_schlieren_plot;'
p38657
aS'    };'
p38658
aS'  };'
p38659
aS'  template <int dim>'
p38660
aS'  EulerProblem<dim>::Postprocessor::Postprocessor()'
p38661
aS'    : do_schlieren_plot(dim == 2)'
p38662
aS'  {}'
p38663
aS'  template <int dim>'
p38664
aS'  void EulerProblem<dim>::Postprocessor::evaluate_vector_field('
p38665
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p38666
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p38667
aS'  {'
p38668
aS'    const unsigned int n_evaluation_points = inputs.solution_values.size();'
p38669
aS'    if (do_schlieren_plot == true)'
p38670
aS'      Assert(inputs.solution_gradients.size() == n_evaluation_points,'
p38671
aS'             ExcInternalError());'
p38672
aS'    Assert(computed_quantities.size() == n_evaluation_points,'
p38673
aS'           ExcInternalError());'
p38674
aS'    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError());'
p38675
aS'    Assert(computed_quantities[0].size() =='
p38676
aS'             dim + 2 + (do_schlieren_plot == true ? 1 : 0),'
p38677
aS'           ExcInternalError());'
p38678
aS'    for (unsigned int q = 0; q < n_evaluation_points; ++q)'
p38679
aS'      {'
p38680
aS'        Tensor<1, dim + 2> solution;'
p38681
aS'        for (unsigned int d = 0; d < dim + 2; ++d)'
p38682
aS'          solution[d] = inputs.solution_values[q](d);'
p38683
aS'        const double         density  = solution[0];'
p38684
aS'        const Tensor<1, dim> velocity = euler_velocity<dim>(solution);'
p38685
aS'        const double         pressure = euler_pressure<dim>(solution);'
p38686
aS'        for (unsigned int d = 0; d < dim; ++d)'
p38687
aS'          computed_quantities[q](d) = velocity[d];'
p38688
aS'        computed_quantities[q](dim)     = pressure;'
p38689
aS'        computed_quantities[q](dim + 1) = std::sqrt(gamma * pressure / density);'
p38690
aS'        if (do_schlieren_plot == true)'
p38691
aS'          computed_quantities[q](dim + 2) ='
p38692
aS'            inputs.solution_gradients[q][0] * inputs.solution_gradients[q][0];'
p38693
aS'      }'
p38694
aS'  }'
p38695
aS'  template <int dim>'
p38696
aS'  std::vector<std::string> EulerProblem<dim>::Postprocessor::get_names() const'
p38697
aS'  {'
p38698
aS'    std::vector<std::string> names;'
p38699
aS'    for (unsigned int d = 0; d < dim; ++d)'
p38700
aS'      names.emplace_back("velocity");'
p38701
aS'    names.emplace_back("pressure");'
p38702
aS'    names.emplace_back("speed_of_sound");'
p38703
aS'    if (do_schlieren_plot == true)'
p38704
aS'      names.emplace_back("schlieren_plot");'
p38705
aS'    return names;'
p38706
aS'  }'
p38707
aS'  template <int dim>'
p38708
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p38709
aS'  EulerProblem<dim>::Postprocessor::get_data_component_interpretation() const'
p38710
aS'  {'
p38711
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p38712
aS'      interpretation;'
p38713
aS'    for (unsigned int d = 0; d < dim; ++d)'
p38714
aS'      interpretation.push_back('
p38715
aS'        DataComponentInterpretation::component_is_part_of_vector);'
p38716
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p38717
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p38718
aS'    if (do_schlieren_plot == true)'
p38719
aS'      interpretation.push_back('
p38720
aS'        DataComponentInterpretation::component_is_scalar);'
p38721
aS'    return interpretation;'
p38722
aS'  }'
p38723
aS'  template <int dim>'
p38724
aS'  UpdateFlags EulerProblem<dim>::Postprocessor::get_needed_update_flags() const'
p38725
aS'  {'
p38726
aS'    if (do_schlieren_plot == true)'
p38727
aS'      return update_values | update_gradients;'
p38728
aS'    else'
p38729
aS'      return update_values;'
p38730
aS'  }'
p38731
aS'  template <int dim>'
p38732
aS'  EulerProblem<dim>::EulerProblem()'
p38733
aS'    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p38734
aS'#ifdef DEAL_II_WITH_P4EST'
p38735
aS'    , triangulation(MPI_COMM_WORLD)'
p38736
aS'#endif'
p38737
aS'    , fe(FE_DGQ<dim>(fe_degree), dim + 2)'
p38738
aS'    , mapping(fe_degree)'
p38739
aS'    , dof_handler(triangulation)'
p38740
aS'    , timer(pcout, TimerOutput::never, TimerOutput::wall_times)'
p38741
aS'    , euler_operator(timer)'
p38742
aS'    , time(0)'
p38743
aS'    , time_step(0)'
p38744
aS'  {}'
p38745
aS'  template <int dim>'
p38746
aS'  void EulerProblem<dim>::make_grid_and_dofs()'
p38747
aS'  {'
p38748
aS'    switch (testcase)'
p38749
aS'      {'
p38750
aS'        case 0:'
p38751
aS'          {'
p38752
aS'            Point<dim> lower_left;'
p38753
aS'            for (unsigned int d = 1; d < dim; ++d)'
p38754
aS'              lower_left[d] = -5;'
p38755
aS'            Point<dim> upper_right;'
p38756
aS'            upper_right[0] = 10;'
p38757
aS'            for (unsigned int d = 1; d < dim; ++d)'
p38758
aS'              upper_right[d] = 5;'
p38759
aS'            GridGenerator::hyper_rectangle(triangulation,'
p38760
aS'                                           lower_left,'
p38761
aS'                                           upper_right);'
p38762
aS'            triangulation.refine_global(2);'
p38763
aS'            euler_operator.set_inflow_boundary('
p38764
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p38765
aS'            break;'
p38766
aS'          }'
p38767
aS'        case 1:'
p38768
aS'          {'
p38769
aS'            GridGenerator::channel_with_cylinder('
p38770
aS'              triangulation, 0.03, 1, 0, true);'
p38771
aS'            euler_operator.set_inflow_boundary('
p38772
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p38773
aS'            euler_operator.set_subsonic_outflow_boundary('
p38774
aS'              1, std::make_unique<ExactSolution<dim>>(0));'
p38775
aS'            euler_operator.set_wall_boundary(2);'
p38776
aS'            euler_operator.set_wall_boundary(3);'
p38777
aS'            if (dim == 3)'
p38778
aS'              euler_operator.set_body_force('
p38779
aS'                std::make_unique<Functions::ConstantFunction<dim>>('
p38780
aS'                  std::vector<double>({0., 0., -0.2})));'
p38781
aS'            break;'
p38782
aS'          }'
p38783
aS'        default:'
p38784
aS'          Assert(false, ExcNotImplemented());'
p38785
aS'      }'
p38786
aS'    triangulation.refine_global(n_global_refinements);'
p38787
aS'    dof_handler.distribute_dofs(fe);'
p38788
aS'    euler_operator.reinit(mapping, dof_handler);'
p38789
aS'    euler_operator.initialize_vector(solution);'
p38790
aS'    std::locale s = pcout.get_stream().getloc();'
p38791
aS'    pcout.get_stream().imbue(std::locale(""));'
p38792
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p38793
aS'          << " ( = " << (dim + 2) << " [vars] x "'
p38794
aS'          << triangulation.n_global_active_cells() << " [cells] x "'
p38795
aS'          << Utilities::pow(fe_degree + 1, dim) << " [dofs/cell/var] )"'
p38796
aS'          << std::endl;'
p38797
aS'    pcout.get_stream().imbue(s);'
p38798
aS'  }'
p38799
aS'  template <int dim>'
p38800
aS'  void EulerProblem<dim>::output_results(const unsigned int result_number)'
p38801
aS'  {'
p38802
aS'    const std::array<double, 3> errors ='
p38803
aS'      euler_operator.compute_errors(ExactSolution<dim>(time), solution);'
p38804
aS'    const std::string quantity_name = testcase == 0 ? "error" : "norm";'
p38805
aS'    pcout << "Time:" << std::setw(8) << std::setprecision(3) << time'
p38806
aS'          << ", dt: " << std::setw(8) << std::setprecision(2) << time_step'
p38807
aS'          << ", " << quantity_name << " rho: " << std::setprecision(4)'
p38808
aS'          << std::setw(10) << errors[0] << ", rho * u: " << std::setprecision(4)'
p38809
aS'          << std::setw(10) << errors[1] << ", energy:" << std::setprecision(4)'
p38810
aS'          << std::setw(10) << errors[2] << std::endl;'
p38811
aS'    {'
p38812
aS'      TimerOutput::Scope t(timer, "output");'
p38813
aS'      Postprocessor postprocessor;'
p38814
aS'      DataOut<dim>  data_out;'
p38815
aS'      DataOutBase::VtkFlags flags;'
p38816
aS'      flags.write_higher_order_cells = true;'
p38817
aS'      data_out.set_flags(flags);'
p38818
aS'      data_out.attach_dof_handler(dof_handler);'
p38819
aS'      {'
p38820
aS'        std::vector<std::string> names;'
p38821
aS'        names.emplace_back("density");'
p38822
aS'        for (unsigned int d = 0; d < dim; ++d)'
p38823
aS'          names.emplace_back("momentum");'
p38824
aS'        names.emplace_back("energy");'
p38825
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p38826
aS'          interpretation;'
p38827
aS'        interpretation.push_back('
p38828
aS'          DataComponentInterpretation::component_is_scalar);'
p38829
aS'        for (unsigned int d = 0; d < dim; ++d)'
p38830
aS'          interpretation.push_back('
p38831
aS'            DataComponentInterpretation::component_is_part_of_vector);'
p38832
aS'        interpretation.push_back('
p38833
aS'          DataComponentInterpretation::component_is_scalar);'
p38834
aS'        data_out.add_data_vector(dof_handler, solution, names, interpretation);'
p38835
aS'      }'
p38836
aS'      data_out.add_data_vector(solution, postprocessor);'
p38837
aS'      LinearAlgebra::distributed::Vector<Number> reference;'
p38838
aS'      if (testcase == 0 && dim == 2)'
p38839
aS'        {'
p38840
aS'          reference.reinit(solution);'
p38841
aS'          euler_operator.project(ExactSolution<dim>(time), reference);'
p38842
aS'          reference.sadd(-1., 1, solution);'
p38843
aS'          std::vector<std::string> names;'
p38844
aS'          names.emplace_back("error_density");'
p38845
aS'          for (unsigned int d = 0; d < dim; ++d)'
p38846
aS'            names.emplace_back("error_momentum");'
p38847
aS'          names.emplace_back("error_energy");'
p38848
aS'          std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p38849
aS'            interpretation;'
p38850
aS'          interpretation.push_back('
p38851
aS'            DataComponentInterpretation::component_is_scalar);'
p38852
aS'          for (unsigned int d = 0; d < dim; ++d)'
p38853
aS'            interpretation.push_back('
p38854
aS'              DataComponentInterpretation::component_is_part_of_vector);'
p38855
aS'          interpretation.push_back('
p38856
aS'            DataComponentInterpretation::component_is_scalar);'
p38857
aS'          data_out.add_data_vector(dof_handler,'
p38858
aS'                                   reference,'
p38859
aS'                                   names,'
p38860
aS'                                   interpretation);'
p38861
aS'        }'
p38862
aS'      Vector<double> mpi_owner(triangulation.n_active_cells());'
p38863
aS'      mpi_owner = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);'
p38864
aS'      data_out.add_data_vector(mpi_owner, "owner");'
p38865
aS'      data_out.build_patches(mapping,'
p38866
aS'                             fe.degree,'
p38867
aS'                             DataOut<dim>::curved_inner_cells);'
p38868
aS'      const std::string filename ='
p38869
aS'        "solution_" + Utilities::int_to_string(result_number, 3) + ".vtu";'
p38870
aS'      data_out.write_vtu_in_parallel(filename, MPI_COMM_WORLD);'
p38871
aS'    }'
p38872
aS'  }'
p38873
aS'  template <int dim>'
p38874
aS'  void EulerProblem<dim>::run()'
p38875
aS'  {'
p38876
aS'    {'
p38877
aS'      const unsigned int n_vect_number = VectorizedArray<Number>::size();'
p38878
aS'      const unsigned int n_vect_bits   = 8 * sizeof(Number) * n_vect_number;'
p38879
aS'      pcout << "Running with "'
p38880
aS'            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD)'
p38881
aS'            << " MPI processes" << std::endl;'
p38882
aS'      pcout << "Vectorization over " << n_vect_number << " "'
p38883
aS'            << (std::is_same<Number, double>::value ? "doubles" : "floats")'
p38884
aS'            << " = " << n_vect_bits << " bits ("'
p38885
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p38886
aS'            << std::endl;'
p38887
aS'    }'
p38888
aS'    make_grid_and_dofs();'
p38889
aS'    const LowStorageRungeKuttaIntegrator integrator(lsrk_scheme);'
p38890
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_1;'
p38891
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_2;'
p38892
aS'    rk_register_1.reinit(solution);'
p38893
aS'    rk_register_2.reinit(solution);'
p38894
aS'    euler_operator.project(ExactSolution<dim>(time), solution);'
p38895
aS'    double min_vertex_distance = std::numeric_limits<double>::max();'
p38896
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p38897
aS'      if (cell->is_locally_owned())'
p38898
aS'        min_vertex_distance ='
p38899
aS'          std::min(min_vertex_distance, cell->minimum_vertex_distance());'
p38900
aS'    min_vertex_distance ='
p38901
aS'      Utilities::MPI::min(min_vertex_distance, MPI_COMM_WORLD);'
p38902
aS'    time_step = courant_number * integrator.n_stages() /'
p38903
aS'                euler_operator.compute_cell_transport_speed(solution);'
p38904
aS'    pcout << "Time step size: " << time_step'
p38905
aS'          << ", minimal h: " << min_vertex_distance'
p38906
aS'          << ", initial transport scaling: "'
p38907
aS'          << 1. / euler_operator.compute_cell_transport_speed(solution)'
p38908
aS'          << std::endl'
p38909
aS'          << std::endl;'
p38910
aS'    output_results(0);'
p38911
aS'    unsigned int timestep_number = 0;'
p38912
aS'    while (time < final_time - 1e-12)'
p38913
aS'      {'
p38914
aS'        ++timestep_number;'
p38915
aS'        if (timestep_number % 5 == 0)'
p38916
aS'          time_step ='
p38917
aS'            courant_number * integrator.n_stages() /'
p38918
aS'            Utilities::truncate_to_n_digits('
p38919
aS'              euler_operator.compute_cell_transport_speed(solution), 3);'
p38920
aS'        {'
p38921
aS'          TimerOutput::Scope t(timer, "rk time stepping total");'
p38922
aS'          integrator.perform_time_step(euler_operator,'
p38923
aS'                                       time,'
p38924
aS'                                       time_step,'
p38925
aS'                                       solution,'
p38926
aS'                                       rk_register_1,'
p38927
aS'                                       rk_register_2);'
p38928
aS'        }'
p38929
aS'        time += time_step;'
p38930
aS'        if (static_cast<int>(time / output_tick) !='
p38931
aS'              static_cast<int>((time - time_step) / output_tick) ||'
p38932
aS'            time >= final_time - 1e-12)'
p38933
aS'          output_results('
p38934
aS'            static_cast<unsigned int>(std::round(time / output_tick)));'
p38935
aS'      }'
p38936
aS'    timer.print_wall_time_statistics(MPI_COMM_WORLD);'
p38937
aS'    pcout << std::endl;'
p38938
aS'  }'
p38939
aS'} // namespace Euler_DG'
p38940
aS'int main(int argc, char **argv)'
p38941
ag24
aS'  using namespace Euler_DG;'
p38942
aS'  using namespace dealii;'
p38943
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p38944
aS'  try'
p38945
aS'    {'
p38946
aS'      deallog.depth_console(0);'
p38947
aS'      EulerProblem<dimension> euler_problem;'
p38948
aS'      euler_problem.run();'
p38949
aS'    }'
p38950
aS'  catch (std::exception &exc)'
p38951
aS'    {'
p38952
aS'      std::cerr << std::endl'
p38953
aS'                << std::endl'
p38954
aS'                << "----------------------------------------------------"'
p38955
aS'                << std::endl;'
p38956
aS'      std::cerr << "Exception on processing: " << std::endl'
p38957
aS'                << exc.what() << std::endl'
p38958
aS'                << "Aborting!" << std::endl'
p38959
aS'                << "----------------------------------------------------"'
p38960
aS'                << std::endl;'
p38961
aS'      return 1;'
p38962
aS'    }'
p38963
aS'  catch (...)'
p38964
aS'    {'
p38965
aS'      std::cerr << std::endl'
p38966
aS'                << std::endl'
p38967
aS'                << "----------------------------------------------------"'
p38968
aS'                << std::endl;'
p38969
aS'      std::cerr << "Unknown exception!" << std::endl'
p38970
aS'                << "Aborting!" << std::endl'
p38971
aS'                << "----------------------------------------------------"'
p38972
aS'                << std::endl;'
p38973
aS'      return 1;'
p38974
aS'    }'
p38975
aS'  return 0;'
p38976
ag32
aS'/* ---------------------------------------------------------------------'
p38977
aS' *'
p38978
aS' * Copyright (C) 2020 - 2021 by the deal.II authors'
p38979
aS' *'
p38980
aS' * This file is part of the deal.II library.'
p38981
aS' *'
p38982
aS' * The deal.II library is free software; you can use it, redistribute'
p38983
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p38984
aS' * Public License as published by the Free Software Foundation; either'
p38985
aS' * version 2.1 of the License, or (at your option) any later version.'
p38986
aS' * The full text of the license can be found in the file LICENSE.md at'
p38987
aS' * the top level directory of deal.II.'
p38988
aS' *'
p38989
aS' * ---------------------------------------------------------------------'
p38990
aS' *'
p38991
aS' * Authors: Bruno Blais, Toni El Geitani Nehme, Rene Gassmoeller, Peter Munch'
p38992
aS' */'
p38993
aS'#include <deal.II/base/bounding_box.h>'
p38994
aS'#include <deal.II/base/conditional_ostream.h>'
p38995
aS'#include <deal.II/base/discrete_time.h>'
p38996
aS'#include <deal.II/base/mpi.h>'
p38997
aS'#include <deal.II/base/parameter_acceptor.h>'
p38998
aS'#include <deal.II/base/timer.h>'
p38999
aS'#include <deal.II/distributed/cell_weights.h>'
p39000
aS'#include <deal.II/distributed/solution_transfer.h>'
p39001
aS'#include <deal.II/distributed/tria.h>'
p39002
aS'#include <deal.II/dofs/dof_handler.h>'
p39003
aS'#include <deal.II/dofs/dof_tools.h>'
p39004
aS'#include <deal.II/fe/fe_q.h>'
p39005
aS'#include <deal.II/fe/fe_system.h>'
p39006
aS'#include <deal.II/fe/mapping_q.h>'
p39007
aS'#include <deal.II/grid/grid_generator.h>'
p39008
aS'#include <deal.II/grid/grid_tools.h>'
p39009
aS'#include <deal.II/lac/la_parallel_vector.h>'
p39010
aS'#include <deal.II/lac/vector.h>'
p39011
aS'#include <deal.II/numerics/data_out.h>'
p39012
aS'#include <deal.II/numerics/vector_tools.h>'
p39013
aS'#include <deal.II/particles/particle_handler.h>'
p39014
aS'#include <deal.II/particles/generators.h>'
p39015
aS'#include <deal.II/particles/data_out.h>'
p39016
aS'#include <cmath>'
p39017
aS'#include <iostream>'
p39018
aS'namespace Step68'
p39019
ag24
aS'  using namespace dealii;'
p39020
aS'  class ParticleTrackingParameters : public ParameterAcceptor'
p39021
aS'  {'
p39022
aS'  public:'
p39023
aS'    ParticleTrackingParameters();'
p39024
aS'    std::string output_directory = "./";'
p39025
aS'    unsigned int velocity_degree       = 1;'
p39026
aS'    double       time_step             = 0.002;'
p39027
aS'    double       final_time            = 4.0;'
p39028
aS'    unsigned int output_frequency      = 10;'
p39029
aS'    unsigned int repartition_frequency = 5;'
p39030
aS'    unsigned int fluid_refinement              = 4;'
p39031
aS'    unsigned int particle_insertion_refinement = 3;'
p39032
aS'  };'
p39033
aS'  ParticleTrackingParameters::ParticleTrackingParameters()'
p39034
aS'    : ParameterAcceptor("Particle Tracking Problem/")'
p39035
aS'  {'
p39036
aS'    add_parameter('
p39037
aS'      "Velocity degree", velocity_degree, "", prm, Patterns::Integer(1));'
p39038
aS'    add_parameter("Output frequency",'
p39039
aS'                  output_frequency,'
p39040
aS'                  "Iteration frequency at which output results are written",'
p39041
aS'                  prm,'
p39042
aS'                  Patterns::Integer(1));'
p39043
aS'    add_parameter("Repartition frequency",'
p39044
aS'                  repartition_frequency,'
p39045
aS'                  "Iteration frequency at which the mesh is load balanced",'
p39046
aS'                  prm,'
p39047
aS'                  Patterns::Integer(1));'
p39048
aS'    add_parameter("Output directory", output_directory);'
p39049
aS'    add_parameter("Time step", time_step, "", prm, Patterns::Double());'
p39050
aS'    add_parameter("Final time",'
p39051
aS'                  final_time,'
p39052
aS'                  "End time of the simulation",'
p39053
aS'                  prm,'
p39054
aS'                  Patterns::Double());'
p39055
aS'    add_parameter("Fluid refinement",'
p39056
aS'                  fluid_refinement,'
p39057
aS'                  "Refinement level of the fluid domain",'
p39058
aS'                  prm,'
p39059
aS'                  Patterns::Integer(0));'
p39060
aS'    add_parameter('
p39061
aS'      "Particle insertion refinement",'
p39062
aS'      particle_insertion_refinement,'
p39063
aS'      "Refinement of the volumetric mesh used to insert the particles",'
p39064
aS'      prm,'
p39065
aS'      Patterns::Integer(0));'
p39066
aS'  }'
p39067
aS'  template <int dim>'
p39068
aS'  class Vortex : public Function<dim>'
p39069
aS'  {'
p39070
aS'  public:'
p39071
aS'    Vortex()'
p39072
aS'      : Function<dim>(dim)'
p39073
aS'    {}'
p39074
aS'    virtual void vector_value(const Point<dim> &point,'
p39075
aS'                              Vector<double> &  values) const override;'
p39076
aS'  };'
p39077
aS'  template <int dim>'
p39078
aS'  void Vortex<dim>::vector_value(const Point<dim> &point,'
p39079
aS'                                 Vector<double> &  values) const'
p39080
aS'  {'
p39081
aS'    const double T = 4;'
p39082
aS'    const double t = this->get_time();'
p39083
aS'    const double px = numbers::PI * point(0);'
p39084
aS'    const double py = numbers::PI * point(1);'
p39085
aS'    const double pt = numbers::PI / T * t;'
p39086
aS'    values[0] = -2 * cos(pt) * pow(sin(px), 2) * sin(py) * cos(py);'
p39087
aS'    values[1] = 2 * cos(pt) * pow(sin(py), 2) * sin(px) * cos(px);'
p39088
aS'    if (dim == 3)'
p39089
aS'      {'
p39090
aS'        values[2] = 0;'
p39091
aS'      }'
p39092
aS'  }'
p39093
aS'  template <int dim>'
p39094
aS'  class ParticleTracking'
p39095
aS'  {'
p39096
aS'  public:'
p39097
aS'    ParticleTracking(const ParticleTrackingParameters &par,'
p39098
aS'                     const bool                        interpolated_velocity);'
p39099
aS'    void run();'
p39100
aS'  private:'
p39101
aS'    void generate_particles();'
p39102
aS'    void setup_background_dofs();'
p39103
aS'    void interpolate_function_to_field();'
p39104
aS'    void euler_step_interpolated(const double dt);'
p39105
aS'    void euler_step_analytical(const double dt);'
p39106
aS'    unsigned int cell_weight('
p39107
aS'      const typename parallel::distributed::Triangulation<dim>::cell_iterator'
p39108
aS'        &cell,'
p39109
aS'      const typename parallel::distributed::Triangulation<dim>::CellStatus'
p39110
aS'        status) const;'
p39111
aS'    void output_particles(const unsigned int it);'
p39112
aS'    void output_background(const unsigned int it);'
p39113
aS'    const ParticleTrackingParameters &par;'
p39114
aS'    MPI_Comm                                  mpi_communicator;'
p39115
aS'    parallel::distributed::Triangulation<dim> background_triangulation;'
p39116
aS'    Particles::ParticleHandler<dim>           particle_handler;'
p39117
aS'    DoFHandler<dim>                            fluid_dh;'
p39118
aS'    FESystem<dim>                              fluid_fe;'
p39119
aS'    MappingQ1<dim>                             mapping;'
p39120
aS'    LinearAlgebra::distributed::Vector<double> velocity_field;'
p39121
aS'    Vortex<dim> velocity;'
p39122
aS'    ConditionalOStream pcout;'
p39123
aS'    bool interpolated_velocity;'
p39124
aS'  };'
p39125
aS'  template <int dim>'
p39126
aS'  ParticleTracking<dim>::ParticleTracking(const ParticleTrackingParameters &par,'
p39127
aS'                                          const bool interpolated_velocity)'
p39128
aS'    : par(par)'
p39129
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p39130
aS'    , background_triangulation(mpi_communicator)'
p39131
aS'    , fluid_dh(background_triangulation)'
p39132
aS'    , fluid_fe(FE_Q<dim>(par.velocity_degree), dim)'
p39133
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p39134
aS'    , interpolated_velocity(interpolated_velocity)'
p39135
aS'  {}'
p39136
aS'  template <int dim>'
p39137
aS'  unsigned int ParticleTracking<dim>::cell_weight('
p39138
aS'    const typename parallel::distributed::Triangulation<dim>::cell_iterator'
p39139
aS'      &                                                                  cell,'
p39140
aS'    const typename parallel::distributed::Triangulation<dim>::CellStatus status)'
p39141
aS'    const'
p39142
aS'  {'
p39143
aS'    if (!cell->is_locally_owned())'
p39144
aS'      return 0;'
p39145
aS'    const unsigned int particle_weight = 10000;'
p39146
aS'    if (status == parallel::distributed::Triangulation<dim>::CELL_PERSIST ||'
p39147
aS'        status == parallel::distributed::Triangulation<dim>::CELL_REFINE)'
p39148
aS'      {'
p39149
aS'        const unsigned int n_particles_in_cell ='
p39150
aS'          particle_handler.n_particles_in_cell(cell);'
p39151
aS'        return n_particles_in_cell * particle_weight;'
p39152
aS'      }'
p39153
aS'    else if (status == parallel::distributed::Triangulation<dim>::CELL_COARSEN)'
p39154
aS'      {'
p39155
aS'        unsigned int n_particles_in_cell = 0;'
p39156
aS'        for (unsigned int child_index = 0; child_index < cell->n_children();'
p39157
aS'             ++child_index)'
p39158
aS'          n_particles_in_cell +='
p39159
aS'            particle_handler.n_particles_in_cell(cell->child(child_index));'
p39160
aS'        return n_particles_in_cell * particle_weight;'
p39161
aS'      }'
p39162
aS'    Assert(false, ExcInternalError());'
p39163
aS'    return 0;'
p39164
aS'  }'
p39165
aS'  template <int dim>'
p39166
aS'  void ParticleTracking<dim>::generate_particles()'
p39167
aS'  {'
p39168
aS'    GridGenerator::hyper_cube(background_triangulation, 0, 1);'
p39169
aS'    background_triangulation.refine_global(par.fluid_refinement);'
p39170
aS'    background_triangulation.signals.cell_weight.connect('
p39171
aS'      [&]('
p39172
aS'        const typename parallel::distributed::Triangulation<dim>::cell_iterator'
p39173
aS'          &cell,'
p39174
aS'        const typename parallel::distributed::Triangulation<dim>::CellStatus'
p39175
aS'          status) -> unsigned int { return this->cell_weight(cell, status); });'
p39176
aS'    background_triangulation.signals.pre_distributed_repartition.connect('
p39177
aS'      [this]() { this->particle_handler.register_store_callback_function(); });'
p39178
aS'    background_triangulation.signals.post_distributed_repartition.connect('
p39179
aS'      [&]() { this->particle_handler.register_load_callback_function(false); });'
p39180
aS'    particle_handler.initialize(background_triangulation, mapping, 1 + dim);'
p39181
aS'    Point<dim> center;'
p39182
aS'    center[0] = 0.5;'
p39183
aS'    center[1] = 0.75;'
p39184
aS'    if (dim == 3)'
p39185
aS'      center[2] = 0.5;'
p39186
aS'    const double outer_radius = 0.15;'
p39187
aS'    const double inner_radius = 0.01;'
p39188
aS'    parallel::distributed::Triangulation<dim> particle_triangulation('
p39189
aS'      MPI_COMM_WORLD);'
p39190
aS'    GridGenerator::hyper_shell('
p39191
aS'      particle_triangulation, center, inner_radius, outer_radius, 6);'
p39192
aS'    particle_triangulation.refine_global(par.particle_insertion_refinement);'
p39193
aS'    const auto my_bounding_box = GridTools::compute_mesh_predicate_bounding_box('
p39194
aS'      background_triangulation, IteratorFilters::LocallyOwnedCell());'
p39195
aS'    const auto global_bounding_boxes ='
p39196
aS'      Utilities::MPI::all_gather(MPI_COMM_WORLD, my_bounding_box);'
p39197
aS'    std::vector<std::vector<double>> properties('
p39198
aS'      particle_triangulation.n_locally_owned_active_cells(),'
p39199
aS'      std::vector<double>(dim + 1, 0.));'
p39200
aS'    Particles::Generators::quadrature_points(particle_triangulation,'
p39201
aS'                                             QMidpoint<dim>(),'
p39202
aS'                                             global_bounding_boxes,'
p39203
aS'                                             particle_handler,'
p39204
aS'                                             mapping,'
p39205
aS'                                             properties);'
p39206
aS'    pcout << "Number of particles inserted: "'
p39207
aS'          << particle_handler.n_global_particles() << std::endl;'
p39208
aS'  }'
p39209
aS'  template <int dim>'
p39210
aS'  void ParticleTracking<dim>::setup_background_dofs()'
p39211
aS'  {'
p39212
aS'    fluid_dh.distribute_dofs(fluid_fe);'
p39213
aS'    const IndexSet locally_owned_dofs = fluid_dh.locally_owned_dofs();'
p39214
aS'    IndexSet       locally_relevant_dofs;'
p39215
aS'    DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs);'
p39216
aS'    velocity_field.reinit(locally_owned_dofs,'
p39217
aS'                          locally_relevant_dofs,'
p39218
aS'                          mpi_communicator);'
p39219
aS'  }'
p39220
aS'  template <int dim>'
p39221
aS'  void ParticleTracking<dim>::interpolate_function_to_field()'
p39222
aS'  {'
p39223
aS'    velocity_field.zero_out_ghost_values();'
p39224
aS'    VectorTools::interpolate(mapping, fluid_dh, velocity, velocity_field);'
p39225
aS'    velocity_field.update_ghost_values();'
p39226
aS'  }'
p39227
aS'  template <int dim>'
p39228
aS'  void ParticleTracking<dim>::euler_step_analytical(const double dt)'
p39229
aS'  {'
p39230
aS'    const unsigned int this_mpi_rank ='
p39231
aS'      Utilities::MPI::this_mpi_process(mpi_communicator);'
p39232
aS'    Vector<double> particle_velocity(dim);'
p39233
aS'    for (auto &particle : particle_handler)'
p39234
aS'      {'
p39235
aS'        Point<dim> particle_location = particle.get_location();'
p39236
aS'        velocity.vector_value(particle_location, particle_velocity);'
p39237
aS'        for (int d = 0; d < dim; ++d)'
p39238
aS'          particle_location[d] += particle_velocity[d] * dt;'
p39239
aS'        particle.set_location(particle_location);'
p39240
aS'        ArrayView<double> properties = particle.get_properties();'
p39241
aS'        for (int d = 0; d < dim; ++d)'
p39242
aS'          properties[d] = particle_velocity[d];'
p39243
aS'        properties[dim] = this_mpi_rank;'
p39244
aS'      }'
p39245
aS'  }'
p39246
aS'  template <int dim>'
p39247
aS'  void ParticleTracking<dim>::euler_step_interpolated(const double dt)'
p39248
aS'  {'
p39249
aS'    Vector<double> local_dof_values(fluid_fe.dofs_per_cell);'
p39250
aS'    auto particle = particle_handler.begin();'
p39251
aS'    while (particle != particle_handler.end())'
p39252
aS'      {'
p39253
aS'        const auto cell ='
p39254
aS'          particle->get_surrounding_cell(background_triangulation);'
p39255
aS'        const auto dh_cell ='
p39256
aS'          typename DoFHandler<dim>::cell_iterator(*cell, &fluid_dh);'
p39257
aS'        dh_cell->get_dof_values(velocity_field, local_dof_values);'
p39258
aS'        const auto pic = particle_handler.particles_in_cell(cell);'
p39259
aS'        Assert(pic.begin() == particle, ExcInternalError());'
p39260
aS'        for (auto &p : pic)'
p39261
aS'          {'
p39262
aS'            const Point<dim> reference_location = p.get_reference_location();'
p39263
aS'            Tensor<1, dim>   particle_velocity;'
p39264
aS'            for (unsigned int j = 0; j < fluid_fe.dofs_per_cell; ++j)'
p39265
aS'              {'
p39266
aS'                const auto comp_j = fluid_fe.system_to_component_index(j);'
p39267
aS'                particle_velocity[comp_j.first] +='
p39268
aS'                  fluid_fe.shape_value(j, reference_location) *'
p39269
aS'                  local_dof_values[j];'
p39270
aS'              }'
p39271
aS'            Point<dim> particle_location = particle->get_location();'
p39272
aS'            for (int d = 0; d < dim; ++d)'
p39273
aS'              particle_location[d] += particle_velocity[d] * dt;'
p39274
aS'            p.set_location(particle_location);'
p39275
aS'            ArrayView<double> properties = p.get_properties();'
p39276
aS'            for (int d = 0; d < dim; ++d)'
p39277
aS'              properties[d] = particle_velocity[d];'
p39278
aS'            properties[dim] ='
p39279
aS'              Utilities::MPI::this_mpi_process(mpi_communicator);'
p39280
aS'            ++particle;'
p39281
aS'          }'
p39282
aS'      }'
p39283
aS'  }'
p39284
aS'  template <int dim>'
p39285
aS'  void ParticleTracking<dim>::output_particles(const unsigned int it)'
p39286
aS'  {'
p39287
aS'    Particles::DataOut<dim, dim> particle_output;'
p39288
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p39289
aS'    solution_names.push_back("process_id");'
p39290
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p39291
aS'      data_component_interpretation('
p39292
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p39293
aS'    data_component_interpretation.push_back('
p39294
aS'      DataComponentInterpretation::component_is_scalar);'
p39295
aS'    particle_output.build_patches(particle_handler,'
p39296
aS'                                  solution_names,'
p39297
aS'                                  data_component_interpretation);'
p39298
aS'    const std::string output_folder(par.output_directory);'
p39299
aS'    const std::string file_name(interpolated_velocity ?'
p39300
aS'                                  "interpolated-particles" :'
p39301
aS'                                  "analytical-particles");'
p39302
aS'    pcout << "Writing particle output file: " << file_name << "-" << it'
p39303
aS'          << std::endl;'
p39304
aS'    particle_output.write_vtu_with_pvtu_record('
p39305
aS'      output_folder, file_name, it, mpi_communicator, 6);'
p39306
aS'  }'
p39307
aS'  template <int dim>'
p39308
aS'  void ParticleTracking<dim>::output_background(const unsigned int it)'
p39309
aS'  {'
p39310
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p39311
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p39312
aS'      data_component_interpretation('
p39313
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p39314
aS'    DataOut<dim> data_out;'
p39315
aS'    data_out.attach_dof_handler(fluid_dh);'
p39316
aS'    data_out.add_data_vector(velocity_field,'
p39317
aS'                             solution_names,'
p39318
aS'                             DataOut<dim>::type_dof_data,'
p39319
aS'                             data_component_interpretation);'
p39320
aS'    Vector<float> subdomain(background_triangulation.n_active_cells());'
p39321
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p39322
aS'      subdomain(i) = background_triangulation.locally_owned_subdomain();'
p39323
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p39324
aS'    data_out.build_patches(mapping);'
p39325
aS'    const std::string output_folder(par.output_directory);'
p39326
aS'    const std::string file_name("background");'
p39327
aS'    pcout << "Writing background field file: " << file_name << "-" << it'
p39328
aS'          << std::endl;'
p39329
aS'    data_out.write_vtu_with_pvtu_record('
p39330
aS'      output_folder, file_name, it, mpi_communicator, 6);'
p39331
aS'  }'
p39332
aS'  template <int dim>'
p39333
aS'  void ParticleTracking<dim>::run()'
p39334
aS'  {'
p39335
aS'    DiscreteTime discrete_time(0, par.final_time, par.time_step);'
p39336
aS'    generate_particles();'
p39337
aS'    pcout << "Repartitioning triangulation after particle generation"'
p39338
aS'          << std::endl;'
p39339
aS'    background_triangulation.repartition();'
p39340
aS'    if (interpolated_velocity)'
p39341
aS'      {'
p39342
aS'        setup_background_dofs();'
p39343
aS'        interpolate_function_to_field();'
p39344
aS'        euler_step_interpolated(0.);'
p39345
aS'      }'
p39346
aS'    else'
p39347
aS'      euler_step_analytical(0.);'
p39348
aS'    output_particles(discrete_time.get_step_number());'
p39349
aS'    if (interpolated_velocity)'
p39350
aS'      output_background(discrete_time.get_step_number());'
p39351
aS'    while (!discrete_time.is_at_end())'
p39352
aS'      {'
p39353
aS'        discrete_time.advance_time();'
p39354
aS'        velocity.set_time(discrete_time.get_previous_time());'
p39355
aS'        if ((discrete_time.get_step_number() % par.repartition_frequency) == 0)'
p39356
aS'          {'
p39357
aS'            background_triangulation.repartition();'
p39358
aS'            if (interpolated_velocity)'
p39359
aS'              setup_background_dofs();'
p39360
aS'          }'
p39361
aS'        if (interpolated_velocity)'
p39362
aS'          {'
p39363
aS'            interpolate_function_to_field();'
p39364
aS'            euler_step_interpolated(discrete_time.get_previous_step_size());'
p39365
aS'          }'
p39366
aS'        else'
p39367
aS'          euler_step_analytical(discrete_time.get_previous_step_size());'
p39368
aS'        particle_handler.sort_particles_into_subdomains_and_cells();'
p39369
aS'        if ((discrete_time.get_step_number() % par.output_frequency) == 0)'
p39370
aS'          {'
p39371
aS'            output_particles(discrete_time.get_step_number());'
p39372
aS'            if (interpolated_velocity)'
p39373
aS'              output_background(discrete_time.get_step_number());'
p39374
aS'          }'
p39375
aS'      }'
p39376
aS'  }'
p39377
aS'} // namespace Step68'
p39378
aS'int main(int argc, char *argv[])'
p39379
ag24
aS'  using namespace Step68;'
p39380
aS'  using namespace dealii;'
p39381
aS'  deallog.depth_console(1);'
p39382
aS'  try'
p39383
aS'    {'
p39384
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p39385
aS'      std::string prm_file;'
p39386
aS'      if (argc > 1)'
p39387
aS'        prm_file = argv[1];'
p39388
aS'      else'
p39389
aS'        prm_file = "parameters.prm";'
p39390
aS'      ParticleTrackingParameters par;'
p39391
aS'      ParameterAcceptor::initialize(prm_file);'
p39392
aS'      {'
p39393
aS'        Step68::ParticleTracking<2> particle_tracking(par, false);'
p39394
aS'        particle_tracking.run();'
p39395
aS'      }'
p39396
aS'      {'
p39397
aS'        Step68::ParticleTracking<2> particle_tracking(par, true);'
p39398
aS'        particle_tracking.run();'
p39399
aS'      }'
p39400
aS'    }'
p39401
aS'  catch (std::exception &exc)'
p39402
aS'    {'
p39403
aS'      std::cerr << std::endl'
p39404
aS'                << std::endl'
p39405
aS'                << "----------------------------------------------------"'
p39406
aS'                << std::endl;'
p39407
aS'      std::cerr << "Exception on processing: " << std::endl'
p39408
aS'                << exc.what() << std::endl'
p39409
aS'                << "Aborting!" << std::endl'
p39410
aS'                << "----------------------------------------------------"'
p39411
aS'                << std::endl;'
p39412
aS'      return 1;'
p39413
aS'    }'
p39414
aS'  catch (...)'
p39415
aS'    {'
p39416
aS'      std::cerr << std::endl'
p39417
aS'                << std::endl'
p39418
aS'                << "----------------------------------------------------"'
p39419
aS'                << std::endl;'
p39420
aS'      std::cerr << "Unknown exception!" << std::endl'
p39421
aS'                << "Aborting!" << std::endl'
p39422
aS'                << "----------------------------------------------------"'
p39423
aS'                << std::endl;'
p39424
aS'      return 1;'
p39425
aS'    }'
p39426
aS'  return 0;'
p39427
ag32
aS'/* ---------------------------------------------------------------------'
p39428
aS' *'
p39429
aS' * Copyright (C) 2019 - 2021 by the deal.II authors'
p39430
aS' *'
p39431
aS' * This file is part of the deal.II library.'
p39432
aS' *'
p39433
aS' * The deal.II library is free software; you can use it, redistribute'
p39434
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p39435
aS' * Public License as published by the Free Software Foundation; either'
p39436
aS' * version 2.1 of the License, or (at your option) any later version.'
p39437
aS' * The full text of the license can be found in the file LICENSE.md at'
p39438
aS' * the top level directory of deal.II.'
p39439
aS' *'
p39440
aS' * ---------------------------------------------------------------------'
p39441
aS' *'
p39442
aS' * Authors: Matthias Maier, Texas A&M University;'
p39443
aS' *          Ignacio Tomas, Texas A&M University, Sandia National Laboratories'
p39444
aS' *'
p39445
aS' * Sandia National Laboratories is a multimission laboratory managed and'
p39446
aS' * operated by National Technology & Engineering Solutions of Sandia, LLC, a'
p39447
aS' * wholly owned subsidiary of Honeywell International Inc., for the U.S.'
p39448
aS" * Department of Energy's National Nuclear Security Administration under"
p39449
aS' * contract DE-NA0003525. This document describes objective technical results'
p39450
aS' * and analysis. Any subjective views or opinions that might be expressed in'
p39451
aS' * the paper do not necessarily represent the views of the U.S. Department of'
p39452
aS' * Energy or the United States Government.'
p39453
aS' */'
p39454
aS'#include <deal.II/base/conditional_ostream.h>'
p39455
aS'#include <deal.II/base/parallel.h>'
p39456
aS'#include <deal.II/base/parameter_acceptor.h>'
p39457
aS'#include <deal.II/base/partitioner.h>'
p39458
aS'#include <deal.II/base/quadrature.h>'
p39459
aS'#include <deal.II/base/timer.h>'
p39460
aS'#include <deal.II/base/work_stream.h>'
p39461
aS'#include <deal.II/distributed/tria.h>'
p39462
aS'#include <deal.II/dofs/dof_handler.h>'
p39463
aS'#include <deal.II/dofs/dof_renumbering.h>'
p39464
aS'#include <deal.II/dofs/dof_tools.h>'
p39465
aS'#include <deal.II/fe/fe.h>'
p39466
aS'#include <deal.II/fe/fe_q.h>'
p39467
aS'#include <deal.II/fe/fe_values.h>'
p39468
aS'#include <deal.II/fe/mapping.h>'
p39469
aS'#include <deal.II/fe/mapping_q.h>'
p39470
aS'#include <deal.II/grid/grid_generator.h>'
p39471
aS'#include <deal.II/grid/manifold_lib.h>'
p39472
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p39473
aS'#include <deal.II/lac/la_parallel_vector.h>'
p39474
aS'#include <deal.II/lac/sparse_matrix.h>'
p39475
aS'#include <deal.II/lac/sparse_matrix.templates.h>'
p39476
aS'#include <deal.II/lac/vector.h>'
p39477
aS'#include <deal.II/meshworker/scratch_data.h>'
p39478
aS'#include <deal.II/numerics/data_out.h>'
p39479
aS'#include <deal.II/numerics/vector_tools.h>'
p39480
aS'#include <boost/archive/binary_iarchive.hpp>'
p39481
aS'#include <boost/archive/binary_oarchive.hpp>'
p39482
aS'#include <deal.II/base/std_cxx20/iota_view.h>'
p39483
aS'#include <boost/range/iterator_range.hpp>'
p39484
aS'#include <cmath>'
p39485
aS'#include <fstream>'
p39486
aS'#include <future>'
p39487
aS'namespace Step69'
p39488
ag24
aS'  using namespace dealii;'
p39489
aS'  namespace Boundaries'
p39490
aS'  {'
p39491
aS'    constexpr types::boundary_id do_nothing = 0;'
p39492
aS'    constexpr types::boundary_id free_slip  = 1;'
p39493
aS'    constexpr types::boundary_id dirichlet  = 2;'
p39494
aS'  } // namespace Boundaries'
p39495
aS'  template <int dim>'
p39496
aS'  class Discretization : public ParameterAcceptor'
p39497
aS'  {'
p39498
aS'  public:'
p39499
aS'    Discretization(const MPI_Comm     mpi_communicator,'
p39500
aS'                   TimerOutput &      computing_timer,'
p39501
aS'                   const std::string &subsection = "Discretization");'
p39502
aS'    void setup();'
p39503
aS'    const MPI_Comm mpi_communicator;'
p39504
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p39505
aS'    const MappingQ<dim>   mapping;'
p39506
aS'    const FE_Q<dim>       finite_element;'
p39507
aS'    const QGauss<dim>     quadrature;'
p39508
aS'    const QGauss<dim - 1> face_quadrature;'
p39509
aS'  private:'
p39510
aS'    TimerOutput &computing_timer;'
p39511
aS'    double length;'
p39512
aS'    double height;'
p39513
aS'    double disk_position;'
p39514
aS'    double disk_diameter;'
p39515
aS'    unsigned int refinement;'
p39516
aS'  };'
p39517
aS'  template <int dim>'
p39518
aS'  class OfflineData : public ParameterAcceptor'
p39519
aS'  {'
p39520
aS'  public:'
p39521
aS'    using BoundaryNormalMap ='
p39522
aS'      std::map<types::global_dof_index,'
p39523
aS'               std::tuple<Tensor<1, dim>, types::boundary_id, Point<dim>>>;'
p39524
aS'    OfflineData(const MPI_Comm             mpi_communicator,'
p39525
aS'                TimerOutput &              computing_timer,'
p39526
aS'                const Discretization<dim> &discretization,'
p39527
aS'                const std::string &        subsection = "OfflineData");'
p39528
aS'    void setup();'
p39529
aS'    void assemble();'
p39530
aS'    DoFHandler<dim> dof_handler;'
p39531
aS'    std::shared_ptr<const Utilities::MPI::Partitioner> partitioner;'
p39532
aS'    unsigned int n_locally_owned;'
p39533
aS'    unsigned int n_locally_relevant;'
p39534
aS'    SparsityPattern sparsity_pattern;'
p39535
aS'    BoundaryNormalMap boundary_normal_map;'
p39536
aS'    SparseMatrix<double>                  lumped_mass_matrix;'
p39537
aS'    std::array<SparseMatrix<double>, dim> cij_matrix;'
p39538
aS'    std::array<SparseMatrix<double>, dim> nij_matrix;'
p39539
aS'    SparseMatrix<double>                  norm_matrix;'
p39540
aS'  private:'
p39541
aS'    const MPI_Comm mpi_communicator;'
p39542
aS'    TimerOutput &  computing_timer;'
p39543
aS'    SmartPointer<const Discretization<dim>> discretization;'
p39544
aS'  };'
p39545
aS'  template <int dim>'
p39546
aS'  class ProblemDescription'
p39547
aS'  {'
p39548
aS'  public:'
p39549
aS'    static constexpr unsigned int problem_dimension = 2 + dim;'
p39550
aS'    using state_type = Tensor<1, problem_dimension>;'
p39551
aS'    using flux_type  = Tensor<1, problem_dimension, Tensor<1, dim>>;'
p39552
aS'    const static std::array<std::string, problem_dimension> component_names;'
p39553
aS'    static constexpr double gamma = 7. / 5.;'
p39554
aS'    static DEAL_II_ALWAYS_INLINE inline Tensor<1, dim>'
p39555
aS'    momentum(const state_type &U);'
p39556
aS'    static DEAL_II_ALWAYS_INLINE inline double'
p39557
aS'    internal_energy(const state_type &U);'
p39558
aS'    static DEAL_II_ALWAYS_INLINE inline double pressure(const state_type &U);'
p39559
aS'    static DEAL_II_ALWAYS_INLINE inline double'
p39560
aS'    speed_of_sound(const state_type &U);'
p39561
aS'    static DEAL_II_ALWAYS_INLINE inline flux_type flux(const state_type &U);'
p39562
aS'    static DEAL_II_ALWAYS_INLINE inline double'
p39563
aS'    compute_lambda_max(const state_type &    U_i,'
p39564
aS'                       const state_type &    U_j,'
p39565
aS'                       const Tensor<1, dim> &n_ij);'
p39566
aS'  };'
p39567
aS'  template <int dim>'
p39568
aS'  class InitialValues : public ParameterAcceptor'
p39569
aS'  {'
p39570
aS'  public:'
p39571
aS'    using state_type = typename ProblemDescription<dim>::state_type;'
p39572
aS'    InitialValues(const std::string &subsection = "InitialValues");'
p39573
aS'    std::function<state_type(const Point<dim> &point, double t)> initial_state;'
p39574
aS'  private:'
p39575
aS'    void parse_parameters_callback();'
p39576
aS'    Tensor<1, dim> initial_direction;'
p39577
aS'    Tensor<1, 3>   initial_1d_state;'
p39578
aS'  };'
p39579
aS'  template <int dim>'
p39580
aS'  class TimeStepping : public ParameterAcceptor'
p39581
aS'  {'
p39582
aS'  public:'
p39583
aS'    static constexpr unsigned int problem_dimension ='
p39584
aS'      ProblemDescription<dim>::problem_dimension;'
p39585
aS'    using state_type = typename ProblemDescription<dim>::state_type;'
p39586
aS'    using flux_type  = typename ProblemDescription<dim>::flux_type;'
p39587
aS'    using vector_type ='
p39588
aS'      std::array<LinearAlgebra::distributed::Vector<double>, problem_dimension>;'
p39589
aS'    TimeStepping(const MPI_Comm            mpi_communicator,'
p39590
aS'                 TimerOutput &             computing_timer,'
p39591
aS'                 const OfflineData<dim> &  offline_data,'
p39592
aS'                 const InitialValues<dim> &initial_values,'
p39593
aS'                 const std::string &       subsection = "TimeStepping");'
p39594
aS'    void prepare();'
p39595
aS'    double make_one_step(vector_type &U, double t);'
p39596
aS'  private:'
p39597
aS'    const MPI_Comm mpi_communicator;'
p39598
aS'    TimerOutput &  computing_timer;'
p39599
aS'    SmartPointer<const OfflineData<dim>>   offline_data;'
p39600
aS'    SmartPointer<const InitialValues<dim>> initial_values;'
p39601
aS'    SparseMatrix<double> dij_matrix;'
p39602
aS'    vector_type temporary_vector;'
p39603
aS'    double cfl_update;'
p39604
aS'  };'
p39605
aS'  template <int dim>'
p39606
aS'  class SchlierenPostprocessor : public ParameterAcceptor'
p39607
aS'  {'
p39608
aS'  public:'
p39609
aS'    static constexpr unsigned int problem_dimension ='
p39610
aS'      ProblemDescription<dim>::problem_dimension;'
p39611
aS'    using state_type = typename ProblemDescription<dim>::state_type;'
p39612
aS'    using vector_type ='
p39613
aS'      std::array<LinearAlgebra::distributed::Vector<double>, problem_dimension>;'
p39614
aS'    SchlierenPostprocessor('
p39615
aS'      const MPI_Comm          mpi_communicator,'
p39616
aS'      TimerOutput &           computing_timer,'
p39617
aS'      const OfflineData<dim> &offline_data,'
p39618
aS'      const std::string &     subsection = "SchlierenPostprocessor");'
p39619
aS'    void prepare();'
p39620
aS'    void compute_schlieren(const vector_type &U);'
p39621
aS'    LinearAlgebra::distributed::Vector<double> schlieren;'
p39622
aS'  private:'
p39623
aS'    const MPI_Comm mpi_communicator;'
p39624
aS'    TimerOutput &  computing_timer;'
p39625
aS'    SmartPointer<const OfflineData<dim>> offline_data;'
p39626
aS'    Vector<double> r;'
p39627
aS'    unsigned int schlieren_index;'
p39628
aS'    double       schlieren_beta;'
p39629
aS'  };'
p39630
aS'  template <int dim>'
p39631
aS'  class MainLoop : public ParameterAcceptor'
p39632
aS'  {'
p39633
aS'  public:'
p39634
aS'    using vector_type = typename TimeStepping<dim>::vector_type;'
p39635
aS'    MainLoop(const MPI_Comm mpi_communnicator);'
p39636
aS'    void run();'
p39637
aS'  private:'
p39638
aS'    vector_type interpolate_initial_values(const double t = 0);'
p39639
aS'    void output(const vector_type &U,'
p39640
aS'                const std::string &name,'
p39641
aS'                double             t,'
p39642
aS'                unsigned int       cycle,'
p39643
aS'                bool               checkpoint = false);'
p39644
aS'    const MPI_Comm     mpi_communicator;'
p39645
aS'    std::ostringstream timer_output;'
p39646
aS'    TimerOutput        computing_timer;'
p39647
aS'    ConditionalOStream pcout;'
p39648
aS'    std::string base_name;'
p39649
aS'    double      t_final;'
p39650
aS'    double      output_granularity;'
p39651
aS'    bool asynchronous_writeback;'
p39652
aS'    bool resume;'
p39653
aS'    Discretization<dim>         discretization;'
p39654
aS'    OfflineData<dim>            offline_data;'
p39655
aS'    InitialValues<dim>          initial_values;'
p39656
aS'    TimeStepping<dim>           time_stepping;'
p39657
aS'    SchlierenPostprocessor<dim> schlieren_postprocessor;'
p39658
aS'    vector_type output_vector;'
p39659
aS'    std::future<void> background_thread_state;'
p39660
aS'  };'
p39661
aS'  template <int dim>'
p39662
aS'  Discretization<dim>::Discretization(const MPI_Comm     mpi_communicator,'
p39663
aS'                                      TimerOutput &      computing_timer,'
p39664
aS'                                      const std::string &subsection)'
p39665
aS'    : ParameterAcceptor(subsection)'
p39666
aS'    , mpi_communicator(mpi_communicator)'
p39667
aS'    , triangulation(mpi_communicator)'
p39668
aS'    , mapping(1)'
p39669
aS'    , finite_element(1)'
p39670
aS'    , quadrature(3)'
p39671
aS'    , face_quadrature(3)'
p39672
aS'    , computing_timer(computing_timer)'
p39673
aS'  {'
p39674
aS'    length = 4.;'
p39675
aS'    add_parameter("length", length, "Length of computational domain");'
p39676
aS'    height = 2.;'
p39677
aS'    add_parameter("height", height, "Height of computational domain");'
p39678
aS'    disk_position = 0.6;'
p39679
aS'    add_parameter("object position",'
p39680
aS'                  disk_position,'
p39681
aS'                  "x position of immersed disk center point");'
p39682
aS'    disk_diameter = 0.5;'
p39683
aS'    add_parameter("object diameter",'
p39684
aS'                  disk_diameter,'
p39685
aS'                  "Diameter of immersed disk");'
p39686
aS'    refinement = 5;'
p39687
aS'    add_parameter("refinement",'
p39688
aS'                  refinement,'
p39689
aS'                  "Number of refinement steps of the geometry");'
p39690
aS'  }'
p39691
aS'  template <int dim>'
p39692
aS'  void Discretization<dim>::setup()'
p39693
aS'  {'
p39694
aS'    TimerOutput::Scope scope(computing_timer, "discretization - setup");'
p39695
aS'    triangulation.clear();'
p39696
aS'    Triangulation<dim> tria1, tria2, tria3, tria4, tria5, tria6;'
p39697
aS'    GridGenerator::hyper_cube_with_cylindrical_hole('
p39698
aS'      tria1, disk_diameter / 2., disk_diameter, 0.5, 1, false);'
p39699
aS'    GridGenerator::subdivided_hyper_rectangle('
p39700
aS'      tria2,'
p39701
aS'      {2, 1},'
p39702
aS'      Point<2>(-disk_diameter, disk_diameter),'
p39703
aS'      Point<2>(disk_diameter, height / 2.));'
p39704
aS'    GridGenerator::subdivided_hyper_rectangle('
p39705
aS'      tria3,'
p39706
aS'      {2, 1},'
p39707
aS'      Point<2>(-disk_diameter, -disk_diameter),'
p39708
aS'      Point<2>(disk_diameter, -height / 2.));'
p39709
aS'    GridGenerator::subdivided_hyper_rectangle('
p39710
aS'      tria4,'
p39711
aS'      {6, 2},'
p39712
aS'      Point<2>(disk_diameter, -disk_diameter),'
p39713
aS'      Point<2>(length - disk_position, disk_diameter));'
p39714
aS'    GridGenerator::subdivided_hyper_rectangle('
p39715
aS'      tria5,'
p39716
aS'      {6, 1},'
p39717
aS'      Point<2>(disk_diameter, disk_diameter),'
p39718
aS'      Point<2>(length - disk_position, height / 2.));'
p39719
aS'    GridGenerator::subdivided_hyper_rectangle('
p39720
aS'      tria6,'
p39721
aS'      {6, 1},'
p39722
aS'      Point<2>(disk_diameter, -height / 2.),'
p39723
aS'      Point<2>(length - disk_position, -disk_diameter));'
p39724
aS'    GridGenerator::merge_triangulations('
p39725
aS'      {&tria1, &tria2, &tria3, &tria4, &tria5, &tria6},'
p39726
aS'      triangulation,'
p39727
aS'      1.e-12,'
p39728
aS'      true);'
p39729
aS'    triangulation.set_manifold(0, PolarManifold<2>(Point<2>()));'
p39730
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p39731
aS'      {'
p39732
aS'        for (const auto v : cell->vertex_indices())'
p39733
aS'          {'
p39734
aS'            if (cell->vertex(v)[0] <= -disk_diameter + 1.e-6)'
p39735
aS'              cell->vertex(v)[0] = -disk_position;'
p39736
aS'          }'
p39737
aS'      }'
p39738
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p39739
aS'      {'
p39740
aS'        for (const auto f : cell->face_indices())'
p39741
aS'          {'
p39742
aS'            const auto face = cell->face(f);'
p39743
aS'            if (face->at_boundary())'
p39744
aS'              {'
p39745
aS'                const auto center = face->center();'
p39746
aS'                if (center[0] > length - disk_position - 1.e-6)'
p39747
aS'                  face->set_boundary_id(Boundaries::do_nothing);'
p39748
aS'                else if (center[0] < -disk_position + 1.e-6)'
p39749
aS'                  face->set_boundary_id(Boundaries::dirichlet);'
p39750
aS'                else'
p39751
aS'                  face->set_boundary_id(Boundaries::free_slip);'
p39752
aS'              }'
p39753
aS'          }'
p39754
aS'      }'
p39755
aS'    triangulation.refine_global(refinement);'
p39756
aS'  }'
p39757
aS'  template <int dim>'
p39758
aS'  OfflineData<dim>::OfflineData(const MPI_Comm             mpi_communicator,'
p39759
aS'                                TimerOutput &              computing_timer,'
p39760
aS'                                const Discretization<dim> &discretization,'
p39761
aS'                                const std::string &        subsection)'
p39762
aS'    : ParameterAcceptor(subsection)'
p39763
aS'    , dof_handler(discretization.triangulation)'
p39764
aS'    , mpi_communicator(mpi_communicator)'
p39765
aS'    , computing_timer(computing_timer)'
p39766
aS'    , discretization(&discretization)'
p39767
aS'  {}'
p39768
aS'  template <int dim>'
p39769
aS'  void OfflineData<dim>::setup()'
p39770
aS'  {'
p39771
aS'    IndexSet locally_owned;'
p39772
aS'    IndexSet locally_relevant;'
p39773
aS'    {'
p39774
aS'      TimerOutput::Scope scope(computing_timer,'
p39775
aS'                               "offline_data - distribute dofs");'
p39776
aS'      dof_handler.distribute_dofs(discretization->finite_element);'
p39777
aS'      locally_owned   = dof_handler.locally_owned_dofs();'
p39778
aS'      n_locally_owned = locally_owned.n_elements();'
p39779
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant);'
p39780
aS'      n_locally_relevant = locally_relevant.n_elements();'
p39781
aS'      partitioner ='
p39782
aS'        std::make_shared<Utilities::MPI::Partitioner>(locally_owned,'
p39783
aS'                                                      locally_relevant,'
p39784
aS'                                                      mpi_communicator);'
p39785
aS'    }'
p39786
aS'    {'
p39787
aS'      TimerOutput::Scope scope('
p39788
aS'        computing_timer,'
p39789
aS'        "offline_data - create sparsity pattern and set up matrices");'
p39790
aS'      DynamicSparsityPattern dsp(n_locally_relevant, n_locally_relevant);'
p39791
aS'      const auto dofs_per_cell ='
p39792
aS'        discretization->finite_element.n_dofs_per_cell();'
p39793
aS'      std::vector<types::global_dof_index> dof_indices(dofs_per_cell);'
p39794
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p39795
aS'        {'
p39796
aS'          if (cell->is_artificial())'
p39797
aS'            continue;'
p39798
aS'           * corresponding "local" index range on the MPI process: */'
p39799
aS'          cell->get_dof_indices(dof_indices);'
p39800
aS'          std::transform(dof_indices.begin(),'
p39801
aS'                         dof_indices.end(),'
p39802
aS'                         dof_indices.begin(),'
p39803
aS'                         [&](types::global_dof_index index) {'
p39804
aS'                           return partitioner->global_to_local(index);'
p39805
aS'                         });'
p39806
aS'           * dofs on the cell: */'
p39807
aS'          for (const auto dof : dof_indices)'
p39808
aS'            dsp.add_entries(dof, dof_indices.begin(), dof_indices.end());'
p39809
aS'        }'
p39810
aS'      sparsity_pattern.copy_from(dsp);'
p39811
aS'      lumped_mass_matrix.reinit(sparsity_pattern);'
p39812
aS'      norm_matrix.reinit(sparsity_pattern);'
p39813
aS'      for (auto &matrix : cij_matrix)'
p39814
aS'        matrix.reinit(sparsity_pattern);'
p39815
aS'      for (auto &matrix : nij_matrix)'
p39816
aS'        matrix.reinit(sparsity_pattern);'
p39817
aS'    }'
p39818
aS'  }'
p39819
aS'  namespace'
p39820
aS'  {'
p39821
aS'    template <int dim>'
p39822
aS'    struct CopyData'
p39823
aS'    {'
p39824
aS'      bool                                         is_artificial;'
p39825
aS'      std::vector<types::global_dof_index>         local_dof_indices;'
p39826
aS'      typename OfflineData<dim>::BoundaryNormalMap local_boundary_normal_map;'
p39827
aS'      FullMatrix<double>                           cell_lumped_mass_matrix;'
p39828
aS'      std::array<FullMatrix<double>, dim>          cell_cij_matrix;'
p39829
aS'    };'
p39830
aS'    template <typename IteratorType>'
p39831
aS'    DEAL_II_ALWAYS_INLINE inline SparseMatrix<double>::value_type'
p39832
aS'    get_entry(const SparseMatrix<double> &matrix, const IteratorType &it)'
p39833
aS'    {'
p39834
aS'      const SparseMatrix<double>::const_iterator matrix_iterator('
p39835
aS'        &matrix, it->global_index());'
p39836
aS'      return matrix_iterator->value();'
p39837
aS'    }'
p39838
aS'    template <typename IteratorType>'
p39839
aS'    DEAL_II_ALWAYS_INLINE inline void'
p39840
aS'    set_entry(SparseMatrix<double> &           matrix,'
p39841
aS'              const IteratorType &             it,'
p39842
aS'              SparseMatrix<double>::value_type value)'
p39843
aS'    {'
p39844
aS'      SparseMatrix<double>::iterator matrix_iterator(&matrix,'
p39845
aS'                                                     it->global_index());'
p39846
aS'      matrix_iterator->value() = value;'
p39847
aS'    }'
p39848
aS'    template <std::size_t k, typename IteratorType>'
p39849
aS'    DEAL_II_ALWAYS_INLINE inline Tensor<1, k>'
p39850
aS'    gather_get_entry(const std::array<SparseMatrix<double>, k> &c_ij,'
p39851
aS'                     const IteratorType                         it)'
p39852
aS'    {'
p39853
aS'      Tensor<1, k> result;'
p39854
aS'      for (unsigned int j = 0; j < k; ++j)'
p39855
aS'        result[j] = get_entry(c_ij[j], it);'
p39856
aS'      return result;'
p39857
aS'    }'
p39858
aS'    template <std::size_t k>'
p39859
aS'    DEAL_II_ALWAYS_INLINE inline Tensor<1, k>'
p39860
aS'    gather(const std::array<SparseMatrix<double>, k> &n_ij,'
p39861
aS'           const unsigned int                         i,'
p39862
aS'           const unsigned int                         j)'
p39863
aS'    {'
p39864
aS'      Tensor<1, k> result;'
p39865
aS'      for (unsigned int l = 0; l < k; ++l)'
p39866
aS'        result[l] = n_ij[l](i, j);'
p39867
aS'      return result;'
p39868
aS'    }'
p39869
aS'    template <std::size_t k>'
p39870
aS'    DEAL_II_ALWAYS_INLINE inline Tensor<1, k>'
p39871
aS'    gather(const std::array<LinearAlgebra::distributed::Vector<double>, k> &U,'
p39872
aS'           const unsigned int                                               i)'
p39873
aS'    {'
p39874
aS'      Tensor<1, k> result;'
p39875
aS'      for (unsigned int j = 0; j < k; ++j)'
p39876
aS'        result[j] = U[j].local_element(i);'
p39877
aS'      return result;'
p39878
aS'    }'
p39879
aS'    template <std::size_t k, int k2>'
p39880
aS'    DEAL_II_ALWAYS_INLINE inline void'
p39881
aS'    scatter(std::array<LinearAlgebra::distributed::Vector<double>, k> &U,'
p39882
aS'            const Tensor<1, k2> &                                      tensor,'
p39883
aS'            const unsigned int                                         i)'
p39884
aS'    {'
p39885
aS'      static_assert(k == k2,'
p39886
aS'                    "The dimensions of the input arguments must agree");'
p39887
aS'      for (unsigned int j = 0; j < k; ++j)'
p39888
aS'        U[j].local_element(i) = tensor[j];'
p39889
aS'    }'
p39890
aS'  } // namespace'
p39891
aS'  template <int dim>'
p39892
aS'  void OfflineData<dim>::assemble()'
p39893
aS'  {'
p39894
aS'    lumped_mass_matrix = 0.;'
p39895
aS'    norm_matrix        = 0.;'
p39896
aS'    for (auto &matrix : cij_matrix)'
p39897
aS'      matrix = 0.;'
p39898
aS'    for (auto &matrix : nij_matrix)'
p39899
aS'      matrix = 0.;'
p39900
aS'    unsigned int dofs_per_cell ='
p39901
aS'      discretization->finite_element.n_dofs_per_cell();'
p39902
aS'    unsigned int n_q_points = discretization->quadrature.size();'
p39903
aS'    MeshWorker::ScratchData<dim> scratch_data('
p39904
aS'      discretization->mapping,'
p39905
aS'      discretization->finite_element,'
p39906
aS'      discretization->quadrature,'
p39907
aS'      update_values | update_gradients | update_quadrature_points |'
p39908
aS'        update_JxW_values,'
p39909
aS'      discretization->face_quadrature,'
p39910
aS'      update_normal_vectors | update_values | update_JxW_values);'
p39911
aS'    {'
p39912
aS'      TimerOutput::Scope scope('
p39913
aS'        computing_timer,'
p39914
aS'        "offline_data - assemble lumped mass matrix, and c_ij");'
p39915
aS'      const auto local_assemble_system = //'
p39916
aS'        [&](const typename DoFHandler<dim>::cell_iterator &cell,'
p39917
aS'            MeshWorker::ScratchData<dim> &                 scratch,'
p39918
aS'            CopyData<dim> &                                copy) {'
p39919
aS'          copy.is_artificial = cell->is_artificial();'
p39920
aS'          if (copy.is_artificial)'
p39921
aS'            return;'
p39922
aS'          copy.local_boundary_normal_map.clear();'
p39923
aS'          copy.cell_lumped_mass_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p39924
aS'          for (auto &matrix : copy.cell_cij_matrix)'
p39925
aS'            matrix.reinit(dofs_per_cell, dofs_per_cell);'
p39926
aS'          const auto &fe_values = scratch.reinit(cell);'
p39927
aS'          copy.local_dof_indices.resize(dofs_per_cell);'
p39928
aS'          cell->get_dof_indices(copy.local_dof_indices);'
p39929
aS'          std::transform(copy.local_dof_indices.begin(),'
p39930
aS'                         copy.local_dof_indices.end(),'
p39931
aS'                         copy.local_dof_indices.begin(),'
p39932
aS'                         [&](types::global_dof_index index) {'
p39933
aS'                           return partitioner->global_to_local(index);'
p39934
aS'                         });'
p39935
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p39936
aS'            {'
p39937
aS'              const auto JxW = fe_values.JxW(q_point);'
p39938
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p39939
aS'                {'
p39940
aS'                  const auto value_JxW ='
p39941
aS'                    fe_values.shape_value(j, q_point) * JxW;'
p39942
aS'                  const auto grad_JxW = fe_values.shape_grad(j, q_point) * JxW;'
p39943
aS'                  copy.cell_lumped_mass_matrix(j, j) += value_JxW;'
p39944
aS'                  for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p39945
aS'                    {'
p39946
aS'                      const auto value = fe_values.shape_value(i, q_point);'
p39947
aS'                      for (unsigned int d = 0; d < dim; ++d)'
p39948
aS'                        copy.cell_cij_matrix[d](i, j) += value * grad_JxW[d];'
p39949
aS'                    } /* i */'
p39950
aS'                }     /* j */'
p39951
aS'            }         /* q */'
p39952
aS'          for (const auto f : cell->face_indices())'
p39953
aS'            {'
p39954
aS'              const auto face = cell->face(f);'
p39955
aS'              const auto id   = face->boundary_id();'
p39956
aS'              if (!face->at_boundary())'
p39957
aS'                continue;'
p39958
aS'              const auto &fe_face_values = scratch.reinit(cell, f);'
p39959
aS'              const unsigned int n_face_q_points ='
p39960
aS'                fe_face_values.get_quadrature().size();'
p39961
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p39962
aS'                {'
p39963
aS'                  if (!discretization->finite_element.has_support_on_face(j, f))'
p39964
aS'                    continue;'
p39965
aS'                  Tensor<1, dim> normal;'
p39966
aS'                  if (id == Boundaries::free_slip)'
p39967
aS'                    {'
p39968
aS'                      for (unsigned int q = 0; q < n_face_q_points; ++q)'
p39969
aS'                        normal += fe_face_values.normal_vector(q) *'
p39970
aS'                                  fe_face_values.shape_value(j, q);'
p39971
aS'                    }'
p39972
aS'                  const auto index = copy.local_dof_indices[j];'
p39973
aS'                  Point<dim> position;'
p39974
aS'                  for (const auto v : cell->vertex_indices())'
p39975
aS'                    if (cell->vertex_dof_index(v, 0) =='
p39976
aS'                        partitioner->local_to_global(index))'
p39977
aS'                      {'
p39978
aS'                        position = cell->vertex(v);'
p39979
aS'                        break;'
p39980
aS'                      }'
p39981
aS'                  const auto old_id ='
p39982
aS'                    std::get<1>(copy.local_boundary_normal_map[index]);'
p39983
aS'                  copy.local_boundary_normal_map[index] ='
p39984
aS'                    std::make_tuple(normal, std::max(old_id, id), position);'
p39985
aS'                }'
p39986
aS'            }'
p39987
aS'        };'
p39988
aS'      const auto copy_local_to_global = [&](const CopyData<dim> &copy) {'
p39989
aS'        if (copy.is_artificial)'
p39990
aS'          return;'
p39991
aS'        for (const auto &it : copy.local_boundary_normal_map)'
p39992
aS'          {'
p39993
aS'            std::get<0>(boundary_normal_map[it.first]) +='
p39994
aS'              std::get<0>(it.second);'
p39995
aS'            std::get<1>(boundary_normal_map[it.first]) ='
p39996
aS'              std::max(std::get<1>(boundary_normal_map[it.first]),'
p39997
aS'                       std::get<1>(it.second));'
p39998
aS'            std::get<2>(boundary_normal_map[it.first]) = std::get<2>(it.second);'
p39999
aS'          }'
p40000
aS'        lumped_mass_matrix.add(copy.local_dof_indices,'
p40001
aS'                               copy.cell_lumped_mass_matrix);'
p40002
aS'        for (int k = 0; k < dim; ++k)'
p40003
aS'          {'
p40004
aS'            cij_matrix[k].add(copy.local_dof_indices, copy.cell_cij_matrix[k]);'
p40005
aS'            nij_matrix[k].add(copy.local_dof_indices, copy.cell_cij_matrix[k]);'
p40006
aS'          }'
p40007
aS'      };'
p40008
aS'      WorkStream::run(dof_handler.begin_active(),'
p40009
aS'                      dof_handler.end(),'
p40010
aS'                      local_assemble_system,'
p40011
aS'                      copy_local_to_global,'
p40012
aS'                      scratch_data,'
p40013
aS'                      CopyData<dim>());'
p40014
aS'    }'
p40015
aS'    {'
p40016
aS'      TimerOutput::Scope scope(computing_timer,'
p40017
aS'                               "offline_data - compute |c_ij|, and n_ij");'
p40018
aS'      const std_cxx20::ranges::iota_view<unsigned int, unsigned int> indices('
p40019
aS'        0, n_locally_relevant);'
p40020
aS'      const auto on_subranges = //'
p40021
aS'        [&](const auto i1, const auto i2) {'
p40022
aS'          for (const auto row_index :'
p40023
aS'               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1,'
p40024
aS'                                                                        *i2))'
p40025
aS'            {'
p40026
aS'              std::for_each('
p40027
aS'                sparsity_pattern.begin(row_index),'
p40028
aS'                sparsity_pattern.end(row_index),'
p40029
aS'                [&](const dealii::SparsityPatternIterators::Accessor &jt) {'
p40030
aS'                  const auto   c_ij = gather_get_entry(cij_matrix, &jt);'
p40031
aS'                  const double norm = c_ij.norm();'
p40032
aS'                  set_entry(norm_matrix, &jt, norm);'
p40033
aS'                  for (unsigned int j = 0; j < dim; ++j)'
p40034
aS'                    set_entry(nij_matrix[j], &jt, c_ij[j] / norm);'
p40035
aS'                });'
p40036
aS'            }'
p40037
aS'        };'
p40038
aS'      parallel::apply_to_subranges(indices.begin(),'
p40039
aS'                                   indices.end(),'
p40040
aS'                                   on_subranges,'
p40041
aS'                                   4096);'
p40042
aS'      for (auto &it : boundary_normal_map)'
p40043
aS'        {'
p40044
aS'          auto &normal = std::get<0>(it.second);'
p40045
aS'          normal /= (normal.norm() + std::numeric_limits<double>::epsilon());'
p40046
aS'        }'
p40047
aS'    }'
p40048
aS'  }'
p40049
aS'  template <int dim>'
p40050
aS'  DEAL_II_ALWAYS_INLINE inline Tensor<1, dim>'
p40051
aS'  ProblemDescription<dim>::momentum(const state_type &U)'
p40052
aS'  {'
p40053
aS'    Tensor<1, dim> result;'
p40054
aS'    std::copy_n(&U[1], dim, &result[0]);'
p40055
aS'    return result;'
p40056
aS'  }'
p40057
aS'  template <int dim>'
p40058
aS'  DEAL_II_ALWAYS_INLINE inline double'
p40059
aS'  ProblemDescription<dim>::internal_energy(const state_type &U)'
p40060
aS'  {'
p40061
aS'    const double &rho = U[0];'
p40062
aS'    const auto    m   = momentum(U);'
p40063
aS'    const double &E   = U[dim + 1];'
p40064
aS'    return E - 0.5 * m.norm_square() / rho;'
p40065
aS'  }'
p40066
aS'  template <int dim>'
p40067
aS'  DEAL_II_ALWAYS_INLINE inline double'
p40068
aS'  ProblemDescription<dim>::pressure(const state_type &U)'
p40069
aS'  {'
p40070
aS'    return (gamma - 1.) * internal_energy(U);'
p40071
aS'  }'
p40072
aS'  template <int dim>'
p40073
aS'  DEAL_II_ALWAYS_INLINE inline double'
p40074
aS'  ProblemDescription<dim>::speed_of_sound(const state_type &U)'
p40075
aS'  {'
p40076
aS'    const double &rho = U[0];'
p40077
aS'    const double  p   = pressure(U);'
p40078
aS'    return std::sqrt(gamma * p / rho);'
p40079
aS'  }'
p40080
aS'  template <int dim>'
p40081
aS'  DEAL_II_ALWAYS_INLINE inline typename ProblemDescription<dim>::flux_type'
p40082
aS'  ProblemDescription<dim>::flux(const state_type &U)'
p40083
aS'  {'
p40084
aS'    const double &rho = U[0];'
p40085
aS'    const auto    m   = momentum(U);'
p40086
aS'    const auto    p   = pressure(U);'
p40087
aS'    const double &E   = U[dim + 1];'
p40088
aS'    flux_type result;'
p40089
aS'    result[0] = m;'
p40090
aS'    for (unsigned int i = 0; i < dim; ++i)'
p40091
aS'      {'
p40092
aS'        result[1 + i] = m * m[i] / rho;'
p40093
aS'        result[1 + i][i] += p;'
p40094
aS'      }'
p40095
aS'    result[dim + 1] = m / rho * (E + p);'
p40096
aS'    return result;'
p40097
aS'  }'
p40098
aS'  namespace'
p40099
aS'  {'
p40100
aS'    template <int dim>'
p40101
aS'    DEAL_II_ALWAYS_INLINE inline std::array<double, 4> riemann_data_from_state('
p40102
aS'      const typename ProblemDescription<dim>::state_type U,'
p40103
aS'      const Tensor<1, dim> &                             n_ij)'
p40104
aS'    {'
p40105
aS'      Tensor<1, 3> projected_U;'
p40106
aS'      projected_U[0] = U[0];'
p40107
aS'      const auto m   = ProblemDescription<dim>::momentum(U);'
p40108
aS'      projected_U[1] = n_ij * m;'
p40109
aS'      const auto perpendicular_m = m - projected_U[1] * n_ij;'
p40110
aS'      projected_U[2] = U[1 + dim] - 0.5 * perpendicular_m.norm_square() / U[0];'
p40111
aS'      return {{projected_U[0],'
p40112
aS'               projected_U[1] / projected_U[0],'
p40113
aS'               ProblemDescription<1>::pressure(projected_U),'
p40114
aS'               ProblemDescription<1>::speed_of_sound(projected_U)}};'
p40115
aS'    }'
p40116
aS'    DEAL_II_ALWAYS_INLINE inline double positive_part(const double number)'
p40117
aS'    {'
p40118
aS'      return std::max(number, 0.);'
p40119
aS'    }'
p40120
aS'    DEAL_II_ALWAYS_INLINE inline double negative_part(const double number)'
p40121
aS'    {'
p40122
aS'      return -std::min(number, 0.);'
p40123
aS'    }'
p40124
aS'    DEAL_II_ALWAYS_INLINE inline double'
p40125
aS'    lambda1_minus(const std::array<double, 4> &riemann_data,'
p40126
aS'                  const double                 p_star)'
p40127
aS'    {'
p40128
aS'      constexpr double gamma = ProblemDescription<1>::gamma;'
p40129
aS'      const auto       u     = riemann_data[1];'
p40130
aS'      const auto       p     = riemann_data[2];'
p40131
aS'      const auto       a     = riemann_data[3];'
p40132
aS'      const double factor = (gamma + 1.0) / 2.0 / gamma;'
p40133
aS'      const double tmp    = positive_part((p_star - p) / p);'
p40134
aS'      return u - a * std::sqrt(1.0 + factor * tmp);'
p40135
aS'    }'
p40136
aS'    DEAL_II_ALWAYS_INLINE inline double'
p40137
aS'    lambda3_plus(const std::array<double, 4> &riemann_data, const double p_star)'
p40138
aS'    {'
p40139
aS'      constexpr double gamma = ProblemDescription<1>::gamma;'
p40140
aS'      const auto       u     = riemann_data[1];'
p40141
aS'      const auto       p     = riemann_data[2];'
p40142
aS'      const auto       a     = riemann_data[3];'
p40143
aS'      const double factor = (gamma + 1.0) / 2.0 / gamma;'
p40144
aS'      const double tmp    = positive_part((p_star - p) / p);'
p40145
aS'      return u + a * std::sqrt(1.0 + factor * tmp);'
p40146
aS'    }'
p40147
aS'    DEAL_II_ALWAYS_INLINE inline double'
p40148
aS'    lambda_max_two_rarefaction(const std::array<double, 4> &riemann_data_i,'
p40149
aS'                               const std::array<double, 4> &riemann_data_j)'
p40150
aS'    {'
p40151
aS'      constexpr double gamma = ProblemDescription<1>::gamma;'
p40152
aS'      const auto       u_i   = riemann_data_i[1];'
p40153
aS'      const auto       p_i   = riemann_data_i[2];'
p40154
aS'      const auto       a_i   = riemann_data_i[3];'
p40155
aS'      const auto       u_j   = riemann_data_j[1];'
p40156
aS'      const auto       p_j   = riemann_data_j[2];'
p40157
aS'      const auto       a_j   = riemann_data_j[3];'
p40158
aS'      const double numerator = a_i + a_j - (gamma - 1.) / 2. * (u_j - u_i);'
p40159
aS'      const double denominator ='
p40160
aS'        a_i * std::pow(p_i / p_j, -1. * (gamma - 1.) / 2. / gamma) + a_j * 1.;'
p40161
aS'      const double p_star ='
p40162
aS'        p_j * std::pow(numerator / denominator, 2. * gamma / (gamma - 1));'
p40163
aS'      const double lambda1 = lambda1_minus(riemann_data_i, p_star);'
p40164
aS'      const double lambda3 = lambda3_plus(riemann_data_j, p_star);'
p40165
aS'      return std::max(positive_part(lambda3), negative_part(lambda1));'
p40166
aS'    }'
p40167
aS'    DEAL_II_ALWAYS_INLINE inline double'
p40168
aS'    lambda_max_expansion(const std::array<double, 4> &riemann_data_i,'
p40169
aS'                         const std::array<double, 4> &riemann_data_j)'
p40170
aS'    {'
p40171
aS'      const auto u_i = riemann_data_i[1];'
p40172
aS'      const auto a_i = riemann_data_i[3];'
p40173
aS'      const auto u_j = riemann_data_j[1];'
p40174
aS'      const auto a_j = riemann_data_j[3];'
p40175
aS'      return std::max(std::abs(u_i), std::abs(u_j)) + 5. * std::max(a_i, a_j);'
p40176
aS'    }'
p40177
aS'  } // namespace'
p40178
aS'  template <int dim>'
p40179
aS'  DEAL_II_ALWAYS_INLINE inline double'
p40180
aS'  ProblemDescription<dim>::compute_lambda_max(const state_type &    U_i,'
p40181
aS'                                              const state_type &    U_j,'
p40182
aS'                                              const Tensor<1, dim> &n_ij)'
p40183
aS'  {'
p40184
aS'    const auto riemann_data_i = riemann_data_from_state(U_i, n_ij);'
p40185
aS'    const auto riemann_data_j = riemann_data_from_state(U_j, n_ij);'
p40186
aS'    const double lambda_1 ='
p40187
aS'      lambda_max_two_rarefaction(riemann_data_i, riemann_data_j);'
p40188
aS'    const double lambda_2 ='
p40189
aS'      lambda_max_expansion(riemann_data_i, riemann_data_j);'
p40190
aS'    return std::min(lambda_1, lambda_2);'
p40191
aS'  }'
p40192
aS'  template <>'
p40193
aS'  const std::array<std::string, 3> ProblemDescription<1>::component_names{'
p40194
aS'    {"rho", "m", "E"}};'
p40195
aS'  template <>'
p40196
aS'  const std::array<std::string, 4> ProblemDescription<2>::component_names{'
p40197
aS'    {"rho", "m_1", "m_2", "E"}};'
p40198
aS'  template <>'
p40199
aS'  const std::array<std::string, 5> ProblemDescription<3>::component_names{'
p40200
aS'    {"rho", "m_1", "m_2", "m_3", "E"}};'
p40201
aS'  template <int dim>'
p40202
aS'  InitialValues<dim>::InitialValues(const std::string &subsection)'
p40203
aS'    : ParameterAcceptor(subsection)'
p40204
aS'  {'
p40205
aS'       the ParameterAcceptor::parse_parameters_call_back signal: */'
p40206
aS'    ParameterAcceptor::parse_parameters_call_back.connect('
p40207
aS'      std::bind(&InitialValues<dim>::parse_parameters_callback, this));'
p40208
aS'    initial_direction[0] = 1.;'
p40209
aS'    add_parameter("initial direction",'
p40210
aS'                  initial_direction,'
p40211
aS'                  "Initial direction of the uniform flow field");'
p40212
aS'    initial_1d_state[0] = ProblemDescription<dim>::gamma;'
p40213
aS'    initial_1d_state[1] = 3.;'
p40214
aS'    initial_1d_state[2] = 1.;'
p40215
aS'    add_parameter("initial 1d state",'
p40216
aS'                  initial_1d_state,'
p40217
aS'                  "Initial 1d state (rho, u, p) of the uniform flow field");'
p40218
aS'  }'
p40219
aS'  template <int dim>'
p40220
aS'  void InitialValues<dim>::parse_parameters_callback()'
p40221
aS'  {'
p40222
aS'    AssertThrow(initial_direction.norm() != 0.,'
p40223
aS'                ExcMessage('
p40224
aS'                  "Initial shock front direction is set to the zero vector."));'
p40225
aS'    initial_direction /= initial_direction.norm();'
p40226
aS'    initial_state = [this](const Point<dim> & /*point*/, double /*t*/) {'
p40227
aS'      const double            rho   = initial_1d_state[0];'
p40228
aS'      const double            u     = initial_1d_state[1];'
p40229
aS'      const double            p     = initial_1d_state[2];'
p40230
aS'      static constexpr double gamma = ProblemDescription<dim>::gamma;'
p40231
aS'      state_type state;'
p40232
aS'      state[0] = rho;'
p40233
aS'      for (unsigned int i = 0; i < dim; ++i)'
p40234
aS'        state[1 + i] = rho * u * initial_direction[i];'
p40235
aS'      state[dim + 1] = p / (gamma - 1.) + 0.5 * rho * u * u;'
p40236
aS'      return state;'
p40237
aS'    };'
p40238
aS'  }'
p40239
aS'  template <int dim>'
p40240
aS'  TimeStepping<dim>::TimeStepping('
p40241
aS'    const MPI_Comm            mpi_communicator,'
p40242
aS'    TimerOutput &             computing_timer,'
p40243
aS'    const OfflineData<dim> &  offline_data,'
p40244
aS'    const InitialValues<dim> &initial_values,'
p40245
aS'    const std::string &       subsection /*= "TimeStepping"*/)'
p40246
aS'    : ParameterAcceptor(subsection)'
p40247
aS'    , mpi_communicator(mpi_communicator)'
p40248
aS'    , computing_timer(computing_timer)'
p40249
aS'    , offline_data(&offline_data)'
p40250
aS'    , initial_values(&initial_values)'
p40251
aS'  {'
p40252
aS'    cfl_update = 0.80;'
p40253
aS'    add_parameter("cfl update",'
p40254
aS'                  cfl_update,'
p40255
aS'                  "Relative CFL constant used for update");'
p40256
aS'  }'
p40257
aS'  template <int dim>'
p40258
aS'  void TimeStepping<dim>::prepare()'
p40259
aS'  {'
p40260
aS'    TimerOutput::Scope scope(computing_timer,'
p40261
aS'                             "time_stepping - prepare scratch space");'
p40262
aS'    for (auto &it : temporary_vector)'
p40263
aS'      it.reinit(offline_data->partitioner);'
p40264
aS'    dij_matrix.reinit(offline_data->sparsity_pattern);'
p40265
aS'  }'
p40266
aS'  template <int dim>'
p40267
aS'  double TimeStepping<dim>::make_one_step(vector_type &U, double t)'
p40268
aS'  {'
p40269
aS'    const auto &n_locally_owned    = offline_data->n_locally_owned;'
p40270
aS'    const auto &n_locally_relevant = offline_data->n_locally_relevant;'
p40271
aS'    const std_cxx20::ranges::iota_view<unsigned int, unsigned int>'
p40272
aS'      indices_owned(0, n_locally_owned);'
p40273
aS'    const std_cxx20::ranges::iota_view<unsigned int, unsigned int>'
p40274
aS'      indices_relevant(0, n_locally_relevant);'
p40275
aS'    const auto &sparsity = offline_data->sparsity_pattern;'
p40276
aS'    const auto &lumped_mass_matrix = offline_data->lumped_mass_matrix;'
p40277
aS'    const auto &norm_matrix        = offline_data->norm_matrix;'
p40278
aS'    const auto &nij_matrix         = offline_data->nij_matrix;'
p40279
aS'    const auto &cij_matrix         = offline_data->cij_matrix;'
p40280
aS'    const auto &boundary_normal_map = offline_data->boundary_normal_map;'
p40281
aS'    {'
p40282
aS'      TimerOutput::Scope scope(computing_timer,'
p40283
aS'                               "time_stepping - 1 compute d_ij");'
p40284
aS'      const auto on_subranges = //'
p40285
aS'        [&](const auto i1, const auto i2) {'
p40286
aS'          for (const auto i :'
p40287
aS'               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1,'
p40288
aS'                                                                        *i2))'
p40289
aS'            {'
p40290
aS'              const auto U_i = gather(U, i);'
p40291
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p40292
aS'                {'
p40293
aS'                  const auto j = jt->column();'
p40294
aS'                  if (j >= i)'
p40295
aS'                    continue;'
p40296
aS'                  const auto U_j = gather(U, j);'
p40297
aS'                  const auto   n_ij = gather_get_entry(nij_matrix, jt);'
p40298
aS'                  const double norm = get_entry(norm_matrix, jt);'
p40299
aS'                  const auto lambda_max ='
p40300
aS'                    ProblemDescription<dim>::compute_lambda_max(U_i, U_j, n_ij);'
p40301
aS'                  double d = norm * lambda_max;'
p40302
aS'                  if (boundary_normal_map.count(i) != 0 &&'
p40303
aS'                      boundary_normal_map.count(j) != 0)'
p40304
aS'                    {'
p40305
aS'                      const auto n_ji = gather(nij_matrix, j, i);'
p40306
aS'                      const auto lambda_max_2 ='
p40307
aS'                        ProblemDescription<dim>::compute_lambda_max(U_j,'
p40308
aS'                                                                    U_i,'
p40309
aS'                                                                    n_ji);'
p40310
aS'                      const double norm_2 = norm_matrix(j, i);'
p40311
aS'                      d = std::max(d, norm_2 * lambda_max_2);'
p40312
aS'                    }'
p40313
aS'                  set_entry(dij_matrix, jt, d);'
p40314
aS'                  dij_matrix(j, i) = d;'
p40315
aS'                }'
p40316
aS'            }'
p40317
aS'        };'
p40318
aS'      parallel::apply_to_subranges(indices_relevant.begin(),'
p40319
aS'                                   indices_relevant.end(),'
p40320
aS'                                   on_subranges,'
p40321
aS'                                   4096);'
p40322
aS'    }'
p40323
aS'    std::atomic<double> tau_max{std::numeric_limits<double>::infinity()};'
p40324
aS'    {'
p40325
aS'      TimerOutput::Scope scope(computing_timer,'
p40326
aS'                               "time_stepping - 2 compute d_ii, and tau_max");'
p40327
aS'      const auto on_subranges = //'
p40328
aS'        [&](const auto i1, const auto i2) {'
p40329
aS'          double tau_max_on_subrange = std::numeric_limits<double>::infinity();'
p40330
aS'          for (const auto i :'
p40331
aS'               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1,'
p40332
aS'                                                                        *i2))'
p40333
aS'            {'
p40334
aS'              double d_sum = 0.;'
p40335
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p40336
aS'                {'
p40337
aS'                  const auto j = jt->column();'
p40338
aS'                  if (j == i)'
p40339
aS'                    continue;'
p40340
aS'                  d_sum -= get_entry(dij_matrix, jt);'
p40341
aS'                }'
p40342
aS'              dij_matrix.diag_element(i) = d_sum;'
p40343
aS'              const double mass   = lumped_mass_matrix.diag_element(i);'
p40344
aS'              const double tau    = cfl_update * mass / (-2. * d_sum);'
p40345
aS'              tau_max_on_subrange = std::min(tau_max_on_subrange, tau);'
p40346
aS'            }'
p40347
aS'          double current_tau_max = tau_max.load();'
p40348
aS'          while (current_tau_max > tau_max_on_subrange &&'
p40349
aS'                 !tau_max.compare_exchange_weak(current_tau_max,'
p40350
aS'                                                tau_max_on_subrange))'
p40351
aS'            ;'
p40352
aS'        };'
p40353
aS'      parallel::apply_to_subranges(indices_relevant.begin(),'
p40354
aS'                                   indices_relevant.end(),'
p40355
aS'                                   on_subranges,'
p40356
aS'                                   4096);'
p40357
aS'      tau_max.store(Utilities::MPI::min(tau_max.load(), mpi_communicator));'
p40358
aS'      AssertThrow('
p40359
aS'        !std::isnan(tau_max.load()) && !std::isinf(tau_max.load()) &&'
p40360
aS'          tau_max.load() > 0.,'
p40361
aS'        ExcMessage('
p40362
aS'          "I\'m sorry, Dave. I\'m afraid I can\'t do that. - We crashed."));'
p40363
aS'    }'
p40364
aS'    {'
p40365
aS'      TimerOutput::Scope scope(computing_timer,'
p40366
aS'                               "time_stepping - 3 perform update");'
p40367
aS'      const auto on_subranges = //'
p40368
aS'        [&](const auto i1, const auto i2) {'
p40369
aS'          for (const auto i : boost::make_iterator_range(i1, i2))'
p40370
aS'            {'
p40371
aS'              Assert(i < n_locally_owned, ExcInternalError());'
p40372
aS'              const auto U_i = gather(U, i);'
p40373
aS'              const auto   f_i = ProblemDescription<dim>::flux(U_i);'
p40374
aS'              const double m_i = lumped_mass_matrix.diag_element(i);'
p40375
aS'              auto U_i_new = U_i;'
p40376
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p40377
aS'                {'
p40378
aS'                  const auto j = jt->column();'
p40379
aS'                  const auto U_j = gather(U, j);'
p40380
aS'                  const auto f_j = ProblemDescription<dim>::flux(U_j);'
p40381
aS'                  const auto c_ij = gather_get_entry(cij_matrix, jt);'
p40382
aS'                  const auto d_ij = get_entry(dij_matrix, jt);'
p40383
aS'                  for (unsigned int k = 0; k < problem_dimension; ++k)'
p40384
aS'                    {'
p40385
aS'                      U_i_new[k] +='
p40386
aS'                        tau_max / m_i *'
p40387
aS'                        (-(f_j[k] - f_i[k]) * c_ij + d_ij * (U_j[k] - U_i[k]));'
p40388
aS'                    }'
p40389
aS'                }'
p40390
aS'              scatter(temporary_vector, U_i_new, i);'
p40391
aS'            }'
p40392
aS'        };'
p40393
aS'      parallel::apply_to_subranges(indices_owned.begin(),'
p40394
aS'                                   indices_owned.end(),'
p40395
aS'                                   on_subranges,'
p40396
aS'                                   4096);'
p40397
aS'    }'
p40398
aS'    {'
p40399
aS'      TimerOutput::Scope scope(computing_timer,'
p40400
aS'                               "time_stepping - 4 fix boundary states");'
p40401
aS'      for (auto it : boundary_normal_map)'
p40402
aS'        {'
p40403
aS'          const auto i = it.first;'
p40404
aS'          if (i >= n_locally_owned)'
p40405
aS'            continue;'
p40406
aS'          const auto &normal   = std::get<0>(it.second);'
p40407
aS'          const auto &id       = std::get<1>(it.second);'
p40408
aS'          const auto &position = std::get<2>(it.second);'
p40409
aS'          auto U_i = gather(temporary_vector, i);'
p40410
aS'          if (id == Boundaries::free_slip)'
p40411
aS'            {'
p40412
aS'              auto m = ProblemDescription<dim>::momentum(U_i);'
p40413
aS'              m -= (m * normal) * normal;'
p40414
aS'              for (unsigned int k = 0; k < dim; ++k)'
p40415
aS'                U_i[k + 1] = m[k];'
p40416
aS'            }'
p40417
aS'          else if (id == Boundaries::dirichlet)'
p40418
aS'            {'
p40419
aS'              U_i = initial_values->initial_state(position, t + tau_max);'
p40420
aS'            }'
p40421
aS'          scatter(temporary_vector, U_i, i);'
p40422
aS'        }'
p40423
aS'    }'
p40424
aS'    for (auto &it : temporary_vector)'
p40425
aS'      it.update_ghost_values();'
p40426
aS'    U.swap(temporary_vector);'
p40427
aS'    return tau_max;'
p40428
aS'  }'
p40429
aS'  template <int dim>'
p40430
aS'  SchlierenPostprocessor<dim>::SchlierenPostprocessor('
p40431
aS'    const MPI_Comm          mpi_communicator,'
p40432
aS'    TimerOutput &           computing_timer,'
p40433
aS'    const OfflineData<dim> &offline_data,'
p40434
aS'    const std::string &     subsection /*= "SchlierenPostprocessor"*/)'
p40435
aS'    : ParameterAcceptor(subsection)'
p40436
aS'    , mpi_communicator(mpi_communicator)'
p40437
aS'    , computing_timer(computing_timer)'
p40438
aS'    , offline_data(&offline_data)'
p40439
aS'  {'
p40440
aS'    schlieren_beta = 10.;'
p40441
aS'    add_parameter("schlieren beta",'
p40442
aS'                  schlieren_beta,'
p40443
aS'                  "Beta factor used in Schlieren-type postprocessor");'
p40444
aS'    schlieren_index = 0;'
p40445
aS'    add_parameter("schlieren index",'
p40446
aS'                  schlieren_index,'
p40447
aS'                  "Use the corresponding component of the state vector for the "'
p40448
aS'                  "schlieren plot");'
p40449
aS'  }'
p40450
aS'  template <int dim>'
p40451
aS'  void SchlierenPostprocessor<dim>::prepare()'
p40452
aS'  {'
p40453
aS'    TimerOutput::Scope scope(computing_timer,'
p40454
aS'                             "schlieren_postprocessor - prepare scratch space");'
p40455
aS'    r.reinit(offline_data->n_locally_relevant);'
p40456
aS'    schlieren.reinit(offline_data->partitioner);'
p40457
aS'  }'
p40458
aS'  template <int dim>'
p40459
aS'  void SchlierenPostprocessor<dim>::compute_schlieren(const vector_type &U)'
p40460
aS'  {'
p40461
aS'    TimerOutput::Scope scope('
p40462
aS'      computing_timer, "schlieren_postprocessor - compute schlieren plot");'
p40463
aS'    const auto &sparsity            = offline_data->sparsity_pattern;'
p40464
aS'    const auto &lumped_mass_matrix  = offline_data->lumped_mass_matrix;'
p40465
aS'    const auto &cij_matrix          = offline_data->cij_matrix;'
p40466
aS'    const auto &boundary_normal_map = offline_data->boundary_normal_map;'
p40467
aS'    const auto &n_locally_owned     = offline_data->n_locally_owned;'
p40468
aS'    const auto indices ='
p40469
aS'      std_cxx20::ranges::iota_view<unsigned int, unsigned int>(0,'
p40470
aS'                                                               n_locally_owned);'
p40471
aS'    std::atomic<double> r_i_max{0.};'
p40472
aS'    std::atomic<double> r_i_min{std::numeric_limits<double>::infinity()};'
p40473
aS'    {'
p40474
aS'      const auto on_subranges = //'
p40475
aS'        [&](const auto i1, const auto i2) {'
p40476
aS'          double r_i_max_on_subrange = 0.;'
p40477
aS'          double r_i_min_on_subrange = std::numeric_limits<double>::infinity();'
p40478
aS'          for (const auto i : boost::make_iterator_range(i1, i2))'
p40479
aS'            {'
p40480
aS'              Assert(i < n_locally_owned, ExcInternalError());'
p40481
aS'              Tensor<1, dim> r_i;'
p40482
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p40483
aS'                {'
p40484
aS'                  const auto j = jt->column();'
p40485
aS'                  if (i == j)'
p40486
aS'                    continue;'
p40487
aS'                  const auto U_js = U[schlieren_index].local_element(j);'
p40488
aS'                  const auto c_ij = gather_get_entry(cij_matrix, jt);'
p40489
aS'                  r_i += c_ij * U_js;'
p40490
aS'                }'
p40491
aS'              const auto bnm_it = boundary_normal_map.find(i);'
p40492
aS'              if (bnm_it != boundary_normal_map.end())'
p40493
aS'                {'
p40494
aS'                  const auto &normal = std::get<0>(bnm_it->second);'
p40495
aS'                  const auto &id     = std::get<1>(bnm_it->second);'
p40496
aS'                  if (id == Boundaries::free_slip)'
p40497
aS'                    r_i -= 1. * (r_i * normal) * normal;'
p40498
aS'                  else'
p40499
aS'                    r_i = 0.;'
p40500
aS'                }'
p40501
aS'              const double m_i    = lumped_mass_matrix.diag_element(i);'
p40502
aS'              r[i]                = r_i.norm() / m_i;'
p40503
aS'              r_i_max_on_subrange = std::max(r_i_max_on_subrange, r[i]);'
p40504
aS'              r_i_min_on_subrange = std::min(r_i_min_on_subrange, r[i]);'
p40505
aS'            }'
p40506
aS'          double current_r_i_max = r_i_max.load();'
p40507
aS'          while (current_r_i_max < r_i_max_on_subrange &&'
p40508
aS'                 !r_i_max.compare_exchange_weak(current_r_i_max,'
p40509
aS'                                                r_i_max_on_subrange))'
p40510
aS'            ;'
p40511
aS'          double current_r_i_min = r_i_min.load();'
p40512
aS'          while (current_r_i_min > r_i_min_on_subrange &&'
p40513
aS'                 !r_i_min.compare_exchange_weak(current_r_i_min,'
p40514
aS'                                                r_i_min_on_subrange))'
p40515
aS'            ;'
p40516
aS'        };'
p40517
aS'      parallel::apply_to_subranges(indices.begin(),'
p40518
aS'                                   indices.end(),'
p40519
aS'                                   on_subranges,'
p40520
aS'                                   4096);'
p40521
aS'    }'
p40522
aS'    r_i_max.store(Utilities::MPI::max(r_i_max.load(), mpi_communicator));'
p40523
aS'    r_i_min.store(Utilities::MPI::min(r_i_min.load(), mpi_communicator));'
p40524
aS'    {'
p40525
aS'      const auto on_subranges = //'
p40526
aS'        [&](const auto i1, const auto i2) {'
p40527
aS'          for (const auto i : boost::make_iterator_range(i1, i2))'
p40528
aS'            {'
p40529
aS'              Assert(i < n_locally_owned, ExcInternalError());'
p40530
aS'              schlieren.local_element(i) ='
p40531
aS'                1. - std::exp(-schlieren_beta * (r[i] - r_i_min) /'
p40532
aS'                              (r_i_max - r_i_min));'
p40533
aS'            }'
p40534
aS'        };'
p40535
aS'      parallel::apply_to_subranges(indices.begin(),'
p40536
aS'                                   indices.end(),'
p40537
aS'                                   on_subranges,'
p40538
aS'                                   4096);'
p40539
aS'    }'
p40540
aS'    schlieren.update_ghost_values();'
p40541
aS'  }'
p40542
aS'  template <int dim>'
p40543
aS'  MainLoop<dim>::MainLoop(const MPI_Comm mpi_communicator)'
p40544
aS'    : ParameterAcceptor("A - MainLoop")'
p40545
aS'    , mpi_communicator(mpi_communicator)'
p40546
aS'    , computing_timer(mpi_communicator,'
p40547
aS'                      timer_output,'
p40548
aS'                      TimerOutput::never,'
p40549
aS'                      TimerOutput::cpu_and_wall_times)'
p40550
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p40551
aS'    , discretization(mpi_communicator, computing_timer, "B - Discretization")'
p40552
aS'    , offline_data(mpi_communicator,'
p40553
aS'                   computing_timer,'
p40554
aS'                   discretization,'
p40555
aS'                   "C - OfflineData")'
p40556
aS'    , initial_values("D - InitialValues")'
p40557
aS'    , time_stepping(mpi_communicator,'
p40558
aS'                    computing_timer,'
p40559
aS'                    offline_data,'
p40560
aS'                    initial_values,'
p40561
aS'                    "E - TimeStepping")'
p40562
aS'    , schlieren_postprocessor(mpi_communicator,'
p40563
aS'                              computing_timer,'
p40564
aS'                              offline_data,'
p40565
aS'                              "F - SchlierenPostprocessor")'
p40566
aS'  {'
p40567
aS'    base_name = "test";'
p40568
aS'    add_parameter("basename", base_name, "Base name for all output files");'
p40569
aS'    t_final = 4.;'
p40570
aS'    add_parameter("final time", t_final, "Final time");'
p40571
aS'    output_granularity = 0.02;'
p40572
aS'    add_parameter("output granularity",'
p40573
aS'                  output_granularity,'
p40574
aS'                  "time interval for output");'
p40575
aS'    asynchronous_writeback = true;'
p40576
aS'    add_parameter("asynchronous writeback",'
p40577
aS'                  asynchronous_writeback,'
p40578
aS'                  "Write out solution in a background thread performing IO");'
p40579
aS'    resume = false;'
p40580
aS'    add_parameter("resume", resume, "Resume an interrupted computation.");'
p40581
aS'  }'
p40582
aS'  namespace'
p40583
aS'  {'
p40584
aS'    void print_head(ConditionalOStream &pcout,'
p40585
aS'                    const std::string & header,'
p40586
aS'                    const std::string & secondary = "")'
p40587
aS'    {'
p40588
aS'      const auto header_size   = header.size();'
p40589
aS"      const auto padded_header = std::string((34 - header_size) / 2, ' ') +"
p40590
aS'                                 header +'
p40591
aS"                                 std::string((35 - header_size) / 2, ' ');"
p40592
aS'      const auto secondary_size = secondary.size();'
p40593
aS'      const auto padded_secondary ='
p40594
aS"        std::string((34 - secondary_size) / 2, ' ') + secondary +"
p40595
aS"        std::string((35 - secondary_size) / 2, ' ');"
p40596
aS'      pcout << std::endl;'
p40597
aS'      pcout << "    ####################################################" << std::endl;'
p40598
aS'      pcout << "    #########                                  #########" << std::endl;'
p40599
aS'      pcout << "    #########"     <<  padded_header   <<     "#########" << std::endl;'
p40600
aS'      pcout << "    #########"     << padded_secondary <<     "#########" << std::endl;'
p40601
aS'      pcout << "    #########                                  #########" << std::endl;'
p40602
aS'      pcout << "    ####################################################" << std::endl;'
p40603
aS'      pcout << std::endl;'
p40604
aS'    }'
p40605
aS'  } // namespace'
p40606
aS'  template <int dim>'
p40607
aS'  void MainLoop<dim>::run()'
p40608
aS'  {'
p40609
aS'    pcout << "Reading parameters and allocating objects... " << std::flush;'
p40610
aS'    ParameterAcceptor::initialize("step-69.prm");'
p40611
aS'    pcout << "done" << std::endl;'
p40612
aS'    {'
p40613
aS'      print_head(pcout, "create triangulation");'
p40614
aS'      discretization.setup();'
p40615
aS'      pcout << "Number of active cells:       "'
p40616
aS'            << discretization.triangulation.n_global_active_cells()'
p40617
aS'            << std::endl;'
p40618
aS'      print_head(pcout, "compute offline data");'
p40619
aS'      offline_data.setup();'
p40620
aS'      offline_data.assemble();'
p40621
aS'      pcout << "Number of degrees of freedom: "'
p40622
aS'            << offline_data.dof_handler.n_dofs() << std::endl;'
p40623
aS'      print_head(pcout, "set up time step");'
p40624
aS'      time_stepping.prepare();'
p40625
aS'      schlieren_postprocessor.prepare();'
p40626
aS'    }'
p40627
aS'    double       t            = 0.;'
p40628
aS'    unsigned int output_cycle = 0;'
p40629
aS'    print_head(pcout, "interpolate initial values");'
p40630
aS'    vector_type U = interpolate_initial_values();'
p40631
aS'    if (resume)'
p40632
aS'      {'
p40633
aS'        print_head(pcout, "restore interrupted computation");'
p40634
aS'        const unsigned int i ='
p40635
aS'          discretization.triangulation.locally_owned_subdomain();'
p40636
aS'        const std::string name = base_name + "-checkpoint-" +'
p40637
aS'                                 Utilities::int_to_string(i, 4) + ".archive";'
p40638
aS'        std::ifstream file(name, std::ios::binary);'
p40639
aS'        boost::archive::binary_iarchive ia(file);'
p40640
aS'        ia >> t >> output_cycle;'
p40641
aS'        for (auto &it1 : U)'
p40642
aS'          {'
p40643
aS'            for (auto &it2 : it1)'
p40644
aS'              ia >> it2;'
p40645
aS'            it1.update_ghost_values();'
p40646
aS'          }'
p40647
aS'      }'
p40648
aS'    output(U, base_name, t, output_cycle++);'
p40649
aS'    print_head(pcout, "enter main loop");'
p40650
aS'    for (unsigned int cycle = 1; t < t_final; ++cycle)'
p40651
aS'      {'
p40652
aS'        std::ostringstream head;'
p40653
aS'        std::ostringstream secondary;'
p40654
aS'        head << "Cycle  " << Utilities::int_to_string(cycle, 6) << "  (" //'
p40655
aS'             << std::fixed << std::setprecision(1) << t / t_final * 100  //'
p40656
aS'             << "%)";'
p40657
aS'        secondary << "at time t = " << std::setprecision(8) << std::fixed << t;'
p40658
aS'        print_head(pcout, head.str(), secondary.str());'
p40659
aS'        t += time_stepping.make_one_step(U, t);'
p40660
aS'        if (t > output_cycle * output_granularity)'
p40661
aS'          {'
p40662
aS'            output(U, base_name, t, output_cycle, true);'
p40663
aS'            ++output_cycle;'
p40664
aS'          }'
p40665
aS'      }'
p40666
aS'    if (background_thread_state.valid())'
p40667
aS'      background_thread_state.wait();'
p40668
aS'    computing_timer.print_summary();'
p40669
aS'    pcout << timer_output.str() << std::endl;'
p40670
aS'  }'
p40671
aS'  template <int dim>'
p40672
aS'  typename MainLoop<dim>::vector_type'
p40673
aS'  MainLoop<dim>::interpolate_initial_values(const double t)'
p40674
aS'  {'
p40675
aS'    pcout << "MainLoop<dim>::interpolate_initial_values(t = " << t << ")"'
p40676
aS'          << std::endl;'
p40677
aS'    TimerOutput::Scope scope(computing_timer,'
p40678
aS'                             "main_loop - setup scratch space");'
p40679
aS'    vector_type U;'
p40680
aS'    for (auto &it : U)'
p40681
aS'      it.reinit(offline_data.partitioner);'
p40682
aS'    constexpr auto problem_dimension ='
p40683
aS'      ProblemDescription<dim>::problem_dimension;'
p40684
aS'    for (unsigned int i = 0; i < problem_dimension; ++i)'
p40685
aS'      VectorTools::interpolate(offline_data.dof_handler,'
p40686
aS'                               ScalarFunctionFromFunctionObject<dim, double>('
p40687
aS'                                 [&](const Point<dim> &x) {'
p40688
aS'                                   return initial_values.initial_state(x, t)[i];'
p40689
aS'                                 }),'
p40690
aS'                               U[i]);'
p40691
aS'    for (auto &it : U)'
p40692
aS'      it.update_ghost_values();'
p40693
aS'    return U;'
p40694
aS'  }'
p40695
aS'  template <int dim>'
p40696
aS'  void MainLoop<dim>::output(const typename MainLoop<dim>::vector_type &U,'
p40697
aS'                             const std::string &                        name,'
p40698
aS'                             const double                               t,'
p40699
aS'                             const unsigned int                         cycle,'
p40700
aS'                             const bool checkpoint)'
p40701
aS'  {'
p40702
aS'    pcout << "MainLoop<dim>::output(t = " << t'
p40703
aS'          << ", checkpoint = " << checkpoint << ")" << std::endl;'
p40704
aS'    if (background_thread_state.valid())'
p40705
aS'      {'
p40706
aS'        TimerOutput::Scope timer(computing_timer, "main_loop - stalled output");'
p40707
aS'        background_thread_state.wait();'
p40708
aS'      }'
p40709
aS'    constexpr auto problem_dimension ='
p40710
aS'      ProblemDescription<dim>::problem_dimension;'
p40711
aS'    for (unsigned int i = 0; i < problem_dimension; ++i)'
p40712
aS'      {'
p40713
aS'        output_vector[i] = U[i];'
p40714
aS'        output_vector[i].update_ghost_values();'
p40715
aS'      }'
p40716
aS'    schlieren_postprocessor.compute_schlieren(output_vector);'
p40717
aS'    auto data_out = std::make_shared<DataOut<dim>>();'
p40718
aS'    data_out->attach_dof_handler(offline_data.dof_handler);'
p40719
aS'    const auto &component_names = ProblemDescription<dim>::component_names;'
p40720
aS'    for (unsigned int i = 0; i < problem_dimension; ++i)'
p40721
aS'      data_out->add_data_vector(output_vector[i], component_names[i]);'
p40722
aS'    data_out->add_data_vector(schlieren_postprocessor.schlieren,'
p40723
aS'                              "schlieren_plot");'
p40724
aS'    data_out->build_patches(discretization.mapping,'
p40725
aS'                            discretization.finite_element.degree - 1);'
p40726
aS'    const auto output_worker = [this, name, t, cycle, checkpoint, data_out]() {'
p40727
aS'      if (checkpoint)'
p40728
aS'        {'
p40729
aS'          const unsigned int i ='
p40730
aS'            discretization.triangulation.locally_owned_subdomain();'
p40731
aS'          std::string filename ='
p40732
aS'            name + "-checkpoint-" + Utilities::int_to_string(i, 4) + ".archive";'
p40733
aS'          std::ofstream file(filename, std::ios::binary | std::ios::trunc);'
p40734
aS'          boost::archive::binary_oarchive oa(file);'
p40735
aS'          oa << t << cycle;'
p40736
aS'          for (const auto &it1 : output_vector)'
p40737
aS'            for (const auto &it2 : it1)'
p40738
aS'              oa << it2;'
p40739
aS'        }'
p40740
aS'      DataOutBase::VtkFlags flags(t,'
p40741
aS'                                  cycle,'
p40742
aS'                                  true,'
p40743
aS'                                  DataOutBase::VtkFlags::best_speed);'
p40744
aS'      data_out->set_flags(flags);'
p40745
aS'      data_out->write_vtu_with_pvtu_record('
p40746
aS'        "", name + "-solution", cycle, mpi_communicator, 6);'
p40747
aS'    };'
p40748
aS'    if (asynchronous_writeback)'
p40749
aS'      {'
p40750
aS'        background_thread_state = std::async(std::launch::async, output_worker);'
p40751
aS'      }'
p40752
aS'    else'
p40753
aS'      {'
p40754
aS'        output_worker();'
p40755
aS'      }'
p40756
aS'  }'
p40757
aS'} // namespace Step69'
p40758
aS'int main(int argc, char *argv[])'
p40759
ag24
aS'  try'
p40760
aS'    {'
p40761
aS'      constexpr int dim = 2;'
p40762
aS'      using namespace dealii;'
p40763
aS'      using namespace Step69;'
p40764
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);'
p40765
aS'      MPI_Comm      mpi_communicator(MPI_COMM_WORLD);'
p40766
aS'      MainLoop<dim> main_loop(mpi_communicator);'
p40767
aS'      main_loop.run();'
p40768
aS'    }'
p40769
aS'  catch (std::exception &exc)'
p40770
aS'    {'
p40771
aS'      std::cerr << std::endl'
p40772
aS'                << std::endl'
p40773
aS'                << "----------------------------------------------------"'
p40774
aS'                << std::endl;'
p40775
aS'      std::cerr << "Exception on processing: " << std::endl'
p40776
aS'                << exc.what() << std::endl'
p40777
aS'                << "Aborting!" << std::endl'
p40778
aS'                << "----------------------------------------------------"'
p40779
aS'                << std::endl;'
p40780
aS'      return 1;'
p40781
aS'    }'
p40782
aS'  catch (...)'
p40783
aS'    {'
p40784
aS'      std::cerr << std::endl'
p40785
aS'                << std::endl'
p40786
aS'                << "----------------------------------------------------"'
p40787
aS'                << std::endl;'
p40788
aS'      std::cerr << "Unknown exception!" << std::endl'
p40789
aS'                << "Aborting!" << std::endl'
p40790
aS'                << "----------------------------------------------------"'
p40791
aS'                << std::endl;'
p40792
aS'      return 1;'
p40793
aS'    };'
p40794
ag32
aS'/* ---------------------------------------------------------------------'
p40795
aS' *'
p40796
aS' * Copyright (C) 2000 - 2021 by the deal.II authors'
p40797
aS' *'
p40798
aS' * This file is part of the deal.II library.'
p40799
aS' *'
p40800
aS' * The deal.II library is free software; you can use it, redistribute'
p40801
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p40802
aS' * Public License as published by the Free Software Foundation; either'
p40803
aS' * version 2.1 of the License, or (at your option) any later version.'
p40804
aS' * The full text of the license can be found in the file LICENSE.md at'
p40805
aS' * the top level directory of deal.II.'
p40806
aS' *'
p40807
aS' * ---------------------------------------------------------------------'
p40808
aS' *'
p40809
aS' * Author: Wolfgang Bangerth and Ralf Hartmann, University of Heidelberg, 2000'
p40810
aS' */'
p40811
aS'#include <deal.II/base/quadrature_lib.h>'
p40812
aS'#include <deal.II/base/function.h>'
p40813
aS'#include <deal.II/base/logstream.h>'
p40814
aS'#include <deal.II/lac/vector.h>'
p40815
aS'#include <deal.II/lac/full_matrix.h>'
p40816
aS'#include <deal.II/lac/sparse_matrix.h>'
p40817
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p40818
aS'#include <deal.II/lac/solver_cg.h>'
p40819
aS'#include <deal.II/lac/precondition.h>'
p40820
aS'#include <deal.II/lac/affine_constraints.h>'
p40821
aS'#include <deal.II/grid/tria.h>'
p40822
aS'#include <deal.II/grid/grid_generator.h>'
p40823
aS'#include <deal.II/grid/grid_refinement.h>'
p40824
aS'#include <deal.II/dofs/dof_handler.h>'
p40825
aS'#include <deal.II/dofs/dof_tools.h>'
p40826
aS'#include <deal.II/fe/fe_q.h>'
p40827
aS'#include <deal.II/numerics/matrix_tools.h>'
p40828
aS'#include <deal.II/numerics/error_estimator.h>'
p40829
aS'#include <deal.II/numerics/data_out.h>'
p40830
aS'#include <deal.II/dofs/dof_renumbering.h>'
p40831
aS'#include <deal.II/base/smartpointer.h>'
p40832
aS'#include <deal.II/numerics/vector_tools.h>'
p40833
aS'#include <deal.II/base/convergence_table.h>'
p40834
aS'#include <deal.II/fe/fe_values.h>'
p40835
aS'#include <array>'
p40836
aS'#include <fstream>'
p40837
aS'#include <iostream>'
p40838
aS'namespace Step7'
p40839
ag24
aS'  using namespace dealii;'
p40840
aS'  template <int dim>'
p40841
aS'  class SolutionBase'
p40842
aS'  {'
p40843
aS'  protected:'
p40844
aS'    static const std::array<Point<dim>, 3> source_centers;'
p40845
aS'    static const double                    width;'
p40846
aS'  };'
p40847
aS'  template <>'
p40848
aS'  const std::array<Point<1>, 3> SolutionBase<1>::source_centers = {'
p40849
aS'    {Point<1>(-1.0 / 3.0), Point<1>(0.0), Point<1>(+1.0 / 3.0)}};'
p40850
aS'  template <>'
p40851
aS'  const std::array<Point<2>, 3> SolutionBase<2>::source_centers = {'
p40852
aS'    {Point<2>(-0.5, +0.5), Point<2>(-0.5, -0.5), Point<2>(+0.5, -0.5)}};'
p40853
aS'  template <int dim>'
p40854
aS'  const double SolutionBase<dim>::width = 1. / 8.;'
p40855
aS'  template <int dim>'
p40856
aS'  class Solution : public Function<dim>, protected SolutionBase<dim>'
p40857
aS'  {'
p40858
aS'  public:'
p40859
aS'    virtual double value(const Point<dim> & p,'
p40860
aS'                         const unsigned int component = 0) const override;'
p40861
aS'    virtual Tensor<1, dim>'
p40862
aS'    gradient(const Point<dim> & p,'
p40863
aS'             const unsigned int component = 0) const override;'
p40864
aS'  };'
p40865
aS'  template <int dim>'
p40866
aS'  double Solution<dim>::value(const Point<dim> &p, const unsigned int) const'
p40867
aS'  {'
p40868
aS'    double return_value = 0;'
p40869
aS'    for (const auto &center : this->source_centers)'
p40870
aS'      {'
p40871
aS'        const Tensor<1, dim> x_minus_xi = p - center;'
p40872
aS'        return_value +='
p40873
aS'          std::exp(-x_minus_xi.norm_square() / (this->width * this->width));'
p40874
aS'      }'
p40875
aS'    return return_value;'
p40876
aS'  }'
p40877
aS'  template <int dim>'
p40878
aS'  Tensor<1, dim> Solution<dim>::gradient(const Point<dim> &p,'
p40879
aS'                                         const unsigned int) const'
p40880
aS'  {'
p40881
aS'    Tensor<1, dim> return_value;'
p40882
aS'    for (const auto &center : this->source_centers)'
p40883
aS'      {'
p40884
aS'        const Tensor<1, dim> x_minus_xi = p - center;'
p40885
aS'        return_value +='
p40886
aS'          (-2. / (this->width * this->width) *'
p40887
aS'           std::exp(-x_minus_xi.norm_square() / (this->width * this->width)) *'
p40888
aS'           x_minus_xi);'
p40889
aS'      }'
p40890
aS'    return return_value;'
p40891
aS'  }'
p40892
aS'  template <int dim>'
p40893
aS'  class RightHandSide : public Function<dim>, protected SolutionBase<dim>'
p40894
aS'  {'
p40895
aS'  public:'
p40896
aS'    virtual double value(const Point<dim> & p,'
p40897
aS'                         const unsigned int component = 0) const override;'
p40898
aS'  };'
p40899
aS'  template <int dim>'
p40900
aS'  double RightHandSide<dim>::value(const Point<dim> &p,'
p40901
aS'                                   const unsigned int) const'
p40902
aS'  {'
p40903
aS'    double return_value = 0;'
p40904
aS'    for (const auto &center : this->source_centers)'
p40905
aS'      {'
p40906
aS'        const Tensor<1, dim> x_minus_xi = p - center;'
p40907
aS'        return_value +='
p40908
aS'          ((2. * dim -'
p40909
aS'            4. * x_minus_xi.norm_square() / (this->width * this->width)) /'
p40910
aS'           (this->width * this->width) *'
p40911
aS'           std::exp(-x_minus_xi.norm_square() / (this->width * this->width)));'
p40912
aS'        return_value +='
p40913
aS'          std::exp(-x_minus_xi.norm_square() / (this->width * this->width));'
p40914
aS'      }'
p40915
aS'    return return_value;'
p40916
aS'  }'
p40917
aS'  template <int dim>'
p40918
aS'  class HelmholtzProblem'
p40919
aS'  {'
p40920
aS'  public:'
p40921
aS'    enum RefinementMode'
p40922
aS'    {'
p40923
aS'      global_refinement,'
p40924
aS'      adaptive_refinement'
p40925
aS'    };'
p40926
aS'    HelmholtzProblem(const FiniteElement<dim> &fe,'
p40927
aS'                     const RefinementMode      refinement_mode);'
p40928
aS'    void run();'
p40929
aS'  private:'
p40930
aS'    void setup_system();'
p40931
aS'    void assemble_system();'
p40932
aS'    void solve();'
p40933
aS'    void refine_grid();'
p40934
aS'    void process_solution(const unsigned int cycle);'
p40935
aS'    Triangulation<dim> triangulation;'
p40936
aS'    DoFHandler<dim>    dof_handler;'
p40937
aS'    SmartPointer<const FiniteElement<dim>> fe;'
p40938
aS'    AffineConstraints<double> hanging_node_constraints;'
p40939
aS'    SparsityPattern      sparsity_pattern;'
p40940
aS'    SparseMatrix<double> system_matrix;'
p40941
aS'    Vector<double> solution;'
p40942
aS'    Vector<double> system_rhs;'
p40943
aS'    const RefinementMode refinement_mode;'
p40944
aS'    ConvergenceTable convergence_table;'
p40945
aS'  };'
p40946
aS'  template <int dim>'
p40947
aS'  HelmholtzProblem<dim>::HelmholtzProblem(const FiniteElement<dim> &fe,'
p40948
aS'                                          const RefinementMode refinement_mode)'
p40949
aS'    : dof_handler(triangulation)'
p40950
aS'    , fe(&fe)'
p40951
aS'    , refinement_mode(refinement_mode)'
p40952
aS'  {}'
p40953
aS'  template <int dim>'
p40954
aS'  void HelmholtzProblem<dim>::setup_system()'
p40955
aS'  {'
p40956
aS'    dof_handler.distribute_dofs(*fe);'
p40957
aS'    DoFRenumbering::Cuthill_McKee(dof_handler);'
p40958
aS'    hanging_node_constraints.clear();'
p40959
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p40960
aS'                                            hanging_node_constraints);'
p40961
aS'    hanging_node_constraints.close();'
p40962
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p40963
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p40964
aS'    hanging_node_constraints.condense(dsp);'
p40965
aS'    sparsity_pattern.copy_from(dsp);'
p40966
aS'    system_matrix.reinit(sparsity_pattern);'
p40967
aS'    solution.reinit(dof_handler.n_dofs());'
p40968
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p40969
aS'  }'
p40970
aS'  template <int dim>'
p40971
aS'  void HelmholtzProblem<dim>::assemble_system()'
p40972
aS'  {'
p40973
aS'    QGauss<dim>     quadrature_formula(fe->degree + 1);'
p40974
aS'    QGauss<dim - 1> face_quadrature_formula(fe->degree + 1);'
p40975
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p40976
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p40977
aS'    const unsigned int dofs_per_cell = fe->n_dofs_per_cell();'
p40978
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p40979
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p40980
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p40981
aS'    FEValues<dim> fe_values(*fe,'
p40982
aS'                            quadrature_formula,'
p40983
aS'                            update_values | update_gradients |'
p40984
aS'                              update_quadrature_points | update_JxW_values);'
p40985
aS'    FEFaceValues<dim> fe_face_values(*fe,'
p40986
aS'                                     face_quadrature_formula,'
p40987
aS'                                     update_values | update_quadrature_points |'
p40988
aS'                                       update_normal_vectors |'
p40989
aS'                                       update_JxW_values);'
p40990
aS'    const RightHandSide<dim> right_hand_side;'
p40991
aS'    std::vector<double>      rhs_values(n_q_points);'
p40992
aS'    Solution<dim> exact_solution;'
p40993
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p40994
aS'      {'
p40995
aS'        cell_matrix = 0.;'
p40996
aS'        cell_rhs    = 0.;'
p40997
aS'        fe_values.reinit(cell);'
p40998
aS'        right_hand_side.value_list(fe_values.get_quadrature_points(),'
p40999
aS'                                   rhs_values);'
p41000
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p41001
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p41002
aS'            {'
p41003
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p41004
aS'                cell_matrix(i, j) +='
p41005
aS'                  ((fe_values.shape_grad(i, q_point) *     // grad phi_i(x_q)'
p41006
aS'                      fe_values.shape_grad(j, q_point)     // grad phi_j(x_q)'
p41007
aS'                    +                                      //'
p41008
aS'                    fe_values.shape_value(i, q_point) *    // phi_i(x_q)'
p41009
aS'                      fe_values.shape_value(j, q_point)) * // phi_j(x_q)'
p41010
aS'                   fe_values.JxW(q_point));                // dx'
p41011
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)'
p41012
aS'                              rhs_values[q_point] *               // f(x_q)'
p41013
aS'                              fe_values.JxW(q_point));            // dx'
p41014
aS'            }'
p41015
aS'        for (const auto &face : cell->face_iterators())'
p41016
aS'          if (face->at_boundary() && (face->boundary_id() == 1))'
p41017
aS'            {'
p41018
aS'              fe_face_values.reinit(cell, face);'
p41019
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p41020
aS'                   ++q_point)'
p41021
aS'                {'
p41022
aS'                  const double neumann_value ='
p41023
aS'                    (exact_solution.gradient('
p41024
aS'                       fe_face_values.quadrature_point(q_point)) *'
p41025
aS'                     fe_face_values.normal_vector(q_point));'
p41026
aS'                  for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p41027
aS'                    cell_rhs(i) +='
p41028
aS'                      (fe_face_values.shape_value(i, q_point) * // phi_i(x_q)'
p41029
aS'                       neumann_value *                          // g(x_q)'
p41030
aS'                       fe_face_values.JxW(q_point));            // dx'
p41031
aS'                }'
p41032
aS'            }'
p41033
aS'        cell->get_dof_indices(local_dof_indices);'
p41034
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p41035
aS'          {'
p41036
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p41037
aS'              system_matrix.add(local_dof_indices[i],'
p41038
aS'                                local_dof_indices[j],'
p41039
aS'                                cell_matrix(i, j));'
p41040
aS'            system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p41041
aS'          }'
p41042
aS'      }'
p41043
aS'    hanging_node_constraints.condense(system_matrix);'
p41044
aS'    hanging_node_constraints.condense(system_rhs);'
p41045
aS'    std::map<types::global_dof_index, double> boundary_values;'
p41046
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p41047
aS'                                             0,'
p41048
aS'                                             Solution<dim>(),'
p41049
aS'                                             boundary_values);'
p41050
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p41051
aS'                                       system_matrix,'
p41052
aS'                                       solution,'
p41053
aS'                                       system_rhs);'
p41054
aS'  }'
p41055
aS'  template <int dim>'
p41056
aS'  void HelmholtzProblem<dim>::solve()'
p41057
aS'  {'
p41058
aS'    SolverControl            solver_control(1000, 1e-12);'
p41059
aS'    SolverCG<Vector<double>> cg(solver_control);'
p41060
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p41061
aS'    preconditioner.initialize(system_matrix, 1.2);'
p41062
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p41063
aS'    hanging_node_constraints.distribute(solution);'
p41064
aS'  }'
p41065
aS'  template <int dim>'
p41066
aS'  void HelmholtzProblem<dim>::refine_grid()'
p41067
aS'  {'
p41068
aS'    switch (refinement_mode)'
p41069
aS'      {'
p41070
aS'        case global_refinement:'
p41071
aS'          {'
p41072
aS'            triangulation.refine_global(1);'
p41073
aS'            break;'
p41074
aS'          }'
p41075
aS'        case adaptive_refinement:'
p41076
aS'          {'
p41077
aS'            Vector<float> estimated_error_per_cell('
p41078
aS'              triangulation.n_active_cells());'
p41079
aS'            KellyErrorEstimator<dim>::estimate('
p41080
aS'              dof_handler,'
p41081
aS'              QGauss<dim - 1>(fe->degree + 1),'
p41082
aS'              std::map<types::boundary_id, const Function<dim> *>(),'
p41083
aS'              solution,'
p41084
aS'              estimated_error_per_cell);'
p41085
aS'            GridRefinement::refine_and_coarsen_fixed_number('
p41086
aS'              triangulation, estimated_error_per_cell, 0.3, 0.03);'
p41087
aS'            triangulation.execute_coarsening_and_refinement();'
p41088
aS'            break;'
p41089
aS'          }'
p41090
aS'        default:'
p41091
aS'          {'
p41092
aS'            Assert(false, ExcNotImplemented());'
p41093
aS'          }'
p41094
aS'      }'
p41095
aS'  }'
p41096
aS'  template <int dim>'
p41097
aS'  void HelmholtzProblem<dim>::process_solution(const unsigned int cycle)'
p41098
aS'  {'
p41099
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p41100
aS'    VectorTools::integrate_difference(dof_handler,'
p41101
aS'                                      solution,'
p41102
aS'                                      Solution<dim>(),'
p41103
aS'                                      difference_per_cell,'
p41104
aS'                                      QGauss<dim>(fe->degree + 1),'
p41105
aS'                                      VectorTools::L2_norm);'
p41106
aS'    const double L2_error ='
p41107
aS'      VectorTools::compute_global_error(triangulation,'
p41108
aS'                                        difference_per_cell,'
p41109
aS'                                        VectorTools::L2_norm);'
p41110
aS'    VectorTools::integrate_difference(dof_handler,'
p41111
aS'                                      solution,'
p41112
aS'                                      Solution<dim>(),'
p41113
aS'                                      difference_per_cell,'
p41114
aS'                                      QGauss<dim>(fe->degree + 1),'
p41115
aS'                                      VectorTools::H1_seminorm);'
p41116
aS'    const double H1_error ='
p41117
aS'      VectorTools::compute_global_error(triangulation,'
p41118
aS'                                        difference_per_cell,'
p41119
aS'                                        VectorTools::H1_seminorm);'
p41120
aS'    const QTrapezoid<1>  q_trapez;'
p41121
aS'    const QIterated<dim> q_iterated(q_trapez, fe->degree * 2 + 1);'
p41122
aS'    VectorTools::integrate_difference(dof_handler,'
p41123
aS'                                      solution,'
p41124
aS'                                      Solution<dim>(),'
p41125
aS'                                      difference_per_cell,'
p41126
aS'                                      q_iterated,'
p41127
aS'                                      VectorTools::Linfty_norm);'
p41128
aS'    const double Linfty_error ='
p41129
aS'      VectorTools::compute_global_error(triangulation,'
p41130
aS'                                        difference_per_cell,'
p41131
aS'                                        VectorTools::Linfty_norm);'
p41132
aS'    const unsigned int n_active_cells = triangulation.n_active_cells();'
p41133
aS'    const unsigned int n_dofs         = dof_handler.n_dofs();'
p41134
aS'    std::cout << "Cycle " << cycle << \':\' << std::endl'
p41135
aS'              << "   Number of active cells:       " << n_active_cells'
p41136
aS'              << std::endl'
p41137
aS'              << "   Number of degrees of freedom: " << n_dofs << std::endl;'
p41138
aS'    convergence_table.add_value("cycle", cycle);'
p41139
aS'    convergence_table.add_value("cells", n_active_cells);'
p41140
aS'    convergence_table.add_value("dofs", n_dofs);'
p41141
aS'    convergence_table.add_value("L2", L2_error);'
p41142
aS'    convergence_table.add_value("H1", H1_error);'
p41143
aS'    convergence_table.add_value("Linfty", Linfty_error);'
p41144
aS'  }'
p41145
aS'  template <int dim>'
p41146
aS'  void HelmholtzProblem<dim>::run()'
p41147
aS'  {'
p41148
aS'    const unsigned int n_cycles ='
p41149
aS'      (refinement_mode == global_refinement) ? 5 : 9;'
p41150
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p41151
aS'      {'
p41152
aS'        if (cycle == 0)'
p41153
aS'          {'
p41154
aS'            GridGenerator::hyper_cube(triangulation, -1., 1.);'
p41155
aS'            triangulation.refine_global(3);'
p41156
aS'            for (const auto &cell : triangulation.cell_iterators())'
p41157
aS'              for (const auto &face : cell->face_iterators())'
p41158
aS'                {'
p41159
aS'                  const auto center = face->center();'
p41160
aS'                  if ((std::fabs(center(0) - (-1.0)) < 1e-12) ||'
p41161
aS'                      (std::fabs(center(1) - (-1.0)) < 1e-12))'
p41162
aS'                    face->set_boundary_id(1);'
p41163
aS'                }'
p41164
aS'          }'
p41165
aS'        else'
p41166
aS'          refine_grid();'
p41167
aS'        setup_system();'
p41168
aS'        assemble_system();'
p41169
aS'        solve();'
p41170
aS'        process_solution(cycle);'
p41171
aS'      }'
p41172
aS'    std::string vtk_filename;'
p41173
aS'    switch (refinement_mode)'
p41174
aS'      {'
p41175
aS'        case global_refinement:'
p41176
aS'          vtk_filename = "solution-global";'
p41177
aS'          break;'
p41178
aS'        case adaptive_refinement:'
p41179
aS'          vtk_filename = "solution-adaptive";'
p41180
aS'          break;'
p41181
aS'        default:'
p41182
aS'          Assert(false, ExcNotImplemented());'
p41183
aS'      }'
p41184
aS'    switch (fe->degree)'
p41185
aS'      {'
p41186
aS'        case 1:'
p41187
aS'          vtk_filename += "-q1";'
p41188
aS'          break;'
p41189
aS'        case 2:'
p41190
aS'          vtk_filename += "-q2";'
p41191
aS'          break;'
p41192
aS'        default:'
p41193
aS'          Assert(false, ExcNotImplemented());'
p41194
aS'      }'
p41195
aS'    vtk_filename += ".vtk";'
p41196
aS'    std::ofstream output(vtk_filename);'
p41197
aS'    DataOut<dim> data_out;'
p41198
aS'    data_out.attach_dof_handler(dof_handler);'
p41199
aS'    data_out.add_data_vector(solution, "solution");'
p41200
aS'    data_out.build_patches(fe->degree);'
p41201
aS'    data_out.write_vtk(output);'
p41202
aS'    convergence_table.set_precision("L2", 3);'
p41203
aS'    convergence_table.set_precision("H1", 3);'
p41204
aS'    convergence_table.set_precision("Linfty", 3);'
p41205
aS'    convergence_table.set_scientific("L2", true);'
p41206
aS'    convergence_table.set_scientific("H1", true);'
p41207
aS'    convergence_table.set_scientific("Linfty", true);'
p41208
aS'    convergence_table.set_tex_caption("cells", "\\\\# cells");'
p41209
aS'    convergence_table.set_tex_caption("dofs", "\\\\# dofs");'
p41210
aS'    convergence_table.set_tex_caption("L2", "$L^2$-error");'
p41211
aS'    convergence_table.set_tex_caption("H1", "$H^1$-error");'
p41212
aS'    convergence_table.set_tex_caption("Linfty", "$L^\\\\infty$-error");'
p41213
aS'    convergence_table.set_tex_format("cells", "r");'
p41214
aS'    convergence_table.set_tex_format("dofs", "r");'
p41215
aS'    std::cout << std::endl;'
p41216
aS'    convergence_table.write_text(std::cout);'
p41217
aS'    std::string error_filename = "error";'
p41218
aS'    switch (refinement_mode)'
p41219
aS'      {'
p41220
aS'        case global_refinement:'
p41221
aS'          error_filename += "-global";'
p41222
aS'          break;'
p41223
aS'        case adaptive_refinement:'
p41224
aS'          error_filename += "-adaptive";'
p41225
aS'          break;'
p41226
aS'        default:'
p41227
aS'          Assert(false, ExcNotImplemented());'
p41228
aS'      }'
p41229
aS'    switch (fe->degree)'
p41230
aS'      {'
p41231
aS'        case 1:'
p41232
aS'          error_filename += "-q1";'
p41233
aS'          break;'
p41234
aS'        case 2:'
p41235
aS'          error_filename += "-q2";'
p41236
aS'          break;'
p41237
aS'        default:'
p41238
aS'          Assert(false, ExcNotImplemented());'
p41239
aS'      }'
p41240
aS'    error_filename += ".tex";'
p41241
aS'    std::ofstream error_table_file(error_filename);'
p41242
aS'    convergence_table.write_tex(error_table_file);'
p41243
aS'    if (refinement_mode == global_refinement)'
p41244
aS'      {'
p41245
aS'        convergence_table.add_column_to_supercolumn("cycle", "n cells");'
p41246
aS'        convergence_table.add_column_to_supercolumn("cells", "n cells");'
p41247
aS'        std::vector<std::string> new_order;'
p41248
aS'        new_order.emplace_back("n cells");'
p41249
aS'        new_order.emplace_back("H1");'
p41250
aS'        new_order.emplace_back("L2");'
p41251
aS'        convergence_table.set_column_order(new_order);'
p41252
aS'        convergence_table.evaluate_convergence_rates('
p41253
aS'          "L2", ConvergenceTable::reduction_rate);'
p41254
aS'        convergence_table.evaluate_convergence_rates('
p41255
aS'          "L2", ConvergenceTable::reduction_rate_log2);'
p41256
aS'        convergence_table.evaluate_convergence_rates('
p41257
aS'          "H1", ConvergenceTable::reduction_rate);'
p41258
aS'        convergence_table.evaluate_convergence_rates('
p41259
aS'          "H1", ConvergenceTable::reduction_rate_log2);'
p41260
aS'        std::cout << std::endl;'
p41261
aS'        convergence_table.write_text(std::cout);'
p41262
aS'        std::string conv_filename = "convergence";'
p41263
aS'        switch (refinement_mode)'
p41264
aS'          {'
p41265
aS'            case global_refinement:'
p41266
aS'              conv_filename += "-global";'
p41267
aS'              break;'
p41268
aS'            case adaptive_refinement:'
p41269
aS'              conv_filename += "-adaptive";'
p41270
aS'              break;'
p41271
aS'            default:'
p41272
aS'              Assert(false, ExcNotImplemented());'
p41273
aS'          }'
p41274
aS'        switch (fe->degree)'
p41275
aS'          {'
p41276
aS'            case 1:'
p41277
aS'              conv_filename += "-q1";'
p41278
aS'              break;'
p41279
aS'            case 2:'
p41280
aS'              conv_filename += "-q2";'
p41281
aS'              break;'
p41282
aS'            default:'
p41283
aS'              Assert(false, ExcNotImplemented());'
p41284
aS'          }'
p41285
aS'        conv_filename += ".tex";'
p41286
aS'        std::ofstream table_file(conv_filename);'
p41287
aS'        convergence_table.write_tex(table_file);'
p41288
aS'      }'
p41289
aS'  }'
p41290
aS'} // namespace Step7'
p41291
aS'int main()'
p41292
ag24
aS'  const unsigned int dim = 2;'
p41293
aS'  try'
p41294
aS'    {'
p41295
aS'      using namespace dealii;'
p41296
aS'      using namespace Step7;'
p41297
aS'      {'
p41298
aS'        std::cout << "Solving with Q1 elements, adaptive refinement"'
p41299
aS'                  << std::endl'
p41300
aS'                  << "============================================="'
p41301
aS'                  << std::endl'
p41302
aS'                  << std::endl;'
p41303
aS'        FE_Q<dim>             fe(1);'
p41304
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p41305
aS'          fe, HelmholtzProblem<dim>::adaptive_refinement);'
p41306
aS'        helmholtz_problem_2d.run();'
p41307
aS'        std::cout << std::endl;'
p41308
aS'      }'
p41309
aS'      {'
p41310
aS'        std::cout << "Solving with Q1 elements, global refinement" << std::endl'
p41311
aS'                  << "===========================================" << std::endl'
p41312
aS'                  << std::endl;'
p41313
aS'        FE_Q<dim>             fe(1);'
p41314
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p41315
aS'          fe, HelmholtzProblem<dim>::global_refinement);'
p41316
aS'        helmholtz_problem_2d.run();'
p41317
aS'        std::cout << std::endl;'
p41318
aS'      }'
p41319
aS'      {'
p41320
aS'        std::cout << "Solving with Q2 elements, global refinement" << std::endl'
p41321
aS'                  << "===========================================" << std::endl'
p41322
aS'                  << std::endl;'
p41323
aS'        FE_Q<dim>             fe(2);'
p41324
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p41325
aS'          fe, HelmholtzProblem<dim>::global_refinement);'
p41326
aS'        helmholtz_problem_2d.run();'
p41327
aS'        std::cout << std::endl;'
p41328
aS'      }'
p41329
aS'      {'
p41330
aS'        std::cout << "Solving with Q2 elements, adaptive refinement"'
p41331
aS'                  << std::endl'
p41332
aS'                  << "===========================================" << std::endl'
p41333
aS'                  << std::endl;'
p41334
aS'        FE_Q<dim>             fe(2);'
p41335
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p41336
aS'          fe, HelmholtzProblem<dim>::adaptive_refinement);'
p41337
aS'        helmholtz_problem_2d.run();'
p41338
aS'        std::cout << std::endl;'
p41339
aS'      }'
p41340
aS'    }'
p41341
aS'  catch (std::exception &exc)'
p41342
aS'    {'
p41343
aS'      std::cerr << std::endl'
p41344
aS'                << std::endl'
p41345
aS'                << "----------------------------------------------------"'
p41346
aS'                << std::endl;'
p41347
aS'      std::cerr << "Exception on processing: " << std::endl'
p41348
aS'                << exc.what() << std::endl'
p41349
aS'                << "Aborting!" << std::endl'
p41350
aS'                << "----------------------------------------------------"'
p41351
aS'                << std::endl;'
p41352
aS'      return 1;'
p41353
aS'    }'
p41354
aS'  catch (...)'
p41355
aS'    {'
p41356
aS'      std::cerr << std::endl'
p41357
aS'                << std::endl'
p41358
aS'                << "----------------------------------------------------"'
p41359
aS'                << std::endl;'
p41360
aS'      std::cerr << "Unknown exception!" << std::endl'
p41361
aS'                << "Aborting!" << std::endl'
p41362
aS'                << "----------------------------------------------------"'
p41363
aS'                << std::endl;'
p41364
aS'      return 1;'
p41365
aS'    }'
p41366
aS'  return 0;'
p41367
ag32
aS'/* ---------------------------------------------------------------------'
p41368
aS' *'
p41369
aS' * Copyright (C) 2020 - 2021 by the deal.II authors'
p41370
aS' *'
p41371
aS' * This file is part of the deal.II library.'
p41372
aS' *'
p41373
aS' * The deal.II library is free software; you can use it, redistribute'
p41374
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p41375
aS' * Public License as published by the Free Software Foundation; either'
p41376
aS' * version 2.1 of the License, or (at your option) any later version.'
p41377
aS' * The full text of the license can be found in the file LICENSE.md at'
p41378
aS' * the top level directory of deal.II.'
p41379
aS' *'
p41380
aS' * ---------------------------------------------------------------------'
p41381
aS' *'
p41382
aS' * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020'
p41383
aS' */'
p41384
aS'#include <deal.II/base/function.h>'
p41385
aS'#include <deal.II/base/quadrature_lib.h>'
p41386
aS'#include <deal.II/base/timer.h>'
p41387
aS'#include <deal.II/lac/block_linear_operator.h>'
p41388
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p41389
aS'#include <deal.II/lac/linear_operator.h>'
p41390
aS'#include <deal.II/lac/linear_operator_tools.h>'
p41391
aS'#define FORCE_USE_OF_TRILINOS'
p41392
aS'namespace LA'
p41393
ag24
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p41394
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p41395
aS'  using namespace dealii::LinearAlgebraPETSc;'
p41396
aS'#  define USE_PETSC_LA'
p41397
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p41398
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p41399
aS'#else'
p41400
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p41401
aS'#endif'
p41402
aS'} // namespace LA'
p41403
aS'#include <deal.II/base/conditional_ostream.h>'
p41404
aS'#include <deal.II/base/index_set.h>'
p41405
aS'#include <deal.II/base/parameter_acceptor.h>'
p41406
aS'#include <deal.II/base/parsed_function.h>'
p41407
aS'#include <deal.II/base/utilities.h>'
p41408
aS'#include <deal.II/distributed/grid_refinement.h>'
p41409
aS'#include <deal.II/distributed/solution_transfer.h>'
p41410
aS'#include <deal.II/distributed/tria.h>'
p41411
aS'#include <deal.II/dofs/dof_handler.h>'
p41412
aS'#include <deal.II/dofs/dof_renumbering.h>'
p41413
aS'#include <deal.II/dofs/dof_tools.h>'
p41414
aS'#include <deal.II/fe/fe_nothing.h>'
p41415
aS'#include <deal.II/fe/fe_q.h>'
p41416
aS'#include <deal.II/fe/fe_system.h>'
p41417
aS'#include <deal.II/fe/fe_values.h>'
p41418
aS'#include <deal.II/fe/mapping_fe_field.h>'
p41419
aS'#include <deal.II/fe/mapping_q.h>'
p41420
aS'#include <deal.II/grid/grid_generator.h>'
p41421
aS'#include <deal.II/grid/grid_in.h>'
p41422
aS'#include <deal.II/grid/grid_tools.h>'
p41423
aS'#include <deal.II/grid/manifold_lib.h>'
p41424
aS'#include <deal.II/lac/affine_constraints.h>'
p41425
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p41426
aS'#include <deal.II/lac/full_matrix.h>'
p41427
aS'#include <deal.II/lac/petsc_precondition.h>'
p41428
aS'#include <deal.II/lac/petsc_solver.h>'
p41429
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p41430
aS'#include <deal.II/lac/petsc_vector.h>'
p41431
aS'#include <deal.II/lac/solver_cg.h>'
p41432
aS'#include <deal.II/lac/solver_gmres.h>'
p41433
aS'#include <deal.II/lac/solver_minres.h>'
p41434
aS'#include <deal.II/lac/sparsity_tools.h>'
p41435
aS'#include <deal.II/lac/vector.h>'
p41436
aS'#include <deal.II/numerics/data_out.h>'
p41437
aS'#include <deal.II/numerics/error_estimator.h>'
p41438
aS'#include <deal.II/numerics/vector_tools.h>'
p41439
aS'#include <deal.II/particles/data_out.h>'
p41440
aS'#include <deal.II/particles/generators.h>'
p41441
aS'#include <deal.II/particles/particle_handler.h>'
p41442
aS'#include <deal.II/particles/utilities.h>'
p41443
aS'#include <deal.II/opencascade/manifold_lib.h>'
p41444
aS'#include <deal.II/opencascade/utilities.h>'
p41445
aS'#ifdef DEAL_II_WITH_OPENCASCADE'
p41446
aS'#  include <TopoDS.hxx>'
p41447
aS'#endif'
p41448
aS'#include <cmath>'
p41449
aS'#include <fstream>'
p41450
aS'#include <iostream>'
p41451
aS'#include <memory>'
p41452
aS'namespace Step70'
p41453
ag24
aS'  using namespace dealii;'
p41454
aS'  template <int dim, int spacedim = dim>'
p41455
aS'  class StokesImmersedProblemParameters : public ParameterAcceptor'
p41456
aS'  {'
p41457
aS'  public:'
p41458
aS'    StokesImmersedProblemParameters();'
p41459
aS'    void set_time(const double &time) const'
p41460
aS'    {'
p41461
aS'      rhs.set_time(time);'
p41462
aS'      angular_velocity.set_time(time);'
p41463
aS'    }'
p41464
aS'    std::string output_directory = ".";'
p41465
aS'    unsigned int velocity_degree = 2;'
p41466
aS'    unsigned int number_of_time_steps = 501;'
p41467
aS'    double       final_time           = 1.0;'
p41468
aS'    unsigned int output_frequency = 1;'
p41469
aS'    unsigned int initial_fluid_refinement      = 5;'
p41470
aS'    unsigned int initial_solid_refinement      = 5;'
p41471
aS'    unsigned int particle_insertion_refinement = 3;'
p41472
aS'    unsigned int fluid_rtree_extraction_level = 1;'
p41473
aS'    double viscosity    = 1.0;'
p41474
aS'    double penalty_term = 100;'
p41475
aS'    std::list<types::boundary_id> homogeneous_dirichlet_ids{0};'
p41476
aS'    std::string name_of_fluid_grid       = "hyper_cube";'
p41477
aS'    std::string arguments_for_fluid_grid = "-1: 1: false";'
p41478
aS'    std::string name_of_solid_grid       = "hyper_rectangle";'
p41479
aS'    std::string arguments_for_solid_grid = spacedim == 2 ?'
p41480
aS'                                             "-.5, -.1: .5, .1: false" :'
p41481
aS'                                             "-.5, -.1, -.1: .5, .1, .1: false";'
p41482
aS'    std::string name_of_particle_grid = "hyper_ball";'
p41483
aS'    std::string arguments_for_particle_grid ='
p41484
aS'      spacedim == 2 ? "0.3, 0.3: 0.1: false" : "0.3, 0.3, 0.3 : 0.1: false";'
p41485
aS'    int          max_level_refinement = 8;'
p41486
aS'    int          min_level_refinement = 5;'
p41487
aS'    std::string  refinement_strategy  = "fixed_fraction";'
p41488
aS'    double       coarsening_fraction  = 0.3;'
p41489
aS'    double       refinement_fraction  = 0.3;'
p41490
aS'    unsigned int max_cells            = 20000;'
p41491
aS'    int          refinement_frequency = 5;'
p41492
aS'    mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> rhs;'
p41493
aS'    mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>'
p41494
aS'      angular_velocity;'
p41495
aS'  };'
p41496
aS'  template <int dim, int spacedim>'
p41497
aS'  StokesImmersedProblemParameters<dim,'
p41498
aS'                                  spacedim>::StokesImmersedProblemParameters()'
p41499
aS'    : ParameterAcceptor("Stokes Immersed Problem/")'
p41500
aS'    , rhs("Right hand side", spacedim + 1)'
p41501
aS'    , angular_velocity("Angular velocity")'
p41502
aS'  {'
p41503
aS'    add_parameter('
p41504
aS'      "Velocity degree", velocity_degree, "", this->prm, Patterns::Integer(1));'
p41505
aS'    add_parameter("Number of time steps", number_of_time_steps);'
p41506
aS'    add_parameter("Output frequency", output_frequency);'
p41507
aS'    add_parameter("Output directory", output_directory);'
p41508
aS'    add_parameter("Final time", final_time);'
p41509
aS'    add_parameter("Viscosity", viscosity);'
p41510
aS'    add_parameter("Nitsche penalty term", penalty_term);'
p41511
aS'    add_parameter("Initial fluid refinement",'
p41512
aS'                  initial_fluid_refinement,'
p41513
aS'                  "Initial mesh refinement used for the fluid domain Omega");'
p41514
aS'    add_parameter("Initial solid refinement",'
p41515
aS'                  initial_solid_refinement,'
p41516
aS'                  "Initial mesh refinement used for the solid domain Gamma");'
p41517
aS'    add_parameter("Fluid bounding boxes extraction level",'
p41518
aS'                  fluid_rtree_extraction_level,'
p41519
aS'                  "Extraction level of the rtree used to construct global "'
p41520
aS'                  "bounding boxes");'
p41521
aS'    add_parameter('
p41522
aS'      "Particle insertion refinement",'
p41523
aS'      particle_insertion_refinement,'
p41524
aS'      "Refinement of the volumetric mesh used to insert the particles");'
p41525
aS'    add_parameter('
p41526
aS'      "Homogeneous Dirichlet boundary ids",'
p41527
aS'      homogeneous_dirichlet_ids,'
p41528
aS'      "Boundary Ids over which homogeneous Dirichlet boundary conditions are applied");'
p41529
aS'    enter_subsection("Grid generation");'
p41530
aS'    {'
p41531
aS'      add_parameter("Fluid grid generator", name_of_fluid_grid);'
p41532
aS'      add_parameter("Fluid grid generator arguments", arguments_for_fluid_grid);'
p41533
aS'      add_parameter("Solid grid generator", name_of_solid_grid);'
p41534
aS'      add_parameter("Solid grid generator arguments", arguments_for_solid_grid);'
p41535
aS'      add_parameter("Particle grid generator", name_of_particle_grid);'
p41536
aS'      add_parameter("Particle grid generator arguments",'
p41537
aS'                    arguments_for_particle_grid);'
p41538
aS'    }'
p41539
aS'    leave_subsection();'
p41540
aS'    enter_subsection("Refinement and remeshing");'
p41541
aS'    {'
p41542
aS'      add_parameter("Refinement step frequency", refinement_frequency);'
p41543
aS'      add_parameter("Refinement maximal level", max_level_refinement);'
p41544
aS'      add_parameter("Refinement minimal level", min_level_refinement);'
p41545
aS'      add_parameter("Refinement strategy",'
p41546
aS'                    refinement_strategy,'
p41547
aS'                    "",'
p41548
aS'                    this->prm,'
p41549
aS'                    Patterns::Selection("fixed_fraction|fixed_number"));'
p41550
aS'      add_parameter("Refinement coarsening fraction", coarsening_fraction);'
p41551
aS'      add_parameter("Refinement fraction", refinement_fraction);'
p41552
aS'      add_parameter("Maximum number of cells", max_cells);'
p41553
aS'    }'
p41554
aS'    leave_subsection();'
p41555
aS'    rhs.declare_parameters_call_back.connect([&]() {'
p41556
aS'      Functions::ParsedFunction<spacedim>::declare_parameters(this->prm,'
p41557
aS'                                                              spacedim + 1);'
p41558
aS'    });'
p41559
aS'    angular_velocity.declare_parameters_call_back.connect([&]() {'
p41560
aS'      this->prm.set("Function expression",'
p41561
aS'                    "t < .500001 ? 6.283185 : -6.283185");'
p41562
aS'    });'
p41563
aS'  }'
p41564
aS'  template <int spacedim>'
p41565
aS'  class SolidVelocity : public Function<spacedim>'
p41566
aS'  {'
p41567
aS'  public:'
p41568
aS'    static_assert(spacedim > 1,'
p41569
aS'                  "Cannot instantiate SolidVelocity for spacedim == 1");'
p41570
aS'    SolidVelocity(const Functions::ParsedFunction<spacedim> &angular_velocity)'
p41571
aS'      : angular_velocity(angular_velocity)'
p41572
aS'    {}'
p41573
aS'    virtual double value(const Point<spacedim> &p,'
p41574
aS'                         unsigned int           component = 0) const override'
p41575
aS'    {'
p41576
aS'      Tensor<1, spacedim> velocity;'
p41577
aS'      const double omega = angular_velocity.value(p);'
p41578
aS'      velocity[0]        = -omega * p[1];'
p41579
aS'      velocity[1]        = omega * p[0];'
p41580
aS'      return velocity[component];'
p41581
aS'    }'
p41582
aS'  private:'
p41583
aS'    const Functions::ParsedFunction<spacedim> &angular_velocity;'
p41584
aS'  };'
p41585
aS'  template <int spacedim>'
p41586
aS'  class SolidPosition : public Function<spacedim>'
p41587
aS'  {'
p41588
aS'  public:'
p41589
aS'    static_assert(spacedim > 1,'
p41590
aS'                  "Cannot instantiate SolidPosition for spacedim == 1");'
p41591
aS'    SolidPosition(const Functions::ParsedFunction<spacedim> &angular_velocity,'
p41592
aS'                  const double                               time_step)'
p41593
aS'      : Function<spacedim>(spacedim)'
p41594
aS'      , angular_velocity(angular_velocity)'
p41595
aS'      , time_step(time_step)'
p41596
aS'    {}'
p41597
aS'    virtual double value(const Point<spacedim> &p,'
p41598
aS'                         unsigned int           component = 0) const override'
p41599
aS'    {'
p41600
aS'      Point<spacedim> new_position = p;'
p41601
aS'      double dtheta = angular_velocity.value(p) * time_step;'
p41602
aS'      new_position[0] = std::cos(dtheta) * p[0] - std::sin(dtheta) * p[1];'
p41603
aS'      new_position[1] = std::sin(dtheta) * p[0] + std::cos(dtheta) * p[1];'
p41604
aS'      return new_position[component];'
p41605
aS'    }'
p41606
aS'    void set_time_step(const double new_time_step)'
p41607
aS'    {'
p41608
aS'      time_step = new_time_step;'
p41609
aS'    }'
p41610
aS'  private:'
p41611
aS'    const Functions::ParsedFunction<spacedim> &angular_velocity;'
p41612
aS'    double                                     time_step;'
p41613
aS'  };'
p41614
aS'  template <int dim, int spacedim = dim>'
p41615
aS'  class StokesImmersedProblem'
p41616
aS'  {'
p41617
aS'  public:'
p41618
aS'    StokesImmersedProblem('
p41619
aS'      const StokesImmersedProblemParameters<dim, spacedim> &par);'
p41620
aS'    void run();'
p41621
aS'  private:'
p41622
aS'    void make_grid();'
p41623
aS'    double compute_time_step() const;'
p41624
aS'    void setup_tracer_particles();'
p41625
aS'    void setup_solid_particles();'
p41626
aS'    void initial_setup();'
p41627
aS'    void setup_dofs();'
p41628
aS'    void assemble_stokes_system();'
p41629
aS'    void assemble_nitsche_restriction();'
p41630
aS'    void solve();'
p41631
aS'    void refine_and_transfer();'
p41632
aS'    void output_results(const unsigned int cycle, const double time) const;'
p41633
aS'    void output_particles(const Particles::ParticleHandler<spacedim> &particles,'
p41634
aS'                          std::string                                 fprefix,'
p41635
aS'                          const unsigned int                          iter,'
p41636
aS'                          const double time) const;'
p41637
aS'    const StokesImmersedProblemParameters<dim, spacedim> &par;'
p41638
aS'    MPI_Comm mpi_communicator;'
p41639
aS'    ConditionalOStream pcout;'
p41640
aS'    mutable TimerOutput computing_timer;'
p41641
aS'    parallel::distributed::Triangulation<spacedim>      fluid_tria;'
p41642
aS'    parallel::distributed::Triangulation<dim, spacedim> solid_tria;'
p41643
aS'    std::unique_ptr<FiniteElement<spacedim>>      fluid_fe;'
p41644
aS'    std::unique_ptr<FiniteElement<dim, spacedim>> solid_fe;'
p41645
aS'    std::unique_ptr<Quadrature<spacedim>> fluid_quadrature_formula;'
p41646
aS'    std::unique_ptr<Quadrature<dim>>      solid_quadrature_formula;'
p41647
aS'    DoFHandler<spacedim>      fluid_dh;'
p41648
aS'    DoFHandler<dim, spacedim> solid_dh;'
p41649
aS'    std::unique_ptr<MappingFEField<dim, spacedim>> solid_mapping;'
p41650
aS'    std::vector<IndexSet> fluid_owned_dofs;'
p41651
aS'    std::vector<IndexSet> solid_owned_dofs;'
p41652
aS'    std::vector<IndexSet> fluid_relevant_dofs;'
p41653
aS'    std::vector<IndexSet> solid_relevant_dofs;'
p41654
aS'    AffineConstraints<double> constraints;'
p41655
aS'    LA::MPI::BlockSparseMatrix system_matrix;'
p41656
aS'    LA::MPI::BlockSparseMatrix preconditioner_matrix;'
p41657
aS'    LA::MPI::BlockVector solution;'
p41658
aS'    LA::MPI::BlockVector locally_relevant_solution;'
p41659
aS'    LA::MPI::BlockVector system_rhs;'
p41660
aS'    Particles::ParticleHandler<spacedim> tracer_particle_handler;'
p41661
aS'    Particles::ParticleHandler<spacedim> solid_particle_handler;'
p41662
aS'    IndexSet locally_owned_tracer_particle_coordinates;'
p41663
aS'    IndexSet locally_relevant_tracer_particle_coordinates;'
p41664
aS'    LA::MPI::Vector tracer_particle_velocities;'
p41665
aS'    LA::MPI::Vector relevant_tracer_particle_displacements;'
p41666
aS'    std::vector<std::vector<BoundingBox<spacedim>>> global_fluid_bounding_boxes;'
p41667
aS'  };'
p41668
aS'  template <int dim, int spacedim>'
p41669
aS'  StokesImmersedProblem<dim, spacedim>::StokesImmersedProblem('
p41670
aS'    const StokesImmersedProblemParameters<dim, spacedim> &par)'
p41671
aS'    : par(par)'
p41672
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p41673
aS'    , pcout(std::cout,'
p41674
aS'            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p41675
aS'    , computing_timer(mpi_communicator,'
p41676
aS'                      pcout,'
p41677
aS'                      TimerOutput::summary,'
p41678
aS'                      TimerOutput::wall_times)'
p41679
aS'    , fluid_tria(mpi_communicator,'
p41680
aS'                 typename Triangulation<spacedim>::MeshSmoothing('
p41681
aS'                   Triangulation<spacedim>::smoothing_on_refinement |'
p41682
aS'                   Triangulation<spacedim>::smoothing_on_coarsening))'
p41683
aS'    , solid_tria(mpi_communicator,'
p41684
aS'                 typename Triangulation<dim, spacedim>::MeshSmoothing('
p41685
aS'                   Triangulation<dim, spacedim>::smoothing_on_refinement |'
p41686
aS'                   Triangulation<dim, spacedim>::smoothing_on_coarsening))'
p41687
aS'    , fluid_dh(fluid_tria)'
p41688
aS'    , solid_dh(solid_tria)'
p41689
aS'  {}'
p41690
aS'  template <int dim, int spacedim>'
p41691
aS'  void read_grid_and_cad_files(const std::string &grid_file_name,'
p41692
aS'                               const std::string &ids_and_cad_file_names,'
p41693
aS'                               Triangulation<dim, spacedim> &tria)'
p41694
aS'  {'
p41695
aS'    GridIn<dim, spacedim> grid_in;'
p41696
aS'    grid_in.attach_triangulation(tria);'
p41697
aS'    grid_in.read(grid_file_name);'
p41698
aS'#ifdef DEAL_II_WITH_OPENCASCADE'
p41699
aS'    using map_type  = std::map<types::manifold_id, std::string>;'
p41700
aS'    using Converter = Patterns::Tools::Convert<map_type>;'
p41701
aS'    for (const auto &pair : Converter::to_value(ids_and_cad_file_names))'
p41702
aS'      {'
p41703
aS'        const auto &manifold_id   = pair.first;'
p41704
aS'        const auto &cad_file_name = pair.second;'
p41705
aS'        const auto extension = boost::algorithm::to_lower_copy('
p41706
aS"          cad_file_name.substr(cad_file_name.find_last_of('.') + 1));"
p41707
aS'        TopoDS_Shape shape;'
p41708
aS'        if (extension == "iges" || extension == "igs")'
p41709
aS'          shape = OpenCASCADE::read_IGES(cad_file_name);'
p41710
aS'        else if (extension == "step" || extension == "stp")'
p41711
aS'          shape = OpenCASCADE::read_STEP(cad_file_name);'
p41712
aS'        else'
p41713
aS'          AssertThrow(false,'
p41714
aS'                      ExcNotImplemented("We found an extension that we "'
p41715
aS'                                        "do not recognize as a CAD file "'
p41716
aS'                                        "extension. Bailing out."));'
p41717
aS'        const auto n_elements = OpenCASCADE::count_elements(shape);'
p41718
aS'        if ((std::get<0>(n_elements) == 0))'
p41719
aS'          tria.set_manifold('
p41720
aS'            manifold_id,'
p41721
aS'            OpenCASCADE::ArclengthProjectionLineManifold<dim, spacedim>(shape));'
p41722
aS'        else if (spacedim == 3)'
p41723
aS'          {'
p41724
aS'            const auto t = reinterpret_cast<Triangulation<dim, 3> *>(&tria);'
p41725
aS'            t->set_manifold(manifold_id,'
p41726
aS'                            OpenCASCADE::NormalToMeshProjectionManifold<dim, 3>('
p41727
aS'                              shape));'
p41728
aS'          }'
p41729
aS'        else'
p41730
aS'          tria.set_manifold(manifold_id,'
p41731
aS'                            OpenCASCADE::NURBSPatchManifold<dim, spacedim>('
p41732
aS'                              TopoDS::Face(shape)));'
p41733
aS'      }'
p41734
aS'#else'
p41735
aS'    (void)ids_and_cad_file_names;'
p41736
aS'    AssertThrow(false, ExcNotImplemented("Generation of the grid failed."));'
p41737
aS'#endif'
p41738
aS'  }'
p41739
aS'  template <int dim, int spacedim>'
p41740
aS'  void StokesImmersedProblem<dim, spacedim>::make_grid()'
p41741
aS'  {'
p41742
aS'    try'
p41743
aS'      {'
p41744
aS'        GridGenerator::generate_from_name_and_arguments('
p41745
aS'          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);'
p41746
aS'      }'
p41747
aS'    catch (...)'
p41748
aS'      {'
p41749
aS'        pcout << "Generating from name and argument failed." << std::endl'
p41750
aS'              << "Trying to read from file name." << std::endl;'
p41751
aS'        read_grid_and_cad_files(par.name_of_fluid_grid,'
p41752
aS'                                par.arguments_for_fluid_grid,'
p41753
aS'                                fluid_tria);'
p41754
aS'      }'
p41755
aS'    fluid_tria.refine_global(par.initial_fluid_refinement);'
p41756
aS'    try'
p41757
aS'      {'
p41758
aS'        GridGenerator::generate_from_name_and_arguments('
p41759
aS'          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);'
p41760
aS'      }'
p41761
aS'    catch (...)'
p41762
aS'      {'
p41763
aS'        read_grid_and_cad_files(par.name_of_solid_grid,'
p41764
aS'                                par.arguments_for_solid_grid,'
p41765
aS'                                solid_tria);'
p41766
aS'      }'
p41767
aS'    solid_tria.refine_global(par.initial_solid_refinement);'
p41768
aS'  }'
p41769
aS'  template <int dim, int spacedim>'
p41770
aS'  void StokesImmersedProblem<dim, spacedim>::setup_tracer_particles()'
p41771
aS'  {'
p41772
aS'    parallel::distributed::Triangulation<spacedim> particle_insert_tria('
p41773
aS'      mpi_communicator);'
p41774
aS'    GridGenerator::generate_from_name_and_arguments('
p41775
aS'      particle_insert_tria,'
p41776
aS'      par.name_of_particle_grid,'
p41777
aS'      par.arguments_for_particle_grid);'
p41778
aS'    particle_insert_tria.refine_global(par.particle_insertion_refinement);'
p41779
aS'    FE_Q<spacedim>       particles_fe(1);'
p41780
aS'    DoFHandler<spacedim> particles_dof_handler(particle_insert_tria);'
p41781
aS'    particles_dof_handler.distribute_dofs(particles_fe);'
p41782
aS'    std::vector<BoundingBox<spacedim>> all_boxes;'
p41783
aS'    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());'
p41784
aS'    for (const auto &cell : fluid_tria.active_cell_iterators())'
p41785
aS'      if (cell->is_locally_owned())'
p41786
aS'        all_boxes.emplace_back(cell->bounding_box());'
p41787
aS'    const auto tree = pack_rtree(all_boxes);'
p41788
aS'    const auto local_boxes ='
p41789
aS'      extract_rtree_level(tree, par.fluid_rtree_extraction_level);'
p41790
aS'    global_fluid_bounding_boxes ='
p41791
aS'      Utilities::MPI::all_gather(mpi_communicator, local_boxes);'
p41792
aS'    tracer_particle_handler.initialize(fluid_tria,'
p41793
aS'                                       StaticMappingQ1<spacedim>::mapping);'
p41794
aS'    Particles::Generators::dof_support_points(particles_dof_handler,'
p41795
aS'                                              global_fluid_bounding_boxes,'
p41796
aS'                                              tracer_particle_handler);'
p41797
aS'    pcout << "Tracer particles: "'
p41798
aS'          << tracer_particle_handler.n_global_particles() << std::endl;'
p41799
aS'    locally_owned_tracer_particle_coordinates ='
p41800
aS'      tracer_particle_handler.locally_owned_particle_ids().tensor_product('
p41801
aS'        complete_index_set(spacedim));'
p41802
aS'    locally_relevant_tracer_particle_coordinates ='
p41803
aS'      locally_owned_tracer_particle_coordinates;'
p41804
aS'    fluid_tria.signals.pre_distributed_refinement.connect('
p41805
aS'      [&]() { tracer_particle_handler.register_store_callback_function(); });'
p41806
aS'    fluid_tria.signals.post_distributed_refinement.connect([&]() {'
p41807
aS'      tracer_particle_handler.register_load_callback_function(false);'
p41808
aS'    });'
p41809
aS'  }'
p41810
aS'  template <int dim, int spacedim>'
p41811
aS'  void StokesImmersedProblem<dim, spacedim>::setup_solid_particles()'
p41812
aS'  {'
p41813
aS'    QGauss<dim> quadrature(fluid_fe->degree + 1);'
p41814
aS'    const unsigned int n_properties = 1;'
p41815
aS'    solid_particle_handler.initialize(fluid_tria,'
p41816
aS'                                      StaticMappingQ1<spacedim>::mapping,'
p41817
aS'                                      n_properties);'
p41818
aS'    std::vector<Point<spacedim>> quadrature_points_vec;'
p41819
aS'    quadrature_points_vec.reserve(quadrature.size() *'
p41820
aS'                                  solid_tria.n_locally_owned_active_cells());'
p41821
aS'    std::vector<std::vector<double>> properties;'
p41822
aS'    properties.reserve(quadrature.size() *'
p41823
aS'                       solid_tria.n_locally_owned_active_cells());'
p41824
aS'    FEValues<dim, spacedim> fe_v(*solid_fe,'
p41825
aS'                                 quadrature,'
p41826
aS'                                 update_JxW_values | update_quadrature_points);'
p41827
aS'    for (const auto &cell : solid_dh.active_cell_iterators())'
p41828
aS'      if (cell->is_locally_owned())'
p41829
aS'        {'
p41830
aS'          fe_v.reinit(cell);'
p41831
aS'          const auto &points = fe_v.get_quadrature_points();'
p41832
aS'          const auto &JxW    = fe_v.get_JxW_values();'
p41833
aS'          for (unsigned int q = 0; q < points.size(); ++q)'
p41834
aS'            {'
p41835
aS'              quadrature_points_vec.emplace_back(points[q]);'
p41836
aS'              properties.emplace_back('
p41837
aS'                std::vector<double>(n_properties, JxW[q]));'
p41838
aS'            }'
p41839
aS'        }'
p41840
aS'    Assert(!global_fluid_bounding_boxes.empty(),'
p41841
aS'           ExcInternalError('
p41842
aS'             "I was expecting the "'
p41843
aS'             "global_fluid_bounding_boxes to be filled at this stage. "'
p41844
aS'             "Make sure you fill this vector before trying to use it "'
p41845
aS'             "here. Bailing out."));'
p41846
aS'    solid_particle_handler.insert_global_particles(quadrature_points_vec,'
p41847
aS'                                                   global_fluid_bounding_boxes,'
p41848
aS'                                                   properties);'
p41849
aS'    fluid_tria.signals.pre_distributed_refinement.connect('
p41850
aS'      [&]() { solid_particle_handler.register_store_callback_function(); });'
p41851
aS'    fluid_tria.signals.post_distributed_refinement.connect('
p41852
aS'      [&]() { solid_particle_handler.register_load_callback_function(false); });'
p41853
aS'    pcout << "Solid particles: " << solid_particle_handler.n_global_particles()'
p41854
aS'          << std::endl;'
p41855
aS'  }'
p41856
aS'  template <int dim, int spacedim>'
p41857
aS'  void StokesImmersedProblem<dim, spacedim>::initial_setup()'
p41858
aS'  {'
p41859
aS'    TimerOutput::Scope t(computing_timer, "Initial setup");'
p41860
aS'    fluid_fe ='
p41861
aS'      std::make_unique<FESystem<spacedim>>(FE_Q<spacedim>(par.velocity_degree),'
p41862
aS'                                           spacedim,'
p41863
aS'                                           FE_Q<spacedim>(par.velocity_degree -'
p41864
aS'                                                          1),'
p41865
aS'                                           1);'
p41866
aS'    solid_fe = std::make_unique<FE_Nothing<dim, spacedim>>();'
p41867
aS'    solid_dh.distribute_dofs(*solid_fe);'
p41868
aS'    fluid_quadrature_formula ='
p41869
aS'      std::make_unique<QGauss<spacedim>>(par.velocity_degree + 1);'
p41870
aS'    solid_quadrature_formula ='
p41871
aS'      std::make_unique<QGauss<dim>>(par.velocity_degree + 1);'
p41872
aS'  }'
p41873
aS'  template <int dim, int spacedim>'
p41874
aS'  void StokesImmersedProblem<dim, spacedim>::setup_dofs()'
p41875
aS'  {'
p41876
aS'    TimerOutput::Scope t(computing_timer, "Setup dofs");'
p41877
aS'    fluid_dh.distribute_dofs(*fluid_fe);'
p41878
aS'    std::vector<unsigned int> stokes_sub_blocks(spacedim + 1, 0);'
p41879
aS'    stokes_sub_blocks[spacedim] = 1;'
p41880
aS'    DoFRenumbering::component_wise(fluid_dh, stokes_sub_blocks);'
p41881
aS'    auto dofs_per_block ='
p41882
aS'      DoFTools::count_dofs_per_fe_block(fluid_dh, stokes_sub_blocks);'
p41883
aS'    const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];'
p41884
aS'    pcout << "   Number of degrees of freedom: " << fluid_dh.n_dofs() << " ("'
p41885
aS'          << n_u << \'+\' << n_p << " -- "'
p41886
aS"          << solid_particle_handler.n_global_particles() << '+'"
p41887
aS"          << tracer_particle_handler.n_global_particles() << ')' << std::endl;"
p41888
aS'    fluid_owned_dofs.resize(2);'
p41889
aS'    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);'
p41890
aS'    fluid_owned_dofs[1] ='
p41891
aS'      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);'
p41892
aS'    IndexSet locally_relevant_dofs;'
p41893
aS'    DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs);'
p41894
aS'    fluid_relevant_dofs.resize(2);'
p41895
aS'    fluid_relevant_dofs[0] = locally_relevant_dofs.get_view(0, n_u);'
p41896
aS'    fluid_relevant_dofs[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);'
p41897
aS'    {'
p41898
aS'      constraints.reinit(locally_relevant_dofs);'
p41899
aS'      FEValuesExtractors::Vector velocities(0);'
p41900
aS'      DoFTools::make_hanging_node_constraints(fluid_dh, constraints);'
p41901
aS'      VectorTools::interpolate_boundary_values('
p41902
aS'        fluid_dh,'
p41903
aS'        0,'
p41904
aS'        Functions::ZeroFunction<spacedim>(spacedim + 1),'
p41905
aS'        constraints,'
p41906
aS'        fluid_fe->component_mask(velocities));'
p41907
aS'      constraints.close();'
p41908
aS'    }'
p41909
aS'    auto locally_owned_dofs_per_processor ='
p41910
aS'      Utilities::MPI::all_gather(mpi_communicator,'
p41911
aS'                                 fluid_dh.locally_owned_dofs());'
p41912
aS'    {'
p41913
aS'      system_matrix.clear();'
p41914
aS'      Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);'
p41915
aS'      for (unsigned int c = 0; c < spacedim + 1; ++c)'
p41916
aS'        for (unsigned int d = 0; d < spacedim + 1; ++d)'
p41917
aS'          if (c == spacedim && d == spacedim)'
p41918
aS'            coupling[c][d] = DoFTools::none;'
p41919
aS'          else if (c == spacedim || d == spacedim || c == d)'
p41920
aS'            coupling[c][d] = DoFTools::always;'
p41921
aS'          else'
p41922
aS'            coupling[c][d] = DoFTools::none;'
p41923
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p41924
aS'      DoFTools::make_sparsity_pattern('
p41925
aS'        fluid_dh, coupling, dsp, constraints, false);'
p41926
aS'      SparsityTools::distribute_sparsity_pattern('
p41927
aS'        dsp,'
p41928
aS'        locally_owned_dofs_per_processor,'
p41929
aS'        mpi_communicator,'
p41930
aS'        locally_relevant_dofs);'
p41931
aS'      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);'
p41932
aS'    }'
p41933
aS'    {'
p41934
aS'      preconditioner_matrix.clear();'
p41935
aS'      Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);'
p41936
aS'      for (unsigned int c = 0; c < spacedim + 1; ++c)'
p41937
aS'        for (unsigned int d = 0; d < spacedim + 1; ++d)'
p41938
aS'          if (c == spacedim && d == spacedim)'
p41939
aS'            coupling[c][d] = DoFTools::always;'
p41940
aS'          else'
p41941
aS'            coupling[c][d] = DoFTools::none;'
p41942
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p41943
aS'      DoFTools::make_sparsity_pattern('
p41944
aS'        fluid_dh, coupling, dsp, constraints, false);'
p41945
aS'      SparsityTools::distribute_sparsity_pattern('
p41946
aS'        dsp,'
p41947
aS'        locally_owned_dofs_per_processor,'
p41948
aS'        mpi_communicator,'
p41949
aS'        locally_relevant_dofs);'
p41950
aS'      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);'
p41951
aS'    }'
p41952
aS'    locally_relevant_solution.reinit(fluid_owned_dofs,'
p41953
aS'                                     fluid_relevant_dofs,'
p41954
aS'                                     mpi_communicator);'
p41955
aS'    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);'
p41956
aS'    solution.reinit(fluid_owned_dofs, mpi_communicator);'
p41957
aS'  }'
p41958
aS'  template <int dim, int spacedim>'
p41959
aS'  void StokesImmersedProblem<dim, spacedim>::assemble_stokes_system()'
p41960
aS'  {'
p41961
aS'    system_matrix         = 0;'
p41962
aS'    preconditioner_matrix = 0;'
p41963
aS'    system_rhs            = 0;'
p41964
aS'    TimerOutput::Scope t(computing_timer, "Assemble Stokes terms");'
p41965
aS'    FEValues<spacedim> fe_values(*fluid_fe,'
p41966
aS'                                 *fluid_quadrature_formula,'
p41967
aS'                                 update_values | update_gradients |'
p41968
aS'                                   update_quadrature_points |'
p41969
aS'                                   update_JxW_values);'
p41970
aS'    const unsigned int dofs_per_cell = fluid_fe->n_dofs_per_cell();'
p41971
aS'    const unsigned int n_q_points    = fluid_quadrature_formula->size();'
p41972
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p41973
aS'    FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell);'
p41974
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p41975
aS'    std::vector<Vector<double>> rhs_values(n_q_points,'
p41976
aS'                                           Vector<double>(spacedim + 1));'
p41977
aS'    std::vector<Tensor<2, spacedim>> grad_phi_u(dofs_per_cell);'
p41978
aS'    std::vector<double>              div_phi_u(dofs_per_cell);'
p41979
aS'    std::vector<double>              phi_p(dofs_per_cell);'
p41980
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p41981
aS'    const FEValuesExtractors::Vector     velocities(0);'
p41982
aS'    const FEValuesExtractors::Scalar     pressure(spacedim);'
p41983
aS'    for (const auto &cell : fluid_dh.active_cell_iterators())'
p41984
aS'      if (cell->is_locally_owned())'
p41985
aS'        {'
p41986
aS'          cell_matrix  = 0;'
p41987
aS'          cell_matrix2 = 0;'
p41988
aS'          cell_rhs     = 0;'
p41989
aS'          fe_values.reinit(cell);'
p41990
aS'          par.rhs.vector_value_list(fe_values.get_quadrature_points(),'
p41991
aS'                                    rhs_values);'
p41992
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p41993
aS'            {'
p41994
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p41995
aS'                {'
p41996
aS'                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);'
p41997
aS'                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);'
p41998
aS'                  phi_p[k]      = fe_values[pressure].value(k, q);'
p41999
aS'                }'
p42000
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p42001
aS'                {'
p42002
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p42003
aS'                    {'
p42004
aS'                      cell_matrix(i, j) +='
p42005
aS'                        (par.viscosity *'
p42006
aS'                           scalar_product(grad_phi_u[i], grad_phi_u[j]) -'
p42007
aS'                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p42008
aS'                        fe_values.JxW(q);'
p42009
aS'                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *'
p42010
aS'                                            phi_p[j] * fe_values.JxW(q);'
p42011
aS'                    }'
p42012
aS'                  const unsigned int component_i ='
p42013
aS'                    fluid_fe->system_to_component_index(i).first;'
p42014
aS'                  cell_rhs(i) += fe_values.shape_value(i, q) *'
p42015
aS'                                 rhs_values[q](component_i) * fe_values.JxW(q);'
p42016
aS'                }'
p42017
aS'            }'
p42018
aS'          cell->get_dof_indices(local_dof_indices);'
p42019
aS'          constraints.distribute_local_to_global(cell_matrix,'
p42020
aS'                                                 cell_rhs,'
p42021
aS'                                                 local_dof_indices,'
p42022
aS'                                                 system_matrix,'
p42023
aS'                                                 system_rhs);'
p42024
aS'          constraints.distribute_local_to_global(cell_matrix2,'
p42025
aS'                                                 local_dof_indices,'
p42026
aS'                                                 preconditioner_matrix);'
p42027
aS'        }'
p42028
aS'    system_matrix.compress(VectorOperation::add);'
p42029
aS'    preconditioner_matrix.compress(VectorOperation::add);'
p42030
aS'    system_rhs.compress(VectorOperation::add);'
p42031
aS'  }'
p42032
aS'  template <int dim, int spacedim>'
p42033
aS'  void StokesImmersedProblem<dim, spacedim>::assemble_nitsche_restriction()'
p42034
aS'  {'
p42035
aS'    TimerOutput::Scope t(computing_timer, "Assemble Nitsche terms");'
p42036
aS'    const FEValuesExtractors::Vector velocities(0);'
p42037
aS'    const FEValuesExtractors::Scalar pressure(spacedim);'
p42038
aS'    SolidVelocity<spacedim> solid_velocity(par.angular_velocity);'
p42039
aS'    std::vector<types::global_dof_index> fluid_dof_indices('
p42040
aS'      fluid_fe->n_dofs_per_cell());'
p42041
aS'    FullMatrix<double>     local_matrix(fluid_fe->n_dofs_per_cell(),'
p42042
aS'                                    fluid_fe->n_dofs_per_cell());'
p42043
aS'    dealii::Vector<double> local_rhs(fluid_fe->n_dofs_per_cell());'
p42044
aS'    const auto penalty_parameter ='
p42045
aS'      1.0 / GridTools::minimal_cell_diameter(fluid_tria);'
p42046
aS'    auto particle = solid_particle_handler.begin();'
p42047
aS'    while (particle != solid_particle_handler.end())'
p42048
aS'      {'
p42049
aS'        local_matrix = 0;'
p42050
aS'        local_rhs    = 0;'
p42051
aS'        const auto &cell = particle->get_surrounding_cell(fluid_tria);'
p42052
aS'        const auto &dh_cell ='
p42053
aS'          typename DoFHandler<spacedim>::cell_iterator(*cell, &fluid_dh);'
p42054
aS'        dh_cell->get_dof_indices(fluid_dof_indices);'
p42055
aS'        const auto pic = solid_particle_handler.particles_in_cell(cell);'
p42056
aS'        Assert(pic.begin() == particle, ExcInternalError());'
p42057
aS'        for (const auto &p : pic)'
p42058
aS'          {'
p42059
aS'            const auto &ref_q  = p.get_reference_location();'
p42060
aS'            const auto &real_q = p.get_location();'
p42061
aS'            const auto &JxW    = p.get_properties()[0];'
p42062
aS'            for (unsigned int i = 0; i < fluid_fe->n_dofs_per_cell(); ++i)'
p42063
aS'              {'
p42064
aS'                const auto comp_i ='
p42065
aS'                  fluid_fe->system_to_component_index(i).first;'
p42066
aS'                if (comp_i < spacedim)'
p42067
aS'                  {'
p42068
aS'                    for (unsigned int j = 0; j < fluid_fe->n_dofs_per_cell();'
p42069
aS'                         ++j)'
p42070
aS'                      {'
p42071
aS'                        const auto comp_j ='
p42072
aS'                          fluid_fe->system_to_component_index(j).first;'
p42073
aS'                        if (comp_i == comp_j)'
p42074
aS'                          local_matrix(i, j) +='
p42075
aS'                            penalty_parameter * par.penalty_term *'
p42076
aS'                            fluid_fe->shape_value(i, ref_q) *'
p42077
aS'                            fluid_fe->shape_value(j, ref_q) * JxW;'
p42078
aS'                      }'
p42079
aS'                    local_rhs(i) += penalty_parameter * par.penalty_term *'
p42080
aS'                                    solid_velocity.value(real_q, comp_i) *'
p42081
aS'                                    fluid_fe->shape_value(i, ref_q) * JxW;'
p42082
aS'                  }'
p42083
aS'              }'
p42084
aS'          }'
p42085
aS'        constraints.distribute_local_to_global(local_matrix,'
p42086
aS'                                               local_rhs,'
p42087
aS'                                               fluid_dof_indices,'
p42088
aS'                                               system_matrix,'
p42089
aS'                                               system_rhs);'
p42090
aS'        particle = pic.end();'
p42091
aS'      }'
p42092
aS'    system_matrix.compress(VectorOperation::add);'
p42093
aS'    system_rhs.compress(VectorOperation::add);'
p42094
aS'  }'
p42095
aS'  template <int dim, int spacedim>'
p42096
aS'  void StokesImmersedProblem<dim, spacedim>::solve()'
p42097
aS'  {'
p42098
aS'    TimerOutput::Scope t(computing_timer, "Solve");'
p42099
aS'    LA::MPI::PreconditionAMG prec_A;'
p42100
aS'    {'
p42101
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p42102
aS'#ifdef USE_PETSC_LA'
p42103
aS'      data.symmetric_operator = true;'
p42104
aS'#endif'
p42105
aS'      prec_A.initialize(system_matrix.block(0, 0), data);'
p42106
aS'    }'
p42107
aS'    LA::MPI::PreconditionAMG prec_S;'
p42108
aS'    {'
p42109
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p42110
aS'#ifdef USE_PETSC_LA'
p42111
aS'      data.symmetric_operator = true;'
p42112
aS'#endif'
p42113
aS'      prec_S.initialize(preconditioner_matrix.block(1, 1), data);'
p42114
aS'    }'
p42115
aS'    const auto A = linear_operator<LA::MPI::Vector>(system_matrix.block(0, 0));'
p42116
aS'    const auto amgA = linear_operator(A, prec_A);'
p42117
aS'    const auto S ='
p42118
aS'      linear_operator<LA::MPI::Vector>(preconditioner_matrix.block(1, 1));'
p42119
aS'    const auto amgS = linear_operator(S, prec_S);'
p42120
aS'    ReductionControl          inner_solver_control(100,'
p42121
aS'                                          1e-8 * system_rhs.l2_norm(),'
p42122
aS'                                          1.e-2);'
p42123
aS'    SolverCG<LA::MPI::Vector> cg(inner_solver_control);'
p42124
aS'    const auto invS = inverse_operator(S, cg, amgS);'
p42125
aS'    const auto P = block_diagonal_operator<2, LA::MPI::BlockVector>('
p42126
aS'      std::array<'
p42127
aS'        dealii::LinearOperator<typename LA::MPI::BlockVector::BlockType>,'
p42128
aS'        2>{{amgA, amgS}});'
p42129
aS'    SolverControl solver_control(system_matrix.m(),'
p42130
aS'                                 1e-10 * system_rhs.l2_norm());'
p42131
aS'    SolverFGMRES<LA::MPI::BlockVector> solver(solver_control);'
p42132
aS'    constraints.set_zero(solution);'
p42133
aS'    solver.solve(system_matrix, solution, system_rhs, P);'
p42134
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p42135
aS'          << std::endl;'
p42136
aS'    constraints.distribute(solution);'
p42137
aS'    locally_relevant_solution = solution;'
p42138
aS'    const double mean_pressure ='
p42139
aS'      VectorTools::compute_mean_value(fluid_dh,'
p42140
aS'                                      QGauss<spacedim>(par.velocity_degree + 2),'
p42141
aS'                                      locally_relevant_solution,'
p42142
aS'                                      spacedim);'
p42143
aS'    solution.block(1).add(-mean_pressure);'
p42144
aS'    locally_relevant_solution.block(1) = solution.block(1);'
p42145
aS'  }'
p42146
aS'  template <int dim, int spacedim>'
p42147
aS'  void StokesImmersedProblem<dim, spacedim>::refine_and_transfer()'
p42148
aS'  {'
p42149
aS'    TimerOutput::Scope               t(computing_timer, "Refine");'
p42150
aS'    const FEValuesExtractors::Vector velocity(0);'
p42151
aS'    Vector<float> error_per_cell(fluid_tria.n_active_cells());'
p42152
aS'    KellyErrorEstimator<spacedim>::estimate(fluid_dh,'
p42153
aS'                                            QGauss<spacedim - 1>('
p42154
aS'                                              par.velocity_degree + 1),'
p42155
aS'                                            {},'
p42156
aS'                                            locally_relevant_solution,'
p42157
aS'                                            error_per_cell,'
p42158
aS'                                            fluid_fe->component_mask(velocity));'
p42159
aS'    if (par.refinement_strategy == "fixed_fraction")'
p42160
aS'      {'
p42161
aS'        parallel::distributed::GridRefinement::'
p42162
aS'          refine_and_coarsen_fixed_fraction(fluid_tria,'
p42163
aS'                                            error_per_cell,'
p42164
aS'                                            par.refinement_fraction,'
p42165
aS'                                            par.coarsening_fraction);'
p42166
aS'      }'
p42167
aS'    else if (par.refinement_strategy == "fixed_number")'
p42168
aS'      {'
p42169
aS'        parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p42170
aS'          fluid_tria,'
p42171
aS'          error_per_cell,'
p42172
aS'          par.refinement_fraction,'
p42173
aS'          par.coarsening_fraction,'
p42174
aS'          par.max_cells);'
p42175
aS'      }'
p42176
aS'    for (const auto &cell : fluid_tria.active_cell_iterators())'
p42177
aS'      {'
p42178
aS'        if (cell->refine_flag_set() &&'
p42179
aS'            cell->level() == par.max_level_refinement)'
p42180
aS'          cell->clear_refine_flag();'
p42181
aS'        if (cell->coarsen_flag_set() &&'
p42182
aS'            cell->level() == par.min_level_refinement)'
p42183
aS'          cell->clear_coarsen_flag();'
p42184
aS'      }'
p42185
aS'    parallel::distributed::SolutionTransfer<spacedim, LA::MPI::BlockVector>'
p42186
aS'      transfer(fluid_dh);'
p42187
aS'    fluid_tria.prepare_coarsening_and_refinement();'
p42188
aS'    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);'
p42189
aS'    fluid_tria.execute_coarsening_and_refinement();'
p42190
aS'    setup_dofs();'
p42191
aS'    transfer.interpolate(solution);'
p42192
aS'    constraints.distribute(solution);'
p42193
aS'    locally_relevant_solution = solution;'
p42194
aS'  }'
p42195
aS'  template <int dim, int spacedim>'
p42196
aS'  void'
p42197
aS'  StokesImmersedProblem<dim, spacedim>::output_results(const unsigned int cycle,'
p42198
aS'                                                       double time) const'
p42199
aS'  {'
p42200
aS'    TimerOutput::Scope t(computing_timer, "Output fluid");'
p42201
aS'    std::vector<std::string> solution_names(spacedim, "velocity");'
p42202
aS'    solution_names.emplace_back("pressure");'
p42203
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p42204
aS'      data_component_interpretation('
p42205
aS'        spacedim, DataComponentInterpretation::component_is_part_of_vector);'
p42206
aS'    data_component_interpretation.push_back('
p42207
aS'      DataComponentInterpretation::component_is_scalar);'
p42208
aS'    DataOut<spacedim> data_out;'
p42209
aS'    data_out.attach_dof_handler(fluid_dh);'
p42210
aS'    data_out.add_data_vector(locally_relevant_solution,'
p42211
aS'                             solution_names,'
p42212
aS'                             DataOut<spacedim>::type_dof_data,'
p42213
aS'                             data_component_interpretation);'
p42214
aS'    Vector<float> subdomain(fluid_tria.n_active_cells());'
p42215
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p42216
aS'      subdomain(i) = fluid_tria.locally_owned_subdomain();'
p42217
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p42218
aS'    data_out.build_patches();'
p42219
aS'    const std::string filename ='
p42220
aS'      "solution-" + Utilities::int_to_string(cycle) + ".vtu";'
p42221
aS'    data_out.write_vtu_in_parallel(par.output_directory + "/" + filename,'
p42222
aS'                                   mpi_communicator);'
p42223
aS'    static std::vector<std::pair<double, std::string>> times_and_names;'
p42224
aS'    times_and_names.push_back(std::make_pair(time, filename));'
p42225
aS'    std::ofstream ofile(par.output_directory + "/" + "solution.pvd");'
p42226
aS'    DataOutBase::write_pvd_record(ofile, times_and_names);'
p42227
aS'  }'
p42228
aS'  template <int dim, int spacedim>'
p42229
aS'  void StokesImmersedProblem<dim, spacedim>::output_particles('
p42230
aS'    const Particles::ParticleHandler<spacedim> &particles,'
p42231
aS'    std::string                                 fprefix,'
p42232
aS'    const unsigned int                          iter,'
p42233
aS'    const double                                time) const'
p42234
aS'  {'
p42235
aS'    Particles::DataOut<spacedim> particles_out;'
p42236
aS'    particles_out.build_patches(particles);'
p42237
aS'    const std::string filename ='
p42238
aS'      (fprefix + "-" + Utilities::int_to_string(iter) + ".vtu");'
p42239
aS'    particles_out.write_vtu_in_parallel(par.output_directory + "/" + filename,'
p42240
aS'                                        mpi_communicator);'
p42241
aS'    static std::map<std::string, std::vector<std::pair<double, std::string>>>'
p42242
aS'      times_and_names;'
p42243
aS'    if (times_and_names.find(fprefix) != times_and_names.end())'
p42244
aS'      times_and_names[fprefix].push_back(std::make_pair(time, filename));'
p42245
aS'    else'
p42246
aS'      times_and_names[fprefix] = {std::make_pair(time, filename)};'
p42247
aS'    std::ofstream ofile(par.output_directory + "/" + fprefix + ".pvd");'
p42248
aS'    DataOutBase::write_pvd_record(ofile, times_and_names[fprefix]);'
p42249
aS'  }'
p42250
aS'  template <int dim, int spacedim>'
p42251
aS'  void StokesImmersedProblem<dim, spacedim>::run()'
p42252
aS'  {'
p42253
aS'#ifdef USE_PETSC_LA'
p42254
aS'    pcout << "Running StokesImmersedProblem<"'
p42255
aS'          << Utilities::dim_string(dim, spacedim) << "> using PETSc."'
p42256
aS'          << std::endl;'
p42257
aS'#else'
p42258
aS'    pcout << "Running StokesImmersedProblem<"'
p42259
aS'          << Utilities::dim_string(dim, spacedim) << "> using Trilinos."'
p42260
aS'          << std::endl;'
p42261
aS'#endif'
p42262
aS'    par.prm.print_parameters(par.output_directory + "/" + "used_parameters_" +'
p42263
aS'                               std::to_string(dim) + std::to_string(spacedim) +'
p42264
aS'                               ".prm",'
p42265
aS'                             ParameterHandler::Short);'
p42266
aS'    const double time_step    = par.final_time / (par.number_of_time_steps - 1);'
p42267
aS'    double       time         = 0;'
p42268
aS'    unsigned int output_cycle = 0;'
p42269
aS'    for (unsigned int cycle = 0; cycle < par.number_of_time_steps;'
p42270
aS'         ++cycle, time += time_step)'
p42271
aS'      {'
p42272
aS'        par.set_time(time);'
p42273
aS'        pcout << "Cycle " << cycle << \':\' << std::endl'
p42274
aS'              << "Time : " << time << ", time step: " << time_step << std::endl;'
p42275
aS'        if (cycle == 0)'
p42276
aS'          {'
p42277
aS'            make_grid();'
p42278
aS'            initial_setup();'
p42279
aS'            setup_dofs();'
p42280
aS'            setup_tracer_particles();'
p42281
aS'            setup_solid_particles();'
p42282
aS'            tracer_particle_velocities.reinit('
p42283
aS'              locally_owned_tracer_particle_coordinates, mpi_communicator);'
p42284
aS'            output_results(output_cycle, time);'
p42285
aS'            {'
p42286
aS'              TimerOutput::Scope t(computing_timer, "Output tracer particles");'
p42287
aS'              output_particles(tracer_particle_handler,'
p42288
aS'                               "tracer",'
p42289
aS'                               output_cycle,'
p42290
aS'                               time);'
p42291
aS'            }'
p42292
aS'            {'
p42293
aS'              TimerOutput::Scope t(computing_timer, "Output solid particles");'
p42294
aS'              output_particles(solid_particle_handler,'
p42295
aS'                               "solid",'
p42296
aS'                               output_cycle,'
p42297
aS'                               time);'
p42298
aS'            }'
p42299
aS'          }'
p42300
aS'        else'
p42301
aS'          {'
p42302
aS'            TimerOutput::Scope t(computing_timer,'
p42303
aS'                                 "Set solid particle position");'
p42304
aS'            SolidPosition<spacedim> solid_position(par.angular_velocity,'
p42305
aS'                                                   time_step);'
p42306
aS'            solid_particle_handler.set_particle_positions(solid_position,'
p42307
aS'                                                          false);'
p42308
aS'          }'
p42309
aS'        {'
p42310
aS'          TimerOutput::Scope t(computing_timer, "Set tracer particle motion");'
p42311
aS'          Particles::Utilities::interpolate_field_on_particles('
p42312
aS'            fluid_dh,'
p42313
aS'            tracer_particle_handler,'
p42314
aS'            locally_relevant_solution,'
p42315
aS'            tracer_particle_velocities,'
p42316
aS'            fluid_fe->component_mask(FEValuesExtractors::Vector(0)));'
p42317
aS'          tracer_particle_velocities *= time_step;'
p42318
aS'          locally_relevant_tracer_particle_coordinates ='
p42319
aS'            tracer_particle_handler.locally_owned_particle_ids().tensor_product('
p42320
aS'              complete_index_set(spacedim));'
p42321
aS'          relevant_tracer_particle_displacements.reinit('
p42322
aS'            locally_owned_tracer_particle_coordinates,'
p42323
aS'            locally_relevant_tracer_particle_coordinates,'
p42324
aS'            mpi_communicator);'
p42325
aS'          relevant_tracer_particle_displacements = tracer_particle_velocities;'
p42326
aS'          tracer_particle_handler.set_particle_positions('
p42327
aS'            relevant_tracer_particle_displacements);'
p42328
aS'        }'
p42329
aS'        assemble_stokes_system();'
p42330
aS'        assemble_nitsche_restriction();'
p42331
aS'        solve();'
p42332
aS'        if (cycle % par.output_frequency == 0)'
p42333
aS'          {'
p42334
aS'            output_results(output_cycle, time);'
p42335
aS'            {'
p42336
aS'              TimerOutput::Scope t(computing_timer, "Output tracer particles");'
p42337
aS'              output_particles(tracer_particle_handler,'
p42338
aS'                               "tracer",'
p42339
aS'                               output_cycle,'
p42340
aS'                               time);'
p42341
aS'            }'
p42342
aS'            {'
p42343
aS'              TimerOutput::Scope t(computing_timer, "Output solid particles");'
p42344
aS'              output_particles(solid_particle_handler,'
p42345
aS'                               "solid",'
p42346
aS'                               output_cycle,'
p42347
aS'                               time);'
p42348
aS'            }'
p42349
aS'            ++output_cycle;'
p42350
aS'          }'
p42351
aS'        if (cycle % par.refinement_frequency == 0 &&'
p42352
aS'            cycle != par.number_of_time_steps - 1)'
p42353
aS'          refine_and_transfer();'
p42354
aS'      }'
p42355
aS'  }'
p42356
aS'} // namespace Step70'
p42357
aS'int main(int argc, char *argv[])'
p42358
ag24
aS'  using namespace Step70;'
p42359
aS'  using namespace dealii;'
p42360
aS'  deallog.depth_console(1);'
p42361
aS'  try'
p42362
aS'    {'
p42363
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p42364
aS'      std::string prm_file;'
p42365
aS'      if (argc > 1)'
p42366
aS'        prm_file = argv[1];'
p42367
aS'      else'
p42368
aS'        prm_file = "parameters.prm";'
p42369
aS'      if (prm_file.find("23") != std::string::npos)'
p42370
aS'        {'
p42371
aS'          StokesImmersedProblemParameters<2, 3> par;'
p42372
aS'          ParameterAcceptor::initialize(prm_file);'
p42373
aS'          StokesImmersedProblem<2, 3> problem(par);'
p42374
aS'          problem.run();'
p42375
aS'        }'
p42376
aS'      else if (prm_file.find("3") != std::string::npos)'
p42377
aS'        {'
p42378
aS'          StokesImmersedProblemParameters<3> par;'
p42379
aS'          ParameterAcceptor::initialize(prm_file);'
p42380
aS'          StokesImmersedProblem<3> problem(par);'
p42381
aS'          problem.run();'
p42382
aS'        }'
p42383
aS'      else'
p42384
aS'        {'
p42385
aS'          StokesImmersedProblemParameters<2> par;'
p42386
aS'          ParameterAcceptor::initialize(prm_file);'
p42387
aS'          StokesImmersedProblem<2> problem(par);'
p42388
aS'          problem.run();'
p42389
aS'        }'
p42390
aS'    }'
p42391
aS'  catch (std::exception &exc)'
p42392
aS'    {'
p42393
aS'      std::cerr << std::endl'
p42394
aS'                << std::endl'
p42395
aS'                << "----------------------------------------------------"'
p42396
aS'                << std::endl;'
p42397
aS'      std::cerr << "Exception on processing: " << std::endl'
p42398
aS'                << exc.what() << std::endl'
p42399
aS'                << "Aborting!" << std::endl'
p42400
aS'                << "----------------------------------------------------"'
p42401
aS'                << std::endl;'
p42402
aS'      return 1;'
p42403
aS'    }'
p42404
aS'  catch (...)'
p42405
aS'    {'
p42406
aS'      std::cerr << std::endl'
p42407
aS'                << std::endl'
p42408
aS'                << "----------------------------------------------------"'
p42409
aS'                << std::endl;'
p42410
aS'      std::cerr << "Unknown exception!" << std::endl'
p42411
aS'                << "Aborting!" << std::endl'
p42412
aS'                << "----------------------------------------------------"'
p42413
aS'                << std::endl;'
p42414
aS'      return 1;'
p42415
aS'    }'
p42416
aS'  return 0;'
p42417
ag32
aS'/* ---------------------------------------------------------------------'
p42418
aS' *'
p42419
aS' * Copyright (C) 2021 by the deal.II authors'
p42420
aS' *'
p42421
aS' * This file is part of the deal.II library.'
p42422
aS' *'
p42423
aS' * The deal.II library is free software; you can use it, redistribute'
p42424
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p42425
aS' * Public License as published by the Free Software Foundation; either'
p42426
aS' * version 2.1 of the License, or (at your option) any later version.'
p42427
aS' * The full text of the license can be found in the file LICENSE.md at'
p42428
aS' * the top level directory of deal.II.'
p42429
aS' *'
p42430
aS' * ---------------------------------------------------------------------'
p42431
aS' *'
p42432
aS' * Author: Jean-Paul Pelteret, 2021'
p42433
aS' */'
p42434
aS'#include <deal.II/algorithms/general_data_storage.h>'
p42435
aS'#include <deal.II/base/discrete_time.h>'
p42436
aS'#include <deal.II/base/numbers.h>'
p42437
aS'#include <deal.II/base/parameter_acceptor.h>'
p42438
aS'#include <deal.II/base/symmetric_tensor.h>'
p42439
aS'#include <deal.II/base/tensor.h>'
p42440
aS'#include <deal.II/base/timer.h>'
p42441
aS'#include <deal.II/base/utilities.h>'
p42442
aS'#include <deal.II/physics/transformations.h>'
p42443
aS'#include <deal.II/physics/elasticity/kinematics.h>'
p42444
aS'#include <deal.II/physics/elasticity/standard_tensors.h>'
p42445
aS'#include <deal.II/differentiation/ad.h>'
p42446
aS'#include <deal.II/differentiation/sd.h>'
p42447
aS'#include <fstream>'
p42448
aS'namespace Step71'
p42449
ag24
aS'  using namespace dealii;'
p42450
aS'  namespace SimpleExample'
p42451
aS'  {'
p42452
aS'    template <typename NumberType>'
p42453
aS'    NumberType f(const NumberType &x, const NumberType &y)'
p42454
aS'    {'
p42455
aS'      return std::cos(y / x);'
p42456
aS'    }'
p42457
aS'    double df_dx(const double x, const double y);'
p42458
aS'    double df_dy(const double x, const double y);'
p42459
aS'    double d2f_dx_dx(const double x, const double y);'
p42460
aS'    double d2f_dx_dy(const double x, const double y);'
p42461
aS'    double d2f_dy_dx(const double x, const double y);'
p42462
aS'    double d2f_dy_dy(const double x, const double y);'
p42463
aS'    void'
p42464
aS'    run_and_verify_ad(const double x, const double y, const double tol = 1e-12)'
p42465
aS'    {'
p42466
aS'      constexpr unsigned int                     dim = 1;'
p42467
aS'      constexpr Differentiation::AD::NumberTypes ADTypeCode ='
p42468
aS'        Differentiation::AD::NumberTypes::sacado_dfad_dfad;'
p42469
aS'      using ADHelper ='
p42470
aS'        Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;'
p42471
aS'      constexpr unsigned int n_independent_variables = 2;'
p42472
aS'      ADHelper ad_helper(n_independent_variables);'
p42473
aS'      using ADNumberType = typename ADHelper::ad_type;'
p42474
aS'      ad_helper.register_independent_variables({x, y});'
p42475
aS'      const std::vector<ADNumberType> independent_variables_ad ='
p42476
aS'        ad_helper.get_sensitive_variables();'
p42477
aS'      const ADNumberType &x_ad = independent_variables_ad[0];'
p42478
aS'      const ADNumberType &y_ad = independent_variables_ad[1];'
p42479
aS'      const ADNumberType f_ad = f(x_ad, y_ad);'
p42480
aS'      ad_helper.register_dependent_variable(f_ad);'
p42481
aS'      Vector<double>     Df(ad_helper.n_dependent_variables());'
p42482
aS'      FullMatrix<double> D2f(ad_helper.n_dependent_variables(),'
p42483
aS'                             ad_helper.n_independent_variables());'
p42484
aS'      const double computed_f = ad_helper.compute_value();'
p42485
aS'      ad_helper.compute_gradient(Df);'
p42486
aS'      ad_helper.compute_hessian(D2f);'
p42487
aS'      AssertThrow(std::abs(f(x, y) - computed_f) < tol,'
p42488
aS'                  ExcMessage(std::string("Incorrect value computed for f. ") +'
p42489
aS'                             std::string("Hand-calculated value: ") +'
p42490
aS'                             Utilities::to_string(f(x, y)) +'
p42491
aS'                             std::string(" ; ") +'
p42492
aS'                             std::string("Value computed by AD: ") +'
p42493
aS'                             Utilities::to_string(computed_f)));'
p42494
aS'      const double computed_df_dx = Df[0];'
p42495
aS'      const double computed_df_dy = Df[1];'
p42496
aS'      AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,'
p42497
aS'                  ExcMessage('
p42498
aS'                    std::string("Incorrect value computed for df/dx. ") +'
p42499
aS'                    std::string("Hand-calculated value: ") +'
p42500
aS'                    Utilities::to_string(df_dx(x, y)) + std::string(" ; ") +'
p42501
aS'                    std::string("Value computed by AD: ") +'
p42502
aS'                    Utilities::to_string(computed_df_dx)));'
p42503
aS'      AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,'
p42504
aS'                  ExcMessage('
p42505
aS'                    std::string("Incorrect value computed for df/dy. ") +'
p42506
aS'                    std::string("Hand-calculated value: ") +'
p42507
aS'                    Utilities::to_string(df_dy(x, y)) + std::string(" ; ") +'
p42508
aS'                    std::string("Value computed by AD: ") +'
p42509
aS'                    Utilities::to_string(computed_df_dy)));'
p42510
aS'      const double computed_d2f_dx_dx = D2f[0][0];'
p42511
aS'      const double computed_d2f_dx_dy = D2f[0][1];'
p42512
aS'      const double computed_d2f_dy_dx = D2f[1][0];'
p42513
aS'      const double computed_d2f_dy_dy = D2f[1][1];'
p42514
aS'      AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,'
p42515
aS'                  ExcMessage('
p42516
aS'                    std::string("Incorrect value computed for d2f/dx_dx. ") +'
p42517
aS'                    std::string("Hand-calculated value: ") +'
p42518
aS'                    Utilities::to_string(d2f_dx_dx(x, y)) + std::string(" ; ") +'
p42519
aS'                    std::string("Value computed by AD: ") +'
p42520
aS'                    Utilities::to_string(computed_d2f_dx_dx)));'
p42521
aS'      AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,'
p42522
aS'                  ExcMessage('
p42523
aS'                    std::string("Incorrect value computed for d2f/dx_dy. ") +'
p42524
aS'                    std::string("Hand-calculated value: ") +'
p42525
aS'                    Utilities::to_string(d2f_dx_dy(x, y)) + std::string(" ; ") +'
p42526
aS'                    std::string("Value computed by AD: ") +'
p42527
aS'                    Utilities::to_string(computed_d2f_dx_dy)));'
p42528
aS'      AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,'
p42529
aS'                  ExcMessage('
p42530
aS'                    std::string("Incorrect value computed for d2f/dy_dx. ") +'
p42531
aS'                    std::string("Hand-calculated value: ") +'
p42532
aS'                    Utilities::to_string(d2f_dy_dx(x, y)) + std::string(" ; ") +'
p42533
aS'                    std::string("Value computed by AD: ") +'
p42534
aS'                    Utilities::to_string(computed_d2f_dy_dx)));'
p42535
aS'      AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,'
p42536
aS'                  ExcMessage('
p42537
aS'                    std::string("Incorrect value computed for d2f/dy_dy. ") +'
p42538
aS'                    std::string("Hand-calculated value: ") +'
p42539
aS'                    Utilities::to_string(d2f_dy_dy(x, y)) + std::string(" ; ") +'
p42540
aS'                    std::string("Value computed by AD: ") +'
p42541
aS'                    Utilities::to_string(computed_d2f_dy_dy)));'
p42542
aS'    }'
p42543
aS'    double df_dx(const double x, const double y)'
p42544
aS'    {'
p42545
aS'      Assert(x != 0.0, ExcDivideByZero());'
p42546
aS'      return y * std::sin(y / x) / (x * x);'
p42547
aS'    }'
p42548
aS'    double df_dy(const double x, const double y)'
p42549
aS'    {'
p42550
aS'      return -std::sin(y / x) / x;'
p42551
aS'    }'
p42552
aS'    double d2f_dx_dx(const double x, const double y)'
p42553
aS'    {'
p42554
aS'      return -y * (2 * x * std::sin(y / x) + y * std::cos(y / x)) /'
p42555
aS'             (x * x * x * x);'
p42556
aS'    }'
p42557
aS'    double d2f_dx_dy(const double x, const double y)'
p42558
aS'    {'
p42559
aS'      return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);'
p42560
aS'    }'
p42561
aS'    double d2f_dy_dx(const double x, const double y)'
p42562
aS'    {'
p42563
aS'      return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);'
p42564
aS'    }'
p42565
aS'    double d2f_dy_dy(const double x, const double y)'
p42566
aS'    {'
p42567
aS'      return -(std::cos(y / x)) / (x * x);'
p42568
aS'    }'
p42569
aS'    void'
p42570
aS'    run_and_verify_sd(const double x, const double y, const double tol = 1e-12)'
p42571
aS'    {'
p42572
aS'      const Differentiation::SD::Expression x_sd("x");'
p42573
aS'      const Differentiation::SD::Expression y_sd("y");'
p42574
aS'      const Differentiation::SD::Expression f_sd = f(x_sd, y_sd);'
p42575
aS'      const Differentiation::SD::Expression df_dx_sd = f_sd.differentiate(x_sd);'
p42576
aS'      const Differentiation::SD::Expression df_dy_sd = f_sd.differentiate(y_sd);'
p42577
aS'      const Differentiation::SD::Expression d2f_dx_dx_sd ='
p42578
aS'        df_dx_sd.differentiate(x_sd);'
p42579
aS'      const Differentiation::SD::Expression d2f_dx_dy_sd ='
p42580
aS'        df_dx_sd.differentiate(y_sd);'
p42581
aS'      const Differentiation::SD::Expression d2f_dy_dx_sd ='
p42582
aS'        df_dy_sd.differentiate(x_sd);'
p42583
aS'      const Differentiation::SD::Expression d2f_dy_dy_sd ='
p42584
aS'        df_dy_sd.differentiate(y_sd);'
p42585
aS'      const Differentiation::SD::types::substitution_map substitution_map ='
p42586
aS'        Differentiation::SD::make_substitution_map('
p42587
aS'          std::pair<Differentiation::SD::Expression, double>{x_sd, x},'
p42588
aS'          std::pair<Differentiation::SD::Expression, double>{y_sd, y});'
p42589
aS'      const double computed_f ='
p42590
aS'        f_sd.substitute_and_evaluate<double>(substitution_map);'
p42591
aS'      AssertThrow(std::abs(f(x, y) - computed_f) < tol,'
p42592
aS'                  ExcMessage(std::string("Incorrect value computed for f. ") +'
p42593
aS'                             std::string("Hand-calculated value: ") +'
p42594
aS'                             Utilities::to_string(f(x, y)) +'
p42595
aS'                             std::string(" ; ") +'
p42596
aS'                             std::string("Value computed by AD: ") +'
p42597
aS'                             Utilities::to_string(computed_f)));'
p42598
aS'      const double computed_df_dx ='
p42599
aS'        df_dx_sd.substitute_and_evaluate<double>(substitution_map);'
p42600
aS'      const double computed_df_dy ='
p42601
aS'        df_dy_sd.substitute_and_evaluate<double>(substitution_map);'
p42602
aS'      AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,'
p42603
aS'                  ExcMessage('
p42604
aS'                    std::string("Incorrect value computed for df/dx. ") +'
p42605
aS'                    std::string("Hand-calculated value: ") +'
p42606
aS'                    Utilities::to_string(df_dx(x, y)) + std::string(" ; ") +'
p42607
aS'                    std::string("Value computed by AD: ") +'
p42608
aS'                    Utilities::to_string(computed_df_dx)));'
p42609
aS'      AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,'
p42610
aS'                  ExcMessage('
p42611
aS'                    std::string("Incorrect value computed for df/dy. ") +'
p42612
aS'                    std::string("Hand-calculated value: ") +'
p42613
aS'                    Utilities::to_string(df_dy(x, y)) + std::string(" ; ") +'
p42614
aS'                    std::string("Value computed by AD: ") +'
p42615
aS'                    Utilities::to_string(computed_df_dy)));'
p42616
aS'      const double computed_d2f_dx_dx ='
p42617
aS'        d2f_dx_dx_sd.substitute_and_evaluate<double>(substitution_map);'
p42618
aS'      const double computed_d2f_dx_dy ='
p42619
aS'        d2f_dx_dy_sd.substitute_and_evaluate<double>(substitution_map);'
p42620
aS'      const double computed_d2f_dy_dx ='
p42621
aS'        d2f_dy_dx_sd.substitute_and_evaluate<double>(substitution_map);'
p42622
aS'      const double computed_d2f_dy_dy ='
p42623
aS'        d2f_dy_dy_sd.substitute_and_evaluate<double>(substitution_map);'
p42624
aS'      AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,'
p42625
aS'                  ExcMessage('
p42626
aS'                    std::string("Incorrect value computed for d2f/dx_dx. ") +'
p42627
aS'                    std::string("Hand-calculated value: ") +'
p42628
aS'                    Utilities::to_string(d2f_dx_dx(x, y)) + std::string(" ; ") +'
p42629
aS'                    std::string("Value computed by SD: ") +'
p42630
aS'                    Utilities::to_string(computed_d2f_dx_dx)));'
p42631
aS'      AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,'
p42632
aS'                  ExcMessage('
p42633
aS'                    std::string("Incorrect value computed for d2f/dx_dy. ") +'
p42634
aS'                    std::string("Hand-calculated value: ") +'
p42635
aS'                    Utilities::to_string(d2f_dx_dy(x, y)) + std::string(" ; ") +'
p42636
aS'                    std::string("Value computed by SD: ") +'
p42637
aS'                    Utilities::to_string(computed_d2f_dx_dy)));'
p42638
aS'      AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,'
p42639
aS'                  ExcMessage('
p42640
aS'                    std::string("Incorrect value computed for d2f/dy_dx. ") +'
p42641
aS'                    std::string("Hand-calculated value: ") +'
p42642
aS'                    Utilities::to_string(d2f_dy_dx(x, y)) + std::string(" ; ") +'
p42643
aS'                    std::string("Value computed by SD: ") +'
p42644
aS'                    Utilities::to_string(computed_d2f_dy_dx)));'
p42645
aS'      AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,'
p42646
aS'                  ExcMessage('
p42647
aS'                    std::string("Incorrect value computed for d2f/dy_dy. ") +'
p42648
aS'                    std::string("Hand-calculated value: ") +'
p42649
aS'                    Utilities::to_string(d2f_dy_dy(x, y)) + std::string(" ; ") +'
p42650
aS'                    std::string("Value computed by SD: ") +'
p42651
aS'                    Utilities::to_string(computed_d2f_dy_dy)));'
p42652
aS'    }'
p42653
aS'    void run()'
p42654
aS'    {'
p42655
aS'      const double x = 1.23;'
p42656
aS'      const double y = 0.91;'
p42657
aS'      std::cout << "Simple example using automatic differentiation..."'
p42658
aS'                << std::endl;'
p42659
aS'      run_and_verify_ad(x, y);'
p42660
aS'      std::cout << "... all calculations are correct!" << std::endl;'
p42661
aS'      std::cout << "Simple example using symbolic differentiation."'
p42662
aS'                << std::endl;'
p42663
aS'      run_and_verify_sd(x, y);'
p42664
aS'      std::cout << "... all calculations are correct!" << std::endl;'
p42665
aS'    }'
p42666
aS'  } // namespace SimpleExample'
p42667
aS'  namespace CoupledConstitutiveLaws'
p42668
aS'  {'
p42669
aS'    class ConstitutiveParameters : public ParameterAcceptor'
p42670
aS'    {'
p42671
aS'    public:'
p42672
aS'      ConstitutiveParameters();'
p42673
aS'      double mu_e       = 30.0e3;'
p42674
aS'      double mu_e_inf   = 250.0e3;'
p42675
aS'      double mu_e_h_sat = 212.2e3;'
p42676
aS'      double nu_e       = 0.49;'
p42677
aS'      double mu_v       = 20.0e3;'
p42678
aS'      double mu_v_inf   = 35.0e3;'
p42679
aS'      double mu_v_h_sat = 92.84e3;'
p42680
aS'      double tau_v      = 0.6;'
p42681
aS'      double mu_r = 6.0;'
p42682
aS'      bool initialized = false;'
p42683
aS'    };'
p42684
aS'    ConstitutiveParameters::ConstitutiveParameters()'
p42685
aS'      : ParameterAcceptor("/Coupled Constitutive Laws/Constitutive Parameters/")'
p42686
aS'    {'
p42687
aS'      add_parameter("Elastic shear modulus", mu_e);'
p42688
aS'      add_parameter("Elastic shear modulus at magnetic saturation", mu_e_inf);'
p42689
aS'      add_parameter('
p42690
aS'        "Saturation magnetic field strength for elastic shear modulus",'
p42691
aS'        mu_e_h_sat);'
p42692
aS'      add_parameter("Poisson ratio", nu_e);'
p42693
aS'      add_parameter("Viscoelastic shear modulus", mu_v);'
p42694
aS'      add_parameter("Viscoelastic shear modulus at magnetic saturation",'
p42695
aS'                    mu_v_inf);'
p42696
aS'      add_parameter('
p42697
aS'        "Saturation magnetic field strength for viscoelastic shear modulus",'
p42698
aS'        mu_v_h_sat);'
p42699
aS'      add_parameter("Characteristic relaxation time", tau_v);'
p42700
aS'      add_parameter("Relative magnetic permeability", mu_r);'
p42701
aS'      parse_parameters_call_back.connect([&]() { initialized = true; });'
p42702
aS'    }'
p42703
aS'    template <int dim>'
p42704
aS'    class Coupled_Magnetomechanical_Constitutive_Law_Base'
p42705
aS'    {'
p42706
aS'    public:'
p42707
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base('
p42708
aS'        const ConstitutiveParameters &constitutive_parameters);'
p42709
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p42710
aS'                                        const Tensor<1, dim> &         H,'
p42711
aS'                                        const DiscreteTime &time) = 0;'
p42712
aS'      virtual double get_psi() const = 0;'
p42713
aS'      virtual Tensor<1, dim> get_B() const = 0;'
p42714
aS'      virtual SymmetricTensor<2, dim> get_S() const = 0;'
p42715
aS'      virtual SymmetricTensor<2, dim> get_DD() const = 0;'
p42716
aS'      virtual Tensor<3, dim> get_PP() const = 0;'
p42717
aS'      virtual SymmetricTensor<4, dim> get_HH() const = 0;'
p42718
aS'      virtual void update_end_of_timestep()'
p42719
aS'      {}'
p42720
aS'    protected:'
p42721
aS'      const ConstitutiveParameters &constitutive_parameters;'
p42722
aS'      double get_mu_e() const;'
p42723
aS'      double get_mu_e_inf() const;'
p42724
aS'      double get_mu_e_h_sat() const;'
p42725
aS'      double get_nu_e() const;'
p42726
aS'      double get_lambda_e() const;'
p42727
aS'      double get_kappa_e() const;'
p42728
aS'      double get_mu_v() const;'
p42729
aS'      double get_mu_v_inf() const;'
p42730
aS'      double get_mu_v_h_sat() const;'
p42731
aS'      double get_tau_v() const;'
p42732
aS'      double get_mu_r() const;'
p42733
aS'      constexpr double get_mu_0() const;'
p42734
aS'      double           get_delta_t(const DiscreteTime &time) const;'
p42735
aS'    };'
p42736
aS'    template <int dim>'
p42737
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::'
p42738
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base('
p42739
aS'        const ConstitutiveParameters &constitutive_parameters)'
p42740
aS'      : constitutive_parameters(constitutive_parameters)'
p42741
aS'    {'
p42742
aS'      Assert(get_kappa_e() > 0, ExcInternalError());'
p42743
aS'    }'
p42744
aS'    template <int dim>'
p42745
aS'    double'
p42746
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e() const'
p42747
aS'    {'
p42748
aS'      return constitutive_parameters.mu_e;'
p42749
aS'    }'
p42750
aS'    template <int dim>'
p42751
aS'    double'
p42752
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_inf() const'
p42753
aS'    {'
p42754
aS'      return constitutive_parameters.mu_e_inf;'
p42755
aS'    }'
p42756
aS'    template <int dim>'
p42757
aS'    double'
p42758
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_h_sat() const'
p42759
aS'    {'
p42760
aS'      return constitutive_parameters.mu_e_h_sat;'
p42761
aS'    }'
p42762
aS'    template <int dim>'
p42763
aS'    double'
p42764
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_nu_e() const'
p42765
aS'    {'
p42766
aS'      return constitutive_parameters.nu_e;'
p42767
aS'    }'
p42768
aS'    template <int dim>'
p42769
aS'    double'
p42770
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_lambda_e() const'
p42771
aS'    {'
p42772
aS'      return 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());'
p42773
aS'    }'
p42774
aS'    template <int dim>'
p42775
aS'    double'
p42776
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_kappa_e() const'
p42777
aS'    {'
p42778
aS'      return (2.0 * get_mu_e() * (1.0 + get_nu_e())) /'
p42779
aS'             (3.0 * (1.0 - 2.0 * get_nu_e()));'
p42780
aS'    }'
p42781
aS'    template <int dim>'
p42782
aS'    double'
p42783
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v() const'
p42784
aS'    {'
p42785
aS'      return constitutive_parameters.mu_v;'
p42786
aS'    }'
p42787
aS'    template <int dim>'
p42788
aS'    double'
p42789
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_inf() const'
p42790
aS'    {'
p42791
aS'      return constitutive_parameters.mu_v_inf;'
p42792
aS'    }'
p42793
aS'    template <int dim>'
p42794
aS'    double'
p42795
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_h_sat() const'
p42796
aS'    {'
p42797
aS'      return constitutive_parameters.mu_v_h_sat;'
p42798
aS'    }'
p42799
aS'    template <int dim>'
p42800
aS'    double'
p42801
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_tau_v() const'
p42802
aS'    {'
p42803
aS'      return constitutive_parameters.tau_v;'
p42804
aS'    }'
p42805
aS'    template <int dim>'
p42806
aS'    double'
p42807
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_r() const'
p42808
aS'    {'
p42809
aS'      return constitutive_parameters.mu_r;'
p42810
aS'    }'
p42811
aS'    template <int dim>'
p42812
aS'    constexpr double'
p42813
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_0() const'
p42814
aS'    {'
p42815
aS'      return 4.0 * numbers::PI * 1e-7;'
p42816
aS'    }'
p42817
aS'    template <int dim>'
p42818
aS'    double Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_delta_t('
p42819
aS'      const DiscreteTime &time) const'
p42820
aS'    {'
p42821
aS'      return time.get_previous_step_size();'
p42822
aS'    }'
p42823
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42824
aS'    class Magnetoelastic_Constitutive_Law_AD final'
p42825
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p42826
aS'    {'
p42827
aS'      using ADHelper ='
p42828
aS'        Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;'
p42829
aS'      using ADNumberType = typename ADHelper::ad_type;'
p42830
aS'    public:'
p42831
aS'      Magnetoelastic_Constitutive_Law_AD('
p42832
aS'        const ConstitutiveParameters &constitutive_parameters);'
p42833
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p42834
aS'                                        const Tensor<1, dim> &         H,'
p42835
aS'                                        const DiscreteTime &) override;'
p42836
aS'      virtual double get_psi() const override;'
p42837
aS'      virtual Tensor<1, dim> get_B() const override;'
p42838
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p42839
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p42840
aS'      virtual Tensor<3, dim> get_PP() const override;'
p42841
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p42842
aS'    private:'
p42843
aS'      const FEValuesExtractors::Vector             H_components;'
p42844
aS'      const FEValuesExtractors::SymmetricTensor<2> C_components;'
p42845
aS'      ADHelper ad_helper;'
p42846
aS'      double             psi;'
p42847
aS'      Vector<double>     Dpsi;'
p42848
aS'      FullMatrix<double> D2psi;'
p42849
aS'    };'
p42850
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42851
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::'
p42852
aS'      Magnetoelastic_Constitutive_Law_AD('
p42853
aS'        const ConstitutiveParameters &constitutive_parameters)'
p42854
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p42855
aS'          constitutive_parameters)'
p42856
aS'      , H_components(0)'
p42857
aS'      , C_components(Tensor<1, dim>::n_independent_components)'
p42858
aS'      , ad_helper(Tensor<1, dim>::n_independent_components +'
p42859
aS'                  SymmetricTensor<2, dim>::n_independent_components)'
p42860
aS'      , psi(0.0)'
p42861
aS'      , Dpsi(ad_helper.n_independent_variables())'
p42862
aS'      , D2psi(ad_helper.n_independent_variables(),'
p42863
aS'              ad_helper.n_independent_variables())'
p42864
aS'    {}'
p42865
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42866
aS'    void'
p42867
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::update_internal_data('
p42868
aS'      const SymmetricTensor<2, dim> &C,'
p42869
aS'      const Tensor<1, dim> &         H,'
p42870
aS'      const DiscreteTime &)'
p42871
aS'    {'
p42872
aS'      Assert(determinant(C) > 0, ExcInternalError());'
p42873
aS'      ad_helper.reset();'
p42874
aS'      ad_helper.register_independent_variable(H, H_components);'
p42875
aS'      ad_helper.register_independent_variable(C, C_components);'
p42876
aS'      const Tensor<1, dim, ADNumberType> H_ad ='
p42877
aS'        ad_helper.get_sensitive_variables(H_components);'
p42878
aS'      const SymmetricTensor<2, dim, ADNumberType> C_ad ='
p42879
aS'        ad_helper.get_sensitive_variables(C_components);'
p42880
aS'      const ADNumberType det_F_ad = std::sqrt(determinant(C_ad));'
p42881
aS'      const SymmetricTensor<2, dim, ADNumberType> C_inv_ad = invert(C_ad);'
p42882
aS'      AssertThrow(det_F_ad > ADNumberType(0.0),'
p42883
aS'                  ExcMessage("Volumetric Jacobian must be positive."));'
p42884
aS'      const ADNumberType f_mu_e_ad ='
p42885
aS'        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *'
p42886
aS'                std::tanh((2.0 * H_ad * H_ad) /'
p42887
aS'                          (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()));'
p42888
aS'      const ADNumberType psi_ad ='
p42889
aS'        0.5 * this->get_mu_e() * f_mu_e_ad *'
p42890
aS'          (trace(C_ad) - dim - 2.0 * std::log(det_F_ad))                 //'
p42891
aS'        + this->get_lambda_e() * std::log(det_F_ad) * std::log(det_F_ad) //'
p42892
aS'        - 0.5 * this->get_mu_0() * this->get_mu_r() * det_F_ad *'
p42893
aS'            (H_ad * C_inv_ad * H_ad); //'
p42894
aS'      ad_helper.register_dependent_variable(psi_ad);'
p42895
aS'      psi = ad_helper.compute_value();'
p42896
aS'      ad_helper.compute_gradient(Dpsi);'
p42897
aS'      ad_helper.compute_hessian(D2psi);'
p42898
aS'    }'
p42899
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42900
aS'    double Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_psi() const'
p42901
aS'    {'
p42902
aS'      return psi;'
p42903
aS'    }'
p42904
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42905
aS'    Tensor<1, dim>'
p42906
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_B() const'
p42907
aS'    {'
p42908
aS'      const Tensor<1, dim> dpsi_dH ='
p42909
aS'        ad_helper.extract_gradient_component(Dpsi, H_components);'
p42910
aS'      return -dpsi_dH;'
p42911
aS'    }'
p42912
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42913
aS'    SymmetricTensor<2, dim>'
p42914
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_S() const'
p42915
aS'    {'
p42916
aS'      const SymmetricTensor<2, dim> dpsi_dC ='
p42917
aS'        ad_helper.extract_gradient_component(Dpsi, C_components);'
p42918
aS'      return 2.0 * dpsi_dC;'
p42919
aS'    }'
p42920
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42921
aS'    SymmetricTensor<2, dim>'
p42922
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_DD() const'
p42923
aS'    {'
p42924
aS'      const Tensor<2, dim> dpsi_dH_dH ='
p42925
aS'        ad_helper.extract_hessian_component(D2psi, H_components, H_components);'
p42926
aS'      return -symmetrize(dpsi_dH_dH);'
p42927
aS'    }'
p42928
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42929
aS'    Tensor<3, dim>'
p42930
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_PP() const'
p42931
aS'    {'
p42932
aS'      const Tensor<3, dim> dpsi_dC_dH ='
p42933
aS'        ad_helper.extract_hessian_component(D2psi, C_components, H_components);'
p42934
aS'      return -2.0 * dpsi_dC_dH;'
p42935
aS'    }'
p42936
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p42937
aS'    SymmetricTensor<4, dim>'
p42938
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_HH() const'
p42939
aS'    {'
p42940
aS'      const SymmetricTensor<4, dim> dpsi_dC_dC ='
p42941
aS'        ad_helper.extract_hessian_component(D2psi, C_components, C_components);'
p42942
aS'      return 4.0 * dpsi_dC_dC;'
p42943
aS'    }'
p42944
aS'    template <int dim>'
p42945
aS'    class Magnetoviscoelastic_Constitutive_Law_SD final'
p42946
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p42947
aS'    {'
p42948
aS'    public:'
p42949
aS'      Magnetoviscoelastic_Constitutive_Law_SD('
p42950
aS'        const ConstitutiveParameters &               constitutive_parameters,'
p42951
aS'        const Differentiation::SD::OptimizerType     optimizer_type,'
p42952
aS'        const Differentiation::SD::OptimizationFlags optimization_flags);'
p42953
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p42954
aS'                                        const Tensor<1, dim> &         H,'
p42955
aS'                                        const DiscreteTime &time) override;'
p42956
aS'      virtual double get_psi() const override;'
p42957
aS'      virtual Tensor<1, dim> get_B() const override;'
p42958
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p42959
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p42960
aS'      virtual Tensor<3, dim> get_PP() const override;'
p42961
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p42962
aS'      virtual void update_end_of_timestep() override;'
p42963
aS'    private:'
p42964
aS'      SymmetricTensor<2, dim> Q_t;'
p42965
aS'      SymmetricTensor<2, dim> Q_t1;'
p42966
aS'      const Differentiation::SD::Expression mu_e_sd;'
p42967
aS'      const Differentiation::SD::Expression mu_e_inf_sd;'
p42968
aS'      const Differentiation::SD::Expression mu_e_h_sat_sd;'
p42969
aS'      const Differentiation::SD::Expression lambda_e_sd;'
p42970
aS'      const Differentiation::SD::Expression mu_v_sd;'
p42971
aS'      const Differentiation::SD::Expression mu_v_inf_sd;'
p42972
aS'      const Differentiation::SD::Expression mu_v_h_sat_sd;'
p42973
aS'      const Differentiation::SD::Expression tau_v_sd;'
p42974
aS'      const Differentiation::SD::Expression delta_t_sd;'
p42975
aS'      const Differentiation::SD::Expression mu_r_sd;'
p42976
aS'      const Tensor<1, dim, Differentiation::SD::Expression>          H_sd;'
p42977
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_sd;'
p42978
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t_sd;'
p42979
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t1_sd;'
p42980
aS'      Differentiation::SD::Expression                          psi_sd;'
p42981
aS'      Tensor<1, dim, Differentiation::SD::Expression>          B_sd;'
p42982
aS'      SymmetricTensor<2, dim, Differentiation::SD::Expression> S_sd;'
p42983
aS'      SymmetricTensor<2, dim, Differentiation::SD::Expression> BB_sd;'
p42984
aS'      Tensor<3, dim, Differentiation::SD::Expression>          PP_sd;'
p42985
aS'      SymmetricTensor<4, dim, Differentiation::SD::Expression> HH_sd;'
p42986
aS'      Differentiation::SD::BatchOptimizer<double> optimizer;'
p42987
aS'      Differentiation::SD::types::substitution_map'
p42988
aS'      make_substitution_map(const SymmetricTensor<2, dim> &C,'
p42989
aS'                            const Tensor<1, dim> &         H,'
p42990
aS'                            const double                   delta_t) const;'
p42991
aS'      void initialize_optimizer();'
p42992
aS'    };'
p42993
aS'    template <int dim>'
p42994
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::'
p42995
aS'      Magnetoviscoelastic_Constitutive_Law_SD('
p42996
aS'        const ConstitutiveParameters &               constitutive_parameters,'
p42997
aS'        const Differentiation::SD::OptimizerType     optimizer_type,'
p42998
aS'        const Differentiation::SD::OptimizationFlags optimization_flags)'
p42999
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p43000
aS'          constitutive_parameters)'
p43001
aS'      , Q_t(Physics::Elasticity::StandardTensors<dim>::I)'
p43002
aS'      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)'
p43003
aS'      , mu_e_sd("mu_e")'
p43004
aS'      , mu_e_inf_sd("mu_e_inf")'
p43005
aS'      , mu_e_h_sat_sd("mu_e_h_sat")'
p43006
aS'      , lambda_e_sd("lambda_e")'
p43007
aS'      , mu_v_sd("mu_v")'
p43008
aS'      , mu_v_inf_sd("mu_v_inf")'
p43009
aS'      , mu_v_h_sat_sd("mu_v_h_sat")'
p43010
aS'      , tau_v_sd("tau_v")'
p43011
aS'      , delta_t_sd("delta_t")'
p43012
aS'      , mu_r_sd("mu_r")'
p43013
aS'      , H_sd(Differentiation::SD::make_vector_of_symbols<dim>("H"))'
p43014
aS'      , C_sd(Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("C"))'
p43015
aS'      , Q_t_sd('
p43016
aS'          Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("Q_t"))'
p43017
aS'      , Q_t1_sd('
p43018
aS'          Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("Q_t1"))'
p43019
aS'      , optimizer(optimizer_type, optimization_flags)'
p43020
aS'    {'
p43021
aS'      initialize_optimizer();'
p43022
aS'    }'
p43023
aS'    template <int dim>'
p43024
aS'    Differentiation::SD::types::substitution_map'
p43025
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::make_substitution_map('
p43026
aS'      const SymmetricTensor<2, dim> &C,'
p43027
aS'      const Tensor<1, dim> &         H,'
p43028
aS'      const double                   delta_t) const'
p43029
aS'    {'
p43030
aS'      return Differentiation::SD::make_substitution_map('
p43031
aS'        std::make_pair(mu_e_sd, this->get_mu_e()),'
p43032
aS'        std::make_pair(mu_e_inf_sd, this->get_mu_e_inf()),'
p43033
aS'        std::make_pair(mu_e_h_sat_sd, this->get_mu_e_h_sat()),'
p43034
aS'        std::make_pair(lambda_e_sd, this->get_lambda_e()),'
p43035
aS'        std::make_pair(mu_v_sd, this->get_mu_v()),'
p43036
aS'        std::make_pair(mu_v_inf_sd, this->get_mu_v_inf()),'
p43037
aS'        std::make_pair(mu_v_h_sat_sd, this->get_mu_v_h_sat()),'
p43038
aS'        std::make_pair(tau_v_sd, this->get_tau_v()),'
p43039
aS'        std::make_pair(delta_t_sd, delta_t),'
p43040
aS'        std::make_pair(mu_r_sd, this->get_mu_r()),'
p43041
aS'        std::make_pair(H_sd, H),'
p43042
aS'        std::make_pair(C_sd, C),'
p43043
aS'        std::make_pair(Q_t_sd, Q_t),'
p43044
aS'        std::make_pair(Q_t1_sd, Q_t1));'
p43045
aS'    }'
p43046
aS'    template <int dim>'
p43047
aS'    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::initialize_optimizer()'
p43048
aS'    {'
p43049
aS'      const Differentiation::SD::Expression det_F_sd ='
p43050
aS'        std::sqrt(determinant(C_sd));'
p43051
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_inv_sd ='
p43052
aS'        invert(C_sd);'
p43053
aS'      const Differentiation::SD::Expression f_mu_e_sd ='
p43054
aS'        1.0 +'
p43055
aS'        (mu_e_inf_sd / mu_e_sd - 1.0) *'
p43056
aS'          std::tanh((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));'
p43057
aS'      const Differentiation::SD::Expression psi_ME_sd ='
p43058
aS'        0.5 * mu_e_sd * f_mu_e_sd *'
p43059
aS'          (trace(C_sd) - dim - 2.0 * std::log(det_F_sd)) +'
p43060
aS'        lambda_e_sd * std::log(det_F_sd) * std::log(det_F_sd) -'
p43061
aS'        0.5 * this->get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);'
p43062
aS'      const Differentiation::SD::Expression f_mu_v_sd ='
p43063
aS'        1.0 +'
p43064
aS'        (mu_v_inf_sd / mu_v_sd - 1.0) *'
p43065
aS'          std::tanh((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));'
p43066
aS'      const Differentiation::SD::Expression psi_MVE_sd ='
p43067
aS'        0.5 * mu_v_sd * f_mu_v_sd *'
p43068
aS'        (Q_t_sd * (std::pow(det_F_sd, -2.0 / dim) * C_sd) - dim -'
p43069
aS'         std::log(determinant(Q_t_sd)));'
p43070
aS'      psi_sd = psi_ME_sd + psi_MVE_sd;'
p43071
aS'      B_sd = -Differentiation::SD::differentiate(psi_sd, H_sd);'
p43072
aS'      S_sd = 2.0 * Differentiation::SD::differentiate(psi_sd, C_sd);'
p43073
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression>'
p43074
aS'        Q_t_sd_explicit ='
p43075
aS'          (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *'
p43076
aS'          (Q_t1_sd +'
p43077
aS'           (delta_t_sd / tau_v_sd * std::pow(det_F_sd, 2.0 / dim) * C_inv_sd));'
p43078
aS'      const Differentiation::SD::types::substitution_map'
p43079
aS'        substitution_map_explicit = Differentiation::SD::make_substitution_map('
p43080
aS'          std::make_pair(Q_t_sd, Q_t_sd_explicit));'
p43081
aS'      BB_sd = symmetrize(Differentiation::SD::differentiate('
p43082
aS'        Differentiation::SD::substitute(B_sd, substitution_map_explicit),'
p43083
aS'        H_sd));'
p43084
aS'      PP_sd = -Differentiation::SD::differentiate('
p43085
aS'        Differentiation::SD::substitute(S_sd, substitution_map_explicit), H_sd);'
p43086
aS'      HH_sd ='
p43087
aS'        2.0 *'
p43088
aS'        Differentiation::SD::differentiate('
p43089
aS'          Differentiation::SD::substitute(S_sd, substitution_map_explicit),'
p43090
aS'          C_sd);'
p43091
aS'      optimizer.register_symbols('
p43092
aS'        Differentiation::SD::Utilities::extract_symbols('
p43093
aS'          make_substitution_map({}, {}, 0)));'
p43094
aS'      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);'
p43095
aS'      optimizer.optimize();'
p43096
aS'    }'
p43097
aS'    template <int dim>'
p43098
aS'    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_internal_data('
p43099
aS'      const SymmetricTensor<2, dim> &C,'
p43100
aS'      const Tensor<1, dim> &         H,'
p43101
aS'      const DiscreteTime &           time)'
p43102
aS'    {'
p43103
aS'      const double delta_t = this->get_delta_t(time);'
p43104
aS'      const double                  det_F = std::sqrt(determinant(C));'
p43105
aS'      const SymmetricTensor<2, dim> C_inv = invert(C);'
p43106
aS'      AssertThrow(det_F > 0.0,'
p43107
aS'                  ExcMessage("Volumetric Jacobian must be positive."));'
p43108
aS'      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *'
p43109
aS'            (Q_t1 + (delta_t / this->get_tau_v()) * std::pow(det_F, 2.0 / dim) *'
p43110
aS'                      C_inv);'
p43111
aS'      const auto substitution_map = make_substitution_map(C, H, delta_t);'
p43112
aS'      optimizer.substitute(substitution_map);'
p43113
aS'    }'
p43114
aS'    template <int dim>'
p43115
aS'    double Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_psi() const'
p43116
aS'    {'
p43117
aS'      return optimizer.evaluate(psi_sd);'
p43118
aS'    }'
p43119
aS'    template <int dim>'
p43120
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_B() const'
p43121
aS'    {'
p43122
aS'      return optimizer.evaluate(B_sd);'
p43123
aS'    }'
p43124
aS'    template <int dim>'
p43125
aS'    SymmetricTensor<2, dim>'
p43126
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_S() const'
p43127
aS'    {'
p43128
aS'      return optimizer.evaluate(S_sd);'
p43129
aS'    }'
p43130
aS'    template <int dim>'
p43131
aS'    SymmetricTensor<2, dim>'
p43132
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_DD() const'
p43133
aS'    {'
p43134
aS'      return optimizer.evaluate(BB_sd);'
p43135
aS'    }'
p43136
aS'    template <int dim>'
p43137
aS'    Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_PP() const'
p43138
aS'    {'
p43139
aS'      return optimizer.evaluate(PP_sd);'
p43140
aS'    }'
p43141
aS'    template <int dim>'
p43142
aS'    SymmetricTensor<4, dim>'
p43143
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_HH() const'
p43144
aS'    {'
p43145
aS'      return optimizer.evaluate(HH_sd);'
p43146
aS'    }'
p43147
aS'    template <int dim>'
p43148
aS'    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_end_of_timestep()'
p43149
aS'    {'
p43150
aS'      Q_t1 = Q_t;'
p43151
aS'    }'
p43152
aS'    template <int dim>'
p43153
aS'    class Magnetoelastic_Constitutive_Law final'
p43154
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p43155
aS'    {'
p43156
aS'    public:'
p43157
aS'      Magnetoelastic_Constitutive_Law('
p43158
aS'        const ConstitutiveParameters &constitutive_parameters);'
p43159
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p43160
aS'                                        const Tensor<1, dim> &         H,'
p43161
aS'                                        const DiscreteTime &) override;'
p43162
aS'      virtual double get_psi() const override;'
p43163
aS'      virtual Tensor<1, dim> get_B() const override;'
p43164
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p43165
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p43166
aS'      virtual Tensor<3, dim> get_PP() const override;'
p43167
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p43168
aS'    private:'
p43169
aS'      double                  psi;'
p43170
aS'      Tensor<1, dim>          B;'
p43171
aS'      SymmetricTensor<2, dim> S;'
p43172
aS'      SymmetricTensor<2, dim> BB;'
p43173
aS'      Tensor<3, dim>          PP;'
p43174
aS'      SymmetricTensor<4, dim> HH;'
p43175
aS'    };'
p43176
aS'    template <int dim>'
p43177
aS'    Magnetoelastic_Constitutive_Law<dim>::Magnetoelastic_Constitutive_Law('
p43178
aS'      const ConstitutiveParameters &constitutive_parameters)'
p43179
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p43180
aS'          constitutive_parameters)'
p43181
aS'      , psi(0.0)'
p43182
aS'    {}'
p43183
aS'    template <int dim>'
p43184
aS'    void Magnetoelastic_Constitutive_Law<dim>::update_internal_data('
p43185
aS'      const SymmetricTensor<2, dim> &C,'
p43186
aS'      const Tensor<1, dim> &         H,'
p43187
aS'      const DiscreteTime &)'
p43188
aS'    {'
p43189
aS'      const double                  det_F = std::sqrt(determinant(C));'
p43190
aS'      const SymmetricTensor<2, dim> C_inv = invert(C);'
p43191
aS'      AssertThrow(det_F > 0.0,'
p43192
aS'                  ExcMessage("Volumetric Jacobian must be positive."));'
p43193
aS'      const double two_h_dot_h_div_h_sat_squ ='
p43194
aS'        (2.0 * H * H) / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat());'
p43195
aS'      const double tanh_two_h_dot_h_div_h_sat_squ ='
p43196
aS'        std::tanh(two_h_dot_h_div_h_sat_squ);'
p43197
aS'      const double f_mu_e ='
p43198
aS'        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *'
p43199
aS'                tanh_two_h_dot_h_div_h_sat_squ;'
p43200
aS'      const double dtanh_two_h_dot_h_div_h_sat_squ ='
p43201
aS'        std::pow(1.0 / std::cosh(two_h_dot_h_div_h_sat_squ), 2.0);'
p43202
aS'      const Tensor<1, dim> dtwo_h_dot_h_div_h_sat_squ_dH ='
p43203
aS'        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) * H;'
p43204
aS'      const Tensor<1, dim> df_mu_e_dH ='
p43205
aS'        (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *'
p43206
aS'        (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);'
p43207
aS'      const double d2tanh_two_h_dot_h_div_h_sat_squ ='
p43208
aS'        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;'
p43209
aS'      const SymmetricTensor<2, dim> d2two_h_dot_h_div_h_sat_squ_dH_dH ='
p43210
aS'        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) *'
p43211
aS'        Physics::Elasticity::StandardTensors<dim>::I;'
p43212
aS'      const SymmetricTensor<2, dim> d2f_mu_e_dH_dH ='
p43213
aS'        (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *'
p43214
aS'        (d2tanh_two_h_dot_h_div_h_sat_squ *'
p43215
aS'           symmetrize(outer_product(dtwo_h_dot_h_div_h_sat_squ_dH,'
p43216
aS'                                    dtwo_h_dot_h_div_h_sat_squ_dH)) +'
p43217
aS'         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);'
p43218
aS'      const double         log_det_F         = std::log(det_F);'
p43219
aS'      const double         tr_C              = trace(C);'
p43220
aS'      const Tensor<1, dim> C_inv_dot_H       = C_inv * H;'
p43221
aS'      const double         H_dot_C_inv_dot_H = H * C_inv_dot_H;'
p43222
aS'      const SymmetricTensor<2, dim> d_tr_C_dC ='
p43223
aS'        Physics::Elasticity::StandardTensors<dim>::I;'
p43224
aS'      const SymmetricTensor<2, dim> ddet_F_dC     = 0.5 * det_F * C_inv;'
p43225
aS'      const SymmetricTensor<2, dim> dlog_det_F_dC = 0.5 * C_inv;'
p43226
aS'      const Tensor<1, dim> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;'
p43227
aS'      SymmetricTensor<4, dim> dC_inv_dC;'
p43228
aS'      for (unsigned int A = 0; A < dim; ++A)'
p43229
aS'        for (unsigned int B = A; B < dim; ++B)'
p43230
aS'          for (unsigned int C = 0; C < dim; ++C)'
p43231
aS'            for (unsigned int D = C; D < dim; ++D)'
p43232
aS'              dC_inv_dC[A][B][C][D] -=               //'
p43233
aS'                0.5 * (C_inv[A][C] * C_inv[B][D]     //'
p43234
aS'                       + C_inv[A][D] * C_inv[B][C]); //'
p43235
aS'      const SymmetricTensor<2, dim> dH_dot_C_inv_dot_H_dC ='
p43236
aS'        -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H));'
p43237
aS'      const SymmetricTensor<4, dim> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;'
p43238
aS'      const SymmetricTensor<4, dim> d2det_F_dC_dC ='
p43239
aS'        0.5 * (outer_product(C_inv, ddet_F_dC) + det_F * dC_inv_dC);'
p43240
aS'      const SymmetricTensor<2, dim> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;'
p43241
aS'      Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;'
p43242
aS'      for (unsigned int A = 0; A < dim; ++A)'
p43243
aS'        for (unsigned int B = 0; B < dim; ++B)'
p43244
aS'          for (unsigned int C = 0; C < dim; ++C)'
p43245
aS'            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -='
p43246
aS'              C_inv[A][C] * C_inv_dot_H[B] + //'
p43247
aS'              C_inv_dot_H[A] * C_inv[B][C];  //'
p43248
aS'      SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;'
p43249
aS'      for (unsigned int A = 0; A < dim; ++A)'
p43250
aS'        for (unsigned int B = A; B < dim; ++B)'
p43251
aS'          for (unsigned int C = 0; C < dim; ++C)'
p43252
aS'            for (unsigned int D = C; D < dim; ++D)'
p43253
aS'              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +='
p43254
aS'                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +'
p43255
aS'                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +'
p43256
aS'                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +'
p43257
aS'                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);'
p43258
aS'      psi ='
p43259
aS'        (0.5 * this->get_mu_e() * f_mu_e) *'
p43260
aS'          (tr_C - dim - 2.0 * std::log(det_F)) +'
p43261
aS'        this->get_lambda_e() * (std::log(det_F) * std::log(det_F)) -'
p43262
aS'        (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H);'
p43263
aS'      B = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *'
p43264
aS'            df_mu_e_dH //'
p43265
aS'          + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p43266
aS'              dH_dot_C_inv_dot_H_dH; //'
p43267
aS'      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                        //'
p43268
aS'            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              //'
p43269
aS'          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) //'
p43270
aS'          - 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *            //'
p43271
aS'              (H_dot_C_inv_dot_H * ddet_F_dC                               //'
p43272
aS'               + det_F * dH_dot_C_inv_dot_H_dC);                           //'
p43273
aS'      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * //'
p43274
aS'             d2f_mu_e_dH_dH                                             //'
p43275
aS'           + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p43276
aS'               d2H_dot_C_inv_dot_H_dH_dH; //'
p43277
aS'      PP = -2.0 * (0.5 * this->get_mu_e()) *                                  //'
p43278
aS'             outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   //'
p43279
aS'                           df_mu_e_dH)                                        //'
p43280
aS'           +                                                                  //'
p43281
aS'           2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                //'
p43282
aS'             (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) //'
p43283
aS'              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           //'
p43284
aS'      HH ='
p43285
aS'        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) //'
p43286
aS'        + 4.0 * this->get_lambda_e() *                                       //'
p43287
aS'            (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               //'
p43288
aS'             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          //'
p43289
aS'        - 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                //'
p43290
aS'            (H_dot_C_inv_dot_H * d2det_F_dC_dC                               //'
p43291
aS'             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               //'
p43292
aS'             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               //'
p43293
aS'             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           //'
p43294
aS'    }'
p43295
aS'    template <int dim>'
p43296
aS'    double Magnetoelastic_Constitutive_Law<dim>::get_psi() const'
p43297
aS'    {'
p43298
aS'      return psi;'
p43299
aS'    }'
p43300
aS'    template <int dim>'
p43301
aS'    Tensor<1, dim> Magnetoelastic_Constitutive_Law<dim>::get_B() const'
p43302
aS'    {'
p43303
aS'      return B;'
p43304
aS'    }'
p43305
aS'    template <int dim>'
p43306
aS'    SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_S() const'
p43307
aS'    {'
p43308
aS'      return S;'
p43309
aS'    }'
p43310
aS'    template <int dim>'
p43311
aS'    SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_DD() const'
p43312
aS'    {'
p43313
aS'      return BB;'
p43314
aS'    }'
p43315
aS'    template <int dim>'
p43316
aS'    Tensor<3, dim> Magnetoelastic_Constitutive_Law<dim>::get_PP() const'
p43317
aS'    {'
p43318
aS'      return PP;'
p43319
aS'    }'
p43320
aS'    template <int dim>'
p43321
aS'    SymmetricTensor<4, dim> Magnetoelastic_Constitutive_Law<dim>::get_HH() const'
p43322
aS'    {'
p43323
aS'      return HH;'
p43324
aS'    }'
p43325
aS'    template <int dim>'
p43326
aS'    class Magnetoviscoelastic_Constitutive_Law final'
p43327
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p43328
aS'    {'
p43329
aS'    public:'
p43330
aS'      Magnetoviscoelastic_Constitutive_Law('
p43331
aS'        const ConstitutiveParameters &constitutive_parameters);'
p43332
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p43333
aS'                                        const Tensor<1, dim> &         H,'
p43334
aS'                                        const DiscreteTime &time) override;'
p43335
aS'      virtual double get_psi() const override;'
p43336
aS'      virtual Tensor<1, dim> get_B() const override;'
p43337
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p43338
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p43339
aS'      virtual Tensor<3, dim> get_PP() const override;'
p43340
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p43341
aS'      virtual void update_end_of_timestep() override;'
p43342
aS'    private:'
p43343
aS'      SymmetricTensor<2, dim> Q_t;'
p43344
aS'      SymmetricTensor<2, dim> Q_t1;'
p43345
aS'      double                  psi;'
p43346
aS'      Tensor<1, dim>          B;'
p43347
aS'      SymmetricTensor<2, dim> S;'
p43348
aS'      SymmetricTensor<2, dim> BB;'
p43349
aS'      Tensor<3, dim>          PP;'
p43350
aS'      SymmetricTensor<4, dim> HH;'
p43351
aS'      mutable GeneralDataStorage cache;'
p43352
aS'      void set_primary_variables(const SymmetricTensor<2, dim> &C,'
p43353
aS'                                 const Tensor<1, dim> &         H) const;'
p43354
aS'      void update_internal_variable(const DiscreteTime &time);'
p43355
aS'      const Tensor<1, dim> &get_H() const;'
p43356
aS'      const SymmetricTensor<2, dim> &get_C() const;'
p43357
aS'      double get_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p43358
aS'      double get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p43359
aS'      double get_f_mu(const double mu,'
p43360
aS'                      const double mu_inf,'
p43361
aS'                      const double mu_h_sat) const;'
p43362
aS'      double get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p43363
aS'      Tensor<1, dim>'
p43364
aS'      get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const;'
p43365
aS'      Tensor<1, dim> get_df_mu_dH(const double mu,'
p43366
aS'                                  const double mu_inf,'
p43367
aS'                                  const double mu_h_sat) const;'
p43368
aS'      double get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p43369
aS'      SymmetricTensor<2, dim>'
p43370
aS'      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const;'
p43371
aS'      SymmetricTensor<2, dim> get_d2f_mu_dH_dH(const double mu,'
p43372
aS'                                               const double mu_inf,'
p43373
aS'                                               const double mu_h_sat) const;'
p43374
aS'      const double &get_det_F() const;'
p43375
aS'      const SymmetricTensor<2, dim> &get_C_inv() const;'
p43376
aS'      const double &get_log_det_F() const;'
p43377
aS'      const double &get_trace_C() const;'
p43378
aS'      const Tensor<1, dim> &get_C_inv_dot_H() const;'
p43379
aS'      const double &get_H_dot_C_inv_dot_H() const;'
p43380
aS'      const SymmetricTensor<4, dim> &get_dC_inv_dC() const;'
p43381
aS'      const SymmetricTensor<2, dim> &get_d_tr_C_dC() const;'
p43382
aS'      const SymmetricTensor<2, dim> &get_ddet_F_dC() const;'
p43383
aS'      const SymmetricTensor<2, dim> &get_dlog_det_F_dC() const;'
p43384
aS'      const Tensor<1, dim> &get_dH_dot_C_inv_dot_H_dH() const;'
p43385
aS'      const SymmetricTensor<2, dim> &get_dH_dot_C_inv_dot_H_dC() const;'
p43386
aS'      const SymmetricTensor<4, dim> &'
p43387
aS'      get_dQ_t_dC(const DiscreteTime &time) const;'
p43388
aS'      const SymmetricTensor<4, dim> &get_d2log_det_F_dC_dC() const;'
p43389
aS'      const SymmetricTensor<4, dim> &get_d2det_F_dC_dC() const;'
p43390
aS'      const SymmetricTensor<2, dim> &get_d2H_dot_C_inv_dot_H_dH_dH() const;'
p43391
aS'      const Tensor<3, dim> &get_d2H_dot_C_inv_dot_H_dC_dH() const;'
p43392
aS'      const SymmetricTensor<4, dim> &get_d2H_dot_C_inv_dot_H_dC_dC() const;'
p43393
aS'    };'
p43394
aS'    template <int dim>'
p43395
aS'    Magnetoviscoelastic_Constitutive_Law<'
p43396
aS'      dim>::Magnetoviscoelastic_Constitutive_Law(const ConstitutiveParameters'
p43397
aS'                                                   &constitutive_parameters)'
p43398
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p43399
aS'          constitutive_parameters)'
p43400
aS'      , Q_t(Physics::Elasticity::StandardTensors<dim>::I)'
p43401
aS'      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)'
p43402
aS'      , psi(0.0)'
p43403
aS'    {}'
p43404
aS'    template <int dim>'
p43405
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_data('
p43406
aS'      const SymmetricTensor<2, dim> &C,'
p43407
aS'      const Tensor<1, dim> &         H,'
p43408
aS'      const DiscreteTime &           time)'
p43409
aS'    {'
p43410
aS'      set_primary_variables(C, H);'
p43411
aS'      update_internal_variable(time);'
p43412
aS'      const double f_mu_e = get_f_mu(this->get_mu_e(),'
p43413
aS'                                     this->get_mu_e_inf(),'
p43414
aS'                                     this->get_mu_e_h_sat());'
p43415
aS'      const double f_mu_v = get_f_mu(this->get_mu_v(),'
p43416
aS'                                     this->get_mu_v_inf(),'
p43417
aS'                                     this->get_mu_v_h_sat());'
p43418
aS'      const Tensor<1, dim> df_mu_e_dH = get_df_mu_dH(this->get_mu_e(),'
p43419
aS'                                                     this->get_mu_e_inf(),'
p43420
aS'                                                     this->get_mu_e_h_sat());'
p43421
aS'      const Tensor<1, dim> df_mu_v_dH = get_df_mu_dH(this->get_mu_v(),'
p43422
aS'                                                     this->get_mu_v_inf(),'
p43423
aS'                                                     this->get_mu_v_h_sat());'
p43424
aS'      const SymmetricTensor<2, dim> d2f_mu_e_dH_dH ='
p43425
aS'        get_d2f_mu_dH_dH(this->get_mu_e(),'
p43426
aS'                         this->get_mu_e_inf(),'
p43427
aS'                         this->get_mu_e_h_sat());'
p43428
aS'      const SymmetricTensor<2, dim> d2f_mu_v_dH_dH ='
p43429
aS'        get_d2f_mu_dH_dH(this->get_mu_v(),'
p43430
aS'                         this->get_mu_v_inf(),'
p43431
aS'                         this->get_mu_v_h_sat());'
p43432
aS'      const double &                 det_F = get_det_F();'
p43433
aS'      const SymmetricTensor<2, dim> &C_inv = get_C_inv();'
p43434
aS'      const double &log_det_F         = get_log_det_F();'
p43435
aS'      const double &tr_C              = get_trace_C();'
p43436
aS'      const double &H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();'
p43437
aS'      const SymmetricTensor<2, dim> &d_tr_C_dC     = get_d_tr_C_dC();'
p43438
aS'      const SymmetricTensor<2, dim> &ddet_F_dC     = get_ddet_F_dC();'
p43439
aS'      const SymmetricTensor<2, dim> &dlog_det_F_dC = get_dlog_det_F_dC();'
p43440
aS'      const SymmetricTensor<4, dim> &dQ_t_dC = get_dQ_t_dC(time);'
p43441
aS'      const Tensor<1, dim> &dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();'
p43442
aS'      const SymmetricTensor<2, dim> &dH_dot_C_inv_dot_H_dC ='
p43443
aS'        get_dH_dot_C_inv_dot_H_dC();'
p43444
aS'      const SymmetricTensor<4, dim> &d2log_det_F_dC_dC ='
p43445
aS'        get_d2log_det_F_dC_dC();'
p43446
aS'      const SymmetricTensor<4, dim> &d2det_F_dC_dC = get_d2det_F_dC_dC();'
p43447
aS'      const SymmetricTensor<2, dim> &d2H_dot_C_inv_dot_H_dH_dH ='
p43448
aS'        get_d2H_dot_C_inv_dot_H_dH_dH();'
p43449
aS'      const Tensor<3, dim> &d2H_dot_C_inv_dot_H_dC_dH ='
p43450
aS'        get_d2H_dot_C_inv_dot_H_dC_dH();'
p43451
aS'      const SymmetricTensor<4, dim> &d2H_dot_C_inv_dot_H_dC_dC ='
p43452
aS'        get_d2H_dot_C_inv_dot_H_dC_dC();'
p43453
aS'      psi = (0.5 * this->get_mu_e() * f_mu_e) *'
p43454
aS'              (tr_C - dim - 2.0 * std::log(det_F)) +'
p43455
aS'            this->get_lambda_e() * (std::log(det_F) * std::log(det_F));'
p43456
aS'      psi += (0.5 * this->get_mu_v() * f_mu_v) *'
p43457
aS'             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -'
p43458
aS'              std::log(determinant(Q_t)));'
p43459
aS'      psi -='
p43460
aS'        (0.5 * this->get_mu_0() * this->get_mu_r()) * det_F * (H * C_inv * H);'
p43461
aS'      B ='
p43462
aS'        -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;'
p43463
aS'      B -= (0.5 * this->get_mu_v()) *'
p43464
aS'           (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -'
p43465
aS'            std::log(determinant(Q_t))) *'
p43466
aS'           df_mu_v_dH;'
p43467
aS'      B += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p43468
aS'           dH_dot_C_inv_dot_H_dH;'
p43469
aS'      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                         //'
p43470
aS'            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               //'
p43471
aS'          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); //'
p43472
aS'      S += 2.0 * (0.5 * this->get_mu_v() * f_mu_v) *'
p43473
aS'           ((Q_t * C) *'
p43474
aS'              ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +'
p43475
aS'            std::pow(det_F, -2.0 / dim) * Q_t);                // dC/dC = II'
p43476
aS'      S -= 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * //'
p43477
aS'           (H_dot_C_inv_dot_H * ddet_F_dC                      //'
p43478
aS'            + det_F * dH_dot_C_inv_dot_H_dC);                  //'
p43479
aS'      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *'
p43480
aS'           d2f_mu_e_dH_dH;'
p43481
aS'      BB -= (0.5 * this->get_mu_v()) *'
p43482
aS'            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -'
p43483
aS'             std::log(determinant(Q_t))) *'
p43484
aS'            d2f_mu_v_dH_dH;'
p43485
aS'      BB += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p43486
aS'            d2H_dot_C_inv_dot_H_dH_dH;'
p43487
aS'      PP = -2.0 * (0.5 * this->get_mu_e()) *'
p43488
aS'           outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),'
p43489
aS'                         df_mu_e_dH);'
p43490
aS'      PP -= 2.0 * (0.5 * this->get_mu_v()) *'
p43491
aS'            outer_product(Tensor<2, dim>((Q_t * C) *'
p43492
aS'                                           ((-2.0 / dim) *'
p43493
aS'                                            std::pow(det_F, -2.0 / dim - 1.0) *'
p43494
aS'                                            ddet_F_dC) +'
p43495
aS'                                         std::pow(det_F, -2.0 / dim) * Q_t),'
p43496
aS'                          df_mu_v_dH);'
p43497
aS'      PP += 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *'
p43498
aS'            (outer_product(Tensor<2, dim>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +'
p43499
aS'             det_F * d2H_dot_C_inv_dot_H_dC_dH);'
p43500
aS'      HH ='
p43501
aS'        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) //'
p43502
aS'        + 4.0 * this->get_lambda_e() *                                       //'
p43503
aS'            (2.0 * outer_product(dlog_det_F_dC, dlog_det_F_dC)               //'
p43504
aS'             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         //'
p43505
aS'      HH += 4.0 * (0.5 * this->get_mu_v() * f_mu_v) *'
p43506
aS'            (outer_product((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *'
p43507
aS'                             ddet_F_dC,'
p43508
aS'                           C * dQ_t_dC + Q_t) +'
p43509
aS'             (Q_t * C) *'
p43510
aS'               (outer_product(ddet_F_dC,'
p43511
aS'                              (-2.0 / dim) * (-2.0 / dim - 1.0) *'
p43512
aS'                                std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +'
p43513
aS'                ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *'
p43514
aS'                 d2det_F_dC_dC)) +'
p43515
aS'             outer_product(Q_t,'
p43516
aS'                           (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *'
p43517
aS'                             ddet_F_dC) +'
p43518
aS'             std::pow(det_F, -2.0 / dim) * dQ_t_dC);'
p43519
aS'      HH -= 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * //'
p43520
aS'            (H_dot_C_inv_dot_H * d2det_F_dC_dC                  //'
p43521
aS'             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  //'
p43522
aS'             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  //'
p43523
aS'             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              //'
p43524
aS'      cache.reset();'
p43525
aS'    }'
p43526
aS'    template <int dim>'
p43527
aS'    double Magnetoviscoelastic_Constitutive_Law<dim>::get_psi() const'
p43528
aS'    {'
p43529
aS'      return psi;'
p43530
aS'    }'
p43531
aS'    template <int dim>'
p43532
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_B() const'
p43533
aS'    {'
p43534
aS'      return B;'
p43535
aS'    }'
p43536
aS'    template <int dim>'
p43537
aS'    SymmetricTensor<2, dim>'
p43538
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_S() const'
p43539
aS'    {'
p43540
aS'      return S;'
p43541
aS'    }'
p43542
aS'    template <int dim>'
p43543
aS'    SymmetricTensor<2, dim>'
p43544
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_DD() const'
p43545
aS'    {'
p43546
aS'      return BB;'
p43547
aS'    }'
p43548
aS'    template <int dim>'
p43549
aS'    Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_PP() const'
p43550
aS'    {'
p43551
aS'      return PP;'
p43552
aS'    }'
p43553
aS'    template <int dim>'
p43554
aS'    SymmetricTensor<4, dim>'
p43555
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_HH() const'
p43556
aS'    {'
p43557
aS'      return HH;'
p43558
aS'    }'
p43559
aS'    template <int dim>'
p43560
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::update_end_of_timestep()'
p43561
aS'    {'
p43562
aS'      Q_t1 = Q_t;'
p43563
aS'    }'
p43564
aS'    template <int dim>'
p43565
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_variable('
p43566
aS'      const DiscreteTime &time)'
p43567
aS'    {'
p43568
aS'      const double delta_t = this->get_delta_t(time);'
p43569
aS'      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *'
p43570
aS'            (Q_t1 + (delta_t / this->get_tau_v()) *'
p43571
aS'                      std::pow(get_det_F(), 2.0 / dim) * get_C_inv());'
p43572
aS'    }'
p43573
aS'    template <int dim>'
p43574
aS'    double'
p43575
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_two_h_dot_h_div_h_sat_squ('
p43576
aS'      const double mu_h_sat) const'
p43577
aS'    {'
p43578
aS'      const Tensor<1, dim> &H = get_H();'
p43579
aS'      return (2.0 * H * H) / (mu_h_sat * mu_h_sat);'
p43580
aS'    }'
p43581
aS'    template <int dim>'
p43582
aS'    double Magnetoviscoelastic_Constitutive_Law<'
p43583
aS'      dim>::get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const'
p43584
aS'    {'
p43585
aS'      return std::tanh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));'
p43586
aS'    }'
p43587
aS'    template <int dim>'
p43588
aS'    double Magnetoviscoelastic_Constitutive_Law<dim>::get_f_mu('
p43589
aS'      const double mu,'
p43590
aS'      const double mu_inf,'
p43591
aS'      const double mu_h_sat) const'
p43592
aS'    {'
p43593
aS'      return 1.0 +'
p43594
aS'             (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);'
p43595
aS'    }'
p43596
aS'    template <int dim>'
p43597
aS'    double Magnetoviscoelastic_Constitutive_Law<'
p43598
aS'      dim>::get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const'
p43599
aS'    {'
p43600
aS'      return std::pow(1.0 / std::cosh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),'
p43601
aS'                      2.0);'
p43602
aS'    }'
p43603
aS'    template <int dim>'
p43604
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<'
p43605
aS'      dim>::get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const'
p43606
aS'    {'
p43607
aS'      return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();'
p43608
aS'    }'
p43609
aS'    template <int dim>'
p43610
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_df_mu_dH('
p43611
aS'      const double mu,'
p43612
aS'      const double mu_inf,'
p43613
aS'      const double mu_h_sat) const'
p43614
aS'    {'
p43615
aS'      return (mu_inf / mu - 1.0) *'
p43616
aS'             (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *'
p43617
aS'              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));'
p43618
aS'    }'
p43619
aS'    template <int dim>'
p43620
aS'    double Magnetoviscoelastic_Constitutive_Law<'
p43621
aS'      dim>::get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const'
p43622
aS'    {'
p43623
aS'      return -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *'
p43624
aS'             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);'
p43625
aS'    }'
p43626
aS'    template <int dim>'
p43627
aS'    SymmetricTensor<2, dim> Magnetoviscoelastic_Constitutive_Law<'
p43628
aS'      dim>::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const'
p43629
aS'    {'
p43630
aS'      return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *'
p43631
aS'             Physics::Elasticity::StandardTensors<dim>::I;'
p43632
aS'    }'
p43633
aS'    template <int dim>'
p43634
aS'    SymmetricTensor<2, dim>'
p43635
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2f_mu_dH_dH('
p43636
aS'      const double mu,'
p43637
aS'      const double mu_inf,'
p43638
aS'      const double mu_h_sat) const'
p43639
aS'    {'
p43640
aS'      return (mu_inf / mu - 1.0) *'
p43641
aS'             (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *'
p43642
aS'                symmetrize('
p43643
aS'                  outer_product(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),'
p43644
aS'                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +'
p43645
aS'              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *'
p43646
aS'                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));'
p43647
aS'    }'
p43648
aS'    template <int dim>'
p43649
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::set_primary_variables('
p43650
aS'      const SymmetricTensor<2, dim> &C,'
p43651
aS'      const Tensor<1, dim> &         H) const'
p43652
aS'    {'
p43653
aS'      const std::string name_H("H");'
p43654
aS'      Assert(!cache.stores_object_with_name(name_H),'
p43655
aS'             ExcMessage('
p43656
aS'               "The primary variable has already been added to the cache."));'
p43657
aS'      cache.add_unique_copy(name_H, H);'
p43658
aS'      const std::string name_C("C");'
p43659
aS'      Assert(!cache.stores_object_with_name(name_C),'
p43660
aS'             ExcMessage('
p43661
aS'               "The primary variable has already been added to the cache."));'
p43662
aS'      cache.add_unique_copy(name_C, C);'
p43663
aS'    }'
p43664
aS'    template <int dim>'
p43665
aS'    const Tensor<1, dim> &'
p43666
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_H() const'
p43667
aS'    {'
p43668
aS'      const std::string name("H");'
p43669
aS'      Assert(cache.stores_object_with_name(name),'
p43670
aS'             ExcMessage("Primary variables must be added to the cache."));'
p43671
aS'      return cache.template get_object_with_name<Tensor<1, dim>>(name);'
p43672
aS'    }'
p43673
aS'    template <int dim>'
p43674
aS'    const SymmetricTensor<2, dim> &'
p43675
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_C() const'
p43676
aS'    {'
p43677
aS'      const std::string name("C");'
p43678
aS'      Assert(cache.stores_object_with_name(name),'
p43679
aS'             ExcMessage("Primary variables must be added to the cache."));'
p43680
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43681
aS'    }'
p43682
aS'    template <int dim>'
p43683
aS'    const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_det_F() const'
p43684
aS'    {'
p43685
aS'      const std::string name("det_F");'
p43686
aS'      if (cache.stores_object_with_name(name) == false)'
p43687
aS'        {'
p43688
aS'          const double det_F = std::sqrt(determinant(get_C()));'
p43689
aS'          AssertThrow(det_F > 0.0,'
p43690
aS'                      ExcMessage("Volumetric Jacobian must be positive."));'
p43691
aS'          cache.add_unique_copy(name, det_F);'
p43692
aS'        }'
p43693
aS'      return cache.template get_object_with_name<double>(name);'
p43694
aS'    }'
p43695
aS'    template <int dim>'
p43696
aS'    const SymmetricTensor<2, dim> &'
p43697
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv() const'
p43698
aS'    {'
p43699
aS'      const std::string name("C_inv");'
p43700
aS'      if (cache.stores_object_with_name(name) == false)'
p43701
aS'        {'
p43702
aS'          cache.add_unique_copy(name, invert(get_C()));'
p43703
aS'        }'
p43704
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43705
aS'    }'
p43706
aS'    template <int dim>'
p43707
aS'    const double &'
p43708
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_log_det_F() const'
p43709
aS'    {'
p43710
aS'      const std::string name("log(det_F)");'
p43711
aS'      if (cache.stores_object_with_name(name) == false)'
p43712
aS'        cache.add_unique_copy(name, std::log(get_det_F()));'
p43713
aS'      return cache.template get_object_with_name<double>(name);'
p43714
aS'    }'
p43715
aS'    template <int dim>'
p43716
aS'    const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_trace_C() const'
p43717
aS'    {'
p43718
aS'      const std::string name("trace(C)");'
p43719
aS'      if (cache.stores_object_with_name(name) == false)'
p43720
aS'        cache.add_unique_copy(name, trace(get_C()));'
p43721
aS'      return cache.template get_object_with_name<double>(name);'
p43722
aS'    }'
p43723
aS'    template <int dim>'
p43724
aS'    const Tensor<1, dim> &'
p43725
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv_dot_H() const'
p43726
aS'    {'
p43727
aS'      const std::string name("C_inv_dot_H");'
p43728
aS'      if (cache.stores_object_with_name(name) == false)'
p43729
aS'        cache.add_unique_copy(name, get_C_inv() * get_H());'
p43730
aS'      return cache.template get_object_with_name<Tensor<1, dim>>(name);'
p43731
aS'    }'
p43732
aS'    template <int dim>'
p43733
aS'    const double &'
p43734
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_H_dot_C_inv_dot_H() const'
p43735
aS'    {'
p43736
aS'      const std::string name("H_dot_C_inv_dot_H");'
p43737
aS'      if (cache.stores_object_with_name(name) == false)'
p43738
aS'        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());'
p43739
aS'      return cache.template get_object_with_name<double>(name);'
p43740
aS'    }'
p43741
aS'    template <int dim>'
p43742
aS'    const SymmetricTensor<4, dim> &'
p43743
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dQ_t_dC('
p43744
aS'      const DiscreteTime &time) const'
p43745
aS'    {'
p43746
aS'      const std::string name("dQ_t_dC");'
p43747
aS'      if (cache.stores_object_with_name(name) == false)'
p43748
aS'        {'
p43749
aS'          const double  delta_t = this->get_delta_t(time);'
p43750
aS'          const double &det_F   = get_det_F();'
p43751
aS'          const SymmetricTensor<4, dim> dQ_t_dC ='
p43752
aS'            (1.0 / (1.0 + delta_t / this->get_tau_v())) *'
p43753
aS'            (delta_t / this->get_tau_v()) *'
p43754
aS'            ((2.0 / dim) * std::pow(det_F, 2.0 / dim - 1.0) *'
p43755
aS'               outer_product(get_C_inv(), get_ddet_F_dC()) +'
p43756
aS'             std::pow(det_F, 2.0 / dim) * get_dC_inv_dC());'
p43757
aS'          cache.add_unique_copy(name, dQ_t_dC);'
p43758
aS'        }'
p43759
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p43760
aS'    }'
p43761
aS'    template <int dim>'
p43762
aS'    const SymmetricTensor<4, dim> &'
p43763
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dC_inv_dC() const'
p43764
aS'    {'
p43765
aS'      const std::string name("dC_inv_dC");'
p43766
aS'      if (cache.stores_object_with_name(name) == false)'
p43767
aS'        {'
p43768
aS'          const SymmetricTensor<2, dim> &C_inv = get_C_inv();'
p43769
aS'          SymmetricTensor<4, dim>        dC_inv_dC;'
p43770
aS'          for (unsigned int A = 0; A < dim; ++A)'
p43771
aS'            for (unsigned int B = A; B < dim; ++B)'
p43772
aS'              for (unsigned int C = 0; C < dim; ++C)'
p43773
aS'                for (unsigned int D = C; D < dim; ++D)'
p43774
aS'                  dC_inv_dC[A][B][C][D] -=               //'
p43775
aS'                    0.5 * (C_inv[A][C] * C_inv[B][D]     //'
p43776
aS'                           + C_inv[A][D] * C_inv[B][C]); //'
p43777
aS'          cache.add_unique_copy(name, dC_inv_dC);'
p43778
aS'        }'
p43779
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p43780
aS'    }'
p43781
aS'    template <int dim>'
p43782
aS'    const SymmetricTensor<2, dim> &'
p43783
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d_tr_C_dC() const'
p43784
aS'    {'
p43785
aS'      const std::string name("d_tr_C_dC");'
p43786
aS'      if (cache.stores_object_with_name(name) == false)'
p43787
aS'        cache.add_unique_copy(name,'
p43788
aS'                              Physics::Elasticity::StandardTensors<dim>::I);'
p43789
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43790
aS'    }'
p43791
aS'    template <int dim>'
p43792
aS'    const SymmetricTensor<2, dim> &'
p43793
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_ddet_F_dC() const'
p43794
aS'    {'
p43795
aS'      const std::string name("ddet_F_dC");'
p43796
aS'      if (cache.stores_object_with_name(name) == false)'
p43797
aS'        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());'
p43798
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43799
aS'    }'
p43800
aS'    template <int dim>'
p43801
aS'    const SymmetricTensor<2, dim> &'
p43802
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dlog_det_F_dC() const'
p43803
aS'    {'
p43804
aS'      const std::string name("dlog_det_F_dC");'
p43805
aS'      if (cache.stores_object_with_name(name) == false)'
p43806
aS'        cache.add_unique_copy(name, 0.5 * get_C_inv());'
p43807
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43808
aS'    }'
p43809
aS'    template <int dim>'
p43810
aS'    const Tensor<1, dim> &'
p43811
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dH() const'
p43812
aS'    {'
p43813
aS'      const std::string name("dH_dot_C_inv_dot_H_dH");'
p43814
aS'      if (cache.stores_object_with_name(name) == false)'
p43815
aS'        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());'
p43816
aS'      return cache.template get_object_with_name<Tensor<1, dim>>(name);'
p43817
aS'    }'
p43818
aS'    template <int dim>'
p43819
aS'    const SymmetricTensor<2, dim> &'
p43820
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dC() const'
p43821
aS'    {'
p43822
aS'      const std::string name("dH_dot_C_inv_dot_H_dC");'
p43823
aS'      if (cache.stores_object_with_name(name) == false)'
p43824
aS'        {'
p43825
aS'          const Tensor<1, dim> C_inv_dot_H = get_C_inv_dot_H();'
p43826
aS'          cache.add_unique_copy('
p43827
aS'            name, -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H)));'
p43828
aS'        }'
p43829
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43830
aS'    }'
p43831
aS'    template <int dim>'
p43832
aS'    const SymmetricTensor<4, dim> &'
p43833
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2log_det_F_dC_dC() const'
p43834
aS'    {'
p43835
aS'      const std::string name("d2log_det_F_dC_dC");'
p43836
aS'      if (cache.stores_object_with_name(name) == false)'
p43837
aS'        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());'
p43838
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p43839
aS'    }'
p43840
aS'    template <int dim>'
p43841
aS'    const SymmetricTensor<4, dim> &'
p43842
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2det_F_dC_dC() const'
p43843
aS'    {'
p43844
aS'      const std::string name("d2det_F_dC_dC");'
p43845
aS'      if (cache.stores_object_with_name(name) == false)'
p43846
aS'        cache.add_unique_copy(name,'
p43847
aS'                              0.5 *'
p43848
aS'                                (outer_product(get_C_inv(), get_ddet_F_dC()) +'
p43849
aS'                                 get_det_F() * get_dC_inv_dC()));'
p43850
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p43851
aS'    }'
p43852
aS'    template <int dim>'
p43853
aS'    const SymmetricTensor<2, dim> &'
p43854
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dH_dH()'
p43855
aS'      const'
p43856
aS'    {'
p43857
aS'      const std::string name("d2H_dot_C_inv_dot_H_dH_dH");'
p43858
aS'      if (cache.stores_object_with_name(name) == false)'
p43859
aS'        cache.add_unique_copy(name, 2.0 * get_C_inv());'
p43860
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p43861
aS'    }'
p43862
aS'    template <int dim>'
p43863
aS'    const Tensor<3, dim> &'
p43864
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dH()'
p43865
aS'      const'
p43866
aS'    {'
p43867
aS'      const std::string name("d2H_dot_C_inv_dot_H_dC_dH");'
p43868
aS'      if (cache.stores_object_with_name(name) == false)'
p43869
aS'        {'
p43870
aS'          const Tensor<1, dim> &         C_inv_dot_H = get_C_inv_dot_H();'
p43871
aS'          const SymmetricTensor<2, dim> &C_inv       = get_C_inv();'
p43872
aS'          Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;'
p43873
aS'          for (unsigned int A = 0; A < dim; ++A)'
p43874
aS'            for (unsigned int B = 0; B < dim; ++B)'
p43875
aS'              for (unsigned int C = 0; C < dim; ++C)'
p43876
aS'                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -='
p43877
aS'                  C_inv[A][C] * C_inv_dot_H[B] + //'
p43878
aS'                  C_inv_dot_H[A] * C_inv[B][C];  //'
p43879
aS'          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);'
p43880
aS'        }'
p43881
aS'      return cache.template get_object_with_name<Tensor<3, dim>>(name);'
p43882
aS'    }'
p43883
aS'    template <int dim>'
p43884
aS'    const SymmetricTensor<4, dim> &'
p43885
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dC()'
p43886
aS'      const'
p43887
aS'    {'
p43888
aS'      const std::string name("d2H_dot_C_inv_dot_H_dC_dC");'
p43889
aS'      if (cache.stores_object_with_name(name) == false)'
p43890
aS'        {'
p43891
aS'          const Tensor<1, dim> &         C_inv_dot_H = get_C_inv_dot_H();'
p43892
aS'          const SymmetricTensor<2, dim> &C_inv       = get_C_inv();'
p43893
aS'          SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;'
p43894
aS'          for (unsigned int A = 0; A < dim; ++A)'
p43895
aS'            for (unsigned int B = A; B < dim; ++B)'
p43896
aS'              for (unsigned int C = 0; C < dim; ++C)'
p43897
aS'                for (unsigned int D = C; D < dim; ++D)'
p43898
aS'                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +='
p43899
aS'                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +'
p43900
aS'                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +'
p43901
aS'                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +'
p43902
aS'                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);'
p43903
aS'          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);'
p43904
aS'        }'
p43905
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p43906
aS'    }'
p43907
aS'    class RheologicalExperimentParameters : public ParameterAcceptor'
p43908
aS'    {'
p43909
aS'    public:'
p43910
aS'      RheologicalExperimentParameters();'
p43911
aS'      double sample_radius = 0.01;'
p43912
aS'      double sample_height = 0.001;'
p43913
aS'      double lambda_2 = 0.95;'
p43914
aS'      double gamma_12 = 0.05;'
p43915
aS'      double H_2      = 60.0e3;'
p43916
aS'      double       frequency         = 1.0 / (2.0 * numbers::PI);'
p43917
aS'      unsigned int n_cycles          = 5;'
p43918
aS'      unsigned int n_steps_per_cycle = 2500;'
p43919
aS'      bool        output_data_to_file = true;'
p43920
aS'      std::string output_filename_rd ='
p43921
aS'        "experimental_results-rate_dependent.csv";'
p43922
aS'      std::string output_filename_ri ='
p43923
aS'        "experimental_results-rate_independent.csv";'
p43924
aS'      double start_time() const;'
p43925
aS'      double end_time() const;'
p43926
aS'      double delta_t() const;'
p43927
aS'      Tensor<1, 3> get_H(const double time) const;'
p43928
aS'      Tensor<2, 3> get_F(const double time) const;'
p43929
aS'      bool print_status(const int step_number) const;'
p43930
aS'      bool initialized = false;'
p43931
aS'    };'
p43932
aS'    RheologicalExperimentParameters::RheologicalExperimentParameters()'
p43933
aS'      : ParameterAcceptor("/Coupled Constitutive Laws/Rheological Experiment/")'
p43934
aS'    {'
p43935
aS'      add_parameter("Experimental sample radius", sample_radius);'
p43936
aS'      add_parameter("Experimental sample radius", sample_height);'
p43937
aS'      add_parameter("Axial stretch", lambda_2);'
p43938
aS'      add_parameter("Shear strain amplitude", gamma_12);'
p43939
aS'      add_parameter("Axial magnetic field strength", H_2);'
p43940
aS'      add_parameter("Frequency", frequency);'
p43941
aS'      add_parameter("Number of loading cycles", n_cycles);'
p43942
aS'      add_parameter("Discretisation for each cycle", n_steps_per_cycle);'
p43943
aS'      add_parameter("Output experimental results to file", output_data_to_file);'
p43944
aS'      add_parameter("Output file name (rate dependent constitutive law)",'
p43945
aS'                    output_filename_rd);'
p43946
aS'      add_parameter("Output file name (rate independent constitutive law)",'
p43947
aS'                    output_filename_ri);'
p43948
aS'      parse_parameters_call_back.connect([&]() -> void { initialized = true; });'
p43949
aS'    }'
p43950
aS'    double RheologicalExperimentParameters::start_time() const'
p43951
aS'    {'
p43952
aS'      return 0.0;'
p43953
aS'    }'
p43954
aS'    double RheologicalExperimentParameters::end_time() const'
p43955
aS'    {'
p43956
aS'      return n_cycles / frequency;'
p43957
aS'    }'
p43958
aS'    double RheologicalExperimentParameters::delta_t() const'
p43959
aS'    {'
p43960
aS'      return (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);'
p43961
aS'    }'
p43962
aS'    bool'
p43963
aS'    RheologicalExperimentParameters::print_status(const int step_number) const'
p43964
aS'    {'
p43965
aS'      return (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;'
p43966
aS'    }'
p43967
aS'    Tensor<1, 3> RheologicalExperimentParameters::get_H(const double) const'
p43968
aS'    {'
p43969
aS'      return Tensor<1, 3>({0.0, 0.0, H_2});'
p43970
aS'    }'
p43971
aS'    Tensor<2, 3> RheologicalExperimentParameters::get_F(const double time) const'
p43972
aS'    {'
p43973
aS'      AssertThrow((sample_radius > 0.0 && sample_height > 0.0),'
p43974
aS'                  ExcMessage("Non-physical sample dimensions"));'
p43975
aS'      AssertThrow(lambda_2 > 0.0,'
p43976
aS'                  ExcMessage("Non-physical applied axial stretch"));'
p43977
aS'      const double sqrt_lambda_2     = std::sqrt(lambda_2);'
p43978
aS'      const double inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;'
p43979
aS'      const double alpha_max ='
p43980
aS'        std::atan(std::tan(gamma_12) * sample_height /'
p43981
aS'                  sample_radius); // Small strain approximation'
p43982
aS'      const double A       = sample_radius * alpha_max;'
p43983
aS'      const double w       = 2.0 * numbers::PI * frequency; // in rad /s'
p43984
aS'      const double gamma_t = A * std::sin(w * time);'
p43985
aS'      const double tau_t ='
p43986
aS'        gamma_t /'
p43987
aS'        (sample_radius * sample_height); // Torsion angle per unit length'
p43988
aS'      const double alpha_t = tau_t * lambda_2 * sample_height;'
p43989
aS'      Tensor<2, 3> F;'
p43990
aS'      F[0][0] = inv_sqrt_lambda_2 * std::cos(alpha_t);'
p43991
aS'      F[0][1] = -inv_sqrt_lambda_2 * std::sin(alpha_t);'
p43992
aS'      F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * std::sin(alpha_t);'
p43993
aS'      F[1][0] = inv_sqrt_lambda_2 * std::sin(alpha_t);'
p43994
aS'      F[1][1] = inv_sqrt_lambda_2 * std::cos(alpha_t);'
p43995
aS'      F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * std::cos(alpha_t);'
p43996
aS'      F[2][0] = 0.0;'
p43997
aS'      F[2][1] = 0.0;'
p43998
aS'      F[2][2] = lambda_2;'
p43999
aS'      AssertThrow((F[0][0] > 0) && (F[1][1] > 0) && (F[2][2] > 0),'
p44000
aS'                  ExcMessage("Non-physical deformation gradient component."));'
p44001
aS'      AssertThrow(std::abs(determinant(F) - 1.0) < 1e-6,'
p44002
aS'                  ExcMessage("Volumetric Jacobian is not equal to unity."));'
p44003
aS'      return F;'
p44004
aS'    }'
p44005
aS'    template <int dim>'
p44006
aS'    void run_rheological_experiment('
p44007
aS'      const RheologicalExperimentParameters &experimental_parameters,'
p44008
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p44009
aS'        &material_hand_calculated,'
p44010
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p44011
aS'        &               material_assisted_computation,'
p44012
aS'      TimerOutput &     timer,'
p44013
aS'      const std::string filename)'
p44014
aS'    {'
p44015
aS'      const auto check_material_class_results ='
p44016
aS'        []('
p44017
aS'          const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &to_verify,'
p44018
aS'          const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &blessed,'
p44019
aS'          const double tol = 1e-6) {'
p44020
aS'          (void)to_verify;'
p44021
aS'          (void)blessed;'
p44022
aS'          (void)tol;'
p44023
aS'          Assert(std::abs(blessed.get_psi() - to_verify.get_psi()) < tol,'
p44024
aS'                 ExcMessage("No match for psi. Error: " +'
p44025
aS'                            Utilities::to_string(std::abs('
p44026
aS'                              blessed.get_psi() - to_verify.get_psi()))));'
p44027
aS'          Assert((blessed.get_B() - to_verify.get_B()).norm() < tol,'
p44028
aS'                 ExcMessage("No match for B. Error: " +'
p44029
aS'                            Utilities::to_string('
p44030
aS'                              (blessed.get_B() - to_verify.get_B()).norm())));'
p44031
aS'          Assert((blessed.get_S() - to_verify.get_S()).norm() < tol,'
p44032
aS'                 ExcMessage("No match for S. Error: " +'
p44033
aS'                            Utilities::to_string('
p44034
aS'                              (blessed.get_S() - to_verify.get_S()).norm())));'
p44035
aS'          Assert((blessed.get_DD() - to_verify.get_DD()).norm() < tol,'
p44036
aS'                 ExcMessage("No match for BB. Error: " +'
p44037
aS'                            Utilities::to_string('
p44038
aS'                              (blessed.get_DD() - to_verify.get_DD()).norm())));'
p44039
aS'          Assert((blessed.get_PP() - to_verify.get_PP()).norm() < tol,'
p44040
aS'                 ExcMessage("No match for PP. Error: " +'
p44041
aS'                            Utilities::to_string('
p44042
aS'                              (blessed.get_PP() - to_verify.get_PP()).norm())));'
p44043
aS'          Assert((blessed.get_HH() - to_verify.get_HH()).norm() < tol,'
p44044
aS'                 ExcMessage("No match for HH. Error: " +'
p44045
aS'                            Utilities::to_string('
p44046
aS'                              (blessed.get_HH() - to_verify.get_HH()).norm())));'
p44047
aS'        };'
p44048
aS'      std::ostringstream stream;'
p44049
aS'      stream'
p44050
aS'        << "Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\\n";'
p44051
aS'      for (DiscreteTime time(experimental_parameters.start_time(),'
p44052
aS'                             experimental_parameters.end_time() +'
p44053
aS'                               experimental_parameters.delta_t(),'
p44054
aS'                             experimental_parameters.delta_t());'
p44055
aS'           time.is_at_end() == false;'
p44056
aS'           time.advance_time())'
p44057
aS'        {'
p44058
aS'          if (experimental_parameters.print_status(time.get_step_number()))'
p44059
aS'            std::cout << "Timestep = " << time.get_step_number()'
p44060
aS'                      << " @ time = " << time.get_current_time() << "s."'
p44061
aS'                      << std::endl;'
p44062
aS'          const Tensor<1, dim> H ='
p44063
aS'            experimental_parameters.get_H(time.get_current_time());'
p44064
aS'          const Tensor<2, dim> F ='
p44065
aS'            experimental_parameters.get_F(time.get_current_time());'
p44066
aS'          const SymmetricTensor<2, dim> C ='
p44067
aS'            Physics::Elasticity::Kinematics::C(F);'
p44068
aS'          {'
p44069
aS'            TimerOutput::Scope timer_section(timer, "Hand calculated");'
p44070
aS'            material_hand_calculated.update_internal_data(C, H, time);'
p44071
aS'            material_hand_calculated.update_end_of_timestep();'
p44072
aS'          }'
p44073
aS'          {'
p44074
aS'            TimerOutput::Scope timer_section(timer, "Assisted computation");'
p44075
aS'            material_assisted_computation.update_internal_data(C, H, time);'
p44076
aS'            material_assisted_computation.update_end_of_timestep();'
p44077
aS'          }'
p44078
aS'          check_material_class_results(material_hand_calculated,'
p44079
aS'                                       material_assisted_computation);'
p44080
aS'          if (experimental_parameters.output_data_to_file)'
p44081
aS'            {'
p44082
aS'              const Tensor<1, dim> h ='
p44083
aS'                Physics::Transformations::Covariant::push_forward(H, F);'
p44084
aS'              const Tensor<1, dim> b ='
p44085
aS'                Physics::Transformations::Piola::push_forward('
p44086
aS'                  material_hand_calculated.get_B(), F);'
p44087
aS'              const SymmetricTensor<2, dim> sigma ='
p44088
aS'                Physics::Transformations::Piola::push_forward('
p44089
aS'                  material_hand_calculated.get_S(), F);'
p44090
aS'              stream << time.get_current_time() << ";" << h[2] << ";" << b[2]'
p44091
aS'                     << ";" << F[1][2] * 100.0 << ";" << sigma[1][2] << "\\n";'
p44092
aS'            }'
p44093
aS'        }'
p44094
aS'      if (experimental_parameters.output_data_to_file)'
p44095
aS'        {'
p44096
aS'          std::ofstream output(filename);'
p44097
aS'          output << stream.str();'
p44098
aS'        }'
p44099
aS'    }'
p44100
aS'    void run(int argc, char *argv[])'
p44101
aS'    {'
p44102
aS'      using namespace dealii;'
p44103
aS'      constexpr unsigned int dim = 3;'
p44104
aS'      const ConstitutiveParameters          constitutive_parameters;'
p44105
aS'      const RheologicalExperimentParameters experimental_parameters;'
p44106
aS'      std::string parameter_file;'
p44107
aS'      if (argc > 1)'
p44108
aS'        parameter_file = argv[1];'
p44109
aS'      else'
p44110
aS'        parameter_file = "parameters.prm";'
p44111
aS'      ParameterAcceptor::initialize(parameter_file, "used_parameters.prm");'
p44112
aS'      {'
p44113
aS'        TimerOutput timer(std::cout,'
p44114
aS'                          TimerOutput::summary,'
p44115
aS'                          TimerOutput::wall_times);'
p44116
aS'        std::cout'
p44117
aS'          << "Coupled magnetoelastic constitutive law using automatic differentiation."'
p44118
aS'          << std::endl;'
p44119
aS'        constexpr Differentiation::AD::NumberTypes ADTypeCode ='
p44120
aS'          Differentiation::AD::NumberTypes::sacado_dfad_dfad;'
p44121
aS'        Magnetoelastic_Constitutive_Law<dim> material(constitutive_parameters);'
p44122
aS'        Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode> material_ad('
p44123
aS'          constitutive_parameters);'
p44124
aS'        run_rheological_experiment(experimental_parameters,'
p44125
aS'                                   material,'
p44126
aS'                                   material_ad,'
p44127
aS'                                   timer,'
p44128
aS'                                   experimental_parameters.output_filename_ri);'
p44129
aS'        std::cout << "... all calculations are correct!" << std::endl;'
p44130
aS'      }'
p44131
aS'      {'
p44132
aS'        TimerOutput timer(std::cout,'
p44133
aS'                          TimerOutput::summary,'
p44134
aS'                          TimerOutput::wall_times);'
p44135
aS'        std::cout'
p44136
aS'          << "Coupled magneto-viscoelastic constitutive law using symbolic differentiation."'
p44137
aS'          << std::endl;'
p44138
aS'#ifdef DEAL_II_SYMENGINE_WITH_LLVM'
p44139
aS'        std::cout << "Using LLVM optimizer." << std::endl;'
p44140
aS'        constexpr Differentiation::SD::OptimizerType optimizer_type ='
p44141
aS'          Differentiation::SD::OptimizerType::llvm;'
p44142
aS'        constexpr Differentiation::SD::OptimizationFlags optimization_flags ='
p44143
aS'          Differentiation::SD::OptimizationFlags::optimize_all;'
p44144
aS'#else'
p44145
aS'        std::cout << "Using lambda optimizer." << std::endl;'
p44146
aS'        constexpr Differentiation::SD::OptimizerType optimizer_type ='
p44147
aS'          Differentiation::SD::OptimizerType::lambda;'
p44148
aS'        constexpr Differentiation::SD::OptimizationFlags optimization_flags ='
p44149
aS'          Differentiation::SD::OptimizationFlags::optimize_cse;'
p44150
aS'#endif'
p44151
aS'        Magnetoviscoelastic_Constitutive_Law<dim> material('
p44152
aS'          constitutive_parameters);'
p44153
aS'        timer.enter_subsection("Initialize symbolic CL");'
p44154
aS'        Magnetoviscoelastic_Constitutive_Law_SD<dim> material_sd('
p44155
aS'          constitutive_parameters, optimizer_type, optimization_flags);'
p44156
aS'        timer.leave_subsection();'
p44157
aS'        run_rheological_experiment(experimental_parameters,'
p44158
aS'                                   material,'
p44159
aS'                                   material_sd,'
p44160
aS'                                   timer,'
p44161
aS'                                   experimental_parameters.output_filename_rd);'
p44162
aS'        std::cout << "... all calculations are correct!" << std::endl;'
p44163
aS'      }'
p44164
aS'    }'
p44165
aS'  } // namespace CoupledConstitutiveLaws'
p44166
aS'} // namespace Step71'
p44167
aS'int main(int argc, char *argv[])'
p44168
ag24
aS'  Step71::SimpleExample::run();'
p44169
aS'  Step71::CoupledConstitutiveLaws::run(argc, argv);'
p44170
aS'  return 0;'
p44171
ag32
aS'/* ---------------------------------------------------------------------'
p44172
aS' *'
p44173
aS' * Copyright (C) 2021 by the deal.II authors'
p44174
aS' *'
p44175
aS' * This file is part of the deal.II library.'
p44176
aS' *'
p44177
aS' * The deal.II library is free software; you can use it, redistribute'
p44178
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p44179
aS' * Public License as published by the Free Software Foundation; either'
p44180
aS' * version 2.1 of the License, or (at your option) any later version.'
p44181
aS' * The full text of the license can be found in the file LICENSE.md at'
p44182
aS' * the top level directory of deal.II.'
p44183
aS' *'
p44184
aS' * ---------------------------------------------------------------------'
p44185
aS' *'
p44186
aS' * Authors: Jean-Paul Pelteret,'
p44187
aS' *          Wolfgang Bangerth, Colorado State University, 2021.'
p44188
aS' * Based on step-15, authored by Sven Wetterauer, University of Heidelberg, 2012'
p44189
aS' */'
p44190
aS'#include <deal.II/base/quadrature_lib.h>'
p44191
aS'#include <deal.II/base/function.h>'
p44192
aS'#include <deal.II/base/parameter_acceptor.h>'
p44193
aS'#include <deal.II/base/timer.h>'
p44194
aS'#include <deal.II/base/utilities.h>'
p44195
aS'#include <deal.II/differentiation/ad.h>'
p44196
aS'#include <deal.II/lac/vector.h>'
p44197
aS'#include <deal.II/lac/full_matrix.h>'
p44198
aS'#include <deal.II/lac/sparse_matrix.h>'
p44199
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p44200
aS'#include <deal.II/lac/solver_cg.h>'
p44201
aS'#include <deal.II/lac/precondition.h>'
p44202
aS'#include <deal.II/lac/affine_constraints.h>'
p44203
aS'#include <deal.II/grid/tria.h>'
p44204
aS'#include <deal.II/grid/grid_generator.h>'
p44205
aS'#include <deal.II/grid/grid_refinement.h>'
p44206
aS'#include <deal.II/dofs/dof_handler.h>'
p44207
aS'#include <deal.II/dofs/dof_tools.h>'
p44208
aS'#include <deal.II/fe/fe_values.h>'
p44209
aS'#include <deal.II/fe/fe_values_extractors.h>'
p44210
aS'#include <deal.II/fe/fe_q.h>'
p44211
aS'#include <deal.II/meshworker/copy_data.h>'
p44212
aS'#include <deal.II/meshworker/mesh_loop.h>'
p44213
aS'#include <deal.II/meshworker/scratch_data.h>'
p44214
aS'#include <deal.II/numerics/vector_tools.h>'
p44215
aS'#include <deal.II/numerics/matrix_tools.h>'
p44216
aS'#include <deal.II/numerics/data_out.h>'
p44217
aS'#include <deal.II/numerics/error_estimator.h>'
p44218
aS'#include <fstream>'
p44219
aS'#include <iostream>'
p44220
aS'#include <deal.II/numerics/solution_transfer.h>'
p44221
aS'namespace Step72'
p44222
ag24
aS'  using namespace dealii;'
p44223
aS'  class MinimalSurfaceProblemParameters : public ParameterAcceptor'
p44224
aS'  {'
p44225
aS'  public:'
p44226
aS'    MinimalSurfaceProblemParameters();'
p44227
aS'    unsigned int formulation = 0;'
p44228
aS'    double tolerance = 1e-2;'
p44229
aS'  };'
p44230
aS'  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()'
p44231
aS'    : ParameterAcceptor("Minimal Surface Problem/")'
p44232
aS'  {'
p44233
aS'    add_parameter('
p44234
aS'      "Formulation", formulation, "", this->prm, Patterns::Integer(0, 2));'
p44235
aS'    add_parameter("Tolerance", tolerance, "", this->prm, Patterns::Double(0.0));'
p44236
aS'  }'
p44237
aS'  template <int dim>'
p44238
aS'  class MinimalSurfaceProblem'
p44239
aS'  {'
p44240
aS'  public:'
p44241
aS'    MinimalSurfaceProblem();'
p44242
aS'    void run(const int formulation, const double tolerance);'
p44243
aS'  private:'
p44244
aS'    void   setup_system(const bool initial_step);'
p44245
aS'    void   assemble_system_unassisted();'
p44246
aS'    void   assemble_system_with_residual_linearization();'
p44247
aS'    void   assemble_system_using_energy_functional();'
p44248
aS'    void   solve();'
p44249
aS'    void   refine_mesh();'
p44250
aS'    void   set_boundary_values();'
p44251
aS'    double compute_residual(const double alpha) const;'
p44252
aS'    double determine_step_length() const;'
p44253
aS'    void   output_results(const unsigned int refinement_cycle) const;'
p44254
aS'    Triangulation<dim> triangulation;'
p44255
aS'    DoFHandler<dim> dof_handler;'
p44256
aS'    FE_Q<dim>       fe;'
p44257
aS'    QGauss<dim>     quadrature_formula;'
p44258
aS'    AffineConstraints<double> hanging_node_constraints;'
p44259
aS'    SparsityPattern      sparsity_pattern;'
p44260
aS'    SparseMatrix<double> system_matrix;'
p44261
aS'    Vector<double> current_solution;'
p44262
aS'    Vector<double> newton_update;'
p44263
aS'    Vector<double> system_rhs;'
p44264
aS'  };'
p44265
aS'  template <int dim>'
p44266
aS'  class BoundaryValues : public Function<dim>'
p44267
aS'  {'
p44268
aS'  public:'
p44269
aS'    virtual double value(const Point<dim> & p,'
p44270
aS'                         const unsigned int component = 0) const override;'
p44271
aS'  };'
p44272
aS'  template <int dim>'
p44273
aS'  double BoundaryValues<dim>::value(const Point<dim> &p,'
p44274
aS'                                    const unsigned int /*component*/) const'
p44275
aS'  {'
p44276
aS'    return std::sin(2 * numbers::PI * (p[0] + p[1]));'
p44277
aS'  }'
p44278
aS'  template <int dim>'
p44279
aS'  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()'
p44280
aS'    : dof_handler(triangulation)'
p44281
aS'    , fe(2)'
p44282
aS'    , quadrature_formula(fe.degree + 1)'
p44283
aS'  {}'
p44284
aS'  template <int dim>'
p44285
aS'  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step)'
p44286
aS'  {'
p44287
aS'    if (initial_step)'
p44288
aS'      {'
p44289
aS'        dof_handler.distribute_dofs(fe);'
p44290
aS'        current_solution.reinit(dof_handler.n_dofs());'
p44291
aS'        hanging_node_constraints.clear();'
p44292
aS'        DoFTools::make_hanging_node_constraints(dof_handler,'
p44293
aS'                                                hanging_node_constraints);'
p44294
aS'        hanging_node_constraints.close();'
p44295
aS'      }'
p44296
aS'    newton_update.reinit(dof_handler.n_dofs());'
p44297
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p44298
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p44299
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p44300
aS'    hanging_node_constraints.condense(dsp);'
p44301
aS'    sparsity_pattern.copy_from(dsp);'
p44302
aS'    system_matrix.reinit(sparsity_pattern);'
p44303
aS'  }'
p44304
aS'  template <int dim>'
p44305
aS'  void MinimalSurfaceProblem<dim>::assemble_system_unassisted()'
p44306
aS'  {'
p44307
aS'    system_matrix = 0;'
p44308
aS'    system_rhs    = 0;'
p44309
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p44310
aS'    using ScratchData = MeshWorker::ScratchData<dim>;'
p44311
aS'    using CopyData    = MeshWorker::CopyData<1, 1, 1>;'
p44312
aS'    using CellIteratorType = decltype(dof_handler.begin_active());'
p44313
aS'    const ScratchData sample_scratch_data(fe,'
p44314
aS'                                          quadrature_formula,'
p44315
aS'                                          update_gradients |'
p44316
aS'                                            update_quadrature_points |'
p44317
aS'                                            update_JxW_values);'
p44318
aS'    const CopyData    sample_copy_data(dofs_per_cell);'
p44319
aS'    const auto cell_worker = [this](const CellIteratorType &cell,'
p44320
aS'                                    ScratchData &           scratch_data,'
p44321
aS'                                    CopyData &              copy_data) {'
p44322
aS'      const auto &fe_values = scratch_data.reinit(cell);'
p44323
aS'      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0];'
p44324
aS'      Vector<double> &                      cell_rhs    = copy_data.vectors[0];'
p44325
aS'      std::vector<types::global_dof_index> &local_dof_indices ='
p44326
aS'        copy_data.local_dof_indices[0];'
p44327
aS'      cell->get_dof_indices(local_dof_indices);'
p44328
aS'      std::vector<Tensor<1, dim>> old_solution_gradients('
p44329
aS'        fe_values.n_quadrature_points);'
p44330
aS'      fe_values.get_function_gradients(current_solution,'
p44331
aS'                                       old_solution_gradients);'
p44332
aS'      for (const unsigned int q : fe_values.quadrature_point_indices())'
p44333
aS'        {'
p44334
aS'          const double coeff ='
p44335
aS'            1.0 / std::sqrt(1.0 + old_solution_gradients[q] *'
p44336
aS'                                    old_solution_gradients[q]);'
p44337
aS'          for (const unsigned int i : fe_values.dof_indices())'
p44338
aS'            {'
p44339
aS'              for (const unsigned int j : fe_values.dof_indices())'
p44340
aS'                cell_matrix(i, j) +='
p44341
aS'                  (((fe_values.shape_grad(i, q)      // ((\\nabla \\phi_i'
p44342
aS'                     * coeff                         //   * a_n'
p44343
aS'                     * fe_values.shape_grad(j, q))   //   * \\nabla \\phi_j)'
p44344
aS'                    -                                //  -'
p44345
aS'                    (fe_values.shape_grad(i, q)      //  (\\nabla \\phi_i'
p44346
aS'                     * coeff * coeff * coeff         //   * a_n^3'
p44347
aS'                     * (fe_values.shape_grad(j, q)   //   * (\\nabla \\phi_j'
p44348
aS'                        * old_solution_gradients[q]) //      * \\nabla u_n)'
p44349
aS'                     * old_solution_gradients[q]))   //   * \\nabla u_n)))'
p44350
aS'                   * fe_values.JxW(q));              // * dx'
p44351
aS'              cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \\nabla \\phi_i'
p44352
aS'                              * coeff                     // * a_n'
p44353
aS'                              * old_solution_gradients[q] // * u_n'
p44354
aS'                              * fe_values.JxW(q));        // * dx'
p44355
aS'            }'
p44356
aS'        }'
p44357
aS'    };'
p44358
aS'    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) {'
p44359
aS'      const FullMatrix<double> &cell_matrix = copy_data.matrices[0];'
p44360
aS'      const Vector<double> &    cell_rhs    = copy_data.vectors[0];'
p44361
aS'      const std::vector<types::global_dof_index> &local_dof_indices ='
p44362
aS'        copy_data.local_dof_indices[0];'
p44363
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p44364
aS'        {'
p44365
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p44366
aS'            system_matrix.add(local_dof_indices[i],'
p44367
aS'                              local_dof_indices[j],'
p44368
aS'                              cell_matrix(i, j));'
p44369
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p44370
aS'        }'
p44371
aS'    };'
p44372
aS'    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),'
p44373
aS'                          cell_worker,'
p44374
aS'                          copier,'
p44375
aS'                          sample_scratch_data,'
p44376
aS'                          sample_copy_data,'
p44377
aS'                          MeshWorker::assemble_own_cells);'
p44378
aS'    hanging_node_constraints.condense(system_matrix);'
p44379
aS'    hanging_node_constraints.condense(system_rhs);'
p44380
aS'    std::map<types::global_dof_index, double> boundary_values;'
p44381
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p44382
aS'                                             0,'
p44383
aS'                                             Functions::ZeroFunction<dim>(),'
p44384
aS'                                             boundary_values);'
p44385
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p44386
aS'                                       system_matrix,'
p44387
aS'                                       newton_update,'
p44388
aS'                                       system_rhs);'
p44389
aS'  }'
p44390
aS'  template <int dim>'
p44391
aS'  void MinimalSurfaceProblem<dim>::assemble_system_with_residual_linearization()'
p44392
aS'  {'
p44393
aS'    system_matrix = 0;'
p44394
aS'    system_rhs    = 0;'
p44395
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p44396
aS'    using ScratchData      = MeshWorker::ScratchData<dim>;'
p44397
aS'    using CopyData         = MeshWorker::CopyData<1, 1, 1>;'
p44398
aS'    using CellIteratorType = decltype(dof_handler.begin_active());'
p44399
aS'    const ScratchData sample_scratch_data(fe,'
p44400
aS'                                          quadrature_formula,'
p44401
aS'                                          update_gradients |'
p44402
aS'                                            update_quadrature_points |'
p44403
aS'                                            update_JxW_values);'
p44404
aS'    const CopyData    sample_copy_data(dofs_per_cell);'
p44405
aS'    using ADHelper = Differentiation::AD::ResidualLinearization<'
p44406
aS'      Differentiation::AD::NumberTypes::sacado_dfad,'
p44407
aS'      double>;'
p44408
aS'    using ADNumberType = typename ADHelper::ad_type;'
p44409
aS'    const FEValuesExtractors::Scalar u_fe(0);'
p44410
aS'    const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,'
p44411
aS'                                           ScratchData &           scratch_data,'
p44412
aS'                                           CopyData &              copy_data) {'
p44413
aS'      const auto &       fe_values     = scratch_data.reinit(cell);'
p44414
aS'      const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();'
p44415
aS'      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0];'
p44416
aS'      Vector<double> &                      cell_rhs    = copy_data.vectors[0];'
p44417
aS'      std::vector<types::global_dof_index> &local_dof_indices ='
p44418
aS'        copy_data.local_dof_indices[0];'
p44419
aS'      cell->get_dof_indices(local_dof_indices);'
p44420
aS'      const unsigned int n_independent_variables = local_dof_indices.size();'
p44421
aS'      const unsigned int n_dependent_variables   = dofs_per_cell;'
p44422
aS'      ADHelper ad_helper(n_independent_variables, n_dependent_variables);'
p44423
aS'      ad_helper.register_dof_values(current_solution, local_dof_indices);'
p44424
aS'      const std::vector<ADNumberType> &dof_values_ad ='
p44425
aS'        ad_helper.get_sensitive_dof_values();'
p44426
aS'      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients('
p44427
aS'        fe_values.n_quadrature_points);'
p44428
aS'      fe_values[u_fe].get_function_gradients_from_local_dof_values('
p44429
aS'        dof_values_ad, old_solution_gradients);'
p44430
aS'      std::vector<ADNumberType> residual_ad(n_dependent_variables,'
p44431
aS'                                            ADNumberType(0.0));'
p44432
aS'      for (const unsigned int q : fe_values.quadrature_point_indices())'
p44433
aS'        {'
p44434
aS'          const ADNumberType coeff ='
p44435
aS'            1.0 / std::sqrt(1.0 + old_solution_gradients[q] *'
p44436
aS'                                    old_solution_gradients[q]);'
p44437
aS'          for (const unsigned int i : fe_values.dof_indices())'
p44438
aS'            {'
p44439
aS'              residual_ad[i] += (fe_values.shape_grad(i, q)   // \\nabla \\phi_i'
p44440
aS'                                 * coeff                      // * a_n'
p44441
aS'                                 * old_solution_gradients[q]) // * u_n'
p44442
aS'                                * fe_values.JxW(q);           // * dx'
p44443
aS'            }'
p44444
aS'        }'
p44445
aS'      ad_helper.register_residual_vector(residual_ad);'
p44446
aS'      ad_helper.compute_residual(cell_rhs);'
p44447
aS'      cell_rhs *= -1.0;'
p44448
aS'      ad_helper.compute_linearization(cell_matrix);'
p44449
aS'    };'
p44450
aS'    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) {'
p44451
aS'      const FullMatrix<double> &cell_matrix = copy_data.matrices[0];'
p44452
aS'      const Vector<double> &    cell_rhs    = copy_data.vectors[0];'
p44453
aS'      const std::vector<types::global_dof_index> &local_dof_indices ='
p44454
aS'        copy_data.local_dof_indices[0];'
p44455
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p44456
aS'        {'
p44457
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p44458
aS'            system_matrix.add(local_dof_indices[i],'
p44459
aS'                              local_dof_indices[j],'
p44460
aS'                              cell_matrix(i, j));'
p44461
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p44462
aS'        }'
p44463
aS'    };'
p44464
aS'    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),'
p44465
aS'                          cell_worker,'
p44466
aS'                          copier,'
p44467
aS'                          sample_scratch_data,'
p44468
aS'                          sample_copy_data,'
p44469
aS'                          MeshWorker::assemble_own_cells);'
p44470
aS'    hanging_node_constraints.condense(system_matrix);'
p44471
aS'    hanging_node_constraints.condense(system_rhs);'
p44472
aS'    std::map<types::global_dof_index, double> boundary_values;'
p44473
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p44474
aS'                                             0,'
p44475
aS'                                             Functions::ZeroFunction<dim>(),'
p44476
aS'                                             boundary_values);'
p44477
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p44478
aS'                                       system_matrix,'
p44479
aS'                                       newton_update,'
p44480
aS'                                       system_rhs);'
p44481
aS'  }'
p44482
aS'  template <int dim>'
p44483
aS'  void MinimalSurfaceProblem<dim>::assemble_system_using_energy_functional()'
p44484
aS'  {'
p44485
aS'    system_matrix = 0;'
p44486
aS'    system_rhs    = 0;'
p44487
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p44488
aS'    using ScratchData      = MeshWorker::ScratchData<dim>;'
p44489
aS'    using CopyData         = MeshWorker::CopyData<1, 1, 1>;'
p44490
aS'    using CellIteratorType = decltype(dof_handler.begin_active());'
p44491
aS'    const ScratchData sample_scratch_data(fe,'
p44492
aS'                                          quadrature_formula,'
p44493
aS'                                          update_gradients |'
p44494
aS'                                            update_quadrature_points |'
p44495
aS'                                            update_JxW_values);'
p44496
aS'    const CopyData    sample_copy_data(dofs_per_cell);'
p44497
aS'    using ADHelper = Differentiation::AD::EnergyFunctional<'
p44498
aS'      Differentiation::AD::NumberTypes::sacado_dfad_dfad,'
p44499
aS'      double>;'
p44500
aS'    using ADNumberType = typename ADHelper::ad_type;'
p44501
aS'    const FEValuesExtractors::Scalar u_fe(0);'
p44502
aS'    const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,'
p44503
aS'                                           ScratchData &           scratch_data,'
p44504
aS'                                           CopyData &              copy_data) {'
p44505
aS'      const auto &fe_values = scratch_data.reinit(cell);'
p44506
aS'      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0];'
p44507
aS'      Vector<double> &                      cell_rhs    = copy_data.vectors[0];'
p44508
aS'      std::vector<types::global_dof_index> &local_dof_indices ='
p44509
aS'        copy_data.local_dof_indices[0];'
p44510
aS'      cell->get_dof_indices(local_dof_indices);'
p44511
aS'      const unsigned int n_independent_variables = local_dof_indices.size();'
p44512
aS'      ADHelper           ad_helper(n_independent_variables);'
p44513
aS'      ad_helper.register_dof_values(current_solution, local_dof_indices);'
p44514
aS'      const std::vector<ADNumberType> &dof_values_ad ='
p44515
aS'        ad_helper.get_sensitive_dof_values();'
p44516
aS'      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients('
p44517
aS'        fe_values.n_quadrature_points);'
p44518
aS'      fe_values[u_fe].get_function_gradients_from_local_dof_values('
p44519
aS'        dof_values_ad, old_solution_gradients);'
p44520
aS'      ADNumberType energy_ad = ADNumberType(0.0);'
p44521
aS'      for (const unsigned int q : fe_values.quadrature_point_indices())'
p44522
aS'        {'
p44523
aS'          const ADNumberType psi = std::sqrt(1.0 + old_solution_gradients[q] *'
p44524
aS'                                                     old_solution_gradients[q]);'
p44525
aS'          energy_ad += psi * fe_values.JxW(q);'
p44526
aS'        }'
p44527
aS'      ad_helper.register_energy_functional(energy_ad);'
p44528
aS'      ad_helper.compute_residual(cell_rhs);'
p44529
aS'      cell_rhs *= -1.0;'
p44530
aS'      ad_helper.compute_linearization(cell_matrix);'
p44531
aS'    };'
p44532
aS'    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) {'
p44533
aS'      const FullMatrix<double> &cell_matrix = copy_data.matrices[0];'
p44534
aS'      const Vector<double> &    cell_rhs    = copy_data.vectors[0];'
p44535
aS'      const std::vector<types::global_dof_index> &local_dof_indices ='
p44536
aS'        copy_data.local_dof_indices[0];'
p44537
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p44538
aS'        {'
p44539
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p44540
aS'            system_matrix.add(local_dof_indices[i],'
p44541
aS'                              local_dof_indices[j],'
p44542
aS'                              cell_matrix(i, j));'
p44543
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p44544
aS'        }'
p44545
aS'    };'
p44546
aS'    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),'
p44547
aS'                          cell_worker,'
p44548
aS'                          copier,'
p44549
aS'                          sample_scratch_data,'
p44550
aS'                          sample_copy_data,'
p44551
aS'                          MeshWorker::assemble_own_cells);'
p44552
aS'    hanging_node_constraints.condense(system_matrix);'
p44553
aS'    hanging_node_constraints.condense(system_rhs);'
p44554
aS'    std::map<types::global_dof_index, double> boundary_values;'
p44555
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p44556
aS'                                             0,'
p44557
aS'                                             Functions::ZeroFunction<dim>(),'
p44558
aS'                                             boundary_values);'
p44559
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p44560
aS'                                       system_matrix,'
p44561
aS'                                       newton_update,'
p44562
aS'                                       system_rhs);'
p44563
aS'  }'
p44564
aS'  template <int dim>'
p44565
aS'  void MinimalSurfaceProblem<dim>::solve()'
p44566
aS'  {'
p44567
aS'    SolverControl            solver_control(system_rhs.size(),'
p44568
aS'                                 system_rhs.l2_norm() * 1e-6);'
p44569
aS'    SolverCG<Vector<double>> solver(solver_control);'
p44570
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p44571
aS'    preconditioner.initialize(system_matrix, 1.2);'
p44572
aS'    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p44573
aS'    hanging_node_constraints.distribute(newton_update);'
p44574
aS'    const double alpha = determine_step_length();'
p44575
aS'    current_solution.add(alpha, newton_update);'
p44576
aS'  }'
p44577
aS'  template <int dim>'
p44578
aS'  void MinimalSurfaceProblem<dim>::refine_mesh()'
p44579
aS'  {'
p44580
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p44581
aS'    KellyErrorEstimator<dim>::estimate('
p44582
aS'      dof_handler,'
p44583
aS'      QGauss<dim - 1>(fe.degree + 1),'
p44584
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p44585
aS'      current_solution,'
p44586
aS'      estimated_error_per_cell);'
p44587
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p44588
aS'                                                    estimated_error_per_cell,'
p44589
aS'                                                    0.3,'
p44590
aS'                                                    0.03);'
p44591
aS'    triangulation.prepare_coarsening_and_refinement();'
p44592
aS'    SolutionTransfer<dim> solution_transfer(dof_handler);'
p44593
aS'    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);'
p44594
aS'    triangulation.execute_coarsening_and_refinement();'
p44595
aS'    dof_handler.distribute_dofs(fe);'
p44596
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p44597
aS'    solution_transfer.interpolate(current_solution, tmp);'
p44598
aS'    current_solution = tmp;'
p44599
aS'    hanging_node_constraints.clear();'
p44600
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p44601
aS'                                            hanging_node_constraints);'
p44602
aS'    hanging_node_constraints.close();'
p44603
aS'    set_boundary_values();'
p44604
aS'    setup_system(false);'
p44605
aS'  }'
p44606
aS'  template <int dim>'
p44607
aS'  void MinimalSurfaceProblem<dim>::set_boundary_values()'
p44608
aS'  {'
p44609
aS'    std::map<types::global_dof_index, double> boundary_values;'
p44610
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p44611
aS'                                             0,'
p44612
aS'                                             BoundaryValues<dim>(),'
p44613
aS'                                             boundary_values);'
p44614
aS'    for (auto &boundary_value : boundary_values)'
p44615
aS'      current_solution(boundary_value.first) = boundary_value.second;'
p44616
aS'    hanging_node_constraints.distribute(current_solution);'
p44617
aS'  }'
p44618
aS'  template <int dim>'
p44619
aS'  double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const'
p44620
aS'  {'
p44621
aS'    Vector<double> residual(dof_handler.n_dofs());'
p44622
aS'    Vector<double> evaluation_point(dof_handler.n_dofs());'
p44623
aS'    evaluation_point = current_solution;'
p44624
aS'    evaluation_point.add(alpha, newton_update);'
p44625
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p44626
aS'    FEValues<dim>     fe_values(fe,'
p44627
aS'                            quadrature_formula,'
p44628
aS'                            update_gradients | update_quadrature_points |'
p44629
aS'                              update_JxW_values);'
p44630
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p44631
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p44632
aS'    Vector<double>              cell_residual(dofs_per_cell);'
p44633
aS'    std::vector<Tensor<1, dim>> gradients(n_q_points);'
p44634
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p44635
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p44636
aS'      {'
p44637
aS'        cell_residual = 0;'
p44638
aS'        fe_values.reinit(cell);'
p44639
aS'        fe_values.get_function_gradients(evaluation_point, gradients);'
p44640
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p44641
aS'          {'
p44642
aS'            const double coeff ='
p44643
aS'              1.0 / std::sqrt(1.0 + gradients[q] * gradients[q]);'
p44644
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p44645
aS'              cell_residual(i) -= (fe_values.shape_grad(i, q) // \\nabla \\phi_i'
p44646
aS'                                   * coeff                    // * a_n'
p44647
aS'                                   * gradients[q]             // * u_n'
p44648
aS'                                   * fe_values.JxW(q));       // * dx'
p44649
aS'          }'
p44650
aS'        cell->get_dof_indices(local_dof_indices);'
p44651
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p44652
aS'          residual(local_dof_indices[i]) += cell_residual(i);'
p44653
aS'      }'
p44654
aS'    hanging_node_constraints.condense(residual);'
p44655
aS'    for (types::global_dof_index i :'
p44656
aS'         DoFTools::extract_boundary_dofs(dof_handler))'
p44657
aS'      residual(i) = 0;'
p44658
aS'    return residual.l2_norm();'
p44659
aS'  }'
p44660
aS'  template <int dim>'
p44661
aS'  double MinimalSurfaceProblem<dim>::determine_step_length() const'
p44662
aS'  {'
p44663
aS'    return 0.1;'
p44664
aS'  }'
p44665
aS'  template <int dim>'
p44666
aS'  void MinimalSurfaceProblem<dim>::output_results('
p44667
aS'    const unsigned int refinement_cycle) const'
p44668
aS'  {'
p44669
aS'    DataOut<dim> data_out;'
p44670
aS'    data_out.attach_dof_handler(dof_handler);'
p44671
aS'    data_out.add_data_vector(current_solution, "solution");'
p44672
aS'    data_out.add_data_vector(newton_update, "update");'
p44673
aS'    data_out.build_patches();'
p44674
aS'    const std::string filename ='
p44675
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu";'
p44676
aS'    std::ofstream output(filename);'
p44677
aS'    data_out.write_vtu(output);'
p44678
aS'  }'
p44679
aS'  template <int dim>'
p44680
aS'  void MinimalSurfaceProblem<dim>::run(const int    formulation,'
p44681
aS'                                       const double tolerance)'
p44682
aS'  {'
p44683
aS'    std::cout << "******** Assembly approach ********" << std::endl;'
p44684
aS'    const std::array<std::string, 3> method_descriptions = {'
p44685
aS'      {"Unassisted implementation (full hand linearization).",'
p44686
aS'       "Automated linearization of the finite element residual.",'
p44687
aS'       "Automated computation of finite element residual and linearization using a variational formulation."}};'
p44688
aS'    AssertIndexRange(formulation, method_descriptions.size());'
p44689
aS'    std::cout << method_descriptions[formulation] << std::endl << std::endl;'
p44690
aS'    TimerOutput timer(std::cout, TimerOutput::summary, TimerOutput::wall_times);'
p44691
aS'    GridGenerator::hyper_ball(triangulation);'
p44692
aS'    triangulation.refine_global(2);'
p44693
aS'    setup_system(/*first time=*/true);'
p44694
aS'    set_boundary_values();'
p44695
aS'    double       last_residual_norm = std::numeric_limits<double>::max();'
p44696
aS'    unsigned int refinement_cycle   = 0;'
p44697
aS'    do'
p44698
aS'      {'
p44699
aS'        std::cout << "Mesh refinement step " << refinement_cycle << std::endl;'
p44700
aS'        if (refinement_cycle != 0)'
p44701
aS'          refine_mesh();'
p44702
aS'        std::cout << "  Initial residual: " << compute_residual(0) << std::endl;'
p44703
aS'        for (unsigned int inner_iteration = 0; inner_iteration < 5;'
p44704
aS'             ++inner_iteration)'
p44705
aS'          {'
p44706
aS'            {'
p44707
aS'              TimerOutput::Scope t(timer, "Assemble");'
p44708
aS'              if (formulation == 0)'
p44709
aS'                assemble_system_unassisted();'
p44710
aS'              else if (formulation == 1)'
p44711
aS'                assemble_system_with_residual_linearization();'
p44712
aS'              else if (formulation == 2)'
p44713
aS'                assemble_system_using_energy_functional();'
p44714
aS'              else'
p44715
aS'                AssertThrow(false, ExcNotImplemented());'
p44716
aS'            }'
p44717
aS'            last_residual_norm = system_rhs.l2_norm();'
p44718
aS'            {'
p44719
aS'              TimerOutput::Scope t(timer, "Solve");'
p44720
aS'              solve();'
p44721
aS'            }'
p44722
aS'            std::cout << "  Residual: " << compute_residual(0) << std::endl;'
p44723
aS'          }'
p44724
aS'        output_results(refinement_cycle);'
p44725
aS'        ++refinement_cycle;'
p44726
aS'        std::cout << std::endl;'
p44727
aS'      }'
p44728
aS'    while (last_residual_norm > tolerance);'
p44729
aS'  }'
p44730
aS'} // namespace Step72'
p44731
aS'int main(int argc, char *argv[])'
p44732
ag24
aS'  try'
p44733
aS'    {'
p44734
aS'      using namespace Step72;'
p44735
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);'
p44736
aS'      std::string prm_file;'
p44737
aS'      if (argc > 1)'
p44738
aS'        prm_file = argv[1];'
p44739
aS'      else'
p44740
aS'        prm_file = "parameters.prm";'
p44741
aS'      const MinimalSurfaceProblemParameters parameters;'
p44742
aS'      ParameterAcceptor::initialize(prm_file);'
p44743
aS'      MinimalSurfaceProblem<2> minimal_surface_problem_2d;'
p44744
aS'      minimal_surface_problem_2d.run(parameters.formulation,'
p44745
aS'                                     parameters.tolerance);'
p44746
aS'    }'
p44747
aS'  catch (std::exception &exc)'
p44748
aS'    {'
p44749
aS'      std::cerr << std::endl'
p44750
aS'                << std::endl'
p44751
aS'                << "----------------------------------------------------"'
p44752
aS'                << std::endl;'
p44753
aS'      std::cerr << "Exception on processing: " << std::endl'
p44754
aS'                << exc.what() << std::endl'
p44755
aS'                << "Aborting!" << std::endl'
p44756
aS'                << "----------------------------------------------------"'
p44757
aS'                << std::endl;'
p44758
aS'      return 1;'
p44759
aS'    }'
p44760
aS'  catch (...)'
p44761
aS'    {'
p44762
aS'      std::cerr << std::endl'
p44763
aS'                << std::endl'
p44764
aS'                << "----------------------------------------------------"'
p44765
aS'                << std::endl;'
p44766
aS'      std::cerr << "Unknown exception!" << std::endl'
p44767
aS'                << "Aborting!" << std::endl'
p44768
aS'                << "----------------------------------------------------"'
p44769
aS'                << std::endl;'
p44770
aS'      return 1;'
p44771
aS'    }'
p44772
aS'  return 0;'
p44773
ag32
aS'/* ---------------------------------------------------------------------'
p44774
aS' *'
p44775
aS' * Copyright (C) 2020 - 2021 by the deal.II authors'
p44776
aS' *'
p44777
aS' * This file is part of the deal.II library.'
p44778
aS' *'
p44779
aS' * The deal.II library is free software; you can use it, redistribute'
p44780
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p44781
aS' * Public License as published by the Free Software Foundation; either'
p44782
aS' * version 2.1 of the License, or (at your option) any later version.'
p44783
aS' * The full text of the license can be found in the file LICENSE at'
p44784
aS' * the top level of the deal.II distribution.'
p44785
aS' *'
p44786
aS' * ---------------------------------------------------------------------'
p44787
aS' *'
p44788
aS' * Author: Timo Heister and Jiaqi Zhang, Clemson University, 2020'
p44789
aS' */'
p44790
aS'#include <deal.II/base/quadrature_lib.h>'
p44791
aS'#include <deal.II/base/function.h>'
p44792
aS'#include <deal.II/base/function_lib.h>'
p44793
aS'#include <deal.II/lac/vector.h>'
p44794
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p44795
aS'#include <deal.II/lac/sparse_matrix.h>'
p44796
aS'#include <deal.II/lac/sparse_direct.h>'
p44797
aS'#include <deal.II/grid/tria.h>'
p44798
aS'#include <deal.II/grid/grid_generator.h>'
p44799
aS'#include <deal.II/grid/grid_out.h>'
p44800
aS'#include <deal.II/grid/grid_refinement.h>'
p44801
aS'#include <deal.II/fe/fe_values.h>'
p44802
aS'#include <deal.II/dofs/dof_handler.h>'
p44803
aS'#include <deal.II/dofs/dof_tools.h>'
p44804
aS'#include <deal.II/numerics/data_out.h>'
p44805
aS'#include <deal.II/fe/mapping_q1.h>'
p44806
aS'#include <deal.II/fe/fe_dgq.h>'
p44807
aS'#include <deal.II/fe/fe_interface_values.h>'
p44808
aS'#include <deal.II/numerics/derivative_approximation.h>'
p44809
aS'#include <deal.II/numerics/vector_tools.h>'
p44810
aS'#include <deal.II/base/convergence_table.h>'
p44811
aS'#include <deal.II/meshworker/copy_data.h>'
p44812
aS'#include <deal.II/meshworker/mesh_loop.h>'
p44813
aS'#include <deal.II/meshworker/scratch_data.h>'
p44814
aS'namespace Step74'
p44815
ag24
aS'  using namespace dealii;'
p44816
aS'  enum class TestCase'
p44817
aS'  {'
p44818
aS'    convergence_rate,'
p44819
aS'    l_singularity'
p44820
aS'  };'
p44821
aS'  template <int dim>'
p44822
aS'  class SmoothSolution : public Function<dim>'
p44823
aS'  {'
p44824
aS'  public:'
p44825
aS'    SmoothSolution()'
p44826
aS'      : Function<dim>()'
p44827
aS'    {}'
p44828
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p44829
aS'                            std::vector<double> &          values,'
p44830
aS'                            const unsigned int component = 0) const override;'
p44831
aS'    virtual Tensor<1, dim>'
p44832
aS'    gradient(const Point<dim> & point,'
p44833
aS'             const unsigned int component = 0) const override;'
p44834
aS'  };'
p44835
aS'  template <int dim>'
p44836
aS'  void SmoothSolution<dim>::value_list(const std::vector<Point<dim>> &points,'
p44837
aS'                                       std::vector<double> &          values,'
p44838
aS'                                       const unsigned int /*component*/) const'
p44839
aS'  {'
p44840
aS'    using numbers::PI;'
p44841
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p44842
aS'      values[i] ='
p44843
aS'        std::sin(2. * PI * points[i][0]) * std::sin(2. * PI * points[i][1]);'
p44844
aS'  }'
p44845
aS'  template <int dim>'
p44846
aS'  Tensor<1, dim>'
p44847
aS'  SmoothSolution<dim>::gradient(const Point<dim> &point,'
p44848
aS'                                const unsigned int /*component*/) const'
p44849
aS'  {'
p44850
aS'    Tensor<1, dim> return_value;'
p44851
aS'    using numbers::PI;'
p44852
aS'    return_value[0] ='
p44853
aS'      2. * PI * std::cos(2. * PI * point[0]) * std::sin(2. * PI * point[1]);'
p44854
aS'    return_value[1] ='
p44855
aS'      2. * PI * std::sin(2. * PI * point[0]) * std::cos(2. * PI * point[1]);'
p44856
aS'    return return_value;'
p44857
aS'  }'
p44858
aS'  template <int dim>'
p44859
aS'  class SmoothRightHandSide : public Function<dim>'
p44860
aS'  {'
p44861
aS'  public:'
p44862
aS'    SmoothRightHandSide()'
p44863
aS'      : Function<dim>()'
p44864
aS'    {}'
p44865
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p44866
aS'                            std::vector<double> &          values,'
p44867
aS'                            const unsigned int /*component*/) const override;'
p44868
aS'  };'
p44869
aS'  template <int dim>'
p44870
aS'  void'
p44871
aS'  SmoothRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,'
p44872
aS'                                       std::vector<double> &          values,'
p44873
aS'                                       const unsigned int /*component*/) const'
p44874
aS'  {'
p44875
aS'    using numbers::PI;'
p44876
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p44877
aS'      values[i] = 8. * PI * PI * std::sin(2. * PI * points[i][0]) *'
p44878
aS'                  std::sin(2. * PI * points[i][1]);'
p44879
aS'  }'
p44880
aS'  template <int dim>'
p44881
aS'  class SingularRightHandSide : public Function<dim>'
p44882
aS'  {'
p44883
aS'  public:'
p44884
aS'    SingularRightHandSide()'
p44885
aS'      : Function<dim>()'
p44886
aS'    {}'
p44887
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p44888
aS'                            std::vector<double> &          values,'
p44889
aS'                            const unsigned int /*component*/) const override;'
p44890
aS'  private:'
p44891
aS'    const Functions::LSingularityFunction ref;'
p44892
aS'  };'
p44893
aS'  template <int dim>'
p44894
aS'  void'
p44895
aS'  SingularRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,'
p44896
aS'                                         std::vector<double> &          values,'
p44897
aS'                                         const unsigned int /*component*/) const'
p44898
aS'  {'
p44899
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p44900
aS'      values[i] = -ref.laplacian(points[i]);'
p44901
aS'  }'
p44902
aS'  template <int dim>'
p44903
aS'  void get_function_jump(const FEInterfaceValues<dim> &fe_iv,'
p44904
aS'                         const Vector<double> &        solution,'
p44905
aS'                         std::vector<double> &         jump)'
p44906
aS'  {'
p44907
aS'    const unsigned int                 n_q = fe_iv.n_quadrature_points;'
p44908
aS'    std::array<std::vector<double>, 2> face_values;'
p44909
aS'    jump.resize(n_q);'
p44910
aS'    for (unsigned int i = 0; i < 2; ++i)'
p44911
aS'      {'
p44912
aS'        face_values[i].resize(n_q);'
p44913
aS'        fe_iv.get_fe_face_values(i).get_function_values(solution,'
p44914
aS'                                                        face_values[i]);'
p44915
aS'      }'
p44916
aS'    for (unsigned int q = 0; q < n_q; ++q)'
p44917
aS'      jump[q] = face_values[0][q] - face_values[1][q];'
p44918
aS'  }'
p44919
aS'  template <int dim>'
p44920
aS'  void get_function_gradient_jump(const FEInterfaceValues<dim> &fe_iv,'
p44921
aS'                                  const Vector<double> &        solution,'
p44922
aS'                                  std::vector<Tensor<1, dim>> & gradient_jump)'
p44923
aS'  {'
p44924
aS'    const unsigned int          n_q = fe_iv.n_quadrature_points;'
p44925
aS'    std::vector<Tensor<1, dim>> face_gradients[2];'
p44926
aS'    gradient_jump.resize(n_q);'
p44927
aS'    for (unsigned int i = 0; i < 2; ++i)'
p44928
aS'      {'
p44929
aS'        face_gradients[i].resize(n_q);'
p44930
aS'        fe_iv.get_fe_face_values(i).get_function_gradients(solution,'
p44931
aS'                                                           face_gradients[i]);'
p44932
aS'      }'
p44933
aS'    for (unsigned int q = 0; q < n_q; ++q)'
p44934
aS'      gradient_jump[q] = face_gradients[0][q] - face_gradients[1][q];'
p44935
aS'  }'
p44936
aS'  double get_penalty_factor(const unsigned int fe_degree,'
p44937
aS'                            const double       cell_extent_left,'
p44938
aS'                            const double       cell_extent_right)'
p44939
aS'  {'
p44940
aS'    const unsigned int degree = std::max(1U, fe_degree);'
p44941
aS'    return degree * (degree + 1.) * 0.5 *'
p44942
aS'           (1. / cell_extent_left + 1. / cell_extent_right);'
p44943
aS'  }'
p44944
aS'  struct CopyDataFace'
p44945
aS'  {'
p44946
aS'    FullMatrix<double>                   cell_matrix;'
p44947
aS'    std::vector<types::global_dof_index> joint_dof_indices;'
p44948
aS'    std::array<double, 2>                values;'
p44949
aS'    std::array<unsigned int, 2>          cell_indices;'
p44950
aS'  };'
p44951
aS'  struct CopyData'
p44952
aS'  {'
p44953
aS'    FullMatrix<double>                   cell_matrix;'
p44954
aS'    Vector<double>                       cell_rhs;'
p44955
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p44956
aS'    std::vector<CopyDataFace>            face_data;'
p44957
aS'    double                               value;'
p44958
aS'    unsigned int                         cell_index;'
p44959
aS'    template <class Iterator>'
p44960
aS'    void reinit(const Iterator &cell, const unsigned int dofs_per_cell)'
p44961
aS'    {'
p44962
aS'      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p44963
aS'      cell_rhs.reinit(dofs_per_cell);'
p44964
aS'      local_dof_indices.resize(dofs_per_cell);'
p44965
aS'      cell->get_dof_indices(local_dof_indices);'
p44966
aS'    }'
p44967
aS'  };'
p44968
aS'  template <int dim>'
p44969
aS'  class SIPGLaplace'
p44970
aS'  {'
p44971
aS'  public:'
p44972
aS'    SIPGLaplace(const TestCase &test_case);'
p44973
aS'    void run();'
p44974
aS'  private:'
p44975
aS'    void setup_system();'
p44976
aS'    void assemble_system();'
p44977
aS'    void solve();'
p44978
aS'    void refine_grid();'
p44979
aS'    void output_results(const unsigned int cycle) const;'
p44980
aS'    void   compute_errors();'
p44981
aS'    void   compute_error_estimate();'
p44982
aS'    double compute_energy_norm_error();'
p44983
aS'    Triangulation<dim>    triangulation;'
p44984
aS'    const unsigned int    degree;'
p44985
aS'    const QGauss<dim>     quadrature;'
p44986
aS'    const QGauss<dim - 1> face_quadrature;'
p44987
aS'    const QGauss<dim>     quadrature_overintegration;'
p44988
aS'    const QGauss<dim - 1> face_quadrature_overintegration;'
p44989
aS'    const MappingQ1<dim>  mapping;'
p44990
aS'    using ScratchData = MeshWorker::ScratchData<dim>;'
p44991
aS'    const FE_DGQ<dim> fe;'
p44992
aS'    DoFHandler<dim>   dof_handler;'
p44993
aS'    SparsityPattern      sparsity_pattern;'
p44994
aS'    SparseMatrix<double> system_matrix;'
p44995
aS'    Vector<double>       solution;'
p44996
aS'    Vector<double>       system_rhs;'
p44997
aS'    Vector<double> estimated_error_square_per_cell;'
p44998
aS'    Vector<double> energy_norm_square_per_cell;'
p44999
aS'    ConvergenceTable convergence_table;'
p45000
aS'    const double diffusion_coefficient = 1.;'
p45001
aS'    const TestCase                       test_case;'
p45002
aS'    std::unique_ptr<const Function<dim>> exact_solution;'
p45003
aS'    std::unique_ptr<const Function<dim>> rhs_function;'
p45004
aS'  };'
p45005
aS'  template <int dim>'
p45006
aS'  SIPGLaplace<dim>::SIPGLaplace(const TestCase &test_case)'
p45007
aS'    : degree(3)'
p45008
aS'    , quadrature(degree + 1)'
p45009
aS'    , face_quadrature(degree + 1)'
p45010
aS'    , quadrature_overintegration(degree + 2)'
p45011
aS'    , face_quadrature_overintegration(degree + 2)'
p45012
aS'    , mapping()'
p45013
aS'    , fe(degree)'
p45014
aS'    , dof_handler(triangulation)'
p45015
aS'    , test_case(test_case)'
p45016
aS'  {'
p45017
aS'    if (test_case == TestCase::convergence_rate)'
p45018
aS'      {'
p45019
aS'        exact_solution = std::make_unique<const SmoothSolution<dim>>();'
p45020
aS'        rhs_function   = std::make_unique<const SmoothRightHandSide<dim>>();'
p45021
aS'      }'
p45022
aS'    else if (test_case == TestCase::l_singularity)'
p45023
aS'      {'
p45024
aS'        exact_solution ='
p45025
aS'          std::make_unique<const Functions::LSingularityFunction>();'
p45026
aS'        rhs_function = std::make_unique<const SingularRightHandSide<dim>>();'
p45027
aS'      }'
p45028
aS'    else'
p45029
aS'      AssertThrow(false, ExcNotImplemented());'
p45030
aS'  }'
p45031
aS'  template <int dim>'
p45032
aS'  void SIPGLaplace<dim>::setup_system()'
p45033
aS'  {'
p45034
aS'    dof_handler.distribute_dofs(fe);'
p45035
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p45036
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p45037
aS'    sparsity_pattern.copy_from(dsp);'
p45038
aS'    system_matrix.reinit(sparsity_pattern);'
p45039
aS'    solution.reinit(dof_handler.n_dofs());'
p45040
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p45041
aS'  }'
p45042
aS'  template <int dim>'
p45043
aS'  void SIPGLaplace<dim>::assemble_system()'
p45044
aS'  {'
p45045
aS'    const auto cell_worker ='
p45046
aS'      [&](const auto &cell, auto &scratch_data, auto &copy_data) {'
p45047
aS'        const FEValues<dim> &fe_v          = scratch_data.reinit(cell);'
p45048
aS'        const unsigned int   dofs_per_cell = fe_v.dofs_per_cell;'
p45049
aS'        copy_data.reinit(cell, dofs_per_cell);'
p45050
aS'        const auto &       q_points    = scratch_data.get_quadrature_points();'
p45051
aS'        const unsigned int n_q_points  = q_points.size();'
p45052
aS'        const std::vector<double> &JxW = scratch_data.get_JxW_values();'
p45053
aS'        std::vector<double> rhs(n_q_points);'
p45054
aS'        rhs_function->value_list(q_points, rhs);'
p45055
aS'        for (unsigned int point = 0; point < n_q_points; ++point)'
p45056
aS'          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p45057
aS'            {'
p45058
aS'              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p45059
aS'                copy_data.cell_matrix(i, j) +='
p45060
aS'                  diffusion_coefficient *     // nu'
p45061
aS'                  fe_v.shape_grad(i, point) * // grad v_h'
p45062
aS'                  fe_v.shape_grad(j, point) * // grad u_h'
p45063
aS'                  JxW[point];                 // dx'
p45064
aS'              copy_data.cell_rhs(i) += fe_v.shape_value(i, point) * // v_h'
p45065
aS'                                       rhs[point] *                 // f'
p45066
aS'                                       JxW[point];                  // dx'
p45067
aS'            }'
p45068
aS'      };'
p45069
aS'    const auto boundary_worker = [&](const auto &        cell,'
p45070
aS'                                     const unsigned int &face_no,'
p45071
aS'                                     auto &              scratch_data,'
p45072
aS'                                     auto &              copy_data) {'
p45073
aS'      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);'
p45074
aS'      const auto &       q_points      = scratch_data.get_quadrature_points();'
p45075
aS'      const unsigned int n_q_points    = q_points.size();'
p45076
aS'      const unsigned int dofs_per_cell = fe_fv.dofs_per_cell;'
p45077
aS'      const std::vector<double> &        JxW = scratch_data.get_JxW_values();'
p45078
aS'      const std::vector<Tensor<1, dim>> &normals ='
p45079
aS'        scratch_data.get_normal_vectors();'
p45080
aS'      std::vector<double> g(n_q_points);'
p45081
aS'      exact_solution->value_list(q_points, g);'
p45082
aS'      const double extent1 = cell->measure() / cell->face(face_no)->measure();'
p45083
aS'      const double penalty = get_penalty_factor(degree, extent1, extent1);'
p45084
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p45085
aS'        {'
p45086
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p45087
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p45088
aS'              copy_data.cell_matrix(i, j) +='
p45089
aS'                (-diffusion_coefficient *        // - nu'
p45090
aS'                   fe_fv.shape_value(i, point) * // v_h'
p45091
aS'                   (fe_fv.shape_grad(j, point) * // (grad u_h .'
p45092
aS'                    normals[point])              //  n)'
p45093
aS'                 - diffusion_coefficient *         // - nu'
p45094
aS'                     (fe_fv.shape_grad(i, point) * // (grad v_h .'
p45095
aS'                      normals[point]) *            //  n)'
p45096
aS'                     fe_fv.shape_value(j, point)   // u_h'
p45097
aS'                 + diffusion_coefficient * penalty * // + nu sigma'
p45098
aS'                     fe_fv.shape_value(i, point) *   // v_h'
p45099
aS'                     fe_fv.shape_value(j, point)     // u_h'
p45100
aS'                 ) *'
p45101
aS'                JxW[point]; // dx'
p45102
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p45103
aS'            copy_data.cell_rhs(i) +='
p45104
aS'              (-diffusion_coefficient *        // - nu'
p45105
aS'                 (fe_fv.shape_grad(i, point) * // (grad v_h .'
p45106
aS'                  normals[point]) *            //  n)'
p45107
aS'                 g[point]                      // g'
p45108
aS'               + diffusion_coefficient * penalty *        // + nu sigma'
p45109
aS'                   fe_fv.shape_value(i, point) * g[point] // v_h g'
p45110
aS'               ) *'
p45111
aS'              JxW[point]; // dx'
p45112
aS'        }'
p45113
aS'    };'
p45114
aS'    const auto face_worker = [&](const auto &        cell,'
p45115
aS'                                 const unsigned int &f,'
p45116
aS'                                 const unsigned int &sf,'
p45117
aS'                                 const auto &        ncell,'
p45118
aS'                                 const unsigned int &nf,'
p45119
aS'                                 const unsigned int &nsf,'
p45120
aS'                                 auto &              scratch_data,'
p45121
aS'                                 auto &              copy_data) {'
p45122
aS'      const FEInterfaceValues<dim> &fe_iv ='
p45123
aS'        scratch_data.reinit(cell, f, sf, ncell, nf, nsf);'
p45124
aS'      const auto &       q_points   = fe_iv.get_quadrature_points();'
p45125
aS'      const unsigned int n_q_points = q_points.size();'
p45126
aS'      copy_data.face_data.emplace_back();'
p45127
aS'      CopyDataFace &     copy_data_face = copy_data.face_data.back();'
p45128
aS'      const unsigned int n_dofs_face    = fe_iv.n_current_interface_dofs();'
p45129
aS'      copy_data_face.joint_dof_indices  = fe_iv.get_interface_dof_indices();'
p45130
aS'      copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face);'
p45131
aS'      const std::vector<double> &        JxW     = fe_iv.get_JxW_values();'
p45132
aS'      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();'
p45133
aS'      const double extent1 = cell->measure() / cell->face(f)->measure();'
p45134
aS'      const double extent2 = ncell->measure() / ncell->face(nf)->measure();'
p45135
aS'      const double penalty = get_penalty_factor(degree, extent1, extent2);'
p45136
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p45137
aS'        {'
p45138
aS'          for (unsigned int i = 0; i < n_dofs_face; ++i)'
p45139
aS'            for (unsigned int j = 0; j < n_dofs_face; ++j)'
p45140
aS'              copy_data_face.cell_matrix(i, j) +='
p45141
aS'                (-diffusion_coefficient *              // - nu'
p45142
aS'                   fe_iv.jump(i, point) *              // [v_h]'
p45143
aS'                   (fe_iv.average_gradient(j, point) * // ({grad u_h} .'
p45144
aS'                    normals[point])                    //  n)'
p45145
aS'                 - diffusion_coefficient *               // - nu'
p45146
aS'                     (fe_iv.average_gradient(i, point) * // (grad v_h .'
p45147
aS'                      normals[point]) *                  //  n)'
p45148
aS'                     fe_iv.jump(j, point)                // [u_h]'
p45149
aS'                 + diffusion_coefficient * penalty * // + nu sigma'
p45150
aS'                     fe_iv.jump(i, point) *          // [v_h]'
p45151
aS'                     fe_iv.jump(j, point)            // [u_h]'
p45152
aS'                 ) *'
p45153
aS'                JxW[point]; // dx'
p45154
aS'        }'
p45155
aS'    };'
p45156
aS'    AffineConstraints<double> constraints;'
p45157
aS'    constraints.close();'
p45158
aS'    const auto copier = [&](const auto &c) {'
p45159
aS'      constraints.distribute_local_to_global(c.cell_matrix,'
p45160
aS'                                             c.cell_rhs,'
p45161
aS'                                             c.local_dof_indices,'
p45162
aS'                                             system_matrix,'
p45163
aS'                                             system_rhs);'
p45164
aS'      for (auto &cdf : c.face_data)'
p45165
aS'        {'
p45166
aS'          constraints.distribute_local_to_global(cdf.cell_matrix,'
p45167
aS'                                                 cdf.joint_dof_indices,'
p45168
aS'                                                 system_matrix);'
p45169
aS'        }'
p45170
aS'    };'
p45171
aS'    const UpdateFlags cell_flags = update_values | update_gradients |'
p45172
aS'                                   update_quadrature_points | update_JxW_values;'
p45173
aS'    const UpdateFlags face_flags = update_values | update_gradients |'
p45174
aS'                                   update_quadrature_points |'
p45175
aS'                                   update_normal_vectors | update_JxW_values;'
p45176
aS'    ScratchData scratch_data('
p45177
aS'      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);'
p45178
aS'    CopyData copy_data;'
p45179
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p45180
aS'                          dof_handler.end(),'
p45181
aS'                          cell_worker,'
p45182
aS'                          copier,'
p45183
aS'                          scratch_data,'
p45184
aS'                          copy_data,'
p45185
aS'                          MeshWorker::assemble_own_cells |'
p45186
aS'                            MeshWorker::assemble_boundary_faces |'
p45187
aS'                            MeshWorker::assemble_own_interior_faces_once,'
p45188
aS'                          boundary_worker,'
p45189
aS'                          face_worker);'
p45190
aS'  }'
p45191
aS'  template <int dim>'
p45192
aS'  void SIPGLaplace<dim>::solve()'
p45193
aS'  {'
p45194
aS'    SparseDirectUMFPACK A_direct;'
p45195
aS'    A_direct.initialize(system_matrix);'
p45196
aS'    A_direct.vmult(solution, system_rhs);'
p45197
aS'  }'
p45198
aS'  template <int dim>'
p45199
aS'  void SIPGLaplace<dim>::output_results(const unsigned int cycle) const'
p45200
aS'  {'
p45201
aS'    const std::string filename = "sol_Q" + Utilities::int_to_string(degree, 1) +'
p45202
aS'                                 "-" + Utilities::int_to_string(cycle, 2) +'
p45203
aS'                                 ".vtu";'
p45204
aS'    std::ofstream output(filename);'
p45205
aS'    DataOut<dim> data_out;'
p45206
aS'    data_out.attach_dof_handler(dof_handler);'
p45207
aS'    data_out.add_data_vector(solution, "u", DataOut<dim>::type_dof_data);'
p45208
aS'    data_out.build_patches(mapping);'
p45209
aS'    data_out.write_vtu(output);'
p45210
aS'  }'
p45211
aS'  template <int dim>'
p45212
aS'  void SIPGLaplace<dim>::compute_error_estimate()'
p45213
aS'  {'
p45214
aS'    const auto cell_worker ='
p45215
aS'      [&](const auto &cell, auto &scratch_data, auto &copy_data) {'
p45216
aS'        const FEValues<dim> &fe_v = scratch_data.reinit(cell);'
p45217
aS'        copy_data.cell_index = cell->active_cell_index();'
p45218
aS'        const auto &               q_points   = fe_v.get_quadrature_points();'
p45219
aS'        const unsigned int         n_q_points = q_points.size();'
p45220
aS'        const std::vector<double> &JxW        = fe_v.get_JxW_values();'
p45221
aS'        std::vector<Tensor<2, dim>> hessians(n_q_points);'
p45222
aS'        fe_v.get_function_hessians(solution, hessians);'
p45223
aS'        std::vector<double> rhs(n_q_points);'
p45224
aS'        rhs_function->value_list(q_points, rhs);'
p45225
aS'        const double hk                   = cell->diameter();'
p45226
aS'        double       residual_norm_square = 0;'
p45227
aS'        for (unsigned int point = 0; point < n_q_points; ++point)'
p45228
aS'          {'
p45229
aS'            const double residual ='
p45230
aS'              rhs[point] + diffusion_coefficient * trace(hessians[point]);'
p45231
aS'            residual_norm_square += residual * residual * JxW[point];'
p45232
aS'          }'
p45233
aS'        copy_data.value = hk * hk * residual_norm_square;'
p45234
aS'      };'
p45235
aS'    const auto boundary_worker = [&](const auto &        cell,'
p45236
aS'                                     const unsigned int &face_no,'
p45237
aS'                                     auto &              scratch_data,'
p45238
aS'                                     auto &              copy_data) {'
p45239
aS'      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);'
p45240
aS'      const auto &   q_points   = fe_fv.get_quadrature_points();'
p45241
aS'      const unsigned n_q_points = q_points.size();'
p45242
aS'      const std::vector<double> &JxW = fe_fv.get_JxW_values();'
p45243
aS'      std::vector<double> g(n_q_points);'
p45244
aS'      exact_solution->value_list(q_points, g);'
p45245
aS'      std::vector<double> sol_u(n_q_points);'
p45246
aS'      fe_fv.get_function_values(solution, sol_u);'
p45247
aS'      const double extent1 = cell->measure() / cell->face(face_no)->measure();'
p45248
aS'      const double penalty = get_penalty_factor(degree, extent1, extent1);'
p45249
aS'      double difference_norm_square = 0.;'
p45250
aS'      for (unsigned int point = 0; point < q_points.size(); ++point)'
p45251
aS'        {'
p45252
aS'          const double diff = (g[point] - sol_u[point]);'
p45253
aS'          difference_norm_square += diff * diff * JxW[point];'
p45254
aS'        }'
p45255
aS'      copy_data.value += penalty * difference_norm_square;'
p45256
aS'    };'
p45257
aS'    const auto face_worker = [&](const auto &        cell,'
p45258
aS'                                 const unsigned int &f,'
p45259
aS'                                 const unsigned int &sf,'
p45260
aS'                                 const auto &        ncell,'
p45261
aS'                                 const unsigned int &nf,'
p45262
aS'                                 const unsigned int &nsf,'
p45263
aS'                                 auto &              scratch_data,'
p45264
aS'                                 auto &              copy_data) {'
p45265
aS'      const FEInterfaceValues<dim> &fe_iv ='
p45266
aS'        scratch_data.reinit(cell, f, sf, ncell, nf, nsf);'
p45267
aS'      copy_data.face_data.emplace_back();'
p45268
aS'      CopyDataFace &copy_data_face = copy_data.face_data.back();'
p45269
aS'      copy_data_face.cell_indices[0] = cell->active_cell_index();'
p45270
aS'      copy_data_face.cell_indices[1] = ncell->active_cell_index();'
p45271
aS'      const std::vector<double> &        JxW     = fe_iv.get_JxW_values();'
p45272
aS'      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();'
p45273
aS'      const auto &       q_points   = fe_iv.get_quadrature_points();'
p45274
aS'      const unsigned int n_q_points = q_points.size();'
p45275
aS'      std::vector<double> jump(n_q_points);'
p45276
aS'      get_function_jump(fe_iv, solution, jump);'
p45277
aS'      std::vector<Tensor<1, dim>> grad_jump(n_q_points);'
p45278
aS'      get_function_gradient_jump(fe_iv, solution, grad_jump);'
p45279
aS'      const double h = cell->face(f)->diameter();'
p45280
aS'      const double extent1 = cell->measure() / cell->face(f)->measure();'
p45281
aS'      const double extent2 = ncell->measure() / ncell->face(nf)->measure();'
p45282
aS'      const double penalty = get_penalty_factor(degree, extent1, extent2);'
p45283
aS'      double flux_jump_square = 0;'
p45284
aS'      double u_jump_square    = 0;'
p45285
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p45286
aS'        {'
p45287
aS'          u_jump_square += jump[point] * jump[point] * JxW[point];'
p45288
aS'          const double flux_jump = grad_jump[point] * normals[point];'
p45289
aS'          flux_jump_square +='
p45290
aS'            diffusion_coefficient * flux_jump * flux_jump * JxW[point];'
p45291
aS'        }'
p45292
aS'      copy_data_face.values[0] ='
p45293
aS'        0.5 * h * (flux_jump_square + penalty * u_jump_square);'
p45294
aS'      copy_data_face.values[1] = copy_data_face.values[0];'
p45295
aS'    };'
p45296
aS'    const auto copier = [&](const auto &copy_data) {'
p45297
aS'      if (copy_data.cell_index != numbers::invalid_unsigned_int)'
p45298
aS'        estimated_error_square_per_cell[copy_data.cell_index] +='
p45299
aS'          copy_data.value;'
p45300
aS'      for (auto &cdf : copy_data.face_data)'
p45301
aS'        for (unsigned int j = 0; j < 2; ++j)'
p45302
aS'          estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];'
p45303
aS'    };'
p45304
aS'    estimated_error_square_per_cell.reinit(triangulation.n_active_cells());'
p45305
aS'    const UpdateFlags cell_flags ='
p45306
aS'      update_hessians | update_quadrature_points | update_JxW_values;'
p45307
aS'    const UpdateFlags face_flags = update_values | update_gradients |'
p45308
aS'                                   update_quadrature_points |'
p45309
aS'                                   update_JxW_values | update_normal_vectors;'
p45310
aS'    ScratchData scratch_data('
p45311
aS'      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);'
p45312
aS'    CopyData copy_data;'
p45313
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p45314
aS'                          dof_handler.end(),'
p45315
aS'                          cell_worker,'
p45316
aS'                          copier,'
p45317
aS'                          scratch_data,'
p45318
aS'                          copy_data,'
p45319
aS'                          MeshWorker::assemble_own_cells |'
p45320
aS'                            MeshWorker::assemble_own_interior_faces_once |'
p45321
aS'                            MeshWorker::assemble_boundary_faces,'
p45322
aS'                          boundary_worker,'
p45323
aS'                          face_worker);'
p45324
aS'  }'
p45325
aS'  template <int dim>'
p45326
aS'  double SIPGLaplace<dim>::compute_energy_norm_error()'
p45327
aS'  {'
p45328
aS'    energy_norm_square_per_cell.reinit(triangulation.n_active_cells());'
p45329
aS'    const auto cell_worker ='
p45330
aS'      [&](const auto &cell, auto &scratch_data, auto &copy_data) {'
p45331
aS'        const FEValues<dim> &fe_v = scratch_data.reinit(cell);'
p45332
aS'        copy_data.cell_index = cell->active_cell_index();'
p45333
aS'        const auto &               q_points   = fe_v.get_quadrature_points();'
p45334
aS'        const unsigned int         n_q_points = q_points.size();'
p45335
aS'        const std::vector<double> &JxW        = fe_v.get_JxW_values();'
p45336
aS'        std::vector<Tensor<1, dim>> grad_u(n_q_points);'
p45337
aS'        fe_v.get_function_gradients(solution, grad_u);'
p45338
aS'        std::vector<Tensor<1, dim>> grad_exact(n_q_points);'
p45339
aS'        exact_solution->gradient_list(q_points, grad_exact);'
p45340
aS'        double norm_square = 0;'
p45341
aS'        for (unsigned int point = 0; point < n_q_points; ++point)'
p45342
aS'          {'
p45343
aS'            norm_square +='
p45344
aS'              (grad_u[point] - grad_exact[point]).norm_square() * JxW[point];'
p45345
aS'          }'
p45346
aS'        copy_data.value = diffusion_coefficient * norm_square;'
p45347
aS'      };'
p45348
aS'    const auto boundary_worker = [&](const auto &        cell,'
p45349
aS'                                     const unsigned int &face_no,'
p45350
aS'                                     auto &              scratch_data,'
p45351
aS'                                     auto &              copy_data) {'
p45352
aS'      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);'
p45353
aS'      const auto &   q_points   = fe_fv.get_quadrature_points();'
p45354
aS'      const unsigned n_q_points = q_points.size();'
p45355
aS'      const std::vector<double> &JxW = fe_fv.get_JxW_values();'
p45356
aS'      std::vector<double> g(n_q_points);'
p45357
aS'      exact_solution->value_list(q_points, g);'
p45358
aS'      std::vector<double> sol_u(n_q_points);'
p45359
aS'      fe_fv.get_function_values(solution, sol_u);'
p45360
aS'      const double extent1 = cell->measure() / cell->face(face_no)->measure();'
p45361
aS'      const double penalty = get_penalty_factor(degree, extent1, extent1);'
p45362
aS'      double difference_norm_square = 0.;'
p45363
aS'      for (unsigned int point = 0; point < q_points.size(); ++point)'
p45364
aS'        {'
p45365
aS'          const double diff = (g[point] - sol_u[point]);'
p45366
aS'          difference_norm_square += diff * diff * JxW[point];'
p45367
aS'        }'
p45368
aS'      copy_data.value += penalty * difference_norm_square;'
p45369
aS'    };'
p45370
aS'    const auto face_worker = [&](const auto &        cell,'
p45371
aS'                                 const unsigned int &f,'
p45372
aS'                                 const unsigned int &sf,'
p45373
aS'                                 const auto &        ncell,'
p45374
aS'                                 const unsigned int &nf,'
p45375
aS'                                 const unsigned int &nsf,'
p45376
aS'                                 auto &              scratch_data,'
p45377
aS'                                 auto &              copy_data) {'
p45378
aS'      const FEInterfaceValues<dim> &fe_iv ='
p45379
aS'        scratch_data.reinit(cell, f, sf, ncell, nf, nsf);'
p45380
aS'      copy_data.face_data.emplace_back();'
p45381
aS'      CopyDataFace &copy_data_face = copy_data.face_data.back();'
p45382
aS'      copy_data_face.cell_indices[0] = cell->active_cell_index();'
p45383
aS'      copy_data_face.cell_indices[1] = ncell->active_cell_index();'
p45384
aS'      const std::vector<double> &JxW = fe_iv.get_JxW_values();'
p45385
aS'      const auto &       q_points   = fe_iv.get_quadrature_points();'
p45386
aS'      const unsigned int n_q_points = q_points.size();'
p45387
aS'      std::vector<double> jump(n_q_points);'
p45388
aS'      get_function_jump(fe_iv, solution, jump);'
p45389
aS'      const double extent1 = cell->measure() / cell->face(f)->measure();'
p45390
aS'      const double extent2 = ncell->measure() / ncell->face(nf)->measure();'
p45391
aS'      const double penalty = get_penalty_factor(degree, extent1, extent2);'
p45392
aS'      double u_jump_square = 0;'
p45393
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p45394
aS'        {'
p45395
aS'          u_jump_square += jump[point] * jump[point] * JxW[point];'
p45396
aS'        }'
p45397
aS'      copy_data_face.values[0] = 0.5 * penalty * u_jump_square;'
p45398
aS'      copy_data_face.values[1] = copy_data_face.values[0];'
p45399
aS'    };'
p45400
aS'    const auto copier = [&](const auto &copy_data) {'
p45401
aS'      if (copy_data.cell_index != numbers::invalid_unsigned_int)'
p45402
aS'        energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value;'
p45403
aS'      for (auto &cdf : copy_data.face_data)'
p45404
aS'        for (unsigned int j = 0; j < 2; ++j)'
p45405
aS'          energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];'
p45406
aS'    };'
p45407
aS'    const UpdateFlags cell_flags ='
p45408
aS'      update_gradients | update_quadrature_points | update_JxW_values;'
p45409
aS'    UpdateFlags face_flags ='
p45410
aS'      update_values | update_quadrature_points | update_JxW_values;'
p45411
aS'    const ScratchData scratch_data(mapping,'
p45412
aS'                                   fe,'
p45413
aS'                                   quadrature_overintegration,'
p45414
aS'                                   cell_flags,'
p45415
aS'                                   face_quadrature_overintegration,'
p45416
aS'                                   face_flags);'
p45417
aS'    CopyData copy_data;'
p45418
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p45419
aS'                          dof_handler.end(),'
p45420
aS'                          cell_worker,'
p45421
aS'                          copier,'
p45422
aS'                          scratch_data,'
p45423
aS'                          copy_data,'
p45424
aS'                          MeshWorker::assemble_own_cells |'
p45425
aS'                            MeshWorker::assemble_own_interior_faces_once |'
p45426
aS'                            MeshWorker::assemble_boundary_faces,'
p45427
aS'                          boundary_worker,'
p45428
aS'                          face_worker);'
p45429
aS'    const double energy_error ='
p45430
aS'      std::sqrt(energy_norm_square_per_cell.l1_norm());'
p45431
aS'    return energy_error;'
p45432
aS'  }'
p45433
aS'  template <int dim>'
p45434
aS'  void SIPGLaplace<dim>::refine_grid()'
p45435
aS'  {'
p45436
aS'    const double refinement_fraction = 0.1;'
p45437
aS'    GridRefinement::refine_and_coarsen_fixed_number('
p45438
aS'      triangulation, estimated_error_square_per_cell, refinement_fraction, 0.);'
p45439
aS'    triangulation.execute_coarsening_and_refinement();'
p45440
aS'  }'
p45441
aS'  template <int dim>'
p45442
aS'  void SIPGLaplace<dim>::compute_errors()'
p45443
aS'  {'
p45444
aS'    double L2_error, H1_error, energy_error;'
p45445
aS'    {'
p45446
aS'      Vector<float> difference_per_cell(triangulation.n_active_cells());'
p45447
aS'      VectorTools::integrate_difference(mapping,'
p45448
aS'                                        dof_handler,'
p45449
aS'                                        solution,'
p45450
aS'                                        *(exact_solution.get()),'
p45451
aS'                                        difference_per_cell,'
p45452
aS'                                        quadrature_overintegration,'
p45453
aS'                                        VectorTools::L2_norm);'
p45454
aS'      L2_error = VectorTools::compute_global_error(triangulation,'
p45455
aS'                                                   difference_per_cell,'
p45456
aS'                                                   VectorTools::L2_norm);'
p45457
aS'      convergence_table.add_value("L2", L2_error);'
p45458
aS'    }'
p45459
aS'    {'
p45460
aS'      Vector<float> difference_per_cell(triangulation.n_active_cells());'
p45461
aS'      VectorTools::integrate_difference(mapping,'
p45462
aS'                                        dof_handler,'
p45463
aS'                                        solution,'
p45464
aS'                                        *(exact_solution.get()),'
p45465
aS'                                        difference_per_cell,'
p45466
aS'                                        quadrature_overintegration,'
p45467
aS'                                        VectorTools::H1_seminorm);'
p45468
aS'      H1_error = VectorTools::compute_global_error(triangulation,'
p45469
aS'                                                   difference_per_cell,'
p45470
aS'                                                   VectorTools::H1_seminorm);'
p45471
aS'      convergence_table.add_value("H1", H1_error);'
p45472
aS'    }'
p45473
aS'    {'
p45474
aS'      energy_error = compute_energy_norm_error();'
p45475
aS'      convergence_table.add_value("Energy", energy_error);'
p45476
aS'    }'
p45477
aS'    std::cout << "  Error in the L2 norm         : " << L2_error << std::endl'
p45478
aS'              << "  Error in the H1 seminorm     : " << H1_error << std::endl'
p45479
aS'              << "  Error in the energy norm     : " << energy_error'
p45480
aS'              << std::endl;'
p45481
aS'  }'
p45482
aS'  template <int dim>'
p45483
aS'  void SIPGLaplace<dim>::run()'
p45484
aS'  {'
p45485
aS'    const unsigned int max_cycle ='
p45486
aS'      (test_case == TestCase::convergence_rate ? 6 : 20);'
p45487
aS'    for (unsigned int cycle = 0; cycle < max_cycle; ++cycle)'
p45488
aS'      {'
p45489
aS'        std::cout << "Cycle " << cycle << std::endl;'
p45490
aS'        switch (test_case)'
p45491
aS'          {'
p45492
aS'            case TestCase::convergence_rate:'
p45493
aS'              {'
p45494
aS'                if (cycle == 0)'
p45495
aS'                  {'
p45496
aS'                    GridGenerator::hyper_cube(triangulation);'
p45497
aS'                    triangulation.refine_global(2);'
p45498
aS'                  }'
p45499
aS'                else'
p45500
aS'                  {'
p45501
aS'                    triangulation.refine_global(1);'
p45502
aS'                  }'
p45503
aS'                break;'
p45504
aS'              }'
p45505
aS'            case TestCase::l_singularity:'
p45506
aS'              {'
p45507
aS'                if (cycle == 0)'
p45508
aS'                  {'
p45509
aS'                    GridGenerator::hyper_L(triangulation);'
p45510
aS'                    triangulation.refine_global(3);'
p45511
aS'                  }'
p45512
aS'                else'
p45513
aS'                  {'
p45514
aS'                    refine_grid();'
p45515
aS'                  }'
p45516
aS'                break;'
p45517
aS'              }'
p45518
aS'            default:'
p45519
aS'              {'
p45520
aS'                Assert(false, ExcNotImplemented());'
p45521
aS'              }'
p45522
aS'          }'
p45523
aS'        std::cout << "  Number of active cells       : "'
p45524
aS'                  << triangulation.n_active_cells() << std::endl;'
p45525
aS'        setup_system();'
p45526
aS'        std::cout << "  Number of degrees of freedom : " << dof_handler.n_dofs()'
p45527
aS'                  << std::endl;'
p45528
aS'        assemble_system();'
p45529
aS'        solve();'
p45530
aS'        output_results(cycle);'
p45531
aS'        {'
p45532
aS'          convergence_table.add_value("cycle", cycle);'
p45533
aS'          convergence_table.add_value("cells", triangulation.n_active_cells());'
p45534
aS'          convergence_table.add_value("dofs", dof_handler.n_dofs());'
p45535
aS'        }'
p45536
aS'        compute_errors();'
p45537
aS'        if (test_case == TestCase::l_singularity)'
p45538
aS'          {'
p45539
aS'            compute_error_estimate();'
p45540
aS'            std::cout << "  Estimated error              : "'
p45541
aS'                      << std::sqrt(estimated_error_square_per_cell.l1_norm())'
p45542
aS'                      << std::endl;'
p45543
aS'            convergence_table.add_value('
p45544
aS'              "Estimator",'
p45545
aS'              std::sqrt(estimated_error_square_per_cell.l1_norm()));'
p45546
aS'          }'
p45547
aS'        std::cout << std::endl;'
p45548
aS'      }'
p45549
aS'    convergence_table.set_precision("L2", 3);'
p45550
aS'    convergence_table.set_precision("H1", 3);'
p45551
aS'    convergence_table.set_precision("Energy", 3);'
p45552
aS'    convergence_table.set_scientific("L2", true);'
p45553
aS'    convergence_table.set_scientific("H1", true);'
p45554
aS'    convergence_table.set_scientific("Energy", true);'
p45555
aS'    if (test_case == TestCase::convergence_rate)'
p45556
aS'      {'
p45557
aS'        convergence_table.evaluate_convergence_rates('
p45558
aS'          "L2", ConvergenceTable::reduction_rate_log2);'
p45559
aS'        convergence_table.evaluate_convergence_rates('
p45560
aS'          "H1", ConvergenceTable::reduction_rate_log2);'
p45561
aS'      }'
p45562
aS'    if (test_case == TestCase::l_singularity)'
p45563
aS'      {'
p45564
aS'        convergence_table.set_precision("Estimator", 3);'
p45565
aS'        convergence_table.set_scientific("Estimator", true);'
p45566
aS'      }'
p45567
aS'    std::cout << "degree = " << degree << std::endl;'
p45568
aS'    convergence_table.write_text('
p45569
aS'      std::cout, TableHandler::TextOutputFormat::org_mode_table);'
p45570
aS'  }'
p45571
aS'} // namespace Step74'
p45572
aS'int main()'
p45573
ag24
aS'  try'
p45574
aS'    {'
p45575
aS'      using namespace dealii;'
p45576
aS'      using namespace Step74;'
p45577
aS'      const TestCase test_case = TestCase::l_singularity;'
p45578
aS'      SIPGLaplace<2> problem(test_case);'
p45579
aS'      problem.run();'
p45580
aS'    }'
p45581
aS'  catch (std::exception &exc)'
p45582
aS'    {'
p45583
aS'      std::cerr << std::endl'
p45584
aS'                << std::endl'
p45585
aS'                << "----------------------------------------------------"'
p45586
aS'                << std::endl;'
p45587
aS'      std::cerr << "Exception on processing: " << std::endl'
p45588
aS'                << exc.what() << std::endl'
p45589
aS'                << "Aborting!" << std::endl'
p45590
aS'                << "----------------------------------------------------"'
p45591
aS'                << std::endl;'
p45592
aS'      return 1;'
p45593
aS'    }'
p45594
aS'  catch (...)'
p45595
aS'    {'
p45596
aS'      std::cerr << std::endl'
p45597
aS'                << std::endl'
p45598
aS'                << "----------------------------------------------------"'
p45599
aS'                << std::endl;'
p45600
aS'      std::cerr << "Unknown exception!" << std::endl'
p45601
aS'                << "Aborting!" << std::endl'
p45602
aS'                << "----------------------------------------------------"'
p45603
aS'                << std::endl;'
p45604
aS'      return 1;'
p45605
aS'    };'
p45606
aS'  return 0;'
p45607
ag32
aS'/* ---------------------------------------------------------------------'
p45608
aS' *'
p45609
aS' * Copyright (C) 2021 by the deal.II authors'
p45610
aS' *'
p45611
aS' * This file is part of the deal.II library.'
p45612
aS' *'
p45613
aS' * The deal.II library is free software; you can use it, redistribute'
p45614
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p45615
aS' * Public License as published by the Free Software Foundation; either'
p45616
aS' * version 2.1 of the License, or (at your option) any later version.'
p45617
aS' * The full text of the license can be found in the file LICENSE.md at'
p45618
aS' * the top level directory of deal.II.'
p45619
aS' *'
p45620
aS' * ---------------------------------------------------------------------'
p45621
aS' *'
p45622
aS' * Author: Marc Fehling, Colorado State University, 2021'
p45623
aS' *         Peter Munch, Technical University of Munich and Helmholtz-Zentrum'
p45624
aS' *                      hereon, 2021'
p45625
aS' *         Wolfgang Bangerth, Colorado State University, 2021'
p45626
aS' */'
p45627
aS'#include <deal.II/base/conditional_ostream.h>'
p45628
aS'#include <deal.II/base/index_set.h>'
p45629
aS'#include <deal.II/base/mpi.h>'
p45630
aS'#include <deal.II/base/quadrature_lib.h>'
p45631
aS'#include <deal.II/base/timer.h>'
p45632
aS'#include <deal.II/distributed/grid_refinement.h>'
p45633
aS'#include <deal.II/distributed/tria.h>'
p45634
aS'#include <deal.II/dofs/dof_handler.h>'
p45635
aS'#include <deal.II/dofs/dof_tools.h>'
p45636
aS'#include <deal.II/grid/grid_generator.h>'
p45637
aS'#include <deal.II/fe/fe_q.h>'
p45638
aS'#include <deal.II/fe/fe_series.h>'
p45639
aS'#include <deal.II/hp/fe_collection.h>'
p45640
aS'#include <deal.II/hp/refinement.h>'
p45641
aS'#include <deal.II/lac/affine_constraints.h>'
p45642
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p45643
aS'#include <deal.II/lac/precondition.h>'
p45644
aS'#include <deal.II/lac/solver_cg.h>'
p45645
aS'#include <deal.II/lac/trilinos_precondition.h>'
p45646
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p45647
aS'#include <deal.II/lac/vector.h>'
p45648
aS'#include <deal.II/numerics/data_out.h>'
p45649
aS'#include <deal.II/numerics/error_estimator.h>'
p45650
aS'#include <deal.II/numerics/smoothness_estimator.h>'
p45651
aS'#include <deal.II/numerics/vector_tools.h>'
p45652
aS'#include <algorithm>'
p45653
aS'#include <fstream>'
p45654
aS'#include <iostream>'
p45655
aS'#include <deal.II/distributed/cell_weights.h>'
p45656
aS'#include <deal.II/base/function.h>'
p45657
aS'#include <deal.II/base/geometric_utilities.h>'
p45658
aS'#include <deal.II/matrix_free/matrix_free.h>'
p45659
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p45660
aS'#include <deal.II/matrix_free/tools.h>'
p45661
aS'#include <deal.II/lac/la_parallel_vector.h>'
p45662
aS'#include <deal.II/multigrid/mg_coarse.h>'
p45663
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p45664
aS'#include <deal.II/multigrid/mg_matrix.h>'
p45665
aS'#include <deal.II/multigrid/mg_smoother.h>'
p45666
aS'#include <deal.II/multigrid/mg_tools.h>'
p45667
aS'#include <deal.II/multigrid/mg_transfer_global_coarsening.h>'
p45668
aS'#include <deal.II/multigrid/multigrid.h>'
p45669
aS'namespace Step75'
p45670
ag24
aS'  using namespace dealii;'
p45671
aS'  template <int dim>'
p45672
aS'  class Solution : public Function<dim>'
p45673
aS'  {'
p45674
aS'  public:'
p45675
aS'    Solution()'
p45676
aS'      : Function<dim>()'
p45677
aS'    {}'
p45678
aS'    virtual double value(const Point<dim> &p,'
p45679
aS'                         const unsigned int /*component*/) const override'
p45680
aS'    {'
p45681
aS'      const std::array<double, dim> p_sphere ='
p45682
aS'        GeometricUtilities::Coordinates::to_spherical(p);'
p45683
aS'      constexpr const double alpha = 2. / 3.;'
p45684
aS'      return std::pow(p_sphere[0], alpha) * std::sin(alpha * p_sphere[1]);'
p45685
aS'    }'
p45686
aS'  };'
p45687
aS'  struct MultigridParameters'
p45688
aS'  {'
p45689
aS'    struct'
p45690
aS'    {'
p45691
aS'      std::string  type            = "cg_with_amg";'
p45692
aS'      unsigned int maxiter         = 10000;'
p45693
aS'      double       abstol          = 1e-20;'
p45694
aS'      double       reltol          = 1e-4;'
p45695
aS'      unsigned int smoother_sweeps = 1;'
p45696
aS'      unsigned int n_cycles        = 1;'
p45697
aS'      std::string  smoother_type   = "ILU";'
p45698
aS'    } coarse_solver;'
p45699
aS'    struct'
p45700
aS'    {'
p45701
aS'      std::string  type                = "chebyshev";'
p45702
aS'      double       smoothing_range     = 20;'
p45703
aS'      unsigned int degree              = 5;'
p45704
aS'      unsigned int eig_cg_n_iterations = 20;'
p45705
aS'    } smoother;'
p45706
aS'    struct'
p45707
aS'    {'
p45708
aS'      MGTransferGlobalCoarseningTools::PolynomialCoarseningSequenceType'
p45709
aS'        p_sequence = MGTransferGlobalCoarseningTools::'
p45710
aS'          PolynomialCoarseningSequenceType::decrease_by_one;'
p45711
aS'      bool perform_h_transfer = true;'
p45712
aS'    } transfer;'
p45713
aS'  };'
p45714
aS'  struct Parameters'
p45715
aS'  {'
p45716
aS'    unsigned int n_cycles         = 8;'
p45717
aS'    double       tolerance_factor = 1e-12;'
p45718
aS'    MultigridParameters mg_data;'
p45719
aS'    unsigned int min_h_level            = 5;'
p45720
aS'    unsigned int max_h_level            = 12;'
p45721
aS'    unsigned int min_p_degree           = 2;'
p45722
aS'    unsigned int max_p_degree           = 6;'
p45723
aS'    unsigned int max_p_level_difference = 1;'
p45724
aS'    double refine_fraction    = 0.3;'
p45725
aS'    double coarsen_fraction   = 0.03;'
p45726
aS'    double p_refine_fraction  = 0.9;'
p45727
aS'    double p_coarsen_fraction = 0.9;'
p45728
aS'    double weighting_factor   = 1e6;'
p45729
aS'    double weighting_exponent = 1.;'
p45730
aS'  };'
p45731
aS'  template <int dim, typename number>'
p45732
aS'  class LaplaceOperator : public Subscriptor'
p45733
aS'  {'
p45734
aS'  public:'
p45735
aS'    using VectorType = LinearAlgebra::distributed::Vector<number>;'
p45736
aS'    using FECellIntegrator = FEEvaluation<dim, -1, 0, 1, number>;'
p45737
aS'    LaplaceOperator() = default;'
p45738
aS'    LaplaceOperator(const hp::MappingCollection<dim> &mapping,'
p45739
aS'                    const DoFHandler<dim> &           dof_handler,'
p45740
aS'                    const hp::QCollection<dim> &      quad,'
p45741
aS'                    const AffineConstraints<number> & constraints,'
p45742
aS'                    VectorType &                      system_rhs);'
p45743
aS'    void reinit(const hp::MappingCollection<dim> &mapping,'
p45744
aS'                const DoFHandler<dim> &           dof_handler,'
p45745
aS'                const hp::QCollection<dim> &      quad,'
p45746
aS'                const AffineConstraints<number> & constraints,'
p45747
aS'                VectorType &                      system_rhs);'
p45748
aS'    types::global_dof_index m() const;'
p45749
aS'    number el(unsigned int, unsigned int) const;'
p45750
aS'    void initialize_dof_vector(VectorType &vec) const;'
p45751
aS'    void vmult(VectorType &dst, const VectorType &src) const;'
p45752
aS'    void Tvmult(VectorType &dst, const VectorType &src) const;'
p45753
aS'    const TrilinosWrappers::SparseMatrix &get_system_matrix() const;'
p45754
aS'    void compute_inverse_diagonal(VectorType &diagonal) const;'
p45755
aS'  private:'
p45756
aS'    void do_cell_integral_local(FECellIntegrator &integrator) const;'
p45757
aS'    void do_cell_integral_global(FECellIntegrator &integrator,'
p45758
aS'                                 VectorType &      dst,'
p45759
aS'                                 const VectorType &src) const;'
p45760
aS'    void do_cell_integral_range('
p45761
aS'      const MatrixFree<dim, number> &              matrix_free,'
p45762
aS'      VectorType &                                 dst,'
p45763
aS'      const VectorType &                           src,'
p45764
aS'      const std::pair<unsigned int, unsigned int> &range) const;'
p45765
aS'    MatrixFree<dim, number> matrix_free;'
p45766
aS'    AffineConstraints<number>              constraints;'
p45767
aS'    mutable TrilinosWrappers::SparseMatrix system_matrix;'
p45768
aS'  };'
p45769
aS'  template <int dim, typename number>'
p45770
aS'  LaplaceOperator<dim, number>::LaplaceOperator('
p45771
aS'    const hp::MappingCollection<dim> &mapping,'
p45772
aS'    const DoFHandler<dim> &           dof_handler,'
p45773
aS'    const hp::QCollection<dim> &      quad,'
p45774
aS'    const AffineConstraints<number> & constraints,'
p45775
aS'    VectorType &                      system_rhs)'
p45776
aS'  {'
p45777
aS'    this->reinit(mapping, dof_handler, quad, constraints, system_rhs);'
p45778
aS'  }'
p45779
aS'  template <int dim, typename number>'
p45780
aS'  void LaplaceOperator<dim, number>::reinit('
p45781
aS'    const hp::MappingCollection<dim> &mapping,'
p45782
aS'    const DoFHandler<dim> &           dof_handler,'
p45783
aS'    const hp::QCollection<dim> &      quad,'
p45784
aS'    const AffineConstraints<number> & constraints,'
p45785
aS'    VectorType &                      system_rhs)'
p45786
aS'  {'
p45787
aS'    this->system_matrix.clear();'
p45788
aS'    this->constraints.copy_from(constraints);'
p45789
aS'    typename MatrixFree<dim, number>::AdditionalData data;'
p45790
aS'    data.mapping_update_flags = update_gradients;'
p45791
aS'    matrix_free.reinit(mapping, dof_handler, constraints, quad, data);'
p45792
aS'    {'
p45793
aS'      AffineConstraints<number> constraints_without_dbc;'
p45794
aS'      IndexSet locally_relevant_dofs;'
p45795
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler,'
p45796
aS'                                              locally_relevant_dofs);'
p45797
aS'      constraints_without_dbc.reinit(locally_relevant_dofs);'
p45798
aS'      DoFTools::make_hanging_node_constraints(dof_handler,'
p45799
aS'                                              constraints_without_dbc);'
p45800
aS'      constraints_without_dbc.close();'
p45801
aS'      VectorType b, x;'
p45802
aS'      this->initialize_dof_vector(system_rhs);'
p45803
aS'      MatrixFree<dim, number> matrix_free;'
p45804
aS'      matrix_free.reinit('
p45805
aS'        mapping, dof_handler, constraints_without_dbc, quad, data);'
p45806
aS'      matrix_free.initialize_dof_vector(b);'
p45807
aS'      matrix_free.initialize_dof_vector(x);'
p45808
aS'      constraints.distribute(x);'
p45809
aS'      matrix_free.cell_loop(&LaplaceOperator::do_cell_integral_range,'
p45810
aS'                            this,'
p45811
aS'                            b,'
p45812
aS'                            x);'
p45813
aS'      constraints.set_zero(b);'
p45814
aS'      system_rhs -= b;'
p45815
aS'    }'
p45816
aS'  }'
p45817
aS'  template <int dim, typename number>'
p45818
aS'  types::global_dof_index LaplaceOperator<dim, number>::m() const'
p45819
aS'  {'
p45820
aS'    return matrix_free.get_dof_handler().n_dofs();'
p45821
aS'  }'
p45822
aS'  template <int dim, typename number>'
p45823
aS'  number LaplaceOperator<dim, number>::el(unsigned int, unsigned int) const'
p45824
aS'  {'
p45825
aS'    Assert(false, ExcNotImplemented());'
p45826
aS'    return 0;'
p45827
aS'  }'
p45828
aS'  template <int dim, typename number>'
p45829
aS'  void'
p45830
aS'  LaplaceOperator<dim, number>::initialize_dof_vector(VectorType &vec) const'
p45831
aS'  {'
p45832
aS'    matrix_free.initialize_dof_vector(vec);'
p45833
aS'  }'
p45834
aS'  template <int dim, typename number>'
p45835
aS'  void LaplaceOperator<dim, number>::vmult(VectorType &      dst,'
p45836
aS'                                           const VectorType &src) const'
p45837
aS'  {'
p45838
aS'    this->matrix_free.cell_loop('
p45839
aS'      &LaplaceOperator::do_cell_integral_range, this, dst, src, true);'
p45840
aS'  }'
p45841
aS'  template <int dim, typename number>'
p45842
aS'  void LaplaceOperator<dim, number>::Tvmult(VectorType &      dst,'
p45843
aS'                                            const VectorType &src) const'
p45844
aS'  {'
p45845
aS'    this->vmult(dst, src);'
p45846
aS'  }'
p45847
aS'  template <int dim, typename number>'
p45848
aS'  void LaplaceOperator<dim, number>::compute_inverse_diagonal('
p45849
aS'    VectorType &diagonal) const'
p45850
aS'  {'
p45851
aS'    MatrixFreeTools::compute_diagonal(matrix_free,'
p45852
aS'                                      diagonal,'
p45853
aS'                                      &LaplaceOperator::do_cell_integral_local,'
p45854
aS'                                      this);'
p45855
aS'    for (auto &i : diagonal)'
p45856
aS'      i = (std::abs(i) > 1.0e-10) ? (1.0 / i) : 1.0;'
p45857
aS'  }'
p45858
aS'  template <int dim, typename number>'
p45859
aS'  const TrilinosWrappers::SparseMatrix &'
p45860
aS'  LaplaceOperator<dim, number>::get_system_matrix() const'
p45861
aS'  {'
p45862
aS'    if (system_matrix.m() == 0 && system_matrix.n() == 0)'
p45863
aS'      {'
p45864
aS'        const auto &dof_handler = this->matrix_free.get_dof_handler();'
p45865
aS'        TrilinosWrappers::SparsityPattern dsp('
p45866
aS'          dof_handler.locally_owned_dofs(),'
p45867
aS'          dof_handler.get_triangulation().get_communicator());'
p45868
aS'        DoFTools::make_sparsity_pattern(dof_handler, dsp, this->constraints);'
p45869
aS'        dsp.compress();'
p45870
aS'        system_matrix.reinit(dsp);'
p45871
aS'        MatrixFreeTools::compute_matrix('
p45872
aS'          matrix_free,'
p45873
aS'          constraints,'
p45874
aS'          system_matrix,'
p45875
aS'          &LaplaceOperator::do_cell_integral_local,'
p45876
aS'          this);'
p45877
aS'      }'
p45878
aS'    return this->system_matrix;'
p45879
aS'  }'
p45880
aS'  template <int dim, typename number>'
p45881
aS'  void LaplaceOperator<dim, number>::do_cell_integral_local('
p45882
aS'    FECellIntegrator &integrator) const'
p45883
aS'  {'
p45884
aS'    integrator.evaluate(EvaluationFlags::gradients);'
p45885
aS'    for (unsigned int q = 0; q < integrator.n_q_points; ++q)'
p45886
aS'      integrator.submit_gradient(integrator.get_gradient(q), q);'
p45887
aS'    integrator.integrate(EvaluationFlags::gradients);'
p45888
aS'  }'
p45889
aS'  template <int dim, typename number>'
p45890
aS'  void LaplaceOperator<dim, number>::do_cell_integral_global('
p45891
aS'    FECellIntegrator &integrator,'
p45892
aS'    VectorType &      dst,'
p45893
aS'    const VectorType &src) const'
p45894
aS'  {'
p45895
aS'    integrator.gather_evaluate(src, EvaluationFlags::gradients);'
p45896
aS'    for (unsigned int q = 0; q < integrator.n_q_points; ++q)'
p45897
aS'      integrator.submit_gradient(integrator.get_gradient(q), q);'
p45898
aS'    integrator.integrate_scatter(EvaluationFlags::gradients, dst);'
p45899
aS'  }'
p45900
aS'  template <int dim, typename number>'
p45901
aS'  void LaplaceOperator<dim, number>::do_cell_integral_range('
p45902
aS'    const MatrixFree<dim, number> &              matrix_free,'
p45903
aS'    VectorType &                                 dst,'
p45904
aS'    const VectorType &                           src,'
p45905
aS'    const std::pair<unsigned int, unsigned int> &range) const'
p45906
aS'  {'
p45907
aS'    FECellIntegrator integrator(matrix_free, range);'
p45908
aS'    for (unsigned cell = range.first; cell < range.second; ++cell)'
p45909
aS'      {'
p45910
aS'        integrator.reinit(cell);'
p45911
aS'        do_cell_integral_global(integrator, dst, src);'
p45912
aS'      }'
p45913
aS'  }'
p45914
aS'  template <typename VectorType,'
p45915
aS'            int dim,'
p45916
aS'            typename SystemMatrixType,'
p45917
aS'            typename LevelMatrixType,'
p45918
aS'            typename MGTransferType>'
p45919
aS'  static void'
p45920
aS'  mg_solve(SolverControl &            solver_control,'
p45921
aS'           VectorType &               dst,'
p45922
aS'           const VectorType &         src,'
p45923
aS'           const MultigridParameters &mg_data,'
p45924
aS'           const DoFHandler<dim> &    dof,'
p45925
aS'           const SystemMatrixType &   fine_matrix,'
p45926
aS'           const MGLevelObject<std::unique_ptr<LevelMatrixType>> &mg_matrices,'
p45927
aS'           const MGTransferType &                                 mg_transfer)'
p45928
aS'  {'
p45929
aS'    AssertThrow(mg_data.coarse_solver.type == "cg_with_amg",'
p45930
aS'                ExcNotImplemented());'
p45931
aS'    AssertThrow(mg_data.smoother.type == "chebyshev", ExcNotImplemented());'
p45932
aS'    const unsigned int min_level = mg_matrices.min_level();'
p45933
aS'    const unsigned int max_level = mg_matrices.max_level();'
p45934
aS'    using SmootherPreconditionerType = DiagonalMatrix<VectorType>;'
p45935
aS'    using SmootherType               = PreconditionChebyshev<LevelMatrixType,'
p45936
aS'                                               VectorType,'
p45937
aS'                                               SmootherPreconditionerType>;'
p45938
aS'    using PreconditionerType = PreconditionMG<dim, VectorType, MGTransferType>;'
p45939
aS'    mg::Matrix<VectorType> mg_matrix(mg_matrices);'
p45940
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data('
p45941
aS'      min_level, max_level);'
p45942
aS'    for (unsigned int level = min_level; level <= max_level; level++)'
p45943
aS'      {'
p45944
aS'        smoother_data[level].preconditioner ='
p45945
aS'          std::make_shared<SmootherPreconditionerType>();'
p45946
aS'        mg_matrices[level]->compute_inverse_diagonal('
p45947
aS'          smoother_data[level].preconditioner->get_vector());'
p45948
aS'        smoother_data[level].smoothing_range = mg_data.smoother.smoothing_range;'
p45949
aS'        smoother_data[level].degree          = mg_data.smoother.degree;'
p45950
aS'        smoother_data[level].eig_cg_n_iterations ='
p45951
aS'          mg_data.smoother.eig_cg_n_iterations;'
p45952
aS'      }'
p45953
aS'    MGSmootherPrecondition<LevelMatrixType, SmootherType, VectorType>'
p45954
aS'      mg_smoother;'
p45955
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p45956
aS'    ReductionControl coarse_grid_solver_control(mg_data.coarse_solver.maxiter,'
p45957
aS'                                                mg_data.coarse_solver.abstol,'
p45958
aS'                                                mg_data.coarse_solver.reltol,'
p45959
aS'                                                false,'
p45960
aS'                                                false);'
p45961
aS'    SolverCG<VectorType> coarse_grid_solver(coarse_grid_solver_control);'
p45962
aS'    std::unique_ptr<MGCoarseGridBase<VectorType>> mg_coarse;'
p45963
aS'    TrilinosWrappers::PreconditionAMG                 precondition_amg;'
p45964
aS'    TrilinosWrappers::PreconditionAMG::AdditionalData amg_data;'
p45965
aS'    amg_data.smoother_sweeps = mg_data.coarse_solver.smoother_sweeps;'
p45966
aS'    amg_data.n_cycles        = mg_data.coarse_solver.n_cycles;'
p45967
aS'    amg_data.smoother_type   = mg_data.coarse_solver.smoother_type.c_str();'
p45968
aS'    precondition_amg.initialize(mg_matrices[min_level]->get_system_matrix(),'
p45969
aS'                                amg_data);'
p45970
aS'    mg_coarse ='
p45971
aS'      std::make_unique<MGCoarseGridIterativeSolver<VectorType,'
p45972
aS'                                                   SolverCG<VectorType>,'
p45973
aS'                                                   LevelMatrixType,'
p45974
aS'                                                   decltype(precondition_amg)>>('
p45975
aS'        coarse_grid_solver, *mg_matrices[min_level], precondition_amg);'
p45976
aS'    Multigrid<VectorType> mg('
p45977
aS'      mg_matrix, *mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p45978
aS'    PreconditionerType preconditioner(dof, mg, mg_transfer);'
p45979
aS'    SolverCG<VectorType>(solver_control)'
p45980
aS'      .solve(fine_matrix, dst, src, preconditioner);'
p45981
aS'  }'
p45982
aS'  template <typename VectorType, typename OperatorType, int dim>'
p45983
aS'  void solve_with_gmg(SolverControl &                  solver_control,'
p45984
aS'                      const OperatorType &             system_matrix,'
p45985
aS'                      VectorType &                     dst,'
p45986
aS'                      const VectorType &               src,'
p45987
aS'                      const MultigridParameters &      mg_data,'
p45988
aS'                      const hp::MappingCollection<dim> mapping_collection,'
p45989
aS'                      const DoFHandler<dim> &          dof_handler,'
p45990
aS'                      const hp::QCollection<dim> &     quadrature_collection)'
p45991
aS'  {'
p45992
aS'    MGLevelObject<DoFHandler<dim>>                     dof_handlers;'
p45993
aS'    MGLevelObject<std::unique_ptr<OperatorType>>       operators;'
p45994
aS'    MGLevelObject<MGTwoLevelTransfer<dim, VectorType>> transfers;'
p45995
aS'    std::vector<std::shared_ptr<const Triangulation<dim>>>'
p45996
aS'      coarse_grid_triangulations;'
p45997
aS'    if (mg_data.transfer.perform_h_transfer)'
p45998
aS'      coarse_grid_triangulations ='
p45999
aS'        MGTransferGlobalCoarseningTools::create_geometric_coarsening_sequence('
p46000
aS'          dof_handler.get_triangulation());'
p46001
aS'    else'
p46002
aS'      coarse_grid_triangulations.emplace_back('
p46003
aS'        const_cast<Triangulation<dim> *>(&(dof_handler.get_triangulation())),'
p46004
aS'        [](auto &) {});'
p46005
aS'    const unsigned int n_h_levels = coarse_grid_triangulations.size() - 1;'
p46006
aS'    const auto get_max_active_fe_degree = [&](const auto &dof_handler) {'
p46007
aS'      unsigned int max = 0;'
p46008
aS'      for (auto &cell : dof_handler.active_cell_iterators())'
p46009
aS'        if (cell->is_locally_owned())'
p46010
aS'          max ='
p46011
aS'            std::max(max, dof_handler.get_fe(cell->active_fe_index()).degree);'
p46012
aS'      return Utilities::MPI::max(max, MPI_COMM_WORLD);'
p46013
aS'    };'
p46014
aS'    const unsigned int n_p_levels ='
p46015
aS'      MGTransferGlobalCoarseningTools::create_polynomial_coarsening_sequence('
p46016
aS'        get_max_active_fe_degree(dof_handler), mg_data.transfer.p_sequence)'
p46017
aS'        .size();'
p46018
aS'    std::map<unsigned int, unsigned int> fe_index_for_degree;'
p46019
aS'    for (unsigned int i = 0; i < dof_handler.get_fe_collection().size(); ++i)'
p46020
aS'      {'
p46021
aS'        const unsigned int degree = dof_handler.get_fe(i).degree;'
p46022
aS'        Assert(fe_index_for_degree.find(degree) == fe_index_for_degree.end(),'
p46023
aS'               ExcMessage("FECollection does not contain unique degrees."));'
p46024
aS'        fe_index_for_degree[degree] = i;'
p46025
aS'      }'
p46026
aS'    unsigned int minlevel   = 0;'
p46027
aS'    unsigned int minlevel_p = n_h_levels;'
p46028
aS'    unsigned int maxlevel   = n_h_levels + n_p_levels - 1;'
p46029
aS'    dof_handlers.resize(minlevel, maxlevel);'
p46030
aS'    operators.resize(minlevel, maxlevel);'
p46031
aS'    transfers.resize(minlevel, maxlevel);'
p46032
aS'    for (unsigned int l = 0; l < n_h_levels; ++l)'
p46033
aS'      {'
p46034
aS'        dof_handlers[l].reinit(*coarse_grid_triangulations[l]);'
p46035
aS'        dof_handlers[l].distribute_dofs(dof_handler.get_fe_collection());'
p46036
aS'      }'
p46037
aS'    for (unsigned int i = 0, l = maxlevel; i < n_p_levels; ++i, --l)'
p46038
aS'      {'
p46039
aS'        dof_handlers[l].reinit(dof_handler.get_triangulation());'
p46040
aS'        if (l == maxlevel) // finest level'
p46041
aS'          {'
p46042
aS'            auto &dof_handler_mg = dof_handlers[l];'
p46043
aS'            auto cell_other = dof_handler.begin_active();'
p46044
aS'            for (auto &cell : dof_handler_mg.active_cell_iterators())'
p46045
aS'              {'
p46046
aS'                if (cell->is_locally_owned())'
p46047
aS'                  cell->set_active_fe_index(cell_other->active_fe_index());'
p46048
aS'                cell_other++;'
p46049
aS'              }'
p46050
aS'          }'
p46051
aS'        else // coarse level'
p46052
aS'          {'
p46053
aS'            auto &dof_handler_fine   = dof_handlers[l + 1];'
p46054
aS'            auto &dof_handler_coarse = dof_handlers[l + 0];'
p46055
aS'            auto cell_other = dof_handler_fine.begin_active();'
p46056
aS'            for (auto &cell : dof_handler_coarse.active_cell_iterators())'
p46057
aS'              {'
p46058
aS'                if (cell->is_locally_owned())'
p46059
aS'                  {'
p46060
aS'                    const unsigned int next_degree ='
p46061
aS'                      MGTransferGlobalCoarseningTools::'
p46062
aS'                        create_next_polynomial_coarsening_degree('
p46063
aS'                          cell_other->get_fe().degree,'
p46064
aS'                          mg_data.transfer.p_sequence);'
p46065
aS'                    Assert(fe_index_for_degree.find(next_degree) !='
p46066
aS'                             fe_index_for_degree.end(),'
p46067
aS'                           ExcMessage("Next polynomial degree in sequence "'
p46068
aS'                                      "does not exist in FECollection."));'
p46069
aS'                    cell->set_active_fe_index(fe_index_for_degree[next_degree]);'
p46070
aS'                  }'
p46071
aS'                cell_other++;'
p46072
aS'              }'
p46073
aS'          }'
p46074
aS'        dof_handlers[l].distribute_dofs(dof_handler.get_fe_collection());'
p46075
aS'      }'
p46076
aS'    MGLevelObject<AffineConstraints<typename VectorType::value_type>>'
p46077
aS'      constraints(minlevel, maxlevel);'
p46078
aS'    for (unsigned int level = minlevel; level <= maxlevel; ++level)'
p46079
aS'      {'
p46080
aS'        const auto &dof_handler = dof_handlers[level];'
p46081
aS'        auto &      constraint  = constraints[level];'
p46082
aS'        IndexSet locally_relevant_dofs;'
p46083
aS'        DoFTools::extract_locally_relevant_dofs(dof_handler,'
p46084
aS'                                                locally_relevant_dofs);'
p46085
aS'        constraint.reinit(locally_relevant_dofs);'
p46086
aS'        DoFTools::make_hanging_node_constraints(dof_handler, constraint);'
p46087
aS'        VectorTools::interpolate_boundary_values(mapping_collection,'
p46088
aS'                                                 dof_handler,'
p46089
aS'                                                 0,'
p46090
aS'                                                 Functions::ZeroFunction<dim>(),'
p46091
aS'                                                 constraint);'
p46092
aS'        constraint.close();'
p46093
aS'        VectorType dummy;'
p46094
aS'        operators[level] = std::make_unique<OperatorType>(mapping_collection,'
p46095
aS'                                                          dof_handler,'
p46096
aS'                                                          quadrature_collection,'
p46097
aS'                                                          constraint,'
p46098
aS'                                                          dummy);'
p46099
aS'      }'
p46100
aS'    for (unsigned int level = minlevel; level < minlevel_p; ++level)'
p46101
aS'      transfers[level + 1].reinit_geometric_transfer(dof_handlers[level + 1],'
p46102
aS'                                                     dof_handlers[level],'
p46103
aS'                                                     constraints[level + 1],'
p46104
aS'                                                     constraints[level]);'
p46105
aS'    for (unsigned int level = minlevel_p; level < maxlevel; ++level)'
p46106
aS'      transfers[level + 1].reinit_polynomial_transfer(dof_handlers[level + 1],'
p46107
aS'                                                      dof_handlers[level],'
p46108
aS'                                                      constraints[level + 1],'
p46109
aS'                                                      constraints[level]);'
p46110
aS'    MGTransferGlobalCoarsening<dim, VectorType> transfer('
p46111
aS'      transfers, [&](const auto l, auto &vec) {'
p46112
aS'        operators[l]->initialize_dof_vector(vec);'
p46113
aS'      });'
p46114
aS'    mg_solve(solver_control,'
p46115
aS'             dst,'
p46116
aS'             src,'
p46117
aS'             mg_data,'
p46118
aS'             dof_handler,'
p46119
aS'             system_matrix,'
p46120
aS'             operators,'
p46121
aS'             transfer);'
p46122
aS'  }'
p46123
aS'  template <int dim>'
p46124
aS'  class LaplaceProblem'
p46125
aS'  {'
p46126
aS'  public:'
p46127
aS'    LaplaceProblem(const Parameters &parameters);'
p46128
aS'    void run();'
p46129
aS'  private:'
p46130
aS'    void initialize_grid();'
p46131
aS'    void setup_system();'
p46132
aS'    void print_diagnostics();'
p46133
aS'    void solve_system();'
p46134
aS'    void compute_indicators();'
p46135
aS'    void adapt_resolution();'
p46136
aS'    void output_results(const unsigned int cycle);'
p46137
aS'    MPI_Comm mpi_communicator;'
p46138
aS'    const Parameters prm;'
p46139
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p46140
aS'    DoFHandler<dim>                           dof_handler;'
p46141
aS'    hp::MappingCollection<dim> mapping_collection;'
p46142
aS'    hp::FECollection<dim>      fe_collection;'
p46143
aS'    hp::QCollection<dim>       quadrature_collection;'
p46144
aS'    hp::QCollection<dim - 1>   face_quadrature_collection;'
p46145
aS'    IndexSet locally_owned_dofs;'
p46146
aS'    IndexSet locally_relevant_dofs;'
p46147
aS'    AffineConstraints<double> constraints;'
p46148
aS'    LaplaceOperator<dim, double>               laplace_operator;'
p46149
aS'    LinearAlgebra::distributed::Vector<double> locally_relevant_solution;'
p46150
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p46151
aS'    std::unique_ptr<FESeries::Legendre<dim>>    legendre;'
p46152
aS'    std::unique_ptr<parallel::CellWeights<dim>> cell_weights;'
p46153
aS'    Vector<float> estimated_error_per_cell;'
p46154
aS'    Vector<float> hp_decision_indicators;'
p46155
aS'    ConditionalOStream pcout;'
p46156
aS'    TimerOutput        computing_timer;'
p46157
aS'  };'
p46158
aS'  template <int dim>'
p46159
aS'  LaplaceProblem<dim>::LaplaceProblem(const Parameters &parameters)'
p46160
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p46161
aS'    , prm(parameters)'
p46162
aS'    , triangulation(mpi_communicator)'
p46163
aS'    , dof_handler(triangulation)'
p46164
aS'    , pcout(std::cout,'
p46165
aS'            (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p46166
aS'    , computing_timer(mpi_communicator,'
p46167
aS'                      pcout,'
p46168
aS'                      TimerOutput::summary,'
p46169
aS'                      TimerOutput::wall_times)'
p46170
aS'  {'
p46171
aS'    Assert(prm.min_h_level <= prm.max_h_level,'
p46172
aS'           ExcMessage('
p46173
aS'             "Triangulation level limits have been incorrectly set up."));'
p46174
aS'    Assert(prm.min_p_degree <= prm.max_p_degree,'
p46175
aS'           ExcMessage("FECollection degrees have been incorrectly set up."));'
p46176
aS'    mapping_collection.push_back(MappingQ1<dim>());'
p46177
aS'    for (unsigned int degree = 1; degree <= prm.max_p_degree; ++degree)'
p46178
aS'      {'
p46179
aS'        fe_collection.push_back(FE_Q<dim>(degree));'
p46180
aS'        quadrature_collection.push_back(QGauss<dim>(degree + 1));'
p46181
aS'        face_quadrature_collection.push_back(QGauss<dim - 1>(degree + 1));'
p46182
aS'      }'
p46183
aS'    const unsigned int min_fe_index = prm.min_p_degree - 1;'
p46184
aS'    fe_collection.set_hierarchy('
p46185
aS'      [](const typename hp::FECollection<dim> &fe_collection,'
p46186
aS'         const unsigned int                    fe_index) -> unsigned int {'
p46187
aS'        return ((fe_index + 1) < fe_collection.size()) ? fe_index + 1 :'
p46188
aS'                                                         fe_index;'
p46189
aS'      },'
p46190
aS'      [min_fe_index](const typename hp::FECollection<dim> &,'
p46191
aS'                     const unsigned int fe_index) -> unsigned int {'
p46192
aS'        Assert(fe_index >= min_fe_index,'
p46193
aS'               ExcMessage("Finite element is not part of hierarchy!"));'
p46194
aS'        return (fe_index > min_fe_index) ? fe_index - 1 : fe_index;'
p46195
aS'      });'
p46196
aS'    legendre = std::make_unique<FESeries::Legendre<dim>>('
p46197
aS'      SmoothnessEstimator::Legendre::default_fe_series(fe_collection));'
p46198
aS'    cell_weights = std::make_unique<parallel::CellWeights<dim>>('
p46199
aS'      dof_handler,'
p46200
aS'      parallel::CellWeights<dim>::ndofs_weighting('
p46201
aS'        {prm.weighting_factor, prm.weighting_exponent}));'
p46202
aS'    triangulation.signals.post_p4est_refinement.connect('
p46203
aS'      [&, min_fe_index]() {'
p46204
aS'        const parallel::distributed::TemporarilyMatchRefineFlags<dim>'
p46205
aS'          refine_modifier(triangulation);'
p46206
aS'        hp::Refinement::limit_p_level_difference(dof_handler,'
p46207
aS'                                                 prm.max_p_level_difference,'
p46208
aS'      },'
p46209
aS'      boost::signals2::at_front);'
p46210
aS'  }'
p46211
aS'  template <int dim>'
p46212
aS'  void LaplaceProblem<dim>::initialize_grid()'
p46213
aS'  {'
p46214
aS'    TimerOutput::Scope t(computing_timer, "initialize grid");'
p46215
aS'    std::vector<unsigned int> repetitions(dim);'
p46216
aS'    Point<dim>                bottom_left, top_right;'
p46217
aS'    for (unsigned int d = 0; d < dim; ++d)'
p46218
aS'      if (d < 2)'
p46219
aS'        {'
p46220
aS'          repetitions[d] = 2;'
p46221
aS'          bottom_left[d] = -1.;'
p46222
aS'          top_right[d]   = 1.;'
p46223
aS'        }'
p46224
aS'      else'
p46225
aS'        {'
p46226
aS'          repetitions[d] = 1;'
p46227
aS'          bottom_left[d] = 0.;'
p46228
aS'          top_right[d]   = 1.;'
p46229
aS'        }'
p46230
aS'    std::vector<int> cells_to_remove(dim, 1);'
p46231
aS'    cells_to_remove[0] = -1;'
p46232
aS'    GridGenerator::subdivided_hyper_L('
p46233
aS'      triangulation, repetitions, bottom_left, top_right, cells_to_remove);'
p46234
aS'    triangulation.refine_global(prm.min_h_level);'
p46235
aS'    const unsigned int min_fe_index = prm.min_p_degree - 1;'
p46236
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p46237
aS'      if (cell->is_locally_owned())'
p46238
aS'        cell->set_active_fe_index(min_fe_index);'
p46239
aS'  }'
p46240
aS'  template <int dim>'
p46241
aS'  void LaplaceProblem<dim>::setup_system()'
p46242
aS'  {'
p46243
aS'    TimerOutput::Scope t(computing_timer, "setup system");'
p46244
aS'    dof_handler.distribute_dofs(fe_collection);'
p46245
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p46246
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p46247
aS'    locally_relevant_solution.reinit(locally_owned_dofs,'
p46248
aS'                                     locally_relevant_dofs,'
p46249
aS'                                     mpi_communicator);'
p46250
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p46251
aS'    constraints.clear();'
p46252
aS'    constraints.reinit(locally_relevant_dofs);'
p46253
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p46254
aS'    VectorTools::interpolate_boundary_values('
p46255
aS'      mapping_collection, dof_handler, 0, Solution<dim>(), constraints);'
p46256
aS'    constraints.close();'
p46257
aS'    laplace_operator.reinit(mapping_collection,'
p46258
aS'                            dof_handler,'
p46259
aS'                            quadrature_collection,'
p46260
aS'                            constraints,'
p46261
aS'                            system_rhs);'
p46262
aS'  }'
p46263
aS'  template <int dim>'
p46264
aS'  void LaplaceProblem<dim>::print_diagnostics()'
p46265
aS'  {'
p46266
aS'    const unsigned int first_n_processes ='
p46267
aS'      std::min<unsigned int>(8,'
p46268
aS'                             Utilities::MPI::n_mpi_processes(mpi_communicator));'
p46269
aS'    const bool output_cropped ='
p46270
aS'      first_n_processes < Utilities::MPI::n_mpi_processes(mpi_communicator);'
p46271
aS'    {'
p46272
aS'      pcout << "   Number of active cells:       "'
p46273
aS'            << triangulation.n_global_active_cells() << std::endl'
p46274
aS'            << "     by partition:              ";'
p46275
aS'      std::vector<unsigned int> n_active_cells_per_subdomain ='
p46276
aS'        Utilities::MPI::gather(mpi_communicator,'
p46277
aS'                               triangulation.n_locally_owned_active_cells());'
p46278
aS'      for (unsigned int i = 0; i < first_n_processes; ++i)'
p46279
aS"        pcout << ' ' << n_active_cells_per_subdomain[i];"
p46280
aS'      if (output_cropped)'
p46281
aS'        pcout << " ...";'
p46282
aS'      pcout << std::endl;'
p46283
aS'    }'
p46284
aS'    {'
p46285
aS'      pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p46286
aS'            << std::endl'
p46287
aS'            << "     by partition:              ";'
p46288
aS'      std::vector<types::global_dof_index> n_dofs_per_subdomain ='
p46289
aS'        Utilities::MPI::gather(mpi_communicator,'
p46290
aS'                               dof_handler.n_locally_owned_dofs());'
p46291
aS'      for (unsigned int i = 0; i < first_n_processes; ++i)'
p46292
aS"        pcout << ' ' << n_dofs_per_subdomain[i];"
p46293
aS'      if (output_cropped)'
p46294
aS'        pcout << " ...";'
p46295
aS'      pcout << std::endl;'
p46296
aS'    }'
p46297
aS'    {'
p46298
aS'      std::vector<types::global_dof_index> n_constraints_per_subdomain ='
p46299
aS'        Utilities::MPI::gather(mpi_communicator, constraints.n_constraints());'
p46300
aS'      pcout << "   Number of constraints:        "'
p46301
aS'            << std::accumulate(n_constraints_per_subdomain.begin(),'
p46302
aS'                               n_constraints_per_subdomain.end(),'
p46303
aS'                               0)'
p46304
aS'            << std::endl'
p46305
aS'            << "     by partition:              ";'
p46306
aS'      for (unsigned int i = 0; i < first_n_processes; ++i)'
p46307
aS"        pcout << ' ' << n_constraints_per_subdomain[i];"
p46308
aS'      if (output_cropped)'
p46309
aS'        pcout << " ...";'
p46310
aS'      pcout << std::endl;'
p46311
aS'    }'
p46312
aS'    {'
p46313
aS'      std::vector<unsigned int> n_fe_indices(fe_collection.size(), 0);'
p46314
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p46315
aS'        if (cell->is_locally_owned())'
p46316
aS'          n_fe_indices[cell->active_fe_index()]++;'
p46317
aS'      Utilities::MPI::sum(n_fe_indices, mpi_communicator, n_fe_indices);'
p46318
aS'      pcout << "   Frequencies of poly. degrees:";'
p46319
aS'      for (unsigned int i = 0; i < fe_collection.size(); ++i)'
p46320
aS'        if (n_fe_indices[i] > 0)'
p46321
aS'          pcout << \' \' << fe_collection[i].degree << ":" << n_fe_indices[i];'
p46322
aS'      pcout << std::endl;'
p46323
aS'    }'
p46324
aS'  }'
p46325
aS'  template <int dim>'
p46326
aS'  void LaplaceProblem<dim>::solve_system()'
p46327
aS'  {'
p46328
aS'    TimerOutput::Scope t(computing_timer, "solve system");'
p46329
aS'    LinearAlgebra::distributed::Vector<double> completely_distributed_solution;'
p46330
aS'    laplace_operator.initialize_dof_vector(completely_distributed_solution);'
p46331
aS'    SolverControl solver_control(system_rhs.size(),'
p46332
aS'                                 prm.tolerance_factor * system_rhs.l2_norm());'
p46333
aS'    solve_with_gmg(solver_control,'
p46334
aS'                   laplace_operator,'
p46335
aS'                   completely_distributed_solution,'
p46336
aS'                   system_rhs,'
p46337
aS'                   prm.mg_data,'
p46338
aS'                   mapping_collection,'
p46339
aS'                   dof_handler,'
p46340
aS'                   quadrature_collection);'
p46341
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p46342
aS'          << std::endl;'
p46343
aS'    constraints.distribute(completely_distributed_solution);'
p46344
aS'    locally_relevant_solution.copy_locally_owned_data_from('
p46345
aS'      completely_distributed_solution);'
p46346
aS'    locally_relevant_solution.update_ghost_values();'
p46347
aS'  }'
p46348
aS'  template <int dim>'
p46349
aS'  void LaplaceProblem<dim>::compute_indicators()'
p46350
aS'  {'
p46351
aS'    TimerOutput::Scope t(computing_timer, "compute indicators");'
p46352
aS'    estimated_error_per_cell.grow_or_shrink(triangulation.n_active_cells());'
p46353
aS'    KellyErrorEstimator<dim>::estimate('
p46354
aS'      dof_handler,'
p46355
aS'      face_quadrature_collection,'
p46356
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p46357
aS'      locally_relevant_solution,'
p46358
aS'      estimated_error_per_cell,'
p46359
aS'      KellyErrorEstimator<dim>::Strategy::face_diameter_over_twice_max_degree);'
p46360
aS'    hp_decision_indicators.grow_or_shrink(triangulation.n_active_cells());'
p46361
aS'    SmoothnessEstimator::Legendre::coefficient_decay(*legendre,'
p46362
aS'                                                     dof_handler,'
p46363
aS'                                                     locally_relevant_solution,'
p46364
aS'                                                     hp_decision_indicators);'
p46365
aS'  }'
p46366
aS'  template <int dim>'
p46367
aS'  void LaplaceProblem<dim>::adapt_resolution()'
p46368
aS'  {'
p46369
aS'    TimerOutput::Scope t(computing_timer, "adapt resolution");'
p46370
aS'    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p46371
aS'      triangulation,'
p46372
aS'      estimated_error_per_cell,'
p46373
aS'      prm.refine_fraction,'
p46374
aS'      prm.coarsen_fraction);'
p46375
aS'    hp::Refinement::p_adaptivity_fixed_number(dof_handler,'
p46376
aS'                                              hp_decision_indicators,'
p46377
aS'                                              prm.p_refine_fraction,'
p46378
aS'                                              prm.p_coarsen_fraction);'
p46379
aS'    hp::Refinement::choose_p_over_h(dof_handler);'
p46380
aS'    Assert(triangulation.n_levels() >= prm.min_h_level + 1 &&'
p46381
aS'             triangulation.n_levels() <= prm.max_h_level + 1,'
p46382
aS'           ExcInternalError());'
p46383
aS'    if (triangulation.n_levels() > prm.max_h_level)'
p46384
aS'      for (const auto &cell :'
p46385
aS'           triangulation.active_cell_iterators_on_level(prm.max_h_level))'
p46386
aS'        cell->clear_refine_flag();'
p46387
aS'    for (const auto &cell :'
p46388
aS'         triangulation.active_cell_iterators_on_level(prm.min_h_level))'
p46389
aS'      cell->clear_coarsen_flag();'
p46390
aS'    triangulation.execute_coarsening_and_refinement();'
p46391
aS'  }'
p46392
aS'  template <int dim>'
p46393
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle)'
p46394
aS'  {'
p46395
aS'    TimerOutput::Scope t(computing_timer, "output results");'
p46396
aS'    Vector<float> fe_degrees(triangulation.n_active_cells());'
p46397
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p46398
aS'      if (cell->is_locally_owned())'
p46399
aS'        fe_degrees(cell->active_cell_index()) = cell->get_fe().degree;'
p46400
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p46401
aS'    for (auto &subd : subdomain)'
p46402
aS'      subd = triangulation.locally_owned_subdomain();'
p46403
aS'    DataOut<dim> data_out;'
p46404
aS'    data_out.attach_dof_handler(dof_handler);'
p46405
aS'    data_out.add_data_vector(locally_relevant_solution, "solution");'
p46406
aS'    data_out.add_data_vector(fe_degrees, "fe_degree");'
p46407
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p46408
aS'    data_out.add_data_vector(estimated_error_per_cell, "error");'
p46409
aS'    data_out.add_data_vector(hp_decision_indicators, "hp_indicator");'
p46410
aS'    data_out.build_patches(mapping_collection);'
p46411
aS'    data_out.write_vtu_with_pvtu_record('
p46412
aS'      "./", "solution", cycle, mpi_communicator, 2, 1);'
p46413
aS'  }'
p46414
aS'  template <int dim>'
p46415
aS'  void LaplaceProblem<dim>::run()'
p46416
aS'  {'
p46417
aS'    pcout << "Running with Trilinos on "'
p46418
aS'          << Utilities::MPI::n_mpi_processes(mpi_communicator)'
p46419
aS'          << " MPI rank(s)..." << std::endl;'
p46420
aS'    {'
p46421
aS'      pcout << "Calculating transformation matrices..." << std::endl;'
p46422
aS'      TimerOutput::Scope t(computing_timer, "calculate transformation");'
p46423
aS'      legendre->precalculate_all_transformation_matrices();'
p46424
aS'    }'
p46425
aS'    for (unsigned int cycle = 0; cycle < prm.n_cycles; ++cycle)'
p46426
aS'      {'
p46427
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p46428
aS'        if (cycle == 0)'
p46429
aS'          initialize_grid();'
p46430
aS'        else'
p46431
aS'          adapt_resolution();'
p46432
aS'        setup_system();'
p46433
aS'        print_diagnostics();'
p46434
aS'        solve_system();'
p46435
aS'        compute_indicators();'
p46436
aS'        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32)'
p46437
aS'          output_results(cycle);'
p46438
aS'        computing_timer.print_summary();'
p46439
aS'        computing_timer.reset();'
p46440
aS'        pcout << std::endl;'
p46441
aS'      }'
p46442
aS'  }'
p46443
aS'} // namespace Step75'
p46444
aS'int main(int argc, char *argv[])'
p46445
ag24
aS'  try'
p46446
aS'    {'
p46447
aS'      using namespace dealii;'
p46448
aS'      using namespace Step75;'
p46449
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p46450
aS'      Parameters        prm;'
p46451
aS'      LaplaceProblem<2> laplace_problem(prm);'
p46452
aS'      laplace_problem.run();'
p46453
aS'    }'
p46454
aS'  catch (std::exception &exc)'
p46455
aS'    {'
p46456
aS'      std::cerr << std::endl'
p46457
aS'                << std::endl'
p46458
aS'                << "----------------------------------------------------"'
p46459
aS'                << std::endl;'
p46460
aS'      std::cerr << "Exception on processing: " << std::endl'
p46461
aS'                << exc.what() << std::endl'
p46462
aS'                << "Aborting!" << std::endl'
p46463
aS'                << "----------------------------------------------------"'
p46464
aS'                << std::endl;'
p46465
aS'      return 1;'
p46466
aS'    }'
p46467
aS'  catch (...)'
p46468
aS'    {'
p46469
aS'      std::cerr << std::endl'
p46470
aS'                << std::endl'
p46471
aS'                << "----------------------------------------------------"'
p46472
aS'                << std::endl;'
p46473
aS'      std::cerr << "Unknown exception!" << std::endl'
p46474
aS'                << "Aborting!" << std::endl'
p46475
aS'                << "----------------------------------------------------"'
p46476
aS'                << std::endl;'
p46477
aS'      return 1;'
p46478
aS'    }'
p46479
aS'  return 0;'
p46480
ag32
aS'/* ---------------------------------------------------------------------'
p46481
aS' *'
p46482
aS' * Copyright (C) 2020 - 2021 by the deal.II authors'
p46483
aS' *'
p46484
aS' * This file is part of the deal.II library.'
p46485
aS' *'
p46486
aS' * The deal.II library is free software; you can use it, redistribute'
p46487
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p46488
aS' * Public License as published by the Free Software Foundation; either'
p46489
aS' * version 2.1 of the License, or (at your option) any later version.'
p46490
aS' * The full text of the license can be found in the file LICENSE.md at'
p46491
aS' * the top level directory of deal.II.'
p46492
aS' *'
p46493
aS' * ---------------------------------------------------------------------'
p46494
aS' *'
p46495
aS' * Author: Martin Kronbichler, Peter Munch, David Schneider, 2020'
p46496
aS' */'
p46497
aS'#include <deal.II/base/conditional_ostream.h>'
p46498
aS'#include <deal.II/base/function.h>'
p46499
aS'#include <deal.II/base/logstream.h>'
p46500
aS'#include <deal.II/base/time_stepping.h>'
p46501
aS'#include <deal.II/base/timer.h>'
p46502
aS'#include <deal.II/base/utilities.h>'
p46503
aS'#include <deal.II/base/vectorization.h>'
p46504
aS'#include <deal.II/distributed/tria.h>'
p46505
aS'#include <deal.II/dofs/dof_handler.h>'
p46506
aS'#include <deal.II/fe/fe_dgq.h>'
p46507
aS'#include <deal.II/fe/fe_system.h>'
p46508
aS'#include <deal.II/grid/grid_generator.h>'
p46509
aS'#include <deal.II/grid/tria.h>'
p46510
aS'#include <deal.II/grid/tria_accessor.h>'
p46511
aS'#include <deal.II/grid/tria_iterator.h>'
p46512
aS'#include <deal.II/lac/affine_constraints.h>'
p46513
aS'#include <deal.II/lac/la_parallel_vector.h>'
p46514
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p46515
aS'#include <deal.II/matrix_free/matrix_free.h>'
p46516
aS'#include <deal.II/matrix_free/operators.h>'
p46517
aS'#include <deal.II/numerics/data_out.h>'
p46518
aS'#include <fstream>'
p46519
aS'#include <iomanip>'
p46520
aS'#include <iostream>'
p46521
aS'#include <deal.II/matrix_free/tools.h>'
p46522
aS'namespace Euler_DG'
p46523
ag24
aS'  using namespace dealii;'
p46524
aS'  constexpr unsigned int testcase             = 1;'
p46525
aS'  constexpr unsigned int dimension            = 2;'
p46526
aS'  constexpr unsigned int n_global_refinements = 2;'
p46527
aS'  constexpr unsigned int fe_degree            = 5;'
p46528
aS'  constexpr unsigned int n_q_points_1d        = fe_degree + 2;'
p46529
aS'  constexpr unsigned int group_size = numbers::invalid_unsigned_int;'
p46530
aS'  using Number = double;'
p46531
aS'  using VectorizedArrayType = VectorizedArray<Number>;'
p46532
aS'  constexpr double gamma       = 1.4;'
p46533
aS'  constexpr double final_time  = testcase == 0 ? 10 : 2.0;'
p46534
aS'  constexpr double output_tick = testcase == 0 ? 1 : 0.05;'
p46535
aS'  const double courant_number = 0.15 / std::pow(fe_degree, 1.5);'
p46536
aS'  constexpr unsigned int max_time_steps = numbers::invalid_unsigned_int;'
p46537
aS'  enum LowStorageRungeKuttaScheme'
p46538
aS'  {'
p46539
aS'    stage_3_order_3,'
p46540
aS'    stage_5_order_4,'
p46541
aS'    stage_7_order_4,'
p46542
aS'    stage_9_order_5,'
p46543
aS'  };'
p46544
aS'  constexpr LowStorageRungeKuttaScheme lsrk_scheme = stage_5_order_4;'
p46545
aS'  class LowStorageRungeKuttaIntegrator'
p46546
aS'  {'
p46547
aS'  public:'
p46548
aS'    LowStorageRungeKuttaIntegrator(const LowStorageRungeKuttaScheme scheme)'
p46549
aS'    {'
p46550
aS'      TimeStepping::runge_kutta_method lsrk;'
p46551
aS'      switch (scheme)'
p46552
aS'        {'
p46553
aS'          case stage_3_order_3:'
p46554
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE3_ORDER3;'
p46555
aS'            break;'
p46556
aS'          case stage_5_order_4:'
p46557
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE5_ORDER4;'
p46558
aS'            break;'
p46559
aS'          case stage_7_order_4:'
p46560
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE7_ORDER4;'
p46561
aS'            break;'
p46562
aS'          case stage_9_order_5:'
p46563
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE9_ORDER5;'
p46564
aS'            break;'
p46565
aS'          default:'
p46566
aS'            AssertThrow(false, ExcNotImplemented());'
p46567
aS'        }'
p46568
aS'      TimeStepping::LowStorageRungeKutta<'
p46569
aS'        LinearAlgebra::distributed::Vector<Number>>'
p46570
aS'                          rk_integrator(lsrk);'
p46571
aS'      std::vector<double> ci; // not used'
p46572
aS'      rk_integrator.get_coefficients(ai, bi, ci);'
p46573
aS'    }'
p46574
aS'    unsigned int n_stages() const'
p46575
aS'    {'
p46576
aS'      return bi.size();'
p46577
aS'    }'
p46578
aS'    template <typename VectorType, typename Operator>'
p46579
aS'    void perform_time_step(const Operator &pde_operator,'
p46580
aS'                           const double    current_time,'
p46581
aS'                           const double    time_step,'
p46582
aS'                           VectorType &    solution,'
p46583
aS'                           VectorType &    vec_ri,'
p46584
aS'                           VectorType &    vec_ki) const'
p46585
aS'    {'
p46586
aS'      AssertDimension(ai.size() + 1, bi.size());'
p46587
aS'      vec_ki.swap(solution);'
p46588
aS'      double sum_previous_bi = 0;'
p46589
aS'      for (unsigned int stage = 0; stage < bi.size(); ++stage)'
p46590
aS'        {'
p46591
aS'          const double c_i = stage == 0 ? 0 : sum_previous_bi + ai[stage - 1];'
p46592
aS'          pde_operator.perform_stage(stage,'
p46593
aS'                                     current_time + c_i * time_step,'
p46594
aS'                                     bi[stage] * time_step,'
p46595
aS'                                     (stage == bi.size() - 1 ?'
p46596
aS'                                        0 :'
p46597
aS'                                        ai[stage] * time_step),'
p46598
aS'                                     (stage % 2 == 0 ? vec_ki : vec_ri),'
p46599
aS'                                     (stage % 2 == 0 ? vec_ri : vec_ki),'
p46600
aS'                                     solution);'
p46601
aS'          if (stage > 0)'
p46602
aS'            sum_previous_bi += bi[stage - 1];'
p46603
aS'        }'
p46604
aS'    }'
p46605
aS'  private:'
p46606
aS'    std::vector<double> bi;'
p46607
aS'    std::vector<double> ai;'
p46608
aS'  };'
p46609
aS'  enum EulerNumericalFlux'
p46610
aS'  {'
p46611
aS'    lax_friedrichs_modified,'
p46612
aS'    harten_lax_vanleer,'
p46613
aS'  };'
p46614
aS'  constexpr EulerNumericalFlux numerical_flux_type = lax_friedrichs_modified;'
p46615
aS'  template <int dim>'
p46616
aS'  class ExactSolution : public Function<dim>'
p46617
aS'  {'
p46618
aS'  public:'
p46619
aS'    ExactSolution(const double time)'
p46620
aS'      : Function<dim>(dim + 2, time)'
p46621
aS'    {}'
p46622
aS'    virtual double value(const Point<dim> & p,'
p46623
aS'                         const unsigned int component = 0) const override;'
p46624
aS'  };'
p46625
aS'  template <int dim>'
p46626
aS'  double ExactSolution<dim>::value(const Point<dim> & x,'
p46627
aS'                                   const unsigned int component) const'
p46628
aS'  {'
p46629
aS'    const double t = this->get_time();'
p46630
aS'    switch (testcase)'
p46631
aS'      {'
p46632
aS'        case 0:'
p46633
aS'          {'
p46634
aS'            Assert(dim == 2, ExcNotImplemented());'
p46635
aS'            const double beta = 5;'
p46636
aS'            Point<dim> x0;'
p46637
aS'            x0[0] = 5.;'
p46638
aS'            const double radius_sqr ='
p46639
aS'              (x - x0).norm_square() - 2. * (x[0] - x0[0]) * t + t * t;'
p46640
aS'            const double factor ='
p46641
aS'              beta / (numbers::PI * 2) * std::exp(1. - radius_sqr);'
p46642
aS'            const double density_log = std::log2('
p46643
aS'              std::abs(1. - (gamma - 1.) / gamma * 0.25 * factor * factor));'
p46644
aS'            const double density = std::exp2(density_log * (1. / (gamma - 1.)));'
p46645
aS'            const double u       = 1. - factor * (x[1] - x0[1]);'
p46646
aS'            const double v       = factor * (x[0] - t - x0[0]);'
p46647
aS'            if (component == 0)'
p46648
aS'              return density;'
p46649
aS'            else if (component == 1)'
p46650
aS'              return density * u;'
p46651
aS'            else if (component == 2)'
p46652
aS'              return density * v;'
p46653
aS'            else'
p46654
aS'              {'
p46655
aS'                const double pressure ='
p46656
aS'                  std::exp2(density_log * (gamma / (gamma - 1.)));'
p46657
aS'                return pressure / (gamma - 1.) +'
p46658
aS'                       0.5 * (density * u * u + density * v * v);'
p46659
aS'              }'
p46660
aS'          }'
p46661
aS'        case 1:'
p46662
aS'          {'
p46663
aS'            if (component == 0)'
p46664
aS'              return 1.;'
p46665
aS'            else if (component == 1)'
p46666
aS'              return 0.4;'
p46667
aS'            else if (component == dim + 1)'
p46668
aS'              return 3.097857142857143;'
p46669
aS'            else'
p46670
aS'              return 0.;'
p46671
aS'          }'
p46672
aS'        default:'
p46673
aS'          Assert(false, ExcNotImplemented());'
p46674
aS'          return 0.;'
p46675
aS'      }'
p46676
aS'  }'
p46677
aS'  template <int dim, typename Number>'
p46678
aS'  inline DEAL_II_ALWAYS_INLINE //'
p46679
aS'    Tensor<1, dim, Number>'
p46680
aS'    euler_velocity(const Tensor<1, dim + 2, Number> &conserved_variables)'
p46681
aS'  {'
p46682
aS'    const Number inverse_density = Number(1.) / conserved_variables[0];'
p46683
aS'    Tensor<1, dim, Number> velocity;'
p46684
aS'    for (unsigned int d = 0; d < dim; ++d)'
p46685
aS'      velocity[d] = conserved_variables[1 + d] * inverse_density;'
p46686
aS'    return velocity;'
p46687
aS'  }'
p46688
aS'  template <int dim, typename Number>'
p46689
aS'  inline DEAL_II_ALWAYS_INLINE //'
p46690
aS'    Number'
p46691
aS'    euler_pressure(const Tensor<1, dim + 2, Number> &conserved_variables)'
p46692
aS'  {'
p46693
aS'    const Tensor<1, dim, Number> velocity ='
p46694
aS'      euler_velocity<dim>(conserved_variables);'
p46695
aS'    Number rho_u_dot_u = conserved_variables[1] * velocity[0];'
p46696
aS'    for (unsigned int d = 1; d < dim; ++d)'
p46697
aS'      rho_u_dot_u += conserved_variables[1 + d] * velocity[d];'
p46698
aS'    return (gamma - 1.) * (conserved_variables[dim + 1] - 0.5 * rho_u_dot_u);'
p46699
aS'  }'
p46700
aS'  template <int dim, typename Number>'
p46701
aS'  inline DEAL_II_ALWAYS_INLINE //'
p46702
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>>'
p46703
aS'    euler_flux(const Tensor<1, dim + 2, Number> &conserved_variables)'
p46704
aS'  {'
p46705
aS'    const Tensor<1, dim, Number> velocity ='
p46706
aS'      euler_velocity<dim>(conserved_variables);'
p46707
aS'    const Number pressure = euler_pressure<dim>(conserved_variables);'
p46708
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>> flux;'
p46709
aS'    for (unsigned int d = 0; d < dim; ++d)'
p46710
aS'      {'
p46711
aS'        flux[0][d] = conserved_variables[1 + d];'
p46712
aS'        for (unsigned int e = 0; e < dim; ++e)'
p46713
aS'          flux[e + 1][d] = conserved_variables[e + 1] * velocity[d];'
p46714
aS'        flux[d + 1][d] += pressure;'
p46715
aS'        flux[dim + 1][d] ='
p46716
aS'          velocity[d] * (conserved_variables[dim + 1] + pressure);'
p46717
aS'      }'
p46718
aS'    return flux;'
p46719
aS'  }'
p46720
aS'  template <int n_components, int dim, typename Number>'
p46721
aS'  inline DEAL_II_ALWAYS_INLINE //'
p46722
aS'    Tensor<1, n_components, Number>'
p46723
aS'    operator*(const Tensor<1, n_components, Tensor<1, dim, Number>> &matrix,'
p46724
aS'              const Tensor<1, dim, Number> &                         vector)'
p46725
aS'  {'
p46726
aS'    Tensor<1, n_components, Number> result;'
p46727
aS'    for (unsigned int d = 0; d < n_components; ++d)'
p46728
aS'      result[d] = matrix[d] * vector;'
p46729
aS'    return result;'
p46730
aS'  }'
p46731
aS'  template <int dim, typename Number>'
p46732
aS'  inline DEAL_II_ALWAYS_INLINE //'
p46733
aS'    Tensor<1, dim + 2, Number>'
p46734
aS'    euler_numerical_flux(const Tensor<1, dim + 2, Number> &u_m,'
p46735
aS'                         const Tensor<1, dim + 2, Number> &u_p,'
p46736
aS'                         const Tensor<1, dim, Number> &    normal)'
p46737
aS'  {'
p46738
aS'    const auto velocity_m = euler_velocity<dim>(u_m);'
p46739
aS'    const auto velocity_p = euler_velocity<dim>(u_p);'
p46740
aS'    const auto pressure_m = euler_pressure<dim>(u_m);'
p46741
aS'    const auto pressure_p = euler_pressure<dim>(u_p);'
p46742
aS'    const auto flux_m = euler_flux<dim>(u_m);'
p46743
aS'    const auto flux_p = euler_flux<dim>(u_p);'
p46744
aS'    switch (numerical_flux_type)'
p46745
aS'      {'
p46746
aS'        case lax_friedrichs_modified:'
p46747
aS'          {'
p46748
aS'            const auto lambda ='
p46749
aS'              0.5 * std::sqrt(std::max(velocity_p.norm_square() +'
p46750
aS'                                         gamma * pressure_p * (1. / u_p[0]),'
p46751
aS'                                       velocity_m.norm_square() +'
p46752
aS'                                         gamma * pressure_m * (1. / u_m[0])));'
p46753
aS'            return 0.5 * (flux_m * normal + flux_p * normal) +'
p46754
aS'                   0.5 * lambda * (u_m - u_p);'
p46755
aS'          }'
p46756
aS'        case harten_lax_vanleer:'
p46757
aS'          {'
p46758
aS'            const auto avg_velocity_normal ='
p46759
aS'              0.5 * ((velocity_m + velocity_p) * normal);'
p46760
aS'            const auto   avg_c = std::sqrt(std::abs('
p46761
aS'              0.5 * gamma *'
p46762
aS'              (pressure_p * (1. / u_p[0]) + pressure_m * (1. / u_m[0]))));'
p46763
aS'            const Number s_pos ='
p46764
aS'              std::max(Number(), avg_velocity_normal + avg_c);'
p46765
aS'            const Number s_neg ='
p46766
aS'              std::min(Number(), avg_velocity_normal - avg_c);'
p46767
aS'            const Number inverse_s = Number(1.) / (s_pos - s_neg);'
p46768
aS'            return inverse_s *'
p46769
aS'                   ((s_pos * (flux_m * normal) - s_neg * (flux_p * normal)) -'
p46770
aS'                    s_pos * s_neg * (u_m - u_p));'
p46771
aS'          }'
p46772
aS'        default:'
p46773
aS'          {'
p46774
aS'            Assert(false, ExcNotImplemented());'
p46775
aS'            return {};'
p46776
aS'          }'
p46777
aS'      }'
p46778
aS'  }'
p46779
aS'  template <int dim, typename VectorizedArrayType>'
p46780
aS'  VectorizedArrayType'
p46781
aS'  evaluate_function(const Function<dim> &                  function,'
p46782
aS'                    const Point<dim, VectorizedArrayType> &p_vectorized,'
p46783
aS'                    const unsigned int                     component)'
p46784
aS'  {'
p46785
aS'    VectorizedArrayType result;'
p46786
aS'    for (unsigned int v = 0; v < VectorizedArrayType::size(); ++v)'
p46787
aS'      {'
p46788
aS'        Point<dim> p;'
p46789
aS'        for (unsigned int d = 0; d < dim; ++d)'
p46790
aS'          p[d] = p_vectorized[d][v];'
p46791
aS'        result[v] = function.value(p, component);'
p46792
aS'      }'
p46793
aS'    return result;'
p46794
aS'  }'
p46795
aS'  template <int dim, typename VectorizedArrayType, int n_components = dim + 2>'
p46796
aS'  Tensor<1, n_components, VectorizedArrayType>'
p46797
aS'  evaluate_function(const Function<dim> &                  function,'
p46798
aS'                    const Point<dim, VectorizedArrayType> &p_vectorized)'
p46799
aS'  {'
p46800
aS'    AssertDimension(function.n_components, n_components);'
p46801
aS'    Tensor<1, n_components, VectorizedArrayType> result;'
p46802
aS'    for (unsigned int v = 0; v < VectorizedArrayType::size(); ++v)'
p46803
aS'      {'
p46804
aS'        Point<dim> p;'
p46805
aS'        for (unsigned int d = 0; d < dim; ++d)'
p46806
aS'          p[d] = p_vectorized[d][v];'
p46807
aS'        for (unsigned int d = 0; d < n_components; ++d)'
p46808
aS'          result[d][v] = function.value(p, d);'
p46809
aS'      }'
p46810
aS'    return result;'
p46811
aS'  }'
p46812
aS'  template <int dim, int degree, int n_points_1d>'
p46813
aS'  class EulerOperator'
p46814
aS'  {'
p46815
aS'  public:'
p46816
aS'    static constexpr unsigned int n_quadrature_points_1d = n_points_1d;'
p46817
aS'    EulerOperator(TimerOutput &timer_output);'
p46818
aS'    ~EulerOperator();'
p46819
aS'    void reinit(const Mapping<dim> &   mapping,'
p46820
aS'                const DoFHandler<dim> &dof_handler);'
p46821
aS'    void set_inflow_boundary(const types::boundary_id       boundary_id,'
p46822
aS'                             std::unique_ptr<Function<dim>> inflow_function);'
p46823
aS'    void set_subsonic_outflow_boundary('
p46824
aS'      const types::boundary_id       boundary_id,'
p46825
aS'      std::unique_ptr<Function<dim>> outflow_energy);'
p46826
aS'    void set_wall_boundary(const types::boundary_id boundary_id);'
p46827
aS'    void set_body_force(std::unique_ptr<Function<dim>> body_force);'
p46828
aS'    void'
p46829
aS'    perform_stage(const unsigned int                                stage,'
p46830
aS'                  const Number                                      cur_time,'
p46831
aS'                  const Number                                      bi,'
p46832
aS'                  const Number                                      ai,'
p46833
aS'                  const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p46834
aS'                  LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p46835
aS'                  LinearAlgebra::distributed::Vector<Number> &solution) const;'
p46836
aS'    void project(const Function<dim> &                       function,'
p46837
aS'                 LinearAlgebra::distributed::Vector<Number> &solution) const;'
p46838
aS'    std::array<double, 3> compute_errors('
p46839
aS'      const Function<dim> &                             function,'
p46840
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p46841
aS'    double compute_cell_transport_speed('
p46842
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p46843
aS'    void'
p46844
aS'    initialize_vector(LinearAlgebra::distributed::Vector<Number> &vector) const;'
p46845
aS'  private:'
p46846
aS'    MPI_Comm subcommunicator;'
p46847
aS'    MatrixFree<dim, Number, VectorizedArrayType> data;'
p46848
aS'    TimerOutput &timer;'
p46849
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p46850
aS'      inflow_boundaries;'
p46851
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p46852
aS'                                   subsonic_outflow_boundaries;'
p46853
aS'    std::set<types::boundary_id>   wall_boundaries;'
p46854
aS'    std::unique_ptr<Function<dim>> body_force;'
p46855
aS'  };'
p46856
aS'  template <int dim, int degree, int n_points_1d>'
p46857
aS'  EulerOperator<dim, degree, n_points_1d>::EulerOperator(TimerOutput &timer)'
p46858
aS'    : timer(timer)'
p46859
aS'  {'
p46860
aS'#if DEAL_II_MPI_VERSION_GTE(3, 0)'
p46861
aS'    if (group_size == 1)'
p46862
aS'      {'
p46863
aS'        this->subcommunicator = MPI_COMM_SELF;'
p46864
aS'      }'
p46865
aS'    else if (group_size == numbers::invalid_unsigned_int)'
p46866
aS'      {'
p46867
aS'        const auto rank = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);'
p46868
aS'        MPI_Comm_split_type(MPI_COMM_WORLD,'
p46869
aS'                            MPI_COMM_TYPE_SHARED,'
p46870
aS'                            rank,'
p46871
aS'                            MPI_INFO_NULL,'
p46872
aS'                            &subcommunicator);'
p46873
aS'      }'
p46874
aS'    else'
p46875
aS'      {'
p46876
aS'        Assert(false, ExcNotImplemented());'
p46877
aS'      }'
p46878
aS'#else'
p46879
aS'    (void)subcommunicator;'
p46880
aS'    (void)group_size;'
p46881
aS'    this->subcommunicator = MPI_COMM_SELF;'
p46882
aS'#endif'
p46883
aS'  }'
p46884
aS'  template <int dim, int degree, int n_points_1d>'
p46885
aS'  EulerOperator<dim, degree, n_points_1d>::~EulerOperator()'
p46886
aS'  {'
p46887
aS'#ifdef DEAL_II_WITH_MPI'
p46888
aS'    if (this->subcommunicator != MPI_COMM_SELF)'
p46889
aS'      MPI_Comm_free(&subcommunicator);'
p46890
aS'#endif'
p46891
aS'  }'
p46892
aS'  template <int dim, int degree, int n_points_1d>'
p46893
aS'  void EulerOperator<dim, degree, n_points_1d>::reinit('
p46894
aS'    const Mapping<dim> &   mapping,'
p46895
aS'    const DoFHandler<dim> &dof_handler)'
p46896
aS'  {'
p46897
aS'    const std::vector<const DoFHandler<dim> *> dof_handlers = {&dof_handler};'
p46898
aS'    const AffineConstraints<double>            dummy;'
p46899
aS'    const std::vector<const AffineConstraints<double> *> constraints = {&dummy};'
p46900
aS'    const std::vector<Quadrature<1>> quadratures = {QGauss<1>(n_q_points_1d),'
p46901
aS'                                                    QGauss<1>(fe_degree + 1)};'
p46902
aS'    typename MatrixFree<dim, Number, VectorizedArrayType>::AdditionalData'
p46903
aS'      additional_data;'
p46904
aS'    additional_data.mapping_update_flags ='
p46905
aS'      (update_gradients | update_JxW_values | update_quadrature_points |'
p46906
aS'       update_values);'
p46907
aS'    additional_data.mapping_update_flags_inner_faces ='
p46908
aS'      (update_JxW_values | update_quadrature_points | update_normal_vectors |'
p46909
aS'       update_values);'
p46910
aS'    additional_data.mapping_update_flags_boundary_faces ='
p46911
aS'      (update_JxW_values | update_quadrature_points | update_normal_vectors |'
p46912
aS'       update_values);'
p46913
aS'    additional_data.tasks_parallel_scheme ='
p46914
aS'      MatrixFree<dim, Number, VectorizedArrayType>::AdditionalData::none;'
p46915
aS'    MatrixFreeTools::categorize_by_boundary_ids(dof_handler.get_triangulation(),'
p46916
aS'                                                additional_data);'
p46917
aS'    additional_data.communicator_sm = subcommunicator;'
p46918
aS'    data.reinit('
p46919
aS'      mapping, dof_handlers, constraints, quadratures, additional_data);'
p46920
aS'  }'
p46921
aS'  template <int dim, int degree, int n_points_1d>'
p46922
aS'  void EulerOperator<dim, degree, n_points_1d>::perform_stage('
p46923
aS'    const unsigned int                                stage,'
p46924
aS'    const Number                                      current_time,'
p46925
aS'    const Number                                      bi,'
p46926
aS'    const Number                                      ai,'
p46927
aS'    const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p46928
aS'    LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p46929
aS'    LinearAlgebra::distributed::Vector<Number> &      solution) const'
p46930
aS'  {'
p46931
aS'    for (auto &i : inflow_boundaries)'
p46932
aS'      i.second->set_time(current_time);'
p46933
aS'    for (auto &i : subsonic_outflow_boundaries)'
p46934
aS'      i.second->set_time(current_time);'
p46935
aS'    data.template loop_cell_centric<LinearAlgebra::distributed::Vector<Number>,'
p46936
aS'                                    LinearAlgebra::distributed::Vector<Number>>('
p46937
aS'      [&](const auto &data, auto &dst, const auto &src, const auto cell_range) {'
p46938
aS'        using FECellIntegral = FEEvaluation<dim,'
p46939
aS'                                            degree,'
p46940
aS'                                            n_points_1d,'
p46941
aS'                                            dim + 2,'
p46942
aS'                                            Number,'
p46943
aS'                                            VectorizedArrayType>;'
p46944
aS'        using FEFaceIntegral = FEFaceEvaluation<dim,'
p46945
aS'                                                degree,'
p46946
aS'                                                n_points_1d,'
p46947
aS'                                                dim + 2,'
p46948
aS'                                                Number,'
p46949
aS'                                                VectorizedArrayType>;'
p46950
aS'        FECellIntegral phi(data);'
p46951
aS'        FECellIntegral phi_temp(data);'
p46952
aS'        FEFaceIntegral phi_m(data, true);'
p46953
aS'        FEFaceIntegral phi_p(data, false);'
p46954
aS'        Tensor<1, dim, VectorizedArrayType>     constant_body_force;'
p46955
aS'        const Functions::ConstantFunction<dim> *constant_function ='
p46956
aS'          dynamic_cast<Functions::ConstantFunction<dim> *>(body_force.get());'
p46957
aS'        if (constant_function)'
p46958
aS'          constant_body_force ='
p46959
aS'            evaluate_function<dim, VectorizedArrayType, dim>('
p46960
aS'              *constant_function, Point<dim, VectorizedArrayType>());'
p46961
aS'        const dealii::internal::EvaluatorTensorProduct<'
p46962
aS'          dealii::internal::EvaluatorVariant::evaluate_evenodd,'
p46963
aS'          dim,'
p46964
aS'          n_points_1d,'
p46965
aS'          n_points_1d,'
p46966
aS'          VectorizedArrayType>'
p46967
aS'          eval(AlignedVector<VectorizedArrayType>(),'
p46968
aS'               data.get_shape_info().data[0].shape_gradients_collocation_eo,'
p46969
aS'               AlignedVector<VectorizedArrayType>());'
p46970
aS'        AlignedVector<VectorizedArrayType> buffer(phi.static_n_q_points *'
p46971
aS'                                                  phi.n_components);'
p46972
aS'        for (unsigned int cell = cell_range.first; cell < cell_range.second;'
p46973
aS'             ++cell)'
p46974
aS'          {'
p46975
aS'            phi.reinit(cell);'
p46976
aS'            if (ai != Number())'
p46977
aS'              phi_temp.reinit(cell);'
p46978
aS'            if (ai != Number() && stage == 0)'
p46979
aS'              {'
p46980
aS'                phi.read_dof_values(src);'
p46981
aS'                for (unsigned int i = 0;'
p46982
aS'                     i < phi.static_dofs_per_component * (dim + 2);'
p46983
aS'                     ++i)'
p46984
aS'                  phi_temp.begin_dof_values()[i] = phi.begin_dof_values()[i];'
p46985
aS'                phi.evaluate(EvaluationFlags::values);'
p46986
aS'              }'
p46987
aS'            else'
p46988
aS'              {'
p46989
aS'                phi.gather_evaluate(src, EvaluationFlags::values);'
p46990
aS'              }'
p46991
aS'            for (unsigned int i = 0; i < phi.static_n_q_points * (dim + 2); ++i)'
p46992
aS'              buffer[i] = phi.begin_values()[i];'
p46993
aS'            for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p46994
aS'              {'
p46995
aS'                const auto w_q = phi.get_value(q);'
p46996
aS'                phi.submit_gradient(euler_flux<dim>(w_q), q);'
p46997
aS'                if (body_force.get() != nullptr)'
p46998
aS'                  {'
p46999
aS'                    const Tensor<1, dim, VectorizedArrayType> force ='
p47000
aS'                      constant_function ?'
p47001
aS'                        constant_body_force :'
p47002
aS'                        evaluate_function<dim, VectorizedArrayType, dim>('
p47003
aS'                          *body_force, phi.quadrature_point(q));'
p47004
aS'                    Tensor<1, dim + 2, VectorizedArrayType> forcing;'
p47005
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p47006
aS'                      forcing[d + 1] = w_q[0] * force[d];'
p47007
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p47008
aS'                      forcing[dim + 1] += force[d] * w_q[d + 1];'
p47009
aS'                    phi.submit_value(forcing, q);'
p47010
aS'                  }'
p47011
aS'              }'
p47012
aS'            {'
p47013
aS'              auto *values_ptr   = phi.begin_values();'
p47014
aS'              auto *gradient_ptr = phi.begin_gradients();'
p47015
aS'              for (unsigned int c = 0; c < dim + 2; ++c)'
p47016
aS'                {'
p47017
aS'                  if (dim >= 1 && body_force.get() == nullptr)'
p47018
aS'                    eval.template gradients<0, false, false>('
p47019
aS'                      gradient_ptr + phi.static_n_q_points * 0, values_ptr);'
p47020
aS'                  else if (dim >= 1)'
p47021
aS'                    eval.template gradients<0, false, true>('
p47022
aS'                      gradient_ptr + phi.static_n_q_points * 0, values_ptr);'
p47023
aS'                  if (dim >= 2)'
p47024
aS'                    eval.template gradients<1, false, true>('
p47025
aS'                      gradient_ptr + phi.static_n_q_points * 1, values_ptr);'
p47026
aS'                  if (dim >= 3)'
p47027
aS'                    eval.template gradients<2, false, true>('
p47028
aS'                      gradient_ptr + phi.static_n_q_points * 2, values_ptr);'
p47029
aS'                  values_ptr += phi.static_n_q_points;'
p47030
aS'                  gradient_ptr += phi.static_n_q_points * dim;'
p47031
aS'                }'
p47032
aS'            }'
p47033
aS'            for (unsigned int face = 0;'
p47034
aS'                 face < GeometryInfo<dim>::faces_per_cell;'
p47035
aS'                 ++face)'
p47036
aS'              {'
p47037
aS'                const auto boundary_ids ='
p47038
aS'                  data.get_faces_by_cells_boundary_id(cell, face);'
p47039
aS'                Assert(std::equal(boundary_ids.begin(),'
p47040
aS'                                  boundary_ids.begin() +'
p47041
aS'                                    data.n_active_entries_per_cell_batch(cell),'
p47042
aS'                                  boundary_ids.begin()),'
p47043
aS'                       ExcMessage("Boundary IDs of lanes differ."));'
p47044
aS'                const auto boundary_id = boundary_ids[0];'
p47045
aS'                phi_m.reinit(cell, face);'
p47046
aS'                internal::FEFaceNormalEvaluationImpl<dim,'
p47047
aS'                                                     n_points_1d - 1,'
p47048
aS'                                                     VectorizedArrayType>::'
p47049
aS'                  template interpolate_quadrature<true, false>('
p47050
aS'                    dim + 2,'
p47051
aS'                    data.get_shape_info(),'
p47052
aS'                    buffer.data(),'
p47053
aS'                    phi_m.begin_values(),'
p47054
aS'                    false,'
p47055
aS'                    face);'
p47056
aS'                if (boundary_id == numbers::internal_face_boundary_id)'
p47057
aS'                  {'
p47058
aS'                    phi_p.reinit(cell, face);'
p47059
aS'                    phi_p.gather_evaluate(src, EvaluationFlags::values);'
p47060
aS'                    for (unsigned int q = 0; q < phi_m.n_q_points; ++q)'
p47061
aS'                      {'
p47062
aS'                        const auto numerical_flux ='
p47063
aS'                          euler_numerical_flux<dim>(phi_m.get_value(q),'
p47064
aS'                                                    phi_p.get_value(q),'
p47065
aS'                                                    phi_m.get_normal_vector(q));'
p47066
aS'                        phi_m.submit_value(-numerical_flux, q);'
p47067
aS'                      }'
p47068
aS'                  }'
p47069
aS'                else'
p47070
aS'                  {'
p47071
aS'                    for (unsigned int q = 0; q < phi_m.n_q_points; ++q)'
p47072
aS'                      {'
p47073
aS'                        const auto w_m    = phi_m.get_value(q);'
p47074
aS'                        const auto normal = phi_m.get_normal_vector(q);'
p47075
aS'                        auto rho_u_dot_n = w_m[1] * normal[0];'
p47076
aS'                        for (unsigned int d = 1; d < dim; ++d)'
p47077
aS'                          rho_u_dot_n += w_m[1 + d] * normal[d];'
p47078
aS'                        bool at_outflow = false;'
p47079
aS'                        Tensor<1, dim + 2, VectorizedArrayType> w_p;'
p47080
aS'                        if (wall_boundaries.find(boundary_id) !='
p47081
aS'                            wall_boundaries.end())'
p47082
aS'                          {'
p47083
aS'                            w_p[0] = w_m[0];'
p47084
aS'                            for (unsigned int d = 0; d < dim; ++d)'
p47085
aS'                              w_p[d + 1] ='
p47086
aS'                                w_m[d + 1] - 2. * rho_u_dot_n * normal[d];'
p47087
aS'                            w_p[dim + 1] = w_m[dim + 1];'
p47088
aS'                          }'
p47089
aS'                        else if (inflow_boundaries.find(boundary_id) !='
p47090
aS'                                 inflow_boundaries.end())'
p47091
aS'                          w_p = evaluate_function('
p47092
aS'                            *inflow_boundaries.find(boundary_id)->second,'
p47093
aS'                            phi_m.quadrature_point(q));'
p47094
aS'                        else if (subsonic_outflow_boundaries.find('
p47095
aS'                                   boundary_id) !='
p47096
aS'                                 subsonic_outflow_boundaries.end())'
p47097
aS'                          {'
p47098
aS'                            w_p = w_m;'
p47099
aS'                            w_p[dim + 1] ='
p47100
aS'                              evaluate_function(*subsonic_outflow_boundaries'
p47101
aS'                                                   .find(boundary_id)'
p47102
aS'                                                   ->second,'
p47103
aS'                                                phi_m.quadrature_point(q),'
p47104
aS'                                                dim + 1);'
p47105
aS'                            at_outflow = true;'
p47106
aS'                          }'
p47107
aS'                        else'
p47108
aS'                          AssertThrow(false,'
p47109
aS'                                      ExcMessage('
p47110
aS'                                        "Unknown boundary id, did "'
p47111
aS'                                        "you set a boundary condition for "'
p47112
aS'                                        "this part of the domain boundary?"));'
p47113
aS'                        auto flux = euler_numerical_flux<dim>(w_m, w_p, normal);'
p47114
aS'                        if (at_outflow)'
p47115
aS'                          for (unsigned int v = 0;'
p47116
aS'                               v < VectorizedArrayType::size();'
p47117
aS'                               ++v)'
p47118
aS'                            {'
p47119
aS'                              if (rho_u_dot_n[v] < -1e-12)'
p47120
aS'                                for (unsigned int d = 0; d < dim; ++d)'
p47121
aS'                                  flux[d + 1][v] = 0.;'
p47122
aS'                            }'
p47123
aS'                        phi_m.submit_value(-flux, q);'
p47124
aS'                      }'
p47125
aS'                  }'
p47126
aS'                internal::FEFaceNormalEvaluationImpl<dim,'
p47127
aS'                                                     n_points_1d - 1,'
p47128
aS'                                                     VectorizedArrayType>::'
p47129
aS'                  template interpolate_quadrature<false, true>('
p47130
aS'                    dim + 2,'
p47131
aS'                    data.get_shape_info(),'
p47132
aS'                    phi_m.begin_values(),'
p47133
aS'                    phi.begin_values(),'
p47134
aS'                    false,'
p47135
aS'                    face);'
p47136
aS'              }'
p47137
aS'            for (unsigned int q = 0; q < phi.static_n_q_points; ++q)'
p47138
aS'              {'
p47139
aS'                const auto factor = VectorizedArrayType(1.0) / phi.JxW(q);'
p47140
aS'                for (unsigned int c = 0; c < dim + 2; ++c)'
p47141
aS'                  phi.begin_values()[c * phi.static_n_q_points + q] ='
p47142
aS'                    phi.begin_values()[c * phi.static_n_q_points + q] * factor;'
p47143
aS'              }'
p47144
aS'            internal::FEEvaluationImplBasisChange<'
p47145
aS'              dealii::internal::EvaluatorVariant::evaluate_evenodd,'
p47146
aS'              internal::EvaluatorQuantity::hessian,'
p47147
aS'              dim,'
p47148
aS'              degree + 1,'
p47149
aS'              n_points_1d,'
p47150
aS'              VectorizedArrayType,'
p47151
aS'              VectorizedArrayType>::do_backward(dim + 2,'
p47152
aS'                                                data.get_shape_info()'
p47153
aS'                                                  .data[0]'
p47154
aS'                                                  .inverse_shape_values_eo,'
p47155
aS'                                                false,'
p47156
aS'                                                phi.begin_values(),'
p47157
aS'                                                phi.begin_dof_values());'
p47158
aS'            if (ai == Number())'
p47159
aS'              {'
p47160
aS'                for (unsigned int q = 0; q < phi.static_dofs_per_cell; ++q)'
p47161
aS'                  phi.begin_dof_values()[q] = bi * phi.begin_dof_values()[q];'
p47162
aS'                phi.distribute_local_to_global(solution);'
p47163
aS'              }'
p47164
aS'            else'
p47165
aS'              {'
p47166
aS'                if (stage != 0)'
p47167
aS'                  phi_temp.read_dof_values(solution);'
p47168
aS'                for (unsigned int q = 0; q < phi.static_dofs_per_cell; ++q)'
p47169
aS'                  {'
p47170
aS'                    const auto K_i = phi.begin_dof_values()[q];'
p47171
aS'                    phi.begin_dof_values()[q] ='
p47172
aS'                      phi_temp.begin_dof_values()[q] + (ai * K_i);'
p47173
aS'                    phi_temp.begin_dof_values()[q] += bi * K_i;'
p47174
aS'                  }'
p47175
aS'                phi.set_dof_values(dst);'
p47176
aS'                phi_temp.set_dof_values(solution);'
p47177
aS'              }'
p47178
aS'          }'
p47179
aS'      },'
p47180
aS'      vec_ki,'
p47181
aS'      current_ri,'
p47182
aS'      true,'
p47183
aS'      MatrixFree<dim, Number, VectorizedArrayType>::DataAccessOnFaces::values);'
p47184
aS'  }'
p47185
aS'  template <int dim, int degree, int n_points_1d>'
p47186
aS'  void EulerOperator<dim, degree, n_points_1d>::initialize_vector('
p47187
aS'    LinearAlgebra::distributed::Vector<Number> &vector) const'
p47188
aS'  {'
p47189
aS'    data.initialize_dof_vector(vector);'
p47190
aS'  }'
p47191
aS'  template <int dim, int degree, int n_points_1d>'
p47192
aS'  void EulerOperator<dim, degree, n_points_1d>::set_inflow_boundary('
p47193
aS'    const types::boundary_id       boundary_id,'
p47194
aS'    std::unique_ptr<Function<dim>> inflow_function)'
p47195
aS'  {'
p47196
aS'    AssertThrow(subsonic_outflow_boundaries.find(boundary_id) =='
p47197
aS'                    subsonic_outflow_boundaries.end() &&'
p47198
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p47199
aS'                ExcMessage("You already set the boundary with id " +'
p47200
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p47201
aS'                           " to another type of boundary before now setting " +'
p47202
aS'                           "it as inflow"));'
p47203
aS'    AssertThrow(inflow_function->n_components == dim + 2,'
p47204
aS'                ExcMessage("Expected function with dim+2 components"));'
p47205
aS'    inflow_boundaries[boundary_id] = std::move(inflow_function);'
p47206
aS'  }'
p47207
aS'  template <int dim, int degree, int n_points_1d>'
p47208
aS'  void EulerOperator<dim, degree, n_points_1d>::set_subsonic_outflow_boundary('
p47209
aS'    const types::boundary_id       boundary_id,'
p47210
aS'    std::unique_ptr<Function<dim>> outflow_function)'
p47211
aS'  {'
p47212
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p47213
aS'                    inflow_boundaries.end() &&'
p47214
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p47215
aS'                ExcMessage("You already set the boundary with id " +'
p47216
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p47217
aS'                           " to another type of boundary before now setting " +'
p47218
aS'                           "it as subsonic outflow"));'
p47219
aS'    AssertThrow(outflow_function->n_components == dim + 2,'
p47220
aS'                ExcMessage("Expected function with dim+2 components"));'
p47221
aS'    subsonic_outflow_boundaries[boundary_id] = std::move(outflow_function);'
p47222
aS'  }'
p47223
aS'  template <int dim, int degree, int n_points_1d>'
p47224
aS'  void EulerOperator<dim, degree, n_points_1d>::set_wall_boundary('
p47225
aS'    const types::boundary_id boundary_id)'
p47226
aS'  {'
p47227
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p47228
aS'                    inflow_boundaries.end() &&'
p47229
aS'                  subsonic_outflow_boundaries.find(boundary_id) =='
p47230
aS'                    subsonic_outflow_boundaries.end(),'
p47231
aS'                ExcMessage("You already set the boundary with id " +'
p47232
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p47233
aS'                           " to another type of boundary before now setting " +'
p47234
aS'                           "it as wall boundary"));'
p47235
aS'    wall_boundaries.insert(boundary_id);'
p47236
aS'  }'
p47237
aS'  template <int dim, int degree, int n_points_1d>'
p47238
aS'  void EulerOperator<dim, degree, n_points_1d>::set_body_force('
p47239
aS'    std::unique_ptr<Function<dim>> body_force)'
p47240
aS'  {'
p47241
aS'    AssertDimension(body_force->n_components, dim);'
p47242
aS'    this->body_force = std::move(body_force);'
p47243
aS'  }'
p47244
aS'  template <int dim, int degree, int n_points_1d>'
p47245
aS'  void EulerOperator<dim, degree, n_points_1d>::project('
p47246
aS'    const Function<dim> &                       function,'
p47247
aS'    LinearAlgebra::distributed::Vector<Number> &solution) const'
p47248
aS'  {'
p47249
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number, VectorizedArrayType>'
p47250
aS'      phi(data, 0, 1);'
p47251
aS'    MatrixFreeOperators::CellwiseInverseMassMatrix<dim,'
p47252
aS'                                                   degree,'
p47253
aS'                                                   dim + 2,'
p47254
aS'                                                   Number,'
p47255
aS'                                                   VectorizedArrayType>'
p47256
aS'      inverse(phi);'
p47257
aS'    solution.zero_out_ghost_values();'
p47258
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p47259
aS'      {'
p47260
aS'        phi.reinit(cell);'
p47261
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p47262
aS'          phi.submit_dof_value(evaluate_function(function,'
p47263
aS'                                                 phi.quadrature_point(q)),'
p47264
aS'                               q);'
p47265
aS'        inverse.transform_from_q_points_to_basis(dim + 2,'
p47266
aS'                                                 phi.begin_dof_values(),'
p47267
aS'                                                 phi.begin_dof_values());'
p47268
aS'        phi.set_dof_values(solution);'
p47269
aS'      }'
p47270
aS'  }'
p47271
aS'  template <int dim, int degree, int n_points_1d>'
p47272
aS'  std::array<double, 3> EulerOperator<dim, degree, n_points_1d>::compute_errors('
p47273
aS'    const Function<dim> &                             function,'
p47274
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p47275
aS'  {'
p47276
aS'    TimerOutput::Scope t(timer, "compute errors");'
p47277
aS'    double             errors_squared[3] = {};'
p47278
aS'    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number, VectorizedArrayType>'
p47279
aS'      phi(data, 0, 0);'
p47280
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p47281
aS'      {'
p47282
aS'        phi.reinit(cell);'
p47283
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p47284
aS'        VectorizedArrayType local_errors_squared[3] = {};'
p47285
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p47286
aS'          {'
p47287
aS'            const auto error ='
p47288
aS'              evaluate_function(function, phi.quadrature_point(q)) -'
p47289
aS'              phi.get_value(q);'
p47290
aS'            const auto JxW = phi.JxW(q);'
p47291
aS'            local_errors_squared[0] += error[0] * error[0] * JxW;'
p47292
aS'            for (unsigned int d = 0; d < dim; ++d)'
p47293
aS'              local_errors_squared[1] += (error[d + 1] * error[d + 1]) * JxW;'
p47294
aS'            local_errors_squared[2] += (error[dim + 1] * error[dim + 1]) * JxW;'
p47295
aS'          }'
p47296
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p47297
aS'             ++v)'
p47298
aS'          for (unsigned int d = 0; d < 3; ++d)'
p47299
aS'            errors_squared[d] += local_errors_squared[d][v];'
p47300
aS'      }'
p47301
aS'    Utilities::MPI::sum(errors_squared, MPI_COMM_WORLD, errors_squared);'
p47302
aS'    std::array<double, 3> errors;'
p47303
aS'    for (unsigned int d = 0; d < 3; ++d)'
p47304
aS'      errors[d] = std::sqrt(errors_squared[d]);'
p47305
aS'    return errors;'
p47306
aS'  }'
p47307
aS'  template <int dim, int degree, int n_points_1d>'
p47308
aS'  double EulerOperator<dim, degree, n_points_1d>::compute_cell_transport_speed('
p47309
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p47310
aS'  {'
p47311
aS'    TimerOutput::Scope t(timer, "compute transport speed");'
p47312
aS'    Number             max_transport = 0;'
p47313
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number, VectorizedArrayType>'
p47314
aS'      phi(data, 0, 1);'
p47315
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p47316
aS'      {'
p47317
aS'        phi.reinit(cell);'
p47318
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p47319
aS'        VectorizedArrayType local_max = 0.;'
p47320
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p47321
aS'          {'
p47322
aS'            const auto solution = phi.get_value(q);'
p47323
aS'            const auto velocity = euler_velocity<dim>(solution);'
p47324
aS'            const auto pressure = euler_pressure<dim>(solution);'
p47325
aS'            const auto          inverse_jacobian = phi.inverse_jacobian(q);'
p47326
aS'            const auto          convective_speed = inverse_jacobian * velocity;'
p47327
aS'            VectorizedArrayType convective_limit = 0.;'
p47328
aS'            for (unsigned int d = 0; d < dim; ++d)'
p47329
aS'              convective_limit ='
p47330
aS'                std::max(convective_limit, std::abs(convective_speed[d]));'
p47331
aS'            const auto speed_of_sound ='
p47332
aS'              std::sqrt(gamma * pressure * (1. / solution[0]));'
p47333
aS'            Tensor<1, dim, VectorizedArrayType> eigenvector;'
p47334
aS'            for (unsigned int d = 0; d < dim; ++d)'
p47335
aS'              eigenvector[d] = 1.;'
p47336
aS'            for (unsigned int i = 0; i < 5; ++i)'
p47337
aS'              {'
p47338
aS'                eigenvector = transpose(inverse_jacobian) *'
p47339
aS'                              (inverse_jacobian * eigenvector);'
p47340
aS'                VectorizedArrayType eigenvector_norm = 0.;'
p47341
aS'                for (unsigned int d = 0; d < dim; ++d)'
p47342
aS'                  eigenvector_norm ='
p47343
aS'                    std::max(eigenvector_norm, std::abs(eigenvector[d]));'
p47344
aS'                eigenvector /= eigenvector_norm;'
p47345
aS'              }'
p47346
aS'            const auto jac_times_ev   = inverse_jacobian * eigenvector;'
p47347
aS'            const auto max_eigenvalue = std::sqrt('
p47348
aS'              (jac_times_ev * jac_times_ev) / (eigenvector * eigenvector));'
p47349
aS'            local_max ='
p47350
aS'              std::max(local_max,'
p47351
aS'                       max_eigenvalue * speed_of_sound + convective_limit);'
p47352
aS'          }'
p47353
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p47354
aS'             ++v)'
p47355
aS'          for (unsigned int d = 0; d < 3; ++d)'
p47356
aS'            max_transport = std::max(max_transport, local_max[v]);'
p47357
aS'      }'
p47358
aS'    max_transport = Utilities::MPI::max(max_transport, MPI_COMM_WORLD);'
p47359
aS'    return max_transport;'
p47360
aS'  }'
p47361
aS'  template <int dim>'
p47362
aS'  class EulerProblem'
p47363
aS'  {'
p47364
aS'  public:'
p47365
aS'    EulerProblem();'
p47366
aS'    void run();'
p47367
aS'  private:'
p47368
aS'    void make_grid_and_dofs();'
p47369
aS'    void output_results(const unsigned int result_number);'
p47370
aS'    LinearAlgebra::distributed::Vector<Number> solution;'
p47371
aS'    ConditionalOStream pcout;'
p47372
aS'#ifdef DEAL_II_WITH_P4EST'
p47373
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p47374
aS'#else'
p47375
aS'    Triangulation<dim> triangulation;'
p47376
aS'#endif'
p47377
aS'    FESystem<dim>        fe;'
p47378
aS'    MappingQGeneric<dim> mapping;'
p47379
aS'    DoFHandler<dim>      dof_handler;'
p47380
aS'    TimerOutput timer;'
p47381
aS'    EulerOperator<dim, fe_degree, n_q_points_1d> euler_operator;'
p47382
aS'    double time, time_step;'
p47383
aS'    class Postprocessor : public DataPostprocessor<dim>'
p47384
aS'    {'
p47385
aS'    public:'
p47386
aS'      Postprocessor();'
p47387
aS'      virtual void evaluate_vector_field('
p47388
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p47389
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p47390
aS'      virtual std::vector<std::string> get_names() const override;'
p47391
aS'      virtual std::vector<'
p47392
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p47393
aS'      get_data_component_interpretation() const override;'
p47394
aS'      virtual UpdateFlags get_needed_update_flags() const override;'
p47395
aS'    private:'
p47396
aS'      const bool do_schlieren_plot;'
p47397
aS'    };'
p47398
aS'  };'
p47399
aS'  template <int dim>'
p47400
aS'  EulerProblem<dim>::Postprocessor::Postprocessor()'
p47401
aS'    : do_schlieren_plot(dim == 2)'
p47402
aS'  {}'
p47403
aS'  template <int dim>'
p47404
aS'  void EulerProblem<dim>::Postprocessor::evaluate_vector_field('
p47405
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p47406
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p47407
aS'  {'
p47408
aS'    const unsigned int n_evaluation_points = inputs.solution_values.size();'
p47409
aS'    if (do_schlieren_plot == true)'
p47410
aS'      Assert(inputs.solution_gradients.size() == n_evaluation_points,'
p47411
aS'             ExcInternalError());'
p47412
aS'    Assert(computed_quantities.size() == n_evaluation_points,'
p47413
aS'           ExcInternalError());'
p47414
aS'    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError());'
p47415
aS'    Assert(computed_quantities[0].size() =='
p47416
aS'             dim + 2 + (do_schlieren_plot == true ? 1 : 0),'
p47417
aS'           ExcInternalError());'
p47418
aS'    for (unsigned int q = 0; q < n_evaluation_points; ++q)'
p47419
aS'      {'
p47420
aS'        Tensor<1, dim + 2> solution;'
p47421
aS'        for (unsigned int d = 0; d < dim + 2; ++d)'
p47422
aS'          solution[d] = inputs.solution_values[q](d);'
p47423
aS'        const double         density  = solution[0];'
p47424
aS'        const Tensor<1, dim> velocity = euler_velocity<dim>(solution);'
p47425
aS'        const double         pressure = euler_pressure<dim>(solution);'
p47426
aS'        for (unsigned int d = 0; d < dim; ++d)'
p47427
aS'          computed_quantities[q](d) = velocity[d];'
p47428
aS'        computed_quantities[q](dim)     = pressure;'
p47429
aS'        computed_quantities[q](dim + 1) = std::sqrt(gamma * pressure / density);'
p47430
aS'        if (do_schlieren_plot == true)'
p47431
aS'          computed_quantities[q](dim + 2) ='
p47432
aS'            inputs.solution_gradients[q][0] * inputs.solution_gradients[q][0];'
p47433
aS'      }'
p47434
aS'  }'
p47435
aS'  template <int dim>'
p47436
aS'  std::vector<std::string> EulerProblem<dim>::Postprocessor::get_names() const'
p47437
aS'  {'
p47438
aS'    std::vector<std::string> names;'
p47439
aS'    for (unsigned int d = 0; d < dim; ++d)'
p47440
aS'      names.emplace_back("velocity");'
p47441
aS'    names.emplace_back("pressure");'
p47442
aS'    names.emplace_back("speed_of_sound");'
p47443
aS'    if (do_schlieren_plot == true)'
p47444
aS'      names.emplace_back("schlieren_plot");'
p47445
aS'    return names;'
p47446
aS'  }'
p47447
aS'  template <int dim>'
p47448
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p47449
aS'  EulerProblem<dim>::Postprocessor::get_data_component_interpretation() const'
p47450
aS'  {'
p47451
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p47452
aS'      interpretation;'
p47453
aS'    for (unsigned int d = 0; d < dim; ++d)'
p47454
aS'      interpretation.push_back('
p47455
aS'        DataComponentInterpretation::component_is_part_of_vector);'
p47456
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p47457
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p47458
aS'    if (do_schlieren_plot == true)'
p47459
aS'      interpretation.push_back('
p47460
aS'        DataComponentInterpretation::component_is_scalar);'
p47461
aS'    return interpretation;'
p47462
aS'  }'
p47463
aS'  template <int dim>'
p47464
aS'  UpdateFlags EulerProblem<dim>::Postprocessor::get_needed_update_flags() const'
p47465
aS'  {'
p47466
aS'    if (do_schlieren_plot == true)'
p47467
aS'      return update_values | update_gradients;'
p47468
aS'    else'
p47469
aS'      return update_values;'
p47470
aS'  }'
p47471
aS'  template <int dim>'
p47472
aS'  EulerProblem<dim>::EulerProblem()'
p47473
aS'    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p47474
aS'#ifdef DEAL_II_WITH_P4EST'
p47475
aS'    , triangulation(MPI_COMM_WORLD)'
p47476
aS'#endif'
p47477
aS'    , fe(FE_DGQ<dim>(fe_degree), dim + 2)'
p47478
aS'    , mapping(fe_degree)'
p47479
aS'    , dof_handler(triangulation)'
p47480
aS'    , timer(pcout, TimerOutput::never, TimerOutput::wall_times)'
p47481
aS'    , euler_operator(timer)'
p47482
aS'    , time(0)'
p47483
aS'    , time_step(0)'
p47484
aS'  {}'
p47485
aS'  template <int dim>'
p47486
aS'  void EulerProblem<dim>::make_grid_and_dofs()'
p47487
aS'  {'
p47488
aS'    switch (testcase)'
p47489
aS'      {'
p47490
aS'        case 0:'
p47491
aS'          {'
p47492
aS'            Point<dim> lower_left;'
p47493
aS'            for (unsigned int d = 1; d < dim; ++d)'
p47494
aS'              lower_left[d] = -5;'
p47495
aS'            Point<dim> upper_right;'
p47496
aS'            upper_right[0] = 10;'
p47497
aS'            for (unsigned int d = 1; d < dim; ++d)'
p47498
aS'              upper_right[d] = 5;'
p47499
aS'            GridGenerator::hyper_rectangle(triangulation,'
p47500
aS'                                           lower_left,'
p47501
aS'                                           upper_right);'
p47502
aS'            triangulation.refine_global(2);'
p47503
aS'            euler_operator.set_inflow_boundary('
p47504
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p47505
aS'            break;'
p47506
aS'          }'
p47507
aS'        case 1:'
p47508
aS'          {'
p47509
aS'            GridGenerator::channel_with_cylinder('
p47510
aS'              triangulation, 0.03, 1, 0, true);'
p47511
aS'            euler_operator.set_inflow_boundary('
p47512
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p47513
aS'            euler_operator.set_subsonic_outflow_boundary('
p47514
aS'              1, std::make_unique<ExactSolution<dim>>(0));'
p47515
aS'            euler_operator.set_wall_boundary(2);'
p47516
aS'            euler_operator.set_wall_boundary(3);'
p47517
aS'            if (dim == 3)'
p47518
aS'              euler_operator.set_body_force('
p47519
aS'                std::make_unique<Functions::ConstantFunction<dim>>('
p47520
aS'                  std::vector<double>({0., 0., -0.2})));'
p47521
aS'            break;'
p47522
aS'          }'
p47523
aS'        default:'
p47524
aS'          Assert(false, ExcNotImplemented());'
p47525
aS'      }'
p47526
aS'    triangulation.refine_global(n_global_refinements);'
p47527
aS'    dof_handler.distribute_dofs(fe);'
p47528
aS'    euler_operator.reinit(mapping, dof_handler);'
p47529
aS'    euler_operator.initialize_vector(solution);'
p47530
aS'    std::locale s = pcout.get_stream().getloc();'
p47531
aS'    pcout.get_stream().imbue(std::locale(""));'
p47532
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p47533
aS'          << " ( = " << (dim + 2) << " [vars] x "'
p47534
aS'          << triangulation.n_global_active_cells() << " [cells] x "'
p47535
aS'          << Utilities::pow(fe_degree + 1, dim) << " [dofs/cell/var] )"'
p47536
aS'          << std::endl;'
p47537
aS'    pcout.get_stream().imbue(s);'
p47538
aS'  }'
p47539
aS'  template <int dim>'
p47540
aS'  void EulerProblem<dim>::output_results(const unsigned int result_number)'
p47541
aS'  {'
p47542
aS'    const std::array<double, 3> errors ='
p47543
aS'      euler_operator.compute_errors(ExactSolution<dim>(time), solution);'
p47544
aS'    const std::string quantity_name = testcase == 0 ? "error" : "norm";'
p47545
aS'    pcout << "Time:" << std::setw(8) << std::setprecision(3) << time'
p47546
aS'          << ", dt: " << std::setw(8) << std::setprecision(2) << time_step'
p47547
aS'          << ", " << quantity_name << " rho: " << std::setprecision(4)'
p47548
aS'          << std::setw(10) << errors[0] << ", rho * u: " << std::setprecision(4)'
p47549
aS'          << std::setw(10) << errors[1] << ", energy:" << std::setprecision(4)'
p47550
aS'          << std::setw(10) << errors[2] << std::endl;'
p47551
aS'    {'
p47552
aS'      TimerOutput::Scope t(timer, "output");'
p47553
aS'      Postprocessor postprocessor;'
p47554
aS'      DataOut<dim>  data_out;'
p47555
aS'      DataOutBase::VtkFlags flags;'
p47556
aS'      flags.write_higher_order_cells = true;'
p47557
aS'      data_out.set_flags(flags);'
p47558
aS'      data_out.attach_dof_handler(dof_handler);'
p47559
aS'      {'
p47560
aS'        std::vector<std::string> names;'
p47561
aS'        names.emplace_back("density");'
p47562
aS'        for (unsigned int d = 0; d < dim; ++d)'
p47563
aS'          names.emplace_back("momentum");'
p47564
aS'        names.emplace_back("energy");'
p47565
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p47566
aS'          interpretation;'
p47567
aS'        interpretation.push_back('
p47568
aS'          DataComponentInterpretation::component_is_scalar);'
p47569
aS'        for (unsigned int d = 0; d < dim; ++d)'
p47570
aS'          interpretation.push_back('
p47571
aS'            DataComponentInterpretation::component_is_part_of_vector);'
p47572
aS'        interpretation.push_back('
p47573
aS'          DataComponentInterpretation::component_is_scalar);'
p47574
aS'        data_out.add_data_vector(dof_handler, solution, names, interpretation);'
p47575
aS'      }'
p47576
aS'      data_out.add_data_vector(solution, postprocessor);'
p47577
aS'      LinearAlgebra::distributed::Vector<Number> reference;'
p47578
aS'      if (testcase == 0 && dim == 2)'
p47579
aS'        {'
p47580
aS'          reference.reinit(solution);'
p47581
aS'          euler_operator.project(ExactSolution<dim>(time), reference);'
p47582
aS'          reference.sadd(-1., 1, solution);'
p47583
aS'          std::vector<std::string> names;'
p47584
aS'          names.emplace_back("error_density");'
p47585
aS'          for (unsigned int d = 0; d < dim; ++d)'
p47586
aS'            names.emplace_back("error_momentum");'
p47587
aS'          names.emplace_back("error_energy");'
p47588
aS'          std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p47589
aS'            interpretation;'
p47590
aS'          interpretation.push_back('
p47591
aS'            DataComponentInterpretation::component_is_scalar);'
p47592
aS'          for (unsigned int d = 0; d < dim; ++d)'
p47593
aS'            interpretation.push_back('
p47594
aS'              DataComponentInterpretation::component_is_part_of_vector);'
p47595
aS'          interpretation.push_back('
p47596
aS'            DataComponentInterpretation::component_is_scalar);'
p47597
aS'          data_out.add_data_vector(dof_handler,'
p47598
aS'                                   reference,'
p47599
aS'                                   names,'
p47600
aS'                                   interpretation);'
p47601
aS'        }'
p47602
aS'      Vector<double> mpi_owner(triangulation.n_active_cells());'
p47603
aS'      mpi_owner = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);'
p47604
aS'      data_out.add_data_vector(mpi_owner, "owner");'
p47605
aS'      data_out.build_patches(mapping,'
p47606
aS'                             fe.degree,'
p47607
aS'                             DataOut<dim>::curved_inner_cells);'
p47608
aS'      const std::string filename ='
p47609
aS'        "solution_" + Utilities::int_to_string(result_number, 3) + ".vtu";'
p47610
aS'      data_out.write_vtu_in_parallel(filename, MPI_COMM_WORLD);'
p47611
aS'    }'
p47612
aS'  }'
p47613
aS'  template <int dim>'
p47614
aS'  void EulerProblem<dim>::run()'
p47615
aS'  {'
p47616
aS'    {'
p47617
aS'      const unsigned int n_vect_number = VectorizedArrayType::size();'
p47618
aS'      const unsigned int n_vect_bits   = 8 * sizeof(Number) * n_vect_number;'
p47619
aS'      pcout << "Running with "'
p47620
aS'            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD)'
p47621
aS'            << " MPI processes" << std::endl;'
p47622
aS'      pcout << "Vectorization over " << n_vect_number << " "'
p47623
aS'            << (std::is_same<Number, double>::value ? "doubles" : "floats")'
p47624
aS'            << " = " << n_vect_bits << " bits ("'
p47625
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p47626
aS'            << std::endl;'
p47627
aS'    }'
p47628
aS'    make_grid_and_dofs();'
p47629
aS'    const LowStorageRungeKuttaIntegrator integrator(lsrk_scheme);'
p47630
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_1;'
p47631
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_2;'
p47632
aS'    rk_register_1.reinit(solution);'
p47633
aS'    rk_register_2.reinit(solution);'
p47634
aS'    euler_operator.project(ExactSolution<dim>(time), solution);'
p47635
aS'    double min_vertex_distance = std::numeric_limits<double>::max();'
p47636
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p47637
aS'      if (cell->is_locally_owned())'
p47638
aS'        min_vertex_distance ='
p47639
aS'          std::min(min_vertex_distance, cell->minimum_vertex_distance());'
p47640
aS'    min_vertex_distance ='
p47641
aS'      Utilities::MPI::min(min_vertex_distance, MPI_COMM_WORLD);'
p47642
aS'    time_step = courant_number * integrator.n_stages() /'
p47643
aS'                euler_operator.compute_cell_transport_speed(solution);'
p47644
aS'    pcout << "Time step size: " << time_step'
p47645
aS'          << ", minimal h: " << min_vertex_distance'
p47646
aS'          << ", initial transport scaling: "'
p47647
aS'          << 1. / euler_operator.compute_cell_transport_speed(solution)'
p47648
aS'          << std::endl'
p47649
aS'          << std::endl;'
p47650
aS'    output_results(0);'
p47651
aS'    unsigned int timestep_number = 0;'
p47652
aS'    while (time < final_time - 1e-12 && timestep_number < max_time_steps)'
p47653
aS'      {'
p47654
aS'        ++timestep_number;'
p47655
aS'        if (timestep_number % 5 == 0)'
p47656
aS'          time_step ='
p47657
aS'            courant_number * integrator.n_stages() /'
p47658
aS'            Utilities::truncate_to_n_digits('
p47659
aS'              euler_operator.compute_cell_transport_speed(solution), 3);'
p47660
aS'        {'
p47661
aS'          TimerOutput::Scope t(timer, "rk time stepping total");'
p47662
aS'          integrator.perform_time_step(euler_operator,'
p47663
aS'                                       time,'
p47664
aS'                                       time_step,'
p47665
aS'                                       solution,'
p47666
aS'                                       rk_register_1,'
p47667
aS'                                       rk_register_2);'
p47668
aS'        }'
p47669
aS'        time += time_step;'
p47670
aS'        if (static_cast<int>(time / output_tick) !='
p47671
aS'              static_cast<int>((time - time_step) / output_tick) ||'
p47672
aS'            time >= final_time - 1e-12)'
p47673
aS'          output_results('
p47674
aS'            static_cast<unsigned int>(std::round(time / output_tick)));'
p47675
aS'      }'
p47676
aS'    timer.print_wall_time_statistics(MPI_COMM_WORLD);'
p47677
aS'    pcout << std::endl;'
p47678
aS'  }'
p47679
aS'} // namespace Euler_DG'
p47680
aS'int main(int argc, char **argv)'
p47681
ag24
aS'  using namespace Euler_DG;'
p47682
aS'  using namespace dealii;'
p47683
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p47684
aS'  try'
p47685
aS'    {'
p47686
aS'      deallog.depth_console(0);'
p47687
aS'      EulerProblem<dimension> euler_problem;'
p47688
aS'      euler_problem.run();'
p47689
aS'    }'
p47690
aS'  catch (std::exception &exc)'
p47691
aS'    {'
p47692
aS'      std::cerr << std::endl'
p47693
aS'                << std::endl'
p47694
aS'                << "----------------------------------------------------"'
p47695
aS'                << std::endl;'
p47696
aS'      std::cerr << "Exception on processing: " << std::endl'
p47697
aS'                << exc.what() << std::endl'
p47698
aS'                << "Aborting!" << std::endl'
p47699
aS'                << "----------------------------------------------------"'
p47700
aS'                << std::endl;'
p47701
aS'      return 1;'
p47702
aS'    }'
p47703
aS'  catch (...)'
p47704
aS'    {'
p47705
aS'      std::cerr << std::endl'
p47706
aS'                << std::endl'
p47707
aS'                << "----------------------------------------------------"'
p47708
aS'                << std::endl;'
p47709
aS'      std::cerr << "Unknown exception!" << std::endl'
p47710
aS'                << "Aborting!" << std::endl'
p47711
aS'                << "----------------------------------------------------"'
p47712
aS'                << std::endl;'
p47713
aS'      return 1;'
p47714
aS'    }'
p47715
aS'  return 0;'
p47716
ag32
aS'/* ---------------------------------------------------------------------'
p47717
aS' *'
p47718
aS' * Copyright (C) 2021 by the deal.II authors'
p47719
aS' *'
p47720
aS' * This file is part of the deal.II library.'
p47721
aS' *'
p47722
aS' * The deal.II library is free software; you can use it, redistribute'
p47723
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p47724
aS' * Public License as published by the Free Software Foundation; either'
p47725
aS' * version 2.1 of the License, or (at your option) any later version.'
p47726
aS' * The full text of the license can be found in the file LICENSE.md at'
p47727
aS' * the top level directory of deal.II.'
p47728
aS' *'
p47729
aS' * ---------------------------------------------------------------------'
p47730
aS' *'
p47731
aS' * Author: Wolfgang Bangerth, Colorado State University, 2021.'
p47732
aS' * Based on step-15 by Sven Wetterauer, University of Heidelberg, 2012.'
p47733
aS' */'
p47734
aS'#include <deal.II/base/quadrature_lib.h>'
p47735
aS'#include <deal.II/base/function.h>'
p47736
aS'#include <deal.II/base/timer.h>'
p47737
aS'#include <deal.II/base/utilities.h>'
p47738
aS'#include <deal.II/lac/vector.h>'
p47739
aS'#include <deal.II/lac/full_matrix.h>'
p47740
aS'#include <deal.II/lac/sparse_matrix.h>'
p47741
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p47742
aS'#include <deal.II/lac/affine_constraints.h>'
p47743
aS'#include <deal.II/lac/sparse_direct.h>'
p47744
aS'#include <deal.II/grid/tria.h>'
p47745
aS'#include <deal.II/grid/grid_generator.h>'
p47746
aS'#include <deal.II/grid/grid_refinement.h>'
p47747
aS'#include <deal.II/dofs/dof_handler.h>'
p47748
aS'#include <deal.II/dofs/dof_accessor.h>'
p47749
aS'#include <deal.II/dofs/dof_tools.h>'
p47750
aS'#include <deal.II/fe/fe_values.h>'
p47751
aS'#include <deal.II/fe/fe_q.h>'
p47752
aS'#include <deal.II/numerics/vector_tools.h>'
p47753
aS'#include <deal.II/numerics/matrix_tools.h>'
p47754
aS'#include <deal.II/numerics/data_out.h>'
p47755
aS'#include <deal.II/numerics/error_estimator.h>'
p47756
aS'#include <deal.II/numerics/solution_transfer.h>'
p47757
aS'#include <deal.II/sundials/kinsol.h>'
p47758
aS'#include <fstream>'
p47759
aS'#include <iostream>'
p47760
aS'namespace Step77'
p47761
ag24
aS'  using namespace dealii;'
p47762
aS'  template <int dim>'
p47763
aS'  class MinimalSurfaceProblem'
p47764
aS'  {'
p47765
aS'  public:'
p47766
aS'    MinimalSurfaceProblem();'
p47767
aS'    void run();'
p47768
aS'  private:'
p47769
aS'    void setup_system(const bool initial_step);'
p47770
aS'    void solve(const Vector<double> &rhs,'
p47771
aS'               Vector<double> &      solution,'
p47772
aS'               const double          tolerance);'
p47773
aS'    void refine_mesh();'
p47774
aS'    void output_results(const unsigned int refinement_cycle);'
p47775
aS'    void set_boundary_values();'
p47776
aS'    void compute_and_factorize_jacobian(const Vector<double> &evaluation_point);'
p47777
aS'    void compute_residual(const Vector<double> &evaluation_point,'
p47778
aS'                          Vector<double> &      residual);'
p47779
aS'    Triangulation<dim> triangulation;'
p47780
aS'    DoFHandler<dim> dof_handler;'
p47781
aS'    FE_Q<dim>       fe;'
p47782
aS'    AffineConstraints<double> hanging_node_constraints;'
p47783
aS'    SparsityPattern                      sparsity_pattern;'
p47784
aS'    SparseMatrix<double>                 jacobian_matrix;'
p47785
aS'    std::unique_ptr<SparseDirectUMFPACK> jacobian_matrix_factorization;'
p47786
aS'    Vector<double> current_solution;'
p47787
aS'    TimerOutput computing_timer;'
p47788
aS'  };'
p47789
aS'  template <int dim>'
p47790
aS'  class BoundaryValues : public Function<dim>'
p47791
aS'  {'
p47792
aS'  public:'
p47793
aS'    virtual double value(const Point<dim> & p,'
p47794
aS'                         const unsigned int component = 0) const override;'
p47795
aS'  };'
p47796
aS'  template <int dim>'
p47797
aS'  double BoundaryValues<dim>::value(const Point<dim> &p,'
p47798
aS'                                    const unsigned int /*component*/) const'
p47799
aS'  {'
p47800
aS'    return std::sin(2 * numbers::PI * (p[0] + p[1]));'
p47801
aS'  }'
p47802
aS'  template <int dim>'
p47803
aS'  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()'
p47804
aS'    : dof_handler(triangulation)'
p47805
aS'    , fe(1)'
p47806
aS'    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times)'
p47807
aS'  {}'
p47808
aS'  template <int dim>'
p47809
aS'  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step)'
p47810
aS'  {'
p47811
aS'    TimerOutput::Scope t(computing_timer, "set up");'
p47812
aS'    if (initial_step)'
p47813
aS'      {'
p47814
aS'        dof_handler.distribute_dofs(fe);'
p47815
aS'        current_solution.reinit(dof_handler.n_dofs());'
p47816
aS'        hanging_node_constraints.clear();'
p47817
aS'        DoFTools::make_hanging_node_constraints(dof_handler,'
p47818
aS'                                                hanging_node_constraints);'
p47819
aS'        hanging_node_constraints.close();'
p47820
aS'      }'
p47821
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p47822
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p47823
aS'    hanging_node_constraints.condense(dsp);'
p47824
aS'    sparsity_pattern.copy_from(dsp);'
p47825
aS'    jacobian_matrix.reinit(sparsity_pattern);'
p47826
aS'    jacobian_matrix_factorization.reset();'
p47827
aS'  }'
p47828
aS'  template <int dim>'
p47829
aS'  void MinimalSurfaceProblem<dim>::compute_and_factorize_jacobian('
p47830
aS'    const Vector<double> &evaluation_point)'
p47831
aS'  {'
p47832
aS'    {'
p47833
aS'      TimerOutput::Scope t(computing_timer, "assembling the Jacobian");'
p47834
aS'      std::cout << "  Computing Jacobian matrix" << std::endl;'
p47835
aS'      const QGauss<dim> quadrature_formula(fe.degree + 1);'
p47836
aS'      jacobian_matrix = 0;'
p47837
aS'      FEValues<dim> fe_values(fe,'
p47838
aS'                              quadrature_formula,'
p47839
aS'                              update_gradients | update_quadrature_points |'
p47840
aS'                                update_JxW_values);'
p47841
aS'      const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p47842
aS'      const unsigned int n_q_points    = quadrature_formula.size();'
p47843
aS'      FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p47844
aS'      std::vector<Tensor<1, dim>> evaluation_point_gradients(n_q_points);'
p47845
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p47846
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p47847
aS'        {'
p47848
aS'          cell_matrix = 0;'
p47849
aS'          fe_values.reinit(cell);'
p47850
aS'          fe_values.get_function_gradients(evaluation_point,'
p47851
aS'                                           evaluation_point_gradients);'
p47852
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p47853
aS'            {'
p47854
aS'              const double coeff ='
p47855
aS'                1.0 / std::sqrt(1 + evaluation_point_gradients[q] *'
p47856
aS'                                      evaluation_point_gradients[q]);'
p47857
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p47858
aS'                {'
p47859
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p47860
aS'                    cell_matrix(i, j) +='
p47861
aS'                      (((fe_values.shape_grad(i, q)    // ((\\nabla \\phi_i'
p47862
aS'                         * coeff                       //   * a_n'
p47863
aS'                         * fe_values.shape_grad(j, q)) //   * \\nabla \\phi_j)'
p47864
aS'                        -                              //  -'
p47865
aS'                        (fe_values.shape_grad(i, q)    //  (\\nabla \\phi_i'
p47866
aS'                         * coeff * coeff * coeff       //   * a_n^3'
p47867
aS'                         *'
p47868
aS'                         (fe_values.shape_grad(j, q)       //   * (\\nabla \\phi_j'
p47869
aS'                          * evaluation_point_gradients[q]) //      * \\nabla u_n)'
p47870
aS'                         * evaluation_point_gradients[q])) //   * \\nabla u_n)))'
p47871
aS'                       * fe_values.JxW(q));                // * dx'
p47872
aS'                }'
p47873
aS'            }'
p47874
aS'          cell->get_dof_indices(local_dof_indices);'
p47875
aS'          hanging_node_constraints.distribute_local_to_global(cell_matrix,'
p47876
aS'                                                              local_dof_indices,'
p47877
aS'                                                              jacobian_matrix);'
p47878
aS'        }'
p47879
aS'      std::map<types::global_dof_index, double> boundary_values;'
p47880
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p47881
aS'                                               0,'
p47882
aS'                                               Functions::ZeroFunction<dim>(),'
p47883
aS'                                               boundary_values);'
p47884
aS'      Vector<double> dummy_solution(dof_handler.n_dofs());'
p47885
aS'      Vector<double> dummy_rhs(dof_handler.n_dofs());'
p47886
aS'      MatrixTools::apply_boundary_values(boundary_values,'
p47887
aS'                                         jacobian_matrix,'
p47888
aS'                                         dummy_solution,'
p47889
aS'                                         dummy_rhs);'
p47890
aS'    }'
p47891
aS'    {'
p47892
aS'      TimerOutput::Scope t(computing_timer, "factorizing the Jacobian");'
p47893
aS'      std::cout << "  Factorizing Jacobian matrix" << std::endl;'
p47894
aS'      jacobian_matrix_factorization = std::make_unique<SparseDirectUMFPACK>();'
p47895
aS'      jacobian_matrix_factorization->factorize(jacobian_matrix);'
p47896
aS'    }'
p47897
aS'  }'
p47898
aS'  template <int dim>'
p47899
aS'  void MinimalSurfaceProblem<dim>::compute_residual('
p47900
aS'    const Vector<double> &evaluation_point,'
p47901
aS'    Vector<double> &      residual)'
p47902
aS'  {'
p47903
aS'    TimerOutput::Scope t(computing_timer, "assembling the residual");'
p47904
aS'    std::cout << "  Computing residual vector..." << std::flush;'
p47905
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p47906
aS'    FEValues<dim>     fe_values(fe,'
p47907
aS'                            quadrature_formula,'
p47908
aS'                            update_gradients | update_quadrature_points |'
p47909
aS'                              update_JxW_values);'
p47910
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p47911
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p47912
aS'    Vector<double>              cell_residual(dofs_per_cell);'
p47913
aS'    std::vector<Tensor<1, dim>> evaluation_point_gradients(n_q_points);'
p47914
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p47915
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47916
aS'      {'
p47917
aS'        cell_residual = 0;'
p47918
aS'        fe_values.reinit(cell);'
p47919
aS'        fe_values.get_function_gradients(evaluation_point,'
p47920
aS'                                         evaluation_point_gradients);'
p47921
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p47922
aS'          {'
p47923
aS'            const double coeff ='
p47924
aS'              1.0 / std::sqrt(1 + evaluation_point_gradients[q] *'
p47925
aS'                                    evaluation_point_gradients[q]);'
p47926
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p47927
aS'              cell_residual(i) = (fe_values.shape_grad(i, q) // \\nabla \\phi_i'
p47928
aS'                                  * coeff                    // * a_n'
p47929
aS'                                  * evaluation_point_gradients[q] // * u_n'
p47930
aS'                                  * fe_values.JxW(q));            // * dx'
p47931
aS'          }'
p47932
aS'        cell->get_dof_indices(local_dof_indices);'
p47933
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p47934
aS'          residual(local_dof_indices[i]) += cell_residual(i);'
p47935
aS'      }'
p47936
aS'    hanging_node_constraints.condense(residual);'
p47937
aS'    for (const types::global_dof_index i :'
p47938
aS'         DoFTools::extract_boundary_dofs(dof_handler))'
p47939
aS'      residual(i) = 0;'
p47940
aS'    for (const types::global_dof_index i :'
p47941
aS'         DoFTools::extract_hanging_node_dofs(dof_handler))'
p47942
aS'      residual(i) = 0;'
p47943
aS'    std::cout << " norm=" << residual.l2_norm() << std::endl;'
p47944
aS'  }'
p47945
aS'  template <int dim>'
p47946
aS'  void MinimalSurfaceProblem<dim>::solve(const Vector<double> &rhs,'
p47947
aS'                                         Vector<double> &      solution,'
p47948
aS'                                         const double /*tolerance*/)'
p47949
aS'  {'
p47950
aS'    TimerOutput::Scope t(computing_timer, "linear system solve");'
p47951
aS'    std::cout << "  Solving linear system" << std::endl;'
p47952
aS'    jacobian_matrix_factorization->vmult(solution, rhs);'
p47953
aS'    hanging_node_constraints.distribute(solution);'
p47954
aS'  }'
p47955
aS'  template <int dim>'
p47956
aS'  void MinimalSurfaceProblem<dim>::refine_mesh()'
p47957
aS'  {'
p47958
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p47959
aS'    KellyErrorEstimator<dim>::estimate('
p47960
aS'      dof_handler,'
p47961
aS'      QGauss<dim - 1>(fe.degree + 1),'
p47962
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p47963
aS'      current_solution,'
p47964
aS'      estimated_error_per_cell);'
p47965
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p47966
aS'                                                    estimated_error_per_cell,'
p47967
aS'                                                    0.3,'
p47968
aS'                                                    0.03);'
p47969
aS'    triangulation.prepare_coarsening_and_refinement();'
p47970
aS'    SolutionTransfer<dim> solution_transfer(dof_handler);'
p47971
aS'    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);'
p47972
aS'    triangulation.execute_coarsening_and_refinement();'
p47973
aS'    dof_handler.distribute_dofs(fe);'
p47974
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p47975
aS'    solution_transfer.interpolate(current_solution, tmp);'
p47976
aS'    current_solution = std::move(tmp);'
p47977
aS'    hanging_node_constraints.clear();'
p47978
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p47979
aS'                                            hanging_node_constraints);'
p47980
aS'    hanging_node_constraints.close();'
p47981
aS'    hanging_node_constraints.distribute(current_solution);'
p47982
aS'    set_boundary_values();'
p47983
aS'    setup_system(/*initial_step=*/false);'
p47984
aS'  }'
p47985
aS'  template <int dim>'
p47986
aS'  void MinimalSurfaceProblem<dim>::set_boundary_values()'
p47987
aS'  {'
p47988
aS'    std::map<types::global_dof_index, double> boundary_values;'
p47989
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p47990
aS'                                             0,'
p47991
aS'                                             BoundaryValues<dim>(),'
p47992
aS'                                             boundary_values);'
p47993
aS'    for (const auto &boundary_value : boundary_values)'
p47994
aS'      current_solution(boundary_value.first) = boundary_value.second;'
p47995
aS'    hanging_node_constraints.distribute(current_solution);'
p47996
aS'  }'
p47997
aS'  template <int dim>'
p47998
aS'  void MinimalSurfaceProblem<dim>::output_results('
p47999
aS'    const unsigned int refinement_cycle)'
p48000
aS'  {'
p48001
aS'    TimerOutput::Scope t(computing_timer, "graphical output");'
p48002
aS'    DataOut<dim> data_out;'
p48003
aS'    data_out.attach_dof_handler(dof_handler);'
p48004
aS'    data_out.add_data_vector(current_solution, "solution");'
p48005
aS'    data_out.build_patches();'
p48006
aS'    const std::string filename ='
p48007
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu";'
p48008
aS'    std::ofstream output(filename);'
p48009
aS'    data_out.write_vtu(output);'
p48010
aS'  }'
p48011
aS'  template <int dim>'
p48012
aS'  void MinimalSurfaceProblem<dim>::run()'
p48013
aS'  {'
p48014
aS'    GridGenerator::hyper_ball(triangulation);'
p48015
aS'    triangulation.refine_global(2);'
p48016
aS'    setup_system(/*initial_step=*/true);'
p48017
aS'    set_boundary_values();'
p48018
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 6;'
p48019
aS'         ++refinement_cycle)'
p48020
aS'      {'
p48021
aS'        computing_timer.reset();'
p48022
aS'        std::cout << "Mesh refinement step " << refinement_cycle << std::endl;'
p48023
aS'        if (refinement_cycle != 0)'
p48024
aS'          refine_mesh();'
p48025
aS'        const double target_tolerance = 1e-3 * std::pow(0.1, refinement_cycle);'
p48026
aS'        std::cout << "  Target_tolerance: " << target_tolerance << std::endl'
p48027
aS'                  << std::endl;'
p48028
aS'        {'
p48029
aS'          typename SUNDIALS::KINSOL<Vector<double>>::AdditionalData'
p48030
aS'            additional_data;'
p48031
aS'          additional_data.function_tolerance = target_tolerance;'
p48032
aS'          SUNDIALS::KINSOL<Vector<double>> nonlinear_solver(additional_data);'
p48033
aS'          nonlinear_solver.reinit_vector = [&](Vector<double> &x) {'
p48034
aS'            x.reinit(dof_handler.n_dofs());'
p48035
aS'          };'
p48036
aS'          nonlinear_solver.residual ='
p48037
aS'            [&](const Vector<double> &evaluation_point,'
p48038
aS'                Vector<double> &      residual) {'
p48039
aS'              compute_residual(evaluation_point, residual);'
p48040
aS'              return 0;'
p48041
aS'            };'
p48042
aS'          nonlinear_solver.setup_jacobian ='
p48043
aS'            [&](const Vector<double> &current_u,'
p48044
aS'                const Vector<double> & /*current_f*/) {'
p48045
aS'              compute_and_factorize_jacobian(current_u);'
p48046
aS'              return 0;'
p48047
aS'            };'
p48048
aS'          nonlinear_solver.solve_with_jacobian = [&](const Vector<double> &rhs,'
p48049
aS'                                                     Vector<double> &      dst,'
p48050
aS'                                                     const double tolerance) {'
p48051
aS'            this->solve(rhs, dst, tolerance);'
p48052
aS'            return 0;'
p48053
aS'          };'
p48054
aS'          nonlinear_solver.solve(current_solution);'
p48055
aS'        }'
p48056
aS'        output_results(refinement_cycle);'
p48057
aS'        computing_timer.print_summary();'
p48058
aS'        std::cout << std::endl;'
p48059
aS'      }'
p48060
aS'  }'
p48061
aS'} // namespace Step77'
p48062
aS'int main()'
p48063
ag24
aS'  try'
p48064
aS'    {'
p48065
aS'      using namespace Step77;'
p48066
aS'      MinimalSurfaceProblem<2> laplace_problem_2d;'
p48067
aS'      laplace_problem_2d.run();'
p48068
aS'    }'
p48069
aS'  catch (std::exception &exc)'
p48070
aS'    {'
p48071
aS'      std::cerr << std::endl'
p48072
aS'                << std::endl'
p48073
aS'                << "----------------------------------------------------"'
p48074
aS'                << std::endl;'
p48075
aS'      std::cerr << "Exception on processing: " << std::endl'
p48076
aS'                << exc.what() << std::endl'
p48077
aS'                << "Aborting!" << std::endl'
p48078
aS'                << "----------------------------------------------------"'
p48079
aS'                << std::endl;'
p48080
aS'      return 1;'
p48081
aS'    }'
p48082
aS'  catch (...)'
p48083
aS'    {'
p48084
aS'      std::cerr << std::endl'
p48085
aS'                << std::endl'
p48086
aS'                << "----------------------------------------------------"'
p48087
aS'                << std::endl;'
p48088
aS'      std::cerr << "Unknown exception!" << std::endl'
p48089
aS'                << "Aborting!" << std::endl'
p48090
aS'                << "----------------------------------------------------"'
p48091
aS'                << std::endl;'
p48092
aS'      return 1;'
p48093
aS'    }'
p48094
aS'  return 0;'
p48095
ag32
aS'/* ---------------------------------------------------------------------'
p48096
aS' *'
p48097
aS' * Copyright (C) 2021 by the deal.II authors'
p48098
aS' *'
p48099
aS' * This file is part of the deal.II library.'
p48100
aS' *'
p48101
aS' * The deal.II library is free software; you can use it, redistribute'
p48102
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p48103
aS' * Public License as published by the Free Software Foundation; either'
p48104
aS' * version 2.1 of the License, or (at your option) any later version.'
p48105
aS' * The full text of the license can be found in the file LICENSE.md at'
p48106
aS' * the top level directory of deal.II.'
p48107
aS' *'
p48108
aS' * ---------------------------------------------------------------------'
p48109
aS' *'
p48110
aS' * Author: Tyler Anderson, Colorado State University, 2021'
p48111
aS' */'
p48112
aS'#include <deal.II/base/convergence_table.h>'
p48113
aS'#include <deal.II/base/function.h>'
p48114
aS'#include <deal.II/base/logstream.h>'
p48115
aS'#include <deal.II/base/quadrature_lib.h>'
p48116
aS'#include <deal.II/base/utilities.h>'
p48117
aS'#include <deal.II/dofs/dof_handler.h>'
p48118
aS'#include <deal.II/dofs/dof_accessor.h>'
p48119
aS'#include <deal.II/dofs/dof_tools.h>'
p48120
aS'#include <deal.II/fe/fe_q.h>'
p48121
aS'#include <deal.II/fe/fe_values.h>'
p48122
aS'#include <deal.II/grid/grid_generator.h>'
p48123
aS'#include <deal.II/grid/grid_refinement.h>'
p48124
aS'#include <deal.II/grid/grid_out.h>'
p48125
aS'#include <deal.II/grid/tria.h>'
p48126
aS'#include <deal.II/grid/tria_accessor.h>'
p48127
aS'#include <deal.II/grid/tria_iterator.h>'
p48128
aS'#include <deal.II/lac/affine_constraints.h>'
p48129
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p48130
aS'#include <deal.II/lac/full_matrix.h>'
p48131
aS'#include <deal.II/lac/precondition.h>'
p48132
aS'#include <deal.II/lac/sparse_matrix.h>'
p48133
aS'#include <deal.II/lac/solver_cg.h>'
p48134
aS'#include <deal.II/lac/vector.h>'
p48135
aS'#include <deal.II/numerics/data_out.h>'
p48136
aS'#include <deal.II/numerics/data_out_stack.h>'
p48137
aS'#include <deal.II/numerics/error_estimator.h>'
p48138
aS'#include <deal.II/numerics/matrix_tools.h>'
p48139
aS'#include <deal.II/numerics/solution_transfer.h>'
p48140
aS'#include <deal.II/numerics/vector_tools.h>'
p48141
aS'#include <fstream>'
p48142
aS'#include <iostream>'
p48143
aS'namespace BlackScholesSolver'
p48144
ag24
aS'  using namespace dealii;'
p48145
aS'#define MMS'
p48146
aS'  template <int dim>'
p48147
aS'  class Solution : public Function<dim>'
p48148
aS'  {'
p48149
aS'  public:'
p48150
aS'    Solution(const double maturity_time);'
p48151
aS'    virtual double value(const Point<dim> & p,'
p48152
aS'                         const unsigned int component = 0) const override;'
p48153
aS'    virtual Tensor<1, dim>'
p48154
aS'    gradient(const Point<dim> & p,'
p48155
aS'             const unsigned int component = 0) const override;'
p48156
aS'  private:'
p48157
aS'    const double maturity_time;'
p48158
aS'  };'
p48159
aS'  template <int dim>'
p48160
aS'  Solution<dim>::Solution(const double maturity_time)'
p48161
aS'    : maturity_time(maturity_time)'
p48162
aS'  {'
p48163
aS'    Assert(dim == 1, ExcNotImplemented());'
p48164
aS'  }'
p48165
aS'  template <int dim>'
p48166
aS'  double Solution<dim>::value(const Point<dim> & p,'
p48167
aS'                              const unsigned int component) const'
p48168
aS'  {'
p48169
aS'    return -Utilities::fixed_power<2, double>(p(component)) -'
p48170
aS'           Utilities::fixed_power<2, double>(this->get_time()) + 6;'
p48171
aS'  }'
p48172
aS'  template <int dim>'
p48173
aS'  Tensor<1, dim> Solution<dim>::gradient(const Point<dim> & p,'
p48174
aS'                                         const unsigned int component) const'
p48175
aS'  {'
p48176
aS'    return Point<dim>(-2 * p(component));'
p48177
aS'  }'
p48178
aS'  template <int dim>'
p48179
aS'  class InitialConditions : public Function<dim>'
p48180
aS'  {'
p48181
aS'  public:'
p48182
aS'    InitialConditions(const double strike_price);'
p48183
aS'    virtual double value(const Point<dim> & p,'
p48184
aS'                         const unsigned int component = 0) const override;'
p48185
aS'  private:'
p48186
aS'    const double strike_price;'
p48187
aS'  };'
p48188
aS'  template <int dim>'
p48189
aS'  InitialConditions<dim>::InitialConditions(const double strike_price)'
p48190
aS'    : strike_price(strike_price)'
p48191
aS'  {}'
p48192
aS'  template <int dim>'
p48193
aS'  double InitialConditions<dim>::value(const Point<dim> & p,'
p48194
aS'                                       const unsigned int component) const'
p48195
aS'  {'
p48196
aS'#ifdef MMS'
p48197
aS'    return -Utilities::fixed_power<2, double>(p(component)) + 6;'
p48198
aS'#else'
p48199
aS'    return std::max(p(component) - strike_price, 0.);'
p48200
aS'#endif'
p48201
aS'  }'
p48202
aS'  template <int dim>'
p48203
aS'  class LeftBoundaryValues : public Function<dim>'
p48204
aS'  {'
p48205
aS'  public:'
p48206
aS'    virtual double value(const Point<dim> & p,'
p48207
aS'                         const unsigned int component = 0) const override;'
p48208
aS'  };'
p48209
aS'  template <int dim>'
p48210
aS'  double LeftBoundaryValues<dim>::value(const Point<dim> &,'
p48211
aS'                                        const unsigned int /*component*/) const'
p48212
aS'  {'
p48213
aS'#ifdef MMS'
p48214
aS'    return -Utilities::fixed_power<2, double>(this->get_time()) + 6;'
p48215
aS'#else'
p48216
aS'    return 0.;'
p48217
aS'#endif'
p48218
aS'  }'
p48219
aS'  template <int dim>'
p48220
aS'  class RightBoundaryValues : public Function<dim>'
p48221
aS'  {'
p48222
aS'  public:'
p48223
aS'    RightBoundaryValues(const double strike_price, const double interest_rate);'
p48224
aS'    virtual double value(const Point<dim> & p,'
p48225
aS'                         const unsigned int component = 0) const override;'
p48226
aS'  private:'
p48227
aS'    const double strike_price;'
p48228
aS'    const double interest_rate;'
p48229
aS'  };'
p48230
aS'  template <int dim>'
p48231
aS'  RightBoundaryValues<dim>::RightBoundaryValues(const double strike_price,'
p48232
aS'                                                const double interest_rate)'
p48233
aS'    : strike_price(strike_price)'
p48234
aS'    , interest_rate(interest_rate)'
p48235
aS'  {}'
p48236
aS'  template <int dim>'
p48237
aS'  double RightBoundaryValues<dim>::value(const Point<dim> & p,'
p48238
aS'                                         const unsigned int component) const'
p48239
aS'  {'
p48240
aS'#ifdef MMS'
p48241
aS'    return -Utilities::fixed_power<2, double>(p(component)) -'
p48242
aS'           Utilities::fixed_power<2, double>(this->get_time()) + 6;'
p48243
aS'#else'
p48244
aS'    return (p(component) - strike_price) *'
p48245
aS'           exp((-interest_rate) * (this->get_time()));'
p48246
aS'#endif'
p48247
aS'  }'
p48248
aS'  template <int dim>'
p48249
aS'  class RightHandSide : public Function<dim>'
p48250
aS'  {'
p48251
aS'  public:'
p48252
aS'    RightHandSide(const double asset_volatility, const double interest_rate);'
p48253
aS'    virtual double value(const Point<dim> & p,'
p48254
aS'                         const unsigned int component = 0) const override;'
p48255
aS'  private:'
p48256
aS'    const double asset_volatility;'
p48257
aS'    const double interest_rate;'
p48258
aS'  };'
p48259
aS'  template <int dim>'
p48260
aS'  RightHandSide<dim>::RightHandSide(const double asset_volatility,'
p48261
aS'                                    const double interest_rate)'
p48262
aS'    : asset_volatility(asset_volatility)'
p48263
aS'    , interest_rate(interest_rate)'
p48264
aS'  {}'
p48265
aS'  template <int dim>'
p48266
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p48267
aS'                                   const unsigned int component) const'
p48268
aS'  {'
p48269
aS'#ifdef MMS'
p48270
aS'    return 2 * (this->get_time()) -'
p48271
aS'           Utilities::fixed_power<2, double>(asset_volatility * p(component)) -'
p48272
aS'           2 * interest_rate * Utilities::fixed_power<2, double>(p(component)) -'
p48273
aS'           interest_rate *'
p48274
aS'             (-Utilities::fixed_power<2, double>(p(component)) -'
p48275
aS'              Utilities::fixed_power<2, double>(this->get_time()) + 6);'
p48276
aS'#else'
p48277
aS'    (void)p;'
p48278
aS'    (void)component;'
p48279
aS'    return 0.0;'
p48280
aS'#endif'
p48281
aS'  }'
p48282
aS'  template <int dim>'
p48283
aS'  class BlackScholes'
p48284
aS'  {'
p48285
aS'  public:'
p48286
aS'    BlackScholes();'
p48287
aS'    void run();'
p48288
aS'  private:'
p48289
aS'    void setup_system();'
p48290
aS'    void solve_time_step();'
p48291
aS'    void refine_grid();'
p48292
aS'    void process_solution();'
p48293
aS'    void add_results_for_output();'
p48294
aS'    void write_convergence_table();'
p48295
aS'    const double maximum_stock_price;'
p48296
aS'    const double maturity_time;'
p48297
aS'    const double asset_volatility;'
p48298
aS'    const double interest_rate;'
p48299
aS'    const double strike_price;'
p48300
aS'    Triangulation<dim> triangulation;'
p48301
aS'    FE_Q<dim>          fe;'
p48302
aS'    DoFHandler<dim>    dof_handler;'
p48303
aS'    AffineConstraints<double> constraints;'
p48304
aS'    SparsityPattern      sparsity_pattern;'
p48305
aS'    SparseMatrix<double> mass_matrix;'
p48306
aS'    SparseMatrix<double> laplace_matrix;'
p48307
aS'    SparseMatrix<double> a_matrix;'
p48308
aS'    SparseMatrix<double> b_matrix;'
p48309
aS'    SparseMatrix<double> system_matrix;'
p48310
aS'    Vector<double> solution;'
p48311
aS'    Vector<double> system_rhs;'
p48312
aS'    double time;'
p48313
aS'    double time_step;'
p48314
aS'    const double       theta;'
p48315
aS'    const unsigned int n_cycles;'
p48316
aS'    const unsigned int n_time_steps;'
p48317
aS'    DataOutStack<dim>        data_out_stack;'
p48318
aS'    std::vector<std::string> solution_names;'
p48319
aS'    ConvergenceTable convergence_table;'
p48320
aS'  };'
p48321
aS'  template <int dim>'
p48322
aS'  BlackScholes<dim>::BlackScholes()'
p48323
aS'    : maximum_stock_price(1.)'
p48324
aS'    , maturity_time(1.)'
p48325
aS'    , asset_volatility(.2)'
p48326
aS'    , interest_rate(0.05)'
p48327
aS'    , strike_price(0.5)'
p48328
aS'    , fe(1)'
p48329
aS'    , dof_handler(triangulation)'
p48330
aS'    , time(0.0)'
p48331
aS'    , theta(0.5)'
p48332
aS'    , n_cycles(4)'
p48333
aS'    , n_time_steps(5000)'
p48334
aS'  {'
p48335
aS'    Assert(dim == 1, ExcNotImplemented());'
p48336
aS'  }'
p48337
aS'  template <int dim>'
p48338
aS'  void BlackScholes<dim>::setup_system()'
p48339
aS'  {'
p48340
aS'    dof_handler.distribute_dofs(fe);'
p48341
aS'    time_step = maturity_time / n_time_steps;'
p48342
aS'    constraints.clear();'
p48343
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p48344
aS'    constraints.close();'
p48345
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p48346
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p48347
aS'                                    dsp,'
p48348
aS'                                    constraints,'
p48349
aS'    sparsity_pattern.copy_from(dsp);'
p48350
aS'    mass_matrix.reinit(sparsity_pattern);'
p48351
aS'    laplace_matrix.reinit(sparsity_pattern);'
p48352
aS'    a_matrix.reinit(sparsity_pattern);'
p48353
aS'    b_matrix.reinit(sparsity_pattern);'
p48354
aS'    system_matrix.reinit(sparsity_pattern);'
p48355
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p48356
aS'                                      QGauss<dim>(fe.degree + 1),'
p48357
aS'                                      mass_matrix);'
p48358
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p48359
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p48360
aS'    QGauss<dim>        quadrature_formula(fe.degree + 1);'
p48361
aS'    FEValues<dim>      fe_values(fe,'
p48362
aS'                            quadrature_formula,'
p48363
aS'                            update_values | update_gradients |'
p48364
aS'                              update_quadrature_points | update_JxW_values);'
p48365
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p48366
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p48367
aS'      {'
p48368
aS'        cell_matrix = 0.;'
p48369
aS'        fe_values.reinit(cell);'
p48370
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p48371
aS'          {'
p48372
aS'            const double current_coefficient ='
p48373
aS'              fe_values.quadrature_point(q_index).square();'
p48374
aS'            for (const unsigned int i : fe_values.dof_indices())'
p48375
aS'              {'
p48376
aS'                for (const unsigned int j : fe_values.dof_indices())'
p48377
aS'                  cell_matrix(i, j) +='
p48378
aS'                    (current_coefficient *              // (x_q)^2'
p48379
aS'                     fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p48380
aS'                     fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p48381
aS'                     fe_values.JxW(q_index));           // dx'
p48382
aS'              }'
p48383
aS'          }'
p48384
aS'        cell->get_dof_indices(local_dof_indices);'
p48385
aS'        for (const unsigned int i : fe_values.dof_indices())'
p48386
aS'          {'
p48387
aS'            for (const unsigned int j : fe_values.dof_indices())'
p48388
aS'              laplace_matrix.add(local_dof_indices[i],'
p48389
aS'                                 local_dof_indices[j],'
p48390
aS'                                 cell_matrix(i, j));'
p48391
aS'          }'
p48392
aS'      }'
p48393
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p48394
aS'      {'
p48395
aS'        cell_matrix = 0.;'
p48396
aS'        fe_values.reinit(cell);'
p48397
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p48398
aS'          {'
p48399
aS'            const Tensor<1, dim> current_coefficient ='
p48400
aS'              fe_values.quadrature_point(q_index);'
p48401
aS'            for (const unsigned int i : fe_values.dof_indices())'
p48402
aS'              {'
p48403
aS'                for (const unsigned int j : fe_values.dof_indices())'
p48404
aS'                  {'
p48405
aS'                    cell_matrix(i, j) +='
p48406
aS'                      (current_coefficient *               // x_q'
p48407
aS'                       fe_values.shape_grad(i, q_index) *  // grad phi_i(x_q)'
p48408
aS'                       fe_values.shape_value(j, q_index) * // phi_j(x_q)'
p48409
aS'                       fe_values.JxW(q_index));            // dx'
p48410
aS'                  }'
p48411
aS'              }'
p48412
aS'          }'
p48413
aS'        cell->get_dof_indices(local_dof_indices);'
p48414
aS'        for (const unsigned int i : fe_values.dof_indices())'
p48415
aS'          {'
p48416
aS'            for (const unsigned int j : fe_values.dof_indices())'
p48417
aS'              a_matrix.add(local_dof_indices[i],'
p48418
aS'                           local_dof_indices[j],'
p48419
aS'                           cell_matrix(i, j));'
p48420
aS'          }'
p48421
aS'      }'
p48422
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p48423
aS'      {'
p48424
aS'        cell_matrix = 0.;'
p48425
aS'        fe_values.reinit(cell);'
p48426
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p48427
aS'          {'
p48428
aS'            const Tensor<1, dim> current_coefficient ='
p48429
aS'              fe_values.quadrature_point(q_index);'
p48430
aS'            for (const unsigned int i : fe_values.dof_indices())'
p48431
aS'              {'
p48432
aS'                for (const unsigned int j : fe_values.dof_indices())'
p48433
aS'                  cell_matrix(i, j) +='
p48434
aS'                    (current_coefficient *               // x_q'
p48435
aS'                     fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p48436
aS'                     fe_values.shape_grad(j, q_index) *  // grad phi_j(x_q)'
p48437
aS'                     fe_values.JxW(q_index));            // dx'
p48438
aS'              }'
p48439
aS'          }'
p48440
aS'        cell->get_dof_indices(local_dof_indices);'
p48441
aS'        for (const unsigned int i : fe_values.dof_indices())'
p48442
aS'          {'
p48443
aS'            for (const unsigned int j : fe_values.dof_indices())'
p48444
aS'              b_matrix.add(local_dof_indices[i],'
p48445
aS'                           local_dof_indices[j],'
p48446
aS'                           cell_matrix(i, j));'
p48447
aS'          }'
p48448
aS'      }'
p48449
aS'    solution.reinit(dof_handler.n_dofs());'
p48450
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p48451
aS'  }'
p48452
aS'  template <int dim>'
p48453
aS'  void BlackScholes<dim>::solve_time_step()'
p48454
aS'  {'
p48455
aS'    SolverControl                          solver_control(1000, 1e-12);'
p48456
aS'    SolverCG<Vector<double>>               cg(solver_control);'
p48457
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p48458
aS'    preconditioner.initialize(system_matrix, 1.0);'
p48459
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p48460
aS'    constraints.distribute(solution);'
p48461
aS'  }'
p48462
aS'  template <int dim>'
p48463
aS'  void BlackScholes<dim>::add_results_for_output()'
p48464
aS'  {'
p48465
aS'    data_out_stack.new_parameter_value(time, time_step);'
p48466
aS'    data_out_stack.attach_dof_handler(dof_handler);'
p48467
aS'    data_out_stack.add_data_vector(solution, solution_names);'
p48468
aS'    data_out_stack.build_patches(2);'
p48469
aS'    data_out_stack.finish_parameter_value();'
p48470
aS'  }'
p48471
aS'  template <int dim>'
p48472
aS'  void BlackScholes<dim>::refine_grid()'
p48473
aS'  {'
p48474
aS'    triangulation.refine_global(1);'
p48475
aS'  }'
p48476
aS'  template <int dim>'
p48477
aS'  void BlackScholes<dim>::process_solution()'
p48478
aS'  {'
p48479
aS'    Solution<dim> sol(maturity_time);'
p48480
aS'    sol.set_time(time);'
p48481
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p48482
aS'    VectorTools::integrate_difference(dof_handler,'
p48483
aS'                                      solution,'
p48484
aS'                                      sol,'
p48485
aS'                                      difference_per_cell,'
p48486
aS'                                      QGauss<dim>(fe.degree + 1),'
p48487
aS'                                      VectorTools::L2_norm);'
p48488
aS'    const double L2_error ='
p48489
aS'      VectorTools::compute_global_error(triangulation,'
p48490
aS'                                        difference_per_cell,'
p48491
aS'                                        VectorTools::L2_norm);'
p48492
aS'    VectorTools::integrate_difference(dof_handler,'
p48493
aS'                                      solution,'
p48494
aS'                                      sol,'
p48495
aS'                                      difference_per_cell,'
p48496
aS'                                      QGauss<dim>(fe.degree + 1),'
p48497
aS'                                      VectorTools::H1_seminorm);'
p48498
aS'    const double H1_error ='
p48499
aS'      VectorTools::compute_global_error(triangulation,'
p48500
aS'                                        difference_per_cell,'
p48501
aS'                                        VectorTools::H1_seminorm);'
p48502
aS'    const QTrapezoid<1>  q_trapezoid;'
p48503
aS'    const QIterated<dim> q_iterated(q_trapezoid, fe.degree * 2 + 1);'
p48504
aS'    VectorTools::integrate_difference(dof_handler,'
p48505
aS'                                      solution,'
p48506
aS'                                      sol,'
p48507
aS'                                      difference_per_cell,'
p48508
aS'                                      q_iterated,'
p48509
aS'                                      VectorTools::Linfty_norm);'
p48510
aS'    const double Linfty_error ='
p48511
aS'      VectorTools::compute_global_error(triangulation,'
p48512
aS'                                        difference_per_cell,'
p48513
aS'                                        VectorTools::Linfty_norm);'
p48514
aS'    const unsigned int n_active_cells = triangulation.n_active_cells();'
p48515
aS'    const unsigned int n_dofs         = dof_handler.n_dofs();'
p48516
aS'    convergence_table.add_value("cells", n_active_cells);'
p48517
aS'    convergence_table.add_value("dofs", n_dofs);'
p48518
aS'    convergence_table.add_value("L2", L2_error);'
p48519
aS'    convergence_table.add_value("H1", H1_error);'
p48520
aS'    convergence_table.add_value("Linfty", Linfty_error);'
p48521
aS'  }'
p48522
aS'  template <int dim>'
p48523
aS'  void BlackScholes<dim>::write_convergence_table()'
p48524
aS'  {'
p48525
aS'    convergence_table.set_precision("L2", 3);'
p48526
aS'    convergence_table.set_precision("H1", 3);'
p48527
aS'    convergence_table.set_precision("Linfty", 3);'
p48528
aS'    convergence_table.set_scientific("L2", true);'
p48529
aS'    convergence_table.set_scientific("H1", true);'
p48530
aS'    convergence_table.set_scientific("Linfty", true);'
p48531
aS'    convergence_table.set_tex_caption("cells", "\\\\# cells");'
p48532
aS'    convergence_table.set_tex_caption("dofs", "\\\\# dofs");'
p48533
aS'    convergence_table.set_tex_caption("L2", "@f$L^2@f$-error");'
p48534
aS'    convergence_table.set_tex_caption("H1", "@f$H^1@f$-error");'
p48535
aS'    convergence_table.set_tex_caption("Linfty", "@f$L^\\\\infty@f$-error");'
p48536
aS'    convergence_table.set_tex_format("cells", "r");'
p48537
aS'    convergence_table.set_tex_format("dofs", "r");'
p48538
aS'    std::cout << std::endl;'
p48539
aS'    convergence_table.write_text(std::cout);'
p48540
aS'    std::string error_filename = "error";'
p48541
aS'    error_filename += "-global";'
p48542
aS'    error_filename += ".tex";'
p48543
aS'    std::ofstream error_table_file(error_filename);'
p48544
aS'    convergence_table.write_tex(error_table_file);'
p48545
aS'    convergence_table.add_column_to_supercolumn("cells", "n cells");'
p48546
aS'    std::vector<std::string> new_order;'
p48547
aS'    new_order.emplace_back("n cells");'
p48548
aS'    new_order.emplace_back("H1");'
p48549
aS'    new_order.emplace_back("L2");'
p48550
aS'    convergence_table.set_column_order(new_order);'
p48551
aS'    convergence_table.evaluate_convergence_rates('
p48552
aS'      "L2", ConvergenceTable::reduction_rate);'
p48553
aS'    convergence_table.evaluate_convergence_rates('
p48554
aS'      "L2", ConvergenceTable::reduction_rate_log2);'
p48555
aS'    convergence_table.evaluate_convergence_rates('
p48556
aS'      "H1", ConvergenceTable::reduction_rate);'
p48557
aS'    convergence_table.evaluate_convergence_rates('
p48558
aS'      "H1", ConvergenceTable::reduction_rate_log2);'
p48559
aS'    std::cout << std::endl;'
p48560
aS'    convergence_table.write_text(std::cout);'
p48561
aS'    std::string conv_filename = "convergence";'
p48562
aS'    conv_filename += "-global";'
p48563
aS'    switch (fe.degree)'
p48564
aS'      {'
p48565
aS'        case 1:'
p48566
aS'          conv_filename += "-q1";'
p48567
aS'          break;'
p48568
aS'        case 2:'
p48569
aS'          conv_filename += "-q2";'
p48570
aS'          break;'
p48571
aS'        default:'
p48572
aS'          Assert(false, ExcNotImplemented());'
p48573
aS'      }'
p48574
aS'    conv_filename += ".tex";'
p48575
aS'    std::ofstream table_file(conv_filename);'
p48576
aS'    convergence_table.write_tex(table_file);'
p48577
aS'  }'
p48578
aS'  template <int dim>'
p48579
aS'  void BlackScholes<dim>::run()'
p48580
aS'  {'
p48581
aS'    GridGenerator::hyper_cube(triangulation, 0.0, maximum_stock_price, true);'
p48582
aS'    triangulation.refine_global(0);'
p48583
aS'    solution_names.emplace_back("u");'
p48584
aS'    data_out_stack.declare_data_vector(solution_names,'
p48585
aS'                                       DataOutStack<dim>::dof_vector);'
p48586
aS'    Vector<double> vmult_result;'
p48587
aS'    Vector<double> forcing_terms;'
p48588
aS'    for (unsigned int cycle = 0; cycle < n_cycles; cycle++)'
p48589
aS'      {'
p48590
aS'        if (cycle != 0)'
p48591
aS'          {'
p48592
aS'            refine_grid();'
p48593
aS'            time = 0.0;'
p48594
aS'          }'
p48595
aS'        setup_system();'
p48596
aS'        std::cout << std::endl'
p48597
aS'                  << "===========================================" << std::endl'
p48598
aS'                  << "Cycle " << cycle << \':\' << std::endl'
p48599
aS'                  << "Number of active cells: "'
p48600
aS'                  << triangulation.n_active_cells() << std::endl'
p48601
aS'                  << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p48602
aS'                  << std::endl'
p48603
aS'                  << std::endl;'
p48604
aS'        VectorTools::interpolate(dof_handler,'
p48605
aS'                                 InitialConditions<dim>(strike_price),'
p48606
aS'                                 solution);'
p48607
aS'        if (cycle == (n_cycles - 1))'
p48608
aS'          {'
p48609
aS'            add_results_for_output();'
p48610
aS'          }'
p48611
aS'        vmult_result.reinit(dof_handler.n_dofs());'
p48612
aS'        forcing_terms.reinit(dof_handler.n_dofs());'
p48613
aS'        for (unsigned int timestep_number = 0; timestep_number < n_time_steps;'
p48614
aS'             ++timestep_number)'
p48615
aS'          {'
p48616
aS'            time += time_step;'
p48617
aS'            if (timestep_number % 1000 == 0)'
p48618
aS'              std::cout << "Time step " << timestep_number << " at t=" << time'
p48619
aS'                        << std::endl;'
p48620
aS'            mass_matrix.vmult(system_rhs, solution);'
p48621
aS'            laplace_matrix.vmult(vmult_result, solution);'
p48622
aS'            system_rhs.add('
p48623
aS'              (-1) * (1 - theta) * time_step *'
p48624
aS'                Utilities::fixed_power<2, double>(asset_volatility) * 0.5,'
p48625
aS'              vmult_result);'
p48626
aS'            mass_matrix.vmult(vmult_result, solution);'
p48627
aS'            system_rhs.add((-1) * (1 - theta) * time_step * interest_rate * 2,'
p48628
aS'                           vmult_result);'
p48629
aS'            a_matrix.vmult(vmult_result, solution);'
p48630
aS'            system_rhs.add((-1) * time_step * interest_rate, vmult_result);'
p48631
aS'            b_matrix.vmult(vmult_result, solution);'
p48632
aS'            system_rhs.add('
p48633
aS'              (-1) * Utilities::fixed_power<2, double>(asset_volatility) *'
p48634
aS'                time_step * 1,'
p48635
aS'              vmult_result);'
p48636
aS'            RightHandSide<dim> rhs_function(asset_volatility, interest_rate);'
p48637
aS'            rhs_function.set_time(time);'
p48638
aS'            VectorTools::create_right_hand_side(dof_handler,'
p48639
aS'                                                QGauss<dim>(fe.degree + 1),'
p48640
aS'                                                rhs_function,'
p48641
aS'                                                forcing_terms);'
p48642
aS'            forcing_terms *= time_step * theta;'
p48643
aS'            system_rhs -= forcing_terms;'
p48644
aS'            rhs_function.set_time(time - time_step);'
p48645
aS'            VectorTools::create_right_hand_side(dof_handler,'
p48646
aS'                                                QGauss<dim>(fe.degree + 1),'
p48647
aS'                                                rhs_function,'
p48648
aS'                                                forcing_terms);'
p48649
aS'            forcing_terms *= time_step * (1 - theta);'
p48650
aS'            system_rhs -= forcing_terms;'
p48651
aS'            system_matrix.copy_from(mass_matrix);'
p48652
aS'            system_matrix.add('
p48653
aS'              (theta)*time_step *'
p48654
aS'                Utilities::fixed_power<2, double>(asset_volatility) * 0.5,'
p48655
aS'              laplace_matrix);'
p48656
aS'            system_matrix.add((time_step)*interest_rate * theta * (1 + 1),'
p48657
aS'                              mass_matrix);'
p48658
aS'            constraints.condense(system_matrix, system_rhs);'
p48659
aS'            {'
p48660
aS'              RightBoundaryValues<dim> right_boundary_function(strike_price,'
p48661
aS'                                                               interest_rate);'
p48662
aS'              LeftBoundaryValues<dim>  left_boundary_function;'
p48663
aS'              right_boundary_function.set_time(time);'
p48664
aS'              left_boundary_function.set_time(time);'
p48665
aS'              std::map<types::global_dof_index, double> boundary_values;'
p48666
aS'              VectorTools::interpolate_boundary_values(dof_handler,'
p48667
aS'                                                       0,'
p48668
aS'                                                       left_boundary_function,'
p48669
aS'                                                       boundary_values);'
p48670
aS'              VectorTools::interpolate_boundary_values(dof_handler,'
p48671
aS'                                                       1,'
p48672
aS'                                                       right_boundary_function,'
p48673
aS'                                                       boundary_values);'
p48674
aS'              MatrixTools::apply_boundary_values(boundary_values,'
p48675
aS'                                                 system_matrix,'
p48676
aS'                                                 solution,'
p48677
aS'                                                 system_rhs);'
p48678
aS'            }'
p48679
aS'            solve_time_step();'
p48680
aS'            if (cycle == (n_cycles - 1))'
p48681
aS'              {'
p48682
aS'                add_results_for_output();'
p48683
aS'              }'
p48684
aS'          }'
p48685
aS'#ifdef MMS'
p48686
aS'        process_solution();'
p48687
aS'#endif'
p48688
aS'      }'
p48689
aS'    const std::string filename = "solution.vtk";'
p48690
aS'    std::ofstream     output(filename);'
p48691
aS'    data_out_stack.write_vtk(output);'
p48692
aS'#ifdef MMS'
p48693
aS'    write_convergence_table();'
p48694
aS'#endif'
p48695
aS'  }'
p48696
aS'} // namespace BlackScholesSolver'
p48697
aS'int main()'
p48698
ag24
aS'  try'
p48699
aS'    {'
p48700
aS'      using namespace BlackScholesSolver;'
p48701
aS'      BlackScholes<1> black_scholes_solver;'
p48702
aS'      black_scholes_solver.run();'
p48703
aS'    }'
p48704
aS'  catch (std::exception &exc)'
p48705
aS'    {'
p48706
aS'      std::cerr << std::endl'
p48707
aS'                << std::endl'
p48708
aS'                << "----------------------------------------------------"'
p48709
aS'                << std::endl;'
p48710
aS'      std::cerr << "Exception on processing: " << std::endl'
p48711
aS'                << exc.what() << std::endl'
p48712
aS'                << "Aborting!" << std::endl'
p48713
aS'                << "----------------------------------------------------"'
p48714
aS'                << std::endl;'
p48715
aS'      return 1;'
p48716
aS'    }'
p48717
aS'  catch (...)'
p48718
aS'    {'
p48719
aS'      std::cerr << std::endl'
p48720
aS'                << std::endl'
p48721
aS'                << "----------------------------------------------------"'
p48722
aS'                << std::endl;'
p48723
aS'      std::cerr << "Unknown exception!" << std::endl'
p48724
aS'                << "Aborting!" << std::endl'
p48725
aS'                << "----------------------------------------------------"'
p48726
aS'                << std::endl;'
p48727
aS'      return 1;'
p48728
aS'    }'
p48729
aS'  return 0;'
p48730
ag32
aS'/* ---------------------------------------------------------------------'
p48731
aS' *'
p48732
aS' * Copyright (C) 2021 by the deal.II authors'
p48733
aS' *'
p48734
aS' * This file is part of the deal.II library.'
p48735
aS' *'
p48736
aS' * The deal.II library is free software; you can use it, redistribute'
p48737
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p48738
aS' * Public License as published by the Free Software Foundation; either'
p48739
aS' * version 2.1 of the License, or (at your option) any later version.'
p48740
aS' * The full text of the license can be found in the file LICENSE.md at'
p48741
aS' * the top level directory of deal.II.'
p48742
aS' *'
p48743
aS' * ---------------------------------------------------------------------'
p48744
aS' *'
p48745
aS" * Author: Justin O'Connor, Colorado State University, 2021."
p48746
aS' */'
p48747
aS'#include <deal.II/base/quadrature_lib.h>'
p48748
aS'#include <deal.II/base/function.h>'
p48749
aS'#include <deal.II/base/tensor.h>'
p48750
aS'#include <deal.II/base/timer.h>'
p48751
aS'#include <deal.II/base/signaling_nan.h>'
p48752
aS'#include <deal.II/lac/block_vector.h>'
p48753
aS'#include <deal.II/lac/full_matrix.h>'
p48754
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p48755
aS'#include <deal.II/lac/linear_operator.h>'
p48756
aS'#include <deal.II/lac/packaged_operation.h>'
p48757
aS'#include <deal.II/lac/sparse_direct.h>'
p48758
aS'#include <deal.II/lac/affine_constraints.h>'
p48759
aS'#include <deal.II/grid/tria.h>'
p48760
aS'#include <deal.II/grid/grid_generator.h>'
p48761
aS'#include <deal.II/grid/grid_refinement.h>'
p48762
aS'#include <deal.II/dofs/dof_handler.h>'
p48763
aS'#include <deal.II/dofs/dof_renumbering.h>'
p48764
aS'#include <deal.II/dofs/dof_tools.h>'
p48765
aS'#include <deal.II/fe/fe_values.h>'
p48766
aS'#include <deal.II/fe/fe_dgq.h>'
p48767
aS'#include <deal.II/fe/fe_system.h>'
p48768
aS'#include <deal.II/fe/fe_q.h>'
p48769
aS'#include <deal.II/numerics/vector_tools.h>'
p48770
aS'#include <deal.II/numerics/matrix_tools.h>'
p48771
aS'#include <deal.II/numerics/data_out.h>'
p48772
aS'#include <iostream>'
p48773
aS'#include <fstream>'
p48774
aS'#include <algorithm>'
p48775
aS'namespace SAND'
p48776
ag24
aS'  using namespace dealii;'
p48777
aS'  namespace SolutionComponents'
p48778
aS'  {'
p48779
aS'    template <int dim>'
p48780
aS'    constexpr unsigned int density = 0;'
p48781
aS'    template <int dim>'
p48782
aS'    constexpr unsigned int displacement = 1;'
p48783
aS'    template <int dim>'
p48784
aS'    constexpr unsigned int unfiltered_density = 1 + dim;'
p48785
aS'    template <int dim>'
p48786
aS'    constexpr unsigned int displacement_multiplier = 2 + dim;'
p48787
aS'    template <int dim>'
p48788
aS'    constexpr unsigned int unfiltered_density_multiplier = 2 + 2 * dim;'
p48789
aS'    template <int dim>'
p48790
aS'    constexpr unsigned int density_lower_slack = 3 + 2 * dim;'
p48791
aS'    template <int dim>'
p48792
aS'    constexpr unsigned int density_lower_slack_multiplier = 4 + 2 * dim;'
p48793
aS'    template <int dim>'
p48794
aS'    constexpr unsigned int density_upper_slack = 5 + 2 * dim;'
p48795
aS'    template <int dim>'
p48796
aS'    constexpr unsigned int density_upper_slack_multiplier = 6 + 2 * dim;'
p48797
aS'  } // namespace SolutionComponents'
p48798
aS'  namespace SolutionBlocks'
p48799
aS'  {'
p48800
aS'    constexpr unsigned int density                        = 0;'
p48801
aS'    constexpr unsigned int displacement                   = 1;'
p48802
aS'    constexpr unsigned int unfiltered_density             = 2;'
p48803
aS'    constexpr unsigned int displacement_multiplier        = 3;'
p48804
aS'    constexpr unsigned int unfiltered_density_multiplier  = 4;'
p48805
aS'    constexpr unsigned int density_lower_slack            = 5;'
p48806
aS'    constexpr unsigned int density_lower_slack_multiplier = 6;'
p48807
aS'    constexpr unsigned int density_upper_slack            = 7;'
p48808
aS'    constexpr unsigned int density_upper_slack_multiplier = 8;'
p48809
aS'  } // namespace SolutionBlocks'
p48810
aS'  namespace BoundaryIds'
p48811
aS'  {'
p48812
aS'    constexpr types::boundary_id down_force = 101;'
p48813
aS'    constexpr types::boundary_id no_force   = 102;'
p48814
aS'  } // namespace BoundaryIds'
p48815
aS'  namespace ValueExtractors'
p48816
aS'  {'
p48817
aS'    template <int dim>'
p48818
aS'    const FEValuesExtractors::Scalar'
p48819
aS'      densities(SolutionComponents::density<dim>);'
p48820
aS'    template <int dim>'
p48821
aS'    const FEValuesExtractors::Vector'
p48822
aS'      displacements(SolutionComponents::displacement<dim>);'
p48823
aS'    template <int dim>'
p48824
aS'    const FEValuesExtractors::Scalar'
p48825
aS'      unfiltered_densities(SolutionComponents::unfiltered_density<dim>);'
p48826
aS'    template <int dim>'
p48827
aS'    const FEValuesExtractors::Vector displacement_multipliers('
p48828
aS'      SolutionComponents::displacement_multiplier<dim>);'
p48829
aS'    template <int dim>'
p48830
aS'    const FEValuesExtractors::Scalar unfiltered_density_multipliers('
p48831
aS'      SolutionComponents::unfiltered_density_multiplier<dim>);'
p48832
aS'    template <int dim>'
p48833
aS'    const FEValuesExtractors::Scalar'
p48834
aS'      density_lower_slacks(SolutionComponents::density_lower_slack<dim>);'
p48835
aS'    template <int dim>'
p48836
aS'    const FEValuesExtractors::Scalar density_lower_slack_multipliers('
p48837
aS'      SolutionComponents::density_lower_slack_multiplier<dim>);'
p48838
aS'    template <int dim>'
p48839
aS'    const FEValuesExtractors::Scalar'
p48840
aS'      density_upper_slacks(SolutionComponents::density_upper_slack<dim>);'
p48841
aS'    template <int dim>'
p48842
aS'    const FEValuesExtractors::Scalar density_upper_slack_multipliers('
p48843
aS'      SolutionComponents::density_upper_slack_multiplier<dim>);'
p48844
aS'  } // namespace ValueExtractors'
p48845
aS'  template <int dim>'
p48846
aS'  class SANDTopOpt'
p48847
aS'  {'
p48848
aS'  public:'
p48849
aS'    SANDTopOpt();'
p48850
aS'    void run();'
p48851
aS'  private:'
p48852
aS'    void create_triangulation();'
p48853
aS'    void setup_boundary_values();'
p48854
aS'    void setup_block_system();'
p48855
aS'    void setup_filter_matrix();'
p48856
aS'    void assemble_system();'
p48857
aS'    BlockVector<double> solve();'
p48858
aS'    std::pair<double, double>'
p48859
aS'    calculate_max_step_size(const BlockVector<double> &state,'
p48860
aS'                            const BlockVector<double> &step) const;'
p48861
aS'    BlockVector<double>'
p48862
aS'    calculate_test_rhs(const BlockVector<double> &test_solution) const;'
p48863
aS'    double calculate_exact_merit(const BlockVector<double> &test_solution);'
p48864
aS'    BlockVector<double> find_max_step();'
p48865
aS'    BlockVector<double> compute_scaled_step(const BlockVector<double> &state,'
p48866
aS'                                            const BlockVector<double> &step,'
p48867
aS'                                            const double descent_requirement);'
p48868
aS'    bool check_convergence(const BlockVector<double> &state);'
p48869
aS'    void output_results(const unsigned int j) const;'
p48870
aS'    void write_as_stl();'
p48871
aS'    std::set<typename Triangulation<dim>::cell_iterator>'
p48872
aS'    find_relevant_neighbors('
p48873
aS'      typename Triangulation<dim>::cell_iterator cell) const;'
p48874
aS'    Triangulation<dim>        triangulation;'
p48875
aS'    FESystem<dim>             fe;'
p48876
aS'    DoFHandler<dim>           dof_handler;'
p48877
aS'    AffineConstraints<double> constraints;'
p48878
aS'    std::map<types::global_dof_index, double> boundary_values;'
p48879
aS'    BlockSparsityPattern      sparsity_pattern;'
p48880
aS'    BlockSparseMatrix<double> system_matrix;'
p48881
aS'    SparsityPattern      filter_sparsity_pattern;'
p48882
aS'    SparseMatrix<double> filter_matrix;'
p48883
aS'    BlockVector<double> system_rhs;'
p48884
aS'    BlockVector<double> nonlinear_solution;'
p48885
aS'    const double density_ratio;'
p48886
aS'    const double density_penalty_exponent;'
p48887
aS'    const double filter_r;'
p48888
aS'    double       penalty_multiplier;'
p48889
aS'    double       barrier_size;'
p48890
aS'    TimerOutput timer;'
p48891
aS'  };'
p48892
aS'  template <int dim>'
p48893
aS'  SANDTopOpt<dim>::SANDTopOpt()'
p48894
aS'    : fe(FE_DGQ<dim>(0),'
p48895
aS'         1,'
p48896
aS'         (FESystem<dim>(FE_Q<dim>(1) ^ dim)),'
p48897
aS'         1,'
p48898
aS'         FE_DGQ<dim>(0),'
p48899
aS'         1,'
p48900
aS'         (FESystem<dim>(FE_Q<dim>(1) ^ dim)),'
p48901
aS'         1,'
p48902
aS'         FE_DGQ<dim>(0),'
p48903
aS'         5)'
p48904
aS'    , dof_handler(triangulation)'
p48905
aS'    , density_ratio(.5)'
p48906
aS'    , density_penalty_exponent(3)'
p48907
aS'    , filter_r(.251)'
p48908
aS'    , penalty_multiplier(1)'
p48909
aS'    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)'
p48910
aS'  {'
p48911
aS'    Assert(dim > 1, ExcNotImplemented());'
p48912
aS'  }'
p48913
aS'  template <int dim>'
p48914
aS'  void SANDTopOpt<dim>::create_triangulation()'
p48915
aS'  {'
p48916
aS'    Assert(dim == 2, ExcNotImplemented());'
p48917
aS'    GridGenerator::subdivided_hyper_rectangle(triangulation,'
p48918
aS'                                              {6, 1},'
p48919
aS'                                              Point<dim>(0, 0),'
p48920
aS'                                              Point<dim>(6, 1));'
p48921
aS'    triangulation.refine_global(3);'
p48922
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p48923
aS'      {'
p48924
aS'        for (const auto &face : cell->face_iterators())'
p48925
aS'          {'
p48926
aS'            if (face->at_boundary())'
p48927
aS'              {'
p48928
aS'                const auto center = face->center();'
p48929
aS'                if (std::fabs(center(1) - 1) < 1e-12)'
p48930
aS'                  {'
p48931
aS'                    if ((std::fabs(center(0) - 3) < .3))'
p48932
aS'                      face->set_boundary_id(BoundaryIds::down_force);'
p48933
aS'                    else'
p48934
aS'                      face->set_boundary_id(BoundaryIds::no_force);'
p48935
aS'                  }'
p48936
aS'                else'
p48937
aS'                  face->set_boundary_id(BoundaryIds::no_force);'
p48938
aS'              }'
p48939
aS'          }'
p48940
aS'      }'
p48941
aS'  }'
p48942
aS'  template <int dim>'
p48943
aS'  void SANDTopOpt<dim>::setup_boundary_values()'
p48944
aS'  {'
p48945
aS'    boundary_values.clear();'
p48946
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p48947
aS'      {'
p48948
aS'        for (const auto &face : cell->face_iterators())'
p48949
aS'          {'
p48950
aS'            if (face->at_boundary())'
p48951
aS'              {'
p48952
aS'                const auto center = face->center();'
p48953
aS'                if (std::fabs(center(1) - 0) < 1e-12)'
p48954
aS'                  {'
p48955
aS'                    for (const auto vertex_number : cell->vertex_indices())'
p48956
aS'                      {'
p48957
aS'                        const auto vert = cell->vertex(vertex_number);'
p48958
aS'                        if (std::fabs(vert(0) - 0) < 1e-12 &&'
p48959
aS'                            std::fabs(vert(1) - 0) < 1e-12)'
p48960
aS'                          {'
p48961
aS'                            types::global_dof_index x_displacement ='
p48962
aS'                              cell->vertex_dof_index(vertex_number, 0);'
p48963
aS'                            types::global_dof_index y_displacement ='
p48964
aS'                              cell->vertex_dof_index(vertex_number, 1);'
p48965
aS'                            types::global_dof_index x_displacement_multiplier ='
p48966
aS'                              cell->vertex_dof_index(vertex_number, 2);'
p48967
aS'                            types::global_dof_index y_displacement_multiplier ='
p48968
aS'                              cell->vertex_dof_index(vertex_number, 3);'
p48969
aS'                            boundary_values[x_displacement]            = 0;'
p48970
aS'                            boundary_values[y_displacement]            = 0;'
p48971
aS'                            boundary_values[x_displacement_multiplier] = 0;'
p48972
aS'                            boundary_values[y_displacement_multiplier] = 0;'
p48973
aS'                          }'
p48974
aS'                        else if (std::fabs(vert(0) - 6) < 1e-12 &&'
p48975
aS'                                 std::fabs(vert(1) - 0) < 1e-12)'
p48976
aS'                          {'
p48977
aS'                            types::global_dof_index y_displacement ='
p48978
aS'                              cell->vertex_dof_index(vertex_number, 1);'
p48979
aS'                            types::global_dof_index y_displacement_multiplier ='
p48980
aS'                              cell->vertex_dof_index(vertex_number, 3);'
p48981
aS'                            boundary_values[y_displacement]            = 0;'
p48982
aS'                            boundary_values[y_displacement_multiplier] = 0;'
p48983
aS'                          }'
p48984
aS'                      }'
p48985
aS'                  }'
p48986
aS'              }'
p48987
aS'          }'
p48988
aS'      }'
p48989
aS'  }'
p48990
aS'  template <int dim>'
p48991
aS'  void SANDTopOpt<dim>::setup_block_system()'
p48992
aS'  {'
p48993
aS'    std::vector<unsigned int> block_component(9, 2);'
p48994
aS'    block_component[0] = 0;'
p48995
aS'    block_component[1] = 1;'
p48996
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p48997
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p48998
aS'    const types::global_dof_index                     n_p = dofs_per_block[0];'
p48999
aS'    const types::global_dof_index                     n_u = dofs_per_block[1];'
p49000
aS'    const std::vector<BlockVector<double>::size_type> block_sizes = {'
p49001
aS'      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};'
p49002
aS'    BlockDynamicSparsityPattern dsp(9, 9);'
p49003
aS'    for (unsigned int k = 0; k < 9; ++k)'
p49004
aS'      for (unsigned int j = 0; j < 9; ++j)'
p49005
aS'        dsp.block(j, k).reinit(block_sizes[j], block_sizes[k]);'
p49006
aS'    dsp.collect_sizes();'
p49007
aS'    Table<2, DoFTools::Coupling> coupling(2 * dim + 7, 2 * dim + 7);'
p49008
aS'    {'
p49009
aS'      using namespace SolutionComponents;'
p49010
aS'      coupling[density<dim>][density<dim>] = DoFTools::always;'
p49011
aS'      for (unsigned int i = 0; i < dim; ++i)'
p49012
aS'        {'
p49013
aS'          coupling[density<dim>][displacement<dim> + i] = DoFTools::always;'
p49014
aS'          coupling[displacement<dim> + i][density<dim>] = DoFTools::always;'
p49015
aS'        }'
p49016
aS'      for (unsigned int i = 0; i < dim; ++i)'
p49017
aS'        {'
p49018
aS'          coupling[density<dim>][displacement_multiplier<dim> + i] ='
p49019
aS'            DoFTools::always;'
p49020
aS'          coupling[displacement_multiplier<dim> + i][density<dim>] ='
p49021
aS'            DoFTools::always;'
p49022
aS'        }'
p49023
aS'      coupling[density<dim>][unfiltered_density_multiplier<dim>] ='
p49024
aS'        DoFTools::always;'
p49025
aS'      coupling[unfiltered_density_multiplier<dim>][density<dim>] ='
p49026
aS'        DoFTools::always;'
p49027
aS'      for (unsigned int i = 0; i < dim; ++i)'
p49028
aS'        {'
p49029
aS'          for (unsigned int k = 0; k < dim; ++k)'
p49030
aS'            {'
p49031
aS'              coupling[displacement<dim> + i]'
p49032
aS'                      [displacement_multiplier<dim> + k] = DoFTools::always;'
p49033
aS'              coupling[displacement_multiplier<dim> + k]'
p49034
aS'                      [displacement<dim> + i] = DoFTools::always;'
p49035
aS'            }'
p49036
aS'        }'
p49037
aS'      coupling[density_lower_slack<dim>][density_lower_slack<dim>] ='
p49038
aS'        DoFTools::always;'
p49039
aS'      coupling[density_lower_slack<dim>][density_upper_slack<dim>] ='
p49040
aS'        DoFTools::always;'
p49041
aS'      coupling[density_upper_slack<dim>][density_lower_slack<dim>] ='
p49042
aS'        DoFTools::always;'
p49043
aS'      coupling[density_lower_slack_multiplier<dim>]'
p49044
aS'              [density_lower_slack_multiplier<dim>] = DoFTools::always;'
p49045
aS'      coupling[density_lower_slack_multiplier<dim>]'
p49046
aS'              [density_upper_slack_multiplier<dim>] = DoFTools::always;'
p49047
aS'      coupling[density_upper_slack_multiplier<dim>]'
p49048
aS'              [density_lower_slack_multiplier<dim>] = DoFTools::always;'
p49049
aS'    }'
p49050
aS'    const ComponentMask density_mask ='
p49051
aS'      fe.component_mask(ValueExtractors::densities<dim>);'
p49052
aS'    const IndexSet density_dofs ='
p49053
aS'      DoFTools::extract_dofs(dof_handler, density_mask);'
p49054
aS'    types::global_dof_index last_density_dof ='
p49055
aS'      density_dofs.nth_index_in_set(density_dofs.n_elements() - 1);'
p49056
aS'    constraints.clear();'
p49057
aS'    constraints.add_line(last_density_dof);'
p49058
aS'    for (unsigned int i = 0; i < density_dofs.n_elements() - 1; ++i)'
p49059
aS'      constraints.add_entry(last_density_dof,'
p49060
aS'                            density_dofs.nth_index_in_set(i),'
p49061
aS'                            -1);'
p49062
aS'    constraints.set_inhomogeneity(last_density_dof, 0);'
p49063
aS'    constraints.close();'
p49064
aS'    DoFTools::make_sparsity_pattern(dof_handler, coupling, dsp, constraints);'
p49065
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p49066
aS'      {'
p49067
aS'        const unsigned int i = cell->active_cell_index();'
p49068
aS'        for (const auto &check_cell : find_relevant_neighbors(cell))'
p49069
aS'          {'
p49070
aS'            const double distance ='
p49071
aS'              cell->center().distance(check_cell->center());'
p49072
aS'            if (distance < filter_r)'
p49073
aS'              {'
p49074
aS'                dsp'
p49075
aS'                  .block(SolutionBlocks::unfiltered_density,'
p49076
aS'                         SolutionBlocks::unfiltered_density_multiplier)'
p49077
aS'                  .add(i, check_cell->active_cell_index());'
p49078
aS'                dsp'
p49079
aS'                  .block(SolutionBlocks::unfiltered_density_multiplier,'
p49080
aS'                         SolutionBlocks::unfiltered_density)'
p49081
aS'                  .add(i, check_cell->active_cell_index());'
p49082
aS'              }'
p49083
aS'          }'
p49084
aS'      }'
p49085
aS'    sparsity_pattern.copy_from(dsp);'
p49086
aS'    std::ofstream out("sparsity.plt");'
p49087
aS'    sparsity_pattern.print_gnuplot(out);'
p49088
aS'    system_matrix.reinit(sparsity_pattern);'
p49089
aS'    nonlinear_solution.reinit(block_sizes);'
p49090
aS'    system_rhs.reinit(block_sizes);'
p49091
aS'    {'
p49092
aS'      using namespace SolutionBlocks;'
p49093
aS'      nonlinear_solution.block(density).add(density_ratio);'
p49094
aS'      nonlinear_solution.block(unfiltered_density).add(density_ratio);'
p49095
aS'      nonlinear_solution.block(unfiltered_density_multiplier)'
p49096
aS'        .add(density_ratio);'
p49097
aS'      nonlinear_solution.block(density_lower_slack).add(density_ratio);'
p49098
aS'      nonlinear_solution.block(density_lower_slack_multiplier).add(50);'
p49099
aS'      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);'
p49100
aS'      nonlinear_solution.block(density_upper_slack_multiplier).add(50);'
p49101
aS'    }'
p49102
aS'  }'
p49103
aS'  template <int dim>'
p49104
aS'  void SANDTopOpt<dim>::setup_filter_matrix()'
p49105
aS'  {'
p49106
aS'    filter_sparsity_pattern.copy_from('
p49107
aS'      sparsity_pattern.block(SolutionBlocks::unfiltered_density,'
p49108
aS'                             SolutionBlocks::unfiltered_density_multiplier));'
p49109
aS'    filter_matrix.reinit(filter_sparsity_pattern);'
p49110
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p49111
aS'      {'
p49112
aS'        const unsigned int i = cell->active_cell_index();'
p49113
aS'        for (const auto &check_cell : find_relevant_neighbors(cell))'
p49114
aS'          {'
p49115
aS'            const double distance ='
p49116
aS'              cell->center().distance(check_cell->center());'
p49117
aS'            if (distance < filter_r)'
p49118
aS'              {'
p49119
aS'                filter_matrix.add(i,'
p49120
aS'                                  check_cell->active_cell_index(),'
p49121
aS'                                  filter_r - distance);'
p49122
aS'              }'
p49123
aS'          }'
p49124
aS'      }'
p49125
aS'    for (unsigned int i = 0; i < filter_matrix.m(); ++i)'
p49126
aS'      {'
p49127
aS'        double denominator = 0;'
p49128
aS'        for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);'
p49129
aS'             iter != filter_matrix.end(i);'
p49130
aS'             iter++)'
p49131
aS'          denominator = denominator + iter->value();'
p49132
aS'        for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);'
p49133
aS'             iter != filter_matrix.end(i);'
p49134
aS'             iter++)'
p49135
aS'          iter->value() = iter->value() / denominator;'
p49136
aS'      }'
p49137
aS'  }'
p49138
aS'  template <int dim>'
p49139
aS'  std::set<typename Triangulation<dim>::cell_iterator>'
p49140
aS'  SANDTopOpt<dim>::find_relevant_neighbors('
p49141
aS'    typename Triangulation<dim>::cell_iterator cell) const'
p49142
aS'  {'
p49143
aS'    std::set<unsigned int>                               neighbor_ids;'
p49144
aS'    std::set<typename Triangulation<dim>::cell_iterator> cells_to_check;'
p49145
aS'    neighbor_ids.insert(cell->active_cell_index());'
p49146
aS'    cells_to_check.insert(cell);'
p49147
aS'    bool new_neighbors_found;'
p49148
aS'    do'
p49149
aS'      {'
p49150
aS'        new_neighbors_found = false;'
p49151
aS'        for (const auto &check_cell :'
p49152
aS'             std::vector<typename Triangulation<dim>::cell_iterator>('
p49153
aS'               cells_to_check.begin(), cells_to_check.end()))'
p49154
aS'          {'
p49155
aS'            for (const auto n : check_cell->face_indices())'
p49156
aS'              {'
p49157
aS'                if (!(check_cell->face(n)->at_boundary()))'
p49158
aS'                  {'
p49159
aS'                    const auto & neighbor = check_cell->neighbor(n);'
p49160
aS'                    const double distance ='
p49161
aS'                      cell->center().distance(neighbor->center());'
p49162
aS'                    if ((distance < filter_r) &&'
p49163
aS'                        !(neighbor_ids.count(neighbor->active_cell_index())))'
p49164
aS'                      {'
p49165
aS'                        cells_to_check.insert(neighbor);'
p49166
aS'                        neighbor_ids.insert(neighbor->active_cell_index());'
p49167
aS'                        new_neighbors_found = true;'
p49168
aS'                      }'
p49169
aS'                  }'
p49170
aS'              }'
p49171
aS'          }'
p49172
aS'      }'
p49173
aS'    while (new_neighbors_found);'
p49174
aS'    return cells_to_check;'
p49175
aS'  }'
p49176
aS'  template <int dim>'
p49177
aS'  void SANDTopOpt<dim>::assemble_system()'
p49178
aS'  {'
p49179
aS'    TimerOutput::Scope t(timer, "assembly");'
p49180
aS'    system_matrix = 0;'
p49181
aS'    system_rhs    = 0;'
p49182
aS'    MappingQGeneric<dim> mapping(1);'
p49183
aS'    QGauss<dim>          quadrature_formula(fe.degree + 1);'
p49184
aS'    QGauss<dim - 1>      face_quadrature_formula(fe.degree + 1);'
p49185
aS'    FEValues<dim>        fe_values(mapping,'
p49186
aS'                            fe,'
p49187
aS'                            quadrature_formula,'
p49188
aS'                            update_values | update_gradients |'
p49189
aS'                              update_quadrature_points | update_JxW_values);'
p49190
aS'    FEFaceValues<dim>    fe_face_values(mapping,'
p49191
aS'                                     fe,'
p49192
aS'                                     face_quadrature_formula,'
p49193
aS'                                     update_values | update_quadrature_points |'
p49194
aS'                                       update_normal_vectors |'
p49195
aS'                                       update_JxW_values);'
p49196
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p49197
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p49198
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p49199
aS'    Vector<double>     dummy_cell_rhs(dofs_per_cell);'
p49200
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p49201
aS'    std::vector<double>                    lambda_values(n_q_points);'
p49202
aS'    std::vector<double>                    mu_values(n_q_points);'
p49203
aS'    const Functions::ConstantFunction<dim> lambda(1.);'
p49204
aS'    const Functions::ConstantFunction<dim> mu(1.);'
p49205
aS'    std::vector<Tensor<1, dim>>            rhs_values(n_q_points);'
p49206
aS'    BlockVector<double> filtered_unfiltered_density_solution ='
p49207
aS'      nonlinear_solution;'
p49208
aS'    BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution ='
p49209
aS'      nonlinear_solution;'
p49210
aS'    filter_matrix.vmult(filtered_unfiltered_density_solution.block('
p49211
aS'                          SolutionBlocks::unfiltered_density),'
p49212
aS'                        nonlinear_solution.block('
p49213
aS'                          SolutionBlocks::unfiltered_density));'
p49214
aS'    filter_matrix.Tvmult('
p49215
aS'      filter_adjoint_unfiltered_density_multiplier_solution.block('
p49216
aS'        SolutionBlocks::unfiltered_density_multiplier),'
p49217
aS'      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));'
p49218
aS'    std::vector<double>                  old_density_values(n_q_points);'
p49219
aS'    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);'
p49220
aS'    std::vector<double>                  old_displacement_divs(n_q_points);'
p49221
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);'
p49222
aS'    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);'
p49223
aS'    std::vector<double>         old_displacement_multiplier_divs(n_q_points);'
p49224
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads('
p49225
aS'      n_q_points);'
p49226
aS'    std::vector<double> old_lower_slack_multiplier_values(n_q_points);'
p49227
aS'    std::vector<double> old_upper_slack_multiplier_values(n_q_points);'
p49228
aS'    std::vector<double> old_lower_slack_values(n_q_points);'
p49229
aS'    std::vector<double> old_upper_slack_values(n_q_points);'
p49230
aS'    std::vector<double> old_unfiltered_density_values(n_q_points);'
p49231
aS'    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);'
p49232
aS'    std::vector<double> filtered_unfiltered_density_values(n_q_points);'
p49233
aS'    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values('
p49234
aS'      n_q_points);'
p49235
aS'    using namespace ValueExtractors;'
p49236
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p49237
aS'      {'
p49238
aS'        cell_matrix = 0;'
p49239
aS'        cell->get_dof_indices(local_dof_indices);'
p49240
aS'        fe_values.reinit(cell);'
p49241
aS'        lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p49242
aS'        mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p49243
aS'        fe_values[densities<dim>].get_function_values(nonlinear_solution,'
p49244
aS'                                                      old_density_values);'
p49245
aS'        fe_values[displacements<dim>].get_function_values('
p49246
aS'          nonlinear_solution, old_displacement_values);'
p49247
aS'        fe_values[displacements<dim>].get_function_divergences('
p49248
aS'          nonlinear_solution, old_displacement_divs);'
p49249
aS'        fe_values[displacements<dim>].get_function_symmetric_gradients('
p49250
aS'          nonlinear_solution, old_displacement_symmgrads);'
p49251
aS'        fe_values[displacement_multipliers<dim>].get_function_values('
p49252
aS'          nonlinear_solution, old_displacement_multiplier_values);'
p49253
aS'        fe_values[displacement_multipliers<dim>].get_function_divergences('
p49254
aS'          nonlinear_solution, old_displacement_multiplier_divs);'
p49255
aS'        fe_values[displacement_multipliers<dim>]'
p49256
aS'          .get_function_symmetric_gradients('
p49257
aS'            nonlinear_solution, old_displacement_multiplier_symmgrads);'
p49258
aS'        fe_values[density_lower_slacks<dim>].get_function_values('
p49259
aS'          nonlinear_solution, old_lower_slack_values);'
p49260
aS'        fe_values[density_lower_slack_multipliers<dim>].get_function_values('
p49261
aS'          nonlinear_solution, old_lower_slack_multiplier_values);'
p49262
aS'        fe_values[density_upper_slacks<dim>].get_function_values('
p49263
aS'          nonlinear_solution, old_upper_slack_values);'
p49264
aS'        fe_values[density_upper_slack_multipliers<dim>].get_function_values('
p49265
aS'          nonlinear_solution, old_upper_slack_multiplier_values);'
p49266
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p49267
aS'          nonlinear_solution, old_unfiltered_density_values);'
p49268
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p49269
aS'          nonlinear_solution, old_unfiltered_density_multiplier_values);'
p49270
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p49271
aS'          filtered_unfiltered_density_solution,'
p49272
aS'          filtered_unfiltered_density_values);'
p49273
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p49274
aS'          filter_adjoint_unfiltered_density_multiplier_solution,'
p49275
aS'          filter_adjoint_unfiltered_density_multiplier_values);'
p49276
aS'        for (const auto q_point : fe_values.quadrature_point_indices())'
p49277
aS'          {'
p49278
aS'            for (const auto i : fe_values.dof_indices())'
p49279
aS'              {'
p49280
aS'                const SymmetricTensor<2, dim> displacement_phi_i_symmgrad ='
p49281
aS'                  fe_values[displacements<dim>].symmetric_gradient(i, q_point);'
p49282
aS'                const double displacement_phi_i_div ='
p49283
aS'                  fe_values[displacements<dim>].divergence(i, q_point);'
p49284
aS'                const SymmetricTensor<2, dim>'
p49285
aS'                  displacement_multiplier_phi_i_symmgrad ='
p49286
aS'                    fe_values[displacement_multipliers<dim>].symmetric_gradient('
p49287
aS'                      i, q_point);'
p49288
aS'                const double displacement_multiplier_phi_i_div ='
p49289
aS'                  fe_values[displacement_multipliers<dim>].divergence(i,'
p49290
aS'                                                                      q_point);'
p49291
aS'                const double density_phi_i ='
p49292
aS'                  fe_values[densities<dim>].value(i, q_point);'
p49293
aS'                const double unfiltered_density_phi_i ='
p49294
aS'                  fe_values[unfiltered_densities<dim>].value(i, q_point);'
p49295
aS'                const double unfiltered_density_multiplier_phi_i ='
p49296
aS'                  fe_values[unfiltered_density_multipliers<dim>].value(i,'
p49297
aS'                                                                       q_point);'
p49298
aS'                const double lower_slack_multiplier_phi_i ='
p49299
aS'                  fe_values[density_lower_slack_multipliers<dim>].value('
p49300
aS'                    i, q_point);'
p49301
aS'                const double lower_slack_phi_i ='
p49302
aS'                  fe_values[density_lower_slacks<dim>].value(i, q_point);'
p49303
aS'                const double upper_slack_phi_i ='
p49304
aS'                  fe_values[density_upper_slacks<dim>].value(i, q_point);'
p49305
aS'                const double upper_slack_multiplier_phi_i ='
p49306
aS'                  fe_values[density_upper_slack_multipliers<dim>].value('
p49307
aS'                    i, q_point);'
p49308
aS'                for (const auto j : fe_values.dof_indices())'
p49309
aS'                  {'
p49310
aS'                    const SymmetricTensor<2, dim> displacement_phi_j_symmgrad ='
p49311
aS'                      fe_values[displacements<dim>].symmetric_gradient(j,'
p49312
aS'                                                                       q_point);'
p49313
aS'                    const double displacement_phi_j_div ='
p49314
aS'                      fe_values[displacements<dim>].divergence(j, q_point);'
p49315
aS'                    const SymmetricTensor<2, dim>'
p49316
aS'                      displacement_multiplier_phi_j_symmgrad ='
p49317
aS'                        fe_values[displacement_multipliers<dim>]'
p49318
aS'                          .symmetric_gradient(j, q_point);'
p49319
aS'                    const double displacement_multiplier_phi_j_div ='
p49320
aS'                      fe_values[displacement_multipliers<dim>].divergence('
p49321
aS'                        j, q_point);'
p49322
aS'                    const double density_phi_j ='
p49323
aS'                      fe_values[densities<dim>].value(j, q_point);'
p49324
aS'                    const double unfiltered_density_phi_j ='
p49325
aS'                      fe_values[unfiltered_densities<dim>].value(j, q_point);'
p49326
aS'                    const double unfiltered_density_multiplier_phi_j ='
p49327
aS'                      fe_values[unfiltered_density_multipliers<dim>].value('
p49328
aS'                        j, q_point);'
p49329
aS'                    const double lower_slack_phi_j ='
p49330
aS'                      fe_values[density_lower_slacks<dim>].value(j, q_point);'
p49331
aS'                    const double upper_slack_phi_j ='
p49332
aS'                      fe_values[density_upper_slacks<dim>].value(j, q_point);'
p49333
aS'                    const double lower_slack_multiplier_phi_j ='
p49334
aS'                      fe_values[density_lower_slack_multipliers<dim>].value('
p49335
aS'                        j, q_point);'
p49336
aS'                    const double upper_slack_multiplier_phi_j ='
p49337
aS'                      fe_values[density_upper_slack_multipliers<dim>].value('
p49338
aS'                        j, q_point);'
p49339
aS'                    cell_matrix(i, j) +='
p49340
aS'                      fe_values.JxW(q_point) *'
p49341
aS'                      ('
p49342
aS'                        -density_phi_i * unfiltered_density_multiplier_phi_j'
p49343
aS'                        + density_penalty_exponent *'
p49344
aS'                            (density_penalty_exponent - 1) *'
p49345
aS'                            std::pow(old_density_values[q_point],'
p49346
aS'                                     density_penalty_exponent - 2) *'
p49347
aS'                            density_phi_i * density_phi_j *'
p49348
aS'                            (old_displacement_multiplier_divs[q_point] *'
p49349
aS'                               old_displacement_divs[q_point] *'
p49350
aS'                               lambda_values[q_point] +'
p49351
aS'                             2 * mu_values[q_point] *'
p49352
aS'                               (old_displacement_symmgrads[q_point] *'
p49353
aS'                                old_displacement_multiplier_symmgrads[q_point]))'
p49354
aS'                        + density_penalty_exponent *'
p49355
aS'                            std::pow(old_density_values[q_point],'
p49356
aS'                                     density_penalty_exponent - 1) *'
p49357
aS'                            density_phi_i *'
p49358
aS'                            (displacement_multiplier_phi_j_div *'
p49359
aS'                               old_displacement_divs[q_point] *'
p49360
aS'                               lambda_values[q_point] +'
p49361
aS'                             2 * mu_values[q_point] *'
p49362
aS'                               (old_displacement_symmgrads[q_point] *'
p49363
aS'                                displacement_multiplier_phi_j_symmgrad))'
p49364
aS'                        + density_penalty_exponent *'
p49365
aS'                            std::pow(old_density_values[q_point],'
p49366
aS'                                     density_penalty_exponent - 1) *'
p49367
aS'                            density_phi_i *'
p49368
aS'                            (displacement_phi_j_div *'
p49369
aS'                               old_displacement_multiplier_divs[q_point] *'
p49370
aS'                               lambda_values[q_point] +'
p49371
aS'                             2 * mu_values[q_point] *'
p49372
aS'                               (old_displacement_multiplier_symmgrads[q_point] *'
p49373
aS'                                displacement_phi_j_symmgrad)));'
p49374
aS'                    cell_matrix(i, j) +='
p49375
aS'                      fe_values.JxW(q_point) *'
p49376
aS'                      (density_penalty_exponent *'
p49377
aS'                         std::pow(old_density_values[q_point],'
p49378
aS'                                  density_penalty_exponent - 1) *'
p49379
aS'                         density_phi_j *'
p49380
aS'                         (old_displacement_multiplier_divs[q_point] *'
p49381
aS'                            displacement_phi_i_div * lambda_values[q_point] +'
p49382
aS'                          2 * mu_values[q_point] *'
p49383
aS'                            (old_displacement_multiplier_symmgrads[q_point] *'
p49384
aS'                             displacement_phi_i_symmgrad))'
p49385
aS'                       + std::pow(old_density_values[q_point],'
p49386
aS'                                  density_penalty_exponent) *'
p49387
aS'                           (displacement_multiplier_phi_j_div *'
p49388
aS'                              displacement_phi_i_div * lambda_values[q_point] +'
p49389
aS'                            2 * mu_values[q_point] *'
p49390
aS'                              (displacement_multiplier_phi_j_symmgrad *'
p49391
aS'                               displacement_phi_i_symmgrad))'
p49392
aS'                      );'
p49393
aS'                     * calculated elsewhere. */'
p49394
aS'                    cell_matrix(i, j) +='
p49395
aS'                      fe_values.JxW(q_point) *'
p49396
aS'                      (-1 * unfiltered_density_phi_i *'
p49397
aS'                         lower_slack_multiplier_phi_j +'
p49398
aS'                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);'
p49399
aS'                    cell_matrix(i, j) +='
p49400
aS'                      fe_values.JxW(q_point) *'
p49401
aS'                      ('
p49402
aS'                        density_penalty_exponent *'
p49403
aS'                          std::pow(old_density_values[q_point],'
p49404
aS'                                   density_penalty_exponent - 1) *'
p49405
aS'                          density_phi_j *'
p49406
aS'                          (old_displacement_divs[q_point] *'
p49407
aS'                             displacement_multiplier_phi_i_div *'
p49408
aS'                             lambda_values[q_point] +'
p49409
aS'                           2 * mu_values[q_point] *'
p49410
aS'                             (old_displacement_symmgrads[q_point] *'
p49411
aS'                              displacement_multiplier_phi_i_symmgrad))'
p49412
aS'                        + std::pow(old_density_values[q_point],'
p49413
aS'                                   density_penalty_exponent) *'
p49414
aS'                            (displacement_phi_j_div *'
p49415
aS'                               displacement_multiplier_phi_i_div *'
p49416
aS'                               lambda_values[q_point] +'
p49417
aS'                             2 * mu_values[q_point] *'
p49418
aS'                               (displacement_phi_j_symmgrad *'
p49419
aS'                                displacement_multiplier_phi_i_symmgrad)));'
p49420
aS'                    cell_matrix(i, j) +='
p49421
aS'                      -1 * fe_values.JxW(q_point) *'
p49422
aS'                      lower_slack_multiplier_phi_i *'
p49423
aS'                      (unfiltered_density_phi_j - lower_slack_phi_j);'
p49424
aS'                    cell_matrix(i, j) +='
p49425
aS'                      -1 * fe_values.JxW(q_point) *'
p49426
aS'                      upper_slack_multiplier_phi_i *'
p49427
aS'                      (-1 * unfiltered_density_phi_j - upper_slack_phi_j);'
p49428
aS'                     * is added later */'
p49429
aS'                    cell_matrix(i, j) += -1 * fe_values.JxW(q_point) *'
p49430
aS'                                         unfiltered_density_multiplier_phi_i *'
p49431
aS'                                         (density_phi_j);'
p49432
aS'                    cell_matrix(i, j) +='
p49433
aS'                      fe_values.JxW(q_point) *'
p49434
aS'                      (lower_slack_phi_i * lower_slack_multiplier_phi_j'
p49435
aS'                       + lower_slack_phi_i * lower_slack_phi_j *'
p49436
aS'                           old_lower_slack_multiplier_values[q_point] /'
p49437
aS'                           old_lower_slack_values[q_point]);'
p49438
aS'                    cell_matrix(i, j) +='
p49439
aS'                      fe_values.JxW(q_point) *'
p49440
aS'                      (upper_slack_phi_i * upper_slack_multiplier_phi_j'
p49441
aS'                       + upper_slack_phi_i * upper_slack_phi_j *'
p49442
aS'                           old_upper_slack_multiplier_values[q_point] /'
p49443
aS'                           old_upper_slack_values[q_point]);'
p49444
aS'                  }'
p49445
aS'              }'
p49446
aS'          }'
p49447
aS'        MatrixTools::local_apply_boundary_values(boundary_values,'
p49448
aS'                                                 local_dof_indices,'
p49449
aS'                                                 cell_matrix,'
p49450
aS'                                                 dummy_cell_rhs,'
p49451
aS'                                                 true);'
p49452
aS'        constraints.distribute_local_to_global(cell_matrix,'
p49453
aS'                                               local_dof_indices,'
p49454
aS'                                               system_matrix);'
p49455
aS'      }'
p49456
aS'    system_rhs = calculate_test_rhs(nonlinear_solution);'
p49457
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p49458
aS'      {'
p49459
aS'        const unsigned int i = cell->active_cell_index();'
p49460
aS'        for (typename SparseMatrix<double>::iterator iter ='
p49461
aS'               filter_matrix.begin(i);'
p49462
aS'             iter != filter_matrix.end(i);'
p49463
aS'             ++iter)'
p49464
aS'          {'
p49465
aS'            const unsigned int j     = iter->column();'
p49466
aS'            const double       value = iter->value() * cell->measure();'
p49467
aS'            system_matrix'
p49468
aS'              .block(SolutionBlocks::unfiltered_density_multiplier,'
p49469
aS'                     SolutionBlocks::unfiltered_density)'
p49470
aS'              .add(i, j, value);'
p49471
aS'            system_matrix'
p49472
aS'              .block(SolutionBlocks::unfiltered_density,'
p49473
aS'                     SolutionBlocks::unfiltered_density_multiplier)'
p49474
aS'              .add(j, i, value);'
p49475
aS'          }'
p49476
aS'      }'
p49477
aS'  }'
p49478
aS'  template <int dim>'
p49479
aS'  BlockVector<double> SANDTopOpt<dim>::solve()'
p49480
aS'  {'
p49481
aS'    TimerOutput::Scope t(timer, "solver");'
p49482
aS'    BlockVector<double> linear_solution;'
p49483
aS'    linear_solution.reinit(nonlinear_solution);'
p49484
aS'    SparseDirectUMFPACK A_direct;'
p49485
aS'    A_direct.initialize(system_matrix);'
p49486
aS'    A_direct.vmult(linear_solution, system_rhs);'
p49487
aS'    constraints.distribute(linear_solution);'
p49488
aS'    return linear_solution;'
p49489
aS'  }'
p49490
aS'  template <int dim>'
p49491
aS'  std::pair<double, double> SANDTopOpt<dim>::calculate_max_step_size('
p49492
aS'    const BlockVector<double> &state,'
p49493
aS'    const BlockVector<double> &step) const'
p49494
aS'  {'
p49495
aS'    double       fraction_to_boundary;'
p49496
aS'    const double min_fraction_to_boundary = .8;'
p49497
aS'    const double max_fraction_to_boundary = 1. - 1e-5;'
p49498
aS'    if (min_fraction_to_boundary < 1 - barrier_size)'
p49499
aS'      {'
p49500
aS'        if (1 - barrier_size < max_fraction_to_boundary)'
p49501
aS'          fraction_to_boundary = 1 - barrier_size;'
p49502
aS'        else'
p49503
aS'          fraction_to_boundary = max_fraction_to_boundary;'
p49504
aS'      }'
p49505
aS'    else'
p49506
aS'      fraction_to_boundary = min_fraction_to_boundary;'
p49507
aS'    double step_size_s_low  = 0;'
p49508
aS'    double step_size_z_low  = 0;'
p49509
aS'    double step_size_s_high = 1;'
p49510
aS'    double step_size_z_high = 1;'
p49511
aS'    double step_size_s, step_size_z;'
p49512
aS'    const int max_bisection_method_steps = 50;'
p49513
aS'    for (unsigned int k = 0; k < max_bisection_method_steps; ++k)'
p49514
aS'      {'
p49515
aS'        step_size_s = (step_size_s_low + step_size_s_high) / 2;'
p49516
aS'        step_size_z = (step_size_z_low + step_size_z_high) / 2;'
p49517
aS'        const BlockVector<double> state_test_s ='
p49518
aS'          (fraction_to_boundary * state) + (step_size_s * step);'
p49519
aS'        const BlockVector<double> state_test_z ='
p49520
aS'          (fraction_to_boundary * state) + (step_size_z * step);'
p49521
aS'        const bool accept_s ='
p49522
aS'          (state_test_s.block(SolutionBlocks::density_lower_slack)'
p49523
aS'             .is_non_negative()) &&'
p49524
aS'          (state_test_s.block(SolutionBlocks::density_upper_slack)'
p49525
aS'             .is_non_negative());'
p49526
aS'        const bool accept_z ='
p49527
aS'          (state_test_z.block(SolutionBlocks::density_lower_slack_multiplier)'
p49528
aS'             .is_non_negative()) &&'
p49529
aS'          (state_test_z.block(SolutionBlocks::density_upper_slack_multiplier)'
p49530
aS'             .is_non_negative());'
p49531
aS'        if (accept_s)'
p49532
aS'          step_size_s_low = step_size_s;'
p49533
aS'        else'
p49534
aS'          step_size_s_high = step_size_s;'
p49535
aS'        if (accept_z)'
p49536
aS'          step_size_z_low = step_size_z;'
p49537
aS'        else'
p49538
aS'          step_size_z_high = step_size_z;'
p49539
aS'      }'
p49540
aS'    return {step_size_s_low, step_size_z_low};'
p49541
aS'  }'
p49542
aS'  template <int dim>'
p49543
aS'  BlockVector<double> SANDTopOpt<dim>::calculate_test_rhs('
p49544
aS'    const BlockVector<double> &test_solution) const'
p49545
aS'  {'
p49546
aS'    BlockVector<double> test_rhs;'
p49547
aS'    test_rhs.reinit(system_rhs);'
p49548
aS'    MappingQGeneric<dim>  mapping(1);'
p49549
aS'    const QGauss<dim>     quadrature_formula(fe.degree + 1);'
p49550
aS'    const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p49551
aS'    FEValues<dim>         fe_values(mapping,'
p49552
aS'                            fe,'
p49553
aS'                            quadrature_formula,'
p49554
aS'                            update_values | update_gradients |'
p49555
aS'                              update_quadrature_points | update_JxW_values);'
p49556
aS'    FEFaceValues<dim>     fe_face_values(mapping,'
p49557
aS'                                     fe,'
p49558
aS'                                     face_quadrature_formula,'
p49559
aS'                                     update_values | update_quadrature_points |'
p49560
aS'                                       update_normal_vectors |'
p49561
aS'                                       update_JxW_values);'
p49562
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p49563
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p49564
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p49565
aS'    FullMatrix<double> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);'
p49566
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p49567
aS'    std::vector<double> lambda_values(n_q_points);'
p49568
aS'    std::vector<double> mu_values(n_q_points);'
p49569
aS'    const Functions::ConstantFunction<dim> lambda(1.), mu(1.);'
p49570
aS'    std::vector<Tensor<1, dim>>            rhs_values(n_q_points);'
p49571
aS'    BlockVector<double> filtered_unfiltered_density_solution = test_solution;'
p49572
aS'    BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution ='
p49573
aS'      test_solution;'
p49574
aS'    filtered_unfiltered_density_solution.block('
p49575
aS'      SolutionBlocks::unfiltered_density) = 0;'
p49576
aS'    filter_adjoint_unfiltered_density_multiplier_solution.block('
p49577
aS'      SolutionBlocks::unfiltered_density_multiplier) = 0;'
p49578
aS'    filter_matrix.vmult(filtered_unfiltered_density_solution.block('
p49579
aS'                          SolutionBlocks::unfiltered_density),'
p49580
aS'                        test_solution.block('
p49581
aS'                          SolutionBlocks::unfiltered_density));'
p49582
aS'    filter_matrix.Tvmult('
p49583
aS'      filter_adjoint_unfiltered_density_multiplier_solution.block('
p49584
aS'        SolutionBlocks::unfiltered_density_multiplier),'
p49585
aS'      test_solution.block(SolutionBlocks::unfiltered_density_multiplier));'
p49586
aS'    std::vector<double>                  old_density_values(n_q_points);'
p49587
aS'    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);'
p49588
aS'    std::vector<double>                  old_displacement_divs(n_q_points);'
p49589
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);'
p49590
aS'    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);'
p49591
aS'    std::vector<double>         old_displacement_multiplier_divs(n_q_points);'
p49592
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads('
p49593
aS'      n_q_points);'
p49594
aS'    std::vector<double> old_lower_slack_multiplier_values(n_q_points);'
p49595
aS'    std::vector<double> old_upper_slack_multiplier_values(n_q_points);'
p49596
aS'    std::vector<double> old_lower_slack_values(n_q_points);'
p49597
aS'    std::vector<double> old_upper_slack_values(n_q_points);'
p49598
aS'    std::vector<double> old_unfiltered_density_values(n_q_points);'
p49599
aS'    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);'
p49600
aS'    std::vector<double> filtered_unfiltered_density_values(n_q_points);'
p49601
aS'    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values('
p49602
aS'      n_q_points);'
p49603
aS'    using namespace ValueExtractors;'
p49604
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p49605
aS'      {'
p49606
aS'        cell_rhs = 0;'
p49607
aS'        cell->get_dof_indices(local_dof_indices);'
p49608
aS'        fe_values.reinit(cell);'
p49609
aS'        lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p49610
aS'        mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p49611
aS'        fe_values[densities<dim>].get_function_values(test_solution,'
p49612
aS'                                                      old_density_values);'
p49613
aS'        fe_values[displacements<dim>].get_function_values('
p49614
aS'          test_solution, old_displacement_values);'
p49615
aS'        fe_values[displacements<dim>].get_function_divergences('
p49616
aS'          test_solution, old_displacement_divs);'
p49617
aS'        fe_values[displacements<dim>].get_function_symmetric_gradients('
p49618
aS'          test_solution, old_displacement_symmgrads);'
p49619
aS'        fe_values[displacement_multipliers<dim>].get_function_values('
p49620
aS'          test_solution, old_displacement_multiplier_values);'
p49621
aS'        fe_values[displacement_multipliers<dim>].get_function_divergences('
p49622
aS'          test_solution, old_displacement_multiplier_divs);'
p49623
aS'        fe_values[displacement_multipliers<dim>]'
p49624
aS'          .get_function_symmetric_gradients('
p49625
aS'            test_solution, old_displacement_multiplier_symmgrads);'
p49626
aS'        fe_values[density_lower_slacks<dim>].get_function_values('
p49627
aS'          test_solution, old_lower_slack_values);'
p49628
aS'        fe_values[density_lower_slack_multipliers<dim>].get_function_values('
p49629
aS'          test_solution, old_lower_slack_multiplier_values);'
p49630
aS'        fe_values[density_upper_slacks<dim>].get_function_values('
p49631
aS'          test_solution, old_upper_slack_values);'
p49632
aS'        fe_values[density_upper_slack_multipliers<dim>].get_function_values('
p49633
aS'          test_solution, old_upper_slack_multiplier_values);'
p49634
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p49635
aS'          test_solution, old_unfiltered_density_values);'
p49636
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p49637
aS'          test_solution, old_unfiltered_density_multiplier_values);'
p49638
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p49639
aS'          filtered_unfiltered_density_solution,'
p49640
aS'          filtered_unfiltered_density_values);'
p49641
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p49642
aS'          filter_adjoint_unfiltered_density_multiplier_solution,'
p49643
aS'          filter_adjoint_unfiltered_density_multiplier_values);'
p49644
aS'        for (const auto q_point : fe_values.quadrature_point_indices())'
p49645
aS'          {'
p49646
aS'            for (const auto i : fe_values.dof_indices())'
p49647
aS'              {'
p49648
aS'                const SymmetricTensor<2, dim> displacement_phi_i_symmgrad ='
p49649
aS'                  fe_values[displacements<dim>].symmetric_gradient(i, q_point);'
p49650
aS'                const double displacement_phi_i_div ='
p49651
aS'                  fe_values[displacements<dim>].divergence(i, q_point);'
p49652
aS'                const SymmetricTensor<2, dim>'
p49653
aS'                  displacement_multiplier_phi_i_symmgrad ='
p49654
aS'                    fe_values[displacement_multipliers<dim>].symmetric_gradient('
p49655
aS'                      i, q_point);'
p49656
aS'                const double displacement_multiplier_phi_i_div ='
p49657
aS'                  fe_values[displacement_multipliers<dim>].divergence(i,'
p49658
aS'                                                                      q_point);'
p49659
aS'                const double density_phi_i ='
p49660
aS'                  fe_values[densities<dim>].value(i, q_point);'
p49661
aS'                const double unfiltered_density_phi_i ='
p49662
aS'                  fe_values[unfiltered_densities<dim>].value(i, q_point);'
p49663
aS'                const double unfiltered_density_multiplier_phi_i ='
p49664
aS'                  fe_values[unfiltered_density_multipliers<dim>].value(i,'
p49665
aS'                                                                       q_point);'
p49666
aS'                const double lower_slack_multiplier_phi_i ='
p49667
aS'                  fe_values[density_lower_slack_multipliers<dim>].value('
p49668
aS'                    i, q_point);'
p49669
aS'                const double lower_slack_phi_i ='
p49670
aS'                  fe_values[density_lower_slacks<dim>].value(i, q_point);'
p49671
aS'                const double upper_slack_phi_i ='
p49672
aS'                  fe_values[density_upper_slacks<dim>].value(i, q_point);'
p49673
aS'                const double upper_slack_multiplier_phi_i ='
p49674
aS'                  fe_values[density_upper_slack_multipliers<dim>].value('
p49675
aS'                    i, q_point);'
p49676
aS'                 * 2 and 3, are the variational derivatives of the'
p49677
aS'                 * Lagrangian with respect to the decision'
p49678
aS'                 * variables - the density, displacement, and'
p49679
aS'                 * unfiltered density. */'
p49680
aS'                cell_rhs(i) +='
p49681
aS'                  -1 * fe_values.JxW(q_point) *'
p49682
aS'                  (density_penalty_exponent *'
p49683
aS'                     std::pow(old_density_values[q_point],'
p49684
aS'                              density_penalty_exponent - 1) *'
p49685
aS'                     density_phi_i *'
p49686
aS'                     (old_displacement_multiplier_divs[q_point] *'
p49687
aS'                        old_displacement_divs[q_point] *'
p49688
aS'                        lambda_values[q_point] +'
p49689
aS'                      2 * mu_values[q_point] *'
p49690
aS'                        (old_displacement_symmgrads[q_point] *'
p49691
aS'                         old_displacement_multiplier_symmgrads[q_point])) -'
p49692
aS'                   density_phi_i *'
p49693
aS'                     old_unfiltered_density_multiplier_values[q_point]);'
p49694
aS'                 * below. */'
p49695
aS'                cell_rhs(i) +='
p49696
aS'                  -1 * fe_values.JxW(q_point) *'
p49697
aS'                  (std::pow(old_density_values[q_point],'
p49698
aS'                            density_penalty_exponent) *'
p49699
aS'                   (old_displacement_multiplier_divs[q_point] *'
p49700
aS'                      displacement_phi_i_div * lambda_values[q_point] +'
p49701
aS'                    2 * mu_values[q_point] *'
p49702
aS'                      (old_displacement_multiplier_symmgrads[q_point] *'
p49703
aS'                       displacement_phi_i_symmgrad)));'
p49704
aS'                cell_rhs(i) +='
p49705
aS'                  -1 * fe_values.JxW(q_point) *'
p49706
aS'                  (unfiltered_density_phi_i *'
p49707
aS'                     filter_adjoint_unfiltered_density_multiplier_values'
p49708
aS'                       [q_point] +'
p49709
aS'                   unfiltered_density_phi_i *'
p49710
aS'                     old_upper_slack_multiplier_values[q_point] +'
p49711
aS'                   -1 * unfiltered_density_phi_i *'
p49712
aS'                     old_lower_slack_multiplier_values[q_point]);'
p49713
aS'                 * with below. This equation being driven to 0'
p49714
aS'                 * ensures that the elasticity equation is met as'
p49715
aS'                 * a constraint. */'
p49716
aS'                cell_rhs(i) += -1 * fe_values.JxW(q_point) *'
p49717
aS'                               (std::pow(old_density_values[q_point],'
p49718
aS'                                         density_penalty_exponent) *'
p49719
aS'                                (old_displacement_divs[q_point] *'
p49720
aS'                                   displacement_multiplier_phi_i_div *'
p49721
aS'                                   lambda_values[q_point] +'
p49722
aS'                                 2 * mu_values[q_point] *'
p49723
aS'                                   (displacement_multiplier_phi_i_symmgrad *'
p49724
aS'                                    old_displacement_symmgrads[q_point])));'
p49725
aS'                 * variable equal to the unfiltered density,'
p49726
aS'                 * giving a minimum density of 0. */'
p49727
aS'                cell_rhs(i) += fe_values.JxW(q_point) *'
p49728
aS'                               (lower_slack_multiplier_phi_i *'
p49729
aS'                                (old_unfiltered_density_values[q_point] -'
p49730
aS'                                 old_lower_slack_values[q_point]));'
p49731
aS'                 * variable equal to one minus the unfiltered'
p49732
aS'                 * density. */'
p49733
aS'                cell_rhs(i) += fe_values.JxW(q_point) *'
p49734
aS'                               (upper_slack_multiplier_phi_i *'
p49735
aS'                                (1 - old_unfiltered_density_values[q_point] -'
p49736
aS'                                 old_upper_slack_values[q_point]));'
p49737
aS'                 * density and the filter applied to the'
p49738
aS'                 * unfiltered density. This being driven to 0 by'
p49739
aS'                 * the Newton steps ensures that the filter is'
p49740
aS'                 * applied correctly. */'
p49741
aS'                cell_rhs(i) += fe_values.JxW(q_point) *'
p49742
aS'                               (unfiltered_density_multiplier_phi_i *'
p49743
aS'                                (old_density_values[q_point] -'
p49744
aS'                                 filtered_unfiltered_density_values[q_point]));'
p49745
aS'                 * requirement that $s*z = \\alpha$ for the barrier'
p49746
aS'                 * size alpha, and gives complementary slackness'
p49747
aS'                 * from KKT conditions when $\\alpha$ goes to 0. */'
p49748
aS'                cell_rhs(i) +='
p49749
aS'                  -1 * fe_values.JxW(q_point) *'
p49750
aS'                  (lower_slack_phi_i *'
p49751
aS'                   (old_lower_slack_multiplier_values[q_point] -'
p49752
aS'                    barrier_size / old_lower_slack_values[q_point]));'
p49753
aS'                cell_rhs(i) +='
p49754
aS'                  -1 * fe_values.JxW(q_point) *'
p49755
aS'                  (upper_slack_phi_i *'
p49756
aS'                   (old_upper_slack_multiplier_values[q_point] -'
p49757
aS'                    barrier_size / old_upper_slack_values[q_point]));'
p49758
aS'              }'
p49759
aS'          }'
p49760
aS'        for (const auto &face : cell->face_iterators())'
p49761
aS'          {'
p49762
aS'            if (face->at_boundary() &&'
p49763
aS'                face->boundary_id() == BoundaryIds::down_force)'
p49764
aS'              {'
p49765
aS'                fe_face_values.reinit(cell, face);'
p49766
aS'                for (const auto face_q_point :'
p49767
aS'                     fe_face_values.quadrature_point_indices())'
p49768
aS'                  {'
p49769
aS'                    for (const auto i : fe_face_values.dof_indices())'
p49770
aS'                      {'
p49771
aS'                        Tensor<1, dim> traction;'
p49772
aS'                        traction[1] = -1.;'
p49773
aS'                        cell_rhs(i) +='
p49774
aS'                          -1 *'
p49775
aS'                          (traction * fe_face_values[displacements<dim>].value('
p49776
aS'                                        i, face_q_point)) *'
p49777
aS'                          fe_face_values.JxW(face_q_point);'
p49778
aS'                        cell_rhs(i) +='
p49779
aS'                          (traction *'
p49780
aS'                           fe_face_values[displacement_multipliers<dim>].value('
p49781
aS'                             i, face_q_point)) *'
p49782
aS'                          fe_face_values.JxW(face_q_point);'
p49783
aS'                      }'
p49784
aS'                  }'
p49785
aS'              }'
p49786
aS'          }'
p49787
aS'        MatrixTools::local_apply_boundary_values(boundary_values,'
p49788
aS'                                                 local_dof_indices,'
p49789
aS'                                                 dummy_cell_matrix,'
p49790
aS'                                                 cell_rhs,'
p49791
aS'                                                 true);'
p49792
aS'        constraints.distribute_local_to_global(cell_rhs,'
p49793
aS'                                               local_dof_indices,'
p49794
aS'                                               test_rhs);'
p49795
aS'      }'
p49796
aS'    return test_rhs;'
p49797
aS'  }'
p49798
aS'  template <int dim>'
p49799
aS'  double SANDTopOpt<dim>::calculate_exact_merit('
p49800
aS'    const BlockVector<double> &test_solution)'
p49801
aS'  {'
p49802
aS'    TimerOutput::Scope t(timer, "merit function");'
p49803
aS'    double objective_function_merit = 0;'
p49804
aS'    {'
p49805
aS'      MappingQGeneric<dim>  mapping(1);'
p49806
aS'      const QGauss<dim>     quadrature_formula(fe.degree + 1);'
p49807
aS'      const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p49808
aS'      FEValues<dim>         fe_values(mapping,'
p49809
aS'                              fe,'
p49810
aS'                              quadrature_formula,'
p49811
aS'                              update_values | update_gradients |'
p49812
aS'                                update_quadrature_points | update_JxW_values);'
p49813
aS'      FEFaceValues<dim>     fe_face_values(mapping,'
p49814
aS'                                       fe,'
p49815
aS'                                       face_quadrature_formula,'
p49816
aS'                                       update_values |'
p49817
aS'                                         update_quadrature_points |'
p49818
aS'                                         update_normal_vectors |'
p49819
aS'                                         update_JxW_values);'
p49820
aS'      const unsigned int n_face_q_points = face_quadrature_formula.size();'
p49821
aS'      std::vector<Tensor<1, dim>> displacement_face_values(n_face_q_points);'
p49822
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p49823
aS'        {'
p49824
aS'          for (const auto &face : cell->face_iterators())'
p49825
aS'            {'
p49826
aS'              if (face->at_boundary() &&'
p49827
aS'                  face->boundary_id() == BoundaryIds::down_force)'
p49828
aS'                {'
p49829
aS'                  fe_face_values.reinit(cell, face);'
p49830
aS'                  fe_face_values[ValueExtractors::displacements<dim>]'
p49831
aS'                    .get_function_values(test_solution,'
p49832
aS'                                         displacement_face_values);'
p49833
aS'                  for (unsigned int face_q_point = 0;'
p49834
aS'                       face_q_point < n_face_q_points;'
p49835
aS'                       ++face_q_point)'
p49836
aS'                    {'
p49837
aS'                      Tensor<1, dim> traction;'
p49838
aS'                      traction[1] = -1.;'
p49839
aS'                      objective_function_merit +='
p49840
aS'                        (traction * displacement_face_values[face_q_point]) *'
p49841
aS'                        fe_face_values.JxW(face_q_point);'
p49842
aS'                    }'
p49843
aS'                }'
p49844
aS'            }'
p49845
aS'        }'
p49846
aS'    }'
p49847
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p49848
aS'      {'
p49849
aS'        objective_function_merit ='
p49850
aS'          objective_function_merit -'
p49851
aS'          barrier_size * cell->measure() *'
p49852
aS'            std::log(test_solution.block('
p49853
aS'              SolutionBlocks::density_lower_slack)[cell->active_cell_index()]);'
p49854
aS'        objective_function_merit ='
p49855
aS'          objective_function_merit -'
p49856
aS'          barrier_size * cell->measure() *'
p49857
aS'            std::log(test_solution.block('
p49858
aS'              SolutionBlocks::density_upper_slack)[cell->active_cell_index()]);'
p49859
aS'      }'
p49860
aS'    const BlockVector<double> test_rhs = calculate_test_rhs(test_solution);'
p49861
aS'    const double elasticity_constraint_merit ='
p49862
aS'      penalty_multiplier *'
p49863
aS'      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();'
p49864
aS'    const double filter_constraint_merit ='
p49865
aS'      penalty_multiplier *'
p49866
aS'      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();'
p49867
aS'    const double lower_slack_merit ='
p49868
aS'      penalty_multiplier *'
p49869
aS'      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();'
p49870
aS'    const double upper_slack_merit ='
p49871
aS'      penalty_multiplier *'
p49872
aS'      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();'
p49873
aS'    const double total_merit ='
p49874
aS'      objective_function_merit + elasticity_constraint_merit +'
p49875
aS'      filter_constraint_merit + lower_slack_merit + upper_slack_merit;'
p49876
aS'    return total_merit;'
p49877
aS'  }'
p49878
aS'  template <int dim>'
p49879
aS'  BlockVector<double> SANDTopOpt<dim>::find_max_step()'
p49880
aS'  {'
p49881
aS'    assemble_system();'
p49882
aS'    BlockVector<double> step = solve();'
p49883
aS'    const std::vector<unsigned int> decision_variables = {'
p49884
aS'      SolutionBlocks::density,'
p49885
aS'      SolutionBlocks::displacement,'
p49886
aS'      SolutionBlocks::unfiltered_density,'
p49887
aS'      SolutionBlocks::density_upper_slack,'
p49888
aS'      SolutionBlocks::density_lower_slack};'
p49889
aS'    double hess_part = 0;'
p49890
aS'    double grad_part = 0;'
p49891
aS'    for (const unsigned int decision_variable_i : decision_variables)'
p49892
aS'      {'
p49893
aS'        for (const unsigned int decision_variable_j : decision_variables)'
p49894
aS'          {'
p49895
aS'            Vector<double> temp_vector(step.block(decision_variable_i).size());'
p49896
aS'            system_matrix.block(decision_variable_i, decision_variable_j)'
p49897
aS'              .vmult(temp_vector, step.block(decision_variable_j));'
p49898
aS'            hess_part += step.block(decision_variable_i) * temp_vector;'
p49899
aS'          }'
p49900
aS'        grad_part -= system_rhs.block(decision_variable_i) *'
p49901
aS'                     step.block(decision_variable_i);'
p49902
aS'      }'
p49903
aS'    const std::vector<unsigned int> equality_constraint_multipliers = {'
p49904
aS'      SolutionBlocks::displacement_multiplier,'
p49905
aS'      SolutionBlocks::unfiltered_density_multiplier,'
p49906
aS'      SolutionBlocks::density_lower_slack_multiplier,'
p49907
aS'      SolutionBlocks::density_upper_slack_multiplier};'
p49908
aS'    double constraint_norm = 0;'
p49909
aS'    for (unsigned int multiplier_i : equality_constraint_multipliers)'
p49910
aS'      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();'
p49911
aS'    double test_penalty_multiplier;'
p49912
aS'    if (hess_part > 0)'
p49913
aS'      test_penalty_multiplier ='
p49914
aS'        (grad_part + .5 * hess_part) / (.05 * constraint_norm);'
p49915
aS'    else'
p49916
aS'      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);'
p49917
aS'    penalty_multiplier = std::max(penalty_multiplier, test_penalty_multiplier);'
p49918
aS'    const std::pair<double, double> max_step_sizes ='
p49919
aS'      calculate_max_step_size(nonlinear_solution, step);'
p49920
aS'    const double step_size_s = max_step_sizes.first;'
p49921
aS'    const double step_size_z = max_step_sizes.second;'
p49922
aS'    step.block(SolutionBlocks::density) *= step_size_s;'
p49923
aS'    step.block(SolutionBlocks::displacement) *= step_size_s;'
p49924
aS'    step.block(SolutionBlocks::unfiltered_density) *= step_size_s;'
p49925
aS'    step.block(SolutionBlocks::displacement_multiplier) *= step_size_z;'
p49926
aS'    step.block(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;'
p49927
aS'    step.block(SolutionBlocks::density_lower_slack) *= step_size_s;'
p49928
aS'    step.block(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;'
p49929
aS'    step.block(SolutionBlocks::density_upper_slack) *= step_size_s;'
p49930
aS'    step.block(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;'
p49931
aS'    return step;'
p49932
aS'  }'
p49933
aS'  template <int dim>'
p49934
aS'  BlockVector<double>'
p49935
aS'  SANDTopOpt<dim>::compute_scaled_step(const BlockVector<double> &state,'
p49936
aS'                                       const BlockVector<double> &max_step,'
p49937
aS'                                       const double descent_requirement)'
p49938
aS'  {'
p49939
aS'    const double merit_derivative ='
p49940
aS'      (calculate_exact_merit(state + 1e-4 * max_step) -'
p49941
aS'       calculate_exact_merit(state)) /'
p49942
aS'      1e-4;'
p49943
aS'    double       step_size                 = 1;'
p49944
aS'    unsigned int max_linesearch_iterations = 10;'
p49945
aS'    for (unsigned int k = 0; k < max_linesearch_iterations; ++k)'
p49946
aS'      {'
p49947
aS'        if (calculate_exact_merit(state + step_size * max_step) <'
p49948
aS'            calculate_exact_merit(state) +'
p49949
aS'              step_size * descent_requirement * merit_derivative)'
p49950
aS'          break;'
p49951
aS'        else'
p49952
aS'          step_size = step_size / 2;'
p49953
aS'      }'
p49954
aS'    return state + (step_size * max_step);'
p49955
aS'  }'
p49956
aS'  template <int dim>'
p49957
aS'  bool SANDTopOpt<dim>::check_convergence(const BlockVector<double> &state)'
p49958
aS'  {'
p49959
aS'    const BlockVector<double> test_rhs      = calculate_test_rhs(state);'
p49960
aS'    const double              test_rhs_norm = test_rhs.l1_norm();'
p49961
aS'    const double convergence_condition = 1e-2;'
p49962
aS'    const double target_norm           = convergence_condition * barrier_size;'
p49963
aS'    std::cout << "    Checking convergence. Current rhs norm is "'
p49964
aS'              << test_rhs_norm << ", target is " << target_norm << std::endl;'
p49965
aS'    return (test_rhs_norm < target_norm);'
p49966
aS'  }'
p49967
aS'  template <int dim>'
p49968
aS'  void SANDTopOpt<dim>::output_results(const unsigned int iteration) const'
p49969
aS'  {'
p49970
aS'    std::vector<std::string> solution_names(1, "density");'
p49971
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p49972
aS'      data_component_interpretation('
p49973
aS'        1, DataComponentInterpretation::component_is_scalar);'
p49974
aS'    for (unsigned int i = 0; i < dim; ++i)'
p49975
aS'      {'
p49976
aS'        solution_names.emplace_back("displacement");'
p49977
aS'        data_component_interpretation.push_back('
p49978
aS'          DataComponentInterpretation::component_is_part_of_vector);'
p49979
aS'      }'
p49980
aS'    solution_names.emplace_back("unfiltered_density");'
p49981
aS'    data_component_interpretation.push_back('
p49982
aS'      DataComponentInterpretation::component_is_scalar);'
p49983
aS'    for (unsigned int i = 0; i < dim; ++i)'
p49984
aS'      {'
p49985
aS'        solution_names.emplace_back("displacement_multiplier");'
p49986
aS'        data_component_interpretation.push_back('
p49987
aS'          DataComponentInterpretation::component_is_part_of_vector);'
p49988
aS'      }'
p49989
aS'    solution_names.emplace_back("unfiltered_density_multiplier");'
p49990
aS'    data_component_interpretation.push_back('
p49991
aS'      DataComponentInterpretation::component_is_scalar);'
p49992
aS'    solution_names.emplace_back("low_slack");'
p49993
aS'    data_component_interpretation.push_back('
p49994
aS'      DataComponentInterpretation::component_is_scalar);'
p49995
aS'    solution_names.emplace_back("low_slack_multiplier");'
p49996
aS'    data_component_interpretation.push_back('
p49997
aS'      DataComponentInterpretation::component_is_scalar);'
p49998
aS'    solution_names.emplace_back("high_slack");'
p49999
aS'    data_component_interpretation.push_back('
p50000
aS'      DataComponentInterpretation::component_is_scalar);'
p50001
aS'    solution_names.emplace_back("high_slack_multiplier");'
p50002
aS'    data_component_interpretation.push_back('
p50003
aS'      DataComponentInterpretation::component_is_scalar);'
p50004
aS'    DataOut<dim> data_out;'
p50005
aS'    data_out.attach_dof_handler(dof_handler);'
p50006
aS'    data_out.add_data_vector(nonlinear_solution,'
p50007
aS'                             solution_names,'
p50008
aS'                             DataOut<dim>::type_dof_data,'
p50009
aS'                             data_component_interpretation);'
p50010
aS'    data_out.build_patches();'
p50011
aS'    std::ofstream output("solution" + std::to_string(iteration) + ".vtu");'
p50012
aS'    data_out.write_vtu(output);'
p50013
aS'  }'
p50014
aS'  template <int dim>'
p50015
aS'  void SANDTopOpt<dim>::write_as_stl()'
p50016
aS'  {'
p50017
aS'    static_assert(dim == 2,'
p50018
aS'                  "This function is not implemented for anything "'
p50019
aS'                  "other than the 2d case.");'
p50020
aS'    std::ofstream stlfile;'
p50021
aS'    stlfile.open("bridge.stl");'
p50022
aS'    stlfile << "solid bridge\\n" << std::scientific;'
p50023
aS'    double height = .25;'
p50024
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p50025
aS'      {'
p50026
aS'        if (nonlinear_solution.block('
p50027
aS'              SolutionBlocks::density)[cell->active_cell_index()] > 0.5)'
p50028
aS'          {'
p50029
aS'            const Tensor<1, dim> edge_directions[2] = {cell->vertex(1) -'
p50030
aS'                                                         cell->vertex(0),'
p50031
aS'                                                       cell->vertex(2) -'
p50032
aS'                                                         cell->vertex(0)};'
p50033
aS'            const Tensor<2, dim> edge_tensor('
p50034
aS'              {{edge_directions[0][0], edge_directions[0][1]},'
p50035
aS'               {edge_directions[1][0], edge_directions[1][1]}});'
p50036
aS'            const bool is_right_handed_cell = (determinant(edge_tensor) > 0);'
p50037
aS'            if (is_right_handed_cell)'
p50038
aS'              {'
p50039
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50040
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p50041
aS'                stlfile << "      outer loop\\n";'
p50042
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p50043
aS'                        << cell->vertex(0)[1] << " " << 0.000000e+00 << "\\n";'
p50044
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50045
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p50046
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50047
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p50048
aS'                stlfile << "      endloop\\n";'
p50049
aS'                stlfile << "   endfacet\\n";'
p50050
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50051
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p50052
aS'                stlfile << "      outer loop\\n";'
p50053
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50054
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p50055
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50056
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p50057
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p50058
aS'                        << cell->vertex(3)[1] << " " << 0.000000e+00 << "\\n";'
p50059
aS'                stlfile << "      endloop\\n";'
p50060
aS'                stlfile << "   endfacet\\n";'
p50061
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50062
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p50063
aS'                stlfile << "      outer loop\\n";'
p50064
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p50065
aS'                        << cell->vertex(0)[1] << " " << height << "\\n";'
p50066
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50067
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p50068
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50069
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p50070
aS'                stlfile << "      endloop\\n";'
p50071
aS'                stlfile << "   endfacet\\n";'
p50072
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50073
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p50074
aS'                stlfile << "      outer loop\\n";'
p50075
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50076
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p50077
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p50078
aS'                        << cell->vertex(3)[1] << " " << height << "\\n";'
p50079
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50080
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p50081
aS'                stlfile << "      endloop\\n";'
p50082
aS'                stlfile << "   endfacet\\n";'
p50083
aS'              }'
p50084
aS'            else /* The cell has a left-handed set up */'
p50085
aS'              {'
p50086
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50087
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p50088
aS'                stlfile << "      outer loop\\n";'
p50089
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p50090
aS'                        << cell->vertex(0)[1] << " " << 0.000000e+00 << "\\n";'
p50091
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50092
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p50093
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50094
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p50095
aS'                stlfile << "      endloop\\n";'
p50096
aS'                stlfile << "   endfacet\\n";'
p50097
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50098
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p50099
aS'                stlfile << "      outer loop\\n";'
p50100
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50101
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p50102
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p50103
aS'                        << cell->vertex(3)[1] << " " << 0.000000e+00 << "\\n";'
p50104
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50105
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p50106
aS'                stlfile << "      endloop\\n";'
p50107
aS'                stlfile << "   endfacet\\n";'
p50108
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50109
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p50110
aS'                stlfile << "      outer loop\\n";'
p50111
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p50112
aS'                        << cell->vertex(0)[1] << " " << height << "\\n";'
p50113
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50114
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p50115
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50116
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p50117
aS'                stlfile << "      endloop\\n";'
p50118
aS'                stlfile << "   endfacet\\n";'
p50119
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p50120
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p50121
aS'                stlfile << "      outer loop\\n";'
p50122
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p50123
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p50124
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p50125
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p50126
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p50127
aS'                        << cell->vertex(3)[1] << " " << height << "\\n";'
p50128
aS'                stlfile << "      endloop\\n";'
p50129
aS'                stlfile << "   endfacet\\n";'
p50130
aS'              }'
p50131
aS'            for (unsigned int face_number = 0;'
p50132
aS'                 face_number < GeometryInfo<dim>::faces_per_cell;'
p50133
aS'                 ++face_number)'
p50134
aS'              {'
p50135
aS'                const typename DoFHandler<dim>::face_iterator face ='
p50136
aS'                  cell->face(face_number);'
p50137
aS'                if ((face->at_boundary()) ||'
p50138
aS'                    (!face->at_boundary() &&'
p50139
aS'                     (nonlinear_solution.block('
p50140
aS'                        0)[cell->neighbor(face_number)->active_cell_index()] <'
p50141
aS'                      0.5)))'
p50142
aS'                  {'
p50143
aS'                    const Tensor<1, dim> normal_vector ='
p50144
aS'                      (face->center() - cell->center());'
p50145
aS'                    const double normal_norm = normal_vector.norm();'
p50146
aS'                    if ((face->vertex(0)[0] - face->vertex(0)[0]) *'
p50147
aS'                            (face->vertex(1)[1] - face->vertex(0)[1]) *'
p50148
aS'                            0.000000e+00 +'
p50149
aS'                          (face->vertex(0)[1] - face->vertex(0)[1]) * (0 - 0) *'
p50150
aS'                            normal_vector[0] +'
p50151
aS'                          (height - 0) *'
p50152
aS'                            (face->vertex(1)[0] - face->vertex(0)[0]) *'
p50153
aS'                            normal_vector[1] -'
p50154
aS'                          (face->vertex(0)[0] - face->vertex(0)[0]) * (0 - 0) *'
p50155
aS'                            normal_vector[1] -'
p50156
aS'                          (face->vertex(0)[1] - face->vertex(0)[1]) *'
p50157
aS'                            (face->vertex(1)[0] - face->vertex(0)[0]) *'
p50158
aS'                            normal_vector[0] -'
p50159
aS'                          (height - 0) *'
p50160
aS'                            (face->vertex(1)[1] - face->vertex(0)[1]) * 0 >'
p50161
aS'                        0)'
p50162
aS'                      {'
p50163
aS'                        stlfile << "   facet normal "'
p50164
aS'                                << normal_vector[0] / normal_norm << " "'
p50165
aS'                                << normal_vector[1] / normal_norm << " "'
p50166
aS'                                << 0.000000e+00 << "\\n";'
p50167
aS'                        stlfile << "      outer loop\\n";'
p50168
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p50169
aS'                                << " " << face->vertex(0)[1] << " "'
p50170
aS'                                << 0.000000e+00 << "\\n";'
p50171
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p50172
aS'                                << " " << face->vertex(0)[1] << " " << height'
p50173
aS'                                << "\\n";'
p50174
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p50175
aS'                                << " " << face->vertex(1)[1] << " "'
p50176
aS'                                << 0.000000e+00 << "\\n";'
p50177
aS'                        stlfile << "      endloop\\n";'
p50178
aS'                        stlfile << "   endfacet\\n";'
p50179
aS'                        stlfile << "   facet normal "'
p50180
aS'                                << normal_vector[0] / normal_norm << " "'
p50181
aS'                                << normal_vector[1] / normal_norm << " "'
p50182
aS'                                << 0.000000e+00 << "\\n";'
p50183
aS'                        stlfile << "      outer loop\\n";'
p50184
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p50185
aS'                                << " " << face->vertex(0)[1] << " " << height'
p50186
aS'                                << "\\n";'
p50187
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p50188
aS'                                << " " << face->vertex(1)[1] << " " << height'
p50189
aS'                                << "\\n";'
p50190
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p50191
aS'                                << " " << face->vertex(1)[1] << " "'
p50192
aS'                                << 0.000000e+00 << "\\n";'
p50193
aS'                        stlfile << "      endloop\\n";'
p50194
aS'                        stlfile << "   endfacet\\n";'
p50195
aS'                      }'
p50196
aS'                    else'
p50197
aS'                      {'
p50198
aS'                        stlfile << "   facet normal "'
p50199
aS'                                << normal_vector[0] / normal_norm << " "'
p50200
aS'                                << normal_vector[1] / normal_norm << " "'
p50201
aS'                                << 0.000000e+00 << "\\n";'
p50202
aS'                        stlfile << "      outer loop\\n";'
p50203
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p50204
aS'                                << " " << face->vertex(0)[1] << " "'
p50205
aS'                                << 0.000000e+00 << "\\n";'
p50206
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p50207
aS'                                << " " << face->vertex(1)[1] << " "'
p50208
aS'                                << 0.000000e+00 << "\\n";'
p50209
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p50210
aS'                                << " " << face->vertex(0)[1] << " " << height'
p50211
aS'                                << "\\n";'
p50212
aS'                        stlfile << "      endloop\\n";'
p50213
aS'                        stlfile << "   endfacet\\n";'
p50214
aS'                        stlfile << "   facet normal "'
p50215
aS'                                << normal_vector[0] / normal_norm << " "'
p50216
aS'                                << normal_vector[1] / normal_norm << " "'
p50217
aS'                                << 0.000000e+00 << "\\n";'
p50218
aS'                        stlfile << "      outer loop\\n";'
p50219
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p50220
aS'                                << " " << face->vertex(0)[1] << " " << height'
p50221
aS'                                << "\\n";'
p50222
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p50223
aS'                                << " " << face->vertex(1)[1] << " "'
p50224
aS'                                << 0.000000e+00 << "\\n";'
p50225
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p50226
aS'                                << " " << face->vertex(1)[1] << " " << height'
p50227
aS'                                << "\\n";'
p50228
aS'                        stlfile << "      endloop\\n";'
p50229
aS'                        stlfile << "   endfacet\\n";'
p50230
aS'                      }'
p50231
aS'                  }'
p50232
aS'              }'
p50233
aS'          }'
p50234
aS'      }'
p50235
aS'    stlfile << "endsolid bridge";'
p50236
aS'  }'
p50237
aS'  template <int dim>'
p50238
aS'  void SANDTopOpt<dim>::run()'
p50239
aS'  {'
p50240
aS'    std::cout << "filter r is: " << filter_r << std::endl;'
p50241
aS'    {'
p50242
aS'      TimerOutput::Scope t(timer, "setup");'
p50243
aS'      create_triangulation();'
p50244
aS'      dof_handler.distribute_dofs(fe);'
p50245
aS'      DoFRenumbering::component_wise(dof_handler);'
p50246
aS'      setup_boundary_values();'
p50247
aS'      setup_block_system();'
p50248
aS'      setup_filter_matrix();'
p50249
aS'    }'
p50250
aS'    barrier_size                  = 25;'
p50251
aS'    const double min_barrier_size = .0005;'
p50252
aS'    const unsigned int max_uphill_steps    = 8;'
p50253
aS'    const double       descent_requirement = .0001;'
p50254
aS'    unsigned int       iteration_number = 0;'
p50255
aS'    const unsigned int max_iterations   = 10000;'
p50256
aS'    do'
p50257
aS'      {'
p50258
aS'        std::cout << "Starting outer step in iteration " << iteration_number'
p50259
aS'                  << " with barrier parameter " << barrier_size << std::endl;'
p50260
aS'        do'
p50261
aS'          {'
p50262
aS'            std::cout << "  Starting inner step in iteration "'
p50263
aS'                      << iteration_number'
p50264
aS'                      << " with merit function penalty multiplier "'
p50265
aS'                      << penalty_multiplier << std::endl;'
p50266
aS'            bool watchdog_step_found = false;'
p50267
aS'            const BlockVector<double> watchdog_state = nonlinear_solution;'
p50268
aS'            BlockVector<double>       first_step;'
p50269
aS'            double target_merit     = numbers::signaling_nan<double>();'
p50270
aS'            double merit_derivative = numbers::signaling_nan<double>();'
p50271
aS'            for (unsigned int k = 0; k < max_uphill_steps; ++k)'
p50272
aS'              {'
p50273
aS'                ++iteration_number;'
p50274
aS'                const BlockVector<double> update_step = find_max_step();'
p50275
aS'                if (k == 0)'
p50276
aS'                  {'
p50277
aS'                    first_step = update_step;'
p50278
aS'                    merit_derivative ='
p50279
aS'                      ((calculate_exact_merit(watchdog_state +'
p50280
aS'                                              .0001 * first_step) -'
p50281
aS'                        calculate_exact_merit(watchdog_state)) /'
p50282
aS'                       .0001);'
p50283
aS'                    target_merit = calculate_exact_merit(watchdog_state) +'
p50284
aS'                                   descent_requirement * merit_derivative;'
p50285
aS'                  }'
p50286
aS'                nonlinear_solution += update_step;'
p50287
aS'                const double current_merit ='
p50288
aS'                  calculate_exact_merit(nonlinear_solution);'
p50289
aS'                std::cout << "    current watchdog state merit is: "'
p50290
aS'                          << current_merit << "; target merit is "'
p50291
aS'                          << target_merit << std::endl;'
p50292
aS'                if (current_merit < target_merit)'
p50293
aS'                  {'
p50294
aS'                    watchdog_step_found = true;'
p50295
aS'                    std::cout << "    found workable step after " << k + 1'
p50296
aS'                              << " iterations" << std::endl;'
p50297
aS'                    break;'
p50298
aS'                  }'
p50299
aS'              }'
p50300
aS'            if (watchdog_step_found == false)'
p50301
aS'              {'
p50302
aS'                ++iteration_number;'
p50303
aS'                const BlockVector<double> update_step = find_max_step();'
p50304
aS'                const BlockVector<double> stretch_state ='
p50305
aS'                  compute_scaled_step(nonlinear_solution,'
p50306
aS'                                      update_step,'
p50307
aS'                                      descent_requirement);'
p50308
aS'                if ((calculate_exact_merit(nonlinear_solution) <'
p50309
aS'                     calculate_exact_merit(watchdog_state)) ||'
p50310
aS'                    (calculate_exact_merit(stretch_state) < target_merit))'
p50311
aS'                  {'
p50312
aS'                    std::cout << "    Taking scaled step from end of watchdog"'
p50313
aS'                              << std::endl;'
p50314
aS'                    nonlinear_solution = stretch_state;'
p50315
aS'                  }'
p50316
aS'                else'
p50317
aS'                  {'
p50318
aS'                    std::cout'
p50319
aS'                      << "    Taking scaled step from beginning of watchdog"'
p50320
aS'                      << std::endl;'
p50321
aS'                    if (calculate_exact_merit(stretch_state) >'
p50322
aS'                        calculate_exact_merit(watchdog_state))'
p50323
aS'                      {'
p50324
aS'                        nonlinear_solution ='
p50325
aS'                          compute_scaled_step(watchdog_state,'
p50326
aS'                                              first_step,'
p50327
aS'                                              descent_requirement);'
p50328
aS'                      }'
p50329
aS'                    else'
p50330
aS'                      {'
p50331
aS'                        ++iteration_number;'
p50332
aS'                        nonlinear_solution = stretch_state;'
p50333
aS'                        const BlockVector<double> stretch_step ='
p50334
aS'                          find_max_step();'
p50335
aS'                        nonlinear_solution ='
p50336
aS'                          compute_scaled_step(nonlinear_solution,'
p50337
aS'                                              stretch_step,'
p50338
aS'                                              descent_requirement);'
p50339
aS'                      }'
p50340
aS'                  }'
p50341
aS'              }'
p50342
aS'            output_results(iteration_number);'
p50343
aS'          }'
p50344
aS'        while ((iteration_number < max_iterations) &&'
p50345
aS'               (check_convergence(nonlinear_solution) == false));'
p50346
aS'        const double barrier_size_multiplier = .8;'
p50347
aS'        const double barrier_size_exponent   = 1.2;'
p50348
aS'        barrier_size ='
p50349
aS'          std::max(std::min(barrier_size * barrier_size_multiplier,'
p50350
aS'                            std::pow(barrier_size, barrier_size_exponent)),'
p50351
aS'                   min_barrier_size);'
p50352
aS'        std::cout << std::endl;'
p50353
aS'      }'
p50354
aS'    while (((barrier_size > min_barrier_size) ||'
p50355
aS'            (check_convergence(nonlinear_solution) == false)) &&'
p50356
aS'           (iteration_number < max_iterations));'
p50357
aS'    write_as_stl();'
p50358
aS'    timer.print_summary();'
p50359
aS'  }'
p50360
aS'} // namespace SAND'
p50361
aS'int main()'
p50362
ag24
aS'  try'
p50363
aS'    {'
p50364
aS'      SAND::SANDTopOpt<2> elastic_problem_2d;'
p50365
aS'      elastic_problem_2d.run();'
p50366
aS'    }'
p50367
aS'  catch (std::exception &exc)'
p50368
aS'    {'
p50369
aS'      std::cerr << std::endl'
p50370
aS'                << std::endl'
p50371
aS'                << "----------------------------------------------------"'
p50372
aS'                << std::endl;'
p50373
aS'      std::cerr << "Exception on processing: " << std::endl'
p50374
aS'                << exc.what() << std::endl'
p50375
aS'                << "Aborting!" << std::endl'
p50376
aS'                << "----------------------------------------------------"'
p50377
aS'                << std::endl;'
p50378
aS'      return 1;'
p50379
aS'    }'
p50380
aS'  catch (...)'
p50381
aS'    {'
p50382
aS'      std::cerr << std::endl'
p50383
aS'                << std::endl'
p50384
aS'                << "----------------------------------------------------"'
p50385
aS'                << std::endl;'
p50386
aS'      std::cerr << "Unknown exception!" << std::endl'
p50387
aS'                << "Aborting!" << std::endl'
p50388
aS'                << "----------------------------------------------------"'
p50389
aS'                << std::endl;'
p50390
aS'      return 1;'
p50391
aS'    }'
p50392
aS'  return 0;'
p50393
ag32
aS'/* ---------------------------------------------------------------------'
p50394
aS' *'
p50395
aS' * Copyright (C) 2000 - 2021 by the deal.II authors'
p50396
aS' *'
p50397
aS' * This file is part of the deal.II library.'
p50398
aS' *'
p50399
aS' * The deal.II library is free software; you can use it, redistribute'
p50400
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p50401
aS' * Public License as published by the Free Software Foundation; either'
p50402
aS' * version 2.1 of the License, or (at your option) any later version.'
p50403
aS' * The full text of the license can be found in the file LICENSE.md at'
p50404
aS' * the top level directory of deal.II.'
p50405
aS' *'
p50406
aS' * ---------------------------------------------------------------------'
p50407
aS' *'
p50408
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 2000'
p50409
aS' */'
p50410
aS'#include <deal.II/base/quadrature_lib.h>'
p50411
aS'#include <deal.II/base/function.h>'
p50412
aS'#include <deal.II/base/tensor.h>'
p50413
aS'#include <deal.II/lac/vector.h>'
p50414
aS'#include <deal.II/lac/full_matrix.h>'
p50415
aS'#include <deal.II/lac/sparse_matrix.h>'
p50416
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p50417
aS'#include <deal.II/lac/solver_cg.h>'
p50418
aS'#include <deal.II/lac/precondition.h>'
p50419
aS'#include <deal.II/lac/affine_constraints.h>'
p50420
aS'#include <deal.II/grid/tria.h>'
p50421
aS'#include <deal.II/grid/grid_generator.h>'
p50422
aS'#include <deal.II/grid/grid_refinement.h>'
p50423
aS'#include <deal.II/dofs/dof_handler.h>'
p50424
aS'#include <deal.II/dofs/dof_tools.h>'
p50425
aS'#include <deal.II/fe/fe_values.h>'
p50426
aS'#include <deal.II/numerics/vector_tools.h>'
p50427
aS'#include <deal.II/numerics/matrix_tools.h>'
p50428
aS'#include <deal.II/numerics/data_out.h>'
p50429
aS'#include <deal.II/numerics/error_estimator.h>'
p50430
aS'#include <deal.II/fe/fe_system.h>'
p50431
aS'#include <deal.II/fe/fe_q.h>'
p50432
aS'#include <fstream>'
p50433
aS'#include <iostream>'
p50434
aS'namespace Step8'
p50435
ag24
aS'  using namespace dealii;'
p50436
aS'  template <int dim>'
p50437
aS'  class ElasticProblem'
p50438
aS'  {'
p50439
aS'  public:'
p50440
aS'    ElasticProblem();'
p50441
aS'    void run();'
p50442
aS'  private:'
p50443
aS'    void setup_system();'
p50444
aS'    void assemble_system();'
p50445
aS'    void solve();'
p50446
aS'    void refine_grid();'
p50447
aS'    void output_results(const unsigned int cycle) const;'
p50448
aS'    Triangulation<dim> triangulation;'
p50449
aS'    DoFHandler<dim>    dof_handler;'
p50450
aS'    FESystem<dim> fe;'
p50451
aS'    AffineConstraints<double> constraints;'
p50452
aS'    SparsityPattern      sparsity_pattern;'
p50453
aS'    SparseMatrix<double> system_matrix;'
p50454
aS'    Vector<double> solution;'
p50455
aS'    Vector<double> system_rhs;'
p50456
aS'  };'
p50457
aS'  template <int dim>'
p50458
aS'  void right_hand_side(const std::vector<Point<dim>> &points,'
p50459
aS'                       std::vector<Tensor<1, dim>> &  values)'
p50460
aS'  {'
p50461
aS'    Assert(values.size() == points.size(),'
p50462
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p50463
aS'    Assert(dim >= 2, ExcNotImplemented());'
p50464
aS'    Point<dim> point_1, point_2;'
p50465
aS'    point_1(0) = 0.5;'
p50466
aS'    point_2(0) = -0.5;'
p50467
aS'    for (unsigned int point_n = 0; point_n < points.size(); ++point_n)'
p50468
aS'      {'
p50469
aS'        if (((points[point_n] - point_1).norm_square() < 0.2 * 0.2) ||'
p50470
aS'            ((points[point_n] - point_2).norm_square() < 0.2 * 0.2))'
p50471
aS'          values[point_n][0] = 1.0;'
p50472
aS'        else'
p50473
aS'          values[point_n][0] = 0.0;'
p50474
aS'        if (points[point_n].norm_square() < 0.2 * 0.2)'
p50475
aS'          values[point_n][1] = 1.0;'
p50476
aS'        else'
p50477
aS'          values[point_n][1] = 0.0;'
p50478
aS'      }'
p50479
aS'  }'
p50480
aS'  template <int dim>'
p50481
aS'  ElasticProblem<dim>::ElasticProblem()'
p50482
aS'    : dof_handler(triangulation)'
p50483
aS'    , fe(FE_Q<dim>(1), dim)'
p50484
aS'  {}'
p50485
aS'  template <int dim>'
p50486
aS'  void ElasticProblem<dim>::setup_system()'
p50487
aS'  {'
p50488
aS'    dof_handler.distribute_dofs(fe);'
p50489
aS'    solution.reinit(dof_handler.n_dofs());'
p50490
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p50491
aS'    constraints.clear();'
p50492
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p50493
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p50494
aS'                                             0,'
p50495
aS'                                             Functions::ZeroFunction<dim>(dim),'
p50496
aS'                                             constraints);'
p50497
aS'    constraints.close();'
p50498
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p50499
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p50500
aS'                                    dsp,'
p50501
aS'                                    constraints,'
p50502
aS'    sparsity_pattern.copy_from(dsp);'
p50503
aS'    system_matrix.reinit(sparsity_pattern);'
p50504
aS'  }'
p50505
aS'  template <int dim>'
p50506
aS'  void ElasticProblem<dim>::assemble_system()'
p50507
aS'  {'
p50508
aS'    QGauss<dim> quadrature_formula(fe.degree + 1);'
p50509
aS'    FEValues<dim> fe_values(fe,'
p50510
aS'                            quadrature_formula,'
p50511
aS'                            update_values | update_gradients |'
p50512
aS'                              update_quadrature_points | update_JxW_values);'
p50513
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p50514
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p50515
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p50516
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p50517
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p50518
aS'    std::vector<double> lambda_values(n_q_points);'
p50519
aS'    std::vector<double> mu_values(n_q_points);'
p50520
aS'    Functions::ConstantFunction<dim> lambda(1.), mu(1.);'
p50521
aS'    std::vector<Tensor<1, dim>> rhs_values(n_q_points);'
p50522
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p50523
aS'      {'
p50524
aS'        cell_matrix = 0;'
p50525
aS'        cell_rhs    = 0;'
p50526
aS'        fe_values.reinit(cell);'
p50527
aS'        lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p50528
aS'        mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p50529
aS'        right_hand_side(fe_values.get_quadrature_points(), rhs_values);'
p50530
aS'        for (const unsigned int i : fe_values.dof_indices())'
p50531
aS'          {'
p50532
aS'            const unsigned int component_i ='
p50533
aS'              fe.system_to_component_index(i).first;'
p50534
aS'            for (const unsigned int j : fe_values.dof_indices())'
p50535
aS'              {'
p50536
aS'                const unsigned int component_j ='
p50537
aS'                  fe.system_to_component_index(j).first;'
p50538
aS'                for (const unsigned int q_point :'
p50539
aS'                     fe_values.quadrature_point_indices())'
p50540
aS'                  {'
p50541
aS'                    cell_matrix(i, j) +='
p50542
aS'                      (                                                  //'
p50543
aS'                        (fe_values.shape_grad(i, q_point)[component_i] * //'
p50544
aS'                         fe_values.shape_grad(j, q_point)[component_j] * //'
p50545
aS'                         lambda_values[q_point])                         //'
p50546
aS'                        +                                                //'
p50547
aS'                        (fe_values.shape_grad(i, q_point)[component_j] * //'
p50548
aS'                         fe_values.shape_grad(j, q_point)[component_i] * //'
p50549
aS'                         mu_values[q_point])                             //'
p50550
aS'                        +                                                //'
p50551
aS'                        ((component_i == component_j) ?        //'
p50552
aS'                           (fe_values.shape_grad(i, q_point) * //'
p50553
aS'                            fe_values.shape_grad(j, q_point) * //'
p50554
aS'                            mu_values[q_point]) :              //'
p50555
aS'                           0)                                  //'
p50556
aS'                        ) *                                    //'
p50557
aS'                      fe_values.JxW(q_point);                  //'
p50558
aS'                  }'
p50559
aS'              }'
p50560
aS'          }'
p50561
aS'        for (const unsigned int i : fe_values.dof_indices())'
p50562
aS'          {'
p50563
aS'            const unsigned int component_i ='
p50564
aS'              fe.system_to_component_index(i).first;'
p50565
aS'            for (const unsigned int q_point :'
p50566
aS'                 fe_values.quadrature_point_indices())'
p50567
aS'              cell_rhs(i) += fe_values.shape_value(i, q_point) *'
p50568
aS'                             rhs_values[q_point][component_i] *'
p50569
aS'                             fe_values.JxW(q_point);'
p50570
aS'          }'
p50571
aS'        cell->get_dof_indices(local_dof_indices);'
p50572
aS'        constraints.distribute_local_to_global('
p50573
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p50574
aS'      }'
p50575
aS'  }'
p50576
aS'  template <int dim>'
p50577
aS'  void ElasticProblem<dim>::solve()'
p50578
aS'  {'
p50579
aS'    SolverControl            solver_control(1000, 1e-12);'
p50580
aS'    SolverCG<Vector<double>> cg(solver_control);'
p50581
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p50582
aS'    preconditioner.initialize(system_matrix, 1.2);'
p50583
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p50584
aS'    constraints.distribute(solution);'
p50585
aS'  }'
p50586
aS'  template <int dim>'
p50587
aS'  void ElasticProblem<dim>::refine_grid()'
p50588
aS'  {'
p50589
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p50590
aS'    KellyErrorEstimator<dim>::estimate(dof_handler,'
p50591
aS'                                       QGauss<dim - 1>(fe.degree + 1),'
p50592
aS'                                       {},'
p50593
aS'                                       solution,'
p50594
aS'                                       estimated_error_per_cell);'
p50595
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p50596
aS'                                                    estimated_error_per_cell,'
p50597
aS'                                                    0.3,'
p50598
aS'                                                    0.03);'
p50599
aS'    triangulation.execute_coarsening_and_refinement();'
p50600
aS'  }'
p50601
aS'  template <int dim>'
p50602
aS'  void ElasticProblem<dim>::output_results(const unsigned int cycle) const'
p50603
aS'  {'
p50604
aS'    DataOut<dim> data_out;'
p50605
aS'    data_out.attach_dof_handler(dof_handler);'
p50606
aS'    std::vector<std::string> solution_names;'
p50607
aS'    switch (dim)'
p50608
aS'      {'
p50609
aS'        case 1:'
p50610
aS'          solution_names.emplace_back("displacement");'
p50611
aS'          break;'
p50612
aS'        case 2:'
p50613
aS'          solution_names.emplace_back("x_displacement");'
p50614
aS'          solution_names.emplace_back("y_displacement");'
p50615
aS'          break;'
p50616
aS'        case 3:'
p50617
aS'          solution_names.emplace_back("x_displacement");'
p50618
aS'          solution_names.emplace_back("y_displacement");'
p50619
aS'          solution_names.emplace_back("z_displacement");'
p50620
aS'          break;'
p50621
aS'        default:'
p50622
aS'          Assert(false, ExcNotImplemented());'
p50623
aS'      }'
p50624
aS'    data_out.add_data_vector(solution, solution_names);'
p50625
aS'    data_out.build_patches();'
p50626
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p50627
aS'    data_out.write_vtk(output);'
p50628
aS'  }'
p50629
aS'  template <int dim>'
p50630
aS'  void ElasticProblem<dim>::run()'
p50631
aS'  {'
p50632
aS'    for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p50633
aS'      {'
p50634
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p50635
aS'        if (cycle == 0)'
p50636
aS'          {'
p50637
aS'            GridGenerator::hyper_cube(triangulation, -1, 1);'
p50638
aS'            triangulation.refine_global(4);'
p50639
aS'          }'
p50640
aS'        else'
p50641
aS'          refine_grid();'
p50642
aS'        std::cout << "   Number of active cells:       "'
p50643
aS'                  << triangulation.n_active_cells() << std::endl;'
p50644
aS'        setup_system();'
p50645
aS'        std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p50646
aS'                  << std::endl;'
p50647
aS'        assemble_system();'
p50648
aS'        solve();'
p50649
aS'        output_results(cycle);'
p50650
aS'      }'
p50651
aS'  }'
p50652
aS'} // namespace Step8'
p50653
aS'int main()'
p50654
ag24
aS'  try'
p50655
aS'    {'
p50656
aS'      Step8::ElasticProblem<2> elastic_problem_2d;'
p50657
aS'      elastic_problem_2d.run();'
p50658
aS'    }'
p50659
aS'  catch (std::exception &exc)'
p50660
aS'    {'
p50661
aS'      std::cerr << std::endl'
p50662
aS'                << std::endl'
p50663
aS'                << "----------------------------------------------------"'
p50664
aS'                << std::endl;'
p50665
aS'      std::cerr << "Exception on processing: " << std::endl'
p50666
aS'                << exc.what() << std::endl'
p50667
aS'                << "Aborting!" << std::endl'
p50668
aS'                << "----------------------------------------------------"'
p50669
aS'                << std::endl;'
p50670
aS'      return 1;'
p50671
aS'    }'
p50672
aS'  catch (...)'
p50673
aS'    {'
p50674
aS'      std::cerr << std::endl'
p50675
aS'                << std::endl'
p50676
aS'                << "----------------------------------------------------"'
p50677
aS'                << std::endl;'
p50678
aS'      std::cerr << "Unknown exception!" << std::endl'
p50679
aS'                << "Aborting!" << std::endl'
p50680
aS'                << "----------------------------------------------------"'
p50681
aS'                << std::endl;'
p50682
aS'      return 1;'
p50683
aS'    }'
p50684
aS'  return 0;'
p50685
ag32
aS'/* ---------------------------------------------------------------------'
p50686
aS' *'
p50687
aS' * Copyright (C) 2000 - 2021 by the deal.II authors'
p50688
aS' *'
p50689
aS' * This file is part of the deal.II library.'
p50690
aS' *'
p50691
aS' * The deal.II library is free software; you can use it, redistribute'
p50692
aS' * it, and/or modify it under the terms of the GNU Lesser General'
p50693
aS' * Public License as published by the Free Software Foundation; either'
p50694
aS' * version 2.1 of the License, or (at your option) any later version.'
p50695
aS' * The full text of the license can be found in the file LICENSE.md at'
p50696
aS' * the top level directory of deal.II.'
p50697
aS' *'
p50698
aS' * ---------------------------------------------------------------------'
p50699
aS' *'
p50700
aS' * Author: Wolfgang Bangerth, University of Heidelberg, 2000'
p50701
aS' */'
p50702
aS'#include <deal.II/base/quadrature_lib.h>'
p50703
aS'#include <deal.II/base/function.h>'
p50704
aS'#include <deal.II/base/logstream.h>'
p50705
aS'#include <deal.II/lac/vector.h>'
p50706
aS'#include <deal.II/lac/full_matrix.h>'
p50707
aS'#include <deal.II/lac/sparse_matrix.h>'
p50708
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p50709
aS'#include <deal.II/lac/solver_gmres.h>'
p50710
aS'#include <deal.II/lac/precondition.h>'
p50711
aS'#include <deal.II/lac/affine_constraints.h>'
p50712
aS'#include <deal.II/grid/tria.h>'
p50713
aS'#include <deal.II/grid/grid_generator.h>'
p50714
aS'#include <deal.II/grid/grid_refinement.h>'
p50715
aS'#include <deal.II/dofs/dof_handler.h>'
p50716
aS'#include <deal.II/dofs/dof_tools.h>'
p50717
aS'#include <deal.II/fe/fe_values.h>'
p50718
aS'#include <deal.II/numerics/vector_tools.h>'
p50719
aS'#include <deal.II/numerics/matrix_tools.h>'
p50720
aS'#include <deal.II/numerics/data_out.h>'
p50721
aS'#include <deal.II/fe/fe_q.h>'
p50722
aS'#include <deal.II/grid/grid_out.h>'
p50723
aS'#include <deal.II/base/work_stream.h>'
p50724
aS'#include <deal.II/base/multithread_info.h>'
p50725
aS'#include <deal.II/base/tensor_function.h>'
p50726
aS'#include <deal.II/numerics/error_estimator.h>'
p50727
aS'#include <fstream>'
p50728
aS'#include <iostream>'
p50729
aS'namespace Step9'
p50730
ag24
aS'  using namespace dealii;'
p50731
aS'  template <int dim>'
p50732
aS'  class AdvectionField : public TensorFunction<1, dim>'
p50733
aS'  {'
p50734
aS'  public:'
p50735
aS'    virtual Tensor<1, dim> value(const Point<dim> &p) const override;'
p50736
aS'    DeclException2(ExcDimensionMismatch,'
p50737
aS'                   unsigned int,'
p50738
aS'                   unsigned int,'
p50739
aS'                   << "The vector has size " << arg1 << " but should have "'
p50740
aS'                   << arg2 << " elements.");'
p50741
aS'  };'
p50742
aS'  template <int dim>'
p50743
aS'  Tensor<1, dim> AdvectionField<dim>::value(const Point<dim> &p) const'
p50744
aS'  {'
p50745
aS'    Tensor<1, dim> value;'
p50746
aS'    value[0] = 2;'
p50747
aS'    for (unsigned int i = 1; i < dim; ++i)'
p50748
aS'      value[i] = 1 + 0.8 * std::sin(8. * numbers::PI * p[0]);'
p50749
aS'    return value;'
p50750
aS'  }'
p50751
aS'  template <int dim>'
p50752
aS'  class RightHandSide : public Function<dim>'
p50753
aS'  {'
p50754
aS'  public:'
p50755
aS'    virtual double value(const Point<dim> & p,'
p50756
aS'                         const unsigned int component = 0) const override;'
p50757
aS'  private:'
p50758
aS'    static const Point<dim> center_point;'
p50759
aS'  };'
p50760
aS'  template <>'
p50761
aS'  const Point<1> RightHandSide<1>::center_point = Point<1>(-0.75);'
p50762
aS'  template <>'
p50763
aS'  const Point<2> RightHandSide<2>::center_point = Point<2>(-0.75, -0.75);'
p50764
aS'  template <>'
p50765
aS'  const Point<3> RightHandSide<3>::center_point = Point<3>(-0.75, -0.75, -0.75);'
p50766
aS'  template <int dim>'
p50767
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p50768
aS'                                   const unsigned int component) const'
p50769
aS'  {'
p50770
aS'    (void)component;'
p50771
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p50772
aS'    const double diameter = 0.1;'
p50773
aS'    return ((p - center_point).norm_square() < diameter * diameter ?'
p50774
aS'              0.1 / std::pow(diameter, dim) :'
p50775
aS'              0.0);'
p50776
aS'  }'
p50777
aS'  template <int dim>'
p50778
aS'  class BoundaryValues : public Function<dim>'
p50779
aS'  {'
p50780
aS'  public:'
p50781
aS'    virtual double value(const Point<dim> & p,'
p50782
aS'                         const unsigned int component = 0) const override;'
p50783
aS'  };'
p50784
aS'  template <int dim>'
p50785
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p50786
aS'                                    const unsigned int component) const'
p50787
aS'  {'
p50788
aS'    (void)component;'
p50789
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p50790
aS'    const double sine_term = std::sin(16. * numbers::PI * p.norm_square());'
p50791
aS'    const double weight    = std::exp(5. * (1. - p.norm_square()));'
p50792
aS'    return weight * sine_term;'
p50793
aS'  }'
p50794
aS'  template <int dim>'
p50795
aS'  class AdvectionProblem'
p50796
aS'  {'
p50797
aS'  public:'
p50798
aS'    AdvectionProblem();'
p50799
aS'    void run();'
p50800
aS'  private:'
p50801
aS'    void setup_system();'
p50802
aS'    struct AssemblyScratchData'
p50803
aS'    {'
p50804
aS'      AssemblyScratchData(const FiniteElement<dim> &fe);'
p50805
aS'      AssemblyScratchData(const AssemblyScratchData &scratch_data);'
p50806
aS'      FEValues<dim>     fe_values;'
p50807
aS'      FEFaceValues<dim> fe_face_values;'
p50808
aS'      std::vector<double>         rhs_values;'
p50809
aS'      std::vector<Tensor<1, dim>> advection_directions;'
p50810
aS'      std::vector<double>         face_boundary_values;'
p50811
aS'      std::vector<Tensor<1, dim>> face_advection_directions;'
p50812
aS'      AdvectionField<dim> advection_field;'
p50813
aS'      RightHandSide<dim>  right_hand_side;'
p50814
aS'      BoundaryValues<dim> boundary_values;'
p50815
aS'    };'
p50816
aS'    struct AssemblyCopyData'
p50817
aS'    {'
p50818
aS'      FullMatrix<double>                   cell_matrix;'
p50819
aS'      Vector<double>                       cell_rhs;'
p50820
aS'      std::vector<types::global_dof_index> local_dof_indices;'
p50821
aS'    };'
p50822
aS'    void assemble_system();'
p50823
aS'    void local_assemble_system('
p50824
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p50825
aS'      AssemblyScratchData &                                 scratch,'
p50826
aS'      AssemblyCopyData &                                    copy_data);'
p50827
aS'    void copy_local_to_global(const AssemblyCopyData &copy_data);'
p50828
aS'    void solve();'
p50829
aS'    void refine_grid();'
p50830
aS'    void output_results(const unsigned int cycle) const;'
p50831
aS'    Triangulation<dim> triangulation;'
p50832
aS'    DoFHandler<dim>    dof_handler;'
p50833
aS'    FE_Q<dim> fe;'
p50834
aS'    AffineConstraints<double> hanging_node_constraints;'
p50835
aS'    SparsityPattern      sparsity_pattern;'
p50836
aS'    SparseMatrix<double> system_matrix;'
p50837
aS'    Vector<double> solution;'
p50838
aS'    Vector<double> system_rhs;'
p50839
aS'  };'
p50840
aS'  class GradientEstimation'
p50841
aS'  {'
p50842
aS'  public:'
p50843
aS'    template <int dim>'
p50844
aS'    static void estimate(const DoFHandler<dim> &dof,'
p50845
aS'                         const Vector<double> & solution,'
p50846
aS'                         Vector<float> &        error_per_cell);'
p50847
aS'    DeclException2(ExcInvalidVectorLength,'
p50848
aS'                   int,'
p50849
aS'                   int,'
p50850
aS'                   << "Vector has length " << arg1 << ", but should have "'
p50851
aS'                   << arg2);'
p50852
aS'    DeclException0(ExcInsufficientDirections);'
p50853
aS'  private:'
p50854
aS'    template <int dim>'
p50855
aS'    struct EstimateScratchData'
p50856
aS'    {'
p50857
aS'      EstimateScratchData(const FiniteElement<dim> &fe,'
p50858
aS'                          const Vector<double> &    solution,'
p50859
aS'                          Vector<float> &           error_per_cell);'
p50860
aS'      EstimateScratchData(const EstimateScratchData &data);'
p50861
aS'      FEValues<dim> fe_midpoint_value;'
p50862
aS'      std::vector<typename DoFHandler<dim>::active_cell_iterator>'
p50863
aS'        active_neighbors;'
p50864
aS'      const Vector<double> &solution;'
p50865
aS'      Vector<float> &       error_per_cell;'
p50866
aS'      std::vector<double> cell_midpoint_value;'
p50867
aS'      std::vector<double> neighbor_midpoint_value;'
p50868
aS'    };'
p50869
aS'    struct EstimateCopyData'
p50870
aS'    {};'
p50871
aS'    template <int dim>'
p50872
aS'    static void'
p50873
aS'    estimate_cell(const typename DoFHandler<dim>::active_cell_iterator &cell,'
p50874
aS'                  EstimateScratchData<dim> &scratch_data,'
p50875
aS'                  const EstimateCopyData &  copy_data);'
p50876
aS'  };'
p50877
aS'  template <int dim>'
p50878
aS'  AdvectionProblem<dim>::AdvectionProblem()'
p50879
aS'    : dof_handler(triangulation)'
p50880
aS'    , fe(5)'
p50881
aS'  {}'
p50882
aS'  template <int dim>'
p50883
aS'  void AdvectionProblem<dim>::setup_system()'
p50884
aS'  {'
p50885
aS'    dof_handler.distribute_dofs(fe);'
p50886
aS'    hanging_node_constraints.clear();'
p50887
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p50888
aS'                                            hanging_node_constraints);'
p50889
aS'    hanging_node_constraints.close();'
p50890
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p50891
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p50892
aS'                                    dsp,'
p50893
aS'                                    hanging_node_constraints,'
p50894
aS'    sparsity_pattern.copy_from(dsp);'
p50895
aS'    system_matrix.reinit(sparsity_pattern);'
p50896
aS'    solution.reinit(dof_handler.n_dofs());'
p50897
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p50898
aS'  }'
p50899
aS'  template <int dim>'
p50900
aS'  void AdvectionProblem<dim>::assemble_system()'
p50901
aS'  {'
p50902
aS'    WorkStream::run(dof_handler.begin_active(),'
p50903
aS'                    dof_handler.end(),'
p50904
aS'                    *this,'
p50905
aS'                    &AdvectionProblem::local_assemble_system,'
p50906
aS'                    &AdvectionProblem::copy_local_to_global,'
p50907
aS'                    AssemblyScratchData(fe),'
p50908
aS'                    AssemblyCopyData());'
p50909
aS'  }'
p50910
aS'  template <int dim>'
p50911
aS'  AdvectionProblem<dim>::AssemblyScratchData::AssemblyScratchData('
p50912
aS'    const FiniteElement<dim> &fe)'
p50913
aS'    : fe_values(fe,'
p50914
aS'                QGauss<dim>(fe.degree + 1),'
p50915
aS'                update_values | update_gradients | update_quadrature_points |'
p50916
aS'                  update_JxW_values)'
p50917
aS'    , fe_face_values(fe,'
p50918
aS'                     QGauss<dim - 1>(fe.degree + 1),'
p50919
aS'                     update_values | update_quadrature_points |'
p50920
aS'                       update_JxW_values | update_normal_vectors)'
p50921
aS'    , rhs_values(fe_values.get_quadrature().size())'
p50922
aS'    , advection_directions(fe_values.get_quadrature().size())'
p50923
aS'    , face_boundary_values(fe_face_values.get_quadrature().size())'
p50924
aS'    , face_advection_directions(fe_face_values.get_quadrature().size())'
p50925
aS'  {}'
p50926
aS'  template <int dim>'
p50927
aS'  AdvectionProblem<dim>::AssemblyScratchData::AssemblyScratchData('
p50928
aS'    const AssemblyScratchData &scratch_data)'
p50929
aS'    : fe_values(scratch_data.fe_values.get_fe(),'
p50930
aS'                scratch_data.fe_values.get_quadrature(),'
p50931
aS'                update_values | update_gradients | update_quadrature_points |'
p50932
aS'                  update_JxW_values)'
p50933
aS'    , fe_face_values(scratch_data.fe_face_values.get_fe(),'
p50934
aS'                     scratch_data.fe_face_values.get_quadrature(),'
p50935
aS'                     update_values | update_quadrature_points |'
p50936
aS'                       update_JxW_values | update_normal_vectors)'
p50937
aS'    , rhs_values(scratch_data.rhs_values.size())'
p50938
aS'    , advection_directions(scratch_data.advection_directions.size())'
p50939
aS'    , face_boundary_values(scratch_data.face_boundary_values.size())'
p50940
aS'    , face_advection_directions(scratch_data.face_advection_directions.size())'
p50941
aS'  {}'
p50942
aS'  template <int dim>'
p50943
aS'  void AdvectionProblem<dim>::local_assemble_system('
p50944
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p50945
aS'    AssemblyScratchData &                                 scratch_data,'
p50946
aS'    AssemblyCopyData &                                    copy_data)'
p50947
aS'  {'
p50948
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p50949
aS'    const unsigned int n_q_points ='
p50950
aS'      scratch_data.fe_values.get_quadrature().size();'
p50951
aS'    const unsigned int n_face_q_points ='
p50952
aS'      scratch_data.fe_face_values.get_quadrature().size();'
p50953
aS'    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p50954
aS'    copy_data.cell_rhs.reinit(dofs_per_cell);'
p50955
aS'    copy_data.local_dof_indices.resize(dofs_per_cell);'
p50956
aS'    scratch_data.fe_values.reinit(cell);'
p50957
aS'    scratch_data.advection_field.value_list('
p50958
aS'      scratch_data.fe_values.get_quadrature_points(),'
p50959
aS'      scratch_data.advection_directions);'
p50960
aS'    scratch_data.right_hand_side.value_list('
p50961
aS'      scratch_data.fe_values.get_quadrature_points(), scratch_data.rhs_values);'
p50962
aS'    const double delta = 0.1 * cell->diameter();'
p50963
aS'    for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p50964
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p50965
aS'        {'
p50966
aS'          const auto &sd = scratch_data;'
p50967
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p50968
aS'            copy_data.cell_matrix(i, j) +='
p50969
aS'              ((sd.fe_values.shape_value(i, q_point) +           // (phi_i +'
p50970
aS'                delta * (sd.advection_directions[q_point] *      // delta beta'
p50971
aS'                         sd.fe_values.shape_grad(i, q_point))) * // grad phi_i)'
p50972
aS'               sd.advection_directions[q_point] *                // beta'
p50973
aS'               sd.fe_values.shape_grad(j, q_point)) *            // grad phi_j'
p50974
aS'              sd.fe_values.JxW(q_point);                         // dx'
p50975
aS'          copy_data.cell_rhs(i) +='
p50976
aS'            (sd.fe_values.shape_value(i, q_point) +           // (phi_i +'
p50977
aS'             delta * (sd.advection_directions[q_point] *      // delta beta'
p50978
aS'                      sd.fe_values.shape_grad(i, q_point))) * // grad phi_i)'
p50979
aS'            sd.rhs_values[q_point] *                          // f'
p50980
aS'            sd.fe_values.JxW(q_point);                        // dx'
p50981
aS'        }'
p50982
aS'    for (const auto &face : cell->face_iterators())'
p50983
aS'      if (face->at_boundary())'
p50984
aS'        {'
p50985
aS'          scratch_data.fe_face_values.reinit(cell, face);'
p50986
aS'          scratch_data.boundary_values.value_list('
p50987
aS'            scratch_data.fe_face_values.get_quadrature_points(),'
p50988
aS'            scratch_data.face_boundary_values);'
p50989
aS'          scratch_data.advection_field.value_list('
p50990
aS'            scratch_data.fe_face_values.get_quadrature_points(),'
p50991
aS'            scratch_data.face_advection_directions);'
p50992
aS'          for (unsigned int q_point = 0; q_point < n_face_q_points; ++q_point)'
p50993
aS'            if (scratch_data.fe_face_values.normal_vector(q_point) *'
p50994
aS'                  scratch_data.face_advection_directions[q_point] <'
p50995
aS'                0.)'
p50996
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p50997
aS'                {'
p50998
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p50999
aS'                    copy_data.cell_matrix(i, j) -='
p51000
aS'                      (scratch_data.face_advection_directions[q_point] *'
p51001
aS'                       scratch_data.fe_face_values.normal_vector(q_point) *'
p51002
aS'                       scratch_data.fe_face_values.shape_value(i, q_point) *'
p51003
aS'                       scratch_data.fe_face_values.shape_value(j, q_point) *'
p51004
aS'                       scratch_data.fe_face_values.JxW(q_point));'
p51005
aS'                  copy_data.cell_rhs(i) -='
p51006
aS'                    (scratch_data.face_advection_directions[q_point] *'
p51007
aS'                     scratch_data.fe_face_values.normal_vector(q_point) *'
p51008
aS'                     scratch_data.face_boundary_values[q_point] *'
p51009
aS'                     scratch_data.fe_face_values.shape_value(i, q_point) *'
p51010
aS'                     scratch_data.fe_face_values.JxW(q_point));'
p51011
aS'                }'
p51012
aS'        }'
p51013
aS'    cell->get_dof_indices(copy_data.local_dof_indices);'
p51014
aS'  }'
p51015
aS'  template <int dim>'
p51016
aS'  void'
p51017
aS'  AdvectionProblem<dim>::copy_local_to_global(const AssemblyCopyData &copy_data)'
p51018
aS'  {'
p51019
aS'    hanging_node_constraints.distribute_local_to_global('
p51020
aS'      copy_data.cell_matrix,'
p51021
aS'      copy_data.cell_rhs,'
p51022
aS'      copy_data.local_dof_indices,'
p51023
aS'      system_matrix,'
p51024
aS'      system_rhs);'
p51025
aS'  }'
p51026
aS'  template <int dim>'
p51027
aS'  void AdvectionProblem<dim>::solve()'
p51028
aS'  {'
p51029
aS'    SolverControl               solver_control(std::max<std::size_t>(1000,'
p51030
aS'                                                       system_rhs.size() / 10),'
p51031
aS'                                 1e-10 * system_rhs.l2_norm());'
p51032
aS'    SolverGMRES<Vector<double>> solver(solver_control);'
p51033
aS'    PreconditionJacobi<SparseMatrix<double>> preconditioner;'
p51034
aS'    preconditioner.initialize(system_matrix, 1.0);'
p51035
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p51036
aS'    Vector<double> residual(dof_handler.n_dofs());'
p51037
aS'    system_matrix.vmult(residual, solution);'
p51038
aS'    residual -= system_rhs;'
p51039
aS'    std::cout << "   Iterations required for convergence: "'
p51040
aS"              << solver_control.last_step() << '\\n'"
p51041
aS'              << "   Max norm of residual:                "'
p51042
aS"              << residual.linfty_norm() << '\\n';"
p51043
aS'    hanging_node_constraints.distribute(solution);'
p51044
aS'  }'
p51045
aS'  template <int dim>'
p51046
aS'  void AdvectionProblem<dim>::refine_grid()'
p51047
aS'  {'
p51048
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p51049
aS'    GradientEstimation::estimate(dof_handler,'
p51050
aS'                                 solution,'
p51051
aS'                                 estimated_error_per_cell);'
p51052
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p51053
aS'                                                    estimated_error_per_cell,'
p51054
aS'                                                    0.3,'
p51055
aS'                                                    0.03);'
p51056
aS'    triangulation.execute_coarsening_and_refinement();'
p51057
aS'  }'
p51058
aS'  template <int dim>'
p51059
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p51060
aS'  {'
p51061
aS'    {'
p51062
aS'      GridOut       grid_out;'
p51063
aS'      std::ofstream output("grid-" + std::to_string(cycle) + ".vtu");'
p51064
aS'      grid_out.write_vtu(triangulation, output);'
p51065
aS'    }'
p51066
aS'    {'
p51067
aS'      DataOut<dim> data_out;'
p51068
aS'      data_out.attach_dof_handler(dof_handler);'
p51069
aS'      data_out.add_data_vector(solution, "solution");'
p51070
aS'      data_out.build_patches(8);'
p51071
aS'      DataOutBase::VtkFlags vtk_flags;'
p51072
aS'      vtk_flags.compression_level ='
p51073
aS'        DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p51074
aS'      data_out.set_flags(vtk_flags);'
p51075
aS'      std::ofstream output("solution-" + std::to_string(cycle) + ".vtu");'
p51076
aS'      data_out.write_vtu(output);'
p51077
aS'    }'
p51078
aS'  }'
p51079
aS'  template <int dim>'
p51080
aS'  void AdvectionProblem<dim>::run()'
p51081
aS'  {'
p51082
aS'    for (unsigned int cycle = 0; cycle < 10; ++cycle)'
p51083
aS'      {'
p51084
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p51085
aS'        if (cycle == 0)'
p51086
aS'          {'
p51087
aS'            GridGenerator::hyper_cube(triangulation, -1, 1);'
p51088
aS'            triangulation.refine_global(3);'
p51089
aS'          }'
p51090
aS'        else'
p51091
aS'          {'
p51092
aS'            refine_grid();'
p51093
aS'          }'
p51094
aS'        std::cout << "   Number of active cells:              "'
p51095
aS'                  << triangulation.n_active_cells() << std::endl;'
p51096
aS'        setup_system();'
p51097
aS'        std::cout << "   Number of degrees of freedom:        "'
p51098
aS'                  << dof_handler.n_dofs() << std::endl;'
p51099
aS'        assemble_system();'
p51100
aS'        solve();'
p51101
aS'        output_results(cycle);'
p51102
aS'      }'
p51103
aS'  }'
p51104
aS'  template <int dim>'
p51105
aS'  GradientEstimation::EstimateScratchData<dim>::EstimateScratchData('
p51106
aS'    const FiniteElement<dim> &fe,'
p51107
aS'    const Vector<double> &    solution,'
p51108
aS'    Vector<float> &           error_per_cell)'
p51109
aS'    : fe_midpoint_value(fe,'
p51110
aS'                        QMidpoint<dim>(),'
p51111
aS'                        update_values | update_quadrature_points)'
p51112
aS'    , solution(solution)'
p51113
aS'    , error_per_cell(error_per_cell)'
p51114
aS'    , cell_midpoint_value(1)'
p51115
aS'    , neighbor_midpoint_value(1)'
p51116
aS'  {'
p51117
aS'    active_neighbors.reserve(GeometryInfo<dim>::faces_per_cell *'
p51118
aS'                             GeometryInfo<dim>::max_children_per_face);'
p51119
aS'  }'
p51120
aS'  template <int dim>'
p51121
aS'  GradientEstimation::EstimateScratchData<dim>::EstimateScratchData('
p51122
aS'    const EstimateScratchData &scratch_data)'
p51123
aS'    : fe_midpoint_value(scratch_data.fe_midpoint_value.get_fe(),'
p51124
aS'                        scratch_data.fe_midpoint_value.get_quadrature(),'
p51125
aS'                        update_values | update_quadrature_points)'
p51126
aS'    , solution(scratch_data.solution)'
p51127
aS'    , error_per_cell(scratch_data.error_per_cell)'
p51128
aS'    , cell_midpoint_value(1)'
p51129
aS'    , neighbor_midpoint_value(1)'
p51130
aS'  {}'
p51131
aS'  template <int dim>'
p51132
aS'  void GradientEstimation::estimate(const DoFHandler<dim> &dof_handler,'
p51133
aS'                                    const Vector<double> & solution,'
p51134
aS'                                    Vector<float> &        error_per_cell)'
p51135
aS'  {'
p51136
aS'    Assert('
p51137
aS'      error_per_cell.size() == dof_handler.get_triangulation().n_active_cells(),'
p51138
aS'      ExcInvalidVectorLength(error_per_cell.size(),'
p51139
aS'                             dof_handler.get_triangulation().n_active_cells()));'
p51140
aS'    WorkStream::run(dof_handler.begin_active(),'
p51141
aS'                    dof_handler.end(),'
p51142
aS'                    &GradientEstimation::template estimate_cell<dim>,'
p51143
aS'                    std::function<void(const EstimateCopyData &)>(),'
p51144
aS'                    EstimateScratchData<dim>(dof_handler.get_fe(),'
p51145
aS'                                             solution,'
p51146
aS'                                             error_per_cell),'
p51147
aS'                    EstimateCopyData());'
p51148
aS'  }'
p51149
aS'  template <int dim>'
p51150
aS'  void GradientEstimation::estimate_cell('
p51151
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p51152
aS'    EstimateScratchData<dim> &                            scratch_data,'
p51153
aS'    const EstimateCopyData &)'
p51154
aS'  {'
p51155
aS'    Tensor<2, dim> Y;'
p51156
aS'    scratch_data.fe_midpoint_value.reinit(cell);'
p51157
aS'    scratch_data.active_neighbors.clear();'
p51158
aS'    for (const auto face_n : cell->face_indices())'
p51159
aS'      if (!cell->at_boundary(face_n))'
p51160
aS'        {'
p51161
aS'          const auto face     = cell->face(face_n);'
p51162
aS'          const auto neighbor = cell->neighbor(face_n);'
p51163
aS'          if (neighbor->is_active())'
p51164
aS'            scratch_data.active_neighbors.push_back(neighbor);'
p51165
aS'          else'
p51166
aS'            {'
p51167
aS'              if (dim == 1)'
p51168
aS'                {'
p51169
aS'                  auto neighbor_child = neighbor;'
p51170
aS'                  while (neighbor_child->has_children())'
p51171
aS'                    neighbor_child = neighbor_child->child(face_n == 0 ? 1 : 0);'
p51172
aS'                  Assert(neighbor_child->neighbor(face_n == 0 ? 1 : 0) == cell,'
p51173
aS'                         ExcInternalError());'
p51174
aS'                  scratch_data.active_neighbors.push_back(neighbor_child);'
p51175
aS'                }'
p51176
aS'              else'
p51177
aS'                for (unsigned int subface_n = 0; subface_n < face->n_children();'
p51178
aS'                     ++subface_n)'
p51179
aS'                  scratch_data.active_neighbors.push_back('
p51180
aS'                    cell->neighbor_child_on_subface(face_n, subface_n));'
p51181
aS'            }'
p51182
aS'        }'
p51183
aS'    const Point<dim> this_center ='
p51184
aS'      scratch_data.fe_midpoint_value.quadrature_point(0);'
p51185
aS'    scratch_data.fe_midpoint_value.get_function_values('
p51186
aS'      scratch_data.solution, scratch_data.cell_midpoint_value);'
p51187
aS'    Tensor<1, dim> projected_gradient;'
p51188
aS'    for (const auto &neighbor : scratch_data.active_neighbors)'
p51189
aS'      {'
p51190
aS'        scratch_data.fe_midpoint_value.reinit(neighbor);'
p51191
aS'        const Point<dim> neighbor_center ='
p51192
aS'          scratch_data.fe_midpoint_value.quadrature_point(0);'
p51193
aS'        scratch_data.fe_midpoint_value.get_function_values('
p51194
aS'          scratch_data.solution, scratch_data.neighbor_midpoint_value);'
p51195
aS'        Tensor<1, dim> y        = neighbor_center - this_center;'
p51196
aS'        const double   distance = y.norm();'
p51197
aS'        y /= distance;'
p51198
aS'        for (unsigned int i = 0; i < dim; ++i)'
p51199
aS'          for (unsigned int j = 0; j < dim; ++j)'
p51200
aS'            Y[i][j] += y[i] * y[j];'
p51201
aS'        projected_gradient += (scratch_data.neighbor_midpoint_value[0] -'
p51202
aS'                               scratch_data.cell_midpoint_value[0]) /'
p51203
aS'                              distance * y;'
p51204
aS'      }'
p51205
aS'    AssertThrow(determinant(Y) != 0, ExcInsufficientDirections());'
p51206
aS'    const Tensor<2, dim> Y_inverse = invert(Y);'
p51207
aS'    const Tensor<1, dim> gradient = Y_inverse * projected_gradient;'
p51208
aS'    scratch_data.error_per_cell(cell->active_cell_index()) ='
p51209
aS'      (std::pow(cell->diameter(), 1 + 1.0 * dim / 2) * gradient.norm());'
p51210
aS'  }'
p51211
aS'} // namespace Step9'
p51212
aS'int main()'
p51213
ag24
aS'  using namespace dealii;'
p51214
aS'  try'
p51215
aS'    {'
p51216
aS'      MultithreadInfo::set_thread_limit();'
p51217
aS'      Step9::AdvectionProblem<2> advection_problem_2d;'
p51218
aS'      advection_problem_2d.run();'
p51219
aS'    }'
p51220
aS'  catch (std::exception &exc)'
p51221
aS'    {'
p51222
aS'      std::cerr << std::endl'
p51223
aS'                << std::endl'
p51224
aS'                << "----------------------------------------------------"'
p51225
aS'                << std::endl;'
p51226
aS'      std::cerr << "Exception on processing: " << std::endl'
p51227
aS'                << exc.what() << std::endl'
p51228
aS'                << "Aborting!" << std::endl'
p51229
aS'                << "----------------------------------------------------"'
p51230
aS'                << std::endl;'
p51231
aS'      return 1;'
p51232
aS'    }'
p51233
aS'  catch (...)'
p51234
aS'    {'
p51235
aS'      std::cerr << std::endl'
p51236
aS'                << std::endl'
p51237
aS'                << "----------------------------------------------------"'
p51238
aS'                << std::endl;'
p51239
aS'      std::cerr << "Unknown exception!" << std::endl'
p51240
aS'                << "Aborting!" << std::endl'
p51241
aS'                << "----------------------------------------------------"'
p51242
aS'                << std::endl;'
p51243
aS'      return 1;'
p51244
aS'    }'
p51245
aS'  return 0;'
p51246
ag32
a.