(lp0
S'#include <deal.II/grid/tria.h>'
p1
aS'#include <deal.II/grid/grid_generator.h>'
p2
aS'#include <deal.II/grid/grid_out.h>'
p3
aS'#include <iostream>'
p4
aS'#include <fstream>'
p5
aS'#include <cmath>'
p6
aS'using namespace dealii;'
p7
aS'void first_grid()'
p8
aS'{'
p9
aS'  Triangulation<2> triangulation;'
p10
aS'  GridGenerator::hyper_cube(triangulation);'
p11
aS'  triangulation.refine_global(4);'
p12
aS'  std::ofstream out("grid-1.svg");'
p13
aS'  GridOut       grid_out;'
p14
aS'  grid_out.write_svg(triangulation, out);'
p15
aS'  std::cout << "Grid written to grid-1.svg" << std::endl;'
p16
aS'}'
p17
aS'void second_grid()'
p18
ag9
aS'  Triangulation<2> triangulation;'
p19
aS'  const Point<2> center(1, 0);'
p20
aS'  const double   inner_radius = 0.5, outer_radius = 1.0;'
p21
aS'  GridGenerator::hyper_shell('
p22
aS'    triangulation, center, inner_radius, outer_radius, 10);'
p23
aS'  for (unsigned int step = 0; step < 5; ++step)'
p24
aS'    {'
p25
aS'      for (auto &cell : triangulation.active_cell_iterators())'
p26
aS'        {'
p27
aS'          for (const auto v : cell->vertex_indices())'
p28
aS'            {'
p29
aS'              const double distance_from_center ='
p30
aS'                center.distance(cell->vertex(v));'
p31
aS'              if (std::fabs(distance_from_center - inner_radius) <='
p32
aS'                  1e-6 * inner_radius)'
p33
aS'                {'
p34
aS'                  cell->set_refine_flag();'
p35
aS'                  break;'
p36
aS'                }'
p37
aS'            }'
p38
aS'        }'
p39
aS'      triangulation.execute_coarsening_and_refinement();'
p40
aS'    }'
p41
aS'  std::ofstream out("grid-2.svg");'
p42
aS'  GridOut       grid_out;'
p43
aS'  grid_out.write_svg(triangulation, out);'
p44
aS'  std::cout << "Grid written to grid-2.svg" << std::endl;'
p45
ag17
aS'int main()'
p46
ag9
aS'  first_grid();'
p47
aS'  second_grid();'
p48
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p49
aS'#include <deal.II/base/convergence_table.h>'
p50
aS'#include <deal.II/grid/grid_generator.h>'
p51
aS'#include <deal.II/grid/manifold_lib.h>'
p52
aS'#include <deal.II/grid/tria.h>'
p53
aS'#include <deal.II/grid/grid_out.h>'
p54
aS'#include <deal.II/dofs/dof_handler.h>'
p55
aS'#include <deal.II/fe/fe_values.h>'
p56
aS'#include <deal.II/fe/fe_nothing.h>'
p57
aS'#include <deal.II/fe/mapping_q.h>'
p58
aS'#include <iostream>'
p59
aS'#include <fstream>'
p60
aS'#include <cmath>'
p61
aS'namespace Step10'
p62
ag9
aS'  using namespace dealii;'
p63
aS'  const long double pi = 3.141592653589793238462643L;'
p64
aS'  template <int dim>'
p65
aS'  void gnuplot_output()'
p66
aS'  {'
p67
aS'    std::cout << "Output of grids into gnuplot files:" << std::endl'
p68
aS'              << "===================================" << std::endl;'
p69
aS'    Triangulation<dim> triangulation;'
p70
aS'    GridGenerator::hyper_ball(triangulation);'
p71
aS'    for (unsigned int refinement = 0; refinement < 2; ++refinement)'
p72
aS'      {'
p73
aS'        std::cout << "Refinement level: " << refinement << std::endl;'
p74
aS'        std::string filename_base = "ball_" + std::to_string(refinement);'
p75
aS'        for (unsigned int degree = 1; degree < 4; ++degree)'
p76
aS'          {'
p77
aS'            std::cout << "Degree = " << degree << std::endl;'
p78
aS'            const MappingQ<dim> mapping(degree);'
p79
aS'            GridOut               grid_out;'
p80
aS'            GridOutFlags::Gnuplot gnuplot_flags(false, 60);'
p81
aS'            grid_out.set_flags(gnuplot_flags);'
p82
aS'            std::string filename ='
p83
aS'              filename_base + "_mapping_q_" + std::to_string(degree) + ".dat";'
p84
aS'            std::ofstream gnuplot_file(filename);'
p85
aS'            grid_out.write_gnuplot(triangulation, gnuplot_file, &mapping);'
p86
aS'          }'
p87
aS'        std::cout << std::endl;'
p88
aS'        triangulation.refine_global();'
p89
aS'      }'
p90
aS'  }'
p91
aS'  template <int dim>'
p92
aS'  void compute_pi_by_area()'
p93
aS'  {'
p94
aS'    std::cout << "Computation of Pi by the area:" << std::endl'
p95
aS'              << "==============================" << std::endl;'
p96
aS'    const QGauss<dim> quadrature(4);'
p97
aS'    for (unsigned int degree = 1; degree < 5; ++degree)'
p98
aS'      {'
p99
aS'        std::cout << "Degree = " << degree << std::endl;'
p100
aS'        Triangulation<dim> triangulation;'
p101
aS'        GridGenerator::hyper_ball(triangulation);'
p102
aS'        const MappingQ<dim> mapping(degree);'
p103
aS'        const FE_Nothing<dim> fe;'
p104
aS'        DoFHandler<dim> dof_handler(triangulation);'
p105
aS'        FEValues<dim> fe_values(mapping, fe, quadrature, update_JxW_values);'
p106
aS'        ConvergenceTable table;'
p107
aS'        for (unsigned int refinement = 0; refinement < 6;'
p108
aS'             ++refinement, triangulation.refine_global(1))'
p109
aS'          {'
p110
aS'            table.add_value("cells", triangulation.n_active_cells());'
p111
aS'            dof_handler.distribute_dofs(fe);'
p112
aS'            long double area = 0;'
p113
aS'            for (const auto &cell : dof_handler.active_cell_iterators())'
p114
aS'              {'
p115
aS'                fe_values.reinit(cell);'
p116
aS'                for (unsigned int i = 0; i < fe_values.n_quadrature_points; ++i)'
p117
aS'                  area += static_cast<long double>(fe_values.JxW(i));'
p118
aS'              }'
p119
aS'            table.add_value("eval.pi", static_cast<double>(area));'
p120
aS'            table.add_value("error", static_cast<double>(std::fabs(area - pi)));'
p121
aS'          }'
p122
aS'        table.omit_column_from_convergence_rate_evaluation("cells");'
p123
aS'        table.omit_column_from_convergence_rate_evaluation("eval.pi");'
p124
aS'        table.evaluate_all_convergence_rates('
p125
aS'                                    ConvergenceTable::reduction_rate_log2);'
p126
aS'        table.set_precision("eval.pi", 16);'
p127
aS'        table.set_scientific("error", true);'
p128
aS'        table.write_text(std::cout);'
p129
aS'        std::cout << std::endl;'
p130
aS'      }'
p131
aS'  }'
p132
aS'  template <int dim>'
p133
aS'  void compute_pi_by_perimeter()'
p134
aS'  {'
p135
aS'    std::cout << "Computation of Pi by the perimeter:" << std::endl'
p136
aS'              << "===================================" << std::endl;'
p137
aS'    const QGauss<dim - 1> quadrature(4);'
p138
aS'    for (unsigned int degree = 1; degree < 5; ++degree)'
p139
aS'      {'
p140
aS'        std::cout << "Degree = " << degree << std::endl;'
p141
aS'        Triangulation<dim> triangulation;'
p142
aS'        GridGenerator::hyper_ball(triangulation);'
p143
aS'        const MappingQ<dim>   mapping(degree);'
p144
aS'        const FE_Nothing<dim> fe;'
p145
aS'        DoFHandler<dim> dof_handler(triangulation);'
p146
aS'        FEFaceValues<dim> fe_face_values(mapping,'
p147
aS'                                         fe,'
p148
aS'                                         quadrature,'
p149
aS'                                         update_JxW_values);'
p150
aS'        ConvergenceTable  table;'
p151
aS'        for (unsigned int refinement = 0; refinement < 6;'
p152
aS'             ++refinement, triangulation.refine_global(1))'
p153
aS'          {'
p154
aS'            table.add_value("cells", triangulation.n_active_cells());'
p155
aS'            dof_handler.distribute_dofs(fe);'
p156
aS'            long double perimeter = 0;'
p157
aS'            for (const auto &cell : dof_handler.active_cell_iterators())'
p158
aS'              for (const auto &face : cell->face_iterators())'
p159
aS'                if (face->at_boundary())'
p160
aS'                  {'
p161
aS'                    fe_face_values.reinit(cell, face);'
p162
aS'                    for (unsigned int i = 0;'
p163
aS'                         i < fe_face_values.n_quadrature_points;'
p164
aS'                         ++i)'
p165
aS'                      perimeter +='
p166
aS'                        static_cast<long double>(fe_face_values.JxW(i));'
p167
aS'                  }'
p168
aS'            table.add_value("eval.pi", static_cast<double>(perimeter / 2.0L));'
p169
aS'            table.add_value('
p170
aS'              "error", static_cast<double>(std::fabs(perimeter / 2.0L - pi)));'
p171
aS'          }'
p172
aS'        table.omit_column_from_convergence_rate_evaluation("cells");'
p173
aS'        table.omit_column_from_convergence_rate_evaluation("eval.pi");'
p174
aS'        table.evaluate_all_convergence_rates('
p175
aS'          ConvergenceTable::reduction_rate_log2);'
p176
aS'        table.set_precision("eval.pi", 16);'
p177
aS'        table.set_scientific("error", true);'
p178
aS'        table.write_text(std::cout);'
p179
aS'        std::cout << std::endl;'
p180
aS'      }'
p181
aS'  }'
p182
aS'} // namespace Step10'
p183
aS'int main()'
p184
ag9
aS'  try'
p185
aS'    {'
p186
aS'      std::cout.precision(16);'
p187
aS'      const unsigned int dim = 2;'
p188
aS'      Step10::gnuplot_output<dim>();'
p189
aS'      Step10::compute_pi_by_area<dim>();'
p190
aS'      Step10::compute_pi_by_perimeter<dim>();'
p191
aS'    }'
p192
aS'  catch (std::exception &exc)'
p193
aS'    {'
p194
aS'      std::cerr << std::endl'
p195
aS'                << std::endl'
p196
aS'                << "----------------------------------------------------"'
p197
aS'                << std::endl;'
p198
aS'      std::cerr << "Exception on processing: " << std::endl'
p199
aS'                << exc.what() << std::endl'
p200
aS'                << "Aborting!" << std::endl'
p201
aS'                << "----------------------------------------------------"'
p202
aS'                << std::endl;'
p203
aS'      return 1;'
p204
aS'    }'
p205
aS'  catch (...)'
p206
aS'    {'
p207
aS'      std::cerr << std::endl'
p208
aS'                << std::endl'
p209
aS'                << "----------------------------------------------------"'
p210
aS'                << std::endl;'
p211
aS'      std::cerr << "Unknown exception!" << std::endl'
p212
aS'                << "Aborting!" << std::endl'
p213
aS'                << "----------------------------------------------------"'
p214
aS'                << std::endl;'
p215
aS'      return 1;'
p216
aS'    }'
p217
aS'  return 0;'
p218
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p219
aS'#include <deal.II/base/function.h>'
p220
aS'#include <deal.II/base/logstream.h>'
p221
aS'#include <deal.II/base/table_handler.h>'
p222
aS'#include <deal.II/lac/vector.h>'
p223
aS'#include <deal.II/lac/sparse_matrix.h>'
p224
aS'#include <deal.II/lac/solver_cg.h>'
p225
aS'#include <deal.II/lac/precondition.h>'
p226
aS'#include <deal.II/lac/affine_constraints.h>'
p227
aS'#include <deal.II/grid/tria.h>'
p228
aS'#include <deal.II/grid/grid_generator.h>'
p229
aS'#include <deal.II/dofs/dof_handler.h>'
p230
aS'#include <deal.II/dofs/dof_tools.h>'
p231
aS'#include <deal.II/fe/fe_q.h>'
p232
aS'#include <deal.II/fe/fe_values.h>'
p233
aS'#include <deal.II/fe/mapping_q.h>'
p234
aS'#include <deal.II/numerics/vector_tools.h>'
p235
aS'#include <deal.II/numerics/matrix_tools.h>'
p236
aS'#include <deal.II/numerics/data_out.h>'
p237
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p238
aS'#include <algorithm>'
p239
aS'#include <iostream>'
p240
aS'#include <iomanip>'
p241
aS'#include <cmath>'
p242
aS'namespace Step11'
p243
ag9
aS'  using namespace dealii;'
p244
aS'  template <int dim>'
p245
aS'  class LaplaceProblem'
p246
aS'  {'
p247
aS'  public:'
p248
aS'    LaplaceProblem(const unsigned int mapping_degree);'
p249
aS'    void run();'
p250
aS'  private:'
p251
aS'    void setup_system();'
p252
aS'    void assemble_and_solve();'
p253
aS'    void solve();'
p254
aS'    void write_high_order_mesh(const unsigned cycle);'
p255
aS'    Triangulation<dim> triangulation;'
p256
aS'    FE_Q<dim>          fe;'
p257
aS'    DoFHandler<dim>    dof_handler;'
p258
aS'    MappingQ<dim>      mapping;'
p259
aS'    SparsityPattern           sparsity_pattern;'
p260
aS'    SparseMatrix<double>      system_matrix;'
p261
aS'    AffineConstraints<double> mean_value_constraints;'
p262
aS'    Vector<double> solution;'
p263
aS'    Vector<double> system_rhs;'
p264
aS'    TableHandler output_table;'
p265
aS'  };'
p266
aS'  template <int dim>'
p267
aS'  LaplaceProblem<dim>::LaplaceProblem(const unsigned int mapping_degree)'
p268
aS'    : fe(1)'
p269
aS'    , dof_handler(triangulation)'
p270
aS'    , mapping(mapping_degree)'
p271
aS'  {'
p272
aS'    std::cout << "Using mapping with degree " << mapping_degree << ":"'
p273
aS'              << std::endl'
p274
aS'              << "============================" << std::endl;'
p275
aS'  }'
p276
aS'  template <int dim>'
p277
aS'  void LaplaceProblem<dim>::setup_system()'
p278
aS'  {'
p279
aS'    dof_handler.distribute_dofs(fe);'
p280
aS'    solution.reinit(dof_handler.n_dofs());'
p281
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p282
aS'    const IndexSet boundary_dofs = DoFTools::extract_boundary_dofs(dof_handler);'
p283
aS'    const types::global_dof_index first_boundary_dof ='
p284
aS'      boundary_dofs.nth_index_in_set(0);'
p285
aS'    mean_value_constraints.clear();'
p286
aS'    mean_value_constraints.add_line(first_boundary_dof);'
p287
aS'    for (types::global_dof_index i : boundary_dofs)'
p288
aS'      if (i != first_boundary_dof)'
p289
aS'        mean_value_constraints.add_entry(first_boundary_dof, i, -1);'
p290
aS'    mean_value_constraints.close();'
p291
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p292
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p293
aS'    mean_value_constraints.condense(dsp);'
p294
aS'    sparsity_pattern.copy_from(dsp);'
p295
aS'    system_matrix.reinit(sparsity_pattern);'
p296
aS'  }'
p297
aS'  template <int dim>'
p298
aS'  void LaplaceProblem<dim>::assemble_and_solve()'
p299
aS'  {'
p300
aS'    const unsigned int gauss_degree ='
p301
aS'      std::max(static_cast<unsigned int>('
p302
aS'                 std::ceil(1. * (mapping.get_degree() + 1) / 2)),'
p303
aS'               2U);'
p304
aS'    MatrixTools::create_laplace_matrix(mapping,'
p305
aS'                                       dof_handler,'
p306
aS'                                       QGauss<dim>(gauss_degree),'
p307
aS'                                       system_matrix);'
p308
aS'    VectorTools::create_right_hand_side(mapping,'
p309
aS'                                        dof_handler,'
p310
aS'                                        QGauss<dim>(gauss_degree),'
p311
aS'                                        Functions::ConstantFunction<dim>(-2),'
p312
aS'                                        system_rhs);'
p313
aS'    Vector<double> tmp(system_rhs.size());'
p314
aS'    VectorTools::create_boundary_right_hand_side('
p315
aS'      mapping,'
p316
aS'      dof_handler,'
p317
aS'      QGauss<dim - 1>(gauss_degree),'
p318
aS'      Functions::ConstantFunction<dim>(1),'
p319
aS'      tmp);'
p320
aS'    system_rhs += tmp;'
p321
aS'    mean_value_constraints.condense(system_matrix);'
p322
aS'    mean_value_constraints.condense(system_rhs);'
p323
aS'    solve();'
p324
aS'    mean_value_constraints.distribute(solution);'
p325
aS'    Vector<float> norm_per_cell(triangulation.n_active_cells());'
p326
aS'    VectorTools::integrate_difference(mapping,'
p327
aS'                                      dof_handler,'
p328
aS'                                      solution,'
p329
aS'                                      Functions::ZeroFunction<dim>(),'
p330
aS'                                      norm_per_cell,'
p331
aS'                                      QGauss<dim>(gauss_degree + 1),'
p332
aS'                                      VectorTools::H1_seminorm);'
p333
aS'    const double norm ='
p334
aS'      VectorTools::compute_global_error(triangulation,'
p335
aS'                                        norm_per_cell,'
p336
aS'                                        VectorTools::H1_seminorm);'
p337
aS'    output_table.add_value("cells", triangulation.n_active_cells());'
p338
aS'    output_table.add_value("|u|_1", norm);'
p339
aS'    output_table.add_value("error",'
p340
aS'                           std::fabs(norm - std::sqrt(3.14159265358 / 2)));'
p341
aS'  }'
p342
aS'  template <int dim>'
p343
aS'  void LaplaceProblem<dim>::solve()'
p344
aS'  {'
p345
aS'    SolverControl            solver_control(1000, 1e-12);'
p346
aS'    SolverCG<Vector<double>> cg(solver_control);'
p347
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p348
aS'    preconditioner.initialize(system_matrix, 1.2);'
p349
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p350
aS'  }'
p351
aS'  template <int dim>'
p352
aS'  void LaplaceProblem<dim>::write_high_order_mesh(const unsigned cycle)'
p353
aS'  {'
p354
aS'    DataOut<dim> data_out;'
p355
aS'    DataOutBase::VtkFlags flags;'
p356
aS'    flags.write_higher_order_cells = true;'
p357
aS'    data_out.set_flags(flags);'
p358
aS'    data_out.attach_dof_handler(dof_handler);'
p359
aS'    data_out.add_data_vector(solution, "solution");'
p360
aS'    data_out.build_patches(mapping,'
p361
aS'                           mapping.get_degree(),'
p362
aS'                           DataOut<dim>::curved_inner_cells);'
p363
aS'    std::ofstream file("solution-c=" + std::to_string(cycle) +'
p364
aS'                       ".p=" + std::to_string(mapping.get_degree()) + ".vtu");'
p365
aS'    data_out.write_vtu(file);'
p366
aS'  }'
p367
aS'  template <int dim>'
p368
aS'  void LaplaceProblem<dim>::run()'
p369
aS'  {'
p370
aS'    GridGenerator::hyper_ball(triangulation);'
p371
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p372
aS'      {'
p373
aS'        setup_system();'
p374
aS'        assemble_and_solve();'
p375
aS'        write_high_order_mesh(cycle);'
p376
aS'        triangulation.refine_global();'
p377
aS'      }'
p378
aS'    output_table.set_precision("|u|_1", 6);'
p379
aS'    output_table.set_precision("error", 6);'
p380
aS'    output_table.write_text(std::cout);'
p381
aS'    std::cout << std::endl;'
p382
aS'  }'
p383
aS'} // namespace Step11'
p384
aS'int main()'
p385
ag9
aS'  try'
p386
aS'    {'
p387
aS'      std::cout.precision(5);'
p388
aS'      for (unsigned int mapping_degree = 1; mapping_degree <= 3;'
p389
aS'           ++mapping_degree)'
p390
aS'        Step11::LaplaceProblem<2>(mapping_degree).run();'
p391
aS'    }'
p392
aS'  catch (std::exception &exc)'
p393
aS'    {'
p394
aS'      std::cerr << std::endl'
p395
aS'                << std::endl'
p396
aS'                << "----------------------------------------------------"'
p397
aS'                << std::endl;'
p398
aS'      std::cerr << "Exception on processing: " << std::endl'
p399
aS'                << exc.what() << std::endl'
p400
aS'                << "Aborting!" << std::endl'
p401
aS'                << "----------------------------------------------------"'
p402
aS'                << std::endl;'
p403
aS'      return 1;'
p404
aS'    }'
p405
aS'  catch (...)'
p406
aS'    {'
p407
aS'      std::cerr << std::endl'
p408
aS'                << std::endl'
p409
aS'                << "----------------------------------------------------"'
p410
aS'                << std::endl;'
p411
aS'      std::cerr << "Unknown exception!" << std::endl'
p412
aS'                << "Aborting!" << std::endl'
p413
aS'                << "----------------------------------------------------"'
p414
aS'                << std::endl;'
p415
aS'      return 1;'
p416
aS'    };'
p417
aS'  return 0;'
p418
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p419
aS'#include <deal.II/base/function.h>'
p420
aS'#include <deal.II/lac/vector.h>'
p421
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p422
aS'#include <deal.II/lac/sparse_matrix.h>'
p423
aS'#include <deal.II/grid/tria.h>'
p424
aS'#include <deal.II/grid/grid_generator.h>'
p425
aS'#include <deal.II/grid/grid_out.h>'
p426
aS'#include <deal.II/grid/grid_refinement.h>'
p427
aS'#include <deal.II/fe/fe_values.h>'
p428
aS'#include <deal.II/dofs/dof_handler.h>'
p429
aS'#include <deal.II/numerics/vector_tools.h>'
p430
aS'#include <deal.II/dofs/dof_tools.h>'
p431
aS'#include <deal.II/numerics/data_out.h>'
p432
aS'#include <deal.II/fe/mapping_q1.h>'
p433
aS'#include <deal.II/fe/fe_dgq.h>'
p434
aS'#include <deal.II/fe/fe_interface_values.h>'
p435
aS'#include <deal.II/lac/solver_richardson.h>'
p436
aS'#include <deal.II/lac/precondition_block.h>'
p437
aS'#include <deal.II/numerics/derivative_approximation.h>'
p438
aS'#include <deal.II/meshworker/mesh_loop.h>'
p439
aS'#include <iostream>'
p440
aS'#include <fstream>'
p441
aS'namespace Step12'
p442
ag9
aS'  using namespace dealii;'
p443
aS'  template <int dim>'
p444
aS'  class BoundaryValues : public Function<dim>'
p445
aS'  {'
p446
aS'  public:'
p447
aS'    BoundaryValues() = default;'
p448
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p449
aS'                            std::vector<double> &          values,'
p450
aS'                            const unsigned int component = 0) const override;'
p451
aS'  };'
p452
aS'  template <int dim>'
p453
aS'  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,'
p454
aS'                                       std::vector<double> &          values,'
p455
aS'                                       const unsigned int component) const'
p456
aS'  {'
p457
aS'    AssertIndexRange(component, 1);'
p458
aS'    Assert(values.size() == points.size(),'
p459
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p460
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p461
aS'      {'
p462
aS'        if (points[i](0) < 0.5)'
p463
aS'          values[i] = 1.;'
p464
aS'        else'
p465
aS'          values[i] = 0.;'
p466
aS'      }'
p467
aS'  }'
p468
aS'  template <int dim>'
p469
aS'  Tensor<1, dim> beta(const Point<dim> &p)'
p470
aS'  {'
p471
aS'    Assert(dim >= 2, ExcNotImplemented());'
p472
aS'    Tensor<1, dim> wind_field;'
p473
aS'    wind_field[0] = -p[1];'
p474
aS'    wind_field[1] = p[0];'
p475
aS'    if (wind_field.norm() > 1e-10)'
p476
aS'      wind_field /= wind_field.norm();'
p477
aS'    return wind_field;'
p478
aS'  }'
p479
aS'  template <int dim>'
p480
aS'  struct ScratchData'
p481
aS'  {'
p482
aS'    ScratchData(const Mapping<dim> &       mapping,'
p483
aS'                const FiniteElement<dim> & fe,'
p484
aS'                const Quadrature<dim> &    quadrature,'
p485
aS'                const Quadrature<dim - 1> &quadrature_face,'
p486
aS'                const UpdateFlags          update_flags = update_values |'
p487
aS'                                                 update_gradients |'
p488
aS'                                                 update_quadrature_points |'
p489
aS'                                                 update_JxW_values,'
p490
aS'                const UpdateFlags interface_update_flags ='
p491
aS'                  update_values | update_gradients | update_quadrature_points |'
p492
aS'                  update_JxW_values | update_normal_vectors)'
p493
aS'      : fe_values(mapping, fe, quadrature, update_flags)'
p494
aS'      , fe_interface_values(mapping,'
p495
aS'                            fe,'
p496
aS'                            quadrature_face,'
p497
aS'                            interface_update_flags)'
p498
aS'    {}'
p499
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p500
aS'      : fe_values(scratch_data.fe_values.get_mapping(),'
p501
aS'                  scratch_data.fe_values.get_fe(),'
p502
aS'                  scratch_data.fe_values.get_quadrature(),'
p503
aS'                  scratch_data.fe_values.get_update_flags())'
p504
aS'      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),'
p505
aS'                            scratch_data.fe_interface_values.get_fe(),'
p506
aS'                            scratch_data.fe_interface_values.get_quadrature(),'
p507
aS'                            scratch_data.fe_interface_values.get_update_flags())'
p508
aS'    {}'
p509
aS'    FEValues<dim>          fe_values;'
p510
aS'    FEInterfaceValues<dim> fe_interface_values;'
p511
aS'  };'
p512
aS'  struct CopyDataFace'
p513
aS'  {'
p514
aS'    FullMatrix<double>                   cell_matrix;'
p515
aS'    std::vector<types::global_dof_index> joint_dof_indices;'
p516
aS'  };'
p517
aS'  struct CopyData'
p518
aS'  {'
p519
aS'    FullMatrix<double>                   cell_matrix;'
p520
aS'    Vector<double>                       cell_rhs;'
p521
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p522
aS'    std::vector<CopyDataFace>            face_data;'
p523
aS'    template <class Iterator>'
p524
aS'    void reinit(const Iterator &cell, unsigned int dofs_per_cell)'
p525
aS'    {'
p526
aS'      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p527
aS'      cell_rhs.reinit(dofs_per_cell);'
p528
aS'      local_dof_indices.resize(dofs_per_cell);'
p529
aS'      cell->get_dof_indices(local_dof_indices);'
p530
aS'    }'
p531
aS'  };'
p532
aS'  template <int dim>'
p533
aS'  class AdvectionProblem'
p534
aS'  {'
p535
aS'  public:'
p536
aS'    AdvectionProblem();'
p537
aS'    void run();'
p538
aS'  private:'
p539
aS'    void setup_system();'
p540
aS'    void assemble_system();'
p541
aS'    void solve();'
p542
aS'    void refine_grid();'
p543
aS'    void output_results(const unsigned int cycle) const;'
p544
aS'    Triangulation<dim>   triangulation;'
p545
aS'    const MappingQ1<dim> mapping;'
p546
aS'    const FE_DGQ<dim> fe;'
p547
aS'    DoFHandler<dim>   dof_handler;'
p548
aS'    const QGauss<dim>     quadrature;'
p549
aS'    const QGauss<dim - 1> quadrature_face;'
p550
aS'    SparsityPattern      sparsity_pattern;'
p551
aS'    SparseMatrix<double> system_matrix;'
p552
aS'    Vector<double> solution;'
p553
aS'    Vector<double> right_hand_side;'
p554
aS'  };'
p555
aS'  template <int dim>'
p556
aS'  AdvectionProblem<dim>::AdvectionProblem()'
p557
aS'    : mapping()'
p558
aS'    , fe(1)'
p559
aS'    , dof_handler(triangulation)'
p560
aS'    , quadrature(fe.tensor_degree() + 1)'
p561
aS'    , quadrature_face(fe.tensor_degree() + 1)'
p562
aS'  {}'
p563
aS'  template <int dim>'
p564
aS'  void AdvectionProblem<dim>::setup_system()'
p565
aS'  {'
p566
aS'    dof_handler.distribute_dofs(fe);'
p567
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p568
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p569
aS'    sparsity_pattern.copy_from(dsp);'
p570
aS'    system_matrix.reinit(sparsity_pattern);'
p571
aS'    solution.reinit(dof_handler.n_dofs());'
p572
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p573
aS'  }'
p574
aS'  template <int dim>'
p575
aS'  void AdvectionProblem<dim>::assemble_system()'
p576
aS'  {'
p577
aS'    using Iterator = typename DoFHandler<dim>::active_cell_iterator;'
p578
aS'    const BoundaryValues<dim> boundary_function;'
p579
aS'    const auto cell_worker = [&](const Iterator &  cell,'
p580
aS'                                 ScratchData<dim> &scratch_data,'
p581
aS'                                 CopyData &        copy_data) {'
p582
aS'      const unsigned int n_dofs ='
p583
aS'        scratch_data.fe_values.get_fe().n_dofs_per_cell();'
p584
aS'      copy_data.reinit(cell, n_dofs);'
p585
aS'      scratch_data.fe_values.reinit(cell);'
p586
aS'      const auto &q_points = scratch_data.fe_values.get_quadrature_points();'
p587
aS'      const FEValues<dim> &      fe_v = scratch_data.fe_values;'
p588
aS'      const std::vector<double> &JxW  = fe_v.get_JxW_values();'
p589
aS'      for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p590
aS'        {'
p591
aS'          auto beta_q = beta(q_points[point]);'
p592
aS'          for (unsigned int i = 0; i < n_dofs; ++i)'
p593
aS'            for (unsigned int j = 0; j < n_dofs; ++j)'
p594
aS'              {'
p595
aS'                copy_data.cell_matrix(i, j) +='
p596
aS'                  -beta_q                      // -\\beta'
p597
aS'              }'
p598
aS'        }'
p599
aS'    };'
p600
aS'    const auto boundary_worker = [&](const Iterator &    cell,'
p601
aS'                                     const unsigned int &face_no,'
p602
aS'                                     ScratchData<dim> &  scratch_data,'
p603
aS'                                     CopyData &          copy_data) {'
p604
aS'      scratch_data.fe_interface_values.reinit(cell, face_no);'
p605
aS'      const FEFaceValuesBase<dim> &fe_face ='
p606
aS'        scratch_data.fe_interface_values.get_fe_face_values(0);'
p607
aS'      const auto &q_points = fe_face.get_quadrature_points();'
p608
aS'      const unsigned int n_facet_dofs = fe_face.get_fe().n_dofs_per_cell();'
p609
aS'      const std::vector<double> &        JxW     = fe_face.get_JxW_values();'
p610
aS'      const std::vector<Tensor<1, dim>> &normals = fe_face.get_normal_vectors();'
p611
aS'      std::vector<double> g(q_points.size());'
p612
aS'      boundary_function.value_list(q_points, g);'
p613
aS'      for (unsigned int point = 0; point < q_points.size(); ++point)'
p614
aS'        {'
p615
aS'          const double beta_dot_n = beta(q_points[point]) * normals[point];'
p616
aS'          if (beta_dot_n > 0)'
p617
aS'            {'
p618
aS'              for (unsigned int i = 0; i < n_facet_dofs; ++i)'
p619
aS'                for (unsigned int j = 0; j < n_facet_dofs; ++j)'
p620
aS'                  copy_data.cell_matrix(i, j) +='
p621
aS'                    fe_face.shape_value(i, point)   // \\phi_i'
p622
aS'            }'
p623
aS'          else'
p624
aS'            for (unsigned int i = 0; i < n_facet_dofs; ++i)'
p625
aS'              copy_data.cell_rhs(i) += -fe_face.shape_value(i, point) // \\phi_i'
p626
aS'        }'
p627
aS'    };'
p628
aS'    const auto face_worker = [&](const Iterator &    cell,'
p629
aS'                                 const unsigned int &f,'
p630
aS'                                 const unsigned int &sf,'
p631
aS'                                 const Iterator &    ncell,'
p632
aS'                                 const unsigned int &nf,'
p633
aS'                                 const unsigned int &nsf,'
p634
aS'                                 ScratchData<dim> &  scratch_data,'
p635
aS'                                 CopyData &          copy_data) {'
p636
aS'      FEInterfaceValues<dim> &fe_iv = scratch_data.fe_interface_values;'
p637
aS'      fe_iv.reinit(cell, f, sf, ncell, nf, nsf);'
p638
aS'      const auto &q_points = fe_iv.get_quadrature_points();'
p639
aS'      copy_data.face_data.emplace_back();'
p640
aS'      CopyDataFace &copy_data_face = copy_data.face_data.back();'
p641
aS'      const unsigned int n_dofs        = fe_iv.n_current_interface_dofs();'
p642
aS'      copy_data_face.joint_dof_indices = fe_iv.get_interface_dof_indices();'
p643
aS'      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);'
p644
aS'      const std::vector<double> &        JxW     = fe_iv.get_JxW_values();'
p645
aS'      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();'
p646
aS'      for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint)'
p647
aS'        {'
p648
aS'          const double beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];'
p649
aS'          for (unsigned int i = 0; i < n_dofs; ++i)'
p650
aS'            for (unsigned int j = 0; j < n_dofs; ++j)'
p651
aS'              copy_data_face.cell_matrix(i, j) +='
p652
aS'                fe_iv.jump(i, qpoint) // [\\phi_i]'
p653
aS'                fe_iv.shape_value((beta_dot_n > 0), j, qpoint) // phi_j^{upwind}'
p654
aS'        }'
p655
aS'    };'
p656
aS'    const AffineConstraints<double> constraints;'
p657
aS'    const auto copier = [&](const CopyData &c) {'
p658
aS'      constraints.distribute_local_to_global(c.cell_matrix,'
p659
aS'                                             c.cell_rhs,'
p660
aS'                                             c.local_dof_indices,'
p661
aS'                                             system_matrix,'
p662
aS'                                             right_hand_side);'
p663
aS'      for (auto &cdf : c.face_data)'
p664
aS'        {'
p665
aS'          constraints.distribute_local_to_global(cdf.cell_matrix,'
p666
aS'                                                 cdf.joint_dof_indices,'
p667
aS'                                                 system_matrix);'
p668
aS'        }'
p669
aS'    };'
p670
aS'    ScratchData<dim> scratch_data(mapping, fe, quadrature, quadrature_face);'
p671
aS'    CopyData         copy_data;'
p672
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p673
aS'                          dof_handler.end(),'
p674
aS'                          cell_worker,'
p675
aS'                          copier,'
p676
aS'                          scratch_data,'
p677
aS'                          copy_data,'
p678
aS'                          MeshWorker::assemble_own_cells |'
p679
aS'                            MeshWorker::assemble_boundary_faces |'
p680
aS'                            MeshWorker::assemble_own_interior_faces_once,'
p681
aS'                          boundary_worker,'
p682
aS'                          face_worker);'
p683
aS'  }'
p684
aS'  template <int dim>'
p685
aS'  void AdvectionProblem<dim>::solve()'
p686
aS'  {'
p687
aS'    SolverControl                    solver_control(1000, 1e-12);'
p688
aS'    SolverRichardson<Vector<double>> solver(solver_control);'
p689
aS'    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;'
p690
aS'    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());'
p691
aS'    solver.solve(system_matrix, solution, right_hand_side, preconditioner);'
p692
aS'    std::cout << "  Solver converged in " << solver_control.last_step()'
p693
aS'              << " iterations." << std::endl;'
p694
aS'  }'
p695
aS'  template <int dim>'
p696
aS'  void AdvectionProblem<dim>::refine_grid()'
p697
aS'  {'
p698
aS'    Vector<float> gradient_indicator(triangulation.n_active_cells());'
p699
aS'    DerivativeApproximation::approximate_gradient(mapping,'
p700
aS'                                                  dof_handler,'
p701
aS'                                                  solution,'
p702
aS'                                                  gradient_indicator);'
p703
aS'    unsigned int cell_no = 0;'
p704
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p705
aS'      gradient_indicator(cell_no++) *='
p706
aS'        std::pow(cell->diameter(), 1 + 1.0 * dim / 2);'
p707
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p708
aS'                                                    gradient_indicator,'
p709
aS'                                                    0.3,'
p710
aS'                                                    0.1);'
p711
aS'    triangulation.execute_coarsening_and_refinement();'
p712
aS'  }'
p713
aS'  template <int dim>'
p714
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p715
aS'  {'
p716
aS'    const std::string filename = "solution-" + std::to_string(cycle) + ".vtk";'
p717
aS'    std::cout << "  Writing solution to <" << filename << ">" << std::endl;'
p718
aS'    std::ofstream output(filename);'
p719
aS'    DataOut<dim> data_out;'
p720
aS'    data_out.attach_dof_handler(dof_handler);'
p721
aS'    data_out.add_data_vector(solution, "u", DataOut<dim>::type_dof_data);'
p722
aS'    data_out.build_patches(mapping);'
p723
aS'    data_out.write_vtk(output);'
p724
aS'    {'
p725
aS'      Vector<float> values(triangulation.n_active_cells());'
p726
aS'      VectorTools::integrate_difference(mapping,'
p727
aS'                                        dof_handler,'
p728
aS'                                        solution,'
p729
aS'                                        Functions::ZeroFunction<dim>(),'
p730
aS'                                        values,'
p731
aS'                                        quadrature,'
p732
aS'                                        VectorTools::Linfty_norm);'
p733
aS'      const double l_infty ='
p734
aS'        VectorTools::compute_global_error(triangulation,'
p735
aS'                                          values,'
p736
aS'                                          VectorTools::Linfty_norm);'
p737
aS'      std::cout << "  L-infinity norm: " << l_infty << std::endl;'
p738
aS'    }'
p739
aS'  }'
p740
aS'  template <int dim>'
p741
aS'  void AdvectionProblem<dim>::run()'
p742
aS'  {'
p743
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p744
aS'      {'
p745
aS'        std::cout << "Cycle " << cycle << std::endl;'
p746
aS'        if (cycle == 0)'
p747
aS'          {'
p748
aS'            GridGenerator::hyper_cube(triangulation);'
p749
aS'            triangulation.refine_global(3);'
p750
aS'          }'
p751
aS'        else'
p752
aS'          refine_grid();'
p753
aS'        std::cout << "  Number of active cells:       "'
p754
aS'                  << triangulation.n_active_cells() << std::endl;'
p755
aS'        setup_system();'
p756
aS'        std::cout << "  Number of degrees of freedom: " << dof_handler.n_dofs()'
p757
aS'                  << std::endl;'
p758
aS'        assemble_system();'
p759
aS'        solve();'
p760
aS'        output_results(cycle);'
p761
aS'      }'
p762
aS'  }'
p763
aS'} // namespace Step12'
p764
aS'int main()'
p765
ag9
aS'  try'
p766
aS'    {'
p767
aS'      Step12::AdvectionProblem<2> dgmethod;'
p768
aS'      dgmethod.run();'
p769
aS'    }'
p770
aS'  catch (std::exception &exc)'
p771
aS'    {'
p772
aS'      std::cerr << std::endl'
p773
aS'                << std::endl'
p774
aS'                << "----------------------------------------------------"'
p775
aS'                << std::endl;'
p776
aS'      std::cerr << "Exception on processing: " << std::endl'
p777
aS'                << exc.what() << std::endl'
p778
aS'                << "Aborting!" << std::endl'
p779
aS'                << "----------------------------------------------------"'
p780
aS'                << std::endl;'
p781
aS'      return 1;'
p782
aS'    }'
p783
aS'  catch (...)'
p784
aS'    {'
p785
aS'      std::cerr << std::endl'
p786
aS'                << std::endl'
p787
aS'                << "----------------------------------------------------"'
p788
aS'                << std::endl;'
p789
aS'      std::cerr << "Unknown exception!" << std::endl'
p790
aS'                << "Aborting!" << std::endl'
p791
aS'                << "----------------------------------------------------"'
p792
aS'                << std::endl;'
p793
aS'      return 1;'
p794
aS'    }'
p795
aS'  return 0;'
p796
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p797
aS'#include <deal.II/base/function.h>'
p798
aS'#include <deal.II/lac/vector.h>'
p799
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p800
aS'#include <deal.II/lac/sparse_matrix.h>'
p801
aS'#include <deal.II/grid/tria.h>'
p802
aS'#include <deal.II/grid/grid_generator.h>'
p803
aS'#include <deal.II/grid/grid_out.h>'
p804
aS'#include <deal.II/grid/grid_refinement.h>'
p805
aS'#include <deal.II/fe/fe_values.h>'
p806
aS'#include <deal.II/dofs/dof_handler.h>'
p807
aS'#include <deal.II/dofs/dof_tools.h>'
p808
aS'#include <deal.II/numerics/data_out.h>'
p809
aS'#include <deal.II/fe/mapping_q1.h>'
p810
aS'#include <deal.II/fe/fe_dgq.h>'
p811
aS'#include <deal.II/lac/solver_richardson.h>'
p812
aS'#include <deal.II/lac/precondition_block.h>'
p813
aS'#include <deal.II/numerics/derivative_approximation.h>'
p814
aS'#include <deal.II/meshworker/dof_info.h>'
p815
aS'#include <deal.II/meshworker/integration_info.h>'
p816
aS'#include <deal.II/meshworker/simple.h>'
p817
aS'#include <deal.II/meshworker/loop.h>'
p818
aS'#include <iostream>'
p819
aS'#include <fstream>'
p820
aS'namespace Step12'
p821
ag9
aS'  using namespace dealii;'
p822
aS'  template <int dim>'
p823
aS'  class BoundaryValues : public Function<dim>'
p824
aS'  {'
p825
aS'  public:'
p826
aS'    BoundaryValues() = default;'
p827
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p828
aS'                            std::vector<double> &          values,'
p829
aS'                            const unsigned int component = 0) const override;'
p830
aS'  };'
p831
aS'  template <int dim>'
p832
aS'  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,'
p833
aS'                                       std::vector<double> &          values,'
p834
aS'                                       const unsigned int component) const'
p835
aS'  {'
p836
aS'    AssertIndexRange(component, 1);'
p837
aS'    Assert(values.size() == points.size(),'
p838
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p839
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p840
aS'      {'
p841
aS'        if (points[i](0) < 0.5)'
p842
aS'          values[i] = 1.;'
p843
aS'        else'
p844
aS'          values[i] = 0.;'
p845
aS'      }'
p846
aS'  }'
p847
aS'  template <int dim>'
p848
aS'  Tensor<1, dim> beta(const Point<dim> &p)'
p849
aS'  {'
p850
aS'    Assert(dim >= 2, ExcNotImplemented());'
p851
aS'    Tensor<1, dim> wind_field;'
p852
aS'    wind_field[0] = -p[1];'
p853
aS'    wind_field[1] = p[0];'
p854
aS'    wind_field /= wind_field.norm();'
p855
aS'    return wind_field;'
p856
aS'  }'
p857
aS'  template <int dim>'
p858
aS'  class AdvectionProblem'
p859
aS'  {'
p860
aS'  public:'
p861
aS'    AdvectionProblem();'
p862
aS'    void run();'
p863
aS'  private:'
p864
aS'    void setup_system();'
p865
aS'    void assemble_system();'
p866
aS'    void solve(Vector<double> &solution);'
p867
aS'    void refine_grid();'
p868
aS'    void output_results(const unsigned int cycle) const;'
p869
aS'    Triangulation<dim>   triangulation;'
p870
aS'    const MappingQ1<dim> mapping;'
p871
aS'    FE_DGQ<dim>     fe;'
p872
aS'    DoFHandler<dim> dof_handler;'
p873
aS'    SparsityPattern      sparsity_pattern;'
p874
aS'    SparseMatrix<double> system_matrix;'
p875
aS'    Vector<double> solution;'
p876
aS'    Vector<double> right_hand_side;'
p877
aS'    using DoFInfo  = MeshWorker::DoFInfo<dim>;'
p878
aS'    using CellInfo = MeshWorker::IntegrationInfo<dim>;'
p879
aS'    static void integrate_cell_term(DoFInfo &dinfo, CellInfo &info);'
p880
aS'    static void integrate_boundary_term(DoFInfo &dinfo, CellInfo &info);'
p881
aS'    static void integrate_face_term(DoFInfo & dinfo1,'
p882
aS'                                    DoFInfo & dinfo2,'
p883
aS'                                    CellInfo &info1,'
p884
aS'                                    CellInfo &info2);'
p885
aS'  };'
p886
aS'  template <int dim>'
p887
aS'  AdvectionProblem<dim>::AdvectionProblem()'
p888
aS'    : mapping()'
p889
aS'    , fe(1)'
p890
aS'    , dof_handler(triangulation)'
p891
aS'  {}'
p892
aS'  template <int dim>'
p893
aS'  void AdvectionProblem<dim>::setup_system()'
p894
aS'  {'
p895
aS'    dof_handler.distribute_dofs(fe);'
p896
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p897
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p898
aS'    sparsity_pattern.copy_from(dsp);'
p899
aS'    system_matrix.reinit(sparsity_pattern);'
p900
aS'    solution.reinit(dof_handler.n_dofs());'
p901
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p902
aS'  }'
p903
aS'  template <int dim>'
p904
aS'  void AdvectionProblem<dim>::assemble_system()'
p905
aS'  {'
p906
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p907
aS'    const unsigned int n_gauss_points = dof_handler.get_fe().degree + 1;'
p908
aS'    info_box.initialize_gauss_quadrature(n_gauss_points,'
p909
aS'                                         n_gauss_points,'
p910
aS'                                         n_gauss_points);'
p911
aS'    info_box.initialize_update_flags();'
p912
aS'    UpdateFlags update_flags ='
p913
aS'      update_quadrature_points | update_values | update_gradients;'
p914
aS'    info_box.add_update_flags(update_flags, true, true, true, true);'
p915
aS'    info_box.initialize(fe, mapping);'
p916
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p917
aS'    MeshWorker::Assembler::SystemSimple<SparseMatrix<double>, Vector<double>>'
p918
aS'      assembler;'
p919
aS'    assembler.initialize(system_matrix, right_hand_side);'
p920
aS'    MeshWorker::loop<dim,'
p921
aS'                     dim,'
p922
aS'                     MeshWorker::DoFInfo<dim>,'
p923
aS'                     MeshWorker::IntegrationInfoBox<dim>>('
p924
aS'      dof_handler.begin_active(),'
p925
aS'      dof_handler.end(),'
p926
aS'      dof_info,'
p927
aS'      info_box,'
p928
aS'      &AdvectionProblem<dim>::integrate_cell_term,'
p929
aS'      &AdvectionProblem<dim>::integrate_boundary_term,'
p930
aS'      &AdvectionProblem<dim>::integrate_face_term,'
p931
aS'      assembler);'
p932
aS'  }'
p933
aS'  template <int dim>'
p934
aS'  void AdvectionProblem<dim>::integrate_cell_term(DoFInfo & dinfo,'
p935
aS'                                                  CellInfo &info)'
p936
aS'  {'
p937
aS'    const FEValuesBase<dim> &  fe_values    = info.fe_values();'
p938
aS'    FullMatrix<double> &       local_matrix = dinfo.matrix(0).matrix;'
p939
aS'    const std::vector<double> &JxW          = fe_values.get_JxW_values();'
p940
aS'    for (unsigned int point = 0; point < fe_values.n_quadrature_points; ++point)'
p941
aS'      {'
p942
aS'        const Tensor<1, dim> beta_at_q_point ='
p943
aS'          beta(fe_values.quadrature_point(point));'
p944
aS'        for (unsigned int i = 0; i < fe_values.dofs_per_cell; ++i)'
p945
aS'          for (unsigned int j = 0; j < fe_values.dofs_per_cell; ++j)'
p946
aS'            local_matrix(i, j) += -beta_at_q_point *                //'
p947
aS'                                  fe_values.shape_grad(i, point) *  //'
p948
aS'                                  fe_values.shape_value(j, point) * //'
p949
aS'                                  JxW[point];'
p950
aS'      }'
p951
aS'  }'
p952
aS'  template <int dim>'
p953
aS'  void AdvectionProblem<dim>::integrate_boundary_term(DoFInfo & dinfo,'
p954
aS'                                                      CellInfo &info)'
p955
aS'  {'
p956
aS'    const FEValuesBase<dim> &fe_face_values = info.fe_values();'
p957
aS'    FullMatrix<double> &     local_matrix   = dinfo.matrix(0).matrix;'
p958
aS'    Vector<double> &         local_vector   = dinfo.vector(0).block(0);'
p959
aS'    const std::vector<double> &        JxW = fe_face_values.get_JxW_values();'
p960
aS'    const std::vector<Tensor<1, dim>> &normals ='
p961
aS'      fe_face_values.get_normal_vectors();'
p962
aS'    std::vector<double> g(fe_face_values.n_quadrature_points);'
p963
aS'    static BoundaryValues<dim> boundary_function;'
p964
aS'    boundary_function.value_list(fe_face_values.get_quadrature_points(), g);'
p965
aS'    for (unsigned int point = 0; point < fe_face_values.n_quadrature_points;'
p966
aS'         ++point)'
p967
aS'      {'
p968
aS'        const double beta_dot_n ='
p969
aS'          beta(fe_face_values.quadrature_point(point)) * normals[point];'
p970
aS'        if (beta_dot_n > 0)'
p971
aS'          for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i)'
p972
aS'            for (unsigned int j = 0; j < fe_face_values.dofs_per_cell; ++j)'
p973
aS'              local_matrix(i, j) += beta_dot_n *                           //'
p974
aS'                                    fe_face_values.shape_value(j, point) * //'
p975
aS'                                    fe_face_values.shape_value(i, point) * //'
p976
aS'                                    JxW[point];'
p977
aS'        else'
p978
aS'          for (unsigned int i = 0; i < fe_face_values.dofs_per_cell; ++i)'
p979
aS'            local_vector(i) += -beta_dot_n *                          //'
p980
aS'                               g[point] *                             //'
p981
aS'                               fe_face_values.shape_value(i, point) * //'
p982
aS'                               JxW[point];'
p983
aS'      }'
p984
aS'  }'
p985
aS'  template <int dim>'
p986
aS'  void AdvectionProblem<dim>::integrate_face_term(DoFInfo & dinfo1,'
p987
aS'                                                  DoFInfo & dinfo2,'
p988
aS'                                                  CellInfo &info1,'
p989
aS'                                                  CellInfo &info2)'
p990
aS'  {'
p991
aS'    const FEValuesBase<dim> &fe_face_values = info1.fe_values();'
p992
aS'    const unsigned int       dofs_per_cell  = fe_face_values.dofs_per_cell;'
p993
aS'    const FEValuesBase<dim> &fe_face_values_neighbor = info2.fe_values();'
p994
aS'    const unsigned int       neighbor_dofs_per_cell ='
p995
aS'      fe_face_values_neighbor.dofs_per_cell;'
p996
aS'    FullMatrix<double> &u1_v1_matrix = dinfo1.matrix(0, false).matrix;'
p997
aS'    FullMatrix<double> &u2_v1_matrix = dinfo1.matrix(0, true).matrix;'
p998
aS'    FullMatrix<double> &u1_v2_matrix = dinfo2.matrix(0, true).matrix;'
p999
aS'    FullMatrix<double> &u2_v2_matrix = dinfo2.matrix(0, false).matrix;'
p1000
aS'    const std::vector<double> &        JxW = fe_face_values.get_JxW_values();'
p1001
aS'    const std::vector<Tensor<1, dim>> &normals ='
p1002
aS'      fe_face_values.get_normal_vectors();'
p1003
aS'    for (unsigned int point = 0; point < fe_face_values.n_quadrature_points;'
p1004
aS'         ++point)'
p1005
aS'      {'
p1006
aS'        const double beta_dot_n ='
p1007
aS'          beta(fe_face_values.quadrature_point(point)) * normals[point];'
p1008
aS'        if (beta_dot_n > 0)'
p1009
aS'          {'
p1010
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1011
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p1012
aS'                u1_v1_matrix(i, j) += beta_dot_n *                           //'
p1013
aS'                                      fe_face_values.shape_value(j, point) * //'
p1014
aS'                                      fe_face_values.shape_value(i, point) * //'
p1015
aS'                                      JxW[point];'
p1016
aS'            for (unsigned int k = 0; k < neighbor_dofs_per_cell; ++k)'
p1017
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p1018
aS'                u1_v2_matrix(k, j) +='
p1019
aS'                  -beta_dot_n *                                   //'
p1020
aS'                  fe_face_values.shape_value(j, point) *          //'
p1021
aS'                  fe_face_values_neighbor.shape_value(k, point) * //'
p1022
aS'                  JxW[point];'
p1023
aS'          }'
p1024
aS'        else'
p1025
aS'          {'
p1026
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1027
aS'              for (unsigned int l = 0; l < neighbor_dofs_per_cell; ++l)'
p1028
aS'                u2_v1_matrix(i, l) +='
p1029
aS'                  beta_dot_n *                                    //'
p1030
aS'                  fe_face_values_neighbor.shape_value(l, point) * //'
p1031
aS'                  fe_face_values.shape_value(i, point) *          //'
p1032
aS'                  JxW[point];'
p1033
aS'            for (unsigned int k = 0; k < neighbor_dofs_per_cell; ++k)'
p1034
aS'              for (unsigned int l = 0; l < neighbor_dofs_per_cell; ++l)'
p1035
aS'                u2_v2_matrix(k, l) +='
p1036
aS'                  -beta_dot_n *                                   //'
p1037
aS'                  fe_face_values_neighbor.shape_value(l, point) * //'
p1038
aS'                  fe_face_values_neighbor.shape_value(k, point) * //'
p1039
aS'                  JxW[point];'
p1040
aS'          }'
p1041
aS'      }'
p1042
aS'  }'
p1043
aS'  template <int dim>'
p1044
aS'  void AdvectionProblem<dim>::solve(Vector<double> &solution)'
p1045
aS'  {'
p1046
aS'    SolverControl                    solver_control(1000, 1e-12);'
p1047
aS'    SolverRichardson<Vector<double>> solver(solver_control);'
p1048
aS'    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;'
p1049
aS'    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());'
p1050
aS'    solver.solve(system_matrix, solution, right_hand_side, preconditioner);'
p1051
aS'  }'
p1052
aS'  template <int dim>'
p1053
aS'  void AdvectionProblem<dim>::refine_grid()'
p1054
aS'  {'
p1055
aS'    Vector<float> gradient_indicator(triangulation.n_active_cells());'
p1056
aS'    DerivativeApproximation::approximate_gradient(mapping,'
p1057
aS'                                                  dof_handler,'
p1058
aS'                                                  solution,'
p1059
aS'                                                  gradient_indicator);'
p1060
aS'    unsigned int cell_no = 0;'
p1061
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p1062
aS'      gradient_indicator(cell_no++) *='
p1063
aS'        std::pow(cell->diameter(), 1 + 1.0 * dim / 2);'
p1064
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p1065
aS'                                                    gradient_indicator,'
p1066
aS'                                                    0.3,'
p1067
aS'                                                    0.1);'
p1068
aS'    triangulation.execute_coarsening_and_refinement();'
p1069
aS'  }'
p1070
aS'  template <int dim>'
p1071
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p1072
aS'  {'
p1073
aS'    {'
p1074
aS'      const std::string filename = "grid-" + std::to_string(cycle) + ".eps";'
p1075
aS'      deallog << "Writing grid to <" << filename << ">" << std::endl;'
p1076
aS'      std::ofstream eps_output(filename);'
p1077
aS'      GridOut grid_out;'
p1078
aS'      grid_out.write_eps(triangulation, eps_output);'
p1079
aS'    }'
p1080
aS'    {'
p1081
aS'      const std::string filename = "sol-" + std::to_string(cycle) + ".gnuplot";'
p1082
aS'      deallog << "Writing solution to <" << filename << ">" << std::endl;'
p1083
aS'      std::ofstream gnuplot_output(filename);'
p1084
aS'      DataOut<dim> data_out;'
p1085
aS'      data_out.attach_dof_handler(dof_handler);'
p1086
aS'      data_out.add_data_vector(solution, "u");'
p1087
aS'      data_out.build_patches();'
p1088
aS'      data_out.write_gnuplot(gnuplot_output);'
p1089
aS'    }'
p1090
aS'  }'
p1091
aS'  template <int dim>'
p1092
aS'  void AdvectionProblem<dim>::run()'
p1093
aS'  {'
p1094
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p1095
aS'      {'
p1096
aS'        deallog << "Cycle " << cycle << std::endl;'
p1097
aS'        if (cycle == 0)'
p1098
aS'          {'
p1099
aS'            GridGenerator::hyper_cube(triangulation);'
p1100
aS'            triangulation.refine_global(3);'
p1101
aS'          }'
p1102
aS'        else'
p1103
aS'          refine_grid();'
p1104
aS'        deallog << "Number of active cells:       "'
p1105
aS'                << triangulation.n_active_cells() << std::endl;'
p1106
aS'        setup_system();'
p1107
aS'        deallog << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p1108
aS'                << std::endl;'
p1109
aS'        assemble_system();'
p1110
aS'        solve(solution);'
p1111
aS'        output_results(cycle);'
p1112
aS'      }'
p1113
aS'  }'
p1114
aS'} // namespace Step12'
p1115
aS'int main()'
p1116
ag9
aS'  try'
p1117
aS'    {'
p1118
aS'      dealii::deallog.depth_console(5);'
p1119
aS'      Step12::AdvectionProblem<2> dgmethod;'
p1120
aS'      dgmethod.run();'
p1121
aS'    }'
p1122
aS'  catch (std::exception &exc)'
p1123
aS'    {'
p1124
aS'      std::cerr << std::endl'
p1125
aS'                << std::endl'
p1126
aS'                << "----------------------------------------------------"'
p1127
aS'                << std::endl;'
p1128
aS'      std::cerr << "Exception on processing: " << std::endl'
p1129
aS'                << exc.what() << std::endl'
p1130
aS'                << "Aborting!" << std::endl'
p1131
aS'                << "----------------------------------------------------"'
p1132
aS'                << std::endl;'
p1133
aS'      return 1;'
p1134
aS'    }'
p1135
aS'  catch (...)'
p1136
aS'    {'
p1137
aS'      std::cerr << std::endl'
p1138
aS'                << std::endl'
p1139
aS'                << "----------------------------------------------------"'
p1140
aS'                << std::endl;'
p1141
aS'      std::cerr << "Unknown exception!" << std::endl'
p1142
aS'                << "Aborting!" << std::endl'
p1143
aS'                << "----------------------------------------------------"'
p1144
aS'                << std::endl;'
p1145
aS'      return 1;'
p1146
aS'    }'
p1147
aS'  return 0;'
p1148
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p1149
aS'#include <deal.II/base/function.h>'
p1150
aS'#include <deal.II/base/logstream.h>'
p1151
aS'#include <deal.II/base/table_handler.h>'
p1152
aS'#include <deal.II/base/thread_management.h>'
p1153
aS'#include <deal.II/base/work_stream.h>'
p1154
aS'#include <deal.II/lac/vector.h>'
p1155
aS'#include <deal.II/lac/full_matrix.h>'
p1156
aS'#include <deal.II/lac/sparse_matrix.h>'
p1157
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p1158
aS'#include <deal.II/lac/solver_cg.h>'
p1159
aS'#include <deal.II/lac/precondition.h>'
p1160
aS'#include <deal.II/lac/affine_constraints.h>'
p1161
aS'#include <deal.II/grid/tria.h>'
p1162
aS'#include <deal.II/grid/grid_generator.h>'
p1163
aS'#include <deal.II/grid/grid_refinement.h>'
p1164
aS'#include <deal.II/dofs/dof_handler.h>'
p1165
aS'#include <deal.II/dofs/dof_tools.h>'
p1166
aS'#include <deal.II/fe/fe_q.h>'
p1167
aS'#include <deal.II/fe/fe_values.h>'
p1168
aS'#include <deal.II/numerics/vector_tools.h>'
p1169
aS'#include <deal.II/numerics/matrix_tools.h>'
p1170
aS'#include <deal.II/numerics/data_out.h>'
p1171
aS'#include <deal.II/numerics/error_estimator.h>'
p1172
aS'#include <iostream>'
p1173
aS'#include <fstream>'
p1174
aS'#include <list>'
p1175
aS'namespace Step13'
p1176
ag9
aS'  using namespace dealii;'
p1177
aS'  namespace Evaluation'
p1178
aS'  {'
p1179
aS'    template <int dim>'
p1180
aS'    class EvaluationBase'
p1181
aS'    {'
p1182
aS'    public:'
p1183
aS'      virtual ~EvaluationBase() = default;'
p1184
aS'      void set_refinement_cycle(const unsigned int refinement_cycle);'
p1185
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1186
aS'                              const Vector<double> & solution) const = 0;'
p1187
aS'    protected:'
p1188
aS'      unsigned int refinement_cycle;'
p1189
aS'    };'
p1190
aS'    template <int dim>'
p1191
aS'    void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)'
p1192
aS'    {'
p1193
aS'      refinement_cycle = step;'
p1194
aS'    }'
p1195
aS'    template <int dim>'
p1196
aS'    class PointValueEvaluation : public EvaluationBase<dim>'
p1197
aS'    {'
p1198
aS'    public:'
p1199
aS'      PointValueEvaluation(const Point<dim> &evaluation_point,'
p1200
aS'                           TableHandler &    results_table);'
p1201
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1202
aS'                              const Vector<double> & solution) const override;'
p1203
aS'      DeclException1('
p1204
aS'        ExcEvaluationPointNotFound,'
p1205
aS'        Point<dim>,'
p1206
aS'        << "The evaluation point " << arg1'
p1207
aS'        << " was not found among the vertices of the present grid.");'
p1208
aS'    private:'
p1209
aS'      const Point<dim> evaluation_point;'
p1210
aS'      TableHandler &   results_table;'
p1211
aS'    };'
p1212
aS'    template <int dim>'
p1213
aS'    PointValueEvaluation<dim>::PointValueEvaluation('
p1214
aS'      const Point<dim> &evaluation_point,'
p1215
aS'      TableHandler &    results_table)'
p1216
aS'      : evaluation_point(evaluation_point)'
p1217
aS'      , results_table(results_table)'
p1218
aS'    {}'
p1219
aS'    template <int dim>'
p1220
aS'    void PointValueEvaluation<dim>::'
p1221
aS'         operator()(const DoFHandler<dim> &dof_handler,'
p1222
aS'               const Vector<double> & solution) const'
p1223
aS'    {'
p1224
aS'      double point_value = 1e20;'
p1225
aS'      bool evaluation_point_found = false;'
p1226
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p1227
aS'        if (!evaluation_point_found)'
p1228
aS'          for (const auto vertex : cell->vertex_indices())'
p1229
aS'            if (cell->vertex(vertex) == evaluation_point)'
p1230
aS'              {'
p1231
aS'                point_value = solution(cell->vertex_dof_index(vertex, 0));'
p1232
aS'                evaluation_point_found = true;'
p1233
aS'                break;'
p1234
aS'              };'
p1235
aS'      AssertThrow(evaluation_point_found,'
p1236
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p1237
aS'      results_table.add_value("DoFs", dof_handler.n_dofs());'
p1238
aS'      results_table.add_value("u(x_0)", point_value);'
p1239
aS'    }'
p1240
aS'    template <int dim>'
p1241
aS'    class SolutionOutput : public EvaluationBase<dim>'
p1242
aS'    {'
p1243
aS'    public:'
p1244
aS'      SolutionOutput(const std::string &             output_name_base,'
p1245
aS'                     const DataOutBase::OutputFormat output_format);'
p1246
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1247
aS'                              const Vector<double> & solution) const override;'
p1248
aS'    private:'
p1249
aS'      const std::string               output_name_base;'
p1250
aS'      const DataOutBase::OutputFormat output_format;'
p1251
aS'    };'
p1252
aS'    template <int dim>'
p1253
aS'    SolutionOutput<dim>::SolutionOutput('
p1254
aS'      const std::string &             output_name_base,'
p1255
aS'      const DataOutBase::OutputFormat output_format)'
p1256
aS'      : output_name_base(output_name_base)'
p1257
aS'      , output_format(output_format)'
p1258
aS'    {}'
p1259
aS'    template <int dim>'
p1260
aS'    void SolutionOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,'
p1261
aS'                                         const Vector<double> & solution) const'
p1262
aS'    {'
p1263
aS'      DataOut<dim> data_out;'
p1264
aS'      data_out.attach_dof_handler(dof_handler);'
p1265
aS'      data_out.add_data_vector(solution, "solution");'
p1266
aS'      data_out.build_patches();'
p1267
aS'      std::ofstream out(output_name_base + "-" +'
p1268
aS'                        std::to_string(this->refinement_cycle) +'
p1269
aS'                        data_out.default_suffix(output_format));'
p1270
aS'      data_out.write(out, output_format);'
p1271
aS'    }'
p1272
aS'  } // namespace Evaluation'
p1273
aS'  namespace LaplaceSolver'
p1274
aS'  {'
p1275
aS'    template <int dim>'
p1276
aS'    class Base'
p1277
aS'    {'
p1278
aS'    public:'
p1279
aS'      Base(Triangulation<dim> &coarse_grid);'
p1280
aS'      virtual ~Base() = default;'
p1281
aS'      virtual void solve_problem() = 0;'
p1282
aS'      virtual void postprocess('
p1283
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;'
p1284
aS'      virtual void         refine_grid()                            = 0;'
p1285
aS'      virtual unsigned int n_dofs() const                           = 0;'
p1286
aS'    protected:'
p1287
aS'      const SmartPointer<Triangulation<dim>> triangulation;'
p1288
aS'    };'
p1289
aS'    template <int dim>'
p1290
aS'    Base<dim>::Base(Triangulation<dim> &coarse_grid)'
p1291
aS'      : triangulation(&coarse_grid)'
p1292
aS'    {}'
p1293
aS'    template <int dim>'
p1294
aS'    class Solver : public virtual Base<dim>'
p1295
aS'    {'
p1296
aS'    public:'
p1297
aS'      Solver(Triangulation<dim> &      triangulation,'
p1298
aS'             const FiniteElement<dim> &fe,'
p1299
aS'             const Quadrature<dim> &   quadrature,'
p1300
aS'             const Function<dim> &     boundary_values);'
p1301
aS'      virtual ~Solver() override;'
p1302
aS'      virtual void solve_problem() override;'
p1303
aS'      virtual void postprocess('
p1304
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const override;'
p1305
aS'      virtual unsigned int n_dofs() const override;'
p1306
aS'    protected:'
p1307
aS'      const SmartPointer<const FiniteElement<dim>> fe;'
p1308
aS'      const SmartPointer<const Quadrature<dim>>    quadrature;'
p1309
aS'      DoFHandler<dim>                              dof_handler;'
p1310
aS'      Vector<double>                               solution;'
p1311
aS'      const SmartPointer<const Function<dim>>      boundary_values;'
p1312
aS'      virtual void assemble_rhs(Vector<double> &rhs) const = 0;'
p1313
aS'    private:'
p1314
aS'      struct LinearSystem'
p1315
aS'      {'
p1316
aS'        LinearSystem(const DoFHandler<dim> &dof_handler);'
p1317
aS'        void solve(Vector<double> &solution) const;'
p1318
aS'        AffineConstraints<double> hanging_node_constraints;'
p1319
aS'        SparsityPattern           sparsity_pattern;'
p1320
aS'        SparseMatrix<double>      matrix;'
p1321
aS'        Vector<double>            rhs;'
p1322
aS'      };'
p1323
aS'      struct AssemblyScratchData'
p1324
aS'      {'
p1325
aS'        AssemblyScratchData(const FiniteElement<dim> &fe,'
p1326
aS'                            const Quadrature<dim> &   quadrature);'
p1327
aS'        AssemblyScratchData(const AssemblyScratchData &scratch_data);'
p1328
aS'        FEValues<dim> fe_values;'
p1329
aS'      };'
p1330
aS'      struct AssemblyCopyData'
p1331
aS'      {'
p1332
aS'        FullMatrix<double>                   cell_matrix;'
p1333
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p1334
aS'      };'
p1335
aS'      void assemble_linear_system(LinearSystem &linear_system);'
p1336
aS'      void local_assemble_matrix('
p1337
aS'        const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1338
aS'        AssemblyScratchData &                                 scratch_data,'
p1339
aS'        AssemblyCopyData &                                    copy_data) const;'
p1340
aS'      void copy_local_to_global(const AssemblyCopyData &copy_data,'
p1341
aS'                                LinearSystem &          linear_system) const;'
p1342
aS'    };'
p1343
aS'    template <int dim>'
p1344
aS'    Solver<dim>::Solver(Triangulation<dim> &      triangulation,'
p1345
aS'                        const FiniteElement<dim> &fe,'
p1346
aS'                        const Quadrature<dim> &   quadrature,'
p1347
aS'                        const Function<dim> &     boundary_values)'
p1348
aS'      : Base<dim>(triangulation)'
p1349
aS'      , fe(&fe)'
p1350
aS'      , quadrature(&quadrature)'
p1351
aS'      , dof_handler(triangulation)'
p1352
aS'      , boundary_values(&boundary_values)'
p1353
aS'    {}'
p1354
aS'    template <int dim>'
p1355
aS'    Solver<dim>::~Solver()'
p1356
aS'    {'
p1357
aS'      dof_handler.clear();'
p1358
aS'    }'
p1359
aS'    template <int dim>'
p1360
aS'    void Solver<dim>::solve_problem()'
p1361
aS'    {'
p1362
aS'      dof_handler.distribute_dofs(*fe);'
p1363
aS'      solution.reinit(dof_handler.n_dofs());'
p1364
aS'      LinearSystem linear_system(dof_handler);'
p1365
aS'      assemble_linear_system(linear_system);'
p1366
aS'      linear_system.solve(solution);'
p1367
aS'    }'
p1368
aS'    template <int dim>'
p1369
aS'    void Solver<dim>::postprocess('
p1370
aS'      const Evaluation::EvaluationBase<dim> &postprocessor) const'
p1371
aS'    {'
p1372
aS'      postprocessor(dof_handler, solution);'
p1373
aS'    }'
p1374
aS'    template <int dim>'
p1375
aS'    unsigned int Solver<dim>::n_dofs() const'
p1376
aS'    {'
p1377
aS'      return dof_handler.n_dofs();'
p1378
aS'    }'
p1379
aS'    template <int dim>'
p1380
aS'    void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)'
p1381
aS'    {'
p1382
aS'      Threads::Task<void> rhs_task ='
p1383
aS'        Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);'
p1384
aS'      auto worker ='
p1385
aS'        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1386
aS'               AssemblyScratchData &scratch_data,'
p1387
aS'               AssemblyCopyData &   copy_data) {'
p1388
aS'          this->local_assemble_matrix(cell, scratch_data, copy_data);'
p1389
aS'        };'
p1390
aS'      auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {'
p1391
aS'        this->copy_local_to_global(copy_data, linear_system);'
p1392
aS'      };'
p1393
aS'      WorkStream::run(dof_handler.begin_active(),'
p1394
aS'                      dof_handler.end(),'
p1395
aS'                      worker,'
p1396
aS'                      copier,'
p1397
aS'                      AssemblyScratchData(*fe, *quadrature),'
p1398
aS'                      AssemblyCopyData());'
p1399
aS'      linear_system.hanging_node_constraints.condense(linear_system.matrix);'
p1400
aS'      std::map<types::global_dof_index, double> boundary_value_map;'
p1401
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p1402
aS'                                               0,'
p1403
aS'                                               boundary_value_map);'
p1404
aS'      rhs_task.join();'
p1405
aS'      linear_system.hanging_node_constraints.condense(linear_system.rhs);'
p1406
aS'      MatrixTools::apply_boundary_values(boundary_value_map,'
p1407
aS'                                         linear_system.matrix,'
p1408
aS'                                         solution,'
p1409
aS'                                         linear_system.rhs);'
p1410
aS'    }'
p1411
aS'    template <int dim>'
p1412
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p1413
aS'      const FiniteElement<dim> &fe,'
p1414
aS'      const Quadrature<dim> &   quadrature)'
p1415
aS'      : fe_values(fe, quadrature, update_gradients | update_JxW_values)'
p1416
aS'    {}'
p1417
aS'    template <int dim>'
p1418
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p1419
aS'      const AssemblyScratchData &scratch_data)'
p1420
aS'      : fe_values(scratch_data.fe_values.get_fe(),'
p1421
aS'                  scratch_data.fe_values.get_quadrature(),'
p1422
aS'                  update_gradients | update_JxW_values)'
p1423
aS'    {}'
p1424
aS'    template <int dim>'
p1425
aS'    void Solver<dim>::local_assemble_matrix('
p1426
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1427
aS'      AssemblyScratchData &                                 scratch_data,'
p1428
aS'      AssemblyCopyData &                                    copy_data) const'
p1429
aS'    {'
p1430
aS'      const unsigned int dofs_per_cell = fe->n_dofs_per_cell();'
p1431
aS'      const unsigned int n_q_points    = quadrature->size();'
p1432
aS'      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p1433
aS'      copy_data.local_dof_indices.resize(dofs_per_cell);'
p1434
aS'      scratch_data.fe_values.reinit(cell);'
p1435
aS'      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p1436
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1437
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p1438
aS'            copy_data.cell_matrix(i, j) +='
p1439
aS'               scratch_data.fe_values.shape_grad(j, q_point) *'
p1440
aS'               scratch_data.fe_values.JxW(q_point));'
p1441
aS'      cell->get_dof_indices(copy_data.local_dof_indices);'
p1442
aS'    }'
p1443
aS'    template <int dim>'
p1444
aS'    void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,'
p1445
aS'                                           LinearSystem &linear_system) const'
p1446
aS'    {'
p1447
aS'      for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)'
p1448
aS'        for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)'
p1449
aS'          linear_system.matrix.add(copy_data.local_dof_indices[i],'
p1450
aS'                                   copy_data.local_dof_indices[j],'
p1451
aS'                                   copy_data.cell_matrix(i, j));'
p1452
aS'    }'
p1453
aS'    template <int dim>'
p1454
aS'    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)'
p1455
aS'    {'
p1456
aS'      hanging_node_constraints.clear();'
p1457
aS'      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) ='
p1458
aS'        &DoFTools::make_hanging_node_constraints;'
p1459
aS'      Threads::Task<void> side_task ='
p1460
aS'        Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);'
p1461
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p1462
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p1463
aS'      side_task.join();'
p1464
aS'      hanging_node_constraints.close();'
p1465
aS'      hanging_node_constraints.condense(dsp);'
p1466
aS'      sparsity_pattern.copy_from(dsp);'
p1467
aS'      matrix.reinit(sparsity_pattern);'
p1468
aS'      rhs.reinit(dof_handler.n_dofs());'
p1469
aS'    }'
p1470
aS'    template <int dim>'
p1471
aS'    void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const'
p1472
aS'    {'
p1473
aS'      SolverControl            solver_control(1000, 1e-12);'
p1474
aS'      SolverCG<Vector<double>> cg(solver_control);'
p1475
aS'      PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p1476
aS'      preconditioner.initialize(matrix, 1.2);'
p1477
aS'      cg.solve(matrix, solution, rhs, preconditioner);'
p1478
aS'      hanging_node_constraints.distribute(solution);'
p1479
aS'    }'
p1480
aS'    template <int dim>'
p1481
aS'    class PrimalSolver : public Solver<dim>'
p1482
aS'    {'
p1483
aS'    public:'
p1484
aS'      PrimalSolver(Triangulation<dim> &      triangulation,'
p1485
aS'                   const FiniteElement<dim> &fe,'
p1486
aS'                   const Quadrature<dim> &   quadrature,'
p1487
aS'                   const Function<dim> &     rhs_function,'
p1488
aS'                   const Function<dim> &     boundary_values);'
p1489
aS'    protected:'
p1490
aS'      const SmartPointer<const Function<dim>> rhs_function;'
p1491
aS'      virtual void assemble_rhs(Vector<double> &rhs) const override;'
p1492
aS'    };'
p1493
aS'    template <int dim>'
p1494
aS'    PrimalSolver<dim>::PrimalSolver(Triangulation<dim> &      triangulation,'
p1495
aS'                                    const FiniteElement<dim> &fe,'
p1496
aS'                                    const Quadrature<dim> &   quadrature,'
p1497
aS'                                    const Function<dim> &     rhs_function,'
p1498
aS'                                    const Function<dim> &     boundary_values)'
p1499
aS'      : Base<dim>(triangulation)'
p1500
aS'      , Solver<dim>(triangulation, fe, quadrature, boundary_values)'
p1501
aS'      , rhs_function(&rhs_function)'
p1502
aS'    {}'
p1503
aS'    template <int dim>'
p1504
aS'    void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const'
p1505
aS'    {'
p1506
aS'      FEValues<dim> fe_values(*this->fe,'
p1507
aS'                              update_values | update_quadrature_points |'
p1508
aS'                                update_JxW_values);'
p1509
aS'      const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();'
p1510
aS'      const unsigned int n_q_points    = this->quadrature->size();'
p1511
aS'      Vector<double>                       cell_rhs(dofs_per_cell);'
p1512
aS'      std::vector<double>                  rhs_values(n_q_points);'
p1513
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p1514
aS'      for (const auto &cell : this->dof_handler.active_cell_iterators())'
p1515
aS'        {'
p1516
aS'          cell_rhs = 0;'
p1517
aS'          fe_values.reinit(cell);'
p1518
aS'          rhs_function->value_list(fe_values.get_quadrature_points(),'
p1519
aS'                                   rhs_values);'
p1520
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p1521
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1522
aS'              cell_rhs(i) += fe_values.shape_value(i, q_point) * //'
p1523
aS'                             rhs_values[q_point] *               //'
p1524
aS'                             fe_values.JxW(q_point);'
p1525
aS'          cell->get_dof_indices(local_dof_indices);'
p1526
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p1527
aS'            rhs(local_dof_indices[i]) += cell_rhs(i);'
p1528
aS'        };'
p1529
aS'    }'
p1530
aS'    template <int dim>'
p1531
aS'    class RefinementGlobal : public PrimalSolver<dim>'
p1532
aS'    {'
p1533
aS'    public:'
p1534
aS'      RefinementGlobal(Triangulation<dim> &      coarse_grid,'
p1535
aS'                       const FiniteElement<dim> &fe,'
p1536
aS'                       const Quadrature<dim> &   quadrature,'
p1537
aS'                       const Function<dim> &     rhs_function,'
p1538
aS'                       const Function<dim> &     boundary_values);'
p1539
aS'      virtual void refine_grid() override;'
p1540
aS'    };'
p1541
aS'    template <int dim>'
p1542
aS'    RefinementGlobal<dim>::RefinementGlobal('
p1543
aS'      Triangulation<dim> &      coarse_grid,'
p1544
aS'      const FiniteElement<dim> &fe,'
p1545
aS'      const Quadrature<dim> &   quadrature,'
p1546
aS'      const Function<dim> &     rhs_function,'
p1547
aS'      const Function<dim> &     boundary_values)'
p1548
aS'      : Base<dim>(coarse_grid)'
p1549
aS'      , PrimalSolver<dim>(coarse_grid,'
p1550
aS'                          fe,'
p1551
aS'                          quadrature,'
p1552
aS'                          rhs_function,'
p1553
aS'                          boundary_values)'
p1554
aS'    {}'
p1555
aS'    template <int dim>'
p1556
aS'    void RefinementGlobal<dim>::refine_grid()'
p1557
aS'    {'
p1558
aS'      this->triangulation->refine_global(1);'
p1559
aS'    }'
p1560
aS'    template <int dim>'
p1561
aS'    class RefinementKelly : public PrimalSolver<dim>'
p1562
aS'    {'
p1563
aS'    public:'
p1564
aS'      RefinementKelly(Triangulation<dim> &      coarse_grid,'
p1565
aS'                      const FiniteElement<dim> &fe,'
p1566
aS'                      const Quadrature<dim> &   quadrature,'
p1567
aS'                      const Function<dim> &     rhs_function,'
p1568
aS'                      const Function<dim> &     boundary_values);'
p1569
aS'      virtual void refine_grid() override;'
p1570
aS'    };'
p1571
aS'    template <int dim>'
p1572
aS'    RefinementKelly<dim>::RefinementKelly(Triangulation<dim> &      coarse_grid,'
p1573
aS'                                          const FiniteElement<dim> &fe,'
p1574
aS'                                          const Quadrature<dim> &   quadrature,'
p1575
aS'                                          const Function<dim> &rhs_function,'
p1576
aS'                                          const Function<dim> &boundary_values)'
p1577
aS'      : Base<dim>(coarse_grid)'
p1578
aS'      , PrimalSolver<dim>(coarse_grid,'
p1579
aS'                          fe,'
p1580
aS'                          quadrature,'
p1581
aS'                          rhs_function,'
p1582
aS'                          boundary_values)'
p1583
aS'    {}'
p1584
aS'    template <int dim>'
p1585
aS'    void RefinementKelly<dim>::refine_grid()'
p1586
aS'    {'
p1587
aS'      Vector<float> estimated_error_per_cell('
p1588
aS'        this->triangulation->n_active_cells());'
p1589
aS'      KellyErrorEstimator<dim>::estimate('
p1590
aS'        this->dof_handler,'
p1591
aS'        QGauss<dim - 1>(this->fe->degree + 1),'
p1592
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p1593
aS'        this->solution,'
p1594
aS'        estimated_error_per_cell);'
p1595
aS'      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,'
p1596
aS'                                                      estimated_error_per_cell,'
p1597
aS'                                                      0.3,'
p1598
aS'                                                      0.03);'
p1599
aS'      this->triangulation->execute_coarsening_and_refinement();'
p1600
aS'    }'
p1601
aS'  } // namespace LaplaceSolver'
p1602
aS'  template <int dim>'
p1603
aS'  class Solution : public Function<dim>'
p1604
aS'  {'
p1605
aS'  public:'
p1606
aS'    virtual double value(const Point<dim> & p,'
p1607
aS'                         const unsigned int component) const override;'
p1608
aS'  };'
p1609
aS'  template <int dim>'
p1610
aS'  double Solution<dim>::value(const Point<dim> & p,'
p1611
aS'                              const unsigned int component) const'
p1612
aS'  {'
p1613
aS'    AssertIndexRange(component, 1);'
p1614
aS'    double q = p(0);'
p1615
aS'    for (unsigned int i = 1; i < dim; ++i)'
p1616
aS'      q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p1617
aS'    const double exponential = std::exp(q);'
p1618
aS'    return exponential;'
p1619
aS'  }'
p1620
aS'  template <int dim>'
p1621
aS'  class RightHandSide : public Function<dim>'
p1622
aS'  {'
p1623
aS'  public:'
p1624
aS'    virtual double value(const Point<dim> & p,'
p1625
aS'                         const unsigned int component) const override;'
p1626
aS'  };'
p1627
aS'  template <int dim>'
p1628
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p1629
aS'                                   const unsigned int component) const'
p1630
aS'  {'
p1631
aS'    AssertIndexRange(component, 1);'
p1632
aS'    double q = p(0);'
p1633
aS'    for (unsigned int i = 1; i < dim; ++i)'
p1634
aS'      q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p1635
aS'    const double u  = std::exp(q);'
p1636
aS'    double       t1 = 1, t2 = 0, t3 = 0;'
p1637
aS'    for (unsigned int i = 1; i < dim; ++i)'
p1638
aS'      {'
p1639
aS'        t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);'
p1640
aS'        t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p1641
aS'              100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);'
p1642
aS'        t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) *'
p1643
aS'                std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p1644
aS'              100 * std::sin(10 * p(i) + 5 * p(0) * p(0));'
p1645
aS'      };'
p1646
aS'    t1 = t1 * t1;'
p1647
aS'    return -u * (t1 + t2 + t3);'
p1648
aS'  }'
p1649
aS'  template <int dim>'
p1650
aS'  void run_simulation('
p1651
aS'    LaplaceSolver::Base<dim> &                          solver,'
p1652
aS'    const std::list<Evaluation::EvaluationBase<dim> *> &postprocessor_list)'
p1653
aS'  {'
p1654
aS'    std::cout << "Refinement cycle: ";'
p1655
aS'    for (unsigned int step = 0; true; ++step)'
p1656
aS'      {'
p1657
aS'        std::cout << step << " " << std::flush;'
p1658
aS'        solver.solve_problem();'
p1659
aS'        for (const auto &postprocessor : postprocessor_list)'
p1660
aS'          {'
p1661
aS'            postprocessor->set_refinement_cycle(step);'
p1662
aS'            solver.postprocess(*postprocessor);'
p1663
aS'          };'
p1664
aS'        if (solver.n_dofs() < 20000)'
p1665
aS'          solver.refine_grid();'
p1666
aS'        else'
p1667
aS'          break;'
p1668
aS'      };'
p1669
aS'    std::cout << std::endl;'
p1670
aS'  }'
p1671
aS'  template <int dim>'
p1672
aS'  void solve_problem(const std::string &solver_name)'
p1673
aS'  {'
p1674
aS'    const std::string header ='
p1675
aS'      "Running tests with \\"" + solver_name + "\\" refinement criterion:";'
p1676
aS'    std::cout << header << std::endl'
p1677
aS"              << std::string(header.size(), '-') << std::endl;"
p1678
aS'    Triangulation<dim> triangulation;'
p1679
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p1680
aS'    triangulation.refine_global(2);'
p1681
aS'    const FE_Q<dim>    fe(1);'
p1682
aS'    const QGauss<dim>  quadrature(4);'
p1683
aS'    RightHandSide<dim> rhs_function;'
p1684
aS'    Solution<dim>      boundary_values;'
p1685
aS'    std::unique_ptr<LaplaceSolver::Base<dim>> solver;'
p1686
aS'    if (solver_name == "global")'
p1687
aS'      solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>('
p1688
aS'        triangulation, fe, quadrature, rhs_function, boundary_values);'
p1689
aS'    else if (solver_name == "kelly")'
p1690
aS'      solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>('
p1691
aS'        triangulation, fe, quadrature, rhs_function, boundary_values);'
p1692
aS'    else'
p1693
aS'      AssertThrow(false, ExcNotImplemented());'
p1694
aS'    TableHandler                          results_table;'
p1695
aS'    Evaluation::PointValueEvaluation<dim> postprocessor1(Point<dim>(0.5, 0.5),'
p1696
aS'                                                         results_table);'
p1697
aS'    Evaluation::SolutionOutput<dim> postprocessor2(std::string("solution-") +'
p1698
aS'                                                     solver_name,'
p1699
aS'                                                   DataOutBase::gnuplot);'
p1700
aS'    std::list<Evaluation::EvaluationBase<dim> *> postprocessor_list;'
p1701
aS'    postprocessor_list.push_back(&postprocessor1);'
p1702
aS'    postprocessor_list.push_back(&postprocessor2);'
p1703
aS'    run_simulation(*solver, postprocessor_list);'
p1704
aS'    results_table.write_text(std::cout);'
p1705
aS'    std::cout << std::endl;'
p1706
aS'  }'
p1707
aS'} // namespace Step13'
p1708
aS'int main()'
p1709
ag9
aS'  try'
p1710
aS'    {'
p1711
aS'      Step13::solve_problem<2>("global");'
p1712
aS'      Step13::solve_problem<2>("kelly");'
p1713
aS'    }'
p1714
aS'  catch (std::exception &exc)'
p1715
aS'    {'
p1716
aS'      std::cerr << std::endl'
p1717
aS'                << std::endl'
p1718
aS'                << "----------------------------------------------------"'
p1719
aS'                << std::endl;'
p1720
aS'      std::cerr << "Exception on processing: " << std::endl'
p1721
aS'                << exc.what() << std::endl'
p1722
aS'                << "Aborting!" << std::endl'
p1723
aS'                << "----------------------------------------------------"'
p1724
aS'                << std::endl;'
p1725
aS'      return 1;'
p1726
aS'    }'
p1727
aS'  catch (...)'
p1728
aS'    {'
p1729
aS'      std::cerr << std::endl'
p1730
aS'                << std::endl'
p1731
aS'                << "----------------------------------------------------"'
p1732
aS'                << std::endl;'
p1733
aS'      std::cerr << "Unknown exception!" << std::endl'
p1734
aS'                << "Aborting!" << std::endl'
p1735
aS'                << "----------------------------------------------------"'
p1736
aS'                << std::endl;'
p1737
aS'      return 1;'
p1738
aS'    };'
p1739
aS'  return 0;'
p1740
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p1741
aS'#include <deal.II/base/function.h>'
p1742
aS'#include <deal.II/base/logstream.h>'
p1743
aS'#include <deal.II/base/thread_management.h>'
p1744
aS'#include <deal.II/base/work_stream.h>'
p1745
aS'#include <deal.II/lac/vector.h>'
p1746
aS'#include <deal.II/lac/full_matrix.h>'
p1747
aS'#include <deal.II/lac/sparse_matrix.h>'
p1748
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p1749
aS'#include <deal.II/lac/solver_cg.h>'
p1750
aS'#include <deal.II/lac/precondition.h>'
p1751
aS'#include <deal.II/lac/affine_constraints.h>'
p1752
aS'#include <deal.II/grid/tria.h>'
p1753
aS'#include <deal.II/grid/grid_generator.h>'
p1754
aS'#include <deal.II/grid/grid_out.h>'
p1755
aS'#include <deal.II/grid/grid_refinement.h>'
p1756
aS'#include <deal.II/dofs/dof_handler.h>'
p1757
aS'#include <deal.II/dofs/dof_tools.h>'
p1758
aS'#include <deal.II/fe/fe_q.h>'
p1759
aS'#include <deal.II/fe/fe_values.h>'
p1760
aS'#include <deal.II/fe/fe_tools.h>'
p1761
aS'#include <deal.II/numerics/vector_tools.h>'
p1762
aS'#include <deal.II/numerics/matrix_tools.h>'
p1763
aS'#include <deal.II/numerics/data_out.h>'
p1764
aS'#include <deal.II/numerics/error_estimator.h>'
p1765
aS'#include <algorithm>'
p1766
aS'#include <fstream>'
p1767
aS'#include <iostream>'
p1768
aS'#include <list>'
p1769
aS'#include <memory>'
p1770
aS'#include <numeric>'
p1771
aS'namespace Step14'
p1772
ag9
aS'  using namespace dealii;'
p1773
aS'  namespace Evaluation'
p1774
aS'  {'
p1775
aS'    template <int dim>'
p1776
aS'    class EvaluationBase'
p1777
aS'    {'
p1778
aS'    public:'
p1779
aS'      virtual ~EvaluationBase() = default;'
p1780
aS'      void set_refinement_cycle(const unsigned int refinement_cycle);'
p1781
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1782
aS'                              const Vector<double> & solution) const = 0;'
p1783
aS'    protected:'
p1784
aS'      unsigned int refinement_cycle;'
p1785
aS'    };'
p1786
aS'    template <int dim>'
p1787
aS'    void EvaluationBase<dim>::set_refinement_cycle(const unsigned int step)'
p1788
aS'    {'
p1789
aS'      refinement_cycle = step;'
p1790
aS'    }'
p1791
aS'    template <int dim>'
p1792
aS'    class PointValueEvaluation : public EvaluationBase<dim>'
p1793
aS'    {'
p1794
aS'    public:'
p1795
aS'      PointValueEvaluation(const Point<dim> &evaluation_point);'
p1796
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1797
aS'                              const Vector<double> & solution) const override;'
p1798
aS'      DeclException1('
p1799
aS'        ExcEvaluationPointNotFound,'
p1800
aS'        Point<dim>,'
p1801
aS'        << "The evaluation point " << arg1'
p1802
aS'        << " was not found among the vertices of the present grid.");'
p1803
aS'    private:'
p1804
aS'      const Point<dim> evaluation_point;'
p1805
aS'    };'
p1806
aS'    template <int dim>'
p1807
aS'    PointValueEvaluation<dim>::PointValueEvaluation('
p1808
aS'      const Point<dim> &evaluation_point)'
p1809
aS'      : evaluation_point(evaluation_point)'
p1810
aS'    {}'
p1811
aS'    template <int dim>'
p1812
aS'    void PointValueEvaluation<dim>::'
p1813
aS'         operator()(const DoFHandler<dim> &dof_handler,'
p1814
aS'               const Vector<double> & solution) const'
p1815
aS'    {'
p1816
aS'      double point_value = 1e20;'
p1817
aS'      bool evaluation_point_found = false;'
p1818
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p1819
aS'        if (!evaluation_point_found)'
p1820
aS'          for (const auto vertex : cell->vertex_indices())'
p1821
aS'            if (cell->vertex(vertex).distance(evaluation_point) <'
p1822
aS'                cell->diameter() * 1e-8)'
p1823
aS'              {'
p1824
aS'                point_value = solution(cell->vertex_dof_index(vertex, 0));'
p1825
aS'                evaluation_point_found = true;'
p1826
aS'                break;'
p1827
aS'              }'
p1828
aS'      AssertThrow(evaluation_point_found,'
p1829
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p1830
aS'      std::cout << "   Point value=" << point_value << std::endl;'
p1831
aS'    }'
p1832
aS'    template <int dim>'
p1833
aS'    class PointXDerivativeEvaluation : public EvaluationBase<dim>'
p1834
aS'    {'
p1835
aS'    public:'
p1836
aS'      PointXDerivativeEvaluation(const Point<dim> &evaluation_point);'
p1837
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1838
aS'                              const Vector<double> & solution) const;'
p1839
aS'      DeclException1('
p1840
aS'        ExcEvaluationPointNotFound,'
p1841
aS'        Point<dim>,'
p1842
aS'        << "The evaluation point " << arg1'
p1843
aS'        << " was not found among the vertices of the present grid.");'
p1844
aS'    private:'
p1845
aS'      const Point<dim> evaluation_point;'
p1846
aS'    };'
p1847
aS'    template <int dim>'
p1848
aS'    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation('
p1849
aS'      const Point<dim> &evaluation_point)'
p1850
aS'      : evaluation_point(evaluation_point)'
p1851
aS'    {}'
p1852
aS'    template <int dim>'
p1853
aS'    void PointXDerivativeEvaluation<dim>::'
p1854
aS'         operator()(const DoFHandler<dim> &dof_handler,'
p1855
aS'               const Vector<double> & solution) const'
p1856
aS'    {'
p1857
aS'      double point_derivative = 0;'
p1858
aS'      QTrapezoid<dim>             vertex_quadrature;'
p1859
aS'      FEValues<dim>               fe_values(dof_handler.get_fe(),'
p1860
aS'                              vertex_quadrature,'
p1861
aS'                              update_gradients | update_quadrature_points);'
p1862
aS'      std::vector<Tensor<1, dim>> solution_gradients(vertex_quadrature.size());'
p1863
aS'      unsigned int evaluation_point_hits = 0;'
p1864
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p1865
aS'        for (const auto vertex : cell->vertex_indices())'
p1866
aS'          if (cell->vertex(vertex) == evaluation_point)'
p1867
aS'            {'
p1868
aS'              fe_values.reinit(cell);'
p1869
aS'              fe_values.get_function_gradients(solution, solution_gradients);'
p1870
aS'              unsigned int q_point = 0;'
p1871
aS'              for (; q_point < solution_gradients.size(); ++q_point)'
p1872
aS'                if (fe_values.quadrature_point(q_point) == evaluation_point)'
p1873
aS'                  break;'
p1874
aS'              Assert(q_point < solution_gradients.size(), ExcInternalError());'
p1875
aS'              point_derivative += solution_gradients[q_point][0];'
p1876
aS'              ++evaluation_point_hits;'
p1877
aS'              break;'
p1878
aS'            }'
p1879
aS'      AssertThrow(evaluation_point_hits > 0,'
p1880
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p1881
aS'      point_derivative /= evaluation_point_hits;'
p1882
aS'      std::cout << "   Point x-derivative=" << point_derivative << std::endl;'
p1883
aS'    }'
p1884
aS'    template <int dim>'
p1885
aS'    class GridOutput : public EvaluationBase<dim>'
p1886
aS'    {'
p1887
aS'    public:'
p1888
aS'      GridOutput(const std::string &output_name_base);'
p1889
aS'      virtual void operator()(const DoFHandler<dim> &dof_handler,'
p1890
aS'                              const Vector<double> & solution) const override;'
p1891
aS'    private:'
p1892
aS'      const std::string output_name_base;'
p1893
aS'    };'
p1894
aS'    template <int dim>'
p1895
aS'    GridOutput<dim>::GridOutput(const std::string &output_name_base)'
p1896
aS'      : output_name_base(output_name_base)'
p1897
aS'    {}'
p1898
aS'    template <int dim>'
p1899
aS'    void GridOutput<dim>::operator()(const DoFHandler<dim> &dof_handler,'
p1900
aS'                                     const Vector<double> & /*solution*/) const'
p1901
aS'    {'
p1902
aS'      std::ofstream out(output_name_base + "-" +'
p1903
aS'                        std::to_string(this->refinement_cycle) + ".svg");'
p1904
aS'      GridOut().write_svg(dof_handler.get_triangulation(), out);'
p1905
aS'    }'
p1906
aS'  } // namespace Evaluation'
p1907
aS'  namespace LaplaceSolver'
p1908
aS'  {'
p1909
aS'    template <int dim>'
p1910
aS'    class Base'
p1911
aS'    {'
p1912
aS'    public:'
p1913
aS'      Base(Triangulation<dim> &coarse_grid);'
p1914
aS'      virtual ~Base() = default;'
p1915
aS'      virtual void solve_problem() = 0;'
p1916
aS'      virtual void postprocess('
p1917
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const = 0;'
p1918
aS'      virtual void         refine_grid()                            = 0;'
p1919
aS'      virtual unsigned int n_dofs() const                           = 0;'
p1920
aS'      virtual void set_refinement_cycle(const unsigned int cycle);'
p1921
aS'      virtual void output_solution() const = 0;'
p1922
aS'    protected:'
p1923
aS'      const SmartPointer<Triangulation<dim>> triangulation;'
p1924
aS'      unsigned int refinement_cycle;'
p1925
aS'    };'
p1926
aS'    template <int dim>'
p1927
aS'    Base<dim>::Base(Triangulation<dim> &coarse_grid)'
p1928
aS'      : triangulation(&coarse_grid)'
p1929
aS'      , refinement_cycle(numbers::invalid_unsigned_int)'
p1930
aS'    {}'
p1931
aS'    template <int dim>'
p1932
aS'    void Base<dim>::set_refinement_cycle(const unsigned int cycle)'
p1933
aS'    {'
p1934
aS'      refinement_cycle = cycle;'
p1935
aS'    }'
p1936
aS'    template <int dim>'
p1937
aS'    class Solver : public virtual Base<dim>'
p1938
aS'    {'
p1939
aS'    public:'
p1940
aS'      Solver(Triangulation<dim> &       triangulation,'
p1941
aS'             const FiniteElement<dim> & fe,'
p1942
aS'             const Quadrature<dim> &    quadrature,'
p1943
aS'             const Quadrature<dim - 1> &face_quadrature,'
p1944
aS'             const Function<dim> &      boundary_values);'
p1945
aS'      virtual ~Solver() override;'
p1946
aS'      virtual void solve_problem() override;'
p1947
aS'      virtual void postprocess('
p1948
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const override;'
p1949
aS'      virtual unsigned int n_dofs() const override;'
p1950
aS'    protected:'
p1951
aS'      const SmartPointer<const FiniteElement<dim>>  fe;'
p1952
aS'      const SmartPointer<const Quadrature<dim>>     quadrature;'
p1953
aS'      const SmartPointer<const Quadrature<dim - 1>> face_quadrature;'
p1954
aS'      DoFHandler<dim>                               dof_handler;'
p1955
aS'      Vector<double>                                solution;'
p1956
aS'      const SmartPointer<const Function<dim>>       boundary_values;'
p1957
aS'      virtual void assemble_rhs(Vector<double> &rhs) const = 0;'
p1958
aS'    private:'
p1959
aS'      struct LinearSystem'
p1960
aS'      {'
p1961
aS'        LinearSystem(const DoFHandler<dim> &dof_handler);'
p1962
aS'        void solve(Vector<double> &solution) const;'
p1963
aS'        AffineConstraints<double> hanging_node_constraints;'
p1964
aS'        SparsityPattern           sparsity_pattern;'
p1965
aS'        SparseMatrix<double>      matrix;'
p1966
aS'        Vector<double>            rhs;'
p1967
aS'      };'
p1968
aS'      struct AssemblyScratchData'
p1969
aS'      {'
p1970
aS'        AssemblyScratchData(const FiniteElement<dim> &fe,'
p1971
aS'                            const Quadrature<dim> &   quadrature);'
p1972
aS'        AssemblyScratchData(const AssemblyScratchData &scratch_data);'
p1973
aS'        FEValues<dim> fe_values;'
p1974
aS'      };'
p1975
aS'      struct AssemblyCopyData'
p1976
aS'      {'
p1977
aS'        FullMatrix<double>                   cell_matrix;'
p1978
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p1979
aS'      };'
p1980
aS'      void assemble_linear_system(LinearSystem &linear_system);'
p1981
aS'      void local_assemble_matrix('
p1982
aS'        const typename DoFHandler<dim>::active_cell_iterator &cell,'
p1983
aS'        AssemblyScratchData &                                 scratch_data,'
p1984
aS'        AssemblyCopyData &                                    copy_data) const;'
p1985
aS'      void copy_local_to_global(const AssemblyCopyData &copy_data,'
p1986
aS'                                LinearSystem &          linear_system) const;'
p1987
aS'    };'
p1988
aS'    template <int dim>'
p1989
aS'    Solver<dim>::Solver(Triangulation<dim> &       triangulation,'
p1990
aS'                        const FiniteElement<dim> & fe,'
p1991
aS'                        const Quadrature<dim> &    quadrature,'
p1992
aS'                        const Quadrature<dim - 1> &face_quadrature,'
p1993
aS'                        const Function<dim> &      boundary_values)'
p1994
aS'      : Base<dim>(triangulation)'
p1995
aS'      , fe(&fe)'
p1996
aS'      , quadrature(&quadrature)'
p1997
aS'      , face_quadrature(&face_quadrature)'
p1998
aS'      , dof_handler(triangulation)'
p1999
aS'      , boundary_values(&boundary_values)'
p2000
aS'    {}'
p2001
aS'    template <int dim>'
p2002
aS'    Solver<dim>::~Solver()'
p2003
aS'    {'
p2004
aS'      dof_handler.clear();'
p2005
aS'    }'
p2006
aS'    template <int dim>'
p2007
aS'    void Solver<dim>::solve_problem()'
p2008
aS'    {'
p2009
aS'      dof_handler.distribute_dofs(*fe);'
p2010
aS'      solution.reinit(dof_handler.n_dofs());'
p2011
aS'      LinearSystem linear_system(dof_handler);'
p2012
aS'      assemble_linear_system(linear_system);'
p2013
aS'      linear_system.solve(solution);'
p2014
aS'    }'
p2015
aS'    template <int dim>'
p2016
aS'    void Solver<dim>::postprocess('
p2017
aS'      const Evaluation::EvaluationBase<dim> &postprocessor) const'
p2018
aS'    {'
p2019
aS'      postprocessor(dof_handler, solution);'
p2020
aS'    }'
p2021
aS'    template <int dim>'
p2022
aS'    unsigned int Solver<dim>::n_dofs() const'
p2023
aS'    {'
p2024
aS'      return dof_handler.n_dofs();'
p2025
aS'    }'
p2026
aS'    template <int dim>'
p2027
aS'    void Solver<dim>::assemble_linear_system(LinearSystem &linear_system)'
p2028
aS'    {'
p2029
aS'      Threads::Task<void> rhs_task ='
p2030
aS'        Threads::new_task(&Solver<dim>::assemble_rhs, *this, linear_system.rhs);'
p2031
aS'      auto worker ='
p2032
aS'        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p2033
aS'               AssemblyScratchData &scratch_data,'
p2034
aS'               AssemblyCopyData &   copy_data) {'
p2035
aS'          this->local_assemble_matrix(cell, scratch_data, copy_data);'
p2036
aS'        };'
p2037
aS'      auto copier = [this, &linear_system](const AssemblyCopyData &copy_data) {'
p2038
aS'        this->copy_local_to_global(copy_data, linear_system);'
p2039
aS'      };'
p2040
aS'      WorkStream::run(dof_handler.begin_active(),'
p2041
aS'                      dof_handler.end(),'
p2042
aS'                      worker,'
p2043
aS'                      copier,'
p2044
aS'                      AssemblyScratchData(*fe, *quadrature),'
p2045
aS'                      AssemblyCopyData());'
p2046
aS'      linear_system.hanging_node_constraints.condense(linear_system.matrix);'
p2047
aS'      std::map<types::global_dof_index, double> boundary_value_map;'
p2048
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p2049
aS'                                               0,'
p2050
aS'                                               boundary_value_map);'
p2051
aS'      rhs_task.join();'
p2052
aS'      linear_system.hanging_node_constraints.condense(linear_system.rhs);'
p2053
aS'      MatrixTools::apply_boundary_values(boundary_value_map,'
p2054
aS'                                         linear_system.matrix,'
p2055
aS'                                         solution,'
p2056
aS'                                         linear_system.rhs);'
p2057
aS'    }'
p2058
aS'    template <int dim>'
p2059
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p2060
aS'      const FiniteElement<dim> &fe,'
p2061
aS'      const Quadrature<dim> &   quadrature)'
p2062
aS'      : fe_values(fe, quadrature, update_gradients | update_JxW_values)'
p2063
aS'    {}'
p2064
aS'    template <int dim>'
p2065
aS'    Solver<dim>::AssemblyScratchData::AssemblyScratchData('
p2066
aS'      const AssemblyScratchData &scratch_data)'
p2067
aS'      : fe_values(scratch_data.fe_values.get_fe(),'
p2068
aS'                  scratch_data.fe_values.get_quadrature(),'
p2069
aS'                  update_gradients | update_JxW_values)'
p2070
aS'    {}'
p2071
aS'    template <int dim>'
p2072
aS'    void Solver<dim>::local_assemble_matrix('
p2073
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p2074
aS'      AssemblyScratchData &                                 scratch_data,'
p2075
aS'      AssemblyCopyData &                                    copy_data) const'
p2076
aS'    {'
p2077
aS'      const unsigned int dofs_per_cell = fe->n_dofs_per_cell();'
p2078
aS'      const unsigned int n_q_points    = quadrature->size();'
p2079
aS'      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p2080
aS'      copy_data.local_dof_indices.resize(dofs_per_cell);'
p2081
aS'      scratch_data.fe_values.reinit(cell);'
p2082
aS'      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p2083
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2084
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p2085
aS'            copy_data.cell_matrix(i, j) +='
p2086
aS'               scratch_data.fe_values.shape_grad(j, q_point) *'
p2087
aS'               scratch_data.fe_values.JxW(q_point));'
p2088
aS'      cell->get_dof_indices(copy_data.local_dof_indices);'
p2089
aS'    }'
p2090
aS'    template <int dim>'
p2091
aS'    void Solver<dim>::copy_local_to_global(const AssemblyCopyData &copy_data,'
p2092
aS'                                           LinearSystem &linear_system) const'
p2093
aS'    {'
p2094
aS'      for (unsigned int i = 0; i < copy_data.local_dof_indices.size(); ++i)'
p2095
aS'        for (unsigned int j = 0; j < copy_data.local_dof_indices.size(); ++j)'
p2096
aS'          linear_system.matrix.add(copy_data.local_dof_indices[i],'
p2097
aS'                                   copy_data.local_dof_indices[j],'
p2098
aS'                                   copy_data.cell_matrix(i, j));'
p2099
aS'    }'
p2100
aS'    template <int dim>'
p2101
aS'    Solver<dim>::LinearSystem::LinearSystem(const DoFHandler<dim> &dof_handler)'
p2102
aS'    {'
p2103
aS'      hanging_node_constraints.clear();'
p2104
aS'      void (*mhnc_p)(const DoFHandler<dim> &, AffineConstraints<double> &) ='
p2105
aS'        &DoFTools::make_hanging_node_constraints;'
p2106
aS'      Threads::Task<void> side_task ='
p2107
aS'        Threads::new_task(mhnc_p, dof_handler, hanging_node_constraints);'
p2108
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p2109
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p2110
aS'      side_task.join();'
p2111
aS'      hanging_node_constraints.close();'
p2112
aS'      hanging_node_constraints.condense(dsp);'
p2113
aS'      sparsity_pattern.copy_from(dsp);'
p2114
aS'      matrix.reinit(sparsity_pattern);'
p2115
aS'      rhs.reinit(dof_handler.n_dofs());'
p2116
aS'    }'
p2117
aS'    template <int dim>'
p2118
aS'    void Solver<dim>::LinearSystem::solve(Vector<double> &solution) const'
p2119
aS'    {'
p2120
aS'      SolverControl            solver_control(5000, 1e-12);'
p2121
aS'      SolverCG<Vector<double>> cg(solver_control);'
p2122
aS'      PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p2123
aS'      preconditioner.initialize(matrix, 1.2);'
p2124
aS'      cg.solve(matrix, solution, rhs, preconditioner);'
p2125
aS'      hanging_node_constraints.distribute(solution);'
p2126
aS'    }'
p2127
aS'    template <int dim>'
p2128
aS'    class PrimalSolver : public Solver<dim>'
p2129
aS'    {'
p2130
aS'    public:'
p2131
aS'      PrimalSolver(Triangulation<dim> &       triangulation,'
p2132
aS'                   const FiniteElement<dim> & fe,'
p2133
aS'                   const Quadrature<dim> &    quadrature,'
p2134
aS'                   const Quadrature<dim - 1> &face_quadrature,'
p2135
aS'                   const Function<dim> &      rhs_function,'
p2136
aS'                   const Function<dim> &      boundary_values);'
p2137
aS'      virtual void output_solution() const override;'
p2138
aS'    protected:'
p2139
aS'      const SmartPointer<const Function<dim>> rhs_function;'
p2140
aS'      virtual void assemble_rhs(Vector<double> &rhs) const override;'
p2141
aS'    };'
p2142
aS'    template <int dim>'
p2143
aS'    PrimalSolver<dim>::PrimalSolver(Triangulation<dim> &       triangulation,'
p2144
aS'                                    const FiniteElement<dim> & fe,'
p2145
aS'                                    const Quadrature<dim> &    quadrature,'
p2146
aS'                                    const Quadrature<dim - 1> &face_quadrature,'
p2147
aS'                                    const Function<dim> &      rhs_function,'
p2148
aS'                                    const Function<dim> &      boundary_values)'
p2149
aS'      : Base<dim>(triangulation)'
p2150
aS'      , Solver<dim>(triangulation,'
p2151
aS'                    fe,'
p2152
aS'                    quadrature,'
p2153
aS'                    face_quadrature,'
p2154
aS'                    boundary_values)'
p2155
aS'      , rhs_function(&rhs_function)'
p2156
aS'    {}'
p2157
aS'    template <int dim>'
p2158
aS'    void PrimalSolver<dim>::output_solution() const'
p2159
aS'    {'
p2160
aS'      DataOut<dim> data_out;'
p2161
aS'      data_out.attach_dof_handler(this->dof_handler);'
p2162
aS'      data_out.add_data_vector(this->solution, "solution");'
p2163
aS'      data_out.build_patches();'
p2164
aS'      std::ofstream out("solution-" + std::to_string(this->refinement_cycle) +'
p2165
aS'                        ".vtu");'
p2166
aS'      data_out.write(out, DataOutBase::vtu);'
p2167
aS'    }'
p2168
aS'    template <int dim>'
p2169
aS'    void PrimalSolver<dim>::assemble_rhs(Vector<double> &rhs) const'
p2170
aS'    {'
p2171
aS'      FEValues<dim> fe_values(*this->fe,'
p2172
aS'                              update_values | update_quadrature_points |'
p2173
aS'                                update_JxW_values);'
p2174
aS'      const unsigned int dofs_per_cell = this->fe->n_dofs_per_cell();'
p2175
aS'      const unsigned int n_q_points    = this->quadrature->size();'
p2176
aS'      Vector<double>                       cell_rhs(dofs_per_cell);'
p2177
aS'      std::vector<double>                  rhs_values(n_q_points);'
p2178
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p2179
aS'      for (const auto &cell : this->dof_handler.active_cell_iterators())'
p2180
aS'        {'
p2181
aS'          cell_rhs = 0;'
p2182
aS'          fe_values.reinit(cell);'
p2183
aS'          rhs_function->value_list(fe_values.get_quadrature_points(),'
p2184
aS'                                   rhs_values);'
p2185
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p2186
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2187
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)'
p2188
aS'                              rhs_values[q_point] *               // f((x_q)'
p2189
aS'                              fe_values.JxW(q_point));            // dx'
p2190
aS'          cell->get_dof_indices(local_dof_indices);'
p2191
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2192
aS'            rhs(local_dof_indices[i]) += cell_rhs(i);'
p2193
aS'        }'
p2194
aS'    }'
p2195
aS'    template <int dim>'
p2196
aS'    class RefinementGlobal : public PrimalSolver<dim>'
p2197
aS'    {'
p2198
aS'    public:'
p2199
aS'      RefinementGlobal(Triangulation<dim> &       coarse_grid,'
p2200
aS'                       const FiniteElement<dim> & fe,'
p2201
aS'                       const Quadrature<dim> &    quadrature,'
p2202
aS'                       const Quadrature<dim - 1> &face_quadrature,'
p2203
aS'                       const Function<dim> &      rhs_function,'
p2204
aS'                       const Function<dim> &      boundary_values);'
p2205
aS'      virtual void refine_grid() override;'
p2206
aS'    };'
p2207
aS'    template <int dim>'
p2208
aS'    RefinementGlobal<dim>::RefinementGlobal('
p2209
aS'      Triangulation<dim> &       coarse_grid,'
p2210
aS'      const FiniteElement<dim> & fe,'
p2211
aS'      const Quadrature<dim> &    quadrature,'
p2212
aS'      const Quadrature<dim - 1> &face_quadrature,'
p2213
aS'      const Function<dim> &      rhs_function,'
p2214
aS'      const Function<dim> &      boundary_values)'
p2215
aS'      : Base<dim>(coarse_grid)'
p2216
aS'      , PrimalSolver<dim>(coarse_grid,'
p2217
aS'                          fe,'
p2218
aS'                          quadrature,'
p2219
aS'                          face_quadrature,'
p2220
aS'                          rhs_function,'
p2221
aS'                          boundary_values)'
p2222
aS'    {}'
p2223
aS'    template <int dim>'
p2224
aS'    void RefinementGlobal<dim>::refine_grid()'
p2225
aS'    {'
p2226
aS'      this->triangulation->refine_global(1);'
p2227
aS'    }'
p2228
aS'    template <int dim>'
p2229
aS'    class RefinementKelly : public PrimalSolver<dim>'
p2230
aS'    {'
p2231
aS'    public:'
p2232
aS'      RefinementKelly(Triangulation<dim> &       coarse_grid,'
p2233
aS'                      const FiniteElement<dim> & fe,'
p2234
aS'                      const Quadrature<dim> &    quadrature,'
p2235
aS'                      const Quadrature<dim - 1> &face_quadrature,'
p2236
aS'                      const Function<dim> &      rhs_function,'
p2237
aS'                      const Function<dim> &      boundary_values);'
p2238
aS'      virtual void refine_grid() override;'
p2239
aS'    };'
p2240
aS'    template <int dim>'
p2241
aS'    RefinementKelly<dim>::RefinementKelly('
p2242
aS'      Triangulation<dim> &       coarse_grid,'
p2243
aS'      const FiniteElement<dim> & fe,'
p2244
aS'      const Quadrature<dim> &    quadrature,'
p2245
aS'      const Quadrature<dim - 1> &face_quadrature,'
p2246
aS'      const Function<dim> &      rhs_function,'
p2247
aS'      const Function<dim> &      boundary_values)'
p2248
aS'      : Base<dim>(coarse_grid)'
p2249
aS'      , PrimalSolver<dim>(coarse_grid,'
p2250
aS'                          fe,'
p2251
aS'                          quadrature,'
p2252
aS'                          face_quadrature,'
p2253
aS'                          rhs_function,'
p2254
aS'                          boundary_values)'
p2255
aS'    {}'
p2256
aS'    template <int dim>'
p2257
aS'    void RefinementKelly<dim>::refine_grid()'
p2258
aS'    {'
p2259
aS'      Vector<float> estimated_error_per_cell('
p2260
aS'        this->triangulation->n_active_cells());'
p2261
aS'      KellyErrorEstimator<dim>::estimate('
p2262
aS'        this->dof_handler,'
p2263
aS'        QGauss<dim - 1>(this->fe->degree + 1),'
p2264
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p2265
aS'        this->solution,'
p2266
aS'        estimated_error_per_cell);'
p2267
aS'      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,'
p2268
aS'                                                      estimated_error_per_cell,'
p2269
aS'                                                      0.3,'
p2270
aS'                                                      0.03);'
p2271
aS'      this->triangulation->execute_coarsening_and_refinement();'
p2272
aS'    }'
p2273
aS'    template <int dim>'
p2274
aS'    class RefinementWeightedKelly : public PrimalSolver<dim>'
p2275
aS'    {'
p2276
aS'    public:'
p2277
aS'      RefinementWeightedKelly(Triangulation<dim> &       coarse_grid,'
p2278
aS'                              const FiniteElement<dim> & fe,'
p2279
aS'                              const Quadrature<dim> &    quadrature,'
p2280
aS'                              const Quadrature<dim - 1> &face_quadrature,'
p2281
aS'                              const Function<dim> &      rhs_function,'
p2282
aS'                              const Function<dim> &      boundary_values,'
p2283
aS'                              const Function<dim> &      weighting_function);'
p2284
aS'      virtual void refine_grid() override;'
p2285
aS'    private:'
p2286
aS'      const SmartPointer<const Function<dim>> weighting_function;'
p2287
aS'    };'
p2288
aS'    template <int dim>'
p2289
aS'    RefinementWeightedKelly<dim>::RefinementWeightedKelly('
p2290
aS'      Triangulation<dim> &       coarse_grid,'
p2291
aS'      const FiniteElement<dim> & fe,'
p2292
aS'      const Quadrature<dim> &    quadrature,'
p2293
aS'      const Quadrature<dim - 1> &face_quadrature,'
p2294
aS'      const Function<dim> &      rhs_function,'
p2295
aS'      const Function<dim> &      boundary_values,'
p2296
aS'      const Function<dim> &      weighting_function)'
p2297
aS'      : Base<dim>(coarse_grid)'
p2298
aS'      , PrimalSolver<dim>(coarse_grid,'
p2299
aS'                          fe,'
p2300
aS'                          quadrature,'
p2301
aS'                          face_quadrature,'
p2302
aS'                          rhs_function,'
p2303
aS'                          boundary_values)'
p2304
aS'      , weighting_function(&weighting_function)'
p2305
aS'    {}'
p2306
aS'    template <int dim>'
p2307
aS'    void RefinementWeightedKelly<dim>::refine_grid()'
p2308
aS'    {'
p2309
aS'      Vector<float> estimated_error_per_cell('
p2310
aS'        this->triangulation->n_active_cells());'
p2311
aS'      std::map<types::boundary_id, const Function<dim> *> dummy_function_map;'
p2312
aS'      KellyErrorEstimator<dim>::estimate(this->dof_handler,'
p2313
aS'                                         dummy_function_map,'
p2314
aS'                                         this->solution,'
p2315
aS'                                         estimated_error_per_cell);'
p2316
aS'      for (const auto &cell : this->dof_handler.active_cell_iterators())'
p2317
aS'        estimated_error_per_cell(cell->active_cell_index()) *='
p2318
aS'          weighting_function->value(cell->center());'
p2319
aS'      GridRefinement::refine_and_coarsen_fixed_number(*this->triangulation,'
p2320
aS'                                                      estimated_error_per_cell,'
p2321
aS'                                                      0.3,'
p2322
aS'                                                      0.03);'
p2323
aS'      this->triangulation->execute_coarsening_and_refinement();'
p2324
aS'    }'
p2325
aS'  } // namespace LaplaceSolver'
p2326
aS'  namespace Data'
p2327
aS'  {'
p2328
aS'    template <int dim>'
p2329
aS'    struct SetUpBase : public Subscriptor'
p2330
aS'    {'
p2331
aS'      virtual const Function<dim> &get_boundary_values() const = 0;'
p2332
aS'      virtual const Function<dim> &get_right_hand_side() const = 0;'
p2333
aS'      virtual void'
p2334
aS'      create_coarse_grid(Triangulation<dim> &coarse_grid) const = 0;'
p2335
aS'    };'
p2336
aS'    template <class Traits, int dim>'
p2337
aS'    struct SetUp : public SetUpBase<dim>'
p2338
aS'    {'
p2339
aS'      virtual const Function<dim> &get_boundary_values() const override;'
p2340
aS'      virtual const Function<dim> &get_right_hand_side() const override;'
p2341
aS'      virtual void'
p2342
aS'      create_coarse_grid(Triangulation<dim> &coarse_grid) const override;'
p2343
aS'    private:'
p2344
aS'      static const typename Traits::BoundaryValues boundary_values;'
p2345
aS'      static const typename Traits::RightHandSide  right_hand_side;'
p2346
aS'    };'
p2347
aS'    template <class Traits, int dim>'
p2348
aS'    const typename Traits::BoundaryValues SetUp<Traits, dim>::boundary_values;'
p2349
aS'    template <class Traits, int dim>'
p2350
aS'    const typename Traits::RightHandSide SetUp<Traits, dim>::right_hand_side;'
p2351
aS'    template <class Traits, int dim>'
p2352
aS'    const Function<dim> &SetUp<Traits, dim>::get_boundary_values() const'
p2353
aS'    {'
p2354
aS'      return boundary_values;'
p2355
aS'    }'
p2356
aS'    template <class Traits, int dim>'
p2357
aS'    const Function<dim> &SetUp<Traits, dim>::get_right_hand_side() const'
p2358
aS'    {'
p2359
aS'      return right_hand_side;'
p2360
aS'    }'
p2361
aS'    template <class Traits, int dim>'
p2362
aS'    void SetUp<Traits, dim>::create_coarse_grid('
p2363
aS'      Triangulation<dim> &coarse_grid) const'
p2364
aS'    {'
p2365
aS'      Traits::create_coarse_grid(coarse_grid);'
p2366
aS'    }'
p2367
aS'    template <int dim>'
p2368
aS'    struct CurvedRidges'
p2369
aS'    {'
p2370
aS'      class BoundaryValues : public Function<dim>'
p2371
aS'      {'
p2372
aS'      public:'
p2373
aS'        virtual double value(const Point<dim> & p,'
p2374
aS'                             const unsigned int component) const;'
p2375
aS'      };'
p2376
aS'      class RightHandSide : public Function<dim>'
p2377
aS'      {'
p2378
aS'      public:'
p2379
aS'        virtual double value(const Point<dim> & p,'
p2380
aS'                             const unsigned int component) const;'
p2381
aS'      };'
p2382
aS'      static void create_coarse_grid(Triangulation<dim> &coarse_grid);'
p2383
aS'    };'
p2384
aS'    template <int dim>'
p2385
aS'    double CurvedRidges<dim>::BoundaryValues::value('
p2386
aS'      const Point<dim> &p,'
p2387
aS'      const unsigned int /*component*/) const'
p2388
aS'    {'
p2389
aS'      double q = p(0);'
p2390
aS'      for (unsigned int i = 1; i < dim; ++i)'
p2391
aS'        q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p2392
aS'      const double exponential = std::exp(q);'
p2393
aS'      return exponential;'
p2394
aS'    }'
p2395
aS'    template <int dim>'
p2396
aS'    double CurvedRidges<dim>::RightHandSide::value('
p2397
aS'      const Point<dim> &p,'
p2398
aS'      const unsigned int /*component*/) const'
p2399
aS'    {'
p2400
aS'      double q = p(0);'
p2401
aS'      for (unsigned int i = 1; i < dim; ++i)'
p2402
aS'        q += std::sin(10 * p(i) + 5 * p(0) * p(0));'
p2403
aS'      const double u  = std::exp(q);'
p2404
aS'      double       t1 = 1, t2 = 0, t3 = 0;'
p2405
aS'      for (unsigned int i = 1; i < dim; ++i)'
p2406
aS'        {'
p2407
aS'          t1 += std::cos(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);'
p2408
aS'          t2 += 10 * std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p2409
aS'                100 * std::sin(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);'
p2410
aS'          t3 += 100 * std::cos(10 * p(i) + 5 * p(0) * p(0)) *'
p2411
aS'                  std::cos(10 * p(i) + 5 * p(0) * p(0)) -'
p2412
aS'                100 * std::sin(10 * p(i) + 5 * p(0) * p(0));'
p2413
aS'        }'
p2414
aS'      t1 = t1 * t1;'
p2415
aS'      return -u * (t1 + t2 + t3);'
p2416
aS'    }'
p2417
aS'    template <int dim>'
p2418
aS'    void CurvedRidges<dim>::create_coarse_grid(Triangulation<dim> &coarse_grid)'
p2419
aS'    {'
p2420
aS'      GridGenerator::hyper_cube(coarse_grid, -1, 1);'
p2421
aS'      coarse_grid.refine_global(2);'
p2422
aS'    }'
p2423
aS'    template <int dim>'
p2424
aS'    struct Exercise_2_3'
p2425
aS'    {'
p2426
aS'      using BoundaryValues = Functions::ZeroFunction<dim>;'
p2427
aS'      class RightHandSide : public Functions::ConstantFunction<dim>'
p2428
aS'      {'
p2429
aS'      public:'
p2430
aS'        RightHandSide()'
p2431
aS'          : Functions::ConstantFunction<dim>(1.)'
p2432
aS'        {}'
p2433
aS'      };'
p2434
aS'      static void create_coarse_grid(Triangulation<dim> &coarse_grid);'
p2435
aS'    };'
p2436
aS'    template <>'
p2437
aS'    void Exercise_2_3<2>::create_coarse_grid(Triangulation<2> &coarse_grid)'
p2438
aS'    {'
p2439
aS'      const unsigned int dim = 2;'
p2440
aS'      const std::vector<Point<2>> vertices = {'
p2441
aS'        {-1.0, -1.0}, {-0.5, -1.0}, {+0.0, -1.0}, {+0.5, -1.0}, {+1.0, -1.0}, //'
p2442
aS'        {-1.0, -0.5}, {-0.5, -0.5}, {+0.0, -0.5}, {+0.5, -0.5}, {+1.0, -0.5}, //'
p2443
aS'        {-1.0, +0.0}, {-0.5, +0.0}, {+0.5, +0.0}, {+1.0, +0.0},               //'
p2444
aS'        {-1.0, +0.5}, {-0.5, +0.5}, {+0.0, +0.5}, {+0.5, +0.5}, {+1.0, +0.5}, //'
p2445
aS'        {-1.0, +1.0}, {-0.5, +1.0}, {+0.0, +1.0}, {+0.5, +1.0}, {+1.0, +1.0}};'
p2446
aS'      const std::vector<std::array<int, GeometryInfo<dim>::vertices_per_cell>>'
p2447
aS'        cell_vertices = {{{0, 1, 5, 6}},'
p2448
aS'                         {{1, 2, 6, 7}},'
p2449
aS'                         {{2, 3, 7, 8}},'
p2450
aS'                         {{3, 4, 8, 9}},'
p2451
aS'                         {{5, 6, 10, 11}},'
p2452
aS'                         {{8, 9, 12, 13}},'
p2453
aS'                         {{10, 11, 14, 15}},'
p2454
aS'                         {{12, 13, 17, 18}},'
p2455
aS'                         {{14, 15, 19, 20}},'
p2456
aS'                         {{15, 16, 20, 21}},'
p2457
aS'                         {{16, 17, 21, 22}},'
p2458
aS'                         {{17, 18, 22, 23}}};'
p2459
aS'      const unsigned int n_cells = cell_vertices.size();'
p2460
aS'      std::vector<CellData<dim>> cells(n_cells, CellData<dim>());'
p2461
aS'      for (unsigned int i = 0; i < n_cells; ++i)'
p2462
aS'        {'
p2463
aS'          for (unsigned int j = 0; j < cell_vertices[i].size(); ++j)'
p2464
aS'            cells[i].vertices[j] = cell_vertices[i][j];'
p2465
aS'          cells[i].material_id = 0;'
p2466
aS'        }'
p2467
aS'      coarse_grid.create_triangulation(vertices, cells, SubCellData());'
p2468
aS'      coarse_grid.refine_global(1);'
p2469
aS'    }'
p2470
aS'  } // namespace Data'
p2471
aS'  namespace DualFunctional'
p2472
aS'  {'
p2473
aS'    template <int dim>'
p2474
aS'    class DualFunctionalBase : public Subscriptor'
p2475
aS'    {'
p2476
aS'    public:'
p2477
aS'      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2478
aS'                                Vector<double> &       rhs) const = 0;'
p2479
aS'    };'
p2480
aS'    template <int dim>'
p2481
aS'    class PointValueEvaluation : public DualFunctionalBase<dim>'
p2482
aS'    {'
p2483
aS'    public:'
p2484
aS'      PointValueEvaluation(const Point<dim> &evaluation_point);'
p2485
aS'      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2486
aS'                                Vector<double> &       rhs) const override;'
p2487
aS'      DeclException1('
p2488
aS'        ExcEvaluationPointNotFound,'
p2489
aS'        Point<dim>,'
p2490
aS'        << "The evaluation point " << arg1'
p2491
aS'        << " was not found among the vertices of the present grid.");'
p2492
aS'    protected:'
p2493
aS'      const Point<dim> evaluation_point;'
p2494
aS'    };'
p2495
aS'    template <int dim>'
p2496
aS'    PointValueEvaluation<dim>::PointValueEvaluation('
p2497
aS'      const Point<dim> &evaluation_point)'
p2498
aS'      : evaluation_point(evaluation_point)'
p2499
aS'    {}'
p2500
aS'    template <int dim>'
p2501
aS'    void'
p2502
aS'    PointValueEvaluation<dim>::assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2503
aS'                                            Vector<double> &       rhs) const'
p2504
aS'    {'
p2505
aS'      rhs.reinit(dof_handler.n_dofs());'
p2506
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p2507
aS'        for (const auto vertex : cell->vertex_indices())'
p2508
aS'          if (cell->vertex(vertex).distance(evaluation_point) <'
p2509
aS'              cell->diameter() * 1e-8)'
p2510
aS'            {'
p2511
aS'              rhs(cell->vertex_dof_index(vertex, 0)) = 1;'
p2512
aS'              return;'
p2513
aS'            }'
p2514
aS'      AssertThrow(false, ExcEvaluationPointNotFound(evaluation_point));'
p2515
aS'    }'
p2516
aS'    template <int dim>'
p2517
aS'    class PointXDerivativeEvaluation : public DualFunctionalBase<dim>'
p2518
aS'    {'
p2519
aS'    public:'
p2520
aS'      PointXDerivativeEvaluation(const Point<dim> &evaluation_point);'
p2521
aS'      virtual void assemble_rhs(const DoFHandler<dim> &dof_handler,'
p2522
aS'                                Vector<double> &       rhs) const;'
p2523
aS'      DeclException1('
p2524
aS'        ExcEvaluationPointNotFound,'
p2525
aS'        Point<dim>,'
p2526
aS'        << "The evaluation point " << arg1'
p2527
aS'        << " was not found among the vertices of the present grid.");'
p2528
aS'    protected:'
p2529
aS'      const Point<dim> evaluation_point;'
p2530
aS'    };'
p2531
aS'    template <int dim>'
p2532
aS'    PointXDerivativeEvaluation<dim>::PointXDerivativeEvaluation('
p2533
aS'      const Point<dim> &evaluation_point)'
p2534
aS'      : evaluation_point(evaluation_point)'
p2535
aS'    {}'
p2536
aS'    template <int dim>'
p2537
aS'    void PointXDerivativeEvaluation<dim>::assemble_rhs('
p2538
aS'      const DoFHandler<dim> &dof_handler,'
p2539
aS'      Vector<double> &       rhs) const'
p2540
aS'    {'
p2541
aS'      rhs.reinit(dof_handler.n_dofs());'
p2542
aS'      QGauss<dim>        quadrature(dof_handler.get_fe().degree + 1);'
p2543
aS'      FEValues<dim>      fe_values(dof_handler.get_fe(),'
p2544
aS'                              quadrature,'
p2545
aS'                              update_gradients | update_quadrature_points |'
p2546
aS'                                update_JxW_values);'
p2547
aS'      const unsigned int n_q_points    = fe_values.n_quadrature_points;'
p2548
aS'      const unsigned int dofs_per_cell = dof_handler.get_fe().dofs_per_cell;'
p2549
aS'      Vector<double>            cell_rhs(dofs_per_cell);'
p2550
aS'      std::vector<unsigned int> local_dof_indices(dofs_per_cell);'
p2551
aS'      double total_volume = 0;'
p2552
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p2553
aS'        if (cell->center().distance(evaluation_point) <= cell->diameter())'
p2554
aS'          {'
p2555
aS'            fe_values.reinit(cell);'
p2556
aS'            cell_rhs = 0;'
p2557
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p2558
aS'              {'
p2559
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2560
aS'                  cell_rhs(i) +='
p2561
aS'                    fe_values.shape_grad(i, q)[0] // (d/dx phi_i(x_q))'
p2562
aS'                total_volume += fe_values.JxW(q);'
p2563
aS'              }'
p2564
aS'            cell->get_dof_indices(local_dof_indices);'
p2565
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p2566
aS'              rhs(local_dof_indices[i]) += cell_rhs(i);'
p2567
aS'          }'
p2568
aS'      AssertThrow(total_volume > 0,'
p2569
aS'                  ExcEvaluationPointNotFound(evaluation_point));'
p2570
aS'      rhs /= total_volume;'
p2571
aS'    }'
p2572
aS'  } // namespace DualFunctional'
p2573
aS'  namespace LaplaceSolver'
p2574
aS'  {'
p2575
aS'    template <int dim>'
p2576
aS'    class DualSolver : public Solver<dim>'
p2577
aS'    {'
p2578
aS'    public:'
p2579
aS'      DualSolver('
p2580
aS'        Triangulation<dim> &                           triangulation,'
p2581
aS'        const FiniteElement<dim> &                     fe,'
p2582
aS'        const Quadrature<dim> &                        quadrature,'
p2583
aS'        const Quadrature<dim - 1> &                    face_quadrature,'
p2584
aS'        const DualFunctional::DualFunctionalBase<dim> &dual_functional);'
p2585
aS'    protected:'
p2586
aS'      const SmartPointer<const DualFunctional::DualFunctionalBase<dim>>'
p2587
aS'                   dual_functional;'
p2588
aS'      virtual void assemble_rhs(Vector<double> &rhs) const override;'
p2589
aS'      static const Functions::ZeroFunction<dim> boundary_values;'
p2590
aS'    };'
p2591
aS'    template <int dim>'
p2592
aS'    const Functions::ZeroFunction<dim> DualSolver<dim>::boundary_values;'
p2593
aS'    template <int dim>'
p2594
aS'    DualSolver<dim>::DualSolver('
p2595
aS'      Triangulation<dim> &                           triangulation,'
p2596
aS'      const FiniteElement<dim> &                     fe,'
p2597
aS'      const Quadrature<dim> &                        quadrature,'
p2598
aS'      const Quadrature<dim - 1> &                    face_quadrature,'
p2599
aS'      const DualFunctional::DualFunctionalBase<dim> &dual_functional)'
p2600
aS'      : Base<dim>(triangulation)'
p2601
aS'      , Solver<dim>(triangulation,'
p2602
aS'                    fe,'
p2603
aS'                    quadrature,'
p2604
aS'                    face_quadrature,'
p2605
aS'                    boundary_values)'
p2606
aS'      , dual_functional(&dual_functional)'
p2607
aS'    {}'
p2608
aS'    template <int dim>'
p2609
aS'    void DualSolver<dim>::assemble_rhs(Vector<double> &rhs) const'
p2610
aS'    {'
p2611
aS'      dual_functional->assemble_rhs(this->dof_handler, rhs);'
p2612
aS'    }'
p2613
aS'    template <int dim>'
p2614
aS'    class WeightedResidual : public PrimalSolver<dim>, public DualSolver<dim>'
p2615
aS'    {'
p2616
aS'    public:'
p2617
aS'      WeightedResidual('
p2618
aS'        Triangulation<dim> &                           coarse_grid,'
p2619
aS'        const FiniteElement<dim> &                     primal_fe,'
p2620
aS'        const FiniteElement<dim> &                     dual_fe,'
p2621
aS'        const Quadrature<dim> &                        quadrature,'
p2622
aS'        const Quadrature<dim - 1> &                    face_quadrature,'
p2623
aS'        const Function<dim> &                          rhs_function,'
p2624
aS'        const Function<dim> &                          boundary_values,'
p2625
aS'        const DualFunctional::DualFunctionalBase<dim> &dual_functional);'
p2626
aS'      virtual void solve_problem() override;'
p2627
aS'      virtual void postprocess('
p2628
aS'        const Evaluation::EvaluationBase<dim> &postprocessor) const override;'
p2629
aS'      virtual unsigned int n_dofs() const override;'
p2630
aS'      virtual void refine_grid() override;'
p2631
aS'      virtual void output_solution() const override;'
p2632
aS'    private:'
p2633
aS'      void solve_primal_problem();'
p2634
aS'      void solve_dual_problem();'
p2635
aS'      using active_cell_iterator ='
p2636
aS'        typename DoFHandler<dim>::active_cell_iterator;'
p2637
aS'      using FaceIntegrals ='
p2638
aS'        typename std::map<typename DoFHandler<dim>::face_iterator, double>;'
p2639
aS'      struct CellData'
p2640
aS'      {'
p2641
aS'        FEValues<dim>                           fe_values;'
p2642
aS'        const SmartPointer<const Function<dim>> right_hand_side;'
p2643
aS'        std::vector<double> cell_residual;'
p2644
aS'        std::vector<double> rhs_values;'
p2645
aS'        std::vector<double> dual_weights;'
p2646
aS'        std::vector<double> cell_laplacians;'
p2647
aS'        CellData(const FiniteElement<dim> &fe,'
p2648
aS'                 const Quadrature<dim> &   quadrature,'
p2649
aS'                 const Function<dim> &     right_hand_side);'
p2650
aS'        CellData(const CellData &cell_data);'
p2651
aS'      };'
p2652
aS'      struct FaceData'
p2653
aS'      {'
p2654
aS'        FEFaceValues<dim>    fe_face_values_cell;'
p2655
aS'        FEFaceValues<dim>    fe_face_values_neighbor;'
p2656
aS'        FESubfaceValues<dim> fe_subface_values_cell;'
p2657
aS'        std::vector<double>                  jump_residual;'
p2658
aS'        std::vector<double>                  dual_weights;'
p2659
aS'        typename std::vector<Tensor<1, dim>> cell_grads;'
p2660
aS'        typename std::vector<Tensor<1, dim>> neighbor_grads;'
p2661
aS'        FaceData(const FiniteElement<dim> & fe,'
p2662
aS'                 const Quadrature<dim - 1> &face_quadrature);'
p2663
aS'        FaceData(const FaceData &face_data);'
p2664
aS'      };'
p2665
aS'      struct WeightedResidualScratchData'
p2666
aS'      {'
p2667
aS'        WeightedResidualScratchData('
p2668
aS'          const FiniteElement<dim> & primal_fe,'
p2669
aS'          const Quadrature<dim> &    primal_quadrature,'
p2670
aS'          const Quadrature<dim - 1> &primal_face_quadrature,'
p2671
aS'          const Function<dim> &      rhs_function,'
p2672
aS'          const Vector<double> &     primal_solution,'
p2673
aS'          const Vector<double> &     dual_weights);'
p2674
aS'        WeightedResidualScratchData('
p2675
aS'          const WeightedResidualScratchData &scratch_data);'
p2676
aS'        CellData       cell_data;'
p2677
aS'        FaceData       face_data;'
p2678
aS'        Vector<double> primal_solution;'
p2679
aS'        Vector<double> dual_weights;'
p2680
aS'      };'
p2681
aS'      struct WeightedResidualCopyData'
p2682
aS'      {};'
p2683
aS'      void estimate_error(Vector<float> &error_indicators) const;'
p2684
aS'      void estimate_on_one_cell(const active_cell_iterator & cell,'
p2685
aS'                                WeightedResidualScratchData &scratch_data,'
p2686
aS'                                WeightedResidualCopyData &   copy_data,'
p2687
aS'                                Vector<float> &              error_indicators,'
p2688
aS'                                FaceIntegrals &face_integrals) const;'
p2689
aS'      void integrate_over_cell(const active_cell_iterator &cell,'
p2690
aS'                               const Vector<double> &      primal_solution,'
p2691
aS'                               const Vector<double> &      dual_weights,'
p2692
aS'                               CellData &                  cell_data,'
p2693
aS'                               Vector<float> &error_indicators) const;'
p2694
aS'      void integrate_over_regular_face(const active_cell_iterator &cell,'
p2695
aS'                                       const unsigned int          face_no,'
p2696
aS'                                       const Vector<double> &primal_solution,'
p2697
aS'                                       const Vector<double> &dual_weights,'
p2698
aS'                                       FaceData &            face_data,'
p2699
aS'                                       FaceIntegrals &face_integrals) const;'
p2700
aS'      void integrate_over_irregular_face(const active_cell_iterator &cell,'
p2701
aS'                                         const unsigned int          face_no,'
p2702
aS'                                         const Vector<double> &primal_solution,'
p2703
aS'                                         const Vector<double> &dual_weights,'
p2704
aS'                                         FaceData &            face_data,'
p2705
aS'                                         FaceIntegrals &face_integrals) const;'
p2706
aS'    };'
p2707
aS'    template <int dim>'
p2708
aS'    WeightedResidual<dim>::CellData::CellData('
p2709
aS'      const FiniteElement<dim> &fe,'
p2710
aS'      const Quadrature<dim> &   quadrature,'
p2711
aS'      const Function<dim> &     right_hand_side)'
p2712
aS'      : fe_values(fe,'
p2713
aS'                  quadrature,'
p2714
aS'                  update_values | update_hessians | update_quadrature_points |'
p2715
aS'                    update_JxW_values)'
p2716
aS'      , right_hand_side(&right_hand_side)'
p2717
aS'      , cell_residual(quadrature.size())'
p2718
aS'      , rhs_values(quadrature.size())'
p2719
aS'      , dual_weights(quadrature.size())'
p2720
aS'      , cell_laplacians(quadrature.size())'
p2721
aS'    {}'
p2722
aS'    template <int dim>'
p2723
aS'    WeightedResidual<dim>::CellData::CellData(const CellData &cell_data)'
p2724
aS'      : fe_values(cell_data.fe_values.get_fe(),'
p2725
aS'                  cell_data.fe_values.get_quadrature(),'
p2726
aS'                  update_values | update_hessians | update_quadrature_points |'
p2727
aS'                    update_JxW_values)'
p2728
aS'      , right_hand_side(cell_data.right_hand_side)'
p2729
aS'      , cell_residual(cell_data.cell_residual)'
p2730
aS'      , rhs_values(cell_data.rhs_values)'
p2731
aS'      , dual_weights(cell_data.dual_weights)'
p2732
aS'      , cell_laplacians(cell_data.cell_laplacians)'
p2733
aS'    {}'
p2734
aS'    template <int dim>'
p2735
aS'    WeightedResidual<dim>::FaceData::FaceData('
p2736
aS'      const FiniteElement<dim> & fe,'
p2737
aS'      const Quadrature<dim - 1> &face_quadrature)'
p2738
aS'      : fe_face_values_cell(fe,'
p2739
aS'                            face_quadrature,'
p2740
aS'                            update_values | update_gradients |'
p2741
aS'                              update_JxW_values | update_normal_vectors)'
p2742
aS'      , fe_face_values_neighbor(fe,'
p2743
aS'                                face_quadrature,'
p2744
aS'                                update_values | update_gradients |'
p2745
aS'                                  update_JxW_values | update_normal_vectors)'
p2746
aS'      , fe_subface_values_cell(fe, face_quadrature, update_gradients)'
p2747
aS'    {'
p2748
aS'      const unsigned int n_face_q_points = face_quadrature.size();'
p2749
aS'      jump_residual.resize(n_face_q_points);'
p2750
aS'      dual_weights.resize(n_face_q_points);'
p2751
aS'      cell_grads.resize(n_face_q_points);'
p2752
aS'      neighbor_grads.resize(n_face_q_points);'
p2753
aS'    }'
p2754
aS'    template <int dim>'
p2755
aS'    WeightedResidual<dim>::FaceData::FaceData(const FaceData &face_data)'
p2756
aS'      : fe_face_values_cell(face_data.fe_face_values_cell.get_fe(),'
p2757
aS'                            face_data.fe_face_values_cell.get_quadrature(),'
p2758
aS'                            update_values | update_gradients |'
p2759
aS'                              update_JxW_values | update_normal_vectors)'
p2760
aS'      , fe_face_values_neighbor('
p2761
aS'          face_data.fe_face_values_neighbor.get_fe(),'
p2762
aS'          face_data.fe_face_values_neighbor.get_quadrature(),'
p2763
aS'          update_values | update_gradients | update_JxW_values |'
p2764
aS'            update_normal_vectors)'
p2765
aS'      , fe_subface_values_cell('
p2766
aS'          face_data.fe_subface_values_cell.get_fe(),'
p2767
aS'          face_data.fe_subface_values_cell.get_quadrature(),'
p2768
aS'          update_gradients)'
p2769
aS'      , jump_residual(face_data.jump_residual)'
p2770
aS'      , dual_weights(face_data.dual_weights)'
p2771
aS'      , cell_grads(face_data.cell_grads)'
p2772
aS'      , neighbor_grads(face_data.neighbor_grads)'
p2773
aS'    {}'
p2774
aS'    template <int dim>'
p2775
aS'    WeightedResidual<dim>::WeightedResidualScratchData::'
p2776
aS'      WeightedResidualScratchData('
p2777
aS'        const FiniteElement<dim> & primal_fe,'
p2778
aS'        const Quadrature<dim> &    primal_quadrature,'
p2779
aS'        const Quadrature<dim - 1> &primal_face_quadrature,'
p2780
aS'        const Function<dim> &      rhs_function,'
p2781
aS'        const Vector<double> &     primal_solution,'
p2782
aS'        const Vector<double> &     dual_weights)'
p2783
aS'      : cell_data(primal_fe, primal_quadrature, rhs_function)'
p2784
aS'      , face_data(primal_fe, primal_face_quadrature)'
p2785
aS'      , primal_solution(primal_solution)'
p2786
aS'      , dual_weights(dual_weights)'
p2787
aS'    {}'
p2788
aS'    template <int dim>'
p2789
aS'    WeightedResidual<dim>::WeightedResidualScratchData::'
p2790
aS'      WeightedResidualScratchData('
p2791
aS'        const WeightedResidualScratchData &scratch_data)'
p2792
aS'      : cell_data(scratch_data.cell_data)'
p2793
aS'      , face_data(scratch_data.face_data)'
p2794
aS'      , primal_solution(scratch_data.primal_solution)'
p2795
aS'      , dual_weights(scratch_data.dual_weights)'
p2796
aS'    {}'
p2797
aS'    template <int dim>'
p2798
aS'    WeightedResidual<dim>::WeightedResidual('
p2799
aS'      Triangulation<dim> &                           coarse_grid,'
p2800
aS'      const FiniteElement<dim> &                     primal_fe,'
p2801
aS'      const FiniteElement<dim> &                     dual_fe,'
p2802
aS'      const Quadrature<dim> &                        quadrature,'
p2803
aS'      const Quadrature<dim - 1> &                    face_quadrature,'
p2804
aS'      const Function<dim> &                          rhs_function,'
p2805
aS'      const Function<dim> &                          bv,'
p2806
aS'      const DualFunctional::DualFunctionalBase<dim> &dual_functional)'
p2807
aS'      : Base<dim>(coarse_grid)'
p2808
aS'      , PrimalSolver<dim>(coarse_grid,'
p2809
aS'                          primal_fe,'
p2810
aS'                          quadrature,'
p2811
aS'                          face_quadrature,'
p2812
aS'                          rhs_function,'
p2813
aS'                          bv)'
p2814
aS'      , DualSolver<dim>(coarse_grid,'
p2815
aS'                        dual_fe,'
p2816
aS'                        quadrature,'
p2817
aS'                        face_quadrature,'
p2818
aS'                        dual_functional)'
p2819
aS'    {}'
p2820
aS'    template <int dim>'
p2821
aS'    void WeightedResidual<dim>::solve_problem()'
p2822
aS'    {'
p2823
aS'      Threads::TaskGroup<void> tasks;'
p2824
aS'      tasks +='
p2825
aS'        Threads::new_task(&WeightedResidual<dim>::solve_primal_problem, *this);'
p2826
aS'      tasks +='
p2827
aS'        Threads::new_task(&WeightedResidual<dim>::solve_dual_problem, *this);'
p2828
aS'      tasks.join_all();'
p2829
aS'    }'
p2830
aS'    template <int dim>'
p2831
aS'    void WeightedResidual<dim>::solve_primal_problem()'
p2832
aS'    {'
p2833
aS'      PrimalSolver<dim>::solve_problem();'
p2834
aS'    }'
p2835
aS'    template <int dim>'
p2836
aS'    void WeightedResidual<dim>::solve_dual_problem()'
p2837
aS'    {'
p2838
aS'      DualSolver<dim>::solve_problem();'
p2839
aS'    }'
p2840
aS'    template <int dim>'
p2841
aS'    void WeightedResidual<dim>::postprocess('
p2842
aS'      const Evaluation::EvaluationBase<dim> &postprocessor) const'
p2843
aS'    {'
p2844
aS'      PrimalSolver<dim>::postprocess(postprocessor);'
p2845
aS'    }'
p2846
aS'    template <int dim>'
p2847
aS'    unsigned int WeightedResidual<dim>::n_dofs() const'
p2848
aS'    {'
p2849
aS'      return PrimalSolver<dim>::n_dofs();'
p2850
aS'    }'
p2851
aS'    template <int dim>'
p2852
aS'    void WeightedResidual<dim>::refine_grid()'
p2853
aS'    {'
p2854
aS'      Vector<float> error_indicators(this->triangulation->n_active_cells());'
p2855
aS'      estimate_error(error_indicators);'
p2856
aS'      for (float &error_indicator : error_indicators)'
p2857
aS'        error_indicator = std::fabs(error_indicator);'
p2858
aS'      GridRefinement::refine_and_coarsen_fixed_fraction(*this->triangulation,'
p2859
aS'                                                        error_indicators,'
p2860
aS'                                                        0.8,'
p2861
aS'                                                        0.02);'
p2862
aS'      this->triangulation->execute_coarsening_and_refinement();'
p2863
aS'    }'
p2864
aS'    template <int dim>'
p2865
aS'    void WeightedResidual<dim>::output_solution() const'
p2866
aS'    {'
p2867
aS'      AffineConstraints<double> primal_hanging_node_constraints;'
p2868
aS'      DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,'
p2869
aS'                                              primal_hanging_node_constraints);'
p2870
aS'      primal_hanging_node_constraints.close();'
p2871
aS'      Vector<double> dual_solution(PrimalSolver<dim>::dof_handler.n_dofs());'
p2872
aS'      FETools::interpolate(DualSolver<dim>::dof_handler,'
p2873
aS'                           DualSolver<dim>::solution,'
p2874
aS'                           PrimalSolver<dim>::dof_handler,'
p2875
aS'                           primal_hanging_node_constraints,'
p2876
aS'                           dual_solution);'
p2877
aS'      DataOut<dim> data_out;'
p2878
aS'      data_out.attach_dof_handler(PrimalSolver<dim>::dof_handler);'
p2879
aS'      data_out.add_data_vector(PrimalSolver<dim>::solution, "primal_solution");'
p2880
aS'      data_out.add_data_vector(dual_solution, "dual_solution");'
p2881
aS'      data_out.build_patches();'
p2882
aS'      std::ofstream out("solution-" + std::to_string(this->refinement_cycle) +'
p2883
aS'                        ".vtu");'
p2884
aS'      data_out.write(out, DataOutBase::vtu);'
p2885
aS'    }'
p2886
aS'    template <int dim>'
p2887
aS'    void'
p2888
aS'    WeightedResidual<dim>::estimate_error(Vector<float> &error_indicators) const'
p2889
aS'    {'
p2890
aS'      AffineConstraints<double> dual_hanging_node_constraints;'
p2891
aS'      DoFTools::make_hanging_node_constraints(DualSolver<dim>::dof_handler,'
p2892
aS'                                              dual_hanging_node_constraints);'
p2893
aS'      dual_hanging_node_constraints.close();'
p2894
aS'      Vector<double> primal_solution(DualSolver<dim>::dof_handler.n_dofs());'
p2895
aS'      FETools::interpolate(PrimalSolver<dim>::dof_handler,'
p2896
aS'                           PrimalSolver<dim>::solution,'
p2897
aS'                           DualSolver<dim>::dof_handler,'
p2898
aS'                           dual_hanging_node_constraints,'
p2899
aS'                           primal_solution);'
p2900
aS'      AffineConstraints<double> primal_hanging_node_constraints;'
p2901
aS'      DoFTools::make_hanging_node_constraints(PrimalSolver<dim>::dof_handler,'
p2902
aS'                                              primal_hanging_node_constraints);'
p2903
aS'      primal_hanging_node_constraints.close();'
p2904
aS'      Vector<double> dual_weights(DualSolver<dim>::dof_handler.n_dofs());'
p2905
aS'      FETools::interpolation_difference(DualSolver<dim>::dof_handler,'
p2906
aS'                                        dual_hanging_node_constraints,'
p2907
aS'                                        DualSolver<dim>::solution,'
p2908
aS'                                        PrimalSolver<dim>::dof_handler,'
p2909
aS'                                        primal_hanging_node_constraints,'
p2910
aS'                                        dual_weights);'
p2911
aS'      FaceIntegrals face_integrals;'
p2912
aS'      for (const auto &cell :'
p2913
aS'           DualSolver<dim>::dof_handler.active_cell_iterators())'
p2914
aS'        for (const auto &face : cell->face_iterators())'
p2915
aS'          face_integrals[face] = -1e20;'
p2916
aS'      auto worker = [this,'
p2917
aS'                     &error_indicators,'
p2918
aS'                     &face_integrals](const active_cell_iterator & cell,'
p2919
aS'                                      WeightedResidualScratchData &scratch_data,'
p2920
aS'                                      WeightedResidualCopyData &   copy_data) {'
p2921
aS'        this->estimate_on_one_cell('
p2922
aS'          cell, scratch_data, copy_data, error_indicators, face_integrals);'
p2923
aS'      };'
p2924
aS'      auto do_nothing_copier ='
p2925
aS'        std::function<void(const WeightedResidualCopyData &)>();'
p2926
aS'      WorkStream::run('
p2927
aS'        DualSolver<dim>::dof_handler.begin_active(),'
p2928
aS'        DualSolver<dim>::dof_handler.end(),'
p2929
aS'        worker,'
p2930
aS'        do_nothing_copier,'
p2931
aS'        WeightedResidualScratchData(*DualSolver<dim>::fe,'
p2932
aS'                                    primal_solution,'
p2933
aS'                                    dual_weights),'
p2934
aS'        WeightedResidualCopyData());'
p2935
aS'      unsigned int present_cell = 0;'
p2936
aS'      for (const auto &cell :'
p2937
aS'           DualSolver<dim>::dof_handler.active_cell_iterators())'
p2938
aS'        {'
p2939
aS'          for (const auto &face : cell->face_iterators())'
p2940
aS'            {'
p2941
aS'              Assert(face_integrals.find(face) != face_integrals.end(),'
p2942
aS'                     ExcInternalError());'
p2943
aS'              error_indicators(present_cell) -= 0.5 * face_integrals[face];'
p2944
aS'            }'
p2945
aS'          ++present_cell;'
p2946
aS'        }'
p2947
aS'      std::cout << "   Estimated error="'
p2948
aS'                << std::accumulate(error_indicators.begin(),'
p2949
aS'                                   error_indicators.end(),'
p2950
aS'                                   0.)'
p2951
aS'                << std::endl;'
p2952
aS'    }'
p2953
aS'    template <int dim>'
p2954
aS'    void WeightedResidual<dim>::estimate_on_one_cell('
p2955
aS'      const active_cell_iterator & cell,'
p2956
aS'      WeightedResidualScratchData &scratch_data,'
p2957
aS'      WeightedResidualCopyData &   copy_data,'
p2958
aS'      Vector<float> &              error_indicators,'
p2959
aS'      FaceIntegrals &              face_integrals) const'
p2960
aS'    {'
p2961
aS'      integrate_over_cell(cell,'
p2962
aS'                          scratch_data.primal_solution,'
p2963
aS'                          scratch_data.dual_weights,'
p2964
aS'                          scratch_data.cell_data,'
p2965
aS'                          error_indicators);'
p2966
aS'      for (const auto face_no : cell->face_indices())'
p2967
aS'        {'
p2968
aS'          if (cell->face(face_no)->at_boundary())'
p2969
aS'            {'
p2970
aS'              face_integrals[cell->face(face_no)] = 0;'
p2971
aS'              continue;'
p2972
aS'            }'
p2973
aS'          if ((cell->neighbor(face_no)->has_children() == false) &&'
p2974
aS'            continue;'
p2975
aS'          if (cell->at_boundary(face_no) == false)'
p2976
aS'            if (cell->neighbor(face_no)->level() < cell->level())'
p2977
aS'              continue;'
p2978
aS'          if (cell->face(face_no)->has_children() == false)'
p2979
aS'            integrate_over_regular_face(cell,'
p2980
aS'                                        face_no,'
p2981
aS'                                        scratch_data.primal_solution,'
p2982
aS'                                        scratch_data.dual_weights,'
p2983
aS'                                        scratch_data.face_data,'
p2984
aS'                                        face_integrals);'
p2985
aS'          else'
p2986
aS'            integrate_over_irregular_face(cell,'
p2987
aS'                                          face_no,'
p2988
aS'                                          scratch_data.primal_solution,'
p2989
aS'                                          scratch_data.dual_weights,'
p2990
aS'                                          scratch_data.face_data,'
p2991
aS'                                          face_integrals);'
p2992
aS'        }'
p2993
aS'    }'
p2994
aS'    template <int dim>'
p2995
aS'    void WeightedResidual<dim>::integrate_over_cell('
p2996
aS'      const active_cell_iterator &cell,'
p2997
aS'      const Vector<double> &      primal_solution,'
p2998
aS'      const Vector<double> &      dual_weights,'
p2999
aS'      CellData &                  cell_data,'
p3000
aS'      Vector<float> &             error_indicators) const'
p3001
aS'    {'
p3002
aS'      cell_data.fe_values.reinit(cell);'
p3003
aS'      cell_data.right_hand_side->value_list('
p3004
aS'        cell_data.fe_values.get_quadrature_points(), cell_data.rhs_values);'
p3005
aS'      cell_data.fe_values.get_function_laplacians(primal_solution,'
p3006
aS'                                                  cell_data.cell_laplacians);'
p3007
aS'      cell_data.fe_values.get_function_values(dual_weights,'
p3008
aS'                                              cell_data.dual_weights);'
p3009
aS'      double sum = 0;'
p3010
aS'      for (unsigned int p = 0; p < cell_data.fe_values.n_quadrature_points; ++p)'
p3011
aS'        sum += ((cell_data.rhs_values[p] + cell_data.cell_laplacians[p]) *'
p3012
aS'                cell_data.dual_weights[p] * cell_data.fe_values.JxW(p));'
p3013
aS'      error_indicators(cell->active_cell_index()) += sum;'
p3014
aS'    }'
p3015
aS'    template <int dim>'
p3016
aS'    void WeightedResidual<dim>::integrate_over_regular_face('
p3017
aS'      const active_cell_iterator &cell,'
p3018
aS'      const unsigned int          face_no,'
p3019
aS'      const Vector<double> &      primal_solution,'
p3020
aS'      const Vector<double> &      dual_weights,'
p3021
aS'      FaceData &                  face_data,'
p3022
aS'      FaceIntegrals &             face_integrals) const'
p3023
aS'    {'
p3024
aS'      const unsigned int n_q_points ='
p3025
aS'        face_data.fe_face_values_cell.n_quadrature_points;'
p3026
aS'      face_data.fe_face_values_cell.reinit(cell, face_no);'
p3027
aS'      face_data.fe_face_values_cell.get_function_gradients('
p3028
aS'        primal_solution, face_data.cell_grads);'
p3029
aS'      Assert(cell->neighbor(face_no).state() == IteratorState::valid,'
p3030
aS'             ExcInternalError());'
p3031
aS'      const unsigned int neighbor_neighbor ='
p3032
aS'        cell->neighbor_of_neighbor(face_no);'
p3033
aS'      const active_cell_iterator neighbor = cell->neighbor(face_no);'
p3034
aS'      face_data.fe_face_values_neighbor.reinit(neighbor, neighbor_neighbor);'
p3035
aS'      face_data.fe_face_values_neighbor.get_function_gradients('
p3036
aS'        primal_solution, face_data.neighbor_grads);'
p3037
aS'      for (unsigned int p = 0; p < n_q_points; ++p)'
p3038
aS'        face_data.jump_residual[p] ='
p3039
aS'           face_data.fe_face_values_cell.normal_vector(p));'
p3040
aS'      face_data.fe_face_values_cell.get_function_values(dual_weights,'
p3041
aS'                                                        face_data.dual_weights);'
p3042
aS'      double face_integral = 0;'
p3043
aS'      for (unsigned int p = 0; p < n_q_points; ++p)'
p3044
aS'        face_integral +='
p3045
aS'           face_data.fe_face_values_cell.JxW(p));'
p3046
aS'      Assert(face_integrals.find(cell->face(face_no)) != face_integrals.end(),'
p3047
aS'             ExcInternalError());'
p3048
aS'      Assert(face_integrals[cell->face(face_no)] == -1e20, ExcInternalError());'
p3049
aS'      face_integrals[cell->face(face_no)] = face_integral;'
p3050
aS'    }'
p3051
aS'    template <int dim>'
p3052
aS'    void WeightedResidual<dim>::integrate_over_irregular_face('
p3053
aS'      const active_cell_iterator &cell,'
p3054
aS'      const unsigned int          face_no,'
p3055
aS'      const Vector<double> &      primal_solution,'
p3056
aS'      const Vector<double> &      dual_weights,'
p3057
aS'      FaceData &                  face_data,'
p3058
aS'      FaceIntegrals &             face_integrals) const'
p3059
aS'    {'
p3060
aS'      const unsigned int n_q_points ='
p3061
aS'        face_data.fe_face_values_cell.n_quadrature_points;'
p3062
aS'      const typename DoFHandler<dim>::face_iterator face = cell->face(face_no);'
p3063
aS'      const typename DoFHandler<dim>::cell_iterator neighbor ='
p3064
aS'        cell->neighbor(face_no);'
p3065
aS'      Assert(neighbor.state() == IteratorState::valid, ExcInternalError());'
p3066
aS'      Assert(neighbor->has_children(), ExcInternalError());'
p3067
aS'      const unsigned int neighbor_neighbor ='
p3068
aS'        cell->neighbor_of_neighbor(face_no);'
p3069
aS'      for (unsigned int subface_no = 0; subface_no < face->n_children();'
p3070
aS'           ++subface_no)'
p3071
aS'        {'
p3072
aS'          const active_cell_iterator neighbor_child ='
p3073
aS'            cell->neighbor_child_on_subface(face_no, subface_no);'
p3074
aS'          Assert(neighbor_child->face(neighbor_neighbor) =='
p3075
aS'                   cell->face(face_no)->child(subface_no),'
p3076
aS'                 ExcInternalError());'
p3077
aS'          face_data.fe_subface_values_cell.reinit(cell, face_no, subface_no);'
p3078
aS'          face_data.fe_subface_values_cell.get_function_gradients('
p3079
aS'            primal_solution, face_data.cell_grads);'
p3080
aS'          face_data.fe_face_values_neighbor.reinit(neighbor_child,'
p3081
aS'                                                   neighbor_neighbor);'
p3082
aS'          face_data.fe_face_values_neighbor.get_function_gradients('
p3083
aS'            primal_solution, face_data.neighbor_grads);'
p3084
aS'          for (unsigned int p = 0; p < n_q_points; ++p)'
p3085
aS'            face_data.jump_residual[p] ='
p3086
aS'               face_data.fe_face_values_neighbor.normal_vector(p));'
p3087
aS'          face_data.fe_face_values_neighbor.get_function_values('
p3088
aS'            dual_weights, face_data.dual_weights);'
p3089
aS'          double face_integral = 0;'
p3090
aS'          for (unsigned int p = 0; p < n_q_points; ++p)'
p3091
aS'            face_integral +='
p3092
aS'               face_data.fe_face_values_neighbor.JxW(p));'
p3093
aS'          face_integrals[neighbor_child->face(neighbor_neighbor)] ='
p3094
aS'            face_integral;'
p3095
aS'        }'
p3096
aS'      double sum = 0;'
p3097
aS'      for (unsigned int subface_no = 0; subface_no < face->n_children();'
p3098
aS'           ++subface_no)'
p3099
aS'        {'
p3100
aS'          Assert(face_integrals.find(face->child(subface_no)) !='
p3101
aS'                   face_integrals.end(),'
p3102
aS'                 ExcInternalError());'
p3103
aS'          Assert(face_integrals[face->child(subface_no)] != -1e20,'
p3104
aS'                 ExcInternalError());'
p3105
aS'          sum += face_integrals[face->child(subface_no)];'
p3106
aS'        }'
p3107
aS'      face_integrals[face] = sum;'
p3108
aS'    }'
p3109
aS'  } // namespace LaplaceSolver'
p3110
aS'  template <int dim>'
p3111
aS'  struct Framework'
p3112
aS'  {'
p3113
aS'  public:'
p3114
aS'    using Evaluator     = Evaluation::EvaluationBase<dim>;'
p3115
aS'    using EvaluatorList = std::list<Evaluator *>;'
p3116
aS'    struct ProblemDescription'
p3117
aS'    {'
p3118
aS'      unsigned int primal_fe_degree;'
p3119
aS'      unsigned int dual_fe_degree;'
p3120
aS'      std::unique_ptr<const Data::SetUpBase<dim>> data;'
p3121
aS'      enum RefinementCriterion'
p3122
aS'      {'
p3123
aS'        dual_weighted_error_estimator,'
p3124
aS'        global_refinement,'
p3125
aS'        kelly_indicator,'
p3126
aS'        weighted_kelly_indicator'
p3127
aS'      };'
p3128
aS'      RefinementCriterion refinement_criterion;'
p3129
aS'      std::unique_ptr<const DualFunctional::DualFunctionalBase<dim>>'
p3130
aS'        dual_functional;'
p3131
aS'      EvaluatorList evaluator_list;'
p3132
aS'      std::unique_ptr<const Function<dim>> kelly_weight;'
p3133
aS'      unsigned int max_degrees_of_freedom;'
p3134
aS'      ProblemDescription();'
p3135
aS'    };'
p3136
aS'    static void run(const ProblemDescription &descriptor);'
p3137
aS'  };'
p3138
aS'  template <int dim>'
p3139
aS'  Framework<dim>::ProblemDescription::ProblemDescription()'
p3140
aS'    : primal_fe_degree(1)'
p3141
aS'    , dual_fe_degree(2)'
p3142
aS'    , refinement_criterion(dual_weighted_error_estimator)'
p3143
aS'    , max_degrees_of_freedom(20000)'
p3144
aS'  {}'
p3145
aS'  template <int dim>'
p3146
aS'  void Framework<dim>::run(const ProblemDescription &descriptor)'
p3147
aS'  {'
p3148
aS'    Triangulation<dim> triangulation('
p3149
aS'      Triangulation<dim>::smoothing_on_refinement);'
p3150
aS'    descriptor.data->create_coarse_grid(triangulation);'
p3151
aS'    const FE_Q<dim>       primal_fe(descriptor.primal_fe_degree);'
p3152
aS'    const FE_Q<dim>       dual_fe(descriptor.dual_fe_degree);'
p3153
aS'    const QGauss<dim>     quadrature(descriptor.dual_fe_degree + 1);'
p3154
aS'    const QGauss<dim - 1> face_quadrature(descriptor.dual_fe_degree + 1);'
p3155
aS'    std::unique_ptr<LaplaceSolver::Base<dim>> solver;'
p3156
aS'    switch (descriptor.refinement_criterion)'
p3157
aS'      {'
p3158
aS'        case ProblemDescription::dual_weighted_error_estimator:'
p3159
aS'          {'
p3160
aS'            solver = std::make_unique<LaplaceSolver::WeightedResidual<dim>>('
p3161
aS'              triangulation,'
p3162
aS'              primal_fe,'
p3163
aS'              dual_fe,'
p3164
aS'              quadrature,'
p3165
aS'              face_quadrature,'
p3166
aS'              descriptor.data->get_right_hand_side(),'
p3167
aS'              descriptor.data->get_boundary_values(),'
p3168
aS'            break;'
p3169
aS'          }'
p3170
aS'        case ProblemDescription::global_refinement:'
p3171
aS'          {'
p3172
aS'            solver = std::make_unique<LaplaceSolver::RefinementGlobal<dim>>('
p3173
aS'              triangulation,'
p3174
aS'              primal_fe,'
p3175
aS'              quadrature,'
p3176
aS'              face_quadrature,'
p3177
aS'              descriptor.data->get_right_hand_side(),'
p3178
aS'              descriptor.data->get_boundary_values());'
p3179
aS'            break;'
p3180
aS'          }'
p3181
aS'        case ProblemDescription::kelly_indicator:'
p3182
aS'          {'
p3183
aS'            solver = std::make_unique<LaplaceSolver::RefinementKelly<dim>>('
p3184
aS'              triangulation,'
p3185
aS'              primal_fe,'
p3186
aS'              quadrature,'
p3187
aS'              face_quadrature,'
p3188
aS'              descriptor.data->get_right_hand_side(),'
p3189
aS'              descriptor.data->get_boundary_values());'
p3190
aS'            break;'
p3191
aS'          }'
p3192
aS'        case ProblemDescription::weighted_kelly_indicator:'
p3193
aS'          {'
p3194
aS'            solver ='
p3195
aS'              std::make_unique<LaplaceSolver::RefinementWeightedKelly<dim>>('
p3196
aS'                triangulation,'
p3197
aS'                primal_fe,'
p3198
aS'                quadrature,'
p3199
aS'                face_quadrature,'
p3200
aS'                descriptor.data->get_right_hand_side(),'
p3201
aS'                descriptor.data->get_boundary_values(),'
p3202
aS'            break;'
p3203
aS'          }'
p3204
aS'        default:'
p3205
aS'          AssertThrow(false, ExcInternalError());'
p3206
aS'      }'
p3207
aS'    for (unsigned int step = 0; true; ++step)'
p3208
aS'      {'
p3209
aS'        std::cout << "Refinement cycle: " << step << std::endl;'
p3210
aS'        solver->set_refinement_cycle(step);'
p3211
aS'        solver->solve_problem();'
p3212
aS'        solver->output_solution();'
p3213
aS'        std::cout << "   Number of degrees of freedom=" << solver->n_dofs()'
p3214
aS'                  << std::endl;'
p3215
aS'        for (const auto &evaluator : descriptor.evaluator_list)'
p3216
aS'          {'
p3217
aS'            evaluator->set_refinement_cycle(step);'
p3218
aS'            solver->postprocess(*evaluator);'
p3219
aS'          }'
p3220
aS'        if (solver->n_dofs() < descriptor.max_degrees_of_freedom)'
p3221
aS'          solver->refine_grid();'
p3222
aS'        else'
p3223
aS'          break;'
p3224
aS'      }'
p3225
aS'    std::cout << std::endl;'
p3226
aS'  }'
p3227
aS'} // namespace Step14'
p3228
aS'int main()'
p3229
ag9
aS'  try'
p3230
aS'    {'
p3231
aS'      using namespace Step14;'
p3232
aS'      const unsigned int                 dim = 2;'
p3233
aS'      Framework<dim>::ProblemDescription descriptor;'
p3234
aS'      descriptor.refinement_criterion ='
p3235
aS'        Framework<dim>::ProblemDescription::dual_weighted_error_estimator;'
p3236
aS'      descriptor.primal_fe_degree = 1;'
p3237
aS'      descriptor.dual_fe_degree   = 2;'
p3238
aS'      descriptor.data ='
p3239
aS'        std::make_unique<Data::SetUp<Data::Exercise_2_3<dim>, dim>>();'
p3240
aS'      const Point<dim> evaluation_point(0.75, 0.75);'
p3241
aS'      descriptor.dual_functional ='
p3242
aS'        std::make_unique<DualFunctional::PointValueEvaluation<dim>>('
p3243
aS'          evaluation_point);'
p3244
aS'      Evaluation::PointValueEvaluation<dim> postprocessor1(evaluation_point);'
p3245
aS'      Evaluation::GridOutput<dim>           postprocessor2("grid");'
p3246
aS'      descriptor.evaluator_list.push_back(&postprocessor1);'
p3247
aS'      descriptor.evaluator_list.push_back(&postprocessor2);'
p3248
aS'      descriptor.max_degrees_of_freedom = 20000;'
p3249
aS'      Framework<dim>::run(descriptor);'
p3250
aS'    }'
p3251
aS'  catch (std::exception &exc)'
p3252
aS'    {'
p3253
aS'      std::cerr << std::endl'
p3254
aS'                << std::endl'
p3255
aS'                << "----------------------------------------------------"'
p3256
aS'                << std::endl;'
p3257
aS'      std::cerr << "Exception on processing: " << std::endl'
p3258
aS'                << exc.what() << std::endl'
p3259
aS'                << "Aborting!" << std::endl'
p3260
aS'                << "----------------------------------------------------"'
p3261
aS'                << std::endl;'
p3262
aS'      return 1;'
p3263
aS'    }'
p3264
aS'  catch (...)'
p3265
aS'    {'
p3266
aS'      std::cerr << std::endl'
p3267
aS'                << std::endl'
p3268
aS'                << "----------------------------------------------------"'
p3269
aS'                << std::endl;'
p3270
aS'      std::cerr << "Unknown exception!" << std::endl'
p3271
aS'                << "Aborting!" << std::endl'
p3272
aS'                << "----------------------------------------------------"'
p3273
aS'                << std::endl;'
p3274
aS'      return 1;'
p3275
aS'    }'
p3276
aS'  return 0;'
p3277
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p3278
aS'#include <deal.II/base/function.h>'
p3279
aS'#include <deal.II/base/utilities.h>'
p3280
aS'#include <deal.II/lac/vector.h>'
p3281
aS'#include <deal.II/lac/full_matrix.h>'
p3282
aS'#include <deal.II/lac/sparse_matrix.h>'
p3283
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p3284
aS'#include <deal.II/lac/solver_cg.h>'
p3285
aS'#include <deal.II/lac/precondition.h>'
p3286
aS'#include <deal.II/lac/affine_constraints.h>'
p3287
aS'#include <deal.II/grid/tria.h>'
p3288
aS'#include <deal.II/grid/grid_generator.h>'
p3289
aS'#include <deal.II/grid/grid_refinement.h>'
p3290
aS'#include <deal.II/dofs/dof_handler.h>'
p3291
aS'#include <deal.II/dofs/dof_tools.h>'
p3292
aS'#include <deal.II/fe/fe_values.h>'
p3293
aS'#include <deal.II/fe/fe_q.h>'
p3294
aS'#include <deal.II/numerics/vector_tools.h>'
p3295
aS'#include <deal.II/numerics/matrix_tools.h>'
p3296
aS'#include <deal.II/numerics/data_out.h>'
p3297
aS'#include <deal.II/numerics/error_estimator.h>'
p3298
aS'#include <fstream>'
p3299
aS'#include <iostream>'
p3300
aS'#include <deal.II/numerics/solution_transfer.h>'
p3301
aS'namespace Step15'
p3302
ag9
aS'  using namespace dealii;'
p3303
aS'  template <int dim>'
p3304
aS'  class MinimalSurfaceProblem'
p3305
aS'  {'
p3306
aS'  public:'
p3307
aS'    MinimalSurfaceProblem();'
p3308
aS'    void run();'
p3309
aS'  private:'
p3310
aS'    void   setup_system(const bool initial_step);'
p3311
aS'    void   assemble_system();'
p3312
aS'    void   solve();'
p3313
aS'    void   refine_mesh();'
p3314
aS'    void   set_boundary_values();'
p3315
aS'    double compute_residual(const double alpha) const;'
p3316
aS'    double determine_step_length() const;'
p3317
aS'    void   output_results(const unsigned int refinement_cycle) const;'
p3318
aS'    Triangulation<dim> triangulation;'
p3319
aS'    DoFHandler<dim> dof_handler;'
p3320
aS'    FE_Q<dim>       fe;'
p3321
aS'    AffineConstraints<double> hanging_node_constraints;'
p3322
aS'    SparsityPattern      sparsity_pattern;'
p3323
aS'    SparseMatrix<double> system_matrix;'
p3324
aS'    Vector<double> current_solution;'
p3325
aS'    Vector<double> newton_update;'
p3326
aS'    Vector<double> system_rhs;'
p3327
aS'  };'
p3328
aS'  template <int dim>'
p3329
aS'  class BoundaryValues : public Function<dim>'
p3330
aS'  {'
p3331
aS'  public:'
p3332
aS'    virtual double value(const Point<dim> & p,'
p3333
aS'                         const unsigned int component = 0) const override;'
p3334
aS'  };'
p3335
aS'  template <int dim>'
p3336
aS'  double BoundaryValues<dim>::value(const Point<dim> &p,'
p3337
aS'                                    const unsigned int /*component*/) const'
p3338
aS'  {'
p3339
aS'    return std::sin(2 * numbers::PI * (p[0] + p[1]));'
p3340
aS'  }'
p3341
aS'  template <int dim>'
p3342
aS'  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()'
p3343
aS'    : dof_handler(triangulation)'
p3344
aS'    , fe(2)'
p3345
aS'  {}'
p3346
aS'  template <int dim>'
p3347
aS'  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step)'
p3348
aS'  {'
p3349
aS'    if (initial_step)'
p3350
aS'      {'
p3351
aS'        dof_handler.distribute_dofs(fe);'
p3352
aS'        current_solution.reinit(dof_handler.n_dofs());'
p3353
aS'        hanging_node_constraints.clear();'
p3354
aS'        DoFTools::make_hanging_node_constraints(dof_handler,'
p3355
aS'                                                hanging_node_constraints);'
p3356
aS'        hanging_node_constraints.close();'
p3357
aS'      }'
p3358
aS'    newton_update.reinit(dof_handler.n_dofs());'
p3359
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p3360
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p3361
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p3362
aS'    hanging_node_constraints.condense(dsp);'
p3363
aS'    sparsity_pattern.copy_from(dsp);'
p3364
aS'    system_matrix.reinit(sparsity_pattern);'
p3365
aS'  }'
p3366
aS'  template <int dim>'
p3367
aS'  void MinimalSurfaceProblem<dim>::assemble_system()'
p3368
aS'  {'
p3369
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p3370
aS'    system_matrix = 0;'
p3371
aS'    system_rhs    = 0;'
p3372
aS'    FEValues<dim> fe_values(fe,'
p3373
aS'                            quadrature_formula,'
p3374
aS'                            update_gradients | update_quadrature_points |'
p3375
aS'                              update_JxW_values);'
p3376
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p3377
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p3378
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p3379
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p3380
aS'    std::vector<Tensor<1, dim>> old_solution_gradients(n_q_points);'
p3381
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p3382
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p3383
aS'      {'
p3384
aS'        cell_matrix = 0;'
p3385
aS'        cell_rhs    = 0;'
p3386
aS'        fe_values.reinit(cell);'
p3387
aS'        fe_values.get_function_gradients(current_solution,'
p3388
aS'                                         old_solution_gradients);'
p3389
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p3390
aS'          {'
p3391
aS'            const double coeff ='
p3392
aS'              1.0 / std::sqrt(1 + old_solution_gradients[q] *'
p3393
aS'                                    old_solution_gradients[q]);'
p3394
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3395
aS'              {'
p3396
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3397
aS'                  cell_matrix(i, j) +='
p3398
aS'                      -                                //  -'
p3399
aS'                cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \\nabla \\phi_i'
p3400
aS'              }'
p3401
aS'          }'
p3402
aS'        cell->get_dof_indices(local_dof_indices);'
p3403
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3404
aS'          {'
p3405
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3406
aS'              system_matrix.add(local_dof_indices[i],'
p3407
aS'                                local_dof_indices[j],'
p3408
aS'                                cell_matrix(i, j));'
p3409
aS'            system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p3410
aS'          }'
p3411
aS'      }'
p3412
aS'    hanging_node_constraints.condense(system_matrix);'
p3413
aS'    hanging_node_constraints.condense(system_rhs);'
p3414
aS'    std::map<types::global_dof_index, double> boundary_values;'
p3415
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p3416
aS'                                             0,'
p3417
aS'                                             Functions::ZeroFunction<dim>(),'
p3418
aS'                                             boundary_values);'
p3419
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p3420
aS'                                       system_matrix,'
p3421
aS'                                       newton_update,'
p3422
aS'                                       system_rhs);'
p3423
aS'  }'
p3424
aS'  template <int dim>'
p3425
aS'  void MinimalSurfaceProblem<dim>::solve()'
p3426
aS'  {'
p3427
aS'    SolverControl            solver_control(system_rhs.size(),'
p3428
aS'                                 system_rhs.l2_norm() * 1e-6);'
p3429
aS'    SolverCG<Vector<double>> solver(solver_control);'
p3430
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p3431
aS'    preconditioner.initialize(system_matrix, 1.2);'
p3432
aS'    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p3433
aS'    hanging_node_constraints.distribute(newton_update);'
p3434
aS'    const double alpha = determine_step_length();'
p3435
aS'    current_solution.add(alpha, newton_update);'
p3436
aS'  }'
p3437
aS'  template <int dim>'
p3438
aS'  void MinimalSurfaceProblem<dim>::refine_mesh()'
p3439
aS'  {'
p3440
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p3441
aS'    KellyErrorEstimator<dim>::estimate('
p3442
aS'      dof_handler,'
p3443
aS'      QGauss<dim - 1>(fe.degree + 1),'
p3444
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p3445
aS'      current_solution,'
p3446
aS'      estimated_error_per_cell);'
p3447
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p3448
aS'                                                    estimated_error_per_cell,'
p3449
aS'                                                    0.3,'
p3450
aS'                                                    0.03);'
p3451
aS'    triangulation.prepare_coarsening_and_refinement();'
p3452
aS'    SolutionTransfer<dim> solution_transfer(dof_handler);'
p3453
aS'    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);'
p3454
aS'    triangulation.execute_coarsening_and_refinement();'
p3455
aS'    dof_handler.distribute_dofs(fe);'
p3456
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p3457
aS'    solution_transfer.interpolate(current_solution, tmp);'
p3458
aS'    current_solution = tmp;'
p3459
aS'    hanging_node_constraints.clear();'
p3460
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p3461
aS'                                            hanging_node_constraints);'
p3462
aS'    hanging_node_constraints.close();'
p3463
aS'    set_boundary_values();'
p3464
aS'    setup_system(false);'
p3465
aS'  }'
p3466
aS'  template <int dim>'
p3467
aS'  void MinimalSurfaceProblem<dim>::set_boundary_values()'
p3468
aS'  {'
p3469
aS'    std::map<types::global_dof_index, double> boundary_values;'
p3470
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p3471
aS'                                             0,'
p3472
aS'                                             BoundaryValues<dim>(),'
p3473
aS'                                             boundary_values);'
p3474
aS'    for (auto &boundary_value : boundary_values)'
p3475
aS'      current_solution(boundary_value.first) = boundary_value.second;'
p3476
aS'    hanging_node_constraints.distribute(current_solution);'
p3477
aS'  }'
p3478
aS'  template <int dim>'
p3479
aS'  double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const'
p3480
aS'  {'
p3481
aS'    Vector<double> residual(dof_handler.n_dofs());'
p3482
aS'    Vector<double> evaluation_point(dof_handler.n_dofs());'
p3483
aS'    evaluation_point = current_solution;'
p3484
aS'    evaluation_point.add(alpha, newton_update);'
p3485
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p3486
aS'    FEValues<dim>     fe_values(fe,'
p3487
aS'                            quadrature_formula,'
p3488
aS'                            update_gradients | update_quadrature_points |'
p3489
aS'                              update_JxW_values);'
p3490
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p3491
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p3492
aS'    Vector<double>              cell_residual(dofs_per_cell);'
p3493
aS'    std::vector<Tensor<1, dim>> gradients(n_q_points);'
p3494
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p3495
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p3496
aS'      {'
p3497
aS'        cell_residual = 0;'
p3498
aS'        fe_values.reinit(cell);'
p3499
aS'        fe_values.get_function_gradients(evaluation_point, gradients);'
p3500
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p3501
aS'          {'
p3502
aS'            const double coeff ='
p3503
aS'              1. / std::sqrt(1 + gradients[q] * gradients[q]);'
p3504
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3505
aS'              cell_residual(i) -= (fe_values.shape_grad(i, q) // \\nabla \\phi_i'
p3506
aS'          }'
p3507
aS'        cell->get_dof_indices(local_dof_indices);'
p3508
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3509
aS'          residual(local_dof_indices[i]) += cell_residual(i);'
p3510
aS'      }'
p3511
aS'    hanging_node_constraints.condense(residual);'
p3512
aS'    for (types::global_dof_index i :'
p3513
aS'         DoFTools::extract_boundary_dofs(dof_handler))'
p3514
aS'      residual(i) = 0;'
p3515
aS'    return residual.l2_norm();'
p3516
aS'  }'
p3517
aS'  template <int dim>'
p3518
aS'  double MinimalSurfaceProblem<dim>::determine_step_length() const'
p3519
aS'  {'
p3520
aS'    return 0.1;'
p3521
aS'  }'
p3522
aS'  template <int dim>'
p3523
aS'  void MinimalSurfaceProblem<dim>::output_results('
p3524
aS'    const unsigned int refinement_cycle) const'
p3525
aS'  {'
p3526
aS'    DataOut<dim> data_out;'
p3527
aS'    data_out.attach_dof_handler(dof_handler);'
p3528
aS'    data_out.add_data_vector(current_solution, "solution");'
p3529
aS'    data_out.add_data_vector(newton_update, "update");'
p3530
aS'    data_out.build_patches();'
p3531
aS'    const std::string filename ='
p3532
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu";'
p3533
aS'    std::ofstream output(filename);'
p3534
aS'    data_out.write_vtu(output);'
p3535
aS'  }'
p3536
aS'  template <int dim>'
p3537
aS'  void MinimalSurfaceProblem<dim>::run()'
p3538
aS'  {'
p3539
aS'    GridGenerator::hyper_ball(triangulation);'
p3540
aS'    triangulation.refine_global(2);'
p3541
aS'    setup_system(/*first time=*/true);'
p3542
aS'    set_boundary_values();'
p3543
aS'    double       last_residual_norm = std::numeric_limits<double>::max();'
p3544
aS'    unsigned int refinement_cycle   = 0;'
p3545
aS'    do'
p3546
aS'      {'
p3547
aS'        std::cout << "Mesh refinement step " << refinement_cycle << std::endl;'
p3548
aS'        if (refinement_cycle != 0)'
p3549
aS'          refine_mesh();'
p3550
aS'        std::cout << "  Initial residual: " << compute_residual(0) << std::endl;'
p3551
aS'        for (unsigned int inner_iteration = 0; inner_iteration < 5;'
p3552
aS'             ++inner_iteration)'
p3553
aS'          {'
p3554
aS'            assemble_system();'
p3555
aS'            last_residual_norm = system_rhs.l2_norm();'
p3556
aS'            solve();'
p3557
aS'            std::cout << "  Residual: " << compute_residual(0) << std::endl;'
p3558
aS'          }'
p3559
aS'        output_results(refinement_cycle);'
p3560
aS'        ++refinement_cycle;'
p3561
aS'        std::cout << std::endl;'
p3562
aS'      }'
p3563
aS'    while (last_residual_norm > 1e-3);'
p3564
aS'  }'
p3565
aS'} // namespace Step15'
p3566
aS'int main()'
p3567
ag9
aS'  try'
p3568
aS'    {'
p3569
aS'      using namespace Step15;'
p3570
aS'      MinimalSurfaceProblem<2> laplace_problem_2d;'
p3571
aS'      laplace_problem_2d.run();'
p3572
aS'    }'
p3573
aS'  catch (std::exception &exc)'
p3574
aS'    {'
p3575
aS'      std::cerr << std::endl'
p3576
aS'                << std::endl'
p3577
aS'                << "----------------------------------------------------"'
p3578
aS'                << std::endl;'
p3579
aS'      std::cerr << "Exception on processing: " << std::endl'
p3580
aS'                << exc.what() << std::endl'
p3581
aS'                << "Aborting!" << std::endl'
p3582
aS'                << "----------------------------------------------------"'
p3583
aS'                << std::endl;'
p3584
aS'      return 1;'
p3585
aS'    }'
p3586
aS'  catch (...)'
p3587
aS'    {'
p3588
aS'      std::cerr << std::endl'
p3589
aS'                << std::endl'
p3590
aS'                << "----------------------------------------------------"'
p3591
aS'                << std::endl;'
p3592
aS'      std::cerr << "Unknown exception!" << std::endl'
p3593
aS'                << "Aborting!" << std::endl'
p3594
aS'                << "----------------------------------------------------"'
p3595
aS'                << std::endl;'
p3596
aS'      return 1;'
p3597
aS'    }'
p3598
aS'  return 0;'
p3599
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p3600
aS'#include <deal.II/base/function.h>'
p3601
aS'#include <deal.II/base/logstream.h>'
p3602
aS'#include <deal.II/base/utilities.h>'
p3603
aS'#include <deal.II/lac/affine_constraints.h>'
p3604
aS'#include <deal.II/lac/vector.h>'
p3605
aS'#include <deal.II/lac/full_matrix.h>'
p3606
aS'#include <deal.II/lac/sparse_matrix.h>'
p3607
aS'#include <deal.II/lac/solver_cg.h>'
p3608
aS'#include <deal.II/lac/precondition.h>'
p3609
aS'#include <deal.II/grid/tria.h>'
p3610
aS'#include <deal.II/grid/grid_generator.h>'
p3611
aS'#include <deal.II/grid/grid_refinement.h>'
p3612
aS'#include <deal.II/dofs/dof_tools.h>'
p3613
aS'#include <deal.II/fe/fe_q.h>'
p3614
aS'#include <deal.II/fe/fe_values.h>'
p3615
aS'#include <deal.II/numerics/vector_tools.h>'
p3616
aS'#include <deal.II/numerics/data_out.h>'
p3617
aS'#include <deal.II/numerics/error_estimator.h>'
p3618
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p3619
aS'#include <deal.II/multigrid/multigrid.h>'
p3620
aS'#include <deal.II/multigrid/mg_transfer.h>'
p3621
aS'#include <deal.II/multigrid/mg_tools.h>'
p3622
aS'#include <deal.II/multigrid/mg_coarse.h>'
p3623
aS'#include <deal.II/multigrid/mg_smoother.h>'
p3624
aS'#include <deal.II/multigrid/mg_matrix.h>'
p3625
aS'#include <deal.II/meshworker/mesh_loop.h>'
p3626
aS'#include <iostream>'
p3627
aS'#include <fstream>'
p3628
aS'using namespace dealii;'
p3629
aS'namespace Step16'
p3630
ag9
aS'  template <int dim>'
p3631
aS'  struct ScratchData'
p3632
aS'  {'
p3633
aS'    ScratchData(const Mapping<dim> &      mapping,'
p3634
aS'                const FiniteElement<dim> &fe,'
p3635
aS'                const unsigned int        quadrature_degree,'
p3636
aS'                const UpdateFlags         update_flags)'
p3637
aS'      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)'
p3638
aS'    {}'
p3639
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p3640
aS'      : fe_values(scratch_data.fe_values.get_mapping(),'
p3641
aS'                  scratch_data.fe_values.get_fe(),'
p3642
aS'                  scratch_data.fe_values.get_quadrature(),'
p3643
aS'                  scratch_data.fe_values.get_update_flags())'
p3644
aS'    {}'
p3645
aS'    FEValues<dim> fe_values;'
p3646
aS'  };'
p3647
aS'  struct CopyData'
p3648
aS'  {'
p3649
aS'    unsigned int                         level;'
p3650
aS'    FullMatrix<double>                   cell_matrix;'
p3651
aS'    Vector<double>                       cell_rhs;'
p3652
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p3653
aS'    template <class Iterator>'
p3654
aS'    void reinit(const Iterator &cell, unsigned int dofs_per_cell)'
p3655
aS'    {'
p3656
aS'      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p3657
aS'      cell_rhs.reinit(dofs_per_cell);'
p3658
aS'      local_dof_indices.resize(dofs_per_cell);'
p3659
aS'      cell->get_active_or_mg_dof_indices(local_dof_indices);'
p3660
aS'      level = cell->level();'
p3661
aS'    }'
p3662
aS'  };'
p3663
aS'  template <int dim>'
p3664
aS'  class LaplaceProblem'
p3665
aS'  {'
p3666
aS'  public:'
p3667
aS'    LaplaceProblem(const unsigned int degree);'
p3668
aS'    void run();'
p3669
aS'  private:'
p3670
aS'    template <class Iterator>'
p3671
aS'    void cell_worker(const Iterator &  cell,'
p3672
aS'                     ScratchData<dim> &scratch_data,'
p3673
aS'                     CopyData &        copy_data);'
p3674
aS'    void setup_system();'
p3675
aS'    void assemble_system();'
p3676
aS'    void assemble_multigrid();'
p3677
aS'    void solve();'
p3678
aS'    void refine_grid();'
p3679
aS'    void output_results(const unsigned int cycle) const;'
p3680
aS'    Triangulation<dim> triangulation;'
p3681
aS'    FE_Q<dim>          fe;'
p3682
aS'    DoFHandler<dim>    dof_handler;'
p3683
aS'    SparsityPattern      sparsity_pattern;'
p3684
aS'    SparseMatrix<double> system_matrix;'
p3685
aS'    AffineConstraints<double> constraints;'
p3686
aS'    Vector<double> solution;'
p3687
aS'    Vector<double> system_rhs;'
p3688
aS'    const unsigned int degree;'
p3689
aS'    MGLevelObject<SparsityPattern> mg_sparsity_patterns;'
p3690
aS'    MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;'
p3691
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p3692
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_matrices;'
p3693
aS'    MGConstrainedDoFs                   mg_constrained_dofs;'
p3694
aS'  };'
p3695
aS'  template <int dim>'
p3696
aS'  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree)'
p3697
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p3698
aS'    , fe(degree)'
p3699
aS'    , dof_handler(triangulation)'
p3700
aS'    , degree(degree)'
p3701
aS'  {}'
p3702
aS'  template <int dim>'
p3703
aS'  void LaplaceProblem<dim>::setup_system()'
p3704
aS'  {'
p3705
aS'    dof_handler.distribute_dofs(fe);'
p3706
aS'    dof_handler.distribute_mg_dofs();'
p3707
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p3708
aS'              << " (by level: ";'
p3709
aS'    for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p3710
aS'      std::cout << dof_handler.n_dofs(level)'
p3711
aS'                << (level == triangulation.n_levels() - 1 ? ")" : ", ");'
p3712
aS'    std::cout << std::endl;'
p3713
aS'    solution.reinit(dof_handler.n_dofs());'
p3714
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p3715
aS'    constraints.clear();'
p3716
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p3717
aS'    std::set<types::boundary_id> dirichlet_boundary_ids = {0};'
p3718
aS'    Functions::ZeroFunction<dim> homogeneous_dirichlet_bc;'
p3719
aS'    const std::map<types::boundary_id, const Function<dim> *>'
p3720
aS'      dirichlet_boundary_functions = {'
p3721
aS'        {types::boundary_id(0), &homogeneous_dirichlet_bc}};'
p3722
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p3723
aS'                                             dirichlet_boundary_functions,'
p3724
aS'                                             constraints);'
p3725
aS'    constraints.close();'
p3726
aS'    {'
p3727
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p3728
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p3729
aS'      sparsity_pattern.copy_from(dsp);'
p3730
aS'    }'
p3731
aS'    system_matrix.reinit(sparsity_pattern);'
p3732
aS'    mg_constrained_dofs.clear();'
p3733
aS'    mg_constrained_dofs.initialize(dof_handler);'
p3734
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p3735
aS'                                                       dirichlet_boundary_ids);'
p3736
aS'    const unsigned int n_levels = triangulation.n_levels();'
p3737
aS'    mg_interface_matrices.resize(0, n_levels - 1);'
p3738
aS'    mg_matrices.resize(0, n_levels - 1);'
p3739
aS'    mg_sparsity_patterns.resize(0, n_levels - 1);'
p3740
aS'    mg_interface_sparsity_patterns.resize(0, n_levels - 1);'
p3741
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p3742
aS'      {'
p3743
aS'        {'
p3744
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p3745
aS'                                     dof_handler.n_dofs(level));'
p3746
aS'          MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p3747
aS'          mg_sparsity_patterns[level].copy_from(dsp);'
p3748
aS'          mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p3749
aS'        }'
p3750
aS'        {'
p3751
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p3752
aS'                                     dof_handler.n_dofs(level));'
p3753
aS'          MGTools::make_interface_sparsity_pattern(dof_handler,'
p3754
aS'                                                   mg_constrained_dofs,'
p3755
aS'                                                   dsp,'
p3756
aS'                                                   level);'
p3757
aS'          mg_interface_sparsity_patterns[level].copy_from(dsp);'
p3758
aS'          mg_interface_matrices[level].reinit('
p3759
aS'            mg_interface_sparsity_patterns[level]);'
p3760
aS'        }'
p3761
aS'      }'
p3762
aS'  }'
p3763
aS'  template <int dim>'
p3764
aS'  template <class Iterator>'
p3765
aS'  void LaplaceProblem<dim>::cell_worker(const Iterator &  cell,'
p3766
aS'                                        ScratchData<dim> &scratch_data,'
p3767
aS'                                        CopyData &        copy_data)'
p3768
aS'  {'
p3769
aS'    FEValues<dim> &fe_values = scratch_data.fe_values;'
p3770
aS'    fe_values.reinit(cell);'
p3771
aS'    const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();'
p3772
aS'    const unsigned int n_q_points    = fe_values.get_quadrature().size();'
p3773
aS'    copy_data.reinit(cell, dofs_per_cell);'
p3774
aS'    const std::vector<double> &JxW = fe_values.get_JxW_values();'
p3775
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p3776
aS'      {'
p3777
aS'        const double coefficient ='
p3778
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3779
aS'          {'
p3780
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3781
aS'              {'
p3782
aS'                copy_data.cell_matrix(i, j) +='
p3783
aS'                  coefficient *'
p3784
aS'                  JxW[q];'
p3785
aS'              }'
p3786
aS'            copy_data.cell_rhs(i) += 1.0 * fe_values.shape_value(i, q) * JxW[q];'
p3787
aS'          }'
p3788
aS'      }'
p3789
aS'  }'
p3790
aS'  template <int dim>'
p3791
aS'  void LaplaceProblem<dim>::assemble_system()'
p3792
aS'  {'
p3793
aS'    MappingQ1<dim> mapping;'
p3794
aS'    auto cell_worker ='
p3795
aS'      [&](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p3796
aS'          ScratchData<dim> &                                    scratch_data,'
p3797
aS'          CopyData &                                            copy_data) {'
p3798
aS'        this->cell_worker(cell, scratch_data, copy_data);'
p3799
aS'      };'
p3800
aS'    auto copier = [&](const CopyData &cd) {'
p3801
aS'      this->constraints.distribute_local_to_global(cd.cell_matrix,'
p3802
aS'                                                   cd.cell_rhs,'
p3803
aS'                                                   cd.local_dof_indices,'
p3804
aS'                                                   system_matrix,'
p3805
aS'                                                   system_rhs);'
p3806
aS'    };'
p3807
aS'    const unsigned int n_gauss_points = degree + 1;'
p3808
aS'    ScratchData<dim> scratch_data(mapping,'
p3809
aS'                                  fe,'
p3810
aS'                                  n_gauss_points,'
p3811
aS'                                  update_values | update_gradients |'
p3812
aS'                                    update_JxW_values |'
p3813
aS'                                    update_quadrature_points);'
p3814
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p3815
aS'                          dof_handler.end(),'
p3816
aS'                          cell_worker,'
p3817
aS'                          copier,'
p3818
aS'                          scratch_data,'
p3819
aS'                          CopyData(),'
p3820
aS'                          MeshWorker::assemble_own_cells);'
p3821
aS'  }'
p3822
aS'  template <int dim>'
p3823
aS'  void LaplaceProblem<dim>::assemble_multigrid()'
p3824
aS'  {'
p3825
aS'    MappingQ1<dim>     mapping;'
p3826
aS'    const unsigned int n_levels = triangulation.n_levels();'
p3827
aS'    std::vector<AffineConstraints<double>> boundary_constraints(n_levels);'
p3828
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p3829
aS'      {'
p3830
aS'        IndexSet dofset;'
p3831
aS'        DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p3832
aS'                                                      level,'
p3833
aS'                                                      dofset);'
p3834
aS'        boundary_constraints[level].reinit(dofset);'
p3835
aS'        boundary_constraints[level].add_lines('
p3836
aS'          mg_constrained_dofs.get_refinement_edge_indices(level));'
p3837
aS'        boundary_constraints[level].add_lines('
p3838
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p3839
aS'        boundary_constraints[level].close();'
p3840
aS'      }'
p3841
aS'    auto cell_worker ='
p3842
aS'      [&](const typename DoFHandler<dim>::level_cell_iterator &cell,'
p3843
aS'          ScratchData<dim> &                                   scratch_data,'
p3844
aS'          CopyData &                                           copy_data) {'
p3845
aS'        this->cell_worker(cell, scratch_data, copy_data);'
p3846
aS'      };'
p3847
aS'    auto copier = [&](const CopyData &cd) {'
p3848
aS'      boundary_constraints[cd.level].distribute_local_to_global('
p3849
aS'        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);'
p3850
aS'      const unsigned int dofs_per_cell = cd.local_dof_indices.size();'
p3851
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p3852
aS'        for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p3853
aS'          if (mg_constrained_dofs.is_interface_matrix_entry('
p3854
aS'                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))'
p3855
aS'            {'
p3856
aS'              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],'
p3857
aS'                                                  cd.local_dof_indices[j],'
p3858
aS'                                                  cd.cell_matrix(i, j));'
p3859
aS'            }'
p3860
aS'    };'
p3861
aS'    const unsigned int n_gauss_points = degree + 1;'
p3862
aS'    ScratchData<dim> scratch_data(mapping,'
p3863
aS'                                  fe,'
p3864
aS'                                  n_gauss_points,'
p3865
aS'                                  update_values | update_gradients |'
p3866
aS'                                    update_JxW_values |'
p3867
aS'                                    update_quadrature_points);'
p3868
aS'    MeshWorker::mesh_loop(dof_handler.begin_mg(),'
p3869
aS'                          dof_handler.end_mg(),'
p3870
aS'                          cell_worker,'
p3871
aS'                          copier,'
p3872
aS'                          scratch_data,'
p3873
aS'                          CopyData(),'
p3874
aS'                          MeshWorker::assemble_own_cells);'
p3875
aS'  }'
p3876
aS'  template <int dim>'
p3877
aS'  void LaplaceProblem<dim>::solve()'
p3878
aS'  {'
p3879
aS'    MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);'
p3880
aS'    mg_transfer.build(dof_handler);'
p3881
aS'    FullMatrix<double> coarse_matrix;'
p3882
aS'    coarse_matrix.copy_from(mg_matrices[0]);'
p3883
aS'    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p3884
aS'    coarse_grid_solver.initialize(coarse_matrix);'
p3885
aS'    using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p3886
aS'    mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;'
p3887
aS'    mg_smoother.initialize(mg_matrices);'
p3888
aS'    mg_smoother.set_steps(2);'
p3889
aS'    mg_smoother.set_symmetric(true);'
p3890
aS'    mg::Matrix<Vector<double>> mg_matrix(mg_matrices);'
p3891
aS'    mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);'
p3892
aS'    mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);'
p3893
aS'    Multigrid<Vector<double>> mg('
p3894
aS'      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);'
p3895
aS'    mg.set_edge_matrices(mg_interface_down, mg_interface_up);'
p3896
aS'    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p3897
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p3898
aS'    SolverControl            solver_control(1000, 1e-12);'
p3899
aS'    SolverCG<Vector<double>> solver(solver_control);'
p3900
aS'    solution = 0;'
p3901
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p3902
aS'    std::cout << "   Number of CG iterations: " << solver_control.last_step()'
p3903
aS'              << "\\n"'
p3904
aS'              << std::endl;'
p3905
aS'    constraints.distribute(solution);'
p3906
aS'  }'
p3907
aS'  template <int dim>'
p3908
aS'  void LaplaceProblem<dim>::refine_grid()'
p3909
aS'  {'
p3910
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p3911
aS'    KellyErrorEstimator<dim>::estimate('
p3912
aS'      dof_handler,'
p3913
aS'      QGauss<dim - 1>(degree + 2),'
p3914
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p3915
aS'      solution,'
p3916
aS'      estimated_error_per_cell);'
p3917
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p3918
aS'                                                    estimated_error_per_cell,'
p3919
aS'                                                    0.3,'
p3920
aS'                                                    0.03);'
p3921
aS'    triangulation.execute_coarsening_and_refinement();'
p3922
aS'  }'
p3923
aS'  template <int dim>'
p3924
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p3925
aS'  {'
p3926
aS'    DataOut<dim> data_out;'
p3927
aS'    data_out.attach_dof_handler(dof_handler);'
p3928
aS'    data_out.add_data_vector(solution, "solution");'
p3929
aS'    data_out.build_patches();'
p3930
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p3931
aS'    data_out.write_vtk(output);'
p3932
aS'  }'
p3933
aS'  template <int dim>'
p3934
aS'  void LaplaceProblem<dim>::run()'
p3935
aS'  {'
p3936
aS'    for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p3937
aS'      {'
p3938
aS'        std::cout << "Cycle " << cycle << std::endl;'
p3939
aS'        if (cycle == 0)'
p3940
aS'          {'
p3941
aS'            GridGenerator::hyper_ball(triangulation);'
p3942
aS'            triangulation.refine_global(2);'
p3943
aS'          }'
p3944
aS'        else'
p3945
aS'          refine_grid();'
p3946
aS'        std::cout << "   Number of active cells:       "'
p3947
aS'                  << triangulation.n_active_cells() << std::endl;'
p3948
aS'        setup_system();'
p3949
aS'        assemble_system();'
p3950
aS'        assemble_multigrid();'
p3951
aS'        solve();'
p3952
aS'        output_results(cycle);'
p3953
aS'      }'
p3954
aS'  }'
p3955
aS'} // namespace Step16'
p3956
aS'int main()'
p3957
ag9
aS'  try'
p3958
aS'    {'
p3959
aS'      using namespace Step16;'
p3960
aS'      LaplaceProblem<2> laplace_problem(1);'
p3961
aS'      laplace_problem.run();'
p3962
aS'    }'
p3963
aS'  catch (std::exception &exc)'
p3964
aS'    {'
p3965
aS'      std::cerr << std::endl'
p3966
aS'                << std::endl'
p3967
aS'                << "----------------------------------------------------"'
p3968
aS'                << std::endl;'
p3969
aS'      std::cerr << "Exception on processing: " << std::endl'
p3970
aS'                << exc.what() << std::endl'
p3971
aS'                << "Aborting!" << std::endl'
p3972
aS'                << "----------------------------------------------------"'
p3973
aS'                << std::endl;'
p3974
aS'      return 1;'
p3975
aS'    }'
p3976
aS'  catch (...)'
p3977
aS'    {'
p3978
aS'      std::cerr << std::endl'
p3979
aS'                << std::endl'
p3980
aS'                << "----------------------------------------------------"'
p3981
aS'                << std::endl;'
p3982
aS'      std::cerr << "Unknown exception!" << std::endl'
p3983
aS'                << "Aborting!" << std::endl'
p3984
aS'                << "----------------------------------------------------"'
p3985
aS'                << std::endl;'
p3986
aS'      return 1;'
p3987
aS'    }'
p3988
aS'  return 0;'
p3989
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p3990
aS'#include <deal.II/base/function.h>'
p3991
aS'#include <deal.II/base/logstream.h>'
p3992
aS'#include <deal.II/base/utilities.h>'
p3993
aS'#include <deal.II/lac/affine_constraints.h>'
p3994
aS'#include <deal.II/lac/vector.h>'
p3995
aS'#include <deal.II/lac/full_matrix.h>'
p3996
aS'#include <deal.II/lac/sparse_matrix.h>'
p3997
aS'#include <deal.II/lac/solver_cg.h>'
p3998
aS'#include <deal.II/lac/precondition.h>'
p3999
aS'#include <deal.II/grid/tria.h>'
p4000
aS'#include <deal.II/grid/grid_generator.h>'
p4001
aS'#include <deal.II/grid/grid_refinement.h>'
p4002
aS'#include <deal.II/dofs/dof_tools.h>'
p4003
aS'#include <deal.II/fe/fe_q.h>'
p4004
aS'#include <deal.II/fe/fe_values.h>'
p4005
aS'#include <deal.II/numerics/vector_tools.h>'
p4006
aS'#include <deal.II/numerics/data_out.h>'
p4007
aS'#include <deal.II/numerics/error_estimator.h>'
p4008
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p4009
aS'#include <deal.II/multigrid/multigrid.h>'
p4010
aS'#include <deal.II/multigrid/mg_transfer.h>'
p4011
aS'#include <deal.II/multigrid/mg_tools.h>'
p4012
aS'#include <deal.II/multigrid/mg_coarse.h>'
p4013
aS'#include <deal.II/multigrid/mg_smoother.h>'
p4014
aS'#include <deal.II/multigrid/mg_matrix.h>'
p4015
aS'#include <deal.II/meshworker/dof_info.h>'
p4016
aS'#include <deal.II/meshworker/integration_info.h>'
p4017
aS'#include <deal.II/meshworker/simple.h>'
p4018
aS'#include <deal.II/meshworker/output.h>'
p4019
aS'#include <deal.II/meshworker/loop.h>'
p4020
aS'#include <deal.II/integrators/laplace.h>'
p4021
aS'#include <deal.II/integrators/l2.h>'
p4022
aS'#include <iostream>'
p4023
aS'#include <fstream>'
p4024
aS'using namespace dealii;'
p4025
aS'namespace Step16'
p4026
ag9
aS'  template <int dim>'
p4027
aS'  class LaplaceIntegrator : public MeshWorker::LocalIntegrator<dim>'
p4028
aS'  {'
p4029
aS'  public:'
p4030
aS'    LaplaceIntegrator();'
p4031
aS'    virtual void cell(MeshWorker::DoFInfo<dim> &        dinfo,'
p4032
aS'                      MeshWorker::IntegrationInfo<dim> &info) const override;'
p4033
aS'  };'
p4034
aS'  template <int dim>'
p4035
aS'  LaplaceIntegrator<dim>::LaplaceIntegrator()'
p4036
aS'    : MeshWorker::LocalIntegrator<dim>(true, false, false)'
p4037
aS'  {}'
p4038
aS'  template <int dim>'
p4039
aS'  void'
p4040
aS'  LaplaceIntegrator<dim>::cell(MeshWorker::DoFInfo<dim> &        dinfo,'
p4041
aS'                               MeshWorker::IntegrationInfo<dim> &info) const'
p4042
aS'  {'
p4043
aS'    AssertDimension(dinfo.n_matrices(), 1);'
p4044
aS'    const double coefficient = (dinfo.cell->center()(0) > 0.) ? .1 : 1.;'
p4045
aS'    LocalIntegrators::Laplace::cell_matrix(dinfo.matrix(0, false).matrix,'
p4046
aS'                                           info.fe_values(0),'
p4047
aS'                                           coefficient);'
p4048
aS'    if (dinfo.n_vectors() > 0)'
p4049
aS'      {'
p4050
aS'        std::vector<double> rhs(info.fe_values(0).n_quadrature_points, 1.);'
p4051
aS'        LocalIntegrators::L2::L2(dinfo.vector(0).block(0),'
p4052
aS'                                 info.fe_values(0),'
p4053
aS'                                 rhs);'
p4054
aS'      }'
p4055
aS'  }'
p4056
aS'  template <int dim>'
p4057
aS'  class LaplaceProblem'
p4058
aS'  {'
p4059
aS'  public:'
p4060
aS'    LaplaceProblem(const unsigned int degree);'
p4061
aS'    void run();'
p4062
aS'  private:'
p4063
aS'    void setup_system();'
p4064
aS'    void assemble_system();'
p4065
aS'    void assemble_multigrid();'
p4066
aS'    void solve();'
p4067
aS'    void refine_grid();'
p4068
aS'    void output_results(const unsigned int cycle) const;'
p4069
aS'    Triangulation<dim> triangulation;'
p4070
aS'    FE_Q<dim>          fe;'
p4071
aS'    DoFHandler<dim>    dof_handler;'
p4072
aS'    SparsityPattern      sparsity_pattern;'
p4073
aS'    SparseMatrix<double> system_matrix;'
p4074
aS'    AffineConstraints<double> constraints;'
p4075
aS'    Vector<double> solution;'
p4076
aS'    Vector<double> system_rhs;'
p4077
aS'    const unsigned int degree;'
p4078
aS'    MGLevelObject<SparsityPattern>      mg_sparsity_patterns;'
p4079
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p4080
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_in;'
p4081
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_out;'
p4082
aS'    MGConstrainedDoFs                   mg_constrained_dofs;'
p4083
aS'  };'
p4084
aS'  template <int dim>'
p4085
aS'  LaplaceProblem<dim>::LaplaceProblem(const unsigned int degree)'
p4086
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p4087
aS'    , fe(degree)'
p4088
aS'    , dof_handler(triangulation)'
p4089
aS'    , degree(degree)'
p4090
aS'  {}'
p4091
aS'  template <int dim>'
p4092
aS'  void LaplaceProblem<dim>::setup_system()'
p4093
aS'  {'
p4094
aS'    dof_handler.distribute_dofs(fe);'
p4095
aS'    dof_handler.distribute_mg_dofs();'
p4096
aS'    deallog << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p4097
aS'            << " (by level: ";'
p4098
aS'    for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p4099
aS'      deallog << dof_handler.n_dofs(level)'
p4100
aS'              << (level == triangulation.n_levels() - 1 ? ")" : ", ");'
p4101
aS'    deallog << std::endl;'
p4102
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p4103
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p4104
aS'    solution.reinit(dof_handler.n_dofs());'
p4105
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p4106
aS'    constraints.clear();'
p4107
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p4108
aS'    std::set<types::boundary_id> dirichlet_boundary_ids = {0};'
p4109
aS'    Functions::ZeroFunction<dim> homogeneous_dirichlet_bc;'
p4110
aS'    const std::map<types::boundary_id, const Function<dim> *>'
p4111
aS'      dirichlet_boundary_functions = {'
p4112
aS'        {types::boundary_id(0), &homogeneous_dirichlet_bc}};'
p4113
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p4114
aS'                                             dirichlet_boundary_functions,'
p4115
aS'                                             constraints);'
p4116
aS'    constraints.close();'
p4117
aS'    constraints.condense(dsp);'
p4118
aS'    sparsity_pattern.copy_from(dsp);'
p4119
aS'    system_matrix.reinit(sparsity_pattern);'
p4120
aS'    mg_constrained_dofs.clear();'
p4121
aS'    mg_constrained_dofs.initialize(dof_handler);'
p4122
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p4123
aS'                                                       dirichlet_boundary_ids);'
p4124
aS'    const unsigned int n_levels = triangulation.n_levels();'
p4125
aS'    mg_interface_in.resize(0, n_levels - 1);'
p4126
aS'    mg_interface_in.clear_elements();'
p4127
aS'    mg_interface_out.resize(0, n_levels - 1);'
p4128
aS'    mg_interface_out.clear_elements();'
p4129
aS'    mg_matrices.resize(0, n_levels - 1);'
p4130
aS'    mg_matrices.clear_elements();'
p4131
aS'    mg_sparsity_patterns.resize(0, n_levels - 1);'
p4132
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p4133
aS'      {'
p4134
aS'        DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p4135
aS'                                   dof_handler.n_dofs(level));'
p4136
aS'        MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p4137
aS'        mg_sparsity_patterns[level].copy_from(dsp);'
p4138
aS'        mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p4139
aS'        mg_interface_in[level].reinit(mg_sparsity_patterns[level]);'
p4140
aS'        mg_interface_out[level].reinit(mg_sparsity_patterns[level]);'
p4141
aS'      }'
p4142
aS'  }'
p4143
aS'  template <int dim>'
p4144
aS'  void LaplaceProblem<dim>::assemble_system()'
p4145
aS'  {'
p4146
aS'    MappingQ1<dim>                      mapping;'
p4147
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p4148
aS'    UpdateFlags                         update_flags ='
p4149
aS'      update_values | update_gradients | update_hessians;'
p4150
aS'    info_box.add_update_flags_all(update_flags);'
p4151
aS'    info_box.initialize(fe, mapping);'
p4152
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p4153
aS'    MeshWorker::Assembler::SystemSimple<SparseMatrix<double>, Vector<double>>'
p4154
aS'      assembler;'
p4155
aS'    assembler.initialize(constraints);'
p4156
aS'    assembler.initialize(system_matrix, system_rhs);'
p4157
aS'    LaplaceIntegrator<dim> matrix_integrator;'
p4158
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p4159
aS'                                           dof_handler.end(),'
p4160
aS'                                           dof_info,'
p4161
aS'                                           info_box,'
p4162
aS'                                           matrix_integrator,'
p4163
aS'                                           assembler);'
p4164
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p4165
aS'      if (constraints.is_constrained(i))'
p4166
aS'        system_matrix.set(i, i, 1.);'
p4167
aS'  }'
p4168
aS'  template <int dim>'
p4169
aS'  void LaplaceProblem<dim>::assemble_multigrid()'
p4170
aS'  {'
p4171
aS'    MappingQ1<dim>                      mapping;'
p4172
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p4173
aS'    UpdateFlags                         update_flags ='
p4174
aS'      update_values | update_gradients | update_hessians;'
p4175
aS'    info_box.add_update_flags_all(update_flags);'
p4176
aS'    info_box.initialize(fe, mapping);'
p4177
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p4178
aS'    MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler;'
p4179
aS'    assembler.initialize(mg_constrained_dofs);'
p4180
aS'    assembler.initialize(mg_matrices);'
p4181
aS'    assembler.initialize_interfaces(mg_interface_in, mg_interface_out);'
p4182
aS'    LaplaceIntegrator<dim> matrix_integrator;'
p4183
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_mg(),'
p4184
aS'                                           dof_handler.end_mg(),'
p4185
aS'                                           dof_info,'
p4186
aS'                                           info_box,'
p4187
aS'                                           matrix_integrator,'
p4188
aS'                                           assembler);'
p4189
aS'    const unsigned int nlevels = triangulation.n_levels();'
p4190
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p4191
aS'      {'
p4192
aS'        for (unsigned int i = 0; i < dof_handler.n_dofs(level); ++i)'
p4193
aS'          if (mg_constrained_dofs.is_boundary_index(level, i) ||'
p4194
aS'              mg_constrained_dofs.at_refinement_edge(level, i))'
p4195
aS'            mg_matrices[level].set(i, i, 1.);'
p4196
aS'      }'
p4197
aS'  }'
p4198
aS'  template <int dim>'
p4199
aS'  void LaplaceProblem<dim>::solve()'
p4200
aS'  {'
p4201
aS'    MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);'
p4202
aS'    mg_transfer.build(dof_handler);'
p4203
aS'    FullMatrix<double> coarse_matrix;'
p4204
aS'    coarse_matrix.copy_from(mg_matrices[0]);'
p4205
aS'    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p4206
aS'    coarse_grid_solver.initialize(coarse_matrix);'
p4207
aS'    using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p4208
aS'    mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;'
p4209
aS'    mg_smoother.initialize(mg_matrices);'
p4210
aS'    mg_smoother.set_steps(2);'
p4211
aS'    mg_smoother.set_symmetric(true);'
p4212
aS'    mg::Matrix<Vector<double>> mg_matrix(mg_matrices);'
p4213
aS'    mg::Matrix<Vector<double>> mg_interface_up(mg_interface_in);'
p4214
aS'    mg::Matrix<Vector<double>> mg_interface_down(mg_interface_out);'
p4215
aS'    Multigrid<Vector<double>> mg('
p4216
aS'      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);'
p4217
aS'    mg.set_edge_matrices(mg_interface_down, mg_interface_up);'
p4218
aS'    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p4219
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p4220
aS'    SolverControl            solver_control(1000, 1e-12);'
p4221
aS'    SolverCG<Vector<double>> solver(solver_control);'
p4222
aS'    solution = 0;'
p4223
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p4224
aS'    constraints.distribute(solution);'
p4225
aS'  }'
p4226
aS'  template <int dim>'
p4227
aS'  void LaplaceProblem<dim>::refine_grid()'
p4228
aS'  {'
p4229
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p4230
aS'    KellyErrorEstimator<dim>::estimate('
p4231
aS'      dof_handler,'
p4232
aS'      QGauss<dim - 1>(fe.degree + 1),'
p4233
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p4234
aS'      solution,'
p4235
aS'      estimated_error_per_cell);'
p4236
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p4237
aS'                                                    estimated_error_per_cell,'
p4238
aS'                                                    0.3,'
p4239
aS'                                                    0.03);'
p4240
aS'    triangulation.execute_coarsening_and_refinement();'
p4241
aS'  }'
p4242
aS'  template <int dim>'
p4243
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p4244
aS'  {'
p4245
aS'    DataOut<dim> data_out;'
p4246
aS'    data_out.attach_dof_handler(dof_handler);'
p4247
aS'    data_out.add_data_vector(solution, "solution");'
p4248
aS'    data_out.build_patches();'
p4249
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p4250
aS'    data_out.write_vtk(output);'
p4251
aS'  }'
p4252
aS'  template <int dim>'
p4253
aS'  void LaplaceProblem<dim>::run()'
p4254
aS'  {'
p4255
aS'    for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p4256
aS'      {'
p4257
aS'        deallog << "Cycle " << cycle << std::endl;'
p4258
aS'        if (cycle == 0)'
p4259
aS'          {'
p4260
aS'            GridGenerator::hyper_ball(triangulation);'
p4261
aS'            triangulation.refine_global(1);'
p4262
aS'          }'
p4263
aS'        else'
p4264
aS'          refine_grid();'
p4265
aS'        deallog << "   Number of active cells:       "'
p4266
aS'                << triangulation.n_active_cells() << std::endl;'
p4267
aS'        setup_system();'
p4268
aS'        assemble_system();'
p4269
aS'        assemble_multigrid();'
p4270
aS'        solve();'
p4271
aS'        output_results(cycle);'
p4272
aS'      }'
p4273
aS'  }'
p4274
aS'} // namespace Step16'
p4275
aS'int main()'
p4276
ag9
aS'  try'
p4277
aS'    {'
p4278
aS'      using namespace Step16;'
p4279
aS'      deallog.depth_console(2);'
p4280
aS'      LaplaceProblem<2> laplace_problem(1);'
p4281
aS'      laplace_problem.run();'
p4282
aS'    }'
p4283
aS'  catch (std::exception &exc)'
p4284
aS'    {'
p4285
aS'      std::cerr << std::endl'
p4286
aS'                << std::endl'
p4287
aS'                << "----------------------------------------------------"'
p4288
aS'                << std::endl;'
p4289
aS'      std::cerr << "Exception on processing: " << std::endl'
p4290
aS'                << exc.what() << std::endl'
p4291
aS'                << "Aborting!" << std::endl'
p4292
aS'                << "----------------------------------------------------"'
p4293
aS'                << std::endl;'
p4294
aS'      return 1;'
p4295
aS'    }'
p4296
aS'  catch (...)'
p4297
aS'    {'
p4298
aS'      std::cerr << std::endl'
p4299
aS'                << std::endl'
p4300
aS'                << "----------------------------------------------------"'
p4301
aS'                << std::endl;'
p4302
aS'      std::cerr << "Unknown exception!" << std::endl'
p4303
aS'                << "Aborting!" << std::endl'
p4304
aS'                << "----------------------------------------------------"'
p4305
aS'                << std::endl;'
p4306
aS'      return 1;'
p4307
aS'    }'
p4308
aS'  return 0;'
p4309
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p4310
aS'#include <deal.II/base/function.h>'
p4311
aS'#include <deal.II/base/logstream.h>'
p4312
aS'#include <deal.II/base/multithread_info.h>'
p4313
aS'#include <deal.II/lac/vector.h>'
p4314
aS'#include <deal.II/lac/full_matrix.h>'
p4315
aS'#include <deal.II/lac/affine_constraints.h>'
p4316
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p4317
aS'#include <deal.II/lac/sparsity_tools.h>'
p4318
aS'#include <deal.II/grid/tria.h>'
p4319
aS'#include <deal.II/grid/grid_generator.h>'
p4320
aS'#include <deal.II/grid/grid_refinement.h>'
p4321
aS'#include <deal.II/dofs/dof_handler.h>'
p4322
aS'#include <deal.II/dofs/dof_tools.h>'
p4323
aS'#include <deal.II/fe/fe_values.h>'
p4324
aS'#include <deal.II/fe/fe_system.h>'
p4325
aS'#include <deal.II/fe/fe_q.h>'
p4326
aS'#include <deal.II/numerics/vector_tools.h>'
p4327
aS'#include <deal.II/numerics/matrix_tools.h>'
p4328
aS'#include <deal.II/numerics/data_out.h>'
p4329
aS'#include <deal.II/numerics/error_estimator.h>'
p4330
aS'#include <deal.II/base/conditional_ostream.h>'
p4331
aS'#include <deal.II/base/mpi.h>'
p4332
aS'#include <deal.II/lac/petsc_vector.h>'
p4333
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p4334
aS'#include <deal.II/lac/petsc_solver.h>'
p4335
aS'#include <deal.II/lac/petsc_precondition.h>'
p4336
aS'#include <deal.II/grid/grid_tools.h>'
p4337
aS'#include <deal.II/dofs/dof_renumbering.h>'
p4338
aS'#include <fstream>'
p4339
aS'#include <iostream>'
p4340
aS'namespace Step17'
p4341
ag9
aS'  using namespace dealii;'
p4342
aS'  template <int dim>'
p4343
aS'  class ElasticProblem'
p4344
aS'  {'
p4345
aS'  public:'
p4346
aS'    ElasticProblem();'
p4347
aS'    void run();'
p4348
aS'  private:'
p4349
aS'    void         setup_system();'
p4350
aS'    void         assemble_system();'
p4351
aS'    unsigned int solve();'
p4352
aS'    void         refine_grid();'
p4353
aS'    void         output_results(const unsigned int cycle) const;'
p4354
aS'    MPI_Comm mpi_communicator;'
p4355
aS'    const unsigned int n_mpi_processes;'
p4356
aS'    const unsigned int this_mpi_process;'
p4357
aS'    ConditionalOStream pcout;'
p4358
aS'    Triangulation<dim> triangulation;'
p4359
aS'    FESystem<dim>      fe;'
p4360
aS'    DoFHandler<dim>    dof_handler;'
p4361
aS'    AffineConstraints<double> hanging_node_constraints;'
p4362
aS'    PETScWrappers::MPI::SparseMatrix system_matrix;'
p4363
aS'    PETScWrappers::MPI::Vector solution;'
p4364
aS'    PETScWrappers::MPI::Vector system_rhs;'
p4365
aS'  };'
p4366
aS'  template <int dim>'
p4367
aS'  class RightHandSide : public Function<dim>'
p4368
aS'  {'
p4369
aS'  public:'
p4370
aS'    virtual void vector_value(const Point<dim> &p,'
p4371
aS'                              Vector<double> &  values) const override'
p4372
aS'    {'
p4373
aS'      Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim));'
p4374
aS'      Assert(dim >= 2, ExcInternalError());'
p4375
aS'      Point<dim> point_1, point_2;'
p4376
aS'      point_1(0) = 0.5;'
p4377
aS'      point_2(0) = -0.5;'
p4378
aS'      if (((p - point_1).norm_square() < 0.2 * 0.2) ||'
p4379
aS'        values(0) = 1;'
p4380
aS'      else'
p4381
aS'        values(0) = 0;'
p4382
aS'      if (p.square() < 0.2 * 0.2)'
p4383
aS'        values(1) = 1;'
p4384
aS'      else'
p4385
aS'        values(1) = 0;'
p4386
aS'    }'
p4387
aS'    virtual void'
p4388
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p4389
aS'                      std::vector<Vector<double>> &  value_list) const override'
p4390
aS'    {'
p4391
aS'      const unsigned int n_points = points.size();'
p4392
aS'      Assert(value_list.size() == n_points,'
p4393
aS'             ExcDimensionMismatch(value_list.size(), n_points));'
p4394
aS'      for (unsigned int p = 0; p < n_points; ++p)'
p4395
aS'        RightHandSide<dim>::vector_value(points[p], value_list[p]);'
p4396
aS'    }'
p4397
aS'  };'
p4398
aS'  template <int dim>'
p4399
aS'  ElasticProblem<dim>::ElasticProblem()'
p4400
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p4401
aS'    , n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator))'
p4402
aS'    , this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator))'
p4403
aS'    , pcout(std::cout, (this_mpi_process == 0))'
p4404
aS'    , fe(FE_Q<dim>(1), dim)'
p4405
aS'    , dof_handler(triangulation)'
p4406
aS'  {}'
p4407
aS'  template <int dim>'
p4408
aS'  void ElasticProblem<dim>::setup_system()'
p4409
aS'  {'
p4410
aS'    GridTools::partition_triangulation(n_mpi_processes, triangulation);'
p4411
aS'    dof_handler.distribute_dofs(fe);'
p4412
aS'    DoFRenumbering::subdomain_wise(dof_handler);'
p4413
aS'    hanging_node_constraints.clear();'
p4414
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p4415
aS'                                            hanging_node_constraints);'
p4416
aS'    hanging_node_constraints.close();'
p4417
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p4418
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p4419
aS'                                    dsp,'
p4420
aS'                                    hanging_node_constraints,'
p4421
aS'                                    false);'
p4422
aS'    const std::vector<IndexSet> locally_owned_dofs_per_proc ='
p4423
aS'      DoFTools::locally_owned_dofs_per_subdomain(dof_handler);'
p4424
aS'    const IndexSet locally_owned_dofs ='
p4425
aS'      locally_owned_dofs_per_proc[this_mpi_process];'
p4426
aS'    system_matrix.reinit(locally_owned_dofs,'
p4427
aS'                         locally_owned_dofs,'
p4428
aS'                         dsp,'
p4429
aS'                         mpi_communicator);'
p4430
aS'    solution.reinit(locally_owned_dofs, mpi_communicator);'
p4431
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p4432
aS'  }'
p4433
aS'  template <int dim>'
p4434
aS'  void ElasticProblem<dim>::assemble_system()'
p4435
aS'  {'
p4436
aS'    QGauss<dim>   quadrature_formula(fe.degree + 1);'
p4437
aS'    FEValues<dim> fe_values(fe,'
p4438
aS'                            quadrature_formula,'
p4439
aS'                            update_values | update_gradients |'
p4440
aS'                              update_quadrature_points | update_JxW_values);'
p4441
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p4442
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p4443
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p4444
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p4445
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p4446
aS'    std::vector<double> lambda_values(n_q_points);'
p4447
aS'    std::vector<double> mu_values(n_q_points);'
p4448
aS'    Functions::ConstantFunction<dim> lambda(1.), mu(1.);'
p4449
aS'    RightHandSide<dim>          right_hand_side;'
p4450
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim));'
p4451
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p4452
aS'      if (cell->subdomain_id() == this_mpi_process)'
p4453
aS'        {'
p4454
aS'          cell_matrix = 0;'
p4455
aS'          cell_rhs    = 0;'
p4456
aS'          fe_values.reinit(cell);'
p4457
aS'          lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p4458
aS'          mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p4459
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p4460
aS'            {'
p4461
aS'              const unsigned int component_i ='
p4462
aS'                fe.system_to_component_index(i).first;'
p4463
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p4464
aS'                {'
p4465
aS'                  const unsigned int component_j ='
p4466
aS'                    fe.system_to_component_index(j).first;'
p4467
aS'                  for (unsigned int q_point = 0; q_point < n_q_points;'
p4468
aS'                       ++q_point)'
p4469
aS'                    {'
p4470
aS'                      cell_matrix(i, j) +='
p4471
aS'                          fe_values.shape_grad(j, q_point)[component_j] *'
p4472
aS'                          lambda_values[q_point]) +'
p4473
aS'                          fe_values.shape_grad(j, q_point)[component_i] *'
p4474
aS'                          mu_values[q_point]) +'
p4475
aS'                             fe_values.shape_grad(j, q_point) *'
p4476
aS'                             mu_values[q_point]) :'
p4477
aS'                            0)) *'
p4478
aS'                        fe_values.JxW(q_point);'
p4479
aS'                    }'
p4480
aS'                }'
p4481
aS'            }'
p4482
aS'          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p4483
aS'                                            rhs_values);'
p4484
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p4485
aS'            {'
p4486
aS'              const unsigned int component_i ='
p4487
aS'                fe.system_to_component_index(i).first;'
p4488
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p4489
aS'                cell_rhs(i) += fe_values.shape_value(i, q_point) *'
p4490
aS'                               rhs_values[q_point](component_i) *'
p4491
aS'                               fe_values.JxW(q_point);'
p4492
aS'            }'
p4493
aS'          cell->get_dof_indices(local_dof_indices);'
p4494
aS'          hanging_node_constraints.distribute_local_to_global(cell_matrix,'
p4495
aS'                                                              cell_rhs,'
p4496
aS'                                                              local_dof_indices,'
p4497
aS'                                                              system_matrix,'
p4498
aS'                                                              system_rhs);'
p4499
aS'        }'
p4500
aS'    system_matrix.compress(VectorOperation::add);'
p4501
aS'    system_rhs.compress(VectorOperation::add);'
p4502
aS'    std::map<types::global_dof_index, double> boundary_values;'
p4503
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p4504
aS'                                             0,'
p4505
aS'                                             Functions::ZeroFunction<dim>(dim),'
p4506
aS'                                             boundary_values);'
p4507
aS'    MatrixTools::apply_boundary_values('
p4508
aS'      boundary_values, system_matrix, solution, system_rhs, false);'
p4509
aS'  }'
p4510
aS'  template <int dim>'
p4511
aS'  unsigned int ElasticProblem<dim>::solve()'
p4512
aS'  {'
p4513
aS'    SolverControl solver_control(solution.size(), 1e-8 * system_rhs.l2_norm());'
p4514
aS'    PETScWrappers::SolverCG cg(solver_control, mpi_communicator);'
p4515
aS'    PETScWrappers::PreconditionBlockJacobi preconditioner(system_matrix);'
p4516
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p4517
aS'    Vector<double> localized_solution(solution);'
p4518
aS'    hanging_node_constraints.distribute(localized_solution);'
p4519
aS'    solution = localized_solution;'
p4520
aS'    return solver_control.last_step();'
p4521
aS'  }'
p4522
aS'  template <int dim>'
p4523
aS'  void ElasticProblem<dim>::refine_grid()'
p4524
aS'  {'
p4525
aS'    const Vector<double> localized_solution(solution);'
p4526
aS'    Vector<float> local_error_per_cell(triangulation.n_active_cells());'
p4527
aS'    KellyErrorEstimator<dim>::estimate(dof_handler,'
p4528
aS'                                       QGauss<dim - 1>(fe.degree + 1),'
p4529
aS'                                       {},'
p4530
aS'                                       localized_solution,'
p4531
aS'                                       local_error_per_cell,'
p4532
aS'                                       ComponentMask(),'
p4533
aS'                                       nullptr,'
p4534
aS'                                       MultithreadInfo::n_threads(),'
p4535
aS'                                       this_mpi_process);'
p4536
aS'    const unsigned int n_local_cells ='
p4537
aS'      GridTools::count_cells_with_subdomain_association(triangulation,'
p4538
aS'                                                        this_mpi_process);'
p4539
aS'    PETScWrappers::MPI::Vector distributed_all_errors('
p4540
aS'      mpi_communicator, triangulation.n_active_cells(), n_local_cells);'
p4541
aS'    for (unsigned int i = 0; i < local_error_per_cell.size(); ++i)'
p4542
aS'      if (local_error_per_cell(i) != 0)'
p4543
aS'        distributed_all_errors(i) = local_error_per_cell(i);'
p4544
aS'    distributed_all_errors.compress(VectorOperation::insert);'
p4545
aS'    const Vector<float> localized_all_errors(distributed_all_errors);'
p4546
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p4547
aS'                                                    localized_all_errors,'
p4548
aS'                                                    0.3,'
p4549
aS'                                                    0.03);'
p4550
aS'    triangulation.execute_coarsening_and_refinement();'
p4551
aS'  }'
p4552
aS'  template <int dim>'
p4553
aS'  void ElasticProblem<dim>::output_results(const unsigned int cycle) const'
p4554
aS'  {'
p4555
aS'    const Vector<double> localized_solution(solution);'
p4556
aS'    if (this_mpi_process == 0)'
p4557
aS'      {'
p4558
aS'        std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p4559
aS'        DataOut<dim> data_out;'
p4560
aS'        data_out.attach_dof_handler(dof_handler);'
p4561
aS'        std::vector<std::string> solution_names;'
p4562
aS'        switch (dim)'
p4563
aS'          {'
p4564
aS'            case 1:'
p4565
aS'              solution_names.emplace_back("displacement");'
p4566
aS'              break;'
p4567
aS'            case 2:'
p4568
aS'              solution_names.emplace_back("x_displacement");'
p4569
aS'              solution_names.emplace_back("y_displacement");'
p4570
aS'              break;'
p4571
aS'            case 3:'
p4572
aS'              solution_names.emplace_back("x_displacement");'
p4573
aS'              solution_names.emplace_back("y_displacement");'
p4574
aS'              solution_names.emplace_back("z_displacement");'
p4575
aS'              break;'
p4576
aS'            default:'
p4577
aS'              Assert(false, ExcInternalError());'
p4578
aS'          }'
p4579
aS'        data_out.add_data_vector(localized_solution, solution_names);'
p4580
aS'        std::vector<unsigned int> partition_int(triangulation.n_active_cells());'
p4581
aS'        GridTools::get_subdomain_association(triangulation, partition_int);'
p4582
aS'        const Vector<double> partitioning(partition_int.begin(),'
p4583
aS'                                          partition_int.end());'
p4584
aS'        data_out.add_data_vector(partitioning, "partitioning");'
p4585
aS'        data_out.build_patches();'
p4586
aS'        data_out.write_vtk(output);'
p4587
aS'      }'
p4588
aS'  }'
p4589
aS'  template <int dim>'
p4590
aS'  void ElasticProblem<dim>::run()'
p4591
aS'  {'
p4592
aS'    for (unsigned int cycle = 0; cycle < 10; ++cycle)'
p4593
aS'      {'
p4594
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p4595
aS'        if (cycle == 0)'
p4596
aS'          {'
p4597
aS'            GridGenerator::hyper_cube(triangulation, -1, 1);'
p4598
aS'            triangulation.refine_global(3);'
p4599
aS'          }'
p4600
aS'        else'
p4601
aS'          refine_grid();'
p4602
aS'        pcout << "   Number of active cells:       "'
p4603
aS'              << triangulation.n_active_cells() << std::endl;'
p4604
aS'        setup_system();'
p4605
aS'        pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p4606
aS'              << " (by partition:";'
p4607
aS'        for (unsigned int p = 0; p < n_mpi_processes; ++p)'
p4608
aS"          pcout << (p == 0 ? ' ' : '+')"
p4609
aS'                << (DoFTools::count_dofs_with_subdomain_association(dof_handler,'
p4610
aS'                                                                    p));'
p4611
aS'        pcout << ")" << std::endl;'
p4612
aS'        assemble_system();'
p4613
aS'        const unsigned int n_iterations = solve();'
p4614
aS'        pcout << "   Solver converged in " << n_iterations << " iterations."'
p4615
aS'              << std::endl;'
p4616
aS'        output_results(cycle);'
p4617
aS'      }'
p4618
aS'  }'
p4619
aS'} // namespace Step17'
p4620
aS'int main(int argc, char **argv)'
p4621
ag9
aS'  try'
p4622
aS'    {'
p4623
aS'      using namespace dealii;'
p4624
aS'      using namespace Step17;'
p4625
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p4626
aS'      ElasticProblem<2> elastic_problem;'
p4627
aS'      elastic_problem.run();'
p4628
aS'    }'
p4629
aS'  catch (std::exception &exc)'
p4630
aS'    {'
p4631
aS'      std::cerr << std::endl'
p4632
aS'                << std::endl'
p4633
aS'                << "----------------------------------------------------"'
p4634
aS'                << std::endl;'
p4635
aS'      std::cerr << "Exception on processing: " << std::endl'
p4636
aS'                << exc.what() << std::endl'
p4637
aS'                << "Aborting!" << std::endl'
p4638
aS'                << "----------------------------------------------------"'
p4639
aS'                << std::endl;'
p4640
aS'      return 1;'
p4641
aS'    }'
p4642
aS'  catch (...)'
p4643
aS'    {'
p4644
aS'      std::cerr << std::endl'
p4645
aS'                << std::endl'
p4646
aS'                << "----------------------------------------------------"'
p4647
aS'                << std::endl;'
p4648
aS'      std::cerr << "Unknown exception!" << std::endl'
p4649
aS'                << "Aborting!" << std::endl'
p4650
aS'                << "----------------------------------------------------"'
p4651
aS'                << std::endl;'
p4652
aS'      return 1;'
p4653
aS'    }'
p4654
aS'  return 0;'
p4655
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p4656
aS'#include <deal.II/base/function.h>'
p4657
aS'#include <deal.II/base/logstream.h>'
p4658
aS'#include <deal.II/base/multithread_info.h>'
p4659
aS'#include <deal.II/base/conditional_ostream.h>'
p4660
aS'#include <deal.II/base/utilities.h>'
p4661
aS'#include <deal.II/lac/vector.h>'
p4662
aS'#include <deal.II/lac/full_matrix.h>'
p4663
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p4664
aS'#include <deal.II/lac/petsc_vector.h>'
p4665
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p4666
aS'#include <deal.II/lac/petsc_solver.h>'
p4667
aS'#include <deal.II/lac/petsc_precondition.h>'
p4668
aS'#include <deal.II/lac/affine_constraints.h>'
p4669
aS'#include <deal.II/lac/sparsity_tools.h>'
p4670
aS'#include <deal.II/distributed/shared_tria.h>'
p4671
aS'#include <deal.II/grid/tria.h>'
p4672
aS'#include <deal.II/grid/grid_generator.h>'
p4673
aS'#include <deal.II/grid/grid_refinement.h>'
p4674
aS'#include <deal.II/grid/manifold_lib.h>'
p4675
aS'#include <deal.II/grid/grid_tools.h>'
p4676
aS'#include <deal.II/dofs/dof_handler.h>'
p4677
aS'#include <deal.II/dofs/dof_tools.h>'
p4678
aS'#include <deal.II/dofs/dof_renumbering.h>'
p4679
aS'#include <deal.II/fe/fe_values.h>'
p4680
aS'#include <deal.II/fe/fe_system.h>'
p4681
aS'#include <deal.II/fe/fe_q.h>'
p4682
aS'#include <deal.II/numerics/vector_tools.h>'
p4683
aS'#include <deal.II/numerics/matrix_tools.h>'
p4684
aS'#include <deal.II/numerics/data_out.h>'
p4685
aS'#include <deal.II/numerics/error_estimator.h>'
p4686
aS'#include <deal.II/base/symmetric_tensor.h>'
p4687
aS'#include <deal.II/physics/transformations.h>'
p4688
aS'#include <fstream>'
p4689
aS'#include <iostream>'
p4690
aS'#include <iomanip>'
p4691
aS'namespace Step18'
p4692
ag9
aS'  using namespace dealii;'
p4693
aS'  template <int dim>'
p4694
aS'  struct PointHistory'
p4695
aS'  {'
p4696
aS'    SymmetricTensor<2, dim> old_stress;'
p4697
aS'  };'
p4698
aS'  template <int dim>'
p4699
aS'  SymmetricTensor<4, dim> get_stress_strain_tensor(const double lambda,'
p4700
aS'                                                   const double mu)'
p4701
aS'  {'
p4702
aS'    SymmetricTensor<4, dim> tmp;'
p4703
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4704
aS'      for (unsigned int j = 0; j < dim; ++j)'
p4705
aS'        for (unsigned int k = 0; k < dim; ++k)'
p4706
aS'          for (unsigned int l = 0; l < dim; ++l)'
p4707
aS'            tmp[i][j][k][l] = (((i == k) && (j == l) ? mu : 0.0) +'
p4708
aS'    return tmp;'
p4709
aS'  }'
p4710
aS'  template <int dim>'
p4711
aS'  inline SymmetricTensor<2, dim> get_strain(const FEValues<dim> &fe_values,'
p4712
aS'                                            const unsigned int   shape_func,'
p4713
aS'                                            const unsigned int   q_point)'
p4714
aS'  {'
p4715
aS'    SymmetricTensor<2, dim> tmp;'
p4716
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4717
aS'      tmp[i][i] = fe_values.shape_grad_component(shape_func, q_point, i)[i];'
p4718
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4719
aS'      for (unsigned int j = i + 1; j < dim; ++j)'
p4720
aS'        tmp[i][j] ='
p4721
aS'           fe_values.shape_grad_component(shape_func, q_point, j)[i]) /'
p4722
aS'          2;'
p4723
aS'    return tmp;'
p4724
aS'  }'
p4725
aS'  template <int dim>'
p4726
aS'  inline SymmetricTensor<2, dim>'
p4727
aS'  get_strain(const std::vector<Tensor<1, dim>> &grad)'
p4728
aS'  {'
p4729
aS'    Assert(grad.size() == dim, ExcInternalError());'
p4730
aS'    SymmetricTensor<2, dim> strain;'
p4731
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4732
aS'      strain[i][i] = grad[i][i];'
p4733
aS'    for (unsigned int i = 0; i < dim; ++i)'
p4734
aS'      for (unsigned int j = i + 1; j < dim; ++j)'
p4735
aS'        strain[i][j] = (grad[i][j] + grad[j][i]) / 2;'
p4736
aS'    return strain;'
p4737
aS'  }'
p4738
aS'  Tensor<2, 2> get_rotation_matrix(const std::vector<Tensor<1, 2>> &grad_u)'
p4739
aS'  {'
p4740
aS'    const double curl = (grad_u[1][0] - grad_u[0][1]);'
p4741
aS'    const double angle = std::atan(curl);'
p4742
aS'    return Physics::Transformations::Rotations::rotation_matrix_2d(-angle);'
p4743
aS'  }'
p4744
aS'  Tensor<2, 3> get_rotation_matrix(const std::vector<Tensor<1, 3>> &grad_u)'
p4745
aS'  {'
p4746
aS'    const Point<3> curl(grad_u[2][1] - grad_u[1][2],'
p4747
aS'                        grad_u[0][2] - grad_u[2][0],'
p4748
aS'                        grad_u[1][0] - grad_u[0][1]);'
p4749
aS'    const double tan_angle = std::sqrt(curl * curl);'
p4750
aS'    const double angle     = std::atan(tan_angle);'
p4751
aS'    if (std::abs(angle) < 1e-9)'
p4752
aS'      {'
p4753
aS'        static const double rotation[3][3] = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};'
p4754
aS'        static const Tensor<2, 3> rot(rotation);'
p4755
aS'        return rot;'
p4756
aS'      }'
p4757
aS'    const Point<3> axis = curl / tan_angle;'
p4758
aS'    return Physics::Transformations::Rotations::rotation_matrix_3d(axis,'
p4759
aS'                                                                   -angle);'
p4760
aS'  }'
p4761
aS'  template <int dim>'
p4762
aS'  class TopLevel'
p4763
aS'  {'
p4764
aS'  public:'
p4765
aS'    TopLevel();'
p4766
aS'    ~TopLevel();'
p4767
aS'    void run();'
p4768
aS'  private:'
p4769
aS'    void create_coarse_grid();'
p4770
aS'    void setup_system();'
p4771
aS'    void assemble_system();'
p4772
aS'    void solve_timestep();'
p4773
aS'    unsigned int solve_linear_problem();'
p4774
aS'    void output_results() const;'
p4775
aS'    void do_initial_timestep();'
p4776
aS'    void do_timestep();'
p4777
aS'    void refine_initial_grid();'
p4778
aS'    void move_mesh();'
p4779
aS'    void setup_quadrature_point_history();'
p4780
aS'    void update_quadrature_point_history();'
p4781
aS'    parallel::shared::Triangulation<dim> triangulation;'
p4782
aS'    FESystem<dim> fe;'
p4783
aS'    DoFHandler<dim> dof_handler;'
p4784
aS'    AffineConstraints<double> hanging_node_constraints;'
p4785
aS'    const QGauss<dim> quadrature_formula;'
p4786
aS'    std::vector<PointHistory<dim>> quadrature_point_history;'
p4787
aS'    PETScWrappers::MPI::SparseMatrix system_matrix;'
p4788
aS'    PETScWrappers::MPI::Vector system_rhs;'
p4789
aS'    Vector<double> incremental_displacement;'
p4790
aS'    double       present_time;'
p4791
aS'    double       present_timestep;'
p4792
aS'    double       end_time;'
p4793
aS'    unsigned int timestep_no;'
p4794
aS'    MPI_Comm mpi_communicator;'
p4795
aS'    const unsigned int n_mpi_processes;'
p4796
aS'    const unsigned int this_mpi_process;'
p4797
aS'    ConditionalOStream pcout;'
p4798
aS'    IndexSet locally_owned_dofs;'
p4799
aS'    IndexSet locally_relevant_dofs;'
p4800
aS'    static const SymmetricTensor<4, dim> stress_strain_tensor;'
p4801
aS'  };'
p4802
aS'  template <int dim>'
p4803
aS'  class BodyForce : public Function<dim>'
p4804
aS'  {'
p4805
aS'  public:'
p4806
aS'    BodyForce();'
p4807
aS'    virtual void vector_value(const Point<dim> &p,'
p4808
aS'                              Vector<double> &  values) const override;'
p4809
aS'    virtual void'
p4810
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p4811
aS'                      std::vector<Vector<double>> &  value_list) const override;'
p4812
aS'  };'
p4813
aS'  template <int dim>'
p4814
aS'  BodyForce<dim>::BodyForce()'
p4815
aS'    : Function<dim>(dim)'
p4816
aS'  {}'
p4817
aS'  template <int dim>'
p4818
aS'  inline void BodyForce<dim>::vector_value(const Point<dim> & /*p*/,'
p4819
aS'                                           Vector<double> &values) const'
p4820
aS'  {'
p4821
aS'    Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim));'
p4822
aS'    const double g   = 9.81;'
p4823
aS'    const double rho = 7700;'
p4824
aS'    values          = 0;'
p4825
aS'    values(dim - 1) = -rho * g;'
p4826
aS'  }'
p4827
aS'  template <int dim>'
p4828
aS'  void BodyForce<dim>::vector_value_list('
p4829
aS'    const std::vector<Point<dim>> &points,'
p4830
aS'    std::vector<Vector<double>> &  value_list) const'
p4831
aS'  {'
p4832
aS'    const unsigned int n_points = points.size();'
p4833
aS'    Assert(value_list.size() == n_points,'
p4834
aS'           ExcDimensionMismatch(value_list.size(), n_points));'
p4835
aS'    for (unsigned int p = 0; p < n_points; ++p)'
p4836
aS'      BodyForce<dim>::vector_value(points[p], value_list[p]);'
p4837
aS'  }'
p4838
aS'  template <int dim>'
p4839
aS'  class IncrementalBoundaryValues : public Function<dim>'
p4840
aS'  {'
p4841
aS'  public:'
p4842
aS'    IncrementalBoundaryValues(const double present_time,'
p4843
aS'                              const double present_timestep);'
p4844
aS'    virtual void vector_value(const Point<dim> &p,'
p4845
aS'                              Vector<double> &  values) const override;'
p4846
aS'    virtual void'
p4847
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p4848
aS'                      std::vector<Vector<double>> &  value_list) const override;'
p4849
aS'  private:'
p4850
aS'    const double velocity;'
p4851
aS'    const double present_time;'
p4852
aS'    const double present_timestep;'
p4853
aS'  };'
p4854
aS'  template <int dim>'
p4855
aS'  IncrementalBoundaryValues<dim>::IncrementalBoundaryValues('
p4856
aS'    const double present_time,'
p4857
aS'    const double present_timestep)'
p4858
aS'    : Function<dim>(dim)'
p4859
aS'    , velocity(.08)'
p4860
aS'    , present_time(present_time)'
p4861
aS'    , present_timestep(present_timestep)'
p4862
aS'  {}'
p4863
aS'  template <int dim>'
p4864
aS'  void'
p4865
aS'  IncrementalBoundaryValues<dim>::vector_value(const Point<dim> & /*p*/,'
p4866
aS'                                               Vector<double> &values) const'
p4867
aS'  {'
p4868
aS'    Assert(values.size() == dim, ExcDimensionMismatch(values.size(), dim));'
p4869
aS'    values    = 0;'
p4870
aS'    values(2) = -present_timestep * velocity;'
p4871
aS'  }'
p4872
aS'  template <int dim>'
p4873
aS'  void IncrementalBoundaryValues<dim>::vector_value_list('
p4874
aS'    const std::vector<Point<dim>> &points,'
p4875
aS'    std::vector<Vector<double>> &  value_list) const'
p4876
aS'  {'
p4877
aS'    const unsigned int n_points = points.size();'
p4878
aS'    Assert(value_list.size() == n_points,'
p4879
aS'           ExcDimensionMismatch(value_list.size(), n_points));'
p4880
aS'    for (unsigned int p = 0; p < n_points; ++p)'
p4881
aS'      IncrementalBoundaryValues<dim>::vector_value(points[p], value_list[p]);'
p4882
aS'  }'
p4883
aS'  template <int dim>'
p4884
aS'  const SymmetricTensor<4, dim> TopLevel<dim>::stress_strain_tensor ='
p4885
aS'    get_stress_strain_tensor<dim>(/*lambda = */ 9.695e10,'
p4886
aS'  template <int dim>'
p4887
aS'  TopLevel<dim>::TopLevel()'
p4888
aS'    : triangulation(MPI_COMM_WORLD)'
p4889
aS'    , fe(FE_Q<dim>(1), dim)'
p4890
aS'    , dof_handler(triangulation)'
p4891
aS'    , quadrature_formula(fe.degree + 1)'
p4892
aS'    , present_time(0.0)'
p4893
aS'    , present_timestep(1.0)'
p4894
aS'    , end_time(10.0)'
p4895
aS'    , timestep_no(0)'
p4896
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p4897
aS'    , n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator))'
p4898
aS'    , this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator))'
p4899
aS'    , pcout(std::cout, this_mpi_process == 0)'
p4900
aS'  {}'
p4901
aS'  template <int dim>'
p4902
aS'  TopLevel<dim>::~TopLevel()'
p4903
aS'  {'
p4904
aS'    dof_handler.clear();'
p4905
aS'  }'
p4906
aS'  template <int dim>'
p4907
aS'  void TopLevel<dim>::run()'
p4908
aS'  {'
p4909
aS'    do_initial_timestep();'
p4910
aS'    while (present_time < end_time)'
p4911
aS'      do_timestep();'
p4912
aS'  }'
p4913
aS'  template <int dim>'
p4914
aS'  void TopLevel<dim>::create_coarse_grid()'
p4915
aS'  {'
p4916
aS'    const double inner_radius = 0.8, outer_radius = 1;'
p4917
aS'    GridGenerator::cylinder_shell(triangulation, 3, inner_radius, outer_radius);'
p4918
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p4919
aS'      for (const auto &face : cell->face_iterators())'
p4920
aS'        if (face->at_boundary())'
p4921
aS'          {'
p4922
aS'            const Point<dim> face_center = face->center();'
p4923
aS'            if (face_center[2] == 0)'
p4924
aS'              face->set_boundary_id(0);'
p4925
aS'            else if (face_center[2] == 3)'
p4926
aS'              face->set_boundary_id(1);'
p4927
aS'            else if (std::sqrt(face_center[0] * face_center[0] +'
p4928
aS'                               face_center[1] * face_center[1]) <'
p4929
aS'              face->set_boundary_id(2);'
p4930
aS'            else'
p4931
aS'              face->set_boundary_id(3);'
p4932
aS'          }'
p4933
aS'    triangulation.refine_global(1);'
p4934
aS'    setup_quadrature_point_history();'
p4935
aS'  }'
p4936
aS'  template <int dim>'
p4937
aS'  void TopLevel<dim>::setup_system()'
p4938
aS'  {'
p4939
aS'    dof_handler.distribute_dofs(fe);'
p4940
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p4941
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p4942
aS'    hanging_node_constraints.clear();'
p4943
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p4944
aS'                                            hanging_node_constraints);'
p4945
aS'    hanging_node_constraints.close();'
p4946
aS'    DynamicSparsityPattern sparsity_pattern(locally_relevant_dofs);'
p4947
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p4948
aS'                                    sparsity_pattern,'
p4949
aS'                                    hanging_node_constraints,'
p4950
aS'    SparsityTools::distribute_sparsity_pattern(sparsity_pattern,'
p4951
aS'                                               locally_owned_dofs,'
p4952
aS'                                               mpi_communicator,'
p4953
aS'                                               locally_relevant_dofs);'
p4954
aS'    system_matrix.reinit(locally_owned_dofs,'
p4955
aS'                         locally_owned_dofs,'
p4956
aS'                         sparsity_pattern,'
p4957
aS'                         mpi_communicator);'
p4958
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p4959
aS'    incremental_displacement.reinit(dof_handler.n_dofs());'
p4960
aS'  }'
p4961
aS'  template <int dim>'
p4962
aS'  void TopLevel<dim>::assemble_system()'
p4963
aS'  {'
p4964
aS'    system_rhs    = 0;'
p4965
aS'    system_matrix = 0;'
p4966
aS'    FEValues<dim> fe_values(fe,'
p4967
aS'                            quadrature_formula,'
p4968
aS'                            update_values | update_gradients |'
p4969
aS'                              update_quadrature_points | update_JxW_values);'
p4970
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p4971
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p4972
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p4973
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p4974
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p4975
aS'    BodyForce<dim>              body_force;'
p4976
aS'    std::vector<Vector<double>> body_force_values(n_q_points,'
p4977
aS'                                                  Vector<double>(dim));'
p4978
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p4979
aS'      if (cell->is_locally_owned())'
p4980
aS'        {'
p4981
aS'          cell_matrix = 0;'
p4982
aS'          cell_rhs    = 0;'
p4983
aS'          fe_values.reinit(cell);'
p4984
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p4985
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p4986
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p4987
aS'                {'
p4988
aS'                  const SymmetricTensor<2, dim>'
p4989
aS'                    eps_phi_i = get_strain(fe_values, i, q_point),'
p4990
aS'                    eps_phi_j = get_strain(fe_values, j, q_point);'
p4991
aS'                  cell_matrix(i, j) += (eps_phi_i *            //'
p4992
aS'                                        stress_strain_tensor * //'
p4993
aS'                                        eps_phi_j              //'
p4994
aS'                                       fe_values.JxW(q_point); //'
p4995
aS'                }'
p4996
aS'          const PointHistory<dim> *local_quadrature_points_data ='
p4997
aS'            reinterpret_cast<PointHistory<dim> *>(cell->user_pointer());'
p4998
aS'          body_force.vector_value_list(fe_values.get_quadrature_points(),'
p4999
aS'                                       body_force_values);'
p5000
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p5001
aS'            {'
p5002
aS'              const unsigned int component_i ='
p5003
aS'                fe.system_to_component_index(i).first;'
p5004
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p5005
aS'                {'
p5006
aS'                  const SymmetricTensor<2, dim> &old_stress ='
p5007
aS'                    local_quadrature_points_data[q_point].old_stress;'
p5008
aS'                  cell_rhs(i) +='
p5009
aS'                       fe_values.shape_value(i, q_point) -'
p5010
aS'                     old_stress * get_strain(fe_values, i, q_point)) *'
p5011
aS'                    fe_values.JxW(q_point);'
p5012
aS'                }'
p5013
aS'            }'
p5014
aS'          cell->get_dof_indices(local_dof_indices);'
p5015
aS'          hanging_node_constraints.distribute_local_to_global(cell_matrix,'
p5016
aS'                                                              cell_rhs,'
p5017
aS'                                                              local_dof_indices,'
p5018
aS'                                                              system_matrix,'
p5019
aS'                                                              system_rhs);'
p5020
aS'        }'
p5021
aS'    system_matrix.compress(VectorOperation::add);'
p5022
aS'    system_rhs.compress(VectorOperation::add);'
p5023
aS'    FEValuesExtractors::Scalar                z_component(dim - 1);'
p5024
aS'    std::map<types::global_dof_index, double> boundary_values;'
p5025
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5026
aS'                                             0,'
p5027
aS'                                             Functions::ZeroFunction<dim>(dim),'
p5028
aS'                                             boundary_values);'
p5029
aS'    VectorTools::interpolate_boundary_values('
p5030
aS'      dof_handler,'
p5031
aS'      1,'
p5032
aS'      IncrementalBoundaryValues<dim>(present_time, present_timestep),'
p5033
aS'      boundary_values,'
p5034
aS'      fe.component_mask(z_component));'
p5035
aS'    PETScWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator);'
p5036
aS'    MatrixTools::apply_boundary_values('
p5037
aS'      boundary_values, system_matrix, tmp, system_rhs, false);'
p5038
aS'    incremental_displacement = tmp;'
p5039
aS'  }'
p5040
aS'  template <int dim>'
p5041
aS'  void TopLevel<dim>::solve_timestep()'
p5042
aS'  {'
p5043
aS'    pcout << "    Assembling system..." << std::flush;'
p5044
aS'    assemble_system();'
p5045
aS'    pcout << " norm of rhs is " << system_rhs.l2_norm() << std::endl;'
p5046
aS'    const unsigned int n_iterations = solve_linear_problem();'
p5047
aS'    pcout << "    Solver converged in " << n_iterations << " iterations."'
p5048
aS'          << std::endl;'
p5049
aS'    pcout << "    Updating quadrature point data..." << std::flush;'
p5050
aS'    update_quadrature_point_history();'
p5051
aS'    pcout << std::endl;'
p5052
aS'  }'
p5053
aS'  template <int dim>'
p5054
aS'  unsigned int TopLevel<dim>::solve_linear_problem()'
p5055
aS'  {'
p5056
aS'    PETScWrappers::MPI::Vector distributed_incremental_displacement('
p5057
aS'      locally_owned_dofs, mpi_communicator);'
p5058
aS'    distributed_incremental_displacement = incremental_displacement;'
p5059
aS'    SolverControl solver_control(dof_handler.n_dofs(),'
p5060
aS'                                 1e-16 * system_rhs.l2_norm());'
p5061
aS'    PETScWrappers::SolverCG cg(solver_control, mpi_communicator);'
p5062
aS'    PETScWrappers::PreconditionBlockJacobi preconditioner(system_matrix);'
p5063
aS'    cg.solve(system_matrix,'
p5064
aS'             distributed_incremental_displacement,'
p5065
aS'             system_rhs,'
p5066
aS'             preconditioner);'
p5067
aS'    incremental_displacement = distributed_incremental_displacement;'
p5068
aS'    hanging_node_constraints.distribute(incremental_displacement);'
p5069
aS'    return solver_control.last_step();'
p5070
aS'  }'
p5071
aS'  template <int dim>'
p5072
aS'  void TopLevel<dim>::output_results() const'
p5073
aS'  {'
p5074
aS'    DataOut<dim> data_out;'
p5075
aS'    data_out.attach_dof_handler(dof_handler);'
p5076
aS'    std::vector<std::string> solution_names;'
p5077
aS'    switch (dim)'
p5078
aS'      {'
p5079
aS'        case 1:'
p5080
aS'          solution_names.emplace_back("delta_x");'
p5081
aS'          break;'
p5082
aS'        case 2:'
p5083
aS'          solution_names.emplace_back("delta_x");'
p5084
aS'          solution_names.emplace_back("delta_y");'
p5085
aS'          break;'
p5086
aS'        case 3:'
p5087
aS'          solution_names.emplace_back("delta_x");'
p5088
aS'          solution_names.emplace_back("delta_y");'
p5089
aS'          solution_names.emplace_back("delta_z");'
p5090
aS'          break;'
p5091
aS'        default:'
p5092
aS'          Assert(false, ExcNotImplemented());'
p5093
aS'      }'
p5094
aS'    data_out.add_data_vector(incremental_displacement, solution_names);'
p5095
aS'    Vector<double> norm_of_stress(triangulation.n_active_cells());'
p5096
aS'    {'
p5097
aS'      for (auto &cell : triangulation.active_cell_iterators())'
p5098
aS'        if (cell->is_locally_owned())'
p5099
aS'          {'
p5100
aS'            SymmetricTensor<2, dim> accumulated_stress;'
p5101
aS'            for (unsigned int q = 0; q < quadrature_formula.size(); ++q)'
p5102
aS'              accumulated_stress +='
p5103
aS'                reinterpret_cast<PointHistory<dim> *>(cell->user_pointer())[q]'
p5104
aS'                  .old_stress;'
p5105
aS'            norm_of_stress(cell->active_cell_index()) ='
p5106
aS'          }'
p5107
aS'        else'
p5108
aS'          norm_of_stress(cell->active_cell_index()) = -1e+20;'
p5109
aS'    }'
p5110
aS'    data_out.add_data_vector(norm_of_stress, "norm_of_stress");'
p5111
aS'    std::vector<types::subdomain_id> partition_int('
p5112
aS'      triangulation.n_active_cells());'
p5113
aS'    GridTools::get_subdomain_association(triangulation, partition_int);'
p5114
aS'    const Vector<double> partitioning(partition_int.begin(),'
p5115
aS'                                      partition_int.end());'
p5116
aS'    data_out.add_data_vector(partitioning, "partitioning");'
p5117
aS'    data_out.build_patches();'
p5118
aS'    const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record('
p5119
aS'      "./", "solution", timestep_no, mpi_communicator, 4);'
p5120
aS'    if (this_mpi_process == 0)'
p5121
aS'      {'
p5122
aS'        static std::vector<std::pair<double, std::string>> times_and_names;'
p5123
aS'        times_and_names.push_back('
p5124
aS'          std::pair<double, std::string>(present_time, pvtu_filename));'
p5125
aS'        std::ofstream pvd_output("solution.pvd");'
p5126
aS'        DataOutBase::write_pvd_record(pvd_output, times_and_names);'
p5127
aS'      }'
p5128
aS'  }'
p5129
aS'  template <int dim>'
p5130
aS'  void TopLevel<dim>::do_initial_timestep()'
p5131
aS'  {'
p5132
aS'    present_time += present_timestep;'
p5133
aS'    ++timestep_no;'
p5134
aS'    pcout << "Timestep " << timestep_no << " at time " << present_time'
p5135
aS'          << std::endl;'
p5136
aS'    for (unsigned int cycle = 0; cycle < 2; ++cycle)'
p5137
aS'      {'
p5138
aS'        pcout << "  Cycle " << cycle << \':\' << std::endl;'
p5139
aS'        if (cycle == 0)'
p5140
aS'          create_coarse_grid();'
p5141
aS'        else'
p5142
aS'          refine_initial_grid();'
p5143
aS'        pcout << "    Number of active cells:       "'
p5144
aS'              << triangulation.n_active_cells() << " (by partition:";'
p5145
aS'        for (unsigned int p = 0; p < n_mpi_processes; ++p)'
p5146
aS"          pcout << (p == 0 ? ' ' : '+')"
p5147
aS'                << (GridTools::count_cells_with_subdomain_association('
p5148
aS'                     triangulation, p));'
p5149
aS'        pcout << ")" << std::endl;'
p5150
aS'        setup_system();'
p5151
aS'        pcout << "    Number of degrees of freedom: " << dof_handler.n_dofs()'
p5152
aS'              << " (by partition:";'
p5153
aS'        for (unsigned int p = 0; p < n_mpi_processes; ++p)'
p5154
aS"          pcout << (p == 0 ? ' ' : '+')"
p5155
aS'                << (DoFTools::count_dofs_with_subdomain_association(dof_handler,'
p5156
aS'                                                                    p));'
p5157
aS'        pcout << ")" << std::endl;'
p5158
aS'        solve_timestep();'
p5159
aS'      }'
p5160
aS'    move_mesh();'
p5161
aS'    output_results();'
p5162
aS'    pcout << std::endl;'
p5163
aS'  }'
p5164
aS'  template <int dim>'
p5165
aS'  void TopLevel<dim>::do_timestep()'
p5166
aS'  {'
p5167
aS'    present_time += present_timestep;'
p5168
aS'    ++timestep_no;'
p5169
aS'    pcout << "Timestep " << timestep_no << " at time " << present_time'
p5170
aS'          << std::endl;'
p5171
aS'    if (present_time > end_time)'
p5172
aS'      {'
p5173
aS'        present_timestep -= (present_time - end_time);'
p5174
aS'        present_time = end_time;'
p5175
aS'      }'
p5176
aS'    solve_timestep();'
p5177
aS'    move_mesh();'
p5178
aS'    output_results();'
p5179
aS'    pcout << std::endl;'
p5180
aS'  }'
p5181
aS'  template <int dim>'
p5182
aS'  void TopLevel<dim>::refine_initial_grid()'
p5183
aS'  {'
p5184
aS'    Vector<float> error_per_cell(triangulation.n_active_cells());'
p5185
aS'    KellyErrorEstimator<dim>::estimate('
p5186
aS'      dof_handler,'
p5187
aS'      QGauss<dim - 1>(fe.degree + 1),'
p5188
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p5189
aS'      incremental_displacement,'
p5190
aS'      error_per_cell,'
p5191
aS'      ComponentMask(),'
p5192
aS'      nullptr,'
p5193
aS'      MultithreadInfo::n_threads(),'
p5194
aS'      this_mpi_process);'
p5195
aS'    const unsigned int n_local_cells ='
p5196
aS'      triangulation.n_locally_owned_active_cells();'
p5197
aS'    PETScWrappers::MPI::Vector distributed_error_per_cell('
p5198
aS'      mpi_communicator, triangulation.n_active_cells(), n_local_cells);'
p5199
aS'    for (unsigned int i = 0; i < error_per_cell.size(); ++i)'
p5200
aS'      if (error_per_cell(i) != 0)'
p5201
aS'        distributed_error_per_cell(i) = error_per_cell(i);'
p5202
aS'    distributed_error_per_cell.compress(VectorOperation::insert);'
p5203
aS'    error_per_cell = distributed_error_per_cell;'
p5204
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p5205
aS'                                                    error_per_cell,'
p5206
aS'                                                    0.35,'
p5207
aS'                                                    0.03);'
p5208
aS'    triangulation.execute_coarsening_and_refinement();'
p5209
aS'    setup_quadrature_point_history();'
p5210
aS'  }'
p5211
aS'  template <int dim>'
p5212
aS'  void TopLevel<dim>::move_mesh()'
p5213
aS'  {'
p5214
aS'    pcout << "    Moving mesh..." << std::endl;'
p5215
aS'    std::vector<bool> vertex_touched(triangulation.n_vertices(), false);'
p5216
aS'    for (auto &cell : dof_handler.active_cell_iterators())'
p5217
aS'      for (const auto v : cell->vertex_indices())'
p5218
aS'        if (vertex_touched[cell->vertex_index(v)] == false)'
p5219
aS'          {'
p5220
aS'            vertex_touched[cell->vertex_index(v)] = true;'
p5221
aS'            Point<dim> vertex_displacement;'
p5222
aS'            for (unsigned int d = 0; d < dim; ++d)'
p5223
aS'              vertex_displacement[d] ='
p5224
aS'                incremental_displacement(cell->vertex_dof_index(v, d));'
p5225
aS'            cell->vertex(v) += vertex_displacement;'
p5226
aS'          }'
p5227
aS'  }'
p5228
aS'  template <int dim>'
p5229
aS'  void TopLevel<dim>::setup_quadrature_point_history()'
p5230
aS'  {'
p5231
aS'    triangulation.clear_user_data();'
p5232
aS'    {'
p5233
aS'      std::vector<PointHistory<dim>> tmp;'
p5234
aS'      quadrature_point_history.swap(tmp);'
p5235
aS'    }'
p5236
aS'    quadrature_point_history.resize('
p5237
aS'      triangulation.n_locally_owned_active_cells() * quadrature_formula.size());'
p5238
aS'    unsigned int history_index = 0;'
p5239
aS'    for (auto &cell : triangulation.active_cell_iterators())'
p5240
aS'      if (cell->is_locally_owned())'
p5241
aS'        {'
p5242
aS'          cell->set_user_pointer(&quadrature_point_history[history_index]);'
p5243
aS'          history_index += quadrature_formula.size();'
p5244
aS'        }'
p5245
aS'    Assert(history_index == quadrature_point_history.size(),'
p5246
aS'           ExcInternalError());'
p5247
aS'  }'
p5248
aS'  template <int dim>'
p5249
aS'  void TopLevel<dim>::update_quadrature_point_history()'
p5250
aS'  {'
p5251
aS'    FEValues<dim> fe_values(fe,'
p5252
aS'                            quadrature_formula,'
p5253
aS'                            update_values | update_gradients);'
p5254
aS'    std::vector<std::vector<Tensor<1, dim>>> displacement_increment_grads('
p5255
aS'      quadrature_formula.size(), std::vector<Tensor<1, dim>>(dim));'
p5256
aS'    for (auto &cell : dof_handler.active_cell_iterators())'
p5257
aS'      if (cell->is_locally_owned())'
p5258
aS'        {'
p5259
aS'          PointHistory<dim> *local_quadrature_points_history ='
p5260
aS'            reinterpret_cast<PointHistory<dim> *>(cell->user_pointer());'
p5261
aS'          Assert(local_quadrature_points_history >='
p5262
aS'                   &quadrature_point_history.front(),'
p5263
aS'                 ExcInternalError());'
p5264
aS'          Assert(local_quadrature_points_history <='
p5265
aS'                   &quadrature_point_history.back(),'
p5266
aS'                 ExcInternalError());'
p5267
aS'          fe_values.reinit(cell);'
p5268
aS'          fe_values.get_function_gradients(incremental_displacement,'
p5269
aS'                                           displacement_increment_grads);'
p5270
aS'          for (unsigned int q = 0; q < quadrature_formula.size(); ++q)'
p5271
aS'            {'
p5272
aS'              const SymmetricTensor<2, dim> new_stress ='
p5273
aS'                  get_strain(displacement_increment_grads[q])));'
p5274
aS'              const Tensor<2, dim> rotation ='
p5275
aS'                get_rotation_matrix(displacement_increment_grads[q]);'
p5276
aS'              const SymmetricTensor<2, dim> rotated_new_stress ='
p5277
aS'                symmetrize(transpose(rotation) *'
p5278
aS'                           static_cast<Tensor<2, dim>>(new_stress) * rotation);'
p5279
aS'              local_quadrature_points_history[q].old_stress ='
p5280
aS'                rotated_new_stress;'
p5281
aS'            }'
p5282
aS'        }'
p5283
aS'  }'
p5284
aS'} // namespace Step18'
p5285
aS'int main(int argc, char **argv)'
p5286
ag9
aS'  try'
p5287
aS'    {'
p5288
aS'      using namespace dealii;'
p5289
aS'      using namespace Step18;'
p5290
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p5291
aS'      TopLevel<3> elastic_problem;'
p5292
aS'      elastic_problem.run();'
p5293
aS'    }'
p5294
aS'  catch (std::exception &exc)'
p5295
aS'    {'
p5296
aS'      std::cerr << std::endl'
p5297
aS'                << std::endl'
p5298
aS'                << "----------------------------------------------------"'
p5299
aS'                << std::endl;'
p5300
aS'      std::cerr << "Exception on processing: " << std::endl'
p5301
aS'                << exc.what() << std::endl'
p5302
aS'                << "Aborting!" << std::endl'
p5303
aS'                << "----------------------------------------------------"'
p5304
aS'                << std::endl;'
p5305
aS'      return 1;'
p5306
aS'    }'
p5307
aS'  catch (...)'
p5308
aS'    {'
p5309
aS'      std::cerr << std::endl'
p5310
aS'                << std::endl'
p5311
aS'                << "----------------------------------------------------"'
p5312
aS'                << std::endl;'
p5313
aS'      std::cerr << "Unknown exception!" << std::endl'
p5314
aS'                << "Aborting!" << std::endl'
p5315
aS'                << "----------------------------------------------------"'
p5316
aS'                << std::endl;'
p5317
aS'      return 1;'
p5318
aS'    }'
p5319
aS'  return 0;'
p5320
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p5321
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p5322
aS'#include <deal.II/lac/full_matrix.h>'
p5323
aS'#include <deal.II/lac/precondition.h>'
p5324
aS'#include <deal.II/lac/solver_cg.h>'
p5325
aS'#include <deal.II/lac/sparse_matrix.h>'
p5326
aS'#include <deal.II/lac/vector.h>'
p5327
aS'#include <deal.II/lac/affine_constraints.h>'
p5328
aS'#include <deal.II/grid/tria.h>'
p5329
aS'#include <deal.II/grid/grid_refinement.h>'
p5330
aS'#include <deal.II/fe/mapping_q.h>'
p5331
aS'#include <deal.II/matrix_free/fe_point_evaluation.h>'
p5332
aS'#include <deal.II/fe/fe_q.h>'
p5333
aS'#include <deal.II/fe/fe_values.h>'
p5334
aS'#include <deal.II/dofs/dof_handler.h>'
p5335
aS'#include <deal.II/dofs/dof_tools.h>'
p5336
aS'#include <deal.II/numerics/data_out.h>'
p5337
aS'#include <deal.II/numerics/vector_tools.h>'
p5338
aS'#include <deal.II/numerics/error_estimator.h>'
p5339
aS'#include <deal.II/base/discrete_time.h>'
p5340
aS'#include <deal.II/particles/particle_handler.h>'
p5341
aS'#include <deal.II/particles/data_out.h>'
p5342
aS'#include <fstream>'
p5343
aS'using namespace dealii;'
p5344
aS'namespace Step19'
p5345
ag9
aS'  namespace BoundaryIds'
p5346
aS'  {'
p5347
aS'    constexpr types::boundary_id open          = 101;'
p5348
aS'    constexpr types::boundary_id cathode       = 102;'
p5349
aS'    constexpr types::boundary_id focus_element = 103;'
p5350
aS'    constexpr types::boundary_id anode         = 104;'
p5351
aS'  } // namespace BoundaryIds'
p5352
aS'  namespace Constants'
p5353
aS'  {'
p5354
aS'    constexpr double electron_mass   = 9.1093837015e-31;'
p5355
aS'    constexpr double electron_charge = 1.602176634e-19;'
p5356
aS'    constexpr double V0 = 1;'
p5357
aS'    constexpr double E_threshold = 0.05;'
p5358
aS'    constexpr double electrons_per_particle = 3e15;'
p5359
aS'  } // namespace Constants'
p5360
aS'  template <int dim>'
p5361
aS'  class CathodeRaySimulator'
p5362
aS'  {'
p5363
aS'  public:'
p5364
aS'    CathodeRaySimulator();'
p5365
aS'    void run();'
p5366
aS'  private:'
p5367
aS'    void make_grid();'
p5368
aS'    void setup_system();'
p5369
aS'    void assemble_system();'
p5370
aS'    void solve_field();'
p5371
aS'    void refine_grid();'
p5372
aS'    void create_particles();'
p5373
aS'    void move_particles();'
p5374
aS'    void track_lost_particle('
p5375
aS'      const typename Particles::ParticleIterator<dim> &        particle,'
p5376
aS'      const typename Triangulation<dim>::active_cell_iterator &cell);'
p5377
aS'    void update_timestep_size();'
p5378
aS'    void output_results() const;'
p5379
aS'    Triangulation<dim>        triangulation;'
p5380
aS'    MappingQGeneric<dim>      mapping;'
p5381
aS'    FE_Q<dim>                 fe;'
p5382
aS'    DoFHandler<dim>           dof_handler;'
p5383
aS'    AffineConstraints<double> constraints;'
p5384
aS'    SparseMatrix<double> system_matrix;'
p5385
aS'    SparsityPattern      sparsity_pattern;'
p5386
aS'    Vector<double> solution;'
p5387
aS'    Vector<double> system_rhs;'
p5388
aS'    Particles::ParticleHandler<dim> particle_handler;'
p5389
aS'    types::particle_index           next_unused_particle_id;'
p5390
aS'    types::particle_index           n_recently_lost_particles;'
p5391
aS'    types::particle_index           n_total_lost_particles;'
p5392
aS'    types::particle_index           n_particles_lost_through_anode;'
p5393
aS'    DiscreteTime time;'
p5394
aS'  };'
p5395
aS'  template <int dim>'
p5396
aS'  CathodeRaySimulator<dim>::CathodeRaySimulator()'
p5397
aS'    : mapping(1)'
p5398
aS'    , fe(2)'
p5399
aS'    , dof_handler(triangulation)'
p5400
aS'    , particle_handler(triangulation, mapping, /*n_properties=*/dim)'
p5401
aS'    , next_unused_particle_id(0)'
p5402
aS'    , n_recently_lost_particles(0)'
p5403
aS'    , n_total_lost_particles(0)'
p5404
aS'    , n_particles_lost_through_anode(0)'
p5405
aS'    , time(0, 1e-4)'
p5406
aS'  {'
p5407
aS'    particle_handler.signals.particle_lost.connect('
p5408
aS'      [this](const typename Particles::ParticleIterator<dim> &        particle,'
p5409
aS'             const typename Triangulation<dim>::active_cell_iterator &cell) {'
p5410
aS'        this->track_lost_particle(particle, cell);'
p5411
aS'      });'
p5412
aS'  }'
p5413
aS'  template <int dim>'
p5414
aS'  void CathodeRaySimulator<dim>::make_grid()'
p5415
aS'  {'
p5416
aS'    static_assert(dim == 2,'
p5417
aS'                  "This function is currently only implemented for 2d.");'
p5418
aS'    const double       delta = 0.5;'
p5419
aS'    const unsigned int nx    = 5;'
p5420
aS'    const unsigned int ny    = 3;'
p5421
aS'    const std::vector<Point<dim>> vertices //'
p5422
aS'      = {{0, 0},'
p5423
aS'         {1, 0},'
p5424
aS'         {2, 0},'
p5425
aS'         {3, 0},'
p5426
aS'         {4, 0},'
p5427
aS'         {delta, 1},'
p5428
aS'         {1, 1},'
p5429
aS'         {2, 1},'
p5430
aS'         {3, 1},'
p5431
aS'         {4, 1},'
p5432
aS'         {0, 2},'
p5433
aS'         {1, 2},'
p5434
aS'         {2, 2},'
p5435
aS'         {3, 2},'
p5436
aS'         {4, 2}};'
p5437
aS'    AssertDimension(vertices.size(), nx * ny);'
p5438
aS'    const std::vector<unsigned int> cell_vertices[(nx - 1) * (ny - 1)] = {'
p5439
aS'      {0, 1, nx + 0, nx + 1},'
p5440
aS'      {1, 2, nx + 1, nx + 2},'
p5441
aS'      {2, 3, nx + 2, nx + 3},'
p5442
aS'      {3, 4, nx + 3, nx + 4},'
p5443
aS'      {5, nx + 1, 2 * nx + 0, 2 * nx + 1},'
p5444
aS'      {nx + 1, nx + 2, 2 * nx + 1, 2 * nx + 2},'
p5445
aS'      {nx + 2, nx + 3, 2 * nx + 2, 2 * nx + 3},'
p5446
aS'      {nx + 3, nx + 4, 2 * nx + 3, 2 * nx + 4}};'
p5447
aS'    std::vector<CellData<dim>> cells((nx - 1) * (ny - 1), CellData<dim>());'
p5448
aS'    for (unsigned int i = 0; i < cells.size(); ++i)'
p5449
aS'      {'
p5450
aS'        cells[i].vertices    = cell_vertices[i];'
p5451
aS'        cells[i].material_id = 0;'
p5452
aS'      }'
p5453
aS'    triangulation.create_triangulation('
p5454
aS'      vertices,'
p5455
aS'      cells,'
p5456
aS'      SubCellData()); // No boundary information'
p5457
aS'    triangulation.refine_global(2);'
p5458
aS'    for (auto &cell : triangulation.active_cell_iterators())'
p5459
aS'      for (auto &face : cell->face_iterators())'
p5460
aS'        if (face->at_boundary())'
p5461
aS'          {'
p5462
aS'            if ((face->center()[0] > 0) && (face->center()[0] < 0.5) &&'
p5463
aS'              face->set_boundary_id(BoundaryIds::cathode);'
p5464
aS'            else if ((face->center()[0] > 0) && (face->center()[0] < 2))'
p5465
aS'              face->set_boundary_id(BoundaryIds::focus_element);'
p5466
aS'            else if ((face->center()[0] > 4 - 1e-12) &&'
p5467
aS'              face->set_boundary_id(BoundaryIds::anode);'
p5468
aS'            else'
p5469
aS'              face->set_boundary_id(BoundaryIds::open);'
p5470
aS'          }'
p5471
aS'    triangulation.refine_global(1);'
p5472
aS'  }'
p5473
aS'  template <int dim>'
p5474
aS'  void CathodeRaySimulator<dim>::setup_system()'
p5475
aS'  {'
p5476
aS'    dof_handler.distribute_dofs(fe);'
p5477
aS'    solution.reinit(dof_handler.n_dofs());'
p5478
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p5479
aS'    constraints.clear();'
p5480
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p5481
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5482
aS'                                             BoundaryIds::cathode,'
p5483
aS'                                             Functions::ConstantFunction<dim>('
p5484
aS'                                               -Constants::V0),'
p5485
aS'                                             constraints);'
p5486
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5487
aS'                                             BoundaryIds::focus_element,'
p5488
aS'                                             Functions::ConstantFunction<dim>('
p5489
aS'                                               -Constants::V0),'
p5490
aS'                                             constraints);'
p5491
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p5492
aS'                                             BoundaryIds::anode,'
p5493
aS'                                             Functions::ConstantFunction<dim>('
p5494
aS'                                               +Constants::V0),'
p5495
aS'                                             constraints);'
p5496
aS'    constraints.close();'
p5497
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p5498
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p5499
aS'                                    dsp,'
p5500
aS'                                    constraints,'
p5501
aS'    sparsity_pattern.copy_from(dsp);'
p5502
aS'    system_matrix.reinit(sparsity_pattern);'
p5503
aS'  }'
p5504
aS'  template <int dim>'
p5505
aS'  void CathodeRaySimulator<dim>::assemble_system()'
p5506
aS'  {'
p5507
aS'    system_matrix = 0;'
p5508
aS'    system_rhs    = 0;'
p5509
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p5510
aS'    FEValues<dim> fe_values(fe,'
p5511
aS'                            quadrature_formula,'
p5512
aS'                            update_values | update_gradients |'
p5513
aS'                              update_quadrature_points | update_JxW_values);'
p5514
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p5515
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p5516
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p5517
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p5518
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5519
aS'      {'
p5520
aS'        cell_matrix = 0;'
p5521
aS'        cell_rhs    = 0;'
p5522
aS'        fe_values.reinit(cell);'
p5523
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p5524
aS'          for (const unsigned int i : fe_values.dof_indices())'
p5525
aS'            {'
p5526
aS'              for (const unsigned int j : fe_values.dof_indices())'
p5527
aS'                cell_matrix(i, j) +='
p5528
aS'                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p5529
aS'                   fe_values.JxW(q_index));           // dx'
p5530
aS'            }'
p5531
aS'        if (particle_handler.n_particles_in_cell(cell) > 0)'
p5532
aS'          for (const auto &particle : particle_handler.particles_in_cell(cell))'
p5533
aS'            {'
p5534
aS'              const Point<dim> &reference_location ='
p5535
aS'                particle.get_reference_location();'
p5536
aS'              for (const unsigned int i : fe_values.dof_indices())'
p5537
aS'                cell_rhs(i) +='
p5538
aS'                    Constants::electron_charge));          // e'
p5539
aS'            }'
p5540
aS'        cell->get_dof_indices(local_dof_indices);'
p5541
aS'        constraints.distribute_local_to_global('
p5542
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p5543
aS'      }'
p5544
aS'  }'
p5545
aS'  template <int dim>'
p5546
aS'  void CathodeRaySimulator<dim>::solve_field()'
p5547
aS'  {'
p5548
aS'    SolverControl            solver_control(1000, 1e-12);'
p5549
aS'    SolverCG<Vector<double>> solver(solver_control);'
p5550
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p5551
aS'    preconditioner.initialize(system_matrix, 1.2);'
p5552
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p5553
aS'    constraints.distribute(solution);'
p5554
aS'  }'
p5555
aS'  template <int dim>'
p5556
aS'  void CathodeRaySimulator<dim>::refine_grid()'
p5557
aS'  {'
p5558
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p5559
aS'    KellyErrorEstimator<dim>::estimate(dof_handler,'
p5560
aS'                                       QGauss<dim - 1>(fe.degree + 1),'
p5561
aS'                                       {},'
p5562
aS'                                       solution,'
p5563
aS'                                       estimated_error_per_cell);'
p5564
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p5565
aS'                                                    estimated_error_per_cell,'
p5566
aS'                                                    0.1,'
p5567
aS'                                                    0.03);'
p5568
aS'    triangulation.execute_coarsening_and_refinement();'
p5569
aS'  }'
p5570
aS'  template <int dim>'
p5571
aS'  void CathodeRaySimulator<dim>::create_particles()'
p5572
aS'  {'
p5573
aS'    FEFaceValues<dim> fe_face_values(fe,'
p5574
aS'                                     QMidpoint<dim - 1>(),'
p5575
aS'                                     update_quadrature_points |'
p5576
aS'                                       update_gradients |'
p5577
aS'                                       update_normal_vectors);'
p5578
aS'    std::vector<Tensor<1, dim>> solution_gradients('
p5579
aS'      fe_face_values.n_quadrature_points);'
p5580
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5581
aS'      for (const auto &face : cell->face_iterators())'
p5582
aS'        if (face->at_boundary() &&'
p5583
aS'          {'
p5584
aS'            fe_face_values.reinit(cell, face);'
p5585
aS'            const FEValuesExtractors::Scalar electric_potential(0);'
p5586
aS'            fe_face_values[electric_potential].get_function_gradients('
p5587
aS'              solution, solution_gradients);'
p5588
aS'            for (const unsigned int q_point :'
p5589
aS'                 fe_face_values.quadrature_point_indices())'
p5590
aS'              {'
p5591
aS'                const Tensor<1, dim> E = solution_gradients[q_point];'
p5592
aS'                if ((E * fe_face_values.normal_vector(q_point) < 0) &&'
p5593
aS'                  {'
p5594
aS'                    const Point<dim> &location ='
p5595
aS'                      fe_face_values.quadrature_point(q_point);'
p5596
aS'                    Particles::Particle<dim> new_particle;'
p5597
aS'                    new_particle.set_location(location);'
p5598
aS'                    new_particle.set_reference_location('
p5599
aS'                      mapping.transform_real_to_unit_cell(cell, location));'
p5600
aS'                    new_particle.set_id(next_unused_particle_id);'
p5601
aS'                    particle_handler.insert_particle(new_particle, cell);'
p5602
aS'                    ++next_unused_particle_id;'
p5603
aS'                  }'
p5604
aS'              }'
p5605
aS'          }'
p5606
aS'    particle_handler.update_cached_numbers();'
p5607
aS'  }'
p5608
aS'  template <int dim>'
p5609
aS'  void CathodeRaySimulator<dim>::move_particles()'
p5610
aS'  {'
p5611
aS'    const double dt = time.get_next_step_size();'
p5612
aS'    Vector<double>            solution_values(fe.n_dofs_per_cell());'
p5613
aS'    FEPointEvaluation<1, dim> evaluator(mapping, fe, update_gradients);'
p5614
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p5615
aS'      if (particle_handler.n_particles_in_cell(cell) > 0)'
p5616
aS'        {'
p5617
aS'          const typename Particles::ParticleHandler<'
p5618
aS'            dim>::particle_iterator_range particles_in_cell ='
p5619
aS'            particle_handler.particles_in_cell(cell);'
p5620
aS'          std::vector<Point<dim>> particle_positions;'
p5621
aS'          for (const auto &particle : particles_in_cell)'
p5622
aS'            particle_positions.push_back(particle.get_reference_location());'
p5623
aS'          cell->get_dof_values(solution, solution_values);'
p5624
aS'          evaluator.reinit(cell, particle_positions);'
p5625
aS'          evaluator.evaluate(make_array_view(solution_values),'
p5626
aS'                             EvaluationFlags::gradients);'
p5627
aS'          {'
p5628
aS'            typename Particles::ParticleHandler<dim>::particle_iterator'
p5629
aS'              particle = particles_in_cell.begin();'
p5630
aS'            for (unsigned int particle_index = 0;'
p5631
aS'                 particle != particles_in_cell.end();'
p5632
aS'                 ++particle, ++particle_index)'
p5633
aS'              {'
p5634
aS'                const Tensor<1, dim> &E ='
p5635
aS'                  evaluator.get_gradient(particle_index);'
p5636
aS'                const Tensor<1, dim> old_velocity(particle->get_properties());'
p5637
aS'                const Tensor<1, dim> acceleration ='
p5638
aS'                  Constants::electron_charge / Constants::electron_mass * E;'
p5639
aS'                const Tensor<1, dim> new_velocity ='
p5640
aS'                  old_velocity + acceleration * dt;'
p5641
aS'                particle->set_properties(make_array_view(new_velocity));'
p5642
aS'                const Point<dim> new_location ='
p5643
aS'                  particle->get_location() + dt * new_velocity;'
p5644
aS'                particle->set_location(new_location);'
p5645
aS'              }'
p5646
aS'          }'
p5647
aS'        }'
p5648
aS'    particle_handler.sort_particles_into_subdomains_and_cells();'
p5649
aS'  }'
p5650
aS'  template <int dim>'
p5651
aS'  void CathodeRaySimulator<dim>::track_lost_particle('
p5652
aS'    const typename Particles::ParticleIterator<dim> &        particle,'
p5653
aS'    const typename Triangulation<dim>::active_cell_iterator &cell)'
p5654
aS'  {'
p5655
aS'    ++n_recently_lost_particles;'
p5656
aS'    ++n_total_lost_particles;'
p5657
aS'    const Point<dim> current_location              = particle->get_location();'
p5658
aS'    const Point<dim> approximate_previous_location = cell->center();'
p5659
aS'    if ((approximate_previous_location[0] < 4) && (current_location[0] > 4))'
p5660
aS'      {'
p5661
aS'        const Tensor<1, dim> direction ='
p5662
aS'        const double right_boundary_intercept ='
p5663
aS'          approximate_previous_location[1] +'
p5664
aS'        if ((right_boundary_intercept > 0.5) &&'
p5665
aS'          ++n_particles_lost_through_anode;'
p5666
aS'      }'
p5667
aS'  }'
p5668
aS'  template <int dim>'
p5669
aS'  void CathodeRaySimulator<dim>::update_timestep_size()'
p5670
aS'  {'
p5671
aS'    if (time.get_step_number() > 0)'
p5672
aS'      {'
p5673
aS'        double min_cell_size_over_velocity = std::numeric_limits<double>::max();'
p5674
aS'        for (const auto &cell : dof_handler.active_cell_iterators())'
p5675
aS'          if (particle_handler.n_particles_in_cell(cell) > 0)'
p5676
aS'            {'
p5677
aS'              const double cell_size = cell->minimum_vertex_distance();'
p5678
aS'              double max_particle_velocity(0.0);'
p5679
aS'              for (const auto &particle :'
p5680
aS'                   particle_handler.particles_in_cell(cell))'
p5681
aS'                {'
p5682
aS'                  const Tensor<1, dim> velocity(particle.get_properties());'
p5683
aS'                  max_particle_velocity ='
p5684
aS'                    std::max(max_particle_velocity, velocity.norm());'
p5685
aS'                }'
p5686
aS'              if (max_particle_velocity > 0)'
p5687
aS'                min_cell_size_over_velocity ='
p5688
aS'                  std::min(min_cell_size_over_velocity,'
p5689
aS'                           cell_size / max_particle_velocity);'
p5690
aS'            }'
p5691
aS'        constexpr double c_safety = 0.5;'
p5692
aS'        time.set_desired_next_step_size(c_safety * 0.5 *'
p5693
aS'                                        min_cell_size_over_velocity);'
p5694
aS'      }'
p5695
aS'    else'
p5696
aS'      {'
p5697
aS'        const QTrapezoid<dim> vertex_quadrature;'
p5698
aS'        FEValues<dim> fe_values(fe, vertex_quadrature, update_gradients);'
p5699
aS'        std::vector<Tensor<1, dim>> field_gradients(vertex_quadrature.size());'
p5700
aS'        double min_timestep = std::numeric_limits<double>::max();'
p5701
aS'        for (const auto &cell : dof_handler.active_cell_iterators())'
p5702
aS'          if (particle_handler.n_particles_in_cell(cell) > 0)'
p5703
aS'            {'
p5704
aS'              const double cell_size = cell->minimum_vertex_distance();'
p5705
aS'              fe_values.reinit(cell);'
p5706
aS'              fe_values.get_function_gradients(solution, field_gradients);'
p5707
aS'              double max_E = 0;'
p5708
aS'              for (const auto q_point : fe_values.quadrature_point_indices())'
p5709
aS'                max_E = std::max(max_E, field_gradients[q_point].norm());'
p5710
aS'              if (max_E > 0)'
p5711
aS'                min_timestep ='
p5712
aS'                  std::min(min_timestep,'
p5713
aS'                           std::sqrt(0.5 * cell_size *'
p5714
aS'                                     Constants::electron_mass /'
p5715
aS'                                     Constants::electron_charge / max_E));'
p5716
aS'            }'
p5717
aS'        time.set_desired_next_step_size(min_timestep);'
p5718
aS'      }'
p5719
aS'  }'
p5720
aS'  template <int dim>'
p5721
aS'  class ElectricFieldPostprocessor : public DataPostprocessorVector<dim>'
p5722
aS'  {'
p5723
aS'  public:'
p5724
aS'    ElectricFieldPostprocessor()'
p5725
aS'      : DataPostprocessorVector<dim>("electric_field", update_gradients)'
p5726
aS'    {}'
p5727
aS'    virtual void evaluate_scalar_field('
p5728
aS'      const DataPostprocessorInputs::Scalar<dim> &input_data,'
p5729
aS'      std::vector<Vector<double>> &computed_quantities) const override'
p5730
aS'    {'
p5731
aS'      AssertDimension(input_data.solution_gradients.size(),'
p5732
aS'                      computed_quantities.size());'
p5733
aS'      for (unsigned int p = 0; p < input_data.solution_gradients.size(); ++p)'
p5734
aS'        {'
p5735
aS'          AssertDimension(computed_quantities[p].size(), dim);'
p5736
aS'          for (unsigned int d = 0; d < dim; ++d)'
p5737
aS'            computed_quantities[p][d] = input_data.solution_gradients[p][d];'
p5738
aS'        }'
p5739
aS'    }'
p5740
aS'  };'
p5741
aS'  template <int dim>'
p5742
aS'  void CathodeRaySimulator<dim>::output_results() const'
p5743
aS'  {'
p5744
aS'    {'
p5745
aS'      ElectricFieldPostprocessor<dim> electric_field;'
p5746
aS'      DataOut<dim>                    data_out;'
p5747
aS'      data_out.attach_dof_handler(dof_handler);'
p5748
aS'      data_out.add_data_vector(solution, "electric_potential");'
p5749
aS'      data_out.add_data_vector(solution, electric_field);'
p5750
aS'      data_out.build_patches();'
p5751
aS'      data_out.set_flags('
p5752
aS'        DataOutBase::VtkFlags(time.get_current_time(), time.get_step_number()));'
p5753
aS'      std::ofstream output("solution-" +'
p5754
aS'                           Utilities::int_to_string(time.get_step_number(), 4) +'
p5755
aS'                           ".vtu");'
p5756
aS'      data_out.write_vtu(output);'
p5757
aS'    }'
p5758
aS'    {'
p5759
aS'      Particles::DataOut<dim, dim> particle_out;'
p5760
aS'      particle_out.build_patches('
p5761
aS'        particle_handler,'
p5762
aS'        std::vector<std::string>(dim, "velocity"),'
p5763
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>('
p5764
aS'          dim, DataComponentInterpretation::component_is_part_of_vector));'
p5765
aS'      particle_out.set_flags('
p5766
aS'        DataOutBase::VtkFlags(time.get_current_time(), time.get_step_number()));'
p5767
aS'      std::ofstream output("particles-" +'
p5768
aS'                           Utilities::int_to_string(time.get_step_number(), 4) +'
p5769
aS'                           ".vtu");'
p5770
aS'      particle_out.write_vtu(output);'
p5771
aS'    }'
p5772
aS'  }'
p5773
aS'  template <int dim>'
p5774
aS'  void CathodeRaySimulator<dim>::run()'
p5775
aS'  {'
p5776
aS'    make_grid();'
p5777
aS'    const unsigned int n_pre_refinement_cycles = 3;'
p5778
aS'    for (unsigned int refinement_cycle = 0;'
p5779
aS'         refinement_cycle < n_pre_refinement_cycles;'
p5780
aS'         ++refinement_cycle)'
p5781
aS'      {'
p5782
aS'        setup_system();'
p5783
aS'        assemble_system();'
p5784
aS'        solve_field();'
p5785
aS'        refine_grid();'
p5786
aS'      }'
p5787
aS'    setup_system();'
p5788
aS'    do'
p5789
aS'      {'
p5790
aS'        std::cout << "Timestep " << time.get_step_number() + 1 << std::endl;'
p5791
aS'        std::cout << "  Field degrees of freedom:                 "'
p5792
aS'                  << dof_handler.n_dofs() << std::endl;'
p5793
aS'        assemble_system();'
p5794
aS'        solve_field();'
p5795
aS'        create_particles();'
p5796
aS'        std::cout << "  Total number of particles in simulation:  "'
p5797
aS'                  << particle_handler.n_global_particles() << std::endl;'
p5798
aS'        n_recently_lost_particles = 0;'
p5799
aS'        update_timestep_size();'
p5800
aS'        move_particles();'
p5801
aS'        time.advance_time();'
p5802
aS'        output_results();'
p5803
aS'        std::cout << "  Number of particles lost this time step:  "'
p5804
aS'                  << n_recently_lost_particles << std::endl;'
p5805
aS'        if (n_total_lost_particles > 0)'
p5806
aS'          std::cout << "  Fraction of particles lost through anode: "'
p5807
aS'                    << 1. * n_particles_lost_through_anode /'
p5808
aS'                         n_total_lost_particles'
p5809
aS'                    << std::endl;'
p5810
aS'        std::cout << std::endl'
p5811
aS'                  << "  Now at t=" << time.get_current_time()'
p5812
aS'                  << ", dt=" << time.get_previous_step_size() << \'.\''
p5813
aS'                  << std::endl'
p5814
aS'                  << std::endl;'
p5815
aS'      }'
p5816
aS'    while (time.is_at_end() == false);'
p5817
aS'  }'
p5818
aS'} // namespace Step19'
p5819
aS'int main()'
p5820
ag9
aS'  try'
p5821
aS'    {'
p5822
aS'      Step19::CathodeRaySimulator<2> cathode_ray_simulator_2d;'
p5823
aS'      cathode_ray_simulator_2d.run();'
p5824
aS'    }'
p5825
aS'  catch (std::exception &exc)'
p5826
aS'    {'
p5827
aS'      std::cerr << std::endl'
p5828
aS'                << std::endl'
p5829
aS'                << "----------------------------------------------------"'
p5830
aS'                << std::endl;'
p5831
aS'      std::cerr << "Exception on processing: " << std::endl'
p5832
aS'                << exc.what() << std::endl'
p5833
aS'                << "Aborting!" << std::endl'
p5834
aS'                << "----------------------------------------------------"'
p5835
aS'                << std::endl;'
p5836
aS'      return 1;'
p5837
aS'    }'
p5838
aS'  catch (...)'
p5839
aS'    {'
p5840
aS'      std::cerr << std::endl'
p5841
aS'                << std::endl'
p5842
aS'                << "----------------------------------------------------"'
p5843
aS'                << std::endl;'
p5844
aS'      std::cerr << "Unknown exception!" << std::endl'
p5845
aS'                << "Aborting!" << std::endl'
p5846
aS'                << "----------------------------------------------------"'
p5847
aS'                << std::endl;'
p5848
aS'      return 1;'
p5849
aS'    }'
p5850
aS'  return 0;'
p5851
ag17
aS'#include <deal.II/grid/tria.h>'
p5852
aS'#include <deal.II/grid/grid_generator.h>'
p5853
aS'#include <deal.II/dofs/dof_handler.h>'
p5854
aS'#include <deal.II/fe/fe_q.h>'
p5855
aS'#include <deal.II/dofs/dof_tools.h>'
p5856
aS'#include <deal.II/lac/sparse_matrix.h>'
p5857
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p5858
aS'#include <deal.II/dofs/dof_renumbering.h>'
p5859
aS'#include <fstream>'
p5860
aS'using namespace dealii;'
p5861
aS'void make_grid(Triangulation<2> &triangulation)'
p5862
ag9
aS'  const Point<2> center(1, 0);'
p5863
aS'  const double   inner_radius = 0.5, outer_radius = 1.0;'
p5864
aS'  GridGenerator::hyper_shell('
p5865
aS'    triangulation, center, inner_radius, outer_radius, 5);'
p5866
aS'  for (unsigned int step = 0; step < 3; ++step)'
p5867
aS'    {'
p5868
aS'      for (auto &cell : triangulation.active_cell_iterators())'
p5869
aS'        for (const auto v : cell->vertex_indices())'
p5870
aS'          {'
p5871
aS'            const double distance_from_center ='
p5872
aS'              center.distance(cell->vertex(v));'
p5873
aS'            if (std::fabs(distance_from_center - inner_radius) <='
p5874
aS'                1e-6 * inner_radius)'
p5875
aS'              {'
p5876
aS'                cell->set_refine_flag();'
p5877
aS'                break;'
p5878
aS'              }'
p5879
aS'          }'
p5880
aS'      triangulation.execute_coarsening_and_refinement();'
p5881
aS'    }'
p5882
ag17
aS'void distribute_dofs(DoFHandler<2> &dof_handler)'
p5883
ag9
aS'  const FE_Q<2> finite_element(1);'
p5884
aS'  dof_handler.distribute_dofs(finite_element);'
p5885
aS'  DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),'
p5886
aS'                                                  dof_handler.n_dofs());'
p5887
aS'  DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);'
p5888
aS'  SparsityPattern sparsity_pattern;'
p5889
aS'  sparsity_pattern.copy_from(dynamic_sparsity_pattern);'
p5890
aS'  std::ofstream out("sparsity_pattern1.svg");'
p5891
aS'  sparsity_pattern.print_svg(out);'
p5892
ag17
aS'void renumber_dofs(DoFHandler<2> &dof_handler)'
p5893
ag9
aS'  DoFRenumbering::Cuthill_McKee(dof_handler);'
p5894
aS'  DynamicSparsityPattern dynamic_sparsity_pattern(dof_handler.n_dofs(),'
p5895
aS'                                                  dof_handler.n_dofs());'
p5896
aS'  DoFTools::make_sparsity_pattern(dof_handler, dynamic_sparsity_pattern);'
p5897
aS'  SparsityPattern sparsity_pattern;'
p5898
aS'  sparsity_pattern.copy_from(dynamic_sparsity_pattern);'
p5899
aS'  std::ofstream out("sparsity_pattern2.svg");'
p5900
aS'  sparsity_pattern.print_svg(out);'
p5901
ag17
aS'int main()'
p5902
ag9
aS'  Triangulation<2> triangulation;'
p5903
aS'  make_grid(triangulation);'
p5904
aS'  DoFHandler<2> dof_handler(triangulation);'
p5905
aS'  distribute_dofs(dof_handler);'
p5906
aS'  renumber_dofs(dof_handler);'
p5907
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p5908
aS'#include <deal.II/base/logstream.h>'
p5909
aS'#include <deal.II/base/function.h>'
p5910
aS'#include <deal.II/lac/block_vector.h>'
p5911
aS'#include <deal.II/lac/full_matrix.h>'
p5912
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p5913
aS'#include <deal.II/lac/solver_cg.h>'
p5914
aS'#include <deal.II/lac/precondition.h>'
p5915
aS'#include <deal.II/lac/linear_operator.h>'
p5916
aS'#include <deal.II/lac/packaged_operation.h>'
p5917
aS'#include <deal.II/grid/tria.h>'
p5918
aS'#include <deal.II/grid/grid_generator.h>'
p5919
aS'#include <deal.II/dofs/dof_handler.h>'
p5920
aS'#include <deal.II/dofs/dof_renumbering.h>'
p5921
aS'#include <deal.II/dofs/dof_tools.h>'
p5922
aS'#include <deal.II/fe/fe_dgq.h>'
p5923
aS'#include <deal.II/fe/fe_system.h>'
p5924
aS'#include <deal.II/fe/fe_values.h>'
p5925
aS'#include <deal.II/numerics/vector_tools.h>'
p5926
aS'#include <deal.II/numerics/matrix_tools.h>'
p5927
aS'#include <deal.II/numerics/data_out.h>'
p5928
aS'#include <fstream>'
p5929
aS'#include <iostream>'
p5930
aS'#include <deal.II/fe/fe_raviart_thomas.h>'
p5931
aS'#include <deal.II/base/tensor_function.h>'
p5932
aS'namespace Step20'
p5933
ag9
aS'  using namespace dealii;'
p5934
aS'  template <int dim>'
p5935
aS'  class MixedLaplaceProblem'
p5936
aS'  {'
p5937
aS'  public:'
p5938
aS'    MixedLaplaceProblem(const unsigned int degree);'
p5939
aS'    void run();'
p5940
aS'  private:'
p5941
aS'    void make_grid_and_dofs();'
p5942
aS'    void assemble_system();'
p5943
aS'    void solve();'
p5944
aS'    void compute_errors() const;'
p5945
aS'    void output_results() const;'
p5946
aS'    const unsigned int degree;'
p5947
aS'    Triangulation<dim> triangulation;'
p5948
aS'    FESystem<dim>      fe;'
p5949
aS'    DoFHandler<dim>    dof_handler;'
p5950
aS'    BlockSparsityPattern      sparsity_pattern;'
p5951
aS'    BlockSparseMatrix<double> system_matrix;'
p5952
aS'    BlockVector<double> solution;'
p5953
aS'    BlockVector<double> system_rhs;'
p5954
aS'  };'
p5955
aS'  namespace PrescribedSolution'
p5956
aS'  {'
p5957
aS'    constexpr double alpha = 0.3;'
p5958
aS'    constexpr double beta  = 1;'
p5959
aS'    template <int dim>'
p5960
aS'    class RightHandSide : public Function<dim>'
p5961
aS'    {'
p5962
aS'    public:'
p5963
aS'      RightHandSide()'
p5964
aS'        : Function<dim>(1)'
p5965
aS'      {}'
p5966
aS'      virtual double value(const Point<dim> & p,'
p5967
aS'                           const unsigned int component = 0) const override;'
p5968
aS'    };'
p5969
aS'    template <int dim>'
p5970
aS'    class PressureBoundaryValues : public Function<dim>'
p5971
aS'    {'
p5972
aS'    public:'
p5973
aS'      PressureBoundaryValues()'
p5974
aS'        : Function<dim>(1)'
p5975
aS'      {}'
p5976
aS'      virtual double value(const Point<dim> & p,'
p5977
aS'                           const unsigned int component = 0) const override;'
p5978
aS'    };'
p5979
aS'    template <int dim>'
p5980
aS'    class ExactSolution : public Function<dim>'
p5981
aS'    {'
p5982
aS'    public:'
p5983
aS'      ExactSolution()'
p5984
aS'        : Function<dim>(dim + 1)'
p5985
aS'      {}'
p5986
aS'      virtual void vector_value(const Point<dim> &p,'
p5987
aS'                                Vector<double> &  value) const override;'
p5988
aS'    };'
p5989
aS'    template <int dim>'
p5990
aS'    double RightHandSide<dim>::value(const Point<dim> & /*p*/,'
p5991
aS'                                     const unsigned int /*component*/) const'
p5992
aS'    {'
p5993
aS'      return 0;'
p5994
aS'    }'
p5995
aS'    template <int dim>'
p5996
aS'    double'
p5997
aS'    PressureBoundaryValues<dim>::value(const Point<dim> &p,'
p5998
aS'                                       const unsigned int /*component*/) const'
p5999
aS'    {'
p6000
aS'      return -(alpha * p[0] * p[1] * p[1] / 2 + beta * p[0] -'
p6001
aS'               alpha * p[0] * p[0] * p[0] / 6);'
p6002
aS'    }'
p6003
aS'    template <int dim>'
p6004
aS'    void ExactSolution<dim>::vector_value(const Point<dim> &p,'
p6005
aS'                                          Vector<double> &  values) const'
p6006
aS'    {'
p6007
aS'      Assert(values.size() == dim + 1,'
p6008
aS'             ExcDimensionMismatch(values.size(), dim + 1));'
p6009
aS'      values(0) = alpha * p[1] * p[1] / 2 + beta - alpha * p[0] * p[0] / 2;'
p6010
aS'      values(1) = alpha * p[0] * p[1];'
p6011
aS'      values(2) = -(alpha * p[0] * p[1] * p[1] / 2 + beta * p[0] -'
p6012
aS'                    alpha * p[0] * p[0] * p[0] / 6);'
p6013
aS'    }'
p6014
aS'    template <int dim>'
p6015
aS'    class KInverse : public TensorFunction<2, dim>'
p6016
aS'    {'
p6017
aS'    public:'
p6018
aS'      KInverse()'
p6019
aS'        : TensorFunction<2, dim>()'
p6020
aS'      {}'
p6021
aS'      virtual void'
p6022
aS'      value_list(const std::vector<Point<dim>> &points,'
p6023
aS'                 std::vector<Tensor<2, dim>> &  values) const override;'
p6024
aS'    };'
p6025
aS'    template <int dim>'
p6026
aS'    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,'
p6027
aS'                                   std::vector<Tensor<2, dim>> &  values) const'
p6028
aS'    {'
p6029
aS'      AssertDimension(points.size(), values.size());'
p6030
aS'      for (auto &value : values)'
p6031
aS'        value = unit_symmetric_tensor<dim>();'
p6032
aS'    }'
p6033
aS'  } // namespace PrescribedSolution'
p6034
aS'  template <int dim>'
p6035
aS'  MixedLaplaceProblem<dim>::MixedLaplaceProblem(const unsigned int degree)'
p6036
aS'    : degree(degree)'
p6037
aS'    , fe(FE_RaviartThomas<dim>(degree), 1, FE_DGQ<dim>(degree), 1)'
p6038
aS'    , dof_handler(triangulation)'
p6039
aS'  {}'
p6040
aS'  template <int dim>'
p6041
aS'  void MixedLaplaceProblem<dim>::make_grid_and_dofs()'
p6042
aS'  {'
p6043
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p6044
aS'    triangulation.refine_global(5);'
p6045
aS'    dof_handler.distribute_dofs(fe);'
p6046
aS'    DoFRenumbering::component_wise(dof_handler);'
p6047
aS'    const std::vector<types::global_dof_index> dofs_per_component ='
p6048
aS'      DoFTools::count_dofs_per_fe_component(dof_handler);'
p6049
aS'    const unsigned int n_u = dofs_per_component[0],'
p6050
aS'                       n_p = dofs_per_component[dim];'
p6051
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p6052
aS'              << std::endl'
p6053
aS'              << "Total number of cells: " << triangulation.n_cells()'
p6054
aS'              << std::endl'
p6055
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p6056
aS'              << " (" << n_u << \'+\' << n_p << \')\' << std::endl;'
p6057
aS'    BlockDynamicSparsityPattern dsp(2, 2);'
p6058
aS'    dsp.block(0, 0).reinit(n_u, n_u);'
p6059
aS'    dsp.block(1, 0).reinit(n_p, n_u);'
p6060
aS'    dsp.block(0, 1).reinit(n_u, n_p);'
p6061
aS'    dsp.block(1, 1).reinit(n_p, n_p);'
p6062
aS'    dsp.collect_sizes();'
p6063
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p6064
aS'    sparsity_pattern.copy_from(dsp);'
p6065
aS'    system_matrix.reinit(sparsity_pattern);'
p6066
aS'    solution.reinit(2);'
p6067
aS'    solution.block(0).reinit(n_u);'
p6068
aS'    solution.block(1).reinit(n_p);'
p6069
aS'    solution.collect_sizes();'
p6070
aS'    system_rhs.reinit(2);'
p6071
aS'    system_rhs.block(0).reinit(n_u);'
p6072
aS'    system_rhs.block(1).reinit(n_p);'
p6073
aS'    system_rhs.collect_sizes();'
p6074
aS'  }'
p6075
aS'  template <int dim>'
p6076
aS'  void MixedLaplaceProblem<dim>::assemble_system()'
p6077
aS'  {'
p6078
aS'    QGauss<dim>     quadrature_formula(degree + 2);'
p6079
aS'    QGauss<dim - 1> face_quadrature_formula(degree + 2);'
p6080
aS'    FEValues<dim>     fe_values(fe,'
p6081
aS'                            quadrature_formula,'
p6082
aS'                            update_values | update_gradients |'
p6083
aS'                              update_quadrature_points | update_JxW_values);'
p6084
aS'    FEFaceValues<dim> fe_face_values(fe,'
p6085
aS'                                     face_quadrature_formula,'
p6086
aS'                                     update_values | update_normal_vectors |'
p6087
aS'                                       update_quadrature_points |'
p6088
aS'                                       update_JxW_values);'
p6089
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p6090
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p6091
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p6092
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p6093
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p6094
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p6095
aS'    const PrescribedSolution::RightHandSide<dim> right_hand_side;'
p6096
aS'    const PrescribedSolution::PressureBoundaryValues<dim>'
p6097
aS'                                            pressure_boundary_values;'
p6098
aS'    const PrescribedSolution::KInverse<dim> k_inverse;'
p6099
aS'    std::vector<double>         rhs_values(n_q_points);'
p6100
aS'    std::vector<double>         boundary_values(n_face_q_points);'
p6101
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p6102
aS'    const FEValuesExtractors::Vector velocities(0);'
p6103
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p6104
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p6105
aS'      {'
p6106
aS'        fe_values.reinit(cell);'
p6107
aS'        local_matrix = 0;'
p6108
aS'        local_rhs    = 0;'
p6109
aS'        right_hand_side.value_list(fe_values.get_quadrature_points(),'
p6110
aS'                                   rhs_values);'
p6111
aS'        k_inverse.value_list(fe_values.get_quadrature_points(),'
p6112
aS'                             k_inverse_values);'
p6113
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p6114
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6115
aS'            {'
p6116
aS'              const Tensor<1, dim> phi_i_u = fe_values[velocities].value(i, q);'
p6117
aS'              const double div_phi_i_u = fe_values[velocities].divergence(i, q);'
p6118
aS'              const double phi_i_p     = fe_values[pressure].value(i, q);'
p6119
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p6120
aS'                {'
p6121
aS'                  const Tensor<1, dim> phi_j_u ='
p6122
aS'                    fe_values[velocities].value(j, q);'
p6123
aS'                  const double div_phi_j_u ='
p6124
aS'                    fe_values[velocities].divergence(j, q);'
p6125
aS'                  const double phi_j_p = fe_values[pressure].value(j, q);'
p6126
aS'                  local_matrix(i, j) +='
p6127
aS'                     - phi_i_p * div_phi_j_u                 //'
p6128
aS'                     - div_phi_i_u * phi_j_p)                //'
p6129
aS'                }'
p6130
aS'              local_rhs(i) += -phi_i_p * rhs_values[q] * fe_values.JxW(q);'
p6131
aS'            }'
p6132
aS'        for (const auto &face : cell->face_iterators())'
p6133
aS'          if (face->at_boundary())'
p6134
aS'            {'
p6135
aS'              fe_face_values.reinit(cell, face);'
p6136
aS'              pressure_boundary_values.value_list('
p6137
aS'                fe_face_values.get_quadrature_points(), boundary_values);'
p6138
aS'              for (unsigned int q = 0; q < n_face_q_points; ++q)'
p6139
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6140
aS'                  local_rhs(i) += -(fe_face_values[velocities].value(i, q) * //'
p6141
aS'                                    fe_face_values.normal_vector(q) *        //'
p6142
aS'                                    boundary_values[q] *                     //'
p6143
aS'                                    fe_face_values.JxW(q));'
p6144
aS'            }'
p6145
aS'        cell->get_dof_indices(local_dof_indices);'
p6146
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6147
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p6148
aS'            system_matrix.add(local_dof_indices[i],'
p6149
aS'                              local_dof_indices[j],'
p6150
aS'                              local_matrix(i, j));'
p6151
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6152
aS'          system_rhs(local_dof_indices[i]) += local_rhs(i);'
p6153
aS'      }'
p6154
aS'  }'
p6155
aS'  template <int dim>'
p6156
aS'  void MixedLaplaceProblem<dim>::solve()'
p6157
aS'  {'
p6158
aS'    const auto &M = system_matrix.block(0, 0);'
p6159
aS'    const auto &B = system_matrix.block(0, 1);'
p6160
aS'    const auto &F = system_rhs.block(0);'
p6161
aS'    const auto &G = system_rhs.block(1);'
p6162
aS'    auto &U = solution.block(0);'
p6163
aS'    auto &P = solution.block(1);'
p6164
aS'    const auto op_M = linear_operator(M);'
p6165
aS'    const auto op_B = linear_operator(B);'
p6166
aS'    ReductionControl         reduction_control_M(2000, 1.0e-18, 1.0e-10);'
p6167
aS'    SolverCG<Vector<double>> solver_M(reduction_control_M);'
p6168
aS'    PreconditionJacobi<SparseMatrix<double>> preconditioner_M;'
p6169
aS'    preconditioner_M.initialize(M);'
p6170
aS'    const auto op_M_inv = inverse_operator(op_M, solver_M, preconditioner_M);'
p6171
aS'    const auto op_S = transpose_operator(op_B) * op_M_inv * op_B;'
p6172
aS'    const auto op_aS ='
p6173
aS'      transpose_operator(op_B) * linear_operator(preconditioner_M) * op_B;'
p6174
aS'    IterationNumberControl   iteration_number_control_aS(30, 1.e-18);'
p6175
aS'    SolverCG<Vector<double>> solver_aS(iteration_number_control_aS);'
p6176
aS'    const auto preconditioner_S ='
p6177
aS'      inverse_operator(op_aS, solver_aS, PreconditionIdentity());'
p6178
aS'    const auto schur_rhs = transpose_operator(op_B) * op_M_inv * F - G;'
p6179
aS'    SolverControl            solver_control_S(2000, 1.e-12);'
p6180
aS'    SolverCG<Vector<double>> solver_S(solver_control_S);'
p6181
aS'    const auto op_S_inv = inverse_operator(op_S, solver_S, preconditioner_S);'
p6182
aS'    P = op_S_inv * schur_rhs;'
p6183
aS'    std::cout << solver_control_S.last_step()'
p6184
aS'              << " CG Schur complement iterations to obtain convergence."'
p6185
aS'              << std::endl;'
p6186
aS'    U = op_M_inv * (F - op_B * P);'
p6187
aS'  }'
p6188
aS'  template <int dim>'
p6189
aS'  void MixedLaplaceProblem<dim>::compute_errors() const'
p6190
aS'  {'
p6191
aS'    const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);'
p6192
aS'    const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),'
p6193
aS'                                                     dim + 1);'
p6194
aS'    PrescribedSolution::ExactSolution<dim> exact_solution;'
p6195
aS'    Vector<double> cellwise_errors(triangulation.n_active_cells());'
p6196
aS'    QTrapezoid<1>  q_trapez;'
p6197
aS'    QIterated<dim> quadrature(q_trapez, degree + 2);'
p6198
aS'    VectorTools::integrate_difference(dof_handler,'
p6199
aS'                                      solution,'
p6200
aS'                                      exact_solution,'
p6201
aS'                                      cellwise_errors,'
p6202
aS'                                      quadrature,'
p6203
aS'                                      VectorTools::L2_norm,'
p6204
aS'                                      &pressure_mask);'
p6205
aS'    const double p_l2_error ='
p6206
aS'      VectorTools::compute_global_error(triangulation,'
p6207
aS'                                        cellwise_errors,'
p6208
aS'                                        VectorTools::L2_norm);'
p6209
aS'    VectorTools::integrate_difference(dof_handler,'
p6210
aS'                                      solution,'
p6211
aS'                                      exact_solution,'
p6212
aS'                                      cellwise_errors,'
p6213
aS'                                      quadrature,'
p6214
aS'                                      VectorTools::L2_norm,'
p6215
aS'                                      &velocity_mask);'
p6216
aS'    const double u_l2_error ='
p6217
aS'      VectorTools::compute_global_error(triangulation,'
p6218
aS'                                        cellwise_errors,'
p6219
aS'                                        VectorTools::L2_norm);'
p6220
aS'    std::cout << "Errors: ||e_p||_L2 = " << p_l2_error'
p6221
aS'              << ",   ||e_u||_L2 = " << u_l2_error << std::endl;'
p6222
aS'  }'
p6223
aS'  template <int dim>'
p6224
aS'  void MixedLaplaceProblem<dim>::output_results() const'
p6225
aS'  {'
p6226
aS'    std::vector<std::string> solution_names(dim, "u");'
p6227
aS'    solution_names.emplace_back("p");'
p6228
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p6229
aS'      interpretation(dim,'
p6230
aS'                     DataComponentInterpretation::component_is_part_of_vector);'
p6231
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p6232
aS'    DataOut<dim> data_out;'
p6233
aS'    data_out.add_data_vector(dof_handler,'
p6234
aS'                             solution,'
p6235
aS'                             solution_names,'
p6236
aS'                             interpretation);'
p6237
aS'    data_out.build_patches(degree + 1);'
p6238
aS'    std::ofstream output("solution.vtu");'
p6239
aS'    data_out.write_vtu(output);'
p6240
aS'  }'
p6241
aS'  template <int dim>'
p6242
aS'  void MixedLaplaceProblem<dim>::run()'
p6243
aS'  {'
p6244
aS'    make_grid_and_dofs();'
p6245
aS'    assemble_system();'
p6246
aS'    solve();'
p6247
aS'    compute_errors();'
p6248
aS'    output_results();'
p6249
aS'  }'
p6250
aS'} // namespace Step20'
p6251
aS'int main()'
p6252
ag9
aS'  try'
p6253
aS'    {'
p6254
aS'      using namespace Step20;'
p6255
aS'      const unsigned int     fe_degree = 0;'
p6256
aS'      MixedLaplaceProblem<2> mixed_laplace_problem(fe_degree);'
p6257
aS'      mixed_laplace_problem.run();'
p6258
aS'    }'
p6259
aS'  catch (std::exception &exc)'
p6260
aS'    {'
p6261
aS'      std::cerr << std::endl'
p6262
aS'                << std::endl'
p6263
aS'                << "----------------------------------------------------"'
p6264
aS'                << std::endl;'
p6265
aS'      std::cerr << "Exception on processing: " << std::endl'
p6266
aS'                << exc.what() << std::endl'
p6267
aS'                << "Aborting!" << std::endl'
p6268
aS'                << "----------------------------------------------------"'
p6269
aS'                << std::endl;'
p6270
aS'      return 1;'
p6271
aS'    }'
p6272
aS'  catch (...)'
p6273
aS'    {'
p6274
aS'      std::cerr << std::endl'
p6275
aS'                << std::endl'
p6276
aS'                << "----------------------------------------------------"'
p6277
aS'                << std::endl;'
p6278
aS'      std::cerr << "Unknown exception!" << std::endl'
p6279
aS'                << "Aborting!" << std::endl'
p6280
aS'                << "----------------------------------------------------"'
p6281
aS'                << std::endl;'
p6282
aS'      return 1;'
p6283
aS'    }'
p6284
aS'  return 0;'
p6285
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p6286
aS'#include <deal.II/base/logstream.h>'
p6287
aS'#include <deal.II/base/function.h>'
p6288
aS'#include <deal.II/lac/block_vector.h>'
p6289
aS'#include <deal.II/lac/full_matrix.h>'
p6290
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p6291
aS'#include <deal.II/lac/solver_cg.h>'
p6292
aS'#include <deal.II/lac/precondition.h>'
p6293
aS'#include <deal.II/lac/affine_constraints.h>'
p6294
aS'#include <deal.II/grid/tria.h>'
p6295
aS'#include <deal.II/grid/grid_generator.h>'
p6296
aS'#include <deal.II/grid/grid_tools.h>'
p6297
aS'#include <deal.II/dofs/dof_handler.h>'
p6298
aS'#include <deal.II/dofs/dof_renumbering.h>'
p6299
aS'#include <deal.II/dofs/dof_tools.h>'
p6300
aS'#include <deal.II/fe/fe_raviart_thomas.h>'
p6301
aS'#include <deal.II/fe/fe_dgq.h>'
p6302
aS'#include <deal.II/fe/fe_system.h>'
p6303
aS'#include <deal.II/fe/fe_values.h>'
p6304
aS'#include <deal.II/numerics/vector_tools.h>'
p6305
aS'#include <deal.II/numerics/matrix_tools.h>'
p6306
aS'#include <deal.II/numerics/data_out.h>'
p6307
aS'#include <iostream>'
p6308
aS'#include <fstream>'
p6309
aS'#include <deal.II/base/tensor_function.h>'
p6310
aS'#include <deal.II/base/discrete_time.h>'
p6311
aS'namespace Step21'
p6312
ag9
aS'  using namespace dealii;'
p6313
aS'  template <int dim>'
p6314
aS'  class TwoPhaseFlowProblem'
p6315
aS'  {'
p6316
aS'  public:'
p6317
aS'    TwoPhaseFlowProblem(const unsigned int degree);'
p6318
aS'    void run();'
p6319
aS'  private:'
p6320
aS'    void   make_grid_and_dofs();'
p6321
aS'    void   assemble_system();'
p6322
aS'    void   assemble_rhs_S();'
p6323
aS'    double get_maximal_velocity() const;'
p6324
aS'    void   solve();'
p6325
aS'    void   project_back_saturation();'
p6326
aS'    void   output_results() const;'
p6327
aS'    const unsigned int degree;'
p6328
aS'    Triangulation<dim> triangulation;'
p6329
aS'    FESystem<dim>      fe;'
p6330
aS'    DoFHandler<dim>    dof_handler;'
p6331
aS'    BlockSparsityPattern      sparsity_pattern;'
p6332
aS'    BlockSparseMatrix<double> system_matrix;'
p6333
aS'    const unsigned int n_refinement_steps;'
p6334
aS'    DiscreteTime time;'
p6335
aS'    double       viscosity;'
p6336
aS'    BlockVector<double> solution;'
p6337
aS'    BlockVector<double> old_solution;'
p6338
aS'    BlockVector<double> system_rhs;'
p6339
aS'  };'
p6340
aS'  template <int dim>'
p6341
aS'  class PressureRightHandSide : public Function<dim>'
p6342
aS'  {'
p6343
aS'  public:'
p6344
aS'    PressureRightHandSide()'
p6345
aS'      : Function<dim>(1)'
p6346
aS'    {}'
p6347
aS'    virtual double value(const Point<dim> & /*p*/,'
p6348
aS'                         const unsigned int /*component*/ = 0) const override'
p6349
aS'    {'
p6350
aS'      return 0;'
p6351
aS'    }'
p6352
aS'  };'
p6353
aS'  template <int dim>'
p6354
aS'  class PressureBoundaryValues : public Function<dim>'
p6355
aS'  {'
p6356
aS'  public:'
p6357
aS'    PressureBoundaryValues()'
p6358
aS'      : Function<dim>(1)'
p6359
aS'    {}'
p6360
aS'    virtual double value(const Point<dim> &p,'
p6361
aS'                         const unsigned int /*component*/ = 0) const override'
p6362
aS'    {'
p6363
aS'      return 1 - p[0];'
p6364
aS'    }'
p6365
aS'  };'
p6366
aS'  template <int dim>'
p6367
aS'  class SaturationBoundaryValues : public Function<dim>'
p6368
aS'  {'
p6369
aS'  public:'
p6370
aS'    SaturationBoundaryValues()'
p6371
aS'      : Function<dim>(1)'
p6372
aS'    {}'
p6373
aS'    virtual double value(const Point<dim> &p,'
p6374
aS'                         const unsigned int /*component*/ = 0) const override'
p6375
aS'    {'
p6376
aS'      if (p[0] == 0)'
p6377
aS'        return 1;'
p6378
aS'      else'
p6379
aS'        return 0;'
p6380
aS'    }'
p6381
aS'  };'
p6382
aS'  template <int dim>'
p6383
aS'  class InitialValues : public Function<dim>'
p6384
aS'  {'
p6385
aS'  public:'
p6386
aS'    InitialValues()'
p6387
aS'      : Function<dim>(dim + 2)'
p6388
aS'    {}'
p6389
aS'    virtual double value(const Point<dim> & p,'
p6390
aS'                         const unsigned int component = 0) const override'
p6391
aS'    {'
p6392
aS'      return Functions::ZeroFunction<dim>(dim + 2).value(p, component);'
p6393
aS'    }'
p6394
aS'    virtual void vector_value(const Point<dim> &p,'
p6395
aS'                              Vector<double> &  values) const override'
p6396
aS'    {'
p6397
aS'      Functions::ZeroFunction<dim>(dim + 2).vector_value(p, values);'
p6398
aS'    }'
p6399
aS'  };'
p6400
aS'  namespace SingleCurvingCrack'
p6401
aS'  {'
p6402
aS'    template <int dim>'
p6403
aS'    class KInverse : public TensorFunction<2, dim>'
p6404
aS'    {'
p6405
aS'    public:'
p6406
aS'      KInverse()'
p6407
aS'        : TensorFunction<2, dim>()'
p6408
aS'      {}'
p6409
aS'      virtual void'
p6410
aS'      value_list(const std::vector<Point<dim>> &points,'
p6411
aS'                 std::vector<Tensor<2, dim>> &  values) const override'
p6412
aS'      {'
p6413
aS'        Assert(points.size() == values.size(),'
p6414
aS'               ExcDimensionMismatch(points.size(), values.size()));'
p6415
aS'        for (unsigned int p = 0; p < points.size(); ++p)'
p6416
aS'          {'
p6417
aS'            values[p].clear();'
p6418
aS'            const double distance_to_flowline ='
p6419
aS'              std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));'
p6420
aS'            const double permeability ='
p6421
aS'              std::max(std::exp(-(distance_to_flowline * distance_to_flowline) /'
p6422
aS'                       0.01);'
p6423
aS'            for (unsigned int d = 0; d < dim; ++d)'
p6424
aS'              values[p][d][d] = 1. / permeability;'
p6425
aS'          }'
p6426
aS'      }'
p6427
aS'    };'
p6428
aS'  } // namespace SingleCurvingCrack'
p6429
aS'  namespace RandomMedium'
p6430
aS'  {'
p6431
aS'    template <int dim>'
p6432
aS'    class KInverse : public TensorFunction<2, dim>'
p6433
aS'    {'
p6434
aS'    public:'
p6435
aS'      KInverse()'
p6436
aS'        : TensorFunction<2, dim>()'
p6437
aS'      {}'
p6438
aS'      virtual void'
p6439
aS'      value_list(const std::vector<Point<dim>> &points,'
p6440
aS'                 std::vector<Tensor<2, dim>> &  values) const override'
p6441
aS'      {'
p6442
aS'        Assert(points.size() == values.size(),'
p6443
aS'               ExcDimensionMismatch(points.size(), values.size()));'
p6444
aS'        for (unsigned int p = 0; p < points.size(); ++p)'
p6445
aS'          {'
p6446
aS'            values[p].clear();'
p6447
aS'            double permeability = 0;'
p6448
aS'            for (unsigned int i = 0; i < centers.size(); ++i)'
p6449
aS'              permeability += std::exp(-(points[p] - centers[i]).norm_square() /'
p6450
aS'            const double normalized_permeability ='
p6451
aS'              std::min(std::max(permeability, 0.01), 4.);'
p6452
aS'            for (unsigned int d = 0; d < dim; ++d)'
p6453
aS'              values[p][d][d] = 1. / normalized_permeability;'
p6454
aS'          }'
p6455
aS'      }'
p6456
aS'    private:'
p6457
aS'      static std::vector<Point<dim>> centers;'
p6458
aS'      static std::vector<Point<dim>> get_centers()'
p6459
aS'      {'
p6460
aS'        const unsigned int N ='
p6461
aS'        std::vector<Point<dim>> centers_list(N);'
p6462
aS'        for (unsigned int i = 0; i < N; ++i)'
p6463
aS'          for (unsigned int d = 0; d < dim; ++d)'
p6464
aS'            centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX;'
p6465
aS'        return centers_list;'
p6466
aS'      }'
p6467
aS'    };'
p6468
aS'    template <int dim>'
p6469
aS'    std::vector<Point<dim>>'
p6470
aS'      KInverse<dim>::centers = KInverse<dim>::get_centers();'
p6471
aS'  } // namespace RandomMedium'
p6472
aS'  double mobility_inverse(const double S, const double viscosity)'
p6473
aS'  {'
p6474
aS'    return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));'
p6475
aS'  }'
p6476
aS'  double fractional_flow(const double S, const double viscosity)'
p6477
aS'  {'
p6478
aS'    return S * S / (S * S + viscosity * (1 - S) * (1 - S));'
p6479
aS'  }'
p6480
aS'  template <class MatrixType>'
p6481
aS'  class InverseMatrix : public Subscriptor'
p6482
aS'  {'
p6483
aS'  public:'
p6484
aS'    InverseMatrix(const MatrixType &m)'
p6485
aS'      : matrix(&m)'
p6486
aS'    {}'
p6487
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const'
p6488
aS'    {'
p6489
aS'      SolverControl solver_control(std::max<unsigned int>(src.size(), 200),'
p6490
aS'                                   1e-8 * src.l2_norm());'
p6491
aS'      SolverCG<Vector<double>> cg(solver_control);'
p6492
aS'      dst = 0;'
p6493
aS'      cg.solve(*matrix, dst, src, PreconditionIdentity());'
p6494
aS'    }'
p6495
aS'  private:'
p6496
aS'    const SmartPointer<const MatrixType> matrix;'
p6497
aS'  };'
p6498
aS'  class SchurComplement : public Subscriptor'
p6499
aS'  {'
p6500
aS'  public:'
p6501
aS'    SchurComplement(const BlockSparseMatrix<double> &          A,'
p6502
aS'                    const InverseMatrix<SparseMatrix<double>> &Minv)'
p6503
aS'      : system_matrix(&A)'
p6504
aS'      , m_inverse(&Minv)'
p6505
aS'      , tmp1(A.block(0, 0).m())'
p6506
aS'      , tmp2(A.block(0, 0).m())'
p6507
aS'    {}'
p6508
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const'
p6509
aS'    {'
p6510
aS'      system_matrix->block(0, 1).vmult(tmp1, src);'
p6511
aS'      m_inverse->vmult(tmp2, tmp1);'
p6512
aS'      system_matrix->block(1, 0).vmult(dst, tmp2);'
p6513
aS'    }'
p6514
aS'  private:'
p6515
aS'    const SmartPointer<const BlockSparseMatrix<double>>           system_matrix;'
p6516
aS'    const SmartPointer<const InverseMatrix<SparseMatrix<double>>> m_inverse;'
p6517
aS'    mutable Vector<double> tmp1, tmp2;'
p6518
aS'  };'
p6519
aS'  class ApproximateSchurComplement : public Subscriptor'
p6520
aS'  {'
p6521
aS'  public:'
p6522
aS'    ApproximateSchurComplement(const BlockSparseMatrix<double> &A)'
p6523
aS'      : system_matrix(&A)'
p6524
aS'      , tmp1(A.block(0, 0).m())'
p6525
aS'      , tmp2(A.block(0, 0).m())'
p6526
aS'    {}'
p6527
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const'
p6528
aS'    {'
p6529
aS'      system_matrix->block(0, 1).vmult(tmp1, src);'
p6530
aS'      system_matrix->block(0, 0).precondition_Jacobi(tmp2, tmp1);'
p6531
aS'      system_matrix->block(1, 0).vmult(dst, tmp2);'
p6532
aS'    }'
p6533
aS'  private:'
p6534
aS'    const SmartPointer<const BlockSparseMatrix<double>> system_matrix;'
p6535
aS'    mutable Vector<double> tmp1, tmp2;'
p6536
aS'  };'
p6537
aS'  template <int dim>'
p6538
aS'  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree)'
p6539
aS'    : degree(degree)'
p6540
aS'    , fe(FE_RaviartThomas<dim>(degree),'
p6541
aS'         1,'
p6542
aS'         FE_DGQ<dim>(degree),'
p6543
aS'         1,'
p6544
aS'         FE_DGQ<dim>(degree),'
p6545
aS'         1)'
p6546
aS'    , dof_handler(triangulation)'
p6547
aS'    , n_refinement_steps(5)'
p6548
aS'    , time(/*start time*/ 0., /*end time*/ 1.)'
p6549
aS'    , viscosity(0.2)'
p6550
aS'  {}'
p6551
aS'  template <int dim>'
p6552
aS'  void TwoPhaseFlowProblem<dim>::make_grid_and_dofs()'
p6553
aS'  {'
p6554
aS'    GridGenerator::hyper_cube(triangulation, 0, 1);'
p6555
aS'    triangulation.refine_global(n_refinement_steps);'
p6556
aS'    dof_handler.distribute_dofs(fe);'
p6557
aS'    DoFRenumbering::component_wise(dof_handler);'
p6558
aS'    const std::vector<types::global_dof_index> dofs_per_component ='
p6559
aS'      DoFTools::count_dofs_per_fe_component(dof_handler);'
p6560
aS'    const unsigned int n_u = dofs_per_component[0],'
p6561
aS'                       n_p = dofs_per_component[dim],'
p6562
aS'                       n_s = dofs_per_component[dim + 1];'
p6563
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p6564
aS'              << std::endl'
p6565
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p6566
aS'              << " (" << n_u << \'+\' << n_p << \'+\' << n_s << \')\' << std::endl'
p6567
aS'              << std::endl;'
p6568
aS'    const unsigned int n_couplings = dof_handler.max_couplings_between_dofs();'
p6569
aS'    sparsity_pattern.reinit(3, 3);'
p6570
aS'    sparsity_pattern.block(0, 0).reinit(n_u, n_u, n_couplings);'
p6571
aS'    sparsity_pattern.block(1, 0).reinit(n_p, n_u, n_couplings);'
p6572
aS'    sparsity_pattern.block(2, 0).reinit(n_s, n_u, n_couplings);'
p6573
aS'    sparsity_pattern.block(0, 1).reinit(n_u, n_p, n_couplings);'
p6574
aS'    sparsity_pattern.block(1, 1).reinit(n_p, n_p, n_couplings);'
p6575
aS'    sparsity_pattern.block(2, 1).reinit(n_s, n_p, n_couplings);'
p6576
aS'    sparsity_pattern.block(0, 2).reinit(n_u, n_s, n_couplings);'
p6577
aS'    sparsity_pattern.block(1, 2).reinit(n_p, n_s, n_couplings);'
p6578
aS'    sparsity_pattern.block(2, 2).reinit(n_s, n_s, n_couplings);'
p6579
aS'    sparsity_pattern.collect_sizes();'
p6580
aS'    DoFTools::make_sparsity_pattern(dof_handler, sparsity_pattern);'
p6581
aS'    sparsity_pattern.compress();'
p6582
aS'    system_matrix.reinit(sparsity_pattern);'
p6583
aS'    solution.reinit(3);'
p6584
aS'    solution.block(0).reinit(n_u);'
p6585
aS'    solution.block(1).reinit(n_p);'
p6586
aS'    solution.block(2).reinit(n_s);'
p6587
aS'    solution.collect_sizes();'
p6588
aS'    old_solution.reinit(3);'
p6589
aS'    old_solution.block(0).reinit(n_u);'
p6590
aS'    old_solution.block(1).reinit(n_p);'
p6591
aS'    old_solution.block(2).reinit(n_s);'
p6592
aS'    old_solution.collect_sizes();'
p6593
aS'    system_rhs.reinit(3);'
p6594
aS'    system_rhs.block(0).reinit(n_u);'
p6595
aS'    system_rhs.block(1).reinit(n_p);'
p6596
aS'    system_rhs.block(2).reinit(n_s);'
p6597
aS'    system_rhs.collect_sizes();'
p6598
aS'  }'
p6599
aS'  template <int dim>'
p6600
aS'  void TwoPhaseFlowProblem<dim>::assemble_system()'
p6601
aS'  {'
p6602
aS'    system_matrix = 0;'
p6603
aS'    system_rhs    = 0;'
p6604
aS'    QGauss<dim>     quadrature_formula(degree + 2);'
p6605
aS'    QGauss<dim - 1> face_quadrature_formula(degree + 2);'
p6606
aS'    FEValues<dim>     fe_values(fe,'
p6607
aS'                            quadrature_formula,'
p6608
aS'                            update_values | update_gradients |'
p6609
aS'                              update_quadrature_points | update_JxW_values);'
p6610
aS'    FEFaceValues<dim> fe_face_values(fe,'
p6611
aS'                                     face_quadrature_formula,'
p6612
aS'                                     update_values | update_normal_vectors |'
p6613
aS'                                       update_quadrature_points |'
p6614
aS'                                       update_JxW_values);'
p6615
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p6616
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p6617
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p6618
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p6619
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p6620
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p6621
aS'    const PressureRightHandSide<dim>  pressure_right_hand_side;'
p6622
aS'    const PressureBoundaryValues<dim> pressure_boundary_values;'
p6623
aS'    const RandomMedium::KInverse<dim> k_inverse;'
p6624
aS'    std::vector<double>         pressure_rhs_values(n_q_points);'
p6625
aS'    std::vector<double>         boundary_values(n_face_q_points);'
p6626
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p6627
aS'    std::vector<Vector<double>>              old_solution_values(n_q_points,'
p6628
aS'                                                                 Vector<double>(dim + 2));'
p6629
aS'    std::vector<std::vector<Tensor<1, dim>>> old_solution_grads('
p6630
aS'      n_q_points, std::vector<Tensor<1, dim>>(dim + 2));'
p6631
aS'    const FEValuesExtractors::Vector velocities(0);'
p6632
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p6633
aS'    const FEValuesExtractors::Scalar saturation(dim + 1);'
p6634
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p6635
aS'      {'
p6636
aS'        fe_values.reinit(cell);'
p6637
aS'        local_matrix = 0;'
p6638
aS'        local_rhs    = 0;'
p6639
aS'        fe_values.get_function_values(old_solution, old_solution_values);'
p6640
aS'        pressure_right_hand_side.value_list(fe_values.get_quadrature_points(),'
p6641
aS'                                            pressure_rhs_values);'
p6642
aS'        k_inverse.value_list(fe_values.get_quadrature_points(),'
p6643
aS'                             k_inverse_values);'
p6644
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p6645
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6646
aS'            {'
p6647
aS'              const double old_s = old_solution_values[q](dim + 1);'
p6648
aS'              const Tensor<1, dim> phi_i_u = fe_values[velocities].value(i, q);'
p6649
aS'              const double div_phi_i_u = fe_values[velocities].divergence(i, q);'
p6650
aS'              const double phi_i_p     = fe_values[pressure].value(i, q);'
p6651
aS'              const double phi_i_s     = fe_values[saturation].value(i, q);'
p6652
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p6653
aS'                {'
p6654
aS'                  const Tensor<1, dim> phi_j_u ='
p6655
aS'                    fe_values[velocities].value(j, q);'
p6656
aS'                  const double div_phi_j_u ='
p6657
aS'                    fe_values[velocities].divergence(j, q);'
p6658
aS'                  const double phi_j_p = fe_values[pressure].value(j, q);'
p6659
aS'                  const double phi_j_s = fe_values[saturation].value(j, q);'
p6660
aS'                  local_matrix(i, j) +='
p6661
aS'                       mobility_inverse(old_s, viscosity) * phi_j_u -'
p6662
aS'                     div_phi_i_u * phi_j_p - phi_i_p * div_phi_j_u +'
p6663
aS'                     phi_i_s * phi_j_s) *'
p6664
aS'                    fe_values.JxW(q);'
p6665
aS'                }'
p6666
aS'              local_rhs(i) +='
p6667
aS'            }'
p6668
aS'        for (const auto &face : cell->face_iterators())'
p6669
aS'          if (face->at_boundary())'
p6670
aS'            {'
p6671
aS'              fe_face_values.reinit(cell, face);'
p6672
aS'              pressure_boundary_values.value_list('
p6673
aS'                fe_face_values.get_quadrature_points(), boundary_values);'
p6674
aS'              for (unsigned int q = 0; q < n_face_q_points; ++q)'
p6675
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6676
aS'                  {'
p6677
aS'                    const Tensor<1, dim> phi_i_u ='
p6678
aS'                      fe_face_values[velocities].value(i, q);'
p6679
aS'                    local_rhs(i) +='
p6680
aS'                      -(phi_i_u * fe_face_values.normal_vector(q) *'
p6681
aS'                        boundary_values[q] * fe_face_values.JxW(q));'
p6682
aS'                  }'
p6683
aS'            }'
p6684
aS'        cell->get_dof_indices(local_dof_indices);'
p6685
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6686
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p6687
aS'            system_matrix.add(local_dof_indices[i],'
p6688
aS'                              local_dof_indices[j],'
p6689
aS'                              local_matrix(i, j));'
p6690
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6691
aS'          system_rhs(local_dof_indices[i]) += local_rhs(i);'
p6692
aS'      }'
p6693
aS'  }'
p6694
aS'  template <int dim>'
p6695
aS'  void TwoPhaseFlowProblem<dim>::assemble_rhs_S()'
p6696
aS'  {'
p6697
aS'    QGauss<dim>       quadrature_formula(degree + 2);'
p6698
aS'    QGauss<dim - 1>   face_quadrature_formula(degree + 2);'
p6699
aS'    FEValues<dim>     fe_values(fe,'
p6700
aS'                            quadrature_formula,'
p6701
aS'                            update_values | update_gradients |'
p6702
aS'                              update_quadrature_points | update_JxW_values);'
p6703
aS'    FEFaceValues<dim> fe_face_values(fe,'
p6704
aS'                                     face_quadrature_formula,'
p6705
aS'                                     update_values | update_normal_vectors |'
p6706
aS'                                       update_quadrature_points |'
p6707
aS'                                       update_JxW_values);'
p6708
aS'    FEFaceValues<dim> fe_face_values_neighbor(fe,'
p6709
aS'                                              face_quadrature_formula,'
p6710
aS'                                              update_values);'
p6711
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p6712
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p6713
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p6714
aS'    Vector<double> local_rhs(dofs_per_cell);'
p6715
aS'    std::vector<Vector<double>> old_solution_values(n_q_points,'
p6716
aS'                                                    Vector<double>(dim + 2));'
p6717
aS'    std::vector<Vector<double>> old_solution_values_face(n_face_q_points,'
p6718
aS'                                                         Vector<double>(dim +'
p6719
aS'                                                                        2));'
p6720
aS'    std::vector<Vector<double>> old_solution_values_face_neighbor('
p6721
aS'      n_face_q_points, Vector<double>(dim + 2));'
p6722
aS'    std::vector<Vector<double>> present_solution_values(n_q_points,'
p6723
aS'                                                        Vector<double>(dim +'
p6724
aS'                                                                       2));'
p6725
aS'    std::vector<Vector<double>> present_solution_values_face('
p6726
aS'      n_face_q_points, Vector<double>(dim + 2));'
p6727
aS'    std::vector<double>                  neighbor_saturation(n_face_q_points);'
p6728
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p6729
aS'    SaturationBoundaryValues<dim> saturation_boundary_values;'
p6730
aS'    const FEValuesExtractors::Scalar saturation(dim + 1);'
p6731
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p6732
aS'      {'
p6733
aS'        local_rhs = 0;'
p6734
aS'        fe_values.reinit(cell);'
p6735
aS'        fe_values.get_function_values(old_solution, old_solution_values);'
p6736
aS'        fe_values.get_function_values(solution, present_solution_values);'
p6737
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p6738
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6739
aS'            {'
p6740
aS'              const double   old_s = old_solution_values[q](dim + 1);'
p6741
aS'              Tensor<1, dim> present_u;'
p6742
aS'              for (unsigned int d = 0; d < dim; ++d)'
p6743
aS'                present_u[d] = present_solution_values[q](d);'
p6744
aS'              const double         phi_i_s = fe_values[saturation].value(i, q);'
p6745
aS'              const Tensor<1, dim> grad_phi_i_s ='
p6746
aS'                fe_values[saturation].gradient(i, q);'
p6747
aS'              local_rhs(i) +='
p6748
aS'                   present_u * grad_phi_i_s +'
p6749
aS'                 old_s * phi_i_s) *'
p6750
aS'                fe_values.JxW(q);'
p6751
aS'            }'
p6752
aS'        for (const auto face_no : cell->face_indices())'
p6753
aS'          {'
p6754
aS'            fe_face_values.reinit(cell, face_no);'
p6755
aS'            fe_face_values.get_function_values(old_solution,'
p6756
aS'                                               old_solution_values_face);'
p6757
aS'            fe_face_values.get_function_values(solution,'
p6758
aS'                                               present_solution_values_face);'
p6759
aS'            if (cell->at_boundary(face_no))'
p6760
aS'              saturation_boundary_values.value_list('
p6761
aS'                fe_face_values.get_quadrature_points(), neighbor_saturation);'
p6762
aS'            else'
p6763
aS'              {'
p6764
aS'                const auto         neighbor = cell->neighbor(face_no);'
p6765
aS'                const unsigned int neighbor_face ='
p6766
aS'                  cell->neighbor_of_neighbor(face_no);'
p6767
aS'                fe_face_values_neighbor.reinit(neighbor, neighbor_face);'
p6768
aS'                fe_face_values_neighbor.get_function_values('
p6769
aS'                  old_solution, old_solution_values_face_neighbor);'
p6770
aS'                for (unsigned int q = 0; q < n_face_q_points; ++q)'
p6771
aS'                  neighbor_saturation[q] ='
p6772
aS'                    old_solution_values_face_neighbor[q](dim + 1);'
p6773
aS'              }'
p6774
aS'            for (unsigned int q = 0; q < n_face_q_points; ++q)'
p6775
aS'              {'
p6776
aS'                Tensor<1, dim> present_u_face;'
p6777
aS'                for (unsigned int d = 0; d < dim; ++d)'
p6778
aS'                  present_u_face[d] = present_solution_values_face[q](d);'
p6779
aS'                const double normal_flux ='
p6780
aS'                  present_u_face * fe_face_values.normal_vector(q);'
p6781
aS'                const bool is_outflow_q_point = (normal_flux >= 0);'
p6782
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6783
aS'                  local_rhs(i) -='
p6784
aS'                    time.get_next_step_size() * normal_flux *'
p6785
aS'                    fractional_flow((is_outflow_q_point == true ?'
p6786
aS'                                       old_solution_values_face[q](dim + 1) :'
p6787
aS'                                       neighbor_saturation[q]),'
p6788
aS'                                    viscosity) *'
p6789
aS'                    fe_face_values[saturation].value(i, q) *'
p6790
aS'                    fe_face_values.JxW(q);'
p6791
aS'              }'
p6792
aS'          }'
p6793
aS'        cell->get_dof_indices(local_dof_indices);'
p6794
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p6795
aS'          system_rhs(local_dof_indices[i]) += local_rhs(i);'
p6796
aS'      }'
p6797
aS'  }'
p6798
aS'  template <int dim>'
p6799
aS'  void TwoPhaseFlowProblem<dim>::solve()'
p6800
aS'  {'
p6801
aS'    const InverseMatrix<SparseMatrix<double>> m_inverse('
p6802
aS'      system_matrix.block(0, 0));'
p6803
aS'    Vector<double> tmp(solution.block(0).size());'
p6804
aS'    Vector<double> schur_rhs(solution.block(1).size());'
p6805
aS'    Vector<double> tmp2(solution.block(2).size());'
p6806
aS'    {'
p6807
aS'      m_inverse.vmult(tmp, system_rhs.block(0));'
p6808
aS'      system_matrix.block(1, 0).vmult(schur_rhs, tmp);'
p6809
aS'      schur_rhs -= system_rhs.block(1);'
p6810
aS'      SchurComplement schur_complement(system_matrix, m_inverse);'
p6811
aS'      ApproximateSchurComplement approximate_schur_complement(system_matrix);'
p6812
aS'      InverseMatrix<ApproximateSchurComplement> preconditioner('
p6813
aS'        approximate_schur_complement);'
p6814
aS'      SolverControl            solver_control(solution.block(1).size(),'
p6815
aS'                                   1e-12 * schur_rhs.l2_norm());'
p6816
aS'      SolverCG<Vector<double>> cg(solver_control);'
p6817
aS'      cg.solve(schur_complement, solution.block(1), schur_rhs, preconditioner);'
p6818
aS'      std::cout << "   " << solver_control.last_step()'
p6819
aS'                << " CG Schur complement iterations for pressure." << std::endl;'
p6820
aS'    }'
p6821
aS'    {'
p6822
aS'      system_matrix.block(0, 1).vmult(tmp, solution.block(1));'
p6823
aS'      tmp *= -1;'
p6824
aS'      tmp += system_rhs.block(0);'
p6825
aS'      m_inverse.vmult(solution.block(0), tmp);'
p6826
aS'    }'
p6827
aS'    time.set_desired_next_step_size(std::pow(0.5, double(n_refinement_steps)) /'
p6828
aS'                                    get_maximal_velocity());'
p6829
aS'    assemble_rhs_S();'
p6830
aS'    {'
p6831
aS'      SolverControl            solver_control(system_matrix.block(2, 2).m(),'
p6832
aS'                                   1e-8 * system_rhs.block(2).l2_norm());'
p6833
aS'      SolverCG<Vector<double>> cg(solver_control);'
p6834
aS'      cg.solve(system_matrix.block(2, 2),'
p6835
aS'               solution.block(2),'
p6836
aS'               system_rhs.block(2),'
p6837
aS'               PreconditionIdentity());'
p6838
aS'      project_back_saturation();'
p6839
aS'      std::cout << "   " << solver_control.last_step()'
p6840
aS'                << " CG iterations for saturation." << std::endl;'
p6841
aS'    }'
p6842
aS'    old_solution = solution;'
p6843
aS'  }'
p6844
aS'  template <int dim>'
p6845
aS'  void TwoPhaseFlowProblem<dim>::output_results() const'
p6846
aS'  {'
p6847
aS'    if (time.get_step_number() % 5 != 0)'
p6848
aS'      return;'
p6849
aS'    std::vector<std::string> solution_names;'
p6850
aS'    switch (dim)'
p6851
aS'      {'
p6852
aS'        case 2:'
p6853
aS'          solution_names = {"u", "v", "p", "S"};'
p6854
aS'          break;'
p6855
aS'        case 3:'
p6856
aS'          solution_names = {"u", "v", "w", "p", "S"};'
p6857
aS'          break;'
p6858
aS'        default:'
p6859
aS'          Assert(false, ExcNotImplemented());'
p6860
aS'      }'
p6861
aS'    DataOut<dim> data_out;'
p6862
aS'    data_out.attach_dof_handler(dof_handler);'
p6863
aS'    data_out.add_data_vector(solution, solution_names);'
p6864
aS'    data_out.build_patches(degree + 1);'
p6865
aS'    std::ofstream output("solution-" +'
p6866
aS'                         Utilities::int_to_string(time.get_step_number(), 4) +'
p6867
aS'                         ".vtk");'
p6868
aS'    data_out.write_vtk(output);'
p6869
aS'  }'
p6870
aS'  template <int dim>'
p6871
aS'  void TwoPhaseFlowProblem<dim>::project_back_saturation()'
p6872
aS'  {'
p6873
aS'    for (unsigned int i = 0; i < solution.block(2).size(); ++i)'
p6874
aS'      if (solution.block(2)(i) < 0)'
p6875
aS'        solution.block(2)(i) = 0;'
p6876
aS'      else if (solution.block(2)(i) > 1)'
p6877
aS'        solution.block(2)(i) = 1;'
p6878
aS'  }'
p6879
aS'  template <int dim>'
p6880
aS'  double TwoPhaseFlowProblem<dim>::get_maximal_velocity() const'
p6881
aS'  {'
p6882
aS'    QGauss<dim>        quadrature_formula(degree + 2);'
p6883
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p6884
aS'    FEValues<dim> fe_values(fe, quadrature_formula, update_values);'
p6885
aS'    std::vector<Vector<double>> solution_values(n_q_points,'
p6886
aS'                                                Vector<double>(dim + 2));'
p6887
aS'    double                      max_velocity = 0;'
p6888
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p6889
aS'      {'
p6890
aS'        fe_values.reinit(cell);'
p6891
aS'        fe_values.get_function_values(solution, solution_values);'
p6892
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p6893
aS'          {'
p6894
aS'            Tensor<1, dim> velocity;'
p6895
aS'            for (unsigned int i = 0; i < dim; ++i)'
p6896
aS'              velocity[i] = solution_values[q](i);'
p6897
aS'            max_velocity = std::max(max_velocity, velocity.norm());'
p6898
aS'          }'
p6899
aS'      }'
p6900
aS'    return max_velocity;'
p6901
aS'  }'
p6902
aS'  template <int dim>'
p6903
aS'  void TwoPhaseFlowProblem<dim>::run()'
p6904
aS'  {'
p6905
aS'    make_grid_and_dofs();'
p6906
aS'    {'
p6907
aS'      AffineConstraints<double> constraints;'
p6908
aS'      constraints.close();'
p6909
aS'      VectorTools::project(dof_handler,'
p6910
aS'                           constraints,'
p6911
aS'                           QGauss<dim>(degree + 2),'
p6912
aS'                           InitialValues<dim>(),'
p6913
aS'                           old_solution);'
p6914
aS'    }'
p6915
aS'    do'
p6916
aS'      {'
p6917
aS'        std::cout << "Timestep " << time.get_step_number() + 1 << std::endl;'
p6918
aS'        assemble_system();'
p6919
aS'        solve();'
p6920
aS'        output_results();'
p6921
aS'        time.advance_time();'
p6922
aS'        std::cout << "   Now at t=" << time.get_current_time()'
p6923
aS'                  << ", dt=" << time.get_previous_step_size() << \'.\''
p6924
aS'                  << std::endl'
p6925
aS'                  << std::endl;'
p6926
aS'      }'
p6927
aS'    while (time.is_at_end() == false);'
p6928
aS'  }'
p6929
aS'} // namespace Step21'
p6930
aS'int main()'
p6931
ag9
aS'  try'
p6932
aS'    {'
p6933
aS'      using namespace Step21;'
p6934
aS'      TwoPhaseFlowProblem<2> two_phase_flow_problem(0);'
p6935
aS'      two_phase_flow_problem.run();'
p6936
aS'    }'
p6937
aS'  catch (std::exception &exc)'
p6938
aS'    {'
p6939
aS'      std::cerr << std::endl'
p6940
aS'                << std::endl'
p6941
aS'                << "----------------------------------------------------"'
p6942
aS'                << std::endl;'
p6943
aS'      std::cerr << "Exception on processing: " << std::endl'
p6944
aS'                << exc.what() << std::endl'
p6945
aS'                << "Aborting!" << std::endl'
p6946
aS'                << "----------------------------------------------------"'
p6947
aS'                << std::endl;'
p6948
aS'      return 1;'
p6949
aS'    }'
p6950
aS'  catch (...)'
p6951
aS'    {'
p6952
aS'      std::cerr << std::endl'
p6953
aS'                << std::endl'
p6954
aS'                << "----------------------------------------------------"'
p6955
aS'                << std::endl;'
p6956
aS'      std::cerr << "Unknown exception!" << std::endl'
p6957
aS'                << "Aborting!" << std::endl'
p6958
aS'                << "----------------------------------------------------"'
p6959
aS'                << std::endl;'
p6960
aS'      return 1;'
p6961
aS'    }'
p6962
aS'  return 0;'
p6963
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p6964
aS'#include <deal.II/base/logstream.h>'
p6965
aS'#include <deal.II/base/function.h>'
p6966
aS'#include <deal.II/base/utilities.h>'
p6967
aS'#include <deal.II/lac/block_vector.h>'
p6968
aS'#include <deal.II/lac/full_matrix.h>'
p6969
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p6970
aS'#include <deal.II/lac/solver_cg.h>'
p6971
aS'#include <deal.II/lac/precondition.h>'
p6972
aS'#include <deal.II/lac/affine_constraints.h>'
p6973
aS'#include <deal.II/grid/tria.h>'
p6974
aS'#include <deal.II/grid/grid_generator.h>'
p6975
aS'#include <deal.II/grid/grid_tools.h>'
p6976
aS'#include <deal.II/grid/grid_refinement.h>'
p6977
aS'#include <deal.II/dofs/dof_handler.h>'
p6978
aS'#include <deal.II/dofs/dof_renumbering.h>'
p6979
aS'#include <deal.II/dofs/dof_tools.h>'
p6980
aS'#include <deal.II/fe/fe_q.h>'
p6981
aS'#include <deal.II/fe/fe_system.h>'
p6982
aS'#include <deal.II/fe/fe_values.h>'
p6983
aS'#include <deal.II/numerics/vector_tools.h>'
p6984
aS'#include <deal.II/numerics/matrix_tools.h>'
p6985
aS'#include <deal.II/numerics/data_out.h>'
p6986
aS'#include <deal.II/numerics/error_estimator.h>'
p6987
aS'#include <deal.II/lac/sparse_direct.h>'
p6988
aS'#include <deal.II/lac/sparse_ilu.h>'
p6989
aS'#include <iostream>'
p6990
aS'#include <fstream>'
p6991
aS'#include <memory>'
p6992
aS'namespace Step22'
p6993
ag9
aS'  using namespace dealii;'
p6994
aS'  template <int dim>'
p6995
aS'  struct InnerPreconditioner;'
p6996
aS'  template <>'
p6997
aS'  struct InnerPreconditioner<2>'
p6998
aS'  {'
p6999
aS'    using type = SparseDirectUMFPACK;'
p7000
aS'  };'
p7001
aS'  template <>'
p7002
aS'  struct InnerPreconditioner<3>'
p7003
aS'  {'
p7004
aS'    using type = SparseILU<double>;'
p7005
aS'  };'
p7006
aS'  template <int dim>'
p7007
aS'  class StokesProblem'
p7008
aS'  {'
p7009
aS'  public:'
p7010
aS'    StokesProblem(const unsigned int degree);'
p7011
aS'    void run();'
p7012
aS'  private:'
p7013
aS'    void setup_dofs();'
p7014
aS'    void assemble_system();'
p7015
aS'    void solve();'
p7016
aS'    void output_results(const unsigned int refinement_cycle) const;'
p7017
aS'    void refine_mesh();'
p7018
aS'    const unsigned int degree;'
p7019
aS'    Triangulation<dim> triangulation;'
p7020
aS'    FESystem<dim>      fe;'
p7021
aS'    DoFHandler<dim>    dof_handler;'
p7022
aS'    AffineConstraints<double> constraints;'
p7023
aS'    BlockSparsityPattern      sparsity_pattern;'
p7024
aS'    BlockSparseMatrix<double> system_matrix;'
p7025
aS'    BlockSparsityPattern      preconditioner_sparsity_pattern;'
p7026
aS'    BlockSparseMatrix<double> preconditioner_matrix;'
p7027
aS'    BlockVector<double> solution;'
p7028
aS'    BlockVector<double> system_rhs;'
p7029
aS'    std::shared_ptr<typename InnerPreconditioner<dim>::type> A_preconditioner;'
p7030
aS'  };'
p7031
aS'  template <int dim>'
p7032
aS'  class BoundaryValues : public Function<dim>'
p7033
aS'  {'
p7034
aS'  public:'
p7035
aS'    BoundaryValues()'
p7036
aS'      : Function<dim>(dim + 1)'
p7037
aS'    {}'
p7038
aS'    virtual double value(const Point<dim> & p,'
p7039
aS'                         const unsigned int component = 0) const override;'
p7040
aS'    virtual void vector_value(const Point<dim> &p,'
p7041
aS'                              Vector<double> &  value) const override;'
p7042
aS'  };'
p7043
aS'  template <int dim>'
p7044
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p7045
aS'                                    const unsigned int component) const'
p7046
aS'  {'
p7047
aS'    Assert(component < this->n_components,'
p7048
aS'           ExcIndexRange(component, 0, this->n_components));'
p7049
aS'    if (component == 0)'
p7050
aS'      return (p[0] < 0 ? -1 : (p[0] > 0 ? 1 : 0));'
p7051
aS'    return 0;'
p7052
aS'  }'
p7053
aS'  template <int dim>'
p7054
aS'  void BoundaryValues<dim>::vector_value(const Point<dim> &p,'
p7055
aS'                                         Vector<double> &  values) const'
p7056
aS'  {'
p7057
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p7058
aS'      values(c) = BoundaryValues<dim>::value(p, c);'
p7059
aS'  }'
p7060
aS'  template <int dim>'
p7061
aS'  class RightHandSide : public Function<dim>'
p7062
aS'  {'
p7063
aS'  public:'
p7064
aS'    RightHandSide()'
p7065
aS'      : Function<dim>(dim + 1)'
p7066
aS'    {}'
p7067
aS'    virtual double value(const Point<dim> & p,'
p7068
aS'                         const unsigned int component = 0) const override;'
p7069
aS'    virtual void vector_value(const Point<dim> &p,'
p7070
aS'                              Vector<double> &  value) const override;'
p7071
aS'  };'
p7072
aS'  template <int dim>'
p7073
aS'  double RightHandSide<dim>::value(const Point<dim> & /*p*/,'
p7074
aS'                                   const unsigned int /*component*/) const'
p7075
aS'  {'
p7076
aS'    return 0;'
p7077
aS'  }'
p7078
aS'  template <int dim>'
p7079
aS'  void RightHandSide<dim>::vector_value(const Point<dim> &p,'
p7080
aS'                                        Vector<double> &  values) const'
p7081
aS'  {'
p7082
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p7083
aS'      values(c) = RightHandSide<dim>::value(p, c);'
p7084
aS'  }'
p7085
aS'  template <class MatrixType, class PreconditionerType>'
p7086
aS'  class InverseMatrix : public Subscriptor'
p7087
aS'  {'
p7088
aS'  public:'
p7089
aS'    InverseMatrix(const MatrixType &        m,'
p7090
aS'                  const PreconditionerType &preconditioner);'
p7091
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const;'
p7092
aS'  private:'
p7093
aS'    const SmartPointer<const MatrixType>         matrix;'
p7094
aS'    const SmartPointer<const PreconditionerType> preconditioner;'
p7095
aS'  };'
p7096
aS'  template <class MatrixType, class PreconditionerType>'
p7097
aS'  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p7098
aS'    const MatrixType &        m,'
p7099
aS'    const PreconditionerType &preconditioner)'
p7100
aS'    : matrix(&m)'
p7101
aS'    , preconditioner(&preconditioner)'
p7102
aS'  {}'
p7103
aS'  template <class MatrixType, class PreconditionerType>'
p7104
aS'  void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p7105
aS'    Vector<double> &      dst,'
p7106
aS'    const Vector<double> &src) const'
p7107
aS'  {'
p7108
aS'    SolverControl            solver_control(src.size(), 1e-6 * src.l2_norm());'
p7109
aS'    SolverCG<Vector<double>> cg(solver_control);'
p7110
aS'    dst = 0;'
p7111
aS'    cg.solve(*matrix, dst, src, *preconditioner);'
p7112
aS'  }'
p7113
aS'  template <class PreconditionerType>'
p7114
aS'  class SchurComplement : public Subscriptor'
p7115
aS'  {'
p7116
aS'  public:'
p7117
aS'    SchurComplement('
p7118
aS'      const BlockSparseMatrix<double> &system_matrix,'
p7119
aS'      const InverseMatrix<SparseMatrix<double>, PreconditionerType> &A_inverse);'
p7120
aS'    void vmult(Vector<double> &dst, const Vector<double> &src) const;'
p7121
aS'  private:'
p7122
aS'    const SmartPointer<const BlockSparseMatrix<double>> system_matrix;'
p7123
aS'    const SmartPointer<'
p7124
aS'      const InverseMatrix<SparseMatrix<double>, PreconditionerType>>'
p7125
aS'      A_inverse;'
p7126
aS'    mutable Vector<double> tmp1, tmp2;'
p7127
aS'  };'
p7128
aS'  template <class PreconditionerType>'
p7129
aS'  SchurComplement<PreconditionerType>::SchurComplement('
p7130
aS'    const BlockSparseMatrix<double> &system_matrix,'
p7131
aS'    const InverseMatrix<SparseMatrix<double>, PreconditionerType> &A_inverse)'
p7132
aS'    : system_matrix(&system_matrix)'
p7133
aS'    , A_inverse(&A_inverse)'
p7134
aS'    , tmp1(system_matrix.block(0, 0).m())'
p7135
aS'    , tmp2(system_matrix.block(0, 0).m())'
p7136
aS'  {}'
p7137
aS'  template <class PreconditionerType>'
p7138
aS'  void'
p7139
aS'  SchurComplement<PreconditionerType>::vmult(Vector<double> &      dst,'
p7140
aS'                                             const Vector<double> &src) const'
p7141
aS'  {'
p7142
aS'    system_matrix->block(0, 1).vmult(tmp1, src);'
p7143
aS'    A_inverse->vmult(tmp2, tmp1);'
p7144
aS'    system_matrix->block(1, 0).vmult(dst, tmp2);'
p7145
aS'  }'
p7146
aS'  template <int dim>'
p7147
aS'  StokesProblem<dim>::StokesProblem(const unsigned int degree)'
p7148
aS'    : degree(degree)'
p7149
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p7150
aS'    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1)'
p7151
aS'    , dof_handler(triangulation)'
p7152
aS'  {}'
p7153
aS'  template <int dim>'
p7154
aS'  void StokesProblem<dim>::setup_dofs()'
p7155
aS'  {'
p7156
aS'    A_preconditioner.reset();'
p7157
aS'    system_matrix.clear();'
p7158
aS'    preconditioner_matrix.clear();'
p7159
aS'    dof_handler.distribute_dofs(fe);'
p7160
aS'    DoFRenumbering::Cuthill_McKee(dof_handler);'
p7161
aS'    std::vector<unsigned int> block_component(dim + 1, 0);'
p7162
aS'    block_component[dim] = 1;'
p7163
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p7164
aS'    {'
p7165
aS'      constraints.clear();'
p7166
aS'      FEValuesExtractors::Vector velocities(0);'
p7167
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p7168
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p7169
aS'                                               1,'
p7170
aS'                                               BoundaryValues<dim>(),'
p7171
aS'                                               constraints,'
p7172
aS'                                               fe.component_mask(velocities));'
p7173
aS'    }'
p7174
aS'    constraints.close();'
p7175
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p7176
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p7177
aS'    const unsigned int n_u = dofs_per_block[0];'
p7178
aS'    const unsigned int n_p = dofs_per_block[1];'
p7179
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p7180
aS'              << std::endl'
p7181
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p7182
aS'              << " (" << n_u << \'+\' << n_p << \')\' << std::endl;'
p7183
aS'    {'
p7184
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p7185
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p7186
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p7187
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p7188
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p7189
aS'      dsp.collect_sizes();'
p7190
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p7191
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p7192
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p7193
aS'          if (!((c == dim) && (d == dim)))'
p7194
aS'            coupling[c][d] = DoFTools::always;'
p7195
aS'          else'
p7196
aS'            coupling[c][d] = DoFTools::none;'
p7197
aS'      DoFTools::make_sparsity_pattern('
p7198
aS'        dof_handler, coupling, dsp, constraints, false);'
p7199
aS'      sparsity_pattern.copy_from(dsp);'
p7200
aS'    }'
p7201
aS'    {'
p7202
aS'      BlockDynamicSparsityPattern preconditioner_dsp(2, 2);'
p7203
aS'      preconditioner_dsp.block(0, 0).reinit(n_u, n_u);'
p7204
aS'      preconditioner_dsp.block(1, 0).reinit(n_p, n_u);'
p7205
aS'      preconditioner_dsp.block(0, 1).reinit(n_u, n_p);'
p7206
aS'      preconditioner_dsp.block(1, 1).reinit(n_p, n_p);'
p7207
aS'      preconditioner_dsp.collect_sizes();'
p7208
aS'      Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1);'
p7209
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p7210
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p7211
aS'          if (((c == dim) && (d == dim)))'
p7212
aS'            preconditioner_coupling[c][d] = DoFTools::always;'
p7213
aS'          else'
p7214
aS'            preconditioner_coupling[c][d] = DoFTools::none;'
p7215
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p7216
aS'                                      preconditioner_coupling,'
p7217
aS'                                      preconditioner_dsp,'
p7218
aS'                                      constraints,'
p7219
aS'                                      false);'
p7220
aS'      preconditioner_sparsity_pattern.copy_from(preconditioner_dsp);'
p7221
aS'    }'
p7222
aS'    system_matrix.reinit(sparsity_pattern);'
p7223
aS'    preconditioner_matrix.reinit(preconditioner_sparsity_pattern);'
p7224
aS'    solution.reinit(2);'
p7225
aS'    solution.block(0).reinit(n_u);'
p7226
aS'    solution.block(1).reinit(n_p);'
p7227
aS'    solution.collect_sizes();'
p7228
aS'    system_rhs.reinit(2);'
p7229
aS'    system_rhs.block(0).reinit(n_u);'
p7230
aS'    system_rhs.block(1).reinit(n_p);'
p7231
aS'    system_rhs.collect_sizes();'
p7232
aS'  }'
p7233
aS'  template <int dim>'
p7234
aS'  void StokesProblem<dim>::assemble_system()'
p7235
aS'  {'
p7236
aS'    system_matrix         = 0;'
p7237
aS'    system_rhs            = 0;'
p7238
aS'    preconditioner_matrix = 0;'
p7239
aS'    QGauss<dim> quadrature_formula(degree + 2);'
p7240
aS'    FEValues<dim> fe_values(fe,'
p7241
aS'                            quadrature_formula,'
p7242
aS'                            update_values | update_quadrature_points |'
p7243
aS'                              update_JxW_values | update_gradients);'
p7244
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p7245
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p7246
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p7247
aS'    FullMatrix<double> local_preconditioner_matrix(dofs_per_cell,'
p7248
aS'                                                   dofs_per_cell);'
p7249
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p7250
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p7251
aS'    const RightHandSide<dim>    right_hand_side;'
p7252
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p7253
aS'    const FEValuesExtractors::Vector velocities(0);'
p7254
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p7255
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p7256
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p7257
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p7258
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p7259
aS'      {'
p7260
aS'        fe_values.reinit(cell);'
p7261
aS'        local_matrix                = 0;'
p7262
aS'        local_preconditioner_matrix = 0;'
p7263
aS'        local_rhs                   = 0;'
p7264
aS'        right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p7265
aS'                                          rhs_values);'
p7266
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p7267
aS'          {'
p7268
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p7269
aS'              {'
p7270
aS'                symgrad_phi_u[k] ='
p7271
aS'                  fe_values[velocities].symmetric_gradient(k, q);'
p7272
aS'                div_phi_u[k] = fe_values[velocities].divergence(k, q);'
p7273
aS'                phi_p[k]     = fe_values[pressure].value(k, q);'
p7274
aS'              }'
p7275
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7276
aS'              {'
p7277
aS'                for (unsigned int j = 0; j <= i; ++j)'
p7278
aS'                  {'
p7279
aS'                    local_matrix(i, j) +='
p7280
aS'                       - div_phi_u[i] * phi_p[j]                 // (2)'
p7281
aS'                       - phi_p[i] * div_phi_u[j])                // (3)'
p7282
aS'                    local_preconditioner_matrix(i, j) +='
p7283
aS'                  }'
p7284
aS'                const unsigned int component_i ='
p7285
aS'                  fe.system_to_component_index(i).first;'
p7286
aS'                local_rhs(i) += (fe_values.shape_value(i, q)   // (phi_u_i(x_q)'
p7287
aS'              }'
p7288
aS'          }'
p7289
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7290
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p7291
aS'            {'
p7292
aS'              local_matrix(i, j) = local_matrix(j, i);'
p7293
aS'              local_preconditioner_matrix(i, j) ='
p7294
aS'                local_preconditioner_matrix(j, i);'
p7295
aS'            }'
p7296
aS'        cell->get_dof_indices(local_dof_indices);'
p7297
aS'        constraints.distribute_local_to_global(local_matrix,'
p7298
aS'                                               local_rhs,'
p7299
aS'                                               local_dof_indices,'
p7300
aS'                                               system_matrix,'
p7301
aS'                                               system_rhs);'
p7302
aS'        constraints.distribute_local_to_global(local_preconditioner_matrix,'
p7303
aS'                                               local_dof_indices,'
p7304
aS'                                               preconditioner_matrix);'
p7305
aS'      }'
p7306
aS'    std::cout << "   Computing preconditioner..." << std::endl << std::flush;'
p7307
aS'    A_preconditioner ='
p7308
aS'      std::make_shared<typename InnerPreconditioner<dim>::type>();'
p7309
aS'    A_preconditioner->initialize('
p7310
aS'      system_matrix.block(0, 0),'
p7311
aS'      typename InnerPreconditioner<dim>::type::AdditionalData());'
p7312
aS'  }'
p7313
aS'  template <int dim>'
p7314
aS'  void StokesProblem<dim>::solve()'
p7315
aS'  {'
p7316
aS'    const InverseMatrix<SparseMatrix<double>,'
p7317
aS'                        typename InnerPreconditioner<dim>::type>'
p7318
aS'                   A_inverse(system_matrix.block(0, 0), *A_preconditioner);'
p7319
aS'    Vector<double> tmp(solution.block(0).size());'
p7320
aS'    {'
p7321
aS'      Vector<double> schur_rhs(solution.block(1).size());'
p7322
aS'      A_inverse.vmult(tmp, system_rhs.block(0));'
p7323
aS'      system_matrix.block(1, 0).vmult(schur_rhs, tmp);'
p7324
aS'      schur_rhs -= system_rhs.block(1);'
p7325
aS'      SchurComplement<typename InnerPreconditioner<dim>::type> schur_complement('
p7326
aS'        system_matrix, A_inverse);'
p7327
aS'      SolverControl            solver_control(solution.block(1).size(),'
p7328
aS'                                   1e-6 * schur_rhs.l2_norm());'
p7329
aS'      SolverCG<Vector<double>> cg(solver_control);'
p7330
aS'      SparseILU<double> preconditioner;'
p7331
aS'      preconditioner.initialize(preconditioner_matrix.block(1, 1),'
p7332
aS'                                SparseILU<double>::AdditionalData());'
p7333
aS'      InverseMatrix<SparseMatrix<double>, SparseILU<double>> m_inverse('
p7334
aS'        preconditioner_matrix.block(1, 1), preconditioner);'
p7335
aS'      cg.solve(schur_complement, solution.block(1), schur_rhs, m_inverse);'
p7336
aS'      constraints.distribute(solution);'
p7337
aS'      std::cout << "  " << solver_control.last_step()'
p7338
aS'                << " outer CG Schur complement iterations for pressure"'
p7339
aS'                << std::endl;'
p7340
aS'    }'
p7341
aS'    {'
p7342
aS'      system_matrix.block(0, 1).vmult(tmp, solution.block(1));'
p7343
aS'      tmp *= -1;'
p7344
aS'      tmp += system_rhs.block(0);'
p7345
aS'      A_inverse.vmult(solution.block(0), tmp);'
p7346
aS'      constraints.distribute(solution);'
p7347
aS'    }'
p7348
aS'  }'
p7349
aS'  template <int dim>'
p7350
aS'  void'
p7351
aS'  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const'
p7352
aS'  {'
p7353
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p7354
aS'    solution_names.emplace_back("pressure");'
p7355
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p7356
aS'      data_component_interpretation('
p7357
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p7358
aS'    data_component_interpretation.push_back('
p7359
aS'      DataComponentInterpretation::component_is_scalar);'
p7360
aS'    DataOut<dim> data_out;'
p7361
aS'    data_out.attach_dof_handler(dof_handler);'
p7362
aS'    data_out.add_data_vector(solution,'
p7363
aS'                             solution_names,'
p7364
aS'                             DataOut<dim>::type_dof_data,'
p7365
aS'                             data_component_interpretation);'
p7366
aS'    data_out.build_patches();'
p7367
aS'    std::ofstream output('
p7368
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk");'
p7369
aS'    data_out.write_vtk(output);'
p7370
aS'  }'
p7371
aS'  template <int dim>'
p7372
aS'  void StokesProblem<dim>::refine_mesh()'
p7373
aS'  {'
p7374
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p7375
aS'    FEValuesExtractors::Scalar pressure(dim);'
p7376
aS'    KellyErrorEstimator<dim>::estimate('
p7377
aS'      dof_handler,'
p7378
aS'      QGauss<dim - 1>(degree + 1),'
p7379
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p7380
aS'      solution,'
p7381
aS'      estimated_error_per_cell,'
p7382
aS'      fe.component_mask(pressure));'
p7383
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p7384
aS'                                                    estimated_error_per_cell,'
p7385
aS'                                                    0.3,'
p7386
aS'                                                    0.0);'
p7387
aS'    triangulation.execute_coarsening_and_refinement();'
p7388
aS'  }'
p7389
aS'  template <int dim>'
p7390
aS'  void StokesProblem<dim>::run()'
p7391
aS'  {'
p7392
aS'    {'
p7393
aS'      std::vector<unsigned int> subdivisions(dim, 1);'
p7394
aS'      subdivisions[0] = 4;'
p7395
aS'      const Point<dim> bottom_left = (dim == 2 ?                //'
p7396
aS'                                        Point<dim>(-2, -1) :    // 2d case'
p7397
aS'                                        Point<dim>(-2, 0, -1)); // 3d case'
p7398
aS'      const Point<dim> top_right = (dim == 2 ?              //'
p7399
aS'                                      Point<dim>(2, 0) :    // 2d case'
p7400
aS'                                      Point<dim>(2, 1, 0)); // 3d case'
p7401
aS'      GridGenerator::subdivided_hyper_rectangle(triangulation,'
p7402
aS'                                                subdivisions,'
p7403
aS'                                                bottom_left,'
p7404
aS'                                                top_right);'
p7405
aS'    }'
p7406
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p7407
aS'      for (const auto &face : cell->face_iterators())'
p7408
aS'        if (face->center()[dim - 1] == 0)'
p7409
aS'          face->set_all_boundary_ids(1);'
p7410
aS'    triangulation.refine_global(4 - dim);'
p7411
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 6;'
p7412
aS'         ++refinement_cycle)'
p7413
aS'      {'
p7414
aS'        std::cout << "Refinement cycle " << refinement_cycle << std::endl;'
p7415
aS'        if (refinement_cycle > 0)'
p7416
aS'          refine_mesh();'
p7417
aS'        setup_dofs();'
p7418
aS'        std::cout << "   Assembling..." << std::endl << std::flush;'
p7419
aS'        assemble_system();'
p7420
aS'        std::cout << "   Solving..." << std::flush;'
p7421
aS'        solve();'
p7422
aS'        output_results(refinement_cycle);'
p7423
aS'        std::cout << std::endl;'
p7424
aS'      }'
p7425
aS'  }'
p7426
aS'} // namespace Step22'
p7427
aS'int main()'
p7428
ag9
aS'  try'
p7429
aS'    {'
p7430
aS'      using namespace Step22;'
p7431
aS'      StokesProblem<2> flow_problem(1);'
p7432
aS'      flow_problem.run();'
p7433
aS'    }'
p7434
aS'  catch (std::exception &exc)'
p7435
aS'    {'
p7436
aS'      std::cerr << std::endl'
p7437
aS'                << std::endl'
p7438
aS'                << "----------------------------------------------------"'
p7439
aS'                << std::endl;'
p7440
aS'      std::cerr << "Exception on processing: " << std::endl'
p7441
aS'                << exc.what() << std::endl'
p7442
aS'                << "Aborting!" << std::endl'
p7443
aS'                << "----------------------------------------------------"'
p7444
aS'                << std::endl;'
p7445
aS'      return 1;'
p7446
aS'    }'
p7447
aS'  catch (...)'
p7448
aS'    {'
p7449
aS'      std::cerr << std::endl'
p7450
aS'                << std::endl'
p7451
aS'                << "----------------------------------------------------"'
p7452
aS'                << std::endl;'
p7453
aS'      std::cerr << "Unknown exception!" << std::endl'
p7454
aS'                << "Aborting!" << std::endl'
p7455
aS'                << "----------------------------------------------------"'
p7456
aS'                << std::endl;'
p7457
aS'      return 1;'
p7458
aS'    }'
p7459
aS'  return 0;'
p7460
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p7461
aS'#include <deal.II/base/function.h>'
p7462
aS'#include <deal.II/lac/vector.h>'
p7463
aS'#include <deal.II/lac/sparse_matrix.h>'
p7464
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p7465
aS'#include <deal.II/lac/solver_cg.h>'
p7466
aS'#include <deal.II/lac/precondition.h>'
p7467
aS'#include <deal.II/lac/affine_constraints.h>'
p7468
aS'#include <deal.II/grid/tria.h>'
p7469
aS'#include <deal.II/grid/grid_generator.h>'
p7470
aS'#include <deal.II/dofs/dof_handler.h>'
p7471
aS'#include <deal.II/dofs/dof_tools.h>'
p7472
aS'#include <deal.II/fe/fe_q.h>'
p7473
aS'#include <deal.II/numerics/data_out.h>'
p7474
aS'#include <fstream>'
p7475
aS'#include <iostream>'
p7476
aS'#include <deal.II/numerics/vector_tools.h>'
p7477
aS'#include <deal.II/numerics/matrix_tools.h>'
p7478
aS'#include <deal.II/base/utilities.h>'
p7479
aS'namespace Step23'
p7480
ag9
aS'  using namespace dealii;'
p7481
aS'  template <int dim>'
p7482
aS'  class WaveEquation'
p7483
aS'  {'
p7484
aS'  public:'
p7485
aS'    WaveEquation();'
p7486
aS'    void run();'
p7487
aS'  private:'
p7488
aS'    void setup_system();'
p7489
aS'    void solve_u();'
p7490
aS'    void solve_v();'
p7491
aS'    void output_results() const;'
p7492
aS'    Triangulation<dim> triangulation;'
p7493
aS'    FE_Q<dim>          fe;'
p7494
aS'    DoFHandler<dim>    dof_handler;'
p7495
aS'    AffineConstraints<double> constraints;'
p7496
aS'    SparsityPattern      sparsity_pattern;'
p7497
aS'    SparseMatrix<double> mass_matrix;'
p7498
aS'    SparseMatrix<double> laplace_matrix;'
p7499
aS'    SparseMatrix<double> matrix_u;'
p7500
aS'    SparseMatrix<double> matrix_v;'
p7501
aS'    Vector<double> solution_u, solution_v;'
p7502
aS'    Vector<double> old_solution_u, old_solution_v;'
p7503
aS'    Vector<double> system_rhs;'
p7504
aS'    double       time_step;'
p7505
aS'    double       time;'
p7506
aS'    unsigned int timestep_number;'
p7507
aS'    const double theta;'
p7508
aS'  };'
p7509
aS'  template <int dim>'
p7510
aS'  class InitialValuesU : public Function<dim>'
p7511
aS'  {'
p7512
aS'  public:'
p7513
aS'    virtual double value(const Point<dim> & /*p*/,'
p7514
aS'                         const unsigned int component = 0) const override'
p7515
aS'    {'
p7516
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7517
aS'      return 0;'
p7518
aS'    }'
p7519
aS'  };'
p7520
aS'  template <int dim>'
p7521
aS'  class InitialValuesV : public Function<dim>'
p7522
aS'  {'
p7523
aS'  public:'
p7524
aS'    virtual double value(const Point<dim> & /*p*/,'
p7525
aS'                         const unsigned int component = 0) const override'
p7526
aS'    {'
p7527
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7528
aS'      return 0;'
p7529
aS'    }'
p7530
aS'  };'
p7531
aS'  template <int dim>'
p7532
aS'  class RightHandSide : public Function<dim>'
p7533
aS'  {'
p7534
aS'  public:'
p7535
aS'    virtual double value(const Point<dim> & /*p*/,'
p7536
aS'                         const unsigned int component = 0) const override'
p7537
aS'    {'
p7538
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7539
aS'      return 0;'
p7540
aS'    }'
p7541
aS'  };'
p7542
aS'  template <int dim>'
p7543
aS'  class BoundaryValuesU : public Function<dim>'
p7544
aS'  {'
p7545
aS'  public:'
p7546
aS'    virtual double value(const Point<dim> & p,'
p7547
aS'                         const unsigned int component = 0) const override'
p7548
aS'    {'
p7549
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7550
aS'      if ((this->get_time() <= 0.5) && (p[0] < 0) && (p[1] < 1. / 3) &&'
p7551
aS'        return std::sin(this->get_time() * 4 * numbers::PI);'
p7552
aS'      else'
p7553
aS'        return 0;'
p7554
aS'    }'
p7555
aS'  };'
p7556
aS'  template <int dim>'
p7557
aS'  class BoundaryValuesV : public Function<dim>'
p7558
aS'  {'
p7559
aS'  public:'
p7560
aS'    virtual double value(const Point<dim> & p,'
p7561
aS'                         const unsigned int component = 0) const override'
p7562
aS'    {'
p7563
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p7564
aS'      if ((this->get_time() <= 0.5) && (p[0] < 0) && (p[1] < 1. / 3) &&'
p7565
aS'        return (std::cos(this->get_time() * 4 * numbers::PI) * 4 * numbers::PI);'
p7566
aS'      else'
p7567
aS'        return 0;'
p7568
aS'    }'
p7569
aS'  };'
p7570
aS'  template <int dim>'
p7571
aS'  WaveEquation<dim>::WaveEquation()'
p7572
aS'    : fe(1)'
p7573
aS'    , dof_handler(triangulation)'
p7574
aS'    , time_step(1. / 64)'
p7575
aS'    , time(time_step)'
p7576
aS'    , timestep_number(1)'
p7577
aS'    , theta(0.5)'
p7578
aS'  {}'
p7579
aS'  template <int dim>'
p7580
aS'  void WaveEquation<dim>::setup_system()'
p7581
aS'  {'
p7582
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p7583
aS'    triangulation.refine_global(7);'
p7584
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p7585
aS'              << std::endl;'
p7586
aS'    dof_handler.distribute_dofs(fe);'
p7587
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p7588
aS'              << std::endl'
p7589
aS'              << std::endl;'
p7590
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p7591
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p7592
aS'    sparsity_pattern.copy_from(dsp);'
p7593
aS'    mass_matrix.reinit(sparsity_pattern);'
p7594
aS'    laplace_matrix.reinit(sparsity_pattern);'
p7595
aS'    matrix_u.reinit(sparsity_pattern);'
p7596
aS'    matrix_v.reinit(sparsity_pattern);'
p7597
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p7598
aS'                                      QGauss<dim>(fe.degree + 1),'
p7599
aS'                                      mass_matrix);'
p7600
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p7601
aS'                                         QGauss<dim>(fe.degree + 1),'
p7602
aS'                                         laplace_matrix);'
p7603
aS'    solution_u.reinit(dof_handler.n_dofs());'
p7604
aS'    solution_v.reinit(dof_handler.n_dofs());'
p7605
aS'    old_solution_u.reinit(dof_handler.n_dofs());'
p7606
aS'    old_solution_v.reinit(dof_handler.n_dofs());'
p7607
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p7608
aS'    constraints.close();'
p7609
aS'  }'
p7610
aS'  template <int dim>'
p7611
aS'  void WaveEquation<dim>::solve_u()'
p7612
aS'  {'
p7613
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p7614
aS'    SolverCG<Vector<double>> cg(solver_control);'
p7615
aS'    cg.solve(matrix_u, solution_u, system_rhs, PreconditionIdentity());'
p7616
aS'    std::cout << "   u-equation: " << solver_control.last_step()'
p7617
aS'              << " CG iterations." << std::endl;'
p7618
aS'  }'
p7619
aS'  template <int dim>'
p7620
aS'  void WaveEquation<dim>::solve_v()'
p7621
aS'  {'
p7622
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p7623
aS'    SolverCG<Vector<double>> cg(solver_control);'
p7624
aS'    cg.solve(matrix_v, solution_v, system_rhs, PreconditionIdentity());'
p7625
aS'    std::cout << "   v-equation: " << solver_control.last_step()'
p7626
aS'              << " CG iterations." << std::endl;'
p7627
aS'  }'
p7628
aS'  template <int dim>'
p7629
aS'  void WaveEquation<dim>::output_results() const'
p7630
aS'  {'
p7631
aS'    DataOut<dim> data_out;'
p7632
aS'    data_out.attach_dof_handler(dof_handler);'
p7633
aS'    data_out.add_data_vector(solution_u, "U");'
p7634
aS'    data_out.add_data_vector(solution_v, "V");'
p7635
aS'    data_out.build_patches();'
p7636
aS'    const std::string filename ='
p7637
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p7638
aS'    DataOutBase::VtkFlags vtk_flags;'
p7639
aS'    vtk_flags.compression_level ='
p7640
aS'      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p7641
aS'    data_out.set_flags(vtk_flags);'
p7642
aS'    std::ofstream output(filename);'
p7643
aS'    data_out.write_vtu(output);'
p7644
aS'  }'
p7645
aS'  template <int dim>'
p7646
aS'  void WaveEquation<dim>::run()'
p7647
aS'  {'
p7648
aS'    setup_system();'
p7649
aS'    VectorTools::project(dof_handler,'
p7650
aS'                         constraints,'
p7651
aS'                         QGauss<dim>(fe.degree + 1),'
p7652
aS'                         InitialValuesU<dim>(),'
p7653
aS'                         old_solution_u);'
p7654
aS'    VectorTools::project(dof_handler,'
p7655
aS'                         constraints,'
p7656
aS'                         QGauss<dim>(fe.degree + 1),'
p7657
aS'                         InitialValuesV<dim>(),'
p7658
aS'                         old_solution_v);'
p7659
aS'    Vector<double> tmp(solution_u.size());'
p7660
aS'    Vector<double> forcing_terms(solution_u.size());'
p7661
aS'    for (; time <= 5; time += time_step, ++timestep_number)'
p7662
aS'      {'
p7663
aS'        std::cout << "Time step " << timestep_number << " at t=" << time'
p7664
aS'                  << std::endl;'
p7665
aS'        mass_matrix.vmult(system_rhs, old_solution_u);'
p7666
aS'        mass_matrix.vmult(tmp, old_solution_v);'
p7667
aS'        system_rhs.add(time_step, tmp);'
p7668
aS'        laplace_matrix.vmult(tmp, old_solution_u);'
p7669
aS'        system_rhs.add(-theta * (1 - theta) * time_step * time_step, tmp);'
p7670
aS'        RightHandSide<dim> rhs_function;'
p7671
aS'        rhs_function.set_time(time);'
p7672
aS'        VectorTools::create_right_hand_side(dof_handler,'
p7673
aS'                                            QGauss<dim>(fe.degree + 1),'
p7674
aS'                                            rhs_function,'
p7675
aS'                                            tmp);'
p7676
aS'        forcing_terms = tmp;'
p7677
aS'        forcing_terms *= theta * time_step;'
p7678
aS'        rhs_function.set_time(time - time_step);'
p7679
aS'        VectorTools::create_right_hand_side(dof_handler,'
p7680
aS'                                            QGauss<dim>(fe.degree + 1),'
p7681
aS'                                            rhs_function,'
p7682
aS'                                            tmp);'
p7683
aS'        forcing_terms.add((1 - theta) * time_step, tmp);'
p7684
aS'        system_rhs.add(theta * time_step, forcing_terms);'
p7685
aS'        {'
p7686
aS'          BoundaryValuesU<dim> boundary_values_u_function;'
p7687
aS'          boundary_values_u_function.set_time(time);'
p7688
aS'          std::map<types::global_dof_index, double> boundary_values;'
p7689
aS'          VectorTools::interpolate_boundary_values(dof_handler,'
p7690
aS'                                                   0,'
p7691
aS'                                                   boundary_values_u_function,'
p7692
aS'                                                   boundary_values);'
p7693
aS'          matrix_u.copy_from(mass_matrix);'
p7694
aS'          matrix_u.add(theta * theta * time_step * time_step, laplace_matrix);'
p7695
aS'          MatrixTools::apply_boundary_values(boundary_values,'
p7696
aS'                                             matrix_u,'
p7697
aS'                                             solution_u,'
p7698
aS'                                             system_rhs);'
p7699
aS'        }'
p7700
aS'        solve_u();'
p7701
aS'        laplace_matrix.vmult(system_rhs, solution_u);'
p7702
aS'        system_rhs *= -theta * time_step;'
p7703
aS'        mass_matrix.vmult(tmp, old_solution_v);'
p7704
aS'        system_rhs += tmp;'
p7705
aS'        laplace_matrix.vmult(tmp, old_solution_u);'
p7706
aS'        system_rhs.add(-time_step * (1 - theta), tmp);'
p7707
aS'        system_rhs += forcing_terms;'
p7708
aS'        {'
p7709
aS'          BoundaryValuesV<dim> boundary_values_v_function;'
p7710
aS'          boundary_values_v_function.set_time(time);'
p7711
aS'          std::map<types::global_dof_index, double> boundary_values;'
p7712
aS'          VectorTools::interpolate_boundary_values(dof_handler,'
p7713
aS'                                                   0,'
p7714
aS'                                                   boundary_values_v_function,'
p7715
aS'                                                   boundary_values);'
p7716
aS'          matrix_v.copy_from(mass_matrix);'
p7717
aS'          MatrixTools::apply_boundary_values(boundary_values,'
p7718
aS'                                             matrix_v,'
p7719
aS'                                             solution_v,'
p7720
aS'                                             system_rhs);'
p7721
aS'        }'
p7722
aS'        solve_v();'
p7723
aS'        output_results();'
p7724
aS'        std::cout << "   Total energy: "'
p7725
aS'                  << (mass_matrix.matrix_norm_square(solution_v) +'
p7726
aS'                      laplace_matrix.matrix_norm_square(solution_u)) /'
p7727
aS'                       2'
p7728
aS'                  << std::endl;'
p7729
aS'        old_solution_u = solution_u;'
p7730
aS'        old_solution_v = solution_v;'
p7731
aS'      }'
p7732
aS'  }'
p7733
aS'} // namespace Step23'
p7734
aS'int main()'
p7735
ag9
aS'  try'
p7736
aS'    {'
p7737
aS'      using namespace Step23;'
p7738
aS'      WaveEquation<2> wave_equation_solver;'
p7739
aS'      wave_equation_solver.run();'
p7740
aS'    }'
p7741
aS'  catch (std::exception &exc)'
p7742
aS'    {'
p7743
aS'      std::cerr << std::endl'
p7744
aS'                << std::endl'
p7745
aS'                << "----------------------------------------------------"'
p7746
aS'                << std::endl;'
p7747
aS'      std::cerr << "Exception on processing: " << std::endl'
p7748
aS'                << exc.what() << std::endl'
p7749
aS'                << "Aborting!" << std::endl'
p7750
aS'                << "----------------------------------------------------"'
p7751
aS'                << std::endl;'
p7752
aS'      return 1;'
p7753
aS'    }'
p7754
aS'  catch (...)'
p7755
aS'    {'
p7756
aS'      std::cerr << std::endl'
p7757
aS'                << std::endl'
p7758
aS'                << "----------------------------------------------------"'
p7759
aS'                << std::endl;'
p7760
aS'      std::cerr << "Unknown exception!" << std::endl'
p7761
aS'                << "Aborting!" << std::endl'
p7762
aS'                << "----------------------------------------------------"'
p7763
aS'                << std::endl;'
p7764
aS'      return 1;'
p7765
aS'    }'
p7766
aS'  return 0;'
p7767
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p7768
aS'#include <deal.II/base/function.h>'
p7769
aS'#include <deal.II/base/logstream.h>'
p7770
aS'#include <deal.II/base/utilities.h>'
p7771
aS'#include <deal.II/lac/vector.h>'
p7772
aS'#include <deal.II/lac/full_matrix.h>'
p7773
aS'#include <deal.II/lac/sparse_matrix.h>'
p7774
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p7775
aS'#include <deal.II/lac/solver_cg.h>'
p7776
aS'#include <deal.II/lac/precondition.h>'
p7777
aS'#include <deal.II/lac/affine_constraints.h>'
p7778
aS'#include <deal.II/grid/tria.h>'
p7779
aS'#include <deal.II/grid/grid_generator.h>'
p7780
aS'#include <deal.II/dofs/dof_handler.h>'
p7781
aS'#include <deal.II/dofs/dof_tools.h>'
p7782
aS'#include <deal.II/fe/fe_q.h>'
p7783
aS'#include <deal.II/fe/fe_values.h>'
p7784
aS'#include <deal.II/numerics/data_out.h>'
p7785
aS'#include <deal.II/numerics/matrix_tools.h>'
p7786
aS'#include <deal.II/numerics/vector_tools.h>'
p7787
aS'#include <fstream>'
p7788
aS'#include <iostream>'
p7789
aS'#include <deal.II/grid/grid_tools.h>'
p7790
aS'namespace Step24'
p7791
ag9
aS'  using namespace dealii;'
p7792
aS'  template <int dim>'
p7793
aS'  class TATForwardProblem'
p7794
aS'  {'
p7795
aS'  public:'
p7796
aS'    TATForwardProblem();'
p7797
aS'    void run();'
p7798
aS'  private:'
p7799
aS'    void setup_system();'
p7800
aS'    void solve_p();'
p7801
aS'    void solve_v();'
p7802
aS'    void output_results() const;'
p7803
aS'    Triangulation<dim> triangulation;'
p7804
aS'    FE_Q<dim>          fe;'
p7805
aS'    DoFHandler<dim>    dof_handler;'
p7806
aS'    AffineConstraints<double> constraints;'
p7807
aS'    SparsityPattern      sparsity_pattern;'
p7808
aS'    SparseMatrix<double> system_matrix;'
p7809
aS'    SparseMatrix<double> mass_matrix;'
p7810
aS'    SparseMatrix<double> laplace_matrix;'
p7811
aS'    Vector<double> solution_p, solution_v;'
p7812
aS'    Vector<double> old_solution_p, old_solution_v;'
p7813
aS'    Vector<double> system_rhs_p, system_rhs_v;'
p7814
aS'    double       time_step, time;'
p7815
aS'    unsigned int timestep_number;'
p7816
aS'    const double theta;'
p7817
aS'    SparseMatrix<double> boundary_matrix;'
p7818
aS'    const double         wave_speed;'
p7819
aS'    std::vector<Point<dim>> detector_locations;'
p7820
aS'  };'
p7821
aS'  template <int dim>'
p7822
aS'  class InitialValuesP : public Function<dim>'
p7823
aS'  {'
p7824
aS'  public:'
p7825
aS'    virtual double value(const Point<dim> &p,'
p7826
aS'                         const unsigned int /*component*/ = 0) const override'
p7827
aS'    {'
p7828
aS'      static const std::array<Source, 5> sources{'
p7829
aS'        {Source(Point<dim>(0, 0), 0.025),'
p7830
aS'         Source(Point<dim>(-0.135, 0), 0.05),'
p7831
aS'         Source(Point<dim>(0.17, 0), 0.03),'
p7832
aS'         Source(Point<dim>(-0.25, 0), 0.02),'
p7833
aS'         Source(Point<dim>(-0.05, -0.15), 0.015)}};'
p7834
aS'      for (const auto &source : sources)'
p7835
aS'        if (p.distance(source.location) < source.radius)'
p7836
aS'          return 1;'
p7837
aS'      return 0;'
p7838
aS'    }'
p7839
aS'  private:'
p7840
aS'    struct Source'
p7841
aS'    {'
p7842
aS'      Source(const Point<dim> &l, const double r)'
p7843
aS'        : location(l)'
p7844
aS'        , radius(r)'
p7845
aS'      {}'
p7846
aS'      const Point<dim> location;'
p7847
aS'      const double     radius;'
p7848
aS'    };'
p7849
aS'  };'
p7850
aS'  template <int dim>'
p7851
aS'  TATForwardProblem<dim>::TATForwardProblem()'
p7852
aS'    : fe(1)'
p7853
aS'    , dof_handler(triangulation)'
p7854
aS'    , time_step(std::numeric_limits<double>::quiet_NaN())'
p7855
aS'    , time(time_step)'
p7856
aS'    , timestep_number(1)'
p7857
aS'    , theta(0.5)'
p7858
aS'    , wave_speed(1.437)'
p7859
aS'  {'
p7860
aS'    Assert(dim == 2, ExcNotImplemented());'
p7861
aS'    const double detector_step_angle = 2.25;'
p7862
aS'    const double detector_radius     = 0.5;'
p7863
aS'    for (double detector_angle = 2 * numbers::PI; detector_angle >= 0;'
p7864
aS'         detector_angle -= detector_step_angle / 360 * 2 * numbers::PI)'
p7865
aS'      detector_locations.push_back('
p7866
aS'        Point<dim>(std::cos(detector_angle), std::sin(detector_angle)) *'
p7867
aS'        detector_radius);'
p7868
aS'  }'
p7869
aS'  template <int dim>'
p7870
aS'  void TATForwardProblem<dim>::setup_system()'
p7871
aS'  {'
p7872
aS'    const Point<dim> center;'
p7873
aS'    GridGenerator::hyper_ball(triangulation, center, 1.);'
p7874
aS'    triangulation.refine_global(7);'
p7875
aS'    time_step = GridTools::minimal_cell_diameter(triangulation) / wave_speed /'
p7876
aS'                std::sqrt(1. * dim);'
p7877
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p7878
aS'              << std::endl;'
p7879
aS'    dof_handler.distribute_dofs(fe);'
p7880
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p7881
aS'              << std::endl'
p7882
aS'              << std::endl;'
p7883
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p7884
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p7885
aS'    sparsity_pattern.copy_from(dsp);'
p7886
aS'    system_matrix.reinit(sparsity_pattern);'
p7887
aS'    mass_matrix.reinit(sparsity_pattern);'
p7888
aS'    laplace_matrix.reinit(sparsity_pattern);'
p7889
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p7890
aS'                                      QGauss<dim>(fe.degree + 1),'
p7891
aS'                                      mass_matrix);'
p7892
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p7893
aS'                                         QGauss<dim>(fe.degree + 1),'
p7894
aS'                                         laplace_matrix);'
p7895
aS'    boundary_matrix.reinit(sparsity_pattern);'
p7896
aS'    {'
p7897
aS'      const QGauss<dim - 1> quadrature_formula(fe.degree + 1);'
p7898
aS'      FEFaceValues<dim>     fe_values(fe,'
p7899
aS'                                  quadrature_formula,'
p7900
aS'                                  update_values | update_JxW_values);'
p7901
aS'      const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p7902
aS'      const unsigned int n_q_points    = quadrature_formula.size();'
p7903
aS'      FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p7904
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p7905
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p7906
aS'        for (const auto &face : cell->face_iterators())'
p7907
aS'          if (face->at_boundary())'
p7908
aS'            {'
p7909
aS'              cell_matrix = 0;'
p7910
aS'              fe_values.reinit(cell, face);'
p7911
aS'              for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p7912
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7913
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p7914
aS'                    cell_matrix(i, j) += (fe_values.shape_value(i, q_point) *'
p7915
aS'                                          fe_values.shape_value(j, q_point) *'
p7916
aS'                                          fe_values.JxW(q_point));'
p7917
aS'              cell->get_dof_indices(local_dof_indices);'
p7918
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p7919
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p7920
aS'                  boundary_matrix.add(local_dof_indices[i],'
p7921
aS'                                      local_dof_indices[j],'
p7922
aS'                                      cell_matrix(i, j));'
p7923
aS'            }'
p7924
aS'    }'
p7925
aS'    system_matrix.copy_from(mass_matrix);'
p7926
aS'    system_matrix.add(time_step * time_step * theta * theta * wave_speed *'
p7927
aS'                        wave_speed,'
p7928
aS'                      laplace_matrix);'
p7929
aS'    system_matrix.add(wave_speed * theta * time_step, boundary_matrix);'
p7930
aS'    solution_p.reinit(dof_handler.n_dofs());'
p7931
aS'    old_solution_p.reinit(dof_handler.n_dofs());'
p7932
aS'    system_rhs_p.reinit(dof_handler.n_dofs());'
p7933
aS'    solution_v.reinit(dof_handler.n_dofs());'
p7934
aS'    old_solution_v.reinit(dof_handler.n_dofs());'
p7935
aS'    system_rhs_v.reinit(dof_handler.n_dofs());'
p7936
aS'    constraints.close();'
p7937
aS'  }'
p7938
aS'  template <int dim>'
p7939
aS'  void TATForwardProblem<dim>::solve_p()'
p7940
aS'  {'
p7941
aS'    SolverControl solver_control(1000, 1e-8 * system_rhs_p.l2_norm());'
p7942
aS'    SolverCG<Vector<double>> cg(solver_control);'
p7943
aS'    cg.solve(system_matrix, solution_p, system_rhs_p, PreconditionIdentity());'
p7944
aS'    std::cout << "   p-equation: " << solver_control.last_step()'
p7945
aS'              << " CG iterations." << std::endl;'
p7946
aS'  }'
p7947
aS'  template <int dim>'
p7948
aS'  void TATForwardProblem<dim>::solve_v()'
p7949
aS'  {'
p7950
aS'    SolverControl solver_control(1000, 1e-8 * system_rhs_v.l2_norm());'
p7951
aS'    SolverCG<Vector<double>> cg(solver_control);'
p7952
aS'    cg.solve(mass_matrix, solution_v, system_rhs_v, PreconditionIdentity());'
p7953
aS'    std::cout << "   v-equation: " << solver_control.last_step()'
p7954
aS'              << " CG iterations." << std::endl;'
p7955
aS'  }'
p7956
aS'  template <int dim>'
p7957
aS'  void TATForwardProblem<dim>::output_results() const'
p7958
aS'  {'
p7959
aS'    DataOut<dim> data_out;'
p7960
aS'    data_out.attach_dof_handler(dof_handler);'
p7961
aS'    data_out.add_data_vector(solution_p, "P");'
p7962
aS'    data_out.add_data_vector(solution_v, "V");'
p7963
aS'    data_out.build_patches();'
p7964
aS'    const std::string filename ='
p7965
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p7966
aS'    DataOutBase::VtkFlags vtk_flags;'
p7967
aS'    vtk_flags.compression_level ='
p7968
aS'      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p7969
aS'    std::ofstream output(filename);'
p7970
aS'    data_out.write_vtu(output);'
p7971
aS'  }'
p7972
aS'  template <int dim>'
p7973
aS'  void TATForwardProblem<dim>::run()'
p7974
aS'  {'
p7975
aS'    setup_system();'
p7976
aS'    VectorTools::project(dof_handler,'
p7977
aS'                         constraints,'
p7978
aS'                         QGauss<dim>(fe.degree + 1),'
p7979
aS'                         InitialValuesP<dim>(),'
p7980
aS'                         old_solution_p);'
p7981
aS'    old_solution_v = 0;'
p7982
aS'    std::ofstream detector_data("detectors.dat");'
p7983
aS'    Vector<double> tmp(solution_p.size());'
p7984
aS'    Vector<double> G1(solution_p.size());'
p7985
aS'    Vector<double> G2(solution_v.size());'
p7986
aS'    const double end_time = 0.7;'
p7987
aS'    for (time = time_step; time <= end_time;'
p7988
aS'         time += time_step, ++timestep_number)'
p7989
aS'      {'
p7990
aS'        std::cout << std::endl;'
p7991
aS'        std::cout << "time_step " << timestep_number << " @ t=" << time'
p7992
aS'                  << std::endl;'
p7993
aS'        mass_matrix.vmult(G1, old_solution_p);'
p7994
aS'        mass_matrix.vmult(tmp, old_solution_v);'
p7995
aS'        G1.add(time_step * (1 - theta), tmp);'
p7996
aS'        mass_matrix.vmult(G2, old_solution_v);'
p7997
aS'        laplace_matrix.vmult(tmp, old_solution_p);'
p7998
aS'        G2.add(-wave_speed * wave_speed * time_step * (1 - theta), tmp);'
p7999
aS'        boundary_matrix.vmult(tmp, old_solution_p);'
p8000
aS'        G2.add(wave_speed, tmp);'
p8001
aS'        system_rhs_p = G1;'
p8002
aS'        system_rhs_p.add(time_step * theta, G2);'
p8003
aS'        solve_p();'
p8004
aS'        system_rhs_v = G2;'
p8005
aS'        laplace_matrix.vmult(tmp, solution_p);'
p8006
aS'        system_rhs_v.add(-time_step * theta * wave_speed * wave_speed, tmp);'
p8007
aS'        boundary_matrix.vmult(tmp, solution_p);'
p8008
aS'        system_rhs_v.add(-wave_speed, tmp);'
p8009
aS'        solve_v();'
p8010
aS'        output_results();'
p8011
aS'        detector_data << time;'
p8012
aS'        for (unsigned int i = 0; i < detector_locations.size(); ++i)'
p8013
aS'          detector_data << " "'
p8014
aS'                        << VectorTools::point_value(dof_handler,'
p8015
aS'                                                    solution_p,'
p8016
aS'                                                    detector_locations[i])'
p8017
aS'                        << " ";'
p8018
aS'        detector_data << std::endl;'
p8019
aS'        old_solution_p = solution_p;'
p8020
aS'        old_solution_v = solution_v;'
p8021
aS'      }'
p8022
aS'  }'
p8023
aS'} // namespace Step24'
p8024
aS'int main()'
p8025
ag9
aS'  try'
p8026
aS'    {'
p8027
aS'      using namespace Step24;'
p8028
aS'      TATForwardProblem<2> forward_problem_solver;'
p8029
aS'      forward_problem_solver.run();'
p8030
aS'    }'
p8031
aS'  catch (std::exception &exc)'
p8032
aS'    {'
p8033
aS'      std::cerr << std::endl'
p8034
aS'                << std::endl'
p8035
aS'                << "----------------------------------------------------"'
p8036
aS'                << std::endl;'
p8037
aS'      std::cerr << "Exception on processing: " << std::endl'
p8038
aS'                << exc.what() << std::endl'
p8039
aS'                << "Aborting!" << std::endl'
p8040
aS'                << "----------------------------------------------------"'
p8041
aS'                << std::endl;'
p8042
aS'      return 1;'
p8043
aS'    }'
p8044
aS'  catch (...)'
p8045
aS'    {'
p8046
aS'      std::cerr << std::endl'
p8047
aS'                << std::endl'
p8048
aS'                << "----------------------------------------------------"'
p8049
aS'                << std::endl;'
p8050
aS'      std::cerr << "Unknown exception!" << std::endl'
p8051
aS'                << "Aborting!" << std::endl'
p8052
aS'                << "----------------------------------------------------"'
p8053
aS'                << std::endl;'
p8054
aS'      return 1;'
p8055
aS'    }'
p8056
aS'  return 0;'
p8057
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p8058
aS'#include <deal.II/base/function.h>'
p8059
aS'#include <deal.II/base/utilities.h>'
p8060
aS'#include <deal.II/lac/vector.h>'
p8061
aS'#include <deal.II/lac/full_matrix.h>'
p8062
aS'#include <deal.II/lac/sparse_matrix.h>'
p8063
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p8064
aS'#include <deal.II/lac/solver_cg.h>'
p8065
aS'#include <deal.II/lac/precondition.h>'
p8066
aS'#include <deal.II/lac/affine_constraints.h>'
p8067
aS'#include <deal.II/grid/tria.h>'
p8068
aS'#include <deal.II/grid/grid_generator.h>'
p8069
aS'#include <deal.II/dofs/dof_handler.h>'
p8070
aS'#include <deal.II/dofs/dof_tools.h>'
p8071
aS'#include <deal.II/fe/fe_q.h>'
p8072
aS'#include <deal.II/fe/fe_values.h>'
p8073
aS'#include <deal.II/numerics/vector_tools.h>'
p8074
aS'#include <deal.II/numerics/matrix_tools.h>'
p8075
aS'#include <deal.II/numerics/data_out.h>'
p8076
aS'#include <fstream>'
p8077
aS'#include <iostream>'
p8078
aS'namespace Step25'
p8079
ag9
aS'  using namespace dealii;'
p8080
aS'  template <int dim>'
p8081
aS'  class SineGordonProblem'
p8082
aS'  {'
p8083
aS'  public:'
p8084
aS'    SineGordonProblem();'
p8085
aS'    void run();'
p8086
aS'  private:'
p8087
aS'    void         make_grid_and_dofs();'
p8088
aS'    void         assemble_system();'
p8089
aS'    void         compute_nl_term(const Vector<double> &old_data,'
p8090
aS'                                 const Vector<double> &new_data,'
p8091
aS'                                 Vector<double> &      nl_term) const;'
p8092
aS'    void         compute_nl_matrix(const Vector<double> &old_data,'
p8093
aS'                                   const Vector<double> &new_data,'
p8094
aS'                                   SparseMatrix<double> &nl_matrix) const;'
p8095
aS'    unsigned int solve();'
p8096
aS'    void         output_results(const unsigned int timestep_number) const;'
p8097
aS'    Triangulation<dim> triangulation;'
p8098
aS'    FE_Q<dim>          fe;'
p8099
aS'    DoFHandler<dim>    dof_handler;'
p8100
aS'    SparsityPattern      sparsity_pattern;'
p8101
aS'    SparseMatrix<double> system_matrix;'
p8102
aS'    SparseMatrix<double> mass_matrix;'
p8103
aS'    SparseMatrix<double> laplace_matrix;'
p8104
aS'    const unsigned int n_global_refinements;'
p8105
aS'    double       time;'
p8106
aS'    const double final_time, time_step;'
p8107
aS'    const double theta;'
p8108
aS'    Vector<double> solution, solution_update, old_solution;'
p8109
aS'    Vector<double> M_x_velocity;'
p8110
aS'    Vector<double> system_rhs;'
p8111
aS'    const unsigned int output_timestep_skip;'
p8112
aS'  };'
p8113
aS'  template <int dim>'
p8114
aS'  class ExactSolution : public Function<dim>'
p8115
aS'  {'
p8116
aS'  public:'
p8117
aS'    ExactSolution(const unsigned int n_components = 1, const double time = 0.)'
p8118
aS'      : Function<dim>(n_components, time)'
p8119
aS'    {}'
p8120
aS'    virtual double value(const Point<dim> &p,'
p8121
aS'                         const unsigned int /*component*/ = 0) const override'
p8122
aS'    {'
p8123
aS'      const double t = this->get_time();'
p8124
aS'      switch (dim)'
p8125
aS'        {'
p8126
aS'          case 1:'
p8127
aS'            {'
p8128
aS'              const double m  = 0.5;'
p8129
aS'              const double c1 = 0.;'
p8130
aS'              const double c2 = 0.;'
p8131
aS'              return -4. * std::atan(m / std::sqrt(1. - m * m) *'
p8132
aS'                                     std::sin(std::sqrt(1. - m * m) * t + c2) /'
p8133
aS'                                     std::cosh(m * p[0] + c1));'
p8134
aS'            }'
p8135
aS'          case 2:'
p8136
aS'            {'
p8137
aS'              const double theta  = numbers::PI / 4.;'
p8138
aS'              const double lambda = 1.;'
p8139
aS'              const double a0     = 1.;'
p8140
aS'              const double s      = 1.;'
p8141
aS'              const double arg    = p[0] * std::cos(theta) +'
p8142
aS'                                 std::sin(theta) * (p[1] * std::cosh(lambda) +'
p8143
aS'                                                    t * std::sinh(lambda));'
p8144
aS'              return 4. * std::atan(a0 * std::exp(s * arg));'
p8145
aS'            }'
p8146
aS'          case 3:'
p8147
aS'            {'
p8148
aS'              const double theta = numbers::PI / 4;'
p8149
aS'              const double phi   = numbers::PI / 4;'
p8150
aS'              const double tau   = 1.;'
p8151
aS'              const double c0    = 1.;'
p8152
aS'              const double s     = 1.;'
p8153
aS'              const double arg   = p[0] * std::cos(theta) +'
p8154
aS'                                 p[1] * std::sin(theta) * std::cos(phi) +'
p8155
aS'                                 std::sin(theta) * std::sin(phi) *'
p8156
aS'              return 4. * std::atan(c0 * std::exp(s * arg));'
p8157
aS'            }'
p8158
aS'          default:'
p8159
aS'            Assert(false, ExcNotImplemented());'
p8160
aS'            return -1e8;'
p8161
aS'        }'
p8162
aS'    }'
p8163
aS'  };'
p8164
aS'  template <int dim>'
p8165
aS'  class InitialValues : public Function<dim>'
p8166
aS'  {'
p8167
aS'  public:'
p8168
aS'    InitialValues(const unsigned int n_components = 1, const double time = 0.)'
p8169
aS'      : Function<dim>(n_components, time)'
p8170
aS'    {}'
p8171
aS'    virtual double value(const Point<dim> & p,'
p8172
aS'                         const unsigned int component = 0) const override'
p8173
aS'    {'
p8174
aS'      return ExactSolution<dim>(1, this->get_time()).value(p, component);'
p8175
aS'    }'
p8176
aS'  };'
p8177
aS'  template <int dim>'
p8178
aS'  SineGordonProblem<dim>::SineGordonProblem()'
p8179
aS'    : fe(1)'
p8180
aS'    , dof_handler(triangulation)'
p8181
aS'    , n_global_refinements(6)'
p8182
aS'    , time(-5.4414)'
p8183
aS'    , final_time(2.7207)'
p8184
aS'    , time_step(10 * 1. / std::pow(2., 1. * n_global_refinements))'
p8185
aS'    , theta(0.5)'
p8186
aS'    , output_timestep_skip(1)'
p8187
aS'  {}'
p8188
aS'  template <int dim>'
p8189
aS'  void SineGordonProblem<dim>::make_grid_and_dofs()'
p8190
aS'  {'
p8191
aS'    GridGenerator::hyper_cube(triangulation, -10, 10);'
p8192
aS'    triangulation.refine_global(n_global_refinements);'
p8193
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p8194
aS'              << std::endl'
p8195
aS'              << "   Total number of cells: " << triangulation.n_cells()'
p8196
aS'              << std::endl;'
p8197
aS'    dof_handler.distribute_dofs(fe);'
p8198
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p8199
aS'              << std::endl;'
p8200
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p8201
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p8202
aS'    sparsity_pattern.copy_from(dsp);'
p8203
aS'    system_matrix.reinit(sparsity_pattern);'
p8204
aS'    mass_matrix.reinit(sparsity_pattern);'
p8205
aS'    laplace_matrix.reinit(sparsity_pattern);'
p8206
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p8207
aS'                                      QGauss<dim>(fe.degree + 1),'
p8208
aS'                                      mass_matrix);'
p8209
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p8210
aS'                                         QGauss<dim>(fe.degree + 1),'
p8211
aS'                                         laplace_matrix);'
p8212
aS'    solution.reinit(dof_handler.n_dofs());'
p8213
aS'    solution_update.reinit(dof_handler.n_dofs());'
p8214
aS'    old_solution.reinit(dof_handler.n_dofs());'
p8215
aS'    M_x_velocity.reinit(dof_handler.n_dofs());'
p8216
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p8217
aS'  }'
p8218
aS'  template <int dim>'
p8219
aS'  void SineGordonProblem<dim>::assemble_system()'
p8220
aS'  {'
p8221
aS'    system_matrix.copy_from(mass_matrix);'
p8222
aS'    system_matrix.add(std::pow(time_step * theta, 2), laplace_matrix);'
p8223
aS'    SparseMatrix<double> tmp_matrix(sparsity_pattern);'
p8224
aS'    compute_nl_matrix(old_solution, solution, tmp_matrix);'
p8225
aS'    system_matrix.add(std::pow(time_step * theta, 2), tmp_matrix);'
p8226
aS'    system_rhs = 0.;'
p8227
aS'    Vector<double> tmp_vector(solution.size());'
p8228
aS'    mass_matrix.vmult(system_rhs, solution);'
p8229
aS'    laplace_matrix.vmult(tmp_vector, solution);'
p8230
aS'    system_rhs.add(std::pow(time_step * theta, 2), tmp_vector);'
p8231
aS'    mass_matrix.vmult(tmp_vector, old_solution);'
p8232
aS'    system_rhs.add(-1.0, tmp_vector);'
p8233
aS'    laplace_matrix.vmult(tmp_vector, old_solution);'
p8234
aS'    system_rhs.add(std::pow(time_step, 2) * theta * (1 - theta), tmp_vector);'
p8235
aS'    system_rhs.add(-time_step, M_x_velocity);'
p8236
aS'    compute_nl_term(old_solution, solution, tmp_vector);'
p8237
aS'    system_rhs.add(std::pow(time_step, 2) * theta, tmp_vector);'
p8238
aS'    system_rhs *= -1.;'
p8239
aS'  }'
p8240
aS'  template <int dim>'
p8241
aS'  void SineGordonProblem<dim>::compute_nl_term(const Vector<double> &old_data,'
p8242
aS'                                               const Vector<double> &new_data,'
p8243
aS'                                               Vector<double> &nl_term) const'
p8244
aS'  {'
p8245
aS'    nl_term = 0;'
p8246
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p8247
aS'    FEValues<dim>     fe_values(fe,'
p8248
aS'                            quadrature_formula,'
p8249
aS'                            update_values | update_JxW_values |'
p8250
aS'                              update_quadrature_points);'
p8251
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p8252
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p8253
aS'    Vector<double>                       local_nl_term(dofs_per_cell);'
p8254
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p8255
aS'    std::vector<double>                  old_data_values(n_q_points);'
p8256
aS'    std::vector<double>                  new_data_values(n_q_points);'
p8257
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p8258
aS'      {'
p8259
aS'        local_nl_term = 0;'
p8260
aS'        fe_values.reinit(cell);'
p8261
aS'        fe_values.get_function_values(old_data, old_data_values);'
p8262
aS'        fe_values.get_function_values(new_data, new_data_values);'
p8263
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p8264
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8265
aS'            local_nl_term(i) +='
p8266
aS'               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));'
p8267
aS'        cell->get_dof_indices(local_dof_indices);'
p8268
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8269
aS'          nl_term(local_dof_indices[i]) += local_nl_term(i);'
p8270
aS'      }'
p8271
aS'  }'
p8272
aS'  template <int dim>'
p8273
aS'  void SineGordonProblem<dim>::compute_nl_matrix('
p8274
aS'    const Vector<double> &old_data,'
p8275
aS'    const Vector<double> &new_data,'
p8276
aS'    SparseMatrix<double> &nl_matrix) const'
p8277
aS'  {'
p8278
aS'    QGauss<dim>   quadrature_formula(fe.degree + 1);'
p8279
aS'    FEValues<dim> fe_values(fe,'
p8280
aS'                            quadrature_formula,'
p8281
aS'                            update_values | update_JxW_values |'
p8282
aS'                              update_quadrature_points);'
p8283
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p8284
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p8285
aS'    FullMatrix<double> local_nl_matrix(dofs_per_cell, dofs_per_cell);'
p8286
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p8287
aS'    std::vector<double>                  old_data_values(n_q_points);'
p8288
aS'    std::vector<double>                  new_data_values(n_q_points);'
p8289
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p8290
aS'      {'
p8291
aS'        local_nl_matrix = 0;'
p8292
aS'        fe_values.reinit(cell);'
p8293
aS'        fe_values.get_function_values(old_data, old_data_values);'
p8294
aS'        fe_values.get_function_values(new_data, new_data_values);'
p8295
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p8296
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8297
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8298
aS'              local_nl_matrix(i, j) +='
p8299
aS'                 fe_values.shape_value(i, q_point) *'
p8300
aS'                 fe_values.shape_value(j, q_point) * fe_values.JxW(q_point));'
p8301
aS'        cell->get_dof_indices(local_dof_indices);'
p8302
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8303
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8304
aS'            nl_matrix.add(local_dof_indices[i],'
p8305
aS'                          local_dof_indices[j],'
p8306
aS'                          local_nl_matrix(i, j));'
p8307
aS'      }'
p8308
aS'  }'
p8309
aS'  template <int dim>'
p8310
aS'  unsigned int SineGordonProblem<dim>::solve()'
p8311
aS'  {'
p8312
aS'    SolverControl            solver_control(1000, 1e-12 * system_rhs.l2_norm());'
p8313
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8314
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p8315
aS'    preconditioner.initialize(system_matrix, 1.2);'
p8316
aS'    cg.solve(system_matrix, solution_update, system_rhs, preconditioner);'
p8317
aS'    return solver_control.last_step();'
p8318
aS'  }'
p8319
aS'  template <int dim>'
p8320
aS'  void SineGordonProblem<dim>::output_results('
p8321
aS'    const unsigned int timestep_number) const'
p8322
aS'  {'
p8323
aS'    DataOut<dim> data_out;'
p8324
aS'    data_out.attach_dof_handler(dof_handler);'
p8325
aS'    data_out.add_data_vector(solution, "u");'
p8326
aS'    data_out.build_patches();'
p8327
aS'    const std::string filename ='
p8328
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p8329
aS'    DataOutBase::VtkFlags vtk_flags;'
p8330
aS'    vtk_flags.compression_level ='
p8331
aS'      DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p8332
aS'    data_out.set_flags(vtk_flags);'
p8333
aS'    std::ofstream output(filename);'
p8334
aS'    data_out.write_vtu(output);'
p8335
aS'  }'
p8336
aS'  template <int dim>'
p8337
aS'  void SineGordonProblem<dim>::run()'
p8338
aS'  {'
p8339
aS'    make_grid_and_dofs();'
p8340
aS'    {'
p8341
aS'      AffineConstraints<double> constraints;'
p8342
aS'      constraints.close();'
p8343
aS'      VectorTools::project(dof_handler,'
p8344
aS'                           constraints,'
p8345
aS'                           QGauss<dim>(fe.degree + 1),'
p8346
aS'                           InitialValues<dim>(1, time),'
p8347
aS'                           solution);'
p8348
aS'    }'
p8349
aS'    output_results(0);'
p8350
aS'    unsigned int timestep_number = 1;'
p8351
aS'    for (time += time_step; time <= final_time;'
p8352
aS'         time += time_step, ++timestep_number)'
p8353
aS'      {'
p8354
aS'        old_solution = solution;'
p8355
aS'        std::cout << std::endl'
p8356
aS'                  << "Time step #" << timestep_number << "; "'
p8357
aS'                  << "advancing to t = " << time << "." << std::endl;'
p8358
aS'        double initial_rhs_norm = 0.;'
p8359
aS'        bool   first_iteration  = true;'
p8360
aS'        do'
p8361
aS'          {'
p8362
aS'            assemble_system();'
p8363
aS'            if (first_iteration == true)'
p8364
aS'              initial_rhs_norm = system_rhs.l2_norm();'
p8365
aS'            const unsigned int n_iterations = solve();'
p8366
aS'            solution += solution_update;'
p8367
aS'            if (first_iteration == true)'
p8368
aS'              std::cout << "    " << n_iterations;'
p8369
aS'            else'
p8370
aS"              std::cout << '+' << n_iterations;"
p8371
aS'            first_iteration = false;'
p8372
aS'          }'
p8373
aS'        while (system_rhs.l2_norm() > 1e-6 * initial_rhs_norm);'
p8374
aS'        std::cout << " CG iterations per nonlinear step." << std::endl;'
p8375
aS'        Vector<double> tmp_vector(solution.size());'
p8376
aS'        laplace_matrix.vmult(tmp_vector, solution);'
p8377
aS'        M_x_velocity.add(-time_step * theta, tmp_vector);'
p8378
aS'        laplace_matrix.vmult(tmp_vector, old_solution);'
p8379
aS'        M_x_velocity.add(-time_step * (1 - theta), tmp_vector);'
p8380
aS'        compute_nl_term(old_solution, solution, tmp_vector);'
p8381
aS'        M_x_velocity.add(-time_step, tmp_vector);'
p8382
aS'        if (timestep_number % output_timestep_skip == 0)'
p8383
aS'          output_results(timestep_number);'
p8384
aS'      }'
p8385
aS'  }'
p8386
aS'} // namespace Step25'
p8387
aS'int main()'
p8388
ag9
aS'  try'
p8389
aS'    {'
p8390
aS'      using namespace Step25;'
p8391
aS'      SineGordonProblem<1> sg_problem;'
p8392
aS'      sg_problem.run();'
p8393
aS'    }'
p8394
aS'  catch (std::exception &exc)'
p8395
aS'    {'
p8396
aS'      std::cerr << std::endl'
p8397
aS'                << std::endl'
p8398
aS'                << "----------------------------------------------------"'
p8399
aS'                << std::endl;'
p8400
aS'      std::cerr << "Exception on processing: " << std::endl'
p8401
aS'                << exc.what() << std::endl'
p8402
aS'                << "Aborting!" << std::endl'
p8403
aS'                << "----------------------------------------------------"'
p8404
aS'                << std::endl;'
p8405
aS'      return 1;'
p8406
aS'    }'
p8407
aS'  catch (...)'
p8408
aS'    {'
p8409
aS'      std::cerr << std::endl'
p8410
aS'                << std::endl'
p8411
aS'                << "----------------------------------------------------"'
p8412
aS'                << std::endl;'
p8413
aS'      std::cerr << "Unknown exception!" << std::endl'
p8414
aS'                << "Aborting!" << std::endl'
p8415
aS'                << "----------------------------------------------------"'
p8416
aS'                << std::endl;'
p8417
aS'      return 1;'
p8418
aS'    }'
p8419
aS'  return 0;'
p8420
ag17
aS'#include <deal.II/base/utilities.h>'
p8421
aS'#include <deal.II/base/quadrature_lib.h>'
p8422
aS'#include <deal.II/base/function.h>'
p8423
aS'#include <deal.II/base/logstream.h>'
p8424
aS'#include <deal.II/lac/vector.h>'
p8425
aS'#include <deal.II/lac/full_matrix.h>'
p8426
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p8427
aS'#include <deal.II/lac/sparse_matrix.h>'
p8428
aS'#include <deal.II/lac/solver_cg.h>'
p8429
aS'#include <deal.II/lac/precondition.h>'
p8430
aS'#include <deal.II/lac/affine_constraints.h>'
p8431
aS'#include <deal.II/grid/tria.h>'
p8432
aS'#include <deal.II/grid/grid_generator.h>'
p8433
aS'#include <deal.II/grid/grid_refinement.h>'
p8434
aS'#include <deal.II/grid/grid_out.h>'
p8435
aS'#include <deal.II/dofs/dof_handler.h>'
p8436
aS'#include <deal.II/dofs/dof_tools.h>'
p8437
aS'#include <deal.II/fe/fe_q.h>'
p8438
aS'#include <deal.II/fe/fe_values.h>'
p8439
aS'#include <deal.II/numerics/data_out.h>'
p8440
aS'#include <deal.II/numerics/vector_tools.h>'
p8441
aS'#include <deal.II/numerics/error_estimator.h>'
p8442
aS'#include <deal.II/numerics/solution_transfer.h>'
p8443
aS'#include <deal.II/numerics/matrix_tools.h>'
p8444
aS'#include <fstream>'
p8445
aS'#include <iostream>'
p8446
aS'namespace Step26'
p8447
ag9
aS'  using namespace dealii;'
p8448
aS'  template <int dim>'
p8449
aS'  class HeatEquation'
p8450
aS'  {'
p8451
aS'  public:'
p8452
aS'    HeatEquation();'
p8453
aS'    void run();'
p8454
aS'  private:'
p8455
aS'    void setup_system();'
p8456
aS'    void solve_time_step();'
p8457
aS'    void output_results() const;'
p8458
aS'    void refine_mesh(const unsigned int min_grid_level,'
p8459
aS'                     const unsigned int max_grid_level);'
p8460
aS'    Triangulation<dim> triangulation;'
p8461
aS'    FE_Q<dim>          fe;'
p8462
aS'    DoFHandler<dim>    dof_handler;'
p8463
aS'    AffineConstraints<double> constraints;'
p8464
aS'    SparsityPattern      sparsity_pattern;'
p8465
aS'    SparseMatrix<double> mass_matrix;'
p8466
aS'    SparseMatrix<double> laplace_matrix;'
p8467
aS'    SparseMatrix<double> system_matrix;'
p8468
aS'    Vector<double> solution;'
p8469
aS'    Vector<double> old_solution;'
p8470
aS'    Vector<double> system_rhs;'
p8471
aS'    double       time;'
p8472
aS'    double       time_step;'
p8473
aS'    unsigned int timestep_number;'
p8474
aS'    const double theta;'
p8475
aS'  };'
p8476
aS'  template <int dim>'
p8477
aS'  class RightHandSide : public Function<dim>'
p8478
aS'  {'
p8479
aS'  public:'
p8480
aS'    RightHandSide()'
p8481
aS'      : Function<dim>()'
p8482
aS'      , period(0.2)'
p8483
aS'    {}'
p8484
aS'    virtual double value(const Point<dim> & p,'
p8485
aS'                         const unsigned int component = 0) const override;'
p8486
aS'  private:'
p8487
aS'    const double period;'
p8488
aS'  };'
p8489
aS'  template <int dim>'
p8490
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p8491
aS'                                   const unsigned int component) const'
p8492
aS'  {'
p8493
aS'    AssertIndexRange(component, 1);'
p8494
aS'    Assert(dim == 2, ExcNotImplemented());'
p8495
aS'    const double time = this->get_time();'
p8496
aS'    const double point_within_period ='
p8497
aS'    if ((point_within_period >= 0.0) && (point_within_period <= 0.2))'
p8498
aS'      {'
p8499
aS'        if ((p[0] > 0.5) && (p[1] > -0.5))'
p8500
aS'          return 1;'
p8501
aS'        else'
p8502
aS'          return 0;'
p8503
aS'      }'
p8504
aS'    else if ((point_within_period >= 0.5) && (point_within_period <= 0.7))'
p8505
aS'      {'
p8506
aS'        if ((p[0] > -0.5) && (p[1] > 0.5))'
p8507
aS'          return 1;'
p8508
aS'        else'
p8509
aS'          return 0;'
p8510
aS'      }'
p8511
aS'    else'
p8512
aS'      return 0;'
p8513
aS'  }'
p8514
aS'  template <int dim>'
p8515
aS'  class BoundaryValues : public Function<dim>'
p8516
aS'  {'
p8517
aS'  public:'
p8518
aS'    virtual double value(const Point<dim> & p,'
p8519
aS'                         const unsigned int component = 0) const override;'
p8520
aS'  };'
p8521
aS'  template <int dim>'
p8522
aS'  double BoundaryValues<dim>::value(const Point<dim> & /*p*/,'
p8523
aS'                                    const unsigned int component) const'
p8524
aS'  {'
p8525
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p8526
aS'    return 0;'
p8527
aS'  }'
p8528
aS'  template <int dim>'
p8529
aS'  HeatEquation<dim>::HeatEquation()'
p8530
aS'    : fe(1)'
p8531
aS'    , dof_handler(triangulation)'
p8532
aS'    , time_step(1. / 500)'
p8533
aS'    , theta(0.5)'
p8534
aS'  {}'
p8535
aS'  template <int dim>'
p8536
aS'  void HeatEquation<dim>::setup_system()'
p8537
aS'  {'
p8538
aS'    dof_handler.distribute_dofs(fe);'
p8539
aS'    std::cout << std::endl'
p8540
aS'              << "===========================================" << std::endl'
p8541
aS'              << "Number of active cells: " << triangulation.n_active_cells()'
p8542
aS'              << std::endl'
p8543
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p8544
aS'              << std::endl'
p8545
aS'              << std::endl;'
p8546
aS'    constraints.clear();'
p8547
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p8548
aS'    constraints.close();'
p8549
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p8550
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p8551
aS'                                    dsp,'
p8552
aS'                                    constraints,'
p8553
aS'    sparsity_pattern.copy_from(dsp);'
p8554
aS'    mass_matrix.reinit(sparsity_pattern);'
p8555
aS'    laplace_matrix.reinit(sparsity_pattern);'
p8556
aS'    system_matrix.reinit(sparsity_pattern);'
p8557
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p8558
aS'                                      QGauss<dim>(fe.degree + 1),'
p8559
aS'                                      mass_matrix);'
p8560
aS'    MatrixCreator::create_laplace_matrix(dof_handler,'
p8561
aS'                                         QGauss<dim>(fe.degree + 1),'
p8562
aS'                                         laplace_matrix);'
p8563
aS'    solution.reinit(dof_handler.n_dofs());'
p8564
aS'    old_solution.reinit(dof_handler.n_dofs());'
p8565
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p8566
aS'  }'
p8567
aS'  template <int dim>'
p8568
aS'  void HeatEquation<dim>::solve_time_step()'
p8569
aS'  {'
p8570
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p8571
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8572
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p8573
aS'    preconditioner.initialize(system_matrix, 1.0);'
p8574
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p8575
aS'    constraints.distribute(solution);'
p8576
aS'    std::cout << "     " << solver_control.last_step() << " CG iterations."'
p8577
aS'              << std::endl;'
p8578
aS'  }'
p8579
aS'  template <int dim>'
p8580
aS'  void HeatEquation<dim>::output_results() const'
p8581
aS'  {'
p8582
aS'    DataOut<dim> data_out;'
p8583
aS'    data_out.attach_dof_handler(dof_handler);'
p8584
aS'    data_out.add_data_vector(solution, "U");'
p8585
aS'    data_out.build_patches();'
p8586
aS'    data_out.set_flags(DataOutBase::VtkFlags(time, timestep_number));'
p8587
aS'    const std::string filename ='
p8588
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtk";'
p8589
aS'    std::ofstream output(filename);'
p8590
aS'    data_out.write_vtk(output);'
p8591
aS'  }'
p8592
aS'  template <int dim>'
p8593
aS'  void HeatEquation<dim>::refine_mesh(const unsigned int min_grid_level,'
p8594
aS'                                      const unsigned int max_grid_level)'
p8595
aS'  {'
p8596
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p8597
aS'    KellyErrorEstimator<dim>::estimate('
p8598
aS'      dof_handler,'
p8599
aS'      QGauss<dim - 1>(fe.degree + 1),'
p8600
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p8601
aS'      solution,'
p8602
aS'      estimated_error_per_cell);'
p8603
aS'    GridRefinement::refine_and_coarsen_fixed_fraction(triangulation,'
p8604
aS'                                                      estimated_error_per_cell,'
p8605
aS'                                                      0.6,'
p8606
aS'                                                      0.4);'
p8607
aS'    if (triangulation.n_levels() > max_grid_level)'
p8608
aS'      for (const auto &cell :'
p8609
aS'           triangulation.active_cell_iterators_on_level(max_grid_level))'
p8610
aS'        cell->clear_refine_flag();'
p8611
aS'    for (const auto &cell :'
p8612
aS'         triangulation.active_cell_iterators_on_level(min_grid_level))'
p8613
aS'      cell->clear_coarsen_flag();'
p8614
aS'    SolutionTransfer<dim> solution_trans(dof_handler);'
p8615
aS'    Vector<double> previous_solution;'
p8616
aS'    previous_solution = solution;'
p8617
aS'    triangulation.prepare_coarsening_and_refinement();'
p8618
aS'    solution_trans.prepare_for_coarsening_and_refinement(previous_solution);'
p8619
aS'    triangulation.execute_coarsening_and_refinement();'
p8620
aS'    setup_system();'
p8621
aS'    solution_trans.interpolate(previous_solution, solution);'
p8622
aS'    constraints.distribute(solution);'
p8623
aS'  }'
p8624
aS'  template <int dim>'
p8625
aS'  void HeatEquation<dim>::run()'
p8626
aS'  {'
p8627
aS'    const unsigned int initial_global_refinement       = 2;'
p8628
aS'    const unsigned int n_adaptive_pre_refinement_steps = 4;'
p8629
aS'    GridGenerator::hyper_L(triangulation);'
p8630
aS'    triangulation.refine_global(initial_global_refinement);'
p8631
aS'    setup_system();'
p8632
aS'    unsigned int pre_refinement_step = 0;'
p8633
aS'    Vector<double> tmp;'
p8634
aS'    Vector<double> forcing_terms;'
p8635
aS'  start_time_iteration:'
p8636
aS'    time            = 0.0;'
p8637
aS'    timestep_number = 0;'
p8638
aS'    tmp.reinit(solution.size());'
p8639
aS'    forcing_terms.reinit(solution.size());'
p8640
aS'    VectorTools::interpolate(dof_handler,'
p8641
aS'                             Functions::ZeroFunction<dim>(),'
p8642
aS'                             old_solution);'
p8643
aS'    solution = old_solution;'
p8644
aS'    output_results();'
p8645
aS'    while (time <= 0.5)'
p8646
aS'      {'
p8647
aS'        time += time_step;'
p8648
aS'        ++timestep_number;'
p8649
aS'        std::cout << "Time step " << timestep_number << " at t=" << time'
p8650
aS'                  << std::endl;'
p8651
aS'        mass_matrix.vmult(system_rhs, old_solution);'
p8652
aS'        laplace_matrix.vmult(tmp, old_solution);'
p8653
aS'        system_rhs.add(-(1 - theta) * time_step, tmp);'
p8654
aS'        RightHandSide<dim> rhs_function;'
p8655
aS'        rhs_function.set_time(time);'
p8656
aS'        VectorTools::create_right_hand_side(dof_handler,'
p8657
aS'                                            QGauss<dim>(fe.degree + 1),'
p8658
aS'                                            rhs_function,'
p8659
aS'                                            tmp);'
p8660
aS'        forcing_terms = tmp;'
p8661
aS'        forcing_terms *= time_step * theta;'
p8662
aS'        rhs_function.set_time(time - time_step);'
p8663
aS'        VectorTools::create_right_hand_side(dof_handler,'
p8664
aS'                                            QGauss<dim>(fe.degree + 1),'
p8665
aS'                                            rhs_function,'
p8666
aS'                                            tmp);'
p8667
aS'        forcing_terms.add(time_step * (1 - theta), tmp);'
p8668
aS'        system_rhs += forcing_terms;'
p8669
aS'        system_matrix.copy_from(mass_matrix);'
p8670
aS'        system_matrix.add(theta * time_step, laplace_matrix);'
p8671
aS'        constraints.condense(system_matrix, system_rhs);'
p8672
aS'        {'
p8673
aS'          BoundaryValues<dim> boundary_values_function;'
p8674
aS'          boundary_values_function.set_time(time);'
p8675
aS'          std::map<types::global_dof_index, double> boundary_values;'
p8676
aS'          VectorTools::interpolate_boundary_values(dof_handler,'
p8677
aS'                                                   0,'
p8678
aS'                                                   boundary_values_function,'
p8679
aS'                                                   boundary_values);'
p8680
aS'          MatrixTools::apply_boundary_values(boundary_values,'
p8681
aS'                                             system_matrix,'
p8682
aS'                                             solution,'
p8683
aS'                                             system_rhs);'
p8684
aS'        }'
p8685
aS'        solve_time_step();'
p8686
aS'        output_results();'
p8687
aS'        if ((timestep_number == 1) &&'
p8688
aS'          {'
p8689
aS'            refine_mesh(initial_global_refinement,'
p8690
aS'                        initial_global_refinement +'
p8691
aS'                          n_adaptive_pre_refinement_steps);'
p8692
aS'            ++pre_refinement_step;'
p8693
aS'            tmp.reinit(solution.size());'
p8694
aS'            forcing_terms.reinit(solution.size());'
p8695
aS'            std::cout << std::endl;'
p8696
aS'            goto start_time_iteration;'
p8697
aS'          }'
p8698
aS'        else if ((timestep_number > 0) && (timestep_number % 5 == 0))'
p8699
aS'          {'
p8700
aS'            refine_mesh(initial_global_refinement,'
p8701
aS'                        initial_global_refinement +'
p8702
aS'                          n_adaptive_pre_refinement_steps);'
p8703
aS'            tmp.reinit(solution.size());'
p8704
aS'            forcing_terms.reinit(solution.size());'
p8705
aS'          }'
p8706
aS'        old_solution = solution;'
p8707
aS'      }'
p8708
aS'  }'
p8709
aS'} // namespace Step26'
p8710
aS'int main()'
p8711
ag9
aS'  try'
p8712
aS'    {'
p8713
aS'      using namespace Step26;'
p8714
aS'      HeatEquation<2> heat_equation_solver;'
p8715
aS'      heat_equation_solver.run();'
p8716
aS'    }'
p8717
aS'  catch (std::exception &exc)'
p8718
aS'    {'
p8719
aS'      std::cerr << std::endl'
p8720
aS'                << std::endl'
p8721
aS'                << "----------------------------------------------------"'
p8722
aS'                << std::endl;'
p8723
aS'      std::cerr << "Exception on processing: " << std::endl'
p8724
aS'                << exc.what() << std::endl'
p8725
aS'                << "Aborting!" << std::endl'
p8726
aS'                << "----------------------------------------------------"'
p8727
aS'                << std::endl;'
p8728
aS'      return 1;'
p8729
aS'    }'
p8730
aS'  catch (...)'
p8731
aS'    {'
p8732
aS'      std::cerr << std::endl'
p8733
aS'                << std::endl'
p8734
aS'                << "----------------------------------------------------"'
p8735
aS'                << std::endl;'
p8736
aS'      std::cerr << "Unknown exception!" << std::endl'
p8737
aS'                << "Aborting!" << std::endl'
p8738
aS'                << "----------------------------------------------------"'
p8739
aS'                << std::endl;'
p8740
aS'      return 1;'
p8741
aS'    }'
p8742
aS'  return 0;'
p8743
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p8744
aS'#include <deal.II/base/function.h>'
p8745
aS'#include <deal.II/base/logstream.h>'
p8746
aS'#include <deal.II/base/utilities.h>'
p8747
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p8748
aS'#include <deal.II/lac/vector.h>'
p8749
aS'#include <deal.II/lac/full_matrix.h>'
p8750
aS'#include <deal.II/lac/sparse_matrix.h>'
p8751
aS'#include <deal.II/lac/solver_cg.h>'
p8752
aS'#include <deal.II/lac/precondition.h>'
p8753
aS'#include <deal.II/lac/affine_constraints.h>'
p8754
aS'#include <deal.II/grid/tria.h>'
p8755
aS'#include <deal.II/grid/grid_generator.h>'
p8756
aS'#include <deal.II/grid/grid_refinement.h>'
p8757
aS'#include <deal.II/dofs/dof_tools.h>'
p8758
aS'#include <deal.II/fe/fe_q.h>'
p8759
aS'#include <deal.II/numerics/vector_tools.h>'
p8760
aS'#include <deal.II/numerics/matrix_tools.h>'
p8761
aS'#include <deal.II/numerics/data_out.h>'
p8762
aS'#include <deal.II/numerics/error_estimator.h>'
p8763
aS'#include <deal.II/hp/fe_collection.h>'
p8764
aS'#include <deal.II/hp/fe_values.h>'
p8765
aS'#include <deal.II/hp/refinement.h>'
p8766
aS'#include <deal.II/fe/fe_series.h>'
p8767
aS'#include <deal.II/numerics/smoothness_estimator.h>'
p8768
aS'#include <fstream>'
p8769
aS'#include <iostream>'
p8770
aS'namespace Step27'
p8771
ag9
aS'  using namespace dealii;'
p8772
aS'  template <int dim>'
p8773
aS'  class LaplaceProblem'
p8774
aS'  {'
p8775
aS'  public:'
p8776
aS'    LaplaceProblem();'
p8777
aS'    ~LaplaceProblem();'
p8778
aS'    void run();'
p8779
aS'  private:'
p8780
aS'    void setup_system();'
p8781
aS'    void assemble_system();'
p8782
aS'    void solve();'
p8783
aS'    void create_coarse_grid();'
p8784
aS'    void postprocess(const unsigned int cycle);'
p8785
aS'    Triangulation<dim> triangulation;'
p8786
aS'    DoFHandler<dim>          dof_handler;'
p8787
aS'    hp::FECollection<dim>    fe_collection;'
p8788
aS'    hp::QCollection<dim>     quadrature_collection;'
p8789
aS'    hp::QCollection<dim - 1> face_quadrature_collection;'
p8790
aS'    AffineConstraints<double> constraints;'
p8791
aS'    SparsityPattern      sparsity_pattern;'
p8792
aS'    SparseMatrix<double> system_matrix;'
p8793
aS'    Vector<double> solution;'
p8794
aS'    Vector<double> system_rhs;'
p8795
aS'    const unsigned int max_degree;'
p8796
aS'  };'
p8797
aS'  template <int dim>'
p8798
aS'  class RightHandSide : public Function<dim>'
p8799
aS'  {'
p8800
aS'  public:'
p8801
aS'    virtual double value(const Point<dim> & p,'
p8802
aS'                         const unsigned int component) const override;'
p8803
aS'  };'
p8804
aS'  template <int dim>'
p8805
aS'  double RightHandSide<dim>::value(const Point<dim> &p,'
p8806
aS'                                   const unsigned int /*component*/) const'
p8807
aS'  {'
p8808
aS'    double product = 1;'
p8809
aS'    for (unsigned int d = 0; d < dim; ++d)'
p8810
aS'      product *= (p[d] + 1);'
p8811
aS'    return product;'
p8812
aS'  }'
p8813
aS'  template <int dim>'
p8814
aS'  LaplaceProblem<dim>::LaplaceProblem()'
p8815
aS'    : dof_handler(triangulation)'
p8816
aS'    , max_degree(dim <= 2 ? 7 : 5)'
p8817
aS'  {'
p8818
aS'    for (unsigned int degree = 2; degree <= max_degree; ++degree)'
p8819
aS'      {'
p8820
aS'        fe_collection.push_back(FE_Q<dim>(degree));'
p8821
aS'        quadrature_collection.push_back(QGauss<dim>(degree + 1));'
p8822
aS'        face_quadrature_collection.push_back(QGauss<dim - 1>(degree + 1));'
p8823
aS'      }'
p8824
aS'  }'
p8825
aS'  template <int dim>'
p8826
aS'  LaplaceProblem<dim>::~LaplaceProblem()'
p8827
aS'  {'
p8828
aS'    dof_handler.clear();'
p8829
aS'  }'
p8830
aS'  template <int dim>'
p8831
aS'  void LaplaceProblem<dim>::setup_system()'
p8832
aS'  {'
p8833
aS'    dof_handler.distribute_dofs(fe_collection);'
p8834
aS'    solution.reinit(dof_handler.n_dofs());'
p8835
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p8836
aS'    constraints.clear();'
p8837
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p8838
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p8839
aS'                                             0,'
p8840
aS'                                             Functions::ZeroFunction<dim>(),'
p8841
aS'                                             constraints);'
p8842
aS'    constraints.close();'
p8843
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p8844
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p8845
aS'    sparsity_pattern.copy_from(dsp);'
p8846
aS'    system_matrix.reinit(sparsity_pattern);'
p8847
aS'  }'
p8848
aS'  template <int dim>'
p8849
aS'  void LaplaceProblem<dim>::assemble_system()'
p8850
aS'  {'
p8851
aS'    hp::FEValues<dim> hp_fe_values(fe_collection,'
p8852
aS'                                   quadrature_collection,'
p8853
aS'                                   update_values | update_gradients |'
p8854
aS'                                     update_quadrature_points |'
p8855
aS'                                     update_JxW_values);'
p8856
aS'    RightHandSide<dim> rhs_function;'
p8857
aS'    FullMatrix<double> cell_matrix;'
p8858
aS'    Vector<double>     cell_rhs;'
p8859
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p8860
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p8861
aS'      {'
p8862
aS'        const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();'
p8863
aS'        cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p8864
aS'        cell_matrix = 0;'
p8865
aS'        cell_rhs.reinit(dofs_per_cell);'
p8866
aS'        cell_rhs = 0;'
p8867
aS'        hp_fe_values.reinit(cell);'
p8868
aS'        const FEValues<dim> &fe_values = hp_fe_values.get_present_fe_values();'
p8869
aS'        std::vector<double> rhs_values(fe_values.n_quadrature_points);'
p8870
aS'        rhs_function.value_list(fe_values.get_quadrature_points(), rhs_values);'
p8871
aS'        for (unsigned int q_point = 0; q_point < fe_values.n_quadrature_points;'
p8872
aS'             ++q_point)'
p8873
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p8874
aS'            {'
p8875
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p8876
aS'                cell_matrix(i, j) +='
p8877
aS'                   fe_values.shape_grad(j, q_point) * // grad phi_j(x_q)'
p8878
aS'                   fe_values.JxW(q_point));           // dx'
p8879
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)'
p8880
aS'                              rhs_values[q_point] *               // f(x_q)'
p8881
aS'                              fe_values.JxW(q_point));            // dx'
p8882
aS'            }'
p8883
aS'        local_dof_indices.resize(dofs_per_cell);'
p8884
aS'        cell->get_dof_indices(local_dof_indices);'
p8885
aS'        constraints.distribute_local_to_global('
p8886
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p8887
aS'      }'
p8888
aS'  }'
p8889
aS'  template <int dim>'
p8890
aS'  void LaplaceProblem<dim>::solve()'
p8891
aS'  {'
p8892
aS'    SolverControl            solver_control(system_rhs.size(),'
p8893
aS'                                 1e-12 * system_rhs.l2_norm());'
p8894
aS'    SolverCG<Vector<double>> cg(solver_control);'
p8895
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p8896
aS'    preconditioner.initialize(system_matrix, 1.2);'
p8897
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p8898
aS'    constraints.distribute(solution);'
p8899
aS'  }'
p8900
aS'  template <int dim>'
p8901
aS'  void LaplaceProblem<dim>::postprocess(const unsigned int cycle)'
p8902
aS'  {'
p8903
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p8904
aS'    KellyErrorEstimator<dim>::estimate('
p8905
aS'      dof_handler,'
p8906
aS'      face_quadrature_collection,'
p8907
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p8908
aS'      solution,'
p8909
aS'      estimated_error_per_cell);'
p8910
aS'    Vector<float> smoothness_indicators(triangulation.n_active_cells());'
p8911
aS'    FESeries::Fourier<dim> fourier ='
p8912
aS'      SmoothnessEstimator::Fourier::default_fe_series(fe_collection);'
p8913
aS'    SmoothnessEstimator::Fourier::coefficient_decay(fourier,'
p8914
aS'                                                    dof_handler,'
p8915
aS'                                                    solution,'
p8916
aS'                                                    smoothness_indicators);'
p8917
aS'    {'
p8918
aS'      Vector<float> fe_degrees(triangulation.n_active_cells());'
p8919
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p8920
aS'        fe_degrees(cell->active_cell_index()) ='
p8921
aS'          fe_collection[cell->active_fe_index()].degree;'
p8922
aS'      DataOut<dim> data_out;'
p8923
aS'      data_out.attach_dof_handler(dof_handler);'
p8924
aS'      data_out.add_data_vector(solution, "solution");'
p8925
aS'      data_out.add_data_vector(estimated_error_per_cell, "error");'
p8926
aS'      data_out.add_data_vector(smoothness_indicators, "smoothness");'
p8927
aS'      data_out.add_data_vector(fe_degrees, "fe_degree");'
p8928
aS'      data_out.build_patches();'
p8929
aS'      const std::string filename ='
p8930
aS'        "solution-" + Utilities::int_to_string(cycle, 2) + ".vtk";'
p8931
aS'      std::ofstream output(filename);'
p8932
aS'      data_out.write_vtk(output);'
p8933
aS'    }'
p8934
aS'    {'
p8935
aS'      GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p8936
aS'                                                      estimated_error_per_cell,'
p8937
aS'                                                      0.3,'
p8938
aS'                                                      0.03);'
p8939
aS'      hp::Refinement::p_adaptivity_from_relative_threshold('
p8940
aS'        dof_handler, smoothness_indicators, 0.2, 0.2);'
p8941
aS'      hp::Refinement::choose_p_over_h(dof_handler);'
p8942
aS'      triangulation.prepare_coarsening_and_refinement();'
p8943
aS'      hp::Refinement::limit_p_level_difference(dof_handler);'
p8944
aS'      triangulation.execute_coarsening_and_refinement();'
p8945
aS'    }'
p8946
aS'  }'
p8947
aS'  template <int dim>'
p8948
aS'  void LaplaceProblem<dim>::create_coarse_grid()'
p8949
aS'  {'
p8950
aS'    Triangulation<dim> cube;'
p8951
aS'    GridGenerator::subdivided_hyper_cube(cube, 4, -1., 1.);'
p8952
aS'    std::set<typename Triangulation<dim>::active_cell_iterator> cells_to_remove;'
p8953
aS'    for (const auto &cell : cube.active_cell_iterators())'
p8954
aS'      for (unsigned int v = 0; v < GeometryInfo<dim>::vertices_per_cell; ++v)'
p8955
aS'        if (cell->vertex(v).square() < .1)'
p8956
aS'          cells_to_remove.insert(cell);'
p8957
aS'    GridGenerator::create_triangulation_with_removed_cells(cube,'
p8958
aS'                                                           cells_to_remove,'
p8959
aS'                                                           triangulation);'
p8960
aS'    triangulation.refine_global(3);'
p8961
aS'  }'
p8962
aS'  template <int dim>'
p8963
aS'  void LaplaceProblem<dim>::run()'
p8964
aS'  {'
p8965
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p8966
aS'      {'
p8967
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p8968
aS'        if (cycle == 0)'
p8969
aS'          create_coarse_grid();'
p8970
aS'        setup_system();'
p8971
aS'        std::cout << "   Number of active cells      : "'
p8972
aS'                  << triangulation.n_active_cells() << std::endl'
p8973
aS'                  << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p8974
aS'                  << std::endl'
p8975
aS'                  << "   Number of constraints       : "'
p8976
aS'                  << constraints.n_constraints() << std::endl;'
p8977
aS'        assemble_system();'
p8978
aS'        solve();'
p8979
aS'        postprocess(cycle);'
p8980
aS'      }'
p8981
aS'  }'
p8982
aS'} // namespace Step27'
p8983
aS'int main()'
p8984
ag9
aS'  try'
p8985
aS'    {'
p8986
aS'      using namespace Step27;'
p8987
aS'      LaplaceProblem<2> laplace_problem;'
p8988
aS'      laplace_problem.run();'
p8989
aS'    }'
p8990
aS'  catch (std::exception &exc)'
p8991
aS'    {'
p8992
aS'      std::cerr << std::endl'
p8993
aS'                << std::endl'
p8994
aS'                << "----------------------------------------------------"'
p8995
aS'                << std::endl;'
p8996
aS'      std::cerr << "Exception on processing: " << std::endl'
p8997
aS'                << exc.what() << std::endl'
p8998
aS'                << "Aborting!" << std::endl'
p8999
aS'                << "----------------------------------------------------"'
p9000
aS'                << std::endl;'
p9001
aS'      return 1;'
p9002
aS'    }'
p9003
aS'  catch (...)'
p9004
aS'    {'
p9005
aS'      std::cerr << std::endl'
p9006
aS'                << std::endl'
p9007
aS'                << "----------------------------------------------------"'
p9008
aS'                << std::endl;'
p9009
aS'      std::cerr << "Unknown exception!" << std::endl'
p9010
aS'                << "Aborting!" << std::endl'
p9011
aS'                << "----------------------------------------------------"'
p9012
aS'                << std::endl;'
p9013
aS'      return 1;'
p9014
aS'    }'
p9015
aS'  return 0;'
p9016
ag17
aS'#include <deal.II/base/timer.h>'
p9017
aS'#include <deal.II/base/quadrature_lib.h>'
p9018
aS'#include <deal.II/base/function.h>'
p9019
aS'#include <deal.II/base/parameter_handler.h>'
p9020
aS'#include <deal.II/base/thread_management.h>'
p9021
aS'#include <deal.II/base/utilities.h>'
p9022
aS'#include <deal.II/lac/vector.h>'
p9023
aS'#include <deal.II/lac/full_matrix.h>'
p9024
aS'#include <deal.II/lac/sparsity_pattern.h>'
p9025
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p9026
aS'#include <deal.II/lac/sparse_matrix.h>'
p9027
aS'#include <deal.II/lac/solver_cg.h>'
p9028
aS'#include <deal.II/lac/precondition.h>'
p9029
aS'#include <deal.II/lac/affine_constraints.h>'
p9030
aS'#include <deal.II/grid/tria.h>'
p9031
aS'#include <deal.II/grid/grid_refinement.h>'
p9032
aS'#include <deal.II/grid/grid_out.h>'
p9033
aS'#include <deal.II/grid/grid_generator.h>'
p9034
aS'#include <deal.II/dofs/dof_handler.h>'
p9035
aS'#include <deal.II/dofs/dof_tools.h>'
p9036
aS'#include <deal.II/fe/fe_q.h>'
p9037
aS'#include <deal.II/fe/fe_values.h>'
p9038
aS'#include <deal.II/numerics/vector_tools.h>'
p9039
aS'#include <deal.II/numerics/matrix_tools.h>'
p9040
aS'#include <deal.II/numerics/data_out.h>'
p9041
aS'#include <deal.II/numerics/error_estimator.h>'
p9042
aS'#include <fstream>'
p9043
aS'#include <iostream>'
p9044
aS'#include <deal.II/lac/block_vector.h>'
p9045
aS'#include <deal.II/numerics/solution_transfer.h>'
p9046
aS'#include <deal.II/grid/grid_tools.h>'
p9047
aS'#include <boost/io/ios_state.hpp>'
p9048
aS'#include <list>'
p9049
aS'#include <iomanip>'
p9050
aS'namespace Step28'
p9051
ag9
aS'  using namespace dealii;'
p9052
aS'  class MaterialData'
p9053
aS'  {'
p9054
aS'  public:'
p9055
aS'    MaterialData(const unsigned int n_groups);'
p9056
aS'    double get_diffusion_coefficient(const unsigned int group,'
p9057
aS'                                     const unsigned int material_id) const;'
p9058
aS'    double get_removal_XS(const unsigned int group,'
p9059
aS'                          const unsigned int material_id) const;'
p9060
aS'    double get_fission_XS(const unsigned int group,'
p9061
aS'                          const unsigned int material_id) const;'
p9062
aS'    double get_fission_dist_XS(const unsigned int group_1,'
p9063
aS'                               const unsigned int group_2,'
p9064
aS'                               const unsigned int material_id) const;'
p9065
aS'    double get_scattering_XS(const unsigned int group_1,'
p9066
aS'                             const unsigned int group_2,'
p9067
aS'                             const unsigned int material_id) const;'
p9068
aS'    double get_fission_spectrum(const unsigned int group,'
p9069
aS'                                const unsigned int material_id) const;'
p9070
aS'  private:'
p9071
aS'    const unsigned int n_groups;'
p9072
aS'    const unsigned int n_materials;'
p9073
aS'    Table<2, double> diffusion;'
p9074
aS'    Table<2, double> sigma_r;'
p9075
aS'    Table<2, double> nu_sigma_f;'
p9076
aS'    Table<3, double> sigma_s;'
p9077
aS'    Table<2, double> chi;'
p9078
aS'  };'
p9079
aS'  MaterialData::MaterialData(const unsigned int n_groups)'
p9080
aS'    : n_groups(n_groups)'
p9081
aS'    , n_materials(8)'
p9082
aS'    , diffusion(n_materials, n_groups)'
p9083
aS'    , sigma_r(n_materials, n_groups)'
p9084
aS'    , nu_sigma_f(n_materials, n_groups)'
p9085
aS'    , sigma_s(n_materials, n_groups, n_groups)'
p9086
aS'    , chi(n_materials, n_groups)'
p9087
aS'  {'
p9088
aS'    switch (this->n_groups)'
p9089
aS'      {'
p9090
aS'        case 2:'
p9091
aS'          {'
p9092
aS'            for (unsigned int m = 0; m < n_materials; ++m)'
p9093
aS'              {'
p9094
aS'                diffusion[m][0] = 1.2;'
p9095
aS'                diffusion[m][1] = 0.4;'
p9096
aS'                chi[m][0]       = 1.0;'
p9097
aS'                chi[m][1]       = 0.0;'
p9098
aS'                sigma_r[m][0]   = 0.03;'
p9099
aS'                for (unsigned int group_1 = 0; group_1 < n_groups; ++group_1)'
p9100
aS'                  for (unsigned int group_2 = 0; group_2 < n_groups; ++group_2)'
p9101
aS'                    sigma_s[m][group_1][group_2] = 0.0;'
p9102
aS'              }'
p9103
aS'            diffusion[5][1] = 0.2;'
p9104
aS'            sigma_r[4][0] = 0.026;'
p9105
aS'            sigma_r[5][0] = 0.051;'
p9106
aS'            sigma_r[6][0] = 0.026;'
p9107
aS'            sigma_r[7][0] = 0.050;'
p9108
aS'            sigma_r[0][1] = 0.100;'
p9109
aS'            sigma_r[1][1] = 0.200;'
p9110
aS'            sigma_r[2][1] = 0.250;'
p9111
aS'            sigma_r[3][1] = 0.300;'
p9112
aS'            sigma_r[4][1] = 0.020;'
p9113
aS'            sigma_r[5][1] = 0.040;'
p9114
aS'            sigma_r[6][1] = 0.020;'
p9115
aS'            sigma_r[7][1] = 0.800;'
p9116
aS'            nu_sigma_f[0][0] = 0.0050;'
p9117
aS'            nu_sigma_f[1][0] = 0.0075;'
p9118
aS'            nu_sigma_f[2][0] = 0.0075;'
p9119
aS'            nu_sigma_f[3][0] = 0.0075;'
p9120
aS'            nu_sigma_f[4][0] = 0.000;'
p9121
aS'            nu_sigma_f[5][0] = 0.000;'
p9122
aS'            nu_sigma_f[6][0] = 1e-7;'
p9123
aS'            nu_sigma_f[7][0] = 0.00;'
p9124
aS'            nu_sigma_f[0][1] = 0.125;'
p9125
aS'            nu_sigma_f[1][1] = 0.300;'
p9126
aS'            nu_sigma_f[2][1] = 0.375;'
p9127
aS'            nu_sigma_f[3][1] = 0.450;'
p9128
aS'            nu_sigma_f[4][1] = 0.000;'
p9129
aS'            nu_sigma_f[5][1] = 0.000;'
p9130
aS'            nu_sigma_f[6][1] = 3e-6;'
p9131
aS'            nu_sigma_f[7][1] = 0.00;'
p9132
aS'            sigma_s[0][0][1] = 0.020;'
p9133
aS'            sigma_s[1][0][1] = 0.015;'
p9134
aS'            sigma_s[2][0][1] = 0.015;'
p9135
aS'            sigma_s[3][0][1] = 0.015;'
p9136
aS'            sigma_s[4][0][1] = 0.025;'
p9137
aS'            sigma_s[5][0][1] = 0.050;'
p9138
aS'            sigma_s[6][0][1] = 0.025;'
p9139
aS'            sigma_s[7][0][1] = 0.010;'
p9140
aS'            break;'
p9141
aS'          }'
p9142
aS'        default:'
p9143
aS'          Assert(false,'
p9144
aS'                 ExcMessage('
p9145
aS'                   "Presently, only data for 2 groups is implemented"));'
p9146
aS'      }'
p9147
aS'  }'
p9148
aS'  double'
p9149
aS'  MaterialData::get_diffusion_coefficient(const unsigned int group,'
p9150
aS'                                          const unsigned int material_id) const'
p9151
aS'  {'
p9152
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9153
aS'    Assert(material_id < n_materials,'
p9154
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9155
aS'    return diffusion[material_id][group];'
p9156
aS'  }'
p9157
aS'  double MaterialData::get_removal_XS(const unsigned int group,'
p9158
aS'                                      const unsigned int material_id) const'
p9159
aS'  {'
p9160
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9161
aS'    Assert(material_id < n_materials,'
p9162
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9163
aS'    return sigma_r[material_id][group];'
p9164
aS'  }'
p9165
aS'  double MaterialData::get_fission_XS(const unsigned int group,'
p9166
aS'                                      const unsigned int material_id) const'
p9167
aS'  {'
p9168
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9169
aS'    Assert(material_id < n_materials,'
p9170
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9171
aS'    return nu_sigma_f[material_id][group];'
p9172
aS'  }'
p9173
aS'  double MaterialData::get_scattering_XS(const unsigned int group_1,'
p9174
aS'                                         const unsigned int group_2,'
p9175
aS'                                         const unsigned int material_id) const'
p9176
aS'  {'
p9177
aS'    Assert(group_1 < n_groups, ExcIndexRange(group_1, 0, n_groups));'
p9178
aS'    Assert(group_2 < n_groups, ExcIndexRange(group_2, 0, n_groups));'
p9179
aS'    Assert(material_id < n_materials,'
p9180
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9181
aS'    return sigma_s[material_id][group_1][group_2];'
p9182
aS'  }'
p9183
aS'  double'
p9184
aS'  MaterialData::get_fission_spectrum(const unsigned int group,'
p9185
aS'                                     const unsigned int material_id) const'
p9186
aS'  {'
p9187
aS'    Assert(group < n_groups, ExcIndexRange(group, 0, n_groups));'
p9188
aS'    Assert(material_id < n_materials,'
p9189
aS'           ExcIndexRange(material_id, 0, n_materials));'
p9190
aS'    return chi[material_id][group];'
p9191
aS'  }'
p9192
aS'  double MaterialData::get_fission_dist_XS(const unsigned int group_1,'
p9193
aS'                                           const unsigned int group_2,'
p9194
aS'                                           const unsigned int material_id) const'
p9195
aS'  {'
p9196
aS'    return (get_fission_spectrum(group_1, material_id) *'
p9197
aS'            get_fission_XS(group_2, material_id));'
p9198
aS'  }'
p9199
aS'  template <int dim>'
p9200
aS'  class EnergyGroup'
p9201
aS'  {'
p9202
aS'  public:'
p9203
aS'    EnergyGroup(const unsigned int        group,'
p9204
aS'                const MaterialData &      material_data,'
p9205
aS'                const Triangulation<dim> &coarse_grid,'
p9206
aS'                const FiniteElement<dim> &fe);'
p9207
aS'    void setup_linear_system();'
p9208
aS'    unsigned int n_active_cells() const;'
p9209
aS'    unsigned int n_dofs() const;'
p9210
aS'    void assemble_system_matrix();'
p9211
aS'    void assemble_ingroup_rhs(const Function<dim> &extraneous_source);'
p9212
aS'    void assemble_cross_group_rhs(const EnergyGroup<dim> &g_prime);'
p9213
aS'    void solve();'
p9214
aS'    double get_fission_source() const;'
p9215
aS'    void output_results(const unsigned int cycle) const;'
p9216
aS'    void estimate_errors(Vector<float> &error_indicators) const;'
p9217
aS'    void refine_grid(const Vector<float> &error_indicators,'
p9218
aS'                     const double         refine_threshold,'
p9219
aS'                     const double         coarsen_threshold);'
p9220
aS'  public:'
p9221
aS'    Vector<double> solution;'
p9222
aS'    Vector<double> solution_old;'
p9223
aS'  private:'
p9224
aS'    const unsigned int  group;'
p9225
aS'    const MaterialData &material_data;'
p9226
aS'    Triangulation<dim>        triangulation;'
p9227
aS'    const FiniteElement<dim> &fe;'
p9228
aS'    DoFHandler<dim>           dof_handler;'
p9229
aS'    SparsityPattern      sparsity_pattern;'
p9230
aS'    SparseMatrix<double> system_matrix;'
p9231
aS'    Vector<double> system_rhs;'
p9232
aS'    std::map<types::global_dof_index, double> boundary_values;'
p9233
aS'    AffineConstraints<double>                 hanging_node_constraints;'
p9234
aS'  private:'
p9235
aS'    void assemble_cross_group_rhs_recursive('
p9236
aS'      const EnergyGroup<dim> &                       g_prime,'
p9237
aS'      const typename DoFHandler<dim>::cell_iterator &cell_g,'
p9238
aS'      const typename DoFHandler<dim>::cell_iterator &cell_g_prime,'
p9239
aS'      const FullMatrix<double> &                     prolongation_matrix);'
p9240
aS'  };'
p9241
aS'  template <int dim>'
p9242
aS'  EnergyGroup<dim>::EnergyGroup(const unsigned int        group,'
p9243
aS'                                const MaterialData &      material_data,'
p9244
aS'                                const Triangulation<dim> &coarse_grid,'
p9245
aS'                                const FiniteElement<dim> &fe)'
p9246
aS'    : group(group)'
p9247
aS'    , material_data(material_data)'
p9248
aS'    , fe(fe)'
p9249
aS'    , dof_handler(triangulation)'
p9250
aS'  {'
p9251
aS'    triangulation.copy_triangulation(coarse_grid);'
p9252
aS'    dof_handler.distribute_dofs(fe);'
p9253
aS'  }'
p9254
aS'  template <int dim>'
p9255
aS'  unsigned int EnergyGroup<dim>::n_active_cells() const'
p9256
aS'  {'
p9257
aS'    return triangulation.n_active_cells();'
p9258
aS'  }'
p9259
aS'  template <int dim>'
p9260
aS'  unsigned int EnergyGroup<dim>::n_dofs() const'
p9261
aS'  {'
p9262
aS'    return dof_handler.n_dofs();'
p9263
aS'  }'
p9264
aS'  template <int dim>'
p9265
aS'  void EnergyGroup<dim>::setup_linear_system()'
p9266
aS'  {'
p9267
aS'    const unsigned int n_dofs = dof_handler.n_dofs();'
p9268
aS'    hanging_node_constraints.clear();'
p9269
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p9270
aS'                                            hanging_node_constraints);'
p9271
aS'    hanging_node_constraints.close();'
p9272
aS'    system_matrix.clear();'
p9273
aS'    DynamicSparsityPattern dsp(n_dofs, n_dofs);'
p9274
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p9275
aS'    hanging_node_constraints.condense(dsp);'
p9276
aS'    sparsity_pattern.copy_from(dsp);'
p9277
aS'    system_matrix.reinit(sparsity_pattern);'
p9278
aS'    system_rhs.reinit(n_dofs);'
p9279
aS'    if (solution.size() == 0)'
p9280
aS'      {'
p9281
aS'        solution.reinit(n_dofs);'
p9282
aS'        solution_old.reinit(n_dofs);'
p9283
aS'        solution_old = 1.0;'
p9284
aS'        solution     = solution_old;'
p9285
aS'      }'
p9286
aS'    boundary_values.clear();'
p9287
aS'    for (unsigned int i = 0; i < dim; ++i)'
p9288
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p9289
aS'                                               2 * i + 1,'
p9290
aS'                                               Functions::ZeroFunction<dim>(),'
p9291
aS'                                               boundary_values);'
p9292
aS'  }'
p9293
aS'  template <int dim>'
p9294
aS'  void EnergyGroup<dim>::assemble_system_matrix()'
p9295
aS'  {'
p9296
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p9297
aS'    FEValues<dim> fe_values(fe,'
p9298
aS'                            quadrature_formula,'
p9299
aS'                            update_values | update_gradients |'
p9300
aS'                              update_JxW_values);'
p9301
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p9302
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p9303
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p9304
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p9305
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p9306
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9307
aS'      {'
p9308
aS'        cell_matrix = 0;'
p9309
aS'        fe_values.reinit(cell);'
p9310
aS'        const double diffusion_coefficient ='
p9311
aS'          material_data.get_diffusion_coefficient(group, cell->material_id());'
p9312
aS'        const double removal_XS ='
p9313
aS'          material_data.get_removal_XS(group, cell->material_id());'
p9314
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9315
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9316
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p9317
aS'              cell_matrix(i, j) +='
p9318
aS'                    fe_values.shape_grad(j, q_point) +'
p9319
aS'                  removal_XS * fe_values.shape_value(i, q_point) *'
p9320
aS'                    fe_values.shape_value(j, q_point)) *'
p9321
aS'                 fe_values.JxW(q_point));'
p9322
aS'        cell->get_dof_indices(local_dof_indices);'
p9323
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9324
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p9325
aS'            system_matrix.add(local_dof_indices[i],'
p9326
aS'                              local_dof_indices[j],'
p9327
aS'                              cell_matrix(i, j));'
p9328
aS'      }'
p9329
aS'    hanging_node_constraints.condense(system_matrix);'
p9330
aS'  }'
p9331
aS'  template <int dim>'
p9332
aS'  void'
p9333
aS'  EnergyGroup<dim>::assemble_ingroup_rhs(const Function<dim> &extraneous_source)'
p9334
aS'  {'
p9335
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p9336
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p9337
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p9338
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p9339
aS'    FEValues<dim> fe_values(fe,'
p9340
aS'                            quadrature_formula,'
p9341
aS'                            update_values | update_quadrature_points |'
p9342
aS'                              update_JxW_values);'
p9343
aS'    Vector<double>      cell_rhs(dofs_per_cell);'
p9344
aS'    std::vector<double> extraneous_source_values(n_q_points);'
p9345
aS'    std::vector<double> solution_old_values(n_q_points);'
p9346
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p9347
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9348
aS'      {'
p9349
aS'        cell_rhs = 0;'
p9350
aS'        fe_values.reinit(cell);'
p9351
aS'        const double fission_dist_XS ='
p9352
aS'          material_data.get_fission_dist_XS(group, group, cell->material_id());'
p9353
aS'        extraneous_source.value_list(fe_values.get_quadrature_points(),'
p9354
aS'                                     extraneous_source_values);'
p9355
aS'        fe_values.get_function_values(solution_old, solution_old_values);'
p9356
aS'        cell->get_dof_indices(local_dof_indices);'
p9357
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9358
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9359
aS'            cell_rhs(i) +='
p9360
aS'                fission_dist_XS * solution_old_values[q_point]) *'
p9361
aS'               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));'
p9362
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p9363
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p9364
aS'      }'
p9365
aS'  }'
p9366
aS'  template <int dim>'
p9367
aS'  void'
p9368
aS'  EnergyGroup<dim>::assemble_cross_group_rhs(const EnergyGroup<dim> &g_prime)'
p9369
aS'  {'
p9370
aS'    if (group == g_prime.group)'
p9371
aS'      return;'
p9372
aS'    const std::list<std::pair<typename DoFHandler<dim>::cell_iterator,'
p9373
aS'                              typename DoFHandler<dim>::cell_iterator>>'
p9374
aS'      cell_list ='
p9375
aS'        GridTools::get_finest_common_cells(dof_handler, g_prime.dof_handler);'
p9376
aS'    for (const auto &cell_pair : cell_list)'
p9377
aS'      {'
p9378
aS'        FullMatrix<double> unit_matrix(fe.n_dofs_per_cell());'
p9379
aS'        for (unsigned int i = 0; i < unit_matrix.m(); ++i)'
p9380
aS'          unit_matrix(i, i) = 1;'
p9381
aS'        assemble_cross_group_rhs_recursive(g_prime,'
p9382
aS'                                           cell_pair.first,'
p9383
aS'                                           cell_pair.second,'
p9384
aS'                                           unit_matrix);'
p9385
aS'      }'
p9386
aS'  }'
p9387
aS'  template <int dim>'
p9388
aS'  void EnergyGroup<dim>::assemble_cross_group_rhs_recursive('
p9389
aS'    const EnergyGroup<dim> &                       g_prime,'
p9390
aS'    const typename DoFHandler<dim>::cell_iterator &cell_g,'
p9391
aS'    const typename DoFHandler<dim>::cell_iterator &cell_g_prime,'
p9392
aS'    const FullMatrix<double> &                     prolongation_matrix)'
p9393
aS'  {'
p9394
aS'    if (!cell_g->has_children() && !cell_g_prime->has_children())'
p9395
aS'      {'
p9396
aS'        const QGauss<dim>  quadrature_formula(fe.degree + 1);'
p9397
aS'        const unsigned int n_q_points = quadrature_formula.size();'
p9398
aS'        FEValues<dim> fe_values(fe,'
p9399
aS'                                quadrature_formula,'
p9400
aS'                                update_values | update_JxW_values);'
p9401
aS'        if (cell_g->level() > cell_g_prime->level())'
p9402
aS'          fe_values.reinit(cell_g);'
p9403
aS'        else'
p9404
aS'          fe_values.reinit(cell_g_prime);'
p9405
aS'        const double fission_dist_XS ='
p9406
aS'          material_data.get_fission_dist_XS(group,'
p9407
aS'                                            g_prime.group,'
p9408
aS'                                            cell_g_prime->material_id());'
p9409
aS'        const double scattering_XS ='
p9410
aS'          material_data.get_scattering_XS(g_prime.group,'
p9411
aS'                                          group,'
p9412
aS'                                          cell_g_prime->material_id());'
p9413
aS'        FullMatrix<double> local_mass_matrix_f(fe.n_dofs_per_cell(),'
p9414
aS'                                               fe.n_dofs_per_cell());'
p9415
aS'        FullMatrix<double> local_mass_matrix_g(fe.n_dofs_per_cell(),'
p9416
aS'                                               fe.n_dofs_per_cell());'
p9417
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9418
aS'          for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p9419
aS'            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p9420
aS'              {'
p9421
aS'                local_mass_matrix_f(i, j) +='
p9422
aS'                   fe_values.shape_value(j, q_point) * fe_values.JxW(q_point));'
p9423
aS'                local_mass_matrix_g(i, j) +='
p9424
aS'                   fe_values.shape_value(j, q_point) * fe_values.JxW(q_point));'
p9425
aS'              }'
p9426
aS'        Vector<double> g_prime_new_values(fe.n_dofs_per_cell());'
p9427
aS'        Vector<double> g_prime_old_values(fe.n_dofs_per_cell());'
p9428
aS'        cell_g_prime->get_dof_values(g_prime.solution_old, g_prime_old_values);'
p9429
aS'        cell_g_prime->get_dof_values(g_prime.solution, g_prime_new_values);'
p9430
aS'        Vector<double> cell_rhs(fe.n_dofs_per_cell());'
p9431
aS'        Vector<double> tmp(fe.n_dofs_per_cell());'
p9432
aS'        if (cell_g->level() > cell_g_prime->level())'
p9433
aS'          {'
p9434
aS'            prolongation_matrix.vmult(tmp, g_prime_old_values);'
p9435
aS'            local_mass_matrix_f.vmult(cell_rhs, tmp);'
p9436
aS'            prolongation_matrix.vmult(tmp, g_prime_new_values);'
p9437
aS'            local_mass_matrix_g.vmult_add(cell_rhs, tmp);'
p9438
aS'          }'
p9439
aS'        else'
p9440
aS'          {'
p9441
aS'            local_mass_matrix_f.vmult(tmp, g_prime_old_values);'
p9442
aS'            prolongation_matrix.Tvmult(cell_rhs, tmp);'
p9443
aS'            local_mass_matrix_g.vmult(tmp, g_prime_new_values);'
p9444
aS'            prolongation_matrix.Tvmult_add(cell_rhs, tmp);'
p9445
aS'          }'
p9446
aS'        std::vector<types::global_dof_index> local_dof_indices('
p9447
aS'          fe.n_dofs_per_cell());'
p9448
aS'        cell_g->get_dof_indices(local_dof_indices);'
p9449
aS'        for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p9450
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p9451
aS'      }'
p9452
aS'    else'
p9453
aS'      for (unsigned int child = 0;'
p9454
aS'           child < GeometryInfo<dim>::max_children_per_cell;'
p9455
aS'           ++child)'
p9456
aS'        {'
p9457
aS'          FullMatrix<double> new_matrix(fe.n_dofs_per_cell(),'
p9458
aS'                                        fe.n_dofs_per_cell());'
p9459
aS'          fe.get_prolongation_matrix(child).mmult(new_matrix,'
p9460
aS'                                                  prolongation_matrix);'
p9461
aS'          if (cell_g->has_children())'
p9462
aS'            assemble_cross_group_rhs_recursive(g_prime,'
p9463
aS'                                               cell_g->child(child),'
p9464
aS'                                               cell_g_prime,'
p9465
aS'                                               new_matrix);'
p9466
aS'          else'
p9467
aS'            assemble_cross_group_rhs_recursive(g_prime,'
p9468
aS'                                               cell_g,'
p9469
aS'                                               cell_g_prime->child(child),'
p9470
aS'                                               new_matrix);'
p9471
aS'        }'
p9472
aS'  }'
p9473
aS'  template <int dim>'
p9474
aS'  double EnergyGroup<dim>::get_fission_source() const'
p9475
aS'  {'
p9476
aS'    const QGauss<dim>  quadrature_formula(fe.degree + 1);'
p9477
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p9478
aS'    FEValues<dim> fe_values(fe,'
p9479
aS'                            quadrature_formula,'
p9480
aS'                            update_values | update_JxW_values);'
p9481
aS'    std::vector<double> solution_values(n_q_points);'
p9482
aS'    double fission_source = 0;'
p9483
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p9484
aS'      {'
p9485
aS'        fe_values.reinit(cell);'
p9486
aS'        const double fission_XS ='
p9487
aS'          material_data.get_fission_XS(group, cell->material_id());'
p9488
aS'        fe_values.get_function_values(solution, solution_values);'
p9489
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p9490
aS'          fission_source +='
p9491
aS'      }'
p9492
aS'    return fission_source;'
p9493
aS'  }'
p9494
aS'  template <int dim>'
p9495
aS'  void EnergyGroup<dim>::solve()'
p9496
aS'  {'
p9497
aS'    hanging_node_constraints.condense(system_rhs);'
p9498
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p9499
aS'                                       system_matrix,'
p9500
aS'                                       solution,'
p9501
aS'                                       system_rhs);'
p9502
aS'    SolverControl            solver_control(system_matrix.m(),'
p9503
aS'                                 1e-12 * system_rhs.l2_norm());'
p9504
aS'    SolverCG<Vector<double>> cg(solver_control);'
p9505
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p9506
aS'    preconditioner.initialize(system_matrix, 1.2);'
p9507
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p9508
aS'    hanging_node_constraints.distribute(solution);'
p9509
aS'  }'
p9510
aS'  template <int dim>'
p9511
aS'  void EnergyGroup<dim>::estimate_errors(Vector<float> &error_indicators) const'
p9512
aS'  {'
p9513
aS'    KellyErrorEstimator<dim>::estimate('
p9514
aS'      dof_handler,'
p9515
aS'      QGauss<dim - 1>(fe.degree + 1),'
p9516
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p9517
aS'      solution,'
p9518
aS'      error_indicators);'
p9519
aS'    error_indicators /= solution.linfty_norm();'
p9520
aS'  }'
p9521
aS'  template <int dim>'
p9522
aS'  void EnergyGroup<dim>::refine_grid(const Vector<float> &error_indicators,'
p9523
aS'                                     const double         refine_threshold,'
p9524
aS'                                     const double         coarsen_threshold)'
p9525
aS'  {'
p9526
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p9527
aS'      if (error_indicators(cell->active_cell_index()) > refine_threshold)'
p9528
aS'        cell->set_refine_flag();'
p9529
aS'      else if (error_indicators(cell->active_cell_index()) < coarsen_threshold)'
p9530
aS'        cell->set_coarsen_flag();'
p9531
aS'    SolutionTransfer<dim> soltrans(dof_handler);'
p9532
aS'    triangulation.prepare_coarsening_and_refinement();'
p9533
aS'    soltrans.prepare_for_coarsening_and_refinement(solution);'
p9534
aS'    triangulation.execute_coarsening_and_refinement();'
p9535
aS'    dof_handler.distribute_dofs(fe);'
p9536
aS'    setup_linear_system();'
p9537
aS'    solution.reinit(dof_handler.n_dofs());'
p9538
aS'    soltrans.interpolate(solution_old, solution);'
p9539
aS'    hanging_node_constraints.distribute(solution);'
p9540
aS'    solution_old.reinit(dof_handler.n_dofs());'
p9541
aS'    solution_old = solution;'
p9542
aS'  }'
p9543
aS'  template <int dim>'
p9544
aS'  void EnergyGroup<dim>::output_results(const unsigned int cycle) const'
p9545
aS'  {'
p9546
aS'    const std::string filename = std::string("solution-") +'
p9547
aS'                                 Utilities::int_to_string(group, 2) + "." +'
p9548
aS'                                 Utilities::int_to_string(cycle, 2) + ".vtu";'
p9549
aS'    DataOut<dim> data_out;'
p9550
aS'    data_out.attach_dof_handler(dof_handler);'
p9551
aS'    data_out.add_data_vector(solution, "solution");'
p9552
aS'    data_out.build_patches();'
p9553
aS'    std::ofstream output(filename);'
p9554
aS'    data_out.write_vtu(output);'
p9555
aS'  }'
p9556
aS'  template <int dim>'
p9557
aS'  class NeutronDiffusionProblem'
p9558
aS'  {'
p9559
aS'  public:'
p9560
aS'    class Parameters'
p9561
aS'    {'
p9562
aS'    public:'
p9563
aS'      Parameters();'
p9564
aS'      static void declare_parameters(ParameterHandler &prm);'
p9565
aS'      void        get_parameters(ParameterHandler &prm);'
p9566
aS'      unsigned int n_groups;'
p9567
aS'      unsigned int n_refinement_cycles;'
p9568
aS'      unsigned int fe_degree;'
p9569
aS'      double convergence_tolerance;'
p9570
aS'    };'
p9571
aS'    NeutronDiffusionProblem(const Parameters &parameters);'
p9572
aS'    void run();'
p9573
aS'  private:'
p9574
aS'    void initialize_problem();'
p9575
aS'    void refine_grid();'
p9576
aS'    double get_total_fission_source() const;'
p9577
aS'    const Parameters & parameters;'
p9578
aS'    const MaterialData material_data;'
p9579
aS'    FE_Q<dim>          fe;'
p9580
aS'    double k_eff;'
p9581
aS'    std::vector<std::unique_ptr<EnergyGroup<dim>>> energy_groups;'
p9582
aS'    std::ofstream convergence_table_stream;'
p9583
aS'  };'
p9584
aS'  template <int dim>'
p9585
aS'  NeutronDiffusionProblem<dim>::Parameters::Parameters()'
p9586
aS'    : n_groups(2)'
p9587
aS'    , n_refinement_cycles(5)'
p9588
aS'    , fe_degree(2)'
p9589
aS'    , convergence_tolerance(1e-12)'
p9590
aS'  {}'
p9591
aS'  template <int dim>'
p9592
aS'  void NeutronDiffusionProblem<dim>::Parameters::declare_parameters('
p9593
aS'    ParameterHandler &prm)'
p9594
aS'  {'
p9595
aS'    prm.declare_entry("Number of energy groups",'
p9596
aS'                      "2",'
p9597
aS'                      Patterns::Integer(),'
p9598
aS'                      "The number of energy different groups considered");'
p9599
aS'    prm.declare_entry("Refinement cycles",'
p9600
aS'                      "5",'
p9601
aS'                      Patterns::Integer(),'
p9602
aS'                      "Number of refinement cycles to be performed");'
p9603
aS'    prm.declare_entry("Finite element degree",'
p9604
aS'                      "2",'
p9605
aS'                      Patterns::Integer(),'
p9606
aS'                      "Polynomial degree of the finite element to be used");'
p9607
aS'    prm.declare_entry('
p9608
aS'      "Power iteration tolerance",'
p9609
aS'      "1e-12",'
p9610
aS'      Patterns::Double(),'
p9611
aS'      "Inner power iterations are stopped when the change in k_eff falls "'
p9612
aS'      "below this tolerance");'
p9613
aS'  }'
p9614
aS'  template <int dim>'
p9615
aS'  void NeutronDiffusionProblem<dim>::Parameters::get_parameters('
p9616
aS'    ParameterHandler &prm)'
p9617
aS'  {'
p9618
aS'    n_groups              = prm.get_integer("Number of energy groups");'
p9619
aS'    n_refinement_cycles   = prm.get_integer("Refinement cycles");'
p9620
aS'    fe_degree             = prm.get_integer("Finite element degree");'
p9621
aS'    convergence_tolerance = prm.get_double("Power iteration tolerance");'
p9622
aS'  }'
p9623
aS'  template <int dim>'
p9624
aS'  NeutronDiffusionProblem<dim>::NeutronDiffusionProblem('
p9625
aS'    const Parameters &parameters)'
p9626
aS'    : parameters(parameters)'
p9627
aS'    , material_data(parameters.n_groups)'
p9628
aS'    , fe(parameters.fe_degree)'
p9629
aS'    , k_eff(std::numeric_limits<double>::quiet_NaN())'
p9630
aS'  {}'
p9631
aS'  template <int dim>'
p9632
aS'  void NeutronDiffusionProblem<dim>::initialize_problem()'
p9633
aS'  {'
p9634
aS'    const unsigned int rods_per_assembly_x = 17, rods_per_assembly_y = 17;'
p9635
aS'    const double       pin_pitch_x = 1.26, pin_pitch_y = 1.26;'
p9636
aS'    const double       assembly_height = 200;'
p9637
aS'    const unsigned int assemblies_x = 2, assemblies_y = 2, assemblies_z = 1;'
p9638
aS'    const Point<dim> bottom_left = Point<dim>();'
p9639
aS'    const Point<dim> upper_right ='
p9640
aS'                             assemblies_y * rods_per_assembly_y * pin_pitch_y) :'
p9641
aS'                  Point<dim>(assemblies_x * rods_per_assembly_x * pin_pitch_x,'
p9642
aS'                             assemblies_y * rods_per_assembly_y * pin_pitch_y,'
p9643
aS'                             assemblies_z * assembly_height));'
p9644
aS'    std::vector<unsigned int> n_subdivisions;'
p9645
aS'    n_subdivisions.push_back(assemblies_x * rods_per_assembly_x);'
p9646
aS'    if (dim >= 2)'
p9647
aS'      n_subdivisions.push_back(assemblies_y * rods_per_assembly_y);'
p9648
aS'    if (dim >= 3)'
p9649
aS'      n_subdivisions.push_back(assemblies_z);'
p9650
aS'    Triangulation<dim> coarse_grid;'
p9651
aS'    GridGenerator::subdivided_hyper_rectangle('
p9652
aS'      coarse_grid, n_subdivisions, bottom_left, upper_right, true);'
p9653
aS'    const unsigned int n_assemblies = 4;'
p9654
aS'    const unsigned int assembly_materials'
p9655
aS'      [n_assemblies][rods_per_assembly_x][rods_per_assembly_y] = {'
p9656
aS'        {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9657
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9658
aS'         {1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1},'
p9659
aS'         {1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1},'
p9660
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9661
aS'         {1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1},'
p9662
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9663
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9664
aS'         {1, 1, 5, 1, 1, 5, 1, 1, 7, 1, 1, 5, 1, 1, 5, 1, 1},'
p9665
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9666
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9667
aS'         {1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1},'
p9668
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9669
aS'         {1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1},'
p9670
aS'         {1, 1, 1, 1, 1, 5, 1, 1, 5, 1, 1, 5, 1, 1, 1, 1, 1},'
p9671
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9672
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},'
p9673
aS'        {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9674
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9675
aS'         {1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1},'
p9676
aS'         {1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1},'
p9677
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9678
aS'         {1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1},'
p9679
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9680
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9681
aS'         {1, 1, 8, 1, 1, 8, 1, 1, 7, 1, 1, 8, 1, 1, 8, 1, 1},'
p9682
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9683
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9684
aS'         {1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1},'
p9685
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9686
aS'         {1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1},'
p9687
aS'         {1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1},'
p9688
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},'
p9689
aS'         {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}},'
p9690
aS'        {{2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2},'
p9691
aS'         {2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2},'
p9692
aS'         {2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2},'
p9693
aS'         {2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2},'
p9694
aS'         {2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2},'
p9695
aS'         {2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2},'
p9696
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p9697
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p9698
aS'         {2, 3, 5, 4, 4, 5, 4, 4, 7, 4, 4, 5, 4, 4, 5, 3, 2},'
p9699
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p9700
aS'         {2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2},'
p9701
aS'         {2, 3, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 4, 4, 5, 3, 2},'
p9702
aS'         {2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 2},'
p9703
aS'         {2, 3, 3, 5, 3, 4, 4, 4, 4, 4, 4, 4, 3, 5, 3, 3, 2},'
p9704
aS'         {2, 3, 3, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 3, 3, 2},'
p9705
aS'         {2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2},'
p9706
aS'         {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}},'
p9707
aS'        {{6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9708
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9709
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9710
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9711
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9712
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9713
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9714
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9715
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9716
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9717
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9718
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9719
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9720
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9721
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9722
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},'
p9723
aS'         {6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}}};'
p9724
aS'    const unsigned int core[assemblies_x][assemblies_y][assemblies_z] = {'
p9725
aS'      {{0}, {2}}, {{2}, {0}}};'
p9726
aS'    for (auto &cell : coarse_grid.active_cell_iterators())'
p9727
aS'      {'
p9728
aS'        const Point<dim> cell_center = cell->center();'
p9729
aS'        const unsigned int tmp_x = int(cell_center[0] / pin_pitch_x);'
p9730
aS'        const unsigned int ax    = tmp_x / rods_per_assembly_x;'
p9731
aS'        const unsigned int cx    = tmp_x - ax * rods_per_assembly_x;'
p9732
aS'        const unsigned     tmp_y = int(cell_center[1] / pin_pitch_y);'
p9733
aS'        const unsigned int ay    = tmp_y / rods_per_assembly_y;'
p9734
aS'        const unsigned int cy    = tmp_y - ay * rods_per_assembly_y;'
p9735
aS'        const unsigned int az ='
p9736
aS'        Assert(ax < assemblies_x, ExcInternalError());'
p9737
aS'        Assert(ay < assemblies_y, ExcInternalError());'
p9738
aS'        Assert(az < assemblies_z, ExcInternalError());'
p9739
aS'        Assert(core[ax][ay][az] < n_assemblies, ExcInternalError());'
p9740
aS'        Assert(cx < rods_per_assembly_x, ExcInternalError());'
p9741
aS'        Assert(cy < rods_per_assembly_y, ExcInternalError());'
p9742
aS'        cell->set_material_id(assembly_materials[core[ax][ay][az]][cx][cy] - 1);'
p9743
aS'      }'
p9744
aS'    for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9745
aS'      energy_groups.emplace_back(std::make_unique<EnergyGroup<dim>>('
p9746
aS'        group, material_data, coarse_grid, fe));'
p9747
aS'    convergence_table_stream.open("convergence_table");'
p9748
aS'    convergence_table_stream.precision(12);'
p9749
aS'  }'
p9750
aS'  template <int dim>'
p9751
aS'  double NeutronDiffusionProblem<dim>::get_total_fission_source() const'
p9752
aS'  {'
p9753
aS'    std::vector<double>  fission_sources(parameters.n_groups);'
p9754
aS'    Threads::TaskGroup<> tasks;'
p9755
aS'    for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9756
aS'      tasks += Threads::new_task<>([&, group]() {'
p9757
aS'        fission_sources[group] = energy_groups[group]->get_fission_source();'
p9758
aS'      });'
p9759
aS'    tasks.join_all();'
p9760
aS'    return std::accumulate(fission_sources.begin(), fission_sources.end(), 0.0);'
p9761
aS'  }'
p9762
aS'  template <int dim>'
p9763
aS'  void NeutronDiffusionProblem<dim>::refine_grid()'
p9764
aS'  {'
p9765
aS'    std::vector<types::global_dof_index> n_cells(parameters.n_groups);'
p9766
aS'    for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9767
aS'      n_cells[group] = energy_groups[group]->n_active_cells();'
p9768
aS'    BlockVector<float> group_error_indicators(n_cells);'
p9769
aS'    {'
p9770
aS'      Threads::TaskGroup<> tasks;'
p9771
aS'      for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9772
aS'        tasks += Threads::new_task([&, group]() {'
p9773
aS'          energy_groups[group]->estimate_errors('
p9774
aS'            group_error_indicators.block(group));'
p9775
aS'        });'
p9776
aS'    }'
p9777
aS'    const float max_error         = group_error_indicators.linfty_norm();'
p9778
aS'    const float refine_threshold  = 0.3 * max_error;'
p9779
aS'    const float coarsen_threshold = 0.01 * max_error;'
p9780
aS'    {'
p9781
aS'      Threads::TaskGroup<void> tasks;'
p9782
aS'      for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9783
aS'        tasks += Threads::new_task([&, group]() {'
p9784
aS'          energy_groups[group]->refine_grid(group_error_indicators.block(group),'
p9785
aS'                                            refine_threshold,'
p9786
aS'                                            coarsen_threshold);'
p9787
aS'        });'
p9788
aS'    }'
p9789
aS'  }'
p9790
aS'  template <int dim>'
p9791
aS'  void NeutronDiffusionProblem<dim>::run()'
p9792
aS'  {'
p9793
aS'    boost::io::ios_flags_saver restore_flags(std::cout);'
p9794
aS'    std::cout << std::setprecision(12) << std::fixed;'
p9795
aS'    double k_eff_old = 0.0;'
p9796
aS'    for (unsigned int cycle = 0; cycle < parameters.n_refinement_cycles;'
p9797
aS'         ++cycle)'
p9798
aS'      {'
p9799
aS'        Timer timer;'
p9800
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p9801
aS'        if (cycle == 0)'
p9802
aS'          {'
p9803
aS'            initialize_problem();'
p9804
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9805
aS'              energy_groups[group]->setup_linear_system();'
p9806
aS'          }'
p9807
aS'        else'
p9808
aS'          {'
p9809
aS'            refine_grid();'
p9810
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9811
aS'              energy_groups[group]->solution *= k_eff;'
p9812
aS'          }'
p9813
aS'        std::cout << "   Numbers of active cells:       ";'
p9814
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9815
aS"          std::cout << energy_groups[group]->n_active_cells() << ' ';"
p9816
aS'        std::cout << std::endl;'
p9817
aS'        std::cout << "   Numbers of degrees of freedom: ";'
p9818
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9819
aS"          std::cout << energy_groups[group]->n_dofs() << ' ';"
p9820
aS'        std::cout << std::endl << std::endl;'
p9821
aS'        Threads::TaskGroup<> tasks;'
p9822
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9823
aS'          tasks += Threads::new_task('
p9824
aS'            [&, group]() { energy_groups[group]->assemble_system_matrix(); });'
p9825
aS'        tasks.join_all();'
p9826
aS'        double       error;'
p9827
aS'        unsigned int iteration = 1;'
p9828
aS'        do'
p9829
aS'          {'
p9830
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9831
aS'              {'
p9832
aS'                energy_groups[group]->assemble_ingroup_rhs('
p9833
aS'                  Functions::ZeroFunction<dim>());'
p9834
aS'                for (unsigned int bgroup = 0; bgroup < parameters.n_groups;'
p9835
aS'                     ++bgroup)'
p9836
aS'                  energy_groups[group]->assemble_cross_group_rhs('
p9837
aS'                energy_groups[group]->solve();'
p9838
aS'              }'
p9839
aS'            k_eff = get_total_fission_source();'
p9840
aS'            error = std::abs(k_eff - k_eff_old) / std::abs(k_eff);'
p9841
aS'            const double flux_ratio = energy_groups[0]->solution.linfty_norm() /'
p9842
aS'                                      energy_groups[1]->solution.linfty_norm();'
p9843
aS'            const double max_thermal = energy_groups[1]->solution.linfty_norm();'
p9844
aS'            std::cout << "Iter number:" << std::setw(2) << std::right'
p9845
aS'                      << iteration << " k_eff=" << k_eff'
p9846
aS'                      << " flux_ratio=" << flux_ratio'
p9847
aS'                      << " max_thermal=" << max_thermal << std::endl;'
p9848
aS'            k_eff_old = k_eff;'
p9849
aS'            for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9850
aS'              {'
p9851
aS'                energy_groups[group]->solution_old ='
p9852
aS'                  energy_groups[group]->solution;'
p9853
aS'                energy_groups[group]->solution_old /= k_eff;'
p9854
aS'              }'
p9855
aS'            ++iteration;'
p9856
aS'          }'
p9857
aS'        while ((error > parameters.convergence_tolerance) && (iteration < 500));'
p9858
aS'        convergence_table_stream << cycle << " " << energy_groups[0]->n_dofs()'
p9859
aS'                                 << " " << energy_groups[1]->n_dofs() << " "'
p9860
aS'                                 << k_eff << " "'
p9861
aS'                                 << energy_groups[0]->solution.linfty_norm() /'
p9862
aS'                                      energy_groups[1]->solution.linfty_norm()'
p9863
aS"                                 << '\\n';"
p9864
aS'        for (unsigned int group = 0; group < parameters.n_groups; ++group)'
p9865
aS'          energy_groups[group]->output_results(cycle);'
p9866
aS'        std::cout << std::endl;'
p9867
aS'        std::cout << "   Cycle=" << cycle << ", n_dofs="'
p9868
aS'                  << energy_groups[0]->n_dofs() + energy_groups[1]->n_dofs()'
p9869
aS'                  << ",  k_eff=" << k_eff << ", time=" << timer.cpu_time()'
p9870
aS'                  << std::endl;'
p9871
aS'        std::cout << std::endl << std::endl;'
p9872
aS'      }'
p9873
aS'  }'
p9874
aS'} // namespace Step28'
p9875
aS'int main(int argc, char **argv)'
p9876
ag9
aS'  try'
p9877
aS'    {'
p9878
aS'      using namespace dealii;'
p9879
aS'      using namespace Step28;'
p9880
aS'      std::string filename;'
p9881
aS'      if (argc < 2)'
p9882
aS'        filename = "project.prm";'
p9883
aS'      else'
p9884
aS'        filename = argv[1];'
p9885
aS'      const unsigned int dim = 2;'
p9886
aS'      ParameterHandler parameter_handler;'
p9887
aS'      NeutronDiffusionProblem<dim>::Parameters parameters;'
p9888
aS'      parameters.declare_parameters(parameter_handler);'
p9889
aS'      parameter_handler.parse_input(filename);'
p9890
aS'      parameters.get_parameters(parameter_handler);'
p9891
aS'      NeutronDiffusionProblem<dim> neutron_diffusion_problem(parameters);'
p9892
aS'      neutron_diffusion_problem.run();'
p9893
aS'    }'
p9894
aS'  catch (std::exception &exc)'
p9895
aS'    {'
p9896
aS'      std::cerr << std::endl'
p9897
aS'                << std::endl'
p9898
aS'                << "----------------------------------------------------"'
p9899
aS'                << std::endl;'
p9900
aS'      std::cerr << "Exception on processing: " << std::endl'
p9901
aS'                << exc.what() << std::endl'
p9902
aS'                << "Aborting!" << std::endl'
p9903
aS'                << "----------------------------------------------------"'
p9904
aS'                << std::endl;'
p9905
aS'      return 1;'
p9906
aS'    }'
p9907
aS'  catch (...)'
p9908
aS'    {'
p9909
aS'      std::cerr << std::endl'
p9910
aS'                << std::endl'
p9911
aS'                << "----------------------------------------------------"'
p9912
aS'                << std::endl;'
p9913
aS'      std::cerr << "Unknown exception!" << std::endl'
p9914
aS'                << "Aborting!" << std::endl'
p9915
aS'                << "----------------------------------------------------"'
p9916
aS'                << std::endl;'
p9917
aS'      return 1;'
p9918
aS'    }'
p9919
aS'  return 0;'
p9920
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p9921
aS'#include <deal.II/base/function.h>'
p9922
aS'#include <deal.II/base/logstream.h>'
p9923
aS'#include <deal.II/lac/vector.h>'
p9924
aS'#include <deal.II/lac/full_matrix.h>'
p9925
aS'#include <deal.II/lac/sparse_matrix.h>'
p9926
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p9927
aS'#include <deal.II/grid/tria.h>'
p9928
aS'#include <deal.II/grid/grid_generator.h>'
p9929
aS'#include <deal.II/grid/manifold_lib.h>'
p9930
aS'#include <deal.II/dofs/dof_handler.h>'
p9931
aS'#include <deal.II/dofs/dof_tools.h>'
p9932
aS'#include <deal.II/fe/fe_q.h>'
p9933
aS'#include <deal.II/fe/fe_values.h>'
p9934
aS'#include <deal.II/numerics/matrix_tools.h>'
p9935
aS'#include <deal.II/numerics/data_out.h>'
p9936
aS'#include <deal.II/numerics/vector_tools.h>'
p9937
aS'#include <iostream>'
p9938
aS'#include <fstream>'
p9939
aS'#include <deal.II/base/parameter_handler.h>'
p9940
aS'#include <deal.II/lac/sparse_direct.h>'
p9941
aS'#include <deal.II/fe/fe_system.h>'
p9942
aS'#include <deal.II/base/timer.h>'
p9943
aS'namespace Step29'
p9944
ag9
aS'  using namespace dealii;'
p9945
aS'  template <int dim>'
p9946
aS'  class DirichletBoundaryValues : public Function<dim>'
p9947
aS'  {'
p9948
aS'  public:'
p9949
aS'    DirichletBoundaryValues()'
p9950
aS'      : Function<dim>(2)'
p9951
aS'    {}'
p9952
aS'    virtual void vector_value(const Point<dim> & /*p*/,'
p9953
aS'                              Vector<double> &values) const override'
p9954
aS'    {'
p9955
aS'      Assert(values.size() == 2, ExcDimensionMismatch(values.size(), 2));'
p9956
aS'      values(0) = 1;'
p9957
aS'      values(1) = 0;'
p9958
aS'    }'
p9959
aS'    virtual void'
p9960
aS'    vector_value_list(const std::vector<Point<dim>> &points,'
p9961
aS'                      std::vector<Vector<double>> &  value_list) const override'
p9962
aS'    {'
p9963
aS'      Assert(value_list.size() == points.size(),'
p9964
aS'             ExcDimensionMismatch(value_list.size(), points.size()));'
p9965
aS'      for (unsigned int p = 0; p < points.size(); ++p)'
p9966
aS'        DirichletBoundaryValues<dim>::vector_value(points[p], value_list[p]);'
p9967
aS'    }'
p9968
aS'  };'
p9969
aS'  class ParameterReader : public Subscriptor'
p9970
aS'  {'
p9971
aS'  public:'
p9972
aS'    ParameterReader(ParameterHandler &);'
p9973
aS'    void read_parameters(const std::string &);'
p9974
aS'  private:'
p9975
aS'    void              declare_parameters();'
p9976
aS'    ParameterHandler &prm;'
p9977
aS'  };'
p9978
aS'  ParameterReader::ParameterReader(ParameterHandler &paramhandler)'
p9979
aS'    : prm(paramhandler)'
p9980
aS'  {}'
p9981
aS'  void ParameterReader::declare_parameters()'
p9982
aS'  {'
p9983
aS'    prm.enter_subsection("Mesh & geometry parameters");'
p9984
aS'    {'
p9985
aS'      prm.declare_entry("Number of refinements",'
p9986
aS'                        "6",'
p9987
aS'                        Patterns::Integer(0),'
p9988
aS'                        "Number of global mesh refinement steps "'
p9989
aS'                        "applied to initial coarse grid");'
p9990
aS'      prm.declare_entry("Focal distance",'
p9991
aS'                        "0.3",'
p9992
aS'                        Patterns::Double(0),'
p9993
aS'                        "Distance of the focal point of the lens "'
p9994
aS'                        "to the x-axis");'
p9995
aS'    }'
p9996
aS'    prm.leave_subsection();'
p9997
aS'    prm.enter_subsection("Physical constants");'
p9998
aS'    {'
p9999
aS'      prm.declare_entry("c", "1.5e5", Patterns::Double(0), "Wave speed");'
p10000
aS'      prm.declare_entry("omega", "5.0e7", Patterns::Double(0), "Frequency");'
p10001
aS'    }'
p10002
aS'    prm.leave_subsection();'
p10003
aS'    prm.enter_subsection("Output parameters");'
p10004
aS'    {'
p10005
aS'      prm.declare_entry("Output filename",'
p10006
aS'                        "solution",'
p10007
aS'                        Patterns::Anything(),'
p10008
aS'                        "Name of the output file (without extension)");'
p10009
aS'      DataOutInterface<1>::declare_parameters(prm);'
p10010
aS'    }'
p10011
aS'    prm.leave_subsection();'
p10012
aS'  }'
p10013
aS'  void ParameterReader::read_parameters(const std::string &parameter_file)'
p10014
aS'  {'
p10015
aS'    declare_parameters();'
p10016
aS'    prm.parse_input(parameter_file);'
p10017
aS'  }'
p10018
aS'  template <int dim>'
p10019
aS'  class ComputeIntensity : public DataPostprocessorScalar<dim>'
p10020
aS'  {'
p10021
aS'  public:'
p10022
aS'    ComputeIntensity();'
p10023
aS'    virtual void evaluate_vector_field('
p10024
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p10025
aS'      std::vector<Vector<double>> &computed_quantities) const override;'
p10026
aS'  };'
p10027
aS'  template <int dim>'
p10028
aS'  ComputeIntensity<dim>::ComputeIntensity()'
p10029
aS'    : DataPostprocessorScalar<dim>("Intensity", update_values)'
p10030
aS'  {}'
p10031
aS'  template <int dim>'
p10032
aS'  void ComputeIntensity<dim>::evaluate_vector_field('
p10033
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p10034
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p10035
aS'  {'
p10036
aS'    Assert(computed_quantities.size() == inputs.solution_values.size(),'
p10037
aS'           ExcDimensionMismatch(computed_quantities.size(),'
p10038
aS'                                inputs.solution_values.size()));'
p10039
aS'    for (unsigned int i = 0; i < computed_quantities.size(); i++)'
p10040
aS'      {'
p10041
aS'        Assert(computed_quantities[i].size() == 1,'
p10042
aS'               ExcDimensionMismatch(computed_quantities[i].size(), 1));'
p10043
aS'        Assert(inputs.solution_values[i].size() == 2,'
p10044
aS'               ExcDimensionMismatch(inputs.solution_values[i].size(), 2));'
p10045
aS'        const std::complex<double> u(inputs.solution_values[i](0),'
p10046
aS'                                     inputs.solution_values[i](1));'
p10047
aS'        computed_quantities[i](0) = std::abs(u);'
p10048
aS'      }'
p10049
aS'  }'
p10050
aS'  template <int dim>'
p10051
aS'  class UltrasoundProblem'
p10052
aS'  {'
p10053
aS'  public:'
p10054
aS'    UltrasoundProblem(ParameterHandler &);'
p10055
aS'    void run();'
p10056
aS'  private:'
p10057
aS'    void make_grid();'
p10058
aS'    void setup_system();'
p10059
aS'    void assemble_system();'
p10060
aS'    void solve();'
p10061
aS'    void output_results() const;'
p10062
aS'    ParameterHandler &prm;'
p10063
aS'    Triangulation<dim> triangulation;'
p10064
aS'    DoFHandler<dim>    dof_handler;'
p10065
aS'    FESystem<dim>      fe;'
p10066
aS'    SparsityPattern      sparsity_pattern;'
p10067
aS'    SparseMatrix<double> system_matrix;'
p10068
aS'    Vector<double>       solution, system_rhs;'
p10069
aS'  };'
p10070
aS'  template <int dim>'
p10071
aS'  UltrasoundProblem<dim>::UltrasoundProblem(ParameterHandler &param)'
p10072
aS'    : prm(param)'
p10073
aS'    , dof_handler(triangulation)'
p10074
aS'    , fe(FE_Q<dim>(1), 2)'
p10075
aS'  {}'
p10076
aS'  template <int dim>'
p10077
aS'  void UltrasoundProblem<dim>::make_grid()'
p10078
aS'  {'
p10079
aS'    std::cout << "Generating grid... ";'
p10080
aS'    Timer timer;'
p10081
aS'    prm.enter_subsection("Mesh & geometry parameters");'
p10082
aS'    const double       focal_distance = prm.get_double("Focal distance");'
p10083
aS'    const unsigned int n_refinements = prm.get_integer("Number of refinements");'
p10084
aS'    prm.leave_subsection();'
p10085
aS'    const Point<dim> transducer ='
p10086
aS'    const Point<dim> focal_point = (dim == 2) ?'
p10087
aS'                                     Point<dim>(0.5, focal_distance) :'
p10088
aS'                                     Point<dim>(0.5, 0.5, focal_distance);'
p10089
aS'    GridGenerator::subdivided_hyper_cube(triangulation, 5, 0, 1);'
p10090
aS'    for (auto &cell : triangulation.cell_iterators())'
p10091
aS'      for (const auto &face : cell->face_iterators())'
p10092
aS'        if (face->at_boundary() &&'
p10093
aS'          {'
p10094
aS'            face->set_boundary_id(1);'
p10095
aS'            face->set_manifold_id(1);'
p10096
aS'          }'
p10097
aS'    triangulation.set_manifold(1, SphericalManifold<dim>(focal_point));'
p10098
aS'    triangulation.refine_global(n_refinements);'
p10099
aS'    timer.stop();'
p10100
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10101
aS'    std::cout << "  Number of active cells:  " << triangulation.n_active_cells()'
p10102
aS'              << std::endl;'
p10103
aS'  }'
p10104
aS'  template <int dim>'
p10105
aS'  void UltrasoundProblem<dim>::setup_system()'
p10106
aS'  {'
p10107
aS'    std::cout << "Setting up system... ";'
p10108
aS'    Timer timer;'
p10109
aS'    dof_handler.distribute_dofs(fe);'
p10110
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p10111
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p10112
aS'    sparsity_pattern.copy_from(dsp);'
p10113
aS'    system_matrix.reinit(sparsity_pattern);'
p10114
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p10115
aS'    solution.reinit(dof_handler.n_dofs());'
p10116
aS'    timer.stop();'
p10117
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10118
aS'    std::cout << "  Number of degrees of freedom: " << dof_handler.n_dofs()'
p10119
aS'              << std::endl;'
p10120
aS'  }'
p10121
aS'  template <int dim>'
p10122
aS'  void UltrasoundProblem<dim>::assemble_system()'
p10123
aS'  {'
p10124
aS'    std::cout << "Assembling system matrix... ";'
p10125
aS'    Timer timer;'
p10126
aS'    prm.enter_subsection("Physical constants");'
p10127
aS'    const double omega = prm.get_double("omega"), c = prm.get_double("c");'
p10128
aS'    prm.leave_subsection();'
p10129
aS'    QGauss<dim>     quadrature_formula(fe.degree + 1);'
p10130
aS'    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p10131
aS'    const unsigned int n_q_points      = quadrature_formula.size(),'
p10132
aS'                       n_face_q_points = face_quadrature_formula.size(),'
p10133
aS'                       dofs_per_cell   = fe.n_dofs_per_cell();'
p10134
aS'    FEValues<dim> fe_values(fe,'
p10135
aS'                            quadrature_formula,'
p10136
aS'                            update_values | update_gradients |'
p10137
aS'                              update_JxW_values);'
p10138
aS'    FEFaceValues<dim> fe_face_values(fe,'
p10139
aS'                                     face_quadrature_formula,'
p10140
aS'                                     update_values | update_JxW_values);'
p10141
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p10142
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p10143
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p10144
aS'      {'
p10145
aS'        cell_matrix = 0;'
p10146
aS'        fe_values.reinit(cell);'
p10147
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10148
aS'          {'
p10149
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10150
aS'              {'
p10151
aS'                if (fe.system_to_component_index(i).first =='
p10152
aS'                    fe.system_to_component_index(j).first)'
p10153
aS'                  {'
p10154
aS'                    for (unsigned int q_point = 0; q_point < n_q_points;'
p10155
aS'                         ++q_point)'
p10156
aS'                      cell_matrix(i, j) +='
p10157
aS'                           fe_values.shape_value(j, q_point)) *'
p10158
aS'                           fe_values.shape_grad(j, q_point)) *'
p10159
aS'                            c * c) *'
p10160
aS'                         fe_values.JxW(q_point));'
p10161
aS'                  }'
p10162
aS'              }'
p10163
aS'          }'
p10164
aS'        for (const auto face_no : cell->face_indices())'
p10165
aS'          if (cell->face(face_no)->at_boundary() &&'
p10166
aS'            {'
p10167
aS'              fe_face_values.reinit(cell, face_no);'
p10168
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10169
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10170
aS'                  if ((fe.system_to_component_index(i).first !='
p10171
aS'                       fe.system_to_component_index(j).first) &&'
p10172
aS'                      fe.has_support_on_face(i, face_no) &&'
p10173
aS'                      fe.has_support_on_face(j, face_no))'
p10174
aS'                    for (unsigned int q_point = 0; q_point < n_face_q_points;'
p10175
aS'                         ++q_point)'
p10176
aS'                      cell_matrix(i, j) +='
p10177
aS'                                                                        1) *'
p10178
aS'                        fe_face_values.shape_value(i, q_point) *'
p10179
aS'                        fe_face_values.shape_value(j, q_point) * c * omega *'
p10180
aS'                        fe_face_values.JxW(q_point);'
p10181
aS'            }'
p10182
aS'        cell->get_dof_indices(local_dof_indices);'
p10183
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10184
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10185
aS'            system_matrix.add(local_dof_indices[i],'
p10186
aS'                              local_dof_indices[j],'
p10187
aS'                              cell_matrix(i, j));'
p10188
aS'      }'
p10189
aS'    std::map<types::global_dof_index, double> boundary_values;'
p10190
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p10191
aS'                                             1,'
p10192
aS'                                             DirichletBoundaryValues<dim>(),'
p10193
aS'                                             boundary_values);'
p10194
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p10195
aS'                                       system_matrix,'
p10196
aS'                                       solution,'
p10197
aS'                                       system_rhs);'
p10198
aS'    timer.stop();'
p10199
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10200
aS'  }'
p10201
aS'  template <int dim>'
p10202
aS'  void UltrasoundProblem<dim>::solve()'
p10203
aS'  {'
p10204
aS'    std::cout << "Solving linear system... ";'
p10205
aS'    Timer timer;'
p10206
aS'    SparseDirectUMFPACK A_direct;'
p10207
aS'    A_direct.initialize(system_matrix);'
p10208
aS'    A_direct.vmult(solution, system_rhs);'
p10209
aS'    timer.stop();'
p10210
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10211
aS'  }'
p10212
aS'  template <int dim>'
p10213
aS'  void UltrasoundProblem<dim>::output_results() const'
p10214
aS'  {'
p10215
aS'    std::cout << "Generating output... ";'
p10216
aS'    Timer timer;'
p10217
aS'    ComputeIntensity<dim> intensities;'
p10218
aS'    DataOut<dim>          data_out;'
p10219
aS'    data_out.attach_dof_handler(dof_handler);'
p10220
aS'    prm.enter_subsection("Output parameters");'
p10221
aS'    const std::string output_filename = prm.get("Output filename");'
p10222
aS'    data_out.parse_parameters(prm);'
p10223
aS'    prm.leave_subsection();'
p10224
aS'    const std::string filename = output_filename + data_out.default_suffix();'
p10225
aS'    std::ofstream output(filename);'
p10226
aS'    std::vector<std::string> solution_names;'
p10227
aS'    solution_names.emplace_back("Re_u");'
p10228
aS'    solution_names.emplace_back("Im_u");'
p10229
aS'    data_out.add_data_vector(solution, solution_names);'
p10230
aS'    data_out.add_data_vector(solution, intensities);'
p10231
aS'    data_out.build_patches();'
p10232
aS'    data_out.write(output);'
p10233
aS'    timer.stop();'
p10234
aS'    std::cout << "done (" << timer.cpu_time() << "s)" << std::endl;'
p10235
aS'  }'
p10236
aS'  template <int dim>'
p10237
aS'  void UltrasoundProblem<dim>::run()'
p10238
aS'  {'
p10239
aS'    make_grid();'
p10240
aS'    setup_system();'
p10241
aS'    assemble_system();'
p10242
aS'    solve();'
p10243
aS'    output_results();'
p10244
aS'  }'
p10245
aS'} // namespace Step29'
p10246
aS'int main()'
p10247
ag9
aS'  try'
p10248
aS'    {'
p10249
aS'      using namespace dealii;'
p10250
aS'      using namespace Step29;'
p10251
aS'      ParameterHandler prm;'
p10252
aS'      ParameterReader  param(prm);'
p10253
aS'      param.read_parameters("step-29.prm");'
p10254
aS'      UltrasoundProblem<2> ultrasound_problem(prm);'
p10255
aS'      ultrasound_problem.run();'
p10256
aS'    }'
p10257
aS'  catch (std::exception &exc)'
p10258
aS'    {'
p10259
aS'      std::cerr << std::endl'
p10260
aS'                << std::endl'
p10261
aS'                << "----------------------------------------------------"'
p10262
aS'                << std::endl;'
p10263
aS'      std::cerr << "Exception on processing: " << std::endl'
p10264
aS'                << exc.what() << std::endl'
p10265
aS'                << "Aborting!" << std::endl'
p10266
aS'                << "----------------------------------------------------"'
p10267
aS'                << std::endl;'
p10268
aS'      return 1;'
p10269
aS'    }'
p10270
aS'  catch (...)'
p10271
aS'    {'
p10272
aS'      std::cerr << std::endl'
p10273
aS'                << std::endl'
p10274
aS'                << "----------------------------------------------------"'
p10275
aS'                << std::endl;'
p10276
aS'      std::cerr << "Unknown exception!" << std::endl'
p10277
aS'                << "Aborting!" << std::endl'
p10278
aS'                << "----------------------------------------------------"'
p10279
aS'                << std::endl;'
p10280
aS'      return 1;'
p10281
aS'    }'
p10282
aS'  return 0;'
p10283
ag17
aS'#include <deal.II/grid/tria.h>'
p10284
aS'#include <deal.II/dofs/dof_handler.h>'
p10285
aS'#include <deal.II/grid/grid_generator.h>'
p10286
aS'#include <deal.II/fe/fe_q.h>'
p10287
aS'#include <deal.II/dofs/dof_tools.h>'
p10288
aS'#include <deal.II/fe/fe_values.h>'
p10289
aS'#include <deal.II/base/quadrature_lib.h>'
p10290
aS'#include <deal.II/base/function.h>'
p10291
aS'#include <deal.II/numerics/vector_tools.h>'
p10292
aS'#include <deal.II/numerics/matrix_tools.h>'
p10293
aS'#include <deal.II/lac/vector.h>'
p10294
aS'#include <deal.II/lac/full_matrix.h>'
p10295
aS'#include <deal.II/lac/sparse_matrix.h>'
p10296
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p10297
aS'#include <deal.II/lac/solver_cg.h>'
p10298
aS'#include <deal.II/lac/precondition.h>'
p10299
aS'#include <deal.II/numerics/data_out.h>'
p10300
aS'#include <fstream>'
p10301
aS'#include <iostream>'
p10302
aS'using namespace dealii;'
p10303
aS'class Step3'
p10304
ag9
aS'public:'
p10305
aS'  Step3();'
p10306
aS'  void run();'
p10307
aS'private:'
p10308
aS'  void make_grid();'
p10309
aS'  void setup_system();'
p10310
aS'  void assemble_system();'
p10311
aS'  void solve();'
p10312
aS'  void output_results() const;'
p10313
aS'  Triangulation<2> triangulation;'
p10314
aS'  FE_Q<2>          fe;'
p10315
aS'  DoFHandler<2>    dof_handler;'
p10316
aS'  SparsityPattern      sparsity_pattern;'
p10317
aS'  SparseMatrix<double> system_matrix;'
p10318
aS'  Vector<double> solution;'
p10319
aS'  Vector<double> system_rhs;'
p10320
aS'};'
p10321
aS'Step3::Step3()'
p10322
aS'  : fe(1)'
p10323
aS'  , dof_handler(triangulation)'
p10324
aS'{}'
p10325
aS'void Step3::make_grid()'
p10326
ag9
aS'  GridGenerator::hyper_cube(triangulation, -1, 1);'
p10327
aS'  triangulation.refine_global(5);'
p10328
aS'  std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p10329
aS'            << std::endl;'
p10330
ag17
aS'void Step3::setup_system()'
p10331
ag9
aS'  dof_handler.distribute_dofs(fe);'
p10332
aS'  std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p10333
aS'            << std::endl;'
p10334
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p10335
aS'  DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p10336
aS'  sparsity_pattern.copy_from(dsp);'
p10337
aS'  system_matrix.reinit(sparsity_pattern);'
p10338
aS'  solution.reinit(dof_handler.n_dofs());'
p10339
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p10340
ag17
aS'void Step3::assemble_system()'
p10341
ag9
aS'  QGauss<2> quadrature_formula(fe.degree + 1);'
p10342
aS'  FEValues<2> fe_values(fe,'
p10343
aS'                        quadrature_formula,'
p10344
aS'                        update_values | update_gradients | update_JxW_values);'
p10345
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p10346
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p10347
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p10348
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p10349
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p10350
aS'    {'
p10351
aS'      fe_values.reinit(cell);'
p10352
aS'      cell_matrix = 0;'
p10353
aS'      cell_rhs    = 0;'
p10354
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p10355
aS'        {'
p10356
aS'          for (const unsigned int i : fe_values.dof_indices())'
p10357
aS'            for (const unsigned int j : fe_values.dof_indices())'
p10358
aS'              cell_matrix(i, j) +='
p10359
aS'                 fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p10360
aS'                 fe_values.JxW(q_index));           // dx'
p10361
aS'          for (const unsigned int i : fe_values.dof_indices())'
p10362
aS'            cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p10363
aS'                            1. *                                // f(x_q)'
p10364
aS'                            fe_values.JxW(q_index));            // dx'
p10365
aS'        }'
p10366
aS'      cell->get_dof_indices(local_dof_indices);'
p10367
aS'      for (const unsigned int i : fe_values.dof_indices())'
p10368
aS'        for (const unsigned int j : fe_values.dof_indices())'
p10369
aS'          system_matrix.add(local_dof_indices[i],'
p10370
aS'                            local_dof_indices[j],'
p10371
aS'                            cell_matrix(i, j));'
p10372
aS'      for (const unsigned int i : fe_values.dof_indices())'
p10373
aS'        system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p10374
aS'    }'
p10375
aS'  std::map<types::global_dof_index, double> boundary_values;'
p10376
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p10377
aS'                                           0,'
p10378
aS'                                           Functions::ZeroFunction<2>(),'
p10379
aS'                                           boundary_values);'
p10380
aS'  MatrixTools::apply_boundary_values(boundary_values,'
p10381
aS'                                     system_matrix,'
p10382
aS'                                     solution,'
p10383
aS'                                     system_rhs);'
p10384
ag17
aS'void Step3::solve()'
p10385
ag9
aS'  SolverControl solver_control(1000, 1e-12);'
p10386
aS'  SolverCG<Vector<double>> solver(solver_control);'
p10387
aS'  solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p10388
ag17
aS'void Step3::output_results() const'
p10389
ag9
aS'  DataOut<2> data_out;'
p10390
aS'  data_out.attach_dof_handler(dof_handler);'
p10391
aS'  data_out.add_data_vector(solution, "solution");'
p10392
aS'  data_out.build_patches();'
p10393
aS'  std::ofstream output("solution.vtk");'
p10394
aS'  data_out.write_vtk(output);'
p10395
ag17
aS'void Step3::run()'
p10396
ag9
aS'  make_grid();'
p10397
aS'  setup_system();'
p10398
aS'  assemble_system();'
p10399
aS'  solve();'
p10400
aS'  output_results();'
p10401
ag17
aS'int main()'
p10402
ag9
aS'  deallog.depth_console(2);'
p10403
aS'  Step3 laplace_problem;'
p10404
aS'  laplace_problem.run();'
p10405
aS'  return 0;'
p10406
ag17
aS'#include <deal.II/base/function.h>'
p10407
aS'#include <deal.II/base/quadrature_lib.h>'
p10408
aS'#include <deal.II/base/timer.h>'
p10409
aS'#include <deal.II/lac/precondition_block.h>'
p10410
aS'#include <deal.II/lac/solver_richardson.h>'
p10411
aS'#include <deal.II/lac/sparse_matrix.h>'
p10412
aS'#include <deal.II/lac/vector.h>'
p10413
aS'#include <deal.II/grid/tria.h>'
p10414
aS'#include <deal.II/grid/grid_generator.h>'
p10415
aS'#include <deal.II/grid/grid_out.h>'
p10416
aS'#include <deal.II/grid/grid_refinement.h>'
p10417
aS'#include <deal.II/dofs/dof_handler.h>'
p10418
aS'#include <deal.II/dofs/dof_tools.h>'
p10419
aS'#include <deal.II/fe/fe_values.h>'
p10420
aS'#include <deal.II/fe/mapping_q1.h>'
p10421
aS'#include <deal.II/fe/fe_dgq.h>'
p10422
aS'#include <deal.II/numerics/data_out.h>'
p10423
aS'#include <deal.II/numerics/derivative_approximation.h>'
p10424
aS'#include <array>'
p10425
aS'#include <iostream>'
p10426
aS'#include <fstream>'
p10427
aS'namespace Step30'
p10428
ag9
aS'  using namespace dealii;'
p10429
aS'  template <int dim>'
p10430
aS'  class RHS : public Function<dim>'
p10431
aS'  {'
p10432
aS'  public:'
p10433
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p10434
aS'                            std::vector<double> &          values,'
p10435
aS'                            const unsigned int /*component*/ = 0) const override'
p10436
aS'    {'
p10437
aS'      Assert(values.size() == points.size(),'
p10438
aS'             ExcDimensionMismatch(values.size(), points.size()));'
p10439
aS'      std::fill(values.begin(), values.end(), 0.);'
p10440
aS'    }'
p10441
aS'  };'
p10442
aS'  template <int dim>'
p10443
aS'  class BoundaryValues : public Function<dim>'
p10444
aS'  {'
p10445
aS'  public:'
p10446
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p10447
aS'                            std::vector<double> &          values,'
p10448
aS'                            const unsigned int /*component*/ = 0) const override'
p10449
aS'    {'
p10450
aS'      Assert(values.size() == points.size(),'
p10451
aS'             ExcDimensionMismatch(values.size(), points.size()));'
p10452
aS'      for (unsigned int i = 0; i < values.size(); ++i)'
p10453
aS'        {'
p10454
aS'          if (points[i](0) < 0.5)'
p10455
aS'            values[i] = 1.;'
p10456
aS'          else'
p10457
aS'            values[i] = 0.;'
p10458
aS'        }'
p10459
aS'    }'
p10460
aS'  };'
p10461
aS'  template <int dim>'
p10462
aS'  class Beta'
p10463
aS'  {'
p10464
aS'  public:'
p10465
aS'    void value_list(const std::vector<Point<dim>> &points,'
p10466
aS'                    std::vector<Point<dim>> &      values) const'
p10467
aS'    {'
p10468
aS'      Assert(values.size() == points.size(),'
p10469
aS'             ExcDimensionMismatch(values.size(), points.size()));'
p10470
aS'      for (unsigned int i = 0; i < points.size(); ++i)'
p10471
aS'        {'
p10472
aS'          if (points[i](0) > 0)'
p10473
aS'            {'
p10474
aS'              values[i](0) = -points[i](1);'
p10475
aS'              values[i](1) = points[i](0);'
p10476
aS'            }'
p10477
aS'          else'
p10478
aS'            {'
p10479
aS'              values[i]    = Point<dim>();'
p10480
aS'              values[i](0) = -points[i](1);'
p10481
aS'            }'
p10482
aS'        }'
p10483
aS'    }'
p10484
aS'  };'
p10485
aS'  template <int dim>'
p10486
aS'  class DGTransportEquation'
p10487
aS'  {'
p10488
aS'  public:'
p10489
aS'    DGTransportEquation();'
p10490
aS'    void assemble_cell_term(const FEValues<dim> &fe_v,'
p10491
aS'                            FullMatrix<double> & ui_vi_matrix,'
p10492
aS'                            Vector<double> &     cell_vector) const;'
p10493
aS'    void assemble_boundary_term(const FEFaceValues<dim> &fe_v,'
p10494
aS'                                FullMatrix<double> &     ui_vi_matrix,'
p10495
aS'                                Vector<double> &         cell_vector) const;'
p10496
aS'    void assemble_face_term(const FEFaceValuesBase<dim> &fe_v,'
p10497
aS'                            const FEFaceValuesBase<dim> &fe_v_neighbor,'
p10498
aS'                            FullMatrix<double> &         ui_vi_matrix,'
p10499
aS'                            FullMatrix<double> &         ue_vi_matrix,'
p10500
aS'                            FullMatrix<double> &         ui_ve_matrix,'
p10501
aS'                            FullMatrix<double> &         ue_ve_matrix) const;'
p10502
aS'  private:'
p10503
aS'    const Beta<dim>           beta_function;'
p10504
aS'    const RHS<dim>            rhs_function;'
p10505
aS'    const BoundaryValues<dim> boundary_function;'
p10506
aS'  };'
p10507
aS'  template <int dim>'
p10508
aS'  DGTransportEquation<dim>::DGTransportEquation()'
p10509
aS'    : beta_function()'
p10510
aS'    , rhs_function()'
p10511
aS'    , boundary_function()'
p10512
aS'  {}'
p10513
aS'  template <int dim>'
p10514
aS'  void DGTransportEquation<dim>::assemble_cell_term('
p10515
aS'    const FEValues<dim> &fe_v,'
p10516
aS'    FullMatrix<double> & ui_vi_matrix,'
p10517
aS'    Vector<double> &     cell_vector) const'
p10518
aS'  {'
p10519
aS'    const std::vector<double> &JxW = fe_v.get_JxW_values();'
p10520
aS'    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);'
p10521
aS'    std::vector<double>     rhs(fe_v.n_quadrature_points);'
p10522
aS'    beta_function.value_list(fe_v.get_quadrature_points(), beta);'
p10523
aS'    rhs_function.value_list(fe_v.get_quadrature_points(), rhs);'
p10524
aS'    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p10525
aS'      for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p10526
aS'        {'
p10527
aS'          for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p10528
aS'            ui_vi_matrix(i, j) -= beta[point] * fe_v.shape_grad(i, point) *'
p10529
aS'                                  fe_v.shape_value(j, point) * JxW[point];'
p10530
aS'          cell_vector(i) +='
p10531
aS'            rhs[point] * fe_v.shape_value(i, point) * JxW[point];'
p10532
aS'        }'
p10533
aS'  }'
p10534
aS'  template <int dim>'
p10535
aS'  void DGTransportEquation<dim>::assemble_boundary_term('
p10536
aS'    const FEFaceValues<dim> &fe_v,'
p10537
aS'    FullMatrix<double> &     ui_vi_matrix,'
p10538
aS'    Vector<double> &         cell_vector) const'
p10539
aS'  {'
p10540
aS'    const std::vector<double> &        JxW     = fe_v.get_JxW_values();'
p10541
aS'    const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p10542
aS'    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);'
p10543
aS'    std::vector<double>     g(fe_v.n_quadrature_points);'
p10544
aS'    beta_function.value_list(fe_v.get_quadrature_points(), beta);'
p10545
aS'    boundary_function.value_list(fe_v.get_quadrature_points(), g);'
p10546
aS'    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p10547
aS'      {'
p10548
aS'        const double beta_n = beta[point] * normals[point];'
p10549
aS'        if (beta_n > 0)'
p10550
aS'          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p10551
aS'            for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p10552
aS'              ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *'
p10553
aS'                                    fe_v.shape_value(i, point) * JxW[point];'
p10554
aS'        else'
p10555
aS'          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p10556
aS'            cell_vector(i) -='
p10557
aS'              beta_n * g[point] * fe_v.shape_value(i, point) * JxW[point];'
p10558
aS'      }'
p10559
aS'  }'
p10560
aS'  template <int dim>'
p10561
aS'  void DGTransportEquation<dim>::assemble_face_term('
p10562
aS'    const FEFaceValuesBase<dim> &fe_v,'
p10563
aS'    const FEFaceValuesBase<dim> &fe_v_neighbor,'
p10564
aS'    FullMatrix<double> &         ui_vi_matrix,'
p10565
aS'    FullMatrix<double> &         ue_vi_matrix,'
p10566
aS'    FullMatrix<double> &         ui_ve_matrix,'
p10567
aS'    FullMatrix<double> &         ue_ve_matrix) const'
p10568
aS'  {'
p10569
aS'    const std::vector<double> &        JxW     = fe_v.get_JxW_values();'
p10570
aS'    const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p10571
aS'    std::vector<Point<dim>> beta(fe_v.n_quadrature_points);'
p10572
aS'    beta_function.value_list(fe_v.get_quadrature_points(), beta);'
p10573
aS'    for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p10574
aS'      {'
p10575
aS'        const double beta_n = beta[point] * normals[point];'
p10576
aS'        if (beta_n > 0)'
p10577
aS'          {'
p10578
aS'            for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p10579
aS'              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p10580
aS'                ui_vi_matrix(i, j) += beta_n * fe_v.shape_value(j, point) *'
p10581
aS'                                      fe_v.shape_value(i, point) * JxW[point];'
p10582
aS'            for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)'
p10583
aS'              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p10584
aS'                ui_ve_matrix(k, j) -= beta_n * fe_v.shape_value(j, point) *'
p10585
aS'                                      fe_v_neighbor.shape_value(k, point) *'
p10586
aS'                                      JxW[point];'
p10587
aS'          }'
p10588
aS'        else'
p10589
aS'          {'
p10590
aS'            for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p10591
aS'              for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)'
p10592
aS'                ue_vi_matrix(i, l) += beta_n *'
p10593
aS'                                      fe_v_neighbor.shape_value(l, point) *'
p10594
aS'                                      fe_v.shape_value(i, point) * JxW[point];'
p10595
aS'            for (unsigned int k = 0; k < fe_v_neighbor.dofs_per_cell; ++k)'
p10596
aS'              for (unsigned int l = 0; l < fe_v_neighbor.dofs_per_cell; ++l)'
p10597
aS'                ue_ve_matrix(k, l) -='
p10598
aS'                  beta_n * fe_v_neighbor.shape_value(l, point) *'
p10599
aS'                  fe_v_neighbor.shape_value(k, point) * JxW[point];'
p10600
aS'          }'
p10601
aS'      }'
p10602
aS'  }'
p10603
aS'  template <int dim>'
p10604
aS'  class DGMethod'
p10605
aS'  {'
p10606
aS'  public:'
p10607
aS'    DGMethod(const bool anisotropic);'
p10608
aS'    void run();'
p10609
aS'  private:'
p10610
aS'    void setup_system();'
p10611
aS'    void assemble_system();'
p10612
aS'    void solve(Vector<double> &solution);'
p10613
aS'    void refine_grid();'
p10614
aS'    void set_anisotropic_flags();'
p10615
aS'    void output_results(const unsigned int cycle) const;'
p10616
aS'    Triangulation<dim>   triangulation;'
p10617
aS'    const MappingQ1<dim> mapping;'
p10618
aS'    const unsigned int degree;'
p10619
aS'    FE_DGQ<dim>        fe;'
p10620
aS'    DoFHandler<dim>    dof_handler;'
p10621
aS'    SparsityPattern      sparsity_pattern;'
p10622
aS'    SparseMatrix<double> system_matrix;'
p10623
aS'    const double anisotropic_threshold_ratio;'
p10624
aS'    const bool anisotropic;'
p10625
aS'    const QGauss<dim>     quadrature;'
p10626
aS'    const QGauss<dim - 1> face_quadrature;'
p10627
aS'    Vector<double> solution2;'
p10628
aS'    Vector<double> right_hand_side;'
p10629
aS'    const DGTransportEquation<dim> dg;'
p10630
aS'  };'
p10631
aS'  template <int dim>'
p10632
aS'  DGMethod<dim>::DGMethod(const bool anisotropic)'
p10633
aS'    : mapping()'
p10634
aS'    ,'
p10635
aS'    degree(1)'
p10636
aS'    , fe(degree)'
p10637
aS'    , dof_handler(triangulation)'
p10638
aS'    , anisotropic_threshold_ratio(3.)'
p10639
aS'    , anisotropic(anisotropic)'
p10640
aS'    ,'
p10641
aS'    quadrature(degree + 1)'
p10642
aS'    , face_quadrature(degree + 1)'
p10643
aS'    , dg()'
p10644
aS'  {}'
p10645
aS'  template <int dim>'
p10646
aS'  void DGMethod<dim>::setup_system()'
p10647
aS'  {'
p10648
aS'    dof_handler.distribute_dofs(fe);'
p10649
aS'    sparsity_pattern.reinit(dof_handler.n_dofs(),'
p10650
aS'                            dof_handler.n_dofs(),'
p10651
aS'                               GeometryInfo<dim>::max_children_per_face +'
p10652
aS'                             1) *'
p10653
aS'                              fe.n_dofs_per_cell());'
p10654
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, sparsity_pattern);'
p10655
aS'    sparsity_pattern.compress();'
p10656
aS'    system_matrix.reinit(sparsity_pattern);'
p10657
aS'    solution2.reinit(dof_handler.n_dofs());'
p10658
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p10659
aS'  }'
p10660
aS'  template <int dim>'
p10661
aS'  void DGMethod<dim>::assemble_system()'
p10662
aS'  {'
p10663
aS'    const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();'
p10664
aS'    std::vector<types::global_dof_index> dofs(dofs_per_cell);'
p10665
aS'    std::vector<types::global_dof_index> dofs_neighbor(dofs_per_cell);'
p10666
aS'    const UpdateFlags update_flags = update_values | update_gradients |'
p10667
aS'                                     update_quadrature_points |'
p10668
aS'                                     update_JxW_values;'
p10669
aS'    const UpdateFlags face_update_flags ='
p10670
aS'      update_values | update_quadrature_points | update_JxW_values |'
p10671
aS'      update_normal_vectors;'
p10672
aS'    const UpdateFlags neighbor_face_update_flags = update_values;'
p10673
aS'    FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);'
p10674
aS'    FEFaceValues<dim>    fe_v_face(mapping,'
p10675
aS'                                fe,'
p10676
aS'                                face_quadrature,'
p10677
aS'                                face_update_flags);'
p10678
aS'    FESubfaceValues<dim> fe_v_subface(mapping,'
p10679
aS'                                      fe,'
p10680
aS'                                      face_quadrature,'
p10681
aS'                                      face_update_flags);'
p10682
aS'    FEFaceValues<dim>    fe_v_face_neighbor(mapping,'
p10683
aS'                                         fe,'
p10684
aS'                                         face_quadrature,'
p10685
aS'                                         neighbor_face_update_flags);'
p10686
aS'    FullMatrix<double> ui_vi_matrix(dofs_per_cell, dofs_per_cell);'
p10687
aS'    FullMatrix<double> ue_vi_matrix(dofs_per_cell, dofs_per_cell);'
p10688
aS'    FullMatrix<double> ui_ve_matrix(dofs_per_cell, dofs_per_cell);'
p10689
aS'    FullMatrix<double> ue_ve_matrix(dofs_per_cell, dofs_per_cell);'
p10690
aS'    Vector<double> cell_vector(dofs_per_cell);'
p10691
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p10692
aS'      {'
p10693
aS'        ui_vi_matrix = 0;'
p10694
aS'        cell_vector  = 0;'
p10695
aS'        fe_v.reinit(cell);'
p10696
aS'        dg.assemble_cell_term(fe_v, ui_vi_matrix, cell_vector);'
p10697
aS'        cell->get_dof_indices(dofs);'
p10698
aS'        for (const auto face_no : cell->face_indices())'
p10699
aS'          {'
p10700
aS'            const auto face = cell->face(face_no);'
p10701
aS'            if (face->at_boundary())'
p10702
aS'              {'
p10703
aS'                fe_v_face.reinit(cell, face_no);'
p10704
aS'                dg.assemble_boundary_term(fe_v_face, ui_vi_matrix, cell_vector);'
p10705
aS'              }'
p10706
aS'            else'
p10707
aS'              {'
p10708
aS'                Assert(cell->neighbor(face_no).state() == IteratorState::valid,'
p10709
aS'                       ExcInternalError());'
p10710
aS'                const auto neighbor = cell->neighbor(face_no);'
p10711
aS'                if (face->has_children())'
p10712
aS'                  {'
p10713
aS'                    const unsigned int neighbor2 ='
p10714
aS'                      cell->neighbor_face_no(face_no);'
p10715
aS'                    for (unsigned int subface_no = 0;'
p10716
aS'                         subface_no < face->n_active_descendants();'
p10717
aS'                         ++subface_no)'
p10718
aS'                      {'
p10719
aS'                        const auto neighbor_child ='
p10720
aS'                          cell->neighbor_child_on_subface(face_no, subface_no);'
p10721
aS'                        Assert(!neighbor_child->has_children(),'
p10722
aS'                               ExcInternalError());'
p10723
aS'                        ue_vi_matrix = 0;'
p10724
aS'                        ui_ve_matrix = 0;'
p10725
aS'                        ue_ve_matrix = 0;'
p10726
aS'                        fe_v_subface.reinit(cell, face_no, subface_no);'
p10727
aS'                        fe_v_face_neighbor.reinit(neighbor_child, neighbor2);'
p10728
aS'                        dg.assemble_face_term(fe_v_subface,'
p10729
aS'                                              fe_v_face_neighbor,'
p10730
aS'                                              ui_vi_matrix,'
p10731
aS'                                              ue_vi_matrix,'
p10732
aS'                                              ui_ve_matrix,'
p10733
aS'                                              ue_ve_matrix);'
p10734
aS'                        neighbor_child->get_dof_indices(dofs_neighbor);'
p10735
aS'                        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10736
aS'                          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10737
aS'                            {'
p10738
aS'                              system_matrix.add(dofs[i],'
p10739
aS'                                                dofs_neighbor[j],'
p10740
aS'                                                ue_vi_matrix(i, j));'
p10741
aS'                              system_matrix.add(dofs_neighbor[i],'
p10742
aS'                                                dofs[j],'
p10743
aS'                                                ui_ve_matrix(i, j));'
p10744
aS'                              system_matrix.add(dofs_neighbor[i],'
p10745
aS'                                                dofs_neighbor[j],'
p10746
aS'                                                ue_ve_matrix(i, j));'
p10747
aS'                            }'
p10748
aS'                      }'
p10749
aS'                  }'
p10750
aS'                else'
p10751
aS'                  {'
p10752
aS'                    if (dim > 1 && cell->neighbor_is_coarser(face_no))'
p10753
aS'                      continue;'
p10754
aS'                    if (((dim > 1) && (cell->index() < neighbor->index())) ||'
p10755
aS'                      {'
p10756
aS'                        const unsigned int neighbor2 ='
p10757
aS'                          cell->neighbor_of_neighbor(face_no);'
p10758
aS'                        ue_vi_matrix = 0;'
p10759
aS'                        ui_ve_matrix = 0;'
p10760
aS'                        ue_ve_matrix = 0;'
p10761
aS'                        fe_v_face.reinit(cell, face_no);'
p10762
aS'                        fe_v_face_neighbor.reinit(neighbor, neighbor2);'
p10763
aS'                        dg.assemble_face_term(fe_v_face,'
p10764
aS'                                              fe_v_face_neighbor,'
p10765
aS'                                              ui_vi_matrix,'
p10766
aS'                                              ue_vi_matrix,'
p10767
aS'                                              ui_ve_matrix,'
p10768
aS'                                              ue_ve_matrix);'
p10769
aS'                        neighbor->get_dof_indices(dofs_neighbor);'
p10770
aS'                        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10771
aS'                          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10772
aS'                            {'
p10773
aS'                              system_matrix.add(dofs[i],'
p10774
aS'                                                dofs_neighbor[j],'
p10775
aS'                                                ue_vi_matrix(i, j));'
p10776
aS'                              system_matrix.add(dofs_neighbor[i],'
p10777
aS'                                                dofs[j],'
p10778
aS'                                                ui_ve_matrix(i, j));'
p10779
aS'                              system_matrix.add(dofs_neighbor[i],'
p10780
aS'                                                dofs_neighbor[j],'
p10781
aS'                                                ue_ve_matrix(i, j));'
p10782
aS'                            }'
p10783
aS'                      }'
p10784
aS'                  }'
p10785
aS'              }'
p10786
aS'          }'
p10787
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10788
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p10789
aS'            system_matrix.add(dofs[i], dofs[j], ui_vi_matrix(i, j));'
p10790
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p10791
aS'          right_hand_side(dofs[i]) += cell_vector(i);'
p10792
aS'      }'
p10793
aS'  }'
p10794
aS'  template <int dim>'
p10795
aS'  void DGMethod<dim>::solve(Vector<double> &solution)'
p10796
aS'  {'
p10797
aS'    SolverControl                    solver_control(1000, 1e-12, false, false);'
p10798
aS'    SolverRichardson<Vector<double>> solver(solver_control);'
p10799
aS'    PreconditionBlockSSOR<SparseMatrix<double>> preconditioner;'
p10800
aS'    preconditioner.initialize(system_matrix, fe.n_dofs_per_cell());'
p10801
aS'    solver.solve(system_matrix, solution, right_hand_side, preconditioner);'
p10802
aS'  }'
p10803
aS'  template <int dim>'
p10804
aS'  void DGMethod<dim>::refine_grid()'
p10805
aS'  {'
p10806
aS'    Vector<float> gradient_indicator(triangulation.n_active_cells());'
p10807
aS'    DerivativeApproximation::approximate_gradient(mapping,'
p10808
aS'                                                  dof_handler,'
p10809
aS'                                                  solution2,'
p10810
aS'                                                  gradient_indicator);'
p10811
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p10812
aS'      gradient_indicator[cell->active_cell_index()] *='
p10813
aS'        std::pow(cell->diameter(), 1 + 1.0 * dim / 2);'
p10814
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p10815
aS'                                                    gradient_indicator,'
p10816
aS'                                                    0.3,'
p10817
aS'                                                    0.1);'
p10818
aS'    if (anisotropic)'
p10819
aS'      set_anisotropic_flags();'
p10820
aS'    triangulation.execute_coarsening_and_refinement();'
p10821
aS'  }'
p10822
aS'  template <int dim>'
p10823
aS'  void DGMethod<dim>::set_anisotropic_flags()'
p10824
aS'  {'
p10825
aS'    UpdateFlags face_update_flags ='
p10826
aS'      UpdateFlags(update_values | update_JxW_values);'
p10827
aS'    FEFaceValues<dim>    fe_v_face(mapping,'
p10828
aS'                                fe,'
p10829
aS'                                face_quadrature,'
p10830
aS'                                face_update_flags);'
p10831
aS'    FESubfaceValues<dim> fe_v_subface(mapping,'
p10832
aS'                                      fe,'
p10833
aS'                                      face_quadrature,'
p10834
aS'                                      face_update_flags);'
p10835
aS'    FEFaceValues<dim>    fe_v_face_neighbor(mapping,'
p10836
aS'                                         fe,'
p10837
aS'                                         face_quadrature,'
p10838
aS'                                         update_values);'
p10839
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p10840
aS'      if (cell->refine_flag_set())'
p10841
aS'        {'
p10842
aS'          Point<dim> jump;'
p10843
aS'          Point<dim> area;'
p10844
aS'          for (const auto face_no : cell->face_indices())'
p10845
aS'            {'
p10846
aS'              const auto face = cell->face(face_no);'
p10847
aS'              if (!face->at_boundary())'
p10848
aS'                {'
p10849
aS'                  Assert(cell->neighbor(face_no).state() =='
p10850
aS'                           IteratorState::valid,'
p10851
aS'                         ExcInternalError());'
p10852
aS'                  const auto neighbor = cell->neighbor(face_no);'
p10853
aS'                  std::vector<double> u(fe_v_face.n_quadrature_points);'
p10854
aS'                  std::vector<double> u_neighbor(fe_v_face.n_quadrature_points);'
p10855
aS'                  if (face->has_children())'
p10856
aS'                    {'
p10857
aS'                      unsigned int neighbor2 = cell->neighbor_face_no(face_no);'
p10858
aS'                      for (unsigned int subface_no = 0;'
p10859
aS'                           subface_no < face->n_active_descendants();'
p10860
aS'                           ++subface_no)'
p10861
aS'                        {'
p10862
aS'                          const auto neighbor_child ='
p10863
aS'                            cell->neighbor_child_on_subface(face_no,'
p10864
aS'                                                            subface_no);'
p10865
aS'                          Assert(!neighbor_child->has_children(),'
p10866
aS'                                 ExcInternalError());'
p10867
aS'                          fe_v_subface.reinit(cell, face_no, subface_no);'
p10868
aS'                          fe_v_face_neighbor.reinit(neighbor_child, neighbor2);'
p10869
aS'                          fe_v_subface.get_function_values(solution2, u);'
p10870
aS'                          fe_v_face_neighbor.get_function_values(solution2,'
p10871
aS'                                                                 u_neighbor);'
p10872
aS'                          const std::vector<double> &JxW ='
p10873
aS'                            fe_v_subface.get_JxW_values();'
p10874
aS'                          for (unsigned int x = 0;'
p10875
aS'                               x < fe_v_subface.n_quadrature_points;'
p10876
aS'                               ++x)'
p10877
aS'                            {'
p10878
aS'                              jump[face_no / 2] +='
p10879
aS'                                std::abs(u[x] - u_neighbor[x]) * JxW[x];'
p10880
aS'                              area[face_no / 2] += JxW[x];'
p10881
aS'                            }'
p10882
aS'                        }'
p10883
aS'                    }'
p10884
aS'                  else'
p10885
aS'                    {'
p10886
aS'                      if (!cell->neighbor_is_coarser(face_no))'
p10887
aS'                        {'
p10888
aS'                          unsigned int neighbor2 ='
p10889
aS'                            cell->neighbor_of_neighbor(face_no);'
p10890
aS'                          fe_v_face.reinit(cell, face_no);'
p10891
aS'                          fe_v_face_neighbor.reinit(neighbor, neighbor2);'
p10892
aS'                          fe_v_face.get_function_values(solution2, u);'
p10893
aS'                          fe_v_face_neighbor.get_function_values(solution2,'
p10894
aS'                                                                 u_neighbor);'
p10895
aS'                          const std::vector<double> &JxW ='
p10896
aS'                            fe_v_face.get_JxW_values();'
p10897
aS'                          for (unsigned int x = 0;'
p10898
aS'                               x < fe_v_face.n_quadrature_points;'
p10899
aS'                               ++x)'
p10900
aS'                            {'
p10901
aS'                              jump[face_no / 2] +='
p10902
aS'                                std::abs(u[x] - u_neighbor[x]) * JxW[x];'
p10903
aS'                              area[face_no / 2] += JxW[x];'
p10904
aS'                            }'
p10905
aS'                        }'
p10906
aS'                      else // i.e. neighbor is coarser than cell'
p10907
aS'                        {'
p10908
aS'                          std::pair<unsigned int, unsigned int>'
p10909
aS'                            neighbor_face_subface ='
p10910
aS'                              cell->neighbor_of_coarser_neighbor(face_no);'
p10911
aS'                          Assert(neighbor_face_subface.first < cell->n_faces(),'
p10912
aS'                                 ExcInternalError());'
p10913
aS'                          Assert(neighbor_face_subface.second <'
p10914
aS'                                   neighbor->face(neighbor_face_subface.first)'
p10915
aS'                                     ->n_active_descendants(),'
p10916
aS'                                 ExcInternalError());'
p10917
aS'                          Assert(neighbor->neighbor_child_on_subface('
p10918
aS'                                   neighbor_face_subface.first,'
p10919
aS'                                   neighbor_face_subface.second) == cell,'
p10920
aS'                                 ExcInternalError());'
p10921
aS'                          fe_v_face.reinit(cell, face_no);'
p10922
aS'                          fe_v_subface.reinit(neighbor,'
p10923
aS'                                              neighbor_face_subface.first,'
p10924
aS'                                              neighbor_face_subface.second);'
p10925
aS'                          fe_v_face.get_function_values(solution2, u);'
p10926
aS'                          fe_v_subface.get_function_values(solution2,'
p10927
aS'                                                           u_neighbor);'
p10928
aS'                          const std::vector<double> &JxW ='
p10929
aS'                            fe_v_face.get_JxW_values();'
p10930
aS'                          for (unsigned int x = 0;'
p10931
aS'                               x < fe_v_face.n_quadrature_points;'
p10932
aS'                               ++x)'
p10933
aS'                            {'
p10934
aS'                              jump[face_no / 2] +='
p10935
aS'                                std::abs(u[x] - u_neighbor[x]) * JxW[x];'
p10936
aS'                              area[face_no / 2] += JxW[x];'
p10937
aS'                            }'
p10938
aS'                        }'
p10939
aS'                    }'
p10940
aS'                }'
p10941
aS'            }'
p10942
aS'          std::array<double, dim> average_jumps;'
p10943
aS'          double                  sum_of_average_jumps = 0.;'
p10944
aS'          for (unsigned int i = 0; i < dim; ++i)'
p10945
aS'            {'
p10946
aS'              average_jumps[i] = jump(i) / area(i);'
p10947
aS'              sum_of_average_jumps += average_jumps[i];'
p10948
aS'            }'
p10949
aS'          for (unsigned int i = 0; i < dim; ++i)'
p10950
aS'            if (average_jumps[i] > anisotropic_threshold_ratio *'
p10951
aS'              cell->set_refine_flag(RefinementCase<dim>::cut_axis(i));'
p10952
aS'        }'
p10953
aS'  }'
p10954
aS'  template <int dim>'
p10955
aS'  void DGMethod<dim>::output_results(const unsigned int cycle) const'
p10956
aS'  {'
p10957
aS'    std::string refine_type;'
p10958
aS'    if (anisotropic)'
p10959
aS'      refine_type = ".aniso";'
p10960
aS'    else'
p10961
aS'      refine_type = ".iso";'
p10962
aS'    {'
p10963
aS'      const std::string filename ='
p10964
aS'        "grid-" + std::to_string(cycle) + refine_type + ".svg";'
p10965
aS'      std::cout << "   Writing grid to <" << filename << ">..." << std::endl;'
p10966
aS'      std::ofstream svg_output(filename);'
p10967
aS'      GridOut grid_out;'
p10968
aS'      grid_out.write_svg(triangulation, svg_output);'
p10969
aS'    }'
p10970
aS'    {'
p10971
aS'      const std::string filename ='
p10972
aS'        "sol-" + std::to_string(cycle) + refine_type + ".vtu";'
p10973
aS'      std::cout << "   Writing solution to <" << filename << ">..."'
p10974
aS'                << std::endl;'
p10975
aS'      std::ofstream gnuplot_output(filename);'
p10976
aS'      DataOut<dim> data_out;'
p10977
aS'      data_out.attach_dof_handler(dof_handler);'
p10978
aS'      data_out.add_data_vector(solution2, "u");'
p10979
aS'      data_out.build_patches(degree);'
p10980
aS'      data_out.write_vtu(gnuplot_output);'
p10981
aS'    }'
p10982
aS'  }'
p10983
aS'  template <int dim>'
p10984
aS'  void DGMethod<dim>::run()'
p10985
aS'  {'
p10986
aS'    for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p10987
aS'      {'
p10988
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p10989
aS'        if (cycle == 0)'
p10990
aS'          {'
p10991
aS'            Point<dim> p1, p2;'
p10992
aS'            p1(0) = 0;'
p10993
aS'            p1(0) = -1;'
p10994
aS'            for (unsigned int i = 0; i < dim; ++i)'
p10995
aS'              p2(i) = 1.;'
p10996
aS'            std::vector<unsigned int> repetitions(dim, 1);'
p10997
aS'            repetitions[0] = 2;'
p10998
aS'            GridGenerator::subdivided_hyper_rectangle(triangulation,'
p10999
aS'                                                      repetitions,'
p11000
aS'                                                      p1,'
p11001
aS'                                                      p2);'
p11002
aS'            triangulation.refine_global(5 - dim);'
p11003
aS'          }'
p11004
aS'        else'
p11005
aS'          refine_grid();'
p11006
aS'        std::cout << "   Number of active cells:       "'
p11007
aS'                  << triangulation.n_active_cells() << std::endl;'
p11008
aS'        setup_system();'
p11009
aS'        std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p11010
aS'                  << std::endl;'
p11011
aS'        Timer assemble_timer;'
p11012
aS'        assemble_system();'
p11013
aS'        std::cout << "   Time of assemble_system: " << assemble_timer.cpu_time()'
p11014
aS'                  << std::endl;'
p11015
aS'        solve(solution2);'
p11016
aS'        output_results(cycle);'
p11017
aS'        std::cout << std::endl;'
p11018
aS'      }'
p11019
aS'  }'
p11020
aS'} // namespace Step30'
p11021
aS'int main()'
p11022
ag9
aS'  try'
p11023
aS'    {'
p11024
aS'      using namespace Step30;'
p11025
aS'      const unsigned int dim = 2;'
p11026
aS'      {'
p11027
aS'        std::cout << "Performing a " << dim'
p11028
aS'                  << "D run with isotropic refinement..." << std::endl'
p11029
aS'                  << "------------------------------------------------"'
p11030
aS'                  << std::endl;'
p11031
aS'        DGMethod<dim> dgmethod_iso(false);'
p11032
aS'        dgmethod_iso.run();'
p11033
aS'      }'
p11034
aS'      {'
p11035
aS'        std::cout << std::endl'
p11036
aS'                  << "Performing a " << dim'
p11037
aS'                  << "D run with anisotropic refinement..." << std::endl'
p11038
aS'                  << "--------------------------------------------------"'
p11039
aS'                  << std::endl;'
p11040
aS'        DGMethod<dim> dgmethod_aniso(true);'
p11041
aS'        dgmethod_aniso.run();'
p11042
aS'      }'
p11043
aS'    }'
p11044
aS'  catch (std::exception &exc)'
p11045
aS'    {'
p11046
aS'      std::cerr << std::endl'
p11047
aS'                << std::endl'
p11048
aS'                << "----------------------------------------------------"'
p11049
aS'                << std::endl;'
p11050
aS'      std::cerr << "Exception on processing: " << std::endl'
p11051
aS'                << exc.what() << std::endl'
p11052
aS'                << "Aborting!" << std::endl'
p11053
aS'                << "----------------------------------------------------"'
p11054
aS'                << std::endl;'
p11055
aS'      return 1;'
p11056
aS'    }'
p11057
aS'  catch (...)'
p11058
aS'    {'
p11059
aS'      std::cerr << std::endl'
p11060
aS'                << std::endl'
p11061
aS'                << "----------------------------------------------------"'
p11062
aS'                << std::endl;'
p11063
aS'      std::cerr << "Unknown exception!" << std::endl'
p11064
aS'                << "Aborting!" << std::endl'
p11065
aS'                << "----------------------------------------------------"'
p11066
aS'                << std::endl;'
p11067
aS'      return 1;'
p11068
aS'    };'
p11069
aS'  return 0;'
p11070
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p11071
aS'#include <deal.II/base/logstream.h>'
p11072
aS'#include <deal.II/base/utilities.h>'
p11073
aS'#include <deal.II/lac/full_matrix.h>'
p11074
aS'#include <deal.II/lac/solver_gmres.h>'
p11075
aS'#include <deal.II/lac/solver_cg.h>'
p11076
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p11077
aS'#include <deal.II/lac/affine_constraints.h>'
p11078
aS'#include <deal.II/grid/tria.h>'
p11079
aS'#include <deal.II/grid/grid_generator.h>'
p11080
aS'#include <deal.II/grid/grid_tools.h>'
p11081
aS'#include <deal.II/grid/grid_refinement.h>'
p11082
aS'#include <deal.II/dofs/dof_handler.h>'
p11083
aS'#include <deal.II/dofs/dof_renumbering.h>'
p11084
aS'#include <deal.II/dofs/dof_tools.h>'
p11085
aS'#include <deal.II/fe/fe_q.h>'
p11086
aS'#include <deal.II/fe/fe_system.h>'
p11087
aS'#include <deal.II/fe/fe_values.h>'
p11088
aS'#include <deal.II/numerics/vector_tools.h>'
p11089
aS'#include <deal.II/numerics/data_out.h>'
p11090
aS'#include <deal.II/numerics/error_estimator.h>'
p11091
aS'#include <deal.II/numerics/solution_transfer.h>'
p11092
aS'#include <deal.II/base/index_set.h>'
p11093
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p11094
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p11095
aS'#include <deal.II/lac/trilinos_vector.h>'
p11096
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p11097
aS'#include <deal.II/lac/trilinos_precondition.h>'
p11098
aS'#include <iostream>'
p11099
aS'#include <fstream>'
p11100
aS'#include <memory>'
p11101
aS'#include <limits>'
p11102
aS'namespace Step31'
p11103
ag9
aS'  using namespace dealii;'
p11104
aS'  namespace EquationData'
p11105
aS'  {'
p11106
aS'    constexpr double eta     = 1;'
p11107
aS'    constexpr double kappa   = 1e-6;'
p11108
aS'    constexpr double beta    = 10;'
p11109
aS'    constexpr double density = 1;'
p11110
aS'    template <int dim>'
p11111
aS'    class TemperatureInitialValues : public Function<dim>'
p11112
aS'    {'
p11113
aS'    public:'
p11114
aS'      TemperatureInitialValues()'
p11115
aS'        : Function<dim>(1)'
p11116
aS'      {}'
p11117
aS'      virtual double value(const Point<dim> & /*p*/,'
p11118
aS'                           const unsigned int /*component*/ = 0) const override'
p11119
aS'      {'
p11120
aS'        return 0;'
p11121
aS'      }'
p11122
aS'      virtual void vector_value(const Point<dim> &p,'
p11123
aS'                                Vector<double> &  value) const override'
p11124
aS'      {'
p11125
aS'        for (unsigned int c = 0; c < this->n_components; ++c)'
p11126
aS'          value(c) = TemperatureInitialValues<dim>::value(p, c);'
p11127
aS'      }'
p11128
aS'    };'
p11129
aS'    template <int dim>'
p11130
aS'    class TemperatureRightHandSide : public Function<dim>'
p11131
aS'    {'
p11132
aS'    public:'
p11133
aS'      TemperatureRightHandSide()'
p11134
aS'        : Function<dim>(1)'
p11135
aS'      {}'
p11136
aS'      virtual double value(const Point<dim> & p,'
p11137
aS'                           const unsigned int component = 0) const override'
p11138
aS'      {'
p11139
aS'        Assert(component == 0,'
p11140
aS'               ExcMessage("Invalid operation for a scalar function."));'
p11141
aS'        Assert((dim == 2) || (dim == 3), ExcNotImplemented());'
p11142
aS'        static const Point<dim> source_centers[3] = {'
p11143
aS'        static const double source_radius = (dim == 2 ? 1. / 32 : 1. / 8);'
p11144
aS'        return ((source_centers[0].distance(p) < source_radius) ||'
p11145
aS'                  1 :'
p11146
aS'                  0);'
p11147
aS'      }'
p11148
aS'      virtual void vector_value(const Point<dim> &p,'
p11149
aS'                                Vector<double> &  value) const override'
p11150
aS'      {'
p11151
aS'        for (unsigned int c = 0; c < this->n_components; ++c)'
p11152
aS'          value(c) = TemperatureRightHandSide<dim>::value(p, c);'
p11153
aS'      }'
p11154
aS'    };'
p11155
aS'  } // namespace EquationData'
p11156
aS'  namespace LinearSolvers'
p11157
aS'  {'
p11158
aS'    template <class MatrixType, class PreconditionerType>'
p11159
aS'    class InverseMatrix : public Subscriptor'
p11160
aS'    {'
p11161
aS'    public:'
p11162
aS'      InverseMatrix(const MatrixType &        m,'
p11163
aS'                    const PreconditionerType &preconditioner);'
p11164
aS'      template <typename VectorType>'
p11165
aS'      void vmult(VectorType &dst, const VectorType &src) const;'
p11166
aS'    private:'
p11167
aS'      const SmartPointer<const MatrixType> matrix;'
p11168
aS'      const PreconditionerType &           preconditioner;'
p11169
aS'    };'
p11170
aS'    template <class MatrixType, class PreconditionerType>'
p11171
aS'    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p11172
aS'      const MatrixType &        m,'
p11173
aS'      const PreconditionerType &preconditioner)'
p11174
aS'      : matrix(&m)'
p11175
aS'      , preconditioner(preconditioner)'
p11176
aS'    {}'
p11177
aS'    template <class MatrixType, class PreconditionerType>'
p11178
aS'    template <typename VectorType>'
p11179
aS'    void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p11180
aS'      VectorType &      dst,'
p11181
aS'      const VectorType &src) const'
p11182
aS'    {'
p11183
aS'      SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm());'
p11184
aS'      SolverCG<VectorType> cg(solver_control);'
p11185
aS'      dst = 0;'
p11186
aS'      try'
p11187
aS'        {'
p11188
aS'          cg.solve(*matrix, dst, src, preconditioner);'
p11189
aS'        }'
p11190
aS'      catch (std::exception &e)'
p11191
aS'        {'
p11192
aS'          Assert(false, ExcMessage(e.what()));'
p11193
aS'        }'
p11194
aS'    }'
p11195
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p11196
aS'    class BlockSchurPreconditioner : public Subscriptor'
p11197
aS'    {'
p11198
aS'    public:'
p11199
aS'      BlockSchurPreconditioner('
p11200
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p11201
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11202
aS'                            PreconditionerTypeMp> &Mpinv,'
p11203
aS'        const PreconditionerTypeA &                Apreconditioner);'
p11204
aS'      void vmult(TrilinosWrappers::MPI::BlockVector &      dst,'
p11205
aS'                 const TrilinosWrappers::MPI::BlockVector &src) const;'
p11206
aS'    private:'
p11207
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p11208
aS'        stokes_matrix;'
p11209
aS'      const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11210
aS'                                             PreconditionerTypeMp>>'
p11211
aS'                                 m_inverse;'
p11212
aS'      const PreconditionerTypeA &a_preconditioner;'
p11213
aS'      mutable TrilinosWrappers::MPI::Vector tmp;'
p11214
aS'    };'
p11215
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p11216
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::'
p11217
aS'      BlockSchurPreconditioner('
p11218
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p11219
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11220
aS'                            PreconditionerTypeMp> &Mpinv,'
p11221
aS'        const PreconditionerTypeA &                Apreconditioner)'
p11222
aS'      : stokes_matrix(&S)'
p11223
aS'      , m_inverse(&Mpinv)'
p11224
aS'      , a_preconditioner(Apreconditioner)'
p11225
aS'      , tmp(complete_index_set(stokes_matrix->block(1, 1).m()))'
p11226
aS'    {}'
p11227
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p11228
aS'    void'
p11229
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult('
p11230
aS'      TrilinosWrappers::MPI::BlockVector &      dst,'
p11231
aS'      const TrilinosWrappers::MPI::BlockVector &src) const'
p11232
aS'    {'
p11233
aS'      a_preconditioner.vmult(dst.block(0), src.block(0));'
p11234
aS'      stokes_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1));'
p11235
aS'      tmp *= -1;'
p11236
aS'      m_inverse->vmult(dst.block(1), tmp);'
p11237
aS'    }'
p11238
aS'  } // namespace LinearSolvers'
p11239
aS'  template <int dim>'
p11240
aS'  class BoussinesqFlowProblem'
p11241
aS'  {'
p11242
aS'  public:'
p11243
aS'    BoussinesqFlowProblem();'
p11244
aS'    void run();'
p11245
aS'  private:'
p11246
aS'    void   setup_dofs();'
p11247
aS'    void   assemble_stokes_preconditioner();'
p11248
aS'    void   build_stokes_preconditioner();'
p11249
aS'    void   assemble_stokes_system();'
p11250
aS'    void   assemble_temperature_system(const double maximal_velocity);'
p11251
aS'    void   assemble_temperature_matrix();'
p11252
aS'    double get_maximal_velocity() const;'
p11253
aS'    std::pair<double, double> get_extrapolated_temperature_range() const;'
p11254
aS'    void                      solve();'
p11255
aS'    void                      output_results() const;'
p11256
aS'    void                      refine_mesh(const unsigned int max_grid_level);'
p11257
aS'    double compute_viscosity('
p11258
aS'      const std::vector<double> &        old_temperature,'
p11259
aS'      const std::vector<double> &        old_old_temperature,'
p11260
aS'      const std::vector<Tensor<1, dim>> &old_temperature_grads,'
p11261
aS'      const std::vector<Tensor<1, dim>> &old_old_temperature_grads,'
p11262
aS'      const std::vector<double> &        old_temperature_laplacians,'
p11263
aS'      const std::vector<double> &        old_old_temperature_laplacians,'
p11264
aS'      const std::vector<Tensor<1, dim>> &old_velocity_values,'
p11265
aS'      const std::vector<Tensor<1, dim>> &old_old_velocity_values,'
p11266
aS'      const std::vector<double> &        gamma_values,'
p11267
aS'      const double                       global_u_infty,'
p11268
aS'      const double                       global_T_variation,'
p11269
aS'      const double                       cell_diameter) const;'
p11270
aS'    Triangulation<dim> triangulation;'
p11271
aS'    double             global_Omega_diameter;'
p11272
aS'    const unsigned int        stokes_degree;'
p11273
aS'    FESystem<dim>             stokes_fe;'
p11274
aS'    DoFHandler<dim>           stokes_dof_handler;'
p11275
aS'    AffineConstraints<double> stokes_constraints;'
p11276
aS'    std::vector<IndexSet>               stokes_partitioning;'
p11277
aS'    TrilinosWrappers::BlockSparseMatrix stokes_matrix;'
p11278
aS'    TrilinosWrappers::BlockSparseMatrix stokes_preconditioner_matrix;'
p11279
aS'    TrilinosWrappers::MPI::BlockVector stokes_solution;'
p11280
aS'    TrilinosWrappers::MPI::BlockVector old_stokes_solution;'
p11281
aS'    TrilinosWrappers::MPI::BlockVector stokes_rhs;'
p11282
aS'    const unsigned int        temperature_degree;'
p11283
aS'    FE_Q<dim>                 temperature_fe;'
p11284
aS'    DoFHandler<dim>           temperature_dof_handler;'
p11285
aS'    AffineConstraints<double> temperature_constraints;'
p11286
aS'    TrilinosWrappers::SparseMatrix temperature_mass_matrix;'
p11287
aS'    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;'
p11288
aS'    TrilinosWrappers::SparseMatrix temperature_matrix;'
p11289
aS'    TrilinosWrappers::MPI::Vector temperature_solution;'
p11290
aS'    TrilinosWrappers::MPI::Vector old_temperature_solution;'
p11291
aS'    TrilinosWrappers::MPI::Vector old_old_temperature_solution;'
p11292
aS'    TrilinosWrappers::MPI::Vector temperature_rhs;'
p11293
aS'    double       time_step;'
p11294
aS'    double       old_time_step;'
p11295
aS'    unsigned int timestep_number;'
p11296
aS'    std::shared_ptr<TrilinosWrappers::PreconditionAMG> Amg_preconditioner;'
p11297
aS'    std::shared_ptr<TrilinosWrappers::PreconditionIC>  Mp_preconditioner;'
p11298
aS'    bool rebuild_stokes_matrix;'
p11299
aS'    bool rebuild_temperature_matrices;'
p11300
aS'    bool rebuild_stokes_preconditioner;'
p11301
aS'  };'
p11302
aS'  template <int dim>'
p11303
aS'  BoussinesqFlowProblem<dim>::BoussinesqFlowProblem()'
p11304
aS'    : triangulation(Triangulation<dim>::maximum_smoothing)'
p11305
aS'    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN())'
p11306
aS'    , stokes_degree(1)'
p11307
aS'    , stokes_fe(FE_Q<dim>(stokes_degree + 1), dim, FE_Q<dim>(stokes_degree), 1)'
p11308
aS'    , stokes_dof_handler(triangulation)'
p11309
aS'    ,'
p11310
aS'    temperature_degree(2)'
p11311
aS'    , temperature_fe(temperature_degree)'
p11312
aS'    , temperature_dof_handler(triangulation)'
p11313
aS'    ,'
p11314
aS'    time_step(0)'
p11315
aS'    , old_time_step(0)'
p11316
aS'    , timestep_number(0)'
p11317
aS'    , rebuild_stokes_matrix(true)'
p11318
aS'    , rebuild_temperature_matrices(true)'
p11319
aS'    , rebuild_stokes_preconditioner(true)'
p11320
aS'  {}'
p11321
aS'  template <int dim>'
p11322
aS'  double BoussinesqFlowProblem<dim>::get_maximal_velocity() const'
p11323
aS'  {'
p11324
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(), stokes_degree + 1);'
p11325
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p11326
aS'    FEValues<dim> fe_values(stokes_fe, quadrature_formula, update_values);'
p11327
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points);'
p11328
aS'    double                      max_velocity = 0;'
p11329
aS'    const FEValuesExtractors::Vector velocities(0);'
p11330
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p11331
aS'      {'
p11332
aS'        fe_values.reinit(cell);'
p11333
aS'        fe_values[velocities].get_function_values(stokes_solution,'
p11334
aS'                                                  velocity_values);'
p11335
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p11336
aS'          max_velocity = std::max(max_velocity, velocity_values[q].norm());'
p11337
aS'      }'
p11338
aS'    return max_velocity;'
p11339
aS'  }'
p11340
aS'  template <int dim>'
p11341
aS'  std::pair<double, double>'
p11342
aS'  BoussinesqFlowProblem<dim>::get_extrapolated_temperature_range() const'
p11343
aS'  {'
p11344
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p11345
aS'                                            temperature_degree);'
p11346
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p11347
aS'    FEValues<dim> fe_values(temperature_fe, quadrature_formula, update_values);'
p11348
aS'    std::vector<double> old_temperature_values(n_q_points);'
p11349
aS'    std::vector<double> old_old_temperature_values(n_q_points);'
p11350
aS'    if (timestep_number != 0)'
p11351
aS'      {'
p11352
aS'        double min_temperature = std::numeric_limits<double>::max(),'
p11353
aS'               max_temperature = -std::numeric_limits<double>::max();'
p11354
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p11355
aS'          {'
p11356
aS'            fe_values.reinit(cell);'
p11357
aS'            fe_values.get_function_values(old_temperature_solution,'
p11358
aS'                                          old_temperature_values);'
p11359
aS'            fe_values.get_function_values(old_old_temperature_solution,'
p11360
aS'                                          old_old_temperature_values);'
p11361
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p11362
aS'              {'
p11363
aS'                const double temperature ='
p11364
aS'                  time_step / old_time_step * old_old_temperature_values[q];'
p11365
aS'                min_temperature = std::min(min_temperature, temperature);'
p11366
aS'                max_temperature = std::max(max_temperature, temperature);'
p11367
aS'              }'
p11368
aS'          }'
p11369
aS'        return std::make_pair(min_temperature, max_temperature);'
p11370
aS'      }'
p11371
aS'    else'
p11372
aS'      {'
p11373
aS'        double min_temperature = std::numeric_limits<double>::max(),'
p11374
aS'               max_temperature = -std::numeric_limits<double>::max();'
p11375
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p11376
aS'          {'
p11377
aS'            fe_values.reinit(cell);'
p11378
aS'            fe_values.get_function_values(old_temperature_solution,'
p11379
aS'                                          old_temperature_values);'
p11380
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p11381
aS'              {'
p11382
aS'                const double temperature = old_temperature_values[q];'
p11383
aS'                min_temperature = std::min(min_temperature, temperature);'
p11384
aS'                max_temperature = std::max(max_temperature, temperature);'
p11385
aS'              }'
p11386
aS'          }'
p11387
aS'        return std::make_pair(min_temperature, max_temperature);'
p11388
aS'      }'
p11389
aS'  }'
p11390
aS'  template <int dim>'
p11391
aS'  double BoussinesqFlowProblem<dim>::compute_viscosity('
p11392
aS'    const std::vector<double> &        old_temperature,'
p11393
aS'    const std::vector<double> &        old_old_temperature,'
p11394
aS'    const std::vector<Tensor<1, dim>> &old_temperature_grads,'
p11395
aS'    const std::vector<Tensor<1, dim>> &old_old_temperature_grads,'
p11396
aS'    const std::vector<double> &        old_temperature_laplacians,'
p11397
aS'    const std::vector<double> &        old_old_temperature_laplacians,'
p11398
aS'    const std::vector<Tensor<1, dim>> &old_velocity_values,'
p11399
aS'    const std::vector<Tensor<1, dim>> &old_old_velocity_values,'
p11400
aS'    const std::vector<double> &        gamma_values,'
p11401
aS'    const double                       global_u_infty,'
p11402
aS'    const double                       global_T_variation,'
p11403
aS'    const double                       cell_diameter) const'
p11404
aS'  {'
p11405
aS'    constexpr double beta  = 0.017 * dim;'
p11406
aS'    constexpr double alpha = 1.0;'
p11407
aS'    if (global_u_infty == 0)'
p11408
aS'      return 5e-3 * cell_diameter;'
p11409
aS'    const unsigned int n_q_points = old_temperature.size();'
p11410
aS'    double max_residual = 0;'
p11411
aS'    double max_velocity = 0;'
p11412
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p11413
aS'      {'
p11414
aS'        const Tensor<1, dim> u ='
p11415
aS'        const double dT_dt ='
p11416
aS'        const double u_grad_T ='
p11417
aS'          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;'
p11418
aS'        const double kappa_Delta_T ='
p11419
aS'          EquationData::kappa *'
p11420
aS'          2;'
p11421
aS'        const double residual ='
p11422
aS'          std::abs((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *'
p11423
aS'                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2,'
p11424
aS'                            alpha - 1.));'
p11425
aS'        max_residual = std::max(residual, max_residual);'
p11426
aS'        max_velocity = std::max(std::sqrt(u * u), max_velocity);'
p11427
aS'      }'
p11428
aS'    const double c_R            = std::pow(2., (4. - 2 * alpha) / dim);'
p11429
aS'    const double global_scaling = c_R * global_u_infty * global_T_variation *'
p11430
aS'                                  std::pow(global_Omega_diameter, alpha - 2.);'
p11431
aS'    return ('
p11432
aS'      beta * max_velocity *'
p11433
aS'      std::min(cell_diameter,'
p11434
aS'               std::pow(cell_diameter, alpha) * max_residual / global_scaling));'
p11435
aS'  }'
p11436
aS'  template <int dim>'
p11437
aS'  void BoussinesqFlowProblem<dim>::setup_dofs()'
p11438
aS'  {'
p11439
aS'    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0);'
p11440
aS'    stokes_sub_blocks[dim] = 1;'
p11441
aS'    {'
p11442
aS'      stokes_dof_handler.distribute_dofs(stokes_fe);'
p11443
aS'      DoFRenumbering::component_wise(stokes_dof_handler, stokes_sub_blocks);'
p11444
aS'      stokes_constraints.clear();'
p11445
aS'      DoFTools::make_hanging_node_constraints(stokes_dof_handler,'
p11446
aS'                                              stokes_constraints);'
p11447
aS'      std::set<types::boundary_id> no_normal_flux_boundaries;'
p11448
aS'      no_normal_flux_boundaries.insert(0);'
p11449
aS'      VectorTools::compute_no_normal_flux_constraints(stokes_dof_handler,'
p11450
aS'                                                      0,'
p11451
aS'                                                      no_normal_flux_boundaries,'
p11452
aS'                                                      stokes_constraints);'
p11453
aS'      stokes_constraints.close();'
p11454
aS'    }'
p11455
aS'    {'
p11456
aS'      temperature_dof_handler.distribute_dofs(temperature_fe);'
p11457
aS'      temperature_constraints.clear();'
p11458
aS'      DoFTools::make_hanging_node_constraints(temperature_dof_handler,'
p11459
aS'                                              temperature_constraints);'
p11460
aS'      temperature_constraints.close();'
p11461
aS'    }'
p11462
aS'    const std::vector<types::global_dof_index> stokes_dofs_per_block ='
p11463
aS'      DoFTools::count_dofs_per_fe_block(stokes_dof_handler, stokes_sub_blocks);'
p11464
aS'    const unsigned int n_u = stokes_dofs_per_block[0],'
p11465
aS'                       n_p = stokes_dofs_per_block[1],'
p11466
aS'                       n_T = temperature_dof_handler.n_dofs();'
p11467
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p11468
aS'              << " (on " << triangulation.n_levels() << " levels)" << std::endl'
p11469
aS'              << "Number of degrees of freedom: " << n_u + n_p + n_T << " ("'
p11470
aS"              << n_u << '+' << n_p << '+' << n_T << ')' << std::endl"
p11471
aS'              << std::endl;'
p11472
aS'    stokes_partitioning.resize(2);'
p11473
aS'    stokes_partitioning[0] = complete_index_set(n_u);'
p11474
aS'    stokes_partitioning[1] = complete_index_set(n_p);'
p11475
aS'    {'
p11476
aS'      stokes_matrix.clear();'
p11477
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p11478
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p11479
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p11480
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p11481
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p11482
aS'      dsp.collect_sizes();'
p11483
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p11484
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p11485
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p11486
aS'          if (!((c == dim) && (d == dim)))'
p11487
aS'            coupling[c][d] = DoFTools::always;'
p11488
aS'          else'
p11489
aS'            coupling[c][d] = DoFTools::none;'
p11490
aS'      DoFTools::make_sparsity_pattern('
p11491
aS'        stokes_dof_handler, coupling, dsp, stokes_constraints, false);'
p11492
aS'      stokes_matrix.reinit(dsp);'
p11493
aS'    }'
p11494
aS'    {'
p11495
aS'      Amg_preconditioner.reset();'
p11496
aS'      Mp_preconditioner.reset();'
p11497
aS'      stokes_preconditioner_matrix.clear();'
p11498
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p11499
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p11500
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p11501
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p11502
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p11503
aS'      dsp.collect_sizes();'
p11504
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p11505
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p11506
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p11507
aS'          if (c == d)'
p11508
aS'            coupling[c][d] = DoFTools::always;'
p11509
aS'          else'
p11510
aS'            coupling[c][d] = DoFTools::none;'
p11511
aS'      DoFTools::make_sparsity_pattern('
p11512
aS'        stokes_dof_handler, coupling, dsp, stokes_constraints, false);'
p11513
aS'      stokes_preconditioner_matrix.reinit(dsp);'
p11514
aS'    }'
p11515
aS'    {'
p11516
aS'      temperature_mass_matrix.clear();'
p11517
aS'      temperature_stiffness_matrix.clear();'
p11518
aS'      temperature_matrix.clear();'
p11519
aS'      DynamicSparsityPattern dsp(n_T, n_T);'
p11520
aS'      DoFTools::make_sparsity_pattern(temperature_dof_handler,'
p11521
aS'                                      dsp,'
p11522
aS'                                      temperature_constraints,'
p11523
aS'                                      false);'
p11524
aS'      temperature_matrix.reinit(dsp);'
p11525
aS'      temperature_mass_matrix.reinit(temperature_matrix);'
p11526
aS'      temperature_stiffness_matrix.reinit(temperature_matrix);'
p11527
aS'    }'
p11528
aS'    IndexSet temperature_partitioning = complete_index_set(n_T);'
p11529
aS'    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);'
p11530
aS'    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);'
p11531
aS'    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);'
p11532
aS'    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);'
p11533
aS'    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);'
p11534
aS'    old_old_temperature_solution.reinit(temperature_partitioning,'
p11535
aS'                                        MPI_COMM_WORLD);'
p11536
aS'    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);'
p11537
aS'  }'
p11538
aS'  template <int dim>'
p11539
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_preconditioner()'
p11540
aS'  {'
p11541
aS'    stokes_preconditioner_matrix = 0;'
p11542
aS'    const QGauss<dim> quadrature_formula(stokes_degree + 2);'
p11543
aS'    FEValues<dim>     stokes_fe_values(stokes_fe,'
p11544
aS'                                   quadrature_formula,'
p11545
aS'                                   update_JxW_values | update_values |'
p11546
aS'                                     update_gradients);'
p11547
aS'    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p11548
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p11549
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p11550
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p11551
aS'    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);'
p11552
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p11553
aS'    const FEValuesExtractors::Vector velocities(0);'
p11554
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p11555
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p11556
aS'      {'
p11557
aS'        stokes_fe_values.reinit(cell);'
p11558
aS'        local_matrix = 0;'
p11559
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p11560
aS'          {'
p11561
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p11562
aS'              {'
p11563
aS'                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);'
p11564
aS'                phi_p[k]      = stokes_fe_values[pressure].value(k, q);'
p11565
aS'              }'
p11566
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11567
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p11568
aS'                local_matrix(i, j) +='
p11569
aS'                     scalar_product(grad_phi_u[i], grad_phi_u[j]) +'
p11570
aS'                  stokes_fe_values.JxW(q);'
p11571
aS'          }'
p11572
aS'        cell->get_dof_indices(local_dof_indices);'
p11573
aS'        stokes_constraints.distribute_local_to_global('
p11574
aS'          local_matrix, local_dof_indices, stokes_preconditioner_matrix);'
p11575
aS'      }'
p11576
aS'  }'
p11577
aS'  template <int dim>'
p11578
aS'  void BoussinesqFlowProblem<dim>::build_stokes_preconditioner()'
p11579
aS'  {'
p11580
aS'    if (rebuild_stokes_preconditioner == false)'
p11581
aS'      return;'
p11582
aS'    std::cout << "   Rebuilding Stokes preconditioner..." << std::flush;'
p11583
aS'    assemble_stokes_preconditioner();'
p11584
aS'    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionAMG>();'
p11585
aS'    std::vector<std::vector<bool>> constant_modes;'
p11586
aS'    FEValuesExtractors::Vector     velocity_components(0);'
p11587
aS'    DoFTools::extract_constant_modes(stokes_dof_handler,'
p11588
aS'                                     stokes_fe.component_mask('
p11589
aS'                                       velocity_components),'
p11590
aS'                                     constant_modes);'
p11591
aS'    TrilinosWrappers::PreconditionAMG::AdditionalData amg_data;'
p11592
aS'    amg_data.constant_modes = constant_modes;'
p11593
aS'    amg_data.elliptic              = true;'
p11594
aS'    amg_data.higher_order_elements = true;'
p11595
aS'    amg_data.smoother_sweeps       = 2;'
p11596
aS'    amg_data.aggregation_threshold = 0.02;'
p11597
aS'    Amg_preconditioner->initialize(stokes_preconditioner_matrix.block(0, 0),'
p11598
aS'                                   amg_data);'
p11599
aS'    Mp_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>();'
p11600
aS'    Mp_preconditioner->initialize(stokes_preconditioner_matrix.block(1, 1));'
p11601
aS'    std::cout << std::endl;'
p11602
aS'    rebuild_stokes_preconditioner = false;'
p11603
aS'  }'
p11604
aS'  template <int dim>'
p11605
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_system()'
p11606
aS'  {'
p11607
aS'    std::cout << "   Assembling..." << std::flush;'
p11608
aS'    if (rebuild_stokes_matrix == true)'
p11609
aS'      stokes_matrix = 0;'
p11610
aS'    stokes_rhs = 0;'
p11611
aS'    const QGauss<dim> quadrature_formula(stokes_degree + 2);'
p11612
aS'    FEValues<dim>     stokes_fe_values('
p11613
aS'      stokes_fe,'
p11614
aS'      quadrature_formula,'
p11615
aS'      update_values | update_quadrature_points | update_JxW_values |'
p11616
aS'    FEValues<dim> temperature_fe_values(temperature_fe,'
p11617
aS'                                        quadrature_formula,'
p11618
aS'                                        update_values);'
p11619
aS'    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p11620
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p11621
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p11622
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p11623
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p11624
aS'    std::vector<double> old_temperature_values(n_q_points);'
p11625
aS'    std::vector<Tensor<1, dim>>          phi_u(dofs_per_cell);'
p11626
aS'    std::vector<SymmetricTensor<2, dim>> grads_phi_u(dofs_per_cell);'
p11627
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p11628
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p11629
aS'    const FEValuesExtractors::Vector velocities(0);'
p11630
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p11631
aS'    auto       cell             = stokes_dof_handler.begin_active();'
p11632
aS'    const auto endc             = stokes_dof_handler.end();'
p11633
aS'    auto       temperature_cell = temperature_dof_handler.begin_active();'
p11634
aS'    for (; cell != endc; ++cell, ++temperature_cell)'
p11635
aS'      {'
p11636
aS'        stokes_fe_values.reinit(cell);'
p11637
aS'        temperature_fe_values.reinit(temperature_cell);'
p11638
aS'        local_matrix = 0;'
p11639
aS'        local_rhs    = 0;'
p11640
aS'        temperature_fe_values.get_function_values(old_temperature_solution,'
p11641
aS'                                                  old_temperature_values);'
p11642
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p11643
aS'          {'
p11644
aS'            const double old_temperature = old_temperature_values[q];'
p11645
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p11646
aS'              {'
p11647
aS'                phi_u[k] = stokes_fe_values[velocities].value(k, q);'
p11648
aS'                if (rebuild_stokes_matrix)'
p11649
aS'                  {'
p11650
aS'                    grads_phi_u[k] ='
p11651
aS'                      stokes_fe_values[velocities].symmetric_gradient(k, q);'
p11652
aS'                    div_phi_u[k] ='
p11653
aS'                      stokes_fe_values[velocities].divergence(k, q);'
p11654
aS'                    phi_p[k] = stokes_fe_values[pressure].value(k, q);'
p11655
aS'                  }'
p11656
aS'              }'
p11657
aS'            if (rebuild_stokes_matrix)'
p11658
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11659
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p11660
aS'                  local_matrix(i, j) +='
p11661
aS'                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p11662
aS'                    stokes_fe_values.JxW(q);'
p11663
aS'            const Point<dim> gravity ='
p11664
aS'              -((dim == 2) ? (Point<dim>(0, 1)) : (Point<dim>(0, 0, 1)));'
p11665
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11666
aS'              local_rhs(i) += (-EquationData::density * EquationData::beta *'
p11667
aS'                               gravity * phi_u[i] * old_temperature) *'
p11668
aS'                              stokes_fe_values.JxW(q);'
p11669
aS'          }'
p11670
aS'        cell->get_dof_indices(local_dof_indices);'
p11671
aS'        if (rebuild_stokes_matrix == true)'
p11672
aS'          stokes_constraints.distribute_local_to_global(local_matrix,'
p11673
aS'                                                        local_rhs,'
p11674
aS'                                                        local_dof_indices,'
p11675
aS'                                                        stokes_matrix,'
p11676
aS'                                                        stokes_rhs);'
p11677
aS'        else'
p11678
aS'          stokes_constraints.distribute_local_to_global(local_rhs,'
p11679
aS'                                                        local_dof_indices,'
p11680
aS'                                                        stokes_rhs);'
p11681
aS'      }'
p11682
aS'    rebuild_stokes_matrix = false;'
p11683
aS'    std::cout << std::endl;'
p11684
aS'  }'
p11685
aS'  template <int dim>'
p11686
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_matrix()'
p11687
aS'  {'
p11688
aS'    if (rebuild_temperature_matrices == false)'
p11689
aS'      return;'
p11690
aS'    temperature_mass_matrix      = 0;'
p11691
aS'    temperature_stiffness_matrix = 0;'
p11692
aS'    QGauss<dim>   quadrature_formula(temperature_degree + 2);'
p11693
aS'    FEValues<dim> temperature_fe_values(temperature_fe,'
p11694
aS'                                        quadrature_formula,'
p11695
aS'                                        update_values | update_gradients |'
p11696
aS'                                          update_JxW_values);'
p11697
aS'    const unsigned int dofs_per_cell = temperature_fe.n_dofs_per_cell();'
p11698
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p11699
aS'    FullMatrix<double> local_mass_matrix(dofs_per_cell, dofs_per_cell);'
p11700
aS'    FullMatrix<double> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);'
p11701
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p11702
aS'    std::vector<double>         phi_T(dofs_per_cell);'
p11703
aS'    std::vector<Tensor<1, dim>> grad_phi_T(dofs_per_cell);'
p11704
aS'    for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p11705
aS'      {'
p11706
aS'        local_mass_matrix      = 0;'
p11707
aS'        local_stiffness_matrix = 0;'
p11708
aS'        temperature_fe_values.reinit(cell);'
p11709
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p11710
aS'          {'
p11711
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p11712
aS'              {'
p11713
aS'                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);'
p11714
aS'                phi_T[k]      = temperature_fe_values.shape_value(k, q);'
p11715
aS'              }'
p11716
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11717
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p11718
aS'                {'
p11719
aS'                  local_mass_matrix(i, j) +='
p11720
aS'                  local_stiffness_matrix(i, j) +='
p11721
aS'                     temperature_fe_values.JxW(q));'
p11722
aS'                }'
p11723
aS'          }'
p11724
aS'        cell->get_dof_indices(local_dof_indices);'
p11725
aS'        temperature_constraints.distribute_local_to_global('
p11726
aS'          local_mass_matrix, local_dof_indices, temperature_mass_matrix);'
p11727
aS'        temperature_constraints.distribute_local_to_global('
p11728
aS'          local_stiffness_matrix,'
p11729
aS'          local_dof_indices,'
p11730
aS'          temperature_stiffness_matrix);'
p11731
aS'      }'
p11732
aS'    rebuild_temperature_matrices = false;'
p11733
aS'  }'
p11734
aS'  template <int dim>'
p11735
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_system('
p11736
aS'    const double maximal_velocity)'
p11737
aS'  {'
p11738
aS'    const bool use_bdf2_scheme = (timestep_number != 0);'
p11739
aS'    if (use_bdf2_scheme == true)'
p11740
aS'      {'
p11741
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p11742
aS'        temperature_matrix *='
p11743
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p11744
aS'      }'
p11745
aS'    else'
p11746
aS'      {'
p11747
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p11748
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p11749
aS'      }'
p11750
aS'    temperature_rhs = 0;'
p11751
aS'    const QGauss<dim> quadrature_formula(temperature_degree + 2);'
p11752
aS'    FEValues<dim>     temperature_fe_values(temperature_fe,'
p11753
aS'                                        quadrature_formula,'
p11754
aS'                                        update_values | update_gradients |'
p11755
aS'                                          update_hessians |'
p11756
aS'                                          update_quadrature_points |'
p11757
aS'                                          update_JxW_values);'
p11758
aS'    FEValues<dim>     stokes_fe_values(stokes_fe,'
p11759
aS'                                   quadrature_formula,'
p11760
aS'                                   update_values);'
p11761
aS'    const unsigned int dofs_per_cell = temperature_fe.n_dofs_per_cell();'
p11762
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p11763
aS'    Vector<double> local_rhs(dofs_per_cell);'
p11764
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p11765
aS'    std::vector<Tensor<1, dim>> old_velocity_values(n_q_points);'
p11766
aS'    std::vector<Tensor<1, dim>> old_old_velocity_values(n_q_points);'
p11767
aS'    std::vector<double>         old_temperature_values(n_q_points);'
p11768
aS'    std::vector<double>         old_old_temperature_values(n_q_points);'
p11769
aS'    std::vector<Tensor<1, dim>> old_temperature_grads(n_q_points);'
p11770
aS'    std::vector<Tensor<1, dim>> old_old_temperature_grads(n_q_points);'
p11771
aS'    std::vector<double>         old_temperature_laplacians(n_q_points);'
p11772
aS'    std::vector<double>         old_old_temperature_laplacians(n_q_points);'
p11773
aS'    EquationData::TemperatureRightHandSide<dim> temperature_right_hand_side;'
p11774
aS'    std::vector<double>                         gamma_values(n_q_points);'
p11775
aS'    std::vector<double>         phi_T(dofs_per_cell);'
p11776
aS'    std::vector<Tensor<1, dim>> grad_phi_T(dofs_per_cell);'
p11777
aS'    const std::pair<double, double> global_T_range ='
p11778
aS'      get_extrapolated_temperature_range();'
p11779
aS'    const FEValuesExtractors::Vector velocities(0);'
p11780
aS'    auto       cell        = temperature_dof_handler.begin_active();'
p11781
aS'    const auto endc        = temperature_dof_handler.end();'
p11782
aS'    auto       stokes_cell = stokes_dof_handler.begin_active();'
p11783
aS'    for (; cell != endc; ++cell, ++stokes_cell)'
p11784
aS'      {'
p11785
aS'        local_rhs = 0;'
p11786
aS'        temperature_fe_values.reinit(cell);'
p11787
aS'        stokes_fe_values.reinit(stokes_cell);'
p11788
aS'        temperature_fe_values.get_function_values(old_temperature_solution,'
p11789
aS'                                                  old_temperature_values);'
p11790
aS'        temperature_fe_values.get_function_values(old_old_temperature_solution,'
p11791
aS'                                                  old_old_temperature_values);'
p11792
aS'        temperature_fe_values.get_function_gradients(old_temperature_solution,'
p11793
aS'                                                     old_temperature_grads);'
p11794
aS'        temperature_fe_values.get_function_gradients('
p11795
aS'          old_old_temperature_solution, old_old_temperature_grads);'
p11796
aS'        temperature_fe_values.get_function_laplacians('
p11797
aS'          old_temperature_solution, old_temperature_laplacians);'
p11798
aS'        temperature_fe_values.get_function_laplacians('
p11799
aS'          old_old_temperature_solution, old_old_temperature_laplacians);'
p11800
aS'        temperature_right_hand_side.value_list('
p11801
aS'          temperature_fe_values.get_quadrature_points(), gamma_values);'
p11802
aS'        stokes_fe_values[velocities].get_function_values(stokes_solution,'
p11803
aS'                                                         old_velocity_values);'
p11804
aS'        stokes_fe_values[velocities].get_function_values('
p11805
aS'          old_stokes_solution, old_old_velocity_values);'
p11806
aS'        const double nu ='
p11807
aS'          compute_viscosity(old_temperature_values,'
p11808
aS'                            old_old_temperature_values,'
p11809
aS'                            old_temperature_grads,'
p11810
aS'                            old_old_temperature_grads,'
p11811
aS'                            old_temperature_laplacians,'
p11812
aS'                            old_old_temperature_laplacians,'
p11813
aS'                            old_velocity_values,'
p11814
aS'                            old_old_velocity_values,'
p11815
aS'                            gamma_values,'
p11816
aS'                            maximal_velocity,'
p11817
aS'                            global_T_range.second - global_T_range.first,'
p11818
aS'                            cell->diameter());'
p11819
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p11820
aS'          {'
p11821
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p11822
aS'              {'
p11823
aS'                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);'
p11824
aS'                phi_T[k]      = temperature_fe_values.shape_value(k, q);'
p11825
aS'              }'
p11826
aS'            const double T_term_for_rhs ='
p11827
aS'                  old_old_temperature_values[q] * (time_step * time_step) /'
p11828
aS'                 old_temperature_values[q]);'
p11829
aS'            const Tensor<1, dim> ext_grad_T ='
p11830
aS'                  old_old_temperature_grads[q] * time_step / old_time_step) :'
p11831
aS'                 old_temperature_grads[q]);'
p11832
aS'            const Tensor<1, dim> extrapolated_u ='
p11833
aS'                  old_old_velocity_values[q] * time_step / old_time_step) :'
p11834
aS'                 old_velocity_values[q]);'
p11835
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p11836
aS'              local_rhs(i) +='
p11837
aS'                 time_step * extrapolated_u * ext_grad_T * phi_T[i] -'
p11838
aS'                 time_step * nu * ext_grad_T * grad_phi_T[i] +'
p11839
aS'                 time_step * gamma_values[q] * phi_T[i]) *'
p11840
aS'                temperature_fe_values.JxW(q);'
p11841
aS'          }'
p11842
aS'        cell->get_dof_indices(local_dof_indices);'
p11843
aS'        temperature_constraints.distribute_local_to_global(local_rhs,'
p11844
aS'                                                           local_dof_indices,'
p11845
aS'                                                           temperature_rhs);'
p11846
aS'      }'
p11847
aS'  }'
p11848
aS'  template <int dim>'
p11849
aS'  void BoussinesqFlowProblem<dim>::solve()'
p11850
aS'  {'
p11851
aS'    std::cout << "   Solving..." << std::endl;'
p11852
aS'    {'
p11853
aS'      const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix,'
p11854
aS'                                         TrilinosWrappers::PreconditionIC>'
p11855
aS'        mp_inverse(stokes_preconditioner_matrix.block(1, 1),'
p11856
aS'      const LinearSolvers::BlockSchurPreconditioner<'
p11857
aS'        TrilinosWrappers::PreconditionAMG,'
p11858
aS'        TrilinosWrappers::PreconditionIC>'
p11859
aS'        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);'
p11860
aS'      SolverControl solver_control(stokes_matrix.m(),'
p11861
aS'                                   1e-6 * stokes_rhs.l2_norm());'
p11862
aS'      SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres('
p11863
aS'        solver_control,'
p11864
aS'        SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData(100));'
p11865
aS'      for (unsigned int i = 0; i < stokes_solution.size(); ++i)'
p11866
aS'        if (stokes_constraints.is_constrained(i))'
p11867
aS'          stokes_solution(i) = 0;'
p11868
aS'      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);'
p11869
aS'      stokes_constraints.distribute(stokes_solution);'
p11870
aS'      std::cout << "   " << solver_control.last_step()'
p11871
aS'                << " GMRES iterations for Stokes subsystem." << std::endl;'
p11872
aS'    }'
p11873
aS'    old_time_step                 = time_step;'
p11874
aS'    const double maximal_velocity = get_maximal_velocity();'
p11875
aS'    if (maximal_velocity >= 0.01)'
p11876
aS'      time_step = 1. / (1.7 * dim * std::sqrt(1. * dim)) / temperature_degree *'
p11877
aS'                  GridTools::minimal_cell_diameter(triangulation) /'
p11878
aS'                  maximal_velocity;'
p11879
aS'    else'
p11880
aS'      time_step = 1. / (1.7 * dim * std::sqrt(1. * dim)) / temperature_degree *'
p11881
aS'                  GridTools::minimal_cell_diameter(triangulation) / .01;'
p11882
aS'    std::cout << "   "'
p11883
aS'              << "Time step: " << time_step << std::endl;'
p11884
aS'    temperature_solution = old_temperature_solution;'
p11885
aS'    assemble_temperature_system(maximal_velocity);'
p11886
aS'    {'
p11887
aS'      SolverControl solver_control(temperature_matrix.m(),'
p11888
aS'                                   1e-8 * temperature_rhs.l2_norm());'
p11889
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p11890
aS'      TrilinosWrappers::PreconditionIC preconditioner;'
p11891
aS'      preconditioner.initialize(temperature_matrix);'
p11892
aS'      cg.solve(temperature_matrix,'
p11893
aS'               temperature_solution,'
p11894
aS'               temperature_rhs,'
p11895
aS'               preconditioner);'
p11896
aS'      temperature_constraints.distribute(temperature_solution);'
p11897
aS'      std::cout << "   " << solver_control.last_step()'
p11898
aS'                << " CG iterations for temperature." << std::endl;'
p11899
aS'      double min_temperature = temperature_solution(0),'
p11900
aS'             max_temperature = temperature_solution(0);'
p11901
aS'      for (unsigned int i = 0; i < temperature_solution.size(); ++i)'
p11902
aS'        {'
p11903
aS'          min_temperature ='
p11904
aS'            std::min<double>(min_temperature, temperature_solution(i));'
p11905
aS'          max_temperature ='
p11906
aS'            std::max<double>(max_temperature, temperature_solution(i));'
p11907
aS'        }'
p11908
aS'      std::cout << "   Temperature range: " << min_temperature << \' \''
p11909
aS'                << max_temperature << std::endl;'
p11910
aS'    }'
p11911
aS'  }'
p11912
aS'  template <int dim>'
p11913
aS'  void BoussinesqFlowProblem<dim>::output_results() const'
p11914
aS'  {'
p11915
aS'    if (timestep_number % 10 != 0)'
p11916
aS'      return;'
p11917
aS'    std::vector<std::string> stokes_names(dim, "velocity");'
p11918
aS'    stokes_names.emplace_back("p");'
p11919
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p11920
aS'      stokes_component_interpretation('
p11921
aS'        dim + 1, DataComponentInterpretation::component_is_scalar);'
p11922
aS'    for (unsigned int i = 0; i < dim; ++i)'
p11923
aS'      stokes_component_interpretation[i] ='
p11924
aS'        DataComponentInterpretation::component_is_part_of_vector;'
p11925
aS'    DataOut<dim> data_out;'
p11926
aS'    data_out.add_data_vector(stokes_dof_handler,'
p11927
aS'                             stokes_solution,'
p11928
aS'                             stokes_names,'
p11929
aS'                             stokes_component_interpretation);'
p11930
aS'    data_out.add_data_vector(temperature_dof_handler,'
p11931
aS'                             temperature_solution,'
p11932
aS'                             "T");'
p11933
aS'    data_out.build_patches(std::min(stokes_degree, temperature_degree));'
p11934
aS'    std::ofstream output("solution-" +'
p11935
aS'                         Utilities::int_to_string(timestep_number, 4) + ".vtk");'
p11936
aS'    data_out.write_vtk(output);'
p11937
aS'  }'
p11938
aS'  template <int dim>'
p11939
aS'  void'
p11940
aS'  BoussinesqFlowProblem<dim>::refine_mesh(const unsigned int max_grid_level)'
p11941
aS'  {'
p11942
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p11943
aS'    KellyErrorEstimator<dim>::estimate(temperature_dof_handler,'
p11944
aS'                                       QGauss<dim - 1>(temperature_degree + 1),'
p11945
aS'                                       {},'
p11946
aS'                                       temperature_solution,'
p11947
aS'                                       estimated_error_per_cell);'
p11948
aS'    GridRefinement::refine_and_coarsen_fixed_fraction(triangulation,'
p11949
aS'                                                      estimated_error_per_cell,'
p11950
aS'                                                      0.8,'
p11951
aS'                                                      0.1);'
p11952
aS'    if (triangulation.n_levels() > max_grid_level)'
p11953
aS'      for (auto &cell :'
p11954
aS'           triangulation.active_cell_iterators_on_level(max_grid_level))'
p11955
aS'        cell->clear_refine_flag();'
p11956
aS'    std::vector<TrilinosWrappers::MPI::Vector> x_temperature(2);'
p11957
aS'    x_temperature[0]                            = temperature_solution;'
p11958
aS'    x_temperature[1]                            = old_temperature_solution;'
p11959
aS'    TrilinosWrappers::MPI::BlockVector x_stokes = stokes_solution;'
p11960
aS'    SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> temperature_trans('
p11961
aS'      temperature_dof_handler);'
p11962
aS'    SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> stokes_trans('
p11963
aS'      stokes_dof_handler);'
p11964
aS'    triangulation.prepare_coarsening_and_refinement();'
p11965
aS'    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);'
p11966
aS'    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);'
p11967
aS'    triangulation.execute_coarsening_and_refinement();'
p11968
aS'    setup_dofs();'
p11969
aS'    std::vector<TrilinosWrappers::MPI::Vector> tmp(2);'
p11970
aS'    tmp[0].reinit(temperature_solution);'
p11971
aS'    tmp[1].reinit(temperature_solution);'
p11972
aS'    temperature_trans.interpolate(x_temperature, tmp);'
p11973
aS'    temperature_solution     = tmp[0];'
p11974
aS'    old_temperature_solution = tmp[1];'
p11975
aS'    temperature_constraints.distribute(temperature_solution);'
p11976
aS'    temperature_constraints.distribute(old_temperature_solution);'
p11977
aS'    stokes_trans.interpolate(x_stokes, stokes_solution);'
p11978
aS'    stokes_constraints.distribute(stokes_solution);'
p11979
aS'    rebuild_stokes_matrix         = true;'
p11980
aS'    rebuild_temperature_matrices  = true;'
p11981
aS'    rebuild_stokes_preconditioner = true;'
p11982
aS'  }'
p11983
aS'  template <int dim>'
p11984
aS'  void BoussinesqFlowProblem<dim>::run()'
p11985
aS'  {'
p11986
aS'    const unsigned int initial_refinement     = (dim == 2 ? 4 : 2);'
p11987
aS'    const unsigned int n_pre_refinement_steps = (dim == 2 ? 4 : 3);'
p11988
aS'    GridGenerator::hyper_cube(triangulation);'
p11989
aS'    global_Omega_diameter = GridTools::diameter(triangulation);'
p11990
aS'    triangulation.refine_global(initial_refinement);'
p11991
aS'    setup_dofs();'
p11992
aS'    unsigned int pre_refinement_step = 0;'
p11993
aS'  start_time_iteration:'
p11994
aS'    VectorTools::project(temperature_dof_handler,'
p11995
aS'                         temperature_constraints,'
p11996
aS'                         QGauss<dim>(temperature_degree + 2),'
p11997
aS'                         EquationData::TemperatureInitialValues<dim>(),'
p11998
aS'                         old_temperature_solution);'
p11999
aS'    timestep_number = 0;'
p12000
aS'    time_step = old_time_step = 0;'
p12001
aS'    double time = 0;'
p12002
aS'    do'
p12003
aS'      {'
p12004
aS'        std::cout << "Timestep " << timestep_number << ":  t=" << time'
p12005
aS'                  << std::endl;'
p12006
aS'        assemble_stokes_system();'
p12007
aS'        build_stokes_preconditioner();'
p12008
aS'        assemble_temperature_matrix();'
p12009
aS'        solve();'
p12010
aS'        output_results();'
p12011
aS'        std::cout << std::endl;'
p12012
aS'        if ((timestep_number == 0) &&'
p12013
aS'          {'
p12014
aS'            refine_mesh(initial_refinement + n_pre_refinement_steps);'
p12015
aS'            ++pre_refinement_step;'
p12016
aS'            goto start_time_iteration;'
p12017
aS'          }'
p12018
aS'        else if ((timestep_number > 0) && (timestep_number % 5 == 0))'
p12019
aS'          refine_mesh(initial_refinement + n_pre_refinement_steps);'
p12020
aS'        time += time_step;'
p12021
aS'        ++timestep_number;'
p12022
aS'        old_stokes_solution          = stokes_solution;'
p12023
aS'        old_old_temperature_solution = old_temperature_solution;'
p12024
aS'        old_temperature_solution     = temperature_solution;'
p12025
aS'      }'
p12026
aS'    while (time <= 100);'
p12027
aS'  }'
p12028
aS'} // namespace Step31'
p12029
aS'int main(int argc, char *argv[])'
p12030
ag9
aS'  try'
p12031
aS'    {'
p12032
aS'      using namespace dealii;'
p12033
aS'      using namespace Step31;'
p12034
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p12035
aS'        argc, argv, numbers::invalid_unsigned_int);'
p12036
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p12037
aS'                  ExcMessage('
p12038
aS'                    "This program can only be run in serial, use ./step-31"));'
p12039
aS'      BoussinesqFlowProblem<2> flow_problem;'
p12040
aS'      flow_problem.run();'
p12041
aS'    }'
p12042
aS'  catch (std::exception &exc)'
p12043
aS'    {'
p12044
aS'      std::cerr << std::endl'
p12045
aS'                << std::endl'
p12046
aS'                << "----------------------------------------------------"'
p12047
aS'                << std::endl;'
p12048
aS'      std::cerr << "Exception on processing: " << std::endl'
p12049
aS'                << exc.what() << std::endl'
p12050
aS'                << "Aborting!" << std::endl'
p12051
aS'                << "----------------------------------------------------"'
p12052
aS'                << std::endl;'
p12053
aS'      return 1;'
p12054
aS'    }'
p12055
aS'  catch (...)'
p12056
aS'    {'
p12057
aS'      std::cerr << std::endl'
p12058
aS'                << std::endl'
p12059
aS'                << "----------------------------------------------------"'
p12060
aS'                << std::endl;'
p12061
aS'      std::cerr << "Unknown exception!" << std::endl'
p12062
aS'                << "Aborting!" << std::endl'
p12063
aS'                << "----------------------------------------------------"'
p12064
aS'                << std::endl;'
p12065
aS'      return 1;'
p12066
aS'    }'
p12067
aS'  return 0;'
p12068
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p12069
aS'#include <deal.II/base/logstream.h>'
p12070
aS'#include <deal.II/base/function.h>'
p12071
aS'#include <deal.II/base/utilities.h>'
p12072
aS'#include <deal.II/base/conditional_ostream.h>'
p12073
aS'#include <deal.II/base/work_stream.h>'
p12074
aS'#include <deal.II/base/timer.h>'
p12075
aS'#include <deal.II/base/parameter_handler.h>'
p12076
aS'#include <deal.II/lac/full_matrix.h>'
p12077
aS'#include <deal.II/lac/solver_bicgstab.h>'
p12078
aS'#include <deal.II/lac/solver_cg.h>'
p12079
aS'#include <deal.II/lac/solver_gmres.h>'
p12080
aS'#include <deal.II/lac/affine_constraints.h>'
p12081
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p12082
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p12083
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p12084
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p12085
aS'#include <deal.II/lac/trilinos_precondition.h>'
p12086
aS'#include <deal.II/lac/trilinos_solver.h>'
p12087
aS'#include <deal.II/grid/tria.h>'
p12088
aS'#include <deal.II/grid/grid_generator.h>'
p12089
aS'#include <deal.II/grid/filtered_iterator.h>'
p12090
aS'#include <deal.II/grid/manifold_lib.h>'
p12091
aS'#include <deal.II/grid/grid_tools.h>'
p12092
aS'#include <deal.II/grid/grid_refinement.h>'
p12093
aS'#include <deal.II/dofs/dof_handler.h>'
p12094
aS'#include <deal.II/dofs/dof_renumbering.h>'
p12095
aS'#include <deal.II/dofs/dof_tools.h>'
p12096
aS'#include <deal.II/fe/fe_q.h>'
p12097
aS'#include <deal.II/fe/fe_dgq.h>'
p12098
aS'#include <deal.II/fe/fe_dgp.h>'
p12099
aS'#include <deal.II/fe/fe_system.h>'
p12100
aS'#include <deal.II/fe/fe_values.h>'
p12101
aS'#include <deal.II/fe/mapping_q.h>'
p12102
aS'#include <deal.II/numerics/vector_tools.h>'
p12103
aS'#include <deal.II/numerics/matrix_tools.h>'
p12104
aS'#include <deal.II/numerics/data_out.h>'
p12105
aS'#include <deal.II/numerics/error_estimator.h>'
p12106
aS'#include <deal.II/numerics/solution_transfer.h>'
p12107
aS'#include <fstream>'
p12108
aS'#include <iostream>'
p12109
aS'#include <limits>'
p12110
aS'#include <locale>'
p12111
aS'#include <string>'
p12112
aS'#include <deal.II/distributed/solution_transfer.h>'
p12113
aS'#include <deal.II/base/index_set.h>'
p12114
aS'#include <deal.II/distributed/tria.h>'
p12115
aS'#include <deal.II/distributed/grid_refinement.h>'
p12116
aS'namespace Step32'
p12117
ag9
aS'  using namespace dealii;'
p12118
aS'  namespace EquationData'
p12119
aS'  {'
p12120
aS'    constexpr double eta                   = 1e21;    /* Pa s       */'
p12121
aS'    constexpr double kappa                 = 1e-6;    /* m^2 / s    */'
p12122
aS'    constexpr double reference_density     = 3300;    /* kg / m^3   */'
p12123
aS'    constexpr double reference_temperature = 293;     /* K          */'
p12124
aS'    constexpr double expansion_coefficient = 2e-5;    /* 1/K        */'
p12125
aS'    constexpr double specific_heat         = 1250;    /* J / K / kg */'
p12126
aS'    constexpr double radiogenic_heating    = 7.4e-12; /* W / kg     */'
p12127
aS'    constexpr double R0 = 6371000. - 2890000.; /* m          */'
p12128
aS'    constexpr double R1 = 6371000. - 35000.;   /* m          */'
p12129
aS'    constexpr double T0 = 4000 + 273; /* K          */'
p12130
aS'    constexpr double T1 = 700 + 273;  /* K          */'
p12131
aS'    double density(const double temperature)'
p12132
aS'    {'
p12133
aS'      return ('
p12134
aS'        reference_density *'
p12135
aS'    }'
p12136
aS'    template <int dim>'
p12137
aS'    Tensor<1, dim> gravity_vector(const Point<dim> &p)'
p12138
aS'    {'
p12139
aS'      const double r = p.norm();'
p12140
aS'      return -(1.245e-6 * r + 7.714e13 / r / r) * p / r;'
p12141
aS'    }'
p12142
aS'    template <int dim>'
p12143
aS'    class TemperatureInitialValues : public Function<dim>'
p12144
aS'    {'
p12145
aS'    public:'
p12146
aS'      TemperatureInitialValues()'
p12147
aS'        : Function<dim>(1)'
p12148
aS'      {}'
p12149
aS'      virtual double value(const Point<dim> & p,'
p12150
aS'                           const unsigned int component = 0) const override;'
p12151
aS'      virtual void vector_value(const Point<dim> &p,'
p12152
aS'                                Vector<double> &  value) const override;'
p12153
aS'    };'
p12154
aS'    template <int dim>'
p12155
aS'    double TemperatureInitialValues<dim>::value(const Point<dim> &p,'
p12156
aS'                                                const unsigned int) const'
p12157
aS'    {'
p12158
aS'      const double r = p.norm();'
p12159
aS'      const double h = R1 - R0;'
p12160
aS'      const double s = (r - R0) / h;'
p12161
aS'      const double q ='
p12162
aS'      const double phi = std::atan2(p(0), p(1));'
p12163
aS'      const double tau = s + 0.2 * s * (1 - s) * std::sin(6 * phi) * q;'
p12164
aS'      return T0 * (1.0 - tau) + T1 * tau;'
p12165
aS'    }'
p12166
aS'    template <int dim>'
p12167
aS'    void'
p12168
aS'    TemperatureInitialValues<dim>::vector_value(const Point<dim> &p,'
p12169
aS'                                                Vector<double> &  values) const'
p12170
aS'    {'
p12171
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p12172
aS'        values(c) = TemperatureInitialValues<dim>::value(p, c);'
p12173
aS'    }'
p12174
aS'    constexpr double pressure_scaling = eta / 10000;'
p12175
aS'    const double year_in_seconds = 60 * 60 * 24 * 365.2425;'
p12176
aS'  } // namespace EquationData'
p12177
aS'  namespace LinearSolvers'
p12178
aS'  {'
p12179
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p12180
aS'    class BlockSchurPreconditioner : public Subscriptor'
p12181
aS'    {'
p12182
aS'    public:'
p12183
aS'      BlockSchurPreconditioner(const TrilinosWrappers::BlockSparseMatrix &S,'
p12184
aS'                               const TrilinosWrappers::BlockSparseMatrix &Spre,'
p12185
aS'                               const PreconditionerTypeMp &Mppreconditioner,'
p12186
aS'                               const PreconditionerTypeA & Apreconditioner,'
p12187
aS'                               const bool                  do_solve_A)'
p12188
aS'        : stokes_matrix(&S)'
p12189
aS'        , stokes_preconditioner_matrix(&Spre)'
p12190
aS'        , mp_preconditioner(Mppreconditioner)'
p12191
aS'        , a_preconditioner(Apreconditioner)'
p12192
aS'        , do_solve_A(do_solve_A)'
p12193
aS'      {}'
p12194
aS'      void vmult(TrilinosWrappers::MPI::BlockVector &      dst,'
p12195
aS'                 const TrilinosWrappers::MPI::BlockVector &src) const'
p12196
aS'      {'
p12197
aS'        TrilinosWrappers::MPI::Vector utmp(src.block(0));'
p12198
aS'        {'
p12199
aS'          SolverControl solver_control(5000, 1e-6 * src.block(1).l2_norm());'
p12200
aS'          SolverCG<TrilinosWrappers::MPI::Vector> solver(solver_control);'
p12201
aS'          solver.solve(stokes_preconditioner_matrix->block(1, 1),'
p12202
aS'                       dst.block(1),'
p12203
aS'                       src.block(1),'
p12204
aS'                       mp_preconditioner);'
p12205
aS'          dst.block(1) *= -1.0;'
p12206
aS'        }'
p12207
aS'        {'
p12208
aS'          stokes_matrix->block(0, 1).vmult(utmp, dst.block(1));'
p12209
aS'          utmp *= -1.0;'
p12210
aS'          utmp.add(src.block(0));'
p12211
aS'        }'
p12212
aS'        if (do_solve_A == true)'
p12213
aS'          {'
p12214
aS'            SolverControl solver_control(5000, utmp.l2_norm() * 1e-2);'
p12215
aS'            TrilinosWrappers::SolverCG solver(solver_control);'
p12216
aS'            solver.solve(stokes_matrix->block(0, 0),'
p12217
aS'                         dst.block(0),'
p12218
aS'                         utmp,'
p12219
aS'                         a_preconditioner);'
p12220
aS'          }'
p12221
aS'        else'
p12222
aS'          a_preconditioner.vmult(dst.block(0), utmp);'
p12223
aS'      }'
p12224
aS'    private:'
p12225
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p12226
aS'        stokes_matrix;'
p12227
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p12228
aS'                                  stokes_preconditioner_matrix;'
p12229
aS'      const PreconditionerTypeMp &mp_preconditioner;'
p12230
aS'      const PreconditionerTypeA & a_preconditioner;'
p12231
aS'      const bool                  do_solve_A;'
p12232
aS'    };'
p12233
aS'  } // namespace LinearSolvers'
p12234
aS'  namespace Assembly'
p12235
aS'  {'
p12236
aS'    namespace Scratch'
p12237
aS'    {'
p12238
aS'      template <int dim>'
p12239
aS'      struct StokesPreconditioner'
p12240
aS'      {'
p12241
aS'        StokesPreconditioner(const FiniteElement<dim> &stokes_fe,'
p12242
aS'                             const Quadrature<dim> &   stokes_quadrature,'
p12243
aS'                             const Mapping<dim> &      mapping,'
p12244
aS'                             const UpdateFlags         update_flags);'
p12245
aS'        StokesPreconditioner(const StokesPreconditioner &data);'
p12246
aS'        FEValues<dim> stokes_fe_values;'
p12247
aS'        std::vector<Tensor<2, dim>> grad_phi_u;'
p12248
aS'        std::vector<double>         phi_p;'
p12249
aS'      };'
p12250
aS'      template <int dim>'
p12251
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p12252
aS'        const FiniteElement<dim> &stokes_fe,'
p12253
aS'        const Quadrature<dim> &   stokes_quadrature,'
p12254
aS'        const Mapping<dim> &      mapping,'
p12255
aS'        const UpdateFlags         update_flags)'
p12256
aS'        : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags)'
p12257
aS'        , grad_phi_u(stokes_fe.n_dofs_per_cell())'
p12258
aS'        , phi_p(stokes_fe.n_dofs_per_cell())'
p12259
aS'      {}'
p12260
aS'      template <int dim>'
p12261
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p12262
aS'        const StokesPreconditioner &scratch)'
p12263
aS'        : stokes_fe_values(scratch.stokes_fe_values.get_mapping(),'
p12264
aS'                           scratch.stokes_fe_values.get_fe(),'
p12265
aS'                           scratch.stokes_fe_values.get_quadrature(),'
p12266
aS'                           scratch.stokes_fe_values.get_update_flags())'
p12267
aS'        , grad_phi_u(scratch.grad_phi_u)'
p12268
aS'        , phi_p(scratch.phi_p)'
p12269
aS'      {}'
p12270
aS'      template <int dim>'
p12271
aS'      struct StokesSystem : public StokesPreconditioner<dim>'
p12272
aS'      {'
p12273
aS'        StokesSystem(const FiniteElement<dim> &stokes_fe,'
p12274
aS'                     const Mapping<dim> &      mapping,'
p12275
aS'                     const Quadrature<dim> &   stokes_quadrature,'
p12276
aS'                     const UpdateFlags         stokes_update_flags,'
p12277
aS'                     const FiniteElement<dim> &temperature_fe,'
p12278
aS'                     const UpdateFlags         temperature_update_flags);'
p12279
aS'        StokesSystem(const StokesSystem<dim> &data);'
p12280
aS'        FEValues<dim> temperature_fe_values;'
p12281
aS'        std::vector<Tensor<1, dim>>          phi_u;'
p12282
aS'        std::vector<SymmetricTensor<2, dim>> grads_phi_u;'
p12283
aS'        std::vector<double>                  div_phi_u;'
p12284
aS'        std::vector<double> old_temperature_values;'
p12285
aS'      };'
p12286
aS'      template <int dim>'
p12287
aS'      StokesSystem<dim>::StokesSystem('
p12288
aS'        const FiniteElement<dim> &stokes_fe,'
p12289
aS'        const Mapping<dim> &      mapping,'
p12290
aS'        const Quadrature<dim> &   stokes_quadrature,'
p12291
aS'        const UpdateFlags         stokes_update_flags,'
p12292
aS'        const FiniteElement<dim> &temperature_fe,'
p12293
aS'        const UpdateFlags         temperature_update_flags)'
p12294
aS'        : StokesPreconditioner<dim>(stokes_fe,'
p12295
aS'                                    stokes_quadrature,'
p12296
aS'                                    mapping,'
p12297
aS'                                    stokes_update_flags)'
p12298
aS'        , temperature_fe_values(mapping,'
p12299
aS'                                temperature_fe,'
p12300
aS'                                stokes_quadrature,'
p12301
aS'                                temperature_update_flags)'
p12302
aS'        , phi_u(stokes_fe.n_dofs_per_cell())'
p12303
aS'        , grads_phi_u(stokes_fe.n_dofs_per_cell())'
p12304
aS'        , div_phi_u(stokes_fe.n_dofs_per_cell())'
p12305
aS'        , old_temperature_values(stokes_quadrature.size())'
p12306
aS'      {}'
p12307
aS'      template <int dim>'
p12308
aS'      StokesSystem<dim>::StokesSystem(const StokesSystem<dim> &scratch)'
p12309
aS'        : StokesPreconditioner<dim>(scratch)'
p12310
aS'        , temperature_fe_values('
p12311
aS'            scratch.temperature_fe_values.get_mapping(),'
p12312
aS'            scratch.temperature_fe_values.get_fe(),'
p12313
aS'            scratch.temperature_fe_values.get_quadrature(),'
p12314
aS'            scratch.temperature_fe_values.get_update_flags())'
p12315
aS'        , phi_u(scratch.phi_u)'
p12316
aS'        , grads_phi_u(scratch.grads_phi_u)'
p12317
aS'        , div_phi_u(scratch.div_phi_u)'
p12318
aS'        , old_temperature_values(scratch.old_temperature_values)'
p12319
aS'      {}'
p12320
aS'      template <int dim>'
p12321
aS'      struct TemperatureMatrix'
p12322
aS'      {'
p12323
aS'        TemperatureMatrix(const FiniteElement<dim> &temperature_fe,'
p12324
aS'                          const Mapping<dim> &      mapping,'
p12325
aS'                          const Quadrature<dim> &   temperature_quadrature);'
p12326
aS'        TemperatureMatrix(const TemperatureMatrix &data);'
p12327
aS'        FEValues<dim> temperature_fe_values;'
p12328
aS'        std::vector<double>         phi_T;'
p12329
aS'        std::vector<Tensor<1, dim>> grad_phi_T;'
p12330
aS'      };'
p12331
aS'      template <int dim>'
p12332
aS'      TemperatureMatrix<dim>::TemperatureMatrix('
p12333
aS'        const FiniteElement<dim> &temperature_fe,'
p12334
aS'        const Mapping<dim> &      mapping,'
p12335
aS'        const Quadrature<dim> &   temperature_quadrature)'
p12336
aS'        : temperature_fe_values(mapping,'
p12337
aS'                                temperature_fe,'
p12338
aS'                                temperature_quadrature,'
p12339
aS'                                update_values | update_gradients |'
p12340
aS'                                  update_JxW_values)'
p12341
aS'        , phi_T(temperature_fe.n_dofs_per_cell())'
p12342
aS'        , grad_phi_T(temperature_fe.n_dofs_per_cell())'
p12343
aS'      {}'
p12344
aS'      template <int dim>'
p12345
aS'      TemperatureMatrix<dim>::TemperatureMatrix('
p12346
aS'        const TemperatureMatrix &scratch)'
p12347
aS'        : temperature_fe_values('
p12348
aS'            scratch.temperature_fe_values.get_mapping(),'
p12349
aS'            scratch.temperature_fe_values.get_fe(),'
p12350
aS'            scratch.temperature_fe_values.get_quadrature(),'
p12351
aS'            scratch.temperature_fe_values.get_update_flags())'
p12352
aS'        , phi_T(scratch.phi_T)'
p12353
aS'        , grad_phi_T(scratch.grad_phi_T)'
p12354
aS'      {}'
p12355
aS'      template <int dim>'
p12356
aS'      struct TemperatureRHS'
p12357
aS'      {'
p12358
aS'        TemperatureRHS(const FiniteElement<dim> &temperature_fe,'
p12359
aS'                       const FiniteElement<dim> &stokes_fe,'
p12360
aS'                       const Mapping<dim> &      mapping,'
p12361
aS'                       const Quadrature<dim> &   quadrature);'
p12362
aS'        TemperatureRHS(const TemperatureRHS &data);'
p12363
aS'        FEValues<dim> temperature_fe_values;'
p12364
aS'        FEValues<dim> stokes_fe_values;'
p12365
aS'        std::vector<double>         phi_T;'
p12366
aS'        std::vector<Tensor<1, dim>> grad_phi_T;'
p12367
aS'        std::vector<Tensor<1, dim>> old_velocity_values;'
p12368
aS'        std::vector<Tensor<1, dim>> old_old_velocity_values;'
p12369
aS'        std::vector<SymmetricTensor<2, dim>> old_strain_rates;'
p12370
aS'        std::vector<SymmetricTensor<2, dim>> old_old_strain_rates;'
p12371
aS'        std::vector<double>         old_temperature_values;'
p12372
aS'        std::vector<double>         old_old_temperature_values;'
p12373
aS'        std::vector<Tensor<1, dim>> old_temperature_grads;'
p12374
aS'        std::vector<Tensor<1, dim>> old_old_temperature_grads;'
p12375
aS'        std::vector<double>         old_temperature_laplacians;'
p12376
aS'        std::vector<double>         old_old_temperature_laplacians;'
p12377
aS'      };'
p12378
aS'      template <int dim>'
p12379
aS'      TemperatureRHS<dim>::TemperatureRHS('
p12380
aS'        const FiniteElement<dim> &temperature_fe,'
p12381
aS'        const FiniteElement<dim> &stokes_fe,'
p12382
aS'        const Mapping<dim> &      mapping,'
p12383
aS'        const Quadrature<dim> &   quadrature)'
p12384
aS'        : temperature_fe_values(mapping,'
p12385
aS'                                temperature_fe,'
p12386
aS'                                quadrature,'
p12387
aS'                                update_values | update_gradients |'
p12388
aS'                                  update_hessians | update_quadrature_points |'
p12389
aS'                                  update_JxW_values)'
p12390
aS'        , stokes_fe_values(mapping,'
p12391
aS'                           stokes_fe,'
p12392
aS'                           quadrature,'
p12393
aS'                           update_values | update_gradients)'
p12394
aS'        , phi_T(temperature_fe.n_dofs_per_cell())'
p12395
aS'        , grad_phi_T(temperature_fe.n_dofs_per_cell())'
p12396
aS'        ,'
p12397
aS'        old_velocity_values(quadrature.size())'
p12398
aS'        , old_old_velocity_values(quadrature.size())'
p12399
aS'        , old_strain_rates(quadrature.size())'
p12400
aS'        , old_old_strain_rates(quadrature.size())'
p12401
aS'        ,'
p12402
aS'        old_temperature_values(quadrature.size())'
p12403
aS'        , old_old_temperature_values(quadrature.size())'
p12404
aS'        , old_temperature_grads(quadrature.size())'
p12405
aS'        , old_old_temperature_grads(quadrature.size())'
p12406
aS'        , old_temperature_laplacians(quadrature.size())'
p12407
aS'        , old_old_temperature_laplacians(quadrature.size())'
p12408
aS'      {}'
p12409
aS'      template <int dim>'
p12410
aS'      TemperatureRHS<dim>::TemperatureRHS(const TemperatureRHS &scratch)'
p12411
aS'        : temperature_fe_values('
p12412
aS'            scratch.temperature_fe_values.get_mapping(),'
p12413
aS'            scratch.temperature_fe_values.get_fe(),'
p12414
aS'            scratch.temperature_fe_values.get_quadrature(),'
p12415
aS'            scratch.temperature_fe_values.get_update_flags())'
p12416
aS'        , stokes_fe_values(scratch.stokes_fe_values.get_mapping(),'
p12417
aS'                           scratch.stokes_fe_values.get_fe(),'
p12418
aS'                           scratch.stokes_fe_values.get_quadrature(),'
p12419
aS'                           scratch.stokes_fe_values.get_update_flags())'
p12420
aS'        , phi_T(scratch.phi_T)'
p12421
aS'        , grad_phi_T(scratch.grad_phi_T)'
p12422
aS'        ,'
p12423
aS'        old_velocity_values(scratch.old_velocity_values)'
p12424
aS'        , old_old_velocity_values(scratch.old_old_velocity_values)'
p12425
aS'        , old_strain_rates(scratch.old_strain_rates)'
p12426
aS'        , old_old_strain_rates(scratch.old_old_strain_rates)'
p12427
aS'        ,'
p12428
aS'        old_temperature_values(scratch.old_temperature_values)'
p12429
aS'        , old_old_temperature_values(scratch.old_old_temperature_values)'
p12430
aS'        , old_temperature_grads(scratch.old_temperature_grads)'
p12431
aS'        , old_old_temperature_grads(scratch.old_old_temperature_grads)'
p12432
aS'        , old_temperature_laplacians(scratch.old_temperature_laplacians)'
p12433
aS'        , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians)'
p12434
aS'      {}'
p12435
aS'    } // namespace Scratch'
p12436
aS'    namespace CopyData'
p12437
aS'    {'
p12438
aS'      template <int dim>'
p12439
aS'      struct StokesPreconditioner'
p12440
aS'      {'
p12441
aS'        StokesPreconditioner(const FiniteElement<dim> &stokes_fe);'
p12442
aS'        StokesPreconditioner(const StokesPreconditioner &data);'
p12443
aS'        StokesPreconditioner &operator=(const StokesPreconditioner &) = default;'
p12444
aS'        FullMatrix<double>                   local_matrix;'
p12445
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p12446
aS'      };'
p12447
aS'      template <int dim>'
p12448
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p12449
aS'        const FiniteElement<dim> &stokes_fe)'
p12450
aS'        : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell())'
p12451
aS'        , local_dof_indices(stokes_fe.n_dofs_per_cell())'
p12452
aS'      {}'
p12453
aS'      template <int dim>'
p12454
aS'      StokesPreconditioner<dim>::StokesPreconditioner('
p12455
aS'        const StokesPreconditioner &data)'
p12456
aS'        : local_matrix(data.local_matrix)'
p12457
aS'        , local_dof_indices(data.local_dof_indices)'
p12458
aS'      {}'
p12459
aS'      template <int dim>'
p12460
aS'      struct StokesSystem : public StokesPreconditioner<dim>'
p12461
aS'      {'
p12462
aS'        StokesSystem(const FiniteElement<dim> &stokes_fe);'
p12463
aS'        Vector<double> local_rhs;'
p12464
aS'      };'
p12465
aS'      template <int dim>'
p12466
aS'      StokesSystem<dim>::StokesSystem(const FiniteElement<dim> &stokes_fe)'
p12467
aS'        : StokesPreconditioner<dim>(stokes_fe)'
p12468
aS'        , local_rhs(stokes_fe.n_dofs_per_cell())'
p12469
aS'      {}'
p12470
aS'      template <int dim>'
p12471
aS'      struct TemperatureMatrix'
p12472
aS'      {'
p12473
aS'        TemperatureMatrix(const FiniteElement<dim> &temperature_fe);'
p12474
aS'        FullMatrix<double>                   local_mass_matrix;'
p12475
aS'        FullMatrix<double>                   local_stiffness_matrix;'
p12476
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p12477
aS'      };'
p12478
aS'      template <int dim>'
p12479
aS'      TemperatureMatrix<dim>::TemperatureMatrix('
p12480
aS'        const FiniteElement<dim> &temperature_fe)'
p12481
aS'        : local_mass_matrix(temperature_fe.n_dofs_per_cell(),'
p12482
aS'                            temperature_fe.n_dofs_per_cell())'
p12483
aS'        , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(),'
p12484
aS'                                 temperature_fe.n_dofs_per_cell())'
p12485
aS'        , local_dof_indices(temperature_fe.n_dofs_per_cell())'
p12486
aS'      {}'
p12487
aS'      template <int dim>'
p12488
aS'      struct TemperatureRHS'
p12489
aS'      {'
p12490
aS'        TemperatureRHS(const FiniteElement<dim> &temperature_fe);'
p12491
aS'        Vector<double>                       local_rhs;'
p12492
aS'        std::vector<types::global_dof_index> local_dof_indices;'
p12493
aS'        FullMatrix<double>                   matrix_for_bc;'
p12494
aS'      };'
p12495
aS'      template <int dim>'
p12496
aS'      TemperatureRHS<dim>::TemperatureRHS('
p12497
aS'        const FiniteElement<dim> &temperature_fe)'
p12498
aS'        : local_rhs(temperature_fe.n_dofs_per_cell())'
p12499
aS'        , local_dof_indices(temperature_fe.n_dofs_per_cell())'
p12500
aS'        , matrix_for_bc(temperature_fe.n_dofs_per_cell(),'
p12501
aS'                        temperature_fe.n_dofs_per_cell())'
p12502
aS'      {}'
p12503
aS'    } // namespace CopyData'
p12504
aS'  }   // namespace Assembly'
p12505
aS'  template <int dim>'
p12506
aS'  class BoussinesqFlowProblem'
p12507
aS'  {'
p12508
aS'  public:'
p12509
aS'    struct Parameters;'
p12510
aS'    BoussinesqFlowProblem(Parameters &parameters);'
p12511
aS'    void run();'
p12512
aS'  private:'
p12513
aS'    void   setup_dofs();'
p12514
aS'    void   assemble_stokes_preconditioner();'
p12515
aS'    void   build_stokes_preconditioner();'
p12516
aS'    void   assemble_stokes_system();'
p12517
aS'    void   assemble_temperature_matrix();'
p12518
aS'    void   assemble_temperature_system(const double maximal_velocity);'
p12519
aS'    double get_maximal_velocity() const;'
p12520
aS'    double get_cfl_number() const;'
p12521
aS'    double get_entropy_variation(const double average_temperature) const;'
p12522
aS'    std::pair<double, double> get_extrapolated_temperature_range() const;'
p12523
aS'    void                      solve();'
p12524
aS'    void                      output_results();'
p12525
aS'    void                      refine_mesh(const unsigned int max_grid_level);'
p12526
aS'    double compute_viscosity('
p12527
aS'      const std::vector<double> &        old_temperature,'
p12528
aS'      const std::vector<double> &        old_old_temperature,'
p12529
aS'      const std::vector<Tensor<1, dim>> &old_temperature_grads,'
p12530
aS'      const std::vector<Tensor<1, dim>> &old_old_temperature_grads,'
p12531
aS'      const std::vector<double> &        old_temperature_laplacians,'
p12532
aS'      const std::vector<double> &        old_old_temperature_laplacians,'
p12533
aS'      const std::vector<Tensor<1, dim>> &old_velocity_values,'
p12534
aS'      const std::vector<Tensor<1, dim>> &old_old_velocity_values,'
p12535
aS'      const std::vector<SymmetricTensor<2, dim>> &old_strain_rates,'
p12536
aS'      const std::vector<SymmetricTensor<2, dim>> &old_old_strain_rates,'
p12537
aS'      const double                                global_u_infty,'
p12538
aS'      const double                                global_T_variation,'
p12539
aS'      const double                                average_temperature,'
p12540
aS'      const double                                global_entropy_variation,'
p12541
aS'      const double                                cell_diameter) const;'
p12542
aS'  public:'
p12543
aS'    struct Parameters'
p12544
aS'    {'
p12545
aS'      Parameters(const std::string &parameter_filename);'
p12546
aS'      static void declare_parameters(ParameterHandler &prm);'
p12547
aS'      void        parse_parameters(ParameterHandler &prm);'
p12548
aS'      double end_time;'
p12549
aS'      unsigned int initial_global_refinement;'
p12550
aS'      unsigned int initial_adaptive_refinement;'
p12551
aS'      bool         generate_graphical_output;'
p12552
aS'      unsigned int graphical_output_interval;'
p12553
aS'      unsigned int adaptive_refinement_interval;'
p12554
aS'      double stabilization_alpha;'
p12555
aS'      double stabilization_c_R;'
p12556
aS'      double stabilization_beta;'
p12557
aS'      unsigned int stokes_velocity_degree;'
p12558
aS'      bool         use_locally_conservative_discretization;'
p12559
aS'      unsigned int temperature_degree;'
p12560
aS'    };'
p12561
aS'  private:'
p12562
aS'    Parameters &parameters;'
p12563
aS'    ConditionalOStream pcout;'
p12564
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p12565
aS'    double                                    global_Omega_diameter;'
p12566
aS'    const MappingQ<dim> mapping;'
p12567
aS'    const FESystem<dim>       stokes_fe;'
p12568
aS'    DoFHandler<dim>           stokes_dof_handler;'
p12569
aS'    AffineConstraints<double> stokes_constraints;'
p12570
aS'    TrilinosWrappers::BlockSparseMatrix stokes_matrix;'
p12571
aS'    TrilinosWrappers::BlockSparseMatrix stokes_preconditioner_matrix;'
p12572
aS'    TrilinosWrappers::MPI::BlockVector stokes_solution;'
p12573
aS'    TrilinosWrappers::MPI::BlockVector old_stokes_solution;'
p12574
aS'    TrilinosWrappers::MPI::BlockVector stokes_rhs;'
p12575
aS'    FE_Q<dim>                 temperature_fe;'
p12576
aS'    DoFHandler<dim>           temperature_dof_handler;'
p12577
aS'    AffineConstraints<double> temperature_constraints;'
p12578
aS'    TrilinosWrappers::SparseMatrix temperature_mass_matrix;'
p12579
aS'    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;'
p12580
aS'    TrilinosWrappers::SparseMatrix temperature_matrix;'
p12581
aS'    TrilinosWrappers::MPI::Vector temperature_solution;'
p12582
aS'    TrilinosWrappers::MPI::Vector old_temperature_solution;'
p12583
aS'    TrilinosWrappers::MPI::Vector old_old_temperature_solution;'
p12584
aS'    TrilinosWrappers::MPI::Vector temperature_rhs;'
p12585
aS'    double       time_step;'
p12586
aS'    double       old_time_step;'
p12587
aS'    unsigned int timestep_number;'
p12588
aS'    std::shared_ptr<TrilinosWrappers::PreconditionAMG>    Amg_preconditioner;'
p12589
aS'    std::shared_ptr<TrilinosWrappers::PreconditionJacobi> Mp_preconditioner;'
p12590
aS'    std::shared_ptr<TrilinosWrappers::PreconditionJacobi> T_preconditioner;'
p12591
aS'    bool rebuild_stokes_matrix;'
p12592
aS'    bool rebuild_stokes_preconditioner;'
p12593
aS'    bool rebuild_temperature_matrices;'
p12594
aS'    bool rebuild_temperature_preconditioner;'
p12595
aS'    TimerOutput computing_timer;'
p12596
aS'    void setup_stokes_matrix('
p12597
aS'      const std::vector<IndexSet> &stokes_partitioning,'
p12598
aS'      const std::vector<IndexSet> &stokes_relevant_partitioning);'
p12599
aS'    void setup_stokes_preconditioner('
p12600
aS'      const std::vector<IndexSet> &stokes_partitioning,'
p12601
aS'      const std::vector<IndexSet> &stokes_relevant_partitioning);'
p12602
aS'    void setup_temperature_matrices('
p12603
aS'      const IndexSet &temperature_partitioning,'
p12604
aS'      const IndexSet &temperature_relevant_partitioning);'
p12605
aS'    void local_assemble_stokes_preconditioner('
p12606
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p12607
aS'      Assembly::Scratch::StokesPreconditioner<dim> &        scratch,'
p12608
aS'      Assembly::CopyData::StokesPreconditioner<dim> &       data);'
p12609
aS'    void copy_local_to_global_stokes_preconditioner('
p12610
aS'      const Assembly::CopyData::StokesPreconditioner<dim> &data);'
p12611
aS'    void local_assemble_stokes_system('
p12612
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p12613
aS'      Assembly::Scratch::StokesSystem<dim> &                scratch,'
p12614
aS'      Assembly::CopyData::StokesSystem<dim> &               data);'
p12615
aS'    void copy_local_to_global_stokes_system('
p12616
aS'      const Assembly::CopyData::StokesSystem<dim> &data);'
p12617
aS'    void local_assemble_temperature_matrix('
p12618
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p12619
aS'      Assembly::Scratch::TemperatureMatrix<dim> &           scratch,'
p12620
aS'      Assembly::CopyData::TemperatureMatrix<dim> &          data);'
p12621
aS'    void copy_local_to_global_temperature_matrix('
p12622
aS'      const Assembly::CopyData::TemperatureMatrix<dim> &data);'
p12623
aS'    void local_assemble_temperature_rhs('
p12624
aS'      const std::pair<double, double> global_T_range,'
p12625
aS'      const double                    global_max_velocity,'
p12626
aS'      const double                    global_entropy_variation,'
p12627
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p12628
aS'      Assembly::Scratch::TemperatureRHS<dim> &              scratch,'
p12629
aS'      Assembly::CopyData::TemperatureRHS<dim> &             data);'
p12630
aS'    void copy_local_to_global_temperature_rhs('
p12631
aS'      const Assembly::CopyData::TemperatureRHS<dim> &data);'
p12632
aS'    class Postprocessor;'
p12633
aS'  };'
p12634
aS'  template <int dim>'
p12635
aS'  BoussinesqFlowProblem<dim>::Parameters::Parameters('
p12636
aS'    const std::string &parameter_filename)'
p12637
aS'    : end_time(1e8)'
p12638
aS'    , initial_global_refinement(2)'
p12639
aS'    , initial_adaptive_refinement(2)'
p12640
aS'    , adaptive_refinement_interval(10)'
p12641
aS'    , stabilization_alpha(2)'
p12642
aS'    , stabilization_c_R(0.11)'
p12643
aS'    , stabilization_beta(0.078)'
p12644
aS'    , stokes_velocity_degree(2)'
p12645
aS'    , use_locally_conservative_discretization(true)'
p12646
aS'    , temperature_degree(2)'
p12647
aS'  {'
p12648
aS'    ParameterHandler prm;'
p12649
aS'    BoussinesqFlowProblem<dim>::Parameters::declare_parameters(prm);'
p12650
aS'    std::ifstream parameter_file(parameter_filename);'
p12651
aS'    if (!parameter_file)'
p12652
aS'      {'
p12653
aS'        parameter_file.close();'
p12654
aS'        std::ofstream parameter_out(parameter_filename);'
p12655
aS'        prm.print_parameters(parameter_out, ParameterHandler::Text);'
p12656
aS'        AssertThrow('
p12657
aS'          false,'
p12658
aS'          ExcMessage('
p12659
aS'            "Input parameter file <" + parameter_filename +'
p12660
aS'            "> not found. Creating a template file of the same name."));'
p12661
aS'      }'
p12662
aS'    prm.parse_input(parameter_file);'
p12663
aS'    parse_parameters(prm);'
p12664
aS'  }'
p12665
aS'  template <int dim>'
p12666
aS'  void BoussinesqFlowProblem<dim>::Parameters::declare_parameters('
p12667
aS'    ParameterHandler &prm)'
p12668
aS'  {'
p12669
aS'    prm.declare_entry("End time",'
p12670
aS'                      "1e8",'
p12671
aS'                      Patterns::Double(0),'
p12672
aS'                      "The end time of the simulation in years.");'
p12673
aS'    prm.declare_entry("Initial global refinement",'
p12674
aS'                      "2",'
p12675
aS'                      Patterns::Integer(0),'
p12676
aS'                      "The number of global refinement steps performed on "'
p12677
aS'                      "the initial coarse mesh, before the problem is first "'
p12678
aS'                      "solved there.");'
p12679
aS'    prm.declare_entry("Initial adaptive refinement",'
p12680
aS'                      "2",'
p12681
aS'                      Patterns::Integer(0),'
p12682
aS'                      "The number of adaptive refinement steps performed after "'
p12683
aS'                      "initial global refinement.");'
p12684
aS'    prm.declare_entry("Time steps between mesh refinement",'
p12685
aS'                      "10",'
p12686
aS'                      Patterns::Integer(1),'
p12687
aS'                      "The number of time steps after which the mesh is to be "'
p12688
aS'                      "adapted based on computed error indicators.");'
p12689
aS'    prm.declare_entry("Generate graphical output",'
p12690
aS'                      "false",'
p12691
aS'                      Patterns::Bool(),'
p12692
aS'                      "Whether graphical output is to be generated or not. "'
p12693
aS'                      "You may not want to get graphical output if the number "'
p12694
aS'                      "of processors is large.");'
p12695
aS'    prm.declare_entry("Time steps between graphical output",'
p12696
aS'                      "50",'
p12697
aS'                      Patterns::Integer(1),'
p12698
aS'                      "The number of time steps between each generation of "'
p12699
aS'                      "graphical output files.");'
p12700
aS'    prm.enter_subsection("Stabilization parameters");'
p12701
aS'    {'
p12702
aS'      prm.declare_entry("alpha",'
p12703
aS'                        "2",'
p12704
aS'                        Patterns::Double(1, 2),'
p12705
aS'                        "The exponent in the entropy viscosity stabilization.");'
p12706
aS'      prm.declare_entry("c_R",'
p12707
aS'                        "0.11",'
p12708
aS'                        Patterns::Double(0),'
p12709
aS'                        "The c_R factor in the entropy viscosity "'
p12710
aS'                        "stabilization.");'
p12711
aS'      prm.declare_entry("beta",'
p12712
aS'                        "0.078",'
p12713
aS'                        Patterns::Double(0),'
p12714
aS'                        "The beta factor in the artificial viscosity "'
p12715
aS'                        "stabilization. An appropriate value for 2d is 0.052 "'
p12716
aS'                        "and 0.078 for 3d.");'
p12717
aS'    }'
p12718
aS'    prm.leave_subsection();'
p12719
aS'    prm.enter_subsection("Discretization");'
p12720
aS'    {'
p12721
aS'      prm.declare_entry('
p12722
aS'        "Stokes velocity polynomial degree",'
p12723
aS'        "2",'
p12724
aS'        Patterns::Integer(1),'
p12725
aS'        "The polynomial degree to use for the velocity variables "'
p12726
aS'        "in the Stokes system.");'
p12727
aS'      prm.declare_entry('
p12728
aS'        "Temperature polynomial degree",'
p12729
aS'        "2",'
p12730
aS'        Patterns::Integer(1),'
p12731
aS'        "The polynomial degree to use for the temperature variable.");'
p12732
aS'      prm.declare_entry('
p12733
aS'        "Use locally conservative discretization",'
p12734
aS'        "true",'
p12735
aS'        Patterns::Bool(),'
p12736
aS'        "Whether to use a Stokes discretization that is locally "'
p12737
aS'        "conservative at the expense of a larger number of degrees "'
p12738
aS'        "of freedom, or to go with a cheaper discretization "'
p12739
aS'        "that does not locally conserve mass (although it is "'
p12740
aS'        "globally conservative.");'
p12741
aS'    }'
p12742
aS'    prm.leave_subsection();'
p12743
aS'  }'
p12744
aS'  template <int dim>'
p12745
aS'  void BoussinesqFlowProblem<dim>::Parameters::parse_parameters('
p12746
aS'    ParameterHandler &prm)'
p12747
aS'  {'
p12748
aS'    end_time                  = prm.get_double("End time");'
p12749
aS'    initial_global_refinement = prm.get_integer("Initial global refinement");'
p12750
aS'    initial_adaptive_refinement ='
p12751
aS'      prm.get_integer("Initial adaptive refinement");'
p12752
aS'    adaptive_refinement_interval ='
p12753
aS'      prm.get_integer("Time steps between mesh refinement");'
p12754
aS'    generate_graphical_output = prm.get_bool("Generate graphical output");'
p12755
aS'    graphical_output_interval ='
p12756
aS'      prm.get_integer("Time steps between graphical output");'
p12757
aS'    prm.enter_subsection("Stabilization parameters");'
p12758
aS'    {'
p12759
aS'      stabilization_alpha = prm.get_double("alpha");'
p12760
aS'      stabilization_c_R   = prm.get_double("c_R");'
p12761
aS'      stabilization_beta  = prm.get_double("beta");'
p12762
aS'    }'
p12763
aS'    prm.leave_subsection();'
p12764
aS'    prm.enter_subsection("Discretization");'
p12765
aS'    {'
p12766
aS'      stokes_velocity_degree ='
p12767
aS'        prm.get_integer("Stokes velocity polynomial degree");'
p12768
aS'      temperature_degree = prm.get_integer("Temperature polynomial degree");'
p12769
aS'      use_locally_conservative_discretization ='
p12770
aS'        prm.get_bool("Use locally conservative discretization");'
p12771
aS'    }'
p12772
aS'    prm.leave_subsection();'
p12773
aS'  }'
p12774
aS'  template <int dim>'
p12775
aS'  BoussinesqFlowProblem<dim>::BoussinesqFlowProblem(Parameters &parameters_)'
p12776
aS'    : parameters(parameters_)'
p12777
aS'    , pcout(std::cout, (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0))'
p12778
aS'    ,'
p12779
aS'    triangulation(MPI_COMM_WORLD,'
p12780
aS'                  typename Triangulation<dim>::MeshSmoothing('
p12781
aS'                    Triangulation<dim>::smoothing_on_refinement |'
p12782
aS'                    Triangulation<dim>::smoothing_on_coarsening))'
p12783
aS'    ,'
p12784
aS'    global_Omega_diameter(0.)'
p12785
aS'    ,'
p12786
aS'    mapping(4)'
p12787
aS'    ,'
p12788
aS'    stokes_fe(FE_Q<dim>(parameters.stokes_velocity_degree),'
p12789
aS'              dim,'
p12790
aS'                 static_cast<const FiniteElement<dim> &>('
p12791
aS'                   FE_DGP<dim>(parameters.stokes_velocity_degree - 1)) :'
p12792
aS'                 static_cast<const FiniteElement<dim> &>('
p12793
aS'                   FE_Q<dim>(parameters.stokes_velocity_degree - 1))),'
p12794
aS'              1)'
p12795
aS'    ,'
p12796
aS'    stokes_dof_handler(triangulation)'
p12797
aS'    ,'
p12798
aS'    temperature_fe(parameters.temperature_degree)'
p12799
aS'    , temperature_dof_handler(triangulation)'
p12800
aS'    ,'
p12801
aS'    time_step(0)'
p12802
aS'    , old_time_step(0)'
p12803
aS'    , timestep_number(0)'
p12804
aS'    , rebuild_stokes_matrix(true)'
p12805
aS'    , rebuild_stokes_preconditioner(true)'
p12806
aS'    , rebuild_temperature_matrices(true)'
p12807
aS'    , rebuild_temperature_preconditioner(true)'
p12808
aS'    ,'
p12809
aS'    computing_timer(MPI_COMM_WORLD,'
p12810
aS'                    pcout,'
p12811
aS'                    TimerOutput::summary,'
p12812
aS'                    TimerOutput::wall_times)'
p12813
aS'  {}'
p12814
aS'  template <int dim>'
p12815
aS'  double BoussinesqFlowProblem<dim>::get_maximal_velocity() const'
p12816
aS'  {'
p12817
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p12818
aS'                                            parameters.stokes_velocity_degree);'
p12819
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p12820
aS'    FEValues<dim>               fe_values(mapping,'
p12821
aS'                            stokes_fe,'
p12822
aS'                            quadrature_formula,'
p12823
aS'                            update_values);'
p12824
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points);'
p12825
aS'    const FEValuesExtractors::Vector velocities(0);'
p12826
aS'    double max_local_velocity = 0;'
p12827
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p12828
aS'      if (cell->is_locally_owned())'
p12829
aS'        {'
p12830
aS'          fe_values.reinit(cell);'
p12831
aS'          fe_values[velocities].get_function_values(stokes_solution,'
p12832
aS'                                                    velocity_values);'
p12833
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p12834
aS'            max_local_velocity ='
p12835
aS'              std::max(max_local_velocity, velocity_values[q].norm());'
p12836
aS'        }'
p12837
aS'    return Utilities::MPI::max(max_local_velocity, MPI_COMM_WORLD);'
p12838
aS'  }'
p12839
aS'  template <int dim>'
p12840
aS'  double BoussinesqFlowProblem<dim>::get_cfl_number() const'
p12841
aS'  {'
p12842
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p12843
aS'                                            parameters.stokes_velocity_degree);'
p12844
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p12845
aS'    FEValues<dim>               fe_values(mapping,'
p12846
aS'                            stokes_fe,'
p12847
aS'                            quadrature_formula,'
p12848
aS'                            update_values);'
p12849
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points);'
p12850
aS'    const FEValuesExtractors::Vector velocities(0);'
p12851
aS'    double max_local_cfl = 0;'
p12852
aS'    for (const auto &cell : stokes_dof_handler.active_cell_iterators())'
p12853
aS'      if (cell->is_locally_owned())'
p12854
aS'        {'
p12855
aS'          fe_values.reinit(cell);'
p12856
aS'          fe_values[velocities].get_function_values(stokes_solution,'
p12857
aS'                                                    velocity_values);'
p12858
aS'          double max_local_velocity = 1e-10;'
p12859
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p12860
aS'            max_local_velocity ='
p12861
aS'              std::max(max_local_velocity, velocity_values[q].norm());'
p12862
aS'          max_local_cfl ='
p12863
aS'            std::max(max_local_cfl, max_local_velocity / cell->diameter());'
p12864
aS'        }'
p12865
aS'    return Utilities::MPI::max(max_local_cfl, MPI_COMM_WORLD);'
p12866
aS'  }'
p12867
aS'  template <int dim>'
p12868
aS'  double BoussinesqFlowProblem<dim>::get_entropy_variation('
p12869
aS'    const double average_temperature) const'
p12870
aS'  {'
p12871
aS'    if (parameters.stabilization_alpha != 2)'
p12872
aS'      return 1.;'
p12873
aS'    const QGauss<dim>  quadrature_formula(parameters.temperature_degree + 1);'
p12874
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p12875
aS'    FEValues<dim>       fe_values(temperature_fe,'
p12876
aS'                            quadrature_formula,'
p12877
aS'                            update_values | update_JxW_values);'
p12878
aS'    std::vector<double> old_temperature_values(n_q_points);'
p12879
aS'    std::vector<double> old_old_temperature_values(n_q_points);'
p12880
aS'    double min_entropy = std::numeric_limits<double>::max(),'
p12881
aS'           max_entropy = -std::numeric_limits<double>::max(), area = 0,'
p12882
aS'           entropy_integrated = 0;'
p12883
aS'    for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p12884
aS'      if (cell->is_locally_owned())'
p12885
aS'        {'
p12886
aS'          fe_values.reinit(cell);'
p12887
aS'          fe_values.get_function_values(old_temperature_solution,'
p12888
aS'                                        old_temperature_values);'
p12889
aS'          fe_values.get_function_values(old_old_temperature_solution,'
p12890
aS'                                        old_old_temperature_values);'
p12891
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p12892
aS'            {'
p12893
aS'              const double T ='
p12894
aS'              const double entropy ='
p12895
aS'              min_entropy = std::min(min_entropy, entropy);'
p12896
aS'              max_entropy = std::max(max_entropy, entropy);'
p12897
aS'              area += fe_values.JxW(q);'
p12898
aS'              entropy_integrated += fe_values.JxW(q) * entropy;'
p12899
aS'            }'
p12900
aS'        }'
p12901
aS'    const double local_sums[2]   = {entropy_integrated, area},'
p12902
aS'                 local_maxima[2] = {-min_entropy, max_entropy};'
p12903
aS'    double global_sums[2], global_maxima[2];'
p12904
aS'    Utilities::MPI::sum(local_sums, MPI_COMM_WORLD, global_sums);'
p12905
aS'    Utilities::MPI::max(local_maxima, MPI_COMM_WORLD, global_maxima);'
p12906
aS'    const double average_entropy = global_sums[0] / global_sums[1];'
p12907
aS'    const double entropy_diff    = std::max(global_maxima[1] - average_entropy,'
p12908
aS'                                         average_entropy - (-global_maxima[0]));'
p12909
aS'    return entropy_diff;'
p12910
aS'  }'
p12911
aS'  template <int dim>'
p12912
aS'  std::pair<double, double>'
p12913
aS'  BoussinesqFlowProblem<dim>::get_extrapolated_temperature_range() const'
p12914
aS'  {'
p12915
aS'    const QIterated<dim> quadrature_formula(QTrapezoid<1>(),'
p12916
aS'                                            parameters.temperature_degree);'
p12917
aS'    const unsigned int   n_q_points = quadrature_formula.size();'
p12918
aS'    FEValues<dim>       fe_values(mapping,'
p12919
aS'                            temperature_fe,'
p12920
aS'                            quadrature_formula,'
p12921
aS'                            update_values);'
p12922
aS'    std::vector<double> old_temperature_values(n_q_points);'
p12923
aS'    std::vector<double> old_old_temperature_values(n_q_points);'
p12924
aS'    double min_local_temperature = std::numeric_limits<double>::max(),'
p12925
aS'           max_local_temperature = -std::numeric_limits<double>::max();'
p12926
aS'    if (timestep_number != 0)'
p12927
aS'      {'
p12928
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p12929
aS'          if (cell->is_locally_owned())'
p12930
aS'            {'
p12931
aS'              fe_values.reinit(cell);'
p12932
aS'              fe_values.get_function_values(old_temperature_solution,'
p12933
aS'                                            old_temperature_values);'
p12934
aS'              fe_values.get_function_values(old_old_temperature_solution,'
p12935
aS'                                            old_old_temperature_values);'
p12936
aS'              for (unsigned int q = 0; q < n_q_points; ++q)'
p12937
aS'                {'
p12938
aS'                  const double temperature ='
p12939
aS'                      old_temperature_values[q] -'
p12940
aS'                    time_step / old_time_step * old_old_temperature_values[q];'
p12941
aS'                  min_local_temperature ='
p12942
aS'                    std::min(min_local_temperature, temperature);'
p12943
aS'                  max_local_temperature ='
p12944
aS'                    std::max(max_local_temperature, temperature);'
p12945
aS'                }'
p12946
aS'            }'
p12947
aS'      }'
p12948
aS'    else'
p12949
aS'      {'
p12950
aS'        for (const auto &cell : temperature_dof_handler.active_cell_iterators())'
p12951
aS'          if (cell->is_locally_owned())'
p12952
aS'            {'
p12953
aS'              fe_values.reinit(cell);'
p12954
aS'              fe_values.get_function_values(old_temperature_solution,'
p12955
aS'                                            old_temperature_values);'
p12956
aS'              for (unsigned int q = 0; q < n_q_points; ++q)'
p12957
aS'                {'
p12958
aS'                  const double temperature = old_temperature_values[q];'
p12959
aS'                  min_local_temperature ='
p12960
aS'                    std::min(min_local_temperature, temperature);'
p12961
aS'                  max_local_temperature ='
p12962
aS'                    std::max(max_local_temperature, temperature);'
p12963
aS'                }'
p12964
aS'            }'
p12965
aS'      }'
p12966
aS'    double local_extrema[2] = {-min_local_temperature, max_local_temperature};'
p12967
aS'    double global_extrema[2];'
p12968
aS'    Utilities::MPI::max(local_extrema, MPI_COMM_WORLD, global_extrema);'
p12969
aS'    return std::make_pair(-global_extrema[0], global_extrema[1]);'
p12970
aS'  }'
p12971
aS'  template <int dim>'
p12972
aS'  double BoussinesqFlowProblem<dim>::compute_viscosity('
p12973
aS'    const std::vector<double> &                 old_temperature,'
p12974
aS'    const std::vector<double> &                 old_old_temperature,'
p12975
aS'    const std::vector<Tensor<1, dim>> &         old_temperature_grads,'
p12976
aS'    const std::vector<Tensor<1, dim>> &         old_old_temperature_grads,'
p12977
aS'    const std::vector<double> &                 old_temperature_laplacians,'
p12978
aS'    const std::vector<double> &                 old_old_temperature_laplacians,'
p12979
aS'    const std::vector<Tensor<1, dim>> &         old_velocity_values,'
p12980
aS'    const std::vector<Tensor<1, dim>> &         old_old_velocity_values,'
p12981
aS'    const std::vector<SymmetricTensor<2, dim>> &old_strain_rates,'
p12982
aS'    const std::vector<SymmetricTensor<2, dim>> &old_old_strain_rates,'
p12983
aS'    const double                                global_u_infty,'
p12984
aS'    const double                                global_T_variation,'
p12985
aS'    const double                                average_temperature,'
p12986
aS'    const double                                global_entropy_variation,'
p12987
aS'    const double                                cell_diameter) const'
p12988
aS'  {'
p12989
aS'    if (global_u_infty == 0)'
p12990
aS'      return 5e-3 * cell_diameter;'
p12991
aS'    const unsigned int n_q_points = old_temperature.size();'
p12992
aS'    double max_residual = 0;'
p12993
aS'    double max_velocity = 0;'
p12994
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p12995
aS'      {'
p12996
aS'        const Tensor<1, dim> u ='
p12997
aS'        const SymmetricTensor<2, dim> strain_rate ='
p12998
aS'        const double T = (old_temperature[q] + old_old_temperature[q]) / 2;'
p12999
aS'        const double dT_dt ='
p13000
aS'        const double u_grad_T ='
p13001
aS'          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;'
p13002
aS'        const double kappa_Delta_T ='
p13003
aS'          EquationData::kappa *'
p13004
aS'          2;'
p13005
aS'        const double gamma ='
p13006
aS'            2 * EquationData::eta * strain_rate * strain_rate) /'
p13007
aS'        double residual = std::abs(dT_dt + u_grad_T - kappa_Delta_T - gamma);'
p13008
aS'        if (parameters.stabilization_alpha == 2)'
p13009
aS'          residual *= std::abs(T - average_temperature);'
p13010
aS'        max_residual = std::max(residual, max_residual);'
p13011
aS'        max_velocity = std::max(std::sqrt(u * u), max_velocity);'
p13012
aS'      }'
p13013
aS'    const double max_viscosity ='
p13014
aS'    if (timestep_number == 0)'
p13015
aS'      return max_viscosity;'
p13016
aS'    else'
p13017
aS'      {'
p13018
aS'        Assert(old_time_step > 0, ExcInternalError());'
p13019
aS'        double entropy_viscosity;'
p13020
aS'        if (parameters.stabilization_alpha == 2)'
p13021
aS'          entropy_viscosity ='
p13022
aS'             max_residual / global_entropy_variation);'
p13023
aS'        else'
p13024
aS'          entropy_viscosity ='
p13025
aS'             global_Omega_diameter * max_velocity * max_residual /'
p13026
aS'        return std::min(max_viscosity, entropy_viscosity);'
p13027
aS'      }'
p13028
aS'  }'
p13029
aS'  template <int dim>'
p13030
aS'  void BoussinesqFlowProblem<dim>::setup_stokes_matrix('
p13031
aS'    const std::vector<IndexSet> &stokes_partitioning,'
p13032
aS'    const std::vector<IndexSet> &stokes_relevant_partitioning)'
p13033
aS'  {'
p13034
aS'    stokes_matrix.clear();'
p13035
aS'    TrilinosWrappers::BlockSparsityPattern sp(stokes_partitioning,'
p13036
aS'                                              stokes_partitioning,'
p13037
aS'                                              stokes_relevant_partitioning,'
p13038
aS'                                              MPI_COMM_WORLD);'
p13039
aS'    Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p13040
aS'    for (unsigned int c = 0; c < dim + 1; ++c)'
p13041
aS'      for (unsigned int d = 0; d < dim + 1; ++d)'
p13042
aS'        if (!((c == dim) && (d == dim)))'
p13043
aS'          coupling[c][d] = DoFTools::always;'
p13044
aS'        else'
p13045
aS'          coupling[c][d] = DoFTools::none;'
p13046
aS'    DoFTools::make_sparsity_pattern(stokes_dof_handler,'
p13047
aS'                                    coupling,'
p13048
aS'                                    sp,'
p13049
aS'                                    stokes_constraints,'
p13050
aS'                                    false,'
p13051
aS'                                    Utilities::MPI::this_mpi_process('
p13052
aS'                                      MPI_COMM_WORLD));'
p13053
aS'    sp.compress();'
p13054
aS'    stokes_matrix.reinit(sp);'
p13055
aS'  }'
p13056
aS'  template <int dim>'
p13057
aS'  void BoussinesqFlowProblem<dim>::setup_stokes_preconditioner('
p13058
aS'    const std::vector<IndexSet> &stokes_partitioning,'
p13059
aS'    const std::vector<IndexSet> &stokes_relevant_partitioning)'
p13060
aS'  {'
p13061
aS'    Amg_preconditioner.reset();'
p13062
aS'    Mp_preconditioner.reset();'
p13063
aS'    stokes_preconditioner_matrix.clear();'
p13064
aS'    TrilinosWrappers::BlockSparsityPattern sp(stokes_partitioning,'
p13065
aS'                                              stokes_partitioning,'
p13066
aS'                                              stokes_relevant_partitioning,'
p13067
aS'                                              MPI_COMM_WORLD);'
p13068
aS'    Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p13069
aS'    for (unsigned int c = 0; c < dim + 1; ++c)'
p13070
aS'      for (unsigned int d = 0; d < dim + 1; ++d)'
p13071
aS'        if (c == d)'
p13072
aS'          coupling[c][d] = DoFTools::always;'
p13073
aS'        else'
p13074
aS'          coupling[c][d] = DoFTools::none;'
p13075
aS'    DoFTools::make_sparsity_pattern(stokes_dof_handler,'
p13076
aS'                                    coupling,'
p13077
aS'                                    sp,'
p13078
aS'                                    stokes_constraints,'
p13079
aS'                                    false,'
p13080
aS'                                    Utilities::MPI::this_mpi_process('
p13081
aS'                                      MPI_COMM_WORLD));'
p13082
aS'    sp.compress();'
p13083
aS'    stokes_preconditioner_matrix.reinit(sp);'
p13084
aS'  }'
p13085
aS'  template <int dim>'
p13086
aS'  void BoussinesqFlowProblem<dim>::setup_temperature_matrices('
p13087
aS'    const IndexSet &temperature_partitioner,'
p13088
aS'    const IndexSet &temperature_relevant_partitioner)'
p13089
aS'  {'
p13090
aS'    T_preconditioner.reset();'
p13091
aS'    temperature_mass_matrix.clear();'
p13092
aS'    temperature_stiffness_matrix.clear();'
p13093
aS'    temperature_matrix.clear();'
p13094
aS'    TrilinosWrappers::SparsityPattern sp(temperature_partitioner,'
p13095
aS'                                         temperature_partitioner,'
p13096
aS'                                         temperature_relevant_partitioner,'
p13097
aS'                                         MPI_COMM_WORLD);'
p13098
aS'    DoFTools::make_sparsity_pattern(temperature_dof_handler,'
p13099
aS'                                    sp,'
p13100
aS'                                    temperature_constraints,'
p13101
aS'                                    false,'
p13102
aS'                                    Utilities::MPI::this_mpi_process('
p13103
aS'                                      MPI_COMM_WORLD));'
p13104
aS'    sp.compress();'
p13105
aS'    temperature_matrix.reinit(sp);'
p13106
aS'    temperature_mass_matrix.reinit(sp);'
p13107
aS'    temperature_stiffness_matrix.reinit(sp);'
p13108
aS'  }'
p13109
aS'  template <int dim>'
p13110
aS'  void BoussinesqFlowProblem<dim>::setup_dofs()'
p13111
aS'  {'
p13112
aS'    TimerOutput::Scope timing_section(computing_timer, "Setup dof systems");'
p13113
aS'    stokes_dof_handler.distribute_dofs(stokes_fe);'
p13114
aS'    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0);'
p13115
aS'    stokes_sub_blocks[dim] = 1;'
p13116
aS'    DoFRenumbering::component_wise(stokes_dof_handler, stokes_sub_blocks);'
p13117
aS'    temperature_dof_handler.distribute_dofs(temperature_fe);'
p13118
aS'    const std::vector<types::global_dof_index> stokes_dofs_per_block ='
p13119
aS'      DoFTools::count_dofs_per_fe_block(stokes_dof_handler, stokes_sub_blocks);'
p13120
aS'    const unsigned int n_u = stokes_dofs_per_block[0],'
p13121
aS'                       n_p = stokes_dofs_per_block[1],'
p13122
aS'                       n_T = temperature_dof_handler.n_dofs();'
p13123
aS'    std::locale s = pcout.get_stream().getloc();'
p13124
aS'    pcout.get_stream().imbue(std::locale(""));'
p13125
aS'    pcout << "Number of active cells: " << triangulation.n_global_active_cells()'
p13126
aS'          << " (on " << triangulation.n_levels() << " levels)" << std::endl'
p13127
aS'          << "Number of degrees of freedom: " << n_u + n_p + n_T << " (" << n_u'
p13128
aS"          << '+' << n_p << '+' << n_T << ')' << std::endl"
p13129
aS'          << std::endl;'
p13130
aS'    pcout.get_stream().imbue(s);'
p13131
aS'    std::vector<IndexSet> stokes_partitioning, stokes_relevant_partitioning;'
p13132
aS'    IndexSet              temperature_partitioning(n_T),'
p13133
aS'      temperature_relevant_partitioning(n_T);'
p13134
aS'    IndexSet stokes_relevant_set;'
p13135
aS'    {'
p13136
aS'      IndexSet stokes_index_set = stokes_dof_handler.locally_owned_dofs();'
p13137
aS'      stokes_partitioning.push_back(stokes_index_set.get_view(0, n_u));'
p13138
aS'      stokes_partitioning.push_back(stokes_index_set.get_view(n_u, n_u + n_p));'
p13139
aS'      DoFTools::extract_locally_relevant_dofs(stokes_dof_handler,'
p13140
aS'                                              stokes_relevant_set);'
p13141
aS'      stokes_relevant_partitioning.push_back('
p13142
aS'        stokes_relevant_set.get_view(0, n_u));'
p13143
aS'      stokes_relevant_partitioning.push_back('
p13144
aS'        stokes_relevant_set.get_view(n_u, n_u + n_p));'
p13145
aS'      temperature_partitioning = temperature_dof_handler.locally_owned_dofs();'
p13146
aS'      DoFTools::extract_locally_relevant_dofs('
p13147
aS'        temperature_dof_handler, temperature_relevant_partitioning);'
p13148
aS'    }'
p13149
aS'    {'
p13150
aS'      stokes_constraints.clear();'
p13151
aS'      stokes_constraints.reinit(stokes_relevant_set);'
p13152
aS'      DoFTools::make_hanging_node_constraints(stokes_dof_handler,'
p13153
aS'                                              stokes_constraints);'
p13154
aS'      FEValuesExtractors::Vector velocity_components(0);'
p13155
aS'      VectorTools::interpolate_boundary_values('
p13156
aS'        stokes_dof_handler,'
p13157
aS'        0,'
p13158
aS'        Functions::ZeroFunction<dim>(dim + 1),'
p13159
aS'        stokes_constraints,'
p13160
aS'        stokes_fe.component_mask(velocity_components));'
p13161
aS'      std::set<types::boundary_id> no_normal_flux_boundaries;'
p13162
aS'      no_normal_flux_boundaries.insert(1);'
p13163
aS'      VectorTools::compute_no_normal_flux_constraints(stokes_dof_handler,'
p13164
aS'                                                      0,'
p13165
aS'                                                      no_normal_flux_boundaries,'
p13166
aS'                                                      stokes_constraints,'
p13167
aS'                                                      mapping);'
p13168
aS'      stokes_constraints.close();'
p13169
aS'    }'
p13170
aS'    {'
p13171
aS'      temperature_constraints.clear();'
p13172
aS'      temperature_constraints.reinit(temperature_relevant_partitioning);'
p13173
aS'      DoFTools::make_hanging_node_constraints(temperature_dof_handler,'
p13174
aS'                                              temperature_constraints);'
p13175
aS'      VectorTools::interpolate_boundary_values('
p13176
aS'        temperature_dof_handler,'
p13177
aS'        0,'
p13178
aS'        EquationData::TemperatureInitialValues<dim>(),'
p13179
aS'        temperature_constraints);'
p13180
aS'      VectorTools::interpolate_boundary_values('
p13181
aS'        temperature_dof_handler,'
p13182
aS'        1,'
p13183
aS'        EquationData::TemperatureInitialValues<dim>(),'
p13184
aS'        temperature_constraints);'
p13185
aS'      temperature_constraints.close();'
p13186
aS'    }'
p13187
aS'    setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning);'
p13188
aS'    setup_stokes_preconditioner(stokes_partitioning,'
p13189
aS'                                stokes_relevant_partitioning);'
p13190
aS'    setup_temperature_matrices(temperature_partitioning,'
p13191
aS'                               temperature_relevant_partitioning);'
p13192
aS'    stokes_rhs.reinit(stokes_partitioning,'
p13193
aS'                      stokes_relevant_partitioning,'
p13194
aS'                      MPI_COMM_WORLD,'
p13195
aS'                      true);'
p13196
aS'    stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD);'
p13197
aS'    old_stokes_solution.reinit(stokes_solution);'
p13198
aS'    temperature_rhs.reinit(temperature_partitioning,'
p13199
aS'                           temperature_relevant_partitioning,'
p13200
aS'                           MPI_COMM_WORLD,'
p13201
aS'                           true);'
p13202
aS'    temperature_solution.reinit(temperature_relevant_partitioning,'
p13203
aS'                                MPI_COMM_WORLD);'
p13204
aS'    old_temperature_solution.reinit(temperature_solution);'
p13205
aS'    old_old_temperature_solution.reinit(temperature_solution);'
p13206
aS'    rebuild_stokes_matrix              = true;'
p13207
aS'    rebuild_stokes_preconditioner      = true;'
p13208
aS'    rebuild_temperature_matrices       = true;'
p13209
aS'    rebuild_temperature_preconditioner = true;'
p13210
aS'  }'
p13211
aS'  template <int dim>'
p13212
aS'  void BoussinesqFlowProblem<dim>::local_assemble_stokes_preconditioner('
p13213
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13214
aS'    Assembly::Scratch::StokesPreconditioner<dim> &        scratch,'
p13215
aS'    Assembly::CopyData::StokesPreconditioner<dim> &       data)'
p13216
aS'  {'
p13217
aS'    const unsigned int dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p13218
aS'    const unsigned int n_q_points ='
p13219
aS'      scratch.stokes_fe_values.n_quadrature_points;'
p13220
aS'    const FEValuesExtractors::Vector velocities(0);'
p13221
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p13222
aS'    scratch.stokes_fe_values.reinit(cell);'
p13223
aS'    cell->get_dof_indices(data.local_dof_indices);'
p13224
aS'    data.local_matrix = 0;'
p13225
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13226
aS'      {'
p13227
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p13228
aS'          {'
p13229
aS'            scratch.grad_phi_u[k] ='
p13230
aS'              scratch.stokes_fe_values[velocities].gradient(k, q);'
p13231
aS'            scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q);'
p13232
aS'          }'
p13233
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p13234
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p13235
aS'            data.local_matrix(i, j) +='
p13236
aS'                 scalar_product(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) +'
p13237
aS'                 EquationData::pressure_scaling *'
p13238
aS'              scratch.stokes_fe_values.JxW(q);'
p13239
aS'      }'
p13240
aS'  }'
p13241
aS'  template <int dim>'
p13242
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_stokes_preconditioner('
p13243
aS'    const Assembly::CopyData::StokesPreconditioner<dim> &data)'
p13244
aS'  {'
p13245
aS'    stokes_constraints.distribute_local_to_global(data.local_matrix,'
p13246
aS'                                                  data.local_dof_indices,'
p13247
aS'                                                  stokes_preconditioner_matrix);'
p13248
aS'  }'
p13249
aS'  template <int dim>'
p13250
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_preconditioner()'
p13251
aS'  {'
p13252
aS'    stokes_preconditioner_matrix = 0;'
p13253
aS'    const QGauss<dim> quadrature_formula(parameters.stokes_velocity_degree + 1);'
p13254
aS'    using CellFilter ='
p13255
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p13256
aS'    auto worker ='
p13257
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13258
aS'             Assembly::Scratch::StokesPreconditioner<dim> &        scratch,'
p13259
aS'             Assembly::CopyData::StokesPreconditioner<dim> &       data) {'
p13260
aS'        this->local_assemble_stokes_preconditioner(cell, scratch, data);'
p13261
aS'      };'
p13262
aS'    auto copier ='
p13263
aS'      [this](const Assembly::CopyData::StokesPreconditioner<dim> &data) {'
p13264
aS'        this->copy_local_to_global_stokes_preconditioner(data);'
p13265
aS'      };'
p13266
aS'    WorkStream::run(CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13267
aS'                               stokes_dof_handler.begin_active()),'
p13268
aS'                    CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13269
aS'                               stokes_dof_handler.end()),'
p13270
aS'                    worker,'
p13271
aS'                    copier,'
p13272
aS'                    Assembly::Scratch::StokesPreconditioner<dim>('
p13273
aS'                      stokes_fe,'
p13274
aS'                      quadrature_formula,'
p13275
aS'                      mapping,'
p13276
aS'                      update_JxW_values | update_values | update_gradients),'
p13277
aS'                    Assembly::CopyData::StokesPreconditioner<dim>(stokes_fe));'
p13278
aS'    stokes_preconditioner_matrix.compress(VectorOperation::add);'
p13279
aS'  }'
p13280
aS'  template <int dim>'
p13281
aS'  void BoussinesqFlowProblem<dim>::build_stokes_preconditioner()'
p13282
aS'  {'
p13283
aS'    if (rebuild_stokes_preconditioner == false)'
p13284
aS'      return;'
p13285
aS'    TimerOutput::Scope timer_section(computing_timer,'
p13286
aS'                                     "   Build Stokes preconditioner");'
p13287
aS'    pcout << "   Rebuilding Stokes preconditioner..." << std::flush;'
p13288
aS'    assemble_stokes_preconditioner();'
p13289
aS'    std::vector<std::vector<bool>> constant_modes;'
p13290
aS'    FEValuesExtractors::Vector     velocity_components(0);'
p13291
aS'    DoFTools::extract_constant_modes(stokes_dof_handler,'
p13292
aS'                                     stokes_fe.component_mask('
p13293
aS'                                       velocity_components),'
p13294
aS'                                     constant_modes);'
p13295
aS'    Mp_preconditioner ='
p13296
aS'      std::make_shared<TrilinosWrappers::PreconditionJacobi>();'
p13297
aS'    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionAMG>();'
p13298
aS'    TrilinosWrappers::PreconditionAMG::AdditionalData Amg_data;'
p13299
aS'    Amg_data.constant_modes        = constant_modes;'
p13300
aS'    Amg_data.elliptic              = true;'
p13301
aS'    Amg_data.higher_order_elements = true;'
p13302
aS'    Amg_data.smoother_sweeps       = 2;'
p13303
aS'    Amg_data.aggregation_threshold = 0.02;'
p13304
aS'    Mp_preconditioner->initialize(stokes_preconditioner_matrix.block(1, 1));'
p13305
aS'    Amg_preconditioner->initialize(stokes_preconditioner_matrix.block(0, 0),'
p13306
aS'                                   Amg_data);'
p13307
aS'    rebuild_stokes_preconditioner = false;'
p13308
aS'    pcout << std::endl;'
p13309
aS'  }'
p13310
aS'  template <int dim>'
p13311
aS'  void BoussinesqFlowProblem<dim>::local_assemble_stokes_system('
p13312
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13313
aS'    Assembly::Scratch::StokesSystem<dim> &                scratch,'
p13314
aS'    Assembly::CopyData::StokesSystem<dim> &               data)'
p13315
aS'  {'
p13316
aS'    const unsigned int dofs_per_cell ='
p13317
aS'      scratch.stokes_fe_values.get_fe().n_dofs_per_cell();'
p13318
aS'    const unsigned int n_q_points ='
p13319
aS'      scratch.stokes_fe_values.n_quadrature_points;'
p13320
aS'    const FEValuesExtractors::Vector velocities(0);'
p13321
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p13322
aS'    scratch.stokes_fe_values.reinit(cell);'
p13323
aS'    typename DoFHandler<dim>::active_cell_iterator temperature_cell('
p13324
aS'      &triangulation, cell->level(), cell->index(), &temperature_dof_handler);'
p13325
aS'    scratch.temperature_fe_values.reinit(temperature_cell);'
p13326
aS'    if (rebuild_stokes_matrix)'
p13327
aS'      data.local_matrix = 0;'
p13328
aS'    data.local_rhs = 0;'
p13329
aS'    scratch.temperature_fe_values.get_function_values('
p13330
aS'      old_temperature_solution, scratch.old_temperature_values);'
p13331
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13332
aS'      {'
p13333
aS'        const double old_temperature = scratch.old_temperature_values[q];'
p13334
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p13335
aS'          {'
p13336
aS'            scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q);'
p13337
aS'            if (rebuild_stokes_matrix)'
p13338
aS'              {'
p13339
aS'                scratch.grads_phi_u[k] ='
p13340
aS'                  scratch.stokes_fe_values[velocities].symmetric_gradient(k, q);'
p13341
aS'                scratch.div_phi_u[k] ='
p13342
aS'                  scratch.stokes_fe_values[velocities].divergence(k, q);'
p13343
aS'                scratch.phi_p[k] ='
p13344
aS'                  scratch.stokes_fe_values[pressure].value(k, q);'
p13345
aS'              }'
p13346
aS'          }'
p13347
aS'        if (rebuild_stokes_matrix == true)'
p13348
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p13349
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p13350
aS'              data.local_matrix(i, j) +='
p13351
aS'                  scratch.phi_p[j]) -'
p13352
aS'                  scratch.div_phi_u[j])) *'
p13353
aS'                scratch.stokes_fe_values.JxW(q);'
p13354
aS'        const Tensor<1, dim> gravity = EquationData::gravity_vector('
p13355
aS'          scratch.stokes_fe_values.quadrature_point(q));'
p13356
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p13357
aS'          data.local_rhs(i) += (EquationData::density(old_temperature) *'
p13358
aS'                                gravity * scratch.phi_u[i]) *'
p13359
aS'                               scratch.stokes_fe_values.JxW(q);'
p13360
aS'      }'
p13361
aS'    cell->get_dof_indices(data.local_dof_indices);'
p13362
aS'  }'
p13363
aS'  template <int dim>'
p13364
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_stokes_system('
p13365
aS'    const Assembly::CopyData::StokesSystem<dim> &data)'
p13366
aS'  {'
p13367
aS'    if (rebuild_stokes_matrix == true)'
p13368
aS'      stokes_constraints.distribute_local_to_global(data.local_matrix,'
p13369
aS'                                                    data.local_rhs,'
p13370
aS'                                                    data.local_dof_indices,'
p13371
aS'                                                    stokes_matrix,'
p13372
aS'                                                    stokes_rhs);'
p13373
aS'    else'
p13374
aS'      stokes_constraints.distribute_local_to_global(data.local_rhs,'
p13375
aS'                                                    data.local_dof_indices,'
p13376
aS'                                                    stokes_rhs);'
p13377
aS'  }'
p13378
aS'  template <int dim>'
p13379
aS'  void BoussinesqFlowProblem<dim>::assemble_stokes_system()'
p13380
aS'  {'
p13381
aS'    TimerOutput::Scope timer_section(computing_timer,'
p13382
aS'                                     "   Assemble Stokes system");'
p13383
aS'    if (rebuild_stokes_matrix == true)'
p13384
aS'      stokes_matrix = 0;'
p13385
aS'    stokes_rhs = 0;'
p13386
aS'    const QGauss<dim> quadrature_formula(parameters.stokes_velocity_degree + 1);'
p13387
aS'    using CellFilter ='
p13388
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p13389
aS'    WorkStream::run('
p13390
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13391
aS'                 stokes_dof_handler.begin_active()),'
p13392
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(), stokes_dof_handler.end()),'
p13393
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13394
aS'             Assembly::Scratch::StokesSystem<dim> &                scratch,'
p13395
aS'             Assembly::CopyData::StokesSystem<dim> &               data) {'
p13396
aS'        this->local_assemble_stokes_system(cell, scratch, data);'
p13397
aS'      },'
p13398
aS'      [this](const Assembly::CopyData::StokesSystem<dim> &data) {'
p13399
aS'        this->copy_local_to_global_stokes_system(data);'
p13400
aS'      },'
p13401
aS'      Assembly::Scratch::StokesSystem<dim>('
p13402
aS'        stokes_fe,'
p13403
aS'        mapping,'
p13404
aS'        quadrature_formula,'
p13405
aS'        temperature_fe,'
p13406
aS'        update_values),'
p13407
aS'      Assembly::CopyData::StokesSystem<dim>(stokes_fe));'
p13408
aS'    if (rebuild_stokes_matrix == true)'
p13409
aS'      stokes_matrix.compress(VectorOperation::add);'
p13410
aS'    stokes_rhs.compress(VectorOperation::add);'
p13411
aS'    rebuild_stokes_matrix = false;'
p13412
aS'    pcout << std::endl;'
p13413
aS'  }'
p13414
aS'  template <int dim>'
p13415
aS'  void BoussinesqFlowProblem<dim>::local_assemble_temperature_matrix('
p13416
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13417
aS'    Assembly::Scratch::TemperatureMatrix<dim> &           scratch,'
p13418
aS'    Assembly::CopyData::TemperatureMatrix<dim> &          data)'
p13419
aS'  {'
p13420
aS'    const unsigned int dofs_per_cell ='
p13421
aS'      scratch.temperature_fe_values.get_fe().n_dofs_per_cell();'
p13422
aS'    const unsigned int n_q_points ='
p13423
aS'      scratch.temperature_fe_values.n_quadrature_points;'
p13424
aS'    scratch.temperature_fe_values.reinit(cell);'
p13425
aS'    cell->get_dof_indices(data.local_dof_indices);'
p13426
aS'    data.local_mass_matrix      = 0;'
p13427
aS'    data.local_stiffness_matrix = 0;'
p13428
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13429
aS'      {'
p13430
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p13431
aS'          {'
p13432
aS'            scratch.grad_phi_T[k] ='
p13433
aS'              scratch.temperature_fe_values.shape_grad(k, q);'
p13434
aS'            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);'
p13435
aS'          }'
p13436
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p13437
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p13438
aS'            {'
p13439
aS'              data.local_mass_matrix(i, j) +='
p13440
aS'                 scratch.temperature_fe_values.JxW(q));'
p13441
aS'              data.local_stiffness_matrix(i, j) +='
p13442
aS'                 scratch.grad_phi_T[j] * scratch.temperature_fe_values.JxW(q));'
p13443
aS'            }'
p13444
aS'      }'
p13445
aS'  }'
p13446
aS'  template <int dim>'
p13447
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_temperature_matrix('
p13448
aS'    const Assembly::CopyData::TemperatureMatrix<dim> &data)'
p13449
aS'  {'
p13450
aS'    temperature_constraints.distribute_local_to_global(data.local_mass_matrix,'
p13451
aS'                                                       data.local_dof_indices,'
p13452
aS'                                                       temperature_mass_matrix);'
p13453
aS'    temperature_constraints.distribute_local_to_global('
p13454
aS'      data.local_stiffness_matrix,'
p13455
aS'      data.local_dof_indices,'
p13456
aS'      temperature_stiffness_matrix);'
p13457
aS'  }'
p13458
aS'  template <int dim>'
p13459
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_matrix()'
p13460
aS'  {'
p13461
aS'    if (rebuild_temperature_matrices == false)'
p13462
aS'      return;'
p13463
aS'    TimerOutput::Scope timer_section(computing_timer,'
p13464
aS'                                     "   Assemble temperature matrices");'
p13465
aS'    temperature_mass_matrix      = 0;'
p13466
aS'    temperature_stiffness_matrix = 0;'
p13467
aS'    const QGauss<dim> quadrature_formula(parameters.temperature_degree + 2);'
p13468
aS'    using CellFilter ='
p13469
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p13470
aS'    WorkStream::run('
p13471
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13472
aS'                 temperature_dof_handler.begin_active()),'
p13473
aS'      CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13474
aS'                 temperature_dof_handler.end()),'
p13475
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13476
aS'             Assembly::Scratch::TemperatureMatrix<dim> &           scratch,'
p13477
aS'             Assembly::CopyData::TemperatureMatrix<dim> &          data) {'
p13478
aS'        this->local_assemble_temperature_matrix(cell, scratch, data);'
p13479
aS'      },'
p13480
aS'      [this](const Assembly::CopyData::TemperatureMatrix<dim> &data) {'
p13481
aS'        this->copy_local_to_global_temperature_matrix(data);'
p13482
aS'      },'
p13483
aS'      Assembly::Scratch::TemperatureMatrix<dim>(temperature_fe,'
p13484
aS'                                                mapping,'
p13485
aS'                                                quadrature_formula),'
p13486
aS'      Assembly::CopyData::TemperatureMatrix<dim>(temperature_fe));'
p13487
aS'    temperature_mass_matrix.compress(VectorOperation::add);'
p13488
aS'    temperature_stiffness_matrix.compress(VectorOperation::add);'
p13489
aS'    rebuild_temperature_matrices       = false;'
p13490
aS'    rebuild_temperature_preconditioner = true;'
p13491
aS'  }'
p13492
aS'  template <int dim>'
p13493
aS'  void BoussinesqFlowProblem<dim>::local_assemble_temperature_rhs('
p13494
aS'    const std::pair<double, double> global_T_range,'
p13495
aS'    const double                    global_max_velocity,'
p13496
aS'    const double                    global_entropy_variation,'
p13497
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13498
aS'    Assembly::Scratch::TemperatureRHS<dim> &              scratch,'
p13499
aS'    Assembly::CopyData::TemperatureRHS<dim> &             data)'
p13500
aS'  {'
p13501
aS'    const bool use_bdf2_scheme = (timestep_number != 0);'
p13502
aS'    const unsigned int dofs_per_cell ='
p13503
aS'      scratch.temperature_fe_values.get_fe().n_dofs_per_cell();'
p13504
aS'    const unsigned int n_q_points ='
p13505
aS'      scratch.temperature_fe_values.n_quadrature_points;'
p13506
aS'    const FEValuesExtractors::Vector velocities(0);'
p13507
aS'    data.local_rhs     = 0;'
p13508
aS'    data.matrix_for_bc = 0;'
p13509
aS'    cell->get_dof_indices(data.local_dof_indices);'
p13510
aS'    scratch.temperature_fe_values.reinit(cell);'
p13511
aS'    typename DoFHandler<dim>::active_cell_iterator stokes_cell('
p13512
aS'      &triangulation, cell->level(), cell->index(), &stokes_dof_handler);'
p13513
aS'    scratch.stokes_fe_values.reinit(stokes_cell);'
p13514
aS'    scratch.temperature_fe_values.get_function_values('
p13515
aS'      old_temperature_solution, scratch.old_temperature_values);'
p13516
aS'    scratch.temperature_fe_values.get_function_values('
p13517
aS'      old_old_temperature_solution, scratch.old_old_temperature_values);'
p13518
aS'    scratch.temperature_fe_values.get_function_gradients('
p13519
aS'      old_temperature_solution, scratch.old_temperature_grads);'
p13520
aS'    scratch.temperature_fe_values.get_function_gradients('
p13521
aS'      old_old_temperature_solution, scratch.old_old_temperature_grads);'
p13522
aS'    scratch.temperature_fe_values.get_function_laplacians('
p13523
aS'      old_temperature_solution, scratch.old_temperature_laplacians);'
p13524
aS'    scratch.temperature_fe_values.get_function_laplacians('
p13525
aS'      old_old_temperature_solution, scratch.old_old_temperature_laplacians);'
p13526
aS'    scratch.stokes_fe_values[velocities].get_function_values('
p13527
aS'      stokes_solution, scratch.old_velocity_values);'
p13528
aS'    scratch.stokes_fe_values[velocities].get_function_values('
p13529
aS'      old_stokes_solution, scratch.old_old_velocity_values);'
p13530
aS'    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients('
p13531
aS'      stokes_solution, scratch.old_strain_rates);'
p13532
aS'    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients('
p13533
aS'      old_stokes_solution, scratch.old_old_strain_rates);'
p13534
aS'    const double nu ='
p13535
aS'      compute_viscosity(scratch.old_temperature_values,'
p13536
aS'                        scratch.old_old_temperature_values,'
p13537
aS'                        scratch.old_temperature_grads,'
p13538
aS'                        scratch.old_old_temperature_grads,'
p13539
aS'                        scratch.old_temperature_laplacians,'
p13540
aS'                        scratch.old_old_temperature_laplacians,'
p13541
aS'                        scratch.old_velocity_values,'
p13542
aS'                        scratch.old_old_velocity_values,'
p13543
aS'                        scratch.old_strain_rates,'
p13544
aS'                        scratch.old_old_strain_rates,'
p13545
aS'                        global_max_velocity,'
p13546
aS'                        global_T_range.second - global_T_range.first,'
p13547
aS'                        0.5 * (global_T_range.second + global_T_range.first),'
p13548
aS'                        global_entropy_variation,'
p13549
aS'                        cell->diameter());'
p13550
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p13551
aS'      {'
p13552
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p13553
aS'          {'
p13554
aS'            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);'
p13555
aS'            scratch.grad_phi_T[k] ='
p13556
aS'              scratch.temperature_fe_values.shape_grad(k, q);'
p13557
aS'          }'
p13558
aS'        const double T_term_for_rhs ='
p13559
aS'              scratch.old_old_temperature_values[q] * (time_step * time_step) /'
p13560
aS'             scratch.old_temperature_values[q]);'
p13561
aS'        const double ext_T ='
p13562
aS'                              scratch.old_old_temperature_values[q] *'
p13563
aS'                                time_step / old_time_step) :'
p13564
aS'                             scratch.old_temperature_values[q]);'
p13565
aS'        const Tensor<1, dim> ext_grad_T ='
p13566
aS'                              scratch.old_old_temperature_grads[q] * time_step /'
p13567
aS'                                old_time_step) :'
p13568
aS'                             scratch.old_temperature_grads[q]);'
p13569
aS'        const Tensor<1, dim> extrapolated_u ='
p13570
aS'              scratch.old_old_velocity_values[q] * time_step / old_time_step) :'
p13571
aS'             scratch.old_velocity_values[q]);'
p13572
aS'        const SymmetricTensor<2, dim> extrapolated_strain_rate ='
p13573
aS'              scratch.old_old_strain_rates[q] * time_step / old_time_step) :'
p13574
aS'             scratch.old_strain_rates[q]);'
p13575
aS'        const double gamma ='
p13576
aS'            2 * EquationData::eta * extrapolated_strain_rate *'
p13577
aS'              extrapolated_strain_rate) /'
p13578
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p13579
aS'          {'
p13580
aS'            data.local_rhs(i) +='
p13581
aS'               time_step * extrapolated_u * ext_grad_T * scratch.phi_T[i] -'
p13582
aS'               time_step * nu * ext_grad_T * scratch.grad_phi_T[i] +'
p13583
aS'               time_step * gamma * scratch.phi_T[i]) *'
p13584
aS'              scratch.temperature_fe_values.JxW(q);'
p13585
aS'            if (temperature_constraints.is_inhomogeneously_constrained('
p13586
aS'                  data.local_dof_indices[i]))'
p13587
aS'              {'
p13588
aS'                for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p13589
aS'                  data.matrix_for_bc(j, i) +='
p13590
aS'                                          1.) +'
p13591
aS'                     scratch.grad_phi_T[i] * scratch.grad_phi_T[j] *'
p13592
aS'                       EquationData::kappa * time_step) *'
p13593
aS'                    scratch.temperature_fe_values.JxW(q);'
p13594
aS'              }'
p13595
aS'          }'
p13596
aS'      }'
p13597
aS'  }'
p13598
aS'  template <int dim>'
p13599
aS'  void BoussinesqFlowProblem<dim>::copy_local_to_global_temperature_rhs('
p13600
aS'    const Assembly::CopyData::TemperatureRHS<dim> &data)'
p13601
aS'  {'
p13602
aS'    temperature_constraints.distribute_local_to_global(data.local_rhs,'
p13603
aS'                                                       data.local_dof_indices,'
p13604
aS'                                                       temperature_rhs,'
p13605
aS'                                                       data.matrix_for_bc);'
p13606
aS'  }'
p13607
aS'  template <int dim>'
p13608
aS'  void BoussinesqFlowProblem<dim>::assemble_temperature_system('
p13609
aS'    const double maximal_velocity)'
p13610
aS'  {'
p13611
aS'    const bool use_bdf2_scheme = (timestep_number != 0);'
p13612
aS'    if (use_bdf2_scheme == true)'
p13613
aS'      {'
p13614
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p13615
aS'        temperature_matrix *='
p13616
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p13617
aS'      }'
p13618
aS'    else'
p13619
aS'      {'
p13620
aS'        temperature_matrix.copy_from(temperature_mass_matrix);'
p13621
aS'        temperature_matrix.add(time_step, temperature_stiffness_matrix);'
p13622
aS'      }'
p13623
aS'    if (rebuild_temperature_preconditioner == true)'
p13624
aS'      {'
p13625
aS'        T_preconditioner ='
p13626
aS'          std::make_shared<TrilinosWrappers::PreconditionJacobi>();'
p13627
aS'        T_preconditioner->initialize(temperature_matrix);'
p13628
aS'        rebuild_temperature_preconditioner = false;'
p13629
aS'      }'
p13630
aS'    temperature_rhs = 0;'
p13631
aS'    const QGauss<dim> quadrature_formula(parameters.temperature_degree + 2);'
p13632
aS'    const std::pair<double, double> global_T_range ='
p13633
aS'      get_extrapolated_temperature_range();'
p13634
aS'    const double average_temperature ='
p13635
aS'      0.5 * (global_T_range.first + global_T_range.second);'
p13636
aS'    const double global_entropy_variation ='
p13637
aS'      get_entropy_variation(average_temperature);'
p13638
aS'    using CellFilter ='
p13639
aS'      FilteredIterator<typename DoFHandler<2>::active_cell_iterator>;'
p13640
aS'    auto worker ='
p13641
aS'      [this, global_T_range, maximal_velocity, global_entropy_variation]('
p13642
aS'        const typename DoFHandler<dim>::active_cell_iterator &cell,'
p13643
aS'        Assembly::Scratch::TemperatureRHS<dim> &              scratch,'
p13644
aS'        Assembly::CopyData::TemperatureRHS<dim> &             data) {'
p13645
aS'        this->local_assemble_temperature_rhs(global_T_range,'
p13646
aS'                                             maximal_velocity,'
p13647
aS'                                             global_entropy_variation,'
p13648
aS'                                             cell,'
p13649
aS'                                             scratch,'
p13650
aS'                                             data);'
p13651
aS'      };'
p13652
aS'    auto copier = [this](const Assembly::CopyData::TemperatureRHS<dim> &data) {'
p13653
aS'      this->copy_local_to_global_temperature_rhs(data);'
p13654
aS'    };'
p13655
aS'    WorkStream::run(CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13656
aS'                               temperature_dof_handler.begin_active()),'
p13657
aS'                    CellFilter(IteratorFilters::LocallyOwnedCell(),'
p13658
aS'                               temperature_dof_handler.end()),'
p13659
aS'                    worker,'
p13660
aS'                    copier,'
p13661
aS'                    Assembly::Scratch::TemperatureRHS<dim>('
p13662
aS'                      temperature_fe, stokes_fe, mapping, quadrature_formula),'
p13663
aS'                    Assembly::CopyData::TemperatureRHS<dim>(temperature_fe));'
p13664
aS'    temperature_rhs.compress(VectorOperation::add);'
p13665
aS'  }'
p13666
aS'  template <int dim>'
p13667
aS'  void BoussinesqFlowProblem<dim>::solve()'
p13668
aS'  {'
p13669
aS'    {'
p13670
aS'      TimerOutput::Scope timer_section(computing_timer,'
p13671
aS'                                       "   Solve Stokes system");'
p13672
aS'      pcout << "   Solving Stokes system... " << std::flush;'
p13673
aS'      TrilinosWrappers::MPI::BlockVector distributed_stokes_solution('
p13674
aS'        stokes_rhs);'
p13675
aS'      distributed_stokes_solution = stokes_solution;'
p13676
aS'      distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;'
p13677
aS'      const unsigned int'
p13678
aS'        start = (distributed_stokes_solution.block(0).size() +'
p13679
aS'                 distributed_stokes_solution.block(1).local_range().first),'
p13680
aS'        end   = (distributed_stokes_solution.block(0).size() +'
p13681
aS'               distributed_stokes_solution.block(1).local_range().second);'
p13682
aS'      for (unsigned int i = start; i < end; ++i)'
p13683
aS'        if (stokes_constraints.is_constrained(i))'
p13684
aS'          distributed_stokes_solution(i) = 0;'
p13685
aS'      PrimitiveVectorMemory<TrilinosWrappers::MPI::BlockVector> mem;'
p13686
aS'      unsigned int  n_iterations     = 0;'
p13687
aS'      const double  solver_tolerance = 1e-8 * stokes_rhs.l2_norm();'
p13688
aS'      SolverControl solver_control(30, solver_tolerance);'
p13689
aS'      try'
p13690
aS'        {'
p13691
aS'          const LinearSolvers::BlockSchurPreconditioner<'
p13692
aS'            TrilinosWrappers::PreconditionAMG,'
p13693
aS'            TrilinosWrappers::PreconditionJacobi>'
p13694
aS'            preconditioner(stokes_matrix,'
p13695
aS'                           stokes_preconditioner_matrix,'
p13696
aS'                           false);'
p13697
aS'          SolverFGMRES<TrilinosWrappers::MPI::BlockVector> solver('
p13698
aS'            solver_control,'
p13699
aS'            mem,'
p13700
aS'            SolverFGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData('
p13701
aS'              30));'
p13702
aS'          solver.solve(stokes_matrix,'
p13703
aS'                       distributed_stokes_solution,'
p13704
aS'                       stokes_rhs,'
p13705
aS'                       preconditioner);'
p13706
aS'          n_iterations = solver_control.last_step();'
p13707
aS'        }'
p13708
aS'      catch (SolverControl::NoConvergence &)'
p13709
aS'        {'
p13710
aS'          const LinearSolvers::BlockSchurPreconditioner<'
p13711
aS'            TrilinosWrappers::PreconditionAMG,'
p13712
aS'            TrilinosWrappers::PreconditionJacobi>'
p13713
aS'            preconditioner(stokes_matrix,'
p13714
aS'                           stokes_preconditioner_matrix,'
p13715
aS'                           true);'
p13716
aS'          SolverControl solver_control_refined(stokes_matrix.m(),'
p13717
aS'                                               solver_tolerance);'
p13718
aS'          SolverFGMRES<TrilinosWrappers::MPI::BlockVector> solver('
p13719
aS'            solver_control_refined,'
p13720
aS'            mem,'
p13721
aS'            SolverFGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData('
p13722
aS'              50));'
p13723
aS'          solver.solve(stokes_matrix,'
p13724
aS'                       distributed_stokes_solution,'
p13725
aS'                       stokes_rhs,'
p13726
aS'                       preconditioner);'
p13727
aS'          n_iterations ='
p13728
aS'        }'
p13729
aS'      stokes_constraints.distribute(distributed_stokes_solution);'
p13730
aS'      distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;'
p13731
aS'      stokes_solution = distributed_stokes_solution;'
p13732
aS'      pcout << n_iterations << " iterations." << std::endl;'
p13733
aS'    }'
p13734
aS'    {'
p13735
aS'      TimerOutput::Scope timer_section(computing_timer,'
p13736
aS'                                       "   Assemble temperature rhs");'
p13737
aS'      old_time_step = time_step;'
p13738
aS'      const double scaling = (dim == 3 ? 0.25 : 1.0);'
p13739
aS'      time_step            = (scaling / (2.1 * dim * std::sqrt(1. * dim)) /'
p13740
aS'      const double maximal_velocity = get_maximal_velocity();'
p13741
aS'      pcout << "   Maximal velocity: "'
p13742
aS'            << maximal_velocity * EquationData::year_in_seconds * 100'
p13743
aS'            << " cm/year" << std::endl;'
p13744
aS'      pcout << "   "'
p13745
aS'            << "Time step: " << time_step / EquationData::year_in_seconds'
p13746
aS'            << " years" << std::endl;'
p13747
aS'      temperature_solution = old_temperature_solution;'
p13748
aS'      assemble_temperature_system(maximal_velocity);'
p13749
aS'    }'
p13750
aS'    {'
p13751
aS'      TimerOutput::Scope timer_section(computing_timer,'
p13752
aS'                                       "   Solve temperature system");'
p13753
aS'      SolverControl solver_control(temperature_matrix.m(),'
p13754
aS'                                   1e-12 * temperature_rhs.l2_norm());'
p13755
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p13756
aS'      TrilinosWrappers::MPI::Vector distributed_temperature_solution('
p13757
aS'        temperature_rhs);'
p13758
aS'      distributed_temperature_solution = temperature_solution;'
p13759
aS'      cg.solve(temperature_matrix,'
p13760
aS'               distributed_temperature_solution,'
p13761
aS'               temperature_rhs,'
p13762
aS'      temperature_constraints.distribute(distributed_temperature_solution);'
p13763
aS'      temperature_solution = distributed_temperature_solution;'
p13764
aS'      pcout << "   " << solver_control.last_step()'
p13765
aS'            << " CG iterations for temperature" << std::endl;'
p13766
aS'      double temperature[2] = {std::numeric_limits<double>::max(),'
p13767
aS'                               -std::numeric_limits<double>::max()};'
p13768
aS'      double global_temperature[2];'
p13769
aS'      for (unsigned int i ='
p13770
aS'             distributed_temperature_solution.local_range().first;'
p13771
aS'           i < distributed_temperature_solution.local_range().second;'
p13772
aS'           ++i)'
p13773
aS'        {'
p13774
aS'          temperature[0] ='
p13775
aS'            std::min<double>(temperature[0],'
p13776
aS'                             distributed_temperature_solution(i));'
p13777
aS'          temperature[1] ='
p13778
aS'            std::max<double>(temperature[1],'
p13779
aS'                             distributed_temperature_solution(i));'
p13780
aS'        }'
p13781
aS'      temperature[0] *= -1.0;'
p13782
aS'      Utilities::MPI::max(temperature, MPI_COMM_WORLD, global_temperature);'
p13783
aS'      global_temperature[0] *= -1.0;'
p13784
aS'      pcout << "   Temperature range: " << global_temperature[0] << \' \''
p13785
aS'            << global_temperature[1] << std::endl;'
p13786
aS'    }'
p13787
aS'  }'
p13788
aS'  template <int dim>'
p13789
aS'  class BoussinesqFlowProblem<dim>::Postprocessor'
p13790
aS'    : public DataPostprocessor<dim>'
p13791
aS'  {'
p13792
aS'  public:'
p13793
aS'    Postprocessor(const unsigned int partition, const double minimal_pressure);'
p13794
aS'    virtual void evaluate_vector_field('
p13795
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p13796
aS'      std::vector<Vector<double>> &computed_quantities) const override;'
p13797
aS'    virtual std::vector<std::string> get_names() const override;'
p13798
aS'    virtual std::vector<'
p13799
aS'      DataComponentInterpretation::DataComponentInterpretation>'
p13800
aS'    get_data_component_interpretation() const override;'
p13801
aS'    virtual UpdateFlags get_needed_update_flags() const override;'
p13802
aS'  private:'
p13803
aS'    const unsigned int partition;'
p13804
aS'    const double       minimal_pressure;'
p13805
aS'  };'
p13806
aS'  template <int dim>'
p13807
aS'  BoussinesqFlowProblem<dim>::Postprocessor::Postprocessor('
p13808
aS'    const unsigned int partition,'
p13809
aS'    const double       minimal_pressure)'
p13810
aS'    : partition(partition)'
p13811
aS'    , minimal_pressure(minimal_pressure)'
p13812
aS'  {}'
p13813
aS'  template <int dim>'
p13814
aS'  std::vector<std::string>'
p13815
aS'  BoussinesqFlowProblem<dim>::Postprocessor::get_names() const'
p13816
aS'  {'
p13817
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p13818
aS'    solution_names.emplace_back("p");'
p13819
aS'    solution_names.emplace_back("T");'
p13820
aS'    solution_names.emplace_back("friction_heating");'
p13821
aS'    solution_names.emplace_back("partition");'
p13822
aS'    return solution_names;'
p13823
aS'  }'
p13824
aS'  template <int dim>'
p13825
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p13826
aS'  BoussinesqFlowProblem<dim>::Postprocessor::get_data_component_interpretation()'
p13827
aS'    const'
p13828
aS'  {'
p13829
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p13830
aS'      interpretation(dim,'
p13831
aS'                     DataComponentInterpretation::component_is_part_of_vector);'
p13832
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p13833
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p13834
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p13835
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p13836
aS'    return interpretation;'
p13837
aS'  }'
p13838
aS'  template <int dim>'
p13839
aS'  UpdateFlags'
p13840
aS'  BoussinesqFlowProblem<dim>::Postprocessor::get_needed_update_flags() const'
p13841
aS'  {'
p13842
aS'    return update_values | update_gradients | update_quadrature_points;'
p13843
aS'  }'
p13844
aS'  template <int dim>'
p13845
aS'  void BoussinesqFlowProblem<dim>::Postprocessor::evaluate_vector_field('
p13846
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p13847
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p13848
aS'  {'
p13849
aS'    const unsigned int n_quadrature_points = inputs.solution_values.size();'
p13850
aS'    Assert(inputs.solution_gradients.size() == n_quadrature_points,'
p13851
aS'           ExcInternalError());'
p13852
aS'    Assert(computed_quantities.size() == n_quadrature_points,'
p13853
aS'           ExcInternalError());'
p13854
aS'    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError());'
p13855
aS'    for (unsigned int q = 0; q < n_quadrature_points; ++q)'
p13856
aS'      {'
p13857
aS'        for (unsigned int d = 0; d < dim; ++d)'
p13858
aS'          computed_quantities[q](d) = (inputs.solution_values[q](d) *'
p13859
aS'                                       EquationData::year_in_seconds * 100);'
p13860
aS'        const double pressure ='
p13861
aS'        computed_quantities[q](dim) = pressure;'
p13862
aS'        const double temperature        = inputs.solution_values[q](dim + 1);'
p13863
aS'        computed_quantities[q](dim + 1) = temperature;'
p13864
aS'        Tensor<2, dim> grad_u;'
p13865
aS'        for (unsigned int d = 0; d < dim; ++d)'
p13866
aS'          grad_u[d] = inputs.solution_gradients[q][d];'
p13867
aS'        const SymmetricTensor<2, dim> strain_rate = symmetrize(grad_u);'
p13868
aS'        computed_quantities[q](dim + 2) ='
p13869
aS'          2 * EquationData::eta * strain_rate * strain_rate;'
p13870
aS'        computed_quantities[q](dim + 3) = partition;'
p13871
aS'      }'
p13872
aS'  }'
p13873
aS'  template <int dim>'
p13874
aS'  void BoussinesqFlowProblem<dim>::output_results()'
p13875
aS'  {'
p13876
aS'    TimerOutput::Scope timer_section(computing_timer, "Postprocessing");'
p13877
aS'    const FESystem<dim> joint_fe(stokes_fe, 1, temperature_fe, 1);'
p13878
aS'    DoFHandler<dim> joint_dof_handler(triangulation);'
p13879
aS'    joint_dof_handler.distribute_dofs(joint_fe);'
p13880
aS'    Assert(joint_dof_handler.n_dofs() =='
p13881
aS'             stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),'
p13882
aS'           ExcInternalError());'
p13883
aS'    TrilinosWrappers::MPI::Vector joint_solution;'
p13884
aS'    joint_solution.reinit(joint_dof_handler.locally_owned_dofs(),'
p13885
aS'                          MPI_COMM_WORLD);'
p13886
aS'    {'
p13887
aS'      std::vector<types::global_dof_index> local_joint_dof_indices('
p13888
aS'        joint_fe.n_dofs_per_cell());'
p13889
aS'      std::vector<types::global_dof_index> local_stokes_dof_indices('
p13890
aS'        stokes_fe.n_dofs_per_cell());'
p13891
aS'      std::vector<types::global_dof_index> local_temperature_dof_indices('
p13892
aS'        temperature_fe.n_dofs_per_cell());'
p13893
aS'      typename DoFHandler<dim>::active_cell_iterator'
p13894
aS'        joint_cell       = joint_dof_handler.begin_active(),'
p13895
aS'        joint_endc       = joint_dof_handler.end(),'
p13896
aS'        stokes_cell      = stokes_dof_handler.begin_active(),'
p13897
aS'        temperature_cell = temperature_dof_handler.begin_active();'
p13898
aS'      for (; joint_cell != joint_endc;'
p13899
aS'           ++joint_cell, ++stokes_cell, ++temperature_cell)'
p13900
aS'        if (joint_cell->is_locally_owned())'
p13901
aS'          {'
p13902
aS'            joint_cell->get_dof_indices(local_joint_dof_indices);'
p13903
aS'            stokes_cell->get_dof_indices(local_stokes_dof_indices);'
p13904
aS'            temperature_cell->get_dof_indices(local_temperature_dof_indices);'
p13905
aS'            for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)'
p13906
aS'              if (joint_fe.system_to_base_index(i).first.first == 0)'
p13907
aS'                {'
p13908
aS'                  Assert(joint_fe.system_to_base_index(i).second <'
p13909
aS'                           local_stokes_dof_indices.size(),'
p13910
aS'                         ExcInternalError());'
p13911
aS'                  joint_solution(local_joint_dof_indices[i]) = stokes_solution('
p13912
aS'                    local_stokes_dof_indices[joint_fe.system_to_base_index(i)'
p13913
aS'                                               .second]);'
p13914
aS'                }'
p13915
aS'              else'
p13916
aS'                {'
p13917
aS'                  Assert(joint_fe.system_to_base_index(i).first.first == 1,'
p13918
aS'                         ExcInternalError());'
p13919
aS'                  Assert(joint_fe.system_to_base_index(i).second <'
p13920
aS'                           local_temperature_dof_indices.size(),'
p13921
aS'                         ExcInternalError());'
p13922
aS'                  joint_solution(local_joint_dof_indices[i]) ='
p13923
aS'                    temperature_solution('
p13924
aS'                      local_temperature_dof_indices'
p13925
aS'                        [joint_fe.system_to_base_index(i).second]);'
p13926
aS'                }'
p13927
aS'          }'
p13928
aS'    }'
p13929
aS'    joint_solution.compress(VectorOperation::insert);'
p13930
aS'    IndexSet locally_relevant_joint_dofs(joint_dof_handler.n_dofs());'
p13931
aS'    DoFTools::extract_locally_relevant_dofs(joint_dof_handler,'
p13932
aS'                                            locally_relevant_joint_dofs);'
p13933
aS'    TrilinosWrappers::MPI::Vector locally_relevant_joint_solution;'
p13934
aS'    locally_relevant_joint_solution.reinit(locally_relevant_joint_dofs,'
p13935
aS'                                           MPI_COMM_WORLD);'
p13936
aS'    locally_relevant_joint_solution = joint_solution;'
p13937
aS'    Postprocessor postprocessor(Utilities::MPI::this_mpi_process('
p13938
aS'                                  MPI_COMM_WORLD),'
p13939
aS'                                stokes_solution.block(1).min());'
p13940
aS'    DataOut<dim> data_out;'
p13941
aS'    data_out.attach_dof_handler(joint_dof_handler);'
p13942
aS'    data_out.add_data_vector(locally_relevant_joint_solution, postprocessor);'
p13943
aS'    data_out.build_patches();'
p13944
aS'    static int out_index = 0;'
p13945
aS'    data_out.write_vtu_with_pvtu_record('
p13946
aS'      "./", "solution", out_index, MPI_COMM_WORLD, 5);'
p13947
aS'    out_index++;'
p13948
aS'  }'
p13949
aS'  template <int dim>'
p13950
aS'  void'
p13951
aS'  BoussinesqFlowProblem<dim>::refine_mesh(const unsigned int max_grid_level)'
p13952
aS'  {'
p13953
aS'    parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector>'
p13954
aS'      temperature_trans(temperature_dof_handler);'
p13955
aS'    parallel::distributed::SolutionTransfer<dim,'
p13956
aS'                                            TrilinosWrappers::MPI::BlockVector>'
p13957
aS'      stokes_trans(stokes_dof_handler);'
p13958
aS'    {'
p13959
aS'      TimerOutput::Scope timer_section(computing_timer,'
p13960
aS'                                       "Refine mesh structure, part 1");'
p13961
aS'      Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p13962
aS'      KellyErrorEstimator<dim>::estimate('
p13963
aS'        temperature_dof_handler,'
p13964
aS'        QGauss<dim - 1>(parameters.temperature_degree + 1),'
p13965
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p13966
aS'        temperature_solution,'
p13967
aS'        estimated_error_per_cell,'
p13968
aS'        ComponentMask(),'
p13969
aS'        nullptr,'
p13970
aS'        0,'
p13971
aS'        triangulation.locally_owned_subdomain());'
p13972
aS'      parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction('
p13973
aS'        triangulation, estimated_error_per_cell, 0.3, 0.1);'
p13974
aS'      if (triangulation.n_levels() > max_grid_level)'
p13975
aS'        for (typename Triangulation<dim>::active_cell_iterator cell ='
p13976
aS'               triangulation.begin_active(max_grid_level);'
p13977
aS'             cell != triangulation.end();'
p13978
aS'             ++cell)'
p13979
aS'          cell->clear_refine_flag();'
p13980
aS'      std::vector<const TrilinosWrappers::MPI::Vector *> x_temperature(2);'
p13981
aS'      x_temperature[0] = &temperature_solution;'
p13982
aS'      x_temperature[1] = &old_temperature_solution;'
p13983
aS'      std::vector<const TrilinosWrappers::MPI::BlockVector *> x_stokes(2);'
p13984
aS'      x_stokes[0] = &stokes_solution;'
p13985
aS'      x_stokes[1] = &old_stokes_solution;'
p13986
aS'      triangulation.prepare_coarsening_and_refinement();'
p13987
aS'      temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);'
p13988
aS'      stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);'
p13989
aS'      triangulation.execute_coarsening_and_refinement();'
p13990
aS'    }'
p13991
aS'    setup_dofs();'
p13992
aS'    {'
p13993
aS'      TimerOutput::Scope timer_section(computing_timer,'
p13994
aS'                                       "Refine mesh structure, part 2");'
p13995
aS'      {'
p13996
aS'        TrilinosWrappers::MPI::Vector distributed_temp1(temperature_rhs);'
p13997
aS'        TrilinosWrappers::MPI::Vector distributed_temp2(temperature_rhs);'
p13998
aS'        std::vector<TrilinosWrappers::MPI::Vector *> tmp(2);'
p13999
aS'        tmp[0] = &(distributed_temp1);'
p14000
aS'        tmp[1] = &(distributed_temp2);'
p14001
aS'        temperature_trans.interpolate(tmp);'
p14002
aS'        temperature_constraints.distribute(distributed_temp1);'
p14003
aS'        temperature_constraints.distribute(distributed_temp2);'
p14004
aS'        temperature_solution     = distributed_temp1;'
p14005
aS'        old_temperature_solution = distributed_temp2;'
p14006
aS'      }'
p14007
aS'      {'
p14008
aS'        TrilinosWrappers::MPI::BlockVector distributed_stokes(stokes_rhs);'
p14009
aS'        TrilinosWrappers::MPI::BlockVector old_distributed_stokes(stokes_rhs);'
p14010
aS'        std::vector<TrilinosWrappers::MPI::BlockVector *> stokes_tmp(2);'
p14011
aS'        stokes_tmp[0] = &(distributed_stokes);'
p14012
aS'        stokes_tmp[1] = &(old_distributed_stokes);'
p14013
aS'        stokes_trans.interpolate(stokes_tmp);'
p14014
aS'        stokes_constraints.distribute(distributed_stokes);'
p14015
aS'        stokes_constraints.distribute(old_distributed_stokes);'
p14016
aS'        stokes_solution     = distributed_stokes;'
p14017
aS'        old_stokes_solution = old_distributed_stokes;'
p14018
aS'      }'
p14019
aS'    }'
p14020
aS'  }'
p14021
aS'  template <int dim>'
p14022
aS'  void BoussinesqFlowProblem<dim>::run()'
p14023
aS'  {'
p14024
aS'    GridGenerator::hyper_shell(triangulation,'
p14025
aS'                               Point<dim>(),'
p14026
aS'                               EquationData::R0,'
p14027
aS'                               EquationData::R1,'
p14028
aS'                               true);'
p14029
aS'    global_Omega_diameter = GridTools::diameter(triangulation);'
p14030
aS'    triangulation.refine_global(parameters.initial_global_refinement);'
p14031
aS'    setup_dofs();'
p14032
aS'    unsigned int pre_refinement_step = 0;'
p14033
aS'  start_time_iteration:'
p14034
aS'    {'
p14035
aS'      TrilinosWrappers::MPI::Vector solution('
p14036
aS'        temperature_dof_handler.locally_owned_dofs());'
p14037
aS'      VectorTools::project(temperature_dof_handler,'
p14038
aS'                           temperature_constraints,'
p14039
aS'                           QGauss<dim>(parameters.temperature_degree + 2),'
p14040
aS'                           EquationData::TemperatureInitialValues<dim>(),'
p14041
aS'                           solution);'
p14042
aS'      temperature_solution         = solution;'
p14043
aS'      old_temperature_solution     = solution;'
p14044
aS'      old_old_temperature_solution = solution;'
p14045
aS'    }'
p14046
aS'    timestep_number = 0;'
p14047
aS'    time_step = old_time_step = 0;'
p14048
aS'    double time = 0;'
p14049
aS'    do'
p14050
aS'      {'
p14051
aS'        pcout << "Timestep " << timestep_number'
p14052
aS'              << ":  t=" << time / EquationData::year_in_seconds << " years"'
p14053
aS'              << std::endl;'
p14054
aS'        assemble_stokes_system();'
p14055
aS'        build_stokes_preconditioner();'
p14056
aS'        assemble_temperature_matrix();'
p14057
aS'        solve();'
p14058
aS'        pcout << std::endl;'
p14059
aS'        if ((timestep_number == 0) &&'
p14060
aS'          {'
p14061
aS'            refine_mesh(parameters.initial_global_refinement +'
p14062
aS'                        parameters.initial_adaptive_refinement);'
p14063
aS'            ++pre_refinement_step;'
p14064
aS'            goto start_time_iteration;'
p14065
aS'          }'
p14066
aS'        else if ((timestep_number > 0) &&'
p14067
aS'                  0))'
p14068
aS'          refine_mesh(parameters.initial_global_refinement +'
p14069
aS'                      parameters.initial_adaptive_refinement);'
p14070
aS'        if ((parameters.generate_graphical_output == true) &&'
p14071
aS'          output_results();'
p14072
aS'        if (time > parameters.end_time * EquationData::year_in_seconds)'
p14073
aS'          break;'
p14074
aS'        TrilinosWrappers::MPI::BlockVector old_old_stokes_solution;'
p14075
aS'        old_old_stokes_solution      = old_stokes_solution;'
p14076
aS'        old_stokes_solution          = stokes_solution;'
p14077
aS'        old_old_temperature_solution = old_temperature_solution;'
p14078
aS'        old_temperature_solution     = temperature_solution;'
p14079
aS'        if (old_time_step > 0)'
p14080
aS'          {'
p14081
aS'            {'
p14082
aS'              TrilinosWrappers::MPI::BlockVector distr_solution(stokes_rhs);'
p14083
aS'              distr_solution = stokes_solution;'
p14084
aS'              TrilinosWrappers::MPI::BlockVector distr_old_solution(stokes_rhs);'
p14085
aS'              distr_old_solution = old_old_stokes_solution;'
p14086
aS'              distr_solution.sadd(1. + time_step / old_time_step,'
p14087
aS'                                  -time_step / old_time_step,'
p14088
aS'                                  distr_old_solution);'
p14089
aS'              stokes_solution = distr_solution;'
p14090
aS'            }'
p14091
aS'            {'
p14092
aS'              TrilinosWrappers::MPI::Vector distr_solution(temperature_rhs);'
p14093
aS'              distr_solution = temperature_solution;'
p14094
aS'              TrilinosWrappers::MPI::Vector distr_old_solution(temperature_rhs);'
p14095
aS'              distr_old_solution = old_old_temperature_solution;'
p14096
aS'              distr_solution.sadd(1. + time_step / old_time_step,'
p14097
aS'                                  -time_step / old_time_step,'
p14098
aS'                                  distr_old_solution);'
p14099
aS'              temperature_solution = distr_solution;'
p14100
aS'            }'
p14101
aS'          }'
p14102
aS'        if ((timestep_number > 0) && (timestep_number % 100 == 0))'
p14103
aS'          computing_timer.print_summary();'
p14104
aS'        time += time_step;'
p14105
aS'        ++timestep_number;'
p14106
aS'      }'
p14107
aS'    while (true);'
p14108
aS'    if ((parameters.generate_graphical_output == true) &&'
p14109
aS'        !((timestep_number - 1) % parameters.graphical_output_interval == 0))'
p14110
aS'      output_results();'
p14111
aS'  }'
p14112
aS'} // namespace Step32'
p14113
aS'int main(int argc, char *argv[])'
p14114
ag9
aS'  try'
p14115
aS'    {'
p14116
aS'      using namespace Step32;'
p14117
aS'      using namespace dealii;'
p14118
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p14119
aS'        argc, argv, numbers::invalid_unsigned_int);'
p14120
aS'      std::string parameter_filename;'
p14121
aS'      if (argc >= 2)'
p14122
aS'        parameter_filename = argv[1];'
p14123
aS'      else'
p14124
aS'        parameter_filename = "step-32.prm";'
p14125
aS'      const int                              dim = 2;'
p14126
aS'      BoussinesqFlowProblem<dim>::Parameters parameters(parameter_filename);'
p14127
aS'      BoussinesqFlowProblem<dim>             flow_problem(parameters);'
p14128
aS'      flow_problem.run();'
p14129
aS'    }'
p14130
aS'  catch (std::exception &exc)'
p14131
aS'    {'
p14132
aS'      std::cerr << std::endl'
p14133
aS'                << std::endl'
p14134
aS'                << "----------------------------------------------------"'
p14135
aS'                << std::endl;'
p14136
aS'      std::cerr << "Exception on processing: " << std::endl'
p14137
aS'                << exc.what() << std::endl'
p14138
aS'                << "Aborting!" << std::endl'
p14139
aS'                << "----------------------------------------------------"'
p14140
aS'                << std::endl;'
p14141
aS'      return 1;'
p14142
aS'    }'
p14143
aS'  catch (...)'
p14144
aS'    {'
p14145
aS'      std::cerr << std::endl'
p14146
aS'                << std::endl'
p14147
aS'                << "----------------------------------------------------"'
p14148
aS'                << std::endl;'
p14149
aS'      std::cerr << "Unknown exception!" << std::endl'
p14150
aS'                << "Aborting!" << std::endl'
p14151
aS'                << "----------------------------------------------------"'
p14152
aS'                << std::endl;'
p14153
aS'      return 1;'
p14154
aS'    }'
p14155
aS'  return 0;'
p14156
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p14157
aS'#include <deal.II/base/function.h>'
p14158
aS'#include <deal.II/base/parameter_handler.h>'
p14159
aS'#include <deal.II/base/function_parser.h>'
p14160
aS'#include <deal.II/base/utilities.h>'
p14161
aS'#include <deal.II/base/conditional_ostream.h>'
p14162
aS'#include <deal.II/lac/vector.h>'
p14163
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p14164
aS'#include <deal.II/grid/tria.h>'
p14165
aS'#include <deal.II/grid/grid_generator.h>'
p14166
aS'#include <deal.II/grid/grid_out.h>'
p14167
aS'#include <deal.II/grid/grid_refinement.h>'
p14168
aS'#include <deal.II/grid/grid_in.h>'
p14169
aS'#include <deal.II/dofs/dof_handler.h>'
p14170
aS'#include <deal.II/dofs/dof_tools.h>'
p14171
aS'#include <deal.II/fe/fe_values.h>'
p14172
aS'#include <deal.II/fe/fe_system.h>'
p14173
aS'#include <deal.II/fe/mapping_q1.h>'
p14174
aS'#include <deal.II/fe/fe_q.h>'
p14175
aS'#include <deal.II/numerics/data_out.h>'
p14176
aS'#include <deal.II/numerics/vector_tools.h>'
p14177
aS'#include <deal.II/numerics/solution_transfer.h>'
p14178
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p14179
aS'#include <deal.II/lac/trilinos_precondition.h>'
p14180
aS'#include <deal.II/lac/trilinos_solver.h>'
p14181
aS'#include <Sacado.hpp>'
p14182
aS'#include <iostream>'
p14183
aS'#include <fstream>'
p14184
aS'#include <vector>'
p14185
aS'#include <memory>'
p14186
aS'#include <array>'
p14187
aS'namespace Step33'
p14188
ag9
aS'  using namespace dealii;'
p14189
aS'  template <int dim>'
p14190
aS'  struct EulerEquations'
p14191
aS'  {'
p14192
aS'    static const unsigned int n_components             = dim + 2;'
p14193
aS'    static const unsigned int first_momentum_component = 0;'
p14194
aS'    static const unsigned int density_component        = dim;'
p14195
aS'    static const unsigned int energy_component         = dim + 1;'
p14196
aS'    static std::vector<std::string> component_names()'
p14197
aS'    {'
p14198
aS'      std::vector<std::string> names(dim, "momentum");'
p14199
aS'      names.emplace_back("density");'
p14200
aS'      names.emplace_back("energy_density");'
p14201
aS'      return names;'
p14202
aS'    }'
p14203
aS'    static std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14204
aS'    component_interpretation()'
p14205
aS'    {'
p14206
aS'      std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14207
aS'        data_component_interpretation('
p14208
aS'          dim, DataComponentInterpretation::component_is_part_of_vector);'
p14209
aS'      data_component_interpretation.push_back('
p14210
aS'        DataComponentInterpretation::component_is_scalar);'
p14211
aS'      data_component_interpretation.push_back('
p14212
aS'        DataComponentInterpretation::component_is_scalar);'
p14213
aS'      return data_component_interpretation;'
p14214
aS'    }'
p14215
aS'    static const double gas_gamma;'
p14216
aS'    template <typename InputVector>'
p14217
aS'    static typename InputVector::value_type'
p14218
aS'    compute_kinetic_energy(const InputVector &W)'
p14219
aS'    {'
p14220
aS'      typename InputVector::value_type kinetic_energy = 0;'
p14221
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14222
aS'        kinetic_energy +='
p14223
aS'          W[first_momentum_component + d] * W[first_momentum_component + d];'
p14224
aS'      kinetic_energy *= 1. / (2 * W[density_component]);'
p14225
aS'      return kinetic_energy;'
p14226
aS'    }'
p14227
aS'    template <typename InputVector>'
p14228
aS'    static typename InputVector::value_type'
p14229
aS'    compute_pressure(const InputVector &W)'
p14230
aS'    {'
p14231
aS'      return ((gas_gamma - 1.0) *'
p14232
aS'    }'
p14233
aS'    template <typename InputVector>'
p14234
aS'    static void compute_flux_matrix(const InputVector &W,'
p14235
aS'                                    ndarray<typename InputVector::value_type,'
p14236
aS'                                            EulerEquations<dim>::n_components,'
p14237
aS'                                            dim> &     flux)'
p14238
aS'    {'
p14239
aS'      const typename InputVector::value_type pressure = compute_pressure(W);'
p14240
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14241
aS'        {'
p14242
aS'          for (unsigned int e = 0; e < dim; ++e)'
p14243
aS'            flux[first_momentum_component + d][e] ='
p14244
aS'              W[first_momentum_component + d] *'
p14245
aS'              W[first_momentum_component + e] / W[density_component];'
p14246
aS'          flux[first_momentum_component + d][d] += pressure;'
p14247
aS'        }'
p14248
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14249
aS'        flux[density_component][d] = W[first_momentum_component + d];'
p14250
aS'      for (unsigned int d = 0; d < dim; ++d)'
p14251
aS'        flux[energy_component][d] = W[first_momentum_component + d] /'
p14252
aS'                                    W[density_component] *'
p14253
aS'    }'
p14254
aS'    template <typename InputVector>'
p14255
aS'    static void numerical_normal_flux('
p14256
aS'      const Tensor<1, dim> &                                      normal,'
p14257
aS'      const InputVector &                                         Wplus,'
p14258
aS'      const InputVector &                                         Wminus,'
p14259
aS'      const double                                                alpha,'
p14260
aS'      std::array<typename InputVector::value_type, n_components> &normal_flux)'
p14261
aS'    {'
p14262
aS'      ndarray<typename InputVector::value_type,'
p14263
aS'              EulerEquations<dim>::n_components,'
p14264
aS'              dim>'
p14265
aS'        iflux, oflux;'
p14266
aS'      compute_flux_matrix(Wplus, iflux);'
p14267
aS'      compute_flux_matrix(Wminus, oflux);'
p14268
aS'      for (unsigned int di = 0; di < n_components; ++di)'
p14269
aS'        {'
p14270
aS'          normal_flux[di] = 0;'
p14271
aS'          for (unsigned int d = 0; d < dim; ++d)'
p14272
aS'            normal_flux[di] += 0.5 * (iflux[di][d] + oflux[di][d]) * normal[d];'
p14273
aS'          normal_flux[di] += 0.5 * alpha * (Wplus[di] - Wminus[di]);'
p14274
aS'        }'
p14275
aS'    }'
p14276
aS'    template <typename InputVector>'
p14277
aS'    static void compute_forcing_vector('
p14278
aS'      const InputVector &                                         W,'
p14279
aS'      std::array<typename InputVector::value_type, n_components> &forcing)'
p14280
aS'    {'
p14281
aS'      const double gravity = -1.0;'
p14282
aS'      for (unsigned int c = 0; c < n_components; ++c)'
p14283
aS'        switch (c)'
p14284
aS'          {'
p14285
aS'            case first_momentum_component + dim - 1:'
p14286
aS'              forcing[c] = gravity * W[density_component];'
p14287
aS'              break;'
p14288
aS'            case energy_component:'
p14289
aS'              forcing[c] = gravity * W[first_momentum_component + dim - 1];'
p14290
aS'              break;'
p14291
aS'            default:'
p14292
aS'              forcing[c] = 0;'
p14293
aS'          }'
p14294
aS'    }'
p14295
aS'    enum BoundaryKind'
p14296
aS'    {'
p14297
aS'      inflow_boundary,'
p14298
aS'      outflow_boundary,'
p14299
aS'      no_penetration_boundary,'
p14300
aS'      pressure_boundary'
p14301
aS'    };'
p14302
aS'    template <typename DataVector>'
p14303
aS'    static void'
p14304
aS'    compute_Wminus(const std::array<BoundaryKind, n_components> &boundary_kind,'
p14305
aS'                   const Tensor<1, dim> &                        normal_vector,'
p14306
aS'                   const DataVector &                            Wplus,'
p14307
aS'                   const Vector<double> &boundary_values,'
p14308
aS'                   const DataVector &    Wminus)'
p14309
aS'    {'
p14310
aS'      for (unsigned int c = 0; c < n_components; c++)'
p14311
aS'        switch (boundary_kind[c])'
p14312
aS'          {'
p14313
aS'            case inflow_boundary:'
p14314
aS'              {'
p14315
aS'                Wminus[c] = boundary_values(c);'
p14316
aS'                break;'
p14317
aS'              }'
p14318
aS'            case outflow_boundary:'
p14319
aS'              {'
p14320
aS'                Wminus[c] = Wplus[c];'
p14321
aS'                break;'
p14322
aS'              }'
p14323
aS'            case pressure_boundary:'
p14324
aS'              {'
p14325
aS'                const typename DataVector::value_type density ='
p14326
aS'                     boundary_values(density_component) :'
p14327
aS'                     Wplus[density_component]);'
p14328
aS'                typename DataVector::value_type kinetic_energy = 0;'
p14329
aS'                for (unsigned int d = 0; d < dim; ++d)'
p14330
aS'                  if (boundary_kind[d] == inflow_boundary)'
p14331
aS'                    kinetic_energy += boundary_values(d) * boundary_values(d);'
p14332
aS'                  else'
p14333
aS'                    kinetic_energy += Wplus[d] * Wplus[d];'
p14334
aS'                kinetic_energy *= 1. / 2. / density;'
p14335
aS'                Wminus[c] ='
p14336
aS'                  boundary_values(c) / (gas_gamma - 1.0) + kinetic_energy;'
p14337
aS'                break;'
p14338
aS'              }'
p14339
aS'            case no_penetration_boundary:'
p14340
aS'              {'
p14341
aS'                typename DataVector::value_type vdotn = 0;'
p14342
aS'                for (unsigned int d = 0; d < dim; d++)'
p14343
aS'                  {'
p14344
aS'                    vdotn += Wplus[d] * normal_vector[d];'
p14345
aS'                  }'
p14346
aS'                Wminus[c] = Wplus[c] - 2.0 * vdotn * normal_vector[c];'
p14347
aS'                break;'
p14348
aS'              }'
p14349
aS'            default:'
p14350
aS'              Assert(false, ExcNotImplemented());'
p14351
aS'          }'
p14352
aS'    }'
p14353
aS'    static void'
p14354
aS'    compute_refinement_indicators(const DoFHandler<dim> &dof_handler,'
p14355
aS'                                  const Mapping<dim> &   mapping,'
p14356
aS'                                  const Vector<double> & solution,'
p14357
aS'                                  Vector<double> &       refinement_indicators)'
p14358
aS'    {'
p14359
aS'      const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();'
p14360
aS'      std::vector<unsigned int> dofs(dofs_per_cell);'
p14361
aS'      const QMidpoint<dim> quadrature_formula;'
p14362
aS'      const UpdateFlags    update_flags = update_gradients;'
p14363
aS'      FEValues<dim>        fe_v(mapping,'
p14364
aS'                         dof_handler.get_fe(),'
p14365
aS'                         quadrature_formula,'
p14366
aS'                         update_flags);'
p14367
aS'      std::vector<std::vector<Tensor<1, dim>>> dU('
p14368
aS'        1, std::vector<Tensor<1, dim>>(n_components));'
p14369
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p14370
aS'        {'
p14371
aS'          const unsigned int cell_no = cell->active_cell_index();'
p14372
aS'          fe_v.reinit(cell);'
p14373
aS'          fe_v.get_function_gradients(solution, dU);'
p14374
aS'          refinement_indicators(cell_no) = std::log('
p14375
aS'            1 + std::sqrt(dU[0][density_component] * dU[0][density_component]));'
p14376
aS'        }'
p14377
aS'    }'
p14378
aS'    class Postprocessor : public DataPostprocessor<dim>'
p14379
aS'    {'
p14380
aS'    public:'
p14381
aS'      Postprocessor(const bool do_schlieren_plot);'
p14382
aS'      virtual void evaluate_vector_field('
p14383
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p14384
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p14385
aS'      virtual std::vector<std::string> get_names() const override;'
p14386
aS'      virtual std::vector<'
p14387
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p14388
aS'      get_data_component_interpretation() const override;'
p14389
aS'      virtual UpdateFlags get_needed_update_flags() const override;'
p14390
aS'    private:'
p14391
aS'      const bool do_schlieren_plot;'
p14392
aS'    };'
p14393
aS'  };'
p14394
aS'  template <int dim>'
p14395
aS'  const double EulerEquations<dim>::gas_gamma = 1.4;'
p14396
aS'  template <int dim>'
p14397
aS'  EulerEquations<dim>::Postprocessor::Postprocessor('
p14398
aS'    const bool do_schlieren_plot)'
p14399
aS'    : do_schlieren_plot(do_schlieren_plot)'
p14400
aS'  {}'
p14401
aS'  template <int dim>'
p14402
aS'  void EulerEquations<dim>::Postprocessor::evaluate_vector_field('
p14403
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p14404
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p14405
aS'  {'
p14406
aS'    const unsigned int n_quadrature_points = inputs.solution_values.size();'
p14407
aS'    if (do_schlieren_plot == true)'
p14408
aS'      Assert(inputs.solution_gradients.size() == n_quadrature_points,'
p14409
aS'             ExcInternalError());'
p14410
aS'    Assert(computed_quantities.size() == n_quadrature_points,'
p14411
aS'           ExcInternalError());'
p14412
aS'    Assert(inputs.solution_values[0].size() == n_components,'
p14413
aS'           ExcInternalError());'
p14414
aS'    if (do_schlieren_plot == true)'
p14415
aS'      {'
p14416
aS'        Assert(computed_quantities[0].size() == dim + 2, ExcInternalError());'
p14417
aS'      }'
p14418
aS'    else'
p14419
aS'      {'
p14420
aS'        Assert(computed_quantities[0].size() == dim + 1, ExcInternalError());'
p14421
aS'      }'
p14422
aS'    for (unsigned int q = 0; q < n_quadrature_points; ++q)'
p14423
aS'      {'
p14424
aS'        const double density = inputs.solution_values[q](density_component);'
p14425
aS'        for (unsigned int d = 0; d < dim; ++d)'
p14426
aS'          computed_quantities[q](d) ='
p14427
aS'            inputs.solution_values[q](first_momentum_component + d) / density;'
p14428
aS'        computed_quantities[q](dim) ='
p14429
aS'          compute_pressure(inputs.solution_values[q]);'
p14430
aS'        if (do_schlieren_plot == true)'
p14431
aS'          computed_quantities[q](dim + 1) ='
p14432
aS'            inputs.solution_gradients[q][density_component] *'
p14433
aS'            inputs.solution_gradients[q][density_component];'
p14434
aS'      }'
p14435
aS'  }'
p14436
aS'  template <int dim>'
p14437
aS'  std::vector<std::string> EulerEquations<dim>::Postprocessor::get_names() const'
p14438
aS'  {'
p14439
aS'    std::vector<std::string> names;'
p14440
aS'    for (unsigned int d = 0; d < dim; ++d)'
p14441
aS'      names.emplace_back("velocity");'
p14442
aS'    names.emplace_back("pressure");'
p14443
aS'    if (do_schlieren_plot == true)'
p14444
aS'      names.emplace_back("schlieren_plot");'
p14445
aS'    return names;'
p14446
aS'  }'
p14447
aS'  template <int dim>'
p14448
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14449
aS'  EulerEquations<dim>::Postprocessor::get_data_component_interpretation() const'
p14450
aS'  {'
p14451
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p14452
aS'      interpretation(dim,'
p14453
aS'                     DataComponentInterpretation::component_is_part_of_vector);'
p14454
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p14455
aS'    if (do_schlieren_plot == true)'
p14456
aS'      interpretation.push_back('
p14457
aS'        DataComponentInterpretation::component_is_scalar);'
p14458
aS'    return interpretation;'
p14459
aS'  }'
p14460
aS'  template <int dim>'
p14461
aS'  UpdateFlags'
p14462
aS'  EulerEquations<dim>::Postprocessor::get_needed_update_flags() const'
p14463
aS'  {'
p14464
aS'    if (do_schlieren_plot == true)'
p14465
aS'      return update_values | update_gradients;'
p14466
aS'    else'
p14467
aS'      return update_values;'
p14468
aS'  }'
p14469
aS'  namespace Parameters'
p14470
aS'  {'
p14471
aS'    struct Solver'
p14472
aS'    {'
p14473
aS'      enum SolverType'
p14474
aS'      {'
p14475
aS'        gmres,'
p14476
aS'        direct'
p14477
aS'      };'
p14478
aS'      SolverType solver;'
p14479
aS'      enum OutputType'
p14480
aS'      {'
p14481
aS'        quiet,'
p14482
aS'        verbose'
p14483
aS'      };'
p14484
aS'      OutputType output;'
p14485
aS'      double linear_residual;'
p14486
aS'      int    max_iterations;'
p14487
aS'      double ilut_fill;'
p14488
aS'      double ilut_atol;'
p14489
aS'      double ilut_rtol;'
p14490
aS'      double ilut_drop;'
p14491
aS'      static void declare_parameters(ParameterHandler &prm);'
p14492
aS'      void        parse_parameters(ParameterHandler &prm);'
p14493
aS'    };'
p14494
aS'    void Solver::declare_parameters(ParameterHandler &prm)'
p14495
aS'    {'
p14496
aS'      prm.enter_subsection("linear solver");'
p14497
aS'      {'
p14498
aS'        prm.declare_entry('
p14499
aS'          "output",'
p14500
aS'          "quiet",'
p14501
aS'          Patterns::Selection("quiet|verbose"),'
p14502
aS'          "State whether output from solver runs should be printed. "'
p14503
aS'          "Choices are <quiet|verbose>.");'
p14504
aS'        prm.declare_entry("method",'
p14505
aS'                          "gmres",'
p14506
aS'                          Patterns::Selection("gmres|direct"),'
p14507
aS'                          "The kind of solver for the linear system. "'
p14508
aS'                          "Choices are <gmres|direct>.");'
p14509
aS'        prm.declare_entry("residual",'
p14510
aS'                          "1e-10",'
p14511
aS'                          Patterns::Double(),'
p14512
aS'                          "Linear solver residual");'
p14513
aS'        prm.declare_entry("max iters",'
p14514
aS'                          "300",'
p14515
aS'                          Patterns::Integer(),'
p14516
aS'                          "Maximum solver iterations");'
p14517
aS'        prm.declare_entry("ilut fill",'
p14518
aS'                          "2",'
p14519
aS'                          Patterns::Double(),'
p14520
aS'                          "Ilut preconditioner fill");'
p14521
aS'        prm.declare_entry("ilut absolute tolerance",'
p14522
aS'                          "1e-9",'
p14523
aS'                          Patterns::Double(),'
p14524
aS'                          "Ilut preconditioner tolerance");'
p14525
aS'        prm.declare_entry("ilut relative tolerance",'
p14526
aS'                          "1.1",'
p14527
aS'                          Patterns::Double(),'
p14528
aS'                          "Ilut relative tolerance");'
p14529
aS'        prm.declare_entry("ilut drop tolerance",'
p14530
aS'                          "1e-10",'
p14531
aS'                          Patterns::Double(),'
p14532
aS'                          "Ilut drop tolerance");'
p14533
aS'      }'
p14534
aS'      prm.leave_subsection();'
p14535
aS'    }'
p14536
aS'    void Solver::parse_parameters(ParameterHandler &prm)'
p14537
aS'    {'
p14538
aS'      prm.enter_subsection("linear solver");'
p14539
aS'      {'
p14540
aS'        const std::string op = prm.get("output");'
p14541
aS'        if (op == "verbose")'
p14542
aS'          output = verbose;'
p14543
aS'        if (op == "quiet")'
p14544
aS'          output = quiet;'
p14545
aS'        const std::string sv = prm.get("method");'
p14546
aS'        if (sv == "direct")'
p14547
aS'          solver = direct;'
p14548
aS'        else if (sv == "gmres")'
p14549
aS'          solver = gmres;'
p14550
aS'        linear_residual = prm.get_double("residual");'
p14551
aS'        max_iterations  = prm.get_integer("max iters");'
p14552
aS'        ilut_fill       = prm.get_double("ilut fill");'
p14553
aS'        ilut_atol       = prm.get_double("ilut absolute tolerance");'
p14554
aS'        ilut_rtol       = prm.get_double("ilut relative tolerance");'
p14555
aS'        ilut_drop       = prm.get_double("ilut drop tolerance");'
p14556
aS'      }'
p14557
aS'      prm.leave_subsection();'
p14558
aS'    }'
p14559
aS'    struct Refinement'
p14560
aS'    {'
p14561
aS'      bool   do_refine;'
p14562
aS'      double shock_val;'
p14563
aS'      double shock_levels;'
p14564
aS'      static void declare_parameters(ParameterHandler &prm);'
p14565
aS'      void        parse_parameters(ParameterHandler &prm);'
p14566
aS'    };'
p14567
aS'    void Refinement::declare_parameters(ParameterHandler &prm)'
p14568
aS'    {'
p14569
aS'      prm.enter_subsection("refinement");'
p14570
aS'      {'
p14571
aS'        prm.declare_entry("refinement",'
p14572
aS'                          "true",'
p14573
aS'                          Patterns::Bool(),'
p14574
aS'                          "Whether to perform mesh refinement or not");'
p14575
aS'        prm.declare_entry("refinement fraction",'
p14576
aS'                          "0.1",'
p14577
aS'                          Patterns::Double(),'
p14578
aS'                          "Fraction of high refinement");'
p14579
aS'        prm.declare_entry("unrefinement fraction",'
p14580
aS'                          "0.1",'
p14581
aS'                          Patterns::Double(),'
p14582
aS'                          "Fraction of low unrefinement");'
p14583
aS'        prm.declare_entry("max elements",'
p14584
aS'                          "1000000",'
p14585
aS'                          Patterns::Double(),'
p14586
aS'                          "maximum number of elements");'
p14587
aS'        prm.declare_entry("shock value",'
p14588
aS'                          "4.0",'
p14589
aS'                          Patterns::Double(),'
p14590
aS'                          "value for shock indicator");'
p14591
aS'        prm.declare_entry("shock levels",'
p14592
aS'                          "3.0",'
p14593
aS'                          Patterns::Double(),'
p14594
aS'                          "number of shock refinement levels");'
p14595
aS'      }'
p14596
aS'      prm.leave_subsection();'
p14597
aS'    }'
p14598
aS'    void Refinement::parse_parameters(ParameterHandler &prm)'
p14599
aS'    {'
p14600
aS'      prm.enter_subsection("refinement");'
p14601
aS'      {'
p14602
aS'        do_refine    = prm.get_bool("refinement");'
p14603
aS'        shock_val    = prm.get_double("shock value");'
p14604
aS'        shock_levels = prm.get_double("shock levels");'
p14605
aS'      }'
p14606
aS'      prm.leave_subsection();'
p14607
aS'    }'
p14608
aS'    struct Flux'
p14609
aS'    {'
p14610
aS'      enum StabilizationKind'
p14611
aS'      {'
p14612
aS'        constant,'
p14613
aS'        mesh_dependent'
p14614
aS'      };'
p14615
aS'      StabilizationKind stabilization_kind;'
p14616
aS'      double stabilization_value;'
p14617
aS'      static void declare_parameters(ParameterHandler &prm);'
p14618
aS'      void        parse_parameters(ParameterHandler &prm);'
p14619
aS'    };'
p14620
aS'    void Flux::declare_parameters(ParameterHandler &prm)'
p14621
aS'    {'
p14622
aS'      prm.enter_subsection("flux");'
p14623
aS'      {'
p14624
aS'        prm.declare_entry('
p14625
aS'          "stab",'
p14626
aS'          "mesh",'
p14627
aS'          Patterns::Selection("constant|mesh"),'
p14628
aS'          "Whether to use a constant stabilization parameter or "'
p14629
aS'          "a mesh-dependent one");'
p14630
aS'        prm.declare_entry("stab value",'
p14631
aS'                          "1",'
p14632
aS'                          Patterns::Double(),'
p14633
aS'                          "alpha stabilization");'
p14634
aS'      }'
p14635
aS'      prm.leave_subsection();'
p14636
aS'    }'
p14637
aS'    void Flux::parse_parameters(ParameterHandler &prm)'
p14638
aS'    {'
p14639
aS'      prm.enter_subsection("flux");'
p14640
aS'      {'
p14641
aS'        const std::string stab = prm.get("stab");'
p14642
aS'        if (stab == "constant")'
p14643
aS'          stabilization_kind = constant;'
p14644
aS'        else if (stab == "mesh")'
p14645
aS'          stabilization_kind = mesh_dependent;'
p14646
aS'        else'
p14647
aS'          AssertThrow(false, ExcNotImplemented());'
p14648
aS'        stabilization_value = prm.get_double("stab value");'
p14649
aS'      }'
p14650
aS'      prm.leave_subsection();'
p14651
aS'    }'
p14652
aS'    struct Output'
p14653
aS'    {'
p14654
aS'      bool   schlieren_plot;'
p14655
aS'      double output_step;'
p14656
aS'      static void declare_parameters(ParameterHandler &prm);'
p14657
aS'      void        parse_parameters(ParameterHandler &prm);'
p14658
aS'    };'
p14659
aS'    void Output::declare_parameters(ParameterHandler &prm)'
p14660
aS'    {'
p14661
aS'      prm.enter_subsection("output");'
p14662
aS'      {'
p14663
aS'        prm.declare_entry("schlieren plot",'
p14664
aS'                          "true",'
p14665
aS'                          Patterns::Bool(),'
p14666
aS'                          "Whether or not to produce schlieren plots");'
p14667
aS'        prm.declare_entry("step",'
p14668
aS'                          "-1",'
p14669
aS'                          Patterns::Double(),'
p14670
aS'                          "Output once per this period");'
p14671
aS'      }'
p14672
aS'      prm.leave_subsection();'
p14673
aS'    }'
p14674
aS'    void Output::parse_parameters(ParameterHandler &prm)'
p14675
aS'    {'
p14676
aS'      prm.enter_subsection("output");'
p14677
aS'      {'
p14678
aS'        schlieren_plot = prm.get_bool("schlieren plot");'
p14679
aS'        output_step    = prm.get_double("step");'
p14680
aS'      }'
p14681
aS'      prm.leave_subsection();'
p14682
aS'    }'
p14683
aS'    template <int dim>'
p14684
aS'    struct AllParameters : public Solver,'
p14685
aS'                           public Refinement,'
p14686
aS'                           public Flux,'
p14687
aS'                           public Output'
p14688
aS'    {'
p14689
aS'      static const unsigned int max_n_boundaries = 10;'
p14690
aS'      struct BoundaryConditions'
p14691
aS'      {'
p14692
aS'        std::array<typename EulerEquations<dim>::BoundaryKind,'
p14693
aS'                   EulerEquations<dim>::n_components>'
p14694
aS'          kind;'
p14695
aS'        FunctionParser<dim> values;'
p14696
aS'        BoundaryConditions();'
p14697
aS'      };'
p14698
aS'      AllParameters();'
p14699
aS'      double diffusion_power;'
p14700
aS'      double time_step, final_time;'
p14701
aS'      double theta;'
p14702
aS'      bool   is_stationary;'
p14703
aS'      std::string mesh_filename;'
p14704
aS'      FunctionParser<dim> initial_conditions;'
p14705
aS'      BoundaryConditions  boundary_conditions[max_n_boundaries];'
p14706
aS'      static void declare_parameters(ParameterHandler &prm);'
p14707
aS'      void        parse_parameters(ParameterHandler &prm);'
p14708
aS'    };'
p14709
aS'    template <int dim>'
p14710
aS'    AllParameters<dim>::BoundaryConditions::BoundaryConditions()'
p14711
aS'      : values(EulerEquations<dim>::n_components)'
p14712
aS'    {'
p14713
aS'      std::fill(kind.begin(),'
p14714
aS'                kind.end(),'
p14715
aS'                EulerEquations<dim>::no_penetration_boundary);'
p14716
aS'    }'
p14717
aS'    template <int dim>'
p14718
aS'    AllParameters<dim>::AllParameters()'
p14719
aS'      : diffusion_power(0.)'
p14720
aS'      , time_step(1.)'
p14721
aS'      , final_time(1.)'
p14722
aS'      , theta(.5)'
p14723
aS'      , is_stationary(true)'
p14724
aS'      , initial_conditions(EulerEquations<dim>::n_components)'
p14725
aS'    {}'
p14726
aS'    template <int dim>'
p14727
aS'    void AllParameters<dim>::declare_parameters(ParameterHandler &prm)'
p14728
aS'    {'
p14729
aS'      prm.declare_entry("mesh",'
p14730
aS'                        "grid.inp",'
p14731
aS'                        Patterns::Anything(),'
p14732
aS'                        "input file name");'
p14733
aS'      prm.declare_entry("diffusion power",'
p14734
aS'                        "2.0",'
p14735
aS'                        Patterns::Double(),'
p14736
aS'                        "power of mesh size for diffusion");'
p14737
aS'      prm.enter_subsection("time stepping");'
p14738
aS'      {'
p14739
aS'        prm.declare_entry("time step",'
p14740
aS'                          "0.1",'
p14741
aS'                          Patterns::Double(0),'
p14742
aS'                          "simulation time step");'
p14743
aS'        prm.declare_entry("final time",'
p14744
aS'                          "10.0",'
p14745
aS'                          Patterns::Double(0),'
p14746
aS'                          "simulation end time");'
p14747
aS'        prm.declare_entry("theta scheme value",'
p14748
aS'                          "0.5",'
p14749
aS'                          Patterns::Double(0, 1),'
p14750
aS'                          "value for theta that interpolated between explicit "'
p14751
aS'                          "Euler (theta=0), Crank-Nicolson (theta=0.5), and "'
p14752
aS'                          "implicit Euler (theta=1).");'
p14753
aS'      }'
p14754
aS'      prm.leave_subsection();'
p14755
aS'      for (unsigned int b = 0; b < max_n_boundaries; ++b)'
p14756
aS'        {'
p14757
aS'          prm.enter_subsection("boundary_" + Utilities::int_to_string(b));'
p14758
aS'          {'
p14759
aS'            prm.declare_entry("no penetration",'
p14760
aS'                              "false",'
p14761
aS'                              Patterns::Bool(),'
p14762
aS'                              "whether the named boundary allows gas to "'
p14763
aS'                              "penetrate or is a rigid wall");'
p14764
aS'            for (unsigned int di = 0; di < EulerEquations<dim>::n_components;'
p14765
aS'                 ++di)'
p14766
aS'              {'
p14767
aS'                prm.declare_entry("w_" + Utilities::int_to_string(di),'
p14768
aS'                                  "outflow",'
p14769
aS'                                  Patterns::Selection('
p14770
aS'                                    "inflow|outflow|pressure"),'
p14771
aS'                                  "<inflow|outflow|pressure>");'
p14772
aS'                prm.declare_entry("w_" + Utilities::int_to_string(di) +'
p14773
aS'                                    " value",'
p14774
aS'                                  "0.0",'
p14775
aS'                                  Patterns::Anything(),'
p14776
aS'                                  "expression in x,y,z");'
p14777
aS'              }'
p14778
aS'          }'
p14779
aS'          prm.leave_subsection();'
p14780
aS'        }'
p14781
aS'      prm.enter_subsection("initial condition");'
p14782
aS'      {'
p14783
aS'        for (unsigned int di = 0; di < EulerEquations<dim>::n_components; ++di)'
p14784
aS'          prm.declare_entry("w_" + Utilities::int_to_string(di) + " value",'
p14785
aS'                            "0.0",'
p14786
aS'                            Patterns::Anything(),'
p14787
aS'                            "expression in x,y,z");'
p14788
aS'      }'
p14789
aS'      prm.leave_subsection();'
p14790
aS'      Parameters::Solver::declare_parameters(prm);'
p14791
aS'      Parameters::Refinement::declare_parameters(prm);'
p14792
aS'      Parameters::Flux::declare_parameters(prm);'
p14793
aS'      Parameters::Output::declare_parameters(prm);'
p14794
aS'    }'
p14795
aS'    template <int dim>'
p14796
aS'    void AllParameters<dim>::parse_parameters(ParameterHandler &prm)'
p14797
aS'    {'
p14798
aS'      mesh_filename   = prm.get("mesh");'
p14799
aS'      diffusion_power = prm.get_double("diffusion power");'
p14800
aS'      prm.enter_subsection("time stepping");'
p14801
aS'      {'
p14802
aS'        time_step = prm.get_double("time step");'
p14803
aS'        if (time_step == 0)'
p14804
aS'          {'
p14805
aS'            is_stationary = true;'
p14806
aS'            time_step     = 1.0;'
p14807
aS'            final_time    = 1.0;'
p14808
aS'          }'
p14809
aS'        else'
p14810
aS'          is_stationary = false;'
p14811
aS'        final_time = prm.get_double("final time");'
p14812
aS'        theta      = prm.get_double("theta scheme value");'
p14813
aS'      }'
p14814
aS'      prm.leave_subsection();'
p14815
aS'      for (unsigned int boundary_id = 0; boundary_id < max_n_boundaries;'
p14816
aS'           ++boundary_id)'
p14817
aS'        {'
p14818
aS'          prm.enter_subsection("boundary_" +'
p14819
aS'                               Utilities::int_to_string(boundary_id));'
p14820
aS'          {'
p14821
aS'            std::vector<std::string> expressions('
p14822
aS'              EulerEquations<dim>::n_components, "0.0");'
p14823
aS'            const bool no_penetration = prm.get_bool("no penetration");'
p14824
aS'            for (unsigned int di = 0; di < EulerEquations<dim>::n_components;'
p14825
aS'                 ++di)'
p14826
aS'              {'
p14827
aS'                const std::string boundary_type ='
p14828
aS'                  prm.get("w_" + Utilities::int_to_string(di));'
p14829
aS'                if ((di < dim) && (no_penetration == true))'
p14830
aS'                  boundary_conditions[boundary_id].kind[di] ='
p14831
aS'                    EulerEquations<dim>::no_penetration_boundary;'
p14832
aS'                else if (boundary_type == "inflow")'
p14833
aS'                  boundary_conditions[boundary_id].kind[di] ='
p14834
aS'                    EulerEquations<dim>::inflow_boundary;'
p14835
aS'                else if (boundary_type == "pressure")'
p14836
aS'                  boundary_conditions[boundary_id].kind[di] ='
p14837
aS'                    EulerEquations<dim>::pressure_boundary;'
p14838
aS'                else if (boundary_type == "outflow")'
p14839
aS'                  boundary_conditions[boundary_id].kind[di] ='
p14840
aS'                    EulerEquations<dim>::outflow_boundary;'
p14841
aS'                else'
p14842
aS'                  AssertThrow(false, ExcNotImplemented());'
p14843
aS'                expressions[di] ='
p14844
aS'                  prm.get("w_" + Utilities::int_to_string(di) + " value");'
p14845
aS'              }'
p14846
aS'            boundary_conditions[boundary_id].values.initialize('
p14847
aS'              FunctionParser<dim>::default_variable_names(),'
p14848
aS'              expressions,'
p14849
aS'              std::map<std::string, double>());'
p14850
aS'          }'
p14851
aS'          prm.leave_subsection();'
p14852
aS'        }'
p14853
aS'      prm.enter_subsection("initial condition");'
p14854
aS'      {'
p14855
aS'        std::vector<std::string> expressions(EulerEquations<dim>::n_components,'
p14856
aS'                                             "0.0");'
p14857
aS'        for (unsigned int di = 0; di < EulerEquations<dim>::n_components; di++)'
p14858
aS'          expressions[di] ='
p14859
aS'            prm.get("w_" + Utilities::int_to_string(di) + " value");'
p14860
aS'        initial_conditions.initialize('
p14861
aS'          FunctionParser<dim>::default_variable_names(),'
p14862
aS'          expressions,'
p14863
aS'          std::map<std::string, double>());'
p14864
aS'      }'
p14865
aS'      prm.leave_subsection();'
p14866
aS'      Parameters::Solver::parse_parameters(prm);'
p14867
aS'      Parameters::Refinement::parse_parameters(prm);'
p14868
aS'      Parameters::Flux::parse_parameters(prm);'
p14869
aS'      Parameters::Output::parse_parameters(prm);'
p14870
aS'    }'
p14871
aS'  } // namespace Parameters'
p14872
aS'  template <int dim>'
p14873
aS'  class ConservationLaw'
p14874
aS'  {'
p14875
aS'  public:'
p14876
aS'    ConservationLaw(const char *input_filename);'
p14877
aS'    void run();'
p14878
aS'  private:'
p14879
aS'    void setup_system();'
p14880
aS'    void assemble_system();'
p14881
aS'    void assemble_cell_term(const FEValues<dim> &                       fe_v,'
p14882
aS'                            const std::vector<types::global_dof_index> &dofs);'
p14883
aS'    void assemble_face_term('
p14884
aS'      const unsigned int                          face_no,'
p14885
aS'      const FEFaceValuesBase<dim> &               fe_v,'
p14886
aS'      const FEFaceValuesBase<dim> &               fe_v_neighbor,'
p14887
aS'      const std::vector<types::global_dof_index> &dofs,'
p14888
aS'      const std::vector<types::global_dof_index> &dofs_neighbor,'
p14889
aS'      const bool                                  external_face,'
p14890
aS'      const unsigned int                          boundary_id,'
p14891
aS'      const double                                face_diameter);'
p14892
aS'    std::pair<unsigned int, double> solve(Vector<double> &solution);'
p14893
aS'    void compute_refinement_indicators(Vector<double> &indicator) const;'
p14894
aS'    void refine_grid(const Vector<double> &indicator);'
p14895
aS'    void output_results() const;'
p14896
aS'    Triangulation<dim>   triangulation;'
p14897
aS'    const MappingQ1<dim> mapping;'
p14898
aS'    const FESystem<dim> fe;'
p14899
aS'    DoFHandler<dim>     dof_handler;'
p14900
aS'    const QGauss<dim>     quadrature;'
p14901
aS'    const QGauss<dim - 1> face_quadrature;'
p14902
aS'    Vector<double> old_solution;'
p14903
aS'    Vector<double> current_solution;'
p14904
aS'    Vector<double> predictor;'
p14905
aS'    Vector<double> right_hand_side;'
p14906
aS'    TrilinosWrappers::SparseMatrix system_matrix;'
p14907
aS'    Parameters::AllParameters<dim> parameters;'
p14908
aS'    ConditionalOStream             verbose_cout;'
p14909
aS'  };'
p14910
aS'  template <int dim>'
p14911
aS'  ConservationLaw<dim>::ConservationLaw(const char *input_filename)'
p14912
aS'    : mapping()'
p14913
aS'    , fe(FE_Q<dim>(1), EulerEquations<dim>::n_components)'
p14914
aS'    , dof_handler(triangulation)'
p14915
aS'    , quadrature(fe.degree + 1)'
p14916
aS'    , face_quadrature(fe.degree + 1)'
p14917
aS'    , verbose_cout(std::cout, false)'
p14918
aS'  {'
p14919
aS'    ParameterHandler prm;'
p14920
aS'    Parameters::AllParameters<dim>::declare_parameters(prm);'
p14921
aS'    prm.parse_input(input_filename);'
p14922
aS'    parameters.parse_parameters(prm);'
p14923
aS'    verbose_cout.set_condition(parameters.output =='
p14924
aS'                               Parameters::Solver::verbose);'
p14925
aS'  }'
p14926
aS'  template <int dim>'
p14927
aS'  void ConservationLaw<dim>::setup_system()'
p14928
aS'  {'
p14929
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p14930
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p14931
aS'    system_matrix.reinit(dsp);'
p14932
aS'  }'
p14933
aS'  template <int dim>'
p14934
aS'  void ConservationLaw<dim>::assemble_system()'
p14935
aS'  {'
p14936
aS'    const unsigned int dofs_per_cell = dof_handler.get_fe().n_dofs_per_cell();'
p14937
aS'    std::vector<types::global_dof_index> dof_indices(dofs_per_cell);'
p14938
aS'    std::vector<types::global_dof_index> dof_indices_neighbor(dofs_per_cell);'
p14939
aS'    const UpdateFlags update_flags = update_values | update_gradients |'
p14940
aS'                                     update_quadrature_points |'
p14941
aS'                                     update_JxW_values,'
p14942
aS'                      face_update_flags ='
p14943
aS'                        update_values | update_quadrature_points |'
p14944
aS'                        update_JxW_values | update_normal_vectors,'
p14945
aS'                      neighbor_face_update_flags = update_values;'
p14946
aS'    FEValues<dim>        fe_v(mapping, fe, quadrature, update_flags);'
p14947
aS'    FEFaceValues<dim>    fe_v_face(mapping,'
p14948
aS'                                fe,'
p14949
aS'                                face_quadrature,'
p14950
aS'                                face_update_flags);'
p14951
aS'    FESubfaceValues<dim> fe_v_subface(mapping,'
p14952
aS'                                      fe,'
p14953
aS'                                      face_quadrature,'
p14954
aS'                                      face_update_flags);'
p14955
aS'    FEFaceValues<dim>    fe_v_face_neighbor(mapping,'
p14956
aS'                                         fe,'
p14957
aS'                                         face_quadrature,'
p14958
aS'                                         neighbor_face_update_flags);'
p14959
aS'    FESubfaceValues<dim> fe_v_subface_neighbor(mapping,'
p14960
aS'                                               fe,'
p14961
aS'                                               face_quadrature,'
p14962
aS'                                               neighbor_face_update_flags);'
p14963
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p14964
aS'      {'
p14965
aS'        fe_v.reinit(cell);'
p14966
aS'        cell->get_dof_indices(dof_indices);'
p14967
aS'        assemble_cell_term(fe_v, dof_indices);'
p14968
aS'        for (const auto face_no : cell->face_indices())'
p14969
aS'          if (cell->at_boundary(face_no))'
p14970
aS'            {'
p14971
aS'              fe_v_face.reinit(cell, face_no);'
p14972
aS'              assemble_face_term(face_no,'
p14973
aS'                                 fe_v_face,'
p14974
aS'                                 fe_v_face,'
p14975
aS'                                 dof_indices,'
p14976
aS'                                 std::vector<types::global_dof_index>(),'
p14977
aS'                                 true,'
p14978
aS'                                 cell->face(face_no)->boundary_id(),'
p14979
aS'                                 cell->face(face_no)->diameter());'
p14980
aS'            }'
p14981
aS'          else'
p14982
aS'            {'
p14983
aS'              if (cell->neighbor(face_no)->has_children())'
p14984
aS'                {'
p14985
aS'                  const unsigned int neighbor2 ='
p14986
aS'                    cell->neighbor_of_neighbor(face_no);'
p14987
aS'                  for (unsigned int subface_no = 0;'
p14988
aS'                       subface_no < cell->face(face_no)->n_children();'
p14989
aS'                       ++subface_no)'
p14990
aS'                    {'
p14991
aS'                      const typename DoFHandler<dim>::active_cell_iterator'
p14992
aS'                        neighbor_child ='
p14993
aS'                          cell->neighbor_child_on_subface(face_no, subface_no);'
p14994
aS'                      Assert(neighbor_child->face(neighbor2) =='
p14995
aS'                               cell->face(face_no)->child(subface_no),'
p14996
aS'                             ExcInternalError());'
p14997
aS'                      Assert(neighbor_child->is_active(), ExcInternalError());'
p14998
aS'                      fe_v_subface.reinit(cell, face_no, subface_no);'
p14999
aS'                      fe_v_face_neighbor.reinit(neighbor_child, neighbor2);'
p15000
aS'                      neighbor_child->get_dof_indices(dof_indices_neighbor);'
p15001
aS'                      assemble_face_term('
p15002
aS'                        face_no,'
p15003
aS'                        fe_v_subface,'
p15004
aS'                        fe_v_face_neighbor,'
p15005
aS'                        dof_indices,'
p15006
aS'                        dof_indices_neighbor,'
p15007
aS'                        false,'
p15008
aS'                        numbers::invalid_unsigned_int,'
p15009
aS'                        neighbor_child->face(neighbor2)->diameter());'
p15010
aS'                    }'
p15011
aS'                }'
p15012
aS'              else if (cell->neighbor(face_no)->level() != cell->level())'
p15013
aS'                {'
p15014
aS'                  const typename DoFHandler<dim>::cell_iterator neighbor ='
p15015
aS'                    cell->neighbor(face_no);'
p15016
aS'                  Assert(neighbor->level() == cell->level() - 1,'
p15017
aS'                         ExcInternalError());'
p15018
aS'                  neighbor->get_dof_indices(dof_indices_neighbor);'
p15019
aS'                  const std::pair<unsigned int, unsigned int> faceno_subfaceno ='
p15020
aS'                    cell->neighbor_of_coarser_neighbor(face_no);'
p15021
aS'                  const unsigned int neighbor_face_no = faceno_subfaceno.first,'
p15022
aS'                                     neighbor_subface_no ='
p15023
aS'                                       faceno_subfaceno.second;'
p15024
aS'                  Assert(neighbor->neighbor_child_on_subface('
p15025
aS'                           neighbor_face_no, neighbor_subface_no) == cell,'
p15026
aS'                         ExcInternalError());'
p15027
aS'                  fe_v_face.reinit(cell, face_no);'
p15028
aS'                  fe_v_subface_neighbor.reinit(neighbor,'
p15029
aS'                                               neighbor_face_no,'
p15030
aS'                                               neighbor_subface_no);'
p15031
aS'                  assemble_face_term(face_no,'
p15032
aS'                                     fe_v_face,'
p15033
aS'                                     fe_v_subface_neighbor,'
p15034
aS'                                     dof_indices,'
p15035
aS'                                     dof_indices_neighbor,'
p15036
aS'                                     false,'
p15037
aS'                                     numbers::invalid_unsigned_int,'
p15038
aS'                                     cell->face(face_no)->diameter());'
p15039
aS'                }'
p15040
aS'            }'
p15041
aS'      }'
p15042
aS'  }'
p15043
aS'  template <int dim>'
p15044
aS'  void ConservationLaw<dim>::assemble_cell_term('
p15045
aS'    const FEValues<dim> &                       fe_v,'
p15046
aS'    const std::vector<types::global_dof_index> &dof_indices)'
p15047
aS'  {'
p15048
aS'    const unsigned int dofs_per_cell = fe_v.dofs_per_cell;'
p15049
aS'    const unsigned int n_q_points    = fe_v.n_quadrature_points;'
p15050
aS'    Table<2, Sacado::Fad::DFad<double>> W(n_q_points,'
p15051
aS'                                          EulerEquations<dim>::n_components);'
p15052
aS'    Table<2, double> W_old(n_q_points, EulerEquations<dim>::n_components);'
p15053
aS'    Table<3, Sacado::Fad::DFad<double>> grad_W('
p15054
aS'      n_q_points, EulerEquations<dim>::n_components, dim);'
p15055
aS'    Table<3, double> grad_W_old(n_q_points,'
p15056
aS'                                EulerEquations<dim>::n_components,'
p15057
aS'                                dim);'
p15058
aS'    std::vector<double> residual_derivatives(dofs_per_cell);'
p15059
aS'    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values('
p15060
aS'      dofs_per_cell);'
p15061
aS'    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15062
aS'      independent_local_dof_values[i] = current_solution(dof_indices[i]);'
p15063
aS'    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15064
aS'      independent_local_dof_values[i].diff(i, dofs_per_cell);'
p15065
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15066
aS'      for (unsigned int c = 0; c < EulerEquations<dim>::n_components; ++c)'
p15067
aS'        {'
p15068
aS'          W[q][c]     = 0;'
p15069
aS'          W_old[q][c] = 0;'
p15070
aS'          for (unsigned int d = 0; d < dim; ++d)'
p15071
aS'            {'
p15072
aS'              grad_W[q][c][d]     = 0;'
p15073
aS'              grad_W_old[q][c][d] = 0;'
p15074
aS'            }'
p15075
aS'        }'
p15076
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15077
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15078
aS'        {'
p15079
aS'          const unsigned int c ='
p15080
aS'            fe_v.get_fe().system_to_component_index(i).first;'
p15081
aS'          W[q][c] += independent_local_dof_values[i] *'
p15082
aS'                     fe_v.shape_value_component(i, q, c);'
p15083
aS'          W_old[q][c] +='
p15084
aS'            old_solution(dof_indices[i]) * fe_v.shape_value_component(i, q, c);'
p15085
aS'          for (unsigned int d = 0; d < dim; d++)'
p15086
aS'            {'
p15087
aS'              grad_W[q][c][d] += independent_local_dof_values[i] *'
p15088
aS'                                 fe_v.shape_grad_component(i, q, c)[d];'
p15089
aS'              grad_W_old[q][c][d] += old_solution(dof_indices[i]) *'
p15090
aS'                                     fe_v.shape_grad_component(i, q, c)[d];'
p15091
aS'            }'
p15092
aS'        }'
p15093
aS'    std::vector<ndarray<Sacado::Fad::DFad<double>,'
p15094
aS'                        EulerEquations<dim>::n_components,'
p15095
aS'                        dim>>'
p15096
aS'      flux(n_q_points);'
p15097
aS'    std::vector<ndarray<double, EulerEquations<dim>::n_components, dim>>'
p15098
aS'      flux_old(n_q_points);'
p15099
aS'    std::vector<'
p15100
aS'      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>'
p15101
aS'      forcing(n_q_points);'
p15102
aS'    std::vector<std::array<double, EulerEquations<dim>::n_components>>'
p15103
aS'      forcing_old(n_q_points);'
p15104
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15105
aS'      {'
p15106
aS'        EulerEquations<dim>::compute_flux_matrix(W_old[q], flux_old[q]);'
p15107
aS'        EulerEquations<dim>::compute_forcing_vector(W_old[q], forcing_old[q]);'
p15108
aS'        EulerEquations<dim>::compute_flux_matrix(W[q], flux[q]);'
p15109
aS'        EulerEquations<dim>::compute_forcing_vector(W[q], forcing[q]);'
p15110
aS'      }'
p15111
aS'    for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p15112
aS'      {'
p15113
aS'        Sacado::Fad::DFad<double> R_i = 0;'
p15114
aS'        const unsigned int component_i ='
p15115
aS'          fe_v.get_fe().system_to_component_index(i).first;'
p15116
aS'        for (unsigned int point = 0; point < fe_v.n_quadrature_points; ++point)'
p15117
aS'          {'
p15118
aS'            if (parameters.is_stationary == false)'
p15119
aS'              R_i += 1.0 / parameters.time_step *'
p15120
aS'                     fe_v.shape_value_component(i, point, component_i) *'
p15121
aS'                     fe_v.JxW(point);'
p15122
aS'            for (unsigned int d = 0; d < dim; d++)'
p15123
aS'              R_i -='
p15124
aS'                fe_v.shape_grad_component(i, point, component_i)[d] *'
p15125
aS'                fe_v.JxW(point);'
p15126
aS'            for (unsigned int d = 0; d < dim; d++)'
p15127
aS'              R_i +='
p15128
aS'                1.0 *'
p15129
aS'                std::pow(fe_v.get_cell()->diameter(),'
p15130
aS'                         parameters.diffusion_power) *'
p15131
aS'                fe_v.shape_grad_component(i, point, component_i)[d] *'
p15132
aS'                fe_v.JxW(point);'
p15133
aS'            R_i -='
p15134
aS'              fe_v.shape_value_component(i, point, component_i) *'
p15135
aS'              fe_v.JxW(point);'
p15136
aS'          }'
p15137
aS'        for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p15138
aS'          residual_derivatives[k] = R_i.fastAccessDx(k);'
p15139
aS'        system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);'
p15140
aS'        right_hand_side(dof_indices[i]) -= R_i.val();'
p15141
aS'      }'
p15142
aS'  }'
p15143
aS'  template <int dim>'
p15144
aS'  void ConservationLaw<dim>::assemble_face_term('
p15145
aS'    const unsigned int                          face_no,'
p15146
aS'    const FEFaceValuesBase<dim> &               fe_v,'
p15147
aS'    const FEFaceValuesBase<dim> &               fe_v_neighbor,'
p15148
aS'    const std::vector<types::global_dof_index> &dof_indices,'
p15149
aS'    const std::vector<types::global_dof_index> &dof_indices_neighbor,'
p15150
aS'    const bool                                  external_face,'
p15151
aS'    const unsigned int                          boundary_id,'
p15152
aS'    const double                                face_diameter)'
p15153
aS'  {'
p15154
aS'    const unsigned int n_q_points    = fe_v.n_quadrature_points;'
p15155
aS'    const unsigned int dofs_per_cell = fe_v.dofs_per_cell;'
p15156
aS'    std::vector<Sacado::Fad::DFad<double>> independent_local_dof_values('
p15157
aS'      dofs_per_cell),'
p15158
aS'      independent_neighbor_dof_values(external_face == false ? dofs_per_cell :'
p15159
aS'                                                               0);'
p15160
aS'    const unsigned int n_independent_variables ='
p15161
aS'    for (unsigned int i = 0; i < dofs_per_cell; i++)'
p15162
aS'      {'
p15163
aS'        independent_local_dof_values[i] = current_solution(dof_indices[i]);'
p15164
aS'        independent_local_dof_values[i].diff(i, n_independent_variables);'
p15165
aS'      }'
p15166
aS'    if (external_face == false)'
p15167
aS'      for (unsigned int i = 0; i < dofs_per_cell; i++)'
p15168
aS'        {'
p15169
aS'          independent_neighbor_dof_values[i] ='
p15170
aS'            current_solution(dof_indices_neighbor[i]);'
p15171
aS'          independent_neighbor_dof_values[i].diff(i + dofs_per_cell,'
p15172
aS'                                                  n_independent_variables);'
p15173
aS'        }'
p15174
aS'    Table<2, Sacado::Fad::DFad<double>> Wplus('
p15175
aS'      n_q_points, EulerEquations<dim>::n_components),'
p15176
aS'      Wminus(n_q_points, EulerEquations<dim>::n_components);'
p15177
aS'    Table<2, double> Wplus_old(n_q_points, EulerEquations<dim>::n_components),'
p15178
aS'      Wminus_old(n_q_points, EulerEquations<dim>::n_components);'
p15179
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15180
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15181
aS'        {'
p15182
aS'          const unsigned int component_i ='
p15183
aS'            fe_v.get_fe().system_to_component_index(i).first;'
p15184
aS'          Wplus[q][component_i] +='
p15185
aS'            independent_local_dof_values[i] *'
p15186
aS'            fe_v.shape_value_component(i, q, component_i);'
p15187
aS'          Wplus_old[q][component_i] +='
p15188
aS'            old_solution(dof_indices[i]) *'
p15189
aS'            fe_v.shape_value_component(i, q, component_i);'
p15190
aS'        }'
p15191
aS'    if (external_face == false)'
p15192
aS'      {'
p15193
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p15194
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p15195
aS'            {'
p15196
aS'              const unsigned int component_i ='
p15197
aS'                fe_v_neighbor.get_fe().system_to_component_index(i).first;'
p15198
aS'              Wminus[q][component_i] +='
p15199
aS'                independent_neighbor_dof_values[i] *'
p15200
aS'                fe_v_neighbor.shape_value_component(i, q, component_i);'
p15201
aS'              Wminus_old[q][component_i] +='
p15202
aS'                old_solution(dof_indices_neighbor[i]) *'
p15203
aS'                fe_v_neighbor.shape_value_component(i, q, component_i);'
p15204
aS'            }'
p15205
aS'      }'
p15206
aS'    else'
p15207
aS'      {'
p15208
aS'        Assert(boundary_id < Parameters::AllParameters<dim>::max_n_boundaries,'
p15209
aS'               ExcIndexRange(boundary_id,'
p15210
aS'                             0,'
p15211
aS'                             Parameters::AllParameters<dim>::max_n_boundaries));'
p15212
aS'        std::vector<Vector<double>> boundary_values('
p15213
aS'          n_q_points, Vector<double>(EulerEquations<dim>::n_components));'
p15214
aS'        parameters.boundary_conditions[boundary_id].values.vector_value_list('
p15215
aS'          fe_v.get_quadrature_points(), boundary_values);'
p15216
aS'        for (unsigned int q = 0; q < n_q_points; q++)'
p15217
aS'          {'
p15218
aS'            EulerEquations<dim>::compute_Wminus('
p15219
aS'              parameters.boundary_conditions[boundary_id].kind,'
p15220
aS'              fe_v.normal_vector(q),'
p15221
aS'              Wplus[q],'
p15222
aS'              boundary_values[q],'
p15223
aS'              Wminus[q]);'
p15224
aS'            EulerEquations<dim>::compute_Wminus('
p15225
aS'              parameters.boundary_conditions[boundary_id].kind,'
p15226
aS'              fe_v.normal_vector(q),'
p15227
aS'              Wplus_old[q],'
p15228
aS'              boundary_values[q],'
p15229
aS'              Wminus_old[q]);'
p15230
aS'          }'
p15231
aS'      }'
p15232
aS'    std::vector<'
p15233
aS'      std::array<Sacado::Fad::DFad<double>, EulerEquations<dim>::n_components>>'
p15234
aS'      normal_fluxes(n_q_points);'
p15235
aS'    std::vector<std::array<double, EulerEquations<dim>::n_components>>'
p15236
aS'      normal_fluxes_old(n_q_points);'
p15237
aS'    double alpha;'
p15238
aS'    switch (parameters.stabilization_kind)'
p15239
aS'      {'
p15240
aS'        case Parameters::Flux::constant:'
p15241
aS'          alpha = parameters.stabilization_value;'
p15242
aS'          break;'
p15243
aS'        case Parameters::Flux::mesh_dependent:'
p15244
aS'          alpha = face_diameter / (2.0 * parameters.time_step);'
p15245
aS'          break;'
p15246
aS'        default:'
p15247
aS'          Assert(false, ExcNotImplemented());'
p15248
aS'          alpha = 1;'
p15249
aS'      }'
p15250
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p15251
aS'      {'
p15252
aS'        EulerEquations<dim>::numerical_normal_flux('
p15253
aS'          fe_v.normal_vector(q), Wplus[q], Wminus[q], alpha, normal_fluxes[q]);'
p15254
aS'        EulerEquations<dim>::numerical_normal_flux(fe_v.normal_vector(q),'
p15255
aS'                                                   Wplus_old[q],'
p15256
aS'                                                   Wminus_old[q],'
p15257
aS'                                                   alpha,'
p15258
aS'                                                   normal_fluxes_old[q]);'
p15259
aS'      }'
p15260
aS'    std::vector<double> residual_derivatives(dofs_per_cell);'
p15261
aS'    for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p15262
aS'      if (fe_v.get_fe().has_support_on_face(i, face_no) == true)'
p15263
aS'        {'
p15264
aS'          Sacado::Fad::DFad<double> R_i = 0;'
p15265
aS'          for (unsigned int point = 0; point < n_q_points; ++point)'
p15266
aS'            {'
p15267
aS'              const unsigned int component_i ='
p15268
aS'                fe_v.get_fe().system_to_component_index(i).first;'
p15269
aS'              R_i += (parameters.theta * normal_fluxes[point][component_i] +'
p15270
aS'                        normal_fluxes_old[point][component_i]) *'
p15271
aS'                     fe_v.shape_value_component(i, point, component_i) *'
p15272
aS'                     fe_v.JxW(point);'
p15273
aS'            }'
p15274
aS'          for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p15275
aS'            residual_derivatives[k] = R_i.fastAccessDx(k);'
p15276
aS'          system_matrix.add(dof_indices[i], dof_indices, residual_derivatives);'
p15277
aS'          if (external_face == false)'
p15278
aS'            {'
p15279
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p15280
aS'                residual_derivatives[k] = R_i.fastAccessDx(dofs_per_cell + k);'
p15281
aS'              system_matrix.add(dof_indices[i],'
p15282
aS'                                dof_indices_neighbor,'
p15283
aS'                                residual_derivatives);'
p15284
aS'            }'
p15285
aS'          right_hand_side(dof_indices[i]) -= R_i.val();'
p15286
aS'        }'
p15287
aS'  }'
p15288
aS'  template <int dim>'
p15289
aS'  std::pair<unsigned int, double>'
p15290
aS'  ConservationLaw<dim>::solve(Vector<double> &newton_update)'
p15291
aS'  {'
p15292
aS'    switch (parameters.solver)'
p15293
aS'      {'
p15294
aS'        case Parameters::Solver::direct:'
p15295
aS'          {'
p15296
aS'            SolverControl                                  solver_control(1, 0);'
p15297
aS'            TrilinosWrappers::SolverDirect::AdditionalData data('
p15298
aS'              parameters.output == Parameters::Solver::verbose);'
p15299
aS'            TrilinosWrappers::SolverDirect direct(solver_control, data);'
p15300
aS'            direct.solve(system_matrix, newton_update, right_hand_side);'
p15301
aS'            return {solver_control.last_step(), solver_control.last_value()};'
p15302
aS'          }'
p15303
aS'        case Parameters::Solver::gmres:'
p15304
aS'          {'
p15305
aS'            Epetra_Vector x(View,'
p15306
aS'                            system_matrix.trilinos_matrix().DomainMap(),'
p15307
aS'                            newton_update.begin());'
p15308
aS'            Epetra_Vector b(View,'
p15309
aS'                            system_matrix.trilinos_matrix().RangeMap(),'
p15310
aS'                            right_hand_side.begin());'
p15311
aS'            AztecOO solver;'
p15312
aS'            solver.SetAztecOption('
p15313
aS'              AZ_output,'
p15314
aS'                                                                AZ_all));'
p15315
aS'            solver.SetAztecOption(AZ_solver, AZ_gmres);'
p15316
aS'            solver.SetRHS(&b);'
p15317
aS'            solver.SetLHS(&x);'
p15318
aS'            solver.SetAztecOption(AZ_precond, AZ_dom_decomp);'
p15319
aS'            solver.SetAztecOption(AZ_subdomain_solve, AZ_ilut);'
p15320
aS'            solver.SetAztecOption(AZ_overlap, 0);'
p15321
aS'            solver.SetAztecOption(AZ_reorder, 0);'
p15322
aS'            solver.SetAztecParam(AZ_drop, parameters.ilut_drop);'
p15323
aS'            solver.SetAztecParam(AZ_ilut_fill, parameters.ilut_fill);'
p15324
aS'            solver.SetAztecParam(AZ_athresh, parameters.ilut_atol);'
p15325
aS'            solver.SetAztecParam(AZ_rthresh, parameters.ilut_rtol);'
p15326
aS'            solver.SetUserMatrix('
p15327
aS'              const_cast<Epetra_CrsMatrix *>(&system_matrix.trilinos_matrix()));'
p15328
aS'            solver.Iterate(parameters.max_iterations,'
p15329
aS'                           parameters.linear_residual);'
p15330
aS'            return {solver.NumIters(), solver.TrueResidual()};'
p15331
aS'          }'
p15332
aS'      }'
p15333
aS'    Assert(false, ExcNotImplemented());'
p15334
aS'    return {0, 0};'
p15335
aS'  }'
p15336
aS'  template <int dim>'
p15337
aS'  void ConservationLaw<dim>::compute_refinement_indicators('
p15338
aS'    Vector<double> &refinement_indicators) const'
p15339
aS'  {'
p15340
aS'    EulerEquations<dim>::compute_refinement_indicators(dof_handler,'
p15341
aS'                                                       mapping,'
p15342
aS'                                                       predictor,'
p15343
aS'                                                       refinement_indicators);'
p15344
aS'  }'
p15345
aS'  template <int dim>'
p15346
aS'  void'
p15347
aS'  ConservationLaw<dim>::refine_grid(const Vector<double> &refinement_indicators)'
p15348
aS'  {'
p15349
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p15350
aS'      {'
p15351
aS'        const unsigned int cell_no = cell->active_cell_index();'
p15352
aS'        cell->clear_coarsen_flag();'
p15353
aS'        cell->clear_refine_flag();'
p15354
aS'        if ((cell->level() < parameters.shock_levels) &&'
p15355
aS'          cell->set_refine_flag();'
p15356
aS'        else if ((cell->level() > 0) &&'
p15357
aS'                  0.75 * parameters.shock_val))'
p15358
aS'          cell->set_coarsen_flag();'
p15359
aS'      }'
p15360
aS'    std::vector<Vector<double>> transfer_in;'
p15361
aS'    std::vector<Vector<double>> transfer_out;'
p15362
aS'    transfer_in.push_back(old_solution);'
p15363
aS'    transfer_in.push_back(predictor);'
p15364
aS'    triangulation.prepare_coarsening_and_refinement();'
p15365
aS'    SolutionTransfer<dim> soltrans(dof_handler);'
p15366
aS'    soltrans.prepare_for_coarsening_and_refinement(transfer_in);'
p15367
aS'    triangulation.execute_coarsening_and_refinement();'
p15368
aS'    dof_handler.clear();'
p15369
aS'    dof_handler.distribute_dofs(fe);'
p15370
aS'    {'
p15371
aS'      Vector<double> new_old_solution(1);'
p15372
aS'      Vector<double> new_predictor(1);'
p15373
aS'      transfer_out.push_back(new_old_solution);'
p15374
aS'      transfer_out.push_back(new_predictor);'
p15375
aS'      transfer_out[0].reinit(dof_handler.n_dofs());'
p15376
aS'      transfer_out[1].reinit(dof_handler.n_dofs());'
p15377
aS'    }'
p15378
aS'    soltrans.interpolate(transfer_in, transfer_out);'
p15379
aS'    old_solution.reinit(transfer_out[0].size());'
p15380
aS'    old_solution = transfer_out[0];'
p15381
aS'    predictor.reinit(transfer_out[1].size());'
p15382
aS'    predictor = transfer_out[1];'
p15383
aS'    current_solution.reinit(dof_handler.n_dofs());'
p15384
aS'    current_solution = old_solution;'
p15385
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p15386
aS'  }'
p15387
aS'  template <int dim>'
p15388
aS'  void ConservationLaw<dim>::output_results() const'
p15389
aS'  {'
p15390
aS'    typename EulerEquations<dim>::Postprocessor postprocessor('
p15391
aS'      parameters.schlieren_plot);'
p15392
aS'    DataOut<dim> data_out;'
p15393
aS'    data_out.attach_dof_handler(dof_handler);'
p15394
aS'    data_out.add_data_vector(current_solution,'
p15395
aS'                             EulerEquations<dim>::component_names(),'
p15396
aS'                             DataOut<dim>::type_dof_data,'
p15397
aS'                             EulerEquations<dim>::component_interpretation());'
p15398
aS'    data_out.add_data_vector(current_solution, postprocessor);'
p15399
aS'    data_out.build_patches();'
p15400
aS'    static unsigned int output_file_number = 0;'
p15401
aS'    std::string         filename ='
p15402
aS'      "solution-" + Utilities::int_to_string(output_file_number, 3) + ".vtk";'
p15403
aS'    std::ofstream output(filename);'
p15404
aS'    data_out.write_vtk(output);'
p15405
aS'    ++output_file_number;'
p15406
aS'  }'
p15407
aS'  template <int dim>'
p15408
aS'  void ConservationLaw<dim>::run()'
p15409
aS'  {'
p15410
aS'    {'
p15411
aS'      GridIn<dim> grid_in;'
p15412
aS'      grid_in.attach_triangulation(triangulation);'
p15413
aS'      std::ifstream input_file(parameters.mesh_filename);'
p15414
aS'      Assert(input_file, ExcFileNotOpen(parameters.mesh_filename.c_str()));'
p15415
aS'      grid_in.read_ucd(input_file);'
p15416
aS'    }'
p15417
aS'    dof_handler.clear();'
p15418
aS'    dof_handler.distribute_dofs(fe);'
p15419
aS'    old_solution.reinit(dof_handler.n_dofs());'
p15420
aS'    current_solution.reinit(dof_handler.n_dofs());'
p15421
aS'    predictor.reinit(dof_handler.n_dofs());'
p15422
aS'    right_hand_side.reinit(dof_handler.n_dofs());'
p15423
aS'    setup_system();'
p15424
aS'    VectorTools::interpolate(dof_handler,'
p15425
aS'                             parameters.initial_conditions,'
p15426
aS'                             old_solution);'
p15427
aS'    current_solution = old_solution;'
p15428
aS'    predictor        = old_solution;'
p15429
aS'    if (parameters.do_refine == true)'
p15430
aS'      for (unsigned int i = 0; i < parameters.shock_levels; ++i)'
p15431
aS'        {'
p15432
aS'          Vector<double> refinement_indicators(triangulation.n_active_cells());'
p15433
aS'          compute_refinement_indicators(refinement_indicators);'
p15434
aS'          refine_grid(refinement_indicators);'
p15435
aS'          setup_system();'
p15436
aS'          VectorTools::interpolate(dof_handler,'
p15437
aS'                                   parameters.initial_conditions,'
p15438
aS'                                   old_solution);'
p15439
aS'          current_solution = old_solution;'
p15440
aS'          predictor        = old_solution;'
p15441
aS'        }'
p15442
aS'    output_results();'
p15443
aS'    Vector<double> newton_update(dof_handler.n_dofs());'
p15444
aS'    double time        = 0;'
p15445
aS'    double next_output = time + parameters.output_step;'
p15446
aS'    predictor = old_solution;'
p15447
aS'    while (time < parameters.final_time)'
p15448
aS'      {'
p15449
aS'        std::cout << "T=" << time << std::endl'
p15450
aS'                  << "   Number of active cells:       "'
p15451
aS'                  << triangulation.n_active_cells() << std::endl'
p15452
aS'                  << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p15453
aS'                  << std::endl'
p15454
aS'                  << std::endl;'
p15455
aS'        std::cout << "   NonLin Res     Lin Iter       Lin Res" << std::endl'
p15456
aS'                  << "   _____________________________________" << std::endl;'
p15457
aS'        unsigned int nonlin_iter = 0;'
p15458
aS'        current_solution         = predictor;'
p15459
aS'        while (true)'
p15460
aS'          {'
p15461
aS'            system_matrix = 0;'
p15462
aS'            right_hand_side = 0;'
p15463
aS'            assemble_system();'
p15464
aS'            const double res_norm = right_hand_side.l2_norm();'
p15465
aS'            if (std::fabs(res_norm) < 1e-10)'
p15466
aS'              {'
p15467
aS'                std::printf("   %-16.3e (converged)\\n\\n", res_norm);'
p15468
aS'                break;'
p15469
aS'              }'
p15470
aS'            else'
p15471
aS'              {'
p15472
aS'                newton_update = 0;'
p15473
aS'                std::pair<unsigned int, double> convergence ='
p15474
aS'                  solve(newton_update);'
p15475
aS'                current_solution += newton_update;'
p15476
aS'                std::printf("   %-16.3e %04d        %-5.2e\\n",'
p15477
aS'                            res_norm,'
p15478
aS'                            convergence.first,'
p15479
aS'                            convergence.second);'
p15480
aS'              }'
p15481
aS'            ++nonlin_iter;'
p15482
aS'            AssertThrow(nonlin_iter <= 10,'
p15483
aS'                        ExcMessage("No convergence in nonlinear solver"));'
p15484
aS'          }'
p15485
aS'        time += parameters.time_step;'
p15486
aS'        if (parameters.output_step < 0)'
p15487
aS'          output_results();'
p15488
aS'        else if (time >= next_output)'
p15489
aS'          {'
p15490
aS'            output_results();'
p15491
aS'            next_output += parameters.output_step;'
p15492
aS'          }'
p15493
aS'        predictor = current_solution;'
p15494
aS'        predictor.sadd(2.0, -1.0, old_solution);'
p15495
aS'        old_solution = current_solution;'
p15496
aS'        if (parameters.do_refine == true)'
p15497
aS'          {'
p15498
aS'            Vector<double> refinement_indicators('
p15499
aS'              triangulation.n_active_cells());'
p15500
aS'            compute_refinement_indicators(refinement_indicators);'
p15501
aS'            refine_grid(refinement_indicators);'
p15502
aS'            setup_system();'
p15503
aS'            newton_update.reinit(dof_handler.n_dofs());'
p15504
aS'          }'
p15505
aS'      }'
p15506
aS'  }'
p15507
aS'} // namespace Step33'
p15508
aS'int main(int argc, char *argv[])'
p15509
ag9
aS'  try'
p15510
aS'    {'
p15511
aS'      using namespace dealii;'
p15512
aS'      using namespace Step33;'
p15513
aS'      if (argc != 2)'
p15514
aS'        {'
p15515
aS'          std::cout << "Usage:" << argv[0] << " input_file" << std::endl;'
p15516
aS'          std::exit(1);'
p15517
aS'        }'
p15518
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p15519
aS'        argc, argv, dealii::numbers::invalid_unsigned_int);'
p15520
aS'      ConservationLaw<2> cons(argv[1]);'
p15521
aS'      cons.run();'
p15522
aS'    }'
p15523
aS'  catch (std::exception &exc)'
p15524
aS'    {'
p15525
aS'      std::cerr << std::endl'
p15526
aS'                << std::endl'
p15527
aS'                << "----------------------------------------------------"'
p15528
aS'                << std::endl;'
p15529
aS'      std::cerr << "Exception on processing: " << std::endl'
p15530
aS'                << exc.what() << std::endl'
p15531
aS'                << "Aborting!" << std::endl'
p15532
aS'                << "----------------------------------------------------"'
p15533
aS'                << std::endl;'
p15534
aS'      return 1;'
p15535
aS'    }'
p15536
aS'  catch (...)'
p15537
aS'    {'
p15538
aS'      std::cerr << std::endl'
p15539
aS'                << std::endl'
p15540
aS'                << "----------------------------------------------------"'
p15541
aS'                << std::endl;'
p15542
aS'      std::cerr << "Unknown exception!" << std::endl'
p15543
aS'                << "Aborting!" << std::endl'
p15544
aS'                << "----------------------------------------------------"'
p15545
aS'                << std::endl;'
p15546
aS'      return 1;'
p15547
aS'    };'
p15548
aS'  return 0;'
p15549
ag17
aS'#include <deal.II/base/smartpointer.h>'
p15550
aS'#include <deal.II/base/convergence_table.h>'
p15551
aS'#include <deal.II/base/quadrature_lib.h>'
p15552
aS'#include <deal.II/base/quadrature_selector.h>'
p15553
aS'#include <deal.II/base/parsed_function.h>'
p15554
aS'#include <deal.II/base/utilities.h>'
p15555
aS'#include <deal.II/lac/full_matrix.h>'
p15556
aS'#include <deal.II/lac/vector.h>'
p15557
aS'#include <deal.II/lac/solver_control.h>'
p15558
aS'#include <deal.II/lac/solver_gmres.h>'
p15559
aS'#include <deal.II/lac/precondition.h>'
p15560
aS'#include <deal.II/grid/tria.h>'
p15561
aS'#include <deal.II/grid/grid_generator.h>'
p15562
aS'#include <deal.II/grid/grid_in.h>'
p15563
aS'#include <deal.II/grid/grid_out.h>'
p15564
aS'#include <deal.II/grid/manifold_lib.h>'
p15565
aS'#include <deal.II/dofs/dof_handler.h>'
p15566
aS'#include <deal.II/dofs/dof_tools.h>'
p15567
aS'#include <deal.II/fe/fe_q.h>'
p15568
aS'#include <deal.II/fe/fe_values.h>'
p15569
aS'#include <deal.II/fe/mapping_q.h>'
p15570
aS'#include <deal.II/numerics/data_out.h>'
p15571
aS'#include <deal.II/numerics/vector_tools.h>'
p15572
aS'#include <cmath>'
p15573
aS'#include <iostream>'
p15574
aS'#include <fstream>'
p15575
aS'#include <string>'
p15576
aS'namespace Step34'
p15577
ag9
aS'  using namespace dealii;'
p15578
aS'  namespace LaplaceKernel'
p15579
aS'  {'
p15580
aS'    template <int dim>'
p15581
aS'    double single_layer(const Tensor<1, dim> &R)'
p15582
aS'    {'
p15583
aS'      switch (dim)'
p15584
aS'        {'
p15585
aS'          case 2:'
p15586
aS'            return (-std::log(R.norm()) / (2 * numbers::PI));'
p15587
aS'          case 3:'
p15588
aS'            return (1. / (R.norm() * 4 * numbers::PI));'
p15589
aS'          default:'
p15590
aS'            Assert(false, ExcInternalError());'
p15591
aS'            return 0.;'
p15592
aS'        }'
p15593
aS'    }'
p15594
aS'    template <int dim>'
p15595
aS'    Tensor<1, dim> double_layer(const Tensor<1, dim> &R)'
p15596
aS'    {'
p15597
aS'      switch (dim)'
p15598
aS'        {'
p15599
aS'          case 2:'
p15600
aS'            return R / (-2 * numbers::PI * R.norm_square());'
p15601
aS'          case 3:'
p15602
aS'            return R / (-4 * numbers::PI * R.norm_square() * R.norm());'
p15603
aS'          default:'
p15604
aS'            Assert(false, ExcInternalError());'
p15605
aS'            return Tensor<1, dim>();'
p15606
aS'        }'
p15607
aS'    }'
p15608
aS'  } // namespace LaplaceKernel'
p15609
aS'  template <int dim>'
p15610
aS'  class BEMProblem'
p15611
aS'  {'
p15612
aS'  public:'
p15613
aS'    BEMProblem(const unsigned int fe_degree      = 1,'
p15614
aS'               const unsigned int mapping_degree = 1);'
p15615
aS'    void run();'
p15616
aS'  private:'
p15617
aS'    void read_parameters(const std::string &filename);'
p15618
aS'    void read_domain();'
p15619
aS'    void refine_and_resize();'
p15620
aS'    void assemble_system();'
p15621
aS'    void solve_system();'
p15622
aS'    void compute_errors(const unsigned int cycle);'
p15623
aS'    void compute_exterior_solution();'
p15624
aS'    void output_results(const unsigned int cycle);'
p15625
aS'    const Quadrature<dim - 1> &get_singular_quadrature('
p15626
aS'      const typename DoFHandler<dim - 1, dim>::active_cell_iterator &cell,'
p15627
aS'      const unsigned int index) const;'
p15628
aS'    Triangulation<dim - 1, dim> tria;'
p15629
aS'    FE_Q<dim - 1, dim>          fe;'
p15630
aS'    DoFHandler<dim - 1, dim>    dof_handler;'
p15631
aS'    MappingQ<dim - 1, dim>      mapping;'
p15632
aS'    FullMatrix<double> system_matrix;'
p15633
aS'    Vector<double>     system_rhs;'
p15634
aS'    Vector<double> phi;'
p15635
aS'    Vector<double> alpha;'
p15636
aS'    ConvergenceTable convergence_table;'
p15637
aS'    Functions::ParsedFunction<dim> wind;'
p15638
aS'    Functions::ParsedFunction<dim> exact_solution;'
p15639
aS'    unsigned int                         singular_quadrature_order;'
p15640
aS'    std::shared_ptr<Quadrature<dim - 1>> quadrature;'
p15641
aS'    SolverControl solver_control;'
p15642
aS'    unsigned int n_cycles;'
p15643
aS'    unsigned int external_refinement;'
p15644
aS'    bool run_in_this_dimension;'
p15645
aS'    bool extend_solution;'
p15646
aS'  };'
p15647
aS'  template <int dim>'
p15648
aS'  BEMProblem<dim>::BEMProblem(const unsigned int fe_degree,'
p15649
aS'                              const unsigned int mapping_degree)'
p15650
aS'    : fe(fe_degree)'
p15651
aS'    , dof_handler(tria)'
p15652
aS'    , mapping(mapping_degree, true)'
p15653
aS'    , wind(dim)'
p15654
aS'    , singular_quadrature_order(5)'
p15655
aS'    , n_cycles(4)'
p15656
aS'    , external_refinement(5)'
p15657
aS'    , run_in_this_dimension(true)'
p15658
aS'    , extend_solution(true)'
p15659
aS'  {}'
p15660
aS'  template <int dim>'
p15661
aS'  void BEMProblem<dim>::read_parameters(const std::string &filename)'
p15662
aS'  {'
p15663
aS'    deallog << std::endl'
p15664
aS'            << "Parsing parameter file " << filename << std::endl'
p15665
aS'            << "for a " << dim << " dimensional simulation. " << std::endl;'
p15666
aS'    ParameterHandler prm;'
p15667
aS'    prm.declare_entry("Number of cycles", "4", Patterns::Integer());'
p15668
aS'    prm.declare_entry("External refinement", "5", Patterns::Integer());'
p15669
aS'    prm.declare_entry("Extend solution on the -2,2 box",'
p15670
aS'                      "true",'
p15671
aS'                      Patterns::Bool());'
p15672
aS'    prm.declare_entry("Run 2d simulation", "true", Patterns::Bool());'
p15673
aS'    prm.declare_entry("Run 3d simulation", "true", Patterns::Bool());'
p15674
aS'    prm.enter_subsection("Quadrature rules");'
p15675
aS'    {'
p15676
aS'      prm.declare_entry('
p15677
aS'        "Quadrature type",'
p15678
aS'        "gauss",'
p15679
aS'        Patterns::Selection('
p15680
aS'          QuadratureSelector<(dim - 1)>::get_quadrature_names()));'
p15681
aS'      prm.declare_entry("Quadrature order", "4", Patterns::Integer());'
p15682
aS'      prm.declare_entry("Singular quadrature order", "5", Patterns::Integer());'
p15683
aS'    }'
p15684
aS'    prm.leave_subsection();'
p15685
aS'    prm.enter_subsection("Wind function 2d");'
p15686
aS'    {'
p15687
aS'      Functions::ParsedFunction<2>::declare_parameters(prm, 2);'
p15688
aS'      prm.set("Function expression", "1; 1");'
p15689
aS'    }'
p15690
aS'    prm.leave_subsection();'
p15691
aS'    prm.enter_subsection("Wind function 3d");'
p15692
aS'    {'
p15693
aS'      Functions::ParsedFunction<3>::declare_parameters(prm, 3);'
p15694
aS'      prm.set("Function expression", "1; 1; 1");'
p15695
aS'    }'
p15696
aS'    prm.leave_subsection();'
p15697
aS'    prm.enter_subsection("Exact solution 2d");'
p15698
aS'    {'
p15699
aS'      Functions::ParsedFunction<2>::declare_parameters(prm);'
p15700
aS'      prm.set("Function expression", "x+y");'
p15701
aS'    }'
p15702
aS'    prm.leave_subsection();'
p15703
aS'    prm.enter_subsection("Exact solution 3d");'
p15704
aS'    {'
p15705
aS'      Functions::ParsedFunction<3>::declare_parameters(prm);'
p15706
aS'      prm.set("Function expression", "x+y+z");'
p15707
aS'    }'
p15708
aS'    prm.leave_subsection();'
p15709
aS'    prm.enter_subsection("Solver");'
p15710
aS'    SolverControl::declare_parameters(prm);'
p15711
aS'    prm.leave_subsection();'
p15712
aS'    prm.parse_input(filename);'
p15713
aS'    n_cycles            = prm.get_integer("Number of cycles");'
p15714
aS'    external_refinement = prm.get_integer("External refinement");'
p15715
aS'    extend_solution     = prm.get_bool("Extend solution on the -2,2 box");'
p15716
aS'    prm.enter_subsection("Quadrature rules");'
p15717
aS'    {'
p15718
aS'      quadrature = std::shared_ptr<Quadrature<dim - 1>>('
p15719
aS'        new QuadratureSelector<dim - 1>(prm.get("Quadrature type"),'
p15720
aS'                                        prm.get_integer("Quadrature order")));'
p15721
aS'      singular_quadrature_order = prm.get_integer("Singular quadrature order");'
p15722
aS'    }'
p15723
aS'    prm.leave_subsection();'
p15724
aS'    prm.enter_subsection("Wind function " + std::to_string(dim) + "d");'
p15725
aS'    {'
p15726
aS'      wind.parse_parameters(prm);'
p15727
aS'    }'
p15728
aS'    prm.leave_subsection();'
p15729
aS'    prm.enter_subsection("Exact solution " + std::to_string(dim) + "d");'
p15730
aS'    {'
p15731
aS'      exact_solution.parse_parameters(prm);'
p15732
aS'    }'
p15733
aS'    prm.leave_subsection();'
p15734
aS'    prm.enter_subsection("Solver");'
p15735
aS'    solver_control.parse_parameters(prm);'
p15736
aS'    prm.leave_subsection();'
p15737
aS'    run_in_this_dimension ='
p15738
aS'      prm.get_bool("Run " + std::to_string(dim) + "d simulation");'
p15739
aS'  }'
p15740
aS'  template <int dim>'
p15741
aS'  void BEMProblem<dim>::read_domain()'
p15742
aS'  {'
p15743
aS'    const Point<dim>                      center = Point<dim>();'
p15744
aS'    const SphericalManifold<dim - 1, dim> manifold(center);'
p15745
aS'    std::ifstream in;'
p15746
aS'    switch (dim)'
p15747
aS'      {'
p15748
aS'        case 2:'
p15749
aS'          in.open("coarse_circle.inp");'
p15750
aS'          break;'
p15751
aS'        case 3:'
p15752
aS'          in.open("coarse_sphere.inp");'
p15753
aS'          break;'
p15754
aS'        default:'
p15755
aS'          Assert(false, ExcNotImplemented());'
p15756
aS'      }'
p15757
aS'    GridIn<dim - 1, dim> gi;'
p15758
aS'    gi.attach_triangulation(tria);'
p15759
aS'    gi.read_ucd(in);'
p15760
aS'    tria.set_all_manifold_ids(1);'
p15761
aS'    tria.set_manifold(1, manifold);'
p15762
aS'  }'
p15763
aS'  template <int dim>'
p15764
aS'  void BEMProblem<dim>::refine_and_resize()'
p15765
aS'  {'
p15766
aS'    tria.refine_global(1);'
p15767
aS'    dof_handler.distribute_dofs(fe);'
p15768
aS'    const unsigned int n_dofs = dof_handler.n_dofs();'
p15769
aS'    system_matrix.reinit(n_dofs, n_dofs);'
p15770
aS'    system_rhs.reinit(n_dofs);'
p15771
aS'    phi.reinit(n_dofs);'
p15772
aS'    alpha.reinit(n_dofs);'
p15773
aS'  }'
p15774
aS'  template <int dim>'
p15775
aS'  void BEMProblem<dim>::assemble_system()'
p15776
aS'  {'
p15777
aS'    FEValues<dim - 1, dim> fe_v(mapping,'
p15778
aS'                                fe,'
p15779
aS'                                update_values | update_normal_vectors |'
p15780
aS'                                  update_quadrature_points | update_JxW_values);'
p15781
aS'    const unsigned int n_q_points = fe_v.n_quadrature_points;'
p15782
aS'    std::vector<types::global_dof_index> local_dof_indices('
p15783
aS'      fe.n_dofs_per_cell());'
p15784
aS'    std::vector<Vector<double>> cell_wind(n_q_points, Vector<double>(dim));'
p15785
aS'    double                      normal_wind;'
p15786
aS'    Vector<double> local_matrix_row_i(fe.n_dofs_per_cell());'
p15787
aS'    std::vector<Point<dim>> support_points(dof_handler.n_dofs());'
p15788
aS'    DoFTools::map_dofs_to_support_points<dim - 1, dim>(mapping,'
p15789
aS'                                                       dof_handler,'
p15790
aS'                                                       support_points);'
p15791
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p15792
aS'      {'
p15793
aS'        fe_v.reinit(cell);'
p15794
aS'        cell->get_dof_indices(local_dof_indices);'
p15795
aS'        const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();'
p15796
aS'        const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p15797
aS'        wind.vector_value_list(q_points, cell_wind);'
p15798
aS'        for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p15799
aS'          {'
p15800
aS'            local_matrix_row_i = 0;'
p15801
aS'            bool         is_singular    = false;'
p15802
aS'            unsigned int singular_index = numbers::invalid_unsigned_int;'
p15803
aS'            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p15804
aS'              if (local_dof_indices[j] == i)'
p15805
aS'                {'
p15806
aS'                  singular_index = j;'
p15807
aS'                  is_singular    = true;'
p15808
aS'                  break;'
p15809
aS'                }'
p15810
aS'            if (is_singular == false)'
p15811
aS'              {'
p15812
aS'                for (unsigned int q = 0; q < n_q_points; ++q)'
p15813
aS'                  {'
p15814
aS'                    normal_wind = 0;'
p15815
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p15816
aS'                      normal_wind += normals[q][d] * cell_wind[q](d);'
p15817
aS'                    const Tensor<1, dim> R = q_points[q] - support_points[i];'
p15818
aS'                    system_rhs(i) += (LaplaceKernel::single_layer(R) *'
p15819
aS'                                      normal_wind * fe_v.JxW(q));'
p15820
aS'                    for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p15821
aS'                      local_matrix_row_i(j) -='
p15822
aS'                         fe_v.shape_value(j, q) * fe_v.JxW(q));'
p15823
aS'                  }'
p15824
aS'              }'
p15825
aS'            else'
p15826
aS'              {'
p15827
aS'                Assert(singular_index != numbers::invalid_unsigned_int,'
p15828
aS'                       ExcInternalError());'
p15829
aS'                const Quadrature<dim - 1> &singular_quadrature ='
p15830
aS'                  get_singular_quadrature(cell, singular_index);'
p15831
aS'                FEValues<dim - 1, dim> fe_v_singular('
p15832
aS'                  mapping,'
p15833
aS'                  fe,'
p15834
aS'                  singular_quadrature,'
p15835
aS'                  update_jacobians | update_values | update_normal_vectors |'
p15836
aS'                    update_quadrature_points);'
p15837
aS'                fe_v_singular.reinit(cell);'
p15838
aS'                std::vector<Vector<double>> singular_cell_wind('
p15839
aS'                  singular_quadrature.size(), Vector<double>(dim));'
p15840
aS'                const std::vector<Tensor<1, dim>> &singular_normals ='
p15841
aS'                  fe_v_singular.get_normal_vectors();'
p15842
aS'                const std::vector<Point<dim>> &singular_q_points ='
p15843
aS'                  fe_v_singular.get_quadrature_points();'
p15844
aS'                wind.vector_value_list(singular_q_points, singular_cell_wind);'
p15845
aS'                for (unsigned int q = 0; q < singular_quadrature.size(); ++q)'
p15846
aS'                  {'
p15847
aS'                    const Tensor<1, dim> R ='
p15848
aS'                      singular_q_points[q] - support_points[i];'
p15849
aS'                    double normal_wind = 0;'
p15850
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p15851
aS'                      normal_wind +='
p15852
aS'                    system_rhs(i) += (LaplaceKernel::single_layer(R) *'
p15853
aS'                                      normal_wind * fe_v_singular.JxW(q));'
p15854
aS'                    for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p15855
aS'                      {'
p15856
aS'                        local_matrix_row_i(j) -='
p15857
aS'                            singular_normals[q]) *'
p15858
aS'                           fe_v_singular.shape_value(j, q) *'
p15859
aS'                           fe_v_singular.JxW(q));'
p15860
aS'                      }'
p15861
aS'                  }'
p15862
aS'              }'
p15863
aS'            for (unsigned int j = 0; j < fe.n_dofs_per_cell(); ++j)'
p15864
aS'              system_matrix(i, local_dof_indices[j]) += local_matrix_row_i(j);'
p15865
aS'          }'
p15866
aS'      }'
p15867
aS'    Vector<double> ones(dof_handler.n_dofs());'
p15868
aS'    ones.add(-1.);'
p15869
aS'    system_matrix.vmult(alpha, ones);'
p15870
aS'    alpha.add(1);'
p15871
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p15872
aS'      system_matrix(i, i) += alpha(i);'
p15873
aS'  }'
p15874
aS'  template <int dim>'
p15875
aS'  void BEMProblem<dim>::solve_system()'
p15876
aS'  {'
p15877
aS'    SolverGMRES<Vector<double>> solver(solver_control);'
p15878
aS'    solver.solve(system_matrix, phi, system_rhs, PreconditionIdentity());'
p15879
aS'  }'
p15880
aS'  template <int dim>'
p15881
aS'  void BEMProblem<dim>::compute_errors(const unsigned int cycle)'
p15882
aS'  {'
p15883
aS'    Vector<float> difference_per_cell(tria.n_active_cells());'
p15884
aS'    VectorTools::integrate_difference(mapping,'
p15885
aS'                                      dof_handler,'
p15886
aS'                                      phi,'
p15887
aS'                                      exact_solution,'
p15888
aS'                                      difference_per_cell,'
p15889
aS'                                      QGauss<(dim - 1)>(2 * fe.degree + 1),'
p15890
aS'                                      VectorTools::L2_norm);'
p15891
aS'    const double L2_error ='
p15892
aS'      VectorTools::compute_global_error(tria,'
p15893
aS'                                        difference_per_cell,'
p15894
aS'                                        VectorTools::L2_norm);'
p15895
aS'    Vector<double> difference_per_node(alpha);'
p15896
aS'    difference_per_node.add(-.5);'
p15897
aS'    const double       alpha_error    = difference_per_node.linfty_norm();'
p15898
aS'    const unsigned int n_active_cells = tria.n_active_cells();'
p15899
aS'    const unsigned int n_dofs         = dof_handler.n_dofs();'
p15900
aS'    deallog << "Cycle " << cycle << \':\' << std::endl'
p15901
aS'            << "   Number of active cells:       " << n_active_cells'
p15902
aS'            << std::endl'
p15903
aS'            << "   Number of degrees of freedom: " << n_dofs << std::endl;'
p15904
aS'    convergence_table.add_value("cycle", cycle);'
p15905
aS'    convergence_table.add_value("cells", n_active_cells);'
p15906
aS'    convergence_table.add_value("dofs", n_dofs);'
p15907
aS'    convergence_table.add_value("L2(phi)", L2_error);'
p15908
aS'    convergence_table.add_value("Linfty(alpha)", alpha_error);'
p15909
aS'  }'
p15910
aS'  template <>'
p15911
aS'  const Quadrature<2> &BEMProblem<3>::get_singular_quadrature('
p15912
aS'    const DoFHandler<2, 3>::active_cell_iterator &,'
p15913
aS'    const unsigned int index) const'
p15914
aS'  {'
p15915
aS'    Assert(index < fe.n_dofs_per_cell(),'
p15916
aS'           ExcIndexRange(0, fe.n_dofs_per_cell(), index));'
p15917
aS'    static std::vector<QGaussOneOverR<2>> quadratures;'
p15918
aS'    if (quadratures.size() == 0)'
p15919
aS'      for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p15920
aS'        quadratures.emplace_back(singular_quadrature_order,'
p15921
aS'                                 fe.get_unit_support_points()[i],'
p15922
aS'                                 true);'
p15923
aS'    return quadratures[index];'
p15924
aS'  }'
p15925
aS'  template <>'
p15926
aS'  const Quadrature<1> &BEMProblem<2>::get_singular_quadrature('
p15927
aS'    const DoFHandler<1, 2>::active_cell_iterator &cell,'
p15928
aS'    const unsigned int                            index) const'
p15929
aS'  {'
p15930
aS'    Assert(index < fe.n_dofs_per_cell(),'
p15931
aS'           ExcIndexRange(0, fe.n_dofs_per_cell(), index));'
p15932
aS'    static Quadrature<1> *q_pointer = nullptr;'
p15933
aS'    if (q_pointer)'
p15934
aS'      delete q_pointer;'
p15935
aS'    q_pointer = new QGaussLogR<1>(singular_quadrature_order,'
p15936
aS'                                  fe.get_unit_support_points()[index],'
p15937
aS'                                  1. / cell->measure(),'
p15938
aS'                                  true);'
p15939
aS'    return (*q_pointer);'
p15940
aS'  }'
p15941
aS'  template <int dim>'
p15942
aS'  void BEMProblem<dim>::compute_exterior_solution()'
p15943
aS'  {'
p15944
aS'    Triangulation<dim> external_tria;'
p15945
aS'    GridGenerator::hyper_cube(external_tria, -2, 2);'
p15946
aS'    FE_Q<dim>       external_fe(1);'
p15947
aS'    DoFHandler<dim> external_dh(external_tria);'
p15948
aS'    Vector<double>  external_phi;'
p15949
aS'    external_tria.refine_global(external_refinement);'
p15950
aS'    external_dh.distribute_dofs(external_fe);'
p15951
aS'    external_phi.reinit(external_dh.n_dofs());'
p15952
aS'    FEValues<dim - 1, dim> fe_v(mapping,'
p15953
aS'                                fe,'
p15954
aS'                                update_values | update_normal_vectors |'
p15955
aS'                                  update_quadrature_points | update_JxW_values);'
p15956
aS'    const unsigned int n_q_points = fe_v.n_quadrature_points;'
p15957
aS'    std::vector<types::global_dof_index> dofs(fe.n_dofs_per_cell());'
p15958
aS'    std::vector<double>         local_phi(n_q_points);'
p15959
aS'    std::vector<double>         normal_wind(n_q_points);'
p15960
aS'    std::vector<Vector<double>> local_wind(n_q_points, Vector<double>(dim));'
p15961
aS'    std::vector<Point<dim>> external_support_points(external_dh.n_dofs());'
p15962
aS'    DoFTools::map_dofs_to_support_points<dim>(StaticMappingQ1<dim>::mapping,'
p15963
aS'                                              external_dh,'
p15964
aS'                                              external_support_points);'
p15965
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p15966
aS'      {'
p15967
aS'        fe_v.reinit(cell);'
p15968
aS'        const std::vector<Point<dim>> &q_points = fe_v.get_quadrature_points();'
p15969
aS'        const std::vector<Tensor<1, dim>> &normals = fe_v.get_normal_vectors();'
p15970
aS'        cell->get_dof_indices(dofs);'
p15971
aS'        fe_v.get_function_values(phi, local_phi);'
p15972
aS'        wind.vector_value_list(q_points, local_wind);'
p15973
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p15974
aS'          {'
p15975
aS'            normal_wind[q] = 0;'
p15976
aS'            for (unsigned int d = 0; d < dim; ++d)'
p15977
aS'              normal_wind[q] += normals[q][d] * local_wind[q](d);'
p15978
aS'          }'
p15979
aS'        for (unsigned int i = 0; i < external_dh.n_dofs(); ++i)'
p15980
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p15981
aS'            {'
p15982
aS'              const Tensor<1, dim> R = q_points[q] - external_support_points[i];'
p15983
aS'              external_phi(i) +='
p15984
aS'                    local_phi[q]) *'
p15985
aS'                 fe_v.JxW(q));'
p15986
aS'            }'
p15987
aS'      }'
p15988
aS'    DataOut<dim> data_out;'
p15989
aS'    data_out.attach_dof_handler(external_dh);'
p15990
aS'    data_out.add_data_vector(external_phi, "external_phi");'
p15991
aS'    data_out.build_patches();'
p15992
aS'    const std::string filename = std::to_string(dim) + "d_external.vtk";'
p15993
aS'    std::ofstream     file(filename);'
p15994
aS'    data_out.write_vtk(file);'
p15995
aS'  }'
p15996
aS'  template <int dim>'
p15997
aS'  void BEMProblem<dim>::output_results(const unsigned int cycle)'
p15998
aS'  {'
p15999
aS'    DataOut<dim - 1, dim> dataout;'
p16000
aS'    dataout.attach_dof_handler(dof_handler);'
p16001
aS'    dataout.add_data_vector(phi, "phi", DataOut<dim - 1, dim>::type_dof_data);'
p16002
aS'    dataout.add_data_vector(alpha,'
p16003
aS'                            "alpha",'
p16004
aS'                            DataOut<dim - 1, dim>::type_dof_data);'
p16005
aS'    dataout.build_patches(mapping,'
p16006
aS'                          mapping.get_degree(),'
p16007
aS'                          DataOut<dim - 1, dim>::curved_inner_cells);'
p16008
aS'    const std::string filename = std::to_string(dim) + "d_boundary_solution_" +'
p16009
aS'                                 std::to_string(cycle) + ".vtk";'
p16010
aS'    std::ofstream file(filename);'
p16011
aS'    dataout.write_vtk(file);'
p16012
aS'    if (cycle == n_cycles - 1)'
p16013
aS'      {'
p16014
aS'        convergence_table.set_precision("L2(phi)", 3);'
p16015
aS'        convergence_table.set_precision("Linfty(alpha)", 3);'
p16016
aS'        convergence_table.set_scientific("L2(phi)", true);'
p16017
aS'        convergence_table.set_scientific("Linfty(alpha)", true);'
p16018
aS'        convergence_table.evaluate_convergence_rates('
p16019
aS'          "L2(phi)", ConvergenceTable::reduction_rate_log2);'
p16020
aS'        convergence_table.evaluate_convergence_rates('
p16021
aS'          "Linfty(alpha)", ConvergenceTable::reduction_rate_log2);'
p16022
aS'        deallog << std::endl;'
p16023
aS'        convergence_table.write_text(std::cout);'
p16024
aS'      }'
p16025
aS'  }'
p16026
aS'  template <int dim>'
p16027
aS'  void BEMProblem<dim>::run()'
p16028
aS'  {'
p16029
aS'    read_parameters("parameters.prm");'
p16030
aS'    if (run_in_this_dimension == false)'
p16031
aS'      {'
p16032
aS'        deallog << "Run in dimension " << dim'
p16033
aS'                << " explicitly disabled in parameter file. " << std::endl;'
p16034
aS'        return;'
p16035
aS'      }'
p16036
aS'    read_domain();'
p16037
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p16038
aS'      {'
p16039
aS'        refine_and_resize();'
p16040
aS'        assemble_system();'
p16041
aS'        solve_system();'
p16042
aS'        compute_errors(cycle);'
p16043
aS'        output_results(cycle);'
p16044
aS'      }'
p16045
aS'    if (extend_solution == true)'
p16046
aS'      compute_exterior_solution();'
p16047
aS'  }'
p16048
aS'} // namespace Step34'
p16049
aS'int main()'
p16050
ag9
aS'  try'
p16051
aS'    {'
p16052
aS'      using namespace Step34;'
p16053
aS'      const unsigned int degree         = 1;'
p16054
aS'      const unsigned int mapping_degree = 1;'
p16055
aS'      deallog.depth_console(3);'
p16056
aS'      BEMProblem<2> laplace_problem_2d(degree, mapping_degree);'
p16057
aS'      laplace_problem_2d.run();'
p16058
aS'      BEMProblem<3> laplace_problem_3d(degree, mapping_degree);'
p16059
aS'      laplace_problem_3d.run();'
p16060
aS'    }'
p16061
aS'  catch (std::exception &exc)'
p16062
aS'    {'
p16063
aS'      std::cerr << std::endl'
p16064
aS'                << std::endl'
p16065
aS'                << "----------------------------------------------------"'
p16066
aS'                << std::endl;'
p16067
aS'      std::cerr << "Exception on processing: " << std::endl'
p16068
aS'                << exc.what() << std::endl'
p16069
aS'                << "Aborting!" << std::endl'
p16070
aS'                << "----------------------------------------------------"'
p16071
aS'                << std::endl;'
p16072
aS'      return 1;'
p16073
aS'    }'
p16074
aS'  catch (...)'
p16075
aS'    {'
p16076
aS'      std::cerr << std::endl'
p16077
aS'                << std::endl'
p16078
aS'                << "----------------------------------------------------"'
p16079
aS'                << std::endl;'
p16080
aS'      std::cerr << "Unknown exception!" << std::endl'
p16081
aS'                << "Aborting!" << std::endl'
p16082
aS'                << "----------------------------------------------------"'
p16083
aS'                << std::endl;'
p16084
aS'      return 1;'
p16085
aS'    }'
p16086
aS'  return 0;'
p16087
ag17
aS'#include <deal.II/base/parameter_handler.h>'
p16088
aS'#include <deal.II/base/point.h>'
p16089
aS'#include <deal.II/base/function.h>'
p16090
aS'#include <deal.II/base/quadrature_lib.h>'
p16091
aS'#include <deal.II/base/multithread_info.h>'
p16092
aS'#include <deal.II/base/thread_management.h>'
p16093
aS'#include <deal.II/base/work_stream.h>'
p16094
aS'#include <deal.II/base/parallel.h>'
p16095
aS'#include <deal.II/base/utilities.h>'
p16096
aS'#include <deal.II/base/conditional_ostream.h>'
p16097
aS'#include <deal.II/lac/vector.h>'
p16098
aS'#include <deal.II/lac/sparse_matrix.h>'
p16099
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p16100
aS'#include <deal.II/lac/solver_cg.h>'
p16101
aS'#include <deal.II/lac/precondition.h>'
p16102
aS'#include <deal.II/lac/solver_gmres.h>'
p16103
aS'#include <deal.II/lac/sparse_ilu.h>'
p16104
aS'#include <deal.II/lac/sparse_direct.h>'
p16105
aS'#include <deal.II/lac/affine_constraints.h>'
p16106
aS'#include <deal.II/grid/tria.h>'
p16107
aS'#include <deal.II/grid/grid_generator.h>'
p16108
aS'#include <deal.II/grid/grid_refinement.h>'
p16109
aS'#include <deal.II/grid/grid_in.h>'
p16110
aS'#include <deal.II/dofs/dof_handler.h>'
p16111
aS'#include <deal.II/dofs/dof_tools.h>'
p16112
aS'#include <deal.II/dofs/dof_renumbering.h>'
p16113
aS'#include <deal.II/fe/fe_q.h>'
p16114
aS'#include <deal.II/fe/fe_values.h>'
p16115
aS'#include <deal.II/fe/fe_tools.h>'
p16116
aS'#include <deal.II/fe/fe_system.h>'
p16117
aS'#include <deal.II/numerics/matrix_tools.h>'
p16118
aS'#include <deal.II/numerics/vector_tools.h>'
p16119
aS'#include <deal.II/numerics/data_out.h>'
p16120
aS'#include <fstream>'
p16121
aS'#include <cmath>'
p16122
aS'#include <iostream>'
p16123
aS'namespace Step35'
p16124
ag9
aS'  using namespace dealii;'
p16125
aS'  namespace RunTimeParameters'
p16126
aS'  {'
p16127
aS'    enum class Method'
p16128
aS'    {'
p16129
aS'      standard,'
p16130
aS'      rotational'
p16131
aS'    };'
p16132
aS'    class Data_Storage'
p16133
aS'    {'
p16134
aS'    public:'
p16135
aS'      Data_Storage();'
p16136
aS'      void read_data(const std::string &filename);'
p16137
aS'      Method form;'
p16138
aS'      double dt;'
p16139
aS'      double initial_time;'
p16140
aS'      double final_time;'
p16141
aS'      double Reynolds;'
p16142
aS'      unsigned int n_global_refines;'
p16143
aS'      unsigned int pressure_degree;'
p16144
aS'      unsigned int vel_max_iterations;'
p16145
aS'      unsigned int vel_Krylov_size;'
p16146
aS'      unsigned int vel_off_diagonals;'
p16147
aS'      unsigned int vel_update_prec;'
p16148
aS'      double       vel_eps;'
p16149
aS'      double       vel_diag_strength;'
p16150
aS'      bool         verbose;'
p16151
aS'      unsigned int output_interval;'
p16152
aS'    protected:'
p16153
aS'      ParameterHandler prm;'
p16154
aS'    };'
p16155
aS'    Data_Storage::Data_Storage()'
p16156
aS'      : form(Method::rotational)'
p16157
aS'      , dt(5e-4)'
p16158
aS'      , initial_time(0.)'
p16159
aS'      , final_time(1.)'
p16160
aS'      , Reynolds(1.)'
p16161
aS'      , n_global_refines(0)'
p16162
aS'      , pressure_degree(1)'
p16163
aS'      , vel_max_iterations(1000)'
p16164
aS'      , vel_Krylov_size(30)'
p16165
aS'      , vel_off_diagonals(60)'
p16166
aS'      , vel_update_prec(15)'
p16167
aS'      , vel_eps(1e-12)'
p16168
aS'      , vel_diag_strength(0.01)'
p16169
aS'      , verbose(true)'
p16170
aS'      , output_interval(15)'
p16171
aS'    {'
p16172
aS'      prm.declare_entry("Method_Form",'
p16173
aS'                        "rotational",'
p16174
aS'                        Patterns::Selection("rotational|standard"),'
p16175
aS'                        " Used to select the type of method that we are going "'
p16176
aS'                        "to use. ");'
p16177
aS'      prm.enter_subsection("Physical data");'
p16178
aS'      {'
p16179
aS'        prm.declare_entry("initial_time",'
p16180
aS'                          "0.",'
p16181
aS'                          Patterns::Double(0.),'
p16182
aS'                          " The initial time of the simulation. ");'
p16183
aS'        prm.declare_entry("final_time",'
p16184
aS'                          "1.",'
p16185
aS'                          Patterns::Double(0.),'
p16186
aS'                          " The final time of the simulation. ");'
p16187
aS'        prm.declare_entry("Reynolds",'
p16188
aS'                          "1.",'
p16189
aS'                          Patterns::Double(0.),'
p16190
aS'                          " The Reynolds number. ");'
p16191
aS'      }'
p16192
aS'      prm.leave_subsection();'
p16193
aS'      prm.enter_subsection("Time step data");'
p16194
aS'      {'
p16195
aS'        prm.declare_entry("dt",'
p16196
aS'                          "5e-4",'
p16197
aS'                          Patterns::Double(0.),'
p16198
aS'                          " The time step size. ");'
p16199
aS'      }'
p16200
aS'      prm.leave_subsection();'
p16201
aS'      prm.enter_subsection("Space discretization");'
p16202
aS'      {'
p16203
aS'        prm.declare_entry("n_of_refines",'
p16204
aS'                          "0",'
p16205
aS'                          Patterns::Integer(0, 15),'
p16206
aS'                          " The number of global refines we do on the mesh. ");'
p16207
aS'        prm.declare_entry("pressure_fe_degree",'
p16208
aS'                          "1",'
p16209
aS'                          Patterns::Integer(1, 5),'
p16210
aS'                          " The polynomial degree for the pressure space. ");'
p16211
aS'      }'
p16212
aS'      prm.leave_subsection();'
p16213
aS'      prm.enter_subsection("Data solve velocity");'
p16214
aS'      {'
p16215
aS'        prm.declare_entry('
p16216
aS'          "max_iterations",'
p16217
aS'          "1000",'
p16218
aS'          Patterns::Integer(1, 1000),'
p16219
aS'          " The maximal number of iterations GMRES must make. ");'
p16220
aS'        prm.declare_entry("eps",'
p16221
aS'                          "1e-12",'
p16222
aS'                          Patterns::Double(0.),'
p16223
aS'                          " The stopping criterion. ");'
p16224
aS'        prm.declare_entry("Krylov_size",'
p16225
aS'                          "30",'
p16226
aS'                          Patterns::Integer(1),'
p16227
aS'                          " The size of the Krylov subspace to be used. ");'
p16228
aS'        prm.declare_entry("off_diagonals",'
p16229
aS'                          "60",'
p16230
aS'                          Patterns::Integer(0),'
p16231
aS'                          " The number of off-diagonal elements ILU must "'
p16232
aS'                          "compute. ");'
p16233
aS'        prm.declare_entry("diag_strength",'
p16234
aS'                          "0.01",'
p16235
aS'                          Patterns::Double(0.),'
p16236
aS'                          " Diagonal strengthening coefficient. ");'
p16237
aS'        prm.declare_entry("update_prec",'
p16238
aS'                          "15",'
p16239
aS'                          Patterns::Integer(1),'
p16240
aS'                          " This number indicates how often we need to "'
p16241
aS'                          "update the preconditioner");'
p16242
aS'      }'
p16243
aS'      prm.leave_subsection();'
p16244
aS'      prm.declare_entry("verbose",'
p16245
aS'                        "true",'
p16246
aS'                        Patterns::Bool(),'
p16247
aS'                        " This indicates whether the output of the solution "'
p16248
aS'                        "process should be verbose. ");'
p16249
aS'      prm.declare_entry("output_interval",'
p16250
aS'                        "1",'
p16251
aS'                        Patterns::Integer(1),'
p16252
aS'                        " This indicates between how many time steps we print "'
p16253
aS'                        "the solution. ");'
p16254
aS'    }'
p16255
aS'    void Data_Storage::read_data(const std::string &filename)'
p16256
aS'    {'
p16257
aS'      std::ifstream file(filename);'
p16258
aS'      AssertThrow(file, ExcFileNotOpen(filename));'
p16259
aS'      prm.parse_input(file);'
p16260
aS'      if (prm.get("Method_Form") == std::string("rotational"))'
p16261
aS'        form = Method::rotational;'
p16262
aS'      else'
p16263
aS'        form = Method::standard;'
p16264
aS'      prm.enter_subsection("Physical data");'
p16265
aS'      {'
p16266
aS'        initial_time = prm.get_double("initial_time");'
p16267
aS'        final_time   = prm.get_double("final_time");'
p16268
aS'        Reynolds     = prm.get_double("Reynolds");'
p16269
aS'      }'
p16270
aS'      prm.leave_subsection();'
p16271
aS'      prm.enter_subsection("Time step data");'
p16272
aS'      {'
p16273
aS'        dt = prm.get_double("dt");'
p16274
aS'      }'
p16275
aS'      prm.leave_subsection();'
p16276
aS'      prm.enter_subsection("Space discretization");'
p16277
aS'      {'
p16278
aS'        n_global_refines = prm.get_integer("n_of_refines");'
p16279
aS'        pressure_degree  = prm.get_integer("pressure_fe_degree");'
p16280
aS'      }'
p16281
aS'      prm.leave_subsection();'
p16282
aS'      prm.enter_subsection("Data solve velocity");'
p16283
aS'      {'
p16284
aS'        vel_max_iterations = prm.get_integer("max_iterations");'
p16285
aS'        vel_eps            = prm.get_double("eps");'
p16286
aS'        vel_Krylov_size    = prm.get_integer("Krylov_size");'
p16287
aS'        vel_off_diagonals  = prm.get_integer("off_diagonals");'
p16288
aS'        vel_diag_strength  = prm.get_double("diag_strength");'
p16289
aS'        vel_update_prec    = prm.get_integer("update_prec");'
p16290
aS'      }'
p16291
aS'      prm.leave_subsection();'
p16292
aS'      verbose = prm.get_bool("verbose");'
p16293
aS'      output_interval = prm.get_integer("output_interval");'
p16294
aS'    }'
p16295
aS'  } // namespace RunTimeParameters'
p16296
aS'  namespace EquationData'
p16297
aS'  {'
p16298
aS'    template <int dim>'
p16299
aS'    class MultiComponentFunction : public Function<dim>'
p16300
aS'    {'
p16301
aS'    public:'
p16302
aS'      MultiComponentFunction(const double initial_time = 0.);'
p16303
aS'      void set_component(const unsigned int d);'
p16304
aS'    protected:'
p16305
aS'      unsigned int comp;'
p16306
aS'    };'
p16307
aS'    template <int dim>'
p16308
aS'    MultiComponentFunction<dim>::MultiComponentFunction('
p16309
aS'      const double initial_time)'
p16310
aS'      : Function<dim>(1, initial_time)'
p16311
aS'      , comp(0)'
p16312
aS'    {}'
p16313
aS'    template <int dim>'
p16314
aS'    void MultiComponentFunction<dim>::set_component(const unsigned int d)'
p16315
aS'    {'
p16316
aS'      Assert(d < dim, ExcIndexRange(d, 0, dim));'
p16317
aS'      comp = d;'
p16318
aS'    }'
p16319
aS'    template <int dim>'
p16320
aS'    class Velocity : public MultiComponentFunction<dim>'
p16321
aS'    {'
p16322
aS'    public:'
p16323
aS'      Velocity(const double initial_time = 0.0);'
p16324
aS'      virtual double value(const Point<dim> & p,'
p16325
aS'                           const unsigned int component = 0) const override;'
p16326
aS'      virtual void value_list(const std::vector<Point<dim>> &points,'
p16327
aS'                              std::vector<double> &          values,'
p16328
aS'                              const unsigned int component = 0) const override;'
p16329
aS'    };'
p16330
aS'    template <int dim>'
p16331
aS'    Velocity<dim>::Velocity(const double initial_time)'
p16332
aS'      : MultiComponentFunction<dim>(initial_time)'
p16333
aS'    {}'
p16334
aS'    template <int dim>'
p16335
aS'    void Velocity<dim>::value_list(const std::vector<Point<dim>> &points,'
p16336
aS'                                   std::vector<double> &          values,'
p16337
aS'                                   const unsigned int) const'
p16338
aS'    {'
p16339
aS'      const unsigned int n_points = points.size();'
p16340
aS'      Assert(values.size() == n_points,'
p16341
aS'             ExcDimensionMismatch(values.size(), n_points));'
p16342
aS'      for (unsigned int i = 0; i < n_points; ++i)'
p16343
aS'        values[i] = Velocity<dim>::value(points[i]);'
p16344
aS'    }'
p16345
aS'    template <int dim>'
p16346
aS'    double Velocity<dim>::value(const Point<dim> &p, const unsigned int) const'
p16347
aS'    {'
p16348
aS'      if (this->comp == 0)'
p16349
aS'        {'
p16350
aS'          const double Um = 1.5;'
p16351
aS'          const double H  = 4.1;'
p16352
aS'          return 4. * Um * p(1) * (H - p(1)) / (H * H);'
p16353
aS'        }'
p16354
aS'      else'
p16355
aS'        return 0.;'
p16356
aS'    }'
p16357
aS'    template <int dim>'
p16358
aS'    class Pressure : public Function<dim>'
p16359
aS'    {'
p16360
aS'    public:'
p16361
aS'      Pressure(const double initial_time = 0.0);'
p16362
aS'      virtual double value(const Point<dim> & p,'
p16363
aS'                           const unsigned int component = 0) const override;'
p16364
aS'      virtual void value_list(const std::vector<Point<dim>> &points,'
p16365
aS'                              std::vector<double> &          values,'
p16366
aS'                              const unsigned int component = 0) const override;'
p16367
aS'    };'
p16368
aS'    template <int dim>'
p16369
aS'    Pressure<dim>::Pressure(const double initial_time)'
p16370
aS'      : Function<dim>(1, initial_time)'
p16371
aS'    {}'
p16372
aS'    template <int dim>'
p16373
aS'    double Pressure<dim>::value(const Point<dim> & p,'
p16374
aS'                                const unsigned int component) const'
p16375
aS'    {'
p16376
aS'      AssertIndexRange(component, 1);'
p16377
aS'      return 25. - p(0);'
p16378
aS'    }'
p16379
aS'    template <int dim>'
p16380
aS'    void Pressure<dim>::value_list(const std::vector<Point<dim>> &points,'
p16381
aS'                                   std::vector<double> &          values,'
p16382
aS'                                   const unsigned int component) const'
p16383
aS'    {'
p16384
aS'      AssertIndexRange(component, 1);'
p16385
aS'      const unsigned int n_points = points.size();'
p16386
aS'      Assert(values.size() == n_points,'
p16387
aS'             ExcDimensionMismatch(values.size(), n_points));'
p16388
aS'      for (unsigned int i = 0; i < n_points; ++i)'
p16389
aS'        values[i] = Pressure<dim>::value(points[i]);'
p16390
aS'    }'
p16391
aS'  } // namespace EquationData'
p16392
aS'  template <int dim>'
p16393
aS'  class NavierStokesProjection'
p16394
aS'  {'
p16395
aS'  public:'
p16396
aS'    NavierStokesProjection(const RunTimeParameters::Data_Storage &data);'
p16397
aS'    void run(const bool verbose = false, const unsigned int n_plots = 10);'
p16398
aS'  protected:'
p16399
aS'    RunTimeParameters::Method type;'
p16400
aS'    const unsigned int deg;'
p16401
aS'    const double       dt;'
p16402
aS'    const double       t_0;'
p16403
aS'    const double       T;'
p16404
aS'    const double       Re;'
p16405
aS'    EquationData::Velocity<dim>               vel_exact;'
p16406
aS'    std::map<types::global_dof_index, double> boundary_values;'
p16407
aS'    std::vector<types::boundary_id>           boundary_ids;'
p16408
aS'    Triangulation<dim> triangulation;'
p16409
aS'    FE_Q<dim> fe_velocity;'
p16410
aS'    FE_Q<dim> fe_pressure;'
p16411
aS'    DoFHandler<dim> dof_handler_velocity;'
p16412
aS'    DoFHandler<dim> dof_handler_pressure;'
p16413
aS'    QGauss<dim> quadrature_pressure;'
p16414
aS'    QGauss<dim> quadrature_velocity;'
p16415
aS'    SparsityPattern sparsity_pattern_velocity;'
p16416
aS'    SparsityPattern sparsity_pattern_pressure;'
p16417
aS'    SparsityPattern sparsity_pattern_pres_vel;'
p16418
aS'    SparseMatrix<double> vel_Laplace_plus_Mass;'
p16419
aS'    SparseMatrix<double> vel_it_matrix[dim];'
p16420
aS'    SparseMatrix<double> vel_Mass;'
p16421
aS'    SparseMatrix<double> vel_Laplace;'
p16422
aS'    SparseMatrix<double> vel_Advection;'
p16423
aS'    SparseMatrix<double> pres_Laplace;'
p16424
aS'    SparseMatrix<double> pres_Mass;'
p16425
aS'    SparseMatrix<double> pres_Diff[dim];'
p16426
aS'    SparseMatrix<double> pres_iterative;'
p16427
aS'    Vector<double> pres_n;'
p16428
aS'    Vector<double> pres_n_minus_1;'
p16429
aS'    Vector<double> phi_n;'
p16430
aS'    Vector<double> phi_n_minus_1;'
p16431
aS'    Vector<double> u_n[dim];'
p16432
aS'    Vector<double> u_n_minus_1[dim];'
p16433
aS'    Vector<double> u_star[dim];'
p16434
aS'    Vector<double> force[dim];'
p16435
aS'    Vector<double> v_tmp;'
p16436
aS'    Vector<double> pres_tmp;'
p16437
aS'    Vector<double> rot_u;'
p16438
aS'    SparseILU<double>   prec_velocity[dim];'
p16439
aS'    SparseILU<double>   prec_pres_Laplace;'
p16440
aS'    SparseDirectUMFPACK prec_mass;'
p16441
aS'    SparseDirectUMFPACK prec_vel_mass;'
p16442
aS'    DeclException2(ExcInvalidTimeStep,'
p16443
aS'                   double,'
p16444
aS'                   double,'
p16445
aS'                   << " The time step " << arg1 << " is out of range."'
p16446
aS'                   << std::endl'
p16447
aS'                   << " The permitted range is (0," << arg2 << "]");'
p16448
aS'    void create_triangulation_and_dofs(const unsigned int n_refines);'
p16449
aS'    void initialize();'
p16450
aS'    void interpolate_velocity();'
p16451
aS'    void diffusion_step(const bool reinit_prec);'
p16452
aS'    void projection_step(const bool reinit_prec);'
p16453
aS'    void update_pressure(const bool reinit_prec);'
p16454
aS'  private:'
p16455
aS'    unsigned int vel_max_its;'
p16456
aS'    unsigned int vel_Krylov_size;'
p16457
aS'    unsigned int vel_off_diagonals;'
p16458
aS'    unsigned int vel_update_prec;'
p16459
aS'    double       vel_eps;'
p16460
aS'    double       vel_diag_strength;'
p16461
aS'    void initialize_velocity_matrices();'
p16462
aS'    void initialize_pressure_matrices();'
p16463
aS'    using IteratorTuple ='
p16464
aS'      std::tuple<typename DoFHandler<dim>::active_cell_iterator,'
p16465
aS'                 typename DoFHandler<dim>::active_cell_iterator>;'
p16466
aS'    using IteratorPair = SynchronousIterators<IteratorTuple>;'
p16467
aS'    void initialize_gradient_operator();'
p16468
aS'    struct InitGradPerTaskData'
p16469
aS'    {'
p16470
aS'      unsigned int                         d;'
p16471
aS'      unsigned int                         vel_dpc;'
p16472
aS'      unsigned int                         pres_dpc;'
p16473
aS'      FullMatrix<double>                   local_grad;'
p16474
aS'      std::vector<types::global_dof_index> vel_local_dof_indices;'
p16475
aS'      std::vector<types::global_dof_index> pres_local_dof_indices;'
p16476
aS'      InitGradPerTaskData(const unsigned int dd,'
p16477
aS'                          const unsigned int vdpc,'
p16478
aS'                          const unsigned int pdpc)'
p16479
aS'        : d(dd)'
p16480
aS'        , vel_dpc(vdpc)'
p16481
aS'        , pres_dpc(pdpc)'
p16482
aS'        , local_grad(vdpc, pdpc)'
p16483
aS'        , vel_local_dof_indices(vdpc)'
p16484
aS'        , pres_local_dof_indices(pdpc)'
p16485
aS'      {}'
p16486
aS'    };'
p16487
aS'    struct InitGradScratchData'
p16488
aS'    {'
p16489
aS'      unsigned int  nqp;'
p16490
aS'      FEValues<dim> fe_val_vel;'
p16491
aS'      FEValues<dim> fe_val_pres;'
p16492
aS'      InitGradScratchData(const FE_Q<dim> &  fe_v,'
p16493
aS'                          const FE_Q<dim> &  fe_p,'
p16494
aS'                          const QGauss<dim> &quad,'
p16495
aS'                          const UpdateFlags  flags_v,'
p16496
aS'                          const UpdateFlags  flags_p)'
p16497
aS'        : nqp(quad.size())'
p16498
aS'        , fe_val_vel(fe_v, quad, flags_v)'
p16499
aS'        , fe_val_pres(fe_p, quad, flags_p)'
p16500
aS'      {}'
p16501
aS'      InitGradScratchData(const InitGradScratchData &data)'
p16502
aS'        : nqp(data.nqp)'
p16503
aS'        , fe_val_vel(data.fe_val_vel.get_fe(),'
p16504
aS'                     data.fe_val_vel.get_quadrature(),'
p16505
aS'                     data.fe_val_vel.get_update_flags())'
p16506
aS'        , fe_val_pres(data.fe_val_pres.get_fe(),'
p16507
aS'                      data.fe_val_pres.get_quadrature(),'
p16508
aS'                      data.fe_val_pres.get_update_flags())'
p16509
aS'      {}'
p16510
aS'    };'
p16511
aS'    void assemble_one_cell_of_gradient(const IteratorPair & SI,'
p16512
aS'                                       InitGradScratchData &scratch,'
p16513
aS'                                       InitGradPerTaskData &data);'
p16514
aS'    void copy_gradient_local_to_global(const InitGradPerTaskData &data);'
p16515
aS'    void assemble_advection_term();'
p16516
aS'    struct AdvectionPerTaskData'
p16517
aS'    {'
p16518
aS'      FullMatrix<double>                   local_advection;'
p16519
aS'      std::vector<types::global_dof_index> local_dof_indices;'
p16520
aS'      AdvectionPerTaskData(const unsigned int dpc)'
p16521
aS'        : local_advection(dpc, dpc)'
p16522
aS'        , local_dof_indices(dpc)'
p16523
aS'      {}'
p16524
aS'    };'
p16525
aS'    struct AdvectionScratchData'
p16526
aS'    {'
p16527
aS'      unsigned int                nqp;'
p16528
aS'      unsigned int                dpc;'
p16529
aS'      std::vector<Point<dim>>     u_star_local;'
p16530
aS'      std::vector<Tensor<1, dim>> grad_u_star;'
p16531
aS'      std::vector<double>         u_star_tmp;'
p16532
aS'      FEValues<dim>               fe_val;'
p16533
aS'      AdvectionScratchData(const FE_Q<dim> &  fe,'
p16534
aS'                           const QGauss<dim> &quad,'
p16535
aS'                           const UpdateFlags  flags)'
p16536
aS'        : nqp(quad.size())'
p16537
aS'        , dpc(fe.n_dofs_per_cell())'
p16538
aS'        , u_star_local(nqp)'
p16539
aS'        , grad_u_star(nqp)'
p16540
aS'        , u_star_tmp(nqp)'
p16541
aS'        , fe_val(fe, quad, flags)'
p16542
aS'      {}'
p16543
aS'      AdvectionScratchData(const AdvectionScratchData &data)'
p16544
aS'        : nqp(data.nqp)'
p16545
aS'        , dpc(data.dpc)'
p16546
aS'        , u_star_local(nqp)'
p16547
aS'        , grad_u_star(nqp)'
p16548
aS'        , u_star_tmp(nqp)'
p16549
aS'        , fe_val(data.fe_val.get_fe(),'
p16550
aS'                 data.fe_val.get_quadrature(),'
p16551
aS'                 data.fe_val.get_update_flags())'
p16552
aS'      {}'
p16553
aS'    };'
p16554
aS'    void assemble_one_cell_of_advection('
p16555
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p16556
aS'      AdvectionScratchData &                                scratch,'
p16557
aS'      AdvectionPerTaskData &                                data);'
p16558
aS'    void copy_advection_local_to_global(const AdvectionPerTaskData &data);'
p16559
aS'    void diffusion_component_solve(const unsigned int d);'
p16560
aS'    void output_results(const unsigned int step);'
p16561
aS'    void assemble_vorticity(const bool reinit_prec);'
p16562
aS'  };'
p16563
aS'  template <int dim>'
p16564
aS'  NavierStokesProjection<dim>::NavierStokesProjection('
p16565
aS'    const RunTimeParameters::Data_Storage &data)'
p16566
aS'    : type(data.form)'
p16567
aS'    , deg(data.pressure_degree)'
p16568
aS'    , dt(data.dt)'
p16569
aS'    , t_0(data.initial_time)'
p16570
aS'    , T(data.final_time)'
p16571
aS'    , Re(data.Reynolds)'
p16572
aS'    , vel_exact(data.initial_time)'
p16573
aS'    , fe_velocity(deg + 1)'
p16574
aS'    , fe_pressure(deg)'
p16575
aS'    , dof_handler_velocity(triangulation)'
p16576
aS'    , dof_handler_pressure(triangulation)'
p16577
aS'    , quadrature_pressure(deg + 1)'
p16578
aS'    , quadrature_velocity(deg + 2)'
p16579
aS'    , vel_max_its(data.vel_max_iterations)'
p16580
aS'    , vel_Krylov_size(data.vel_Krylov_size)'
p16581
aS'    , vel_off_diagonals(data.vel_off_diagonals)'
p16582
aS'    , vel_update_prec(data.vel_update_prec)'
p16583
aS'    , vel_eps(data.vel_eps)'
p16584
aS'    , vel_diag_strength(data.vel_diag_strength)'
p16585
aS'  {'
p16586
aS'    if (deg < 1)'
p16587
aS'      std::cout'
p16588
aS'        << " WARNING: The chosen pair of finite element spaces is not stable."'
p16589
aS'        << std::endl'
p16590
aS'        << " The obtained results will be nonsense" << std::endl;'
p16591
aS'    AssertThrow(!((dt <= 0.) || (dt > .5 * T)), ExcInvalidTimeStep(dt, .5 * T));'
p16592
aS'    create_triangulation_and_dofs(data.n_global_refines);'
p16593
aS'    initialize();'
p16594
aS'  }'
p16595
aS'  template <int dim>'
p16596
aS'  void NavierStokesProjection<dim>::create_triangulation_and_dofs('
p16597
aS'    const unsigned int n_refines)'
p16598
aS'  {'
p16599
aS'    GridIn<dim> grid_in;'
p16600
aS'    grid_in.attach_triangulation(triangulation);'
p16601
aS'    {'
p16602
aS'      std::string   filename = "nsbench2.inp";'
p16603
aS'      std::ifstream file(filename);'
p16604
aS'      Assert(file, ExcFileNotOpen(filename.c_str()));'
p16605
aS'      grid_in.read_ucd(file);'
p16606
aS'    }'
p16607
aS'    std::cout << "Number of refines = " << n_refines << std::endl;'
p16608
aS'    triangulation.refine_global(n_refines);'
p16609
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p16610
aS'              << std::endl;'
p16611
aS'    boundary_ids = triangulation.get_boundary_ids();'
p16612
aS'    dof_handler_velocity.distribute_dofs(fe_velocity);'
p16613
aS'    DoFRenumbering::boost::Cuthill_McKee(dof_handler_velocity);'
p16614
aS'    dof_handler_pressure.distribute_dofs(fe_pressure);'
p16615
aS'    DoFRenumbering::boost::Cuthill_McKee(dof_handler_pressure);'
p16616
aS'    initialize_velocity_matrices();'
p16617
aS'    initialize_pressure_matrices();'
p16618
aS'    initialize_gradient_operator();'
p16619
aS'    pres_n.reinit(dof_handler_pressure.n_dofs());'
p16620
aS'    pres_n_minus_1.reinit(dof_handler_pressure.n_dofs());'
p16621
aS'    phi_n.reinit(dof_handler_pressure.n_dofs());'
p16622
aS'    phi_n_minus_1.reinit(dof_handler_pressure.n_dofs());'
p16623
aS'    pres_tmp.reinit(dof_handler_pressure.n_dofs());'
p16624
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16625
aS'      {'
p16626
aS'        u_n[d].reinit(dof_handler_velocity.n_dofs());'
p16627
aS'        u_n_minus_1[d].reinit(dof_handler_velocity.n_dofs());'
p16628
aS'        u_star[d].reinit(dof_handler_velocity.n_dofs());'
p16629
aS'        force[d].reinit(dof_handler_velocity.n_dofs());'
p16630
aS'      }'
p16631
aS'    v_tmp.reinit(dof_handler_velocity.n_dofs());'
p16632
aS'    rot_u.reinit(dof_handler_velocity.n_dofs());'
p16633
aS'    std::cout << "dim (X_h) = " << (dof_handler_velocity.n_dofs() * dim) //'
p16634
aS'              << std::endl                                               //'
p16635
aS'              << "dim (M_h) = " << dof_handler_pressure.n_dofs()         //'
p16636
aS'              << std::endl                                               //'
p16637
aS'              << "Re        = " << Re << std::endl                       //'
p16638
aS'              << std::endl;'
p16639
aS'  }'
p16640
aS'  template <int dim>'
p16641
aS'  void NavierStokesProjection<dim>::initialize()'
p16642
aS'  {'
p16643
aS'    vel_Laplace_plus_Mass = 0.;'
p16644
aS'    vel_Laplace_plus_Mass.add(1. / Re, vel_Laplace);'
p16645
aS'    vel_Laplace_plus_Mass.add(1.5 / dt, vel_Mass);'
p16646
aS'    EquationData::Pressure<dim> pres(t_0);'
p16647
aS'    VectorTools::interpolate(dof_handler_pressure, pres, pres_n_minus_1);'
p16648
aS'    pres.advance_time(dt);'
p16649
aS'    VectorTools::interpolate(dof_handler_pressure, pres, pres_n);'
p16650
aS'    phi_n         = 0.;'
p16651
aS'    phi_n_minus_1 = 0.;'
p16652
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16653
aS'      {'
p16654
aS'        vel_exact.set_time(t_0);'
p16655
aS'        vel_exact.set_component(d);'
p16656
aS'        VectorTools::interpolate(dof_handler_velocity,'
p16657
aS'                                 vel_exact,'
p16658
aS'                                 u_n_minus_1[d]);'
p16659
aS'        vel_exact.advance_time(dt);'
p16660
aS'        VectorTools::interpolate(dof_handler_velocity, vel_exact, u_n[d]);'
p16661
aS'      }'
p16662
aS'  }'
p16663
aS'  template <int dim>'
p16664
aS'  void NavierStokesProjection<dim>::initialize_velocity_matrices()'
p16665
aS'  {'
p16666
aS'    {'
p16667
aS'      DynamicSparsityPattern dsp(dof_handler_velocity.n_dofs(),'
p16668
aS'                                 dof_handler_velocity.n_dofs());'
p16669
aS'      DoFTools::make_sparsity_pattern(dof_handler_velocity, dsp);'
p16670
aS'      sparsity_pattern_velocity.copy_from(dsp);'
p16671
aS'    }'
p16672
aS'    vel_Laplace_plus_Mass.reinit(sparsity_pattern_velocity);'
p16673
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16674
aS'      vel_it_matrix[d].reinit(sparsity_pattern_velocity);'
p16675
aS'    vel_Mass.reinit(sparsity_pattern_velocity);'
p16676
aS'    vel_Laplace.reinit(sparsity_pattern_velocity);'
p16677
aS'    vel_Advection.reinit(sparsity_pattern_velocity);'
p16678
aS'    MatrixCreator::create_mass_matrix(dof_handler_velocity,'
p16679
aS'                                      quadrature_velocity,'
p16680
aS'                                      vel_Mass);'
p16681
aS'    MatrixCreator::create_laplace_matrix(dof_handler_velocity,'
p16682
aS'                                         quadrature_velocity,'
p16683
aS'                                         vel_Laplace);'
p16684
aS'  }'
p16685
aS'  template <int dim>'
p16686
aS'  void NavierStokesProjection<dim>::initialize_pressure_matrices()'
p16687
aS'  {'
p16688
aS'    {'
p16689
aS'      DynamicSparsityPattern dsp(dof_handler_pressure.n_dofs(),'
p16690
aS'                                 dof_handler_pressure.n_dofs());'
p16691
aS'      DoFTools::make_sparsity_pattern(dof_handler_pressure, dsp);'
p16692
aS'      sparsity_pattern_pressure.copy_from(dsp);'
p16693
aS'    }'
p16694
aS'    pres_Laplace.reinit(sparsity_pattern_pressure);'
p16695
aS'    pres_iterative.reinit(sparsity_pattern_pressure);'
p16696
aS'    pres_Mass.reinit(sparsity_pattern_pressure);'
p16697
aS'    MatrixCreator::create_laplace_matrix(dof_handler_pressure,'
p16698
aS'                                         quadrature_pressure,'
p16699
aS'                                         pres_Laplace);'
p16700
aS'    MatrixCreator::create_mass_matrix(dof_handler_pressure,'
p16701
aS'                                      quadrature_pressure,'
p16702
aS'                                      pres_Mass);'
p16703
aS'  }'
p16704
aS'  template <int dim>'
p16705
aS'  void NavierStokesProjection<dim>::initialize_gradient_operator()'
p16706
aS'  {'
p16707
aS'    {'
p16708
aS'      DynamicSparsityPattern dsp(dof_handler_velocity.n_dofs(),'
p16709
aS'                                 dof_handler_pressure.n_dofs());'
p16710
aS'      DoFTools::make_sparsity_pattern(dof_handler_velocity,'
p16711
aS'                                      dof_handler_pressure,'
p16712
aS'                                      dsp);'
p16713
aS'      sparsity_pattern_pres_vel.copy_from(dsp);'
p16714
aS'    }'
p16715
aS'    InitGradPerTaskData per_task_data(0,'
p16716
aS'                                      fe_velocity.n_dofs_per_cell(),'
p16717
aS'                                      fe_pressure.n_dofs_per_cell());'
p16718
aS'    InitGradScratchData scratch_data(fe_velocity,'
p16719
aS'                                     fe_pressure,'
p16720
aS'                                     quadrature_velocity,'
p16721
aS'                                     update_gradients | update_JxW_values,'
p16722
aS'                                     update_values);'
p16723
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16724
aS'      {'
p16725
aS'        pres_Diff[d].reinit(sparsity_pattern_pres_vel);'
p16726
aS'        per_task_data.d = d;'
p16727
aS'        WorkStream::run('
p16728
aS'          IteratorPair(IteratorTuple(dof_handler_velocity.begin_active(),'
p16729
aS'                                     dof_handler_pressure.begin_active())),'
p16730
aS'          IteratorPair(IteratorTuple(dof_handler_velocity.end(),'
p16731
aS'                                     dof_handler_pressure.end())),'
p16732
aS'          &NavierStokesProjection<dim>::assemble_one_cell_of_gradient,'
p16733
aS'          &NavierStokesProjection<dim>::copy_gradient_local_to_global,'
p16734
aS'          scratch_data,'
p16735
aS'          per_task_data);'
p16736
aS'      }'
p16737
aS'  }'
p16738
aS'  template <int dim>'
p16739
aS'  void NavierStokesProjection<dim>::assemble_one_cell_of_gradient('
p16740
aS'    const IteratorPair & SI,'
p16741
aS'    InitGradScratchData &scratch,'
p16742
aS'    InitGradPerTaskData &data)'
p16743
aS'  {'
p16744
aS'    scratch.fe_val_vel.reinit(std::get<0>(*SI));'
p16745
aS'    scratch.fe_val_pres.reinit(std::get<1>(*SI));'
p16746
aS'    std::get<0>(*SI)->get_dof_indices(data.vel_local_dof_indices);'
p16747
aS'    std::get<1>(*SI)->get_dof_indices(data.pres_local_dof_indices);'
p16748
aS'    data.local_grad = 0.;'
p16749
aS'    for (unsigned int q = 0; q < scratch.nqp; ++q)'
p16750
aS'      {'
p16751
aS'        for (unsigned int i = 0; i < data.vel_dpc; ++i)'
p16752
aS'          for (unsigned int j = 0; j < data.pres_dpc; ++j)'
p16753
aS'            data.local_grad(i, j) +='
p16754
aS'              -scratch.fe_val_vel.JxW(q) *'
p16755
aS'              scratch.fe_val_vel.shape_grad(i, q)[data.d] *'
p16756
aS'              scratch.fe_val_pres.shape_value(j, q);'
p16757
aS'      }'
p16758
aS'  }'
p16759
aS'  template <int dim>'
p16760
aS'  void NavierStokesProjection<dim>::copy_gradient_local_to_global('
p16761
aS'    const InitGradPerTaskData &data)'
p16762
aS'  {'
p16763
aS'    for (unsigned int i = 0; i < data.vel_dpc; ++i)'
p16764
aS'      for (unsigned int j = 0; j < data.pres_dpc; ++j)'
p16765
aS'        pres_Diff[data.d].add(data.vel_local_dof_indices[i],'
p16766
aS'                              data.pres_local_dof_indices[j],'
p16767
aS'                              data.local_grad(i, j));'
p16768
aS'  }'
p16769
aS'  template <int dim>'
p16770
aS'  void NavierStokesProjection<dim>::run(const bool         verbose,'
p16771
aS'                                        const unsigned int output_interval)'
p16772
aS'  {'
p16773
aS'    ConditionalOStream verbose_cout(std::cout, verbose);'
p16774
aS'    const auto n_steps = static_cast<unsigned int>((T - t_0) / dt);'
p16775
aS'    vel_exact.set_time(2. * dt);'
p16776
aS'    output_results(1);'
p16777
aS'    for (unsigned int n = 2; n <= n_steps; ++n)'
p16778
aS'      {'
p16779
aS'        if (n % output_interval == 0)'
p16780
aS'          {'
p16781
aS'            verbose_cout << "Plotting Solution" << std::endl;'
p16782
aS'            output_results(n);'
p16783
aS'          }'
p16784
aS'        std::cout << "Step = " << n << " Time = " << (n * dt) << std::endl;'
p16785
aS'        verbose_cout << "  Interpolating the velocity " << std::endl;'
p16786
aS'        interpolate_velocity();'
p16787
aS'        verbose_cout << "  Diffusion Step" << std::endl;'
p16788
aS'        if (n % vel_update_prec == 0)'
p16789
aS'          verbose_cout << "    With reinitialization of the preconditioner"'
p16790
aS'                       << std::endl;'
p16791
aS'        diffusion_step((n % vel_update_prec == 0) || (n == 2));'
p16792
aS'        verbose_cout << "  Projection Step" << std::endl;'
p16793
aS'        projection_step((n == 2));'
p16794
aS'        verbose_cout << "  Updating the Pressure" << std::endl;'
p16795
aS'        update_pressure((n == 2));'
p16796
aS'        vel_exact.advance_time(dt);'
p16797
aS'      }'
p16798
aS'    output_results(n_steps);'
p16799
aS'  }'
p16800
aS'  template <int dim>'
p16801
aS'  void NavierStokesProjection<dim>::interpolate_velocity()'
p16802
aS'  {'
p16803
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16804
aS'      {'
p16805
aS'        u_star[d].equ(2., u_n[d]);'
p16806
aS'        u_star[d] -= u_n_minus_1[d];'
p16807
aS'      }'
p16808
aS'  }'
p16809
aS'  template <int dim>'
p16810
aS'  void NavierStokesProjection<dim>::diffusion_step(const bool reinit_prec)'
p16811
aS'  {'
p16812
aS'    pres_tmp.equ(-1., pres_n);'
p16813
aS'    pres_tmp.add(-4. / 3., phi_n, 1. / 3., phi_n_minus_1);'
p16814
aS'    assemble_advection_term();'
p16815
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16816
aS'      {'
p16817
aS'        force[d] = 0.;'
p16818
aS'        v_tmp.equ(2. / dt, u_n[d]);'
p16819
aS'        v_tmp.add(-.5 / dt, u_n_minus_1[d]);'
p16820
aS'        vel_Mass.vmult_add(force[d], v_tmp);'
p16821
aS'        pres_Diff[d].vmult_add(force[d], pres_tmp);'
p16822
aS'        u_n_minus_1[d] = u_n[d];'
p16823
aS'        vel_it_matrix[d].copy_from(vel_Laplace_plus_Mass);'
p16824
aS'        vel_it_matrix[d].add(1., vel_Advection);'
p16825
aS'        vel_exact.set_component(d);'
p16826
aS'        boundary_values.clear();'
p16827
aS'        for (const auto &boundary_id : boundary_ids)'
p16828
aS'          {'
p16829
aS'            switch (boundary_id)'
p16830
aS'              {'
p16831
aS'                case 1:'
p16832
aS'                  VectorTools::interpolate_boundary_values('
p16833
aS'                    dof_handler_velocity,'
p16834
aS'                    boundary_id,'
p16835
aS'                    Functions::ZeroFunction<dim>(),'
p16836
aS'                    boundary_values);'
p16837
aS'                  break;'
p16838
aS'                case 2:'
p16839
aS'                  VectorTools::interpolate_boundary_values(dof_handler_velocity,'
p16840
aS'                                                           boundary_id,'
p16841
aS'                                                           vel_exact,'
p16842
aS'                                                           boundary_values);'
p16843
aS'                  break;'
p16844
aS'                case 3:'
p16845
aS'                  if (d != 0)'
p16846
aS'                    VectorTools::interpolate_boundary_values('
p16847
aS'                      dof_handler_velocity,'
p16848
aS'                      boundary_id,'
p16849
aS'                      Functions::ZeroFunction<dim>(),'
p16850
aS'                      boundary_values);'
p16851
aS'                  break;'
p16852
aS'                case 4:'
p16853
aS'                  VectorTools::interpolate_boundary_values('
p16854
aS'                    dof_handler_velocity,'
p16855
aS'                    boundary_id,'
p16856
aS'                    Functions::ZeroFunction<dim>(),'
p16857
aS'                    boundary_values);'
p16858
aS'                  break;'
p16859
aS'                default:'
p16860
aS'                  Assert(false, ExcNotImplemented());'
p16861
aS'              }'
p16862
aS'          }'
p16863
aS'        MatrixTools::apply_boundary_values(boundary_values,'
p16864
aS'                                           vel_it_matrix[d],'
p16865
aS'                                           u_n[d],'
p16866
aS'                                           force[d]);'
p16867
aS'      }'
p16868
aS'    Threads::TaskGroup<void> tasks;'
p16869
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16870
aS'      {'
p16871
aS'        if (reinit_prec)'
p16872
aS'          prec_velocity[d].initialize(vel_it_matrix[d],'
p16873
aS'                                      SparseILU<double>::AdditionalData('
p16874
aS'                                        vel_diag_strength, vel_off_diagonals));'
p16875
aS'        tasks += Threads::new_task('
p16876
aS'          &NavierStokesProjection<dim>::diffusion_component_solve, *this, d);'
p16877
aS'      }'
p16878
aS'    tasks.join_all();'
p16879
aS'  }'
p16880
aS'  template <int dim>'
p16881
aS'  void'
p16882
aS'  NavierStokesProjection<dim>::diffusion_component_solve(const unsigned int d)'
p16883
aS'  {'
p16884
aS'    SolverControl solver_control(vel_max_its, vel_eps * force[d].l2_norm());'
p16885
aS'    SolverGMRES<Vector<double>> gmres('
p16886
aS'      solver_control,'
p16887
aS'      SolverGMRES<Vector<double>>::AdditionalData(vel_Krylov_size));'
p16888
aS'    gmres.solve(vel_it_matrix[d], u_n[d], force[d], prec_velocity[d]);'
p16889
aS'  }'
p16890
aS'  template <int dim>'
p16891
aS'  void NavierStokesProjection<dim>::assemble_advection_term()'
p16892
aS'  {'
p16893
aS'    vel_Advection = 0.;'
p16894
aS'    AdvectionPerTaskData data(fe_velocity.n_dofs_per_cell());'
p16895
aS'    AdvectionScratchData scratch(fe_velocity,'
p16896
aS'                                 quadrature_velocity,'
p16897
aS'                                 update_values | update_JxW_values |'
p16898
aS'                                   update_gradients);'
p16899
aS'    WorkStream::run('
p16900
aS'      dof_handler_velocity.begin_active(),'
p16901
aS'      dof_handler_velocity.end(),'
p16902
aS'      &NavierStokesProjection<dim>::assemble_one_cell_of_advection,'
p16903
aS'      &NavierStokesProjection<dim>::copy_advection_local_to_global,'
p16904
aS'      scratch,'
p16905
aS'      data);'
p16906
aS'  }'
p16907
aS'  template <int dim>'
p16908
aS'  void NavierStokesProjection<dim>::assemble_one_cell_of_advection('
p16909
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p16910
aS'    AdvectionScratchData &                                scratch,'
p16911
aS'    AdvectionPerTaskData &                                data)'
p16912
aS'  {'
p16913
aS'    scratch.fe_val.reinit(cell);'
p16914
aS'    cell->get_dof_indices(data.local_dof_indices);'
p16915
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16916
aS'      {'
p16917
aS'        scratch.fe_val.get_function_values(u_star[d], scratch.u_star_tmp);'
p16918
aS'        for (unsigned int q = 0; q < scratch.nqp; ++q)'
p16919
aS'          scratch.u_star_local[q](d) = scratch.u_star_tmp[q];'
p16920
aS'      }'
p16921
aS'    for (unsigned int d = 0; d < dim; ++d)'
p16922
aS'      {'
p16923
aS'        scratch.fe_val.get_function_gradients(u_star[d], scratch.grad_u_star);'
p16924
aS'        for (unsigned int q = 0; q < scratch.nqp; ++q)'
p16925
aS'          {'
p16926
aS'            if (d == 0)'
p16927
aS'              scratch.u_star_tmp[q] = 0.;'
p16928
aS'            scratch.u_star_tmp[q] += scratch.grad_u_star[q][d];'
p16929
aS'          }'
p16930
aS'      }'
p16931
aS'    data.local_advection = 0.;'
p16932
aS'    for (unsigned int q = 0; q < scratch.nqp; ++q)'
p16933
aS'      for (unsigned int i = 0; i < scratch.dpc; ++i)'
p16934
aS'        for (unsigned int j = 0; j < scratch.dpc; ++j)'
p16935
aS'          data.local_advection(i, j) += (scratch.u_star_local[q] *            //'
p16936
aS'                                           scratch.fe_val.shape_grad(j, q) *  //'
p16937
aS'                                           scratch.fe_val.shape_value(i, q)   //'
p16938
aS'                                         +                                    //'
p16939
aS'                                         0.5 *                                //'
p16940
aS'                                           scratch.u_star_tmp[q] *            //'
p16941
aS'                                           scratch.fe_val.shape_value(i, q) * //'
p16942
aS'                                           scratch.fe_val.shape_value(j, q))  //'
p16943
aS'  }'
p16944
aS'  template <int dim>'
p16945
aS'  void NavierStokesProjection<dim>::copy_advection_local_to_global('
p16946
aS'    const AdvectionPerTaskData &data)'
p16947
aS'  {'
p16948
aS'    for (unsigned int i = 0; i < fe_velocity.n_dofs_per_cell(); ++i)'
p16949
aS'      for (unsigned int j = 0; j < fe_velocity.n_dofs_per_cell(); ++j)'
p16950
aS'        vel_Advection.add(data.local_dof_indices[i],'
p16951
aS'                          data.local_dof_indices[j],'
p16952
aS'                          data.local_advection(i, j));'
p16953
aS'  }'
p16954
aS'  template <int dim>'
p16955
aS'  void NavierStokesProjection<dim>::projection_step(const bool reinit_prec)'
p16956
aS'  {'
p16957
aS'    pres_iterative.copy_from(pres_Laplace);'
p16958
aS'    pres_tmp = 0.;'
p16959
aS'    for (unsigned d = 0; d < dim; ++d)'
p16960
aS'      pres_Diff[d].Tvmult_add(pres_tmp, u_n[d]);'
p16961
aS'    phi_n_minus_1 = phi_n;'
p16962
aS'    static std::map<types::global_dof_index, double> bval;'
p16963
aS'    if (reinit_prec)'
p16964
aS'      VectorTools::interpolate_boundary_values(dof_handler_pressure,'
p16965
aS'                                               3,'
p16966
aS'                                               Functions::ZeroFunction<dim>(),'
p16967
aS'                                               bval);'
p16968
aS'    MatrixTools::apply_boundary_values(bval, pres_iterative, phi_n, pres_tmp);'
p16969
aS'    if (reinit_prec)'
p16970
aS'      prec_pres_Laplace.initialize(pres_iterative,'
p16971
aS'                                   SparseILU<double>::AdditionalData('
p16972
aS'                                     vel_diag_strength, vel_off_diagonals));'
p16973
aS'    SolverControl solvercontrol(vel_max_its, vel_eps * pres_tmp.l2_norm());'
p16974
aS'    SolverCG<Vector<double>> cg(solvercontrol);'
p16975
aS'    cg.solve(pres_iterative, phi_n, pres_tmp, prec_pres_Laplace);'
p16976
aS'    phi_n *= 1.5 / dt;'
p16977
aS'  }'
p16978
aS'  template <int dim>'
p16979
aS'  void NavierStokesProjection<dim>::update_pressure(const bool reinit_prec)'
p16980
aS'  {'
p16981
aS'    pres_n_minus_1 = pres_n;'
p16982
aS'    switch (type)'
p16983
aS'      {'
p16984
aS'        case RunTimeParameters::Method::standard:'
p16985
aS'          pres_n += phi_n;'
p16986
aS'          break;'
p16987
aS'        case RunTimeParameters::Method::rotational:'
p16988
aS'          if (reinit_prec)'
p16989
aS'            prec_mass.initialize(pres_Mass);'
p16990
aS'          pres_n = pres_tmp;'
p16991
aS'          prec_mass.solve(pres_n);'
p16992
aS'          pres_n.sadd(1. / Re, 1., pres_n_minus_1);'
p16993
aS'          pres_n += phi_n;'
p16994
aS'          break;'
p16995
aS'        default:'
p16996
aS'          Assert(false, ExcNotImplemented());'
p16997
aS'      };'
p16998
aS'  }'
p16999
aS'  template <int dim>'
p17000
aS'  void NavierStokesProjection<dim>::output_results(const unsigned int step)'
p17001
aS'  {'
p17002
aS'    assemble_vorticity((step == 1));'
p17003
aS'    const FESystem<dim> joint_fe('
p17004
aS'      fe_velocity, dim, fe_pressure, 1, fe_velocity, 1);'
p17005
aS'    DoFHandler<dim> joint_dof_handler(triangulation);'
p17006
aS'    joint_dof_handler.distribute_dofs(joint_fe);'
p17007
aS'    Assert(joint_dof_handler.n_dofs() =='
p17008
aS'              dof_handler_pressure.n_dofs()),'
p17009
aS'           ExcInternalError());'
p17010
aS'    Vector<double> joint_solution(joint_dof_handler.n_dofs());'
p17011
aS'    std::vector<types::global_dof_index> loc_joint_dof_indices('
p17012
aS'      joint_fe.n_dofs_per_cell()),'
p17013
aS'      loc_vel_dof_indices(fe_velocity.n_dofs_per_cell()),'
p17014
aS'      loc_pres_dof_indices(fe_pressure.n_dofs_per_cell());'
p17015
aS'    typename DoFHandler<dim>::active_cell_iterator'
p17016
aS'      joint_cell = joint_dof_handler.begin_active(),'
p17017
aS'      joint_endc = joint_dof_handler.end(),'
p17018
aS'      vel_cell   = dof_handler_velocity.begin_active(),'
p17019
aS'      pres_cell  = dof_handler_pressure.begin_active();'
p17020
aS'    for (; joint_cell != joint_endc; ++joint_cell, ++vel_cell, ++pres_cell)'
p17021
aS'      {'
p17022
aS'        joint_cell->get_dof_indices(loc_joint_dof_indices);'
p17023
aS'        vel_cell->get_dof_indices(loc_vel_dof_indices);'
p17024
aS'        pres_cell->get_dof_indices(loc_pres_dof_indices);'
p17025
aS'        for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)'
p17026
aS'          switch (joint_fe.system_to_base_index(i).first.first)'
p17027
aS'            {'
p17028
aS'              case 0:'
p17029
aS'                Assert(joint_fe.system_to_base_index(i).first.second < dim,'
p17030
aS'                       ExcInternalError());'
p17031
aS'                joint_solution(loc_joint_dof_indices[i]) ='
p17032
aS'                  u_n[joint_fe.system_to_base_index(i).first.second]('
p17033
aS'                    loc_vel_dof_indices[joint_fe.system_to_base_index(i)'
p17034
aS'                                          .second]);'
p17035
aS'                break;'
p17036
aS'              case 1:'
p17037
aS'                Assert(joint_fe.system_to_base_index(i).first.second == 0,'
p17038
aS'                       ExcInternalError());'
p17039
aS'                joint_solution(loc_joint_dof_indices[i]) ='
p17040
aS'                  pres_n(loc_pres_dof_indices[joint_fe.system_to_base_index(i)'
p17041
aS'                                                .second]);'
p17042
aS'                break;'
p17043
aS'              case 2:'
p17044
aS'                Assert(joint_fe.system_to_base_index(i).first.second == 0,'
p17045
aS'                       ExcInternalError());'
p17046
aS'                joint_solution(loc_joint_dof_indices[i]) = rot_u('
p17047
aS'                  loc_vel_dof_indices[joint_fe.system_to_base_index(i).second]);'
p17048
aS'                break;'
p17049
aS'              default:'
p17050
aS'                Assert(false, ExcInternalError());'
p17051
aS'            }'
p17052
aS'      }'
p17053
aS'    std::vector<std::string> joint_solution_names(dim, "v");'
p17054
aS'    joint_solution_names.emplace_back("p");'
p17055
aS'    joint_solution_names.emplace_back("rot_u");'
p17056
aS'    DataOut<dim> data_out;'
p17057
aS'    data_out.attach_dof_handler(joint_dof_handler);'
p17058
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p17059
aS'      component_interpretation('
p17060
aS'        dim + 2, DataComponentInterpretation::component_is_part_of_vector);'
p17061
aS'    component_interpretation[dim] ='
p17062
aS'      DataComponentInterpretation::component_is_scalar;'
p17063
aS'    component_interpretation[dim + 1] ='
p17064
aS'      DataComponentInterpretation::component_is_scalar;'
p17065
aS'    data_out.add_data_vector(joint_solution,'
p17066
aS'                             joint_solution_names,'
p17067
aS'                             DataOut<dim>::type_dof_data,'
p17068
aS'                             component_interpretation);'
p17069
aS'    data_out.build_patches(deg + 1);'
p17070
aS'    std::ofstream output("solution-" + Utilities::int_to_string(step, 5) +'
p17071
aS'                         ".vtk");'
p17072
aS'    data_out.write_vtk(output);'
p17073
aS'  }'
p17074
aS'  template <int dim>'
p17075
aS'  void NavierStokesProjection<dim>::assemble_vorticity(const bool reinit_prec)'
p17076
aS'  {'
p17077
aS'    Assert(dim == 2, ExcNotImplemented());'
p17078
aS'    if (reinit_prec)'
p17079
aS'      prec_vel_mass.initialize(vel_Mass);'
p17080
aS'    FEValues<dim>      fe_val_vel(fe_velocity,'
p17081
aS'                             quadrature_velocity,'
p17082
aS'                             update_gradients | update_JxW_values |'
p17083
aS'                               update_values);'
p17084
aS'    const unsigned int dpc = fe_velocity.n_dofs_per_cell(),'
p17085
aS'                       nqp = quadrature_velocity.size();'
p17086
aS'    std::vector<types::global_dof_index> ldi(dpc);'
p17087
aS'    Vector<double>                       loc_rot(dpc);'
p17088
aS'    std::vector<Tensor<1, dim>> grad_u1(nqp), grad_u2(nqp);'
p17089
aS'    rot_u = 0.;'
p17090
aS'    for (const auto &cell : dof_handler_velocity.active_cell_iterators())'
p17091
aS'      {'
p17092
aS'        fe_val_vel.reinit(cell);'
p17093
aS'        cell->get_dof_indices(ldi);'
p17094
aS'        fe_val_vel.get_function_gradients(u_n[0], grad_u1);'
p17095
aS'        fe_val_vel.get_function_gradients(u_n[1], grad_u2);'
p17096
aS'        loc_rot = 0.;'
p17097
aS'        for (unsigned int q = 0; q < nqp; ++q)'
p17098
aS'          for (unsigned int i = 0; i < dpc; ++i)'
p17099
aS'            loc_rot(i) += (grad_u2[q][0] - grad_u1[q][1]) * //'
p17100
aS'                          fe_val_vel.shape_value(i, q) *    //'
p17101
aS'                          fe_val_vel.JxW(q);'
p17102
aS'        for (unsigned int i = 0; i < dpc; ++i)'
p17103
aS'          rot_u(ldi[i]) += loc_rot(i);'
p17104
aS'      }'
p17105
aS'    prec_vel_mass.solve(rot_u);'
p17106
aS'  }'
p17107
aS'} // namespace Step35'
p17108
aS'int main()'
p17109
ag9
aS'  try'
p17110
aS'    {'
p17111
aS'      using namespace Step35;'
p17112
aS'      RunTimeParameters::Data_Storage data;'
p17113
aS'      data.read_data("parameter-file.prm");'
p17114
aS'      deallog.depth_console(data.verbose ? 2 : 0);'
p17115
aS'      NavierStokesProjection<2> test(data);'
p17116
aS'      test.run(data.verbose, data.output_interval);'
p17117
aS'    }'
p17118
aS'  catch (std::exception &exc)'
p17119
aS'    {'
p17120
aS'      std::cerr << std::endl'
p17121
aS'                << std::endl'
p17122
aS'                << "----------------------------------------------------"'
p17123
aS'                << std::endl;'
p17124
aS'      std::cerr << "Exception on processing: " << std::endl'
p17125
aS'                << exc.what() << std::endl'
p17126
aS'                << "Aborting!" << std::endl'
p17127
aS'                << "----------------------------------------------------"'
p17128
aS'                << std::endl;'
p17129
aS'      return 1;'
p17130
aS'    }'
p17131
aS'  catch (...)'
p17132
aS'    {'
p17133
aS'      std::cerr << std::endl'
p17134
aS'                << std::endl'
p17135
aS'                << "----------------------------------------------------"'
p17136
aS'                << std::endl;'
p17137
aS'      std::cerr << "Unknown exception!" << std::endl'
p17138
aS'                << "Aborting!" << std::endl'
p17139
aS'                << "----------------------------------------------------"'
p17140
aS'                << std::endl;'
p17141
aS'      return 1;'
p17142
aS'    }'
p17143
aS'  std::cout << "----------------------------------------------------"'
p17144
aS'            << std::endl'
p17145
aS'            << "Apparently everything went fine!" << std::endl'
p17146
aS'            << "Don\'t forget to brush your teeth :-)" << std::endl'
p17147
aS'            << std::endl;'
p17148
aS'  return 0;'
p17149
ag17
aS'#include <deal.II/base/logstream.h>'
p17150
aS'#include <deal.II/base/quadrature_lib.h>'
p17151
aS'#include <deal.II/base/function.h>'
p17152
aS'#include <deal.II/base/function_parser.h>'
p17153
aS'#include <deal.II/base/parameter_handler.h>'
p17154
aS'#include <deal.II/base/utilities.h>'
p17155
aS'#include <deal.II/grid/tria.h>'
p17156
aS'#include <deal.II/grid/grid_generator.h>'
p17157
aS'#include <deal.II/dofs/dof_handler.h>'
p17158
aS'#include <deal.II/dofs/dof_tools.h>'
p17159
aS'#include <deal.II/fe/fe_q.h>'
p17160
aS'#include <deal.II/fe/fe_values.h>'
p17161
aS'#include <deal.II/numerics/vector_tools.h>'
p17162
aS'#include <deal.II/numerics/matrix_tools.h>'
p17163
aS'#include <deal.II/numerics/data_out.h>'
p17164
aS'#include <deal.II/lac/affine_constraints.h>'
p17165
aS'#include <deal.II/lac/full_matrix.h>'
p17166
aS'#include <deal.II/base/index_set.h>'
p17167
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p17168
aS'#include <deal.II/lac/petsc_vector.h>'
p17169
aS'#include <deal.II/lac/slepc_solver.h>'
p17170
aS'#include <fstream>'
p17171
aS'#include <iostream>'
p17172
aS'namespace Step36'
p17173
ag9
aS'  using namespace dealii;'
p17174
aS'  template <int dim>'
p17175
aS'  class EigenvalueProblem'
p17176
aS'  {'
p17177
aS'  public:'
p17178
aS'    EigenvalueProblem(const std::string &prm_file);'
p17179
aS'    void run();'
p17180
aS'  private:'
p17181
aS'    void         make_grid_and_dofs();'
p17182
aS'    void         assemble_system();'
p17183
aS'    unsigned int solve();'
p17184
aS'    void         output_results() const;'
p17185
aS'    Triangulation<dim> triangulation;'
p17186
aS'    FE_Q<dim>          fe;'
p17187
aS'    DoFHandler<dim>    dof_handler;'
p17188
aS'    PETScWrappers::SparseMatrix             stiffness_matrix, mass_matrix;'
p17189
aS'    std::vector<PETScWrappers::MPI::Vector> eigenfunctions;'
p17190
aS'    std::vector<double>                     eigenvalues;'
p17191
aS'    ParameterHandler parameters;'
p17192
aS'    AffineConstraints<double> constraints;'
p17193
aS'  };'
p17194
aS'  template <int dim>'
p17195
aS'  EigenvalueProblem<dim>::EigenvalueProblem(const std::string &prm_file)'
p17196
aS'    : fe(1)'
p17197
aS'    , dof_handler(triangulation)'
p17198
aS'  {'
p17199
aS'    parameters.declare_entry('
p17200
aS'      "Global mesh refinement steps",'
p17201
aS'      "5",'
p17202
aS'      Patterns::Integer(0, 20),'
p17203
aS'      "The number of times the 1-cell coarse mesh should "'
p17204
aS'      "be refined globally for our computations.");'
p17205
aS'    parameters.declare_entry("Number of eigenvalues/eigenfunctions",'
p17206
aS'                             "5",'
p17207
aS'                             Patterns::Integer(0, 100),'
p17208
aS'                             "The number of eigenvalues/eigenfunctions "'
p17209
aS'                             "to be computed.");'
p17210
aS'    parameters.declare_entry("Potential",'
p17211
aS'                             "0",'
p17212
aS'                             Patterns::Anything(),'
p17213
aS'                             "A functional description of the potential.");'
p17214
aS'    parameters.parse_input(prm_file);'
p17215
aS'  }'
p17216
aS'  template <int dim>'
p17217
aS'  void EigenvalueProblem<dim>::make_grid_and_dofs()'
p17218
aS'  {'
p17219
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p17220
aS'    triangulation.refine_global('
p17221
aS'      parameters.get_integer("Global mesh refinement steps"));'
p17222
aS'    dof_handler.distribute_dofs(fe);'
p17223
aS'    DoFTools::make_zero_boundary_constraints(dof_handler, constraints);'
p17224
aS'    constraints.close();'
p17225
aS'    stiffness_matrix.reinit(dof_handler.n_dofs(),'
p17226
aS'                            dof_handler.n_dofs(),'
p17227
aS'                            dof_handler.max_couplings_between_dofs());'
p17228
aS'    mass_matrix.reinit(dof_handler.n_dofs(),'
p17229
aS'                       dof_handler.n_dofs(),'
p17230
aS'                       dof_handler.max_couplings_between_dofs());'
p17231
aS'    IndexSet eigenfunction_index_set = dof_handler.locally_owned_dofs();'
p17232
aS'    eigenfunctions.resize('
p17233
aS'      parameters.get_integer("Number of eigenvalues/eigenfunctions"));'
p17234
aS'    for (unsigned int i = 0; i < eigenfunctions.size(); ++i)'
p17235
aS'      eigenfunctions[i].reinit(eigenfunction_index_set, MPI_COMM_WORLD);'
p17236
aS'    eigenvalues.resize(eigenfunctions.size());'
p17237
aS'  }'
p17238
aS'  template <int dim>'
p17239
aS'  void EigenvalueProblem<dim>::assemble_system()'
p17240
aS'  {'
p17241
aS'    QGauss<dim> quadrature_formula(fe.degree + 1);'
p17242
aS'    FEValues<dim> fe_values(fe,'
p17243
aS'                            quadrature_formula,'
p17244
aS'                            update_values | update_gradients |'
p17245
aS'                              update_quadrature_points | update_JxW_values);'
p17246
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p17247
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p17248
aS'    FullMatrix<double> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);'
p17249
aS'    FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);'
p17250
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p17251
aS'    FunctionParser<dim> potential;'
p17252
aS'    potential.initialize(FunctionParser<dim>::default_variable_names(),'
p17253
aS'                         parameters.get("Potential"),'
p17254
aS'                         typename FunctionParser<dim>::ConstMap());'
p17255
aS'    std::vector<double> potential_values(n_q_points);'
p17256
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p17257
aS'      {'
p17258
aS'        fe_values.reinit(cell);'
p17259
aS'        cell_stiffness_matrix = 0;'
p17260
aS'        cell_mass_matrix      = 0;'
p17261
aS'        potential.value_list(fe_values.get_quadrature_points(),'
p17262
aS'                             potential_values);'
p17263
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p17264
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p17265
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p17266
aS'              {'
p17267
aS'                cell_stiffness_matrix(i, j) +=           //'
p17268
aS'                     fe_values.shape_grad(j, q_point)    //'
p17269
aS'                   +                                     //'
p17270
aS'                   potential_values[q_point] *           //'
p17271
aS'                     fe_values.shape_value(i, q_point) * //'
p17272
aS'                     fe_values.shape_value(j, q_point)   //'
p17273
aS'                  fe_values.JxW(q_point);                //'
p17274
aS'                cell_mass_matrix(i, j) +=              //'
p17275
aS'                   fe_values.shape_value(j, q_point)   //'
p17276
aS'                  fe_values.JxW(q_point);              //'
p17277
aS'              }'
p17278
aS'        cell->get_dof_indices(local_dof_indices);'
p17279
aS'        constraints.distribute_local_to_global(cell_stiffness_matrix,'
p17280
aS'                                               local_dof_indices,'
p17281
aS'                                               stiffness_matrix);'
p17282
aS'        constraints.distribute_local_to_global(cell_mass_matrix,'
p17283
aS'                                               local_dof_indices,'
p17284
aS'                                               mass_matrix);'
p17285
aS'      }'
p17286
aS'    stiffness_matrix.compress(VectorOperation::add);'
p17287
aS'    mass_matrix.compress(VectorOperation::add);'
p17288
aS'    double min_spurious_eigenvalue = std::numeric_limits<double>::max(),'
p17289
aS'           max_spurious_eigenvalue = -std::numeric_limits<double>::max();'
p17290
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p17291
aS'      if (constraints.is_constrained(i))'
p17292
aS'        {'
p17293
aS'          const double ev         = stiffness_matrix(i, i) / mass_matrix(i, i);'
p17294
aS'          min_spurious_eigenvalue = std::min(min_spurious_eigenvalue, ev);'
p17295
aS'          max_spurious_eigenvalue = std::max(max_spurious_eigenvalue, ev);'
p17296
aS'        }'
p17297
aS'    std::cout << "   Spurious eigenvalues are all in the interval "'
p17298
aS'              << "[" << min_spurious_eigenvalue << ","'
p17299
aS'              << max_spurious_eigenvalue << "]" << std::endl;'
p17300
aS'  }'
p17301
aS'  template <int dim>'
p17302
aS'  unsigned int EigenvalueProblem<dim>::solve()'
p17303
aS'  {'
p17304
aS'    SolverControl                    solver_control(dof_handler.n_dofs(), 1e-9);'
p17305
aS'    SLEPcWrappers::SolverKrylovSchur eigensolver(solver_control);'
p17306
aS'    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);'
p17307
aS'    eigensolver.set_problem_type(EPS_GHEP);'
p17308
aS'    eigensolver.solve(stiffness_matrix,'
p17309
aS'                      mass_matrix,'
p17310
aS'                      eigenvalues,'
p17311
aS'                      eigenfunctions,'
p17312
aS'                      eigenfunctions.size());'
p17313
aS'    for (unsigned int i = 0; i < eigenfunctions.size(); ++i)'
p17314
aS'      eigenfunctions[i] /= eigenfunctions[i].linfty_norm();'
p17315
aS'    return solver_control.last_step();'
p17316
aS'  }'
p17317
aS'  template <int dim>'
p17318
aS'  void EigenvalueProblem<dim>::output_results() const'
p17319
aS'  {'
p17320
aS'    DataOut<dim> data_out;'
p17321
aS'    data_out.attach_dof_handler(dof_handler);'
p17322
aS'    for (unsigned int i = 0; i < eigenfunctions.size(); ++i)'
p17323
aS'      data_out.add_data_vector(eigenfunctions[i],'
p17324
aS'                               std::string("eigenfunction_") +'
p17325
aS'                                 Utilities::int_to_string(i));'
p17326
aS'    Vector<double> projected_potential(dof_handler.n_dofs());'
p17327
aS'    {'
p17328
aS'      FunctionParser<dim> potential;'
p17329
aS'      potential.initialize(FunctionParser<dim>::default_variable_names(),'
p17330
aS'                           parameters.get("Potential"),'
p17331
aS'                           typename FunctionParser<dim>::ConstMap());'
p17332
aS'      VectorTools::interpolate(dof_handler, potential, projected_potential);'
p17333
aS'    }'
p17334
aS'    data_out.add_data_vector(projected_potential, "interpolated_potential");'
p17335
aS'    data_out.build_patches();'
p17336
aS'    std::ofstream output("eigenvectors.vtk");'
p17337
aS'    data_out.write_vtk(output);'
p17338
aS'  }'
p17339
aS'  template <int dim>'
p17340
aS'  void EigenvalueProblem<dim>::run()'
p17341
aS'  {'
p17342
aS'    make_grid_and_dofs();'
p17343
aS'    std::cout << "   Number of active cells:       "'
p17344
aS'              << triangulation.n_active_cells() << std::endl'
p17345
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p17346
aS'              << std::endl;'
p17347
aS'    assemble_system();'
p17348
aS'    const unsigned int n_iterations = solve();'
p17349
aS'    std::cout << "   Solver converged in " << n_iterations << " iterations."'
p17350
aS'              << std::endl;'
p17351
aS'    output_results();'
p17352
aS'    std::cout << std::endl;'
p17353
aS'    for (unsigned int i = 0; i < eigenvalues.size(); ++i)'
p17354
aS'      std::cout << "      Eigenvalue " << i << " : " << eigenvalues[i]'
p17355
aS'                << std::endl;'
p17356
aS'  }'
p17357
aS'} // namespace Step36'
p17358
aS'int main(int argc, char **argv)'
p17359
ag9
aS'  try'
p17360
aS'    {'
p17361
aS'      using namespace dealii;'
p17362
aS'      using namespace Step36;'
p17363
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p17364
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p17365
aS'                  ExcMessage('
p17366
aS'                    "This program can only be run in serial, use ./step-36"));'
p17367
aS'      EigenvalueProblem<2> problem("step-36.prm");'
p17368
aS'      problem.run();'
p17369
aS'    }'
p17370
aS'  catch (std::exception &exc)'
p17371
aS'    {'
p17372
aS'      std::cerr << std::endl'
p17373
aS'                << std::endl'
p17374
aS'                << "----------------------------------------------------"'
p17375
aS'                << std::endl;'
p17376
aS'      std::cerr << "Exception on processing: " << std::endl'
p17377
aS'                << exc.what() << std::endl'
p17378
aS'                << "Aborting!" << std::endl'
p17379
aS'                << "----------------------------------------------------"'
p17380
aS'                << std::endl;'
p17381
aS'      return 1;'
p17382
aS'    }'
p17383
aS'  catch (...)'
p17384
aS'    {'
p17385
aS'      std::cerr << std::endl'
p17386
aS'                << std::endl'
p17387
aS'                << "----------------------------------------------------"'
p17388
aS'                << std::endl;'
p17389
aS'      std::cerr << "Unknown exception!" << std::endl'
p17390
aS'                << "Aborting!" << std::endl'
p17391
aS'                << "----------------------------------------------------"'
p17392
aS'                << std::endl;'
p17393
aS'      return 1;'
p17394
aS'    }'
p17395
aS'  std::cout << std::endl << "   Job done." << std::endl;'
p17396
aS'  return 0;'
p17397
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p17398
aS'#include <deal.II/base/function.h>'
p17399
aS'#include <deal.II/base/timer.h>'
p17400
aS'#include <deal.II/lac/affine_constraints.h>'
p17401
aS'#include <deal.II/lac/solver_cg.h>'
p17402
aS'#include <deal.II/lac/la_parallel_vector.h>'
p17403
aS'#include <deal.II/lac/precondition.h>'
p17404
aS'#include <deal.II/fe/fe_q.h>'
p17405
aS'#include <deal.II/grid/tria.h>'
p17406
aS'#include <deal.II/grid/grid_generator.h>'
p17407
aS'#include <deal.II/multigrid/multigrid.h>'
p17408
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p17409
aS'#include <deal.II/multigrid/mg_tools.h>'
p17410
aS'#include <deal.II/multigrid/mg_coarse.h>'
p17411
aS'#include <deal.II/multigrid/mg_smoother.h>'
p17412
aS'#include <deal.II/multigrid/mg_matrix.h>'
p17413
aS'#include <deal.II/numerics/data_out.h>'
p17414
aS'#include <deal.II/numerics/vector_tools.h>'
p17415
aS'#include <deal.II/matrix_free/matrix_free.h>'
p17416
aS'#include <deal.II/matrix_free/operators.h>'
p17417
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p17418
aS'#include <iostream>'
p17419
aS'#include <fstream>'
p17420
aS'namespace Step37'
p17421
ag9
aS'  using namespace dealii;'
p17422
aS'  const unsigned int degree_finite_element = 2;'
p17423
aS'  const unsigned int dimension             = 3;'
p17424
aS'  template <int dim>'
p17425
aS'  class Coefficient : public Function<dim>'
p17426
aS'  {'
p17427
aS'  public:'
p17428
aS'    virtual double value(const Point<dim> & p,'
p17429
aS'                         const unsigned int component = 0) const override;'
p17430
aS'    template <typename number>'
p17431
aS'    number value(const Point<dim, number> &p,'
p17432
aS'                 const unsigned int        component = 0) const;'
p17433
aS'  };'
p17434
aS'  template <int dim>'
p17435
aS'  template <typename number>'
p17436
aS'  number Coefficient<dim>::value(const Point<dim, number> &p,'
p17437
aS'                                 const unsigned int /*component*/) const'
p17438
aS'  {'
p17439
aS'    return 1. / (0.05 + 2. * p.square());'
p17440
aS'  }'
p17441
aS'  template <int dim>'
p17442
aS'  double Coefficient<dim>::value(const Point<dim> & p,'
p17443
aS'                                 const unsigned int component) const'
p17444
aS'  {'
p17445
aS'    return value<double>(p, component);'
p17446
aS'  }'
p17447
aS'  template <int dim, int fe_degree, typename number>'
p17448
aS'  class LaplaceOperator'
p17449
aS'    : public MatrixFreeOperators::'
p17450
aS'        Base<dim, LinearAlgebra::distributed::Vector<number>>'
p17451
aS'  {'
p17452
aS'  public:'
p17453
aS'    using value_type = number;'
p17454
aS'    LaplaceOperator();'
p17455
aS'    void clear() override;'
p17456
aS'    void evaluate_coefficient(const Coefficient<dim> &coefficient_function);'
p17457
aS'    virtual void compute_diagonal() override;'
p17458
aS'  private:'
p17459
aS'    virtual void apply_add('
p17460
aS'      LinearAlgebra::distributed::Vector<number> &      dst,'
p17461
aS'      const LinearAlgebra::distributed::Vector<number> &src) const override;'
p17462
aS'    void'
p17463
aS'    local_apply(const MatrixFree<dim, number> &                   data,'
p17464
aS'                LinearAlgebra::distributed::Vector<number> &      dst,'
p17465
aS'                const LinearAlgebra::distributed::Vector<number> &src,'
p17466
aS'                const std::pair<unsigned int, unsigned int> &cell_range) const;'
p17467
aS'    void local_compute_diagonal('
p17468
aS'      const MatrixFree<dim, number> &              data,'
p17469
aS'      LinearAlgebra::distributed::Vector<number> & dst,'
p17470
aS'      const unsigned int &                         dummy,'
p17471
aS'      const std::pair<unsigned int, unsigned int> &cell_range) const;'
p17472
aS'    Table<2, VectorizedArray<number>> coefficient;'
p17473
aS'  };'
p17474
aS'  template <int dim, int fe_degree, typename number>'
p17475
aS'  LaplaceOperator<dim, fe_degree, number>::LaplaceOperator()'
p17476
aS'    : MatrixFreeOperators::Base<dim,'
p17477
aS'                                LinearAlgebra::distributed::Vector<number>>()'
p17478
aS'  {}'
p17479
aS'  template <int dim, int fe_degree, typename number>'
p17480
aS'  void LaplaceOperator<dim, fe_degree, number>::clear()'
p17481
aS'  {'
p17482
aS'    coefficient.reinit(0, 0);'
p17483
aS'    MatrixFreeOperators::Base<dim, LinearAlgebra::distributed::Vector<number>>::'
p17484
aS'      clear();'
p17485
aS'  }'
p17486
aS'  template <int dim, int fe_degree, typename number>'
p17487
aS'  void LaplaceOperator<dim, fe_degree, number>::evaluate_coefficient('
p17488
aS'    const Coefficient<dim> &coefficient_function)'
p17489
aS'  {'
p17490
aS'    const unsigned int n_cells = this->data->n_cell_batches();'
p17491
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*this->data);'
p17492
aS'    coefficient.reinit(n_cells, phi.n_q_points);'
p17493
aS'    for (unsigned int cell = 0; cell < n_cells; ++cell)'
p17494
aS'      {'
p17495
aS'        phi.reinit(cell);'
p17496
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p17497
aS'          coefficient(cell, q) ='
p17498
aS'            coefficient_function.value(phi.quadrature_point(q));'
p17499
aS'      }'
p17500
aS'  }'
p17501
aS'  template <int dim, int fe_degree, typename number>'
p17502
aS'  void LaplaceOperator<dim, fe_degree, number>::local_apply('
p17503
aS'    const MatrixFree<dim, number> &                   data,'
p17504
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p17505
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p17506
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p17507
aS'  {'
p17508
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data);'
p17509
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p17510
aS'      {'
p17511
aS'        AssertDimension(coefficient.size(0), data.n_cell_batches());'
p17512
aS'        AssertDimension(coefficient.size(1), phi.n_q_points);'
p17513
aS'        phi.reinit(cell);'
p17514
aS'        phi.read_dof_values(src);'
p17515
aS'        phi.evaluate(EvaluationFlags::gradients);'
p17516
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p17517
aS'          phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);'
p17518
aS'        phi.integrate(EvaluationFlags::gradients);'
p17519
aS'        phi.distribute_local_to_global(dst);'
p17520
aS'      }'
p17521
aS'  }'
p17522
aS'  template <int dim, int fe_degree, typename number>'
p17523
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_add('
p17524
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p17525
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p17526
aS'  {'
p17527
aS'    this->data->cell_loop(&LaplaceOperator::local_apply, this, dst, src);'
p17528
aS'  }'
p17529
aS'  template <int dim, int fe_degree, typename number>'
p17530
aS'  void LaplaceOperator<dim, fe_degree, number>::compute_diagonal()'
p17531
aS'  {'
p17532
aS'    this->inverse_diagonal_entries.reset('
p17533
aS'      new DiagonalMatrix<LinearAlgebra::distributed::Vector<number>>());'
p17534
aS'    LinearAlgebra::distributed::Vector<number> &inverse_diagonal ='
p17535
aS'      this->inverse_diagonal_entries->get_vector();'
p17536
aS'    this->data->initialize_dof_vector(inverse_diagonal);'
p17537
aS'    unsigned int dummy = 0;'
p17538
aS'    this->data->cell_loop(&LaplaceOperator::local_compute_diagonal,'
p17539
aS'                          this,'
p17540
aS'                          inverse_diagonal,'
p17541
aS'                          dummy);'
p17542
aS'    this->set_constrained_entries_to_one(inverse_diagonal);'
p17543
aS'    for (unsigned int i = 0; i < inverse_diagonal.locally_owned_size(); ++i)'
p17544
aS'      {'
p17545
aS'        Assert(inverse_diagonal.local_element(i) > 0.,'
p17546
aS'               ExcMessage("No diagonal entry in a positive definite operator "'
p17547
aS'                          "should be zero"));'
p17548
aS'        inverse_diagonal.local_element(i) ='
p17549
aS'          1. / inverse_diagonal.local_element(i);'
p17550
aS'      }'
p17551
aS'  }'
p17552
aS'  template <int dim, int fe_degree, typename number>'
p17553
aS'  void LaplaceOperator<dim, fe_degree, number>::local_compute_diagonal('
p17554
aS'    const MatrixFree<dim, number> &             data,'
p17555
aS'    LinearAlgebra::distributed::Vector<number> &dst,'
p17556
aS'    const unsigned int &,'
p17557
aS'    const std::pair<unsigned int, unsigned int> &cell_range) const'
p17558
aS'  {'
p17559
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data);'
p17560
aS'    AlignedVector<VectorizedArray<number>> diagonal(phi.dofs_per_cell);'
p17561
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p17562
aS'      {'
p17563
aS'        AssertDimension(coefficient.size(0), data.n_cell_batches());'
p17564
aS'        AssertDimension(coefficient.size(1), phi.n_q_points);'
p17565
aS'        phi.reinit(cell);'
p17566
aS'        for (unsigned int i = 0; i < phi.dofs_per_cell; ++i)'
p17567
aS'          {'
p17568
aS'            for (unsigned int j = 0; j < phi.dofs_per_cell; ++j)'
p17569
aS'              phi.submit_dof_value(VectorizedArray<number>(), j);'
p17570
aS'            phi.submit_dof_value(make_vectorized_array<number>(1.), i);'
p17571
aS'            phi.evaluate(EvaluationFlags::gradients);'
p17572
aS'            for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p17573
aS'              phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),'
p17574
aS'                                  q);'
p17575
aS'            phi.integrate(EvaluationFlags::gradients);'
p17576
aS'            diagonal[i] = phi.get_dof_value(i);'
p17577
aS'          }'
p17578
aS'        for (unsigned int i = 0; i < phi.dofs_per_cell; ++i)'
p17579
aS'          phi.submit_dof_value(diagonal[i], i);'
p17580
aS'        phi.distribute_local_to_global(dst);'
p17581
aS'      }'
p17582
aS'  }'
p17583
aS'  template <int dim>'
p17584
aS'  class LaplaceProblem'
p17585
aS'  {'
p17586
aS'  public:'
p17587
aS'    LaplaceProblem();'
p17588
aS'    void run();'
p17589
aS'  private:'
p17590
aS'    void setup_system();'
p17591
aS'    void assemble_rhs();'
p17592
aS'    void solve();'
p17593
aS'    void output_results(const unsigned int cycle) const;'
p17594
aS'#ifdef DEAL_II_WITH_P4EST'
p17595
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p17596
aS'#else'
p17597
aS'    Triangulation<dim> triangulation;'
p17598
aS'#endif'
p17599
aS'    FE_Q<dim>       fe;'
p17600
aS'    DoFHandler<dim> dof_handler;'
p17601
aS'    MappingQ1<dim> mapping;'
p17602
aS'    AffineConstraints<double> constraints;'
p17603
aS'    using SystemMatrixType ='
p17604
aS'      LaplaceOperator<dim, degree_finite_element, double>;'
p17605
aS'    SystemMatrixType system_matrix;'
p17606
aS'    MGConstrainedDoFs mg_constrained_dofs;'
p17607
aS'    using LevelMatrixType = LaplaceOperator<dim, degree_finite_element, float>;'
p17608
aS'    MGLevelObject<LevelMatrixType> mg_matrices;'
p17609
aS'    LinearAlgebra::distributed::Vector<double> solution;'
p17610
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p17611
aS'    double             setup_time;'
p17612
aS'    ConditionalOStream pcout;'
p17613
aS'    ConditionalOStream time_details;'
p17614
aS'  };'
p17615
aS'  template <int dim>'
p17616
aS'  LaplaceProblem<dim>::LaplaceProblem()'
p17617
aS'    :'
p17618
aS'#ifdef DEAL_II_WITH_P4EST'
p17619
aS'    triangulation('
p17620
aS'      MPI_COMM_WORLD,'
p17621
aS'      Triangulation<dim>::limit_level_difference_at_vertices,'
p17622
aS'      parallel::distributed::Triangulation<dim>::construct_multigrid_hierarchy)'
p17623
aS'    ,'
p17624
aS'#else'
p17625
aS'    triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p17626
aS'    ,'
p17627
aS'#endif'
p17628
aS'    fe(degree_finite_element)'
p17629
aS'    , dof_handler(triangulation)'
p17630
aS'    , setup_time(0.)'
p17631
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p17632
aS'    ,'
p17633
aS'    time_details(std::cout,'
p17634
aS'                 false && Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p17635
aS'  {}'
p17636
aS'  template <int dim>'
p17637
aS'  void LaplaceProblem<dim>::setup_system()'
p17638
aS'  {'
p17639
aS'    Timer time;'
p17640
aS'    setup_time = 0;'
p17641
aS'    system_matrix.clear();'
p17642
aS'    mg_matrices.clear_elements();'
p17643
aS'    dof_handler.distribute_dofs(fe);'
p17644
aS'    dof_handler.distribute_mg_dofs();'
p17645
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p17646
aS'          << std::endl;'
p17647
aS'    IndexSet locally_relevant_dofs;'
p17648
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p17649
aS'    constraints.clear();'
p17650
aS'    constraints.reinit(locally_relevant_dofs);'
p17651
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p17652
aS'    VectorTools::interpolate_boundary_values('
p17653
aS'      mapping, dof_handler, 0, Functions::ZeroFunction<dim>(), constraints);'
p17654
aS'    constraints.close();'
p17655
aS'    setup_time += time.wall_time();'
p17656
aS'    time_details << "Distribute DoFs & B.C.     (CPU/wall) " << time.cpu_time()'
p17657
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p17658
aS'    time.restart();'
p17659
aS'    {'
p17660
aS'      typename MatrixFree<dim, double>::AdditionalData additional_data;'
p17661
aS'      additional_data.tasks_parallel_scheme ='
p17662
aS'        MatrixFree<dim, double>::AdditionalData::none;'
p17663
aS'      additional_data.mapping_update_flags ='
p17664
aS'      std::shared_ptr<MatrixFree<dim, double>> system_mf_storage('
p17665
aS'        new MatrixFree<dim, double>());'
p17666
aS'      system_mf_storage->reinit(mapping,'
p17667
aS'                                dof_handler,'
p17668
aS'                                constraints,'
p17669
aS'                                QGauss<1>(fe.degree + 1),'
p17670
aS'                                additional_data);'
p17671
aS'      system_matrix.initialize(system_mf_storage);'
p17672
aS'    }'
p17673
aS'    system_matrix.evaluate_coefficient(Coefficient<dim>());'
p17674
aS'    system_matrix.initialize_dof_vector(solution);'
p17675
aS'    system_matrix.initialize_dof_vector(system_rhs);'
p17676
aS'    setup_time += time.wall_time();'
p17677
aS'    time_details << "Setup matrix-free system   (CPU/wall) " << time.cpu_time()'
p17678
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p17679
aS'    time.restart();'
p17680
aS'    const unsigned int nlevels = triangulation.n_global_levels();'
p17681
aS'    mg_matrices.resize(0, nlevels - 1);'
p17682
aS'    std::set<types::boundary_id> dirichlet_boundary;'
p17683
aS'    dirichlet_boundary.insert(0);'
p17684
aS'    mg_constrained_dofs.initialize(dof_handler);'
p17685
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p17686
aS'                                                       dirichlet_boundary);'
p17687
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p17688
aS'      {'
p17689
aS'        IndexSet relevant_dofs;'
p17690
aS'        DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p17691
aS'                                                      level,'
p17692
aS'                                                      relevant_dofs);'
p17693
aS'        AffineConstraints<double> level_constraints;'
p17694
aS'        level_constraints.reinit(relevant_dofs);'
p17695
aS'        level_constraints.add_lines('
p17696
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p17697
aS'        level_constraints.close();'
p17698
aS'        typename MatrixFree<dim, float>::AdditionalData additional_data;'
p17699
aS'        additional_data.tasks_parallel_scheme ='
p17700
aS'          MatrixFree<dim, float>::AdditionalData::none;'
p17701
aS'        additional_data.mapping_update_flags ='
p17702
aS'        additional_data.mg_level = level;'
p17703
aS'        std::shared_ptr<MatrixFree<dim, float>> mg_mf_storage_level('
p17704
aS'          new MatrixFree<dim, float>());'
p17705
aS'        mg_mf_storage_level->reinit(mapping,'
p17706
aS'                                    dof_handler,'
p17707
aS'                                    level_constraints,'
p17708
aS'                                    QGauss<1>(fe.degree + 1),'
p17709
aS'                                    additional_data);'
p17710
aS'        mg_matrices[level].initialize(mg_mf_storage_level,'
p17711
aS'                                      mg_constrained_dofs,'
p17712
aS'                                      level);'
p17713
aS'        mg_matrices[level].evaluate_coefficient(Coefficient<dim>());'
p17714
aS'      }'
p17715
aS'    setup_time += time.wall_time();'
p17716
aS'    time_details << "Setup matrix-free levels   (CPU/wall) " << time.cpu_time()'
p17717
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p17718
aS'  }'
p17719
aS'  template <int dim>'
p17720
aS'  void LaplaceProblem<dim>::assemble_rhs()'
p17721
aS'  {'
p17722
aS'    Timer time;'
p17723
aS'    system_rhs = 0;'
p17724
aS'    FEEvaluation<dim, degree_finite_element> phi('
p17725
aS'    for (unsigned int cell = 0;'
p17726
aS'         cell < system_matrix.get_matrix_free()->n_cell_batches();'
p17727
aS'         ++cell)'
p17728
aS'      {'
p17729
aS'        phi.reinit(cell);'
p17730
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p17731
aS'          phi.submit_value(make_vectorized_array<double>(1.0), q);'
p17732
aS'        phi.integrate(EvaluationFlags::values);'
p17733
aS'        phi.distribute_local_to_global(system_rhs);'
p17734
aS'      }'
p17735
aS'    system_rhs.compress(VectorOperation::add);'
p17736
aS'    setup_time += time.wall_time();'
p17737
aS'    time_details << "Assemble right hand side   (CPU/wall) " << time.cpu_time()'
p17738
aS'                 << "s/" << time.wall_time() << "s" << std::endl;'
p17739
aS'  }'
p17740
aS'  template <int dim>'
p17741
aS'  void LaplaceProblem<dim>::solve()'
p17742
aS'  {'
p17743
aS'    Timer                            time;'
p17744
aS'    MGTransferMatrixFree<dim, float> mg_transfer(mg_constrained_dofs);'
p17745
aS'    mg_transfer.build(dof_handler);'
p17746
aS'    setup_time += time.wall_time();'
p17747
aS'    time_details << "MG build transfer time     (CPU/wall) " << time.cpu_time()'
p17748
aS'                 << "s/" << time.wall_time() << "s\\n";'
p17749
aS'    time.restart();'
p17750
aS'    using SmootherType ='
p17751
aS'      PreconditionChebyshev<LevelMatrixType,'
p17752
aS'                            LinearAlgebra::distributed::Vector<float>>;'
p17753
aS'    mg::SmootherRelaxation<SmootherType,'
p17754
aS'                           LinearAlgebra::distributed::Vector<float>>'
p17755
aS'                                                         mg_smoother;'
p17756
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data;'
p17757
aS'    smoother_data.resize(0, triangulation.n_global_levels() - 1);'
p17758
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p17759
aS'         ++level)'
p17760
aS'      {'
p17761
aS'        if (level > 0)'
p17762
aS'          {'
p17763
aS'            smoother_data[level].smoothing_range     = 15.;'
p17764
aS'            smoother_data[level].degree              = 5;'
p17765
aS'            smoother_data[level].eig_cg_n_iterations = 10;'
p17766
aS'          }'
p17767
aS'        else'
p17768
aS'          {'
p17769
aS'            smoother_data[0].smoothing_range = 1e-3;'
p17770
aS'            smoother_data[0].degree          = numbers::invalid_unsigned_int;'
p17771
aS'            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();'
p17772
aS'          }'
p17773
aS'        mg_matrices[level].compute_diagonal();'
p17774
aS'        smoother_data[level].preconditioner ='
p17775
aS'          mg_matrices[level].get_matrix_diagonal_inverse();'
p17776
aS'      }'
p17777
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p17778
aS'    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>>'
p17779
aS'      mg_coarse;'
p17780
aS'    mg_coarse.initialize(mg_smoother);'
p17781
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix('
p17782
aS'      mg_matrices);'
p17783
aS'    MGLevelObject<MatrixFreeOperators::MGInterfaceOperator<LevelMatrixType>>'
p17784
aS'      mg_interface_matrices;'
p17785
aS'    mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1);'
p17786
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p17787
aS'         ++level)'
p17788
aS'      mg_interface_matrices[level].initialize(mg_matrices[level]);'
p17789
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_interface('
p17790
aS'      mg_interface_matrices);'
p17791
aS'    Multigrid<LinearAlgebra::distributed::Vector<float>> mg('
p17792
aS'      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p17793
aS'    mg.set_edge_matrices(mg_interface, mg_interface);'
p17794
aS'    PreconditionMG<dim,'
p17795
aS'                   LinearAlgebra::distributed::Vector<float>,'
p17796
aS'                   MGTransferMatrixFree<dim, float>>'
p17797
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p17798
aS'    SolverControl solver_control(100, 1e-12 * system_rhs.l2_norm());'
p17799
aS'    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control);'
p17800
aS'    setup_time += time.wall_time();'
p17801
aS'    time_details << "MG build smoother time     (CPU/wall) " << time.cpu_time()'
p17802
aS'                 << "s/" << time.wall_time() << "s\\n";'
p17803
aS'    pcout << "Total setup time               (wall) " << setup_time << "s\\n";'
p17804
aS'    time.reset();'
p17805
aS'    time.start();'
p17806
aS'    constraints.set_zero(solution);'
p17807
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p17808
aS'    constraints.distribute(solution);'
p17809
aS'    pcout << "Time solve (" << solver_control.last_step() << " iterations)"'
p17810
aS'          << (solver_control.last_step() < 10 ? "  " : " ") << "(CPU/wall) "'
p17811
aS'          << time.cpu_time() << "s/" << time.wall_time() << "s\\n";'
p17812
aS'  }'
p17813
aS'  template <int dim>'
p17814
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p17815
aS'  {'
p17816
aS'    Timer time;'
p17817
aS'    if (triangulation.n_global_active_cells() > 1000000)'
p17818
aS'      return;'
p17819
aS'    DataOut<dim> data_out;'
p17820
aS'    solution.update_ghost_values();'
p17821
aS'    data_out.attach_dof_handler(dof_handler);'
p17822
aS'    data_out.add_data_vector(solution, "solution");'
p17823
aS'    data_out.build_patches(mapping);'
p17824
aS'    DataOutBase::VtkFlags flags;'
p17825
aS'    flags.compression_level = DataOutBase::VtkFlags::best_speed;'
p17826
aS'    data_out.set_flags(flags);'
p17827
aS'    data_out.write_vtu_with_pvtu_record('
p17828
aS'      "./", "solution", cycle, MPI_COMM_WORLD, 3);'
p17829
aS'    time_details << "Time write output          (CPU/wall) " << time.cpu_time()'
p17830
aS'                 << "s/" << time.wall_time() << "s\\n";'
p17831
aS'  }'
p17832
aS'  template <int dim>'
p17833
aS'  void LaplaceProblem<dim>::run()'
p17834
aS'  {'
p17835
aS'    {'
p17836
aS'      const unsigned int n_vect_doubles = VectorizedArray<double>::size();'
p17837
aS'      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles;'
p17838
aS'      pcout << "Vectorization over " << n_vect_doubles'
p17839
aS'            << " doubles = " << n_vect_bits << " bits ("'
p17840
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p17841
aS'            << std::endl;'
p17842
aS'    }'
p17843
aS'    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle)'
p17844
aS'      {'
p17845
aS'        pcout << "Cycle " << cycle << std::endl;'
p17846
aS'        if (cycle == 0)'
p17847
aS'          {'
p17848
aS'            GridGenerator::hyper_cube(triangulation, 0., 1.);'
p17849
aS'            triangulation.refine_global(3 - dim);'
p17850
aS'          }'
p17851
aS'        triangulation.refine_global(1);'
p17852
aS'        setup_system();'
p17853
aS'        assemble_rhs();'
p17854
aS'        solve();'
p17855
aS'        output_results(cycle);'
p17856
aS'        pcout << std::endl;'
p17857
aS'      };'
p17858
aS'  }'
p17859
aS'} // namespace Step37'
p17860
aS'int main(int argc, char *argv[])'
p17861
ag9
aS'  try'
p17862
aS'    {'
p17863
aS'      using namespace Step37;'
p17864
aS'      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);'
p17865
aS'      LaplaceProblem<dimension> laplace_problem;'
p17866
aS'      laplace_problem.run();'
p17867
aS'    }'
p17868
aS'  catch (std::exception &exc)'
p17869
aS'    {'
p17870
aS'      std::cerr << std::endl'
p17871
aS'                << std::endl'
p17872
aS'                << "----------------------------------------------------"'
p17873
aS'                << std::endl;'
p17874
aS'      std::cerr << "Exception on processing: " << std::endl'
p17875
aS'                << exc.what() << std::endl'
p17876
aS'                << "Aborting!" << std::endl'
p17877
aS'                << "----------------------------------------------------"'
p17878
aS'                << std::endl;'
p17879
aS'      return 1;'
p17880
aS'    }'
p17881
aS'  catch (...)'
p17882
aS'    {'
p17883
aS'      std::cerr << std::endl'
p17884
aS'                << std::endl'
p17885
aS'                << "----------------------------------------------------"'
p17886
aS'                << std::endl;'
p17887
aS'      std::cerr << "Unknown exception!" << std::endl'
p17888
aS'                << "Aborting!" << std::endl'
p17889
aS'                << "----------------------------------------------------"'
p17890
aS'                << std::endl;'
p17891
aS'      return 1;'
p17892
aS'    }'
p17893
aS'  return 0;'
p17894
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p17895
aS'#include <deal.II/base/function.h>'
p17896
aS'#include <deal.II/lac/full_matrix.h>'
p17897
aS'#include <deal.II/lac/vector.h>'
p17898
aS'#include <deal.II/lac/solver_control.h>'
p17899
aS'#include <deal.II/lac/solver_cg.h>'
p17900
aS'#include <deal.II/lac/precondition.h>'
p17901
aS'#include <deal.II/lac/sparse_matrix.h>'
p17902
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p17903
aS'#include <deal.II/grid/tria.h>'
p17904
aS'#include <deal.II/grid/manifold_lib.h>'
p17905
aS'#include <deal.II/grid/grid_generator.h>'
p17906
aS'#include <deal.II/dofs/dof_handler.h>'
p17907
aS'#include <deal.II/dofs/dof_tools.h>'
p17908
aS'#include <deal.II/fe/fe_q.h>'
p17909
aS'#include <deal.II/fe/fe_values.h>'
p17910
aS'#include <deal.II/fe/mapping_q.h>'
p17911
aS'#include <deal.II/numerics/data_out.h>'
p17912
aS'#include <deal.II/numerics/vector_tools.h>'
p17913
aS'#include <deal.II/numerics/matrix_tools.h>'
p17914
aS'#include <fstream>'
p17915
aS'#include <iostream>'
p17916
aS'namespace Step38'
p17917
ag9
aS'  using namespace dealii;'
p17918
aS'  template <int spacedim>'
p17919
aS'  class LaplaceBeltramiProblem'
p17920
aS'  {'
p17921
aS'  public:'
p17922
aS'    LaplaceBeltramiProblem(const unsigned degree = 2);'
p17923
aS'    void run();'
p17924
aS'  private:'
p17925
aS'    static constexpr unsigned int dim = spacedim - 1;'
p17926
aS'    void make_grid_and_dofs();'
p17927
aS'    void assemble_system();'
p17928
aS'    void solve();'
p17929
aS'    void output_results() const;'
p17930
aS'    void compute_error() const;'
p17931
aS'    Triangulation<dim, spacedim> triangulation;'
p17932
aS'    FE_Q<dim, spacedim>          fe;'
p17933
aS'    DoFHandler<dim, spacedim>    dof_handler;'
p17934
aS'    MappingQ<dim, spacedim>      mapping;'
p17935
aS'    SparsityPattern      sparsity_pattern;'
p17936
aS'    SparseMatrix<double> system_matrix;'
p17937
aS'    Vector<double> solution;'
p17938
aS'    Vector<double> system_rhs;'
p17939
aS'  };'
p17940
aS'  template <int dim>'
p17941
aS'  class Solution : public Function<dim>'
p17942
aS'  {'
p17943
aS'  public:'
p17944
aS'    virtual double value(const Point<dim> & p,'
p17945
aS'                         const unsigned int component = 0) const override;'
p17946
aS'    virtual Tensor<1, dim>'
p17947
aS'    gradient(const Point<dim> & p,'
p17948
aS'             const unsigned int component = 0) const override;'
p17949
aS'  };'
p17950
aS'  template <>'
p17951
aS'  double Solution<2>::value(const Point<2> &p, const unsigned int) const'
p17952
aS'  {'
p17953
aS'    return (-2. * p(0) * p(1));'
p17954
aS'  }'
p17955
aS'  template <>'
p17956
aS'  Tensor<1, 2> Solution<2>::gradient(const Point<2> &p,'
p17957
aS'                                     const unsigned int) const'
p17958
aS'  {'
p17959
aS'    Tensor<1, 2> return_value;'
p17960
aS'    return_value[0] = -2. * p(1) * (1 - 2. * p(0) * p(0));'
p17961
aS'    return_value[1] = -2. * p(0) * (1 - 2. * p(1) * p(1));'
p17962
aS'    return return_value;'
p17963
aS'  }'
p17964
aS'  template <>'
p17965
aS'  double Solution<3>::value(const Point<3> &p, const unsigned int) const'
p17966
aS'  {'
p17967
aS'    return (std::sin(numbers::PI * p(0)) * std::cos(numbers::PI * p(1)) *'
p17968
aS'            exp(p(2)));'
p17969
aS'  }'
p17970
aS'  template <>'
p17971
aS'  Tensor<1, 3> Solution<3>::gradient(const Point<3> &p,'
p17972
aS'                                     const unsigned int) const'
p17973
aS'  {'
p17974
aS'    using numbers::PI;'
p17975
aS'    Tensor<1, 3> return_value;'
p17976
aS'    return_value[0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p17977
aS'    return_value[1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p17978
aS'    return_value[2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p17979
aS'    return return_value;'
p17980
aS'  }'
p17981
aS'  template <int dim>'
p17982
aS'  class RightHandSide : public Function<dim>'
p17983
aS'  {'
p17984
aS'  public:'
p17985
aS'    virtual double value(const Point<dim> & p,'
p17986
aS'                         const unsigned int component = 0) const override;'
p17987
aS'  };'
p17988
aS'  template <>'
p17989
aS'  double RightHandSide<2>::value(const Point<2> &p,'
p17990
aS'                                 const unsigned int /*component*/) const'
p17991
aS'  {'
p17992
aS'    return (-8. * p(0) * p(1));'
p17993
aS'  }'
p17994
aS'  template <>'
p17995
aS'  double RightHandSide<3>::value(const Point<3> &p,'
p17996
aS'                                 const unsigned int /*component*/) const'
p17997
aS'  {'
p17998
aS'    using numbers::PI;'
p17999
aS'    Tensor<2, 3> hessian;'
p18000
aS'    hessian[0][0] = -PI * PI * sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18001
aS'    hessian[1][1] = -PI * PI * sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18002
aS'    hessian[2][2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18003
aS'    hessian[0][1] = -PI * PI * cos(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18004
aS'    hessian[1][0] = -PI * PI * cos(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18005
aS'    hessian[0][2] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18006
aS'    hessian[2][0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18007
aS'    hessian[1][2] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18008
aS'    hessian[2][1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18009
aS'    Tensor<1, 3> gradient;'
p18010
aS'    gradient[0] = PI * cos(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18011
aS'    gradient[1] = -PI * sin(PI * p(0)) * sin(PI * p(1)) * exp(p(2));'
p18012
aS'    gradient[2] = sin(PI * p(0)) * cos(PI * p(1)) * exp(p(2));'
p18013
aS'    Point<3> normal = p;'
p18014
aS'    normal /= p.norm();'
p18015
aS'    return (-trace(hessian) + 2 * (gradient * normal) +'
p18016
aS'  }'
p18017
aS'  template <int spacedim>'
p18018
aS'  LaplaceBeltramiProblem<spacedim>::LaplaceBeltramiProblem('
p18019
aS'    const unsigned degree)'
p18020
aS'    : fe(degree)'
p18021
aS'    , dof_handler(triangulation)'
p18022
aS'    , mapping(degree)'
p18023
aS'  {}'
p18024
aS'  template <int spacedim>'
p18025
aS'  void LaplaceBeltramiProblem<spacedim>::make_grid_and_dofs()'
p18026
aS'  {'
p18027
aS'    {'
p18028
aS'      Triangulation<spacedim> volume_mesh;'
p18029
aS'      GridGenerator::half_hyper_ball(volume_mesh);'
p18030
aS'      std::set<types::boundary_id> boundary_ids;'
p18031
aS'      boundary_ids.insert(0);'
p18032
aS'      GridGenerator::extract_boundary_mesh(volume_mesh,'
p18033
aS'                                           triangulation,'
p18034
aS'                                           boundary_ids);'
p18035
aS'    }'
p18036
aS'    triangulation.set_all_manifold_ids(0);'
p18037
aS'    triangulation.set_manifold(0, SphericalManifold<dim, spacedim>());'
p18038
aS'    triangulation.refine_global(4);'
p18039
aS'    std::cout << "Surface mesh has " << triangulation.n_active_cells()'
p18040
aS'              << " cells." << std::endl;'
p18041
aS'    dof_handler.distribute_dofs(fe);'
p18042
aS'    std::cout << "Surface mesh has " << dof_handler.n_dofs()'
p18043
aS'              << " degrees of freedom." << std::endl;'
p18044
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p18045
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p18046
aS'    sparsity_pattern.copy_from(dsp);'
p18047
aS'    system_matrix.reinit(sparsity_pattern);'
p18048
aS'    solution.reinit(dof_handler.n_dofs());'
p18049
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p18050
aS'  }'
p18051
aS'  template <int spacedim>'
p18052
aS'  void LaplaceBeltramiProblem<spacedim>::assemble_system()'
p18053
aS'  {'
p18054
aS'    system_matrix = 0;'
p18055
aS'    system_rhs    = 0;'
p18056
aS'    const QGauss<dim>       quadrature_formula(2 * fe.degree);'
p18057
aS'    FEValues<dim, spacedim> fe_values(mapping,'
p18058
aS'                                      fe,'
p18059
aS'                                      quadrature_formula,'
p18060
aS'                                      update_values | update_gradients |'
p18061
aS'                                        update_quadrature_points |'
p18062
aS'                                        update_JxW_values);'
p18063
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p18064
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p18065
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p18066
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p18067
aS'    std::vector<double>                  rhs_values(n_q_points);'
p18068
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p18069
aS'    RightHandSide<spacedim> rhs;'
p18070
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p18071
aS'      {'
p18072
aS'        cell_matrix = 0;'
p18073
aS'        cell_rhs    = 0;'
p18074
aS'        fe_values.reinit(cell);'
p18075
aS'        rhs.value_list(fe_values.get_quadrature_points(), rhs_values);'
p18076
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18077
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p18078
aS'            for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p18079
aS'              cell_matrix(i, j) += fe_values.shape_grad(i, q_point) *'
p18080
aS'                                   fe_values.shape_grad(j, q_point) *'
p18081
aS'                                   fe_values.JxW(q_point);'
p18082
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18083
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p18084
aS'            cell_rhs(i) += fe_values.shape_value(i, q_point) *'
p18085
aS'                           rhs_values[q_point] * fe_values.JxW(q_point);'
p18086
aS'        cell->get_dof_indices(local_dof_indices);'
p18087
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p18088
aS'          {'
p18089
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p18090
aS'              system_matrix.add(local_dof_indices[i],'
p18091
aS'                                local_dof_indices[j],'
p18092
aS'                                cell_matrix(i, j));'
p18093
aS'            system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p18094
aS'          }'
p18095
aS'      }'
p18096
aS'    std::map<types::global_dof_index, double> boundary_values;'
p18097
aS'    VectorTools::interpolate_boundary_values('
p18098
aS'      mapping, dof_handler, 0, Solution<spacedim>(), boundary_values);'
p18099
aS'    MatrixTools::apply_boundary_values('
p18100
aS'      boundary_values, system_matrix, solution, system_rhs, false);'
p18101
aS'  }'
p18102
aS'  template <int spacedim>'
p18103
aS'  void LaplaceBeltramiProblem<spacedim>::solve()'
p18104
aS'  {'
p18105
aS'    SolverControl solver_control(solution.size(), 1e-7 * system_rhs.l2_norm());'
p18106
aS'    SolverCG<Vector<double>> cg(solver_control);'
p18107
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p18108
aS'    preconditioner.initialize(system_matrix, 1.2);'
p18109
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p18110
aS'  }'
p18111
aS'  template <int spacedim>'
p18112
aS'  void LaplaceBeltramiProblem<spacedim>::output_results() const'
p18113
aS'  {'
p18114
aS'    DataOut<dim, spacedim> data_out;'
p18115
aS'    data_out.attach_dof_handler(dof_handler);'
p18116
aS'    data_out.add_data_vector(solution,'
p18117
aS'                             "solution",'
p18118
aS'                             DataOut<dim, spacedim>::type_dof_data);'
p18119
aS'    data_out.build_patches(mapping, mapping.get_degree());'
p18120
aS'    const std::string filename ='
p18121
aS'      "solution-" + std::to_string(spacedim) + "d.vtk";'
p18122
aS'    std::ofstream output(filename);'
p18123
aS'    data_out.write_vtk(output);'
p18124
aS'  }'
p18125
aS'  template <int spacedim>'
p18126
aS'  void LaplaceBeltramiProblem<spacedim>::compute_error() const'
p18127
aS'  {'
p18128
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p18129
aS'    VectorTools::integrate_difference(mapping,'
p18130
aS'                                      dof_handler,'
p18131
aS'                                      solution,'
p18132
aS'                                      Solution<spacedim>(),'
p18133
aS'                                      difference_per_cell,'
p18134
aS'                                      QGauss<dim>(2 * fe.degree + 1),'
p18135
aS'                                      VectorTools::H1_norm);'
p18136
aS'    double h1_error = VectorTools::compute_global_error(triangulation,'
p18137
aS'                                                        difference_per_cell,'
p18138
aS'                                                        VectorTools::H1_norm);'
p18139
aS'    std::cout << "H1 error = " << h1_error << std::endl;'
p18140
aS'  }'
p18141
aS'  template <int spacedim>'
p18142
aS'  void LaplaceBeltramiProblem<spacedim>::run()'
p18143
aS'  {'
p18144
aS'    make_grid_and_dofs();'
p18145
aS'    assemble_system();'
p18146
aS'    solve();'
p18147
aS'    output_results();'
p18148
aS'    compute_error();'
p18149
aS'  }'
p18150
aS'} // namespace Step38'
p18151
aS'int main()'
p18152
ag9
aS'  try'
p18153
aS'    {'
p18154
aS'      using namespace Step38;'
p18155
aS'      LaplaceBeltramiProblem<3> laplace_beltrami;'
p18156
aS'      laplace_beltrami.run();'
p18157
aS'    }'
p18158
aS'  catch (std::exception &exc)'
p18159
aS'    {'
p18160
aS'      std::cerr << std::endl'
p18161
aS'                << std::endl'
p18162
aS'                << "----------------------------------------------------"'
p18163
aS'                << std::endl;'
p18164
aS'      std::cerr << "Exception on processing: " << std::endl'
p18165
aS'                << exc.what() << std::endl'
p18166
aS'                << "Aborting!" << std::endl'
p18167
aS'                << "----------------------------------------------------"'
p18168
aS'                << std::endl;'
p18169
aS'      return 1;'
p18170
aS'    }'
p18171
aS'  catch (...)'
p18172
aS'    {'
p18173
aS'      std::cerr << std::endl'
p18174
aS'                << std::endl'
p18175
aS'                << "----------------------------------------------------"'
p18176
aS'                << std::endl;'
p18177
aS'      std::cerr << "Unknown exception!" << std::endl'
p18178
aS'                << "Aborting!" << std::endl'
p18179
aS'                << "----------------------------------------------------"'
p18180
aS'                << std::endl;'
p18181
aS'      return 1;'
p18182
aS'    }'
p18183
aS'  return 0;'
p18184
ag17
aS'#include <deal.II/lac/sparse_matrix.h>'
p18185
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p18186
aS'#include <deal.II/lac/solver_cg.h>'
p18187
aS'#include <deal.II/lac/precondition.h>'
p18188
aS'#include <deal.II/lac/precondition_block.h>'
p18189
aS'#include <deal.II/lac/block_vector.h>'
p18190
aS'#include <deal.II/grid/grid_generator.h>'
p18191
aS'#include <deal.II/grid/grid_refinement.h>'
p18192
aS'#include <deal.II/fe/fe_q.h>'
p18193
aS'#include <deal.II/fe/fe_dgp.h>'
p18194
aS'#include <deal.II/fe/fe_dgq.h>'
p18195
aS'#include <deal.II/dofs/dof_tools.h>'
p18196
aS'#include <deal.II/meshworker/dof_info.h>'
p18197
aS'#include <deal.II/meshworker/integration_info.h>'
p18198
aS'#include <deal.II/meshworker/assembler.h>'
p18199
aS'#include <deal.II/meshworker/loop.h>'
p18200
aS'#include <deal.II/integrators/laplace.h>'
p18201
aS'#include <deal.II/multigrid/mg_tools.h>'
p18202
aS'#include <deal.II/multigrid/multigrid.h>'
p18203
aS'#include <deal.II/multigrid/mg_matrix.h>'
p18204
aS'#include <deal.II/multigrid/mg_transfer.h>'
p18205
aS'#include <deal.II/multigrid/mg_coarse.h>'
p18206
aS'#include <deal.II/multigrid/mg_smoother.h>'
p18207
aS'#include <deal.II/base/function_lib.h>'
p18208
aS'#include <deal.II/base/quadrature_lib.h>'
p18209
aS'#include <deal.II/numerics/vector_tools.h>'
p18210
aS'#include <deal.II/numerics/data_out.h>'
p18211
aS'#include <iostream>'
p18212
aS'#include <fstream>'
p18213
aS'namespace Step39'
p18214
ag9
aS'  using namespace dealii;'
p18215
aS'  Functions::SlitSingularityFunction<2> exact_solution;'
p18216
aS'  template <int dim>'
p18217
aS'  class MatrixIntegrator : public MeshWorker::LocalIntegrator<dim>'
p18218
aS'  {'
p18219
aS'  public:'
p18220
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18221
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18222
aS'    void'
p18223
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18224
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18225
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18226
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18227
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p18228
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p18229
aS'  };'
p18230
aS'  template <int dim>'
p18231
aS'  void MatrixIntegrator<dim>::cell('
p18232
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p18233
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p18234
aS'  {'
p18235
aS'    LocalIntegrators::Laplace::cell_matrix(dinfo.matrix(0, false).matrix,'
p18236
aS'                                           info.fe_values());'
p18237
aS'  }'
p18238
aS'  template <int dim>'
p18239
aS'  void MatrixIntegrator<dim>::boundary('
p18240
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p18241
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p18242
aS'  {'
p18243
aS'    const unsigned int degree = info.fe_values(0).get_fe().tensor_degree();'
p18244
aS'    LocalIntegrators::Laplace::nitsche_matrix('
p18245
aS'      dinfo.matrix(0, false).matrix,'
p18246
aS'      info.fe_values(0),'
p18247
aS'      LocalIntegrators::Laplace::compute_penalty(dinfo, dinfo, degree, degree));'
p18248
aS'  }'
p18249
aS'  template <int dim>'
p18250
aS'  void MatrixIntegrator<dim>::face('
p18251
aS'    MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18252
aS'    MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18253
aS'    typename MeshWorker::IntegrationInfo<dim> &info1,'
p18254
aS'    typename MeshWorker::IntegrationInfo<dim> &info2) const'
p18255
aS'  {'
p18256
aS'    const unsigned int degree = info1.fe_values(0).get_fe().tensor_degree();'
p18257
aS'    LocalIntegrators::Laplace::ip_matrix('
p18258
aS'      dinfo1.matrix(0, false).matrix,'
p18259
aS'      dinfo1.matrix(0, true).matrix,'
p18260
aS'      dinfo2.matrix(0, true).matrix,'
p18261
aS'      dinfo2.matrix(0, false).matrix,'
p18262
aS'      info1.fe_values(0),'
p18263
aS'      info2.fe_values(0),'
p18264
aS'      LocalIntegrators::Laplace::compute_penalty('
p18265
aS'        dinfo1, dinfo2, degree, degree));'
p18266
aS'  }'
p18267
aS'  template <int dim>'
p18268
aS'  class RHSIntegrator : public MeshWorker::LocalIntegrator<dim>'
p18269
aS'  {'
p18270
aS'  public:'
p18271
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18272
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18273
aS'    void'
p18274
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18275
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18276
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18277
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18278
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p18279
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p18280
aS'  };'
p18281
aS'  template <int dim>'
p18282
aS'  void'
p18283
aS'  RHSIntegrator<dim>::cell(MeshWorker::DoFInfo<dim> &,'
p18284
aS'                           typename MeshWorker::IntegrationInfo<dim> &) const'
p18285
aS'  {}'
p18286
aS'  template <int dim>'
p18287
aS'  void RHSIntegrator<dim>::boundary('
p18288
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p18289
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p18290
aS'  {'
p18291
aS'    const FEValuesBase<dim> &fe           = info.fe_values();'
p18292
aS'    Vector<double> &         local_vector = dinfo.vector(0).block(0);'
p18293
aS'    std::vector<double> boundary_values(fe.n_quadrature_points);'
p18294
aS'    exact_solution.value_list(fe.get_quadrature_points(), boundary_values);'
p18295
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p18296
aS'    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() /'
p18297
aS'                           dinfo.cell->measure();'
p18298
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18299
aS'      for (unsigned int i = 0; i < fe.dofs_per_cell; ++i)'
p18300
aS'        local_vector(i) +='
p18301
aS'           + fe.normal_vector(k) * fe.shape_grad(i, k)) // + n * grad v_i(x_k))'
p18302
aS'  }'
p18303
aS'  template <int dim>'
p18304
aS'  void'
p18305
aS'  RHSIntegrator<dim>::face(MeshWorker::DoFInfo<dim> &,'
p18306
aS'                           MeshWorker::DoFInfo<dim> &,'
p18307
aS'                           typename MeshWorker::IntegrationInfo<dim> &,'
p18308
aS'                           typename MeshWorker::IntegrationInfo<dim> &) const'
p18309
aS'  {}'
p18310
aS'  template <int dim>'
p18311
aS'  class Estimator : public MeshWorker::LocalIntegrator<dim>'
p18312
aS'  {'
p18313
aS'  public:'
p18314
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18315
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18316
aS'    void'
p18317
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18318
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18319
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18320
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18321
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p18322
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p18323
aS'  };'
p18324
aS'  template <int dim>'
p18325
aS'  void'
p18326
aS'  Estimator<dim>::cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18327
aS'                       typename MeshWorker::IntegrationInfo<dim> &info) const'
p18328
aS'  {'
p18329
aS'    const FEValuesBase<dim> &fe = info.fe_values();'
p18330
aS'    const std::vector<Tensor<2, dim>> &DDuh = info.hessians[0][0];'
p18331
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18332
aS'      {'
p18333
aS'        const double t = dinfo.cell->diameter() * trace(DDuh[k]);'
p18334
aS'        dinfo.value(0) += t * t * fe.JxW(k);'
p18335
aS'      }'
p18336
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p18337
aS'  }'
p18338
aS'  template <int dim>'
p18339
aS'  void Estimator<dim>::boundary('
p18340
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p18341
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p18342
aS'  {'
p18343
aS'    const FEValuesBase<dim> &fe = info.fe_values();'
p18344
aS'    std::vector<double> boundary_values(fe.n_quadrature_points);'
p18345
aS'    exact_solution.value_list(fe.get_quadrature_points(), boundary_values);'
p18346
aS'    const std::vector<double> &uh = info.values[0][0];'
p18347
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p18348
aS'    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() /'
p18349
aS'                           dinfo.cell->measure();'
p18350
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18351
aS'      {'
p18352
aS'        const double diff = boundary_values[k] - uh[k];'
p18353
aS'        dinfo.value(0) += penalty * diff * diff * fe.JxW(k);'
p18354
aS'      }'
p18355
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p18356
aS'  }'
p18357
aS'  template <int dim>'
p18358
aS'  void'
p18359
aS'  Estimator<dim>::face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18360
aS'                       MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18361
aS'                       typename MeshWorker::IntegrationInfo<dim> &info1,'
p18362
aS'                       typename MeshWorker::IntegrationInfo<dim> &info2) const'
p18363
aS'  {'
p18364
aS'    const FEValuesBase<dim> &          fe   = info1.fe_values();'
p18365
aS'    const std::vector<double> &        uh1  = info1.values[0][0];'
p18366
aS'    const std::vector<double> &        uh2  = info2.values[0][0];'
p18367
aS'    const std::vector<Tensor<1, dim>> &Duh1 = info1.gradients[0][0];'
p18368
aS'    const std::vector<Tensor<1, dim>> &Duh2 = info2.gradients[0][0];'
p18369
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p18370
aS'    const double       penalty1 ='
p18371
aS'      degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();'
p18372
aS'    const double penalty2 ='
p18373
aS'      degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();'
p18374
aS'    const double penalty = penalty1 + penalty2;'
p18375
aS'    const double h       = dinfo1.face->measure();'
p18376
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18377
aS'      {'
p18378
aS'        const double diff1 = uh1[k] - uh2[k];'
p18379
aS'        const double diff2 ='
p18380
aS'          fe.normal_vector(k) * Duh1[k] - fe.normal_vector(k) * Duh2[k];'
p18381
aS'        dinfo1.value(0) +='
p18382
aS'      }'
p18383
aS'    dinfo1.value(0) = std::sqrt(dinfo1.value(0));'
p18384
aS'    dinfo2.value(0) = dinfo1.value(0);'
p18385
aS'  }'
p18386
aS'  template <int dim>'
p18387
aS'  class ErrorIntegrator : public MeshWorker::LocalIntegrator<dim>'
p18388
aS'  {'
p18389
aS'  public:'
p18390
aS'    void cell(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18391
aS'              typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18392
aS'    void'
p18393
aS'         boundary(MeshWorker::DoFInfo<dim> &                 dinfo,'
p18394
aS'                  typename MeshWorker::IntegrationInfo<dim> &info) const override;'
p18395
aS'    void face(MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18396
aS'              MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18397
aS'              typename MeshWorker::IntegrationInfo<dim> &info1,'
p18398
aS'              typename MeshWorker::IntegrationInfo<dim> &info2) const override;'
p18399
aS'  };'
p18400
aS'  template <int dim>'
p18401
aS'  void ErrorIntegrator<dim>::cell('
p18402
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p18403
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p18404
aS'  {'
p18405
aS'    const FEValuesBase<dim> &   fe = info.fe_values();'
p18406
aS'    std::vector<Tensor<1, dim>> exact_gradients(fe.n_quadrature_points);'
p18407
aS'    std::vector<double>         exact_values(fe.n_quadrature_points);'
p18408
aS'    exact_solution.gradient_list(fe.get_quadrature_points(), exact_gradients);'
p18409
aS'    exact_solution.value_list(fe.get_quadrature_points(), exact_values);'
p18410
aS'    const std::vector<Tensor<1, dim>> &Duh = info.gradients[0][0];'
p18411
aS'    const std::vector<double> &        uh  = info.values[0][0];'
p18412
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18413
aS'      {'
p18414
aS'        double sum = 0;'
p18415
aS'        for (unsigned int d = 0; d < dim; ++d)'
p18416
aS'          {'
p18417
aS'            const double diff = exact_gradients[k][d] - Duh[k][d];'
p18418
aS'            sum += diff * diff;'
p18419
aS'          }'
p18420
aS'        const double diff = exact_values[k] - uh[k];'
p18421
aS'        dinfo.value(0) += sum * fe.JxW(k);'
p18422
aS'        dinfo.value(1) += diff * diff * fe.JxW(k);'
p18423
aS'      }'
p18424
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p18425
aS'    dinfo.value(1) = std::sqrt(dinfo.value(1));'
p18426
aS'  }'
p18427
aS'  template <int dim>'
p18428
aS'  void ErrorIntegrator<dim>::boundary('
p18429
aS'    MeshWorker::DoFInfo<dim> &                 dinfo,'
p18430
aS'    typename MeshWorker::IntegrationInfo<dim> &info) const'
p18431
aS'  {'
p18432
aS'    const FEValuesBase<dim> &fe = info.fe_values();'
p18433
aS'    std::vector<double> exact_values(fe.n_quadrature_points);'
p18434
aS'    exact_solution.value_list(fe.get_quadrature_points(), exact_values);'
p18435
aS'    const std::vector<double> &uh = info.values[0][0];'
p18436
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p18437
aS'    const double penalty = 2. * degree * (degree + 1) * dinfo.face->measure() /'
p18438
aS'                           dinfo.cell->measure();'
p18439
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18440
aS'      {'
p18441
aS'        const double diff = exact_values[k] - uh[k];'
p18442
aS'        dinfo.value(0) += penalty * diff * diff * fe.JxW(k);'
p18443
aS'      }'
p18444
aS'    dinfo.value(0) = std::sqrt(dinfo.value(0));'
p18445
aS'  }'
p18446
aS'  template <int dim>'
p18447
aS'  void ErrorIntegrator<dim>::face('
p18448
aS'    MeshWorker::DoFInfo<dim> &                 dinfo1,'
p18449
aS'    MeshWorker::DoFInfo<dim> &                 dinfo2,'
p18450
aS'    typename MeshWorker::IntegrationInfo<dim> &info1,'
p18451
aS'    typename MeshWorker::IntegrationInfo<dim> &info2) const'
p18452
aS'  {'
p18453
aS'    const FEValuesBase<dim> &  fe  = info1.fe_values();'
p18454
aS'    const std::vector<double> &uh1 = info1.values[0][0];'
p18455
aS'    const std::vector<double> &uh2 = info2.values[0][0];'
p18456
aS'    const unsigned int degree = fe.get_fe().tensor_degree();'
p18457
aS'    const double       penalty1 ='
p18458
aS'      degree * (degree + 1) * dinfo1.face->measure() / dinfo1.cell->measure();'
p18459
aS'    const double penalty2 ='
p18460
aS'      degree * (degree + 1) * dinfo2.face->measure() / dinfo2.cell->measure();'
p18461
aS'    const double penalty = penalty1 + penalty2;'
p18462
aS'    for (unsigned k = 0; k < fe.n_quadrature_points; ++k)'
p18463
aS'      {'
p18464
aS'        const double diff = uh1[k] - uh2[k];'
p18465
aS'        dinfo1.value(0) += (penalty * diff * diff) * fe.JxW(k);'
p18466
aS'      }'
p18467
aS'    dinfo1.value(0) = std::sqrt(dinfo1.value(0));'
p18468
aS'    dinfo2.value(0) = dinfo1.value(0);'
p18469
aS'  }'
p18470
aS'  template <int dim>'
p18471
aS'  class InteriorPenaltyProblem'
p18472
aS'  {'
p18473
aS'  public:'
p18474
aS'    using CellInfo = MeshWorker::IntegrationInfo<dim>;'
p18475
aS'    InteriorPenaltyProblem(const FiniteElement<dim> &fe);'
p18476
aS'    void run(unsigned int n_steps);'
p18477
aS'  private:'
p18478
aS'    void   setup_system();'
p18479
aS'    void   assemble_matrix();'
p18480
aS'    void   assemble_mg_matrix();'
p18481
aS'    void   assemble_right_hand_side();'
p18482
aS'    void   error();'
p18483
aS'    double estimate();'
p18484
aS'    void   solve();'
p18485
aS'    void   output_results(const unsigned int cycle) const;'
p18486
aS'    Triangulation<dim>        triangulation;'
p18487
aS'    const MappingQ1<dim>      mapping;'
p18488
aS'    const FiniteElement<dim> &fe;'
p18489
aS'    DoFHandler<dim>           dof_handler;'
p18490
aS'    SparsityPattern      sparsity;'
p18491
aS'    SparseMatrix<double> matrix;'
p18492
aS'    Vector<double>       solution;'
p18493
aS'    Vector<double>       right_hand_side;'
p18494
aS'    BlockVector<double>  estimates;'
p18495
aS'    MGLevelObject<SparsityPattern>      mg_sparsity;'
p18496
aS'    MGLevelObject<SparseMatrix<double>> mg_matrix;'
p18497
aS'    MGLevelObject<SparsityPattern> mg_sparsity_dg_interface;'
p18498
aS'    MGLevelObject<SparseMatrix<double>> mg_matrix_dg_down;'
p18499
aS'    MGLevelObject<SparseMatrix<double>> mg_matrix_dg_up;'
p18500
aS'  };'
p18501
aS'  template <int dim>'
p18502
aS'  InteriorPenaltyProblem<dim>::InteriorPenaltyProblem('
p18503
aS'    const FiniteElement<dim> &fe)'
p18504
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p18505
aS'    , mapping()'
p18506
aS'    , fe(fe)'
p18507
aS'    , dof_handler(triangulation)'
p18508
aS'    , estimates(1)'
p18509
aS'  {'
p18510
aS'    GridGenerator::hyper_cube_slit(triangulation, -1, 1);'
p18511
aS'  }'
p18512
aS'  template <int dim>'
p18513
aS'  void InteriorPenaltyProblem<dim>::setup_system()'
p18514
aS'  {'
p18515
aS'    dof_handler.distribute_dofs(fe);'
p18516
aS'    dof_handler.distribute_mg_dofs();'
p18517
aS'    unsigned int n_dofs = dof_handler.n_dofs();'
p18518
aS'    solution.reinit(n_dofs);'
p18519
aS'    right_hand_side.reinit(n_dofs);'
p18520
aS'    DynamicSparsityPattern dsp(n_dofs);'
p18521
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p18522
aS'    sparsity.copy_from(dsp);'
p18523
aS'    matrix.reinit(sparsity);'
p18524
aS'    const unsigned int n_levels = triangulation.n_levels();'
p18525
aS'    mg_matrix.resize(0, n_levels - 1);'
p18526
aS'    mg_matrix.clear_elements();'
p18527
aS'    mg_matrix_dg_up.resize(0, n_levels - 1);'
p18528
aS'    mg_matrix_dg_up.clear_elements();'
p18529
aS'    mg_matrix_dg_down.resize(0, n_levels - 1);'
p18530
aS'    mg_matrix_dg_down.clear_elements();'
p18531
aS'    mg_sparsity.resize(0, n_levels - 1);'
p18532
aS'    mg_sparsity_dg_interface.resize(0, n_levels - 1);'
p18533
aS'    for (unsigned int level = mg_sparsity.min_level();'
p18534
aS'         level <= mg_sparsity.max_level();'
p18535
aS'         ++level)'
p18536
aS'      {'
p18537
aS'        DynamicSparsityPattern dsp(dof_handler.n_dofs(level));'
p18538
aS'        MGTools::make_flux_sparsity_pattern(dof_handler, dsp, level);'
p18539
aS'        mg_sparsity[level].copy_from(dsp);'
p18540
aS'        mg_matrix[level].reinit(mg_sparsity[level]);'
p18541
aS'        if (level > 0)'
p18542
aS'          {'
p18543
aS'            DynamicSparsityPattern dsp;'
p18544
aS'            dsp.reinit(dof_handler.n_dofs(level - 1),'
p18545
aS'                       dof_handler.n_dofs(level));'
p18546
aS'            MGTools::make_flux_sparsity_pattern_edge(dof_handler, dsp, level);'
p18547
aS'            mg_sparsity_dg_interface[level].copy_from(dsp);'
p18548
aS'            mg_matrix_dg_up[level].reinit(mg_sparsity_dg_interface[level]);'
p18549
aS'            mg_matrix_dg_down[level].reinit(mg_sparsity_dg_interface[level]);'
p18550
aS'          }'
p18551
aS'      }'
p18552
aS'  }'
p18553
aS'  template <int dim>'
p18554
aS'  void InteriorPenaltyProblem<dim>::assemble_matrix()'
p18555
aS'  {'
p18556
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p18557
aS'    UpdateFlags update_flags = update_values | update_gradients;'
p18558
aS'    info_box.add_update_flags_all(update_flags);'
p18559
aS'    info_box.initialize(fe, mapping);'
p18560
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p18561
aS'    MeshWorker::Assembler::MatrixSimple<SparseMatrix<double>> assembler;'
p18562
aS'    assembler.initialize(matrix);'
p18563
aS'    MatrixIntegrator<dim> integrator;'
p18564
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p18565
aS'                                           dof_handler.end(),'
p18566
aS'                                           dof_info,'
p18567
aS'                                           info_box,'
p18568
aS'                                           integrator,'
p18569
aS'                                           assembler);'
p18570
aS'  }'
p18571
aS'  template <int dim>'
p18572
aS'  void InteriorPenaltyProblem<dim>::assemble_mg_matrix()'
p18573
aS'  {'
p18574
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p18575
aS'    UpdateFlags update_flags = update_values | update_gradients;'
p18576
aS'    info_box.add_update_flags_all(update_flags);'
p18577
aS'    info_box.initialize(fe, mapping);'
p18578
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p18579
aS'    MeshWorker::Assembler::MGMatrixSimple<SparseMatrix<double>> assembler;'
p18580
aS'    assembler.initialize(mg_matrix);'
p18581
aS'    assembler.initialize_fluxes(mg_matrix_dg_up, mg_matrix_dg_down);'
p18582
aS'    MatrixIntegrator<dim> integrator;'
p18583
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_mg(),'
p18584
aS'                                           dof_handler.end_mg(),'
p18585
aS'                                           dof_info,'
p18586
aS'                                           info_box,'
p18587
aS'                                           integrator,'
p18588
aS'                                           assembler);'
p18589
aS'  }'
p18590
aS'  template <int dim>'
p18591
aS'  void InteriorPenaltyProblem<dim>::assemble_right_hand_side()'
p18592
aS'  {'
p18593
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p18594
aS'    UpdateFlags                         update_flags ='
p18595
aS'      update_quadrature_points | update_values | update_gradients;'
p18596
aS'    info_box.add_update_flags_all(update_flags);'
p18597
aS'    info_box.initialize(fe, mapping);'
p18598
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p18599
aS'    MeshWorker::Assembler::ResidualSimple<Vector<double>> assembler;'
p18600
aS'    AnyData                                               data;'
p18601
aS'    data.add<Vector<double> *>(&right_hand_side, "RHS");'
p18602
aS'    assembler.initialize(data);'
p18603
aS'    RHSIntegrator<dim> integrator;'
p18604
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p18605
aS'                                           dof_handler.end(),'
p18606
aS'                                           dof_info,'
p18607
aS'                                           info_box,'
p18608
aS'                                           integrator,'
p18609
aS'                                           assembler);'
p18610
aS'    right_hand_side *= -1.;'
p18611
aS'  }'
p18612
aS'  template <int dim>'
p18613
aS'  void InteriorPenaltyProblem<dim>::solve()'
p18614
aS'  {'
p18615
aS'    SolverControl            control(1000, 1.e-12);'
p18616
aS'    SolverCG<Vector<double>> solver(control);'
p18617
aS'    MGTransferPrebuilt<Vector<double>> mg_transfer;'
p18618
aS'    mg_transfer.build(dof_handler);'
p18619
aS'    FullMatrix<double> coarse_matrix;'
p18620
aS'    coarse_matrix.copy_from(mg_matrix[0]);'
p18621
aS'    MGCoarseGridHouseholder<double, Vector<double>> mg_coarse;'
p18622
aS'    mg_coarse.initialize(coarse_matrix);'
p18623
aS'    GrowingVectorMemory<Vector<double>> mem;'
p18624
aS'    using RELAXATION = PreconditionSOR<SparseMatrix<double>>;'
p18625
aS'    mg::SmootherRelaxation<RELAXATION, Vector<double>> mg_smoother;'
p18626
aS'    RELAXATION::AdditionalData                         smoother_data(1.);'
p18627
aS'    mg_smoother.initialize(mg_matrix, smoother_data);'
p18628
aS'    mg_smoother.set_steps(2);'
p18629
aS'    mg_smoother.set_symmetric(true);'
p18630
aS'    mg_smoother.set_variable(false);'
p18631
aS'    mg::Matrix<Vector<double>> mgmatrix(mg_matrix);'
p18632
aS'    mg::Matrix<Vector<double>> mgdown(mg_matrix_dg_down);'
p18633
aS'    mg::Matrix<Vector<double>> mgup(mg_matrix_dg_up);'
p18634
aS'    Multigrid<Vector<double>> mg('
p18635
aS'      mgmatrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p18636
aS'    mg.set_edge_flux_matrices(mgdown, mgup);'
p18637
aS'    PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p18638
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p18639
aS'    solver.solve(matrix, solution, right_hand_side, preconditioner);'
p18640
aS'  }'
p18641
aS'  template <int dim>'
p18642
aS'  double InteriorPenaltyProblem<dim>::estimate()'
p18643
aS'  {'
p18644
aS'    std::vector<unsigned int> old_user_indices;'
p18645
aS'    triangulation.save_user_indices(old_user_indices);'
p18646
aS'    estimates.block(0).reinit(triangulation.n_active_cells());'
p18647
aS'    unsigned int i = 0;'
p18648
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p18649
aS'      cell->set_user_index(i++);'
p18650
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p18651
aS'    const unsigned int                  n_gauss_points ='
p18652
aS'      dof_handler.get_fe().tensor_degree() + 1;'
p18653
aS'    info_box.initialize_gauss_quadrature(n_gauss_points,'
p18654
aS'                                         n_gauss_points + 1,'
p18655
aS'                                         n_gauss_points);'
p18656
aS'    AnyData solution_data;'
p18657
aS'    solution_data.add<const Vector<double> *>(&solution, "solution");'
p18658
aS'    info_box.cell_selector.add("solution", false, false, true);'
p18659
aS'    info_box.boundary_selector.add("solution", true, true, false);'
p18660
aS'    info_box.face_selector.add("solution", true, true, false);'
p18661
aS'    info_box.add_update_flags_boundary(update_quadrature_points);'
p18662
aS'    info_box.initialize(fe, mapping, solution_data, solution);'
p18663
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p18664
aS'    MeshWorker::Assembler::CellsAndFaces<double> assembler;'
p18665
aS'    AnyData                                      out_data;'
p18666
aS'    out_data.add<BlockVector<double> *>(&estimates, "cells");'
p18667
aS'    assembler.initialize(out_data, false);'
p18668
aS'    Estimator<dim> integrator;'
p18669
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p18670
aS'                                           dof_handler.end(),'
p18671
aS'                                           dof_info,'
p18672
aS'                                           info_box,'
p18673
aS'                                           integrator,'
p18674
aS'                                           assembler);'
p18675
aS'    triangulation.load_user_indices(old_user_indices);'
p18676
aS'    return estimates.block(0).l2_norm();'
p18677
aS'  }'
p18678
aS'  template <int dim>'
p18679
aS'  void InteriorPenaltyProblem<dim>::error()'
p18680
aS'  {'
p18681
aS'    BlockVector<double> errors(2);'
p18682
aS'    errors.block(0).reinit(triangulation.n_active_cells());'
p18683
aS'    errors.block(1).reinit(triangulation.n_active_cells());'
p18684
aS'    std::vector<unsigned int> old_user_indices;'
p18685
aS'    triangulation.save_user_indices(old_user_indices);'
p18686
aS'    unsigned int i = 0;'
p18687
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p18688
aS'      cell->set_user_index(i++);'
p18689
aS'    MeshWorker::IntegrationInfoBox<dim> info_box;'
p18690
aS'    const unsigned int                  n_gauss_points ='
p18691
aS'      dof_handler.get_fe().tensor_degree() + 1;'
p18692
aS'    info_box.initialize_gauss_quadrature(n_gauss_points,'
p18693
aS'                                         n_gauss_points + 1,'
p18694
aS'                                         n_gauss_points);'
p18695
aS'    AnyData solution_data;'
p18696
aS'    solution_data.add<Vector<double> *>(&solution, "solution");'
p18697
aS'    info_box.cell_selector.add("solution", true, true, false);'
p18698
aS'    info_box.boundary_selector.add("solution", true, false, false);'
p18699
aS'    info_box.face_selector.add("solution", true, false, false);'
p18700
aS'    info_box.add_update_flags_cell(update_quadrature_points);'
p18701
aS'    info_box.add_update_flags_boundary(update_quadrature_points);'
p18702
aS'    info_box.initialize(fe, mapping, solution_data, solution);'
p18703
aS'    MeshWorker::DoFInfo<dim> dof_info(dof_handler);'
p18704
aS'    MeshWorker::Assembler::CellsAndFaces<double> assembler;'
p18705
aS'    AnyData                                      out_data;'
p18706
aS'    out_data.add<BlockVector<double> *>(&errors, "cells");'
p18707
aS'    assembler.initialize(out_data, false);'
p18708
aS'    ErrorIntegrator<dim> integrator;'
p18709
aS'    MeshWorker::integration_loop<dim, dim>(dof_handler.begin_active(),'
p18710
aS'                                           dof_handler.end(),'
p18711
aS'                                           dof_info,'
p18712
aS'                                           info_box,'
p18713
aS'                                           integrator,'
p18714
aS'                                           assembler);'
p18715
aS'    triangulation.load_user_indices(old_user_indices);'
p18716
aS'    deallog << "energy-error: " << errors.block(0).l2_norm() << std::endl;'
p18717
aS'    deallog << "L2-error:     " << errors.block(1).l2_norm() << std::endl;'
p18718
aS'  }'
p18719
aS'  template <int dim>'
p18720
aS'  void'
p18721
aS'  InteriorPenaltyProblem<dim>::output_results(const unsigned int cycle) const'
p18722
aS'  {'
p18723
aS'    const std::string filename ='
p18724
aS'      "sol-" + Utilities::int_to_string(cycle, 2) + ".gnuplot";'
p18725
aS'    deallog << "Writing solution to <" << filename << ">..." << std::endl'
p18726
aS'            << std::endl;'
p18727
aS'    std::ofstream gnuplot_output(filename);'
p18728
aS'    DataOut<dim> data_out;'
p18729
aS'    data_out.attach_dof_handler(dof_handler);'
p18730
aS'    data_out.add_data_vector(solution, "u");'
p18731
aS'    data_out.add_data_vector(estimates.block(0), "est");'
p18732
aS'    data_out.build_patches();'
p18733
aS'    data_out.write_gnuplot(gnuplot_output);'
p18734
aS'  }'
p18735
aS'  template <int dim>'
p18736
aS'  void InteriorPenaltyProblem<dim>::run(unsigned int n_steps)'
p18737
aS'  {'
p18738
aS'    deallog << "Element: " << fe.get_name() << std::endl;'
p18739
aS'    for (unsigned int s = 0; s < n_steps; ++s)'
p18740
aS'      {'
p18741
aS'        deallog << "Step " << s << std::endl;'
p18742
aS'        if (estimates.block(0).size() == 0)'
p18743
aS'          triangulation.refine_global(1);'
p18744
aS'        else'
p18745
aS'          {'
p18746
aS'            GridRefinement::refine_and_coarsen_fixed_fraction('
p18747
aS'              triangulation, estimates.block(0), 0.5, 0.0);'
p18748
aS'            triangulation.execute_coarsening_and_refinement();'
p18749
aS'          }'
p18750
aS'        deallog << "Triangulation " << triangulation.n_active_cells()'
p18751
aS'                << " cells, " << triangulation.n_levels() << " levels"'
p18752
aS'                << std::endl;'
p18753
aS'        setup_system();'
p18754
aS'        deallog << "DoFHandler " << dof_handler.n_dofs() << " dofs, level dofs";'
p18755
aS'        for (unsigned int l = 0; l < triangulation.n_levels(); ++l)'
p18756
aS"          deallog << ' ' << dof_handler.n_dofs(l);"
p18757
aS'        deallog << std::endl;'
p18758
aS'        deallog << "Assemble matrix" << std::endl;'
p18759
aS'        assemble_matrix();'
p18760
aS'        deallog << "Assemble multilevel matrix" << std::endl;'
p18761
aS'        assemble_mg_matrix();'
p18762
aS'        deallog << "Assemble right hand side" << std::endl;'
p18763
aS'        assemble_right_hand_side();'
p18764
aS'        deallog << "Solve" << std::endl;'
p18765
aS'        solve();'
p18766
aS'        error();'
p18767
aS'        deallog << "Estimate " << estimate() << std::endl;'
p18768
aS'        output_results(s);'
p18769
aS'      }'
p18770
aS'  }'
p18771
aS'} // namespace Step39'
p18772
aS'int main()'
p18773
ag9
aS'  try'
p18774
aS'    {'
p18775
aS'      using namespace dealii;'
p18776
aS'      using namespace Step39;'
p18777
aS'      deallog.depth_console(2);'
p18778
aS'      std::ofstream logfile("deallog");'
p18779
aS'      deallog.attach(logfile);'
p18780
aS'      FE_DGQ<2>                 fe1(3);'
p18781
aS'      InteriorPenaltyProblem<2> test1(fe1);'
p18782
aS'      test1.run(12);'
p18783
aS'    }'
p18784
aS'  catch (std::exception &exc)'
p18785
aS'    {'
p18786
aS'      std::cerr << std::endl'
p18787
aS'                << std::endl'
p18788
aS'                << "----------------------------------------------------"'
p18789
aS'                << std::endl;'
p18790
aS'      std::cerr << "Exception on processing: " << std::endl'
p18791
aS'                << exc.what() << std::endl'
p18792
aS'                << "Aborting!" << std::endl'
p18793
aS'                << "----------------------------------------------------"'
p18794
aS'                << std::endl;'
p18795
aS'      return 1;'
p18796
aS'    }'
p18797
aS'  catch (...)'
p18798
aS'    {'
p18799
aS'      std::cerr << std::endl'
p18800
aS'                << std::endl'
p18801
aS'                << "----------------------------------------------------"'
p18802
aS'                << std::endl;'
p18803
aS'      std::cerr << "Unknown exception!" << std::endl'
p18804
aS'                << "Aborting!" << std::endl'
p18805
aS'                << "----------------------------------------------------"'
p18806
aS'                << std::endl;'
p18807
aS'      return 1;'
p18808
aS'    }'
p18809
aS'  return 0;'
p18810
ag17
aS'#include <deal.II/grid/tria.h>'
p18811
aS'#include <deal.II/dofs/dof_handler.h>'
p18812
aS'#include <deal.II/grid/grid_generator.h>'
p18813
aS'#include <deal.II/fe/fe_q.h>'
p18814
aS'#include <deal.II/dofs/dof_tools.h>'
p18815
aS'#include <deal.II/fe/fe_values.h>'
p18816
aS'#include <deal.II/base/quadrature_lib.h>'
p18817
aS'#include <deal.II/base/function.h>'
p18818
aS'#include <deal.II/numerics/vector_tools.h>'
p18819
aS'#include <deal.II/numerics/matrix_tools.h>'
p18820
aS'#include <deal.II/lac/vector.h>'
p18821
aS'#include <deal.II/lac/full_matrix.h>'
p18822
aS'#include <deal.II/lac/sparse_matrix.h>'
p18823
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p18824
aS'#include <deal.II/lac/solver_cg.h>'
p18825
aS'#include <deal.II/lac/precondition.h>'
p18826
aS'#include <deal.II/numerics/data_out.h>'
p18827
aS'#include <fstream>'
p18828
aS'#include <iostream>'
p18829
aS'#include <deal.II/base/logstream.h>'
p18830
aS'using namespace dealii;'
p18831
aS'template <int dim>'
p18832
aS'class Step4'
p18833
ag9
aS'public:'
p18834
aS'  Step4();'
p18835
aS'  void run();'
p18836
aS'private:'
p18837
aS'  void make_grid();'
p18838
aS'  void setup_system();'
p18839
aS'  void assemble_system();'
p18840
aS'  void solve();'
p18841
aS'  void output_results() const;'
p18842
aS'  Triangulation<dim> triangulation;'
p18843
aS'  FE_Q<dim>          fe;'
p18844
aS'  DoFHandler<dim>    dof_handler;'
p18845
aS'  SparsityPattern      sparsity_pattern;'
p18846
aS'  SparseMatrix<double> system_matrix;'
p18847
aS'  Vector<double> solution;'
p18848
aS'  Vector<double> system_rhs;'
p18849
aS'};'
p18850
aS'template <int dim>'
p18851
aS'class RightHandSide : public Function<dim>'
p18852
ag9
aS'public:'
p18853
aS'  virtual double value(const Point<dim> & p,'
p18854
aS'                       const unsigned int component = 0) const override;'
p18855
aS'};'
p18856
aS'template <int dim>'
p18857
aS'class BoundaryValues : public Function<dim>'
p18858
ag9
aS'public:'
p18859
aS'  virtual double value(const Point<dim> & p,'
p18860
aS'                       const unsigned int component = 0) const override;'
p18861
aS'};'
p18862
aS'template <int dim>'
p18863
aS'double RightHandSide<dim>::value(const Point<dim> &p,'
p18864
aS'                                 const unsigned int /*component*/) const'
p18865
ag9
aS'  double return_value = 0.0;'
p18866
aS'  for (unsigned int i = 0; i < dim; ++i)'
p18867
aS'    return_value += 4.0 * std::pow(p(i), 4.0);'
p18868
aS'  return return_value;'
p18869
ag17
aS'template <int dim>'
p18870
aS'double BoundaryValues<dim>::value(const Point<dim> &p,'
p18871
aS'                                  const unsigned int /*component*/) const'
p18872
ag9
aS'  return p.square();'
p18873
ag17
aS'template <int dim>'
p18874
aS'Step4<dim>::Step4()'
p18875
aS'  : fe(1)'
p18876
aS'  , dof_handler(triangulation)'
p18877
aS'{}'
p18878
aS'template <int dim>'
p18879
aS'void Step4<dim>::make_grid()'
p18880
ag9
aS'  GridGenerator::hyper_cube(triangulation, -1, 1);'
p18881
aS'  triangulation.refine_global(4);'
p18882
aS'  std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p18883
aS'            << std::endl'
p18884
aS'            << "   Total number of cells: " << triangulation.n_cells()'
p18885
aS'            << std::endl;'
p18886
ag17
aS'template <int dim>'
p18887
aS'void Step4<dim>::setup_system()'
p18888
ag9
aS'  dof_handler.distribute_dofs(fe);'
p18889
aS'  std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p18890
aS'            << std::endl;'
p18891
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p18892
aS'  DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p18893
aS'  sparsity_pattern.copy_from(dsp);'
p18894
aS'  system_matrix.reinit(sparsity_pattern);'
p18895
aS'  solution.reinit(dof_handler.n_dofs());'
p18896
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p18897
ag17
aS'template <int dim>'
p18898
aS'void Step4<dim>::assemble_system()'
p18899
ag9
aS'  QGauss<dim> quadrature_formula(fe.degree + 1);'
p18900
aS'  RightHandSide<dim> right_hand_side;'
p18901
aS'  FEValues<dim> fe_values(fe,'
p18902
aS'                          quadrature_formula,'
p18903
aS'                          update_values | update_gradients |'
p18904
aS'                            update_quadrature_points | update_JxW_values);'
p18905
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p18906
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p18907
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p18908
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p18909
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p18910
aS'    {'
p18911
aS'      fe_values.reinit(cell);'
p18912
aS'      cell_matrix = 0;'
p18913
aS'      cell_rhs    = 0;'
p18914
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p18915
aS'        for (const unsigned int i : fe_values.dof_indices())'
p18916
aS'          {'
p18917
aS'            for (const unsigned int j : fe_values.dof_indices())'
p18918
aS'              cell_matrix(i, j) +='
p18919
aS'                 fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p18920
aS'                 fe_values.JxW(q_index));           // dx'
p18921
aS'            const auto &x_q = fe_values.quadrature_point(q_index);'
p18922
aS'            cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p18923
aS'                            right_hand_side.value(x_q) *        // f(x_q)'
p18924
aS'                            fe_values.JxW(q_index));            // dx'
p18925
aS'          }'
p18926
aS'      cell->get_dof_indices(local_dof_indices);'
p18927
aS'      for (const unsigned int i : fe_values.dof_indices())'
p18928
aS'        {'
p18929
aS'          for (const unsigned int j : fe_values.dof_indices())'
p18930
aS'            system_matrix.add(local_dof_indices[i],'
p18931
aS'                              local_dof_indices[j],'
p18932
aS'                              cell_matrix(i, j));'
p18933
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p18934
aS'        }'
p18935
aS'    }'
p18936
aS'  std::map<types::global_dof_index, double> boundary_values;'
p18937
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p18938
aS'                                           0,'
p18939
aS'                                           BoundaryValues<dim>(),'
p18940
aS'                                           boundary_values);'
p18941
aS'  MatrixTools::apply_boundary_values(boundary_values,'
p18942
aS'                                     system_matrix,'
p18943
aS'                                     solution,'
p18944
aS'                                     system_rhs);'
p18945
ag17
aS'template <int dim>'
p18946
aS'void Step4<dim>::solve()'
p18947
ag9
aS'  SolverControl            solver_control(1000, 1e-12);'
p18948
aS'  SolverCG<Vector<double>> solver(solver_control);'
p18949
aS'  solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p18950
aS'  std::cout << "   " << solver_control.last_step()'
p18951
aS'            << " CG iterations needed to obtain convergence." << std::endl;'
p18952
ag17
aS'template <int dim>'
p18953
aS'void Step4<dim>::output_results() const'
p18954
ag9
aS'  DataOut<dim> data_out;'
p18955
aS'  data_out.attach_dof_handler(dof_handler);'
p18956
aS'  data_out.add_data_vector(solution, "solution");'
p18957
aS'  data_out.build_patches();'
p18958
aS'  std::ofstream output(dim == 2 ? "solution-2d.vtk" : "solution-3d.vtk");'
p18959
aS'  data_out.write_vtk(output);'
p18960
ag17
aS'template <int dim>'
p18961
aS'void Step4<dim>::run()'
p18962
ag9
aS'  std::cout << "Solving problem in " << dim << " space dimensions."'
p18963
aS'            << std::endl;'
p18964
aS'  make_grid();'
p18965
aS'  setup_system();'
p18966
aS'  assemble_system();'
p18967
aS'  solve();'
p18968
aS'  output_results();'
p18969
ag17
aS'int main()'
p18970
ag9
aS'  {'
p18971
aS'    Step4<2> laplace_problem_2d;'
p18972
aS'    laplace_problem_2d.run();'
p18973
aS'  }'
p18974
aS'  {'
p18975
aS'    Step4<3> laplace_problem_3d;'
p18976
aS'    laplace_problem_3d.run();'
p18977
aS'  }'
p18978
aS'  return 0;'
p18979
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p18980
aS'#include <deal.II/base/function.h>'
p18981
aS'#include <deal.II/base/timer.h>'
p18982
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p18983
aS'namespace LA'
p18984
ag9
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p18985
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p18986
aS'  using namespace dealii::LinearAlgebraPETSc;'
p18987
aS'#  define USE_PETSC_LA'
p18988
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p18989
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p18990
aS'#else'
p18991
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p18992
aS'#endif'
p18993
aS'} // namespace LA'
p18994
aS'#include <deal.II/lac/vector.h>'
p18995
aS'#include <deal.II/lac/full_matrix.h>'
p18996
aS'#include <deal.II/lac/solver_cg.h>'
p18997
aS'#include <deal.II/lac/affine_constraints.h>'
p18998
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p18999
aS'#include <deal.II/grid/grid_generator.h>'
p19000
aS'#include <deal.II/dofs/dof_handler.h>'
p19001
aS'#include <deal.II/dofs/dof_tools.h>'
p19002
aS'#include <deal.II/fe/fe_values.h>'
p19003
aS'#include <deal.II/fe/fe_q.h>'
p19004
aS'#include <deal.II/numerics/vector_tools.h>'
p19005
aS'#include <deal.II/numerics/data_out.h>'
p19006
aS'#include <deal.II/numerics/error_estimator.h>'
p19007
aS'#include <deal.II/base/utilities.h>'
p19008
aS'#include <deal.II/base/conditional_ostream.h>'
p19009
aS'#include <deal.II/base/index_set.h>'
p19010
aS'#include <deal.II/lac/sparsity_tools.h>'
p19011
aS'#include <deal.II/distributed/tria.h>'
p19012
aS'#include <deal.II/distributed/grid_refinement.h>'
p19013
aS'#include <fstream>'
p19014
aS'#include <iostream>'
p19015
aS'namespace Step40'
p19016
ag9
aS'  using namespace dealii;'
p19017
aS'  template <int dim>'
p19018
aS'  class LaplaceProblem'
p19019
aS'  {'
p19020
aS'  public:'
p19021
aS'    LaplaceProblem();'
p19022
aS'    void run();'
p19023
aS'  private:'
p19024
aS'    void setup_system();'
p19025
aS'    void assemble_system();'
p19026
aS'    void solve();'
p19027
aS'    void refine_grid();'
p19028
aS'    void output_results(const unsigned int cycle) const;'
p19029
aS'    MPI_Comm mpi_communicator;'
p19030
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p19031
aS'    FE_Q<dim>       fe;'
p19032
aS'    DoFHandler<dim> dof_handler;'
p19033
aS'    IndexSet locally_owned_dofs;'
p19034
aS'    IndexSet locally_relevant_dofs;'
p19035
aS'    AffineConstraints<double> constraints;'
p19036
aS'    LA::MPI::SparseMatrix system_matrix;'
p19037
aS'    LA::MPI::Vector       locally_relevant_solution;'
p19038
aS'    LA::MPI::Vector       system_rhs;'
p19039
aS'    ConditionalOStream pcout;'
p19040
aS'    TimerOutput        computing_timer;'
p19041
aS'  };'
p19042
aS'  template <int dim>'
p19043
aS'  LaplaceProblem<dim>::LaplaceProblem()'
p19044
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p19045
aS'    , triangulation(mpi_communicator,'
p19046
aS'                    typename Triangulation<dim>::MeshSmoothing('
p19047
aS'                      Triangulation<dim>::smoothing_on_refinement |'
p19048
aS'                      Triangulation<dim>::smoothing_on_coarsening))'
p19049
aS'    , fe(2)'
p19050
aS'    , dof_handler(triangulation)'
p19051
aS'    , pcout(std::cout,'
p19052
aS'    , computing_timer(mpi_communicator,'
p19053
aS'                      pcout,'
p19054
aS'                      TimerOutput::summary,'
p19055
aS'                      TimerOutput::wall_times)'
p19056
aS'  {}'
p19057
aS'  template <int dim>'
p19058
aS'  void LaplaceProblem<dim>::setup_system()'
p19059
aS'  {'
p19060
aS'    TimerOutput::Scope t(computing_timer, "setup");'
p19061
aS'    dof_handler.distribute_dofs(fe);'
p19062
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p19063
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p19064
aS'    locally_relevant_solution.reinit(locally_owned_dofs,'
p19065
aS'                                     locally_relevant_dofs,'
p19066
aS'                                     mpi_communicator);'
p19067
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p19068
aS'    constraints.clear();'
p19069
aS'    constraints.reinit(locally_relevant_dofs);'
p19070
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p19071
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p19072
aS'                                             0,'
p19073
aS'                                             Functions::ZeroFunction<dim>(),'
p19074
aS'                                             constraints);'
p19075
aS'    constraints.close();'
p19076
aS'    DynamicSparsityPattern dsp(locally_relevant_dofs);'
p19077
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p19078
aS'    SparsityTools::distribute_sparsity_pattern(dsp,'
p19079
aS'                                               dof_handler.locally_owned_dofs(),'
p19080
aS'                                               mpi_communicator,'
p19081
aS'                                               locally_relevant_dofs);'
p19082
aS'    system_matrix.reinit(locally_owned_dofs,'
p19083
aS'                         locally_owned_dofs,'
p19084
aS'                         dsp,'
p19085
aS'                         mpi_communicator);'
p19086
aS'  }'
p19087
aS'  template <int dim>'
p19088
aS'  void LaplaceProblem<dim>::assemble_system()'
p19089
aS'  {'
p19090
aS'    TimerOutput::Scope t(computing_timer, "assembly");'
p19091
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p19092
aS'    FEValues<dim> fe_values(fe,'
p19093
aS'                            quadrature_formula,'
p19094
aS'                            update_values | update_gradients |'
p19095
aS'                              update_quadrature_points | update_JxW_values);'
p19096
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p19097
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p19098
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p19099
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p19100
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p19101
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p19102
aS'      if (cell->is_locally_owned())'
p19103
aS'        {'
p19104
aS'          cell_matrix = 0.;'
p19105
aS'          cell_rhs    = 0.;'
p19106
aS'          fe_values.reinit(cell);'
p19107
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p19108
aS'            {'
p19109
aS'              const double rhs_value ='
p19110
aS'                     0.5 +'
p19111
aS'                       0.25 * std::sin(4.0 * numbers::PI *'
p19112
aS'                                       fe_values.quadrature_point(q_point)[0]) ?'
p19113
aS'                   1. :'
p19114
aS'                   -1.);'
p19115
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p19116
aS'                {'
p19117
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p19118
aS'                    cell_matrix(i, j) += fe_values.shape_grad(i, q_point) *'
p19119
aS'                                         fe_values.shape_grad(j, q_point) *'
p19120
aS'                                         fe_values.JxW(q_point);'
p19121
aS'                  cell_rhs(i) += rhs_value *                         //'
p19122
aS'                                 fe_values.shape_value(i, q_point) * //'
p19123
aS'                                 fe_values.JxW(q_point);'
p19124
aS'                }'
p19125
aS'            }'
p19126
aS'          cell->get_dof_indices(local_dof_indices);'
p19127
aS'          constraints.distribute_local_to_global(cell_matrix,'
p19128
aS'                                                 cell_rhs,'
p19129
aS'                                                 local_dof_indices,'
p19130
aS'                                                 system_matrix,'
p19131
aS'                                                 system_rhs);'
p19132
aS'        }'
p19133
aS'    system_matrix.compress(VectorOperation::add);'
p19134
aS'    system_rhs.compress(VectorOperation::add);'
p19135
aS'  }'
p19136
aS'  template <int dim>'
p19137
aS'  void LaplaceProblem<dim>::solve()'
p19138
aS'  {'
p19139
aS'    TimerOutput::Scope t(computing_timer, "solve");'
p19140
aS'    LA::MPI::Vector    completely_distributed_solution(locally_owned_dofs,'
p19141
aS'                                                    mpi_communicator);'
p19142
aS'    SolverControl solver_control(dof_handler.n_dofs(), 1e-12);'
p19143
aS'#ifdef USE_PETSC_LA'
p19144
aS'    LA::SolverCG solver(solver_control, mpi_communicator);'
p19145
aS'#else'
p19146
aS'    LA::SolverCG solver(solver_control);'
p19147
aS'#endif'
p19148
aS'    LA::MPI::PreconditionAMG preconditioner;'
p19149
aS'    LA::MPI::PreconditionAMG::AdditionalData data;'
p19150
aS'#ifdef USE_PETSC_LA'
p19151
aS'    data.symmetric_operator = true;'
p19152
aS'#else'
p19153
aS'#endif'
p19154
aS'    preconditioner.initialize(system_matrix, data);'
p19155
aS'    solver.solve(system_matrix,'
p19156
aS'                 completely_distributed_solution,'
p19157
aS'                 system_rhs,'
p19158
aS'                 preconditioner);'
p19159
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p19160
aS'          << std::endl;'
p19161
aS'    constraints.distribute(completely_distributed_solution);'
p19162
aS'    locally_relevant_solution = completely_distributed_solution;'
p19163
aS'  }'
p19164
aS'  template <int dim>'
p19165
aS'  void LaplaceProblem<dim>::refine_grid()'
p19166
aS'  {'
p19167
aS'    TimerOutput::Scope t(computing_timer, "refine");'
p19168
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p19169
aS'    KellyErrorEstimator<dim>::estimate('
p19170
aS'      dof_handler,'
p19171
aS'      QGauss<dim - 1>(fe.degree + 1),'
p19172
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p19173
aS'      locally_relevant_solution,'
p19174
aS'      estimated_error_per_cell);'
p19175
aS'    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p19176
aS'      triangulation, estimated_error_per_cell, 0.3, 0.03);'
p19177
aS'    triangulation.execute_coarsening_and_refinement();'
p19178
aS'  }'
p19179
aS'  template <int dim>'
p19180
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle) const'
p19181
aS'  {'
p19182
aS'    DataOut<dim> data_out;'
p19183
aS'    data_out.attach_dof_handler(dof_handler);'
p19184
aS'    data_out.add_data_vector(locally_relevant_solution, "u");'
p19185
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p19186
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p19187
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p19188
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p19189
aS'    data_out.build_patches();'
p19190
aS'    data_out.write_vtu_with_pvtu_record('
p19191
aS'      "./", "solution", cycle, mpi_communicator, 2, 8);'
p19192
aS'  }'
p19193
aS'  template <int dim>'
p19194
aS'  void LaplaceProblem<dim>::run()'
p19195
aS'  {'
p19196
aS'    pcout << "Running with "'
p19197
aS'#ifdef USE_PETSC_LA'
p19198
aS'          << "PETSc"'
p19199
aS'#else'
p19200
aS'          << "Trilinos"'
p19201
aS'#endif'
p19202
aS'          << " on " << Utilities::MPI::n_mpi_processes(mpi_communicator)'
p19203
aS'          << " MPI rank(s)..." << std::endl;'
p19204
aS'    const unsigned int n_cycles = 8;'
p19205
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p19206
aS'      {'
p19207
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p19208
aS'        if (cycle == 0)'
p19209
aS'          {'
p19210
aS'            GridGenerator::hyper_cube(triangulation);'
p19211
aS'            triangulation.refine_global(5);'
p19212
aS'          }'
p19213
aS'        else'
p19214
aS'          refine_grid();'
p19215
aS'        setup_system();'
p19216
aS'        pcout << "   Number of active cells:       "'
p19217
aS'              << triangulation.n_global_active_cells() << std::endl'
p19218
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p19219
aS'              << std::endl;'
p19220
aS'        assemble_system();'
p19221
aS'        solve();'
p19222
aS'        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32)'
p19223
aS'          {'
p19224
aS'            TimerOutput::Scope t(computing_timer, "output");'
p19225
aS'            output_results(cycle);'
p19226
aS'          }'
p19227
aS'        computing_timer.print_summary();'
p19228
aS'        computing_timer.reset();'
p19229
aS'        pcout << std::endl;'
p19230
aS'      }'
p19231
aS'  }'
p19232
aS'} // namespace Step40'
p19233
aS'int main(int argc, char *argv[])'
p19234
ag9
aS'  try'
p19235
aS'    {'
p19236
aS'      using namespace dealii;'
p19237
aS'      using namespace Step40;'
p19238
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p19239
aS'      LaplaceProblem<2> laplace_problem_2d;'
p19240
aS'      laplace_problem_2d.run();'
p19241
aS'    }'
p19242
aS'  catch (std::exception &exc)'
p19243
aS'    {'
p19244
aS'      std::cerr << std::endl'
p19245
aS'                << std::endl'
p19246
aS'                << "----------------------------------------------------"'
p19247
aS'                << std::endl;'
p19248
aS'      std::cerr << "Exception on processing: " << std::endl'
p19249
aS'                << exc.what() << std::endl'
p19250
aS'                << "Aborting!" << std::endl'
p19251
aS'                << "----------------------------------------------------"'
p19252
aS'                << std::endl;'
p19253
aS'      return 1;'
p19254
aS'    }'
p19255
aS'  catch (...)'
p19256
aS'    {'
p19257
aS'      std::cerr << std::endl'
p19258
aS'                << std::endl'
p19259
aS'                << "----------------------------------------------------"'
p19260
aS'                << std::endl;'
p19261
aS'      std::cerr << "Unknown exception!" << std::endl'
p19262
aS'                << "Aborting!" << std::endl'
p19263
aS'                << "----------------------------------------------------"'
p19264
aS'                << std::endl;'
p19265
aS'      return 1;'
p19266
aS'    }'
p19267
aS'  return 0;'
p19268
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p19269
aS'#include <deal.II/base/function.h>'
p19270
aS'#include <deal.II/base/index_set.h>'
p19271
aS'#include <deal.II/lac/affine_constraints.h>'
p19272
aS'#include <deal.II/lac/vector.h>'
p19273
aS'#include <deal.II/lac/full_matrix.h>'
p19274
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p19275
aS'#include <deal.II/lac/solver_cg.h>'
p19276
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p19277
aS'#include <deal.II/lac/trilinos_vector.h>'
p19278
aS'#include <deal.II/lac/trilinos_precondition.h>'
p19279
aS'#include <deal.II/grid/tria.h>'
p19280
aS'#include <deal.II/grid/grid_generator.h>'
p19281
aS'#include <deal.II/fe/fe_q.h>'
p19282
aS'#include <deal.II/fe/fe_values.h>'
p19283
aS'#include <deal.II/dofs/dof_handler.h>'
p19284
aS'#include <deal.II/dofs/dof_tools.h>'
p19285
aS'#include <deal.II/numerics/vector_tools.h>'
p19286
aS'#include <deal.II/numerics/data_out.h>'
p19287
aS'#include <fstream>'
p19288
aS'#include <iostream>'
p19289
aS'namespace Step41'
p19290
ag9
aS'  using namespace dealii;'
p19291
aS'  template <int dim>'
p19292
aS'  class ObstacleProblem'
p19293
aS'  {'
p19294
aS'  public:'
p19295
aS'    ObstacleProblem();'
p19296
aS'    void run();'
p19297
aS'  private:'
p19298
aS'    void make_grid();'
p19299
aS'    void setup_system();'
p19300
aS'    void assemble_system();'
p19301
aS'    void'
p19302
aS'         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);'
p19303
aS'    void update_solution_and_constraints();'
p19304
aS'    void solve();'
p19305
aS'    void output_results(const unsigned int iteration) const;'
p19306
aS'    Triangulation<dim>        triangulation;'
p19307
aS'    FE_Q<dim>                 fe;'
p19308
aS'    DoFHandler<dim>           dof_handler;'
p19309
aS'    AffineConstraints<double> constraints;'
p19310
aS'    IndexSet                  active_set;'
p19311
aS'    TrilinosWrappers::SparseMatrix system_matrix;'
p19312
aS'    TrilinosWrappers::SparseMatrix complete_system_matrix;'
p19313
aS'    TrilinosWrappers::MPI::Vector solution;'
p19314
aS'    TrilinosWrappers::MPI::Vector system_rhs;'
p19315
aS'    TrilinosWrappers::MPI::Vector complete_system_rhs;'
p19316
aS'    TrilinosWrappers::MPI::Vector diagonal_of_mass_matrix;'
p19317
aS'    TrilinosWrappers::MPI::Vector contact_force;'
p19318
aS'  };'
p19319
aS'  template <int dim>'
p19320
aS'  class RightHandSide : public Function<dim>'
p19321
aS'  {'
p19322
aS'  public:'
p19323
aS'    virtual double value(const Point<dim> & /*p*/,'
p19324
aS'                         const unsigned int component = 0) const override'
p19325
aS'    {'
p19326
aS'      AssertIndexRange(component, 1);'
p19327
aS'      return -10;'
p19328
aS'    }'
p19329
aS'  };'
p19330
aS'  template <int dim>'
p19331
aS'  class BoundaryValues : public Function<dim>'
p19332
aS'  {'
p19333
aS'  public:'
p19334
aS'    virtual double value(const Point<dim> & /*p*/,'
p19335
aS'                         const unsigned int component = 0) const override'
p19336
aS'    {'
p19337
aS'      AssertIndexRange(component, 1);'
p19338
aS'      return 0;'
p19339
aS'    }'
p19340
aS'  };'
p19341
aS'  template <int dim>'
p19342
aS'  class Obstacle : public Function<dim>'
p19343
aS'  {'
p19344
aS'  public:'
p19345
aS'    virtual double value(const Point<dim> & p,'
p19346
aS'                         const unsigned int component = 0) const override'
p19347
aS'    {'
p19348
aS'      Assert(component == 0, ExcIndexRange(component, 0, 1));'
p19349
aS'      if (p(0) < -0.5)'
p19350
aS'        return -0.2;'
p19351
aS'      else if (p(0) >= -0.5 && p(0) < 0.0)'
p19352
aS'        return -0.4;'
p19353
aS'      else if (p(0) >= 0.0 && p(0) < 0.5)'
p19354
aS'        return -0.6;'
p19355
aS'      else'
p19356
aS'        return -0.8;'
p19357
aS'    }'
p19358
aS'  };'
p19359
aS'  template <int dim>'
p19360
aS'  ObstacleProblem<dim>::ObstacleProblem()'
p19361
aS'    : fe(1)'
p19362
aS'    , dof_handler(triangulation)'
p19363
aS'  {}'
p19364
aS'  template <int dim>'
p19365
aS'  void ObstacleProblem<dim>::make_grid()'
p19366
aS'  {'
p19367
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p19368
aS'    triangulation.refine_global(7);'
p19369
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p19370
aS'              << std::endl'
p19371
aS'              << "Total number of cells: " << triangulation.n_cells()'
p19372
aS'              << std::endl;'
p19373
aS'  }'
p19374
aS'  template <int dim>'
p19375
aS'  void ObstacleProblem<dim>::setup_system()'
p19376
aS'  {'
p19377
aS'    dof_handler.distribute_dofs(fe);'
p19378
aS'    active_set.set_size(dof_handler.n_dofs());'
p19379
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p19380
aS'              << std::endl'
p19381
aS'              << std::endl;'
p19382
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p19383
aS'                                             0,'
p19384
aS'                                             BoundaryValues<dim>(),'
p19385
aS'                                             constraints);'
p19386
aS'    constraints.close();'
p19387
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p19388
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p19389
aS'    system_matrix.reinit(dsp);'
p19390
aS'    complete_system_matrix.reinit(dsp);'
p19391
aS'    IndexSet solution_index_set = dof_handler.locally_owned_dofs();'
p19392
aS'    solution.reinit(solution_index_set, MPI_COMM_WORLD);'
p19393
aS'    system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);'
p19394
aS'    complete_system_rhs.reinit(solution_index_set, MPI_COMM_WORLD);'
p19395
aS'    contact_force.reinit(solution_index_set, MPI_COMM_WORLD);'
p19396
aS'    TrilinosWrappers::SparseMatrix mass_matrix;'
p19397
aS'    mass_matrix.reinit(dsp);'
p19398
aS'    assemble_mass_matrix_diagonal(mass_matrix);'
p19399
aS'    diagonal_of_mass_matrix.reinit(solution_index_set);'
p19400
aS'    for (unsigned int j = 0; j < solution.size(); j++)'
p19401
aS'      diagonal_of_mass_matrix(j) = mass_matrix.diag_element(j);'
p19402
aS'  }'
p19403
aS'  template <int dim>'
p19404
aS'  void ObstacleProblem<dim>::assemble_system()'
p19405
aS'  {'
p19406
aS'    std::cout << "   Assembling system..." << std::endl;'
p19407
aS'    system_matrix = 0;'
p19408
aS'    system_rhs    = 0;'
p19409
aS'    const QGauss<dim>  quadrature_formula(fe.degree + 1);'
p19410
aS'    RightHandSide<dim> right_hand_side;'
p19411
aS'    FEValues<dim> fe_values(fe,'
p19412
aS'                            quadrature_formula,'
p19413
aS'                            update_values | update_gradients |'
p19414
aS'                              update_quadrature_points | update_JxW_values);'
p19415
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p19416
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p19417
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p19418
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p19419
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p19420
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p19421
aS'      {'
p19422
aS'        fe_values.reinit(cell);'
p19423
aS'        cell_matrix = 0;'
p19424
aS'        cell_rhs    = 0;'
p19425
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p19426
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p19427
aS'            {'
p19428
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p19429
aS'                cell_matrix(i, j) +='
p19430
aS'                   fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point));'
p19431
aS'              cell_rhs(i) +='
p19432
aS'                 right_hand_side.value(fe_values.quadrature_point(q_point)) *'
p19433
aS'                 fe_values.JxW(q_point));'
p19434
aS'            }'
p19435
aS'        cell->get_dof_indices(local_dof_indices);'
p19436
aS'        constraints.distribute_local_to_global(cell_matrix,'
p19437
aS'                                               cell_rhs,'
p19438
aS'                                               local_dof_indices,'
p19439
aS'                                               system_matrix,'
p19440
aS'                                               system_rhs,'
p19441
aS'                                               true);'
p19442
aS'      }'
p19443
aS'  }'
p19444
aS'  template <int dim>'
p19445
aS'  void ObstacleProblem<dim>::assemble_mass_matrix_diagonal('
p19446
aS'    TrilinosWrappers::SparseMatrix &mass_matrix)'
p19447
aS'  {'
p19448
aS'    Assert(fe.degree == 1, ExcNotImplemented());'
p19449
aS'    const QTrapezoid<dim> quadrature_formula;'
p19450
aS'    FEValues<dim>         fe_values(fe,'
p19451
aS'                            quadrature_formula,'
p19452
aS'                            update_values | update_JxW_values);'
p19453
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p19454
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p19455
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p19456
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p19457
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p19458
aS'      {'
p19459
aS'        fe_values.reinit(cell);'
p19460
aS'        cell_matrix = 0;'
p19461
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p19462
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p19463
aS'            cell_matrix(i, i) +='
p19464
aS'               fe_values.shape_value(i, q_point) * fe_values.JxW(q_point));'
p19465
aS'        cell->get_dof_indices(local_dof_indices);'
p19466
aS'        constraints.distribute_local_to_global(cell_matrix,'
p19467
aS'                                               local_dof_indices,'
p19468
aS'                                               mass_matrix);'
p19469
aS'      }'
p19470
aS'  }'
p19471
aS'  template <int dim>'
p19472
aS'  void ObstacleProblem<dim>::update_solution_and_constraints()'
p19473
aS'  {'
p19474
aS'    std::cout << "   Updating active set..." << std::endl;'
p19475
aS'    const double penalty_parameter = 100.0;'
p19476
aS'    TrilinosWrappers::MPI::Vector lambda('
p19477
aS'      complete_index_set(dof_handler.n_dofs()));'
p19478
aS'    complete_system_matrix.residual(lambda, solution, complete_system_rhs);'
p19479
aS'    contact_force = lambda;'
p19480
aS'    contact_force.scale(diagonal_of_mass_matrix);'
p19481
aS'    contact_force *= -1;'
p19482
aS'    constraints.clear();'
p19483
aS'    active_set.clear();'
p19484
aS'    const Obstacle<dim> obstacle;'
p19485
aS'    std::vector<bool>   dof_touched(dof_handler.n_dofs(), false);'
p19486
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p19487
aS'      for (const auto v : cell->vertex_indices())'
p19488
aS'        {'
p19489
aS'          Assert(dof_handler.get_fe().n_dofs_per_cell() == cell->n_vertices(),'
p19490
aS'                 ExcNotImplemented());'
p19491
aS'          const unsigned int dof_index = cell->vertex_dof_index(v, 0);'
p19492
aS'          if (dof_touched[dof_index] == false)'
p19493
aS'            dof_touched[dof_index] = true;'
p19494
aS'          else'
p19495
aS'            continue;'
p19496
aS'          const double obstacle_value = obstacle.value(cell->vertex(v));'
p19497
aS'          const double solution_value = solution(dof_index);'
p19498
aS'          if (lambda(dof_index) + penalty_parameter *'
p19499
aS'                                    diagonal_of_mass_matrix(dof_index) *'
p19500
aS'              0)'
p19501
aS'            {'
p19502
aS'              active_set.add_index(dof_index);'
p19503
aS'              constraints.add_line(dof_index);'
p19504
aS'              constraints.set_inhomogeneity(dof_index, obstacle_value);'
p19505
aS'              solution(dof_index) = obstacle_value;'
p19506
aS'              lambda(dof_index) = 0;'
p19507
aS'            }'
p19508
aS'        }'
p19509
aS'    std::cout << "      Size of active set: " << active_set.n_elements()'
p19510
aS'              << std::endl;'
p19511
aS'    std::cout << "   Residual of the non-contact part of the system: "'
p19512
aS'              << lambda.l2_norm() << std::endl;'
p19513
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p19514
aS'                                             0,'
p19515
aS'                                             BoundaryValues<dim>(),'
p19516
aS'                                             constraints);'
p19517
aS'    constraints.close();'
p19518
aS'  }'
p19519
aS'  template <int dim>'
p19520
aS'  void ObstacleProblem<dim>::solve()'
p19521
aS'  {'
p19522
aS'    std::cout << "   Solving system..." << std::endl;'
p19523
aS'    ReductionControl                        reduction_control(100, 1e-12, 1e-3);'
p19524
aS'    SolverCG<TrilinosWrappers::MPI::Vector> solver(reduction_control);'
p19525
aS'    TrilinosWrappers::PreconditionAMG       precondition;'
p19526
aS'    precondition.initialize(system_matrix);'
p19527
aS'    solver.solve(system_matrix, solution, system_rhs, precondition);'
p19528
aS'    constraints.distribute(solution);'
p19529
aS'    std::cout << "      Error: " << reduction_control.initial_value() << " -> "'
p19530
aS'              << reduction_control.last_value() << " in "'
p19531
aS'              << reduction_control.last_step() << " CG iterations."'
p19532
aS'              << std::endl;'
p19533
aS'  }'
p19534
aS'  template <int dim>'
p19535
aS'  void ObstacleProblem<dim>::output_results(const unsigned int iteration) const'
p19536
aS'  {'
p19537
aS'    std::cout << "   Writing graphical output..." << std::endl;'
p19538
aS'    TrilinosWrappers::MPI::Vector active_set_vector('
p19539
aS'      dof_handler.locally_owned_dofs(), MPI_COMM_WORLD);'
p19540
aS'    for (const auto index : active_set)'
p19541
aS'      active_set_vector[index] = 1.;'
p19542
aS'    DataOut<dim> data_out;'
p19543
aS'    data_out.attach_dof_handler(dof_handler);'
p19544
aS'    data_out.add_data_vector(solution, "displacement");'
p19545
aS'    data_out.add_data_vector(active_set_vector, "active_set");'
p19546
aS'    data_out.add_data_vector(contact_force, "lambda");'
p19547
aS'    data_out.build_patches();'
p19548
aS'    std::ofstream output_vtk("output_" +'
p19549
aS'                             Utilities::int_to_string(iteration, 3) + ".vtk");'
p19550
aS'    data_out.write_vtk(output_vtk);'
p19551
aS'  }'
p19552
aS'  template <int dim>'
p19553
aS'  void ObstacleProblem<dim>::run()'
p19554
aS'  {'
p19555
aS'    make_grid();'
p19556
aS'    setup_system();'
p19557
aS'    IndexSet active_set_old(active_set);'
p19558
aS'    for (unsigned int iteration = 0; iteration <= solution.size(); ++iteration)'
p19559
aS'      {'
p19560
aS'        std::cout << "Newton iteration " << iteration << std::endl;'
p19561
aS'        assemble_system();'
p19562
aS'        if (iteration == 0)'
p19563
aS'          {'
p19564
aS'            complete_system_matrix.copy_from(system_matrix);'
p19565
aS'            complete_system_rhs = system_rhs;'
p19566
aS'          }'
p19567
aS'        solve();'
p19568
aS'        update_solution_and_constraints();'
p19569
aS'        output_results(iteration);'
p19570
aS'        if (active_set == active_set_old)'
p19571
aS'          break;'
p19572
aS'        active_set_old = active_set;'
p19573
aS'        std::cout << std::endl;'
p19574
aS'      }'
p19575
aS'  }'
p19576
aS'} // namespace Step41'
p19577
aS'int main(int argc, char *argv[])'
p19578
ag9
aS'  try'
p19579
aS'    {'
p19580
aS'      using namespace dealii;'
p19581
aS'      using namespace Step41;'
p19582
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p19583
aS'        argc, argv, numbers::invalid_unsigned_int);'
p19584
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p19585
aS'                  ExcMessage('
p19586
aS'                    "This program can only be run in serial, use ./step-41"));'
p19587
aS'      ObstacleProblem<2> obstacle_problem;'
p19588
aS'      obstacle_problem.run();'
p19589
aS'    }'
p19590
aS'  catch (std::exception &exc)'
p19591
aS'    {'
p19592
aS'      std::cerr << std::endl'
p19593
aS'                << std::endl'
p19594
aS'                << "----------------------------------------------------"'
p19595
aS'                << std::endl;'
p19596
aS'      std::cerr << "Exception on processing: " << std::endl'
p19597
aS'                << exc.what() << std::endl'
p19598
aS'                << "Aborting!" << std::endl'
p19599
aS'                << "----------------------------------------------------"'
p19600
aS'                << std::endl;'
p19601
aS'      return 1;'
p19602
aS'    }'
p19603
aS'  catch (...)'
p19604
aS'    {'
p19605
aS'      std::cerr << std::endl'
p19606
aS'                << std::endl'
p19607
aS'                << "----------------------------------------------------"'
p19608
aS'                << std::endl;'
p19609
aS'      std::cerr << "Unknown exception!" << std::endl'
p19610
aS'                << "Aborting!" << std::endl'
p19611
aS'                << "----------------------------------------------------"'
p19612
aS'                << std::endl;'
p19613
aS'      return 1;'
p19614
aS'    }'
p19615
aS'  return 0;'
p19616
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p19617
aS'#include <deal.II/base/parameter_handler.h>'
p19618
aS'#include <deal.II/base/utilities.h>'
p19619
aS'#include <deal.II/base/index_set.h>'
p19620
aS'#include <deal.II/base/quadrature_lib.h>'
p19621
aS'#include <deal.II/base/function.h>'
p19622
aS'#include <deal.II/base/timer.h>'
p19623
aS'#include <deal.II/lac/vector.h>'
p19624
aS'#include <deal.II/lac/full_matrix.h>'
p19625
aS'#include <deal.II/lac/sparsity_tools.h>'
p19626
aS'#include <deal.II/lac/sparse_matrix.h>'
p19627
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p19628
aS'#include <deal.II/lac/solver_bicgstab.h>'
p19629
aS'#include <deal.II/lac/precondition.h>'
p19630
aS'#include <deal.II/lac/affine_constraints.h>'
p19631
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p19632
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p19633
aS'#include <deal.II/lac/trilinos_vector.h>'
p19634
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p19635
aS'#include <deal.II/lac/trilinos_precondition.h>'
p19636
aS'#include <deal.II/lac/trilinos_solver.h>'
p19637
aS'#include <deal.II/grid/tria.h>'
p19638
aS'#include <deal.II/grid/grid_generator.h>'
p19639
aS'#include <deal.II/grid/grid_tools.h>'
p19640
aS'#include <deal.II/grid/manifold_lib.h>'
p19641
aS'#include <deal.II/distributed/tria.h>'
p19642
aS'#include <deal.II/distributed/grid_refinement.h>'
p19643
aS'#include <deal.II/distributed/solution_transfer.h>'
p19644
aS'#include <deal.II/dofs/dof_handler.h>'
p19645
aS'#include <deal.II/dofs/dof_renumbering.h>'
p19646
aS'#include <deal.II/dofs/dof_tools.h>'
p19647
aS'#include <deal.II/fe/fe_q.h>'
p19648
aS'#include <deal.II/fe/fe_system.h>'
p19649
aS'#include <deal.II/fe/fe_values.h>'
p19650
aS'#include <deal.II/numerics/vector_tools.h>'
p19651
aS'#include <deal.II/numerics/matrix_tools.h>'
p19652
aS'#include <deal.II/numerics/data_out.h>'
p19653
aS'#include <deal.II/numerics/error_estimator.h>'
p19654
aS'#include <deal.II/numerics/fe_field_function.h>'
p19655
aS'#include <fstream>'
p19656
aS'#include <iostream>'
p19657
aS'#include <sys/stat.h>'
p19658
aS'#include <cerrno>'
p19659
aS'namespace Step42'
p19660
ag9
aS'  using namespace dealii;'
p19661
aS'  template <int dim>'
p19662
aS'  class ConstitutiveLaw'
p19663
aS'  {'
p19664
aS'  public:'
p19665
aS'    ConstitutiveLaw(const double E,'
p19666
aS'                    const double nu,'
p19667
aS'                    const double sigma_0,'
p19668
aS'                    const double gamma);'
p19669
aS'    void set_sigma_0(double sigma_zero);'
p19670
aS'    bool get_stress_strain_tensor('
p19671
aS'      const SymmetricTensor<2, dim> &strain_tensor,'
p19672
aS'      SymmetricTensor<4, dim> &      stress_strain_tensor) const;'
p19673
aS'    void get_linearized_stress_strain_tensors('
p19674
aS'      const SymmetricTensor<2, dim> &strain_tensor,'
p19675
aS'      SymmetricTensor<4, dim> &      stress_strain_tensor_linearized,'
p19676
aS'      SymmetricTensor<4, dim> &      stress_strain_tensor) const;'
p19677
aS'  private:'
p19678
aS'    const double kappa;'
p19679
aS'    const double mu;'
p19680
aS'    double       sigma_0;'
p19681
aS'    const double gamma;'
p19682
aS'    const SymmetricTensor<4, dim> stress_strain_tensor_kappa;'
p19683
aS'    const SymmetricTensor<4, dim> stress_strain_tensor_mu;'
p19684
aS'  };'
p19685
aS'  template <int dim>'
p19686
aS'  ConstitutiveLaw<dim>::ConstitutiveLaw(double E,'
p19687
aS'                                        double nu,'
p19688
aS'                                        double sigma_0,'
p19689
aS'                                        double gamma)'
p19690
aS'    : kappa(E / (3 * (1 - 2 * nu)))'
p19691
aS'    , mu(E / (2 * (1 + nu)))'
p19692
aS'    , sigma_0(sigma_0)'
p19693
aS'    , gamma(gamma)'
p19694
aS'    , stress_strain_tensor_kappa(kappa *'
p19695
aS'                                 outer_product(unit_symmetric_tensor<dim>(),'
p19696
aS'                                               unit_symmetric_tensor<dim>()))'
p19697
aS'    , stress_strain_tensor_mu('
p19698
aS'        2 * mu *'
p19699
aS'                                                unit_symmetric_tensor<dim>()) /'
p19700
aS'                                    3.0))'
p19701
aS'  {}'
p19702
aS'  template <int dim>'
p19703
aS'  void ConstitutiveLaw<dim>::set_sigma_0(double sigma_zero)'
p19704
aS'  {'
p19705
aS'    sigma_0 = sigma_zero;'
p19706
aS'  }'
p19707
aS'  template <int dim>'
p19708
aS'  bool ConstitutiveLaw<dim>::get_stress_strain_tensor('
p19709
aS'    const SymmetricTensor<2, dim> &strain_tensor,'
p19710
aS'    SymmetricTensor<4, dim> &      stress_strain_tensor) const'
p19711
aS'  {'
p19712
aS'    Assert(dim == 3, ExcNotImplemented());'
p19713
aS'    SymmetricTensor<2, dim> stress_tensor;'
p19714
aS'    stress_tensor ='
p19715
aS'    const SymmetricTensor<2, dim> deviator_stress_tensor ='
p19716
aS'      deviator(stress_tensor);'
p19717
aS'    const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();'
p19718
aS'    stress_strain_tensor = stress_strain_tensor_mu;'
p19719
aS'    if (deviator_stress_tensor_norm > sigma_0)'
p19720
aS'      {'
p19721
aS'        const double beta = sigma_0 / deviator_stress_tensor_norm;'
p19722
aS'        stress_strain_tensor *= (gamma + (1 - gamma) * beta);'
p19723
aS'      }'
p19724
aS'    stress_strain_tensor += stress_strain_tensor_kappa;'
p19725
aS'    return (deviator_stress_tensor_norm > sigma_0);'
p19726
aS'  }'
p19727
aS'  template <int dim>'
p19728
aS'  void ConstitutiveLaw<dim>::get_linearized_stress_strain_tensors('
p19729
aS'    const SymmetricTensor<2, dim> &strain_tensor,'
p19730
aS'    SymmetricTensor<4, dim> &      stress_strain_tensor_linearized,'
p19731
aS'    SymmetricTensor<4, dim> &      stress_strain_tensor) const'
p19732
aS'  {'
p19733
aS'    Assert(dim == 3, ExcNotImplemented());'
p19734
aS'    SymmetricTensor<2, dim> stress_tensor;'
p19735
aS'    stress_tensor ='
p19736
aS'    stress_strain_tensor            = stress_strain_tensor_mu;'
p19737
aS'    stress_strain_tensor_linearized = stress_strain_tensor_mu;'
p19738
aS'    SymmetricTensor<2, dim> deviator_stress_tensor = deviator(stress_tensor);'
p19739
aS'    const double deviator_stress_tensor_norm = deviator_stress_tensor.norm();'
p19740
aS'    if (deviator_stress_tensor_norm > sigma_0)'
p19741
aS'      {'
p19742
aS'        const double beta = sigma_0 / deviator_stress_tensor_norm;'
p19743
aS'        stress_strain_tensor *= (gamma + (1 - gamma) * beta);'
p19744
aS'        stress_strain_tensor_linearized *= (gamma + (1 - gamma) * beta);'
p19745
aS'        deviator_stress_tensor /= deviator_stress_tensor_norm;'
p19746
aS'        stress_strain_tensor_linearized -='
p19747
aS'          outer_product(deviator_stress_tensor, deviator_stress_tensor);'
p19748
aS'      }'
p19749
aS'    stress_strain_tensor += stress_strain_tensor_kappa;'
p19750
aS'    stress_strain_tensor_linearized += stress_strain_tensor_kappa;'
p19751
aS'  }'
p19752
aS'  namespace EquationData'
p19753
aS'  {'
p19754
aS'    template <int dim>'
p19755
aS'    class BoundaryForce : public Function<dim>'
p19756
aS'    {'
p19757
aS'    public:'
p19758
aS'      BoundaryForce();'
p19759
aS'      virtual double value(const Point<dim> & p,'
p19760
aS'                           const unsigned int component = 0) const override;'
p19761
aS'      virtual void vector_value(const Point<dim> &p,'
p19762
aS'                                Vector<double> &  values) const override;'
p19763
aS'    };'
p19764
aS'    template <int dim>'
p19765
aS'    BoundaryForce<dim>::BoundaryForce()'
p19766
aS'      : Function<dim>(dim)'
p19767
aS'    {}'
p19768
aS'    template <int dim>'
p19769
aS'    double BoundaryForce<dim>::value(const Point<dim> &,'
p19770
aS'                                     const unsigned int) const'
p19771
aS'    {'
p19772
aS'      return 0.;'
p19773
aS'    }'
p19774
aS'    template <int dim>'
p19775
aS'    void BoundaryForce<dim>::vector_value(const Point<dim> &p,'
p19776
aS'                                          Vector<double> &  values) const'
p19777
aS'    {'
p19778
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p19779
aS'        values(c) = BoundaryForce<dim>::value(p, c);'
p19780
aS'    }'
p19781
aS'    template <int dim>'
p19782
aS'    class BoundaryValues : public Function<dim>'
p19783
aS'    {'
p19784
aS'    public:'
p19785
aS'      BoundaryValues();'
p19786
aS'      virtual double value(const Point<dim> & p,'
p19787
aS'                           const unsigned int component = 0) const override;'
p19788
aS'    };'
p19789
aS'    template <int dim>'
p19790
aS'    BoundaryValues<dim>::BoundaryValues()'
p19791
aS'      : Function<dim>(dim)'
p19792
aS'    {}'
p19793
aS'    template <int dim>'
p19794
aS'    double BoundaryValues<dim>::value(const Point<dim> &,'
p19795
aS'                                      const unsigned int) const'
p19796
aS'    {'
p19797
aS'      return 0.;'
p19798
aS'    }'
p19799
aS'    template <int dim>'
p19800
aS'    class SphereObstacle : public Function<dim>'
p19801
aS'    {'
p19802
aS'    public:'
p19803
aS'      SphereObstacle(const double z_surface);'
p19804
aS'      virtual double value(const Point<dim> & p,'
p19805
aS'                           const unsigned int component = 0) const override;'
p19806
aS'      virtual void vector_value(const Point<dim> &p,'
p19807
aS'                                Vector<double> &  values) const override;'
p19808
aS'    private:'
p19809
aS'      const double z_surface;'
p19810
aS'    };'
p19811
aS'    template <int dim>'
p19812
aS'    SphereObstacle<dim>::SphereObstacle(const double z_surface)'
p19813
aS'      : Function<dim>(dim)'
p19814
aS'      , z_surface(z_surface)'
p19815
aS'    {}'
p19816
aS'    template <int dim>'
p19817
aS'    double SphereObstacle<dim>::value(const Point<dim> & p,'
p19818
aS'                                      const unsigned int component) const'
p19819
aS'    {'
p19820
aS'      if (component == 0)'
p19821
aS'        return p(0);'
p19822
aS'      else if (component == 1)'
p19823
aS'        return p(1);'
p19824
aS'      else if (component == 2)'
p19825
aS'        {'
p19826
aS'          if ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) < 0.36)'
p19827
aS'            return (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -'
p19828
aS'                    z_surface + 0.59);'
p19829
aS'          else'
p19830
aS'            return 1000;'
p19831
aS'        }'
p19832
aS'      Assert(false, ExcNotImplemented());'
p19833
aS'      return 1e9; // an unreasonable value; ignored in debug mode because of the'
p19834
aS'    }'
p19835
aS'    template <int dim>'
p19836
aS'    void SphereObstacle<dim>::vector_value(const Point<dim> &p,'
p19837
aS'                                           Vector<double> &  values) const'
p19838
aS'    {'
p19839
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p19840
aS'        values(c) = SphereObstacle<dim>::value(p, c);'
p19841
aS'    }'
p19842
aS'    template <int dim>'
p19843
aS'    class BitmapFile'
p19844
aS'    {'
p19845
aS'    public:'
p19846
aS'      BitmapFile(const std::string &name);'
p19847
aS'      double get_value(const double x, const double y) const;'
p19848
aS'    private:'
p19849
aS'      std::vector<double> obstacle_data;'
p19850
aS'      double              hx, hy;'
p19851
aS'      int                 nx, ny;'
p19852
aS'      double get_pixel_value(const int i, const int j) const;'
p19853
aS'    };'
p19854
aS'    template <int dim>'
p19855
aS'    BitmapFile<dim>::BitmapFile(const std::string &name)'
p19856
aS'      : obstacle_data(0)'
p19857
aS'      , hx(0)'
p19858
aS'      , hy(0)'
p19859
aS'      , nx(0)'
p19860
aS'      , ny(0)'
p19861
aS'    {'
p19862
aS'      std::ifstream f(name);'
p19863
aS'      AssertThrow(f,'
p19864
aS'                  ExcMessage(std::string("Can\'t read from file <") + name +'
p19865
aS'                             ">!"));'
p19866
aS'      std::string temp;'
p19867
aS'      f >> temp >> nx >> ny;'
p19868
aS'      AssertThrow(nx > 0 && ny > 0, ExcMessage("Invalid file format."));'
p19869
aS'      for (int k = 0; k < nx * ny; ++k)'
p19870
aS'        {'
p19871
aS'          double val;'
p19872
aS'          f >> val;'
p19873
aS'          obstacle_data.push_back(val);'
p19874
aS'        }'
p19875
aS'      hx = 1.0 / (nx - 1);'
p19876
aS'      hy = 1.0 / (ny - 1);'
p19877
aS'      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p19878
aS'        std::cout << "Read obstacle from file <" << name << ">" << std::endl'
p19879
aS'                  << "Resolution of the scanned obstacle picture: " << nx'
p19880
aS'                  << " x " << ny << std::endl;'
p19881
aS'    }'
p19882
aS'    template <int dim>'
p19883
aS'    double BitmapFile<dim>::get_pixel_value(const int i, const int j) const'
p19884
aS'    {'
p19885
aS'      assert(i >= 0 && i < nx);'
p19886
aS'      assert(j >= 0 && j < ny);'
p19887
aS'      return obstacle_data[nx * (ny - 1 - j) + i];'
p19888
aS'    }'
p19889
aS'    template <int dim>'
p19890
aS'    double BitmapFile<dim>::get_value(const double x, const double y) const'
p19891
aS'    {'
p19892
aS'      const int ix = std::min(std::max(static_cast<int>(x / hx), 0), nx - 2);'
p19893
aS'      const int iy = std::min(std::max(static_cast<int>(y / hy), 0), ny - 2);'
p19894
aS'      const double xi  = std::min(std::max((x - ix * hx) / hx, 1.), 0.);'
p19895
aS'      const double eta = std::min(std::max((y - iy * hy) / hy, 1.), 0.);'
p19896
aS'      return ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +'
p19897
aS'              xi * (1 - eta) * get_pixel_value(ix + 1, iy) +'
p19898
aS'              xi * eta * get_pixel_value(ix + 1, iy + 1));'
p19899
aS'    }'
p19900
aS'    template <int dim>'
p19901
aS'    class ChineseObstacle : public Function<dim>'
p19902
aS'    {'
p19903
aS'    public:'
p19904
aS'      ChineseObstacle(const std::string &filename, const double z_surface);'
p19905
aS'      virtual double value(const Point<dim> & p,'
p19906
aS'                           const unsigned int component = 0) const override;'
p19907
aS'      virtual void vector_value(const Point<dim> &p,'
p19908
aS'                                Vector<double> &  values) const override;'
p19909
aS'    private:'
p19910
aS'      const BitmapFile<dim> input_obstacle;'
p19911
aS'      double                z_surface;'
p19912
aS'    };'
p19913
aS'    template <int dim>'
p19914
aS'    ChineseObstacle<dim>::ChineseObstacle(const std::string &filename,'
p19915
aS'                                          const double       z_surface)'
p19916
aS'      : Function<dim>(dim)'
p19917
aS'      , input_obstacle(filename)'
p19918
aS'      , z_surface(z_surface)'
p19919
aS'    {}'
p19920
aS'    template <int dim>'
p19921
aS'    double ChineseObstacle<dim>::value(const Point<dim> & p,'
p19922
aS'                                       const unsigned int component) const'
p19923
aS'    {'
p19924
aS'      if (component == 0)'
p19925
aS'        return p(0);'
p19926
aS'      if (component == 1)'
p19927
aS'        return p(1);'
p19928
aS'      else if (component == 2)'
p19929
aS'        {'
p19930
aS'          if (p(0) >= 0.0 && p(0) <= 1.0 && p(1) >= 0.0 && p(1) <= 1.0)'
p19931
aS'            return z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));'
p19932
aS'        }'
p19933
aS'      Assert(false, ExcNotImplemented());'
p19934
aS'      return 1e9; // an unreasonable value; ignored in debug mode because of the'
p19935
aS'    }'
p19936
aS'    template <int dim>'
p19937
aS'    void ChineseObstacle<dim>::vector_value(const Point<dim> &p,'
p19938
aS'                                            Vector<double> &  values) const'
p19939
aS'    {'
p19940
aS'      for (unsigned int c = 0; c < this->n_components; ++c)'
p19941
aS'        values(c) = ChineseObstacle<dim>::value(p, c);'
p19942
aS'    }'
p19943
aS'  } // namespace EquationData'
p19944
aS'  template <int dim>'
p19945
aS'  class PlasticityContactProblem'
p19946
aS'  {'
p19947
aS'  public:'
p19948
aS'    PlasticityContactProblem(const ParameterHandler &prm);'
p19949
aS'    void run();'
p19950
aS'    static void declare_parameters(ParameterHandler &prm);'
p19951
aS'  private:'
p19952
aS'    void make_grid();'
p19953
aS'    void setup_system();'
p19954
aS'    void compute_dirichlet_constraints();'
p19955
aS'    void update_solution_and_constraints();'
p19956
aS'    void'
p19957
aS'         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &mass_matrix);'
p19958
aS'    void assemble_newton_system('
p19959
aS'      const TrilinosWrappers::MPI::Vector &linearization_point);'
p19960
aS'    void compute_nonlinear_residual('
p19961
aS'      const TrilinosWrappers::MPI::Vector &linearization_point);'
p19962
aS'    void solve_newton_system();'
p19963
aS'    void solve_newton();'
p19964
aS'    void refine_grid();'
p19965
aS'    void move_mesh(const TrilinosWrappers::MPI::Vector &displacement) const;'
p19966
aS'    void output_results(const unsigned int current_refinement_cycle);'
p19967
aS'    void output_contact_force() const;'
p19968
aS'    MPI_Comm           mpi_communicator;'
p19969
aS'    ConditionalOStream pcout;'
p19970
aS'    TimerOutput        computing_timer;'
p19971
aS'    const unsigned int                        n_initial_global_refinements;'
p19972
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p19973
aS'    const unsigned int fe_degree;'
p19974
aS'    FESystem<dim>      fe;'
p19975
aS'    DoFHandler<dim>    dof_handler;'
p19976
aS'    IndexSet locally_owned_dofs;'
p19977
aS'    IndexSet locally_relevant_dofs;'
p19978
aS'    AffineConstraints<double> constraints_hanging_nodes;'
p19979
aS'    AffineConstraints<double> constraints_dirichlet_and_hanging_nodes;'
p19980
aS'    AffineConstraints<double> all_constraints;'
p19981
aS'    IndexSet      active_set;'
p19982
aS'    Vector<float> fraction_of_plastic_q_points_per_cell;'
p19983
aS'    TrilinosWrappers::SparseMatrix newton_matrix;'
p19984
aS'    TrilinosWrappers::MPI::Vector solution;'
p19985
aS'    TrilinosWrappers::MPI::Vector newton_rhs;'
p19986
aS'    TrilinosWrappers::MPI::Vector newton_rhs_uncondensed;'
p19987
aS'    TrilinosWrappers::MPI::Vector diag_mass_matrix_vector;'
p19988
aS'    const double         e_modulus, nu, gamma, sigma_0;'
p19989
aS'    ConstitutiveLaw<dim> constitutive_law;'
p19990
aS'    const std::string                          base_mesh;'
p19991
aS'    const std::shared_ptr<const Function<dim>> obstacle;'
p19992
aS'    struct RefinementStrategy'
p19993
aS'    {'
p19994
aS'      enum value'
p19995
aS'      {'
p19996
aS'        refine_global,'
p19997
aS'        refine_percentage,'
p19998
aS'        refine_fix_dofs'
p19999
aS'      };'
p20000
aS'    };'
p20001
aS'    typename RefinementStrategy::value refinement_strategy;'
p20002
aS'    const bool         transfer_solution;'
p20003
aS'    std::string        output_dir;'
p20004
aS'    const unsigned int n_refinement_cycles;'
p20005
aS'    unsigned int       current_refinement_cycle;'
p20006
aS'  };'
p20007
aS'  template <int dim>'
p20008
aS'  void PlasticityContactProblem<dim>::declare_parameters(ParameterHandler &prm)'
p20009
aS'  {'
p20010
aS'    prm.declare_entry('
p20011
aS'      "polynomial degree",'
p20012
aS'      "1",'
p20013
aS'      Patterns::Integer(),'
p20014
aS'      "Polynomial degree of the FE_Q finite element space, typically 1 or 2.");'
p20015
aS'    prm.declare_entry("number of initial refinements",'
p20016
aS'                      "2",'
p20017
aS'                      Patterns::Integer(),'
p20018
aS'                      "Number of initial global mesh refinement steps before "'
p20019
aS'                      "the first computation.");'
p20020
aS'    prm.declare_entry('
p20021
aS'      "refinement strategy",'
p20022
aS'      "percentage",'
p20023
aS'      Patterns::Selection("global|percentage"),'
p20024
aS'      "Mesh refinement strategy:\\n"'
p20025
aS'      " global: one global refinement\\n"'
p20026
aS'      " percentage: a fixed percentage of cells gets refined using the Kelly estimator.");'
p20027
aS'    prm.declare_entry("number of cycles",'
p20028
aS'                      "5",'
p20029
aS'                      Patterns::Integer(),'
p20030
aS'                      "Number of adaptive mesh refinement cycles to run.");'
p20031
aS'    prm.declare_entry('
p20032
aS'      "obstacle",'
p20033
aS'      "sphere",'
p20034
aS'      Patterns::Selection("sphere|read from file"),'
p20035
aS'      "The name of the obstacle to use. This may either be \'sphere\' if we should "'
p20036
aS'      "use a spherical obstacle, or \'read from file\' in which case the obstacle "'
p20037
aS'      "will be read from a file named \'obstacle.pbm\' that is supposed to be in "'
p20038
aS'      "ASCII PBM format.");'
p20039
aS'    prm.declare_entry('
p20040
aS'      "output directory",'
p20041
aS'      "",'
p20042
aS'      Patterns::Anything(),'
p20043
aS'      "Directory for output files (graphical output and benchmark "'
p20044
aS'      "statistics). If empty, use the current directory.");'
p20045
aS'    prm.declare_entry('
p20046
aS'      "transfer solution",'
p20047
aS'      "false",'
p20048
aS'      Patterns::Bool(),'
p20049
aS'      "Whether the solution should be used as a starting guess "'
p20050
aS'      "for the next finer mesh. If false, then the iteration starts at "'
p20051
aS'      "zero on every mesh.");'
p20052
aS'    prm.declare_entry("base mesh",'
p20053
aS'                      "box",'
p20054
aS'                      Patterns::Selection("box|half sphere"),'
p20055
aS'                      "Select the shape of the domain: \'box\' or \'half sphere\'");'
p20056
aS'  }'
p20057
aS'  template <int dim>'
p20058
aS'  PlasticityContactProblem<dim>::PlasticityContactProblem('
p20059
aS'    const ParameterHandler &prm)'
p20060
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p20061
aS'    , pcout(std::cout,'
p20062
aS'    , computing_timer(MPI_COMM_WORLD,'
p20063
aS'                      pcout,'
p20064
aS'                      TimerOutput::never,'
p20065
aS'                      TimerOutput::wall_times)'
p20066
aS'    , n_initial_global_refinements('
p20067
aS'        prm.get_integer("number of initial refinements"))'
p20068
aS'    , triangulation(mpi_communicator)'
p20069
aS'    , fe_degree(prm.get_integer("polynomial degree"))'
p20070
aS'    , fe(FE_Q<dim>(QGaussLobatto<1>(fe_degree + 1)), dim)'
p20071
aS'    , dof_handler(triangulation)'
p20072
aS'    , e_modulus(200000)'
p20073
aS'    , nu(0.3)'
p20074
aS'    , gamma(0.01)'
p20075
aS'    , sigma_0(400.0)'
p20076
aS'    , constitutive_law(e_modulus, nu, sigma_0, gamma)'
p20077
aS'    , base_mesh(prm.get("base mesh"))'
p20078
aS'    , obstacle(prm.get("obstacle") == "read from file" ?'
p20079
aS'                 static_cast<const Function<dim> *>('
p20080
aS'                   new EquationData::ChineseObstacle<dim>('
p20081
aS'                     "obstacle.pbm",'
p20082
aS'                 static_cast<const Function<dim> *>('
p20083
aS'                   new EquationData::SphereObstacle<dim>('
p20084
aS'                     base_mesh == "box" ? 1.0 : 0.5)))'
p20085
aS'    , transfer_solution(prm.get_bool("transfer solution"))'
p20086
aS'    , n_refinement_cycles(prm.get_integer("number of cycles"))'
p20087
aS'    , current_refinement_cycle(0)'
p20088
aS'  {'
p20089
aS'    std::string strat = prm.get("refinement strategy");'
p20090
aS'    if (strat == "global")'
p20091
aS'      refinement_strategy = RefinementStrategy::refine_global;'
p20092
aS'    else if (strat == "percentage")'
p20093
aS'      refinement_strategy = RefinementStrategy::refine_percentage;'
p20094
aS'    else'
p20095
aS'      AssertThrow(false, ExcNotImplemented());'
p20096
aS'    output_dir = prm.get("output directory");'
p20097
aS'    if (output_dir != "" && *(output_dir.rbegin()) != \'/\')'
p20098
aS'      output_dir += "/";'
p20099
aS'    if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p20100
aS'      {'
p20101
aS'        const int ierr = mkdir(output_dir.c_str(), 0777);'
p20102
aS'        AssertThrow(ierr == 0 || errno == EEXIST, ExcIO());'
p20103
aS'      }'
p20104
aS'    pcout << "    Using output directory \'" << output_dir << "\'" << std::endl;'
p20105
aS'    pcout << "    FE degree " << fe_degree << std::endl;'
p20106
aS'    pcout << "    transfer solution " << (transfer_solution ? "true" : "false")'
p20107
aS'          << std::endl;'
p20108
aS'  }'
p20109
aS'  Point<3> rotate_half_sphere(const Point<3> &in)'
p20110
aS'  {'
p20111
aS'    return {in(2), in(1), -in(0)};'
p20112
aS'  }'
p20113
aS'  template <int dim>'
p20114
aS'  void PlasticityContactProblem<dim>::make_grid()'
p20115
aS'  {'
p20116
aS'    if (base_mesh == "half sphere")'
p20117
aS'      {'
p20118
aS'        const Point<dim> center(0, 0, 0);'
p20119
aS'        const double     radius = 0.8;'
p20120
aS'        GridGenerator::half_hyper_ball(triangulation, center, radius);'
p20121
aS'        triangulation.reset_all_manifolds();'
p20122
aS'        GridTools::transform(&rotate_half_sphere, triangulation);'
p20123
aS'        GridTools::shift(Point<dim>(0.5, 0.5, 0.5), triangulation);'
p20124
aS'        SphericalManifold<dim> manifold_description(Point<dim>(0.5, 0.5, 0.5));'
p20125
aS'        GridTools::copy_boundary_to_manifold_id(triangulation);'
p20126
aS'        triangulation.set_manifold(0, manifold_description);'
p20127
aS'      }'
p20128
aS'    else'
p20129
aS'      {'
p20130
aS'        const Point<dim> p1(0, 0, 0);'
p20131
aS'        const Point<dim> p2(1.0, 1.0, 1.0);'
p20132
aS'        GridGenerator::hyper_rectangle(triangulation, p1, p2);'
p20133
aS'        for (const auto &cell : triangulation.active_cell_iterators())'
p20134
aS'          for (const auto &face : cell->face_iterators())'
p20135
aS'            if (face->at_boundary())'
p20136
aS'              {'
p20137
aS'                if (std::fabs(face->center()[2] - p2[2]) < 1e-12)'
p20138
aS'                  face->set_boundary_id(1);'
p20139
aS'                if (std::fabs(face->center()[0] - p1[0]) < 1e-12 ||'
p20140
aS'                    std::fabs(face->center()[0] - p2[0]) < 1e-12 ||'
p20141
aS'                    std::fabs(face->center()[1] - p1[1]) < 1e-12 ||'
p20142
aS'                    std::fabs(face->center()[1] - p2[1]) < 1e-12)'
p20143
aS'                  face->set_boundary_id(8);'
p20144
aS'                if (std::fabs(face->center()[2] - p1[2]) < 1e-12)'
p20145
aS'                  face->set_boundary_id(6);'
p20146
aS'              }'
p20147
aS'      }'
p20148
aS'    triangulation.refine_global(n_initial_global_refinements);'
p20149
aS'  }'
p20150
aS'  template <int dim>'
p20151
aS'  void PlasticityContactProblem<dim>::setup_system()'
p20152
aS'  {'
p20153
aS'    {'
p20154
aS'      TimerOutput::Scope t(computing_timer, "Setup: distribute DoFs");'
p20155
aS'      dof_handler.distribute_dofs(fe);'
p20156
aS'      locally_owned_dofs = dof_handler.locally_owned_dofs();'
p20157
aS'      locally_relevant_dofs.clear();'
p20158
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler,'
p20159
aS'                                              locally_relevant_dofs);'
p20160
aS'    }'
p20161
aS'    {'
p20162
aS'      TimerOutput::Scope t(computing_timer, "Setup: constraints");'
p20163
aS'      constraints_hanging_nodes.reinit(locally_relevant_dofs);'
p20164
aS'      DoFTools::make_hanging_node_constraints(dof_handler,'
p20165
aS'                                              constraints_hanging_nodes);'
p20166
aS'      constraints_hanging_nodes.close();'
p20167
aS'      pcout << "   Number of active cells: "'
p20168
aS'            << triangulation.n_global_active_cells() << std::endl'
p20169
aS'            << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p20170
aS'            << std::endl;'
p20171
aS'      compute_dirichlet_constraints();'
p20172
aS'    }'
p20173
aS'    {'
p20174
aS'      TimerOutput::Scope t(computing_timer, "Setup: vectors");'
p20175
aS'      solution.reinit(locally_relevant_dofs, mpi_communicator);'
p20176
aS'      newton_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p20177
aS'      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);'
p20178
aS'      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);'
p20179
aS'      fraction_of_plastic_q_points_per_cell.reinit('
p20180
aS'        triangulation.n_active_cells());'
p20181
aS'      active_set.clear();'
p20182
aS'      active_set.set_size(dof_handler.n_dofs());'
p20183
aS'    }'
p20184
aS'    {'
p20185
aS'      TimerOutput::Scope                t(computing_timer, "Setup: matrix");'
p20186
aS'      TrilinosWrappers::SparsityPattern sp(locally_owned_dofs,'
p20187
aS'                                           mpi_communicator);'
p20188
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p20189
aS'                                      sp,'
p20190
aS'                                      constraints_dirichlet_and_hanging_nodes,'
p20191
aS'                                      false,'
p20192
aS'                                      Utilities::MPI::this_mpi_process('
p20193
aS'                                        mpi_communicator));'
p20194
aS'      sp.compress();'
p20195
aS'      newton_matrix.reinit(sp);'
p20196
aS'      TrilinosWrappers::SparseMatrix &mass_matrix = newton_matrix;'
p20197
aS'      assemble_mass_matrix_diagonal(mass_matrix);'
p20198
aS'      const unsigned int start = (newton_rhs.local_range().first),'
p20199
aS'                         end   = (newton_rhs.local_range().second);'
p20200
aS'      for (unsigned int j = start; j < end; ++j)'
p20201
aS'        diag_mass_matrix_vector(j) = mass_matrix.diag_element(j);'
p20202
aS'      diag_mass_matrix_vector.compress(VectorOperation::insert);'
p20203
aS'      mass_matrix = 0;'
p20204
aS'    }'
p20205
aS'  }'
p20206
aS'  template <int dim>'
p20207
aS'  void PlasticityContactProblem<dim>::compute_dirichlet_constraints()'
p20208
aS'  {'
p20209
aS'    constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs);'
p20210
aS'    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);'
p20211
aS'    if (base_mesh == "box")'
p20212
aS'      {'
p20213
aS'        VectorTools::interpolate_boundary_values('
p20214
aS'          dof_handler,'
p20215
aS'          6,'
p20216
aS'          EquationData::BoundaryValues<dim>(),'
p20217
aS'          constraints_dirichlet_and_hanging_nodes,'
p20218
aS'          ComponentMask());'
p20219
aS'        const FEValuesExtractors::Scalar x_displacement(0);'
p20220
aS'        const FEValuesExtractors::Scalar y_displacement(1);'
p20221
aS'        VectorTools::interpolate_boundary_values('
p20222
aS'          dof_handler,'
p20223
aS'          8,'
p20224
aS'          EquationData::BoundaryValues<dim>(),'
p20225
aS'          constraints_dirichlet_and_hanging_nodes,'
p20226
aS'           fe.component_mask(y_displacement)));'
p20227
aS'      }'
p20228
aS'    else'
p20229
aS'      VectorTools::interpolate_boundary_values('
p20230
aS'        dof_handler,'
p20231
aS'        0,'
p20232
aS'        EquationData::BoundaryValues<dim>(),'
p20233
aS'        constraints_dirichlet_and_hanging_nodes,'
p20234
aS'        ComponentMask());'
p20235
aS'    constraints_dirichlet_and_hanging_nodes.close();'
p20236
aS'  }'
p20237
aS'  template <int dim>'
p20238
aS'  void PlasticityContactProblem<dim>::assemble_mass_matrix_diagonal('
p20239
aS'    TrilinosWrappers::SparseMatrix &mass_matrix)'
p20240
aS'  {'
p20241
aS'    QGaussLobatto<dim - 1> face_quadrature_formula(fe.degree + 1);'
p20242
aS'    FEFaceValues<dim> fe_values_face(fe,'
p20243
aS'                                     face_quadrature_formula,'
p20244
aS'                                     update_values | update_JxW_values);'
p20245
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p20246
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p20247
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p20248
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p20249
aS'    const FEValuesExtractors::Vector displacement(0);'
p20250
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20251
aS'      if (cell->is_locally_owned())'
p20252
aS'        for (const auto &face : cell->face_iterators())'
p20253
aS'          if (face->at_boundary() && face->boundary_id() == 1)'
p20254
aS'            {'
p20255
aS'              fe_values_face.reinit(cell, face);'
p20256
aS'              cell_matrix = 0;'
p20257
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p20258
aS'                   ++q_point)'
p20259
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20260
aS'                  cell_matrix(i, i) +='
p20261
aS'                     fe_values_face[displacement].value(i, q_point) *'
p20262
aS'                     fe_values_face.JxW(q_point));'
p20263
aS'              cell->get_dof_indices(local_dof_indices);'
p20264
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20265
aS'                mass_matrix.add(local_dof_indices[i],'
p20266
aS'                                local_dof_indices[i],'
p20267
aS'                                cell_matrix(i, i));'
p20268
aS'            }'
p20269
aS'    mass_matrix.compress(VectorOperation::add);'
p20270
aS'  }'
p20271
aS'  template <int dim>'
p20272
aS'  void PlasticityContactProblem<dim>::update_solution_and_constraints()'
p20273
aS'  {'
p20274
aS'    std::vector<bool> dof_touched(dof_handler.n_dofs(), false);'
p20275
aS'    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p20276
aS'                                                       mpi_communicator);'
p20277
aS'    distributed_solution = solution;'
p20278
aS'    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,'
p20279
aS'                                         mpi_communicator);'
p20280
aS'    lambda = newton_rhs_uncondensed;'
p20281
aS'    TrilinosWrappers::MPI::Vector diag_mass_matrix_vector_relevant('
p20282
aS'      locally_relevant_dofs, mpi_communicator);'
p20283
aS'    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;'
p20284
aS'    all_constraints.reinit(locally_relevant_dofs);'
p20285
aS'    active_set.clear();'
p20286
aS'    Quadrature<dim - 1> face_quadrature(fe.get_unit_face_support_points());'
p20287
aS'    FEFaceValues<dim>   fe_values_face(fe,'
p20288
aS'                                     face_quadrature,'
p20289
aS'                                     update_quadrature_points);'
p20290
aS'    const unsigned int dofs_per_face   = fe.n_dofs_per_face();'
p20291
aS'    const unsigned int n_face_q_points = face_quadrature.size();'
p20292
aS'    std::vector<types::global_dof_index> dof_indices(dofs_per_face);'
p20293
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20294
aS'      if (!cell->is_artificial())'
p20295
aS'        for (const auto &face : cell->face_iterators())'
p20296
aS'          if (face->at_boundary() && face->boundary_id() == 1)'
p20297
aS'            {'
p20298
aS'              fe_values_face.reinit(cell, face);'
p20299
aS'              face->get_dof_indices(dof_indices);'
p20300
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p20301
aS'                   ++q_point)'
p20302
aS'                {'
p20303
aS'                  const unsigned int component ='
p20304
aS'                    fe.face_system_to_component_index(q_point).first;'
p20305
aS'                  const unsigned int index_z = dof_indices[q_point];'
p20306
aS'                  if ((component == 2) && (dof_touched[index_z] == false))'
p20307
aS'                    {'
p20308
aS'                      dof_touched[index_z] = true;'
p20309
aS'                      const Point<dim> this_support_point ='
p20310
aS'                        fe_values_face.quadrature_point(q_point);'
p20311
aS'                      const double obstacle_value ='
p20312
aS'                        obstacle->value(this_support_point, 2);'
p20313
aS'                      const double solution_here = solution(index_z);'
p20314
aS'                      const double undeformed_gap ='
p20315
aS'                        obstacle_value - this_support_point(2);'
p20316
aS'                      const double c = 100.0 * e_modulus;'
p20317
aS'                      if ((lambda(index_z) /'
p20318
aS'                               diag_mass_matrix_vector_relevant(index_z) +'
p20319
aS'                             c * (solution_here - undeformed_gap) >'
p20320
aS'                           0) &&'
p20321
aS'                          !constraints_hanging_nodes.is_constrained(index_z))'
p20322
aS'                        {'
p20323
aS'                          all_constraints.add_line(index_z);'
p20324
aS'                          all_constraints.set_inhomogeneity(index_z,'
p20325
aS'                                                            undeformed_gap);'
p20326
aS'                          distributed_solution(index_z) = undeformed_gap;'
p20327
aS'                          active_set.add_index(index_z);'
p20328
aS'                        }'
p20329
aS'                    }'
p20330
aS'                }'
p20331
aS'            }'
p20332
aS'    distributed_solution.compress(VectorOperation::insert);'
p20333
aS'    solution = distributed_solution;'
p20334
aS'    all_constraints.close();'
p20335
aS'    all_constraints.merge(constraints_dirichlet_and_hanging_nodes);'
p20336
aS'    pcout << "         Size of active set: "'
p20337
aS'          << Utilities::MPI::sum((active_set & locally_owned_dofs).n_elements(),'
p20338
aS'                                 mpi_communicator)'
p20339
aS'          << std::endl;'
p20340
aS'  }'
p20341
aS'  template <int dim>'
p20342
aS'  void PlasticityContactProblem<dim>::assemble_newton_system('
p20343
aS'    const TrilinosWrappers::MPI::Vector &linearization_point)'
p20344
aS'  {'
p20345
aS'    TimerOutput::Scope t(computing_timer, "Assembling");'
p20346
aS'    QGauss<dim>     quadrature_formula(fe.degree + 1);'
p20347
aS'    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p20348
aS'    FEValues<dim> fe_values(fe,'
p20349
aS'                            quadrature_formula,'
p20350
aS'                            update_values | update_gradients |'
p20351
aS'                              update_JxW_values);'
p20352
aS'    FEFaceValues<dim> fe_values_face(fe,'
p20353
aS'                                     face_quadrature_formula,'
p20354
aS'                                     update_values | update_quadrature_points |'
p20355
aS'                                       update_JxW_values);'
p20356
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p20357
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p20358
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p20359
aS'    const EquationData::BoundaryForce<dim> boundary_force;'
p20360
aS'    std::vector<Vector<double>> boundary_force_values(n_face_q_points,'
p20361
aS'                                                      Vector<double>(dim));'
p20362
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p20363
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p20364
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p20365
aS'    const FEValuesExtractors::Vector displacement(0);'
p20366
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20367
aS'      if (cell->is_locally_owned())'
p20368
aS'        {'
p20369
aS'          fe_values.reinit(cell);'
p20370
aS'          cell_matrix = 0;'
p20371
aS'          cell_rhs    = 0;'
p20372
aS'          std::vector<SymmetricTensor<2, dim>> strain_tensor(n_q_points);'
p20373
aS'          fe_values[displacement].get_function_symmetric_gradients('
p20374
aS'            linearization_point, strain_tensor);'
p20375
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p20376
aS'            {'
p20377
aS'              SymmetricTensor<4, dim> stress_strain_tensor_linearized;'
p20378
aS'              SymmetricTensor<4, dim> stress_strain_tensor;'
p20379
aS'              constitutive_law.get_linearized_stress_strain_tensors('
p20380
aS'                strain_tensor[q_point],'
p20381
aS'                stress_strain_tensor_linearized,'
p20382
aS'                stress_strain_tensor);'
p20383
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20384
aS'                {'
p20385
aS'                  const SymmetricTensor<2, dim> stress_phi_i ='
p20386
aS'                    stress_strain_tensor_linearized *'
p20387
aS'                    fe_values[displacement].symmetric_gradient(i, q_point);'
p20388
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p20389
aS'                    cell_matrix(i, j) +='
p20390
aS'                       fe_values[displacement].symmetric_gradient(j, q_point) *'
p20391
aS'                       fe_values.JxW(q_point));'
p20392
aS'                  cell_rhs(i) +='
p20393
aS'                      stress_strain_tensor *'
p20394
aS'                        fe_values[displacement].symmetric_gradient(i,'
p20395
aS'                                                                   q_point)) *'
p20396
aS'                     strain_tensor[q_point] * fe_values.JxW(q_point));'
p20397
aS'                }'
p20398
aS'            }'
p20399
aS'          for (const auto &face : cell->face_iterators())'
p20400
aS'            if (face->at_boundary() && face->boundary_id() == 1)'
p20401
aS'              {'
p20402
aS'                fe_values_face.reinit(cell, face);'
p20403
aS'                boundary_force.vector_value_list('
p20404
aS'                  fe_values_face.get_quadrature_points(),'
p20405
aS'                  boundary_force_values);'
p20406
aS'                for (unsigned int q_point = 0; q_point < n_face_q_points;'
p20407
aS'                     ++q_point)'
p20408
aS'                  {'
p20409
aS'                    Tensor<1, dim> rhs_values;'
p20410
aS'                    rhs_values[2] = boundary_force_values[q_point][2];'
p20411
aS'                    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20412
aS'                      cell_rhs(i) +='
p20413
aS'                         rhs_values * fe_values_face.JxW(q_point));'
p20414
aS'                  }'
p20415
aS'              }'
p20416
aS'          cell->get_dof_indices(local_dof_indices);'
p20417
aS'          all_constraints.distribute_local_to_global(cell_matrix,'
p20418
aS'                                                     cell_rhs,'
p20419
aS'                                                     local_dof_indices,'
p20420
aS'                                                     newton_matrix,'
p20421
aS'                                                     newton_rhs,'
p20422
aS'                                                     true);'
p20423
aS'        }'
p20424
aS'    newton_matrix.compress(VectorOperation::add);'
p20425
aS'    newton_rhs.compress(VectorOperation::add);'
p20426
aS'  }'
p20427
aS'  template <int dim>'
p20428
aS'  void PlasticityContactProblem<dim>::compute_nonlinear_residual('
p20429
aS'    const TrilinosWrappers::MPI::Vector &linearization_point)'
p20430
aS'  {'
p20431
aS'    QGauss<dim>     quadrature_formula(fe.degree + 1);'
p20432
aS'    QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p20433
aS'    FEValues<dim> fe_values(fe,'
p20434
aS'                            quadrature_formula,'
p20435
aS'                            update_values | update_gradients |'
p20436
aS'                              update_JxW_values);'
p20437
aS'    FEFaceValues<dim> fe_values_face(fe,'
p20438
aS'                                     face_quadrature_formula,'
p20439
aS'                                     update_values | update_quadrature_points |'
p20440
aS'                                       update_JxW_values);'
p20441
aS'    const unsigned int dofs_per_cell   = fe.n_dofs_per_cell();'
p20442
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p20443
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p20444
aS'    const EquationData::BoundaryForce<dim> boundary_force;'
p20445
aS'    std::vector<Vector<double>> boundary_force_values(n_face_q_points,'
p20446
aS'                                                      Vector<double>(dim));'
p20447
aS'    Vector<double> cell_rhs(dofs_per_cell);'
p20448
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p20449
aS'    const FEValuesExtractors::Vector displacement(0);'
p20450
aS'    newton_rhs             = 0;'
p20451
aS'    newton_rhs_uncondensed = 0;'
p20452
aS'    fraction_of_plastic_q_points_per_cell = 0;'
p20453
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20454
aS'      if (cell->is_locally_owned())'
p20455
aS'        {'
p20456
aS'          fe_values.reinit(cell);'
p20457
aS'          cell_rhs = 0;'
p20458
aS'          std::vector<SymmetricTensor<2, dim>> strain_tensors(n_q_points);'
p20459
aS'          fe_values[displacement].get_function_symmetric_gradients('
p20460
aS'            linearization_point, strain_tensors);'
p20461
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p20462
aS'            {'
p20463
aS'              SymmetricTensor<4, dim> stress_strain_tensor;'
p20464
aS'              const bool              q_point_is_plastic ='
p20465
aS'                constitutive_law.get_stress_strain_tensor('
p20466
aS'                  strain_tensors[q_point], stress_strain_tensor);'
p20467
aS'              if (q_point_is_plastic)'
p20468
aS'                ++fraction_of_plastic_q_points_per_cell('
p20469
aS'                  cell->active_cell_index());'
p20470
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20471
aS'                {'
p20472
aS'                  cell_rhs(i) -='
p20473
aS'                     fe_values[displacement].symmetric_gradient(i, q_point) *'
p20474
aS'                     fe_values.JxW(q_point));'
p20475
aS'                  Tensor<1, dim> rhs_values;'
p20476
aS'                  rhs_values = 0;'
p20477
aS'                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) *'
p20478
aS'                                  rhs_values * fe_values.JxW(q_point));'
p20479
aS'                }'
p20480
aS'            }'
p20481
aS'          for (const auto &face : cell->face_iterators())'
p20482
aS'            if (face->at_boundary() && face->boundary_id() == 1)'
p20483
aS'              {'
p20484
aS'                fe_values_face.reinit(cell, face);'
p20485
aS'                boundary_force.vector_value_list('
p20486
aS'                  fe_values_face.get_quadrature_points(),'
p20487
aS'                  boundary_force_values);'
p20488
aS'                for (unsigned int q_point = 0; q_point < n_face_q_points;'
p20489
aS'                     ++q_point)'
p20490
aS'                  {'
p20491
aS'                    Tensor<1, dim> rhs_values;'
p20492
aS'                    rhs_values[2] = boundary_force_values[q_point][2];'
p20493
aS'                    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20494
aS'                      cell_rhs(i) +='
p20495
aS'                         rhs_values * fe_values_face.JxW(q_point));'
p20496
aS'                  }'
p20497
aS'              }'
p20498
aS'          cell->get_dof_indices(local_dof_indices);'
p20499
aS'          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global('
p20500
aS'            cell_rhs, local_dof_indices, newton_rhs);'
p20501
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p20502
aS'            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);'
p20503
aS'        }'
p20504
aS'    fraction_of_plastic_q_points_per_cell /= quadrature_formula.size();'
p20505
aS'    newton_rhs.compress(VectorOperation::add);'
p20506
aS'    newton_rhs_uncondensed.compress(VectorOperation::add);'
p20507
aS'  }'
p20508
aS'  template <int dim>'
p20509
aS'  void PlasticityContactProblem<dim>::solve_newton_system()'
p20510
aS'  {'
p20511
aS'    TimerOutput::Scope t(computing_timer, "Solve");'
p20512
aS'    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p20513
aS'                                                       mpi_communicator);'
p20514
aS'    distributed_solution = solution;'
p20515
aS'    constraints_hanging_nodes.set_zero(distributed_solution);'
p20516
aS'    constraints_hanging_nodes.set_zero(newton_rhs);'
p20517
aS'    TrilinosWrappers::PreconditionAMG preconditioner;'
p20518
aS'    {'
p20519
aS'      TimerOutput::Scope t(computing_timer, "Solve: setup preconditioner");'
p20520
aS'      std::vector<std::vector<bool>> constant_modes;'
p20521
aS'      DoFTools::extract_constant_modes(dof_handler,'
p20522
aS'                                       ComponentMask(),'
p20523
aS'                                       constant_modes);'
p20524
aS'      TrilinosWrappers::PreconditionAMG::AdditionalData additional_data;'
p20525
aS'      additional_data.constant_modes        = constant_modes;'
p20526
aS'      additional_data.elliptic              = true;'
p20527
aS'      additional_data.n_cycles              = 1;'
p20528
aS'      additional_data.w_cycle               = false;'
p20529
aS'      additional_data.output_details        = false;'
p20530
aS'      additional_data.smoother_sweeps       = 2;'
p20531
aS'      additional_data.aggregation_threshold = 1e-2;'
p20532
aS'      preconditioner.initialize(newton_matrix, additional_data);'
p20533
aS'    }'
p20534
aS'    {'
p20535
aS'      TimerOutput::Scope t(computing_timer, "Solve: iterate");'
p20536
aS'      TrilinosWrappers::MPI::Vector tmp(locally_owned_dofs, mpi_communicator);'
p20537
aS'      const double relative_accuracy = 1e-8;'
p20538
aS'      const double solver_tolerance ='
p20539
aS'        relative_accuracy *'
p20540
aS'        newton_matrix.residual(tmp, distributed_solution, newton_rhs);'
p20541
aS'      SolverControl solver_control(newton_matrix.m(), solver_tolerance);'
p20542
aS'      SolverBicgstab<TrilinosWrappers::MPI::Vector> solver(solver_control);'
p20543
aS'      solver.solve(newton_matrix,'
p20544
aS'                   distributed_solution,'
p20545
aS'                   newton_rhs,'
p20546
aS'                   preconditioner);'
p20547
aS'      pcout << "         Error: " << solver_control.initial_value() << " -> "'
p20548
aS'            << solver_control.last_value() << " in "'
p20549
aS'            << solver_control.last_step() << " Bicgstab iterations."'
p20550
aS'            << std::endl;'
p20551
aS'    }'
p20552
aS'    all_constraints.distribute(distributed_solution);'
p20553
aS'    solution = distributed_solution;'
p20554
aS'  }'
p20555
aS'  template <int dim>'
p20556
aS'  void PlasticityContactProblem<dim>::solve_newton()'
p20557
aS'  {'
p20558
aS'    TrilinosWrappers::MPI::Vector old_solution(locally_owned_dofs,'
p20559
aS'                                               mpi_communicator);'
p20560
aS'    TrilinosWrappers::MPI::Vector residual(locally_owned_dofs,'
p20561
aS'                                           mpi_communicator);'
p20562
aS'    TrilinosWrappers::MPI::Vector tmp_vector(locally_owned_dofs,'
p20563
aS'                                             mpi_communicator);'
p20564
aS'    TrilinosWrappers::MPI::Vector locally_relevant_tmp_vector('
p20565
aS'      locally_relevant_dofs, mpi_communicator);'
p20566
aS'    TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p20567
aS'                                                       mpi_communicator);'
p20568
aS'    double residual_norm;'
p20569
aS'    double previous_residual_norm = -std::numeric_limits<double>::max();'
p20570
aS'    const double correct_sigma = sigma_0;'
p20571
aS'    IndexSet old_active_set(active_set);'
p20572
aS'    for (unsigned int newton_step = 1; newton_step <= 100; ++newton_step)'
p20573
aS'      {'
p20574
aS'        if (newton_step == 1 &&'
p20575
aS'             !transfer_solution))'
p20576
aS'          constitutive_law.set_sigma_0(1e+10);'
p20577
aS'        else if (newton_step == 2 || current_refinement_cycle > 0 ||'
p20578
aS'                 !transfer_solution)'
p20579
aS'          constitutive_law.set_sigma_0(correct_sigma);'
p20580
aS'        pcout << " " << std::endl;'
p20581
aS'        pcout << "   Newton iteration " << newton_step << std::endl;'
p20582
aS'        pcout << "      Updating active set..." << std::endl;'
p20583
aS'        {'
p20584
aS'          TimerOutput::Scope t(computing_timer, "update active set");'
p20585
aS'          update_solution_and_constraints();'
p20586
aS'        }'
p20587
aS'        pcout << "      Assembling system... " << std::endl;'
p20588
aS'        newton_matrix = 0;'
p20589
aS'        newton_rhs    = 0;'
p20590
aS'        assemble_newton_system(solution);'
p20591
aS'        pcout << "      Solving system... " << std::endl;'
p20592
aS'        solve_newton_system();'
p20593
aS'        if ((newton_step == 1) ||'
p20594
aS'             current_refinement_cycle == 0) ||'
p20595
aS'          {'
p20596
aS'            compute_nonlinear_residual(solution);'
p20597
aS'            old_solution = solution;'
p20598
aS'            residual                     = newton_rhs;'
p20599
aS'            const unsigned int start_res = (residual.local_range().first),'
p20600
aS'                               end_res   = (residual.local_range().second);'
p20601
aS'            for (unsigned int n = start_res; n < end_res; ++n)'
p20602
aS'              if (all_constraints.is_inhomogeneously_constrained(n))'
p20603
aS'                residual(n) = 0;'
p20604
aS'            residual.compress(VectorOperation::insert);'
p20605
aS'            residual_norm = residual.l2_norm();'
p20606
aS'            pcout << "      Accepting Newton solution with residual: "'
p20607
aS'                  << residual_norm << std::endl;'
p20608
aS'          }'
p20609
aS'        else'
p20610
aS'          {'
p20611
aS'            for (unsigned int i = 0; i < 5; ++i)'
p20612
aS'              {'
p20613
aS'                distributed_solution = solution;'
p20614
aS'                const double alpha = std::pow(0.5, static_cast<double>(i));'
p20615
aS'                tmp_vector         = old_solution;'
p20616
aS'                tmp_vector.sadd(1 - alpha, alpha, distributed_solution);'
p20617
aS'                TimerOutput::Scope t(computing_timer, "Residual and lambda");'
p20618
aS'                locally_relevant_tmp_vector = tmp_vector;'
p20619
aS'                compute_nonlinear_residual(locally_relevant_tmp_vector);'
p20620
aS'                residual = newton_rhs;'
p20621
aS'                const unsigned int start_res = (residual.local_range().first),'
p20622
aS'                                   end_res   = (residual.local_range().second);'
p20623
aS'                for (unsigned int n = start_res; n < end_res; ++n)'
p20624
aS'                  if (all_constraints.is_inhomogeneously_constrained(n))'
p20625
aS'                    residual(n) = 0;'
p20626
aS'                residual.compress(VectorOperation::insert);'
p20627
aS'                residual_norm = residual.l2_norm();'
p20628
aS'                pcout'
p20629
aS'                  << "      Residual of the non-contact part of the system: "'
p20630
aS'                  << residual_norm << std::endl'
p20631
aS'                  << "         with a damping parameter alpha = " << alpha'
p20632
aS'                  << std::endl;'
p20633
aS'                if (residual_norm < previous_residual_norm)'
p20634
aS'                  break;'
p20635
aS'              }'
p20636
aS'            solution     = tmp_vector;'
p20637
aS'            old_solution = solution;'
p20638
aS'          }'
p20639
aS'        previous_residual_norm = residual_norm;'
p20640
aS'        if (Utilities::MPI::sum((active_set == old_active_set) ? 0 : 1,'
p20641
aS'                                mpi_communicator) == 0)'
p20642
aS'          {'
p20643
aS'            pcout << "      Active set did not change!" << std::endl;'
p20644
aS'            if (residual_norm < 1e-10)'
p20645
aS'              break;'
p20646
aS'          }'
p20647
aS'        old_active_set = active_set;'
p20648
aS'      }'
p20649
aS'  }'
p20650
aS'  template <int dim>'
p20651
aS'  void PlasticityContactProblem<dim>::refine_grid()'
p20652
aS'  {'
p20653
aS'    if (refinement_strategy == RefinementStrategy::refine_global)'
p20654
aS'      {'
p20655
aS'        for (typename Triangulation<dim>::active_cell_iterator cell ='
p20656
aS'               triangulation.begin_active();'
p20657
aS'             cell != triangulation.end();'
p20658
aS'             ++cell)'
p20659
aS'          if (cell->is_locally_owned())'
p20660
aS'            cell->set_refine_flag();'
p20661
aS'      }'
p20662
aS'    else'
p20663
aS'      {'
p20664
aS'        Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p20665
aS'        KellyErrorEstimator<dim>::estimate('
p20666
aS'          dof_handler,'
p20667
aS'          QGauss<dim - 1>(fe.degree + 2),'
p20668
aS'          std::map<types::boundary_id, const Function<dim> *>(),'
p20669
aS'          solution,'
p20670
aS'          estimated_error_per_cell);'
p20671
aS'        parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number('
p20672
aS'          triangulation, estimated_error_per_cell, 0.3, 0.03);'
p20673
aS'      }'
p20674
aS'    triangulation.prepare_coarsening_and_refinement();'
p20675
aS'    parallel::distributed::SolutionTransfer<dim, TrilinosWrappers::MPI::Vector>'
p20676
aS'      solution_transfer(dof_handler);'
p20677
aS'    if (transfer_solution)'
p20678
aS'      solution_transfer.prepare_for_coarsening_and_refinement(solution);'
p20679
aS'    triangulation.execute_coarsening_and_refinement();'
p20680
aS'    setup_system();'
p20681
aS'    if (transfer_solution)'
p20682
aS'      {'
p20683
aS'        TrilinosWrappers::MPI::Vector distributed_solution(locally_owned_dofs,'
p20684
aS'                                                           mpi_communicator);'
p20685
aS'        solution_transfer.interpolate(distributed_solution);'
p20686
aS'        constraints_hanging_nodes.distribute(distributed_solution);'
p20687
aS'        solution = distributed_solution;'
p20688
aS'        compute_nonlinear_residual(solution);'
p20689
aS'      }'
p20690
aS'  }'
p20691
aS'  template <int dim>'
p20692
aS'  void PlasticityContactProblem<dim>::move_mesh('
p20693
aS'    const TrilinosWrappers::MPI::Vector &displacement) const'
p20694
aS'  {'
p20695
aS'    std::vector<bool> vertex_touched(triangulation.n_vertices(), false);'
p20696
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20697
aS'      if (cell->is_locally_owned())'
p20698
aS'        for (const auto v : cell->vertex_indices())'
p20699
aS'          if (vertex_touched[cell->vertex_index(v)] == false)'
p20700
aS'            {'
p20701
aS'              vertex_touched[cell->vertex_index(v)] = true;'
p20702
aS'              Point<dim> vertex_displacement;'
p20703
aS'              for (unsigned int d = 0; d < dim; ++d)'
p20704
aS'                vertex_displacement[d] ='
p20705
aS'                  displacement(cell->vertex_dof_index(v, d));'
p20706
aS'              cell->vertex(v) += vertex_displacement;'
p20707
aS'            }'
p20708
aS'  }'
p20709
aS'  template <int dim>'
p20710
aS'  void PlasticityContactProblem<dim>::output_results('
p20711
aS'    const unsigned int current_refinement_cycle)'
p20712
aS'  {'
p20713
aS'    TimerOutput::Scope t(computing_timer, "Graphical output");'
p20714
aS'    pcout << "      Writing graphical output... " << std::flush;'
p20715
aS'    move_mesh(solution);'
p20716
aS'    TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,'
p20717
aS'                                                     mpi_communicator);'
p20718
aS'    const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),'
p20719
aS'                       end_res = (newton_rhs_uncondensed.local_range().second);'
p20720
aS'    for (unsigned int n = start_res; n < end_res; ++n)'
p20721
aS'      if (all_constraints.is_inhomogeneously_constrained(n))'
p20722
aS'        distributed_lambda(n) ='
p20723
aS'          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);'
p20724
aS'    distributed_lambda.compress(VectorOperation::insert);'
p20725
aS'    constraints_hanging_nodes.distribute(distributed_lambda);'
p20726
aS'    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,'
p20727
aS'                                         mpi_communicator);'
p20728
aS'    lambda = distributed_lambda;'
p20729
aS'    TrilinosWrappers::MPI::Vector distributed_active_set_vector('
p20730
aS'      locally_owned_dofs, mpi_communicator);'
p20731
aS'    distributed_active_set_vector = 0.;'
p20732
aS'    for (const auto index : active_set)'
p20733
aS'      distributed_active_set_vector[index] = 1.;'
p20734
aS'    distributed_lambda.compress(VectorOperation::insert);'
p20735
aS'    TrilinosWrappers::MPI::Vector active_set_vector(locally_relevant_dofs,'
p20736
aS'                                                    mpi_communicator);'
p20737
aS'    active_set_vector = distributed_active_set_vector;'
p20738
aS'    DataOut<dim> data_out;'
p20739
aS'    data_out.attach_dof_handler(dof_handler);'
p20740
aS'    const std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p20741
aS'      data_component_interpretation('
p20742
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p20743
aS'    data_out.add_data_vector(solution,'
p20744
aS'                             std::vector<std::string>(dim, "displacement"),'
p20745
aS'                             DataOut<dim>::type_dof_data,'
p20746
aS'                             data_component_interpretation);'
p20747
aS'    data_out.add_data_vector(lambda,'
p20748
aS'                             std::vector<std::string>(dim, "contact_force"),'
p20749
aS'                             DataOut<dim>::type_dof_data,'
p20750
aS'                             data_component_interpretation);'
p20751
aS'    data_out.add_data_vector(active_set_vector,'
p20752
aS'                             std::vector<std::string>(dim, "active_set"),'
p20753
aS'                             DataOut<dim>::type_dof_data,'
p20754
aS'                             data_component_interpretation);'
p20755
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p20756
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p20757
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p20758
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p20759
aS'    data_out.add_data_vector(fraction_of_plastic_q_points_per_cell,'
p20760
aS'                             "fraction_of_plastic_q_points");'
p20761
aS'    data_out.build_patches();'
p20762
aS'    const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record('
p20763
aS'      output_dir, "solution", current_refinement_cycle, mpi_communicator, 2);'
p20764
aS'    pcout << pvtu_filename << std::endl;'
p20765
aS'    TrilinosWrappers::MPI::Vector tmp(solution);'
p20766
aS'    tmp *= -1;'
p20767
aS'    move_mesh(tmp);'
p20768
aS'  }'
p20769
aS'  template <int dim>'
p20770
aS'  void PlasticityContactProblem<dim>::output_contact_force() const'
p20771
aS'  {'
p20772
aS'    TrilinosWrappers::MPI::Vector distributed_lambda(locally_owned_dofs,'
p20773
aS'                                                     mpi_communicator);'
p20774
aS'    const unsigned int start_res = (newton_rhs_uncondensed.local_range().first),'
p20775
aS'                       end_res = (newton_rhs_uncondensed.local_range().second);'
p20776
aS'    for (unsigned int n = start_res; n < end_res; ++n)'
p20777
aS'      if (all_constraints.is_inhomogeneously_constrained(n))'
p20778
aS'        distributed_lambda(n) ='
p20779
aS'          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);'
p20780
aS'      else'
p20781
aS'        distributed_lambda(n) = 0;'
p20782
aS'    distributed_lambda.compress(VectorOperation::insert);'
p20783
aS'    constraints_hanging_nodes.distribute(distributed_lambda);'
p20784
aS'    TrilinosWrappers::MPI::Vector lambda(locally_relevant_dofs,'
p20785
aS'                                         mpi_communicator);'
p20786
aS'    lambda = distributed_lambda;'
p20787
aS'    double contact_force = 0.0;'
p20788
aS'    QGauss<dim - 1>   face_quadrature_formula(fe.degree + 1);'
p20789
aS'    FEFaceValues<dim> fe_values_face(fe,'
p20790
aS'                                     face_quadrature_formula,'
p20791
aS'                                     update_values | update_JxW_values);'
p20792
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p20793
aS'    const FEValuesExtractors::Vector displacement(0);'
p20794
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p20795
aS'      if (cell->is_locally_owned())'
p20796
aS'        for (const auto &face : cell->face_iterators())'
p20797
aS'          if (face->at_boundary() && face->boundary_id() == 1)'
p20798
aS'            {'
p20799
aS'              fe_values_face.reinit(cell, face);'
p20800
aS'              std::vector<Tensor<1, dim>> lambda_values(n_face_q_points);'
p20801
aS'              fe_values_face[displacement].get_function_values(lambda,'
p20802
aS'                                                               lambda_values);'
p20803
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p20804
aS'                   ++q_point)'
p20805
aS'                contact_force +='
p20806
aS'                  lambda_values[q_point][2] * fe_values_face.JxW(q_point);'
p20807
aS'            }'
p20808
aS'    contact_force = Utilities::MPI::sum(contact_force, MPI_COMM_WORLD);'
p20809
aS'    pcout << "Contact force = " << contact_force << std::endl;'
p20810
aS'  }'
p20811
aS'  template <int dim>'
p20812
aS'  void PlasticityContactProblem<dim>::run()'
p20813
aS'  {'
p20814
aS'    computing_timer.reset();'
p20815
aS'    for (; current_refinement_cycle < n_refinement_cycles;'
p20816
aS'         ++current_refinement_cycle)'
p20817
aS'      {'
p20818
aS'        {'
p20819
aS'          TimerOutput::Scope t(computing_timer, "Setup");'
p20820
aS'          pcout << std::endl;'
p20821
aS'          pcout << "Cycle " << current_refinement_cycle << \':\' << std::endl;'
p20822
aS'          if (current_refinement_cycle == 0)'
p20823
aS'            {'
p20824
aS'              make_grid();'
p20825
aS'              setup_system();'
p20826
aS'            }'
p20827
aS'          else'
p20828
aS'            {'
p20829
aS'              TimerOutput::Scope t(computing_timer, "Setup: refine mesh");'
p20830
aS'              refine_grid();'
p20831
aS'            }'
p20832
aS'        }'
p20833
aS'        solve_newton();'
p20834
aS'        output_results(current_refinement_cycle);'
p20835
aS'        computing_timer.print_summary();'
p20836
aS'        computing_timer.reset();'
p20837
aS'        Utilities::System::MemoryStats stats;'
p20838
aS'        Utilities::System::get_memory_stats(stats);'
p20839
aS'        pcout << "Peak virtual memory used, resident in kB: " << stats.VmSize'
p20840
aS'              << " " << stats.VmRSS << std::endl;'
p20841
aS'        if (base_mesh == "box")'
p20842
aS'          output_contact_force();'
p20843
aS'      }'
p20844
aS'  }'
p20845
aS'} // namespace Step42'
p20846
aS'int main(int argc, char *argv[])'
p20847
ag9
aS'  using namespace dealii;'
p20848
aS'  using namespace Step42;'
p20849
aS'  try'
p20850
aS'    {'
p20851
aS'      ParameterHandler prm;'
p20852
aS'      PlasticityContactProblem<3>::declare_parameters(prm);'
p20853
aS'      if (argc != 2)'
p20854
aS'        {'
p20855
aS'          std::cerr << "*** Call this program as <./step-42 input.prm>"'
p20856
aS'                    << std::endl;'
p20857
aS'          return 1;'
p20858
aS'        }'
p20859
aS'      prm.parse_input(argv[1]);'
p20860
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p20861
aS'        argc, argv, numbers::invalid_unsigned_int);'
p20862
aS'      {'
p20863
aS'        PlasticityContactProblem<3> problem(prm);'
p20864
aS'        problem.run();'
p20865
aS'      }'
p20866
aS'    }'
p20867
aS'  catch (std::exception &exc)'
p20868
aS'    {'
p20869
aS'      std::cerr << std::endl'
p20870
aS'                << std::endl'
p20871
aS'                << "----------------------------------------------------"'
p20872
aS'                << std::endl;'
p20873
aS'      std::cerr << "Exception on processing: " << std::endl'
p20874
aS'                << exc.what() << std::endl'
p20875
aS'                << "Aborting!" << std::endl'
p20876
aS'                << "----------------------------------------------------"'
p20877
aS'                << std::endl;'
p20878
aS'      return 1;'
p20879
aS'    }'
p20880
aS'  catch (...)'
p20881
aS'    {'
p20882
aS'      std::cerr << std::endl'
p20883
aS'                << std::endl'
p20884
aS'                << "----------------------------------------------------"'
p20885
aS'                << std::endl;'
p20886
aS'      std::cerr << "Unknown exception!" << std::endl'
p20887
aS'                << "Aborting!" << std::endl'
p20888
aS'                << "----------------------------------------------------"'
p20889
aS'                << std::endl;'
p20890
aS'      return 1;'
p20891
aS'    }'
p20892
aS'  return 0;'
p20893
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p20894
aS'#include <deal.II/base/logstream.h>'
p20895
aS'#include <deal.II/base/utilities.h>'
p20896
aS'#include <deal.II/base/function.h>'
p20897
aS'#include <deal.II/base/tensor_function.h>'
p20898
aS'#include <deal.II/base/index_set.h>'
p20899
aS'#include <deal.II/lac/full_matrix.h>'
p20900
aS'#include <deal.II/lac/solver_gmres.h>'
p20901
aS'#include <deal.II/lac/solver_cg.h>'
p20902
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p20903
aS'#include <deal.II/lac/affine_constraints.h>'
p20904
aS'#include <deal.II/grid/tria.h>'
p20905
aS'#include <deal.II/grid/grid_generator.h>'
p20906
aS'#include <deal.II/grid/grid_tools.h>'
p20907
aS'#include <deal.II/dofs/dof_handler.h>'
p20908
aS'#include <deal.II/dofs/dof_renumbering.h>'
p20909
aS'#include <deal.II/dofs/dof_tools.h>'
p20910
aS'#include <deal.II/fe/fe_q.h>'
p20911
aS'#include <deal.II/fe/fe_system.h>'
p20912
aS'#include <deal.II/fe/fe_values.h>'
p20913
aS'#include <deal.II/numerics/vector_tools.h>'
p20914
aS'#include <deal.II/numerics/data_out.h>'
p20915
aS'#include <deal.II/numerics/solution_transfer.h>'
p20916
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p20917
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p20918
aS'#include <deal.II/lac/trilinos_vector.h>'
p20919
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p20920
aS'#include <deal.II/lac/trilinos_precondition.h>'
p20921
aS'#include <iostream>'
p20922
aS'#include <fstream>'
p20923
aS'#include <memory>'
p20924
aS'namespace Step43'
p20925
ag9
aS'  using namespace dealii;'
p20926
aS'  template <int dim>'
p20927
aS'  class PressureBoundaryValues : public Function<dim>'
p20928
aS'  {'
p20929
aS'  public:'
p20930
aS'    PressureBoundaryValues()'
p20931
aS'      : Function<dim>(1)'
p20932
aS'    {}'
p20933
aS'    virtual double value(const Point<dim> & p,'
p20934
aS'                         const unsigned int component = 0) const override;'
p20935
aS'  };'
p20936
aS'  template <int dim>'
p20937
aS'  double'
p20938
aS'  PressureBoundaryValues<dim>::value(const Point<dim> &p,'
p20939
aS'                                     const unsigned int /*component*/) const'
p20940
aS'  {'
p20941
aS'    return 1 - p[0];'
p20942
aS'  }'
p20943
aS'  template <int dim>'
p20944
aS'  class SaturationBoundaryValues : public Function<dim>'
p20945
aS'  {'
p20946
aS'  public:'
p20947
aS'    SaturationBoundaryValues()'
p20948
aS'      : Function<dim>(1)'
p20949
aS'    {}'
p20950
aS'    virtual double value(const Point<dim> & p,'
p20951
aS'                         const unsigned int component = 0) const override;'
p20952
aS'  };'
p20953
aS'  template <int dim>'
p20954
aS'  double'
p20955
aS'  SaturationBoundaryValues<dim>::value(const Point<dim> &p,'
p20956
aS'                                       const unsigned int /*component*/) const'
p20957
aS'  {'
p20958
aS'    if (p[0] == 0)'
p20959
aS'      return 1;'
p20960
aS'    else'
p20961
aS'      return 0;'
p20962
aS'  }'
p20963
aS'  template <int dim>'
p20964
aS'  class SaturationInitialValues : public Function<dim>'
p20965
aS'  {'
p20966
aS'  public:'
p20967
aS'    SaturationInitialValues()'
p20968
aS'      : Function<dim>(1)'
p20969
aS'    {}'
p20970
aS'    virtual double value(const Point<dim> & p,'
p20971
aS'                         const unsigned int component = 0) const override;'
p20972
aS'    virtual void vector_value(const Point<dim> &p,'
p20973
aS'                              Vector<double> &  value) const override;'
p20974
aS'  };'
p20975
aS'  template <int dim>'
p20976
aS'  double'
p20977
aS'  SaturationInitialValues<dim>::value(const Point<dim> & /*p*/,'
p20978
aS'                                      const unsigned int /*component*/) const'
p20979
aS'  {'
p20980
aS'    return 0.2;'
p20981
aS'  }'
p20982
aS'  template <int dim>'
p20983
aS'  void SaturationInitialValues<dim>::vector_value(const Point<dim> &p,'
p20984
aS'                                                  Vector<double> &values) const'
p20985
aS'  {'
p20986
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p20987
aS'      values(c) = SaturationInitialValues<dim>::value(p, c);'
p20988
aS'  }'
p20989
aS'  namespace SingleCurvingCrack'
p20990
aS'  {'
p20991
aS'    template <int dim>'
p20992
aS'    class KInverse : public TensorFunction<2, dim>'
p20993
aS'    {'
p20994
aS'    public:'
p20995
aS'      KInverse()'
p20996
aS'        : TensorFunction<2, dim>()'
p20997
aS'      {}'
p20998
aS'      virtual void'
p20999
aS'      value_list(const std::vector<Point<dim>> &points,'
p21000
aS'                 std::vector<Tensor<2, dim>> &  values) const override;'
p21001
aS'    };'
p21002
aS'    template <int dim>'
p21003
aS'    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,'
p21004
aS'                                   std::vector<Tensor<2, dim>> &  values) const'
p21005
aS'    {'
p21006
aS'      Assert(points.size() == values.size(),'
p21007
aS'             ExcDimensionMismatch(points.size(), values.size()));'
p21008
aS'      for (unsigned int p = 0; p < points.size(); ++p)'
p21009
aS'        {'
p21010
aS'          values[p].clear();'
p21011
aS'          const double distance_to_flowline ='
p21012
aS'            std::fabs(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));'
p21013
aS'          const double permeability ='
p21014
aS'            std::max(std::exp(-(distance_to_flowline * distance_to_flowline) /'
p21015
aS'                     0.01);'
p21016
aS'          for (unsigned int d = 0; d < dim; ++d)'
p21017
aS'            values[p][d][d] = 1. / permeability;'
p21018
aS'        }'
p21019
aS'    }'
p21020
aS'  } // namespace SingleCurvingCrack'
p21021
aS'  namespace RandomMedium'
p21022
aS'  {'
p21023
aS'    template <int dim>'
p21024
aS'    class KInverse : public TensorFunction<2, dim>'
p21025
aS'    {'
p21026
aS'    public:'
p21027
aS'      KInverse()'
p21028
aS'        : TensorFunction<2, dim>()'
p21029
aS'      {}'
p21030
aS'      virtual void'
p21031
aS'      value_list(const std::vector<Point<dim>> &points,'
p21032
aS'                 std::vector<Tensor<2, dim>> &  values) const override;'
p21033
aS'    private:'
p21034
aS'      static std::vector<Point<dim>> centers;'
p21035
aS'    };'
p21036
aS'    template <int dim>'
p21037
aS'    std::vector<Point<dim>> KInverse<dim>::centers = []() {'
p21038
aS'      const unsigned int N ='
p21039
aS'      std::vector<Point<dim>> centers_list(N);'
p21040
aS'      for (unsigned int i = 0; i < N; ++i)'
p21041
aS'        for (unsigned int d = 0; d < dim; ++d)'
p21042
aS'          centers_list[i][d] = static_cast<double>(rand()) / RAND_MAX;'
p21043
aS'      return centers_list;'
p21044
aS'    }();'
p21045
aS'    template <int dim>'
p21046
aS'    void KInverse<dim>::value_list(const std::vector<Point<dim>> &points,'
p21047
aS'                                   std::vector<Tensor<2, dim>> &  values) const'
p21048
aS'    {'
p21049
aS'      AssertDimension(points.size(), values.size());'
p21050
aS'      for (unsigned int p = 0; p < points.size(); ++p)'
p21051
aS'        {'
p21052
aS'          values[p].clear();'
p21053
aS'          double permeability = 0;'
p21054
aS'          for (unsigned int i = 0; i < centers.size(); ++i)'
p21055
aS'            permeability +='
p21056
aS'              std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));'
p21057
aS'          const double normalized_permeability ='
p21058
aS'            std::min(std::max(permeability, 0.01), 4.);'
p21059
aS'          for (unsigned int d = 0; d < dim; ++d)'
p21060
aS'            values[p][d][d] = 1. / normalized_permeability;'
p21061
aS'        }'
p21062
aS'    }'
p21063
aS'  } // namespace RandomMedium'
p21064
aS'  double mobility_inverse(const double S, const double viscosity)'
p21065
aS'  {'
p21066
aS'    return 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));'
p21067
aS'  }'
p21068
aS'  double fractional_flow(const double S, const double viscosity)'
p21069
aS'  {'
p21070
aS'    Assert((S >= 0) && (S <= 1),'
p21071
aS'           ExcMessage("Saturation is outside its physically valid range."));'
p21072
aS'    return S * S / (S * S + viscosity * (1 - S) * (1 - S));'
p21073
aS'  }'
p21074
aS'  double fractional_flow_derivative(const double S, const double viscosity)'
p21075
aS'  {'
p21076
aS'    Assert((S >= 0) && (S <= 1),'
p21077
aS'           ExcMessage("Saturation is outside its physically valid range."));'
p21078
aS'    const double temp = (S * S + viscosity * (1 - S) * (1 - S));'
p21079
aS'    const double numerator ='
p21080
aS'      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));'
p21081
aS'    const double denominator = std::pow(temp, 2.0);'
p21082
aS'    const double F_prime = numerator / denominator;'
p21083
aS'    Assert(F_prime >= 0, ExcInternalError());'
p21084
aS'    return F_prime;'
p21085
aS'  }'
p21086
aS'  namespace LinearSolvers'
p21087
aS'  {'
p21088
aS'    template <class MatrixType, class PreconditionerType>'
p21089
aS'    class InverseMatrix : public Subscriptor'
p21090
aS'    {'
p21091
aS'    public:'
p21092
aS'      InverseMatrix(const MatrixType &        m,'
p21093
aS'                    const PreconditionerType &preconditioner);'
p21094
aS'      template <typename VectorType>'
p21095
aS'      void vmult(VectorType &dst, const VectorType &src) const;'
p21096
aS'    private:'
p21097
aS'      const SmartPointer<const MatrixType> matrix;'
p21098
aS'      const PreconditionerType &           preconditioner;'
p21099
aS'    };'
p21100
aS'    template <class MatrixType, class PreconditionerType>'
p21101
aS'    InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p21102
aS'      const MatrixType &        m,'
p21103
aS'      const PreconditionerType &preconditioner)'
p21104
aS'      : matrix(&m)'
p21105
aS'      , preconditioner(preconditioner)'
p21106
aS'    {}'
p21107
aS'    template <class MatrixType, class PreconditionerType>'
p21108
aS'    template <typename VectorType>'
p21109
aS'    void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p21110
aS'      VectorType &      dst,'
p21111
aS'      const VectorType &src) const'
p21112
aS'    {'
p21113
aS'      SolverControl        solver_control(src.size(), 1e-7 * src.l2_norm());'
p21114
aS'      SolverCG<VectorType> cg(solver_control);'
p21115
aS'      dst = 0;'
p21116
aS'      try'
p21117
aS'        {'
p21118
aS'          cg.solve(*matrix, dst, src, preconditioner);'
p21119
aS'        }'
p21120
aS'      catch (std::exception &e)'
p21121
aS'        {'
p21122
aS'          Assert(false, ExcMessage(e.what()));'
p21123
aS'        }'
p21124
aS'    }'
p21125
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p21126
aS'    class BlockSchurPreconditioner : public Subscriptor'
p21127
aS'    {'
p21128
aS'    public:'
p21129
aS'      BlockSchurPreconditioner('
p21130
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p21131
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p21132
aS'                            PreconditionerTypeMp> &Mpinv,'
p21133
aS'        const PreconditionerTypeA &                Apreconditioner);'
p21134
aS'      void vmult(TrilinosWrappers::MPI::BlockVector &      dst,'
p21135
aS'                 const TrilinosWrappers::MPI::BlockVector &src) const;'
p21136
aS'    private:'
p21137
aS'      const SmartPointer<const TrilinosWrappers::BlockSparseMatrix>'
p21138
aS'        darcy_matrix;'
p21139
aS'      const SmartPointer<const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p21140
aS'                                             PreconditionerTypeMp>>'
p21141
aS'                                 m_inverse;'
p21142
aS'      const PreconditionerTypeA &a_preconditioner;'
p21143
aS'      mutable TrilinosWrappers::MPI::Vector tmp;'
p21144
aS'    };'
p21145
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p21146
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::'
p21147
aS'      BlockSchurPreconditioner('
p21148
aS'        const TrilinosWrappers::BlockSparseMatrix &S,'
p21149
aS'        const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p21150
aS'                            PreconditionerTypeMp> &Mpinv,'
p21151
aS'        const PreconditionerTypeA &                Apreconditioner)'
p21152
aS'      : darcy_matrix(&S)'
p21153
aS'      , m_inverse(&Mpinv)'
p21154
aS'      , a_preconditioner(Apreconditioner)'
p21155
aS'      , tmp(complete_index_set(darcy_matrix->block(1, 1).m()))'
p21156
aS'    {}'
p21157
aS'    template <class PreconditionerTypeA, class PreconditionerTypeMp>'
p21158
aS'    void'
p21159
aS'    BlockSchurPreconditioner<PreconditionerTypeA, PreconditionerTypeMp>::vmult('
p21160
aS'      TrilinosWrappers::MPI::BlockVector &      dst,'
p21161
aS'      const TrilinosWrappers::MPI::BlockVector &src) const'
p21162
aS'    {'
p21163
aS'      a_preconditioner.vmult(dst.block(0), src.block(0));'
p21164
aS'      darcy_matrix->block(1, 0).residual(tmp, dst.block(0), src.block(1));'
p21165
aS'      tmp *= -1;'
p21166
aS'      m_inverse->vmult(dst.block(1), tmp);'
p21167
aS'    }'
p21168
aS'  } // namespace LinearSolvers'
p21169
aS'  template <int dim>'
p21170
aS'  class TwoPhaseFlowProblem'
p21171
aS'  {'
p21172
aS'  public:'
p21173
aS'    TwoPhaseFlowProblem(const unsigned int degree);'
p21174
aS'    void run();'
p21175
aS'  private:'
p21176
aS'    void setup_dofs();'
p21177
aS'    void assemble_darcy_preconditioner();'
p21178
aS'    void build_darcy_preconditioner();'
p21179
aS'    void assemble_darcy_system();'
p21180
aS'    void assemble_saturation_system();'
p21181
aS'    void assemble_saturation_matrix();'
p21182
aS'    void assemble_saturation_rhs();'
p21183
aS'    void assemble_saturation_rhs_cell_term('
p21184
aS'      const FEValues<dim> &                       saturation_fe_values,'
p21185
aS'      const FEValues<dim> &                       darcy_fe_values,'
p21186
aS'      const double                                global_max_u_F_prime,'
p21187
aS'      const double                                global_S_variation,'
p21188
aS'      const std::vector<types::global_dof_index> &local_dof_indices);'
p21189
aS'    void assemble_saturation_rhs_boundary_term('
p21190
aS'      const FEFaceValues<dim> &                   saturation_fe_face_values,'
p21191
aS'      const FEFaceValues<dim> &                   darcy_fe_face_values,'
p21192
aS'      const std::vector<types::global_dof_index> &local_dof_indices);'
p21193
aS'    void solve();'
p21194
aS'    void refine_mesh(const unsigned int min_grid_level,'
p21195
aS'                     const unsigned int max_grid_level);'
p21196
aS'    void output_results() const;'
p21197
aS'    double                    get_max_u_F_prime() const;'
p21198
aS'    std::pair<double, double> get_extrapolated_saturation_range() const;'
p21199
aS'    bool   determine_whether_to_solve_for_pressure_and_velocity() const;'
p21200
aS'    void   project_back_saturation();'
p21201
aS'    double compute_viscosity('
p21202
aS'      const std::vector<double> &        old_saturation,'
p21203
aS'      const std::vector<double> &        old_old_saturation,'
p21204
aS'      const std::vector<Tensor<1, dim>> &old_saturation_grads,'
p21205
aS'      const std::vector<Tensor<1, dim>> &old_old_saturation_grads,'
p21206
aS'      const std::vector<Vector<double>> &present_darcy_values,'
p21207
aS'      const double                       global_max_u_F_prime,'
p21208
aS'      const double                       global_S_variation,'
p21209
aS'      const double                       cell_diameter) const;'
p21210
aS'    Triangulation<dim> triangulation;'
p21211
aS'    double             global_Omega_diameter;'
p21212
aS'    const unsigned int degree;'
p21213
aS'    const unsigned int        darcy_degree;'
p21214
aS'    FESystem<dim>             darcy_fe;'
p21215
aS'    DoFHandler<dim>           darcy_dof_handler;'
p21216
aS'    AffineConstraints<double> darcy_constraints;'
p21217
aS'    AffineConstraints<double> darcy_preconditioner_constraints;'
p21218
aS'    TrilinosWrappers::BlockSparseMatrix darcy_matrix;'
p21219
aS'    TrilinosWrappers::BlockSparseMatrix darcy_preconditioner_matrix;'
p21220
aS'    TrilinosWrappers::MPI::BlockVector darcy_solution;'
p21221
aS'    TrilinosWrappers::MPI::BlockVector darcy_rhs;'
p21222
aS'    TrilinosWrappers::MPI::BlockVector last_computed_darcy_solution;'
p21223
aS'    TrilinosWrappers::MPI::BlockVector second_last_computed_darcy_solution;'
p21224
aS'    const unsigned int        saturation_degree;'
p21225
aS'    FE_Q<dim>                 saturation_fe;'
p21226
aS'    DoFHandler<dim>           saturation_dof_handler;'
p21227
aS'    AffineConstraints<double> saturation_constraints;'
p21228
aS'    TrilinosWrappers::SparseMatrix saturation_matrix;'
p21229
aS'    TrilinosWrappers::MPI::Vector saturation_solution;'
p21230
aS'    TrilinosWrappers::MPI::Vector old_saturation_solution;'
p21231
aS'    TrilinosWrappers::MPI::Vector old_old_saturation_solution;'
p21232
aS'    TrilinosWrappers::MPI::Vector saturation_rhs;'
p21233
aS'    TrilinosWrappers::MPI::Vector'
p21234
aS'      saturation_matching_last_computed_darcy_solution;'
p21235
aS'    const double saturation_refinement_threshold;'
p21236
aS'    double       time;'
p21237
aS'    const double end_time;'
p21238
aS'    double current_macro_time_step;'
p21239
aS'    double old_macro_time_step;'
p21240
aS'    double       time_step;'
p21241
aS'    double       old_time_step;'
p21242
aS'    unsigned int timestep_number;'
p21243
aS'    const double viscosity;'
p21244
aS'    const double porosity;'
p21245
aS'    const double AOS_threshold;'
p21246
aS'    std::shared_ptr<TrilinosWrappers::PreconditionIC> Amg_preconditioner;'
p21247
aS'    std::shared_ptr<TrilinosWrappers::PreconditionIC> Mp_preconditioner;'
p21248
aS'    bool rebuild_saturation_matrix;'
p21249
aS'    const RandomMedium::KInverse<dim> k_inverse;'
p21250
aS'  };'
p21251
aS'  template <int dim>'
p21252
aS'  TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem(const unsigned int degree)'
p21253
aS'    : triangulation(Triangulation<dim>::maximum_smoothing)'
p21254
aS'    , global_Omega_diameter(std::numeric_limits<double>::quiet_NaN())'
p21255
aS'    , degree(degree)'
p21256
aS'    , darcy_degree(degree)'
p21257
aS'    , darcy_fe(FE_Q<dim>(darcy_degree + 1), dim, FE_Q<dim>(darcy_degree), 1)'
p21258
aS'    , darcy_dof_handler(triangulation)'
p21259
aS'    ,'
p21260
aS'    saturation_degree(degree + 1)'
p21261
aS'    , saturation_fe(saturation_degree)'
p21262
aS'    , saturation_dof_handler(triangulation)'
p21263
aS'    ,'
p21264
aS'    saturation_refinement_threshold(0.5)'
p21265
aS'    ,'
p21266
aS'    time(0)'
p21267
aS'    , end_time(10)'
p21268
aS'    ,'
p21269
aS'    current_macro_time_step(0)'
p21270
aS'    , old_macro_time_step(0)'
p21271
aS'    ,'
p21272
aS'    time_step(0)'
p21273
aS'    , old_time_step(0)'
p21274
aS'    , timestep_number(0)'
p21275
aS'    , viscosity(0.2)'
p21276
aS'    , porosity(1.0)'
p21277
aS'    , AOS_threshold(3.0)'
p21278
aS'    ,'
p21279
aS'    rebuild_saturation_matrix(true)'
p21280
aS'  {}'
p21281
aS'  template <int dim>'
p21282
aS'  void TwoPhaseFlowProblem<dim>::setup_dofs()'
p21283
aS'  {'
p21284
aS'    std::vector<unsigned int> darcy_block_component(dim + 1, 0);'
p21285
aS'    darcy_block_component[dim] = 1;'
p21286
aS'    {'
p21287
aS'      darcy_dof_handler.distribute_dofs(darcy_fe);'
p21288
aS'      DoFRenumbering::Cuthill_McKee(darcy_dof_handler);'
p21289
aS'      DoFRenumbering::component_wise(darcy_dof_handler, darcy_block_component);'
p21290
aS'      darcy_constraints.clear();'
p21291
aS'      DoFTools::make_hanging_node_constraints(darcy_dof_handler,'
p21292
aS'                                              darcy_constraints);'
p21293
aS'      darcy_constraints.close();'
p21294
aS'    }'
p21295
aS'    {'
p21296
aS'      saturation_dof_handler.distribute_dofs(saturation_fe);'
p21297
aS'      saturation_constraints.clear();'
p21298
aS'      DoFTools::make_hanging_node_constraints(saturation_dof_handler,'
p21299
aS'                                              saturation_constraints);'
p21300
aS'      saturation_constraints.close();'
p21301
aS'    }'
p21302
aS'    {'
p21303
aS'      darcy_preconditioner_constraints.clear();'
p21304
aS'      FEValuesExtractors::Scalar pressure(dim);'
p21305
aS'      DoFTools::make_hanging_node_constraints(darcy_dof_handler,'
p21306
aS'                                              darcy_preconditioner_constraints);'
p21307
aS'      DoFTools::make_zero_boundary_constraints(darcy_dof_handler,'
p21308
aS'                                               darcy_preconditioner_constraints,'
p21309
aS'                                               darcy_fe.component_mask('
p21310
aS'                                                 pressure));'
p21311
aS'      darcy_preconditioner_constraints.close();'
p21312
aS'    }'
p21313
aS'    const std::vector<types::global_dof_index> darcy_dofs_per_block ='
p21314
aS'      DoFTools::count_dofs_per_fe_block(darcy_dof_handler,'
p21315
aS'                                        darcy_block_component);'
p21316
aS'    const unsigned int n_u = darcy_dofs_per_block[0],'
p21317
aS'                       n_p = darcy_dofs_per_block[1],'
p21318
aS'                       n_s = saturation_dof_handler.n_dofs();'
p21319
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p21320
aS'              << " (on " << triangulation.n_levels() << " levels)" << std::endl'
p21321
aS'              << "Number of degrees of freedom: " << n_u + n_p + n_s << " ("'
p21322
aS"              << n_u << '+' << n_p << '+' << n_s << ')' << std::endl"
p21323
aS'              << std::endl;'
p21324
aS'    {'
p21325
aS'      darcy_matrix.clear();'
p21326
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p21327
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p21328
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p21329
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p21330
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p21331
aS'      dsp.collect_sizes();'
p21332
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p21333
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p21334
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p21335
aS'          if (!((c == dim) && (d == dim)))'
p21336
aS'            coupling[c][d] = DoFTools::always;'
p21337
aS'          else'
p21338
aS'            coupling[c][d] = DoFTools::none;'
p21339
aS'      DoFTools::make_sparsity_pattern('
p21340
aS'        darcy_dof_handler, coupling, dsp, darcy_constraints, false);'
p21341
aS'      darcy_matrix.reinit(dsp);'
p21342
aS'    }'
p21343
aS'    {'
p21344
aS'      Amg_preconditioner.reset();'
p21345
aS'      Mp_preconditioner.reset();'
p21346
aS'      darcy_preconditioner_matrix.clear();'
p21347
aS'      BlockDynamicSparsityPattern dsp(2, 2);'
p21348
aS'      dsp.block(0, 0).reinit(n_u, n_u);'
p21349
aS'      dsp.block(0, 1).reinit(n_u, n_p);'
p21350
aS'      dsp.block(1, 0).reinit(n_p, n_u);'
p21351
aS'      dsp.block(1, 1).reinit(n_p, n_p);'
p21352
aS'      dsp.collect_sizes();'
p21353
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p21354
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p21355
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p21356
aS'          if (c == d)'
p21357
aS'            coupling[c][d] = DoFTools::always;'
p21358
aS'          else'
p21359
aS'            coupling[c][d] = DoFTools::none;'
p21360
aS'      DoFTools::make_sparsity_pattern('
p21361
aS'        darcy_dof_handler, coupling, dsp, darcy_constraints, false);'
p21362
aS'      darcy_preconditioner_matrix.reinit(dsp);'
p21363
aS'    }'
p21364
aS'    {'
p21365
aS'      saturation_matrix.clear();'
p21366
aS'      DynamicSparsityPattern dsp(n_s, n_s);'
p21367
aS'      DoFTools::make_sparsity_pattern(saturation_dof_handler,'
p21368
aS'                                      dsp,'
p21369
aS'                                      saturation_constraints,'
p21370
aS'                                      false);'
p21371
aS'      saturation_matrix.reinit(dsp);'
p21372
aS'    }'
p21373
aS'    std::vector<IndexSet> darcy_partitioning(2);'
p21374
aS'    darcy_partitioning[0] = complete_index_set(n_u);'
p21375
aS'    darcy_partitioning[1] = complete_index_set(n_p);'
p21376
aS'    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);'
p21377
aS'    darcy_solution.collect_sizes();'
p21378
aS'    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);'
p21379
aS'    last_computed_darcy_solution.collect_sizes();'
p21380
aS'    second_last_computed_darcy_solution.reinit(darcy_partitioning,'
p21381
aS'                                               MPI_COMM_WORLD);'
p21382
aS'    second_last_computed_darcy_solution.collect_sizes();'
p21383
aS'    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);'
p21384
aS'    darcy_rhs.collect_sizes();'
p21385
aS'    IndexSet saturation_partitioning = complete_index_set(n_s);'
p21386
aS'    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p21387
aS'    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p21388
aS'    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p21389
aS'    saturation_matching_last_computed_darcy_solution.reinit('
p21390
aS'      saturation_partitioning, MPI_COMM_WORLD);'
p21391
aS'    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);'
p21392
aS'  }'
p21393
aS'  template <int dim>'
p21394
aS'  void TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner()'
p21395
aS'  {'
p21396
aS'    std::cout << "   Rebuilding darcy preconditioner..." << std::endl;'
p21397
aS'    darcy_preconditioner_matrix = 0;'
p21398
aS'    const QGauss<dim> quadrature_formula(darcy_degree + 2);'
p21399
aS'    FEValues<dim>     darcy_fe_values(darcy_fe,'
p21400
aS'                                  quadrature_formula,'
p21401
aS'                                  update_JxW_values | update_values |'
p21402
aS'                                    update_gradients |'
p21403
aS'                                    update_quadrature_points);'
p21404
aS'    FEValues<dim>     saturation_fe_values(saturation_fe,'
p21405
aS'                                       quadrature_formula,'
p21406
aS'                                       update_values);'
p21407
aS'    const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();'
p21408
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p21409
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p21410
aS'    std::vector<double> old_saturation_values(n_q_points);'
p21411
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p21412
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21413
aS'    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);'
p21414
aS'    std::vector<Tensor<1, dim>> grad_phi_p(dofs_per_cell);'
p21415
aS'    const FEValuesExtractors::Vector velocities(0);'
p21416
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p21417
aS'    auto       cell            = darcy_dof_handler.begin_active();'
p21418
aS'    const auto endc            = darcy_dof_handler.end();'
p21419
aS'    auto       saturation_cell = saturation_dof_handler.begin_active();'
p21420
aS'    for (; cell != endc; ++cell, ++saturation_cell)'
p21421
aS'      {'
p21422
aS'        darcy_fe_values.reinit(cell);'
p21423
aS'        saturation_fe_values.reinit(saturation_cell);'
p21424
aS'        local_matrix = 0;'
p21425
aS'        saturation_fe_values.get_function_values(old_saturation_solution,'
p21426
aS'                                                 old_saturation_values);'
p21427
aS'        k_inverse.value_list(darcy_fe_values.get_quadrature_points(),'
p21428
aS'                             k_inverse_values);'
p21429
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p21430
aS'          {'
p21431
aS'            const double old_s = old_saturation_values[q];'
p21432
aS'            const double inverse_mobility = mobility_inverse(old_s, viscosity);'
p21433
aS'            const double mobility         = 1.0 / inverse_mobility;'
p21434
aS'            const Tensor<2, dim> permeability = invert(k_inverse_values[q]);'
p21435
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p21436
aS'              {'
p21437
aS'                phi_u[k]      = darcy_fe_values[velocities].value(k, q);'
p21438
aS'                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);'
p21439
aS'              }'
p21440
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21441
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p21442
aS'                {'
p21443
aS'                  local_matrix(i, j) +='
p21444
aS'                       phi_u[j] +'
p21445
aS'                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *'
p21446
aS'                    darcy_fe_values.JxW(q);'
p21447
aS'                }'
p21448
aS'          }'
p21449
aS'        cell->get_dof_indices(local_dof_indices);'
p21450
aS'        darcy_preconditioner_constraints.distribute_local_to_global('
p21451
aS'          local_matrix, local_dof_indices, darcy_preconditioner_matrix);'
p21452
aS'      }'
p21453
aS'  }'
p21454
aS'  template <int dim>'
p21455
aS'  void TwoPhaseFlowProblem<dim>::build_darcy_preconditioner()'
p21456
aS'  {'
p21457
aS'    assemble_darcy_preconditioner();'
p21458
aS'    Amg_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>();'
p21459
aS'    Amg_preconditioner->initialize(darcy_preconditioner_matrix.block(0, 0));'
p21460
aS'    Mp_preconditioner = std::make_shared<TrilinosWrappers::PreconditionIC>();'
p21461
aS'    Mp_preconditioner->initialize(darcy_preconditioner_matrix.block(1, 1));'
p21462
aS'  }'
p21463
aS'  template <int dim>'
p21464
aS'  void TwoPhaseFlowProblem<dim>::assemble_darcy_system()'
p21465
aS'  {'
p21466
aS'    darcy_matrix = 0;'
p21467
aS'    darcy_rhs    = 0;'
p21468
aS'    QGauss<dim>     quadrature_formula(darcy_degree + 2);'
p21469
aS'    QGauss<dim - 1> face_quadrature_formula(darcy_degree + 2);'
p21470
aS'    FEValues<dim> darcy_fe_values(darcy_fe,'
p21471
aS'                                  quadrature_formula,'
p21472
aS'                                  update_values | update_gradients |'
p21473
aS'                                    update_quadrature_points |'
p21474
aS'                                    update_JxW_values);'
p21475
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p21476
aS'                                       quadrature_formula,'
p21477
aS'                                       update_values);'
p21478
aS'    FEFaceValues<dim> darcy_fe_face_values(darcy_fe,'
p21479
aS'                                           face_quadrature_formula,'
p21480
aS'                                           update_values |'
p21481
aS'                                             update_normal_vectors |'
p21482
aS'                                             update_quadrature_points |'
p21483
aS'                                             update_JxW_values);'
p21484
aS'    const unsigned int dofs_per_cell = darcy_fe.n_dofs_per_cell();'
p21485
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p21486
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p21487
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p21488
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p21489
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21490
aS'    const Functions::ZeroFunction<dim> pressure_right_hand_side;'
p21491
aS'    const PressureBoundaryValues<dim>  pressure_boundary_values;'
p21492
aS'    std::vector<double>         pressure_rhs_values(n_q_points);'
p21493
aS'    std::vector<double>         boundary_values(n_face_q_points);'
p21494
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p21495
aS'    std::vector<double> old_saturation_values(n_q_points);'
p21496
aS'    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);'
p21497
aS'    std::vector<double>         div_phi_u(dofs_per_cell);'
p21498
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p21499
aS'    const FEValuesExtractors::Vector velocities(0);'
p21500
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p21501
aS'    auto       cell            = darcy_dof_handler.begin_active();'
p21502
aS'    const auto endc            = darcy_dof_handler.end();'
p21503
aS'    auto       saturation_cell = saturation_dof_handler.begin_active();'
p21504
aS'    for (; cell != endc; ++cell, ++saturation_cell)'
p21505
aS'      {'
p21506
aS'        darcy_fe_values.reinit(cell);'
p21507
aS'        saturation_fe_values.reinit(saturation_cell);'
p21508
aS'        local_matrix = 0;'
p21509
aS'        local_rhs    = 0;'
p21510
aS'        saturation_fe_values.get_function_values(old_saturation_solution,'
p21511
aS'                                                 old_saturation_values);'
p21512
aS'        pressure_right_hand_side.value_list('
p21513
aS'          darcy_fe_values.get_quadrature_points(), pressure_rhs_values);'
p21514
aS'        k_inverse.value_list(darcy_fe_values.get_quadrature_points(),'
p21515
aS'                             k_inverse_values);'
p21516
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p21517
aS'          {'
p21518
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p21519
aS'              {'
p21520
aS'                phi_u[k]     = darcy_fe_values[velocities].value(k, q);'
p21521
aS'                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);'
p21522
aS'                phi_p[k]     = darcy_fe_values[pressure].value(k, q);'
p21523
aS'              }'
p21524
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21525
aS'              {'
p21526
aS'                const double old_s = old_saturation_values[q];'
p21527
aS'                for (unsigned int j = 0; j <= i; ++j)'
p21528
aS'                  {'
p21529
aS'                    local_matrix(i, j) +='
p21530
aS'                         mobility_inverse(old_s, viscosity) * phi_u[j] -'
p21531
aS'                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p21532
aS'                      darcy_fe_values.JxW(q);'
p21533
aS'                  }'
p21534
aS'                local_rhs(i) +='
p21535
aS'              }'
p21536
aS'          }'
p21537
aS'        for (const auto &face : cell->face_iterators())'
p21538
aS'          if (face->at_boundary())'
p21539
aS'            {'
p21540
aS'              darcy_fe_face_values.reinit(cell, face);'
p21541
aS'              pressure_boundary_values.value_list('
p21542
aS'                darcy_fe_face_values.get_quadrature_points(), boundary_values);'
p21543
aS'              for (unsigned int q = 0; q < n_face_q_points; ++q)'
p21544
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21545
aS'                  {'
p21546
aS'                    const Tensor<1, dim> phi_i_u ='
p21547
aS'                      darcy_fe_face_values[velocities].value(i, q);'
p21548
aS'                    local_rhs(i) +='
p21549
aS'                      -(phi_i_u * darcy_fe_face_values.normal_vector(q) *'
p21550
aS'                        boundary_values[q] * darcy_fe_face_values.JxW(q));'
p21551
aS'                  }'
p21552
aS'            }'
p21553
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21554
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p21555
aS'            local_matrix(i, j) = local_matrix(j, i);'
p21556
aS'        cell->get_dof_indices(local_dof_indices);'
p21557
aS'        darcy_constraints.distribute_local_to_global('
p21558
aS'          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);'
p21559
aS'      }'
p21560
aS'  }'
p21561
aS'  template <int dim>'
p21562
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_system()'
p21563
aS'  {'
p21564
aS'    if (rebuild_saturation_matrix == true)'
p21565
aS'      {'
p21566
aS'        saturation_matrix = 0;'
p21567
aS'        assemble_saturation_matrix();'
p21568
aS'      }'
p21569
aS'    saturation_rhs = 0;'
p21570
aS'    assemble_saturation_rhs();'
p21571
aS'  }'
p21572
aS'  template <int dim>'
p21573
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_matrix()'
p21574
aS'  {'
p21575
aS'    QGauss<dim> quadrature_formula(saturation_degree + 2);'
p21576
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p21577
aS'                                       quadrature_formula,'
p21578
aS'                                       update_values | update_JxW_values);'
p21579
aS'    const unsigned int dofs_per_cell = saturation_fe.n_dofs_per_cell();'
p21580
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p21581
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p21582
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p21583
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21584
aS'    for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p21585
aS'      {'
p21586
aS'        saturation_fe_values.reinit(cell);'
p21587
aS'        local_matrix = 0;'
p21588
aS'        local_rhs    = 0;'
p21589
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p21590
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21591
aS'            {'
p21592
aS'              const double phi_i_s = saturation_fe_values.shape_value(i, q);'
p21593
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p21594
aS'                {'
p21595
aS'                  const double phi_j_s = saturation_fe_values.shape_value(j, q);'
p21596
aS'                  local_matrix(i, j) +='
p21597
aS'                    porosity * phi_i_s * phi_j_s * saturation_fe_values.JxW(q);'
p21598
aS'                }'
p21599
aS'            }'
p21600
aS'        cell->get_dof_indices(local_dof_indices);'
p21601
aS'        saturation_constraints.distribute_local_to_global(local_matrix,'
p21602
aS'                                                          local_dof_indices,'
p21603
aS'                                                          saturation_matrix);'
p21604
aS'      }'
p21605
aS'  }'
p21606
aS'  template <int dim>'
p21607
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs()'
p21608
aS'  {'
p21609
aS'    QGauss<dim>     quadrature_formula(saturation_degree + 2);'
p21610
aS'    QGauss<dim - 1> face_quadrature_formula(saturation_degree + 2);'
p21611
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p21612
aS'                                       quadrature_formula,'
p21613
aS'                                       update_values | update_gradients |'
p21614
aS'                                         update_quadrature_points |'
p21615
aS'                                         update_JxW_values);'
p21616
aS'    FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);'
p21617
aS'    FEFaceValues<dim> saturation_fe_face_values(saturation_fe,'
p21618
aS'                                                face_quadrature_formula,'
p21619
aS'                                                update_values |'
p21620
aS'                                                  update_normal_vectors |'
p21621
aS'                                                  update_quadrature_points |'
p21622
aS'                                                  update_JxW_values);'
p21623
aS'    FEFaceValues<dim> darcy_fe_face_values(darcy_fe,'
p21624
aS'                                           face_quadrature_formula,'
p21625
aS'                                           update_values);'
p21626
aS'    FEFaceValues<dim> saturation_fe_face_values_neighbor('
p21627
aS'      saturation_fe, face_quadrature_formula, update_values);'
p21628
aS'    const unsigned int dofs_per_cell ='
p21629
aS'      saturation_dof_handler.get_fe().n_dofs_per_cell();'
p21630
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p21631
aS'    const double                    global_max_u_F_prime = get_max_u_F_prime();'
p21632
aS'    const std::pair<double, double> global_S_range ='
p21633
aS'      get_extrapolated_saturation_range();'
p21634
aS'    const double global_S_variation ='
p21635
aS'      global_S_range.second - global_S_range.first;'
p21636
aS'    auto       cell       = saturation_dof_handler.begin_active();'
p21637
aS'    const auto endc       = saturation_dof_handler.end();'
p21638
aS'    auto       darcy_cell = darcy_dof_handler.begin_active();'
p21639
aS'    for (; cell != endc; ++cell, ++darcy_cell)'
p21640
aS'      {'
p21641
aS'        saturation_fe_values.reinit(cell);'
p21642
aS'        darcy_fe_values.reinit(darcy_cell);'
p21643
aS'        cell->get_dof_indices(local_dof_indices);'
p21644
aS'        assemble_saturation_rhs_cell_term(saturation_fe_values,'
p21645
aS'                                          darcy_fe_values,'
p21646
aS'                                          global_max_u_F_prime,'
p21647
aS'                                          global_S_variation,'
p21648
aS'                                          local_dof_indices);'
p21649
aS'        for (const auto &face : cell->face_iterators())'
p21650
aS'          if (face->at_boundary())'
p21651
aS'            {'
p21652
aS'              darcy_fe_face_values.reinit(darcy_cell, face);'
p21653
aS'              saturation_fe_face_values.reinit(cell, face);'
p21654
aS'              assemble_saturation_rhs_boundary_term(saturation_fe_face_values,'
p21655
aS'                                                    darcy_fe_face_values,'
p21656
aS'                                                    local_dof_indices);'
p21657
aS'            }'
p21658
aS'      }'
p21659
aS'  }'
p21660
aS'  template <int dim>'
p21661
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term('
p21662
aS'    const FEValues<dim> &                       saturation_fe_values,'
p21663
aS'    const FEValues<dim> &                       darcy_fe_values,'
p21664
aS'    const double                                global_max_u_F_prime,'
p21665
aS'    const double                                global_S_variation,'
p21666
aS'    const std::vector<types::global_dof_index> &local_dof_indices)'
p21667
aS'  {'
p21668
aS'    const unsigned int dofs_per_cell = saturation_fe_values.dofs_per_cell;'
p21669
aS'    const unsigned int n_q_points    = saturation_fe_values.n_quadrature_points;'
p21670
aS'    std::vector<double>         old_saturation_solution_values(n_q_points);'
p21671
aS'    std::vector<double>         old_old_saturation_solution_values(n_q_points);'
p21672
aS'    std::vector<Tensor<1, dim>> old_grad_saturation_solution_values(n_q_points);'
p21673
aS'    std::vector<Tensor<1, dim>> old_old_grad_saturation_solution_values('
p21674
aS'      n_q_points);'
p21675
aS'    std::vector<Vector<double>> present_darcy_solution_values('
p21676
aS'      n_q_points, Vector<double>(dim + 1));'
p21677
aS'    saturation_fe_values.get_function_values(old_saturation_solution,'
p21678
aS'                                             old_saturation_solution_values);'
p21679
aS'    saturation_fe_values.get_function_values('
p21680
aS'      old_old_saturation_solution, old_old_saturation_solution_values);'
p21681
aS'    saturation_fe_values.get_function_gradients('
p21682
aS'      old_saturation_solution, old_grad_saturation_solution_values);'
p21683
aS'    saturation_fe_values.get_function_gradients('
p21684
aS'      old_old_saturation_solution, old_old_grad_saturation_solution_values);'
p21685
aS'    darcy_fe_values.get_function_values(darcy_solution,'
p21686
aS'                                        present_darcy_solution_values);'
p21687
aS'    const double nu ='
p21688
aS'      compute_viscosity(old_saturation_solution_values,'
p21689
aS'                        old_old_saturation_solution_values,'
p21690
aS'                        old_grad_saturation_solution_values,'
p21691
aS'                        old_old_grad_saturation_solution_values,'
p21692
aS'                        present_darcy_solution_values,'
p21693
aS'                        global_max_u_F_prime,'
p21694
aS'                        global_S_variation,'
p21695
aS'                        saturation_fe_values.get_cell()->diameter());'
p21696
aS'    Vector<double> local_rhs(dofs_per_cell);'
p21697
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p21698
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21699
aS'        {'
p21700
aS'          const double   old_s = old_saturation_solution_values[q];'
p21701
aS'          Tensor<1, dim> present_u;'
p21702
aS'          for (unsigned int d = 0; d < dim; ++d)'
p21703
aS'            present_u[d] = present_darcy_solution_values[q](d);'
p21704
aS'          const double         phi_i_s = saturation_fe_values.shape_value(i, q);'
p21705
aS'          const Tensor<1, dim> grad_phi_i_s ='
p21706
aS'            saturation_fe_values.shape_grad(i, q);'
p21707
aS'          local_rhs(i) +='
p21708
aS'               grad_phi_i_s -'
p21709
aS'             time_step * nu * old_grad_saturation_solution_values[q] *'
p21710
aS'               grad_phi_i_s +'
p21711
aS'             porosity * old_s * phi_i_s) *'
p21712
aS'            saturation_fe_values.JxW(q);'
p21713
aS'        }'
p21714
aS'    saturation_constraints.distribute_local_to_global(local_rhs,'
p21715
aS'                                                      local_dof_indices,'
p21716
aS'                                                      saturation_rhs);'
p21717
aS'  }'
p21718
aS'  template <int dim>'
p21719
aS'  void TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term('
p21720
aS'    const FEFaceValues<dim> &                   saturation_fe_face_values,'
p21721
aS'    const FEFaceValues<dim> &                   darcy_fe_face_values,'
p21722
aS'    const std::vector<types::global_dof_index> &local_dof_indices)'
p21723
aS'  {'
p21724
aS'    const unsigned int dofs_per_cell = saturation_fe_face_values.dofs_per_cell;'
p21725
aS'    const unsigned int n_face_q_points ='
p21726
aS'      saturation_fe_face_values.n_quadrature_points;'
p21727
aS'    Vector<double> local_rhs(dofs_per_cell);'
p21728
aS'    std::vector<double> old_saturation_solution_values_face(n_face_q_points);'
p21729
aS'    std::vector<Vector<double>> present_darcy_solution_values_face('
p21730
aS'      n_face_q_points, Vector<double>(dim + 1));'
p21731
aS'    std::vector<double> neighbor_saturation(n_face_q_points);'
p21732
aS'    saturation_fe_face_values.get_function_values('
p21733
aS'      old_saturation_solution, old_saturation_solution_values_face);'
p21734
aS'    darcy_fe_face_values.get_function_values('
p21735
aS'      darcy_solution, present_darcy_solution_values_face);'
p21736
aS'    SaturationBoundaryValues<dim> saturation_boundary_values;'
p21737
aS'    saturation_boundary_values.value_list('
p21738
aS'      saturation_fe_face_values.get_quadrature_points(), neighbor_saturation);'
p21739
aS'    for (unsigned int q = 0; q < n_face_q_points; ++q)'
p21740
aS'      {'
p21741
aS'        Tensor<1, dim> present_u_face;'
p21742
aS'        for (unsigned int d = 0; d < dim; ++d)'
p21743
aS'          present_u_face[d] = present_darcy_solution_values_face[q](d);'
p21744
aS'        const double normal_flux ='
p21745
aS'          present_u_face * saturation_fe_face_values.normal_vector(q);'
p21746
aS'        const bool is_outflow_q_point = (normal_flux >= 0);'
p21747
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p21748
aS'          local_rhs(i) -='
p21749
aS'            time_step * normal_flux *'
p21750
aS'            fractional_flow((is_outflow_q_point == true ?'
p21751
aS'                               old_saturation_solution_values_face[q] :'
p21752
aS'                               neighbor_saturation[q]),'
p21753
aS'                            viscosity) *'
p21754
aS'            saturation_fe_face_values.shape_value(i, q) *'
p21755
aS'            saturation_fe_face_values.JxW(q);'
p21756
aS'      }'
p21757
aS'    saturation_constraints.distribute_local_to_global(local_rhs,'
p21758
aS'                                                      local_dof_indices,'
p21759
aS'                                                      saturation_rhs);'
p21760
aS'  }'
p21761
aS'  template <int dim>'
p21762
aS'  void TwoPhaseFlowProblem<dim>::solve()'
p21763
aS'  {'
p21764
aS'    const bool solve_for_pressure_and_velocity ='
p21765
aS'      determine_whether_to_solve_for_pressure_and_velocity();'
p21766
aS'    if (solve_for_pressure_and_velocity == true)'
p21767
aS'      {'
p21768
aS'        std::cout << "   Solving Darcy (pressure-velocity) system..."'
p21769
aS'                  << std::endl;'
p21770
aS'        assemble_darcy_system();'
p21771
aS'        build_darcy_preconditioner();'
p21772
aS'        {'
p21773
aS'          const LinearSolvers::InverseMatrix<TrilinosWrappers::SparseMatrix,'
p21774
aS'                                             TrilinosWrappers::PreconditionIC>'
p21775
aS'            mp_inverse(darcy_preconditioner_matrix.block(1, 1),'
p21776
aS'          const LinearSolvers::BlockSchurPreconditioner<'
p21777
aS'            TrilinosWrappers::PreconditionIC,'
p21778
aS'            TrilinosWrappers::PreconditionIC>'
p21779
aS'            preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);'
p21780
aS'          SolverControl solver_control(darcy_matrix.m(),'
p21781
aS'                                       1e-16 * darcy_rhs.l2_norm());'
p21782
aS'          SolverGMRES<TrilinosWrappers::MPI::BlockVector> gmres('
p21783
aS'            solver_control,'
p21784
aS'            SolverGMRES<TrilinosWrappers::MPI::BlockVector>::AdditionalData('
p21785
aS'              100));'
p21786
aS'          for (unsigned int i = 0; i < darcy_solution.size(); ++i)'
p21787
aS'            if (darcy_constraints.is_constrained(i))'
p21788
aS'              darcy_solution(i) = 0;'
p21789
aS'          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);'
p21790
aS'          darcy_constraints.distribute(darcy_solution);'
p21791
aS'          std::cout << "        ..." << solver_control.last_step()'
p21792
aS'                    << " GMRES iterations." << std::endl;'
p21793
aS'        }'
p21794
aS'        {'
p21795
aS'          second_last_computed_darcy_solution = last_computed_darcy_solution;'
p21796
aS'          last_computed_darcy_solution        = darcy_solution;'
p21797
aS'          saturation_matching_last_computed_darcy_solution ='
p21798
aS'            saturation_solution;'
p21799
aS'        }'
p21800
aS'      }'
p21801
aS'    else'
p21802
aS'      {'
p21803
aS'        darcy_solution = last_computed_darcy_solution;'
p21804
aS'        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,'
p21805
aS'                            -current_macro_time_step / old_macro_time_step,'
p21806
aS'                            second_last_computed_darcy_solution);'
p21807
aS'      }'
p21808
aS'    {'
p21809
aS'      old_time_step = time_step;'
p21810
aS'      const double max_u_F_prime = get_max_u_F_prime();'
p21811
aS'      if (max_u_F_prime > 0)'
p21812
aS'        time_step = porosity * GridTools::minimal_cell_diameter(triangulation) /'
p21813
aS'                    saturation_degree / max_u_F_prime / 50;'
p21814
aS'      else'
p21815
aS'        time_step = end_time - time;'
p21816
aS'    }'
p21817
aS'    if (solve_for_pressure_and_velocity == true)'
p21818
aS'      {'
p21819
aS'        old_macro_time_step     = current_macro_time_step;'
p21820
aS'        current_macro_time_step = time_step;'
p21821
aS'      }'
p21822
aS'    else'
p21823
aS'      current_macro_time_step += time_step;'
p21824
aS'    {'
p21825
aS'      std::cout << "   Solving saturation transport equation..." << std::endl;'
p21826
aS'      assemble_saturation_system();'
p21827
aS'      SolverControl solver_control(saturation_matrix.m(),'
p21828
aS'                                   1e-16 * saturation_rhs.l2_norm());'
p21829
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p21830
aS'      TrilinosWrappers::PreconditionIC preconditioner;'
p21831
aS'      preconditioner.initialize(saturation_matrix);'
p21832
aS'      cg.solve(saturation_matrix,'
p21833
aS'               saturation_solution,'
p21834
aS'               saturation_rhs,'
p21835
aS'               preconditioner);'
p21836
aS'      saturation_constraints.distribute(saturation_solution);'
p21837
aS'      project_back_saturation();'
p21838
aS'      std::cout << "        ..." << solver_control.last_step()'
p21839
aS'                << " CG iterations." << std::endl;'
p21840
aS'    }'
p21841
aS'  }'
p21842
aS'  template <int dim>'
p21843
aS'  void TwoPhaseFlowProblem<dim>::refine_mesh(const unsigned int min_grid_level,'
p21844
aS'                                             const unsigned int max_grid_level)'
p21845
aS'  {'
p21846
aS'    Vector<double> refinement_indicators(triangulation.n_active_cells());'
p21847
aS'    {'
p21848
aS'      const QMidpoint<dim>        quadrature_formula;'
p21849
aS'      FEValues<dim>               fe_values(saturation_fe,'
p21850
aS'                              quadrature_formula,'
p21851
aS'                              update_gradients);'
p21852
aS'      std::vector<Tensor<1, dim>> grad_saturation(1);'
p21853
aS'      TrilinosWrappers::MPI::Vector extrapolated_saturation_solution('
p21854
aS'        saturation_solution);'
p21855
aS'      if (timestep_number != 0)'
p21856
aS'        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),'
p21857
aS'                                              time_step / old_time_step,'
p21858
aS'                                              old_saturation_solution);'
p21859
aS'      for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p21860
aS'        {'
p21861
aS'          const unsigned int cell_no = cell->active_cell_index();'
p21862
aS'          fe_values.reinit(cell);'
p21863
aS'          fe_values.get_function_gradients(extrapolated_saturation_solution,'
p21864
aS'                                           grad_saturation);'
p21865
aS'          refinement_indicators(cell_no) = grad_saturation[0].norm();'
p21866
aS'        }'
p21867
aS'    }'
p21868
aS'    {'
p21869
aS'      for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p21870
aS'        {'
p21871
aS'          const unsigned int cell_no = cell->active_cell_index();'
p21872
aS'          cell->clear_coarsen_flag();'
p21873
aS'          cell->clear_refine_flag();'
p21874
aS'          if ((static_cast<unsigned int>(cell->level()) < max_grid_level) &&'
p21875
aS'               saturation_refinement_threshold))'
p21876
aS'            cell->set_refine_flag();'
p21877
aS'          else if ((static_cast<unsigned int>(cell->level()) >'
p21878
aS'                    min_grid_level) &&'
p21879
aS'                    0.5 * saturation_refinement_threshold))'
p21880
aS'            cell->set_coarsen_flag();'
p21881
aS'        }'
p21882
aS'    }'
p21883
aS'    triangulation.prepare_coarsening_and_refinement();'
p21884
aS'    {'
p21885
aS'      std::vector<TrilinosWrappers::MPI::Vector> x_saturation(3);'
p21886
aS'      x_saturation[0] = saturation_solution;'
p21887
aS'      x_saturation[1] = old_saturation_solution;'
p21888
aS'      x_saturation[2] = saturation_matching_last_computed_darcy_solution;'
p21889
aS'      std::vector<TrilinosWrappers::MPI::BlockVector> x_darcy(2);'
p21890
aS'      x_darcy[0] = last_computed_darcy_solution;'
p21891
aS'      x_darcy[1] = second_last_computed_darcy_solution;'
p21892
aS'      SolutionTransfer<dim, TrilinosWrappers::MPI::Vector> saturation_soltrans('
p21893
aS'        saturation_dof_handler);'
p21894
aS'      SolutionTransfer<dim, TrilinosWrappers::MPI::BlockVector> darcy_soltrans('
p21895
aS'        darcy_dof_handler);'
p21896
aS'      triangulation.prepare_coarsening_and_refinement();'
p21897
aS'      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);'
p21898
aS'      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);'
p21899
aS'      triangulation.execute_coarsening_and_refinement();'
p21900
aS'      setup_dofs();'
p21901
aS'      std::vector<TrilinosWrappers::MPI::Vector> tmp_saturation(3);'
p21902
aS'      tmp_saturation[0].reinit(saturation_solution);'
p21903
aS'      tmp_saturation[1].reinit(saturation_solution);'
p21904
aS'      tmp_saturation[2].reinit(saturation_solution);'
p21905
aS'      saturation_soltrans.interpolate(x_saturation, tmp_saturation);'
p21906
aS'      saturation_solution                              = tmp_saturation[0];'
p21907
aS'      old_saturation_solution                          = tmp_saturation[1];'
p21908
aS'      saturation_matching_last_computed_darcy_solution = tmp_saturation[2];'
p21909
aS'      saturation_constraints.distribute(saturation_solution);'
p21910
aS'      saturation_constraints.distribute(old_saturation_solution);'
p21911
aS'      saturation_constraints.distribute('
p21912
aS'        saturation_matching_last_computed_darcy_solution);'
p21913
aS'      std::vector<TrilinosWrappers::MPI::BlockVector> tmp_darcy(2);'
p21914
aS'      tmp_darcy[0].reinit(darcy_solution);'
p21915
aS'      tmp_darcy[1].reinit(darcy_solution);'
p21916
aS'      darcy_soltrans.interpolate(x_darcy, tmp_darcy);'
p21917
aS'      last_computed_darcy_solution        = tmp_darcy[0];'
p21918
aS'      second_last_computed_darcy_solution = tmp_darcy[1];'
p21919
aS'      darcy_constraints.distribute(last_computed_darcy_solution);'
p21920
aS'      darcy_constraints.distribute(second_last_computed_darcy_solution);'
p21921
aS'      rebuild_saturation_matrix = true;'
p21922
aS'    }'
p21923
aS'  }'
p21924
aS'  template <int dim>'
p21925
aS'  void TwoPhaseFlowProblem<dim>::output_results() const'
p21926
aS'  {'
p21927
aS'    const FESystem<dim> joint_fe(darcy_fe, 1, saturation_fe, 1);'
p21928
aS'    DoFHandler<dim>     joint_dof_handler(triangulation);'
p21929
aS'    joint_dof_handler.distribute_dofs(joint_fe);'
p21930
aS'    Assert(joint_dof_handler.n_dofs() =='
p21931
aS'             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),'
p21932
aS'           ExcInternalError());'
p21933
aS'    Vector<double> joint_solution(joint_dof_handler.n_dofs());'
p21934
aS'    {'
p21935
aS'      std::vector<types::global_dof_index> local_joint_dof_indices('
p21936
aS'        joint_fe.n_dofs_per_cell());'
p21937
aS'      std::vector<types::global_dof_index> local_darcy_dof_indices('
p21938
aS'        darcy_fe.n_dofs_per_cell());'
p21939
aS'      std::vector<types::global_dof_index> local_saturation_dof_indices('
p21940
aS'        saturation_fe.n_dofs_per_cell());'
p21941
aS'      auto       joint_cell      = joint_dof_handler.begin_active();'
p21942
aS'      const auto joint_endc      = joint_dof_handler.end();'
p21943
aS'      auto       darcy_cell      = darcy_dof_handler.begin_active();'
p21944
aS'      auto       saturation_cell = saturation_dof_handler.begin_active();'
p21945
aS'      for (; joint_cell != joint_endc;'
p21946
aS'           ++joint_cell, ++darcy_cell, ++saturation_cell)'
p21947
aS'        {'
p21948
aS'          joint_cell->get_dof_indices(local_joint_dof_indices);'
p21949
aS'          darcy_cell->get_dof_indices(local_darcy_dof_indices);'
p21950
aS'          saturation_cell->get_dof_indices(local_saturation_dof_indices);'
p21951
aS'          for (unsigned int i = 0; i < joint_fe.n_dofs_per_cell(); ++i)'
p21952
aS'            if (joint_fe.system_to_base_index(i).first.first == 0)'
p21953
aS'              {'
p21954
aS'                Assert(joint_fe.system_to_base_index(i).second <'
p21955
aS'                         local_darcy_dof_indices.size(),'
p21956
aS'                       ExcInternalError());'
p21957
aS'                joint_solution(local_joint_dof_indices[i]) = darcy_solution('
p21958
aS'                  local_darcy_dof_indices[joint_fe.system_to_base_index(i)'
p21959
aS'                                            .second]);'
p21960
aS'              }'
p21961
aS'            else'
p21962
aS'              {'
p21963
aS'                Assert(joint_fe.system_to_base_index(i).first.first == 1,'
p21964
aS'                       ExcInternalError());'
p21965
aS'                Assert(joint_fe.system_to_base_index(i).second <'
p21966
aS'                         local_darcy_dof_indices.size(),'
p21967
aS'                       ExcInternalError());'
p21968
aS'                joint_solution(local_joint_dof_indices[i]) ='
p21969
aS'                  saturation_solution('
p21970
aS'                    local_saturation_dof_indices'
p21971
aS'                      [joint_fe.system_to_base_index(i).second]);'
p21972
aS'              }'
p21973
aS'        }'
p21974
aS'    }'
p21975
aS'    std::vector<std::string> joint_solution_names(dim, "velocity");'
p21976
aS'    joint_solution_names.emplace_back("pressure");'
p21977
aS'    joint_solution_names.emplace_back("saturation");'
p21978
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p21979
aS'      data_component_interpretation('
p21980
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p21981
aS'    data_component_interpretation.push_back('
p21982
aS'      DataComponentInterpretation::component_is_scalar);'
p21983
aS'    data_component_interpretation.push_back('
p21984
aS'      DataComponentInterpretation::component_is_scalar);'
p21985
aS'    DataOut<dim> data_out;'
p21986
aS'    data_out.attach_dof_handler(joint_dof_handler);'
p21987
aS'    data_out.add_data_vector(joint_solution,'
p21988
aS'                             joint_solution_names,'
p21989
aS'                             DataOut<dim>::type_dof_data,'
p21990
aS'                             data_component_interpretation);'
p21991
aS'    data_out.build_patches();'
p21992
aS'    std::string filename ='
p21993
aS'      "solution-" + Utilities::int_to_string(timestep_number, 5) + ".vtu";'
p21994
aS'    std::ofstream output(filename);'
p21995
aS'    data_out.write_vtu(output);'
p21996
aS'  }'
p21997
aS'  template <int dim>'
p21998
aS'  bool TwoPhaseFlowProblem<'
p21999
aS'    dim>::determine_whether_to_solve_for_pressure_and_velocity() const'
p22000
aS'  {'
p22001
aS'    if (timestep_number <= 2)'
p22002
aS'      return true;'
p22003
aS'    const QGauss<dim>  quadrature_formula(saturation_degree + 2);'
p22004
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p22005
aS'    FEValues<dim> fe_values(saturation_fe,'
p22006
aS'                            quadrature_formula,'
p22007
aS'                            update_values | update_quadrature_points);'
p22008
aS'    std::vector<double> old_saturation_after_solving_pressure(n_q_points);'
p22009
aS'    std::vector<double> present_saturation(n_q_points);'
p22010
aS'    std::vector<Tensor<2, dim>> k_inverse_values(n_q_points);'
p22011
aS'    double max_global_aop_indicator = 0.0;'
p22012
aS'    for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p22013
aS'      {'
p22014
aS'        double max_local_mobility_reciprocal_difference = 0.0;'
p22015
aS'        double max_local_permeability_inverse_l1_norm   = 0.0;'
p22016
aS'        fe_values.reinit(cell);'
p22017
aS'        fe_values.get_function_values('
p22018
aS'          saturation_matching_last_computed_darcy_solution,'
p22019
aS'          old_saturation_after_solving_pressure);'
p22020
aS'        fe_values.get_function_values(saturation_solution, present_saturation);'
p22021
aS'        k_inverse.value_list(fe_values.get_quadrature_points(),'
p22022
aS'                             k_inverse_values);'
p22023
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p22024
aS'          {'
p22025
aS'            const double mobility_reciprocal_difference = std::fabs('
p22026
aS'              mobility_inverse(present_saturation[q], viscosity) -'
p22027
aS'              mobility_inverse(old_saturation_after_solving_pressure[q],'
p22028
aS'                               viscosity));'
p22029
aS'            max_local_mobility_reciprocal_difference ='
p22030
aS'              std::max(max_local_mobility_reciprocal_difference,'
p22031
aS'                       mobility_reciprocal_difference);'
p22032
aS'            max_local_permeability_inverse_l1_norm ='
p22033
aS'              std::max(max_local_permeability_inverse_l1_norm,'
p22034
aS'                       l1_norm(k_inverse_values[q]));'
p22035
aS'          }'
p22036
aS'        max_global_aop_indicator ='
p22037
aS'          std::max(max_global_aop_indicator,'
p22038
aS'                    max_local_permeability_inverse_l1_norm));'
p22039
aS'      }'
p22040
aS'    return (max_global_aop_indicator > AOS_threshold);'
p22041
aS'  }'
p22042
aS'  template <int dim>'
p22043
aS'  void TwoPhaseFlowProblem<dim>::project_back_saturation()'
p22044
aS'  {'
p22045
aS'    for (unsigned int i = 0; i < saturation_solution.size(); ++i)'
p22046
aS'      if (saturation_solution(i) < 0.2)'
p22047
aS'        saturation_solution(i) = 0.2;'
p22048
aS'      else if (saturation_solution(i) > 1)'
p22049
aS'        saturation_solution(i) = 1;'
p22050
aS'  }'
p22051
aS'  template <int dim>'
p22052
aS'  double TwoPhaseFlowProblem<dim>::get_max_u_F_prime() const'
p22053
aS'  {'
p22054
aS'    const QGauss<dim>  quadrature_formula(darcy_degree + 2);'
p22055
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p22056
aS'    FEValues<dim> darcy_fe_values(darcy_fe, quadrature_formula, update_values);'
p22057
aS'    FEValues<dim> saturation_fe_values(saturation_fe,'
p22058
aS'                                       quadrature_formula,'
p22059
aS'                                       update_values);'
p22060
aS'    std::vector<Vector<double>> darcy_solution_values(n_q_points,'
p22061
aS'                                                      Vector<double>(dim + 1));'
p22062
aS'    std::vector<double>         saturation_values(n_q_points);'
p22063
aS'    double max_velocity_times_dF_dS = 0;'
p22064
aS'    auto       cell            = darcy_dof_handler.begin_active();'
p22065
aS'    const auto endc            = darcy_dof_handler.end();'
p22066
aS'    auto       saturation_cell = saturation_dof_handler.begin_active();'
p22067
aS'    for (; cell != endc; ++cell, ++saturation_cell)'
p22068
aS'      {'
p22069
aS'        darcy_fe_values.reinit(cell);'
p22070
aS'        saturation_fe_values.reinit(saturation_cell);'
p22071
aS'        darcy_fe_values.get_function_values(darcy_solution,'
p22072
aS'                                            darcy_solution_values);'
p22073
aS'        saturation_fe_values.get_function_values(old_saturation_solution,'
p22074
aS'                                                 saturation_values);'
p22075
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p22076
aS'          {'
p22077
aS'            Tensor<1, dim> velocity;'
p22078
aS'            for (unsigned int i = 0; i < dim; ++i)'
p22079
aS'              velocity[i] = darcy_solution_values[q](i);'
p22080
aS'            const double dF_dS ='
p22081
aS'              fractional_flow_derivative(saturation_values[q], viscosity);'
p22082
aS'            max_velocity_times_dF_dS ='
p22083
aS'              std::max(max_velocity_times_dF_dS, velocity.norm() * dF_dS);'
p22084
aS'          }'
p22085
aS'      }'
p22086
aS'    return max_velocity_times_dF_dS;'
p22087
aS'  }'
p22088
aS'  template <int dim>'
p22089
aS'  std::pair<double, double>'
p22090
aS'  TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range() const'
p22091
aS'  {'
p22092
aS'    const QGauss<dim>  quadrature_formula(saturation_degree + 2);'
p22093
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p22094
aS'    FEValues<dim> fe_values(saturation_fe, quadrature_formula, update_values);'
p22095
aS'    std::vector<double> old_saturation_values(n_q_points);'
p22096
aS'    std::vector<double> old_old_saturation_values(n_q_points);'
p22097
aS'    if (timestep_number != 0)'
p22098
aS'      {'
p22099
aS'        double min_saturation = std::numeric_limits<double>::max(),'
p22100
aS'               max_saturation = -std::numeric_limits<double>::max();'
p22101
aS'        for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p22102
aS'          {'
p22103
aS'            fe_values.reinit(cell);'
p22104
aS'            fe_values.get_function_values(old_saturation_solution,'
p22105
aS'                                          old_saturation_values);'
p22106
aS'            fe_values.get_function_values(old_old_saturation_solution,'
p22107
aS'                                          old_old_saturation_values);'
p22108
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p22109
aS'              {'
p22110
aS'                const double saturation ='
p22111
aS'                  time_step / old_time_step * old_old_saturation_values[q];'
p22112
aS'                min_saturation = std::min(min_saturation, saturation);'
p22113
aS'                max_saturation = std::max(max_saturation, saturation);'
p22114
aS'              }'
p22115
aS'          }'
p22116
aS'        return std::make_pair(min_saturation, max_saturation);'
p22117
aS'      }'
p22118
aS'    else'
p22119
aS'      {'
p22120
aS'        double min_saturation = std::numeric_limits<double>::max(),'
p22121
aS'               max_saturation = -std::numeric_limits<double>::max();'
p22122
aS'        for (const auto &cell : saturation_dof_handler.active_cell_iterators())'
p22123
aS'          {'
p22124
aS'            fe_values.reinit(cell);'
p22125
aS'            fe_values.get_function_values(old_saturation_solution,'
p22126
aS'                                          old_saturation_values);'
p22127
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p22128
aS'              {'
p22129
aS'                const double saturation = old_saturation_values[q];'
p22130
aS'                min_saturation = std::min(min_saturation, saturation);'
p22131
aS'                max_saturation = std::max(max_saturation, saturation);'
p22132
aS'              }'
p22133
aS'          }'
p22134
aS'        return std::make_pair(min_saturation, max_saturation);'
p22135
aS'      }'
p22136
aS'  }'
p22137
aS'  template <int dim>'
p22138
aS'  double TwoPhaseFlowProblem<dim>::compute_viscosity('
p22139
aS'    const std::vector<double> &        old_saturation,'
p22140
aS'    const std::vector<double> &        old_old_saturation,'
p22141
aS'    const std::vector<Tensor<1, dim>> &old_saturation_grads,'
p22142
aS'    const std::vector<Tensor<1, dim>> &old_old_saturation_grads,'
p22143
aS'    const std::vector<Vector<double>> &present_darcy_values,'
p22144
aS'    const double                       global_max_u_F_prime,'
p22145
aS'    const double                       global_S_variation,'
p22146
aS'    const double                       cell_diameter) const'
p22147
aS'  {'
p22148
aS'    const double beta  = .4 * dim;'
p22149
aS'    const double alpha = 1;'
p22150
aS'    if (global_max_u_F_prime == 0)'
p22151
aS'      return 5e-3 * cell_diameter;'
p22152
aS'    const unsigned int n_q_points = old_saturation.size();'
p22153
aS'    double max_residual             = 0;'
p22154
aS'    double max_velocity_times_dF_dS = 0;'
p22155
aS'    const bool use_dF_dS = true;'
p22156
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p22157
aS'      {'
p22158
aS'        Tensor<1, dim> u;'
p22159
aS'        for (unsigned int d = 0; d < dim; ++d)'
p22160
aS'          u[d] = present_darcy_values[q](d);'
p22161
aS'        const double dS_dt = porosity *'
p22162
aS'                             old_time_step;'
p22163
aS'        const double dF_dS = fractional_flow_derivative('
p22164
aS'        const double u_grad_S ='
p22165
aS'          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /'
p22166
aS'          2.0;'
p22167
aS'        const double residual ='
p22168
aS'          std::abs((dS_dt + u_grad_S) *'
p22169
aS'                   std::pow((old_saturation[q] + old_old_saturation[q]) / 2,'
p22170
aS'                            alpha - 1.));'
p22171
aS'        max_residual = std::max(residual, max_residual);'
p22172
aS'        max_velocity_times_dF_dS ='
p22173
aS'          std::max(std::sqrt(u * u) * (use_dF_dS ? std::max(dF_dS, 1.) : 1),'
p22174
aS'                   max_velocity_times_dF_dS);'
p22175
aS'      }'
p22176
aS'    const double c_R            = 1.0;'
p22177
aS'    const double global_scaling = c_R * porosity *'
p22178
aS'                                  std::pow(global_Omega_diameter, alpha - 2.);'
p22179
aS'    return (beta *'
p22180
aS'                                                std::pow(cell_diameter, alpha) *'
p22181
aS'                                                  max_residual /'
p22182
aS'                                                  global_scaling));'
p22183
aS'  }'
p22184
aS'  template <int dim>'
p22185
aS'  void TwoPhaseFlowProblem<dim>::run()'
p22186
aS'  {'
p22187
aS'    const unsigned int initial_refinement     = (dim == 2 ? 5 : 2);'
p22188
aS'    const unsigned int n_pre_refinement_steps = (dim == 2 ? 3 : 2);'
p22189
aS'    GridGenerator::hyper_cube(triangulation, 0, 1);'
p22190
aS'    triangulation.refine_global(initial_refinement);'
p22191
aS'    global_Omega_diameter = GridTools::diameter(triangulation);'
p22192
aS'    setup_dofs();'
p22193
aS'    unsigned int pre_refinement_step = 0;'
p22194
aS'  start_time_iteration:'
p22195
aS'    VectorTools::project(saturation_dof_handler,'
p22196
aS'                         saturation_constraints,'
p22197
aS'                         QGauss<dim>(saturation_degree + 2),'
p22198
aS'                         SaturationInitialValues<dim>(),'
p22199
aS'                         old_saturation_solution);'
p22200
aS'    time_step = old_time_step = 0;'
p22201
aS'    current_macro_time_step = old_macro_time_step = 0;'
p22202
aS'    time = 0;'
p22203
aS'    do'
p22204
aS'      {'
p22205
aS'        std::cout << "Timestep " << timestep_number << ":  t=" << time'
p22206
aS'                  << ", dt=" << time_step << std::endl;'
p22207
aS'        solve();'
p22208
aS'        std::cout << std::endl;'
p22209
aS'        if (timestep_number % 200 == 0)'
p22210
aS'          output_results();'
p22211
aS'        if (timestep_number % 25 == 0)'
p22212
aS'          refine_mesh(initial_refinement,'
p22213
aS'                      initial_refinement + n_pre_refinement_steps);'
p22214
aS'        if ((timestep_number == 0) &&'
p22215
aS'          {'
p22216
aS'            ++pre_refinement_step;'
p22217
aS'            goto start_time_iteration;'
p22218
aS'          }'
p22219
aS'        time += time_step;'
p22220
aS'        ++timestep_number;'
p22221
aS'        old_old_saturation_solution = old_saturation_solution;'
p22222
aS'        old_saturation_solution     = saturation_solution;'
p22223
aS'      }'
p22224
aS'    while (time <= end_time);'
p22225
aS'  }'
p22226
aS'} // namespace Step43'
p22227
aS'int main(int argc, char *argv[])'
p22228
ag9
aS'  try'
p22229
aS'    {'
p22230
aS'      using namespace dealii;'
p22231
aS'      using namespace Step43;'
p22232
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization('
p22233
aS'        argc, argv, numbers::invalid_unsigned_int);'
p22234
aS'      AssertThrow(Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) == 1,'
p22235
aS'                  ExcMessage('
p22236
aS'                    "This program can only be run in serial, use ./step-43"));'
p22237
aS'      TwoPhaseFlowProblem<2> two_phase_flow_problem(1);'
p22238
aS'      two_phase_flow_problem.run();'
p22239
aS'    }'
p22240
aS'  catch (std::exception &exc)'
p22241
aS'    {'
p22242
aS'      std::cerr << std::endl'
p22243
aS'                << std::endl'
p22244
aS'                << "----------------------------------------------------"'
p22245
aS'                << std::endl;'
p22246
aS'      std::cerr << "Exception on processing: " << std::endl'
p22247
aS'                << exc.what() << std::endl'
p22248
aS'                << "Aborting!" << std::endl'
p22249
aS'                << "----------------------------------------------------"'
p22250
aS'                << std::endl;'
p22251
aS'      return 1;'
p22252
aS'    }'
p22253
aS'  catch (...)'
p22254
aS'    {'
p22255
aS'      std::cerr << std::endl'
p22256
aS'                << std::endl'
p22257
aS'                << "----------------------------------------------------"'
p22258
aS'                << std::endl;'
p22259
aS'      std::cerr << "Unknown exception!" << std::endl'
p22260
aS'                << "Aborting!" << std::endl'
p22261
aS'                << "----------------------------------------------------"'
p22262
aS'                << std::endl;'
p22263
aS'      return 1;'
p22264
aS'    }'
p22265
aS'  return 0;'
p22266
ag17
aS'#include <deal.II/base/function.h>'
p22267
aS'#include <deal.II/base/parameter_handler.h>'
p22268
aS'#include <deal.II/base/point.h>'
p22269
aS'#include <deal.II/base/quadrature_lib.h>'
p22270
aS'#include <deal.II/base/symmetric_tensor.h>'
p22271
aS'#include <deal.II/base/tensor.h>'
p22272
aS'#include <deal.II/base/timer.h>'
p22273
aS'#include <deal.II/base/work_stream.h>'
p22274
aS'#include <deal.II/dofs/dof_renumbering.h>'
p22275
aS'#include <deal.II/dofs/dof_tools.h>'
p22276
aS'#include <deal.II/base/quadrature_point_data.h>'
p22277
aS'#include <deal.II/grid/grid_generator.h>'
p22278
aS'#include <deal.II/grid/grid_tools.h>'
p22279
aS'#include <deal.II/grid/grid_in.h>'
p22280
aS'#include <deal.II/grid/tria.h>'
p22281
aS'#include <deal.II/fe/fe_dgp_monomial.h>'
p22282
aS'#include <deal.II/fe/fe_q.h>'
p22283
aS'#include <deal.II/fe/fe_system.h>'
p22284
aS'#include <deal.II/fe/fe_tools.h>'
p22285
aS'#include <deal.II/fe/fe_values.h>'
p22286
aS'#include <deal.II/fe/mapping_q_eulerian.h>'
p22287
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p22288
aS'#include <deal.II/lac/block_vector.h>'
p22289
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p22290
aS'#include <deal.II/lac/full_matrix.h>'
p22291
aS'#include <deal.II/lac/precondition_selector.h>'
p22292
aS'#include <deal.II/lac/solver_cg.h>'
p22293
aS'#include <deal.II/lac/solver_selector.h>'
p22294
aS'#include <deal.II/lac/sparse_direct.h>'
p22295
aS'#include <deal.II/lac/affine_constraints.h>'
p22296
aS'#include <deal.II/lac/linear_operator.h>'
p22297
aS'#include <deal.II/lac/packaged_operation.h>'
p22298
aS'#include <deal.II/numerics/data_out.h>'
p22299
aS'#include <deal.II/numerics/vector_tools.h>'
p22300
aS'#include <deal.II/physics/elasticity/kinematics.h>'
p22301
aS'#include <deal.II/physics/elasticity/standard_tensors.h>'
p22302
aS'#include <iostream>'
p22303
aS'#include <fstream>'
p22304
aS'namespace Step44'
p22305
ag9
aS'  using namespace dealii;'
p22306
aS'  namespace Parameters'
p22307
aS'  {'
p22308
aS'    struct FESystem'
p22309
aS'    {'
p22310
aS'      unsigned int poly_degree;'
p22311
aS'      unsigned int quad_order;'
p22312
aS'      static void declare_parameters(ParameterHandler &prm);'
p22313
aS'      void parse_parameters(ParameterHandler &prm);'
p22314
aS'    };'
p22315
aS'    void FESystem::declare_parameters(ParameterHandler &prm)'
p22316
aS'    {'
p22317
aS'      prm.enter_subsection("Finite element system");'
p22318
aS'      {'
p22319
aS'        prm.declare_entry("Polynomial degree",'
p22320
aS'                          "2",'
p22321
aS'                          Patterns::Integer(0),'
p22322
aS'                          "Displacement system polynomial order");'
p22323
aS'        prm.declare_entry("Quadrature order",'
p22324
aS'                          "3",'
p22325
aS'                          Patterns::Integer(0),'
p22326
aS'                          "Gauss quadrature order");'
p22327
aS'      }'
p22328
aS'      prm.leave_subsection();'
p22329
aS'    }'
p22330
aS'    void FESystem::parse_parameters(ParameterHandler &prm)'
p22331
aS'    {'
p22332
aS'      prm.enter_subsection("Finite element system");'
p22333
aS'      {'
p22334
aS'        poly_degree = prm.get_integer("Polynomial degree");'
p22335
aS'        quad_order  = prm.get_integer("Quadrature order");'
p22336
aS'      }'
p22337
aS'      prm.leave_subsection();'
p22338
aS'    }'
p22339
aS'    struct Geometry'
p22340
aS'    {'
p22341
aS'      unsigned int global_refinement;'
p22342
aS'      double       scale;'
p22343
aS'      double       p_p0;'
p22344
aS'      static void declare_parameters(ParameterHandler &prm);'
p22345
aS'      void parse_parameters(ParameterHandler &prm);'
p22346
aS'    };'
p22347
aS'    void Geometry::declare_parameters(ParameterHandler &prm)'
p22348
aS'    {'
p22349
aS'      prm.enter_subsection("Geometry");'
p22350
aS'      {'
p22351
aS'        prm.declare_entry("Global refinement",'
p22352
aS'                          "2",'
p22353
aS'                          Patterns::Integer(0),'
p22354
aS'                          "Global refinement level");'
p22355
aS'        prm.declare_entry("Grid scale",'
p22356
aS'                          "1e-3",'
p22357
aS'                          Patterns::Double(0.0),'
p22358
aS'                          "Global grid scaling factor");'
p22359
aS'        prm.declare_entry("Pressure ratio p/p0",'
p22360
aS'                          "100",'
p22361
aS'                          Patterns::Selection("20|40|60|80|100"),'
p22362
aS'                          "Ratio of applied pressure to reference pressure");'
p22363
aS'      }'
p22364
aS'      prm.leave_subsection();'
p22365
aS'    }'
p22366
aS'    void Geometry::parse_parameters(ParameterHandler &prm)'
p22367
aS'    {'
p22368
aS'      prm.enter_subsection("Geometry");'
p22369
aS'      {'
p22370
aS'        global_refinement = prm.get_integer("Global refinement");'
p22371
aS'        scale             = prm.get_double("Grid scale");'
p22372
aS'        p_p0              = prm.get_double("Pressure ratio p/p0");'
p22373
aS'      }'
p22374
aS'      prm.leave_subsection();'
p22375
aS'    }'
p22376
aS'    struct Materials'
p22377
aS'    {'
p22378
aS'      double nu;'
p22379
aS'      double mu;'
p22380
aS'      static void declare_parameters(ParameterHandler &prm);'
p22381
aS'      void parse_parameters(ParameterHandler &prm);'
p22382
aS'    };'
p22383
aS'    void Materials::declare_parameters(ParameterHandler &prm)'
p22384
aS'    {'
p22385
aS'      prm.enter_subsection("Material properties");'
p22386
aS'      {'
p22387
aS'        prm.declare_entry("Poisson\'s ratio",'
p22388
aS'                          "0.4999",'
p22389
aS'                          Patterns::Double(-1.0, 0.5),'
p22390
aS'                          "Poisson\'s ratio");'
p22391
aS'        prm.declare_entry("Shear modulus",'
p22392
aS'                          "80.194e6",'
p22393
aS'                          Patterns::Double(),'
p22394
aS'                          "Shear modulus");'
p22395
aS'      }'
p22396
aS'      prm.leave_subsection();'
p22397
aS'    }'
p22398
aS'    void Materials::parse_parameters(ParameterHandler &prm)'
p22399
aS'    {'
p22400
aS'      prm.enter_subsection("Material properties");'
p22401
aS'      {'
p22402
aS'        nu = prm.get_double("Poisson\'s ratio");'
p22403
aS'        mu = prm.get_double("Shear modulus");'
p22404
aS'      }'
p22405
aS'      prm.leave_subsection();'
p22406
aS'    }'
p22407
aS'    struct LinearSolver'
p22408
aS'    {'
p22409
aS'      std::string type_lin;'
p22410
aS'      double      tol_lin;'
p22411
aS'      double      max_iterations_lin;'
p22412
aS'      bool        use_static_condensation;'
p22413
aS'      std::string preconditioner_type;'
p22414
aS'      double      preconditioner_relaxation;'
p22415
aS'      static void declare_parameters(ParameterHandler &prm);'
p22416
aS'      void parse_parameters(ParameterHandler &prm);'
p22417
aS'    };'
p22418
aS'    void LinearSolver::declare_parameters(ParameterHandler &prm)'
p22419
aS'    {'
p22420
aS'      prm.enter_subsection("Linear solver");'
p22421
aS'      {'
p22422
aS'        prm.declare_entry("Solver type",'
p22423
aS'                          "CG",'
p22424
aS'                          Patterns::Selection("CG|Direct"),'
p22425
aS'                          "Type of solver used to solve the linear system");'
p22426
aS'        prm.declare_entry("Residual",'
p22427
aS'                          "1e-6",'
p22428
aS'                          Patterns::Double(0.0),'
p22429
aS'                          "Linear solver residual (scaled by residual norm)");'
p22430
aS'        prm.declare_entry('
p22431
aS'          "Max iteration multiplier",'
p22432
aS'          "1",'
p22433
aS'          Patterns::Double(0.0),'
p22434
aS'          "Linear solver iterations (multiples of the system matrix size)");'
p22435
aS'        prm.declare_entry("Use static condensation",'
p22436
aS'                          "true",'
p22437
aS'                          Patterns::Bool(),'
p22438
aS'                          "Solve the full block system or a reduced problem");'
p22439
aS'        prm.declare_entry("Preconditioner type",'
p22440
aS'                          "ssor",'
p22441
aS'                          Patterns::Selection("jacobi|ssor"),'
p22442
aS'                          "Type of preconditioner");'
p22443
aS'        prm.declare_entry("Preconditioner relaxation",'
p22444
aS'                          "0.65",'
p22445
aS'                          Patterns::Double(0.0),'
p22446
aS'                          "Preconditioner relaxation value");'
p22447
aS'      }'
p22448
aS'      prm.leave_subsection();'
p22449
aS'    }'
p22450
aS'    void LinearSolver::parse_parameters(ParameterHandler &prm)'
p22451
aS'    {'
p22452
aS'      prm.enter_subsection("Linear solver");'
p22453
aS'      {'
p22454
aS'        type_lin                  = prm.get("Solver type");'
p22455
aS'        tol_lin                   = prm.get_double("Residual");'
p22456
aS'        max_iterations_lin        = prm.get_double("Max iteration multiplier");'
p22457
aS'        use_static_condensation   = prm.get_bool("Use static condensation");'
p22458
aS'        preconditioner_type       = prm.get("Preconditioner type");'
p22459
aS'        preconditioner_relaxation = prm.get_double("Preconditioner relaxation");'
p22460
aS'      }'
p22461
aS'      prm.leave_subsection();'
p22462
aS'    }'
p22463
aS'    struct NonlinearSolver'
p22464
aS'    {'
p22465
aS'      unsigned int max_iterations_NR;'
p22466
aS'      double       tol_f;'
p22467
aS'      double       tol_u;'
p22468
aS'      static void declare_parameters(ParameterHandler &prm);'
p22469
aS'      void parse_parameters(ParameterHandler &prm);'
p22470
aS'    };'
p22471
aS'    void NonlinearSolver::declare_parameters(ParameterHandler &prm)'
p22472
aS'    {'
p22473
aS'      prm.enter_subsection("Nonlinear solver");'
p22474
aS'      {'
p22475
aS'        prm.declare_entry("Max iterations Newton-Raphson",'
p22476
aS'                          "10",'
p22477
aS'                          Patterns::Integer(0),'
p22478
aS'                          "Number of Newton-Raphson iterations allowed");'
p22479
aS'        prm.declare_entry("Tolerance force",'
p22480
aS'                          "1.0e-9",'
p22481
aS'                          Patterns::Double(0.0),'
p22482
aS'                          "Force residual tolerance");'
p22483
aS'        prm.declare_entry("Tolerance displacement",'
p22484
aS'                          "1.0e-6",'
p22485
aS'                          Patterns::Double(0.0),'
p22486
aS'                          "Displacement error tolerance");'
p22487
aS'      }'
p22488
aS'      prm.leave_subsection();'
p22489
aS'    }'
p22490
aS'    void NonlinearSolver::parse_parameters(ParameterHandler &prm)'
p22491
aS'    {'
p22492
aS'      prm.enter_subsection("Nonlinear solver");'
p22493
aS'      {'
p22494
aS'        max_iterations_NR = prm.get_integer("Max iterations Newton-Raphson");'
p22495
aS'        tol_f             = prm.get_double("Tolerance force");'
p22496
aS'        tol_u             = prm.get_double("Tolerance displacement");'
p22497
aS'      }'
p22498
aS'      prm.leave_subsection();'
p22499
aS'    }'
p22500
aS'    struct Time'
p22501
aS'    {'
p22502
aS'      double delta_t;'
p22503
aS'      double end_time;'
p22504
aS'      static void declare_parameters(ParameterHandler &prm);'
p22505
aS'      void parse_parameters(ParameterHandler &prm);'
p22506
aS'    };'
p22507
aS'    void Time::declare_parameters(ParameterHandler &prm)'
p22508
aS'    {'
p22509
aS'      prm.enter_subsection("Time");'
p22510
aS'      {'
p22511
aS'        prm.declare_entry("End time", "1", Patterns::Double(), "End time");'
p22512
aS'        prm.declare_entry("Time step size",'
p22513
aS'                          "0.1",'
p22514
aS'                          Patterns::Double(),'
p22515
aS'                          "Time step size");'
p22516
aS'      }'
p22517
aS'      prm.leave_subsection();'
p22518
aS'    }'
p22519
aS'    void Time::parse_parameters(ParameterHandler &prm)'
p22520
aS'    {'
p22521
aS'      prm.enter_subsection("Time");'
p22522
aS'      {'
p22523
aS'        end_time = prm.get_double("End time");'
p22524
aS'        delta_t  = prm.get_double("Time step size");'
p22525
aS'      }'
p22526
aS'      prm.leave_subsection();'
p22527
aS'    }'
p22528
aS'    struct AllParameters : public FESystem,'
p22529
aS'                           public Geometry,'
p22530
aS'                           public Materials,'
p22531
aS'                           public LinearSolver,'
p22532
aS'                           public NonlinearSolver,'
p22533
aS'                           public Time'
p22534
aS'    {'
p22535
aS'      AllParameters(const std::string &input_file);'
p22536
aS'      static void declare_parameters(ParameterHandler &prm);'
p22537
aS'      void parse_parameters(ParameterHandler &prm);'
p22538
aS'    };'
p22539
aS'    AllParameters::AllParameters(const std::string &input_file)'
p22540
aS'    {'
p22541
aS'      ParameterHandler prm;'
p22542
aS'      declare_parameters(prm);'
p22543
aS'      prm.parse_input(input_file);'
p22544
aS'      parse_parameters(prm);'
p22545
aS'    }'
p22546
aS'    void AllParameters::declare_parameters(ParameterHandler &prm)'
p22547
aS'    {'
p22548
aS'      FESystem::declare_parameters(prm);'
p22549
aS'      Geometry::declare_parameters(prm);'
p22550
aS'      Materials::declare_parameters(prm);'
p22551
aS'      LinearSolver::declare_parameters(prm);'
p22552
aS'      NonlinearSolver::declare_parameters(prm);'
p22553
aS'      Time::declare_parameters(prm);'
p22554
aS'    }'
p22555
aS'    void AllParameters::parse_parameters(ParameterHandler &prm)'
p22556
aS'    {'
p22557
aS'      FESystem::parse_parameters(prm);'
p22558
aS'      Geometry::parse_parameters(prm);'
p22559
aS'      Materials::parse_parameters(prm);'
p22560
aS'      LinearSolver::parse_parameters(prm);'
p22561
aS'      NonlinearSolver::parse_parameters(prm);'
p22562
aS'      Time::parse_parameters(prm);'
p22563
aS'    }'
p22564
aS'  } // namespace Parameters'
p22565
aS'  class Time'
p22566
aS'  {'
p22567
aS'  public:'
p22568
aS'    Time(const double time_end, const double delta_t)'
p22569
aS'      : timestep(0)'
p22570
aS'      , time_current(0.0)'
p22571
aS'      , time_end(time_end)'
p22572
aS'      , delta_t(delta_t)'
p22573
aS'    {}'
p22574
aS'    virtual ~Time() = default;'
p22575
aS'    double current() const'
p22576
aS'    {'
p22577
aS'      return time_current;'
p22578
aS'    }'
p22579
aS'    double end() const'
p22580
aS'    {'
p22581
aS'      return time_end;'
p22582
aS'    }'
p22583
aS'    double get_delta_t() const'
p22584
aS'    {'
p22585
aS'      return delta_t;'
p22586
aS'    }'
p22587
aS'    unsigned int get_timestep() const'
p22588
aS'    {'
p22589
aS'      return timestep;'
p22590
aS'    }'
p22591
aS'    void increment()'
p22592
aS'    {'
p22593
aS'      time_current += delta_t;'
p22594
aS'      ++timestep;'
p22595
aS'    }'
p22596
aS'  private:'
p22597
aS'    unsigned int timestep;'
p22598
aS'    double       time_current;'
p22599
aS'    const double time_end;'
p22600
aS'    const double delta_t;'
p22601
aS'  };'
p22602
aS'  template <int dim>'
p22603
aS'  class Material_Compressible_Neo_Hook_Three_Field'
p22604
aS'  {'
p22605
aS'  public:'
p22606
aS'    Material_Compressible_Neo_Hook_Three_Field(const double mu, const double nu)'
p22607
aS'      : kappa((2.0 * mu * (1.0 + nu)) / (3.0 * (1.0 - 2.0 * nu)))'
p22608
aS'      , c_1(mu / 2.0)'
p22609
aS'      , det_F(1.0)'
p22610
aS'      , p_tilde(0.0)'
p22611
aS'      , J_tilde(1.0)'
p22612
aS'      , b_bar(Physics::Elasticity::StandardTensors<dim>::I)'
p22613
aS'    {'
p22614
aS'      Assert(kappa > 0, ExcInternalError());'
p22615
aS'    }'
p22616
aS'    void update_material_data(const Tensor<2, dim> &F,'
p22617
aS'                              const double          p_tilde_in,'
p22618
aS'                              const double          J_tilde_in)'
p22619
aS'    {'
p22620
aS'      det_F                      = determinant(F);'
p22621
aS'      const Tensor<2, dim> F_bar = Physics::Elasticity::Kinematics::F_iso(F);'
p22622
aS'      b_bar                      = Physics::Elasticity::Kinematics::b(F_bar);'
p22623
aS'      p_tilde                    = p_tilde_in;'
p22624
aS'      J_tilde                    = J_tilde_in;'
p22625
aS'      Assert(det_F > 0, ExcInternalError());'
p22626
aS'    }'
p22627
aS'    SymmetricTensor<2, dim> get_tau()'
p22628
aS'    {'
p22629
aS'      return get_tau_iso() + get_tau_vol();'
p22630
aS'    }'
p22631
aS'    SymmetricTensor<4, dim> get_Jc() const'
p22632
aS'    {'
p22633
aS'      return get_Jc_vol() + get_Jc_iso();'
p22634
aS'    }'
p22635
aS'    double get_dPsi_vol_dJ() const'
p22636
aS'    {'
p22637
aS'      return (kappa / 2.0) * (J_tilde - 1.0 / J_tilde);'
p22638
aS'    }'
p22639
aS'    double get_d2Psi_vol_dJ2() const'
p22640
aS'    {'
p22641
aS'      return ((kappa / 2.0) * (1.0 + 1.0 / (J_tilde * J_tilde)));'
p22642
aS'    }'
p22643
aS'    double get_det_F() const'
p22644
aS'    {'
p22645
aS'      return det_F;'
p22646
aS'    }'
p22647
aS'    double get_p_tilde() const'
p22648
aS'    {'
p22649
aS'      return p_tilde;'
p22650
aS'    }'
p22651
aS'    double get_J_tilde() const'
p22652
aS'    {'
p22653
aS'      return J_tilde;'
p22654
aS'    }'
p22655
aS'  protected:'
p22656
aS'    const double kappa;'
p22657
aS'    const double c_1;'
p22658
aS'    double                  det_F;'
p22659
aS'    double                  p_tilde;'
p22660
aS'    double                  J_tilde;'
p22661
aS'    SymmetricTensor<2, dim> b_bar;'
p22662
aS'    SymmetricTensor<2, dim> get_tau_vol() const'
p22663
aS'    {'
p22664
aS'      return p_tilde * det_F * Physics::Elasticity::StandardTensors<dim>::I;'
p22665
aS'    }'
p22666
aS'    SymmetricTensor<2, dim> get_tau_iso() const'
p22667
aS'    {'
p22668
aS'      return Physics::Elasticity::StandardTensors<dim>::dev_P * get_tau_bar();'
p22669
aS'    }'
p22670
aS'    SymmetricTensor<2, dim> get_tau_bar() const'
p22671
aS'    {'
p22672
aS'      return 2.0 * c_1 * b_bar;'
p22673
aS'    }'
p22674
aS'    SymmetricTensor<4, dim> get_Jc_vol() const'
p22675
aS'    {'
p22676
aS'      return p_tilde * det_F *'
p22677
aS'    }'
p22678
aS'    SymmetricTensor<4, dim> get_Jc_iso() const'
p22679
aS'    {'
p22680
aS'      const SymmetricTensor<2, dim> tau_bar = get_tau_bar();'
p22681
aS'      const SymmetricTensor<2, dim> tau_iso = get_tau_iso();'
p22682
aS'      const SymmetricTensor<4, dim> tau_iso_x_I ='
p22683
aS'        outer_product(tau_iso, Physics::Elasticity::StandardTensors<dim>::I);'
p22684
aS'      const SymmetricTensor<4, dim> I_x_tau_iso ='
p22685
aS'        outer_product(Physics::Elasticity::StandardTensors<dim>::I, tau_iso);'
p22686
aS'      const SymmetricTensor<4, dim> c_bar = get_c_bar();'
p22687
aS'      return (2.0 / dim) * trace(tau_bar) *'
p22688
aS'               Physics::Elasticity::StandardTensors<dim>::dev_P -'
p22689
aS'             Physics::Elasticity::StandardTensors<dim>::dev_P * c_bar *'
p22690
aS'               Physics::Elasticity::StandardTensors<dim>::dev_P;'
p22691
aS'    }'
p22692
aS'    SymmetricTensor<4, dim> get_c_bar() const'
p22693
aS'    {'
p22694
aS'      return SymmetricTensor<4, dim>();'
p22695
aS'    }'
p22696
aS'  };'
p22697
aS'  template <int dim>'
p22698
aS'  class PointHistory'
p22699
aS'  {'
p22700
aS'  public:'
p22701
aS'    PointHistory()'
p22702
aS'      : F_inv(Physics::Elasticity::StandardTensors<dim>::I)'
p22703
aS'      , tau(SymmetricTensor<2, dim>())'
p22704
aS'      , d2Psi_vol_dJ2(0.0)'
p22705
aS'      , dPsi_vol_dJ(0.0)'
p22706
aS'      , Jc(SymmetricTensor<4, dim>())'
p22707
aS'    {}'
p22708
aS'    virtual ~PointHistory() = default;'
p22709
aS'    void setup_lqp(const Parameters::AllParameters &parameters)'
p22710
aS'    {'
p22711
aS'      material ='
p22712
aS'        std::make_shared<Material_Compressible_Neo_Hook_Three_Field<dim>>('
p22713
aS'          parameters.mu, parameters.nu);'
p22714
aS'      update_values(Tensor<2, dim>(), 0.0, 1.0);'
p22715
aS'    }'
p22716
aS'    void update_values(const Tensor<2, dim> &Grad_u_n,'
p22717
aS'                       const double          p_tilde,'
p22718
aS'                       const double          J_tilde)'
p22719
aS'    {'
p22720
aS'      const Tensor<2, dim> F = Physics::Elasticity::Kinematics::F(Grad_u_n);'
p22721
aS'      material->update_material_data(F, p_tilde, J_tilde);'
p22722
aS'      F_inv         = invert(F);'
p22723
aS'      tau           = material->get_tau();'
p22724
aS'      Jc            = material->get_Jc();'
p22725
aS'      dPsi_vol_dJ   = material->get_dPsi_vol_dJ();'
p22726
aS'      d2Psi_vol_dJ2 = material->get_d2Psi_vol_dJ2();'
p22727
aS'    }'
p22728
aS'    double get_J_tilde() const'
p22729
aS'    {'
p22730
aS'      return material->get_J_tilde();'
p22731
aS'    }'
p22732
aS'    double get_det_F() const'
p22733
aS'    {'
p22734
aS'      return material->get_det_F();'
p22735
aS'    }'
p22736
aS'    const Tensor<2, dim> &get_F_inv() const'
p22737
aS'    {'
p22738
aS'      return F_inv;'
p22739
aS'    }'
p22740
aS'    double get_p_tilde() const'
p22741
aS'    {'
p22742
aS'      return material->get_p_tilde();'
p22743
aS'    }'
p22744
aS'    const SymmetricTensor<2, dim> &get_tau() const'
p22745
aS'    {'
p22746
aS'      return tau;'
p22747
aS'    }'
p22748
aS'    double get_dPsi_vol_dJ() const'
p22749
aS'    {'
p22750
aS'      return dPsi_vol_dJ;'
p22751
aS'    }'
p22752
aS'    double get_d2Psi_vol_dJ2() const'
p22753
aS'    {'
p22754
aS'      return d2Psi_vol_dJ2;'
p22755
aS'    }'
p22756
aS'    const SymmetricTensor<4, dim> &get_Jc() const'
p22757
aS'    {'
p22758
aS'      return Jc;'
p22759
aS'    }'
p22760
aS'  private:'
p22761
aS'    std::shared_ptr<Material_Compressible_Neo_Hook_Three_Field<dim>> material;'
p22762
aS'    Tensor<2, dim> F_inv;'
p22763
aS'    SymmetricTensor<2, dim> tau;'
p22764
aS'    double                  d2Psi_vol_dJ2;'
p22765
aS'    double                  dPsi_vol_dJ;'
p22766
aS'    SymmetricTensor<4, dim> Jc;'
p22767
aS'  };'
p22768
aS'  template <int dim>'
p22769
aS'  class Solid'
p22770
aS'  {'
p22771
aS'  public:'
p22772
aS'    Solid(const std::string &input_file);'
p22773
aS'    void run();'
p22774
aS'  private:'
p22775
aS'    struct PerTaskData_ASM;'
p22776
aS'    struct ScratchData_ASM;'
p22777
aS'    struct PerTaskData_SC;'
p22778
aS'    struct ScratchData_SC;'
p22779
aS'    struct PerTaskData_UQPH;'
p22780
aS'    struct ScratchData_UQPH;'
p22781
aS'    void make_grid();'
p22782
aS'    void system_setup();'
p22783
aS'    void determine_component_extractors();'
p22784
aS'    void make_constraints(const int it_nr);'
p22785
aS'    void assemble_system();'
p22786
aS'    void assemble_system_one_cell('
p22787
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p22788
aS'      ScratchData_ASM &                                     scratch,'
p22789
aS'      PerTaskData_ASM &                                     data) const;'
p22790
aS'    void assemble_sc();'
p22791
aS'    void assemble_sc_one_cell('
p22792
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p22793
aS'      ScratchData_SC &                                      scratch,'
p22794
aS'      PerTaskData_SC &                                      data);'
p22795
aS'    void copy_local_to_global_sc(const PerTaskData_SC &data);'
p22796
aS'    void setup_qph();'
p22797
aS'    void update_qph_incremental(const BlockVector<double> &solution_delta);'
p22798
aS'    void update_qph_incremental_one_cell('
p22799
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p22800
aS'      ScratchData_UQPH &                                    scratch,'
p22801
aS'      PerTaskData_UQPH &                                    data);'
p22802
aS'    void copy_local_to_global_UQPH(const PerTaskData_UQPH & /*data*/)'
p22803
aS'    {}'
p22804
aS'    void solve_nonlinear_timestep(BlockVector<double> &solution_delta);'
p22805
aS'    std::pair<unsigned int, double>'
p22806
aS'    solve_linear_system(BlockVector<double> &newton_update);'
p22807
aS'    BlockVector<double>'
p22808
aS'    get_total_solution(const BlockVector<double> &solution_delta) const;'
p22809
aS'    void output_results() const;'
p22810
aS'    Parameters::AllParameters parameters;'
p22811
aS'    double vol_reference;'
p22812
aS'    Triangulation<dim> triangulation;'
p22813
aS'    Time                time;'
p22814
aS'    mutable TimerOutput timer;'
p22815
aS'    CellDataStorage<typename Triangulation<dim>::cell_iterator,'
p22816
aS'                    PointHistory<dim>>'
p22817
aS'      quadrature_point_history;'
p22818
aS'    const unsigned int               degree;'
p22819
aS'    const FESystem<dim>              fe;'
p22820
aS'    DoFHandler<dim>                  dof_handler;'
p22821
aS'    const unsigned int               dofs_per_cell;'
p22822
aS'    const FEValuesExtractors::Vector u_fe;'
p22823
aS'    const FEValuesExtractors::Scalar p_fe;'
p22824
aS'    const FEValuesExtractors::Scalar J_fe;'
p22825
aS'    static const unsigned int n_blocks          = 3;'
p22826
aS'    static const unsigned int n_components      = dim + 2;'
p22827
aS'    static const unsigned int first_u_component = 0;'
p22828
aS'    static const unsigned int p_component       = dim;'
p22829
aS'    static const unsigned int J_component       = dim + 1;'
p22830
aS'    enum'
p22831
aS'    {'
p22832
aS'      u_dof = 0,'
p22833
aS'      p_dof = 1,'
p22834
aS'      J_dof = 2'
p22835
aS'    };'
p22836
aS'    std::vector<types::global_dof_index> dofs_per_block;'
p22837
aS'    std::vector<types::global_dof_index> element_indices_u;'
p22838
aS'    std::vector<types::global_dof_index> element_indices_p;'
p22839
aS'    std::vector<types::global_dof_index> element_indices_J;'
p22840
aS'    const QGauss<dim>     qf_cell;'
p22841
aS'    const QGauss<dim - 1> qf_face;'
p22842
aS'    const unsigned int    n_q_points;'
p22843
aS'    const unsigned int    n_q_points_f;'
p22844
aS'    AffineConstraints<double> constraints;'
p22845
aS'    BlockSparsityPattern      sparsity_pattern;'
p22846
aS'    BlockSparseMatrix<double> tangent_matrix;'
p22847
aS'    BlockVector<double>       system_rhs;'
p22848
aS'    BlockVector<double>       solution_n;'
p22849
aS'    struct Errors'
p22850
aS'    {'
p22851
aS'      Errors()'
p22852
aS'        : norm(1.0)'
p22853
aS'        , u(1.0)'
p22854
aS'        , p(1.0)'
p22855
aS'        , J(1.0)'
p22856
aS'      {}'
p22857
aS'      void reset()'
p22858
aS'      {'
p22859
aS'        norm = 1.0;'
p22860
aS'        u    = 1.0;'
p22861
aS'        p    = 1.0;'
p22862
aS'        J    = 1.0;'
p22863
aS'      }'
p22864
aS'      void normalize(const Errors &rhs)'
p22865
aS'      {'
p22866
aS'        if (rhs.norm != 0.0)'
p22867
aS'          norm /= rhs.norm;'
p22868
aS'        if (rhs.u != 0.0)'
p22869
aS'          u /= rhs.u;'
p22870
aS'        if (rhs.p != 0.0)'
p22871
aS'          p /= rhs.p;'
p22872
aS'        if (rhs.J != 0.0)'
p22873
aS'          J /= rhs.J;'
p22874
aS'      }'
p22875
aS'      double norm, u, p, J;'
p22876
aS'    };'
p22877
aS'    Errors error_residual, error_residual_0, error_residual_norm, error_update,'
p22878
aS'      error_update_0, error_update_norm;'
p22879
aS'    void get_error_residual(Errors &error_residual);'
p22880
aS'    void get_error_update(const BlockVector<double> &newton_update,'
p22881
aS'                          Errors &                   error_update);'
p22882
aS'    std::pair<double, double> get_error_dilation() const;'
p22883
aS'    double compute_vol_current() const;'
p22884
aS'    static void print_conv_header();'
p22885
aS'    void print_conv_footer();'
p22886
aS'  };'
p22887
aS'  template <int dim>'
p22888
aS'  Solid<dim>::Solid(const std::string &input_file)'
p22889
aS'    : parameters(input_file)'
p22890
aS'    , vol_reference(0.)'
p22891
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p22892
aS'    , time(parameters.end_time, parameters.delta_t)'
p22893
aS'    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)'
p22894
aS'    , degree(parameters.poly_degree)'
p22895
aS'    ,'
p22896
aS'    fe(FE_Q<dim>(parameters.poly_degree),'
p22897
aS'       dim, // displacement'
p22898
aS'       FE_DGPMonomial<dim>(parameters.poly_degree - 1),'
p22899
aS'       1, // pressure'
p22900
aS'       FE_DGPMonomial<dim>(parameters.poly_degree - 1),'
p22901
aS'       1)'
p22902
aS'    , // dilatation'
p22903
aS'    dof_handler(triangulation)'
p22904
aS'    , dofs_per_cell(fe.n_dofs_per_cell())'
p22905
aS'    , u_fe(first_u_component)'
p22906
aS'    , p_fe(p_component)'
p22907
aS'    , J_fe(J_component)'
p22908
aS'    , dofs_per_block(n_blocks)'
p22909
aS'    , qf_cell(parameters.quad_order)'
p22910
aS'    , qf_face(parameters.quad_order)'
p22911
aS'    , n_q_points(qf_cell.size())'
p22912
aS'    , n_q_points_f(qf_face.size())'
p22913
aS'  {'
p22914
aS'    Assert(dim == 2 || dim == 3,'
p22915
aS'           ExcMessage("This problem only works in 2 or 3 space dimensions."));'
p22916
aS'    determine_component_extractors();'
p22917
aS'  }'
p22918
aS'  template <int dim>'
p22919
aS'  void Solid<dim>::run()'
p22920
aS'  {'
p22921
aS'    make_grid();'
p22922
aS'    system_setup();'
p22923
aS'    {'
p22924
aS'      AffineConstraints<double> constraints;'
p22925
aS'      constraints.close();'
p22926
aS'      const ComponentSelectFunction<dim> J_mask(J_component, n_components);'
p22927
aS'      VectorTools::project('
p22928
aS'        dof_handler, constraints, QGauss<dim>(degree + 2), J_mask, solution_n);'
p22929
aS'    }'
p22930
aS'    output_results();'
p22931
aS'    time.increment();'
p22932
aS'    BlockVector<double> solution_delta(dofs_per_block);'
p22933
aS'    while (time.current() < time.end())'
p22934
aS'      {'
p22935
aS'        solution_delta = 0.0;'
p22936
aS'        solve_nonlinear_timestep(solution_delta);'
p22937
aS'        solution_n += solution_delta;'
p22938
aS'        output_results();'
p22939
aS'        time.increment();'
p22940
aS'      }'
p22941
aS'  }'
p22942
aS'  template <int dim>'
p22943
aS'  struct Solid<dim>::PerTaskData_ASM'
p22944
aS'  {'
p22945
aS'    FullMatrix<double>                   cell_matrix;'
p22946
aS'    Vector<double>                       cell_rhs;'
p22947
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p22948
aS'    PerTaskData_ASM(const unsigned int dofs_per_cell)'
p22949
aS'      : cell_matrix(dofs_per_cell, dofs_per_cell)'
p22950
aS'      , cell_rhs(dofs_per_cell)'
p22951
aS'      , local_dof_indices(dofs_per_cell)'
p22952
aS'    {}'
p22953
aS'    void reset()'
p22954
aS'    {'
p22955
aS'      cell_matrix = 0.0;'
p22956
aS'      cell_rhs    = 0.0;'
p22957
aS'    }'
p22958
aS'  };'
p22959
aS'  template <int dim>'
p22960
aS'  struct Solid<dim>::ScratchData_ASM'
p22961
aS'  {'
p22962
aS'    FEValues<dim>     fe_values;'
p22963
aS'    FEFaceValues<dim> fe_face_values;'
p22964
aS'    std::vector<std::vector<double>>                  Nx;'
p22965
aS'    std::vector<std::vector<Tensor<2, dim>>>          grad_Nx;'
p22966
aS'    std::vector<std::vector<SymmetricTensor<2, dim>>> symm_grad_Nx;'
p22967
aS'    ScratchData_ASM(const FiniteElement<dim> &fe_cell,'
p22968
aS'                    const QGauss<dim> &       qf_cell,'
p22969
aS'                    const UpdateFlags         uf_cell,'
p22970
aS'                    const QGauss<dim - 1> &   qf_face,'
p22971
aS'                    const UpdateFlags         uf_face)'
p22972
aS'      : fe_values(fe_cell, qf_cell, uf_cell)'
p22973
aS'      , fe_face_values(fe_cell, qf_face, uf_face)'
p22974
aS'      , Nx(qf_cell.size(), std::vector<double>(fe_cell.n_dofs_per_cell()))'
p22975
aS'      , grad_Nx(qf_cell.size(),'
p22976
aS'                std::vector<Tensor<2, dim>>(fe_cell.n_dofs_per_cell()))'
p22977
aS'      , symm_grad_Nx(qf_cell.size(),'
p22978
aS'                     std::vector<SymmetricTensor<2, dim>>('
p22979
aS'                       fe_cell.n_dofs_per_cell()))'
p22980
aS'    {}'
p22981
aS'    ScratchData_ASM(const ScratchData_ASM &rhs)'
p22982
aS'      : fe_values(rhs.fe_values.get_fe(),'
p22983
aS'                  rhs.fe_values.get_quadrature(),'
p22984
aS'                  rhs.fe_values.get_update_flags())'
p22985
aS'      , fe_face_values(rhs.fe_face_values.get_fe(),'
p22986
aS'                       rhs.fe_face_values.get_quadrature(),'
p22987
aS'                       rhs.fe_face_values.get_update_flags())'
p22988
aS'      , Nx(rhs.Nx)'
p22989
aS'      , grad_Nx(rhs.grad_Nx)'
p22990
aS'      , symm_grad_Nx(rhs.symm_grad_Nx)'
p22991
aS'    {}'
p22992
aS'    void reset()'
p22993
aS'    {'
p22994
aS'      const unsigned int n_q_points      = Nx.size();'
p22995
aS'      const unsigned int n_dofs_per_cell = Nx[0].size();'
p22996
aS'      for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p22997
aS'        {'
p22998
aS'          Assert(Nx[q_point].size() == n_dofs_per_cell, ExcInternalError());'
p22999
aS'          Assert(grad_Nx[q_point].size() == n_dofs_per_cell,'
p23000
aS'                 ExcInternalError());'
p23001
aS'          Assert(symm_grad_Nx[q_point].size() == n_dofs_per_cell,'
p23002
aS'                 ExcInternalError());'
p23003
aS'          for (unsigned int k = 0; k < n_dofs_per_cell; ++k)'
p23004
aS'            {'
p23005
aS'              Nx[q_point][k]           = 0.0;'
p23006
aS'              grad_Nx[q_point][k]      = 0.0;'
p23007
aS'              symm_grad_Nx[q_point][k] = 0.0;'
p23008
aS'            }'
p23009
aS'        }'
p23010
aS'    }'
p23011
aS'  };'
p23012
aS'  template <int dim>'
p23013
aS'  struct Solid<dim>::PerTaskData_SC'
p23014
aS'  {'
p23015
aS'    FullMatrix<double>                   cell_matrix;'
p23016
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p23017
aS'    FullMatrix<double> k_orig;'
p23018
aS'    FullMatrix<double> k_pu;'
p23019
aS'    FullMatrix<double> k_pJ;'
p23020
aS'    FullMatrix<double> k_JJ;'
p23021
aS'    FullMatrix<double> k_pJ_inv;'
p23022
aS'    FullMatrix<double> k_bbar;'
p23023
aS'    FullMatrix<double> A;'
p23024
aS'    FullMatrix<double> B;'
p23025
aS'    FullMatrix<double> C;'
p23026
aS'    PerTaskData_SC(const unsigned int dofs_per_cell,'
p23027
aS'                   const unsigned int n_u,'
p23028
aS'                   const unsigned int n_p,'
p23029
aS'                   const unsigned int n_J)'
p23030
aS'      : cell_matrix(dofs_per_cell, dofs_per_cell)'
p23031
aS'      , local_dof_indices(dofs_per_cell)'
p23032
aS'      , k_orig(dofs_per_cell, dofs_per_cell)'
p23033
aS'      , k_pu(n_p, n_u)'
p23034
aS'      , k_pJ(n_p, n_J)'
p23035
aS'      , k_JJ(n_J, n_J)'
p23036
aS'      , k_pJ_inv(n_p, n_J)'
p23037
aS'      , k_bbar(n_u, n_u)'
p23038
aS'      , A(n_J, n_u)'
p23039
aS'      , B(n_J, n_u)'
p23040
aS'      , C(n_p, n_u)'
p23041
aS'    {}'
p23042
aS'    void reset()'
p23043
aS'    {}'
p23044
aS'  };'
p23045
aS'  template <int dim>'
p23046
aS'  struct Solid<dim>::ScratchData_SC'
p23047
aS'  {'
p23048
aS'    void reset()'
p23049
aS'    {}'
p23050
aS'  };'
p23051
aS'  template <int dim>'
p23052
aS'  struct Solid<dim>::PerTaskData_UQPH'
p23053
aS'  {'
p23054
aS'    void reset()'
p23055
aS'    {}'
p23056
aS'  };'
p23057
aS'  template <int dim>'
p23058
aS'  struct Solid<dim>::ScratchData_UQPH'
p23059
aS'  {'
p23060
aS'    const BlockVector<double> &solution_total;'
p23061
aS'    std::vector<Tensor<2, dim>> solution_grads_u_total;'
p23062
aS'    std::vector<double>         solution_values_p_total;'
p23063
aS'    std::vector<double>         solution_values_J_total;'
p23064
aS'    FEValues<dim> fe_values;'
p23065
aS'    ScratchData_UQPH(const FiniteElement<dim> & fe_cell,'
p23066
aS'                     const QGauss<dim> &        qf_cell,'
p23067
aS'                     const UpdateFlags          uf_cell,'
p23068
aS'                     const BlockVector<double> &solution_total)'
p23069
aS'      : solution_total(solution_total)'
p23070
aS'      , solution_grads_u_total(qf_cell.size())'
p23071
aS'      , solution_values_p_total(qf_cell.size())'
p23072
aS'      , solution_values_J_total(qf_cell.size())'
p23073
aS'      , fe_values(fe_cell, qf_cell, uf_cell)'
p23074
aS'    {}'
p23075
aS'    ScratchData_UQPH(const ScratchData_UQPH &rhs)'
p23076
aS'      : solution_total(rhs.solution_total)'
p23077
aS'      , solution_grads_u_total(rhs.solution_grads_u_total)'
p23078
aS'      , solution_values_p_total(rhs.solution_values_p_total)'
p23079
aS'      , solution_values_J_total(rhs.solution_values_J_total)'
p23080
aS'      , fe_values(rhs.fe_values.get_fe(),'
p23081
aS'                  rhs.fe_values.get_quadrature(),'
p23082
aS'                  rhs.fe_values.get_update_flags())'
p23083
aS'    {}'
p23084
aS'    void reset()'
p23085
aS'    {'
p23086
aS'      const unsigned int n_q_points = solution_grads_u_total.size();'
p23087
aS'      for (unsigned int q = 0; q < n_q_points; ++q)'
p23088
aS'        {'
p23089
aS'          solution_grads_u_total[q]  = 0.0;'
p23090
aS'          solution_values_p_total[q] = 0.0;'
p23091
aS'          solution_values_J_total[q] = 0.0;'
p23092
aS'        }'
p23093
aS'    }'
p23094
aS'  };'
p23095
aS'  template <int dim>'
p23096
aS'  void Solid<dim>::make_grid()'
p23097
aS'  {'
p23098
aS'    GridGenerator::hyper_rectangle('
p23099
aS'      triangulation,'
p23100
aS'      true);'
p23101
aS'    GridTools::scale(parameters.scale, triangulation);'
p23102
aS'    triangulation.refine_global(std::max(1U, parameters.global_refinement));'
p23103
aS'    vol_reference = GridTools::volume(triangulation);'
p23104
aS'    std::cout << "Grid:\\n\\t Reference volume: " << vol_reference << std::endl;'
p23105
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p23106
aS'      for (const auto &face : cell->face_iterators())'
p23107
aS'        {'
p23108
aS'          if (face->at_boundary() == true &&'
p23109
aS'              face->center()[1] == 1.0 * parameters.scale)'
p23110
aS'            {'
p23111
aS'              if (dim == 3)'
p23112
aS'                {'
p23113
aS'                  if (face->center()[0] < 0.5 * parameters.scale &&'
p23114
aS'                      face->center()[2] < 0.5 * parameters.scale)'
p23115
aS'                    face->set_boundary_id(6);'
p23116
aS'                }'
p23117
aS'              else'
p23118
aS'                {'
p23119
aS'                  if (face->center()[0] < 0.5 * parameters.scale)'
p23120
aS'                    face->set_boundary_id(6);'
p23121
aS'                }'
p23122
aS'            }'
p23123
aS'        }'
p23124
aS'  }'
p23125
aS'  template <int dim>'
p23126
aS'  void Solid<dim>::system_setup()'
p23127
aS'  {'
p23128
aS'    timer.enter_subsection("Setup system");'
p23129
aS'    std::vector<unsigned int> block_component(n_components,'
p23130
aS'                                              u_dof); // Displacement'
p23131
aS'    block_component[p_component] = p_dof;             // Pressure'
p23132
aS'    block_component[J_component] = J_dof;             // Dilatation'
p23133
aS'    dof_handler.distribute_dofs(fe);'
p23134
aS'    DoFRenumbering::Cuthill_McKee(dof_handler);'
p23135
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p23136
aS'    dofs_per_block ='
p23137
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p23138
aS'    std::cout << "Triangulation:"'
p23139
aS'              << "\\n\\t Number of active cells: "'
p23140
aS'              << triangulation.n_active_cells()'
p23141
aS'              << "\\n\\t Number of degrees of freedom: " << dof_handler.n_dofs()'
p23142
aS'              << std::endl;'
p23143
aS'    tangent_matrix.clear();'
p23144
aS'    {'
p23145
aS'      const types::global_dof_index n_dofs_u = dofs_per_block[u_dof];'
p23146
aS'      const types::global_dof_index n_dofs_p = dofs_per_block[p_dof];'
p23147
aS'      const types::global_dof_index n_dofs_J = dofs_per_block[J_dof];'
p23148
aS'      BlockDynamicSparsityPattern dsp(n_blocks, n_blocks);'
p23149
aS'      dsp.block(u_dof, u_dof).reinit(n_dofs_u, n_dofs_u);'
p23150
aS'      dsp.block(u_dof, p_dof).reinit(n_dofs_u, n_dofs_p);'
p23151
aS'      dsp.block(u_dof, J_dof).reinit(n_dofs_u, n_dofs_J);'
p23152
aS'      dsp.block(p_dof, u_dof).reinit(n_dofs_p, n_dofs_u);'
p23153
aS'      dsp.block(p_dof, p_dof).reinit(n_dofs_p, n_dofs_p);'
p23154
aS'      dsp.block(p_dof, J_dof).reinit(n_dofs_p, n_dofs_J);'
p23155
aS'      dsp.block(J_dof, u_dof).reinit(n_dofs_J, n_dofs_u);'
p23156
aS'      dsp.block(J_dof, p_dof).reinit(n_dofs_J, n_dofs_p);'
p23157
aS'      dsp.block(J_dof, J_dof).reinit(n_dofs_J, n_dofs_J);'
p23158
aS'      dsp.collect_sizes();'
p23159
aS'      Table<2, DoFTools::Coupling> coupling(n_components, n_components);'
p23160
aS'      for (unsigned int ii = 0; ii < n_components; ++ii)'
p23161
aS'        for (unsigned int jj = 0; jj < n_components; ++jj)'
p23162
aS'          if (((ii < p_component) && (jj == J_component)) ||'
p23163
aS'            coupling[ii][jj] = DoFTools::none;'
p23164
aS'          else'
p23165
aS'            coupling[ii][jj] = DoFTools::always;'
p23166
aS'      DoFTools::make_sparsity_pattern('
p23167
aS'        dof_handler, coupling, dsp, constraints, false);'
p23168
aS'      sparsity_pattern.copy_from(dsp);'
p23169
aS'    }'
p23170
aS'    tangent_matrix.reinit(sparsity_pattern);'
p23171
aS'    system_rhs.reinit(dofs_per_block);'
p23172
aS'    system_rhs.collect_sizes();'
p23173
aS'    solution_n.reinit(dofs_per_block);'
p23174
aS'    solution_n.collect_sizes();'
p23175
aS'    setup_qph();'
p23176
aS'    timer.leave_subsection();'
p23177
aS'  }'
p23178
aS'  template <int dim>'
p23179
aS'  void Solid<dim>::determine_component_extractors()'
p23180
aS'  {'
p23181
aS'    element_indices_u.clear();'
p23182
aS'    element_indices_p.clear();'
p23183
aS'    element_indices_J.clear();'
p23184
aS'    for (unsigned int k = 0; k < fe.n_dofs_per_cell(); ++k)'
p23185
aS'      {'
p23186
aS'        const unsigned int k_group = fe.system_to_base_index(k).first.first;'
p23187
aS'        if (k_group == u_dof)'
p23188
aS'          element_indices_u.push_back(k);'
p23189
aS'        else if (k_group == p_dof)'
p23190
aS'          element_indices_p.push_back(k);'
p23191
aS'        else if (k_group == J_dof)'
p23192
aS'          element_indices_J.push_back(k);'
p23193
aS'        else'
p23194
aS'          {'
p23195
aS'            Assert(k_group <= J_dof, ExcInternalError());'
p23196
aS'          }'
p23197
aS'      }'
p23198
aS'  }'
p23199
aS'  template <int dim>'
p23200
aS'  void Solid<dim>::setup_qph()'
p23201
aS'  {'
p23202
aS'    std::cout << "    Setting up quadrature point data..." << std::endl;'
p23203
aS'    quadrature_point_history.initialize(triangulation.begin_active(),'
p23204
aS'                                        triangulation.end(),'
p23205
aS'                                        n_q_points);'
p23206
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p23207
aS'      {'
p23208
aS'        const std::vector<std::shared_ptr<PointHistory<dim>>> lqph ='
p23209
aS'          quadrature_point_history.get_data(cell);'
p23210
aS'        Assert(lqph.size() == n_q_points, ExcInternalError());'
p23211
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p23212
aS'          lqph[q_point]->setup_lqp(parameters);'
p23213
aS'      }'
p23214
aS'  }'
p23215
aS'  template <int dim>'
p23216
aS'  void'
p23217
aS'  Solid<dim>::update_qph_incremental(const BlockVector<double> &solution_delta)'
p23218
aS'  {'
p23219
aS'    timer.enter_subsection("Update QPH data");'
p23220
aS'    std::cout << " UQPH " << std::flush;'
p23221
aS'    const BlockVector<double> solution_total('
p23222
aS'      get_total_solution(solution_delta));'
p23223
aS'    const UpdateFlags uf_UQPH(update_values | update_gradients);'
p23224
aS'    PerTaskData_UQPH  per_task_data_UQPH;'
p23225
aS'    ScratchData_UQPH  scratch_data_UQPH(fe, qf_cell, uf_UQPH, solution_total);'
p23226
aS'    WorkStream::run(dof_handler.active_cell_iterators(),'
p23227
aS'                    &Solid::update_qph_incremental_one_cell,'
p23228
aS'                    &Solid::copy_local_to_global_UQPH,'
p23229
aS'                    scratch_data_UQPH,'
p23230
aS'                    per_task_data_UQPH);'
p23231
aS'    timer.leave_subsection();'
p23232
aS'  }'
p23233
aS'  template <int dim>'
p23234
aS'  void Solid<dim>::update_qph_incremental_one_cell('
p23235
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23236
aS'    ScratchData_UQPH &                                    scratch,'
p23237
aS'    PerTaskData_UQPH & /*data*/)'
p23238
aS'  {'
p23239
aS'    const std::vector<std::shared_ptr<PointHistory<dim>>> lqph ='
p23240
aS'      quadrature_point_history.get_data(cell);'
p23241
aS'    Assert(lqph.size() == n_q_points, ExcInternalError());'
p23242
aS'    Assert(scratch.solution_grads_u_total.size() == n_q_points,'
p23243
aS'           ExcInternalError());'
p23244
aS'    Assert(scratch.solution_values_p_total.size() == n_q_points,'
p23245
aS'           ExcInternalError());'
p23246
aS'    Assert(scratch.solution_values_J_total.size() == n_q_points,'
p23247
aS'           ExcInternalError());'
p23248
aS'    scratch.reset();'
p23249
aS'    scratch.fe_values.reinit(cell);'
p23250
aS'    scratch.fe_values[u_fe].get_function_gradients('
p23251
aS'      scratch.solution_total, scratch.solution_grads_u_total);'
p23252
aS'    scratch.fe_values[p_fe].get_function_values('
p23253
aS'      scratch.solution_total, scratch.solution_values_p_total);'
p23254
aS'    scratch.fe_values[J_fe].get_function_values('
p23255
aS'      scratch.solution_total, scratch.solution_values_J_total);'
p23256
aS'    for (const unsigned int q_point :'
p23257
aS'         scratch.fe_values.quadrature_point_indices())'
p23258
aS'      lqph[q_point]->update_values(scratch.solution_grads_u_total[q_point],'
p23259
aS'                                   scratch.solution_values_p_total[q_point],'
p23260
aS'                                   scratch.solution_values_J_total[q_point]);'
p23261
aS'  }'
p23262
aS'  template <int dim>'
p23263
aS'  void Solid<dim>::solve_nonlinear_timestep(BlockVector<double> &solution_delta)'
p23264
aS'  {'
p23265
aS'    std::cout << std::endl'
p23266
aS'              << "Timestep " << time.get_timestep() << " @ " << time.current()'
p23267
aS'              << "s" << std::endl;'
p23268
aS'    BlockVector<double> newton_update(dofs_per_block);'
p23269
aS'    error_residual.reset();'
p23270
aS'    error_residual_0.reset();'
p23271
aS'    error_residual_norm.reset();'
p23272
aS'    error_update.reset();'
p23273
aS'    error_update_0.reset();'
p23274
aS'    error_update_norm.reset();'
p23275
aS'    print_conv_header();'
p23276
aS'    unsigned int newton_iteration = 0;'
p23277
aS'    for (; newton_iteration < parameters.max_iterations_NR; ++newton_iteration)'
p23278
aS'      {'
p23279
aS'        std::cout << " " << std::setw(2) << newton_iteration << " "'
p23280
aS'                  << std::flush;'
p23281
aS'        make_constraints(newton_iteration);'
p23282
aS'        assemble_system();'
p23283
aS'        get_error_residual(error_residual);'
p23284
aS'        if (newton_iteration == 0)'
p23285
aS'          error_residual_0 = error_residual;'
p23286
aS'        error_residual_norm = error_residual;'
p23287
aS'        error_residual_norm.normalize(error_residual_0);'
p23288
aS'        if (newton_iteration > 0 && error_update_norm.u <= parameters.tol_u &&'
p23289
aS'            error_residual_norm.u <= parameters.tol_f)'
p23290
aS'          {'
p23291
aS'            std::cout << " CONVERGED! " << std::endl;'
p23292
aS'            print_conv_footer();'
p23293
aS'            break;'
p23294
aS'          }'
p23295
aS'        const std::pair<unsigned int, double> lin_solver_output ='
p23296
aS'          solve_linear_system(newton_update);'
p23297
aS'        get_error_update(newton_update, error_update);'
p23298
aS'        if (newton_iteration == 0)'
p23299
aS'          error_update_0 = error_update;'
p23300
aS'        error_update_norm = error_update;'
p23301
aS'        error_update_norm.normalize(error_update_0);'
p23302
aS'        solution_delta += newton_update;'
p23303
aS'        update_qph_incremental(solution_delta);'
p23304
aS'        std::cout << " | " << std::fixed << std::setprecision(3) << std::setw(7)'
p23305
aS'                  << std::scientific << lin_solver_output.first << "  "'
p23306
aS'                  << lin_solver_output.second << "  "'
p23307
aS'                  << error_residual_norm.norm << "  " << error_residual_norm.u'
p23308
aS'                  << "  " << error_residual_norm.p << "  "'
p23309
aS'                  << error_residual_norm.J << "  " << error_update_norm.norm'
p23310
aS'                  << "  " << error_update_norm.u << "  " << error_update_norm.p'
p23311
aS'                  << "  " << error_update_norm.J << "  " << std::endl;'
p23312
aS'      }'
p23313
aS'    AssertThrow(newton_iteration < parameters.max_iterations_NR,'
p23314
aS'                ExcMessage("No convergence in nonlinear solver!"));'
p23315
aS'  }'
p23316
aS'  template <int dim>'
p23317
aS'  void Solid<dim>::print_conv_header()'
p23318
aS'  {'
p23319
aS'    static const unsigned int l_width = 150;'
p23320
aS'    for (unsigned int i = 0; i < l_width; ++i)'
p23321
aS'      std::cout << "_";'
p23322
aS'    std::cout << std::endl;'
p23323
aS'    std::cout << "               SOLVER STEP               "'
p23324
aS'              << " |  LIN_IT   LIN_RES    RES_NORM    "'
p23325
aS'              << " RES_U     RES_P      RES_J     NU_NORM     "'
p23326
aS'              << " NU_U       NU_P       NU_J " << std::endl;'
p23327
aS'    for (unsigned int i = 0; i < l_width; ++i)'
p23328
aS'      std::cout << "_";'
p23329
aS'    std::cout << std::endl;'
p23330
aS'  }'
p23331
aS'  template <int dim>'
p23332
aS'  void Solid<dim>::print_conv_footer()'
p23333
aS'  {'
p23334
aS'    static const unsigned int l_width = 150;'
p23335
aS'    for (unsigned int i = 0; i < l_width; ++i)'
p23336
aS'      std::cout << "_";'
p23337
aS'    std::cout << std::endl;'
p23338
aS'    const std::pair<double, double> error_dil = get_error_dilation();'
p23339
aS'    std::cout << "Relative errors:" << std::endl'
p23340
aS'              << "Displacement:\\t" << error_update.u / error_update_0.u'
p23341
aS'              << std::endl'
p23342
aS'              << "Force: \\t\\t" << error_residual.u / error_residual_0.u'
p23343
aS'              << std::endl'
p23344
aS'              << "Dilatation:\\t" << error_dil.first << std::endl'
p23345
aS'              << "v / V_0:\\t" << error_dil.second * vol_reference << " / "'
p23346
aS'              << vol_reference << " = " << error_dil.second << std::endl;'
p23347
aS'  }'
p23348
aS'  template <int dim>'
p23349
aS'  double Solid<dim>::compute_vol_current() const'
p23350
aS'  {'
p23351
aS'    double vol_current = 0.0;'
p23352
aS'    FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);'
p23353
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p23354
aS'      {'
p23355
aS'        fe_values.reinit(cell);'
p23356
aS'        const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph ='
p23357
aS'          quadrature_point_history.get_data(cell);'
p23358
aS'        Assert(lqph.size() == n_q_points, ExcInternalError());'
p23359
aS'        for (const unsigned int q_point : fe_values.quadrature_point_indices())'
p23360
aS'          {'
p23361
aS'            const double det_F_qp = lqph[q_point]->get_det_F();'
p23362
aS'            const double JxW      = fe_values.JxW(q_point);'
p23363
aS'            vol_current += det_F_qp * JxW;'
p23364
aS'          }'
p23365
aS'      }'
p23366
aS'    Assert(vol_current > 0.0, ExcInternalError());'
p23367
aS'    return vol_current;'
p23368
aS'  }'
p23369
aS'  template <int dim>'
p23370
aS'  std::pair<double, double> Solid<dim>::get_error_dilation() const'
p23371
aS'  {'
p23372
aS'    double dil_L2_error = 0.0;'
p23373
aS'    FEValues<dim> fe_values(fe, qf_cell, update_JxW_values);'
p23374
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p23375
aS'      {'
p23376
aS'        fe_values.reinit(cell);'
p23377
aS'        const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph ='
p23378
aS'          quadrature_point_history.get_data(cell);'
p23379
aS'        Assert(lqph.size() == n_q_points, ExcInternalError());'
p23380
aS'        for (const unsigned int q_point : fe_values.quadrature_point_indices())'
p23381
aS'          {'
p23382
aS'            const double det_F_qp   = lqph[q_point]->get_det_F();'
p23383
aS'            const double J_tilde_qp = lqph[q_point]->get_J_tilde();'
p23384
aS'            const double the_error_qp_squared ='
p23385
aS'              std::pow((det_F_qp - J_tilde_qp), 2);'
p23386
aS'            const double JxW = fe_values.JxW(q_point);'
p23387
aS'            dil_L2_error += the_error_qp_squared * JxW;'
p23388
aS'          }'
p23389
aS'      }'
p23390
aS'    return std::make_pair(std::sqrt(dil_L2_error),'
p23391
aS'                          compute_vol_current() / vol_reference);'
p23392
aS'  }'
p23393
aS'  template <int dim>'
p23394
aS'  void Solid<dim>::get_error_residual(Errors &error_residual)'
p23395
aS'  {'
p23396
aS'    BlockVector<double> error_res(dofs_per_block);'
p23397
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p23398
aS'      if (!constraints.is_constrained(i))'
p23399
aS'        error_res(i) = system_rhs(i);'
p23400
aS'    error_residual.norm = error_res.l2_norm();'
p23401
aS'    error_residual.u    = error_res.block(u_dof).l2_norm();'
p23402
aS'    error_residual.p    = error_res.block(p_dof).l2_norm();'
p23403
aS'    error_residual.J    = error_res.block(J_dof).l2_norm();'
p23404
aS'  }'
p23405
aS'  template <int dim>'
p23406
aS'  void Solid<dim>::get_error_update(const BlockVector<double> &newton_update,'
p23407
aS'                                    Errors &                   error_update)'
p23408
aS'  {'
p23409
aS'    BlockVector<double> error_ud(dofs_per_block);'
p23410
aS'    for (unsigned int i = 0; i < dof_handler.n_dofs(); ++i)'
p23411
aS'      if (!constraints.is_constrained(i))'
p23412
aS'        error_ud(i) = newton_update(i);'
p23413
aS'    error_update.norm = error_ud.l2_norm();'
p23414
aS'    error_update.u    = error_ud.block(u_dof).l2_norm();'
p23415
aS'    error_update.p    = error_ud.block(p_dof).l2_norm();'
p23416
aS'    error_update.J    = error_ud.block(J_dof).l2_norm();'
p23417
aS'  }'
p23418
aS'  template <int dim>'
p23419
aS'  BlockVector<double> Solid<dim>::get_total_solution('
p23420
aS'    const BlockVector<double> &solution_delta) const'
p23421
aS'  {'
p23422
aS'    BlockVector<double> solution_total(solution_n);'
p23423
aS'    solution_total += solution_delta;'
p23424
aS'    return solution_total;'
p23425
aS'  }'
p23426
aS'  template <int dim>'
p23427
aS'  void Solid<dim>::assemble_system()'
p23428
aS'  {'
p23429
aS'    timer.enter_subsection("Assemble system");'
p23430
aS'    std::cout << " ASM_SYS " << std::flush;'
p23431
aS'    tangent_matrix = 0.0;'
p23432
aS'    system_rhs     = 0.0;'
p23433
aS'    const UpdateFlags uf_cell(update_values | update_gradients |'
p23434
aS'                              update_JxW_values);'
p23435
aS'    const UpdateFlags uf_face(update_values | update_normal_vectors |'
p23436
aS'                              update_JxW_values);'
p23437
aS'    PerTaskData_ASM per_task_data(dofs_per_cell);'
p23438
aS'    ScratchData_ASM scratch_data(fe, qf_cell, uf_cell, qf_face, uf_face);'
p23439
aS'    WorkStream::run('
p23440
aS'      dof_handler.active_cell_iterators(),'
p23441
aS'      [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23442
aS'             ScratchData_ASM &                                     scratch,'
p23443
aS'             PerTaskData_ASM &                                     data) {'
p23444
aS'        this->assemble_system_one_cell(cell, scratch, data);'
p23445
aS'      },'
p23446
aS'      [this](const PerTaskData_ASM &data) {'
p23447
aS'        this->constraints.distribute_local_to_global(data.cell_matrix,'
p23448
aS'                                                     data.cell_rhs,'
p23449
aS'                                                     data.local_dof_indices,'
p23450
aS'                                                     tangent_matrix,'
p23451
aS'                                                     system_rhs);'
p23452
aS'      },'
p23453
aS'      scratch_data,'
p23454
aS'      per_task_data);'
p23455
aS'    timer.leave_subsection();'
p23456
aS'  }'
p23457
aS'  template <int dim>'
p23458
aS'  void Solid<dim>::assemble_system_one_cell('
p23459
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23460
aS'    ScratchData_ASM &                                     scratch,'
p23461
aS'    PerTaskData_ASM &                                     data) const'
p23462
aS'  {'
p23463
aS'    data.reset();'
p23464
aS'    scratch.reset();'
p23465
aS'    scratch.fe_values.reinit(cell);'
p23466
aS'    cell->get_dof_indices(data.local_dof_indices);'
p23467
aS'    const std::vector<std::shared_ptr<const PointHistory<dim>>> lqph ='
p23468
aS'      quadrature_point_history.get_data(cell);'
p23469
aS'    Assert(lqph.size() == n_q_points, ExcInternalError());'
p23470
aS'    for (const unsigned int q_point :'
p23471
aS'         scratch.fe_values.quadrature_point_indices())'
p23472
aS'      {'
p23473
aS'        const Tensor<2, dim> F_inv = lqph[q_point]->get_F_inv();'
p23474
aS'        for (const unsigned int k : scratch.fe_values.dof_indices())'
p23475
aS'          {'
p23476
aS'            const unsigned int k_group = fe.system_to_base_index(k).first.first;'
p23477
aS'            if (k_group == u_dof)'
p23478
aS'              {'
p23479
aS'                scratch.grad_Nx[q_point][k] ='
p23480
aS'                  scratch.fe_values[u_fe].gradient(k, q_point) * F_inv;'
p23481
aS'                scratch.symm_grad_Nx[q_point][k] ='
p23482
aS'                  symmetrize(scratch.grad_Nx[q_point][k]);'
p23483
aS'              }'
p23484
aS'            else if (k_group == p_dof)'
p23485
aS'              scratch.Nx[q_point][k] ='
p23486
aS'                scratch.fe_values[p_fe].value(k, q_point);'
p23487
aS'            else if (k_group == J_dof)'
p23488
aS'              scratch.Nx[q_point][k] ='
p23489
aS'                scratch.fe_values[J_fe].value(k, q_point);'
p23490
aS'            else'
p23491
aS'              Assert(k_group <= J_dof, ExcInternalError());'
p23492
aS'          }'
p23493
aS'      }'
p23494
aS'    for (const unsigned int q_point :'
p23495
aS'         scratch.fe_values.quadrature_point_indices())'
p23496
aS'      {'
p23497
aS'        const SymmetricTensor<2, dim> tau     = lqph[q_point]->get_tau();'
p23498
aS'        const Tensor<2, dim>          tau_ns  = lqph[q_point]->get_tau();'
p23499
aS'        const SymmetricTensor<4, dim> Jc      = lqph[q_point]->get_Jc();'
p23500
aS'        const double                  det_F   = lqph[q_point]->get_det_F();'
p23501
aS'        const double                  p_tilde = lqph[q_point]->get_p_tilde();'
p23502
aS'        const double                  J_tilde = lqph[q_point]->get_J_tilde();'
p23503
aS'        const double dPsi_vol_dJ   = lqph[q_point]->get_dPsi_vol_dJ();'
p23504
aS'        const double d2Psi_vol_dJ2 = lqph[q_point]->get_d2Psi_vol_dJ2();'
p23505
aS'        const SymmetricTensor<2, dim> &I ='
p23506
aS'          Physics::Elasticity::StandardTensors<dim>::I;'
p23507
aS'        SymmetricTensor<2, dim> symm_grad_Nx_i_x_Jc;'
p23508
aS'        Tensor<1, dim>          grad_Nx_i_comp_i_x_tau;'
p23509
aS'        const std::vector<double> &                 N = scratch.Nx[q_point];'
p23510
aS'        const std::vector<SymmetricTensor<2, dim>> &symm_grad_Nx ='
p23511
aS'          scratch.symm_grad_Nx[q_point];'
p23512
aS'        const std::vector<Tensor<2, dim>> &grad_Nx = scratch.grad_Nx[q_point];'
p23513
aS'        const double                       JxW = scratch.fe_values.JxW(q_point);'
p23514
aS'        for (const unsigned int i : scratch.fe_values.dof_indices())'
p23515
aS'          {'
p23516
aS'            const unsigned int component_i ='
p23517
aS'              fe.system_to_component_index(i).first;'
p23518
aS'            const unsigned int i_group = fe.system_to_base_index(i).first.first;'
p23519
aS'            if (i_group == u_dof)'
p23520
aS'              data.cell_rhs(i) -= (symm_grad_Nx[i] * tau) * JxW;'
p23521
aS'            else if (i_group == p_dof)'
p23522
aS'              data.cell_rhs(i) -= N[i] * (det_F - J_tilde) * JxW;'
p23523
aS'            else if (i_group == J_dof)'
p23524
aS'              data.cell_rhs(i) -= N[i] * (dPsi_vol_dJ - p_tilde) * JxW;'
p23525
aS'            else'
p23526
aS'              Assert(i_group <= J_dof, ExcInternalError());'
p23527
aS'            if (i_group == u_dof)'
p23528
aS'              {'
p23529
aS'                symm_grad_Nx_i_x_Jc    = symm_grad_Nx[i] * Jc;'
p23530
aS'                grad_Nx_i_comp_i_x_tau = grad_Nx[i][component_i] * tau_ns;'
p23531
aS'              }'
p23532
aS'            for (const unsigned int j :'
p23533
aS'                 scratch.fe_values.dof_indices_ending_at(i))'
p23534
aS'              {'
p23535
aS'                const unsigned int component_j ='
p23536
aS'                  fe.system_to_component_index(j).first;'
p23537
aS'                const unsigned int j_group ='
p23538
aS'                  fe.system_to_base_index(j).first.first;'
p23539
aS'                if ((i_group == j_group) && (i_group == u_dof))'
p23540
aS'                  {'
p23541
aS'                    data.cell_matrix(i, j) += symm_grad_Nx_i_x_Jc *  //'
p23542
aS'                                              symm_grad_Nx[j] * JxW; //'
p23543
aS'                    if (component_i == component_j)'
p23544
aS'                      data.cell_matrix(i, j) +='
p23545
aS'                        grad_Nx_i_comp_i_x_tau * grad_Nx[j][component_j] * JxW;'
p23546
aS'                  }'
p23547
aS'                else if ((i_group == p_dof) && (j_group == u_dof))'
p23548
aS'                  {'
p23549
aS'                    data.cell_matrix(i, j) += N[i] * det_F *               //'
p23550
aS'                  }'
p23551
aS'                else if ((i_group == J_dof) && (j_group == p_dof))'
p23552
aS'                  data.cell_matrix(i, j) -= N[i] * N[j] * JxW;'
p23553
aS'                else if ((i_group == j_group) && (i_group == J_dof))'
p23554
aS'                  data.cell_matrix(i, j) += N[i] * d2Psi_vol_dJ2 * N[j] * JxW;'
p23555
aS'                else'
p23556
aS'                  Assert((i_group <= J_dof) && (j_group <= J_dof),'
p23557
aS'                         ExcInternalError());'
p23558
aS'              }'
p23559
aS'          }'
p23560
aS'      }'
p23561
aS'    for (const auto &face : cell->face_iterators())'
p23562
aS'      if (face->at_boundary() && face->boundary_id() == 6)'
p23563
aS'        {'
p23564
aS'          scratch.fe_face_values.reinit(cell, face);'
p23565
aS'          for (const unsigned int f_q_point :'
p23566
aS'               scratch.fe_face_values.quadrature_point_indices())'
p23567
aS'            {'
p23568
aS'              const Tensor<1, dim> &N ='
p23569
aS'                scratch.fe_face_values.normal_vector(f_q_point);'
p23570
aS'              static const double p0 ='
p23571
aS'                -4.0 / (parameters.scale * parameters.scale);'
p23572
aS'              const double         time_ramp = (time.current() / time.end());'
p23573
aS'              const double         pressure  = p0 * parameters.p_p0 * time_ramp;'
p23574
aS'              const Tensor<1, dim> traction  = pressure * N;'
p23575
aS'              for (const unsigned int i : scratch.fe_values.dof_indices())'
p23576
aS'                {'
p23577
aS'                  const unsigned int i_group ='
p23578
aS'                    fe.system_to_base_index(i).first.first;'
p23579
aS'                  if (i_group == u_dof)'
p23580
aS'                    {'
p23581
aS'                      const unsigned int component_i ='
p23582
aS'                        fe.system_to_component_index(i).first;'
p23583
aS'                      const double Ni ='
p23584
aS'                        scratch.fe_face_values.shape_value(i, f_q_point);'
p23585
aS'                      const double JxW = scratch.fe_face_values.JxW(f_q_point);'
p23586
aS'                      data.cell_rhs(i) += (Ni * traction[component_i]) * JxW;'
p23587
aS'                    }'
p23588
aS'                }'
p23589
aS'            }'
p23590
aS'        }'
p23591
aS'    for (const unsigned int i : scratch.fe_values.dof_indices())'
p23592
aS'      for (const unsigned int j :'
p23593
aS'           scratch.fe_values.dof_indices_starting_at(i + 1))'
p23594
aS'        data.cell_matrix(i, j) = data.cell_matrix(j, i);'
p23595
aS'  }'
p23596
aS'  template <int dim>'
p23597
aS'  void Solid<dim>::make_constraints(const int it_nr)'
p23598
aS'  {'
p23599
aS'    const bool apply_dirichlet_bc = (it_nr == 0);'
p23600
aS'    if (it_nr > 1)'
p23601
aS'      {'
p23602
aS'        std::cout << " --- " << std::flush;'
p23603
aS'        return;'
p23604
aS'      }'
p23605
aS'    std::cout << " CST " << std::flush;'
p23606
aS'    if (apply_dirichlet_bc)'
p23607
aS'      {'
p23608
aS'        constraints.clear();'
p23609
aS'        const FEValuesExtractors::Scalar x_displacement(0);'
p23610
aS'        const FEValuesExtractors::Scalar y_displacement(1);'
p23611
aS'        {'
p23612
aS'          const int boundary_id = 0;'
p23613
aS'          VectorTools::interpolate_boundary_values('
p23614
aS'            dof_handler,'
p23615
aS'            boundary_id,'
p23616
aS'            Functions::ZeroFunction<dim>(n_components),'
p23617
aS'            constraints,'
p23618
aS'            fe.component_mask(x_displacement));'
p23619
aS'        }'
p23620
aS'        {'
p23621
aS'          const int boundary_id = 2;'
p23622
aS'          VectorTools::interpolate_boundary_values('
p23623
aS'            dof_handler,'
p23624
aS'            boundary_id,'
p23625
aS'            Functions::ZeroFunction<dim>(n_components),'
p23626
aS'            constraints,'
p23627
aS'            fe.component_mask(y_displacement));'
p23628
aS'        }'
p23629
aS'        if (dim == 3)'
p23630
aS'          {'
p23631
aS'            const FEValuesExtractors::Scalar z_displacement(2);'
p23632
aS'            {'
p23633
aS'              const int boundary_id = 3;'
p23634
aS'              VectorTools::interpolate_boundary_values('
p23635
aS'                dof_handler,'
p23636
aS'                boundary_id,'
p23637
aS'                Functions::ZeroFunction<dim>(n_components),'
p23638
aS'                constraints,'
p23639
aS'                 fe.component_mask(z_displacement)));'
p23640
aS'            }'
p23641
aS'            {'
p23642
aS'              const int boundary_id = 4;'
p23643
aS'              VectorTools::interpolate_boundary_values('
p23644
aS'                dof_handler,'
p23645
aS'                boundary_id,'
p23646
aS'                Functions::ZeroFunction<dim>(n_components),'
p23647
aS'                constraints,'
p23648
aS'                fe.component_mask(z_displacement));'
p23649
aS'            }'
p23650
aS'            {'
p23651
aS'              const int boundary_id = 6;'
p23652
aS'              VectorTools::interpolate_boundary_values('
p23653
aS'                dof_handler,'
p23654
aS'                boundary_id,'
p23655
aS'                Functions::ZeroFunction<dim>(n_components),'
p23656
aS'                constraints,'
p23657
aS'                 fe.component_mask(z_displacement)));'
p23658
aS'            }'
p23659
aS'          }'
p23660
aS'        else'
p23661
aS'          {'
p23662
aS'            {'
p23663
aS'              const int boundary_id = 3;'
p23664
aS'              VectorTools::interpolate_boundary_values('
p23665
aS'                dof_handler,'
p23666
aS'                boundary_id,'
p23667
aS'                Functions::ZeroFunction<dim>(n_components),'
p23668
aS'                constraints,'
p23669
aS'            }'
p23670
aS'            {'
p23671
aS'              const int boundary_id = 6;'
p23672
aS'              VectorTools::interpolate_boundary_values('
p23673
aS'                dof_handler,'
p23674
aS'                boundary_id,'
p23675
aS'                Functions::ZeroFunction<dim>(n_components),'
p23676
aS'                constraints,'
p23677
aS'            }'
p23678
aS'          }'
p23679
aS'      }'
p23680
aS'    else'
p23681
aS'      {'
p23682
aS'        if (constraints.has_inhomogeneities())'
p23683
aS'          {'
p23684
aS'            AffineConstraints<double> homogeneous_constraints(constraints);'
p23685
aS'            for (unsigned int dof = 0; dof != dof_handler.n_dofs(); ++dof)'
p23686
aS'              if (homogeneous_constraints.is_inhomogeneously_constrained(dof))'
p23687
aS'                homogeneous_constraints.set_inhomogeneity(dof, 0.0);'
p23688
aS'            constraints.clear();'
p23689
aS'            constraints.copy_from(homogeneous_constraints);'
p23690
aS'          }'
p23691
aS'      }'
p23692
aS'    constraints.close();'
p23693
aS'  }'
p23694
aS'  template <int dim>'
p23695
aS'  void Solid<dim>::assemble_sc()'
p23696
aS'  {'
p23697
aS'    timer.enter_subsection("Perform static condensation");'
p23698
aS'    std::cout << " ASM_SC " << std::flush;'
p23699
aS'    PerTaskData_SC per_task_data(dofs_per_cell,'
p23700
aS'                                 element_indices_u.size(),'
p23701
aS'                                 element_indices_p.size(),'
p23702
aS'                                 element_indices_J.size());'
p23703
aS'    ScratchData_SC scratch_data;'
p23704
aS'    WorkStream::run(dof_handler.active_cell_iterators(),'
p23705
aS'                    &Solid::assemble_sc_one_cell,'
p23706
aS'                    &Solid::copy_local_to_global_sc,'
p23707
aS'                    scratch_data,'
p23708
aS'                    per_task_data);'
p23709
aS'    timer.leave_subsection();'
p23710
aS'  }'
p23711
aS'  template <int dim>'
p23712
aS'  void Solid<dim>::copy_local_to_global_sc(const PerTaskData_SC &data)'
p23713
aS'  {'
p23714
aS'    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p23715
aS'      for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p23716
aS'        tangent_matrix.add(data.local_dof_indices[i],'
p23717
aS'                           data.local_dof_indices[j],'
p23718
aS'                           data.cell_matrix(i, j));'
p23719
aS'  }'
p23720
aS'  template <int dim>'
p23721
aS'  void Solid<dim>::assemble_sc_one_cell('
p23722
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p23723
aS'    ScratchData_SC &                                      scratch,'
p23724
aS'    PerTaskData_SC &                                      data)'
p23725
aS'  {'
p23726
aS'    data.reset();'
p23727
aS'    scratch.reset();'
p23728
aS'    cell->get_dof_indices(data.local_dof_indices);'
p23729
aS'    data.k_orig.extract_submatrix_from(tangent_matrix,'
p23730
aS'                                       data.local_dof_indices,'
p23731
aS'                                       data.local_dof_indices);'
p23732
aS'    data.k_pu.extract_submatrix_from(data.k_orig,'
p23733
aS'                                     element_indices_p,'
p23734
aS'                                     element_indices_u);'
p23735
aS'    data.k_pJ.extract_submatrix_from(data.k_orig,'
p23736
aS'                                     element_indices_p,'
p23737
aS'                                     element_indices_J);'
p23738
aS'    data.k_JJ.extract_submatrix_from(data.k_orig,'
p23739
aS'                                     element_indices_J,'
p23740
aS'                                     element_indices_J);'
p23741
aS'    data.k_pJ_inv.invert(data.k_pJ);'
p23742
aS'    data.k_pJ_inv.mmult(data.A, data.k_pu);'
p23743
aS'    data.k_JJ.mmult(data.B, data.A);'
p23744
aS'    data.k_pJ_inv.Tmmult(data.C, data.B);'
p23745
aS'    data.k_pu.Tmmult(data.k_bbar, data.C);'
p23746
aS'    data.k_bbar.scatter_matrix_to(element_indices_u,'
p23747
aS'                                  element_indices_u,'
p23748
aS'                                  data.cell_matrix);'
p23749
aS'    data.k_pJ_inv.add(-1.0, data.k_pJ);'
p23750
aS'    data.k_pJ_inv.scatter_matrix_to(element_indices_p,'
p23751
aS'                                    element_indices_J,'
p23752
aS'                                    data.cell_matrix);'
p23753
aS'  }'
p23754
aS'  template <int dim>'
p23755
aS'  std::pair<unsigned int, double>'
p23756
aS'  Solid<dim>::solve_linear_system(BlockVector<double> &newton_update)'
p23757
aS'  {'
p23758
aS'    unsigned int lin_it  = 0;'
p23759
aS'    double       lin_res = 0.0;'
p23760
aS'    if (parameters.use_static_condensation == true)'
p23761
aS'      {'
p23762
aS'        BlockVector<double> A(dofs_per_block);'
p23763
aS'        BlockVector<double> B(dofs_per_block);'
p23764
aS'        {'
p23765
aS'          assemble_sc();'
p23766
aS'          tangent_matrix.block(p_dof, J_dof)'
p23767
aS'            .vmult(A.block(J_dof), system_rhs.block(p_dof));'
p23768
aS'          tangent_matrix.block(J_dof, J_dof)'
p23769
aS'            .vmult(B.block(J_dof), A.block(J_dof));'
p23770
aS'          A.block(J_dof) = system_rhs.block(J_dof);'
p23771
aS'          A.block(J_dof) -= B.block(J_dof);'
p23772
aS'          tangent_matrix.block(p_dof, J_dof)'
p23773
aS'            .Tvmult(A.block(p_dof), A.block(J_dof));'
p23774
aS'          tangent_matrix.block(u_dof, p_dof)'
p23775
aS'            .vmult(A.block(u_dof), A.block(p_dof));'
p23776
aS'          system_rhs.block(u_dof) -= A.block(u_dof);'
p23777
aS'          timer.enter_subsection("Linear solver");'
p23778
aS'          std::cout << " SLV " << std::flush;'
p23779
aS'          if (parameters.type_lin == "CG")'
p23780
aS'            {'
p23781
aS'              const auto solver_its = static_cast<unsigned int>('
p23782
aS'                tangent_matrix.block(u_dof, u_dof).m() *'
p23783
aS'                parameters.max_iterations_lin);'
p23784
aS'              const double tol_sol ='
p23785
aS'                parameters.tol_lin * system_rhs.block(u_dof).l2_norm();'
p23786
aS'              SolverControl solver_control(solver_its, tol_sol);'
p23787
aS'              GrowingVectorMemory<Vector<double>> GVM;'
p23788
aS'              SolverCG<Vector<double>> solver_CG(solver_control, GVM);'
p23789
aS'              PreconditionSelector<SparseMatrix<double>, Vector<double>>'
p23790
aS'                preconditioner(parameters.preconditioner_type,'
p23791
aS'                               parameters.preconditioner_relaxation);'
p23792
aS'              preconditioner.use_matrix(tangent_matrix.block(u_dof, u_dof));'
p23793
aS'              solver_CG.solve(tangent_matrix.block(u_dof, u_dof),'
p23794
aS'                              newton_update.block(u_dof),'
p23795
aS'                              system_rhs.block(u_dof),'
p23796
aS'                              preconditioner);'
p23797
aS'              lin_it  = solver_control.last_step();'
p23798
aS'              lin_res = solver_control.last_value();'
p23799
aS'            }'
p23800
aS'          else if (parameters.type_lin == "Direct")'
p23801
aS'            {'
p23802
aS'              SparseDirectUMFPACK A_direct;'
p23803
aS'              A_direct.initialize(tangent_matrix.block(u_dof, u_dof));'
p23804
aS'              A_direct.vmult(newton_update.block(u_dof),'
p23805
aS'                             system_rhs.block(u_dof));'
p23806
aS'              lin_it  = 1;'
p23807
aS'              lin_res = 0.0;'
p23808
aS'            }'
p23809
aS'          else'
p23810
aS'            Assert(false, ExcMessage("Linear solver type not implemented"));'
p23811
aS'          timer.leave_subsection();'
p23812
aS'        }'
p23813
aS'        constraints.distribute(newton_update);'
p23814
aS'        timer.enter_subsection("Linear solver postprocessing");'
p23815
aS'        std::cout << " PP " << std::flush;'
p23816
aS'        {'
p23817
aS'          tangent_matrix.block(p_dof, u_dof)'
p23818
aS'            .vmult(A.block(p_dof), newton_update.block(u_dof));'
p23819
aS'          A.block(p_dof) *= -1.0;'
p23820
aS'          A.block(p_dof) += system_rhs.block(p_dof);'
p23821
aS'          tangent_matrix.block(p_dof, J_dof)'
p23822
aS'            .vmult(newton_update.block(J_dof), A.block(p_dof));'
p23823
aS'        }'
p23824
aS'        constraints.distribute(newton_update);'
p23825
aS'        {'
p23826
aS'          tangent_matrix.block(J_dof, J_dof)'
p23827
aS'            .vmult(A.block(J_dof), newton_update.block(J_dof));'
p23828
aS'          A.block(J_dof) *= -1.0;'
p23829
aS'          A.block(J_dof) += system_rhs.block(J_dof);'
p23830
aS'          tangent_matrix.block(p_dof, J_dof)'
p23831
aS'            .Tvmult(newton_update.block(p_dof), A.block(J_dof));'
p23832
aS'        }'
p23833
aS'        constraints.distribute(newton_update);'
p23834
aS'        timer.leave_subsection();'
p23835
aS'      }'
p23836
aS'    else'
p23837
aS'      {'
p23838
aS'        std::cout << " ------ " << std::flush;'
p23839
aS'        timer.enter_subsection("Linear solver");'
p23840
aS'        std::cout << " SLV " << std::flush;'
p23841
aS'        if (parameters.type_lin == "CG")'
p23842
aS'          {'
p23843
aS'            const Vector<double> &f_u = system_rhs.block(u_dof);'
p23844
aS'            const Vector<double> &f_p = system_rhs.block(p_dof);'
p23845
aS'            const Vector<double> &f_J = system_rhs.block(J_dof);'
p23846
aS'            Vector<double> &d_u = newton_update.block(u_dof);'
p23847
aS'            Vector<double> &d_p = newton_update.block(p_dof);'
p23848
aS'            Vector<double> &d_J = newton_update.block(J_dof);'
p23849
aS'            const auto K_uu ='
p23850
aS'              linear_operator(tangent_matrix.block(u_dof, u_dof));'
p23851
aS'            const auto K_up ='
p23852
aS'              linear_operator(tangent_matrix.block(u_dof, p_dof));'
p23853
aS'            const auto K_pu ='
p23854
aS'              linear_operator(tangent_matrix.block(p_dof, u_dof));'
p23855
aS'            const auto K_Jp ='
p23856
aS'              linear_operator(tangent_matrix.block(J_dof, p_dof));'
p23857
aS'            const auto K_JJ ='
p23858
aS'              linear_operator(tangent_matrix.block(J_dof, J_dof));'
p23859
aS'            PreconditionSelector<SparseMatrix<double>, Vector<double>>'
p23860
aS'              preconditioner_K_Jp_inv("jacobi");'
p23861
aS'            preconditioner_K_Jp_inv.use_matrix('
p23862
aS'              tangent_matrix.block(J_dof, p_dof));'
p23863
aS'            ReductionControl solver_control_K_Jp_inv('
p23864
aS'              static_cast<unsigned int>(tangent_matrix.block(J_dof, p_dof).m() *'
p23865
aS'                                        parameters.max_iterations_lin),'
p23866
aS'              1.0e-30,'
p23867
aS'              parameters.tol_lin);'
p23868
aS'            SolverSelector<Vector<double>> solver_K_Jp_inv;'
p23869
aS'            solver_K_Jp_inv.select("cg");'
p23870
aS'            solver_K_Jp_inv.set_control(solver_control_K_Jp_inv);'
p23871
aS'            const auto K_Jp_inv ='
p23872
aS'              inverse_operator(K_Jp, solver_K_Jp_inv, preconditioner_K_Jp_inv);'
p23873
aS'            const auto K_pJ_inv     = transpose_operator(K_Jp_inv);'
p23874
aS'            const auto K_pp_bar     = K_Jp_inv * K_JJ * K_pJ_inv;'
p23875
aS'            const auto K_uu_bar_bar = K_up * K_pp_bar * K_pu;'
p23876
aS'            const auto K_uu_con     = K_uu + K_uu_bar_bar;'
p23877
aS'            PreconditionSelector<SparseMatrix<double>, Vector<double>>'
p23878
aS'              preconditioner_K_con_inv(parameters.preconditioner_type,'
p23879
aS'                                       parameters.preconditioner_relaxation);'
p23880
aS'            preconditioner_K_con_inv.use_matrix('
p23881
aS'              tangent_matrix.block(u_dof, u_dof));'
p23882
aS'            ReductionControl solver_control_K_con_inv('
p23883
aS'              static_cast<unsigned int>(tangent_matrix.block(u_dof, u_dof).m() *'
p23884
aS'                                        parameters.max_iterations_lin),'
p23885
aS'              1.0e-30,'
p23886
aS'              parameters.tol_lin);'
p23887
aS'            SolverSelector<Vector<double>> solver_K_con_inv;'
p23888
aS'            solver_K_con_inv.select("cg");'
p23889
aS'            solver_K_con_inv.set_control(solver_control_K_con_inv);'
p23890
aS'            const auto K_uu_con_inv ='
p23891
aS'              inverse_operator(K_uu_con,'
p23892
aS'                               solver_K_con_inv,'
p23893
aS'                               preconditioner_K_con_inv);'
p23894
aS'            d_u ='
p23895
aS'              K_uu_con_inv * (f_u - K_up * (K_Jp_inv * f_J - K_pp_bar * f_p));'
p23896
aS'            timer.leave_subsection();'
p23897
aS'            timer.enter_subsection("Linear solver postprocessing");'
p23898
aS'            std::cout << " PP " << std::flush;'
p23899
aS'            d_J = K_pJ_inv * (f_p - K_pu * d_u);'
p23900
aS'            d_p = K_Jp_inv * (f_J - K_JJ * d_J);'
p23901
aS'            lin_it  = solver_control_K_con_inv.last_step();'
p23902
aS'            lin_res = solver_control_K_con_inv.last_value();'
p23903
aS'          }'
p23904
aS'        else if (parameters.type_lin == "Direct")'
p23905
aS'          {'
p23906
aS'            SparseDirectUMFPACK A_direct;'
p23907
aS'            A_direct.initialize(tangent_matrix);'
p23908
aS'            A_direct.vmult(newton_update, system_rhs);'
p23909
aS'            lin_it  = 1;'
p23910
aS'            lin_res = 0.0;'
p23911
aS'            std::cout << " -- " << std::flush;'
p23912
aS'          }'
p23913
aS'        else'
p23914
aS'          Assert(false, ExcMessage("Linear solver type not implemented"));'
p23915
aS'        timer.leave_subsection();'
p23916
aS'        constraints.distribute(newton_update);'
p23917
aS'      }'
p23918
aS'    return std::make_pair(lin_it, lin_res);'
p23919
aS'  }'
p23920
aS'  template <int dim>'
p23921
aS'  void Solid<dim>::output_results() const'
p23922
aS'  {'
p23923
aS'    DataOut<dim> data_out;'
p23924
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p23925
aS'      data_component_interpretation('
p23926
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p23927
aS'    data_component_interpretation.push_back('
p23928
aS'      DataComponentInterpretation::component_is_scalar);'
p23929
aS'    data_component_interpretation.push_back('
p23930
aS'      DataComponentInterpretation::component_is_scalar);'
p23931
aS'    std::vector<std::string> solution_name(dim, "displacement");'
p23932
aS'    solution_name.emplace_back("pressure");'
p23933
aS'    solution_name.emplace_back("dilatation");'
p23934
aS'    DataOutBase::VtkFlags output_flags;'
p23935
aS'    output_flags.write_higher_order_cells = true;'
p23936
aS'    data_out.set_flags(output_flags);'
p23937
aS'    data_out.attach_dof_handler(dof_handler);'
p23938
aS'    data_out.add_data_vector(solution_n,'
p23939
aS'                             solution_name,'
p23940
aS'                             DataOut<dim>::type_dof_data,'
p23941
aS'                             data_component_interpretation);'
p23942
aS'    Vector<double> soln(solution_n.size());'
p23943
aS'    for (unsigned int i = 0; i < soln.size(); ++i)'
p23944
aS'      soln(i) = solution_n(i);'
p23945
aS'    MappingQEulerian<dim> q_mapping(degree, dof_handler, soln);'
p23946
aS'    data_out.build_patches(q_mapping, degree);'
p23947
aS'    std::ofstream output("solution-" + std::to_string(dim) + "d-" +'
p23948
aS'                         std::to_string(time.get_timestep()) + ".vtu");'
p23949
aS'    data_out.write_vtu(output);'
p23950
aS'  }'
p23951
aS'} // namespace Step44'
p23952
aS'int main()'
p23953
ag9
aS'  using namespace Step44;'
p23954
aS'  try'
p23955
aS'    {'
p23956
aS'      const unsigned int dim = 3;'
p23957
aS'      Solid<dim>         solid("parameters.prm");'
p23958
aS'      solid.run();'
p23959
aS'    }'
p23960
aS'  catch (std::exception &exc)'
p23961
aS'    {'
p23962
aS'      std::cerr << std::endl'
p23963
aS'                << std::endl'
p23964
aS'                << "----------------------------------------------------"'
p23965
aS'                << std::endl;'
p23966
aS'      std::cerr << "Exception on processing: " << std::endl'
p23967
aS'                << exc.what() << std::endl'
p23968
aS'                << "Aborting!" << std::endl'
p23969
aS'                << "----------------------------------------------------"'
p23970
aS'                << std::endl;'
p23971
aS'      return 1;'
p23972
aS'    }'
p23973
aS'  catch (...)'
p23974
aS'    {'
p23975
aS'      std::cerr << std::endl'
p23976
aS'                << std::endl'
p23977
aS'                << "----------------------------------------------------"'
p23978
aS'                << std::endl;'
p23979
aS'      std::cerr << "Unknown exception!" << std::endl'
p23980
aS'                << "Aborting!" << std::endl'
p23981
aS'                << "----------------------------------------------------"'
p23982
aS'                << std::endl;'
p23983
aS'      return 1;'
p23984
aS'    }'
p23985
aS'  return 0;'
p23986
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p23987
aS'#include <deal.II/distributed/grid_refinement.h>'
p23988
aS'#include <deal.II/lac/solver_cg.h>'
p23989
aS'#include <deal.II/lac/affine_constraints.h>'
p23990
aS'#include <deal.II/lac/trilinos_solver.h>'
p23991
aS'#include <deal.II/lac/trilinos_precondition.h>'
p23992
aS'#include <deal.II/lac/trilinos_block_sparse_matrix.h>'
p23993
aS'#include <deal.II/lac/trilinos_parallel_block_vector.h>'
p23994
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p23995
aS'#include <deal.II/grid/grid_generator.h>'
p23996
aS'#include <deal.II/grid/grid_tools.h>'
p23997
aS'#include <deal.II/dofs/dof_renumbering.h>'
p23998
aS'#include <deal.II/dofs/dof_tools.h>'
p23999
aS'#include <deal.II/fe/fe_q.h>'
p24000
aS'#include <deal.II/fe/fe_system.h>'
p24001
aS'#include <deal.II/fe/mapping_q.h>'
p24002
aS'#include <deal.II/numerics/vector_tools.h>'
p24003
aS'#include <deal.II/numerics/data_out.h>'
p24004
aS'#include <deal.II/numerics/error_estimator.h>'
p24005
aS'namespace Step45'
p24006
ag9
aS'  using namespace dealii;'
p24007
aS'  template <int dim>'
p24008
aS'  class StokesProblem'
p24009
aS'  {'
p24010
aS'  public:'
p24011
aS'    StokesProblem(const unsigned int degree);'
p24012
aS'    void run();'
p24013
aS'  private:'
p24014
aS'    void create_mesh();'
p24015
aS'    void setup_dofs();'
p24016
aS'    void assemble_system();'
p24017
aS'    void solve();'
p24018
aS'    void output_results(const unsigned int refinement_cycle) const;'
p24019
aS'    void refine_mesh();'
p24020
aS'    const unsigned int degree;'
p24021
aS'    MPI_Comm mpi_communicator;'
p24022
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p24023
aS'    FESystem<dim>                             fe;'
p24024
aS'    DoFHandler<dim>                           dof_handler;'
p24025
aS'    AffineConstraints<double> constraints;'
p24026
aS'    std::vector<IndexSet>     owned_partitioning;'
p24027
aS'    std::vector<IndexSet>     relevant_partitioning;'
p24028
aS'    TrilinosWrappers::BlockSparseMatrix system_matrix;'
p24029
aS'    TrilinosWrappers::BlockSparseMatrix preconditioner_matrix;'
p24030
aS'    TrilinosWrappers::MPI::BlockVector solution;'
p24031
aS'    TrilinosWrappers::MPI::BlockVector system_rhs;'
p24032
aS'    ConditionalOStream pcout;'
p24033
aS'    MappingQ<dim> mapping;'
p24034
aS'  };'
p24035
aS'  template <int dim>'
p24036
aS'  class BoundaryValues : public Function<dim>'
p24037
aS'  {'
p24038
aS'  public:'
p24039
aS'    BoundaryValues()'
p24040
aS'      : Function<dim>(dim + 1)'
p24041
aS'    {}'
p24042
aS'    virtual double value(const Point<dim> & p,'
p24043
aS'                         const unsigned int component = 0) const override;'
p24044
aS'    virtual void vector_value(const Point<dim> &p,'
p24045
aS'                              Vector<double> &  value) const override;'
p24046
aS'  };'
p24047
aS'  template <int dim>'
p24048
aS'  double BoundaryValues<dim>::value(const Point<dim> & /*p*/,'
p24049
aS'                                    const unsigned int component) const'
p24050
aS'  {'
p24051
aS'    Assert(component < this->n_components,'
p24052
aS'           ExcIndexRange(component, 0, this->n_components));'
p24053
aS'    return 0;'
p24054
aS'  }'
p24055
aS'  template <int dim>'
p24056
aS'  void BoundaryValues<dim>::vector_value(const Point<dim> &p,'
p24057
aS'                                         Vector<double> &  values) const'
p24058
aS'  {'
p24059
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p24060
aS'      values(c) = BoundaryValues<dim>::value(p, c);'
p24061
aS'  }'
p24062
aS'  template <int dim>'
p24063
aS'  class RightHandSide : public Function<dim>'
p24064
aS'  {'
p24065
aS'  public:'
p24066
aS'    RightHandSide()'
p24067
aS'      : Function<dim>(dim + 1)'
p24068
aS'    {}'
p24069
aS'    virtual double value(const Point<dim> & p,'
p24070
aS'                         const unsigned int component = 0) const override;'
p24071
aS'    virtual void vector_value(const Point<dim> &p,'
p24072
aS'                              Vector<double> &  value) const override;'
p24073
aS'  };'
p24074
aS'  template <int dim>'
p24075
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p24076
aS'                                   const unsigned int component) const'
p24077
aS'  {'
p24078
aS'    const Point<dim> center(0.75, 0.1);'
p24079
aS'    const double     r = (p - center).norm();'
p24080
aS'    if (component == 0)'
p24081
aS'      return std::exp(-100. * r * r);'
p24082
aS'    return 0;'
p24083
aS'  }'
p24084
aS'  template <int dim>'
p24085
aS'  void RightHandSide<dim>::vector_value(const Point<dim> &p,'
p24086
aS'                                        Vector<double> &  values) const'
p24087
aS'  {'
p24088
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p24089
aS'      values(c) = RightHandSide<dim>::value(p, c);'
p24090
aS'  }'
p24091
aS'  template <class MatrixType, class PreconditionerType>'
p24092
aS'  class InverseMatrix : public Subscriptor'
p24093
aS'  {'
p24094
aS'  public:'
p24095
aS'    InverseMatrix(const MatrixType &        m,'
p24096
aS'                  const PreconditionerType &preconditioner,'
p24097
aS'                  const IndexSet &          locally_owned,'
p24098
aS'                  const MPI_Comm &          mpi_communicator);'
p24099
aS'    void vmult(TrilinosWrappers::MPI::Vector &      dst,'
p24100
aS'               const TrilinosWrappers::MPI::Vector &src) const;'
p24101
aS'  private:'
p24102
aS'    const SmartPointer<const MatrixType>         matrix;'
p24103
aS'    const SmartPointer<const PreconditionerType> preconditioner;'
p24104
aS'    const MPI_Comm *                      mpi_communicator;'
p24105
aS'    mutable TrilinosWrappers::MPI::Vector tmp;'
p24106
aS'  };'
p24107
aS'  template <class MatrixType, class PreconditionerType>'
p24108
aS'  InverseMatrix<MatrixType, PreconditionerType>::InverseMatrix('
p24109
aS'    const MatrixType &        m,'
p24110
aS'    const PreconditionerType &preconditioner,'
p24111
aS'    const IndexSet &          locally_owned,'
p24112
aS'    const MPI_Comm &          mpi_communicator)'
p24113
aS'    : matrix(&m)'
p24114
aS'    , preconditioner(&preconditioner)'
p24115
aS'    , mpi_communicator(&mpi_communicator)'
p24116
aS'    , tmp(locally_owned, mpi_communicator)'
p24117
aS'  {}'
p24118
aS'  template <class MatrixType, class PreconditionerType>'
p24119
aS'  void InverseMatrix<MatrixType, PreconditionerType>::vmult('
p24120
aS'    TrilinosWrappers::MPI::Vector &      dst,'
p24121
aS'    const TrilinosWrappers::MPI::Vector &src) const'
p24122
aS'  {'
p24123
aS'    SolverControl              solver_control(src.size(), 1e-6 * src.l2_norm());'
p24124
aS'    TrilinosWrappers::SolverCG cg(solver_control,'
p24125
aS'                                  TrilinosWrappers::SolverCG::AdditionalData());'
p24126
aS'    tmp = 0.;'
p24127
aS'    cg.solve(*matrix, tmp, src, *preconditioner);'
p24128
aS'    dst = tmp;'
p24129
aS'  }'
p24130
aS'  template <class PreconditionerType>'
p24131
aS'  class SchurComplement : public TrilinosWrappers::SparseMatrix'
p24132
aS'  {'
p24133
aS'  public:'
p24134
aS'    SchurComplement(const TrilinosWrappers::BlockSparseMatrix &system_matrix,'
p24135
aS'                    const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p24136
aS'                                        PreconditionerType> &  A_inverse,'
p24137
aS'                    const IndexSet &                           owned_pres,'
p24138
aS'                    const MPI_Comm &mpi_communicator);'
p24139
aS'    void vmult(TrilinosWrappers::MPI::Vector &      dst,'
p24140
aS'               const TrilinosWrappers::MPI::Vector &src) const;'
p24141
aS'  private:'
p24142
aS'    const SmartPointer<const TrilinosWrappers::BlockSparseMatrix> system_matrix;'
p24143
aS'    const SmartPointer<'
p24144
aS'      const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>>'
p24145
aS'                                          A_inverse;'
p24146
aS'    mutable TrilinosWrappers::MPI::Vector tmp1, tmp2;'
p24147
aS'  };'
p24148
aS'  template <class PreconditionerType>'
p24149
aS'  SchurComplement<PreconditionerType>::SchurComplement('
p24150
aS'    const TrilinosWrappers::BlockSparseMatrix &system_matrix,'
p24151
aS'    const InverseMatrix<TrilinosWrappers::SparseMatrix, PreconditionerType>'
p24152
aS'      &             A_inverse,'
p24153
aS'    const IndexSet &owned_vel,'
p24154
aS'    const MPI_Comm &mpi_communicator)'
p24155
aS'    : system_matrix(&system_matrix)'
p24156
aS'    , A_inverse(&A_inverse)'
p24157
aS'    , tmp1(owned_vel, mpi_communicator)'
p24158
aS'    , tmp2(tmp1)'
p24159
aS'  {}'
p24160
aS'  template <class PreconditionerType>'
p24161
aS'  void SchurComplement<PreconditionerType>::vmult('
p24162
aS'    TrilinosWrappers::MPI::Vector &      dst,'
p24163
aS'    const TrilinosWrappers::MPI::Vector &src) const'
p24164
aS'  {'
p24165
aS'    system_matrix->block(0, 1).vmult(tmp1, src);'
p24166
aS'    A_inverse->vmult(tmp2, tmp1);'
p24167
aS'    system_matrix->block(1, 0).vmult(dst, tmp2);'
p24168
aS'  }'
p24169
aS'  template <int dim>'
p24170
aS'  StokesProblem<dim>::StokesProblem(const unsigned int degree)'
p24171
aS'    : degree(degree)'
p24172
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p24173
aS'    , triangulation(mpi_communicator)'
p24174
aS'    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1)'
p24175
aS'    , dof_handler(triangulation)'
p24176
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p24177
aS'    , mapping(degree + 1)'
p24178
aS'  {}'
p24179
aS'  template <int dim>'
p24180
aS'  void StokesProblem<dim>::create_mesh()'
p24181
aS'  {'
p24182
aS'    Point<dim>   center;'
p24183
aS'    const double inner_radius = .5;'
p24184
aS'    const double outer_radius = 1.;'
p24185
aS'    GridGenerator::quarter_hyper_shell('
p24186
aS'      triangulation, center, inner_radius, outer_radius, 0, true);'
p24187
aS'    std::vector<GridTools::PeriodicFacePair<'
p24188
aS'      typename parallel::distributed::Triangulation<dim>::cell_iterator>>'
p24189
aS'      periodicity_vector;'
p24190
aS'    FullMatrix<double> rotation_matrix(dim);'
p24191
aS'    rotation_matrix[0][1] = 1.;'
p24192
aS'    rotation_matrix[1][0] = -1.;'
p24193
aS'    GridTools::collect_periodic_faces(triangulation,'
p24194
aS'                                      2,'
p24195
aS'                                      3,'
p24196
aS'                                      1,'
p24197
aS'                                      periodicity_vector,'
p24198
aS'                                      Tensor<1, dim>(),'
p24199
aS'                                      rotation_matrix);'
p24200
aS'    triangulation.add_periodicity(periodicity_vector);'
p24201
aS'    triangulation.refine_global(4 - dim);'
p24202
aS'  }'
p24203
aS'  template <int dim>'
p24204
aS'  void StokesProblem<dim>::setup_dofs()'
p24205
aS'  {'
p24206
aS'    dof_handler.distribute_dofs(fe);'
p24207
aS'    std::vector<unsigned int> block_component(dim + 1, 0);'
p24208
aS'    block_component[dim] = 1;'
p24209
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p24210
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p24211
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p24212
aS'    const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];'
p24213
aS'    {'
p24214
aS'      owned_partitioning.clear();'
p24215
aS'      IndexSet locally_owned_dofs = dof_handler.locally_owned_dofs();'
p24216
aS'      owned_partitioning.push_back(locally_owned_dofs.get_view(0, n_u));'
p24217
aS'      owned_partitioning.push_back(locally_owned_dofs.get_view(n_u, n_u + n_p));'
p24218
aS'      relevant_partitioning.clear();'
p24219
aS'      IndexSet locally_relevant_dofs;'
p24220
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler,'
p24221
aS'                                              locally_relevant_dofs);'
p24222
aS'      relevant_partitioning.push_back(locally_relevant_dofs.get_view(0, n_u));'
p24223
aS'      relevant_partitioning.push_back('
p24224
aS'        locally_relevant_dofs.get_view(n_u, n_u + n_p));'
p24225
aS'      constraints.clear();'
p24226
aS'      constraints.reinit(locally_relevant_dofs);'
p24227
aS'      FEValuesExtractors::Vector velocities(0);'
p24228
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p24229
aS'      VectorTools::interpolate_boundary_values(mapping,'
p24230
aS'                                               dof_handler,'
p24231
aS'                                               0,'
p24232
aS'                                               BoundaryValues<dim>(),'
p24233
aS'                                               constraints,'
p24234
aS'                                               fe.component_mask(velocities));'
p24235
aS'      VectorTools::interpolate_boundary_values(mapping,'
p24236
aS'                                               dof_handler,'
p24237
aS'                                               1,'
p24238
aS'                                               BoundaryValues<dim>(),'
p24239
aS'                                               constraints,'
p24240
aS'                                               fe.component_mask(velocities));'
p24241
aS'      FullMatrix<double> rotation_matrix(dim);'
p24242
aS'      rotation_matrix[0][1] = 1.;'
p24243
aS'      rotation_matrix[1][0] = -1.;'
p24244
aS'      Tensor<1, dim> offset;'
p24245
aS'      std::vector<'
p24246
aS'        GridTools::PeriodicFacePair<typename DoFHandler<dim>::cell_iterator>>'
p24247
aS'        periodicity_vector;'
p24248
aS'      const unsigned int direction = 1;'
p24249
aS'      GridTools::collect_periodic_faces(dof_handler,'
p24250
aS'                                        2,'
p24251
aS'                                        3,'
p24252
aS'                                        direction,'
p24253
aS'                                        periodicity_vector,'
p24254
aS'                                        offset,'
p24255
aS'                                        rotation_matrix);'
p24256
aS'      std::vector<unsigned int> first_vector_components;'
p24257
aS'      first_vector_components.push_back(0);'
p24258
aS'      DoFTools::make_periodicity_constraints<dim, dim>(periodicity_vector,'
p24259
aS'                                                       constraints,'
p24260
aS'                                                       fe.component_mask('
p24261
aS'                                                         velocities),'
p24262
aS'                                                       first_vector_components);'
p24263
aS'      VectorTools::interpolate_boundary_values(mapping,'
p24264
aS'                                               dof_handler,'
p24265
aS'                                               0,'
p24266
aS'                                               BoundaryValues<dim>(),'
p24267
aS'                                               constraints,'
p24268
aS'                                               fe.component_mask(velocities));'
p24269
aS'      VectorTools::interpolate_boundary_values(mapping,'
p24270
aS'                                               dof_handler,'
p24271
aS'                                               1,'
p24272
aS'                                               BoundaryValues<dim>(),'
p24273
aS'                                               constraints,'
p24274
aS'                                               fe.component_mask(velocities));'
p24275
aS'    }'
p24276
aS'    constraints.close();'
p24277
aS'    {'
p24278
aS'      TrilinosWrappers::BlockSparsityPattern bsp(owned_partitioning,'
p24279
aS'                                                 owned_partitioning,'
p24280
aS'                                                 relevant_partitioning,'
p24281
aS'                                                 mpi_communicator);'
p24282
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p24283
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p24284
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p24285
aS'          if (!((c == dim) && (d == dim)))'
p24286
aS'            coupling[c][d] = DoFTools::always;'
p24287
aS'          else'
p24288
aS'            coupling[c][d] = DoFTools::none;'
p24289
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p24290
aS'                                      coupling,'
p24291
aS'                                      bsp,'
p24292
aS'                                      constraints,'
p24293
aS'                                      false,'
p24294
aS'                                      Utilities::MPI::this_mpi_process('
p24295
aS'                                        mpi_communicator));'
p24296
aS'      bsp.compress();'
p24297
aS'      system_matrix.reinit(bsp);'
p24298
aS'    }'
p24299
aS'    {'
p24300
aS'      TrilinosWrappers::BlockSparsityPattern preconditioner_bsp('
p24301
aS'        owned_partitioning,'
p24302
aS'        owned_partitioning,'
p24303
aS'        relevant_partitioning,'
p24304
aS'        mpi_communicator);'
p24305
aS'      Table<2, DoFTools::Coupling> preconditioner_coupling(dim + 1, dim + 1);'
p24306
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p24307
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p24308
aS'          if ((c == dim) && (d == dim))'
p24309
aS'            preconditioner_coupling[c][d] = DoFTools::always;'
p24310
aS'          else'
p24311
aS'            preconditioner_coupling[c][d] = DoFTools::none;'
p24312
aS'      DoFTools::make_sparsity_pattern(dof_handler,'
p24313
aS'                                      preconditioner_coupling,'
p24314
aS'                                      preconditioner_bsp,'
p24315
aS'                                      constraints,'
p24316
aS'                                      false,'
p24317
aS'                                      Utilities::MPI::this_mpi_process('
p24318
aS'                                        mpi_communicator));'
p24319
aS'      preconditioner_bsp.compress();'
p24320
aS'      preconditioner_matrix.reinit(preconditioner_bsp);'
p24321
aS'    }'
p24322
aS'    system_rhs.reinit(owned_partitioning, mpi_communicator);'
p24323
aS'    solution.reinit(owned_partitioning,'
p24324
aS'                    relevant_partitioning,'
p24325
aS'                    mpi_communicator);'
p24326
aS'  }'
p24327
aS'  template <int dim>'
p24328
aS'  void StokesProblem<dim>::assemble_system()'
p24329
aS'  {'
p24330
aS'    system_matrix         = 0.;'
p24331
aS'    system_rhs            = 0.;'
p24332
aS'    preconditioner_matrix = 0.;'
p24333
aS'    QGauss<dim> quadrature_formula(degree + 2);'
p24334
aS'    FEValues<dim> fe_values(mapping,'
p24335
aS'                            fe,'
p24336
aS'                            quadrature_formula,'
p24337
aS'                            update_values | update_quadrature_points |'
p24338
aS'                              update_JxW_values | update_gradients);'
p24339
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p24340
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p24341
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p24342
aS'    FullMatrix<double> local_preconditioner_matrix(dofs_per_cell,'
p24343
aS'                                                   dofs_per_cell);'
p24344
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p24345
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p24346
aS'    const RightHandSide<dim>    right_hand_side;'
p24347
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p24348
aS'    const FEValuesExtractors::Vector velocities(0);'
p24349
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p24350
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p24351
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p24352
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p24353
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p24354
aS'      if (cell->is_locally_owned())'
p24355
aS'        {'
p24356
aS'          fe_values.reinit(cell);'
p24357
aS'          local_matrix                = 0;'
p24358
aS'          local_preconditioner_matrix = 0;'
p24359
aS'          local_rhs                   = 0;'
p24360
aS'          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p24361
aS'                                            rhs_values);'
p24362
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p24363
aS'            {'
p24364
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p24365
aS'                {'
p24366
aS'                  symgrad_phi_u[k] ='
p24367
aS'                    fe_values[velocities].symmetric_gradient(k, q);'
p24368
aS'                  div_phi_u[k] = fe_values[velocities].divergence(k, q);'
p24369
aS'                  phi_p[k]     = fe_values[pressure].value(k, q);'
p24370
aS'                }'
p24371
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p24372
aS'                {'
p24373
aS'                  for (unsigned int j = 0; j <= i; ++j)'
p24374
aS'                    {'
p24375
aS'                      local_matrix(i, j) +='
p24376
aS'                         - div_phi_u[i] * phi_p[j]           // pressure force'
p24377
aS'                         - phi_p[i] * div_phi_u[j])          // divergence'
p24378
aS'                      local_preconditioner_matrix(i, j) +='
p24379
aS'                    }'
p24380
aS'                  const unsigned int component_i ='
p24381
aS'                    fe.system_to_component_index(i).first;'
p24382
aS'                  local_rhs(i) += fe_values.shape_value(i, q)  //'
p24383
aS'                }'
p24384
aS'            }'
p24385
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p24386
aS'            for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p24387
aS'              {'
p24388
aS'                local_matrix(i, j) = local_matrix(j, i);'
p24389
aS'                local_preconditioner_matrix(i, j) ='
p24390
aS'                  local_preconditioner_matrix(j, i);'
p24391
aS'              }'
p24392
aS'          cell->get_dof_indices(local_dof_indices);'
p24393
aS'          constraints.distribute_local_to_global(local_matrix,'
p24394
aS'                                                 local_rhs,'
p24395
aS'                                                 local_dof_indices,'
p24396
aS'                                                 system_matrix,'
p24397
aS'                                                 system_rhs);'
p24398
aS'          constraints.distribute_local_to_global(local_preconditioner_matrix,'
p24399
aS'                                                 local_dof_indices,'
p24400
aS'                                                 preconditioner_matrix);'
p24401
aS'        }'
p24402
aS'    system_matrix.compress(VectorOperation::add);'
p24403
aS'    system_rhs.compress(VectorOperation::add);'
p24404
aS'    pcout << "   Computing preconditioner..." << std::endl << std::flush;'
p24405
aS'  }'
p24406
aS'  template <int dim>'
p24407
aS'  void StokesProblem<dim>::solve()'
p24408
aS'  {'
p24409
aS'    TrilinosWrappers::PreconditionJacobi A_preconditioner;'
p24410
aS'    A_preconditioner.initialize(system_matrix.block(0, 0));'
p24411
aS'    const InverseMatrix<TrilinosWrappers::SparseMatrix,'
p24412
aS'                        TrilinosWrappers::PreconditionJacobi>'
p24413
aS'      A_inverse(system_matrix.block(0, 0),'
p24414
aS'                A_preconditioner,'
p24415
aS'                owned_partitioning[0],'
p24416
aS'                mpi_communicator);'
p24417
aS'    TrilinosWrappers::MPI::BlockVector tmp(owned_partitioning,'
p24418
aS'                                           mpi_communicator);'
p24419
aS'    {'
p24420
aS'      TrilinosWrappers::MPI::Vector schur_rhs(owned_partitioning[1],'
p24421
aS'                                              mpi_communicator);'
p24422
aS'      A_inverse.vmult(tmp.block(0), system_rhs.block(0));'
p24423
aS'      system_matrix.block(1, 0).vmult(schur_rhs, tmp.block(0));'
p24424
aS'      schur_rhs -= system_rhs.block(1);'
p24425
aS'      SchurComplement<TrilinosWrappers::PreconditionJacobi> schur_complement('
p24426
aS'        system_matrix, A_inverse, owned_partitioning[0], mpi_communicator);'
p24427
aS'      SolverControl solver_control(solution.block(1).size(),'
p24428
aS'                                   1e-6 * schur_rhs.l2_norm());'
p24429
aS'      SolverCG<TrilinosWrappers::MPI::Vector> cg(solver_control);'
p24430
aS'      TrilinosWrappers::PreconditionAMG preconditioner;'
p24431
aS'      preconditioner.initialize(preconditioner_matrix.block(1, 1));'
p24432
aS'      InverseMatrix<TrilinosWrappers::SparseMatrix,'
p24433
aS'                    TrilinosWrappers::PreconditionAMG>'
p24434
aS'        m_inverse(preconditioner_matrix.block(1, 1),'
p24435
aS'                  preconditioner,'
p24436
aS'                  owned_partitioning[1],'
p24437
aS'                  mpi_communicator);'
p24438
aS'      cg.solve(schur_complement, tmp.block(1), schur_rhs, preconditioner);'
p24439
aS'      constraints.distribute(tmp);'
p24440
aS'      solution.block(1) = tmp.block(1);'
p24441
aS'    }'
p24442
aS'    {'
p24443
aS'      system_matrix.block(0, 1).vmult(tmp.block(0), tmp.block(1));'
p24444
aS'      tmp.block(0) *= -1;'
p24445
aS'      tmp.block(0) += system_rhs.block(0);'
p24446
aS'      A_inverse.vmult(tmp.block(0), tmp.block(0));'
p24447
aS'      constraints.distribute(tmp);'
p24448
aS'      solution.block(0) = tmp.block(0);'
p24449
aS'    }'
p24450
aS'  }'
p24451
aS'  template <int dim>'
p24452
aS'  void'
p24453
aS'  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const'
p24454
aS'  {'
p24455
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p24456
aS'    solution_names.emplace_back("pressure");'
p24457
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p24458
aS'      data_component_interpretation('
p24459
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p24460
aS'    data_component_interpretation.push_back('
p24461
aS'      DataComponentInterpretation::component_is_scalar);'
p24462
aS'    DataOut<dim> data_out;'
p24463
aS'    data_out.attach_dof_handler(dof_handler);'
p24464
aS'    data_out.add_data_vector(solution,'
p24465
aS'                             solution_names,'
p24466
aS'                             DataOut<dim>::type_dof_data,'
p24467
aS'                             data_component_interpretation);'
p24468
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p24469
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p24470
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p24471
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p24472
aS'    data_out.build_patches(mapping, degree + 1);'
p24473
aS'    data_out.write_vtu_with_pvtu_record('
p24474
aS'      "./", "solution", refinement_cycle, MPI_COMM_WORLD, 2);'
p24475
aS'  }'
p24476
aS'  template <int dim>'
p24477
aS'  void StokesProblem<dim>::refine_mesh()'
p24478
aS'  {'
p24479
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p24480
aS'    FEValuesExtractors::Scalar pressure(dim);'
p24481
aS'    KellyErrorEstimator<dim>::estimate('
p24482
aS'      dof_handler,'
p24483
aS'      QGauss<dim - 1>(degree + 1),'
p24484
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p24485
aS'      solution,'
p24486
aS'      estimated_error_per_cell,'
p24487
aS'      fe.component_mask(pressure));'
p24488
aS'    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p24489
aS'      triangulation, estimated_error_per_cell, 0.3, 0.0);'
p24490
aS'    triangulation.execute_coarsening_and_refinement();'
p24491
aS'  }'
p24492
aS'  template <int dim>'
p24493
aS'  void StokesProblem<dim>::run()'
p24494
aS'  {'
p24495
aS'    create_mesh();'
p24496
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 9;'
p24497
aS'         ++refinement_cycle)'
p24498
aS'      {'
p24499
aS'        pcout << "Refinement cycle " << refinement_cycle << std::endl;'
p24500
aS'        if (refinement_cycle > 0)'
p24501
aS'          refine_mesh();'
p24502
aS'        setup_dofs();'
p24503
aS'        pcout << "   Assembling..." << std::endl << std::flush;'
p24504
aS'        assemble_system();'
p24505
aS'        pcout << "   Solving..." << std::flush;'
p24506
aS'        solve();'
p24507
aS'        output_results(refinement_cycle);'
p24508
aS'        pcout << std::endl;'
p24509
aS'      }'
p24510
aS'  }'
p24511
aS'} // namespace Step45'
p24512
aS'int main(int argc, char *argv[])'
p24513
ag9
aS'  try'
p24514
aS'    {'
p24515
aS'      using namespace dealii;'
p24516
aS'      using namespace Step45;'
p24517
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p24518
aS'      StokesProblem<2>                 flow_problem(1);'
p24519
aS'      flow_problem.run();'
p24520
aS'    }'
p24521
aS'  catch (std::exception &exc)'
p24522
aS'    {'
p24523
aS'      std::cerr << std::endl'
p24524
aS'                << std::endl'
p24525
aS'                << "----------------------------------------------------"'
p24526
aS'                << std::endl;'
p24527
aS'      std::cerr << "Exception on processing: " << std::endl'
p24528
aS'                << exc.what() << std::endl'
p24529
aS'                << "Aborting!" << std::endl'
p24530
aS'                << "----------------------------------------------------"'
p24531
aS'                << std::endl;'
p24532
aS'      return 1;'
p24533
aS'    }'
p24534
aS'  catch (...)'
p24535
aS'    {'
p24536
aS'      std::cerr << std::endl'
p24537
aS'                << std::endl'
p24538
aS'                << "----------------------------------------------------"'
p24539
aS'                << std::endl;'
p24540
aS'      std::cerr << "Unknown exception!" << std::endl'
p24541
aS'                << "Aborting!" << std::endl'
p24542
aS'                << "----------------------------------------------------"'
p24543
aS'                << std::endl;'
p24544
aS'      return 1;'
p24545
aS'    }'
p24546
aS'  return 0;'
p24547
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p24548
aS'#include <deal.II/base/logstream.h>'
p24549
aS'#include <deal.II/base/function.h>'
p24550
aS'#include <deal.II/base/utilities.h>'
p24551
aS'#include <deal.II/lac/vector.h>'
p24552
aS'#include <deal.II/lac/full_matrix.h>'
p24553
aS'#include <deal.II/lac/sparse_matrix.h>'
p24554
aS'#include <deal.II/lac/sparse_direct.h>'
p24555
aS'#include <deal.II/lac/affine_constraints.h>'
p24556
aS'#include <deal.II/grid/tria.h>'
p24557
aS'#include <deal.II/grid/grid_generator.h>'
p24558
aS'#include <deal.II/grid/grid_refinement.h>'
p24559
aS'#include <deal.II/dofs/dof_tools.h>'
p24560
aS'#include <deal.II/fe/fe_q.h>'
p24561
aS'#include <deal.II/fe/fe_nothing.h>'
p24562
aS'#include <deal.II/fe/fe_system.h>'
p24563
aS'#include <deal.II/fe/fe_values.h>'
p24564
aS'#include <deal.II/hp/fe_collection.h>'
p24565
aS'#include <deal.II/hp/fe_values.h>'
p24566
aS'#include <deal.II/numerics/vector_tools.h>'
p24567
aS'#include <deal.II/numerics/data_out.h>'
p24568
aS'#include <deal.II/numerics/error_estimator.h>'
p24569
aS'#include <iostream>'
p24570
aS'#include <fstream>'
p24571
aS'namespace Step46'
p24572
ag9
aS'  using namespace dealii;'
p24573
aS'  template <int dim>'
p24574
aS'  class FluidStructureProblem'
p24575
aS'  {'
p24576
aS'  public:'
p24577
aS'    FluidStructureProblem(const unsigned int stokes_degree,'
p24578
aS'                          const unsigned int elasticity_degree);'
p24579
aS'    void run();'
p24580
aS'  private:'
p24581
aS'    enum'
p24582
aS'    {'
p24583
aS'      fluid_domain_id,'
p24584
aS'      solid_domain_id'
p24585
aS'    };'
p24586
aS'    static bool cell_is_in_fluid_domain('
p24587
aS'      const typename DoFHandler<dim>::cell_iterator &cell);'
p24588
aS'    static bool cell_is_in_solid_domain('
p24589
aS'      const typename DoFHandler<dim>::cell_iterator &cell);'
p24590
aS'    void make_grid();'
p24591
aS'    void set_active_fe_indices();'
p24592
aS'    void setup_dofs();'
p24593
aS'    void assemble_system();'
p24594
aS'    void assemble_interface_term('
p24595
aS'      const FEFaceValuesBase<dim> &         elasticity_fe_face_values,'
p24596
aS'      const FEFaceValuesBase<dim> &         stokes_fe_face_values,'
p24597
aS'      std::vector<Tensor<1, dim>> &         elasticity_phi,'
p24598
aS'      std::vector<SymmetricTensor<2, dim>> &stokes_symgrad_phi_u,'
p24599
aS'      std::vector<double> &                 stokes_phi_p,'
p24600
aS'      FullMatrix<double> &                  local_interface_matrix) const;'
p24601
aS'    void solve();'
p24602
aS'    void output_results(const unsigned int refinement_cycle) const;'
p24603
aS'    void refine_mesh();'
p24604
aS'    const unsigned int stokes_degree;'
p24605
aS'    const unsigned int elasticity_degree;'
p24606
aS'    Triangulation<dim>    triangulation;'
p24607
aS'    FESystem<dim>         stokes_fe;'
p24608
aS'    FESystem<dim>         elasticity_fe;'
p24609
aS'    hp::FECollection<dim> fe_collection;'
p24610
aS'    DoFHandler<dim>       dof_handler;'
p24611
aS'    AffineConstraints<double> constraints;'
p24612
aS'    SparsityPattern      sparsity_pattern;'
p24613
aS'    SparseMatrix<double> system_matrix;'
p24614
aS'    Vector<double> solution;'
p24615
aS'    Vector<double> system_rhs;'
p24616
aS'    const double viscosity;'
p24617
aS'    const double lambda;'
p24618
aS'    const double mu;'
p24619
aS'  };'
p24620
aS'  template <int dim>'
p24621
aS'  class StokesBoundaryValues : public Function<dim>'
p24622
aS'  {'
p24623
aS'  public:'
p24624
aS'    StokesBoundaryValues()'
p24625
aS'      : Function<dim>(dim + 1 + dim)'
p24626
aS'    {}'
p24627
aS'    virtual double value(const Point<dim> & p,'
p24628
aS'                         const unsigned int component = 0) const override;'
p24629
aS'    virtual void vector_value(const Point<dim> &p,'
p24630
aS'                              Vector<double> &  value) const override;'
p24631
aS'  };'
p24632
aS'  template <int dim>'
p24633
aS'  double StokesBoundaryValues<dim>::value(const Point<dim> & p,'
p24634
aS'                                          const unsigned int component) const'
p24635
aS'  {'
p24636
aS'    Assert(component < this->n_components,'
p24637
aS'           ExcIndexRange(component, 0, this->n_components));'
p24638
aS'    if (component == dim - 1)'
p24639
aS'      switch (dim)'
p24640
aS'        {'
p24641
aS'          case 2:'
p24642
aS'            return std::sin(numbers::PI * p[0]);'
p24643
aS'          case 3:'
p24644
aS'            return std::sin(numbers::PI * p[0]) * std::sin(numbers::PI * p[1]);'
p24645
aS'          default:'
p24646
aS'            Assert(false, ExcNotImplemented());'
p24647
aS'        }'
p24648
aS'    return 0;'
p24649
aS'  }'
p24650
aS'  template <int dim>'
p24651
aS'  void StokesBoundaryValues<dim>::vector_value(const Point<dim> &p,'
p24652
aS'                                               Vector<double> &  values) const'
p24653
aS'  {'
p24654
aS'    for (unsigned int c = 0; c < this->n_components; ++c)'
p24655
aS'      values(c) = StokesBoundaryValues<dim>::value(p, c);'
p24656
aS'  }'
p24657
aS'  template <int dim>'
p24658
aS'  FluidStructureProblem<dim>::FluidStructureProblem('
p24659
aS'    const unsigned int stokes_degree,'
p24660
aS'    const unsigned int elasticity_degree)'
p24661
aS'    : stokes_degree(stokes_degree)'
p24662
aS'    , elasticity_degree(elasticity_degree)'
p24663
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p24664
aS'    , stokes_fe(FE_Q<dim>(stokes_degree + 1),'
p24665
aS'                dim,'
p24666
aS'                FE_Q<dim>(stokes_degree),'
p24667
aS'                1,'
p24668
aS'                FE_Nothing<dim>(),'
p24669
aS'                dim)'
p24670
aS'    , elasticity_fe(FE_Nothing<dim>(),'
p24671
aS'                    dim,'
p24672
aS'                    FE_Nothing<dim>(),'
p24673
aS'                    1,'
p24674
aS'                    FE_Q<dim>(elasticity_degree),'
p24675
aS'                    dim)'
p24676
aS'    , dof_handler(triangulation)'
p24677
aS'    , viscosity(2)'
p24678
aS'    , lambda(1)'
p24679
aS'    , mu(1)'
p24680
aS'  {'
p24681
aS'    fe_collection.push_back(stokes_fe);'
p24682
aS'    fe_collection.push_back(elasticity_fe);'
p24683
aS'  }'
p24684
aS'  template <int dim>'
p24685
aS'  bool FluidStructureProblem<dim>::cell_is_in_fluid_domain('
p24686
aS'    const typename DoFHandler<dim>::cell_iterator &cell)'
p24687
aS'  {'
p24688
aS'    return (cell->material_id() == fluid_domain_id);'
p24689
aS'  }'
p24690
aS'  template <int dim>'
p24691
aS'  bool FluidStructureProblem<dim>::cell_is_in_solid_domain('
p24692
aS'    const typename DoFHandler<dim>::cell_iterator &cell)'
p24693
aS'  {'
p24694
aS'    return (cell->material_id() == solid_domain_id);'
p24695
aS'  }'
p24696
aS'  template <int dim>'
p24697
aS'  void FluidStructureProblem<dim>::make_grid()'
p24698
aS'  {'
p24699
aS'    GridGenerator::subdivided_hyper_cube(triangulation, 8, -1, 1);'
p24700
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p24701
aS'      for (const auto &face : cell->face_iterators())'
p24702
aS'        if (face->at_boundary() && (face->center()[dim - 1] == 1))'
p24703
aS'          face->set_all_boundary_ids(1);'
p24704
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p24705
aS'      if (((std::fabs(cell->center()[0]) < 0.25) &&'
p24706
aS'        cell->set_material_id(fluid_domain_id);'
p24707
aS'      else'
p24708
aS'        cell->set_material_id(solid_domain_id);'
p24709
aS'  }'
p24710
aS'  template <int dim>'
p24711
aS'  void FluidStructureProblem<dim>::set_active_fe_indices()'
p24712
aS'  {'
p24713
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p24714
aS'      {'
p24715
aS'        if (cell_is_in_fluid_domain(cell))'
p24716
aS'          cell->set_active_fe_index(0);'
p24717
aS'        else if (cell_is_in_solid_domain(cell))'
p24718
aS'          cell->set_active_fe_index(1);'
p24719
aS'        else'
p24720
aS'          Assert(false, ExcNotImplemented());'
p24721
aS'      }'
p24722
aS'  }'
p24723
aS'  template <int dim>'
p24724
aS'  void FluidStructureProblem<dim>::setup_dofs()'
p24725
aS'  {'
p24726
aS'    set_active_fe_indices();'
p24727
aS'    dof_handler.distribute_dofs(fe_collection);'
p24728
aS'    {'
p24729
aS'      constraints.clear();'
p24730
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p24731
aS'      const FEValuesExtractors::Vector velocities(0);'
p24732
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p24733
aS'                                               1,'
p24734
aS'                                               StokesBoundaryValues<dim>(),'
p24735
aS'                                               constraints,'
p24736
aS'                                               fe_collection.component_mask('
p24737
aS'                                                 velocities));'
p24738
aS'      const FEValuesExtractors::Vector displacements(dim + 1);'
p24739
aS'      VectorTools::interpolate_boundary_values('
p24740
aS'        dof_handler,'
p24741
aS'        0,'
p24742
aS'        Functions::ZeroFunction<dim>(dim + 1 + dim),'
p24743
aS'        constraints,'
p24744
aS'        fe_collection.component_mask(displacements));'
p24745
aS'    }'
p24746
aS'    {'
p24747
aS'      std::vector<types::global_dof_index> local_face_dof_indices('
p24748
aS'        stokes_fe.n_dofs_per_face());'
p24749
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p24750
aS'        if (cell_is_in_fluid_domain(cell))'
p24751
aS'          for (const auto face_no : cell->face_indices())'
p24752
aS'            if (cell->face(face_no)->at_boundary() == false)'
p24753
aS'              {'
p24754
aS'                bool face_is_on_interface = false;'
p24755
aS'                if ((cell->neighbor(face_no)->has_children() == false) &&'
p24756
aS'                  face_is_on_interface = true;'
p24757
aS'                else if (cell->neighbor(face_no)->has_children() == true)'
p24758
aS'                  {'
p24759
aS'                    for (unsigned int sf = 0;'
p24760
aS'                         sf < cell->face(face_no)->n_children();'
p24761
aS'                         ++sf)'
p24762
aS'                      if (cell_is_in_solid_domain('
p24763
aS'                            cell->neighbor_child_on_subface(face_no, sf)))'
p24764
aS'                        {'
p24765
aS'                          face_is_on_interface = true;'
p24766
aS'                          break;'
p24767
aS'                        }'
p24768
aS'                  }'
p24769
aS'                if (face_is_on_interface)'
p24770
aS'                  {'
p24771
aS'                    cell->face(face_no)->get_dof_indices(local_face_dof_indices,'
p24772
aS'                                                         0);'
p24773
aS'                    for (unsigned int i = 0; i < local_face_dof_indices.size();'
p24774
aS'                         ++i)'
p24775
aS'                      if (stokes_fe.face_system_to_component_index(i).first <'
p24776
aS'                          dim)'
p24777
aS'                        constraints.add_line(local_face_dof_indices[i]);'
p24778
aS'                  }'
p24779
aS'              }'
p24780
aS'    }'
p24781
aS'    constraints.close();'
p24782
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p24783
aS'              << std::endl'
p24784
aS'              << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p24785
aS'              << std::endl;'
p24786
aS'    {'
p24787
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p24788
aS'      Table<2, DoFTools::Coupling> cell_coupling(fe_collection.n_components(),'
p24789
aS'                                                 fe_collection.n_components());'
p24790
aS'      Table<2, DoFTools::Coupling> face_coupling(fe_collection.n_components(),'
p24791
aS'                                                 fe_collection.n_components());'
p24792
aS'      for (unsigned int c = 0; c < fe_collection.n_components(); ++c)'
p24793
aS'        for (unsigned int d = 0; d < fe_collection.n_components(); ++d)'
p24794
aS'          {'
p24795
aS'            if (((c < dim + 1) && (d < dim + 1) &&'
p24796
aS'                 !((c == dim) && (d == dim))) ||'
p24797
aS'              cell_coupling[c][d] = DoFTools::always;'
p24798
aS'            if ((c >= dim + 1) && (d < dim + 1))'
p24799
aS'              face_coupling[c][d] = DoFTools::always;'
p24800
aS'          }'
p24801
aS'      DoFTools::make_flux_sparsity_pattern(dof_handler,'
p24802
aS'                                           dsp,'
p24803
aS'                                           cell_coupling,'
p24804
aS'                                           face_coupling);'
p24805
aS'      constraints.condense(dsp);'
p24806
aS'      sparsity_pattern.copy_from(dsp);'
p24807
aS'    }'
p24808
aS'    system_matrix.reinit(sparsity_pattern);'
p24809
aS'    solution.reinit(dof_handler.n_dofs());'
p24810
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p24811
aS'  }'
p24812
aS'  template <int dim>'
p24813
aS'  void FluidStructureProblem<dim>::assemble_system()'
p24814
aS'  {'
p24815
aS'    system_matrix = 0;'
p24816
aS'    system_rhs    = 0;'
p24817
aS'    const QGauss<dim> stokes_quadrature(stokes_degree + 2);'
p24818
aS'    const QGauss<dim> elasticity_quadrature(elasticity_degree + 2);'
p24819
aS'    hp::QCollection<dim> q_collection;'
p24820
aS'    q_collection.push_back(stokes_quadrature);'
p24821
aS'    q_collection.push_back(elasticity_quadrature);'
p24822
aS'    hp::FEValues<dim> hp_fe_values(fe_collection,'
p24823
aS'                                   q_collection,'
p24824
aS'                                   update_values | update_quadrature_points |'
p24825
aS'                                     update_JxW_values | update_gradients);'
p24826
aS'    const QGauss<dim - 1> common_face_quadrature('
p24827
aS'      std::max(stokes_degree + 2, elasticity_degree + 2));'
p24828
aS'    FEFaceValues<dim>    stokes_fe_face_values(stokes_fe,'
p24829
aS'                                            common_face_quadrature,'
p24830
aS'                                            update_JxW_values |'
p24831
aS'                                              update_gradients | update_values);'
p24832
aS'    FEFaceValues<dim>    elasticity_fe_face_values(elasticity_fe,'
p24833
aS'                                                common_face_quadrature,'
p24834
aS'                                                update_normal_vectors |'
p24835
aS'                                                  update_values);'
p24836
aS'    FESubfaceValues<dim> stokes_fe_subface_values(stokes_fe,'
p24837
aS'                                                  common_face_quadrature,'
p24838
aS'                                                  update_JxW_values |'
p24839
aS'                                                    update_gradients |'
p24840
aS'                                                    update_values);'
p24841
aS'    FESubfaceValues<dim> elasticity_fe_subface_values(elasticity_fe,'
p24842
aS'                                                      common_face_quadrature,'
p24843
aS'                                                      update_normal_vectors |'
p24844
aS'                                                        update_values);'
p24845
aS'    const unsigned int stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();'
p24846
aS'    const unsigned int elasticity_dofs_per_cell ='
p24847
aS'      elasticity_fe.n_dofs_per_cell();'
p24848
aS'    FullMatrix<double> local_matrix;'
p24849
aS'    FullMatrix<double> local_interface_matrix(elasticity_dofs_per_cell,'
p24850
aS'                                              stokes_dofs_per_cell);'
p24851
aS'    Vector<double>     local_rhs;'
p24852
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p24853
aS'    std::vector<types::global_dof_index> neighbor_dof_indices('
p24854
aS'      stokes_dofs_per_cell);'
p24855
aS'    const Functions::ZeroFunction<dim> right_hand_side(dim + 1);'
p24856
aS'    const FEValuesExtractors::Vector velocities(0);'
p24857
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p24858
aS'    const FEValuesExtractors::Vector displacements(dim + 1);'
p24859
aS'    std::vector<SymmetricTensor<2, dim>> stokes_symgrad_phi_u('
p24860
aS'      stokes_dofs_per_cell);'
p24861
aS'    std::vector<double> stokes_div_phi_u(stokes_dofs_per_cell);'
p24862
aS'    std::vector<double> stokes_phi_p(stokes_dofs_per_cell);'
p24863
aS'    std::vector<Tensor<2, dim>> elasticity_grad_phi(elasticity_dofs_per_cell);'
p24864
aS'    std::vector<double>         elasticity_div_phi(elasticity_dofs_per_cell);'
p24865
aS'    std::vector<Tensor<1, dim>> elasticity_phi(elasticity_dofs_per_cell);'
p24866
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p24867
aS'      {'
p24868
aS'        hp_fe_values.reinit(cell);'
p24869
aS'        const FEValues<dim> &fe_values = hp_fe_values.get_present_fe_values();'
p24870
aS'        local_matrix.reinit(cell->get_fe().n_dofs_per_cell(),'
p24871
aS'                            cell->get_fe().n_dofs_per_cell());'
p24872
aS'        local_rhs.reinit(cell->get_fe().n_dofs_per_cell());'
p24873
aS'        if (cell_is_in_fluid_domain(cell))'
p24874
aS'          {'
p24875
aS'            const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();'
p24876
aS'            Assert(dofs_per_cell == stokes_dofs_per_cell, ExcInternalError());'
p24877
aS'            for (unsigned int q = 0; q < fe_values.n_quadrature_points; ++q)'
p24878
aS'              {'
p24879
aS'                for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p24880
aS'                  {'
p24881
aS'                    stokes_symgrad_phi_u[k] ='
p24882
aS'                      fe_values[velocities].symmetric_gradient(k, q);'
p24883
aS'                    stokes_div_phi_u[k] ='
p24884
aS'                      fe_values[velocities].divergence(k, q);'
p24885
aS'                    stokes_phi_p[k] = fe_values[pressure].value(k, q);'
p24886
aS'                  }'
p24887
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p24888
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p24889
aS'                    local_matrix(i, j) +='
p24890
aS'                         stokes_symgrad_phi_u[j] -'
p24891
aS'                       stokes_div_phi_u[i] * stokes_phi_p[j] -'
p24892
aS'                       stokes_phi_p[i] * stokes_div_phi_u[j]) *'
p24893
aS'                      fe_values.JxW(q);'
p24894
aS'              }'
p24895
aS'          }'
p24896
aS'        else'
p24897
aS'          {'
p24898
aS'            const unsigned int dofs_per_cell = cell->get_fe().n_dofs_per_cell();'
p24899
aS'            Assert(dofs_per_cell == elasticity_dofs_per_cell,'
p24900
aS'                   ExcInternalError());'
p24901
aS'            for (unsigned int q = 0; q < fe_values.n_quadrature_points; ++q)'
p24902
aS'              {'
p24903
aS'                for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p24904
aS'                  {'
p24905
aS'                    elasticity_grad_phi[k] ='
p24906
aS'                      fe_values[displacements].gradient(k, q);'
p24907
aS'                    elasticity_div_phi[k] ='
p24908
aS'                      fe_values[displacements].divergence(k, q);'
p24909
aS'                  }'
p24910
aS'                for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p24911
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p24912
aS'                    {'
p24913
aS'                      local_matrix(i, j) +='
p24914
aS'                           elasticity_div_phi[j] +'
p24915
aS'                         mu * scalar_product(elasticity_grad_phi[i],'
p24916
aS'                                             elasticity_grad_phi[j]) +'
p24917
aS'                         mu *'
p24918
aS'                           scalar_product(elasticity_grad_phi[i],'
p24919
aS'                                          transpose(elasticity_grad_phi[j]))) *'
p24920
aS'                        fe_values.JxW(q);'
p24921
aS'                    }'
p24922
aS'              }'
p24923
aS'          }'
p24924
aS'        local_dof_indices.resize(cell->get_fe().n_dofs_per_cell());'
p24925
aS'        cell->get_dof_indices(local_dof_indices);'
p24926
aS'        constraints.distribute_local_to_global(local_matrix,'
p24927
aS'                                               local_rhs,'
p24928
aS'                                               local_dof_indices,'
p24929
aS'                                               system_matrix,'
p24930
aS'                                               system_rhs);'
p24931
aS'        if (cell_is_in_solid_domain(cell))'
p24932
aS'          for (const auto f : cell->face_indices())'
p24933
aS'            if (cell->face(f)->at_boundary() == false)'
p24934
aS'              {'
p24935
aS'                if ((cell->neighbor(f)->level() == cell->level()) &&'
p24936
aS'                    cell_is_in_fluid_domain(cell->neighbor(f)))'
p24937
aS'                  {'
p24938
aS'                    elasticity_fe_face_values.reinit(cell, f);'
p24939
aS'                    stokes_fe_face_values.reinit(cell->neighbor(f),'
p24940
aS'                                                 cell->neighbor_of_neighbor(f));'
p24941
aS'                    assemble_interface_term(elasticity_fe_face_values,'
p24942
aS'                                            stokes_fe_face_values,'
p24943
aS'                                            elasticity_phi,'
p24944
aS'                                            stokes_symgrad_phi_u,'
p24945
aS'                                            stokes_phi_p,'
p24946
aS'                                            local_interface_matrix);'
p24947
aS'                    cell->neighbor(f)->get_dof_indices(neighbor_dof_indices);'
p24948
aS'                    constraints.distribute_local_to_global('
p24949
aS'                      local_interface_matrix,'
p24950
aS'                      local_dof_indices,'
p24951
aS'                      neighbor_dof_indices,'
p24952
aS'                      system_matrix);'
p24953
aS'                  }'
p24954
aS'                else if ((cell->neighbor(f)->level() == cell->level()) &&'
p24955
aS'                  {'
p24956
aS'                    for (unsigned int subface = 0;'
p24957
aS'                         subface < cell->face(f)->n_children();'
p24958
aS'                         ++subface)'
p24959
aS'                      if (cell_is_in_fluid_domain('
p24960
aS'                            cell->neighbor_child_on_subface(f, subface)))'
p24961
aS'                        {'
p24962
aS'                          elasticity_fe_subface_values.reinit(cell, f, subface);'
p24963
aS'                          stokes_fe_face_values.reinit('
p24964
aS'                            cell->neighbor_child_on_subface(f, subface),'
p24965
aS'                            cell->neighbor_of_neighbor(f));'
p24966
aS'                          assemble_interface_term(elasticity_fe_subface_values,'
p24967
aS'                                                  stokes_fe_face_values,'
p24968
aS'                                                  elasticity_phi,'
p24969
aS'                                                  stokes_symgrad_phi_u,'
p24970
aS'                                                  stokes_phi_p,'
p24971
aS'                                                  local_interface_matrix);'
p24972
aS'                          cell->neighbor_child_on_subface(f, subface)'
p24973
aS'                            ->get_dof_indices(neighbor_dof_indices);'
p24974
aS'                          constraints.distribute_local_to_global('
p24975
aS'                            local_interface_matrix,'
p24976
aS'                            local_dof_indices,'
p24977
aS'                            neighbor_dof_indices,'
p24978
aS'                            system_matrix);'
p24979
aS'                        }'
p24980
aS'                  }'
p24981
aS'                else if (cell->neighbor_is_coarser(f) &&'
p24982
aS'                         cell_is_in_fluid_domain(cell->neighbor(f)))'
p24983
aS'                  {'
p24984
aS'                    elasticity_fe_face_values.reinit(cell, f);'
p24985
aS'                    stokes_fe_subface_values.reinit('
p24986
aS'                      cell->neighbor(f),'
p24987
aS'                      cell->neighbor_of_coarser_neighbor(f).first,'
p24988
aS'                      cell->neighbor_of_coarser_neighbor(f).second);'
p24989
aS'                    assemble_interface_term(elasticity_fe_face_values,'
p24990
aS'                                            stokes_fe_subface_values,'
p24991
aS'                                            elasticity_phi,'
p24992
aS'                                            stokes_symgrad_phi_u,'
p24993
aS'                                            stokes_phi_p,'
p24994
aS'                                            local_interface_matrix);'
p24995
aS'                    cell->neighbor(f)->get_dof_indices(neighbor_dof_indices);'
p24996
aS'                    constraints.distribute_local_to_global('
p24997
aS'                      local_interface_matrix,'
p24998
aS'                      local_dof_indices,'
p24999
aS'                      neighbor_dof_indices,'
p25000
aS'                      system_matrix);'
p25001
aS'                  }'
p25002
aS'              }'
p25003
aS'      }'
p25004
aS'  }'
p25005
aS'  template <int dim>'
p25006
aS'  void FluidStructureProblem<dim>::assemble_interface_term('
p25007
aS'    const FEFaceValuesBase<dim> &         elasticity_fe_face_values,'
p25008
aS'    const FEFaceValuesBase<dim> &         stokes_fe_face_values,'
p25009
aS'    std::vector<Tensor<1, dim>> &         elasticity_phi,'
p25010
aS'    std::vector<SymmetricTensor<2, dim>> &stokes_symgrad_phi_u,'
p25011
aS'    std::vector<double> &                 stokes_phi_p,'
p25012
aS'    FullMatrix<double> &                  local_interface_matrix) const'
p25013
aS'  {'
p25014
aS'    Assert(stokes_fe_face_values.n_quadrature_points =='
p25015
aS'             elasticity_fe_face_values.n_quadrature_points,'
p25016
aS'           ExcInternalError());'
p25017
aS'    const unsigned int n_face_quadrature_points ='
p25018
aS'      elasticity_fe_face_values.n_quadrature_points;'
p25019
aS'    const FEValuesExtractors::Vector velocities(0);'
p25020
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p25021
aS'    const FEValuesExtractors::Vector displacements(dim + 1);'
p25022
aS'    local_interface_matrix = 0;'
p25023
aS'    for (unsigned int q = 0; q < n_face_quadrature_points; ++q)'
p25024
aS'      {'
p25025
aS'        const Tensor<1, dim> normal_vector ='
p25026
aS'          elasticity_fe_face_values.normal_vector(q);'
p25027
aS'        for (unsigned int k = 0; k < stokes_fe_face_values.dofs_per_cell; ++k)'
p25028
aS'          {'
p25029
aS'            stokes_symgrad_phi_u[k] ='
p25030
aS'              stokes_fe_face_values[velocities].symmetric_gradient(k, q);'
p25031
aS'            stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);'
p25032
aS'          }'
p25033
aS'        for (unsigned int k = 0; k < elasticity_fe_face_values.dofs_per_cell;'
p25034
aS'             ++k)'
p25035
aS'          elasticity_phi[k] ='
p25036
aS'            elasticity_fe_face_values[displacements].value(k, q);'
p25037
aS'        for (unsigned int i = 0; i < elasticity_fe_face_values.dofs_per_cell;'
p25038
aS'             ++i)'
p25039
aS'          for (unsigned int j = 0; j < stokes_fe_face_values.dofs_per_cell; ++j)'
p25040
aS'            local_interface_matrix(i, j) +='
p25041
aS'              -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -'
p25042
aS'                 stokes_phi_p[j] * normal_vector) *'
p25043
aS'                elasticity_phi[i] * stokes_fe_face_values.JxW(q));'
p25044
aS'      }'
p25045
aS'  }'
p25046
aS'  template <int dim>'
p25047
aS'  void FluidStructureProblem<dim>::solve()'
p25048
aS'  {'
p25049
aS'    SparseDirectUMFPACK direct_solver;'
p25050
aS'    direct_solver.initialize(system_matrix);'
p25051
aS'    direct_solver.vmult(solution, system_rhs);'
p25052
aS'    constraints.distribute(solution);'
p25053
aS'  }'
p25054
aS'  template <int dim>'
p25055
aS'  void FluidStructureProblem<dim>::output_results('
p25056
aS'    const unsigned int refinement_cycle) const'
p25057
aS'  {'
p25058
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p25059
aS'    solution_names.emplace_back("pressure");'
p25060
aS'    for (unsigned int d = 0; d < dim; ++d)'
p25061
aS'      solution_names.emplace_back("displacement");'
p25062
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p25063
aS'      data_component_interpretation('
p25064
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p25065
aS'    data_component_interpretation.push_back('
p25066
aS'      DataComponentInterpretation::component_is_scalar);'
p25067
aS'    for (unsigned int d = 0; d < dim; ++d)'
p25068
aS'      data_component_interpretation.push_back('
p25069
aS'        DataComponentInterpretation::component_is_part_of_vector);'
p25070
aS'    DataOut<dim> data_out;'
p25071
aS'    data_out.attach_dof_handler(dof_handler);'
p25072
aS'    data_out.add_data_vector(solution,'
p25073
aS'                             solution_names,'
p25074
aS'                             DataOut<dim>::type_dof_data,'
p25075
aS'                             data_component_interpretation);'
p25076
aS'    data_out.build_patches();'
p25077
aS'    std::ofstream output('
p25078
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk");'
p25079
aS'    data_out.write_vtk(output);'
p25080
aS'  }'
p25081
aS'  template <int dim>'
p25082
aS'  void FluidStructureProblem<dim>::refine_mesh()'
p25083
aS'  {'
p25084
aS'    Vector<float> stokes_estimated_error_per_cell('
p25085
aS'      triangulation.n_active_cells());'
p25086
aS'    Vector<float> elasticity_estimated_error_per_cell('
p25087
aS'      triangulation.n_active_cells());'
p25088
aS'    const QGauss<dim - 1> stokes_face_quadrature(stokes_degree + 2);'
p25089
aS'    const QGauss<dim - 1> elasticity_face_quadrature(elasticity_degree + 2);'
p25090
aS'    hp::QCollection<dim - 1> face_q_collection;'
p25091
aS'    face_q_collection.push_back(stokes_face_quadrature);'
p25092
aS'    face_q_collection.push_back(elasticity_face_quadrature);'
p25093
aS'    const FEValuesExtractors::Vector velocities(0);'
p25094
aS'    KellyErrorEstimator<dim>::estimate('
p25095
aS'      dof_handler,'
p25096
aS'      face_q_collection,'
p25097
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p25098
aS'      solution,'
p25099
aS'      stokes_estimated_error_per_cell,'
p25100
aS'      fe_collection.component_mask(velocities));'
p25101
aS'    const FEValuesExtractors::Vector displacements(dim + 1);'
p25102
aS'    KellyErrorEstimator<dim>::estimate('
p25103
aS'      dof_handler,'
p25104
aS'      face_q_collection,'
p25105
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p25106
aS'      solution,'
p25107
aS'      elasticity_estimated_error_per_cell,'
p25108
aS'      fe_collection.component_mask(displacements));'
p25109
aS'    stokes_estimated_error_per_cell *='
p25110
aS'      4. / stokes_estimated_error_per_cell.l2_norm();'
p25111
aS'    elasticity_estimated_error_per_cell *='
p25112
aS'      1. / elasticity_estimated_error_per_cell.l2_norm();'
p25113
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p25114
aS'    estimated_error_per_cell += stokes_estimated_error_per_cell;'
p25115
aS'    estimated_error_per_cell += elasticity_estimated_error_per_cell;'
p25116
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p25117
aS'      for (const auto f : cell->face_indices())'
p25118
aS'        if (cell_is_in_solid_domain(cell))'
p25119
aS'          {'
p25120
aS'            if ((cell->at_boundary(f) == false) &&'
p25121
aS'                  cell_is_in_fluid_domain(cell->neighbor(f))) ||'
p25122
aS'                    cell->neighbor_child_on_subface(f, 0)))) ||'
p25123
aS'                  cell_is_in_fluid_domain(cell->neighbor(f)))))'
p25124
aS'              estimated_error_per_cell(cell->active_cell_index()) = 0;'
p25125
aS'          }'
p25126
aS'        else'
p25127
aS'          {'
p25128
aS'            if ((cell->at_boundary(f) == false) &&'
p25129
aS'                  cell_is_in_solid_domain(cell->neighbor(f))) ||'
p25130
aS'                    cell->neighbor_child_on_subface(f, 0)))) ||'
p25131
aS'                  cell_is_in_solid_domain(cell->neighbor(f)))))'
p25132
aS'              estimated_error_per_cell(cell->active_cell_index()) = 0;'
p25133
aS'          }'
p25134
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p25135
aS'                                                    estimated_error_per_cell,'
p25136
aS'                                                    0.3,'
p25137
aS'                                                    0.0);'
p25138
aS'    triangulation.execute_coarsening_and_refinement();'
p25139
aS'  }'
p25140
aS'  template <int dim>'
p25141
aS'  void FluidStructureProblem<dim>::run()'
p25142
aS'  {'
p25143
aS'    make_grid();'
p25144
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 10 - 2 * dim;'
p25145
aS'         ++refinement_cycle)'
p25146
aS'      {'
p25147
aS'        std::cout << "Refinement cycle " << refinement_cycle << std::endl;'
p25148
aS'        if (refinement_cycle > 0)'
p25149
aS'          refine_mesh();'
p25150
aS'        setup_dofs();'
p25151
aS'        std::cout << "   Assembling..." << std::endl;'
p25152
aS'        assemble_system();'
p25153
aS'        std::cout << "   Solving..." << std::endl;'
p25154
aS'        solve();'
p25155
aS'        std::cout << "   Writing output..." << std::endl;'
p25156
aS'        output_results(refinement_cycle);'
p25157
aS'        std::cout << std::endl;'
p25158
aS'      }'
p25159
aS'  }'
p25160
aS'} // namespace Step46'
p25161
aS'int main()'
p25162
ag9
aS'  try'
p25163
aS'    {'
p25164
aS'      using namespace Step46;'
p25165
aS'      FluidStructureProblem<2> flow_problem(1, 1);'
p25166
aS'      flow_problem.run();'
p25167
aS'    }'
p25168
aS'  catch (std::exception &exc)'
p25169
aS'    {'
p25170
aS'      std::cerr << std::endl'
p25171
aS'                << std::endl'
p25172
aS'                << "----------------------------------------------------"'
p25173
aS'                << std::endl;'
p25174
aS'      std::cerr << "Exception on processing: " << std::endl'
p25175
aS'                << exc.what() << std::endl'
p25176
aS'                << "Aborting!" << std::endl'
p25177
aS'                << "----------------------------------------------------"'
p25178
aS'                << std::endl;'
p25179
aS'      return 1;'
p25180
aS'    }'
p25181
aS'  catch (...)'
p25182
aS'    {'
p25183
aS'      std::cerr << std::endl'
p25184
aS'                << std::endl'
p25185
aS'                << "----------------------------------------------------"'
p25186
aS'                << std::endl;'
p25187
aS'      std::cerr << "Unknown exception!" << std::endl'
p25188
aS'                << "Aborting!" << std::endl'
p25189
aS'                << "----------------------------------------------------"'
p25190
aS'                << std::endl;'
p25191
aS'      return 1;'
p25192
aS'    }'
p25193
aS'  return 0;'
p25194
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p25195
aS'#include <deal.II/base/function.h>'
p25196
aS'#include <deal.II/lac/vector.h>'
p25197
aS'#include <deal.II/lac/full_matrix.h>'
p25198
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p25199
aS'#include <deal.II/lac/solver_cg.h>'
p25200
aS'#include <deal.II/lac/sparse_matrix.h>'
p25201
aS'#include <deal.II/lac/sparse_direct.h>'
p25202
aS'#include <deal.II/grid/tria.h>'
p25203
aS'#include <deal.II/grid/grid_generator.h>'
p25204
aS'#include <deal.II/fe/fe_q.h>'
p25205
aS'#include <deal.II/fe/fe_values.h>'
p25206
aS'#include <deal.II/fe/mapping_q.h>'
p25207
aS'#include <deal.II/dofs/dof_handler.h>'
p25208
aS'#include <deal.II/dofs/dof_tools.h>'
p25209
aS'#include <deal.II/numerics/vector_tools.h>'
p25210
aS'#include <deal.II/numerics/data_out.h>'
p25211
aS'#include <deal.II/fe/fe_interface_values.h>'
p25212
aS'#include <deal.II/meshworker/mesh_loop.h>'
p25213
aS'#include <fstream>'
p25214
aS'#include <iostream>'
p25215
aS'#include <cmath>'
p25216
aS'namespace Step47'
p25217
ag9
aS'  using namespace dealii;'
p25218
aS'  namespace ExactSolution'
p25219
aS'  {'
p25220
aS'    using numbers::PI;'
p25221
aS'    template <int dim>'
p25222
aS'    class Solution : public Function<dim>'
p25223
aS'    {'
p25224
aS'    public:'
p25225
aS'      static_assert(dim == 2, "Only dim==2 is implemented.");'
p25226
aS'      virtual double value(const Point<dim> &p,'
p25227
aS'                           const unsigned int /*component*/ = 0) const override'
p25228
aS'      {'
p25229
aS'        return std::sin(PI * p[0]) * std::sin(PI * p[1]);'
p25230
aS'      }'
p25231
aS'      virtual Tensor<1, dim>'
p25232
aS'      gradient(const Point<dim> &p,'
p25233
aS'               const unsigned int /*component*/ = 0) const override'
p25234
aS'      {'
p25235
aS'        Tensor<1, dim> r;'
p25236
aS'        r[0] = PI * std::cos(PI * p[0]) * std::sin(PI * p[1]);'
p25237
aS'        r[1] = PI * std::cos(PI * p[1]) * std::sin(PI * p[0]);'
p25238
aS'        return r;'
p25239
aS'      }'
p25240
aS'      virtual void'
p25241
aS'      hessian_list(const std::vector<Point<dim>> &       points,'
p25242
aS'                   std::vector<SymmetricTensor<2, dim>> &hessians,'
p25243
aS'                   const unsigned int /*component*/ = 0) const override'
p25244
aS'      {'
p25245
aS'        for (unsigned i = 0; i < points.size(); ++i)'
p25246
aS'          {'
p25247
aS'            const double x = points[i][0];'
p25248
aS'            const double y = points[i][1];'
p25249
aS'            hessians[i][0][0] = -PI * PI * std::sin(PI * x) * std::sin(PI * y);'
p25250
aS'            hessians[i][0][1] = PI * PI * std::cos(PI * x) * std::cos(PI * y);'
p25251
aS'            hessians[i][1][1] = -PI * PI * std::sin(PI * x) * std::sin(PI * y);'
p25252
aS'          }'
p25253
aS'      }'
p25254
aS'    };'
p25255
aS'    template <int dim>'
p25256
aS'    class RightHandSide : public Function<dim>'
p25257
aS'    {'
p25258
aS'    public:'
p25259
aS'      static_assert(dim == 2, "Only dim==2 is implemented");'
p25260
aS'      virtual double value(const Point<dim> &p,'
p25261
aS'                           const unsigned int /*component*/ = 0) const override'
p25262
aS'      {'
p25263
aS'        return 4 * std::pow(PI, 4.0) * std::sin(PI * p[0]) *'
p25264
aS'               std::sin(PI * p[1]);'
p25265
aS'      }'
p25266
aS'    };'
p25267
aS'  } // namespace ExactSolution'
p25268
aS'  template <int dim>'
p25269
aS'  class BiharmonicProblem'
p25270
aS'  {'
p25271
aS'  public:'
p25272
aS'    BiharmonicProblem(const unsigned int fe_degree);'
p25273
aS'    void run();'
p25274
aS'  private:'
p25275
aS'    void make_grid();'
p25276
aS'    void setup_system();'
p25277
aS'    void assemble_system();'
p25278
aS'    void solve();'
p25279
aS'    void compute_errors();'
p25280
aS'    void output_results(const unsigned int iteration) const;'
p25281
aS'    Triangulation<dim> triangulation;'
p25282
aS'    MappingQ<dim> mapping;'
p25283
aS'    FE_Q<dim>                 fe;'
p25284
aS'    DoFHandler<dim>           dof_handler;'
p25285
aS'    AffineConstraints<double> constraints;'
p25286
aS'    SparsityPattern      sparsity_pattern;'
p25287
aS'    SparseMatrix<double> system_matrix;'
p25288
aS'    Vector<double> solution;'
p25289
aS'    Vector<double> system_rhs;'
p25290
aS'  };'
p25291
aS'  template <int dim>'
p25292
aS'  BiharmonicProblem<dim>::BiharmonicProblem(const unsigned int fe_degree)'
p25293
aS'    : mapping(1)'
p25294
aS'    , fe(fe_degree)'
p25295
aS'    , dof_handler(triangulation)'
p25296
aS'  {}'
p25297
aS'  template <int dim>'
p25298
aS'  void BiharmonicProblem<dim>::make_grid()'
p25299
aS'  {'
p25300
aS'    GridGenerator::hyper_cube(triangulation, 0., 1.);'
p25301
aS'    triangulation.refine_global(1);'
p25302
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p25303
aS'              << std::endl'
p25304
aS'              << "Total number of cells: " << triangulation.n_cells()'
p25305
aS'              << std::endl;'
p25306
aS'  }'
p25307
aS'  template <int dim>'
p25308
aS'  void BiharmonicProblem<dim>::setup_system()'
p25309
aS'  {'
p25310
aS'    dof_handler.distribute_dofs(fe);'
p25311
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p25312
aS'              << std::endl;'
p25313
aS'    constraints.clear();'
p25314
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p25315
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p25316
aS'                                             0,'
p25317
aS'                                             ExactSolution::Solution<dim>(),'
p25318
aS'                                             constraints);'
p25319
aS'    constraints.close();'
p25320
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p25321
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp, constraints, true);'
p25322
aS'    sparsity_pattern.copy_from(dsp);'
p25323
aS'    system_matrix.reinit(sparsity_pattern);'
p25324
aS'    solution.reinit(dof_handler.n_dofs());'
p25325
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p25326
aS'  }'
p25327
aS'  template <int dim>'
p25328
aS'  struct ScratchData'
p25329
aS'  {'
p25330
aS'    ScratchData(const Mapping<dim> &      mapping,'
p25331
aS'                const FiniteElement<dim> &fe,'
p25332
aS'                const unsigned int        quadrature_degree,'
p25333
aS'                const UpdateFlags         update_flags,'
p25334
aS'                const UpdateFlags         interface_update_flags)'
p25335
aS'      : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)'
p25336
aS'      , fe_interface_values(mapping,'
p25337
aS'                            fe,'
p25338
aS'                            QGauss<dim - 1>(quadrature_degree),'
p25339
aS'                            interface_update_flags)'
p25340
aS'    {}'
p25341
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p25342
aS'      : fe_values(scratch_data.fe_values.get_mapping(),'
p25343
aS'                  scratch_data.fe_values.get_fe(),'
p25344
aS'                  scratch_data.fe_values.get_quadrature(),'
p25345
aS'                  scratch_data.fe_values.get_update_flags())'
p25346
aS'      , fe_interface_values(scratch_data.fe_values.get_mapping(),'
p25347
aS'                            scratch_data.fe_values.get_fe(),'
p25348
aS'                            scratch_data.fe_interface_values.get_quadrature(),'
p25349
aS'                            scratch_data.fe_interface_values.get_update_flags())'
p25350
aS'    {}'
p25351
aS'    FEValues<dim>          fe_values;'
p25352
aS'    FEInterfaceValues<dim> fe_interface_values;'
p25353
aS'  };'
p25354
aS'  struct CopyData'
p25355
aS'  {'
p25356
aS'    CopyData(const unsigned int dofs_per_cell)'
p25357
aS'      : cell_matrix(dofs_per_cell, dofs_per_cell)'
p25358
aS'      , cell_rhs(dofs_per_cell)'
p25359
aS'      , local_dof_indices(dofs_per_cell)'
p25360
aS'    {}'
p25361
aS'    CopyData(const CopyData &) = default;'
p25362
aS'    CopyData(CopyData &&) = default;'
p25363
aS'    ~CopyData() = default;'
p25364
aS'    CopyData &operator=(const CopyData &) = default;'
p25365
aS'    CopyData &operator=(CopyData &&) = default;'
p25366
aS'    struct FaceData'
p25367
aS'    {'
p25368
aS'      FullMatrix<double>                   cell_matrix;'
p25369
aS'      std::vector<types::global_dof_index> joint_dof_indices;'
p25370
aS'    };'
p25371
aS'    FullMatrix<double>                   cell_matrix;'
p25372
aS'    Vector<double>                       cell_rhs;'
p25373
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p25374
aS'    std::vector<FaceData>                face_data;'
p25375
aS'  };'
p25376
aS'  template <int dim>'
p25377
aS'  void BiharmonicProblem<dim>::assemble_system()'
p25378
aS'  {'
p25379
aS'    using Iterator = typename DoFHandler<dim>::active_cell_iterator;'
p25380
aS'    auto cell_worker = [&](const Iterator &  cell,'
p25381
aS'                           ScratchData<dim> &scratch_data,'
p25382
aS'                           CopyData &        copy_data) {'
p25383
aS'      copy_data.cell_matrix = 0;'
p25384
aS'      copy_data.cell_rhs    = 0;'
p25385
aS'      FEValues<dim> &fe_values = scratch_data.fe_values;'
p25386
aS'      fe_values.reinit(cell);'
p25387
aS'      cell->get_dof_indices(copy_data.local_dof_indices);'
p25388
aS'      const ExactSolution::RightHandSide<dim> right_hand_side;'
p25389
aS'      const unsigned int dofs_per_cell ='
p25390
aS'        scratch_data.fe_values.get_fe().n_dofs_per_cell();'
p25391
aS'      for (unsigned int qpoint = 0; qpoint < fe_values.n_quadrature_points;'
p25392
aS'           ++qpoint)'
p25393
aS'        {'
p25394
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p25395
aS'            {'
p25396
aS'              const Tensor<2, dim> &hessian_i ='
p25397
aS'                fe_values.shape_hessian(i, qpoint);'
p25398
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p25399
aS'                {'
p25400
aS'                  const Tensor<2, dim> &hessian_j ='
p25401
aS'                    fe_values.shape_hessian(j, qpoint);'
p25402
aS'                  copy_data.cell_matrix(i, j) +='
p25403
aS'                    scalar_product(hessian_i,   // nabla^2 phi_i(x)'
p25404
aS'                                   hessian_j) * // nabla^2 phi_j(x)'
p25405
aS'                    fe_values.JxW(qpoint);      // dx'
p25406
aS'                }'
p25407
aS'              copy_data.cell_rhs(i) +='
p25408
aS'                fe_values.shape_value(i, qpoint) * // phi_i(x)'
p25409
aS'                right_hand_side.value('
p25410
aS'                  fe_values.quadrature_point(qpoint)) * // f(x)'
p25411
aS'                fe_values.JxW(qpoint);                  // dx'
p25412
aS'            }'
p25413
aS'        }'
p25414
aS'    };'
p25415
aS'    auto face_worker = [&](const Iterator &    cell,'
p25416
aS'                           const unsigned int &f,'
p25417
aS'                           const unsigned int &sf,'
p25418
aS'                           const Iterator &    ncell,'
p25419
aS'                           const unsigned int &nf,'
p25420
aS'                           const unsigned int &nsf,'
p25421
aS'                           ScratchData<dim> &  scratch_data,'
p25422
aS'                           CopyData &          copy_data) {'
p25423
aS'      FEInterfaceValues<dim> &fe_interface_values ='
p25424
aS'        scratch_data.fe_interface_values;'
p25425
aS'      fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf);'
p25426
aS'      copy_data.face_data.emplace_back();'
p25427
aS'      CopyData::FaceData &copy_data_face = copy_data.face_data.back();'
p25428
aS'      copy_data_face.joint_dof_indices ='
p25429
aS'        fe_interface_values.get_interface_dof_indices();'
p25430
aS'      const unsigned int n_interface_dofs ='
p25431
aS'        fe_interface_values.n_current_interface_dofs();'
p25432
aS'      copy_data_face.cell_matrix.reinit(n_interface_dofs, n_interface_dofs);'
p25433
aS'      const unsigned int p = fe.degree;'
p25434
aS'      const double       gamma_over_h ='
p25435
aS'        std::max((1.0 * p * (p + 1) /'
p25436
aS'                  cell->extent_in_direction('
p25437
aS'                    GeometryInfo<dim>::unit_normal_direction[f])),'
p25438
aS'                  ncell->extent_in_direction('
p25439
aS'                    GeometryInfo<dim>::unit_normal_direction[nf])));'
p25440
aS'      for (unsigned int qpoint = 0;'
p25441
aS'           qpoint < fe_interface_values.n_quadrature_points;'
p25442
aS'           ++qpoint)'
p25443
aS'        {'
p25444
aS'          const auto &n = fe_interface_values.normal(qpoint);'
p25445
aS'          for (unsigned int i = 0; i < n_interface_dofs; ++i)'
p25446
aS'            {'
p25447
aS'              const double av_hessian_i_dot_n_dot_n ='
p25448
aS'              const double jump_grad_i_dot_n ='
p25449
aS'              for (unsigned int j = 0; j < n_interface_dofs; ++j)'
p25450
aS'                {'
p25451
aS'                  const double av_hessian_j_dot_n_dot_n ='
p25452
aS'                  const double jump_grad_j_dot_n ='
p25453
aS'                  copy_data_face.cell_matrix(i, j) +='
p25454
aS'                     - av_hessian_j_dot_n_dot_n      // - {grad^2 u n n }'
p25455
aS'                     +                               // +'
p25456
aS'                     gamma_over_h *                  // gamma/h'
p25457
aS'                       jump_grad_i_dot_n *           // [grad v n]'
p25458
aS'                       jump_grad_j_dot_n) *          // [grad u n]'
p25459
aS'                    fe_interface_values.JxW(qpoint); // dx'
p25460
aS'                }'
p25461
aS'            }'
p25462
aS'        }'
p25463
aS'    };'
p25464
aS'    auto boundary_worker = [&](const Iterator &    cell,'
p25465
aS'                               const unsigned int &face_no,'
p25466
aS'                               ScratchData<dim> &  scratch_data,'
p25467
aS'                               CopyData &          copy_data) {'
p25468
aS'      FEInterfaceValues<dim> &fe_interface_values ='
p25469
aS'        scratch_data.fe_interface_values;'
p25470
aS'      fe_interface_values.reinit(cell, face_no);'
p25471
aS'      const auto &q_points = fe_interface_values.get_quadrature_points();'
p25472
aS'      copy_data.face_data.emplace_back();'
p25473
aS'      CopyData::FaceData &copy_data_face = copy_data.face_data.back();'
p25474
aS'      const unsigned int n_dofs ='
p25475
aS'        fe_interface_values.n_current_interface_dofs();'
p25476
aS'      copy_data_face.joint_dof_indices ='
p25477
aS'        fe_interface_values.get_interface_dof_indices();'
p25478
aS'      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);'
p25479
aS'      const std::vector<double> &JxW = fe_interface_values.get_JxW_values();'
p25480
aS'      const std::vector<Tensor<1, dim>> &normals ='
p25481
aS'        fe_interface_values.get_normal_vectors();'
p25482
aS'      const ExactSolution::Solution<dim> exact_solution;'
p25483
aS'      std::vector<Tensor<1, dim>>        exact_gradients(q_points.size());'
p25484
aS'      exact_solution.gradient_list(q_points, exact_gradients);'
p25485
aS'      const unsigned int p = fe.degree;'
p25486
aS'      const double       gamma_over_h ='
p25487
aS'         cell->extent_in_direction('
p25488
aS'           GeometryInfo<dim>::unit_normal_direction[face_no]));'
p25489
aS'      for (unsigned int qpoint = 0; qpoint < q_points.size(); ++qpoint)'
p25490
aS'        {'
p25491
aS'          const auto &n = normals[qpoint];'
p25492
aS'          for (unsigned int i = 0; i < n_dofs; ++i)'
p25493
aS'            {'
p25494
aS'              const double av_hessian_i_dot_n_dot_n ='
p25495
aS'              const double jump_grad_i_dot_n ='
p25496
aS'              for (unsigned int j = 0; j < n_dofs; ++j)'
p25497
aS'                {'
p25498
aS'                  const double av_hessian_j_dot_n_dot_n ='
p25499
aS'                  const double jump_grad_j_dot_n ='
p25500
aS'                  copy_data_face.cell_matrix(i, j) +='
p25501
aS'                     - av_hessian_j_dot_n_dot_n // - {grad^2 u n n}'
p25502
aS'                     + gamma_over_h             //  gamma/h'
p25503
aS'                    JxW[qpoint]; // dx'
p25504
aS'                }'
p25505
aS'              copy_data.cell_rhs(i) +='
p25506
aS'                 +                                 // +'
p25507
aS'                 gamma_over_h                      //  gamma/h'
p25508
aS'                JxW[qpoint]; // dx'
p25509
aS'            }'
p25510
aS'        }'
p25511
aS'    };'
p25512
aS'    auto copier = [&](const CopyData &copy_data) {'
p25513
aS'      constraints.distribute_local_to_global(copy_data.cell_matrix,'
p25514
aS'                                             copy_data.cell_rhs,'
p25515
aS'                                             copy_data.local_dof_indices,'
p25516
aS'                                             system_matrix,'
p25517
aS'                                             system_rhs);'
p25518
aS'      for (auto &cdf : copy_data.face_data)'
p25519
aS'        {'
p25520
aS'          constraints.distribute_local_to_global(cdf.cell_matrix,'
p25521
aS'                                                 cdf.joint_dof_indices,'
p25522
aS'                                                 system_matrix);'
p25523
aS'        }'
p25524
aS'    };'
p25525
aS'    const unsigned int n_gauss_points = dof_handler.get_fe().degree + 1;'
p25526
aS'    ScratchData<dim>   scratch_data(mapping,'
p25527
aS'                                  fe,'
p25528
aS'                                  n_gauss_points,'
p25529
aS'                                  update_values | update_gradients |'
p25530
aS'                                    update_hessians | update_quadrature_points |'
p25531
aS'                                    update_JxW_values,'
p25532
aS'                                  update_values | update_gradients |'
p25533
aS'                                    update_hessians | update_quadrature_points |'
p25534
aS'                                    update_JxW_values | update_normal_vectors);'
p25535
aS'    CopyData           copy_data(dof_handler.get_fe().n_dofs_per_cell());'
p25536
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p25537
aS'                          dof_handler.end(),'
p25538
aS'                          cell_worker,'
p25539
aS'                          copier,'
p25540
aS'                          scratch_data,'
p25541
aS'                          copy_data,'
p25542
aS'                          MeshWorker::assemble_own_cells |'
p25543
aS'                            MeshWorker::assemble_boundary_faces |'
p25544
aS'                            MeshWorker::assemble_own_interior_faces_once,'
p25545
aS'                          boundary_worker,'
p25546
aS'                          face_worker);'
p25547
aS'  }'
p25548
aS'  template <int dim>'
p25549
aS'  void BiharmonicProblem<dim>::solve()'
p25550
aS'  {'
p25551
aS'    std::cout << "   Solving system..." << std::endl;'
p25552
aS'    SparseDirectUMFPACK A_direct;'
p25553
aS'    A_direct.initialize(system_matrix);'
p25554
aS'    A_direct.vmult(solution, system_rhs);'
p25555
aS'    constraints.distribute(solution);'
p25556
aS'  }'
p25557
aS'  template <int dim>'
p25558
aS'  void BiharmonicProblem<dim>::compute_errors()'
p25559
aS'  {'
p25560
aS'    {'
p25561
aS'      Vector<float> norm_per_cell(triangulation.n_active_cells());'
p25562
aS'      VectorTools::integrate_difference(mapping,'
p25563
aS'                                        dof_handler,'
p25564
aS'                                        solution,'
p25565
aS'                                        ExactSolution::Solution<dim>(),'
p25566
aS'                                        norm_per_cell,'
p25567
aS'                                        QGauss<dim>(fe.degree + 2),'
p25568
aS'                                        VectorTools::L2_norm);'
p25569
aS'      const double error_norm ='
p25570
aS'        VectorTools::compute_global_error(triangulation,'
p25571
aS'                                          norm_per_cell,'
p25572
aS'                                          VectorTools::L2_norm);'
p25573
aS'      std::cout << "   Error in the L2 norm           :     " << error_norm'
p25574
aS'                << std::endl;'
p25575
aS'    }'
p25576
aS'    {'
p25577
aS'      Vector<float> norm_per_cell(triangulation.n_active_cells());'
p25578
aS'      VectorTools::integrate_difference(mapping,'
p25579
aS'                                        dof_handler,'
p25580
aS'                                        solution,'
p25581
aS'                                        ExactSolution::Solution<dim>(),'
p25582
aS'                                        norm_per_cell,'
p25583
aS'                                        QGauss<dim>(fe.degree + 2),'
p25584
aS'                                        VectorTools::H1_seminorm);'
p25585
aS'      const double error_norm ='
p25586
aS'        VectorTools::compute_global_error(triangulation,'
p25587
aS'                                          norm_per_cell,'
p25588
aS'                                          VectorTools::H1_seminorm);'
p25589
aS'      std::cout << "   Error in the H1 seminorm       : " << error_norm'
p25590
aS'                << std::endl;'
p25591
aS'    }'
p25592
aS'    {'
p25593
aS'      const QGauss<dim>            quadrature_formula(fe.degree + 2);'
p25594
aS'      ExactSolution::Solution<dim> exact_solution;'
p25595
aS'      Vector<double> error_per_cell(triangulation.n_active_cells());'
p25596
aS'      FEValues<dim> fe_values(mapping,'
p25597
aS'                              fe,'
p25598
aS'                              quadrature_formula,'
p25599
aS'                              update_values | update_hessians |'
p25600
aS'                                update_quadrature_points | update_JxW_values);'
p25601
aS'      FEValuesExtractors::Scalar scalar(0);'
p25602
aS'      const unsigned int         n_q_points = quadrature_formula.size();'
p25603
aS'      std::vector<SymmetricTensor<2, dim>> exact_hessians(n_q_points);'
p25604
aS'      std::vector<Tensor<2, dim>>          hessians(n_q_points);'
p25605
aS'      for (auto &cell : dof_handler.active_cell_iterators())'
p25606
aS'        {'
p25607
aS'          fe_values.reinit(cell);'
p25608
aS'          fe_values[scalar].get_function_hessians(solution, hessians);'
p25609
aS'          exact_solution.hessian_list(fe_values.get_quadrature_points(),'
p25610
aS'                                      exact_hessians);'
p25611
aS'          double local_error = 0;'
p25612
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p25613
aS'            {'
p25614
aS'              local_error +='
p25615
aS'                 fe_values.JxW(q_point));'
p25616
aS'            }'
p25617
aS'          error_per_cell[cell->active_cell_index()] = std::sqrt(local_error);'
p25618
aS'        }'
p25619
aS'      const double error_norm = error_per_cell.l2_norm();'
p25620
aS'      std::cout << "   Error in the broken H2 seminorm: " << error_norm'
p25621
aS'                << std::endl;'
p25622
aS'    }'
p25623
aS'  }'
p25624
aS'  template <int dim>'
p25625
aS'  void'
p25626
aS'  BiharmonicProblem<dim>::output_results(const unsigned int iteration) const'
p25627
aS'  {'
p25628
aS'    std::cout << "   Writing graphical output..." << std::endl;'
p25629
aS'    DataOut<dim> data_out;'
p25630
aS'    data_out.attach_dof_handler(dof_handler);'
p25631
aS'    data_out.add_data_vector(solution, "solution");'
p25632
aS'    data_out.build_patches();'
p25633
aS'    const std::string filename ='
p25634
aS'    std::ofstream output_vtu(filename);'
p25635
aS'    data_out.write_vtu(output_vtu);'
p25636
aS'  }'
p25637
aS'  template <int dim>'
p25638
aS'  void BiharmonicProblem<dim>::run()'
p25639
aS'  {'
p25640
aS'    make_grid();'
p25641
aS'    const unsigned int n_cycles = 4;'
p25642
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p25643
aS'      {'
p25644
aS'        std::cout << "Cycle " << cycle << " of " << n_cycles << std::endl;'
p25645
aS'        triangulation.refine_global(1);'
p25646
aS'        setup_system();'
p25647
aS'        assemble_system();'
p25648
aS'        solve();'
p25649
aS'        output_results(cycle);'
p25650
aS'        compute_errors();'
p25651
aS'        std::cout << std::endl;'
p25652
aS'      }'
p25653
aS'  }'
p25654
aS'} // namespace Step47'
p25655
aS'int main()'
p25656
ag9
aS'  try'
p25657
aS'    {'
p25658
aS'      using namespace dealii;'
p25659
aS'      using namespace Step47;'
p25660
aS'      const unsigned int fe_degree = 2;'
p25661
aS'      Assert(fe_degree >= 2,'
p25662
aS'             ExcMessage("The C0IP formulation for the biharmonic problem "'
p25663
aS'                        "only works if one uses elements of polynomial "'
p25664
aS'                        "degree at least 2."));'
p25665
aS'      BiharmonicProblem<2> biharmonic_problem(fe_degree);'
p25666
aS'      biharmonic_problem.run();'
p25667
aS'    }'
p25668
aS'  catch (std::exception &exc)'
p25669
aS'    {'
p25670
aS'      std::cerr << std::endl'
p25671
aS'                << std::endl'
p25672
aS'                << "----------------------------------------------------"'
p25673
aS'                << std::endl;'
p25674
aS'      std::cerr << "Exception on processing: " << std::endl'
p25675
aS'                << exc.what() << std::endl'
p25676
aS'                << "Aborting!" << std::endl'
p25677
aS'                << "----------------------------------------------------"'
p25678
aS'                << std::endl;'
p25679
aS'      return 1;'
p25680
aS'    }'
p25681
aS'  catch (...)'
p25682
aS'    {'
p25683
aS'      std::cerr << std::endl'
p25684
aS'                << std::endl'
p25685
aS'                << "----------------------------------------------------"'
p25686
aS'                << std::endl;'
p25687
aS'      std::cerr << "Unknown exception!" << std::endl'
p25688
aS'                << "Aborting!" << std::endl'
p25689
aS'                << "----------------------------------------------------"'
p25690
aS'                << std::endl;'
p25691
aS'      return 1;'
p25692
aS'    }'
p25693
aS'  return 0;'
p25694
ag17
aS'#include <deal.II/base/logstream.h>'
p25695
aS'#include <deal.II/base/utilities.h>'
p25696
aS'#include <deal.II/base/function.h>'
p25697
aS'#include <deal.II/base/conditional_ostream.h>'
p25698
aS'#include <deal.II/base/timer.h>'
p25699
aS'#include <deal.II/lac/vector.h>'
p25700
aS'#include <deal.II/grid/tria.h>'
p25701
aS'#include <deal.II/grid/grid_generator.h>'
p25702
aS'#include <deal.II/dofs/dof_tools.h>'
p25703
aS'#include <deal.II/dofs/dof_handler.h>'
p25704
aS'#include <deal.II/lac/affine_constraints.h>'
p25705
aS'#include <deal.II/fe/fe_q.h>'
p25706
aS'#include <deal.II/fe/fe_values.h>'
p25707
aS'#include <deal.II/numerics/vector_tools.h>'
p25708
aS'#include <deal.II/numerics/data_out.h>'
p25709
aS'#include <deal.II/distributed/tria.h>'
p25710
aS'#include <deal.II/lac/la_parallel_vector.h>'
p25711
aS'#include <deal.II/matrix_free/matrix_free.h>'
p25712
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p25713
aS'#include <fstream>'
p25714
aS'#include <iostream>'
p25715
aS'#include <iomanip>'
p25716
aS'namespace Step48'
p25717
ag9
aS'  using namespace dealii;'
p25718
aS'  const unsigned int dimension = 2;'
p25719
aS'  const unsigned int fe_degree = 4;'
p25720
aS'  template <int dim, int fe_degree>'
p25721
aS'  class SineGordonOperation'
p25722
aS'  {'
p25723
aS'  public:'
p25724
aS'    SineGordonOperation(const MatrixFree<dim, double> &data_in,'
p25725
aS'                        const double                   time_step);'
p25726
aS'    void apply(LinearAlgebra::distributed::Vector<double> &dst,'
p25727
aS'               const std::vector<LinearAlgebra::distributed::Vector<double> *>'
p25728
aS'                 &src) const;'
p25729
aS'  private:'
p25730
aS'    const MatrixFree<dim, double> &            data;'
p25731
aS'    const VectorizedArray<double>              delta_t_sqr;'
p25732
aS'    LinearAlgebra::distributed::Vector<double> inv_mass_matrix;'
p25733
aS'    void local_apply('
p25734
aS'      const MatrixFree<dim, double> &                                  data,'
p25735
aS'      LinearAlgebra::distributed::Vector<double> &                     dst,'
p25736
aS'      const std::vector<LinearAlgebra::distributed::Vector<double> *> &src,'
p25737
aS'      const std::pair<unsigned int, unsigned int> &cell_range) const;'
p25738
aS'  };'
p25739
aS'  template <int dim, int fe_degree>'
p25740
aS'  SineGordonOperation<dim, fe_degree>::SineGordonOperation('
p25741
aS'    const MatrixFree<dim, double> &data_in,'
p25742
aS'    const double                   time_step)'
p25743
aS'    : data(data_in)'
p25744
aS'    , delta_t_sqr(make_vectorized_array(time_step * time_step))'
p25745
aS'  {'
p25746
aS'    data.initialize_dof_vector(inv_mass_matrix);'
p25747
aS'    FEEvaluation<dim, fe_degree> fe_eval(data);'
p25748
aS'    const unsigned int           n_q_points = fe_eval.n_q_points;'
p25749
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p25750
aS'      {'
p25751
aS'        fe_eval.reinit(cell);'
p25752
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p25753
aS'          fe_eval.submit_value(make_vectorized_array(1.), q);'
p25754
aS'        fe_eval.integrate(EvaluationFlags::values);'
p25755
aS'        fe_eval.distribute_local_to_global(inv_mass_matrix);'
p25756
aS'      }'
p25757
aS'    inv_mass_matrix.compress(VectorOperation::add);'
p25758
aS'    for (unsigned int k = 0; k < inv_mass_matrix.locally_owned_size(); ++k)'
p25759
aS'      if (inv_mass_matrix.local_element(k) > 1e-15)'
p25760
aS'        inv_mass_matrix.local_element(k) ='
p25761
aS'          1. / inv_mass_matrix.local_element(k);'
p25762
aS'      else'
p25763
aS'        inv_mass_matrix.local_element(k) = 1;'
p25764
aS'  }'
p25765
aS'  template <int dim, int fe_degree>'
p25766
aS'  void SineGordonOperation<dim, fe_degree>::local_apply('
p25767
aS'    const MatrixFree<dim> &                                          data,'
p25768
aS'    LinearAlgebra::distributed::Vector<double> &                     dst,'
p25769
aS'    const std::vector<LinearAlgebra::distributed::Vector<double> *> &src,'
p25770
aS'    const std::pair<unsigned int, unsigned int> &cell_range) const'
p25771
aS'  {'
p25772
aS'    AssertDimension(src.size(), 2);'
p25773
aS'    FEEvaluation<dim, fe_degree> current(data), old(data);'
p25774
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p25775
aS'      {'
p25776
aS'        current.reinit(cell);'
p25777
aS'        old.reinit(cell);'
p25778
aS'        current.read_dof_values(*src[0]);'
p25779
aS'        old.read_dof_values(*src[1]);'
p25780
aS'        current.evaluate(EvaluationFlags::values | EvaluationFlags::gradients);'
p25781
aS'        old.evaluate(EvaluationFlags::values);'
p25782
aS'        for (unsigned int q = 0; q < current.n_q_points; ++q)'
p25783
aS'          {'
p25784
aS'            const VectorizedArray<double> current_value = current.get_value(q);'
p25785
aS'            const VectorizedArray<double> old_value     = old.get_value(q);'
p25786
aS'            current.submit_value(2. * current_value - old_value -'
p25787
aS'                                   delta_t_sqr * std::sin(current_value),'
p25788
aS'                                 q);'
p25789
aS'            current.submit_gradient(-delta_t_sqr * current.get_gradient(q), q);'
p25790
aS'          }'
p25791
aS'        current.integrate(EvaluationFlags::values | EvaluationFlags::gradients);'
p25792
aS'        current.distribute_local_to_global(dst);'
p25793
aS'      }'
p25794
aS'  }'
p25795
aS'  template <int dim, int fe_degree>'
p25796
aS'  void SineGordonOperation<dim, fe_degree>::apply('
p25797
aS'    LinearAlgebra::distributed::Vector<double> &                     dst,'
p25798
aS'    const std::vector<LinearAlgebra::distributed::Vector<double> *> &src) const'
p25799
aS'  {'
p25800
aS'    data.cell_loop('
p25801
aS'      &SineGordonOperation<dim, fe_degree>::local_apply, this, dst, src, true);'
p25802
aS'    dst.scale(inv_mass_matrix);'
p25803
aS'  }'
p25804
aS'  template <int dim>'
p25805
aS'  class InitialCondition : public Function<dim>'
p25806
aS'  {'
p25807
aS'  public:'
p25808
aS'    InitialCondition(const unsigned int n_components = 1,'
p25809
aS'                     const double       time         = 0.)'
p25810
aS'      : Function<dim>(n_components, time)'
p25811
aS'    {}'
p25812
aS'    virtual double value(const Point<dim> &p,'
p25813
aS'                         const unsigned int /*component*/) const override'
p25814
aS'    {'
p25815
aS'      double t = this->get_time();'
p25816
aS'      const double m  = 0.5;'
p25817
aS'      const double c1 = 0.;'
p25818
aS'      const double c2 = 0.;'
p25819
aS'      const double factor ='
p25820
aS'      double result = 1.;'
p25821
aS'      for (unsigned int d = 0; d < dim; ++d)'
p25822
aS'        result *= -4. * std::atan(factor / std::cosh(m * p[d] + c1));'
p25823
aS'      return result;'
p25824
aS'    }'
p25825
aS'  };'
p25826
aS'  template <int dim>'
p25827
aS'  class SineGordonProblem'
p25828
aS'  {'
p25829
aS'  public:'
p25830
aS'    SineGordonProblem();'
p25831
aS'    void run();'
p25832
aS'  private:'
p25833
aS'    ConditionalOStream pcout;'
p25834
aS'    void make_grid_and_dofs();'
p25835
aS'    void output_results(const unsigned int timestep_number);'
p25836
aS'#ifdef DEAL_II_WITH_P4EST'
p25837
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p25838
aS'#else'
p25839
aS'    Triangulation<dim> triangulation;'
p25840
aS'#endif'
p25841
aS'    FE_Q<dim>       fe;'
p25842
aS'    DoFHandler<dim> dof_handler;'
p25843
aS'    MappingQ1<dim> mapping;'
p25844
aS'    AffineConstraints<double> constraints;'
p25845
aS'    IndexSet                  locally_relevant_dofs;'
p25846
aS'    MatrixFree<dim, double> matrix_free_data;'
p25847
aS'    LinearAlgebra::distributed::Vector<double> solution, old_solution,'
p25848
aS'      old_old_solution;'
p25849
aS'    const unsigned int n_global_refinements;'
p25850
aS'    double             time, time_step;'
p25851
aS'    const double       final_time;'
p25852
aS'    const double       cfl_number;'
p25853
aS'    const unsigned int output_timestep_skip;'
p25854
aS'  };'
p25855
aS'  template <int dim>'
p25856
aS'  SineGordonProblem<dim>::SineGordonProblem()'
p25857
aS'    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p25858
aS'    ,'
p25859
aS'#ifdef DEAL_II_WITH_P4EST'
p25860
aS'    triangulation(MPI_COMM_WORLD)'
p25861
aS'    ,'
p25862
aS'#endif'
p25863
aS'    fe(QGaussLobatto<1>(fe_degree + 1))'
p25864
aS'    , dof_handler(triangulation)'
p25865
aS'    , n_global_refinements(10 - 2 * dim)'
p25866
aS'    , time(-10)'
p25867
aS'    , time_step(10.)'
p25868
aS'    , final_time(10.)'
p25869
aS'    , cfl_number(.1 / fe_degree)'
p25870
aS'    , output_timestep_skip(200)'
p25871
aS'  {}'
p25872
aS'  template <int dim>'
p25873
aS'  void SineGordonProblem<dim>::make_grid_and_dofs()'
p25874
aS'  {'
p25875
aS'    GridGenerator::hyper_cube(triangulation, -15, 15);'
p25876
aS'    triangulation.refine_global(n_global_refinements);'
p25877
aS'    {'
p25878
aS'      typename Triangulation<dim>::active_cell_iterator'
p25879
aS'        cell     = triangulation.begin_active(),'
p25880
aS'        end_cell = triangulation.end();'
p25881
aS'      for (; cell != end_cell; ++cell)'
p25882
aS'        if (cell->is_locally_owned())'
p25883
aS'          if (cell->center().norm() < 11)'
p25884
aS'            cell->set_refine_flag();'
p25885
aS'      triangulation.execute_coarsening_and_refinement();'
p25886
aS'      cell     = triangulation.begin_active();'
p25887
aS'      end_cell = triangulation.end();'
p25888
aS'      for (; cell != end_cell; ++cell)'
p25889
aS'        if (cell->is_locally_owned())'
p25890
aS'          if (cell->center().norm() < 6)'
p25891
aS'            cell->set_refine_flag();'
p25892
aS'      triangulation.execute_coarsening_and_refinement();'
p25893
aS'    }'
p25894
aS'    pcout << "   Number of global active cells: "'
p25895
aS'#ifdef DEAL_II_WITH_P4EST'
p25896
aS'          << triangulation.n_global_active_cells()'
p25897
aS'#else'
p25898
aS'          << triangulation.n_active_cells()'
p25899
aS'#endif'
p25900
aS'          << std::endl;'
p25901
aS'    dof_handler.distribute_dofs(fe);'
p25902
aS'    pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p25903
aS'          << std::endl;'
p25904
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p25905
aS'    constraints.clear();'
p25906
aS'    constraints.reinit(locally_relevant_dofs);'
p25907
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p25908
aS'    constraints.close();'
p25909
aS'    typename MatrixFree<dim>::AdditionalData additional_data;'
p25910
aS'    additional_data.tasks_parallel_scheme ='
p25911
aS'      MatrixFree<dim>::AdditionalData::TasksParallelScheme::partition_partition;'
p25912
aS'    matrix_free_data.reinit(mapping,'
p25913
aS'                            dof_handler,'
p25914
aS'                            constraints,'
p25915
aS'                            QGaussLobatto<1>(fe_degree + 1),'
p25916
aS'                            additional_data);'
p25917
aS'    matrix_free_data.initialize_dof_vector(solution);'
p25918
aS'    old_solution.reinit(solution);'
p25919
aS'    old_old_solution.reinit(solution);'
p25920
aS'  }'
p25921
aS'  template <int dim>'
p25922
aS'  void'
p25923
aS'  SineGordonProblem<dim>::output_results(const unsigned int timestep_number)'
p25924
aS'  {'
p25925
aS'    constraints.distribute(solution);'
p25926
aS'    Vector<float> norm_per_cell(triangulation.n_active_cells());'
p25927
aS'    solution.update_ghost_values();'
p25928
aS'    VectorTools::integrate_difference(mapping,'
p25929
aS'                                      dof_handler,'
p25930
aS'                                      solution,'
p25931
aS'                                      Functions::ZeroFunction<dim>(),'
p25932
aS'                                      norm_per_cell,'
p25933
aS'                                      QGauss<dim>(fe_degree + 1),'
p25934
aS'                                      VectorTools::L2_norm);'
p25935
aS'    const double solution_norm ='
p25936
aS'      VectorTools::compute_global_error(triangulation,'
p25937
aS'                                        norm_per_cell,'
p25938
aS'                                        VectorTools::L2_norm);'
p25939
aS'    pcout << "   Time:" << std::setw(8) << std::setprecision(3) << time'
p25940
aS'          << ", solution norm: " << std::setprecision(5) << std::setw(7)'
p25941
aS'          << solution_norm << std::endl;'
p25942
aS'    DataOut<dim> data_out;'
p25943
aS'    data_out.attach_dof_handler(dof_handler);'
p25944
aS'    data_out.add_data_vector(solution, "solution");'
p25945
aS'    data_out.build_patches(mapping);'
p25946
aS'    data_out.write_vtu_with_pvtu_record('
p25947
aS'      "./", "solution", timestep_number, MPI_COMM_WORLD, 3);'
p25948
aS'    solution.zero_out_ghost_values();'
p25949
aS'  }'
p25950
aS'  template <int dim>'
p25951
aS'  void SineGordonProblem<dim>::run()'
p25952
aS'  {'
p25953
aS'    {'
p25954
aS'      pcout << "Number of MPI ranks:            "'
p25955
aS'            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD) << std::endl;'
p25956
aS'      pcout << "Number of threads on each rank: "'
p25957
aS'            << MultithreadInfo::n_threads() << std::endl;'
p25958
aS'      const unsigned int n_vect_doubles = VectorizedArray<double>::size();'
p25959
aS'      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles;'
p25960
aS'      pcout << "Vectorization over " << n_vect_doubles'
p25961
aS'            << " doubles = " << n_vect_bits << " bits ("'
p25962
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p25963
aS'            << std::endl'
p25964
aS'            << std::endl;'
p25965
aS'    }'
p25966
aS'    make_grid_and_dofs();'
p25967
aS'    const double local_min_cell_diameter ='
p25968
aS'      triangulation.last()->diameter() / std::sqrt(dim);'
p25969
aS'    const double global_min_cell_diameter ='
p25970
aS'      -Utilities::MPI::max(-local_min_cell_diameter, MPI_COMM_WORLD);'
p25971
aS'    time_step = cfl_number * global_min_cell_diameter;'
p25972
aS'    time_step = (final_time - time) / (int((final_time - time) / time_step));'
p25973
aS'    pcout << "   Time step size: " << time_step'
p25974
aS'          << ", finest cell: " << global_min_cell_diameter << std::endl'
p25975
aS'          << std::endl;'
p25976
aS'    VectorTools::interpolate(mapping,'
p25977
aS'                             dof_handler,'
p25978
aS'                             InitialCondition<dim>(1, time),'
p25979
aS'                             solution);'
p25980
aS'    VectorTools::interpolate(mapping,'
p25981
aS'                             dof_handler,'
p25982
aS'                             InitialCondition<dim>(1, time - time_step),'
p25983
aS'                             old_solution);'
p25984
aS'    output_results(0);'
p25985
aS'    std::vector<LinearAlgebra::distributed::Vector<double> *>'
p25986
aS'      previous_solutions({&old_solution, &old_old_solution});'
p25987
aS'    SineGordonOperation<dim, fe_degree> sine_gordon_op(matrix_free_data,'
p25988
aS'                                                       time_step);'
p25989
aS'    unsigned int timestep_number = 1;'
p25990
aS'    Timer  timer;'
p25991
aS'    double wtime       = 0;'
p25992
aS'    double output_time = 0;'
p25993
aS'    for (time += time_step; time <= final_time;'
p25994
aS'         time += time_step, ++timestep_number)'
p25995
aS'      {'
p25996
aS'        timer.restart();'
p25997
aS'        old_old_solution.swap(old_solution);'
p25998
aS'        old_solution.swap(solution);'
p25999
aS'        sine_gordon_op.apply(solution, previous_solutions);'
p26000
aS'        wtime += timer.wall_time();'
p26001
aS'        timer.restart();'
p26002
aS'        if (timestep_number % output_timestep_skip == 0)'
p26003
aS'          output_results(timestep_number / output_timestep_skip);'
p26004
aS'        output_time += timer.wall_time();'
p26005
aS'      }'
p26006
aS'    timer.restart();'
p26007
aS'    output_results(timestep_number / output_timestep_skip + 1);'
p26008
aS'    output_time += timer.wall_time();'
p26009
aS'    pcout << std::endl'
p26010
aS'          << "   Performed " << timestep_number << " time steps." << std::endl;'
p26011
aS'    pcout << "   Average wallclock time per time step: "'
p26012
aS'          << wtime / timestep_number << "s" << std::endl;'
p26013
aS'    pcout << "   Spent " << output_time << "s on output and " << wtime'
p26014
aS'          << "s on computations." << std::endl;'
p26015
aS'  }'
p26016
aS'} // namespace Step48'
p26017
aS'int main(int argc, char **argv)'
p26018
ag9
aS'  using namespace Step48;'
p26019
aS'  using namespace dealii;'
p26020
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization('
p26021
aS'    argc, argv, numbers::invalid_unsigned_int);'
p26022
aS'  try'
p26023
aS'    {'
p26024
aS'      SineGordonProblem<dimension> sg_problem;'
p26025
aS'      sg_problem.run();'
p26026
aS'    }'
p26027
aS'  catch (std::exception &exc)'
p26028
aS'    {'
p26029
aS'      std::cerr << std::endl'
p26030
aS'                << std::endl'
p26031
aS'                << "----------------------------------------------------"'
p26032
aS'                << std::endl;'
p26033
aS'      std::cerr << "Exception on processing: " << std::endl'
p26034
aS'                << exc.what() << std::endl'
p26035
aS'                << "Aborting!" << std::endl'
p26036
aS'                << "----------------------------------------------------"'
p26037
aS'                << std::endl;'
p26038
aS'      return 1;'
p26039
aS'    }'
p26040
aS'  catch (...)'
p26041
aS'    {'
p26042
aS'      std::cerr << std::endl'
p26043
aS'                << std::endl'
p26044
aS'                << "----------------------------------------------------"'
p26045
aS'                << std::endl;'
p26046
aS'      std::cerr << "Unknown exception!" << std::endl'
p26047
aS'                << "Aborting!" << std::endl'
p26048
aS'                << "----------------------------------------------------"'
p26049
aS'                << std::endl;'
p26050
aS'      return 1;'
p26051
aS'    }'
p26052
aS'  return 0;'
p26053
ag17
aS'#include <deal.II/grid/tria.h>'
p26054
aS'#include <deal.II/grid/grid_generator.h>'
p26055
aS'#include <deal.II/grid/grid_tools.h>'
p26056
aS'#include <deal.II/grid/manifold_lib.h>'
p26057
aS'#include <deal.II/grid/grid_out.h>'
p26058
aS'#include <deal.II/grid/grid_in.h>'
p26059
aS'#include <iostream>'
p26060
aS'#include <fstream>'
p26061
aS'#include <map>'
p26062
aS'using namespace dealii;'
p26063
aS'template <int dim>'
p26064
aS'void print_mesh_info(const Triangulation<dim> &triangulation,'
p26065
aS'                     const std::string &       filename)'
p26066
ag9
aS'  std::cout << "Mesh info:" << std::endl'
p26067
aS'            << " dimension: " << dim << std::endl'
p26068
aS'            << " no. of cells: " << triangulation.n_active_cells() << std::endl;'
p26069
aS'  {'
p26070
aS'    std::map<types::boundary_id, unsigned int> boundary_count;'
p26071
aS'    for (const auto &face : triangulation.active_face_iterators())'
p26072
aS'      if (face->at_boundary())'
p26073
aS'        boundary_count[face->boundary_id()]++;'
p26074
aS'    std::cout << " boundary indicators: ";'
p26075
aS'    for (const std::pair<const types::boundary_id, unsigned int> &pair :'
p26076
aS'         boundary_count)'
p26077
aS'      {'
p26078
aS'        std::cout << pair.first << "(" << pair.second << " times) ";'
p26079
aS'      }'
p26080
aS'    std::cout << std::endl;'
p26081
aS'  }'
p26082
aS'  std::ofstream out(filename);'
p26083
aS'  GridOut       grid_out;'
p26084
aS'  grid_out.write_vtu(triangulation, out);'
p26085
aS'  std::cout << " written to " << filename << std::endl << std::endl;'
p26086
ag17
aS'void grid_1()'
p26087
ag9
aS'  Triangulation<2> triangulation;'
p26088
aS'  GridIn<2> gridin;'
p26089
aS'  gridin.attach_triangulation(triangulation);'
p26090
aS'  std::ifstream f("example.msh");'
p26091
aS'  gridin.read_msh(f);'
p26092
aS'  print_mesh_info(triangulation, "grid-1.vtu");'
p26093
ag17
aS'void grid_2()'
p26094
ag9
aS'  Triangulation<2> tria1;'
p26095
aS'  GridGenerator::hyper_cube_with_cylindrical_hole(tria1, 0.25, 1.0);'
p26096
aS'  Triangulation<2>          tria2;'
p26097
aS'  std::vector<unsigned int> repetitions(2);'
p26098
aS'  repetitions[0] = 3;'
p26099
aS'  repetitions[1] = 2;'
p26100
aS'  GridGenerator::subdivided_hyper_rectangle(tria2,'
p26101
aS'                                            repetitions,'
p26102
aS'                                            Point<2>(1.0, -1.0),'
p26103
aS'                                            Point<2>(4.0, 1.0));'
p26104
aS'  Triangulation<2> triangulation;'
p26105
aS'  GridGenerator::merge_triangulations(tria1, tria2, triangulation);'
p26106
aS'  print_mesh_info(triangulation, "grid-2.vtu");'
p26107
ag17
aS'void grid_3()'
p26108
ag9
aS'  Triangulation<2> triangulation;'
p26109
aS'  GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 0.25, 1.0);'
p26110
aS'  for (const auto &cell : triangulation.active_cell_iterators())'
p26111
aS'    {'
p26112
aS'      for (const auto i : cell->vertex_indices())'
p26113
aS'        {'
p26114
aS'          Point<2> &v = cell->vertex(i);'
p26115
aS'          if (std::abs(v(1) - 1.0) < 1e-5)'
p26116
aS'            v(1) += 0.5;'
p26117
aS'        }'
p26118
aS'    }'
p26119
aS'  triangulation.refine_global(2);'
p26120
aS'  print_mesh_info(triangulation, "grid-3.vtu");'
p26121
ag17
aS'void grid_4()'
p26122
ag9
aS'  Triangulation<2> triangulation;'
p26123
aS'  Triangulation<3> out;'
p26124
aS'  GridGenerator::hyper_cube_with_cylindrical_hole(triangulation, 0.25, 1.0);'
p26125
aS'  GridGenerator::extrude_triangulation(triangulation, 3, 2.0, out);'
p26126
aS'  print_mesh_info(out, "grid-4.vtu");'
p26127
ag17
aS'void grid_5()'
p26128
ag9
aS'  Triangulation<2>          triangulation;'
p26129
aS'  std::vector<unsigned int> repetitions(2);'
p26130
aS'  repetitions[0] = 14;'
p26131
aS'  repetitions[1] = 2;'
p26132
aS'  GridGenerator::subdivided_hyper_rectangle(triangulation,'
p26133
aS'                                            repetitions,'
p26134
aS'                                            Point<2>(0.0, 0.0),'
p26135
aS'                                            Point<2>(10.0, 1.0));'
p26136
aS'  GridTools::transform('
p26137
aS'    [](const Point<2> &in) {'
p26138
aS'      return Point<2>(in[0], in[1] + std::sin(numbers::PI * in[0] / 5.0));'
p26139
aS'    },'
p26140
aS'    triangulation);'
p26141
aS'  print_mesh_info(triangulation, "grid-5.vtu");'
p26142
ag17
aS'struct Grid6Func'
p26143
ag9
aS'  double trans(const double y) const'
p26144
aS'  {'
p26145
aS'    return std::tanh(2 * y) / tanh(2);'
p26146
aS'  }'
p26147
aS'  Point<2> operator()(const Point<2> &in) const'
p26148
aS'  {'
p26149
aS'    return {in(0), trans(in(1))};'
p26150
aS'  }'
p26151
aS'};'
p26152
aS'void grid_6()'
p26153
ag9
aS'  Triangulation<2>          triangulation;'
p26154
aS'  std::vector<unsigned int> repetitions(2);'
p26155
aS'  repetitions[0] = repetitions[1] = 40;'
p26156
aS'  GridGenerator::subdivided_hyper_rectangle(triangulation,'
p26157
aS'                                            repetitions,'
p26158
aS'                                            Point<2>(0.0, 0.0),'
p26159
aS'                                            Point<2>(1.0, 1.0));'
p26160
aS'  GridTools::transform(Grid6Func(), triangulation);'
p26161
aS'  print_mesh_info(triangulation, "grid-6.vtu");'
p26162
ag17
aS'void grid_7()'
p26163
ag9
aS'  Triangulation<2>          triangulation;'
p26164
aS'  std::vector<unsigned int> repetitions(2);'
p26165
aS'  repetitions[0] = repetitions[1] = 16;'
p26166
aS'  GridGenerator::subdivided_hyper_rectangle(triangulation,'
p26167
aS'                                            repetitions,'
p26168
aS'                                            Point<2>(0.0, 0.0),'
p26169
aS'                                            Point<2>(1.0, 1.0));'
p26170
aS'  GridTools::distort_random(0.3, triangulation, true);'
p26171
aS'  print_mesh_info(triangulation, "grid-7.vtu");'
p26172
ag17
aS'int main()'
p26173
ag9
aS'  try'
p26174
aS'    {'
p26175
aS'      grid_1();'
p26176
aS'      grid_2();'
p26177
aS'      grid_3();'
p26178
aS'      grid_4();'
p26179
aS'      grid_5();'
p26180
aS'      grid_6();'
p26181
aS'      grid_7();'
p26182
aS'    }'
p26183
aS'  catch (std::exception &exc)'
p26184
aS'    {'
p26185
aS'      std::cerr << std::endl'
p26186
aS'                << std::endl'
p26187
aS'                << "----------------------------------------------------"'
p26188
aS'                << std::endl;'
p26189
aS'      std::cerr << "Exception on processing: " << std::endl'
p26190
aS'                << exc.what() << std::endl'
p26191
aS'                << "Aborting!" << std::endl'
p26192
aS'                << "----------------------------------------------------"'
p26193
aS'                << std::endl;'
p26194
aS'      return 1;'
p26195
aS'    }'
p26196
aS'  catch (...)'
p26197
aS'    {'
p26198
aS'      std::cerr << std::endl'
p26199
aS'                << std::endl'
p26200
aS'                << "----------------------------------------------------"'
p26201
aS'                << std::endl;'
p26202
aS'      std::cerr << "Unknown exception!" << std::endl'
p26203
aS'                << "Aborting!" << std::endl'
p26204
aS'                << "----------------------------------------------------"'
p26205
aS'                << std::endl;'
p26206
aS'      return 1;'
p26207
aS'    }'
p26208
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p26209
aS'#include <deal.II/base/function.h>'
p26210
aS'#include <deal.II/base/logstream.h>'
p26211
aS'#include <deal.II/lac/vector.h>'
p26212
aS'#include <deal.II/lac/full_matrix.h>'
p26213
aS'#include <deal.II/lac/sparse_matrix.h>'
p26214
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p26215
aS'#include <deal.II/lac/solver_cg.h>'
p26216
aS'#include <deal.II/lac/precondition.h>'
p26217
aS'#include <deal.II/grid/tria.h>'
p26218
aS'#include <deal.II/dofs/dof_handler.h>'
p26219
aS'#include <deal.II/dofs/dof_tools.h>'
p26220
aS'#include <deal.II/fe/fe_q.h>'
p26221
aS'#include <deal.II/fe/fe_values.h>'
p26222
aS'#include <deal.II/numerics/vector_tools.h>'
p26223
aS'#include <deal.II/numerics/matrix_tools.h>'
p26224
aS'#include <deal.II/numerics/data_out.h>'
p26225
aS'#include <deal.II/grid/grid_in.h>'
p26226
aS'#include <deal.II/grid/manifold_lib.h>'
p26227
aS'#include <fstream>'
p26228
aS'#include <iostream>'
p26229
aS'using namespace dealii;'
p26230
aS'template <int dim>'
p26231
aS'class Step5'
p26232
ag9
aS'public:'
p26233
aS'  Step5();'
p26234
aS'  void run();'
p26235
aS'private:'
p26236
aS'  void setup_system();'
p26237
aS'  void assemble_system();'
p26238
aS'  void solve();'
p26239
aS'  void output_results(const unsigned int cycle) const;'
p26240
aS'  Triangulation<dim> triangulation;'
p26241
aS'  FE_Q<dim>          fe;'
p26242
aS'  DoFHandler<dim>    dof_handler;'
p26243
aS'  SparsityPattern      sparsity_pattern;'
p26244
aS'  SparseMatrix<double> system_matrix;'
p26245
aS'  Vector<double> solution;'
p26246
aS'  Vector<double> system_rhs;'
p26247
aS'};'
p26248
aS'template <int dim>'
p26249
aS'double coefficient(const Point<dim> &p)'
p26250
ag9
aS'  if (p.square() < 0.5 * 0.5)'
p26251
aS'    return 20;'
p26252
aS'  else'
p26253
aS'    return 1;'
p26254
ag17
aS'template <int dim>'
p26255
aS'Step5<dim>::Step5()'
p26256
aS'  : fe(1)'
p26257
aS'  , dof_handler(triangulation)'
p26258
aS'{}'
p26259
aS'template <int dim>'
p26260
aS'void Step5<dim>::setup_system()'
p26261
ag9
aS'  dof_handler.distribute_dofs(fe);'
p26262
aS'  std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p26263
aS'            << std::endl;'
p26264
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p26265
aS'  DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p26266
aS'  sparsity_pattern.copy_from(dsp);'
p26267
aS'  system_matrix.reinit(sparsity_pattern);'
p26268
aS'  solution.reinit(dof_handler.n_dofs());'
p26269
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p26270
ag17
aS'template <int dim>'
p26271
aS'void Step5<dim>::assemble_system()'
p26272
ag9
aS'  QGauss<dim> quadrature_formula(fe.degree + 1);'
p26273
aS'  FEValues<dim> fe_values(fe,'
p26274
aS'                          quadrature_formula,'
p26275
aS'                          update_values | update_gradients |'
p26276
aS'                            update_quadrature_points | update_JxW_values);'
p26277
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p26278
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p26279
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p26280
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p26281
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p26282
aS'    {'
p26283
aS'      cell_matrix = 0.;'
p26284
aS'      cell_rhs    = 0.;'
p26285
aS'      fe_values.reinit(cell);'
p26286
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p26287
aS'        {'
p26288
aS'          const double current_coefficient ='
p26289
aS'            coefficient(fe_values.quadrature_point(q_index));'
p26290
aS'          for (const unsigned int i : fe_values.dof_indices())'
p26291
aS'            {'
p26292
aS'              for (const unsigned int j : fe_values.dof_indices())'
p26293
aS'                cell_matrix(i, j) +='
p26294
aS'                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p26295
aS'                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p26296
aS'                   fe_values.JxW(q_index));           // dx'
p26297
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p26298
aS'                              1.0 *                               // f(x_q)'
p26299
aS'                              fe_values.JxW(q_index));            // dx'
p26300
aS'            }'
p26301
aS'        }'
p26302
aS'      cell->get_dof_indices(local_dof_indices);'
p26303
aS'      for (const unsigned int i : fe_values.dof_indices())'
p26304
aS'        {'
p26305
aS'          for (const unsigned int j : fe_values.dof_indices())'
p26306
aS'            system_matrix.add(local_dof_indices[i],'
p26307
aS'                              local_dof_indices[j],'
p26308
aS'                              cell_matrix(i, j));'
p26309
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p26310
aS'        }'
p26311
aS'    }'
p26312
aS'  std::map<types::global_dof_index, double> boundary_values;'
p26313
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p26314
aS'                                           0,'
p26315
aS'                                           Functions::ZeroFunction<dim>(),'
p26316
aS'                                           boundary_values);'
p26317
aS'  MatrixTools::apply_boundary_values(boundary_values,'
p26318
aS'                                     system_matrix,'
p26319
aS'                                     solution,'
p26320
aS'                                     system_rhs);'
p26321
ag17
aS'template <int dim>'
p26322
aS'void Step5<dim>::solve()'
p26323
ag9
aS'  SolverControl            solver_control(1000, 1e-12);'
p26324
aS'  SolverCG<Vector<double>> solver(solver_control);'
p26325
aS'  PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p26326
aS'  preconditioner.initialize(system_matrix, 1.2);'
p26327
aS'  solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p26328
aS'  std::cout << "   " << solver_control.last_step()'
p26329
aS'            << " CG iterations needed to obtain convergence." << std::endl;'
p26330
ag17
aS'template <int dim>'
p26331
aS'void Step5<dim>::output_results(const unsigned int cycle) const'
p26332
ag9
aS'  DataOut<dim> data_out;'
p26333
aS'  data_out.attach_dof_handler(dof_handler);'
p26334
aS'  data_out.add_data_vector(solution, "solution");'
p26335
aS'  data_out.build_patches();'
p26336
aS'  std::ofstream output("solution-" + std::to_string(cycle) + ".vtu");'
p26337
aS'  data_out.write_vtu(output);'
p26338
ag17
aS'template <int dim>'
p26339
aS'void Step5<dim>::run()'
p26340
ag9
aS'  GridIn<dim> grid_in;'
p26341
aS'  grid_in.attach_triangulation(triangulation);'
p26342
aS'  std::ifstream input_file("circle-grid.inp");'
p26343
aS'  Assert(dim == 2, ExcInternalError());'
p26344
aS'  grid_in.read_ucd(input_file);'
p26345
aS'  const SphericalManifold<dim> boundary;'
p26346
aS'  triangulation.set_all_manifold_ids_on_boundary(0);'
p26347
aS'  triangulation.set_manifold(0, boundary);'
p26348
aS'  for (unsigned int cycle = 0; cycle < 6; ++cycle)'
p26349
aS'    {'
p26350
aS'      std::cout << "Cycle " << cycle << \':\' << std::endl;'
p26351
aS'      if (cycle != 0)'
p26352
aS'        triangulation.refine_global(1);'
p26353
aS'      std::cout << "   Number of active cells: "  //'
p26354
aS'                << triangulation.n_active_cells() //'
p26355
aS'                << std::endl                      //'
p26356
aS'                << "   Total number of cells: "   //'
p26357
aS'                << triangulation.n_cells()        //'
p26358
aS'                << std::endl;'
p26359
aS'      setup_system();'
p26360
aS'      assemble_system();'
p26361
aS'      solve();'
p26362
aS'      output_results(cycle);'
p26363
aS'    }'
p26364
ag17
aS'int main()'
p26365
ag9
aS'  Step5<2> laplace_problem_2d;'
p26366
aS'  laplace_problem_2d.run();'
p26367
aS'  return 0;'
p26368
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p26369
aS'#include <deal.II/base/data_out_base.h>'
p26370
aS'#include <deal.II/base/index_set.h>'
p26371
aS'#include <deal.II/base/logstream.h>'
p26372
aS'#include <deal.II/base/quadrature_lib.h>'
p26373
aS'#include <deal.II/base/timer.h>'
p26374
aS'#include <deal.II/base/parameter_handler.h>'
p26375
aS'#include <deal.II/distributed/grid_refinement.h>'
p26376
aS'#include <deal.II/distributed/tria.h>'
p26377
aS'#include <deal.II/dofs/dof_tools.h>'
p26378
aS'#include <deal.II/fe/fe_q.h>'
p26379
aS'#include <deal.II/fe/fe_values.h>'
p26380
aS'#include <deal.II/grid/grid_generator.h>'
p26381
aS'#include <deal.II/grid/grid_refinement.h>'
p26382
aS'#include <deal.II/grid/tria.h>'
p26383
aS'#include <deal.II/lac/affine_constraints.h>'
p26384
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p26385
aS'#include <deal.II/lac/solver_cg.h>'
p26386
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p26387
aS'#define FORCE_USE_OF_TRILINOS'
p26388
aS'namespace LA'
p26389
ag9
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p26390
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p26391
aS'  using namespace dealii::LinearAlgebraPETSc;'
p26392
aS'#  define USE_PETSC_LA'
p26393
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p26394
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p26395
aS'#else'
p26396
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p26397
aS'#endif'
p26398
aS'} // namespace LA'
p26399
aS'#include <deal.II/matrix_free/matrix_free.h>'
p26400
aS'#include <deal.II/matrix_free/operators.h>'
p26401
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p26402
aS'#include <deal.II/multigrid/mg_coarse.h>'
p26403
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p26404
aS'#include <deal.II/multigrid/mg_matrix.h>'
p26405
aS'#include <deal.II/multigrid/mg_smoother.h>'
p26406
aS'#include <deal.II/multigrid/mg_tools.h>'
p26407
aS'#include <deal.II/multigrid/mg_transfer.h>'
p26408
aS'#include <deal.II/multigrid/multigrid.h>'
p26409
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p26410
aS'#include <deal.II/numerics/data_out.h>'
p26411
aS'#include <deal.II/numerics/vector_tools.h>'
p26412
aS'#include <deal.II/fe/fe_interface_values.h>'
p26413
aS'#include <deal.II/meshworker/mesh_loop.h>'
p26414
aS'using namespace dealii;'
p26415
aS'namespace ChangeVectorTypes'
p26416
ag9
aS'  template <typename number>'
p26417
aS'  void copy(LA::MPI::Vector &                                         out,'
p26418
aS'            const dealii::LinearAlgebra::distributed::Vector<number> &in)'
p26419
aS'  {'
p26420
aS'    dealii::LinearAlgebra::ReadWriteVector<double> rwv('
p26421
aS'      out.locally_owned_elements());'
p26422
aS'    rwv.import(in, VectorOperation::insert);'
p26423
aS'#ifdef USE_PETSC_LA'
p26424
aS'    AssertThrow(false,'
p26425
aS'                ExcMessage("CopyVectorTypes::copy() not implemented for "'
p26426
aS'                           "PETSc vector types."));'
p26427
aS'#else'
p26428
aS'    out.import(rwv, VectorOperation::insert);'
p26429
aS'#endif'
p26430
aS'  }'
p26431
aS'  template <typename number>'
p26432
aS'  void copy(dealii::LinearAlgebra::distributed::Vector<number> &out,'
p26433
aS'            const LA::MPI::Vector &                             in)'
p26434
aS'  {'
p26435
aS'    dealii::LinearAlgebra::ReadWriteVector<double> rwv;'
p26436
aS'#ifdef USE_PETSC_LA'
p26437
aS'    AssertThrow(false,'
p26438
aS'                ExcMessage("CopyVectorTypes::copy() not implemented for "'
p26439
aS'                           "PETSc vector types."));'
p26440
aS'#else'
p26441
aS'    rwv.reinit(in);'
p26442
aS'#endif'
p26443
aS'    out.import(rwv, VectorOperation::insert);'
p26444
aS'  }'
p26445
aS'} // namespace ChangeVectorTypes'
p26446
aS'template <int dim>'
p26447
aS'class RightHandSide : public Function<dim>'
p26448
ag9
aS'public:'
p26449
aS'  virtual double value(const Point<dim> & /*p*/,'
p26450
aS'                       const unsigned int /*component*/ = 0) const override'
p26451
aS'  {'
p26452
aS'    return 1.0;'
p26453
aS'  }'
p26454
aS'  template <typename number>'
p26455
aS'  VectorizedArray<number>'
p26456
aS'  value(const Point<dim, VectorizedArray<number>> & /*p*/,'
p26457
aS'        const unsigned int /*component*/ = 0) const'
p26458
aS'  {'
p26459
aS'    return VectorizedArray<number>(1.0);'
p26460
aS'  }'
p26461
aS'};'
p26462
aS'template <int dim>'
p26463
aS'class Coefficient : public Function<dim>'
p26464
ag9
aS'public:'
p26465
aS'  virtual double value(const Point<dim> &p,'
p26466
aS'                       const unsigned int /*component*/ = 0) const override;'
p26467
aS'  template <typename number>'
p26468
aS'  VectorizedArray<number> value(const Point<dim, VectorizedArray<number>> &p,'
p26469
aS'                                const unsigned int /*component*/ = 0) const;'
p26470
aS'  template <typename number>'
p26471
aS'  number average_value(const std::vector<Point<dim, number>> &points) const;'
p26472
aS'  template <typename number>'
p26473
aS'  std::shared_ptr<Table<2, VectorizedArray<number>>> make_coefficient_table('
p26474
aS'    const MatrixFree<dim, number, VectorizedArray<number>> &mf_storage) const;'
p26475
aS'};'
p26476
aS'template <int dim>'
p26477
aS'double Coefficient<dim>::value(const Point<dim> &p, const unsigned int) const'
p26478
ag9
aS'  for (int d = 0; d < dim; ++d)'
p26479
aS'    {'
p26480
aS'      if (p[d] < -0.5)'
p26481
aS'        return 100.0;'
p26482
aS'    }'
p26483
aS'  return 1.0;'
p26484
ag17
aS'template <int dim>'
p26485
aS'template <typename number>'
p26486
aS'VectorizedArray<number>'
p26487
aS'Coefficient<dim>::value(const Point<dim, VectorizedArray<number>> &p,'
p26488
aS'                        const unsigned int) const'
p26489
ag9
aS'  VectorizedArray<number> return_value = VectorizedArray<number>(1.0);'
p26490
aS'  for (unsigned int i = 0; i < VectorizedArray<number>::size(); ++i)'
p26491
aS'    {'
p26492
aS'      for (int d = 0; d < dim; ++d)'
p26493
aS'        if (p[d][i] < -0.5)'
p26494
aS'          {'
p26495
aS'            return_value[i] = 100.0;'
p26496
aS'            break;'
p26497
aS'          }'
p26498
aS'    }'
p26499
aS'  return return_value;'
p26500
ag17
aS'template <int dim>'
p26501
aS'template <typename number>'
p26502
aS'number Coefficient<dim>::average_value('
p26503
aS'  const std::vector<Point<dim, number>> &points) const'
p26504
ag9
aS'  number average(0);'
p26505
aS'  for (unsigned int i = 0; i < points.size(); ++i)'
p26506
aS'    average += value(points[i]);'
p26507
aS'  average /= points.size();'
p26508
aS'  return average;'
p26509
ag17
aS'template <int dim>'
p26510
aS'template <typename number>'
p26511
aS'std::shared_ptr<Table<2, VectorizedArray<number>>>'
p26512
aS'Coefficient<dim>::make_coefficient_table('
p26513
aS'  const MatrixFree<dim, number, VectorizedArray<number>> &mf_storage) const'
p26514
ag9
aS'  auto coefficient_table ='
p26515
aS'    std::make_shared<Table<2, VectorizedArray<number>>>();'
p26516
aS'  FEEvaluation<dim, -1, 0, 1, number> fe_eval(mf_storage);'
p26517
aS'  const unsigned int n_cells    = mf_storage.n_cell_batches();'
p26518
aS'  const unsigned int n_q_points = fe_eval.n_q_points;'
p26519
aS'  coefficient_table->reinit(n_cells, 1);'
p26520
aS'  for (unsigned int cell = 0; cell < n_cells; ++cell)'
p26521
aS'    {'
p26522
aS'      fe_eval.reinit(cell);'
p26523
aS'      VectorizedArray<number> average_value = 0.;'
p26524
aS'      for (unsigned int q = 0; q < n_q_points; ++q)'
p26525
aS'        average_value += value(fe_eval.quadrature_point(q));'
p26526
aS'      average_value /= n_q_points;'
p26527
aS'    }'
p26528
aS'  return coefficient_table;'
p26529
ag17
aS'struct Settings'
p26530
ag9
aS'  bool try_parse(const std::string &prm_filename);'
p26531
aS'  enum SolverType'
p26532
aS'  {'
p26533
aS'    gmg_mb,'
p26534
aS'    gmg_mf,'
p26535
aS'    amg'
p26536
aS'  };'
p26537
aS'  SolverType solver;'
p26538
aS'  int          dimension;'
p26539
aS'  double       smoother_dampen;'
p26540
aS'  unsigned int smoother_steps;'
p26541
aS'  unsigned int n_steps;'
p26542
aS'  bool         output;'
p26543
aS'};'
p26544
aS'bool Settings::try_parse(const std::string &prm_filename)'
p26545
ag9
aS'  ParameterHandler prm;'
p26546
aS'  prm.declare_entry("dim", "2", Patterns::Integer(), "The problem dimension.");'
p26547
aS'  prm.declare_entry("n_steps",'
p26548
aS'                    "10",'
p26549
aS'                    Patterns::Integer(0),'
p26550
aS'                    "Number of adaptive refinement steps.");'
p26551
aS'  prm.declare_entry("smoother dampen",'
p26552
aS'                    "1.0",'
p26553
aS'                    Patterns::Double(0.0),'
p26554
aS'                    "Dampen factor for the smoother.");'
p26555
aS'  prm.declare_entry("smoother steps",'
p26556
aS'                    "1",'
p26557
aS'                    Patterns::Integer(1),'
p26558
aS'                    "Number of smoother steps.");'
p26559
aS'  prm.declare_entry("solver",'
p26560
aS'                    "MF",'
p26561
aS'                    Patterns::Selection("MF|MB|AMG"),'
p26562
aS'                    "Switch between matrix-free GMG, "'
p26563
aS'                    "matrix-based GMG, and AMG.");'
p26564
aS'  prm.declare_entry("output",'
p26565
aS'                    "false",'
p26566
aS'                    Patterns::Bool(),'
p26567
aS'                    "Output graphical results.");'
p26568
aS'  if (prm_filename.size() == 0)'
p26569
aS'    {'
p26570
aS'      std::cout << "****  Error: No input file provided!\\n"'
p26571
aS'                << "****  Error: Call this program as \'./step-50 input.prm\\n"'
p26572
aS'                << "\\n"'
p26573
aS'                << "****  You may want to use one of the input files in this\\n"'
p26574
aS'                << "****  directory, or use the following default values\\n"'
p26575
aS'                << "****  to create an input file:\\n";'
p26576
aS'      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p26577
aS'        prm.print_parameters(std::cout, ParameterHandler::Text);'
p26578
aS'      return false;'
p26579
aS'    }'
p26580
aS'  try'
p26581
aS'    {'
p26582
aS'      prm.parse_input(prm_filename);'
p26583
aS'    }'
p26584
aS'  catch (std::exception &e)'
p26585
aS'    {'
p26586
aS'      if (Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p26587
aS'        std::cerr << e.what() << std::endl;'
p26588
aS'      return false;'
p26589
aS'    }'
p26590
aS'  if (prm.get("solver") == "MF")'
p26591
aS'    this->solver = gmg_mf;'
p26592
aS'  else if (prm.get("solver") == "MB")'
p26593
aS'    this->solver = gmg_mb;'
p26594
aS'  else if (prm.get("solver") == "AMG")'
p26595
aS'    this->solver = amg;'
p26596
aS'  else'
p26597
aS'    AssertThrow(false, ExcNotImplemented());'
p26598
aS'  this->dimension       = prm.get_integer("dim");'
p26599
aS'  this->n_steps         = prm.get_integer("n_steps");'
p26600
aS'  this->smoother_dampen = prm.get_double("smoother dampen");'
p26601
aS'  this->smoother_steps  = prm.get_integer("smoother steps");'
p26602
aS'  this->output          = prm.get_bool("output");'
p26603
aS'  return true;'
p26604
ag17
aS'template <int dim, int degree>'
p26605
aS'class LaplaceProblem'
p26606
ag9
aS'public:'
p26607
aS'  LaplaceProblem(const Settings &settings);'
p26608
aS'  void run();'
p26609
aS'private:'
p26610
aS'  using MatrixType         = LA::MPI::SparseMatrix;'
p26611
aS'  using VectorType         = LA::MPI::Vector;'
p26612
aS'  using PreconditionAMG    = LA::MPI::PreconditionAMG;'
p26613
aS'  using PreconditionJacobi = LA::MPI::PreconditionJacobi;'
p26614
aS'  using MatrixFreeLevelMatrix = MatrixFreeOperators::LaplaceOperator<'
p26615
aS'    dim,'
p26616
aS'    degree,'
p26617
aS'    degree + 1,'
p26618
aS'    1,'
p26619
aS'    LinearAlgebra::distributed::Vector<float>>;'
p26620
aS'  using MatrixFreeActiveMatrix = MatrixFreeOperators::LaplaceOperator<'
p26621
aS'    dim,'
p26622
aS'    degree,'
p26623
aS'    degree + 1,'
p26624
aS'    1,'
p26625
aS'    LinearAlgebra::distributed::Vector<double>>;'
p26626
aS'  using MatrixFreeLevelVector  = LinearAlgebra::distributed::Vector<float>;'
p26627
aS'  using MatrixFreeActiveVector = LinearAlgebra::distributed::Vector<double>;'
p26628
aS'  void setup_system();'
p26629
aS'  void setup_multigrid();'
p26630
aS'  void assemble_system();'
p26631
aS'  void assemble_multigrid();'
p26632
aS'  void assemble_rhs();'
p26633
aS'  void solve();'
p26634
aS'  void estimate();'
p26635
aS'  void refine_grid();'
p26636
aS'  void output_results(const unsigned int cycle);'
p26637
aS'  Settings settings;'
p26638
aS'  MPI_Comm           mpi_communicator;'
p26639
aS'  ConditionalOStream pcout;'
p26640
aS'  parallel::distributed::Triangulation<dim> triangulation;'
p26641
aS'  const MappingQ1<dim>                      mapping;'
p26642
aS'  FE_Q<dim>                                 fe;'
p26643
aS'  DoFHandler<dim> dof_handler;'
p26644
aS'  IndexSet                  locally_owned_dofs;'
p26645
aS'  IndexSet                  locally_relevant_dofs;'
p26646
aS'  AffineConstraints<double> constraints;'
p26647
aS'  MatrixType             system_matrix;'
p26648
aS'  MatrixFreeActiveMatrix mf_system_matrix;'
p26649
aS'  VectorType             solution;'
p26650
aS'  VectorType             right_hand_side;'
p26651
aS'  Vector<double>         estimated_error_square_per_cell;'
p26652
aS'  MGLevelObject<MatrixType> mg_matrix;'
p26653
aS'  MGLevelObject<MatrixType> mg_interface_in;'
p26654
aS'  MGConstrainedDoFs         mg_constrained_dofs;'
p26655
aS'  MGLevelObject<MatrixFreeLevelMatrix> mf_mg_matrix;'
p26656
aS'  TimerOutput computing_timer;'
p26657
aS'};'
p26658
aS'template <int dim, int degree>'
p26659
aS'LaplaceProblem<dim, degree>::LaplaceProblem(const Settings &settings)'
p26660
aS'  : settings(settings)'
p26661
aS'  , mpi_communicator(MPI_COMM_WORLD)'
p26662
aS'  , pcout(std::cout, (Utilities::MPI::this_mpi_process(mpi_communicator) == 0))'
p26663
aS'  , triangulation(mpi_communicator,'
p26664
aS'                  Triangulation<dim>::limit_level_difference_at_vertices,'
p26665
aS'                    parallel::distributed::Triangulation<dim>::default_setting :'
p26666
aS'                    parallel::distributed::Triangulation<'
p26667
aS'                      dim>::construct_multigrid_hierarchy)'
p26668
aS'  , mapping()'
p26669
aS'  , fe(degree)'
p26670
aS'  , dof_handler(triangulation)'
p26671
aS'  , computing_timer(pcout, TimerOutput::never, TimerOutput::wall_times)'
p26672
ag9
aS'  GridGenerator::hyper_L(triangulation, -1., 1., /*colorize*/ false);'
p26673
aS'  triangulation.refine_global(1);'
p26674
ag17
aS'template <int dim, int degree>'
p26675
aS'void LaplaceProblem<dim, degree>::setup_system()'
p26676
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Setup");'
p26677
aS'  dof_handler.distribute_dofs(fe);'
p26678
aS'  DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p26679
aS'  locally_owned_dofs = dof_handler.locally_owned_dofs();'
p26680
aS'  solution.reinit(locally_owned_dofs, mpi_communicator);'
p26681
aS'  right_hand_side.reinit(locally_owned_dofs, mpi_communicator);'
p26682
aS'  constraints.reinit(locally_relevant_dofs);'
p26683
aS'  DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p26684
aS'  VectorTools::interpolate_boundary_values('
p26685
aS'    mapping, dof_handler, 0, Functions::ZeroFunction<dim>(), constraints);'
p26686
aS'  constraints.close();'
p26687
aS'  switch (settings.solver)'
p26688
aS'    {'
p26689
aS'      case Settings::gmg_mf:'
p26690
aS'        {'
p26691
aS'          typename MatrixFree<dim, double>::AdditionalData additional_data;'
p26692
aS'          additional_data.tasks_parallel_scheme ='
p26693
aS'            MatrixFree<dim, double>::AdditionalData::none;'
p26694
aS'          additional_data.mapping_update_flags ='
p26695
aS'          std::shared_ptr<MatrixFree<dim, double>> mf_storage ='
p26696
aS'            std::make_shared<MatrixFree<dim, double>>();'
p26697
aS'          mf_storage->reinit(mapping,'
p26698
aS'                             dof_handler,'
p26699
aS'                             constraints,'
p26700
aS'                             QGauss<1>(degree + 1),'
p26701
aS'                             additional_data);'
p26702
aS'          mf_system_matrix.initialize(mf_storage);'
p26703
aS'          const Coefficient<dim> coefficient;'
p26704
aS'          mf_system_matrix.set_coefficient('
p26705
aS'            coefficient.make_coefficient_table(*mf_storage));'
p26706
aS'          break;'
p26707
aS'        }'
p26708
aS'      case Settings::gmg_mb:'
p26709
aS'      case Settings::amg:'
p26710
aS'        {'
p26711
aS'#ifdef USE_PETSC_LA'
p26712
aS'          DynamicSparsityPattern dsp(locally_relevant_dofs);'
p26713
aS'          DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p26714
aS'          SparsityTools::distribute_sparsity_pattern(dsp,'
p26715
aS'                                                     locally_owned_dofs,'
p26716
aS'                                                     mpi_communicator,'
p26717
aS'                                                     locally_relevant_dofs);'
p26718
aS'          system_matrix.reinit(locally_owned_dofs,'
p26719
aS'                               locally_owned_dofs,'
p26720
aS'                               dsp,'
p26721
aS'                               mpi_communicator);'
p26722
aS'#else'
p26723
aS'          TrilinosWrappers::SparsityPattern dsp(locally_owned_dofs,'
p26724
aS'                                                locally_owned_dofs,'
p26725
aS'                                                locally_relevant_dofs,'
p26726
aS'                                                mpi_communicator);'
p26727
aS'          DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p26728
aS'          dsp.compress();'
p26729
aS'          system_matrix.reinit(dsp);'
p26730
aS'#endif'
p26731
aS'          break;'
p26732
aS'        }'
p26733
aS'      default:'
p26734
aS'        Assert(false, ExcNotImplemented());'
p26735
aS'    }'
p26736
ag17
aS'template <int dim, int degree>'
p26737
aS'void LaplaceProblem<dim, degree>::setup_multigrid()'
p26738
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Setup multigrid");'
p26739
aS'  dof_handler.distribute_mg_dofs();'
p26740
aS'  mg_constrained_dofs.clear();'
p26741
aS'  mg_constrained_dofs.initialize(dof_handler);'
p26742
aS'  const std::set<types::boundary_id> boundary_ids = {types::boundary_id(0)};'
p26743
aS'  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, boundary_ids);'
p26744
aS'  const unsigned int n_levels = triangulation.n_global_levels();'
p26745
aS'  switch (settings.solver)'
p26746
aS'    {'
p26747
aS'      case Settings::gmg_mf:'
p26748
aS'        {'
p26749
aS'          mf_mg_matrix.resize(0, n_levels - 1);'
p26750
aS'          for (unsigned int level = 0; level < n_levels; ++level)'
p26751
aS'            {'
p26752
aS'              IndexSet relevant_dofs;'
p26753
aS'              DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p26754
aS'                                                            level,'
p26755
aS'                                                            relevant_dofs);'
p26756
aS'              AffineConstraints<double> level_constraints;'
p26757
aS'              level_constraints.reinit(relevant_dofs);'
p26758
aS'              level_constraints.add_lines('
p26759
aS'                mg_constrained_dofs.get_boundary_indices(level));'
p26760
aS'              level_constraints.close();'
p26761
aS'              typename MatrixFree<dim, float>::AdditionalData additional_data;'
p26762
aS'              additional_data.tasks_parallel_scheme ='
p26763
aS'                MatrixFree<dim, float>::AdditionalData::none;'
p26764
aS'              additional_data.mapping_update_flags ='
p26765
aS'                 update_quadrature_points);'
p26766
aS'              additional_data.mg_level = level;'
p26767
aS'              std::shared_ptr<MatrixFree<dim, float>> mf_storage_level('
p26768
aS'                new MatrixFree<dim, float>());'
p26769
aS'              mf_storage_level->reinit(mapping,'
p26770
aS'                                       dof_handler,'
p26771
aS'                                       level_constraints,'
p26772
aS'                                       QGauss<1>(degree + 1),'
p26773
aS'                                       additional_data);'
p26774
aS'              mf_mg_matrix[level].initialize(mf_storage_level,'
p26775
aS'                                             mg_constrained_dofs,'
p26776
aS'                                             level);'
p26777
aS'              const Coefficient<dim> coefficient;'
p26778
aS'              mf_mg_matrix[level].set_coefficient('
p26779
aS'                coefficient.make_coefficient_table(*mf_storage_level));'
p26780
aS'              mf_mg_matrix[level].compute_diagonal();'
p26781
aS'            }'
p26782
aS'          break;'
p26783
aS'        }'
p26784
aS'      case Settings::gmg_mb:'
p26785
aS'        {'
p26786
aS'          mg_matrix.resize(0, n_levels - 1);'
p26787
aS'          mg_matrix.clear_elements();'
p26788
aS'          mg_interface_in.resize(0, n_levels - 1);'
p26789
aS'          mg_interface_in.clear_elements();'
p26790
aS'          for (unsigned int level = 0; level < n_levels; ++level)'
p26791
aS'            {'
p26792
aS'              IndexSet dof_set;'
p26793
aS'              DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p26794
aS'                                                            level,'
p26795
aS'                                                            dof_set);'
p26796
aS'              {'
p26797
aS'#ifdef USE_PETSC_LA'
p26798
aS'                DynamicSparsityPattern dsp(dof_set);'
p26799
aS'                MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p26800
aS'                dsp.compress();'
p26801
aS'                SparsityTools::distribute_sparsity_pattern('
p26802
aS'                  dsp,'
p26803
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26804
aS'                  mpi_communicator,'
p26805
aS'                  dof_set);'
p26806
aS'                mg_matrix[level].reinit('
p26807
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26808
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26809
aS'                  dsp,'
p26810
aS'                  mpi_communicator);'
p26811
aS'#else'
p26812
aS'                TrilinosWrappers::SparsityPattern dsp('
p26813
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26814
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26815
aS'                  dof_set,'
p26816
aS'                  mpi_communicator);'
p26817
aS'                MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p26818
aS'                dsp.compress();'
p26819
aS'                mg_matrix[level].reinit(dsp);'
p26820
aS'#endif'
p26821
aS'              }'
p26822
aS'              {'
p26823
aS'#ifdef USE_PETSC_LA'
p26824
aS'                DynamicSparsityPattern dsp(dof_set);'
p26825
aS'                MGTools::make_interface_sparsity_pattern(dof_handler,'
p26826
aS'                                                         mg_constrained_dofs,'
p26827
aS'                                                         dsp,'
p26828
aS'                                                         level);'
p26829
aS'                dsp.compress();'
p26830
aS'                SparsityTools::distribute_sparsity_pattern('
p26831
aS'                  dsp,'
p26832
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26833
aS'                  mpi_communicator,'
p26834
aS'                  dof_set);'
p26835
aS'                mg_interface_in[level].reinit('
p26836
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26837
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26838
aS'                  dsp,'
p26839
aS'                  mpi_communicator);'
p26840
aS'#else'
p26841
aS'                TrilinosWrappers::SparsityPattern dsp('
p26842
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26843
aS'                  dof_handler.locally_owned_mg_dofs(level),'
p26844
aS'                  dof_set,'
p26845
aS'                  mpi_communicator);'
p26846
aS'                MGTools::make_interface_sparsity_pattern(dof_handler,'
p26847
aS'                                                         mg_constrained_dofs,'
p26848
aS'                                                         dsp,'
p26849
aS'                                                         level);'
p26850
aS'                dsp.compress();'
p26851
aS'                mg_interface_in[level].reinit(dsp);'
p26852
aS'#endif'
p26853
aS'              }'
p26854
aS'            }'
p26855
aS'          break;'
p26856
aS'        }'
p26857
aS'      default:'
p26858
aS'        Assert(false, ExcNotImplemented());'
p26859
aS'    }'
p26860
ag17
aS'template <int dim, int degree>'
p26861
aS'void LaplaceProblem<dim, degree>::assemble_system()'
p26862
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Assemble");'
p26863
aS'  const QGauss<dim> quadrature_formula(degree + 1);'
p26864
aS'  FEValues<dim> fe_values(fe,'
p26865
aS'                          quadrature_formula,'
p26866
aS'                          update_values | update_gradients |'
p26867
aS'                            update_quadrature_points | update_JxW_values);'
p26868
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p26869
aS'  const unsigned int n_q_points    = quadrature_formula.size();'
p26870
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p26871
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p26872
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p26873
aS'  const Coefficient<dim> coefficient;'
p26874
aS'  RightHandSide<dim>     rhs;'
p26875
aS'  std::vector<double>    rhs_values(n_q_points);'
p26876
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p26877
aS'    if (cell->is_locally_owned())'
p26878
aS'      {'
p26879
aS'        cell_matrix = 0;'
p26880
aS'        cell_rhs    = 0;'
p26881
aS'        fe_values.reinit(cell);'
p26882
aS'        const double coefficient_value ='
p26883
aS'          coefficient.average_value(fe_values.get_quadrature_points());'
p26884
aS'        rhs.value_list(fe_values.get_quadrature_points(), rhs_values);'
p26885
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p26886
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p26887
aS'            {'
p26888
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p26889
aS'                cell_matrix(i, j) +='
p26890
aS'                  coefficient_value *                // epsilon(x)'
p26891
aS'                  fe_values.shape_grad(i, q_point) * // * grad phi_i(x)'
p26892
aS'                  fe_values.shape_grad(j, q_point) * // * grad phi_j(x)'
p26893
aS'                  fe_values.JxW(q_point);            // * dx'
p26894
aS'              cell_rhs(i) +='
p26895
aS'                fe_values.shape_value(i, q_point) * // grad phi_i(x)'
p26896
aS'                rhs_values[q_point] *               // * f(x)'
p26897
aS'                fe_values.JxW(q_point);             // * dx'
p26898
aS'            }'
p26899
aS'        cell->get_dof_indices(local_dof_indices);'
p26900
aS'        constraints.distribute_local_to_global(cell_matrix,'
p26901
aS'                                               cell_rhs,'
p26902
aS'                                               local_dof_indices,'
p26903
aS'                                               system_matrix,'
p26904
aS'                                               right_hand_side);'
p26905
aS'      }'
p26906
aS'  system_matrix.compress(VectorOperation::add);'
p26907
aS'  right_hand_side.compress(VectorOperation::add);'
p26908
ag17
aS'template <int dim, int degree>'
p26909
aS'void LaplaceProblem<dim, degree>::assemble_multigrid()'
p26910
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Assemble multigrid");'
p26911
aS'  QGauss<dim> quadrature_formula(degree + 1);'
p26912
aS'  FEValues<dim> fe_values(fe,'
p26913
aS'                          quadrature_formula,'
p26914
aS'                          update_values | update_gradients |'
p26915
aS'                            update_quadrature_points | update_JxW_values);'
p26916
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p26917
aS'  const unsigned int n_q_points    = quadrature_formula.size();'
p26918
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p26919
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p26920
aS'  const Coefficient<dim> coefficient;'
p26921
aS'  std::vector<AffineConstraints<double>> boundary_constraints('
p26922
aS'    triangulation.n_global_levels());'
p26923
aS'  for (unsigned int level = 0; level < triangulation.n_global_levels(); ++level)'
p26924
aS'    {'
p26925
aS'      IndexSet dof_set;'
p26926
aS'      DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p26927
aS'                                                    level,'
p26928
aS'                                                    dof_set);'
p26929
aS'      boundary_constraints[level].reinit(dof_set);'
p26930
aS'      boundary_constraints[level].add_lines('
p26931
aS'        mg_constrained_dofs.get_refinement_edge_indices(level));'
p26932
aS'      boundary_constraints[level].add_lines('
p26933
aS'        mg_constrained_dofs.get_boundary_indices(level));'
p26934
aS'      boundary_constraints[level].close();'
p26935
aS'    }'
p26936
aS'  for (const auto &cell : dof_handler.cell_iterators())'
p26937
aS'    if (cell->level_subdomain_id() == triangulation.locally_owned_subdomain())'
p26938
aS'      {'
p26939
aS'        cell_matrix = 0;'
p26940
aS'        fe_values.reinit(cell);'
p26941
aS'        const double coefficient_value ='
p26942
aS'          coefficient.average_value(fe_values.get_quadrature_points());'
p26943
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p26944
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p26945
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p26946
aS'              cell_matrix(i, j) +='
p26947
aS'                coefficient_value * fe_values.shape_grad(i, q_point) *'
p26948
aS'                fe_values.shape_grad(j, q_point) * fe_values.JxW(q_point);'
p26949
aS'        cell->get_mg_dof_indices(local_dof_indices);'
p26950
aS'        boundary_constraints[cell->level()].distribute_local_to_global('
p26951
aS'          cell_matrix, local_dof_indices, mg_matrix[cell->level()]);'
p26952
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p26953
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p26954
aS'            if (mg_constrained_dofs.is_interface_matrix_entry('
p26955
aS'                  cell->level(), local_dof_indices[i], local_dof_indices[j]))'
p26956
aS'              mg_interface_in[cell->level()].add(local_dof_indices[i],'
p26957
aS'                                                 local_dof_indices[j],'
p26958
aS'                                                 cell_matrix(i, j));'
p26959
aS'      }'
p26960
aS'  for (unsigned int i = 0; i < triangulation.n_global_levels(); ++i)'
p26961
aS'    {'
p26962
aS'      mg_matrix[i].compress(VectorOperation::add);'
p26963
aS'      mg_interface_in[i].compress(VectorOperation::add);'
p26964
aS'    }'
p26965
ag17
aS'template <int dim, int degree>'
p26966
aS'void LaplaceProblem<dim, degree>::assemble_rhs()'
p26967
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Assemble right-hand side");'
p26968
aS'  MatrixFreeActiveVector solution_copy;'
p26969
aS'  MatrixFreeActiveVector right_hand_side_copy;'
p26970
aS'  mf_system_matrix.initialize_dof_vector(solution_copy);'
p26971
aS'  mf_system_matrix.initialize_dof_vector(right_hand_side_copy);'
p26972
aS'  solution_copy = 0.;'
p26973
aS'  constraints.distribute(solution_copy);'
p26974
aS'  solution_copy.update_ghost_values();'
p26975
aS'  right_hand_side_copy = 0;'
p26976
aS'  const Table<2, VectorizedArray<double>> &coefficient ='
p26977
aS'  RightHandSide<dim> right_hand_side_function;'
p26978
aS'  FEEvaluation<dim, degree, degree + 1, 1, double> phi('
p26979
aS'  for (unsigned int cell = 0;'
p26980
aS'       cell < mf_system_matrix.get_matrix_free()->n_cell_batches();'
p26981
aS'       ++cell)'
p26982
aS'    {'
p26983
aS'      phi.reinit(cell);'
p26984
aS'      phi.read_dof_values_plain(solution_copy);'
p26985
aS'      phi.evaluate(EvaluationFlags::gradients);'
p26986
aS'      for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p26987
aS'        {'
p26988
aS'          phi.submit_gradient(-1.0 *'
p26989
aS'                              q);'
p26990
aS'          phi.submit_value('
p26991
aS'            right_hand_side_function.value(phi.quadrature_point(q)), q);'
p26992
aS'        }'
p26993
aS'      phi.integrate_scatter(EvaluationFlags::values |'
p26994
aS'                              EvaluationFlags::gradients,'
p26995
aS'                            right_hand_side_copy);'
p26996
aS'    }'
p26997
aS'  right_hand_side_copy.compress(VectorOperation::add);'
p26998
aS'  ChangeVectorTypes::copy(right_hand_side, right_hand_side_copy);'
p26999
ag17
aS'template <int dim, int degree>'
p27000
aS'void LaplaceProblem<dim, degree>::solve()'
p27001
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Solve");'
p27002
aS'  SolverControl solver_control(1000, 1.e-10 * right_hand_side.l2_norm());'
p27003
aS'  solver_control.enable_history_data();'
p27004
aS'  solution = 0.;'
p27005
aS'  switch (settings.solver)'
p27006
aS'    {'
p27007
aS'      case Settings::gmg_mf:'
p27008
aS'        {'
p27009
aS'          computing_timer.enter_subsection("Solve: Preconditioner setup");'
p27010
aS'          MGTransferMatrixFree<dim, float> mg_transfer(mg_constrained_dofs);'
p27011
aS'          mg_transfer.build(dof_handler);'
p27012
aS'          SolverControl coarse_solver_control(1000, 1e-12, false, false);'
p27013
aS'          SolverCG<MatrixFreeLevelVector> coarse_solver(coarse_solver_control);'
p27014
aS'          PreconditionIdentity            identity;'
p27015
aS'          MGCoarseGridIterativeSolver<MatrixFreeLevelVector,'
p27016
aS'                                      SolverCG<MatrixFreeLevelVector>,'
p27017
aS'                                      MatrixFreeLevelMatrix,'
p27018
aS'                                      PreconditionIdentity>'
p27019
aS'            coarse_grid_solver(coarse_solver, mf_mg_matrix[0], identity);'
p27020
aS'          using Smoother = dealii::PreconditionJacobi<MatrixFreeLevelMatrix>;'
p27021
aS'          MGSmootherPrecondition<MatrixFreeLevelMatrix,'
p27022
aS'                                 Smoother,'
p27023
aS'                                 MatrixFreeLevelVector>'
p27024
aS'            smoother;'
p27025
aS'          smoother.initialize(mf_mg_matrix,'
p27026
aS'                              typename Smoother::AdditionalData('
p27027
aS'                                settings.smoother_dampen));'
p27028
aS'          smoother.set_steps(settings.smoother_steps);'
p27029
aS'          mg::Matrix<MatrixFreeLevelVector> mg_m(mf_mg_matrix);'
p27030
aS'          MGLevelObject<'
p27031
aS'            MatrixFreeOperators::MGInterfaceOperator<MatrixFreeLevelMatrix>>'
p27032
aS'            mg_interface_matrices;'
p27033
aS'          mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1);'
p27034
aS'          for (unsigned int level = 0; level < triangulation.n_global_levels();'
p27035
aS'               ++level)'
p27036
aS'            mg_interface_matrices[level].initialize(mf_mg_matrix[level]);'
p27037
aS'          mg::Matrix<MatrixFreeLevelVector> mg_interface(mg_interface_matrices);'
p27038
aS'          Multigrid<MatrixFreeLevelVector> mg('
p27039
aS'            mg_m, coarse_grid_solver, mg_transfer, smoother, smoother);'
p27040
aS'          mg.set_edge_matrices(mg_interface, mg_interface);'
p27041
aS'          PreconditionMG<dim,'
p27042
aS'                         MatrixFreeLevelVector,'
p27043
aS'                         MGTransferMatrixFree<dim, float>>'
p27044
aS'            preconditioner(dof_handler, mg, mg_transfer);'
p27045
aS'          MatrixFreeActiveVector solution_copy;'
p27046
aS'          MatrixFreeActiveVector right_hand_side_copy;'
p27047
aS'          mf_system_matrix.initialize_dof_vector(solution_copy);'
p27048
aS'          mf_system_matrix.initialize_dof_vector(right_hand_side_copy);'
p27049
aS'          ChangeVectorTypes::copy(solution_copy, solution);'
p27050
aS'          ChangeVectorTypes::copy(right_hand_side_copy, right_hand_side);'
p27051
aS'          computing_timer.leave_subsection("Solve: Preconditioner setup");'
p27052
aS'          {'
p27053
aS'            TimerOutput::Scope timing(computing_timer,'
p27054
aS'                                      "Solve: 1 multigrid V-cycle");'
p27055
aS'            preconditioner.vmult(solution_copy, right_hand_side_copy);'
p27056
aS'          }'
p27057
aS'          solution_copy = 0.;'
p27058
aS'          {'
p27059
aS'            SolverCG<MatrixFreeActiveVector> solver(solver_control);'
p27060
aS'            TimerOutput::Scope timing(computing_timer, "Solve: CG");'
p27061
aS'            solver.solve(mf_system_matrix,'
p27062
aS'                         solution_copy,'
p27063
aS'                         right_hand_side_copy,'
p27064
aS'                         preconditioner);'
p27065
aS'          }'
p27066
aS'          solution_copy.update_ghost_values();'
p27067
aS'          ChangeVectorTypes::copy(solution, solution_copy);'
p27068
aS'          constraints.distribute(solution);'
p27069
aS'          break;'
p27070
aS'        }'
p27071
aS'      case Settings::gmg_mb:'
p27072
aS'        {'
p27073
aS'          computing_timer.enter_subsection("Solve: Preconditioner setup");'
p27074
aS'          MGTransferPrebuilt<VectorType> mg_transfer(mg_constrained_dofs);'
p27075
aS'          mg_transfer.build(dof_handler);'
p27076
aS'          SolverControl        coarse_solver_control(1000, 1e-12, false, false);'
p27077
aS'          SolverCG<VectorType> coarse_solver(coarse_solver_control);'
p27078
aS'          PreconditionIdentity identity;'
p27079
aS'          MGCoarseGridIterativeSolver<VectorType,'
p27080
aS'                                      SolverCG<VectorType>,'
p27081
aS'                                      MatrixType,'
p27082
aS'                                      PreconditionIdentity>'
p27083
aS'            coarse_grid_solver(coarse_solver, mg_matrix[0], identity);'
p27084
aS'          using Smoother = LA::MPI::PreconditionJacobi;'
p27085
aS'          MGSmootherPrecondition<MatrixType, Smoother, VectorType> smoother;'
p27086
aS'#ifdef USE_PETSC_LA'
p27087
aS'          smoother.initialize(mg_matrix);'
p27088
aS'          Assert('
p27089
aS'            settings.smoother_dampen == 1.0,'
p27090
aS'            ExcNotImplemented('
p27091
aS'              "PETSc\'s PreconditionJacobi has no support for a damping parameter."));'
p27092
aS'#else'
p27093
aS'          smoother.initialize(mg_matrix, settings.smoother_dampen);'
p27094
aS'#endif'
p27095
aS'          smoother.set_steps(settings.smoother_steps);'
p27096
aS'          mg::Matrix<VectorType> mg_m(mg_matrix);'
p27097
aS'          mg::Matrix<VectorType> mg_in(mg_interface_in);'
p27098
aS'          mg::Matrix<VectorType> mg_out(mg_interface_in);'
p27099
aS'          Multigrid<VectorType> mg('
p27100
aS'            mg_m, coarse_grid_solver, mg_transfer, smoother, smoother);'
p27101
aS'          mg.set_edge_matrices(mg_out, mg_in);'
p27102
aS'          PreconditionMG<dim, VectorType, MGTransferPrebuilt<VectorType>>'
p27103
aS'            preconditioner(dof_handler, mg, mg_transfer);'
p27104
aS'          computing_timer.leave_subsection("Solve: Preconditioner setup");'
p27105
aS'          {'
p27106
aS'            TimerOutput::Scope timing(computing_timer,'
p27107
aS'                                      "Solve: 1 multigrid V-cycle");'
p27108
aS'            preconditioner.vmult(solution, right_hand_side);'
p27109
aS'          }'
p27110
aS'          solution = 0.;'
p27111
aS'          {'
p27112
aS'            SolverCG<VectorType> solver(solver_control);'
p27113
aS'            TimerOutput::Scope timing(computing_timer, "Solve: CG");'
p27114
aS'            solver.solve(system_matrix,'
p27115
aS'                         solution,'
p27116
aS'                         right_hand_side,'
p27117
aS'                         preconditioner);'
p27118
aS'          }'
p27119
aS'          constraints.distribute(solution);'
p27120
aS'          break;'
p27121
aS'        }'
p27122
aS'      case Settings::amg:'
p27123
aS'        {'
p27124
aS'          computing_timer.enter_subsection("Solve: Preconditioner setup");'
p27125
aS'          PreconditionAMG                 preconditioner;'
p27126
aS'          PreconditionAMG::AdditionalData Amg_data;'
p27127
aS'#ifdef USE_PETSC_LA'
p27128
aS'          Amg_data.symmetric_operator = true;'
p27129
aS'#else'
p27130
aS'          Amg_data.elliptic              = true;'
p27131
aS'          Amg_data.smoother_type         = "Jacobi";'
p27132
aS'          Amg_data.higher_order_elements = true;'
p27133
aS'          Amg_data.smoother_sweeps       = settings.smoother_steps;'
p27134
aS'          Amg_data.aggregation_threshold = 0.02;'
p27135
aS'#endif'
p27136
aS'          Amg_data.output_details = false;'
p27137
aS'          preconditioner.initialize(system_matrix, Amg_data);'
p27138
aS'          computing_timer.leave_subsection("Solve: Preconditioner setup");'
p27139
aS'          {'
p27140
aS'            TimerOutput::Scope timing(computing_timer,'
p27141
aS'                                      "Solve: 1 multigrid V-cycle");'
p27142
aS'            preconditioner.vmult(solution, right_hand_side);'
p27143
aS'          }'
p27144
aS'          solution = 0.;'
p27145
aS'          {'
p27146
aS'            SolverCG<VectorType> solver(solver_control);'
p27147
aS'            TimerOutput::Scope timing(computing_timer, "Solve: CG");'
p27148
aS'            solver.solve(system_matrix,'
p27149
aS'                         solution,'
p27150
aS'                         right_hand_side,'
p27151
aS'                         preconditioner);'
p27152
aS'          }'
p27153
aS'          constraints.distribute(solution);'
p27154
aS'          break;'
p27155
aS'        }'
p27156
aS'      default:'
p27157
aS'        Assert(false, ExcInternalError());'
p27158
aS'    }'
p27159
aS'  pcout << "   Number of CG iterations:      " << solver_control.last_step()'
p27160
aS'        << std::endl;'
p27161
ag17
aS'template <int dim>'
p27162
aS'struct ScratchData'
p27163
ag9
aS'  ScratchData(const Mapping<dim> &      mapping,'
p27164
aS'              const FiniteElement<dim> &fe,'
p27165
aS'              const unsigned int        quadrature_degree,'
p27166
aS'              const UpdateFlags         update_flags,'
p27167
aS'              const UpdateFlags         interface_update_flags)'
p27168
aS'    : fe_values(mapping, fe, QGauss<dim>(quadrature_degree), update_flags)'
p27169
aS'    , fe_interface_values(mapping,'
p27170
aS'                          fe,'
p27171
aS'                          QGauss<dim - 1>(quadrature_degree),'
p27172
aS'                          interface_update_flags)'
p27173
aS'  {}'
p27174
aS'  ScratchData(const ScratchData<dim> &scratch_data)'
p27175
aS'    : fe_values(scratch_data.fe_values.get_mapping(),'
p27176
aS'                scratch_data.fe_values.get_fe(),'
p27177
aS'                scratch_data.fe_values.get_quadrature(),'
p27178
aS'                scratch_data.fe_values.get_update_flags())'
p27179
aS'    , fe_interface_values(scratch_data.fe_values.get_mapping(),'
p27180
aS'                          scratch_data.fe_values.get_fe(),'
p27181
aS'                          scratch_data.fe_interface_values.get_quadrature(),'
p27182
aS'                          scratch_data.fe_interface_values.get_update_flags())'
p27183
aS'  {}'
p27184
aS'  FEValues<dim>          fe_values;'
p27185
aS'  FEInterfaceValues<dim> fe_interface_values;'
p27186
aS'};'
p27187
aS'struct CopyData'
p27188
ag9
aS'  CopyData()'
p27189
aS'    : cell_index(numbers::invalid_unsigned_int)'
p27190
aS'    , value(0.)'
p27191
aS'  {}'
p27192
aS'  CopyData(const CopyData &) = default;'
p27193
aS'  struct FaceData'
p27194
aS'  {'
p27195
aS'    unsigned int cell_indices[2];'
p27196
aS'    double       values[2];'
p27197
aS'  };'
p27198
aS'  unsigned int          cell_index;'
p27199
aS'  double                value;'
p27200
aS'  std::vector<FaceData> face_data;'
p27201
aS'};'
p27202
aS'template <int dim, int degree>'
p27203
aS'void LaplaceProblem<dim, degree>::estimate()'
p27204
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Estimate");'
p27205
aS'  VectorType temp_solution;'
p27206
aS'  temp_solution.reinit(locally_owned_dofs,'
p27207
aS'                       locally_relevant_dofs,'
p27208
aS'                       mpi_communicator);'
p27209
aS'  temp_solution = solution;'
p27210
aS'  const Coefficient<dim> coefficient;'
p27211
aS'  estimated_error_square_per_cell.reinit(triangulation.n_active_cells());'
p27212
aS'  using Iterator = typename DoFHandler<dim>::active_cell_iterator;'
p27213
aS'  auto cell_worker = [&](const Iterator &  cell,'
p27214
aS'                         ScratchData<dim> &scratch_data,'
p27215
aS'                         CopyData &        copy_data) {'
p27216
aS'    FEValues<dim> &fe_values = scratch_data.fe_values;'
p27217
aS'    fe_values.reinit(cell);'
p27218
aS'    RightHandSide<dim> rhs;'
p27219
aS'    const double       rhs_value = rhs.value(cell->center());'
p27220
aS'    const double nu = coefficient.value(cell->center());'
p27221
aS'    std::vector<Tensor<2, dim>> hessians(fe_values.n_quadrature_points);'
p27222
aS'    fe_values.get_function_hessians(temp_solution, hessians);'
p27223
aS'    copy_data.cell_index = cell->active_cell_index();'
p27224
aS'    double residual_norm_square = 0.;'
p27225
aS'    for (unsigned k = 0; k < fe_values.n_quadrature_points; ++k)'
p27226
aS'      {'
p27227
aS'        const double residual = (rhs_value + nu * trace(hessians[k]));'
p27228
aS'        residual_norm_square += residual * residual * fe_values.JxW(k);'
p27229
aS'      }'
p27230
aS'    copy_data.value ='
p27231
aS'      cell->diameter() * cell->diameter() * residual_norm_square;'
p27232
aS'  };'
p27233
aS'  auto face_worker = [&](const Iterator &    cell,'
p27234
aS'                         const unsigned int &f,'
p27235
aS'                         const unsigned int &sf,'
p27236
aS'                         const Iterator &    ncell,'
p27237
aS'                         const unsigned int &nf,'
p27238
aS'                         const unsigned int &nsf,'
p27239
aS'                         ScratchData<dim> &  scratch_data,'
p27240
aS'                         CopyData &          copy_data) {'
p27241
aS'    FEInterfaceValues<dim> &fe_interface_values ='
p27242
aS'      scratch_data.fe_interface_values;'
p27243
aS'    fe_interface_values.reinit(cell, f, sf, ncell, nf, nsf);'
p27244
aS'    copy_data.face_data.emplace_back();'
p27245
aS'    CopyData::FaceData &copy_data_face = copy_data.face_data.back();'
p27246
aS'    copy_data_face.cell_indices[0] = cell->active_cell_index();'
p27247
aS'    copy_data_face.cell_indices[1] = ncell->active_cell_index();'
p27248
aS'    const double coeff1 = coefficient.value(cell->center());'
p27249
aS'    const double coeff2 = coefficient.value(ncell->center());'
p27250
aS'    std::vector<Tensor<1, dim>> grad_u[2];'
p27251
aS'    for (unsigned int i = 0; i < 2; ++i)'
p27252
aS'      {'
p27253
aS'        grad_u[i].resize(fe_interface_values.n_quadrature_points);'
p27254
aS'        fe_interface_values.get_fe_face_values(i).get_function_gradients('
p27255
aS'          temp_solution, grad_u[i]);'
p27256
aS'      }'
p27257
aS'    double jump_norm_square = 0.;'
p27258
aS'    for (unsigned int qpoint = 0;'
p27259
aS'         qpoint < fe_interface_values.n_quadrature_points;'
p27260
aS'         ++qpoint)'
p27261
aS'      {'
p27262
aS'        const double jump ='
p27263
aS'          coeff1 * grad_u[0][qpoint] * fe_interface_values.normal(qpoint) -'
p27264
aS'          coeff2 * grad_u[1][qpoint] * fe_interface_values.normal(qpoint);'
p27265
aS'        jump_norm_square += jump * jump * fe_interface_values.JxW(qpoint);'
p27266
aS'      }'
p27267
aS'    const double h           = cell->face(f)->measure();'
p27268
aS'    copy_data_face.values[0] = 0.5 * h * jump_norm_square;'
p27269
aS'    copy_data_face.values[1] = copy_data_face.values[0];'
p27270
aS'  };'
p27271
aS'  auto copier = [&](const CopyData &copy_data) {'
p27272
aS'    if (copy_data.cell_index != numbers::invalid_unsigned_int)'
p27273
aS'      estimated_error_square_per_cell[copy_data.cell_index] += copy_data.value;'
p27274
aS'    for (auto &cdf : copy_data.face_data)'
p27275
aS'      for (unsigned int j = 0; j < 2; ++j)'
p27276
aS'        estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];'
p27277
aS'  };'
p27278
aS'  const unsigned int n_gauss_points = degree + 1;'
p27279
aS'  ScratchData<dim>   scratch_data(mapping,'
p27280
aS'                                fe,'
p27281
aS'                                n_gauss_points,'
p27282
aS'                                update_hessians | update_quadrature_points |'
p27283
aS'                                  update_JxW_values,'
p27284
aS'                                update_values | update_gradients |'
p27285
aS'                                  update_JxW_values | update_normal_vectors);'
p27286
aS'  CopyData           copy_data;'
p27287
aS'  MeshWorker::mesh_loop(dof_handler.begin_active(),'
p27288
aS'                        dof_handler.end(),'
p27289
aS'                        cell_worker,'
p27290
aS'                        copier,'
p27291
aS'                        scratch_data,'
p27292
aS'                        copy_data,'
p27293
aS'                        MeshWorker::assemble_own_cells |'
p27294
aS'                          MeshWorker::assemble_ghost_faces_both |'
p27295
aS'                          MeshWorker::assemble_own_interior_faces_once,'
p27296
aS'                        face_worker);'
p27297
aS'  const double global_error_estimate ='
p27298
aS'    std::sqrt(Utilities::MPI::sum(estimated_error_square_per_cell.l1_norm(),'
p27299
aS'                                  mpi_communicator));'
p27300
aS'  pcout << "   Global error estimate:        " << global_error_estimate'
p27301
aS'        << std::endl;'
p27302
ag17
aS'template <int dim, int degree>'
p27303
aS'void LaplaceProblem<dim, degree>::refine_grid()'
p27304
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Refine grid");'
p27305
aS'  const double refinement_fraction = 1. / (std::pow(2.0, dim) - 1.);'
p27306
aS'  parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p27307
aS'    triangulation, estimated_error_square_per_cell, refinement_fraction, 0.0);'
p27308
aS'  triangulation.execute_coarsening_and_refinement();'
p27309
ag17
aS'template <int dim, int degree>'
p27310
aS'void LaplaceProblem<dim, degree>::output_results(const unsigned int cycle)'
p27311
ag9
aS'  TimerOutput::Scope timing(computing_timer, "Output results");'
p27312
aS'  VectorType temp_solution;'
p27313
aS'  temp_solution.reinit(locally_owned_dofs,'
p27314
aS'                       locally_relevant_dofs,'
p27315
aS'                       mpi_communicator);'
p27316
aS'  temp_solution = solution;'
p27317
aS'  DataOut<dim> data_out;'
p27318
aS'  data_out.attach_dof_handler(dof_handler);'
p27319
aS'  data_out.add_data_vector(temp_solution, "solution");'
p27320
aS'  Vector<float> subdomain(triangulation.n_active_cells());'
p27321
aS'  for (unsigned int i = 0; i < subdomain.size(); ++i)'
p27322
aS'    subdomain(i) = triangulation.locally_owned_subdomain();'
p27323
aS'  data_out.add_data_vector(subdomain, "subdomain");'
p27324
aS'  Vector<float> level(triangulation.n_active_cells());'
p27325
aS'  for (const auto &cell : triangulation.active_cell_iterators())'
p27326
aS'    level(cell->active_cell_index()) = cell->level();'
p27327
aS'  data_out.add_data_vector(level, "level");'
p27328
aS'  if (estimated_error_square_per_cell.size() > 0)'
p27329
aS'    data_out.add_data_vector(estimated_error_square_per_cell,'
p27330
aS'                             "estimated_error_square_per_cell");'
p27331
aS'  data_out.build_patches();'
p27332
aS'  const std::string pvtu_filename = data_out.write_vtu_with_pvtu_record('
p27333
aS'    "", "solution", cycle, mpi_communicator, 2 /*n_digits*/, 1 /*n_groups*/);'
p27334
aS'  pcout << "   Wrote " << pvtu_filename << std::endl;'
p27335
ag17
aS'template <int dim, int degree>'
p27336
aS'void LaplaceProblem<dim, degree>::run()'
p27337
ag9
aS'  for (unsigned int cycle = 0; cycle < settings.n_steps; ++cycle)'
p27338
aS'    {'
p27339
aS'      pcout << "Cycle " << cycle << \':\' << std::endl;'
p27340
aS'      if (cycle > 0)'
p27341
aS'        refine_grid();'
p27342
aS'      pcout << "   Number of active cells:       "'
p27343
aS'            << triangulation.n_global_active_cells();'
p27344
aS'      if (settings.solver == Settings::gmg_mf ||'
p27345
aS'          settings.solver == Settings::gmg_mb)'
p27346
aS'        pcout << " (" << triangulation.n_global_levels() << " global levels)"'
p27347
aS'              << std::endl'
p27348
aS'              << "   Partition efficiency:         "'
p27349
aS'              << 1.0 / MGTools::workload_imbalance(triangulation);'
p27350
aS'      pcout << std::endl;'
p27351
aS'      setup_system();'
p27352
aS'      if (settings.solver == Settings::gmg_mf ||'
p27353
aS'          settings.solver == Settings::gmg_mb)'
p27354
aS'        setup_multigrid();'
p27355
aS'      pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs();'
p27356
aS'      if (settings.solver == Settings::gmg_mf ||'
p27357
aS'          settings.solver == Settings::gmg_mb)'
p27358
aS'        {'
p27359
aS'          pcout << " (by level: ";'
p27360
aS'          for (unsigned int level = 0; level < triangulation.n_global_levels();'
p27361
aS'               ++level)'
p27362
aS'            pcout << dof_handler.n_dofs(level)'
p27363
aS'                  << (level == triangulation.n_global_levels() - 1 ? ")" :'
p27364
aS'                                                                     ", ");'
p27365
aS'        }'
p27366
aS'      pcout << std::endl;'
p27367
aS'      if (settings.solver == Settings::gmg_mf)'
p27368
aS'        assemble_rhs();'
p27369
aS'      else /*gmg_mb or amg*/'
p27370
aS'        {'
p27371
aS'          assemble_system();'
p27372
aS'          if (settings.solver == Settings::gmg_mb)'
p27373
aS'            assemble_multigrid();'
p27374
aS'        }'
p27375
aS'      solve();'
p27376
aS'      estimate();'
p27377
aS'      if (settings.output)'
p27378
aS'        output_results(cycle);'
p27379
aS'      computing_timer.print_summary();'
p27380
aS'      computing_timer.reset();'
p27381
aS'    }'
p27382
ag17
aS'int main(int argc, char *argv[])'
p27383
ag9
aS'  using namespace dealii;'
p27384
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p27385
aS'  Settings settings;'
p27386
aS'  if (!settings.try_parse((argc > 1) ? (argv[1]) : ""))'
p27387
aS'    return 0;'
p27388
aS'  try'
p27389
aS'    {'
p27390
aS'      constexpr unsigned int fe_degree = 2;'
p27391
aS'      switch (settings.dimension)'
p27392
aS'        {'
p27393
aS'          case 2:'
p27394
aS'            {'
p27395
aS'              LaplaceProblem<2, fe_degree> test(settings);'
p27396
aS'              test.run();'
p27397
aS'              break;'
p27398
aS'            }'
p27399
aS'          case 3:'
p27400
aS'            {'
p27401
aS'              LaplaceProblem<3, fe_degree> test(settings);'
p27402
aS'              test.run();'
p27403
aS'              break;'
p27404
aS'            }'
p27405
aS'          default:'
p27406
aS'            Assert(false, ExcMessage("This program only works in 2d and 3d."));'
p27407
aS'        }'
p27408
aS'    }'
p27409
aS'  catch (std::exception &exc)'
p27410
aS'    {'
p27411
aS'      std::cerr << std::endl'
p27412
aS'                << std::endl'
p27413
aS'                << "----------------------------------------------------"'
p27414
aS'                << std::endl;'
p27415
aS'      std::cerr << "Exception on processing: " << std::endl'
p27416
aS'                << exc.what() << std::endl'
p27417
aS'                << "Aborting!" << std::endl'
p27418
aS'                << "----------------------------------------------------"'
p27419
aS'                << std::endl;'
p27420
aS'      MPI_Abort(MPI_COMM_WORLD, 1);'
p27421
aS'      return 1;'
p27422
aS'    }'
p27423
aS'  catch (...)'
p27424
aS'    {'
p27425
aS'      std::cerr << std::endl'
p27426
aS'                << std::endl'
p27427
aS'                << "----------------------------------------------------"'
p27428
aS'                << std::endl;'
p27429
aS'      std::cerr << "Unknown exception!" << std::endl'
p27430
aS'                << "Aborting!" << std::endl'
p27431
aS'                << "----------------------------------------------------"'
p27432
aS'                << std::endl;'
p27433
aS'      MPI_Abort(MPI_COMM_WORLD, 2);'
p27434
aS'      return 1;'
p27435
aS'    }'
p27436
aS'  return 0;'
p27437
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p27438
aS'#include <deal.II/base/function.h>'
p27439
aS'#include <deal.II/base/tensor_function.h>'
p27440
aS'#include <deal.II/base/exceptions.h>'
p27441
aS'#include <deal.II/base/logstream.h>'
p27442
aS'#include <deal.II/base/work_stream.h>'
p27443
aS'#include <deal.II/base/convergence_table.h>'
p27444
aS'#include <deal.II/lac/vector.h>'
p27445
aS'#include <deal.II/lac/affine_constraints.h>'
p27446
aS'#include <deal.II/lac/full_matrix.h>'
p27447
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p27448
aS'#include <deal.II/lac/solver_bicgstab.h>'
p27449
aS'#include <deal.II/lac/precondition.h>'
p27450
aS'#include <deal.II/grid/tria.h>'
p27451
aS'#include <deal.II/grid/grid_generator.h>'
p27452
aS'#include <deal.II/grid/grid_refinement.h>'
p27453
aS'#include <deal.II/dofs/dof_handler.h>'
p27454
aS'#include <deal.II/dofs/dof_renumbering.h>'
p27455
aS'#include <deal.II/dofs/dof_tools.h>'
p27456
aS'#include <deal.II/fe/fe_dgq.h>'
p27457
aS'#include <deal.II/fe/fe_system.h>'
p27458
aS'#include <deal.II/fe/fe_values.h>'
p27459
aS'#include <deal.II/numerics/vector_tools.h>'
p27460
aS'#include <deal.II/numerics/error_estimator.h>'
p27461
aS'#include <deal.II/numerics/matrix_tools.h>'
p27462
aS'#include <deal.II/numerics/data_out.h>'
p27463
aS'#include <deal.II/fe/fe_face.h>'
p27464
aS'#include <deal.II/lac/chunk_sparse_matrix.h>'
p27465
aS'#include <deal.II/numerics/data_out_faces.h>'
p27466
aS'#include <iostream>'
p27467
aS'namespace Step51'
p27468
ag9
aS'  using namespace dealii;'
p27469
aS'  template <int dim>'
p27470
aS'  class SolutionBase'
p27471
aS'  {'
p27472
aS'  protected:'
p27473
aS'    static const unsigned int n_source_centers = 3;'
p27474
aS'    static const Point<dim>   source_centers[n_source_centers];'
p27475
aS'    static const double       width;'
p27476
aS'  };'
p27477
aS'  template <>'
p27478
aS'  const Point<1>'
p27479
aS'    SolutionBase<1>::source_centers[SolutionBase<1>::n_source_centers] ='
p27480
aS'      {Point<1>(-1.0 / 3.0), Point<1>(0.0), Point<1>(+1.0 / 3.0)};'
p27481
aS'  template <>'
p27482
aS'  const Point<2>'
p27483
aS'    SolutionBase<2>::source_centers[SolutionBase<2>::n_source_centers] ='
p27484
aS'      {Point<2>(-0.5, +0.5), Point<2>(-0.5, -0.5), Point<2>(+0.5, -0.5)};'
p27485
aS'  template <>'
p27486
aS'  const Point<3>'
p27487
aS'    SolutionBase<3>::source_centers[SolutionBase<3>::n_source_centers] = {'
p27488
aS'      Point<3>(-0.5, +0.5, 0.25),'
p27489
aS'      Point<3>(-0.6, -0.5, -0.125),'
p27490
aS'      Point<3>(+0.5, -0.5, 0.5)};'
p27491
aS'  template <int dim>'
p27492
aS'  const double SolutionBase<dim>::width = 1. / 5.;'
p27493
aS'  template <int dim>'
p27494
aS'  class Solution : public Function<dim>, protected SolutionBase<dim>'
p27495
aS'  {'
p27496
aS'  public:'
p27497
aS'    virtual double value(const Point<dim> &p,'
p27498
aS'                         const unsigned int /*component*/ = 0) const override'
p27499
aS'    {'
p27500
aS'      double sum = 0;'
p27501
aS'      for (unsigned int i = 0; i < this->n_source_centers; ++i)'
p27502
aS'        {'
p27503
aS'          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i];'
p27504
aS'          sum +='
p27505
aS'            std::exp(-x_minus_xi.norm_square() / (this->width * this->width));'
p27506
aS'        }'
p27507
aS'      return sum /'
p27508
aS'             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.);'
p27509
aS'    }'
p27510
aS'    virtual Tensor<1, dim>'
p27511
aS'    gradient(const Point<dim> &p,'
p27512
aS'             const unsigned int /*component*/ = 0) const override'
p27513
aS'    {'
p27514
aS'      Tensor<1, dim> sum;'
p27515
aS'      for (unsigned int i = 0; i < this->n_source_centers; ++i)'
p27516
aS'        {'
p27517
aS'          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i];'
p27518
aS'          sum +='
p27519
aS'             std::exp(-x_minus_xi.norm_square() / (this->width * this->width)) *'
p27520
aS'             x_minus_xi);'
p27521
aS'        }'
p27522
aS'      return sum /'
p27523
aS'             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.);'
p27524
aS'    }'
p27525
aS'  };'
p27526
aS'  template <int dim>'
p27527
aS'  class SolutionAndGradient : public Function<dim>, protected SolutionBase<dim>'
p27528
aS'  {'
p27529
aS'  public:'
p27530
aS'    SolutionAndGradient()'
p27531
aS'      : Function<dim>(dim + 1)'
p27532
aS'    {}'
p27533
aS'    virtual void vector_value(const Point<dim> &p,'
p27534
aS'                              Vector<double> &  v) const override'
p27535
aS'    {'
p27536
aS'      AssertDimension(v.size(), dim + 1);'
p27537
aS'      Solution<dim>  solution;'
p27538
aS'      Tensor<1, dim> grad = solution.gradient(p);'
p27539
aS'      for (unsigned int d = 0; d < dim; ++d)'
p27540
aS'        v[d] = -grad[d];'
p27541
aS'      v[dim] = solution.value(p);'
p27542
aS'    }'
p27543
aS'  };'
p27544
aS'  template <int dim>'
p27545
aS'  class ConvectionVelocity : public TensorFunction<1, dim>'
p27546
aS'  {'
p27547
aS'  public:'
p27548
aS'    ConvectionVelocity()'
p27549
aS'      : TensorFunction<1, dim>()'
p27550
aS'    {}'
p27551
aS'    virtual Tensor<1, dim> value(const Point<dim> &p) const override'
p27552
aS'    {'
p27553
aS'      Tensor<1, dim> convection;'
p27554
aS'      switch (dim)'
p27555
aS'        {'
p27556
aS'          case 1:'
p27557
aS'            convection[0] = 1;'
p27558
aS'            break;'
p27559
aS'          case 2:'
p27560
aS'            convection[0] = p[1];'
p27561
aS'            convection[1] = -p[0];'
p27562
aS'            break;'
p27563
aS'          case 3:'
p27564
aS'            convection[0] = p[1];'
p27565
aS'            convection[1] = -p[0];'
p27566
aS'            convection[2] = 1;'
p27567
aS'            break;'
p27568
aS'          default:'
p27569
aS'            Assert(false, ExcNotImplemented());'
p27570
aS'        }'
p27571
aS'      return convection;'
p27572
aS'    }'
p27573
aS'  };'
p27574
aS'  template <int dim>'
p27575
aS'  class RightHandSide : public Function<dim>, protected SolutionBase<dim>'
p27576
aS'  {'
p27577
aS'  public:'
p27578
aS'    virtual double value(const Point<dim> &p,'
p27579
aS'                         const unsigned int /*component*/ = 0) const override'
p27580
aS'    {'
p27581
aS'      ConvectionVelocity<dim> convection_velocity;'
p27582
aS'      Tensor<1, dim>          convection = convection_velocity.value(p);'
p27583
aS'      double                  sum        = 0;'
p27584
aS'      for (unsigned int i = 0; i < this->n_source_centers; ++i)'
p27585
aS'        {'
p27586
aS'          const Tensor<1, dim> x_minus_xi = p - this->source_centers[i];'
p27587
aS'          sum +='
p27588
aS'              4 * x_minus_xi.norm_square() / (this->width * this->width)) /'
p27589
aS'             std::exp(-x_minus_xi.norm_square() / (this->width * this->width)));'
p27590
aS'        }'
p27591
aS'      return sum /'
p27592
aS'             std::pow(2. * numbers::PI * this->width * this->width, dim / 2.);'
p27593
aS'    }'
p27594
aS'  };'
p27595
aS'  template <int dim>'
p27596
aS'  class HDG'
p27597
aS'  {'
p27598
aS'  public:'
p27599
aS'    enum RefinementMode'
p27600
aS'    {'
p27601
aS'      global_refinement,'
p27602
aS'      adaptive_refinement'
p27603
aS'    };'
p27604
aS'    HDG(const unsigned int degree, const RefinementMode refinement_mode);'
p27605
aS'    void run();'
p27606
aS'  private:'
p27607
aS'    void setup_system();'
p27608
aS'    void assemble_system(const bool reconstruct_trace = false);'
p27609
aS'    void solve();'
p27610
aS'    void postprocess();'
p27611
aS'    void refine_grid(const unsigned int cycle);'
p27612
aS'    void output_results(const unsigned int cycle);'
p27613
aS'    struct PerTaskData;'
p27614
aS'    struct ScratchData;'
p27615
aS'    struct PostProcessScratchData;'
p27616
aS'    void assemble_system_one_cell('
p27617
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p27618
aS'      ScratchData &                                         scratch,'
p27619
aS'      PerTaskData &                                         task_data);'
p27620
aS'    void copy_local_to_global(const PerTaskData &data);'
p27621
aS'    void postprocess_one_cell('
p27622
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p27623
aS'      PostProcessScratchData &                              scratch,'
p27624
aS'      unsigned int &                                        empty_data);'
p27625
aS'    Triangulation<dim> triangulation;'
p27626
aS'    FESystem<dim>   fe_local;'
p27627
aS'    DoFHandler<dim> dof_handler_local;'
p27628
aS'    Vector<double>  solution_local;'
p27629
aS'    FE_FaceQ<dim>   fe;'
p27630
aS'    DoFHandler<dim> dof_handler;'
p27631
aS'    Vector<double>  solution;'
p27632
aS'    Vector<double>  system_rhs;'
p27633
aS'    FE_DGQ<dim>     fe_u_post;'
p27634
aS'    DoFHandler<dim> dof_handler_u_post;'
p27635
aS'    Vector<double>  solution_u_post;'
p27636
aS'    AffineConstraints<double> constraints;'
p27637
aS'    ChunkSparsityPattern      sparsity_pattern;'
p27638
aS'    ChunkSparseMatrix<double> system_matrix;'
p27639
aS'    const RefinementMode refinement_mode;'
p27640
aS'    ConvergenceTable     convergence_table;'
p27641
aS'  };'
p27642
aS'  template <int dim>'
p27643
aS'  HDG<dim>::HDG(const unsigned int degree, const RefinementMode refinement_mode)'
p27644
aS'    : fe_local(FE_DGQ<dim>(degree), dim, FE_DGQ<dim>(degree), 1)'
p27645
aS'    , dof_handler_local(triangulation)'
p27646
aS'    , fe(degree)'
p27647
aS'    , dof_handler(triangulation)'
p27648
aS'    , fe_u_post(degree + 1)'
p27649
aS'    , dof_handler_u_post(triangulation)'
p27650
aS'    , refinement_mode(refinement_mode)'
p27651
aS'  {}'
p27652
aS'  template <int dim>'
p27653
aS'  void HDG<dim>::setup_system()'
p27654
aS'  {'
p27655
aS'    dof_handler_local.distribute_dofs(fe_local);'
p27656
aS'    dof_handler.distribute_dofs(fe);'
p27657
aS'    dof_handler_u_post.distribute_dofs(fe_u_post);'
p27658
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p27659
aS'              << std::endl;'
p27660
aS'    solution.reinit(dof_handler.n_dofs());'
p27661
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p27662
aS'    solution_local.reinit(dof_handler_local.n_dofs());'
p27663
aS'    solution_u_post.reinit(dof_handler_u_post.n_dofs());'
p27664
aS'    constraints.clear();'
p27665
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p27666
aS'    std::map<types::boundary_id, const Function<dim> *> boundary_functions;'
p27667
aS'    Solution<dim>                                       solution_function;'
p27668
aS'    boundary_functions[0] = &solution_function;'
p27669
aS'    VectorTools::project_boundary_values(dof_handler,'
p27670
aS'                                         boundary_functions,'
p27671
aS'                                         QGauss<dim - 1>(fe.degree + 1),'
p27672
aS'                                         constraints);'
p27673
aS'    constraints.close();'
p27674
aS'    {'
p27675
aS'      DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p27676
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p27677
aS'      sparsity_pattern.copy_from(dsp, fe.n_dofs_per_face());'
p27678
aS'    }'
p27679
aS'    system_matrix.reinit(sparsity_pattern);'
p27680
aS'  }'
p27681
aS'  template <int dim>'
p27682
aS'  struct HDG<dim>::PerTaskData'
p27683
aS'  {'
p27684
aS'    FullMatrix<double>                   cell_matrix;'
p27685
aS'    Vector<double>                       cell_vector;'
p27686
aS'    std::vector<types::global_dof_index> dof_indices;'
p27687
aS'    bool trace_reconstruct;'
p27688
aS'    PerTaskData(const unsigned int n_dofs, const bool trace_reconstruct)'
p27689
aS'      : cell_matrix(n_dofs, n_dofs)'
p27690
aS'      , cell_vector(n_dofs)'
p27691
aS'      , dof_indices(n_dofs)'
p27692
aS'      , trace_reconstruct(trace_reconstruct)'
p27693
aS'    {}'
p27694
aS'  };'
p27695
aS'  template <int dim>'
p27696
aS'  struct HDG<dim>::ScratchData'
p27697
aS'  {'
p27698
aS'    FEValues<dim>     fe_values_local;'
p27699
aS'    FEFaceValues<dim> fe_face_values_local;'
p27700
aS'    FEFaceValues<dim> fe_face_values;'
p27701
aS'    FullMatrix<double> ll_matrix;'
p27702
aS'    FullMatrix<double> lf_matrix;'
p27703
aS'    FullMatrix<double> fl_matrix;'
p27704
aS'    FullMatrix<double> tmp_matrix;'
p27705
aS'    Vector<double>     l_rhs;'
p27706
aS'    Vector<double>     tmp_rhs;'
p27707
aS'    std::vector<Tensor<1, dim>> q_phi;'
p27708
aS'    std::vector<double>         q_phi_div;'
p27709
aS'    std::vector<double>         u_phi;'
p27710
aS'    std::vector<Tensor<1, dim>> u_phi_grad;'
p27711
aS'    std::vector<double>         tr_phi;'
p27712
aS'    std::vector<double>         trace_values;'
p27713
aS'    std::vector<std::vector<unsigned int>> fe_local_support_on_face;'
p27714
aS'    std::vector<std::vector<unsigned int>> fe_support_on_face;'
p27715
aS'    ConvectionVelocity<dim> convection_velocity;'
p27716
aS'    RightHandSide<dim>      right_hand_side;'
p27717
aS'    const Solution<dim>     exact_solution;'
p27718
aS'    ScratchData(const FiniteElement<dim> &fe,'
p27719
aS'                const FiniteElement<dim> &fe_local,'
p27720
aS'                const QGauss<dim> &       quadrature_formula,'
p27721
aS'                const QGauss<dim - 1> &   face_quadrature_formula,'
p27722
aS'                const UpdateFlags         local_flags,'
p27723
aS'                const UpdateFlags         local_face_flags,'
p27724
aS'                const UpdateFlags         flags)'
p27725
aS'      : fe_values_local(fe_local, quadrature_formula, local_flags)'
p27726
aS'      , fe_face_values_local(fe_local,'
p27727
aS'                             face_quadrature_formula,'
p27728
aS'                             local_face_flags)'
p27729
aS'      , fe_face_values(fe, face_quadrature_formula, flags)'
p27730
aS'      , ll_matrix(fe_local.n_dofs_per_cell(), fe_local.n_dofs_per_cell())'
p27731
aS'      , lf_matrix(fe_local.n_dofs_per_cell(), fe.n_dofs_per_cell())'
p27732
aS'      , fl_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())'
p27733
aS'      , tmp_matrix(fe.n_dofs_per_cell(), fe_local.n_dofs_per_cell())'
p27734
aS'      , l_rhs(fe_local.n_dofs_per_cell())'
p27735
aS'      , tmp_rhs(fe_local.n_dofs_per_cell())'
p27736
aS'      , q_phi(fe_local.n_dofs_per_cell())'
p27737
aS'      , q_phi_div(fe_local.n_dofs_per_cell())'
p27738
aS'      , u_phi(fe_local.n_dofs_per_cell())'
p27739
aS'      , u_phi_grad(fe_local.n_dofs_per_cell())'
p27740
aS'      , tr_phi(fe.n_dofs_per_cell())'
p27741
aS'      , trace_values(face_quadrature_formula.size())'
p27742
aS'      , fe_local_support_on_face(GeometryInfo<dim>::faces_per_cell)'
p27743
aS'      , fe_support_on_face(GeometryInfo<dim>::faces_per_cell)'
p27744
aS'      , exact_solution()'
p27745
aS'    {'
p27746
aS'      for (unsigned int face_no : GeometryInfo<dim>::face_indices())'
p27747
aS'        for (unsigned int i = 0; i < fe_local.n_dofs_per_cell(); ++i)'
p27748
aS'          {'
p27749
aS'            if (fe_local.has_support_on_face(i, face_no))'
p27750
aS'              fe_local_support_on_face[face_no].push_back(i);'
p27751
aS'          }'
p27752
aS'      for (unsigned int face_no : GeometryInfo<dim>::face_indices())'
p27753
aS'        for (unsigned int i = 0; i < fe.n_dofs_per_cell(); ++i)'
p27754
aS'          {'
p27755
aS'            if (fe.has_support_on_face(i, face_no))'
p27756
aS'              fe_support_on_face[face_no].push_back(i);'
p27757
aS'          }'
p27758
aS'    }'
p27759
aS'    ScratchData(const ScratchData &sd)'
p27760
aS'      : fe_values_local(sd.fe_values_local.get_fe(),'
p27761
aS'                        sd.fe_values_local.get_quadrature(),'
p27762
aS'                        sd.fe_values_local.get_update_flags())'
p27763
aS'      , fe_face_values_local(sd.fe_face_values_local.get_fe(),'
p27764
aS'                             sd.fe_face_values_local.get_quadrature(),'
p27765
aS'                             sd.fe_face_values_local.get_update_flags())'
p27766
aS'      , fe_face_values(sd.fe_face_values.get_fe(),'
p27767
aS'                       sd.fe_face_values.get_quadrature(),'
p27768
aS'                       sd.fe_face_values.get_update_flags())'
p27769
aS'      , ll_matrix(sd.ll_matrix)'
p27770
aS'      , lf_matrix(sd.lf_matrix)'
p27771
aS'      , fl_matrix(sd.fl_matrix)'
p27772
aS'      , tmp_matrix(sd.tmp_matrix)'
p27773
aS'      , l_rhs(sd.l_rhs)'
p27774
aS'      , tmp_rhs(sd.tmp_rhs)'
p27775
aS'      , q_phi(sd.q_phi)'
p27776
aS'      , q_phi_div(sd.q_phi_div)'
p27777
aS'      , u_phi(sd.u_phi)'
p27778
aS'      , u_phi_grad(sd.u_phi_grad)'
p27779
aS'      , tr_phi(sd.tr_phi)'
p27780
aS'      , trace_values(sd.trace_values)'
p27781
aS'      , fe_local_support_on_face(sd.fe_local_support_on_face)'
p27782
aS'      , fe_support_on_face(sd.fe_support_on_face)'
p27783
aS'      , exact_solution()'
p27784
aS'    {}'
p27785
aS'  };'
p27786
aS'  template <int dim>'
p27787
aS'  struct HDG<dim>::PostProcessScratchData'
p27788
aS'  {'
p27789
aS'    FEValues<dim> fe_values_local;'
p27790
aS'    FEValues<dim> fe_values;'
p27791
aS'    std::vector<double>         u_values;'
p27792
aS'    std::vector<Tensor<1, dim>> u_gradients;'
p27793
aS'    FullMatrix<double>          cell_matrix;'
p27794
aS'    Vector<double> cell_rhs;'
p27795
aS'    Vector<double> cell_sol;'
p27796
aS'    PostProcessScratchData(const FiniteElement<dim> &fe,'
p27797
aS'                           const FiniteElement<dim> &fe_local,'
p27798
aS'                           const QGauss<dim> &       quadrature_formula,'
p27799
aS'                           const UpdateFlags         local_flags,'
p27800
aS'                           const UpdateFlags         flags)'
p27801
aS'      : fe_values_local(fe_local, quadrature_formula, local_flags)'
p27802
aS'      , fe_values(fe, quadrature_formula, flags)'
p27803
aS'      , u_values(quadrature_formula.size())'
p27804
aS'      , u_gradients(quadrature_formula.size())'
p27805
aS'      , cell_matrix(fe.n_dofs_per_cell(), fe.n_dofs_per_cell())'
p27806
aS'      , cell_rhs(fe.n_dofs_per_cell())'
p27807
aS'      , cell_sol(fe.n_dofs_per_cell())'
p27808
aS'    {}'
p27809
aS'    PostProcessScratchData(const PostProcessScratchData &sd)'
p27810
aS'      : fe_values_local(sd.fe_values_local.get_fe(),'
p27811
aS'                        sd.fe_values_local.get_quadrature(),'
p27812
aS'                        sd.fe_values_local.get_update_flags())'
p27813
aS'      , fe_values(sd.fe_values.get_fe(),'
p27814
aS'                  sd.fe_values.get_quadrature(),'
p27815
aS'                  sd.fe_values.get_update_flags())'
p27816
aS'      , u_values(sd.u_values)'
p27817
aS'      , u_gradients(sd.u_gradients)'
p27818
aS'      , cell_matrix(sd.cell_matrix)'
p27819
aS'      , cell_rhs(sd.cell_rhs)'
p27820
aS'      , cell_sol(sd.cell_sol)'
p27821
aS'    {}'
p27822
aS'  };'
p27823
aS'  template <int dim>'
p27824
aS'  void HDG<dim>::assemble_system(const bool trace_reconstruct)'
p27825
aS'  {'
p27826
aS'    const QGauss<dim>     quadrature_formula(fe.degree + 1);'
p27827
aS'    const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p27828
aS'    const UpdateFlags local_flags(update_values | update_gradients |'
p27829
aS'                                  update_JxW_values | update_quadrature_points);'
p27830
aS'    const UpdateFlags local_face_flags(update_values);'
p27831
aS'    const UpdateFlags flags(update_values | update_normal_vectors |'
p27832
aS'                            update_quadrature_points | update_JxW_values);'
p27833
aS'    PerTaskData task_data(fe.n_dofs_per_cell(), trace_reconstruct);'
p27834
aS'    ScratchData scratch(fe,'
p27835
aS'                        fe_local,'
p27836
aS'                        quadrature_formula,'
p27837
aS'                        face_quadrature_formula,'
p27838
aS'                        local_flags,'
p27839
aS'                        local_face_flags,'
p27840
aS'                        flags);'
p27841
aS'    WorkStream::run(dof_handler.begin_active(),'
p27842
aS'                    dof_handler.end(),'
p27843
aS'                    &HDG<dim>::assemble_system_one_cell,'
p27844
aS'                    &HDG<dim>::copy_local_to_global,'
p27845
aS'                    scratch,'
p27846
aS'                    task_data);'
p27847
aS'  }'
p27848
aS'  template <int dim>'
p27849
aS'  void HDG<dim>::assemble_system_one_cell('
p27850
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p27851
aS'    ScratchData &                                         scratch,'
p27852
aS'    PerTaskData &                                         task_data)'
p27853
aS'  {'
p27854
aS'    typename DoFHandler<dim>::active_cell_iterator loc_cell(&triangulation,'
p27855
aS'                                                            cell->level(),'
p27856
aS'                                                            cell->index(),'
p27857
aS'                                                            &dof_handler_local);'
p27858
aS'    const unsigned int n_q_points ='
p27859
aS'      scratch.fe_values_local.get_quadrature().size();'
p27860
aS'    const unsigned int n_face_q_points ='
p27861
aS'      scratch.fe_face_values_local.get_quadrature().size();'
p27862
aS'    const unsigned int loc_dofs_per_cell ='
p27863
aS'      scratch.fe_values_local.get_fe().n_dofs_per_cell();'
p27864
aS'    const FEValuesExtractors::Vector fluxes(0);'
p27865
aS'    const FEValuesExtractors::Scalar scalar(dim);'
p27866
aS'    scratch.ll_matrix = 0;'
p27867
aS'    scratch.l_rhs     = 0;'
p27868
aS'    if (!task_data.trace_reconstruct)'
p27869
aS'      {'
p27870
aS'        scratch.lf_matrix     = 0;'
p27871
aS'        scratch.fl_matrix     = 0;'
p27872
aS'        task_data.cell_matrix = 0;'
p27873
aS'        task_data.cell_vector = 0;'
p27874
aS'      }'
p27875
aS'    scratch.fe_values_local.reinit(loc_cell);'
p27876
aS'    for (unsigned int q = 0; q < n_q_points; ++q)'
p27877
aS'      {'
p27878
aS'        const double rhs_value = scratch.right_hand_side.value('
p27879
aS'          scratch.fe_values_local.quadrature_point(q));'
p27880
aS'        const Tensor<1, dim> convection = scratch.convection_velocity.value('
p27881
aS'          scratch.fe_values_local.quadrature_point(q));'
p27882
aS'        const double JxW = scratch.fe_values_local.JxW(q);'
p27883
aS'        for (unsigned int k = 0; k < loc_dofs_per_cell; ++k)'
p27884
aS'          {'
p27885
aS'            scratch.q_phi[k] = scratch.fe_values_local[fluxes].value(k, q);'
p27886
aS'            scratch.q_phi_div[k] ='
p27887
aS'              scratch.fe_values_local[fluxes].divergence(k, q);'
p27888
aS'            scratch.u_phi[k] = scratch.fe_values_local[scalar].value(k, q);'
p27889
aS'            scratch.u_phi_grad[k] ='
p27890
aS'              scratch.fe_values_local[scalar].gradient(k, q);'
p27891
aS'          }'
p27892
aS'        for (unsigned int i = 0; i < loc_dofs_per_cell; ++i)'
p27893
aS'          {'
p27894
aS'            for (unsigned int j = 0; j < loc_dofs_per_cell; ++j)'
p27895
aS'              scratch.ll_matrix(i, j) +='
p27896
aS'                 scratch.q_phi_div[i] * scratch.u_phi[j] +'
p27897
aS'                 scratch.u_phi[i] * scratch.q_phi_div[j] -'
p27898
aS'                JxW;'
p27899
aS'            scratch.l_rhs(i) += scratch.u_phi[i] * rhs_value * JxW;'
p27900
aS'          }'
p27901
aS'      }'
p27902
aS'    for (const auto face_no : cell->face_indices())'
p27903
aS'      {'
p27904
aS'        scratch.fe_face_values_local.reinit(loc_cell, face_no);'
p27905
aS'        scratch.fe_face_values.reinit(cell, face_no);'
p27906
aS'        if (task_data.trace_reconstruct)'
p27907
aS'          scratch.fe_face_values.get_function_values(solution,'
p27908
aS'                                                     scratch.trace_values);'
p27909
aS'        for (unsigned int q = 0; q < n_face_q_points; ++q)'
p27910
aS'          {'
p27911
aS'            const double     JxW = scratch.fe_face_values.JxW(q);'
p27912
aS'            const Point<dim> quadrature_point ='
p27913
aS'              scratch.fe_face_values.quadrature_point(q);'
p27914
aS'            const Tensor<1, dim> normal ='
p27915
aS'              scratch.fe_face_values.normal_vector(q);'
p27916
aS'            const Tensor<1, dim> convection ='
p27917
aS'              scratch.convection_velocity.value(quadrature_point);'
p27918
aS'            const double tau_stab = (5. + std::abs(convection * normal));'
p27919
aS'            for (unsigned int k = 0;'
p27920
aS'                 k < scratch.fe_local_support_on_face[face_no].size();'
p27921
aS'                 ++k)'
p27922
aS'              {'
p27923
aS'                const unsigned int kk ='
p27924
aS'                  scratch.fe_local_support_on_face[face_no][k];'
p27925
aS'                scratch.q_phi[k] ='
p27926
aS'                  scratch.fe_face_values_local[fluxes].value(kk, q);'
p27927
aS'                scratch.u_phi[k] ='
p27928
aS'                  scratch.fe_face_values_local[scalar].value(kk, q);'
p27929
aS'              }'
p27930
aS'            if (!task_data.trace_reconstruct)'
p27931
aS'              {'
p27932
aS'                for (unsigned int k = 0;'
p27933
aS'                     k < scratch.fe_support_on_face[face_no].size();'
p27934
aS'                     ++k)'
p27935
aS'                  scratch.tr_phi[k] = scratch.fe_face_values.shape_value('
p27936
aS'                    scratch.fe_support_on_face[face_no][k], q);'
p27937
aS'                for (unsigned int i = 0;'
p27938
aS'                     i < scratch.fe_local_support_on_face[face_no].size();'
p27939
aS'                     ++i)'
p27940
aS'                  for (unsigned int j = 0;'
p27941
aS'                       j < scratch.fe_support_on_face[face_no].size();'
p27942
aS'                       ++j)'
p27943
aS'                    {'
p27944
aS'                      const unsigned int ii ='
p27945
aS'                        scratch.fe_local_support_on_face[face_no][i];'
p27946
aS'                      const unsigned int jj ='
p27947
aS'                        scratch.fe_support_on_face[face_no][j];'
p27948
aS'                      scratch.lf_matrix(ii, jj) +='
p27949
aS'                         scratch.tr_phi[j]) *'
p27950
aS'                        JxW;'
p27951
aS'                      scratch.fl_matrix(jj, ii) -='
p27952
aS'                          tau_stab * scratch.u_phi[i]) *'
p27953
aS'                         scratch.tr_phi[j]) *'
p27954
aS'                        JxW;'
p27955
aS'                    }'
p27956
aS'                for (unsigned int i = 0;'
p27957
aS'                     i < scratch.fe_support_on_face[face_no].size();'
p27958
aS'                     ++i)'
p27959
aS'                  for (unsigned int j = 0;'
p27960
aS'                       j < scratch.fe_support_on_face[face_no].size();'
p27961
aS'                       ++j)'
p27962
aS'                    {'
p27963
aS'                      const unsigned int ii ='
p27964
aS'                        scratch.fe_support_on_face[face_no][i];'
p27965
aS'                      const unsigned int jj ='
p27966
aS'                        scratch.fe_support_on_face[face_no][j];'
p27967
aS'                      task_data.cell_matrix(ii, jj) +='
p27968
aS'                         scratch.tr_phi[j]) *'
p27969
aS'                        JxW;'
p27970
aS'                    }'
p27971
aS'                if (cell->face(face_no)->at_boundary() &&'
p27972
aS'                  {'
p27973
aS'                    const double neumann_value ='
p27974
aS'                      -scratch.exact_solution.gradient(quadrature_point) *'
p27975
aS'                        normal +'
p27976
aS'                      convection * normal *'
p27977
aS'                        scratch.exact_solution.value(quadrature_point);'
p27978
aS'                    for (unsigned int i = 0;'
p27979
aS'                         i < scratch.fe_support_on_face[face_no].size();'
p27980
aS'                         ++i)'
p27981
aS'                      {'
p27982
aS'                        const unsigned int ii ='
p27983
aS'                          scratch.fe_support_on_face[face_no][i];'
p27984
aS'                        task_data.cell_vector(ii) +='
p27985
aS'                          scratch.tr_phi[i] * neumann_value * JxW;'
p27986
aS'                      }'
p27987
aS'                  }'
p27988
aS'              }'
p27989
aS'            for (unsigned int i = 0;'
p27990
aS'                 i < scratch.fe_local_support_on_face[face_no].size();'
p27991
aS'                 ++i)'
p27992
aS'              for (unsigned int j = 0;'
p27993
aS'                   j < scratch.fe_local_support_on_face[face_no].size();'
p27994
aS'                   ++j)'
p27995
aS'                {'
p27996
aS'                  const unsigned int ii ='
p27997
aS'                    scratch.fe_local_support_on_face[face_no][i];'
p27998
aS'                  const unsigned int jj ='
p27999
aS'                    scratch.fe_local_support_on_face[face_no][j];'
p28000
aS'                  scratch.ll_matrix(ii, jj) +='
p28001
aS'                    tau_stab * scratch.u_phi[i] * scratch.u_phi[j] * JxW;'
p28002
aS'                }'
p28003
aS'            if (task_data.trace_reconstruct)'
p28004
aS'              for (unsigned int i = 0;'
p28005
aS'                   i < scratch.fe_local_support_on_face[face_no].size();'
p28006
aS'                   ++i)'
p28007
aS'                {'
p28008
aS'                  const unsigned int ii ='
p28009
aS'                    scratch.fe_local_support_on_face[face_no][i];'
p28010
aS'                  scratch.l_rhs(ii) -='
p28011
aS'                     scratch.u_phi[i] * (convection * normal - tau_stab)) *'
p28012
aS'                    scratch.trace_values[q] * JxW;'
p28013
aS'                }'
p28014
aS'          }'
p28015
aS'      }'
p28016
aS'    scratch.ll_matrix.gauss_jordan();'
p28017
aS'    if (task_data.trace_reconstruct == false)'
p28018
aS'      {'
p28019
aS'        scratch.fl_matrix.mmult(scratch.tmp_matrix, scratch.ll_matrix);'
p28020
aS'        scratch.tmp_matrix.vmult_add(task_data.cell_vector, scratch.l_rhs);'
p28021
aS'        scratch.tmp_matrix.mmult(task_data.cell_matrix,'
p28022
aS'                                 scratch.lf_matrix,'
p28023
aS'                                 true);'
p28024
aS'        cell->get_dof_indices(task_data.dof_indices);'
p28025
aS'      }'
p28026
aS'    else'
p28027
aS'      {'
p28028
aS'        scratch.ll_matrix.vmult(scratch.tmp_rhs, scratch.l_rhs);'
p28029
aS'        loc_cell->set_dof_values(scratch.tmp_rhs, solution_local);'
p28030
aS'      }'
p28031
aS'  }'
p28032
aS'  template <int dim>'
p28033
aS'  void HDG<dim>::copy_local_to_global(const PerTaskData &data)'
p28034
aS'  {'
p28035
aS'    if (data.trace_reconstruct == false)'
p28036
aS'      constraints.distribute_local_to_global(data.cell_matrix,'
p28037
aS'                                             data.cell_vector,'
p28038
aS'                                             data.dof_indices,'
p28039
aS'                                             system_matrix,'
p28040
aS'                                             system_rhs);'
p28041
aS'  }'
p28042
aS'  template <int dim>'
p28043
aS'  void HDG<dim>::solve()'
p28044
aS'  {'
p28045
aS'    SolverControl                  solver_control(system_matrix.m() * 10,'
p28046
aS'                                 1e-11 * system_rhs.l2_norm());'
p28047
aS'    SolverBicgstab<Vector<double>> solver(solver_control);'
p28048
aS'    solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p28049
aS'    std::cout << "   Number of BiCGStab iterations: "'
p28050
aS'              << solver_control.last_step() << std::endl;'
p28051
aS'    system_matrix.clear();'
p28052
aS'    sparsity_pattern.reinit(0, 0, 0, 1);'
p28053
aS'    constraints.distribute(solution);'
p28054
aS'    assemble_system(true);'
p28055
aS'  }'
p28056
aS'  template <int dim>'
p28057
aS'  void HDG<dim>::postprocess()'
p28058
aS'  {'
p28059
aS'    {'
p28060
aS'      const QGauss<dim> quadrature_formula(fe_u_post.degree + 1);'
p28061
aS'      const UpdateFlags local_flags(update_values);'
p28062
aS'      const UpdateFlags flags(update_values | update_gradients |'
p28063
aS'                              update_JxW_values);'
p28064
aS'      PostProcessScratchData scratch('
p28065
aS'        fe_u_post, fe_local, quadrature_formula, local_flags, flags);'
p28066
aS'      WorkStream::run('
p28067
aS'        dof_handler_u_post.begin_active(),'
p28068
aS'        dof_handler_u_post.end(),'
p28069
aS'        [this](const typename DoFHandler<dim>::active_cell_iterator &cell,'
p28070
aS'               PostProcessScratchData &                              scratch,'
p28071
aS'               unsigned int &                                        data) {'
p28072
aS'          this->postprocess_one_cell(cell, scratch, data);'
p28073
aS'        },'
p28074
aS'        std::function<void(const unsigned int &)>(),'
p28075
aS'        scratch,'
p28076
aS'        0U);'
p28077
aS'    }'
p28078
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p28079
aS'    ComponentSelectFunction<dim> value_select(dim, dim + 1);'
p28080
aS'    VectorTools::integrate_difference(dof_handler_local,'
p28081
aS'                                      solution_local,'
p28082
aS'                                      SolutionAndGradient<dim>(),'
p28083
aS'                                      difference_per_cell,'
p28084
aS'                                      QGauss<dim>(fe.degree + 2),'
p28085
aS'                                      VectorTools::L2_norm,'
p28086
aS'                                      &value_select);'
p28087
aS'    const double L2_error ='
p28088
aS'      VectorTools::compute_global_error(triangulation,'
p28089
aS'                                        difference_per_cell,'
p28090
aS'                                        VectorTools::L2_norm);'
p28091
aS'    ComponentSelectFunction<dim> gradient_select('
p28092
aS'      std::pair<unsigned int, unsigned int>(0, dim), dim + 1);'
p28093
aS'    VectorTools::integrate_difference(dof_handler_local,'
p28094
aS'                                      solution_local,'
p28095
aS'                                      SolutionAndGradient<dim>(),'
p28096
aS'                                      difference_per_cell,'
p28097
aS'                                      QGauss<dim>(fe.degree + 2),'
p28098
aS'                                      VectorTools::L2_norm,'
p28099
aS'                                      &gradient_select);'
p28100
aS'    const double grad_error ='
p28101
aS'      VectorTools::compute_global_error(triangulation,'
p28102
aS'                                        difference_per_cell,'
p28103
aS'                                        VectorTools::L2_norm);'
p28104
aS'    VectorTools::integrate_difference(dof_handler_u_post,'
p28105
aS'                                      solution_u_post,'
p28106
aS'                                      Solution<dim>(),'
p28107
aS'                                      difference_per_cell,'
p28108
aS'                                      QGauss<dim>(fe.degree + 3),'
p28109
aS'                                      VectorTools::L2_norm);'
p28110
aS'    const double post_error ='
p28111
aS'      VectorTools::compute_global_error(triangulation,'
p28112
aS'                                        difference_per_cell,'
p28113
aS'                                        VectorTools::L2_norm);'
p28114
aS'    convergence_table.add_value("cells", triangulation.n_active_cells());'
p28115
aS'    convergence_table.add_value("dofs", dof_handler.n_dofs());'
p28116
aS'    convergence_table.add_value("val L2", L2_error);'
p28117
aS'    convergence_table.set_scientific("val L2", true);'
p28118
aS'    convergence_table.set_precision("val L2", 3);'
p28119
aS'    convergence_table.add_value("grad L2", grad_error);'
p28120
aS'    convergence_table.set_scientific("grad L2", true);'
p28121
aS'    convergence_table.set_precision("grad L2", 3);'
p28122
aS'    convergence_table.add_value("val L2-post", post_error);'
p28123
aS'    convergence_table.set_scientific("val L2-post", true);'
p28124
aS'    convergence_table.set_precision("val L2-post", 3);'
p28125
aS'  }'
p28126
aS'  template <int dim>'
p28127
aS'  void HDG<dim>::postprocess_one_cell('
p28128
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p28129
aS'    PostProcessScratchData &                              scratch,'
p28130
aS'    unsigned int &)'
p28131
aS'  {'
p28132
aS'    typename DoFHandler<dim>::active_cell_iterator loc_cell(&triangulation,'
p28133
aS'                                                            cell->level(),'
p28134
aS'                                                            cell->index(),'
p28135
aS'                                                            &dof_handler_local);'
p28136
aS'    scratch.fe_values_local.reinit(loc_cell);'
p28137
aS'    scratch.fe_values.reinit(cell);'
p28138
aS'    FEValuesExtractors::Vector fluxes(0);'
p28139
aS'    FEValuesExtractors::Scalar scalar(dim);'
p28140
aS'    const unsigned int n_q_points = scratch.fe_values.get_quadrature().size();'
p28141
aS'    const unsigned int dofs_per_cell = scratch.fe_values.dofs_per_cell;'
p28142
aS'    scratch.fe_values_local[scalar].get_function_values(solution_local,'
p28143
aS'                                                        scratch.u_values);'
p28144
aS'    scratch.fe_values_local[fluxes].get_function_values(solution_local,'
p28145
aS'                                                        scratch.u_gradients);'
p28146
aS'    double sum = 0;'
p28147
aS'    for (unsigned int i = 1; i < dofs_per_cell; ++i)'
p28148
aS'      {'
p28149
aS'        for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p28150
aS'          {'
p28151
aS'            sum = 0;'
p28152
aS'            for (unsigned int q = 0; q < n_q_points; ++q)'
p28153
aS'              sum += (scratch.fe_values.shape_grad(i, q) *'
p28154
aS'                      scratch.fe_values.shape_grad(j, q)) *'
p28155
aS'                     scratch.fe_values.JxW(q);'
p28156
aS'            scratch.cell_matrix(i, j) = sum;'
p28157
aS'          }'
p28158
aS'        sum = 0;'
p28159
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p28160
aS'          sum -= (scratch.fe_values.shape_grad(i, q) * scratch.u_gradients[q]) *'
p28161
aS'                 scratch.fe_values.JxW(q);'
p28162
aS'        scratch.cell_rhs(i) = sum;'
p28163
aS'      }'
p28164
aS'    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p28165
aS'      {'
p28166
aS'        sum = 0;'
p28167
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p28168
aS'          sum += scratch.fe_values.shape_value(j, q) * scratch.fe_values.JxW(q);'
p28169
aS'        scratch.cell_matrix(0, j) = sum;'
p28170
aS'      }'
p28171
aS'    {'
p28172
aS'      sum = 0;'
p28173
aS'      for (unsigned int q = 0; q < n_q_points; ++q)'
p28174
aS'        sum += scratch.u_values[q] * scratch.fe_values.JxW(q);'
p28175
aS'      scratch.cell_rhs(0) = sum;'
p28176
aS'    }'
p28177
aS'    scratch.cell_matrix.gauss_jordan();'
p28178
aS'    scratch.cell_matrix.vmult(scratch.cell_sol, scratch.cell_rhs);'
p28179
aS'    cell->distribute_local_to_global(scratch.cell_sol, solution_u_post);'
p28180
aS'  }'
p28181
aS'  template <int dim>'
p28182
aS'  void HDG<dim>::output_results(const unsigned int cycle)'
p28183
aS'  {'
p28184
aS'    std::string filename;'
p28185
aS'    switch (refinement_mode)'
p28186
aS'      {'
p28187
aS'        case global_refinement:'
p28188
aS'          filename = "solution-global";'
p28189
aS'          break;'
p28190
aS'        case adaptive_refinement:'
p28191
aS'          filename = "solution-adaptive";'
p28192
aS'          break;'
p28193
aS'        default:'
p28194
aS'          Assert(false, ExcNotImplemented());'
p28195
aS'      }'
p28196
aS'    std::string face_out(filename);'
p28197
aS'    face_out += "-face";'
p28198
aS'    filename += "-q" + Utilities::int_to_string(fe.degree, 1);'
p28199
aS'    filename += "-" + Utilities::int_to_string(cycle, 2);'
p28200
aS'    filename += ".vtk";'
p28201
aS'    std::ofstream output(filename);'
p28202
aS'    DataOut<dim> data_out;'
p28203
aS'    std::vector<std::string> names(dim, "gradient");'
p28204
aS'    names.emplace_back("solution");'
p28205
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p28206
aS'      component_interpretation('
p28207
aS'        dim + 1, DataComponentInterpretation::component_is_part_of_vector);'
p28208
aS'    component_interpretation[dim] ='
p28209
aS'      DataComponentInterpretation::component_is_scalar;'
p28210
aS'    data_out.add_data_vector(dof_handler_local,'
p28211
aS'                             solution_local,'
p28212
aS'                             names,'
p28213
aS'                             component_interpretation);'
p28214
aS'    std::vector<std::string> post_name(1, "u_post");'
p28215
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p28216
aS'      post_comp_type(1, DataComponentInterpretation::component_is_scalar);'
p28217
aS'    data_out.add_data_vector(dof_handler_u_post,'
p28218
aS'                             solution_u_post,'
p28219
aS'                             post_name,'
p28220
aS'                             post_comp_type);'
p28221
aS'    data_out.build_patches(fe.degree);'
p28222
aS'    data_out.write_vtk(output);'
p28223
aS'    face_out += "-q" + Utilities::int_to_string(fe.degree, 1);'
p28224
aS'    face_out += "-" + Utilities::int_to_string(cycle, 2);'
p28225
aS'    face_out += ".vtk";'
p28226
aS'    std::ofstream face_output(face_out);'
p28227
aS'    DataOutFaces<dim>        data_out_face(false);'
p28228
aS'    std::vector<std::string> face_name(1, "u_hat");'
p28229
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p28230
aS'      face_component_type(1, DataComponentInterpretation::component_is_scalar);'
p28231
aS'    data_out_face.add_data_vector(dof_handler,'
p28232
aS'                                  solution,'
p28233
aS'                                  face_name,'
p28234
aS'                                  face_component_type);'
p28235
aS'    data_out_face.build_patches(fe.degree);'
p28236
aS'    data_out_face.write_vtk(face_output);'
p28237
aS'  }'
p28238
aS'  template <int dim>'
p28239
aS'  void HDG<dim>::refine_grid(const unsigned int cycle)'
p28240
aS'  {'
p28241
aS'    if (cycle == 0)'
p28242
aS'      {'
p28243
aS'        GridGenerator::subdivided_hyper_cube(triangulation, 2, -1, 1);'
p28244
aS'        triangulation.refine_global(3 - dim);'
p28245
aS'      }'
p28246
aS'    else'
p28247
aS'      switch (refinement_mode)'
p28248
aS'        {'
p28249
aS'          case global_refinement:'
p28250
aS'            {'
p28251
aS'              triangulation.clear();'
p28252
aS'              GridGenerator::subdivided_hyper_cube(triangulation,'
p28253
aS'                                                   2 + (cycle % 2),'
p28254
aS'                                                   -1,'
p28255
aS'                                                   1);'
p28256
aS'              triangulation.refine_global(3 - dim + cycle / 2);'
p28257
aS'              break;'
p28258
aS'            }'
p28259
aS'          case adaptive_refinement:'
p28260
aS'            {'
p28261
aS'              Vector<float> estimated_error_per_cell('
p28262
aS'                triangulation.n_active_cells());'
p28263
aS'              FEValuesExtractors::Scalar scalar(dim);'
p28264
aS'              std::map<types::boundary_id, const Function<dim> *>'
p28265
aS'                neumann_boundary;'
p28266
aS'              KellyErrorEstimator<dim>::estimate(dof_handler_local,'
p28267
aS'                                                 QGauss<dim - 1>(fe.degree + 1),'
p28268
aS'                                                 neumann_boundary,'
p28269
aS'                                                 solution_local,'
p28270
aS'                                                 estimated_error_per_cell,'
p28271
aS'                                                 fe_local.component_mask('
p28272
aS'                                                   scalar));'
p28273
aS'              GridRefinement::refine_and_coarsen_fixed_number('
p28274
aS'                triangulation, estimated_error_per_cell, 0.3, 0.);'
p28275
aS'              triangulation.execute_coarsening_and_refinement();'
p28276
aS'              break;'
p28277
aS'            }'
p28278
aS'          default:'
p28279
aS'            {'
p28280
aS'              Assert(false, ExcNotImplemented());'
p28281
aS'            }'
p28282
aS'        }'
p28283
aS'    for (const auto &cell : triangulation.cell_iterators())'
p28284
aS'      for (const auto &face : cell->face_iterators())'
p28285
aS'        if (face->at_boundary())'
p28286
aS'          if ((std::fabs(face->center()(0) - (-1)) < 1e-12) ||'
p28287
aS'            face->set_boundary_id(1);'
p28288
aS'  }'
p28289
aS'  template <int dim>'
p28290
aS'  void HDG<dim>::run()'
p28291
aS'  {'
p28292
aS'    for (unsigned int cycle = 0; cycle < 10; ++cycle)'
p28293
aS'      {'
p28294
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p28295
aS'        refine_grid(cycle);'
p28296
aS'        setup_system();'
p28297
aS'        assemble_system(false);'
p28298
aS'        solve();'
p28299
aS'        postprocess();'
p28300
aS'        output_results(cycle);'
p28301
aS'      }'
p28302
aS'    if (refinement_mode == global_refinement)'
p28303
aS'      {'
p28304
aS'        convergence_table.evaluate_convergence_rates('
p28305
aS'          "val L2", "cells", ConvergenceTable::reduction_rate_log2, dim);'
p28306
aS'        convergence_table.evaluate_convergence_rates('
p28307
aS'          "grad L2", "cells", ConvergenceTable::reduction_rate_log2, dim);'
p28308
aS'        convergence_table.evaluate_convergence_rates('
p28309
aS'          "val L2-post", "cells", ConvergenceTable::reduction_rate_log2, dim);'
p28310
aS'      }'
p28311
aS'    convergence_table.write_text(std::cout);'
p28312
aS'  }'
p28313
aS'} // end of namespace Step51'
p28314
aS'int main()'
p28315
ag9
aS'  const unsigned int dim = 2;'
p28316
aS'  try'
p28317
aS'    {'
p28318
aS'      {'
p28319
aS'        std::cout << "Solving with Q1 elements, adaptive refinement"'
p28320
aS'                  << std::endl'
p28321
aS'                  << "============================================="'
p28322
aS'                  << std::endl'
p28323
aS'                  << std::endl;'
p28324
aS'        Step51::HDG<dim> hdg_problem(1, Step51::HDG<dim>::adaptive_refinement);'
p28325
aS'        hdg_problem.run();'
p28326
aS'        std::cout << std::endl;'
p28327
aS'      }'
p28328
aS'      {'
p28329
aS'        std::cout << "Solving with Q1 elements, global refinement" << std::endl'
p28330
aS'                  << "===========================================" << std::endl'
p28331
aS'                  << std::endl;'
p28332
aS'        Step51::HDG<dim> hdg_problem(1, Step51::HDG<dim>::global_refinement);'
p28333
aS'        hdg_problem.run();'
p28334
aS'        std::cout << std::endl;'
p28335
aS'      }'
p28336
aS'      {'
p28337
aS'        std::cout << "Solving with Q3 elements, global refinement" << std::endl'
p28338
aS'                  << "===========================================" << std::endl'
p28339
aS'                  << std::endl;'
p28340
aS'        Step51::HDG<dim> hdg_problem(3, Step51::HDG<dim>::global_refinement);'
p28341
aS'        hdg_problem.run();'
p28342
aS'        std::cout << std::endl;'
p28343
aS'      }'
p28344
aS'    }'
p28345
aS'  catch (std::exception &exc)'
p28346
aS'    {'
p28347
aS'      std::cerr << std::endl'
p28348
aS'                << std::endl'
p28349
aS'                << "----------------------------------------------------"'
p28350
aS'                << std::endl;'
p28351
aS'      std::cerr << "Exception on processing: " << std::endl'
p28352
aS'                << exc.what() << std::endl'
p28353
aS'                << "Aborting!" << std::endl'
p28354
aS'                << "----------------------------------------------------"'
p28355
aS'                << std::endl;'
p28356
aS'      return 1;'
p28357
aS'    }'
p28358
aS'  catch (...)'
p28359
aS'    {'
p28360
aS'      std::cerr << std::endl'
p28361
aS'                << std::endl'
p28362
aS'                << "----------------------------------------------------"'
p28363
aS'                << std::endl;'
p28364
aS'      std::cerr << "Unknown exception!" << std::endl'
p28365
aS'                << "Aborting!" << std::endl'
p28366
aS'                << "----------------------------------------------------"'
p28367
aS'                << std::endl;'
p28368
aS'      return 1;'
p28369
aS'    }'
p28370
aS'  return 0;'
p28371
ag17
aS'#include <deal.II/base/discrete_time.h>'
p28372
aS'#include <deal.II/base/function.h>'
p28373
aS'#include <deal.II/base/quadrature_lib.h>'
p28374
aS'#include <deal.II/grid/grid_generator.h>'
p28375
aS'#include <deal.II/grid/tria.h>'
p28376
aS'#include <deal.II/grid/grid_out.h>'
p28377
aS'#include <deal.II/dofs/dof_handler.h>'
p28378
aS'#include <deal.II/dofs/dof_tools.h>'
p28379
aS'#include <deal.II/fe/fe_q.h>'
p28380
aS'#include <deal.II/fe/fe_values.h>'
p28381
aS'#include <deal.II/lac/affine_constraints.h>'
p28382
aS'#include <deal.II/lac/sparse_direct.h>'
p28383
aS'#include <deal.II/numerics/vector_tools.h>'
p28384
aS'#include <deal.II/numerics/data_out.h>'
p28385
aS'#include <fstream>'
p28386
aS'#include <iostream>'
p28387
aS'#include <cmath>'
p28388
aS'#include <map>'
p28389
aS'#include <deal.II/base/time_stepping.h>'
p28390
aS'namespace Step52'
p28391
ag9
aS'  using namespace dealii;'
p28392
aS'  class Diffusion'
p28393
aS'  {'
p28394
aS'  public:'
p28395
aS'    Diffusion();'
p28396
aS'    void run();'
p28397
aS'  private:'
p28398
aS'    void setup_system();'
p28399
aS'    void assemble_system();'
p28400
aS'    double get_source(const double time, const Point<2> &point) const;'
p28401
aS'    Vector<double> evaluate_diffusion(const double          time,'
p28402
aS'                                      const Vector<double> &y) const;'
p28403
aS'    Vector<double> id_minus_tau_J_inverse(const double          time,'
p28404
aS'                                          const double          tau,'
p28405
aS'                                          const Vector<double> &y);'
p28406
aS'    void output_results(const double                     time,'
p28407
aS'                        const unsigned int               time_step,'
p28408
aS'                        TimeStepping::runge_kutta_method method) const;'
p28409
aS'    void explicit_method(const TimeStepping::runge_kutta_method method,'
p28410
aS'                         const unsigned int                     n_time_steps,'
p28411
aS'                         const double                           initial_time,'
p28412
aS'                         const double                           final_time);'
p28413
aS'    void implicit_method(const TimeStepping::runge_kutta_method method,'
p28414
aS'                         const unsigned int                     n_time_steps,'
p28415
aS'                         const double                           initial_time,'
p28416
aS'                         const double                           final_time);'
p28417
aS'    unsigned int'
p28418
aS'    embedded_explicit_method(const TimeStepping::runge_kutta_method method,'
p28419
aS'                             const unsigned int n_time_steps,'
p28420
aS'                             const double       initial_time,'
p28421
aS'                             const double       final_time);'
p28422
aS'    const unsigned int fe_degree;'
p28423
aS'    const double diffusion_coefficient;'
p28424
aS'    const double absorption_cross_section;'
p28425
aS'    Triangulation<2> triangulation;'
p28426
aS'    const FE_Q<2> fe;'
p28427
aS'    DoFHandler<2> dof_handler;'
p28428
aS'    AffineConstraints<double> constraint_matrix;'
p28429
aS'    SparsityPattern sparsity_pattern;'
p28430
aS'    SparseMatrix<double> system_matrix;'
p28431
aS'    SparseMatrix<double> mass_matrix;'
p28432
aS'    SparseMatrix<double> mass_minus_tau_Jacobian;'
p28433
aS'    SparseDirectUMFPACK inverse_mass_matrix;'
p28434
aS'    Vector<double> solution;'
p28435
aS'  };'
p28436
aS'  Diffusion::Diffusion()'
p28437
aS'    : fe_degree(2)'
p28438
aS'    , diffusion_coefficient(1. / 30.)'
p28439
aS'    , absorption_cross_section(1.)'
p28440
aS'    , fe(fe_degree)'
p28441
aS'    , dof_handler(triangulation)'
p28442
aS'  {}'
p28443
aS'  void Diffusion::setup_system()'
p28444
aS'  {'
p28445
aS'    dof_handler.distribute_dofs(fe);'
p28446
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p28447
aS'                                             1,'
p28448
aS'                                             Functions::ZeroFunction<2>(),'
p28449
aS'                                             constraint_matrix);'
p28450
aS'    constraint_matrix.close();'
p28451
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p28452
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraint_matrix);'
p28453
aS'    sparsity_pattern.copy_from(dsp);'
p28454
aS'    system_matrix.reinit(sparsity_pattern);'
p28455
aS'    mass_matrix.reinit(sparsity_pattern);'
p28456
aS'    mass_minus_tau_Jacobian.reinit(sparsity_pattern);'
p28457
aS'    solution.reinit(dof_handler.n_dofs());'
p28458
aS'  }'
p28459
aS'  void Diffusion::assemble_system()'
p28460
aS'  {'
p28461
aS'    system_matrix = 0.;'
p28462
aS'    mass_matrix   = 0.;'
p28463
aS'    const QGauss<2> quadrature_formula(fe_degree + 1);'
p28464
aS'    FEValues<2> fe_values(fe,'
p28465
aS'                          quadrature_formula,'
p28466
aS'                          update_values | update_gradients | update_JxW_values);'
p28467
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p28468
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p28469
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p28470
aS'    FullMatrix<double> cell_mass_matrix(dofs_per_cell, dofs_per_cell);'
p28471
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p28472
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p28473
aS'      {'
p28474
aS'        cell_matrix      = 0.;'
p28475
aS'        cell_mass_matrix = 0.;'
p28476
aS'        fe_values.reinit(cell);'
p28477
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p28478
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p28479
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p28480
aS'              {'
p28481
aS'                cell_matrix(i, j) +='
p28482
aS'                      fe_values.shape_grad(i, q_point) *    //  * grad phi_i'
p28483
aS'                      fe_values.shape_grad(j, q_point)      //  * grad phi_j'
p28484
aS'                    - absorption_cross_section *            //  -Sigma'
p28485
aS'                        fe_values.shape_value(i, q_point) * //  * phi_i'
p28486
aS'                        fe_values.shape_value(j, q_point))  //  * phi_j)'
p28487
aS'                cell_mass_matrix(i, j) += fe_values.shape_value(i, q_point) *'
p28488
aS'                                          fe_values.shape_value(j, q_point) *'
p28489
aS'                                          fe_values.JxW(q_point);'
p28490
aS'              }'
p28491
aS'        cell->get_dof_indices(local_dof_indices);'
p28492
aS'        constraint_matrix.distribute_local_to_global(cell_matrix,'
p28493
aS'                                                     local_dof_indices,'
p28494
aS'                                                     system_matrix);'
p28495
aS'        constraint_matrix.distribute_local_to_global(cell_mass_matrix,'
p28496
aS'                                                     local_dof_indices,'
p28497
aS'                                                     mass_matrix);'
p28498
aS'      }'
p28499
aS'    inverse_mass_matrix.initialize(mass_matrix);'
p28500
aS'  }'
p28501
aS'  double Diffusion::get_source(const double time, const Point<2> &point) const'
p28502
aS'  {'
p28503
aS'    const double intensity = 10.;'
p28504
aS'    const double frequency = numbers::PI / 10.;'
p28505
aS'    const double b         = 5.;'
p28506
aS'    const double x         = point(0);'
p28507
aS'    return intensity *'
p28508
aS'            std::sin(frequency * time) *'
p28509
aS'               2. * diffusion_coefficient));'
p28510
aS'  }'
p28511
aS'  Vector<double> Diffusion::evaluate_diffusion(const double          time,'
p28512
aS'                                               const Vector<double> &y) const'
p28513
aS'  {'
p28514
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p28515
aS'    tmp = 0.;'
p28516
aS'    system_matrix.vmult(tmp, y);'
p28517
aS'    const QGauss<2> quadrature_formula(fe_degree + 1);'
p28518
aS'    FEValues<2> fe_values(fe,'
p28519
aS'                          quadrature_formula,'
p28520
aS'                          update_values | update_quadrature_points |'
p28521
aS'                            update_JxW_values);'
p28522
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p28523
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p28524
aS'    Vector<double> cell_source(dofs_per_cell);'
p28525
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p28526
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p28527
aS'      {'
p28528
aS'        cell_source = 0.;'
p28529
aS'        fe_values.reinit(cell);'
p28530
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p28531
aS'          {'
p28532
aS'            const double source ='
p28533
aS'              get_source(time, fe_values.quadrature_point(q_point));'
p28534
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p28535
aS'              cell_source(i) += fe_values.shape_value(i, q_point) * // phi_i(x)'
p28536
aS'                                source *                            // * S(x)'
p28537
aS'                                fe_values.JxW(q_point);             // * dx'
p28538
aS'          }'
p28539
aS'        cell->get_dof_indices(local_dof_indices);'
p28540
aS'        constraint_matrix.distribute_local_to_global(cell_source,'
p28541
aS'                                                     local_dof_indices,'
p28542
aS'                                                     tmp);'
p28543
aS'      }'
p28544
aS'    Vector<double> value(dof_handler.n_dofs());'
p28545
aS'    inverse_mass_matrix.vmult(value, tmp);'
p28546
aS'    return value;'
p28547
aS'  }'
p28548
aS'  Vector<double> Diffusion::id_minus_tau_J_inverse(const double /*time*/,'
p28549
aS'                                                   const double          tau,'
p28550
aS'                                                   const Vector<double> &y)'
p28551
aS'  {'
p28552
aS'    SparseDirectUMFPACK inverse_mass_minus_tau_Jacobian;'
p28553
aS'    mass_minus_tau_Jacobian.copy_from(mass_matrix);'
p28554
aS'    mass_minus_tau_Jacobian.add(-tau, system_matrix);'
p28555
aS'    inverse_mass_minus_tau_Jacobian.initialize(mass_minus_tau_Jacobian);'
p28556
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p28557
aS'    mass_matrix.vmult(tmp, y);'
p28558
aS'    Vector<double> result(y);'
p28559
aS'    inverse_mass_minus_tau_Jacobian.vmult(result, tmp);'
p28560
aS'    return result;'
p28561
aS'  }'
p28562
aS'  void Diffusion::output_results(const double                     time,'
p28563
aS'                                 const unsigned int               time_step,'
p28564
aS'                                 TimeStepping::runge_kutta_method method) const'
p28565
aS'  {'
p28566
aS'    std::string method_name;'
p28567
aS'    switch (method)'
p28568
aS'      {'
p28569
aS'        case TimeStepping::FORWARD_EULER:'
p28570
aS'          {'
p28571
aS'            method_name = "forward_euler";'
p28572
aS'            break;'
p28573
aS'          }'
p28574
aS'        case TimeStepping::RK_THIRD_ORDER:'
p28575
aS'          {'
p28576
aS'            method_name = "rk3";'
p28577
aS'            break;'
p28578
aS'          }'
p28579
aS'        case TimeStepping::RK_CLASSIC_FOURTH_ORDER:'
p28580
aS'          {'
p28581
aS'            method_name = "rk4";'
p28582
aS'            break;'
p28583
aS'          }'
p28584
aS'        case TimeStepping::BACKWARD_EULER:'
p28585
aS'          {'
p28586
aS'            method_name = "backward_euler";'
p28587
aS'            break;'
p28588
aS'          }'
p28589
aS'        case TimeStepping::IMPLICIT_MIDPOINT:'
p28590
aS'          {'
p28591
aS'            method_name = "implicit_midpoint";'
p28592
aS'            break;'
p28593
aS'          }'
p28594
aS'        case TimeStepping::SDIRK_TWO_STAGES:'
p28595
aS'          {'
p28596
aS'            method_name = "sdirk";'
p28597
aS'            break;'
p28598
aS'          }'
p28599
aS'        case TimeStepping::HEUN_EULER:'
p28600
aS'          {'
p28601
aS'            method_name = "heun_euler";'
p28602
aS'            break;'
p28603
aS'          }'
p28604
aS'        case TimeStepping::BOGACKI_SHAMPINE:'
p28605
aS'          {'
p28606
aS'            method_name = "bocacki_shampine";'
p28607
aS'            break;'
p28608
aS'          }'
p28609
aS'        case TimeStepping::DOPRI:'
p28610
aS'          {'
p28611
aS'            method_name = "dopri";'
p28612
aS'            break;'
p28613
aS'          }'
p28614
aS'        case TimeStepping::FEHLBERG:'
p28615
aS'          {'
p28616
aS'            method_name = "fehlberg";'
p28617
aS'            break;'
p28618
aS'          }'
p28619
aS'        case TimeStepping::CASH_KARP:'
p28620
aS'          {'
p28621
aS'            method_name = "cash_karp";'
p28622
aS'            break;'
p28623
aS'          }'
p28624
aS'        default:'
p28625
aS'          {'
p28626
aS'            break;'
p28627
aS'          }'
p28628
aS'      }'
p28629
aS'    DataOut<2> data_out;'
p28630
aS'    data_out.attach_dof_handler(dof_handler);'
p28631
aS'    data_out.add_data_vector(solution, "solution");'
p28632
aS'    data_out.build_patches();'
p28633
aS'    data_out.set_flags(DataOutBase::VtkFlags(time, time_step));'
p28634
aS'    const std::string filename = "solution_" + method_name + "-" +'
p28635
aS'                                 Utilities::int_to_string(time_step, 3) +'
p28636
aS'                                 ".vtu";'
p28637
aS'    std::ofstream output(filename);'
p28638
aS'    data_out.write_vtu(output);'
p28639
aS'    static std::vector<std::pair<double, std::string>> times_and_names;'
p28640
aS'    static std::string method_name_prev = "";'
p28641
aS'    static std::string pvd_filename;'
p28642
aS'    if (method_name_prev != method_name)'
p28643
aS'      {'
p28644
aS'        times_and_names.clear();'
p28645
aS'        method_name_prev = method_name;'
p28646
aS'        pvd_filename     = "solution_" + method_name + ".pvd";'
p28647
aS'      }'
p28648
aS'    times_and_names.emplace_back(time, filename);'
p28649
aS'    std::ofstream pvd_output(pvd_filename);'
p28650
aS'    DataOutBase::write_pvd_record(pvd_output, times_and_names);'
p28651
aS'  }'
p28652
aS'  void Diffusion::explicit_method(const TimeStepping::runge_kutta_method method,'
p28653
aS'                                  const unsigned int n_time_steps,'
p28654
aS'                                  const double       initial_time,'
p28655
aS'                                  const double       final_time)'
p28656
aS'  {'
p28657
aS'    const double time_step ='
p28658
aS'    solution = 0.;'
p28659
aS'    constraint_matrix.distribute(solution);'
p28660
aS'    TimeStepping::ExplicitRungeKutta<Vector<double>> explicit_runge_kutta('
p28661
aS'      method);'
p28662
aS'    output_results(initial_time, 0, method);'
p28663
aS'    DiscreteTime time(initial_time, final_time, time_step);'
p28664
aS'    while (time.is_at_end() == false)'
p28665
aS'      {'
p28666
aS'        explicit_runge_kutta.evolve_one_time_step('
p28667
aS'          [this](const double time, const Vector<double> &y) {'
p28668
aS'            return this->evaluate_diffusion(time, y);'
p28669
aS'          },'
p28670
aS'          time.get_current_time(),'
p28671
aS'          time.get_next_step_size(),'
p28672
aS'          solution);'
p28673
aS'        time.advance_time();'
p28674
aS'        constraint_matrix.distribute(solution);'
p28675
aS'        if (time.get_step_number() % 10 == 0)'
p28676
aS'          output_results(time.get_current_time(),'
p28677
aS'                         time.get_step_number(),'
p28678
aS'                         method);'
p28679
aS'      }'
p28680
aS'  }'
p28681
aS'  void Diffusion::implicit_method(const TimeStepping::runge_kutta_method method,'
p28682
aS'                                  const unsigned int n_time_steps,'
p28683
aS'                                  const double       initial_time,'
p28684
aS'                                  const double       final_time)'
p28685
aS'  {'
p28686
aS'    const double time_step ='
p28687
aS'    solution = 0.;'
p28688
aS'    constraint_matrix.distribute(solution);'
p28689
aS'    TimeStepping::ImplicitRungeKutta<Vector<double>> implicit_runge_kutta('
p28690
aS'      method);'
p28691
aS'    output_results(initial_time, 0, method);'
p28692
aS'    DiscreteTime time(initial_time, final_time, time_step);'
p28693
aS'    while (time.is_at_end() == false)'
p28694
aS'      {'
p28695
aS'        implicit_runge_kutta.evolve_one_time_step('
p28696
aS'          [this](const double time, const Vector<double> &y) {'
p28697
aS'            return this->evaluate_diffusion(time, y);'
p28698
aS'          },'
p28699
aS'          [this](const double time, const double tau, const Vector<double> &y) {'
p28700
aS'            return this->id_minus_tau_J_inverse(time, tau, y);'
p28701
aS'          },'
p28702
aS'          time.get_current_time(),'
p28703
aS'          time.get_next_step_size(),'
p28704
aS'          solution);'
p28705
aS'        time.advance_time();'
p28706
aS'        constraint_matrix.distribute(solution);'
p28707
aS'        if (time.get_step_number() % 10 == 0)'
p28708
aS'          output_results(time.get_current_time(),'
p28709
aS'                         time.get_step_number(),'
p28710
aS'                         method);'
p28711
aS'      }'
p28712
aS'  }'
p28713
aS'  unsigned int Diffusion::embedded_explicit_method('
p28714
aS'    const TimeStepping::runge_kutta_method method,'
p28715
aS'    const unsigned int                     n_time_steps,'
p28716
aS'    const double                           initial_time,'
p28717
aS'    const double                           final_time)'
p28718
aS'  {'
p28719
aS'    const double time_step ='
p28720
aS'    const double coarsen_param = 1.2;'
p28721
aS'    const double refine_param  = 0.8;'
p28722
aS'    const double min_delta     = 1e-8;'
p28723
aS'    const double max_delta     = 10 * time_step;'
p28724
aS'    const double refine_tol    = 1e-1;'
p28725
aS'    const double coarsen_tol   = 1e-5;'
p28726
aS'    solution = 0.;'
p28727
aS'    constraint_matrix.distribute(solution);'
p28728
aS'    TimeStepping::EmbeddedExplicitRungeKutta<Vector<double>>'
p28729
aS'      embedded_explicit_runge_kutta(method,'
p28730
aS'                                    coarsen_param,'
p28731
aS'                                    refine_param,'
p28732
aS'                                    min_delta,'
p28733
aS'                                    max_delta,'
p28734
aS'                                    refine_tol,'
p28735
aS'                                    coarsen_tol);'
p28736
aS'    output_results(initial_time, 0, method);'
p28737
aS'    DiscreteTime time(initial_time, final_time, time_step);'
p28738
aS'    while (time.is_at_end() == false)'
p28739
aS'      {'
p28740
aS'        const double new_time ='
p28741
aS'          embedded_explicit_runge_kutta.evolve_one_time_step('
p28742
aS'            [this](const double time, const Vector<double> &y) {'
p28743
aS'              return this->evaluate_diffusion(time, y);'
p28744
aS'            },'
p28745
aS'            time.get_current_time(),'
p28746
aS'            time.get_next_step_size(),'
p28747
aS'            solution);'
p28748
aS'        time.set_next_step_size(new_time - time.get_current_time());'
p28749
aS'        time.advance_time();'
p28750
aS'        constraint_matrix.distribute(solution);'
p28751
aS'        if (time.get_step_number() % 10 == 0)'
p28752
aS'          output_results(time.get_current_time(),'
p28753
aS'                         time.get_step_number(),'
p28754
aS'                         method);'
p28755
aS'        time.set_desired_next_step_size('
p28756
aS'          embedded_explicit_runge_kutta.get_status().delta_t_guess);'
p28757
aS'      }'
p28758
aS'    return time.get_step_number();'
p28759
aS'  }'
p28760
aS'  void Diffusion::run()'
p28761
aS'  {'
p28762
aS'    GridGenerator::hyper_cube(triangulation, 0., 5.);'
p28763
aS'    triangulation.refine_global(4);'
p28764
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p28765
aS'      for (const auto &face : cell->face_iterators())'
p28766
aS'        if (face->at_boundary())'
p28767
aS'          {'
p28768
aS'            if ((face->center()[0] == 0.) || (face->center()[0] == 5.))'
p28769
aS'              face->set_boundary_id(1);'
p28770
aS'            else'
p28771
aS'              face->set_boundary_id(0);'
p28772
aS'          }'
p28773
aS'    setup_system();'
p28774
aS'    assemble_system();'
p28775
aS'    unsigned int       n_steps      = 0;'
p28776
aS'    const unsigned int n_time_steps = 200;'
p28777
aS'    const double       initial_time = 0.;'
p28778
aS'    const double       final_time   = 10.;'
p28779
aS'    std::cout << "Explicit methods:" << std::endl;'
p28780
aS'    explicit_method(TimeStepping::FORWARD_EULER,'
p28781
aS'                    n_time_steps,'
p28782
aS'                    initial_time,'
p28783
aS'                    final_time);'
p28784
aS'    std::cout << "   Forward Euler:            error=" << solution.l2_norm()'
p28785
aS'              << std::endl;'
p28786
aS'    explicit_method(TimeStepping::RK_THIRD_ORDER,'
p28787
aS'                    n_time_steps,'
p28788
aS'                    initial_time,'
p28789
aS'                    final_time);'
p28790
aS'    std::cout << "   Third order Runge-Kutta:  error=" << solution.l2_norm()'
p28791
aS'              << std::endl;'
p28792
aS'    explicit_method(TimeStepping::RK_CLASSIC_FOURTH_ORDER,'
p28793
aS'                    n_time_steps,'
p28794
aS'                    initial_time,'
p28795
aS'                    final_time);'
p28796
aS'    std::cout << "   Fourth order Runge-Kutta: error=" << solution.l2_norm()'
p28797
aS'              << std::endl;'
p28798
aS'    std::cout << std::endl;'
p28799
aS'    std::cout << "Implicit methods:" << std::endl;'
p28800
aS'    implicit_method(TimeStepping::BACKWARD_EULER,'
p28801
aS'                    n_time_steps,'
p28802
aS'                    initial_time,'
p28803
aS'                    final_time);'
p28804
aS'    std::cout << "   Backward Euler:           error=" << solution.l2_norm()'
p28805
aS'              << std::endl;'
p28806
aS'    implicit_method(TimeStepping::IMPLICIT_MIDPOINT,'
p28807
aS'                    n_time_steps,'
p28808
aS'                    initial_time,'
p28809
aS'                    final_time);'
p28810
aS'    std::cout << "   Implicit Midpoint:        error=" << solution.l2_norm()'
p28811
aS'              << std::endl;'
p28812
aS'    implicit_method(TimeStepping::CRANK_NICOLSON,'
p28813
aS'                    n_time_steps,'
p28814
aS'                    initial_time,'
p28815
aS'                    final_time);'
p28816
aS'    std::cout << "   Crank-Nicolson:           error=" << solution.l2_norm()'
p28817
aS'              << std::endl;'
p28818
aS'    implicit_method(TimeStepping::SDIRK_TWO_STAGES,'
p28819
aS'                    n_time_steps,'
p28820
aS'                    initial_time,'
p28821
aS'                    final_time);'
p28822
aS'    std::cout << "   SDIRK:                    error=" << solution.l2_norm()'
p28823
aS'              << std::endl;'
p28824
aS'    std::cout << std::endl;'
p28825
aS'    std::cout << "Embedded explicit methods:" << std::endl;'
p28826
aS'    n_steps = embedded_explicit_method(TimeStepping::HEUN_EULER,'
p28827
aS'                                       n_time_steps,'
p28828
aS'                                       initial_time,'
p28829
aS'                                       final_time);'
p28830
aS'    std::cout << "   Heun-Euler:               error=" << solution.l2_norm()'
p28831
aS'              << std::endl;'
p28832
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p28833
aS'    n_steps = embedded_explicit_method(TimeStepping::BOGACKI_SHAMPINE,'
p28834
aS'                                       n_time_steps,'
p28835
aS'                                       initial_time,'
p28836
aS'                                       final_time);'
p28837
aS'    std::cout << "   Bogacki-Shampine:         error=" << solution.l2_norm()'
p28838
aS'              << std::endl;'
p28839
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p28840
aS'    n_steps = embedded_explicit_method(TimeStepping::DOPRI,'
p28841
aS'                                       n_time_steps,'
p28842
aS'                                       initial_time,'
p28843
aS'                                       final_time);'
p28844
aS'    std::cout << "   Dopri:                    error=" << solution.l2_norm()'
p28845
aS'              << std::endl;'
p28846
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p28847
aS'    n_steps = embedded_explicit_method(TimeStepping::FEHLBERG,'
p28848
aS'                                       n_time_steps,'
p28849
aS'                                       initial_time,'
p28850
aS'                                       final_time);'
p28851
aS'    std::cout << "   Fehlberg:                 error=" << solution.l2_norm()'
p28852
aS'              << std::endl;'
p28853
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p28854
aS'    n_steps = embedded_explicit_method(TimeStepping::CASH_KARP,'
p28855
aS'                                       n_time_steps,'
p28856
aS'                                       initial_time,'
p28857
aS'                                       final_time);'
p28858
aS'    std::cout << "   Cash-Karp:                error=" << solution.l2_norm()'
p28859
aS'              << std::endl;'
p28860
aS'    std::cout << "                   steps performed=" << n_steps << std::endl;'
p28861
aS'  }'
p28862
aS'} // namespace Step52'
p28863
aS'int main()'
p28864
ag9
aS'  try'
p28865
aS'    {'
p28866
aS'      Step52::Diffusion diffusion;'
p28867
aS'      diffusion.run();'
p28868
aS'    }'
p28869
aS'  catch (std::exception &exc)'
p28870
aS'    {'
p28871
aS'      std::cerr << std::endl'
p28872
aS'                << std::endl'
p28873
aS'                << "----------------------------------------------------"'
p28874
aS'                << std::endl;'
p28875
aS'      std::cerr << "Exception on processing: " << std::endl'
p28876
aS'                << exc.what() << std::endl'
p28877
aS'                << "Aborting!" << std::endl'
p28878
aS'                << "----------------------------------------------------"'
p28879
aS'                << std::endl;'
p28880
aS'      return 1;'
p28881
aS'    }'
p28882
aS'  catch (...)'
p28883
aS'    {'
p28884
aS'      std::cerr << std::endl'
p28885
aS'                << std::endl'
p28886
aS'                << "----------------------------------------------------"'
p28887
aS'                << std::endl;'
p28888
aS'      std::cerr << "Unknown exception!" << std::endl'
p28889
aS'                << "Aborting!" << std::endl'
p28890
aS'                << "----------------------------------------------------"'
p28891
aS'                << std::endl;'
p28892
aS'      return 1;'
p28893
aS'    };'
p28894
aS'  return 0;'
p28895
ag17
aS'#include <deal.II/grid/tria.h>'
p28896
aS'#include <deal.II/grid/grid_generator.h>'
p28897
aS'#include <deal.II/grid/grid_out.h>'
p28898
aS'#include <deal.II/grid/manifold.h>'
p28899
aS'#include <deal.II/grid/grid_tools.h>'
p28900
aS'#include <deal.II/base/function_lib.h>'
p28901
aS'#include <boost/iostreams/filtering_stream.hpp>'
p28902
aS'#include <boost/iostreams/filter/gzip.hpp>'
p28903
aS'#include <boost/iostreams/device/file.hpp>'
p28904
aS'#include <fstream>'
p28905
aS'#include <iostream>'
p28906
aS'#include <memory>'
p28907
aS'namespace Step53'
p28908
ag9
aS'  using namespace dealii;'
p28909
aS'  class AfricaTopography'
p28910
aS'  {'
p28911
aS'  public:'
p28912
aS'    AfricaTopography();'
p28913
aS'    double value(const double lon, const double lat) const;'
p28914
aS'  private:'
p28915
aS'    const Functions::InterpolatedUniformGridData<2> topography_data;'
p28916
aS'    static std::vector<double> get_data();'
p28917
aS'  };'
p28918
aS'  AfricaTopography::AfricaTopography()'
p28919
aS'    : topography_data({{std::make_pair(-6.983333, 11.966667),'
p28920
aS'                        std::make_pair(25, 35.95)}},'
p28921
aS'                      {{379, 219}},'
p28922
aS'                      Table<2, double>(380, 220, get_data().begin()))'
p28923
aS'  {}'
p28924
aS'  double AfricaTopography::value(const double lon, const double lat) const'
p28925
aS'  {'
p28926
aS'    return topography_data.value('
p28927
aS'      Point<2>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI));'
p28928
aS'  }'
p28929
aS'  std::vector<double> AfricaTopography::get_data()'
p28930
aS'  {'
p28931
aS'    std::vector<double> data;'
p28932
aS'    boost::iostreams::filtering_istream in;'
p28933
aS'    in.push(boost::iostreams::basic_gzip_decompressor<>());'
p28934
aS'    in.push(boost::iostreams::file_source("topography.txt.gz"));'
p28935
aS'    for (unsigned int line = 0; line < 83600; ++line)'
p28936
aS'      {'
p28937
aS'        try'
p28938
aS'          {'
p28939
aS'            double lat, lon, elevation;'
p28940
aS'            in >> lat >> lon >> elevation;'
p28941
aS'            data.push_back(elevation);'
p28942
aS'          }'
p28943
aS'        catch (...)'
p28944
aS'          {'
p28945
aS'            AssertThrow(false,'
p28946
aS'                        ExcMessage("Could not read all 83,600 data points "'
p28947
aS'                                   "from the file <topography.txt.gz>!"));'
p28948
aS'          }'
p28949
aS'      }'
p28950
aS'    return data;'
p28951
aS'  }'
p28952
aS'  class AfricaGeometry : public ChartManifold<3, 3>'
p28953
aS'  {'
p28954
aS'  public:'
p28955
aS'    virtual Point<3> pull_back(const Point<3> &space_point) const override;'
p28956
aS'    virtual Point<3> push_forward(const Point<3> &chart_point) const override;'
p28957
aS'    virtual std::unique_ptr<Manifold<3, 3>> clone() const override;'
p28958
aS'  private:'
p28959
aS'    static const double R;'
p28960
aS'    static const double ellipticity;'
p28961
aS'    const AfricaTopography topography;'
p28962
aS'    Point<3> push_forward_wgs84(const Point<3> &phi_theta_d) const;'
p28963
aS'    Point<3> pull_back_wgs84(const Point<3> &x) const;'
p28964
aS'    Point<3> push_forward_topo(const Point<3> &phi_theta_d_hat) const;'
p28965
aS'    Point<3> pull_back_topo(const Point<3> &phi_theta_d) const;'
p28966
aS'  };'
p28967
aS'  const double AfricaGeometry::R           = 6378137;'
p28968
aS'  const double AfricaGeometry::ellipticity = 8.1819190842622e-2;'
p28969
aS'  Point<3> AfricaGeometry::pull_back(const Point<3> &space_point) const'
p28970
aS'  {'
p28971
aS'    return pull_back_topo(pull_back_wgs84(space_point));'
p28972
aS'  }'
p28973
aS'  Point<3> AfricaGeometry::push_forward(const Point<3> &chart_point) const'
p28974
aS'  {'
p28975
aS'    return push_forward_wgs84(push_forward_topo(chart_point));'
p28976
aS'  }'
p28977
aS'  std::unique_ptr<Manifold<3, 3>> AfricaGeometry::clone() const'
p28978
aS'  {'
p28979
aS'    return std::make_unique<AfricaGeometry>();'
p28980
aS'  }'
p28981
aS'  Point<3> AfricaGeometry::push_forward_wgs84(const Point<3> &phi_theta_d) const'
p28982
aS'  {'
p28983
aS'    const double phi   = phi_theta_d[0];'
p28984
aS'    const double theta = phi_theta_d[1];'
p28985
aS'    const double d     = phi_theta_d[2];'
p28986
aS'    const double R_bar = R / std::sqrt(1 - (ellipticity * ellipticity *'
p28987
aS'                                            std::sin(theta) * std::sin(theta)));'
p28988
aS'    return {(R_bar + d) * std::cos(phi) * std::cos(theta),'
p28989
aS'  }'
p28990
aS'  Point<3> AfricaGeometry::pull_back_wgs84(const Point<3> &x) const'
p28991
aS'  {'
p28992
aS'    const double b   = std::sqrt(R * R * (1 - ellipticity * ellipticity));'
p28993
aS'    const double ep  = std::sqrt((R * R - b * b) / (b * b));'
p28994
aS'    const double p   = std::sqrt(x(0) * x(0) + x(1) * x(1));'
p28995
aS'    const double th  = std::atan2(R * x(2), b * p);'
p28996
aS'    const double phi = std::atan2(x(1), x(0));'
p28997
aS'    const double theta ='
p28998
aS'      std::atan2(x(2) + ep * ep * b * std::pow(std::sin(th), 3),'
p28999
aS'    const double R_bar ='
p29000
aS'      R / (std::sqrt(1 - ellipticity * ellipticity * std::sin(theta) *'
p29001
aS'                           std::sin(theta)));'
p29002
aS'    const double R_plus_d = p / std::cos(theta);'
p29003
aS'    Point<3> phi_theta_d;'
p29004
aS'    if (phi < 0)'
p29005
aS'      phi_theta_d[0] = phi + 2 * numbers::PI;'
p29006
aS'    else if (phi > 2 * numbers::PI)'
p29007
aS'      phi_theta_d[0] = phi - 2 * numbers::PI;'
p29008
aS'    else'
p29009
aS'      phi_theta_d[0] = phi;'
p29010
aS'    phi_theta_d[1] = theta;'
p29011
aS'    phi_theta_d[2] = R_plus_d - R_bar;'
p29012
aS'    return phi_theta_d;'
p29013
aS'  }'
p29014
aS'  Point<3>'
p29015
aS'  AfricaGeometry::push_forward_topo(const Point<3> &phi_theta_d_hat) const'
p29016
aS'  {'
p29017
aS'    const double d_hat = phi_theta_d_hat[2];'
p29018
aS'    const double h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);'
p29019
aS'    const double d = d_hat + (d_hat + 500000) / 500000 * h;'
p29020
aS'    return {phi_theta_d_hat[0], phi_theta_d_hat[1], d};'
p29021
aS'  }'
p29022
aS'  Point<3> AfricaGeometry::pull_back_topo(const Point<3> &phi_theta_d) const'
p29023
aS'  {'
p29024
aS'    const double d     = phi_theta_d[2];'
p29025
aS'    const double h     = topography.value(phi_theta_d[0], phi_theta_d[1]);'
p29026
aS'    const double d_hat = 500000 * (d - h) / (500000 + h);'
p29027
aS'    return {phi_theta_d[0], phi_theta_d[1], d_hat};'
p29028
aS'  }'
p29029
aS'  void run()'
p29030
aS'  {'
p29031
aS'    AfricaGeometry   geometry;'
p29032
aS'    Triangulation<3> triangulation;'
p29033
aS'    {'
p29034
aS'      const Point<3> corner_points[2] = {'
p29035
aS'        Point<3>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),'
p29036
aS'        Point<3>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};'
p29037
aS'      std::vector<unsigned int> subdivisions(3);'
p29038
aS'      subdivisions[0] = 1;'
p29039
aS'      subdivisions[1] = 2;'
p29040
aS'      subdivisions[2] = 1;'
p29041
aS'      GridGenerator::subdivided_hyper_rectangle('
p29042
aS'        triangulation, subdivisions, corner_points[0], corner_points[1], true);'
p29043
aS'      GridTools::transform('
p29044
aS'        [&geometry](const Point<3> &chart_point) {'
p29045
aS'          return geometry.push_forward(chart_point);'
p29046
aS'        },'
p29047
aS'        triangulation);'
p29048
aS'    }'
p29049
aS'    triangulation.set_manifold(0, geometry);'
p29050
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p29051
aS'      cell->set_all_manifold_ids(0);'
p29052
aS'    for (unsigned int i = 0; i < 6; ++i)'
p29053
aS'      {'
p29054
aS'        for (const auto &cell : triangulation.active_cell_iterators())'
p29055
aS'          for (const auto &face : cell->face_iterators())'
p29056
aS'            if (face->boundary_id() == 5)'
p29057
aS'              {'
p29058
aS'                cell->set_refine_flag();'
p29059
aS'                break;'
p29060
aS'              }'
p29061
aS'        triangulation.execute_coarsening_and_refinement();'
p29062
aS'        std::cout << "Refinement step " << i + 1 << ": "'
p29063
aS'                  << triangulation.n_active_cells() << " cells, "'
p29064
aS'                  << GridTools::minimal_cell_diameter(triangulation) / 1000'
p29065
aS'                  << "km minimal cell diameter" << std::endl;'
p29066
aS'      }'
p29067
aS'    const std::string filename = "mesh.vtu";'
p29068
aS'    std::ofstream     out(filename);'
p29069
aS'    GridOut           grid_out;'
p29070
aS'    grid_out.write_vtu(triangulation, out);'
p29071
aS'  }'
p29072
aS'} // namespace Step53'
p29073
aS'int main()'
p29074
ag9
aS'  try'
p29075
aS'    {'
p29076
aS'      Step53::run();'
p29077
aS'    }'
p29078
aS'  catch (std::exception &exc)'
p29079
aS'    {'
p29080
aS'      std::cerr << std::endl'
p29081
aS'                << std::endl'
p29082
aS'                << "----------------------------------------------------"'
p29083
aS'                << std::endl;'
p29084
aS'      std::cerr << "Exception on processing: " << std::endl'
p29085
aS'                << exc.what() << std::endl'
p29086
aS'                << "Aborting!" << std::endl'
p29087
aS'                << "----------------------------------------------------"'
p29088
aS'                << std::endl;'
p29089
aS'      return 1;'
p29090
aS'    }'
p29091
aS'  catch (...)'
p29092
aS'    {'
p29093
aS'      std::cerr << std::endl'
p29094
aS'                << std::endl'
p29095
aS'                << "----------------------------------------------------"'
p29096
aS'                << std::endl;'
p29097
aS'      std::cerr << "Unknown exception!" << std::endl'
p29098
aS'                << "Aborting!" << std::endl'
p29099
aS'                << "----------------------------------------------------"'
p29100
aS'                << std::endl;'
p29101
aS'      return 1;'
p29102
aS'    }'
p29103
ag17
aS'#include <deal.II/grid/tria.h>'
p29104
aS'#include <deal.II/grid/grid_generator.h>'
p29105
aS'#include <deal.II/grid/grid_in.h>'
p29106
aS'#include <deal.II/grid/grid_out.h>'
p29107
aS'#include <deal.II/numerics/data_out.h>'
p29108
aS'#include <deal.II/numerics/vector_tools.h>'
p29109
aS'#include <deal.II/opencascade/manifold_lib.h>'
p29110
aS'#include <deal.II/opencascade/utilities.h>'
p29111
aS'#include <cmath>'
p29112
aS'#include <iostream>'
p29113
aS'#include <fstream>'
p29114
aS'#include <string>'
p29115
aS'namespace Step54'
p29116
ag9
aS'  using namespace dealii;'
p29117
aS'  class TriangulationOnCAD'
p29118
aS'  {'
p29119
aS'  public:'
p29120
aS'    enum ProjectionType'
p29121
aS'    {'
p29122
aS'      NormalProjection       = 0,'
p29123
aS'      DirectionalProjection  = 1,'
p29124
aS'      NormalToMeshProjection = 2'
p29125
aS'    };'
p29126
aS'    TriangulationOnCAD('
p29127
aS'      const std::string &  initial_mesh_filename,'
p29128
aS'      const std::string &  cad_file_name,'
p29129
aS'      const std::string &  output_filename,'
p29130
aS'      const ProjectionType surface_projection_kind = NormalProjection);'
p29131
aS'    void run();'
p29132
aS'  private:'
p29133
aS'    void read_domain();'
p29134
aS'    void refine_mesh();'
p29135
aS'    void output_results(const unsigned int cycle);'
p29136
aS'    Triangulation<2, 3> tria;'
p29137
aS'    const std::string initial_mesh_filename;'
p29138
aS'    const std::string cad_file_name;'
p29139
aS'    const std::string output_filename;'
p29140
aS'    const ProjectionType surface_projection_kind;'
p29141
aS'  };'
p29142
aS'  TriangulationOnCAD::TriangulationOnCAD('
p29143
aS'    const std::string &  initial_mesh_filename,'
p29144
aS'    const std::string &  cad_file_name,'
p29145
aS'    const std::string &  output_filename,'
p29146
aS'    const ProjectionType surface_projection_kind)'
p29147
aS'    : initial_mesh_filename(initial_mesh_filename)'
p29148
aS'    , cad_file_name(cad_file_name)'
p29149
aS'    , output_filename(output_filename)'
p29150
aS'    , surface_projection_kind(surface_projection_kind)'
p29151
aS'  {}'
p29152
aS'  void TriangulationOnCAD::read_domain()'
p29153
aS'  {'
p29154
aS'    TopoDS_Shape bow_surface = OpenCASCADE::read_IGES(cad_file_name, 1e-3);'
p29155
aS'    const double tolerance = OpenCASCADE::get_shape_tolerance(bow_surface) * 5;'
p29156
aS'    std::vector<TopoDS_Compound>  compounds;'
p29157
aS'    std::vector<TopoDS_CompSolid> compsolids;'
p29158
aS'    std::vector<TopoDS_Solid>     solids;'
p29159
aS'    std::vector<TopoDS_Shell>     shells;'
p29160
aS'    std::vector<TopoDS_Wire>      wires;'
p29161
aS'    OpenCASCADE::extract_compound_shapes('
p29162
aS'      bow_surface, compounds, compsolids, solids, shells, wires);'
p29163
aS'    std::ifstream in;'
p29164
aS'    in.open(initial_mesh_filename);'
p29165
aS'    GridIn<2, 3> gi;'
p29166
aS'    gi.attach_triangulation(tria);'
p29167
aS'    gi.read_vtk(in);'
p29168
aS'    output_results(0);'
p29169
aS'    Triangulation<2, 3>::active_cell_iterator cell = tria.begin_active();'
p29170
aS'    cell->set_manifold_id(1);'
p29171
aS'    for (const auto &face : cell->face_iterators())'
p29172
aS'      face->set_manifold_id(2);'
p29173
aS'    Assert('
p29174
aS'      wires.size() > 0,'
p29175
aS'      ExcMessage('
p29176
aS'        "I could not find any wire in the CAD file you gave me. Bailing out."));'
p29177
aS'    OpenCASCADE::ArclengthProjectionLineManifold<2, 3> line_projector('
p29178
aS'      wires[0], tolerance);'
p29179
aS'    tria.set_manifold(2, line_projector);'
p29180
aS'    switch (surface_projection_kind)'
p29181
aS'      {'
p29182
aS'        case NormalProjection:'
p29183
aS'          {'
p29184
aS'            OpenCASCADE::NormalProjectionManifold<2, 3> normal_projector('
p29185
aS'              bow_surface, tolerance);'
p29186
aS'            tria.set_manifold(1, normal_projector);'
p29187
aS'            break;'
p29188
aS'          }'
p29189
aS'        case DirectionalProjection:'
p29190
aS'          {'
p29191
aS'            OpenCASCADE::DirectionalProjectionManifold<2, 3>'
p29192
aS'              directional_projector(bow_surface,'
p29193
aS'                                    Point<3>(0.0, 1.0, 0.0),'
p29194
aS'                                    tolerance);'
p29195
aS'            tria.set_manifold(1, directional_projector);'
p29196
aS'            break;'
p29197
aS'          }'
p29198
aS'        case NormalToMeshProjection:'
p29199
aS'          {'
p29200
aS'            OpenCASCADE::NormalToMeshProjectionManifold<2, 3>'
p29201
aS'              normal_to_mesh_projector(bow_surface, tolerance);'
p29202
aS'            tria.set_manifold(1, normal_to_mesh_projector);'
p29203
aS'            break;'
p29204
aS'          }'
p29205
aS'        default:'
p29206
aS'          AssertThrow(false, ExcInternalError());'
p29207
aS'      }'
p29208
aS'  }'
p29209
aS'  void TriangulationOnCAD::refine_mesh()'
p29210
aS'  {'
p29211
aS'    tria.refine_global(1);'
p29212
aS'  }'
p29213
aS'  void TriangulationOnCAD::output_results(const unsigned int cycle)'
p29214
aS'  {'
p29215
aS'    const std::string filename ='
p29216
aS'    std::ofstream logfile(filename);'
p29217
aS'    GridOut       grid_out;'
p29218
aS'    grid_out.write_vtk(tria, logfile);'
p29219
aS'  }'
p29220
aS'  void TriangulationOnCAD::run()'
p29221
aS'  {'
p29222
aS'    read_domain();'
p29223
aS'    const unsigned int n_cycles = 5;'
p29224
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p29225
aS'      {'
p29226
aS'        refine_mesh();'
p29227
aS'        output_results(cycle + 1);'
p29228
aS'      }'
p29229
aS'  }'
p29230
aS'} // namespace Step54'
p29231
aS'int main()'
p29232
ag9
aS'  try'
p29233
aS'    {'
p29234
aS'      using namespace Step54;'
p29235
aS'      const std::string in_mesh_filename = "input/initial_mesh_3d.vtk";'
p29236
aS'      const std::string cad_file_name    = "input/DTMB-5415_bulbous_bow.iges";'
p29237
aS'      std::cout << "----------------------------------------------------------"'
p29238
aS'                << std::endl;'
p29239
aS'      std::cout << "Testing projection in direction normal to CAD surface"'
p29240
aS'                << std::endl;'
p29241
aS'      std::cout << "----------------------------------------------------------"'
p29242
aS'                << std::endl;'
p29243
aS'      std::string        out_mesh_filename = ("3d_mesh_normal_projection");'
p29244
aS'      TriangulationOnCAD tria_on_cad_norm(in_mesh_filename,'
p29245
aS'                                          cad_file_name,'
p29246
aS'                                          out_mesh_filename,'
p29247
aS'                                          TriangulationOnCAD::NormalProjection);'
p29248
aS'      tria_on_cad_norm.run();'
p29249
aS'      std::cout << "----------------------------------------------------------"'
p29250
aS'                << std::endl;'
p29251
aS'      std::cout << std::endl;'
p29252
aS'      std::cout << std::endl;'
p29253
aS'      std::cout << "----------------------------------------------------------"'
p29254
aS'                << std::endl;'
p29255
aS'      std::cout << "Testing projection in y-axis direction" << std::endl;'
p29256
aS'      std::cout << "----------------------------------------------------------"'
p29257
aS'                << std::endl;'
p29258
aS'      out_mesh_filename = ("3d_mesh_directional_projection");'
p29259
aS'      TriangulationOnCAD tria_on_cad_dir('
p29260
aS'        in_mesh_filename,'
p29261
aS'        cad_file_name,'
p29262
aS'        out_mesh_filename,'
p29263
aS'        TriangulationOnCAD::DirectionalProjection);'
p29264
aS'      tria_on_cad_dir.run();'
p29265
aS'      std::cout << "----------------------------------------------------------"'
p29266
aS'                << std::endl;'
p29267
aS'      std::cout << std::endl;'
p29268
aS'      std::cout << std::endl;'
p29269
aS'      std::cout << "----------------------------------------------------------"'
p29270
aS'                << std::endl;'
p29271
aS'      std::cout << "Testing projection in direction normal to mesh elements"'
p29272
aS'                << std::endl;'
p29273
aS'      std::cout << "----------------------------------------------------------"'
p29274
aS'                << std::endl;'
p29275
aS'      out_mesh_filename = ("3d_mesh_normal_to_mesh_projection");'
p29276
aS'      TriangulationOnCAD tria_on_cad_norm_to_mesh('
p29277
aS'        in_mesh_filename,'
p29278
aS'        cad_file_name,'
p29279
aS'        out_mesh_filename,'
p29280
aS'        TriangulationOnCAD::NormalToMeshProjection);'
p29281
aS'      tria_on_cad_norm_to_mesh.run();'
p29282
aS'      std::cout << "----------------------------------------------------------"'
p29283
aS'                << std::endl;'
p29284
aS'      std::cout << std::endl;'
p29285
aS'      std::cout << std::endl;'
p29286
aS'    }'
p29287
aS'  catch (std::exception &exc)'
p29288
aS'    {'
p29289
aS'      std::cerr << std::endl'
p29290
aS'                << std::endl'
p29291
aS'                << "----------------------------------------------------"'
p29292
aS'                << std::endl;'
p29293
aS'      std::cerr << "Exception on processing: " << std::endl'
p29294
aS'                << exc.what() << std::endl'
p29295
aS'                << "Aborting!" << std::endl'
p29296
aS'                << "----------------------------------------------------"'
p29297
aS'                << std::endl;'
p29298
aS'      return 1;'
p29299
aS'    }'
p29300
aS'  catch (...)'
p29301
aS'    {'
p29302
aS'      std::cerr << std::endl'
p29303
aS'                << std::endl'
p29304
aS'                << "----------------------------------------------------"'
p29305
aS'                << std::endl;'
p29306
aS'      std::cerr << "Unknown exception!" << std::endl'
p29307
aS'                << "Aborting!" << std::endl'
p29308
aS'                << "----------------------------------------------------"'
p29309
aS'                << std::endl;'
p29310
aS'      return 1;'
p29311
aS'    }'
p29312
aS'  return 0;'
p29313
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p29314
aS'#include <deal.II/base/function.h>'
p29315
aS'#include <deal.II/base/timer.h>'
p29316
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p29317
aS'namespace LA'
p29318
ag9
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p29319
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p29320
aS'  using namespace dealii::LinearAlgebraPETSc;'
p29321
aS'#  define USE_PETSC_LA'
p29322
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p29323
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p29324
aS'#else'
p29325
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p29326
aS'#endif'
p29327
aS'} // namespace LA'
p29328
aS'#include <deal.II/lac/vector.h>'
p29329
aS'#include <deal.II/lac/full_matrix.h>'
p29330
aS'#include <deal.II/lac/solver_cg.h>'
p29331
aS'#include <deal.II/lac/solver_gmres.h>'
p29332
aS'#include <deal.II/lac/solver_minres.h>'
p29333
aS'#include <deal.II/lac/affine_constraints.h>'
p29334
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p29335
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p29336
aS'#include <deal.II/lac/petsc_vector.h>'
p29337
aS'#include <deal.II/lac/petsc_solver.h>'
p29338
aS'#include <deal.II/lac/petsc_precondition.h>'
p29339
aS'#include <deal.II/grid/grid_generator.h>'
p29340
aS'#include <deal.II/grid/manifold_lib.h>'
p29341
aS'#include <deal.II/grid/grid_tools.h>'
p29342
aS'#include <deal.II/dofs/dof_handler.h>'
p29343
aS'#include <deal.II/dofs/dof_renumbering.h>'
p29344
aS'#include <deal.II/dofs/dof_tools.h>'
p29345
aS'#include <deal.II/fe/fe_values.h>'
p29346
aS'#include <deal.II/fe/fe_q.h>'
p29347
aS'#include <deal.II/fe/fe_system.h>'
p29348
aS'#include <deal.II/numerics/vector_tools.h>'
p29349
aS'#include <deal.II/numerics/data_out.h>'
p29350
aS'#include <deal.II/numerics/error_estimator.h>'
p29351
aS'#include <deal.II/base/utilities.h>'
p29352
aS'#include <deal.II/base/conditional_ostream.h>'
p29353
aS'#include <deal.II/base/index_set.h>'
p29354
aS'#include <deal.II/lac/sparsity_tools.h>'
p29355
aS'#include <deal.II/distributed/tria.h>'
p29356
aS'#include <deal.II/distributed/grid_refinement.h>'
p29357
aS'#include <cmath>'
p29358
aS'#include <fstream>'
p29359
aS'#include <iostream>'
p29360
aS'namespace Step55'
p29361
ag9
aS'  using namespace dealii;'
p29362
aS'  namespace LinearSolvers'
p29363
aS'  {'
p29364
aS'    template <class Matrix, class Preconditioner>'
p29365
aS'    class InverseMatrix : public Subscriptor'
p29366
aS'    {'
p29367
aS'    public:'
p29368
aS'      InverseMatrix(const Matrix &m, const Preconditioner &preconditioner);'
p29369
aS'      template <typename VectorType>'
p29370
aS'      void vmult(VectorType &dst, const VectorType &src) const;'
p29371
aS'    private:'
p29372
aS'      const SmartPointer<const Matrix> matrix;'
p29373
aS'      const Preconditioner &           preconditioner;'
p29374
aS'    };'
p29375
aS'    template <class Matrix, class Preconditioner>'
p29376
aS'    InverseMatrix<Matrix, Preconditioner>::InverseMatrix('
p29377
aS'      const Matrix &        m,'
p29378
aS'      const Preconditioner &preconditioner)'
p29379
aS'      : matrix(&m)'
p29380
aS'      , preconditioner(preconditioner)'
p29381
aS'    {}'
p29382
aS'    template <class Matrix, class Preconditioner>'
p29383
aS'    template <typename VectorType>'
p29384
aS'    void'
p29385
aS'    InverseMatrix<Matrix, Preconditioner>::vmult(VectorType &      dst,'
p29386
aS'                                                 const VectorType &src) const'
p29387
aS'    {'
p29388
aS'      SolverControl solver_control(src.size(), 1e-8 * src.l2_norm());'
p29389
aS'      SolverCG<LA::MPI::Vector> cg(solver_control);'
p29390
aS'      dst = 0;'
p29391
aS'      try'
p29392
aS'        {'
p29393
aS'          cg.solve(*matrix, dst, src, preconditioner);'
p29394
aS'        }'
p29395
aS'      catch (std::exception &e)'
p29396
aS'        {'
p29397
aS'          Assert(false, ExcMessage(e.what()));'
p29398
aS'        }'
p29399
aS'    }'
p29400
aS'    template <class PreconditionerA, class PreconditionerS>'
p29401
aS'    class BlockDiagonalPreconditioner : public Subscriptor'
p29402
aS'    {'
p29403
aS'    public:'
p29404
aS'      BlockDiagonalPreconditioner(const PreconditionerA &preconditioner_A,'
p29405
aS'                                  const PreconditionerS &preconditioner_S);'
p29406
aS'      void vmult(LA::MPI::BlockVector &      dst,'
p29407
aS'                 const LA::MPI::BlockVector &src) const;'
p29408
aS'    private:'
p29409
aS'      const PreconditionerA &preconditioner_A;'
p29410
aS'      const PreconditionerS &preconditioner_S;'
p29411
aS'    };'
p29412
aS'    template <class PreconditionerA, class PreconditionerS>'
p29413
aS'    BlockDiagonalPreconditioner<PreconditionerA, PreconditionerS>::'
p29414
aS'      BlockDiagonalPreconditioner(const PreconditionerA &preconditioner_A,'
p29415
aS'                                  const PreconditionerS &preconditioner_S)'
p29416
aS'      : preconditioner_A(preconditioner_A)'
p29417
aS'      , preconditioner_S(preconditioner_S)'
p29418
aS'    {}'
p29419
aS'    template <class PreconditionerA, class PreconditionerS>'
p29420
aS'    void BlockDiagonalPreconditioner<PreconditionerA, PreconditionerS>::vmult('
p29421
aS'      LA::MPI::BlockVector &      dst,'
p29422
aS'      const LA::MPI::BlockVector &src) const'
p29423
aS'    {'
p29424
aS'      preconditioner_A.vmult(dst.block(0), src.block(0));'
p29425
aS'      preconditioner_S.vmult(dst.block(1), src.block(1));'
p29426
aS'    }'
p29427
aS'  } // namespace LinearSolvers'
p29428
aS'  template <int dim>'
p29429
aS'  class RightHandSide : public Function<dim>'
p29430
aS'  {'
p29431
aS'  public:'
p29432
aS'    RightHandSide()'
p29433
aS'      : Function<dim>(dim + 1)'
p29434
aS'    {}'
p29435
aS'    virtual void vector_value(const Point<dim> &p,'
p29436
aS'                              Vector<double> &  value) const override;'
p29437
aS'  };'
p29438
aS'  template <int dim>'
p29439
aS'  void RightHandSide<dim>::vector_value(const Point<dim> &p,'
p29440
aS'                                        Vector<double> &  values) const'
p29441
aS'  {'
p29442
aS'    const double R_x = p[0];'
p29443
aS'    const double R_y = p[1];'
p29444
aS'    const double pi  = numbers::PI;'
p29445
aS'    const double pi2 = pi * pi;'
p29446
aS'    values[0] ='
p29447
aS'      -1.0L / 2.0L * (-2 * sqrt(25.0 + 4 * pi2) + 10.0) *'
p29448
aS'        exp(R_x * (-2 * sqrt(25.0 + 4 * pi2) + 10.0)) -'
p29449
aS'      0.4 * pi2 * exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi) +'
p29450
aS'      0.1 * pow(-sqrt(25.0 + 4 * pi2) + 5.0, 2) *'
p29451
aS'        exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi);'
p29452
aS'    values[1] = 0.2 * pi * (-sqrt(25.0 + 4 * pi2) + 5.0) *'
p29453
aS'                  exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) -'
p29454
aS'                0.05 * pow(-sqrt(25.0 + 4 * pi2) + 5.0, 3) *'
p29455
aS'                  exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) /'
p29456
aS'                  pi;'
p29457
aS'    values[2] = 0;'
p29458
aS'  }'
p29459
aS'  template <int dim>'
p29460
aS'  class ExactSolution : public Function<dim>'
p29461
aS'  {'
p29462
aS'  public:'
p29463
aS'    ExactSolution()'
p29464
aS'      : Function<dim>(dim + 1)'
p29465
aS'    {}'
p29466
aS'    virtual void vector_value(const Point<dim> &p,'
p29467
aS'                              Vector<double> &  value) const override;'
p29468
aS'  };'
p29469
aS'  template <int dim>'
p29470
aS'  void ExactSolution<dim>::vector_value(const Point<dim> &p,'
p29471
aS'                                        Vector<double> &  values) const'
p29472
aS'  {'
p29473
aS'    const double R_x = p[0];'
p29474
aS'    const double R_y = p[1];'
p29475
aS'    const double pi  = numbers::PI;'
p29476
aS'    const double pi2 = pi * pi;'
p29477
aS'    values[0] ='
p29478
aS'      -exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * cos(2 * R_y * pi) + 1;'
p29479
aS'    values[1] = (1.0L / 2.0L) * (-sqrt(25.0 + 4 * pi2) + 5.0) *'
p29480
aS'                exp(R_x * (-sqrt(25.0 + 4 * pi2) + 5.0)) * sin(2 * R_y * pi) /'
p29481
aS'                pi;'
p29482
aS'    values[2] ='
p29483
aS'      -1.0L / 2.0L * exp(R_x * (-2 * sqrt(25.0 + 4 * pi2) + 10.0)) -'
p29484
aS'      2.0 *'
p29485
aS'         0.0134758939981709 * exp(4 * sqrt(25.0 + 4 * pi2))) /'
p29486
aS'         16.0 * sqrt(25.0 + 4 * pi2) * exp(3 * sqrt(25.0 + 4 * pi2))) -'
p29487
aS'      1634508.68623606 * exp(-3.0 * sqrt(25.0 + 4 * pi2)) /'
p29488
aS'       3269017.37247211 * exp(-3 * sqrt(25.0 + 4 * pi2))) /'
p29489
aS'      0.00336897349954273 * exp(1.0 * sqrt(25.0 + 4 * pi2)) /'
p29490
aS'  }'
p29491
aS'  template <int dim>'
p29492
aS'  class StokesProblem'
p29493
aS'  {'
p29494
aS'  public:'
p29495
aS'    StokesProblem(unsigned int velocity_degree);'
p29496
aS'    void run();'
p29497
aS'  private:'
p29498
aS'    void make_grid();'
p29499
aS'    void setup_system();'
p29500
aS'    void assemble_system();'
p29501
aS'    void solve();'
p29502
aS'    void refine_grid();'
p29503
aS'    void output_results(const unsigned int cycle) const;'
p29504
aS'    unsigned int velocity_degree;'
p29505
aS'    double       viscosity;'
p29506
aS'    MPI_Comm     mpi_communicator;'
p29507
aS'    FESystem<dim>                             fe;'
p29508
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p29509
aS'    DoFHandler<dim>                           dof_handler;'
p29510
aS'    std::vector<IndexSet> owned_partitioning;'
p29511
aS'    std::vector<IndexSet> relevant_partitioning;'
p29512
aS'    AffineConstraints<double> constraints;'
p29513
aS'    LA::MPI::BlockSparseMatrix system_matrix;'
p29514
aS'    LA::MPI::BlockSparseMatrix preconditioner_matrix;'
p29515
aS'    LA::MPI::BlockVector       locally_relevant_solution;'
p29516
aS'    LA::MPI::BlockVector       system_rhs;'
p29517
aS'    ConditionalOStream pcout;'
p29518
aS'    TimerOutput        computing_timer;'
p29519
aS'  };'
p29520
aS'  template <int dim>'
p29521
aS'  StokesProblem<dim>::StokesProblem(unsigned int velocity_degree)'
p29522
aS'    : velocity_degree(velocity_degree)'
p29523
aS'    , viscosity(0.1)'
p29524
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p29525
aS'    , fe(FE_Q<dim>(velocity_degree), dim, FE_Q<dim>(velocity_degree - 1), 1)'
p29526
aS'    , triangulation(mpi_communicator,'
p29527
aS'                    typename Triangulation<dim>::MeshSmoothing('
p29528
aS'                      Triangulation<dim>::smoothing_on_refinement |'
p29529
aS'                      Triangulation<dim>::smoothing_on_coarsening))'
p29530
aS'    , dof_handler(triangulation)'
p29531
aS'    , pcout(std::cout,'
p29532
aS'    , computing_timer(mpi_communicator,'
p29533
aS'                      pcout,'
p29534
aS'                      TimerOutput::summary,'
p29535
aS'                      TimerOutput::wall_times)'
p29536
aS'  {}'
p29537
aS'  template <int dim>'
p29538
aS'  void StokesProblem<dim>::make_grid()'
p29539
aS'  {'
p29540
aS'    GridGenerator::hyper_cube(triangulation, -0.5, 1.5);'
p29541
aS'    triangulation.refine_global(3);'
p29542
aS'  }'
p29543
aS'  template <int dim>'
p29544
aS'  void StokesProblem<dim>::setup_system()'
p29545
aS'  {'
p29546
aS'    TimerOutput::Scope t(computing_timer, "setup");'
p29547
aS'    dof_handler.distribute_dofs(fe);'
p29548
aS'    std::vector<unsigned int> stokes_sub_blocks(dim + 1, 0);'
p29549
aS'    stokes_sub_blocks[dim] = 1;'
p29550
aS'    DoFRenumbering::component_wise(dof_handler, stokes_sub_blocks);'
p29551
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p29552
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, stokes_sub_blocks);'
p29553
aS'    const unsigned int n_u = dofs_per_block[0];'
p29554
aS'    const unsigned int n_p = dofs_per_block[1];'
p29555
aS'    pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs() << " ("'
p29556
aS"          << n_u << '+' << n_p << ')' << std::endl;"
p29557
aS'    owned_partitioning.resize(2);'
p29558
aS'    owned_partitioning[0] = dof_handler.locally_owned_dofs().get_view(0, n_u);'
p29559
aS'    owned_partitioning[1] ='
p29560
aS'      dof_handler.locally_owned_dofs().get_view(n_u, n_u + n_p);'
p29561
aS'    IndexSet locally_relevant_dofs;'
p29562
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p29563
aS'    relevant_partitioning.resize(2);'
p29564
aS'    relevant_partitioning[0] = locally_relevant_dofs.get_view(0, n_u);'
p29565
aS'    relevant_partitioning[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);'
p29566
aS'    {'
p29567
aS'      constraints.reinit(locally_relevant_dofs);'
p29568
aS'      FEValuesExtractors::Vector velocities(0);'
p29569
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p29570
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p29571
aS'                                               0,'
p29572
aS'                                               ExactSolution<dim>(),'
p29573
aS'                                               constraints,'
p29574
aS'                                               fe.component_mask(velocities));'
p29575
aS'      constraints.close();'
p29576
aS'    }'
p29577
aS'    {'
p29578
aS'      system_matrix.clear();'
p29579
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p29580
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p29581
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p29582
aS'          if (c == dim && d == dim)'
p29583
aS'            coupling[c][d] = DoFTools::none;'
p29584
aS'          else if (c == dim || d == dim || c == d)'
p29585
aS'            coupling[c][d] = DoFTools::always;'
p29586
aS'          else'
p29587
aS'            coupling[c][d] = DoFTools::none;'
p29588
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p29589
aS'      DoFTools::make_sparsity_pattern('
p29590
aS'        dof_handler, coupling, dsp, constraints, false);'
p29591
aS'      SparsityTools::distribute_sparsity_pattern('
p29592
aS'        dsp,'
p29593
aS'        dof_handler.locally_owned_dofs(),'
p29594
aS'        mpi_communicator,'
p29595
aS'        locally_relevant_dofs);'
p29596
aS'      system_matrix.reinit(owned_partitioning, dsp, mpi_communicator);'
p29597
aS'    }'
p29598
aS'    {'
p29599
aS'      preconditioner_matrix.clear();'
p29600
aS'      Table<2, DoFTools::Coupling> coupling(dim + 1, dim + 1);'
p29601
aS'      for (unsigned int c = 0; c < dim + 1; ++c)'
p29602
aS'        for (unsigned int d = 0; d < dim + 1; ++d)'
p29603
aS'          if (c == dim && d == dim)'
p29604
aS'            coupling[c][d] = DoFTools::always;'
p29605
aS'          else'
p29606
aS'            coupling[c][d] = DoFTools::none;'
p29607
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p29608
aS'      DoFTools::make_sparsity_pattern('
p29609
aS'        dof_handler, coupling, dsp, constraints, false);'
p29610
aS'      SparsityTools::distribute_sparsity_pattern('
p29611
aS'        dsp,'
p29612
aS'        Utilities::MPI::all_gather(mpi_communicator,'
p29613
aS'                                   dof_handler.locally_owned_dofs()),'
p29614
aS'        mpi_communicator,'
p29615
aS'        locally_relevant_dofs);'
p29616
aS'      preconditioner_matrix.reinit(owned_partitioning,'
p29617
aS'                                   dsp,'
p29618
aS'                                   mpi_communicator);'
p29619
aS'    }'
p29620
aS'    locally_relevant_solution.reinit(owned_partitioning,'
p29621
aS'                                     relevant_partitioning,'
p29622
aS'                                     mpi_communicator);'
p29623
aS'    system_rhs.reinit(owned_partitioning, mpi_communicator);'
p29624
aS'  }'
p29625
aS'  template <int dim>'
p29626
aS'  void StokesProblem<dim>::assemble_system()'
p29627
aS'  {'
p29628
aS'    TimerOutput::Scope t(computing_timer, "assembly");'
p29629
aS'    system_matrix         = 0;'
p29630
aS'    preconditioner_matrix = 0;'
p29631
aS'    system_rhs            = 0;'
p29632
aS'    const QGauss<dim> quadrature_formula(velocity_degree + 1);'
p29633
aS'    FEValues<dim> fe_values(fe,'
p29634
aS'                            quadrature_formula,'
p29635
aS'                            update_values | update_gradients |'
p29636
aS'                              update_quadrature_points | update_JxW_values);'
p29637
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p29638
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p29639
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p29640
aS'    FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell);'
p29641
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p29642
aS'    const RightHandSide<dim>    right_hand_side;'
p29643
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p29644
aS'    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);'
p29645
aS'    std::vector<double>         div_phi_u(dofs_per_cell);'
p29646
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p29647
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p29648
aS'    const FEValuesExtractors::Vector     velocities(0);'
p29649
aS'    const FEValuesExtractors::Scalar     pressure(dim);'
p29650
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p29651
aS'      if (cell->is_locally_owned())'
p29652
aS'        {'
p29653
aS'          cell_matrix  = 0;'
p29654
aS'          cell_matrix2 = 0;'
p29655
aS'          cell_rhs     = 0;'
p29656
aS'          fe_values.reinit(cell);'
p29657
aS'          right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p29658
aS'                                            rhs_values);'
p29659
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p29660
aS'            {'
p29661
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p29662
aS'                {'
p29663
aS'                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);'
p29664
aS'                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);'
p29665
aS'                  phi_p[k]      = fe_values[pressure].value(k, q);'
p29666
aS'                }'
p29667
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p29668
aS'                {'
p29669
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p29670
aS'                    {'
p29671
aS'                      cell_matrix(i, j) +='
p29672
aS'                           scalar_product(grad_phi_u[i], grad_phi_u[j]) -'
p29673
aS'                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p29674
aS'                        fe_values.JxW(q);'
p29675
aS'                      cell_matrix2(i, j) += 1.0 / viscosity * phi_p[i] *'
p29676
aS'                                            phi_p[j] * fe_values.JxW(q);'
p29677
aS'                    }'
p29678
aS'                  const unsigned int component_i ='
p29679
aS'                    fe.system_to_component_index(i).first;'
p29680
aS'                  cell_rhs(i) += fe_values.shape_value(i, q) *'
p29681
aS'                                 rhs_values[q](component_i) * fe_values.JxW(q);'
p29682
aS'                }'
p29683
aS'            }'
p29684
aS'          cell->get_dof_indices(local_dof_indices);'
p29685
aS'          constraints.distribute_local_to_global(cell_matrix,'
p29686
aS'                                                 cell_rhs,'
p29687
aS'                                                 local_dof_indices,'
p29688
aS'                                                 system_matrix,'
p29689
aS'                                                 system_rhs);'
p29690
aS'          constraints.distribute_local_to_global(cell_matrix2,'
p29691
aS'                                                 local_dof_indices,'
p29692
aS'                                                 preconditioner_matrix);'
p29693
aS'        }'
p29694
aS'    system_matrix.compress(VectorOperation::add);'
p29695
aS'    preconditioner_matrix.compress(VectorOperation::add);'
p29696
aS'    system_rhs.compress(VectorOperation::add);'
p29697
aS'  }'
p29698
aS'  template <int dim>'
p29699
aS'  void StokesProblem<dim>::solve()'
p29700
aS'  {'
p29701
aS'    TimerOutput::Scope t(computing_timer, "solve");'
p29702
aS'    LA::MPI::PreconditionAMG prec_A;'
p29703
aS'    {'
p29704
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p29705
aS'#ifdef USE_PETSC_LA'
p29706
aS'      data.symmetric_operator = true;'
p29707
aS'#endif'
p29708
aS'      prec_A.initialize(system_matrix.block(0, 0), data);'
p29709
aS'    }'
p29710
aS'    LA::MPI::PreconditionAMG prec_S;'
p29711
aS'    {'
p29712
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p29713
aS'#ifdef USE_PETSC_LA'
p29714
aS'      data.symmetric_operator = true;'
p29715
aS'#endif'
p29716
aS'      prec_S.initialize(preconditioner_matrix.block(1, 1), data);'
p29717
aS'    }'
p29718
aS'    using mp_inverse_t = LinearSolvers::InverseMatrix<LA::MPI::SparseMatrix,'
p29719
aS'                                                      LA::MPI::PreconditionAMG>;'
p29720
aS'    const mp_inverse_t mp_inverse(preconditioner_matrix.block(1, 1), prec_S);'
p29721
aS'    const LinearSolvers::BlockDiagonalPreconditioner<LA::MPI::PreconditionAMG,'
p29722
aS'                                                     mp_inverse_t>'
p29723
aS'      preconditioner(prec_A, mp_inverse);'
p29724
aS'    SolverControl solver_control(system_matrix.m(),'
p29725
aS'                                 1e-10 * system_rhs.l2_norm());'
p29726
aS'    SolverMinRes<LA::MPI::BlockVector> solver(solver_control);'
p29727
aS'    LA::MPI::BlockVector distributed_solution(owned_partitioning,'
p29728
aS'                                              mpi_communicator);'
p29729
aS'    constraints.set_zero(distributed_solution);'
p29730
aS'    solver.solve(system_matrix,'
p29731
aS'                 distributed_solution,'
p29732
aS'                 system_rhs,'
p29733
aS'                 preconditioner);'
p29734
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p29735
aS'          << std::endl;'
p29736
aS'    constraints.distribute(distributed_solution);'
p29737
aS'    locally_relevant_solution = distributed_solution;'
p29738
aS'    const double mean_pressure ='
p29739
aS'      VectorTools::compute_mean_value(dof_handler,'
p29740
aS'                                      QGauss<dim>(velocity_degree + 2),'
p29741
aS'                                      locally_relevant_solution,'
p29742
aS'                                      dim);'
p29743
aS'    distributed_solution.block(1).add(-mean_pressure);'
p29744
aS'    locally_relevant_solution.block(1) = distributed_solution.block(1);'
p29745
aS'  }'
p29746
aS'  template <int dim>'
p29747
aS'  void StokesProblem<dim>::refine_grid()'
p29748
aS'  {'
p29749
aS'    TimerOutput::Scope t(computing_timer, "refine");'
p29750
aS'    triangulation.refine_global();'
p29751
aS'  }'
p29752
aS'  template <int dim>'
p29753
aS'  void StokesProblem<dim>::output_results(const unsigned int cycle) const'
p29754
aS'  {'
p29755
aS'    {'
p29756
aS'      const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);'
p29757
aS'      const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),'
p29758
aS'                                                       dim + 1);'
p29759
aS'      Vector<double> cellwise_errors(triangulation.n_active_cells());'
p29760
aS'      QGauss<dim>    quadrature(velocity_degree + 2);'
p29761
aS'      VectorTools::integrate_difference(dof_handler,'
p29762
aS'                                        locally_relevant_solution,'
p29763
aS'                                        ExactSolution<dim>(),'
p29764
aS'                                        cellwise_errors,'
p29765
aS'                                        quadrature,'
p29766
aS'                                        VectorTools::L2_norm,'
p29767
aS'                                        &velocity_mask);'
p29768
aS'      const double error_u_l2 ='
p29769
aS'        VectorTools::compute_global_error(triangulation,'
p29770
aS'                                          cellwise_errors,'
p29771
aS'                                          VectorTools::L2_norm);'
p29772
aS'      VectorTools::integrate_difference(dof_handler,'
p29773
aS'                                        locally_relevant_solution,'
p29774
aS'                                        ExactSolution<dim>(),'
p29775
aS'                                        cellwise_errors,'
p29776
aS'                                        quadrature,'
p29777
aS'                                        VectorTools::L2_norm,'
p29778
aS'                                        &pressure_mask);'
p29779
aS'      const double error_p_l2 ='
p29780
aS'        VectorTools::compute_global_error(triangulation,'
p29781
aS'                                          cellwise_errors,'
p29782
aS'                                          VectorTools::L2_norm);'
p29783
aS'      pcout << "error: u_0: " << error_u_l2 << " p_0: " << error_p_l2'
p29784
aS'            << std::endl;'
p29785
aS'    }'
p29786
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p29787
aS'    solution_names.emplace_back("pressure");'
p29788
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p29789
aS'      data_component_interpretation('
p29790
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p29791
aS'    data_component_interpretation.push_back('
p29792
aS'      DataComponentInterpretation::component_is_scalar);'
p29793
aS'    DataOut<dim> data_out;'
p29794
aS'    data_out.attach_dof_handler(dof_handler);'
p29795
aS'    data_out.add_data_vector(locally_relevant_solution,'
p29796
aS'                             solution_names,'
p29797
aS'                             DataOut<dim>::type_dof_data,'
p29798
aS'                             data_component_interpretation);'
p29799
aS'    LA::MPI::BlockVector interpolated;'
p29800
aS'    interpolated.reinit(owned_partitioning, MPI_COMM_WORLD);'
p29801
aS'    VectorTools::interpolate(dof_handler, ExactSolution<dim>(), interpolated);'
p29802
aS'    LA::MPI::BlockVector interpolated_relevant(owned_partitioning,'
p29803
aS'                                               relevant_partitioning,'
p29804
aS'                                               MPI_COMM_WORLD);'
p29805
aS'    interpolated_relevant = interpolated;'
p29806
aS'    {'
p29807
aS'      std::vector<std::string> solution_names(dim, "ref_u");'
p29808
aS'      solution_names.emplace_back("ref_p");'
p29809
aS'      data_out.add_data_vector(interpolated_relevant,'
p29810
aS'                               solution_names,'
p29811
aS'                               DataOut<dim>::type_dof_data,'
p29812
aS'                               data_component_interpretation);'
p29813
aS'    }'
p29814
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p29815
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p29816
aS'      subdomain(i) = triangulation.locally_owned_subdomain();'
p29817
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p29818
aS'    data_out.build_patches();'
p29819
aS'    data_out.write_vtu_with_pvtu_record('
p29820
aS'      "./", "solution", cycle, mpi_communicator, 2);'
p29821
aS'  }'
p29822
aS'  template <int dim>'
p29823
aS'  void StokesProblem<dim>::run()'
p29824
aS'  {'
p29825
aS'#ifdef USE_PETSC_LA'
p29826
aS'    pcout << "Running using PETSc." << std::endl;'
p29827
aS'#else'
p29828
aS'    pcout << "Running using Trilinos." << std::endl;'
p29829
aS'#endif'
p29830
aS'    const unsigned int n_cycles = 5;'
p29831
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p29832
aS'      {'
p29833
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p29834
aS'        if (cycle == 0)'
p29835
aS'          make_grid();'
p29836
aS'        else'
p29837
aS'          refine_grid();'
p29838
aS'        setup_system();'
p29839
aS'        assemble_system();'
p29840
aS'        solve();'
p29841
aS'        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32)'
p29842
aS'          {'
p29843
aS'            TimerOutput::Scope t(computing_timer, "output");'
p29844
aS'            output_results(cycle);'
p29845
aS'          }'
p29846
aS'        computing_timer.print_summary();'
p29847
aS'        computing_timer.reset();'
p29848
aS'        pcout << std::endl;'
p29849
aS'      }'
p29850
aS'  }'
p29851
aS'} // namespace Step55'
p29852
aS'int main(int argc, char *argv[])'
p29853
ag9
aS'  try'
p29854
aS'    {'
p29855
aS'      using namespace dealii;'
p29856
aS'      using namespace Step55;'
p29857
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p29858
aS'      StokesProblem<2> problem(2);'
p29859
aS'      problem.run();'
p29860
aS'    }'
p29861
aS'  catch (std::exception &exc)'
p29862
aS'    {'
p29863
aS'      std::cerr << std::endl'
p29864
aS'                << std::endl'
p29865
aS'                << "----------------------------------------------------"'
p29866
aS'                << std::endl;'
p29867
aS'      std::cerr << "Exception on processing: " << std::endl'
p29868
aS'                << exc.what() << std::endl'
p29869
aS'                << "Aborting!" << std::endl'
p29870
aS'                << "----------------------------------------------------"'
p29871
aS'                << std::endl;'
p29872
aS'      return 1;'
p29873
aS'    }'
p29874
aS'  catch (...)'
p29875
aS'    {'
p29876
aS'      std::cerr << std::endl'
p29877
aS'                << std::endl'
p29878
aS'                << "----------------------------------------------------"'
p29879
aS'                << std::endl;'
p29880
aS'      std::cerr << "Unknown exception!" << std::endl'
p29881
aS'                << "Aborting!" << std::endl'
p29882
aS'                << "----------------------------------------------------"'
p29883
aS'                << std::endl;'
p29884
aS'      return 1;'
p29885
aS'    }'
p29886
aS'  return 0;'
p29887
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p29888
aS'#include <deal.II/base/logstream.h>'
p29889
aS'#include <deal.II/base/function.h>'
p29890
aS'#include <deal.II/base/utilities.h>'
p29891
aS'#include <deal.II/lac/block_vector.h>'
p29892
aS'#include <deal.II/lac/full_matrix.h>'
p29893
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p29894
aS'#include <deal.II/lac/block_sparsity_pattern.h>'
p29895
aS'#include <deal.II/lac/solver_cg.h>'
p29896
aS'#include <deal.II/lac/precondition.h>'
p29897
aS'#include <deal.II/lac/affine_constraints.h>'
p29898
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p29899
aS'#include <deal.II/lac/solver_gmres.h>'
p29900
aS'#include <deal.II/grid/tria.h>'
p29901
aS'#include <deal.II/grid/grid_generator.h>'
p29902
aS'#include <deal.II/grid/grid_tools.h>'
p29903
aS'#include <deal.II/grid/grid_refinement.h>'
p29904
aS'#include <deal.II/dofs/dof_handler.h>'
p29905
aS'#include <deal.II/dofs/dof_renumbering.h>'
p29906
aS'#include <deal.II/dofs/dof_tools.h>'
p29907
aS'#include <deal.II/fe/fe_q.h>'
p29908
aS'#include <deal.II/fe/fe_system.h>'
p29909
aS'#include <deal.II/fe/fe_values.h>'
p29910
aS'#include <deal.II/numerics/vector_tools.h>'
p29911
aS'#include <deal.II/numerics/matrix_tools.h>'
p29912
aS'#include <deal.II/numerics/data_out.h>'
p29913
aS'#include <deal.II/numerics/error_estimator.h>'
p29914
aS'#include <deal.II/lac/sparse_direct.h>'
p29915
aS'#include <deal.II/lac/sparse_ilu.h>'
p29916
aS'#include <deal.II/grid/grid_out.h>'
p29917
aS'#include <deal.II/base/timer.h>'
p29918
aS'#include <deal.II/multigrid/multigrid.h>'
p29919
aS'#include <deal.II/multigrid/mg_transfer.h>'
p29920
aS'#include <deal.II/multigrid/mg_tools.h>'
p29921
aS'#include <deal.II/multigrid/mg_coarse.h>'
p29922
aS'#include <deal.II/multigrid/mg_smoother.h>'
p29923
aS'#include <deal.II/multigrid/mg_matrix.h>'
p29924
aS'#include <iostream>'
p29925
aS'#include <fstream>'
p29926
aS'namespace Step56'
p29927
ag9
aS'  using namespace dealii;'
p29928
aS'  enum class SolverType'
p29929
aS'  {'
p29930
aS'    FGMRES_ILU,'
p29931
aS'    FGMRES_GMG,'
p29932
aS'    UMFPACK'
p29933
aS'  };'
p29934
aS'  template <int dim>'
p29935
aS'  class Solution : public Function<dim>'
p29936
aS'  {'
p29937
aS'  public:'
p29938
aS'    Solution()'
p29939
aS'      : Function<dim>(dim + 1)'
p29940
aS'    {}'
p29941
aS'    virtual double value(const Point<dim> & p,'
p29942
aS'                         const unsigned int component = 0) const override;'
p29943
aS'    virtual Tensor<1, dim>'
p29944
aS'    gradient(const Point<dim> & p,'
p29945
aS'             const unsigned int component = 0) const override;'
p29946
aS'  };'
p29947
aS'  template <>'
p29948
aS'  double Solution<2>::value(const Point<2> &   p,'
p29949
aS'                            const unsigned int component) const'
p29950
aS'  {'
p29951
aS'    Assert(component <= 2 + 1, ExcIndexRange(component, 0, 2 + 1));'
p29952
aS'    using numbers::PI;'
p29953
aS'    const double x = p(0);'
p29954
aS'    const double y = p(1);'
p29955
aS'    if (component == 0)'
p29956
aS'      return sin(PI * x);'
p29957
aS'    if (component == 1)'
p29958
aS'      return -PI * y * cos(PI * x);'
p29959
aS'    if (component == 2)'
p29960
aS'      return sin(PI * x) * cos(PI * y);'
p29961
aS'    return 0;'
p29962
aS'  }'
p29963
aS'  template <>'
p29964
aS'  double Solution<3>::value(const Point<3> &   p,'
p29965
aS'                            const unsigned int component) const'
p29966
aS'  {'
p29967
aS'    Assert(component <= 3 + 1, ExcIndexRange(component, 0, 3 + 1));'
p29968
aS'    using numbers::PI;'
p29969
aS'    const double x = p(0);'
p29970
aS'    const double y = p(1);'
p29971
aS'    const double z = p(2);'
p29972
aS'    if (component == 0)'
p29973
aS'      return 2.0 * sin(PI * x);'
p29974
aS'    if (component == 1)'
p29975
aS'      return -PI * y * cos(PI * x);'
p29976
aS'    if (component == 2)'
p29977
aS'      return -PI * z * cos(PI * x);'
p29978
aS'    if (component == 3)'
p29979
aS'      return sin(PI * x) * cos(PI * y) * sin(PI * z);'
p29980
aS'    return 0;'
p29981
aS'  }'
p29982
aS'  template <>'
p29983
aS'  Tensor<1, 2> Solution<2>::gradient(const Point<2> &   p,'
p29984
aS'                                     const unsigned int component) const'
p29985
aS'  {'
p29986
aS'    Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));'
p29987
aS'    using numbers::PI;'
p29988
aS'    const double x = p(0);'
p29989
aS'    const double y = p(1);'
p29990
aS'    Tensor<1, 2> return_value;'
p29991
aS'    if (component == 0)'
p29992
aS'      {'
p29993
aS'        return_value[0] = PI * cos(PI * x);'
p29994
aS'        return_value[1] = 0.0;'
p29995
aS'      }'
p29996
aS'    else if (component == 1)'
p29997
aS'      {'
p29998
aS'        return_value[0] = y * PI * PI * sin(PI * x);'
p29999
aS'        return_value[1] = -PI * cos(PI * x);'
p30000
aS'      }'
p30001
aS'    else if (component == 2)'
p30002
aS'      {'
p30003
aS'        return_value[0] = PI * cos(PI * x) * cos(PI * y);'
p30004
aS'        return_value[1] = -PI * sin(PI * x) * sin(PI * y);'
p30005
aS'      }'
p30006
aS'    return return_value;'
p30007
aS'  }'
p30008
aS'  template <>'
p30009
aS'  Tensor<1, 3> Solution<3>::gradient(const Point<3> &   p,'
p30010
aS'                                     const unsigned int component) const'
p30011
aS'  {'
p30012
aS'    Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));'
p30013
aS'    using numbers::PI;'
p30014
aS'    const double x = p(0);'
p30015
aS'    const double y = p(1);'
p30016
aS'    const double z = p(2);'
p30017
aS'    Tensor<1, 3> return_value;'
p30018
aS'    if (component == 0)'
p30019
aS'      {'
p30020
aS'        return_value[0] = 2 * PI * cos(PI * x);'
p30021
aS'        return_value[1] = 0.0;'
p30022
aS'        return_value[2] = 0.0;'
p30023
aS'      }'
p30024
aS'    else if (component == 1)'
p30025
aS'      {'
p30026
aS'        return_value[0] = y * PI * PI * sin(PI * x);'
p30027
aS'        return_value[1] = -PI * cos(PI * x);'
p30028
aS'        return_value[2] = 0.0;'
p30029
aS'      }'
p30030
aS'    else if (component == 2)'
p30031
aS'      {'
p30032
aS'        return_value[0] = z * PI * PI * sin(PI * x);'
p30033
aS'        return_value[1] = 0.0;'
p30034
aS'        return_value[2] = -PI * cos(PI * x);'
p30035
aS'      }'
p30036
aS'    else if (component == 3)'
p30037
aS'      {'
p30038
aS'        return_value[0] = PI * cos(PI * x) * cos(PI * y) * sin(PI * z);'
p30039
aS'        return_value[1] = -PI * sin(PI * x) * sin(PI * y) * sin(PI * z);'
p30040
aS'        return_value[2] = PI * sin(PI * x) * cos(PI * y) * cos(PI * z);'
p30041
aS'      }'
p30042
aS'    return return_value;'
p30043
aS'  }'
p30044
aS'  template <int dim>'
p30045
aS'  class RightHandSide : public Function<dim>'
p30046
aS'  {'
p30047
aS'  public:'
p30048
aS'    RightHandSide()'
p30049
aS'      : Function<dim>(dim + 1)'
p30050
aS'    {}'
p30051
aS'    virtual double value(const Point<dim> & p,'
p30052
aS'                         const unsigned int component = 0) const override;'
p30053
aS'  };'
p30054
aS'  template <>'
p30055
aS'  double RightHandSide<2>::value(const Point<2> &   p,'
p30056
aS'                                 const unsigned int component) const'
p30057
aS'  {'
p30058
aS'    Assert(component <= 2, ExcIndexRange(component, 0, 2 + 1));'
p30059
aS'    using numbers::PI;'
p30060
aS'    double x = p(0);'
p30061
aS'    double y = p(1);'
p30062
aS'    if (component == 0)'
p30063
aS'      return PI * PI * sin(PI * x) + PI * cos(PI * x) * cos(PI * y);'
p30064
aS'    if (component == 1)'
p30065
aS'      return -PI * PI * PI * y * cos(PI * x) - PI * sin(PI * y) * sin(PI * x);'
p30066
aS'    if (component == 2)'
p30067
aS'      return 0;'
p30068
aS'    return 0;'
p30069
aS'  }'
p30070
aS'  template <>'
p30071
aS'  double RightHandSide<3>::value(const Point<3> &   p,'
p30072
aS'                                 const unsigned int component) const'
p30073
aS'  {'
p30074
aS'    Assert(component <= 3, ExcIndexRange(component, 0, 3 + 1));'
p30075
aS'    using numbers::PI;'
p30076
aS'    double x = p(0);'
p30077
aS'    double y = p(1);'
p30078
aS'    double z = p(2);'
p30079
aS'    if (component == 0)'
p30080
aS'      return 2 * PI * PI * sin(PI * x) +'
p30081
aS'             PI * cos(PI * x) * cos(PI * y) * sin(PI * z);'
p30082
aS'    if (component == 1)'
p30083
aS'      return -PI * PI * PI * y * cos(PI * x) +'
p30084
aS'             PI * (-1) * sin(PI * y) * sin(PI * x) * sin(PI * z);'
p30085
aS'    if (component == 2)'
p30086
aS'      return -PI * PI * PI * z * cos(PI * x) +'
p30087
aS'             PI * cos(PI * z) * sin(PI * x) * cos(PI * y);'
p30088
aS'    if (component == 3)'
p30089
aS'      return 0;'
p30090
aS'    return 0;'
p30091
aS'  }'
p30092
aS'  template <class PreconditionerAType, class PreconditionerSType>'
p30093
aS'  class BlockSchurPreconditioner : public Subscriptor'
p30094
aS'  {'
p30095
aS'  public:'
p30096
aS'    BlockSchurPreconditioner('
p30097
aS'      const BlockSparseMatrix<double> &system_matrix,'
p30098
aS'      const SparseMatrix<double> &     schur_complement_matrix,'
p30099
aS'      const PreconditionerAType &      preconditioner_A,'
p30100
aS'      const PreconditionerSType &      preconditioner_S,'
p30101
aS'      const bool                       do_solve_A);'
p30102
aS'    void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;'
p30103
aS'    mutable unsigned int n_iterations_A;'
p30104
aS'    mutable unsigned int n_iterations_S;'
p30105
aS'  private:'
p30106
aS'    const BlockSparseMatrix<double> &system_matrix;'
p30107
aS'    const SparseMatrix<double> &     schur_complement_matrix;'
p30108
aS'    const PreconditionerAType &      preconditioner_A;'
p30109
aS'    const PreconditionerSType &      preconditioner_S;'
p30110
aS'    const bool do_solve_A;'
p30111
aS'  };'
p30112
aS'  template <class PreconditionerAType, class PreconditionerSType>'
p30113
aS'  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::'
p30114
aS'    BlockSchurPreconditioner('
p30115
aS'      const BlockSparseMatrix<double> &system_matrix,'
p30116
aS'      const SparseMatrix<double> &     schur_complement_matrix,'
p30117
aS'      const PreconditionerAType &      preconditioner_A,'
p30118
aS'      const PreconditionerSType &      preconditioner_S,'
p30119
aS'      const bool                       do_solve_A)'
p30120
aS'    : n_iterations_A(0)'
p30121
aS'    , n_iterations_S(0)'
p30122
aS'    , system_matrix(system_matrix)'
p30123
aS'    , schur_complement_matrix(schur_complement_matrix)'
p30124
aS'    , preconditioner_A(preconditioner_A)'
p30125
aS'    , preconditioner_S(preconditioner_S)'
p30126
aS'    , do_solve_A(do_solve_A)'
p30127
aS'  {}'
p30128
aS'  template <class PreconditionerAType, class PreconditionerSType>'
p30129
aS'  void'
p30130
aS'  BlockSchurPreconditioner<PreconditionerAType, PreconditionerSType>::vmult('
p30131
aS'    BlockVector<double> &      dst,'
p30132
aS'    const BlockVector<double> &src) const'
p30133
aS'  {'
p30134
aS'    Vector<double> utmp(src.block(0));'
p30135
aS'    {'
p30136
aS'      SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());'
p30137
aS'      SolverCG<Vector<double>> cg(solver_control);'
p30138
aS'      dst.block(1) = 0.0;'
p30139
aS'      cg.solve(schur_complement_matrix,'
p30140
aS'               dst.block(1),'
p30141
aS'               src.block(1),'
p30142
aS'               preconditioner_S);'
p30143
aS'      n_iterations_S += solver_control.last_step();'
p30144
aS'      dst.block(1) *= -1.0;'
p30145
aS'    }'
p30146
aS'    {'
p30147
aS'      system_matrix.block(0, 1).vmult(utmp, dst.block(1));'
p30148
aS'      utmp *= -1.0;'
p30149
aS'      utmp += src.block(0);'
p30150
aS'    }'
p30151
aS'    if (do_solve_A == true)'
p30152
aS'      {'
p30153
aS'        SolverControl            solver_control(10000, utmp.l2_norm() * 1e-4);'
p30154
aS'        SolverCG<Vector<double>> cg(solver_control);'
p30155
aS'        dst.block(0) = 0.0;'
p30156
aS'        cg.solve(system_matrix.block(0, 0),'
p30157
aS'                 dst.block(0),'
p30158
aS'                 utmp,'
p30159
aS'                 preconditioner_A);'
p30160
aS'        n_iterations_A += solver_control.last_step();'
p30161
aS'      }'
p30162
aS'    else'
p30163
aS'      {'
p30164
aS'        preconditioner_A.vmult(dst.block(0), utmp);'
p30165
aS'        n_iterations_A += 1;'
p30166
aS'      }'
p30167
aS'  }'
p30168
aS'  template <int dim>'
p30169
aS'  class StokesProblem'
p30170
aS'  {'
p30171
aS'  public:'
p30172
aS'    StokesProblem(const unsigned int pressure_degree,'
p30173
aS'                  const SolverType   solver_type);'
p30174
aS'    void run();'
p30175
aS'  private:'
p30176
aS'    void setup_dofs();'
p30177
aS'    void assemble_system();'
p30178
aS'    void assemble_multigrid();'
p30179
aS'    void solve();'
p30180
aS'    void compute_errors();'
p30181
aS'    void output_results(const unsigned int refinement_cycle) const;'
p30182
aS'    const unsigned int pressure_degree;'
p30183
aS'    const SolverType   solver_type;'
p30184
aS'    Triangulation<dim> triangulation;'
p30185
aS'    FESystem<dim>      velocity_fe;'
p30186
aS'    FESystem<dim>      fe;'
p30187
aS'    DoFHandler<dim>    dof_handler;'
p30188
aS'    DoFHandler<dim>    velocity_dof_handler;'
p30189
aS'    AffineConstraints<double> constraints;'
p30190
aS'    BlockSparsityPattern      sparsity_pattern;'
p30191
aS'    BlockSparseMatrix<double> system_matrix;'
p30192
aS'    SparseMatrix<double>      pressure_mass_matrix;'
p30193
aS'    BlockVector<double> solution;'
p30194
aS'    BlockVector<double> system_rhs;'
p30195
aS'    MGLevelObject<SparsityPattern>      mg_sparsity_patterns;'
p30196
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p30197
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_matrices;'
p30198
aS'    MGConstrainedDoFs                   mg_constrained_dofs;'
p30199
aS'    TimerOutput computing_timer;'
p30200
aS'  };'
p30201
aS'  template <int dim>'
p30202
aS'  StokesProblem<dim>::StokesProblem(const unsigned int pressure_degree,'
p30203
aS'                                    const SolverType   solver_type)'
p30204
aS'    : pressure_degree(pressure_degree)'
p30205
aS'    , solver_type(solver_type)'
p30206
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p30207
aS'    ,'
p30208
aS'    velocity_fe(FE_Q<dim>(pressure_degree + 1), dim)'
p30209
aS'    ,'
p30210
aS'    fe(velocity_fe, 1, FE_Q<dim>(pressure_degree), 1)'
p30211
aS'    , dof_handler(triangulation)'
p30212
aS'    , velocity_dof_handler(triangulation)'
p30213
aS'    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times)'
p30214
aS'  {}'
p30215
aS'  template <int dim>'
p30216
aS'  void StokesProblem<dim>::setup_dofs()'
p30217
aS'  {'
p30218
aS'    TimerOutput::Scope scope(computing_timer, "Setup");'
p30219
aS'    system_matrix.clear();'
p30220
aS'    pressure_mass_matrix.clear();'
p30221
aS'    dof_handler.distribute_dofs(fe);'
p30222
aS'    std::vector<unsigned int> block_component(2);'
p30223
aS'    block_component[0] = 0;'
p30224
aS'    block_component[1] = 1;'
p30225
aS'    const FEValuesExtractors::Vector velocities(0);'
p30226
aS'    if (solver_type == SolverType::FGMRES_ILU)'
p30227
aS'      {'
p30228
aS'        TimerOutput::Scope ilu_specific(computing_timer, "(ILU specific)");'
p30229
aS'        DoFRenumbering::Cuthill_McKee(dof_handler);'
p30230
aS'      }'
p30231
aS'    DoFRenumbering::block_wise(dof_handler);'
p30232
aS'    if (solver_type == SolverType::FGMRES_GMG)'
p30233
aS'      {'
p30234
aS'        TimerOutput::Scope multigrid_specific(computing_timer,'
p30235
aS'                                              "(Multigrid specific)");'
p30236
aS'        TimerOutput::Scope setup_multigrid(computing_timer,'
p30237
aS'                                           "Setup - Multigrid");'
p30238
aS'        velocity_dof_handler.distribute_dofs(velocity_fe);'
p30239
aS'        velocity_dof_handler.distribute_mg_dofs();'
p30240
aS'        std::set<types::boundary_id> zero_boundary_ids;'
p30241
aS'        zero_boundary_ids.insert(0);'
p30242
aS'        mg_constrained_dofs.clear();'
p30243
aS'        mg_constrained_dofs.initialize(velocity_dof_handler);'
p30244
aS'        mg_constrained_dofs.make_zero_boundary_constraints(velocity_dof_handler,'
p30245
aS'                                                           zero_boundary_ids);'
p30246
aS'        const unsigned int n_levels = triangulation.n_levels();'
p30247
aS'        mg_interface_matrices.resize(0, n_levels - 1);'
p30248
aS'        mg_matrices.resize(0, n_levels - 1);'
p30249
aS'        mg_sparsity_patterns.resize(0, n_levels - 1);'
p30250
aS'        for (unsigned int level = 0; level < n_levels; ++level)'
p30251
aS'          {'
p30252
aS'            DynamicSparsityPattern csp(velocity_dof_handler.n_dofs(level),'
p30253
aS'                                       velocity_dof_handler.n_dofs(level));'
p30254
aS'            MGTools::make_sparsity_pattern(velocity_dof_handler, csp, level);'
p30255
aS'            mg_sparsity_patterns[level].copy_from(csp);'
p30256
aS'            mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p30257
aS'            mg_interface_matrices[level].reinit(mg_sparsity_patterns[level]);'
p30258
aS'          }'
p30259
aS'      }'
p30260
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p30261
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p30262
aS'    const unsigned int n_u = dofs_per_block[0];'
p30263
aS'    const unsigned int n_p = dofs_per_block[1];'
p30264
aS'    {'
p30265
aS'      constraints.clear();'
p30266
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p30267
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p30268
aS'                                               0,'
p30269
aS'                                               Solution<dim>(),'
p30270
aS'                                               constraints,'
p30271
aS'                                               fe.component_mask(velocities));'
p30272
aS'      if (solver_type == SolverType::UMFPACK)'
p30273
aS'        constraints.add_line(n_u);'
p30274
aS'      constraints.close();'
p30275
aS'    }'
p30276
aS'    std::cout << "\\tNumber of active cells: " << triangulation.n_active_cells()'
p30277
aS'              << std::endl'
p30278
aS'              << "\\tNumber of degrees of freedom: " << dof_handler.n_dofs()'
p30279
aS'              << " (" << n_u << \'+\' << n_p << \')\' << std::endl;'
p30280
aS'    {'
p30281
aS'      BlockDynamicSparsityPattern csp(dofs_per_block, dofs_per_block);'
p30282
aS'      DoFTools::make_sparsity_pattern(dof_handler, csp, constraints, false);'
p30283
aS'      sparsity_pattern.copy_from(csp);'
p30284
aS'    }'
p30285
aS'    system_matrix.reinit(sparsity_pattern);'
p30286
aS'    solution.reinit(dofs_per_block);'
p30287
aS'    system_rhs.reinit(dofs_per_block);'
p30288
aS'  }'
p30289
aS'  template <int dim>'
p30290
aS'  void StokesProblem<dim>::assemble_system()'
p30291
aS'  {'
p30292
aS'    TimerOutput::Scope assemble(computing_timer, "Assemble");'
p30293
aS'    system_matrix = 0;'
p30294
aS'    system_rhs    = 0;'
p30295
aS'    const bool assemble_pressure_mass_matrix ='
p30296
aS'    QGauss<dim> quadrature_formula(pressure_degree + 2);'
p30297
aS'    FEValues<dim> fe_values(fe,'
p30298
aS'                            quadrature_formula,'
p30299
aS'                            update_values | update_quadrature_points |'
p30300
aS'                              update_JxW_values | update_gradients);'
p30301
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p30302
aS'    const unsigned int n_q_points = quadrature_formula.size();'
p30303
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p30304
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p30305
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p30306
aS'    const RightHandSide<dim>    right_hand_side;'
p30307
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim + 1));'
p30308
aS'    const FEValuesExtractors::Vector velocities(0);'
p30309
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p30310
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p30311
aS'    std::vector<double>                  div_phi_u(dofs_per_cell);'
p30312
aS'    std::vector<double>                  phi_p(dofs_per_cell);'
p30313
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p30314
aS'      {'
p30315
aS'        fe_values.reinit(cell);'
p30316
aS'        local_matrix = 0;'
p30317
aS'        local_rhs    = 0;'
p30318
aS'        right_hand_side.vector_value_list(fe_values.get_quadrature_points(),'
p30319
aS'                                          rhs_values);'
p30320
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p30321
aS'          {'
p30322
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p30323
aS'              {'
p30324
aS'                symgrad_phi_u[k] ='
p30325
aS'                  fe_values[velocities].symmetric_gradient(k, q);'
p30326
aS'                div_phi_u[k] = fe_values[velocities].divergence(k, q);'
p30327
aS'                phi_p[k]     = fe_values[pressure].value(k, q);'
p30328
aS'              }'
p30329
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p30330
aS'              {'
p30331
aS'                for (unsigned int j = 0; j <= i; ++j)'
p30332
aS'                  {'
p30333
aS'                    local_matrix(i, j) +='
p30334
aS'                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +'
p30335
aS'                                                        0)) *'
p30336
aS'                      fe_values.JxW(q);'
p30337
aS'                  }'
p30338
aS'                const unsigned int component_i ='
p30339
aS'                  fe.system_to_component_index(i).first;'
p30340
aS'                local_rhs(i) += fe_values.shape_value(i, q) *'
p30341
aS'                                rhs_values[q](component_i) * fe_values.JxW(q);'
p30342
aS'              }'
p30343
aS'          }'
p30344
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p30345
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p30346
aS'            local_matrix(i, j) = local_matrix(j, i);'
p30347
aS'        cell->get_dof_indices(local_dof_indices);'
p30348
aS'        constraints.distribute_local_to_global(local_matrix,'
p30349
aS'                                               local_rhs,'
p30350
aS'                                               local_dof_indices,'
p30351
aS'                                               system_matrix,'
p30352
aS'                                               system_rhs);'
p30353
aS'      }'
p30354
aS'    if (solver_type != SolverType::UMFPACK)'
p30355
aS'      {'
p30356
aS'        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));'
p30357
aS'        pressure_mass_matrix.copy_from(system_matrix.block(1, 1));'
p30358
aS'        system_matrix.block(1, 1) = 0;'
p30359
aS'      }'
p30360
aS'  }'
p30361
aS'  template <int dim>'
p30362
aS'  void StokesProblem<dim>::assemble_multigrid()'
p30363
aS'  {'
p30364
aS'    TimerOutput::Scope multigrid_specific(computing_timer,'
p30365
aS'                                          "(Multigrid specific)");'
p30366
aS'    TimerOutput::Scope assemble_multigrid(computing_timer,'
p30367
aS'                                          "Assemble Multigrid");'
p30368
aS'    mg_matrices = 0.;'
p30369
aS'    QGauss<dim> quadrature_formula(pressure_degree + 2);'
p30370
aS'    FEValues<dim> fe_values(velocity_fe,'
p30371
aS'                            quadrature_formula,'
p30372
aS'                            update_values | update_quadrature_points |'
p30373
aS'                              update_JxW_values | update_gradients);'
p30374
aS'    const unsigned int dofs_per_cell = velocity_fe.n_dofs_per_cell();'
p30375
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p30376
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p30377
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p30378
aS'    const FEValuesExtractors::Vector velocities(0);'
p30379
aS'    std::vector<SymmetricTensor<2, dim>> symgrad_phi_u(dofs_per_cell);'
p30380
aS'    std::vector<AffineConstraints<double>> boundary_constraints('
p30381
aS'      triangulation.n_levels());'
p30382
aS'    std::vector<AffineConstraints<double>> boundary_interface_constraints('
p30383
aS'      triangulation.n_levels());'
p30384
aS'    for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p30385
aS'      {'
p30386
aS'        boundary_constraints[level].add_lines('
p30387
aS'          mg_constrained_dofs.get_refinement_edge_indices(level));'
p30388
aS'        boundary_constraints[level].add_lines('
p30389
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p30390
aS'        boundary_constraints[level].close();'
p30391
aS'        IndexSet idx = mg_constrained_dofs.get_refinement_edge_indices(level) &'
p30392
aS'                       mg_constrained_dofs.get_boundary_indices(level);'
p30393
aS'        boundary_interface_constraints[level].add_lines(idx);'
p30394
aS'        boundary_interface_constraints[level].close();'
p30395
aS'      }'
p30396
aS'    for (const auto &cell : velocity_dof_handler.cell_iterators())'
p30397
aS'      {'
p30398
aS'        fe_values.reinit(cell);'
p30399
aS'        cell_matrix = 0;'
p30400
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p30401
aS'          {'
p30402
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p30403
aS'              symgrad_phi_u[k] = fe_values[velocities].symmetric_gradient(k, q);'
p30404
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p30405
aS'              for (unsigned int j = 0; j <= i; ++j)'
p30406
aS'                {'
p30407
aS'                  cell_matrix(i, j) +='
p30408
aS'                }'
p30409
aS'          }'
p30410
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p30411
aS'          for (unsigned int j = i + 1; j < dofs_per_cell; ++j)'
p30412
aS'            cell_matrix(i, j) = cell_matrix(j, i);'
p30413
aS'        cell->get_mg_dof_indices(local_dof_indices);'
p30414
aS'        boundary_constraints[cell->level()].distribute_local_to_global('
p30415
aS'          cell_matrix, local_dof_indices, mg_matrices[cell->level()]);'
p30416
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p30417
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p30418
aS'            if (!mg_constrained_dofs.at_refinement_edge(cell->level(),'
p30419
aS'                                                        local_dof_indices[i]) ||'
p30420
aS'                mg_constrained_dofs.at_refinement_edge(cell->level(),'
p30421
aS'                                                       local_dof_indices[j]))'
p30422
aS'              cell_matrix(i, j) = 0;'
p30423
aS'        boundary_interface_constraints[cell->level()]'
p30424
aS'          .distribute_local_to_global(cell_matrix,'
p30425
aS'                                      local_dof_indices,'
p30426
aS'                                      mg_interface_matrices[cell->level()]);'
p30427
aS'      }'
p30428
aS'  }'
p30429
aS'  template <int dim>'
p30430
aS'  void StokesProblem<dim>::solve()'
p30431
aS'  {'
p30432
aS'    TimerOutput::Scope solve(computing_timer, "Solve");'
p30433
aS'    constraints.set_zero(solution);'
p30434
aS'    if (solver_type == SolverType::UMFPACK)'
p30435
aS'      {'
p30436
aS'        computing_timer.enter_subsection("(UMFPACK specific)");'
p30437
aS'        computing_timer.enter_subsection("Solve - Initialize");'
p30438
aS'        SparseDirectUMFPACK A_direct;'
p30439
aS'        A_direct.initialize(system_matrix);'
p30440
aS'        computing_timer.leave_subsection();'
p30441
aS'        computing_timer.leave_subsection();'
p30442
aS'        {'
p30443
aS'          TimerOutput::Scope solve_backslash(computing_timer,'
p30444
aS'                                             "Solve - Backslash");'
p30445
aS'          A_direct.vmult(solution, system_rhs);'
p30446
aS'        }'
p30447
aS'        constraints.distribute(solution);'
p30448
aS'        return;'
p30449
aS'      }'
p30450
aS'    SolverControl solver_control(system_matrix.m(),'
p30451
aS'                                 1e-10 * system_rhs.l2_norm());'
p30452
aS'    unsigned int  n_iterations_A;'
p30453
aS'    unsigned int  n_iterations_S;'
p30454
aS'    const bool use_expensive = true;'
p30455
aS'    SolverFGMRES<BlockVector<double>> solver(solver_control);'
p30456
aS'    if (solver_type == SolverType::FGMRES_ILU)'
p30457
aS'      {'
p30458
aS'        computing_timer.enter_subsection("(ILU specific)");'
p30459
aS'        computing_timer.enter_subsection("Solve - Set-up Preconditioner");'
p30460
aS'        std::cout << "   Computing preconditioner..." << std::endl'
p30461
aS'                  << std::flush;'
p30462
aS'        SparseILU<double> A_preconditioner;'
p30463
aS'        A_preconditioner.initialize(system_matrix.block(0, 0));'
p30464
aS'        SparseILU<double> S_preconditioner;'
p30465
aS'        S_preconditioner.initialize(pressure_mass_matrix);'
p30466
aS'        const BlockSchurPreconditioner<SparseILU<double>, SparseILU<double>>'
p30467
aS'          preconditioner(system_matrix,'
p30468
aS'                         pressure_mass_matrix,'
p30469
aS'                         A_preconditioner,'
p30470
aS'                         S_preconditioner,'
p30471
aS'                         use_expensive);'
p30472
aS'        computing_timer.leave_subsection();'
p30473
aS'        computing_timer.leave_subsection();'
p30474
aS'        {'
p30475
aS'          TimerOutput::Scope solve_fmgres(computing_timer, "Solve - FGMRES");'
p30476
aS'          solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p30477
aS'          n_iterations_A = preconditioner.n_iterations_A;'
p30478
aS'          n_iterations_S = preconditioner.n_iterations_S;'
p30479
aS'        }'
p30480
aS'      }'
p30481
aS'    else'
p30482
aS'      {'
p30483
aS'        computing_timer.enter_subsection("(Multigrid specific)");'
p30484
aS'        computing_timer.enter_subsection("Solve - Set-up Preconditioner");'
p30485
aS'        MGTransferPrebuilt<Vector<double>> mg_transfer(mg_constrained_dofs);'
p30486
aS'        mg_transfer.build(velocity_dof_handler);'
p30487
aS'        FullMatrix<double> coarse_matrix;'
p30488
aS'        coarse_matrix.copy_from(mg_matrices[0]);'
p30489
aS'        MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p30490
aS'        coarse_grid_solver.initialize(coarse_matrix);'
p30491
aS'        using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p30492
aS'        mg::SmootherRelaxation<Smoother, Vector<double>> mg_smoother;'
p30493
aS'        mg_smoother.initialize(mg_matrices);'
p30494
aS'        mg_smoother.set_steps(2);'
p30495
aS'        mg_smoother.set_symmetric(true);'
p30496
aS'        mg::Matrix<Vector<double>> mg_matrix(mg_matrices);'
p30497
aS'        mg::Matrix<Vector<double>> mg_interface_up(mg_interface_matrices);'
p30498
aS'        mg::Matrix<Vector<double>> mg_interface_down(mg_interface_matrices);'
p30499
aS'        Multigrid<Vector<double>> mg('
p30500
aS'          mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);'
p30501
aS'        mg.set_edge_matrices(mg_interface_down, mg_interface_up);'
p30502
aS'        PreconditionMG<dim, Vector<double>, MGTransferPrebuilt<Vector<double>>>'
p30503
aS'          A_Multigrid(velocity_dof_handler, mg, mg_transfer);'
p30504
aS'        SparseILU<double> S_preconditioner;'
p30505
aS'        S_preconditioner.initialize(pressure_mass_matrix,'
p30506
aS'                                    SparseILU<double>::AdditionalData());'
p30507
aS'        const BlockSchurPreconditioner<'
p30508
aS'          PreconditionMG<dim,'
p30509
aS'                         Vector<double>,'
p30510
aS'                         MGTransferPrebuilt<Vector<double>>>,'
p30511
aS'          SparseILU<double>>'
p30512
aS'          preconditioner(system_matrix,'
p30513
aS'                         pressure_mass_matrix,'
p30514
aS'                         A_Multigrid,'
p30515
aS'                         S_preconditioner,'
p30516
aS'                         use_expensive);'
p30517
aS'        computing_timer.leave_subsection();'
p30518
aS'        computing_timer.leave_subsection();'
p30519
aS'        {'
p30520
aS'          TimerOutput::Scope solve_fmgres(computing_timer, "Solve - FGMRES");'
p30521
aS'          solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p30522
aS'          n_iterations_A = preconditioner.n_iterations_A;'
p30523
aS'          n_iterations_S = preconditioner.n_iterations_S;'
p30524
aS'        }'
p30525
aS'      }'
p30526
aS'    constraints.distribute(solution);'
p30527
aS'    std::cout'
p30528
aS'      << std::endl'
p30529
aS'      << "\\tNumber of FGMRES iterations: " << solver_control.last_step()'
p30530
aS'      << std::endl'
p30531
aS'      << "\\tTotal number of iterations used for approximation of A inverse: "'
p30532
aS'      << n_iterations_A << std::endl'
p30533
aS'      << "\\tTotal number of iterations used for approximation of S inverse: "'
p30534
aS'      << n_iterations_S << std::endl'
p30535
aS'      << std::endl;'
p30536
aS'  }'
p30537
aS'  template <int dim>'
p30538
aS'  void StokesProblem<dim>::compute_errors()'
p30539
aS'  {'
p30540
aS'    const double mean_pressure = VectorTools::compute_mean_value('
p30541
aS'      dof_handler, QGauss<dim>(pressure_degree + 2), solution, dim);'
p30542
aS'    solution.block(1).add(-mean_pressure);'
p30543
aS'    std::cout << "   Note: The mean value was adjusted by " << -mean_pressure'
p30544
aS'              << std::endl;'
p30545
aS'    const ComponentSelectFunction<dim> pressure_mask(dim, dim + 1);'
p30546
aS'    const ComponentSelectFunction<dim> velocity_mask(std::make_pair(0, dim),'
p30547
aS'                                                     dim + 1);'
p30548
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p30549
aS'    VectorTools::integrate_difference(dof_handler,'
p30550
aS'                                      solution,'
p30551
aS'                                      Solution<dim>(),'
p30552
aS'                                      difference_per_cell,'
p30553
aS'                                      QGauss<dim>(pressure_degree + 2),'
p30554
aS'                                      VectorTools::L2_norm,'
p30555
aS'                                      &velocity_mask);'
p30556
aS'    const double Velocity_L2_error ='
p30557
aS'      VectorTools::compute_global_error(triangulation,'
p30558
aS'                                        difference_per_cell,'
p30559
aS'                                        VectorTools::L2_norm);'
p30560
aS'    VectorTools::integrate_difference(dof_handler,'
p30561
aS'                                      solution,'
p30562
aS'                                      Solution<dim>(),'
p30563
aS'                                      difference_per_cell,'
p30564
aS'                                      QGauss<dim>(pressure_degree + 2),'
p30565
aS'                                      VectorTools::L2_norm,'
p30566
aS'                                      &pressure_mask);'
p30567
aS'    const double Pressure_L2_error ='
p30568
aS'      VectorTools::compute_global_error(triangulation,'
p30569
aS'                                        difference_per_cell,'
p30570
aS'                                        VectorTools::L2_norm);'
p30571
aS'    VectorTools::integrate_difference(dof_handler,'
p30572
aS'                                      solution,'
p30573
aS'                                      Solution<dim>(),'
p30574
aS'                                      difference_per_cell,'
p30575
aS'                                      QGauss<dim>(pressure_degree + 2),'
p30576
aS'                                      VectorTools::H1_norm,'
p30577
aS'                                      &velocity_mask);'
p30578
aS'    const double Velocity_H1_error ='
p30579
aS'      VectorTools::compute_global_error(triangulation,'
p30580
aS'                                        difference_per_cell,'
p30581
aS'                                        VectorTools::H1_norm);'
p30582
aS'    std::cout << std::endl'
p30583
aS'              << "   Velocity L2 Error: " << Velocity_L2_error << std::endl'
p30584
aS'              << "   Pressure L2 Error: " << Pressure_L2_error << std::endl'
p30585
aS'              << "   Velocity H1 Error: " << Velocity_H1_error << std::endl;'
p30586
aS'  }'
p30587
aS'  template <int dim>'
p30588
aS'  void'
p30589
aS'  StokesProblem<dim>::output_results(const unsigned int refinement_cycle) const'
p30590
aS'  {'
p30591
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p30592
aS'    solution_names.emplace_back("pressure");'
p30593
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p30594
aS'      data_component_interpretation('
p30595
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p30596
aS'    data_component_interpretation.push_back('
p30597
aS'      DataComponentInterpretation::component_is_scalar);'
p30598
aS'    DataOut<dim> data_out;'
p30599
aS'    data_out.attach_dof_handler(dof_handler);'
p30600
aS'    data_out.add_data_vector(solution,'
p30601
aS'                             solution_names,'
p30602
aS'                             DataOut<dim>::type_dof_data,'
p30603
aS'                             data_component_interpretation);'
p30604
aS'    data_out.build_patches();'
p30605
aS'    std::ofstream output('
p30606
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtk");'
p30607
aS'    data_out.write_vtk(output);'
p30608
aS'  }'
p30609
aS'  template <int dim>'
p30610
aS'  void StokesProblem<dim>::run()'
p30611
aS'  {'
p30612
aS'    GridGenerator::hyper_cube(triangulation);'
p30613
aS'    triangulation.refine_global(6 - dim);'
p30614
aS'    if (solver_type == SolverType::FGMRES_ILU)'
p30615
aS'      std::cout << "Now running with ILU" << std::endl;'
p30616
aS'    else if (solver_type == SolverType::FGMRES_GMG)'
p30617
aS'      std::cout << "Now running with Multigrid" << std::endl;'
p30618
aS'    else'
p30619
aS'      std::cout << "Now running with UMFPACK" << std::endl;'
p30620
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 3;'
p30621
aS'         ++refinement_cycle)'
p30622
aS'      {'
p30623
aS'        std::cout << "Refinement cycle " << refinement_cycle << std::endl;'
p30624
aS'        if (refinement_cycle > 0)'
p30625
aS'          triangulation.refine_global(1);'
p30626
aS'        std::cout << "   Set-up..." << std::endl;'
p30627
aS'        setup_dofs();'
p30628
aS'        std::cout << "   Assembling..." << std::endl;'
p30629
aS'        assemble_system();'
p30630
aS'        if (solver_type == SolverType::FGMRES_GMG)'
p30631
aS'          {'
p30632
aS'            std::cout << "   Assembling Multigrid..." << std::endl;'
p30633
aS'            assemble_multigrid();'
p30634
aS'          }'
p30635
aS'        std::cout << "   Solving..." << std::flush;'
p30636
aS'        solve();'
p30637
aS'        compute_errors();'
p30638
aS'        output_results(refinement_cycle);'
p30639
aS'        Utilities::System::MemoryStats mem;'
p30640
aS'        Utilities::System::get_memory_stats(mem);'
p30641
aS'        std::cout << "   VM Peak: " << mem.VmPeak << std::endl;'
p30642
aS'        computing_timer.print_summary();'
p30643
aS'        computing_timer.reset();'
p30644
aS'      }'
p30645
aS'  }'
p30646
aS'} // namespace Step56'
p30647
aS'int main()'
p30648
ag9
aS'  try'
p30649
aS'    {'
p30650
aS'      using namespace Step56;'
p30651
aS'      const int degree = 1;'
p30652
aS'      const int dim    = 3;'
p30653
aS'      StokesProblem<dim> flow_problem(degree, SolverType::FGMRES_GMG);'
p30654
aS'      flow_problem.run();'
p30655
aS'    }'
p30656
aS'  catch (std::exception &exc)'
p30657
aS'    {'
p30658
aS'      std::cerr << std::endl'
p30659
aS'                << std::endl'
p30660
aS'                << "----------------------------------------------------"'
p30661
aS'                << std::endl;'
p30662
aS'      std::cerr << "Exception on processing: " << std::endl'
p30663
aS'                << exc.what() << std::endl'
p30664
aS'                << "Aborting!" << std::endl'
p30665
aS'                << "----------------------------------------------------"'
p30666
aS'                << std::endl;'
p30667
aS'      return 1;'
p30668
aS'    }'
p30669
aS'  catch (...)'
p30670
aS'    {'
p30671
aS'      std::cerr << std::endl'
p30672
aS'                << std::endl'
p30673
aS'                << "----------------------------------------------------"'
p30674
aS'                << std::endl;'
p30675
aS'      std::cerr << "Unknown exception!" << std::endl'
p30676
aS'                << "Aborting!" << std::endl'
p30677
aS'                << "----------------------------------------------------"'
p30678
aS'                << std::endl;'
p30679
aS'      return 1;'
p30680
aS'    }'
p30681
aS'  return 0;'
p30682
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p30683
aS'#include <deal.II/base/function.h>'
p30684
aS'#include <deal.II/base/utilities.h>'
p30685
aS'#include <deal.II/base/tensor.h>'
p30686
aS'#include <deal.II/lac/block_vector.h>'
p30687
aS'#include <deal.II/lac/full_matrix.h>'
p30688
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p30689
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p30690
aS'#include <deal.II/lac/solver_cg.h>'
p30691
aS'#include <deal.II/lac/solver_gmres.h>'
p30692
aS'#include <deal.II/lac/precondition.h>'
p30693
aS'#include <deal.II/lac/affine_constraints.h>'
p30694
aS'#include <deal.II/grid/tria.h>'
p30695
aS'#include <deal.II/grid/grid_generator.h>'
p30696
aS'#include <deal.II/grid/grid_refinement.h>'
p30697
aS'#include <deal.II/grid/grid_tools.h>'
p30698
aS'#include <deal.II/dofs/dof_handler.h>'
p30699
aS'#include <deal.II/dofs/dof_renumbering.h>'
p30700
aS'#include <deal.II/dofs/dof_tools.h>'
p30701
aS'#include <deal.II/fe/fe_q.h>'
p30702
aS'#include <deal.II/fe/fe_system.h>'
p30703
aS'#include <deal.II/fe/fe_values.h>'
p30704
aS'#include <deal.II/numerics/vector_tools.h>'
p30705
aS'#include <deal.II/numerics/matrix_tools.h>'
p30706
aS'#include <deal.II/numerics/data_out.h>'
p30707
aS'#include <deal.II/numerics/error_estimator.h>'
p30708
aS'#include <deal.II/numerics/solution_transfer.h>'
p30709
aS'#include <deal.II/lac/sparse_direct.h>'
p30710
aS'#include <deal.II/lac/sparse_ilu.h>'
p30711
aS'#include <fstream>'
p30712
aS'#include <iostream>'
p30713
aS'namespace Step57'
p30714
ag9
aS'  using namespace dealii;'
p30715
aS'  template <int dim>'
p30716
aS'  class StationaryNavierStokes'
p30717
aS'  {'
p30718
aS'  public:'
p30719
aS'    StationaryNavierStokes(const unsigned int degree);'
p30720
aS'    void run(const unsigned int refinement);'
p30721
aS'  private:'
p30722
aS'    void setup_dofs();'
p30723
aS'    void initialize_system();'
p30724
aS'    void assemble(const bool initial_step, const bool assemble_matrix);'
p30725
aS'    void assemble_system(const bool initial_step);'
p30726
aS'    void assemble_rhs(const bool initial_step);'
p30727
aS'    void solve(const bool initial_step);'
p30728
aS'    void refine_mesh();'
p30729
aS'    void process_solution(unsigned int refinement);'
p30730
aS'    void output_results(const unsigned int refinement_cycle) const;'
p30731
aS'    void newton_iteration(const double       tolerance,'
p30732
aS'                          const unsigned int max_n_line_searches,'
p30733
aS'                          const unsigned int max_n_refinements,'
p30734
aS'                          const bool         is_initial_step,'
p30735
aS'                          const bool         output_result);'
p30736
aS'    void compute_initial_guess(double step_size);'
p30737
aS'    double                               viscosity;'
p30738
aS'    double                               gamma;'
p30739
aS'    const unsigned int                   degree;'
p30740
aS'    std::vector<types::global_dof_index> dofs_per_block;'
p30741
aS'    Triangulation<dim> triangulation;'
p30742
aS'    FESystem<dim>      fe;'
p30743
aS'    DoFHandler<dim>    dof_handler;'
p30744
aS'    AffineConstraints<double> zero_constraints;'
p30745
aS'    AffineConstraints<double> nonzero_constraints;'
p30746
aS'    BlockSparsityPattern      sparsity_pattern;'
p30747
aS'    BlockSparseMatrix<double> system_matrix;'
p30748
aS'    SparseMatrix<double>      pressure_mass_matrix;'
p30749
aS'    BlockVector<double> present_solution;'
p30750
aS'    BlockVector<double> newton_update;'
p30751
aS'    BlockVector<double> system_rhs;'
p30752
aS'    BlockVector<double> evaluation_point;'
p30753
aS'  };'
p30754
aS'  template <int dim>'
p30755
aS'  class BoundaryValues : public Function<dim>'
p30756
aS'  {'
p30757
aS'  public:'
p30758
aS'    BoundaryValues()'
p30759
aS'      : Function<dim>(dim + 1)'
p30760
aS'    {}'
p30761
aS'    virtual double value(const Point<dim> & p,'
p30762
aS'                         const unsigned int component) const override;'
p30763
aS'  };'
p30764
aS'  template <int dim>'
p30765
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p30766
aS'                                    const unsigned int component) const'
p30767
aS'  {'
p30768
aS'    Assert(component < this->n_components,'
p30769
aS'           ExcIndexRange(component, 0, this->n_components));'
p30770
aS'    if (component == 0 && std::abs(p[dim - 1] - 1.0) < 1e-10)'
p30771
aS'      return 1.0;'
p30772
aS'    return 0;'
p30773
aS'  }'
p30774
aS'  template <class PreconditionerMp>'
p30775
aS'  class BlockSchurPreconditioner : public Subscriptor'
p30776
aS'  {'
p30777
aS'  public:'
p30778
aS'    BlockSchurPreconditioner(double                           gamma,'
p30779
aS'                             double                           viscosity,'
p30780
aS'                             const BlockSparseMatrix<double> &S,'
p30781
aS'                             const SparseMatrix<double> &     P,'
p30782
aS'                             const PreconditionerMp &         Mppreconditioner);'
p30783
aS'    void vmult(BlockVector<double> &dst, const BlockVector<double> &src) const;'
p30784
aS'  private:'
p30785
aS'    const double                     gamma;'
p30786
aS'    const double                     viscosity;'
p30787
aS'    const BlockSparseMatrix<double> &stokes_matrix;'
p30788
aS'    const SparseMatrix<double> &     pressure_mass_matrix;'
p30789
aS'    const PreconditionerMp &         mp_preconditioner;'
p30790
aS'    SparseDirectUMFPACK              A_inverse;'
p30791
aS'  };'
p30792
aS'  template <class PreconditionerMp>'
p30793
aS'  BlockSchurPreconditioner<PreconditionerMp>::BlockSchurPreconditioner('
p30794
aS'    double                           gamma,'
p30795
aS'    double                           viscosity,'
p30796
aS'    const BlockSparseMatrix<double> &S,'
p30797
aS'    const SparseMatrix<double> &     P,'
p30798
aS'    const PreconditionerMp &         Mppreconditioner)'
p30799
aS'    : gamma(gamma)'
p30800
aS'    , viscosity(viscosity)'
p30801
aS'    , stokes_matrix(S)'
p30802
aS'    , pressure_mass_matrix(P)'
p30803
aS'    , mp_preconditioner(Mppreconditioner)'
p30804
aS'  {'
p30805
aS'    A_inverse.initialize(stokes_matrix.block(0, 0));'
p30806
aS'  }'
p30807
aS'  template <class PreconditionerMp>'
p30808
aS'  void BlockSchurPreconditioner<PreconditionerMp>::vmult('
p30809
aS'    BlockVector<double> &      dst,'
p30810
aS'    const BlockVector<double> &src) const'
p30811
aS'  {'
p30812
aS'    Vector<double> utmp(src.block(0));'
p30813
aS'    {'
p30814
aS'      SolverControl solver_control(1000, 1e-6 * src.block(1).l2_norm());'
p30815
aS'      SolverCG<Vector<double>> cg(solver_control);'
p30816
aS'      dst.block(1) = 0.0;'
p30817
aS'      cg.solve(pressure_mass_matrix,'
p30818
aS'               dst.block(1),'
p30819
aS'               src.block(1),'
p30820
aS'               mp_preconditioner);'
p30821
aS'      dst.block(1) *= -(viscosity + gamma);'
p30822
aS'    }'
p30823
aS'    {'
p30824
aS'      stokes_matrix.block(0, 1).vmult(utmp, dst.block(1));'
p30825
aS'      utmp *= -1.0;'
p30826
aS'      utmp += src.block(0);'
p30827
aS'    }'
p30828
aS'    A_inverse.vmult(dst.block(0), utmp);'
p30829
aS'  }'
p30830
aS'  template <int dim>'
p30831
aS'  StationaryNavierStokes<dim>::StationaryNavierStokes(const unsigned int degree)'
p30832
aS'    : viscosity(1.0 / 7500.0)'
p30833
aS'    , gamma(1.0)'
p30834
aS'    , degree(degree)'
p30835
aS'    , triangulation(Triangulation<dim>::maximum_smoothing)'
p30836
aS'    , fe(FE_Q<dim>(degree + 1), dim, FE_Q<dim>(degree), 1)'
p30837
aS'    , dof_handler(triangulation)'
p30838
aS'  {}'
p30839
aS'  template <int dim>'
p30840
aS'  void StationaryNavierStokes<dim>::setup_dofs()'
p30841
aS'  {'
p30842
aS'    system_matrix.clear();'
p30843
aS'    pressure_mass_matrix.clear();'
p30844
aS'    dof_handler.distribute_dofs(fe);'
p30845
aS'    std::vector<unsigned int> block_component(dim + 1, 0);'
p30846
aS'    block_component[dim] = 1;'
p30847
aS'    DoFRenumbering::component_wise(dof_handler, block_component);'
p30848
aS'    dofs_per_block ='
p30849
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p30850
aS'    unsigned int dof_u = dofs_per_block[0];'
p30851
aS'    unsigned int dof_p = dofs_per_block[1];'
p30852
aS'    FEValuesExtractors::Vector velocities(0);'
p30853
aS'    {'
p30854
aS'      nonzero_constraints.clear();'
p30855
aS'      DoFTools::make_hanging_node_constraints(dof_handler, nonzero_constraints);'
p30856
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p30857
aS'                                               0,'
p30858
aS'                                               BoundaryValues<dim>(),'
p30859
aS'                                               nonzero_constraints,'
p30860
aS'                                               fe.component_mask(velocities));'
p30861
aS'    }'
p30862
aS'    nonzero_constraints.close();'
p30863
aS'    {'
p30864
aS'      zero_constraints.clear();'
p30865
aS'      DoFTools::make_hanging_node_constraints(dof_handler, zero_constraints);'
p30866
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p30867
aS'                                               0,'
p30868
aS'                                               Functions::ZeroFunction<dim>('
p30869
aS'                                                 dim + 1),'
p30870
aS'                                               zero_constraints,'
p30871
aS'                                               fe.component_mask(velocities));'
p30872
aS'    }'
p30873
aS'    zero_constraints.close();'
p30874
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p30875
aS'              << std::endl'
p30876
aS'              << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p30877
aS'              << " (" << dof_u << " + " << dof_p << \')\' << std::endl;'
p30878
aS'  }'
p30879
aS'  template <int dim>'
p30880
aS'  void StationaryNavierStokes<dim>::initialize_system()'
p30881
aS'  {'
p30882
aS'    {'
p30883
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p30884
aS'      DoFTools::make_sparsity_pattern(dof_handler, dsp, nonzero_constraints);'
p30885
aS'      sparsity_pattern.copy_from(dsp);'
p30886
aS'    }'
p30887
aS'    system_matrix.reinit(sparsity_pattern);'
p30888
aS'    present_solution.reinit(dofs_per_block);'
p30889
aS'    newton_update.reinit(dofs_per_block);'
p30890
aS'    system_rhs.reinit(dofs_per_block);'
p30891
aS'  }'
p30892
aS'  template <int dim>'
p30893
aS'  void StationaryNavierStokes<dim>::assemble(const bool initial_step,'
p30894
aS'                                             const bool assemble_matrix)'
p30895
aS'  {'
p30896
aS'    if (assemble_matrix)'
p30897
aS'      system_matrix = 0;'
p30898
aS'    system_rhs = 0;'
p30899
aS'    QGauss<dim> quadrature_formula(degree + 2);'
p30900
aS'    FEValues<dim> fe_values(fe,'
p30901
aS'                            quadrature_formula,'
p30902
aS'                            update_values | update_quadrature_points |'
p30903
aS'                              update_JxW_values | update_gradients);'
p30904
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p30905
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p30906
aS'    const FEValuesExtractors::Vector velocities(0);'
p30907
aS'    const FEValuesExtractors::Scalar pressure(dim);'
p30908
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p30909
aS'    Vector<double>     local_rhs(dofs_per_cell);'
p30910
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p30911
aS'    std::vector<Tensor<1, dim>> present_velocity_values(n_q_points);'
p30912
aS'    std::vector<Tensor<2, dim>> present_velocity_gradients(n_q_points);'
p30913
aS'    std::vector<double>         present_pressure_values(n_q_points);'
p30914
aS'    std::vector<double>         div_phi_u(dofs_per_cell);'
p30915
aS'    std::vector<Tensor<1, dim>> phi_u(dofs_per_cell);'
p30916
aS'    std::vector<Tensor<2, dim>> grad_phi_u(dofs_per_cell);'
p30917
aS'    std::vector<double>         phi_p(dofs_per_cell);'
p30918
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p30919
aS'      {'
p30920
aS'        fe_values.reinit(cell);'
p30921
aS'        local_matrix = 0;'
p30922
aS'        local_rhs    = 0;'
p30923
aS'        fe_values[velocities].get_function_values(evaluation_point,'
p30924
aS'                                                  present_velocity_values);'
p30925
aS'        fe_values[velocities].get_function_gradients('
p30926
aS'          evaluation_point, present_velocity_gradients);'
p30927
aS'        fe_values[pressure].get_function_values(evaluation_point,'
p30928
aS'                                                present_pressure_values);'
p30929
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p30930
aS'          {'
p30931
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p30932
aS'              {'
p30933
aS'                div_phi_u[k]  = fe_values[velocities].divergence(k, q);'
p30934
aS'                grad_phi_u[k] = fe_values[velocities].gradient(k, q);'
p30935
aS'                phi_u[k]      = fe_values[velocities].value(k, q);'
p30936
aS'                phi_p[k]      = fe_values[pressure].value(k, q);'
p30937
aS'              }'
p30938
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p30939
aS'              {'
p30940
aS'                if (assemble_matrix)'
p30941
aS'                  {'
p30942
aS'                    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p30943
aS'                      {'
p30944
aS'                        local_matrix(i, j) +='
p30945
aS'                             scalar_product(grad_phi_u[j], grad_phi_u[i]) +'
p30946
aS'                           present_velocity_gradients[q] * phi_u[j] * phi_u[i] +'
p30947
aS'                           grad_phi_u[j] * present_velocity_values[q] *'
p30948
aS'                             phi_u[i] -'
p30949
aS'                           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j] +'
p30950
aS'                           gamma * div_phi_u[j] * div_phi_u[i] +'
p30951
aS'                           phi_p[i] * phi_p[j]) *'
p30952
aS'                          fe_values.JxW(q);'
p30953
aS'                      }'
p30954
aS'                  }'
p30955
aS'                double present_velocity_divergence ='
p30956
aS'                  trace(present_velocity_gradients[q]);'
p30957
aS'                local_rhs(i) +='
p30958
aS'                                               grad_phi_u[i]) -'
p30959
aS'                   present_velocity_gradients[q] * present_velocity_values[q] *'
p30960
aS'                     phi_u[i] +'
p30961
aS'                   present_pressure_values[q] * div_phi_u[i] +'
p30962
aS'                   present_velocity_divergence * phi_p[i] -'
p30963
aS'                   gamma * present_velocity_divergence * div_phi_u[i]) *'
p30964
aS'                  fe_values.JxW(q);'
p30965
aS'              }'
p30966
aS'          }'
p30967
aS'        cell->get_dof_indices(local_dof_indices);'
p30968
aS'        const AffineConstraints<double> &constraints_used ='
p30969
aS'          initial_step ? nonzero_constraints : zero_constraints;'
p30970
aS'        if (assemble_matrix)'
p30971
aS'          {'
p30972
aS'            constraints_used.distribute_local_to_global(local_matrix,'
p30973
aS'                                                        local_rhs,'
p30974
aS'                                                        local_dof_indices,'
p30975
aS'                                                        system_matrix,'
p30976
aS'                                                        system_rhs);'
p30977
aS'          }'
p30978
aS'        else'
p30979
aS'          {'
p30980
aS'            constraints_used.distribute_local_to_global(local_rhs,'
p30981
aS'                                                        local_dof_indices,'
p30982
aS'                                                        system_rhs);'
p30983
aS'          }'
p30984
aS'      }'
p30985
aS'    if (assemble_matrix)'
p30986
aS'      {'
p30987
aS'        pressure_mass_matrix.reinit(sparsity_pattern.block(1, 1));'
p30988
aS'        pressure_mass_matrix.copy_from(system_matrix.block(1, 1));'
p30989
aS'        system_matrix.block(1, 1) = 0;'
p30990
aS'      }'
p30991
aS'  }'
p30992
aS'  template <int dim>'
p30993
aS'  void StationaryNavierStokes<dim>::assemble_system(const bool initial_step)'
p30994
aS'  {'
p30995
aS'    assemble(initial_step, true);'
p30996
aS'  }'
p30997
aS'  template <int dim>'
p30998
aS'  void StationaryNavierStokes<dim>::assemble_rhs(const bool initial_step)'
p30999
aS'  {'
p31000
aS'    assemble(initial_step, false);'
p31001
aS'  }'
p31002
aS'  template <int dim>'
p31003
aS'  void StationaryNavierStokes<dim>::solve(const bool initial_step)'
p31004
aS'  {'
p31005
aS'    const AffineConstraints<double> &constraints_used ='
p31006
aS'      initial_step ? nonzero_constraints : zero_constraints;'
p31007
aS'    SolverControl solver_control(system_matrix.m(),'
p31008
aS'                                 1e-4 * system_rhs.l2_norm(),'
p31009
aS'                                 true);'
p31010
aS'    SolverFGMRES<BlockVector<double>> gmres(solver_control);'
p31011
aS'    SparseILU<double>                 pmass_preconditioner;'
p31012
aS'    pmass_preconditioner.initialize(pressure_mass_matrix,'
p31013
aS'                                    SparseILU<double>::AdditionalData());'
p31014
aS'    const BlockSchurPreconditioner<SparseILU<double>> preconditioner('
p31015
aS'      gamma,'
p31016
aS'      viscosity,'
p31017
aS'      system_matrix,'
p31018
aS'      pressure_mass_matrix,'
p31019
aS'      pmass_preconditioner);'
p31020
aS'    gmres.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p31021
aS'    std::cout << "FGMRES steps: " << solver_control.last_step() << std::endl;'
p31022
aS'    constraints_used.distribute(newton_update);'
p31023
aS'  }'
p31024
aS'  template <int dim>'
p31025
aS'  void StationaryNavierStokes<dim>::refine_mesh()'
p31026
aS'  {'
p31027
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p31028
aS'    FEValuesExtractors::Vector velocity(0);'
p31029
aS'    KellyErrorEstimator<dim>::estimate('
p31030
aS'      dof_handler,'
p31031
aS'      QGauss<dim - 1>(degree + 1),'
p31032
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p31033
aS'      present_solution,'
p31034
aS'      estimated_error_per_cell,'
p31035
aS'      fe.component_mask(velocity));'
p31036
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p31037
aS'                                                    estimated_error_per_cell,'
p31038
aS'                                                    0.3,'
p31039
aS'                                                    0.0);'
p31040
aS'    triangulation.prepare_coarsening_and_refinement();'
p31041
aS'    SolutionTransfer<dim, BlockVector<double>> solution_transfer(dof_handler);'
p31042
aS'    solution_transfer.prepare_for_coarsening_and_refinement(present_solution);'
p31043
aS'    triangulation.execute_coarsening_and_refinement();'
p31044
aS'    setup_dofs();'
p31045
aS'    BlockVector<double> tmp(dofs_per_block);'
p31046
aS'    solution_transfer.interpolate(present_solution, tmp);'
p31047
aS'    nonzero_constraints.distribute(tmp);'
p31048
aS'    initialize_system();'
p31049
aS'    present_solution = tmp;'
p31050
aS'  }'
p31051
aS'  template <int dim>'
p31052
aS'  void StationaryNavierStokes<dim>::newton_iteration('
p31053
aS'    const double       tolerance,'
p31054
aS'    const unsigned int max_n_line_searches,'
p31055
aS'    const unsigned int max_n_refinements,'
p31056
aS'    const bool         is_initial_step,'
p31057
aS'    const bool         output_result)'
p31058
aS'  {'
p31059
aS'    bool first_step = is_initial_step;'
p31060
aS'    for (unsigned int refinement_n = 0; refinement_n < max_n_refinements + 1;'
p31061
aS'         ++refinement_n)'
p31062
aS'      {'
p31063
aS'        unsigned int line_search_n = 0;'
p31064
aS'        double       last_res      = 1.0;'
p31065
aS'        double       current_res   = 1.0;'
p31066
aS'        std::cout << "grid refinements: " << refinement_n << std::endl'
p31067
aS'                  << "viscosity: " << viscosity << std::endl;'
p31068
aS'        while ((first_step || (current_res > tolerance)) &&'
p31069
aS'               line_search_n < max_n_line_searches)'
p31070
aS'          {'
p31071
aS'            if (first_step)'
p31072
aS'              {'
p31073
aS'                setup_dofs();'
p31074
aS'                initialize_system();'
p31075
aS'                evaluation_point = present_solution;'
p31076
aS'                assemble_system(first_step);'
p31077
aS'                solve(first_step);'
p31078
aS'                present_solution = newton_update;'
p31079
aS'                nonzero_constraints.distribute(present_solution);'
p31080
aS'                first_step       = false;'
p31081
aS'                evaluation_point = present_solution;'
p31082
aS'                assemble_rhs(first_step);'
p31083
aS'                current_res = system_rhs.l2_norm();'
p31084
aS'                std::cout << "The residual of initial guess is " << current_res'
p31085
aS'                          << std::endl;'
p31086
aS'                last_res = current_res;'
p31087
aS'              }'
p31088
aS'            else'
p31089
aS'              {'
p31090
aS'                evaluation_point = present_solution;'
p31091
aS'                assemble_system(first_step);'
p31092
aS'                solve(first_step);'
p31093
aS'                for (double alpha = 1.0; alpha > 1e-5; alpha *= 0.5)'
p31094
aS'                  {'
p31095
aS'                    evaluation_point = present_solution;'
p31096
aS'                    evaluation_point.add(alpha, newton_update);'
p31097
aS'                    nonzero_constraints.distribute(evaluation_point);'
p31098
aS'                    assemble_rhs(first_step);'
p31099
aS'                    current_res = system_rhs.l2_norm();'
p31100
aS'                    std::cout << "  alpha: " << std::setw(10) << alpha'
p31101
aS'                              << std::setw(0) << "  residual: " << current_res'
p31102
aS'                              << std::endl;'
p31103
aS'                    if (current_res < last_res)'
p31104
aS'                      break;'
p31105
aS'                  }'
p31106
aS'                {'
p31107
aS'                  present_solution = evaluation_point;'
p31108
aS'                  std::cout << "  number of line searches: " << line_search_n'
p31109
aS'                            << "  residual: " << current_res << std::endl;'
p31110
aS'                  last_res = current_res;'
p31111
aS'                }'
p31112
aS'                ++line_search_n;'
p31113
aS'              }'
p31114
aS'            if (output_result)'
p31115
aS'              {'
p31116
aS'                output_results(max_n_line_searches * refinement_n +'
p31117
aS'                               line_search_n);'
p31118
aS'                if (current_res <= tolerance)'
p31119
aS'                  process_solution(refinement_n);'
p31120
aS'              }'
p31121
aS'          }'
p31122
aS'        if (refinement_n < max_n_refinements)'
p31123
aS'          {'
p31124
aS'            refine_mesh();'
p31125
aS'          }'
p31126
aS'      }'
p31127
aS'  }'
p31128
aS'  template <int dim>'
p31129
aS'  void StationaryNavierStokes<dim>::compute_initial_guess(double step_size)'
p31130
aS'  {'
p31131
aS'    const double target_Re = 1.0 / viscosity;'
p31132
aS'    bool is_initial_step = true;'
p31133
aS'    for (double Re = 1000.0; Re < target_Re;'
p31134
aS'         Re        = std::min(Re + step_size, target_Re))'
p31135
aS'      {'
p31136
aS'        viscosity = 1.0 / Re;'
p31137
aS'        std::cout << "Searching for initial guess with Re = " << Re'
p31138
aS'                  << std::endl;'
p31139
aS'        newton_iteration(1e-12, 50, 0, is_initial_step, false);'
p31140
aS'        is_initial_step = false;'
p31141
aS'      }'
p31142
aS'  }'
p31143
aS'  template <int dim>'
p31144
aS'  void StationaryNavierStokes<dim>::output_results('
p31145
aS'    const unsigned int output_index) const'
p31146
aS'  {'
p31147
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p31148
aS'    solution_names.emplace_back("pressure");'
p31149
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p31150
aS'      data_component_interpretation('
p31151
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p31152
aS'    data_component_interpretation.push_back('
p31153
aS'      DataComponentInterpretation::component_is_scalar);'
p31154
aS'    DataOut<dim> data_out;'
p31155
aS'    data_out.attach_dof_handler(dof_handler);'
p31156
aS'    data_out.add_data_vector(present_solution,'
p31157
aS'                             solution_names,'
p31158
aS'                             DataOut<dim>::type_dof_data,'
p31159
aS'                             data_component_interpretation);'
p31160
aS'    data_out.build_patches();'
p31161
aS'    std::ofstream output(std::to_string(1.0 / viscosity) + "-solution-" +'
p31162
aS'                         Utilities::int_to_string(output_index, 4) + ".vtk");'
p31163
aS'    data_out.write_vtk(output);'
p31164
aS'  }'
p31165
aS'  template <int dim>'
p31166
aS'  void StationaryNavierStokes<dim>::process_solution(unsigned int refinement)'
p31167
aS'  {'
p31168
aS'    std::ofstream f(std::to_string(1.0 / viscosity) + "-line-" +'
p31169
aS'                    std::to_string(refinement) + ".txt");'
p31170
aS'    f << "# y u_x u_y" << std::endl;'
p31171
aS'    Point<dim> p;'
p31172
aS'    p(0) = 0.5;'
p31173
aS'    p(1) = 0.5;'
p31174
aS'    f << std::scientific;'
p31175
aS'    for (unsigned int i = 0; i <= 100; ++i)'
p31176
aS'      {'
p31177
aS'        p(dim - 1) = i / 100.0;'
p31178
aS'        Vector<double> tmp_vector(dim + 1);'
p31179
aS'        VectorTools::point_value(dof_handler, present_solution, p, tmp_vector);'
p31180
aS'        f << p(dim - 1);'
p31181
aS'        for (int j = 0; j < dim; j++)'
p31182
aS'          f << " " << tmp_vector(j);'
p31183
aS'        f << std::endl;'
p31184
aS'      }'
p31185
aS'  }'
p31186
aS'  template <int dim>'
p31187
aS'  void StationaryNavierStokes<dim>::run(const unsigned int refinement)'
p31188
aS'  {'
p31189
aS'    GridGenerator::hyper_cube(triangulation);'
p31190
aS'    triangulation.refine_global(5);'
p31191
aS'    const double Re = 1.0 / viscosity;'
p31192
aS'    if (Re > 1000.0)'
p31193
aS'      {'
p31194
aS'        std::cout << "Searching for initial guess ..." << std::endl;'
p31195
aS'        const double step_size = 2000.0;'
p31196
aS'        compute_initial_guess(step_size);'
p31197
aS'        std::cout << "Found initial guess." << std::endl;'
p31198
aS'        std::cout << "Computing solution with target Re = " << Re << std::endl;'
p31199
aS'        viscosity = 1.0 / Re;'
p31200
aS'        newton_iteration(1e-12, 50, refinement, false, true);'
p31201
aS'      }'
p31202
aS'    else'
p31203
aS'      {'
p31204
aS'        newton_iteration(1e-12, 50, refinement, true, true);'
p31205
aS'      }'
p31206
aS'  }'
p31207
aS'} // namespace Step57'
p31208
aS'int main()'
p31209
ag9
aS'  try'
p31210
aS'    {'
p31211
aS'      using namespace Step57;'
p31212
aS'      StationaryNavierStokes<2> flow(/* degree = */ 1);'
p31213
aS'      flow.run(4);'
p31214
aS'    }'
p31215
aS'  catch (std::exception &exc)'
p31216
aS'    {'
p31217
aS'      std::cerr << std::endl'
p31218
aS'                << std::endl'
p31219
aS'                << "----------------------------------------------------"'
p31220
aS'                << std::endl;'
p31221
aS'      std::cerr << "Exception on processing: " << std::endl'
p31222
aS'                << exc.what() << std::endl'
p31223
aS'                << "Aborting!" << std::endl'
p31224
aS'                << "----------------------------------------------------"'
p31225
aS'                << std::endl;'
p31226
aS'      return 1;'
p31227
aS'    }'
p31228
aS'  catch (...)'
p31229
aS'    {'
p31230
aS'      std::cerr << std::endl'
p31231
aS'                << std::endl'
p31232
aS'                << "----------------------------------------------------"'
p31233
aS'                << std::endl;'
p31234
aS'      std::cerr << "Unknown exception!" << std::endl'
p31235
aS'                << "Aborting!" << std::endl'
p31236
aS'                << "----------------------------------------------------"'
p31237
aS'                << std::endl;'
p31238
aS'      return 1;'
p31239
aS'    }'
p31240
aS'  return 0;'
p31241
ag17
aS'#include <deal.II/base/logstream.h>'
p31242
aS'#include <deal.II/lac/vector.h>'
p31243
aS'#include <deal.II/lac/full_matrix.h>'
p31244
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p31245
aS'#include <deal.II/lac/sparse_matrix.h>'
p31246
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p31247
aS'#include <deal.II/lac/block_vector.h>'
p31248
aS'#include <deal.II/lac/affine_constraints.h>'
p31249
aS'#include <deal.II/lac/sparse_direct.h>'
p31250
aS'#include <deal.II/grid/tria.h>'
p31251
aS'#include <deal.II/grid/grid_generator.h>'
p31252
aS'#include <deal.II/grid/grid_refinement.h>'
p31253
aS'#include <deal.II/dofs/dof_handler.h>'
p31254
aS'#include <deal.II/dofs/dof_tools.h>'
p31255
aS'#include <deal.II/fe/fe_q.h>'
p31256
aS'#include <deal.II/fe/fe_values.h>'
p31257
aS'#include <deal.II/numerics/data_out.h>'
p31258
aS'#include <deal.II/numerics/vector_tools.h>'
p31259
aS'#include <deal.II/numerics/error_estimator.h>'
p31260
aS'#include <deal.II/numerics/matrix_tools.h>'
p31261
aS'#include <fstream>'
p31262
aS'#include <iostream>'
p31263
aS'namespace Step58'
p31264
ag9
aS'  using namespace dealii;'
p31265
aS'  template <int dim>'
p31266
aS'  class NonlinearSchroedingerEquation'
p31267
aS'  {'
p31268
aS'  public:'
p31269
aS'    NonlinearSchroedingerEquation();'
p31270
aS'    void run();'
p31271
aS'  private:'
p31272
aS'    void setup_system();'
p31273
aS'    void assemble_matrices();'
p31274
aS'    void do_half_phase_step();'
p31275
aS'    void do_full_spatial_step();'
p31276
aS'    void output_results() const;'
p31277
aS'    Triangulation<dim> triangulation;'
p31278
aS'    FE_Q<dim>          fe;'
p31279
aS'    DoFHandler<dim>    dof_handler;'
p31280
aS'    AffineConstraints<std::complex<double>> constraints;'
p31281
aS'    SparsityPattern                    sparsity_pattern;'
p31282
aS'    SparseMatrix<std::complex<double>> system_matrix;'
p31283
aS'    SparseMatrix<std::complex<double>> rhs_matrix;'
p31284
aS'    Vector<std::complex<double>> solution;'
p31285
aS'    Vector<std::complex<double>> system_rhs;'
p31286
aS'    double       time;'
p31287
aS'    double       time_step;'
p31288
aS'    unsigned int timestep_number;'
p31289
aS'    double kappa;'
p31290
aS'  };'
p31291
aS'  template <int dim>'
p31292
aS'  class InitialValues : public Function<dim, std::complex<double>>'
p31293
aS'  {'
p31294
aS'  public:'
p31295
aS'    InitialValues()'
p31296
aS'      : Function<dim, std::complex<double>>(1)'
p31297
aS'    {}'
p31298
aS'    virtual std::complex<double>'
p31299
aS'    value(const Point<dim> &p, const unsigned int component = 0) const override;'
p31300
aS'  };'
p31301
aS'  template <int dim>'
p31302
aS'  std::complex<double>'
p31303
aS'  InitialValues<dim>::value(const Point<dim> & p,'
p31304
aS'                            const unsigned int component) const'
p31305
aS'  {'
p31306
aS'    static_assert(dim == 2, "This initial condition only works in 2d.");'
p31307
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p31308
aS'    const std::vector<Point<dim>> vortex_centers = {{0, -0.3},'
p31309
aS'                                                    {0, +0.3},'
p31310
aS'                                                    {+0.3, 0},'
p31311
aS'                                                    {-0.3, 0}};'
p31312
aS'    const double R = 0.1;'
p31313
aS'    const double alpha ='
p31314
aS'      1. / (std::pow(R, dim) * std::pow(numbers::PI, dim / 2.));'
p31315
aS'    double sum = 0;'
p31316
aS'    for (const auto &vortex_center : vortex_centers)'
p31317
aS'      {'
p31318
aS'        const Tensor<1, dim> distance = p - vortex_center;'
p31319
aS'        const double         r        = distance.norm();'
p31320
aS'        sum += alpha * std::exp(-(r * r) / (R * R));'
p31321
aS'      }'
p31322
aS'    return {std::sqrt(sum), 0.};'
p31323
aS'  }'
p31324
aS'  template <int dim>'
p31325
aS'  class Potential : public Function<dim>'
p31326
aS'  {'
p31327
aS'  public:'
p31328
aS'    Potential() = default;'
p31329
aS'    virtual double value(const Point<dim> & p,'
p31330
aS'                         const unsigned int component = 0) const override;'
p31331
aS'  };'
p31332
aS'  template <int dim>'
p31333
aS'  double Potential<dim>::value(const Point<dim> & p,'
p31334
aS'                               const unsigned int component) const'
p31335
aS'  {'
p31336
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p31337
aS'    return (Point<dim>().distance(p) > 0.7 ? 1000 : 0);'
p31338
aS'  }'
p31339
aS'  template <int dim>'
p31340
aS'  NonlinearSchroedingerEquation<dim>::NonlinearSchroedingerEquation()'
p31341
aS'    : fe(2)'
p31342
aS'    , dof_handler(triangulation)'
p31343
aS'    , time(0)'
p31344
aS'    , time_step(1. / 128)'
p31345
aS'    , timestep_number(0)'
p31346
aS'    , kappa(1)'
p31347
aS'  {}'
p31348
aS'  template <int dim>'
p31349
aS'  void NonlinearSchroedingerEquation<dim>::setup_system()'
p31350
aS'  {'
p31351
aS'    GridGenerator::hyper_cube(triangulation, -1, 1);'
p31352
aS'    triangulation.refine_global(6);'
p31353
aS'    std::cout << "Number of active cells: " << triangulation.n_active_cells()'
p31354
aS'              << std::endl;'
p31355
aS'    dof_handler.distribute_dofs(fe);'
p31356
aS'    std::cout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p31357
aS'              << std::endl'
p31358
aS'              << std::endl;'
p31359
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p31360
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p31361
aS'    sparsity_pattern.copy_from(dsp);'
p31362
aS'    system_matrix.reinit(sparsity_pattern);'
p31363
aS'    rhs_matrix.reinit(sparsity_pattern);'
p31364
aS'    solution.reinit(dof_handler.n_dofs());'
p31365
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p31366
aS'    constraints.close();'
p31367
aS'  }'
p31368
aS'  template <int dim>'
p31369
aS'  void NonlinearSchroedingerEquation<dim>::assemble_matrices()'
p31370
aS'  {'
p31371
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p31372
aS'    FEValues<dim> fe_values(fe,'
p31373
aS'                            quadrature_formula,'
p31374
aS'                            update_values | update_gradients |'
p31375
aS'                              update_quadrature_points | update_JxW_values);'
p31376
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p31377
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p31378
aS'    FullMatrix<std::complex<double>> cell_matrix_lhs(dofs_per_cell,'
p31379
aS'                                                     dofs_per_cell);'
p31380
aS'    FullMatrix<std::complex<double>> cell_matrix_rhs(dofs_per_cell,'
p31381
aS'                                                     dofs_per_cell);'
p31382
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p31383
aS'    std::vector<double>                  potential_values(n_q_points);'
p31384
aS'    const Potential<dim>                 potential;'
p31385
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p31386
aS'      {'
p31387
aS'        cell_matrix_lhs = std::complex<double>(0.);'
p31388
aS'        cell_matrix_rhs = std::complex<double>(0.);'
p31389
aS'        fe_values.reinit(cell);'
p31390
aS'        potential.value_list(fe_values.get_quadrature_points(),'
p31391
aS'                             potential_values);'
p31392
aS'        for (unsigned int q_index = 0; q_index < n_q_points; ++q_index)'
p31393
aS'          {'
p31394
aS'            for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p31395
aS'              {'
p31396
aS'                for (unsigned int l = 0; l < dofs_per_cell; ++l)'
p31397
aS'                  {'
p31398
aS'                    const std::complex<double> i = {0, 1};'
p31399
aS'                    cell_matrix_lhs(k, l) +='
p31400
aS'                         fe_values.shape_value(l, q_index) +'
p31401
aS'                       time_step / 4 * fe_values.shape_grad(k, q_index) *'
p31402
aS'                         fe_values.shape_grad(l, q_index) +'
p31403
aS'                       time_step / 2 * potential_values[q_index] *'
p31404
aS'                         fe_values.shape_value(k, q_index) *'
p31405
aS'                         fe_values.shape_value(l, q_index)) *'
p31406
aS'                      fe_values.JxW(q_index);'
p31407
aS'                    cell_matrix_rhs(k, l) +='
p31408
aS'                         fe_values.shape_value(l, q_index) -'
p31409
aS'                       time_step / 4 * fe_values.shape_grad(k, q_index) *'
p31410
aS'                         fe_values.shape_grad(l, q_index) -'
p31411
aS'                       time_step / 2 * potential_values[q_index] *'
p31412
aS'                         fe_values.shape_value(k, q_index) *'
p31413
aS'                         fe_values.shape_value(l, q_index)) *'
p31414
aS'                      fe_values.JxW(q_index);'
p31415
aS'                  }'
p31416
aS'              }'
p31417
aS'          }'
p31418
aS'        cell->get_dof_indices(local_dof_indices);'
p31419
aS'        constraints.distribute_local_to_global(cell_matrix_lhs,'
p31420
aS'                                               local_dof_indices,'
p31421
aS'                                               system_matrix);'
p31422
aS'        constraints.distribute_local_to_global(cell_matrix_rhs,'
p31423
aS'                                               local_dof_indices,'
p31424
aS'                                               rhs_matrix);'
p31425
aS'      }'
p31426
aS'  }'
p31427
aS'  template <int dim>'
p31428
aS'  void NonlinearSchroedingerEquation<dim>::do_half_phase_step()'
p31429
aS'  {'
p31430
aS'    for (auto &value : solution)'
p31431
aS'      {'
p31432
aS'        const std::complex<double> i         = {0, 1};'
p31433
aS'        const double               magnitude = std::abs(value);'
p31434
aS'        value = std::exp(-i * kappa * magnitude * magnitude * (time_step / 2)) *'
p31435
aS'                value;'
p31436
aS'      }'
p31437
aS'  }'
p31438
aS'  template <int dim>'
p31439
aS'  void NonlinearSchroedingerEquation<dim>::do_full_spatial_step()'
p31440
aS'  {'
p31441
aS'    rhs_matrix.vmult(system_rhs, solution);'
p31442
aS'    SparseDirectUMFPACK direct_solver;'
p31443
aS'    direct_solver.solve(system_matrix, system_rhs);'
p31444
aS'    solution = system_rhs;'
p31445
aS'  }'
p31446
aS'  namespace DataPostprocessors'
p31447
aS'  {'
p31448
aS'    template <int dim>'
p31449
aS'    class ComplexAmplitude : public DataPostprocessorScalar<dim>'
p31450
aS'    {'
p31451
aS'    public:'
p31452
aS'      ComplexAmplitude();'
p31453
aS'      virtual void evaluate_vector_field('
p31454
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p31455
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p31456
aS'    };'
p31457
aS'    template <int dim>'
p31458
aS'    ComplexAmplitude<dim>::ComplexAmplitude()'
p31459
aS'      : DataPostprocessorScalar<dim>("Amplitude", update_values)'
p31460
aS'    {}'
p31461
aS'    template <int dim>'
p31462
aS'    void ComplexAmplitude<dim>::evaluate_vector_field('
p31463
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p31464
aS'      std::vector<Vector<double>> &               computed_quantities) const'
p31465
aS'    {'
p31466
aS'      Assert(computed_quantities.size() == inputs.solution_values.size(),'
p31467
aS'             ExcDimensionMismatch(computed_quantities.size(),'
p31468
aS'                                  inputs.solution_values.size()));'
p31469
aS'      for (unsigned int q = 0; q < computed_quantities.size(); ++q)'
p31470
aS'        {'
p31471
aS'          Assert(computed_quantities[q].size() == 1,'
p31472
aS'                 ExcDimensionMismatch(computed_quantities[q].size(), 1));'
p31473
aS'          Assert(inputs.solution_values[q].size() == 2,'
p31474
aS'                 ExcDimensionMismatch(inputs.solution_values[q].size(), 2));'
p31475
aS'          const std::complex<double> psi(inputs.solution_values[q](0),'
p31476
aS'                                         inputs.solution_values[q](1));'
p31477
aS'          computed_quantities[q](0) = std::norm(psi);'
p31478
aS'        }'
p31479
aS'    }'
p31480
aS'    template <int dim>'
p31481
aS'    class ComplexPhase : public DataPostprocessorScalar<dim>'
p31482
aS'    {'
p31483
aS'    public:'
p31484
aS'      ComplexPhase();'
p31485
aS'      virtual void evaluate_vector_field('
p31486
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p31487
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p31488
aS'    };'
p31489
aS'    template <int dim>'
p31490
aS'    ComplexPhase<dim>::ComplexPhase()'
p31491
aS'      : DataPostprocessorScalar<dim>("Phase", update_values)'
p31492
aS'    {}'
p31493
aS'    template <int dim>'
p31494
aS'    void ComplexPhase<dim>::evaluate_vector_field('
p31495
aS'      const DataPostprocessorInputs::Vector<dim> &inputs,'
p31496
aS'      std::vector<Vector<double>> &               computed_quantities) const'
p31497
aS'    {'
p31498
aS'      Assert(computed_quantities.size() == inputs.solution_values.size(),'
p31499
aS'             ExcDimensionMismatch(computed_quantities.size(),'
p31500
aS'                                  inputs.solution_values.size()));'
p31501
aS'      double max_phase = -numbers::PI;'
p31502
aS'      for (unsigned int q = 0; q < computed_quantities.size(); ++q)'
p31503
aS'        {'
p31504
aS'          Assert(computed_quantities[q].size() == 1,'
p31505
aS'                 ExcDimensionMismatch(computed_quantities[q].size(), 1));'
p31506
aS'          Assert(inputs.solution_values[q].size() == 2,'
p31507
aS'                 ExcDimensionMismatch(inputs.solution_values[q].size(), 2));'
p31508
aS'          max_phase ='
p31509
aS'            std::max(max_phase,'
p31510
aS'                     std::arg('
p31511
aS'                       std::complex<double>(inputs.solution_values[q](0),'
p31512
aS'                                            inputs.solution_values[q](1))));'
p31513
aS'        }'
p31514
aS'      for (auto &output : computed_quantities)'
p31515
aS'        output(0) = max_phase;'
p31516
aS'    }'
p31517
aS'  } // namespace DataPostprocessors'
p31518
aS'  template <int dim>'
p31519
aS'  void NonlinearSchroedingerEquation<dim>::output_results() const'
p31520
aS'  {'
p31521
aS'    const DataPostprocessors::ComplexAmplitude<dim> complex_magnitude;'
p31522
aS'    const DataPostprocessors::ComplexPhase<dim>     complex_phase;'
p31523
aS'    DataOut<dim> data_out;'
p31524
aS'    data_out.attach_dof_handler(dof_handler);'
p31525
aS'    data_out.add_data_vector(solution, "Psi");'
p31526
aS'    data_out.add_data_vector(solution, complex_magnitude);'
p31527
aS'    data_out.add_data_vector(solution, complex_phase);'
p31528
aS'    data_out.build_patches();'
p31529
aS'    data_out.set_flags(DataOutBase::VtkFlags(time, timestep_number));'
p31530
aS'    const std::string filename ='
p31531
aS'      "solution-" + Utilities::int_to_string(timestep_number, 3) + ".vtu";'
p31532
aS'    std::ofstream output(filename);'
p31533
aS'    data_out.write_vtu(output);'
p31534
aS'  }'
p31535
aS'  template <int dim>'
p31536
aS'  void NonlinearSchroedingerEquation<dim>::run()'
p31537
aS'  {'
p31538
aS'    setup_system();'
p31539
aS'    assemble_matrices();'
p31540
aS'    time = 0;'
p31541
aS'    VectorTools::interpolate(dof_handler, InitialValues<dim>(), solution);'
p31542
aS'    output_results();'
p31543
aS'    const double end_time = 1;'
p31544
aS'    for (; time <= end_time; time += time_step)'
p31545
aS'      {'
p31546
aS'        ++timestep_number;'
p31547
aS'        std::cout << "Time step " << timestep_number << " at t=" << time'
p31548
aS'                  << std::endl;'
p31549
aS'        do_half_phase_step();'
p31550
aS'        do_full_spatial_step();'
p31551
aS'        do_half_phase_step();'
p31552
aS'        if (timestep_number % 1 == 0)'
p31553
aS'          output_results();'
p31554
aS'      }'
p31555
aS'  }'
p31556
aS'} // namespace Step58'
p31557
aS'int main()'
p31558
ag9
aS'  try'
p31559
aS'    {'
p31560
aS'      using namespace Step58;'
p31561
aS'      NonlinearSchroedingerEquation<2> nse;'
p31562
aS'      nse.run();'
p31563
aS'    }'
p31564
aS'  catch (std::exception &exc)'
p31565
aS'    {'
p31566
aS'      std::cerr << std::endl'
p31567
aS'                << std::endl'
p31568
aS'                << "----------------------------------------------------"'
p31569
aS'                << std::endl;'
p31570
aS'      std::cerr << "Exception on processing: " << std::endl'
p31571
aS'                << exc.what() << std::endl'
p31572
aS'                << "Aborting!" << std::endl'
p31573
aS'                << "----------------------------------------------------"'
p31574
aS'                << std::endl;'
p31575
aS'      return 1;'
p31576
aS'    }'
p31577
aS'  catch (...)'
p31578
aS'    {'
p31579
aS'      std::cerr << std::endl'
p31580
aS'                << std::endl'
p31581
aS'                << "----------------------------------------------------"'
p31582
aS'                << std::endl;'
p31583
aS'      std::cerr << "Unknown exception!" << std::endl'
p31584
aS'                << "Aborting!" << std::endl'
p31585
aS'                << "----------------------------------------------------"'
p31586
aS'                << std::endl;'
p31587
aS'      return 1;'
p31588
aS'    }'
p31589
aS'  return 0;'
p31590
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p31591
aS'#include <deal.II/base/function.h>'
p31592
aS'#include <deal.II/base/logstream.h>'
p31593
aS'#include <deal.II/base/timer.h>'
p31594
aS'#include <deal.II/lac/affine_constraints.h>'
p31595
aS'#include <deal.II/lac/full_matrix.h>'
p31596
aS'#include <deal.II/lac/solver_cg.h>'
p31597
aS'#include <deal.II/lac/la_parallel_vector.h>'
p31598
aS'#include <deal.II/lac/precondition.h>'
p31599
aS'#include <deal.II/lac/tensor_product_matrix.h>'
p31600
aS'#include <deal.II/fe/fe_dgq.h>'
p31601
aS'#include <deal.II/fe/fe_tools.h>'
p31602
aS'#include <deal.II/grid/tria.h>'
p31603
aS'#include <deal.II/grid/grid_generator.h>'
p31604
aS'#include <deal.II/grid/grid_tools.h>'
p31605
aS'#include <deal.II/multigrid/multigrid.h>'
p31606
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p31607
aS'#include <deal.II/multigrid/mg_tools.h>'
p31608
aS'#include <deal.II/multigrid/mg_coarse.h>'
p31609
aS'#include <deal.II/multigrid/mg_smoother.h>'
p31610
aS'#include <deal.II/multigrid/mg_matrix.h>'
p31611
aS'#include <deal.II/numerics/vector_tools.h>'
p31612
aS'#include <deal.II/matrix_free/matrix_free.h>'
p31613
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p31614
aS'#include <iostream>'
p31615
aS'#include <fstream>'
p31616
aS'namespace Step59'
p31617
ag9
aS'  using namespace dealii;'
p31618
aS'  const unsigned int degree_finite_element = 8;'
p31619
aS'  const unsigned int dimension             = 3;'
p31620
aS'  template <int dim>'
p31621
aS'  class Solution : public Function<dim>'
p31622
aS'  {'
p31623
aS'  public:'
p31624
aS'    virtual double value(const Point<dim> &p,'
p31625
aS'                         const unsigned int = 0) const override final'
p31626
aS'    {'
p31627
aS'      double val = 1.;'
p31628
aS'      for (unsigned int d = 0; d < dim; ++d)'
p31629
aS'        val *= std::cos(numbers::PI * 2.4 * p[d]);'
p31630
aS'      return val;'
p31631
aS'    }'
p31632
aS'    virtual Tensor<1, dim> gradient(const Point<dim> &p,'
p31633
aS'                                    const unsigned int = 0) const override final'
p31634
aS'    {'
p31635
aS'      const double   arg = numbers::PI * 2.4;'
p31636
aS'      Tensor<1, dim> grad;'
p31637
aS'      for (unsigned int d = 0; d < dim; ++d)'
p31638
aS'        {'
p31639
aS'          grad[d] = 1.;'
p31640
aS'          for (unsigned int e = 0; e < dim; ++e)'
p31641
aS'            if (d == e)'
p31642
aS'              grad[d] *= -arg * std::sin(arg * p[e]);'
p31643
aS'            else'
p31644
aS'              grad[d] *= std::cos(arg * p[e]);'
p31645
aS'        }'
p31646
aS'      return grad;'
p31647
aS'    }'
p31648
aS'  };'
p31649
aS'  template <int dim>'
p31650
aS'  class RightHandSide : public Function<dim>'
p31651
aS'  {'
p31652
aS'  public:'
p31653
aS'    virtual double value(const Point<dim> &p,'
p31654
aS'                         const unsigned int = 0) const override final'
p31655
aS'    {'
p31656
aS'      const double arg = numbers::PI * 2.4;'
p31657
aS'      double       val = 1.;'
p31658
aS'      for (unsigned int d = 0; d < dim; ++d)'
p31659
aS'        val *= std::cos(arg * p[d]);'
p31660
aS'      return dim * arg * arg * val;'
p31661
aS'    }'
p31662
aS'  };'
p31663
aS'  template <int dim, int fe_degree, typename number>'
p31664
aS'  class LaplaceOperator : public Subscriptor'
p31665
aS'  {'
p31666
aS'  public:'
p31667
aS'    using value_type = number;'
p31668
aS'    LaplaceOperator() = default;'
p31669
aS'    void initialize(std::shared_ptr<const MatrixFree<dim, number>> data);'
p31670
aS'    void clear();'
p31671
aS'    types::global_dof_index m() const;'
p31672
aS'    void initialize_dof_vector('
p31673
aS'      LinearAlgebra::distributed::Vector<number> &vec) const;'
p31674
aS'    std::shared_ptr<const MatrixFree<dim, number>> get_matrix_free() const;'
p31675
aS'    void vmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p31676
aS'               const LinearAlgebra::distributed::Vector<number> &src) const;'
p31677
aS'    void Tvmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p31678
aS'                const LinearAlgebra::distributed::Vector<number> &src) const;'
p31679
aS'    number get_penalty_factor() const'
p31680
aS'    {'
p31681
aS'      return 1.0 * fe_degree * (fe_degree + 1);'
p31682
aS'    }'
p31683
aS'  private:'
p31684
aS'    void'
p31685
aS'    apply_cell(const MatrixFree<dim, number> &                   data,'
p31686
aS'               LinearAlgebra::distributed::Vector<number> &      dst,'
p31687
aS'               const LinearAlgebra::distributed::Vector<number> &src,'
p31688
aS'               const std::pair<unsigned int, unsigned int> &cell_range) const;'
p31689
aS'    void'
p31690
aS'    apply_face(const MatrixFree<dim, number> &                   data,'
p31691
aS'               LinearAlgebra::distributed::Vector<number> &      dst,'
p31692
aS'               const LinearAlgebra::distributed::Vector<number> &src,'
p31693
aS'               const std::pair<unsigned int, unsigned int> &face_range) const;'
p31694
aS'    void apply_boundary('
p31695
aS'      const MatrixFree<dim, number> &                   data,'
p31696
aS'      LinearAlgebra::distributed::Vector<number> &      dst,'
p31697
aS'      const LinearAlgebra::distributed::Vector<number> &src,'
p31698
aS'      const std::pair<unsigned int, unsigned int> &     face_range) const;'
p31699
aS'    std::shared_ptr<const MatrixFree<dim, number>> data;'
p31700
aS'  };'
p31701
aS'  template <int dim, int fe_degree, typename number>'
p31702
aS'  class PreconditionBlockJacobi'
p31703
aS'  {'
p31704
aS'  public:'
p31705
aS'    using value_type = number;'
p31706
aS'    void clear()'
p31707
aS'    {'
p31708
aS'      cell_matrices.clear();'
p31709
aS'    }'
p31710
aS'    void initialize(const LaplaceOperator<dim, fe_degree, number> &op);'
p31711
aS'    void vmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p31712
aS'               const LinearAlgebra::distributed::Vector<number> &src) const;'
p31713
aS'    void Tvmult(LinearAlgebra::distributed::Vector<number> &      dst,'
p31714
aS'                const LinearAlgebra::distributed::Vector<number> &src) const'
p31715
aS'    {'
p31716
aS'      vmult(dst, src);'
p31717
aS'    }'
p31718
aS'  private:'
p31719
aS'    std::shared_ptr<const MatrixFree<dim, number>> data;'
p31720
aS'    std::vector<TensorProductMatrixSymmetricSum<dim,'
p31721
aS'                                                VectorizedArray<number>,'
p31722
aS'                                                fe_degree + 1>>'
p31723
aS'      cell_matrices;'
p31724
aS'  };'
p31725
aS'  template <int dim, typename number>'
p31726
aS'  void adjust_ghost_range_if_necessary('
p31727
aS'    const MatrixFree<dim, number> &                   data,'
p31728
aS'    const LinearAlgebra::distributed::Vector<number> &vec)'
p31729
aS'  {'
p31730
aS'    if (vec.get_partitioner().get() =='
p31731
aS'        data.get_dof_info(0).vector_partitioner.get())'
p31732
aS'      return;'
p31733
aS'    LinearAlgebra::distributed::Vector<number> copy_vec(vec);'
p31734
aS'    const_cast<LinearAlgebra::distributed::Vector<number> &>(vec).reinit('
p31735
aS'      data.get_dof_info(0).vector_partitioner);'
p31736
aS'    const_cast<LinearAlgebra::distributed::Vector<number> &>(vec)'
p31737
aS'      .copy_locally_owned_data_from(copy_vec);'
p31738
aS'  }'
p31739
aS'  template <int dim, int fe_degree, typename number>'
p31740
aS'  void LaplaceOperator<dim, fe_degree, number>::clear()'
p31741
aS'  {'
p31742
aS'    data.reset();'
p31743
aS'  }'
p31744
aS'  template <int dim, int fe_degree, typename number>'
p31745
aS'  void LaplaceOperator<dim, fe_degree, number>::initialize('
p31746
aS'    std::shared_ptr<const MatrixFree<dim, number>> data)'
p31747
aS'  {'
p31748
aS'    this->data = data;'
p31749
aS'  }'
p31750
aS'  template <int dim, int fe_degree, typename number>'
p31751
aS'  std::shared_ptr<const MatrixFree<dim, number>>'
p31752
aS'  LaplaceOperator<dim, fe_degree, number>::get_matrix_free() const'
p31753
aS'  {'
p31754
aS'    return data;'
p31755
aS'  }'
p31756
aS'  template <int dim, int fe_degree, typename number>'
p31757
aS'  void LaplaceOperator<dim, fe_degree, number>::initialize_dof_vector('
p31758
aS'    LinearAlgebra::distributed::Vector<number> &vec) const'
p31759
aS'  {'
p31760
aS'    data->initialize_dof_vector(vec);'
p31761
aS'  }'
p31762
aS'  template <int dim, int fe_degree, typename number>'
p31763
aS'  types::global_dof_index LaplaceOperator<dim, fe_degree, number>::m() const'
p31764
aS'  {'
p31765
aS'    Assert(data.get() != nullptr, ExcNotInitialized());'
p31766
aS'    return data->get_dof_handler().n_dofs();'
p31767
aS'  }'
p31768
aS'  template <int dim, int fe_degree, typename number>'
p31769
aS'  void LaplaceOperator<dim, fe_degree, number>::vmult('
p31770
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p31771
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p31772
aS'  {'
p31773
aS'    adjust_ghost_range_if_necessary(*data, dst);'
p31774
aS'    adjust_ghost_range_if_necessary(*data, src);'
p31775
aS'    data->loop(&LaplaceOperator::apply_cell,'
p31776
aS'               &LaplaceOperator::apply_face,'
p31777
aS'               &LaplaceOperator::apply_boundary,'
p31778
aS'               this,'
p31779
aS'               dst,'
p31780
aS'               src,'
p31781
aS'               MatrixFree<dim, number>::DataAccessOnFaces::gradients,'
p31782
aS'               MatrixFree<dim, number>::DataAccessOnFaces::gradients);'
p31783
aS'  }'
p31784
aS'  template <int dim, int fe_degree, typename number>'
p31785
aS'  void LaplaceOperator<dim, fe_degree, number>::Tvmult('
p31786
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p31787
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p31788
aS'  {'
p31789
aS'    vmult(dst, src);'
p31790
aS'  }'
p31791
aS'  template <int dim, int fe_degree, typename number>'
p31792
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_cell('
p31793
aS'    const MatrixFree<dim, number> &                   data,'
p31794
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p31795
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p31796
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p31797
aS'  {'
p31798
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(data);'
p31799
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p31800
aS'      {'
p31801
aS'        phi.reinit(cell);'
p31802
aS'        phi.gather_evaluate(src, EvaluationFlags::gradients);'
p31803
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p31804
aS'          phi.submit_gradient(phi.get_gradient(q), q);'
p31805
aS'        phi.integrate_scatter(EvaluationFlags::gradients, dst);'
p31806
aS'      }'
p31807
aS'  }'
p31808
aS'  template <int dim, int fe_degree, typename number>'
p31809
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_face('
p31810
aS'    const MatrixFree<dim, number> &                   data,'
p31811
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p31812
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p31813
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p31814
aS'  {'
p31815
aS'    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_inner(data,'
p31816
aS'                                                                         true);'
p31817
aS'    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_outer(data,'
p31818
aS'                                                                         false);'
p31819
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p31820
aS'      {'
p31821
aS'        phi_inner.reinit(face);'
p31822
aS'        phi_inner.gather_evaluate(src,'
p31823
aS'                                  EvaluationFlags::values |'
p31824
aS'                                    EvaluationFlags::gradients);'
p31825
aS'        phi_outer.reinit(face);'
p31826
aS'        phi_outer.gather_evaluate(src,'
p31827
aS'                                  EvaluationFlags::values |'
p31828
aS'                                    EvaluationFlags::gradients);'
p31829
aS'        const VectorizedArray<number> inverse_length_normal_to_face ='
p31830
aS'          0.5 * (std::abs((phi_inner.get_normal_vector(0) *'
p31831
aS'                           phi_inner.inverse_jacobian(0))[dim - 1]) +'
p31832
aS'                 std::abs((phi_outer.get_normal_vector(0) *'
p31833
aS'                           phi_outer.inverse_jacobian(0))[dim - 1]));'
p31834
aS'        const VectorizedArray<number> sigma ='
p31835
aS'          inverse_length_normal_to_face * get_penalty_factor();'
p31836
aS'        for (unsigned int q = 0; q < phi_inner.n_q_points; ++q)'
p31837
aS'          {'
p31838
aS'            const VectorizedArray<number> solution_jump ='
p31839
aS'            const VectorizedArray<number> average_normal_derivative ='
p31840
aS'               phi_outer.get_normal_derivative(q)) *'
p31841
aS'              number(0.5);'
p31842
aS'            const VectorizedArray<number> test_by_value ='
p31843
aS'              solution_jump * sigma - average_normal_derivative;'
p31844
aS'            phi_inner.submit_value(test_by_value, q);'
p31845
aS'            phi_outer.submit_value(-test_by_value, q);'
p31846
aS'            phi_inner.submit_normal_derivative(-solution_jump * number(0.5), q);'
p31847
aS'            phi_outer.submit_normal_derivative(-solution_jump * number(0.5), q);'
p31848
aS'          }'
p31849
aS'        phi_inner.integrate_scatter(EvaluationFlags::values |'
p31850
aS'                                      EvaluationFlags::gradients,'
p31851
aS'                                    dst);'
p31852
aS'        phi_outer.integrate_scatter(EvaluationFlags::values |'
p31853
aS'                                      EvaluationFlags::gradients,'
p31854
aS'                                    dst);'
p31855
aS'      }'
p31856
aS'  }'
p31857
aS'  template <int dim, int fe_degree, typename number>'
p31858
aS'  void LaplaceOperator<dim, fe_degree, number>::apply_boundary('
p31859
aS'    const MatrixFree<dim, number> &                   data,'
p31860
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p31861
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p31862
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p31863
aS'  {'
p31864
aS'    FEFaceEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi_inner(data,'
p31865
aS'                                                                         true);'
p31866
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p31867
aS'      {'
p31868
aS'        phi_inner.reinit(face);'
p31869
aS'        phi_inner.gather_evaluate(src,'
p31870
aS'                                  EvaluationFlags::values |'
p31871
aS'                                    EvaluationFlags::gradients);'
p31872
aS'        const VectorizedArray<number> inverse_length_normal_to_face ='
p31873
aS'          std::abs((phi_inner.get_normal_vector(0) *'
p31874
aS'                    phi_inner.inverse_jacobian(0))[dim - 1]);'
p31875
aS'        const VectorizedArray<number> sigma ='
p31876
aS'          inverse_length_normal_to_face * get_penalty_factor();'
p31877
aS'        const bool is_dirichlet = (data.get_boundary_id(face) == 0);'
p31878
aS'        for (unsigned int q = 0; q < phi_inner.n_q_points; ++q)'
p31879
aS'          {'
p31880
aS'            const VectorizedArray<number> u_inner = phi_inner.get_value(q);'
p31881
aS'            const VectorizedArray<number> u_outer ='
p31882
aS'              is_dirichlet ? -u_inner : u_inner;'
p31883
aS'            const VectorizedArray<number> normal_derivative_inner ='
p31884
aS'              phi_inner.get_normal_derivative(q);'
p31885
aS'            const VectorizedArray<number> normal_derivative_outer ='
p31886
aS'              is_dirichlet ? normal_derivative_inner : -normal_derivative_inner;'
p31887
aS'            const VectorizedArray<number> solution_jump = (u_inner - u_outer);'
p31888
aS'            const VectorizedArray<number> average_normal_derivative ='
p31889
aS'            const VectorizedArray<number> test_by_value ='
p31890
aS'              solution_jump * sigma - average_normal_derivative;'
p31891
aS'            phi_inner.submit_normal_derivative(-solution_jump * number(0.5), q);'
p31892
aS'            phi_inner.submit_value(test_by_value, q);'
p31893
aS'          }'
p31894
aS'        phi_inner.integrate_scatter(EvaluationFlags::values |'
p31895
aS'                                      EvaluationFlags::gradients,'
p31896
aS'                                    dst);'
p31897
aS'      }'
p31898
aS'  }'
p31899
aS'  template <int dim, int fe_degree, typename number>'
p31900
aS'  void PreconditionBlockJacobi<dim, fe_degree, number>::initialize('
p31901
aS'    const LaplaceOperator<dim, fe_degree, number> &op)'
p31902
aS'  {'
p31903
aS'    data = op.get_matrix_free();'
p31904
aS'    std::string name = data->get_dof_handler().get_fe().get_name();'
p31905
aS'    name.replace(name.find(\'<\') + 1, 1, "1");'
p31906
aS'    std::unique_ptr<FiniteElement<1>> fe_1d = FETools::get_fe_by_name<1>(name);'
p31907
aS'    const unsigned int                                 N = fe_degree + 1;'
p31908
aS'    FullMatrix<double>                                 laplace_unscaled(N, N);'
p31909
aS'    std::array<Table<2, VectorizedArray<number>>, dim> mass_matrices;'
p31910
aS'    std::array<Table<2, VectorizedArray<number>>, dim> laplace_matrices;'
p31911
aS'    for (unsigned int d = 0; d < dim; ++d)'
p31912
aS'      {'
p31913
aS'        mass_matrices[d].reinit(N, N);'
p31914
aS'        laplace_matrices[d].reinit(N, N);'
p31915
aS'      }'
p31916
aS'    QGauss<1> quadrature(N);'
p31917
aS'    for (unsigned int i = 0; i < N; ++i)'
p31918
aS'      for (unsigned int j = 0; j < N; ++j)'
p31919
aS'        {'
p31920
aS'          double sum_mass = 0, sum_laplace = 0;'
p31921
aS'          for (unsigned int q = 0; q < quadrature.size(); ++q)'
p31922
aS'            {'
p31923
aS'              sum_mass += (fe_1d->shape_value(i, quadrature.point(q)) *'
p31924
aS'                           fe_1d->shape_value(j, quadrature.point(q))) *'
p31925
aS'                          quadrature.weight(q);'
p31926
aS'              sum_laplace += (fe_1d->shape_grad(i, quadrature.point(q))[0] *'
p31927
aS'                              fe_1d->shape_grad(j, quadrature.point(q))[0]) *'
p31928
aS'                             quadrature.weight(q);'
p31929
aS'            }'
p31930
aS'          for (unsigned int d = 0; d < dim; ++d)'
p31931
aS'            mass_matrices[d](i, j) = sum_mass;'
p31932
aS'          sum_laplace +='
p31933
aS'               fe_1d->shape_value(j, Point<1>()) * op.get_penalty_factor() +'
p31934
aS'             0.5 * fe_1d->shape_grad(i, Point<1>())[0] *'
p31935
aS'               fe_1d->shape_value(j, Point<1>()) +'
p31936
aS'             0.5 * fe_1d->shape_grad(j, Point<1>())[0] *'
p31937
aS'               fe_1d->shape_value(i, Point<1>()));'
p31938
aS'          sum_laplace +='
p31939
aS'               fe_1d->shape_value(j, Point<1>(1.0)) * op.get_penalty_factor() -'
p31940
aS'             0.5 * fe_1d->shape_grad(i, Point<1>(1.0))[0] *'
p31941
aS'               fe_1d->shape_value(j, Point<1>(1.0)) -'
p31942
aS'             0.5 * fe_1d->shape_grad(j, Point<1>(1.0))[0] *'
p31943
aS'               fe_1d->shape_value(i, Point<1>(1.0)));'
p31944
aS'          laplace_unscaled(i, j) = sum_laplace;'
p31945
aS'        }'
p31946
aS'    cell_matrices.clear();'
p31947
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*data);'
p31948
aS'    unsigned int old_mapping_data_index = numbers::invalid_unsigned_int;'
p31949
aS'    for (unsigned int cell = 0; cell < data->n_cell_batches(); ++cell)'
p31950
aS'      {'
p31951
aS'        phi.reinit(cell);'
p31952
aS'        if (phi.get_mapping_data_index_offset() == old_mapping_data_index)'
p31953
aS'          continue;'
p31954
aS'        Tensor<2, dim, VectorizedArray<number>> inverse_jacobian ='
p31955
aS'          phi.inverse_jacobian(0);'
p31956
aS'        for (unsigned int d = 0; d < dim; ++d)'
p31957
aS'          for (unsigned int e = 0; e < dim; ++e)'
p31958
aS'            if (d != e)'
p31959
aS'              for (unsigned int v = 0; v < VectorizedArray<number>::size(); ++v)'
p31960
aS'                AssertThrow(inverse_jacobian[d][e][v] == 0.,'
p31961
aS'                            ExcNotImplemented());'
p31962
aS'        VectorizedArray<number> jacobian_determinant = inverse_jacobian[0][0];'
p31963
aS'        for (unsigned int e = 1; e < dim; ++e)'
p31964
aS'          jacobian_determinant *= inverse_jacobian[e][e];'
p31965
aS'        jacobian_determinant = 1. / jacobian_determinant;'
p31966
aS'        for (unsigned int d = 0; d < dim; ++d)'
p31967
aS'          {'
p31968
aS'            const VectorizedArray<number> scaling_factor ='
p31969
aS'              inverse_jacobian[d][d] * inverse_jacobian[d][d] *'
p31970
aS'              jacobian_determinant;'
p31971
aS'            for (unsigned int i = 0; i < N; ++i)'
p31972
aS'              for (unsigned int j = 0; j < N; ++j)'
p31973
aS'                laplace_matrices[d](i, j) ='
p31974
aS'                  scaling_factor * laplace_unscaled(i, j);'
p31975
aS'          }'
p31976
aS'        if (cell_matrices.size() <= phi.get_mapping_data_index_offset())'
p31977
aS'          cell_matrices.resize(phi.get_mapping_data_index_offset() + 1);'
p31978
aS'        cell_matrices[phi.get_mapping_data_index_offset()].reinit('
p31979
aS'          mass_matrices, laplace_matrices);'
p31980
aS'      }'
p31981
aS'  }'
p31982
aS'  template <int dim, int fe_degree, typename number>'
p31983
aS'  void PreconditionBlockJacobi<dim, fe_degree, number>::vmult('
p31984
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p31985
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p31986
aS'  {'
p31987
aS'    adjust_ghost_range_if_necessary(*data, dst);'
p31988
aS'    adjust_ghost_range_if_necessary(*data, src);'
p31989
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number> phi(*data);'
p31990
aS'    for (unsigned int cell = 0; cell < data->n_cell_batches(); ++cell)'
p31991
aS'      {'
p31992
aS'        phi.reinit(cell);'
p31993
aS'        phi.read_dof_values(src);'
p31994
aS'        cell_matrices[phi.get_mapping_data_index_offset()].apply_inverse('
p31995
aS'          ArrayView<VectorizedArray<number>>(phi.begin_dof_values(),'
p31996
aS'                                             phi.dofs_per_cell),'
p31997
aS'          ArrayView<const VectorizedArray<number>>(phi.begin_dof_values(),'
p31998
aS'                                                   phi.dofs_per_cell));'
p31999
aS'        phi.set_dof_values(dst);'
p32000
aS'      }'
p32001
aS'  }'
p32002
aS'  template <int dim, int fe_degree>'
p32003
aS'  class LaplaceProblem'
p32004
aS'  {'
p32005
aS'  public:'
p32006
aS'    LaplaceProblem();'
p32007
aS'    void run();'
p32008
aS'  private:'
p32009
aS'    void setup_system();'
p32010
aS'    void compute_rhs();'
p32011
aS'    void solve();'
p32012
aS'    void analyze_results() const;'
p32013
aS'#ifdef DEAL_II_WITH_P4EST'
p32014
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p32015
aS'#else'
p32016
aS'    Triangulation<dim> triangulation;'
p32017
aS'#endif'
p32018
aS'    FE_DGQHermite<dim> fe;'
p32019
aS'    DoFHandler<dim>    dof_handler;'
p32020
aS'    MappingQ1<dim> mapping;'
p32021
aS'    using SystemMatrixType = LaplaceOperator<dim, fe_degree, double>;'
p32022
aS'    SystemMatrixType system_matrix;'
p32023
aS'    using LevelMatrixType = LaplaceOperator<dim, fe_degree, float>;'
p32024
aS'    MGLevelObject<LevelMatrixType> mg_matrices;'
p32025
aS'    LinearAlgebra::distributed::Vector<double> solution;'
p32026
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p32027
aS'    double             setup_time;'
p32028
aS'    ConditionalOStream pcout;'
p32029
aS'    ConditionalOStream time_details;'
p32030
aS'  };'
p32031
aS'  template <int dim, int fe_degree>'
p32032
aS'  LaplaceProblem<dim, fe_degree>::LaplaceProblem()'
p32033
aS'    :'
p32034
aS'#ifdef DEAL_II_WITH_P4EST'
p32035
aS'    triangulation('
p32036
aS'      MPI_COMM_WORLD,'
p32037
aS'      Triangulation<dim>::limit_level_difference_at_vertices,'
p32038
aS'      parallel::distributed::Triangulation<dim>::construct_multigrid_hierarchy)'
p32039
aS'    ,'
p32040
aS'#else'
p32041
aS'    triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p32042
aS'    ,'
p32043
aS'#endif'
p32044
aS'    fe(fe_degree)'
p32045
aS'    , dof_handler(triangulation)'
p32046
aS'    , setup_time(0.)'
p32047
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p32048
aS'    , time_details(std::cout,'
p32049
aS'                   false &&'
p32050
aS'                     Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p32051
aS'  {}'
p32052
aS'  template <int dim, int fe_degree>'
p32053
aS'  void LaplaceProblem<dim, fe_degree>::setup_system()'
p32054
aS'  {'
p32055
aS'    Timer time;'
p32056
aS'    setup_time = 0;'
p32057
aS'    system_matrix.clear();'
p32058
aS'    mg_matrices.clear_elements();'
p32059
aS'    dof_handler.distribute_dofs(fe);'
p32060
aS'    dof_handler.distribute_mg_dofs();'
p32061
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p32062
aS'          << std::endl;'
p32063
aS'    setup_time += time.wall_time();'
p32064
aS'    time_details << "Distribute DoFs               " << time.wall_time() << " s"'
p32065
aS'                 << std::endl;'
p32066
aS'    time.restart();'
p32067
aS'    AffineConstraints<double> dummy;'
p32068
aS'    dummy.close();'
p32069
aS'    {'
p32070
aS'      typename MatrixFree<dim, double>::AdditionalData additional_data;'
p32071
aS'      additional_data.tasks_parallel_scheme ='
p32072
aS'        MatrixFree<dim, double>::AdditionalData::none;'
p32073
aS'      additional_data.mapping_update_flags ='
p32074
aS'      additional_data.mapping_update_flags_inner_faces ='
p32075
aS'      additional_data.mapping_update_flags_boundary_faces ='
p32076
aS'         update_quadrature_points);'
p32077
aS'      const auto system_mf_storage ='
p32078
aS'        std::make_shared<MatrixFree<dim, double>>();'
p32079
aS'      system_mf_storage->reinit('
p32080
aS'        mapping, dof_handler, dummy, QGauss<1>(fe.degree + 1), additional_data);'
p32081
aS'      system_matrix.initialize(system_mf_storage);'
p32082
aS'    }'
p32083
aS'    system_matrix.initialize_dof_vector(solution);'
p32084
aS'    system_matrix.initialize_dof_vector(system_rhs);'
p32085
aS'    setup_time += time.wall_time();'
p32086
aS'    time_details << "Setup matrix-free system      " << time.wall_time() << " s"'
p32087
aS'                 << std::endl;'
p32088
aS'    time.restart();'
p32089
aS'    const unsigned int nlevels = triangulation.n_global_levels();'
p32090
aS'    mg_matrices.resize(0, nlevels - 1);'
p32091
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p32092
aS'      {'
p32093
aS'        typename MatrixFree<dim, float>::AdditionalData additional_data;'
p32094
aS'        additional_data.tasks_parallel_scheme ='
p32095
aS'          MatrixFree<dim, float>::AdditionalData::none;'
p32096
aS'        additional_data.mapping_update_flags ='
p32097
aS'        additional_data.mapping_update_flags_inner_faces ='
p32098
aS'        additional_data.mapping_update_flags_boundary_faces ='
p32099
aS'        additional_data.mg_level = level;'
p32100
aS'        const auto mg_mf_storage_level ='
p32101
aS'          std::make_shared<MatrixFree<dim, float>>();'
p32102
aS'        mg_mf_storage_level->reinit(mapping,'
p32103
aS'                                    dof_handler,'
p32104
aS'                                    dummy,'
p32105
aS'                                    QGauss<1>(fe.degree + 1),'
p32106
aS'                                    additional_data);'
p32107
aS'        mg_matrices[level].initialize(mg_mf_storage_level);'
p32108
aS'      }'
p32109
aS'    setup_time += time.wall_time();'
p32110
aS'    time_details << "Setup matrix-free levels      " << time.wall_time() << " s"'
p32111
aS'                 << std::endl;'
p32112
aS'  }'
p32113
aS'  template <int dim, int fe_degree>'
p32114
aS'  void LaplaceProblem<dim, fe_degree>::compute_rhs()'
p32115
aS'  {'
p32116
aS'    Timer time;'
p32117
aS'    system_rhs                          = 0;'
p32118
aS'    const MatrixFree<dim, double> &data = *system_matrix.get_matrix_free();'
p32119
aS'    FEEvaluation<dim, fe_degree>   phi(data);'
p32120
aS'    RightHandSide<dim>             rhs_func;'
p32121
aS'    Solution<dim>                  exact_solution;'
p32122
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p32123
aS'      {'
p32124
aS'        phi.reinit(cell);'
p32125
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p32126
aS'          {'
p32127
aS'            VectorizedArray<double> rhs_val = VectorizedArray<double>();'
p32128
aS'            Point<dim, VectorizedArray<double>> point_batch ='
p32129
aS'              phi.quadrature_point(q);'
p32130
aS'            for (unsigned int v = 0; v < VectorizedArray<double>::size(); ++v)'
p32131
aS'              {'
p32132
aS'                Point<dim> single_point;'
p32133
aS'                for (unsigned int d = 0; d < dim; ++d)'
p32134
aS'                  single_point[d] = point_batch[d][v];'
p32135
aS'                rhs_val[v] = rhs_func.value(single_point);'
p32136
aS'              }'
p32137
aS'            phi.submit_value(rhs_val, q);'
p32138
aS'          }'
p32139
aS'        phi.integrate_scatter(EvaluationFlags::values, system_rhs);'
p32140
aS'      }'
p32141
aS'    FEFaceEvaluation<dim, fe_degree> phi_face(data, true);'
p32142
aS'    for (unsigned int face = data.n_inner_face_batches();'
p32143
aS'         face < data.n_inner_face_batches() + data.n_boundary_face_batches();'
p32144
aS'         ++face)'
p32145
aS'      {'
p32146
aS'        phi_face.reinit(face);'
p32147
aS'        const VectorizedArray<double> inverse_length_normal_to_face ='
p32148
aS'          std::abs((phi_face.get_normal_vector(0) *'
p32149
aS'                    phi_face.inverse_jacobian(0))[dim - 1]);'
p32150
aS'        const VectorizedArray<double> sigma ='
p32151
aS'          inverse_length_normal_to_face * system_matrix.get_penalty_factor();'
p32152
aS'        for (unsigned int q = 0; q < phi_face.n_q_points; ++q)'
p32153
aS'          {'
p32154
aS'            VectorizedArray<double> test_value = VectorizedArray<double>(),'
p32155
aS'                                    test_normal_derivative ='
p32156
aS'                                      VectorizedArray<double>();'
p32157
aS'            Point<dim, VectorizedArray<double>> point_batch ='
p32158
aS'              phi_face.quadrature_point(q);'
p32159
aS'            for (unsigned int v = 0; v < VectorizedArray<double>::size(); ++v)'
p32160
aS'              {'
p32161
aS'                Point<dim> single_point;'
p32162
aS'                for (unsigned int d = 0; d < dim; ++d)'
p32163
aS'                  single_point[d] = point_batch[d][v];'
p32164
aS'                if (data.get_boundary_id(face) == 0)'
p32165
aS'                  test_value[v] = 2.0 * exact_solution.value(single_point);'
p32166
aS'                else'
p32167
aS'                  {'
p32168
aS'                    Tensor<1, dim> normal;'
p32169
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p32170
aS'                      normal[d] = phi_face.get_normal_vector(q)[d][v];'
p32171
aS'                    test_normal_derivative[v] ='
p32172
aS'                      -normal * exact_solution.gradient(single_point);'
p32173
aS'                  }'
p32174
aS'              }'
p32175
aS'            phi_face.submit_value(test_value * sigma - test_normal_derivative,'
p32176
aS'                                  q);'
p32177
aS'            phi_face.submit_normal_derivative(-0.5 * test_value, q);'
p32178
aS'          }'
p32179
aS'        phi_face.integrate_scatter(EvaluationFlags::values |'
p32180
aS'                                     EvaluationFlags::gradients,'
p32181
aS'                                   system_rhs);'
p32182
aS'      }'
p32183
aS'    system_rhs.compress(VectorOperation::add);'
p32184
aS'    setup_time += time.wall_time();'
p32185
aS'    time_details << "Compute right hand side       " << time.wall_time()'
p32186
aS'                 << " s\\n";'
p32187
aS'  }'
p32188
aS'  template <int dim, int fe_degree>'
p32189
aS'  void LaplaceProblem<dim, fe_degree>::solve()'
p32190
aS'  {'
p32191
aS'    Timer                            time;'
p32192
aS'    MGTransferMatrixFree<dim, float> mg_transfer;'
p32193
aS'    mg_transfer.build(dof_handler);'
p32194
aS'    setup_time += time.wall_time();'
p32195
aS'    time_details << "MG build transfer time        " << time.wall_time()'
p32196
aS'                 << " s\\n";'
p32197
aS'    time.restart();'
p32198
aS'    using SmootherType ='
p32199
aS'      PreconditionChebyshev<LevelMatrixType,'
p32200
aS'                            LinearAlgebra::distributed::Vector<float>,'
p32201
aS'                            PreconditionBlockJacobi<dim, fe_degree, float>>;'
p32202
aS'    mg::SmootherRelaxation<SmootherType,'
p32203
aS'                           LinearAlgebra::distributed::Vector<float>>'
p32204
aS'                                                         mg_smoother;'
p32205
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data;'
p32206
aS'    smoother_data.resize(0, triangulation.n_global_levels() - 1);'
p32207
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p32208
aS'         ++level)'
p32209
aS'      {'
p32210
aS'        if (level > 0)'
p32211
aS'          {'
p32212
aS'            smoother_data[level].smoothing_range     = 15.;'
p32213
aS'            smoother_data[level].degree              = 3;'
p32214
aS'            smoother_data[level].eig_cg_n_iterations = 10;'
p32215
aS'          }'
p32216
aS'        else'
p32217
aS'          {'
p32218
aS'            smoother_data[0].smoothing_range = 2e-2;'
p32219
aS'            smoother_data[0].degree          = numbers::invalid_unsigned_int;'
p32220
aS'            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();'
p32221
aS'          }'
p32222
aS'        smoother_data[level].preconditioner ='
p32223
aS'          std::make_shared<PreconditionBlockJacobi<dim, fe_degree, float>>();'
p32224
aS'        smoother_data[level].preconditioner->initialize(mg_matrices[level]);'
p32225
aS'      }'
p32226
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p32227
aS'    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>>'
p32228
aS'      mg_coarse;'
p32229
aS'    mg_coarse.initialize(mg_smoother);'
p32230
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix('
p32231
aS'      mg_matrices);'
p32232
aS'    Multigrid<LinearAlgebra::distributed::Vector<float>> mg('
p32233
aS'      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p32234
aS'    PreconditionMG<dim,'
p32235
aS'                   LinearAlgebra::distributed::Vector<float>,'
p32236
aS'                   MGTransferMatrixFree<dim, float>>'
p32237
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p32238
aS'    SolverControl solver_control(10000, 1e-12 * system_rhs.l2_norm());'
p32239
aS'    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control);'
p32240
aS'    setup_time += time.wall_time();'
p32241
aS'    time_details << "MG build smoother time        " << time.wall_time()'
p32242
aS'                 << "s\\n";'
p32243
aS'    pcout << "Total setup time              " << setup_time << " s\\n";'
p32244
aS'    time.reset();'
p32245
aS'    time.start();'
p32246
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p32247
aS'    pcout << "Time solve (" << solver_control.last_step() << " iterations)    "'
p32248
aS'          << time.wall_time() << " s" << std::endl;'
p32249
aS'  }'
p32250
aS'  template <int dim, int fe_degree>'
p32251
aS'  void LaplaceProblem<dim, fe_degree>::analyze_results() const'
p32252
aS'  {'
p32253
aS'    Vector<float> error_per_cell(triangulation.n_active_cells());'
p32254
aS'    VectorTools::integrate_difference(mapping,'
p32255
aS'                                      dof_handler,'
p32256
aS'                                      solution,'
p32257
aS'                                      Solution<dim>(),'
p32258
aS'                                      error_per_cell,'
p32259
aS'                                      QGauss<dim>(fe.degree + 2),'
p32260
aS'                                      VectorTools::L2_norm);'
p32261
aS'    pcout << "Verification via L2 error:    "'
p32262
aS'          << std::sqrt('
p32263
aS'               Utilities::MPI::sum(error_per_cell.norm_sqr(), MPI_COMM_WORLD))'
p32264
aS'          << std::endl;'
p32265
aS'  }'
p32266
aS'  template <int dim, int fe_degree>'
p32267
aS'  void LaplaceProblem<dim, fe_degree>::run()'
p32268
aS'  {'
p32269
aS'    const unsigned int n_ranks ='
p32270
aS'      Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD);'
p32271
aS'    pcout << "Running with " << n_ranks << " MPI process"'
p32272
aS'          << (n_ranks > 1 ? "es" : "") << ", element " << fe.get_name()'
p32273
aS'          << std::endl'
p32274
aS'          << std::endl;'
p32275
aS'    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle)'
p32276
aS'      {'
p32277
aS'        pcout << "Cycle " << cycle << std::endl;'
p32278
aS'        if (cycle == 0)'
p32279
aS'          {'
p32280
aS'            Point<dim> upper_right;'
p32281
aS'            upper_right[0] = 2.5;'
p32282
aS'            for (unsigned int d = 1; d < dim; ++d)'
p32283
aS'              upper_right[d] = 2.8;'
p32284
aS'            GridGenerator::hyper_rectangle(triangulation,'
p32285
aS'                                           Point<dim>(),'
p32286
aS'                                           upper_right);'
p32287
aS'            triangulation.begin_active()->face(0)->set_boundary_id(10);'
p32288
aS'            triangulation.begin_active()->face(1)->set_boundary_id(11);'
p32289
aS'            triangulation.begin_active()->face(2)->set_boundary_id(0);'
p32290
aS'            for (unsigned int f = 3;'
p32291
aS'                 f < triangulation.begin_active()->n_faces();'
p32292
aS'                 ++f)'
p32293
aS'              triangulation.begin_active()->face(f)->set_boundary_id(1);'
p32294
aS'            std::vector<GridTools::PeriodicFacePair<'
p32295
aS'              typename Triangulation<dim>::cell_iterator>>'
p32296
aS'              periodic_faces;'
p32297
aS'            GridTools::collect_periodic_faces('
p32298
aS'              triangulation, 10, 11, 0, periodic_faces);'
p32299
aS'            triangulation.add_periodicity(periodic_faces);'
p32300
aS'            triangulation.refine_global(6 - 2 * dim);'
p32301
aS'          }'
p32302
aS'        triangulation.refine_global(1);'
p32303
aS'        setup_system();'
p32304
aS'        compute_rhs();'
p32305
aS'        solve();'
p32306
aS'        analyze_results();'
p32307
aS'        pcout << std::endl;'
p32308
aS'      };'
p32309
aS'  }'
p32310
aS'} // namespace Step59'
p32311
aS'int main(int argc, char *argv[])'
p32312
ag9
aS'  try'
p32313
aS'    {'
p32314
aS'      using namespace Step59;'
p32315
aS'      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);'
p32316
aS'      LaplaceProblem<dimension, degree_finite_element> laplace_problem;'
p32317
aS'      laplace_problem.run();'
p32318
aS'    }'
p32319
aS'  catch (std::exception &exc)'
p32320
aS'    {'
p32321
aS'      std::cerr << std::endl'
p32322
aS'                << std::endl'
p32323
aS'                << "----------------------------------------------------"'
p32324
aS'                << std::endl;'
p32325
aS'      std::cerr << "Exception on processing: " << std::endl'
p32326
aS'                << exc.what() << std::endl'
p32327
aS'                << "Aborting!" << std::endl'
p32328
aS'                << "----------------------------------------------------"'
p32329
aS'                << std::endl;'
p32330
aS'      return 1;'
p32331
aS'    }'
p32332
aS'  catch (...)'
p32333
aS'    {'
p32334
aS'      std::cerr << std::endl'
p32335
aS'                << std::endl'
p32336
aS'                << "----------------------------------------------------"'
p32337
aS'                << std::endl;'
p32338
aS'      std::cerr << "Unknown exception!" << std::endl'
p32339
aS'                << "Aborting!" << std::endl'
p32340
aS'                << "----------------------------------------------------"'
p32341
aS'                << std::endl;'
p32342
aS'      return 1;'
p32343
aS'    }'
p32344
aS'  return 0;'
p32345
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p32346
aS'#include <deal.II/dofs/dof_handler.h>'
p32347
aS'#include <deal.II/dofs/dof_tools.h>'
p32348
aS'#include <deal.II/fe/fe_values.h>'
p32349
aS'#include <deal.II/grid/tria.h>'
p32350
aS'#include <deal.II/grid/grid_generator.h>'
p32351
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p32352
aS'#include <deal.II/lac/full_matrix.h>'
p32353
aS'#include <deal.II/lac/precondition.h>'
p32354
aS'#include <deal.II/lac/solver_cg.h>'
p32355
aS'#include <deal.II/lac/sparse_matrix.h>'
p32356
aS'#include <deal.II/lac/vector.h>'
p32357
aS'#include <deal.II/numerics/data_out.h>'
p32358
aS'#include <deal.II/numerics/vector_tools.h>'
p32359
aS'#include <fstream>'
p32360
aS'#include <deal.II/fe/fe_q.h>'
p32361
aS'#include <deal.II/grid/grid_out.h>'
p32362
aS'#include <deal.II/lac/affine_constraints.h>'
p32363
aS'#include <deal.II/grid/grid_refinement.h>'
p32364
aS'#include <deal.II/numerics/error_estimator.h>'
p32365
aS'using namespace dealii;'
p32366
aS'template <int dim>'
p32367
aS'class Step6'
p32368
ag9
aS'public:'
p32369
aS'  Step6();'
p32370
aS'  void run();'
p32371
aS'private:'
p32372
aS'  void setup_system();'
p32373
aS'  void assemble_system();'
p32374
aS'  void solve();'
p32375
aS'  void refine_grid();'
p32376
aS'  void output_results(const unsigned int cycle) const;'
p32377
aS'  Triangulation<dim> triangulation;'
p32378
aS'  FE_Q<dim>       fe;'
p32379
aS'  DoFHandler<dim> dof_handler;'
p32380
aS'  AffineConstraints<double> constraints;'
p32381
aS'  SparseMatrix<double> system_matrix;'
p32382
aS'  SparsityPattern      sparsity_pattern;'
p32383
aS'  Vector<double> solution;'
p32384
aS'  Vector<double> system_rhs;'
p32385
aS'};'
p32386
aS'template <int dim>'
p32387
aS'double coefficient(const Point<dim> &p)'
p32388
ag9
aS'  if (p.square() < 0.5 * 0.5)'
p32389
aS'    return 20;'
p32390
aS'  else'
p32391
aS'    return 1;'
p32392
ag17
aS'template <int dim>'
p32393
aS'Step6<dim>::Step6()'
p32394
aS'  : fe(2)'
p32395
aS'  , dof_handler(triangulation)'
p32396
aS'{}'
p32397
aS'template <int dim>'
p32398
aS'void Step6<dim>::setup_system()'
p32399
ag9
aS'  dof_handler.distribute_dofs(fe);'
p32400
aS'  solution.reinit(dof_handler.n_dofs());'
p32401
aS'  system_rhs.reinit(dof_handler.n_dofs());'
p32402
aS'  constraints.clear();'
p32403
aS'  DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p32404
aS'  VectorTools::interpolate_boundary_values(dof_handler,'
p32405
aS'                                           0,'
p32406
aS'                                           Functions::ZeroFunction<dim>(),'
p32407
aS'                                           constraints);'
p32408
aS'  constraints.close();'
p32409
aS'  DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p32410
aS'  DoFTools::make_sparsity_pattern(dof_handler,'
p32411
aS'                                  dsp,'
p32412
aS'                                  constraints,'
p32413
aS'  sparsity_pattern.copy_from(dsp);'
p32414
aS'  system_matrix.reinit(sparsity_pattern);'
p32415
ag17
aS'template <int dim>'
p32416
aS'void Step6<dim>::assemble_system()'
p32417
ag9
aS'  const QGauss<dim> quadrature_formula(fe.degree + 1);'
p32418
aS'  FEValues<dim> fe_values(fe,'
p32419
aS'                          quadrature_formula,'
p32420
aS'                          update_values | update_gradients |'
p32421
aS'                            update_quadrature_points | update_JxW_values);'
p32422
aS'  const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p32423
aS'  FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p32424
aS'  Vector<double>     cell_rhs(dofs_per_cell);'
p32425
aS'  std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p32426
aS'  for (const auto &cell : dof_handler.active_cell_iterators())'
p32427
aS'    {'
p32428
aS'      cell_matrix = 0;'
p32429
aS'      cell_rhs    = 0;'
p32430
aS'      fe_values.reinit(cell);'
p32431
aS'      for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p32432
aS'        {'
p32433
aS'          const double current_coefficient ='
p32434
aS'            coefficient(fe_values.quadrature_point(q_index));'
p32435
aS'          for (const unsigned int i : fe_values.dof_indices())'
p32436
aS'            {'
p32437
aS'              for (const unsigned int j : fe_values.dof_indices())'
p32438
aS'                cell_matrix(i, j) +='
p32439
aS'                   fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p32440
aS'                   fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p32441
aS'                   fe_values.JxW(q_index));           // dx'
p32442
aS'              cell_rhs(i) += (1.0 *                               // f(x)'
p32443
aS'                              fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p32444
aS'                              fe_values.JxW(q_index));            // dx'
p32445
aS'            }'
p32446
aS'        }'
p32447
aS'      cell->get_dof_indices(local_dof_indices);'
p32448
aS'      constraints.distribute_local_to_global('
p32449
aS'        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p32450
aS'    }'
p32451
ag17
aS'template <int dim>'
p32452
aS'void Step6<dim>::solve()'
p32453
ag9
aS'  SolverControl            solver_control(1000, 1e-12);'
p32454
aS'  SolverCG<Vector<double>> solver(solver_control);'
p32455
aS'  PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p32456
aS'  preconditioner.initialize(system_matrix, 1.2);'
p32457
aS'  solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p32458
aS'  constraints.distribute(solution);'
p32459
ag17
aS'template <int dim>'
p32460
aS'void Step6<dim>::refine_grid()'
p32461
ag9
aS'  Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p32462
aS'  KellyErrorEstimator<dim>::estimate(dof_handler,'
p32463
aS'                                     QGauss<dim - 1>(fe.degree + 1),'
p32464
aS'                                     {},'
p32465
aS'                                     solution,'
p32466
aS'                                     estimated_error_per_cell);'
p32467
aS'  GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p32468
aS'                                                  estimated_error_per_cell,'
p32469
aS'                                                  0.3,'
p32470
aS'                                                  0.03);'
p32471
aS'  triangulation.execute_coarsening_and_refinement();'
p32472
ag17
aS'template <int dim>'
p32473
aS'void Step6<dim>::output_results(const unsigned int cycle) const'
p32474
ag9
aS'  {'
p32475
aS'    GridOut               grid_out;'
p32476
aS'    std::ofstream         output("grid-" + std::to_string(cycle) + ".gnuplot");'
p32477
aS'    GridOutFlags::Gnuplot gnuplot_flags(false, 5);'
p32478
aS'    grid_out.set_flags(gnuplot_flags);'
p32479
aS'    MappingQGeneric<dim> mapping(3);'
p32480
aS'    grid_out.write_gnuplot(triangulation, output, &mapping);'
p32481
aS'  }'
p32482
aS'  {'
p32483
aS'    DataOut<dim> data_out;'
p32484
aS'    data_out.attach_dof_handler(dof_handler);'
p32485
aS'    data_out.add_data_vector(solution, "solution");'
p32486
aS'    data_out.build_patches();'
p32487
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtu");'
p32488
aS'    data_out.write_vtu(output);'
p32489
aS'  }'
p32490
ag17
aS'template <int dim>'
p32491
aS'void Step6<dim>::run()'
p32492
ag9
aS'  for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p32493
aS'    {'
p32494
aS'      std::cout << "Cycle " << cycle << \':\' << std::endl;'
p32495
aS'      if (cycle == 0)'
p32496
aS'        {'
p32497
aS'          GridGenerator::hyper_ball(triangulation);'
p32498
aS'          triangulation.refine_global(1);'
p32499
aS'        }'
p32500
aS'      else'
p32501
aS'        refine_grid();'
p32502
aS'      std::cout << "   Number of active cells:       "'
p32503
aS'                << triangulation.n_active_cells() << std::endl;'
p32504
aS'      setup_system();'
p32505
aS'      std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p32506
aS'                << std::endl;'
p32507
aS'      assemble_system();'
p32508
aS'      solve();'
p32509
aS'      output_results(cycle);'
p32510
aS'    }'
p32511
ag17
aS'int main()'
p32512
ag9
aS'  try'
p32513
aS'    {'
p32514
aS'      Step6<2> laplace_problem_2d;'
p32515
aS'      laplace_problem_2d.run();'
p32516
aS'    }'
p32517
aS'  catch (std::exception &exc)'
p32518
aS'    {'
p32519
aS'      std::cerr << std::endl'
p32520
aS'                << std::endl'
p32521
aS'                << "----------------------------------------------------"'
p32522
aS'                << std::endl;'
p32523
aS'      std::cerr << "Exception on processing: " << std::endl'
p32524
aS'                << exc.what() << std::endl'
p32525
aS'                << "Aborting!" << std::endl'
p32526
aS'                << "----------------------------------------------------"'
p32527
aS'                << std::endl;'
p32528
aS'      return 1;'
p32529
aS'    }'
p32530
aS'  catch (...)'
p32531
aS'    {'
p32532
aS'      std::cerr << std::endl'
p32533
aS'                << std::endl'
p32534
aS'                << "----------------------------------------------------"'
p32535
aS'                << std::endl;'
p32536
aS'      std::cerr << "Unknown exception!" << std::endl'
p32537
aS'                << "Aborting!" << std::endl'
p32538
aS'                << "----------------------------------------------------"'
p32539
aS'                << std::endl;'
p32540
aS'      return 1;'
p32541
aS'    }'
p32542
aS'  return 0;'
p32543
ag17
aS'#include <deal.II/base/logstream.h>'
p32544
aS'#include <deal.II/base/utilities.h>'
p32545
aS'#include <deal.II/base/timer.h>'
p32546
aS'#include <deal.II/base/parameter_acceptor.h>'
p32547
aS'#include <deal.II/grid/tria.h>'
p32548
aS'#include <deal.II/grid/grid_generator.h>'
p32549
aS'#include <deal.II/grid/grid_tools.h>'
p32550
aS'#include <deal.II/grid/grid_tools_cache.h>'
p32551
aS'#include <deal.II/fe/fe.h>'
p32552
aS'#include <deal.II/fe/fe_q.h>'
p32553
aS'#include <deal.II/fe/fe_system.h>'
p32554
aS'#include <deal.II/fe/mapping_q_eulerian.h>'
p32555
aS'#include <deal.II/fe/mapping_fe_field.h>'
p32556
aS'#include <deal.II/dofs/dof_tools.h>'
p32557
aS'#include <deal.II/base/parsed_function.h>'
p32558
aS'#include <deal.II/numerics/data_out.h>'
p32559
aS'#include <deal.II/numerics/vector_tools.h>'
p32560
aS'#include <deal.II/numerics/matrix_tools.h>'
p32561
aS'#include <deal.II/non_matching/coupling.h>'
p32562
aS'#include <deal.II/lac/affine_constraints.h>'
p32563
aS'#include <deal.II/lac/sparse_matrix.h>'
p32564
aS'#include <deal.II/lac/vector.h>'
p32565
aS'#include <deal.II/lac/sparse_direct.h>'
p32566
aS'#include <deal.II/lac/solver_cg.h>'
p32567
aS'#include <deal.II/lac/precondition.h>'
p32568
aS'#include <deal.II/lac/linear_operator.h>'
p32569
aS'#include <deal.II/lac/linear_operator_tools.h>'
p32570
aS'#include <iostream>'
p32571
aS'#include <fstream>'
p32572
aS'namespace Step60'
p32573
ag9
aS'  using namespace dealii;'
p32574
aS'  template <int dim, int spacedim = dim>'
p32575
aS'  class DistributedLagrangeProblem'
p32576
aS'  {'
p32577
aS'  public:'
p32578
aS'    class Parameters : public ParameterAcceptor'
p32579
aS'    {'
p32580
aS'    public:'
p32581
aS'      Parameters();'
p32582
aS'      unsigned int initial_refinement = 4;'
p32583
aS'      unsigned int delta_refinement = 3;'
p32584
aS'      unsigned int initial_embedded_refinement = 8;'
p32585
aS'      std::list<types::boundary_id> homogeneous_dirichlet_ids{0, 1, 2, 3};'
p32586
aS'      unsigned int embedding_space_finite_element_degree = 1;'
p32587
aS'      unsigned int embedded_space_finite_element_degree = 1;'
p32588
aS'      unsigned int embedded_configuration_finite_element_degree = 1;'
p32589
aS'      unsigned int coupling_quadrature_order = 3;'
p32590
aS'      bool use_displacement = false;'
p32591
aS'      unsigned int verbosity_level = 10;'
p32592
aS'      bool initialized = false;'
p32593
aS'    };'
p32594
aS'    DistributedLagrangeProblem(const Parameters &parameters);'
p32595
aS'    void run();'
p32596
aS'  private:'
p32597
aS'    const Parameters &parameters;'
p32598
aS'    void setup_grids_and_dofs();'
p32599
aS'    void setup_embedding_dofs();'
p32600
aS'    void setup_embedded_dofs();'
p32601
aS'    void setup_coupling();'
p32602
aS'    void assemble_system();'
p32603
aS'    void solve();'
p32604
aS'    void output_results();'
p32605
aS'    std::unique_ptr<Triangulation<spacedim>> space_grid;'
p32606
aS'    std::unique_ptr<GridTools::Cache<spacedim, spacedim>>'
p32607
aS'                                             space_grid_tools_cache;'
p32608
aS'    std::unique_ptr<FiniteElement<spacedim>> space_fe;'
p32609
aS'    std::unique_ptr<DoFHandler<spacedim>>    space_dh;'
p32610
aS'    std::unique_ptr<Triangulation<dim, spacedim>> embedded_grid;'
p32611
aS'    std::unique_ptr<FiniteElement<dim, spacedim>> embedded_fe;'
p32612
aS'    std::unique_ptr<DoFHandler<dim, spacedim>>    embedded_dh;'
p32613
aS'    std::unique_ptr<FiniteElement<dim, spacedim>> embedded_configuration_fe;'
p32614
aS'    std::unique_ptr<DoFHandler<dim, spacedim>>    embedded_configuration_dh;'
p32615
aS'    Vector<double>                                embedded_configuration;'
p32616
aS'    ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>'
p32617
aS'      embedded_configuration_function;'
p32618
aS'    std::unique_ptr<Mapping<dim, spacedim>> embedded_mapping;'
p32619
aS'    ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>'
p32620
aS'      embedded_value_function;'
p32621
aS'    ParameterAcceptorProxy<ReductionControl> schur_solver_control;'
p32622
aS'    SparsityPattern stiffness_sparsity;'
p32623
aS'    SparsityPattern coupling_sparsity;'
p32624
aS'    SparseMatrix<double> stiffness_matrix;'
p32625
aS'    SparseMatrix<double> coupling_matrix;'
p32626
aS'    AffineConstraints<double> constraints;'
p32627
aS'    Vector<double> solution;'
p32628
aS'    Vector<double> rhs;'
p32629
aS'    Vector<double> lambda;'
p32630
aS'    Vector<double> embedded_rhs;'
p32631
aS'    Vector<double> embedded_value;'
p32632
aS'    TimerOutput monitor;'
p32633
aS'  };'
p32634
aS'  template <int dim, int spacedim>'
p32635
aS'  DistributedLagrangeProblem<dim, spacedim>::Parameters::Parameters()'
p32636
aS'    : ParameterAcceptor("/Distributed Lagrange<" +'
p32637
aS'                        Utilities::int_to_string(dim) + "," +'
p32638
aS'                        Utilities::int_to_string(spacedim) + ">/")'
p32639
aS'  {'
p32640
aS'    add_parameter("Initial embedding space refinement", initial_refinement);'
p32641
aS'    add_parameter("Initial embedded space refinement",'
p32642
aS'                  initial_embedded_refinement);'
p32643
aS'    add_parameter("Local refinements steps near embedded domain",'
p32644
aS'                  delta_refinement);'
p32645
aS'    add_parameter("Homogeneous Dirichlet boundary ids",'
p32646
aS'                  homogeneous_dirichlet_ids);'
p32647
aS'    add_parameter("Use displacement in embedded interface", use_displacement);'
p32648
aS'    add_parameter("Embedding space finite element degree",'
p32649
aS'                  embedding_space_finite_element_degree);'
p32650
aS'    add_parameter("Embedded space finite element degree",'
p32651
aS'                  embedded_space_finite_element_degree);'
p32652
aS'    add_parameter("Embedded configuration finite element degree",'
p32653
aS'                  embedded_configuration_finite_element_degree);'
p32654
aS'    add_parameter("Coupling quadrature order", coupling_quadrature_order);'
p32655
aS'    add_parameter("Verbosity level", verbosity_level);'
p32656
aS'    parse_parameters_call_back.connect([&]() -> void { initialized = true; });'
p32657
aS'  }'
p32658
aS'  template <int dim, int spacedim>'
p32659
aS'  DistributedLagrangeProblem<dim, spacedim>::DistributedLagrangeProblem('
p32660
aS'    const Parameters &parameters)'
p32661
aS'    : parameters(parameters)'
p32662
aS'    , embedded_configuration_function("Embedded configuration", spacedim)'
p32663
aS'    , embedded_value_function("Embedded value")'
p32664
aS'    , schur_solver_control("Schur solver control")'
p32665
aS'    , monitor(std::cout, TimerOutput::summary, TimerOutput::cpu_and_wall_times)'
p32666
aS'  {'
p32667
aS'    embedded_configuration_function.declare_parameters_call_back.connect('
p32668
aS'      []() -> void {'
p32669
aS'        ParameterAcceptor::prm.set("Function constants", "R=.3, Cx=.4, Cy=.4");'
p32670
aS'        ParameterAcceptor::prm.set("Function expression",'
p32671
aS'                                   "R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy");'
p32672
aS'      });'
p32673
aS'    embedded_value_function.declare_parameters_call_back.connect('
p32674
aS'      []() -> void { ParameterAcceptor::prm.set("Function expression", "1"); });'
p32675
aS'    schur_solver_control.declare_parameters_call_back.connect([]() -> void {'
p32676
aS'      ParameterAcceptor::prm.set("Max steps", "1000");'
p32677
aS'      ParameterAcceptor::prm.set("Reduction", "1.e-12");'
p32678
aS'      ParameterAcceptor::prm.set("Tolerance", "1.e-12");'
p32679
aS'    });'
p32680
aS'  }'
p32681
aS'  template <int dim, int spacedim>'
p32682
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_grids_and_dofs()'
p32683
aS'  {'
p32684
aS'    TimerOutput::Scope timer_section(monitor, "Setup grids and dofs");'
p32685
aS'    space_grid = std::make_unique<Triangulation<spacedim>>();'
p32686
aS'    GridGenerator::hyper_cube(*space_grid, 0, 1, true);'
p32687
aS'    space_grid->refine_global(parameters.initial_refinement);'
p32688
aS'    space_grid_tools_cache ='
p32689
aS'      std::make_unique<GridTools::Cache<spacedim, spacedim>>(*space_grid);'
p32690
aS'    embedded_grid = std::make_unique<Triangulation<dim, spacedim>>();'
p32691
aS'    GridGenerator::hyper_cube(*embedded_grid);'
p32692
aS'    embedded_grid->refine_global(parameters.initial_embedded_refinement);'
p32693
aS'    embedded_configuration_fe = std::make_unique<FESystem<dim, spacedim>>('
p32694
aS'      FE_Q<dim, spacedim>('
p32695
aS'        parameters.embedded_configuration_finite_element_degree),'
p32696
aS'      spacedim);'
p32697
aS'    embedded_configuration_dh ='
p32698
aS'      std::make_unique<DoFHandler<dim, spacedim>>(*embedded_grid);'
p32699
aS'    embedded_configuration_dh->distribute_dofs(*embedded_configuration_fe);'
p32700
aS'    embedded_configuration.reinit(embedded_configuration_dh->n_dofs());'
p32701
aS'    VectorTools::interpolate(*embedded_configuration_dh,'
p32702
aS'                             embedded_configuration_function,'
p32703
aS'                             embedded_configuration);'
p32704
aS'    if (parameters.use_displacement == true)'
p32705
aS'      embedded_mapping ='
p32706
aS'        std::make_unique<MappingQEulerian<dim, Vector<double>, spacedim>>('
p32707
aS'          parameters.embedded_configuration_finite_element_degree,'
p32708
aS'          embedded_configuration);'
p32709
aS'    else'
p32710
aS'      embedded_mapping ='
p32711
aS'        std::make_unique<MappingFEField<dim, spacedim, Vector<double>>>('
p32712
aS'    setup_embedded_dofs();'
p32713
aS'    std::vector<Point<spacedim>> support_points(embedded_dh->n_dofs());'
p32714
aS'    if (parameters.delta_refinement != 0)'
p32715
aS'      DoFTools::map_dofs_to_support_points(*embedded_mapping,'
p32716
aS'                                           support_points);'
p32717
aS'    for (unsigned int i = 0; i < parameters.delta_refinement; ++i)'
p32718
aS'      {'
p32719
aS'        const auto point_locations ='
p32720
aS'          GridTools::compute_point_locations(*space_grid_tools_cache,'
p32721
aS'                                             support_points);'
p32722
aS'        const auto &cells = std::get<0>(point_locations);'
p32723
aS'        for (auto &cell : cells)'
p32724
aS'          {'
p32725
aS'            cell->set_refine_flag();'
p32726
aS'            for (const auto face_no : cell->face_indices())'
p32727
aS'              if (!cell->at_boundary(face_no))'
p32728
aS'                cell->neighbor(face_no)->set_refine_flag();'
p32729
aS'          }'
p32730
aS'        space_grid->execute_coarsening_and_refinement();'
p32731
aS'      }'
p32732
aS'    const double embedded_space_maximal_diameter ='
p32733
aS'      GridTools::maximal_cell_diameter(*embedded_grid, *embedded_mapping);'
p32734
aS'    double embedding_space_minimal_diameter ='
p32735
aS'      GridTools::minimal_cell_diameter(*space_grid);'
p32736
aS'    deallog << "Embedding minimal diameter: "'
p32737
aS'            << embedding_space_minimal_diameter'
p32738
aS'            << ", embedded maximal diameter: "'
p32739
aS'            << embedded_space_maximal_diameter << ", ratio: "'
p32740
aS'            << embedded_space_maximal_diameter /'
p32741
aS'                 embedding_space_minimal_diameter'
p32742
aS'            << std::endl;'
p32743
aS'    AssertThrow(embedded_space_maximal_diameter <'
p32744
aS'                  embedding_space_minimal_diameter,'
p32745
aS'                ExcMessage('
p32746
aS'                  "The embedding grid is too refined (or the embedded grid "'
p32747
aS'                  "is too coarse). Adjust the parameters so that the minimal "'
p32748
aS'                  "grid size of the embedding grid is larger "'
p32749
aS'                  "than the maximal grid size of the embedded grid."));'
p32750
aS'    setup_embedding_dofs();'
p32751
aS'  }'
p32752
aS'  template <int dim, int spacedim>'
p32753
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_embedding_dofs()'
p32754
aS'  {'
p32755
aS'    space_dh = std::make_unique<DoFHandler<spacedim>>(*space_grid);'
p32756
aS'    space_fe = std::make_unique<FE_Q<spacedim>>('
p32757
aS'      parameters.embedding_space_finite_element_degree);'
p32758
aS'    space_dh->distribute_dofs(*space_fe);'
p32759
aS'    DoFTools::make_hanging_node_constraints(*space_dh, constraints);'
p32760
aS'    for (auto id : parameters.homogeneous_dirichlet_ids)'
p32761
aS'      {'
p32762
aS'        VectorTools::interpolate_boundary_values('
p32763
aS'      }'
p32764
aS'    constraints.close();'
p32765
aS'    DynamicSparsityPattern dsp(space_dh->n_dofs(), space_dh->n_dofs());'
p32766
aS'    DoFTools::make_sparsity_pattern(*space_dh, dsp, constraints);'
p32767
aS'    stiffness_sparsity.copy_from(dsp);'
p32768
aS'    stiffness_matrix.reinit(stiffness_sparsity);'
p32769
aS'    solution.reinit(space_dh->n_dofs());'
p32770
aS'    rhs.reinit(space_dh->n_dofs());'
p32771
aS'    deallog << "Embedding dofs: " << space_dh->n_dofs() << std::endl;'
p32772
aS'  }'
p32773
aS'  template <int dim, int spacedim>'
p32774
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_embedded_dofs()'
p32775
aS'  {'
p32776
aS'    embedded_dh = std::make_unique<DoFHandler<dim, spacedim>>(*embedded_grid);'
p32777
aS'    embedded_fe = std::make_unique<FE_Q<dim, spacedim>>('
p32778
aS'      parameters.embedded_space_finite_element_degree);'
p32779
aS'    embedded_dh->distribute_dofs(*embedded_fe);'
p32780
aS'    lambda.reinit(embedded_dh->n_dofs());'
p32781
aS'    embedded_rhs.reinit(embedded_dh->n_dofs());'
p32782
aS'    embedded_value.reinit(embedded_dh->n_dofs());'
p32783
aS'    deallog << "Embedded dofs: " << embedded_dh->n_dofs() << std::endl;'
p32784
aS'  }'
p32785
aS'  template <int dim, int spacedim>'
p32786
aS'  void DistributedLagrangeProblem<dim, spacedim>::setup_coupling()'
p32787
aS'  {'
p32788
aS'    TimerOutput::Scope timer_section(monitor, "Setup coupling");'
p32789
aS'    QGauss<dim> quad(parameters.coupling_quadrature_order);'
p32790
aS'    DynamicSparsityPattern dsp(space_dh->n_dofs(), embedded_dh->n_dofs());'
p32791
aS'    NonMatching::create_coupling_sparsity_pattern(*space_grid_tools_cache,'
p32792
aS'                                                  quad,'
p32793
aS'                                                  dsp,'
p32794
aS'                                                  AffineConstraints<double>(),'
p32795
aS'                                                  ComponentMask(),'
p32796
aS'                                                  ComponentMask(),'
p32797
aS'    coupling_sparsity.copy_from(dsp);'
p32798
aS'    coupling_matrix.reinit(coupling_sparsity);'
p32799
aS'  }'
p32800
aS'  template <int dim, int spacedim>'
p32801
aS'  void DistributedLagrangeProblem<dim, spacedim>::assemble_system()'
p32802
aS'  {'
p32803
aS'    {'
p32804
aS'      TimerOutput::Scope timer_section(monitor, "Assemble system");'
p32805
aS'      MatrixTools::create_laplace_matrix('
p32806
aS'        QGauss<spacedim>(2 * space_fe->degree + 1),'
p32807
aS'        stiffness_matrix,'
p32808
aS'        static_cast<const Function<spacedim> *>(nullptr),'
p32809
aS'        constraints);'
p32810
aS'      VectorTools::create_right_hand_side(*embedded_mapping,'
p32811
aS'                                          QGauss<dim>(2 * embedded_fe->degree +'
p32812
aS'                                                      1),'
p32813
aS'                                          embedded_value_function,'
p32814
aS'                                          embedded_rhs);'
p32815
aS'    }'
p32816
aS'    {'
p32817
aS'      TimerOutput::Scope timer_section(monitor, "Assemble coupling system");'
p32818
aS'      QGauss<dim> quad(parameters.coupling_quadrature_order);'
p32819
aS'      NonMatching::create_coupling_mass_matrix(*space_grid_tools_cache,'
p32820
aS'                                               quad,'
p32821
aS'                                               coupling_matrix,'
p32822
aS'                                               AffineConstraints<double>(),'
p32823
aS'                                               ComponentMask(),'
p32824
aS'                                               ComponentMask(),'
p32825
aS'      VectorTools::interpolate(*embedded_mapping,'
p32826
aS'                               embedded_value_function,'
p32827
aS'                               embedded_value);'
p32828
aS'    }'
p32829
aS'  }'
p32830
aS'  template <int dim, int spacedim>'
p32831
aS'  void DistributedLagrangeProblem<dim, spacedim>::solve()'
p32832
aS'  {'
p32833
aS'    TimerOutput::Scope timer_section(monitor, "Solve system");'
p32834
aS'    SparseDirectUMFPACK K_inv_umfpack;'
p32835
aS'    K_inv_umfpack.initialize(stiffness_matrix);'
p32836
aS'    auto K  = linear_operator(stiffness_matrix);'
p32837
aS'    auto Ct = linear_operator(coupling_matrix);'
p32838
aS'    auto C  = transpose_operator(Ct);'
p32839
aS'    auto K_inv = linear_operator(K, K_inv_umfpack);'
p32840
aS'    auto                     S = C * K_inv * Ct;'
p32841
aS'    SolverCG<Vector<double>> solver_cg(schur_solver_control);'
p32842
aS'    auto S_inv = inverse_operator(S, solver_cg, PreconditionIdentity());'
p32843
aS'    lambda = S_inv * embedded_rhs;'
p32844
aS'    solution = K_inv * Ct * lambda;'
p32845
aS'    constraints.distribute(solution);'
p32846
aS'  }'
p32847
aS'  template <int dim, int spacedim>'
p32848
aS'  void DistributedLagrangeProblem<dim, spacedim>::output_results()'
p32849
aS'  {'
p32850
aS'    TimerOutput::Scope timer_section(monitor, "Output results");'
p32851
aS'    DataOut<spacedim> embedding_out;'
p32852
aS'    std::ofstream embedding_out_file("embedding.vtu");'
p32853
aS'    embedding_out.attach_dof_handler(*space_dh);'
p32854
aS'    embedding_out.add_data_vector(solution, "solution");'
p32855
aS'    embedding_out.build_patches('
p32856
aS'      parameters.embedding_space_finite_element_degree);'
p32857
aS'    embedding_out.write_vtu(embedding_out_file);'
p32858
aS'    DataOut<dim, spacedim> embedded_out;'
p32859
aS'    std::ofstream embedded_out_file("embedded.vtu");'
p32860
aS'    embedded_out.attach_dof_handler(*embedded_dh);'
p32861
aS'    embedded_out.add_data_vector(lambda, "lambda");'
p32862
aS'    embedded_out.add_data_vector(embedded_value, "g");'
p32863
aS'    embedded_out.build_patches(*embedded_mapping,'
p32864
aS'                               parameters.embedded_space_finite_element_degree);'
p32865
aS'    embedded_out.write_vtu(embedded_out_file);'
p32866
aS'  }'
p32867
aS'  template <int dim, int spacedim>'
p32868
aS'  void DistributedLagrangeProblem<dim, spacedim>::run()'
p32869
aS'  {'
p32870
aS'    AssertThrow(parameters.initialized, ExcNotInitialized());'
p32871
aS'    deallog.depth_console(parameters.verbosity_level);'
p32872
aS'    setup_grids_and_dofs();'
p32873
aS'    setup_coupling();'
p32874
aS'    assemble_system();'
p32875
aS'    solve();'
p32876
aS'    output_results();'
p32877
aS'  }'
p32878
aS'} // namespace Step60'
p32879
aS'int main(int argc, char **argv)'
p32880
ag9
aS'  try'
p32881
aS'    {'
p32882
aS'      using namespace dealii;'
p32883
aS'      using namespace Step60;'
p32884
aS'      const unsigned int dim = 1, spacedim = 2;'
p32885
aS'      DistributedLagrangeProblem<dim, spacedim>::Parameters parameters;'
p32886
aS'      DistributedLagrangeProblem<dim, spacedim>             problem(parameters);'
p32887
aS'      std::string parameter_file;'
p32888
aS'      if (argc > 1)'
p32889
aS'        parameter_file = argv[1];'
p32890
aS'      else'
p32891
aS'        parameter_file = "parameters.prm";'
p32892
aS'      ParameterAcceptor::initialize(parameter_file, "used_parameters.prm");'
p32893
aS'      problem.run();'
p32894
aS'    }'
p32895
aS'  catch (std::exception &exc)'
p32896
aS'    {'
p32897
aS'      std::cerr << std::endl'
p32898
aS'                << std::endl'
p32899
aS'                << "----------------------------------------------------"'
p32900
aS'                << std::endl;'
p32901
aS'      std::cerr << "Exception on processing: " << std::endl'
p32902
aS'                << exc.what() << std::endl'
p32903
aS'                << "Aborting!" << std::endl'
p32904
aS'                << "----------------------------------------------------"'
p32905
aS'                << std::endl;'
p32906
aS'      return 1;'
p32907
aS'    }'
p32908
aS'  catch (...)'
p32909
aS'    {'
p32910
aS'      std::cerr << std::endl'
p32911
aS'                << std::endl'
p32912
aS'                << "----------------------------------------------------"'
p32913
aS'                << std::endl;'
p32914
aS'      std::cerr << "Unknown exception!" << std::endl'
p32915
aS'                << "Aborting!" << std::endl'
p32916
aS'                << "----------------------------------------------------"'
p32917
aS'                << std::endl;'
p32918
aS'      return 1;'
p32919
aS'    }'
p32920
aS'  return 0;'
p32921
ag17
aS'#include <deal.II/base/quadrature.h>'
p32922
aS'#include <deal.II/base/quadrature_lib.h>'
p32923
aS'#include <deal.II/base/tensor_function.h>'
p32924
aS'#include <deal.II/base/logstream.h>'
p32925
aS'#include <deal.II/base/function.h>'
p32926
aS'#include <deal.II/base/point.h>'
p32927
aS'#include <deal.II/lac/block_vector.h>'
p32928
aS'#include <deal.II/lac/vector.h>'
p32929
aS'#include <deal.II/lac/full_matrix.h>'
p32930
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p32931
aS'#include <deal.II/lac/sparse_matrix.h>'
p32932
aS'#include <deal.II/lac/solver_cg.h>'
p32933
aS'#include <deal.II/lac/precondition.h>'
p32934
aS'#include <deal.II/lac/affine_constraints.h>'
p32935
aS'#include <deal.II/grid/tria.h>'
p32936
aS'#include <deal.II/grid/grid_generator.h>'
p32937
aS'#include <deal.II/dofs/dof_handler.h>'
p32938
aS'#include <deal.II/dofs/dof_tools.h>'
p32939
aS'#include <deal.II/fe/fe_dgq.h>'
p32940
aS'#include <deal.II/fe/fe_raviart_thomas.h>'
p32941
aS'#include <deal.II/fe/fe_dg_vector.h>'
p32942
aS'#include <deal.II/fe/fe_system.h>'
p32943
aS'#include <deal.II/fe/fe_values.h>'
p32944
aS'#include <deal.II/fe/fe_face.h>'
p32945
aS'#include <deal.II/fe/component_mask.h>'
p32946
aS'#include <deal.II/numerics/vector_tools.h>'
p32947
aS'#include <deal.II/numerics/data_out.h>'
p32948
aS'#include <deal.II/numerics/data_out_faces.h>'
p32949
aS'#include <fstream>'
p32950
aS'#include <iostream>'
p32951
aS'namespace Step61'
p32952
ag9
aS'  using namespace dealii;'
p32953
aS'  template <int dim>'
p32954
aS'  class WGDarcyEquation'
p32955
aS'  {'
p32956
aS'  public:'
p32957
aS'    WGDarcyEquation(const unsigned int degree);'
p32958
aS'    void run();'
p32959
aS'  private:'
p32960
aS'    void make_grid();'
p32961
aS'    void setup_system();'
p32962
aS'    void assemble_system();'
p32963
aS'    void solve();'
p32964
aS'    void compute_postprocessed_velocity();'
p32965
aS'    void compute_velocity_errors();'
p32966
aS'    void compute_pressure_error();'
p32967
aS'    void output_results() const;'
p32968
aS'    Triangulation<dim> triangulation;'
p32969
aS'    FESystem<dim>   fe;'
p32970
aS'    DoFHandler<dim> dof_handler;'
p32971
aS'    AffineConstraints<double> constraints;'
p32972
aS'    SparsityPattern      sparsity_pattern;'
p32973
aS'    SparseMatrix<double> system_matrix;'
p32974
aS'    Vector<double> solution;'
p32975
aS'    Vector<double> system_rhs;'
p32976
aS'    FE_DGRaviartThomas<dim> fe_dgrt;'
p32977
aS'    DoFHandler<dim>         dof_handler_dgrt;'
p32978
aS'    Vector<double>          darcy_velocity;'
p32979
aS'  };'
p32980
aS'  template <int dim>'
p32981
aS'  class Coefficient : public TensorFunction<2, dim>'
p32982
aS'  {'
p32983
aS'  public:'
p32984
aS'    Coefficient()'
p32985
aS'      : TensorFunction<2, dim>()'
p32986
aS'    {}'
p32987
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p32988
aS'                            std::vector<Tensor<2, dim>> &values) const override;'
p32989
aS'  };'
p32990
aS'  template <int dim>'
p32991
aS'  void Coefficient<dim>::value_list(const std::vector<Point<dim>> &points,'
p32992
aS'                                    std::vector<Tensor<2, dim>> &  values) const'
p32993
aS'  {'
p32994
aS'    Assert(points.size() == values.size(),'
p32995
aS'           ExcDimensionMismatch(points.size(), values.size()));'
p32996
aS'    for (unsigned int p = 0; p < points.size(); ++p)'
p32997
aS'      values[p] = unit_symmetric_tensor<dim>();'
p32998
aS'  }'
p32999
aS'  template <int dim>'
p33000
aS'  class BoundaryValues : public Function<dim>'
p33001
aS'  {'
p33002
aS'  public:'
p33003
aS'    BoundaryValues()'
p33004
aS'      : Function<dim>(2)'
p33005
aS'    {}'
p33006
aS'    virtual double value(const Point<dim> & p,'
p33007
aS'                         const unsigned int component = 0) const override;'
p33008
aS'  };'
p33009
aS'  template <int dim>'
p33010
aS'  double BoundaryValues<dim>::value(const Point<dim> & /*p*/,'
p33011
aS'                                    const unsigned int /*component*/) const'
p33012
aS'  {'
p33013
aS'    return 0;'
p33014
aS'  }'
p33015
aS'  template <int dim>'
p33016
aS'  class RightHandSide : public Function<dim>'
p33017
aS'  {'
p33018
aS'  public:'
p33019
aS'    virtual double value(const Point<dim> & p,'
p33020
aS'                         const unsigned int component = 0) const override;'
p33021
aS'  };'
p33022
aS'  template <int dim>'
p33023
aS'  double RightHandSide<dim>::value(const Point<dim> &p,'
p33024
aS'                                   const unsigned int /*component*/) const'
p33025
aS'  {'
p33026
aS'    return (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *'
p33027
aS'            std::sin(numbers::PI * p[1]));'
p33028
aS'  }'
p33029
aS'  template <int dim>'
p33030
aS'  class ExactPressure : public Function<dim>'
p33031
aS'  {'
p33032
aS'  public:'
p33033
aS'    ExactPressure()'
p33034
aS'      : Function<dim>(2)'
p33035
aS'    {}'
p33036
aS'    virtual double value(const Point<dim> & p,'
p33037
aS'                         const unsigned int component) const override;'
p33038
aS'  };'
p33039
aS'  template <int dim>'
p33040
aS'  double ExactPressure<dim>::value(const Point<dim> &p,'
p33041
aS'                                   const unsigned int /*component*/) const'
p33042
aS'  {'
p33043
aS'    return std::sin(numbers::PI * p[0]) * std::sin(numbers::PI * p[1]);'
p33044
aS'  }'
p33045
aS'  template <int dim>'
p33046
aS'  class ExactVelocity : public TensorFunction<1, dim>'
p33047
aS'  {'
p33048
aS'  public:'
p33049
aS'    ExactVelocity()'
p33050
aS'      : TensorFunction<1, dim>()'
p33051
aS'    {}'
p33052
aS'    virtual Tensor<1, dim> value(const Point<dim> &p) const override;'
p33053
aS'  };'
p33054
aS'  template <int dim>'
p33055
aS'  Tensor<1, dim> ExactVelocity<dim>::value(const Point<dim> &p) const'
p33056
aS'  {'
p33057
aS'    Tensor<1, dim> return_value;'
p33058
aS'    return_value[0] = -numbers::PI * std::cos(numbers::PI * p[0]) *'
p33059
aS'                      std::sin(numbers::PI * p[1]);'
p33060
aS'    return_value[1] = -numbers::PI * std::sin(numbers::PI * p[0]) *'
p33061
aS'                      std::cos(numbers::PI * p[1]);'
p33062
aS'    return return_value;'
p33063
aS'  }'
p33064
aS'  template <int dim>'
p33065
aS'  WGDarcyEquation<dim>::WGDarcyEquation(const unsigned int degree)'
p33066
aS'    : fe(FE_DGQ<dim>(degree), 1, FE_FaceQ<dim>(degree), 1)'
p33067
aS'    , dof_handler(triangulation)'
p33068
aS'    , fe_dgrt(degree)'
p33069
aS'    , dof_handler_dgrt(triangulation)'
p33070
aS'  {}'
p33071
aS'  template <int dim>'
p33072
aS'  void WGDarcyEquation<dim>::make_grid()'
p33073
aS'  {'
p33074
aS'    GridGenerator::hyper_cube(triangulation, 0, 1);'
p33075
aS'    triangulation.refine_global(5);'
p33076
aS'    std::cout << "   Number of active cells: " << triangulation.n_active_cells()'
p33077
aS'              << std::endl'
p33078
aS'              << "   Total number of cells: " << triangulation.n_cells()'
p33079
aS'              << std::endl;'
p33080
aS'  }'
p33081
aS'  template <int dim>'
p33082
aS'  void WGDarcyEquation<dim>::setup_system()'
p33083
aS'  {'
p33084
aS'    dof_handler.distribute_dofs(fe);'
p33085
aS'    dof_handler_dgrt.distribute_dofs(fe_dgrt);'
p33086
aS'    std::cout << "   Number of pressure degrees of freedom: "'
p33087
aS'              << dof_handler.n_dofs() << std::endl;'
p33088
aS'    solution.reinit(dof_handler.n_dofs());'
p33089
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p33090
aS'    {'
p33091
aS'      constraints.clear();'
p33092
aS'      const FEValuesExtractors::Scalar interface_pressure(1);'
p33093
aS'      const ComponentMask              interface_pressure_mask ='
p33094
aS'        fe.component_mask(interface_pressure);'
p33095
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p33096
aS'                                               0,'
p33097
aS'                                               BoundaryValues<dim>(),'
p33098
aS'                                               constraints,'
p33099
aS'                                               interface_pressure_mask);'
p33100
aS'      constraints.close();'
p33101
aS'    }'
p33102
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p33103
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints);'
p33104
aS'    sparsity_pattern.copy_from(dsp);'
p33105
aS'    system_matrix.reinit(sparsity_pattern);'
p33106
aS'  }'
p33107
aS'  template <int dim>'
p33108
aS'  void WGDarcyEquation<dim>::assemble_system()'
p33109
aS'  {'
p33110
aS'    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1);'
p33111
aS'    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1);'
p33112
aS'    FEValues<dim>     fe_values(fe,'
p33113
aS'                            quadrature_formula,'
p33114
aS'                            update_values | update_quadrature_points |'
p33115
aS'                              update_JxW_values);'
p33116
aS'    FEFaceValues<dim> fe_face_values(fe,'
p33117
aS'                                     face_quadrature_formula,'
p33118
aS'                                     update_values | update_normal_vectors |'
p33119
aS'                                       update_quadrature_points |'
p33120
aS'                                       update_JxW_values);'
p33121
aS'    FEValues<dim>     fe_values_dgrt(fe_dgrt,'
p33122
aS'                                 quadrature_formula,'
p33123
aS'                                 update_values | update_gradients |'
p33124
aS'                                   update_quadrature_points |'
p33125
aS'                                   update_JxW_values);'
p33126
aS'    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt,'
p33127
aS'                                          face_quadrature_formula,'
p33128
aS'                                          update_values |'
p33129
aS'                                            update_normal_vectors |'
p33130
aS'                                            update_quadrature_points |'
p33131
aS'                                            update_JxW_values);'
p33132
aS'    const unsigned int dofs_per_cell      = fe.n_dofs_per_cell();'
p33133
aS'    const unsigned int dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();'
p33134
aS'    const unsigned int n_q_points      = fe_values.get_quadrature().size();'
p33135
aS'    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();'
p33136
aS'    const unsigned int n_face_q_points = fe_face_values.get_quadrature().size();'
p33137
aS'    RightHandSide<dim>  right_hand_side;'
p33138
aS'    std::vector<double> right_hand_side_values(n_q_points);'
p33139
aS'    const Coefficient<dim>      coefficient;'
p33140
aS'    std::vector<Tensor<2, dim>> coefficient_values(n_q_points);'
p33141
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p33142
aS'    FullMatrix<double> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p33143
aS'    FullMatrix<double> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);'
p33144
aS'    FullMatrix<double> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);'
p33145
aS'    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);'
p33146
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p33147
aS'    Vector<double>     cell_solution(dofs_per_cell);'
p33148
aS'    const FEValuesExtractors::Vector velocities(0);'
p33149
aS'    const FEValuesExtractors::Scalar pressure_interior(0);'
p33150
aS'    const FEValuesExtractors::Scalar pressure_face(1);'
p33151
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p33152
aS'      {'
p33153
aS'        fe_values.reinit(cell);'
p33154
aS'        const typename Triangulation<dim>::active_cell_iterator cell_dgrt ='
p33155
aS'          cell;'
p33156
aS'        fe_values_dgrt.reinit(cell_dgrt);'
p33157
aS'        right_hand_side.value_list(fe_values.get_quadrature_points(),'
p33158
aS'                                   right_hand_side_values);'
p33159
aS'        coefficient.value_list(fe_values.get_quadrature_points(),'
p33160
aS'                               coefficient_values);'
p33161
aS'        cell_matrix_M = 0;'
p33162
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p33163
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p33164
aS'            {'
p33165
aS'              const Tensor<1, dim> v_i = fe_values_dgrt[velocities].value(i, q);'
p33166
aS'              for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p33167
aS'                {'
p33168
aS'                  const Tensor<1, dim> v_k ='
p33169
aS'                    fe_values_dgrt[velocities].value(k, q);'
p33170
aS'                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));'
p33171
aS'                }'
p33172
aS'            }'
p33173
aS'        cell_matrix_M.gauss_jordan();'
p33174
aS'        cell_matrix_G = 0;'
p33175
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p33176
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p33177
aS'            {'
p33178
aS'              const double div_v_i ='
p33179
aS'                fe_values_dgrt[velocities].divergence(i, q);'
p33180
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p33181
aS'                {'
p33182
aS'                  const double phi_j_interior ='
p33183
aS'                    fe_values[pressure_interior].value(j, q);'
p33184
aS'                  cell_matrix_G(i, j) -='
p33185
aS'                }'
p33186
aS'            }'
p33187
aS'        for (const auto &face : cell->face_iterators())'
p33188
aS'          {'
p33189
aS'            fe_face_values.reinit(cell, face);'
p33190
aS'            fe_face_values_dgrt.reinit(cell_dgrt, face);'
p33191
aS'            for (unsigned int q = 0; q < n_face_q_points; ++q)'
p33192
aS'              {'
p33193
aS'                const Tensor<1, dim> &normal = fe_face_values.normal_vector(q);'
p33194
aS'                for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p33195
aS'                  {'
p33196
aS'                    const Tensor<1, dim> v_i ='
p33197
aS'                      fe_face_values_dgrt[velocities].value(i, q);'
p33198
aS'                    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p33199
aS'                      {'
p33200
aS'                        const double phi_j_face ='
p33201
aS'                          fe_face_values[pressure_face].value(j, q);'
p33202
aS'                        cell_matrix_G(i, j) +='
p33203
aS'                      }'
p33204
aS'                  }'
p33205
aS'              }'
p33206
aS'          }'
p33207
aS'        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);'
p33208
aS'        local_matrix = 0;'
p33209
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p33210
aS'          {'
p33211
aS'            for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p33212
aS'              {'
p33213
aS'                const Tensor<1, dim> v_k ='
p33214
aS'                  fe_values_dgrt[velocities].value(k, q);'
p33215
aS'                for (unsigned int l = 0; l < dofs_per_cell_dgrt; ++l)'
p33216
aS'                  {'
p33217
aS'                    const Tensor<1, dim> v_l ='
p33218
aS'                      fe_values_dgrt[velocities].value(l, q);'
p33219
aS'                    for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p33220
aS'                      for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p33221
aS'                        local_matrix(i, j) +='
p33222
aS'                          cell_matrix_C[j][l] * v_l * fe_values_dgrt.JxW(q);'
p33223
aS'                  }'
p33224
aS'              }'
p33225
aS'          }'
p33226
aS'        cell_rhs = 0;'
p33227
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p33228
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p33229
aS'            {'
p33230
aS'              cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *'
p33231
aS'                              right_hand_side_values[q] * fe_values.JxW(q));'
p33232
aS'            }'
p33233
aS'        cell->get_dof_indices(local_dof_indices);'
p33234
aS'        constraints.distribute_local_to_global('
p33235
aS'          local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p33236
aS'      }'
p33237
aS'  }'
p33238
aS'  template <int dim>'
p33239
aS'  void WGDarcyEquation<dim>::solve()'
p33240
aS'  {'
p33241
aS'    SolverControl            solver_control(1000, 1e-8 * system_rhs.l2_norm());'
p33242
aS'    SolverCG<Vector<double>> solver(solver_control);'
p33243
aS'    solver.solve(system_matrix, solution, system_rhs, PreconditionIdentity());'
p33244
aS'    constraints.distribute(solution);'
p33245
aS'  }'
p33246
aS'  template <int dim>'
p33247
aS'  void WGDarcyEquation<dim>::compute_postprocessed_velocity()'
p33248
aS'  {'
p33249
aS'    darcy_velocity.reinit(dof_handler_dgrt.n_dofs());'
p33250
aS'    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1);'
p33251
aS'    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1);'
p33252
aS'    FEValues<dim> fe_values(fe,'
p33253
aS'                            quadrature_formula,'
p33254
aS'                            update_values | update_quadrature_points |'
p33255
aS'                              update_JxW_values);'
p33256
aS'    FEFaceValues<dim> fe_face_values(fe,'
p33257
aS'                                     face_quadrature_formula,'
p33258
aS'                                     update_values | update_normal_vectors |'
p33259
aS'                                       update_quadrature_points |'
p33260
aS'                                       update_JxW_values);'
p33261
aS'    FEValues<dim> fe_values_dgrt(fe_dgrt,'
p33262
aS'                                 quadrature_formula,'
p33263
aS'                                 update_values | update_gradients |'
p33264
aS'                                   update_quadrature_points |'
p33265
aS'                                   update_JxW_values);'
p33266
aS'    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt,'
p33267
aS'                                          face_quadrature_formula,'
p33268
aS'                                          update_values |'
p33269
aS'                                            update_normal_vectors |'
p33270
aS'                                            update_quadrature_points |'
p33271
aS'                                            update_JxW_values);'
p33272
aS'    const unsigned int dofs_per_cell      = fe.n_dofs_per_cell();'
p33273
aS'    const unsigned int dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();'
p33274
aS'    const unsigned int n_q_points      = fe_values.get_quadrature().size();'
p33275
aS'    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();'
p33276
aS'    const unsigned int n_face_q_points = fe_face_values.get_quadrature().size();'
p33277
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p33278
aS'    std::vector<types::global_dof_index> local_dof_indices_dgrt('
p33279
aS'      dofs_per_cell_dgrt);'
p33280
aS'    FullMatrix<double> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p33281
aS'    FullMatrix<double> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);'
p33282
aS'    FullMatrix<double> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);'
p33283
aS'    FullMatrix<double> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p33284
aS'    FullMatrix<double> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);'
p33285
aS'    Vector<double> cell_solution(dofs_per_cell);'
p33286
aS'    Vector<double> cell_velocity(dofs_per_cell_dgrt);'
p33287
aS'    const Coefficient<dim>      coefficient;'
p33288
aS'    std::vector<Tensor<2, dim>> coefficient_values(n_q_points_dgrt);'
p33289
aS'    const FEValuesExtractors::Vector velocities(0);'
p33290
aS'    const FEValuesExtractors::Scalar pressure_interior(0);'
p33291
aS'    const FEValuesExtractors::Scalar pressure_face(1);'
p33292
aS'    typename DoFHandler<dim>::active_cell_iterator'
p33293
aS'      cell = dof_handler.begin_active(),'
p33294
aS'      endc = dof_handler.end(), cell_dgrt = dof_handler_dgrt.begin_active();'
p33295
aS'    for (; cell != endc; ++cell, ++cell_dgrt)'
p33296
aS'      {'
p33297
aS'        fe_values.reinit(cell);'
p33298
aS'        fe_values_dgrt.reinit(cell_dgrt);'
p33299
aS'        coefficient.value_list(fe_values_dgrt.get_quadrature_points(),'
p33300
aS'                               coefficient_values);'
p33301
aS'        cell_matrix_M = 0;'
p33302
aS'        cell_matrix_E = 0;'
p33303
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p33304
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p33305
aS'            {'
p33306
aS'              const Tensor<1, dim> v_i = fe_values_dgrt[velocities].value(i, q);'
p33307
aS'              for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p33308
aS'                {'
p33309
aS'                  const Tensor<1, dim> v_k ='
p33310
aS'                    fe_values_dgrt[velocities].value(k, q);'
p33311
aS'                  cell_matrix_E(i, k) +='
p33312
aS'                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));'
p33313
aS'                }'
p33314
aS'            }'
p33315
aS'        cell_matrix_M.gauss_jordan();'
p33316
aS'        cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);'
p33317
aS'        cell_matrix_G = 0;'
p33318
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p33319
aS'          for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p33320
aS'            {'
p33321
aS'              const double div_v_i ='
p33322
aS'                fe_values_dgrt[velocities].divergence(i, q);'
p33323
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p33324
aS'                {'
p33325
aS'                  const double phi_j_interior ='
p33326
aS'                    fe_values[pressure_interior].value(j, q);'
p33327
aS'                  cell_matrix_G(i, j) -='
p33328
aS'                }'
p33329
aS'            }'
p33330
aS'        for (const auto &face : cell->face_iterators())'
p33331
aS'          {'
p33332
aS'            fe_face_values.reinit(cell, face);'
p33333
aS'            fe_face_values_dgrt.reinit(cell_dgrt, face);'
p33334
aS'            for (unsigned int q = 0; q < n_face_q_points; ++q)'
p33335
aS'              {'
p33336
aS'                const Tensor<1, dim> &normal = fe_face_values.normal_vector(q);'
p33337
aS'                for (unsigned int i = 0; i < dofs_per_cell_dgrt; ++i)'
p33338
aS'                  {'
p33339
aS'                    const Tensor<1, dim> v_i ='
p33340
aS'                      fe_face_values_dgrt[velocities].value(i, q);'
p33341
aS'                    for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p33342
aS'                      {'
p33343
aS'                        const double phi_j_face ='
p33344
aS'                          fe_face_values[pressure_face].value(j, q);'
p33345
aS'                        cell_matrix_G(i, j) +='
p33346
aS'                      }'
p33347
aS'                  }'
p33348
aS'              }'
p33349
aS'          }'
p33350
aS'        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);'
p33351
aS'        cell->get_dof_values(solution, cell_solution);'
p33352
aS'        cell_velocity = 0;'
p33353
aS'        for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p33354
aS'          for (unsigned int j = 0; j < dofs_per_cell_dgrt; ++j)'
p33355
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p33356
aS'              cell_velocity(k) +='
p33357
aS'                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));'
p33358
aS'        cell_dgrt->get_dof_indices(local_dof_indices_dgrt);'
p33359
aS'        for (unsigned int k = 0; k < dofs_per_cell_dgrt; ++k)'
p33360
aS'          for (unsigned int j = 0; j < dofs_per_cell_dgrt; ++j)'
p33361
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p33362
aS'              darcy_velocity(local_dof_indices_dgrt[k]) +='
p33363
aS'                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));'
p33364
aS'      }'
p33365
aS'  }'
p33366
aS'  template <int dim>'
p33367
aS'  void WGDarcyEquation<dim>::compute_pressure_error()'
p33368
aS'  {'
p33369
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p33370
aS'    const ComponentSelectFunction<dim> select_interior_pressure(0, 2);'
p33371
aS'    VectorTools::integrate_difference(dof_handler,'
p33372
aS'                                      solution,'
p33373
aS'                                      ExactPressure<dim>(),'
p33374
aS'                                      difference_per_cell,'
p33375
aS'                                      QGauss<dim>(fe.degree + 2),'
p33376
aS'                                      VectorTools::L2_norm,'
p33377
aS'                                      &select_interior_pressure);'
p33378
aS'    const double L2_error = difference_per_cell.l2_norm();'
p33379
aS'    std::cout << "L2_error_pressure " << L2_error << std::endl;'
p33380
aS'  }'
p33381
aS'  template <int dim>'
p33382
aS'  void WGDarcyEquation<dim>::compute_velocity_errors()'
p33383
aS'  {'
p33384
aS'    const QGauss<dim>     quadrature_formula(fe_dgrt.degree + 1);'
p33385
aS'    const QGauss<dim - 1> face_quadrature_formula(fe_dgrt.degree + 1);'
p33386
aS'    FEValues<dim> fe_values_dgrt(fe_dgrt,'
p33387
aS'                                 quadrature_formula,'
p33388
aS'                                 update_values | update_gradients |'
p33389
aS'                                   update_quadrature_points |'
p33390
aS'                                   update_JxW_values);'
p33391
aS'    FEFaceValues<dim> fe_face_values_dgrt(fe_dgrt,'
p33392
aS'                                          face_quadrature_formula,'
p33393
aS'                                          update_values |'
p33394
aS'                                            update_normal_vectors |'
p33395
aS'                                            update_quadrature_points |'
p33396
aS'                                            update_JxW_values);'
p33397
aS'    const unsigned int n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();'
p33398
aS'    const unsigned int n_face_q_points_dgrt ='
p33399
aS'      fe_face_values_dgrt.get_quadrature().size();'
p33400
aS'    std::vector<Tensor<1, dim>> velocity_values(n_q_points_dgrt);'
p33401
aS'    std::vector<Tensor<1, dim>> velocity_face_values(n_face_q_points_dgrt);'
p33402
aS'    const FEValuesExtractors::Vector velocities(0);'
p33403
aS'    const ExactVelocity<dim> exact_velocity;'
p33404
aS'    double L2_err_velocity_cell_sqr_global = 0;'
p33405
aS'    double L2_err_flux_sqr                 = 0;'
p33406
aS'    for (const auto &cell_dgrt : dof_handler_dgrt.active_cell_iterators())'
p33407
aS'      {'
p33408
aS'        fe_values_dgrt.reinit(cell_dgrt);'
p33409
aS'        fe_values_dgrt[velocities].get_function_values(darcy_velocity,'
p33410
aS'                                                       velocity_values);'
p33411
aS'        double L2_err_velocity_cell_sqr_local = 0;'
p33412
aS'        for (unsigned int q = 0; q < n_q_points_dgrt; ++q)'
p33413
aS'          {'
p33414
aS'            const Tensor<1, dim> velocity = velocity_values[q];'
p33415
aS'            const Tensor<1, dim> true_velocity ='
p33416
aS'              exact_velocity.value(fe_values_dgrt.quadrature_point(q));'
p33417
aS'            L2_err_velocity_cell_sqr_local +='
p33418
aS'               fe_values_dgrt.JxW(q));'
p33419
aS'          }'
p33420
aS'        L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;'
p33421
aS'        const double cell_area = cell_dgrt->measure();'
p33422
aS'        for (const auto &face_dgrt : cell_dgrt->face_iterators())'
p33423
aS'          {'
p33424
aS'            const double face_length = face_dgrt->measure();'
p33425
aS'            fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);'
p33426
aS'            fe_face_values_dgrt[velocities].get_function_values('
p33427
aS'              darcy_velocity, velocity_face_values);'
p33428
aS'            double L2_err_flux_face_sqr_local = 0;'
p33429
aS'            for (unsigned int q = 0; q < n_face_q_points_dgrt; ++q)'
p33430
aS'              {'
p33431
aS'                const Tensor<1, dim> velocity = velocity_face_values[q];'
p33432
aS'                const Tensor<1, dim> true_velocity ='
p33433
aS'                  exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));'
p33434
aS'                const Tensor<1, dim> &normal ='
p33435
aS'                  fe_face_values_dgrt.normal_vector(q);'
p33436
aS'                L2_err_flux_face_sqr_local +='
p33437
aS'                   fe_face_values_dgrt.JxW(q));'
p33438
aS'              }'
p33439
aS'            const double err_flux_each_face ='
p33440
aS'              L2_err_flux_face_sqr_local / face_length * cell_area;'
p33441
aS'            L2_err_flux_sqr += err_flux_each_face;'
p33442
aS'          }'
p33443
aS'      }'
p33444
aS'    const double L2_err_velocity_cell ='
p33445
aS'      std::sqrt(L2_err_velocity_cell_sqr_global);'
p33446
aS'    const double L2_err_flux_face = std::sqrt(L2_err_flux_sqr);'
p33447
aS'    std::cout << "L2_error_vel:  " << L2_err_velocity_cell << std::endl'
p33448
aS'              << "L2_error_flux: " << L2_err_flux_face << std::endl;'
p33449
aS'  }'
p33450
aS'  template <int dim>'
p33451
aS'  void WGDarcyEquation<dim>::output_results() const'
p33452
aS'  {'
p33453
aS'    {'
p33454
aS'      DataOut<dim> data_out;'
p33455
aS'      const std::vector<std::string> solution_names = {"interior_pressure",'
p33456
aS'                                                       "interface_pressure"};'
p33457
aS'      data_out.add_data_vector(dof_handler, solution, solution_names);'
p33458
aS'      const std::vector<std::string> velocity_names(dim, "velocity");'
p33459
aS'      const std::vector<'
p33460
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p33461
aS'        velocity_component_interpretation('
p33462
aS'          dim, DataComponentInterpretation::component_is_part_of_vector);'
p33463
aS'      data_out.add_data_vector(dof_handler_dgrt,'
p33464
aS'                               darcy_velocity,'
p33465
aS'                               velocity_names,'
p33466
aS'                               velocity_component_interpretation);'
p33467
aS'      data_out.build_patches(fe.degree);'
p33468
aS'      std::ofstream output("solution_interior.vtu");'
p33469
aS'      data_out.write_vtu(output);'
p33470
aS'    }'
p33471
aS'    {'
p33472
aS'      DataOutFaces<dim> data_out_faces(false);'
p33473
aS'      data_out_faces.attach_dof_handler(dof_handler);'
p33474
aS'      data_out_faces.add_data_vector(solution, "Pressure_Face");'
p33475
aS'      data_out_faces.build_patches(fe.degree);'
p33476
aS'      std::ofstream face_output("solution_interface.vtu");'
p33477
aS'      data_out_faces.write_vtu(face_output);'
p33478
aS'    }'
p33479
aS'  }'
p33480
aS'  template <int dim>'
p33481
aS'  void WGDarcyEquation<dim>::run()'
p33482
aS'  {'
p33483
aS'    std::cout << "Solving problem in " << dim << " space dimensions."'
p33484
aS'              << std::endl;'
p33485
aS'    make_grid();'
p33486
aS'    setup_system();'
p33487
aS'    assemble_system();'
p33488
aS'    solve();'
p33489
aS'    compute_postprocessed_velocity();'
p33490
aS'    compute_pressure_error();'
p33491
aS'    compute_velocity_errors();'
p33492
aS'    output_results();'
p33493
aS'  }'
p33494
aS'} // namespace Step61'
p33495
aS'int main()'
p33496
ag9
aS'  try'
p33497
aS'    {'
p33498
aS'      Step61::WGDarcyEquation<2> wg_darcy(0);'
p33499
aS'      wg_darcy.run();'
p33500
aS'    }'
p33501
aS'  catch (std::exception &exc)'
p33502
aS'    {'
p33503
aS'      std::cerr << std::endl'
p33504
aS'                << std::endl'
p33505
aS'                << "----------------------------------------------------"'
p33506
aS'                << std::endl;'
p33507
aS'      std::cerr << "Exception on processing: " << std::endl'
p33508
aS'                << exc.what() << std::endl'
p33509
aS'                << "Aborting!" << std::endl'
p33510
aS'                << "----------------------------------------------------"'
p33511
aS'                << std::endl;'
p33512
aS'      return 1;'
p33513
aS'    }'
p33514
aS'  catch (...)'
p33515
aS'    {'
p33516
aS'      std::cerr << std::endl'
p33517
aS'                << std::endl'
p33518
aS'                << "----------------------------------------------------"'
p33519
aS'                << std::endl;'
p33520
aS'      std::cerr << "Unknown exception!" << std::endl'
p33521
aS'                << "Aborting!" << std::endl'
p33522
aS'                << "----------------------------------------------------"'
p33523
aS'                << std::endl;'
p33524
aS'      return 1;'
p33525
aS'    }'
p33526
aS'  return 0;'
p33527
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p33528
aS'#include <deal.II/base/function.h>'
p33529
aS'#include <deal.II/base/index_set.h>'
p33530
aS'#include <deal.II/base/quadrature_lib.h>'
p33531
aS'#include <deal.II/base/timer.h>'
p33532
aS'#include <deal.II/base/utilities.h>'
p33533
aS'#include <deal.II/dofs/dof_handler.h>'
p33534
aS'#include <deal.II/dofs/dof_tools.h>'
p33535
aS'#include <deal.II/fe/fe_q.h>'
p33536
aS'#include <deal.II/fe/fe_system.h>'
p33537
aS'#include <deal.II/fe/fe_values.h>'
p33538
aS'#include <deal.II/grid/grid_generator.h>'
p33539
aS'#include <deal.II/grid/grid_refinement.h>'
p33540
aS'#include <deal.II/lac/affine_constraints.h>'
p33541
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p33542
aS'#include <deal.II/lac/full_matrix.h>'
p33543
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p33544
aS'#include <deal.II/lac/petsc_solver.h>'
p33545
aS'#include <deal.II/lac/vector.h>'
p33546
aS'#include <deal.II/numerics/data_out.h>'
p33547
aS'#include <deal.II/numerics/error_estimator.h>'
p33548
aS'#include <fstream>'
p33549
aS'#include <iostream>'
p33550
aS'#include <deal.II/base/tensor.h>'
p33551
aS'#include <deal.II/base/hdf5.h>'
p33552
aS'#include <deal.II/numerics/vector_tools.h>'
p33553
aS'#include <deal.II/grid/grid_tools.h>'
p33554
aS'#include <deal.II/grid/grid_tools_cache.h>'
p33555
aS'namespace step62'
p33556
ag9
aS'  using namespace dealii;'
p33557
aS'  template <int dim>'
p33558
aS'  class RightHandSide : public Function<dim>'
p33559
aS'  {'
p33560
aS'  public:'
p33561
aS'    RightHandSide(HDF5::Group &data);'
p33562
aS'    virtual double value(const Point<dim> & p,'
p33563
aS'                         const unsigned int component) const override;'
p33564
aS'  private:'
p33565
aS'    HDF5::Group data;'
p33566
aS'    const double     max_force_amplitude;'
p33567
aS'    const double     force_sigma_x;'
p33568
aS'    const double     force_sigma_y;'
p33569
aS'    const double     max_force_width_x;'
p33570
aS'    const double     max_force_width_y;'
p33571
aS'    const Point<dim> force_center;'
p33572
aS'  public:'
p33573
aS'    const unsigned int force_component = 0;'
p33574
aS'  };'
p33575
aS'  template <int dim>'
p33576
aS'  class PML : public Function<dim, std::complex<double>>'
p33577
aS'  {'
p33578
aS'  public:'
p33579
aS'    PML(HDF5::Group &data);'
p33580
aS'    virtual std::complex<double>'
p33581
aS'    value(const Point<dim> &p, const unsigned int component) const override;'
p33582
aS'  private:'
p33583
aS'    HDF5::Group data;'
p33584
aS'    const double pml_coeff;'
p33585
aS'    const int    pml_coeff_degree;'
p33586
aS'    const double dimension_x;'
p33587
aS'    const double dimension_y;'
p33588
aS'    const bool   pml_x;'
p33589
aS'    const bool   pml_y;'
p33590
aS'    const double pml_width_x;'
p33591
aS'    const double pml_width_y;'
p33592
aS'    const double a_coeff_x;'
p33593
aS'    const double a_coeff_y;'
p33594
aS'  };'
p33595
aS'  template <int dim>'
p33596
aS'  class Rho : public Function<dim>'
p33597
aS'  {'
p33598
aS'  public:'
p33599
aS'    Rho(HDF5::Group &data);'
p33600
aS'    virtual double value(const Point<dim> & p,'
p33601
aS'                         const unsigned int component = 0) const override;'
p33602
aS'  private:'
p33603
aS'    HDF5::Group data;'
p33604
aS'    const double       lambda;'
p33605
aS'    const double       mu;'
p33606
aS'    const double       material_a_rho;'
p33607
aS'    const double       material_b_rho;'
p33608
aS'    const double       cavity_resonance_frequency;'
p33609
aS'    const unsigned int nb_mirror_pairs;'
p33610
aS'    const double       dimension_y;'
p33611
aS'    const unsigned int grid_level;'
p33612
aS'    double             average_rho_width;'
p33613
aS'  };'
p33614
aS'  template <int dim>'
p33615
aS'  class Parameters'
p33616
aS'  {'
p33617
aS'  public:'
p33618
aS'    Parameters(HDF5::Group &data);'
p33619
aS'    HDF5::Group data;'
p33620
aS'    const std::string        simulation_name;'
p33621
aS'    const bool               save_vtu_files;'
p33622
aS'    const double             start_frequency;'
p33623
aS'    const double             stop_frequency;'
p33624
aS'    const unsigned int       nb_frequency_points;'
p33625
aS'    const double             lambda;'
p33626
aS'    const double             mu;'
p33627
aS'    const double             dimension_x;'
p33628
aS'    const double             dimension_y;'
p33629
aS'    const unsigned int       nb_probe_points;'
p33630
aS'    const unsigned int       grid_level;'
p33631
aS'    const Point<dim>         probe_start_point;'
p33632
aS'    const Point<dim>         probe_stop_point;'
p33633
aS'    const RightHandSide<dim> right_hand_side;'
p33634
aS'    const PML<dim>           pml;'
p33635
aS'    const Rho<dim>           rho;'
p33636
aS'  private:'
p33637
aS'    const double comparison_float_constant = 1e-12;'
p33638
aS'  };'
p33639
aS'  template <int dim>'
p33640
aS'  class QuadratureCache'
p33641
aS'  {'
p33642
aS'  public:'
p33643
aS'    QuadratureCache(const unsigned int dofs_per_cell);'
p33644
aS'  private:'
p33645
aS'    unsigned int dofs_per_cell;'
p33646
aS'  public:'
p33647
aS'    FullMatrix<std::complex<double>>  mass_coefficient;'
p33648
aS'    FullMatrix<std::complex<double>>  stiffness_coefficient;'
p33649
aS'    std::vector<std::complex<double>> right_hand_side;'
p33650
aS'    double                            JxW;'
p33651
aS'  };'
p33652
aS'  template <int dim>'
p33653
aS'  SymmetricTensor<4, dim> get_stiffness_tensor(const double lambda,'
p33654
aS'                                               const double mu)'
p33655
aS'  {'
p33656
aS'    SymmetricTensor<4, dim> stiffness_tensor;'
p33657
aS'    for (unsigned int i = 0; i < dim; ++i)'
p33658
aS'      for (unsigned int j = 0; j < dim; ++j)'
p33659
aS'        for (unsigned int k = 0; k < dim; ++k)'
p33660
aS'          for (unsigned int l = 0; l < dim; ++l)'
p33661
aS'            stiffness_tensor[i][j][k][l] ='
p33662
aS'    return stiffness_tensor;'
p33663
aS'  }'
p33664
aS'  template <int dim>'
p33665
aS'  class ElasticWave'
p33666
aS'  {'
p33667
aS'  public:'
p33668
aS'    ElasticWave(const Parameters<dim> &parameters);'
p33669
aS'    void run();'
p33670
aS'  private:'
p33671
aS'    void setup_system();'
p33672
aS'    void assemble_system(const double omega,'
p33673
aS'                         const bool   calculate_quadrature_data);'
p33674
aS'    void solve();'
p33675
aS'    void initialize_probe_positions_vector();'
p33676
aS'    void store_frequency_step_data(const unsigned int frequency_idx);'
p33677
aS'    void output_results();'
p33678
aS'    void setup_quadrature_cache();'
p33679
aS'    void frequency_sweep();'
p33680
aS'    Parameters<dim> parameters;'
p33681
aS'    MPI_Comm mpi_communicator;'
p33682
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p33683
aS'    QGauss<dim> quadrature_formula;'
p33684
aS'    std::vector<QuadratureCache<dim>> quadrature_cache;'
p33685
aS'    FESystem<dim>   fe;'
p33686
aS'    DoFHandler<dim> dof_handler;'
p33687
aS'    IndexSet locally_owned_dofs;'
p33688
aS'    IndexSet locally_relevant_dofs;'
p33689
aS'    AffineConstraints<std::complex<double>> constraints;'
p33690
aS'    LinearAlgebraPETSc::MPI::SparseMatrix system_matrix;'
p33691
aS'    LinearAlgebraPETSc::MPI::Vector       locally_relevant_solution;'
p33692
aS'    LinearAlgebraPETSc::MPI::Vector       system_rhs;'
p33693
aS'    std::vector<double> frequency;'
p33694
aS'    FullMatrix<double> probe_positions;'
p33695
aS'    HDF5::DataSet frequency_dataset;'
p33696
aS'    HDF5::DataSet probe_positions_dataset;'
p33697
aS'    HDF5::DataSet displacement;'
p33698
aS'    ConditionalOStream pcout;'
p33699
aS'    TimerOutput        computing_timer;'
p33700
aS'  };'
p33701
aS'  template <int dim>'
p33702
aS'  RightHandSide<dim>::RightHandSide(HDF5::Group &data)'
p33703
aS'    : Function<dim>(dim)'
p33704
aS'    , data(data)'
p33705
aS'    , max_force_amplitude(data.get_attribute<double>("max_force_amplitude"))'
p33706
aS'    , force_sigma_x(data.get_attribute<double>("force_sigma_x"))'
p33707
aS'    , force_sigma_y(data.get_attribute<double>("force_sigma_y"))'
p33708
aS'    , max_force_width_x(data.get_attribute<double>("max_force_width_x"))'
p33709
aS'    , max_force_width_y(data.get_attribute<double>("max_force_width_y"))'
p33710
aS'    , force_center(Point<dim>(data.get_attribute<double>("force_x_pos"),'
p33711
aS'                              data.get_attribute<double>("force_y_pos")))'
p33712
aS'  {}'
p33713
aS'  template <int dim>'
p33714
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p33715
aS'                                   const unsigned int component) const'
p33716
aS'  {'
p33717
aS'    if (component == force_component)'
p33718
aS'      {'
p33719
aS'        if (std::abs(p[0] - force_center[0]) < max_force_width_x / 2 &&'
p33720
aS'            std::abs(p[1] - force_center[1]) < max_force_width_y / 2)'
p33721
aS'          {'
p33722
aS'            return max_force_amplitude *'
p33723
aS'                   std::exp(-(std::pow(p[0] - force_center[0], 2) /'
p33724
aS'                              std::pow(p[1] - force_center[1], 2) /'
p33725
aS'          }'
p33726
aS'        else'
p33727
aS'          {'
p33728
aS'            return 0;'
p33729
aS'          }'
p33730
aS'      }'
p33731
aS'    else'
p33732
aS'      {'
p33733
aS'        return 0;'
p33734
aS'      }'
p33735
aS'  }'
p33736
aS'  template <int dim>'
p33737
aS'  PML<dim>::PML(HDF5::Group &data)'
p33738
aS'    : Function<dim, std::complex<double>>(dim)'
p33739
aS'    , data(data)'
p33740
aS'    , pml_coeff(data.get_attribute<double>("pml_coeff"))'
p33741
aS'    , pml_coeff_degree(data.get_attribute<int>("pml_coeff_degree"))'
p33742
aS'    , dimension_x(data.get_attribute<double>("dimension_x"))'
p33743
aS'    , dimension_y(data.get_attribute<double>("dimension_y"))'
p33744
aS'    , pml_x(data.get_attribute<bool>("pml_x"))'
p33745
aS'    , pml_y(data.get_attribute<bool>("pml_y"))'
p33746
aS'    , pml_width_x(data.get_attribute<double>("pml_width_x"))'
p33747
aS'    , pml_width_y(data.get_attribute<double>("pml_width_y"))'
p33748
aS'    , a_coeff_x(pml_coeff / std::pow(pml_width_x, pml_coeff_degree))'
p33749
aS'    , a_coeff_y(pml_coeff / std::pow(pml_width_y, pml_coeff_degree))'
p33750
aS'  {}'
p33751
aS'  template <int dim>'
p33752
aS'  std::complex<double> PML<dim>::value(const Point<dim> & p,'
p33753
aS'                                       const unsigned int component) const'
p33754
aS'  {'
p33755
aS'    double calculated_pml_x_coeff = 0;'
p33756
aS'    double calculated_pml_y_coeff = 0;'
p33757
aS'    if ((component == 0) && pml_x)'
p33758
aS'      {'
p33759
aS'        const double pml_x_start_position = dimension_x / 2 - pml_width_x;'
p33760
aS'        if (std::abs(p[0]) > pml_x_start_position)'
p33761
aS'          {'
p33762
aS'            const double x_prime = std::abs(p[0]) - pml_x_start_position;'
p33763
aS'            calculated_pml_x_coeff ='
p33764
aS'              a_coeff_x * std::pow(x_prime, pml_coeff_degree);'
p33765
aS'          }'
p33766
aS'      }'
p33767
aS'    if ((component == 1) && pml_y)'
p33768
aS'      {'
p33769
aS'        const double pml_y_start_position = dimension_y / 2 - pml_width_y;'
p33770
aS'        if (std::abs(p[1]) > pml_y_start_position)'
p33771
aS'          {'
p33772
aS'            const double y_prime = std::abs(p[1]) - pml_y_start_position;'
p33773
aS'            calculated_pml_y_coeff ='
p33774
aS'              a_coeff_y * std::pow(y_prime, pml_coeff_degree);'
p33775
aS'          }'
p33776
aS'      }'
p33777
aS'    return 1. + std::max(calculated_pml_x_coeff, calculated_pml_y_coeff) *'
p33778
aS'                  std::complex<double>(0., 1.);'
p33779
aS'  }'
p33780
aS'  template <int dim>'
p33781
aS'  Rho<dim>::Rho(HDF5::Group &data)'
p33782
aS'    : Function<dim>(1)'
p33783
aS'    , data(data)'
p33784
aS'    , lambda(data.get_attribute<double>("lambda"))'
p33785
aS'    , mu(data.get_attribute<double>("mu"))'
p33786
aS'    , material_a_rho(data.get_attribute<double>("material_a_rho"))'
p33787
aS'    , material_b_rho(data.get_attribute<double>("material_b_rho"))'
p33788
aS'    , cavity_resonance_frequency('
p33789
aS'        data.get_attribute<double>("cavity_resonance_frequency"))'
p33790
aS'    , nb_mirror_pairs(data.get_attribute<int>("nb_mirror_pairs"))'
p33791
aS'    , dimension_y(data.get_attribute<double>("dimension_y"))'
p33792
aS'    , grid_level(data.get_attribute<int>("grid_level"))'
p33793
aS'  {'
p33794
aS'    average_rho_width = dimension_y / (std::pow(2.0, grid_level));'
p33795
aS'    data.set_attribute("average_rho_width", average_rho_width);'
p33796
aS'  }'
p33797
aS'  template <int dim>'
p33798
aS'  double Rho<dim>::value(const Point<dim> &p,'
p33799
aS'                         const unsigned int /*component*/) const'
p33800
aS'  {'
p33801
aS'    double elastic_constant;'
p33802
aS'    if (dim == 2)'
p33803
aS'      {'
p33804
aS'        elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu);'
p33805
aS'      }'
p33806
aS'    else if (dim == 3)'
p33807
aS'      {'
p33808
aS'        elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu);'
p33809
aS'      }'
p33810
aS'    else'
p33811
aS'      {'
p33812
aS'        Assert(false, ExcInternalError());'
p33813
aS'      }'
p33814
aS'    const double material_a_speed_of_sound ='
p33815
aS'      std::sqrt(elastic_constant / material_a_rho);'
p33816
aS'    const double material_a_wavelength ='
p33817
aS'      material_a_speed_of_sound / cavity_resonance_frequency;'
p33818
aS'    const double material_b_speed_of_sound ='
p33819
aS'      std::sqrt(elastic_constant / material_b_rho);'
p33820
aS'    const double material_b_wavelength ='
p33821
aS'      material_b_speed_of_sound / cavity_resonance_frequency;'
p33822
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p33823
aS'      {'
p33824
aS'        const double layer_transition_center ='
p33825
aS'          material_a_wavelength / 2 +'
p33826
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4);'
p33827
aS'        if (std::abs(p[0]) >='
p33828
aS'            std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))'
p33829
aS'          {'
p33830
aS'            const double coefficient ='
p33831
aS'              average_rho_width;'
p33832
aS'            return (1 - coefficient) * material_a_rho +'
p33833
aS'                   coefficient * material_b_rho;'
p33834
aS'          }'
p33835
aS'      }'
p33836
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p33837
aS'      {'
p33838
aS'        const double layer_transition_center ='
p33839
aS'          material_a_wavelength / 2 +'
p33840
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +'
p33841
aS'          material_b_wavelength / 4;'
p33842
aS'        if (std::abs(p[0]) >='
p33843
aS'            std::abs(p[0]) <= (layer_transition_center + average_rho_width / 2))'
p33844
aS'          {'
p33845
aS'            const double coefficient ='
p33846
aS'              average_rho_width;'
p33847
aS'            return (1 - coefficient) * material_b_rho +'
p33848
aS'                   coefficient * material_a_rho;'
p33849
aS'          }'
p33850
aS'      }'
p33851
aS'    if (std::abs(p[0]) <= material_a_wavelength / 2)'
p33852
aS'      {'
p33853
aS'        return material_a_rho;'
p33854
aS'      }'
p33855
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p33856
aS'      {'
p33857
aS'        const double layer_center ='
p33858
aS'          material_a_wavelength / 2 +'
p33859
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +'
p33860
aS'          material_b_wavelength / 4 + material_a_wavelength / 8;'
p33861
aS'        const double layer_width = material_a_wavelength / 4;'
p33862
aS'        if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&'
p33863
aS'            std::abs(p[0]) <= (layer_center + layer_width / 2))'
p33864
aS'          {'
p33865
aS'            return material_a_rho;'
p33866
aS'          }'
p33867
aS'      }'
p33868
aS'    for (unsigned int idx = 0; idx < nb_mirror_pairs; idx++)'
p33869
aS'      {'
p33870
aS'        const double layer_center ='
p33871
aS'          material_a_wavelength / 2 +'
p33872
aS'          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) +'
p33873
aS'          material_b_wavelength / 8;'
p33874
aS'        const double layer_width = material_b_wavelength / 4;'
p33875
aS'        if (std::abs(p[0]) >= (layer_center - layer_width / 2) &&'
p33876
aS'            std::abs(p[0]) <= (layer_center + layer_width / 2))'
p33877
aS'          {'
p33878
aS'            return material_b_rho;'
p33879
aS'          }'
p33880
aS'      }'
p33881
aS'    return material_a_rho;'
p33882
aS'  }'
p33883
aS'  template <int dim>'
p33884
aS'  Parameters<dim>::Parameters(HDF5::Group &data)'
p33885
aS'    : data(data)'
p33886
aS'    , simulation_name(data.get_attribute<std::string>("simulation_name"))'
p33887
aS'    , save_vtu_files(data.get_attribute<bool>("save_vtu_files"))'
p33888
aS'    , start_frequency(data.get_attribute<double>("start_frequency"))'
p33889
aS'    , stop_frequency(data.get_attribute<double>("stop_frequency"))'
p33890
aS'    , nb_frequency_points(data.get_attribute<int>("nb_frequency_points"))'
p33891
aS'    , lambda(data.get_attribute<double>("lambda"))'
p33892
aS'    , mu(data.get_attribute<double>("mu"))'
p33893
aS'    , dimension_x(data.get_attribute<double>("dimension_x"))'
p33894
aS'    , dimension_y(data.get_attribute<double>("dimension_y"))'
p33895
aS'    , nb_probe_points(data.get_attribute<int>("nb_probe_points"))'
p33896
aS'    , grid_level(data.get_attribute<int>("grid_level"))'
p33897
aS'    , probe_start_point(data.get_attribute<double>("probe_pos_x"),'
p33898
aS'                        data.get_attribute<double>("probe_pos_y") -'
p33899
aS'                          data.get_attribute<double>("probe_width_y") / 2)'
p33900
aS'    , probe_stop_point(data.get_attribute<double>("probe_pos_x"),'
p33901
aS'                       data.get_attribute<double>("probe_pos_y") +'
p33902
aS'                         data.get_attribute<double>("probe_width_y") / 2)'
p33903
aS'    , right_hand_side(data)'
p33904
aS'    , pml(data)'
p33905
aS'    , rho(data)'
p33906
aS'  {}'
p33907
aS'  template <int dim>'
p33908
aS'  QuadratureCache<dim>::QuadratureCache(const unsigned int dofs_per_cell)'
p33909
aS'    : dofs_per_cell(dofs_per_cell)'
p33910
aS'    , mass_coefficient(dofs_per_cell, dofs_per_cell)'
p33911
aS'    , stiffness_coefficient(dofs_per_cell, dofs_per_cell)'
p33912
aS'    , right_hand_side(dofs_per_cell)'
p33913
aS'  {}'
p33914
aS'  template <int dim>'
p33915
aS'  ElasticWave<dim>::ElasticWave(const Parameters<dim> &parameters)'
p33916
aS'    : parameters(parameters)'
p33917
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p33918
aS'    , triangulation(mpi_communicator,'
p33919
aS'                    typename Triangulation<dim>::MeshSmoothing('
p33920
aS'                      Triangulation<dim>::smoothing_on_refinement |'
p33921
aS'                      Triangulation<dim>::smoothing_on_coarsening))'
p33922
aS'    , quadrature_formula(2)'
p33923
aS'    , fe(FE_Q<dim>(1), dim)'
p33924
aS'    , dof_handler(triangulation)'
p33925
aS'    , frequency(parameters.nb_frequency_points)'
p33926
aS'    , probe_positions(parameters.nb_probe_points, dim)'
p33927
aS'    , frequency_dataset(parameters.data.template create_dataset<double>('
p33928
aS'        "frequency",'
p33929
aS'        std::vector<hsize_t>{parameters.nb_frequency_points}))'
p33930
aS'    , probe_positions_dataset(parameters.data.template create_dataset<double>('
p33931
aS'        "position",'
p33932
aS'        std::vector<hsize_t>{parameters.nb_probe_points, dim}))'
p33933
aS'    , displacement('
p33934
aS'        parameters.data.template create_dataset<std::complex<double>>('
p33935
aS'          "displacement",'
p33936
aS'          std::vector<hsize_t>{parameters.nb_probe_points,'
p33937
aS'                               parameters.nb_frequency_points}))'
p33938
aS'    , pcout(std::cout,'
p33939
aS'    , computing_timer(mpi_communicator,'
p33940
aS'                      pcout,'
p33941
aS'                      TimerOutput::summary,'
p33942
aS'                      TimerOutput::wall_times)'
p33943
aS'  {}'
p33944
aS'  template <int dim>'
p33945
aS'  void ElasticWave<dim>::setup_system()'
p33946
aS'  {'
p33947
aS'    TimerOutput::Scope t(computing_timer, "setup");'
p33948
aS'    dof_handler.distribute_dofs(fe);'
p33949
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p33950
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p33951
aS'    locally_relevant_solution.reinit(locally_owned_dofs,'
p33952
aS'                                     locally_relevant_dofs,'
p33953
aS'                                     mpi_communicator);'
p33954
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p33955
aS'    constraints.clear();'
p33956
aS'    constraints.reinit(locally_relevant_dofs);'
p33957
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p33958
aS'    constraints.close();'
p33959
aS'    DynamicSparsityPattern dsp(locally_relevant_dofs);'
p33960
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p33961
aS'    SparsityTools::distribute_sparsity_pattern(dsp,'
p33962
aS'                                               locally_owned_dofs,'
p33963
aS'                                               mpi_communicator,'
p33964
aS'                                               locally_relevant_dofs);'
p33965
aS'    system_matrix.reinit(locally_owned_dofs,'
p33966
aS'                         locally_owned_dofs,'
p33967
aS'                         dsp,'
p33968
aS'                         mpi_communicator);'
p33969
aS'  }'
p33970
aS'  template <int dim>'
p33971
aS'  void ElasticWave<dim>::assemble_system(const double omega,'
p33972
aS'                                         const bool   calculate_quadrature_data)'
p33973
aS'  {'
p33974
aS'    TimerOutput::Scope t(computing_timer, "assembly");'
p33975
aS'    FEValues<dim>      fe_values(fe,'
p33976
aS'                            quadrature_formula,'
p33977
aS'                            update_values | update_gradients |'
p33978
aS'                              update_quadrature_points | update_JxW_values);'
p33979
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p33980
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p33981
aS'    FullMatrix<std::complex<double>> cell_matrix(dofs_per_cell, dofs_per_cell);'
p33982
aS'    Vector<std::complex<double>>     cell_rhs(dofs_per_cell);'
p33983
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p33984
aS'    std::vector<Vector<double>> rhs_values(n_q_points, Vector<double>(dim));'
p33985
aS'    std::vector<double>         rho_values(n_q_points);'
p33986
aS'    std::vector<Vector<std::complex<double>>> pml_values('
p33987
aS'      n_q_points, Vector<std::complex<double>>(dim));'
p33988
aS'    const SymmetricTensor<4, dim> stiffness_tensor ='
p33989
aS'      get_stiffness_tensor<dim>(parameters.lambda, parameters.mu);'
p33990
aS'    const FEValuesExtractors::Vector displacement(0);'
p33991
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p33992
aS'      if (cell->is_locally_owned())'
p33993
aS'        {'
p33994
aS'          cell_matrix = 0;'
p33995
aS'          cell_rhs    = 0;'
p33996
aS'          if (calculate_quadrature_data)'
p33997
aS'            {'
p33998
aS'              fe_values.reinit(cell);'
p33999
aS'              parameters.right_hand_side.vector_value_list('
p34000
aS'                fe_values.get_quadrature_points(), rhs_values);'
p34001
aS'              parameters.rho.value_list(fe_values.get_quadrature_points(),'
p34002
aS'                                        rho_values);'
p34003
aS'              parameters.pml.vector_value_list('
p34004
aS'                fe_values.get_quadrature_points(), pml_values);'
p34005
aS'            }'
p34006
aS'          QuadratureCache<dim> *local_quadrature_points_data ='
p34007
aS'            reinterpret_cast<QuadratureCache<dim> *>(cell->user_pointer());'
p34008
aS'          Assert(local_quadrature_points_data >= &quadrature_cache.front(),'
p34009
aS'                 ExcInternalError());'
p34010
aS'          Assert(local_quadrature_points_data <= &quadrature_cache.back(),'
p34011
aS'                 ExcInternalError());'
p34012
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p34013
aS'            {'
p34014
aS'              QuadratureCache<dim> &quadrature_data ='
p34015
aS'                local_quadrature_points_data[q];'
p34016
aS'              Tensor<1, dim>                       force;'
p34017
aS'              Tensor<1, dim, std::complex<double>> s;'
p34018
aS'              std::complex<double>                 xi(1, 0);'
p34019
aS'              if (calculate_quadrature_data)'
p34020
aS'                {'
p34021
aS'                  quadrature_data.JxW = fe_values.JxW(q);'
p34022
aS'                  for (unsigned int component = 0; component < dim; ++component)'
p34023
aS'                    {'
p34024
aS'                      force[component] = rhs_values[q][component];'
p34025
aS'                      s[component]     = pml_values[q][component];'
p34026
aS'                      xi *= s[component];'
p34027
aS'                    }'
p34028
aS'                  Tensor<4, dim, std::complex<double>> alpha;'
p34029
aS'                  Tensor<4, dim, std::complex<double>> beta;'
p34030
aS'                  for (unsigned int m = 0; m < dim; ++m)'
p34031
aS'                    for (unsigned int n = 0; n < dim; ++n)'
p34032
aS'                      for (unsigned int k = 0; k < dim; ++k)'
p34033
aS'                        for (unsigned int l = 0; l < dim; ++l)'
p34034
aS'                          {'
p34035
aS'                            alpha[m][n][k][l] = xi *'
p34036
aS'                                                stiffness_tensor[m][n][k][l] /'
p34037
aS'                            beta[m][n][k][l] = xi *'
p34038
aS'                                               stiffness_tensor[m][n][k][l] /'
p34039
aS'                          }'
p34040
aS'                  for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34041
aS'                    {'
p34042
aS'                      const Tensor<1, dim> phi_i ='
p34043
aS'                        fe_values[displacement].value(i, q);'
p34044
aS'                      const Tensor<2, dim> grad_phi_i ='
p34045
aS'                        fe_values[displacement].gradient(i, q);'
p34046
aS'                      for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34047
aS'                        {'
p34048
aS'                          const Tensor<1, dim> phi_j ='
p34049
aS'                            fe_values[displacement].value(j, q);'
p34050
aS'                          const Tensor<2, dim> grad_phi_j ='
p34051
aS'                            fe_values[displacement].gradient(j, q);'
p34052
aS'                          quadrature_data.mass_coefficient[i][j] ='
p34053
aS'                            rho_values[q] * xi * phi_i * phi_j;'
p34054
aS'                          std::complex<double> stiffness_coefficient = 0;'
p34055
aS'                          for (unsigned int m = 0; m < dim; ++m)'
p34056
aS'                            for (unsigned int n = 0; n < dim; ++n)'
p34057
aS'                              for (unsigned int k = 0; k < dim; ++k)'
p34058
aS'                                for (unsigned int l = 0; l < dim; ++l)'
p34059
aS'                                  {'
p34060
aS'                                    stiffness_coefficient +='
p34061
aS'                                      grad_phi_i[m][n] *'
p34062
aS'                                       beta[m][n][k][l] * grad_phi_j[k][l]);'
p34063
aS'                                  }'
p34064
aS'                          quadrature_data.stiffness_coefficient[i][j] ='
p34065
aS'                            stiffness_coefficient;'
p34066
aS'                        }'
p34067
aS'                      quadrature_data.right_hand_side[i] ='
p34068
aS'                        phi_i * force * fe_values.JxW(q);'
p34069
aS'                    }'
p34070
aS'                }'
p34071
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34072
aS'                {'
p34073
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34074
aS'                    {'
p34075
aS'                      std::complex<double> matrix_sum = 0;'
p34076
aS'                      matrix_sum += -std::pow(omega, 2) *'
p34077
aS'                                    quadrature_data.mass_coefficient[i][j];'
p34078
aS'                      matrix_sum += quadrature_data.stiffness_coefficient[i][j];'
p34079
aS'                      cell_matrix(i, j) += matrix_sum * quadrature_data.JxW;'
p34080
aS'                    }'
p34081
aS'                  cell_rhs(i) += quadrature_data.right_hand_side[i];'
p34082
aS'                }'
p34083
aS'            }'
p34084
aS'          cell->get_dof_indices(local_dof_indices);'
p34085
aS'          constraints.distribute_local_to_global(cell_matrix,'
p34086
aS'                                                 cell_rhs,'
p34087
aS'                                                 local_dof_indices,'
p34088
aS'                                                 system_matrix,'
p34089
aS'                                                 system_rhs);'
p34090
aS'        }'
p34091
aS'    system_matrix.compress(VectorOperation::add);'
p34092
aS'    system_rhs.compress(VectorOperation::add);'
p34093
aS'  }'
p34094
aS'  template <int dim>'
p34095
aS'  void ElasticWave<dim>::solve()'
p34096
aS'  {'
p34097
aS'    TimerOutput::Scope              t(computing_timer, "solve");'
p34098
aS'    LinearAlgebraPETSc::MPI::Vector completely_distributed_solution('
p34099
aS'      locally_owned_dofs, mpi_communicator);'
p34100
aS'    SolverControl                    solver_control;'
p34101
aS'    PETScWrappers::SparseDirectMUMPS solver(solver_control, mpi_communicator);'
p34102
aS'    solver.solve(system_matrix, completely_distributed_solution, system_rhs);'
p34103
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p34104
aS'          << std::endl;'
p34105
aS'    constraints.distribute(completely_distributed_solution);'
p34106
aS'    locally_relevant_solution = completely_distributed_solution;'
p34107
aS'  }'
p34108
aS'  template <int dim>'
p34109
aS'  void ElasticWave<dim>::initialize_probe_positions_vector()'
p34110
aS'  {'
p34111
aS'    for (unsigned int position_idx = 0;'
p34112
aS'         position_idx < parameters.nb_probe_points;'
p34113
aS'         ++position_idx)'
p34114
aS'      {'
p34115
aS'        const Point<dim> p ='
p34116
aS'          parameters.probe_start_point;'
p34117
aS'        probe_positions[position_idx][0] = p[0];'
p34118
aS'        probe_positions[position_idx][1] = p[1];'
p34119
aS'        if (dim == 3)'
p34120
aS'          {'
p34121
aS'            probe_positions[position_idx][2] = p[2];'
p34122
aS'          }'
p34123
aS'      }'
p34124
aS'  }'
p34125
aS'  template <int dim>'
p34126
aS'  void'
p34127
aS'  ElasticWave<dim>::store_frequency_step_data(const unsigned int frequency_idx)'
p34128
aS'  {'
p34129
aS'    TimerOutput::Scope t(computing_timer, "store_frequency_step_data");'
p34130
aS'    const unsigned int probe_displacement_component = 0;'
p34131
aS'    std::vector<hsize_t>              coordinates;'
p34132
aS'    std::vector<std::complex<double>> displacement_data;'
p34133
aS'    const auto &mapping = get_default_linear_mapping(triangulation);'
p34134
aS'    GridTools::Cache<dim, dim> cache(triangulation, mapping);'
p34135
aS'    typename Triangulation<dim, dim>::active_cell_iterator cell_hint{};'
p34136
aS'    std::vector<bool>                                      marked_vertices = {};'
p34137
aS'    const double                                           tolerance = 1.e-10;'
p34138
aS'    for (unsigned int position_idx = 0;'
p34139
aS'         position_idx < parameters.nb_probe_points;'
p34140
aS'         ++position_idx)'
p34141
aS'      {'
p34142
aS'        Point<dim> point;'
p34143
aS'        for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p34144
aS'          {'
p34145
aS'            point[dim_idx] = probe_positions[position_idx][dim_idx];'
p34146
aS'          }'
p34147
aS'        bool point_in_locally_owned_cell = false;'
p34148
aS'        {'
p34149
aS'          auto cell_and_ref_point = GridTools::find_active_cell_around_point('
p34150
aS'            cache, point, cell_hint, marked_vertices, tolerance);'
p34151
aS'          if (cell_and_ref_point.first.state() == IteratorState::valid)'
p34152
aS'            {'
p34153
aS'              cell_hint = cell_and_ref_point.first;'
p34154
aS'              point_in_locally_owned_cell ='
p34155
aS'                cell_and_ref_point.first->is_locally_owned();'
p34156
aS'            }'
p34157
aS'        }'
p34158
aS'        if (point_in_locally_owned_cell)'
p34159
aS'          {'
p34160
aS'            Vector<std::complex<double>> tmp_vector(dim);'
p34161
aS'            VectorTools::point_value(dof_handler,'
p34162
aS'                                     locally_relevant_solution,'
p34163
aS'                                     point,'
p34164
aS'                                     tmp_vector);'
p34165
aS'            coordinates.emplace_back(position_idx);'
p34166
aS'            coordinates.emplace_back(frequency_idx);'
p34167
aS'            displacement_data.emplace_back('
p34168
aS'              tmp_vector(probe_displacement_component));'
p34169
aS'          }'
p34170
aS'      }'
p34171
aS'    if (coordinates.size() > 0)'
p34172
aS'      {'
p34173
aS'        displacement.write_selection(displacement_data, coordinates);'
p34174
aS'      }'
p34175
aS'    else'
p34176
aS'      {'
p34177
aS'        displacement.write_none<std::complex<double>>();'
p34178
aS'      }'
p34179
aS'    if (parameters.save_vtu_files)'
p34180
aS'      {'
p34181
aS'        std::vector<std::string> solution_names(dim, "displacement");'
p34182
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p34183
aS'          interpretation('
p34184
aS'            dim, DataComponentInterpretation::component_is_part_of_vector);'
p34185
aS'        DataOut<dim> data_out;'
p34186
aS'        data_out.add_data_vector(dof_handler,'
p34187
aS'                                 locally_relevant_solution,'
p34188
aS'                                 solution_names,'
p34189
aS'                                 interpretation);'
p34190
aS'        Vector<float> subdomain(triangulation.n_active_cells());'
p34191
aS'        for (unsigned int i = 0; i < subdomain.size(); ++i)'
p34192
aS'          subdomain(i) = triangulation.locally_owned_subdomain();'
p34193
aS'        data_out.add_data_vector(subdomain, "subdomain");'
p34194
aS'        std::vector<Vector<double>> force('
p34195
aS'          dim, Vector<double>(triangulation.n_active_cells()));'
p34196
aS'        std::vector<Vector<double>> pml('
p34197
aS'          dim, Vector<double>(triangulation.n_active_cells()));'
p34198
aS'        Vector<double> rho(triangulation.n_active_cells());'
p34199
aS'        for (auto &cell : triangulation.active_cell_iterators())'
p34200
aS'          {'
p34201
aS'            if (cell->is_locally_owned())'
p34202
aS'              {'
p34203
aS'                for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p34204
aS'                  {'
p34205
aS'                    force[dim_idx](cell->active_cell_index()) ='
p34206
aS'                      parameters.right_hand_side.value(cell->center(), dim_idx);'
p34207
aS'                    pml[dim_idx](cell->active_cell_index()) ='
p34208
aS'                      parameters.pml.value(cell->center(), dim_idx).imag();'
p34209
aS'                  }'
p34210
aS'                rho(cell->active_cell_index()) ='
p34211
aS'                  parameters.rho.value(cell->center());'
p34212
aS'              }'
p34213
aS'            else'
p34214
aS'              {'
p34215
aS'                for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p34216
aS'                  {'
p34217
aS'                    force[dim_idx](cell->active_cell_index()) = -1e+20;'
p34218
aS'                    pml[dim_idx](cell->active_cell_index())   = -1e+20;'
p34219
aS'                  }'
p34220
aS'                rho(cell->active_cell_index()) = -1e+20;'
p34221
aS'              }'
p34222
aS'          }'
p34223
aS'        for (unsigned int dim_idx = 0; dim_idx < dim; ++dim_idx)'
p34224
aS'          {'
p34225
aS'            data_out.add_data_vector(force[dim_idx],'
p34226
aS'                                     "force_" + std::to_string(dim_idx));'
p34227
aS'            data_out.add_data_vector(pml[dim_idx],'
p34228
aS'                                     "pml_" + std::to_string(dim_idx));'
p34229
aS'          }'
p34230
aS'        data_out.add_data_vector(rho, "rho");'
p34231
aS'        data_out.build_patches();'
p34232
aS'        std::stringstream  frequency_idx_stream;'
p34233
aS'        const unsigned int nb_number_positions ='
p34234
aS'        frequency_idx_stream << std::setw(nb_number_positions)'
p34235
aS"                             << std::setfill('0') << frequency_idx;"
p34236
aS'        std::string filename = (parameters.simulation_name + "_" +'
p34237
aS'                                frequency_idx_stream.str() + ".vtu");'
p34238
aS'        data_out.write_vtu_in_parallel(filename.c_str(), mpi_communicator);'
p34239
aS'      }'
p34240
aS'  }'
p34241
aS'  template <int dim>'
p34242
aS'  void ElasticWave<dim>::output_results()'
p34243
aS'  {'
p34244
aS'    if (Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p34245
aS'      {'
p34246
aS'        frequency_dataset.write(frequency);'
p34247
aS'        probe_positions_dataset.write(probe_positions);'
p34248
aS'      }'
p34249
aS'    else'
p34250
aS'      {'
p34251
aS'        frequency_dataset.write_none<double>();'
p34252
aS'        probe_positions_dataset.write_none<double>();'
p34253
aS'      }'
p34254
aS'  }'
p34255
aS'  template <int dim>'
p34256
aS'  void ElasticWave<dim>::setup_quadrature_cache()'
p34257
aS'  {'
p34258
aS'    triangulation.clear_user_data();'
p34259
aS'    {'
p34260
aS'      std::vector<QuadratureCache<dim>> tmp;'
p34261
aS'      quadrature_cache.swap(tmp);'
p34262
aS'    }'
p34263
aS'    quadrature_cache.resize(triangulation.n_locally_owned_active_cells() *'
p34264
aS'                              quadrature_formula.size(),'
p34265
aS'                            QuadratureCache<dim>(fe.n_dofs_per_cell()));'
p34266
aS'    unsigned int cache_index = 0;'
p34267
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p34268
aS'      if (cell->is_locally_owned())'
p34269
aS'        {'
p34270
aS'          cell->set_user_pointer(&quadrature_cache[cache_index]);'
p34271
aS'          cache_index += quadrature_formula.size();'
p34272
aS'        }'
p34273
aS'    Assert(cache_index == quadrature_cache.size(), ExcInternalError());'
p34274
aS'  }'
p34275
aS'  template <int dim>'
p34276
aS'  void ElasticWave<dim>::frequency_sweep()'
p34277
aS'  {'
p34278
aS'    for (unsigned int frequency_idx = 0;'
p34279
aS'         frequency_idx < parameters.nb_frequency_points;'
p34280
aS'         ++frequency_idx)'
p34281
aS'      {'
p34282
aS'        pcout << parameters.simulation_name + " frequency idx: "'
p34283
aS"              << frequency_idx << '/' << parameters.nb_frequency_points - 1"
p34284
aS'              << std::endl;'
p34285
aS'        setup_system();'
p34286
aS'        if (frequency_idx == 0)'
p34287
aS'          {'
p34288
aS'            pcout << "   Number of active cells :       "'
p34289
aS'                  << triangulation.n_active_cells() << std::endl;'
p34290
aS'            pcout << "   Number of degrees of freedom : "'
p34291
aS'                  << dof_handler.n_dofs() << std::endl;'
p34292
aS'          }'
p34293
aS'        if (frequency_idx == 0)'
p34294
aS'          {'
p34295
aS'            parameters.data.set_attribute("active_cells",'
p34296
aS'                                          triangulation.n_active_cells());'
p34297
aS'            parameters.data.set_attribute("degrees_of_freedom",'
p34298
aS'                                          dof_handler.n_dofs());'
p34299
aS'          }'
p34300
aS'        const double current_loop_frequency ='
p34301
aS'           frequency_idx *'
p34302
aS'        const double current_loop_omega ='
p34303
aS'          2 * numbers::PI * current_loop_frequency;'
p34304
aS'        assemble_system(current_loop_omega,'
p34305
aS'        solve();'
p34306
aS'        frequency[frequency_idx] = current_loop_frequency;'
p34307
aS'        store_frequency_step_data(frequency_idx);'
p34308
aS'        computing_timer.print_summary();'
p34309
aS'        computing_timer.reset();'
p34310
aS'        pcout << std::endl;'
p34311
aS'      }'
p34312
aS'  }'
p34313
aS'  template <int dim>'
p34314
aS'  void ElasticWave<dim>::run()'
p34315
aS'  {'
p34316
aS'#ifdef DEBUG'
p34317
aS'    pcout << "Debug mode" << std::endl;'
p34318
aS'#else'
p34319
aS'    pcout << "Release mode" << std::endl;'
p34320
aS'#endif'
p34321
aS'    {'
p34322
aS'      Point<dim> p1;'
p34323
aS'      p1(0) = -parameters.dimension_x / 2;'
p34324
aS'      p1(1) = -parameters.dimension_y / 2;'
p34325
aS'      if (dim == 3)'
p34326
aS'        {'
p34327
aS'          p1(2) = -parameters.dimension_y / 2;'
p34328
aS'        }'
p34329
aS'      Point<dim> p2;'
p34330
aS'      p2(0) = parameters.dimension_x / 2;'
p34331
aS'      p2(1) = parameters.dimension_y / 2;'
p34332
aS'      if (dim == 3)'
p34333
aS'        {'
p34334
aS'          p2(2) = parameters.dimension_y / 2;'
p34335
aS'        }'
p34336
aS'      std::vector<unsigned int> divisions(dim);'
p34337
aS'      divisions[0] = int(parameters.dimension_x / parameters.dimension_y);'
p34338
aS'      divisions[1] = 1;'
p34339
aS'      if (dim == 3)'
p34340
aS'        {'
p34341
aS'          divisions[2] = 1;'
p34342
aS'        }'
p34343
aS'      GridGenerator::subdivided_hyper_rectangle(triangulation,'
p34344
aS'                                                divisions,'
p34345
aS'                                                p1,'
p34346
aS'                                                p2);'
p34347
aS'    }'
p34348
aS'    triangulation.refine_global(parameters.grid_level);'
p34349
aS'    setup_quadrature_cache();'
p34350
aS'    initialize_probe_positions_vector();'
p34351
aS'    frequency_sweep();'
p34352
aS'    output_results();'
p34353
aS'  }'
p34354
aS'} // namespace step62'
p34355
aS'int main(int argc, char *argv[])'
p34356
ag9
aS'  try'
p34357
aS'    {'
p34358
aS'      using namespace dealii;'
p34359
aS'      const unsigned int dim = 2;'
p34360
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p34361
aS'      HDF5::File data_file("results.h5",'
p34362
aS'                           HDF5::File::FileAccessMode::create,'
p34363
aS'                           MPI_COMM_WORLD);'
p34364
aS'      auto       data = data_file.create_group("data");'
p34365
aS'      const std::vector<std::string> group_names = {"displacement",'
p34366
aS'                                                    "calibration"};'
p34367
aS'      for (auto group_name : group_names)'
p34368
aS'        {'
p34369
aS'          auto group = data.create_group(group_name);'
p34370
aS'          group.set_attribute<double>("dimension_x", 2e-5);'
p34371
aS'          group.set_attribute<double>("dimension_y", 2e-8);'
p34372
aS'          group.set_attribute<double>("probe_pos_x", 8e-6);'
p34373
aS'          group.set_attribute<double>("probe_pos_y", 0);'
p34374
aS'          group.set_attribute<double>("probe_width_y", 2e-08);'
p34375
aS'          group.set_attribute<unsigned int>("nb_probe_points", 5);'
p34376
aS'          group.set_attribute<unsigned int>("grid_level", 1);'
p34377
aS'          group.set_attribute<double>("cavity_resonance_frequency", 20e9);'
p34378
aS'          group.set_attribute<unsigned int>("nb_mirror_pairs", 15);'
p34379
aS'          group.set_attribute<double>("poissons_ratio", 0.27);'
p34380
aS'          group.set_attribute<double>("youngs_modulus", 270000000000.0);'
p34381
aS'          group.set_attribute<double>("material_a_rho", 3200);'
p34382
aS'          if (group_name == std::string("displacement"))'
p34383
aS'            group.set_attribute<double>("material_b_rho", 2000);'
p34384
aS'          else'
p34385
aS'            group.set_attribute<double>("material_b_rho", 3200);'
p34386
aS'          group.set_attribute('
p34387
aS'            "lambda",'
p34388
aS'            group.get_attribute<double>("youngs_modulus") *'
p34389
aS'              group.get_attribute<double>("poissons_ratio") /'
p34390
aS'          group.set_attribute("mu",'
p34391
aS'                              group.get_attribute<double>("youngs_modulus") /'
p34392
aS'                                            "poissons_ratio"))));'
p34393
aS'          group.set_attribute<double>("max_force_amplitude", 1e26);'
p34394
aS'          group.set_attribute<double>("force_sigma_x", 1e-7);'
p34395
aS'          group.set_attribute<double>("force_sigma_y", 1);'
p34396
aS'          group.set_attribute<double>("max_force_width_x", 3e-7);'
p34397
aS'          group.set_attribute<double>("max_force_width_y", 2e-8);'
p34398
aS'          group.set_attribute<double>("force_x_pos", -8e-6);'
p34399
aS'          group.set_attribute<double>("force_y_pos", 0);'
p34400
aS'          group.set_attribute<bool>("pml_x", true);'
p34401
aS'          group.set_attribute<bool>("pml_y", false);'
p34402
aS'          group.set_attribute<double>("pml_width_x", 1.8e-6);'
p34403
aS'          group.set_attribute<double>("pml_width_y", 5e-7);'
p34404
aS'          group.set_attribute<double>("pml_coeff", 1.6);'
p34405
aS'          group.set_attribute<unsigned int>("pml_coeff_degree", 2);'
p34406
aS'          group.set_attribute<double>("center_frequency", 20e9);'
p34407
aS'          group.set_attribute<double>("frequency_range", 0.5e9);'
p34408
aS'          group.set_attribute<double>('
p34409
aS'            "start_frequency",'
p34410
aS'            group.get_attribute<double>("center_frequency") -'
p34411
aS'              group.get_attribute<double>("frequency_range") / 2);'
p34412
aS'          group.set_attribute<double>('
p34413
aS'            "stop_frequency",'
p34414
aS'            group.get_attribute<double>("center_frequency") +'
p34415
aS'              group.get_attribute<double>("frequency_range") / 2);'
p34416
aS'          group.set_attribute<unsigned int>("nb_frequency_points", 400);'
p34417
aS'          if (group_name == std::string("displacement"))'
p34418
aS'            group.set_attribute<std::string>('
p34419
aS'              "simulation_name", std::string("phononic_cavity_displacement"));'
p34420
aS'          else'
p34421
aS'            group.set_attribute<std::string>('
p34422
aS'              "simulation_name", std::string("phononic_cavity_calibration"));'
p34423
aS'          group.set_attribute<bool>("save_vtu_files", false);'
p34424
aS'        }'
p34425
aS'      {'
p34426
aS'        auto                    displacement = data.open_group("displacement");'
p34427
aS'        step62::Parameters<dim> parameters(displacement);'
p34428
aS'        step62::ElasticWave<dim> elastic_problem(parameters);'
p34429
aS'        elastic_problem.run();'
p34430
aS'      }'
p34431
aS'      {'
p34432
aS'        auto                    calibration = data.open_group("calibration");'
p34433
aS'        step62::Parameters<dim> parameters(calibration);'
p34434
aS'        step62::ElasticWave<dim> elastic_problem(parameters);'
p34435
aS'        elastic_problem.run();'
p34436
aS'      }'
p34437
aS'    }'
p34438
aS'  catch (std::exception &exc)'
p34439
aS'    {'
p34440
aS'      std::cerr << std::endl'
p34441
aS'                << std::endl'
p34442
aS'                << "----------------------------------------------------"'
p34443
aS'                << std::endl;'
p34444
aS'      std::cerr << "Exception on processing: " << std::endl'
p34445
aS'                << exc.what() << std::endl'
p34446
aS'                << "Aborting!" << std::endl'
p34447
aS'                << "----------------------------------------------------"'
p34448
aS'                << std::endl;'
p34449
aS'      return 1;'
p34450
aS'    }'
p34451
aS'  catch (...)'
p34452
aS'    {'
p34453
aS'      std::cerr << std::endl'
p34454
aS'                << std::endl'
p34455
aS'                << "----------------------------------------------------"'
p34456
aS'                << std::endl;'
p34457
aS'      std::cerr << "Unknown exception!" << std::endl'
p34458
aS'                << "Aborting!" << std::endl'
p34459
aS'                << "----------------------------------------------------"'
p34460
aS'                << std::endl;'
p34461
aS'      return 1;'
p34462
aS'    }'
p34463
aS'  return 0;'
p34464
ag17
aS'#include <deal.II/base/tensor_function.h>'
p34465
aS'#include <deal.II/base/quadrature_lib.h>'
p34466
aS'#include <deal.II/base/function.h>'
p34467
aS'#include <deal.II/base/timer.h>'
p34468
aS'#include <deal.II/base/parameter_handler.h>'
p34469
aS'#include <deal.II/lac/affine_constraints.h>'
p34470
aS'#include <deal.II/lac/vector.h>'
p34471
aS'#include <deal.II/lac/full_matrix.h>'
p34472
aS'#include <deal.II/lac/sparse_matrix.h>'
p34473
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p34474
aS'#include <deal.II/lac/solver_gmres.h>'
p34475
aS'#include <deal.II/lac/precondition.h>'
p34476
aS'#include <deal.II/lac/relaxation_block.h>'
p34477
aS'#include <deal.II/grid/tria.h>'
p34478
aS'#include <deal.II/grid/grid_generator.h>'
p34479
aS'#include <deal.II/grid/grid_refinement.h>'
p34480
aS'#include <deal.II/grid/manifold_lib.h>'
p34481
aS'#include <deal.II/grid/grid_out.h>'
p34482
aS'#include <deal.II/dofs/dof_handler.h>'
p34483
aS'#include <deal.II/dofs/dof_renumbering.h>'
p34484
aS'#include <deal.II/dofs/dof_tools.h>'
p34485
aS'#include <deal.II/fe/fe_q.h>'
p34486
aS'#include <deal.II/fe/mapping_q.h>'
p34487
aS'#include <deal.II/fe/fe_values.h>'
p34488
aS'#include <deal.II/numerics/vector_tools.h>'
p34489
aS'#include <deal.II/numerics/matrix_tools.h>'
p34490
aS'#include <deal.II/numerics/data_out.h>'
p34491
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p34492
aS'#include <deal.II/multigrid/multigrid.h>'
p34493
aS'#include <deal.II/multigrid/mg_transfer.h>'
p34494
aS'#include <deal.II/multigrid/mg_tools.h>'
p34495
aS'#include <deal.II/multigrid/mg_coarse.h>'
p34496
aS'#include <deal.II/multigrid/mg_smoother.h>'
p34497
aS'#include <deal.II/multigrid/mg_matrix.h>'
p34498
aS'#include <algorithm>'
p34499
aS'#include <fstream>'
p34500
aS'#include <iostream>'
p34501
aS'#include <random>'
p34502
aS'#include <deal.II/meshworker/mesh_loop.h>'
p34503
aS'namespace Step63'
p34504
ag9
aS'  using namespace dealii;'
p34505
aS'  template <int dim>'
p34506
aS'  struct ScratchData'
p34507
aS'  {'
p34508
aS'    ScratchData(const FiniteElement<dim> &fe,'
p34509
aS'                const unsigned int        quadrature_degree)'
p34510
aS'      : fe_values(fe,'
p34511
aS'                  QGauss<dim>(quadrature_degree),'
p34512
aS'                  update_values | update_gradients | update_hessians |'
p34513
aS'                    update_quadrature_points | update_JxW_values)'
p34514
aS'    {}'
p34515
aS'    ScratchData(const ScratchData<dim> &scratch_data)'
p34516
aS'      : fe_values(scratch_data.fe_values.get_fe(),'
p34517
aS'                  scratch_data.fe_values.get_quadrature(),'
p34518
aS'                  update_values | update_gradients | update_hessians |'
p34519
aS'                    update_quadrature_points | update_JxW_values)'
p34520
aS'    {}'
p34521
aS'    FEValues<dim> fe_values;'
p34522
aS'  };'
p34523
aS'  struct CopyData'
p34524
aS'  {'
p34525
aS'    CopyData() = default;'
p34526
aS'    unsigned int level;'
p34527
aS'    unsigned int dofs_per_cell;'
p34528
aS'    FullMatrix<double>                   cell_matrix;'
p34529
aS'    Vector<double>                       cell_rhs;'
p34530
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p34531
aS'  };'
p34532
aS'  struct Settings'
p34533
aS'  {'
p34534
aS'    enum DoFRenumberingStrategy'
p34535
aS'    {'
p34536
aS'      none,'
p34537
aS'      downstream,'
p34538
aS'      upstream,'
p34539
aS'      random'
p34540
aS'    };'
p34541
aS'    void get_parameters(const std::string &prm_filename);'
p34542
aS'    double                 epsilon;'
p34543
aS'    unsigned int           fe_degree;'
p34544
aS'    std::string            smoother_type;'
p34545
aS'    unsigned int           smoothing_steps;'
p34546
aS'    DoFRenumberingStrategy dof_renumbering;'
p34547
aS'    bool                   with_streamline_diffusion;'
p34548
aS'    bool                   output;'
p34549
aS'  };'
p34550
aS'  void Settings::get_parameters(const std::string &prm_filename)'
p34551
aS'  {'
p34552
aS'    ParameterHandler prm;'
p34553
aS'    prm.declare_entry("Epsilon",'
p34554
aS'                      "0.005",'
p34555
aS'                      Patterns::Double(0),'
p34556
aS'                      "Diffusion parameter");'
p34557
aS'    prm.declare_entry("Fe degree",'
p34558
aS'                      "1",'
p34559
aS'                      Patterns::Integer(1),'
p34560
aS'                      "Finite Element degree");'
p34561
aS'    prm.declare_entry("Smoother type",'
p34562
aS'                      "block SOR",'
p34563
aS'                      Patterns::Selection("SOR|Jacobi|block SOR|block Jacobi"),'
p34564
aS'                      "Select smoother: SOR|Jacobi|block SOR|block Jacobi");'
p34565
aS'    prm.declare_entry("Smoothing steps",'
p34566
aS'                      "2",'
p34567
aS'                      Patterns::Integer(1),'
p34568
aS'                      "Number of smoothing steps");'
p34569
aS'    prm.declare_entry('
p34570
aS'      "DoF renumbering",'
p34571
aS'      "downstream",'
p34572
aS'      Patterns::Selection("none|downstream|upstream|random"),'
p34573
aS'      "Select DoF renumbering: none|downstream|upstream|random");'
p34574
aS'    prm.declare_entry("With streamline diffusion",'
p34575
aS'                      "true",'
p34576
aS'                      Patterns::Bool(),'
p34577
aS'                      "Enable streamline diffusion stabilization: true|false");'
p34578
aS'    prm.declare_entry("Output",'
p34579
aS'                      "true",'
p34580
aS'                      Patterns::Bool(),'
p34581
aS'                      "Generate graphical output: true|false");'
p34582
aS'    if (prm_filename.empty())'
p34583
aS'      {'
p34584
aS'        prm.print_parameters(std::cout, ParameterHandler::Text);'
p34585
aS'        AssertThrow('
p34586
aS'          false, ExcMessage("Please pass a .prm file as the first argument!"));'
p34587
aS'      }'
p34588
aS'    prm.parse_input(prm_filename);'
p34589
aS'    epsilon         = prm.get_double("Epsilon");'
p34590
aS'    fe_degree       = prm.get_integer("Fe degree");'
p34591
aS'    smoother_type   = prm.get("Smoother type");'
p34592
aS'    smoothing_steps = prm.get_integer("Smoothing steps");'
p34593
aS'    const std::string renumbering = prm.get("DoF renumbering");'
p34594
aS'    if (renumbering == "none")'
p34595
aS'      dof_renumbering = DoFRenumberingStrategy::none;'
p34596
aS'    else if (renumbering == "downstream")'
p34597
aS'      dof_renumbering = DoFRenumberingStrategy::downstream;'
p34598
aS'    else if (renumbering == "upstream")'
p34599
aS'      dof_renumbering = DoFRenumberingStrategy::upstream;'
p34600
aS'    else if (renumbering == "random")'
p34601
aS'      dof_renumbering = DoFRenumberingStrategy::random;'
p34602
aS'    else'
p34603
aS'      AssertThrow(false,'
p34604
aS'                  ExcMessage("The <DoF renumbering> parameter has "'
p34605
aS'                             "an invalid value."));'
p34606
aS'    with_streamline_diffusion = prm.get_bool("With streamline diffusion");'
p34607
aS'    output                    = prm.get_bool("Output");'
p34608
aS'  }'
p34609
aS'  template <int dim>'
p34610
aS'  std::vector<unsigned int>'
p34611
aS'  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,'
p34612
aS'                                  const Tensor<1, dim>   direction,'
p34613
aS'                                  const unsigned int     level)'
p34614
aS'  {'
p34615
aS'    std::vector<typename DoFHandler<dim>::level_cell_iterator> ordered_cells;'
p34616
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));'
p34617
aS'    for (const auto &cell : dof_handler.cell_iterators_on_level(level))'
p34618
aS'      ordered_cells.push_back(cell);'
p34619
aS'    const DoFRenumbering::'
p34620
aS'      CompareDownstream<typename DoFHandler<dim>::level_cell_iterator, dim>'
p34621
aS'        comparator(direction);'
p34622
aS'    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);'
p34623
aS'    std::vector<unsigned> ordered_indices;'
p34624
aS'    ordered_indices.reserve(dof_handler.get_triangulation().n_cells(level));'
p34625
aS'    for (const auto &cell : ordered_cells)'
p34626
aS'      ordered_indices.push_back(cell->index());'
p34627
aS'    return ordered_indices;'
p34628
aS'  }'
p34629
aS'  template <int dim>'
p34630
aS'  std::vector<unsigned int>'
p34631
aS'  create_downstream_cell_ordering(const DoFHandler<dim> &dof_handler,'
p34632
aS'                                  const Tensor<1, dim>   direction)'
p34633
aS'  {'
p34634
aS'    std::vector<typename DoFHandler<dim>::active_cell_iterator> ordered_cells;'
p34635
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());'
p34636
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p34637
aS'      ordered_cells.push_back(cell);'
p34638
aS'    const DoFRenumbering::'
p34639
aS'      CompareDownstream<typename DoFHandler<dim>::active_cell_iterator, dim>'
p34640
aS'        comparator(direction);'
p34641
aS'    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);'
p34642
aS'    std::vector<unsigned int> ordered_indices;'
p34643
aS'    ordered_indices.reserve(dof_handler.get_triangulation().n_active_cells());'
p34644
aS'    for (const auto &cell : ordered_cells)'
p34645
aS'      ordered_indices.push_back(cell->index());'
p34646
aS'    return ordered_indices;'
p34647
aS'  }'
p34648
aS'  template <int dim>'
p34649
aS'  std::vector<unsigned int>'
p34650
aS'  create_random_cell_ordering(const DoFHandler<dim> &dof_handler,'
p34651
aS'                              const unsigned int     level)'
p34652
aS'  {'
p34653
aS'    std::vector<unsigned int> ordered_cells;'
p34654
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_cells(level));'
p34655
aS'    for (const auto &cell : dof_handler.cell_iterators_on_level(level))'
p34656
aS'      ordered_cells.push_back(cell->index());'
p34657
aS'    std::mt19937 random_number_generator;'
p34658
aS'    std::shuffle(ordered_cells.begin(),'
p34659
aS'                 ordered_cells.end(),'
p34660
aS'                 random_number_generator);'
p34661
aS'    return ordered_cells;'
p34662
aS'  }'
p34663
aS'  template <int dim>'
p34664
aS'  std::vector<unsigned int>'
p34665
aS'  create_random_cell_ordering(const DoFHandler<dim> &dof_handler)'
p34666
aS'  {'
p34667
aS'    std::vector<unsigned int> ordered_cells;'
p34668
aS'    ordered_cells.reserve(dof_handler.get_triangulation().n_active_cells());'
p34669
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p34670
aS'      ordered_cells.push_back(cell->index());'
p34671
aS'    std::mt19937 random_number_generator;'
p34672
aS'    std::shuffle(ordered_cells.begin(),'
p34673
aS'                 ordered_cells.end(),'
p34674
aS'                 random_number_generator);'
p34675
aS'    return ordered_cells;'
p34676
aS'  }'
p34677
aS'  template <int dim>'
p34678
aS'  class RightHandSide : public Function<dim>'
p34679
aS'  {'
p34680
aS'  public:'
p34681
aS'    virtual double value(const Point<dim> & p,'
p34682
aS'                         const unsigned int component = 0) const override;'
p34683
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p34684
aS'                            std::vector<double> &          values,'
p34685
aS'                            const unsigned int component = 0) const override;'
p34686
aS'  };'
p34687
aS'  template <int dim>'
p34688
aS'  double RightHandSide<dim>::value(const Point<dim> &,'
p34689
aS'                                   const unsigned int component) const'
p34690
aS'  {'
p34691
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p34692
aS'    return 0.0;'
p34693
aS'  }'
p34694
aS'  template <int dim>'
p34695
aS'  void RightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,'
p34696
aS'                                      std::vector<double> &          values,'
p34697
aS'                                      const unsigned int component) const'
p34698
aS'  {'
p34699
aS'    Assert(values.size() == points.size(),'
p34700
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p34701
aS'    for (unsigned int i = 0; i < points.size(); ++i)'
p34702
aS'      values[i] = RightHandSide<dim>::value(points[i], component);'
p34703
aS'  }'
p34704
aS'  template <int dim>'
p34705
aS'  class BoundaryValues : public Function<dim>'
p34706
aS'  {'
p34707
aS'  public:'
p34708
aS'    virtual double value(const Point<dim> & p,'
p34709
aS'                         const unsigned int component = 0) const override;'
p34710
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p34711
aS'                            std::vector<double> &          values,'
p34712
aS'                            const unsigned int component = 0) const override;'
p34713
aS'  };'
p34714
aS'  template <int dim>'
p34715
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p34716
aS'                                    const unsigned int component) const'
p34717
aS'  {'
p34718
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p34719
aS'    if (std::fabs(p[0] - 1) < 1e-8 ||'
p34720
aS'      {'
p34721
aS'        return 1.0;'
p34722
aS'      }'
p34723
aS'    else'
p34724
aS'      {'
p34725
aS'        return 0.0;'
p34726
aS'      }'
p34727
aS'  }'
p34728
aS'  template <int dim>'
p34729
aS'  void BoundaryValues<dim>::value_list(const std::vector<Point<dim>> &points,'
p34730
aS'                                       std::vector<double> &          values,'
p34731
aS'                                       const unsigned int component) const'
p34732
aS'  {'
p34733
aS'    Assert(values.size() == points.size(),'
p34734
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p34735
aS'    for (unsigned int i = 0; i < points.size(); ++i)'
p34736
aS'      values[i] = BoundaryValues<dim>::value(points[i], component);'
p34737
aS'  }'
p34738
aS'  template <int dim>'
p34739
aS'  double compute_stabilization_delta(const double         hk,'
p34740
aS'                                     const double         eps,'
p34741
aS'                                     const Tensor<1, dim> dir,'
p34742
aS'                                     const double         pk)'
p34743
aS'  {'
p34744
aS'    const double Peclet = dir.norm() * hk / (2.0 * eps * pk);'
p34745
aS'    const double coth ='
p34746
aS'    return hk / (2.0 * dir.norm() * pk) * (coth - 1.0 / Peclet);'
p34747
aS'  }'
p34748
aS'  template <int dim>'
p34749
aS'  class AdvectionProblem'
p34750
aS'  {'
p34751
aS'  public:'
p34752
aS'    AdvectionProblem(const Settings &settings);'
p34753
aS'    void run();'
p34754
aS'  private:'
p34755
aS'    void setup_system();'
p34756
aS'    template <class IteratorType>'
p34757
aS'    void assemble_cell(const IteratorType &cell,'
p34758
aS'                       ScratchData<dim> &  scratch_data,'
p34759
aS'                       CopyData &          copy_data);'
p34760
aS'    void assemble_system_and_multigrid();'
p34761
aS'    void setup_smoother();'
p34762
aS'    void solve();'
p34763
aS'    void refine_grid();'
p34764
aS'    void output_results(const unsigned int cycle) const;'
p34765
aS'    Triangulation<dim> triangulation;'
p34766
aS'    DoFHandler<dim>    dof_handler;'
p34767
aS'    const FE_Q<dim>     fe;'
p34768
aS'    const MappingQ<dim> mapping;'
p34769
aS'    AffineConstraints<double> constraints;'
p34770
aS'    SparsityPattern      sparsity_pattern;'
p34771
aS'    SparseMatrix<double> system_matrix;'
p34772
aS'    Vector<double> solution;'
p34773
aS'    Vector<double> system_rhs;'
p34774
aS'    MGLevelObject<SparsityPattern> mg_sparsity_patterns;'
p34775
aS'    MGLevelObject<SparsityPattern> mg_interface_sparsity_patterns;'
p34776
aS'    MGLevelObject<SparseMatrix<double>> mg_matrices;'
p34777
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_in;'
p34778
aS'    MGLevelObject<SparseMatrix<double>> mg_interface_out;'
p34779
aS'    mg::Matrix<Vector<double>> mg_matrix;'
p34780
aS'    mg::Matrix<Vector<double>> mg_interface_matrix_in;'
p34781
aS'    mg::Matrix<Vector<double>> mg_interface_matrix_out;'
p34782
aS'    std::unique_ptr<MGSmoother<Vector<double>>> mg_smoother;'
p34783
aS'    using SmootherType ='
p34784
aS'      RelaxationBlock<SparseMatrix<double>, double, Vector<double>>;'
p34785
aS'    using SmootherAdditionalDataType = SmootherType::AdditionalData;'
p34786
aS'    MGLevelObject<SmootherAdditionalDataType> smoother_data;'
p34787
aS'    MGConstrainedDoFs mg_constrained_dofs;'
p34788
aS'    Tensor<1, dim> advection_direction;'
p34789
aS'    const Settings settings;'
p34790
aS'  };'
p34791
aS'  template <int dim>'
p34792
aS'  AdvectionProblem<dim>::AdvectionProblem(const Settings &settings)'
p34793
aS'    : triangulation(Triangulation<dim>::limit_level_difference_at_vertices)'
p34794
aS'    , dof_handler(triangulation)'
p34795
aS'    , fe(settings.fe_degree)'
p34796
aS'    , mapping(settings.fe_degree)'
p34797
aS'    , settings(settings)'
p34798
aS'  {'
p34799
aS'    advection_direction[0] = -std::sin(numbers::PI / 6.0);'
p34800
aS'    if (dim >= 2)'
p34801
aS'      advection_direction[1] = std::cos(numbers::PI / 6.0);'
p34802
aS'    if (dim >= 3)'
p34803
aS'      AssertThrow(false, ExcNotImplemented());'
p34804
aS'  }'
p34805
aS'  template <int dim>'
p34806
aS'  void AdvectionProblem<dim>::setup_system()'
p34807
aS'  {'
p34808
aS'    const unsigned int n_levels = triangulation.n_levels();'
p34809
aS'    dof_handler.distribute_dofs(fe);'
p34810
aS'    solution.reinit(dof_handler.n_dofs());'
p34811
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p34812
aS'    constraints.clear();'
p34813
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p34814
aS'    VectorTools::interpolate_boundary_values('
p34815
aS'      mapping, dof_handler, 0, BoundaryValues<dim>(), constraints);'
p34816
aS'    VectorTools::interpolate_boundary_values('
p34817
aS'      mapping, dof_handler, 1, BoundaryValues<dim>(), constraints);'
p34818
aS'    constraints.close();'
p34819
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p34820
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p34821
aS'                                    dsp,'
p34822
aS'                                    constraints,'
p34823
aS'    sparsity_pattern.copy_from(dsp);'
p34824
aS'    system_matrix.reinit(sparsity_pattern);'
p34825
aS'    dof_handler.distribute_mg_dofs();'
p34826
aS'    if (settings.smoother_type == "SOR" || settings.smoother_type == "Jacobi")'
p34827
aS'      {'
p34828
aS'        if (settings.dof_renumbering =='
p34829
aS'              Settings::DoFRenumberingStrategy::downstream ||'
p34830
aS'            settings.dof_renumbering =='
p34831
aS'              Settings::DoFRenumberingStrategy::upstream)'
p34832
aS'          {'
p34833
aS'            const Tensor<1, dim> direction ='
p34834
aS'                   Settings::DoFRenumberingStrategy::upstream ?'
p34835
aS'                 -1.0 :'
p34836
aS'                 1.0) *'
p34837
aS'              advection_direction;'
p34838
aS'            for (unsigned int level = 0; level < n_levels; ++level)'
p34839
aS'              DoFRenumbering::downstream(dof_handler,'
p34840
aS'                                         level,'
p34841
aS'                                         direction,'
p34842
aS'          }'
p34843
aS'        else if (settings.dof_renumbering =='
p34844
aS'                 Settings::DoFRenumberingStrategy::random)'
p34845
aS'          {'
p34846
aS'            for (unsigned int level = 0; level < n_levels; ++level)'
p34847
aS'              DoFRenumbering::random(dof_handler, level);'
p34848
aS'          }'
p34849
aS'        else'
p34850
aS'          Assert(false, ExcNotImplemented());'
p34851
aS'      }'
p34852
aS'    mg_constrained_dofs.clear();'
p34853
aS'    mg_constrained_dofs.initialize(dof_handler);'
p34854
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});'
p34855
aS'    mg_matrices.resize(0, n_levels - 1);'
p34856
aS'    mg_matrices.clear_elements();'
p34857
aS'    mg_interface_in.resize(0, n_levels - 1);'
p34858
aS'    mg_interface_in.clear_elements();'
p34859
aS'    mg_interface_out.resize(0, n_levels - 1);'
p34860
aS'    mg_interface_out.clear_elements();'
p34861
aS'    mg_sparsity_patterns.resize(0, n_levels - 1);'
p34862
aS'    mg_interface_sparsity_patterns.resize(0, n_levels - 1);'
p34863
aS'    for (unsigned int level = 0; level < n_levels; ++level)'
p34864
aS'      {'
p34865
aS'        {'
p34866
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p34867
aS'                                     dof_handler.n_dofs(level));'
p34868
aS'          MGTools::make_sparsity_pattern(dof_handler, dsp, level);'
p34869
aS'          mg_sparsity_patterns[level].copy_from(dsp);'
p34870
aS'          mg_matrices[level].reinit(mg_sparsity_patterns[level]);'
p34871
aS'        }'
p34872
aS'        {'
p34873
aS'          DynamicSparsityPattern dsp(dof_handler.n_dofs(level),'
p34874
aS'                                     dof_handler.n_dofs(level));'
p34875
aS'          MGTools::make_interface_sparsity_pattern(dof_handler,'
p34876
aS'                                                   mg_constrained_dofs,'
p34877
aS'                                                   dsp,'
p34878
aS'                                                   level);'
p34879
aS'          mg_interface_sparsity_patterns[level].copy_from(dsp);'
p34880
aS'          mg_interface_in[level].reinit(mg_interface_sparsity_patterns[level]);'
p34881
aS'          mg_interface_out[level].reinit(mg_interface_sparsity_patterns[level]);'
p34882
aS'        }'
p34883
aS'      }'
p34884
aS'  }'
p34885
aS'  template <int dim>'
p34886
aS'  template <class IteratorType>'
p34887
aS'  void AdvectionProblem<dim>::assemble_cell(const IteratorType &cell,'
p34888
aS'                                            ScratchData<dim> &  scratch_data,'
p34889
aS'                                            CopyData &          copy_data)'
p34890
aS'  {'
p34891
aS'    copy_data.level = cell->level();'
p34892
aS'    const unsigned int dofs_per_cell ='
p34893
aS'      scratch_data.fe_values.get_fe().n_dofs_per_cell();'
p34894
aS'    copy_data.dofs_per_cell = dofs_per_cell;'
p34895
aS'    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p34896
aS'    const unsigned int n_q_points ='
p34897
aS'      scratch_data.fe_values.get_quadrature().size();'
p34898
aS'    if (cell->is_level_cell() == false)'
p34899
aS'      copy_data.cell_rhs.reinit(dofs_per_cell);'
p34900
aS'    copy_data.local_dof_indices.resize(dofs_per_cell);'
p34901
aS'    cell->get_active_or_mg_dof_indices(copy_data.local_dof_indices);'
p34902
aS'    scratch_data.fe_values.reinit(cell);'
p34903
aS'    RightHandSide<dim>  right_hand_side;'
p34904
aS'    std::vector<double> rhs_values(n_q_points);'
p34905
aS'    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),'
p34906
aS'                               rhs_values);'
p34907
aS'    const double delta = (settings.with_streamline_diffusion ?'
p34908
aS'                            compute_stabilization_delta(cell->diameter(),'
p34909
aS'                                                        settings.epsilon,'
p34910
aS'                                                        advection_direction,'
p34911
aS'                                                        settings.fe_degree) :'
p34912
aS'                            0.0);'
p34913
aS'    for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p34914
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p34915
aS'        {'
p34916
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p34917
aS'            {'
p34918
aS'              copy_data.cell_matrix(i, j) +='
p34919
aS'                 scratch_data.fe_values.shape_grad(i, q_point) *'
p34920
aS'                 scratch_data.fe_values.shape_grad(j, q_point) *'
p34921
aS'                 scratch_data.fe_values.JxW(q_point)) +'
p34922
aS'                  scratch_data.fe_values.shape_grad(j, q_point)) *'
p34923
aS'                 scratch_data.fe_values.JxW(q_point))'
p34924
aS'                + delta *'
p34925
aS'                     scratch_data.fe_values.shape_grad(j, q_point)) *'
p34926
aS'                     scratch_data.fe_values.shape_grad(i, q_point)) *'
p34927
aS'                    scratch_data.fe_values.JxW(q_point) -'
p34928
aS'                delta * settings.epsilon *'
p34929
aS'                  trace(scratch_data.fe_values.shape_hessian(j, q_point)) *'
p34930
aS'                   scratch_data.fe_values.shape_grad(i, q_point)) *'
p34931
aS'                  scratch_data.fe_values.JxW(q_point);'
p34932
aS'            }'
p34933
aS'          if (cell->is_level_cell() == false)'
p34934
aS'            {'
p34935
aS'              copy_data.cell_rhs(i) +='
p34936
aS'                scratch_data.fe_values.shape_value(i, q_point) *'
p34937
aS'                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)'
p34938
aS'                + delta * rhs_values[q_point] * advection_direction *'
p34939
aS'                    scratch_data.fe_values.shape_grad(i, q_point) *'
p34940
aS'                    scratch_data.fe_values.JxW(q_point);'
p34941
aS'            }'
p34942
aS'        }'
p34943
aS'  }'
p34944
aS'  template <int dim>'
p34945
aS'  void AdvectionProblem<dim>::assemble_system_and_multigrid()'
p34946
aS'  {'
p34947
aS'    const auto cell_worker_active ='
p34948
aS'      [&](const decltype(dof_handler.begin_active()) &cell,'
p34949
aS'          ScratchData<dim> &                          scratch_data,'
p34950
aS'          CopyData &                                  copy_data) {'
p34951
aS'        this->assemble_cell(cell, scratch_data, copy_data);'
p34952
aS'      };'
p34953
aS'    const auto copier_active = [&](const CopyData &copy_data) {'
p34954
aS'      constraints.distribute_local_to_global(copy_data.cell_matrix,'
p34955
aS'                                             copy_data.cell_rhs,'
p34956
aS'                                             copy_data.local_dof_indices,'
p34957
aS'                                             system_matrix,'
p34958
aS'                                             system_rhs);'
p34959
aS'    };'
p34960
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p34961
aS'                          dof_handler.end(),'
p34962
aS'                          cell_worker_active,'
p34963
aS'                          copier_active,'
p34964
aS'                          ScratchData<dim>(fe, fe.degree + 1),'
p34965
aS'                          CopyData(),'
p34966
aS'                          MeshWorker::assemble_own_cells);'
p34967
aS'    std::vector<AffineConstraints<double>> boundary_constraints('
p34968
aS'      triangulation.n_global_levels());'
p34969
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p34970
aS'         ++level)'
p34971
aS'      {'
p34972
aS'        IndexSet locally_owned_level_dof_indices;'
p34973
aS'        DoFTools::extract_locally_relevant_level_dofs('
p34974
aS'          dof_handler, level, locally_owned_level_dof_indices);'
p34975
aS'        boundary_constraints[level].reinit(locally_owned_level_dof_indices);'
p34976
aS'        boundary_constraints[level].add_lines('
p34977
aS'          mg_constrained_dofs.get_refinement_edge_indices(level));'
p34978
aS'        boundary_constraints[level].add_lines('
p34979
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p34980
aS'        boundary_constraints[level].close();'
p34981
aS'      }'
p34982
aS'    const auto cell_worker_mg ='
p34983
aS'      [&](const decltype(dof_handler.begin_mg()) &cell,'
p34984
aS'          ScratchData<dim> &                      scratch_data,'
p34985
aS'          CopyData &                              copy_data) {'
p34986
aS'        this->assemble_cell(cell, scratch_data, copy_data);'
p34987
aS'      };'
p34988
aS'    const auto copier_mg = [&](const CopyData &copy_data) {'
p34989
aS'      boundary_constraints[copy_data.level].distribute_local_to_global('
p34990
aS'        copy_data.cell_matrix,'
p34991
aS'        copy_data.local_dof_indices,'
p34992
aS'        mg_matrices[copy_data.level]);'
p34993
aS'      for (unsigned int i = 0; i < copy_data.dofs_per_cell; ++i)'
p34994
aS'        for (unsigned int j = 0; j < copy_data.dofs_per_cell; ++j)'
p34995
aS'          if (mg_constrained_dofs.is_interface_matrix_entry('
p34996
aS'                copy_data.level,'
p34997
aS'                copy_data.local_dof_indices[i],'
p34998
aS'                copy_data.local_dof_indices[j]))'
p34999
aS'            {'
p35000
aS'              mg_interface_out[copy_data.level].add('
p35001
aS'                copy_data.local_dof_indices[i],'
p35002
aS'                copy_data.local_dof_indices[j],'
p35003
aS'                copy_data.cell_matrix(i, j));'
p35004
aS'              mg_interface_in[copy_data.level].add('
p35005
aS'                copy_data.local_dof_indices[i],'
p35006
aS'                copy_data.local_dof_indices[j],'
p35007
aS'                copy_data.cell_matrix(j, i));'
p35008
aS'            }'
p35009
aS'    };'
p35010
aS'    MeshWorker::mesh_loop(dof_handler.begin_mg(),'
p35011
aS'                          dof_handler.end_mg(),'
p35012
aS'                          cell_worker_mg,'
p35013
aS'                          copier_mg,'
p35014
aS'                          ScratchData<dim>(fe, fe.degree + 1),'
p35015
aS'                          CopyData(),'
p35016
aS'                          MeshWorker::assemble_own_cells);'
p35017
aS'  }'
p35018
aS'  template <int dim>'
p35019
aS'  void AdvectionProblem<dim>::setup_smoother()'
p35020
aS'  {'
p35021
aS'    if (settings.smoother_type == "SOR")'
p35022
aS'      {'
p35023
aS'        using Smoother = PreconditionSOR<SparseMatrix<double>>;'
p35024
aS'        auto smoother ='
p35025
aS'          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,'
p35026
aS'                                                  Smoother,'
p35027
aS'                                                  Vector<double>>>();'
p35028
aS'        smoother->initialize(mg_matrices,'
p35029
aS'                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 :'
p35030
aS'                                                                       0.62));'
p35031
aS'        smoother->set_steps(settings.smoothing_steps);'
p35032
aS'        mg_smoother = std::move(smoother);'
p35033
aS'      }'
p35034
aS'    else if (settings.smoother_type == "Jacobi")'
p35035
aS'      {'
p35036
aS'        using Smoother = PreconditionJacobi<SparseMatrix<double>>;'
p35037
aS'        auto smoother ='
p35038
aS'          std::make_unique<MGSmootherPrecondition<SparseMatrix<double>,'
p35039
aS'                                                  Smoother,'
p35040
aS'                                                  Vector<double>>>();'
p35041
aS'        smoother->initialize(mg_matrices,'
p35042
aS'                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :'
p35043
aS'                                                                       0.47));'
p35044
aS'        smoother->set_steps(settings.smoothing_steps);'
p35045
aS'        mg_smoother = std::move(smoother);'
p35046
aS'      }'
p35047
aS'    else if (settings.smoother_type == "block SOR" ||'
p35048
aS'             settings.smoother_type == "block Jacobi")'
p35049
aS'      {'
p35050
aS'        smoother_data.resize(0, triangulation.n_levels() - 1);'
p35051
aS'        for (unsigned int level = 0; level < triangulation.n_levels(); ++level)'
p35052
aS'          {'
p35053
aS'            DoFTools::make_cell_patches(smoother_data[level].block_list,'
p35054
aS'                                        dof_handler,'
p35055
aS'                                        level);'
p35056
aS'            smoother_data[level].relaxation ='
p35057
aS'            smoother_data[level].inversion = PreconditionBlockBase<double>::svd;'
p35058
aS'            std::vector<unsigned int> ordered_indices;'
p35059
aS'            switch (settings.dof_renumbering)'
p35060
aS'              {'
p35061
aS'                case Settings::DoFRenumberingStrategy::downstream:'
p35062
aS'                  ordered_indices ='
p35063
aS'                    create_downstream_cell_ordering(dof_handler,'
p35064
aS'                                                    advection_direction,'
p35065
aS'                                                    level);'
p35066
aS'                  break;'
p35067
aS'                case Settings::DoFRenumberingStrategy::upstream:'
p35068
aS'                  ordered_indices ='
p35069
aS'                    create_downstream_cell_ordering(dof_handler,'
p35070
aS'                                                    -1.0 * advection_direction,'
p35071
aS'                                                    level);'
p35072
aS'                  break;'
p35073
aS'                case Settings::DoFRenumberingStrategy::random:'
p35074
aS'                  ordered_indices ='
p35075
aS'                    create_random_cell_ordering(dof_handler, level);'
p35076
aS'                  break;'
p35077
aS'                case Settings::DoFRenumberingStrategy::none:'
p35078
aS'                  break;'
p35079
aS'                default:'
p35080
aS'                  AssertThrow(false, ExcNotImplemented());'
p35081
aS'                  break;'
p35082
aS'              }'
p35083
aS'            smoother_data[level].order ='
p35084
aS'              std::vector<std::vector<unsigned int>>(1, ordered_indices);'
p35085
aS'          }'
p35086
aS'        if (settings.smoother_type == "block SOR")'
p35087
aS'          {'
p35088
aS'            auto smoother = std::make_unique<MGSmootherPrecondition<'
p35089
aS'              SparseMatrix<double>,'
p35090
aS'              RelaxationBlockSOR<SparseMatrix<double>, double, Vector<double>>,'
p35091
aS'              Vector<double>>>();'
p35092
aS'            smoother->initialize(mg_matrices, smoother_data);'
p35093
aS'            smoother->set_steps(settings.smoothing_steps);'
p35094
aS'            mg_smoother = std::move(smoother);'
p35095
aS'          }'
p35096
aS'        else if (settings.smoother_type == "block Jacobi")'
p35097
aS'          {'
p35098
aS'            auto smoother = std::make_unique<'
p35099
aS'              MGSmootherPrecondition<SparseMatrix<double>,'
p35100
aS'                                     RelaxationBlockJacobi<SparseMatrix<double>,'
p35101
aS'                                                           double,'
p35102
aS'                                                           Vector<double>>,'
p35103
aS'                                     Vector<double>>>();'
p35104
aS'            smoother->initialize(mg_matrices, smoother_data);'
p35105
aS'            smoother->set_steps(settings.smoothing_steps);'
p35106
aS'            mg_smoother = std::move(smoother);'
p35107
aS'          }'
p35108
aS'      }'
p35109
aS'    else'
p35110
aS'      AssertThrow(false, ExcNotImplemented());'
p35111
aS'  }'
p35112
aS'  template <int dim>'
p35113
aS'  void AdvectionProblem<dim>::solve()'
p35114
aS'  {'
p35115
aS'    const unsigned int max_iters       = 200;'
p35116
aS'    const double       solve_tolerance = 1e-8 * system_rhs.l2_norm();'
p35117
aS'    SolverControl      solver_control(max_iters, solve_tolerance, true, true);'
p35118
aS'    solver_control.enable_history_data();'
p35119
aS'    using Transfer = MGTransferPrebuilt<Vector<double>>;'
p35120
aS'    Transfer mg_transfer(mg_constrained_dofs);'
p35121
aS'    mg_transfer.build(dof_handler);'
p35122
aS'    FullMatrix<double> coarse_matrix;'
p35123
aS'    coarse_matrix.copy_from(mg_matrices[0]);'
p35124
aS'    MGCoarseGridHouseholder<double, Vector<double>> coarse_grid_solver;'
p35125
aS'    coarse_grid_solver.initialize(coarse_matrix);'
p35126
aS'    setup_smoother();'
p35127
aS'    mg_matrix.initialize(mg_matrices);'
p35128
aS'    mg_interface_matrix_in.initialize(mg_interface_in);'
p35129
aS'    mg_interface_matrix_out.initialize(mg_interface_out);'
p35130
aS'    Multigrid<Vector<double>> mg('
p35131
aS'      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);'
p35132
aS'    mg.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);'
p35133
aS'    PreconditionMG<dim, Vector<double>, Transfer> preconditioner(dof_handler,'
p35134
aS'                                                                 mg,'
p35135
aS'                                                                 mg_transfer);'
p35136
aS'    std::cout << "     Solving with GMRES to tol " << solve_tolerance << "..."'
p35137
aS'              << std::endl;'
p35138
aS'    SolverGMRES<Vector<double>> solver('
p35139
aS'      solver_control, SolverGMRES<Vector<double>>::AdditionalData(50, true));'
p35140
aS'    Timer time;'
p35141
aS'    time.start();'
p35142
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p35143
aS'    time.stop();'
p35144
aS'    std::cout << "          converged in " << solver_control.last_step()'
p35145
aS'              << " iterations"'
p35146
aS'              << " in " << time.last_wall_time() << " seconds " << std::endl;'
p35147
aS'    constraints.distribute(solution);'
p35148
aS'    mg_smoother.release();'
p35149
aS'  }'
p35150
aS'  template <int dim>'
p35151
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p35152
aS'  {'
p35153
aS'    const unsigned int n_active_cells = triangulation.n_active_cells();'
p35154
aS'    Vector<double>     cell_indices(n_active_cells);'
p35155
aS'    {'
p35156
aS'      std::vector<unsigned int> ordered_indices;'
p35157
aS'      switch (settings.dof_renumbering)'
p35158
aS'        {'
p35159
aS'          case Settings::DoFRenumberingStrategy::downstream:'
p35160
aS'            ordered_indices ='
p35161
aS'              create_downstream_cell_ordering(dof_handler, advection_direction);'
p35162
aS'            break;'
p35163
aS'          case Settings::DoFRenumberingStrategy::upstream:'
p35164
aS'            ordered_indices ='
p35165
aS'              create_downstream_cell_ordering(dof_handler,'
p35166
aS'                                              -1.0 * advection_direction);'
p35167
aS'            break;'
p35168
aS'          case Settings::DoFRenumberingStrategy::random:'
p35169
aS'            ordered_indices = create_random_cell_ordering(dof_handler);'
p35170
aS'            break;'
p35171
aS'          case Settings::DoFRenumberingStrategy::none:'
p35172
aS'            ordered_indices.resize(n_active_cells);'
p35173
aS'            for (unsigned int i = 0; i < n_active_cells; ++i)'
p35174
aS'              ordered_indices[i] = i;'
p35175
aS'            break;'
p35176
aS'          default:'
p35177
aS'            AssertThrow(false, ExcNotImplemented());'
p35178
aS'            break;'
p35179
aS'        }'
p35180
aS'      for (unsigned int i = 0; i < n_active_cells; ++i)'
p35181
aS'        cell_indices(ordered_indices[i]) = static_cast<double>(i);'
p35182
aS'    }'
p35183
aS'    DataOut<dim> data_out;'
p35184
aS'    data_out.attach_dof_handler(dof_handler);'
p35185
aS'    data_out.add_data_vector(solution, "solution");'
p35186
aS'    data_out.add_data_vector(cell_indices, "cell_index");'
p35187
aS'    data_out.build_patches();'
p35188
aS'    const std::string filename ='
p35189
aS'      "solution-" + Utilities::int_to_string(cycle) + ".vtu";'
p35190
aS'    std::ofstream output(filename.c_str());'
p35191
aS'    data_out.write_vtu(output);'
p35192
aS'  }'
p35193
aS'  template <int dim>'
p35194
aS'  void AdvectionProblem<dim>::run()'
p35195
aS'  {'
p35196
aS'    for (unsigned int cycle = 0; cycle < (settings.fe_degree == 1 ? 7 : 5);'
p35197
aS'         ++cycle)'
p35198
aS'      {'
p35199
aS'        std::cout << "  Cycle " << cycle << \':\' << std::endl;'
p35200
aS'        if (cycle == 0)'
p35201
aS'          {'
p35202
aS'            GridGenerator::hyper_cube_with_cylindrical_hole(triangulation,'
p35203
aS'                                                            0.3,'
p35204
aS'                                                            1.0);'
p35205
aS'            const SphericalManifold<dim> manifold_description(Point<dim>(0, 0));'
p35206
aS'            triangulation.set_manifold(1, manifold_description);'
p35207
aS'          }'
p35208
aS'        triangulation.refine_global();'
p35209
aS'        setup_system();'
p35210
aS'        std::cout << "     Number of active cells:       "'
p35211
aS'                  << triangulation.n_active_cells() << " ("'
p35212
aS'                  << triangulation.n_levels() << " levels)" << std::endl;'
p35213
aS'        std::cout << "     Number of degrees of freedom: "'
p35214
aS'                  << dof_handler.n_dofs() << std::endl;'
p35215
aS'        assemble_system_and_multigrid();'
p35216
aS'        solve();'
p35217
aS'        if (settings.output)'
p35218
aS'          output_results(cycle);'
p35219
aS'        std::cout << std::endl;'
p35220
aS'      }'
p35221
aS'  }'
p35222
aS'} // namespace Step63'
p35223
aS'int main(int argc, char *argv[])'
p35224
ag9
aS'  try'
p35225
aS'    {'
p35226
aS'      Step63::Settings settings;'
p35227
aS'      settings.get_parameters((argc > 1) ? (argv[1]) : "");'
p35228
aS'      Step63::AdvectionProblem<2> advection_problem_2d(settings);'
p35229
aS'      advection_problem_2d.run();'
p35230
aS'    }'
p35231
aS'  catch (std::exception &exc)'
p35232
aS'    {'
p35233
aS'      std::cerr << std::endl'
p35234
aS'                << std::endl'
p35235
aS'                << "----------------------------------------------------"'
p35236
aS'                << std::endl;'
p35237
aS'      std::cerr << "Exception on processing: " << std::endl'
p35238
aS'                << exc.what() << std::endl'
p35239
aS'                << "Aborting!" << std::endl'
p35240
aS'                << "----------------------------------------------------"'
p35241
aS'                << std::endl;'
p35242
aS'      return 1;'
p35243
aS'    }'
p35244
aS'  catch (...)'
p35245
aS'    {'
p35246
aS'      std::cerr << std::endl'
p35247
aS'                << std::endl'
p35248
aS'                << "----------------------------------------------------"'
p35249
aS'                << std::endl;'
p35250
aS'      std::cerr << "Unknown exception!" << std::endl'
p35251
aS'                << "Aborting!" << std::endl'
p35252
aS'                << "----------------------------------------------------"'
p35253
aS'                << std::endl;'
p35254
aS'      return 1;'
p35255
aS'    }'
p35256
aS'  return 0;'
p35257
ag17
aS'#include <deal.II/base/timer.h>'
p35258
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p35259
aS'#include <deal.II/lac/precondition.h>'
p35260
aS'#include <deal.II/lac/solver_cg.h>'
p35261
aS'#include <deal.II/lac/sparse_matrix.h>'
p35262
aS'#include <deal.II/lac/vector.h>'
p35263
aS'#include <deal.II/grid/tria.h>'
p35264
aS'#include <deal.II/grid/grid_generator.h>'
p35265
aS'#include <deal.II/grid/grid_refinement.h>'
p35266
aS'#include <deal.II/grid/manifold_lib.h>'
p35267
aS'#include <deal.II/fe/fe_q.h>'
p35268
aS'#include <deal.II/fe/fe_values.h>'
p35269
aS'#include <deal.II/fe/mapping_q_generic.h>'
p35270
aS'#include <deal.II/dofs/dof_handler.h>'
p35271
aS'#include <deal.II/dofs/dof_tools.h>'
p35272
aS'#include <deal.II/numerics/data_out.h>'
p35273
aS'#include <deal.II/numerics/error_estimator.h>'
p35274
aS'#include <deal.II/numerics/vector_tools.h>'
p35275
aS'#include <fstream>'
p35276
aS'#include <deal.II/fe/mapping_q_cache.h>'
p35277
aS'namespace Step65'
p35278
ag9
aS'  using namespace dealii;'
p35279
aS'  template <int dim>'
p35280
aS'  class ExactSolution : public Function<dim>'
p35281
aS'  {'
p35282
aS'  public:'
p35283
aS'    virtual double value(const Point<dim> &p,'
p35284
aS'                         const unsigned int /*component*/ = 0) const override'
p35285
aS'    {'
p35286
aS'      if (p.norm_square() < 0.25)'
p35287
aS'        return p.norm_square();'
p35288
aS'      else'
p35289
aS'        return 0.1 * p.norm_square() + (0.25 - 0.025);'
p35290
aS'    }'
p35291
aS'    virtual Tensor<1, dim>'
p35292
aS'    gradient(const Point<dim> &p,'
p35293
aS'             const unsigned int /*component*/ = 0) const override'
p35294
aS'    {'
p35295
aS'      if (p.norm_square() < 0.25)'
p35296
aS'        return 2. * p;'
p35297
aS'      else'
p35298
aS'        return 0.2 * p;'
p35299
aS'    }'
p35300
aS'  };'
p35301
aS'  template <int dim>'
p35302
aS'  double coefficient(const Point<dim> &p)'
p35303
aS'  {'
p35304
aS'    if (p.norm_square() < 0.25)'
p35305
aS'      return 0.5;'
p35306
aS'    else'
p35307
aS'      return 5.0;'
p35308
aS'  }'
p35309
aS'  template <int dim>'
p35310
aS'  class PoissonProblem'
p35311
aS'  {'
p35312
aS'  public:'
p35313
aS'    PoissonProblem();'
p35314
aS'    void run();'
p35315
aS'  private:'
p35316
aS'    void create_grid();'
p35317
aS'    void setup_system(const Mapping<dim> &mapping);'
p35318
aS'    void assemble_system(const Mapping<dim> &mapping);'
p35319
aS'    void solve();'
p35320
aS'    void postprocess(const Mapping<dim> &mapping);'
p35321
aS'    Triangulation<dim> triangulation;'
p35322
aS'    FE_Q<dim>          fe;'
p35323
aS'    DoFHandler<dim>    dof_handler;'
p35324
aS'    AffineConstraints<double> constraints;'
p35325
aS'    SparsityPattern           sparsity_pattern;'
p35326
aS'    SparseMatrix<double>      system_matrix;'
p35327
aS'    Vector<double>            solution;'
p35328
aS'    Vector<double>            system_rhs;'
p35329
aS'    TimerOutput timer;'
p35330
aS'  };'
p35331
aS'  template <int dim>'
p35332
aS'  PoissonProblem<dim>::PoissonProblem()'
p35333
aS'    : fe(3)'
p35334
aS'    , dof_handler(triangulation)'
p35335
aS'    , timer(std::cout, TimerOutput::never, TimerOutput::wall_times)'
p35336
aS'  {}'
p35337
aS'  template <int dim>'
p35338
aS'  void PoissonProblem<dim>::create_grid()'
p35339
aS'  {'
p35340
aS'    Triangulation<dim> tria_inner;'
p35341
aS'    GridGenerator::hyper_ball(tria_inner, Point<dim>(), 0.5);'
p35342
aS'    Triangulation<dim> tria_outer;'
p35343
aS'    GridGenerator::hyper_shell('
p35344
aS'      tria_outer, Point<dim>(), 0.5, std::sqrt(dim), 2 * dim);'
p35345
aS'    GridGenerator::merge_triangulations(tria_inner, tria_outer, triangulation);'
p35346
aS'    triangulation.reset_all_manifolds();'
p35347
aS'    triangulation.set_all_manifold_ids(0);'
p35348
aS'    for (const auto &cell : triangulation.cell_iterators())'
p35349
aS'      {'
p35350
aS'        for (const auto &face : cell->face_iterators())'
p35351
aS'          {'
p35352
aS'            bool face_at_sphere_boundary = true;'
p35353
aS'            for (const auto v : face->vertex_indices())'
p35354
aS'              {'
p35355
aS'                if (std::abs(face->vertex(v).norm_square() - 0.25) > 1e-12)'
p35356
aS'                  face_at_sphere_boundary = false;'
p35357
aS'              }'
p35358
aS'            if (face_at_sphere_boundary)'
p35359
aS'              face->set_all_manifold_ids(1);'
p35360
aS'          }'
p35361
aS'        if (cell->center().norm_square() < 0.25)'
p35362
aS'          cell->set_material_id(1);'
p35363
aS'        else'
p35364
aS'          cell->set_material_id(0);'
p35365
aS'      }'
p35366
aS'    triangulation.set_manifold(1, SphericalManifold<dim>());'
p35367
aS'    TransfiniteInterpolationManifold<dim> transfinite_manifold;'
p35368
aS'    transfinite_manifold.initialize(triangulation);'
p35369
aS'    triangulation.set_manifold(0, transfinite_manifold);'
p35370
aS'    triangulation.refine_global(9 - 2 * dim);'
p35371
aS'  }'
p35372
aS'  template <int dim>'
p35373
aS'  void PoissonProblem<dim>::setup_system(const Mapping<dim> &mapping)'
p35374
aS'  {'
p35375
aS'    dof_handler.distribute_dofs(fe);'
p35376
aS'    std::cout << "   Number of active cells:       "'
p35377
aS'              << triangulation.n_global_active_cells() << std::endl;'
p35378
aS'    std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p35379
aS'              << std::endl;'
p35380
aS'    {'
p35381
aS'      TimerOutput::Scope scope(timer, "Compute constraints");'
p35382
aS'      constraints.clear();'
p35383
aS'      DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p35384
aS'      VectorTools::interpolate_boundary_values('
p35385
aS'        mapping, dof_handler, 0, ExactSolution<dim>(), constraints);'
p35386
aS'      constraints.close();'
p35387
aS'    }'
p35388
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p35389
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false);'
p35390
aS'    sparsity_pattern.copy_from(dsp);'
p35391
aS'    system_matrix.reinit(sparsity_pattern);'
p35392
aS'    solution.reinit(dof_handler.n_dofs());'
p35393
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p35394
aS'  }'
p35395
aS'  template <int dim>'
p35396
aS'  void PoissonProblem<dim>::assemble_system(const Mapping<dim> &mapping)'
p35397
aS'  {'
p35398
aS'    TimerOutput::Scope scope(timer, "Assemble linear system");'
p35399
aS'    const QGauss<dim> quadrature_formula(fe.degree + 2);'
p35400
aS'    FEValues<dim>     fe_values(mapping,'
p35401
aS'                            fe,'
p35402
aS'                            quadrature_formula,'
p35403
aS'                            update_values | update_gradients |'
p35404
aS'                              update_quadrature_points | update_JxW_values);'
p35405
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p35406
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p35407
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p35408
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p35409
aS'    FullMatrix<double> partial_matrix(dofs_per_cell, dim * n_q_points);'
p35410
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p35411
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p35412
aS'      {'
p35413
aS'        cell_rhs = 0.;'
p35414
aS'        fe_values.reinit(cell);'
p35415
aS'        for (unsigned int q_index = 0; q_index < n_q_points; ++q_index)'
p35416
aS'          {'
p35417
aS'            const double current_coefficient ='
p35418
aS'              coefficient(fe_values.quadrature_point(q_index));'
p35419
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p35420
aS'              {'
p35421
aS'                for (unsigned int d = 0; d < dim; ++d)'
p35422
aS'                  partial_matrix(i, q_index * dim + d) ='
p35423
aS'                    std::sqrt(fe_values.JxW(q_index) * current_coefficient) *'
p35424
aS'                    fe_values.shape_grad(i, q_index)[d];'
p35425
aS'                cell_rhs(i) +='
p35426
aS'                   fe_values.JxW(q_index));            // dx'
p35427
aS'              }'
p35428
aS'          }'
p35429
aS'        partial_matrix.mTmult(cell_matrix, partial_matrix);'
p35430
aS'        cell->get_dof_indices(local_dof_indices);'
p35431
aS'        constraints.distribute_local_to_global('
p35432
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p35433
aS'      }'
p35434
aS'  }'
p35435
aS'  template <int dim>'
p35436
aS'  void PoissonProblem<dim>::solve()'
p35437
aS'  {'
p35438
aS'    TimerOutput::Scope scope(timer, "Solve linear system");'
p35439
aS'    SolverControl            solver_control(1000, 1e-12);'
p35440
aS'    SolverCG<Vector<double>> solver(solver_control);'
p35441
aS'    PreconditionJacobi<SparseMatrix<double>> preconditioner;'
p35442
aS'    preconditioner.initialize(system_matrix);'
p35443
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p35444
aS'    constraints.distribute(solution);'
p35445
aS'    std::cout << "   Number of solver iterations:  "'
p35446
aS'              << solver_control.last_step() << std::endl;'
p35447
aS'  }'
p35448
aS'  template <int dim>'
p35449
aS'  void PoissonProblem<dim>::postprocess(const Mapping<dim> &mapping)'
p35450
aS'  {'
p35451
aS'    {'
p35452
aS'      TimerOutput::Scope scope(timer, "Write output");'
p35453
aS'      DataOut<dim> data_out;'
p35454
aS'      DataOutBase::VtkFlags flags;'
p35455
aS'      flags.write_higher_order_cells = true;'
p35456
aS'      data_out.set_flags(flags);'
p35457
aS'      data_out.attach_dof_handler(dof_handler);'
p35458
aS'      data_out.add_data_vector(solution, "solution");'
p35459
aS'      Vector<double> material_ids(triangulation.n_active_cells());'
p35460
aS'      for (const auto &cell : triangulation.active_cell_iterators())'
p35461
aS'        material_ids[cell->active_cell_index()] = cell->material_id();'
p35462
aS'      data_out.add_data_vector(material_ids, "material_ids");'
p35463
aS'      data_out.build_patches(mapping,'
p35464
aS'                             fe.degree,'
p35465
aS'                             DataOut<dim>::curved_inner_cells);'
p35466
aS'      std::ofstream file('
p35467
aS'         std::to_string(triangulation.n_global_levels() - 10 + 2 * dim) +'
p35468
aS'         ".vtu")'
p35469
aS'          .c_str());'
p35470
aS'      data_out.write_vtu(file);'
p35471
aS'    }'
p35472
aS'    {'
p35473
aS'      TimerOutput::Scope scope(timer, "Compute error norms");'
p35474
aS'      Vector<double> norm_per_cell_p(triangulation.n_active_cells());'
p35475
aS'      VectorTools::integrate_difference(mapping,'
p35476
aS'                                        dof_handler,'
p35477
aS'                                        solution,'
p35478
aS'                                        ExactSolution<dim>(),'
p35479
aS'                                        norm_per_cell_p,'
p35480
aS'                                        QGauss<dim>(fe.degree + 2),'
p35481
aS'                                        VectorTools::L2_norm);'
p35482
aS'      std::cout << "   L2 error vs exact solution:   "'
p35483
aS'                << norm_per_cell_p.l2_norm() << std::endl;'
p35484
aS'      VectorTools::integrate_difference(mapping,'
p35485
aS'                                        dof_handler,'
p35486
aS'                                        solution,'
p35487
aS'                                        ExactSolution<dim>(),'
p35488
aS'                                        norm_per_cell_p,'
p35489
aS'                                        QGauss<dim>(fe.degree + 2),'
p35490
aS'                                        VectorTools::H1_norm);'
p35491
aS'      std::cout << "   H1 error vs exact solution:   "'
p35492
aS'                << norm_per_cell_p.l2_norm() << std::endl;'
p35493
aS'    }'
p35494
aS'    {'
p35495
aS'      TimerOutput::Scope scope(timer, "Compute error estimator");'
p35496
aS'      Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p35497
aS'      KellyErrorEstimator<dim>::estimate('
p35498
aS'        mapping,'
p35499
aS'        dof_handler,'
p35500
aS'        QGauss<dim - 1>(fe.degree + 1),'
p35501
aS'        std::map<types::boundary_id, const Function<dim> *>(),'
p35502
aS'        solution,'
p35503
aS'        estimated_error_per_cell);'
p35504
aS'      std::cout << "   Max cell-wise error estimate: "'
p35505
aS'                << estimated_error_per_cell.linfty_norm() << std::endl;'
p35506
aS'    }'
p35507
aS'  }'
p35508
aS'  template <int dim>'
p35509
aS'  void PoissonProblem<dim>::run()'
p35510
aS'  {'
p35511
aS'    create_grid();'
p35512
aS'    {'
p35513
aS'      std::cout << std::endl'
p35514
aS'                << "====== Running with the basic MappingQGeneric class ====== "'
p35515
aS'                << std::endl'
p35516
aS'                << std::endl;'
p35517
aS'      MappingQGeneric<dim> mapping(fe.degree + 1);'
p35518
aS'      setup_system(mapping);'
p35519
aS'      assemble_system(mapping);'
p35520
aS'      solve();'
p35521
aS'      postprocess(mapping);'
p35522
aS'      timer.print_summary();'
p35523
aS'      timer.reset();'
p35524
aS'    }'
p35525
aS'    {'
p35526
aS'      std::cout'
p35527
aS'        << "====== Running with the optimized MappingQCache class ====== "'
p35528
aS'        << std::endl'
p35529
aS'        << std::endl;'
p35530
aS'      MappingQCache<dim> mapping(fe.degree + 1);'
p35531
aS'      {'
p35532
aS'        TimerOutput::Scope scope(timer, "Initialize mapping cache");'
p35533
aS'        mapping.initialize(MappingQGeneric<dim>(fe.degree + 1), triangulation);'
p35534
aS'      }'
p35535
aS'      std::cout << "   Memory consumption cache:     "'
p35536
aS'                << 1e-6 * mapping.memory_consumption() << " MB" << std::endl;'
p35537
aS'      setup_system(mapping);'
p35538
aS'      assemble_system(mapping);'
p35539
aS'      solve();'
p35540
aS'      postprocess(mapping);'
p35541
aS'      timer.print_summary();'
p35542
aS'    }'
p35543
aS'  }'
p35544
aS'} // namespace Step65'
p35545
aS'int main()'
p35546
ag9
aS'  Step65::PoissonProblem<3> test_program;'
p35547
aS'  test_program.run();'
p35548
aS'  return 0;'
p35549
ag17
aS'#include <deal.II/base/function.h>'
p35550
aS'#include <deal.II/base/quadrature_lib.h>'
p35551
aS'#include <deal.II/base/timer.h>'
p35552
aS'#include <deal.II/base/vectorization.h>'
p35553
aS'#include <deal.II/dofs/dof_accessor.h>'
p35554
aS'#include <deal.II/dofs/dof_handler.h>'
p35555
aS'#include <deal.II/dofs/dof_tools.h>'
p35556
aS'#include <deal.II/fe/fe_q.h>'
p35557
aS'#include <deal.II/fe/mapping_q_generic.h>'
p35558
aS'#include <deal.II/grid/grid_generator.h>'
p35559
aS'#include <deal.II/grid/grid_out.h>'
p35560
aS'#include <deal.II/grid/manifold_lib.h>'
p35561
aS'#include <deal.II/grid/tria.h>'
p35562
aS'#include <deal.II/grid/tria_accessor.h>'
p35563
aS'#include <deal.II/grid/tria_iterator.h>'
p35564
aS'#include <deal.II/lac/affine_constraints.h>'
p35565
aS'#include <deal.II/lac/precondition.h>'
p35566
aS'#include <deal.II/lac/solver_cg.h>'
p35567
aS'#include <deal.II/lac/vector.h>'
p35568
aS'#include <deal.II/numerics/data_out.h>'
p35569
aS'#include <deal.II/numerics/vector_tools.h>'
p35570
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p35571
aS'#include <deal.II/matrix_free/matrix_free.h>'
p35572
aS'#include <deal.II/matrix_free/operators.h>'
p35573
aS'#include <deal.II/matrix_free/tools.h>'
p35574
aS'#include <deal.II/multigrid/mg_coarse.h>'
p35575
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p35576
aS'#include <deal.II/multigrid/mg_matrix.h>'
p35577
aS'#include <deal.II/multigrid/mg_smoother.h>'
p35578
aS'#include <deal.II/multigrid/mg_tools.h>'
p35579
aS'#include <deal.II/multigrid/mg_transfer_matrix_free.h>'
p35580
aS'#include <deal.II/multigrid/multigrid.h>'
p35581
aS'#include <fstream>'
p35582
aS'#include <iostream>'
p35583
aS'namespace Step66'
p35584
ag9
aS'  using namespace dealii;'
p35585
aS'  template <int dim, int fe_degree, typename number>'
p35586
aS'  class JacobianOperator'
p35587
aS'    : public MatrixFreeOperators::'
p35588
aS'        Base<dim, LinearAlgebra::distributed::Vector<number>>'
p35589
aS'  {'
p35590
aS'  public:'
p35591
aS'    using value_type = number;'
p35592
aS'    using FECellIntegrator ='
p35593
aS'      FEEvaluation<dim, fe_degree, fe_degree + 1, 1, number>;'
p35594
aS'    JacobianOperator();'
p35595
aS'    virtual void clear() override;'
p35596
aS'    void evaluate_newton_step('
p35597
aS'      const LinearAlgebra::distributed::Vector<number> &newton_step);'
p35598
aS'    virtual void compute_diagonal() override;'
p35599
aS'  private:'
p35600
aS'    virtual void apply_add('
p35601
aS'      LinearAlgebra::distributed::Vector<number> &      dst,'
p35602
aS'      const LinearAlgebra::distributed::Vector<number> &src) const override;'
p35603
aS'    void'
p35604
aS'    local_apply(const MatrixFree<dim, number> &                   data,'
p35605
aS'                LinearAlgebra::distributed::Vector<number> &      dst,'
p35606
aS'                const LinearAlgebra::distributed::Vector<number> &src,'
p35607
aS'                const std::pair<unsigned int, unsigned int> &cell_range) const;'
p35608
aS'    void local_compute_diagonal(FECellIntegrator &integrator) const;'
p35609
aS'    Table<2, VectorizedArray<number>> nonlinear_values;'
p35610
aS'  };'
p35611
aS'  template <int dim, int fe_degree, typename number>'
p35612
aS'  JacobianOperator<dim, fe_degree, number>::JacobianOperator()'
p35613
aS'    : MatrixFreeOperators::Base<dim,'
p35614
aS'                                LinearAlgebra::distributed::Vector<number>>()'
p35615
aS'  {}'
p35616
aS'  template <int dim, int fe_degree, typename number>'
p35617
aS'  void JacobianOperator<dim, fe_degree, number>::clear()'
p35618
aS'  {'
p35619
aS'    nonlinear_values.reinit(0, 0);'
p35620
aS'    MatrixFreeOperators::Base<dim, LinearAlgebra::distributed::Vector<number>>::'
p35621
aS'      clear();'
p35622
aS'  }'
p35623
aS'  template <int dim, int fe_degree, typename number>'
p35624
aS'  void JacobianOperator<dim, fe_degree, number>::evaluate_newton_step('
p35625
aS'    const LinearAlgebra::distributed::Vector<number> &newton_step)'
p35626
aS'  {'
p35627
aS'    const unsigned int n_cells = this->data->n_cell_batches();'
p35628
aS'    FECellIntegrator   phi(*this->data);'
p35629
aS'    nonlinear_values.reinit(n_cells, phi.n_q_points);'
p35630
aS'    for (unsigned int cell = 0; cell < n_cells; ++cell)'
p35631
aS'      {'
p35632
aS'        phi.reinit(cell);'
p35633
aS'        phi.read_dof_values_plain(newton_step);'
p35634
aS'        phi.evaluate(EvaluationFlags::values);'
p35635
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p35636
aS'          {'
p35637
aS'            nonlinear_values(cell, q) = std::exp(phi.get_value(q));'
p35638
aS'          }'
p35639
aS'      }'
p35640
aS'  }'
p35641
aS'  template <int dim, int fe_degree, typename number>'
p35642
aS'  void JacobianOperator<dim, fe_degree, number>::local_apply('
p35643
aS'    const MatrixFree<dim, number> &                   data,'
p35644
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p35645
aS'    const LinearAlgebra::distributed::Vector<number> &src,'
p35646
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p35647
aS'  {'
p35648
aS'    FECellIntegrator phi(data);'
p35649
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p35650
aS'      {'
p35651
aS'        AssertDimension(nonlinear_values.size(0),'
p35652
aS'                        phi.get_matrix_free().n_cell_batches());'
p35653
aS'        AssertDimension(nonlinear_values.size(1), phi.n_q_points);'
p35654
aS'        phi.reinit(cell);'
p35655
aS'        phi.gather_evaluate(src,'
p35656
aS'                            EvaluationFlags::values |'
p35657
aS'                              EvaluationFlags::gradients);'
p35658
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p35659
aS'          {'
p35660
aS'            phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);'
p35661
aS'            phi.submit_gradient(phi.get_gradient(q), q);'
p35662
aS'          }'
p35663
aS'        phi.integrate_scatter(EvaluationFlags::values |'
p35664
aS'                                EvaluationFlags::gradients,'
p35665
aS'                              dst);'
p35666
aS'      }'
p35667
aS'  }'
p35668
aS'  template <int dim, int fe_degree, typename number>'
p35669
aS'  void JacobianOperator<dim, fe_degree, number>::apply_add('
p35670
aS'    LinearAlgebra::distributed::Vector<number> &      dst,'
p35671
aS'    const LinearAlgebra::distributed::Vector<number> &src) const'
p35672
aS'  {'
p35673
aS'    this->data->cell_loop(&JacobianOperator::local_apply, this, dst, src);'
p35674
aS'  }'
p35675
aS'  template <int dim, int fe_degree, typename number>'
p35676
aS'  void JacobianOperator<dim, fe_degree, number>::local_compute_diagonal('
p35677
aS'    FECellIntegrator &phi) const'
p35678
aS'  {'
p35679
aS'    AssertDimension(nonlinear_values.size(0),'
p35680
aS'                    phi.get_matrix_free().n_cell_batches());'
p35681
aS'    AssertDimension(nonlinear_values.size(1), phi.n_q_points);'
p35682
aS'    const unsigned int cell = phi.get_current_cell_index();'
p35683
aS'    phi.evaluate(EvaluationFlags::values | EvaluationFlags::gradients);'
p35684
aS'    for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p35685
aS'      {'
p35686
aS'        phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);'
p35687
aS'        phi.submit_gradient(phi.get_gradient(q), q);'
p35688
aS'      }'
p35689
aS'    phi.integrate(EvaluationFlags::values | EvaluationFlags::gradients);'
p35690
aS'  }'
p35691
aS'  template <int dim, int fe_degree, typename number>'
p35692
aS'  void JacobianOperator<dim, fe_degree, number>::compute_diagonal()'
p35693
aS'  {'
p35694
aS'    this->inverse_diagonal_entries.reset('
p35695
aS'      new DiagonalMatrix<LinearAlgebra::distributed::Vector<number>>());'
p35696
aS'    LinearAlgebra::distributed::Vector<number> &inverse_diagonal ='
p35697
aS'      this->inverse_diagonal_entries->get_vector();'
p35698
aS'    this->data->initialize_dof_vector(inverse_diagonal);'
p35699
aS'    MatrixFreeTools::compute_diagonal(*this->data,'
p35700
aS'                                      inverse_diagonal,'
p35701
aS'                                      &JacobianOperator::local_compute_diagonal,'
p35702
aS'                                      this);'
p35703
aS'    for (auto &diagonal_element : inverse_diagonal)'
p35704
aS'      {'
p35705
aS'        diagonal_element = (std::abs(diagonal_element) > 1.0e-10) ?'
p35706
aS'                             1.0;'
p35707
aS'      }'
p35708
aS'  }'
p35709
aS'  template <int dim, int fe_degree>'
p35710
aS'  class GelfandProblem'
p35711
aS'  {'
p35712
aS'  public:'
p35713
aS'    GelfandProblem();'
p35714
aS'    void run();'
p35715
aS'  private:'
p35716
aS'    void make_grid();'
p35717
aS'    void setup_system();'
p35718
aS'    void evaluate_residual('
p35719
aS'      LinearAlgebra::distributed::Vector<double> &      dst,'
p35720
aS'      const LinearAlgebra::distributed::Vector<double> &src) const;'
p35721
aS'    void local_evaluate_residual('
p35722
aS'      const MatrixFree<dim, double> &                   data,'
p35723
aS'      LinearAlgebra::distributed::Vector<double> &      dst,'
p35724
aS'      const LinearAlgebra::distributed::Vector<double> &src,'
p35725
aS'      const std::pair<unsigned int, unsigned int> &     cell_range) const;'
p35726
aS'    void assemble_rhs();'
p35727
aS'    double compute_residual(const double alpha);'
p35728
aS'    void compute_update();'
p35729
aS'    void solve();'
p35730
aS'    double compute_solution_norm() const;'
p35731
aS'    void output_results(const unsigned int cycle) const;'
p35732
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p35733
aS'    const MappingQGeneric<dim>                mapping;'
p35734
aS'    FE_Q<dim>       fe;'
p35735
aS'    DoFHandler<dim> dof_handler;'
p35736
aS'    AffineConstraints<double> constraints;'
p35737
aS'    using SystemMatrixType = JacobianOperator<dim, fe_degree, double>;'
p35738
aS'    SystemMatrixType system_matrix;'
p35739
aS'    MGConstrainedDoFs mg_constrained_dofs;'
p35740
aS'    using LevelMatrixType = JacobianOperator<dim, fe_degree, float>;'
p35741
aS'    MGLevelObject<LevelMatrixType>                           mg_matrices;'
p35742
aS'    MGLevelObject<LinearAlgebra::distributed::Vector<float>> mg_solution;'
p35743
aS'    MGTransferMatrixFree<dim, float>                         mg_transfer;'
p35744
aS'    LinearAlgebra::distributed::Vector<double> solution;'
p35745
aS'    LinearAlgebra::distributed::Vector<double> newton_update;'
p35746
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p35747
aS'    unsigned int linear_iterations;'
p35748
aS'    ConditionalOStream pcout;'
p35749
aS'    TimerOutput computing_timer;'
p35750
aS'  };'
p35751
aS'  template <int dim, int fe_degree>'
p35752
aS'  GelfandProblem<dim, fe_degree>::GelfandProblem()'
p35753
aS'    : triangulation(MPI_COMM_WORLD,'
p35754
aS'                    Triangulation<dim>::limit_level_difference_at_vertices,'
p35755
aS'                    parallel::distributed::Triangulation<'
p35756
aS'                      dim>::construct_multigrid_hierarchy)'
p35757
aS'    , mapping(fe_degree)'
p35758
aS'    , fe(fe_degree)'
p35759
aS'    , dof_handler(triangulation)'
p35760
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p35761
aS'    , computing_timer(MPI_COMM_WORLD,'
p35762
aS'                      pcout,'
p35763
aS'                      TimerOutput::never,'
p35764
aS'                      TimerOutput::wall_times)'
p35765
aS'  {}'
p35766
aS'  template <int dim, int fe_degree>'
p35767
aS'  void GelfandProblem<dim, fe_degree>::make_grid()'
p35768
aS'  {'
p35769
aS'    TimerOutput::Scope t(computing_timer, "make grid");'
p35770
aS'    SphericalManifold<dim>                boundary_manifold;'
p35771
aS'    TransfiniteInterpolationManifold<dim> inner_manifold;'
p35772
aS'    GridGenerator::hyper_ball(triangulation);'
p35773
aS'    triangulation.set_all_manifold_ids(1);'
p35774
aS'    triangulation.set_all_manifold_ids_on_boundary(0);'
p35775
aS'    triangulation.set_manifold(0, boundary_manifold);'
p35776
aS'    inner_manifold.initialize(triangulation);'
p35777
aS'    triangulation.set_manifold(1, inner_manifold);'
p35778
aS'    triangulation.refine_global(3 - dim);'
p35779
aS'  }'
p35780
aS'  template <int dim, int fe_degree>'
p35781
aS'  void GelfandProblem<dim, fe_degree>::setup_system()'
p35782
aS'  {'
p35783
aS'    TimerOutput::Scope t(computing_timer, "setup system");'
p35784
aS'    system_matrix.clear();'
p35785
aS'    mg_matrices.clear_elements();'
p35786
aS'    dof_handler.distribute_dofs(fe);'
p35787
aS'    dof_handler.distribute_mg_dofs();'
p35788
aS'    IndexSet locally_relevant_dofs;'
p35789
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p35790
aS'    constraints.clear();'
p35791
aS'    constraints.reinit(locally_relevant_dofs);'
p35792
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p35793
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p35794
aS'                                             0,'
p35795
aS'                                             Functions::ZeroFunction<dim>(),'
p35796
aS'                                             constraints);'
p35797
aS'    constraints.close();'
p35798
aS'    {'
p35799
aS'      typename MatrixFree<dim, double>::AdditionalData additional_data;'
p35800
aS'      additional_data.tasks_parallel_scheme ='
p35801
aS'        MatrixFree<dim, double>::AdditionalData::partition_color;'
p35802
aS'      additional_data.mapping_update_flags ='
p35803
aS'         update_quadrature_points);'
p35804
aS'      auto system_mf_storage = std::make_shared<MatrixFree<dim, double>>();'
p35805
aS'      system_mf_storage->reinit(mapping,'
p35806
aS'                                dof_handler,'
p35807
aS'                                constraints,'
p35808
aS'                                QGauss<1>(fe.degree + 1),'
p35809
aS'                                additional_data);'
p35810
aS'      system_matrix.initialize(system_mf_storage);'
p35811
aS'    }'
p35812
aS'    system_matrix.initialize_dof_vector(solution);'
p35813
aS'    system_matrix.initialize_dof_vector(newton_update);'
p35814
aS'    system_matrix.initialize_dof_vector(system_rhs);'
p35815
aS'    const unsigned int nlevels = triangulation.n_global_levels();'
p35816
aS'    mg_matrices.resize(0, nlevels - 1);'
p35817
aS'    mg_solution.resize(0, nlevels - 1);'
p35818
aS'    std::set<types::boundary_id> dirichlet_boundary;'
p35819
aS'    dirichlet_boundary.insert(0);'
p35820
aS'    mg_constrained_dofs.initialize(dof_handler);'
p35821
aS'    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,'
p35822
aS'                                                       dirichlet_boundary);'
p35823
aS'    mg_transfer.initialize_constraints(mg_constrained_dofs);'
p35824
aS'    mg_transfer.build(dof_handler);'
p35825
aS'    for (unsigned int level = 0; level < nlevels; ++level)'
p35826
aS'      {'
p35827
aS'        IndexSet relevant_dofs;'
p35828
aS'        DoFTools::extract_locally_relevant_level_dofs(dof_handler,'
p35829
aS'                                                      level,'
p35830
aS'                                                      relevant_dofs);'
p35831
aS'        AffineConstraints<double> level_constraints;'
p35832
aS'        level_constraints.reinit(relevant_dofs);'
p35833
aS'        level_constraints.add_lines('
p35834
aS'          mg_constrained_dofs.get_boundary_indices(level));'
p35835
aS'        level_constraints.close();'
p35836
aS'        typename MatrixFree<dim, float>::AdditionalData additional_data;'
p35837
aS'        additional_data.tasks_parallel_scheme ='
p35838
aS'          MatrixFree<dim, float>::AdditionalData::partition_color;'
p35839
aS'        additional_data.mapping_update_flags ='
p35840
aS'           update_quadrature_points);'
p35841
aS'        additional_data.mg_level = level;'
p35842
aS'        auto mg_mf_storage_level = std::make_shared<MatrixFree<dim, float>>();'
p35843
aS'        mg_mf_storage_level->reinit(mapping,'
p35844
aS'                                    dof_handler,'
p35845
aS'                                    level_constraints,'
p35846
aS'                                    QGauss<1>(fe.degree + 1),'
p35847
aS'                                    additional_data);'
p35848
aS'        mg_matrices[level].initialize(mg_mf_storage_level,'
p35849
aS'                                      mg_constrained_dofs,'
p35850
aS'                                      level);'
p35851
aS'        mg_matrices[level].initialize_dof_vector(mg_solution[level]);'
p35852
aS'      }'
p35853
aS'  }'
p35854
aS'  template <int dim, int fe_degree>'
p35855
aS'  void GelfandProblem<dim, fe_degree>::evaluate_residual('
p35856
aS'    LinearAlgebra::distributed::Vector<double> &      dst,'
p35857
aS'    const LinearAlgebra::distributed::Vector<double> &src) const'
p35858
aS'  {'
p35859
aS'    auto matrix_free = system_matrix.get_matrix_free();'
p35860
aS'    matrix_free->cell_loop('
p35861
aS'      &GelfandProblem::local_evaluate_residual, this, dst, src, true);'
p35862
aS'  }'
p35863
aS'  template <int dim, int fe_degree>'
p35864
aS'  void GelfandProblem<dim, fe_degree>::local_evaluate_residual('
p35865
aS'    const MatrixFree<dim, double> &                   data,'
p35866
aS'    LinearAlgebra::distributed::Vector<double> &      dst,'
p35867
aS'    const LinearAlgebra::distributed::Vector<double> &src,'
p35868
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p35869
aS'  {'
p35870
aS'    FEEvaluation<dim, fe_degree, fe_degree + 1, 1, double> phi(data);'
p35871
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p35872
aS'      {'
p35873
aS'        phi.reinit(cell);'
p35874
aS'        phi.read_dof_values_plain(src);'
p35875
aS'        phi.evaluate(EvaluationFlags::values | EvaluationFlags::gradients);'
p35876
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p35877
aS'          {'
p35878
aS'            phi.submit_value(-std::exp(phi.get_value(q)), q);'
p35879
aS'            phi.submit_gradient(phi.get_gradient(q), q);'
p35880
aS'          }'
p35881
aS'        phi.integrate_scatter(EvaluationFlags::values |'
p35882
aS'                                EvaluationFlags::gradients,'
p35883
aS'                              dst);'
p35884
aS'      }'
p35885
aS'  }'
p35886
aS'  template <int dim, int fe_degree>'
p35887
aS'  void GelfandProblem<dim, fe_degree>::assemble_rhs()'
p35888
aS'  {'
p35889
aS'    TimerOutput::Scope t(computing_timer, "assemble right hand side");'
p35890
aS'    evaluate_residual(system_rhs, solution);'
p35891
aS'    system_rhs *= -1.0;'
p35892
aS'  }'
p35893
aS'  template <int dim, int fe_degree>'
p35894
aS'  double GelfandProblem<dim, fe_degree>::compute_residual(const double alpha)'
p35895
aS'  {'
p35896
aS'    TimerOutput::Scope t(computing_timer, "compute residual");'
p35897
aS'    LinearAlgebra::distributed::Vector<double> residual;'
p35898
aS'    LinearAlgebra::distributed::Vector<double> evaluation_point;'
p35899
aS'    system_matrix.initialize_dof_vector(residual);'
p35900
aS'    system_matrix.initialize_dof_vector(evaluation_point);'
p35901
aS'    evaluation_point = solution;'
p35902
aS'    if (alpha > 1e-12)'
p35903
aS'      {'
p35904
aS'        evaluation_point.add(alpha, newton_update);'
p35905
aS'      }'
p35906
aS'    evaluate_residual(residual, evaluation_point);'
p35907
aS'    return residual.l2_norm();'
p35908
aS'  }'
p35909
aS'  template <int dim, int fe_degree>'
p35910
aS'  void GelfandProblem<dim, fe_degree>::compute_update()'
p35911
aS'  {'
p35912
aS'    TimerOutput::Scope t(computing_timer, "compute update");'
p35913
aS'    solution.update_ghost_values();'
p35914
aS'    system_matrix.evaluate_newton_step(solution);'
p35915
aS'    mg_transfer.interpolate_to_mg(dof_handler, mg_solution, solution);'
p35916
aS'    using SmootherType ='
p35917
aS'      PreconditionChebyshev<LevelMatrixType,'
p35918
aS'                            LinearAlgebra::distributed::Vector<float>>;'
p35919
aS'    mg::SmootherRelaxation<SmootherType,'
p35920
aS'                           LinearAlgebra::distributed::Vector<float>>'
p35921
aS'                                                         mg_smoother;'
p35922
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data;'
p35923
aS'    smoother_data.resize(0, triangulation.n_global_levels() - 1);'
p35924
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p35925
aS'         ++level)'
p35926
aS'      {'
p35927
aS'        if (level > 0)'
p35928
aS'          {'
p35929
aS'            smoother_data[level].smoothing_range     = 15.;'
p35930
aS'            smoother_data[level].degree              = 4;'
p35931
aS'            smoother_data[level].eig_cg_n_iterations = 10;'
p35932
aS'          }'
p35933
aS'        else'
p35934
aS'          {'
p35935
aS'            smoother_data[0].smoothing_range = 1e-3;'
p35936
aS'            smoother_data[0].degree          = numbers::invalid_unsigned_int;'
p35937
aS'            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();'
p35938
aS'          }'
p35939
aS'        mg_matrices[level].evaluate_newton_step(mg_solution[level]);'
p35940
aS'        mg_matrices[level].compute_diagonal();'
p35941
aS'        smoother_data[level].preconditioner ='
p35942
aS'          mg_matrices[level].get_matrix_diagonal_inverse();'
p35943
aS'      }'
p35944
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p35945
aS'    MGCoarseGridApplySmoother<LinearAlgebra::distributed::Vector<float>>'
p35946
aS'      mg_coarse;'
p35947
aS'    mg_coarse.initialize(mg_smoother);'
p35948
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_matrix('
p35949
aS'      mg_matrices);'
p35950
aS'    MGLevelObject<MatrixFreeOperators::MGInterfaceOperator<LevelMatrixType>>'
p35951
aS'      mg_interface_matrices;'
p35952
aS'    mg_interface_matrices.resize(0, triangulation.n_global_levels() - 1);'
p35953
aS'    for (unsigned int level = 0; level < triangulation.n_global_levels();'
p35954
aS'         ++level)'
p35955
aS'      {'
p35956
aS'        mg_interface_matrices[level].initialize(mg_matrices[level]);'
p35957
aS'      }'
p35958
aS'    mg::Matrix<LinearAlgebra::distributed::Vector<float>> mg_interface('
p35959
aS'      mg_interface_matrices);'
p35960
aS'    Multigrid<LinearAlgebra::distributed::Vector<float>> mg('
p35961
aS'      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p35962
aS'    mg.set_edge_matrices(mg_interface, mg_interface);'
p35963
aS'    PreconditionMG<dim,'
p35964
aS'                   LinearAlgebra::distributed::Vector<float>,'
p35965
aS'                   MGTransferMatrixFree<dim, float>>'
p35966
aS'      preconditioner(dof_handler, mg, mg_transfer);'
p35967
aS'    SolverControl solver_control(100, 1.e-12);'
p35968
aS'    SolverCG<LinearAlgebra::distributed::Vector<double>> cg(solver_control);'
p35969
aS'    newton_update = 0.0;'
p35970
aS'    cg.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p35971
aS'    constraints.distribute(newton_update);'
p35972
aS'    linear_iterations = solver_control.last_step();'
p35973
aS'    solution.zero_out_ghost_values();'
p35974
aS'  }'
p35975
aS'  template <int dim, int fe_degree>'
p35976
aS'  void GelfandProblem<dim, fe_degree>::solve()'
p35977
aS'  {'
p35978
aS'    TimerOutput::Scope t(computing_timer, "solve");'
p35979
aS'    const unsigned int itmax = 10;'
p35980
aS'    const double       TOLf  = 1e-12;'
p35981
aS'    const double       TOLx  = 1e-10;'
p35982
aS'    Timer solver_timer;'
p35983
aS'    solver_timer.start();'
p35984
aS'    for (unsigned int newton_step = 1; newton_step <= itmax; ++newton_step)'
p35985
aS'      {'
p35986
aS'        assemble_rhs();'
p35987
aS'        compute_update();'
p35988
aS'        const double ERRx = newton_update.l2_norm();'
p35989
aS'        const double ERRf = compute_residual(1.0);'
p35990
aS'        solution.add(1.0, newton_update);'
p35991
aS'        pcout << "   Nstep " << newton_step << ", errf = " << ERRf'
p35992
aS'              << ", errx = " << ERRx << ", it = " << linear_iterations'
p35993
aS'              << std::endl;'
p35994
aS'        if (ERRf < TOLf || ERRx < TOLx)'
p35995
aS'          {'
p35996
aS'            solver_timer.stop();'
p35997
aS'            pcout << "Convergence step " << newton_step << " value " << ERRf'
p35998
aS'                  << " (used wall time: " << solver_timer.wall_time() << " s)"'
p35999
aS'                  << std::endl;'
p36000
aS'            break;'
p36001
aS'          }'
p36002
aS'        else if (newton_step == itmax)'
p36003
aS'          {'
p36004
aS'            solver_timer.stop();'
p36005
aS'            pcout << "WARNING: No convergence of Newton\'s method after "'
p36006
aS'                  << newton_step << " steps." << std::endl;'
p36007
aS'            break;'
p36008
aS'          }'
p36009
aS'      }'
p36010
aS'  }'
p36011
aS'  template <int dim, int fe_degree>'
p36012
aS'  double GelfandProblem<dim, fe_degree>::compute_solution_norm() const'
p36013
aS'  {'
p36014
aS'    solution.update_ghost_values();'
p36015
aS'    Vector<float> norm_per_cell(triangulation.n_active_cells());'
p36016
aS'    VectorTools::integrate_difference(mapping,'
p36017
aS'                                      dof_handler,'
p36018
aS'                                      solution,'
p36019
aS'                                      Functions::ZeroFunction<dim>(),'
p36020
aS'                                      norm_per_cell,'
p36021
aS'                                      QGauss<dim>(fe.degree + 2),'
p36022
aS'                                      VectorTools::H1_seminorm);'
p36023
aS'    solution.zero_out_ghost_values();'
p36024
aS'    return VectorTools::compute_global_error(triangulation,'
p36025
aS'                                             norm_per_cell,'
p36026
aS'                                             VectorTools::H1_seminorm);'
p36027
aS'  }'
p36028
aS'  template <int dim, int fe_degree>'
p36029
aS'  void'
p36030
aS'  GelfandProblem<dim, fe_degree>::output_results(const unsigned int cycle) const'
p36031
aS'  {'
p36032
aS'    if (triangulation.n_global_active_cells() > 1e6)'
p36033
aS'      return;'
p36034
aS'    solution.update_ghost_values();'
p36035
aS'    DataOut<dim> data_out;'
p36036
aS'    data_out.attach_dof_handler(dof_handler);'
p36037
aS'    data_out.add_data_vector(solution, "solution");'
p36038
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p36039
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p36040
aS'      {'
p36041
aS'        subdomain(i) = triangulation.locally_owned_subdomain();'
p36042
aS'      }'
p36043
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p36044
aS'    data_out.build_patches(mapping,'
p36045
aS'                           fe.degree,'
p36046
aS'                           DataOut<dim>::curved_inner_cells);'
p36047
aS'    DataOutBase::VtkFlags flags;'
p36048
aS'    flags.compression_level = DataOutBase::VtkFlags::best_speed;'
p36049
aS'    data_out.set_flags(flags);'
p36050
aS'    data_out.write_vtu_with_pvtu_record('
p36051
aS'      "./", "solution_" + std::to_string(dim) + "d", cycle, MPI_COMM_WORLD, 3);'
p36052
aS'    solution.zero_out_ghost_values();'
p36053
aS'  }'
p36054
aS'  template <int dim, int fe_degree>'
p36055
aS'  void GelfandProblem<dim, fe_degree>::run()'
p36056
aS'  {'
p36057
aS'    {'
p36058
aS'      const unsigned int n_ranks ='
p36059
aS'        Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD);'
p36060
aS'      const unsigned int n_vect_doubles = VectorizedArray<double>::size();'
p36061
aS'      const unsigned int n_vect_bits    = 8 * sizeof(double) * n_vect_doubles;'
p36062
aS'      std::string DAT_header = "START DATE: " + Utilities::System::get_date() +'
p36063
aS'                               ", TIME: " + Utilities::System::get_time();'
p36064
aS'      std::string MPI_header = "Running with " + std::to_string(n_ranks) +'
p36065
aS'                               " MPI process" + (n_ranks > 1 ? "es" : "");'
p36066
aS'      std::string VEC_header ='
p36067
aS'        "Vectorization over " + std::to_string(n_vect_doubles) +'
p36068
aS'        " doubles = " + std::to_string(n_vect_bits) + " bits (" +'
p36069
aS'        Utilities::System::get_current_vectorization_level() +'
p36070
aS'        "), VECTORIZATION_LEVEL=" +'
p36071
aS'        std::to_string(DEAL_II_COMPILER_VECTORIZATION_LEVEL);'
p36072
aS'      std::string SOL_header = "Finite element space: " + fe.get_name();'
p36073
aS"      pcout << std::string(80, '=') << std::endl;"
p36074
aS'      pcout << DAT_header << std::endl;'
p36075
aS"      pcout << std::string(80, '-') << std::endl;"
p36076
aS'      pcout << MPI_header << std::endl;'
p36077
aS'      pcout << VEC_header << std::endl;'
p36078
aS'      pcout << SOL_header << std::endl;'
p36079
aS"      pcout << std::string(80, '=') << std::endl;"
p36080
aS'    }'
p36081
aS'    for (unsigned int cycle = 0; cycle < 9 - dim; ++cycle)'
p36082
aS'      {'
p36083
aS"        pcout << std::string(80, '-') << std::endl;"
p36084
aS'        pcout << "Cycle " << cycle << std::endl;'
p36085
aS"        pcout << std::string(80, '-') << std::endl;"
p36086
aS'        if (cycle == 0)'
p36087
aS'          {'
p36088
aS'            make_grid();'
p36089
aS'          }'
p36090
aS'        else'
p36091
aS'          {'
p36092
aS'            triangulation.refine_global(1);'
p36093
aS'          }'
p36094
aS'        Timer timer;'
p36095
aS'        pcout << "Set up system..." << std::endl;'
p36096
aS'        setup_system();'
p36097
aS'        pcout << "   Triangulation: " << triangulation.n_global_active_cells()'
p36098
aS'              << " cells" << std::endl;'
p36099
aS'        pcout << "   DoFHandler:    " << dof_handler.n_dofs() << " DoFs"'
p36100
aS'              << std::endl;'
p36101
aS'        pcout << std::endl;'
p36102
aS'        pcout << "Solve using Newton\'s method..." << std::endl;'
p36103
aS'        solve();'
p36104
aS'        pcout << std::endl;'
p36105
aS'        timer.stop();'
p36106
aS'        pcout << "Time for setup+solve (CPU/Wall) " << timer.cpu_time() << "/"'
p36107
aS'              << timer.wall_time() << " s" << std::endl;'
p36108
aS'        pcout << std::endl;'
p36109
aS'        pcout << "Output results..." << std::endl;'
p36110
aS'        const double norm = compute_solution_norm();'
p36111
aS'        output_results(cycle);'
p36112
aS'        pcout << "  H1 seminorm: " << norm << std::endl;'
p36113
aS'        pcout << std::endl;'
p36114
aS'        computing_timer.print_summary();'
p36115
aS'        computing_timer.reset();'
p36116
aS'      }'
p36117
aS'  }'
p36118
aS'} // namespace Step66'
p36119
aS'int main(int argc, char *argv[])'
p36120
ag9
aS'  try'
p36121
aS'    {'
p36122
aS'      using namespace Step66;'
p36123
aS'      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);'
p36124
aS'      {'
p36125
aS'        GelfandProblem<2, 4> gelfand_problem;'
p36126
aS'        gelfand_problem.run();'
p36127
aS'      }'
p36128
aS'      {'
p36129
aS'        GelfandProblem<3, 4> gelfand_problem;'
p36130
aS'        gelfand_problem.run();'
p36131
aS'      }'
p36132
aS'    }'
p36133
aS'  catch (std::exception &exc)'
p36134
aS'    {'
p36135
aS'      std::cerr << std::endl'
p36136
aS'                << std::endl'
p36137
aS'                << "----------------------------------------------------"'
p36138
aS'                << std::endl;'
p36139
aS'      std::cerr << "Exception on processing: " << std::endl'
p36140
aS'                << exc.what() << std::endl'
p36141
aS'                << "Aborting!" << std::endl'
p36142
aS'                << "----------------------------------------------------"'
p36143
aS'                << std::endl;'
p36144
aS'      return 1;'
p36145
aS'    }'
p36146
aS'  catch (...)'
p36147
aS'    {'
p36148
aS'      std::cerr << std::endl'
p36149
aS'                << std::endl'
p36150
aS'                << "----------------------------------------------------"'
p36151
aS'                << std::endl;'
p36152
aS'      std::cerr << "Unknown exception!" << std::endl'
p36153
aS'                << "Aborting!" << std::endl'
p36154
aS'                << "----------------------------------------------------"'
p36155
aS'                << std::endl;'
p36156
aS'      return 1;'
p36157
aS'    }'
p36158
aS'  return 0;'
p36159
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p36160
aS'#include <deal.II/base/function.h>'
p36161
aS'#include <deal.II/base/logstream.h>'
p36162
aS'#include <deal.II/base/timer.h>'
p36163
aS'#include <deal.II/base/time_stepping.h>'
p36164
aS'#include <deal.II/base/utilities.h>'
p36165
aS'#include <deal.II/base/vectorization.h>'
p36166
aS'#include <deal.II/distributed/tria.h>'
p36167
aS'#include <deal.II/dofs/dof_handler.h>'
p36168
aS'#include <deal.II/fe/fe_dgq.h>'
p36169
aS'#include <deal.II/fe/fe_system.h>'
p36170
aS'#include <deal.II/grid/grid_generator.h>'
p36171
aS'#include <deal.II/grid/tria.h>'
p36172
aS'#include <deal.II/lac/affine_constraints.h>'
p36173
aS'#include <deal.II/lac/la_parallel_vector.h>'
p36174
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p36175
aS'#include <deal.II/matrix_free/matrix_free.h>'
p36176
aS'#include <deal.II/numerics/data_out.h>'
p36177
aS'#include <fstream>'
p36178
aS'#include <iomanip>'
p36179
aS'#include <iostream>'
p36180
aS'#include <deal.II/matrix_free/operators.h>'
p36181
aS'namespace Euler_DG'
p36182
ag9
aS'  using namespace dealii;'
p36183
aS'  constexpr unsigned int testcase             = 0;'
p36184
aS'  constexpr unsigned int dimension            = 2;'
p36185
aS'  constexpr unsigned int n_global_refinements = 3;'
p36186
aS'  constexpr unsigned int fe_degree            = 5;'
p36187
aS'  constexpr unsigned int n_q_points_1d        = fe_degree + 2;'
p36188
aS'  using Number = double;'
p36189
aS'  constexpr double gamma       = 1.4;'
p36190
aS'  constexpr double final_time  = testcase == 0 ? 10 : 2.0;'
p36191
aS'  constexpr double output_tick = testcase == 0 ? 1 : 0.05;'
p36192
aS'  const double courant_number = 0.15 / std::pow(fe_degree, 1.5);'
p36193
aS'  enum LowStorageRungeKuttaScheme'
p36194
aS'  {'
p36195
aS'    stage_3_order_3, /* Kennedy, Carpenter, Lewis, 2000 */'
p36196
aS'    stage_5_order_4, /* Kennedy, Carpenter, Lewis, 2000 */'
p36197
aS'    stage_7_order_4, /* Tselios, Simos, 2007 */'
p36198
aS'    stage_9_order_5, /* Kennedy, Carpenter, Lewis, 2000 */'
p36199
aS'  };'
p36200
aS'  constexpr LowStorageRungeKuttaScheme lsrk_scheme = stage_5_order_4;'
p36201
aS'  enum EulerNumericalFlux'
p36202
aS'  {'
p36203
aS'    lax_friedrichs_modified,'
p36204
aS'    harten_lax_vanleer,'
p36205
aS'  };'
p36206
aS'  constexpr EulerNumericalFlux numerical_flux_type = lax_friedrichs_modified;'
p36207
aS'  template <int dim>'
p36208
aS'  class ExactSolution : public Function<dim>'
p36209
aS'  {'
p36210
aS'  public:'
p36211
aS'    ExactSolution(const double time)'
p36212
aS'      : Function<dim>(dim + 2, time)'
p36213
aS'    {}'
p36214
aS'    virtual double value(const Point<dim> & p,'
p36215
aS'                         const unsigned int component = 0) const override;'
p36216
aS'  };'
p36217
aS'  template <int dim>'
p36218
aS'  double ExactSolution<dim>::value(const Point<dim> & x,'
p36219
aS'                                   const unsigned int component) const'
p36220
aS'  {'
p36221
aS'    const double t = this->get_time();'
p36222
aS'    switch (testcase)'
p36223
aS'      {'
p36224
aS'        case 0:'
p36225
aS'          {'
p36226
aS'            Assert(dim == 2, ExcNotImplemented());'
p36227
aS'            const double beta = 5;'
p36228
aS'            Point<dim> x0;'
p36229
aS'            x0[0] = 5.;'
p36230
aS'            const double radius_sqr ='
p36231
aS'            const double factor ='
p36232
aS'              beta / (numbers::PI * 2) * std::exp(1. - radius_sqr);'
p36233
aS'            const double density_log = std::log2('
p36234
aS'              std::abs(1. - (gamma - 1.) / gamma * 0.25 * factor * factor));'
p36235
aS'            const double density = std::exp2(density_log * (1. / (gamma - 1.)));'
p36236
aS'            const double u       = 1. - factor * (x[1] - x0[1]);'
p36237
aS'            const double v       = factor * (x[0] - t - x0[0]);'
p36238
aS'            if (component == 0)'
p36239
aS'              return density;'
p36240
aS'            else if (component == 1)'
p36241
aS'              return density * u;'
p36242
aS'            else if (component == 2)'
p36243
aS'              return density * v;'
p36244
aS'            else'
p36245
aS'              {'
p36246
aS'                const double pressure ='
p36247
aS'                  std::exp2(density_log * (gamma / (gamma - 1.)));'
p36248
aS'                return pressure / (gamma - 1.) +'
p36249
aS'                       0.5 * (density * u * u + density * v * v);'
p36250
aS'              }'
p36251
aS'          }'
p36252
aS'        case 1:'
p36253
aS'          {'
p36254
aS'            if (component == 0)'
p36255
aS'              return 1.;'
p36256
aS'            else if (component == 1)'
p36257
aS'              return 0.4;'
p36258
aS'            else if (component == dim + 1)'
p36259
aS'              return 3.097857142857143;'
p36260
aS'            else'
p36261
aS'              return 0.;'
p36262
aS'          }'
p36263
aS'        default:'
p36264
aS'          Assert(false, ExcNotImplemented());'
p36265
aS'          return 0.;'
p36266
aS'      }'
p36267
aS'  }'
p36268
aS'  class LowStorageRungeKuttaIntegrator'
p36269
aS'  {'
p36270
aS'  public:'
p36271
aS'    LowStorageRungeKuttaIntegrator(const LowStorageRungeKuttaScheme scheme)'
p36272
aS'    {'
p36273
aS'      TimeStepping::runge_kutta_method lsrk;'
p36274
aS'      switch (scheme)'
p36275
aS'        {'
p36276
aS'          case stage_3_order_3:'
p36277
aS'            {'
p36278
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE3_ORDER3;'
p36279
aS'              break;'
p36280
aS'            }'
p36281
aS'          case stage_5_order_4:'
p36282
aS'            {'
p36283
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE5_ORDER4;'
p36284
aS'              break;'
p36285
aS'            }'
p36286
aS'          case stage_7_order_4:'
p36287
aS'            {'
p36288
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE7_ORDER4;'
p36289
aS'              break;'
p36290
aS'            }'
p36291
aS'          case stage_9_order_5:'
p36292
aS'            {'
p36293
aS'              lsrk = TimeStepping::LOW_STORAGE_RK_STAGE9_ORDER5;'
p36294
aS'              break;'
p36295
aS'            }'
p36296
aS'          default:'
p36297
aS'            AssertThrow(false, ExcNotImplemented());'
p36298
aS'        }'
p36299
aS'      TimeStepping::LowStorageRungeKutta<'
p36300
aS'        LinearAlgebra::distributed::Vector<Number>>'
p36301
aS'        rk_integrator(lsrk);'
p36302
aS'      rk_integrator.get_coefficients(ai, bi, ci);'
p36303
aS'    }'
p36304
aS'    unsigned int n_stages() const'
p36305
aS'    {'
p36306
aS'      return bi.size();'
p36307
aS'    }'
p36308
aS'    template <typename VectorType, typename Operator>'
p36309
aS'    void perform_time_step(const Operator &pde_operator,'
p36310
aS'                           const double    current_time,'
p36311
aS'                           const double    time_step,'
p36312
aS'                           VectorType &    solution,'
p36313
aS'                           VectorType &    vec_ri,'
p36314
aS'                           VectorType &    vec_ki) const'
p36315
aS'    {'
p36316
aS'      AssertDimension(ai.size() + 1, bi.size());'
p36317
aS'      pde_operator.perform_stage(current_time,'
p36318
aS'                                 bi[0] * time_step,'
p36319
aS'                                 ai[0] * time_step,'
p36320
aS'                                 solution,'
p36321
aS'                                 vec_ri,'
p36322
aS'                                 solution,'
p36323
aS'                                 vec_ri);'
p36324
aS'      for (unsigned int stage = 1; stage < bi.size(); ++stage)'
p36325
aS'        {'
p36326
aS'          const double c_i = ci[stage];'
p36327
aS'          pde_operator.perform_stage(current_time + c_i * time_step,'
p36328
aS'                                     bi[stage] * time_step,'
p36329
aS'                                        0 :'
p36330
aS'                                        ai[stage] * time_step),'
p36331
aS'                                     vec_ri,'
p36332
aS'                                     vec_ki,'
p36333
aS'                                     solution,'
p36334
aS'                                     vec_ri);'
p36335
aS'        }'
p36336
aS'    }'
p36337
aS'  private:'
p36338
aS'    std::vector<double> bi;'
p36339
aS'    std::vector<double> ai;'
p36340
aS'    std::vector<double> ci;'
p36341
aS'  };'
p36342
aS'  template <int dim, typename Number>'
p36343
aS'  inline DEAL_II_ALWAYS_INLINE //'
p36344
aS'    Tensor<1, dim, Number>'
p36345
aS'    euler_velocity(const Tensor<1, dim + 2, Number> &conserved_variables)'
p36346
aS'  {'
p36347
aS'    const Number inverse_density = Number(1.) / conserved_variables[0];'
p36348
aS'    Tensor<1, dim, Number> velocity;'
p36349
aS'    for (unsigned int d = 0; d < dim; ++d)'
p36350
aS'      velocity[d] = conserved_variables[1 + d] * inverse_density;'
p36351
aS'    return velocity;'
p36352
aS'  }'
p36353
aS'  template <int dim, typename Number>'
p36354
aS'  inline DEAL_II_ALWAYS_INLINE //'
p36355
aS'    Number'
p36356
aS'    euler_pressure(const Tensor<1, dim + 2, Number> &conserved_variables)'
p36357
aS'  {'
p36358
aS'    const Tensor<1, dim, Number> velocity ='
p36359
aS'      euler_velocity<dim>(conserved_variables);'
p36360
aS'    Number rho_u_dot_u = conserved_variables[1] * velocity[0];'
p36361
aS'    for (unsigned int d = 1; d < dim; ++d)'
p36362
aS'      rho_u_dot_u += conserved_variables[1 + d] * velocity[d];'
p36363
aS'    return (gamma - 1.) * (conserved_variables[dim + 1] - 0.5 * rho_u_dot_u);'
p36364
aS'  }'
p36365
aS'  template <int dim, typename Number>'
p36366
aS'  inline DEAL_II_ALWAYS_INLINE //'
p36367
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>>'
p36368
aS'    euler_flux(const Tensor<1, dim + 2, Number> &conserved_variables)'
p36369
aS'  {'
p36370
aS'    const Tensor<1, dim, Number> velocity ='
p36371
aS'      euler_velocity<dim>(conserved_variables);'
p36372
aS'    const Number pressure = euler_pressure<dim>(conserved_variables);'
p36373
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>> flux;'
p36374
aS'    for (unsigned int d = 0; d < dim; ++d)'
p36375
aS'      {'
p36376
aS'        flux[0][d] = conserved_variables[1 + d];'
p36377
aS'        for (unsigned int e = 0; e < dim; ++e)'
p36378
aS'          flux[e + 1][d] = conserved_variables[e + 1] * velocity[d];'
p36379
aS'        flux[d + 1][d] += pressure;'
p36380
aS'        flux[dim + 1][d] ='
p36381
aS'          velocity[d] * (conserved_variables[dim + 1] + pressure);'
p36382
aS'      }'
p36383
aS'    return flux;'
p36384
aS'  }'
p36385
aS'  template <int n_components, int dim, typename Number>'
p36386
aS'  inline DEAL_II_ALWAYS_INLINE //'
p36387
aS'    Tensor<1, n_components, Number>'
p36388
aS'    operator*(const Tensor<1, n_components, Tensor<1, dim, Number>> &matrix,'
p36389
aS'              const Tensor<1, dim, Number> &                         vector)'
p36390
aS'  {'
p36391
aS'    Tensor<1, n_components, Number> result;'
p36392
aS'    for (unsigned int d = 0; d < n_components; ++d)'
p36393
aS'      result[d] = matrix[d] * vector;'
p36394
aS'    return result;'
p36395
aS'  }'
p36396
aS'  template <int dim, typename Number>'
p36397
aS'  inline DEAL_II_ALWAYS_INLINE //'
p36398
aS'    Tensor<1, dim + 2, Number>'
p36399
aS'    euler_numerical_flux(const Tensor<1, dim + 2, Number> &u_m,'
p36400
aS'                         const Tensor<1, dim + 2, Number> &u_p,'
p36401
aS'                         const Tensor<1, dim, Number> &    normal)'
p36402
aS'  {'
p36403
aS'    const auto velocity_m = euler_velocity<dim>(u_m);'
p36404
aS'    const auto velocity_p = euler_velocity<dim>(u_p);'
p36405
aS'    const auto pressure_m = euler_pressure<dim>(u_m);'
p36406
aS'    const auto pressure_p = euler_pressure<dim>(u_p);'
p36407
aS'    const auto flux_m = euler_flux<dim>(u_m);'
p36408
aS'    const auto flux_p = euler_flux<dim>(u_p);'
p36409
aS'    switch (numerical_flux_type)'
p36410
aS'      {'
p36411
aS'        case lax_friedrichs_modified:'
p36412
aS'          {'
p36413
aS'            const auto lambda ='
p36414
aS'              0.5 * std::sqrt(std::max(velocity_p.norm_square() +'
p36415
aS'                                         gamma * pressure_p * (1. / u_p[0]),'
p36416
aS'                                       velocity_m.norm_square() +'
p36417
aS'                                         gamma * pressure_m * (1. / u_m[0])));'
p36418
aS'            return 0.5 * (flux_m * normal + flux_p * normal) +'
p36419
aS'                   0.5 * lambda * (u_m - u_p);'
p36420
aS'          }'
p36421
aS'        case harten_lax_vanleer:'
p36422
aS'          {'
p36423
aS'            const auto avg_velocity_normal ='
p36424
aS'              0.5 * ((velocity_m + velocity_p) * normal);'
p36425
aS'            const auto   avg_c = std::sqrt(std::abs('
p36426
aS'              0.5 * gamma *'
p36427
aS'            const Number s_pos ='
p36428
aS'              std::max(Number(), avg_velocity_normal + avg_c);'
p36429
aS'            const Number s_neg ='
p36430
aS'              std::min(Number(), avg_velocity_normal - avg_c);'
p36431
aS'            const Number inverse_s = Number(1.) / (s_pos - s_neg);'
p36432
aS'            return inverse_s *'
p36433
aS'                    s_pos * s_neg * (u_m - u_p));'
p36434
aS'          }'
p36435
aS'        default:'
p36436
aS'          {'
p36437
aS'            Assert(false, ExcNotImplemented());'
p36438
aS'            return {};'
p36439
aS'          }'
p36440
aS'      }'
p36441
aS'  }'
p36442
aS'  template <int dim, typename Number>'
p36443
aS'  VectorizedArray<Number>'
p36444
aS'  evaluate_function(const Function<dim> &                      function,'
p36445
aS'                    const Point<dim, VectorizedArray<Number>> &p_vectorized,'
p36446
aS'                    const unsigned int                         component)'
p36447
aS'  {'
p36448
aS'    VectorizedArray<Number> result;'
p36449
aS'    for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v)'
p36450
aS'      {'
p36451
aS'        Point<dim> p;'
p36452
aS'        for (unsigned int d = 0; d < dim; ++d)'
p36453
aS'          p[d] = p_vectorized[d][v];'
p36454
aS'        result[v] = function.value(p, component);'
p36455
aS'      }'
p36456
aS'    return result;'
p36457
aS'  }'
p36458
aS'  template <int dim, typename Number, int n_components = dim + 2>'
p36459
aS'  Tensor<1, n_components, VectorizedArray<Number>>'
p36460
aS'  evaluate_function(const Function<dim> &                      function,'
p36461
aS'                    const Point<dim, VectorizedArray<Number>> &p_vectorized)'
p36462
aS'  {'
p36463
aS'    AssertDimension(function.n_components, n_components);'
p36464
aS'    Tensor<1, n_components, VectorizedArray<Number>> result;'
p36465
aS'    for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v)'
p36466
aS'      {'
p36467
aS'        Point<dim> p;'
p36468
aS'        for (unsigned int d = 0; d < dim; ++d)'
p36469
aS'          p[d] = p_vectorized[d][v];'
p36470
aS'        for (unsigned int d = 0; d < n_components; ++d)'
p36471
aS'          result[d][v] = function.value(p, d);'
p36472
aS'      }'
p36473
aS'    return result;'
p36474
aS'  }'
p36475
aS'  template <int dim, int degree, int n_points_1d>'
p36476
aS'  class EulerOperator'
p36477
aS'  {'
p36478
aS'  public:'
p36479
aS'    static constexpr unsigned int n_quadrature_points_1d = n_points_1d;'
p36480
aS'    EulerOperator(TimerOutput &timer_output);'
p36481
aS'    void reinit(const Mapping<dim> &   mapping,'
p36482
aS'                const DoFHandler<dim> &dof_handler);'
p36483
aS'    void set_inflow_boundary(const types::boundary_id       boundary_id,'
p36484
aS'                             std::unique_ptr<Function<dim>> inflow_function);'
p36485
aS'    void set_subsonic_outflow_boundary('
p36486
aS'      const types::boundary_id       boundary_id,'
p36487
aS'      std::unique_ptr<Function<dim>> outflow_energy);'
p36488
aS'    void set_wall_boundary(const types::boundary_id boundary_id);'
p36489
aS'    void set_body_force(std::unique_ptr<Function<dim>> body_force);'
p36490
aS'    void apply(const double                                      current_time,'
p36491
aS'               const LinearAlgebra::distributed::Vector<Number> &src,'
p36492
aS'               LinearAlgebra::distributed::Vector<Number> &      dst) const;'
p36493
aS'    void'
p36494
aS'    perform_stage(const Number cur_time,'
p36495
aS'                  const Number factor_solution,'
p36496
aS'                  const Number factor_ai,'
p36497
aS'                  const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p36498
aS'                  LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p36499
aS'                  LinearAlgebra::distributed::Vector<Number> &      solution,'
p36500
aS'                  LinearAlgebra::distributed::Vector<Number> &next_ri) const;'
p36501
aS'    void project(const Function<dim> &                       function,'
p36502
aS'                 LinearAlgebra::distributed::Vector<Number> &solution) const;'
p36503
aS'    std::array<double, 3> compute_errors('
p36504
aS'      const Function<dim> &                             function,'
p36505
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p36506
aS'    double compute_cell_transport_speed('
p36507
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p36508
aS'    void'
p36509
aS'    initialize_vector(LinearAlgebra::distributed::Vector<Number> &vector) const;'
p36510
aS'  private:'
p36511
aS'    MatrixFree<dim, Number> data;'
p36512
aS'    TimerOutput &timer;'
p36513
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p36514
aS'      inflow_boundaries;'
p36515
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p36516
aS'                                   subsonic_outflow_boundaries;'
p36517
aS'    std::set<types::boundary_id>   wall_boundaries;'
p36518
aS'    std::unique_ptr<Function<dim>> body_force;'
p36519
aS'    void local_apply_inverse_mass_matrix('
p36520
aS'      const MatrixFree<dim, Number> &                   data,'
p36521
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p36522
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p36523
aS'      const std::pair<unsigned int, unsigned int> &     cell_range) const;'
p36524
aS'    void local_apply_cell('
p36525
aS'      const MatrixFree<dim, Number> &                   data,'
p36526
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p36527
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p36528
aS'      const std::pair<unsigned int, unsigned int> &     cell_range) const;'
p36529
aS'    void local_apply_face('
p36530
aS'      const MatrixFree<dim, Number> &                   data,'
p36531
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p36532
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p36533
aS'      const std::pair<unsigned int, unsigned int> &     face_range) const;'
p36534
aS'    void local_apply_boundary_face('
p36535
aS'      const MatrixFree<dim, Number> &                   data,'
p36536
aS'      LinearAlgebra::distributed::Vector<Number> &      dst,'
p36537
aS'      const LinearAlgebra::distributed::Vector<Number> &src,'
p36538
aS'      const std::pair<unsigned int, unsigned int> &     face_range) const;'
p36539
aS'  };'
p36540
aS'  template <int dim, int degree, int n_points_1d>'
p36541
aS'  EulerOperator<dim, degree, n_points_1d>::EulerOperator(TimerOutput &timer)'
p36542
aS'    : timer(timer)'
p36543
aS'  {}'
p36544
aS'  template <int dim, int degree, int n_points_1d>'
p36545
aS'  void EulerOperator<dim, degree, n_points_1d>::reinit('
p36546
aS'    const Mapping<dim> &   mapping,'
p36547
aS'    const DoFHandler<dim> &dof_handler)'
p36548
aS'  {'
p36549
aS'    const std::vector<const DoFHandler<dim> *> dof_handlers = {&dof_handler};'
p36550
aS'    const AffineConstraints<double>            dummy;'
p36551
aS'    const std::vector<const AffineConstraints<double> *> constraints = {&dummy};'
p36552
aS'    const std::vector<Quadrature<1>> quadratures = {QGauss<1>(n_q_points_1d),'
p36553
aS'                                                    QGauss<1>(fe_degree + 1)};'
p36554
aS'    typename MatrixFree<dim, Number>::AdditionalData additional_data;'
p36555
aS'    additional_data.mapping_update_flags ='
p36556
aS'       update_values);'
p36557
aS'    additional_data.mapping_update_flags_inner_faces ='
p36558
aS'       update_values);'
p36559
aS'    additional_data.mapping_update_flags_boundary_faces ='
p36560
aS'       update_values);'
p36561
aS'    additional_data.tasks_parallel_scheme ='
p36562
aS'      MatrixFree<dim, Number>::AdditionalData::none;'
p36563
aS'    data.reinit('
p36564
aS'      mapping, dof_handlers, constraints, quadratures, additional_data);'
p36565
aS'  }'
p36566
aS'  template <int dim, int degree, int n_points_1d>'
p36567
aS'  void EulerOperator<dim, degree, n_points_1d>::initialize_vector('
p36568
aS'    LinearAlgebra::distributed::Vector<Number> &vector) const'
p36569
aS'  {'
p36570
aS'    data.initialize_dof_vector(vector);'
p36571
aS'  }'
p36572
aS'  template <int dim, int degree, int n_points_1d>'
p36573
aS'  void EulerOperator<dim, degree, n_points_1d>::set_inflow_boundary('
p36574
aS'    const types::boundary_id       boundary_id,'
p36575
aS'    std::unique_ptr<Function<dim>> inflow_function)'
p36576
aS'  {'
p36577
aS'    AssertThrow(subsonic_outflow_boundaries.find(boundary_id) =='
p36578
aS'                    subsonic_outflow_boundaries.end() &&'
p36579
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p36580
aS'                ExcMessage("You already set the boundary with id " +'
p36581
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p36582
aS'                           " to another type of boundary before now setting " +'
p36583
aS'                           "it as inflow"));'
p36584
aS'    AssertThrow(inflow_function->n_components == dim + 2,'
p36585
aS'                ExcMessage("Expected function with dim+2 components"));'
p36586
aS'    inflow_boundaries[boundary_id] = std::move(inflow_function);'
p36587
aS'  }'
p36588
aS'  template <int dim, int degree, int n_points_1d>'
p36589
aS'  void EulerOperator<dim, degree, n_points_1d>::set_subsonic_outflow_boundary('
p36590
aS'    const types::boundary_id       boundary_id,'
p36591
aS'    std::unique_ptr<Function<dim>> outflow_function)'
p36592
aS'  {'
p36593
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p36594
aS'                    inflow_boundaries.end() &&'
p36595
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p36596
aS'                ExcMessage("You already set the boundary with id " +'
p36597
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p36598
aS'                           " to another type of boundary before now setting " +'
p36599
aS'                           "it as subsonic outflow"));'
p36600
aS'    AssertThrow(outflow_function->n_components == dim + 2,'
p36601
aS'                ExcMessage("Expected function with dim+2 components"));'
p36602
aS'    subsonic_outflow_boundaries[boundary_id] = std::move(outflow_function);'
p36603
aS'  }'
p36604
aS'  template <int dim, int degree, int n_points_1d>'
p36605
aS'  void EulerOperator<dim, degree, n_points_1d>::set_wall_boundary('
p36606
aS'    const types::boundary_id boundary_id)'
p36607
aS'  {'
p36608
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p36609
aS'                    inflow_boundaries.end() &&'
p36610
aS'                  subsonic_outflow_boundaries.find(boundary_id) =='
p36611
aS'                    subsonic_outflow_boundaries.end(),'
p36612
aS'                ExcMessage("You already set the boundary with id " +'
p36613
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p36614
aS'                           " to another type of boundary before now setting " +'
p36615
aS'                           "it as wall boundary"));'
p36616
aS'    wall_boundaries.insert(boundary_id);'
p36617
aS'  }'
p36618
aS'  template <int dim, int degree, int n_points_1d>'
p36619
aS'  void EulerOperator<dim, degree, n_points_1d>::set_body_force('
p36620
aS'    std::unique_ptr<Function<dim>> body_force)'
p36621
aS'  {'
p36622
aS'    AssertDimension(body_force->n_components, dim);'
p36623
aS'    this->body_force = std::move(body_force);'
p36624
aS'  }'
p36625
aS'  template <int dim, int degree, int n_points_1d>'
p36626
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_cell('
p36627
aS'    const MatrixFree<dim, Number> &,'
p36628
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p36629
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p36630
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p36631
aS'  {'
p36632
aS'    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data);'
p36633
aS'    Tensor<1, dim, VectorizedArray<Number>> constant_body_force;'
p36634
aS'    const Functions::ConstantFunction<dim> *constant_function ='
p36635
aS'      dynamic_cast<Functions::ConstantFunction<dim> *>(body_force.get());'
p36636
aS'    if (constant_function)'
p36637
aS'      constant_body_force = evaluate_function<dim, Number, dim>('
p36638
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p36639
aS'      {'
p36640
aS'        phi.reinit(cell);'
p36641
aS'        phi.gather_evaluate(src, EvaluationFlags::values);'
p36642
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p36643
aS'          {'
p36644
aS'            const auto w_q = phi.get_value(q);'
p36645
aS'            phi.submit_gradient(euler_flux<dim>(w_q), q);'
p36646
aS'            if (body_force.get() != nullptr)'
p36647
aS'              {'
p36648
aS'                const Tensor<1, dim, VectorizedArray<Number>> force ='
p36649
aS'                  constant_function ? constant_body_force :'
p36650
aS'                                      evaluate_function<dim, Number, dim>('
p36651
aS'                Tensor<1, dim + 2, VectorizedArray<Number>> forcing;'
p36652
aS'                for (unsigned int d = 0; d < dim; ++d)'
p36653
aS'                  forcing[d + 1] = w_q[0] * force[d];'
p36654
aS'                for (unsigned int d = 0; d < dim; ++d)'
p36655
aS'                  forcing[dim + 1] += force[d] * w_q[d + 1];'
p36656
aS'                phi.submit_value(forcing, q);'
p36657
aS'              }'
p36658
aS'          }'
p36659
aS'        phi.integrate_scatter(((body_force.get() != nullptr) ?'
p36660
aS'                                 EvaluationFlags::values :'
p36661
aS'                                 EvaluationFlags::nothing) |'
p36662
aS'                                EvaluationFlags::gradients,'
p36663
aS'                              dst);'
p36664
aS'      }'
p36665
aS'  }'
p36666
aS'  template <int dim, int degree, int n_points_1d>'
p36667
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_face('
p36668
aS'    const MatrixFree<dim, Number> &,'
p36669
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p36670
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p36671
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p36672
aS'  {'
p36673
aS'    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi_m(data,'
p36674
aS'                                                                      true);'
p36675
aS'    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi_p(data,'
p36676
aS'                                                                      false);'
p36677
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p36678
aS'      {'
p36679
aS'        phi_p.reinit(face);'
p36680
aS'        phi_p.gather_evaluate(src, EvaluationFlags::values);'
p36681
aS'        phi_m.reinit(face);'
p36682
aS'        phi_m.gather_evaluate(src, EvaluationFlags::values);'
p36683
aS'        for (unsigned int q = 0; q < phi_m.n_q_points; ++q)'
p36684
aS'          {'
p36685
aS'            const auto numerical_flux ='
p36686
aS'              euler_numerical_flux<dim>(phi_m.get_value(q),'
p36687
aS'                                        phi_p.get_value(q),'
p36688
aS'                                        phi_m.get_normal_vector(q));'
p36689
aS'            phi_m.submit_value(-numerical_flux, q);'
p36690
aS'            phi_p.submit_value(numerical_flux, q);'
p36691
aS'          }'
p36692
aS'        phi_p.integrate_scatter(EvaluationFlags::values, dst);'
p36693
aS'        phi_m.integrate_scatter(EvaluationFlags::values, dst);'
p36694
aS'      }'
p36695
aS'  }'
p36696
aS'  template <int dim, int degree, int n_points_1d>'
p36697
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_boundary_face('
p36698
aS'    const MatrixFree<dim, Number> &,'
p36699
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p36700
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p36701
aS'    const std::pair<unsigned int, unsigned int> &     face_range) const'
p36702
aS'  {'
p36703
aS'    FEFaceEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data, true);'
p36704
aS'    for (unsigned int face = face_range.first; face < face_range.second; ++face)'
p36705
aS'      {'
p36706
aS'        phi.reinit(face);'
p36707
aS'        phi.gather_evaluate(src, EvaluationFlags::values);'
p36708
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p36709
aS'          {'
p36710
aS'            const auto w_m    = phi.get_value(q);'
p36711
aS'            const auto normal = phi.get_normal_vector(q);'
p36712
aS'            auto rho_u_dot_n = w_m[1] * normal[0];'
p36713
aS'            for (unsigned int d = 1; d < dim; ++d)'
p36714
aS'              rho_u_dot_n += w_m[1 + d] * normal[d];'
p36715
aS'            bool at_outflow = false;'
p36716
aS'            Tensor<1, dim + 2, VectorizedArray<Number>> w_p;'
p36717
aS'            const auto boundary_id = data.get_boundary_id(face);'
p36718
aS'            if (wall_boundaries.find(boundary_id) != wall_boundaries.end())'
p36719
aS'              {'
p36720
aS'                w_p[0] = w_m[0];'
p36721
aS'                for (unsigned int d = 0; d < dim; ++d)'
p36722
aS'                  w_p[d + 1] = w_m[d + 1] - 2. * rho_u_dot_n * normal[d];'
p36723
aS'                w_p[dim + 1] = w_m[dim + 1];'
p36724
aS'              }'
p36725
aS'            else if (inflow_boundaries.find(boundary_id) !='
p36726
aS'                     inflow_boundaries.end())'
p36727
aS'              w_p ='
p36728
aS'                evaluate_function(*inflow_boundaries.find(boundary_id)->second,'
p36729
aS'                                  phi.quadrature_point(q));'
p36730
aS'            else if (subsonic_outflow_boundaries.find(boundary_id) !='
p36731
aS'                     subsonic_outflow_boundaries.end())'
p36732
aS'              {'
p36733
aS'                w_p          = w_m;'
p36734
aS'                w_p[dim + 1] = evaluate_function('
p36735
aS'                  phi.quadrature_point(q),'
p36736
aS'                  dim + 1);'
p36737
aS'                at_outflow = true;'
p36738
aS'              }'
p36739
aS'            else'
p36740
aS'              AssertThrow(false,'
p36741
aS'                          ExcMessage("Unknown boundary id, did "'
p36742
aS'                                     "you set a boundary condition for "'
p36743
aS'                                     "this part of the domain boundary?"));'
p36744
aS'            auto flux = euler_numerical_flux<dim>(w_m, w_p, normal);'
p36745
aS'            if (at_outflow)'
p36746
aS'              for (unsigned int v = 0; v < VectorizedArray<Number>::size(); ++v)'
p36747
aS'                {'
p36748
aS'                  if (rho_u_dot_n[v] < -1e-12)'
p36749
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p36750
aS'                      flux[d + 1][v] = 0.;'
p36751
aS'                }'
p36752
aS'            phi.submit_value(-flux, q);'
p36753
aS'          }'
p36754
aS'        phi.integrate_scatter(EvaluationFlags::values, dst);'
p36755
aS'      }'
p36756
aS'  }'
p36757
aS'  template <int dim, int degree, int n_points_1d>'
p36758
aS'  void EulerOperator<dim, degree, n_points_1d>::local_apply_inverse_mass_matrix('
p36759
aS'    const MatrixFree<dim, Number> &,'
p36760
aS'    LinearAlgebra::distributed::Vector<Number> &      dst,'
p36761
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p36762
aS'    const std::pair<unsigned int, unsigned int> &     cell_range) const'
p36763
aS'  {'
p36764
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1);'
p36765
aS'    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, degree, dim + 2, Number>'
p36766
aS'      inverse(phi);'
p36767
aS'    for (unsigned int cell = cell_range.first; cell < cell_range.second; ++cell)'
p36768
aS'      {'
p36769
aS'        phi.reinit(cell);'
p36770
aS'        phi.read_dof_values(src);'
p36771
aS'        inverse.apply(phi.begin_dof_values(), phi.begin_dof_values());'
p36772
aS'        phi.set_dof_values(dst);'
p36773
aS'      }'
p36774
aS'  }'
p36775
aS'  template <int dim, int degree, int n_points_1d>'
p36776
aS'  void EulerOperator<dim, degree, n_points_1d>::apply('
p36777
aS'    const double                                      current_time,'
p36778
aS'    const LinearAlgebra::distributed::Vector<Number> &src,'
p36779
aS'    LinearAlgebra::distributed::Vector<Number> &      dst) const'
p36780
aS'  {'
p36781
aS'    {'
p36782
aS'      TimerOutput::Scope t(timer, "apply - integrals");'
p36783
aS'      for (auto &i : inflow_boundaries)'
p36784
aS'        i.second->set_time(current_time);'
p36785
aS'      for (auto &i : subsonic_outflow_boundaries)'
p36786
aS'        i.second->set_time(current_time);'
p36787
aS'      data.loop(&EulerOperator::local_apply_cell,'
p36788
aS'                &EulerOperator::local_apply_face,'
p36789
aS'                &EulerOperator::local_apply_boundary_face,'
p36790
aS'                this,'
p36791
aS'                dst,'
p36792
aS'                src,'
p36793
aS'                true,'
p36794
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values,'
p36795
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values);'
p36796
aS'    }'
p36797
aS'    {'
p36798
aS'      TimerOutput::Scope t(timer, "apply - inverse mass");'
p36799
aS'      data.cell_loop(&EulerOperator::local_apply_inverse_mass_matrix,'
p36800
aS'                     this,'
p36801
aS'                     dst,'
p36802
aS'                     dst);'
p36803
aS'    }'
p36804
aS'  }'
p36805
aS'  template <int dim, int degree, int n_points_1d>'
p36806
aS'  void EulerOperator<dim, degree, n_points_1d>::perform_stage('
p36807
aS'    const Number                                      current_time,'
p36808
aS'    const Number                                      factor_solution,'
p36809
aS'    const Number                                      factor_ai,'
p36810
aS'    const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p36811
aS'    LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p36812
aS'    LinearAlgebra::distributed::Vector<Number> &      solution,'
p36813
aS'    LinearAlgebra::distributed::Vector<Number> &      next_ri) const'
p36814
aS'  {'
p36815
aS'    {'
p36816
aS'      TimerOutput::Scope t(timer, "rk_stage - integrals L_h");'
p36817
aS'      for (auto &i : inflow_boundaries)'
p36818
aS'        i.second->set_time(current_time);'
p36819
aS'      for (auto &i : subsonic_outflow_boundaries)'
p36820
aS'        i.second->set_time(current_time);'
p36821
aS'      data.loop(&EulerOperator::local_apply_cell,'
p36822
aS'                &EulerOperator::local_apply_face,'
p36823
aS'                &EulerOperator::local_apply_boundary_face,'
p36824
aS'                this,'
p36825
aS'                vec_ki,'
p36826
aS'                current_ri,'
p36827
aS'                true,'
p36828
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values,'
p36829
aS'                MatrixFree<dim, Number>::DataAccessOnFaces::values);'
p36830
aS'    }'
p36831
aS'    {'
p36832
aS'      TimerOutput::Scope t(timer, "rk_stage - inv mass + vec upd");'
p36833
aS'      data.cell_loop('
p36834
aS'        &EulerOperator::local_apply_inverse_mass_matrix,'
p36835
aS'        this,'
p36836
aS'        next_ri,'
p36837
aS'        vec_ki,'
p36838
aS'        std::function<void(const unsigned int, const unsigned int)>(),'
p36839
aS'        [&](const unsigned int start_range, const unsigned int end_range) {'
p36840
aS'          const Number ai = factor_ai;'
p36841
aS'          const Number bi = factor_solution;'
p36842
aS'          if (ai == Number())'
p36843
aS'            {'
p36844
aS'              for (unsigned int i = start_range; i < end_range; ++i)'
p36845
aS'                {'
p36846
aS'                  const Number k_i          = next_ri.local_element(i);'
p36847
aS'                  const Number sol_i        = solution.local_element(i);'
p36848
aS'                  solution.local_element(i) = sol_i + bi * k_i;'
p36849
aS'                }'
p36850
aS'            }'
p36851
aS'          else'
p36852
aS'            {'
p36853
aS'              for (unsigned int i = start_range; i < end_range; ++i)'
p36854
aS'                {'
p36855
aS'                  const Number k_i          = next_ri.local_element(i);'
p36856
aS'                  const Number sol_i        = solution.local_element(i);'
p36857
aS'                  solution.local_element(i) = sol_i + bi * k_i;'
p36858
aS'                  next_ri.local_element(i)  = sol_i + ai * k_i;'
p36859
aS'                }'
p36860
aS'            }'
p36861
aS'        });'
p36862
aS'    }'
p36863
aS'  }'
p36864
aS'  template <int dim, int degree, int n_points_1d>'
p36865
aS'  void EulerOperator<dim, degree, n_points_1d>::project('
p36866
aS'    const Function<dim> &                       function,'
p36867
aS'    LinearAlgebra::distributed::Vector<Number> &solution) const'
p36868
aS'  {'
p36869
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1);'
p36870
aS'    MatrixFreeOperators::CellwiseInverseMassMatrix<dim, degree, dim + 2, Number>'
p36871
aS'      inverse(phi);'
p36872
aS'    solution.zero_out_ghost_values();'
p36873
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p36874
aS'      {'
p36875
aS'        phi.reinit(cell);'
p36876
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p36877
aS'          phi.submit_dof_value(evaluate_function(function,'
p36878
aS'                                                 phi.quadrature_point(q)),'
p36879
aS'                               q);'
p36880
aS'        inverse.transform_from_q_points_to_basis(dim + 2,'
p36881
aS'                                                 phi.begin_dof_values(),'
p36882
aS'                                                 phi.begin_dof_values());'
p36883
aS'        phi.set_dof_values(solution);'
p36884
aS'      }'
p36885
aS'  }'
p36886
aS'  template <int dim, int degree, int n_points_1d>'
p36887
aS'  std::array<double, 3> EulerOperator<dim, degree, n_points_1d>::compute_errors('
p36888
aS'    const Function<dim> &                             function,'
p36889
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p36890
aS'  {'
p36891
aS'    TimerOutput::Scope t(timer, "compute errors");'
p36892
aS'    double             errors_squared[3] = {};'
p36893
aS'    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number> phi(data, 0, 0);'
p36894
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p36895
aS'      {'
p36896
aS'        phi.reinit(cell);'
p36897
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p36898
aS'        VectorizedArray<Number> local_errors_squared[3] = {};'
p36899
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p36900
aS'          {'
p36901
aS'            const auto error ='
p36902
aS'              evaluate_function(function, phi.quadrature_point(q)) -'
p36903
aS'              phi.get_value(q);'
p36904
aS'            const auto JxW = phi.JxW(q);'
p36905
aS'            local_errors_squared[0] += error[0] * error[0] * JxW;'
p36906
aS'            for (unsigned int d = 0; d < dim; ++d)'
p36907
aS'              local_errors_squared[1] += (error[d + 1] * error[d + 1]) * JxW;'
p36908
aS'            local_errors_squared[2] += (error[dim + 1] * error[dim + 1]) * JxW;'
p36909
aS'          }'
p36910
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p36911
aS'             ++v)'
p36912
aS'          for (unsigned int d = 0; d < 3; ++d)'
p36913
aS'            errors_squared[d] += local_errors_squared[d][v];'
p36914
aS'      }'
p36915
aS'    Utilities::MPI::sum(errors_squared, MPI_COMM_WORLD, errors_squared);'
p36916
aS'    std::array<double, 3> errors;'
p36917
aS'    for (unsigned int d = 0; d < 3; ++d)'
p36918
aS'      errors[d] = std::sqrt(errors_squared[d]);'
p36919
aS'    return errors;'
p36920
aS'  }'
p36921
aS'  template <int dim, int degree, int n_points_1d>'
p36922
aS'  double EulerOperator<dim, degree, n_points_1d>::compute_cell_transport_speed('
p36923
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p36924
aS'  {'
p36925
aS'    TimerOutput::Scope t(timer, "compute transport speed");'
p36926
aS'    Number             max_transport = 0;'
p36927
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number> phi(data, 0, 1);'
p36928
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p36929
aS'      {'
p36930
aS'        phi.reinit(cell);'
p36931
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p36932
aS'        VectorizedArray<Number> local_max = 0.;'
p36933
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p36934
aS'          {'
p36935
aS'            const auto solution = phi.get_value(q);'
p36936
aS'            const auto velocity = euler_velocity<dim>(solution);'
p36937
aS'            const auto pressure = euler_pressure<dim>(solution);'
p36938
aS'            const auto inverse_jacobian = phi.inverse_jacobian(q);'
p36939
aS'            const auto convective_speed = inverse_jacobian * velocity;'
p36940
aS'            VectorizedArray<Number> convective_limit = 0.;'
p36941
aS'            for (unsigned int d = 0; d < dim; ++d)'
p36942
aS'              convective_limit ='
p36943
aS'                std::max(convective_limit, std::abs(convective_speed[d]));'
p36944
aS'            const auto speed_of_sound ='
p36945
aS'              std::sqrt(gamma * pressure * (1. / solution[0]));'
p36946
aS'            Tensor<1, dim, VectorizedArray<Number>> eigenvector;'
p36947
aS'            for (unsigned int d = 0; d < dim; ++d)'
p36948
aS'              eigenvector[d] = 1.;'
p36949
aS'            for (unsigned int i = 0; i < 5; ++i)'
p36950
aS'              {'
p36951
aS'                eigenvector = transpose(inverse_jacobian) *'
p36952
aS'                VectorizedArray<Number> eigenvector_norm = 0.;'
p36953
aS'                for (unsigned int d = 0; d < dim; ++d)'
p36954
aS'                  eigenvector_norm ='
p36955
aS'                    std::max(eigenvector_norm, std::abs(eigenvector[d]));'
p36956
aS'                eigenvector /= eigenvector_norm;'
p36957
aS'              }'
p36958
aS'            const auto jac_times_ev   = inverse_jacobian * eigenvector;'
p36959
aS'            const auto max_eigenvalue = std::sqrt('
p36960
aS'            local_max ='
p36961
aS'              std::max(local_max,'
p36962
aS'                       max_eigenvalue * speed_of_sound + convective_limit);'
p36963
aS'          }'
p36964
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p36965
aS'             ++v)'
p36966
aS'          for (unsigned int d = 0; d < 3; ++d)'
p36967
aS'            max_transport = std::max(max_transport, local_max[v]);'
p36968
aS'      }'
p36969
aS'    max_transport = Utilities::MPI::max(max_transport, MPI_COMM_WORLD);'
p36970
aS'    return max_transport;'
p36971
aS'  }'
p36972
aS'  template <int dim>'
p36973
aS'  class EulerProblem'
p36974
aS'  {'
p36975
aS'  public:'
p36976
aS'    EulerProblem();'
p36977
aS'    void run();'
p36978
aS'  private:'
p36979
aS'    void make_grid_and_dofs();'
p36980
aS'    void output_results(const unsigned int result_number);'
p36981
aS'    LinearAlgebra::distributed::Vector<Number> solution;'
p36982
aS'    ConditionalOStream pcout;'
p36983
aS'#ifdef DEAL_II_WITH_P4EST'
p36984
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p36985
aS'#else'
p36986
aS'    Triangulation<dim> triangulation;'
p36987
aS'#endif'
p36988
aS'    FESystem<dim>        fe;'
p36989
aS'    MappingQGeneric<dim> mapping;'
p36990
aS'    DoFHandler<dim>      dof_handler;'
p36991
aS'    TimerOutput timer;'
p36992
aS'    EulerOperator<dim, fe_degree, n_q_points_1d> euler_operator;'
p36993
aS'    double time, time_step;'
p36994
aS'    class Postprocessor : public DataPostprocessor<dim>'
p36995
aS'    {'
p36996
aS'    public:'
p36997
aS'      Postprocessor();'
p36998
aS'      virtual void evaluate_vector_field('
p36999
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p37000
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p37001
aS'      virtual std::vector<std::string> get_names() const override;'
p37002
aS'      virtual std::vector<'
p37003
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p37004
aS'      get_data_component_interpretation() const override;'
p37005
aS'      virtual UpdateFlags get_needed_update_flags() const override;'
p37006
aS'    private:'
p37007
aS'      const bool do_schlieren_plot;'
p37008
aS'    };'
p37009
aS'  };'
p37010
aS'  template <int dim>'
p37011
aS'  EulerProblem<dim>::Postprocessor::Postprocessor()'
p37012
aS'    : do_schlieren_plot(dim == 2)'
p37013
aS'  {}'
p37014
aS'  template <int dim>'
p37015
aS'  void EulerProblem<dim>::Postprocessor::evaluate_vector_field('
p37016
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p37017
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p37018
aS'  {'
p37019
aS'    const unsigned int n_evaluation_points = inputs.solution_values.size();'
p37020
aS'    if (do_schlieren_plot == true)'
p37021
aS'      Assert(inputs.solution_gradients.size() == n_evaluation_points,'
p37022
aS'             ExcInternalError());'
p37023
aS'    Assert(computed_quantities.size() == n_evaluation_points,'
p37024
aS'           ExcInternalError());'
p37025
aS'    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError());'
p37026
aS'    Assert(computed_quantities[0].size() =='
p37027
aS'             dim + 2 + (do_schlieren_plot == true ? 1 : 0),'
p37028
aS'           ExcInternalError());'
p37029
aS'    for (unsigned int q = 0; q < n_evaluation_points; ++q)'
p37030
aS'      {'
p37031
aS'        Tensor<1, dim + 2> solution;'
p37032
aS'        for (unsigned int d = 0; d < dim + 2; ++d)'
p37033
aS'          solution[d] = inputs.solution_values[q](d);'
p37034
aS'        const double         density  = solution[0];'
p37035
aS'        const Tensor<1, dim> velocity = euler_velocity<dim>(solution);'
p37036
aS'        const double         pressure = euler_pressure<dim>(solution);'
p37037
aS'        for (unsigned int d = 0; d < dim; ++d)'
p37038
aS'          computed_quantities[q](d) = velocity[d];'
p37039
aS'        computed_quantities[q](dim)     = pressure;'
p37040
aS'        computed_quantities[q](dim + 1) = std::sqrt(gamma * pressure / density);'
p37041
aS'        if (do_schlieren_plot == true)'
p37042
aS'          computed_quantities[q](dim + 2) ='
p37043
aS'            inputs.solution_gradients[q][0] * inputs.solution_gradients[q][0];'
p37044
aS'      }'
p37045
aS'  }'
p37046
aS'  template <int dim>'
p37047
aS'  std::vector<std::string> EulerProblem<dim>::Postprocessor::get_names() const'
p37048
aS'  {'
p37049
aS'    std::vector<std::string> names;'
p37050
aS'    for (unsigned int d = 0; d < dim; ++d)'
p37051
aS'      names.emplace_back("velocity");'
p37052
aS'    names.emplace_back("pressure");'
p37053
aS'    names.emplace_back("speed_of_sound");'
p37054
aS'    if (do_schlieren_plot == true)'
p37055
aS'      names.emplace_back("schlieren_plot");'
p37056
aS'    return names;'
p37057
aS'  }'
p37058
aS'  template <int dim>'
p37059
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p37060
aS'  EulerProblem<dim>::Postprocessor::get_data_component_interpretation() const'
p37061
aS'  {'
p37062
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p37063
aS'      interpretation;'
p37064
aS'    for (unsigned int d = 0; d < dim; ++d)'
p37065
aS'      interpretation.push_back('
p37066
aS'        DataComponentInterpretation::component_is_part_of_vector);'
p37067
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p37068
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p37069
aS'    if (do_schlieren_plot == true)'
p37070
aS'      interpretation.push_back('
p37071
aS'        DataComponentInterpretation::component_is_scalar);'
p37072
aS'    return interpretation;'
p37073
aS'  }'
p37074
aS'  template <int dim>'
p37075
aS'  UpdateFlags EulerProblem<dim>::Postprocessor::get_needed_update_flags() const'
p37076
aS'  {'
p37077
aS'    if (do_schlieren_plot == true)'
p37078
aS'      return update_values | update_gradients;'
p37079
aS'    else'
p37080
aS'      return update_values;'
p37081
aS'  }'
p37082
aS'  template <int dim>'
p37083
aS'  EulerProblem<dim>::EulerProblem()'
p37084
aS'    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p37085
aS'#ifdef DEAL_II_WITH_P4EST'
p37086
aS'    , triangulation(MPI_COMM_WORLD)'
p37087
aS'#endif'
p37088
aS'    , fe(FE_DGQ<dim>(fe_degree), dim + 2)'
p37089
aS'    , mapping(fe_degree)'
p37090
aS'    , dof_handler(triangulation)'
p37091
aS'    , timer(pcout, TimerOutput::never, TimerOutput::wall_times)'
p37092
aS'    , euler_operator(timer)'
p37093
aS'    , time(0)'
p37094
aS'    , time_step(0)'
p37095
aS'  {}'
p37096
aS'  template <int dim>'
p37097
aS'  void EulerProblem<dim>::make_grid_and_dofs()'
p37098
aS'  {'
p37099
aS'    switch (testcase)'
p37100
aS'      {'
p37101
aS'        case 0:'
p37102
aS'          {'
p37103
aS'            Point<dim> lower_left;'
p37104
aS'            for (unsigned int d = 1; d < dim; ++d)'
p37105
aS'              lower_left[d] = -5;'
p37106
aS'            Point<dim> upper_right;'
p37107
aS'            upper_right[0] = 10;'
p37108
aS'            for (unsigned int d = 1; d < dim; ++d)'
p37109
aS'              upper_right[d] = 5;'
p37110
aS'            GridGenerator::hyper_rectangle(triangulation,'
p37111
aS'                                           lower_left,'
p37112
aS'                                           upper_right);'
p37113
aS'            triangulation.refine_global(2);'
p37114
aS'            euler_operator.set_inflow_boundary('
p37115
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p37116
aS'            break;'
p37117
aS'          }'
p37118
aS'        case 1:'
p37119
aS'          {'
p37120
aS'            GridGenerator::channel_with_cylinder('
p37121
aS'              triangulation, 0.03, 1, 0, true);'
p37122
aS'            euler_operator.set_inflow_boundary('
p37123
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p37124
aS'            euler_operator.set_subsonic_outflow_boundary('
p37125
aS'              1, std::make_unique<ExactSolution<dim>>(0));'
p37126
aS'            euler_operator.set_wall_boundary(2);'
p37127
aS'            euler_operator.set_wall_boundary(3);'
p37128
aS'            if (dim == 3)'
p37129
aS'              euler_operator.set_body_force('
p37130
aS'                std::make_unique<Functions::ConstantFunction<dim>>('
p37131
aS'                  std::vector<double>({0., 0., -0.2})));'
p37132
aS'            break;'
p37133
aS'          }'
p37134
aS'        default:'
p37135
aS'          Assert(false, ExcNotImplemented());'
p37136
aS'      }'
p37137
aS'    triangulation.refine_global(n_global_refinements);'
p37138
aS'    dof_handler.distribute_dofs(fe);'
p37139
aS'    euler_operator.reinit(mapping, dof_handler);'
p37140
aS'    euler_operator.initialize_vector(solution);'
p37141
aS'    std::locale s = pcout.get_stream().getloc();'
p37142
aS'    pcout.get_stream().imbue(std::locale(""));'
p37143
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p37144
aS'          << " ( = " << (dim + 2) << " [vars] x "'
p37145
aS'          << triangulation.n_global_active_cells() << " [cells] x "'
p37146
aS'          << Utilities::pow(fe_degree + 1, dim) << " [dofs/cell/var] )"'
p37147
aS'          << std::endl;'
p37148
aS'    pcout.get_stream().imbue(s);'
p37149
aS'  }'
p37150
aS'  template <int dim>'
p37151
aS'  void EulerProblem<dim>::output_results(const unsigned int result_number)'
p37152
aS'  {'
p37153
aS'    const std::array<double, 3> errors ='
p37154
aS'      euler_operator.compute_errors(ExactSolution<dim>(time), solution);'
p37155
aS'    const std::string quantity_name = testcase == 0 ? "error" : "norm";'
p37156
aS'    pcout << "Time:" << std::setw(8) << std::setprecision(3) << time'
p37157
aS'          << ", dt: " << std::setw(8) << std::setprecision(2) << time_step'
p37158
aS'          << ", " << quantity_name << " rho: " << std::setprecision(4)'
p37159
aS'          << std::setw(10) << errors[0] << ", rho * u: " << std::setprecision(4)'
p37160
aS'          << std::setw(10) << errors[1] << ", energy:" << std::setprecision(4)'
p37161
aS'          << std::setw(10) << errors[2] << std::endl;'
p37162
aS'    {'
p37163
aS'      TimerOutput::Scope t(timer, "output");'
p37164
aS'      Postprocessor postprocessor;'
p37165
aS'      DataOut<dim>  data_out;'
p37166
aS'      DataOutBase::VtkFlags flags;'
p37167
aS'      flags.write_higher_order_cells = true;'
p37168
aS'      data_out.set_flags(flags);'
p37169
aS'      data_out.attach_dof_handler(dof_handler);'
p37170
aS'      {'
p37171
aS'        std::vector<std::string> names;'
p37172
aS'        names.emplace_back("density");'
p37173
aS'        for (unsigned int d = 0; d < dim; ++d)'
p37174
aS'          names.emplace_back("momentum");'
p37175
aS'        names.emplace_back("energy");'
p37176
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p37177
aS'          interpretation;'
p37178
aS'        interpretation.push_back('
p37179
aS'          DataComponentInterpretation::component_is_scalar);'
p37180
aS'        for (unsigned int d = 0; d < dim; ++d)'
p37181
aS'          interpretation.push_back('
p37182
aS'            DataComponentInterpretation::component_is_part_of_vector);'
p37183
aS'        interpretation.push_back('
p37184
aS'          DataComponentInterpretation::component_is_scalar);'
p37185
aS'        data_out.add_data_vector(dof_handler, solution, names, interpretation);'
p37186
aS'      }'
p37187
aS'      data_out.add_data_vector(solution, postprocessor);'
p37188
aS'      LinearAlgebra::distributed::Vector<Number> reference;'
p37189
aS'      if (testcase == 0 && dim == 2)'
p37190
aS'        {'
p37191
aS'          reference.reinit(solution);'
p37192
aS'          euler_operator.project(ExactSolution<dim>(time), reference);'
p37193
aS'          reference.sadd(-1., 1, solution);'
p37194
aS'          std::vector<std::string> names;'
p37195
aS'          names.emplace_back("error_density");'
p37196
aS'          for (unsigned int d = 0; d < dim; ++d)'
p37197
aS'            names.emplace_back("error_momentum");'
p37198
aS'          names.emplace_back("error_energy");'
p37199
aS'          std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p37200
aS'            interpretation;'
p37201
aS'          interpretation.push_back('
p37202
aS'            DataComponentInterpretation::component_is_scalar);'
p37203
aS'          for (unsigned int d = 0; d < dim; ++d)'
p37204
aS'            interpretation.push_back('
p37205
aS'              DataComponentInterpretation::component_is_part_of_vector);'
p37206
aS'          interpretation.push_back('
p37207
aS'            DataComponentInterpretation::component_is_scalar);'
p37208
aS'          data_out.add_data_vector(dof_handler,'
p37209
aS'                                   reference,'
p37210
aS'                                   names,'
p37211
aS'                                   interpretation);'
p37212
aS'        }'
p37213
aS'      Vector<double> mpi_owner(triangulation.n_active_cells());'
p37214
aS'      mpi_owner = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);'
p37215
aS'      data_out.add_data_vector(mpi_owner, "owner");'
p37216
aS'      data_out.build_patches(mapping,'
p37217
aS'                             fe.degree,'
p37218
aS'                             DataOut<dim>::curved_inner_cells);'
p37219
aS'      const std::string filename ='
p37220
aS'        "solution_" + Utilities::int_to_string(result_number, 3) + ".vtu";'
p37221
aS'      data_out.write_vtu_in_parallel(filename, MPI_COMM_WORLD);'
p37222
aS'    }'
p37223
aS'  }'
p37224
aS'  template <int dim>'
p37225
aS'  void EulerProblem<dim>::run()'
p37226
aS'  {'
p37227
aS'    {'
p37228
aS'      const unsigned int n_vect_number = VectorizedArray<Number>::size();'
p37229
aS'      const unsigned int n_vect_bits   = 8 * sizeof(Number) * n_vect_number;'
p37230
aS'      pcout << "Running with "'
p37231
aS'            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD)'
p37232
aS'            << " MPI processes" << std::endl;'
p37233
aS'      pcout << "Vectorization over " << n_vect_number << " "'
p37234
aS'            << (std::is_same<Number, double>::value ? "doubles" : "floats")'
p37235
aS'            << " = " << n_vect_bits << " bits ("'
p37236
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p37237
aS'            << std::endl;'
p37238
aS'    }'
p37239
aS'    make_grid_and_dofs();'
p37240
aS'    const LowStorageRungeKuttaIntegrator integrator(lsrk_scheme);'
p37241
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_1;'
p37242
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_2;'
p37243
aS'    rk_register_1.reinit(solution);'
p37244
aS'    rk_register_2.reinit(solution);'
p37245
aS'    euler_operator.project(ExactSolution<dim>(time), solution);'
p37246
aS'    double min_vertex_distance = std::numeric_limits<double>::max();'
p37247
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p37248
aS'      if (cell->is_locally_owned())'
p37249
aS'        min_vertex_distance ='
p37250
aS'          std::min(min_vertex_distance, cell->minimum_vertex_distance());'
p37251
aS'    min_vertex_distance ='
p37252
aS'      Utilities::MPI::min(min_vertex_distance, MPI_COMM_WORLD);'
p37253
aS'    time_step = courant_number * integrator.n_stages() /'
p37254
aS'                euler_operator.compute_cell_transport_speed(solution);'
p37255
aS'    pcout << "Time step size: " << time_step'
p37256
aS'          << ", minimal h: " << min_vertex_distance'
p37257
aS'          << ", initial transport scaling: "'
p37258
aS'          << 1. / euler_operator.compute_cell_transport_speed(solution)'
p37259
aS'          << std::endl'
p37260
aS'          << std::endl;'
p37261
aS'    output_results(0);'
p37262
aS'    unsigned int timestep_number = 0;'
p37263
aS'    while (time < final_time - 1e-12)'
p37264
aS'      {'
p37265
aS'        ++timestep_number;'
p37266
aS'        if (timestep_number % 5 == 0)'
p37267
aS'          time_step ='
p37268
aS'            courant_number * integrator.n_stages() /'
p37269
aS'            Utilities::truncate_to_n_digits('
p37270
aS'              euler_operator.compute_cell_transport_speed(solution), 3);'
p37271
aS'        {'
p37272
aS'          TimerOutput::Scope t(timer, "rk time stepping total");'
p37273
aS'          integrator.perform_time_step(euler_operator,'
p37274
aS'                                       time,'
p37275
aS'                                       time_step,'
p37276
aS'                                       solution,'
p37277
aS'                                       rk_register_1,'
p37278
aS'                                       rk_register_2);'
p37279
aS'        }'
p37280
aS'        time += time_step;'
p37281
aS'        if (static_cast<int>(time / output_tick) !='
p37282
aS'              static_cast<int>((time - time_step) / output_tick) ||'
p37283
aS'            time >= final_time - 1e-12)'
p37284
aS'          output_results('
p37285
aS'            static_cast<unsigned int>(std::round(time / output_tick)));'
p37286
aS'      }'
p37287
aS'    timer.print_wall_time_statistics(MPI_COMM_WORLD);'
p37288
aS'    pcout << std::endl;'
p37289
aS'  }'
p37290
aS'} // namespace Euler_DG'
p37291
aS'int main(int argc, char **argv)'
p37292
ag9
aS'  using namespace Euler_DG;'
p37293
aS'  using namespace dealii;'
p37294
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p37295
aS'  try'
p37296
aS'    {'
p37297
aS'      deallog.depth_console(0);'
p37298
aS'      EulerProblem<dimension> euler_problem;'
p37299
aS'      euler_problem.run();'
p37300
aS'    }'
p37301
aS'  catch (std::exception &exc)'
p37302
aS'    {'
p37303
aS'      std::cerr << std::endl'
p37304
aS'                << std::endl'
p37305
aS'                << "----------------------------------------------------"'
p37306
aS'                << std::endl;'
p37307
aS'      std::cerr << "Exception on processing: " << std::endl'
p37308
aS'                << exc.what() << std::endl'
p37309
aS'                << "Aborting!" << std::endl'
p37310
aS'                << "----------------------------------------------------"'
p37311
aS'                << std::endl;'
p37312
aS'      return 1;'
p37313
aS'    }'
p37314
aS'  catch (...)'
p37315
aS'    {'
p37316
aS'      std::cerr << std::endl'
p37317
aS'                << std::endl'
p37318
aS'                << "----------------------------------------------------"'
p37319
aS'                << std::endl;'
p37320
aS'      std::cerr << "Unknown exception!" << std::endl'
p37321
aS'                << "Aborting!" << std::endl'
p37322
aS'                << "----------------------------------------------------"'
p37323
aS'                << std::endl;'
p37324
aS'      return 1;'
p37325
aS'    }'
p37326
aS'  return 0;'
p37327
ag17
aS'#include <deal.II/base/bounding_box.h>'
p37328
aS'#include <deal.II/base/conditional_ostream.h>'
p37329
aS'#include <deal.II/base/discrete_time.h>'
p37330
aS'#include <deal.II/base/mpi.h>'
p37331
aS'#include <deal.II/base/parameter_acceptor.h>'
p37332
aS'#include <deal.II/base/timer.h>'
p37333
aS'#include <deal.II/distributed/cell_weights.h>'
p37334
aS'#include <deal.II/distributed/solution_transfer.h>'
p37335
aS'#include <deal.II/distributed/tria.h>'
p37336
aS'#include <deal.II/dofs/dof_handler.h>'
p37337
aS'#include <deal.II/dofs/dof_tools.h>'
p37338
aS'#include <deal.II/fe/fe_q.h>'
p37339
aS'#include <deal.II/fe/fe_system.h>'
p37340
aS'#include <deal.II/fe/mapping_q.h>'
p37341
aS'#include <deal.II/grid/grid_generator.h>'
p37342
aS'#include <deal.II/grid/grid_tools.h>'
p37343
aS'#include <deal.II/lac/la_parallel_vector.h>'
p37344
aS'#include <deal.II/lac/vector.h>'
p37345
aS'#include <deal.II/numerics/data_out.h>'
p37346
aS'#include <deal.II/numerics/vector_tools.h>'
p37347
aS'#include <deal.II/particles/particle_handler.h>'
p37348
aS'#include <deal.II/particles/generators.h>'
p37349
aS'#include <deal.II/particles/data_out.h>'
p37350
aS'#include <cmath>'
p37351
aS'#include <iostream>'
p37352
aS'namespace Step68'
p37353
ag9
aS'  using namespace dealii;'
p37354
aS'  class ParticleTrackingParameters : public ParameterAcceptor'
p37355
aS'  {'
p37356
aS'  public:'
p37357
aS'    ParticleTrackingParameters();'
p37358
aS'    std::string output_directory = "./";'
p37359
aS'    unsigned int velocity_degree       = 1;'
p37360
aS'    double       time_step             = 0.002;'
p37361
aS'    double       final_time            = 4.0;'
p37362
aS'    unsigned int output_frequency      = 10;'
p37363
aS'    unsigned int repartition_frequency = 5;'
p37364
aS'    unsigned int fluid_refinement              = 4;'
p37365
aS'    unsigned int particle_insertion_refinement = 3;'
p37366
aS'  };'
p37367
aS'  ParticleTrackingParameters::ParticleTrackingParameters()'
p37368
aS'    : ParameterAcceptor("Particle Tracking Problem/")'
p37369
aS'  {'
p37370
aS'    add_parameter('
p37371
aS'      "Velocity degree", velocity_degree, "", prm, Patterns::Integer(1));'
p37372
aS'    add_parameter("Output frequency",'
p37373
aS'                  output_frequency,'
p37374
aS'                  "Iteration frequency at which output results are written",'
p37375
aS'                  prm,'
p37376
aS'                  Patterns::Integer(1));'
p37377
aS'    add_parameter("Repartition frequency",'
p37378
aS'                  repartition_frequency,'
p37379
aS'                  "Iteration frequency at which the mesh is load balanced",'
p37380
aS'                  prm,'
p37381
aS'                  Patterns::Integer(1));'
p37382
aS'    add_parameter("Output directory", output_directory);'
p37383
aS'    add_parameter("Time step", time_step, "", prm, Patterns::Double());'
p37384
aS'    add_parameter("Final time",'
p37385
aS'                  final_time,'
p37386
aS'                  "End time of the simulation",'
p37387
aS'                  prm,'
p37388
aS'                  Patterns::Double());'
p37389
aS'    add_parameter("Fluid refinement",'
p37390
aS'                  fluid_refinement,'
p37391
aS'                  "Refinement level of the fluid domain",'
p37392
aS'                  prm,'
p37393
aS'                  Patterns::Integer(0));'
p37394
aS'    add_parameter('
p37395
aS'      "Particle insertion refinement",'
p37396
aS'      particle_insertion_refinement,'
p37397
aS'      "Refinement of the volumetric mesh used to insert the particles",'
p37398
aS'      prm,'
p37399
aS'      Patterns::Integer(0));'
p37400
aS'  }'
p37401
aS'  template <int dim>'
p37402
aS'  class Vortex : public Function<dim>'
p37403
aS'  {'
p37404
aS'  public:'
p37405
aS'    Vortex()'
p37406
aS'      : Function<dim>(dim)'
p37407
aS'    {}'
p37408
aS'    virtual void vector_value(const Point<dim> &point,'
p37409
aS'                              Vector<double> &  values) const override;'
p37410
aS'  };'
p37411
aS'  template <int dim>'
p37412
aS'  void Vortex<dim>::vector_value(const Point<dim> &point,'
p37413
aS'                                 Vector<double> &  values) const'
p37414
aS'  {'
p37415
aS'    const double T = 4;'
p37416
aS'    const double t = this->get_time();'
p37417
aS'    const double px = numbers::PI * point(0);'
p37418
aS'    const double py = numbers::PI * point(1);'
p37419
aS'    const double pt = numbers::PI / T * t;'
p37420
aS'    values[0] = -2 * cos(pt) * pow(sin(px), 2) * sin(py) * cos(py);'
p37421
aS'    values[1] = 2 * cos(pt) * pow(sin(py), 2) * sin(px) * cos(px);'
p37422
aS'    if (dim == 3)'
p37423
aS'      {'
p37424
aS'        values[2] = 0;'
p37425
aS'      }'
p37426
aS'  }'
p37427
aS'  template <int dim>'
p37428
aS'  class ParticleTracking'
p37429
aS'  {'
p37430
aS'  public:'
p37431
aS'    ParticleTracking(const ParticleTrackingParameters &par,'
p37432
aS'                     const bool                        interpolated_velocity);'
p37433
aS'    void run();'
p37434
aS'  private:'
p37435
aS'    void generate_particles();'
p37436
aS'    void setup_background_dofs();'
p37437
aS'    void interpolate_function_to_field();'
p37438
aS'    void euler_step_interpolated(const double dt);'
p37439
aS'    void euler_step_analytical(const double dt);'
p37440
aS'    unsigned int cell_weight('
p37441
aS'      const typename parallel::distributed::Triangulation<dim>::cell_iterator'
p37442
aS'        &cell,'
p37443
aS'      const typename parallel::distributed::Triangulation<dim>::CellStatus'
p37444
aS'        status) const;'
p37445
aS'    void output_particles(const unsigned int it);'
p37446
aS'    void output_background(const unsigned int it);'
p37447
aS'    const ParticleTrackingParameters &par;'
p37448
aS'    MPI_Comm                                  mpi_communicator;'
p37449
aS'    parallel::distributed::Triangulation<dim> background_triangulation;'
p37450
aS'    Particles::ParticleHandler<dim>           particle_handler;'
p37451
aS'    DoFHandler<dim>                            fluid_dh;'
p37452
aS'    FESystem<dim>                              fluid_fe;'
p37453
aS'    MappingQ1<dim>                             mapping;'
p37454
aS'    LinearAlgebra::distributed::Vector<double> velocity_field;'
p37455
aS'    Vortex<dim> velocity;'
p37456
aS'    ConditionalOStream pcout;'
p37457
aS'    bool interpolated_velocity;'
p37458
aS'  };'
p37459
aS'  template <int dim>'
p37460
aS'  ParticleTracking<dim>::ParticleTracking(const ParticleTrackingParameters &par,'
p37461
aS'                                          const bool interpolated_velocity)'
p37462
aS'    : par(par)'
p37463
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p37464
aS'    , background_triangulation(mpi_communicator)'
p37465
aS'    , fluid_dh(background_triangulation)'
p37466
aS'    , fluid_fe(FE_Q<dim>(par.velocity_degree), dim)'
p37467
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p37468
aS'    , interpolated_velocity(interpolated_velocity)'
p37469
aS'  {}'
p37470
aS'  template <int dim>'
p37471
aS'  unsigned int ParticleTracking<dim>::cell_weight('
p37472
aS'    const typename parallel::distributed::Triangulation<dim>::cell_iterator'
p37473
aS'      &                                                                  cell,'
p37474
aS'    const typename parallel::distributed::Triangulation<dim>::CellStatus status)'
p37475
aS'    const'
p37476
aS'  {'
p37477
aS'    if (!cell->is_locally_owned())'
p37478
aS'      return 0;'
p37479
aS'    const unsigned int particle_weight = 10000;'
p37480
aS'    if (status == parallel::distributed::Triangulation<dim>::CELL_PERSIST ||'
p37481
aS'        status == parallel::distributed::Triangulation<dim>::CELL_REFINE)'
p37482
aS'      {'
p37483
aS'        const unsigned int n_particles_in_cell ='
p37484
aS'          particle_handler.n_particles_in_cell(cell);'
p37485
aS'        return n_particles_in_cell * particle_weight;'
p37486
aS'      }'
p37487
aS'    else if (status == parallel::distributed::Triangulation<dim>::CELL_COARSEN)'
p37488
aS'      {'
p37489
aS'        unsigned int n_particles_in_cell = 0;'
p37490
aS'        for (unsigned int child_index = 0; child_index < cell->n_children();'
p37491
aS'             ++child_index)'
p37492
aS'          n_particles_in_cell +='
p37493
aS'            particle_handler.n_particles_in_cell(cell->child(child_index));'
p37494
aS'        return n_particles_in_cell * particle_weight;'
p37495
aS'      }'
p37496
aS'    Assert(false, ExcInternalError());'
p37497
aS'    return 0;'
p37498
aS'  }'
p37499
aS'  template <int dim>'
p37500
aS'  void ParticleTracking<dim>::generate_particles()'
p37501
aS'  {'
p37502
aS'    GridGenerator::hyper_cube(background_triangulation, 0, 1);'
p37503
aS'    background_triangulation.refine_global(par.fluid_refinement);'
p37504
aS'    background_triangulation.signals.cell_weight.connect('
p37505
aS'      [&]('
p37506
aS'        const typename parallel::distributed::Triangulation<dim>::cell_iterator'
p37507
aS'          &cell,'
p37508
aS'        const typename parallel::distributed::Triangulation<dim>::CellStatus'
p37509
aS'          status) -> unsigned int { return this->cell_weight(cell, status); });'
p37510
aS'    background_triangulation.signals.pre_distributed_repartition.connect('
p37511
aS'      [this]() { this->particle_handler.register_store_callback_function(); });'
p37512
aS'    background_triangulation.signals.post_distributed_repartition.connect('
p37513
aS'      [&]() { this->particle_handler.register_load_callback_function(false); });'
p37514
aS'    particle_handler.initialize(background_triangulation, mapping, 1 + dim);'
p37515
aS'    Point<dim> center;'
p37516
aS'    center[0] = 0.5;'
p37517
aS'    center[1] = 0.75;'
p37518
aS'    if (dim == 3)'
p37519
aS'      center[2] = 0.5;'
p37520
aS'    const double outer_radius = 0.15;'
p37521
aS'    const double inner_radius = 0.01;'
p37522
aS'    parallel::distributed::Triangulation<dim> particle_triangulation('
p37523
aS'      MPI_COMM_WORLD);'
p37524
aS'    GridGenerator::hyper_shell('
p37525
aS'      particle_triangulation, center, inner_radius, outer_radius, 6);'
p37526
aS'    particle_triangulation.refine_global(par.particle_insertion_refinement);'
p37527
aS'    const auto my_bounding_box = GridTools::compute_mesh_predicate_bounding_box('
p37528
aS'      background_triangulation, IteratorFilters::LocallyOwnedCell());'
p37529
aS'    const auto global_bounding_boxes ='
p37530
aS'      Utilities::MPI::all_gather(MPI_COMM_WORLD, my_bounding_box);'
p37531
aS'    std::vector<std::vector<double>> properties('
p37532
aS'      particle_triangulation.n_locally_owned_active_cells(),'
p37533
aS'      std::vector<double>(dim + 1, 0.));'
p37534
aS'    Particles::Generators::quadrature_points(particle_triangulation,'
p37535
aS'                                             QMidpoint<dim>(),'
p37536
aS'                                             global_bounding_boxes,'
p37537
aS'                                             particle_handler,'
p37538
aS'                                             mapping,'
p37539
aS'                                             properties);'
p37540
aS'    pcout << "Number of particles inserted: "'
p37541
aS'          << particle_handler.n_global_particles() << std::endl;'
p37542
aS'  }'
p37543
aS'  template <int dim>'
p37544
aS'  void ParticleTracking<dim>::setup_background_dofs()'
p37545
aS'  {'
p37546
aS'    fluid_dh.distribute_dofs(fluid_fe);'
p37547
aS'    const IndexSet locally_owned_dofs = fluid_dh.locally_owned_dofs();'
p37548
aS'    IndexSet       locally_relevant_dofs;'
p37549
aS'    DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs);'
p37550
aS'    velocity_field.reinit(locally_owned_dofs,'
p37551
aS'                          locally_relevant_dofs,'
p37552
aS'                          mpi_communicator);'
p37553
aS'  }'
p37554
aS'  template <int dim>'
p37555
aS'  void ParticleTracking<dim>::interpolate_function_to_field()'
p37556
aS'  {'
p37557
aS'    velocity_field.zero_out_ghost_values();'
p37558
aS'    VectorTools::interpolate(mapping, fluid_dh, velocity, velocity_field);'
p37559
aS'    velocity_field.update_ghost_values();'
p37560
aS'  }'
p37561
aS'  template <int dim>'
p37562
aS'  void ParticleTracking<dim>::euler_step_analytical(const double dt)'
p37563
aS'  {'
p37564
aS'    const unsigned int this_mpi_rank ='
p37565
aS'      Utilities::MPI::this_mpi_process(mpi_communicator);'
p37566
aS'    Vector<double> particle_velocity(dim);'
p37567
aS'    for (auto &particle : particle_handler)'
p37568
aS'      {'
p37569
aS'        Point<dim> particle_location = particle.get_location();'
p37570
aS'        velocity.vector_value(particle_location, particle_velocity);'
p37571
aS'        for (int d = 0; d < dim; ++d)'
p37572
aS'          particle_location[d] += particle_velocity[d] * dt;'
p37573
aS'        particle.set_location(particle_location);'
p37574
aS'        ArrayView<double> properties = particle.get_properties();'
p37575
aS'        for (int d = 0; d < dim; ++d)'
p37576
aS'          properties[d] = particle_velocity[d];'
p37577
aS'        properties[dim] = this_mpi_rank;'
p37578
aS'      }'
p37579
aS'  }'
p37580
aS'  template <int dim>'
p37581
aS'  void ParticleTracking<dim>::euler_step_interpolated(const double dt)'
p37582
aS'  {'
p37583
aS'    Vector<double> local_dof_values(fluid_fe.dofs_per_cell);'
p37584
aS'    auto particle = particle_handler.begin();'
p37585
aS'    while (particle != particle_handler.end())'
p37586
aS'      {'
p37587
aS'        const auto cell ='
p37588
aS'          particle->get_surrounding_cell(background_triangulation);'
p37589
aS'        const auto dh_cell ='
p37590
aS'          typename DoFHandler<dim>::cell_iterator(*cell, &fluid_dh);'
p37591
aS'        dh_cell->get_dof_values(velocity_field, local_dof_values);'
p37592
aS'        const auto pic = particle_handler.particles_in_cell(cell);'
p37593
aS'        Assert(pic.begin() == particle, ExcInternalError());'
p37594
aS'        for (auto &p : pic)'
p37595
aS'          {'
p37596
aS'            const Point<dim> reference_location = p.get_reference_location();'
p37597
aS'            Tensor<1, dim>   particle_velocity;'
p37598
aS'            for (unsigned int j = 0; j < fluid_fe.dofs_per_cell; ++j)'
p37599
aS'              {'
p37600
aS'                const auto comp_j = fluid_fe.system_to_component_index(j);'
p37601
aS'                particle_velocity[comp_j.first] +='
p37602
aS'                  fluid_fe.shape_value(j, reference_location) *'
p37603
aS'                  local_dof_values[j];'
p37604
aS'              }'
p37605
aS'            Point<dim> particle_location = particle->get_location();'
p37606
aS'            for (int d = 0; d < dim; ++d)'
p37607
aS'              particle_location[d] += particle_velocity[d] * dt;'
p37608
aS'            p.set_location(particle_location);'
p37609
aS'            ArrayView<double> properties = p.get_properties();'
p37610
aS'            for (int d = 0; d < dim; ++d)'
p37611
aS'              properties[d] = particle_velocity[d];'
p37612
aS'            properties[dim] ='
p37613
aS'              Utilities::MPI::this_mpi_process(mpi_communicator);'
p37614
aS'            ++particle;'
p37615
aS'          }'
p37616
aS'      }'
p37617
aS'  }'
p37618
aS'  template <int dim>'
p37619
aS'  void ParticleTracking<dim>::output_particles(const unsigned int it)'
p37620
aS'  {'
p37621
aS'    Particles::DataOut<dim, dim> particle_output;'
p37622
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p37623
aS'    solution_names.push_back("process_id");'
p37624
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p37625
aS'      data_component_interpretation('
p37626
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p37627
aS'    data_component_interpretation.push_back('
p37628
aS'      DataComponentInterpretation::component_is_scalar);'
p37629
aS'    particle_output.build_patches(particle_handler,'
p37630
aS'                                  solution_names,'
p37631
aS'                                  data_component_interpretation);'
p37632
aS'    const std::string output_folder(par.output_directory);'
p37633
aS'    const std::string file_name(interpolated_velocity ?'
p37634
aS'                                  "interpolated-particles" :'
p37635
aS'                                  "analytical-particles");'
p37636
aS'    pcout << "Writing particle output file: " << file_name << "-" << it'
p37637
aS'          << std::endl;'
p37638
aS'    particle_output.write_vtu_with_pvtu_record('
p37639
aS'      output_folder, file_name, it, mpi_communicator, 6);'
p37640
aS'  }'
p37641
aS'  template <int dim>'
p37642
aS'  void ParticleTracking<dim>::output_background(const unsigned int it)'
p37643
aS'  {'
p37644
aS'    std::vector<std::string> solution_names(dim, "velocity");'
p37645
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p37646
aS'      data_component_interpretation('
p37647
aS'        dim, DataComponentInterpretation::component_is_part_of_vector);'
p37648
aS'    DataOut<dim> data_out;'
p37649
aS'    data_out.attach_dof_handler(fluid_dh);'
p37650
aS'    data_out.add_data_vector(velocity_field,'
p37651
aS'                             solution_names,'
p37652
aS'                             DataOut<dim>::type_dof_data,'
p37653
aS'                             data_component_interpretation);'
p37654
aS'    Vector<float> subdomain(background_triangulation.n_active_cells());'
p37655
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p37656
aS'      subdomain(i) = background_triangulation.locally_owned_subdomain();'
p37657
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p37658
aS'    data_out.build_patches(mapping);'
p37659
aS'    const std::string output_folder(par.output_directory);'
p37660
aS'    const std::string file_name("background");'
p37661
aS'    pcout << "Writing background field file: " << file_name << "-" << it'
p37662
aS'          << std::endl;'
p37663
aS'    data_out.write_vtu_with_pvtu_record('
p37664
aS'      output_folder, file_name, it, mpi_communicator, 6);'
p37665
aS'  }'
p37666
aS'  template <int dim>'
p37667
aS'  void ParticleTracking<dim>::run()'
p37668
aS'  {'
p37669
aS'    DiscreteTime discrete_time(0, par.final_time, par.time_step);'
p37670
aS'    generate_particles();'
p37671
aS'    pcout << "Repartitioning triangulation after particle generation"'
p37672
aS'          << std::endl;'
p37673
aS'    background_triangulation.repartition();'
p37674
aS'    if (interpolated_velocity)'
p37675
aS'      {'
p37676
aS'        setup_background_dofs();'
p37677
aS'        interpolate_function_to_field();'
p37678
aS'        euler_step_interpolated(0.);'
p37679
aS'      }'
p37680
aS'    else'
p37681
aS'      euler_step_analytical(0.);'
p37682
aS'    output_particles(discrete_time.get_step_number());'
p37683
aS'    if (interpolated_velocity)'
p37684
aS'      output_background(discrete_time.get_step_number());'
p37685
aS'    while (!discrete_time.is_at_end())'
p37686
aS'      {'
p37687
aS'        discrete_time.advance_time();'
p37688
aS'        velocity.set_time(discrete_time.get_previous_time());'
p37689
aS'        if ((discrete_time.get_step_number() % par.repartition_frequency) == 0)'
p37690
aS'          {'
p37691
aS'            background_triangulation.repartition();'
p37692
aS'            if (interpolated_velocity)'
p37693
aS'              setup_background_dofs();'
p37694
aS'          }'
p37695
aS'        if (interpolated_velocity)'
p37696
aS'          {'
p37697
aS'            interpolate_function_to_field();'
p37698
aS'            euler_step_interpolated(discrete_time.get_previous_step_size());'
p37699
aS'          }'
p37700
aS'        else'
p37701
aS'          euler_step_analytical(discrete_time.get_previous_step_size());'
p37702
aS'        particle_handler.sort_particles_into_subdomains_and_cells();'
p37703
aS'        if ((discrete_time.get_step_number() % par.output_frequency) == 0)'
p37704
aS'          {'
p37705
aS'            output_particles(discrete_time.get_step_number());'
p37706
aS'            if (interpolated_velocity)'
p37707
aS'              output_background(discrete_time.get_step_number());'
p37708
aS'          }'
p37709
aS'      }'
p37710
aS'  }'
p37711
aS'} // namespace Step68'
p37712
aS'int main(int argc, char *argv[])'
p37713
ag9
aS'  using namespace Step68;'
p37714
aS'  using namespace dealii;'
p37715
aS'  deallog.depth_console(1);'
p37716
aS'  try'
p37717
aS'    {'
p37718
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p37719
aS'      std::string prm_file;'
p37720
aS'      if (argc > 1)'
p37721
aS'        prm_file = argv[1];'
p37722
aS'      else'
p37723
aS'        prm_file = "parameters.prm";'
p37724
aS'      ParticleTrackingParameters par;'
p37725
aS'      ParameterAcceptor::initialize(prm_file);'
p37726
aS'      {'
p37727
aS'        Step68::ParticleTracking<2> particle_tracking(par, false);'
p37728
aS'        particle_tracking.run();'
p37729
aS'      }'
p37730
aS'      {'
p37731
aS'        Step68::ParticleTracking<2> particle_tracking(par, true);'
p37732
aS'        particle_tracking.run();'
p37733
aS'      }'
p37734
aS'    }'
p37735
aS'  catch (std::exception &exc)'
p37736
aS'    {'
p37737
aS'      std::cerr << std::endl'
p37738
aS'                << std::endl'
p37739
aS'                << "----------------------------------------------------"'
p37740
aS'                << std::endl;'
p37741
aS'      std::cerr << "Exception on processing: " << std::endl'
p37742
aS'                << exc.what() << std::endl'
p37743
aS'                << "Aborting!" << std::endl'
p37744
aS'                << "----------------------------------------------------"'
p37745
aS'                << std::endl;'
p37746
aS'      return 1;'
p37747
aS'    }'
p37748
aS'  catch (...)'
p37749
aS'    {'
p37750
aS'      std::cerr << std::endl'
p37751
aS'                << std::endl'
p37752
aS'                << "----------------------------------------------------"'
p37753
aS'                << std::endl;'
p37754
aS'      std::cerr << "Unknown exception!" << std::endl'
p37755
aS'                << "Aborting!" << std::endl'
p37756
aS'                << "----------------------------------------------------"'
p37757
aS'                << std::endl;'
p37758
aS'      return 1;'
p37759
aS'    }'
p37760
aS'  return 0;'
p37761
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p37762
aS'#include <deal.II/base/parallel.h>'
p37763
aS'#include <deal.II/base/parameter_acceptor.h>'
p37764
aS'#include <deal.II/base/partitioner.h>'
p37765
aS'#include <deal.II/base/quadrature.h>'
p37766
aS'#include <deal.II/base/timer.h>'
p37767
aS'#include <deal.II/base/work_stream.h>'
p37768
aS'#include <deal.II/distributed/tria.h>'
p37769
aS'#include <deal.II/dofs/dof_handler.h>'
p37770
aS'#include <deal.II/dofs/dof_renumbering.h>'
p37771
aS'#include <deal.II/dofs/dof_tools.h>'
p37772
aS'#include <deal.II/fe/fe.h>'
p37773
aS'#include <deal.II/fe/fe_q.h>'
p37774
aS'#include <deal.II/fe/fe_values.h>'
p37775
aS'#include <deal.II/fe/mapping.h>'
p37776
aS'#include <deal.II/fe/mapping_q.h>'
p37777
aS'#include <deal.II/grid/grid_generator.h>'
p37778
aS'#include <deal.II/grid/manifold_lib.h>'
p37779
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p37780
aS'#include <deal.II/lac/la_parallel_vector.h>'
p37781
aS'#include <deal.II/lac/sparse_matrix.h>'
p37782
aS'#include <deal.II/lac/sparse_matrix.templates.h>'
p37783
aS'#include <deal.II/lac/vector.h>'
p37784
aS'#include <deal.II/meshworker/scratch_data.h>'
p37785
aS'#include <deal.II/numerics/data_out.h>'
p37786
aS'#include <deal.II/numerics/vector_tools.h>'
p37787
aS'#include <boost/archive/binary_iarchive.hpp>'
p37788
aS'#include <boost/archive/binary_oarchive.hpp>'
p37789
aS'#include <deal.II/base/std_cxx20/iota_view.h>'
p37790
aS'#include <boost/range/iterator_range.hpp>'
p37791
aS'#include <cmath>'
p37792
aS'#include <fstream>'
p37793
aS'#include <future>'
p37794
aS'namespace Step69'
p37795
ag9
aS'  using namespace dealii;'
p37796
aS'  namespace Boundaries'
p37797
aS'  {'
p37798
aS'    constexpr types::boundary_id do_nothing = 0;'
p37799
aS'    constexpr types::boundary_id free_slip  = 1;'
p37800
aS'    constexpr types::boundary_id dirichlet  = 2;'
p37801
aS'  } // namespace Boundaries'
p37802
aS'  template <int dim>'
p37803
aS'  class Discretization : public ParameterAcceptor'
p37804
aS'  {'
p37805
aS'  public:'
p37806
aS'    Discretization(const MPI_Comm     mpi_communicator,'
p37807
aS'                   TimerOutput &      computing_timer,'
p37808
aS'                   const std::string &subsection = "Discretization");'
p37809
aS'    void setup();'
p37810
aS'    const MPI_Comm mpi_communicator;'
p37811
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p37812
aS'    const MappingQ<dim>   mapping;'
p37813
aS'    const FE_Q<dim>       finite_element;'
p37814
aS'    const QGauss<dim>     quadrature;'
p37815
aS'    const QGauss<dim - 1> face_quadrature;'
p37816
aS'  private:'
p37817
aS'    TimerOutput &computing_timer;'
p37818
aS'    double length;'
p37819
aS'    double height;'
p37820
aS'    double disk_position;'
p37821
aS'    double disk_diameter;'
p37822
aS'    unsigned int refinement;'
p37823
aS'  };'
p37824
aS'  template <int dim>'
p37825
aS'  class OfflineData : public ParameterAcceptor'
p37826
aS'  {'
p37827
aS'  public:'
p37828
aS'    using BoundaryNormalMap ='
p37829
aS'      std::map<types::global_dof_index,'
p37830
aS'               std::tuple<Tensor<1, dim>, types::boundary_id, Point<dim>>>;'
p37831
aS'    OfflineData(const MPI_Comm             mpi_communicator,'
p37832
aS'                TimerOutput &              computing_timer,'
p37833
aS'                const Discretization<dim> &discretization,'
p37834
aS'                const std::string &        subsection = "OfflineData");'
p37835
aS'    void setup();'
p37836
aS'    void assemble();'
p37837
aS'    DoFHandler<dim> dof_handler;'
p37838
aS'    std::shared_ptr<const Utilities::MPI::Partitioner> partitioner;'
p37839
aS'    unsigned int n_locally_owned;'
p37840
aS'    unsigned int n_locally_relevant;'
p37841
aS'    SparsityPattern sparsity_pattern;'
p37842
aS'    BoundaryNormalMap boundary_normal_map;'
p37843
aS'    SparseMatrix<double>                  lumped_mass_matrix;'
p37844
aS'    std::array<SparseMatrix<double>, dim> cij_matrix;'
p37845
aS'    std::array<SparseMatrix<double>, dim> nij_matrix;'
p37846
aS'    SparseMatrix<double>                  norm_matrix;'
p37847
aS'  private:'
p37848
aS'    const MPI_Comm mpi_communicator;'
p37849
aS'    TimerOutput &  computing_timer;'
p37850
aS'    SmartPointer<const Discretization<dim>> discretization;'
p37851
aS'  };'
p37852
aS'  template <int dim>'
p37853
aS'  class ProblemDescription'
p37854
aS'  {'
p37855
aS'  public:'
p37856
aS'    static constexpr unsigned int problem_dimension = 2 + dim;'
p37857
aS'    using state_type = Tensor<1, problem_dimension>;'
p37858
aS'    using flux_type  = Tensor<1, problem_dimension, Tensor<1, dim>>;'
p37859
aS'    const static std::array<std::string, problem_dimension> component_names;'
p37860
aS'    static constexpr double gamma = 7. / 5.;'
p37861
aS'    static DEAL_II_ALWAYS_INLINE inline Tensor<1, dim>'
p37862
aS'    momentum(const state_type &U);'
p37863
aS'    static DEAL_II_ALWAYS_INLINE inline double'
p37864
aS'    internal_energy(const state_type &U);'
p37865
aS'    static DEAL_II_ALWAYS_INLINE inline double pressure(const state_type &U);'
p37866
aS'    static DEAL_II_ALWAYS_INLINE inline double'
p37867
aS'    speed_of_sound(const state_type &U);'
p37868
aS'    static DEAL_II_ALWAYS_INLINE inline flux_type flux(const state_type &U);'
p37869
aS'    static DEAL_II_ALWAYS_INLINE inline double'
p37870
aS'    compute_lambda_max(const state_type &    U_i,'
p37871
aS'                       const state_type &    U_j,'
p37872
aS'                       const Tensor<1, dim> &n_ij);'
p37873
aS'  };'
p37874
aS'  template <int dim>'
p37875
aS'  class InitialValues : public ParameterAcceptor'
p37876
aS'  {'
p37877
aS'  public:'
p37878
aS'    using state_type = typename ProblemDescription<dim>::state_type;'
p37879
aS'    InitialValues(const std::string &subsection = "InitialValues");'
p37880
aS'    std::function<state_type(const Point<dim> &point, double t)> initial_state;'
p37881
aS'  private:'
p37882
aS'    void parse_parameters_callback();'
p37883
aS'    Tensor<1, dim> initial_direction;'
p37884
aS'    Tensor<1, 3>   initial_1d_state;'
p37885
aS'  };'
p37886
aS'  template <int dim>'
p37887
aS'  class TimeStepping : public ParameterAcceptor'
p37888
aS'  {'
p37889
aS'  public:'
p37890
aS'    static constexpr unsigned int problem_dimension ='
p37891
aS'      ProblemDescription<dim>::problem_dimension;'
p37892
aS'    using state_type = typename ProblemDescription<dim>::state_type;'
p37893
aS'    using flux_type  = typename ProblemDescription<dim>::flux_type;'
p37894
aS'    using vector_type ='
p37895
aS'      std::array<LinearAlgebra::distributed::Vector<double>, problem_dimension>;'
p37896
aS'    TimeStepping(const MPI_Comm            mpi_communicator,'
p37897
aS'                 TimerOutput &             computing_timer,'
p37898
aS'                 const OfflineData<dim> &  offline_data,'
p37899
aS'                 const InitialValues<dim> &initial_values,'
p37900
aS'                 const std::string &       subsection = "TimeStepping");'
p37901
aS'    void prepare();'
p37902
aS'    double make_one_step(vector_type &U, double t);'
p37903
aS'  private:'
p37904
aS'    const MPI_Comm mpi_communicator;'
p37905
aS'    TimerOutput &  computing_timer;'
p37906
aS'    SmartPointer<const OfflineData<dim>>   offline_data;'
p37907
aS'    SmartPointer<const InitialValues<dim>> initial_values;'
p37908
aS'    SparseMatrix<double> dij_matrix;'
p37909
aS'    vector_type temporary_vector;'
p37910
aS'    double cfl_update;'
p37911
aS'  };'
p37912
aS'  template <int dim>'
p37913
aS'  class SchlierenPostprocessor : public ParameterAcceptor'
p37914
aS'  {'
p37915
aS'  public:'
p37916
aS'    static constexpr unsigned int problem_dimension ='
p37917
aS'      ProblemDescription<dim>::problem_dimension;'
p37918
aS'    using state_type = typename ProblemDescription<dim>::state_type;'
p37919
aS'    using vector_type ='
p37920
aS'      std::array<LinearAlgebra::distributed::Vector<double>, problem_dimension>;'
p37921
aS'    SchlierenPostprocessor('
p37922
aS'      const MPI_Comm          mpi_communicator,'
p37923
aS'      TimerOutput &           computing_timer,'
p37924
aS'      const OfflineData<dim> &offline_data,'
p37925
aS'      const std::string &     subsection = "SchlierenPostprocessor");'
p37926
aS'    void prepare();'
p37927
aS'    void compute_schlieren(const vector_type &U);'
p37928
aS'    LinearAlgebra::distributed::Vector<double> schlieren;'
p37929
aS'  private:'
p37930
aS'    const MPI_Comm mpi_communicator;'
p37931
aS'    TimerOutput &  computing_timer;'
p37932
aS'    SmartPointer<const OfflineData<dim>> offline_data;'
p37933
aS'    Vector<double> r;'
p37934
aS'    unsigned int schlieren_index;'
p37935
aS'    double       schlieren_beta;'
p37936
aS'  };'
p37937
aS'  template <int dim>'
p37938
aS'  class MainLoop : public ParameterAcceptor'
p37939
aS'  {'
p37940
aS'  public:'
p37941
aS'    using vector_type = typename TimeStepping<dim>::vector_type;'
p37942
aS'    MainLoop(const MPI_Comm mpi_communnicator);'
p37943
aS'    void run();'
p37944
aS'  private:'
p37945
aS'    vector_type interpolate_initial_values(const double t = 0);'
p37946
aS'    void output(const vector_type &U,'
p37947
aS'                const std::string &name,'
p37948
aS'                double             t,'
p37949
aS'                unsigned int       cycle,'
p37950
aS'                bool               checkpoint = false);'
p37951
aS'    const MPI_Comm     mpi_communicator;'
p37952
aS'    std::ostringstream timer_output;'
p37953
aS'    TimerOutput        computing_timer;'
p37954
aS'    ConditionalOStream pcout;'
p37955
aS'    std::string base_name;'
p37956
aS'    double      t_final;'
p37957
aS'    double      output_granularity;'
p37958
aS'    bool asynchronous_writeback;'
p37959
aS'    bool resume;'
p37960
aS'    Discretization<dim>         discretization;'
p37961
aS'    OfflineData<dim>            offline_data;'
p37962
aS'    InitialValues<dim>          initial_values;'
p37963
aS'    TimeStepping<dim>           time_stepping;'
p37964
aS'    SchlierenPostprocessor<dim> schlieren_postprocessor;'
p37965
aS'    vector_type output_vector;'
p37966
aS'    std::future<void> background_thread_state;'
p37967
aS'  };'
p37968
aS'  template <int dim>'
p37969
aS'  Discretization<dim>::Discretization(const MPI_Comm     mpi_communicator,'
p37970
aS'                                      TimerOutput &      computing_timer,'
p37971
aS'                                      const std::string &subsection)'
p37972
aS'    : ParameterAcceptor(subsection)'
p37973
aS'    , mpi_communicator(mpi_communicator)'
p37974
aS'    , triangulation(mpi_communicator)'
p37975
aS'    , mapping(1)'
p37976
aS'    , finite_element(1)'
p37977
aS'    , quadrature(3)'
p37978
aS'    , face_quadrature(3)'
p37979
aS'    , computing_timer(computing_timer)'
p37980
aS'  {'
p37981
aS'    length = 4.;'
p37982
aS'    add_parameter("length", length, "Length of computational domain");'
p37983
aS'    height = 2.;'
p37984
aS'    add_parameter("height", height, "Height of computational domain");'
p37985
aS'    disk_position = 0.6;'
p37986
aS'    add_parameter("object position",'
p37987
aS'                  disk_position,'
p37988
aS'                  "x position of immersed disk center point");'
p37989
aS'    disk_diameter = 0.5;'
p37990
aS'    add_parameter("object diameter",'
p37991
aS'                  disk_diameter,'
p37992
aS'                  "Diameter of immersed disk");'
p37993
aS'    refinement = 5;'
p37994
aS'    add_parameter("refinement",'
p37995
aS'                  refinement,'
p37996
aS'                  "Number of refinement steps of the geometry");'
p37997
aS'  }'
p37998
aS'  template <int dim>'
p37999
aS'  void Discretization<dim>::setup()'
p38000
aS'  {'
p38001
aS'    TimerOutput::Scope scope(computing_timer, "discretization - setup");'
p38002
aS'    triangulation.clear();'
p38003
aS'    Triangulation<dim> tria1, tria2, tria3, tria4, tria5, tria6;'
p38004
aS'    GridGenerator::hyper_cube_with_cylindrical_hole('
p38005
aS'      tria1, disk_diameter / 2., disk_diameter, 0.5, 1, false);'
p38006
aS'    GridGenerator::subdivided_hyper_rectangle('
p38007
aS'      tria2,'
p38008
aS'      {2, 1},'
p38009
aS'      Point<2>(-disk_diameter, disk_diameter),'
p38010
aS'      Point<2>(disk_diameter, height / 2.));'
p38011
aS'    GridGenerator::subdivided_hyper_rectangle('
p38012
aS'      tria3,'
p38013
aS'      {2, 1},'
p38014
aS'      Point<2>(-disk_diameter, -disk_diameter),'
p38015
aS'      Point<2>(disk_diameter, -height / 2.));'
p38016
aS'    GridGenerator::subdivided_hyper_rectangle('
p38017
aS'      tria4,'
p38018
aS'      {6, 2},'
p38019
aS'      Point<2>(disk_diameter, -disk_diameter),'
p38020
aS'      Point<2>(length - disk_position, disk_diameter));'
p38021
aS'    GridGenerator::subdivided_hyper_rectangle('
p38022
aS'      tria5,'
p38023
aS'      {6, 1},'
p38024
aS'      Point<2>(disk_diameter, disk_diameter),'
p38025
aS'      Point<2>(length - disk_position, height / 2.));'
p38026
aS'    GridGenerator::subdivided_hyper_rectangle('
p38027
aS'      tria6,'
p38028
aS'      {6, 1},'
p38029
aS'      Point<2>(disk_diameter, -height / 2.),'
p38030
aS'      Point<2>(length - disk_position, -disk_diameter));'
p38031
aS'    GridGenerator::merge_triangulations('
p38032
aS'      {&tria1, &tria2, &tria3, &tria4, &tria5, &tria6},'
p38033
aS'      triangulation,'
p38034
aS'      1.e-12,'
p38035
aS'      true);'
p38036
aS'    triangulation.set_manifold(0, PolarManifold<2>(Point<2>()));'
p38037
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p38038
aS'      {'
p38039
aS'        for (const auto v : cell->vertex_indices())'
p38040
aS'          {'
p38041
aS'            if (cell->vertex(v)[0] <= -disk_diameter + 1.e-6)'
p38042
aS'              cell->vertex(v)[0] = -disk_position;'
p38043
aS'          }'
p38044
aS'      }'
p38045
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p38046
aS'      {'
p38047
aS'        for (const auto f : cell->face_indices())'
p38048
aS'          {'
p38049
aS'            const auto face = cell->face(f);'
p38050
aS'            if (face->at_boundary())'
p38051
aS'              {'
p38052
aS'                const auto center = face->center();'
p38053
aS'                if (center[0] > length - disk_position - 1.e-6)'
p38054
aS'                  face->set_boundary_id(Boundaries::do_nothing);'
p38055
aS'                else if (center[0] < -disk_position + 1.e-6)'
p38056
aS'                  face->set_boundary_id(Boundaries::dirichlet);'
p38057
aS'                else'
p38058
aS'                  face->set_boundary_id(Boundaries::free_slip);'
p38059
aS'              }'
p38060
aS'          }'
p38061
aS'      }'
p38062
aS'    triangulation.refine_global(refinement);'
p38063
aS'  }'
p38064
aS'  template <int dim>'
p38065
aS'  OfflineData<dim>::OfflineData(const MPI_Comm             mpi_communicator,'
p38066
aS'                                TimerOutput &              computing_timer,'
p38067
aS'                                const Discretization<dim> &discretization,'
p38068
aS'                                const std::string &        subsection)'
p38069
aS'    : ParameterAcceptor(subsection)'
p38070
aS'    , dof_handler(discretization.triangulation)'
p38071
aS'    , mpi_communicator(mpi_communicator)'
p38072
aS'    , computing_timer(computing_timer)'
p38073
aS'    , discretization(&discretization)'
p38074
aS'  {}'
p38075
aS'  template <int dim>'
p38076
aS'  void OfflineData<dim>::setup()'
p38077
aS'  {'
p38078
aS'    IndexSet locally_owned;'
p38079
aS'    IndexSet locally_relevant;'
p38080
aS'    {'
p38081
aS'      TimerOutput::Scope scope(computing_timer,'
p38082
aS'                               "offline_data - distribute dofs");'
p38083
aS'      dof_handler.distribute_dofs(discretization->finite_element);'
p38084
aS'      locally_owned   = dof_handler.locally_owned_dofs();'
p38085
aS'      n_locally_owned = locally_owned.n_elements();'
p38086
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant);'
p38087
aS'      n_locally_relevant = locally_relevant.n_elements();'
p38088
aS'      partitioner ='
p38089
aS'        std::make_shared<Utilities::MPI::Partitioner>(locally_owned,'
p38090
aS'                                                      locally_relevant,'
p38091
aS'                                                      mpi_communicator);'
p38092
aS'    }'
p38093
aS'    {'
p38094
aS'      TimerOutput::Scope scope('
p38095
aS'        computing_timer,'
p38096
aS'        "offline_data - create sparsity pattern and set up matrices");'
p38097
aS'      DynamicSparsityPattern dsp(n_locally_relevant, n_locally_relevant);'
p38098
aS'      const auto dofs_per_cell ='
p38099
aS'        discretization->finite_element.n_dofs_per_cell();'
p38100
aS'      std::vector<types::global_dof_index> dof_indices(dofs_per_cell);'
p38101
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p38102
aS'        {'
p38103
aS'          if (cell->is_artificial())'
p38104
aS'            continue;'
p38105
aS'          cell->get_dof_indices(dof_indices);'
p38106
aS'          std::transform(dof_indices.begin(),'
p38107
aS'                         dof_indices.end(),'
p38108
aS'                         dof_indices.begin(),'
p38109
aS'                         [&](types::global_dof_index index) {'
p38110
aS'                           return partitioner->global_to_local(index);'
p38111
aS'                         });'
p38112
aS'          for (const auto dof : dof_indices)'
p38113
aS'            dsp.add_entries(dof, dof_indices.begin(), dof_indices.end());'
p38114
aS'        }'
p38115
aS'      sparsity_pattern.copy_from(dsp);'
p38116
aS'      lumped_mass_matrix.reinit(sparsity_pattern);'
p38117
aS'      norm_matrix.reinit(sparsity_pattern);'
p38118
aS'      for (auto &matrix : cij_matrix)'
p38119
aS'        matrix.reinit(sparsity_pattern);'
p38120
aS'      for (auto &matrix : nij_matrix)'
p38121
aS'        matrix.reinit(sparsity_pattern);'
p38122
aS'    }'
p38123
aS'  }'
p38124
aS'  namespace'
p38125
aS'  {'
p38126
aS'    template <int dim>'
p38127
aS'    struct CopyData'
p38128
aS'    {'
p38129
aS'      bool                                         is_artificial;'
p38130
aS'      std::vector<types::global_dof_index>         local_dof_indices;'
p38131
aS'      typename OfflineData<dim>::BoundaryNormalMap local_boundary_normal_map;'
p38132
aS'      FullMatrix<double>                           cell_lumped_mass_matrix;'
p38133
aS'      std::array<FullMatrix<double>, dim>          cell_cij_matrix;'
p38134
aS'    };'
p38135
aS'    template <typename IteratorType>'
p38136
aS'    DEAL_II_ALWAYS_INLINE inline SparseMatrix<double>::value_type'
p38137
aS'    get_entry(const SparseMatrix<double> &matrix, const IteratorType &it)'
p38138
aS'    {'
p38139
aS'      const SparseMatrix<double>::const_iterator matrix_iterator('
p38140
aS'        &matrix, it->global_index());'
p38141
aS'      return matrix_iterator->value();'
p38142
aS'    }'
p38143
aS'    template <typename IteratorType>'
p38144
aS'    DEAL_II_ALWAYS_INLINE inline void'
p38145
aS'    set_entry(SparseMatrix<double> &           matrix,'
p38146
aS'              const IteratorType &             it,'
p38147
aS'              SparseMatrix<double>::value_type value)'
p38148
aS'    {'
p38149
aS'      SparseMatrix<double>::iterator matrix_iterator(&matrix,'
p38150
aS'                                                     it->global_index());'
p38151
aS'      matrix_iterator->value() = value;'
p38152
aS'    }'
p38153
aS'    template <std::size_t k, typename IteratorType>'
p38154
aS'    DEAL_II_ALWAYS_INLINE inline Tensor<1, k>'
p38155
aS'    gather_get_entry(const std::array<SparseMatrix<double>, k> &c_ij,'
p38156
aS'                     const IteratorType                         it)'
p38157
aS'    {'
p38158
aS'      Tensor<1, k> result;'
p38159
aS'      for (unsigned int j = 0; j < k; ++j)'
p38160
aS'        result[j] = get_entry(c_ij[j], it);'
p38161
aS'      return result;'
p38162
aS'    }'
p38163
aS'    template <std::size_t k>'
p38164
aS'    DEAL_II_ALWAYS_INLINE inline Tensor<1, k>'
p38165
aS'    gather(const std::array<SparseMatrix<double>, k> &n_ij,'
p38166
aS'           const unsigned int                         i,'
p38167
aS'           const unsigned int                         j)'
p38168
aS'    {'
p38169
aS'      Tensor<1, k> result;'
p38170
aS'      for (unsigned int l = 0; l < k; ++l)'
p38171
aS'        result[l] = n_ij[l](i, j);'
p38172
aS'      return result;'
p38173
aS'    }'
p38174
aS'    template <std::size_t k>'
p38175
aS'    DEAL_II_ALWAYS_INLINE inline Tensor<1, k>'
p38176
aS'    gather(const std::array<LinearAlgebra::distributed::Vector<double>, k> &U,'
p38177
aS'           const unsigned int                                               i)'
p38178
aS'    {'
p38179
aS'      Tensor<1, k> result;'
p38180
aS'      for (unsigned int j = 0; j < k; ++j)'
p38181
aS'        result[j] = U[j].local_element(i);'
p38182
aS'      return result;'
p38183
aS'    }'
p38184
aS'    template <std::size_t k, int k2>'
p38185
aS'    DEAL_II_ALWAYS_INLINE inline void'
p38186
aS'    scatter(std::array<LinearAlgebra::distributed::Vector<double>, k> &U,'
p38187
aS'            const Tensor<1, k2> &                                      tensor,'
p38188
aS'            const unsigned int                                         i)'
p38189
aS'    {'
p38190
aS'      static_assert(k == k2,'
p38191
aS'                    "The dimensions of the input arguments must agree");'
p38192
aS'      for (unsigned int j = 0; j < k; ++j)'
p38193
aS'        U[j].local_element(i) = tensor[j];'
p38194
aS'    }'
p38195
aS'  } // namespace'
p38196
aS'  template <int dim>'
p38197
aS'  void OfflineData<dim>::assemble()'
p38198
aS'  {'
p38199
aS'    lumped_mass_matrix = 0.;'
p38200
aS'    norm_matrix        = 0.;'
p38201
aS'    for (auto &matrix : cij_matrix)'
p38202
aS'      matrix = 0.;'
p38203
aS'    for (auto &matrix : nij_matrix)'
p38204
aS'      matrix = 0.;'
p38205
aS'    unsigned int dofs_per_cell ='
p38206
aS'      discretization->finite_element.n_dofs_per_cell();'
p38207
aS'    unsigned int n_q_points = discretization->quadrature.size();'
p38208
aS'    MeshWorker::ScratchData<dim> scratch_data('
p38209
aS'      discretization->mapping,'
p38210
aS'      discretization->finite_element,'
p38211
aS'      discretization->quadrature,'
p38212
aS'      update_values | update_gradients | update_quadrature_points |'
p38213
aS'        update_JxW_values,'
p38214
aS'      discretization->face_quadrature,'
p38215
aS'      update_normal_vectors | update_values | update_JxW_values);'
p38216
aS'    {'
p38217
aS'      TimerOutput::Scope scope('
p38218
aS'        computing_timer,'
p38219
aS'        "offline_data - assemble lumped mass matrix, and c_ij");'
p38220
aS'      const auto local_assemble_system = //'
p38221
aS'        [&](const typename DoFHandler<dim>::cell_iterator &cell,'
p38222
aS'            MeshWorker::ScratchData<dim> &                 scratch,'
p38223
aS'            CopyData<dim> &                                copy) {'
p38224
aS'          copy.is_artificial = cell->is_artificial();'
p38225
aS'          if (copy.is_artificial)'
p38226
aS'            return;'
p38227
aS'          copy.local_boundary_normal_map.clear();'
p38228
aS'          copy.cell_lumped_mass_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p38229
aS'          for (auto &matrix : copy.cell_cij_matrix)'
p38230
aS'            matrix.reinit(dofs_per_cell, dofs_per_cell);'
p38231
aS'          const auto &fe_values = scratch.reinit(cell);'
p38232
aS'          copy.local_dof_indices.resize(dofs_per_cell);'
p38233
aS'          cell->get_dof_indices(copy.local_dof_indices);'
p38234
aS'          std::transform(copy.local_dof_indices.begin(),'
p38235
aS'                         copy.local_dof_indices.end(),'
p38236
aS'                         copy.local_dof_indices.begin(),'
p38237
aS'                         [&](types::global_dof_index index) {'
p38238
aS'                           return partitioner->global_to_local(index);'
p38239
aS'                         });'
p38240
aS'          for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p38241
aS'            {'
p38242
aS'              const auto JxW = fe_values.JxW(q_point);'
p38243
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p38244
aS'                {'
p38245
aS'                  const auto value_JxW ='
p38246
aS'                    fe_values.shape_value(j, q_point) * JxW;'
p38247
aS'                  const auto grad_JxW = fe_values.shape_grad(j, q_point) * JxW;'
p38248
aS'                  copy.cell_lumped_mass_matrix(j, j) += value_JxW;'
p38249
aS'                  for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p38250
aS'                    {'
p38251
aS'                      const auto value = fe_values.shape_value(i, q_point);'
p38252
aS'                      for (unsigned int d = 0; d < dim; ++d)'
p38253
aS'                        copy.cell_cij_matrix[d](i, j) += value * grad_JxW[d];'
p38254
aS'                    } /* i */'
p38255
aS'                }     /* j */'
p38256
aS'            }         /* q */'
p38257
aS'          for (const auto f : cell->face_indices())'
p38258
aS'            {'
p38259
aS'              const auto face = cell->face(f);'
p38260
aS'              const auto id   = face->boundary_id();'
p38261
aS'              if (!face->at_boundary())'
p38262
aS'                continue;'
p38263
aS'              const auto &fe_face_values = scratch.reinit(cell, f);'
p38264
aS'              const unsigned int n_face_q_points ='
p38265
aS'                fe_face_values.get_quadrature().size();'
p38266
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p38267
aS'                {'
p38268
aS'                  if (!discretization->finite_element.has_support_on_face(j, f))'
p38269
aS'                    continue;'
p38270
aS'                  Tensor<1, dim> normal;'
p38271
aS'                  if (id == Boundaries::free_slip)'
p38272
aS'                    {'
p38273
aS'                      for (unsigned int q = 0; q < n_face_q_points; ++q)'
p38274
aS'                        normal += fe_face_values.normal_vector(q) *'
p38275
aS'                                  fe_face_values.shape_value(j, q);'
p38276
aS'                    }'
p38277
aS'                  const auto index = copy.local_dof_indices[j];'
p38278
aS'                  Point<dim> position;'
p38279
aS'                  for (const auto v : cell->vertex_indices())'
p38280
aS'                    if (cell->vertex_dof_index(v, 0) =='
p38281
aS'                        partitioner->local_to_global(index))'
p38282
aS'                      {'
p38283
aS'                        position = cell->vertex(v);'
p38284
aS'                        break;'
p38285
aS'                      }'
p38286
aS'                  const auto old_id ='
p38287
aS'                    std::get<1>(copy.local_boundary_normal_map[index]);'
p38288
aS'                  copy.local_boundary_normal_map[index] ='
p38289
aS'                    std::make_tuple(normal, std::max(old_id, id), position);'
p38290
aS'                }'
p38291
aS'            }'
p38292
aS'        };'
p38293
aS'      const auto copy_local_to_global = [&](const CopyData<dim> &copy) {'
p38294
aS'        if (copy.is_artificial)'
p38295
aS'          return;'
p38296
aS'        for (const auto &it : copy.local_boundary_normal_map)'
p38297
aS'          {'
p38298
aS'            std::get<0>(boundary_normal_map[it.first]) +='
p38299
aS'              std::get<0>(it.second);'
p38300
aS'            std::get<1>(boundary_normal_map[it.first]) ='
p38301
aS'              std::max(std::get<1>(boundary_normal_map[it.first]),'
p38302
aS'                       std::get<1>(it.second));'
p38303
aS'            std::get<2>(boundary_normal_map[it.first]) = std::get<2>(it.second);'
p38304
aS'          }'
p38305
aS'        lumped_mass_matrix.add(copy.local_dof_indices,'
p38306
aS'                               copy.cell_lumped_mass_matrix);'
p38307
aS'        for (int k = 0; k < dim; ++k)'
p38308
aS'          {'
p38309
aS'            cij_matrix[k].add(copy.local_dof_indices, copy.cell_cij_matrix[k]);'
p38310
aS'            nij_matrix[k].add(copy.local_dof_indices, copy.cell_cij_matrix[k]);'
p38311
aS'          }'
p38312
aS'      };'
p38313
aS'      WorkStream::run(dof_handler.begin_active(),'
p38314
aS'                      dof_handler.end(),'
p38315
aS'                      local_assemble_system,'
p38316
aS'                      copy_local_to_global,'
p38317
aS'                      scratch_data,'
p38318
aS'                      CopyData<dim>());'
p38319
aS'    }'
p38320
aS'    {'
p38321
aS'      TimerOutput::Scope scope(computing_timer,'
p38322
aS'                               "offline_data - compute |c_ij|, and n_ij");'
p38323
aS'      const std_cxx20::ranges::iota_view<unsigned int, unsigned int> indices('
p38324
aS'        0, n_locally_relevant);'
p38325
aS'      const auto on_subranges = //'
p38326
aS'        [&](const auto i1, const auto i2) {'
p38327
aS'          for (const auto row_index :'
p38328
aS'               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1,'
p38329
aS'            {'
p38330
aS'              std::for_each('
p38331
aS'                sparsity_pattern.begin(row_index),'
p38332
aS'                sparsity_pattern.end(row_index),'
p38333
aS'                [&](const dealii::SparsityPatternIterators::Accessor &jt) {'
p38334
aS'                  const auto   c_ij = gather_get_entry(cij_matrix, &jt);'
p38335
aS'                  const double norm = c_ij.norm();'
p38336
aS'                  set_entry(norm_matrix, &jt, norm);'
p38337
aS'                  for (unsigned int j = 0; j < dim; ++j)'
p38338
aS'                    set_entry(nij_matrix[j], &jt, c_ij[j] / norm);'
p38339
aS'                });'
p38340
aS'            }'
p38341
aS'        };'
p38342
aS'      parallel::apply_to_subranges(indices.begin(),'
p38343
aS'                                   indices.end(),'
p38344
aS'                                   on_subranges,'
p38345
aS'                                   4096);'
p38346
aS'      for (auto &it : boundary_normal_map)'
p38347
aS'        {'
p38348
aS'          auto &normal = std::get<0>(it.second);'
p38349
aS'          normal /= (normal.norm() + std::numeric_limits<double>::epsilon());'
p38350
aS'        }'
p38351
aS'    }'
p38352
aS'  }'
p38353
aS'  template <int dim>'
p38354
aS'  DEAL_II_ALWAYS_INLINE inline Tensor<1, dim>'
p38355
aS'  ProblemDescription<dim>::momentum(const state_type &U)'
p38356
aS'  {'
p38357
aS'    Tensor<1, dim> result;'
p38358
aS'    std::copy_n(&U[1], dim, &result[0]);'
p38359
aS'    return result;'
p38360
aS'  }'
p38361
aS'  template <int dim>'
p38362
aS'  DEAL_II_ALWAYS_INLINE inline double'
p38363
aS'  ProblemDescription<dim>::internal_energy(const state_type &U)'
p38364
aS'  {'
p38365
aS'    const double &rho = U[0];'
p38366
aS'    const auto    m   = momentum(U);'
p38367
aS'    const double &E   = U[dim + 1];'
p38368
aS'    return E - 0.5 * m.norm_square() / rho;'
p38369
aS'  }'
p38370
aS'  template <int dim>'
p38371
aS'  DEAL_II_ALWAYS_INLINE inline double'
p38372
aS'  ProblemDescription<dim>::pressure(const state_type &U)'
p38373
aS'  {'
p38374
aS'    return (gamma - 1.) * internal_energy(U);'
p38375
aS'  }'
p38376
aS'  template <int dim>'
p38377
aS'  DEAL_II_ALWAYS_INLINE inline double'
p38378
aS'  ProblemDescription<dim>::speed_of_sound(const state_type &U)'
p38379
aS'  {'
p38380
aS'    const double &rho = U[0];'
p38381
aS'    const double  p   = pressure(U);'
p38382
aS'    return std::sqrt(gamma * p / rho);'
p38383
aS'  }'
p38384
aS'  template <int dim>'
p38385
aS'  DEAL_II_ALWAYS_INLINE inline typename ProblemDescription<dim>::flux_type'
p38386
aS'  ProblemDescription<dim>::flux(const state_type &U)'
p38387
aS'  {'
p38388
aS'    const double &rho = U[0];'
p38389
aS'    const auto    m   = momentum(U);'
p38390
aS'    const auto    p   = pressure(U);'
p38391
aS'    const double &E   = U[dim + 1];'
p38392
aS'    flux_type result;'
p38393
aS'    result[0] = m;'
p38394
aS'    for (unsigned int i = 0; i < dim; ++i)'
p38395
aS'      {'
p38396
aS'        result[1 + i] = m * m[i] / rho;'
p38397
aS'        result[1 + i][i] += p;'
p38398
aS'      }'
p38399
aS'    result[dim + 1] = m / rho * (E + p);'
p38400
aS'    return result;'
p38401
aS'  }'
p38402
aS'  namespace'
p38403
aS'  {'
p38404
aS'    template <int dim>'
p38405
aS'    DEAL_II_ALWAYS_INLINE inline std::array<double, 4> riemann_data_from_state('
p38406
aS'      const typename ProblemDescription<dim>::state_type U,'
p38407
aS'      const Tensor<1, dim> &                             n_ij)'
p38408
aS'    {'
p38409
aS'      Tensor<1, 3> projected_U;'
p38410
aS'      projected_U[0] = U[0];'
p38411
aS'      const auto m   = ProblemDescription<dim>::momentum(U);'
p38412
aS'      projected_U[1] = n_ij * m;'
p38413
aS'      const auto perpendicular_m = m - projected_U[1] * n_ij;'
p38414
aS'      projected_U[2] = U[1 + dim] - 0.5 * perpendicular_m.norm_square() / U[0];'
p38415
aS'      return {{projected_U[0],'
p38416
aS'               projected_U[1] / projected_U[0],'
p38417
aS'               ProblemDescription<1>::pressure(projected_U),'
p38418
aS'               ProblemDescription<1>::speed_of_sound(projected_U)}};'
p38419
aS'    }'
p38420
aS'    DEAL_II_ALWAYS_INLINE inline double positive_part(const double number)'
p38421
aS'    {'
p38422
aS'      return std::max(number, 0.);'
p38423
aS'    }'
p38424
aS'    DEAL_II_ALWAYS_INLINE inline double negative_part(const double number)'
p38425
aS'    {'
p38426
aS'      return -std::min(number, 0.);'
p38427
aS'    }'
p38428
aS'    DEAL_II_ALWAYS_INLINE inline double'
p38429
aS'    lambda1_minus(const std::array<double, 4> &riemann_data,'
p38430
aS'                  const double                 p_star)'
p38431
aS'    {'
p38432
aS'      constexpr double gamma = ProblemDescription<1>::gamma;'
p38433
aS'      const auto       u     = riemann_data[1];'
p38434
aS'      const auto       p     = riemann_data[2];'
p38435
aS'      const auto       a     = riemann_data[3];'
p38436
aS'      const double factor = (gamma + 1.0) / 2.0 / gamma;'
p38437
aS'      const double tmp    = positive_part((p_star - p) / p);'
p38438
aS'      return u - a * std::sqrt(1.0 + factor * tmp);'
p38439
aS'    }'
p38440
aS'    DEAL_II_ALWAYS_INLINE inline double'
p38441
aS'    lambda3_plus(const std::array<double, 4> &riemann_data, const double p_star)'
p38442
aS'    {'
p38443
aS'      constexpr double gamma = ProblemDescription<1>::gamma;'
p38444
aS'      const auto       u     = riemann_data[1];'
p38445
aS'      const auto       p     = riemann_data[2];'
p38446
aS'      const auto       a     = riemann_data[3];'
p38447
aS'      const double factor = (gamma + 1.0) / 2.0 / gamma;'
p38448
aS'      const double tmp    = positive_part((p_star - p) / p);'
p38449
aS'      return u + a * std::sqrt(1.0 + factor * tmp);'
p38450
aS'    }'
p38451
aS'    DEAL_II_ALWAYS_INLINE inline double'
p38452
aS'    lambda_max_two_rarefaction(const std::array<double, 4> &riemann_data_i,'
p38453
aS'                               const std::array<double, 4> &riemann_data_j)'
p38454
aS'    {'
p38455
aS'      constexpr double gamma = ProblemDescription<1>::gamma;'
p38456
aS'      const auto       u_i   = riemann_data_i[1];'
p38457
aS'      const auto       p_i   = riemann_data_i[2];'
p38458
aS'      const auto       a_i   = riemann_data_i[3];'
p38459
aS'      const auto       u_j   = riemann_data_j[1];'
p38460
aS'      const auto       p_j   = riemann_data_j[2];'
p38461
aS'      const auto       a_j   = riemann_data_j[3];'
p38462
aS'      const double numerator = a_i + a_j - (gamma - 1.) / 2. * (u_j - u_i);'
p38463
aS'      const double denominator ='
p38464
aS'        a_i * std::pow(p_i / p_j, -1. * (gamma - 1.) / 2. / gamma) + a_j * 1.;'
p38465
aS'      const double p_star ='
p38466
aS'        p_j * std::pow(numerator / denominator, 2. * gamma / (gamma - 1));'
p38467
aS'      const double lambda1 = lambda1_minus(riemann_data_i, p_star);'
p38468
aS'      const double lambda3 = lambda3_plus(riemann_data_j, p_star);'
p38469
aS'      return std::max(positive_part(lambda3), negative_part(lambda1));'
p38470
aS'    }'
p38471
aS'    DEAL_II_ALWAYS_INLINE inline double'
p38472
aS'    lambda_max_expansion(const std::array<double, 4> &riemann_data_i,'
p38473
aS'                         const std::array<double, 4> &riemann_data_j)'
p38474
aS'    {'
p38475
aS'      const auto u_i = riemann_data_i[1];'
p38476
aS'      const auto a_i = riemann_data_i[3];'
p38477
aS'      const auto u_j = riemann_data_j[1];'
p38478
aS'      const auto a_j = riemann_data_j[3];'
p38479
aS'      return std::max(std::abs(u_i), std::abs(u_j)) + 5. * std::max(a_i, a_j);'
p38480
aS'    }'
p38481
aS'  } // namespace'
p38482
aS'  template <int dim>'
p38483
aS'  DEAL_II_ALWAYS_INLINE inline double'
p38484
aS'  ProblemDescription<dim>::compute_lambda_max(const state_type &    U_i,'
p38485
aS'                                              const state_type &    U_j,'
p38486
aS'                                              const Tensor<1, dim> &n_ij)'
p38487
aS'  {'
p38488
aS'    const auto riemann_data_i = riemann_data_from_state(U_i, n_ij);'
p38489
aS'    const auto riemann_data_j = riemann_data_from_state(U_j, n_ij);'
p38490
aS'    const double lambda_1 ='
p38491
aS'      lambda_max_two_rarefaction(riemann_data_i, riemann_data_j);'
p38492
aS'    const double lambda_2 ='
p38493
aS'      lambda_max_expansion(riemann_data_i, riemann_data_j);'
p38494
aS'    return std::min(lambda_1, lambda_2);'
p38495
aS'  }'
p38496
aS'  template <>'
p38497
aS'  const std::array<std::string, 3> ProblemDescription<1>::component_names{'
p38498
aS'    {"rho", "m", "E"}};'
p38499
aS'  template <>'
p38500
aS'  const std::array<std::string, 4> ProblemDescription<2>::component_names{'
p38501
aS'    {"rho", "m_1", "m_2", "E"}};'
p38502
aS'  template <>'
p38503
aS'  const std::array<std::string, 5> ProblemDescription<3>::component_names{'
p38504
aS'    {"rho", "m_1", "m_2", "m_3", "E"}};'
p38505
aS'  template <int dim>'
p38506
aS'  InitialValues<dim>::InitialValues(const std::string &subsection)'
p38507
aS'    : ParameterAcceptor(subsection)'
p38508
aS'  {'
p38509
aS'       the ParameterAcceptor::parse_parameters_call_back signal: */'
p38510
aS'    ParameterAcceptor::parse_parameters_call_back.connect('
p38511
aS'      std::bind(&InitialValues<dim>::parse_parameters_callback, this));'
p38512
aS'    initial_direction[0] = 1.;'
p38513
aS'    add_parameter("initial direction",'
p38514
aS'                  initial_direction,'
p38515
aS'                  "Initial direction of the uniform flow field");'
p38516
aS'    initial_1d_state[0] = ProblemDescription<dim>::gamma;'
p38517
aS'    initial_1d_state[1] = 3.;'
p38518
aS'    initial_1d_state[2] = 1.;'
p38519
aS'    add_parameter("initial 1d state",'
p38520
aS'                  initial_1d_state,'
p38521
aS'                  "Initial 1d state (rho, u, p) of the uniform flow field");'
p38522
aS'  }'
p38523
aS'  template <int dim>'
p38524
aS'  void InitialValues<dim>::parse_parameters_callback()'
p38525
aS'  {'
p38526
aS'    AssertThrow(initial_direction.norm() != 0.,'
p38527
aS'                ExcMessage('
p38528
aS'                  "Initial shock front direction is set to the zero vector."));'
p38529
aS'    initial_direction /= initial_direction.norm();'
p38530
aS'    initial_state = [this](const Point<dim> & /*point*/, double /*t*/) {'
p38531
aS'      const double            rho   = initial_1d_state[0];'
p38532
aS'      const double            u     = initial_1d_state[1];'
p38533
aS'      const double            p     = initial_1d_state[2];'
p38534
aS'      static constexpr double gamma = ProblemDescription<dim>::gamma;'
p38535
aS'      state_type state;'
p38536
aS'      state[0] = rho;'
p38537
aS'      for (unsigned int i = 0; i < dim; ++i)'
p38538
aS'        state[1 + i] = rho * u * initial_direction[i];'
p38539
aS'      state[dim + 1] = p / (gamma - 1.) + 0.5 * rho * u * u;'
p38540
aS'      return state;'
p38541
aS'    };'
p38542
aS'  }'
p38543
aS'  template <int dim>'
p38544
aS'  TimeStepping<dim>::TimeStepping('
p38545
aS'    const MPI_Comm            mpi_communicator,'
p38546
aS'    TimerOutput &             computing_timer,'
p38547
aS'    const OfflineData<dim> &  offline_data,'
p38548
aS'    const InitialValues<dim> &initial_values,'
p38549
aS'    const std::string &       subsection /*= "TimeStepping"*/)'
p38550
aS'    : ParameterAcceptor(subsection)'
p38551
aS'    , mpi_communicator(mpi_communicator)'
p38552
aS'    , computing_timer(computing_timer)'
p38553
aS'    , offline_data(&offline_data)'
p38554
aS'    , initial_values(&initial_values)'
p38555
aS'  {'
p38556
aS'    cfl_update = 0.80;'
p38557
aS'    add_parameter("cfl update",'
p38558
aS'                  cfl_update,'
p38559
aS'                  "Relative CFL constant used for update");'
p38560
aS'  }'
p38561
aS'  template <int dim>'
p38562
aS'  void TimeStepping<dim>::prepare()'
p38563
aS'  {'
p38564
aS'    TimerOutput::Scope scope(computing_timer,'
p38565
aS'                             "time_stepping - prepare scratch space");'
p38566
aS'    for (auto &it : temporary_vector)'
p38567
aS'      it.reinit(offline_data->partitioner);'
p38568
aS'    dij_matrix.reinit(offline_data->sparsity_pattern);'
p38569
aS'  }'
p38570
aS'  template <int dim>'
p38571
aS'  double TimeStepping<dim>::make_one_step(vector_type &U, double t)'
p38572
aS'  {'
p38573
aS'    const auto &n_locally_owned    = offline_data->n_locally_owned;'
p38574
aS'    const auto &n_locally_relevant = offline_data->n_locally_relevant;'
p38575
aS'    const std_cxx20::ranges::iota_view<unsigned int, unsigned int>'
p38576
aS'      indices_owned(0, n_locally_owned);'
p38577
aS'    const std_cxx20::ranges::iota_view<unsigned int, unsigned int>'
p38578
aS'      indices_relevant(0, n_locally_relevant);'
p38579
aS'    const auto &sparsity = offline_data->sparsity_pattern;'
p38580
aS'    const auto &lumped_mass_matrix = offline_data->lumped_mass_matrix;'
p38581
aS'    const auto &norm_matrix        = offline_data->norm_matrix;'
p38582
aS'    const auto &nij_matrix         = offline_data->nij_matrix;'
p38583
aS'    const auto &cij_matrix         = offline_data->cij_matrix;'
p38584
aS'    const auto &boundary_normal_map = offline_data->boundary_normal_map;'
p38585
aS'    {'
p38586
aS'      TimerOutput::Scope scope(computing_timer,'
p38587
aS'                               "time_stepping - 1 compute d_ij");'
p38588
aS'      const auto on_subranges = //'
p38589
aS'        [&](const auto i1, const auto i2) {'
p38590
aS'          for (const auto i :'
p38591
aS'               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1,'
p38592
aS'            {'
p38593
aS'              const auto U_i = gather(U, i);'
p38594
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p38595
aS'                {'
p38596
aS'                  const auto j = jt->column();'
p38597
aS'                  if (j >= i)'
p38598
aS'                    continue;'
p38599
aS'                  const auto U_j = gather(U, j);'
p38600
aS'                  const auto   n_ij = gather_get_entry(nij_matrix, jt);'
p38601
aS'                  const double norm = get_entry(norm_matrix, jt);'
p38602
aS'                  const auto lambda_max ='
p38603
aS'                    ProblemDescription<dim>::compute_lambda_max(U_i, U_j, n_ij);'
p38604
aS'                  double d = norm * lambda_max;'
p38605
aS'                  if (boundary_normal_map.count(i) != 0 &&'
p38606
aS'                      boundary_normal_map.count(j) != 0)'
p38607
aS'                    {'
p38608
aS'                      const auto n_ji = gather(nij_matrix, j, i);'
p38609
aS'                      const auto lambda_max_2 ='
p38610
aS'                        ProblemDescription<dim>::compute_lambda_max(U_j,'
p38611
aS'                                                                    U_i,'
p38612
aS'                                                                    n_ji);'
p38613
aS'                      const double norm_2 = norm_matrix(j, i);'
p38614
aS'                      d = std::max(d, norm_2 * lambda_max_2);'
p38615
aS'                    }'
p38616
aS'                  set_entry(dij_matrix, jt, d);'
p38617
aS'                  dij_matrix(j, i) = d;'
p38618
aS'                }'
p38619
aS'            }'
p38620
aS'        };'
p38621
aS'      parallel::apply_to_subranges(indices_relevant.begin(),'
p38622
aS'                                   indices_relevant.end(),'
p38623
aS'                                   on_subranges,'
p38624
aS'                                   4096);'
p38625
aS'    }'
p38626
aS'    std::atomic<double> tau_max{std::numeric_limits<double>::infinity()};'
p38627
aS'    {'
p38628
aS'      TimerOutput::Scope scope(computing_timer,'
p38629
aS'                               "time_stepping - 2 compute d_ii, and tau_max");'
p38630
aS'      const auto on_subranges = //'
p38631
aS'        [&](const auto i1, const auto i2) {'
p38632
aS'          double tau_max_on_subrange = std::numeric_limits<double>::infinity();'
p38633
aS'          for (const auto i :'
p38634
aS'               std_cxx20::ranges::iota_view<unsigned int, unsigned int>(*i1,'
p38635
aS'            {'
p38636
aS'              double d_sum = 0.;'
p38637
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p38638
aS'                {'
p38639
aS'                  const auto j = jt->column();'
p38640
aS'                  if (j == i)'
p38641
aS'                    continue;'
p38642
aS'                  d_sum -= get_entry(dij_matrix, jt);'
p38643
aS'                }'
p38644
aS'              dij_matrix.diag_element(i) = d_sum;'
p38645
aS'              const double mass   = lumped_mass_matrix.diag_element(i);'
p38646
aS'              const double tau    = cfl_update * mass / (-2. * d_sum);'
p38647
aS'              tau_max_on_subrange = std::min(tau_max_on_subrange, tau);'
p38648
aS'            }'
p38649
aS'          double current_tau_max = tau_max.load();'
p38650
aS'          while (current_tau_max > tau_max_on_subrange &&'
p38651
aS'                 !tau_max.compare_exchange_weak(current_tau_max,'
p38652
aS'                                                tau_max_on_subrange))'
p38653
aS'            ;'
p38654
aS'        };'
p38655
aS'      parallel::apply_to_subranges(indices_relevant.begin(),'
p38656
aS'                                   indices_relevant.end(),'
p38657
aS'                                   on_subranges,'
p38658
aS'                                   4096);'
p38659
aS'      tau_max.store(Utilities::MPI::min(tau_max.load(), mpi_communicator));'
p38660
aS'      AssertThrow('
p38661
aS'        !std::isnan(tau_max.load()) && !std::isinf(tau_max.load()) &&'
p38662
aS'          tau_max.load() > 0.,'
p38663
aS'        ExcMessage('
p38664
aS'          "I\'m sorry, Dave. I\'m afraid I can\'t do that. - We crashed."));'
p38665
aS'    }'
p38666
aS'    {'
p38667
aS'      TimerOutput::Scope scope(computing_timer,'
p38668
aS'                               "time_stepping - 3 perform update");'
p38669
aS'      const auto on_subranges = //'
p38670
aS'        [&](const auto i1, const auto i2) {'
p38671
aS'          for (const auto i : boost::make_iterator_range(i1, i2))'
p38672
aS'            {'
p38673
aS'              Assert(i < n_locally_owned, ExcInternalError());'
p38674
aS'              const auto U_i = gather(U, i);'
p38675
aS'              const auto   f_i = ProblemDescription<dim>::flux(U_i);'
p38676
aS'              const double m_i = lumped_mass_matrix.diag_element(i);'
p38677
aS'              auto U_i_new = U_i;'
p38678
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p38679
aS'                {'
p38680
aS'                  const auto j = jt->column();'
p38681
aS'                  const auto U_j = gather(U, j);'
p38682
aS'                  const auto f_j = ProblemDescription<dim>::flux(U_j);'
p38683
aS'                  const auto c_ij = gather_get_entry(cij_matrix, jt);'
p38684
aS'                  const auto d_ij = get_entry(dij_matrix, jt);'
p38685
aS'                  for (unsigned int k = 0; k < problem_dimension; ++k)'
p38686
aS'                    {'
p38687
aS'                      U_i_new[k] +='
p38688
aS'                        tau_max / m_i *'
p38689
aS'                    }'
p38690
aS'                }'
p38691
aS'              scatter(temporary_vector, U_i_new, i);'
p38692
aS'            }'
p38693
aS'        };'
p38694
aS'      parallel::apply_to_subranges(indices_owned.begin(),'
p38695
aS'                                   indices_owned.end(),'
p38696
aS'                                   on_subranges,'
p38697
aS'                                   4096);'
p38698
aS'    }'
p38699
aS'    {'
p38700
aS'      TimerOutput::Scope scope(computing_timer,'
p38701
aS'                               "time_stepping - 4 fix boundary states");'
p38702
aS'      for (auto it : boundary_normal_map)'
p38703
aS'        {'
p38704
aS'          const auto i = it.first;'
p38705
aS'          if (i >= n_locally_owned)'
p38706
aS'            continue;'
p38707
aS'          const auto &normal   = std::get<0>(it.second);'
p38708
aS'          const auto &id       = std::get<1>(it.second);'
p38709
aS'          const auto &position = std::get<2>(it.second);'
p38710
aS'          auto U_i = gather(temporary_vector, i);'
p38711
aS'          if (id == Boundaries::free_slip)'
p38712
aS'            {'
p38713
aS'              auto m = ProblemDescription<dim>::momentum(U_i);'
p38714
aS'              m -= (m * normal) * normal;'
p38715
aS'              for (unsigned int k = 0; k < dim; ++k)'
p38716
aS'                U_i[k + 1] = m[k];'
p38717
aS'            }'
p38718
aS'          else if (id == Boundaries::dirichlet)'
p38719
aS'            {'
p38720
aS'              U_i = initial_values->initial_state(position, t + tau_max);'
p38721
aS'            }'
p38722
aS'          scatter(temporary_vector, U_i, i);'
p38723
aS'        }'
p38724
aS'    }'
p38725
aS'    for (auto &it : temporary_vector)'
p38726
aS'      it.update_ghost_values();'
p38727
aS'    U.swap(temporary_vector);'
p38728
aS'    return tau_max;'
p38729
aS'  }'
p38730
aS'  template <int dim>'
p38731
aS'  SchlierenPostprocessor<dim>::SchlierenPostprocessor('
p38732
aS'    const MPI_Comm          mpi_communicator,'
p38733
aS'    TimerOutput &           computing_timer,'
p38734
aS'    const OfflineData<dim> &offline_data,'
p38735
aS'    const std::string &     subsection /*= "SchlierenPostprocessor"*/)'
p38736
aS'    : ParameterAcceptor(subsection)'
p38737
aS'    , mpi_communicator(mpi_communicator)'
p38738
aS'    , computing_timer(computing_timer)'
p38739
aS'    , offline_data(&offline_data)'
p38740
aS'  {'
p38741
aS'    schlieren_beta = 10.;'
p38742
aS'    add_parameter("schlieren beta",'
p38743
aS'                  schlieren_beta,'
p38744
aS'                  "Beta factor used in Schlieren-type postprocessor");'
p38745
aS'    schlieren_index = 0;'
p38746
aS'    add_parameter("schlieren index",'
p38747
aS'                  schlieren_index,'
p38748
aS'                  "Use the corresponding component of the state vector for the "'
p38749
aS'                  "schlieren plot");'
p38750
aS'  }'
p38751
aS'  template <int dim>'
p38752
aS'  void SchlierenPostprocessor<dim>::prepare()'
p38753
aS'  {'
p38754
aS'    TimerOutput::Scope scope(computing_timer,'
p38755
aS'                             "schlieren_postprocessor - prepare scratch space");'
p38756
aS'    r.reinit(offline_data->n_locally_relevant);'
p38757
aS'    schlieren.reinit(offline_data->partitioner);'
p38758
aS'  }'
p38759
aS'  template <int dim>'
p38760
aS'  void SchlierenPostprocessor<dim>::compute_schlieren(const vector_type &U)'
p38761
aS'  {'
p38762
aS'    TimerOutput::Scope scope('
p38763
aS'      computing_timer, "schlieren_postprocessor - compute schlieren plot");'
p38764
aS'    const auto &sparsity            = offline_data->sparsity_pattern;'
p38765
aS'    const auto &lumped_mass_matrix  = offline_data->lumped_mass_matrix;'
p38766
aS'    const auto &cij_matrix          = offline_data->cij_matrix;'
p38767
aS'    const auto &boundary_normal_map = offline_data->boundary_normal_map;'
p38768
aS'    const auto &n_locally_owned     = offline_data->n_locally_owned;'
p38769
aS'    const auto indices ='
p38770
aS'      std_cxx20::ranges::iota_view<unsigned int, unsigned int>(0,'
p38771
aS'                                                               n_locally_owned);'
p38772
aS'    std::atomic<double> r_i_max{0.};'
p38773
aS'    std::atomic<double> r_i_min{std::numeric_limits<double>::infinity()};'
p38774
aS'    {'
p38775
aS'      const auto on_subranges = //'
p38776
aS'        [&](const auto i1, const auto i2) {'
p38777
aS'          double r_i_max_on_subrange = 0.;'
p38778
aS'          double r_i_min_on_subrange = std::numeric_limits<double>::infinity();'
p38779
aS'          for (const auto i : boost::make_iterator_range(i1, i2))'
p38780
aS'            {'
p38781
aS'              Assert(i < n_locally_owned, ExcInternalError());'
p38782
aS'              Tensor<1, dim> r_i;'
p38783
aS'              for (auto jt = sparsity.begin(i); jt != sparsity.end(i); ++jt)'
p38784
aS'                {'
p38785
aS'                  const auto j = jt->column();'
p38786
aS'                  if (i == j)'
p38787
aS'                    continue;'
p38788
aS'                  const auto U_js = U[schlieren_index].local_element(j);'
p38789
aS'                  const auto c_ij = gather_get_entry(cij_matrix, jt);'
p38790
aS'                  r_i += c_ij * U_js;'
p38791
aS'                }'
p38792
aS'              const auto bnm_it = boundary_normal_map.find(i);'
p38793
aS'              if (bnm_it != boundary_normal_map.end())'
p38794
aS'                {'
p38795
aS'                  const auto &normal = std::get<0>(bnm_it->second);'
p38796
aS'                  const auto &id     = std::get<1>(bnm_it->second);'
p38797
aS'                  if (id == Boundaries::free_slip)'
p38798
aS'                    r_i -= 1. * (r_i * normal) * normal;'
p38799
aS'                  else'
p38800
aS'                    r_i = 0.;'
p38801
aS'                }'
p38802
aS'              const double m_i    = lumped_mass_matrix.diag_element(i);'
p38803
aS'              r[i]                = r_i.norm() / m_i;'
p38804
aS'              r_i_max_on_subrange = std::max(r_i_max_on_subrange, r[i]);'
p38805
aS'              r_i_min_on_subrange = std::min(r_i_min_on_subrange, r[i]);'
p38806
aS'            }'
p38807
aS'          double current_r_i_max = r_i_max.load();'
p38808
aS'          while (current_r_i_max < r_i_max_on_subrange &&'
p38809
aS'                 !r_i_max.compare_exchange_weak(current_r_i_max,'
p38810
aS'                                                r_i_max_on_subrange))'
p38811
aS'            ;'
p38812
aS'          double current_r_i_min = r_i_min.load();'
p38813
aS'          while (current_r_i_min > r_i_min_on_subrange &&'
p38814
aS'                 !r_i_min.compare_exchange_weak(current_r_i_min,'
p38815
aS'                                                r_i_min_on_subrange))'
p38816
aS'            ;'
p38817
aS'        };'
p38818
aS'      parallel::apply_to_subranges(indices.begin(),'
p38819
aS'                                   indices.end(),'
p38820
aS'                                   on_subranges,'
p38821
aS'                                   4096);'
p38822
aS'    }'
p38823
aS'    r_i_max.store(Utilities::MPI::max(r_i_max.load(), mpi_communicator));'
p38824
aS'    r_i_min.store(Utilities::MPI::min(r_i_min.load(), mpi_communicator));'
p38825
aS'    {'
p38826
aS'      const auto on_subranges = //'
p38827
aS'        [&](const auto i1, const auto i2) {'
p38828
aS'          for (const auto i : boost::make_iterator_range(i1, i2))'
p38829
aS'            {'
p38830
aS'              Assert(i < n_locally_owned, ExcInternalError());'
p38831
aS'              schlieren.local_element(i) ='
p38832
aS'                1. - std::exp(-schlieren_beta * (r[i] - r_i_min) /'
p38833
aS'            }'
p38834
aS'        };'
p38835
aS'      parallel::apply_to_subranges(indices.begin(),'
p38836
aS'                                   indices.end(),'
p38837
aS'                                   on_subranges,'
p38838
aS'                                   4096);'
p38839
aS'    }'
p38840
aS'    schlieren.update_ghost_values();'
p38841
aS'  }'
p38842
aS'  template <int dim>'
p38843
aS'  MainLoop<dim>::MainLoop(const MPI_Comm mpi_communicator)'
p38844
aS'    : ParameterAcceptor("A - MainLoop")'
p38845
aS'    , mpi_communicator(mpi_communicator)'
p38846
aS'    , computing_timer(mpi_communicator,'
p38847
aS'                      timer_output,'
p38848
aS'                      TimerOutput::never,'
p38849
aS'                      TimerOutput::cpu_and_wall_times)'
p38850
aS'    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)'
p38851
aS'    , discretization(mpi_communicator, computing_timer, "B - Discretization")'
p38852
aS'    , offline_data(mpi_communicator,'
p38853
aS'                   computing_timer,'
p38854
aS'                   discretization,'
p38855
aS'                   "C - OfflineData")'
p38856
aS'    , initial_values("D - InitialValues")'
p38857
aS'    , time_stepping(mpi_communicator,'
p38858
aS'                    computing_timer,'
p38859
aS'                    offline_data,'
p38860
aS'                    initial_values,'
p38861
aS'                    "E - TimeStepping")'
p38862
aS'    , schlieren_postprocessor(mpi_communicator,'
p38863
aS'                              computing_timer,'
p38864
aS'                              offline_data,'
p38865
aS'                              "F - SchlierenPostprocessor")'
p38866
aS'  {'
p38867
aS'    base_name = "test";'
p38868
aS'    add_parameter("basename", base_name, "Base name for all output files");'
p38869
aS'    t_final = 4.;'
p38870
aS'    add_parameter("final time", t_final, "Final time");'
p38871
aS'    output_granularity = 0.02;'
p38872
aS'    add_parameter("output granularity",'
p38873
aS'                  output_granularity,'
p38874
aS'                  "time interval for output");'
p38875
aS'    asynchronous_writeback = true;'
p38876
aS'    add_parameter("asynchronous writeback",'
p38877
aS'                  asynchronous_writeback,'
p38878
aS'                  "Write out solution in a background thread performing IO");'
p38879
aS'    resume = false;'
p38880
aS'    add_parameter("resume", resume, "Resume an interrupted computation.");'
p38881
aS'  }'
p38882
aS'  namespace'
p38883
aS'  {'
p38884
aS'    void print_head(ConditionalOStream &pcout,'
p38885
aS'                    const std::string & header,'
p38886
aS'                    const std::string & secondary = "")'
p38887
aS'    {'
p38888
aS'      const auto header_size   = header.size();'
p38889
aS"      const auto padded_header = std::string((34 - header_size) / 2, ' ') +"
p38890
aS'                                 header +'
p38891
aS"                                 std::string((35 - header_size) / 2, ' ');"
p38892
aS'      const auto secondary_size = secondary.size();'
p38893
aS'      const auto padded_secondary ='
p38894
aS"        std::string((34 - secondary_size) / 2, ' ') + secondary +"
p38895
aS"        std::string((35 - secondary_size) / 2, ' ');"
p38896
aS'      pcout << std::endl;'
p38897
aS'      pcout << "    ####################################################" << std::endl;'
p38898
aS'      pcout << "    #########                                  #########" << std::endl;'
p38899
aS'      pcout << "    #########"     <<  padded_header   <<     "#########" << std::endl;'
p38900
aS'      pcout << "    #########"     << padded_secondary <<     "#########" << std::endl;'
p38901
aS'      pcout << "    #########                                  #########" << std::endl;'
p38902
aS'      pcout << "    ####################################################" << std::endl;'
p38903
aS'      pcout << std::endl;'
p38904
aS'    }'
p38905
aS'  } // namespace'
p38906
aS'  template <int dim>'
p38907
aS'  void MainLoop<dim>::run()'
p38908
aS'  {'
p38909
aS'    pcout << "Reading parameters and allocating objects... " << std::flush;'
p38910
aS'    ParameterAcceptor::initialize("step-69.prm");'
p38911
aS'    pcout << "done" << std::endl;'
p38912
aS'    {'
p38913
aS'      print_head(pcout, "create triangulation");'
p38914
aS'      discretization.setup();'
p38915
aS'      pcout << "Number of active cells:       "'
p38916
aS'            << discretization.triangulation.n_global_active_cells()'
p38917
aS'            << std::endl;'
p38918
aS'      print_head(pcout, "compute offline data");'
p38919
aS'      offline_data.setup();'
p38920
aS'      offline_data.assemble();'
p38921
aS'      pcout << "Number of degrees of freedom: "'
p38922
aS'            << offline_data.dof_handler.n_dofs() << std::endl;'
p38923
aS'      print_head(pcout, "set up time step");'
p38924
aS'      time_stepping.prepare();'
p38925
aS'      schlieren_postprocessor.prepare();'
p38926
aS'    }'
p38927
aS'    double       t            = 0.;'
p38928
aS'    unsigned int output_cycle = 0;'
p38929
aS'    print_head(pcout, "interpolate initial values");'
p38930
aS'    vector_type U = interpolate_initial_values();'
p38931
aS'    if (resume)'
p38932
aS'      {'
p38933
aS'        print_head(pcout, "restore interrupted computation");'
p38934
aS'        const unsigned int i ='
p38935
aS'          discretization.triangulation.locally_owned_subdomain();'
p38936
aS'        const std::string name = base_name + "-checkpoint-" +'
p38937
aS'                                 Utilities::int_to_string(i, 4) + ".archive";'
p38938
aS'        std::ifstream file(name, std::ios::binary);'
p38939
aS'        boost::archive::binary_iarchive ia(file);'
p38940
aS'        ia >> t >> output_cycle;'
p38941
aS'        for (auto &it1 : U)'
p38942
aS'          {'
p38943
aS'            for (auto &it2 : it1)'
p38944
aS'              ia >> it2;'
p38945
aS'            it1.update_ghost_values();'
p38946
aS'          }'
p38947
aS'      }'
p38948
aS'    output(U, base_name, t, output_cycle++);'
p38949
aS'    print_head(pcout, "enter main loop");'
p38950
aS'    for (unsigned int cycle = 1; t < t_final; ++cycle)'
p38951
aS'      {'
p38952
aS'        std::ostringstream head;'
p38953
aS'        std::ostringstream secondary;'
p38954
aS'        head << "Cycle  " << Utilities::int_to_string(cycle, 6) << "  (" //'
p38955
aS'             << std::fixed << std::setprecision(1) << t / t_final * 100  //'
p38956
aS'             << "%)";'
p38957
aS'        secondary << "at time t = " << std::setprecision(8) << std::fixed << t;'
p38958
aS'        print_head(pcout, head.str(), secondary.str());'
p38959
aS'        t += time_stepping.make_one_step(U, t);'
p38960
aS'        if (t > output_cycle * output_granularity)'
p38961
aS'          {'
p38962
aS'            output(U, base_name, t, output_cycle, true);'
p38963
aS'            ++output_cycle;'
p38964
aS'          }'
p38965
aS'      }'
p38966
aS'    if (background_thread_state.valid())'
p38967
aS'      background_thread_state.wait();'
p38968
aS'    computing_timer.print_summary();'
p38969
aS'    pcout << timer_output.str() << std::endl;'
p38970
aS'  }'
p38971
aS'  template <int dim>'
p38972
aS'  typename MainLoop<dim>::vector_type'
p38973
aS'  MainLoop<dim>::interpolate_initial_values(const double t)'
p38974
aS'  {'
p38975
aS'    pcout << "MainLoop<dim>::interpolate_initial_values(t = " << t << ")"'
p38976
aS'          << std::endl;'
p38977
aS'    TimerOutput::Scope scope(computing_timer,'
p38978
aS'                             "main_loop - setup scratch space");'
p38979
aS'    vector_type U;'
p38980
aS'    for (auto &it : U)'
p38981
aS'      it.reinit(offline_data.partitioner);'
p38982
aS'    constexpr auto problem_dimension ='
p38983
aS'      ProblemDescription<dim>::problem_dimension;'
p38984
aS'    for (unsigned int i = 0; i < problem_dimension; ++i)'
p38985
aS'      VectorTools::interpolate(offline_data.dof_handler,'
p38986
aS'                               ScalarFunctionFromFunctionObject<dim, double>('
p38987
aS'                                 [&](const Point<dim> &x) {'
p38988
aS'                                   return initial_values.initial_state(x, t)[i];'
p38989
aS'                                 }),'
p38990
aS'                               U[i]);'
p38991
aS'    for (auto &it : U)'
p38992
aS'      it.update_ghost_values();'
p38993
aS'    return U;'
p38994
aS'  }'
p38995
aS'  template <int dim>'
p38996
aS'  void MainLoop<dim>::output(const typename MainLoop<dim>::vector_type &U,'
p38997
aS'                             const std::string &                        name,'
p38998
aS'                             const double                               t,'
p38999
aS'                             const unsigned int                         cycle,'
p39000
aS'                             const bool checkpoint)'
p39001
aS'  {'
p39002
aS'    pcout << "MainLoop<dim>::output(t = " << t'
p39003
aS'          << ", checkpoint = " << checkpoint << ")" << std::endl;'
p39004
aS'    if (background_thread_state.valid())'
p39005
aS'      {'
p39006
aS'        TimerOutput::Scope timer(computing_timer, "main_loop - stalled output");'
p39007
aS'        background_thread_state.wait();'
p39008
aS'      }'
p39009
aS'    constexpr auto problem_dimension ='
p39010
aS'      ProblemDescription<dim>::problem_dimension;'
p39011
aS'    for (unsigned int i = 0; i < problem_dimension; ++i)'
p39012
aS'      {'
p39013
aS'        output_vector[i] = U[i];'
p39014
aS'        output_vector[i].update_ghost_values();'
p39015
aS'      }'
p39016
aS'    schlieren_postprocessor.compute_schlieren(output_vector);'
p39017
aS'    auto data_out = std::make_shared<DataOut<dim>>();'
p39018
aS'    data_out->attach_dof_handler(offline_data.dof_handler);'
p39019
aS'    const auto &component_names = ProblemDescription<dim>::component_names;'
p39020
aS'    for (unsigned int i = 0; i < problem_dimension; ++i)'
p39021
aS'      data_out->add_data_vector(output_vector[i], component_names[i]);'
p39022
aS'    data_out->add_data_vector(schlieren_postprocessor.schlieren,'
p39023
aS'                              "schlieren_plot");'
p39024
aS'    data_out->build_patches(discretization.mapping,'
p39025
aS'                            discretization.finite_element.degree - 1);'
p39026
aS'    const auto output_worker = [this, name, t, cycle, checkpoint, data_out]() {'
p39027
aS'      if (checkpoint)'
p39028
aS'        {'
p39029
aS'          const unsigned int i ='
p39030
aS'            discretization.triangulation.locally_owned_subdomain();'
p39031
aS'          std::string filename ='
p39032
aS'            name + "-checkpoint-" + Utilities::int_to_string(i, 4) + ".archive";'
p39033
aS'          std::ofstream file(filename, std::ios::binary | std::ios::trunc);'
p39034
aS'          boost::archive::binary_oarchive oa(file);'
p39035
aS'          oa << t << cycle;'
p39036
aS'          for (const auto &it1 : output_vector)'
p39037
aS'            for (const auto &it2 : it1)'
p39038
aS'              oa << it2;'
p39039
aS'        }'
p39040
aS'      DataOutBase::VtkFlags flags(t,'
p39041
aS'                                  cycle,'
p39042
aS'                                  true,'
p39043
aS'                                  DataOutBase::VtkFlags::best_speed);'
p39044
aS'      data_out->set_flags(flags);'
p39045
aS'      data_out->write_vtu_with_pvtu_record('
p39046
aS'        "", name + "-solution", cycle, mpi_communicator, 6);'
p39047
aS'    };'
p39048
aS'    if (asynchronous_writeback)'
p39049
aS'      {'
p39050
aS'        background_thread_state = std::async(std::launch::async, output_worker);'
p39051
aS'      }'
p39052
aS'    else'
p39053
aS'      {'
p39054
aS'        output_worker();'
p39055
aS'      }'
p39056
aS'  }'
p39057
aS'} // namespace Step69'
p39058
aS'int main(int argc, char *argv[])'
p39059
ag9
aS'  try'
p39060
aS'    {'
p39061
aS'      constexpr int dim = 2;'
p39062
aS'      using namespace dealii;'
p39063
aS'      using namespace Step69;'
p39064
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);'
p39065
aS'      MPI_Comm      mpi_communicator(MPI_COMM_WORLD);'
p39066
aS'      MainLoop<dim> main_loop(mpi_communicator);'
p39067
aS'      main_loop.run();'
p39068
aS'    }'
p39069
aS'  catch (std::exception &exc)'
p39070
aS'    {'
p39071
aS'      std::cerr << std::endl'
p39072
aS'                << std::endl'
p39073
aS'                << "----------------------------------------------------"'
p39074
aS'                << std::endl;'
p39075
aS'      std::cerr << "Exception on processing: " << std::endl'
p39076
aS'                << exc.what() << std::endl'
p39077
aS'                << "Aborting!" << std::endl'
p39078
aS'                << "----------------------------------------------------"'
p39079
aS'                << std::endl;'
p39080
aS'      return 1;'
p39081
aS'    }'
p39082
aS'  catch (...)'
p39083
aS'    {'
p39084
aS'      std::cerr << std::endl'
p39085
aS'                << std::endl'
p39086
aS'                << "----------------------------------------------------"'
p39087
aS'                << std::endl;'
p39088
aS'      std::cerr << "Unknown exception!" << std::endl'
p39089
aS'                << "Aborting!" << std::endl'
p39090
aS'                << "----------------------------------------------------"'
p39091
aS'                << std::endl;'
p39092
aS'      return 1;'
p39093
aS'    };'
p39094
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p39095
aS'#include <deal.II/base/function.h>'
p39096
aS'#include <deal.II/base/logstream.h>'
p39097
aS'#include <deal.II/lac/vector.h>'
p39098
aS'#include <deal.II/lac/full_matrix.h>'
p39099
aS'#include <deal.II/lac/sparse_matrix.h>'
p39100
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p39101
aS'#include <deal.II/lac/solver_cg.h>'
p39102
aS'#include <deal.II/lac/precondition.h>'
p39103
aS'#include <deal.II/lac/affine_constraints.h>'
p39104
aS'#include <deal.II/grid/tria.h>'
p39105
aS'#include <deal.II/grid/grid_generator.h>'
p39106
aS'#include <deal.II/grid/grid_refinement.h>'
p39107
aS'#include <deal.II/dofs/dof_handler.h>'
p39108
aS'#include <deal.II/dofs/dof_tools.h>'
p39109
aS'#include <deal.II/fe/fe_q.h>'
p39110
aS'#include <deal.II/numerics/matrix_tools.h>'
p39111
aS'#include <deal.II/numerics/error_estimator.h>'
p39112
aS'#include <deal.II/numerics/data_out.h>'
p39113
aS'#include <deal.II/dofs/dof_renumbering.h>'
p39114
aS'#include <deal.II/base/smartpointer.h>'
p39115
aS'#include <deal.II/numerics/vector_tools.h>'
p39116
aS'#include <deal.II/base/convergence_table.h>'
p39117
aS'#include <deal.II/fe/fe_values.h>'
p39118
aS'#include <array>'
p39119
aS'#include <fstream>'
p39120
aS'#include <iostream>'
p39121
aS'namespace Step7'
p39122
ag9
aS'  using namespace dealii;'
p39123
aS'  template <int dim>'
p39124
aS'  class SolutionBase'
p39125
aS'  {'
p39126
aS'  protected:'
p39127
aS'    static const std::array<Point<dim>, 3> source_centers;'
p39128
aS'    static const double                    width;'
p39129
aS'  };'
p39130
aS'  template <>'
p39131
aS'  const std::array<Point<1>, 3> SolutionBase<1>::source_centers = {'
p39132
aS'    {Point<1>(-1.0 / 3.0), Point<1>(0.0), Point<1>(+1.0 / 3.0)}};'
p39133
aS'  template <>'
p39134
aS'  const std::array<Point<2>, 3> SolutionBase<2>::source_centers = {'
p39135
aS'    {Point<2>(-0.5, +0.5), Point<2>(-0.5, -0.5), Point<2>(+0.5, -0.5)}};'
p39136
aS'  template <int dim>'
p39137
aS'  const double SolutionBase<dim>::width = 1. / 8.;'
p39138
aS'  template <int dim>'
p39139
aS'  class Solution : public Function<dim>, protected SolutionBase<dim>'
p39140
aS'  {'
p39141
aS'  public:'
p39142
aS'    virtual double value(const Point<dim> & p,'
p39143
aS'                         const unsigned int component = 0) const override;'
p39144
aS'    virtual Tensor<1, dim>'
p39145
aS'    gradient(const Point<dim> & p,'
p39146
aS'             const unsigned int component = 0) const override;'
p39147
aS'  };'
p39148
aS'  template <int dim>'
p39149
aS'  double Solution<dim>::value(const Point<dim> &p, const unsigned int) const'
p39150
aS'  {'
p39151
aS'    double return_value = 0;'
p39152
aS'    for (const auto &center : this->source_centers)'
p39153
aS'      {'
p39154
aS'        const Tensor<1, dim> x_minus_xi = p - center;'
p39155
aS'        return_value +='
p39156
aS'          std::exp(-x_minus_xi.norm_square() / (this->width * this->width));'
p39157
aS'      }'
p39158
aS'    return return_value;'
p39159
aS'  }'
p39160
aS'  template <int dim>'
p39161
aS'  Tensor<1, dim> Solution<dim>::gradient(const Point<dim> &p,'
p39162
aS'                                         const unsigned int) const'
p39163
aS'  {'
p39164
aS'    Tensor<1, dim> return_value;'
p39165
aS'    for (const auto &center : this->source_centers)'
p39166
aS'      {'
p39167
aS'        const Tensor<1, dim> x_minus_xi = p - center;'
p39168
aS'        return_value +='
p39169
aS'           std::exp(-x_minus_xi.norm_square() / (this->width * this->width)) *'
p39170
aS'           x_minus_xi);'
p39171
aS'      }'
p39172
aS'    return return_value;'
p39173
aS'  }'
p39174
aS'  template <int dim>'
p39175
aS'  class RightHandSide : public Function<dim>, protected SolutionBase<dim>'
p39176
aS'  {'
p39177
aS'  public:'
p39178
aS'    virtual double value(const Point<dim> & p,'
p39179
aS'                         const unsigned int component = 0) const override;'
p39180
aS'  };'
p39181
aS'  template <int dim>'
p39182
aS'  double RightHandSide<dim>::value(const Point<dim> &p,'
p39183
aS'                                   const unsigned int) const'
p39184
aS'  {'
p39185
aS'    double return_value = 0;'
p39186
aS'    for (const auto &center : this->source_centers)'
p39187
aS'      {'
p39188
aS'        const Tensor<1, dim> x_minus_xi = p - center;'
p39189
aS'        return_value +='
p39190
aS'            4. * x_minus_xi.norm_square() / (this->width * this->width)) /'
p39191
aS'           std::exp(-x_minus_xi.norm_square() / (this->width * this->width)));'
p39192
aS'        return_value +='
p39193
aS'          std::exp(-x_minus_xi.norm_square() / (this->width * this->width));'
p39194
aS'      }'
p39195
aS'    return return_value;'
p39196
aS'  }'
p39197
aS'  template <int dim>'
p39198
aS'  class HelmholtzProblem'
p39199
aS'  {'
p39200
aS'  public:'
p39201
aS'    enum RefinementMode'
p39202
aS'    {'
p39203
aS'      global_refinement,'
p39204
aS'      adaptive_refinement'
p39205
aS'    };'
p39206
aS'    HelmholtzProblem(const FiniteElement<dim> &fe,'
p39207
aS'                     const RefinementMode      refinement_mode);'
p39208
aS'    void run();'
p39209
aS'  private:'
p39210
aS'    void setup_system();'
p39211
aS'    void assemble_system();'
p39212
aS'    void solve();'
p39213
aS'    void refine_grid();'
p39214
aS'    void process_solution(const unsigned int cycle);'
p39215
aS'    Triangulation<dim> triangulation;'
p39216
aS'    DoFHandler<dim>    dof_handler;'
p39217
aS'    SmartPointer<const FiniteElement<dim>> fe;'
p39218
aS'    AffineConstraints<double> hanging_node_constraints;'
p39219
aS'    SparsityPattern      sparsity_pattern;'
p39220
aS'    SparseMatrix<double> system_matrix;'
p39221
aS'    Vector<double> solution;'
p39222
aS'    Vector<double> system_rhs;'
p39223
aS'    const RefinementMode refinement_mode;'
p39224
aS'    ConvergenceTable convergence_table;'
p39225
aS'  };'
p39226
aS'  template <int dim>'
p39227
aS'  HelmholtzProblem<dim>::HelmholtzProblem(const FiniteElement<dim> &fe,'
p39228
aS'                                          const RefinementMode refinement_mode)'
p39229
aS'    : dof_handler(triangulation)'
p39230
aS'    , fe(&fe)'
p39231
aS'    , refinement_mode(refinement_mode)'
p39232
aS'  {}'
p39233
aS'  template <int dim>'
p39234
aS'  void HelmholtzProblem<dim>::setup_system()'
p39235
aS'  {'
p39236
aS'    dof_handler.distribute_dofs(*fe);'
p39237
aS'    DoFRenumbering::Cuthill_McKee(dof_handler);'
p39238
aS'    hanging_node_constraints.clear();'
p39239
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p39240
aS'                                            hanging_node_constraints);'
p39241
aS'    hanging_node_constraints.close();'
p39242
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p39243
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p39244
aS'    hanging_node_constraints.condense(dsp);'
p39245
aS'    sparsity_pattern.copy_from(dsp);'
p39246
aS'    system_matrix.reinit(sparsity_pattern);'
p39247
aS'    solution.reinit(dof_handler.n_dofs());'
p39248
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p39249
aS'  }'
p39250
aS'  template <int dim>'
p39251
aS'  void HelmholtzProblem<dim>::assemble_system()'
p39252
aS'  {'
p39253
aS'    QGauss<dim>     quadrature_formula(fe->degree + 1);'
p39254
aS'    QGauss<dim - 1> face_quadrature_formula(fe->degree + 1);'
p39255
aS'    const unsigned int n_q_points      = quadrature_formula.size();'
p39256
aS'    const unsigned int n_face_q_points = face_quadrature_formula.size();'
p39257
aS'    const unsigned int dofs_per_cell = fe->n_dofs_per_cell();'
p39258
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p39259
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p39260
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p39261
aS'    FEValues<dim> fe_values(*fe,'
p39262
aS'                            quadrature_formula,'
p39263
aS'                            update_values | update_gradients |'
p39264
aS'                              update_quadrature_points | update_JxW_values);'
p39265
aS'    FEFaceValues<dim> fe_face_values(*fe,'
p39266
aS'                                     face_quadrature_formula,'
p39267
aS'                                     update_values | update_quadrature_points |'
p39268
aS'                                       update_normal_vectors |'
p39269
aS'                                       update_JxW_values);'
p39270
aS'    const RightHandSide<dim> right_hand_side;'
p39271
aS'    std::vector<double>      rhs_values(n_q_points);'
p39272
aS'    Solution<dim> exact_solution;'
p39273
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p39274
aS'      {'
p39275
aS'        cell_matrix = 0.;'
p39276
aS'        cell_rhs    = 0.;'
p39277
aS'        fe_values.reinit(cell);'
p39278
aS'        right_hand_side.value_list(fe_values.get_quadrature_points(),'
p39279
aS'                                   rhs_values);'
p39280
aS'        for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p39281
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p39282
aS'            {'
p39283
aS'              for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p39284
aS'                cell_matrix(i, j) +='
p39285
aS'                      fe_values.shape_grad(j, q_point)     // grad phi_j(x_q)'
p39286
aS'                    +                                      //'
p39287
aS'                    fe_values.shape_value(i, q_point) *    // phi_i(x_q)'
p39288
aS'                      fe_values.shape_value(j, q_point)) * // phi_j(x_q)'
p39289
aS'                   fe_values.JxW(q_point));                // dx'
p39290
aS'              cell_rhs(i) += (fe_values.shape_value(i, q_point) * // phi_i(x_q)'
p39291
aS'                              rhs_values[q_point] *               // f(x_q)'
p39292
aS'                              fe_values.JxW(q_point));            // dx'
p39293
aS'            }'
p39294
aS'        for (const auto &face : cell->face_iterators())'
p39295
aS'          if (face->at_boundary() && (face->boundary_id() == 1))'
p39296
aS'            {'
p39297
aS'              fe_face_values.reinit(cell, face);'
p39298
aS'              for (unsigned int q_point = 0; q_point < n_face_q_points;'
p39299
aS'                   ++q_point)'
p39300
aS'                {'
p39301
aS'                  const double neumann_value ='
p39302
aS'                       fe_face_values.quadrature_point(q_point)) *'
p39303
aS'                     fe_face_values.normal_vector(q_point));'
p39304
aS'                  for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p39305
aS'                    cell_rhs(i) +='
p39306
aS'                       neumann_value *                          // g(x_q)'
p39307
aS'                       fe_face_values.JxW(q_point));            // dx'
p39308
aS'                }'
p39309
aS'            }'
p39310
aS'        cell->get_dof_indices(local_dof_indices);'
p39311
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p39312
aS'          {'
p39313
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p39314
aS'              system_matrix.add(local_dof_indices[i],'
p39315
aS'                                local_dof_indices[j],'
p39316
aS'                                cell_matrix(i, j));'
p39317
aS'            system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p39318
aS'          }'
p39319
aS'      }'
p39320
aS'    hanging_node_constraints.condense(system_matrix);'
p39321
aS'    hanging_node_constraints.condense(system_rhs);'
p39322
aS'    std::map<types::global_dof_index, double> boundary_values;'
p39323
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p39324
aS'                                             0,'
p39325
aS'                                             Solution<dim>(),'
p39326
aS'                                             boundary_values);'
p39327
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p39328
aS'                                       system_matrix,'
p39329
aS'                                       solution,'
p39330
aS'                                       system_rhs);'
p39331
aS'  }'
p39332
aS'  template <int dim>'
p39333
aS'  void HelmholtzProblem<dim>::solve()'
p39334
aS'  {'
p39335
aS'    SolverControl            solver_control(1000, 1e-12);'
p39336
aS'    SolverCG<Vector<double>> cg(solver_control);'
p39337
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p39338
aS'    preconditioner.initialize(system_matrix, 1.2);'
p39339
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p39340
aS'    hanging_node_constraints.distribute(solution);'
p39341
aS'  }'
p39342
aS'  template <int dim>'
p39343
aS'  void HelmholtzProblem<dim>::refine_grid()'
p39344
aS'  {'
p39345
aS'    switch (refinement_mode)'
p39346
aS'      {'
p39347
aS'        case global_refinement:'
p39348
aS'          {'
p39349
aS'            triangulation.refine_global(1);'
p39350
aS'            break;'
p39351
aS'          }'
p39352
aS'        case adaptive_refinement:'
p39353
aS'          {'
p39354
aS'            Vector<float> estimated_error_per_cell('
p39355
aS'              triangulation.n_active_cells());'
p39356
aS'            KellyErrorEstimator<dim>::estimate('
p39357
aS'              dof_handler,'
p39358
aS'              QGauss<dim - 1>(fe->degree + 1),'
p39359
aS'              std::map<types::boundary_id, const Function<dim> *>(),'
p39360
aS'              solution,'
p39361
aS'              estimated_error_per_cell);'
p39362
aS'            GridRefinement::refine_and_coarsen_fixed_number('
p39363
aS'              triangulation, estimated_error_per_cell, 0.3, 0.03);'
p39364
aS'            triangulation.execute_coarsening_and_refinement();'
p39365
aS'            break;'
p39366
aS'          }'
p39367
aS'        default:'
p39368
aS'          {'
p39369
aS'            Assert(false, ExcNotImplemented());'
p39370
aS'          }'
p39371
aS'      }'
p39372
aS'  }'
p39373
aS'  template <int dim>'
p39374
aS'  void HelmholtzProblem<dim>::process_solution(const unsigned int cycle)'
p39375
aS'  {'
p39376
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p39377
aS'    VectorTools::integrate_difference(dof_handler,'
p39378
aS'                                      solution,'
p39379
aS'                                      Solution<dim>(),'
p39380
aS'                                      difference_per_cell,'
p39381
aS'                                      QGauss<dim>(fe->degree + 1),'
p39382
aS'                                      VectorTools::L2_norm);'
p39383
aS'    const double L2_error ='
p39384
aS'      VectorTools::compute_global_error(triangulation,'
p39385
aS'                                        difference_per_cell,'
p39386
aS'                                        VectorTools::L2_norm);'
p39387
aS'    VectorTools::integrate_difference(dof_handler,'
p39388
aS'                                      solution,'
p39389
aS'                                      Solution<dim>(),'
p39390
aS'                                      difference_per_cell,'
p39391
aS'                                      QGauss<dim>(fe->degree + 1),'
p39392
aS'                                      VectorTools::H1_seminorm);'
p39393
aS'    const double H1_error ='
p39394
aS'      VectorTools::compute_global_error(triangulation,'
p39395
aS'                                        difference_per_cell,'
p39396
aS'                                        VectorTools::H1_seminorm);'
p39397
aS'    const QTrapezoid<1>  q_trapez;'
p39398
aS'    const QIterated<dim> q_iterated(q_trapez, fe->degree * 2 + 1);'
p39399
aS'    VectorTools::integrate_difference(dof_handler,'
p39400
aS'                                      solution,'
p39401
aS'                                      Solution<dim>(),'
p39402
aS'                                      difference_per_cell,'
p39403
aS'                                      q_iterated,'
p39404
aS'                                      VectorTools::Linfty_norm);'
p39405
aS'    const double Linfty_error ='
p39406
aS'      VectorTools::compute_global_error(triangulation,'
p39407
aS'                                        difference_per_cell,'
p39408
aS'                                        VectorTools::Linfty_norm);'
p39409
aS'    const unsigned int n_active_cells = triangulation.n_active_cells();'
p39410
aS'    const unsigned int n_dofs         = dof_handler.n_dofs();'
p39411
aS'    std::cout << "Cycle " << cycle << \':\' << std::endl'
p39412
aS'              << "   Number of active cells:       " << n_active_cells'
p39413
aS'              << std::endl'
p39414
aS'              << "   Number of degrees of freedom: " << n_dofs << std::endl;'
p39415
aS'    convergence_table.add_value("cycle", cycle);'
p39416
aS'    convergence_table.add_value("cells", n_active_cells);'
p39417
aS'    convergence_table.add_value("dofs", n_dofs);'
p39418
aS'    convergence_table.add_value("L2", L2_error);'
p39419
aS'    convergence_table.add_value("H1", H1_error);'
p39420
aS'    convergence_table.add_value("Linfty", Linfty_error);'
p39421
aS'  }'
p39422
aS'  template <int dim>'
p39423
aS'  void HelmholtzProblem<dim>::run()'
p39424
aS'  {'
p39425
aS'    const unsigned int n_cycles ='
p39426
aS'    for (unsigned int cycle = 0; cycle < n_cycles; ++cycle)'
p39427
aS'      {'
p39428
aS'        if (cycle == 0)'
p39429
aS'          {'
p39430
aS'            GridGenerator::hyper_cube(triangulation, -1., 1.);'
p39431
aS'            triangulation.refine_global(3);'
p39432
aS'            for (const auto &cell : triangulation.cell_iterators())'
p39433
aS'              for (const auto &face : cell->face_iterators())'
p39434
aS'                {'
p39435
aS'                  const auto center = face->center();'
p39436
aS'                  if ((std::fabs(center(0) - (-1.0)) < 1e-12) ||'
p39437
aS'                    face->set_boundary_id(1);'
p39438
aS'                }'
p39439
aS'          }'
p39440
aS'        else'
p39441
aS'          refine_grid();'
p39442
aS'        setup_system();'
p39443
aS'        assemble_system();'
p39444
aS'        solve();'
p39445
aS'        process_solution(cycle);'
p39446
aS'      }'
p39447
aS'    std::string vtk_filename;'
p39448
aS'    switch (refinement_mode)'
p39449
aS'      {'
p39450
aS'        case global_refinement:'
p39451
aS'          vtk_filename = "solution-global";'
p39452
aS'          break;'
p39453
aS'        case adaptive_refinement:'
p39454
aS'          vtk_filename = "solution-adaptive";'
p39455
aS'          break;'
p39456
aS'        default:'
p39457
aS'          Assert(false, ExcNotImplemented());'
p39458
aS'      }'
p39459
aS'    switch (fe->degree)'
p39460
aS'      {'
p39461
aS'        case 1:'
p39462
aS'          vtk_filename += "-q1";'
p39463
aS'          break;'
p39464
aS'        case 2:'
p39465
aS'          vtk_filename += "-q2";'
p39466
aS'          break;'
p39467
aS'        default:'
p39468
aS'          Assert(false, ExcNotImplemented());'
p39469
aS'      }'
p39470
aS'    vtk_filename += ".vtk";'
p39471
aS'    std::ofstream output(vtk_filename);'
p39472
aS'    DataOut<dim> data_out;'
p39473
aS'    data_out.attach_dof_handler(dof_handler);'
p39474
aS'    data_out.add_data_vector(solution, "solution");'
p39475
aS'    data_out.build_patches(fe->degree);'
p39476
aS'    data_out.write_vtk(output);'
p39477
aS'    convergence_table.set_precision("L2", 3);'
p39478
aS'    convergence_table.set_precision("H1", 3);'
p39479
aS'    convergence_table.set_precision("Linfty", 3);'
p39480
aS'    convergence_table.set_scientific("L2", true);'
p39481
aS'    convergence_table.set_scientific("H1", true);'
p39482
aS'    convergence_table.set_scientific("Linfty", true);'
p39483
aS'    convergence_table.set_tex_caption("cells", "\\\\# cells");'
p39484
aS'    convergence_table.set_tex_caption("dofs", "\\\\# dofs");'
p39485
aS'    convergence_table.set_tex_caption("L2", "$L^2$-error");'
p39486
aS'    convergence_table.set_tex_caption("H1", "$H^1$-error");'
p39487
aS'    convergence_table.set_tex_caption("Linfty", "$L^\\\\infty$-error");'
p39488
aS'    convergence_table.set_tex_format("cells", "r");'
p39489
aS'    convergence_table.set_tex_format("dofs", "r");'
p39490
aS'    std::cout << std::endl;'
p39491
aS'    convergence_table.write_text(std::cout);'
p39492
aS'    std::string error_filename = "error";'
p39493
aS'    switch (refinement_mode)'
p39494
aS'      {'
p39495
aS'        case global_refinement:'
p39496
aS'          error_filename += "-global";'
p39497
aS'          break;'
p39498
aS'        case adaptive_refinement:'
p39499
aS'          error_filename += "-adaptive";'
p39500
aS'          break;'
p39501
aS'        default:'
p39502
aS'          Assert(false, ExcNotImplemented());'
p39503
aS'      }'
p39504
aS'    switch (fe->degree)'
p39505
aS'      {'
p39506
aS'        case 1:'
p39507
aS'          error_filename += "-q1";'
p39508
aS'          break;'
p39509
aS'        case 2:'
p39510
aS'          error_filename += "-q2";'
p39511
aS'          break;'
p39512
aS'        default:'
p39513
aS'          Assert(false, ExcNotImplemented());'
p39514
aS'      }'
p39515
aS'    error_filename += ".tex";'
p39516
aS'    std::ofstream error_table_file(error_filename);'
p39517
aS'    convergence_table.write_tex(error_table_file);'
p39518
aS'    if (refinement_mode == global_refinement)'
p39519
aS'      {'
p39520
aS'        convergence_table.add_column_to_supercolumn("cycle", "n cells");'
p39521
aS'        convergence_table.add_column_to_supercolumn("cells", "n cells");'
p39522
aS'        std::vector<std::string> new_order;'
p39523
aS'        new_order.emplace_back("n cells");'
p39524
aS'        new_order.emplace_back("H1");'
p39525
aS'        new_order.emplace_back("L2");'
p39526
aS'        convergence_table.set_column_order(new_order);'
p39527
aS'        convergence_table.evaluate_convergence_rates('
p39528
aS'          "L2", ConvergenceTable::reduction_rate);'
p39529
aS'        convergence_table.evaluate_convergence_rates('
p39530
aS'          "L2", ConvergenceTable::reduction_rate_log2);'
p39531
aS'        convergence_table.evaluate_convergence_rates('
p39532
aS'          "H1", ConvergenceTable::reduction_rate);'
p39533
aS'        convergence_table.evaluate_convergence_rates('
p39534
aS'          "H1", ConvergenceTable::reduction_rate_log2);'
p39535
aS'        std::cout << std::endl;'
p39536
aS'        convergence_table.write_text(std::cout);'
p39537
aS'        std::string conv_filename = "convergence";'
p39538
aS'        switch (refinement_mode)'
p39539
aS'          {'
p39540
aS'            case global_refinement:'
p39541
aS'              conv_filename += "-global";'
p39542
aS'              break;'
p39543
aS'            case adaptive_refinement:'
p39544
aS'              conv_filename += "-adaptive";'
p39545
aS'              break;'
p39546
aS'            default:'
p39547
aS'              Assert(false, ExcNotImplemented());'
p39548
aS'          }'
p39549
aS'        switch (fe->degree)'
p39550
aS'          {'
p39551
aS'            case 1:'
p39552
aS'              conv_filename += "-q1";'
p39553
aS'              break;'
p39554
aS'            case 2:'
p39555
aS'              conv_filename += "-q2";'
p39556
aS'              break;'
p39557
aS'            default:'
p39558
aS'              Assert(false, ExcNotImplemented());'
p39559
aS'          }'
p39560
aS'        conv_filename += ".tex";'
p39561
aS'        std::ofstream table_file(conv_filename);'
p39562
aS'        convergence_table.write_tex(table_file);'
p39563
aS'      }'
p39564
aS'  }'
p39565
aS'} // namespace Step7'
p39566
aS'int main()'
p39567
ag9
aS'  const unsigned int dim = 2;'
p39568
aS'  try'
p39569
aS'    {'
p39570
aS'      using namespace dealii;'
p39571
aS'      using namespace Step7;'
p39572
aS'      {'
p39573
aS'        std::cout << "Solving with Q1 elements, adaptive refinement"'
p39574
aS'                  << std::endl'
p39575
aS'                  << "============================================="'
p39576
aS'                  << std::endl'
p39577
aS'                  << std::endl;'
p39578
aS'        FE_Q<dim>             fe(1);'
p39579
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p39580
aS'          fe, HelmholtzProblem<dim>::adaptive_refinement);'
p39581
aS'        helmholtz_problem_2d.run();'
p39582
aS'        std::cout << std::endl;'
p39583
aS'      }'
p39584
aS'      {'
p39585
aS'        std::cout << "Solving with Q1 elements, global refinement" << std::endl'
p39586
aS'                  << "===========================================" << std::endl'
p39587
aS'                  << std::endl;'
p39588
aS'        FE_Q<dim>             fe(1);'
p39589
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p39590
aS'          fe, HelmholtzProblem<dim>::global_refinement);'
p39591
aS'        helmholtz_problem_2d.run();'
p39592
aS'        std::cout << std::endl;'
p39593
aS'      }'
p39594
aS'      {'
p39595
aS'        std::cout << "Solving with Q2 elements, global refinement" << std::endl'
p39596
aS'                  << "===========================================" << std::endl'
p39597
aS'                  << std::endl;'
p39598
aS'        FE_Q<dim>             fe(2);'
p39599
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p39600
aS'          fe, HelmholtzProblem<dim>::global_refinement);'
p39601
aS'        helmholtz_problem_2d.run();'
p39602
aS'        std::cout << std::endl;'
p39603
aS'      }'
p39604
aS'      {'
p39605
aS'        std::cout << "Solving with Q2 elements, adaptive refinement"'
p39606
aS'                  << std::endl'
p39607
aS'                  << "===========================================" << std::endl'
p39608
aS'                  << std::endl;'
p39609
aS'        FE_Q<dim>             fe(2);'
p39610
aS'        HelmholtzProblem<dim> helmholtz_problem_2d('
p39611
aS'          fe, HelmholtzProblem<dim>::adaptive_refinement);'
p39612
aS'        helmholtz_problem_2d.run();'
p39613
aS'        std::cout << std::endl;'
p39614
aS'      }'
p39615
aS'    }'
p39616
aS'  catch (std::exception &exc)'
p39617
aS'    {'
p39618
aS'      std::cerr << std::endl'
p39619
aS'                << std::endl'
p39620
aS'                << "----------------------------------------------------"'
p39621
aS'                << std::endl;'
p39622
aS'      std::cerr << "Exception on processing: " << std::endl'
p39623
aS'                << exc.what() << std::endl'
p39624
aS'                << "Aborting!" << std::endl'
p39625
aS'                << "----------------------------------------------------"'
p39626
aS'                << std::endl;'
p39627
aS'      return 1;'
p39628
aS'    }'
p39629
aS'  catch (...)'
p39630
aS'    {'
p39631
aS'      std::cerr << std::endl'
p39632
aS'                << std::endl'
p39633
aS'                << "----------------------------------------------------"'
p39634
aS'                << std::endl;'
p39635
aS'      std::cerr << "Unknown exception!" << std::endl'
p39636
aS'                << "Aborting!" << std::endl'
p39637
aS'                << "----------------------------------------------------"'
p39638
aS'                << std::endl;'
p39639
aS'      return 1;'
p39640
aS'    }'
p39641
aS'  return 0;'
p39642
ag17
aS'#include <deal.II/base/function.h>'
p39643
aS'#include <deal.II/base/quadrature_lib.h>'
p39644
aS'#include <deal.II/base/timer.h>'
p39645
aS'#include <deal.II/lac/block_linear_operator.h>'
p39646
aS'#include <deal.II/lac/generic_linear_algebra.h>'
p39647
aS'#include <deal.II/lac/linear_operator.h>'
p39648
aS'#include <deal.II/lac/linear_operator_tools.h>'
p39649
aS'#define FORCE_USE_OF_TRILINOS'
p39650
aS'namespace LA'
p39651
ag9
aS'#if defined(DEAL_II_WITH_PETSC) && !defined(DEAL_II_PETSC_WITH_COMPLEX) && \\'
p39652
aS'  !(defined(DEAL_II_WITH_TRILINOS) && defined(FORCE_USE_OF_TRILINOS))'
p39653
aS'  using namespace dealii::LinearAlgebraPETSc;'
p39654
aS'#  define USE_PETSC_LA'
p39655
aS'#elif defined(DEAL_II_WITH_TRILINOS)'
p39656
aS'  using namespace dealii::LinearAlgebraTrilinos;'
p39657
aS'#else'
p39658
aS'#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required'
p39659
aS'#endif'
p39660
aS'} // namespace LA'
p39661
aS'#include <deal.II/base/conditional_ostream.h>'
p39662
aS'#include <deal.II/base/index_set.h>'
p39663
aS'#include <deal.II/base/parameter_acceptor.h>'
p39664
aS'#include <deal.II/base/parsed_function.h>'
p39665
aS'#include <deal.II/base/utilities.h>'
p39666
aS'#include <deal.II/distributed/grid_refinement.h>'
p39667
aS'#include <deal.II/distributed/solution_transfer.h>'
p39668
aS'#include <deal.II/distributed/tria.h>'
p39669
aS'#include <deal.II/dofs/dof_handler.h>'
p39670
aS'#include <deal.II/dofs/dof_renumbering.h>'
p39671
aS'#include <deal.II/dofs/dof_tools.h>'
p39672
aS'#include <deal.II/fe/fe_nothing.h>'
p39673
aS'#include <deal.II/fe/fe_q.h>'
p39674
aS'#include <deal.II/fe/fe_system.h>'
p39675
aS'#include <deal.II/fe/fe_values.h>'
p39676
aS'#include <deal.II/fe/mapping_fe_field.h>'
p39677
aS'#include <deal.II/fe/mapping_q.h>'
p39678
aS'#include <deal.II/grid/grid_generator.h>'
p39679
aS'#include <deal.II/grid/grid_in.h>'
p39680
aS'#include <deal.II/grid/grid_tools.h>'
p39681
aS'#include <deal.II/grid/manifold_lib.h>'
p39682
aS'#include <deal.II/lac/affine_constraints.h>'
p39683
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p39684
aS'#include <deal.II/lac/full_matrix.h>'
p39685
aS'#include <deal.II/lac/petsc_precondition.h>'
p39686
aS'#include <deal.II/lac/petsc_solver.h>'
p39687
aS'#include <deal.II/lac/petsc_sparse_matrix.h>'
p39688
aS'#include <deal.II/lac/petsc_vector.h>'
p39689
aS'#include <deal.II/lac/solver_cg.h>'
p39690
aS'#include <deal.II/lac/solver_gmres.h>'
p39691
aS'#include <deal.II/lac/solver_minres.h>'
p39692
aS'#include <deal.II/lac/sparsity_tools.h>'
p39693
aS'#include <deal.II/lac/vector.h>'
p39694
aS'#include <deal.II/numerics/data_out.h>'
p39695
aS'#include <deal.II/numerics/error_estimator.h>'
p39696
aS'#include <deal.II/numerics/vector_tools.h>'
p39697
aS'#include <deal.II/particles/data_out.h>'
p39698
aS'#include <deal.II/particles/generators.h>'
p39699
aS'#include <deal.II/particles/particle_handler.h>'
p39700
aS'#include <deal.II/particles/utilities.h>'
p39701
aS'#include <deal.II/opencascade/manifold_lib.h>'
p39702
aS'#include <deal.II/opencascade/utilities.h>'
p39703
aS'#ifdef DEAL_II_WITH_OPENCASCADE'
p39704
aS'#  include <TopoDS.hxx>'
p39705
aS'#endif'
p39706
aS'#include <cmath>'
p39707
aS'#include <fstream>'
p39708
aS'#include <iostream>'
p39709
aS'#include <memory>'
p39710
aS'namespace Step70'
p39711
ag9
aS'  using namespace dealii;'
p39712
aS'  template <int dim, int spacedim = dim>'
p39713
aS'  class StokesImmersedProblemParameters : public ParameterAcceptor'
p39714
aS'  {'
p39715
aS'  public:'
p39716
aS'    StokesImmersedProblemParameters();'
p39717
aS'    void set_time(const double &time) const'
p39718
aS'    {'
p39719
aS'      rhs.set_time(time);'
p39720
aS'      angular_velocity.set_time(time);'
p39721
aS'    }'
p39722
aS'    std::string output_directory = ".";'
p39723
aS'    unsigned int velocity_degree = 2;'
p39724
aS'    unsigned int number_of_time_steps = 501;'
p39725
aS'    double       final_time           = 1.0;'
p39726
aS'    unsigned int output_frequency = 1;'
p39727
aS'    unsigned int initial_fluid_refinement      = 5;'
p39728
aS'    unsigned int initial_solid_refinement      = 5;'
p39729
aS'    unsigned int particle_insertion_refinement = 3;'
p39730
aS'    unsigned int fluid_rtree_extraction_level = 1;'
p39731
aS'    double viscosity    = 1.0;'
p39732
aS'    double penalty_term = 100;'
p39733
aS'    std::list<types::boundary_id> homogeneous_dirichlet_ids{0};'
p39734
aS'    std::string name_of_fluid_grid       = "hyper_cube";'
p39735
aS'    std::string arguments_for_fluid_grid = "-1: 1: false";'
p39736
aS'    std::string name_of_solid_grid       = "hyper_rectangle";'
p39737
aS'    std::string arguments_for_solid_grid = spacedim == 2 ?'
p39738
aS'                                             "-.5, -.1: .5, .1: false" :'
p39739
aS'                                             "-.5, -.1, -.1: .5, .1, .1: false";'
p39740
aS'    std::string name_of_particle_grid = "hyper_ball";'
p39741
aS'    std::string arguments_for_particle_grid ='
p39742
aS'      spacedim == 2 ? "0.3, 0.3: 0.1: false" : "0.3, 0.3, 0.3 : 0.1: false";'
p39743
aS'    int          max_level_refinement = 8;'
p39744
aS'    int          min_level_refinement = 5;'
p39745
aS'    std::string  refinement_strategy  = "fixed_fraction";'
p39746
aS'    double       coarsening_fraction  = 0.3;'
p39747
aS'    double       refinement_fraction  = 0.3;'
p39748
aS'    unsigned int max_cells            = 20000;'
p39749
aS'    int          refinement_frequency = 5;'
p39750
aS'    mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>> rhs;'
p39751
aS'    mutable ParameterAcceptorProxy<Functions::ParsedFunction<spacedim>>'
p39752
aS'      angular_velocity;'
p39753
aS'  };'
p39754
aS'  template <int dim, int spacedim>'
p39755
aS'  StokesImmersedProblemParameters<dim,'
p39756
aS'                                  spacedim>::StokesImmersedProblemParameters()'
p39757
aS'    : ParameterAcceptor("Stokes Immersed Problem/")'
p39758
aS'    , rhs("Right hand side", spacedim + 1)'
p39759
aS'    , angular_velocity("Angular velocity")'
p39760
aS'  {'
p39761
aS'    add_parameter('
p39762
aS'      "Velocity degree", velocity_degree, "", this->prm, Patterns::Integer(1));'
p39763
aS'    add_parameter("Number of time steps", number_of_time_steps);'
p39764
aS'    add_parameter("Output frequency", output_frequency);'
p39765
aS'    add_parameter("Output directory", output_directory);'
p39766
aS'    add_parameter("Final time", final_time);'
p39767
aS'    add_parameter("Viscosity", viscosity);'
p39768
aS'    add_parameter("Nitsche penalty term", penalty_term);'
p39769
aS'    add_parameter("Initial fluid refinement",'
p39770
aS'                  initial_fluid_refinement,'
p39771
aS'                  "Initial mesh refinement used for the fluid domain Omega");'
p39772
aS'    add_parameter("Initial solid refinement",'
p39773
aS'                  initial_solid_refinement,'
p39774
aS'                  "Initial mesh refinement used for the solid domain Gamma");'
p39775
aS'    add_parameter("Fluid bounding boxes extraction level",'
p39776
aS'                  fluid_rtree_extraction_level,'
p39777
aS'                  "Extraction level of the rtree used to construct global "'
p39778
aS'                  "bounding boxes");'
p39779
aS'    add_parameter('
p39780
aS'      "Particle insertion refinement",'
p39781
aS'      particle_insertion_refinement,'
p39782
aS'      "Refinement of the volumetric mesh used to insert the particles");'
p39783
aS'    add_parameter('
p39784
aS'      "Homogeneous Dirichlet boundary ids",'
p39785
aS'      homogeneous_dirichlet_ids,'
p39786
aS'      "Boundary Ids over which homogeneous Dirichlet boundary conditions are applied");'
p39787
aS'    enter_subsection("Grid generation");'
p39788
aS'    {'
p39789
aS'      add_parameter("Fluid grid generator", name_of_fluid_grid);'
p39790
aS'      add_parameter("Fluid grid generator arguments", arguments_for_fluid_grid);'
p39791
aS'      add_parameter("Solid grid generator", name_of_solid_grid);'
p39792
aS'      add_parameter("Solid grid generator arguments", arguments_for_solid_grid);'
p39793
aS'      add_parameter("Particle grid generator", name_of_particle_grid);'
p39794
aS'      add_parameter("Particle grid generator arguments",'
p39795
aS'                    arguments_for_particle_grid);'
p39796
aS'    }'
p39797
aS'    leave_subsection();'
p39798
aS'    enter_subsection("Refinement and remeshing");'
p39799
aS'    {'
p39800
aS'      add_parameter("Refinement step frequency", refinement_frequency);'
p39801
aS'      add_parameter("Refinement maximal level", max_level_refinement);'
p39802
aS'      add_parameter("Refinement minimal level", min_level_refinement);'
p39803
aS'      add_parameter("Refinement strategy",'
p39804
aS'                    refinement_strategy,'
p39805
aS'                    "",'
p39806
aS'                    this->prm,'
p39807
aS'                    Patterns::Selection("fixed_fraction|fixed_number"));'
p39808
aS'      add_parameter("Refinement coarsening fraction", coarsening_fraction);'
p39809
aS'      add_parameter("Refinement fraction", refinement_fraction);'
p39810
aS'      add_parameter("Maximum number of cells", max_cells);'
p39811
aS'    }'
p39812
aS'    leave_subsection();'
p39813
aS'    rhs.declare_parameters_call_back.connect([&]() {'
p39814
aS'      Functions::ParsedFunction<spacedim>::declare_parameters(this->prm,'
p39815
aS'                                                              spacedim + 1);'
p39816
aS'    });'
p39817
aS'    angular_velocity.declare_parameters_call_back.connect([&]() {'
p39818
aS'      this->prm.set("Function expression",'
p39819
aS'                    "t < .500001 ? 6.283185 : -6.283185");'
p39820
aS'    });'
p39821
aS'  }'
p39822
aS'  template <int spacedim>'
p39823
aS'  class SolidVelocity : public Function<spacedim>'
p39824
aS'  {'
p39825
aS'  public:'
p39826
aS'    static_assert(spacedim > 1,'
p39827
aS'                  "Cannot instantiate SolidVelocity for spacedim == 1");'
p39828
aS'    SolidVelocity(const Functions::ParsedFunction<spacedim> &angular_velocity)'
p39829
aS'      : angular_velocity(angular_velocity)'
p39830
aS'    {}'
p39831
aS'    virtual double value(const Point<spacedim> &p,'
p39832
aS'                         unsigned int           component = 0) const override'
p39833
aS'    {'
p39834
aS'      Tensor<1, spacedim> velocity;'
p39835
aS'      const double omega = angular_velocity.value(p);'
p39836
aS'      velocity[0]        = -omega * p[1];'
p39837
aS'      velocity[1]        = omega * p[0];'
p39838
aS'      return velocity[component];'
p39839
aS'    }'
p39840
aS'  private:'
p39841
aS'    const Functions::ParsedFunction<spacedim> &angular_velocity;'
p39842
aS'  };'
p39843
aS'  template <int spacedim>'
p39844
aS'  class SolidPosition : public Function<spacedim>'
p39845
aS'  {'
p39846
aS'  public:'
p39847
aS'    static_assert(spacedim > 1,'
p39848
aS'                  "Cannot instantiate SolidPosition for spacedim == 1");'
p39849
aS'    SolidPosition(const Functions::ParsedFunction<spacedim> &angular_velocity,'
p39850
aS'                  const double                               time_step)'
p39851
aS'      : Function<spacedim>(spacedim)'
p39852
aS'      , angular_velocity(angular_velocity)'
p39853
aS'      , time_step(time_step)'
p39854
aS'    {}'
p39855
aS'    virtual double value(const Point<spacedim> &p,'
p39856
aS'                         unsigned int           component = 0) const override'
p39857
aS'    {'
p39858
aS'      Point<spacedim> new_position = p;'
p39859
aS'      double dtheta = angular_velocity.value(p) * time_step;'
p39860
aS'      new_position[0] = std::cos(dtheta) * p[0] - std::sin(dtheta) * p[1];'
p39861
aS'      new_position[1] = std::sin(dtheta) * p[0] + std::cos(dtheta) * p[1];'
p39862
aS'      return new_position[component];'
p39863
aS'    }'
p39864
aS'    void set_time_step(const double new_time_step)'
p39865
aS'    {'
p39866
aS'      time_step = new_time_step;'
p39867
aS'    }'
p39868
aS'  private:'
p39869
aS'    const Functions::ParsedFunction<spacedim> &angular_velocity;'
p39870
aS'    double                                     time_step;'
p39871
aS'  };'
p39872
aS'  template <int dim, int spacedim = dim>'
p39873
aS'  class StokesImmersedProblem'
p39874
aS'  {'
p39875
aS'  public:'
p39876
aS'    StokesImmersedProblem('
p39877
aS'      const StokesImmersedProblemParameters<dim, spacedim> &par);'
p39878
aS'    void run();'
p39879
aS'  private:'
p39880
aS'    void make_grid();'
p39881
aS'    double compute_time_step() const;'
p39882
aS'    void setup_tracer_particles();'
p39883
aS'    void setup_solid_particles();'
p39884
aS'    void initial_setup();'
p39885
aS'    void setup_dofs();'
p39886
aS'    void assemble_stokes_system();'
p39887
aS'    void assemble_nitsche_restriction();'
p39888
aS'    void solve();'
p39889
aS'    void refine_and_transfer();'
p39890
aS'    void output_results(const unsigned int cycle, const double time) const;'
p39891
aS'    void output_particles(const Particles::ParticleHandler<spacedim> &particles,'
p39892
aS'                          std::string                                 fprefix,'
p39893
aS'                          const unsigned int                          iter,'
p39894
aS'                          const double time) const;'
p39895
aS'    const StokesImmersedProblemParameters<dim, spacedim> &par;'
p39896
aS'    MPI_Comm mpi_communicator;'
p39897
aS'    ConditionalOStream pcout;'
p39898
aS'    mutable TimerOutput computing_timer;'
p39899
aS'    parallel::distributed::Triangulation<spacedim>      fluid_tria;'
p39900
aS'    parallel::distributed::Triangulation<dim, spacedim> solid_tria;'
p39901
aS'    std::unique_ptr<FiniteElement<spacedim>>      fluid_fe;'
p39902
aS'    std::unique_ptr<FiniteElement<dim, spacedim>> solid_fe;'
p39903
aS'    std::unique_ptr<Quadrature<spacedim>> fluid_quadrature_formula;'
p39904
aS'    std::unique_ptr<Quadrature<dim>>      solid_quadrature_formula;'
p39905
aS'    DoFHandler<spacedim>      fluid_dh;'
p39906
aS'    DoFHandler<dim, spacedim> solid_dh;'
p39907
aS'    std::unique_ptr<MappingFEField<dim, spacedim>> solid_mapping;'
p39908
aS'    std::vector<IndexSet> fluid_owned_dofs;'
p39909
aS'    std::vector<IndexSet> solid_owned_dofs;'
p39910
aS'    std::vector<IndexSet> fluid_relevant_dofs;'
p39911
aS'    std::vector<IndexSet> solid_relevant_dofs;'
p39912
aS'    AffineConstraints<double> constraints;'
p39913
aS'    LA::MPI::BlockSparseMatrix system_matrix;'
p39914
aS'    LA::MPI::BlockSparseMatrix preconditioner_matrix;'
p39915
aS'    LA::MPI::BlockVector solution;'
p39916
aS'    LA::MPI::BlockVector locally_relevant_solution;'
p39917
aS'    LA::MPI::BlockVector system_rhs;'
p39918
aS'    Particles::ParticleHandler<spacedim> tracer_particle_handler;'
p39919
aS'    Particles::ParticleHandler<spacedim> solid_particle_handler;'
p39920
aS'    IndexSet locally_owned_tracer_particle_coordinates;'
p39921
aS'    IndexSet locally_relevant_tracer_particle_coordinates;'
p39922
aS'    LA::MPI::Vector tracer_particle_velocities;'
p39923
aS'    LA::MPI::Vector relevant_tracer_particle_displacements;'
p39924
aS'    std::vector<std::vector<BoundingBox<spacedim>>> global_fluid_bounding_boxes;'
p39925
aS'  };'
p39926
aS'  template <int dim, int spacedim>'
p39927
aS'  StokesImmersedProblem<dim, spacedim>::StokesImmersedProblem('
p39928
aS'    const StokesImmersedProblemParameters<dim, spacedim> &par)'
p39929
aS'    : par(par)'
p39930
aS'    , mpi_communicator(MPI_COMM_WORLD)'
p39931
aS'    , pcout(std::cout,'
p39932
aS'    , computing_timer(mpi_communicator,'
p39933
aS'                      pcout,'
p39934
aS'                      TimerOutput::summary,'
p39935
aS'                      TimerOutput::wall_times)'
p39936
aS'    , fluid_tria(mpi_communicator,'
p39937
aS'                 typename Triangulation<spacedim>::MeshSmoothing('
p39938
aS'                   Triangulation<spacedim>::smoothing_on_refinement |'
p39939
aS'                   Triangulation<spacedim>::smoothing_on_coarsening))'
p39940
aS'    , solid_tria(mpi_communicator,'
p39941
aS'                 typename Triangulation<dim, spacedim>::MeshSmoothing('
p39942
aS'                   Triangulation<dim, spacedim>::smoothing_on_refinement |'
p39943
aS'                   Triangulation<dim, spacedim>::smoothing_on_coarsening))'
p39944
aS'    , fluid_dh(fluid_tria)'
p39945
aS'    , solid_dh(solid_tria)'
p39946
aS'  {}'
p39947
aS'  template <int dim, int spacedim>'
p39948
aS'  void read_grid_and_cad_files(const std::string &grid_file_name,'
p39949
aS'                               const std::string &ids_and_cad_file_names,'
p39950
aS'                               Triangulation<dim, spacedim> &tria)'
p39951
aS'  {'
p39952
aS'    GridIn<dim, spacedim> grid_in;'
p39953
aS'    grid_in.attach_triangulation(tria);'
p39954
aS'    grid_in.read(grid_file_name);'
p39955
aS'#ifdef DEAL_II_WITH_OPENCASCADE'
p39956
aS'    using map_type  = std::map<types::manifold_id, std::string>;'
p39957
aS'    using Converter = Patterns::Tools::Convert<map_type>;'
p39958
aS'    for (const auto &pair : Converter::to_value(ids_and_cad_file_names))'
p39959
aS'      {'
p39960
aS'        const auto &manifold_id   = pair.first;'
p39961
aS'        const auto &cad_file_name = pair.second;'
p39962
aS'        const auto extension = boost::algorithm::to_lower_copy('
p39963
aS"          cad_file_name.substr(cad_file_name.find_last_of('.') + 1));"
p39964
aS'        TopoDS_Shape shape;'
p39965
aS'        if (extension == "iges" || extension == "igs")'
p39966
aS'          shape = OpenCASCADE::read_IGES(cad_file_name);'
p39967
aS'        else if (extension == "step" || extension == "stp")'
p39968
aS'          shape = OpenCASCADE::read_STEP(cad_file_name);'
p39969
aS'        else'
p39970
aS'          AssertThrow(false,'
p39971
aS'                      ExcNotImplemented("We found an extension that we "'
p39972
aS'                                        "do not recognize as a CAD file "'
p39973
aS'                                        "extension. Bailing out."));'
p39974
aS'        const auto n_elements = OpenCASCADE::count_elements(shape);'
p39975
aS'        if ((std::get<0>(n_elements) == 0))'
p39976
aS'          tria.set_manifold('
p39977
aS'            manifold_id,'
p39978
aS'            OpenCASCADE::ArclengthProjectionLineManifold<dim, spacedim>(shape));'
p39979
aS'        else if (spacedim == 3)'
p39980
aS'          {'
p39981
aS'            const auto t = reinterpret_cast<Triangulation<dim, 3> *>(&tria);'
p39982
aS'            t->set_manifold(manifold_id,'
p39983
aS'                            OpenCASCADE::NormalToMeshProjectionManifold<dim, 3>('
p39984
aS'                              shape));'
p39985
aS'          }'
p39986
aS'        else'
p39987
aS'          tria.set_manifold(manifold_id,'
p39988
aS'                            OpenCASCADE::NURBSPatchManifold<dim, spacedim>('
p39989
aS'                              TopoDS::Face(shape)));'
p39990
aS'      }'
p39991
aS'#else'
p39992
aS'    AssertThrow(false, ExcNotImplemented("Generation of the grid failed."));'
p39993
aS'#endif'
p39994
aS'  }'
p39995
aS'  template <int dim, int spacedim>'
p39996
aS'  void StokesImmersedProblem<dim, spacedim>::make_grid()'
p39997
aS'  {'
p39998
aS'    try'
p39999
aS'      {'
p40000
aS'        GridGenerator::generate_from_name_and_arguments('
p40001
aS'          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);'
p40002
aS'      }'
p40003
aS'    catch (...)'
p40004
aS'      {'
p40005
aS'        pcout << "Generating from name and argument failed." << std::endl'
p40006
aS'              << "Trying to read from file name." << std::endl;'
p40007
aS'        read_grid_and_cad_files(par.name_of_fluid_grid,'
p40008
aS'                                par.arguments_for_fluid_grid,'
p40009
aS'                                fluid_tria);'
p40010
aS'      }'
p40011
aS'    fluid_tria.refine_global(par.initial_fluid_refinement);'
p40012
aS'    try'
p40013
aS'      {'
p40014
aS'        GridGenerator::generate_from_name_and_arguments('
p40015
aS'          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);'
p40016
aS'      }'
p40017
aS'    catch (...)'
p40018
aS'      {'
p40019
aS'        read_grid_and_cad_files(par.name_of_solid_grid,'
p40020
aS'                                par.arguments_for_solid_grid,'
p40021
aS'                                solid_tria);'
p40022
aS'      }'
p40023
aS'    solid_tria.refine_global(par.initial_solid_refinement);'
p40024
aS'  }'
p40025
aS'  template <int dim, int spacedim>'
p40026
aS'  void StokesImmersedProblem<dim, spacedim>::setup_tracer_particles()'
p40027
aS'  {'
p40028
aS'    parallel::distributed::Triangulation<spacedim> particle_insert_tria('
p40029
aS'      mpi_communicator);'
p40030
aS'    GridGenerator::generate_from_name_and_arguments('
p40031
aS'      particle_insert_tria,'
p40032
aS'      par.name_of_particle_grid,'
p40033
aS'      par.arguments_for_particle_grid);'
p40034
aS'    particle_insert_tria.refine_global(par.particle_insertion_refinement);'
p40035
aS'    FE_Q<spacedim>       particles_fe(1);'
p40036
aS'    DoFHandler<spacedim> particles_dof_handler(particle_insert_tria);'
p40037
aS'    particles_dof_handler.distribute_dofs(particles_fe);'
p40038
aS'    std::vector<BoundingBox<spacedim>> all_boxes;'
p40039
aS'    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());'
p40040
aS'    for (const auto &cell : fluid_tria.active_cell_iterators())'
p40041
aS'      if (cell->is_locally_owned())'
p40042
aS'        all_boxes.emplace_back(cell->bounding_box());'
p40043
aS'    const auto tree = pack_rtree(all_boxes);'
p40044
aS'    const auto local_boxes ='
p40045
aS'      extract_rtree_level(tree, par.fluid_rtree_extraction_level);'
p40046
aS'    global_fluid_bounding_boxes ='
p40047
aS'      Utilities::MPI::all_gather(mpi_communicator, local_boxes);'
p40048
aS'    tracer_particle_handler.initialize(fluid_tria,'
p40049
aS'                                       StaticMappingQ1<spacedim>::mapping);'
p40050
aS'    Particles::Generators::dof_support_points(particles_dof_handler,'
p40051
aS'                                              global_fluid_bounding_boxes,'
p40052
aS'                                              tracer_particle_handler);'
p40053
aS'    pcout << "Tracer particles: "'
p40054
aS'          << tracer_particle_handler.n_global_particles() << std::endl;'
p40055
aS'    locally_owned_tracer_particle_coordinates ='
p40056
aS'      tracer_particle_handler.locally_owned_particle_ids().tensor_product('
p40057
aS'        complete_index_set(spacedim));'
p40058
aS'    locally_relevant_tracer_particle_coordinates ='
p40059
aS'      locally_owned_tracer_particle_coordinates;'
p40060
aS'    fluid_tria.signals.pre_distributed_refinement.connect('
p40061
aS'      [&]() { tracer_particle_handler.register_store_callback_function(); });'
p40062
aS'    fluid_tria.signals.post_distributed_refinement.connect([&]() {'
p40063
aS'      tracer_particle_handler.register_load_callback_function(false);'
p40064
aS'    });'
p40065
aS'  }'
p40066
aS'  template <int dim, int spacedim>'
p40067
aS'  void StokesImmersedProblem<dim, spacedim>::setup_solid_particles()'
p40068
aS'  {'
p40069
aS'    QGauss<dim> quadrature(fluid_fe->degree + 1);'
p40070
aS'    const unsigned int n_properties = 1;'
p40071
aS'    solid_particle_handler.initialize(fluid_tria,'
p40072
aS'                                      StaticMappingQ1<spacedim>::mapping,'
p40073
aS'                                      n_properties);'
p40074
aS'    std::vector<Point<spacedim>> quadrature_points_vec;'
p40075
aS'    quadrature_points_vec.reserve(quadrature.size() *'
p40076
aS'                                  solid_tria.n_locally_owned_active_cells());'
p40077
aS'    std::vector<std::vector<double>> properties;'
p40078
aS'    properties.reserve(quadrature.size() *'
p40079
aS'                       solid_tria.n_locally_owned_active_cells());'
p40080
aS'    FEValues<dim, spacedim> fe_v(*solid_fe,'
p40081
aS'                                 quadrature,'
p40082
aS'                                 update_JxW_values | update_quadrature_points);'
p40083
aS'    for (const auto &cell : solid_dh.active_cell_iterators())'
p40084
aS'      if (cell->is_locally_owned())'
p40085
aS'        {'
p40086
aS'          fe_v.reinit(cell);'
p40087
aS'          const auto &points = fe_v.get_quadrature_points();'
p40088
aS'          const auto &JxW    = fe_v.get_JxW_values();'
p40089
aS'          for (unsigned int q = 0; q < points.size(); ++q)'
p40090
aS'            {'
p40091
aS'              quadrature_points_vec.emplace_back(points[q]);'
p40092
aS'              properties.emplace_back('
p40093
aS'                std::vector<double>(n_properties, JxW[q]));'
p40094
aS'            }'
p40095
aS'        }'
p40096
aS'    Assert(!global_fluid_bounding_boxes.empty(),'
p40097
aS'           ExcInternalError('
p40098
aS'             "I was expecting the "'
p40099
aS'             "global_fluid_bounding_boxes to be filled at this stage. "'
p40100
aS'             "Make sure you fill this vector before trying to use it "'
p40101
aS'             "here. Bailing out."));'
p40102
aS'    solid_particle_handler.insert_global_particles(quadrature_points_vec,'
p40103
aS'                                                   global_fluid_bounding_boxes,'
p40104
aS'                                                   properties);'
p40105
aS'    fluid_tria.signals.pre_distributed_refinement.connect('
p40106
aS'      [&]() { solid_particle_handler.register_store_callback_function(); });'
p40107
aS'    fluid_tria.signals.post_distributed_refinement.connect('
p40108
aS'      [&]() { solid_particle_handler.register_load_callback_function(false); });'
p40109
aS'    pcout << "Solid particles: " << solid_particle_handler.n_global_particles()'
p40110
aS'          << std::endl;'
p40111
aS'  }'
p40112
aS'  template <int dim, int spacedim>'
p40113
aS'  void StokesImmersedProblem<dim, spacedim>::initial_setup()'
p40114
aS'  {'
p40115
aS'    TimerOutput::Scope t(computing_timer, "Initial setup");'
p40116
aS'    fluid_fe ='
p40117
aS'      std::make_unique<FESystem<spacedim>>(FE_Q<spacedim>(par.velocity_degree),'
p40118
aS'                                           spacedim,'
p40119
aS'                                           FE_Q<spacedim>(par.velocity_degree -'
p40120
aS'                                                          1),'
p40121
aS'                                           1);'
p40122
aS'    solid_fe = std::make_unique<FE_Nothing<dim, spacedim>>();'
p40123
aS'    solid_dh.distribute_dofs(*solid_fe);'
p40124
aS'    fluid_quadrature_formula ='
p40125
aS'      std::make_unique<QGauss<spacedim>>(par.velocity_degree + 1);'
p40126
aS'    solid_quadrature_formula ='
p40127
aS'      std::make_unique<QGauss<dim>>(par.velocity_degree + 1);'
p40128
aS'  }'
p40129
aS'  template <int dim, int spacedim>'
p40130
aS'  void StokesImmersedProblem<dim, spacedim>::setup_dofs()'
p40131
aS'  {'
p40132
aS'    TimerOutput::Scope t(computing_timer, "Setup dofs");'
p40133
aS'    fluid_dh.distribute_dofs(*fluid_fe);'
p40134
aS'    std::vector<unsigned int> stokes_sub_blocks(spacedim + 1, 0);'
p40135
aS'    stokes_sub_blocks[spacedim] = 1;'
p40136
aS'    DoFRenumbering::component_wise(fluid_dh, stokes_sub_blocks);'
p40137
aS'    auto dofs_per_block ='
p40138
aS'      DoFTools::count_dofs_per_fe_block(fluid_dh, stokes_sub_blocks);'
p40139
aS'    const unsigned int n_u = dofs_per_block[0], n_p = dofs_per_block[1];'
p40140
aS'    pcout << "   Number of degrees of freedom: " << fluid_dh.n_dofs() << " ("'
p40141
aS'          << n_u << \'+\' << n_p << " -- "'
p40142
aS"          << solid_particle_handler.n_global_particles() << '+'"
p40143
aS"          << tracer_particle_handler.n_global_particles() << ')' << std::endl;"
p40144
aS'    fluid_owned_dofs.resize(2);'
p40145
aS'    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);'
p40146
aS'    fluid_owned_dofs[1] ='
p40147
aS'      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);'
p40148
aS'    IndexSet locally_relevant_dofs;'
p40149
aS'    DoFTools::extract_locally_relevant_dofs(fluid_dh, locally_relevant_dofs);'
p40150
aS'    fluid_relevant_dofs.resize(2);'
p40151
aS'    fluid_relevant_dofs[0] = locally_relevant_dofs.get_view(0, n_u);'
p40152
aS'    fluid_relevant_dofs[1] = locally_relevant_dofs.get_view(n_u, n_u + n_p);'
p40153
aS'    {'
p40154
aS'      constraints.reinit(locally_relevant_dofs);'
p40155
aS'      FEValuesExtractors::Vector velocities(0);'
p40156
aS'      DoFTools::make_hanging_node_constraints(fluid_dh, constraints);'
p40157
aS'      VectorTools::interpolate_boundary_values('
p40158
aS'        fluid_dh,'
p40159
aS'        0,'
p40160
aS'        Functions::ZeroFunction<spacedim>(spacedim + 1),'
p40161
aS'        constraints,'
p40162
aS'        fluid_fe->component_mask(velocities));'
p40163
aS'      constraints.close();'
p40164
aS'    }'
p40165
aS'    auto locally_owned_dofs_per_processor ='
p40166
aS'      Utilities::MPI::all_gather(mpi_communicator,'
p40167
aS'                                 fluid_dh.locally_owned_dofs());'
p40168
aS'    {'
p40169
aS'      system_matrix.clear();'
p40170
aS'      Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);'
p40171
aS'      for (unsigned int c = 0; c < spacedim + 1; ++c)'
p40172
aS'        for (unsigned int d = 0; d < spacedim + 1; ++d)'
p40173
aS'          if (c == spacedim && d == spacedim)'
p40174
aS'            coupling[c][d] = DoFTools::none;'
p40175
aS'          else if (c == spacedim || d == spacedim || c == d)'
p40176
aS'            coupling[c][d] = DoFTools::always;'
p40177
aS'          else'
p40178
aS'            coupling[c][d] = DoFTools::none;'
p40179
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p40180
aS'      DoFTools::make_sparsity_pattern('
p40181
aS'        fluid_dh, coupling, dsp, constraints, false);'
p40182
aS'      SparsityTools::distribute_sparsity_pattern('
p40183
aS'        dsp,'
p40184
aS'        locally_owned_dofs_per_processor,'
p40185
aS'        mpi_communicator,'
p40186
aS'        locally_relevant_dofs);'
p40187
aS'      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);'
p40188
aS'    }'
p40189
aS'    {'
p40190
aS'      preconditioner_matrix.clear();'
p40191
aS'      Table<2, DoFTools::Coupling> coupling(spacedim + 1, spacedim + 1);'
p40192
aS'      for (unsigned int c = 0; c < spacedim + 1; ++c)'
p40193
aS'        for (unsigned int d = 0; d < spacedim + 1; ++d)'
p40194
aS'          if (c == spacedim && d == spacedim)'
p40195
aS'            coupling[c][d] = DoFTools::always;'
p40196
aS'          else'
p40197
aS'            coupling[c][d] = DoFTools::none;'
p40198
aS'      BlockDynamicSparsityPattern dsp(dofs_per_block, dofs_per_block);'
p40199
aS'      DoFTools::make_sparsity_pattern('
p40200
aS'        fluid_dh, coupling, dsp, constraints, false);'
p40201
aS'      SparsityTools::distribute_sparsity_pattern('
p40202
aS'        dsp,'
p40203
aS'        locally_owned_dofs_per_processor,'
p40204
aS'        mpi_communicator,'
p40205
aS'        locally_relevant_dofs);'
p40206
aS'      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);'
p40207
aS'    }'
p40208
aS'    locally_relevant_solution.reinit(fluid_owned_dofs,'
p40209
aS'                                     fluid_relevant_dofs,'
p40210
aS'                                     mpi_communicator);'
p40211
aS'    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);'
p40212
aS'    solution.reinit(fluid_owned_dofs, mpi_communicator);'
p40213
aS'  }'
p40214
aS'  template <int dim, int spacedim>'
p40215
aS'  void StokesImmersedProblem<dim, spacedim>::assemble_stokes_system()'
p40216
aS'  {'
p40217
aS'    system_matrix         = 0;'
p40218
aS'    preconditioner_matrix = 0;'
p40219
aS'    system_rhs            = 0;'
p40220
aS'    TimerOutput::Scope t(computing_timer, "Assemble Stokes terms");'
p40221
aS'    FEValues<spacedim> fe_values(*fluid_fe,'
p40222
aS'                                 update_values | update_gradients |'
p40223
aS'                                   update_quadrature_points |'
p40224
aS'                                   update_JxW_values);'
p40225
aS'    const unsigned int dofs_per_cell = fluid_fe->n_dofs_per_cell();'
p40226
aS'    const unsigned int n_q_points    = fluid_quadrature_formula->size();'
p40227
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p40228
aS'    FullMatrix<double> cell_matrix2(dofs_per_cell, dofs_per_cell);'
p40229
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p40230
aS'    std::vector<Vector<double>> rhs_values(n_q_points,'
p40231
aS'                                           Vector<double>(spacedim + 1));'
p40232
aS'    std::vector<Tensor<2, spacedim>> grad_phi_u(dofs_per_cell);'
p40233
aS'    std::vector<double>              div_phi_u(dofs_per_cell);'
p40234
aS'    std::vector<double>              phi_p(dofs_per_cell);'
p40235
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p40236
aS'    const FEValuesExtractors::Vector     velocities(0);'
p40237
aS'    const FEValuesExtractors::Scalar     pressure(spacedim);'
p40238
aS'    for (const auto &cell : fluid_dh.active_cell_iterators())'
p40239
aS'      if (cell->is_locally_owned())'
p40240
aS'        {'
p40241
aS'          cell_matrix  = 0;'
p40242
aS'          cell_matrix2 = 0;'
p40243
aS'          cell_rhs     = 0;'
p40244
aS'          fe_values.reinit(cell);'
p40245
aS'          par.rhs.vector_value_list(fe_values.get_quadrature_points(),'
p40246
aS'                                    rhs_values);'
p40247
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p40248
aS'            {'
p40249
aS'              for (unsigned int k = 0; k < dofs_per_cell; ++k)'
p40250
aS'                {'
p40251
aS'                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);'
p40252
aS'                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);'
p40253
aS'                  phi_p[k]      = fe_values[pressure].value(k, q);'
p40254
aS'                }'
p40255
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p40256
aS'                {'
p40257
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p40258
aS'                    {'
p40259
aS'                      cell_matrix(i, j) +='
p40260
aS'                           scalar_product(grad_phi_u[i], grad_phi_u[j]) -'
p40261
aS'                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *'
p40262
aS'                        fe_values.JxW(q);'
p40263
aS'                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *'
p40264
aS'                                            phi_p[j] * fe_values.JxW(q);'
p40265
aS'                    }'
p40266
aS'                  const unsigned int component_i ='
p40267
aS'                    fluid_fe->system_to_component_index(i).first;'
p40268
aS'                  cell_rhs(i) += fe_values.shape_value(i, q) *'
p40269
aS'                                 rhs_values[q](component_i) * fe_values.JxW(q);'
p40270
aS'                }'
p40271
aS'            }'
p40272
aS'          cell->get_dof_indices(local_dof_indices);'
p40273
aS'          constraints.distribute_local_to_global(cell_matrix,'
p40274
aS'                                                 cell_rhs,'
p40275
aS'                                                 local_dof_indices,'
p40276
aS'                                                 system_matrix,'
p40277
aS'                                                 system_rhs);'
p40278
aS'          constraints.distribute_local_to_global(cell_matrix2,'
p40279
aS'                                                 local_dof_indices,'
p40280
aS'                                                 preconditioner_matrix);'
p40281
aS'        }'
p40282
aS'    system_matrix.compress(VectorOperation::add);'
p40283
aS'    preconditioner_matrix.compress(VectorOperation::add);'
p40284
aS'    system_rhs.compress(VectorOperation::add);'
p40285
aS'  }'
p40286
aS'  template <int dim, int spacedim>'
p40287
aS'  void StokesImmersedProblem<dim, spacedim>::assemble_nitsche_restriction()'
p40288
aS'  {'
p40289
aS'    TimerOutput::Scope t(computing_timer, "Assemble Nitsche terms");'
p40290
aS'    const FEValuesExtractors::Vector velocities(0);'
p40291
aS'    const FEValuesExtractors::Scalar pressure(spacedim);'
p40292
aS'    SolidVelocity<spacedim> solid_velocity(par.angular_velocity);'
p40293
aS'    std::vector<types::global_dof_index> fluid_dof_indices('
p40294
aS'      fluid_fe->n_dofs_per_cell());'
p40295
aS'    FullMatrix<double>     local_matrix(fluid_fe->n_dofs_per_cell(),'
p40296
aS'                                    fluid_fe->n_dofs_per_cell());'
p40297
aS'    dealii::Vector<double> local_rhs(fluid_fe->n_dofs_per_cell());'
p40298
aS'    const auto penalty_parameter ='
p40299
aS'      1.0 / GridTools::minimal_cell_diameter(fluid_tria);'
p40300
aS'    auto particle = solid_particle_handler.begin();'
p40301
aS'    while (particle != solid_particle_handler.end())'
p40302
aS'      {'
p40303
aS'        local_matrix = 0;'
p40304
aS'        local_rhs    = 0;'
p40305
aS'        const auto &cell = particle->get_surrounding_cell(fluid_tria);'
p40306
aS'        const auto &dh_cell ='
p40307
aS'          typename DoFHandler<spacedim>::cell_iterator(*cell, &fluid_dh);'
p40308
aS'        dh_cell->get_dof_indices(fluid_dof_indices);'
p40309
aS'        const auto pic = solid_particle_handler.particles_in_cell(cell);'
p40310
aS'        Assert(pic.begin() == particle, ExcInternalError());'
p40311
aS'        for (const auto &p : pic)'
p40312
aS'          {'
p40313
aS'            const auto &ref_q  = p.get_reference_location();'
p40314
aS'            const auto &real_q = p.get_location();'
p40315
aS'            const auto &JxW    = p.get_properties()[0];'
p40316
aS'            for (unsigned int i = 0; i < fluid_fe->n_dofs_per_cell(); ++i)'
p40317
aS'              {'
p40318
aS'                const auto comp_i ='
p40319
aS'                  fluid_fe->system_to_component_index(i).first;'
p40320
aS'                if (comp_i < spacedim)'
p40321
aS'                  {'
p40322
aS'                    for (unsigned int j = 0; j < fluid_fe->n_dofs_per_cell();'
p40323
aS'                         ++j)'
p40324
aS'                      {'
p40325
aS'                        const auto comp_j ='
p40326
aS'                          fluid_fe->system_to_component_index(j).first;'
p40327
aS'                        if (comp_i == comp_j)'
p40328
aS'                          local_matrix(i, j) +='
p40329
aS'                            penalty_parameter * par.penalty_term *'
p40330
aS'                            fluid_fe->shape_value(i, ref_q) *'
p40331
aS'                            fluid_fe->shape_value(j, ref_q) * JxW;'
p40332
aS'                      }'
p40333
aS'                    local_rhs(i) += penalty_parameter * par.penalty_term *'
p40334
aS'                                    solid_velocity.value(real_q, comp_i) *'
p40335
aS'                                    fluid_fe->shape_value(i, ref_q) * JxW;'
p40336
aS'                  }'
p40337
aS'              }'
p40338
aS'          }'
p40339
aS'        constraints.distribute_local_to_global(local_matrix,'
p40340
aS'                                               local_rhs,'
p40341
aS'                                               fluid_dof_indices,'
p40342
aS'                                               system_matrix,'
p40343
aS'                                               system_rhs);'
p40344
aS'        particle = pic.end();'
p40345
aS'      }'
p40346
aS'    system_matrix.compress(VectorOperation::add);'
p40347
aS'    system_rhs.compress(VectorOperation::add);'
p40348
aS'  }'
p40349
aS'  template <int dim, int spacedim>'
p40350
aS'  void StokesImmersedProblem<dim, spacedim>::solve()'
p40351
aS'  {'
p40352
aS'    TimerOutput::Scope t(computing_timer, "Solve");'
p40353
aS'    LA::MPI::PreconditionAMG prec_A;'
p40354
aS'    {'
p40355
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p40356
aS'#ifdef USE_PETSC_LA'
p40357
aS'      data.symmetric_operator = true;'
p40358
aS'#endif'
p40359
aS'      prec_A.initialize(system_matrix.block(0, 0), data);'
p40360
aS'    }'
p40361
aS'    LA::MPI::PreconditionAMG prec_S;'
p40362
aS'    {'
p40363
aS'      LA::MPI::PreconditionAMG::AdditionalData data;'
p40364
aS'#ifdef USE_PETSC_LA'
p40365
aS'      data.symmetric_operator = true;'
p40366
aS'#endif'
p40367
aS'      prec_S.initialize(preconditioner_matrix.block(1, 1), data);'
p40368
aS'    }'
p40369
aS'    const auto A = linear_operator<LA::MPI::Vector>(system_matrix.block(0, 0));'
p40370
aS'    const auto amgA = linear_operator(A, prec_A);'
p40371
aS'    const auto S ='
p40372
aS'      linear_operator<LA::MPI::Vector>(preconditioner_matrix.block(1, 1));'
p40373
aS'    const auto amgS = linear_operator(S, prec_S);'
p40374
aS'    ReductionControl          inner_solver_control(100,'
p40375
aS'                                          1e-8 * system_rhs.l2_norm(),'
p40376
aS'                                          1.e-2);'
p40377
aS'    SolverCG<LA::MPI::Vector> cg(inner_solver_control);'
p40378
aS'    const auto invS = inverse_operator(S, cg, amgS);'
p40379
aS'    const auto P = block_diagonal_operator<2, LA::MPI::BlockVector>('
p40380
aS'      std::array<'
p40381
aS'        dealii::LinearOperator<typename LA::MPI::BlockVector::BlockType>,'
p40382
aS'        2>{{amgA, amgS}});'
p40383
aS'    SolverControl solver_control(system_matrix.m(),'
p40384
aS'                                 1e-10 * system_rhs.l2_norm());'
p40385
aS'    SolverFGMRES<LA::MPI::BlockVector> solver(solver_control);'
p40386
aS'    constraints.set_zero(solution);'
p40387
aS'    solver.solve(system_matrix, solution, system_rhs, P);'
p40388
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p40389
aS'          << std::endl;'
p40390
aS'    constraints.distribute(solution);'
p40391
aS'    locally_relevant_solution = solution;'
p40392
aS'    const double mean_pressure ='
p40393
aS'      VectorTools::compute_mean_value(fluid_dh,'
p40394
aS'                                      QGauss<spacedim>(par.velocity_degree + 2),'
p40395
aS'                                      locally_relevant_solution,'
p40396
aS'                                      spacedim);'
p40397
aS'    solution.block(1).add(-mean_pressure);'
p40398
aS'    locally_relevant_solution.block(1) = solution.block(1);'
p40399
aS'  }'
p40400
aS'  template <int dim, int spacedim>'
p40401
aS'  void StokesImmersedProblem<dim, spacedim>::refine_and_transfer()'
p40402
aS'  {'
p40403
aS'    TimerOutput::Scope               t(computing_timer, "Refine");'
p40404
aS'    const FEValuesExtractors::Vector velocity(0);'
p40405
aS'    Vector<float> error_per_cell(fluid_tria.n_active_cells());'
p40406
aS'    KellyErrorEstimator<spacedim>::estimate(fluid_dh,'
p40407
aS'                                            QGauss<spacedim - 1>('
p40408
aS'                                              par.velocity_degree + 1),'
p40409
aS'                                            {},'
p40410
aS'                                            locally_relevant_solution,'
p40411
aS'                                            error_per_cell,'
p40412
aS'                                            fluid_fe->component_mask(velocity));'
p40413
aS'    if (par.refinement_strategy == "fixed_fraction")'
p40414
aS'      {'
p40415
aS'        parallel::distributed::GridRefinement::'
p40416
aS'          refine_and_coarsen_fixed_fraction(fluid_tria,'
p40417
aS'                                            error_per_cell,'
p40418
aS'                                            par.refinement_fraction,'
p40419
aS'                                            par.coarsening_fraction);'
p40420
aS'      }'
p40421
aS'    else if (par.refinement_strategy == "fixed_number")'
p40422
aS'      {'
p40423
aS'        parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p40424
aS'          fluid_tria,'
p40425
aS'          error_per_cell,'
p40426
aS'          par.refinement_fraction,'
p40427
aS'          par.coarsening_fraction,'
p40428
aS'          par.max_cells);'
p40429
aS'      }'
p40430
aS'    for (const auto &cell : fluid_tria.active_cell_iterators())'
p40431
aS'      {'
p40432
aS'        if (cell->refine_flag_set() &&'
p40433
aS'            cell->level() == par.max_level_refinement)'
p40434
aS'          cell->clear_refine_flag();'
p40435
aS'        if (cell->coarsen_flag_set() &&'
p40436
aS'            cell->level() == par.min_level_refinement)'
p40437
aS'          cell->clear_coarsen_flag();'
p40438
aS'      }'
p40439
aS'    parallel::distributed::SolutionTransfer<spacedim, LA::MPI::BlockVector>'
p40440
aS'      transfer(fluid_dh);'
p40441
aS'    fluid_tria.prepare_coarsening_and_refinement();'
p40442
aS'    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);'
p40443
aS'    fluid_tria.execute_coarsening_and_refinement();'
p40444
aS'    setup_dofs();'
p40445
aS'    transfer.interpolate(solution);'
p40446
aS'    constraints.distribute(solution);'
p40447
aS'    locally_relevant_solution = solution;'
p40448
aS'  }'
p40449
aS'  template <int dim, int spacedim>'
p40450
aS'  void'
p40451
aS'  StokesImmersedProblem<dim, spacedim>::output_results(const unsigned int cycle,'
p40452
aS'                                                       double time) const'
p40453
aS'  {'
p40454
aS'    TimerOutput::Scope t(computing_timer, "Output fluid");'
p40455
aS'    std::vector<std::string> solution_names(spacedim, "velocity");'
p40456
aS'    solution_names.emplace_back("pressure");'
p40457
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p40458
aS'      data_component_interpretation('
p40459
aS'        spacedim, DataComponentInterpretation::component_is_part_of_vector);'
p40460
aS'    data_component_interpretation.push_back('
p40461
aS'      DataComponentInterpretation::component_is_scalar);'
p40462
aS'    DataOut<spacedim> data_out;'
p40463
aS'    data_out.attach_dof_handler(fluid_dh);'
p40464
aS'    data_out.add_data_vector(locally_relevant_solution,'
p40465
aS'                             solution_names,'
p40466
aS'                             DataOut<spacedim>::type_dof_data,'
p40467
aS'                             data_component_interpretation);'
p40468
aS'    Vector<float> subdomain(fluid_tria.n_active_cells());'
p40469
aS'    for (unsigned int i = 0; i < subdomain.size(); ++i)'
p40470
aS'      subdomain(i) = fluid_tria.locally_owned_subdomain();'
p40471
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p40472
aS'    data_out.build_patches();'
p40473
aS'    const std::string filename ='
p40474
aS'      "solution-" + Utilities::int_to_string(cycle) + ".vtu";'
p40475
aS'    data_out.write_vtu_in_parallel(par.output_directory + "/" + filename,'
p40476
aS'                                   mpi_communicator);'
p40477
aS'    static std::vector<std::pair<double, std::string>> times_and_names;'
p40478
aS'    times_and_names.push_back(std::make_pair(time, filename));'
p40479
aS'    std::ofstream ofile(par.output_directory + "/" + "solution.pvd");'
p40480
aS'    DataOutBase::write_pvd_record(ofile, times_and_names);'
p40481
aS'  }'
p40482
aS'  template <int dim, int spacedim>'
p40483
aS'  void StokesImmersedProblem<dim, spacedim>::output_particles('
p40484
aS'    const Particles::ParticleHandler<spacedim> &particles,'
p40485
aS'    std::string                                 fprefix,'
p40486
aS'    const unsigned int                          iter,'
p40487
aS'    const double                                time) const'
p40488
aS'  {'
p40489
aS'    Particles::DataOut<spacedim> particles_out;'
p40490
aS'    particles_out.build_patches(particles);'
p40491
aS'    const std::string filename ='
p40492
aS'    particles_out.write_vtu_in_parallel(par.output_directory + "/" + filename,'
p40493
aS'                                        mpi_communicator);'
p40494
aS'    static std::map<std::string, std::vector<std::pair<double, std::string>>>'
p40495
aS'      times_and_names;'
p40496
aS'    if (times_and_names.find(fprefix) != times_and_names.end())'
p40497
aS'      times_and_names[fprefix].push_back(std::make_pair(time, filename));'
p40498
aS'    else'
p40499
aS'      times_and_names[fprefix] = {std::make_pair(time, filename)};'
p40500
aS'    std::ofstream ofile(par.output_directory + "/" + fprefix + ".pvd");'
p40501
aS'    DataOutBase::write_pvd_record(ofile, times_and_names[fprefix]);'
p40502
aS'  }'
p40503
aS'  template <int dim, int spacedim>'
p40504
aS'  void StokesImmersedProblem<dim, spacedim>::run()'
p40505
aS'  {'
p40506
aS'#ifdef USE_PETSC_LA'
p40507
aS'    pcout << "Running StokesImmersedProblem<"'
p40508
aS'          << Utilities::dim_string(dim, spacedim) << "> using PETSc."'
p40509
aS'          << std::endl;'
p40510
aS'#else'
p40511
aS'    pcout << "Running StokesImmersedProblem<"'
p40512
aS'          << Utilities::dim_string(dim, spacedim) << "> using Trilinos."'
p40513
aS'          << std::endl;'
p40514
aS'#endif'
p40515
aS'    par.prm.print_parameters(par.output_directory + "/" + "used_parameters_" +'
p40516
aS'                               std::to_string(dim) + std::to_string(spacedim) +'
p40517
aS'                               ".prm",'
p40518
aS'                             ParameterHandler::Short);'
p40519
aS'    const double time_step    = par.final_time / (par.number_of_time_steps - 1);'
p40520
aS'    double       time         = 0;'
p40521
aS'    unsigned int output_cycle = 0;'
p40522
aS'    for (unsigned int cycle = 0; cycle < par.number_of_time_steps;'
p40523
aS'         ++cycle, time += time_step)'
p40524
aS'      {'
p40525
aS'        par.set_time(time);'
p40526
aS'        pcout << "Cycle " << cycle << \':\' << std::endl'
p40527
aS'              << "Time : " << time << ", time step: " << time_step << std::endl;'
p40528
aS'        if (cycle == 0)'
p40529
aS'          {'
p40530
aS'            make_grid();'
p40531
aS'            initial_setup();'
p40532
aS'            setup_dofs();'
p40533
aS'            setup_tracer_particles();'
p40534
aS'            setup_solid_particles();'
p40535
aS'            tracer_particle_velocities.reinit('
p40536
aS'              locally_owned_tracer_particle_coordinates, mpi_communicator);'
p40537
aS'            output_results(output_cycle, time);'
p40538
aS'            {'
p40539
aS'              TimerOutput::Scope t(computing_timer, "Output tracer particles");'
p40540
aS'              output_particles(tracer_particle_handler,'
p40541
aS'                               "tracer",'
p40542
aS'                               output_cycle,'
p40543
aS'                               time);'
p40544
aS'            }'
p40545
aS'            {'
p40546
aS'              TimerOutput::Scope t(computing_timer, "Output solid particles");'
p40547
aS'              output_particles(solid_particle_handler,'
p40548
aS'                               "solid",'
p40549
aS'                               output_cycle,'
p40550
aS'                               time);'
p40551
aS'            }'
p40552
aS'          }'
p40553
aS'        else'
p40554
aS'          {'
p40555
aS'            TimerOutput::Scope t(computing_timer,'
p40556
aS'                                 "Set solid particle position");'
p40557
aS'            SolidPosition<spacedim> solid_position(par.angular_velocity,'
p40558
aS'                                                   time_step);'
p40559
aS'            solid_particle_handler.set_particle_positions(solid_position,'
p40560
aS'                                                          false);'
p40561
aS'          }'
p40562
aS'        {'
p40563
aS'          TimerOutput::Scope t(computing_timer, "Set tracer particle motion");'
p40564
aS'          Particles::Utilities::interpolate_field_on_particles('
p40565
aS'            fluid_dh,'
p40566
aS'            tracer_particle_handler,'
p40567
aS'            locally_relevant_solution,'
p40568
aS'            tracer_particle_velocities,'
p40569
aS'            fluid_fe->component_mask(FEValuesExtractors::Vector(0)));'
p40570
aS'          tracer_particle_velocities *= time_step;'
p40571
aS'          locally_relevant_tracer_particle_coordinates ='
p40572
aS'            tracer_particle_handler.locally_owned_particle_ids().tensor_product('
p40573
aS'              complete_index_set(spacedim));'
p40574
aS'          relevant_tracer_particle_displacements.reinit('
p40575
aS'            locally_owned_tracer_particle_coordinates,'
p40576
aS'            locally_relevant_tracer_particle_coordinates,'
p40577
aS'            mpi_communicator);'
p40578
aS'          relevant_tracer_particle_displacements = tracer_particle_velocities;'
p40579
aS'          tracer_particle_handler.set_particle_positions('
p40580
aS'            relevant_tracer_particle_displacements);'
p40581
aS'        }'
p40582
aS'        assemble_stokes_system();'
p40583
aS'        assemble_nitsche_restriction();'
p40584
aS'        solve();'
p40585
aS'        if (cycle % par.output_frequency == 0)'
p40586
aS'          {'
p40587
aS'            output_results(output_cycle, time);'
p40588
aS'            {'
p40589
aS'              TimerOutput::Scope t(computing_timer, "Output tracer particles");'
p40590
aS'              output_particles(tracer_particle_handler,'
p40591
aS'                               "tracer",'
p40592
aS'                               output_cycle,'
p40593
aS'                               time);'
p40594
aS'            }'
p40595
aS'            {'
p40596
aS'              TimerOutput::Scope t(computing_timer, "Output solid particles");'
p40597
aS'              output_particles(solid_particle_handler,'
p40598
aS'                               "solid",'
p40599
aS'                               output_cycle,'
p40600
aS'                               time);'
p40601
aS'            }'
p40602
aS'            ++output_cycle;'
p40603
aS'          }'
p40604
aS'        if (cycle % par.refinement_frequency == 0 &&'
p40605
aS'            cycle != par.number_of_time_steps - 1)'
p40606
aS'          refine_and_transfer();'
p40607
aS'      }'
p40608
aS'  }'
p40609
aS'} // namespace Step70'
p40610
aS'int main(int argc, char *argv[])'
p40611
ag9
aS'  using namespace Step70;'
p40612
aS'  using namespace dealii;'
p40613
aS'  deallog.depth_console(1);'
p40614
aS'  try'
p40615
aS'    {'
p40616
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p40617
aS'      std::string prm_file;'
p40618
aS'      if (argc > 1)'
p40619
aS'        prm_file = argv[1];'
p40620
aS'      else'
p40621
aS'        prm_file = "parameters.prm";'
p40622
aS'      if (prm_file.find("23") != std::string::npos)'
p40623
aS'        {'
p40624
aS'          StokesImmersedProblemParameters<2, 3> par;'
p40625
aS'          ParameterAcceptor::initialize(prm_file);'
p40626
aS'          StokesImmersedProblem<2, 3> problem(par);'
p40627
aS'          problem.run();'
p40628
aS'        }'
p40629
aS'      else if (prm_file.find("3") != std::string::npos)'
p40630
aS'        {'
p40631
aS'          StokesImmersedProblemParameters<3> par;'
p40632
aS'          ParameterAcceptor::initialize(prm_file);'
p40633
aS'          StokesImmersedProblem<3> problem(par);'
p40634
aS'          problem.run();'
p40635
aS'        }'
p40636
aS'      else'
p40637
aS'        {'
p40638
aS'          StokesImmersedProblemParameters<2> par;'
p40639
aS'          ParameterAcceptor::initialize(prm_file);'
p40640
aS'          StokesImmersedProblem<2> problem(par);'
p40641
aS'          problem.run();'
p40642
aS'        }'
p40643
aS'    }'
p40644
aS'  catch (std::exception &exc)'
p40645
aS'    {'
p40646
aS'      std::cerr << std::endl'
p40647
aS'                << std::endl'
p40648
aS'                << "----------------------------------------------------"'
p40649
aS'                << std::endl;'
p40650
aS'      std::cerr << "Exception on processing: " << std::endl'
p40651
aS'                << exc.what() << std::endl'
p40652
aS'                << "Aborting!" << std::endl'
p40653
aS'                << "----------------------------------------------------"'
p40654
aS'                << std::endl;'
p40655
aS'      return 1;'
p40656
aS'    }'
p40657
aS'  catch (...)'
p40658
aS'    {'
p40659
aS'      std::cerr << std::endl'
p40660
aS'                << std::endl'
p40661
aS'                << "----------------------------------------------------"'
p40662
aS'                << std::endl;'
p40663
aS'      std::cerr << "Unknown exception!" << std::endl'
p40664
aS'                << "Aborting!" << std::endl'
p40665
aS'                << "----------------------------------------------------"'
p40666
aS'                << std::endl;'
p40667
aS'      return 1;'
p40668
aS'    }'
p40669
aS'  return 0;'
p40670
ag17
aS'#include <deal.II/algorithms/general_data_storage.h>'
p40671
aS'#include <deal.II/base/discrete_time.h>'
p40672
aS'#include <deal.II/base/numbers.h>'
p40673
aS'#include <deal.II/base/parameter_acceptor.h>'
p40674
aS'#include <deal.II/base/symmetric_tensor.h>'
p40675
aS'#include <deal.II/base/tensor.h>'
p40676
aS'#include <deal.II/base/timer.h>'
p40677
aS'#include <deal.II/base/utilities.h>'
p40678
aS'#include <deal.II/physics/transformations.h>'
p40679
aS'#include <deal.II/physics/elasticity/kinematics.h>'
p40680
aS'#include <deal.II/physics/elasticity/standard_tensors.h>'
p40681
aS'#include <deal.II/differentiation/ad.h>'
p40682
aS'#include <deal.II/differentiation/sd.h>'
p40683
aS'#include <fstream>'
p40684
aS'namespace Step71'
p40685
ag9
aS'  using namespace dealii;'
p40686
aS'  namespace SimpleExample'
p40687
aS'  {'
p40688
aS'    template <typename NumberType>'
p40689
aS'    NumberType f(const NumberType &x, const NumberType &y)'
p40690
aS'    {'
p40691
aS'      return std::cos(y / x);'
p40692
aS'    }'
p40693
aS'    double df_dx(const double x, const double y);'
p40694
aS'    double df_dy(const double x, const double y);'
p40695
aS'    double d2f_dx_dx(const double x, const double y);'
p40696
aS'    double d2f_dx_dy(const double x, const double y);'
p40697
aS'    double d2f_dy_dx(const double x, const double y);'
p40698
aS'    double d2f_dy_dy(const double x, const double y);'
p40699
aS'    void'
p40700
aS'    run_and_verify_ad(const double x, const double y, const double tol = 1e-12)'
p40701
aS'    {'
p40702
aS'      constexpr unsigned int                     dim = 1;'
p40703
aS'      constexpr Differentiation::AD::NumberTypes ADTypeCode ='
p40704
aS'        Differentiation::AD::NumberTypes::sacado_dfad_dfad;'
p40705
aS'      using ADHelper ='
p40706
aS'        Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;'
p40707
aS'      constexpr unsigned int n_independent_variables = 2;'
p40708
aS'      ADHelper ad_helper(n_independent_variables);'
p40709
aS'      using ADNumberType = typename ADHelper::ad_type;'
p40710
aS'      ad_helper.register_independent_variables({x, y});'
p40711
aS'      const std::vector<ADNumberType> independent_variables_ad ='
p40712
aS'        ad_helper.get_sensitive_variables();'
p40713
aS'      const ADNumberType &x_ad = independent_variables_ad[0];'
p40714
aS'      const ADNumberType &y_ad = independent_variables_ad[1];'
p40715
aS'      const ADNumberType f_ad = f(x_ad, y_ad);'
p40716
aS'      ad_helper.register_dependent_variable(f_ad);'
p40717
aS'      Vector<double>     Df(ad_helper.n_dependent_variables());'
p40718
aS'      FullMatrix<double> D2f(ad_helper.n_dependent_variables(),'
p40719
aS'                             ad_helper.n_independent_variables());'
p40720
aS'      const double computed_f = ad_helper.compute_value();'
p40721
aS'      ad_helper.compute_gradient(Df);'
p40722
aS'      ad_helper.compute_hessian(D2f);'
p40723
aS'      AssertThrow(std::abs(f(x, y) - computed_f) < tol,'
p40724
aS'                  ExcMessage(std::string("Incorrect value computed for f. ") +'
p40725
aS'                             std::string("Hand-calculated value: ") +'
p40726
aS'                             Utilities::to_string(f(x, y)) +'
p40727
aS'                             std::string(" ; ") +'
p40728
aS'                             std::string("Value computed by AD: ") +'
p40729
aS'                             Utilities::to_string(computed_f)));'
p40730
aS'      const double computed_df_dx = Df[0];'
p40731
aS'      const double computed_df_dy = Df[1];'
p40732
aS'      AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,'
p40733
aS'                  ExcMessage('
p40734
aS'                    std::string("Incorrect value computed for df/dx. ") +'
p40735
aS'                    std::string("Hand-calculated value: ") +'
p40736
aS'                    Utilities::to_string(df_dx(x, y)) + std::string(" ; ") +'
p40737
aS'                    std::string("Value computed by AD: ") +'
p40738
aS'                    Utilities::to_string(computed_df_dx)));'
p40739
aS'      AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,'
p40740
aS'                  ExcMessage('
p40741
aS'                    std::string("Incorrect value computed for df/dy. ") +'
p40742
aS'                    std::string("Hand-calculated value: ") +'
p40743
aS'                    Utilities::to_string(df_dy(x, y)) + std::string(" ; ") +'
p40744
aS'                    std::string("Value computed by AD: ") +'
p40745
aS'                    Utilities::to_string(computed_df_dy)));'
p40746
aS'      const double computed_d2f_dx_dx = D2f[0][0];'
p40747
aS'      const double computed_d2f_dx_dy = D2f[0][1];'
p40748
aS'      const double computed_d2f_dy_dx = D2f[1][0];'
p40749
aS'      const double computed_d2f_dy_dy = D2f[1][1];'
p40750
aS'      AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,'
p40751
aS'                  ExcMessage('
p40752
aS'                    std::string("Incorrect value computed for d2f/dx_dx. ") +'
p40753
aS'                    std::string("Hand-calculated value: ") +'
p40754
aS'                    Utilities::to_string(d2f_dx_dx(x, y)) + std::string(" ; ") +'
p40755
aS'                    std::string("Value computed by AD: ") +'
p40756
aS'                    Utilities::to_string(computed_d2f_dx_dx)));'
p40757
aS'      AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,'
p40758
aS'                  ExcMessage('
p40759
aS'                    std::string("Incorrect value computed for d2f/dx_dy. ") +'
p40760
aS'                    std::string("Hand-calculated value: ") +'
p40761
aS'                    Utilities::to_string(d2f_dx_dy(x, y)) + std::string(" ; ") +'
p40762
aS'                    std::string("Value computed by AD: ") +'
p40763
aS'                    Utilities::to_string(computed_d2f_dx_dy)));'
p40764
aS'      AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,'
p40765
aS'                  ExcMessage('
p40766
aS'                    std::string("Incorrect value computed for d2f/dy_dx. ") +'
p40767
aS'                    std::string("Hand-calculated value: ") +'
p40768
aS'                    Utilities::to_string(d2f_dy_dx(x, y)) + std::string(" ; ") +'
p40769
aS'                    std::string("Value computed by AD: ") +'
p40770
aS'                    Utilities::to_string(computed_d2f_dy_dx)));'
p40771
aS'      AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,'
p40772
aS'                  ExcMessage('
p40773
aS'                    std::string("Incorrect value computed for d2f/dy_dy. ") +'
p40774
aS'                    std::string("Hand-calculated value: ") +'
p40775
aS'                    Utilities::to_string(d2f_dy_dy(x, y)) + std::string(" ; ") +'
p40776
aS'                    std::string("Value computed by AD: ") +'
p40777
aS'                    Utilities::to_string(computed_d2f_dy_dy)));'
p40778
aS'    }'
p40779
aS'    double df_dx(const double x, const double y)'
p40780
aS'    {'
p40781
aS'      Assert(x != 0.0, ExcDivideByZero());'
p40782
aS'      return y * std::sin(y / x) / (x * x);'
p40783
aS'    }'
p40784
aS'    double df_dy(const double x, const double y)'
p40785
aS'    {'
p40786
aS'      return -std::sin(y / x) / x;'
p40787
aS'    }'
p40788
aS'    double d2f_dx_dx(const double x, const double y)'
p40789
aS'    {'
p40790
aS'      return -y * (2 * x * std::sin(y / x) + y * std::cos(y / x)) /'
p40791
aS'    }'
p40792
aS'    double d2f_dx_dy(const double x, const double y)'
p40793
aS'    {'
p40794
aS'      return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);'
p40795
aS'    }'
p40796
aS'    double d2f_dy_dx(const double x, const double y)'
p40797
aS'    {'
p40798
aS'      return (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);'
p40799
aS'    }'
p40800
aS'    double d2f_dy_dy(const double x, const double y)'
p40801
aS'    {'
p40802
aS'      return -(std::cos(y / x)) / (x * x);'
p40803
aS'    }'
p40804
aS'    void'
p40805
aS'    run_and_verify_sd(const double x, const double y, const double tol = 1e-12)'
p40806
aS'    {'
p40807
aS'      const Differentiation::SD::Expression x_sd("x");'
p40808
aS'      const Differentiation::SD::Expression y_sd("y");'
p40809
aS'      const Differentiation::SD::Expression f_sd = f(x_sd, y_sd);'
p40810
aS'      const Differentiation::SD::Expression df_dx_sd = f_sd.differentiate(x_sd);'
p40811
aS'      const Differentiation::SD::Expression df_dy_sd = f_sd.differentiate(y_sd);'
p40812
aS'      const Differentiation::SD::Expression d2f_dx_dx_sd ='
p40813
aS'        df_dx_sd.differentiate(x_sd);'
p40814
aS'      const Differentiation::SD::Expression d2f_dx_dy_sd ='
p40815
aS'        df_dx_sd.differentiate(y_sd);'
p40816
aS'      const Differentiation::SD::Expression d2f_dy_dx_sd ='
p40817
aS'        df_dy_sd.differentiate(x_sd);'
p40818
aS'      const Differentiation::SD::Expression d2f_dy_dy_sd ='
p40819
aS'        df_dy_sd.differentiate(y_sd);'
p40820
aS'      const Differentiation::SD::types::substitution_map substitution_map ='
p40821
aS'        Differentiation::SD::make_substitution_map('
p40822
aS'          std::pair<Differentiation::SD::Expression, double>{x_sd, x},'
p40823
aS'          std::pair<Differentiation::SD::Expression, double>{y_sd, y});'
p40824
aS'      const double computed_f ='
p40825
aS'        f_sd.substitute_and_evaluate<double>(substitution_map);'
p40826
aS'      AssertThrow(std::abs(f(x, y) - computed_f) < tol,'
p40827
aS'                  ExcMessage(std::string("Incorrect value computed for f. ") +'
p40828
aS'                             std::string("Hand-calculated value: ") +'
p40829
aS'                             Utilities::to_string(f(x, y)) +'
p40830
aS'                             std::string(" ; ") +'
p40831
aS'                             std::string("Value computed by AD: ") +'
p40832
aS'                             Utilities::to_string(computed_f)));'
p40833
aS'      const double computed_df_dx ='
p40834
aS'        df_dx_sd.substitute_and_evaluate<double>(substitution_map);'
p40835
aS'      const double computed_df_dy ='
p40836
aS'        df_dy_sd.substitute_and_evaluate<double>(substitution_map);'
p40837
aS'      AssertThrow(std::abs(df_dx(x, y) - computed_df_dx) < tol,'
p40838
aS'                  ExcMessage('
p40839
aS'                    std::string("Incorrect value computed for df/dx. ") +'
p40840
aS'                    std::string("Hand-calculated value: ") +'
p40841
aS'                    Utilities::to_string(df_dx(x, y)) + std::string(" ; ") +'
p40842
aS'                    std::string("Value computed by AD: ") +'
p40843
aS'                    Utilities::to_string(computed_df_dx)));'
p40844
aS'      AssertThrow(std::abs(df_dy(x, y) - computed_df_dy) < tol,'
p40845
aS'                  ExcMessage('
p40846
aS'                    std::string("Incorrect value computed for df/dy. ") +'
p40847
aS'                    std::string("Hand-calculated value: ") +'
p40848
aS'                    Utilities::to_string(df_dy(x, y)) + std::string(" ; ") +'
p40849
aS'                    std::string("Value computed by AD: ") +'
p40850
aS'                    Utilities::to_string(computed_df_dy)));'
p40851
aS'      const double computed_d2f_dx_dx ='
p40852
aS'        d2f_dx_dx_sd.substitute_and_evaluate<double>(substitution_map);'
p40853
aS'      const double computed_d2f_dx_dy ='
p40854
aS'        d2f_dx_dy_sd.substitute_and_evaluate<double>(substitution_map);'
p40855
aS'      const double computed_d2f_dy_dx ='
p40856
aS'        d2f_dy_dx_sd.substitute_and_evaluate<double>(substitution_map);'
p40857
aS'      const double computed_d2f_dy_dy ='
p40858
aS'        d2f_dy_dy_sd.substitute_and_evaluate<double>(substitution_map);'
p40859
aS'      AssertThrow(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) < tol,'
p40860
aS'                  ExcMessage('
p40861
aS'                    std::string("Incorrect value computed for d2f/dx_dx. ") +'
p40862
aS'                    std::string("Hand-calculated value: ") +'
p40863
aS'                    Utilities::to_string(d2f_dx_dx(x, y)) + std::string(" ; ") +'
p40864
aS'                    std::string("Value computed by SD: ") +'
p40865
aS'                    Utilities::to_string(computed_d2f_dx_dx)));'
p40866
aS'      AssertThrow(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) < tol,'
p40867
aS'                  ExcMessage('
p40868
aS'                    std::string("Incorrect value computed for d2f/dx_dy. ") +'
p40869
aS'                    std::string("Hand-calculated value: ") +'
p40870
aS'                    Utilities::to_string(d2f_dx_dy(x, y)) + std::string(" ; ") +'
p40871
aS'                    std::string("Value computed by SD: ") +'
p40872
aS'                    Utilities::to_string(computed_d2f_dx_dy)));'
p40873
aS'      AssertThrow(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) < tol,'
p40874
aS'                  ExcMessage('
p40875
aS'                    std::string("Incorrect value computed for d2f/dy_dx. ") +'
p40876
aS'                    std::string("Hand-calculated value: ") +'
p40877
aS'                    Utilities::to_string(d2f_dy_dx(x, y)) + std::string(" ; ") +'
p40878
aS'                    std::string("Value computed by SD: ") +'
p40879
aS'                    Utilities::to_string(computed_d2f_dy_dx)));'
p40880
aS'      AssertThrow(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) < tol,'
p40881
aS'                  ExcMessage('
p40882
aS'                    std::string("Incorrect value computed for d2f/dy_dy. ") +'
p40883
aS'                    std::string("Hand-calculated value: ") +'
p40884
aS'                    Utilities::to_string(d2f_dy_dy(x, y)) + std::string(" ; ") +'
p40885
aS'                    std::string("Value computed by SD: ") +'
p40886
aS'                    Utilities::to_string(computed_d2f_dy_dy)));'
p40887
aS'    }'
p40888
aS'    void run()'
p40889
aS'    {'
p40890
aS'      const double x = 1.23;'
p40891
aS'      const double y = 0.91;'
p40892
aS'      std::cout << "Simple example using automatic differentiation..."'
p40893
aS'                << std::endl;'
p40894
aS'      run_and_verify_ad(x, y);'
p40895
aS'      std::cout << "... all calculations are correct!" << std::endl;'
p40896
aS'      std::cout << "Simple example using symbolic differentiation."'
p40897
aS'                << std::endl;'
p40898
aS'      run_and_verify_sd(x, y);'
p40899
aS'      std::cout << "... all calculations are correct!" << std::endl;'
p40900
aS'    }'
p40901
aS'  } // namespace SimpleExample'
p40902
aS'  namespace CoupledConstitutiveLaws'
p40903
aS'  {'
p40904
aS'    class ConstitutiveParameters : public ParameterAcceptor'
p40905
aS'    {'
p40906
aS'    public:'
p40907
aS'      ConstitutiveParameters();'
p40908
aS'      double mu_e       = 30.0e3;'
p40909
aS'      double mu_e_inf   = 250.0e3;'
p40910
aS'      double mu_e_h_sat = 212.2e3;'
p40911
aS'      double nu_e       = 0.49;'
p40912
aS'      double mu_v       = 20.0e3;'
p40913
aS'      double mu_v_inf   = 35.0e3;'
p40914
aS'      double mu_v_h_sat = 92.84e3;'
p40915
aS'      double tau_v      = 0.6;'
p40916
aS'      double mu_r = 6.0;'
p40917
aS'      bool initialized = false;'
p40918
aS'    };'
p40919
aS'    ConstitutiveParameters::ConstitutiveParameters()'
p40920
aS'      : ParameterAcceptor("/Coupled Constitutive Laws/Constitutive Parameters/")'
p40921
aS'    {'
p40922
aS'      add_parameter("Elastic shear modulus", mu_e);'
p40923
aS'      add_parameter("Elastic shear modulus at magnetic saturation", mu_e_inf);'
p40924
aS'      add_parameter('
p40925
aS'        "Saturation magnetic field strength for elastic shear modulus",'
p40926
aS'        mu_e_h_sat);'
p40927
aS'      add_parameter("Poisson ratio", nu_e);'
p40928
aS'      add_parameter("Viscoelastic shear modulus", mu_v);'
p40929
aS'      add_parameter("Viscoelastic shear modulus at magnetic saturation",'
p40930
aS'                    mu_v_inf);'
p40931
aS'      add_parameter('
p40932
aS'        "Saturation magnetic field strength for viscoelastic shear modulus",'
p40933
aS'        mu_v_h_sat);'
p40934
aS'      add_parameter("Characteristic relaxation time", tau_v);'
p40935
aS'      add_parameter("Relative magnetic permeability", mu_r);'
p40936
aS'      parse_parameters_call_back.connect([&]() { initialized = true; });'
p40937
aS'    }'
p40938
aS'    template <int dim>'
p40939
aS'    class Coupled_Magnetomechanical_Constitutive_Law_Base'
p40940
aS'    {'
p40941
aS'    public:'
p40942
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base('
p40943
aS'        const ConstitutiveParameters &constitutive_parameters);'
p40944
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p40945
aS'                                        const Tensor<1, dim> &         H,'
p40946
aS'                                        const DiscreteTime &time) = 0;'
p40947
aS'      virtual double get_psi() const = 0;'
p40948
aS'      virtual Tensor<1, dim> get_B() const = 0;'
p40949
aS'      virtual SymmetricTensor<2, dim> get_S() const = 0;'
p40950
aS'      virtual SymmetricTensor<2, dim> get_DD() const = 0;'
p40951
aS'      virtual Tensor<3, dim> get_PP() const = 0;'
p40952
aS'      virtual SymmetricTensor<4, dim> get_HH() const = 0;'
p40953
aS'      virtual void update_end_of_timestep()'
p40954
aS'      {}'
p40955
aS'    protected:'
p40956
aS'      const ConstitutiveParameters &constitutive_parameters;'
p40957
aS'      double get_mu_e() const;'
p40958
aS'      double get_mu_e_inf() const;'
p40959
aS'      double get_mu_e_h_sat() const;'
p40960
aS'      double get_nu_e() const;'
p40961
aS'      double get_lambda_e() const;'
p40962
aS'      double get_kappa_e() const;'
p40963
aS'      double get_mu_v() const;'
p40964
aS'      double get_mu_v_inf() const;'
p40965
aS'      double get_mu_v_h_sat() const;'
p40966
aS'      double get_tau_v() const;'
p40967
aS'      double get_mu_r() const;'
p40968
aS'      constexpr double get_mu_0() const;'
p40969
aS'      double           get_delta_t(const DiscreteTime &time) const;'
p40970
aS'    };'
p40971
aS'    template <int dim>'
p40972
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::'
p40973
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base('
p40974
aS'        const ConstitutiveParameters &constitutive_parameters)'
p40975
aS'      : constitutive_parameters(constitutive_parameters)'
p40976
aS'    {'
p40977
aS'      Assert(get_kappa_e() > 0, ExcInternalError());'
p40978
aS'    }'
p40979
aS'    template <int dim>'
p40980
aS'    double'
p40981
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e() const'
p40982
aS'    {'
p40983
aS'      return constitutive_parameters.mu_e;'
p40984
aS'    }'
p40985
aS'    template <int dim>'
p40986
aS'    double'
p40987
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_inf() const'
p40988
aS'    {'
p40989
aS'      return constitutive_parameters.mu_e_inf;'
p40990
aS'    }'
p40991
aS'    template <int dim>'
p40992
aS'    double'
p40993
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_e_h_sat() const'
p40994
aS'    {'
p40995
aS'      return constitutive_parameters.mu_e_h_sat;'
p40996
aS'    }'
p40997
aS'    template <int dim>'
p40998
aS'    double'
p40999
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_nu_e() const'
p41000
aS'    {'
p41001
aS'      return constitutive_parameters.nu_e;'
p41002
aS'    }'
p41003
aS'    template <int dim>'
p41004
aS'    double'
p41005
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_lambda_e() const'
p41006
aS'    {'
p41007
aS'      return 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());'
p41008
aS'    }'
p41009
aS'    template <int dim>'
p41010
aS'    double'
p41011
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_kappa_e() const'
p41012
aS'    {'
p41013
aS'      return (2.0 * get_mu_e() * (1.0 + get_nu_e())) /'
p41014
aS'    }'
p41015
aS'    template <int dim>'
p41016
aS'    double'
p41017
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v() const'
p41018
aS'    {'
p41019
aS'      return constitutive_parameters.mu_v;'
p41020
aS'    }'
p41021
aS'    template <int dim>'
p41022
aS'    double'
p41023
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_inf() const'
p41024
aS'    {'
p41025
aS'      return constitutive_parameters.mu_v_inf;'
p41026
aS'    }'
p41027
aS'    template <int dim>'
p41028
aS'    double'
p41029
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_v_h_sat() const'
p41030
aS'    {'
p41031
aS'      return constitutive_parameters.mu_v_h_sat;'
p41032
aS'    }'
p41033
aS'    template <int dim>'
p41034
aS'    double'
p41035
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_tau_v() const'
p41036
aS'    {'
p41037
aS'      return constitutive_parameters.tau_v;'
p41038
aS'    }'
p41039
aS'    template <int dim>'
p41040
aS'    double'
p41041
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_r() const'
p41042
aS'    {'
p41043
aS'      return constitutive_parameters.mu_r;'
p41044
aS'    }'
p41045
aS'    template <int dim>'
p41046
aS'    constexpr double'
p41047
aS'    Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_mu_0() const'
p41048
aS'    {'
p41049
aS'      return 4.0 * numbers::PI * 1e-7;'
p41050
aS'    }'
p41051
aS'    template <int dim>'
p41052
aS'    double Coupled_Magnetomechanical_Constitutive_Law_Base<dim>::get_delta_t('
p41053
aS'      const DiscreteTime &time) const'
p41054
aS'    {'
p41055
aS'      return time.get_previous_step_size();'
p41056
aS'    }'
p41057
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41058
aS'    class Magnetoelastic_Constitutive_Law_AD final'
p41059
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p41060
aS'    {'
p41061
aS'      using ADHelper ='
p41062
aS'        Differentiation::AD::ScalarFunction<dim, ADTypeCode, double>;'
p41063
aS'      using ADNumberType = typename ADHelper::ad_type;'
p41064
aS'    public:'
p41065
aS'      Magnetoelastic_Constitutive_Law_AD('
p41066
aS'        const ConstitutiveParameters &constitutive_parameters);'
p41067
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p41068
aS'                                        const Tensor<1, dim> &         H,'
p41069
aS'                                        const DiscreteTime &) override;'
p41070
aS'      virtual double get_psi() const override;'
p41071
aS'      virtual Tensor<1, dim> get_B() const override;'
p41072
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p41073
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p41074
aS'      virtual Tensor<3, dim> get_PP() const override;'
p41075
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p41076
aS'    private:'
p41077
aS'      const FEValuesExtractors::Vector             H_components;'
p41078
aS'      const FEValuesExtractors::SymmetricTensor<2> C_components;'
p41079
aS'      ADHelper ad_helper;'
p41080
aS'      double             psi;'
p41081
aS'      Vector<double>     Dpsi;'
p41082
aS'      FullMatrix<double> D2psi;'
p41083
aS'    };'
p41084
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41085
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::'
p41086
aS'      Magnetoelastic_Constitutive_Law_AD('
p41087
aS'        const ConstitutiveParameters &constitutive_parameters)'
p41088
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p41089
aS'          constitutive_parameters)'
p41090
aS'      , H_components(0)'
p41091
aS'      , C_components(Tensor<1, dim>::n_independent_components)'
p41092
aS'      , ad_helper(Tensor<1, dim>::n_independent_components +'
p41093
aS'                  SymmetricTensor<2, dim>::n_independent_components)'
p41094
aS'      , psi(0.0)'
p41095
aS'      , Dpsi(ad_helper.n_independent_variables())'
p41096
aS'      , D2psi(ad_helper.n_independent_variables(),'
p41097
aS'              ad_helper.n_independent_variables())'
p41098
aS'    {}'
p41099
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41100
aS'    void'
p41101
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::update_internal_data('
p41102
aS'      const SymmetricTensor<2, dim> &C,'
p41103
aS'      const Tensor<1, dim> &         H,'
p41104
aS'      const DiscreteTime &)'
p41105
aS'    {'
p41106
aS'      Assert(determinant(C) > 0, ExcInternalError());'
p41107
aS'      ad_helper.reset();'
p41108
aS'      ad_helper.register_independent_variable(H, H_components);'
p41109
aS'      ad_helper.register_independent_variable(C, C_components);'
p41110
aS'      const Tensor<1, dim, ADNumberType> H_ad ='
p41111
aS'        ad_helper.get_sensitive_variables(H_components);'
p41112
aS'      const SymmetricTensor<2, dim, ADNumberType> C_ad ='
p41113
aS'        ad_helper.get_sensitive_variables(C_components);'
p41114
aS'      const ADNumberType det_F_ad = std::sqrt(determinant(C_ad));'
p41115
aS'      const SymmetricTensor<2, dim, ADNumberType> C_inv_ad = invert(C_ad);'
p41116
aS'      AssertThrow(det_F_ad > ADNumberType(0.0),'
p41117
aS'                  ExcMessage("Volumetric Jacobian must be positive."));'
p41118
aS'      const ADNumberType f_mu_e_ad ='
p41119
aS'        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *'
p41120
aS'                std::tanh((2.0 * H_ad * H_ad) /'
p41121
aS'      const ADNumberType psi_ad ='
p41122
aS'        0.5 * this->get_mu_e() * f_mu_e_ad *'
p41123
aS'        + this->get_lambda_e() * std::log(det_F_ad) * std::log(det_F_ad) //'
p41124
aS'        - 0.5 * this->get_mu_0() * this->get_mu_r() * det_F_ad *'
p41125
aS'      ad_helper.register_dependent_variable(psi_ad);'
p41126
aS'      psi = ad_helper.compute_value();'
p41127
aS'      ad_helper.compute_gradient(Dpsi);'
p41128
aS'      ad_helper.compute_hessian(D2psi);'
p41129
aS'    }'
p41130
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41131
aS'    double Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_psi() const'
p41132
aS'    {'
p41133
aS'      return psi;'
p41134
aS'    }'
p41135
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41136
aS'    Tensor<1, dim>'
p41137
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_B() const'
p41138
aS'    {'
p41139
aS'      const Tensor<1, dim> dpsi_dH ='
p41140
aS'        ad_helper.extract_gradient_component(Dpsi, H_components);'
p41141
aS'      return -dpsi_dH;'
p41142
aS'    }'
p41143
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41144
aS'    SymmetricTensor<2, dim>'
p41145
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_S() const'
p41146
aS'    {'
p41147
aS'      const SymmetricTensor<2, dim> dpsi_dC ='
p41148
aS'        ad_helper.extract_gradient_component(Dpsi, C_components);'
p41149
aS'      return 2.0 * dpsi_dC;'
p41150
aS'    }'
p41151
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41152
aS'    SymmetricTensor<2, dim>'
p41153
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_DD() const'
p41154
aS'    {'
p41155
aS'      const Tensor<2, dim> dpsi_dH_dH ='
p41156
aS'        ad_helper.extract_hessian_component(D2psi, H_components, H_components);'
p41157
aS'      return -symmetrize(dpsi_dH_dH);'
p41158
aS'    }'
p41159
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41160
aS'    Tensor<3, dim>'
p41161
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_PP() const'
p41162
aS'    {'
p41163
aS'      const Tensor<3, dim> dpsi_dC_dH ='
p41164
aS'        ad_helper.extract_hessian_component(D2psi, C_components, H_components);'
p41165
aS'      return -2.0 * dpsi_dC_dH;'
p41166
aS'    }'
p41167
aS'    template <int dim, Differentiation::AD::NumberTypes ADTypeCode>'
p41168
aS'    SymmetricTensor<4, dim>'
p41169
aS'    Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode>::get_HH() const'
p41170
aS'    {'
p41171
aS'      const SymmetricTensor<4, dim> dpsi_dC_dC ='
p41172
aS'        ad_helper.extract_hessian_component(D2psi, C_components, C_components);'
p41173
aS'      return 4.0 * dpsi_dC_dC;'
p41174
aS'    }'
p41175
aS'    template <int dim>'
p41176
aS'    class Magnetoviscoelastic_Constitutive_Law_SD final'
p41177
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p41178
aS'    {'
p41179
aS'    public:'
p41180
aS'      Magnetoviscoelastic_Constitutive_Law_SD('
p41181
aS'        const ConstitutiveParameters &               constitutive_parameters,'
p41182
aS'        const Differentiation::SD::OptimizerType     optimizer_type,'
p41183
aS'        const Differentiation::SD::OptimizationFlags optimization_flags);'
p41184
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p41185
aS'                                        const Tensor<1, dim> &         H,'
p41186
aS'                                        const DiscreteTime &time) override;'
p41187
aS'      virtual double get_psi() const override;'
p41188
aS'      virtual Tensor<1, dim> get_B() const override;'
p41189
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p41190
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p41191
aS'      virtual Tensor<3, dim> get_PP() const override;'
p41192
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p41193
aS'      virtual void update_end_of_timestep() override;'
p41194
aS'    private:'
p41195
aS'      SymmetricTensor<2, dim> Q_t;'
p41196
aS'      SymmetricTensor<2, dim> Q_t1;'
p41197
aS'      const Differentiation::SD::Expression mu_e_sd;'
p41198
aS'      const Differentiation::SD::Expression mu_e_inf_sd;'
p41199
aS'      const Differentiation::SD::Expression mu_e_h_sat_sd;'
p41200
aS'      const Differentiation::SD::Expression lambda_e_sd;'
p41201
aS'      const Differentiation::SD::Expression mu_v_sd;'
p41202
aS'      const Differentiation::SD::Expression mu_v_inf_sd;'
p41203
aS'      const Differentiation::SD::Expression mu_v_h_sat_sd;'
p41204
aS'      const Differentiation::SD::Expression tau_v_sd;'
p41205
aS'      const Differentiation::SD::Expression delta_t_sd;'
p41206
aS'      const Differentiation::SD::Expression mu_r_sd;'
p41207
aS'      const Tensor<1, dim, Differentiation::SD::Expression>          H_sd;'
p41208
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_sd;'
p41209
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t_sd;'
p41210
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> Q_t1_sd;'
p41211
aS'      Differentiation::SD::Expression                          psi_sd;'
p41212
aS'      Tensor<1, dim, Differentiation::SD::Expression>          B_sd;'
p41213
aS'      SymmetricTensor<2, dim, Differentiation::SD::Expression> S_sd;'
p41214
aS'      SymmetricTensor<2, dim, Differentiation::SD::Expression> BB_sd;'
p41215
aS'      Tensor<3, dim, Differentiation::SD::Expression>          PP_sd;'
p41216
aS'      SymmetricTensor<4, dim, Differentiation::SD::Expression> HH_sd;'
p41217
aS'      Differentiation::SD::BatchOptimizer<double> optimizer;'
p41218
aS'      Differentiation::SD::types::substitution_map'
p41219
aS'      make_substitution_map(const SymmetricTensor<2, dim> &C,'
p41220
aS'                            const Tensor<1, dim> &         H,'
p41221
aS'                            const double                   delta_t) const;'
p41222
aS'      void initialize_optimizer();'
p41223
aS'    };'
p41224
aS'    template <int dim>'
p41225
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::'
p41226
aS'      Magnetoviscoelastic_Constitutive_Law_SD('
p41227
aS'        const ConstitutiveParameters &               constitutive_parameters,'
p41228
aS'        const Differentiation::SD::OptimizerType     optimizer_type,'
p41229
aS'        const Differentiation::SD::OptimizationFlags optimization_flags)'
p41230
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p41231
aS'          constitutive_parameters)'
p41232
aS'      , Q_t(Physics::Elasticity::StandardTensors<dim>::I)'
p41233
aS'      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)'
p41234
aS'      , mu_e_sd("mu_e")'
p41235
aS'      , mu_e_inf_sd("mu_e_inf")'
p41236
aS'      , mu_e_h_sat_sd("mu_e_h_sat")'
p41237
aS'      , lambda_e_sd("lambda_e")'
p41238
aS'      , mu_v_sd("mu_v")'
p41239
aS'      , mu_v_inf_sd("mu_v_inf")'
p41240
aS'      , mu_v_h_sat_sd("mu_v_h_sat")'
p41241
aS'      , tau_v_sd("tau_v")'
p41242
aS'      , delta_t_sd("delta_t")'
p41243
aS'      , mu_r_sd("mu_r")'
p41244
aS'      , H_sd(Differentiation::SD::make_vector_of_symbols<dim>("H"))'
p41245
aS'      , C_sd(Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("C"))'
p41246
aS'      , Q_t_sd('
p41247
aS'          Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("Q_t"))'
p41248
aS'      , Q_t1_sd('
p41249
aS'          Differentiation::SD::make_symmetric_tensor_of_symbols<2, dim>("Q_t1"))'
p41250
aS'      , optimizer(optimizer_type, optimization_flags)'
p41251
aS'    {'
p41252
aS'      initialize_optimizer();'
p41253
aS'    }'
p41254
aS'    template <int dim>'
p41255
aS'    Differentiation::SD::types::substitution_map'
p41256
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::make_substitution_map('
p41257
aS'      const SymmetricTensor<2, dim> &C,'
p41258
aS'      const Tensor<1, dim> &         H,'
p41259
aS'      const double                   delta_t) const'
p41260
aS'    {'
p41261
aS'      return Differentiation::SD::make_substitution_map('
p41262
aS'        std::make_pair(mu_e_sd, this->get_mu_e()),'
p41263
aS'        std::make_pair(mu_e_inf_sd, this->get_mu_e_inf()),'
p41264
aS'        std::make_pair(mu_e_h_sat_sd, this->get_mu_e_h_sat()),'
p41265
aS'        std::make_pair(lambda_e_sd, this->get_lambda_e()),'
p41266
aS'        std::make_pair(mu_v_sd, this->get_mu_v()),'
p41267
aS'        std::make_pair(mu_v_inf_sd, this->get_mu_v_inf()),'
p41268
aS'        std::make_pair(mu_v_h_sat_sd, this->get_mu_v_h_sat()),'
p41269
aS'        std::make_pair(tau_v_sd, this->get_tau_v()),'
p41270
aS'        std::make_pair(delta_t_sd, delta_t),'
p41271
aS'        std::make_pair(mu_r_sd, this->get_mu_r()),'
p41272
aS'        std::make_pair(H_sd, H),'
p41273
aS'        std::make_pair(C_sd, C),'
p41274
aS'        std::make_pair(Q_t_sd, Q_t),'
p41275
aS'        std::make_pair(Q_t1_sd, Q_t1));'
p41276
aS'    }'
p41277
aS'    template <int dim>'
p41278
aS'    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::initialize_optimizer()'
p41279
aS'    {'
p41280
aS'      const Differentiation::SD::Expression det_F_sd ='
p41281
aS'        std::sqrt(determinant(C_sd));'
p41282
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression> C_inv_sd ='
p41283
aS'        invert(C_sd);'
p41284
aS'      const Differentiation::SD::Expression f_mu_e_sd ='
p41285
aS'        1.0 +'
p41286
aS'          std::tanh((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));'
p41287
aS'      const Differentiation::SD::Expression psi_ME_sd ='
p41288
aS'        0.5 * mu_e_sd * f_mu_e_sd *'
p41289
aS'        lambda_e_sd * std::log(det_F_sd) * std::log(det_F_sd) -'
p41290
aS'        0.5 * this->get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);'
p41291
aS'      const Differentiation::SD::Expression f_mu_v_sd ='
p41292
aS'        1.0 +'
p41293
aS'          std::tanh((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));'
p41294
aS'      const Differentiation::SD::Expression psi_MVE_sd ='
p41295
aS'        0.5 * mu_v_sd * f_mu_v_sd *'
p41296
aS'         std::log(determinant(Q_t_sd)));'
p41297
aS'      psi_sd = psi_ME_sd + psi_MVE_sd;'
p41298
aS'      B_sd = -Differentiation::SD::differentiate(psi_sd, H_sd);'
p41299
aS'      S_sd = 2.0 * Differentiation::SD::differentiate(psi_sd, C_sd);'
p41300
aS'      const SymmetricTensor<2, dim, Differentiation::SD::Expression>'
p41301
aS'        Q_t_sd_explicit ='
p41302
aS'      const Differentiation::SD::types::substitution_map'
p41303
aS'        substitution_map_explicit = Differentiation::SD::make_substitution_map('
p41304
aS'          std::make_pair(Q_t_sd, Q_t_sd_explicit));'
p41305
aS'      BB_sd = symmetrize(Differentiation::SD::differentiate('
p41306
aS'        Differentiation::SD::substitute(B_sd, substitution_map_explicit),'
p41307
aS'        H_sd));'
p41308
aS'      PP_sd = -Differentiation::SD::differentiate('
p41309
aS'        Differentiation::SD::substitute(S_sd, substitution_map_explicit), H_sd);'
p41310
aS'      HH_sd ='
p41311
aS'        2.0 *'
p41312
aS'        Differentiation::SD::differentiate('
p41313
aS'          Differentiation::SD::substitute(S_sd, substitution_map_explicit),'
p41314
aS'          C_sd);'
p41315
aS'      optimizer.register_symbols('
p41316
aS'        Differentiation::SD::Utilities::extract_symbols('
p41317
aS'          make_substitution_map({}, {}, 0)));'
p41318
aS'      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);'
p41319
aS'      optimizer.optimize();'
p41320
aS'    }'
p41321
aS'    template <int dim>'
p41322
aS'    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_internal_data('
p41323
aS'      const SymmetricTensor<2, dim> &C,'
p41324
aS'      const Tensor<1, dim> &         H,'
p41325
aS'      const DiscreteTime &           time)'
p41326
aS'    {'
p41327
aS'      const double delta_t = this->get_delta_t(time);'
p41328
aS'      const double                  det_F = std::sqrt(determinant(C));'
p41329
aS'      const SymmetricTensor<2, dim> C_inv = invert(C);'
p41330
aS'      AssertThrow(det_F > 0.0,'
p41331
aS'                  ExcMessage("Volumetric Jacobian must be positive."));'
p41332
aS'      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *'
p41333
aS'                      C_inv);'
p41334
aS'      const auto substitution_map = make_substitution_map(C, H, delta_t);'
p41335
aS'      optimizer.substitute(substitution_map);'
p41336
aS'    }'
p41337
aS'    template <int dim>'
p41338
aS'    double Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_psi() const'
p41339
aS'    {'
p41340
aS'      return optimizer.evaluate(psi_sd);'
p41341
aS'    }'
p41342
aS'    template <int dim>'
p41343
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_B() const'
p41344
aS'    {'
p41345
aS'      return optimizer.evaluate(B_sd);'
p41346
aS'    }'
p41347
aS'    template <int dim>'
p41348
aS'    SymmetricTensor<2, dim>'
p41349
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_S() const'
p41350
aS'    {'
p41351
aS'      return optimizer.evaluate(S_sd);'
p41352
aS'    }'
p41353
aS'    template <int dim>'
p41354
aS'    SymmetricTensor<2, dim>'
p41355
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_DD() const'
p41356
aS'    {'
p41357
aS'      return optimizer.evaluate(BB_sd);'
p41358
aS'    }'
p41359
aS'    template <int dim>'
p41360
aS'    Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_PP() const'
p41361
aS'    {'
p41362
aS'      return optimizer.evaluate(PP_sd);'
p41363
aS'    }'
p41364
aS'    template <int dim>'
p41365
aS'    SymmetricTensor<4, dim>'
p41366
aS'    Magnetoviscoelastic_Constitutive_Law_SD<dim>::get_HH() const'
p41367
aS'    {'
p41368
aS'      return optimizer.evaluate(HH_sd);'
p41369
aS'    }'
p41370
aS'    template <int dim>'
p41371
aS'    void Magnetoviscoelastic_Constitutive_Law_SD<dim>::update_end_of_timestep()'
p41372
aS'    {'
p41373
aS'      Q_t1 = Q_t;'
p41374
aS'    }'
p41375
aS'    template <int dim>'
p41376
aS'    class Magnetoelastic_Constitutive_Law final'
p41377
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p41378
aS'    {'
p41379
aS'    public:'
p41380
aS'      Magnetoelastic_Constitutive_Law('
p41381
aS'        const ConstitutiveParameters &constitutive_parameters);'
p41382
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p41383
aS'                                        const Tensor<1, dim> &         H,'
p41384
aS'                                        const DiscreteTime &) override;'
p41385
aS'      virtual double get_psi() const override;'
p41386
aS'      virtual Tensor<1, dim> get_B() const override;'
p41387
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p41388
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p41389
aS'      virtual Tensor<3, dim> get_PP() const override;'
p41390
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p41391
aS'    private:'
p41392
aS'      double                  psi;'
p41393
aS'      Tensor<1, dim>          B;'
p41394
aS'      SymmetricTensor<2, dim> S;'
p41395
aS'      SymmetricTensor<2, dim> BB;'
p41396
aS'      Tensor<3, dim>          PP;'
p41397
aS'      SymmetricTensor<4, dim> HH;'
p41398
aS'    };'
p41399
aS'    template <int dim>'
p41400
aS'    Magnetoelastic_Constitutive_Law<dim>::Magnetoelastic_Constitutive_Law('
p41401
aS'      const ConstitutiveParameters &constitutive_parameters)'
p41402
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p41403
aS'          constitutive_parameters)'
p41404
aS'      , psi(0.0)'
p41405
aS'    {}'
p41406
aS'    template <int dim>'
p41407
aS'    void Magnetoelastic_Constitutive_Law<dim>::update_internal_data('
p41408
aS'      const SymmetricTensor<2, dim> &C,'
p41409
aS'      const Tensor<1, dim> &         H,'
p41410
aS'      const DiscreteTime &)'
p41411
aS'    {'
p41412
aS'      const double                  det_F = std::sqrt(determinant(C));'
p41413
aS'      const SymmetricTensor<2, dim> C_inv = invert(C);'
p41414
aS'      AssertThrow(det_F > 0.0,'
p41415
aS'                  ExcMessage("Volumetric Jacobian must be positive."));'
p41416
aS'      const double two_h_dot_h_div_h_sat_squ ='
p41417
aS'      const double tanh_two_h_dot_h_div_h_sat_squ ='
p41418
aS'        std::tanh(two_h_dot_h_div_h_sat_squ);'
p41419
aS'      const double f_mu_e ='
p41420
aS'        1.0 + (this->get_mu_e_inf() / this->get_mu_e() - 1.0) *'
p41421
aS'                tanh_two_h_dot_h_div_h_sat_squ;'
p41422
aS'      const double dtanh_two_h_dot_h_div_h_sat_squ ='
p41423
aS'        std::pow(1.0 / std::cosh(two_h_dot_h_div_h_sat_squ), 2.0);'
p41424
aS'      const Tensor<1, dim> dtwo_h_dot_h_div_h_sat_squ_dH ='
p41425
aS'        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) * H;'
p41426
aS'      const Tensor<1, dim> df_mu_e_dH ='
p41427
aS'      const double d2tanh_two_h_dot_h_div_h_sat_squ ='
p41428
aS'        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;'
p41429
aS'      const SymmetricTensor<2, dim> d2two_h_dot_h_div_h_sat_squ_dH_dH ='
p41430
aS'        2.0 * 2.0 / (this->get_mu_e_h_sat() * this->get_mu_e_h_sat()) *'
p41431
aS'        Physics::Elasticity::StandardTensors<dim>::I;'
p41432
aS'      const SymmetricTensor<2, dim> d2f_mu_e_dH_dH ='
p41433
aS'           symmetrize(outer_product(dtwo_h_dot_h_div_h_sat_squ_dH,'
p41434
aS'                                    dtwo_h_dot_h_div_h_sat_squ_dH)) +'
p41435
aS'         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);'
p41436
aS'      const double         log_det_F         = std::log(det_F);'
p41437
aS'      const double         tr_C              = trace(C);'
p41438
aS'      const Tensor<1, dim> C_inv_dot_H       = C_inv * H;'
p41439
aS'      const double         H_dot_C_inv_dot_H = H * C_inv_dot_H;'
p41440
aS'      const SymmetricTensor<2, dim> d_tr_C_dC ='
p41441
aS'        Physics::Elasticity::StandardTensors<dim>::I;'
p41442
aS'      const SymmetricTensor<2, dim> ddet_F_dC     = 0.5 * det_F * C_inv;'
p41443
aS'      const SymmetricTensor<2, dim> dlog_det_F_dC = 0.5 * C_inv;'
p41444
aS'      const Tensor<1, dim> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;'
p41445
aS'      SymmetricTensor<4, dim> dC_inv_dC;'
p41446
aS'      for (unsigned int A = 0; A < dim; ++A)'
p41447
aS'        for (unsigned int B = A; B < dim; ++B)'
p41448
aS'          for (unsigned int C = 0; C < dim; ++C)'
p41449
aS'            for (unsigned int D = C; D < dim; ++D)'
p41450
aS'              dC_inv_dC[A][B][C][D] -=               //'
p41451
aS'                0.5 * (C_inv[A][C] * C_inv[B][D]     //'
p41452
aS'                       + C_inv[A][D] * C_inv[B][C]); //'
p41453
aS'      const SymmetricTensor<2, dim> dH_dot_C_inv_dot_H_dC ='
p41454
aS'        -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H));'
p41455
aS'      const SymmetricTensor<4, dim> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;'
p41456
aS'      const SymmetricTensor<4, dim> d2det_F_dC_dC ='
p41457
aS'        0.5 * (outer_product(C_inv, ddet_F_dC) + det_F * dC_inv_dC);'
p41458
aS'      const SymmetricTensor<2, dim> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;'
p41459
aS'      Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;'
p41460
aS'      for (unsigned int A = 0; A < dim; ++A)'
p41461
aS'        for (unsigned int B = 0; B < dim; ++B)'
p41462
aS'          for (unsigned int C = 0; C < dim; ++C)'
p41463
aS'            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -='
p41464
aS'              C_inv[A][C] * C_inv_dot_H[B] + //'
p41465
aS'              C_inv_dot_H[A] * C_inv[B][C];  //'
p41466
aS'      SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;'
p41467
aS'      for (unsigned int A = 0; A < dim; ++A)'
p41468
aS'        for (unsigned int B = A; B < dim; ++B)'
p41469
aS'          for (unsigned int C = 0; C < dim; ++C)'
p41470
aS'            for (unsigned int D = C; D < dim; ++D)'
p41471
aS'              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +='
p41472
aS'                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +'
p41473
aS'                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +'
p41474
aS'                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +'
p41475
aS'                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);'
p41476
aS'      psi ='
p41477
aS'        this->get_lambda_e() * (std::log(det_F) * std::log(det_F)) -'
p41478
aS'      B = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *'
p41479
aS'            df_mu_e_dH //'
p41480
aS'          + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p41481
aS'              dH_dot_C_inv_dot_H_dH; //'
p41482
aS'      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                        //'
p41483
aS'          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) //'
p41484
aS'          - 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *            //'
p41485
aS'               + det_F * dH_dot_C_inv_dot_H_dC);                           //'
p41486
aS'      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * //'
p41487
aS'             d2f_mu_e_dH_dH                                             //'
p41488
aS'           + 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p41489
aS'               d2H_dot_C_inv_dot_H_dH_dH; //'
p41490
aS'      PP = -2.0 * (0.5 * this->get_mu_e()) *                                  //'
p41491
aS'             outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   //'
p41492
aS'                           df_mu_e_dH)                                        //'
p41493
aS'           +                                                                  //'
p41494
aS'           2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                //'
p41495
aS'              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           //'
p41496
aS'      HH ='
p41497
aS'        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) //'
p41498
aS'        + 4.0 * this->get_lambda_e() *                                       //'
p41499
aS'             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          //'
p41500
aS'        - 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *                //'
p41501
aS'             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               //'
p41502
aS'             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               //'
p41503
aS'             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           //'
p41504
aS'    }'
p41505
aS'    template <int dim>'
p41506
aS'    double Magnetoelastic_Constitutive_Law<dim>::get_psi() const'
p41507
aS'    {'
p41508
aS'      return psi;'
p41509
aS'    }'
p41510
aS'    template <int dim>'
p41511
aS'    Tensor<1, dim> Magnetoelastic_Constitutive_Law<dim>::get_B() const'
p41512
aS'    {'
p41513
aS'      return B;'
p41514
aS'    }'
p41515
aS'    template <int dim>'
p41516
aS'    SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_S() const'
p41517
aS'    {'
p41518
aS'      return S;'
p41519
aS'    }'
p41520
aS'    template <int dim>'
p41521
aS'    SymmetricTensor<2, dim> Magnetoelastic_Constitutive_Law<dim>::get_DD() const'
p41522
aS'    {'
p41523
aS'      return BB;'
p41524
aS'    }'
p41525
aS'    template <int dim>'
p41526
aS'    Tensor<3, dim> Magnetoelastic_Constitutive_Law<dim>::get_PP() const'
p41527
aS'    {'
p41528
aS'      return PP;'
p41529
aS'    }'
p41530
aS'    template <int dim>'
p41531
aS'    SymmetricTensor<4, dim> Magnetoelastic_Constitutive_Law<dim>::get_HH() const'
p41532
aS'    {'
p41533
aS'      return HH;'
p41534
aS'    }'
p41535
aS'    template <int dim>'
p41536
aS'    class Magnetoviscoelastic_Constitutive_Law final'
p41537
aS'      : public Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p41538
aS'    {'
p41539
aS'    public:'
p41540
aS'      Magnetoviscoelastic_Constitutive_Law('
p41541
aS'        const ConstitutiveParameters &constitutive_parameters);'
p41542
aS'      virtual void update_internal_data(const SymmetricTensor<2, dim> &C,'
p41543
aS'                                        const Tensor<1, dim> &         H,'
p41544
aS'                                        const DiscreteTime &time) override;'
p41545
aS'      virtual double get_psi() const override;'
p41546
aS'      virtual Tensor<1, dim> get_B() const override;'
p41547
aS'      virtual SymmetricTensor<2, dim> get_S() const override;'
p41548
aS'      virtual SymmetricTensor<2, dim> get_DD() const override;'
p41549
aS'      virtual Tensor<3, dim> get_PP() const override;'
p41550
aS'      virtual SymmetricTensor<4, dim> get_HH() const override;'
p41551
aS'      virtual void update_end_of_timestep() override;'
p41552
aS'    private:'
p41553
aS'      SymmetricTensor<2, dim> Q_t;'
p41554
aS'      SymmetricTensor<2, dim> Q_t1;'
p41555
aS'      double                  psi;'
p41556
aS'      Tensor<1, dim>          B;'
p41557
aS'      SymmetricTensor<2, dim> S;'
p41558
aS'      SymmetricTensor<2, dim> BB;'
p41559
aS'      Tensor<3, dim>          PP;'
p41560
aS'      SymmetricTensor<4, dim> HH;'
p41561
aS'      mutable GeneralDataStorage cache;'
p41562
aS'      void set_primary_variables(const SymmetricTensor<2, dim> &C,'
p41563
aS'                                 const Tensor<1, dim> &         H) const;'
p41564
aS'      void update_internal_variable(const DiscreteTime &time);'
p41565
aS'      const Tensor<1, dim> &get_H() const;'
p41566
aS'      const SymmetricTensor<2, dim> &get_C() const;'
p41567
aS'      double get_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p41568
aS'      double get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p41569
aS'      double get_f_mu(const double mu,'
p41570
aS'                      const double mu_inf,'
p41571
aS'                      const double mu_h_sat) const;'
p41572
aS'      double get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p41573
aS'      Tensor<1, dim>'
p41574
aS'      get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const;'
p41575
aS'      Tensor<1, dim> get_df_mu_dH(const double mu,'
p41576
aS'                                  const double mu_inf,'
p41577
aS'                                  const double mu_h_sat) const;'
p41578
aS'      double get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const;'
p41579
aS'      SymmetricTensor<2, dim>'
p41580
aS'      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const;'
p41581
aS'      SymmetricTensor<2, dim> get_d2f_mu_dH_dH(const double mu,'
p41582
aS'                                               const double mu_inf,'
p41583
aS'                                               const double mu_h_sat) const;'
p41584
aS'      const double &get_det_F() const;'
p41585
aS'      const SymmetricTensor<2, dim> &get_C_inv() const;'
p41586
aS'      const double &get_log_det_F() const;'
p41587
aS'      const double &get_trace_C() const;'
p41588
aS'      const Tensor<1, dim> &get_C_inv_dot_H() const;'
p41589
aS'      const double &get_H_dot_C_inv_dot_H() const;'
p41590
aS'      const SymmetricTensor<4, dim> &get_dC_inv_dC() const;'
p41591
aS'      const SymmetricTensor<2, dim> &get_d_tr_C_dC() const;'
p41592
aS'      const SymmetricTensor<2, dim> &get_ddet_F_dC() const;'
p41593
aS'      const SymmetricTensor<2, dim> &get_dlog_det_F_dC() const;'
p41594
aS'      const Tensor<1, dim> &get_dH_dot_C_inv_dot_H_dH() const;'
p41595
aS'      const SymmetricTensor<2, dim> &get_dH_dot_C_inv_dot_H_dC() const;'
p41596
aS'      const SymmetricTensor<4, dim> &'
p41597
aS'      get_dQ_t_dC(const DiscreteTime &time) const;'
p41598
aS'      const SymmetricTensor<4, dim> &get_d2log_det_F_dC_dC() const;'
p41599
aS'      const SymmetricTensor<4, dim> &get_d2det_F_dC_dC() const;'
p41600
aS'      const SymmetricTensor<2, dim> &get_d2H_dot_C_inv_dot_H_dH_dH() const;'
p41601
aS'      const Tensor<3, dim> &get_d2H_dot_C_inv_dot_H_dC_dH() const;'
p41602
aS'      const SymmetricTensor<4, dim> &get_d2H_dot_C_inv_dot_H_dC_dC() const;'
p41603
aS'    };'
p41604
aS'    template <int dim>'
p41605
aS'    Magnetoviscoelastic_Constitutive_Law<'
p41606
aS'      dim>::Magnetoviscoelastic_Constitutive_Law(const ConstitutiveParameters'
p41607
aS'                                                   &constitutive_parameters)'
p41608
aS'      : Coupled_Magnetomechanical_Constitutive_Law_Base<dim>('
p41609
aS'          constitutive_parameters)'
p41610
aS'      , Q_t(Physics::Elasticity::StandardTensors<dim>::I)'
p41611
aS'      , Q_t1(Physics::Elasticity::StandardTensors<dim>::I)'
p41612
aS'      , psi(0.0)'
p41613
aS'    {}'
p41614
aS'    template <int dim>'
p41615
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_data('
p41616
aS'      const SymmetricTensor<2, dim> &C,'
p41617
aS'      const Tensor<1, dim> &         H,'
p41618
aS'      const DiscreteTime &           time)'
p41619
aS'    {'
p41620
aS'      set_primary_variables(C, H);'
p41621
aS'      update_internal_variable(time);'
p41622
aS'      const double f_mu_e = get_f_mu(this->get_mu_e(),'
p41623
aS'                                     this->get_mu_e_inf(),'
p41624
aS'                                     this->get_mu_e_h_sat());'
p41625
aS'      const double f_mu_v = get_f_mu(this->get_mu_v(),'
p41626
aS'                                     this->get_mu_v_inf(),'
p41627
aS'                                     this->get_mu_v_h_sat());'
p41628
aS'      const Tensor<1, dim> df_mu_e_dH = get_df_mu_dH(this->get_mu_e(),'
p41629
aS'                                                     this->get_mu_e_inf(),'
p41630
aS'                                                     this->get_mu_e_h_sat());'
p41631
aS'      const Tensor<1, dim> df_mu_v_dH = get_df_mu_dH(this->get_mu_v(),'
p41632
aS'                                                     this->get_mu_v_inf(),'
p41633
aS'                                                     this->get_mu_v_h_sat());'
p41634
aS'      const SymmetricTensor<2, dim> d2f_mu_e_dH_dH ='
p41635
aS'        get_d2f_mu_dH_dH(this->get_mu_e(),'
p41636
aS'                         this->get_mu_e_inf(),'
p41637
aS'                         this->get_mu_e_h_sat());'
p41638
aS'      const SymmetricTensor<2, dim> d2f_mu_v_dH_dH ='
p41639
aS'        get_d2f_mu_dH_dH(this->get_mu_v(),'
p41640
aS'                         this->get_mu_v_inf(),'
p41641
aS'                         this->get_mu_v_h_sat());'
p41642
aS'      const double &                 det_F = get_det_F();'
p41643
aS'      const SymmetricTensor<2, dim> &C_inv = get_C_inv();'
p41644
aS'      const double &log_det_F         = get_log_det_F();'
p41645
aS'      const double &tr_C              = get_trace_C();'
p41646
aS'      const double &H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();'
p41647
aS'      const SymmetricTensor<2, dim> &d_tr_C_dC     = get_d_tr_C_dC();'
p41648
aS'      const SymmetricTensor<2, dim> &ddet_F_dC     = get_ddet_F_dC();'
p41649
aS'      const SymmetricTensor<2, dim> &dlog_det_F_dC = get_dlog_det_F_dC();'
p41650
aS'      const SymmetricTensor<4, dim> &dQ_t_dC = get_dQ_t_dC(time);'
p41651
aS'      const Tensor<1, dim> &dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();'
p41652
aS'      const SymmetricTensor<2, dim> &dH_dot_C_inv_dot_H_dC ='
p41653
aS'        get_dH_dot_C_inv_dot_H_dC();'
p41654
aS'      const SymmetricTensor<4, dim> &d2log_det_F_dC_dC ='
p41655
aS'        get_d2log_det_F_dC_dC();'
p41656
aS'      const SymmetricTensor<4, dim> &d2det_F_dC_dC = get_d2det_F_dC_dC();'
p41657
aS'      const SymmetricTensor<2, dim> &d2H_dot_C_inv_dot_H_dH_dH ='
p41658
aS'        get_d2H_dot_C_inv_dot_H_dH_dH();'
p41659
aS'      const Tensor<3, dim> &d2H_dot_C_inv_dot_H_dC_dH ='
p41660
aS'        get_d2H_dot_C_inv_dot_H_dC_dH();'
p41661
aS'      const SymmetricTensor<4, dim> &d2H_dot_C_inv_dot_H_dC_dC ='
p41662
aS'        get_d2H_dot_C_inv_dot_H_dC_dC();'
p41663
aS'      psi = (0.5 * this->get_mu_e() * f_mu_e) *'
p41664
aS'            this->get_lambda_e() * (std::log(det_F) * std::log(det_F));'
p41665
aS'      psi += (0.5 * this->get_mu_v() * f_mu_v) *'
p41666
aS'              std::log(determinant(Q_t)));'
p41667
aS'      psi -='
p41668
aS'      B ='
p41669
aS'        -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;'
p41670
aS'      B -= (0.5 * this->get_mu_v()) *'
p41671
aS'            std::log(determinant(Q_t))) *'
p41672
aS'           df_mu_v_dH;'
p41673
aS'      B += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p41674
aS'           dH_dot_C_inv_dot_H_dH;'
p41675
aS'      S = 2.0 * (0.5 * this->get_mu_e() * f_mu_e) *                         //'
p41676
aS'          + 2.0 * this->get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); //'
p41677
aS'      S += 2.0 * (0.5 * this->get_mu_v() * f_mu_v) *'
p41678
aS'            std::pow(det_F, -2.0 / dim) * Q_t);                // dC/dC = II'
p41679
aS'      S -= 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * //'
p41680
aS'            + det_F * dH_dot_C_inv_dot_H_dC);                  //'
p41681
aS'      BB = -(0.5 * this->get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *'
p41682
aS'           d2f_mu_e_dH_dH;'
p41683
aS'      BB -= (0.5 * this->get_mu_v()) *'
p41684
aS'             std::log(determinant(Q_t))) *'
p41685
aS'            d2f_mu_v_dH_dH;'
p41686
aS'      BB += 0.5 * this->get_mu_0() * this->get_mu_r() * det_F *'
p41687
aS'            d2H_dot_C_inv_dot_H_dH_dH;'
p41688
aS'      PP = -2.0 * (0.5 * this->get_mu_e()) *'
p41689
aS'           outer_product(Tensor<2, dim>(d_tr_C_dC - 2.0 * dlog_det_F_dC),'
p41690
aS'                         df_mu_e_dH);'
p41691
aS'      PP -= 2.0 * (0.5 * this->get_mu_v()) *'
p41692
aS'            outer_product(Tensor<2, dim>((Q_t * C) *'
p41693
aS'                                            std::pow(det_F, -2.0 / dim - 1.0) *'
p41694
aS'                                            ddet_F_dC) +'
p41695
aS'                                         std::pow(det_F, -2.0 / dim) * Q_t),'
p41696
aS'                          df_mu_v_dH);'
p41697
aS'      PP += 2.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) *'
p41698
aS'             det_F * d2H_dot_C_inv_dot_H_dC_dH);'
p41699
aS'      HH ='
p41700
aS'        4.0 * (0.5 * this->get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) //'
p41701
aS'        + 4.0 * this->get_lambda_e() *                                       //'
p41702
aS'             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         //'
p41703
aS'      HH += 4.0 * (0.5 * this->get_mu_v() * f_mu_v) *'
p41704
aS'                             ddet_F_dC,'
p41705
aS'                           C * dQ_t_dC + Q_t) +'
p41706
aS'                                std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +'
p41707
aS'                 d2det_F_dC_dC)) +'
p41708
aS'             outer_product(Q_t,'
p41709
aS'                             ddet_F_dC) +'
p41710
aS'             std::pow(det_F, -2.0 / dim) * dQ_t_dC);'
p41711
aS'      HH -= 4.0 * (0.5 * this->get_mu_0() * this->get_mu_r()) * //'
p41712
aS'             + outer_product(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  //'
p41713
aS'             + outer_product(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  //'
p41714
aS'             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              //'
p41715
aS'      cache.reset();'
p41716
aS'    }'
p41717
aS'    template <int dim>'
p41718
aS'    double Magnetoviscoelastic_Constitutive_Law<dim>::get_psi() const'
p41719
aS'    {'
p41720
aS'      return psi;'
p41721
aS'    }'
p41722
aS'    template <int dim>'
p41723
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_B() const'
p41724
aS'    {'
p41725
aS'      return B;'
p41726
aS'    }'
p41727
aS'    template <int dim>'
p41728
aS'    SymmetricTensor<2, dim>'
p41729
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_S() const'
p41730
aS'    {'
p41731
aS'      return S;'
p41732
aS'    }'
p41733
aS'    template <int dim>'
p41734
aS'    SymmetricTensor<2, dim>'
p41735
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_DD() const'
p41736
aS'    {'
p41737
aS'      return BB;'
p41738
aS'    }'
p41739
aS'    template <int dim>'
p41740
aS'    Tensor<3, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_PP() const'
p41741
aS'    {'
p41742
aS'      return PP;'
p41743
aS'    }'
p41744
aS'    template <int dim>'
p41745
aS'    SymmetricTensor<4, dim>'
p41746
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_HH() const'
p41747
aS'    {'
p41748
aS'      return HH;'
p41749
aS'    }'
p41750
aS'    template <int dim>'
p41751
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::update_end_of_timestep()'
p41752
aS'    {'
p41753
aS'      Q_t1 = Q_t;'
p41754
aS'    }'
p41755
aS'    template <int dim>'
p41756
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::update_internal_variable('
p41757
aS'      const DiscreteTime &time)'
p41758
aS'    {'
p41759
aS'      const double delta_t = this->get_delta_t(time);'
p41760
aS'      Q_t = (1.0 / (1.0 + delta_t / this->get_tau_v())) *'
p41761
aS'                      std::pow(get_det_F(), 2.0 / dim) * get_C_inv());'
p41762
aS'    }'
p41763
aS'    template <int dim>'
p41764
aS'    double'
p41765
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_two_h_dot_h_div_h_sat_squ('
p41766
aS'      const double mu_h_sat) const'
p41767
aS'    {'
p41768
aS'      const Tensor<1, dim> &H = get_H();'
p41769
aS'      return (2.0 * H * H) / (mu_h_sat * mu_h_sat);'
p41770
aS'    }'
p41771
aS'    template <int dim>'
p41772
aS'    double Magnetoviscoelastic_Constitutive_Law<'
p41773
aS'      dim>::get_tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const'
p41774
aS'    {'
p41775
aS'      return std::tanh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));'
p41776
aS'    }'
p41777
aS'    template <int dim>'
p41778
aS'    double Magnetoviscoelastic_Constitutive_Law<dim>::get_f_mu('
p41779
aS'      const double mu,'
p41780
aS'      const double mu_inf,'
p41781
aS'      const double mu_h_sat) const'
p41782
aS'    {'
p41783
aS'      return 1.0 +'
p41784
aS'    }'
p41785
aS'    template <int dim>'
p41786
aS'    double Magnetoviscoelastic_Constitutive_Law<'
p41787
aS'      dim>::get_dtanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const'
p41788
aS'    {'
p41789
aS'      return std::pow(1.0 / std::cosh(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),'
p41790
aS'                      2.0);'
p41791
aS'    }'
p41792
aS'    template <int dim>'
p41793
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<'
p41794
aS'      dim>::get_dtwo_h_dot_h_div_h_sat_squ_dH(const double mu_h_sat) const'
p41795
aS'    {'
p41796
aS'      return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();'
p41797
aS'    }'
p41798
aS'    template <int dim>'
p41799
aS'    Tensor<1, dim> Magnetoviscoelastic_Constitutive_Law<dim>::get_df_mu_dH('
p41800
aS'      const double mu,'
p41801
aS'      const double mu_inf,'
p41802
aS'      const double mu_h_sat) const'
p41803
aS'    {'
p41804
aS'      return (mu_inf / mu - 1.0) *'
p41805
aS'              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));'
p41806
aS'    }'
p41807
aS'    template <int dim>'
p41808
aS'    double Magnetoviscoelastic_Constitutive_Law<'
p41809
aS'      dim>::get_d2tanh_two_h_dot_h_div_h_sat_squ(const double mu_h_sat) const'
p41810
aS'    {'
p41811
aS'      return -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *'
p41812
aS'             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);'
p41813
aS'    }'
p41814
aS'    template <int dim>'
p41815
aS'    SymmetricTensor<2, dim> Magnetoviscoelastic_Constitutive_Law<'
p41816
aS'      dim>::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(const double mu_h_sat) const'
p41817
aS'    {'
p41818
aS'      return 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *'
p41819
aS'             Physics::Elasticity::StandardTensors<dim>::I;'
p41820
aS'    }'
p41821
aS'    template <int dim>'
p41822
aS'    SymmetricTensor<2, dim>'
p41823
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2f_mu_dH_dH('
p41824
aS'      const double mu,'
p41825
aS'      const double mu_inf,'
p41826
aS'      const double mu_h_sat) const'
p41827
aS'    {'
p41828
aS'      return (mu_inf / mu - 1.0) *'
p41829
aS'                symmetrize('
p41830
aS'                  outer_product(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),'
p41831
aS'                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +'
p41832
aS'              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *'
p41833
aS'                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));'
p41834
aS'    }'
p41835
aS'    template <int dim>'
p41836
aS'    void Magnetoviscoelastic_Constitutive_Law<dim>::set_primary_variables('
p41837
aS'      const SymmetricTensor<2, dim> &C,'
p41838
aS'      const Tensor<1, dim> &         H) const'
p41839
aS'    {'
p41840
aS'      const std::string name_H("H");'
p41841
aS'      Assert(!cache.stores_object_with_name(name_H),'
p41842
aS'             ExcMessage('
p41843
aS'               "The primary variable has already been added to the cache."));'
p41844
aS'      cache.add_unique_copy(name_H, H);'
p41845
aS'      const std::string name_C("C");'
p41846
aS'      Assert(!cache.stores_object_with_name(name_C),'
p41847
aS'             ExcMessage('
p41848
aS'               "The primary variable has already been added to the cache."));'
p41849
aS'      cache.add_unique_copy(name_C, C);'
p41850
aS'    }'
p41851
aS'    template <int dim>'
p41852
aS'    const Tensor<1, dim> &'
p41853
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_H() const'
p41854
aS'    {'
p41855
aS'      const std::string name("H");'
p41856
aS'      Assert(cache.stores_object_with_name(name),'
p41857
aS'             ExcMessage("Primary variables must be added to the cache."));'
p41858
aS'      return cache.template get_object_with_name<Tensor<1, dim>>(name);'
p41859
aS'    }'
p41860
aS'    template <int dim>'
p41861
aS'    const SymmetricTensor<2, dim> &'
p41862
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_C() const'
p41863
aS'    {'
p41864
aS'      const std::string name("C");'
p41865
aS'      Assert(cache.stores_object_with_name(name),'
p41866
aS'             ExcMessage("Primary variables must be added to the cache."));'
p41867
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p41868
aS'    }'
p41869
aS'    template <int dim>'
p41870
aS'    const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_det_F() const'
p41871
aS'    {'
p41872
aS'      const std::string name("det_F");'
p41873
aS'      if (cache.stores_object_with_name(name) == false)'
p41874
aS'        {'
p41875
aS'          const double det_F = std::sqrt(determinant(get_C()));'
p41876
aS'          AssertThrow(det_F > 0.0,'
p41877
aS'                      ExcMessage("Volumetric Jacobian must be positive."));'
p41878
aS'          cache.add_unique_copy(name, det_F);'
p41879
aS'        }'
p41880
aS'      return cache.template get_object_with_name<double>(name);'
p41881
aS'    }'
p41882
aS'    template <int dim>'
p41883
aS'    const SymmetricTensor<2, dim> &'
p41884
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv() const'
p41885
aS'    {'
p41886
aS'      const std::string name("C_inv");'
p41887
aS'      if (cache.stores_object_with_name(name) == false)'
p41888
aS'        {'
p41889
aS'          cache.add_unique_copy(name, invert(get_C()));'
p41890
aS'        }'
p41891
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p41892
aS'    }'
p41893
aS'    template <int dim>'
p41894
aS'    const double &'
p41895
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_log_det_F() const'
p41896
aS'    {'
p41897
aS'      const std::string name("log(det_F)");'
p41898
aS'      if (cache.stores_object_with_name(name) == false)'
p41899
aS'        cache.add_unique_copy(name, std::log(get_det_F()));'
p41900
aS'      return cache.template get_object_with_name<double>(name);'
p41901
aS'    }'
p41902
aS'    template <int dim>'
p41903
aS'    const double &Magnetoviscoelastic_Constitutive_Law<dim>::get_trace_C() const'
p41904
aS'    {'
p41905
aS'      const std::string name("trace(C)");'
p41906
aS'      if (cache.stores_object_with_name(name) == false)'
p41907
aS'        cache.add_unique_copy(name, trace(get_C()));'
p41908
aS'      return cache.template get_object_with_name<double>(name);'
p41909
aS'    }'
p41910
aS'    template <int dim>'
p41911
aS'    const Tensor<1, dim> &'
p41912
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_C_inv_dot_H() const'
p41913
aS'    {'
p41914
aS'      const std::string name("C_inv_dot_H");'
p41915
aS'      if (cache.stores_object_with_name(name) == false)'
p41916
aS'        cache.add_unique_copy(name, get_C_inv() * get_H());'
p41917
aS'      return cache.template get_object_with_name<Tensor<1, dim>>(name);'
p41918
aS'    }'
p41919
aS'    template <int dim>'
p41920
aS'    const double &'
p41921
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_H_dot_C_inv_dot_H() const'
p41922
aS'    {'
p41923
aS'      const std::string name("H_dot_C_inv_dot_H");'
p41924
aS'      if (cache.stores_object_with_name(name) == false)'
p41925
aS'        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());'
p41926
aS'      return cache.template get_object_with_name<double>(name);'
p41927
aS'    }'
p41928
aS'    template <int dim>'
p41929
aS'    const SymmetricTensor<4, dim> &'
p41930
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dQ_t_dC('
p41931
aS'      const DiscreteTime &time) const'
p41932
aS'    {'
p41933
aS'      const std::string name("dQ_t_dC");'
p41934
aS'      if (cache.stores_object_with_name(name) == false)'
p41935
aS'        {'
p41936
aS'          const double  delta_t = this->get_delta_t(time);'
p41937
aS'          const double &det_F   = get_det_F();'
p41938
aS'          const SymmetricTensor<4, dim> dQ_t_dC ='
p41939
aS'               outer_product(get_C_inv(), get_ddet_F_dC()) +'
p41940
aS'             std::pow(det_F, 2.0 / dim) * get_dC_inv_dC());'
p41941
aS'          cache.add_unique_copy(name, dQ_t_dC);'
p41942
aS'        }'
p41943
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p41944
aS'    }'
p41945
aS'    template <int dim>'
p41946
aS'    const SymmetricTensor<4, dim> &'
p41947
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dC_inv_dC() const'
p41948
aS'    {'
p41949
aS'      const std::string name("dC_inv_dC");'
p41950
aS'      if (cache.stores_object_with_name(name) == false)'
p41951
aS'        {'
p41952
aS'          const SymmetricTensor<2, dim> &C_inv = get_C_inv();'
p41953
aS'          SymmetricTensor<4, dim>        dC_inv_dC;'
p41954
aS'          for (unsigned int A = 0; A < dim; ++A)'
p41955
aS'            for (unsigned int B = A; B < dim; ++B)'
p41956
aS'              for (unsigned int C = 0; C < dim; ++C)'
p41957
aS'                for (unsigned int D = C; D < dim; ++D)'
p41958
aS'                  dC_inv_dC[A][B][C][D] -=               //'
p41959
aS'                    0.5 * (C_inv[A][C] * C_inv[B][D]     //'
p41960
aS'                           + C_inv[A][D] * C_inv[B][C]); //'
p41961
aS'          cache.add_unique_copy(name, dC_inv_dC);'
p41962
aS'        }'
p41963
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p41964
aS'    }'
p41965
aS'    template <int dim>'
p41966
aS'    const SymmetricTensor<2, dim> &'
p41967
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d_tr_C_dC() const'
p41968
aS'    {'
p41969
aS'      const std::string name("d_tr_C_dC");'
p41970
aS'      if (cache.stores_object_with_name(name) == false)'
p41971
aS'        cache.add_unique_copy(name,'
p41972
aS'                              Physics::Elasticity::StandardTensors<dim>::I);'
p41973
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p41974
aS'    }'
p41975
aS'    template <int dim>'
p41976
aS'    const SymmetricTensor<2, dim> &'
p41977
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_ddet_F_dC() const'
p41978
aS'    {'
p41979
aS'      const std::string name("ddet_F_dC");'
p41980
aS'      if (cache.stores_object_with_name(name) == false)'
p41981
aS'        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());'
p41982
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p41983
aS'    }'
p41984
aS'    template <int dim>'
p41985
aS'    const SymmetricTensor<2, dim> &'
p41986
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dlog_det_F_dC() const'
p41987
aS'    {'
p41988
aS'      const std::string name("dlog_det_F_dC");'
p41989
aS'      if (cache.stores_object_with_name(name) == false)'
p41990
aS'        cache.add_unique_copy(name, 0.5 * get_C_inv());'
p41991
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p41992
aS'    }'
p41993
aS'    template <int dim>'
p41994
aS'    const Tensor<1, dim> &'
p41995
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dH() const'
p41996
aS'    {'
p41997
aS'      const std::string name("dH_dot_C_inv_dot_H_dH");'
p41998
aS'      if (cache.stores_object_with_name(name) == false)'
p41999
aS'        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());'
p42000
aS'      return cache.template get_object_with_name<Tensor<1, dim>>(name);'
p42001
aS'    }'
p42002
aS'    template <int dim>'
p42003
aS'    const SymmetricTensor<2, dim> &'
p42004
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_dH_dot_C_inv_dot_H_dC() const'
p42005
aS'    {'
p42006
aS'      const std::string name("dH_dot_C_inv_dot_H_dC");'
p42007
aS'      if (cache.stores_object_with_name(name) == false)'
p42008
aS'        {'
p42009
aS'          const Tensor<1, dim> C_inv_dot_H = get_C_inv_dot_H();'
p42010
aS'          cache.add_unique_copy('
p42011
aS'            name, -symmetrize(outer_product(C_inv_dot_H, C_inv_dot_H)));'
p42012
aS'        }'
p42013
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p42014
aS'    }'
p42015
aS'    template <int dim>'
p42016
aS'    const SymmetricTensor<4, dim> &'
p42017
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2log_det_F_dC_dC() const'
p42018
aS'    {'
p42019
aS'      const std::string name("d2log_det_F_dC_dC");'
p42020
aS'      if (cache.stores_object_with_name(name) == false)'
p42021
aS'        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());'
p42022
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p42023
aS'    }'
p42024
aS'    template <int dim>'
p42025
aS'    const SymmetricTensor<4, dim> &'
p42026
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2det_F_dC_dC() const'
p42027
aS'    {'
p42028
aS'      const std::string name("d2det_F_dC_dC");'
p42029
aS'      if (cache.stores_object_with_name(name) == false)'
p42030
aS'        cache.add_unique_copy(name,'
p42031
aS'                              0.5 *'
p42032
aS'                                 get_det_F() * get_dC_inv_dC()));'
p42033
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p42034
aS'    }'
p42035
aS'    template <int dim>'
p42036
aS'    const SymmetricTensor<2, dim> &'
p42037
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dH_dH()'
p42038
aS'      const'
p42039
aS'    {'
p42040
aS'      const std::string name("d2H_dot_C_inv_dot_H_dH_dH");'
p42041
aS'      if (cache.stores_object_with_name(name) == false)'
p42042
aS'        cache.add_unique_copy(name, 2.0 * get_C_inv());'
p42043
aS'      return cache.template get_object_with_name<SymmetricTensor<2, dim>>(name);'
p42044
aS'    }'
p42045
aS'    template <int dim>'
p42046
aS'    const Tensor<3, dim> &'
p42047
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dH()'
p42048
aS'      const'
p42049
aS'    {'
p42050
aS'      const std::string name("d2H_dot_C_inv_dot_H_dC_dH");'
p42051
aS'      if (cache.stores_object_with_name(name) == false)'
p42052
aS'        {'
p42053
aS'          const Tensor<1, dim> &         C_inv_dot_H = get_C_inv_dot_H();'
p42054
aS'          const SymmetricTensor<2, dim> &C_inv       = get_C_inv();'
p42055
aS'          Tensor<3, dim> d2H_dot_C_inv_dot_H_dC_dH;'
p42056
aS'          for (unsigned int A = 0; A < dim; ++A)'
p42057
aS'            for (unsigned int B = 0; B < dim; ++B)'
p42058
aS'              for (unsigned int C = 0; C < dim; ++C)'
p42059
aS'                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -='
p42060
aS'                  C_inv[A][C] * C_inv_dot_H[B] + //'
p42061
aS'                  C_inv_dot_H[A] * C_inv[B][C];  //'
p42062
aS'          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);'
p42063
aS'        }'
p42064
aS'      return cache.template get_object_with_name<Tensor<3, dim>>(name);'
p42065
aS'    }'
p42066
aS'    template <int dim>'
p42067
aS'    const SymmetricTensor<4, dim> &'
p42068
aS'    Magnetoviscoelastic_Constitutive_Law<dim>::get_d2H_dot_C_inv_dot_H_dC_dC()'
p42069
aS'      const'
p42070
aS'    {'
p42071
aS'      const std::string name("d2H_dot_C_inv_dot_H_dC_dC");'
p42072
aS'      if (cache.stores_object_with_name(name) == false)'
p42073
aS'        {'
p42074
aS'          const Tensor<1, dim> &         C_inv_dot_H = get_C_inv_dot_H();'
p42075
aS'          const SymmetricTensor<2, dim> &C_inv       = get_C_inv();'
p42076
aS'          SymmetricTensor<4, dim> d2H_dot_C_inv_dot_H_dC_dC;'
p42077
aS'          for (unsigned int A = 0; A < dim; ++A)'
p42078
aS'            for (unsigned int B = A; B < dim; ++B)'
p42079
aS'              for (unsigned int C = 0; C < dim; ++C)'
p42080
aS'                for (unsigned int D = C; D < dim; ++D)'
p42081
aS'                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +='
p42082
aS'                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +'
p42083
aS'                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +'
p42084
aS'                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +'
p42085
aS'                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);'
p42086
aS'          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);'
p42087
aS'        }'
p42088
aS'      return cache.template get_object_with_name<SymmetricTensor<4, dim>>(name);'
p42089
aS'    }'
p42090
aS'    class RheologicalExperimentParameters : public ParameterAcceptor'
p42091
aS'    {'
p42092
aS'    public:'
p42093
aS'      RheologicalExperimentParameters();'
p42094
aS'      double sample_radius = 0.01;'
p42095
aS'      double sample_height = 0.001;'
p42096
aS'      double lambda_2 = 0.95;'
p42097
aS'      double gamma_12 = 0.05;'
p42098
aS'      double H_2      = 60.0e3;'
p42099
aS'      double       frequency         = 1.0 / (2.0 * numbers::PI);'
p42100
aS'      unsigned int n_cycles          = 5;'
p42101
aS'      unsigned int n_steps_per_cycle = 2500;'
p42102
aS'      bool        output_data_to_file = true;'
p42103
aS'      std::string output_filename_rd ='
p42104
aS'        "experimental_results-rate_dependent.csv";'
p42105
aS'      std::string output_filename_ri ='
p42106
aS'        "experimental_results-rate_independent.csv";'
p42107
aS'      double start_time() const;'
p42108
aS'      double end_time() const;'
p42109
aS'      double delta_t() const;'
p42110
aS'      Tensor<1, 3> get_H(const double time) const;'
p42111
aS'      Tensor<2, 3> get_F(const double time) const;'
p42112
aS'      bool print_status(const int step_number) const;'
p42113
aS'      bool initialized = false;'
p42114
aS'    };'
p42115
aS'    RheologicalExperimentParameters::RheologicalExperimentParameters()'
p42116
aS'      : ParameterAcceptor("/Coupled Constitutive Laws/Rheological Experiment/")'
p42117
aS'    {'
p42118
aS'      add_parameter("Experimental sample radius", sample_radius);'
p42119
aS'      add_parameter("Experimental sample radius", sample_height);'
p42120
aS'      add_parameter("Axial stretch", lambda_2);'
p42121
aS'      add_parameter("Shear strain amplitude", gamma_12);'
p42122
aS'      add_parameter("Axial magnetic field strength", H_2);'
p42123
aS'      add_parameter("Frequency", frequency);'
p42124
aS'      add_parameter("Number of loading cycles", n_cycles);'
p42125
aS'      add_parameter("Discretisation for each cycle", n_steps_per_cycle);'
p42126
aS'      add_parameter("Output experimental results to file", output_data_to_file);'
p42127
aS'      add_parameter("Output file name (rate dependent constitutive law)",'
p42128
aS'                    output_filename_rd);'
p42129
aS'      add_parameter("Output file name (rate independent constitutive law)",'
p42130
aS'                    output_filename_ri);'
p42131
aS'      parse_parameters_call_back.connect([&]() -> void { initialized = true; });'
p42132
aS'    }'
p42133
aS'    double RheologicalExperimentParameters::start_time() const'
p42134
aS'    {'
p42135
aS'      return 0.0;'
p42136
aS'    }'
p42137
aS'    double RheologicalExperimentParameters::end_time() const'
p42138
aS'    {'
p42139
aS'      return n_cycles / frequency;'
p42140
aS'    }'
p42141
aS'    double RheologicalExperimentParameters::delta_t() const'
p42142
aS'    {'
p42143
aS'      return (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);'
p42144
aS'    }'
p42145
aS'    bool'
p42146
aS'    RheologicalExperimentParameters::print_status(const int step_number) const'
p42147
aS'    {'
p42148
aS'      return (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;'
p42149
aS'    }'
p42150
aS'    Tensor<1, 3> RheologicalExperimentParameters::get_H(const double) const'
p42151
aS'    {'
p42152
aS'      return Tensor<1, 3>({0.0, 0.0, H_2});'
p42153
aS'    }'
p42154
aS'    Tensor<2, 3> RheologicalExperimentParameters::get_F(const double time) const'
p42155
aS'    {'
p42156
aS'      AssertThrow((sample_radius > 0.0 && sample_height > 0.0),'
p42157
aS'                  ExcMessage("Non-physical sample dimensions"));'
p42158
aS'      AssertThrow(lambda_2 > 0.0,'
p42159
aS'                  ExcMessage("Non-physical applied axial stretch"));'
p42160
aS'      const double sqrt_lambda_2     = std::sqrt(lambda_2);'
p42161
aS'      const double inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;'
p42162
aS'      const double alpha_max ='
p42163
aS'        std::atan(std::tan(gamma_12) * sample_height /'
p42164
aS'                  sample_radius); // Small strain approximation'
p42165
aS'      const double A       = sample_radius * alpha_max;'
p42166
aS'      const double w       = 2.0 * numbers::PI * frequency; // in rad /s'
p42167
aS'      const double gamma_t = A * std::sin(w * time);'
p42168
aS'      const double tau_t ='
p42169
aS'        gamma_t /'
p42170
aS'      const double alpha_t = tau_t * lambda_2 * sample_height;'
p42171
aS'      Tensor<2, 3> F;'
p42172
aS'      F[0][0] = inv_sqrt_lambda_2 * std::cos(alpha_t);'
p42173
aS'      F[0][1] = -inv_sqrt_lambda_2 * std::sin(alpha_t);'
p42174
aS'      F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * std::sin(alpha_t);'
p42175
aS'      F[1][0] = inv_sqrt_lambda_2 * std::sin(alpha_t);'
p42176
aS'      F[1][1] = inv_sqrt_lambda_2 * std::cos(alpha_t);'
p42177
aS'      F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * std::cos(alpha_t);'
p42178
aS'      F[2][0] = 0.0;'
p42179
aS'      F[2][1] = 0.0;'
p42180
aS'      F[2][2] = lambda_2;'
p42181
aS'      AssertThrow((F[0][0] > 0) && (F[1][1] > 0) && (F[2][2] > 0),'
p42182
aS'                  ExcMessage("Non-physical deformation gradient component."));'
p42183
aS'      AssertThrow(std::abs(determinant(F) - 1.0) < 1e-6,'
p42184
aS'                  ExcMessage("Volumetric Jacobian is not equal to unity."));'
p42185
aS'      return F;'
p42186
aS'    }'
p42187
aS'    template <int dim>'
p42188
aS'    void run_rheological_experiment('
p42189
aS'      const RheologicalExperimentParameters &experimental_parameters,'
p42190
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p42191
aS'        &material_hand_calculated,'
p42192
aS'      Coupled_Magnetomechanical_Constitutive_Law_Base<dim>'
p42193
aS'        &               material_assisted_computation,'
p42194
aS'      TimerOutput &     timer,'
p42195
aS'      const std::string filename)'
p42196
aS'    {'
p42197
aS'      const auto check_material_class_results ='
p42198
aS'        []('
p42199
aS'          const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &to_verify,'
p42200
aS'          const Coupled_Magnetomechanical_Constitutive_Law_Base<dim> &blessed,'
p42201
aS'          const double tol = 1e-6) {'
p42202
aS'          Assert(std::abs(blessed.get_psi() - to_verify.get_psi()) < tol,'
p42203
aS'                 ExcMessage("No match for psi. Error: " +'
p42204
aS'                            Utilities::to_string(std::abs('
p42205
aS'                              blessed.get_psi() - to_verify.get_psi()))));'
p42206
aS'          Assert((blessed.get_B() - to_verify.get_B()).norm() < tol,'
p42207
aS'                 ExcMessage("No match for B. Error: " +'
p42208
aS'                            Utilities::to_string('
p42209
aS'          Assert((blessed.get_S() - to_verify.get_S()).norm() < tol,'
p42210
aS'                 ExcMessage("No match for S. Error: " +'
p42211
aS'                            Utilities::to_string('
p42212
aS'          Assert((blessed.get_DD() - to_verify.get_DD()).norm() < tol,'
p42213
aS'                 ExcMessage("No match for BB. Error: " +'
p42214
aS'                            Utilities::to_string('
p42215
aS'          Assert((blessed.get_PP() - to_verify.get_PP()).norm() < tol,'
p42216
aS'                 ExcMessage("No match for PP. Error: " +'
p42217
aS'                            Utilities::to_string('
p42218
aS'          Assert((blessed.get_HH() - to_verify.get_HH()).norm() < tol,'
p42219
aS'                 ExcMessage("No match for HH. Error: " +'
p42220
aS'                            Utilities::to_string('
p42221
aS'        };'
p42222
aS'      std::ostringstream stream;'
p42223
aS'      stream'
p42224
aS'        << "Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\\n";'
p42225
aS'      for (DiscreteTime time(experimental_parameters.start_time(),'
p42226
aS'                             experimental_parameters.end_time() +'
p42227
aS'                               experimental_parameters.delta_t(),'
p42228
aS'                             experimental_parameters.delta_t());'
p42229
aS'           time.is_at_end() == false;'
p42230
aS'           time.advance_time())'
p42231
aS'        {'
p42232
aS'          if (experimental_parameters.print_status(time.get_step_number()))'
p42233
aS'            std::cout << "Timestep = " << time.get_step_number()'
p42234
aS'                      << " @ time = " << time.get_current_time() << "s."'
p42235
aS'                      << std::endl;'
p42236
aS'          const Tensor<1, dim> H ='
p42237
aS'            experimental_parameters.get_H(time.get_current_time());'
p42238
aS'          const Tensor<2, dim> F ='
p42239
aS'            experimental_parameters.get_F(time.get_current_time());'
p42240
aS'          const SymmetricTensor<2, dim> C ='
p42241
aS'            Physics::Elasticity::Kinematics::C(F);'
p42242
aS'          {'
p42243
aS'            TimerOutput::Scope timer_section(timer, "Hand calculated");'
p42244
aS'            material_hand_calculated.update_internal_data(C, H, time);'
p42245
aS'            material_hand_calculated.update_end_of_timestep();'
p42246
aS'          }'
p42247
aS'          {'
p42248
aS'            TimerOutput::Scope timer_section(timer, "Assisted computation");'
p42249
aS'            material_assisted_computation.update_internal_data(C, H, time);'
p42250
aS'            material_assisted_computation.update_end_of_timestep();'
p42251
aS'          }'
p42252
aS'          check_material_class_results(material_hand_calculated,'
p42253
aS'                                       material_assisted_computation);'
p42254
aS'          if (experimental_parameters.output_data_to_file)'
p42255
aS'            {'
p42256
aS'              const Tensor<1, dim> h ='
p42257
aS'                Physics::Transformations::Covariant::push_forward(H, F);'
p42258
aS'              const Tensor<1, dim> b ='
p42259
aS'                Physics::Transformations::Piola::push_forward('
p42260
aS'                  material_hand_calculated.get_B(), F);'
p42261
aS'              const SymmetricTensor<2, dim> sigma ='
p42262
aS'                Physics::Transformations::Piola::push_forward('
p42263
aS'                  material_hand_calculated.get_S(), F);'
p42264
aS'              stream << time.get_current_time() << ";" << h[2] << ";" << b[2]'
p42265
aS'                     << ";" << F[1][2] * 100.0 << ";" << sigma[1][2] << "\\n";'
p42266
aS'            }'
p42267
aS'        }'
p42268
aS'      if (experimental_parameters.output_data_to_file)'
p42269
aS'        {'
p42270
aS'          std::ofstream output(filename);'
p42271
aS'          output << stream.str();'
p42272
aS'        }'
p42273
aS'    }'
p42274
aS'    void run(int argc, char *argv[])'
p42275
aS'    {'
p42276
aS'      using namespace dealii;'
p42277
aS'      constexpr unsigned int dim = 3;'
p42278
aS'      const ConstitutiveParameters          constitutive_parameters;'
p42279
aS'      const RheologicalExperimentParameters experimental_parameters;'
p42280
aS'      std::string parameter_file;'
p42281
aS'      if (argc > 1)'
p42282
aS'        parameter_file = argv[1];'
p42283
aS'      else'
p42284
aS'        parameter_file = "parameters.prm";'
p42285
aS'      ParameterAcceptor::initialize(parameter_file, "used_parameters.prm");'
p42286
aS'      {'
p42287
aS'        TimerOutput timer(std::cout,'
p42288
aS'                          TimerOutput::summary,'
p42289
aS'                          TimerOutput::wall_times);'
p42290
aS'        std::cout'
p42291
aS'          << "Coupled magnetoelastic constitutive law using automatic differentiation."'
p42292
aS'          << std::endl;'
p42293
aS'        constexpr Differentiation::AD::NumberTypes ADTypeCode ='
p42294
aS'          Differentiation::AD::NumberTypes::sacado_dfad_dfad;'
p42295
aS'        Magnetoelastic_Constitutive_Law<dim> material(constitutive_parameters);'
p42296
aS'        Magnetoelastic_Constitutive_Law_AD<dim, ADTypeCode> material_ad('
p42297
aS'          constitutive_parameters);'
p42298
aS'        run_rheological_experiment(experimental_parameters,'
p42299
aS'                                   material,'
p42300
aS'                                   material_ad,'
p42301
aS'                                   timer,'
p42302
aS'                                   experimental_parameters.output_filename_ri);'
p42303
aS'        std::cout << "... all calculations are correct!" << std::endl;'
p42304
aS'      }'
p42305
aS'      {'
p42306
aS'        TimerOutput timer(std::cout,'
p42307
aS'                          TimerOutput::summary,'
p42308
aS'                          TimerOutput::wall_times);'
p42309
aS'        std::cout'
p42310
aS'          << "Coupled magneto-viscoelastic constitutive law using symbolic differentiation."'
p42311
aS'          << std::endl;'
p42312
aS'#ifdef DEAL_II_SYMENGINE_WITH_LLVM'
p42313
aS'        std::cout << "Using LLVM optimizer." << std::endl;'
p42314
aS'        constexpr Differentiation::SD::OptimizerType optimizer_type ='
p42315
aS'          Differentiation::SD::OptimizerType::llvm;'
p42316
aS'        constexpr Differentiation::SD::OptimizationFlags optimization_flags ='
p42317
aS'          Differentiation::SD::OptimizationFlags::optimize_all;'
p42318
aS'#else'
p42319
aS'        std::cout << "Using lambda optimizer." << std::endl;'
p42320
aS'        constexpr Differentiation::SD::OptimizerType optimizer_type ='
p42321
aS'          Differentiation::SD::OptimizerType::lambda;'
p42322
aS'        constexpr Differentiation::SD::OptimizationFlags optimization_flags ='
p42323
aS'          Differentiation::SD::OptimizationFlags::optimize_cse;'
p42324
aS'#endif'
p42325
aS'        Magnetoviscoelastic_Constitutive_Law<dim> material('
p42326
aS'          constitutive_parameters);'
p42327
aS'        timer.enter_subsection("Initialize symbolic CL");'
p42328
aS'        Magnetoviscoelastic_Constitutive_Law_SD<dim> material_sd('
p42329
aS'          constitutive_parameters, optimizer_type, optimization_flags);'
p42330
aS'        timer.leave_subsection();'
p42331
aS'        run_rheological_experiment(experimental_parameters,'
p42332
aS'                                   material,'
p42333
aS'                                   material_sd,'
p42334
aS'                                   timer,'
p42335
aS'                                   experimental_parameters.output_filename_rd);'
p42336
aS'        std::cout << "... all calculations are correct!" << std::endl;'
p42337
aS'      }'
p42338
aS'    }'
p42339
aS'  } // namespace CoupledConstitutiveLaws'
p42340
aS'} // namespace Step71'
p42341
aS'int main(int argc, char *argv[])'
p42342
ag9
aS'  Step71::SimpleExample::run();'
p42343
aS'  Step71::CoupledConstitutiveLaws::run(argc, argv);'
p42344
aS'  return 0;'
p42345
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p42346
aS'#include <deal.II/base/function.h>'
p42347
aS'#include <deal.II/base/parameter_acceptor.h>'
p42348
aS'#include <deal.II/base/timer.h>'
p42349
aS'#include <deal.II/base/utilities.h>'
p42350
aS'#include <deal.II/differentiation/ad.h>'
p42351
aS'#include <deal.II/lac/vector.h>'
p42352
aS'#include <deal.II/lac/full_matrix.h>'
p42353
aS'#include <deal.II/lac/sparse_matrix.h>'
p42354
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p42355
aS'#include <deal.II/lac/solver_cg.h>'
p42356
aS'#include <deal.II/lac/precondition.h>'
p42357
aS'#include <deal.II/lac/affine_constraints.h>'
p42358
aS'#include <deal.II/grid/tria.h>'
p42359
aS'#include <deal.II/grid/grid_generator.h>'
p42360
aS'#include <deal.II/grid/grid_refinement.h>'
p42361
aS'#include <deal.II/dofs/dof_handler.h>'
p42362
aS'#include <deal.II/dofs/dof_tools.h>'
p42363
aS'#include <deal.II/fe/fe_values.h>'
p42364
aS'#include <deal.II/fe/fe_values_extractors.h>'
p42365
aS'#include <deal.II/fe/fe_q.h>'
p42366
aS'#include <deal.II/meshworker/copy_data.h>'
p42367
aS'#include <deal.II/meshworker/mesh_loop.h>'
p42368
aS'#include <deal.II/meshworker/scratch_data.h>'
p42369
aS'#include <deal.II/numerics/vector_tools.h>'
p42370
aS'#include <deal.II/numerics/matrix_tools.h>'
p42371
aS'#include <deal.II/numerics/data_out.h>'
p42372
aS'#include <deal.II/numerics/error_estimator.h>'
p42373
aS'#include <fstream>'
p42374
aS'#include <iostream>'
p42375
aS'#include <deal.II/numerics/solution_transfer.h>'
p42376
aS'namespace Step72'
p42377
ag9
aS'  using namespace dealii;'
p42378
aS'  class MinimalSurfaceProblemParameters : public ParameterAcceptor'
p42379
aS'  {'
p42380
aS'  public:'
p42381
aS'    MinimalSurfaceProblemParameters();'
p42382
aS'    unsigned int formulation = 0;'
p42383
aS'    double tolerance = 1e-2;'
p42384
aS'  };'
p42385
aS'  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters()'
p42386
aS'    : ParameterAcceptor("Minimal Surface Problem/")'
p42387
aS'  {'
p42388
aS'    add_parameter('
p42389
aS'      "Formulation", formulation, "", this->prm, Patterns::Integer(0, 2));'
p42390
aS'    add_parameter("Tolerance", tolerance, "", this->prm, Patterns::Double(0.0));'
p42391
aS'  }'
p42392
aS'  template <int dim>'
p42393
aS'  class MinimalSurfaceProblem'
p42394
aS'  {'
p42395
aS'  public:'
p42396
aS'    MinimalSurfaceProblem();'
p42397
aS'    void run(const int formulation, const double tolerance);'
p42398
aS'  private:'
p42399
aS'    void   setup_system(const bool initial_step);'
p42400
aS'    void   assemble_system_unassisted();'
p42401
aS'    void   assemble_system_with_residual_linearization();'
p42402
aS'    void   assemble_system_using_energy_functional();'
p42403
aS'    void   solve();'
p42404
aS'    void   refine_mesh();'
p42405
aS'    void   set_boundary_values();'
p42406
aS'    double compute_residual(const double alpha) const;'
p42407
aS'    double determine_step_length() const;'
p42408
aS'    void   output_results(const unsigned int refinement_cycle) const;'
p42409
aS'    Triangulation<dim> triangulation;'
p42410
aS'    DoFHandler<dim> dof_handler;'
p42411
aS'    FE_Q<dim>       fe;'
p42412
aS'    QGauss<dim>     quadrature_formula;'
p42413
aS'    AffineConstraints<double> hanging_node_constraints;'
p42414
aS'    SparsityPattern      sparsity_pattern;'
p42415
aS'    SparseMatrix<double> system_matrix;'
p42416
aS'    Vector<double> current_solution;'
p42417
aS'    Vector<double> newton_update;'
p42418
aS'    Vector<double> system_rhs;'
p42419
aS'  };'
p42420
aS'  template <int dim>'
p42421
aS'  class BoundaryValues : public Function<dim>'
p42422
aS'  {'
p42423
aS'  public:'
p42424
aS'    virtual double value(const Point<dim> & p,'
p42425
aS'                         const unsigned int component = 0) const override;'
p42426
aS'  };'
p42427
aS'  template <int dim>'
p42428
aS'  double BoundaryValues<dim>::value(const Point<dim> &p,'
p42429
aS'                                    const unsigned int /*component*/) const'
p42430
aS'  {'
p42431
aS'    return std::sin(2 * numbers::PI * (p[0] + p[1]));'
p42432
aS'  }'
p42433
aS'  template <int dim>'
p42434
aS'  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()'
p42435
aS'    : dof_handler(triangulation)'
p42436
aS'    , fe(2)'
p42437
aS'    , quadrature_formula(fe.degree + 1)'
p42438
aS'  {}'
p42439
aS'  template <int dim>'
p42440
aS'  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step)'
p42441
aS'  {'
p42442
aS'    if (initial_step)'
p42443
aS'      {'
p42444
aS'        dof_handler.distribute_dofs(fe);'
p42445
aS'        current_solution.reinit(dof_handler.n_dofs());'
p42446
aS'        hanging_node_constraints.clear();'
p42447
aS'        DoFTools::make_hanging_node_constraints(dof_handler,'
p42448
aS'                                                hanging_node_constraints);'
p42449
aS'        hanging_node_constraints.close();'
p42450
aS'      }'
p42451
aS'    newton_update.reinit(dof_handler.n_dofs());'
p42452
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p42453
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p42454
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p42455
aS'    hanging_node_constraints.condense(dsp);'
p42456
aS'    sparsity_pattern.copy_from(dsp);'
p42457
aS'    system_matrix.reinit(sparsity_pattern);'
p42458
aS'  }'
p42459
aS'  template <int dim>'
p42460
aS'  void MinimalSurfaceProblem<dim>::assemble_system_unassisted()'
p42461
aS'  {'
p42462
aS'    system_matrix = 0;'
p42463
aS'    system_rhs    = 0;'
p42464
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p42465
aS'    using ScratchData = MeshWorker::ScratchData<dim>;'
p42466
aS'    using CopyData    = MeshWorker::CopyData<1, 1, 1>;'
p42467
aS'    using CellIteratorType = decltype(dof_handler.begin_active());'
p42468
aS'    const ScratchData sample_scratch_data(fe,'
p42469
aS'                                          quadrature_formula,'
p42470
aS'                                          update_gradients |'
p42471
aS'                                            update_quadrature_points |'
p42472
aS'                                            update_JxW_values);'
p42473
aS'    const CopyData    sample_copy_data(dofs_per_cell);'
p42474
aS'    const auto cell_worker = [this](const CellIteratorType &cell,'
p42475
aS'                                    ScratchData &           scratch_data,'
p42476
aS'                                    CopyData &              copy_data) {'
p42477
aS'      const auto &fe_values = scratch_data.reinit(cell);'
p42478
aS'      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0];'
p42479
aS'      Vector<double> &                      cell_rhs    = copy_data.vectors[0];'
p42480
aS'      std::vector<types::global_dof_index> &local_dof_indices ='
p42481
aS'        copy_data.local_dof_indices[0];'
p42482
aS'      cell->get_dof_indices(local_dof_indices);'
p42483
aS'      std::vector<Tensor<1, dim>> old_solution_gradients('
p42484
aS'        fe_values.n_quadrature_points);'
p42485
aS'      fe_values.get_function_gradients(current_solution,'
p42486
aS'                                       old_solution_gradients);'
p42487
aS'      for (const unsigned int q : fe_values.quadrature_point_indices())'
p42488
aS'        {'
p42489
aS'          const double coeff ='
p42490
aS'            1.0 / std::sqrt(1.0 + old_solution_gradients[q] *'
p42491
aS'                                    old_solution_gradients[q]);'
p42492
aS'          for (const unsigned int i : fe_values.dof_indices())'
p42493
aS'            {'
p42494
aS'              for (const unsigned int j : fe_values.dof_indices())'
p42495
aS'                cell_matrix(i, j) +='
p42496
aS'                    -                                //  -'
p42497
aS'              cell_rhs(i) -= (fe_values.shape_grad(i, q)  // \\nabla \\phi_i'
p42498
aS'            }'
p42499
aS'        }'
p42500
aS'    };'
p42501
aS'    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) {'
p42502
aS'      const FullMatrix<double> &cell_matrix = copy_data.matrices[0];'
p42503
aS'      const Vector<double> &    cell_rhs    = copy_data.vectors[0];'
p42504
aS'      const std::vector<types::global_dof_index> &local_dof_indices ='
p42505
aS'        copy_data.local_dof_indices[0];'
p42506
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p42507
aS'        {'
p42508
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p42509
aS'            system_matrix.add(local_dof_indices[i],'
p42510
aS'                              local_dof_indices[j],'
p42511
aS'                              cell_matrix(i, j));'
p42512
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p42513
aS'        }'
p42514
aS'    };'
p42515
aS'    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),'
p42516
aS'                          cell_worker,'
p42517
aS'                          copier,'
p42518
aS'                          sample_scratch_data,'
p42519
aS'                          sample_copy_data,'
p42520
aS'                          MeshWorker::assemble_own_cells);'
p42521
aS'    hanging_node_constraints.condense(system_matrix);'
p42522
aS'    hanging_node_constraints.condense(system_rhs);'
p42523
aS'    std::map<types::global_dof_index, double> boundary_values;'
p42524
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p42525
aS'                                             0,'
p42526
aS'                                             Functions::ZeroFunction<dim>(),'
p42527
aS'                                             boundary_values);'
p42528
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p42529
aS'                                       system_matrix,'
p42530
aS'                                       newton_update,'
p42531
aS'                                       system_rhs);'
p42532
aS'  }'
p42533
aS'  template <int dim>'
p42534
aS'  void MinimalSurfaceProblem<dim>::assemble_system_with_residual_linearization()'
p42535
aS'  {'
p42536
aS'    system_matrix = 0;'
p42537
aS'    system_rhs    = 0;'
p42538
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p42539
aS'    using ScratchData      = MeshWorker::ScratchData<dim>;'
p42540
aS'    using CopyData         = MeshWorker::CopyData<1, 1, 1>;'
p42541
aS'    using CellIteratorType = decltype(dof_handler.begin_active());'
p42542
aS'    const ScratchData sample_scratch_data(fe,'
p42543
aS'                                          quadrature_formula,'
p42544
aS'                                          update_gradients |'
p42545
aS'                                            update_quadrature_points |'
p42546
aS'                                            update_JxW_values);'
p42547
aS'    const CopyData    sample_copy_data(dofs_per_cell);'
p42548
aS'    using ADHelper = Differentiation::AD::ResidualLinearization<'
p42549
aS'      Differentiation::AD::NumberTypes::sacado_dfad,'
p42550
aS'      double>;'
p42551
aS'    using ADNumberType = typename ADHelper::ad_type;'
p42552
aS'    const FEValuesExtractors::Scalar u_fe(0);'
p42553
aS'    const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,'
p42554
aS'                                           ScratchData &           scratch_data,'
p42555
aS'                                           CopyData &              copy_data) {'
p42556
aS'      const auto &       fe_values     = scratch_data.reinit(cell);'
p42557
aS'      const unsigned int dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();'
p42558
aS'      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0];'
p42559
aS'      Vector<double> &                      cell_rhs    = copy_data.vectors[0];'
p42560
aS'      std::vector<types::global_dof_index> &local_dof_indices ='
p42561
aS'        copy_data.local_dof_indices[0];'
p42562
aS'      cell->get_dof_indices(local_dof_indices);'
p42563
aS'      const unsigned int n_independent_variables = local_dof_indices.size();'
p42564
aS'      const unsigned int n_dependent_variables   = dofs_per_cell;'
p42565
aS'      ADHelper ad_helper(n_independent_variables, n_dependent_variables);'
p42566
aS'      ad_helper.register_dof_values(current_solution, local_dof_indices);'
p42567
aS'      const std::vector<ADNumberType> &dof_values_ad ='
p42568
aS'        ad_helper.get_sensitive_dof_values();'
p42569
aS'      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients('
p42570
aS'        fe_values.n_quadrature_points);'
p42571
aS'      fe_values[u_fe].get_function_gradients_from_local_dof_values('
p42572
aS'        dof_values_ad, old_solution_gradients);'
p42573
aS'      std::vector<ADNumberType> residual_ad(n_dependent_variables,'
p42574
aS'                                            ADNumberType(0.0));'
p42575
aS'      for (const unsigned int q : fe_values.quadrature_point_indices())'
p42576
aS'        {'
p42577
aS'          const ADNumberType coeff ='
p42578
aS'            1.0 / std::sqrt(1.0 + old_solution_gradients[q] *'
p42579
aS'                                    old_solution_gradients[q]);'
p42580
aS'          for (const unsigned int i : fe_values.dof_indices())'
p42581
aS'            {'
p42582
aS'              residual_ad[i] += (fe_values.shape_grad(i, q)   // \\nabla \\phi_i'
p42583
aS'            }'
p42584
aS'        }'
p42585
aS'      ad_helper.register_residual_vector(residual_ad);'
p42586
aS'      ad_helper.compute_residual(cell_rhs);'
p42587
aS'      cell_rhs *= -1.0;'
p42588
aS'      ad_helper.compute_linearization(cell_matrix);'
p42589
aS'    };'
p42590
aS'    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) {'
p42591
aS'      const FullMatrix<double> &cell_matrix = copy_data.matrices[0];'
p42592
aS'      const Vector<double> &    cell_rhs    = copy_data.vectors[0];'
p42593
aS'      const std::vector<types::global_dof_index> &local_dof_indices ='
p42594
aS'        copy_data.local_dof_indices[0];'
p42595
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p42596
aS'        {'
p42597
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p42598
aS'            system_matrix.add(local_dof_indices[i],'
p42599
aS'                              local_dof_indices[j],'
p42600
aS'                              cell_matrix(i, j));'
p42601
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p42602
aS'        }'
p42603
aS'    };'
p42604
aS'    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),'
p42605
aS'                          cell_worker,'
p42606
aS'                          copier,'
p42607
aS'                          sample_scratch_data,'
p42608
aS'                          sample_copy_data,'
p42609
aS'                          MeshWorker::assemble_own_cells);'
p42610
aS'    hanging_node_constraints.condense(system_matrix);'
p42611
aS'    hanging_node_constraints.condense(system_rhs);'
p42612
aS'    std::map<types::global_dof_index, double> boundary_values;'
p42613
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p42614
aS'                                             0,'
p42615
aS'                                             Functions::ZeroFunction<dim>(),'
p42616
aS'                                             boundary_values);'
p42617
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p42618
aS'                                       system_matrix,'
p42619
aS'                                       newton_update,'
p42620
aS'                                       system_rhs);'
p42621
aS'  }'
p42622
aS'  template <int dim>'
p42623
aS'  void MinimalSurfaceProblem<dim>::assemble_system_using_energy_functional()'
p42624
aS'  {'
p42625
aS'    system_matrix = 0;'
p42626
aS'    system_rhs    = 0;'
p42627
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p42628
aS'    using ScratchData      = MeshWorker::ScratchData<dim>;'
p42629
aS'    using CopyData         = MeshWorker::CopyData<1, 1, 1>;'
p42630
aS'    using CellIteratorType = decltype(dof_handler.begin_active());'
p42631
aS'    const ScratchData sample_scratch_data(fe,'
p42632
aS'                                          quadrature_formula,'
p42633
aS'                                          update_gradients |'
p42634
aS'                                            update_quadrature_points |'
p42635
aS'                                            update_JxW_values);'
p42636
aS'    const CopyData    sample_copy_data(dofs_per_cell);'
p42637
aS'    using ADHelper = Differentiation::AD::EnergyFunctional<'
p42638
aS'      Differentiation::AD::NumberTypes::sacado_dfad_dfad,'
p42639
aS'      double>;'
p42640
aS'    using ADNumberType = typename ADHelper::ad_type;'
p42641
aS'    const FEValuesExtractors::Scalar u_fe(0);'
p42642
aS'    const auto cell_worker = [&u_fe, this](const CellIteratorType &cell,'
p42643
aS'                                           ScratchData &           scratch_data,'
p42644
aS'                                           CopyData &              copy_data) {'
p42645
aS'      const auto &fe_values = scratch_data.reinit(cell);'
p42646
aS'      FullMatrix<double> &                  cell_matrix = copy_data.matrices[0];'
p42647
aS'      Vector<double> &                      cell_rhs    = copy_data.vectors[0];'
p42648
aS'      std::vector<types::global_dof_index> &local_dof_indices ='
p42649
aS'        copy_data.local_dof_indices[0];'
p42650
aS'      cell->get_dof_indices(local_dof_indices);'
p42651
aS'      const unsigned int n_independent_variables = local_dof_indices.size();'
p42652
aS'      ADHelper           ad_helper(n_independent_variables);'
p42653
aS'      ad_helper.register_dof_values(current_solution, local_dof_indices);'
p42654
aS'      const std::vector<ADNumberType> &dof_values_ad ='
p42655
aS'        ad_helper.get_sensitive_dof_values();'
p42656
aS'      std::vector<Tensor<1, dim, ADNumberType>> old_solution_gradients('
p42657
aS'        fe_values.n_quadrature_points);'
p42658
aS'      fe_values[u_fe].get_function_gradients_from_local_dof_values('
p42659
aS'        dof_values_ad, old_solution_gradients);'
p42660
aS'      ADNumberType energy_ad = ADNumberType(0.0);'
p42661
aS'      for (const unsigned int q : fe_values.quadrature_point_indices())'
p42662
aS'        {'
p42663
aS'          const ADNumberType psi = std::sqrt(1.0 + old_solution_gradients[q] *'
p42664
aS'                                                     old_solution_gradients[q]);'
p42665
aS'          energy_ad += psi * fe_values.JxW(q);'
p42666
aS'        }'
p42667
aS'      ad_helper.register_energy_functional(energy_ad);'
p42668
aS'      ad_helper.compute_residual(cell_rhs);'
p42669
aS'      cell_rhs *= -1.0;'
p42670
aS'      ad_helper.compute_linearization(cell_matrix);'
p42671
aS'    };'
p42672
aS'    const auto copier = [dofs_per_cell, this](const CopyData &copy_data) {'
p42673
aS'      const FullMatrix<double> &cell_matrix = copy_data.matrices[0];'
p42674
aS'      const Vector<double> &    cell_rhs    = copy_data.vectors[0];'
p42675
aS'      const std::vector<types::global_dof_index> &local_dof_indices ='
p42676
aS'        copy_data.local_dof_indices[0];'
p42677
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p42678
aS'        {'
p42679
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p42680
aS'            system_matrix.add(local_dof_indices[i],'
p42681
aS'                              local_dof_indices[j],'
p42682
aS'                              cell_matrix(i, j));'
p42683
aS'          system_rhs(local_dof_indices[i]) += cell_rhs(i);'
p42684
aS'        }'
p42685
aS'    };'
p42686
aS'    MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),'
p42687
aS'                          cell_worker,'
p42688
aS'                          copier,'
p42689
aS'                          sample_scratch_data,'
p42690
aS'                          sample_copy_data,'
p42691
aS'                          MeshWorker::assemble_own_cells);'
p42692
aS'    hanging_node_constraints.condense(system_matrix);'
p42693
aS'    hanging_node_constraints.condense(system_rhs);'
p42694
aS'    std::map<types::global_dof_index, double> boundary_values;'
p42695
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p42696
aS'                                             0,'
p42697
aS'                                             Functions::ZeroFunction<dim>(),'
p42698
aS'                                             boundary_values);'
p42699
aS'    MatrixTools::apply_boundary_values(boundary_values,'
p42700
aS'                                       system_matrix,'
p42701
aS'                                       newton_update,'
p42702
aS'                                       system_rhs);'
p42703
aS'  }'
p42704
aS'  template <int dim>'
p42705
aS'  void MinimalSurfaceProblem<dim>::solve()'
p42706
aS'  {'
p42707
aS'    SolverControl            solver_control(system_rhs.size(),'
p42708
aS'                                 system_rhs.l2_norm() * 1e-6);'
p42709
aS'    SolverCG<Vector<double>> solver(solver_control);'
p42710
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p42711
aS'    preconditioner.initialize(system_matrix, 1.2);'
p42712
aS'    solver.solve(system_matrix, newton_update, system_rhs, preconditioner);'
p42713
aS'    hanging_node_constraints.distribute(newton_update);'
p42714
aS'    const double alpha = determine_step_length();'
p42715
aS'    current_solution.add(alpha, newton_update);'
p42716
aS'  }'
p42717
aS'  template <int dim>'
p42718
aS'  void MinimalSurfaceProblem<dim>::refine_mesh()'
p42719
aS'  {'
p42720
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p42721
aS'    KellyErrorEstimator<dim>::estimate('
p42722
aS'      dof_handler,'
p42723
aS'      QGauss<dim - 1>(fe.degree + 1),'
p42724
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p42725
aS'      current_solution,'
p42726
aS'      estimated_error_per_cell);'
p42727
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p42728
aS'                                                    estimated_error_per_cell,'
p42729
aS'                                                    0.3,'
p42730
aS'                                                    0.03);'
p42731
aS'    triangulation.prepare_coarsening_and_refinement();'
p42732
aS'    SolutionTransfer<dim> solution_transfer(dof_handler);'
p42733
aS'    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);'
p42734
aS'    triangulation.execute_coarsening_and_refinement();'
p42735
aS'    dof_handler.distribute_dofs(fe);'
p42736
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p42737
aS'    solution_transfer.interpolate(current_solution, tmp);'
p42738
aS'    current_solution = tmp;'
p42739
aS'    hanging_node_constraints.clear();'
p42740
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p42741
aS'                                            hanging_node_constraints);'
p42742
aS'    hanging_node_constraints.close();'
p42743
aS'    set_boundary_values();'
p42744
aS'    setup_system(false);'
p42745
aS'  }'
p42746
aS'  template <int dim>'
p42747
aS'  void MinimalSurfaceProblem<dim>::set_boundary_values()'
p42748
aS'  {'
p42749
aS'    std::map<types::global_dof_index, double> boundary_values;'
p42750
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p42751
aS'                                             0,'
p42752
aS'                                             BoundaryValues<dim>(),'
p42753
aS'                                             boundary_values);'
p42754
aS'    for (auto &boundary_value : boundary_values)'
p42755
aS'      current_solution(boundary_value.first) = boundary_value.second;'
p42756
aS'    hanging_node_constraints.distribute(current_solution);'
p42757
aS'  }'
p42758
aS'  template <int dim>'
p42759
aS'  double MinimalSurfaceProblem<dim>::compute_residual(const double alpha) const'
p42760
aS'  {'
p42761
aS'    Vector<double> residual(dof_handler.n_dofs());'
p42762
aS'    Vector<double> evaluation_point(dof_handler.n_dofs());'
p42763
aS'    evaluation_point = current_solution;'
p42764
aS'    evaluation_point.add(alpha, newton_update);'
p42765
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p42766
aS'    FEValues<dim>     fe_values(fe,'
p42767
aS'                            quadrature_formula,'
p42768
aS'                            update_gradients | update_quadrature_points |'
p42769
aS'                              update_JxW_values);'
p42770
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p42771
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p42772
aS'    Vector<double>              cell_residual(dofs_per_cell);'
p42773
aS'    std::vector<Tensor<1, dim>> gradients(n_q_points);'
p42774
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p42775
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p42776
aS'      {'
p42777
aS'        cell_residual = 0;'
p42778
aS'        fe_values.reinit(cell);'
p42779
aS'        fe_values.get_function_gradients(evaluation_point, gradients);'
p42780
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p42781
aS'          {'
p42782
aS'            const double coeff ='
p42783
aS'              1.0 / std::sqrt(1.0 + gradients[q] * gradients[q]);'
p42784
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p42785
aS'              cell_residual(i) -= (fe_values.shape_grad(i, q) // \\nabla \\phi_i'
p42786
aS'          }'
p42787
aS'        cell->get_dof_indices(local_dof_indices);'
p42788
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p42789
aS'          residual(local_dof_indices[i]) += cell_residual(i);'
p42790
aS'      }'
p42791
aS'    hanging_node_constraints.condense(residual);'
p42792
aS'    for (types::global_dof_index i :'
p42793
aS'         DoFTools::extract_boundary_dofs(dof_handler))'
p42794
aS'      residual(i) = 0;'
p42795
aS'    return residual.l2_norm();'
p42796
aS'  }'
p42797
aS'  template <int dim>'
p42798
aS'  double MinimalSurfaceProblem<dim>::determine_step_length() const'
p42799
aS'  {'
p42800
aS'    return 0.1;'
p42801
aS'  }'
p42802
aS'  template <int dim>'
p42803
aS'  void MinimalSurfaceProblem<dim>::output_results('
p42804
aS'    const unsigned int refinement_cycle) const'
p42805
aS'  {'
p42806
aS'    DataOut<dim> data_out;'
p42807
aS'    data_out.attach_dof_handler(dof_handler);'
p42808
aS'    data_out.add_data_vector(current_solution, "solution");'
p42809
aS'    data_out.add_data_vector(newton_update, "update");'
p42810
aS'    data_out.build_patches();'
p42811
aS'    const std::string filename ='
p42812
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu";'
p42813
aS'    std::ofstream output(filename);'
p42814
aS'    data_out.write_vtu(output);'
p42815
aS'  }'
p42816
aS'  template <int dim>'
p42817
aS'  void MinimalSurfaceProblem<dim>::run(const int    formulation,'
p42818
aS'                                       const double tolerance)'
p42819
aS'  {'
p42820
aS'    std::cout << "******** Assembly approach ********" << std::endl;'
p42821
aS'    const std::array<std::string, 3> method_descriptions = {'
p42822
aS'      {"Unassisted implementation (full hand linearization).",'
p42823
aS'       "Automated linearization of the finite element residual.",'
p42824
aS'       "Automated computation of finite element residual and linearization using a variational formulation."}};'
p42825
aS'    AssertIndexRange(formulation, method_descriptions.size());'
p42826
aS'    std::cout << method_descriptions[formulation] << std::endl << std::endl;'
p42827
aS'    TimerOutput timer(std::cout, TimerOutput::summary, TimerOutput::wall_times);'
p42828
aS'    GridGenerator::hyper_ball(triangulation);'
p42829
aS'    triangulation.refine_global(2);'
p42830
aS'    setup_system(/*first time=*/true);'
p42831
aS'    set_boundary_values();'
p42832
aS'    double       last_residual_norm = std::numeric_limits<double>::max();'
p42833
aS'    unsigned int refinement_cycle   = 0;'
p42834
aS'    do'
p42835
aS'      {'
p42836
aS'        std::cout << "Mesh refinement step " << refinement_cycle << std::endl;'
p42837
aS'        if (refinement_cycle != 0)'
p42838
aS'          refine_mesh();'
p42839
aS'        std::cout << "  Initial residual: " << compute_residual(0) << std::endl;'
p42840
aS'        for (unsigned int inner_iteration = 0; inner_iteration < 5;'
p42841
aS'             ++inner_iteration)'
p42842
aS'          {'
p42843
aS'            {'
p42844
aS'              TimerOutput::Scope t(timer, "Assemble");'
p42845
aS'              if (formulation == 0)'
p42846
aS'                assemble_system_unassisted();'
p42847
aS'              else if (formulation == 1)'
p42848
aS'                assemble_system_with_residual_linearization();'
p42849
aS'              else if (formulation == 2)'
p42850
aS'                assemble_system_using_energy_functional();'
p42851
aS'              else'
p42852
aS'                AssertThrow(false, ExcNotImplemented());'
p42853
aS'            }'
p42854
aS'            last_residual_norm = system_rhs.l2_norm();'
p42855
aS'            {'
p42856
aS'              TimerOutput::Scope t(timer, "Solve");'
p42857
aS'              solve();'
p42858
aS'            }'
p42859
aS'            std::cout << "  Residual: " << compute_residual(0) << std::endl;'
p42860
aS'          }'
p42861
aS'        output_results(refinement_cycle);'
p42862
aS'        ++refinement_cycle;'
p42863
aS'        std::cout << std::endl;'
p42864
aS'      }'
p42865
aS'    while (last_residual_norm > tolerance);'
p42866
aS'  }'
p42867
aS'} // namespace Step72'
p42868
aS'int main(int argc, char *argv[])'
p42869
ag9
aS'  try'
p42870
aS'    {'
p42871
aS'      using namespace Step72;'
p42872
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);'
p42873
aS'      std::string prm_file;'
p42874
aS'      if (argc > 1)'
p42875
aS'        prm_file = argv[1];'
p42876
aS'      else'
p42877
aS'        prm_file = "parameters.prm";'
p42878
aS'      const MinimalSurfaceProblemParameters parameters;'
p42879
aS'      ParameterAcceptor::initialize(prm_file);'
p42880
aS'      MinimalSurfaceProblem<2> minimal_surface_problem_2d;'
p42881
aS'      minimal_surface_problem_2d.run(parameters.formulation,'
p42882
aS'                                     parameters.tolerance);'
p42883
aS'    }'
p42884
aS'  catch (std::exception &exc)'
p42885
aS'    {'
p42886
aS'      std::cerr << std::endl'
p42887
aS'                << std::endl'
p42888
aS'                << "----------------------------------------------------"'
p42889
aS'                << std::endl;'
p42890
aS'      std::cerr << "Exception on processing: " << std::endl'
p42891
aS'                << exc.what() << std::endl'
p42892
aS'                << "Aborting!" << std::endl'
p42893
aS'                << "----------------------------------------------------"'
p42894
aS'                << std::endl;'
p42895
aS'      return 1;'
p42896
aS'    }'
p42897
aS'  catch (...)'
p42898
aS'    {'
p42899
aS'      std::cerr << std::endl'
p42900
aS'                << std::endl'
p42901
aS'                << "----------------------------------------------------"'
p42902
aS'                << std::endl;'
p42903
aS'      std::cerr << "Unknown exception!" << std::endl'
p42904
aS'                << "Aborting!" << std::endl'
p42905
aS'                << "----------------------------------------------------"'
p42906
aS'                << std::endl;'
p42907
aS'      return 1;'
p42908
aS'    }'
p42909
aS'  return 0;'
p42910
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p42911
aS'#include <deal.II/base/function.h>'
p42912
aS'#include <deal.II/base/function_lib.h>'
p42913
aS'#include <deal.II/lac/vector.h>'
p42914
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p42915
aS'#include <deal.II/lac/sparse_matrix.h>'
p42916
aS'#include <deal.II/lac/sparse_direct.h>'
p42917
aS'#include <deal.II/grid/tria.h>'
p42918
aS'#include <deal.II/grid/grid_generator.h>'
p42919
aS'#include <deal.II/grid/grid_out.h>'
p42920
aS'#include <deal.II/grid/grid_refinement.h>'
p42921
aS'#include <deal.II/fe/fe_values.h>'
p42922
aS'#include <deal.II/dofs/dof_handler.h>'
p42923
aS'#include <deal.II/dofs/dof_tools.h>'
p42924
aS'#include <deal.II/numerics/data_out.h>'
p42925
aS'#include <deal.II/fe/mapping_q1.h>'
p42926
aS'#include <deal.II/fe/fe_dgq.h>'
p42927
aS'#include <deal.II/fe/fe_interface_values.h>'
p42928
aS'#include <deal.II/numerics/derivative_approximation.h>'
p42929
aS'#include <deal.II/numerics/vector_tools.h>'
p42930
aS'#include <deal.II/base/convergence_table.h>'
p42931
aS'#include <deal.II/meshworker/copy_data.h>'
p42932
aS'#include <deal.II/meshworker/mesh_loop.h>'
p42933
aS'#include <deal.II/meshworker/scratch_data.h>'
p42934
aS'namespace Step74'
p42935
ag9
aS'  using namespace dealii;'
p42936
aS'  enum class TestCase'
p42937
aS'  {'
p42938
aS'    convergence_rate,'
p42939
aS'    l_singularity'
p42940
aS'  };'
p42941
aS'  template <int dim>'
p42942
aS'  class SmoothSolution : public Function<dim>'
p42943
aS'  {'
p42944
aS'  public:'
p42945
aS'    SmoothSolution()'
p42946
aS'      : Function<dim>()'
p42947
aS'    {}'
p42948
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p42949
aS'                            std::vector<double> &          values,'
p42950
aS'                            const unsigned int component = 0) const override;'
p42951
aS'    virtual Tensor<1, dim>'
p42952
aS'    gradient(const Point<dim> & point,'
p42953
aS'             const unsigned int component = 0) const override;'
p42954
aS'  };'
p42955
aS'  template <int dim>'
p42956
aS'  void SmoothSolution<dim>::value_list(const std::vector<Point<dim>> &points,'
p42957
aS'                                       std::vector<double> &          values,'
p42958
aS'                                       const unsigned int /*component*/) const'
p42959
aS'  {'
p42960
aS'    using numbers::PI;'
p42961
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p42962
aS'      values[i] ='
p42963
aS'        std::sin(2. * PI * points[i][0]) * std::sin(2. * PI * points[i][1]);'
p42964
aS'  }'
p42965
aS'  template <int dim>'
p42966
aS'  Tensor<1, dim>'
p42967
aS'  SmoothSolution<dim>::gradient(const Point<dim> &point,'
p42968
aS'                                const unsigned int /*component*/) const'
p42969
aS'  {'
p42970
aS'    Tensor<1, dim> return_value;'
p42971
aS'    using numbers::PI;'
p42972
aS'    return_value[0] ='
p42973
aS'      2. * PI * std::cos(2. * PI * point[0]) * std::sin(2. * PI * point[1]);'
p42974
aS'    return_value[1] ='
p42975
aS'      2. * PI * std::sin(2. * PI * point[0]) * std::cos(2. * PI * point[1]);'
p42976
aS'    return return_value;'
p42977
aS'  }'
p42978
aS'  template <int dim>'
p42979
aS'  class SmoothRightHandSide : public Function<dim>'
p42980
aS'  {'
p42981
aS'  public:'
p42982
aS'    SmoothRightHandSide()'
p42983
aS'      : Function<dim>()'
p42984
aS'    {}'
p42985
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p42986
aS'                            std::vector<double> &          values,'
p42987
aS'                            const unsigned int /*component*/) const override;'
p42988
aS'  };'
p42989
aS'  template <int dim>'
p42990
aS'  void'
p42991
aS'  SmoothRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,'
p42992
aS'                                       std::vector<double> &          values,'
p42993
aS'                                       const unsigned int /*component*/) const'
p42994
aS'  {'
p42995
aS'    using numbers::PI;'
p42996
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p42997
aS'      values[i] = 8. * PI * PI * std::sin(2. * PI * points[i][0]) *'
p42998
aS'                  std::sin(2. * PI * points[i][1]);'
p42999
aS'  }'
p43000
aS'  template <int dim>'
p43001
aS'  class SingularRightHandSide : public Function<dim>'
p43002
aS'  {'
p43003
aS'  public:'
p43004
aS'    SingularRightHandSide()'
p43005
aS'      : Function<dim>()'
p43006
aS'    {}'
p43007
aS'    virtual void value_list(const std::vector<Point<dim>> &points,'
p43008
aS'                            std::vector<double> &          values,'
p43009
aS'                            const unsigned int /*component*/) const override;'
p43010
aS'  private:'
p43011
aS'    const Functions::LSingularityFunction ref;'
p43012
aS'  };'
p43013
aS'  template <int dim>'
p43014
aS'  void'
p43015
aS'  SingularRightHandSide<dim>::value_list(const std::vector<Point<dim>> &points,'
p43016
aS'                                         std::vector<double> &          values,'
p43017
aS'                                         const unsigned int /*component*/) const'
p43018
aS'  {'
p43019
aS'    for (unsigned int i = 0; i < values.size(); ++i)'
p43020
aS'      values[i] = -ref.laplacian(points[i]);'
p43021
aS'  }'
p43022
aS'  template <int dim>'
p43023
aS'  void get_function_jump(const FEInterfaceValues<dim> &fe_iv,'
p43024
aS'                         const Vector<double> &        solution,'
p43025
aS'                         std::vector<double> &         jump)'
p43026
aS'  {'
p43027
aS'    const unsigned int                 n_q = fe_iv.n_quadrature_points;'
p43028
aS'    std::array<std::vector<double>, 2> face_values;'
p43029
aS'    jump.resize(n_q);'
p43030
aS'    for (unsigned int i = 0; i < 2; ++i)'
p43031
aS'      {'
p43032
aS'        face_values[i].resize(n_q);'
p43033
aS'        fe_iv.get_fe_face_values(i).get_function_values(solution,'
p43034
aS'                                                        face_values[i]);'
p43035
aS'      }'
p43036
aS'    for (unsigned int q = 0; q < n_q; ++q)'
p43037
aS'      jump[q] = face_values[0][q] - face_values[1][q];'
p43038
aS'  }'
p43039
aS'  template <int dim>'
p43040
aS'  void get_function_gradient_jump(const FEInterfaceValues<dim> &fe_iv,'
p43041
aS'                                  const Vector<double> &        solution,'
p43042
aS'                                  std::vector<Tensor<1, dim>> & gradient_jump)'
p43043
aS'  {'
p43044
aS'    const unsigned int          n_q = fe_iv.n_quadrature_points;'
p43045
aS'    std::vector<Tensor<1, dim>> face_gradients[2];'
p43046
aS'    gradient_jump.resize(n_q);'
p43047
aS'    for (unsigned int i = 0; i < 2; ++i)'
p43048
aS'      {'
p43049
aS'        face_gradients[i].resize(n_q);'
p43050
aS'        fe_iv.get_fe_face_values(i).get_function_gradients(solution,'
p43051
aS'                                                           face_gradients[i]);'
p43052
aS'      }'
p43053
aS'    for (unsigned int q = 0; q < n_q; ++q)'
p43054
aS'      gradient_jump[q] = face_gradients[0][q] - face_gradients[1][q];'
p43055
aS'  }'
p43056
aS'  double get_penalty_factor(const unsigned int fe_degree,'
p43057
aS'                            const double       cell_extent_left,'
p43058
aS'                            const double       cell_extent_right)'
p43059
aS'  {'
p43060
aS'    const unsigned int degree = std::max(1U, fe_degree);'
p43061
aS'    return degree * (degree + 1.) * 0.5 *'
p43062
aS'  }'
p43063
aS'  struct CopyDataFace'
p43064
aS'  {'
p43065
aS'    FullMatrix<double>                   cell_matrix;'
p43066
aS'    std::vector<types::global_dof_index> joint_dof_indices;'
p43067
aS'    std::array<double, 2>                values;'
p43068
aS'    std::array<unsigned int, 2>          cell_indices;'
p43069
aS'  };'
p43070
aS'  struct CopyData'
p43071
aS'  {'
p43072
aS'    FullMatrix<double>                   cell_matrix;'
p43073
aS'    Vector<double>                       cell_rhs;'
p43074
aS'    std::vector<types::global_dof_index> local_dof_indices;'
p43075
aS'    std::vector<CopyDataFace>            face_data;'
p43076
aS'    double                               value;'
p43077
aS'    unsigned int                         cell_index;'
p43078
aS'    template <class Iterator>'
p43079
aS'    void reinit(const Iterator &cell, const unsigned int dofs_per_cell)'
p43080
aS'    {'
p43081
aS'      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p43082
aS'      cell_rhs.reinit(dofs_per_cell);'
p43083
aS'      local_dof_indices.resize(dofs_per_cell);'
p43084
aS'      cell->get_dof_indices(local_dof_indices);'
p43085
aS'    }'
p43086
aS'  };'
p43087
aS'  template <int dim>'
p43088
aS'  class SIPGLaplace'
p43089
aS'  {'
p43090
aS'  public:'
p43091
aS'    SIPGLaplace(const TestCase &test_case);'
p43092
aS'    void run();'
p43093
aS'  private:'
p43094
aS'    void setup_system();'
p43095
aS'    void assemble_system();'
p43096
aS'    void solve();'
p43097
aS'    void refine_grid();'
p43098
aS'    void output_results(const unsigned int cycle) const;'
p43099
aS'    void   compute_errors();'
p43100
aS'    void   compute_error_estimate();'
p43101
aS'    double compute_energy_norm_error();'
p43102
aS'    Triangulation<dim>    triangulation;'
p43103
aS'    const unsigned int    degree;'
p43104
aS'    const QGauss<dim>     quadrature;'
p43105
aS'    const QGauss<dim - 1> face_quadrature;'
p43106
aS'    const QGauss<dim>     quadrature_overintegration;'
p43107
aS'    const QGauss<dim - 1> face_quadrature_overintegration;'
p43108
aS'    const MappingQ1<dim>  mapping;'
p43109
aS'    using ScratchData = MeshWorker::ScratchData<dim>;'
p43110
aS'    const FE_DGQ<dim> fe;'
p43111
aS'    DoFHandler<dim>   dof_handler;'
p43112
aS'    SparsityPattern      sparsity_pattern;'
p43113
aS'    SparseMatrix<double> system_matrix;'
p43114
aS'    Vector<double>       solution;'
p43115
aS'    Vector<double>       system_rhs;'
p43116
aS'    Vector<double> estimated_error_square_per_cell;'
p43117
aS'    Vector<double> energy_norm_square_per_cell;'
p43118
aS'    ConvergenceTable convergence_table;'
p43119
aS'    const double diffusion_coefficient = 1.;'
p43120
aS'    const TestCase                       test_case;'
p43121
aS'    std::unique_ptr<const Function<dim>> exact_solution;'
p43122
aS'    std::unique_ptr<const Function<dim>> rhs_function;'
p43123
aS'  };'
p43124
aS'  template <int dim>'
p43125
aS'  SIPGLaplace<dim>::SIPGLaplace(const TestCase &test_case)'
p43126
aS'    : degree(3)'
p43127
aS'    , quadrature(degree + 1)'
p43128
aS'    , face_quadrature(degree + 1)'
p43129
aS'    , quadrature_overintegration(degree + 2)'
p43130
aS'    , face_quadrature_overintegration(degree + 2)'
p43131
aS'    , mapping()'
p43132
aS'    , fe(degree)'
p43133
aS'    , dof_handler(triangulation)'
p43134
aS'    , test_case(test_case)'
p43135
aS'  {'
p43136
aS'    if (test_case == TestCase::convergence_rate)'
p43137
aS'      {'
p43138
aS'        exact_solution = std::make_unique<const SmoothSolution<dim>>();'
p43139
aS'        rhs_function   = std::make_unique<const SmoothRightHandSide<dim>>();'
p43140
aS'      }'
p43141
aS'    else if (test_case == TestCase::l_singularity)'
p43142
aS'      {'
p43143
aS'        exact_solution ='
p43144
aS'          std::make_unique<const Functions::LSingularityFunction>();'
p43145
aS'        rhs_function = std::make_unique<const SingularRightHandSide<dim>>();'
p43146
aS'      }'
p43147
aS'    else'
p43148
aS'      AssertThrow(false, ExcNotImplemented());'
p43149
aS'  }'
p43150
aS'  template <int dim>'
p43151
aS'  void SIPGLaplace<dim>::setup_system()'
p43152
aS'  {'
p43153
aS'    dof_handler.distribute_dofs(fe);'
p43154
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p43155
aS'    DoFTools::make_flux_sparsity_pattern(dof_handler, dsp);'
p43156
aS'    sparsity_pattern.copy_from(dsp);'
p43157
aS'    system_matrix.reinit(sparsity_pattern);'
p43158
aS'    solution.reinit(dof_handler.n_dofs());'
p43159
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p43160
aS'  }'
p43161
aS'  template <int dim>'
p43162
aS'  void SIPGLaplace<dim>::assemble_system()'
p43163
aS'  {'
p43164
aS'    const auto cell_worker ='
p43165
aS'      [&](const auto &cell, auto &scratch_data, auto &copy_data) {'
p43166
aS'        const FEValues<dim> &fe_v          = scratch_data.reinit(cell);'
p43167
aS'        const unsigned int   dofs_per_cell = fe_v.dofs_per_cell;'
p43168
aS'        copy_data.reinit(cell, dofs_per_cell);'
p43169
aS'        const auto &       q_points    = scratch_data.get_quadrature_points();'
p43170
aS'        const unsigned int n_q_points  = q_points.size();'
p43171
aS'        const std::vector<double> &JxW = scratch_data.get_JxW_values();'
p43172
aS'        std::vector<double> rhs(n_q_points);'
p43173
aS'        rhs_function->value_list(q_points, rhs);'
p43174
aS'        for (unsigned int point = 0; point < n_q_points; ++point)'
p43175
aS'          for (unsigned int i = 0; i < fe_v.dofs_per_cell; ++i)'
p43176
aS'            {'
p43177
aS'              for (unsigned int j = 0; j < fe_v.dofs_per_cell; ++j)'
p43178
aS'                copy_data.cell_matrix(i, j) +='
p43179
aS'                  diffusion_coefficient *     // nu'
p43180
aS'                  fe_v.shape_grad(i, point) * // grad v_h'
p43181
aS'                  fe_v.shape_grad(j, point) * // grad u_h'
p43182
aS'                  JxW[point];                 // dx'
p43183
aS'              copy_data.cell_rhs(i) += fe_v.shape_value(i, point) * // v_h'
p43184
aS'                                       rhs[point] *                 // f'
p43185
aS'                                       JxW[point];                  // dx'
p43186
aS'            }'
p43187
aS'      };'
p43188
aS'    const auto boundary_worker = [&](const auto &        cell,'
p43189
aS'                                     const unsigned int &face_no,'
p43190
aS'                                     auto &              scratch_data,'
p43191
aS'                                     auto &              copy_data) {'
p43192
aS'      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);'
p43193
aS'      const auto &       q_points      = scratch_data.get_quadrature_points();'
p43194
aS'      const unsigned int n_q_points    = q_points.size();'
p43195
aS'      const unsigned int dofs_per_cell = fe_fv.dofs_per_cell;'
p43196
aS'      const std::vector<double> &        JxW = scratch_data.get_JxW_values();'
p43197
aS'      const std::vector<Tensor<1, dim>> &normals ='
p43198
aS'        scratch_data.get_normal_vectors();'
p43199
aS'      std::vector<double> g(n_q_points);'
p43200
aS'      exact_solution->value_list(q_points, g);'
p43201
aS'      const double extent1 = cell->measure() / cell->face(face_no)->measure();'
p43202
aS'      const double penalty = get_penalty_factor(degree, extent1, extent1);'
p43203
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p43204
aS'        {'
p43205
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p43206
aS'            for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p43207
aS'              copy_data.cell_matrix(i, j) +='
p43208
aS'                   fe_fv.shape_value(i, point) * // v_h'
p43209
aS'                    normals[point])              //  n)'
p43210
aS'                 - diffusion_coefficient *         // - nu'
p43211
aS'                      normals[point]) *            //  n)'
p43212
aS'                     fe_fv.shape_value(j, point)   // u_h'
p43213
aS'                 + diffusion_coefficient * penalty * // + nu sigma'
p43214
aS'                     fe_fv.shape_value(i, point) *   // v_h'
p43215
aS'                     fe_fv.shape_value(j, point)     // u_h'
p43216
aS'                JxW[point]; // dx'
p43217
aS'          for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p43218
aS'            copy_data.cell_rhs(i) +='
p43219
aS'                  normals[point]) *            //  n)'
p43220
aS'                 g[point]                      // g'
p43221
aS'               + diffusion_coefficient * penalty *        // + nu sigma'
p43222
aS'                   fe_fv.shape_value(i, point) * g[point] // v_h g'
p43223
aS'              JxW[point]; // dx'
p43224
aS'        }'
p43225
aS'    };'
p43226
aS'    const auto face_worker = [&](const auto &        cell,'
p43227
aS'                                 const unsigned int &f,'
p43228
aS'                                 const unsigned int &sf,'
p43229
aS'                                 const auto &        ncell,'
p43230
aS'                                 const unsigned int &nf,'
p43231
aS'                                 const unsigned int &nsf,'
p43232
aS'                                 auto &              scratch_data,'
p43233
aS'                                 auto &              copy_data) {'
p43234
aS'      const FEInterfaceValues<dim> &fe_iv ='
p43235
aS'        scratch_data.reinit(cell, f, sf, ncell, nf, nsf);'
p43236
aS'      const auto &       q_points   = fe_iv.get_quadrature_points();'
p43237
aS'      const unsigned int n_q_points = q_points.size();'
p43238
aS'      copy_data.face_data.emplace_back();'
p43239
aS'      CopyDataFace &     copy_data_face = copy_data.face_data.back();'
p43240
aS'      const unsigned int n_dofs_face    = fe_iv.n_current_interface_dofs();'
p43241
aS'      copy_data_face.joint_dof_indices  = fe_iv.get_interface_dof_indices();'
p43242
aS'      copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face);'
p43243
aS'      const std::vector<double> &        JxW     = fe_iv.get_JxW_values();'
p43244
aS'      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();'
p43245
aS'      const double extent1 = cell->measure() / cell->face(f)->measure();'
p43246
aS'      const double extent2 = ncell->measure() / ncell->face(nf)->measure();'
p43247
aS'      const double penalty = get_penalty_factor(degree, extent1, extent2);'
p43248
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p43249
aS'        {'
p43250
aS'          for (unsigned int i = 0; i < n_dofs_face; ++i)'
p43251
aS'            for (unsigned int j = 0; j < n_dofs_face; ++j)'
p43252
aS'              copy_data_face.cell_matrix(i, j) +='
p43253
aS'                   fe_iv.jump(i, point) *              // [v_h]'
p43254
aS'                    normals[point])                    //  n)'
p43255
aS'                 - diffusion_coefficient *               // - nu'
p43256
aS'                      normals[point]) *                  //  n)'
p43257
aS'                     fe_iv.jump(j, point)                // [u_h]'
p43258
aS'                 + diffusion_coefficient * penalty * // + nu sigma'
p43259
aS'                     fe_iv.jump(i, point) *          // [v_h]'
p43260
aS'                     fe_iv.jump(j, point)            // [u_h]'
p43261
aS'                JxW[point]; // dx'
p43262
aS'        }'
p43263
aS'    };'
p43264
aS'    AffineConstraints<double> constraints;'
p43265
aS'    constraints.close();'
p43266
aS'    const auto copier = [&](const auto &c) {'
p43267
aS'      constraints.distribute_local_to_global(c.cell_matrix,'
p43268
aS'                                             c.cell_rhs,'
p43269
aS'                                             c.local_dof_indices,'
p43270
aS'                                             system_matrix,'
p43271
aS'                                             system_rhs);'
p43272
aS'      for (auto &cdf : c.face_data)'
p43273
aS'        {'
p43274
aS'          constraints.distribute_local_to_global(cdf.cell_matrix,'
p43275
aS'                                                 cdf.joint_dof_indices,'
p43276
aS'                                                 system_matrix);'
p43277
aS'        }'
p43278
aS'    };'
p43279
aS'    const UpdateFlags cell_flags = update_values | update_gradients |'
p43280
aS'                                   update_quadrature_points | update_JxW_values;'
p43281
aS'    const UpdateFlags face_flags = update_values | update_gradients |'
p43282
aS'                                   update_quadrature_points |'
p43283
aS'                                   update_normal_vectors | update_JxW_values;'
p43284
aS'    ScratchData scratch_data('
p43285
aS'      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);'
p43286
aS'    CopyData copy_data;'
p43287
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p43288
aS'                          dof_handler.end(),'
p43289
aS'                          cell_worker,'
p43290
aS'                          copier,'
p43291
aS'                          scratch_data,'
p43292
aS'                          copy_data,'
p43293
aS'                          MeshWorker::assemble_own_cells |'
p43294
aS'                            MeshWorker::assemble_boundary_faces |'
p43295
aS'                            MeshWorker::assemble_own_interior_faces_once,'
p43296
aS'                          boundary_worker,'
p43297
aS'                          face_worker);'
p43298
aS'  }'
p43299
aS'  template <int dim>'
p43300
aS'  void SIPGLaplace<dim>::solve()'
p43301
aS'  {'
p43302
aS'    SparseDirectUMFPACK A_direct;'
p43303
aS'    A_direct.initialize(system_matrix);'
p43304
aS'    A_direct.vmult(solution, system_rhs);'
p43305
aS'  }'
p43306
aS'  template <int dim>'
p43307
aS'  void SIPGLaplace<dim>::output_results(const unsigned int cycle) const'
p43308
aS'  {'
p43309
aS'    const std::string filename = "sol_Q" + Utilities::int_to_string(degree, 1) +'
p43310
aS'                                 "-" + Utilities::int_to_string(cycle, 2) +'
p43311
aS'                                 ".vtu";'
p43312
aS'    std::ofstream output(filename);'
p43313
aS'    DataOut<dim> data_out;'
p43314
aS'    data_out.attach_dof_handler(dof_handler);'
p43315
aS'    data_out.add_data_vector(solution, "u", DataOut<dim>::type_dof_data);'
p43316
aS'    data_out.build_patches(mapping);'
p43317
aS'    data_out.write_vtu(output);'
p43318
aS'  }'
p43319
aS'  template <int dim>'
p43320
aS'  void SIPGLaplace<dim>::compute_error_estimate()'
p43321
aS'  {'
p43322
aS'    const auto cell_worker ='
p43323
aS'      [&](const auto &cell, auto &scratch_data, auto &copy_data) {'
p43324
aS'        const FEValues<dim> &fe_v = scratch_data.reinit(cell);'
p43325
aS'        copy_data.cell_index = cell->active_cell_index();'
p43326
aS'        const auto &               q_points   = fe_v.get_quadrature_points();'
p43327
aS'        const unsigned int         n_q_points = q_points.size();'
p43328
aS'        const std::vector<double> &JxW        = fe_v.get_JxW_values();'
p43329
aS'        std::vector<Tensor<2, dim>> hessians(n_q_points);'
p43330
aS'        fe_v.get_function_hessians(solution, hessians);'
p43331
aS'        std::vector<double> rhs(n_q_points);'
p43332
aS'        rhs_function->value_list(q_points, rhs);'
p43333
aS'        const double hk                   = cell->diameter();'
p43334
aS'        double       residual_norm_square = 0;'
p43335
aS'        for (unsigned int point = 0; point < n_q_points; ++point)'
p43336
aS'          {'
p43337
aS'            const double residual ='
p43338
aS'              rhs[point] + diffusion_coefficient * trace(hessians[point]);'
p43339
aS'            residual_norm_square += residual * residual * JxW[point];'
p43340
aS'          }'
p43341
aS'        copy_data.value = hk * hk * residual_norm_square;'
p43342
aS'      };'
p43343
aS'    const auto boundary_worker = [&](const auto &        cell,'
p43344
aS'                                     const unsigned int &face_no,'
p43345
aS'                                     auto &              scratch_data,'
p43346
aS'                                     auto &              copy_data) {'
p43347
aS'      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);'
p43348
aS'      const auto &   q_points   = fe_fv.get_quadrature_points();'
p43349
aS'      const unsigned n_q_points = q_points.size();'
p43350
aS'      const std::vector<double> &JxW = fe_fv.get_JxW_values();'
p43351
aS'      std::vector<double> g(n_q_points);'
p43352
aS'      exact_solution->value_list(q_points, g);'
p43353
aS'      std::vector<double> sol_u(n_q_points);'
p43354
aS'      fe_fv.get_function_values(solution, sol_u);'
p43355
aS'      const double extent1 = cell->measure() / cell->face(face_no)->measure();'
p43356
aS'      const double penalty = get_penalty_factor(degree, extent1, extent1);'
p43357
aS'      double difference_norm_square = 0.;'
p43358
aS'      for (unsigned int point = 0; point < q_points.size(); ++point)'
p43359
aS'        {'
p43360
aS'          const double diff = (g[point] - sol_u[point]);'
p43361
aS'          difference_norm_square += diff * diff * JxW[point];'
p43362
aS'        }'
p43363
aS'      copy_data.value += penalty * difference_norm_square;'
p43364
aS'    };'
p43365
aS'    const auto face_worker = [&](const auto &        cell,'
p43366
aS'                                 const unsigned int &f,'
p43367
aS'                                 const unsigned int &sf,'
p43368
aS'                                 const auto &        ncell,'
p43369
aS'                                 const unsigned int &nf,'
p43370
aS'                                 const unsigned int &nsf,'
p43371
aS'                                 auto &              scratch_data,'
p43372
aS'                                 auto &              copy_data) {'
p43373
aS'      const FEInterfaceValues<dim> &fe_iv ='
p43374
aS'        scratch_data.reinit(cell, f, sf, ncell, nf, nsf);'
p43375
aS'      copy_data.face_data.emplace_back();'
p43376
aS'      CopyDataFace &copy_data_face = copy_data.face_data.back();'
p43377
aS'      copy_data_face.cell_indices[0] = cell->active_cell_index();'
p43378
aS'      copy_data_face.cell_indices[1] = ncell->active_cell_index();'
p43379
aS'      const std::vector<double> &        JxW     = fe_iv.get_JxW_values();'
p43380
aS'      const std::vector<Tensor<1, dim>> &normals = fe_iv.get_normal_vectors();'
p43381
aS'      const auto &       q_points   = fe_iv.get_quadrature_points();'
p43382
aS'      const unsigned int n_q_points = q_points.size();'
p43383
aS'      std::vector<double> jump(n_q_points);'
p43384
aS'      get_function_jump(fe_iv, solution, jump);'
p43385
aS'      std::vector<Tensor<1, dim>> grad_jump(n_q_points);'
p43386
aS'      get_function_gradient_jump(fe_iv, solution, grad_jump);'
p43387
aS'      const double h = cell->face(f)->diameter();'
p43388
aS'      const double extent1 = cell->measure() / cell->face(f)->measure();'
p43389
aS'      const double extent2 = ncell->measure() / ncell->face(nf)->measure();'
p43390
aS'      const double penalty = get_penalty_factor(degree, extent1, extent2);'
p43391
aS'      double flux_jump_square = 0;'
p43392
aS'      double u_jump_square    = 0;'
p43393
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p43394
aS'        {'
p43395
aS'          u_jump_square += jump[point] * jump[point] * JxW[point];'
p43396
aS'          const double flux_jump = grad_jump[point] * normals[point];'
p43397
aS'          flux_jump_square +='
p43398
aS'            diffusion_coefficient * flux_jump * flux_jump * JxW[point];'
p43399
aS'        }'
p43400
aS'      copy_data_face.values[0] ='
p43401
aS'        0.5 * h * (flux_jump_square + penalty * u_jump_square);'
p43402
aS'      copy_data_face.values[1] = copy_data_face.values[0];'
p43403
aS'    };'
p43404
aS'    const auto copier = [&](const auto &copy_data) {'
p43405
aS'      if (copy_data.cell_index != numbers::invalid_unsigned_int)'
p43406
aS'        estimated_error_square_per_cell[copy_data.cell_index] +='
p43407
aS'          copy_data.value;'
p43408
aS'      for (auto &cdf : copy_data.face_data)'
p43409
aS'        for (unsigned int j = 0; j < 2; ++j)'
p43410
aS'          estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];'
p43411
aS'    };'
p43412
aS'    estimated_error_square_per_cell.reinit(triangulation.n_active_cells());'
p43413
aS'    const UpdateFlags cell_flags ='
p43414
aS'      update_hessians | update_quadrature_points | update_JxW_values;'
p43415
aS'    const UpdateFlags face_flags = update_values | update_gradients |'
p43416
aS'                                   update_quadrature_points |'
p43417
aS'                                   update_JxW_values | update_normal_vectors;'
p43418
aS'    ScratchData scratch_data('
p43419
aS'      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);'
p43420
aS'    CopyData copy_data;'
p43421
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p43422
aS'                          dof_handler.end(),'
p43423
aS'                          cell_worker,'
p43424
aS'                          copier,'
p43425
aS'                          scratch_data,'
p43426
aS'                          copy_data,'
p43427
aS'                          MeshWorker::assemble_own_cells |'
p43428
aS'                            MeshWorker::assemble_own_interior_faces_once |'
p43429
aS'                            MeshWorker::assemble_boundary_faces,'
p43430
aS'                          boundary_worker,'
p43431
aS'                          face_worker);'
p43432
aS'  }'
p43433
aS'  template <int dim>'
p43434
aS'  double SIPGLaplace<dim>::compute_energy_norm_error()'
p43435
aS'  {'
p43436
aS'    energy_norm_square_per_cell.reinit(triangulation.n_active_cells());'
p43437
aS'    const auto cell_worker ='
p43438
aS'      [&](const auto &cell, auto &scratch_data, auto &copy_data) {'
p43439
aS'        const FEValues<dim> &fe_v = scratch_data.reinit(cell);'
p43440
aS'        copy_data.cell_index = cell->active_cell_index();'
p43441
aS'        const auto &               q_points   = fe_v.get_quadrature_points();'
p43442
aS'        const unsigned int         n_q_points = q_points.size();'
p43443
aS'        const std::vector<double> &JxW        = fe_v.get_JxW_values();'
p43444
aS'        std::vector<Tensor<1, dim>> grad_u(n_q_points);'
p43445
aS'        fe_v.get_function_gradients(solution, grad_u);'
p43446
aS'        std::vector<Tensor<1, dim>> grad_exact(n_q_points);'
p43447
aS'        exact_solution->gradient_list(q_points, grad_exact);'
p43448
aS'        double norm_square = 0;'
p43449
aS'        for (unsigned int point = 0; point < n_q_points; ++point)'
p43450
aS'          {'
p43451
aS'            norm_square +='
p43452
aS'          }'
p43453
aS'        copy_data.value = diffusion_coefficient * norm_square;'
p43454
aS'      };'
p43455
aS'    const auto boundary_worker = [&](const auto &        cell,'
p43456
aS'                                     const unsigned int &face_no,'
p43457
aS'                                     auto &              scratch_data,'
p43458
aS'                                     auto &              copy_data) {'
p43459
aS'      const FEFaceValuesBase<dim> &fe_fv = scratch_data.reinit(cell, face_no);'
p43460
aS'      const auto &   q_points   = fe_fv.get_quadrature_points();'
p43461
aS'      const unsigned n_q_points = q_points.size();'
p43462
aS'      const std::vector<double> &JxW = fe_fv.get_JxW_values();'
p43463
aS'      std::vector<double> g(n_q_points);'
p43464
aS'      exact_solution->value_list(q_points, g);'
p43465
aS'      std::vector<double> sol_u(n_q_points);'
p43466
aS'      fe_fv.get_function_values(solution, sol_u);'
p43467
aS'      const double extent1 = cell->measure() / cell->face(face_no)->measure();'
p43468
aS'      const double penalty = get_penalty_factor(degree, extent1, extent1);'
p43469
aS'      double difference_norm_square = 0.;'
p43470
aS'      for (unsigned int point = 0; point < q_points.size(); ++point)'
p43471
aS'        {'
p43472
aS'          const double diff = (g[point] - sol_u[point]);'
p43473
aS'          difference_norm_square += diff * diff * JxW[point];'
p43474
aS'        }'
p43475
aS'      copy_data.value += penalty * difference_norm_square;'
p43476
aS'    };'
p43477
aS'    const auto face_worker = [&](const auto &        cell,'
p43478
aS'                                 const unsigned int &f,'
p43479
aS'                                 const unsigned int &sf,'
p43480
aS'                                 const auto &        ncell,'
p43481
aS'                                 const unsigned int &nf,'
p43482
aS'                                 const unsigned int &nsf,'
p43483
aS'                                 auto &              scratch_data,'
p43484
aS'                                 auto &              copy_data) {'
p43485
aS'      const FEInterfaceValues<dim> &fe_iv ='
p43486
aS'        scratch_data.reinit(cell, f, sf, ncell, nf, nsf);'
p43487
aS'      copy_data.face_data.emplace_back();'
p43488
aS'      CopyDataFace &copy_data_face = copy_data.face_data.back();'
p43489
aS'      copy_data_face.cell_indices[0] = cell->active_cell_index();'
p43490
aS'      copy_data_face.cell_indices[1] = ncell->active_cell_index();'
p43491
aS'      const std::vector<double> &JxW = fe_iv.get_JxW_values();'
p43492
aS'      const auto &       q_points   = fe_iv.get_quadrature_points();'
p43493
aS'      const unsigned int n_q_points = q_points.size();'
p43494
aS'      std::vector<double> jump(n_q_points);'
p43495
aS'      get_function_jump(fe_iv, solution, jump);'
p43496
aS'      const double extent1 = cell->measure() / cell->face(f)->measure();'
p43497
aS'      const double extent2 = ncell->measure() / ncell->face(nf)->measure();'
p43498
aS'      const double penalty = get_penalty_factor(degree, extent1, extent2);'
p43499
aS'      double u_jump_square = 0;'
p43500
aS'      for (unsigned int point = 0; point < n_q_points; ++point)'
p43501
aS'        {'
p43502
aS'          u_jump_square += jump[point] * jump[point] * JxW[point];'
p43503
aS'        }'
p43504
aS'      copy_data_face.values[0] = 0.5 * penalty * u_jump_square;'
p43505
aS'      copy_data_face.values[1] = copy_data_face.values[0];'
p43506
aS'    };'
p43507
aS'    const auto copier = [&](const auto &copy_data) {'
p43508
aS'      if (copy_data.cell_index != numbers::invalid_unsigned_int)'
p43509
aS'        energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value;'
p43510
aS'      for (auto &cdf : copy_data.face_data)'
p43511
aS'        for (unsigned int j = 0; j < 2; ++j)'
p43512
aS'          energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];'
p43513
aS'    };'
p43514
aS'    const UpdateFlags cell_flags ='
p43515
aS'      update_gradients | update_quadrature_points | update_JxW_values;'
p43516
aS'    UpdateFlags face_flags ='
p43517
aS'      update_values | update_quadrature_points | update_JxW_values;'
p43518
aS'    const ScratchData scratch_data(mapping,'
p43519
aS'                                   fe,'
p43520
aS'                                   quadrature_overintegration,'
p43521
aS'                                   cell_flags,'
p43522
aS'                                   face_quadrature_overintegration,'
p43523
aS'                                   face_flags);'
p43524
aS'    CopyData copy_data;'
p43525
aS'    MeshWorker::mesh_loop(dof_handler.begin_active(),'
p43526
aS'                          dof_handler.end(),'
p43527
aS'                          cell_worker,'
p43528
aS'                          copier,'
p43529
aS'                          scratch_data,'
p43530
aS'                          copy_data,'
p43531
aS'                          MeshWorker::assemble_own_cells |'
p43532
aS'                            MeshWorker::assemble_own_interior_faces_once |'
p43533
aS'                            MeshWorker::assemble_boundary_faces,'
p43534
aS'                          boundary_worker,'
p43535
aS'                          face_worker);'
p43536
aS'    const double energy_error ='
p43537
aS'      std::sqrt(energy_norm_square_per_cell.l1_norm());'
p43538
aS'    return energy_error;'
p43539
aS'  }'
p43540
aS'  template <int dim>'
p43541
aS'  void SIPGLaplace<dim>::refine_grid()'
p43542
aS'  {'
p43543
aS'    const double refinement_fraction = 0.1;'
p43544
aS'    GridRefinement::refine_and_coarsen_fixed_number('
p43545
aS'      triangulation, estimated_error_square_per_cell, refinement_fraction, 0.);'
p43546
aS'    triangulation.execute_coarsening_and_refinement();'
p43547
aS'  }'
p43548
aS'  template <int dim>'
p43549
aS'  void SIPGLaplace<dim>::compute_errors()'
p43550
aS'  {'
p43551
aS'    double L2_error, H1_error, energy_error;'
p43552
aS'    {'
p43553
aS'      Vector<float> difference_per_cell(triangulation.n_active_cells());'
p43554
aS'      VectorTools::integrate_difference(mapping,'
p43555
aS'                                        dof_handler,'
p43556
aS'                                        solution,'
p43557
aS'                                        difference_per_cell,'
p43558
aS'                                        quadrature_overintegration,'
p43559
aS'                                        VectorTools::L2_norm);'
p43560
aS'      L2_error = VectorTools::compute_global_error(triangulation,'
p43561
aS'                                                   difference_per_cell,'
p43562
aS'                                                   VectorTools::L2_norm);'
p43563
aS'      convergence_table.add_value("L2", L2_error);'
p43564
aS'    }'
p43565
aS'    {'
p43566
aS'      Vector<float> difference_per_cell(triangulation.n_active_cells());'
p43567
aS'      VectorTools::integrate_difference(mapping,'
p43568
aS'                                        dof_handler,'
p43569
aS'                                        solution,'
p43570
aS'                                        difference_per_cell,'
p43571
aS'                                        quadrature_overintegration,'
p43572
aS'                                        VectorTools::H1_seminorm);'
p43573
aS'      H1_error = VectorTools::compute_global_error(triangulation,'
p43574
aS'                                                   difference_per_cell,'
p43575
aS'                                                   VectorTools::H1_seminorm);'
p43576
aS'      convergence_table.add_value("H1", H1_error);'
p43577
aS'    }'
p43578
aS'    {'
p43579
aS'      energy_error = compute_energy_norm_error();'
p43580
aS'      convergence_table.add_value("Energy", energy_error);'
p43581
aS'    }'
p43582
aS'    std::cout << "  Error in the L2 norm         : " << L2_error << std::endl'
p43583
aS'              << "  Error in the H1 seminorm     : " << H1_error << std::endl'
p43584
aS'              << "  Error in the energy norm     : " << energy_error'
p43585
aS'              << std::endl;'
p43586
aS'  }'
p43587
aS'  template <int dim>'
p43588
aS'  void SIPGLaplace<dim>::run()'
p43589
aS'  {'
p43590
aS'    const unsigned int max_cycle ='
p43591
aS'    for (unsigned int cycle = 0; cycle < max_cycle; ++cycle)'
p43592
aS'      {'
p43593
aS'        std::cout << "Cycle " << cycle << std::endl;'
p43594
aS'        switch (test_case)'
p43595
aS'          {'
p43596
aS'            case TestCase::convergence_rate:'
p43597
aS'              {'
p43598
aS'                if (cycle == 0)'
p43599
aS'                  {'
p43600
aS'                    GridGenerator::hyper_cube(triangulation);'
p43601
aS'                    triangulation.refine_global(2);'
p43602
aS'                  }'
p43603
aS'                else'
p43604
aS'                  {'
p43605
aS'                    triangulation.refine_global(1);'
p43606
aS'                  }'
p43607
aS'                break;'
p43608
aS'              }'
p43609
aS'            case TestCase::l_singularity:'
p43610
aS'              {'
p43611
aS'                if (cycle == 0)'
p43612
aS'                  {'
p43613
aS'                    GridGenerator::hyper_L(triangulation);'
p43614
aS'                    triangulation.refine_global(3);'
p43615
aS'                  }'
p43616
aS'                else'
p43617
aS'                  {'
p43618
aS'                    refine_grid();'
p43619
aS'                  }'
p43620
aS'                break;'
p43621
aS'              }'
p43622
aS'            default:'
p43623
aS'              {'
p43624
aS'                Assert(false, ExcNotImplemented());'
p43625
aS'              }'
p43626
aS'          }'
p43627
aS'        std::cout << "  Number of active cells       : "'
p43628
aS'                  << triangulation.n_active_cells() << std::endl;'
p43629
aS'        setup_system();'
p43630
aS'        std::cout << "  Number of degrees of freedom : " << dof_handler.n_dofs()'
p43631
aS'                  << std::endl;'
p43632
aS'        assemble_system();'
p43633
aS'        solve();'
p43634
aS'        output_results(cycle);'
p43635
aS'        {'
p43636
aS'          convergence_table.add_value("cycle", cycle);'
p43637
aS'          convergence_table.add_value("cells", triangulation.n_active_cells());'
p43638
aS'          convergence_table.add_value("dofs", dof_handler.n_dofs());'
p43639
aS'        }'
p43640
aS'        compute_errors();'
p43641
aS'        if (test_case == TestCase::l_singularity)'
p43642
aS'          {'
p43643
aS'            compute_error_estimate();'
p43644
aS'            std::cout << "  Estimated error              : "'
p43645
aS'                      << std::sqrt(estimated_error_square_per_cell.l1_norm())'
p43646
aS'                      << std::endl;'
p43647
aS'            convergence_table.add_value('
p43648
aS'              "Estimator",'
p43649
aS'              std::sqrt(estimated_error_square_per_cell.l1_norm()));'
p43650
aS'          }'
p43651
aS'        std::cout << std::endl;'
p43652
aS'      }'
p43653
aS'    convergence_table.set_precision("L2", 3);'
p43654
aS'    convergence_table.set_precision("H1", 3);'
p43655
aS'    convergence_table.set_precision("Energy", 3);'
p43656
aS'    convergence_table.set_scientific("L2", true);'
p43657
aS'    convergence_table.set_scientific("H1", true);'
p43658
aS'    convergence_table.set_scientific("Energy", true);'
p43659
aS'    if (test_case == TestCase::convergence_rate)'
p43660
aS'      {'
p43661
aS'        convergence_table.evaluate_convergence_rates('
p43662
aS'          "L2", ConvergenceTable::reduction_rate_log2);'
p43663
aS'        convergence_table.evaluate_convergence_rates('
p43664
aS'          "H1", ConvergenceTable::reduction_rate_log2);'
p43665
aS'      }'
p43666
aS'    if (test_case == TestCase::l_singularity)'
p43667
aS'      {'
p43668
aS'        convergence_table.set_precision("Estimator", 3);'
p43669
aS'        convergence_table.set_scientific("Estimator", true);'
p43670
aS'      }'
p43671
aS'    std::cout << "degree = " << degree << std::endl;'
p43672
aS'    convergence_table.write_text('
p43673
aS'      std::cout, TableHandler::TextOutputFormat::org_mode_table);'
p43674
aS'  }'
p43675
aS'} // namespace Step74'
p43676
aS'int main()'
p43677
ag9
aS'  try'
p43678
aS'    {'
p43679
aS'      using namespace dealii;'
p43680
aS'      using namespace Step74;'
p43681
aS'      const TestCase test_case = TestCase::l_singularity;'
p43682
aS'      SIPGLaplace<2> problem(test_case);'
p43683
aS'      problem.run();'
p43684
aS'    }'
p43685
aS'  catch (std::exception &exc)'
p43686
aS'    {'
p43687
aS'      std::cerr << std::endl'
p43688
aS'                << std::endl'
p43689
aS'                << "----------------------------------------------------"'
p43690
aS'                << std::endl;'
p43691
aS'      std::cerr << "Exception on processing: " << std::endl'
p43692
aS'                << exc.what() << std::endl'
p43693
aS'                << "Aborting!" << std::endl'
p43694
aS'                << "----------------------------------------------------"'
p43695
aS'                << std::endl;'
p43696
aS'      return 1;'
p43697
aS'    }'
p43698
aS'  catch (...)'
p43699
aS'    {'
p43700
aS'      std::cerr << std::endl'
p43701
aS'                << std::endl'
p43702
aS'                << "----------------------------------------------------"'
p43703
aS'                << std::endl;'
p43704
aS'      std::cerr << "Unknown exception!" << std::endl'
p43705
aS'                << "Aborting!" << std::endl'
p43706
aS'                << "----------------------------------------------------"'
p43707
aS'                << std::endl;'
p43708
aS'      return 1;'
p43709
aS'    };'
p43710
aS'  return 0;'
p43711
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p43712
aS'#include <deal.II/base/index_set.h>'
p43713
aS'#include <deal.II/base/mpi.h>'
p43714
aS'#include <deal.II/base/quadrature_lib.h>'
p43715
aS'#include <deal.II/base/timer.h>'
p43716
aS'#include <deal.II/distributed/grid_refinement.h>'
p43717
aS'#include <deal.II/distributed/tria.h>'
p43718
aS'#include <deal.II/dofs/dof_handler.h>'
p43719
aS'#include <deal.II/dofs/dof_tools.h>'
p43720
aS'#include <deal.II/grid/grid_generator.h>'
p43721
aS'#include <deal.II/fe/fe_q.h>'
p43722
aS'#include <deal.II/fe/fe_series.h>'
p43723
aS'#include <deal.II/hp/fe_collection.h>'
p43724
aS'#include <deal.II/hp/refinement.h>'
p43725
aS'#include <deal.II/lac/affine_constraints.h>'
p43726
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p43727
aS'#include <deal.II/lac/precondition.h>'
p43728
aS'#include <deal.II/lac/solver_cg.h>'
p43729
aS'#include <deal.II/lac/trilinos_precondition.h>'
p43730
aS'#include <deal.II/lac/trilinos_sparse_matrix.h>'
p43731
aS'#include <deal.II/lac/vector.h>'
p43732
aS'#include <deal.II/numerics/data_out.h>'
p43733
aS'#include <deal.II/numerics/error_estimator.h>'
p43734
aS'#include <deal.II/numerics/smoothness_estimator.h>'
p43735
aS'#include <deal.II/numerics/vector_tools.h>'
p43736
aS'#include <algorithm>'
p43737
aS'#include <fstream>'
p43738
aS'#include <iostream>'
p43739
aS'#include <deal.II/distributed/cell_weights.h>'
p43740
aS'#include <deal.II/base/function.h>'
p43741
aS'#include <deal.II/base/geometric_utilities.h>'
p43742
aS'#include <deal.II/matrix_free/matrix_free.h>'
p43743
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p43744
aS'#include <deal.II/matrix_free/tools.h>'
p43745
aS'#include <deal.II/lac/la_parallel_vector.h>'
p43746
aS'#include <deal.II/multigrid/mg_coarse.h>'
p43747
aS'#include <deal.II/multigrid/mg_constrained_dofs.h>'
p43748
aS'#include <deal.II/multigrid/mg_matrix.h>'
p43749
aS'#include <deal.II/multigrid/mg_smoother.h>'
p43750
aS'#include <deal.II/multigrid/mg_tools.h>'
p43751
aS'#include <deal.II/multigrid/mg_transfer_global_coarsening.h>'
p43752
aS'#include <deal.II/multigrid/multigrid.h>'
p43753
aS'namespace Step75'
p43754
ag9
aS'  using namespace dealii;'
p43755
aS'  template <int dim>'
p43756
aS'  class Solution : public Function<dim>'
p43757
aS'  {'
p43758
aS'  public:'
p43759
aS'    Solution()'
p43760
aS'      : Function<dim>()'
p43761
aS'    {}'
p43762
aS'    virtual double value(const Point<dim> &p,'
p43763
aS'                         const unsigned int /*component*/) const override'
p43764
aS'    {'
p43765
aS'      const std::array<double, dim> p_sphere ='
p43766
aS'        GeometricUtilities::Coordinates::to_spherical(p);'
p43767
aS'      constexpr const double alpha = 2. / 3.;'
p43768
aS'      return std::pow(p_sphere[0], alpha) * std::sin(alpha * p_sphere[1]);'
p43769
aS'    }'
p43770
aS'  };'
p43771
aS'  struct MultigridParameters'
p43772
aS'  {'
p43773
aS'    struct'
p43774
aS'    {'
p43775
aS'      std::string  type            = "cg_with_amg";'
p43776
aS'      unsigned int maxiter         = 10000;'
p43777
aS'      double       abstol          = 1e-20;'
p43778
aS'      double       reltol          = 1e-4;'
p43779
aS'      unsigned int smoother_sweeps = 1;'
p43780
aS'      unsigned int n_cycles        = 1;'
p43781
aS'      std::string  smoother_type   = "ILU";'
p43782
aS'    } coarse_solver;'
p43783
aS'    struct'
p43784
aS'    {'
p43785
aS'      std::string  type                = "chebyshev";'
p43786
aS'      double       smoothing_range     = 20;'
p43787
aS'      unsigned int degree              = 5;'
p43788
aS'      unsigned int eig_cg_n_iterations = 20;'
p43789
aS'    } smoother;'
p43790
aS'    struct'
p43791
aS'    {'
p43792
aS'      MGTransferGlobalCoarseningTools::PolynomialCoarseningSequenceType'
p43793
aS'        p_sequence = MGTransferGlobalCoarseningTools::'
p43794
aS'          PolynomialCoarseningSequenceType::decrease_by_one;'
p43795
aS'      bool perform_h_transfer = true;'
p43796
aS'    } transfer;'
p43797
aS'  };'
p43798
aS'  struct Parameters'
p43799
aS'  {'
p43800
aS'    unsigned int n_cycles         = 8;'
p43801
aS'    double       tolerance_factor = 1e-12;'
p43802
aS'    MultigridParameters mg_data;'
p43803
aS'    unsigned int min_h_level            = 5;'
p43804
aS'    unsigned int max_h_level            = 12;'
p43805
aS'    unsigned int min_p_degree           = 2;'
p43806
aS'    unsigned int max_p_degree           = 6;'
p43807
aS'    unsigned int max_p_level_difference = 1;'
p43808
aS'    double refine_fraction    = 0.3;'
p43809
aS'    double coarsen_fraction   = 0.03;'
p43810
aS'    double p_refine_fraction  = 0.9;'
p43811
aS'    double p_coarsen_fraction = 0.9;'
p43812
aS'    double weighting_factor   = 1e6;'
p43813
aS'    double weighting_exponent = 1.;'
p43814
aS'  };'
p43815
aS'  template <int dim, typename number>'
p43816
aS'  class LaplaceOperator : public Subscriptor'
p43817
aS'  {'
p43818
aS'  public:'
p43819
aS'    using VectorType = LinearAlgebra::distributed::Vector<number>;'
p43820
aS'    using FECellIntegrator = FEEvaluation<dim, -1, 0, 1, number>;'
p43821
aS'    LaplaceOperator() = default;'
p43822
aS'    LaplaceOperator(const hp::MappingCollection<dim> &mapping,'
p43823
aS'                    const DoFHandler<dim> &           dof_handler,'
p43824
aS'                    const hp::QCollection<dim> &      quad,'
p43825
aS'                    const AffineConstraints<number> & constraints,'
p43826
aS'                    VectorType &                      system_rhs);'
p43827
aS'    void reinit(const hp::MappingCollection<dim> &mapping,'
p43828
aS'                const DoFHandler<dim> &           dof_handler,'
p43829
aS'                const hp::QCollection<dim> &      quad,'
p43830
aS'                const AffineConstraints<number> & constraints,'
p43831
aS'                VectorType &                      system_rhs);'
p43832
aS'    types::global_dof_index m() const;'
p43833
aS'    number el(unsigned int, unsigned int) const;'
p43834
aS'    void initialize_dof_vector(VectorType &vec) const;'
p43835
aS'    void vmult(VectorType &dst, const VectorType &src) const;'
p43836
aS'    void Tvmult(VectorType &dst, const VectorType &src) const;'
p43837
aS'    const TrilinosWrappers::SparseMatrix &get_system_matrix() const;'
p43838
aS'    void compute_inverse_diagonal(VectorType &diagonal) const;'
p43839
aS'  private:'
p43840
aS'    void do_cell_integral_local(FECellIntegrator &integrator) const;'
p43841
aS'    void do_cell_integral_global(FECellIntegrator &integrator,'
p43842
aS'                                 VectorType &      dst,'
p43843
aS'                                 const VectorType &src) const;'
p43844
aS'    void do_cell_integral_range('
p43845
aS'      const MatrixFree<dim, number> &              matrix_free,'
p43846
aS'      VectorType &                                 dst,'
p43847
aS'      const VectorType &                           src,'
p43848
aS'      const std::pair<unsigned int, unsigned int> &range) const;'
p43849
aS'    MatrixFree<dim, number> matrix_free;'
p43850
aS'    AffineConstraints<number>              constraints;'
p43851
aS'    mutable TrilinosWrappers::SparseMatrix system_matrix;'
p43852
aS'  };'
p43853
aS'  template <int dim, typename number>'
p43854
aS'  LaplaceOperator<dim, number>::LaplaceOperator('
p43855
aS'    const hp::MappingCollection<dim> &mapping,'
p43856
aS'    const DoFHandler<dim> &           dof_handler,'
p43857
aS'    const hp::QCollection<dim> &      quad,'
p43858
aS'    const AffineConstraints<number> & constraints,'
p43859
aS'    VectorType &                      system_rhs)'
p43860
aS'  {'
p43861
aS'    this->reinit(mapping, dof_handler, quad, constraints, system_rhs);'
p43862
aS'  }'
p43863
aS'  template <int dim, typename number>'
p43864
aS'  void LaplaceOperator<dim, number>::reinit('
p43865
aS'    const hp::MappingCollection<dim> &mapping,'
p43866
aS'    const DoFHandler<dim> &           dof_handler,'
p43867
aS'    const hp::QCollection<dim> &      quad,'
p43868
aS'    const AffineConstraints<number> & constraints,'
p43869
aS'    VectorType &                      system_rhs)'
p43870
aS'  {'
p43871
aS'    this->system_matrix.clear();'
p43872
aS'    this->constraints.copy_from(constraints);'
p43873
aS'    typename MatrixFree<dim, number>::AdditionalData data;'
p43874
aS'    data.mapping_update_flags = update_gradients;'
p43875
aS'    matrix_free.reinit(mapping, dof_handler, constraints, quad, data);'
p43876
aS'    {'
p43877
aS'      AffineConstraints<number> constraints_without_dbc;'
p43878
aS'      IndexSet locally_relevant_dofs;'
p43879
aS'      DoFTools::extract_locally_relevant_dofs(dof_handler,'
p43880
aS'                                              locally_relevant_dofs);'
p43881
aS'      constraints_without_dbc.reinit(locally_relevant_dofs);'
p43882
aS'      DoFTools::make_hanging_node_constraints(dof_handler,'
p43883
aS'                                              constraints_without_dbc);'
p43884
aS'      constraints_without_dbc.close();'
p43885
aS'      VectorType b, x;'
p43886
aS'      this->initialize_dof_vector(system_rhs);'
p43887
aS'      MatrixFree<dim, number> matrix_free;'
p43888
aS'      matrix_free.reinit('
p43889
aS'        mapping, dof_handler, constraints_without_dbc, quad, data);'
p43890
aS'      matrix_free.initialize_dof_vector(b);'
p43891
aS'      matrix_free.initialize_dof_vector(x);'
p43892
aS'      constraints.distribute(x);'
p43893
aS'      matrix_free.cell_loop(&LaplaceOperator::do_cell_integral_range,'
p43894
aS'                            this,'
p43895
aS'                            b,'
p43896
aS'                            x);'
p43897
aS'      constraints.set_zero(b);'
p43898
aS'      system_rhs -= b;'
p43899
aS'    }'
p43900
aS'  }'
p43901
aS'  template <int dim, typename number>'
p43902
aS'  types::global_dof_index LaplaceOperator<dim, number>::m() const'
p43903
aS'  {'
p43904
aS'    return matrix_free.get_dof_handler().n_dofs();'
p43905
aS'  }'
p43906
aS'  template <int dim, typename number>'
p43907
aS'  number LaplaceOperator<dim, number>::el(unsigned int, unsigned int) const'
p43908
aS'  {'
p43909
aS'    Assert(false, ExcNotImplemented());'
p43910
aS'    return 0;'
p43911
aS'  }'
p43912
aS'  template <int dim, typename number>'
p43913
aS'  void'
p43914
aS'  LaplaceOperator<dim, number>::initialize_dof_vector(VectorType &vec) const'
p43915
aS'  {'
p43916
aS'    matrix_free.initialize_dof_vector(vec);'
p43917
aS'  }'
p43918
aS'  template <int dim, typename number>'
p43919
aS'  void LaplaceOperator<dim, number>::vmult(VectorType &      dst,'
p43920
aS'                                           const VectorType &src) const'
p43921
aS'  {'
p43922
aS'    this->matrix_free.cell_loop('
p43923
aS'      &LaplaceOperator::do_cell_integral_range, this, dst, src, true);'
p43924
aS'  }'
p43925
aS'  template <int dim, typename number>'
p43926
aS'  void LaplaceOperator<dim, number>::Tvmult(VectorType &      dst,'
p43927
aS'                                            const VectorType &src) const'
p43928
aS'  {'
p43929
aS'    this->vmult(dst, src);'
p43930
aS'  }'
p43931
aS'  template <int dim, typename number>'
p43932
aS'  void LaplaceOperator<dim, number>::compute_inverse_diagonal('
p43933
aS'    VectorType &diagonal) const'
p43934
aS'  {'
p43935
aS'    MatrixFreeTools::compute_diagonal(matrix_free,'
p43936
aS'                                      diagonal,'
p43937
aS'                                      &LaplaceOperator::do_cell_integral_local,'
p43938
aS'                                      this);'
p43939
aS'    for (auto &i : diagonal)'
p43940
aS'      i = (std::abs(i) > 1.0e-10) ? (1.0 / i) : 1.0;'
p43941
aS'  }'
p43942
aS'  template <int dim, typename number>'
p43943
aS'  const TrilinosWrappers::SparseMatrix &'
p43944
aS'  LaplaceOperator<dim, number>::get_system_matrix() const'
p43945
aS'  {'
p43946
aS'    if (system_matrix.m() == 0 && system_matrix.n() == 0)'
p43947
aS'      {'
p43948
aS'        const auto &dof_handler = this->matrix_free.get_dof_handler();'
p43949
aS'        TrilinosWrappers::SparsityPattern dsp('
p43950
aS'          dof_handler.locally_owned_dofs(),'
p43951
aS'          dof_handler.get_triangulation().get_communicator());'
p43952
aS'        DoFTools::make_sparsity_pattern(dof_handler, dsp, this->constraints);'
p43953
aS'        dsp.compress();'
p43954
aS'        system_matrix.reinit(dsp);'
p43955
aS'        MatrixFreeTools::compute_matrix('
p43956
aS'          matrix_free,'
p43957
aS'          constraints,'
p43958
aS'          system_matrix,'
p43959
aS'          &LaplaceOperator::do_cell_integral_local,'
p43960
aS'          this);'
p43961
aS'      }'
p43962
aS'    return this->system_matrix;'
p43963
aS'  }'
p43964
aS'  template <int dim, typename number>'
p43965
aS'  void LaplaceOperator<dim, number>::do_cell_integral_local('
p43966
aS'    FECellIntegrator &integrator) const'
p43967
aS'  {'
p43968
aS'    integrator.evaluate(EvaluationFlags::gradients);'
p43969
aS'    for (unsigned int q = 0; q < integrator.n_q_points; ++q)'
p43970
aS'      integrator.submit_gradient(integrator.get_gradient(q), q);'
p43971
aS'    integrator.integrate(EvaluationFlags::gradients);'
p43972
aS'  }'
p43973
aS'  template <int dim, typename number>'
p43974
aS'  void LaplaceOperator<dim, number>::do_cell_integral_global('
p43975
aS'    FECellIntegrator &integrator,'
p43976
aS'    VectorType &      dst,'
p43977
aS'    const VectorType &src) const'
p43978
aS'  {'
p43979
aS'    integrator.gather_evaluate(src, EvaluationFlags::gradients);'
p43980
aS'    for (unsigned int q = 0; q < integrator.n_q_points; ++q)'
p43981
aS'      integrator.submit_gradient(integrator.get_gradient(q), q);'
p43982
aS'    integrator.integrate_scatter(EvaluationFlags::gradients, dst);'
p43983
aS'  }'
p43984
aS'  template <int dim, typename number>'
p43985
aS'  void LaplaceOperator<dim, number>::do_cell_integral_range('
p43986
aS'    const MatrixFree<dim, number> &              matrix_free,'
p43987
aS'    VectorType &                                 dst,'
p43988
aS'    const VectorType &                           src,'
p43989
aS'    const std::pair<unsigned int, unsigned int> &range) const'
p43990
aS'  {'
p43991
aS'    FECellIntegrator integrator(matrix_free, range);'
p43992
aS'    for (unsigned cell = range.first; cell < range.second; ++cell)'
p43993
aS'      {'
p43994
aS'        integrator.reinit(cell);'
p43995
aS'        do_cell_integral_global(integrator, dst, src);'
p43996
aS'      }'
p43997
aS'  }'
p43998
aS'  template <typename VectorType,'
p43999
aS'            int dim,'
p44000
aS'            typename SystemMatrixType,'
p44001
aS'            typename LevelMatrixType,'
p44002
aS'            typename MGTransferType>'
p44003
aS'  static void'
p44004
aS'  mg_solve(SolverControl &            solver_control,'
p44005
aS'           VectorType &               dst,'
p44006
aS'           const VectorType &         src,'
p44007
aS'           const MultigridParameters &mg_data,'
p44008
aS'           const DoFHandler<dim> &    dof,'
p44009
aS'           const SystemMatrixType &   fine_matrix,'
p44010
aS'           const MGLevelObject<std::unique_ptr<LevelMatrixType>> &mg_matrices,'
p44011
aS'           const MGTransferType &                                 mg_transfer)'
p44012
aS'  {'
p44013
aS'    AssertThrow(mg_data.coarse_solver.type == "cg_with_amg",'
p44014
aS'                ExcNotImplemented());'
p44015
aS'    AssertThrow(mg_data.smoother.type == "chebyshev", ExcNotImplemented());'
p44016
aS'    const unsigned int min_level = mg_matrices.min_level();'
p44017
aS'    const unsigned int max_level = mg_matrices.max_level();'
p44018
aS'    using SmootherPreconditionerType = DiagonalMatrix<VectorType>;'
p44019
aS'    using SmootherType               = PreconditionChebyshev<LevelMatrixType,'
p44020
aS'                                               VectorType,'
p44021
aS'                                               SmootherPreconditionerType>;'
p44022
aS'    using PreconditionerType = PreconditionMG<dim, VectorType, MGTransferType>;'
p44023
aS'    mg::Matrix<VectorType> mg_matrix(mg_matrices);'
p44024
aS'    MGLevelObject<typename SmootherType::AdditionalData> smoother_data('
p44025
aS'      min_level, max_level);'
p44026
aS'    for (unsigned int level = min_level; level <= max_level; level++)'
p44027
aS'      {'
p44028
aS'        smoother_data[level].preconditioner ='
p44029
aS'          std::make_shared<SmootherPreconditionerType>();'
p44030
aS'        mg_matrices[level]->compute_inverse_diagonal('
p44031
aS'          smoother_data[level].preconditioner->get_vector());'
p44032
aS'        smoother_data[level].smoothing_range = mg_data.smoother.smoothing_range;'
p44033
aS'        smoother_data[level].degree          = mg_data.smoother.degree;'
p44034
aS'        smoother_data[level].eig_cg_n_iterations ='
p44035
aS'          mg_data.smoother.eig_cg_n_iterations;'
p44036
aS'      }'
p44037
aS'    MGSmootherPrecondition<LevelMatrixType, SmootherType, VectorType>'
p44038
aS'      mg_smoother;'
p44039
aS'    mg_smoother.initialize(mg_matrices, smoother_data);'
p44040
aS'    ReductionControl coarse_grid_solver_control(mg_data.coarse_solver.maxiter,'
p44041
aS'                                                mg_data.coarse_solver.abstol,'
p44042
aS'                                                mg_data.coarse_solver.reltol,'
p44043
aS'                                                false,'
p44044
aS'                                                false);'
p44045
aS'    SolverCG<VectorType> coarse_grid_solver(coarse_grid_solver_control);'
p44046
aS'    std::unique_ptr<MGCoarseGridBase<VectorType>> mg_coarse;'
p44047
aS'    TrilinosWrappers::PreconditionAMG                 precondition_amg;'
p44048
aS'    TrilinosWrappers::PreconditionAMG::AdditionalData amg_data;'
p44049
aS'    amg_data.smoother_sweeps = mg_data.coarse_solver.smoother_sweeps;'
p44050
aS'    amg_data.n_cycles        = mg_data.coarse_solver.n_cycles;'
p44051
aS'    amg_data.smoother_type   = mg_data.coarse_solver.smoother_type.c_str();'
p44052
aS'    precondition_amg.initialize(mg_matrices[min_level]->get_system_matrix(),'
p44053
aS'                                amg_data);'
p44054
aS'    mg_coarse ='
p44055
aS'      std::make_unique<MGCoarseGridIterativeSolver<VectorType,'
p44056
aS'                                                   SolverCG<VectorType>,'
p44057
aS'                                                   LevelMatrixType,'
p44058
aS'                                                   decltype(precondition_amg)>>('
p44059
aS'        coarse_grid_solver, *mg_matrices[min_level], precondition_amg);'
p44060
aS'    Multigrid<VectorType> mg('
p44061
aS'      mg_matrix, *mg_coarse, mg_transfer, mg_smoother, mg_smoother);'
p44062
aS'    PreconditionerType preconditioner(dof, mg, mg_transfer);'
p44063
aS'    SolverCG<VectorType>(solver_control)'
p44064
aS'      .solve(fine_matrix, dst, src, preconditioner);'
p44065
aS'  }'
p44066
aS'  template <typename VectorType, typename OperatorType, int dim>'
p44067
aS'  void solve_with_gmg(SolverControl &                  solver_control,'
p44068
aS'                      const OperatorType &             system_matrix,'
p44069
aS'                      VectorType &                     dst,'
p44070
aS'                      const VectorType &               src,'
p44071
aS'                      const MultigridParameters &      mg_data,'
p44072
aS'                      const hp::MappingCollection<dim> mapping_collection,'
p44073
aS'                      const DoFHandler<dim> &          dof_handler,'
p44074
aS'                      const hp::QCollection<dim> &     quadrature_collection)'
p44075
aS'  {'
p44076
aS'    MGLevelObject<DoFHandler<dim>>                     dof_handlers;'
p44077
aS'    MGLevelObject<std::unique_ptr<OperatorType>>       operators;'
p44078
aS'    MGLevelObject<MGTwoLevelTransfer<dim, VectorType>> transfers;'
p44079
aS'    std::vector<std::shared_ptr<const Triangulation<dim>>>'
p44080
aS'      coarse_grid_triangulations;'
p44081
aS'    if (mg_data.transfer.perform_h_transfer)'
p44082
aS'      coarse_grid_triangulations ='
p44083
aS'        MGTransferGlobalCoarseningTools::create_geometric_coarsening_sequence('
p44084
aS'          dof_handler.get_triangulation());'
p44085
aS'    else'
p44086
aS'      coarse_grid_triangulations.emplace_back('
p44087
aS'        const_cast<Triangulation<dim> *>(&(dof_handler.get_triangulation())),'
p44088
aS'        [](auto &) {});'
p44089
aS'    const unsigned int n_h_levels = coarse_grid_triangulations.size() - 1;'
p44090
aS'    const auto get_max_active_fe_degree = [&](const auto &dof_handler) {'
p44091
aS'      unsigned int max = 0;'
p44092
aS'      for (auto &cell : dof_handler.active_cell_iterators())'
p44093
aS'        if (cell->is_locally_owned())'
p44094
aS'          max ='
p44095
aS'            std::max(max, dof_handler.get_fe(cell->active_fe_index()).degree);'
p44096
aS'      return Utilities::MPI::max(max, MPI_COMM_WORLD);'
p44097
aS'    };'
p44098
aS'    const unsigned int n_p_levels ='
p44099
aS'      MGTransferGlobalCoarseningTools::create_polynomial_coarsening_sequence('
p44100
aS'        get_max_active_fe_degree(dof_handler), mg_data.transfer.p_sequence)'
p44101
aS'        .size();'
p44102
aS'    std::map<unsigned int, unsigned int> fe_index_for_degree;'
p44103
aS'    for (unsigned int i = 0; i < dof_handler.get_fe_collection().size(); ++i)'
p44104
aS'      {'
p44105
aS'        const unsigned int degree = dof_handler.get_fe(i).degree;'
p44106
aS'        Assert(fe_index_for_degree.find(degree) == fe_index_for_degree.end(),'
p44107
aS'               ExcMessage("FECollection does not contain unique degrees."));'
p44108
aS'        fe_index_for_degree[degree] = i;'
p44109
aS'      }'
p44110
aS'    unsigned int minlevel   = 0;'
p44111
aS'    unsigned int minlevel_p = n_h_levels;'
p44112
aS'    unsigned int maxlevel   = n_h_levels + n_p_levels - 1;'
p44113
aS'    dof_handlers.resize(minlevel, maxlevel);'
p44114
aS'    operators.resize(minlevel, maxlevel);'
p44115
aS'    transfers.resize(minlevel, maxlevel);'
p44116
aS'    for (unsigned int l = 0; l < n_h_levels; ++l)'
p44117
aS'      {'
p44118
aS'        dof_handlers[l].reinit(*coarse_grid_triangulations[l]);'
p44119
aS'        dof_handlers[l].distribute_dofs(dof_handler.get_fe_collection());'
p44120
aS'      }'
p44121
aS'    for (unsigned int i = 0, l = maxlevel; i < n_p_levels; ++i, --l)'
p44122
aS'      {'
p44123
aS'        dof_handlers[l].reinit(dof_handler.get_triangulation());'
p44124
aS'        if (l == maxlevel) // finest level'
p44125
aS'          {'
p44126
aS'            auto &dof_handler_mg = dof_handlers[l];'
p44127
aS'            auto cell_other = dof_handler.begin_active();'
p44128
aS'            for (auto &cell : dof_handler_mg.active_cell_iterators())'
p44129
aS'              {'
p44130
aS'                if (cell->is_locally_owned())'
p44131
aS'                  cell->set_active_fe_index(cell_other->active_fe_index());'
p44132
aS'                cell_other++;'
p44133
aS'              }'
p44134
aS'          }'
p44135
aS'        else // coarse level'
p44136
aS'          {'
p44137
aS'            auto &dof_handler_fine   = dof_handlers[l + 1];'
p44138
aS'            auto &dof_handler_coarse = dof_handlers[l + 0];'
p44139
aS'            auto cell_other = dof_handler_fine.begin_active();'
p44140
aS'            for (auto &cell : dof_handler_coarse.active_cell_iterators())'
p44141
aS'              {'
p44142
aS'                if (cell->is_locally_owned())'
p44143
aS'                  {'
p44144
aS'                    const unsigned int next_degree ='
p44145
aS'                      MGTransferGlobalCoarseningTools::'
p44146
aS'                        create_next_polynomial_coarsening_degree('
p44147
aS'                          cell_other->get_fe().degree,'
p44148
aS'                          mg_data.transfer.p_sequence);'
p44149
aS'                    Assert(fe_index_for_degree.find(next_degree) !='
p44150
aS'                             fe_index_for_degree.end(),'
p44151
aS'                           ExcMessage("Next polynomial degree in sequence "'
p44152
aS'                                      "does not exist in FECollection."));'
p44153
aS'                    cell->set_active_fe_index(fe_index_for_degree[next_degree]);'
p44154
aS'                  }'
p44155
aS'                cell_other++;'
p44156
aS'              }'
p44157
aS'          }'
p44158
aS'        dof_handlers[l].distribute_dofs(dof_handler.get_fe_collection());'
p44159
aS'      }'
p44160
aS'    MGLevelObject<AffineConstraints<typename VectorType::value_type>>'
p44161
aS'      constraints(minlevel, maxlevel);'
p44162
aS'    for (unsigned int level = minlevel; level <= maxlevel; ++level)'
p44163
aS'      {'
p44164
aS'        const auto &dof_handler = dof_handlers[level];'
p44165
aS'        auto &      constraint  = constraints[level];'
p44166
aS'        IndexSet locally_relevant_dofs;'
p44167
aS'        DoFTools::extract_locally_relevant_dofs(dof_handler,'
p44168
aS'                                                locally_relevant_dofs);'
p44169
aS'        constraint.reinit(locally_relevant_dofs);'
p44170
aS'        DoFTools::make_hanging_node_constraints(dof_handler, constraint);'
p44171
aS'        VectorTools::interpolate_boundary_values(mapping_collection,'
p44172
aS'                                                 dof_handler,'
p44173
aS'                                                 0,'
p44174
aS'                                                 Functions::ZeroFunction<dim>(),'
p44175
aS'                                                 constraint);'
p44176
aS'        constraint.close();'
p44177
aS'        VectorType dummy;'
p44178
aS'        operators[level] = std::make_unique<OperatorType>(mapping_collection,'
p44179
aS'                                                          dof_handler,'
p44180
aS'                                                          quadrature_collection,'
p44181
aS'                                                          constraint,'
p44182
aS'                                                          dummy);'
p44183
aS'      }'
p44184
aS'    for (unsigned int level = minlevel; level < minlevel_p; ++level)'
p44185
aS'      transfers[level + 1].reinit_geometric_transfer(dof_handlers[level + 1],'
p44186
aS'                                                     dof_handlers[level],'
p44187
aS'                                                     constraints[level + 1],'
p44188
aS'                                                     constraints[level]);'
p44189
aS'    for (unsigned int level = minlevel_p; level < maxlevel; ++level)'
p44190
aS'      transfers[level + 1].reinit_polynomial_transfer(dof_handlers[level + 1],'
p44191
aS'                                                      dof_handlers[level],'
p44192
aS'                                                      constraints[level + 1],'
p44193
aS'                                                      constraints[level]);'
p44194
aS'    MGTransferGlobalCoarsening<dim, VectorType> transfer('
p44195
aS'      transfers, [&](const auto l, auto &vec) {'
p44196
aS'        operators[l]->initialize_dof_vector(vec);'
p44197
aS'      });'
p44198
aS'    mg_solve(solver_control,'
p44199
aS'             dst,'
p44200
aS'             src,'
p44201
aS'             mg_data,'
p44202
aS'             dof_handler,'
p44203
aS'             system_matrix,'
p44204
aS'             operators,'
p44205
aS'             transfer);'
p44206
aS'  }'
p44207
aS'  template <int dim>'
p44208
aS'  class LaplaceProblem'
p44209
aS'  {'
p44210
aS'  public:'
p44211
aS'    LaplaceProblem(const Parameters &parameters);'
p44212
aS'    void run();'
p44213
aS'  private:'
p44214
aS'    void initialize_grid();'
p44215
aS'    void setup_system();'
p44216
aS'    void print_diagnostics();'
p44217
aS'    void solve_system();'
p44218
aS'    void compute_indicators();'
p44219
aS'    void adapt_resolution();'
p44220
aS'    void output_results(const unsigned int cycle);'
p44221
aS'    MPI_Comm mpi_communicator;'
p44222
aS'    const Parameters prm;'
p44223
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p44224
aS'    DoFHandler<dim>                           dof_handler;'
p44225
aS'    hp::MappingCollection<dim> mapping_collection;'
p44226
aS'    hp::FECollection<dim>      fe_collection;'
p44227
aS'    hp::QCollection<dim>       quadrature_collection;'
p44228
aS'    hp::QCollection<dim - 1>   face_quadrature_collection;'
p44229
aS'    IndexSet locally_owned_dofs;'
p44230
aS'    IndexSet locally_relevant_dofs;'
p44231
aS'    AffineConstraints<double> constraints;'
p44232
aS'    LaplaceOperator<dim, double>               laplace_operator;'
p44233
aS'    LinearAlgebra::distributed::Vector<double> locally_relevant_solution;'
p44234
aS'    LinearAlgebra::distributed::Vector<double> system_rhs;'
p44235
aS'    std::unique_ptr<FESeries::Legendre<dim>>    legendre;'
p44236
aS'    std::unique_ptr<parallel::CellWeights<dim>> cell_weights;'
p44237
aS'    Vector<float> estimated_error_per_cell;'
p44238
aS'    Vector<float> hp_decision_indicators;'
p44239
aS'    ConditionalOStream pcout;'
p44240
aS'    TimerOutput        computing_timer;'
p44241
aS'  };'
p44242
aS'  template <int dim>'
p44243
aS'  LaplaceProblem<dim>::LaplaceProblem(const Parameters &parameters)'
p44244
aS'    : mpi_communicator(MPI_COMM_WORLD)'
p44245
aS'    , prm(parameters)'
p44246
aS'    , triangulation(mpi_communicator)'
p44247
aS'    , dof_handler(triangulation)'
p44248
aS'    , pcout(std::cout,'
p44249
aS'    , computing_timer(mpi_communicator,'
p44250
aS'                      pcout,'
p44251
aS'                      TimerOutput::summary,'
p44252
aS'                      TimerOutput::wall_times)'
p44253
aS'  {'
p44254
aS'    Assert(prm.min_h_level <= prm.max_h_level,'
p44255
aS'           ExcMessage('
p44256
aS'             "Triangulation level limits have been incorrectly set up."));'
p44257
aS'    Assert(prm.min_p_degree <= prm.max_p_degree,'
p44258
aS'           ExcMessage("FECollection degrees have been incorrectly set up."));'
p44259
aS'    mapping_collection.push_back(MappingQ1<dim>());'
p44260
aS'    for (unsigned int degree = 1; degree <= prm.max_p_degree; ++degree)'
p44261
aS'      {'
p44262
aS'        fe_collection.push_back(FE_Q<dim>(degree));'
p44263
aS'        quadrature_collection.push_back(QGauss<dim>(degree + 1));'
p44264
aS'        face_quadrature_collection.push_back(QGauss<dim - 1>(degree + 1));'
p44265
aS'      }'
p44266
aS'    const unsigned int min_fe_index = prm.min_p_degree - 1;'
p44267
aS'    fe_collection.set_hierarchy('
p44268
aS'      [](const typename hp::FECollection<dim> &fe_collection,'
p44269
aS'         const unsigned int                    fe_index) -> unsigned int {'
p44270
aS'        return ((fe_index + 1) < fe_collection.size()) ? fe_index + 1 :'
p44271
aS'                                                         fe_index;'
p44272
aS'      },'
p44273
aS'      [min_fe_index](const typename hp::FECollection<dim> &,'
p44274
aS'                     const unsigned int fe_index) -> unsigned int {'
p44275
aS'        Assert(fe_index >= min_fe_index,'
p44276
aS'               ExcMessage("Finite element is not part of hierarchy!"));'
p44277
aS'        return (fe_index > min_fe_index) ? fe_index - 1 : fe_index;'
p44278
aS'      });'
p44279
aS'    legendre = std::make_unique<FESeries::Legendre<dim>>('
p44280
aS'      SmoothnessEstimator::Legendre::default_fe_series(fe_collection));'
p44281
aS'    cell_weights = std::make_unique<parallel::CellWeights<dim>>('
p44282
aS'      dof_handler,'
p44283
aS'      parallel::CellWeights<dim>::ndofs_weighting('
p44284
aS'        {prm.weighting_factor, prm.weighting_exponent}));'
p44285
aS'    triangulation.signals.post_p4est_refinement.connect('
p44286
aS'      [&, min_fe_index]() {'
p44287
aS'        const parallel::distributed::TemporarilyMatchRefineFlags<dim>'
p44288
aS'          refine_modifier(triangulation);'
p44289
aS'        hp::Refinement::limit_p_level_difference(dof_handler,'
p44290
aS'                                                 prm.max_p_level_difference,'
p44291
aS'      },'
p44292
aS'      boost::signals2::at_front);'
p44293
aS'  }'
p44294
aS'  template <int dim>'
p44295
aS'  void LaplaceProblem<dim>::initialize_grid()'
p44296
aS'  {'
p44297
aS'    TimerOutput::Scope t(computing_timer, "initialize grid");'
p44298
aS'    std::vector<unsigned int> repetitions(dim);'
p44299
aS'    Point<dim>                bottom_left, top_right;'
p44300
aS'    for (unsigned int d = 0; d < dim; ++d)'
p44301
aS'      if (d < 2)'
p44302
aS'        {'
p44303
aS'          repetitions[d] = 2;'
p44304
aS'          bottom_left[d] = -1.;'
p44305
aS'          top_right[d]   = 1.;'
p44306
aS'        }'
p44307
aS'      else'
p44308
aS'        {'
p44309
aS'          repetitions[d] = 1;'
p44310
aS'          bottom_left[d] = 0.;'
p44311
aS'          top_right[d]   = 1.;'
p44312
aS'        }'
p44313
aS'    std::vector<int> cells_to_remove(dim, 1);'
p44314
aS'    cells_to_remove[0] = -1;'
p44315
aS'    GridGenerator::subdivided_hyper_L('
p44316
aS'      triangulation, repetitions, bottom_left, top_right, cells_to_remove);'
p44317
aS'    triangulation.refine_global(prm.min_h_level);'
p44318
aS'    const unsigned int min_fe_index = prm.min_p_degree - 1;'
p44319
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p44320
aS'      if (cell->is_locally_owned())'
p44321
aS'        cell->set_active_fe_index(min_fe_index);'
p44322
aS'  }'
p44323
aS'  template <int dim>'
p44324
aS'  void LaplaceProblem<dim>::setup_system()'
p44325
aS'  {'
p44326
aS'    TimerOutput::Scope t(computing_timer, "setup system");'
p44327
aS'    dof_handler.distribute_dofs(fe_collection);'
p44328
aS'    locally_owned_dofs = dof_handler.locally_owned_dofs();'
p44329
aS'    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);'
p44330
aS'    locally_relevant_solution.reinit(locally_owned_dofs,'
p44331
aS'                                     locally_relevant_dofs,'
p44332
aS'                                     mpi_communicator);'
p44333
aS'    system_rhs.reinit(locally_owned_dofs, mpi_communicator);'
p44334
aS'    constraints.clear();'
p44335
aS'    constraints.reinit(locally_relevant_dofs);'
p44336
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p44337
aS'    VectorTools::interpolate_boundary_values('
p44338
aS'      mapping_collection, dof_handler, 0, Solution<dim>(), constraints);'
p44339
aS'    constraints.close();'
p44340
aS'    laplace_operator.reinit(mapping_collection,'
p44341
aS'                            dof_handler,'
p44342
aS'                            quadrature_collection,'
p44343
aS'                            constraints,'
p44344
aS'                            system_rhs);'
p44345
aS'  }'
p44346
aS'  template <int dim>'
p44347
aS'  void LaplaceProblem<dim>::print_diagnostics()'
p44348
aS'  {'
p44349
aS'    const unsigned int first_n_processes ='
p44350
aS'      std::min<unsigned int>(8,'
p44351
aS'                             Utilities::MPI::n_mpi_processes(mpi_communicator));'
p44352
aS'    const bool output_cropped ='
p44353
aS'      first_n_processes < Utilities::MPI::n_mpi_processes(mpi_communicator);'
p44354
aS'    {'
p44355
aS'      pcout << "   Number of active cells:       "'
p44356
aS'            << triangulation.n_global_active_cells() << std::endl'
p44357
aS'            << "     by partition:              ";'
p44358
aS'      std::vector<unsigned int> n_active_cells_per_subdomain ='
p44359
aS'        Utilities::MPI::gather(mpi_communicator,'
p44360
aS'                               triangulation.n_locally_owned_active_cells());'
p44361
aS'      for (unsigned int i = 0; i < first_n_processes; ++i)'
p44362
aS"        pcout << ' ' << n_active_cells_per_subdomain[i];"
p44363
aS'      if (output_cropped)'
p44364
aS'        pcout << " ...";'
p44365
aS'      pcout << std::endl;'
p44366
aS'    }'
p44367
aS'    {'
p44368
aS'      pcout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p44369
aS'            << std::endl'
p44370
aS'            << "     by partition:              ";'
p44371
aS'      std::vector<types::global_dof_index> n_dofs_per_subdomain ='
p44372
aS'        Utilities::MPI::gather(mpi_communicator,'
p44373
aS'                               dof_handler.n_locally_owned_dofs());'
p44374
aS'      for (unsigned int i = 0; i < first_n_processes; ++i)'
p44375
aS"        pcout << ' ' << n_dofs_per_subdomain[i];"
p44376
aS'      if (output_cropped)'
p44377
aS'        pcout << " ...";'
p44378
aS'      pcout << std::endl;'
p44379
aS'    }'
p44380
aS'    {'
p44381
aS'      std::vector<types::global_dof_index> n_constraints_per_subdomain ='
p44382
aS'        Utilities::MPI::gather(mpi_communicator, constraints.n_constraints());'
p44383
aS'      pcout << "   Number of constraints:        "'
p44384
aS'            << std::accumulate(n_constraints_per_subdomain.begin(),'
p44385
aS'                               n_constraints_per_subdomain.end(),'
p44386
aS'                               0)'
p44387
aS'            << std::endl'
p44388
aS'            << "     by partition:              ";'
p44389
aS'      for (unsigned int i = 0; i < first_n_processes; ++i)'
p44390
aS"        pcout << ' ' << n_constraints_per_subdomain[i];"
p44391
aS'      if (output_cropped)'
p44392
aS'        pcout << " ...";'
p44393
aS'      pcout << std::endl;'
p44394
aS'    }'
p44395
aS'    {'
p44396
aS'      std::vector<unsigned int> n_fe_indices(fe_collection.size(), 0);'
p44397
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p44398
aS'        if (cell->is_locally_owned())'
p44399
aS'          n_fe_indices[cell->active_fe_index()]++;'
p44400
aS'      Utilities::MPI::sum(n_fe_indices, mpi_communicator, n_fe_indices);'
p44401
aS'      pcout << "   Frequencies of poly. degrees:";'
p44402
aS'      for (unsigned int i = 0; i < fe_collection.size(); ++i)'
p44403
aS'        if (n_fe_indices[i] > 0)'
p44404
aS'          pcout << \' \' << fe_collection[i].degree << ":" << n_fe_indices[i];'
p44405
aS'      pcout << std::endl;'
p44406
aS'    }'
p44407
aS'  }'
p44408
aS'  template <int dim>'
p44409
aS'  void LaplaceProblem<dim>::solve_system()'
p44410
aS'  {'
p44411
aS'    TimerOutput::Scope t(computing_timer, "solve system");'
p44412
aS'    LinearAlgebra::distributed::Vector<double> completely_distributed_solution;'
p44413
aS'    laplace_operator.initialize_dof_vector(completely_distributed_solution);'
p44414
aS'    SolverControl solver_control(system_rhs.size(),'
p44415
aS'                                 prm.tolerance_factor * system_rhs.l2_norm());'
p44416
aS'    solve_with_gmg(solver_control,'
p44417
aS'                   laplace_operator,'
p44418
aS'                   completely_distributed_solution,'
p44419
aS'                   system_rhs,'
p44420
aS'                   prm.mg_data,'
p44421
aS'                   mapping_collection,'
p44422
aS'                   dof_handler,'
p44423
aS'                   quadrature_collection);'
p44424
aS'    pcout << "   Solved in " << solver_control.last_step() << " iterations."'
p44425
aS'          << std::endl;'
p44426
aS'    constraints.distribute(completely_distributed_solution);'
p44427
aS'    locally_relevant_solution.copy_locally_owned_data_from('
p44428
aS'      completely_distributed_solution);'
p44429
aS'    locally_relevant_solution.update_ghost_values();'
p44430
aS'  }'
p44431
aS'  template <int dim>'
p44432
aS'  void LaplaceProblem<dim>::compute_indicators()'
p44433
aS'  {'
p44434
aS'    TimerOutput::Scope t(computing_timer, "compute indicators");'
p44435
aS'    estimated_error_per_cell.grow_or_shrink(triangulation.n_active_cells());'
p44436
aS'    KellyErrorEstimator<dim>::estimate('
p44437
aS'      dof_handler,'
p44438
aS'      face_quadrature_collection,'
p44439
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p44440
aS'      locally_relevant_solution,'
p44441
aS'      estimated_error_per_cell,'
p44442
aS'      KellyErrorEstimator<dim>::Strategy::face_diameter_over_twice_max_degree);'
p44443
aS'    hp_decision_indicators.grow_or_shrink(triangulation.n_active_cells());'
p44444
aS'    SmoothnessEstimator::Legendre::coefficient_decay(*legendre,'
p44445
aS'                                                     dof_handler,'
p44446
aS'                                                     locally_relevant_solution,'
p44447
aS'                                                     hp_decision_indicators);'
p44448
aS'  }'
p44449
aS'  template <int dim>'
p44450
aS'  void LaplaceProblem<dim>::adapt_resolution()'
p44451
aS'  {'
p44452
aS'    TimerOutput::Scope t(computing_timer, "adapt resolution");'
p44453
aS'    parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number('
p44454
aS'      triangulation,'
p44455
aS'      estimated_error_per_cell,'
p44456
aS'      prm.refine_fraction,'
p44457
aS'      prm.coarsen_fraction);'
p44458
aS'    hp::Refinement::p_adaptivity_fixed_number(dof_handler,'
p44459
aS'                                              hp_decision_indicators,'
p44460
aS'                                              prm.p_refine_fraction,'
p44461
aS'                                              prm.p_coarsen_fraction);'
p44462
aS'    hp::Refinement::choose_p_over_h(dof_handler);'
p44463
aS'    Assert(triangulation.n_levels() >= prm.min_h_level + 1 &&'
p44464
aS'             triangulation.n_levels() <= prm.max_h_level + 1,'
p44465
aS'           ExcInternalError());'
p44466
aS'    if (triangulation.n_levels() > prm.max_h_level)'
p44467
aS'      for (const auto &cell :'
p44468
aS'           triangulation.active_cell_iterators_on_level(prm.max_h_level))'
p44469
aS'        cell->clear_refine_flag();'
p44470
aS'    for (const auto &cell :'
p44471
aS'         triangulation.active_cell_iterators_on_level(prm.min_h_level))'
p44472
aS'      cell->clear_coarsen_flag();'
p44473
aS'    triangulation.execute_coarsening_and_refinement();'
p44474
aS'  }'
p44475
aS'  template <int dim>'
p44476
aS'  void LaplaceProblem<dim>::output_results(const unsigned int cycle)'
p44477
aS'  {'
p44478
aS'    TimerOutput::Scope t(computing_timer, "output results");'
p44479
aS'    Vector<float> fe_degrees(triangulation.n_active_cells());'
p44480
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p44481
aS'      if (cell->is_locally_owned())'
p44482
aS'        fe_degrees(cell->active_cell_index()) = cell->get_fe().degree;'
p44483
aS'    Vector<float> subdomain(triangulation.n_active_cells());'
p44484
aS'    for (auto &subd : subdomain)'
p44485
aS'      subd = triangulation.locally_owned_subdomain();'
p44486
aS'    DataOut<dim> data_out;'
p44487
aS'    data_out.attach_dof_handler(dof_handler);'
p44488
aS'    data_out.add_data_vector(locally_relevant_solution, "solution");'
p44489
aS'    data_out.add_data_vector(fe_degrees, "fe_degree");'
p44490
aS'    data_out.add_data_vector(subdomain, "subdomain");'
p44491
aS'    data_out.add_data_vector(estimated_error_per_cell, "error");'
p44492
aS'    data_out.add_data_vector(hp_decision_indicators, "hp_indicator");'
p44493
aS'    data_out.build_patches(mapping_collection);'
p44494
aS'    data_out.write_vtu_with_pvtu_record('
p44495
aS'      "./", "solution", cycle, mpi_communicator, 2, 1);'
p44496
aS'  }'
p44497
aS'  template <int dim>'
p44498
aS'  void LaplaceProblem<dim>::run()'
p44499
aS'  {'
p44500
aS'    pcout << "Running with Trilinos on "'
p44501
aS'          << Utilities::MPI::n_mpi_processes(mpi_communicator)'
p44502
aS'          << " MPI rank(s)..." << std::endl;'
p44503
aS'    {'
p44504
aS'      pcout << "Calculating transformation matrices..." << std::endl;'
p44505
aS'      TimerOutput::Scope t(computing_timer, "calculate transformation");'
p44506
aS'      legendre->precalculate_all_transformation_matrices();'
p44507
aS'    }'
p44508
aS'    for (unsigned int cycle = 0; cycle < prm.n_cycles; ++cycle)'
p44509
aS'      {'
p44510
aS'        pcout << "Cycle " << cycle << \':\' << std::endl;'
p44511
aS'        if (cycle == 0)'
p44512
aS'          initialize_grid();'
p44513
aS'        else'
p44514
aS'          adapt_resolution();'
p44515
aS'        setup_system();'
p44516
aS'        print_diagnostics();'
p44517
aS'        solve_system();'
p44518
aS'        compute_indicators();'
p44519
aS'        if (Utilities::MPI::n_mpi_processes(mpi_communicator) <= 32)'
p44520
aS'          output_results(cycle);'
p44521
aS'        computing_timer.print_summary();'
p44522
aS'        computing_timer.reset();'
p44523
aS'        pcout << std::endl;'
p44524
aS'      }'
p44525
aS'  }'
p44526
aS'} // namespace Step75'
p44527
aS'int main(int argc, char *argv[])'
p44528
ag9
aS'  try'
p44529
aS'    {'
p44530
aS'      using namespace dealii;'
p44531
aS'      using namespace Step75;'
p44532
aS'      Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p44533
aS'      Parameters        prm;'
p44534
aS'      LaplaceProblem<2> laplace_problem(prm);'
p44535
aS'      laplace_problem.run();'
p44536
aS'    }'
p44537
aS'  catch (std::exception &exc)'
p44538
aS'    {'
p44539
aS'      std::cerr << std::endl'
p44540
aS'                << std::endl'
p44541
aS'                << "----------------------------------------------------"'
p44542
aS'                << std::endl;'
p44543
aS'      std::cerr << "Exception on processing: " << std::endl'
p44544
aS'                << exc.what() << std::endl'
p44545
aS'                << "Aborting!" << std::endl'
p44546
aS'                << "----------------------------------------------------"'
p44547
aS'                << std::endl;'
p44548
aS'      return 1;'
p44549
aS'    }'
p44550
aS'  catch (...)'
p44551
aS'    {'
p44552
aS'      std::cerr << std::endl'
p44553
aS'                << std::endl'
p44554
aS'                << "----------------------------------------------------"'
p44555
aS'                << std::endl;'
p44556
aS'      std::cerr << "Unknown exception!" << std::endl'
p44557
aS'                << "Aborting!" << std::endl'
p44558
aS'                << "----------------------------------------------------"'
p44559
aS'                << std::endl;'
p44560
aS'      return 1;'
p44561
aS'    }'
p44562
aS'  return 0;'
p44563
ag17
aS'#include <deal.II/base/conditional_ostream.h>'
p44564
aS'#include <deal.II/base/function.h>'
p44565
aS'#include <deal.II/base/logstream.h>'
p44566
aS'#include <deal.II/base/time_stepping.h>'
p44567
aS'#include <deal.II/base/timer.h>'
p44568
aS'#include <deal.II/base/utilities.h>'
p44569
aS'#include <deal.II/base/vectorization.h>'
p44570
aS'#include <deal.II/distributed/tria.h>'
p44571
aS'#include <deal.II/dofs/dof_handler.h>'
p44572
aS'#include <deal.II/fe/fe_dgq.h>'
p44573
aS'#include <deal.II/fe/fe_system.h>'
p44574
aS'#include <deal.II/grid/grid_generator.h>'
p44575
aS'#include <deal.II/grid/tria.h>'
p44576
aS'#include <deal.II/grid/tria_accessor.h>'
p44577
aS'#include <deal.II/grid/tria_iterator.h>'
p44578
aS'#include <deal.II/lac/affine_constraints.h>'
p44579
aS'#include <deal.II/lac/la_parallel_vector.h>'
p44580
aS'#include <deal.II/matrix_free/fe_evaluation.h>'
p44581
aS'#include <deal.II/matrix_free/matrix_free.h>'
p44582
aS'#include <deal.II/matrix_free/operators.h>'
p44583
aS'#include <deal.II/numerics/data_out.h>'
p44584
aS'#include <fstream>'
p44585
aS'#include <iomanip>'
p44586
aS'#include <iostream>'
p44587
aS'#include <deal.II/matrix_free/tools.h>'
p44588
aS'namespace Euler_DG'
p44589
ag9
aS'  using namespace dealii;'
p44590
aS'  constexpr unsigned int testcase             = 1;'
p44591
aS'  constexpr unsigned int dimension            = 2;'
p44592
aS'  constexpr unsigned int n_global_refinements = 2;'
p44593
aS'  constexpr unsigned int fe_degree            = 5;'
p44594
aS'  constexpr unsigned int n_q_points_1d        = fe_degree + 2;'
p44595
aS'  constexpr unsigned int group_size = numbers::invalid_unsigned_int;'
p44596
aS'  using Number = double;'
p44597
aS'  using VectorizedArrayType = VectorizedArray<Number>;'
p44598
aS'  constexpr double gamma       = 1.4;'
p44599
aS'  constexpr double final_time  = testcase == 0 ? 10 : 2.0;'
p44600
aS'  constexpr double output_tick = testcase == 0 ? 1 : 0.05;'
p44601
aS'  const double courant_number = 0.15 / std::pow(fe_degree, 1.5);'
p44602
aS'  constexpr unsigned int max_time_steps = numbers::invalid_unsigned_int;'
p44603
aS'  enum LowStorageRungeKuttaScheme'
p44604
aS'  {'
p44605
aS'    stage_3_order_3,'
p44606
aS'    stage_5_order_4,'
p44607
aS'    stage_7_order_4,'
p44608
aS'    stage_9_order_5,'
p44609
aS'  };'
p44610
aS'  constexpr LowStorageRungeKuttaScheme lsrk_scheme = stage_5_order_4;'
p44611
aS'  class LowStorageRungeKuttaIntegrator'
p44612
aS'  {'
p44613
aS'  public:'
p44614
aS'    LowStorageRungeKuttaIntegrator(const LowStorageRungeKuttaScheme scheme)'
p44615
aS'    {'
p44616
aS'      TimeStepping::runge_kutta_method lsrk;'
p44617
aS'      switch (scheme)'
p44618
aS'        {'
p44619
aS'          case stage_3_order_3:'
p44620
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE3_ORDER3;'
p44621
aS'            break;'
p44622
aS'          case stage_5_order_4:'
p44623
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE5_ORDER4;'
p44624
aS'            break;'
p44625
aS'          case stage_7_order_4:'
p44626
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE7_ORDER4;'
p44627
aS'            break;'
p44628
aS'          case stage_9_order_5:'
p44629
aS'            lsrk = TimeStepping::LOW_STORAGE_RK_STAGE9_ORDER5;'
p44630
aS'            break;'
p44631
aS'          default:'
p44632
aS'            AssertThrow(false, ExcNotImplemented());'
p44633
aS'        }'
p44634
aS'      TimeStepping::LowStorageRungeKutta<'
p44635
aS'        LinearAlgebra::distributed::Vector<Number>>'
p44636
aS'                          rk_integrator(lsrk);'
p44637
aS'      std::vector<double> ci; // not used'
p44638
aS'      rk_integrator.get_coefficients(ai, bi, ci);'
p44639
aS'    }'
p44640
aS'    unsigned int n_stages() const'
p44641
aS'    {'
p44642
aS'      return bi.size();'
p44643
aS'    }'
p44644
aS'    template <typename VectorType, typename Operator>'
p44645
aS'    void perform_time_step(const Operator &pde_operator,'
p44646
aS'                           const double    current_time,'
p44647
aS'                           const double    time_step,'
p44648
aS'                           VectorType &    solution,'
p44649
aS'                           VectorType &    vec_ri,'
p44650
aS'                           VectorType &    vec_ki) const'
p44651
aS'    {'
p44652
aS'      AssertDimension(ai.size() + 1, bi.size());'
p44653
aS'      vec_ki.swap(solution);'
p44654
aS'      double sum_previous_bi = 0;'
p44655
aS'      for (unsigned int stage = 0; stage < bi.size(); ++stage)'
p44656
aS'        {'
p44657
aS'          const double c_i = stage == 0 ? 0 : sum_previous_bi + ai[stage - 1];'
p44658
aS'          pde_operator.perform_stage(stage,'
p44659
aS'                                     current_time + c_i * time_step,'
p44660
aS'                                     bi[stage] * time_step,'
p44661
aS'                                        0 :'
p44662
aS'                                        ai[stage] * time_step),'
p44663
aS'                                     solution);'
p44664
aS'          if (stage > 0)'
p44665
aS'            sum_previous_bi += bi[stage - 1];'
p44666
aS'        }'
p44667
aS'    }'
p44668
aS'  private:'
p44669
aS'    std::vector<double> bi;'
p44670
aS'    std::vector<double> ai;'
p44671
aS'  };'
p44672
aS'  enum EulerNumericalFlux'
p44673
aS'  {'
p44674
aS'    lax_friedrichs_modified,'
p44675
aS'    harten_lax_vanleer,'
p44676
aS'  };'
p44677
aS'  constexpr EulerNumericalFlux numerical_flux_type = lax_friedrichs_modified;'
p44678
aS'  template <int dim>'
p44679
aS'  class ExactSolution : public Function<dim>'
p44680
aS'  {'
p44681
aS'  public:'
p44682
aS'    ExactSolution(const double time)'
p44683
aS'      : Function<dim>(dim + 2, time)'
p44684
aS'    {}'
p44685
aS'    virtual double value(const Point<dim> & p,'
p44686
aS'                         const unsigned int component = 0) const override;'
p44687
aS'  };'
p44688
aS'  template <int dim>'
p44689
aS'  double ExactSolution<dim>::value(const Point<dim> & x,'
p44690
aS'                                   const unsigned int component) const'
p44691
aS'  {'
p44692
aS'    const double t = this->get_time();'
p44693
aS'    switch (testcase)'
p44694
aS'      {'
p44695
aS'        case 0:'
p44696
aS'          {'
p44697
aS'            Assert(dim == 2, ExcNotImplemented());'
p44698
aS'            const double beta = 5;'
p44699
aS'            Point<dim> x0;'
p44700
aS'            x0[0] = 5.;'
p44701
aS'            const double radius_sqr ='
p44702
aS'            const double factor ='
p44703
aS'              beta / (numbers::PI * 2) * std::exp(1. - radius_sqr);'
p44704
aS'            const double density_log = std::log2('
p44705
aS'              std::abs(1. - (gamma - 1.) / gamma * 0.25 * factor * factor));'
p44706
aS'            const double density = std::exp2(density_log * (1. / (gamma - 1.)));'
p44707
aS'            const double u       = 1. - factor * (x[1] - x0[1]);'
p44708
aS'            const double v       = factor * (x[0] - t - x0[0]);'
p44709
aS'            if (component == 0)'
p44710
aS'              return density;'
p44711
aS'            else if (component == 1)'
p44712
aS'              return density * u;'
p44713
aS'            else if (component == 2)'
p44714
aS'              return density * v;'
p44715
aS'            else'
p44716
aS'              {'
p44717
aS'                const double pressure ='
p44718
aS'                  std::exp2(density_log * (gamma / (gamma - 1.)));'
p44719
aS'                return pressure / (gamma - 1.) +'
p44720
aS'                       0.5 * (density * u * u + density * v * v);'
p44721
aS'              }'
p44722
aS'          }'
p44723
aS'        case 1:'
p44724
aS'          {'
p44725
aS'            if (component == 0)'
p44726
aS'              return 1.;'
p44727
aS'            else if (component == 1)'
p44728
aS'              return 0.4;'
p44729
aS'            else if (component == dim + 1)'
p44730
aS'              return 3.097857142857143;'
p44731
aS'            else'
p44732
aS'              return 0.;'
p44733
aS'          }'
p44734
aS'        default:'
p44735
aS'          Assert(false, ExcNotImplemented());'
p44736
aS'          return 0.;'
p44737
aS'      }'
p44738
aS'  }'
p44739
aS'  template <int dim, typename Number>'
p44740
aS'  inline DEAL_II_ALWAYS_INLINE //'
p44741
aS'    Tensor<1, dim, Number>'
p44742
aS'    euler_velocity(const Tensor<1, dim + 2, Number> &conserved_variables)'
p44743
aS'  {'
p44744
aS'    const Number inverse_density = Number(1.) / conserved_variables[0];'
p44745
aS'    Tensor<1, dim, Number> velocity;'
p44746
aS'    for (unsigned int d = 0; d < dim; ++d)'
p44747
aS'      velocity[d] = conserved_variables[1 + d] * inverse_density;'
p44748
aS'    return velocity;'
p44749
aS'  }'
p44750
aS'  template <int dim, typename Number>'
p44751
aS'  inline DEAL_II_ALWAYS_INLINE //'
p44752
aS'    Number'
p44753
aS'    euler_pressure(const Tensor<1, dim + 2, Number> &conserved_variables)'
p44754
aS'  {'
p44755
aS'    const Tensor<1, dim, Number> velocity ='
p44756
aS'      euler_velocity<dim>(conserved_variables);'
p44757
aS'    Number rho_u_dot_u = conserved_variables[1] * velocity[0];'
p44758
aS'    for (unsigned int d = 1; d < dim; ++d)'
p44759
aS'      rho_u_dot_u += conserved_variables[1 + d] * velocity[d];'
p44760
aS'    return (gamma - 1.) * (conserved_variables[dim + 1] - 0.5 * rho_u_dot_u);'
p44761
aS'  }'
p44762
aS'  template <int dim, typename Number>'
p44763
aS'  inline DEAL_II_ALWAYS_INLINE //'
p44764
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>>'
p44765
aS'    euler_flux(const Tensor<1, dim + 2, Number> &conserved_variables)'
p44766
aS'  {'
p44767
aS'    const Tensor<1, dim, Number> velocity ='
p44768
aS'      euler_velocity<dim>(conserved_variables);'
p44769
aS'    const Number pressure = euler_pressure<dim>(conserved_variables);'
p44770
aS'    Tensor<1, dim + 2, Tensor<1, dim, Number>> flux;'
p44771
aS'    for (unsigned int d = 0; d < dim; ++d)'
p44772
aS'      {'
p44773
aS'        flux[0][d] = conserved_variables[1 + d];'
p44774
aS'        for (unsigned int e = 0; e < dim; ++e)'
p44775
aS'          flux[e + 1][d] = conserved_variables[e + 1] * velocity[d];'
p44776
aS'        flux[d + 1][d] += pressure;'
p44777
aS'        flux[dim + 1][d] ='
p44778
aS'          velocity[d] * (conserved_variables[dim + 1] + pressure);'
p44779
aS'      }'
p44780
aS'    return flux;'
p44781
aS'  }'
p44782
aS'  template <int n_components, int dim, typename Number>'
p44783
aS'  inline DEAL_II_ALWAYS_INLINE //'
p44784
aS'    Tensor<1, n_components, Number>'
p44785
aS'    operator*(const Tensor<1, n_components, Tensor<1, dim, Number>> &matrix,'
p44786
aS'              const Tensor<1, dim, Number> &                         vector)'
p44787
aS'  {'
p44788
aS'    Tensor<1, n_components, Number> result;'
p44789
aS'    for (unsigned int d = 0; d < n_components; ++d)'
p44790
aS'      result[d] = matrix[d] * vector;'
p44791
aS'    return result;'
p44792
aS'  }'
p44793
aS'  template <int dim, typename Number>'
p44794
aS'  inline DEAL_II_ALWAYS_INLINE //'
p44795
aS'    Tensor<1, dim + 2, Number>'
p44796
aS'    euler_numerical_flux(const Tensor<1, dim + 2, Number> &u_m,'
p44797
aS'                         const Tensor<1, dim + 2, Number> &u_p,'
p44798
aS'                         const Tensor<1, dim, Number> &    normal)'
p44799
aS'  {'
p44800
aS'    const auto velocity_m = euler_velocity<dim>(u_m);'
p44801
aS'    const auto velocity_p = euler_velocity<dim>(u_p);'
p44802
aS'    const auto pressure_m = euler_pressure<dim>(u_m);'
p44803
aS'    const auto pressure_p = euler_pressure<dim>(u_p);'
p44804
aS'    const auto flux_m = euler_flux<dim>(u_m);'
p44805
aS'    const auto flux_p = euler_flux<dim>(u_p);'
p44806
aS'    switch (numerical_flux_type)'
p44807
aS'      {'
p44808
aS'        case lax_friedrichs_modified:'
p44809
aS'          {'
p44810
aS'            const auto lambda ='
p44811
aS'              0.5 * std::sqrt(std::max(velocity_p.norm_square() +'
p44812
aS'                                         gamma * pressure_p * (1. / u_p[0]),'
p44813
aS'                                       velocity_m.norm_square() +'
p44814
aS'                                         gamma * pressure_m * (1. / u_m[0])));'
p44815
aS'            return 0.5 * (flux_m * normal + flux_p * normal) +'
p44816
aS'                   0.5 * lambda * (u_m - u_p);'
p44817
aS'          }'
p44818
aS'        case harten_lax_vanleer:'
p44819
aS'          {'
p44820
aS'            const auto avg_velocity_normal ='
p44821
aS'              0.5 * ((velocity_m + velocity_p) * normal);'
p44822
aS'            const auto   avg_c = std::sqrt(std::abs('
p44823
aS'              0.5 * gamma *'
p44824
aS'            const Number s_pos ='
p44825
aS'              std::max(Number(), avg_velocity_normal + avg_c);'
p44826
aS'            const Number s_neg ='
p44827
aS'              std::min(Number(), avg_velocity_normal - avg_c);'
p44828
aS'            const Number inverse_s = Number(1.) / (s_pos - s_neg);'
p44829
aS'            return inverse_s *'
p44830
aS'                    s_pos * s_neg * (u_m - u_p));'
p44831
aS'          }'
p44832
aS'        default:'
p44833
aS'          {'
p44834
aS'            Assert(false, ExcNotImplemented());'
p44835
aS'            return {};'
p44836
aS'          }'
p44837
aS'      }'
p44838
aS'  }'
p44839
aS'  template <int dim, typename VectorizedArrayType>'
p44840
aS'  VectorizedArrayType'
p44841
aS'  evaluate_function(const Function<dim> &                  function,'
p44842
aS'                    const Point<dim, VectorizedArrayType> &p_vectorized,'
p44843
aS'                    const unsigned int                     component)'
p44844
aS'  {'
p44845
aS'    VectorizedArrayType result;'
p44846
aS'    for (unsigned int v = 0; v < VectorizedArrayType::size(); ++v)'
p44847
aS'      {'
p44848
aS'        Point<dim> p;'
p44849
aS'        for (unsigned int d = 0; d < dim; ++d)'
p44850
aS'          p[d] = p_vectorized[d][v];'
p44851
aS'        result[v] = function.value(p, component);'
p44852
aS'      }'
p44853
aS'    return result;'
p44854
aS'  }'
p44855
aS'  template <int dim, typename VectorizedArrayType, int n_components = dim + 2>'
p44856
aS'  Tensor<1, n_components, VectorizedArrayType>'
p44857
aS'  evaluate_function(const Function<dim> &                  function,'
p44858
aS'                    const Point<dim, VectorizedArrayType> &p_vectorized)'
p44859
aS'  {'
p44860
aS'    AssertDimension(function.n_components, n_components);'
p44861
aS'    Tensor<1, n_components, VectorizedArrayType> result;'
p44862
aS'    for (unsigned int v = 0; v < VectorizedArrayType::size(); ++v)'
p44863
aS'      {'
p44864
aS'        Point<dim> p;'
p44865
aS'        for (unsigned int d = 0; d < dim; ++d)'
p44866
aS'          p[d] = p_vectorized[d][v];'
p44867
aS'        for (unsigned int d = 0; d < n_components; ++d)'
p44868
aS'          result[d][v] = function.value(p, d);'
p44869
aS'      }'
p44870
aS'    return result;'
p44871
aS'  }'
p44872
aS'  template <int dim, int degree, int n_points_1d>'
p44873
aS'  class EulerOperator'
p44874
aS'  {'
p44875
aS'  public:'
p44876
aS'    static constexpr unsigned int n_quadrature_points_1d = n_points_1d;'
p44877
aS'    EulerOperator(TimerOutput &timer_output);'
p44878
aS'    ~EulerOperator();'
p44879
aS'    void reinit(const Mapping<dim> &   mapping,'
p44880
aS'                const DoFHandler<dim> &dof_handler);'
p44881
aS'    void set_inflow_boundary(const types::boundary_id       boundary_id,'
p44882
aS'                             std::unique_ptr<Function<dim>> inflow_function);'
p44883
aS'    void set_subsonic_outflow_boundary('
p44884
aS'      const types::boundary_id       boundary_id,'
p44885
aS'      std::unique_ptr<Function<dim>> outflow_energy);'
p44886
aS'    void set_wall_boundary(const types::boundary_id boundary_id);'
p44887
aS'    void set_body_force(std::unique_ptr<Function<dim>> body_force);'
p44888
aS'    void'
p44889
aS'    perform_stage(const unsigned int                                stage,'
p44890
aS'                  const Number                                      cur_time,'
p44891
aS'                  const Number                                      bi,'
p44892
aS'                  const Number                                      ai,'
p44893
aS'                  const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p44894
aS'                  LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p44895
aS'                  LinearAlgebra::distributed::Vector<Number> &solution) const;'
p44896
aS'    void project(const Function<dim> &                       function,'
p44897
aS'                 LinearAlgebra::distributed::Vector<Number> &solution) const;'
p44898
aS'    std::array<double, 3> compute_errors('
p44899
aS'      const Function<dim> &                             function,'
p44900
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p44901
aS'    double compute_cell_transport_speed('
p44902
aS'      const LinearAlgebra::distributed::Vector<Number> &solution) const;'
p44903
aS'    void'
p44904
aS'    initialize_vector(LinearAlgebra::distributed::Vector<Number> &vector) const;'
p44905
aS'  private:'
p44906
aS'    MPI_Comm subcommunicator;'
p44907
aS'    MatrixFree<dim, Number, VectorizedArrayType> data;'
p44908
aS'    TimerOutput &timer;'
p44909
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p44910
aS'      inflow_boundaries;'
p44911
aS'    std::map<types::boundary_id, std::unique_ptr<Function<dim>>>'
p44912
aS'                                   subsonic_outflow_boundaries;'
p44913
aS'    std::set<types::boundary_id>   wall_boundaries;'
p44914
aS'    std::unique_ptr<Function<dim>> body_force;'
p44915
aS'  };'
p44916
aS'  template <int dim, int degree, int n_points_1d>'
p44917
aS'  EulerOperator<dim, degree, n_points_1d>::EulerOperator(TimerOutput &timer)'
p44918
aS'    : timer(timer)'
p44919
aS'  {'
p44920
aS'#if DEAL_II_MPI_VERSION_GTE(3, 0)'
p44921
aS'    if (group_size == 1)'
p44922
aS'      {'
p44923
aS'        this->subcommunicator = MPI_COMM_SELF;'
p44924
aS'      }'
p44925
aS'    else if (group_size == numbers::invalid_unsigned_int)'
p44926
aS'      {'
p44927
aS'        const auto rank = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);'
p44928
aS'        MPI_Comm_split_type(MPI_COMM_WORLD,'
p44929
aS'                            MPI_COMM_TYPE_SHARED,'
p44930
aS'                            rank,'
p44931
aS'                            MPI_INFO_NULL,'
p44932
aS'                            &subcommunicator);'
p44933
aS'      }'
p44934
aS'    else'
p44935
aS'      {'
p44936
aS'        Assert(false, ExcNotImplemented());'
p44937
aS'      }'
p44938
aS'#else'
p44939
aS'    this->subcommunicator = MPI_COMM_SELF;'
p44940
aS'#endif'
p44941
aS'  }'
p44942
aS'  template <int dim, int degree, int n_points_1d>'
p44943
aS'  EulerOperator<dim, degree, n_points_1d>::~EulerOperator()'
p44944
aS'  {'
p44945
aS'#ifdef DEAL_II_WITH_MPI'
p44946
aS'    if (this->subcommunicator != MPI_COMM_SELF)'
p44947
aS'      MPI_Comm_free(&subcommunicator);'
p44948
aS'#endif'
p44949
aS'  }'
p44950
aS'  template <int dim, int degree, int n_points_1d>'
p44951
aS'  void EulerOperator<dim, degree, n_points_1d>::reinit('
p44952
aS'    const Mapping<dim> &   mapping,'
p44953
aS'    const DoFHandler<dim> &dof_handler)'
p44954
aS'  {'
p44955
aS'    const std::vector<const DoFHandler<dim> *> dof_handlers = {&dof_handler};'
p44956
aS'    const AffineConstraints<double>            dummy;'
p44957
aS'    const std::vector<const AffineConstraints<double> *> constraints = {&dummy};'
p44958
aS'    const std::vector<Quadrature<1>> quadratures = {QGauss<1>(n_q_points_1d),'
p44959
aS'                                                    QGauss<1>(fe_degree + 1)};'
p44960
aS'    typename MatrixFree<dim, Number, VectorizedArrayType>::AdditionalData'
p44961
aS'      additional_data;'
p44962
aS'    additional_data.mapping_update_flags ='
p44963
aS'       update_values);'
p44964
aS'    additional_data.mapping_update_flags_inner_faces ='
p44965
aS'       update_values);'
p44966
aS'    additional_data.mapping_update_flags_boundary_faces ='
p44967
aS'       update_values);'
p44968
aS'    additional_data.tasks_parallel_scheme ='
p44969
aS'      MatrixFree<dim, Number, VectorizedArrayType>::AdditionalData::none;'
p44970
aS'    MatrixFreeTools::categorize_by_boundary_ids(dof_handler.get_triangulation(),'
p44971
aS'                                                additional_data);'
p44972
aS'    additional_data.communicator_sm = subcommunicator;'
p44973
aS'    data.reinit('
p44974
aS'      mapping, dof_handlers, constraints, quadratures, additional_data);'
p44975
aS'  }'
p44976
aS'  template <int dim, int degree, int n_points_1d>'
p44977
aS'  void EulerOperator<dim, degree, n_points_1d>::perform_stage('
p44978
aS'    const unsigned int                                stage,'
p44979
aS'    const Number                                      current_time,'
p44980
aS'    const Number                                      bi,'
p44981
aS'    const Number                                      ai,'
p44982
aS'    const LinearAlgebra::distributed::Vector<Number> &current_ri,'
p44983
aS'    LinearAlgebra::distributed::Vector<Number> &      vec_ki,'
p44984
aS'    LinearAlgebra::distributed::Vector<Number> &      solution) const'
p44985
aS'  {'
p44986
aS'    for (auto &i : inflow_boundaries)'
p44987
aS'      i.second->set_time(current_time);'
p44988
aS'    for (auto &i : subsonic_outflow_boundaries)'
p44989
aS'      i.second->set_time(current_time);'
p44990
aS'    data.template loop_cell_centric<LinearAlgebra::distributed::Vector<Number>,'
p44991
aS'                                    LinearAlgebra::distributed::Vector<Number>>('
p44992
aS'      [&](const auto &data, auto &dst, const auto &src, const auto cell_range) {'
p44993
aS'        using FECellIntegral = FEEvaluation<dim,'
p44994
aS'                                            degree,'
p44995
aS'                                            n_points_1d,'
p44996
aS'                                            dim + 2,'
p44997
aS'                                            Number,'
p44998
aS'                                            VectorizedArrayType>;'
p44999
aS'        using FEFaceIntegral = FEFaceEvaluation<dim,'
p45000
aS'                                                degree,'
p45001
aS'                                                n_points_1d,'
p45002
aS'                                                dim + 2,'
p45003
aS'                                                Number,'
p45004
aS'                                                VectorizedArrayType>;'
p45005
aS'        FECellIntegral phi(data);'
p45006
aS'        FECellIntegral phi_temp(data);'
p45007
aS'        FEFaceIntegral phi_m(data, true);'
p45008
aS'        FEFaceIntegral phi_p(data, false);'
p45009
aS'        Tensor<1, dim, VectorizedArrayType>     constant_body_force;'
p45010
aS'        const Functions::ConstantFunction<dim> *constant_function ='
p45011
aS'          dynamic_cast<Functions::ConstantFunction<dim> *>(body_force.get());'
p45012
aS'        if (constant_function)'
p45013
aS'          constant_body_force ='
p45014
aS'            evaluate_function<dim, VectorizedArrayType, dim>('
p45015
aS'        const dealii::internal::EvaluatorTensorProduct<'
p45016
aS'          dealii::internal::EvaluatorVariant::evaluate_evenodd,'
p45017
aS'          dim,'
p45018
aS'          n_points_1d,'
p45019
aS'          n_points_1d,'
p45020
aS'          VectorizedArrayType>'
p45021
aS'          eval(AlignedVector<VectorizedArrayType>(),'
p45022
aS'               data.get_shape_info().data[0].shape_gradients_collocation_eo,'
p45023
aS'               AlignedVector<VectorizedArrayType>());'
p45024
aS'        AlignedVector<VectorizedArrayType> buffer(phi.static_n_q_points *'
p45025
aS'                                                  phi.n_components);'
p45026
aS'        for (unsigned int cell = cell_range.first; cell < cell_range.second;'
p45027
aS'             ++cell)'
p45028
aS'          {'
p45029
aS'            phi.reinit(cell);'
p45030
aS'            if (ai != Number())'
p45031
aS'              phi_temp.reinit(cell);'
p45032
aS'            if (ai != Number() && stage == 0)'
p45033
aS'              {'
p45034
aS'                phi.read_dof_values(src);'
p45035
aS'                for (unsigned int i = 0;'
p45036
aS'                     i < phi.static_dofs_per_component * (dim + 2);'
p45037
aS'                     ++i)'
p45038
aS'                  phi_temp.begin_dof_values()[i] = phi.begin_dof_values()[i];'
p45039
aS'                phi.evaluate(EvaluationFlags::values);'
p45040
aS'              }'
p45041
aS'            else'
p45042
aS'              {'
p45043
aS'                phi.gather_evaluate(src, EvaluationFlags::values);'
p45044
aS'              }'
p45045
aS'            for (unsigned int i = 0; i < phi.static_n_q_points * (dim + 2); ++i)'
p45046
aS'              buffer[i] = phi.begin_values()[i];'
p45047
aS'            for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p45048
aS'              {'
p45049
aS'                const auto w_q = phi.get_value(q);'
p45050
aS'                phi.submit_gradient(euler_flux<dim>(w_q), q);'
p45051
aS'                if (body_force.get() != nullptr)'
p45052
aS'                  {'
p45053
aS'                    const Tensor<1, dim, VectorizedArrayType> force ='
p45054
aS'                      constant_function ?'
p45055
aS'                        constant_body_force :'
p45056
aS'                        evaluate_function<dim, VectorizedArrayType, dim>('
p45057
aS'                    Tensor<1, dim + 2, VectorizedArrayType> forcing;'
p45058
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p45059
aS'                      forcing[d + 1] = w_q[0] * force[d];'
p45060
aS'                    for (unsigned int d = 0; d < dim; ++d)'
p45061
aS'                      forcing[dim + 1] += force[d] * w_q[d + 1];'
p45062
aS'                    phi.submit_value(forcing, q);'
p45063
aS'                  }'
p45064
aS'              }'
p45065
aS'            {'
p45066
aS'              auto *values_ptr   = phi.begin_values();'
p45067
aS'              auto *gradient_ptr = phi.begin_gradients();'
p45068
aS'              for (unsigned int c = 0; c < dim + 2; ++c)'
p45069
aS'                {'
p45070
aS'                  if (dim >= 1 && body_force.get() == nullptr)'
p45071
aS'                    eval.template gradients<0, false, false>('
p45072
aS'                      gradient_ptr + phi.static_n_q_points * 0, values_ptr);'
p45073
aS'                  else if (dim >= 1)'
p45074
aS'                    eval.template gradients<0, false, true>('
p45075
aS'                      gradient_ptr + phi.static_n_q_points * 0, values_ptr);'
p45076
aS'                  if (dim >= 2)'
p45077
aS'                    eval.template gradients<1, false, true>('
p45078
aS'                      gradient_ptr + phi.static_n_q_points * 1, values_ptr);'
p45079
aS'                  if (dim >= 3)'
p45080
aS'                    eval.template gradients<2, false, true>('
p45081
aS'                      gradient_ptr + phi.static_n_q_points * 2, values_ptr);'
p45082
aS'                  values_ptr += phi.static_n_q_points;'
p45083
aS'                  gradient_ptr += phi.static_n_q_points * dim;'
p45084
aS'                }'
p45085
aS'            }'
p45086
aS'            for (unsigned int face = 0;'
p45087
aS'                 face < GeometryInfo<dim>::faces_per_cell;'
p45088
aS'                 ++face)'
p45089
aS'              {'
p45090
aS'                const auto boundary_ids ='
p45091
aS'                  data.get_faces_by_cells_boundary_id(cell, face);'
p45092
aS'                Assert(std::equal(boundary_ids.begin(),'
p45093
aS'                                  boundary_ids.begin() +'
p45094
aS'                                    data.n_active_entries_per_cell_batch(cell),'
p45095
aS'                                  boundary_ids.begin()),'
p45096
aS'                       ExcMessage("Boundary IDs of lanes differ."));'
p45097
aS'                const auto boundary_id = boundary_ids[0];'
p45098
aS'                phi_m.reinit(cell, face);'
p45099
aS'                internal::FEFaceNormalEvaluationImpl<dim,'
p45100
aS'                                                     n_points_1d - 1,'
p45101
aS'                                                     VectorizedArrayType>::'
p45102
aS'                  template interpolate_quadrature<true, false>('
p45103
aS'                    dim + 2,'
p45104
aS'                    data.get_shape_info(),'
p45105
aS'                    buffer.data(),'
p45106
aS'                    phi_m.begin_values(),'
p45107
aS'                    false,'
p45108
aS'                    face);'
p45109
aS'                if (boundary_id == numbers::internal_face_boundary_id)'
p45110
aS'                  {'
p45111
aS'                    phi_p.reinit(cell, face);'
p45112
aS'                    phi_p.gather_evaluate(src, EvaluationFlags::values);'
p45113
aS'                    for (unsigned int q = 0; q < phi_m.n_q_points; ++q)'
p45114
aS'                      {'
p45115
aS'                        const auto numerical_flux ='
p45116
aS'                          euler_numerical_flux<dim>(phi_m.get_value(q),'
p45117
aS'                                                    phi_p.get_value(q),'
p45118
aS'                                                    phi_m.get_normal_vector(q));'
p45119
aS'                        phi_m.submit_value(-numerical_flux, q);'
p45120
aS'                      }'
p45121
aS'                  }'
p45122
aS'                else'
p45123
aS'                  {'
p45124
aS'                    for (unsigned int q = 0; q < phi_m.n_q_points; ++q)'
p45125
aS'                      {'
p45126
aS'                        const auto w_m    = phi_m.get_value(q);'
p45127
aS'                        const auto normal = phi_m.get_normal_vector(q);'
p45128
aS'                        auto rho_u_dot_n = w_m[1] * normal[0];'
p45129
aS'                        for (unsigned int d = 1; d < dim; ++d)'
p45130
aS'                          rho_u_dot_n += w_m[1 + d] * normal[d];'
p45131
aS'                        bool at_outflow = false;'
p45132
aS'                        Tensor<1, dim + 2, VectorizedArrayType> w_p;'
p45133
aS'                        if (wall_boundaries.find(boundary_id) !='
p45134
aS'                            wall_boundaries.end())'
p45135
aS'                          {'
p45136
aS'                            w_p[0] = w_m[0];'
p45137
aS'                            for (unsigned int d = 0; d < dim; ++d)'
p45138
aS'                              w_p[d + 1] ='
p45139
aS'                                w_m[d + 1] - 2. * rho_u_dot_n * normal[d];'
p45140
aS'                            w_p[dim + 1] = w_m[dim + 1];'
p45141
aS'                          }'
p45142
aS'                        else if (inflow_boundaries.find(boundary_id) !='
p45143
aS'                                 inflow_boundaries.end())'
p45144
aS'                          w_p = evaluate_function('
p45145
aS'                            phi_m.quadrature_point(q));'
p45146
aS'                        else if (subsonic_outflow_boundaries.find('
p45147
aS'                                   boundary_id) !='
p45148
aS'                                 subsonic_outflow_boundaries.end())'
p45149
aS'                          {'
p45150
aS'                            w_p = w_m;'
p45151
aS'                            w_p[dim + 1] ='
p45152
aS'                              evaluate_function(*subsonic_outflow_boundaries'
p45153
aS'                                                   .find(boundary_id)'
p45154
aS'                                                   ->second,'
p45155
aS'                                                phi_m.quadrature_point(q),'
p45156
aS'                                                dim + 1);'
p45157
aS'                            at_outflow = true;'
p45158
aS'                          }'
p45159
aS'                        else'
p45160
aS'                          AssertThrow(false,'
p45161
aS'                                      ExcMessage('
p45162
aS'                                        "Unknown boundary id, did "'
p45163
aS'                                        "you set a boundary condition for "'
p45164
aS'                                        "this part of the domain boundary?"));'
p45165
aS'                        auto flux = euler_numerical_flux<dim>(w_m, w_p, normal);'
p45166
aS'                        if (at_outflow)'
p45167
aS'                          for (unsigned int v = 0;'
p45168
aS'                               v < VectorizedArrayType::size();'
p45169
aS'                               ++v)'
p45170
aS'                            {'
p45171
aS'                              if (rho_u_dot_n[v] < -1e-12)'
p45172
aS'                                for (unsigned int d = 0; d < dim; ++d)'
p45173
aS'                                  flux[d + 1][v] = 0.;'
p45174
aS'                            }'
p45175
aS'                        phi_m.submit_value(-flux, q);'
p45176
aS'                      }'
p45177
aS'                  }'
p45178
aS'                internal::FEFaceNormalEvaluationImpl<dim,'
p45179
aS'                                                     n_points_1d - 1,'
p45180
aS'                                                     VectorizedArrayType>::'
p45181
aS'                  template interpolate_quadrature<false, true>('
p45182
aS'                    dim + 2,'
p45183
aS'                    data.get_shape_info(),'
p45184
aS'                    phi_m.begin_values(),'
p45185
aS'                    phi.begin_values(),'
p45186
aS'                    false,'
p45187
aS'                    face);'
p45188
aS'              }'
p45189
aS'            for (unsigned int q = 0; q < phi.static_n_q_points; ++q)'
p45190
aS'              {'
p45191
aS'                const auto factor = VectorizedArrayType(1.0) / phi.JxW(q);'
p45192
aS'                for (unsigned int c = 0; c < dim + 2; ++c)'
p45193
aS'                  phi.begin_values()[c * phi.static_n_q_points + q] ='
p45194
aS'                    phi.begin_values()[c * phi.static_n_q_points + q] * factor;'
p45195
aS'              }'
p45196
aS'            internal::FEEvaluationImplBasisChange<'
p45197
aS'              dealii::internal::EvaluatorVariant::evaluate_evenodd,'
p45198
aS'              internal::EvaluatorQuantity::hessian,'
p45199
aS'              dim,'
p45200
aS'              degree + 1,'
p45201
aS'              n_points_1d,'
p45202
aS'              VectorizedArrayType,'
p45203
aS'              VectorizedArrayType>::do_backward(dim + 2,'
p45204
aS'                                                data.get_shape_info()'
p45205
aS'                                                  .data[0]'
p45206
aS'                                                  .inverse_shape_values_eo,'
p45207
aS'                                                false,'
p45208
aS'                                                phi.begin_values(),'
p45209
aS'                                                phi.begin_dof_values());'
p45210
aS'            if (ai == Number())'
p45211
aS'              {'
p45212
aS'                for (unsigned int q = 0; q < phi.static_dofs_per_cell; ++q)'
p45213
aS'                  phi.begin_dof_values()[q] = bi * phi.begin_dof_values()[q];'
p45214
aS'                phi.distribute_local_to_global(solution);'
p45215
aS'              }'
p45216
aS'            else'
p45217
aS'              {'
p45218
aS'                if (stage != 0)'
p45219
aS'                  phi_temp.read_dof_values(solution);'
p45220
aS'                for (unsigned int q = 0; q < phi.static_dofs_per_cell; ++q)'
p45221
aS'                  {'
p45222
aS'                    const auto K_i = phi.begin_dof_values()[q];'
p45223
aS'                    phi.begin_dof_values()[q] ='
p45224
aS'                      phi_temp.begin_dof_values()[q] + (ai * K_i);'
p45225
aS'                    phi_temp.begin_dof_values()[q] += bi * K_i;'
p45226
aS'                  }'
p45227
aS'                phi.set_dof_values(dst);'
p45228
aS'                phi_temp.set_dof_values(solution);'
p45229
aS'              }'
p45230
aS'          }'
p45231
aS'      },'
p45232
aS'      vec_ki,'
p45233
aS'      current_ri,'
p45234
aS'      true,'
p45235
aS'      MatrixFree<dim, Number, VectorizedArrayType>::DataAccessOnFaces::values);'
p45236
aS'  }'
p45237
aS'  template <int dim, int degree, int n_points_1d>'
p45238
aS'  void EulerOperator<dim, degree, n_points_1d>::initialize_vector('
p45239
aS'    LinearAlgebra::distributed::Vector<Number> &vector) const'
p45240
aS'  {'
p45241
aS'    data.initialize_dof_vector(vector);'
p45242
aS'  }'
p45243
aS'  template <int dim, int degree, int n_points_1d>'
p45244
aS'  void EulerOperator<dim, degree, n_points_1d>::set_inflow_boundary('
p45245
aS'    const types::boundary_id       boundary_id,'
p45246
aS'    std::unique_ptr<Function<dim>> inflow_function)'
p45247
aS'  {'
p45248
aS'    AssertThrow(subsonic_outflow_boundaries.find(boundary_id) =='
p45249
aS'                    subsonic_outflow_boundaries.end() &&'
p45250
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p45251
aS'                ExcMessage("You already set the boundary with id " +'
p45252
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p45253
aS'                           " to another type of boundary before now setting " +'
p45254
aS'                           "it as inflow"));'
p45255
aS'    AssertThrow(inflow_function->n_components == dim + 2,'
p45256
aS'                ExcMessage("Expected function with dim+2 components"));'
p45257
aS'    inflow_boundaries[boundary_id] = std::move(inflow_function);'
p45258
aS'  }'
p45259
aS'  template <int dim, int degree, int n_points_1d>'
p45260
aS'  void EulerOperator<dim, degree, n_points_1d>::set_subsonic_outflow_boundary('
p45261
aS'    const types::boundary_id       boundary_id,'
p45262
aS'    std::unique_ptr<Function<dim>> outflow_function)'
p45263
aS'  {'
p45264
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p45265
aS'                    inflow_boundaries.end() &&'
p45266
aS'                  wall_boundaries.find(boundary_id) == wall_boundaries.end(),'
p45267
aS'                ExcMessage("You already set the boundary with id " +'
p45268
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p45269
aS'                           " to another type of boundary before now setting " +'
p45270
aS'                           "it as subsonic outflow"));'
p45271
aS'    AssertThrow(outflow_function->n_components == dim + 2,'
p45272
aS'                ExcMessage("Expected function with dim+2 components"));'
p45273
aS'    subsonic_outflow_boundaries[boundary_id] = std::move(outflow_function);'
p45274
aS'  }'
p45275
aS'  template <int dim, int degree, int n_points_1d>'
p45276
aS'  void EulerOperator<dim, degree, n_points_1d>::set_wall_boundary('
p45277
aS'    const types::boundary_id boundary_id)'
p45278
aS'  {'
p45279
aS'    AssertThrow(inflow_boundaries.find(boundary_id) =='
p45280
aS'                    inflow_boundaries.end() &&'
p45281
aS'                  subsonic_outflow_boundaries.find(boundary_id) =='
p45282
aS'                    subsonic_outflow_boundaries.end(),'
p45283
aS'                ExcMessage("You already set the boundary with id " +'
p45284
aS'                           std::to_string(static_cast<int>(boundary_id)) +'
p45285
aS'                           " to another type of boundary before now setting " +'
p45286
aS'                           "it as wall boundary"));'
p45287
aS'    wall_boundaries.insert(boundary_id);'
p45288
aS'  }'
p45289
aS'  template <int dim, int degree, int n_points_1d>'
p45290
aS'  void EulerOperator<dim, degree, n_points_1d>::set_body_force('
p45291
aS'    std::unique_ptr<Function<dim>> body_force)'
p45292
aS'  {'
p45293
aS'    AssertDimension(body_force->n_components, dim);'
p45294
aS'    this->body_force = std::move(body_force);'
p45295
aS'  }'
p45296
aS'  template <int dim, int degree, int n_points_1d>'
p45297
aS'  void EulerOperator<dim, degree, n_points_1d>::project('
p45298
aS'    const Function<dim> &                       function,'
p45299
aS'    LinearAlgebra::distributed::Vector<Number> &solution) const'
p45300
aS'  {'
p45301
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number, VectorizedArrayType>'
p45302
aS'      phi(data, 0, 1);'
p45303
aS'    MatrixFreeOperators::CellwiseInverseMassMatrix<dim,'
p45304
aS'                                                   degree,'
p45305
aS'                                                   dim + 2,'
p45306
aS'                                                   Number,'
p45307
aS'                                                   VectorizedArrayType>'
p45308
aS'      inverse(phi);'
p45309
aS'    solution.zero_out_ghost_values();'
p45310
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p45311
aS'      {'
p45312
aS'        phi.reinit(cell);'
p45313
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p45314
aS'          phi.submit_dof_value(evaluate_function(function,'
p45315
aS'                                                 phi.quadrature_point(q)),'
p45316
aS'                               q);'
p45317
aS'        inverse.transform_from_q_points_to_basis(dim + 2,'
p45318
aS'                                                 phi.begin_dof_values(),'
p45319
aS'                                                 phi.begin_dof_values());'
p45320
aS'        phi.set_dof_values(solution);'
p45321
aS'      }'
p45322
aS'  }'
p45323
aS'  template <int dim, int degree, int n_points_1d>'
p45324
aS'  std::array<double, 3> EulerOperator<dim, degree, n_points_1d>::compute_errors('
p45325
aS'    const Function<dim> &                             function,'
p45326
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p45327
aS'  {'
p45328
aS'    TimerOutput::Scope t(timer, "compute errors");'
p45329
aS'    double             errors_squared[3] = {};'
p45330
aS'    FEEvaluation<dim, degree, n_points_1d, dim + 2, Number, VectorizedArrayType>'
p45331
aS'      phi(data, 0, 0);'
p45332
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p45333
aS'      {'
p45334
aS'        phi.reinit(cell);'
p45335
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p45336
aS'        VectorizedArrayType local_errors_squared[3] = {};'
p45337
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p45338
aS'          {'
p45339
aS'            const auto error ='
p45340
aS'              evaluate_function(function, phi.quadrature_point(q)) -'
p45341
aS'              phi.get_value(q);'
p45342
aS'            const auto JxW = phi.JxW(q);'
p45343
aS'            local_errors_squared[0] += error[0] * error[0] * JxW;'
p45344
aS'            for (unsigned int d = 0; d < dim; ++d)'
p45345
aS'              local_errors_squared[1] += (error[d + 1] * error[d + 1]) * JxW;'
p45346
aS'            local_errors_squared[2] += (error[dim + 1] * error[dim + 1]) * JxW;'
p45347
aS'          }'
p45348
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p45349
aS'             ++v)'
p45350
aS'          for (unsigned int d = 0; d < 3; ++d)'
p45351
aS'            errors_squared[d] += local_errors_squared[d][v];'
p45352
aS'      }'
p45353
aS'    Utilities::MPI::sum(errors_squared, MPI_COMM_WORLD, errors_squared);'
p45354
aS'    std::array<double, 3> errors;'
p45355
aS'    for (unsigned int d = 0; d < 3; ++d)'
p45356
aS'      errors[d] = std::sqrt(errors_squared[d]);'
p45357
aS'    return errors;'
p45358
aS'  }'
p45359
aS'  template <int dim, int degree, int n_points_1d>'
p45360
aS'  double EulerOperator<dim, degree, n_points_1d>::compute_cell_transport_speed('
p45361
aS'    const LinearAlgebra::distributed::Vector<Number> &solution) const'
p45362
aS'  {'
p45363
aS'    TimerOutput::Scope t(timer, "compute transport speed");'
p45364
aS'    Number             max_transport = 0;'
p45365
aS'    FEEvaluation<dim, degree, degree + 1, dim + 2, Number, VectorizedArrayType>'
p45366
aS'      phi(data, 0, 1);'
p45367
aS'    for (unsigned int cell = 0; cell < data.n_cell_batches(); ++cell)'
p45368
aS'      {'
p45369
aS'        phi.reinit(cell);'
p45370
aS'        phi.gather_evaluate(solution, EvaluationFlags::values);'
p45371
aS'        VectorizedArrayType local_max = 0.;'
p45372
aS'        for (unsigned int q = 0; q < phi.n_q_points; ++q)'
p45373
aS'          {'
p45374
aS'            const auto solution = phi.get_value(q);'
p45375
aS'            const auto velocity = euler_velocity<dim>(solution);'
p45376
aS'            const auto pressure = euler_pressure<dim>(solution);'
p45377
aS'            const auto          inverse_jacobian = phi.inverse_jacobian(q);'
p45378
aS'            const auto          convective_speed = inverse_jacobian * velocity;'
p45379
aS'            VectorizedArrayType convective_limit = 0.;'
p45380
aS'            for (unsigned int d = 0; d < dim; ++d)'
p45381
aS'              convective_limit ='
p45382
aS'                std::max(convective_limit, std::abs(convective_speed[d]));'
p45383
aS'            const auto speed_of_sound ='
p45384
aS'              std::sqrt(gamma * pressure * (1. / solution[0]));'
p45385
aS'            Tensor<1, dim, VectorizedArrayType> eigenvector;'
p45386
aS'            for (unsigned int d = 0; d < dim; ++d)'
p45387
aS'              eigenvector[d] = 1.;'
p45388
aS'            for (unsigned int i = 0; i < 5; ++i)'
p45389
aS'              {'
p45390
aS'                eigenvector = transpose(inverse_jacobian) *'
p45391
aS'                VectorizedArrayType eigenvector_norm = 0.;'
p45392
aS'                for (unsigned int d = 0; d < dim; ++d)'
p45393
aS'                  eigenvector_norm ='
p45394
aS'                    std::max(eigenvector_norm, std::abs(eigenvector[d]));'
p45395
aS'                eigenvector /= eigenvector_norm;'
p45396
aS'              }'
p45397
aS'            const auto jac_times_ev   = inverse_jacobian * eigenvector;'
p45398
aS'            const auto max_eigenvalue = std::sqrt('
p45399
aS'            local_max ='
p45400
aS'              std::max(local_max,'
p45401
aS'                       max_eigenvalue * speed_of_sound + convective_limit);'
p45402
aS'          }'
p45403
aS'        for (unsigned int v = 0; v < data.n_active_entries_per_cell_batch(cell);'
p45404
aS'             ++v)'
p45405
aS'          for (unsigned int d = 0; d < 3; ++d)'
p45406
aS'            max_transport = std::max(max_transport, local_max[v]);'
p45407
aS'      }'
p45408
aS'    max_transport = Utilities::MPI::max(max_transport, MPI_COMM_WORLD);'
p45409
aS'    return max_transport;'
p45410
aS'  }'
p45411
aS'  template <int dim>'
p45412
aS'  class EulerProblem'
p45413
aS'  {'
p45414
aS'  public:'
p45415
aS'    EulerProblem();'
p45416
aS'    void run();'
p45417
aS'  private:'
p45418
aS'    void make_grid_and_dofs();'
p45419
aS'    void output_results(const unsigned int result_number);'
p45420
aS'    LinearAlgebra::distributed::Vector<Number> solution;'
p45421
aS'    ConditionalOStream pcout;'
p45422
aS'#ifdef DEAL_II_WITH_P4EST'
p45423
aS'    parallel::distributed::Triangulation<dim> triangulation;'
p45424
aS'#else'
p45425
aS'    Triangulation<dim> triangulation;'
p45426
aS'#endif'
p45427
aS'    FESystem<dim>        fe;'
p45428
aS'    MappingQGeneric<dim> mapping;'
p45429
aS'    DoFHandler<dim>      dof_handler;'
p45430
aS'    TimerOutput timer;'
p45431
aS'    EulerOperator<dim, fe_degree, n_q_points_1d> euler_operator;'
p45432
aS'    double time, time_step;'
p45433
aS'    class Postprocessor : public DataPostprocessor<dim>'
p45434
aS'    {'
p45435
aS'    public:'
p45436
aS'      Postprocessor();'
p45437
aS'      virtual void evaluate_vector_field('
p45438
aS'        const DataPostprocessorInputs::Vector<dim> &inputs,'
p45439
aS'        std::vector<Vector<double>> &computed_quantities) const override;'
p45440
aS'      virtual std::vector<std::string> get_names() const override;'
p45441
aS'      virtual std::vector<'
p45442
aS'        DataComponentInterpretation::DataComponentInterpretation>'
p45443
aS'      get_data_component_interpretation() const override;'
p45444
aS'      virtual UpdateFlags get_needed_update_flags() const override;'
p45445
aS'    private:'
p45446
aS'      const bool do_schlieren_plot;'
p45447
aS'    };'
p45448
aS'  };'
p45449
aS'  template <int dim>'
p45450
aS'  EulerProblem<dim>::Postprocessor::Postprocessor()'
p45451
aS'    : do_schlieren_plot(dim == 2)'
p45452
aS'  {}'
p45453
aS'  template <int dim>'
p45454
aS'  void EulerProblem<dim>::Postprocessor::evaluate_vector_field('
p45455
aS'    const DataPostprocessorInputs::Vector<dim> &inputs,'
p45456
aS'    std::vector<Vector<double>> &               computed_quantities) const'
p45457
aS'  {'
p45458
aS'    const unsigned int n_evaluation_points = inputs.solution_values.size();'
p45459
aS'    if (do_schlieren_plot == true)'
p45460
aS'      Assert(inputs.solution_gradients.size() == n_evaluation_points,'
p45461
aS'             ExcInternalError());'
p45462
aS'    Assert(computed_quantities.size() == n_evaluation_points,'
p45463
aS'           ExcInternalError());'
p45464
aS'    Assert(inputs.solution_values[0].size() == dim + 2, ExcInternalError());'
p45465
aS'    Assert(computed_quantities[0].size() =='
p45466
aS'             dim + 2 + (do_schlieren_plot == true ? 1 : 0),'
p45467
aS'           ExcInternalError());'
p45468
aS'    for (unsigned int q = 0; q < n_evaluation_points; ++q)'
p45469
aS'      {'
p45470
aS'        Tensor<1, dim + 2> solution;'
p45471
aS'        for (unsigned int d = 0; d < dim + 2; ++d)'
p45472
aS'          solution[d] = inputs.solution_values[q](d);'
p45473
aS'        const double         density  = solution[0];'
p45474
aS'        const Tensor<1, dim> velocity = euler_velocity<dim>(solution);'
p45475
aS'        const double         pressure = euler_pressure<dim>(solution);'
p45476
aS'        for (unsigned int d = 0; d < dim; ++d)'
p45477
aS'          computed_quantities[q](d) = velocity[d];'
p45478
aS'        computed_quantities[q](dim)     = pressure;'
p45479
aS'        computed_quantities[q](dim + 1) = std::sqrt(gamma * pressure / density);'
p45480
aS'        if (do_schlieren_plot == true)'
p45481
aS'          computed_quantities[q](dim + 2) ='
p45482
aS'            inputs.solution_gradients[q][0] * inputs.solution_gradients[q][0];'
p45483
aS'      }'
p45484
aS'  }'
p45485
aS'  template <int dim>'
p45486
aS'  std::vector<std::string> EulerProblem<dim>::Postprocessor::get_names() const'
p45487
aS'  {'
p45488
aS'    std::vector<std::string> names;'
p45489
aS'    for (unsigned int d = 0; d < dim; ++d)'
p45490
aS'      names.emplace_back("velocity");'
p45491
aS'    names.emplace_back("pressure");'
p45492
aS'    names.emplace_back("speed_of_sound");'
p45493
aS'    if (do_schlieren_plot == true)'
p45494
aS'      names.emplace_back("schlieren_plot");'
p45495
aS'    return names;'
p45496
aS'  }'
p45497
aS'  template <int dim>'
p45498
aS'  std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p45499
aS'  EulerProblem<dim>::Postprocessor::get_data_component_interpretation() const'
p45500
aS'  {'
p45501
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p45502
aS'      interpretation;'
p45503
aS'    for (unsigned int d = 0; d < dim; ++d)'
p45504
aS'      interpretation.push_back('
p45505
aS'        DataComponentInterpretation::component_is_part_of_vector);'
p45506
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p45507
aS'    interpretation.push_back(DataComponentInterpretation::component_is_scalar);'
p45508
aS'    if (do_schlieren_plot == true)'
p45509
aS'      interpretation.push_back('
p45510
aS'        DataComponentInterpretation::component_is_scalar);'
p45511
aS'    return interpretation;'
p45512
aS'  }'
p45513
aS'  template <int dim>'
p45514
aS'  UpdateFlags EulerProblem<dim>::Postprocessor::get_needed_update_flags() const'
p45515
aS'  {'
p45516
aS'    if (do_schlieren_plot == true)'
p45517
aS'      return update_values | update_gradients;'
p45518
aS'    else'
p45519
aS'      return update_values;'
p45520
aS'  }'
p45521
aS'  template <int dim>'
p45522
aS'  EulerProblem<dim>::EulerProblem()'
p45523
aS'    : pcout(std::cout, Utilities::MPI::this_mpi_process(MPI_COMM_WORLD) == 0)'
p45524
aS'#ifdef DEAL_II_WITH_P4EST'
p45525
aS'    , triangulation(MPI_COMM_WORLD)'
p45526
aS'#endif'
p45527
aS'    , fe(FE_DGQ<dim>(fe_degree), dim + 2)'
p45528
aS'    , mapping(fe_degree)'
p45529
aS'    , dof_handler(triangulation)'
p45530
aS'    , timer(pcout, TimerOutput::never, TimerOutput::wall_times)'
p45531
aS'    , euler_operator(timer)'
p45532
aS'    , time(0)'
p45533
aS'    , time_step(0)'
p45534
aS'  {}'
p45535
aS'  template <int dim>'
p45536
aS'  void EulerProblem<dim>::make_grid_and_dofs()'
p45537
aS'  {'
p45538
aS'    switch (testcase)'
p45539
aS'      {'
p45540
aS'        case 0:'
p45541
aS'          {'
p45542
aS'            Point<dim> lower_left;'
p45543
aS'            for (unsigned int d = 1; d < dim; ++d)'
p45544
aS'              lower_left[d] = -5;'
p45545
aS'            Point<dim> upper_right;'
p45546
aS'            upper_right[0] = 10;'
p45547
aS'            for (unsigned int d = 1; d < dim; ++d)'
p45548
aS'              upper_right[d] = 5;'
p45549
aS'            GridGenerator::hyper_rectangle(triangulation,'
p45550
aS'                                           lower_left,'
p45551
aS'                                           upper_right);'
p45552
aS'            triangulation.refine_global(2);'
p45553
aS'            euler_operator.set_inflow_boundary('
p45554
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p45555
aS'            break;'
p45556
aS'          }'
p45557
aS'        case 1:'
p45558
aS'          {'
p45559
aS'            GridGenerator::channel_with_cylinder('
p45560
aS'              triangulation, 0.03, 1, 0, true);'
p45561
aS'            euler_operator.set_inflow_boundary('
p45562
aS'              0, std::make_unique<ExactSolution<dim>>(0));'
p45563
aS'            euler_operator.set_subsonic_outflow_boundary('
p45564
aS'              1, std::make_unique<ExactSolution<dim>>(0));'
p45565
aS'            euler_operator.set_wall_boundary(2);'
p45566
aS'            euler_operator.set_wall_boundary(3);'
p45567
aS'            if (dim == 3)'
p45568
aS'              euler_operator.set_body_force('
p45569
aS'                std::make_unique<Functions::ConstantFunction<dim>>('
p45570
aS'                  std::vector<double>({0., 0., -0.2})));'
p45571
aS'            break;'
p45572
aS'          }'
p45573
aS'        default:'
p45574
aS'          Assert(false, ExcNotImplemented());'
p45575
aS'      }'
p45576
aS'    triangulation.refine_global(n_global_refinements);'
p45577
aS'    dof_handler.distribute_dofs(fe);'
p45578
aS'    euler_operator.reinit(mapping, dof_handler);'
p45579
aS'    euler_operator.initialize_vector(solution);'
p45580
aS'    std::locale s = pcout.get_stream().getloc();'
p45581
aS'    pcout.get_stream().imbue(std::locale(""));'
p45582
aS'    pcout << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p45583
aS'          << " ( = " << (dim + 2) << " [vars] x "'
p45584
aS'          << triangulation.n_global_active_cells() << " [cells] x "'
p45585
aS'          << Utilities::pow(fe_degree + 1, dim) << " [dofs/cell/var] )"'
p45586
aS'          << std::endl;'
p45587
aS'    pcout.get_stream().imbue(s);'
p45588
aS'  }'
p45589
aS'  template <int dim>'
p45590
aS'  void EulerProblem<dim>::output_results(const unsigned int result_number)'
p45591
aS'  {'
p45592
aS'    const std::array<double, 3> errors ='
p45593
aS'      euler_operator.compute_errors(ExactSolution<dim>(time), solution);'
p45594
aS'    const std::string quantity_name = testcase == 0 ? "error" : "norm";'
p45595
aS'    pcout << "Time:" << std::setw(8) << std::setprecision(3) << time'
p45596
aS'          << ", dt: " << std::setw(8) << std::setprecision(2) << time_step'
p45597
aS'          << ", " << quantity_name << " rho: " << std::setprecision(4)'
p45598
aS'          << std::setw(10) << errors[0] << ", rho * u: " << std::setprecision(4)'
p45599
aS'          << std::setw(10) << errors[1] << ", energy:" << std::setprecision(4)'
p45600
aS'          << std::setw(10) << errors[2] << std::endl;'
p45601
aS'    {'
p45602
aS'      TimerOutput::Scope t(timer, "output");'
p45603
aS'      Postprocessor postprocessor;'
p45604
aS'      DataOut<dim>  data_out;'
p45605
aS'      DataOutBase::VtkFlags flags;'
p45606
aS'      flags.write_higher_order_cells = true;'
p45607
aS'      data_out.set_flags(flags);'
p45608
aS'      data_out.attach_dof_handler(dof_handler);'
p45609
aS'      {'
p45610
aS'        std::vector<std::string> names;'
p45611
aS'        names.emplace_back("density");'
p45612
aS'        for (unsigned int d = 0; d < dim; ++d)'
p45613
aS'          names.emplace_back("momentum");'
p45614
aS'        names.emplace_back("energy");'
p45615
aS'        std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p45616
aS'          interpretation;'
p45617
aS'        interpretation.push_back('
p45618
aS'          DataComponentInterpretation::component_is_scalar);'
p45619
aS'        for (unsigned int d = 0; d < dim; ++d)'
p45620
aS'          interpretation.push_back('
p45621
aS'            DataComponentInterpretation::component_is_part_of_vector);'
p45622
aS'        interpretation.push_back('
p45623
aS'          DataComponentInterpretation::component_is_scalar);'
p45624
aS'        data_out.add_data_vector(dof_handler, solution, names, interpretation);'
p45625
aS'      }'
p45626
aS'      data_out.add_data_vector(solution, postprocessor);'
p45627
aS'      LinearAlgebra::distributed::Vector<Number> reference;'
p45628
aS'      if (testcase == 0 && dim == 2)'
p45629
aS'        {'
p45630
aS'          reference.reinit(solution);'
p45631
aS'          euler_operator.project(ExactSolution<dim>(time), reference);'
p45632
aS'          reference.sadd(-1., 1, solution);'
p45633
aS'          std::vector<std::string> names;'
p45634
aS'          names.emplace_back("error_density");'
p45635
aS'          for (unsigned int d = 0; d < dim; ++d)'
p45636
aS'            names.emplace_back("error_momentum");'
p45637
aS'          names.emplace_back("error_energy");'
p45638
aS'          std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p45639
aS'            interpretation;'
p45640
aS'          interpretation.push_back('
p45641
aS'            DataComponentInterpretation::component_is_scalar);'
p45642
aS'          for (unsigned int d = 0; d < dim; ++d)'
p45643
aS'            interpretation.push_back('
p45644
aS'              DataComponentInterpretation::component_is_part_of_vector);'
p45645
aS'          interpretation.push_back('
p45646
aS'            DataComponentInterpretation::component_is_scalar);'
p45647
aS'          data_out.add_data_vector(dof_handler,'
p45648
aS'                                   reference,'
p45649
aS'                                   names,'
p45650
aS'                                   interpretation);'
p45651
aS'        }'
p45652
aS'      Vector<double> mpi_owner(triangulation.n_active_cells());'
p45653
aS'      mpi_owner = Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);'
p45654
aS'      data_out.add_data_vector(mpi_owner, "owner");'
p45655
aS'      data_out.build_patches(mapping,'
p45656
aS'                             fe.degree,'
p45657
aS'                             DataOut<dim>::curved_inner_cells);'
p45658
aS'      const std::string filename ='
p45659
aS'        "solution_" + Utilities::int_to_string(result_number, 3) + ".vtu";'
p45660
aS'      data_out.write_vtu_in_parallel(filename, MPI_COMM_WORLD);'
p45661
aS'    }'
p45662
aS'  }'
p45663
aS'  template <int dim>'
p45664
aS'  void EulerProblem<dim>::run()'
p45665
aS'  {'
p45666
aS'    {'
p45667
aS'      const unsigned int n_vect_number = VectorizedArrayType::size();'
p45668
aS'      const unsigned int n_vect_bits   = 8 * sizeof(Number) * n_vect_number;'
p45669
aS'      pcout << "Running with "'
p45670
aS'            << Utilities::MPI::n_mpi_processes(MPI_COMM_WORLD)'
p45671
aS'            << " MPI processes" << std::endl;'
p45672
aS'      pcout << "Vectorization over " << n_vect_number << " "'
p45673
aS'            << (std::is_same<Number, double>::value ? "doubles" : "floats")'
p45674
aS'            << " = " << n_vect_bits << " bits ("'
p45675
aS'            << Utilities::System::get_current_vectorization_level() << ")"'
p45676
aS'            << std::endl;'
p45677
aS'    }'
p45678
aS'    make_grid_and_dofs();'
p45679
aS'    const LowStorageRungeKuttaIntegrator integrator(lsrk_scheme);'
p45680
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_1;'
p45681
aS'    LinearAlgebra::distributed::Vector<Number> rk_register_2;'
p45682
aS'    rk_register_1.reinit(solution);'
p45683
aS'    rk_register_2.reinit(solution);'
p45684
aS'    euler_operator.project(ExactSolution<dim>(time), solution);'
p45685
aS'    double min_vertex_distance = std::numeric_limits<double>::max();'
p45686
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p45687
aS'      if (cell->is_locally_owned())'
p45688
aS'        min_vertex_distance ='
p45689
aS'          std::min(min_vertex_distance, cell->minimum_vertex_distance());'
p45690
aS'    min_vertex_distance ='
p45691
aS'      Utilities::MPI::min(min_vertex_distance, MPI_COMM_WORLD);'
p45692
aS'    time_step = courant_number * integrator.n_stages() /'
p45693
aS'                euler_operator.compute_cell_transport_speed(solution);'
p45694
aS'    pcout << "Time step size: " << time_step'
p45695
aS'          << ", minimal h: " << min_vertex_distance'
p45696
aS'          << ", initial transport scaling: "'
p45697
aS'          << 1. / euler_operator.compute_cell_transport_speed(solution)'
p45698
aS'          << std::endl'
p45699
aS'          << std::endl;'
p45700
aS'    output_results(0);'
p45701
aS'    unsigned int timestep_number = 0;'
p45702
aS'    while (time < final_time - 1e-12 && timestep_number < max_time_steps)'
p45703
aS'      {'
p45704
aS'        ++timestep_number;'
p45705
aS'        if (timestep_number % 5 == 0)'
p45706
aS'          time_step ='
p45707
aS'            courant_number * integrator.n_stages() /'
p45708
aS'            Utilities::truncate_to_n_digits('
p45709
aS'              euler_operator.compute_cell_transport_speed(solution), 3);'
p45710
aS'        {'
p45711
aS'          TimerOutput::Scope t(timer, "rk time stepping total");'
p45712
aS'          integrator.perform_time_step(euler_operator,'
p45713
aS'                                       time,'
p45714
aS'                                       time_step,'
p45715
aS'                                       solution,'
p45716
aS'                                       rk_register_1,'
p45717
aS'                                       rk_register_2);'
p45718
aS'        }'
p45719
aS'        time += time_step;'
p45720
aS'        if (static_cast<int>(time / output_tick) !='
p45721
aS'              static_cast<int>((time - time_step) / output_tick) ||'
p45722
aS'            time >= final_time - 1e-12)'
p45723
aS'          output_results('
p45724
aS'            static_cast<unsigned int>(std::round(time / output_tick)));'
p45725
aS'      }'
p45726
aS'    timer.print_wall_time_statistics(MPI_COMM_WORLD);'
p45727
aS'    pcout << std::endl;'
p45728
aS'  }'
p45729
aS'} // namespace Euler_DG'
p45730
aS'int main(int argc, char **argv)'
p45731
ag9
aS'  using namespace Euler_DG;'
p45732
aS'  using namespace dealii;'
p45733
aS'  Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);'
p45734
aS'  try'
p45735
aS'    {'
p45736
aS'      deallog.depth_console(0);'
p45737
aS'      EulerProblem<dimension> euler_problem;'
p45738
aS'      euler_problem.run();'
p45739
aS'    }'
p45740
aS'  catch (std::exception &exc)'
p45741
aS'    {'
p45742
aS'      std::cerr << std::endl'
p45743
aS'                << std::endl'
p45744
aS'                << "----------------------------------------------------"'
p45745
aS'                << std::endl;'
p45746
aS'      std::cerr << "Exception on processing: " << std::endl'
p45747
aS'                << exc.what() << std::endl'
p45748
aS'                << "Aborting!" << std::endl'
p45749
aS'                << "----------------------------------------------------"'
p45750
aS'                << std::endl;'
p45751
aS'      return 1;'
p45752
aS'    }'
p45753
aS'  catch (...)'
p45754
aS'    {'
p45755
aS'      std::cerr << std::endl'
p45756
aS'                << std::endl'
p45757
aS'                << "----------------------------------------------------"'
p45758
aS'                << std::endl;'
p45759
aS'      std::cerr << "Unknown exception!" << std::endl'
p45760
aS'                << "Aborting!" << std::endl'
p45761
aS'                << "----------------------------------------------------"'
p45762
aS'                << std::endl;'
p45763
aS'      return 1;'
p45764
aS'    }'
p45765
aS'  return 0;'
p45766
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p45767
aS'#include <deal.II/base/function.h>'
p45768
aS'#include <deal.II/base/timer.h>'
p45769
aS'#include <deal.II/base/utilities.h>'
p45770
aS'#include <deal.II/lac/vector.h>'
p45771
aS'#include <deal.II/lac/full_matrix.h>'
p45772
aS'#include <deal.II/lac/sparse_matrix.h>'
p45773
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p45774
aS'#include <deal.II/lac/affine_constraints.h>'
p45775
aS'#include <deal.II/lac/sparse_direct.h>'
p45776
aS'#include <deal.II/grid/tria.h>'
p45777
aS'#include <deal.II/grid/grid_generator.h>'
p45778
aS'#include <deal.II/grid/grid_refinement.h>'
p45779
aS'#include <deal.II/dofs/dof_handler.h>'
p45780
aS'#include <deal.II/dofs/dof_accessor.h>'
p45781
aS'#include <deal.II/dofs/dof_tools.h>'
p45782
aS'#include <deal.II/fe/fe_values.h>'
p45783
aS'#include <deal.II/fe/fe_q.h>'
p45784
aS'#include <deal.II/numerics/vector_tools.h>'
p45785
aS'#include <deal.II/numerics/matrix_tools.h>'
p45786
aS'#include <deal.II/numerics/data_out.h>'
p45787
aS'#include <deal.II/numerics/error_estimator.h>'
p45788
aS'#include <deal.II/numerics/solution_transfer.h>'
p45789
aS'#include <deal.II/sundials/kinsol.h>'
p45790
aS'#include <fstream>'
p45791
aS'#include <iostream>'
p45792
aS'namespace Step77'
p45793
ag9
aS'  using namespace dealii;'
p45794
aS'  template <int dim>'
p45795
aS'  class MinimalSurfaceProblem'
p45796
aS'  {'
p45797
aS'  public:'
p45798
aS'    MinimalSurfaceProblem();'
p45799
aS'    void run();'
p45800
aS'  private:'
p45801
aS'    void setup_system(const bool initial_step);'
p45802
aS'    void solve(const Vector<double> &rhs,'
p45803
aS'               Vector<double> &      solution,'
p45804
aS'               const double          tolerance);'
p45805
aS'    void refine_mesh();'
p45806
aS'    void output_results(const unsigned int refinement_cycle);'
p45807
aS'    void set_boundary_values();'
p45808
aS'    void compute_and_factorize_jacobian(const Vector<double> &evaluation_point);'
p45809
aS'    void compute_residual(const Vector<double> &evaluation_point,'
p45810
aS'                          Vector<double> &      residual);'
p45811
aS'    Triangulation<dim> triangulation;'
p45812
aS'    DoFHandler<dim> dof_handler;'
p45813
aS'    FE_Q<dim>       fe;'
p45814
aS'    AffineConstraints<double> hanging_node_constraints;'
p45815
aS'    SparsityPattern                      sparsity_pattern;'
p45816
aS'    SparseMatrix<double>                 jacobian_matrix;'
p45817
aS'    std::unique_ptr<SparseDirectUMFPACK> jacobian_matrix_factorization;'
p45818
aS'    Vector<double> current_solution;'
p45819
aS'    TimerOutput computing_timer;'
p45820
aS'  };'
p45821
aS'  template <int dim>'
p45822
aS'  class BoundaryValues : public Function<dim>'
p45823
aS'  {'
p45824
aS'  public:'
p45825
aS'    virtual double value(const Point<dim> & p,'
p45826
aS'                         const unsigned int component = 0) const override;'
p45827
aS'  };'
p45828
aS'  template <int dim>'
p45829
aS'  double BoundaryValues<dim>::value(const Point<dim> &p,'
p45830
aS'                                    const unsigned int /*component*/) const'
p45831
aS'  {'
p45832
aS'    return std::sin(2 * numbers::PI * (p[0] + p[1]));'
p45833
aS'  }'
p45834
aS'  template <int dim>'
p45835
aS'  MinimalSurfaceProblem<dim>::MinimalSurfaceProblem()'
p45836
aS'    : dof_handler(triangulation)'
p45837
aS'    , fe(1)'
p45838
aS'    , computing_timer(std::cout, TimerOutput::never, TimerOutput::wall_times)'
p45839
aS'  {}'
p45840
aS'  template <int dim>'
p45841
aS'  void MinimalSurfaceProblem<dim>::setup_system(const bool initial_step)'
p45842
aS'  {'
p45843
aS'    TimerOutput::Scope t(computing_timer, "set up");'
p45844
aS'    if (initial_step)'
p45845
aS'      {'
p45846
aS'        dof_handler.distribute_dofs(fe);'
p45847
aS'        current_solution.reinit(dof_handler.n_dofs());'
p45848
aS'        hanging_node_constraints.clear();'
p45849
aS'        DoFTools::make_hanging_node_constraints(dof_handler,'
p45850
aS'                                                hanging_node_constraints);'
p45851
aS'        hanging_node_constraints.close();'
p45852
aS'      }'
p45853
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p45854
aS'    DoFTools::make_sparsity_pattern(dof_handler, dsp);'
p45855
aS'    hanging_node_constraints.condense(dsp);'
p45856
aS'    sparsity_pattern.copy_from(dsp);'
p45857
aS'    jacobian_matrix.reinit(sparsity_pattern);'
p45858
aS'    jacobian_matrix_factorization.reset();'
p45859
aS'  }'
p45860
aS'  template <int dim>'
p45861
aS'  void MinimalSurfaceProblem<dim>::compute_and_factorize_jacobian('
p45862
aS'    const Vector<double> &evaluation_point)'
p45863
aS'  {'
p45864
aS'    {'
p45865
aS'      TimerOutput::Scope t(computing_timer, "assembling the Jacobian");'
p45866
aS'      std::cout << "  Computing Jacobian matrix" << std::endl;'
p45867
aS'      const QGauss<dim> quadrature_formula(fe.degree + 1);'
p45868
aS'      jacobian_matrix = 0;'
p45869
aS'      FEValues<dim> fe_values(fe,'
p45870
aS'                              quadrature_formula,'
p45871
aS'                              update_gradients | update_quadrature_points |'
p45872
aS'                                update_JxW_values);'
p45873
aS'      const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p45874
aS'      const unsigned int n_q_points    = quadrature_formula.size();'
p45875
aS'      FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p45876
aS'      std::vector<Tensor<1, dim>> evaluation_point_gradients(n_q_points);'
p45877
aS'      std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p45878
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p45879
aS'        {'
p45880
aS'          cell_matrix = 0;'
p45881
aS'          fe_values.reinit(cell);'
p45882
aS'          fe_values.get_function_gradients(evaluation_point,'
p45883
aS'                                           evaluation_point_gradients);'
p45884
aS'          for (unsigned int q = 0; q < n_q_points; ++q)'
p45885
aS'            {'
p45886
aS'              const double coeff ='
p45887
aS'                1.0 / std::sqrt(1 + evaluation_point_gradients[q] *'
p45888
aS'                                      evaluation_point_gradients[q]);'
p45889
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p45890
aS'                {'
p45891
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p45892
aS'                    cell_matrix(i, j) +='
p45893
aS'                        -                              //  -'
p45894
aS'                }'
p45895
aS'            }'
p45896
aS'          cell->get_dof_indices(local_dof_indices);'
p45897
aS'          hanging_node_constraints.distribute_local_to_global(cell_matrix,'
p45898
aS'                                                              local_dof_indices,'
p45899
aS'                                                              jacobian_matrix);'
p45900
aS'        }'
p45901
aS'      std::map<types::global_dof_index, double> boundary_values;'
p45902
aS'      VectorTools::interpolate_boundary_values(dof_handler,'
p45903
aS'                                               0,'
p45904
aS'                                               Functions::ZeroFunction<dim>(),'
p45905
aS'                                               boundary_values);'
p45906
aS'      Vector<double> dummy_solution(dof_handler.n_dofs());'
p45907
aS'      Vector<double> dummy_rhs(dof_handler.n_dofs());'
p45908
aS'      MatrixTools::apply_boundary_values(boundary_values,'
p45909
aS'                                         jacobian_matrix,'
p45910
aS'                                         dummy_solution,'
p45911
aS'                                         dummy_rhs);'
p45912
aS'    }'
p45913
aS'    {'
p45914
aS'      TimerOutput::Scope t(computing_timer, "factorizing the Jacobian");'
p45915
aS'      std::cout << "  Factorizing Jacobian matrix" << std::endl;'
p45916
aS'      jacobian_matrix_factorization = std::make_unique<SparseDirectUMFPACK>();'
p45917
aS'      jacobian_matrix_factorization->factorize(jacobian_matrix);'
p45918
aS'    }'
p45919
aS'  }'
p45920
aS'  template <int dim>'
p45921
aS'  void MinimalSurfaceProblem<dim>::compute_residual('
p45922
aS'    const Vector<double> &evaluation_point,'
p45923
aS'    Vector<double> &      residual)'
p45924
aS'  {'
p45925
aS'    TimerOutput::Scope t(computing_timer, "assembling the residual");'
p45926
aS'    std::cout << "  Computing residual vector..." << std::flush;'
p45927
aS'    const QGauss<dim> quadrature_formula(fe.degree + 1);'
p45928
aS'    FEValues<dim>     fe_values(fe,'
p45929
aS'                            quadrature_formula,'
p45930
aS'                            update_gradients | update_quadrature_points |'
p45931
aS'                              update_JxW_values);'
p45932
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p45933
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p45934
aS'    Vector<double>              cell_residual(dofs_per_cell);'
p45935
aS'    std::vector<Tensor<1, dim>> evaluation_point_gradients(n_q_points);'
p45936
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p45937
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p45938
aS'      {'
p45939
aS'        cell_residual = 0;'
p45940
aS'        fe_values.reinit(cell);'
p45941
aS'        fe_values.get_function_gradients(evaluation_point,'
p45942
aS'                                         evaluation_point_gradients);'
p45943
aS'        for (unsigned int q = 0; q < n_q_points; ++q)'
p45944
aS'          {'
p45945
aS'            const double coeff ='
p45946
aS'              1.0 / std::sqrt(1 + evaluation_point_gradients[q] *'
p45947
aS'                                    evaluation_point_gradients[q]);'
p45948
aS'            for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p45949
aS'              cell_residual(i) = (fe_values.shape_grad(i, q) // \\nabla \\phi_i'
p45950
aS'          }'
p45951
aS'        cell->get_dof_indices(local_dof_indices);'
p45952
aS'        for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p45953
aS'          residual(local_dof_indices[i]) += cell_residual(i);'
p45954
aS'      }'
p45955
aS'    hanging_node_constraints.condense(residual);'
p45956
aS'    for (const types::global_dof_index i :'
p45957
aS'         DoFTools::extract_boundary_dofs(dof_handler))'
p45958
aS'      residual(i) = 0;'
p45959
aS'    for (const types::global_dof_index i :'
p45960
aS'         DoFTools::extract_hanging_node_dofs(dof_handler))'
p45961
aS'      residual(i) = 0;'
p45962
aS'    std::cout << " norm=" << residual.l2_norm() << std::endl;'
p45963
aS'  }'
p45964
aS'  template <int dim>'
p45965
aS'  void MinimalSurfaceProblem<dim>::solve(const Vector<double> &rhs,'
p45966
aS'                                         Vector<double> &      solution,'
p45967
aS'                                         const double /*tolerance*/)'
p45968
aS'  {'
p45969
aS'    TimerOutput::Scope t(computing_timer, "linear system solve");'
p45970
aS'    std::cout << "  Solving linear system" << std::endl;'
p45971
aS'    jacobian_matrix_factorization->vmult(solution, rhs);'
p45972
aS'    hanging_node_constraints.distribute(solution);'
p45973
aS'  }'
p45974
aS'  template <int dim>'
p45975
aS'  void MinimalSurfaceProblem<dim>::refine_mesh()'
p45976
aS'  {'
p45977
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p45978
aS'    KellyErrorEstimator<dim>::estimate('
p45979
aS'      dof_handler,'
p45980
aS'      QGauss<dim - 1>(fe.degree + 1),'
p45981
aS'      std::map<types::boundary_id, const Function<dim> *>(),'
p45982
aS'      current_solution,'
p45983
aS'      estimated_error_per_cell);'
p45984
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p45985
aS'                                                    estimated_error_per_cell,'
p45986
aS'                                                    0.3,'
p45987
aS'                                                    0.03);'
p45988
aS'    triangulation.prepare_coarsening_and_refinement();'
p45989
aS'    SolutionTransfer<dim> solution_transfer(dof_handler);'
p45990
aS'    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);'
p45991
aS'    triangulation.execute_coarsening_and_refinement();'
p45992
aS'    dof_handler.distribute_dofs(fe);'
p45993
aS'    Vector<double> tmp(dof_handler.n_dofs());'
p45994
aS'    solution_transfer.interpolate(current_solution, tmp);'
p45995
aS'    current_solution = std::move(tmp);'
p45996
aS'    hanging_node_constraints.clear();'
p45997
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p45998
aS'                                            hanging_node_constraints);'
p45999
aS'    hanging_node_constraints.close();'
p46000
aS'    hanging_node_constraints.distribute(current_solution);'
p46001
aS'    set_boundary_values();'
p46002
aS'    setup_system(/*initial_step=*/false);'
p46003
aS'  }'
p46004
aS'  template <int dim>'
p46005
aS'  void MinimalSurfaceProblem<dim>::set_boundary_values()'
p46006
aS'  {'
p46007
aS'    std::map<types::global_dof_index, double> boundary_values;'
p46008
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p46009
aS'                                             0,'
p46010
aS'                                             BoundaryValues<dim>(),'
p46011
aS'                                             boundary_values);'
p46012
aS'    for (const auto &boundary_value : boundary_values)'
p46013
aS'      current_solution(boundary_value.first) = boundary_value.second;'
p46014
aS'    hanging_node_constraints.distribute(current_solution);'
p46015
aS'  }'
p46016
aS'  template <int dim>'
p46017
aS'  void MinimalSurfaceProblem<dim>::output_results('
p46018
aS'    const unsigned int refinement_cycle)'
p46019
aS'  {'
p46020
aS'    TimerOutput::Scope t(computing_timer, "graphical output");'
p46021
aS'    DataOut<dim> data_out;'
p46022
aS'    data_out.attach_dof_handler(dof_handler);'
p46023
aS'    data_out.add_data_vector(current_solution, "solution");'
p46024
aS'    data_out.build_patches();'
p46025
aS'    const std::string filename ='
p46026
aS'      "solution-" + Utilities::int_to_string(refinement_cycle, 2) + ".vtu";'
p46027
aS'    std::ofstream output(filename);'
p46028
aS'    data_out.write_vtu(output);'
p46029
aS'  }'
p46030
aS'  template <int dim>'
p46031
aS'  void MinimalSurfaceProblem<dim>::run()'
p46032
aS'  {'
p46033
aS'    GridGenerator::hyper_ball(triangulation);'
p46034
aS'    triangulation.refine_global(2);'
p46035
aS'    setup_system(/*initial_step=*/true);'
p46036
aS'    set_boundary_values();'
p46037
aS'    for (unsigned int refinement_cycle = 0; refinement_cycle < 6;'
p46038
aS'         ++refinement_cycle)'
p46039
aS'      {'
p46040
aS'        computing_timer.reset();'
p46041
aS'        std::cout << "Mesh refinement step " << refinement_cycle << std::endl;'
p46042
aS'        if (refinement_cycle != 0)'
p46043
aS'          refine_mesh();'
p46044
aS'        const double target_tolerance = 1e-3 * std::pow(0.1, refinement_cycle);'
p46045
aS'        std::cout << "  Target_tolerance: " << target_tolerance << std::endl'
p46046
aS'                  << std::endl;'
p46047
aS'        {'
p46048
aS'          typename SUNDIALS::KINSOL<Vector<double>>::AdditionalData'
p46049
aS'            additional_data;'
p46050
aS'          additional_data.function_tolerance = target_tolerance;'
p46051
aS'          SUNDIALS::KINSOL<Vector<double>> nonlinear_solver(additional_data);'
p46052
aS'          nonlinear_solver.reinit_vector = [&](Vector<double> &x) {'
p46053
aS'            x.reinit(dof_handler.n_dofs());'
p46054
aS'          };'
p46055
aS'          nonlinear_solver.residual ='
p46056
aS'            [&](const Vector<double> &evaluation_point,'
p46057
aS'                Vector<double> &      residual) {'
p46058
aS'              compute_residual(evaluation_point, residual);'
p46059
aS'              return 0;'
p46060
aS'            };'
p46061
aS'          nonlinear_solver.setup_jacobian ='
p46062
aS'            [&](const Vector<double> &current_u,'
p46063
aS'                const Vector<double> & /*current_f*/) {'
p46064
aS'              compute_and_factorize_jacobian(current_u);'
p46065
aS'              return 0;'
p46066
aS'            };'
p46067
aS'          nonlinear_solver.solve_with_jacobian = [&](const Vector<double> &rhs,'
p46068
aS'                                                     Vector<double> &      dst,'
p46069
aS'                                                     const double tolerance) {'
p46070
aS'            this->solve(rhs, dst, tolerance);'
p46071
aS'            return 0;'
p46072
aS'          };'
p46073
aS'          nonlinear_solver.solve(current_solution);'
p46074
aS'        }'
p46075
aS'        output_results(refinement_cycle);'
p46076
aS'        computing_timer.print_summary();'
p46077
aS'        std::cout << std::endl;'
p46078
aS'      }'
p46079
aS'  }'
p46080
aS'} // namespace Step77'
p46081
aS'int main()'
p46082
ag9
aS'  try'
p46083
aS'    {'
p46084
aS'      using namespace Step77;'
p46085
aS'      MinimalSurfaceProblem<2> laplace_problem_2d;'
p46086
aS'      laplace_problem_2d.run();'
p46087
aS'    }'
p46088
aS'  catch (std::exception &exc)'
p46089
aS'    {'
p46090
aS'      std::cerr << std::endl'
p46091
aS'                << std::endl'
p46092
aS'                << "----------------------------------------------------"'
p46093
aS'                << std::endl;'
p46094
aS'      std::cerr << "Exception on processing: " << std::endl'
p46095
aS'                << exc.what() << std::endl'
p46096
aS'                << "Aborting!" << std::endl'
p46097
aS'                << "----------------------------------------------------"'
p46098
aS'                << std::endl;'
p46099
aS'      return 1;'
p46100
aS'    }'
p46101
aS'  catch (...)'
p46102
aS'    {'
p46103
aS'      std::cerr << std::endl'
p46104
aS'                << std::endl'
p46105
aS'                << "----------------------------------------------------"'
p46106
aS'                << std::endl;'
p46107
aS'      std::cerr << "Unknown exception!" << std::endl'
p46108
aS'                << "Aborting!" << std::endl'
p46109
aS'                << "----------------------------------------------------"'
p46110
aS'                << std::endl;'
p46111
aS'      return 1;'
p46112
aS'    }'
p46113
aS'  return 0;'
p46114
ag17
aS'#include <deal.II/base/convergence_table.h>'
p46115
aS'#include <deal.II/base/function.h>'
p46116
aS'#include <deal.II/base/logstream.h>'
p46117
aS'#include <deal.II/base/quadrature_lib.h>'
p46118
aS'#include <deal.II/base/utilities.h>'
p46119
aS'#include <deal.II/dofs/dof_handler.h>'
p46120
aS'#include <deal.II/dofs/dof_accessor.h>'
p46121
aS'#include <deal.II/dofs/dof_tools.h>'
p46122
aS'#include <deal.II/fe/fe_q.h>'
p46123
aS'#include <deal.II/fe/fe_values.h>'
p46124
aS'#include <deal.II/grid/grid_generator.h>'
p46125
aS'#include <deal.II/grid/grid_refinement.h>'
p46126
aS'#include <deal.II/grid/grid_out.h>'
p46127
aS'#include <deal.II/grid/tria.h>'
p46128
aS'#include <deal.II/grid/tria_accessor.h>'
p46129
aS'#include <deal.II/grid/tria_iterator.h>'
p46130
aS'#include <deal.II/lac/affine_constraints.h>'
p46131
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p46132
aS'#include <deal.II/lac/full_matrix.h>'
p46133
aS'#include <deal.II/lac/precondition.h>'
p46134
aS'#include <deal.II/lac/sparse_matrix.h>'
p46135
aS'#include <deal.II/lac/solver_cg.h>'
p46136
aS'#include <deal.II/lac/vector.h>'
p46137
aS'#include <deal.II/numerics/data_out.h>'
p46138
aS'#include <deal.II/numerics/data_out_stack.h>'
p46139
aS'#include <deal.II/numerics/error_estimator.h>'
p46140
aS'#include <deal.II/numerics/matrix_tools.h>'
p46141
aS'#include <deal.II/numerics/solution_transfer.h>'
p46142
aS'#include <deal.II/numerics/vector_tools.h>'
p46143
aS'#include <fstream>'
p46144
aS'#include <iostream>'
p46145
aS'namespace BlackScholesSolver'
p46146
ag9
aS'  using namespace dealii;'
p46147
aS'#define MMS'
p46148
aS'  template <int dim>'
p46149
aS'  class Solution : public Function<dim>'
p46150
aS'  {'
p46151
aS'  public:'
p46152
aS'    Solution(const double maturity_time);'
p46153
aS'    virtual double value(const Point<dim> & p,'
p46154
aS'                         const unsigned int component = 0) const override;'
p46155
aS'    virtual Tensor<1, dim>'
p46156
aS'    gradient(const Point<dim> & p,'
p46157
aS'             const unsigned int component = 0) const override;'
p46158
aS'  private:'
p46159
aS'    const double maturity_time;'
p46160
aS'  };'
p46161
aS'  template <int dim>'
p46162
aS'  Solution<dim>::Solution(const double maturity_time)'
p46163
aS'    : maturity_time(maturity_time)'
p46164
aS'  {'
p46165
aS'    Assert(dim == 1, ExcNotImplemented());'
p46166
aS'  }'
p46167
aS'  template <int dim>'
p46168
aS'  double Solution<dim>::value(const Point<dim> & p,'
p46169
aS'                              const unsigned int component) const'
p46170
aS'  {'
p46171
aS'    return -Utilities::fixed_power<2, double>(p(component)) -'
p46172
aS'           Utilities::fixed_power<2, double>(this->get_time()) + 6;'
p46173
aS'  }'
p46174
aS'  template <int dim>'
p46175
aS'  Tensor<1, dim> Solution<dim>::gradient(const Point<dim> & p,'
p46176
aS'                                         const unsigned int component) const'
p46177
aS'  {'
p46178
aS'    return Point<dim>(-2 * p(component));'
p46179
aS'  }'
p46180
aS'  template <int dim>'
p46181
aS'  class InitialConditions : public Function<dim>'
p46182
aS'  {'
p46183
aS'  public:'
p46184
aS'    InitialConditions(const double strike_price);'
p46185
aS'    virtual double value(const Point<dim> & p,'
p46186
aS'                         const unsigned int component = 0) const override;'
p46187
aS'  private:'
p46188
aS'    const double strike_price;'
p46189
aS'  };'
p46190
aS'  template <int dim>'
p46191
aS'  InitialConditions<dim>::InitialConditions(const double strike_price)'
p46192
aS'    : strike_price(strike_price)'
p46193
aS'  {}'
p46194
aS'  template <int dim>'
p46195
aS'  double InitialConditions<dim>::value(const Point<dim> & p,'
p46196
aS'                                       const unsigned int component) const'
p46197
aS'  {'
p46198
aS'#ifdef MMS'
p46199
aS'    return -Utilities::fixed_power<2, double>(p(component)) + 6;'
p46200
aS'#else'
p46201
aS'    return std::max(p(component) - strike_price, 0.);'
p46202
aS'#endif'
p46203
aS'  }'
p46204
aS'  template <int dim>'
p46205
aS'  class LeftBoundaryValues : public Function<dim>'
p46206
aS'  {'
p46207
aS'  public:'
p46208
aS'    virtual double value(const Point<dim> & p,'
p46209
aS'                         const unsigned int component = 0) const override;'
p46210
aS'  };'
p46211
aS'  template <int dim>'
p46212
aS'  double LeftBoundaryValues<dim>::value(const Point<dim> &,'
p46213
aS'                                        const unsigned int /*component*/) const'
p46214
aS'  {'
p46215
aS'#ifdef MMS'
p46216
aS'    return -Utilities::fixed_power<2, double>(this->get_time()) + 6;'
p46217
aS'#else'
p46218
aS'    return 0.;'
p46219
aS'#endif'
p46220
aS'  }'
p46221
aS'  template <int dim>'
p46222
aS'  class RightBoundaryValues : public Function<dim>'
p46223
aS'  {'
p46224
aS'  public:'
p46225
aS'    RightBoundaryValues(const double strike_price, const double interest_rate);'
p46226
aS'    virtual double value(const Point<dim> & p,'
p46227
aS'                         const unsigned int component = 0) const override;'
p46228
aS'  private:'
p46229
aS'    const double strike_price;'
p46230
aS'    const double interest_rate;'
p46231
aS'  };'
p46232
aS'  template <int dim>'
p46233
aS'  RightBoundaryValues<dim>::RightBoundaryValues(const double strike_price,'
p46234
aS'                                                const double interest_rate)'
p46235
aS'    : strike_price(strike_price)'
p46236
aS'    , interest_rate(interest_rate)'
p46237
aS'  {}'
p46238
aS'  template <int dim>'
p46239
aS'  double RightBoundaryValues<dim>::value(const Point<dim> & p,'
p46240
aS'                                         const unsigned int component) const'
p46241
aS'  {'
p46242
aS'#ifdef MMS'
p46243
aS'    return -Utilities::fixed_power<2, double>(p(component)) -'
p46244
aS'           Utilities::fixed_power<2, double>(this->get_time()) + 6;'
p46245
aS'#else'
p46246
aS'    return (p(component) - strike_price) *'
p46247
aS'           exp((-interest_rate) * (this->get_time()));'
p46248
aS'#endif'
p46249
aS'  }'
p46250
aS'  template <int dim>'
p46251
aS'  class RightHandSide : public Function<dim>'
p46252
aS'  {'
p46253
aS'  public:'
p46254
aS'    RightHandSide(const double asset_volatility, const double interest_rate);'
p46255
aS'    virtual double value(const Point<dim> & p,'
p46256
aS'                         const unsigned int component = 0) const override;'
p46257
aS'  private:'
p46258
aS'    const double asset_volatility;'
p46259
aS'    const double interest_rate;'
p46260
aS'  };'
p46261
aS'  template <int dim>'
p46262
aS'  RightHandSide<dim>::RightHandSide(const double asset_volatility,'
p46263
aS'                                    const double interest_rate)'
p46264
aS'    : asset_volatility(asset_volatility)'
p46265
aS'    , interest_rate(interest_rate)'
p46266
aS'  {}'
p46267
aS'  template <int dim>'
p46268
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p46269
aS'                                   const unsigned int component) const'
p46270
aS'  {'
p46271
aS'#ifdef MMS'
p46272
aS'    return 2 * (this->get_time()) -'
p46273
aS'           Utilities::fixed_power<2, double>(asset_volatility * p(component)) -'
p46274
aS'           2 * interest_rate * Utilities::fixed_power<2, double>(p(component)) -'
p46275
aS'           interest_rate *'
p46276
aS'              Utilities::fixed_power<2, double>(this->get_time()) + 6);'
p46277
aS'#else'
p46278
aS'    return 0.0;'
p46279
aS'#endif'
p46280
aS'  }'
p46281
aS'  template <int dim>'
p46282
aS'  class BlackScholes'
p46283
aS'  {'
p46284
aS'  public:'
p46285
aS'    BlackScholes();'
p46286
aS'    void run();'
p46287
aS'  private:'
p46288
aS'    void setup_system();'
p46289
aS'    void solve_time_step();'
p46290
aS'    void refine_grid();'
p46291
aS'    void process_solution();'
p46292
aS'    void add_results_for_output();'
p46293
aS'    void write_convergence_table();'
p46294
aS'    const double maximum_stock_price;'
p46295
aS'    const double maturity_time;'
p46296
aS'    const double asset_volatility;'
p46297
aS'    const double interest_rate;'
p46298
aS'    const double strike_price;'
p46299
aS'    Triangulation<dim> triangulation;'
p46300
aS'    FE_Q<dim>          fe;'
p46301
aS'    DoFHandler<dim>    dof_handler;'
p46302
aS'    AffineConstraints<double> constraints;'
p46303
aS'    SparsityPattern      sparsity_pattern;'
p46304
aS'    SparseMatrix<double> mass_matrix;'
p46305
aS'    SparseMatrix<double> laplace_matrix;'
p46306
aS'    SparseMatrix<double> a_matrix;'
p46307
aS'    SparseMatrix<double> b_matrix;'
p46308
aS'    SparseMatrix<double> system_matrix;'
p46309
aS'    Vector<double> solution;'
p46310
aS'    Vector<double> system_rhs;'
p46311
aS'    double time;'
p46312
aS'    double time_step;'
p46313
aS'    const double       theta;'
p46314
aS'    const unsigned int n_cycles;'
p46315
aS'    const unsigned int n_time_steps;'
p46316
aS'    DataOutStack<dim>        data_out_stack;'
p46317
aS'    std::vector<std::string> solution_names;'
p46318
aS'    ConvergenceTable convergence_table;'
p46319
aS'  };'
p46320
aS'  template <int dim>'
p46321
aS'  BlackScholes<dim>::BlackScholes()'
p46322
aS'    : maximum_stock_price(1.)'
p46323
aS'    , maturity_time(1.)'
p46324
aS'    , asset_volatility(.2)'
p46325
aS'    , interest_rate(0.05)'
p46326
aS'    , strike_price(0.5)'
p46327
aS'    , fe(1)'
p46328
aS'    , dof_handler(triangulation)'
p46329
aS'    , time(0.0)'
p46330
aS'    , theta(0.5)'
p46331
aS'    , n_cycles(4)'
p46332
aS'    , n_time_steps(5000)'
p46333
aS'  {'
p46334
aS'    Assert(dim == 1, ExcNotImplemented());'
p46335
aS'  }'
p46336
aS'  template <int dim>'
p46337
aS'  void BlackScholes<dim>::setup_system()'
p46338
aS'  {'
p46339
aS'    dof_handler.distribute_dofs(fe);'
p46340
aS'    time_step = maturity_time / n_time_steps;'
p46341
aS'    constraints.clear();'
p46342
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p46343
aS'    constraints.close();'
p46344
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs());'
p46345
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p46346
aS'                                    dsp,'
p46347
aS'                                    constraints,'
p46348
aS'    sparsity_pattern.copy_from(dsp);'
p46349
aS'    mass_matrix.reinit(sparsity_pattern);'
p46350
aS'    laplace_matrix.reinit(sparsity_pattern);'
p46351
aS'    a_matrix.reinit(sparsity_pattern);'
p46352
aS'    b_matrix.reinit(sparsity_pattern);'
p46353
aS'    system_matrix.reinit(sparsity_pattern);'
p46354
aS'    MatrixCreator::create_mass_matrix(dof_handler,'
p46355
aS'                                      QGauss<dim>(fe.degree + 1),'
p46356
aS'                                      mass_matrix);'
p46357
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p46358
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p46359
aS'    QGauss<dim>        quadrature_formula(fe.degree + 1);'
p46360
aS'    FEValues<dim>      fe_values(fe,'
p46361
aS'                            quadrature_formula,'
p46362
aS'                            update_values | update_gradients |'
p46363
aS'                              update_quadrature_points | update_JxW_values);'
p46364
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p46365
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p46366
aS'      {'
p46367
aS'        cell_matrix = 0.;'
p46368
aS'        fe_values.reinit(cell);'
p46369
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p46370
aS'          {'
p46371
aS'            const double current_coefficient ='
p46372
aS'              fe_values.quadrature_point(q_index).square();'
p46373
aS'            for (const unsigned int i : fe_values.dof_indices())'
p46374
aS'              {'
p46375
aS'                for (const unsigned int j : fe_values.dof_indices())'
p46376
aS'                  cell_matrix(i, j) +='
p46377
aS'                     fe_values.shape_grad(i, q_index) * // grad phi_i(x_q)'
p46378
aS'                     fe_values.shape_grad(j, q_index) * // grad phi_j(x_q)'
p46379
aS'                     fe_values.JxW(q_index));           // dx'
p46380
aS'              }'
p46381
aS'          }'
p46382
aS'        cell->get_dof_indices(local_dof_indices);'
p46383
aS'        for (const unsigned int i : fe_values.dof_indices())'
p46384
aS'          {'
p46385
aS'            for (const unsigned int j : fe_values.dof_indices())'
p46386
aS'              laplace_matrix.add(local_dof_indices[i],'
p46387
aS'                                 local_dof_indices[j],'
p46388
aS'                                 cell_matrix(i, j));'
p46389
aS'          }'
p46390
aS'      }'
p46391
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p46392
aS'      {'
p46393
aS'        cell_matrix = 0.;'
p46394
aS'        fe_values.reinit(cell);'
p46395
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p46396
aS'          {'
p46397
aS'            const Tensor<1, dim> current_coefficient ='
p46398
aS'              fe_values.quadrature_point(q_index);'
p46399
aS'            for (const unsigned int i : fe_values.dof_indices())'
p46400
aS'              {'
p46401
aS'                for (const unsigned int j : fe_values.dof_indices())'
p46402
aS'                  {'
p46403
aS'                    cell_matrix(i, j) +='
p46404
aS'                       fe_values.shape_grad(i, q_index) *  // grad phi_i(x_q)'
p46405
aS'                       fe_values.shape_value(j, q_index) * // phi_j(x_q)'
p46406
aS'                       fe_values.JxW(q_index));            // dx'
p46407
aS'                  }'
p46408
aS'              }'
p46409
aS'          }'
p46410
aS'        cell->get_dof_indices(local_dof_indices);'
p46411
aS'        for (const unsigned int i : fe_values.dof_indices())'
p46412
aS'          {'
p46413
aS'            for (const unsigned int j : fe_values.dof_indices())'
p46414
aS'              a_matrix.add(local_dof_indices[i],'
p46415
aS'                           local_dof_indices[j],'
p46416
aS'                           cell_matrix(i, j));'
p46417
aS'          }'
p46418
aS'      }'
p46419
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p46420
aS'      {'
p46421
aS'        cell_matrix = 0.;'
p46422
aS'        fe_values.reinit(cell);'
p46423
aS'        for (const unsigned int q_index : fe_values.quadrature_point_indices())'
p46424
aS'          {'
p46425
aS'            const Tensor<1, dim> current_coefficient ='
p46426
aS'              fe_values.quadrature_point(q_index);'
p46427
aS'            for (const unsigned int i : fe_values.dof_indices())'
p46428
aS'              {'
p46429
aS'                for (const unsigned int j : fe_values.dof_indices())'
p46430
aS'                  cell_matrix(i, j) +='
p46431
aS'                     fe_values.shape_value(i, q_index) * // phi_i(x_q)'
p46432
aS'                     fe_values.shape_grad(j, q_index) *  // grad phi_j(x_q)'
p46433
aS'                     fe_values.JxW(q_index));            // dx'
p46434
aS'              }'
p46435
aS'          }'
p46436
aS'        cell->get_dof_indices(local_dof_indices);'
p46437
aS'        for (const unsigned int i : fe_values.dof_indices())'
p46438
aS'          {'
p46439
aS'            for (const unsigned int j : fe_values.dof_indices())'
p46440
aS'              b_matrix.add(local_dof_indices[i],'
p46441
aS'                           local_dof_indices[j],'
p46442
aS'                           cell_matrix(i, j));'
p46443
aS'          }'
p46444
aS'      }'
p46445
aS'    solution.reinit(dof_handler.n_dofs());'
p46446
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p46447
aS'  }'
p46448
aS'  template <int dim>'
p46449
aS'  void BlackScholes<dim>::solve_time_step()'
p46450
aS'  {'
p46451
aS'    SolverControl                          solver_control(1000, 1e-12);'
p46452
aS'    SolverCG<Vector<double>>               cg(solver_control);'
p46453
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p46454
aS'    preconditioner.initialize(system_matrix, 1.0);'
p46455
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p46456
aS'    constraints.distribute(solution);'
p46457
aS'  }'
p46458
aS'  template <int dim>'
p46459
aS'  void BlackScholes<dim>::add_results_for_output()'
p46460
aS'  {'
p46461
aS'    data_out_stack.new_parameter_value(time, time_step);'
p46462
aS'    data_out_stack.attach_dof_handler(dof_handler);'
p46463
aS'    data_out_stack.add_data_vector(solution, solution_names);'
p46464
aS'    data_out_stack.build_patches(2);'
p46465
aS'    data_out_stack.finish_parameter_value();'
p46466
aS'  }'
p46467
aS'  template <int dim>'
p46468
aS'  void BlackScholes<dim>::refine_grid()'
p46469
aS'  {'
p46470
aS'    triangulation.refine_global(1);'
p46471
aS'  }'
p46472
aS'  template <int dim>'
p46473
aS'  void BlackScholes<dim>::process_solution()'
p46474
aS'  {'
p46475
aS'    Solution<dim> sol(maturity_time);'
p46476
aS'    sol.set_time(time);'
p46477
aS'    Vector<float> difference_per_cell(triangulation.n_active_cells());'
p46478
aS'    VectorTools::integrate_difference(dof_handler,'
p46479
aS'                                      solution,'
p46480
aS'                                      sol,'
p46481
aS'                                      difference_per_cell,'
p46482
aS'                                      QGauss<dim>(fe.degree + 1),'
p46483
aS'                                      VectorTools::L2_norm);'
p46484
aS'    const double L2_error ='
p46485
aS'      VectorTools::compute_global_error(triangulation,'
p46486
aS'                                        difference_per_cell,'
p46487
aS'                                        VectorTools::L2_norm);'
p46488
aS'    VectorTools::integrate_difference(dof_handler,'
p46489
aS'                                      solution,'
p46490
aS'                                      sol,'
p46491
aS'                                      difference_per_cell,'
p46492
aS'                                      QGauss<dim>(fe.degree + 1),'
p46493
aS'                                      VectorTools::H1_seminorm);'
p46494
aS'    const double H1_error ='
p46495
aS'      VectorTools::compute_global_error(triangulation,'
p46496
aS'                                        difference_per_cell,'
p46497
aS'                                        VectorTools::H1_seminorm);'
p46498
aS'    const QTrapezoid<1>  q_trapezoid;'
p46499
aS'    const QIterated<dim> q_iterated(q_trapezoid, fe.degree * 2 + 1);'
p46500
aS'    VectorTools::integrate_difference(dof_handler,'
p46501
aS'                                      solution,'
p46502
aS'                                      sol,'
p46503
aS'                                      difference_per_cell,'
p46504
aS'                                      q_iterated,'
p46505
aS'                                      VectorTools::Linfty_norm);'
p46506
aS'    const double Linfty_error ='
p46507
aS'      VectorTools::compute_global_error(triangulation,'
p46508
aS'                                        difference_per_cell,'
p46509
aS'                                        VectorTools::Linfty_norm);'
p46510
aS'    const unsigned int n_active_cells = triangulation.n_active_cells();'
p46511
aS'    const unsigned int n_dofs         = dof_handler.n_dofs();'
p46512
aS'    convergence_table.add_value("cells", n_active_cells);'
p46513
aS'    convergence_table.add_value("dofs", n_dofs);'
p46514
aS'    convergence_table.add_value("L2", L2_error);'
p46515
aS'    convergence_table.add_value("H1", H1_error);'
p46516
aS'    convergence_table.add_value("Linfty", Linfty_error);'
p46517
aS'  }'
p46518
aS'  template <int dim>'
p46519
aS'  void BlackScholes<dim>::write_convergence_table()'
p46520
aS'  {'
p46521
aS'    convergence_table.set_precision("L2", 3);'
p46522
aS'    convergence_table.set_precision("H1", 3);'
p46523
aS'    convergence_table.set_precision("Linfty", 3);'
p46524
aS'    convergence_table.set_scientific("L2", true);'
p46525
aS'    convergence_table.set_scientific("H1", true);'
p46526
aS'    convergence_table.set_scientific("Linfty", true);'
p46527
aS'    convergence_table.set_tex_caption("cells", "\\\\# cells");'
p46528
aS'    convergence_table.set_tex_caption("dofs", "\\\\# dofs");'
p46529
aS'    convergence_table.set_tex_caption("L2", "@f$L^2@f$-error");'
p46530
aS'    convergence_table.set_tex_caption("H1", "@f$H^1@f$-error");'
p46531
aS'    convergence_table.set_tex_caption("Linfty", "@f$L^\\\\infty@f$-error");'
p46532
aS'    convergence_table.set_tex_format("cells", "r");'
p46533
aS'    convergence_table.set_tex_format("dofs", "r");'
p46534
aS'    std::cout << std::endl;'
p46535
aS'    convergence_table.write_text(std::cout);'
p46536
aS'    std::string error_filename = "error";'
p46537
aS'    error_filename += "-global";'
p46538
aS'    error_filename += ".tex";'
p46539
aS'    std::ofstream error_table_file(error_filename);'
p46540
aS'    convergence_table.write_tex(error_table_file);'
p46541
aS'    convergence_table.add_column_to_supercolumn("cells", "n cells");'
p46542
aS'    std::vector<std::string> new_order;'
p46543
aS'    new_order.emplace_back("n cells");'
p46544
aS'    new_order.emplace_back("H1");'
p46545
aS'    new_order.emplace_back("L2");'
p46546
aS'    convergence_table.set_column_order(new_order);'
p46547
aS'    convergence_table.evaluate_convergence_rates('
p46548
aS'      "L2", ConvergenceTable::reduction_rate);'
p46549
aS'    convergence_table.evaluate_convergence_rates('
p46550
aS'      "L2", ConvergenceTable::reduction_rate_log2);'
p46551
aS'    convergence_table.evaluate_convergence_rates('
p46552
aS'      "H1", ConvergenceTable::reduction_rate);'
p46553
aS'    convergence_table.evaluate_convergence_rates('
p46554
aS'      "H1", ConvergenceTable::reduction_rate_log2);'
p46555
aS'    std::cout << std::endl;'
p46556
aS'    convergence_table.write_text(std::cout);'
p46557
aS'    std::string conv_filename = "convergence";'
p46558
aS'    conv_filename += "-global";'
p46559
aS'    switch (fe.degree)'
p46560
aS'      {'
p46561
aS'        case 1:'
p46562
aS'          conv_filename += "-q1";'
p46563
aS'          break;'
p46564
aS'        case 2:'
p46565
aS'          conv_filename += "-q2";'
p46566
aS'          break;'
p46567
aS'        default:'
p46568
aS'          Assert(false, ExcNotImplemented());'
p46569
aS'      }'
p46570
aS'    conv_filename += ".tex";'
p46571
aS'    std::ofstream table_file(conv_filename);'
p46572
aS'    convergence_table.write_tex(table_file);'
p46573
aS'  }'
p46574
aS'  template <int dim>'
p46575
aS'  void BlackScholes<dim>::run()'
p46576
aS'  {'
p46577
aS'    GridGenerator::hyper_cube(triangulation, 0.0, maximum_stock_price, true);'
p46578
aS'    triangulation.refine_global(0);'
p46579
aS'    solution_names.emplace_back("u");'
p46580
aS'    data_out_stack.declare_data_vector(solution_names,'
p46581
aS'                                       DataOutStack<dim>::dof_vector);'
p46582
aS'    Vector<double> vmult_result;'
p46583
aS'    Vector<double> forcing_terms;'
p46584
aS'    for (unsigned int cycle = 0; cycle < n_cycles; cycle++)'
p46585
aS'      {'
p46586
aS'        if (cycle != 0)'
p46587
aS'          {'
p46588
aS'            refine_grid();'
p46589
aS'            time = 0.0;'
p46590
aS'          }'
p46591
aS'        setup_system();'
p46592
aS'        std::cout << std::endl'
p46593
aS'                  << "===========================================" << std::endl'
p46594
aS'                  << "Cycle " << cycle << \':\' << std::endl'
p46595
aS'                  << "Number of active cells: "'
p46596
aS'                  << triangulation.n_active_cells() << std::endl'
p46597
aS'                  << "Number of degrees of freedom: " << dof_handler.n_dofs()'
p46598
aS'                  << std::endl'
p46599
aS'                  << std::endl;'
p46600
aS'        VectorTools::interpolate(dof_handler,'
p46601
aS'                                 InitialConditions<dim>(strike_price),'
p46602
aS'                                 solution);'
p46603
aS'        if (cycle == (n_cycles - 1))'
p46604
aS'          {'
p46605
aS'            add_results_for_output();'
p46606
aS'          }'
p46607
aS'        vmult_result.reinit(dof_handler.n_dofs());'
p46608
aS'        forcing_terms.reinit(dof_handler.n_dofs());'
p46609
aS'        for (unsigned int timestep_number = 0; timestep_number < n_time_steps;'
p46610
aS'             ++timestep_number)'
p46611
aS'          {'
p46612
aS'            time += time_step;'
p46613
aS'            if (timestep_number % 1000 == 0)'
p46614
aS'              std::cout << "Time step " << timestep_number << " at t=" << time'
p46615
aS'                        << std::endl;'
p46616
aS'            mass_matrix.vmult(system_rhs, solution);'
p46617
aS'            laplace_matrix.vmult(vmult_result, solution);'
p46618
aS'            system_rhs.add('
p46619
aS'                Utilities::fixed_power<2, double>(asset_volatility) * 0.5,'
p46620
aS'              vmult_result);'
p46621
aS'            mass_matrix.vmult(vmult_result, solution);'
p46622
aS'            system_rhs.add((-1) * (1 - theta) * time_step * interest_rate * 2,'
p46623
aS'                           vmult_result);'
p46624
aS'            a_matrix.vmult(vmult_result, solution);'
p46625
aS'            system_rhs.add((-1) * time_step * interest_rate, vmult_result);'
p46626
aS'            b_matrix.vmult(vmult_result, solution);'
p46627
aS'            system_rhs.add('
p46628
aS'                time_step * 1,'
p46629
aS'              vmult_result);'
p46630
aS'            RightHandSide<dim> rhs_function(asset_volatility, interest_rate);'
p46631
aS'            rhs_function.set_time(time);'
p46632
aS'            VectorTools::create_right_hand_side(dof_handler,'
p46633
aS'                                                QGauss<dim>(fe.degree + 1),'
p46634
aS'                                                rhs_function,'
p46635
aS'                                                forcing_terms);'
p46636
aS'            forcing_terms *= time_step * theta;'
p46637
aS'            system_rhs -= forcing_terms;'
p46638
aS'            rhs_function.set_time(time - time_step);'
p46639
aS'            VectorTools::create_right_hand_side(dof_handler,'
p46640
aS'                                                QGauss<dim>(fe.degree + 1),'
p46641
aS'                                                rhs_function,'
p46642
aS'                                                forcing_terms);'
p46643
aS'            forcing_terms *= time_step * (1 - theta);'
p46644
aS'            system_rhs -= forcing_terms;'
p46645
aS'            system_matrix.copy_from(mass_matrix);'
p46646
aS'            system_matrix.add('
p46647
aS'                Utilities::fixed_power<2, double>(asset_volatility) * 0.5,'
p46648
aS'              laplace_matrix);'
p46649
aS'            system_matrix.add((time_step)*interest_rate * theta * (1 + 1),'
p46650
aS'                              mass_matrix);'
p46651
aS'            constraints.condense(system_matrix, system_rhs);'
p46652
aS'            {'
p46653
aS'              RightBoundaryValues<dim> right_boundary_function(strike_price,'
p46654
aS'                                                               interest_rate);'
p46655
aS'              LeftBoundaryValues<dim>  left_boundary_function;'
p46656
aS'              right_boundary_function.set_time(time);'
p46657
aS'              left_boundary_function.set_time(time);'
p46658
aS'              std::map<types::global_dof_index, double> boundary_values;'
p46659
aS'              VectorTools::interpolate_boundary_values(dof_handler,'
p46660
aS'                                                       0,'
p46661
aS'                                                       left_boundary_function,'
p46662
aS'                                                       boundary_values);'
p46663
aS'              VectorTools::interpolate_boundary_values(dof_handler,'
p46664
aS'                                                       1,'
p46665
aS'                                                       right_boundary_function,'
p46666
aS'                                                       boundary_values);'
p46667
aS'              MatrixTools::apply_boundary_values(boundary_values,'
p46668
aS'                                                 system_matrix,'
p46669
aS'                                                 solution,'
p46670
aS'                                                 system_rhs);'
p46671
aS'            }'
p46672
aS'            solve_time_step();'
p46673
aS'            if (cycle == (n_cycles - 1))'
p46674
aS'              {'
p46675
aS'                add_results_for_output();'
p46676
aS'              }'
p46677
aS'          }'
p46678
aS'#ifdef MMS'
p46679
aS'        process_solution();'
p46680
aS'#endif'
p46681
aS'      }'
p46682
aS'    const std::string filename = "solution.vtk";'
p46683
aS'    std::ofstream     output(filename);'
p46684
aS'    data_out_stack.write_vtk(output);'
p46685
aS'#ifdef MMS'
p46686
aS'    write_convergence_table();'
p46687
aS'#endif'
p46688
aS'  }'
p46689
aS'} // namespace BlackScholesSolver'
p46690
aS'int main()'
p46691
ag9
aS'  try'
p46692
aS'    {'
p46693
aS'      using namespace BlackScholesSolver;'
p46694
aS'      BlackScholes<1> black_scholes_solver;'
p46695
aS'      black_scholes_solver.run();'
p46696
aS'    }'
p46697
aS'  catch (std::exception &exc)'
p46698
aS'    {'
p46699
aS'      std::cerr << std::endl'
p46700
aS'                << std::endl'
p46701
aS'                << "----------------------------------------------------"'
p46702
aS'                << std::endl;'
p46703
aS'      std::cerr << "Exception on processing: " << std::endl'
p46704
aS'                << exc.what() << std::endl'
p46705
aS'                << "Aborting!" << std::endl'
p46706
aS'                << "----------------------------------------------------"'
p46707
aS'                << std::endl;'
p46708
aS'      return 1;'
p46709
aS'    }'
p46710
aS'  catch (...)'
p46711
aS'    {'
p46712
aS'      std::cerr << std::endl'
p46713
aS'                << std::endl'
p46714
aS'                << "----------------------------------------------------"'
p46715
aS'                << std::endl;'
p46716
aS'      std::cerr << "Unknown exception!" << std::endl'
p46717
aS'                << "Aborting!" << std::endl'
p46718
aS'                << "----------------------------------------------------"'
p46719
aS'                << std::endl;'
p46720
aS'      return 1;'
p46721
aS'    }'
p46722
aS'  return 0;'
p46723
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p46724
aS'#include <deal.II/base/function.h>'
p46725
aS'#include <deal.II/base/tensor.h>'
p46726
aS'#include <deal.II/base/timer.h>'
p46727
aS'#include <deal.II/base/signaling_nan.h>'
p46728
aS'#include <deal.II/lac/block_vector.h>'
p46729
aS'#include <deal.II/lac/full_matrix.h>'
p46730
aS'#include <deal.II/lac/block_sparse_matrix.h>'
p46731
aS'#include <deal.II/lac/linear_operator.h>'
p46732
aS'#include <deal.II/lac/packaged_operation.h>'
p46733
aS'#include <deal.II/lac/sparse_direct.h>'
p46734
aS'#include <deal.II/lac/affine_constraints.h>'
p46735
aS'#include <deal.II/grid/tria.h>'
p46736
aS'#include <deal.II/grid/grid_generator.h>'
p46737
aS'#include <deal.II/grid/grid_refinement.h>'
p46738
aS'#include <deal.II/dofs/dof_handler.h>'
p46739
aS'#include <deal.II/dofs/dof_renumbering.h>'
p46740
aS'#include <deal.II/dofs/dof_tools.h>'
p46741
aS'#include <deal.II/fe/fe_values.h>'
p46742
aS'#include <deal.II/fe/fe_dgq.h>'
p46743
aS'#include <deal.II/fe/fe_system.h>'
p46744
aS'#include <deal.II/fe/fe_q.h>'
p46745
aS'#include <deal.II/numerics/vector_tools.h>'
p46746
aS'#include <deal.II/numerics/matrix_tools.h>'
p46747
aS'#include <deal.II/numerics/data_out.h>'
p46748
aS'#include <iostream>'
p46749
aS'#include <fstream>'
p46750
aS'#include <algorithm>'
p46751
aS'namespace SAND'
p46752
ag9
aS'  using namespace dealii;'
p46753
aS'  namespace SolutionComponents'
p46754
aS'  {'
p46755
aS'    template <int dim>'
p46756
aS'    constexpr unsigned int density = 0;'
p46757
aS'    template <int dim>'
p46758
aS'    constexpr unsigned int displacement = 1;'
p46759
aS'    template <int dim>'
p46760
aS'    constexpr unsigned int unfiltered_density = 1 + dim;'
p46761
aS'    template <int dim>'
p46762
aS'    constexpr unsigned int displacement_multiplier = 2 + dim;'
p46763
aS'    template <int dim>'
p46764
aS'    constexpr unsigned int unfiltered_density_multiplier = 2 + 2 * dim;'
p46765
aS'    template <int dim>'
p46766
aS'    constexpr unsigned int density_lower_slack = 3 + 2 * dim;'
p46767
aS'    template <int dim>'
p46768
aS'    constexpr unsigned int density_lower_slack_multiplier = 4 + 2 * dim;'
p46769
aS'    template <int dim>'
p46770
aS'    constexpr unsigned int density_upper_slack = 5 + 2 * dim;'
p46771
aS'    template <int dim>'
p46772
aS'    constexpr unsigned int density_upper_slack_multiplier = 6 + 2 * dim;'
p46773
aS'  } // namespace SolutionComponents'
p46774
aS'  namespace SolutionBlocks'
p46775
aS'  {'
p46776
aS'    constexpr unsigned int density                        = 0;'
p46777
aS'    constexpr unsigned int displacement                   = 1;'
p46778
aS'    constexpr unsigned int unfiltered_density             = 2;'
p46779
aS'    constexpr unsigned int displacement_multiplier        = 3;'
p46780
aS'    constexpr unsigned int unfiltered_density_multiplier  = 4;'
p46781
aS'    constexpr unsigned int density_lower_slack            = 5;'
p46782
aS'    constexpr unsigned int density_lower_slack_multiplier = 6;'
p46783
aS'    constexpr unsigned int density_upper_slack            = 7;'
p46784
aS'    constexpr unsigned int density_upper_slack_multiplier = 8;'
p46785
aS'  } // namespace SolutionBlocks'
p46786
aS'  namespace BoundaryIds'
p46787
aS'  {'
p46788
aS'    constexpr types::boundary_id down_force = 101;'
p46789
aS'    constexpr types::boundary_id no_force   = 102;'
p46790
aS'  } // namespace BoundaryIds'
p46791
aS'  namespace ValueExtractors'
p46792
aS'  {'
p46793
aS'    template <int dim>'
p46794
aS'    const FEValuesExtractors::Scalar'
p46795
aS'      densities(SolutionComponents::density<dim>);'
p46796
aS'    template <int dim>'
p46797
aS'    const FEValuesExtractors::Vector'
p46798
aS'      displacements(SolutionComponents::displacement<dim>);'
p46799
aS'    template <int dim>'
p46800
aS'    const FEValuesExtractors::Scalar'
p46801
aS'      unfiltered_densities(SolutionComponents::unfiltered_density<dim>);'
p46802
aS'    template <int dim>'
p46803
aS'    const FEValuesExtractors::Vector displacement_multipliers('
p46804
aS'      SolutionComponents::displacement_multiplier<dim>);'
p46805
aS'    template <int dim>'
p46806
aS'    const FEValuesExtractors::Scalar unfiltered_density_multipliers('
p46807
aS'      SolutionComponents::unfiltered_density_multiplier<dim>);'
p46808
aS'    template <int dim>'
p46809
aS'    const FEValuesExtractors::Scalar'
p46810
aS'      density_lower_slacks(SolutionComponents::density_lower_slack<dim>);'
p46811
aS'    template <int dim>'
p46812
aS'    const FEValuesExtractors::Scalar density_lower_slack_multipliers('
p46813
aS'      SolutionComponents::density_lower_slack_multiplier<dim>);'
p46814
aS'    template <int dim>'
p46815
aS'    const FEValuesExtractors::Scalar'
p46816
aS'      density_upper_slacks(SolutionComponents::density_upper_slack<dim>);'
p46817
aS'    template <int dim>'
p46818
aS'    const FEValuesExtractors::Scalar density_upper_slack_multipliers('
p46819
aS'      SolutionComponents::density_upper_slack_multiplier<dim>);'
p46820
aS'  } // namespace ValueExtractors'
p46821
aS'  template <int dim>'
p46822
aS'  class SANDTopOpt'
p46823
aS'  {'
p46824
aS'  public:'
p46825
aS'    SANDTopOpt();'
p46826
aS'    void run();'
p46827
aS'  private:'
p46828
aS'    void create_triangulation();'
p46829
aS'    void setup_boundary_values();'
p46830
aS'    void setup_block_system();'
p46831
aS'    void setup_filter_matrix();'
p46832
aS'    void assemble_system();'
p46833
aS'    BlockVector<double> solve();'
p46834
aS'    std::pair<double, double>'
p46835
aS'    calculate_max_step_size(const BlockVector<double> &state,'
p46836
aS'                            const BlockVector<double> &step) const;'
p46837
aS'    BlockVector<double>'
p46838
aS'    calculate_test_rhs(const BlockVector<double> &test_solution) const;'
p46839
aS'    double calculate_exact_merit(const BlockVector<double> &test_solution);'
p46840
aS'    BlockVector<double> find_max_step();'
p46841
aS'    BlockVector<double> compute_scaled_step(const BlockVector<double> &state,'
p46842
aS'                                            const BlockVector<double> &step,'
p46843
aS'                                            const double descent_requirement);'
p46844
aS'    bool check_convergence(const BlockVector<double> &state);'
p46845
aS'    void output_results(const unsigned int j) const;'
p46846
aS'    void write_as_stl();'
p46847
aS'    std::set<typename Triangulation<dim>::cell_iterator>'
p46848
aS'    find_relevant_neighbors('
p46849
aS'      typename Triangulation<dim>::cell_iterator cell) const;'
p46850
aS'    Triangulation<dim>        triangulation;'
p46851
aS'    FESystem<dim>             fe;'
p46852
aS'    DoFHandler<dim>           dof_handler;'
p46853
aS'    AffineConstraints<double> constraints;'
p46854
aS'    std::map<types::global_dof_index, double> boundary_values;'
p46855
aS'    BlockSparsityPattern      sparsity_pattern;'
p46856
aS'    BlockSparseMatrix<double> system_matrix;'
p46857
aS'    SparsityPattern      filter_sparsity_pattern;'
p46858
aS'    SparseMatrix<double> filter_matrix;'
p46859
aS'    BlockVector<double> system_rhs;'
p46860
aS'    BlockVector<double> nonlinear_solution;'
p46861
aS'    const double density_ratio;'
p46862
aS'    const double density_penalty_exponent;'
p46863
aS'    const double filter_r;'
p46864
aS'    double       penalty_multiplier;'
p46865
aS'    double       barrier_size;'
p46866
aS'    TimerOutput timer;'
p46867
aS'  };'
p46868
aS'  template <int dim>'
p46869
aS'  SANDTopOpt<dim>::SANDTopOpt()'
p46870
aS'    : fe(FE_DGQ<dim>(0),'
p46871
aS'         1,'
p46872
aS'         1,'
p46873
aS'         FE_DGQ<dim>(0),'
p46874
aS'         1,'
p46875
aS'         1,'
p46876
aS'         FE_DGQ<dim>(0),'
p46877
aS'         5)'
p46878
aS'    , dof_handler(triangulation)'
p46879
aS'    , density_ratio(.5)'
p46880
aS'    , density_penalty_exponent(3)'
p46881
aS'    , filter_r(.251)'
p46882
aS'    , penalty_multiplier(1)'
p46883
aS'    , timer(std::cout, TimerOutput::summary, TimerOutput::wall_times)'
p46884
aS'  {'
p46885
aS'    Assert(dim > 1, ExcNotImplemented());'
p46886
aS'  }'
p46887
aS'  template <int dim>'
p46888
aS'  void SANDTopOpt<dim>::create_triangulation()'
p46889
aS'  {'
p46890
aS'    Assert(dim == 2, ExcNotImplemented());'
p46891
aS'    GridGenerator::subdivided_hyper_rectangle(triangulation,'
p46892
aS'                                              {6, 1},'
p46893
aS'                                              Point<dim>(0, 0),'
p46894
aS'                                              Point<dim>(6, 1));'
p46895
aS'    triangulation.refine_global(3);'
p46896
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p46897
aS'      {'
p46898
aS'        for (const auto &face : cell->face_iterators())'
p46899
aS'          {'
p46900
aS'            if (face->at_boundary())'
p46901
aS'              {'
p46902
aS'                const auto center = face->center();'
p46903
aS'                if (std::fabs(center(1) - 1) < 1e-12)'
p46904
aS'                  {'
p46905
aS'                    if ((std::fabs(center(0) - 3) < .3))'
p46906
aS'                      face->set_boundary_id(BoundaryIds::down_force);'
p46907
aS'                    else'
p46908
aS'                      face->set_boundary_id(BoundaryIds::no_force);'
p46909
aS'                  }'
p46910
aS'                else'
p46911
aS'                  face->set_boundary_id(BoundaryIds::no_force);'
p46912
aS'              }'
p46913
aS'          }'
p46914
aS'      }'
p46915
aS'  }'
p46916
aS'  template <int dim>'
p46917
aS'  void SANDTopOpt<dim>::setup_boundary_values()'
p46918
aS'  {'
p46919
aS'    boundary_values.clear();'
p46920
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p46921
aS'      {'
p46922
aS'        for (const auto &face : cell->face_iterators())'
p46923
aS'          {'
p46924
aS'            if (face->at_boundary())'
p46925
aS'              {'
p46926
aS'                const auto center = face->center();'
p46927
aS'                if (std::fabs(center(1) - 0) < 1e-12)'
p46928
aS'                  {'
p46929
aS'                    for (const auto vertex_number : cell->vertex_indices())'
p46930
aS'                      {'
p46931
aS'                        const auto vert = cell->vertex(vertex_number);'
p46932
aS'                        if (std::fabs(vert(0) - 0) < 1e-12 &&'
p46933
aS'                            std::fabs(vert(1) - 0) < 1e-12)'
p46934
aS'                          {'
p46935
aS'                            types::global_dof_index x_displacement ='
p46936
aS'                              cell->vertex_dof_index(vertex_number, 0);'
p46937
aS'                            types::global_dof_index y_displacement ='
p46938
aS'                              cell->vertex_dof_index(vertex_number, 1);'
p46939
aS'                            types::global_dof_index x_displacement_multiplier ='
p46940
aS'                              cell->vertex_dof_index(vertex_number, 2);'
p46941
aS'                            types::global_dof_index y_displacement_multiplier ='
p46942
aS'                              cell->vertex_dof_index(vertex_number, 3);'
p46943
aS'                            boundary_values[x_displacement]            = 0;'
p46944
aS'                            boundary_values[y_displacement]            = 0;'
p46945
aS'                            boundary_values[x_displacement_multiplier] = 0;'
p46946
aS'                            boundary_values[y_displacement_multiplier] = 0;'
p46947
aS'                          }'
p46948
aS'                        else if (std::fabs(vert(0) - 6) < 1e-12 &&'
p46949
aS'                                 std::fabs(vert(1) - 0) < 1e-12)'
p46950
aS'                          {'
p46951
aS'                            types::global_dof_index y_displacement ='
p46952
aS'                              cell->vertex_dof_index(vertex_number, 1);'
p46953
aS'                            types::global_dof_index y_displacement_multiplier ='
p46954
aS'                              cell->vertex_dof_index(vertex_number, 3);'
p46955
aS'                            boundary_values[y_displacement]            = 0;'
p46956
aS'                            boundary_values[y_displacement_multiplier] = 0;'
p46957
aS'                          }'
p46958
aS'                      }'
p46959
aS'                  }'
p46960
aS'              }'
p46961
aS'          }'
p46962
aS'      }'
p46963
aS'  }'
p46964
aS'  template <int dim>'
p46965
aS'  void SANDTopOpt<dim>::setup_block_system()'
p46966
aS'  {'
p46967
aS'    std::vector<unsigned int> block_component(9, 2);'
p46968
aS'    block_component[0] = 0;'
p46969
aS'    block_component[1] = 1;'
p46970
aS'    const std::vector<types::global_dof_index> dofs_per_block ='
p46971
aS'      DoFTools::count_dofs_per_fe_block(dof_handler, block_component);'
p46972
aS'    const types::global_dof_index                     n_p = dofs_per_block[0];'
p46973
aS'    const types::global_dof_index                     n_u = dofs_per_block[1];'
p46974
aS'    const std::vector<BlockVector<double>::size_type> block_sizes = {'
p46975
aS'      n_p, n_u, n_p, n_u, n_p, n_p, n_p, n_p, n_p};'
p46976
aS'    BlockDynamicSparsityPattern dsp(9, 9);'
p46977
aS'    for (unsigned int k = 0; k < 9; ++k)'
p46978
aS'      for (unsigned int j = 0; j < 9; ++j)'
p46979
aS'        dsp.block(j, k).reinit(block_sizes[j], block_sizes[k]);'
p46980
aS'    dsp.collect_sizes();'
p46981
aS'    Table<2, DoFTools::Coupling> coupling(2 * dim + 7, 2 * dim + 7);'
p46982
aS'    {'
p46983
aS'      using namespace SolutionComponents;'
p46984
aS'      coupling[density<dim>][density<dim>] = DoFTools::always;'
p46985
aS'      for (unsigned int i = 0; i < dim; ++i)'
p46986
aS'        {'
p46987
aS'          coupling[density<dim>][displacement<dim> + i] = DoFTools::always;'
p46988
aS'          coupling[displacement<dim> + i][density<dim>] = DoFTools::always;'
p46989
aS'        }'
p46990
aS'      for (unsigned int i = 0; i < dim; ++i)'
p46991
aS'        {'
p46992
aS'          coupling[density<dim>][displacement_multiplier<dim> + i] ='
p46993
aS'            DoFTools::always;'
p46994
aS'          coupling[displacement_multiplier<dim> + i][density<dim>] ='
p46995
aS'            DoFTools::always;'
p46996
aS'        }'
p46997
aS'      coupling[density<dim>][unfiltered_density_multiplier<dim>] ='
p46998
aS'        DoFTools::always;'
p46999
aS'      coupling[unfiltered_density_multiplier<dim>][density<dim>] ='
p47000
aS'        DoFTools::always;'
p47001
aS'      for (unsigned int i = 0; i < dim; ++i)'
p47002
aS'        {'
p47003
aS'          for (unsigned int k = 0; k < dim; ++k)'
p47004
aS'            {'
p47005
aS'              coupling[displacement<dim> + i]'
p47006
aS'                      [displacement_multiplier<dim> + k] = DoFTools::always;'
p47007
aS'              coupling[displacement_multiplier<dim> + k]'
p47008
aS'                      [displacement<dim> + i] = DoFTools::always;'
p47009
aS'            }'
p47010
aS'        }'
p47011
aS'      coupling[density_lower_slack<dim>][density_lower_slack<dim>] ='
p47012
aS'        DoFTools::always;'
p47013
aS'      coupling[density_lower_slack<dim>][density_upper_slack<dim>] ='
p47014
aS'        DoFTools::always;'
p47015
aS'      coupling[density_upper_slack<dim>][density_lower_slack<dim>] ='
p47016
aS'        DoFTools::always;'
p47017
aS'      coupling[density_lower_slack_multiplier<dim>]'
p47018
aS'              [density_lower_slack_multiplier<dim>] = DoFTools::always;'
p47019
aS'      coupling[density_lower_slack_multiplier<dim>]'
p47020
aS'              [density_upper_slack_multiplier<dim>] = DoFTools::always;'
p47021
aS'      coupling[density_upper_slack_multiplier<dim>]'
p47022
aS'              [density_lower_slack_multiplier<dim>] = DoFTools::always;'
p47023
aS'    }'
p47024
aS'    const ComponentMask density_mask ='
p47025
aS'      fe.component_mask(ValueExtractors::densities<dim>);'
p47026
aS'    const IndexSet density_dofs ='
p47027
aS'      DoFTools::extract_dofs(dof_handler, density_mask);'
p47028
aS'    types::global_dof_index last_density_dof ='
p47029
aS'      density_dofs.nth_index_in_set(density_dofs.n_elements() - 1);'
p47030
aS'    constraints.clear();'
p47031
aS'    constraints.add_line(last_density_dof);'
p47032
aS'    for (unsigned int i = 0; i < density_dofs.n_elements() - 1; ++i)'
p47033
aS'      constraints.add_entry(last_density_dof,'
p47034
aS'                            density_dofs.nth_index_in_set(i),'
p47035
aS'                            -1);'
p47036
aS'    constraints.set_inhomogeneity(last_density_dof, 0);'
p47037
aS'    constraints.close();'
p47038
aS'    DoFTools::make_sparsity_pattern(dof_handler, coupling, dsp, constraints);'
p47039
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47040
aS'      {'
p47041
aS'        const unsigned int i = cell->active_cell_index();'
p47042
aS'        for (const auto &check_cell : find_relevant_neighbors(cell))'
p47043
aS'          {'
p47044
aS'            const double distance ='
p47045
aS'              cell->center().distance(check_cell->center());'
p47046
aS'            if (distance < filter_r)'
p47047
aS'              {'
p47048
aS'                dsp'
p47049
aS'                  .block(SolutionBlocks::unfiltered_density,'
p47050
aS'                         SolutionBlocks::unfiltered_density_multiplier)'
p47051
aS'                  .add(i, check_cell->active_cell_index());'
p47052
aS'                dsp'
p47053
aS'                  .block(SolutionBlocks::unfiltered_density_multiplier,'
p47054
aS'                         SolutionBlocks::unfiltered_density)'
p47055
aS'                  .add(i, check_cell->active_cell_index());'
p47056
aS'              }'
p47057
aS'          }'
p47058
aS'      }'
p47059
aS'    sparsity_pattern.copy_from(dsp);'
p47060
aS'    std::ofstream out("sparsity.plt");'
p47061
aS'    sparsity_pattern.print_gnuplot(out);'
p47062
aS'    system_matrix.reinit(sparsity_pattern);'
p47063
aS'    nonlinear_solution.reinit(block_sizes);'
p47064
aS'    system_rhs.reinit(block_sizes);'
p47065
aS'    {'
p47066
aS'      using namespace SolutionBlocks;'
p47067
aS'      nonlinear_solution.block(density).add(density_ratio);'
p47068
aS'      nonlinear_solution.block(unfiltered_density).add(density_ratio);'
p47069
aS'      nonlinear_solution.block(unfiltered_density_multiplier)'
p47070
aS'        .add(density_ratio);'
p47071
aS'      nonlinear_solution.block(density_lower_slack).add(density_ratio);'
p47072
aS'      nonlinear_solution.block(density_lower_slack_multiplier).add(50);'
p47073
aS'      nonlinear_solution.block(density_upper_slack).add(1 - density_ratio);'
p47074
aS'      nonlinear_solution.block(density_upper_slack_multiplier).add(50);'
p47075
aS'    }'
p47076
aS'  }'
p47077
aS'  template <int dim>'
p47078
aS'  void SANDTopOpt<dim>::setup_filter_matrix()'
p47079
aS'  {'
p47080
aS'    filter_sparsity_pattern.copy_from('
p47081
aS'      sparsity_pattern.block(SolutionBlocks::unfiltered_density,'
p47082
aS'                             SolutionBlocks::unfiltered_density_multiplier));'
p47083
aS'    filter_matrix.reinit(filter_sparsity_pattern);'
p47084
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47085
aS'      {'
p47086
aS'        const unsigned int i = cell->active_cell_index();'
p47087
aS'        for (const auto &check_cell : find_relevant_neighbors(cell))'
p47088
aS'          {'
p47089
aS'            const double distance ='
p47090
aS'              cell->center().distance(check_cell->center());'
p47091
aS'            if (distance < filter_r)'
p47092
aS'              {'
p47093
aS'                filter_matrix.add(i,'
p47094
aS'                                  check_cell->active_cell_index(),'
p47095
aS'                                  filter_r - distance);'
p47096
aS'              }'
p47097
aS'          }'
p47098
aS'      }'
p47099
aS'    for (unsigned int i = 0; i < filter_matrix.m(); ++i)'
p47100
aS'      {'
p47101
aS'        double denominator = 0;'
p47102
aS'        for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);'
p47103
aS'             iter != filter_matrix.end(i);'
p47104
aS'             iter++)'
p47105
aS'          denominator = denominator + iter->value();'
p47106
aS'        for (SparseMatrix<double>::iterator iter = filter_matrix.begin(i);'
p47107
aS'             iter != filter_matrix.end(i);'
p47108
aS'             iter++)'
p47109
aS'          iter->value() = iter->value() / denominator;'
p47110
aS'      }'
p47111
aS'  }'
p47112
aS'  template <int dim>'
p47113
aS'  std::set<typename Triangulation<dim>::cell_iterator>'
p47114
aS'  SANDTopOpt<dim>::find_relevant_neighbors('
p47115
aS'    typename Triangulation<dim>::cell_iterator cell) const'
p47116
aS'  {'
p47117
aS'    std::set<unsigned int>                               neighbor_ids;'
p47118
aS'    std::set<typename Triangulation<dim>::cell_iterator> cells_to_check;'
p47119
aS'    neighbor_ids.insert(cell->active_cell_index());'
p47120
aS'    cells_to_check.insert(cell);'
p47121
aS'    bool new_neighbors_found;'
p47122
aS'    do'
p47123
aS'      {'
p47124
aS'        new_neighbors_found = false;'
p47125
aS'        for (const auto &check_cell :'
p47126
aS'             std::vector<typename Triangulation<dim>::cell_iterator>('
p47127
aS'               cells_to_check.begin(), cells_to_check.end()))'
p47128
aS'          {'
p47129
aS'            for (const auto n : check_cell->face_indices())'
p47130
aS'              {'
p47131
aS'                if (!(check_cell->face(n)->at_boundary()))'
p47132
aS'                  {'
p47133
aS'                    const auto & neighbor = check_cell->neighbor(n);'
p47134
aS'                    const double distance ='
p47135
aS'                      cell->center().distance(neighbor->center());'
p47136
aS'                    if ((distance < filter_r) &&'
p47137
aS'                        !(neighbor_ids.count(neighbor->active_cell_index())))'
p47138
aS'                      {'
p47139
aS'                        cells_to_check.insert(neighbor);'
p47140
aS'                        neighbor_ids.insert(neighbor->active_cell_index());'
p47141
aS'                        new_neighbors_found = true;'
p47142
aS'                      }'
p47143
aS'                  }'
p47144
aS'              }'
p47145
aS'          }'
p47146
aS'      }'
p47147
aS'    while (new_neighbors_found);'
p47148
aS'    return cells_to_check;'
p47149
aS'  }'
p47150
aS'  template <int dim>'
p47151
aS'  void SANDTopOpt<dim>::assemble_system()'
p47152
aS'  {'
p47153
aS'    TimerOutput::Scope t(timer, "assembly");'
p47154
aS'    system_matrix = 0;'
p47155
aS'    system_rhs    = 0;'
p47156
aS'    MappingQGeneric<dim> mapping(1);'
p47157
aS'    QGauss<dim>          quadrature_formula(fe.degree + 1);'
p47158
aS'    QGauss<dim - 1>      face_quadrature_formula(fe.degree + 1);'
p47159
aS'    FEValues<dim>        fe_values(mapping,'
p47160
aS'                            fe,'
p47161
aS'                            quadrature_formula,'
p47162
aS'                            update_values | update_gradients |'
p47163
aS'                              update_quadrature_points | update_JxW_values);'
p47164
aS'    FEFaceValues<dim>    fe_face_values(mapping,'
p47165
aS'                                     fe,'
p47166
aS'                                     face_quadrature_formula,'
p47167
aS'                                     update_values | update_quadrature_points |'
p47168
aS'                                       update_normal_vectors |'
p47169
aS'                                       update_JxW_values);'
p47170
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p47171
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p47172
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p47173
aS'    Vector<double>     dummy_cell_rhs(dofs_per_cell);'
p47174
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p47175
aS'    std::vector<double>                    lambda_values(n_q_points);'
p47176
aS'    std::vector<double>                    mu_values(n_q_points);'
p47177
aS'    const Functions::ConstantFunction<dim> lambda(1.);'
p47178
aS'    const Functions::ConstantFunction<dim> mu(1.);'
p47179
aS'    std::vector<Tensor<1, dim>>            rhs_values(n_q_points);'
p47180
aS'    BlockVector<double> filtered_unfiltered_density_solution ='
p47181
aS'      nonlinear_solution;'
p47182
aS'    BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution ='
p47183
aS'      nonlinear_solution;'
p47184
aS'    filter_matrix.vmult(filtered_unfiltered_density_solution.block('
p47185
aS'                          SolutionBlocks::unfiltered_density),'
p47186
aS'                        nonlinear_solution.block('
p47187
aS'                          SolutionBlocks::unfiltered_density));'
p47188
aS'    filter_matrix.Tvmult('
p47189
aS'      filter_adjoint_unfiltered_density_multiplier_solution.block('
p47190
aS'        SolutionBlocks::unfiltered_density_multiplier),'
p47191
aS'      nonlinear_solution.block(SolutionBlocks::unfiltered_density_multiplier));'
p47192
aS'    std::vector<double>                  old_density_values(n_q_points);'
p47193
aS'    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);'
p47194
aS'    std::vector<double>                  old_displacement_divs(n_q_points);'
p47195
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);'
p47196
aS'    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);'
p47197
aS'    std::vector<double>         old_displacement_multiplier_divs(n_q_points);'
p47198
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads('
p47199
aS'      n_q_points);'
p47200
aS'    std::vector<double> old_lower_slack_multiplier_values(n_q_points);'
p47201
aS'    std::vector<double> old_upper_slack_multiplier_values(n_q_points);'
p47202
aS'    std::vector<double> old_lower_slack_values(n_q_points);'
p47203
aS'    std::vector<double> old_upper_slack_values(n_q_points);'
p47204
aS'    std::vector<double> old_unfiltered_density_values(n_q_points);'
p47205
aS'    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);'
p47206
aS'    std::vector<double> filtered_unfiltered_density_values(n_q_points);'
p47207
aS'    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values('
p47208
aS'      n_q_points);'
p47209
aS'    using namespace ValueExtractors;'
p47210
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47211
aS'      {'
p47212
aS'        cell_matrix = 0;'
p47213
aS'        cell->get_dof_indices(local_dof_indices);'
p47214
aS'        fe_values.reinit(cell);'
p47215
aS'        lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p47216
aS'        mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p47217
aS'        fe_values[densities<dim>].get_function_values(nonlinear_solution,'
p47218
aS'                                                      old_density_values);'
p47219
aS'        fe_values[displacements<dim>].get_function_values('
p47220
aS'          nonlinear_solution, old_displacement_values);'
p47221
aS'        fe_values[displacements<dim>].get_function_divergences('
p47222
aS'          nonlinear_solution, old_displacement_divs);'
p47223
aS'        fe_values[displacements<dim>].get_function_symmetric_gradients('
p47224
aS'          nonlinear_solution, old_displacement_symmgrads);'
p47225
aS'        fe_values[displacement_multipliers<dim>].get_function_values('
p47226
aS'          nonlinear_solution, old_displacement_multiplier_values);'
p47227
aS'        fe_values[displacement_multipliers<dim>].get_function_divergences('
p47228
aS'          nonlinear_solution, old_displacement_multiplier_divs);'
p47229
aS'        fe_values[displacement_multipliers<dim>]'
p47230
aS'          .get_function_symmetric_gradients('
p47231
aS'            nonlinear_solution, old_displacement_multiplier_symmgrads);'
p47232
aS'        fe_values[density_lower_slacks<dim>].get_function_values('
p47233
aS'          nonlinear_solution, old_lower_slack_values);'
p47234
aS'        fe_values[density_lower_slack_multipliers<dim>].get_function_values('
p47235
aS'          nonlinear_solution, old_lower_slack_multiplier_values);'
p47236
aS'        fe_values[density_upper_slacks<dim>].get_function_values('
p47237
aS'          nonlinear_solution, old_upper_slack_values);'
p47238
aS'        fe_values[density_upper_slack_multipliers<dim>].get_function_values('
p47239
aS'          nonlinear_solution, old_upper_slack_multiplier_values);'
p47240
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p47241
aS'          nonlinear_solution, old_unfiltered_density_values);'
p47242
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p47243
aS'          nonlinear_solution, old_unfiltered_density_multiplier_values);'
p47244
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p47245
aS'          filtered_unfiltered_density_solution,'
p47246
aS'          filtered_unfiltered_density_values);'
p47247
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p47248
aS'          filter_adjoint_unfiltered_density_multiplier_solution,'
p47249
aS'          filter_adjoint_unfiltered_density_multiplier_values);'
p47250
aS'        for (const auto q_point : fe_values.quadrature_point_indices())'
p47251
aS'          {'
p47252
aS'            for (const auto i : fe_values.dof_indices())'
p47253
aS'              {'
p47254
aS'                const SymmetricTensor<2, dim> displacement_phi_i_symmgrad ='
p47255
aS'                  fe_values[displacements<dim>].symmetric_gradient(i, q_point);'
p47256
aS'                const double displacement_phi_i_div ='
p47257
aS'                  fe_values[displacements<dim>].divergence(i, q_point);'
p47258
aS'                const SymmetricTensor<2, dim>'
p47259
aS'                  displacement_multiplier_phi_i_symmgrad ='
p47260
aS'                    fe_values[displacement_multipliers<dim>].symmetric_gradient('
p47261
aS'                      i, q_point);'
p47262
aS'                const double displacement_multiplier_phi_i_div ='
p47263
aS'                  fe_values[displacement_multipliers<dim>].divergence(i,'
p47264
aS'                                                                      q_point);'
p47265
aS'                const double density_phi_i ='
p47266
aS'                  fe_values[densities<dim>].value(i, q_point);'
p47267
aS'                const double unfiltered_density_phi_i ='
p47268
aS'                  fe_values[unfiltered_densities<dim>].value(i, q_point);'
p47269
aS'                const double unfiltered_density_multiplier_phi_i ='
p47270
aS'                  fe_values[unfiltered_density_multipliers<dim>].value(i,'
p47271
aS'                                                                       q_point);'
p47272
aS'                const double lower_slack_multiplier_phi_i ='
p47273
aS'                  fe_values[density_lower_slack_multipliers<dim>].value('
p47274
aS'                    i, q_point);'
p47275
aS'                const double lower_slack_phi_i ='
p47276
aS'                  fe_values[density_lower_slacks<dim>].value(i, q_point);'
p47277
aS'                const double upper_slack_phi_i ='
p47278
aS'                  fe_values[density_upper_slacks<dim>].value(i, q_point);'
p47279
aS'                const double upper_slack_multiplier_phi_i ='
p47280
aS'                  fe_values[density_upper_slack_multipliers<dim>].value('
p47281
aS'                    i, q_point);'
p47282
aS'                for (const auto j : fe_values.dof_indices())'
p47283
aS'                  {'
p47284
aS'                    const SymmetricTensor<2, dim> displacement_phi_j_symmgrad ='
p47285
aS'                      fe_values[displacements<dim>].symmetric_gradient(j,'
p47286
aS'                                                                       q_point);'
p47287
aS'                    const double displacement_phi_j_div ='
p47288
aS'                      fe_values[displacements<dim>].divergence(j, q_point);'
p47289
aS'                    const SymmetricTensor<2, dim>'
p47290
aS'                      displacement_multiplier_phi_j_symmgrad ='
p47291
aS'                        fe_values[displacement_multipliers<dim>]'
p47292
aS'                          .symmetric_gradient(j, q_point);'
p47293
aS'                    const double displacement_multiplier_phi_j_div ='
p47294
aS'                      fe_values[displacement_multipliers<dim>].divergence('
p47295
aS'                        j, q_point);'
p47296
aS'                    const double density_phi_j ='
p47297
aS'                      fe_values[densities<dim>].value(j, q_point);'
p47298
aS'                    const double unfiltered_density_phi_j ='
p47299
aS'                      fe_values[unfiltered_densities<dim>].value(j, q_point);'
p47300
aS'                    const double unfiltered_density_multiplier_phi_j ='
p47301
aS'                      fe_values[unfiltered_density_multipliers<dim>].value('
p47302
aS'                        j, q_point);'
p47303
aS'                    const double lower_slack_phi_j ='
p47304
aS'                      fe_values[density_lower_slacks<dim>].value(j, q_point);'
p47305
aS'                    const double upper_slack_phi_j ='
p47306
aS'                      fe_values[density_upper_slacks<dim>].value(j, q_point);'
p47307
aS'                    const double lower_slack_multiplier_phi_j ='
p47308
aS'                      fe_values[density_lower_slack_multipliers<dim>].value('
p47309
aS'                        j, q_point);'
p47310
aS'                    const double upper_slack_multiplier_phi_j ='
p47311
aS'                      fe_values[density_upper_slack_multipliers<dim>].value('
p47312
aS'                        j, q_point);'
p47313
aS'                    cell_matrix(i, j) +='
p47314
aS'                      fe_values.JxW(q_point) *'
p47315
aS'                        -density_phi_i * unfiltered_density_multiplier_phi_j'
p47316
aS'                        + density_penalty_exponent *'
p47317
aS'                            std::pow(old_density_values[q_point],'
p47318
aS'                                     density_penalty_exponent - 2) *'
p47319
aS'                            density_phi_i * density_phi_j *'
p47320
aS'                               old_displacement_divs[q_point] *'
p47321
aS'                               lambda_values[q_point] +'
p47322
aS'                             2 * mu_values[q_point] *'
p47323
aS'                                old_displacement_multiplier_symmgrads[q_point]))'
p47324
aS'                        + density_penalty_exponent *'
p47325
aS'                            std::pow(old_density_values[q_point],'
p47326
aS'                                     density_penalty_exponent - 1) *'
p47327
aS'                            density_phi_i *'
p47328
aS'                               old_displacement_divs[q_point] *'
p47329
aS'                               lambda_values[q_point] +'
p47330
aS'                             2 * mu_values[q_point] *'
p47331
aS'                                displacement_multiplier_phi_j_symmgrad))'
p47332
aS'                        + density_penalty_exponent *'
p47333
aS'                            std::pow(old_density_values[q_point],'
p47334
aS'                                     density_penalty_exponent - 1) *'
p47335
aS'                            density_phi_i *'
p47336
aS'                               old_displacement_multiplier_divs[q_point] *'
p47337
aS'                               lambda_values[q_point] +'
p47338
aS'                             2 * mu_values[q_point] *'
p47339
aS'                                displacement_phi_j_symmgrad)));'
p47340
aS'                    cell_matrix(i, j) +='
p47341
aS'                      fe_values.JxW(q_point) *'
p47342
aS'                         std::pow(old_density_values[q_point],'
p47343
aS'                                  density_penalty_exponent - 1) *'
p47344
aS'                         density_phi_j *'
p47345
aS'                            displacement_phi_i_div * lambda_values[q_point] +'
p47346
aS'                          2 * mu_values[q_point] *'
p47347
aS'                             displacement_phi_i_symmgrad))'
p47348
aS'                       + std::pow(old_density_values[q_point],'
p47349
aS'                                  density_penalty_exponent) *'
p47350
aS'                              displacement_phi_i_div * lambda_values[q_point] +'
p47351
aS'                            2 * mu_values[q_point] *'
p47352
aS'                               displacement_phi_i_symmgrad))'
p47353
aS'                    cell_matrix(i, j) +='
p47354
aS'                      fe_values.JxW(q_point) *'
p47355
aS'                         lower_slack_multiplier_phi_j +'
p47356
aS'                       unfiltered_density_phi_i * upper_slack_multiplier_phi_j);'
p47357
aS'                    cell_matrix(i, j) +='
p47358
aS'                      fe_values.JxW(q_point) *'
p47359
aS'                        density_penalty_exponent *'
p47360
aS'                          std::pow(old_density_values[q_point],'
p47361
aS'                                   density_penalty_exponent - 1) *'
p47362
aS'                          density_phi_j *'
p47363
aS'                             displacement_multiplier_phi_i_div *'
p47364
aS'                             lambda_values[q_point] +'
p47365
aS'                           2 * mu_values[q_point] *'
p47366
aS'                              displacement_multiplier_phi_i_symmgrad))'
p47367
aS'                        + std::pow(old_density_values[q_point],'
p47368
aS'                                   density_penalty_exponent) *'
p47369
aS'                               displacement_multiplier_phi_i_div *'
p47370
aS'                               lambda_values[q_point] +'
p47371
aS'                             2 * mu_values[q_point] *'
p47372
aS'                                displacement_multiplier_phi_i_symmgrad)));'
p47373
aS'                    cell_matrix(i, j) +='
p47374
aS'                      -1 * fe_values.JxW(q_point) *'
p47375
aS'                      lower_slack_multiplier_phi_i *'
p47376
aS'                    cell_matrix(i, j) +='
p47377
aS'                      -1 * fe_values.JxW(q_point) *'
p47378
aS'                      upper_slack_multiplier_phi_i *'
p47379
aS'                    cell_matrix(i, j) += -1 * fe_values.JxW(q_point) *'
p47380
aS'                                         unfiltered_density_multiplier_phi_i *'
p47381
aS'                    cell_matrix(i, j) +='
p47382
aS'                      fe_values.JxW(q_point) *'
p47383
aS'                       + lower_slack_phi_i * lower_slack_phi_j *'
p47384
aS'                           old_lower_slack_multiplier_values[q_point] /'
p47385
aS'                           old_lower_slack_values[q_point]);'
p47386
aS'                    cell_matrix(i, j) +='
p47387
aS'                      fe_values.JxW(q_point) *'
p47388
aS'                       + upper_slack_phi_i * upper_slack_phi_j *'
p47389
aS'                           old_upper_slack_multiplier_values[q_point] /'
p47390
aS'                           old_upper_slack_values[q_point]);'
p47391
aS'                  }'
p47392
aS'              }'
p47393
aS'          }'
p47394
aS'        MatrixTools::local_apply_boundary_values(boundary_values,'
p47395
aS'                                                 local_dof_indices,'
p47396
aS'                                                 cell_matrix,'
p47397
aS'                                                 dummy_cell_rhs,'
p47398
aS'                                                 true);'
p47399
aS'        constraints.distribute_local_to_global(cell_matrix,'
p47400
aS'                                               local_dof_indices,'
p47401
aS'                                               system_matrix);'
p47402
aS'      }'
p47403
aS'    system_rhs = calculate_test_rhs(nonlinear_solution);'
p47404
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47405
aS'      {'
p47406
aS'        const unsigned int i = cell->active_cell_index();'
p47407
aS'        for (typename SparseMatrix<double>::iterator iter ='
p47408
aS'               filter_matrix.begin(i);'
p47409
aS'             iter != filter_matrix.end(i);'
p47410
aS'             ++iter)'
p47411
aS'          {'
p47412
aS'            const unsigned int j     = iter->column();'
p47413
aS'            const double       value = iter->value() * cell->measure();'
p47414
aS'            system_matrix'
p47415
aS'              .block(SolutionBlocks::unfiltered_density_multiplier,'
p47416
aS'                     SolutionBlocks::unfiltered_density)'
p47417
aS'              .add(i, j, value);'
p47418
aS'            system_matrix'
p47419
aS'              .block(SolutionBlocks::unfiltered_density,'
p47420
aS'                     SolutionBlocks::unfiltered_density_multiplier)'
p47421
aS'              .add(j, i, value);'
p47422
aS'          }'
p47423
aS'      }'
p47424
aS'  }'
p47425
aS'  template <int dim>'
p47426
aS'  BlockVector<double> SANDTopOpt<dim>::solve()'
p47427
aS'  {'
p47428
aS'    TimerOutput::Scope t(timer, "solver");'
p47429
aS'    BlockVector<double> linear_solution;'
p47430
aS'    linear_solution.reinit(nonlinear_solution);'
p47431
aS'    SparseDirectUMFPACK A_direct;'
p47432
aS'    A_direct.initialize(system_matrix);'
p47433
aS'    A_direct.vmult(linear_solution, system_rhs);'
p47434
aS'    constraints.distribute(linear_solution);'
p47435
aS'    return linear_solution;'
p47436
aS'  }'
p47437
aS'  template <int dim>'
p47438
aS'  std::pair<double, double> SANDTopOpt<dim>::calculate_max_step_size('
p47439
aS'    const BlockVector<double> &state,'
p47440
aS'    const BlockVector<double> &step) const'
p47441
aS'  {'
p47442
aS'    double       fraction_to_boundary;'
p47443
aS'    const double min_fraction_to_boundary = .8;'
p47444
aS'    const double max_fraction_to_boundary = 1. - 1e-5;'
p47445
aS'    if (min_fraction_to_boundary < 1 - barrier_size)'
p47446
aS'      {'
p47447
aS'        if (1 - barrier_size < max_fraction_to_boundary)'
p47448
aS'          fraction_to_boundary = 1 - barrier_size;'
p47449
aS'        else'
p47450
aS'          fraction_to_boundary = max_fraction_to_boundary;'
p47451
aS'      }'
p47452
aS'    else'
p47453
aS'      fraction_to_boundary = min_fraction_to_boundary;'
p47454
aS'    double step_size_s_low  = 0;'
p47455
aS'    double step_size_z_low  = 0;'
p47456
aS'    double step_size_s_high = 1;'
p47457
aS'    double step_size_z_high = 1;'
p47458
aS'    double step_size_s, step_size_z;'
p47459
aS'    const int max_bisection_method_steps = 50;'
p47460
aS'    for (unsigned int k = 0; k < max_bisection_method_steps; ++k)'
p47461
aS'      {'
p47462
aS'        step_size_s = (step_size_s_low + step_size_s_high) / 2;'
p47463
aS'        step_size_z = (step_size_z_low + step_size_z_high) / 2;'
p47464
aS'        const BlockVector<double> state_test_s ='
p47465
aS'        const BlockVector<double> state_test_z ='
p47466
aS'        const bool accept_s ='
p47467
aS'             .is_non_negative()) &&'
p47468
aS'             .is_non_negative());'
p47469
aS'        const bool accept_z ='
p47470
aS'             .is_non_negative()) &&'
p47471
aS'             .is_non_negative());'
p47472
aS'        if (accept_s)'
p47473
aS'          step_size_s_low = step_size_s;'
p47474
aS'        else'
p47475
aS'          step_size_s_high = step_size_s;'
p47476
aS'        if (accept_z)'
p47477
aS'          step_size_z_low = step_size_z;'
p47478
aS'        else'
p47479
aS'          step_size_z_high = step_size_z;'
p47480
aS'      }'
p47481
aS'    return {step_size_s_low, step_size_z_low};'
p47482
aS'  }'
p47483
aS'  template <int dim>'
p47484
aS'  BlockVector<double> SANDTopOpt<dim>::calculate_test_rhs('
p47485
aS'    const BlockVector<double> &test_solution) const'
p47486
aS'  {'
p47487
aS'    BlockVector<double> test_rhs;'
p47488
aS'    test_rhs.reinit(system_rhs);'
p47489
aS'    MappingQGeneric<dim>  mapping(1);'
p47490
aS'    const QGauss<dim>     quadrature_formula(fe.degree + 1);'
p47491
aS'    const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p47492
aS'    FEValues<dim>         fe_values(mapping,'
p47493
aS'                            fe,'
p47494
aS'                            quadrature_formula,'
p47495
aS'                            update_values | update_gradients |'
p47496
aS'                              update_quadrature_points | update_JxW_values);'
p47497
aS'    FEFaceValues<dim>     fe_face_values(mapping,'
p47498
aS'                                     fe,'
p47499
aS'                                     face_quadrature_formula,'
p47500
aS'                                     update_values | update_quadrature_points |'
p47501
aS'                                       update_normal_vectors |'
p47502
aS'                                       update_JxW_values);'
p47503
aS'    const unsigned int dofs_per_cell = fe.dofs_per_cell;'
p47504
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p47505
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p47506
aS'    FullMatrix<double> dummy_cell_matrix(dofs_per_cell, dofs_per_cell);'
p47507
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p47508
aS'    std::vector<double> lambda_values(n_q_points);'
p47509
aS'    std::vector<double> mu_values(n_q_points);'
p47510
aS'    const Functions::ConstantFunction<dim> lambda(1.), mu(1.);'
p47511
aS'    std::vector<Tensor<1, dim>>            rhs_values(n_q_points);'
p47512
aS'    BlockVector<double> filtered_unfiltered_density_solution = test_solution;'
p47513
aS'    BlockVector<double> filter_adjoint_unfiltered_density_multiplier_solution ='
p47514
aS'      test_solution;'
p47515
aS'    filtered_unfiltered_density_solution.block('
p47516
aS'      SolutionBlocks::unfiltered_density) = 0;'
p47517
aS'    filter_adjoint_unfiltered_density_multiplier_solution.block('
p47518
aS'      SolutionBlocks::unfiltered_density_multiplier) = 0;'
p47519
aS'    filter_matrix.vmult(filtered_unfiltered_density_solution.block('
p47520
aS'                          SolutionBlocks::unfiltered_density),'
p47521
aS'                        test_solution.block('
p47522
aS'                          SolutionBlocks::unfiltered_density));'
p47523
aS'    filter_matrix.Tvmult('
p47524
aS'      filter_adjoint_unfiltered_density_multiplier_solution.block('
p47525
aS'        SolutionBlocks::unfiltered_density_multiplier),'
p47526
aS'      test_solution.block(SolutionBlocks::unfiltered_density_multiplier));'
p47527
aS'    std::vector<double>                  old_density_values(n_q_points);'
p47528
aS'    std::vector<Tensor<1, dim>>          old_displacement_values(n_q_points);'
p47529
aS'    std::vector<double>                  old_displacement_divs(n_q_points);'
p47530
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_symmgrads(n_q_points);'
p47531
aS'    std::vector<Tensor<1, dim>> old_displacement_multiplier_values(n_q_points);'
p47532
aS'    std::vector<double>         old_displacement_multiplier_divs(n_q_points);'
p47533
aS'    std::vector<SymmetricTensor<2, dim>> old_displacement_multiplier_symmgrads('
p47534
aS'      n_q_points);'
p47535
aS'    std::vector<double> old_lower_slack_multiplier_values(n_q_points);'
p47536
aS'    std::vector<double> old_upper_slack_multiplier_values(n_q_points);'
p47537
aS'    std::vector<double> old_lower_slack_values(n_q_points);'
p47538
aS'    std::vector<double> old_upper_slack_values(n_q_points);'
p47539
aS'    std::vector<double> old_unfiltered_density_values(n_q_points);'
p47540
aS'    std::vector<double> old_unfiltered_density_multiplier_values(n_q_points);'
p47541
aS'    std::vector<double> filtered_unfiltered_density_values(n_q_points);'
p47542
aS'    std::vector<double> filter_adjoint_unfiltered_density_multiplier_values('
p47543
aS'      n_q_points);'
p47544
aS'    using namespace ValueExtractors;'
p47545
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47546
aS'      {'
p47547
aS'        cell_rhs = 0;'
p47548
aS'        cell->get_dof_indices(local_dof_indices);'
p47549
aS'        fe_values.reinit(cell);'
p47550
aS'        lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p47551
aS'        mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p47552
aS'        fe_values[densities<dim>].get_function_values(test_solution,'
p47553
aS'                                                      old_density_values);'
p47554
aS'        fe_values[displacements<dim>].get_function_values('
p47555
aS'          test_solution, old_displacement_values);'
p47556
aS'        fe_values[displacements<dim>].get_function_divergences('
p47557
aS'          test_solution, old_displacement_divs);'
p47558
aS'        fe_values[displacements<dim>].get_function_symmetric_gradients('
p47559
aS'          test_solution, old_displacement_symmgrads);'
p47560
aS'        fe_values[displacement_multipliers<dim>].get_function_values('
p47561
aS'          test_solution, old_displacement_multiplier_values);'
p47562
aS'        fe_values[displacement_multipliers<dim>].get_function_divergences('
p47563
aS'          test_solution, old_displacement_multiplier_divs);'
p47564
aS'        fe_values[displacement_multipliers<dim>]'
p47565
aS'          .get_function_symmetric_gradients('
p47566
aS'            test_solution, old_displacement_multiplier_symmgrads);'
p47567
aS'        fe_values[density_lower_slacks<dim>].get_function_values('
p47568
aS'          test_solution, old_lower_slack_values);'
p47569
aS'        fe_values[density_lower_slack_multipliers<dim>].get_function_values('
p47570
aS'          test_solution, old_lower_slack_multiplier_values);'
p47571
aS'        fe_values[density_upper_slacks<dim>].get_function_values('
p47572
aS'          test_solution, old_upper_slack_values);'
p47573
aS'        fe_values[density_upper_slack_multipliers<dim>].get_function_values('
p47574
aS'          test_solution, old_upper_slack_multiplier_values);'
p47575
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p47576
aS'          test_solution, old_unfiltered_density_values);'
p47577
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p47578
aS'          test_solution, old_unfiltered_density_multiplier_values);'
p47579
aS'        fe_values[unfiltered_densities<dim>].get_function_values('
p47580
aS'          filtered_unfiltered_density_solution,'
p47581
aS'          filtered_unfiltered_density_values);'
p47582
aS'        fe_values[unfiltered_density_multipliers<dim>].get_function_values('
p47583
aS'          filter_adjoint_unfiltered_density_multiplier_solution,'
p47584
aS'          filter_adjoint_unfiltered_density_multiplier_values);'
p47585
aS'        for (const auto q_point : fe_values.quadrature_point_indices())'
p47586
aS'          {'
p47587
aS'            for (const auto i : fe_values.dof_indices())'
p47588
aS'              {'
p47589
aS'                const SymmetricTensor<2, dim> displacement_phi_i_symmgrad ='
p47590
aS'                  fe_values[displacements<dim>].symmetric_gradient(i, q_point);'
p47591
aS'                const double displacement_phi_i_div ='
p47592
aS'                  fe_values[displacements<dim>].divergence(i, q_point);'
p47593
aS'                const SymmetricTensor<2, dim>'
p47594
aS'                  displacement_multiplier_phi_i_symmgrad ='
p47595
aS'                    fe_values[displacement_multipliers<dim>].symmetric_gradient('
p47596
aS'                      i, q_point);'
p47597
aS'                const double displacement_multiplier_phi_i_div ='
p47598
aS'                  fe_values[displacement_multipliers<dim>].divergence(i,'
p47599
aS'                                                                      q_point);'
p47600
aS'                const double density_phi_i ='
p47601
aS'                  fe_values[densities<dim>].value(i, q_point);'
p47602
aS'                const double unfiltered_density_phi_i ='
p47603
aS'                  fe_values[unfiltered_densities<dim>].value(i, q_point);'
p47604
aS'                const double unfiltered_density_multiplier_phi_i ='
p47605
aS'                  fe_values[unfiltered_density_multipliers<dim>].value(i,'
p47606
aS'                                                                       q_point);'
p47607
aS'                const double lower_slack_multiplier_phi_i ='
p47608
aS'                  fe_values[density_lower_slack_multipliers<dim>].value('
p47609
aS'                    i, q_point);'
p47610
aS'                const double lower_slack_phi_i ='
p47611
aS'                  fe_values[density_lower_slacks<dim>].value(i, q_point);'
p47612
aS'                const double upper_slack_phi_i ='
p47613
aS'                  fe_values[density_upper_slacks<dim>].value(i, q_point);'
p47614
aS'                const double upper_slack_multiplier_phi_i ='
p47615
aS'                  fe_values[density_upper_slack_multipliers<dim>].value('
p47616
aS'                    i, q_point);'
p47617
aS'                cell_rhs(i) +='
p47618
aS'                  -1 * fe_values.JxW(q_point) *'
p47619
aS'                     std::pow(old_density_values[q_point],'
p47620
aS'                              density_penalty_exponent - 1) *'
p47621
aS'                     density_phi_i *'
p47622
aS'                        old_displacement_divs[q_point] *'
p47623
aS'                        lambda_values[q_point] +'
p47624
aS'                      2 * mu_values[q_point] *'
p47625
aS'                         old_displacement_multiplier_symmgrads[q_point])) -'
p47626
aS'                   density_phi_i *'
p47627
aS'                     old_unfiltered_density_multiplier_values[q_point]);'
p47628
aS'                cell_rhs(i) +='
p47629
aS'                  -1 * fe_values.JxW(q_point) *'
p47630
aS'                            density_penalty_exponent) *'
p47631
aS'                      displacement_phi_i_div * lambda_values[q_point] +'
p47632
aS'                    2 * mu_values[q_point] *'
p47633
aS'                       displacement_phi_i_symmgrad)));'
p47634
aS'                cell_rhs(i) +='
p47635
aS'                  -1 * fe_values.JxW(q_point) *'
p47636
aS'                     filter_adjoint_unfiltered_density_multiplier_values'
p47637
aS'                       [q_point] +'
p47638
aS'                   unfiltered_density_phi_i *'
p47639
aS'                     old_upper_slack_multiplier_values[q_point] +'
p47640
aS'                   -1 * unfiltered_density_phi_i *'
p47641
aS'                     old_lower_slack_multiplier_values[q_point]);'
p47642
aS'                cell_rhs(i) += -1 * fe_values.JxW(q_point) *'
p47643
aS'                                         density_penalty_exponent) *'
p47644
aS'                                   displacement_multiplier_phi_i_div *'
p47645
aS'                                   lambda_values[q_point] +'
p47646
aS'                                 2 * mu_values[q_point] *'
p47647
aS'                                    old_displacement_symmgrads[q_point])));'
p47648
aS'                cell_rhs(i) += fe_values.JxW(q_point) *'
p47649
aS'                                 old_lower_slack_values[q_point]));'
p47650
aS'                cell_rhs(i) += fe_values.JxW(q_point) *'
p47651
aS'                                 old_upper_slack_values[q_point]));'
p47652
aS'                cell_rhs(i) += fe_values.JxW(q_point) *'
p47653
aS'                                 filtered_unfiltered_density_values[q_point]));'
p47654
aS'                cell_rhs(i) +='
p47655
aS'                  -1 * fe_values.JxW(q_point) *'
p47656
aS'                    barrier_size / old_lower_slack_values[q_point]));'
p47657
aS'                cell_rhs(i) +='
p47658
aS'                  -1 * fe_values.JxW(q_point) *'
p47659
aS'                    barrier_size / old_upper_slack_values[q_point]));'
p47660
aS'              }'
p47661
aS'          }'
p47662
aS'        for (const auto &face : cell->face_iterators())'
p47663
aS'          {'
p47664
aS'            if (face->at_boundary() &&'
p47665
aS'                face->boundary_id() == BoundaryIds::down_force)'
p47666
aS'              {'
p47667
aS'                fe_face_values.reinit(cell, face);'
p47668
aS'                for (const auto face_q_point :'
p47669
aS'                     fe_face_values.quadrature_point_indices())'
p47670
aS'                  {'
p47671
aS'                    for (const auto i : fe_face_values.dof_indices())'
p47672
aS'                      {'
p47673
aS'                        Tensor<1, dim> traction;'
p47674
aS'                        traction[1] = -1.;'
p47675
aS'                        cell_rhs(i) +='
p47676
aS'                          -1 *'
p47677
aS'                                        i, face_q_point)) *'
p47678
aS'                          fe_face_values.JxW(face_q_point);'
p47679
aS'                        cell_rhs(i) +='
p47680
aS'                           fe_face_values[displacement_multipliers<dim>].value('
p47681
aS'                             i, face_q_point)) *'
p47682
aS'                          fe_face_values.JxW(face_q_point);'
p47683
aS'                      }'
p47684
aS'                  }'
p47685
aS'              }'
p47686
aS'          }'
p47687
aS'        MatrixTools::local_apply_boundary_values(boundary_values,'
p47688
aS'                                                 local_dof_indices,'
p47689
aS'                                                 dummy_cell_matrix,'
p47690
aS'                                                 cell_rhs,'
p47691
aS'                                                 true);'
p47692
aS'        constraints.distribute_local_to_global(cell_rhs,'
p47693
aS'                                               local_dof_indices,'
p47694
aS'                                               test_rhs);'
p47695
aS'      }'
p47696
aS'    return test_rhs;'
p47697
aS'  }'
p47698
aS'  template <int dim>'
p47699
aS'  double SANDTopOpt<dim>::calculate_exact_merit('
p47700
aS'    const BlockVector<double> &test_solution)'
p47701
aS'  {'
p47702
aS'    TimerOutput::Scope t(timer, "merit function");'
p47703
aS'    double objective_function_merit = 0;'
p47704
aS'    {'
p47705
aS'      MappingQGeneric<dim>  mapping(1);'
p47706
aS'      const QGauss<dim>     quadrature_formula(fe.degree + 1);'
p47707
aS'      const QGauss<dim - 1> face_quadrature_formula(fe.degree + 1);'
p47708
aS'      FEValues<dim>         fe_values(mapping,'
p47709
aS'                              fe,'
p47710
aS'                              quadrature_formula,'
p47711
aS'                              update_values | update_gradients |'
p47712
aS'                                update_quadrature_points | update_JxW_values);'
p47713
aS'      FEFaceValues<dim>     fe_face_values(mapping,'
p47714
aS'                                       fe,'
p47715
aS'                                       face_quadrature_formula,'
p47716
aS'                                       update_values |'
p47717
aS'                                         update_quadrature_points |'
p47718
aS'                                         update_normal_vectors |'
p47719
aS'                                         update_JxW_values);'
p47720
aS'      const unsigned int n_face_q_points = face_quadrature_formula.size();'
p47721
aS'      std::vector<Tensor<1, dim>> displacement_face_values(n_face_q_points);'
p47722
aS'      for (const auto &cell : dof_handler.active_cell_iterators())'
p47723
aS'        {'
p47724
aS'          for (const auto &face : cell->face_iterators())'
p47725
aS'            {'
p47726
aS'              if (face->at_boundary() &&'
p47727
aS'                  face->boundary_id() == BoundaryIds::down_force)'
p47728
aS'                {'
p47729
aS'                  fe_face_values.reinit(cell, face);'
p47730
aS'                  fe_face_values[ValueExtractors::displacements<dim>]'
p47731
aS'                    .get_function_values(test_solution,'
p47732
aS'                                         displacement_face_values);'
p47733
aS'                  for (unsigned int face_q_point = 0;'
p47734
aS'                       face_q_point < n_face_q_points;'
p47735
aS'                       ++face_q_point)'
p47736
aS'                    {'
p47737
aS'                      Tensor<1, dim> traction;'
p47738
aS'                      traction[1] = -1.;'
p47739
aS'                      objective_function_merit +='
p47740
aS'                        fe_face_values.JxW(face_q_point);'
p47741
aS'                    }'
p47742
aS'                }'
p47743
aS'            }'
p47744
aS'        }'
p47745
aS'    }'
p47746
aS'    for (const auto &cell : triangulation.active_cell_iterators())'
p47747
aS'      {'
p47748
aS'        objective_function_merit ='
p47749
aS'          objective_function_merit -'
p47750
aS'          barrier_size * cell->measure() *'
p47751
aS'            std::log(test_solution.block('
p47752
aS'              SolutionBlocks::density_lower_slack)[cell->active_cell_index()]);'
p47753
aS'        objective_function_merit ='
p47754
aS'          objective_function_merit -'
p47755
aS'          barrier_size * cell->measure() *'
p47756
aS'            std::log(test_solution.block('
p47757
aS'              SolutionBlocks::density_upper_slack)[cell->active_cell_index()]);'
p47758
aS'      }'
p47759
aS'    const BlockVector<double> test_rhs = calculate_test_rhs(test_solution);'
p47760
aS'    const double elasticity_constraint_merit ='
p47761
aS'      penalty_multiplier *'
p47762
aS'      test_rhs.block(SolutionBlocks::displacement_multiplier).l1_norm();'
p47763
aS'    const double filter_constraint_merit ='
p47764
aS'      penalty_multiplier *'
p47765
aS'      test_rhs.block(SolutionBlocks::unfiltered_density_multiplier).l1_norm();'
p47766
aS'    const double lower_slack_merit ='
p47767
aS'      penalty_multiplier *'
p47768
aS'      test_rhs.block(SolutionBlocks::density_lower_slack_multiplier).l1_norm();'
p47769
aS'    const double upper_slack_merit ='
p47770
aS'      penalty_multiplier *'
p47771
aS'      test_rhs.block(SolutionBlocks::density_upper_slack_multiplier).l1_norm();'
p47772
aS'    const double total_merit ='
p47773
aS'      objective_function_merit + elasticity_constraint_merit +'
p47774
aS'      filter_constraint_merit + lower_slack_merit + upper_slack_merit;'
p47775
aS'    return total_merit;'
p47776
aS'  }'
p47777
aS'  template <int dim>'
p47778
aS'  BlockVector<double> SANDTopOpt<dim>::find_max_step()'
p47779
aS'  {'
p47780
aS'    assemble_system();'
p47781
aS'    BlockVector<double> step = solve();'
p47782
aS'    const std::vector<unsigned int> decision_variables = {'
p47783
aS'      SolutionBlocks::density,'
p47784
aS'      SolutionBlocks::displacement,'
p47785
aS'      SolutionBlocks::unfiltered_density,'
p47786
aS'      SolutionBlocks::density_upper_slack,'
p47787
aS'      SolutionBlocks::density_lower_slack};'
p47788
aS'    double hess_part = 0;'
p47789
aS'    double grad_part = 0;'
p47790
aS'    for (const unsigned int decision_variable_i : decision_variables)'
p47791
aS'      {'
p47792
aS'        for (const unsigned int decision_variable_j : decision_variables)'
p47793
aS'          {'
p47794
aS'            Vector<double> temp_vector(step.block(decision_variable_i).size());'
p47795
aS'            system_matrix.block(decision_variable_i, decision_variable_j)'
p47796
aS'              .vmult(temp_vector, step.block(decision_variable_j));'
p47797
aS'            hess_part += step.block(decision_variable_i) * temp_vector;'
p47798
aS'          }'
p47799
aS'        grad_part -= system_rhs.block(decision_variable_i) *'
p47800
aS'                     step.block(decision_variable_i);'
p47801
aS'      }'
p47802
aS'    const std::vector<unsigned int> equality_constraint_multipliers = {'
p47803
aS'      SolutionBlocks::displacement_multiplier,'
p47804
aS'      SolutionBlocks::unfiltered_density_multiplier,'
p47805
aS'      SolutionBlocks::density_lower_slack_multiplier,'
p47806
aS'      SolutionBlocks::density_upper_slack_multiplier};'
p47807
aS'    double constraint_norm = 0;'
p47808
aS'    for (unsigned int multiplier_i : equality_constraint_multipliers)'
p47809
aS'      constraint_norm += system_rhs.block(multiplier_i).linfty_norm();'
p47810
aS'    double test_penalty_multiplier;'
p47811
aS'    if (hess_part > 0)'
p47812
aS'      test_penalty_multiplier ='
p47813
aS'    else'
p47814
aS'      test_penalty_multiplier = (grad_part) / (.05 * constraint_norm);'
p47815
aS'    penalty_multiplier = std::max(penalty_multiplier, test_penalty_multiplier);'
p47816
aS'    const std::pair<double, double> max_step_sizes ='
p47817
aS'      calculate_max_step_size(nonlinear_solution, step);'
p47818
aS'    const double step_size_s = max_step_sizes.first;'
p47819
aS'    const double step_size_z = max_step_sizes.second;'
p47820
aS'    step.block(SolutionBlocks::density) *= step_size_s;'
p47821
aS'    step.block(SolutionBlocks::displacement) *= step_size_s;'
p47822
aS'    step.block(SolutionBlocks::unfiltered_density) *= step_size_s;'
p47823
aS'    step.block(SolutionBlocks::displacement_multiplier) *= step_size_z;'
p47824
aS'    step.block(SolutionBlocks::unfiltered_density_multiplier) *= step_size_z;'
p47825
aS'    step.block(SolutionBlocks::density_lower_slack) *= step_size_s;'
p47826
aS'    step.block(SolutionBlocks::density_lower_slack_multiplier) *= step_size_z;'
p47827
aS'    step.block(SolutionBlocks::density_upper_slack) *= step_size_s;'
p47828
aS'    step.block(SolutionBlocks::density_upper_slack_multiplier) *= step_size_z;'
p47829
aS'    return step;'
p47830
aS'  }'
p47831
aS'  template <int dim>'
p47832
aS'  BlockVector<double>'
p47833
aS'  SANDTopOpt<dim>::compute_scaled_step(const BlockVector<double> &state,'
p47834
aS'                                       const BlockVector<double> &max_step,'
p47835
aS'                                       const double descent_requirement)'
p47836
aS'  {'
p47837
aS'    const double merit_derivative ='
p47838
aS'       calculate_exact_merit(state)) /'
p47839
aS'      1e-4;'
p47840
aS'    double       step_size                 = 1;'
p47841
aS'    unsigned int max_linesearch_iterations = 10;'
p47842
aS'    for (unsigned int k = 0; k < max_linesearch_iterations; ++k)'
p47843
aS'      {'
p47844
aS'        if (calculate_exact_merit(state + step_size * max_step) <'
p47845
aS'            calculate_exact_merit(state) +'
p47846
aS'              step_size * descent_requirement * merit_derivative)'
p47847
aS'          break;'
p47848
aS'        else'
p47849
aS'          step_size = step_size / 2;'
p47850
aS'      }'
p47851
aS'    return state + (step_size * max_step);'
p47852
aS'  }'
p47853
aS'  template <int dim>'
p47854
aS'  bool SANDTopOpt<dim>::check_convergence(const BlockVector<double> &state)'
p47855
aS'  {'
p47856
aS'    const BlockVector<double> test_rhs      = calculate_test_rhs(state);'
p47857
aS'    const double              test_rhs_norm = test_rhs.l1_norm();'
p47858
aS'    const double convergence_condition = 1e-2;'
p47859
aS'    const double target_norm           = convergence_condition * barrier_size;'
p47860
aS'    std::cout << "    Checking convergence. Current rhs norm is "'
p47861
aS'              << test_rhs_norm << ", target is " << target_norm << std::endl;'
p47862
aS'    return (test_rhs_norm < target_norm);'
p47863
aS'  }'
p47864
aS'  template <int dim>'
p47865
aS'  void SANDTopOpt<dim>::output_results(const unsigned int iteration) const'
p47866
aS'  {'
p47867
aS'    std::vector<std::string> solution_names(1, "density");'
p47868
aS'    std::vector<DataComponentInterpretation::DataComponentInterpretation>'
p47869
aS'      data_component_interpretation('
p47870
aS'        1, DataComponentInterpretation::component_is_scalar);'
p47871
aS'    for (unsigned int i = 0; i < dim; ++i)'
p47872
aS'      {'
p47873
aS'        solution_names.emplace_back("displacement");'
p47874
aS'        data_component_interpretation.push_back('
p47875
aS'          DataComponentInterpretation::component_is_part_of_vector);'
p47876
aS'      }'
p47877
aS'    solution_names.emplace_back("unfiltered_density");'
p47878
aS'    data_component_interpretation.push_back('
p47879
aS'      DataComponentInterpretation::component_is_scalar);'
p47880
aS'    for (unsigned int i = 0; i < dim; ++i)'
p47881
aS'      {'
p47882
aS'        solution_names.emplace_back("displacement_multiplier");'
p47883
aS'        data_component_interpretation.push_back('
p47884
aS'          DataComponentInterpretation::component_is_part_of_vector);'
p47885
aS'      }'
p47886
aS'    solution_names.emplace_back("unfiltered_density_multiplier");'
p47887
aS'    data_component_interpretation.push_back('
p47888
aS'      DataComponentInterpretation::component_is_scalar);'
p47889
aS'    solution_names.emplace_back("low_slack");'
p47890
aS'    data_component_interpretation.push_back('
p47891
aS'      DataComponentInterpretation::component_is_scalar);'
p47892
aS'    solution_names.emplace_back("low_slack_multiplier");'
p47893
aS'    data_component_interpretation.push_back('
p47894
aS'      DataComponentInterpretation::component_is_scalar);'
p47895
aS'    solution_names.emplace_back("high_slack");'
p47896
aS'    data_component_interpretation.push_back('
p47897
aS'      DataComponentInterpretation::component_is_scalar);'
p47898
aS'    solution_names.emplace_back("high_slack_multiplier");'
p47899
aS'    data_component_interpretation.push_back('
p47900
aS'      DataComponentInterpretation::component_is_scalar);'
p47901
aS'    DataOut<dim> data_out;'
p47902
aS'    data_out.attach_dof_handler(dof_handler);'
p47903
aS'    data_out.add_data_vector(nonlinear_solution,'
p47904
aS'                             solution_names,'
p47905
aS'                             DataOut<dim>::type_dof_data,'
p47906
aS'                             data_component_interpretation);'
p47907
aS'    data_out.build_patches();'
p47908
aS'    std::ofstream output("solution" + std::to_string(iteration) + ".vtu");'
p47909
aS'    data_out.write_vtu(output);'
p47910
aS'  }'
p47911
aS'  template <int dim>'
p47912
aS'  void SANDTopOpt<dim>::write_as_stl()'
p47913
aS'  {'
p47914
aS'    static_assert(dim == 2,'
p47915
aS'                  "This function is not implemented for anything "'
p47916
aS'                  "other than the 2d case.");'
p47917
aS'    std::ofstream stlfile;'
p47918
aS'    stlfile.open("bridge.stl");'
p47919
aS'    stlfile << "solid bridge\\n" << std::scientific;'
p47920
aS'    double height = .25;'
p47921
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p47922
aS'      {'
p47923
aS'        if (nonlinear_solution.block('
p47924
aS'              SolutionBlocks::density)[cell->active_cell_index()] > 0.5)'
p47925
aS'          {'
p47926
aS'            const Tensor<1, dim> edge_directions[2] = {cell->vertex(1) -'
p47927
aS'                                                         cell->vertex(0),'
p47928
aS'                                                       cell->vertex(2) -'
p47929
aS'                                                         cell->vertex(0)};'
p47930
aS'            const Tensor<2, dim> edge_tensor('
p47931
aS'              {{edge_directions[0][0], edge_directions[0][1]},'
p47932
aS'               {edge_directions[1][0], edge_directions[1][1]}});'
p47933
aS'            const bool is_right_handed_cell = (determinant(edge_tensor) > 0);'
p47934
aS'            if (is_right_handed_cell)'
p47935
aS'              {'
p47936
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p47937
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p47938
aS'                stlfile << "      outer loop\\n";'
p47939
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p47940
aS'                        << cell->vertex(0)[1] << " " << 0.000000e+00 << "\\n";'
p47941
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p47942
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p47943
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p47944
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p47945
aS'                stlfile << "      endloop\\n";'
p47946
aS'                stlfile << "   endfacet\\n";'
p47947
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p47948
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p47949
aS'                stlfile << "      outer loop\\n";'
p47950
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p47951
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p47952
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p47953
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p47954
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p47955
aS'                        << cell->vertex(3)[1] << " " << 0.000000e+00 << "\\n";'
p47956
aS'                stlfile << "      endloop\\n";'
p47957
aS'                stlfile << "   endfacet\\n";'
p47958
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p47959
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p47960
aS'                stlfile << "      outer loop\\n";'
p47961
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p47962
aS'                        << cell->vertex(0)[1] << " " << height << "\\n";'
p47963
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p47964
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p47965
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p47966
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p47967
aS'                stlfile << "      endloop\\n";'
p47968
aS'                stlfile << "   endfacet\\n";'
p47969
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p47970
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p47971
aS'                stlfile << "      outer loop\\n";'
p47972
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p47973
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p47974
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p47975
aS'                        << cell->vertex(3)[1] << " " << height << "\\n";'
p47976
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p47977
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p47978
aS'                stlfile << "      endloop\\n";'
p47979
aS'                stlfile << "   endfacet\\n";'
p47980
aS'              }'
p47981
aS'            else /* The cell has a left-handed set up */'
p47982
aS'              {'
p47983
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p47984
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p47985
aS'                stlfile << "      outer loop\\n";'
p47986
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p47987
aS'                        << cell->vertex(0)[1] << " " << 0.000000e+00 << "\\n";'
p47988
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p47989
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p47990
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p47991
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p47992
aS'                stlfile << "      endloop\\n";'
p47993
aS'                stlfile << "   endfacet\\n";'
p47994
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p47995
aS'                        << 0.000000e+00 << " " << -1.000000e+00 << "\\n";'
p47996
aS'                stlfile << "      outer loop\\n";'
p47997
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p47998
aS'                        << cell->vertex(1)[1] << " " << 0.000000e+00 << "\\n";'
p47999
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p48000
aS'                        << cell->vertex(3)[1] << " " << 0.000000e+00 << "\\n";'
p48001
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p48002
aS'                        << cell->vertex(2)[1] << " " << 0.000000e+00 << "\\n";'
p48003
aS'                stlfile << "      endloop\\n";'
p48004
aS'                stlfile << "   endfacet\\n";'
p48005
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p48006
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p48007
aS'                stlfile << "      outer loop\\n";'
p48008
aS'                stlfile << "         vertex " << cell->vertex(0)[0] << " "'
p48009
aS'                        << cell->vertex(0)[1] << " " << height << "\\n";'
p48010
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p48011
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p48012
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p48013
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p48014
aS'                stlfile << "      endloop\\n";'
p48015
aS'                stlfile << "   endfacet\\n";'
p48016
aS'                stlfile << "   facet normal " << 0.000000e+00 << " "'
p48017
aS'                        << 0.000000e+00 << " " << 1.000000e+00 << "\\n";'
p48018
aS'                stlfile << "      outer loop\\n";'
p48019
aS'                stlfile << "         vertex " << cell->vertex(1)[0] << " "'
p48020
aS'                        << cell->vertex(1)[1] << " " << height << "\\n";'
p48021
aS'                stlfile << "         vertex " << cell->vertex(2)[0] << " "'
p48022
aS'                        << cell->vertex(2)[1] << " " << height << "\\n";'
p48023
aS'                stlfile << "         vertex " << cell->vertex(3)[0] << " "'
p48024
aS'                        << cell->vertex(3)[1] << " " << height << "\\n";'
p48025
aS'                stlfile << "      endloop\\n";'
p48026
aS'                stlfile << "   endfacet\\n";'
p48027
aS'              }'
p48028
aS'            for (unsigned int face_number = 0;'
p48029
aS'                 face_number < GeometryInfo<dim>::faces_per_cell;'
p48030
aS'                 ++face_number)'
p48031
aS'              {'
p48032
aS'                const typename DoFHandler<dim>::face_iterator face ='
p48033
aS'                  cell->face(face_number);'
p48034
aS'                if ((face->at_boundary()) ||'
p48035
aS'                        0)[cell->neighbor(face_number)->active_cell_index()] <'
p48036
aS'                      0.5)))'
p48037
aS'                  {'
p48038
aS'                    const Tensor<1, dim> normal_vector ='
p48039
aS'                    const double normal_norm = normal_vector.norm();'
p48040
aS'                    if ((face->vertex(0)[0] - face->vertex(0)[0]) *'
p48041
aS'                            0.000000e+00 +'
p48042
aS'                            normal_vector[0] +'
p48043
aS'                            normal_vector[1] -'
p48044
aS'                            normal_vector[1] -'
p48045
aS'                            normal_vector[0] -'
p48046
aS'                        0)'
p48047
aS'                      {'
p48048
aS'                        stlfile << "   facet normal "'
p48049
aS'                                << normal_vector[0] / normal_norm << " "'
p48050
aS'                                << normal_vector[1] / normal_norm << " "'
p48051
aS'                                << 0.000000e+00 << "\\n";'
p48052
aS'                        stlfile << "      outer loop\\n";'
p48053
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p48054
aS'                                << " " << face->vertex(0)[1] << " "'
p48055
aS'                                << 0.000000e+00 << "\\n";'
p48056
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p48057
aS'                                << " " << face->vertex(0)[1] << " " << height'
p48058
aS'                                << "\\n";'
p48059
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p48060
aS'                                << " " << face->vertex(1)[1] << " "'
p48061
aS'                                << 0.000000e+00 << "\\n";'
p48062
aS'                        stlfile << "      endloop\\n";'
p48063
aS'                        stlfile << "   endfacet\\n";'
p48064
aS'                        stlfile << "   facet normal "'
p48065
aS'                                << normal_vector[0] / normal_norm << " "'
p48066
aS'                                << normal_vector[1] / normal_norm << " "'
p48067
aS'                                << 0.000000e+00 << "\\n";'
p48068
aS'                        stlfile << "      outer loop\\n";'
p48069
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p48070
aS'                                << " " << face->vertex(0)[1] << " " << height'
p48071
aS'                                << "\\n";'
p48072
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p48073
aS'                                << " " << face->vertex(1)[1] << " " << height'
p48074
aS'                                << "\\n";'
p48075
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p48076
aS'                                << " " << face->vertex(1)[1] << " "'
p48077
aS'                                << 0.000000e+00 << "\\n";'
p48078
aS'                        stlfile << "      endloop\\n";'
p48079
aS'                        stlfile << "   endfacet\\n";'
p48080
aS'                      }'
p48081
aS'                    else'
p48082
aS'                      {'
p48083
aS'                        stlfile << "   facet normal "'
p48084
aS'                                << normal_vector[0] / normal_norm << " "'
p48085
aS'                                << normal_vector[1] / normal_norm << " "'
p48086
aS'                                << 0.000000e+00 << "\\n";'
p48087
aS'                        stlfile << "      outer loop\\n";'
p48088
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p48089
aS'                                << " " << face->vertex(0)[1] << " "'
p48090
aS'                                << 0.000000e+00 << "\\n";'
p48091
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p48092
aS'                                << " " << face->vertex(1)[1] << " "'
p48093
aS'                                << 0.000000e+00 << "\\n";'
p48094
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p48095
aS'                                << " " << face->vertex(0)[1] << " " << height'
p48096
aS'                                << "\\n";'
p48097
aS'                        stlfile << "      endloop\\n";'
p48098
aS'                        stlfile << "   endfacet\\n";'
p48099
aS'                        stlfile << "   facet normal "'
p48100
aS'                                << normal_vector[0] / normal_norm << " "'
p48101
aS'                                << normal_vector[1] / normal_norm << " "'
p48102
aS'                                << 0.000000e+00 << "\\n";'
p48103
aS'                        stlfile << "      outer loop\\n";'
p48104
aS'                        stlfile << "         vertex " << face->vertex(0)[0]'
p48105
aS'                                << " " << face->vertex(0)[1] << " " << height'
p48106
aS'                                << "\\n";'
p48107
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p48108
aS'                                << " " << face->vertex(1)[1] << " "'
p48109
aS'                                << 0.000000e+00 << "\\n";'
p48110
aS'                        stlfile << "         vertex " << face->vertex(1)[0]'
p48111
aS'                                << " " << face->vertex(1)[1] << " " << height'
p48112
aS'                                << "\\n";'
p48113
aS'                        stlfile << "      endloop\\n";'
p48114
aS'                        stlfile << "   endfacet\\n";'
p48115
aS'                      }'
p48116
aS'                  }'
p48117
aS'              }'
p48118
aS'          }'
p48119
aS'      }'
p48120
aS'    stlfile << "endsolid bridge";'
p48121
aS'  }'
p48122
aS'  template <int dim>'
p48123
aS'  void SANDTopOpt<dim>::run()'
p48124
aS'  {'
p48125
aS'    std::cout << "filter r is: " << filter_r << std::endl;'
p48126
aS'    {'
p48127
aS'      TimerOutput::Scope t(timer, "setup");'
p48128
aS'      create_triangulation();'
p48129
aS'      dof_handler.distribute_dofs(fe);'
p48130
aS'      DoFRenumbering::component_wise(dof_handler);'
p48131
aS'      setup_boundary_values();'
p48132
aS'      setup_block_system();'
p48133
aS'      setup_filter_matrix();'
p48134
aS'    }'
p48135
aS'    barrier_size                  = 25;'
p48136
aS'    const double min_barrier_size = .0005;'
p48137
aS'    const unsigned int max_uphill_steps    = 8;'
p48138
aS'    const double       descent_requirement = .0001;'
p48139
aS'    unsigned int       iteration_number = 0;'
p48140
aS'    const unsigned int max_iterations   = 10000;'
p48141
aS'    do'
p48142
aS'      {'
p48143
aS'        std::cout << "Starting outer step in iteration " << iteration_number'
p48144
aS'                  << " with barrier parameter " << barrier_size << std::endl;'
p48145
aS'        do'
p48146
aS'          {'
p48147
aS'            std::cout << "  Starting inner step in iteration "'
p48148
aS'                      << iteration_number'
p48149
aS'                      << " with merit function penalty multiplier "'
p48150
aS'                      << penalty_multiplier << std::endl;'
p48151
aS'            bool watchdog_step_found = false;'
p48152
aS'            const BlockVector<double> watchdog_state = nonlinear_solution;'
p48153
aS'            BlockVector<double>       first_step;'
p48154
aS'            double target_merit     = numbers::signaling_nan<double>();'
p48155
aS'            double merit_derivative = numbers::signaling_nan<double>();'
p48156
aS'            for (unsigned int k = 0; k < max_uphill_steps; ++k)'
p48157
aS'              {'
p48158
aS'                ++iteration_number;'
p48159
aS'                const BlockVector<double> update_step = find_max_step();'
p48160
aS'                if (k == 0)'
p48161
aS'                  {'
p48162
aS'                    first_step = update_step;'
p48163
aS'                    merit_derivative ='
p48164
aS'                                              .0001 * first_step) -'
p48165
aS'                        calculate_exact_merit(watchdog_state)) /'
p48166
aS'                       .0001);'
p48167
aS'                    target_merit = calculate_exact_merit(watchdog_state) +'
p48168
aS'                                   descent_requirement * merit_derivative;'
p48169
aS'                  }'
p48170
aS'                nonlinear_solution += update_step;'
p48171
aS'                const double current_merit ='
p48172
aS'                  calculate_exact_merit(nonlinear_solution);'
p48173
aS'                std::cout << "    current watchdog state merit is: "'
p48174
aS'                          << current_merit << "; target merit is "'
p48175
aS'                          << target_merit << std::endl;'
p48176
aS'                if (current_merit < target_merit)'
p48177
aS'                  {'
p48178
aS'                    watchdog_step_found = true;'
p48179
aS'                    std::cout << "    found workable step after " << k + 1'
p48180
aS'                              << " iterations" << std::endl;'
p48181
aS'                    break;'
p48182
aS'                  }'
p48183
aS'              }'
p48184
aS'            if (watchdog_step_found == false)'
p48185
aS'              {'
p48186
aS'                ++iteration_number;'
p48187
aS'                const BlockVector<double> update_step = find_max_step();'
p48188
aS'                const BlockVector<double> stretch_state ='
p48189
aS'                  compute_scaled_step(nonlinear_solution,'
p48190
aS'                                      update_step,'
p48191
aS'                                      descent_requirement);'
p48192
aS'                if ((calculate_exact_merit(nonlinear_solution) <'
p48193
aS'                     calculate_exact_merit(watchdog_state)) ||'
p48194
aS'                  {'
p48195
aS'                    std::cout << "    Taking scaled step from end of watchdog"'
p48196
aS'                              << std::endl;'
p48197
aS'                    nonlinear_solution = stretch_state;'
p48198
aS'                  }'
p48199
aS'                else'
p48200
aS'                  {'
p48201
aS'                    std::cout'
p48202
aS'                      << "    Taking scaled step from beginning of watchdog"'
p48203
aS'                      << std::endl;'
p48204
aS'                    if (calculate_exact_merit(stretch_state) >'
p48205
aS'                        calculate_exact_merit(watchdog_state))'
p48206
aS'                      {'
p48207
aS'                        nonlinear_solution ='
p48208
aS'                          compute_scaled_step(watchdog_state,'
p48209
aS'                                              first_step,'
p48210
aS'                                              descent_requirement);'
p48211
aS'                      }'
p48212
aS'                    else'
p48213
aS'                      {'
p48214
aS'                        ++iteration_number;'
p48215
aS'                        nonlinear_solution = stretch_state;'
p48216
aS'                        const BlockVector<double> stretch_step ='
p48217
aS'                          find_max_step();'
p48218
aS'                        nonlinear_solution ='
p48219
aS'                          compute_scaled_step(nonlinear_solution,'
p48220
aS'                                              stretch_step,'
p48221
aS'                                              descent_requirement);'
p48222
aS'                      }'
p48223
aS'                  }'
p48224
aS'              }'
p48225
aS'            output_results(iteration_number);'
p48226
aS'          }'
p48227
aS'        while ((iteration_number < max_iterations) &&'
p48228
aS'        const double barrier_size_multiplier = .8;'
p48229
aS'        const double barrier_size_exponent   = 1.2;'
p48230
aS'        barrier_size ='
p48231
aS'          std::max(std::min(barrier_size * barrier_size_multiplier,'
p48232
aS'                            std::pow(barrier_size, barrier_size_exponent)),'
p48233
aS'                   min_barrier_size);'
p48234
aS'        std::cout << std::endl;'
p48235
aS'      }'
p48236
aS'    while (((barrier_size > min_barrier_size) ||'
p48237
aS'    write_as_stl();'
p48238
aS'    timer.print_summary();'
p48239
aS'  }'
p48240
aS'} // namespace SAND'
p48241
aS'int main()'
p48242
ag9
aS'  try'
p48243
aS'    {'
p48244
aS'      SAND::SANDTopOpt<2> elastic_problem_2d;'
p48245
aS'      elastic_problem_2d.run();'
p48246
aS'    }'
p48247
aS'  catch (std::exception &exc)'
p48248
aS'    {'
p48249
aS'      std::cerr << std::endl'
p48250
aS'                << std::endl'
p48251
aS'                << "----------------------------------------------------"'
p48252
aS'                << std::endl;'
p48253
aS'      std::cerr << "Exception on processing: " << std::endl'
p48254
aS'                << exc.what() << std::endl'
p48255
aS'                << "Aborting!" << std::endl'
p48256
aS'                << "----------------------------------------------------"'
p48257
aS'                << std::endl;'
p48258
aS'      return 1;'
p48259
aS'    }'
p48260
aS'  catch (...)'
p48261
aS'    {'
p48262
aS'      std::cerr << std::endl'
p48263
aS'                << std::endl'
p48264
aS'                << "----------------------------------------------------"'
p48265
aS'                << std::endl;'
p48266
aS'      std::cerr << "Unknown exception!" << std::endl'
p48267
aS'                << "Aborting!" << std::endl'
p48268
aS'                << "----------------------------------------------------"'
p48269
aS'                << std::endl;'
p48270
aS'      return 1;'
p48271
aS'    }'
p48272
aS'  return 0;'
p48273
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p48274
aS'#include <deal.II/base/function.h>'
p48275
aS'#include <deal.II/base/tensor.h>'
p48276
aS'#include <deal.II/lac/vector.h>'
p48277
aS'#include <deal.II/lac/full_matrix.h>'
p48278
aS'#include <deal.II/lac/sparse_matrix.h>'
p48279
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p48280
aS'#include <deal.II/lac/solver_cg.h>'
p48281
aS'#include <deal.II/lac/precondition.h>'
p48282
aS'#include <deal.II/lac/affine_constraints.h>'
p48283
aS'#include <deal.II/grid/tria.h>'
p48284
aS'#include <deal.II/grid/grid_generator.h>'
p48285
aS'#include <deal.II/grid/grid_refinement.h>'
p48286
aS'#include <deal.II/dofs/dof_handler.h>'
p48287
aS'#include <deal.II/dofs/dof_tools.h>'
p48288
aS'#include <deal.II/fe/fe_values.h>'
p48289
aS'#include <deal.II/numerics/vector_tools.h>'
p48290
aS'#include <deal.II/numerics/matrix_tools.h>'
p48291
aS'#include <deal.II/numerics/data_out.h>'
p48292
aS'#include <deal.II/numerics/error_estimator.h>'
p48293
aS'#include <deal.II/fe/fe_system.h>'
p48294
aS'#include <deal.II/fe/fe_q.h>'
p48295
aS'#include <fstream>'
p48296
aS'#include <iostream>'
p48297
aS'namespace Step8'
p48298
ag9
aS'  using namespace dealii;'
p48299
aS'  template <int dim>'
p48300
aS'  class ElasticProblem'
p48301
aS'  {'
p48302
aS'  public:'
p48303
aS'    ElasticProblem();'
p48304
aS'    void run();'
p48305
aS'  private:'
p48306
aS'    void setup_system();'
p48307
aS'    void assemble_system();'
p48308
aS'    void solve();'
p48309
aS'    void refine_grid();'
p48310
aS'    void output_results(const unsigned int cycle) const;'
p48311
aS'    Triangulation<dim> triangulation;'
p48312
aS'    DoFHandler<dim>    dof_handler;'
p48313
aS'    FESystem<dim> fe;'
p48314
aS'    AffineConstraints<double> constraints;'
p48315
aS'    SparsityPattern      sparsity_pattern;'
p48316
aS'    SparseMatrix<double> system_matrix;'
p48317
aS'    Vector<double> solution;'
p48318
aS'    Vector<double> system_rhs;'
p48319
aS'  };'
p48320
aS'  template <int dim>'
p48321
aS'  void right_hand_side(const std::vector<Point<dim>> &points,'
p48322
aS'                       std::vector<Tensor<1, dim>> &  values)'
p48323
aS'  {'
p48324
aS'    Assert(values.size() == points.size(),'
p48325
aS'           ExcDimensionMismatch(values.size(), points.size()));'
p48326
aS'    Assert(dim >= 2, ExcNotImplemented());'
p48327
aS'    Point<dim> point_1, point_2;'
p48328
aS'    point_1(0) = 0.5;'
p48329
aS'    point_2(0) = -0.5;'
p48330
aS'    for (unsigned int point_n = 0; point_n < points.size(); ++point_n)'
p48331
aS'      {'
p48332
aS'        if (((points[point_n] - point_1).norm_square() < 0.2 * 0.2) ||'
p48333
aS'          values[point_n][0] = 1.0;'
p48334
aS'        else'
p48335
aS'          values[point_n][0] = 0.0;'
p48336
aS'        if (points[point_n].norm_square() < 0.2 * 0.2)'
p48337
aS'          values[point_n][1] = 1.0;'
p48338
aS'        else'
p48339
aS'          values[point_n][1] = 0.0;'
p48340
aS'      }'
p48341
aS'  }'
p48342
aS'  template <int dim>'
p48343
aS'  ElasticProblem<dim>::ElasticProblem()'
p48344
aS'    : dof_handler(triangulation)'
p48345
aS'    , fe(FE_Q<dim>(1), dim)'
p48346
aS'  {}'
p48347
aS'  template <int dim>'
p48348
aS'  void ElasticProblem<dim>::setup_system()'
p48349
aS'  {'
p48350
aS'    dof_handler.distribute_dofs(fe);'
p48351
aS'    solution.reinit(dof_handler.n_dofs());'
p48352
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p48353
aS'    constraints.clear();'
p48354
aS'    DoFTools::make_hanging_node_constraints(dof_handler, constraints);'
p48355
aS'    VectorTools::interpolate_boundary_values(dof_handler,'
p48356
aS'                                             0,'
p48357
aS'                                             Functions::ZeroFunction<dim>(dim),'
p48358
aS'                                             constraints);'
p48359
aS'    constraints.close();'
p48360
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p48361
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p48362
aS'                                    dsp,'
p48363
aS'                                    constraints,'
p48364
aS'    sparsity_pattern.copy_from(dsp);'
p48365
aS'    system_matrix.reinit(sparsity_pattern);'
p48366
aS'  }'
p48367
aS'  template <int dim>'
p48368
aS'  void ElasticProblem<dim>::assemble_system()'
p48369
aS'  {'
p48370
aS'    QGauss<dim> quadrature_formula(fe.degree + 1);'
p48371
aS'    FEValues<dim> fe_values(fe,'
p48372
aS'                            quadrature_formula,'
p48373
aS'                            update_values | update_gradients |'
p48374
aS'                              update_quadrature_points | update_JxW_values);'
p48375
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p48376
aS'    const unsigned int n_q_points    = quadrature_formula.size();'
p48377
aS'    FullMatrix<double> cell_matrix(dofs_per_cell, dofs_per_cell);'
p48378
aS'    Vector<double>     cell_rhs(dofs_per_cell);'
p48379
aS'    std::vector<types::global_dof_index> local_dof_indices(dofs_per_cell);'
p48380
aS'    std::vector<double> lambda_values(n_q_points);'
p48381
aS'    std::vector<double> mu_values(n_q_points);'
p48382
aS'    Functions::ConstantFunction<dim> lambda(1.), mu(1.);'
p48383
aS'    std::vector<Tensor<1, dim>> rhs_values(n_q_points);'
p48384
aS'    for (const auto &cell : dof_handler.active_cell_iterators())'
p48385
aS'      {'
p48386
aS'        cell_matrix = 0;'
p48387
aS'        cell_rhs    = 0;'
p48388
aS'        fe_values.reinit(cell);'
p48389
aS'        lambda.value_list(fe_values.get_quadrature_points(), lambda_values);'
p48390
aS'        mu.value_list(fe_values.get_quadrature_points(), mu_values);'
p48391
aS'        right_hand_side(fe_values.get_quadrature_points(), rhs_values);'
p48392
aS'        for (const unsigned int i : fe_values.dof_indices())'
p48393
aS'          {'
p48394
aS'            const unsigned int component_i ='
p48395
aS'              fe.system_to_component_index(i).first;'
p48396
aS'            for (const unsigned int j : fe_values.dof_indices())'
p48397
aS'              {'
p48398
aS'                const unsigned int component_j ='
p48399
aS'                  fe.system_to_component_index(j).first;'
p48400
aS'                for (const unsigned int q_point :'
p48401
aS'                     fe_values.quadrature_point_indices())'
p48402
aS'                  {'
p48403
aS'                    cell_matrix(i, j) +='
p48404
aS'                         fe_values.shape_grad(j, q_point)[component_j] * //'
p48405
aS'                         lambda_values[q_point])                         //'
p48406
aS'                        +                                                //'
p48407
aS'                         fe_values.shape_grad(j, q_point)[component_i] * //'
p48408
aS'                         mu_values[q_point])                             //'
p48409
aS'                        +                                                //'
p48410
aS'                            fe_values.shape_grad(j, q_point) * //'
p48411
aS'                            mu_values[q_point]) :              //'
p48412
aS'                           0)                                  //'
p48413
aS'                      fe_values.JxW(q_point);                  //'
p48414
aS'                  }'
p48415
aS'              }'
p48416
aS'          }'
p48417
aS'        for (const unsigned int i : fe_values.dof_indices())'
p48418
aS'          {'
p48419
aS'            const unsigned int component_i ='
p48420
aS'              fe.system_to_component_index(i).first;'
p48421
aS'            for (const unsigned int q_point :'
p48422
aS'                 fe_values.quadrature_point_indices())'
p48423
aS'              cell_rhs(i) += fe_values.shape_value(i, q_point) *'
p48424
aS'                             rhs_values[q_point][component_i] *'
p48425
aS'                             fe_values.JxW(q_point);'
p48426
aS'          }'
p48427
aS'        cell->get_dof_indices(local_dof_indices);'
p48428
aS'        constraints.distribute_local_to_global('
p48429
aS'          cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);'
p48430
aS'      }'
p48431
aS'  }'
p48432
aS'  template <int dim>'
p48433
aS'  void ElasticProblem<dim>::solve()'
p48434
aS'  {'
p48435
aS'    SolverControl            solver_control(1000, 1e-12);'
p48436
aS'    SolverCG<Vector<double>> cg(solver_control);'
p48437
aS'    PreconditionSSOR<SparseMatrix<double>> preconditioner;'
p48438
aS'    preconditioner.initialize(system_matrix, 1.2);'
p48439
aS'    cg.solve(system_matrix, solution, system_rhs, preconditioner);'
p48440
aS'    constraints.distribute(solution);'
p48441
aS'  }'
p48442
aS'  template <int dim>'
p48443
aS'  void ElasticProblem<dim>::refine_grid()'
p48444
aS'  {'
p48445
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p48446
aS'    KellyErrorEstimator<dim>::estimate(dof_handler,'
p48447
aS'                                       QGauss<dim - 1>(fe.degree + 1),'
p48448
aS'                                       {},'
p48449
aS'                                       solution,'
p48450
aS'                                       estimated_error_per_cell);'
p48451
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p48452
aS'                                                    estimated_error_per_cell,'
p48453
aS'                                                    0.3,'
p48454
aS'                                                    0.03);'
p48455
aS'    triangulation.execute_coarsening_and_refinement();'
p48456
aS'  }'
p48457
aS'  template <int dim>'
p48458
aS'  void ElasticProblem<dim>::output_results(const unsigned int cycle) const'
p48459
aS'  {'
p48460
aS'    DataOut<dim> data_out;'
p48461
aS'    data_out.attach_dof_handler(dof_handler);'
p48462
aS'    std::vector<std::string> solution_names;'
p48463
aS'    switch (dim)'
p48464
aS'      {'
p48465
aS'        case 1:'
p48466
aS'          solution_names.emplace_back("displacement");'
p48467
aS'          break;'
p48468
aS'        case 2:'
p48469
aS'          solution_names.emplace_back("x_displacement");'
p48470
aS'          solution_names.emplace_back("y_displacement");'
p48471
aS'          break;'
p48472
aS'        case 3:'
p48473
aS'          solution_names.emplace_back("x_displacement");'
p48474
aS'          solution_names.emplace_back("y_displacement");'
p48475
aS'          solution_names.emplace_back("z_displacement");'
p48476
aS'          break;'
p48477
aS'        default:'
p48478
aS'          Assert(false, ExcNotImplemented());'
p48479
aS'      }'
p48480
aS'    data_out.add_data_vector(solution, solution_names);'
p48481
aS'    data_out.build_patches();'
p48482
aS'    std::ofstream output("solution-" + std::to_string(cycle) + ".vtk");'
p48483
aS'    data_out.write_vtk(output);'
p48484
aS'  }'
p48485
aS'  template <int dim>'
p48486
aS'  void ElasticProblem<dim>::run()'
p48487
aS'  {'
p48488
aS'    for (unsigned int cycle = 0; cycle < 8; ++cycle)'
p48489
aS'      {'
p48490
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p48491
aS'        if (cycle == 0)'
p48492
aS'          {'
p48493
aS'            GridGenerator::hyper_cube(triangulation, -1, 1);'
p48494
aS'            triangulation.refine_global(4);'
p48495
aS'          }'
p48496
aS'        else'
p48497
aS'          refine_grid();'
p48498
aS'        std::cout << "   Number of active cells:       "'
p48499
aS'                  << triangulation.n_active_cells() << std::endl;'
p48500
aS'        setup_system();'
p48501
aS'        std::cout << "   Number of degrees of freedom: " << dof_handler.n_dofs()'
p48502
aS'                  << std::endl;'
p48503
aS'        assemble_system();'
p48504
aS'        solve();'
p48505
aS'        output_results(cycle);'
p48506
aS'      }'
p48507
aS'  }'
p48508
aS'} // namespace Step8'
p48509
aS'int main()'
p48510
ag9
aS'  try'
p48511
aS'    {'
p48512
aS'      Step8::ElasticProblem<2> elastic_problem_2d;'
p48513
aS'      elastic_problem_2d.run();'
p48514
aS'    }'
p48515
aS'  catch (std::exception &exc)'
p48516
aS'    {'
p48517
aS'      std::cerr << std::endl'
p48518
aS'                << std::endl'
p48519
aS'                << "----------------------------------------------------"'
p48520
aS'                << std::endl;'
p48521
aS'      std::cerr << "Exception on processing: " << std::endl'
p48522
aS'                << exc.what() << std::endl'
p48523
aS'                << "Aborting!" << std::endl'
p48524
aS'                << "----------------------------------------------------"'
p48525
aS'                << std::endl;'
p48526
aS'      return 1;'
p48527
aS'    }'
p48528
aS'  catch (...)'
p48529
aS'    {'
p48530
aS'      std::cerr << std::endl'
p48531
aS'                << std::endl'
p48532
aS'                << "----------------------------------------------------"'
p48533
aS'                << std::endl;'
p48534
aS'      std::cerr << "Unknown exception!" << std::endl'
p48535
aS'                << "Aborting!" << std::endl'
p48536
aS'                << "----------------------------------------------------"'
p48537
aS'                << std::endl;'
p48538
aS'      return 1;'
p48539
aS'    }'
p48540
aS'  return 0;'
p48541
ag17
aS'#include <deal.II/base/quadrature_lib.h>'
p48542
aS'#include <deal.II/base/function.h>'
p48543
aS'#include <deal.II/base/logstream.h>'
p48544
aS'#include <deal.II/lac/vector.h>'
p48545
aS'#include <deal.II/lac/full_matrix.h>'
p48546
aS'#include <deal.II/lac/sparse_matrix.h>'
p48547
aS'#include <deal.II/lac/dynamic_sparsity_pattern.h>'
p48548
aS'#include <deal.II/lac/solver_gmres.h>'
p48549
aS'#include <deal.II/lac/precondition.h>'
p48550
aS'#include <deal.II/lac/affine_constraints.h>'
p48551
aS'#include <deal.II/grid/tria.h>'
p48552
aS'#include <deal.II/grid/grid_generator.h>'
p48553
aS'#include <deal.II/grid/grid_refinement.h>'
p48554
aS'#include <deal.II/dofs/dof_handler.h>'
p48555
aS'#include <deal.II/dofs/dof_tools.h>'
p48556
aS'#include <deal.II/fe/fe_values.h>'
p48557
aS'#include <deal.II/numerics/vector_tools.h>'
p48558
aS'#include <deal.II/numerics/matrix_tools.h>'
p48559
aS'#include <deal.II/numerics/data_out.h>'
p48560
aS'#include <deal.II/fe/fe_q.h>'
p48561
aS'#include <deal.II/grid/grid_out.h>'
p48562
aS'#include <deal.II/base/work_stream.h>'
p48563
aS'#include <deal.II/base/multithread_info.h>'
p48564
aS'#include <deal.II/base/tensor_function.h>'
p48565
aS'#include <deal.II/numerics/error_estimator.h>'
p48566
aS'#include <fstream>'
p48567
aS'#include <iostream>'
p48568
aS'namespace Step9'
p48569
ag9
aS'  using namespace dealii;'
p48570
aS'  template <int dim>'
p48571
aS'  class AdvectionField : public TensorFunction<1, dim>'
p48572
aS'  {'
p48573
aS'  public:'
p48574
aS'    virtual Tensor<1, dim> value(const Point<dim> &p) const override;'
p48575
aS'    DeclException2(ExcDimensionMismatch,'
p48576
aS'                   unsigned int,'
p48577
aS'                   unsigned int,'
p48578
aS'                   << "The vector has size " << arg1 << " but should have "'
p48579
aS'                   << arg2 << " elements.");'
p48580
aS'  };'
p48581
aS'  template <int dim>'
p48582
aS'  Tensor<1, dim> AdvectionField<dim>::value(const Point<dim> &p) const'
p48583
aS'  {'
p48584
aS'    Tensor<1, dim> value;'
p48585
aS'    value[0] = 2;'
p48586
aS'    for (unsigned int i = 1; i < dim; ++i)'
p48587
aS'      value[i] = 1 + 0.8 * std::sin(8. * numbers::PI * p[0]);'
p48588
aS'    return value;'
p48589
aS'  }'
p48590
aS'  template <int dim>'
p48591
aS'  class RightHandSide : public Function<dim>'
p48592
aS'  {'
p48593
aS'  public:'
p48594
aS'    virtual double value(const Point<dim> & p,'
p48595
aS'                         const unsigned int component = 0) const override;'
p48596
aS'  private:'
p48597
aS'    static const Point<dim> center_point;'
p48598
aS'  };'
p48599
aS'  template <>'
p48600
aS'  const Point<1> RightHandSide<1>::center_point = Point<1>(-0.75);'
p48601
aS'  template <>'
p48602
aS'  const Point<2> RightHandSide<2>::center_point = Point<2>(-0.75, -0.75);'
p48603
aS'  template <>'
p48604
aS'  const Point<3> RightHandSide<3>::center_point = Point<3>(-0.75, -0.75, -0.75);'
p48605
aS'  template <int dim>'
p48606
aS'  double RightHandSide<dim>::value(const Point<dim> & p,'
p48607
aS'                                   const unsigned int component) const'
p48608
aS'  {'
p48609
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p48610
aS'    const double diameter = 0.1;'
p48611
aS'    return ((p - center_point).norm_square() < diameter * diameter ?'
p48612
aS'              0.1 / std::pow(diameter, dim) :'
p48613
aS'              0.0);'
p48614
aS'  }'
p48615
aS'  template <int dim>'
p48616
aS'  class BoundaryValues : public Function<dim>'
p48617
aS'  {'
p48618
aS'  public:'
p48619
aS'    virtual double value(const Point<dim> & p,'
p48620
aS'                         const unsigned int component = 0) const override;'
p48621
aS'  };'
p48622
aS'  template <int dim>'
p48623
aS'  double BoundaryValues<dim>::value(const Point<dim> & p,'
p48624
aS'                                    const unsigned int component) const'
p48625
aS'  {'
p48626
aS'    Assert(component == 0, ExcIndexRange(component, 0, 1));'
p48627
aS'    const double sine_term = std::sin(16. * numbers::PI * p.norm_square());'
p48628
aS'    const double weight    = std::exp(5. * (1. - p.norm_square()));'
p48629
aS'    return weight * sine_term;'
p48630
aS'  }'
p48631
aS'  template <int dim>'
p48632
aS'  class AdvectionProblem'
p48633
aS'  {'
p48634
aS'  public:'
p48635
aS'    AdvectionProblem();'
p48636
aS'    void run();'
p48637
aS'  private:'
p48638
aS'    void setup_system();'
p48639
aS'    struct AssemblyScratchData'
p48640
aS'    {'
p48641
aS'      AssemblyScratchData(const FiniteElement<dim> &fe);'
p48642
aS'      AssemblyScratchData(const AssemblyScratchData &scratch_data);'
p48643
aS'      FEValues<dim>     fe_values;'
p48644
aS'      FEFaceValues<dim> fe_face_values;'
p48645
aS'      std::vector<double>         rhs_values;'
p48646
aS'      std::vector<Tensor<1, dim>> advection_directions;'
p48647
aS'      std::vector<double>         face_boundary_values;'
p48648
aS'      std::vector<Tensor<1, dim>> face_advection_directions;'
p48649
aS'      AdvectionField<dim> advection_field;'
p48650
aS'      RightHandSide<dim>  right_hand_side;'
p48651
aS'      BoundaryValues<dim> boundary_values;'
p48652
aS'    };'
p48653
aS'    struct AssemblyCopyData'
p48654
aS'    {'
p48655
aS'      FullMatrix<double>                   cell_matrix;'
p48656
aS'      Vector<double>                       cell_rhs;'
p48657
aS'      std::vector<types::global_dof_index> local_dof_indices;'
p48658
aS'    };'
p48659
aS'    void assemble_system();'
p48660
aS'    void local_assemble_system('
p48661
aS'      const typename DoFHandler<dim>::active_cell_iterator &cell,'
p48662
aS'      AssemblyScratchData &                                 scratch,'
p48663
aS'      AssemblyCopyData &                                    copy_data);'
p48664
aS'    void copy_local_to_global(const AssemblyCopyData &copy_data);'
p48665
aS'    void solve();'
p48666
aS'    void refine_grid();'
p48667
aS'    void output_results(const unsigned int cycle) const;'
p48668
aS'    Triangulation<dim> triangulation;'
p48669
aS'    DoFHandler<dim>    dof_handler;'
p48670
aS'    FE_Q<dim> fe;'
p48671
aS'    AffineConstraints<double> hanging_node_constraints;'
p48672
aS'    SparsityPattern      sparsity_pattern;'
p48673
aS'    SparseMatrix<double> system_matrix;'
p48674
aS'    Vector<double> solution;'
p48675
aS'    Vector<double> system_rhs;'
p48676
aS'  };'
p48677
aS'  class GradientEstimation'
p48678
aS'  {'
p48679
aS'  public:'
p48680
aS'    template <int dim>'
p48681
aS'    static void estimate(const DoFHandler<dim> &dof,'
p48682
aS'                         const Vector<double> & solution,'
p48683
aS'                         Vector<float> &        error_per_cell);'
p48684
aS'    DeclException2(ExcInvalidVectorLength,'
p48685
aS'                   int,'
p48686
aS'                   int,'
p48687
aS'                   << "Vector has length " << arg1 << ", but should have "'
p48688
aS'                   << arg2);'
p48689
aS'    DeclException0(ExcInsufficientDirections);'
p48690
aS'  private:'
p48691
aS'    template <int dim>'
p48692
aS'    struct EstimateScratchData'
p48693
aS'    {'
p48694
aS'      EstimateScratchData(const FiniteElement<dim> &fe,'
p48695
aS'                          const Vector<double> &    solution,'
p48696
aS'                          Vector<float> &           error_per_cell);'
p48697
aS'      EstimateScratchData(const EstimateScratchData &data);'
p48698
aS'      FEValues<dim> fe_midpoint_value;'
p48699
aS'      std::vector<typename DoFHandler<dim>::active_cell_iterator>'
p48700
aS'        active_neighbors;'
p48701
aS'      const Vector<double> &solution;'
p48702
aS'      Vector<float> &       error_per_cell;'
p48703
aS'      std::vector<double> cell_midpoint_value;'
p48704
aS'      std::vector<double> neighbor_midpoint_value;'
p48705
aS'    };'
p48706
aS'    struct EstimateCopyData'
p48707
aS'    {};'
p48708
aS'    template <int dim>'
p48709
aS'    static void'
p48710
aS'    estimate_cell(const typename DoFHandler<dim>::active_cell_iterator &cell,'
p48711
aS'                  EstimateScratchData<dim> &scratch_data,'
p48712
aS'                  const EstimateCopyData &  copy_data);'
p48713
aS'  };'
p48714
aS'  template <int dim>'
p48715
aS'  AdvectionProblem<dim>::AdvectionProblem()'
p48716
aS'    : dof_handler(triangulation)'
p48717
aS'    , fe(5)'
p48718
aS'  {}'
p48719
aS'  template <int dim>'
p48720
aS'  void AdvectionProblem<dim>::setup_system()'
p48721
aS'  {'
p48722
aS'    dof_handler.distribute_dofs(fe);'
p48723
aS'    hanging_node_constraints.clear();'
p48724
aS'    DoFTools::make_hanging_node_constraints(dof_handler,'
p48725
aS'                                            hanging_node_constraints);'
p48726
aS'    hanging_node_constraints.close();'
p48727
aS'    DynamicSparsityPattern dsp(dof_handler.n_dofs(), dof_handler.n_dofs());'
p48728
aS'    DoFTools::make_sparsity_pattern(dof_handler,'
p48729
aS'                                    dsp,'
p48730
aS'                                    hanging_node_constraints,'
p48731
aS'    sparsity_pattern.copy_from(dsp);'
p48732
aS'    system_matrix.reinit(sparsity_pattern);'
p48733
aS'    solution.reinit(dof_handler.n_dofs());'
p48734
aS'    system_rhs.reinit(dof_handler.n_dofs());'
p48735
aS'  }'
p48736
aS'  template <int dim>'
p48737
aS'  void AdvectionProblem<dim>::assemble_system()'
p48738
aS'  {'
p48739
aS'    WorkStream::run(dof_handler.begin_active(),'
p48740
aS'                    dof_handler.end(),'
p48741
aS'                    &AdvectionProblem::local_assemble_system,'
p48742
aS'                    &AdvectionProblem::copy_local_to_global,'
p48743
aS'                    AssemblyScratchData(fe),'
p48744
aS'                    AssemblyCopyData());'
p48745
aS'  }'
p48746
aS'  template <int dim>'
p48747
aS'  AdvectionProblem<dim>::AssemblyScratchData::AssemblyScratchData('
p48748
aS'    const FiniteElement<dim> &fe)'
p48749
aS'    : fe_values(fe,'
p48750
aS'                QGauss<dim>(fe.degree + 1),'
p48751
aS'                update_values | update_gradients | update_quadrature_points |'
p48752
aS'                  update_JxW_values)'
p48753
aS'    , fe_face_values(fe,'
p48754
aS'                     QGauss<dim - 1>(fe.degree + 1),'
p48755
aS'                     update_values | update_quadrature_points |'
p48756
aS'                       update_JxW_values | update_normal_vectors)'
p48757
aS'    , rhs_values(fe_values.get_quadrature().size())'
p48758
aS'    , advection_directions(fe_values.get_quadrature().size())'
p48759
aS'    , face_boundary_values(fe_face_values.get_quadrature().size())'
p48760
aS'    , face_advection_directions(fe_face_values.get_quadrature().size())'
p48761
aS'  {}'
p48762
aS'  template <int dim>'
p48763
aS'  AdvectionProblem<dim>::AssemblyScratchData::AssemblyScratchData('
p48764
aS'    const AssemblyScratchData &scratch_data)'
p48765
aS'    : fe_values(scratch_data.fe_values.get_fe(),'
p48766
aS'                scratch_data.fe_values.get_quadrature(),'
p48767
aS'                update_values | update_gradients | update_quadrature_points |'
p48768
aS'                  update_JxW_values)'
p48769
aS'    , fe_face_values(scratch_data.fe_face_values.get_fe(),'
p48770
aS'                     scratch_data.fe_face_values.get_quadrature(),'
p48771
aS'                     update_values | update_quadrature_points |'
p48772
aS'                       update_JxW_values | update_normal_vectors)'
p48773
aS'    , rhs_values(scratch_data.rhs_values.size())'
p48774
aS'    , advection_directions(scratch_data.advection_directions.size())'
p48775
aS'    , face_boundary_values(scratch_data.face_boundary_values.size())'
p48776
aS'    , face_advection_directions(scratch_data.face_advection_directions.size())'
p48777
aS'  {}'
p48778
aS'  template <int dim>'
p48779
aS'  void AdvectionProblem<dim>::local_assemble_system('
p48780
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p48781
aS'    AssemblyScratchData &                                 scratch_data,'
p48782
aS'    AssemblyCopyData &                                    copy_data)'
p48783
aS'  {'
p48784
aS'    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();'
p48785
aS'    const unsigned int n_q_points ='
p48786
aS'      scratch_data.fe_values.get_quadrature().size();'
p48787
aS'    const unsigned int n_face_q_points ='
p48788
aS'      scratch_data.fe_face_values.get_quadrature().size();'
p48789
aS'    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);'
p48790
aS'    copy_data.cell_rhs.reinit(dofs_per_cell);'
p48791
aS'    copy_data.local_dof_indices.resize(dofs_per_cell);'
p48792
aS'    scratch_data.fe_values.reinit(cell);'
p48793
aS'    scratch_data.advection_field.value_list('
p48794
aS'      scratch_data.fe_values.get_quadrature_points(),'
p48795
aS'      scratch_data.advection_directions);'
p48796
aS'    scratch_data.right_hand_side.value_list('
p48797
aS'      scratch_data.fe_values.get_quadrature_points(), scratch_data.rhs_values);'
p48798
aS'    const double delta = 0.1 * cell->diameter();'
p48799
aS'    for (unsigned int q_point = 0; q_point < n_q_points; ++q_point)'
p48800
aS'      for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p48801
aS'        {'
p48802
aS'          const auto &sd = scratch_data;'
p48803
aS'          for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p48804
aS'            copy_data.cell_matrix(i, j) +='
p48805
aS'                delta * (sd.advection_directions[q_point] *      // delta beta'
p48806
aS'                         sd.fe_values.shape_grad(i, q_point))) * // grad phi_i)'
p48807
aS'               sd.advection_directions[q_point] *                // beta'
p48808
aS'               sd.fe_values.shape_grad(j, q_point)) *            // grad phi_j'
p48809
aS'              sd.fe_values.JxW(q_point);                         // dx'
p48810
aS'          copy_data.cell_rhs(i) +='
p48811
aS'             delta * (sd.advection_directions[q_point] *      // delta beta'
p48812
aS'                      sd.fe_values.shape_grad(i, q_point))) * // grad phi_i)'
p48813
aS'            sd.rhs_values[q_point] *                          // f'
p48814
aS'            sd.fe_values.JxW(q_point);                        // dx'
p48815
aS'        }'
p48816
aS'    for (const auto &face : cell->face_iterators())'
p48817
aS'      if (face->at_boundary())'
p48818
aS'        {'
p48819
aS'          scratch_data.fe_face_values.reinit(cell, face);'
p48820
aS'          scratch_data.boundary_values.value_list('
p48821
aS'            scratch_data.fe_face_values.get_quadrature_points(),'
p48822
aS'            scratch_data.face_boundary_values);'
p48823
aS'          scratch_data.advection_field.value_list('
p48824
aS'            scratch_data.fe_face_values.get_quadrature_points(),'
p48825
aS'            scratch_data.face_advection_directions);'
p48826
aS'          for (unsigned int q_point = 0; q_point < n_face_q_points; ++q_point)'
p48827
aS'            if (scratch_data.fe_face_values.normal_vector(q_point) *'
p48828
aS'                  scratch_data.face_advection_directions[q_point] <'
p48829
aS'                0.)'
p48830
aS'              for (unsigned int i = 0; i < dofs_per_cell; ++i)'
p48831
aS'                {'
p48832
aS'                  for (unsigned int j = 0; j < dofs_per_cell; ++j)'
p48833
aS'                    copy_data.cell_matrix(i, j) -='
p48834
aS'                       scratch_data.fe_face_values.normal_vector(q_point) *'
p48835
aS'                       scratch_data.fe_face_values.shape_value(i, q_point) *'
p48836
aS'                       scratch_data.fe_face_values.shape_value(j, q_point) *'
p48837
aS'                       scratch_data.fe_face_values.JxW(q_point));'
p48838
aS'                  copy_data.cell_rhs(i) -='
p48839
aS'                     scratch_data.fe_face_values.normal_vector(q_point) *'
p48840
aS'                     scratch_data.face_boundary_values[q_point] *'
p48841
aS'                     scratch_data.fe_face_values.shape_value(i, q_point) *'
p48842
aS'                     scratch_data.fe_face_values.JxW(q_point));'
p48843
aS'                }'
p48844
aS'        }'
p48845
aS'    cell->get_dof_indices(copy_data.local_dof_indices);'
p48846
aS'  }'
p48847
aS'  template <int dim>'
p48848
aS'  void'
p48849
aS'  AdvectionProblem<dim>::copy_local_to_global(const AssemblyCopyData &copy_data)'
p48850
aS'  {'
p48851
aS'    hanging_node_constraints.distribute_local_to_global('
p48852
aS'      copy_data.cell_matrix,'
p48853
aS'      copy_data.cell_rhs,'
p48854
aS'      copy_data.local_dof_indices,'
p48855
aS'      system_matrix,'
p48856
aS'      system_rhs);'
p48857
aS'  }'
p48858
aS'  template <int dim>'
p48859
aS'  void AdvectionProblem<dim>::solve()'
p48860
aS'  {'
p48861
aS'    SolverControl               solver_control(std::max<std::size_t>(1000,'
p48862
aS'                                                       system_rhs.size() / 10),'
p48863
aS'                                 1e-10 * system_rhs.l2_norm());'
p48864
aS'    SolverGMRES<Vector<double>> solver(solver_control);'
p48865
aS'    PreconditionJacobi<SparseMatrix<double>> preconditioner;'
p48866
aS'    preconditioner.initialize(system_matrix, 1.0);'
p48867
aS'    solver.solve(system_matrix, solution, system_rhs, preconditioner);'
p48868
aS'    Vector<double> residual(dof_handler.n_dofs());'
p48869
aS'    system_matrix.vmult(residual, solution);'
p48870
aS'    residual -= system_rhs;'
p48871
aS'    std::cout << "   Iterations required for convergence: "'
p48872
aS"              << solver_control.last_step() << '\\n'"
p48873
aS'              << "   Max norm of residual:                "'
p48874
aS"              << residual.linfty_norm() << '\\n';"
p48875
aS'    hanging_node_constraints.distribute(solution);'
p48876
aS'  }'
p48877
aS'  template <int dim>'
p48878
aS'  void AdvectionProblem<dim>::refine_grid()'
p48879
aS'  {'
p48880
aS'    Vector<float> estimated_error_per_cell(triangulation.n_active_cells());'
p48881
aS'    GradientEstimation::estimate(dof_handler,'
p48882
aS'                                 solution,'
p48883
aS'                                 estimated_error_per_cell);'
p48884
aS'    GridRefinement::refine_and_coarsen_fixed_number(triangulation,'
p48885
aS'                                                    estimated_error_per_cell,'
p48886
aS'                                                    0.3,'
p48887
aS'                                                    0.03);'
p48888
aS'    triangulation.execute_coarsening_and_refinement();'
p48889
aS'  }'
p48890
aS'  template <int dim>'
p48891
aS'  void AdvectionProblem<dim>::output_results(const unsigned int cycle) const'
p48892
aS'  {'
p48893
aS'    {'
p48894
aS'      GridOut       grid_out;'
p48895
aS'      std::ofstream output("grid-" + std::to_string(cycle) + ".vtu");'
p48896
aS'      grid_out.write_vtu(triangulation, output);'
p48897
aS'    }'
p48898
aS'    {'
p48899
aS'      DataOut<dim> data_out;'
p48900
aS'      data_out.attach_dof_handler(dof_handler);'
p48901
aS'      data_out.add_data_vector(solution, "solution");'
p48902
aS'      data_out.build_patches(8);'
p48903
aS'      DataOutBase::VtkFlags vtk_flags;'
p48904
aS'      vtk_flags.compression_level ='
p48905
aS'        DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed;'
p48906
aS'      data_out.set_flags(vtk_flags);'
p48907
aS'      std::ofstream output("solution-" + std::to_string(cycle) + ".vtu");'
p48908
aS'      data_out.write_vtu(output);'
p48909
aS'    }'
p48910
aS'  }'
p48911
aS'  template <int dim>'
p48912
aS'  void AdvectionProblem<dim>::run()'
p48913
aS'  {'
p48914
aS'    for (unsigned int cycle = 0; cycle < 10; ++cycle)'
p48915
aS'      {'
p48916
aS'        std::cout << "Cycle " << cycle << \':\' << std::endl;'
p48917
aS'        if (cycle == 0)'
p48918
aS'          {'
p48919
aS'            GridGenerator::hyper_cube(triangulation, -1, 1);'
p48920
aS'            triangulation.refine_global(3);'
p48921
aS'          }'
p48922
aS'        else'
p48923
aS'          {'
p48924
aS'            refine_grid();'
p48925
aS'          }'
p48926
aS'        std::cout << "   Number of active cells:              "'
p48927
aS'                  << triangulation.n_active_cells() << std::endl;'
p48928
aS'        setup_system();'
p48929
aS'        std::cout << "   Number of degrees of freedom:        "'
p48930
aS'                  << dof_handler.n_dofs() << std::endl;'
p48931
aS'        assemble_system();'
p48932
aS'        solve();'
p48933
aS'        output_results(cycle);'
p48934
aS'      }'
p48935
aS'  }'
p48936
aS'  template <int dim>'
p48937
aS'  GradientEstimation::EstimateScratchData<dim>::EstimateScratchData('
p48938
aS'    const FiniteElement<dim> &fe,'
p48939
aS'    const Vector<double> &    solution,'
p48940
aS'    Vector<float> &           error_per_cell)'
p48941
aS'    : fe_midpoint_value(fe,'
p48942
aS'                        QMidpoint<dim>(),'
p48943
aS'                        update_values | update_quadrature_points)'
p48944
aS'    , solution(solution)'
p48945
aS'    , error_per_cell(error_per_cell)'
p48946
aS'    , cell_midpoint_value(1)'
p48947
aS'    , neighbor_midpoint_value(1)'
p48948
aS'  {'
p48949
aS'    active_neighbors.reserve(GeometryInfo<dim>::faces_per_cell *'
p48950
aS'                             GeometryInfo<dim>::max_children_per_face);'
p48951
aS'  }'
p48952
aS'  template <int dim>'
p48953
aS'  GradientEstimation::EstimateScratchData<dim>::EstimateScratchData('
p48954
aS'    const EstimateScratchData &scratch_data)'
p48955
aS'    : fe_midpoint_value(scratch_data.fe_midpoint_value.get_fe(),'
p48956
aS'                        scratch_data.fe_midpoint_value.get_quadrature(),'
p48957
aS'                        update_values | update_quadrature_points)'
p48958
aS'    , solution(scratch_data.solution)'
p48959
aS'    , error_per_cell(scratch_data.error_per_cell)'
p48960
aS'    , cell_midpoint_value(1)'
p48961
aS'    , neighbor_midpoint_value(1)'
p48962
aS'  {}'
p48963
aS'  template <int dim>'
p48964
aS'  void GradientEstimation::estimate(const DoFHandler<dim> &dof_handler,'
p48965
aS'                                    const Vector<double> & solution,'
p48966
aS'                                    Vector<float> &        error_per_cell)'
p48967
aS'  {'
p48968
aS'    Assert('
p48969
aS'      error_per_cell.size() == dof_handler.get_triangulation().n_active_cells(),'
p48970
aS'      ExcInvalidVectorLength(error_per_cell.size(),'
p48971
aS'                             dof_handler.get_triangulation().n_active_cells()));'
p48972
aS'    WorkStream::run(dof_handler.begin_active(),'
p48973
aS'                    dof_handler.end(),'
p48974
aS'                    &GradientEstimation::template estimate_cell<dim>,'
p48975
aS'                    std::function<void(const EstimateCopyData &)>(),'
p48976
aS'                    EstimateScratchData<dim>(dof_handler.get_fe(),'
p48977
aS'                                             solution,'
p48978
aS'                                             error_per_cell),'
p48979
aS'                    EstimateCopyData());'
p48980
aS'  }'
p48981
aS'  template <int dim>'
p48982
aS'  void GradientEstimation::estimate_cell('
p48983
aS'    const typename DoFHandler<dim>::active_cell_iterator &cell,'
p48984
aS'    EstimateScratchData<dim> &                            scratch_data,'
p48985
aS'    const EstimateCopyData &)'
p48986
aS'  {'
p48987
aS'    Tensor<2, dim> Y;'
p48988
aS'    scratch_data.fe_midpoint_value.reinit(cell);'
p48989
aS'    scratch_data.active_neighbors.clear();'
p48990
aS'    for (const auto face_n : cell->face_indices())'
p48991
aS'      if (!cell->at_boundary(face_n))'
p48992
aS'        {'
p48993
aS'          const auto face     = cell->face(face_n);'
p48994
aS'          const auto neighbor = cell->neighbor(face_n);'
p48995
aS'          if (neighbor->is_active())'
p48996
aS'            scratch_data.active_neighbors.push_back(neighbor);'
p48997
aS'          else'
p48998
aS'            {'
p48999
aS'              if (dim == 1)'
p49000
aS'                {'
p49001
aS'                  auto neighbor_child = neighbor;'
p49002
aS'                  while (neighbor_child->has_children())'
p49003
aS'                    neighbor_child = neighbor_child->child(face_n == 0 ? 1 : 0);'
p49004
aS'                  Assert(neighbor_child->neighbor(face_n == 0 ? 1 : 0) == cell,'
p49005
aS'                         ExcInternalError());'
p49006
aS'                  scratch_data.active_neighbors.push_back(neighbor_child);'
p49007
aS'                }'
p49008
aS'              else'
p49009
aS'                for (unsigned int subface_n = 0; subface_n < face->n_children();'
p49010
aS'                     ++subface_n)'
p49011
aS'                  scratch_data.active_neighbors.push_back('
p49012
aS'                    cell->neighbor_child_on_subface(face_n, subface_n));'
p49013
aS'            }'
p49014
aS'        }'
p49015
aS'    const Point<dim> this_center ='
p49016
aS'      scratch_data.fe_midpoint_value.quadrature_point(0);'
p49017
aS'    scratch_data.fe_midpoint_value.get_function_values('
p49018
aS'      scratch_data.solution, scratch_data.cell_midpoint_value);'
p49019
aS'    Tensor<1, dim> projected_gradient;'
p49020
aS'    for (const auto &neighbor : scratch_data.active_neighbors)'
p49021
aS'      {'
p49022
aS'        scratch_data.fe_midpoint_value.reinit(neighbor);'
p49023
aS'        const Point<dim> neighbor_center ='
p49024
aS'          scratch_data.fe_midpoint_value.quadrature_point(0);'
p49025
aS'        scratch_data.fe_midpoint_value.get_function_values('
p49026
aS'          scratch_data.solution, scratch_data.neighbor_midpoint_value);'
p49027
aS'        Tensor<1, dim> y        = neighbor_center - this_center;'
p49028
aS'        const double   distance = y.norm();'
p49029
aS'        y /= distance;'
p49030
aS'        for (unsigned int i = 0; i < dim; ++i)'
p49031
aS'          for (unsigned int j = 0; j < dim; ++j)'
p49032
aS'            Y[i][j] += y[i] * y[j];'
p49033
aS'        projected_gradient += (scratch_data.neighbor_midpoint_value[0] -'
p49034
aS'                               scratch_data.cell_midpoint_value[0]) /'
p49035
aS'                              distance * y;'
p49036
aS'      }'
p49037
aS'    AssertThrow(determinant(Y) != 0, ExcInsufficientDirections());'
p49038
aS'    const Tensor<2, dim> Y_inverse = invert(Y);'
p49039
aS'    const Tensor<1, dim> gradient = Y_inverse * projected_gradient;'
p49040
aS'    scratch_data.error_per_cell(cell->active_cell_index()) ='
p49041
aS'  }'
p49042
aS'} // namespace Step9'
p49043
aS'int main()'
p49044
ag9
aS'  using namespace dealii;'
p49045
aS'  try'
p49046
aS'    {'
p49047
aS'      MultithreadInfo::set_thread_limit();'
p49048
aS'      Step9::AdvectionProblem<2> advection_problem_2d;'
p49049
aS'      advection_problem_2d.run();'
p49050
aS'    }'
p49051
aS'  catch (std::exception &exc)'
p49052
aS'    {'
p49053
aS'      std::cerr << std::endl'
p49054
aS'                << std::endl'
p49055
aS'                << "----------------------------------------------------"'
p49056
aS'                << std::endl;'
p49057
aS'      std::cerr << "Exception on processing: " << std::endl'
p49058
aS'                << exc.what() << std::endl'
p49059
aS'                << "Aborting!" << std::endl'
p49060
aS'                << "----------------------------------------------------"'
p49061
aS'                << std::endl;'
p49062
aS'      return 1;'
p49063
aS'    }'
p49064
aS'  catch (...)'
p49065
aS'    {'
p49066
aS'      std::cerr << std::endl'
p49067
aS'                << std::endl'
p49068
aS'                << "----------------------------------------------------"'
p49069
aS'                << std::endl;'
p49070
aS'      std::cerr << "Unknown exception!" << std::endl'
p49071
aS'                << "Aborting!" << std::endl'
p49072
aS'                << "----------------------------------------------------"'
p49073
aS'                << std::endl;'
p49074
aS'      return 1;'
p49075
aS'    }'
p49076
aS'  return 0;'
p49077
ag17
a.