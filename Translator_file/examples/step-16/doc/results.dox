examples/step-16/doc/results.dox



<h1>Results</h1>

在最细的网格上，解决方案看起来像这样。

<p align="center">  <img src="https://www.dealii.org/images/steps/developer/step-16.solution.png" alt="">   </p>  。

更重要的是，我们想看看多网格方法是否真的改善了求解器的性能。因此，这里是文本输出。

<p>周期0 活动单元数：80 自由度数：89（按级别：8，25，89） CG迭代数。8

周期1 活动单元数：158 自由度数：183（按级别：8，25，89，138） CG迭代次数。9

周期2 活动单元数：302 自由度数：352（按级别：8、25、89、223、160） CG迭代次数。10

周期3 活动单元数：578 自由度数：649（按级别：8、25、89、231、494、66） CG迭代次数。10

第四周期 活跃单元数：1100 自由度数：1218（按级别：8、25、89、274、764、417、126） CG迭代次数。10

周期5 活动单元数：2096 自由度数：2317（按级别：8、25、89、304、779、1214、817） CG迭代次数。11

第6周期 活跃单元数：3986 自由度数：4366（按级别：8，25，89，337，836，2270，897，1617） CG迭代数。10

周期7 活动单元数：7574 自由度数：8350（按级别：8、25、89、337、1086、2835、2268、1789、3217） CG迭代次数。11 </pre>

这几乎是完美的多重网格性能：线性残差在10个迭代步骤中被减少了12个数量级，而且结果几乎与网格大小无关。这显然部分是由于所解决的问题的简单性质，但它显示了多梯度方法的力量。




<h3> Possibilities for extensions </h3>


我们鼓励你生成solve()调用的时间并与步骤6进行比较。你会看到多网格方法在粗网格上有相当大的开销，但由于其最佳的复杂性，它在细网格上总是胜过其他方法。

仔细检查这个程序的性能就会发现，它主要是由矩阵-向量操作主导的。step-37展示了一种通过使用无矩阵方法来避免这种情况的方法。

另一个途径是使用代数多网格方法。这里使用的几何多栅方法在实现上有时会有点尴尬，因为它需要所有这些额外的数据结构，如果程序要在%parallel的机器上通过MPI耦合运行，就会变得更加困难，例如。在这种情况下，如果能使用一个黑盒预处理程序，就会更简单，该程序使用某种多栅层次结构以获得良好的性能，但可以自己计算出水平矩阵和类似的东西。代数多栅方法正是这样做的，我们将在步骤31中使用它们来解决斯托克斯问题，在步骤32和步骤40中使用它们来解决平行变化。也就是说，在步骤50中可以找到这个例子程序的MPI并行版本。

最后，人们可能要考虑如何将几何多网格用于其他类型的问题，特别是 @ref vector_valued "矢量值问题"。这是step-56的主题，我们将这里的技术用于斯托克斯方程。


