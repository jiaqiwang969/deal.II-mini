examples/step-40/doc/results.dox



<h1>Results</h1>

当你在单个处理器上或在几个本地MPI安装上运行该程序时，你应该得到这样的输出。

@code
Cycle 0:
   Number of active cells:       1024
   Number of degrees of freedom: 4225
   Solved in 10 iterations.



+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    |     0.176s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| assembly                        |         1 |    0.0209s |        12% |
| output                          |         1 |    0.0189s |        11% |
| setup                           |         1 |    0.0299s |        17% |
| solve                           |         1 |    0.0419s |        24% |
+---------------------------------+-----------+------------+------------+



Cycle 1:
   Number of active cells:       1954
   Number of degrees of freedom: 8399
   Solved in 10 iterations.



+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    |     0.327s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| assembly                        |         1 |    0.0368s |        11% |
| output                          |         1 |    0.0208s |       6.4% |
| refine                          |         1 |     0.157s |        48% |
| setup                           |         1 |    0.0452s |        14% |
| solve                           |         1 |    0.0668s |        20% |
+---------------------------------+-----------+------------+------------+



Cycle 2:
   Number of active cells:       3664
   Number of degrees of freedom: 16183
   Solved in 11 iterations.


...
@endcode



确切的数字是不同的，这取决于我们使用多少个处理器；这是由于预处理程序取决于问题的分区，然后解决方案在最后几位上有所不同，因此，网格细化也略有不同。不过，这里最值得注意的是，迭代次数并不随问题的大小而增加。这保证了我们甚至可以有效地解决最大的问题。

当在足够多的机器上运行时（比如说几千台），这个程序可以相对容易地在不到一分钟的时间内解决有远超过10亿个未知数的问题。另一方面，这样的大问题已经不能被视觉化，所以我们也只在16个处理器上运行该程序。下面是一个网格，以及它在16个处理器上的划分，还有相应的解决方案。

 <table width="100%">
<tr>
<td>
  <img src="https://www.dealii.org/images/steps/developer/step-40.mesh.png" alt="">
</td>
<td>
  <img src="https://www.dealii.org/images/steps/developer/step-40.solution.png" alt="">
</td>
</tr>
</table> 

左边的网格仅有7,069个单元。当然，这个问题我们在单台处理器上使用step-6就已经很容易解决了，但是这个程序的重点是展示如何编写一个可以扩展到更多机器的程序。例如，这里有两张图，显示了如果我们采取越来越多的处理器，程序的大量部分的运行时间是如何在大约5200万和37500万自由度的问题上扩展的（这些和接下来的几张图取自 @ref distributed_paper "分布式计算论文 "的早期版本；显示在更大数量的处理器上运行数据的更新图，以及更多的解释可以在该论文的最终版本中找到）。

 <table width="100%">
<tr>
<td>
  <img src="https://www.dealii.org/images/steps/developer/step-40.strong2.png" alt="">
</td>
<td>
  <img src="https://www.dealii.org/images/steps/developer/step-40.strong.png" alt="">
</td>
</tr>
</table> 

可以清楚地看到，这个程序可以很好地扩展到非常多的处理器。关于我们认为的 "可扩展 "程序的讨论，见 @ref GlossParallelScaling "本词汇表条目"）。曲线，特别是线性求解器，在图形的右端变得有点摇摆不定，因为每个处理器要做的事情太少，无法抵消通信成本（在上面两个例子中，每个处理器要解决的整个问题的部分，在使用4,096个处理器时，只有13,000和90,000个自由度；一个好的经验法则是，如果每个处理器至少有100,000个未知数，并行程序就会运行良好）。

虽然上面的强扩展图显示，如果我们采取越来越多的处理器，我们可以越来越快地解决一个固定大小的问题，但更有趣的问题可能是，问题可以变得多大，以便在一个特定大小的机器上仍然可以在合理的时间内解决它们。我们在下面两张256和4096处理器的图中展示了这一点。

 <table width="100%">
<tr>
<td>
  <img src="https://www.dealii.org/images/steps/developer/step-40.256.png" alt="">
</td>
<td>
  <img src="https://www.dealii.org/images/steps/developer/step-40.4096.png" alt="">
</td>
</tr>
</table> 

这些图显示的是，程序的所有部分都随着自由度数的增加而线性扩展。这一次，由于局部问题的规模太小，线条在左边摇摆不定。关于这些结果的更多讨论，我们参考了 @ref distributed_paper "分布式计算论文"。

那么，一个人能够解决的最大问题是多大？在写这个问题的时候，限制因素是程序使用<a
href="http://acts.nersc.gov/hypre/" target="_top">Hypre package</a>中的BoomerAMG代数多网格方法作为预处理程序，不幸的是，它使用有符号的32位整数来索引%分布式矩阵的元素。这将问题的大小限制在 $2^{31}-1=2,147,483,647$ 个自由度。从上面的图中可以看出，可扩展性会超过这个数字，而且可以预期，给定超过上面显示的4096台机器也会进一步减少计算时间。也就是说，人们当然可以期待，这个限制最终会被hybre的开发者解除。

另一方面，这并不意味着deal.II不能解决更大的问题。事实上，step-37展示了如何解决不仅仅是一点点，而是大大超过我们在这里所展示的任何问题的问题。




<a name="extensions"></a>

<h3>Possibilities for extensions</h3>

从某种意义上说，这个程序是拉普拉斯方程的终极解算器：只要你有足够的处理器，它基本上可以把方程解到你想要的精度。由于拉普拉斯方程本身在这种精度水平上并不十分有趣，因此，更有趣的扩展可能性不在于这个程序，而在于它之后的内容。例如，本教程中的其他几个程序都有相当长的运行时间，特别是在3D中。因此，使用这里解释的技术来扩展其他程序以支持并行的分布式计算将是有趣的。我们在step-32教程程序中对step-31做了这样的处理，但同样的做法也适用于，例如，用于双曲时间相关问题的step-23和step-25，用于气体动力学的step-33，或用于纳维-斯托克斯方程的step-35。

也许同样有趣的是后处理的问题。如上所述，我们只展示了16个处理器的解决方案和网格的图片，因为4,096个处理器解决10亿个未知数会产生几10G的图形输出。目前，除非在至少几百个处理器上运行，否则没有任何程序能够以任何合理的方式将如此大量的数据可视化。然而，有一些方法，可视化程序直接与每个处理器上的求解器进行通信，每个可视化进程渲染这个处理器上的求解器所计算的场景部分。实现这样的接口将允许快速可视化那些在其他方面不适合用图形显示的东西。


