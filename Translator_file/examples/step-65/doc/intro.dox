examples/step-65/doc/intro.dox



 <br> 

<i>
This program was contributed by Martin Kronbichler.
</i>

<a name="Intro"></a>

<h1>Introduction</h1>

本教程程序介绍了一个高级流形类--TransfiniteInterpolationManifold，以及如何解决其主要缺点--相对较高的成本。

<h3>Working with manifolds</h3>

<h4>What we want</h4>

在许多应用中，有限元网格必须能够表示一个相对复杂的几何体。在step-1、step-49和step-53教程程序中，已经介绍了deal.II库中可用的一些生成网格的技术。给定一个基础网格，deal.II能够通过将单元格均匀地或仅在计算域的选定部分细分为子单元来创建一个更细的网格。除了GridGenerator命名空间中的基本网格划分功能外，deal.II还提供了一些接口，可以使用命名空间GridIn的功能读入由（仅四边形和六边形）网格生成器生成的网格，例如在步骤5中演示。外部生成的网格的一个基本限制是，网格中生成的单元所提供的信息只包括顶点的位置和它们的连接性，而没有最初创建这个网格的网格生成器所提供的底层几何体的背景。一旦网格在deal.II中被细化，需要放置更多的点，这就成了问题。第54步教程程序显示了如何通过使用OpenCASCADE库方面的CAD曲面来克服这个限制，第53步通过在源代码内以编程方式提供同类信息。

在deal.II中，网格细化过程中新点的放置或高阶映射的定义由流形对象控制，详见 @ref manifold  "流形模块"。举个例子，考虑以下二维环形的情况（图片取自流形模块）。如果我们从10个单元的初始网格开始，在不附加任何流形的情况下全局细化网格三次，我们将得到以下网格。

 @image html hypershell-nothing.png "" 

图片看起来是这样的，因为在默认情况下，deal.II只知道通过平均父单元的顶点位置来放置子单元的顶点。这就产生了一个多边形域，其面是原始（粗略的网格）单元的边缘。很明显，我们必须对三角形的边界面附加一个曲线描述，以便在网格细化时重现圆形，就像下图一样。

 @image html hypershell-boundary-only.png "" 

这样就好多了。如果我们继续细化网格，至少现在的内外边界已经接近真实的圆了。然而，这幅图中的网格对于环形来说仍然不是最佳的，因为从一个单元到下一个单元的<i>interior</i>线在某些顶点上有扭结，人们宁愿使用下面的网格。

 @image html hypershell-all.png "" 

在这最后一种（最佳）情况下，也是由 GridGenerator::hyper_shell(), 产生的默认情况，曲线流形描述（在这种情况下是极地流形描述）不仅适用于边界面，而且适用于整个域。每当三角化要求一个新的点，例如，当它将一个单元细化为四个子单元时，边缘或单元的中点，它将沿着极坐标系统中各自的中点来放置它们。相比之下，上面那种只有边界受制于极地流形的情况，只有沿边界的中点会沿着曲线描述放置，而内部的中点会通过直角坐标系中周围点的合适平均值来计算（更多细节见 @ref manifold  "流形模块"）。

在这一点上，人们可能会认为曲线形的体积描述是一种方式。这一般来说是不会错的，尽管有时并不那么容易描述这到底应该如何工作。这里有几个例子。

- 想象一下，上面的网格实际上是一个圆盘，而不只是一个环。   在这种情况下，极地流形会在原点退化，不会产生合理的新点。事实上，为那些应该 "看起来是圆的 "但可能在原点或接近原点的东西定义流形描述是令人惊讶的非常困难的。

- 当人们试图将球形流形附加到整个体积上时，类似的事情也会发生在三维球的原点；在这种情况下，新流形点的计算会因异常而中止。

- CAD几何体通常只描述域的边界，就像我们在上面第二张图中只把流形附在边界上一样。同样地，Step-54只使用CAD几何体来生成表面网格（也许是因为这是解决相关问题所需要的），但是如果想解决那里描述的水或船周围空气中的问题，我们就需要有一个体积网格。那么问题来了，我们应该如何准确地描述域的内部应该发生什么。

这些简单的例子清楚地表明，对于许多有趣的情况，我们必须从对全体积的分析性曲率描述的愿望中退一步。将需要有<i>some</i>种导致曲率也在内部的信息，但必须有可能做到这一点，而不需要实际写下描述那种几何的明确公式。

那么，如果我们不在内部做任何事情，只把表面描述为流形，会发生什么呢？有时，如上图所示的环，结果并不可怕。但有时却很糟糕。考虑一个环状体的情况（例如用 GridGenerator::torus()) 生成的环状体，只在表面附加一个TorusManifold对象，内部单元和面没有附加流形，细化前有六个单元在环状方向。如果对网格进行一次细化，我们将得到如下的网格，图中显示的是网格的上半部分被剪切掉了。

 @image html torus_no_inner_manifold.png "" 

这显然是次优的。事实上，如果我们从少于上面显示的环形方向的六个单元开始，映射在某些区域实际上是倒置的，因为沿着内部单元放置的新点与边界相交，因为它们不是沿着环形方向的圆形。环形的简单情况仍然可以被固定下来，因为我们知道环形方向是沿着圆柱坐标系的，所以在曲面上附加一个TorusManifold，结合CylindricalManifold，在环形方向上有适当的周期性，应用于所有的内部实体，将产生一个高质量的网格，如下所示，现在有两个顶部的单元被隐藏起来。

 @image html torus_cylindrical_inner_manifold.png "" 

这个网格是相当不错的，但显然它与对体积的良好描述有关，而我们在其他情况下缺乏这种描述。实际上，在这种情况下也有一个不完美之处，因为我们可以看到域的内部的两个相邻单元的一些不自然的扭结，这些扭结被顶部的两个边界单元所隐藏，与下面的设置相反（由 GridGenerator::torus() 应用的默认流形并使用TransfiniteInterpolationManifold）。

 @image html torus_transfinite_manifold.png "" 

<h3>The class TransfiniteInterpolationManifold</h3>

为了找到一个更好的策略，让我们再看看二维圆盘（这也是沿环形方向旋转的环形实体的基础）。正如我们上面所学到的，我们只能将弯曲的极坐标描述应用于边界（或离原点足够远的单元的边缘），但最终必须过渡到对圆盘中心的直线描述。如果我们在单元的内部使用平坦的流形（也就是说，新的顶点是通过相邻的现有顶点的平均化而产生的），而极地流形只用于圆盘的边界，那么在进行四次全局细化之后，我们会得到以下网格。

 @image html circular_mesh_only_boundary_manifold.png "" 

这并不是一个可怕的网格。同时，如果你知道最初的粗略网格是由中间的一个正方形和周围的四个盖子组成的，那么就不难看出这个网格的每一个细化步骤都是为了得到上面的图片。

虽然deal.II的三角测量类在创建新点时试图将信息从边界传播到内部，但这种算法的影响范围是有限的。

 @image html circular_mesh_boundary_cells.png "" 

上图突出了盘面上那些触及边界的单元，在当时只看一个单元的情况下，原则上可以考虑边界信息。显然，随着网格的细化，可以考虑到一些曲率的区域变得更加有限，因此在网格中形成了看似不规则的点。当计算最左边图片中任何一个边界单元的中心时，理想的位置是外圈和中间的单元之间的中点。这正是三角剖分类中第一个细化步骤所使用的内容。然而，对于第二次细化，所有的内部边缘以及内部单元格层只能根据平面流形描述来加点。

在这一点上，我们意识到需要什么来创建一个更好的网格。对于<i>all</i>子单元中的<i>any</i>新点，即在最左边的红色阴影层内创建的单元，我们要计算相对于各自粗单元覆盖区域内的曲率的插值。这可以通过在上图最左边面板的粗略网格的高亮单元中添加TransfiniteInterpolationManifold类来实现。该类遵守一般流形接口，即在其定义域内给定任何一组点，它可以计算符合流形的加权平均数（使用的公式将在一分钟后给出）。这些加权平均数在细化网格的时候，或者在给定单元上评估符合该流形的高阶映射（如MappingQGeneric或MappingC1）的时候都会用到。在圆盘粗网格的阴影单元上使用该流形（即不仅仅是最外层的单元），在经过四个全局步骤的细化后产生以下网格。

 @image html circular_mesh_transfinite_interpolation.png "" 

这个网格的线条仍有一些扭结，但它们仅限于粗大的网格单元之间的面，而网格的其他部分则如人们所希望的那样平滑。事实上，给定一个直边的中心单元，这个表示法是最好的，因为所有的网格单元都遵循一个平滑的过渡，从内部的方形块的直边到边界的圆形。(我们可以做得更好一些，在中心的方形块中也允许一些曲率，随着中心的接近，这些曲率最终会消失)。




<h4>How it works</h4>

在一个有一条曲线和三条直线的圆盘的简单情况下，我们可以明确写下如何实现形状的混合。为此，将物理单元（如顶部的单元）映射回参考坐标系 $(\xi,\eta)\in (0,1)^2$ 是很有用的，在那里我们计算某些点之间的平均数。如果我们使用一个由四个顶点 $(x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)$ 跨越的简单双线性地图，一个点 $(\xi, \eta)\in (0,1)^2$ 的图像将是

@f{align*}{
(x,y) = (1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) +
       (1-\xi)\eta  (x_2,y_2) + \xi\eta  (x_3,y_3).


@f}



对于曲面的情况，我们要修改这个公式。对于圆盘粗略网格的顶部单元，我们可以假设点 $(x_0,y_0)$ 和 $(x_1,y_1)$ 位于下端的直线上，点 $(x_2,y_2)$ 和 $(x_3,y_3)$ 沿顶部由一个四分之一圆连接。然后我们将点 $(\xi, \eta)$ 映射为

@f{align*}{
(x,y) = (1-\eta) \big[(1-\xi) (x_0,y_0) + \xi (x_1,y_1)\big] +
      \eta \mathbf{c}_3(\xi),


@f}

其中 $\mathbf{c}_3(\xi)$ 是一条曲线，用一个arclength参数 $\xi\in (0,1)$ 来描述四分之一圆的 $(x,y)$ 坐标。这代表了单元格的直线下边缘和曲线上边缘之间的线性插值，也是上图的基础。

这个公式很容易被推广到所有四条边都由曲线而不是直线描述的情况。我们称这四个函数为 $\xi$ 或 $\eta$ ，在水平和垂直方向上，分别为四边形的左、右、下和上边缘的参数。然后，内插法为

@f{align*}{
(x,y) =& (1-\xi)\mathbf{c}_0(\eta) + \xi \mathbf{c}_1(\eta)
        +(1-\eta)\mathbf{c}_2(\xi) + \eta \mathbf{c}_3(\xi)\\
       &-\big[(1-\xi)(1-\eta) (x_0,y_0) + \xi(1-\eta) (x_1,y_1) +
        (1-\xi)\eta  (x_2,y_2) + \xi\eta  (x_3,y_3)\big].


@f}



这个公式假设边界曲线与顶点 $(x_0,y_0), (x_1,y_1), (x_2,y_2), (x_3, y_3)$ ，例如 $\mathbf{c}_0(0)
= (x_0,y_0)$ 或 $\mathbf{c}_0(1) = (x_2,y_2)$ 匹配和重合。公式第二行的双线性插值的减法确保了在边界上完全遵循规定的曲线：沿着四条边中的每一条，我们需要减去在角上评估的两条相邻边的贡献，这时的贡献只是一个顶点位置。很容易检查出，如果四条曲线中的三条 $\mathbf{c}_i$ 是直的，从而与双线性插值重合，那么上面的圆的公式就再现了。

这个公式被称为转折内插，由<a
href="https://doi.org/10.1002%2Fnme.1620070405">Gordon and Hall</a>在1973年提出。尽管转义插值本质上只表示边界曲线的线性混合，但插值完全遵循每个实数 $\xi\in (0,1)$ 或 $\eta\in (0,1)$ 的边界曲线，也就是说，它插值的点数是无限的，这也是Gordon和Hall将这种插值的变体称为转义插值的最初动机。另一种解释是，无限插值从左右和上下线性插值，我们需要从中减去双线性插值，以确保在域的内部有一个单位重量。

无限插值很容易被推广到三个空间维度。在这种情况下，插值允许为一个三维单元的任何一个四边形混合6种不同的表面描述，为一个单元的线混合12种边缘描述。同样，为了确保地图的一致性，有必要减去边缘的贡献，再加上顶点的贡献，使曲线遵循规定的表面或边缘描述。在三维的情况下，也可以使用从曲线边缘到相邻面和相邻单元的转折插值。

在处理.II中的转置插值是通用的，因为它可以处理任意的曲线。它将以 $d$ -维空间的原始坐标来评估曲线，但有一个（或两个，在三维的边缘情况下）坐标固定在 $0$ 或 $1$ ，以确保任何其他流形类，包括CAD文件（如果需要），都可以应用于开箱。无限插值是网格生成器的标准成分，因此在deal.II库中集成这一功能的主要优势是在自适应细化和粗化网格时启用，以及用于创建更高程度的映射，使用流形来插入网格顶点以外的额外点。

关于无限插值的最后一句话，我们提到在没有体积流形描述的情况下，deal.II中的网格细化策略也是基于无限插值的权重，在这个意义上是最优的。不同的是，默认算法一次只看到一个单元，因此将只对那些接触曲面流形的单元应用最优算法。相反，在整个<i>patches</i>个单元上使用转义映射（源于一个较粗的单元），可以用转义插值法，将信息从边界传播到远处的单元。




<h3>Transfinite interpolation is expensive and how to deal with it</h3>

一个具有无限流形描述的网格通常分两步建立。第一步是创建一个粗略的网格（或者从文件中读入），并在一些网格实体上附加一个曲面流形。对于上面的圆盘例子，我们将极坐标流形附加到沿外圆的面（这是由 GridGenerator::hyper_ball()). 自动完成的）在我们开始细化网格之前，我们再为网格的所有内部单元和边缘分配一个TransfiniteInterpolationManifold，当然，这需要基于我们分配给这些实体的一些流形ID（除了边界上的圆以外的一切）。我们是否也给圆盘的内部正方形分配一个TransfiniteInterpolationManifold并不重要，因为对具有直边（或3D中的平坦面）的粗单元进行Transfinite插值，只是产生具有直边（平坦面）的细分子。

之后，当网格被细化或基于此网格建立高阶映射时，单元将查询底层流形对象的新点。这个过程需要一组周围的点，例如一个二维单元的四个顶点，以及一组对这些点的权重，用于定义一个新的点。对于一个单元格的中间点，四个顶点中的每一个都将得到0.25的权重。对于无限插值流形，建立加权和的过程需要一些严肃的工作。根据结构，我们要根据周围点的参考坐标 $\xi$ 和 $\eta$ （或三维的 $\xi, \eta, \zeta$ ）来组合这些点。然而，deal.II中流形类的接口并没有得到周围点的参考坐标（因为它们不是全局存储的），而只是物理坐标。因此，无限插值流形必须做的第一步是反转映射，并在无限插值的一个粗网格单元内找到参考坐标（例如，上述磁盘网格的四个阴影粗网格单元之一）。这种反演是通过牛顿迭代（或者说，基于有限差分的牛顿方案与布罗伊登方法相结合）完成的，并根据上述公式多次查询无限期插值。这些查询中的每一次都可能依次调用一个昂贵的流形，例如球的球形描述，并且本身就很昂贵。由于deal.II的Manifold接口类只提供了一组点，所以转置插值最初甚至不知道周围的点集属于哪个粗大的网格单元，需要根据一些启发式方法在几个单元中搜索。就<a
href="https://en.wikipedia.org/wiki/Atlas_(topology)#Charts">charts</a>而言，我们可以把无限插值的实现描述为基于<a
href="https://en.wikipedia.org/wiki/Atlas_(topology)">atlas</a>的实现。三角形初始粗网格的每个单元都代表一个有自己参考空间的图表，而周围的流形提供了一种从图表空间（即参考单元）到物理空间的转换方式。粗网格单元的图表的集合是一个图集，像往常一样，在图集中查找东西时，人们做的第一件事就是找到正确的图表。

一旦找到周围点的参考坐标，参考坐标系中的新点将通过简单的加权和计算出来。最后，参考点被插入到无限插值的公式中，这就得到了所需的新点。

在许多情况下，曲面流形不仅在网格细化过程中使用，而且还用于确保计算域单元内边界的曲面表示。这对于保证复杂几何上的高阶多项式的高阶收敛性是必须的，但有时对于线性形状函数也需要一个精确的几何。这通常是通过对单元的多项式描述来实现的，如果表示曲面网格元素的多项式程度与数值解的多项式程度相同，则称为等参数概念。如果几何体的度数高于或低于解的度数，则分别称为超参数或次参数的几何体表示。在deal.II中，多项式表示的标准类是MappingQGeneric。例如，如果在三维中使用这个类的多项式度数 $4$ ，总共需要125个（即 $(4+1)^3$ ）点来进行内插。在这些点中，8个是单元的顶点，已经可以从网格中获得，但其他117个点需要由流形提供。如果使用无限插值流形，我们可以想象，通过回拉到一些尚未确定的粗略单元的参考坐标，然后在117个点中的每个点上进行后续的前推，是一个大量的工作，可能非常耗时。

更糟糕的是，许多程序的结构是这样的：对于同一个单元，映射被独立地查询了几次。它的主要用途是组装线性系统，即通过FEValues对象的`mapping`参数计算系统矩阵和右手边。然而，边界值的插值、数值误差的计算、输出的写入以及误差估计器的评估也必须涉及相同的映射，以确保对解向量的一致解释。因此，即使是解决一次的线性静止问题，也会多次评估映射的点。对于上面提到的三维案例，这意味着通过昂贵的算法多次计算每个单元的117个点。对于非线性或随时间变化的问题，情况更加紧迫，这些操作要反复进行。

由于通过无限插值进行流形描述的成本比对平流形的类似查询要高几百倍，所以只计算一次额外的点并在所有后续调用中使用这些点是有意义的。deal.II库提供的MappingQCache类正是为了这个目的。与系统矩阵所消耗的内存相比，这个缓存通常不会太大，在看这个教程程序的结果时就会明白。MappingQCache的用法很简单。一旦网格被设置好（或在细化过程中被改变），我们就调用 MappingQCache::initialize() ，将所需的三角形以及所需的映射作为参数。然后，初始化会遍历网格的所有单元，并查询给定映射的附加点。这些点会被保存为单元的标识符，以便以后当映射计算一些与单元相关的量（如参考坐标和物理坐标之间的映射的Jacobian）时，它们可以被返回。

最后，我们提到，TransfiniteInterpolationManifold也使得网格的细化变得更加昂贵。在这种情况下，MappingQCache无济于事，因为它将计算随后不能再使用的点；目前在deal.II中不存在一个更有效的机制。然而，网格细化也包含许多其他昂贵的步骤，所以与其他计算相比，它并不是一个大问题。它在每个时间步长或非线性迭代中也最多只发生一次。

<h3>The test case</h3>

在这个教程程序中，TransfiniteInterpolationManifold与MappingQCache的结合被举例说明。这个测试案例相对简单，占用了许多典型程序中涉及的解决阶段，例如步骤6的教程程序。作为一个几何体，我们选择了TransfiniteInterpolationManifold的一个使用原型，即涉及一个球形的设置，而这个球形又被一个立方体所包围。例如，这样的设置将用于嵌入背景介质中的球形包容物，如果该包容物具有不同的材料特性，需要通过元素界面来跟踪两种材料之间的界面。这里给出了一个可视化的网格。

 <img src="https://www.dealii.org/images/steps/developer/step-65-mesh.png" alt=""> 

对于这种情况，我们要在域内的表面附加一个球形描述，并使用转折插值来平滑地切换到外部立方体的直线和球中心的立方体。

在该程序中，我们将遵循有限元程序的典型流程，从DoFHandler和稀疏模式的设置开始，组装一个线性系统来解决带有跳跃系数的泊松方程，用一个简单的迭代方法解决，用 VectorTools::integrate_difference() 计算一些数值误差以及误差估计器。我们记录了每个部分的时间，并运行了两次代码。在第一次运行中，我们将一个MappingQGeneric对象分别交给程序的每个阶段，在这些阶段中，点被反复计算。在第二次运行中，我们用MappingQCache代替。


