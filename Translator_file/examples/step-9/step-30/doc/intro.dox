examples/step-30/doc/intro.dox

<a name="Intro"></a>

<h1>Introduction</h1>




<h3>Overview</h3>

这个例子专门讨论 <em> 各向异性细化 </em> ，它扩展到局部细化的可能性。在大多数情况下，这是对step-12教程程序的修改，我们使用相同的DG方法处理线性输运方程。这个程序将涵盖以下主题。<ol>  <li>   <em>  各向异性细化  </em>  : 各向异性细化的含义是什么？     <li>   <em>  实现  </em>  ：对代码进行必要的修改，以便与各向异性的细化网格一起工作。     <li>   <em>  跳跃指标  </em>  : 在DG方法中，各向异性细化的一个简单指标。   </ol>  将不讨论离散化本身，也不讨论这里使用的非各向异性细化的实施技术。这一点请参考步骤12。

请注意，在编写这个教程程序的时候，各向异性的细化只在不连续的Galerkin有限元中完全实现。这一点以后可能会改变（或者已经改变）。




 @note  虽然这个程序是对step-12的修改，但它是在deal.II历史上早期写的step-12的一个版本，当时MeshWorker框架还没有出现。因此，它与现在的step-12几乎没有任何相似之处，除了它以相同的离散化方式求解相同的方程。




<h3>Anisotropic refinement</h3>

在前面的教程程序中，所有的适应过程都是基于 <em> 各向同性 </em> 细化单元，它将所有的边切成两半，并将这些分割的边形成新的单元（当然，还要加上一些额外的边、面和顶点）。在deal.II中， <em> 各向异性细化 </em> 指的是只分割部分边而不改变其他边的过程。例如，考虑一个简单的方形单元。

@code
  *-------*
  |       |
  |       |
  |       |
  *-------*
@endcode

经过通常的细化，它将由四个孩子组成，看起来像这样。

@code
  *---*---*
  |   |   |
  *---*---*     RefinementCase<2>::cut_xy
  |   |   |
  *---*---*
@endcode

新的各向异性细化可能有两种形式：一是我们可以将平行于水平X轴的边缘分割开来，形成这两个子单元。

@code
  *---*---*
  |   |   |
  |   |   |     RefinementCase<2>::cut_x
  |   |   |
  *---*---*
@endcode

或者我们可以拆分沿y轴运行的两条边，再次产生两个孩子，不过，看起来是这样的。

@code
  *-------*
  |       |
  *-------*     RefinementCase<2>::cut_y
  |       |
  *-------*
@endcode

所有单元的细化情况都由枚举 RefinementPossibilities::Possibilities, 来描述，上述各向异性情况被称为 @p cut_x 和 @p cut_y ，原因很明显。各向同性的细化情况在二维中被称为 @p cut_xy ，可以通过 RefinementCase<dim>::isotropic_refinement. 从细化案例类中请求。

在三维中，有第三个轴可以被分割，即z轴，因此我们在这里有一个额外的细化案例 @p cut_z 。各向同性的细化现在将沿x轴、y轴和z轴细化一个单元，因此被称为 @p  cut_xyz。另外还有 @p cut_xy,  @p cut_xz 和 @p cut_yz 的情况，它们沿两个轴精化单元，但不沿第三个轴精化。给出一个六面体单元，X轴向右，Y轴 "进入页面"，Z轴在顶部。

@code
      *-----------*
     /           /|
    /           / |
   /           /  |
  *-----------*   |
  |           |   |
  |           |   *
  |           |  /
  |           | /
  |           |/
  *-----------*
@endcode

我们有各向同性的细化情况。

@code
      *-----*-----*
     /     /     /|
    *-----*-----* |
   /     /     /| *
  *-----*-----* |/|
  |     |     | * |
  |     |     |/| *
  *-----*-----* |/
  |     |     | *
  |     |     |/
  *-----*-----*


  RefinementCase<3>::cut_xyz
@endcode

三种各向异性的情况，只细化一个轴。

@code
      *-----*-----*             *-----------*             *-----------*
     /     /     /|            /           /|            /           /|
    /     /     / |           *-----------* |           /           / |
   /     /     /  |          /           /| |          /           /  *
  *-----*-----*   |         *-----------* | |         *-----------*  /|
  |     |     |   |         |           | | |         |           | / |
  |     |     |   *         |           | | *         |           |/  *
  |     |     |  /          |           | |/          *-----------*  /
  |     |     | /           |           | *           |           | /
  |     |     |/            |           |/            |           |/
  *-----*-----*             *-----------*             *-----------*


  RefinementCase<3>::cut_x  RefinementCase<3>::cut_y  RefinementCase<3>::cut_z
@endcode

和三个案例，它们完善了三个轴中的两个。

@code
      *-----*-----*             *-----*-----*             *-----------*
     /     /     /|            /     /     /|            /           /|
    *-----*-----* |           /     /     / |           *-----------* |
   /     /     /| |          /     /     /  *          /           /| *
  *-----*-----* | |         *-----*-----*  /|         *-----------* |/|
  |     |     | | |         |     |     | / |         |           | * |
  |     |     | | *         |     |     |/  *         |           |/| *
  |     |     | |/          *-----*-----*  /          *-----------* |/
  |     |     | *           |     |     | /           |           | *
  |     |     |/            |     |     |/            |           |/
  *-----*-----*             *-----*-----*             *-----------*


  RefinementCase<3>::cut_xy RefinementCase<3>::cut_xz RefinementCase<3>::cut_yz
@endcode

对于一维问题，各向异性的细化不会产生任何影响，因为一个单元只有一个坐标方向，所以除了各向同性外，不可能以任何其他方式分割。

<h4>Motivation</h4>自适应局部细化是用来获得很好地适应有效解决手头问题的细网格。简而言之，产生较大误差的单元的尺寸被减小，以获得手头问题的更好的近似解。然而，很多问题都含有各向异性的特征。突出的例子是可压缩粘性流动中的冲击或边界层。一个有效的网格可以用较高长宽比的单元来逼近这些特征，而这些单元是根据上述特征定向的。只使用各向同性的细化，原始网格单元的长宽比会被保留下来，因为它们会被单元的子代所继承。因此，从各向同性的网格开始，边界层将被细化，以捕捉壁面法线方向上流场的快速变化，从而导致在法线和切线方向上都具有非常小的边缘长度的单元。通常情况下，在切线方向上的边长要大得多，因此可以使用更少的单元，而不会在近似精度上有明显的损失。各向异性的细化过程可以在每个细化步骤中把母细胞和子细胞的长宽比修改为两个系数。在多次细化的过程中，细单元的长宽比可以得到优化，从而节省了相当数量的单元和相应的自由度，从而节省了计算资源、内存以及CPU时间。

<h3>Implementation</h3>

大多数时候，当我们进行有限元计算时，我们一次只考虑一个单元，例如计算单元对全局矩阵的贡献，或插值边界值。然而，有时我们不得不看一下单元在我们的算法中是如何关联的。单元之间的关系有两种形式：邻居关系和母子关系。对于各向同性的细化情况，deal.II对始终保持的单元格关系使用了某些约定（不变量）。例如，一个细化的单元总是正好有 $2^{dim}$ 个子女。而且（除了1d情况），两个相邻的单元格最多可以相差一个细化级别：它们同样经常被细化，或者其中一个正好再被细化一次，在共同面上正好留下一个悬挂的节点。几乎所有的时候，这些不变量都只在库的内部实现中被关注。然而，在有些情况下，对它们的了解也与应用程序有关。

在当前情况下，值得注意的是，网格细化的种类会影响一些最基本的假设。因此，在应用程序中发现的一些常规代码将需要修改，以利用使用各向异性细化创建的网格的特征。对于那些对deal.II如何演变感兴趣的人来说，可能会感兴趣的是，这种不变量的松动需要一些不兼容的变化。例如，库中曾经有一个成员 GeometryInfo<dim>::children_per_cell ，规定一个单元一旦被细化后有多少个孩子。对于各向同性的细化，这个数字等于  $2^{dim}$  ，如上所述。然而，对于各向异性的细化，这个数字并不存在，因为在二维中可以是2或4，在三维中可以是2、4或8，因此成员 GeometryInfo<dim>::children_per_cell 已经被删除。它现在已经被 GeometryInfo<dim>::max_children_per_cell 所取代，后者指定了一个单元格可以有的<i>maximum</i>个子嗣。一个细化的单元有多少个子代以前是作为静态信息提供的，但现在它取决于一个单元的实际细化状态，可以使用 TriaAccessor::n_children(), 检索，这个调用对各向同性和各向异性的细化都同样有效。对于面和它们的子面也有非常类似的情况：相关的信息可以使用 GeometryInfo<dim>::max_children_per_face 或 <code>face->n_children()</code> 进行查询，这取决于上下文。

另一个重要的方面，也是本教程中最重要的方面，是在组装单元格之间的面的跳跃项时对邻居关系的处理。在步骤12中查看assemble_system函数的文档，我们注意到，我们需要决定一个相邻的单元是否更粗、更细或者与我们当前的单元处于同一（细化）水平。这些决定对于各向异性的细化并不适用，因为细胞的 <em> 级 </em> 所提供的信息并不足以完全描述各向异性的细胞；例如，一个二维细胞的终端子女是否首先在 $x$ 方向切割的二维单元，其子女随后在 $y$ 方向切割时是在第2层，还是在第1层，因为如果该单元被各向同性地精炼一次，就会产生同一组最好的单元？

在各向异性的细化之后，一个更粗的邻居不一定正好比我们低一个级别，而是几乎可以有相对于当前级别的任何级别；事实上，它甚至可以在一个更高的级别上，尽管它更粗。因此，必须在不同的基础上做出决定，而决定的意图却保持不变。

在下文中，我们将讨论当我们想计算对矩阵（或右手边）的贡献时可能发生的情况，其形式为

@f[
  \int_{\partial K} \varphi_i(x) \varphi_j(x) \; dx


@f]

或类似的；记住，我们使用FEFaceValues和FESubfaceValues类来整合这样的条款。我们还将展示如何编写适用于各向同性和各向异性细化的代码。

 <ul> 

    <li>   <em>  更精细的邻居  </em>  ：如果我们在一个活动单元上，想要整合到一个面  $f\subset \partial K$  上，第一个可能性是这个面后面的邻居更精细，即有孩子只占据了共同面的一部分。在这种情况下，所考虑的面必须是一个精致的面，这可以通过询问  <code>if (face->has_children())</code>  来确定。如果这是真的，我们需要在所有的子面中循环，得到这个子面后面的邻居的孩子，这样我们就可以用邻居重新输入一个FEFaceValues对象，用我们的单元格和相应的子面重新输入一个FESubfaceValues对象。

  对于各向同性的细化，这种情况相当简单，因为我们知道，在deal.II中，各向同性细化的自适应网格的一个不变性是，邻居只能正好相差一个细化等级。然而，对于各向异性细化的网格来说，这并不完全正确，特别是在三维中；在那里，我们感兴趣的位于 $f$ 另一侧的活动单元实际上可能不是我们邻居的孩子，而可能是孙子甚至是更远的后代。幸运的是，这种复杂性被隐藏在库的内部。我们所要做的就是调用 CellAccessor::neighbor_child_on_subface() 函数。尽管如此，在3D中，有两种情况需要特别考虑。     <ul>   <li>  如果邻居被各向异性地细化了一次以上，可能这里需要考虑的不是两个或四个而是三个子面。想象一下我们正在考虑的（三维）邻接单元的（二维）面的以下细化过程：首先该面沿x方向细化，后来只沿y方向细化左侧子面。

@code
   *-------*        *---*---*        *---*---*
   |       |        |   |   |        |   |   |
   |       |  --->  |   |   |  --->  *---*   |
   |       |        |   |   |        |   |   |
   *-------*        *---*---*        *---*---*
@endcode

     这里子脸的数量是三个。需要注意的是，对于一个面， TriaAccessor::n_children() 和 TriaAccessor::n_active_descendants(). 之间的细微差别。第一个函数返回直系子女的数量，在上面的例子中是两个，而第二个函数返回活动后代的数量（即，包括子女、孙子和进一步的后代），在上面的例子中是正确的三个。使用 <code>face->n_active_descendants()</code> 对各向同性和各向异性以及二维和三维情况都有效，所以应该始终使用它。应该注意的是，如果最右边图像左侧的两个小子面后面的任何一个单元被进一步细化，那么当前的单元（即我们从这个共同面看的那一面）也要被细化：之所以这样，是因为否则就会违反每条边只有一个悬挂节点的不变量。

      <li> 可能是，邻居比较粗，但仍有比我们当前单元更细的孩子。如果两个同样粗糙的单元被细化，其中一个单元在所考虑的面有两个孩子，另一个有四个孩子，这种情况就会发生。下图中的单元格只是相互分离，以显示各个细化的情况。

@code
      *-----------*     *-----------*
     /           /|    /           /|
    ############# |   +++++++++++++ |
   #           ## |  +           ++ *
  ############# # | +++++++++++++ +/|
  #           # # | +           + + |
  #           # # * +           +++ *
  #           # #/  +++++++++++++ +/
  #           # #   +           + +
  #           ##    +           ++
  #############     +++++++++++++
@endcode



  这里，左边的两个单元是在 $y$ -方向上对母单元进行各向异性分割的结果，而右边的四个单元是在 $y$  -和 $z$ -方向上同时进行各向异性细化的结果。   标有#的左边单元有两个标有+的更细的邻居，但左边单元的实际邻居是完整的右边母单元，因为标有+的两个单元更细，它们的直接母体是一个大单元。     </ul> 

  然而，幸运的是， CellAccessor::neighbor_child_on_subface() 可以自己处理这些情况，如果你在正确的子界面数量上循环，在上面的例子中，这是两个。 FESubfaceValues<dim>::reinit 函数也会照顾到这一点，因此，结果的状态总是正确的。然而，有一个小的注意事项。为了重新调用邻居的FEFaceValues对象，你需要知道指向当前单元格的面的索引。通常你会假设你直接得到的邻居和你一样粗或细，如果它有孩子的话，因此这个信息可以通过 CellAccessor::neighbor_of_neighbor(). 得到，然而如果邻居比较粗，你就必须使用 CellAccessor::neighbor_of_coarser_neighbor() 中的第一个值来代替。为了方便你，有一个 CellAccessor::neighbor_face_no() 可以为你做正确的事情，并返回所需的结果。

    <li>   <em>  邻居和我们的单元格一样细  </em>  ：在我们排除了所有存在更细的子代的情况后，我们只需要决定，邻居是否在这里更粗。为此，有一个 CellAccessor::neighbor_is_coarser() 函数，返回一个布尔值。为了得到相同粗度的邻居的相关情况，我们将使用  <code>else if (!cell->neighbor_is_coarser(face_no))</code>  。这个块里面的代码可以不动。然而，这里有一件事要提到。如果我们想使用一个规则，哪个单元应该在一个给定的面上组合某些条款，我们可以考虑步骤12中提出的规则。我们知道，我们必须舍弃将我们的单元格的水平与邻居的水平进行比较的部分，而用上面提出的对较粗的邻居的测试来取代。然而，我们也必须考虑到具有相同粗度的相邻单元具有相同指数（在不同水平上）的可能性。因此，我们必须包括单元格具有相同索引的情况，并给出一个额外的条件，即哪一个单元格应该集合条款，例如，我们可以选择较低层次的单元格。这个概念的细节可以在下面的实现中看到。

    <li>   <em>  较粗的邻居  </em>  ：剩下的情况很明显：如果没有精炼的邻居，而且邻居不像当前单元那么细，那么它一定是较粗的。因此我们可以留下旧的条件短语，简单地使用  <code>else</code>  。 CellAccessor::neighbor_of_coarser_neighbor() 函数照顾到各向异性细化的所有复杂性，结合一般三维网格上可能的非标准面的方向、翻转和旋转。

 </ul> 

<h4>Mesh smoothing</h4> 当一个三角形被细化时，没有被标记为细化的单元可能仍然被细化。这是由于额外的平滑算法，这些算法是必要的或明确要求的。特别是，在每条边上最多有一个悬空节点的限制，经常迫使邻近已经很细的单元的额外单元被细化，并被标记为进一步细化。

然而，deal.II也实现了一些算法，以确保得到的网格比最低限度的平滑，例如，确保没有孤立的精化单元被非精化单元所包围，因为这些岛屿上的额外自由度几乎都会受到悬挂节点的约束。关于网格平滑的更多信息，请参见三角形类及其 Triangulation::MeshSmoothing 成员的文档）。

大多数最初为各向同性情况开发的平滑算法已经被调整为以非常相似的方式用于各向异性和各向同性的细化工作。然而，有两种算法值得一提。<ol>  <li>   <code>MeshSmoothing::limit_level_difference_at_vertices</code>  : 在各向同性的环境中，该算法试图通过减少在共同顶点相遇的单元的细化水平差异来确保良好的近似质量。然而，对于各向异性的细化没有明确的对应概念，因此该算法不能与各向异性的细化结合使用。这个限制是由一个断言强制执行的，一旦在一个已经被各向异性细化的三角形上调用该算法，就会抛出一个错误。

    <li>   <code>MeshSmoothing::allow_anisotropic_smoothing</code>  : 如果引入细化来限制悬空节点的数量，往往不需要额外的单元来提高近似质量。这对DG方法来说尤其如此。如果你设置了标志 <code>allow_anisotropic_smoothing</code> ，平滑算法试图通过使用各向异性的细化来尽量减少可能不需要的额外单元的数量。如果你设置了这个平滑标志，你可能会得到各向异性的细化单元，即使你从未将一个细化标志设置为各向异性的细化。请注意，如果你的代码尊重各向异性网格的可能性，你只应该使用这个标志。结合一个合适的各向异性指标，这个标志可以帮助节省额外的单元，从而节省精力。   </ol> 




<h3>Jump indicator</h3>

利用各向异性细化的好处，需要一个指标来捕捉溶液的各向异性特征，并利用它们来进行细化过程。一般来说，各向异性的细化过程将包括几个步骤。<ol>  <li>  计算一个误差指标。     <li>  使用误差指标来标记单元进行细化，例如使用固定数量或分数的单元。这些单元将被自动标记为各向同性的细化。     <li>  只在被标记的单元上评估一个明显的各向异性指标。     <li>  使用各向异性指标为合适的单元设置一个新的各向异性细化标志，否则保持标志不变。     <li>  调用 Triangulation<dim>::execute_coarsening_and_refinement 来执行要求的细化，使用要求的各向同性和各向异性标志。   </ol>  这种方法类似于我们在步骤27中用于hp-细化的方法，具有很大的灵活性优势。任何误差指标都可以在各向异性过程中使用，也就是说，如果你有相当多的后验目标导向的误差指标可用，你可以像使用简单的凯利误差估计器一样方便地使用它们。精细化过程的各向异性部分不受这种选择的影响。此外，只要省去第三和第四步，就可以得到与你在deal.II或你的应用程序中的任何各向异性变化之前相同的各向异性的细化结果。作为最后一个优点，只对标记为细化的单元进行工作会使各向异性指标的评估更快，如果指标涉及很多单元的话，这在有很多单元的细网格上会变得很明显。

在这里，我们使用一个非常简单的方法，它只适用于DG方法。一般的想法是非常简单的。DG方法允许离散解在一个单元的面上跳跃，而在每个单元内是平滑的。当然，在极限情况下，我们期望随着我们对网格的细化和对真实解的近似程度越来越高，跳跃会趋于零。因此，在一个给定的面的大跳跃表明该单元应该被细化（至少是）正交于该面，而小跳跃则不会导致这一结论。当然，有可能确切的解决方案并不平滑，它也有跳跃的特征。然而，在这种情况下，一个面的大跳跃表明，这个面或多或少地与跳跃平行，并且在它的附近，因此我们再次期望与所考虑的面正交的细化是有效的。

所提出的指标计算平均跳跃 $K_j$ ，即离散解 $u$ 在单元格上与坐标方向 $f_i^j$ 、 $i=1,2$ 、 $j=1..d$ 正交的两个面上绝对跳跃 $|[u]|$ 的平均值。

@f[
K_j = \frac{\sum_{i=1}^2 \int_{f_i^j}|[u]| dx}{\sum_{i=1}^2 |f_i^j|} .


@f]

如果一个方向的平均跳动比其他方向的跳动的平均值大一定的系数 $\kappa$ ，即如果 $K_i > \kappa \frac 1{d-1} \sum_{j=1, j\neq i}^d K_j$ ，则该单元只沿该特定方向进行细化 $i$ ，否则该单元是各向同性细化的。

这样的标准很容易被推广到方程组：跳跃的绝对值将被矢量值跳跃的适当规范所取代。




<h3>The problem</h3>

我们解决步骤12中提出的线性传输方程。域被扩展到覆盖二维的 $[-1,1]\times[0,1]$ ，其中流场 $\beta$ 在域的右半部描述了一个围绕原点的逆时针四分之一圆，在域的左半部平行于x轴。流入边界再次位于 $x=1$ 处，并沿x轴的正向部分，边界条件选择与步骤12相同。


