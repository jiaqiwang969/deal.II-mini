examples/step-11/doc/results.dox



<h1>Results</h1>

这是该程序的输出结果。

@code
Using mapping with degree 1:
============================
cells  |u|_1    error
    5 0.680402 0.572912
   20 1.088141 0.165173
   80 1.210142 0.043172
  320 1.242375 0.010939
 1280 1.250569 0.002745
 5120 1.252627 0.000687


Using mapping with degree 2:
============================
cells  |u|_1    error
    5 1.177062 0.076252
   20 1.228978 0.024336
   80 1.245175 0.008139
  320 1.250881 0.002433
 1280 1.252646 0.000668
 5120 1.253139 0.000175


Using mapping with degree 3:
============================
cells  |u|_1    error
    5 1.193493 0.059821
   20 1.229825 0.023489
   80 1.245221 0.008094
  320 1.250884 0.002430
 1280 1.252646 0.000668
 5120 1.253139 0.000175
@endcode

正如我们所期望的，每个不同的映射的收敛顺序显然是与网格大小成二次方的。不过 <em> 有趣的是，双线性映射（即1度）的误差比高阶映射的误差大三倍以上；因此在这种情况下，使用高阶映射显然是有利的，不是因为它提高了收敛顺序，而只是为了减少收敛顺序前的常数。另一方面，除了在非常粗的网格上，使用立方体映射只能进一步改善结果，幅度微乎其微。

我们还可以通过使用例如ParaView来可视化底层网格。下面的图片显示了不同映射度的初始网格。

 <img src="https://www.dealii.org/images/steps/developer/step-11.cycle_0.png" alt=""> 

显然，当我们从线性映射到二次映射时，这种影响是最明显的。这也反映在上表中给出的误差值中。从二次方到三次方的效果没有那么明显，但由于对圆形边界的描述更加准确，所以还是很明显的。

接下来，让我们看看三次全局细化后的网格

 <img src="https://www.dealii.org/images/steps/developer/step-11.cycle_3.png" alt=""> 

在这里，差异就不那么明显了，特别是对于高阶映射。事实上，在这个细化水平上，表格中报告的误差值在二度和三度的映射之间基本上是相同的。


