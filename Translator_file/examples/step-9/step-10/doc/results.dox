examples/step-10/doc/results.dox



<h1>Results</h1>


该程序执行两个任务，第一个是生成映射域的可视化，第二个是通过所述的两种方法计算π。让我们先看一下生成的图形。它们是以Gnuplot格式生成的，可以用以下命令查看

@code
set style data lines
set size ratio -1
unset key
unset xtics
unset ytics
plot [-1:1][-1:1] "ball_0_mapping_q_1.dat" lw 4 lt rgb "black"
@endcode

或使用其他文件名之一。第二行确保生成的输出的长宽比实际上是1:1，也就是说，一个圆在你的屏幕上被画成一个圆，而不是一个椭圆。第三行关闭了图形中的键，因为那只会打印信息（文件名），而这些信息现在并不那么重要。同样地，第四行和第五行关闭了刻度线。然后生成具有特定线宽（"lw"，这里设置为4）和线型（"lt"，这里选择线应使用RGB颜色 "黑色"）的图。

下表显示了 $Q_1$ 、 $Q_2$ 和 $Q_3$ 映射的三角计算域，为原始粗网格（左）和一次均匀细化网格（右）。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_0_q1.svg" alt="磁盘的五单元离散化。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_1_q1.svg" alt="磁盘的20单元离散化（即。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_0_q2.svg" alt="五格离散化的圆盘，边缘为二次方。边界与实际的圆几乎没有区别。" width="400" height="400" > </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_1_q2.svg" alt="带有二次方边缘的20个单元离散化。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_0_q3.svg" alt="带有三次方边缘的圆的五单元离散化。边界与实际的圆几乎没有区别。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_ball_1_q3.svg" alt="具有立方体边缘的20单元离散化。" width="400" height="400"> </div> </div>

这些图片显示了高阶映射的明显优势：它们在相当粗的网格上也能相当好地接近真实边界。为了进一步证明这一点，这里是使用 $Q_2$ 和 $Q_3$ 映射的粗网格的右上角四分之一圈的一部分，其中红色虚线标志着实际的圆。

<div class="twocolumn" style="width: 80%"> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_exact_vs_interpolate_q2.svg" alt="二次离散化的特写。二次插值和实际圆之间的距离很小。" width="400" height="400"> </div> <div> <img src="https://www.dealii.org/images/steps/developer/step_10_exact_vs_interpolate_q3.svg" alt="立方离散化的特写。立体插值和实际圆之间的距离非常小。" width="400" height="400"> </div> </div> </div>

很明显，二次映射很好地接近了边界，而对于三次映射来说，对于粗略的网格来说，近似域和真实域之间的差异已经很难看到了。你还可以看到，映射只在三角形的外部边界有一些变化。在内部，所有的线条仍然是由线性函数表示的，这就导致了只在边界的单元上进行额外的计算。因此，高阶映射通常不会比低阶映射明显地慢，因为额外的计算只在所有单元格的一个小子集上执行。




该程序的第二个目的是计算π的值，以达到良好的准确性。这是程序的这一部分的输出。

@code
Output of grids into gnuplot files:
===================================
Refinement level: 0
Degree = 1
Degree = 2
Degree = 3


Refinement level: 1
Degree = 1
Degree = 2
Degree = 3


Computation of Pi by the area:
==============================
Degree = 1
cells      eval.pi            error
    5 1.9999999999999993 1.1416e+00    -
   20 2.8284271247461890 3.1317e-01 1.87
   80 3.0614674589207174 8.0125e-02 1.97
  320 3.1214451522580511 2.0148e-02 1.99
 1280 3.1365484905459380 5.0442e-03 2.00
 5120 3.1403311569547516 1.2615e-03 2.00


Degree = 2
cells      eval.pi            error
    5 3.1045694996615860 3.7023e-02    -
   20 3.1391475703122267 2.4451e-03 3.92
   80 3.1414377167038290 1.5494e-04 3.98
  320 3.1415829366419006 9.7169e-06 4.00
 1280 3.1415920457576898 6.0783e-07 4.00
 5120 3.1415926155921117 3.7998e-08 4.00


Degree = 3
cells      eval.pi            error
    5 3.1410033851499288 5.8927e-04    -
   20 3.1415830393583839 9.6142e-06 5.94
   80 3.1415925017363797 1.5185e-07 5.98
  320 3.1415926512106696 2.3791e-09 6.00
 1280 3.1415926535525927 3.7200e-11 6.00
 5120 3.1415926535892100 5.8302e-13 6.00


Degree = 4
cells      eval.pi            error
    5 3.1415871927401131 5.4608e-06    -
   20 3.1415926314742428 2.2116e-08 7.95
   80 3.1415926535026202 8.7173e-11 7.99
  320 3.1415926535894498 3.4350e-13 7.99
 1280 3.1415926535897896 3.4671e-15 6.63
 5120 3.1415926535897909 2.4009e-15 0.53


Computation of Pi by the perimeter:
===================================
Degree = 1
cells      eval.pi            error
    5 2.8284271247461898 3.1317e-01    -
   20 3.0614674589207178 8.0125e-02 1.97
   80 3.1214451522580520 2.0148e-02 1.99
  320 3.1365484905459389 5.0442e-03 2.00
 1280 3.1403311569547525 1.2615e-03 2.00
 5120 3.1412772509327724 3.1540e-04 2.00


Degree = 2
cells      eval.pi            error
    5 3.1248930668550594 1.6700e-02    -
   20 3.1404050605605449 1.1876e-03 3.81
   80 3.1415157631807009 7.6890e-05 3.95
  320 3.1415878042798613 4.8493e-06 3.99
 1280 3.1415923498174534 3.0377e-07 4.00
 5120 3.1415926345931995 1.8997e-08 4.00


Degree = 3
cells      eval.pi            error
    5 3.1414940401456048 9.8613e-05    -
   20 3.1415913432549156 1.3103e-06 6.23
   80 3.1415926341726910 1.9417e-08 6.08
  320 3.1415926532906897 2.9910e-10 6.02
 1280 3.1415926535851355 4.6578e-12 6.00
 5120 3.1415926535897190 7.4216e-14 5.97


Degree = 4
cells      eval.pi            error
    5 3.1415921029432572 5.5065e-07     -
   20 3.1415926513737595 2.2160e-09  7.96
   80 3.1415926535810712 8.7222e-12  7.99
  320 3.1415926535897576 3.5525e-14  7.94
 1280 3.1415926535897936 4.6729e-16  6.25
 5120 3.1415926535897918 1.4929e-15 -1.68
@endcode






从输出的一个直接观察结果是，在所有情况下，数值都迅速收敛到 $\pi=3.141592653589793238462643$ 的真实值。请注意，对于 $Q_4$ 的映射，我们已经进入了四舍五入误差的制度，收敛率趋于平缓，这已经是相当多的了。然而，也请注意，对于 $Q_1$ 映射，即使在最细的网格上，精度也明显比 $Q_3$ 映射的粗网格上要差得多!




输出的最后一列显示了收敛顺序，以网格宽度的幂为单位  $h$  。在介绍中，我们曾说过  $Q_p$  映射的收敛顺序应该是  $h^{p+1}$  。然而，在所示的例子中，顺序是 $h^{2p}$  !这个起初令人惊讶的事实可以用 $Q_p$ 映射的特性来解释。在<i>p</i>阶时，它使用的支持点是基于<i>p</i>+1点的Gauss-Lobatto正交规则，以这样的方式选择支持点，使正交规则在2<i>p</i>阶时收敛。尽管这些点在这里只用于插值<i>p</i>阶多项式，但我们在数值评估积分时得到了超收敛效应，导致观察到的高阶收敛。这种效应在下面的出版物中也有详细讨论。A. Bonito, A. Demlow, and J. Owen:"拉普拉斯-贝特拉米算子的特征值和特征函数的有限元近似的先验误差估计"，提交，2018年）。)


