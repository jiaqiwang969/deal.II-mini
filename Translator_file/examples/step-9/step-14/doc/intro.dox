examples/step-14/doc/intro.dox

<a name="Intro"></a>

<h1>Introduction</h1>

<h3>The maths</h3>

Rolf Rannacher教授的海德堡小组，deal.II库的三位最初的作者在他们的博士期间和部分之后都属于该小组，自90年代中期以来一直从事有限元离散的适应性和误差估计的研究。其主要成就是开发了任意函数的误差估计，以及用于计算的最佳网格细化。

我们不会太详细地讨论这些概念的推导，但会在本例程序中实现主要思想。对于一般概念的彻底介绍，我们参考Becker和Rannacher的开创性工作 @cite BR95 ， @cite BR96r ，以及同一作者在Acta Numerica @cite BR01 上的概述文章；前者介绍了拉普拉斯方程的误差估计和一般函数输出的适应性概念，而后者给出了这些概念在大量其他更复杂方程中的应用例子。关于个别类型方程的应用，也可参见Becker  @cite Bec95  ,  @cite Bec98  , Kanschat  @cite Kan96  ,  @cite FK97  , Suttmeier  @cite Sut96  的出版物。] ,  @cite RS97  ,  @cite RS98c  ,  @cite RS99  , 班格特  @cite BR99b  ,  @cite Ban00w  ,  @cite BR01a  ,  @cite Ban02  , 和哈特曼  @cite Har02  ,  @cite HH01  ,  @cite HH01b  。所有这些工作，从Becker和Rannacher的原始介绍到对特定方程的个别贡献，后来都被Bangerth和Rannacher总结成一本书，涵盖所有这些主题，见  @cite BR03  。


其基本思想如下：在应用中，人们通常对解本身不感兴趣，而是对它的某些方面感兴趣。例如，在流动问题的模拟中，人们可能想知道浸在流体中的物体的升力或阻力；我们想知道的是这个量的最佳精度，而描述方程的其余解是否得到很好的解决并不是主要兴趣。同样，在弹性方面，人们可能想知道某些点的应力值，以猜测关节的最大负荷值是否安全，例如。或者，在辐射传输问题中，平均通量强度是有意义的。

在刚才列举的所有情况中，我们感兴趣的是解的函数 $J(u)$ 的评估，而不是各地的 $u$ 的值。由于精确的解决方案 $u$ 是不可用的，只有它的数字近似值 $u_h$ ，所以询问计算值 $J(u_h)$ 是否在精确值 $J(u)$ 的一定范围内是明智的，也就是说，我们要约束与这个函数有关的误差， $J(u)-J(u_h)$ 。

为了简化论述，我们假设感兴趣的量 $J$ 以及方程都是线性的，我们将特别展示具有同质Dirichlet边界条件的拉普拉斯方程的推导，尽管这一概念更为普遍。对于这种一般情况，我们参考上面列出的参考文献。  我们的目标是获得误差的界限，  $J(e)=J(u)-J(u_h)$  。为此，让我们用 $z$ 表示对偶问题的解，定义如下。

@f[
  a(\varphi,z) = J(\varphi) \qquad \forall \varphi,


@f]

其中 $a(\cdot,\cdot)$ 是与微分方程相关的双线性形式，测试函数从相应的解空间中选择。然后，以特殊的检验函数 $\varphi=e$ 作为误差，我们有

@f[
  J(e) = a(e,z)


@f]

根据加尔金正交性，我们可以将其改写为

@f[
  J(e) = a(e,z-\varphi_h)


@f]

其中 $\varphi_h$ 可以用我们认为方便的任何方式从离散测试空间中选择。

具体来说，对于拉普拉斯方程来说，其误差特性为

@f[
  J(e) = (\nabla e, \nabla(z-\varphi_h)).


@f]

因为我们不仅要用这个公式来计算误差，而且还要细化网格，所以我们需要将上面的表达式改写为单元格之和，每个单元格的贡献可以作为这个单元格的误差指标。因此，我们将标量产品分成每个单元的条款，并对每个单元进行分项积分。

@f{eqnarray*}
  J(e)
  &=&
  \sum_K (\nabla (u-u_h), \nabla (z-\varphi_h))_K
  \\
  &=&
  \sum_K (-\Delta (u-u_h), z-\varphi_h)_K
  + (\partial_n (u-u_h), z-z_h)_{\partial K}.


@f}

接下来我们使用 $-\Delta u=f$ ，对于拉普拉斯方程的解来说，该解足够平滑， $\partial_n u$ 几乎在任何地方都是连续的--因此在一个单元上涉及 $\partial_n u$ 的项与它的邻居上的项相抵消，其中法向量的符号相反。(不过 $\partial_n u_h$ 的情况并非如此。)在域的边界，没有可以抵消这个项的邻接单元，权重 $z-\varphi_h$ 可以选择为零，而整个项就消失了。

因此，我们有

@f{eqnarray*}
  J(e)
  &=&
  \sum_K (f+\Delta u_h, z-\varphi_h)_K


  - (\partial_n u_h, z-\varphi_h)_{\partial K\backslash \partial\Omega}.


@f}

在最后一步，注意当取 $u_h$ 的法向导数时，我们指的是从单元格的这一边取的这个量的值（对于通常的拉格朗日元素，导数不是跨边连续的）。然后我们重写上述公式，将单元格 $K$ 的一半边缘积分与相邻单元格 $K'$ 交换，得到

@f{eqnarray*}
  J(e)
  &=&
  \sum_K (f+\Delta u_h, z-\varphi_h)_K


  - \frac 12 (\partial_n u_h|_K + \partial_{n'} u_h|_{K'},
              z-\varphi_h)_{\partial K\backslash \partial\Omega}.


@f}

利用对于相邻单元格上的法向量，我们有 $n'=-n$ ，我们定义法向导数的跳跃为

@f[
  [\partial_n u_h] \dealcoloneq \partial_n u_h|_K + \partial_{n'} u_h|_{K'}
  =
  \partial_n u_h|_K - \partial_n u_h|_{K'},


@f]

并在将离散函数 $\varphi_h$ 设置为对偶解的点插值后得到最终形式， $\varphi_h=I_h z$ ，现在它仍然是任意的。

@f{eqnarray*}
  J(e)
  &=&
  \sum_K (f+\Delta u_h, z-I_h z)_K


  - \frac 12 ([\partial_n u_h],
              z-I_h z)_{\partial K\backslash \partial\Omega}.


@f}



借此，我们得到了关于任意（线性）函数的有限元离散化误差的精确表示  $J(\cdot)$  。其结构是残差估计的加权形式，因为 $f+\Delta u_h$ 和 $[\partial_n u_h]$ 都是在精确解上消失的单元和边缘残差，而 $z-I_h z$ 是表示某个单元上的残差对于给定函数的评估有多重要的权重。此外，它是一个面向单元的量，所以我们可以把它作为一个网格细化的标准。问题是：如何评估它？毕竟，评估需要了解对偶解 $z$ ，它带有我们想要知道的最准确的数量的信息。

在一些非常特殊的情况下，这个对偶解是已知的。例如，如果函数 $J(\cdot)$ 是点评估， $J(\varphi)=\varphi(x_0)$ ，那么对偶解必须满足

@f[


  -\Delta z = \delta(x-x_0),


@f]

右手边是狄拉克三角函数，对偶解是关于点 $x_0$ 的格林函数。对于简单的几何形状，这个函数是分析上已知的，我们可以把它插入误差表示公式中。

然而，我们不想把自己限制在这种特殊情况下。相反，我们将以数值方式计算对偶解，并通过一些数值获得的 $\tilde z$ 来近似 $z$ 。我们注意到，使用与原始解 $u_h$ 相同的方法来计算这个近似值 $\tilde z$ 是不够的，因为这样 $\tilde z-I_h \tilde z=0$ 和整体误差估计值将为零。相反，近似值 $\tilde z$ 必须来自一个比原始有限元空间更大的空间。有多种方法可以获得这样的近似值（见所引用的文献），我们将选择用高阶有限元空间来计算它。虽然这肯定不是最有效的方法，但它很简单，因为我们已经有了所有需要做的事情，而且还可以进行简单的实验。对于更有效的方法，再次参考给定的文献，特别是  @cite BR95  ,  @cite BR03  。

至此，我们结束了对这个程序的数学方面的讨论，转而讨论实际的实施。




 @note 如果你只关心计算误差的话，上面有两个步骤似乎没有必要：即(i)从 $z$ 中减去 $\phi_h$ ，以及(ii)将积分拆成单元格之和，并对每个单元格进行积分。事实上，这两个步骤根本没有改变 $J(e)$ ，因为在用 $\tilde z$ 替换 $z$ 之前，我们只考虑上面的相同点。换句话说，如果你只关心<i>estimating the global error</i> $J(e)$ ，那么这些步骤就没有必要。另一方面，如果你想把误差估计值也作为网格中每个单元的细化标准，那么就有必要(i)把估计值分解成单元的总和，(ii)以这样的方式按摩公式，使每个单元的贡献都与局部误差有关。(虽然上面的扭曲没有改变<i>sum</i> $J(e)$ 的值，但它们改变了我们为每个单元 $K$ 计算的值) 。为此，我们想把一切都写成 "残差乘以双重权重 "的形式，其中 "残差 "是随着近似度变得 $u_h$ 越来越好而归于零的东西。例如， $\partial_n
u_h$ 这个量不是残差，因为它只是收敛到精确解的梯度的（法线分量）。另一方面， $[\partial_n u_h]$ 是一个残差，因为它收敛于 $[\partial_n
u]=0$  。我们在制定 $J(e)$ 的最终形式时采取的所有步骤，实际上都是为了使最终公式变成一种形式，即当离散解 $u_h$ 收敛到 $u$ 时，每个项都收敛为零。这样就可以把每个单元的贡献看作是一个 "误差指标"，也会收敛为零--因为它应该随着网格的细化而收敛。




<h3>The software</h3>

第14步的例子程序在很大程度上建立在第13步程序中已经使用的技术上。它对上面解释的双重加权残差估计器的实现是通过派生出第二个类，正确地称为 <code>DualSolver</code>, from the <code>Solver</code> 基类，并有一个类(  <code>WeightedResidual</code> )将两者再次连接起来，控制原始和双重问题的解决，然后用两者来计算网格细化的误差指标。

这个程序延续了上一个例子的模块化概念，通过一个抽象的基类来实现双重功能，描述感兴趣的数量，并提供两个不同的功能来实现这个接口。因此，增加一个不同的兴趣量是很简单的。

其中一个更根本的区别是对数据的处理。一个常见的情况是，你开发了一个解决某个方程的程序，并用不同的右手边、不同的域、不同的系数和边界值等来测试它。通常情况下，这些都必须匹配，这样才能知道确切的解决方案，或者它们的组合根本就有意义。

我们将演示如何以一种简单而又非常灵活的方式实现这一目标。我们将把属于某个设置的所有东西放到一个类中，并围绕它提供一个小的C++砂浆，这样整个设置（域、系数、右手边等）就可以通过只改变 <em> 中的某个 </em> 地方来交换。

再进一步，我们还将所有描述程序如何工作的其他参数集中在一个地方，如有限元的顺序、最大自由度数、对计算出的解应执行的评估对象等等。这使得程序的配置更加简单，我们将在后面的程序中展示如何使用一个库类来处理通过读取输入文件来设置这些参数。总的来说，我们的目的是要减少程序中想要改变某些参数时可能需要查找的地方，因为在实践中发现，随着程序的发展，人们会忘记它们的位置。此外，把所有描述程序在某次运行中的选项放到一个文件中（可以和结果一起存储），比在程序中的某个地方设置各种标志更有助于结果的可重复性，因为在下次改变这个地方后，它们的准确值就会被遗忘。

不幸的是，这个程序已经变得相当长了。虽然这无疑降低了它作为一个示例程序的作用，但我们认为它是一个很好的起点，可以为其他类型的问题开发一个程序，涉及不同于这里处理的拉普拉斯方程的方程。此外，它显示了我们可以向你展示的关于我们的后验误差估计方法的一切，它的结构应该使你能够简单地调整这个方法以适应其他问题、其他函数、其他几何形状、系数等等。

作者认为，就数学的复杂性和添加扩展的简单性而言，本程序是他在范例程序中的杰作。如果你使用这个程序作为你自己程序的基础，我们希望你能在出版物中说明这一事实以及示例程序的作者Wolfgang Bangerth的名字，因为你的程序有相当一部分是由示例程序组成的。


