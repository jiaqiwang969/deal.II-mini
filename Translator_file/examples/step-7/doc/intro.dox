examples/step-7/doc/intro.dox

<a name="Intro"></a>

<h1>Introduction</h1>

在这个程序中，我们将主要考虑两个方面。<ol>  <li>  验证程序的正确性和生成收敛表；  <li>  亥姆霍兹方程的非均质诺伊曼边界条件。   </ol>  除了这些主题，还将再次展示各种改进和技巧。




<h3>Verification of correctness</h3>

可能从来没有一个非琐碎的有限元程序从一开始就能正常工作。因此有必要找到方法来验证计算出的解是否正确。通常，这是通过选择模拟的设置来完成的，我们知道准确的连续解，并评估连续解和计算的离散解之间的差异。如果这个差值以正确的收敛顺序收敛为零，这已经是正确性的一个很好的指示，尽管可能还有其他的误差源持续存在，而这些误差对总误差的贡献很小，或者是更高阶的。在有限元模拟的背景下，这种通过选择适当的右手边和边界条件来选择解决方案的技术通常被称为<i>Method of Manufactured Solution</i>。

在这个例子中，我们不会去研究系统性软件验证的理论，这是一个非常复杂的问题。相反，我们将展示deal.II在这方面所能提供的工具。这基本上是围绕着一个单一的函数的功能， VectorTools::integrate_difference(). 这个函数计算一个给定的连续函数和每个单元上不同规范的有限元场之间的差值。当然，像其他积分一样，我们只能用正交公式来评估这些规范；因此，选择正确的正交公式对准确评估误差至关重要。这一点对于 $L_\infty$ 规范尤其成立，我们只在正交点评估数值和精确解的最大偏差；那么就不应该尝试使用正交规则，其评估只发生在[超级收敛](https://en.wikipedia.org/wiki/Superconvergence)可能发生的点上，例如最低阶高斯正交公式的高斯点，对于该矩阵的装配中的积分是正确的（例如，对于线性元素，不要使用QGauss（2）正交公式）。事实上，这通常也是对其他规范的好建议：如果你的正交点偶然选择在由于超收敛而恰好误差特别小的位置，那么计算出来的误差看起来会比实际情况小得多，甚至可能表明收敛阶数更高。因此，我们将为这些误差准则的积分选择不同的正交公式，而不是线性系统的装配。

函数 VectorTools::integrate_difference() 对三角形的每个单元 $K$ 进行所需规范的评估，并返回一个持有每个单元的这些值的向量。从局部值中，我们可以得到全局误差。例如，如果所有单元 $K$ 的元素为 $e_K$ 的向量 $\mathbf e$ 包含本地 $L_2$ 规范 $\|u-u_h\|_K$ ，那么

@f[
  E = \| {\mathbf e} \| = \left( \sum_K e_K^2 \right)^{1/2}


@f]

是全球  $L_2$  误差  $E=\|u-u_h\|_\Omega$  。

在程序中，我们将展示如何评估和使用这些量，并且我们将监测它们在网格细化下的值。当然，我们必须选择手头的问题，使我们能够明确地说明解决方案及其导数，但由于我们要评估程序的正确性，这才是合理的。如果我们知道程序对一个（或者，如果想真正确定：许多）特别选择的右手边产生了正确的解决方案，我们可以相当有信心，它也将计算出我们不知道确切数值的问题的正确解决方案。

除了简单地计算这些数量之外，我们将展示如何从这个程序产生的数据中生成格式良好的表格，自动计算收敛率等。此外，我们还将比较不同的网格细化策略。




<h3>Non-homogeneous Neumann boundary conditions</h3>

本例程序的第二个完全不相关的主题是使用非均质边界条件。这些条件包括在使用边界积分的变异形式中，我们必须在组装右手边的矢量时进行数值评估。

在我们进入编程之前，让我们简单看看数学公式。我们在这里要解决的方程是亥姆霍兹方程，"带有漂亮的符号"。

@f[


  -\Delta u + \alpha u = f,


@f]

在 $[-1,1]^2$ 与 $\alpha=1$ 的正方形上，用迪里希特边界条件来增强。

@f[
  u = g_1


@f]

在边界 $\Gamma_1$ 的某些部分 $\Gamma$ ，以及诺伊曼条件

@f[
  {\mathbf n}\cdot \nabla u = g_2


@f]

对其余的 $\Gamma_2 = \Gamma \backslash \Gamma_1$ 。在我们特定的测试案例中，我们将使用 $\Gamma_1=\Gamma \cap\{\{x=1\}
\cup \{y=1\}\}$  。 我们说这个方程有 "漂亮的符号"，因为算子 $-\Delta + \alpha I$ 与身份 $I$ 和 $\alpha>0$ 是一个正定算子；<a
href="https://en.wikipedia.org/wiki/Helmholtz_equation">equation with
the "bad sign"</a>是 $-\Delta u - \alpha u$ ，由时间谐波过程建模产生。如果 $\alpha>0$ 很大的话，该算子就不是正定的，这就导致了我们在这里不需要讨论的各种问题。如果 $\alpha$ 恰好是 $-\Delta$ 的特征值之一，那么算子也可能不是可逆的--即方程没有唯一的解--)

因为我们想验证我们的数字解  $u_h$  的收敛性，我们想要一个设置，以便我们知道精确的解  $u$  。这就是 "人造解法 "的作用。为此，让我们选择一个函数

@f[
  \bar u(x) = \sum_{i=1}^3 \exp\left(-\frac{|x-x_i|^2}{\sigma^2}\right)


@f]

其中指数的中心 $x_i$ 为 $x_1=(-\frac 12,\frac 12)$ ， $x_2=(-\frac 12,-\frac 12)$ ，和 $x_3=(\frac 12,-\frac 12)$ ，半宽设为 $\sigma=\frac {1}{8}$ 。然后，制造解的方法说：选择

@f{align*}
  f &= -\Delta \bar u + \bar u, \\
  g_1 &= \bar u|_{\Gamma_1}, \\
  g_2 &= {\mathbf n}\cdot \nabla\bar u|_{\Gamma_2}.


@f}

有了这个特殊的选择，我们就可以推断出原始问题的解恰好是 $u=\bar u$  。换句话说，通过以特定的方式选择方程的右边和边界条件，我们已经为自己制造了一个我们知道其解决方案的问题。这使我们能够计算出我们的数字解决方案的误差。在下面的代码中，我们用 <code>Solution</code> 类来表示 $\bar u$ ，其他类将用于表示 $\bar u|_{\Gamma_1}=g_1$ 和 ${\mathbf n}\cdot \nabla\bar u|_{\Gamma_2}=g_2$  。

利用上述定义，我们可以陈述方程的弱表述，即：找到 $u\in H^1_g=\{v\in H^1: v|_{\Gamma_1}=g_1\}$ ，以便

@f[
  {(\nabla v, \nabla u)}_\Omega + {(v,u)}_\Omega
  =
  {(v,f)}_\Omega + {(v,g_2)}_{\Gamma_2}


@f]

为所有测试函数  $v\in H^1_0=\{v\in H^1: v|_{\Gamma_1}=0\}$  。边界项 ${(v,g_2)}_{\Gamma_2}$ 是通过部分积分和使用 $\partial_n u=g_2$ 对 $\Gamma_2$ 和 $v=0$ 的方式出现的。因此，在离散公式中，我们用来建立全局矩阵和右侧向量的单元矩阵和向量看起来是这样的。

@f{eqnarray*}
  A_{ij}^K &=& \left(\nabla \varphi_i, \nabla \varphi_j\right)_K
              +\left(\varphi_i, \varphi_j\right)_K,
  \\
  F_i^K &=& \left(\varphi_i, f\right)_K
           +\left(\varphi_i, g_2\right)_{\partial K\cap \Gamma_2}.


@f}

由于域积分的生成已经在前面的例子中多次展示过，这里只对轮廓积分的生成感兴趣。它的工作原理如下：对于域积分，我们有一个 <code>FEValues</code> 类，它提供了形状值和梯度，以及雅各布行列式和其他信息，并指定了单元格中的正交点；同样，还有一个 <code>FEFaceValues</code> 类，为单元格面上的积分执行这些任务。我们向它提供一个流形的正交公式，该流形的维数比域的维数少一，以及我们想在其上进行积分的单元格和其面的数量。然后，该类将计算该面的正交点的值、梯度、法向量、权重等，然后我们可以以与域积分相同的方式使用这些值。下面的程序显示了这样做的细节。




<h3>A note on good programming practice</h3>

除了上面概述的数学主题外，我们还想用这个程序来说明良好编程实践的一个方面，即命名空间的使用。在为deal.II库编程时，我们非常注意不要为类和全局函数使用过于通用的名称，例如 <code>f(), sz(), rhs()</code> 等。此外，我们把所有的东西都放到了名字空间  <code>dealii</code>  中。但当一个人写的应用程序不是为了给别人使用时，就不一定会注意这么多。如果你遵循步骤1到步骤6的编程风格，这些函数就会最终进入全局命名空间，不幸的是，很多其他的东西也在那里（基本上是C语言提供的所有东西，以及你通过头文件从操作系统得到的所有东西）。更糟糕的是，C语言的设计者在避免使用通用名称方面也不总是很小心；例如，符号<code>j1, jn</code>在C头文件中被定义（它们表示贝塞尔函数）。

为了避免不同函数或变量的名称相撞时产生的问题（经常出现混乱的错误信息），把你所做的一切放到<a
href="http://en.wikipedia.org/wiki/Namespace_(computer_science)">namespace</a>中是一个好的做法。按照这种风格，我们将在程序的顶部打开一个名字空间 <code>Step7</code> ，将deal.II名字空间导入其中，将本程序特有的一切（除了 <code>main()</code> ，它必须在全局名字空间中）放入其中，并且只在文件的底部关闭它。换句话说，这个程序的结构是这样的

@code
  #includes ...


  namespace Step7
  {
    using namespace dealii;


    ...everything to do with the program...
  }


  int main ()
  {
    ...do whatever main() does...
  }
@endcode

我们将在整个交易.II教程的剩余部分遵循这一方案。


