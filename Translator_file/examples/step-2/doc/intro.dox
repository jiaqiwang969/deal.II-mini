examples/step-2/doc/intro.dox

<a name="Intro"></a>

<h1>Introduction</h1>

 @dealiiVideoLecture{9} 

在前面的例子中，我们已经创建了一个网格，现在我们展示如何在这个网格上定义自由度。在这个例子中，我们将使用最低阶（ $Q_1$ ）的有限元，自由度与网格的顶点相关联。以后的例子将展示更高阶的元素，自由度不一定与顶点相关，但可以与边、面或单元相关。

术语 "自由度 "在有限元界通常用来表示两个略有不同但相关的事情。首先是我们希望将有限元解表示为形状函数的线性组合，形式为 $u_h(\mathbf x) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf
x)$  。这里， $U_j$ 是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。该术语的第二个含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数 $u_h \in V_h$ （例如， $a(u_h,\varphi_h)=(f,\varphi_h)$ 为所有测试函数 $\varphi_h\in
V_h$ ）。换句话说，我们在这里说的是，解决方案需要位于某个空间  $V_h$  中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数 $U_j$ 对 $u_h(\mathbf x)$ 进行展开的形状函数 $\varphi_j(\mathbf x)$ 的集合。当然，空间 $V_h$ 的基数有很多，但我们将特别选择由传统上在网格单元上局部定义的有限元函数描述的基数。在这种情况下描述 "自由度 "需要我们简单地 <i>enumerate</i> 空间的基函数  $V_h$  。对于 $Q_1$ 元素，这意味着简单地以某种方式列举网格的顶点，但对于高阶元素，还必须列举与网格的边、面或单元内部相关的形状函数。换句话说，自由度的枚举是完全独立于我们用于顶点的索引的。提供这种列举 $V_h$ 的基础函数的类被称为DoFHandler。

在网格上定义自由度（简称 "DoF"）是一个相当简单的任务，因为这个库为你做了所有的工作。基本上，你所要做的就是创建一个有限元对象（从deal.II已有的众多有限元类中选取，例如参见 @ref fe 文档），并通过 DoFHandler::distribute_dofs 函数将其交给DoFHandler对象（"分配DoF "是我们用来描述上文讨论的<i>enumerating</i>基函数过程的术语）。DoFHandler是一个知道哪些自由度住在哪里的类，也就是说，它可以回答 "全局有多少自由度 "和 "在这个单元上，给我住在这里的形状函数的全局索引 "这样的问题。当你决定你的系统矩阵应该有多大时，以及当把单个单元的贡献复制到全局矩阵时，你需要这种信息。

<h3> Sparsity </h3>

然后，下一步将是利用这个有限元和网格计算与特定微分方程对应的矩阵和右手。我们将为第三步程序保留这一步骤，而是谈论有限元程序的一个实际问题，即有限元矩阵总是非常稀疏的：这些矩阵中的几乎所有条目都是零。

更准确地说，如果一个矩阵中的非零项<i>per row</i>的数量与整个自由度的数量无关，我们就说该矩阵是稀疏的。例如，拉普拉斯方程的有限差分近似的简单5点模版导致了一个稀疏矩阵，因为每行的非零条目数是5，因此与矩阵的总大小无关。对于更复杂的问题--比如说步骤22的斯托克斯问题--特别是在三维中，每行的条目数可能是几百个。但重要的一点是，这个数字与问题的总体大小无关：如果你细化网格，每行未知数的最大数量保持不变。

与使用泰勒扩展和匹配系数来逼近偏微分方程的解，或使用傅里叶基相比，稀疏性是有限元方法的一个突出特点。

在实践中，正是由于矩阵的稀疏性，使我们能够解决有数百万或数十亿未知数的问题。为了理解这一点，请注意，一个有 $N$ 行的矩阵，每个非零项的数量都有固定的上限，需要 ${\cal O}(N)$ 个内存位置来存储，而矩阵-向量乘法也只需要 ${\cal O}(N)$ 次操作。因此，如果我们有一个线性求解器，只需要固定数量的矩阵向量乘法就能得出这个矩阵的线性系统的解，那么我们就会有一个能以最佳复杂度找到所有 $N$ 未知数的值的求解器，也就是说，总共只需要 ${\cal O}(N)$ 次操作。很明显，如果矩阵不是稀疏的，这是不可能的（因为那样的话，矩阵中的条目数必须是 ${\cal O}(N^s)$ 与一些 $s>1$ ，做固定数量的矩阵-向量乘积将需要 ${\cal O}(N^s)$ 次操作），但这也需要非常专业的求解器，如多网格方法，以满足求解只需要固定数量的矩阵-向量乘法的要求。我们将在本教程的剩余程序中经常研究使用什么求解器的问题。

稀疏性是由以下事实产生的：有限元形状函数是在单个单元上定义的<i>locally</i>，而不是全局的，并且双线性形式中的局部微分算子只对支持度重叠的形状函数进行耦合。一个函数的 "支持 "是指它的非零区域。对于有限元方法，形状函数的支持通常是指与它所定义的顶点、边或面相邻的单元。)换句话说，自由度 $i$ 和 $j$ 如果不是定义在同一个单元上，就不会重叠，因此，矩阵条目 $A_{ij}$ 将为零。  (在某些情况下，如非连续加尔金法，形状函数也可以通过面积分连接到相邻的单元。但是有限元方法一般不会将形状函数与定义了该函数的单元的近邻相联系）。)




<h3> How degrees of freedom are enumerated </h3>

默认情况下，DoFHandler类以一种相当随机的方式枚举网格上的自由度；因此，稀疏度模式也没有为任何特定的目的进行优化。为了说明这一点，下面的代码将演示一个简单的方法来输出对应于DoFHandler的 "稀疏模式"，即一个对象代表了在网格上离散偏微分方程时可能建立的矩阵的所有潜在非零元素及其DoFHandler。这种缺乏结构的疏散模式将从我们下面展示的图片中显现出来。

对于大多数应用和算法来说，自由度的确切编号方式并不重要。例如，我们用来解决线性系统的共轭梯度方法并不关心。另一方面，有些算法确实关心：特别是一些预处理程序，如SSOR，如果它们能以特定的顺序走过自由度，就能更好地工作，如果我们能以这样的方式排序，使SSOR能以这样的顺序从零到 $N$ 迭代它们，那就太好了。其他的例子包括计算不完整的LU或Cholesky分解，或者如果我们关心矩阵的块状结构（见步骤20的例子）。因此，deal.II在命名空间DoFRenumbering中有一些算法可以以特定的方式重新列举自由度。重新编号可以被认为是选择了一个不同的、经排列的有限元空间的基础。因此，这种重新编号所产生的稀疏模式和矩阵与我们没有明确的重新编号所得到的相比，也只是行和列的排列组合。

在下面的程序中，我们将使用Cuthill和McKee的算法来完成。我们将在<a href="#Results">results section</a>中展示原始自由度列举和下面重新编号的版本的稀疏模式。


