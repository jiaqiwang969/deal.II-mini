examples/step-21/doc/results.dox



<h1>Results</h1>

这里介绍的代码并没有真正计算出网页上的结果。原因是，即使在一台好的电脑上，它也要运行一天以上。如果你想重现这些结果，在TwoPhaseFlowProblem的构造函数中把DiscreteTime对象的结束时间修改为`250`。

如果我们运行该程序，我们会得到以下这种输出。

@code
Number of active cells: 1024
Number of degrees of freedom: 4160 (2112+1024+1024)


Timestep 1
   22 CG Schur complement iterations for pressure.
   1 CG iterations for saturation.
   Now at t=0.0326742, dt=0.0326742.


Timestep 2
   17 CG Schur complement iterations for pressure.
   1 CG iterations for saturation.
   Now at t=0.0653816, dt=0.0327074.


Timestep 3
   17 CG Schur complement iterations for pressure.
   1 CG iterations for saturation.
   Now at t=0.0980651, dt=0.0326836.


...
@endcode

我们可以看到，时间步长从一开始就基本恒定，这表明域中的速度并不强烈依赖于饱和度的变化，尽管它们肯定是通过压力方程中的因子 $\lambda(S)$ 来决定的。

我们的第二个观察结果是，在第一和第二时间步之间，解决压力舒尔补足方程所需的CG迭代次数从22次下降到17次（事实上，在其余的计算中，它保持在17次左右）。原因其实很简单。在我们求解一个时间步长的压力之前，我们没有将 <code>solution</code> 变量重置为零。因此，在我们进入CG求解器时，压力（和其他变量）具有前一个时间步骤的值。由于速度和压力在计算过程中变化不大，前一个时间步骤的压力实际上是对这个时间步骤压力的一个很好的初始猜测。因此，一旦我们计算了一次压力，我们需要的迭代次数就会大大减少。

最后的观察是关于求解饱和度所需的迭代次数，也就是一次。这不应该让我们太惊讶：我们必须解决的矩阵是质量矩阵。然而，这是 $DGQ_0$ 元素的分片常数的质量矩阵，其中没有元素与相邻单元的自由度耦合。因此，该矩阵是一个对角线矩阵，很明显，我们应该能够在一次CG迭代中反转该矩阵。


说了这么多，这里有几个电影，显示了饱和度是如何随时间推移而发展的。首先，这是针对单一裂缝模型的，正如在 <code>SingleCurvingCrack::KInverse</code> 类中实现的那样。

 <img src="https://www.dealii.org/images/steps/developer/step-21.centerline.gif" alt=""> 

可以看出，富水流体主要是沿着域中间的高渗透区蜿蜒前行，而域的其他部分则大部分是不渗透的。这部电影和下一部电影是用 <code>n_refinement_steps=7</code> 生成的，导致 $128\times 128$ 的网格有大约16000个单元和大约66000个未知数。


第二部电影显示了 <code>RandomMedium::KInverse</code> 类的随机介质模型的饱和度，我们有随机分布的高渗透率中心，流体从这些区域中的一个跳到另一个。

 <img src="https://www.dealii.org/images/steps/developer/step-21.random2d.gif" alt=""> 


最后，这里是在三个空间维度上的相同情况，在一个具有 <code>n_refinement_steps=5</code> 的网格上，产生一个大约32000个单元和167000个自由度的网格。

 <img src="https://www.dealii.org/images/steps/developer/step-21.random3d.gif" alt=""> 

要重复这些计算，你所要做的就是改变行数

@code
      TwoPhaseFlowProblem<2> two_phase_flow_problem(0);
@endcode

在主函数中为

@code
      TwoPhaseFlowProblem<3> two_phase_flow_problem(0);
@endcode

可视化采用了云技术，每个单元的饱和度都由彩色但透明的云来表示。这样，人们也可以在一定程度上看到域的深处发生了什么。另一种可视化的方式是显示饱和度随时间变化的等值面。有一些技术可以透明地绘制等值面，这样就可以像洋葱的层次一样同时看到几个等值面。

那么，为什么我们不显示这样的等值面呢？问题在于等值面的计算方式：它们要求要可视化的场是连续的，所以等值面可以通过至少在单个细胞中遵循轮廓线来生成。然而，我们的饱和场是片状常数和不连续的。如果我们想为一个饱和度 $S=0.5$ 绘制一个等值面，那么在这个领域中就很可能没有一个点是真正达到饱和度的。如果我们必须在这种情况下定义等值面，我们将不得不采取细胞之间的界面，其中相邻的两个细胞之一的饱和度大于，另一个细胞的饱和度小于0.5。然而，大多数可视化程序似乎并不具备做这种转换的能力。


<a name="extensions"></a>

<h3>Possibilities for extensions</h3>

这个项目有许多可以改进的地方。下面列出了其中的三个。事实上，所有这些问题都在构成当前程序的延续的辅导程序中得到了解决：Step-43。




<h4>Solvers</h4>

目前，该程序并不是特别快：二维随机介质的计算在1000个左右的时间步长中花费了大约一天时间。相应的三维计算在800个时间步骤中几乎花了两天时间。没有比这更快的原因有两个方面。首先，我们在每个时间步骤中都要重建整个矩阵，尽管有些部分如 $B$ 、 $B^T$ 和 $M^S$ 块从未改变。

第二，我们可以在求解器和预处理器方面做得更好。目前，我们用CG方法解决Schur补数 $B^TM^u(S)^{-1}B$ ，使用 $[B^T (\textrm{diag}(M^u(S)))^{-1} B]^{-1}$ 作为预处理程序。应用这个预处理程序是很昂贵的，因为它涉及到每次解决一个线性系统。这可能适合于 @ref
step_20 的 "第20步"，在那里我们只需要解决整个问题一次。然而，在这里我们必须求解数百次，在这种情况下，值得考虑使用一种第一次设置起来比较昂贵，但以后应用起来比较便宜的预处理程序。

一种可能性是意识到我们用作预处理的矩阵， $B^T (\textrm{diag}(M^u(S)))^{-1} B$ 仍然是稀疏的，而且是对称的。如果看一下流场随时间的演变，我们还可以看到，虽然 $S$ 随时间变化很大，但压力几乎没有变化，因此 $B^T (\textrm{diag}(M^u(S)))^{-1} B \approx B^T (\textrm{diag}(M^u(S^0)))^{-1}
B$  。换句话说，第一个时间步骤的矩阵应该是一个很好的前提条件，也适用于所有后来的时间步骤。  通过一些反反复复的操作，实际上并不难得到一个SparseMatrix对象的表示。然后我们可以把它交给SparseMIC类，以形成一个稀疏的不完全Cholesky分解。形成这种分解是很昂贵的，但是我们只需要在第一个时间步骤中做一次，然后就可以在未来把它作为一个廉价的预处理程序。我们甚至可以通过使用SparseDirectUMFPACK类来做得更好，它不仅能产生一个不完整的，而且是一个完整的矩阵分解，这应该会产生一个更好的预处理程序。

最后，为什么使用近似值 $B^T (\textrm{diag}(M^u(S)))^{-1} B$ 来预设 $B^T M^u(S)^{-1} B$ ？后者的矩阵毕竟是压力空间上拉普拉斯算子的混合形式，我们对其使用线性元素。因此，我们可以在直接对应于拉普拉斯的非混合形式的一侧建立一个单独的矩阵 $A^p$ ，例如使用双线性形式 $(\mathbf{K}\lambda(S^n) \nabla
\varphi_i,\nabla\varphi_j)$  。然后我们可以形成这个非混合矩阵的不完全或完全分解，并将其作为混合形式的预处理。

使用这样的技术，可以合理地预期，求解过程将至少快一个数量级。




<h4>Time stepping</h4>

在介绍中，我们已经确定了时间步长的限制

@f[
  \triangle t_{n+1} \le \frac h{|\mathbf{u}^{n+1}(\mathbf{x})|}


@f]

必须是全局性的，即对所有的 $\mathbf x$ 。离散化后，我们通过选择以下方式来满足它

@f[
  \triangle t_{n+1} = \frac {\min_K h_K}{\max_{\mathbf{x}}|\mathbf{u}^{n+1}(\mathbf{x})|}.


@f]



这种对时间步长的限制有些烦人：我们把网格做得越细，时间步长就越小；换句话说，我们受到了两次惩罚：每个时间步长的求解成本更高，我们必须做更多的时间步长。

这一点特别令人讨厌，因为大部分的额外工作是用来解决方程的隐含部分，即压力-速度系统，而正是饱和度的双曲传输方程施加了时间步长的限制。

为了避免这个瓶颈，人们发明了一些方法。例如，他们可能每隔几步时间才重新计算压力-速度场（或者，如果你愿意，对压力/速度和饱和度方程使用不同的时间步长）。这就保持了对廉价显式部分的时间步长限制，而使隐式部分的求解不那么频繁。这个方向的实验当然是值得的；这种方法的一个起点是陈章新、桓冠仁和李宝岩的论文：<i>An improved IMPES method for
two-phase flow in porous media</i>，Transport in Porous Media，54（2004），第361&mdash；376页。当然也有很多其他关于这个主题的论文，但这篇论文前段时间刚好落在我们的桌上。




<h4>Adaptivity</h4>

适应性显然也会有帮助。看一下电影，我们可以清楚地看到，大部分的行动都局限于领域的一个相对较小的部分（这对饱和度来说特别明显，但对速度和压力也是如此）。因此，自适应性可望保持必要的低自由度数量，或者增加精确度。

另一方面，对于时间相关问题的自适应性也不是一件小事：我们必须每隔几个时间步数改变网格，而且每次改变网格时，我们都必须将目前的解决方案传送到下一个网格（SolutionTransfer类可以帮助解决这个问题）。这些并不是无法克服的障碍，但它们确实需要一些额外的编码，而且比我们认为值得打包到这个教程程序中的更多。


