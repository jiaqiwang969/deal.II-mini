// This file is automatically generated from corresponding .inst.in, do not edit.

#ifdef SPLIT_INSTANTIATIONS_COUNT
  #define SPLIT_INSTANTIATIONS_CHECK(C) (((C) % SPLIT_INSTANTIATIONS_COUNT) == SPLIT_INSTANTIATIONS_INDEX)
#else
  #define SPLIT_INSTANTIATIONS_CHECK(C) (1)
#endif

#if (SPLIT_INSTANTIATIONS_CHECK(0))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template class BlockVector< double >;
 template void
 BlockVector< double >::multivector_inner_product(
 FullMatrix< double > &,
 const BlockVector< double > &V,
 const bool) const;
 template void
 BlockVector< double >::multivector_inner_product(
 LAPACKFullMatrix< double > &,
 const BlockVector< double > &V,
 const bool) const;
 template  double 
 BlockVector< double >::multivector_inner_product_with_metric(
 const FullMatrix< double > &,
 const BlockVector< double > &V,
 const bool) const;
 template  double 
 BlockVector< double >::multivector_inner_product_with_metric(
 const LAPACKFullMatrix< double > &,
 const BlockVector< double > &V,
 const bool) const;
 template void
 BlockVector< double >::mmult(BlockVector< double > &V,
 const FullMatrix< double > &,
 const  double ,
 const  double ) const;
 template void
 BlockVector< double >::mmult(BlockVector< double > &V,
 const LAPACKFullMatrix< double > &,
 const  double ,
 const  double ) const;
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(1))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template class BlockVector< float >;
 template void
 BlockVector< float >::multivector_inner_product(
 FullMatrix< float > &,
 const BlockVector< float > &V,
 const bool) const;
 template void
 BlockVector< float >::multivector_inner_product(
 LAPACKFullMatrix< float > &,
 const BlockVector< float > &V,
 const bool) const;
 template  float 
 BlockVector< float >::multivector_inner_product_with_metric(
 const FullMatrix< float > &,
 const BlockVector< float > &V,
 const bool) const;
 template  float 
 BlockVector< float >::multivector_inner_product_with_metric(
 const LAPACKFullMatrix< float > &,
 const BlockVector< float > &V,
 const bool) const;
 template void
 BlockVector< float >::mmult(BlockVector< float > &V,
 const FullMatrix< float > &,
 const  float ,
 const  float ) const;
 template void
 BlockVector< float >::mmult(BlockVector< float > &V,
 const LAPACKFullMatrix< float > &,
 const  float ,
 const  float ) const;
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(2))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template class BlockVector< std::complex<double> >;
 template void
 BlockVector< std::complex<double> >::multivector_inner_product(
 FullMatrix< std::complex<double> > &,
 const BlockVector< std::complex<double> > &V,
 const bool) const;
 template void
 BlockVector< std::complex<double> >::multivector_inner_product(
 LAPACKFullMatrix< std::complex<double> > &,
 const BlockVector< std::complex<double> > &V,
 const bool) const;
 template  std::complex<double> 
 BlockVector< std::complex<double> >::multivector_inner_product_with_metric(
 const FullMatrix< std::complex<double> > &,
 const BlockVector< std::complex<double> > &V,
 const bool) const;
 template  std::complex<double> 
 BlockVector< std::complex<double> >::multivector_inner_product_with_metric(
 const LAPACKFullMatrix< std::complex<double> > &,
 const BlockVector< std::complex<double> > &V,
 const bool) const;
 template void
 BlockVector< std::complex<double> >::mmult(BlockVector< std::complex<double> > &V,
 const FullMatrix< std::complex<double> > &,
 const  std::complex<double> ,
 const  std::complex<double> ) const;
 template void
 BlockVector< std::complex<double> >::mmult(BlockVector< std::complex<double> > &V,
 const LAPACKFullMatrix< std::complex<double> > &,
 const  std::complex<double> ,
 const  std::complex<double> ) const;
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(3))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template class BlockVector< std::complex<float> >;
 template void
 BlockVector< std::complex<float> >::multivector_inner_product(
 FullMatrix< std::complex<float> > &,
 const BlockVector< std::complex<float> > &V,
 const bool) const;
 template void
 BlockVector< std::complex<float> >::multivector_inner_product(
 LAPACKFullMatrix< std::complex<float> > &,
 const BlockVector< std::complex<float> > &V,
 const bool) const;
 template  std::complex<float> 
 BlockVector< std::complex<float> >::multivector_inner_product_with_metric(
 const FullMatrix< std::complex<float> > &,
 const BlockVector< std::complex<float> > &V,
 const bool) const;
 template  std::complex<float> 
 BlockVector< std::complex<float> >::multivector_inner_product_with_metric(
 const LAPACKFullMatrix< std::complex<float> > &,
 const BlockVector< std::complex<float> > &V,
 const bool) const;
 template void
 BlockVector< std::complex<float> >::mmult(BlockVector< std::complex<float> > &V,
 const FullMatrix< std::complex<float> > &,
 const  std::complex<float> ,
 const  std::complex<float> ) const;
 template void
 BlockVector< std::complex<float> >::mmult(BlockVector< std::complex<float> > &V,
 const LAPACKFullMatrix< std::complex<float> > &,
 const  std::complex<float> ,
 const  std::complex<float> ) const;
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(4))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< double >::reinit< double >(const BlockVector< double > &, const bool);
 template void
 BlockVector< double >::add< double >(const std::vector<size_type> &,
 const ::dealii::Vector< double > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(5))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< double >::reinit< float >(const BlockVector< float > &, const bool);
 template void
 BlockVector< double >::add< float >(const std::vector<size_type> &,
 const ::dealii::Vector< float > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(6))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< float >::reinit< double >(const BlockVector< double > &, const bool);
 template void
 BlockVector< float >::add< double >(const std::vector<size_type> &,
 const ::dealii::Vector< double > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(7))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< float >::reinit< float >(const BlockVector< float > &, const bool);
 template void
 BlockVector< float >::add< float >(const std::vector<size_type> &,
 const ::dealii::Vector< float > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(8))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<double> >::reinit< double >(const BlockVector< double > &, const bool);
 template void
 BlockVector< std::complex<double> >::add< double >(const std::vector<size_type> &,
 const ::dealii::Vector< double > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(9))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<double> >::reinit< float >(const BlockVector< float > &, const bool);
 template void
 BlockVector< std::complex<double> >::add< float >(const std::vector<size_type> &,
 const ::dealii::Vector< float > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(10))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<float> >::reinit< double >(const BlockVector< double > &, const bool);
 template void
 BlockVector< std::complex<float> >::add< double >(const std::vector<size_type> &,
 const ::dealii::Vector< double > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(11))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<float> >::reinit< float >(const BlockVector< float > &, const bool);
 template void
 BlockVector< std::complex<float> >::add< float >(const std::vector<size_type> &,
 const ::dealii::Vector< float > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(12))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<double> >::reinit< std::complex<double> >(const BlockVector< std::complex<double> > &, const bool);
 template void
 BlockVector< std::complex<double> >::add< std::complex<double> >(const std::vector<size_type> &,
 const ::dealii::Vector< std::complex<double> > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(13))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<double> >::reinit< std::complex<float> >(const BlockVector< std::complex<float> > &, const bool);
 template void
 BlockVector< std::complex<double> >::add< std::complex<float> >(const std::vector<size_type> &,
 const ::dealii::Vector< std::complex<float> > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(14))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<float> >::reinit< std::complex<double> >(const BlockVector< std::complex<double> > &, const bool);
 template void
 BlockVector< std::complex<float> >::add< std::complex<double> >(const std::vector<size_type> &,
 const ::dealii::Vector< std::complex<double> > &);
 }
 }
 
#endif
#if (SPLIT_INSTANTIATIONS_CHECK(15))
namespace LinearAlgebra
 {
 namespace distributed
 {
 template void
 BlockVector< std::complex<float> >::reinit< std::complex<float> >(const BlockVector< std::complex<float> > &, const bool);
 template void
 BlockVector< std::complex<float> >::add< std::complex<float> >(const std::vector<size_type> &,
 const ::dealii::Vector< std::complex<float> > &);
 }
 }
 
#endif

#undef SPLIT_INSTANTIATIONS_CHECK
