
\title{
UG - A flexible software toolbox for solving partial differential equations
}

\author{
P. Bastian, K. Birken, K. J ohannsen, S. Lang, N. Neuß, H. Rentz-Reichert, C. Wieners 
}

\begin{abstract}
Over the past two decades, some very efficient techniques for the numerical solution of partial differential equations have been developed. We are especially interested in adaptive local grid refinement on unstructured meshes, multigrid solvers and parallelization techniques.

Up to now, these innovative techniques have been implemented mostly in university research codes and only very few commercial codes use them. There are two reasons for this. Firstly, the multigrid solution and adaptive refinement for many engineering applications are still a topic of active research and cannot be considered to be mature enough for routine application. Secondly, the implementation of all these techniques in a code with sufficient generality requires a lot of time and know-how in different fields.

UG (abbreviation for Unstructured Grids) has been designed to overcome these problems. It provides very general tools for the generation and manipulation of unstructured meshes in two and three space dimensions as well as a flexible data layout. Therefore, it can serve on the one hand as a tool for exploring new algorithms and, on the other hand, a whole range of algorithms already implemented can be applied to complex problems.

In this paper, we show the software design structure of UG and explore some of the subsystems in more detail. Finally, we try to illustrate the capabilities of the approach with several non-trivial examples.
\end{abstract}

\section{Introduction}

Over the past two decades, very efficient techniques for the numerical solution of partial differential equations have been developed. Most notably these are:

- use of unstructured meshes for the approximation of complex geometries;

- adaptive local grid refinement in order to minimize the number of degrees of freedom required for a certain accuracy;

- robust multigrid methods for the fast solution of systems of linear equations; - parallelization of these algorithms on MIMD type machines.

Up to now, these innovative techniques have been implemented mostly in university research codes $[2,11,21,4]$ and only very few commercial codes use them, e. g. [22]. The reason for this is twofold. First, the construction of fast and robust iterative solvers is still a problem. Multigrid methods have been applied very successfully in the field of computational fluid dynamics $[16,20,26]$ but the application to problems from nonlinear structural mechanics or multiphase-flow in porous media is still in its infancy.

The second reason is that the integration of all the abovementioned techniques in a single code requires a major coding effort of the order of several tens of man-years. Moreover, the structure of existing codes is often not suited to incorporate all these methods since they require a strong interaction between mesh generator, error estimator, solver and load balancer.

UG (shorthand for Unstructured Grids) has been designed to overcome these problems by providing reusable software tools that simplify the implementation of parallel adaptive multigrid methods on unstructured meshes for complex engineering applications. The heart of UG is its unstructured grid data structure. It allows one to create meshes consisting of triangular, quadrilateral, tetrahedral, pyramidal, hexahedral and prism elements in two and three space dimensions. The mesh data structure is hierarchical and elements can be refined and removed locally.

The geometric data structure is complemented by the algebraic data structure used to represent sparse matrices and vectors. The degrees of freedom can be associated with nodes, edges, faces and elements of the mesh, thus also allowing the implementation of nonconforming, mixed or higher-order finite element discretizations. A large number of linear algebra subroutines, iterative kernels and multigrid components is available. For standard situations, like conforming finite elements, the user does not have to write a single line of code in order to use the multigrid method (even for systems of partial differential equations). The implementation of discretization schemes is simplified by a large collection of routines providing shape functions and their derivatives, quadrature formulas, finite volume constructions etc.

UG is intended primarily to be a tool to explore new discretization schemes, solvers and error estimators. A powerful graphical user interface can help to reduce development time significantly. UG has a built-in shell with command interpreter and allows the user to open any number of windows on his screen. Meshes, contour lines, color plots and vector plots can be displayed in two and three dimensions. Hidden line removal in 3D efficiently uses the hierarchical data representation.

A further great advantage of UG is its support for parallelism. The experiences from a first parallel version described in [4] have led to a new programming model DDD that can be used for the parallelization of applications with graph-like data structures as described in [8]. DDD is the basis of the parallel UG version but can be used independently of it. UG will allow a very smooth transition from sequential to parallel computation.

The rest of this paper is organized as follows. The next section gives a short introduction to local multigrid methods on unstructured meshes, since this is the mathematical basis of UG. Then the software tools provided by the UG library are explained in more detail. Finally, results obtained with some of the problem classes listed above are used to demonstrate the power of our approach.

\section{Local multigrid methods}

The standard multigrid method (see e. g. [14]) can be applied to unstructured grids and local refinement, but it must be modified in order to avoid a deterioration of the complexity of the algorithm. In particular, the smoothing process must be performed only in the refined region. The minimal requirement is the smoothing of all new points on the finer levels. This is analyzed for an additive multigrid variant by Y serentant [27] and for the corresponding multiplicative variant by Bank-Dupont-Y serentant [3]. Here, the convergence rates depend on the number of levels. Optimal complexity can be obtained by the additive multigrid method with smoothing on all refined elements by BramblePasciak-Xu [10] and its multiplicative counterpart BramblePasciak-Wang-Xu [9] (see [5] for a discussion of the different approaches). Here, we explain in detail the concept which was realized by Bastian [4] and which forms the basis of UG. We use a multiplicative multigrid method with smoothing in a slightly enlarged refined region. Up to now, this is the only way of obtaining optimal complexity combined with robustness for a wide range of applications.

\subsection{Grids and multigrids}

A grid is a closed polygonal or polyhedral set and a decomposition into elements. We consider triangular and quadrilateral elements resp. tetrahedrons, pyramids, prisms and hexahedrons. For an element $E$ the corresponding domain in $\mathbb{R}^{d}$, $d=2,3$ is denoted by $\Omega(E)$ and the boundary is denoted by $\partial E$. A grid is consistent, if $\partial E \cap \partial E^{\prime}$ is empty, a common node (corner), a common edge or a common side for all elements $E \neq E^{\prime}$.

Let $\Omega \subset \mathbb{R}^{d}$ be a domain. A multigrid $\mathscr{F}=\left\{\Omega_{0}, \Omega_{1}\right.$, $\left.\Omega_{2}, \ldots, \Omega_{k}\right\}$ is a sequence of consistent grids approximating $\Omega$. The set of elements is denoted by $\mathscr{O}_{l}, l=0, \ldots, k$. Ele ments of different grids will be distinguished. For $l>0$, we assume that there exists a father element $\mathscr{F}(E) \in \mathscr{O}_{l-1}$ for all elements $E \in \mathscr{E}_{l}$. In general, $\Omega(E) \subset \Omega(\mathscr{F}(E))$, but this property will be violated near curved boundaries. For $F \in \mathscr{O}_{l-1}$, let

$$
\mathscr{S}(F)=\left\{E \in \mathscr{E}_{l} \mid \mathscr{F}(E)=F\right\}
$$

be the set of son elements of $F$. The refinement of an element $F$ to $\mathscr{S}(F)$ can be of type regular, irregular or copy. The application of a refinement rule results in the generation of elements of the corresponding type, e. g. application of an irregular refinement rule to $F$ results in $\mathscr{S}(F)$ being irregular elements. For copy elements, we trivially have $\Omega(F)=\Omega(\mathscr{S}(F))$.

The global refinement algorithm conforms to the following rules:

1. all elements of $\Omega_{0}$ are regular;

2. regular and irregular refinement may be applied only to regular elements;

3. the copy rule may be applied to any element.

For a complete discussion of the refinement rules and the refinement algorithm cf. Sect. 3.3. The copy elements are needed in order to cover the domain $\Omega$ on all levels. Most of the copy elements can be omitted in the final implementation as will be explained below. In the following, we will speak of an element as refined if it is refined either regularly or irregularly (but not copy).

\textbf{Example} 1. Multigrid for the unit $\Omega=\left\{x \in \mathbb{R}^{2} \mid\right.$ $|x|<1\}$.

![](https://cdn.mathpix.com/snip/images/Nyp7W1UIGMQEu7mG3NSQkNrwwMytz1KwcAkAHhWiES0.original.fullsize.png)

\subsection{Geometrically based data}

We assume that a linear problem is given on $\Omega$ and that we can define a finite dimensional solution approximating the continuous solution on $\Omega$ for every grid approximating $\Omega$. Therefore, vectors and matrices have to be defined on every grid. For simplicity, we explain only the case where the unknowns are assigned to the nodes. The set of nodes on level $l$ is denoted by $\mathscr{R}$. We call $P \in \mathscr{R}$ point or interpolation point and the position will be denoted by $\operatorname{pos}(P)$. The points on different levels will be distinguished, but they may have the same position. The corners of an element $E$ are denoted by $\mathscr{P}(E)$. In general, father points cannot be defined for refined elements, but for all points $P \in \mathscr{P}(E)$ on copy elements $E$ there exists a well defined father point $\mathscr{F}(P)$. Furthermore, $n[P]$ denotes the number of degrees of freedom associated with $P . n[E]=\sum_{P \in \mathcal{P}(E)} n[P]$ resp. $n_{l}=\sum_{P \in \mathscr{R}} n[P]$ denotes the number of degrees of freedom per element resp. in $\Omega_{l}$.

Let $\mathscr{F}=\left\{\Omega_{0}, \ldots, \Omega_{k}\right\}$ be a multigrid and let

- $x_{l} \in \mathbf{R}^{n_{l}}$ be a vector for the grid on level $l$, 

- $x[E] \in \mathbf{R}^{n[E]}$ the restriction to an element $E \in \mathscr{E}_{l}$ and 

- $x[P] \in \mathbf{R}^{n[P]}$ the restriction to an interpolation point $P \in \mathscr{P}_{i}$ .

On the grid of the top level $\Omega_{k}$, the discretized problem

$$A_{k} x_{k}=b_{k}$$

is given by the global stiffness matrix $A_{k} \in \mathbb{R}^{n_{k} \times n_{k}}$ and the global right-hand side $b_{k} \in \mathbb{R}^{n_{k}}$, the global solution vector is denoted by $x_{k}$. For example, a finite element discretization is constructed from element stiffness matrices $A(E)$ and element right-hand sides $b(E)$. The global stiffness matrix $A_{k}$ and the global right-hand side vector $b_{k}$ are assembled from $\sum_{E \in \mathscr{E}_{k}} A(E)$ resp. $\sum_{E \in \mathscr{X}_{k}} b(E)$ and a modification due to boundary conditions for some points $P \in \mathscr{P}\left(\partial \Omega_{k}\right)$. For the lower levels $l<k$, we only need the stiffness matrix $A_{l}$, because in a multigrid algorithm, auxiliary problems $A_{l} c_{l}=d_{l}$ are solved, where the right-hand side is replaced by the defect $d_{l}$ and the solution vector is replaced by the correction vector $c_{l}$.

Given two interpolation points $P$ and $Q$, the submatrix $A[P, Q] \in \mathbb{R}^{n[P] \times n[Q]}$ is constructed from all matrices $A(E)$ where $P, Q \in \mathscr{P}(E)$. Here, we only consider discretizations where $A[P, Q]=0$ if there is no element with $P, Q \in \mathscr{P}(E)$

\subsection{Grid transfer}

For multigrid methods, the grid transfer is essential for the coupling of values on different levels. In general, the interpolation from level $l-1$ to level $l$ is given by matrices $I_{l} \in \mathbb{R}^{n_{l} \times n_{l-1}}$. Locally, the submatrices $I[E] \in \mathbb{R}^{n[E] \times n[F]}$ and can be constructed by pointwise multilinear interpolation from a father element $F$ to a son element $E \in \mathscr{S}(F)$. Thus, the interpolation is a local operation and $I[P, Q] \neq 0$ only if there is an element $E \in \mathscr{E}_{l}$ such that $P \in \mathscr{P}(E)$ and $Q \in \mathscr{P}(\mathscr{F}(E))$. Usually, the grid transfer from a fine level to a coarse level will be defined by the transposed matrix $R_{l}=I_{l}^{T}$. Furthermore, the stiffness matrices on the coarser levels can be computed by $A_{l-1}=R_{l} A_{l} I_{l}$. Various concepts exist for adapting the grid transfer and the coarse grid matrix to varying diffusion constants or dominating convection.

\subsection{Vector classes}

In the implementation of multigrid methods on locally refined grids, the solution on higher levels will be computed for refined elements only. In addition, we require that the defect computation and the smoothing can be performed on every level without reference to lower levels. Therefore, we build local grids with all refined elements and some copy elements. For the precise definition, the concept of vector classes will be introduced.

The vector classes are defined recursively:

- set $\operatorname{cl}(P)=3$, if there exists a refined element $E$ such that $P \in \mathscr{P}(E)$ 

- $\operatorname{set} \operatorname{cl}(P)=2$, if $\operatorname{cl}(P) \neq 3$ and if there exists an element $E$ such that $P, Q \in \mathscr{P}(E)$ and $\operatorname{cl}(Q)=3$ 

- set $\mathrm{cl}(P)=1, \quad$ if $\operatorname{cl}(P) \neq 2, \operatorname{cl}(P) \neq 3$ and if there exists

- set an element $E$ such that $P, Q \in \mathscr{P}(E)$ and $\operatorname{cl}(Q)=2$

- set $\operatorname{cl}(P)=0 \quad$ for all remaining points $P \in \mathscr{R}$.

A vector $x_{0}, x_{1}, \ldots, x_{k}$ is consistent, if $x[P]=x[\mathscr{F}(P)]$ for all points with $\operatorname{cl}(P)<3$. Analogously, a matrix $A_{0}, A_{1}$, $\ldots, A_{k}$ is consistent, if $A[P, Q]=A[\mathscr{F}(P), \mathscr{F}(Q)]$ for all points with $\operatorname{cl}(P)<3$ and $\operatorname{cl}(Q)<3$. By construction, the stiffness matrix $A$ and the right-hand side $b$ are consistent.

Let $x_{0}, \ldots, x_{k}$ be consistent and $d_{l}=b_{l}-A_{l} x_{l}$ the defect. If $x_{l}[P]$ for $\operatorname{cl}(P)=3$ is changed, the new defect will change for points $P$ with $\operatorname{cl}(P) \geq 2$. In order to compute the new defect, one needs $x_{l}[P]$ for all points with $\operatorname{cl}(P) \geq 1$. This motivates the following definition: the local grids $\Omega_{l}^{\text {loc }}$ are the smallest subsets of the surface grids $\Omega_{l}$, such that $P \in$ $\mathscr{P}\left(\Omega_{l}^{\mathrm{loc}}\right)$ for all $P$ with $\operatorname{cl}(P) \geq 1$, i.e.

$$
\mathscr{E}\left(\Omega_{l}^{\mathrm{loc}}\right)=\left\{E \in \mathscr{S}_{l} \mid \operatorname{cl}(P) \geq 2\right. for some \left.P \in \mathscr{P}(E)\right\}
$$

On the base level we have $\Omega_{0}^{\text {loc }}=\Omega_{0}$.

\textbf{Example} 2. We consider a discretization where the interpolation points are built by the set of all nodes. Then, the surface grids of example 1 define the following local grids.

The points on the base level get class 3 . Here, all points on level 1 get class 3 too. On the local grid $\Omega_{2}^{\text {loc }}$, the points $P_{25}, P_{29}, P_{30}, P_{31}, P_{32}, P_{33}, P_{34}, P_{39}$ get class 3 , the points $P_{23}, P_{24}, P_{27}, P_{28}, P_{38}, P_{40}$ class 2 and the points $P_{26}, P_{35}, P_{36}, P_{37}$ class $1 .$ The son of point of $P_{9}$ in $\mathscr{R}$ is of class 0 , but this point and the corresponding two elements will not be copied to $\Omega_{2}^{\text {loc }}$.

The local multigrid method will be defined such that the solution vector $x_{0}, \ldots, x_{k}$ and the correction $c_{0}, \ldots, c_{k}$ are always consistent. If the stiffness matrix $A_{l}\left[\Omega_{l}^{\mathrm{loc}}\right]$ and the right-hand side $b\left[\Omega_{l}^{\mathrm{loc}}\right.$ ] are assembled on the local grids, they are not consistent. Thus, $b[P]$ and $A[P, P]$ 
for $\operatorname{cl}(P) \leq 1$ must not be used on local grids. Nevertheless, the defect $d_{l}=$ $b_{l}-A_{l} x_{l}$ on the surface grid can be constructed recursively from the local defects $d\left[\Omega_{l}^{l o c}\right]=b\left[\Omega_{l}^{\mathrm{loc}}\right]-A\left[\Omega_{l}^{\mathrm{loc}}\right] x\left[\Omega_{l}^{\mathrm{loc}}\right]$ 


$$
\begin{aligned}
\text { for } l=1, \ldots, k \text { set } & d_{l}[P]=d\left[\Omega_{l}^{l o c}\right][P] \text { for cl }(P) \geq 2 \text { and } \\
& d_{l}[P]=d_{l-1}[\mathcal{F}(P)] \text { for cl }(P)<2
\end{aligned}
$$

We do not need the values $d_{l}[P]$ for $\operatorname{cl}(P)<2$; they will be set to zero in the smoothing step. Therefore, the restriction of $d_{l}$ must not change $d_{l-1}[Q]$ for $Q \in \mathscr{T}_{l-1}$ such that $\operatorname{cl}(\mathscr{S}(Q))<2$. For a simple notation, we set $\operatorname{ncl}(Q)=\operatorname{cl}(\mathscr{S}(Q))$ if $\mathscr{S}(Q)$ is a point on a copy element and $\operatorname{ncl}(Q)=3$ if $Q \in \mathscr{E}(\mathscr{F}(E))$ for a refined element $E$. Then, the set of points where $d_{l-1}[Q]$ can be changed get $\operatorname{ncl}(Q) \geq 2$

\subsection{Smoother and solver}

We formulate the multigrid method for the surface grids, but all steps will be defined such that only points on the local grids are used. The basic step on every level is the smoothing.

$$
\begin{array}{r}
\mathrm{S}\left(\mathrm{c}_{1}, \mathrm{~d}_{1}\right)=\left\{\begin{array}{l}
\text { set } \mathrm{d}_{l}[\mathrm{P}]=0 \text { for } \mathrm{cl}(\mathrm{P})<2 \\
\text { solve } W_{1} w_{l}=\mathrm{d}_{1}, \\
\text { set } w_{l}[\mathrm{P}]=0 \text { for } \operatorname{cl}(\mathbf{P})<3 \\
\mathrm{~d}_{1}:=\mathrm{d}_{l}-A_{1} w_{l}, \\
\left.c_{l}:=c_{l}+w_{l}\right\}
\end{array}\right.
\end{array}
$$

The solution process of the equation $W_{l} w_{l}=d_{l}$ should be local, e. g. $W_{l}=\operatorname{blockdiag}\left(A_{l}\right)$ or $W_{l}=L U$ (incomplete LU decomposition).

A `multigrid cycle` is defined recursively and combines the grid transfer and several smoothing steps. The cycle depends on the parameters $\theta<1, \nu_{0}+\nu_{1} \geq 1$ and $\gamma \geq 1$

![](https://cdn.mathpix.com/snip/images/L8qE5VasFRkPTHtvYSnkGPieorcnI-n5YAGc2HsbnK8.original.fullsize.png)

Now, we can define a multigrid solver.

![](https://cdn.mathpix.com/snip/images/9OVSnipmR7fETOTlQrKTVn-OFkitJ5j7XKtgliZIhO4.original.fullsize.png)

Here, no update of the defect is necessary because after every multigrid cycle the equality $d_{k}=b_{k}-A_{k}\left(x_{k}+c_{k}\right)$ holds. The defect computation and the update of the solution are global operations on the surface grid which can be constructed of local operations using vector classes.

\section{The UG library}

A large software system like UG is usually described at a number of different levels of abstraction. In this chapter, we move through this hierarchy from top to bottom where, on the lower levels, we will focus on a few essential parts due to space limitations. UG knows three design levels which are called architectural design, subsystem design and component design.

At least on the architecture and subsystem level, UG is a modular design and the information hiding principle is used extensively. All state information is distributed among the subsystems. UG is implemented in the $\mathrm{C}$ programming language.

\subsection{Architecture design}

The highest level of abstraction in UG is the architecture design level shown in 

\textbf{UG Library}

The UG library is completely independent of the partial differential equation to be solved. It provides the geometric and algebraic data structures and a huge number of mesh manipulation options, numerical algorithms, visualization techniques and the user interface.

\textbf{Problem Class Libraries}

This part provides discretization, error estimator and, if required, non-standard solvers for a particular set of partial differential equations.

\textbf{Applications}

The application finally provides the domain description, boundary conditions and coefficient functions in order to complete the problem description. A simulation run is typically controlled by a script file that is interpreted by UG's user interface.

\subsection{UG library subsystem design}

Each of the building blocks of the architectural design is decomposed into several subsystems. The subsystems of the UG library are shown in Fig. 2. We now give an informal specification of the services provided by each subsystem. Some of the subsystems will then be explained in more detail in the next subsections.

![](https://cdn.mathpix.com/snip/images/mnOY4dKYy3z2dIvoC9pE_gHPIL6lZvU_2tHZVGSJfpo.original.fullsize.png)

\textbf{Usser Interface}

The user interface provides the user with a "shell-like" command language. All operations of the UG library can usually be executed either via a command typed into the shell or by calling a $C$ function within the code. A scripting language is available to control complex simulation runs. Multiple graphics windows can be opened to visualize simulation results. In two space dimensions the mesh can be manipulated interactively. The user interface is based on the portable device interface described below.

\textbf{Graphics}

The graphics subsystem provides some elementary visualization methods like mesh plots, contour plots, color plots or vector fields. In three dimensions planar cuts and hidden line removal have been implemented. The advantages of an integrated graphics package are that no intermediate data files have to be written and also that information like matrix structure and entries can be displayed easily. The graphics subsystem is described in more detail below.

\textbf{Numerics}

The numerics subsystem provides numerical algorithms in a modular form ranging from basic linear algebra (level 1 and 2) up to methods for the solution of nonlinear time-dependent partial differential equations. In addition, it provides support for the discretization process, e. g. quadrature rules. The numerics subsystem is described in more detail below.

\textbf{Grid Manager}

The grid manager subsystem provides the unstructured mesh and sparse matrix data structures together with functionality for their manipulation. This includes the generation of two- and three-dimensional simplicial triangulations. The grid manager is explained in more detail below. Domain Manager

The purpose of the domain manager is to provide functionality for the description of general two- and threedimensional domains as well as functions on the surface (boundary conditions) and the interior (coefficients) of a domain. The general approach is that a $d$-dimensional domain $\Omega$ is described by its boundary $\partial \Omega$ which is a $d-$ 1-dimensional hypersurface. This is very natural in the context of partial differential equations since boundary conditions have to be provided anyway. The standard way of describing the boundary is through local maps $f_{i}: \mathbb{R}^{d-1} \rightarrow \mathbb{R}^{d}$ with $i=1 \ldots n$ and $n$ the number of patches. Another approach consists of decomposing the boundary in a number of patches where each patch is given by a simplicial surface mesh. In that case, no easy mapping $f_{i}$ exists for a patch. The domain interface will also be used to access CAD data.

\textbf{Device Manager}

The device manager provides a default device called "screen" that allows at least basic character input/output. Optionally, the screen device also has interactive graphics capabilities. The screen device has been implemented for the standard C library, X11, remote X 11 (uses socket communication and an X11 capable daemon on a remote machine), and Apple Macintosh. Write only graphical output is available in postscript and a binary format ("metafile").

\textbf{Low} 

This subsystem provides some basic functionality like memory management, a simple database tool and portable file input/output. Furthermore, some debugging tools are included.

\textbf{Load Balancer}

The load balancer subsystem is intended to solve graph partitioning and scheduling problems that arise when mapping data must be mapped to processors in a parallel environment. The current implementation uses Chaco [15, 17] for that purpose.

\textbf{Dynamic Distributed Data (DDD)}

The DDD subsystem implements a new parallel programming model that is especially suited for managing distributed "graph-like" data structures. Data objects can be created, deleted and transferred between processes easily. Communication among distributed objects is supported in a flexible and efficient way. This subsystem is explained in more detail below.

\textbf{Parallel Processor Interface (PPIF)}

PPIF is a portable message passing interface used by DDD. It has been implemented for PVM, MPI, PARIX, NX and the T3D/T3E. PPIF has very little overhead when used with fast native communication (e. g. shared memory get/put on the T3D).

\subsection{The grid manager subsystem}

Each subsystem is decomposed into components. Components are typically implemented in a single file or a few files. Figure 3 shows the component design of the grid manager subsystem. The main components are coarse-grid generation, refinement and derefinement of a hierarchical multigrid structure and provision of standard shape functions for various element types. Automatic coarse-grid generation is currently only possible for simplicial grids. For the threedimensional case, the grid generator of $\mathrm{J}$. Schöberl [23] has been connected to UG.

![](https://cdn.mathpix.com/snip/images/xTUIB3aOX9mYFacQGZRUXVY2kVZvRZwjlA4ghIVEf2I.original.fullsize.png)

In the following, we concentrate on two aspects of the grid manager, the unstructured grid data structure and the refinement algorithm.

\textbf{Unstructured grid data structure.}

The heart of UG is its unstructured grid data structure which consists of a "geometric" and an "algebraic" part. The geometric part is elementbased, i. e. all information is locally accessible from the element. The ELEMENT data type is given in Table 2 .

The unsigned integer component control is used bitwise to store various pieces of information such as the element type (triangle, quadrilateral, tetrahedron, etc.), how the element is refined, the number of son elements, etc. The id component gives a globally unique identification for the element which is mainly used by the user interface. All elements of one grid level $l$, i. e. the set $\mathscr{S}_{l}$, are contained in a double linked list implemented by the pred and succ pointers. The $\mathrm{n}[\mathrm{l}$ ] array contains references to the corners of the element, which are of type NODE. The father and son pointers provide access to the father and son elements on the lower and higher grid levels. Note that only one reference to a son element is stored. The remaining son elements can be easily accessed by knowledge of the refinement rule. The $\mathrm{nb}[$ ] array provides access to all neighboring elements over each of the faces (edges in 2D). All algebraic information associated with a single geometric object is stored in a data structure of type VECTOR. The vector component of an element refers to the algebraic information associated with this element. Since UG does not have a data structure for faces in $3 \mathrm{D}$, the algebraic information associated with a face in $3 \mathrm{D}$ is also accessible from the element via the sidevector $[$ ] array. Finally, the bnds $[$ ] array provides access to additional information if one or more faces are part of the domain boundary. The BNDS data type is exported by the domain subsystem. The ELEMENT data structure is generic, i.e. the actual number of pointers depends on the context in which the element is used. The numbers $n c$ and $n s$ are given by the element type. In addition, certain pointers may not exist at all, e. g. bnds [] is omitted for interior elements, sidevector [ ] is omitted if no degrees of freedom in faces are required, etc.

The next data types to be considered in detail are the NODE and VERTEX data types given in Table 3 . The nodes on different grid levels of the multigrid hierarchy are distinguished but, since they often share the same position with nodes on coarser grid levels, the position information is stored in the VERTEX data type which is not duplicated over the levels. The essential information of the VERTEX data type is the global position in its $\mathrm{x}$ component, the position with respect to the next coarser grid level given by its xi and father components and the boundary information in the bndp component. Interpolation from a coarser grid level is done by using a reference to a coarse grid element father that contains the global position and local coordinates $\mathrm{xi}$ within that element. This allows one to move new nodes away from their hierarchical position, e. $g$. to resolve internal boundaries.

The NODE data structure again has a control component holding status information, a globally unique id and pred and succ components implementing a double linked list. The start component points to a single linked list of LINK structures which implements a list of all neighboring nodes in the grid. The father and son components give access to the nodes sharing the same VERTEX structure, given by myvertex on the next coarser and finer grid levels. Finally, vector refers to the degrees of freedom associated with the node.

A linked list of neighbors of a node is realized with the LINK data type shown in Table 4. Each list element contains a control word, a reference to the next list element and a reference to the neighboring node. Since node-neighborship is a symmetric relation, we can combine two LINK structures into an EDGE structure also given in Table 4 . In addition, the EDGE data type contains references to the degrees of freedom associated with the edge and to the new node on the finer mesh obtained by a subdivision of the edge. Note that there is fast access from a given LINK structure to its EDGE and the LINK for the opposite direction.

This completes the description of the geometric part of the data structure. The algebraic part uses a (modified) block compressed row storage format to store matrices and vectors. The vector and matrix blocks are implemented by the VECTOR and MATRIX data types shown in Table $5$ .

The VECTOR data type provides access to the geometric object it is associated with, i. e. an object of type NODE, EDGE or ELEMENT. Additional information in the control word indicates if the vector block is associated with a face of an element. All vector blocks on a grid level are connected by a double linked list allowing easy reordering. The index component contains the block number and the skip component indicates whether a row of the matrix corresponds to Dirichlet boundary conditions and has to be skipped in the grid transfer. The matrix block row associated with a given vector block is accessed via the start component. Finally, the algebraic components are stored in the value [ ] array. Note that the VECTOR data type is generic, i. e. the number of components $n v$ may vary.

The MATRIX data type realizes a block row of the matrix with a single linked list. The diagonal block is always the first block in this list. The number of values $n m$ stored in a single block depends on the type of geometric objects associated with the row and column blocks, i. e. a node-node coupling may contain a different number of components than a node-edge coupling.


Note that there is only one object of type VECTOR per geometric object. The number $n v$ of entries in the value field not only contains the degrees of freedom but also the right-hand side and additional storage needed by the numerical algorithms (defect, correction, last time step, etc.). The same is true also for the MATRIX objects which may actually contain several matrices, e. g. the stiffness matrix and an incomplete decomposition of the stiffness matrix. The numerics subsystem provides a symbolic mechanism for describing vectors and matrices to be used in actual computations. The components of these vectors and matrices are in general subsets of the components stored in the VECTOR and MATRIX data structures.

The mesh data structure is completed by providing access to the various linked lists of elements, nodes, vertices and vectors. The form of the numerical algorithms suggests a level-wise access to the data structure. The GRID data type shown in Table 6 provides this access. Since all the lists are double linked, access to the first and last elements is possible.

All grid levels are then combined in the MULTIGRID data type. It provides access to all grid levels, some status information and the context of the multigrid hierarchy. The component theFormat refers to a structure of type FORMAT which describes the number of DOUBLE values to be reserved in the VECTOR and MATRIX data structures per geometric object. In addition, one can control the interconnection pattern of the VECTOR objects. All memory needed by a multigrid data structure is allocated from a special HEAP implemented in the low subsystem. This memory manager is especially suited to manage many small objects efficiently. Finally, each MULTIGRID data structure refers to a description of a boundary value problem (domain, boundary condition, coefficient functions) of type BVP which is exported by the domain subsystem.

One may argue that this unstructured grid data structure requires a lot of memory. This is certainly true if one considers scalar model problems. However, if we consider complex three-dimensional applications, most of the memory is occupied by numerical data. To illustrate this, consider the two-phase flow application presented in the next section. The three-dimensional simulation on a 32 by 32 by 32 hexahedral mesh requires $102 \mathrm{MB}$ of memory. $66 \mathrm{MB}$ are occupied by the entries of the stiffness matrix, the ILU matrix and the unknown and auxiliary vectors.

\textbf{The refinement algorithm}

From the discussion in Sect. 2 it is clear that a multigrid sequence $\mathscr{T}=\left\{\Omega_{0}, \Omega_{1}^{l o c}, \Omega_{2}^{l o c}, \ldots\right.$ $\left.\Omega_{k}^{\text {loc }}\right\}$ should satisfy the following properties:

- nestedness: Each element $E$ on a grid level $l>0$ has a unique father element $F=\mathscr{F}(E)$ with $\Omega(E) \subset \Omega(F)$. As far as the code is concerned this inclusion is not necessary but then additional conditions for stability are needed;

- consistency: Each (local) grid level $\Omega_{l}^{\mathrm{loc}}$ is a consistent grid (see definition in Subsect. 2.1);

- stability: All interior angles must be uniformely bounded away from zero.

The refinement algorithm works with a variety of element types and refinement rules. In general, a refinement rule applied to an element $E$ allows $\Omega(E)$ to be retriangulated by using the corners, edge centers, face centers and the element center of $E$. All element types can be used for this purpose. Regular refinement rules are those that are stable when applied successively. Figure 4 shows regular refinement rules for various element types. For tetrahedrons, the regular refinement strategy of Bey [6] is used. In contrast to the other element types, the four-sided pyramid can not be subdivided by using pyramids only. It is subdivided into 6 pyramids and 4 tetrahedra.

If only regular refinement rules are applied, the resulting grids are automatically consistent. This is in contrast to bisection type refinement strategies in three dimensions (cf. [19]). If only some elements are refined regularly, the consistency of the grids must be ensured by matching edge and face refinement patterns in the transition region. This is achieved by introducing irregular refinement rules which may decrease interior angles. The refinement algorithm in UG works with a full set of refinement rules, i. e. there always exists a refinement rule matching any edge and face refinement pattern. For the two-dimensional case and the simplicial case in three dimensions, the number of rules is so small that they can be stored in a data base. In the other cases, an appropriate rule is generated on demand by connecting the element center with quadrilaterals and triangles on the faces, resulting in pyramidal and tetrahedral elements [18]. Due to the full set of refinement rules, no iteration is required to find the consistent closure which is especially useful in the parallel version.

Overall stability is ensured by allowing only regular elements to be refined. If irregular elements must be refined, they have to be replaced by regular elements first which in turn must be consistent with neighboring elements. It is the task of the global refinement algorithm to match the refinement requested by the error estimator with consistency and stability. Below we give a high-level version of the global refinement algorithm. As input this algorithm receives a multigrid hierarchy $\mathscr{T}$ where the leaf elements (those without sons) have been tagged with a desired refinement rule or a coarsening tag. If all sons of an element are tagged for coarsening, they are deleted from the data structure. Of course, only leaf elements can be removed, since coarsening should be an inverse operation to refinement.

![](https://cdn.mathpix.com/snip/images/--RV8mBtseWYTfxgPMkhBwg8DNK-qIzC9qnd7XLgrv4.original.fullsize.png)


The overall structure of algorithm RefineMultiGrid resembles a multigrid V-cycle. The first for-loop (1) proceeds from the top level $k$ to level 1. No manipulation of the data structure is done in this first loop, only the refinement tags are manipulated! The function MakeConsistent computes a consistent grid for level $l+1$ by tagging elements of level $l$ with a consistent set of refinement rules. Function RestrictTags computes the influence of level-l-tags on level-l-1tags. This is where irregular refinement rules are replaced by regular refinement rules if necessary. In the second forloop starting in line (4), the data structure is actually modified proceeding from coarse to fine levels. When the second loop is entered in line (5), the grid on level $l$ has already been modified and level $l+1$ is constructed from the tags stored on level $l$. Again MakeConsistent is called to compute consistent tags in line (5); then DetermineCopies computes the algebraic classes which in turn determine the copy elements required on level $l+1$. The function RefineGrid in line (7) actually modifies the data structure, i. e. appropriate objects are created/deleted on level $l+1$ and pointers are set correctly. After completion the funtion RefineMultiGrid has constructed a new multigrid hierarchy. The top level of this hierarchy may be either $k-1, k$ or $k+1$. The level-wise structure of the algorithm is very well suited to parallelization as is shown in [4]. Figure 5 shows a cut through a locally refined ball triangulated with pyramidal elements and a torus.

\subsection{The DDD subsystem}

In order to exploit the power of parallel computers for UG applications, the grid manager subsystem is extended to handle grids which are distributed across the processor's local memories. Given the complexity of the data structures involved and their dynamic changes because of grid refinement and load balancing, straightforward usage of messagepassing programming models will certainly be doomed to failure due to the lack of abstraction of communication and distribution methods. Therefore, an abstract programming model supporting high-level operations on the distributed grid data has been designed and integrated into the UG library. From the architecture's viewpoint this Dynamic Distributed Data (DDD) model is implemented as a UG subsystem; a standalone version is nevertheless available in order to allow parallelization of other applications as well.

The basic abstraction DDD supports is the notion of distributed graphs. The graph nodes correspond to those application's data structures, which should be distributable on different processors (DDD objects); the graph edges represent references between the data structures (cf. formal specification document [8]). Distributed objects are used to couple several local graphs (one for each processor) in order to build the distributed graph. The DDD library implementation contains three components with different functionality described in Table 7 , which can be used to manipulate the distributed graph structure and to invoke efficient communication procedures (see the DDD Reference Manual [7] for a detailed description).

Concerning the UG parallel grid manager, the following data types are regarded as DDD objects:

\textbf{ELEMENT} : Elements are the central data structures for distributed grids. As a result of dynamic load balancing, the elements are marked with a destination processor. A grid migration algorithm executes the redistribution of the grid by calling DDD commands from the Transfer component. The redistribution of all other data types depends directly on the element migration. The grid overlapping strategy is formulated in terms of Master and Ghost elements.

\textbf{NODE}: The overlapping of nodes in a distributed grid depends on the element overlapping scheme. Three kinds of nodes exist: Master, Border and Ghost nodes. For the identification of newly created nodes (during adaptive refinement), the DDD Identification component is used.

\textbf{VERTEX}: The replication of vertices is directly linked with the replication of the corresponding nodes. DDD provides mechanisms which allow the expression of this dependency in a simple way.

\textbf{VECTOR}: The distribution of this algebraic data type also depends on the element distribution. As each vector is coupled with its copies on other processors, the DDD Interface component can be used in order to make vectors consistent which have been stored in an inconsistent manner before. Typically this is done from the numerics subsystem by invoking a DDD Interface communication with three parameters: the size of data which should be communicated for each VECTOR data structure, a gather-procedure which copies the data from the VECTOR structure into the message buffer, a scatterprocedure which integrates the data from the message buffer into the VECTOR.

By using DDD the parallel grid manager is the same as the sequential one, both in terms of its usage interface and its program code. The former is advantageous for a clear algorithmic and hierarchical abstraction, the latter is necessary with respect to ongoing code development and maintenance. A part from the grid manager subsystem, noticeable code adaptions have been necessary only for the numerics subsystem; hence, any sequential UG application using standard numerical techniques can use all the advantages of state-of-the-art parallel computing without additional effort for parallelization.

\subsection{The graphics subsystem}

The graphics subsystem in UG provides some elementary visualization methods as well as some interactive tools. Depending on the capabilities of the device manager, the graphical output is displayed on an X11 window, written to a binary metafile format or to a postscript file ("devices"). An arbitrary number of windows can be opened on different devices simultaneously.

The basic objects in the graphics subsystem are the plotobjects (represented by the structure PLOTOBJ) and the work (represented by the structure WORK). Plotobjects are representations of (abstract) objects, for example meshes (2D/3D) or the graph of a sparse matrix (2D). They contain a reference to the multigrid structure serving as a database. Different methods can be applied to plotobjects. The simplest is the draw method, which displays a plotobject. Others are able to change the plotobject's configuration like the findrange method, changing, for example the color range of a plotobject containg the evaluation of a scalar-field. Again, other methods can change the state of the underlying database (i.e. multigrid structure) like the movenode method.

Table 8 lists the plotobjects available and gives a short description of them. Table 9 lists the methods implemented in UG together with a short description. Note that not every method can be applied to every plotobject. Finally, Table 10 describes the three components of the graphics subsystem in more detail.

\subsection{The numerics subsystem}

The numerics subsystem in UG offers a wide range of numerical tools for computations with vectors and matrices in the geometrical based data structure of the grid manager (cf. Sect. 2.2). All algebraic objects can be described and referenced by abstract symbols in UG-scripts.

Using scripts the numerical components can be freely configured, e. g. the cg method can use a multigrid cycle as a preconditioner, the multigrid cycle can use all types of smoothers and grid transfers. This linear solver can be called in a Newton method, which can be applied in every time step. Thus, for a typical time-dependent nonlinear problem, the user only provides the assembling routines for the defect computation and the assembling of the stiffness matrix for the linearized problem on element level. A general-purpose hierachical error indicator is provided for time-dependent grid adaption, but to obtain the optimal grid, a problem dependent error estimator is usually required. For the flexible combination of the components on script level, we developed the concept of numerical procedures.

In many cases, the problem class and the application do not need any parallel extensions, since all global numerical operations are included in the UG library. In particular, gather and scatter routines are called in the BLAS routines and in the smoothing procedures.

\section{Applications}

\subsection{The finite element library}

For many applications, the multilinear conforming approximation is not the optimal choice. Particularly, if the solution is smooth and the geometry of the domain is simple and can be resolved on the coarsest grid, the convergence of higherorder elements is far better. Nonconforming and mixed elements can be used in order to reduce locking phenomena in linear elasticity, effective error bounds can be obtained by higher-order mixed elements and fourth-order problems can be approximated by $C^{1}$-elements.

In UG, a general finite element library is realized [25]. Therefore, we consider interpolation points $\mathscr{P}$ on nodes, edges, faces and elements.

This list can be easily extended: essentially, the assembling of the local stiffness matrices $A(E)$ and the local interpolation matrices $I(E)$ must be implemented for every discretization, then all other tools can be applied.

First, we compare the discretizations for a scalar test problem in a reentrant corner domain. 

![](https://cdn.mathpix.com/snip/images/V4L6neMMFGU3p6b0kyrkHdpQt4PlfdPHcsB2m63UNak.original.fullsize.png)



Here, the refinement strategy ensures an optimal order of convergence in all cases (cf. Table 13).

The next example demonstrates the approximation of a diffusion problem with varying coefficients.

Finally, we give an example in linear elasticity with timedependent surface load. Here, a grid consisting of hexahedrons, pyramids and tetrahedrons is refined and coarsened simultaneously. It is plotted for three subsequent time steps.

\subsection{Density-driven flow in porous media}

In many cases, groundwater flow in porous media involves the transport of solutes that affect liquid density. If density variations exceed $20 \%$, which occurs near salt domes or bedded salt formations, flow and transport are strongly coupled. The primary coupling arises in the equations through the body-force term of the fluid equation and the advection term of the transport equation. A second coupling arises from the velocity-dependent hydrodynamic dispersion in the transport equation. These couplings cause nonlinearities in the equations that preclude analytical solutions and are a challenge for numerical simulations.

Density-driven flow problems can be described by two nonlinear, coupled, time-dependent differential equations, a continuity equation for the fluid and a continuity equation for the solute transport. The fluid continuity equation is written in terms of pressure, assuming that Darcy's law is valid. Both equations are discretized on vertex-centered finite volumes using different constructions for the control volumes. In cases of dominant convection, an aligned finite volume method, where the finite volumes are aligned to a given velocity, is preferable to the standard finite volume method. Furthermore, a consistent velocity approximation of terms involved in the fluid velocity calculation is implemented. The transient equations are solved with a fully implicit time-stepping scheme with time step control. The nonlinear equations are solved in a fully coupled mode using an approximative Newton multigrid method where the linearized system is solved with a linear multigrid method.

For the problem of seawater intrusion in a coastal aquifer, known as the Henry problem, a semi-analytic steady-state solution by Segol [24] exists and is therefore widely used as a benchmark. However, this problem is not very sensitive with respect to the consistent velocity and description of small transition zones. Figure 6 shows the steady-state $20 \%$, $50 \%$ and $80 \%$ concentration isolines in comparison with the analytic solution and other numerical results $[12,13] .$ The numerical solutions obtained all match the analytical solution very closely.

Another test problem is the so-called Elder problem. A closed rectangular box, modelled in cross section, with a source of solute on the top boundary is considered. We have modified this problem, dividing the domain in five subdomains. In four of the subdomains, the permeability value is reduced by a factor of $10^{3}$ compared to the fifth subdomain. The calculations are done on an unstructered grid with 50849 nodes on the finest grid using the aligned finite volumes. Figure 7 shows the temporal evolution of the salt distribution.



\subsection{Two-phase flow in porous media}

The flow of two immiscible fluids in a porous medium is described by two coupled highly non-linear time-dependent partial differential equations, see [1] for an introduction. These equations play an important role in the development of effective in-situ remediation techniques. Due to the hyperbolic/parabolic character of the equations, strong heterogeneities and high non-linearity, they pose a challenging problem for multigrid solution.

A problem class has been developed that solves the two-phase flow equations in a fully-coupled manner using wetting-phase pressure and non-wetting phase saturation as unknowns. A finite volume and a control-volumefinite-element discretization with first- order upwinding have been implemented. Both discretizations support all element types in two and three dimensions. Time discretization is fully implicit, resulting in a large set of nonlinear algebraic equations per time step. The nonlinear equations are then solved iteratively by a Newton-Multigrid technique. A line search method is used to achieve global convergence. Several multigrid techniques have been implemented in UG to handle coefficient jumps induced by saturation fronts and absolute permeability variations. These jumps are in general not aligned with coarse grid lines. In the simulations below, a multigrid method with diagonal scaling, point-block ILU smoother $\left(\nu_{1}=\nu_{2}=2\right)$ and a $\mathrm{W}$-cycle $(\gamma=2)$ has been used.

Figure 8 shows a saturation plot for the infiltration of a dense non-aqueous phase liquid (DNAPL, a fluid with density higher than water and immiscible with it) into a randomly generated porous medium. The simulation history is shown in Table 14. The table shows that the average and maximum number of multigrid iterations stays bounded with increasing mesh size (and fixed time-step size).

Figure 9 shows saturation iso-surfaces for a threedimensional DNAPL infiltration into a heterogeneous porous medium. A block of low permeability has been inserted into the center of the reservoir. Entry pressure effects prevent the DNAPL from infiltrating the low permeability lense. The multigrid performance for this problem is shown in Table $15 .$ Table 15. Simulation data for 3D infiltration problem

\section{Conclusions}

We described in detail the basic ideas and the software design structure of $\mathrm{UG}$. The concepts and the implementation of most of the subsystems in the UG library are now essentially finished, but the components will be extended further. In future work, we will focus on the different applications and large simulations of complex problems with several million unknowns. Although software design was the main emphasis in this paper, one should have in mind that the development of efficient and robust numerical methods is at least as important. Our work in this direction is illustrated by the numerical examples.

From the point of view of the user concerned with software applicability, we can state that not only a basic code documentation but further a description of concepts and explanations of the theoretical background (both connected with examples) have to be available. Up to now, only basic documentation is provided for UG.

We want to emphasize that the development of this software involves a large group of coworkers and a period of several years. Our experiences during development have shown that it is imperative to include a version control system and debugging tools for efficient software design and coding. A clear definition of internal interfaces between the subsystems and external interfaces (e. g. for domain description, coarse grid generation, visual postprocessing) is essential for maintenance and extendability.

\section{References}

1. Aziz, K., Settari, A.: Petroleum Reservoir Simulation. Elsevier, 1979

2. R. Bank: PLTMG Users Guide Version $7.0$, SIAM, 1994

3. R. Bank, T. Dupont, H. Y serentant: The Hierarchical Basis Multigrid Method, Numer. Math. 52 (1988) $427-458$

4. P. Bastian: Parallele adaptive Mehrgitterverfahren. Teubner Skripten zur Numerik, Stuttgart: Teubner-Verlag, 1996 

5. P. Bastian, G. Wittum: On robust and adaptive multigrid methods. In: P. Hemker, P. Wesseling (eds.): Multigrid Methods IV. ISNM, Basel: Birkhäuser, 1994

6. J. Bey: Tetrahedral grid refinement. Computing $\mathbf{5 5}$ (1995) 355-378 7. K. Birken: Dynamic Distributed Data in a Parallel Programming Environment - DDD Reference Manual. Forschungs- und Entwicklungsberichte RUS-23, Rechenzentrum der Universität Stuttgart, 1994 8. K. Birken, P. Bastian: Dynamic Distributed Data (DDD) in a parallel programming environment - specification and functionality. Forschungs- und Entwicklungsberichte RUS-22, Rechenzentrum der Universität Stuttgart, 1994

9. J. H. Bramble, J. E. Pasciak, J. Wang, J. Xu: Convergence estimates for multigrid algorithms without regularity assumptions, Math. Comp. 57 (1991) $23-45$

10. J.H. Bramble, J. E. Pasciak, J. Xu: Parallel Multigrid Preconditioners Math. Comp. $\mathbf{5 5}$ (1990) 1-22

11. P. Deuflhard, P. Leinen, H. Y serentant: Concepts of an A daptive Hierarchical Finite Element Code. IMPACT of Computing in Science and Engineering, 1 (1989) 3-35

12. H.-J. Diersch: FEFLOW User's Manual Version 4.2., tech. rep. WASY $\mathrm{GmbH}$, Berlin, 1994

13. E. Frind, J. Molson: SALTFLOW $2.0$ User's guide. Waterloo Centre for Groundwater Research, Canada, 1994

14. W. Hackbusch: Multi-Grid Methods and Applications. BerlinHeidelberg-New York: Springer, 1985

15. B. Hendrickson, $R .$ Leland: The chaco user's guide version 1.0. Tech.

Rep. SAND93-2339, Sandia National Laboratory, 1993

16. E. H. Hirschel (ed.): Flow Simulation with High-Performance Compters II. Braunschweig: Vieweg, 1996

17. S. Lang: Lastverteilung für paralle adaptive Mehrgitterberechnungen.

Universität Erlangen-Nürnberg, IMMD III, 1994

18. S. Lang: Adaptive refinement and derefinement of unstructured grid hierarchies. Tech. rep., Universität Stuttgart, Institute for Computer Applications, 1997. In preparation

19. J. M. Maubach: Local bisection refinement for $N$-simplicial grids generated by reflection. SIAM J. Sci. Comput. 16 (1995) 210-227

20. D. J. Mavripilis: Three-dimensional multigrid reynolds-averaged navier-stokes solver for unstructured meshes. AIAA Journal, 33 (1995) 21. L. C. McInnes, B. Smith: PETSc2.0: A case study of using MPI to develop numerical software libraries. In Proc. of the MPI Developers Conference, Notre Dame, IN, 1995

22. M. Raw: A coupled algebraic multignid solver for the $3 D$ navier-stokes equations. In Proc. of the $10^{\text {th }}$ GAMM Seminar Kiel, Notes on Numerical Fluid Mechanics, W. Hackbusch, G. Wittum (eds.) vol. 49 , Braunschweig: Vieweg

23. J. Schöberl: Analysis and realisation of mixed finite element models in computational mechanics. Master's thesis, Universität Linz, 1995 24. G. Ségol: Classic Groundwater Simulations. Englewood Cliffs, NJ: Prentice Hall, 1994

25. C. Wieners: The implementation of adaptive multigrid methods for finite elements. Universität Stuttgart, SFB404 Preprint 97/12, 1997 26. G. Wittum: Multignid methods for Stokes- and Navier-Stokes equations. Numer. Math., 54 (1989) 543-563

27. H. Y serentant: Uber die Ausspaltung von Finite-Element-Räumen in Teilräume verschiedener Verfeinerungsstufen. Habilitationsschrift, 1984