\title{
科学计算的通用软件组件
}

 

\section{Introduction}
这篇论文的起源是自己对开发和重用科学软件的困难的痛苦经历，即使我们工作组中的各个软件所解决的基本数学问题是密切相关的。

事实上，软件开发在几乎所有的计算领域都是一个严重的问题，而在处理偏微分方程的数值解的科学计算分支中，它当然也不容易。这就是本论文的背景，它作为一个主旨贯穿整个工作。然而，所应用的方法和所获得的结果都超出了这个范围。

专门讨论科学计算软件的出版物和会议越来越多，这清楚地表明了问题的重要性。这些困难从何而来，科学计算是否有什么特殊之处？

科学计算领域软件开发的一个主导目标是效率。所解决的问题很大，往往是当前技术所允许的那样大。

这种对效率的压力对软件开发的方法产生了深刻的影响。通常情况下，许多决定是 "硬接线"到代码中的，因此不再是局部的。数据结构和算法是紧密相连的。如果一个经过一段时间成长的工作软件的各个方面要适应新的要求，就会出现重大困难。

显然，由于完整应用程序的规模，从头开始不是一种选择--至少从MCILROYS的愿景[McI68]开始，系统化的软件重用就被提上了计算机科学的议程，但可以追溯到计算机的最早时代[Gol93]。然而，一般来说，成功的情况好坏参半，科学计算也不例外。是什么让重用变得如此困难？

科学计算是一个以算法为主导的领域，计算几何、计算图论或更普遍地归入 "计算科学与工程"（CSE）的领域也是如此。在这些领域中，重用的自然单位往往是一个算法，或小套的算法，与相关的数据结构相结合。不同的应用以独特的方式结合不同的算法选择，以实现其特定的目标。然而，一个特定的算法被整类应用所使用是非常普遍的。

但单一算法的重用是公认的困难。诚然，有许多成功的软件包，专门用于不同类型的PDE解决方案。然而，传统的软件包的组织方式并不允许单一算法的超文本重用。算法的实现必须对它们 "赖以生存" 的数据的表示方式做出某些假设。数据结构越复杂，这些假设就越不稳定，它们跨越当前上下文边界的概率就越低。

因此，只要算法在其开发的狭窄环境之外被重新使用，或者这种环境发生变化，就会出现问题。因此，取代新的、更好的数据结构可能是不可能的；在极限情况下，应用程序的进化可能会面临无法克服的困难，并走到尽头。

本论文的第一个主要贡献是对该问题的深入分析，并制定了一个解决策略。这个解决方案是针对在计算网格上运行的算法的情况而详细制定的。这种网格是数值PDE解决方案的核心，在其他领域也很重要，如计算机图形学或计算几何学。此外，除非采取特殊措施，否则相应的数据结构是足够复杂和多变的，实际上排除了算法的超文本重用。

我们提出的解决方案解决了核心问题，即对特定数据表示的承诺。

这里的主要任务在于识别和描述数据和算法之间的关系。为了达到这个目的，我们从具体的数据结构和算法的细节中退后一步，以获得更广泛的视角。我们选择了`拓扑学`和`组合学`的数学分支来提供概念性框架。它们的精确语言允许以一般的、抽象的方式表达问题领域的基本数学结构，与任何表示问题无关。

在对有代表性的网格算法的回顾指导下，我们随后得出了对数据结构能力的抽象描述。一小套内核概念，很大一部分相关的算法都可以在此基础上进行。

为了将发现的抽象概念转移到工作软件中，采用了通用编程的范式。它已经证明了其对代表相对简单的数学结构的数据结构的有用性和力量，如线性序列和矩阵。核心概念产生了一个小的中介层，将数据和算法分开。我们表明，这种方法导致了高效的实现，其性能接近于直接的、低层次的实现。

因此，实现了网格算法与数据结构的有效解耦。这种解耦将这些算法的可重用性提高到一个新的水平。

本论文的第二个主要贡献是解决平行网格计算的问题。高性能科学计算的一个关键问题是应用程序的并行化。这里的驱动力是需要计算越来越大的问题，或者在较小的程度上，在更短的时间内计算相同的问题。如果不使用并行计算机，许多计算任务是无法完成的。

算法代码的`高效并行化`是一项非同寻常的任务。它既涉及数据结构，也涉及算法。自动方法在这一领域的使用受到限制，因为通常不能通过这种方式获得令人满意的效率。

一个有希望的替代方法是特定领域的方法，这也是近年来许多研究工作的主题。我们在分布式重叠网格的抽象基础上推导出一个新的、通用的概念，用于在任意网格类型上工作的算法的并行化。特别是，我们为非结构化网格上的算法开发了一个新的数据依赖性的特征。基于这一特征，我们提出了一种自动生成网格重叠的新算法。这种方法具有最佳的复杂性，即与重叠的大小成线性关系，并构成了具有重要实用价值的进展。

使用通用方法，算法和数据结构的实现方式与维度和底层顺序网格表示法无关。这些组件在内存消耗和运行时间方面增加了非常低的开销（与重叠的大小成线性关系）。它们极大地减少了开发新的并行应用或并行化现有应用的努力。

大量的组件--其中包括本论文中描述的组件--已经用C++语言实现了。它们的源代码可在网上查阅：http: //www.math.tu-cottbus.de/berti/gral.

这项工作的主体组织如下。在第二章中，我们详细调查了科学计算中软件开发和重用的问题和条件，并指出了网格数据结构在数值PDE解决方案中的基本作用。随后，介绍了通用编程方法，作为对所发现问题的可能解决方案。

第三章专门对网格和网格算法进行了领域分析。首先，对网格的拓扑学和组合学特性进行了详细的分析，然后对几个代表性的算法进行了研究。由此产生的算法要求清单被用作调查网格数据结构差异性和共性的指导原则。

下一章包含了对上述抽象层的开发，导致了一个捕捉基本属性的微内核。然后我们展示了如何在这个内核之上实现一些网格组件，从而形成一个通用的、高度可重用的组件库。

第五章处理并行化问题。首先，介绍了一套数据并行网格计算的抽象概念，包括对非结构化网格上的算法的模版概念的形式化。这个概念封装了算法的基本方面，并允许独立于具体算法制定分布方法。然后，通用方法被用来实现一系列的算法和面向数据的组件，以忠实的方式表示抽象概念，也就是说，不牺牲通用性。这些组件或多或少地完全封装了与数据分配有关的任何技术细节，是通用方法力量的一个令人信服的例子。

第六章对该方法的实际可用性进行了调查。我们展示了通用范式如何被用来构建复杂的应用程序（在这种情况下，一个用于气体动力学双曲方程的有限体积求解器），导致了一种程序家族，以及有限元和多网格算法的一般实现。通过讨论解决不可压缩的纳维-斯托克斯方程的现有应用程序的并行化，我们证明了通用方法与更传统的软件设计方式的无缝整合。

此外，通过评估具有一组小内核的通用程序的性能，我们表明我们的方法导致了高效的代码，可以与C或FORTRAN的低级实现竞争。

最后，对获得的结果进行了讨论，并指出了有希望的进一步研究方向。我们有理由期待，沿着本论文中提出的概念，在算法重用方面可以取得实质性的进展，从而在一般的科学计算软件开发方面取得进展。




\section{An Algorithm-centered Approach to Software Development in Scientific Computing}



在计算机时代之初，在科学计算和计算机科学这两个术语被创造出来的多年前，这两个学科几乎是相同的：计算机的最早应用是在今天被称为科学计算的领域，即密码学和导弹和爆炸波的数值模拟。

从那时起，事情发生了深刻的变化。主流计算机科学已经分叉成众多的分支，其中大多数已经远离了它的根源而发展。科学计算现在被视为一门独立的学科，与计算机科学、数值分析和数学物理与工程相关，但又有别于这些学科，而且就其本质而言是跨学科的。

科学计算的核心是`算法`。自从第一台计算机建成以来，这里已经取得了巨大的进步，不仅是在科学计算领域，而且在计算科学的任何其他以算法为中心的领域。一方面是更强大的算法的发展，拓宽了计算处理的范围，另一方面是越来越多的计算机在科学和商业中的使用所推动的越来越强大的硬件的发展，这两者一直在相互刺激。

然而，算法必须被实施才能展开其力量。而这正是计算机科学和科学计算再次相遇的地方--或者说应该如此。随着科学计算中的应用规模不断扩大，并采用了更多的算法需要更复杂的`数据结构`，构建块的重用--`算法`和`数据结构`--变得越来越必要。一般来说，重用是一个困难的问题；在非线性数据结构上运行的算法的重用也绝不是一个已经解决的问题。在本章中，我们试图找出解决这一挑战的可能方案。

在第2.1节中，我们首先详细解释了软件开发在科学计算中的作用以及它所面临的具体问题。然后，我们展示了在过去的几十年里，所涉及的`算法`和`数据结构`的复杂性是如何增长的，考虑硬件方面的需求是如何促成复杂性的，并为这种发展将在不久的将来继续下去的说法给出一些证据。

软件重用是一个几乎和软件本身一样古老的目标。在$2.2$节中，我们介绍了可重用组件的概念，讨论了与之相关的质量度量和权衡，组件的重用在科学计算实践中如何运作，以及何时失败。我们将看到，当`算法与表现出高变异性的复杂数据结构进行交互`时，很难实现重用。这尤其适用于网格和在网格上工作的算法，这是数值PDE解决方案的核心。

在$2.3$节中，我们介绍了通用编程方法作为该问题的可能解决方案。我们用一个著名的例子（STL）来介绍关键的想法，并指出它们如何成功地应用于基于网格的算法，这个话题在后面的章节中充分探讨。最后，我们回顾了一些在精神上相似的可重用通用组件的方法，并简要地指出了软件工程和编程领域的最新发展，这些发展可能对科学计算有兴趣。

\subsection{The Challenges of Software Development in Scientific Computing}

\subsubsection{Fundamental Issues}

用于物理现象数值模拟的软件（如PDEs的求解）不是大规模制造的。它通常是由领域专家自己编写的，也就是说，由对所涉及的数值分析有足够了解的人编写。在极端情况下，领域专家、软件设计师、程序员、测试员和最终用户是同一个人；在任何情况下，这些角色往往比主流计算中的角色重叠得多。

当软件的目的是验证新的算法和方法，或研究尚未理解的物理现象时，情况尤其如此。那么只有少数人对数值或物理背景有必要的了解。对于工程应用的科学软件来说，这一点就不那么严重了，因为在这些软件中，物理和数值技术可以被更多的人使用。

另一方面，科学软件的程序员是数值算法或数学建模的专家，他们往往缺乏软件工程师或计算机科学的正式教育。随着越来越多具有计算机科学背景的人进入这一领域，这种情况开始发生变化，但人们仍然可以看到对软件工程和现代编程范式的成就持某种保守的态度。这部分是由于主流计算机科学对数字错误和实际效率等问题缺乏兴趣，下面将讨论这些问题。这些困难在原则上可能会持续存在，因为科学计算本质上是一个跨学科的领域，所有涉及的学科的专业知识都是根本不存在的。

数值软件的测试和验证的一个主要问题是，错误往往不是那么明显地被发现。首先，可能已经需要大量的经验来判断一个结果是否是错误的，如果是的话，这是否是一个编程错误，一个错误的参数选择或一个不合适的算法。此外，错误可能会 "爬 "到解决方案中，在计算了几个小时后才变得明显，这时导致错误的数据可能已经不存在。这种类型的连续或数字错误在计算的其他分支中并不常见。

此外，一个典型的程序运行涉及大量的数据被创建和处理。这使得检测错误的变量值变得很困难，特别是当它们没有物理解释，而且问题不能被任意缩小的时候。攻击这个问题的方法包括图形[SR97]或比较[MA97]方法。正在生成和处理的大量数据集本身就是一个问题。必须保存在机器内存中的数据可能是一个人可以处理的问题规模的限制因素；产生的数据规模可能远远超过一个人可以永久保存的数据量。

在内存和CPU时间方面的效率是数值模拟的主要质量因素，在这里，它比主流计算更重要。通常情况下，数值问题的大小可以随意放大，从而更好地逼近小规模的特征。限制因素是计算资源和一个程序对其的有效利用。因此，从实用的角度来看，一个非常高效的应用程序可以提供更多的功能，因为可以处理更大或更有趣的问题。另一方面，对于一个典型的问题设置，往往有一种最小的近似大小，低于这个大小的计算就没有什么用处，例如，迭代可能会发散。这意味着一个非常低效（1-2个数量级）的程序只能解决 "toy问题"。

科学计算中使用的效率概念必须与计算机科学中使用的计算复杂性的概念进行对比。后者解决的是渐进复杂性的问题，通常只给出一个增长率，如$O(n)$，也许还有一个前导项的常数，衡量被认为是中心操作的数量，如排序算法中的比较。复杂性分析给出了算法的一个重要特征，但是对于科学计算的目的来说是不够的，因为在科学计算中，低级别的实现问题可能会导致性能的实际差异达到一个数量级或更多。这是科学计算中软件复杂性的一个因素，我们现在准备讨论这个话题。

\subsubsection{Increasing Complexity}

在下文中，我们将讨论复杂性的四个主要来源。第一，算法的复杂性，通过发明更好的算法和数据结构，第二，由于需要获得有效的实现而产生的复杂性，第三，源于更多的物理学的复杂性，最后，由于对 "软因素" 如用户互动的要求越来越高而产生的复杂性。

\subsubsection{Algorithmic Complexity}

在过去的20年中，可以观察到的一个趋势是，算法的结构复杂性在不断增加，数据结构也是如此。在此，我们重点讨论数值PDE解决方案的算法，并以示范性的方式讨论以下算法的发展。增加网格的几何灵活性，适应性和分层方法。

一开始，计算是在结构化的网格上进行的，几乎是唯一的数据结构，其中维数为1,2或3的直角坐标网格仍然发挥着重要作用--由于其效率和简单性，但越来越多地被更复杂的结构所取代或补充。

显然需要用几何网格来表示复杂的计算域，而这是直角坐标网格所不能实现的。采取的一条途径是开发非结构化网格，明确存储连接信息。这些网格表现出极大的几何灵活性，以及良好的几何分辨率的定位。另一条实现几何灵活性的途径是在体拟[TWM85]之上导致多块和过载[Pet97]网格，也称为Chimera网格。这就产生了网格生成的新研究领域。概述见 [Fil96][Tho99] 。自动网格生成的问题仍然缺乏一个完全令人满意的解决方案，特别是在 $3\mathrm{D}$ 。

一个重要的算法里程碑是数值PDE求解中自适应性的出现 [BR78] 。自适应算法通过某种方式测量计算出的近似质量，并检测出近似度不足的区域。实现所需近似的一种方法是在这些区域动态地完善基础网格（ $h$ -版本）。对于非结构化网格，这导致了许多细化算法和支持动态网格变化的数据结构 [Ban98][Bas94] 。在结构化网格的背景下, 出现了(结构化)自适应网格细化(AMR或更精确的SAMR) [BO84] 的技术.在这里，局部笛卡尔网格的层次被建立起来，这使得底层的数值内核只需稍作改变就可以被重复使用。

第二种方法，特别是在有限元中使用，通过高阶多项式丰富基础函数空间（$p$-版本）。这两种方法也可以组成，导致所谓的$h-p$-版本。

另一个里程碑是`分层`方法的发明，特别是用于解决由PDE离散化产生的线性方程组的多网格算法 [Hac85] 。通过在越来越粗的近似尺度上递归地解决这些系统，可以实现$O(n)$的最佳复杂度，$n$是未知数的数量。只要系统是稀疏的，也就是说，非零系数的数量是$O(n)$，这就是真的。

将分层方法与适应性一起使用会使必要的数据结构更加复杂。

\subsubsection{Efficiency Driven Complexity}

复杂性的另一个主要来源是需要利用硬件特性来实现高效率。为实现这一目标所使用的技术可能有很大的不同，这取决于具体的结构。特别是矢量计算机和分层存储机需要一个相对的处理。然而，由于矢量计算机对于不规则结构的问题并不发挥如此重要的作用，在我们的背景下，主要的问题是在分层内存结构中发现的机器内存的非均匀访问成本。分布式内存的极端是以分布式内存机器为标志的，但普通的台式电脑也至少有一个高速缓存级别。

高性能的关键是数据定位。如前所述，科学计算意味着处理大量的数据。因此，从存储数据的地方到使用数据的地方（寄存器）获取数据所需的时间对整体性能至关重要。今天的典型计算机处理数据的速度比获取数据的速度快得多，这一事实导致了硬件缓存的出现，以克服这个所谓的冯-诺依曼瓶颈。这就造成了前面提到的非均匀访问特性。频繁地访问较慢的内存（缓存缺失，远程内存）会导致大量的性能损失，这可以通过应用特定的编程技术来减少，见 [Kue98][PNDN97] 。

众所周知的增强数据定位的技术是操作的集群（如循环平铺），以便一次对缓存中的数据做尽可能多的工作，以及将数据分割成较小的部分，分别处理。后一种方法与数据复制相结合，它也适合于分布式内存机器。

虽然数据定位对于单处理器、单内存机器来说已经是一个问题，但它在分布式计算中占主导地位，如果不考虑数据定位，性能就会急剧下降。硬件的复杂性仍在继续增加；今天的多层机器是由共享内存机器组成的集群，导致了几层的内存层次，例如，见美国能源部30 TFlops项目 [Wol98] 。迅速调整高性能软件以利用这些架构的力量将是一个严峻的挑战。

一项新兴技术是网络科学计算（NSC），它实际上可以被视为引入了一个新的硬件层。通过高速网络连接异构的计算设施，原则上可以为科学计算提供非常大的集群。另外，网络计算为软件的构成方式开辟了新的视角。一个应用程序可以使用仅在程序运行时捆绑的分布式服务，而不是构建单体块 [BGMS98] 。

\subsubsection{Physics Complexity}

数值模拟越成功，人们对处理更难的物理问题的期望和要求就越高。美国联邦高性能计算和通信（HPCC）计划[Nat95]列出了一些有代表性的最重要的问题（所谓的大挑战），将其定义为

科学和工程中具有广泛经济和科学影响的基本问题，其解决方案需要应用高性能计算。

其中包括耦合（结构和流体力学）现场问题$\left[\mathrm{GC}_{-} 99 \mathrm{a}\right]$，GAFD（地球物理和天体物理流体动力学）湍流[HPC99]，油藏建模[GC-99b]，地下水运输和补救[PIC99]，以及全球气候建模[MSD93b][MSD93a]。

许多 "大挑战 "实际上需要对多物理模型进行模拟。起初，数值模拟集中在一个单一的物理模型上，例如结构力学或流体动力学。现在，这些模型之间的耦合开始出现，例如对一架完整的飞机的飞行进行建模，包括流体流动和机翼变形之间的相互作用。除了与寻找声音离散化有关的数学问题[HW95]，还必须解决不同类型的求解器、多网格[PHS98]和不同时间尺度的耦合问题。

\subsubsection{User Interaction Complexity}

许多数值应用程序传统上是以批处理模式运行（和运行）的。一旦启动，它们就会计算数小时、数天甚至数周，最后由可视化程序对数据进行后期处理。更进一步的是通过共同处理模拟数据进行在线可视化。这只是在数据的图形表示可以被控制的意义上是互动的，但不是模拟本身。最后，用户可以被允许互动地引导计算。在运行过程中可以改变相关算法的参数，允许试验不同的选择。这在新算法的验证阶段或某些参数需要调整时特别有意义 [YFD97][PWJO7] 。

一般来说，分布在许多计算机上的数值应用所产生的数据比单个存储器所能容纳的要多得多。单个节点上的可视化很快就成为一个瓶颈，甚至是不可能的。因此，必须开发和实施减少数据的策略，这些策略也是以分布式方式工作的，并且非常接近数据产生的地方。这个地方可能就是模拟代码本身。实现这种局部性，同时为用户保持高度的互动性，是一项非同寻常的任务 [Cro96] 。它还倾向于将数值和可视化任务紧密结合起来。

\subsubsection{The Central Role of Grids for Numerical PDE Solution}

如果我们重新考虑我们所讨论的PDE求解器中软件复杂性的算法因素，结果发现所有这些都围绕着网格数据结构和在其上操作的算法。当然，对于网格是这个领域的核心数据结构这一事实没有什么疑问--在这种情况下，绝大多数的算法都直接或间接地在网格上操作。

首先，数值离散直接访问网格，无论是有限差分（在这种情况下，人们对网格做了非常特殊的假设）、有限体积（见6.2节）还是有限元（见6.3节）。

一个可能的下一步是解决由这种离散化组成的线性系统，例如用有限元方法。虽然这种系统的简单迭代求解器不需要任何网格访问，但更先进的方法需要，如利用问题物理学的多网格或前置条件器。

网格相关算法的另一个来源是`可视化`。在这里，以离散方式在网格上给出的模拟数据，被用来产生几何数据，最后以多种方式产生图形数据 [PvW93] 。

PDE求解器的并行化本质上意味着网格的分布，从而以数据并行的方式进行工作。这需要额外的数据结构来管理分布信息，以及设置和维护这些数据结构的算法。这两种类型的组件都与基本的顺序网格密切互动。这个话题将在$5$章中深入探讨。

网格在数值PDE求解中发挥的主导作用意味着控制相应的数据结构和算法的复杂性是掌握该领域软件建设的关键。但网格的使用并不局限于这个领域。如果我们越过数值模拟的狭窄边界，就会发现网格在其他算法主导的领域也发挥着重要作用，如计算机图形 [FvFH90] 、计算几何 [Ede87] 、计算拓扑 [DEG98] 和几何建模 [Mor97] 。

因此，可以预见，在PDE解决方案中与网格相关的组件领域的进展也会使其他领域受益。也许最重要的是，它可以缓解不同领域的软件之间的合作。一个例子是在模拟程序中越来越多地使用图形算法，如下游排序 [Bey98] 。直接从组合算法库中使用这种算法在今天几乎所有的情况下都是不可能的。

与计算机图形学的联系在上述科学可视化的特征中是非常清楚的。来自计算几何学的方法，如Delaunay三角计算，经常被用于非结构化网格的生成 [She96] 。这又依赖于来自几何建模组件（如CAD程序）的计算领域的表示。事实上，从CAD到网格生成器的几何信息传递是一个仍然缺乏令人满意的解决方案的问题，并且在实践中经常与信息损失有关。

\subsection{Components for Scientific Computing}

\Subsection{What Are Components?}。

由于刚才描述的情况，技术、组合和几何方面以及算法正变得越来越重要。数值分析师不是（也不可能是）所有这些领域的专家--一个人的努力越来越不足以创造先进的科学计算。在其他领域也是如此，在这些领域中，数值算法的使用可以带来收益，例如在CAGD中以数值方式确定曲面的交点。

相反，团队必须一起工作，并且必须以现成的数据结构、算法和高性能策略的构件或组件的形式利用第三方的工作。

当然，从别人的工作中获利，在科学计算中一直在做--算法的重用，也就是想法的重用，是公认的。但这并不足够。鉴于算法的数量、复杂性和实现难度不断增加，这些实现也必须并且正在被重新使用。

术语 "组件" 在文献中的使用方式相当不同。COULANGE[Cou98]将其定义为（第51页）一个`实体`，它可以在新的软件开发中使用，可能还要进行修改。

他进一步指出，不仅代码（实现）可以被重用，而且设计和规范也可以被重用。我们把这个定义与SZYPERSKI在[Szy98]的序言中给出的定义进行对比。

软件组件是独立生产、获取和部署的二进制单位，它们相互作用，形成一个正常的系统。

在这项工作中，我们在Coulange的意义上相当宽泛地使用组件这个术语，而不是在Szyperski的更具体的意义上。一般来说，我们考虑的是在编译时组成的更精细的实体，而不是具有 "非常晚的绑定" 的二进制组件。然而，我们也会对整个库或包使用 "组件" 这个术语，如果它们作为一个整体被重用的话。

众所周知，软件重用并不容易，参见专门讨论这个话题的一般文献 [Cou98][Szy98][Sam97][Kar95] 。对于科学计算来说，重用在某些领域运用得相当成功，但在其他领域却很有限。在下面的章节中，我们将尝试阐明这一事实的一些原因，集中讨论算法实现的重用。基于网格的算法的案例将作为参考点。

在第2.2.2节中，研究了判断科学组件质量的一些标准，并强调了通用性的作用是重用的一个关键。

然后我们回顾了现有组件的主要类型，并分析了一些重用情况（2.2.3节）。因此，在第2.2.4节中，算法对特定数据结构的强烈依赖将被确定为重用的主要障碍。底层数据结构的差异性越大，重用的障碍就越大，这个问题与网格数据结构和在网格上运行的算法高度相关。

本论文集中于算法的重用--小型的、集中的组件。然而，这种小规模或中等规模的再利用并不是利用现有工作的唯一可能方式。在应用层面上，整个仿真环境的设计和规范也是可以被重用的资源。这一领域的研究--在PDE解决方案的背景下--最近刚刚出现[Ahl99][Nor96][LMR97]，在某种意义上是对本论文的补充。

\subsubsection{Quality Criteria for Scientific Computing Components}

在下文中，我们给出了一个广泛的衡量组件质量的属性列表，以满足科学计算的需要。我们首先关注与组件用户相关的属性，然后列出组件开发者特别关注的属性。

我们可以将这些标准粗略地分为四组：服务质量、功能、与其他组件的关系和支持。

从衡量任务解决情况的服务质量属性开始，我们可以提出以下要求。

- 正确性/准确性。该组件是否能提供正确的输出？测试策略是什么？它在数值上是否稳定，是否有误差控制，是否能给出合理的近似值？是否有精度损失，例如在内部计算时，精度较低，或使用条件不好的评估顺序？

- 稳健性。衡量一个组件对有效输入的稳定程度，以及对无效输入检测的错误处理的一致性。具体来说，越是能在编译时进行检查，越是能在库的入口点直接检测到使用错误，库就越是健壮。例如，一个为不同的矩阵表示法提供因子化算法的线性代数库应该确保用户传递的矩阵格式与因子化算法所期望的格式一致。

对于数值算法来说，有时并不容易决定一个给定的输入是否有效，因为浮点实现通常在无效值附近失效，例如奇异矩阵。

- 效率。这意味着内存效率（临时工作空间，输入数据的复制）和运行时性能（内部使用高效算法，优化实现）。它可以进一步区分为理论性能（复杂性）和实际性能，这取决于翻译成机器代码和底层硬件的情况。后一点在科学计算中是众所周知的，但在某种程度上似乎被采取 "纯 "算法理论观点的工作所忽视。一个重要的分题是并行可扩展性。如果一个分布式计算的组件在问题规模和资源（处理器数量）扩大的情况下性能不会大幅下降，那么它就是可扩展的。

下一组是功能问题--哪些任务根本就可以处理？

- 模块化和颗粒化。如果一个组件提供了捆绑的、高层次的功能，那么它的一部分是否可以被重复使用？例如，一个用于解决椭圆PDEs的软件包是否只允许使用迭代线性方程求解器？复杂的操作是否被分解成有意义的部分操作？例如，一个线性代数包可以提供缩放矩阵的方法以达到更好的条件数。

- 灵活性。指用户控制影响内部执行的参数的能力，例如迭代过程中的终止标准，调试水平，或算法块的交换，特别是在运行时。

- 通用性。与可以处理的具体问题的范围有关。一个允许复值矩阵（甚至是任意值）的线性代数包比一个只允许单精度条目的线性代数包更通用。通用程度决定了使用的频率：如果组件只能解决一个 "邻近 "的问题，用户必须找到一些变通方法（问题转换），否则他就不能使用它。问题领域的可变性越大（不同的数据结构，不同的算法选择），产生一个足够通用的组件就越困难。LAPACK库中的程序数量（大约1000个）就说明了这一点。

在这里，我们要强调的是，我们所说的一般性并不是指广度，即所处理的不同问题的范围，也见焦点属性。相反，一个相同的高层次数学问题可以引起许多不同的低层次计算问题，这是因为数据表示和执行决定的变化，这些变化与抽象的数学问题无关，但与具体的计算机解决方案高度相关。

事实将证明，缺乏通用性是大多数现有组件的主要问题；如何提供具有足够大（最好是最大）通用性的组件的问题是这项工作的动力。

- 可扩展性。衡量在尽可能保持用户界面完整的情况下，扩展组件的功能有多容易。一个更确切的术语是可扩展性[BSST93]，它是衡量增加一个新的功能以提高通用性需要付出多少努力，例如，在线性代数库中增加对复数的支持。传统的库实现方式很难实现可扩展性，因为它无法处理满足所有潜在需求而产生的组合爆炸。前两组（服务质量和功能）在某种程度上是组件的内在属性；它们可以通过孤立地看一个特定的组件来回答。考虑组件之间的关系也很重要。

- 互操作性。考虑到一个组件能与其他组件合作的程度。互操作性的主要障碍之一是在接口中规定一套固定的数据结构，特别是在传统的程序语言中。合作的障碍也可能是名称冲突（也见焦点下），或者对上下文的隐含或过于苛刻的假设，例如要求所有进程都参与组件的内部集体操作（在并行计算的情况下），见[Gro98] 。另一个例子是一个网格生成器要求通过GUI交互式运行。

- 重点和紧凑性。该组件是完成一个单一的、定义明确的任务，还是一堆无序的、不相关的功能？它是否通过实现可以从其他包中获取的服务功能而 "重新发明轮子"，例如不可避免的QUICKSORT和容器的实现？包的大小是否与所提供的功能相符？一个不够集中的组件往往比必要的大得多。在这种情况下，小就是美。另外，临时编写的服务子组件（如线性列表）的质量往往比专用包中经过测试和优化的对应组件要差一些。最后，如果在组件中实现了许多基本的数据类型，那么发生冲突的概率就会提高。

- 依赖性。该组件是否依赖于其他的第三方组件或工具的可用性，如一个特定的编译器？依赖关系越多，一个组件被重复使用的可能性就越小，因为安装时可能需要先安装很多其他的组件。大量的依赖关系往往意味着可移植性的限制。依赖关系越专业（特定版本的特定库，或需要非标准编译器的非标准语言扩展），就越容易引起问题。依赖性必须与所提供的功能水平相关，一个高级组件（如并行非线性求解器）比一个低级组件（如消息传递库）更有可能出现依赖性。

最后一个方面在某种程度上超出了 "纯 "软件的范围，即支持属性，它取决于组件的时间演变，并主要取决于其背后的人。

- 稳定性。组件不是静态的实体，而是随着时间的推移而发展的。稳定性涉及到与用户相关的变化频率，如界面语法、前条件和后条件、资源消耗。通常情况下，如果前条件被削弱，后条件被加强，内存和时间消耗减少，接口变得更加通用，使旧的用户代码有效，这都是可以接受的。- 维护。没有人，也没有一个组件是完美的。维护是指回答问题的频率，发现、记录和修复错误，实施新的算法，并优化实现。

- 易用性。衡量从组件中有效获得所需功能的难度，例如，是否有复杂的调用序列，是否有很多不明显的参数需要传递，或者是否需要为组件提供额外的工作存储器？这必须与组件解决的任务的复杂性联系起来。没有人会使用一个需要15行代码的库来调用一个10行就能实现的程序。

对于一个开发商来说，此外，以下标准也很重要。

- 可维护性。是指在不破坏用户代码的情况下，纠正已知错误、增强或扩展库的容易程度。

- 可移植性。是指相对不依赖环境参数，如硬件、特殊库、特定的编译器、系统版本和其他。

- 编码效率：衡量实现一个特定的功能需要多少工作。这是一个非常重要的话题，因为太低的编码效率最终会导致非常不完整或实现不好的组件。它与可扩展性属性、库组件的内部重复使用以及第三方组件的使用密切相关。

\section{Tradeoffs between criteria}

显而易见，这些质量衡量标准有时是相互矛盾的。特别是，效率似乎与几乎所有其他属性都是对立的。由于效率在数值计算领域的巨大重要性，权衡决定往往是为了支持效率。

- 效率 $\leftrightarrow$ 稳健性。对参数有效性的认真检查需要额外的时间或内存，有时比算法本身还要多。一个可能的解决方案是提供不同程度的检查，并让用户决定需要多少。

- 效率 $\leftrightarrow$ 通用性。对效率的考虑越少，开发通用实现就越容易。这是因为对于高效的程序，人们通常需要考虑到问题的更多具体细节。过度泛化往往会导致很差的性能，一个严重的例子是在矩阵乘法程序中把稀疏的矩阵当作密集的矩阵。找到合适的抽象，使两者兼得是一门艺术；这是我们在本论文中试图解决的核心问题之一。- 效率 $\leftrightarrow$ 可移植性。为了获得高性能，人们往往需要对硬件结构和细节（例如缓存大小）做出承诺，或者使用特殊的编译器开关。这些方面并不总是容易封装的。我们可以尝试把那些必须为每个平台移植（优化）的低级基本操作考虑进去，而把其他的部分从这些问题中屏蔽掉。一个例子是BLAS（见第25页），它封装了基本的向量和矩阵操作。在[WD97]中，作者描述了如何根据运行时的测量结果自动生成最佳的BLAS实现。

- 效率 $\leftrightarrow$ 编码效率。高度优化的软件通常更难正确工作，因为程序语句与高级数学公式的联系被掩盖了。像手动解开循环、平铺和手动优化复杂的代数表达式这样的技术为错误开辟了一堆新的来源。因此，手工优化可能会大大增加创建正确软件所需的努力。

- 效率 $\leftrightarrow$ 可维护性。为了纠正或改变某种行为而需要接触的代码越多，就越费力，越容易出错。手工调整的代码通常会用更晦涩、更低级、更明确（即更长）的代码片断来取代可理解的高级代码。如果必须进行修改，就必须检测代码的哪一部分与所考虑的行为相对应，从而在精神上撤销之前的优化转换。

将高级代码自动转化为高效的（相对于手工调整的）低级代码可以为这些问题提供解决方案，这也是一个活跃的研究领域 [BHW97],[DQ99],[Rob96],[DHH99] 。

尽管取得了一些成功，但到目前为止发现的解决方案似乎只是部分的，而且大多数需要语言扩展或预编译器。使用内置语言特性（对于C++）的技术是表达式模板 [Vel95a] 和模板元程序 [Vel95b] 。

- 依赖关系 $\leftrightarrow$ 紧凑性。依赖关系与每种形式的重用都有必然的联系；主要问题是依赖关系的任意程度。例如，一个非线性求解器一般需要一个线性求解器组件，但它是否需要一个特定的包，或者在另一个极端，每一个线性求解器包都可以使用，可能还要进行调整，这就有很大的区别。

增加互操作性倾向于缓解这个问题；然而，同等组件的完全可替代性在很大程度上是一个没有达到的理想。后面介绍的通用编程方法为实现这一目标迈出了一步。

- 易用性 $\leftrightarrow$ 通用性。一个组件的通用性越强，就有越多的 "尾巴 "存在，只有在实际使用时才会被束缚住。这对用户来说是一个很大的负担，因为他必须了解比他实际愿意改变的更多的参数。提供几层访问权限是在保持界面简单的同时保持完全通用性的一个可能的方法。例如，PETSc工具箱[BGMS99]定义了四个层次的访问：基本、中级、高级和开发者。像默认参数这样的语言特性可以帮助创建这些层次。

上面讨论的大多数标准都可以由科学计算中已经确立和使用的技术来匹配--这并不意味着每个组件在每个标准方面的表现都令人满意，也不意味着这些目标容易实现。

正确性本质上是正确实现充分算法的一个功能。稳健性一般需要对参数进行一些类型检查。这在支持数据抽象的强类型语言中更容易实现，正如许多面向对象的语言所提供的那样。传统上，效率（孤立的）是通过在接近物理数据布局的层次上实现的。模块化是一个组织问题，重点和依赖性也是如此；有些语言对模块化开发的支持比其他语言更好。面向对象的技术特别适合于实现灵活性，其中对象状态和动态绑定比程序性方法具有决定性的优势。

其余的主题：通用性，以及与之相关的可扩展性和互操作性的某些方面，似乎更难实现，特别是考虑到可接受的效率的额外要求。在下面两节中，我们将论证通用性在数据表示的高变异性领域是一个真正的挑战，需要一个相当不同的方法来应对这个问题，而且这样的方法在（非结构化）网格计算领域仍然缺失。

\subsubsection{Review of Components for Scientific Computing}

本节的目的是让读者更好地感受该领域中具体软件组件的性质。它决不是要给出一个详尽的概述。我们特别关注与网格有关的组件，并希望收集到一个有一定代表性的集合。

专门用于网格的可重用组件的数量相对较少--大部分集中在网格生成和分区领域--与网格的核心作用形成鲜明对比，可以看作是创建此类组件的一些基本困难的标志。这个问题将在2.2.4节中进一步研究。

现有的科学计算组件可以非常粗略地划分为几种类型。

- 无状态子程序库和面向对象/基于对象的工具箱

- 面向对象的应用程序框架和完整的应用程序

子程序库是最古老的组件类型，并且仍然占现有数值软件的大多数。工具箱与子程序库类似，但也包含数据结构。这两组组件专注于算法组和/或数据结构。

应用框架对应用程序的架构进行建模，并涵盖相当广泛的子领域，如数值PDE求解所需的子领域。完整的应用程序可以解决一个（一类）具体问题。

第一组组件通常比第二组组件更具通用性，第二组组件通常对某一类特定的应用更加专业化。另外，第一组往往支持更多的小规模或有选择的重复使用，而在第二组中，重复使用往往意味着使用整个单体块，只替换其中的一小部分。

很明显，这些类别之间的边界并不鲜明，混合形式普遍存在。

子程序库 创建可重复使用的软件组件的经典方法是将相关的程序集组合成库。今天，大量的代码--大部分是用FORTRAN语言编写的--存在于大量的问题中，包括密集线性代数（BLAS [LHKK79] , LAPACK $\left[\mathrm{A}^{+} 95\right]$ ），稀疏线性代数（ITPACK [KRYG82]），数值正交（QUADPACK [PdKÜK83] ），常微分方程（ODEPACK [Hin83] ）和偏微分方程（ELLPACK [RB84] , CLAWPACK [LeV94] ）。

这些库通常提供一组程序，用户可以调用这些程序（或一个定义良好的程序序列）来访问所需的功能，并将他们自己的数据结构作为参数。

ELLPACK由传统子程序库之上的问题解决环境（PSE）组成。

BLAS是一个特殊的例子，它是一个低级别的支持库，为向量和矩阵的基本代数操作提供实现。其基本思想是，这些操作的效率关键取决于实现如何考虑到硬件特性，如缓存大小。BLAS层可以针对具体的硬件进行专门设计，并将LAPACK等高级库从这些细节中屏蔽掉。因此，我们可以说BLAS封装了高效矢量算术中与硬件相关的部分。

在专门用于网格算法的组件中，我们发现网格生成器如GEOMPACK [Joe91]、TRIANGLE [She99] 或NETGEN [Sch99]，网格划分器如METIS [Kar99] 或JOSTLE [Wal99] ，以及可视化包如VISUAL3 [Hai99] 。几乎所有这些都要求用户将他的数据转换为实现所期望的特定格式，和/或返回，如果产生了输出。毋庸置疑，这种格式通常因情况不同而不同。

工具箱 与纯粹的子程序库相比，工具箱还提供特定领域的数据结构，如稀疏矩阵或计算网格。因此，工具箱通常以基于对象的风格$\mathrm{C}$或面向对象的风格C++来编写，这比FORTRAN语言提供更好的数据抽象支持。PETSC库[BGMS99]是用ANSI C语言编写的，包括解决线性和非线性系统的算法，以及（分布式）向量和稀疏矩阵的数据结构。它可以在顺序和分布式内存机器上运行，并支持用户定义的数据分布。大多数算法的实现都接受用户定义的数据结构，以及在这些结构上工作的例程（例如，矩阵-矢量乘法）。

AGM $^{3 D}[$ Beyg9 $](C)$ 是一个用于三维自适应多网格层次结构的数据结构，它实现了细化和粗化这种层次结构的算法，详见[Bey98] 。这个工具箱的用户将围绕给定的多网格数据结构构建他的应用程序。

GRAPE [GRA99] (C) 是一个基于对象的工具箱，提供二维/三维三角数据结构，支持有限元计算，以及在这些结构上操作的广泛的可视化算法。除了使用GRAPE的数据结构外，还可以通过程序接口传递给用户定义的网格类型和仿真数据[RSS96]，然后由可视化算法使用。

POOMA$\left[\mathrm{K}^{+} 99\right](\mathrm{C}++)$提供了类似数组的数据结构，支持分布，但没有数字算法。

LEDA[MNU99]（C++）实现了高级容器类型（如平衡树）和组合算法，特别是图算法。容器通过元素类型和实现策略进行参数化。然而，一般来说，算法只与库本身的数据结构一起工作。请注意关于图迭代器扩展的评论 。

用于PDE解决方案的包和框架 框架定义了整个应用领域的综合模型。一般来说，它们为应用程序提供了一个整体结构。框架用户可以填补或替换框架中的单个组件。在一个纯粹的框架中，不支持具体算法和数据类型组件的实际实现。因此，框架可以被认为是对工具箱的补充。

一些早期的PDE求解包包括PLTMG（Piecewise Linear Triangle Multigrid Package, [Ban98] , FORTRAN）和MGHAT（Multigrid Galerkin Hierarchical Adaptive Triangles [Mit99] , FORTRAN），这些几乎都是模块化程序，只有作为一个整体才可以重复使用。

大多数现代方法使用面向对象或基于对象的范式。DIFFPACK $[\mathrm{BL} 97](\mathrm{C}++)$ 是一个通过有限差分$(\mathrm{FD})$或有限元（FE）方法解决PDE的框架。KASKADE [REL99][REL97] $(\mathrm{C}++)$ 涵盖了相同的应用领域。这两个框架都为有限元、线性算子和迭代求解器提供了抽象的概念。UG（非结构化网格，$\left.\left[\mathrm{B}^{+} 99\right], \mathrm{C}\right)$）软件包提供了对FE和FV方法以及并行化的支持。

UG和KASKADE都是以非结构化的、适应性的分层网格数据结构为中心。

DAGH（Distributed Adaptive Grid Hierarchies, [PB99] ）（C++）是一个支持直角坐标域上SAMR方法[BO84]等算法的框架。OVERTURE $[\mathrm{BQH} 99](\mathrm{C}++)$也只支持结构化网格，但允许曲线几何和超限奇美拉型网格。它包括网格生成、离散化和可视化子包。这两个软件包都支持分布式内存并行。

虽然用自己的组件来扩展这些框架并不难（这也是它们的设计目的），但在不同的环境中重复使用其中的部分，例如单个算法，就不那么容易了。算法的实现很少是独立的，而是取决于框架所提供的环境。因此，将两个或更多框架的精华结合起来通常是不可能的。

\subsubsection{Shortcomings of Scientific Computing Components}

从$2.1.3$节提供的可用于科学计算的大量（基于网格的）算法的概述中，相当明显的是，一个自然的重用单位是一个单一的算法组件--或者也许是一小群协作的算法，共享一些数据结构。理想的方式是将这些组件从算法库中取出。如果一个人需要，比如说，一个用于网格平滑的方法，他可以从资源库中获取一个合适的组件。

然而，实际的组件并不允许这么容易。对于子程序库和工具箱来说，它们首先具有足够的粒度，问题是数据结构不匹配，需要进行转换--这种方法的缺点将在下面讨论（2.2.4.5节）。

对于框架和完整的应用程序包来说，这个问题甚至更加困难，因为在这里不打算重复使用单个算法。通常的做法是重用软件包的基础设施来实现额外的算法。

这里的关键问题是，所讨论的组件不能处理它们所使用的环境的可变性--用前面一节中介绍的术语来说，它们没有提供足够的通用性。那些试图这样做的，如LAPACK，遇到了库大小的组合爆炸。

这一局限性的主要原因可以通过说明决定往往是过早作出的来表达。许多决定最好是基于组件实际使用时才有的信息。使用哪种数据结构，应用程序是在顺序还是并行环境下运行，是否需要最高的性能或增强的调试支持，等等。然而，许多这些要点已经在库中固定下来了，往往导致所提供的服务不尽人意的情况。

现在我们将用密集线性代数（第2.2.4.1节）、稀疏线性代数（第2.2.4.2节）和网格计算（第2.2.4.3节）的例子更详细地探讨这个问题。这一连串的例子可以被看作是数据结构差异的升级，这也是这里的核心问题。我们讨论了处理数据结构差异的两种可能策略，即数据结构标准（第2.2.4.4节）和数据结构转换（第2.2.4.5节），并表明它们不能提供一个普遍的解决方案。

\subsubsection{Reuse Case Study: Dense Linear Algebra}

假设我们想使用高精度浮点数据类型（如[Bri99]）对密集矩阵进行$L U$因子化，例如用于进行舍入误差分析。一个提供$L U$算法的高质量库是LAPACK。然而，我们没有机会用LAPACK来做，因为它只支持四种基本的浮点类型（单/双精度实数和复数）。

如果LAPACK例程在标量类型上进行参数化，是否会有帮助？这样的参数化--尽管FORTRAN不支持--可以很容易地通过宏来完成，事实上，这种技术（据作者所知）被开发者用来生成基本标量类型的版本。然而，这对我们帮助不大，因为FORTRAN不能支持新的高精度类型的基本算术操作。因此，为了扩展LAPACK以支持这种标量类型，我们必须重写每个例程，手工插入算术操作。该库是不可扩展的。

现在让我们拿一个用允许操作符重载和泛型的语言实现的包，比如C++，和一个提供由标量类型参数化的$L U$分解的线性代数包。(事实上，只要将FORTRAN代码映射到C++并对数组参数进行参数化，就可以很容易地得到这个结果。)通过用这个新类型实例化$L U$分解来获得所需的功能，只要它有正确重载的算术操作。

区别在哪里？当然，C++有模板设施，但在这里，同样的效果本来可以用宏来实现。然而，主要原因是我们能够通过提供$L U$算法所需的操作来隐藏新标量类型和内置类型之间的差异。

然而，我们必须承认，这只是意外的成功。通用的$L U$实现和新的标量类型很适合在一起。但是，如果高精度类型的开发者会用$\operatorname{add}(\mathrm{x}, \mathrm{y})$来做加法，用$\operatorname{mul}(\mathrm{x}, \mathrm{y})$来做乘法，那会怎样？只有一个事实，即有一种与算术运算有关的通用语言，从几百年前就存在，在这里拯救了我们 $-$ 的运算被称为 $+,-, *, / \mathrm{and}=$ ，就是这样。然而，对于指数化来说，已经有了一个问题。

必须对有点简单化的参数化方法作进一步的评论。这将导致一个正确的程序，但也许不能达到可能的最高效率。原因是LAPACK内部使用BLAS例程进行基本操作。这些程序反过来又根据缓存的大小进行了优化，例如使用block。由于新的类型需要更多的内存，BLAS例程的块大小已经不能很好地工作了。因此，不仅是代数运算的意义，而且新类型的大小也是一个重要的参数。

\subsubsection{Reuse Case Study: Sparse System Solver}

假设我们有一个组件$(\mathcal{A})$从一些有限元离散化中组装一个线性系统（一个稀疏矩阵$A$和一个右手向量$b$），另一个组件$(\mathcal{S})$解决一个线性系统。一起使用它们的机会有多大？

嗯，这取决于。在一个典型的案例中，$\mathcal{A}$将使用一个数据结构$D_{\mathcal{A}}$来表示稀疏矩阵，而$\mathcal{S}$将使用另一个结构$D_{\mathcal{S}}$ 。因此，我们最好的办法是将矩阵从它的$D_{\mathcal{A}}$复制到它的$D_{\mathcal{S}}$表示中，要求我们知道两者的细节。同样的推理也适用于向量类型，尽管数据表示的差异和技术难度通常要低一些。

然而，如果我们更幸运，$\mathcal{S}$将允许传递用户定义的数据类型（矩阵和向量），以及底层算法所需的操作。这是例如PETSC中选择的方法（在那里被称为数据结构中立）。在面向对象的实现中，算法将被定义在稀疏矩阵的抽象基类上，人们将使用桥接模式[GHJV94]将自己的矩阵类插入到抽象基类下面的层次结构中。

基于对象的PETSC使用户有可能通过提供指向所使用的矩阵/向量函数的指针来注册一个新的矩阵类型，并从原始C数组中创建向量。事实上，PETSC的Mat类型只是一个占位符，用于任意的矩阵实现（包括非存储矩阵）。

PETSC组件对传递的参数提出了很轻的要求。它们不一定是组件意外选择的特定类型，但只有真正使用的方面必须匹配。在这种情况下，提供矩阵-向量乘法和向量加法的程序就足够了。

如上所述，一个普通的迭代方案对矩阵和向量数据类型的要求很低。然而，通常情况下，迭代方法需要预处理以提高收敛性。从一个给定的线性算子中创建一个预处理，很大程度上取决于要解决的具体问题，因此，存在大量的具体算法。引用 [Saa96] ，第265页。

找到一个好的预处理程序来解决一个给定的稀疏线性系统，常常被视为艺术和科学的结合。理论上的结果很少，而有些方法的效果却出奇的好，往往不顾人们的期望。

因此，我们使用第三个组件$\mathcal{P}$，使用一个数据结构$D_{\mathcal{P}}$，从我们的矩阵$A$中计算出一个格式为$D_{\mathcal{A}}$的预处理程序。

创建预处理程序通常需要对底层矩阵数据结构有更多的了解，从简单的雅可比预处理的对角线元素的访问到不完全因式分解（ILU）的非零模式的详细了解，这也可以包括对矩阵的结构描述部分的再利用 [Saa96] 。处理单个条目是非常细粒度的功能，PETSC使用的函数指针方法已经不能很好地工作了。

因此，如果人们选择，例如ILU预处理，所传递的矩阵就应该自己执行。在用户提供数据结构的情况下，PETSC工具箱中的ILU算法实现不能被重复使用。考虑到上面讨论的困难，这并不令人惊讶。

最后，改变矩阵元素的顺序以达到更好的收敛性，更少的填充，或更好的缓存重用，往往是有利的。这本质上是一个`图论`问题，所以我们想把矩阵传递给一个应用重排序算法的包$\mathcal{G}$。这个包需要一个图的数据结构$D_{\mathcal{G}}$作为输入，并以数组的形式输出一些图节点的排列组合。

该算法可以是像CUTHILL-MCKEE方法那样的通用算法 [Saa96] （也见第62页），但它也可能取决于特定问题的数据，例如见 [Bey98] 。

总而言之，有以下程序。

1.在数据结构$D_{\mathcal{A}}$中组装矩阵$A=A_{\mathcal{A}}$，组件为$\mathcal{A}$ 。

2.将$A_{\mathcal{A}}$从$D_{\mathcal{A}}$转换为$D_{\mathcal{G}}$，得出$A_{\mathcal{G}}$ 。

3.从$A_{\mathcal{G}}$中计算出一个带有$\mathcal{G}$成分的矩阵排序。

4.对$A_{\mathcal{A}}$应用排序。

5.将$A_{\mathcal{A}}$从$D_{\mathcal{A}}$转换为$D_{\mathcal{P}}$ ，得出$A_{\mathcal{P}}$ 。

6.从$A_{\mathcal{P}}$构建一个预处理程序$P_{\mathcal{P}}$，使用组件$\mathcal{P}$。

将矩阵$A_{\mathcal{A}}$和先决条件$P_{\mathcal{P}}$转换为求解器组件$D_{\mathcal{S}}$和$D P_{\mathcal{S}}$所期望的类型$A_{\mathcal{S}}$和$P_{\mathcal{S}}$的值。

8.使用$\mathcal{S}$解决该线性系统。

它涉及到将初始数据结构$D_{\mathcal{A}}$复制或转换为另外两种表示方法$\left(D_{\mathcal{G}}\right.$和$\left.D_{\mathcal{P}}\right)$，这可能需要用户方面的大量工作，而且还需要了解所涉及的所有三种数据结构。如果我们想使用额外的软件包，例如用于调试或评估重排质量的稀疏矩阵可视化工具[BL94]，则需要进行额外的转换。

作为结束语，我们注意到稀疏矩阵-向量乘积是迭代求解器中使用的关键操作，而迭代求解器又是大多数PDE求解器的关键组成部分。这些操作的有效实现既取决于所使用的数据结构，也取决于底层硬件，就像密集矩阵的情况一样。然而，稀疏BLAS的开发必须应对各种困难，最明显的是用于表示稀疏矩阵的数据结构的极大多样化，这使得[SL98]中的基本操作的不同实现方式相应激增，作者指出，NIST的稀疏BLAS[RP97]包含大约10000个例程。


\subsubsection{Reuse Case Study: Particle Tracing on a Grid}

一个著名的非稳态流动现象的可视化方法是粒子追踪[TGE97]：一组粒子被插入域中，它们随时间变化的路径以图形方式显示。在数值上，这需要对每个粒子的普通微分方程（欧拉运动方程）进行积分。

在数值PDE求解的背景下，流场是在计算网格上的离散位置给出的，例如每个计算单元一个值。因此，任何计算粒子路径的算法都需要与网格数据结构和流场表示法密切互动，参见第 $64.$ 页。

现在，可以想象到重新使用现有粒子追踪组件的不同情况。首先，我们可以使用一个通用的流动可视化软件包，如VISUAL3 [Hai99] 。在这种情况下，我们必须将整个网格和流场传递给该软件包。只要复制数据所需的时间与计算所需的时间相比是小的，这通常是可以的。通常情况下，如果采样率较小，就会出现这种情况。每隔$n$个时间步数才写入数据。

小的采样率对静态可视化技术来说并无大碍，因为它作用于一个固定时间的快照。然而，对于像粒子追踪这样的动态技术，这可能会导致不可接受的精度损失。因此，在每个时间步骤中更新当前的粒子位置是很诱人的，如果粒子数量相对较少，这项任务在计算上要比复制完整的流场便宜得多。

一个人可以从另一个提供它的软件包中获得这样的实施吗？嗯，机会不大。一般来说，两个流动求解器的网格数据结构会有所不同，任何致力于其中一个的实现都不会在另一个上工作。因此，要么重新实现粒子追踪器，要么在每个时间步中把整个数据传递给一个可视化软件包，这是很昂贵的。

上面三个小节所讨论的问题都与算法组件所做的不兼容的数据结构假设有关。在转向通用编程作为一种可能的解决方案之前，我们简要地讨论一下为什么两种可能的解决方法--即使用 "标准 "数据结构和数据结构转换--不能提供一种通用的解决方案。

\subsubsection{Data Structure Variance in Scientific Computing}

所有邪恶的根源似乎是所使用的数据结构的可变性。为什么不能为每种类型的数学对象接受一种标准的表示格式，比如非结构化网格或稀疏矩阵？无论如何，这在经典数值库中似乎在某种程度上是可行的，例如密集线性代数。

就其本身而言，这是一个合理的想法，但它在大的方面必然会失败。

不考虑政治原因--人们（供应商、科学家）根本不愿意致力于一个共同的标准--真正的问题是数学结构本身的多样性所固有的，再加上效率考虑。一个计算网格可能是笛卡尔式的，在这种情况下，它只是隐含地给出，它可能是完全非结构化的，只允许简单的或更一般的单元类型。此外，对功能的不同计算要求往往要求不同的数据布局。

出于效率的考虑，简单地选择这些结构中最一般的结构来代表网格的 "明显 "方式被排除了。此外，这也不能解决所有问题。一些用于网格的算法，如下游排序[Bey98]或网格划分[Els97]，实际上是作用于图。因此，在 "标准数据结构"方法中，它们将在标准图的表示上制定，而标准图的表示不能与被视为图的网格相匹配。

结论是，人们必须与许多不同的数据结构共存。底层数学结构的多样性越丰富，多样性就越多。

\subsubsection{Reuse of Algorithms and Data Structure Conversions}

如果我们不能在不同的组件中规定相同的数据结构，我们可以尝试在不同的表示法之间进行转换，以便能够使用它们。

我们将对`转换`和`复制`进行区分。我们所说的转换是指更普遍的情况，即数据结构可能有很大的不同，而且可能不相等，就像上面的图形/网格的例子那样。只有在没有信息损失的情况下，我们才会使用`复制`这个词，因此这个过程是可逆的，而且工作与原始数据的大小成正比。

我们已经强调过，在不同的组件之间转换数据结构会引起几个问题。第一个问题是它所带来的开销，包括速度和内存使用方面的开销。在某些情况下，它可能可以忽略不计，比如在矩阵/图形转换的例子中，在上下文中，线性系统求解的工作可能占主导地位。不过，它还是增加了时间和内存的要求，这通常是不受欢迎的。

在其他情况下，转换的开销可能是令人望而却步的。

- 数据可能是隐性给出的，甚至可能不适合放在内存中

- 如果算法在数据大小上是亚线性的，那么转换可能会破坏渐进的运行时间行为；例如局部搜索或第133页上介绍的重叠生成方法。

- 如果问题以嵌套的方式出现，它可能会使算法的速度降低几个数量级。换句话说，它可以使来自不同来源的算法实现的组合实际上是不可行的。

下一个主要问题是可用性。一般来说，人们必须了解这两种数据结构的内部情况才能在它们之间进行转换，所以转换可能是一项非难事，实际上是重用的严重障碍。

第三个问题是，如果需要将额外的数据与输入相关联，例如，一个有限元网格的域分解的分区号。那么，源和副本的实体之间的对应关系必须被保留，这可能是一个棘手的问题，并进一步增加内存消耗。更加困难的是，当数据结构被算法改变时，例如网格优化或稀疏矩阵的重新排序。一般来说，完全不清楚这些变化是如何被映射回原始数据结构的。

然而，转换问题还有另一个方面。除了确实需要两个副本的情况外，还可能有性能方面的原因。有时，增量构建的最佳数据结构（动态使用）与特定算法使用的最佳数据结构（静态使用）明显不同，因此，转换可能确实是有好处的。

另一方面，最佳数据结构的知识与算法的细节密切相关。这个决定最好是留给算法部分来做。

因此，转换和复制当然是有用的，而且往往是必要的操作；对它们的支持是至关重要的。然而，对于$n$不同的数据结构，一个天真的方法将需要$n(n-1)$转换算法，因此不能随着数据结构数量的增加而扩展。

总而言之，实现应该努力使转换成为不必要的。不幸的是，目前的实践和技术使得它们往往是必要的，以便重新使用对底层数据结构假设不兼容的算法。

因此，核心问题是：`如何制定算法，以便以独立于具体数据结构的方式运行`。这个问题将在本论文的其余部分得到解决。

\subsection{The Generic Programming Approach: A Step Towards Algorithm Reuse}

\subsubsection{The Idea of Generic Programming}

前面的部分明确了要解决的基本问题。一方面，在科学计算的许多分支中发现了数据结构的巨大（和不可避免的）差异。另一方面，虽然算法在原则上不受这些差异的影响，但具体的实现通常会因致力于随机的细节而受到阻碍。因此，主要的任务是在保持效率的同时`将算法的实现`与`具体的数据表示`解耦。因此，可以实现高水平的可重用性。

我们在这里提出的解决方案与某种观点的转变有关。传统上，在FORTRAN等程序性语言中，算法是唯一可以被语言建模的实体。后来，面向对象的语言通过将数据结构的接口与实现分开，允许数据抽象化。不幸的是，这导致了将算法埋入主要面向数据的类中的趋势。然而，算法是他们自己的概念，必须有一个独立的表示，以便独立地被重用。

算法的 "隐藏 "在像GUI编程这样的领域中并不是一个大问题，因为在这些领域中算法扮演的是次要角色。当算法是一个领域的基本抽象时，它就成了一个严重的问题，就像科学计算中的情况。

通用编程[MS89][MS94][Ste96]将重点转移回算法上。它以一种`抽象`的形式专注于它们的先决条件，也就是说，它根据一种算法或一类算法对数据结构进行了分类。一个算法的应用范围通常延伸到大量的数据结构。实现应该尽可能地保留这种通用性，以便成为抽象实体的忠实的具体代表。

由于这种对算法及其实现的强调，通用编程有时也被称为`面向算法` [MS94] 。正如 [Wei98] 所指出的，通过算法和数据结构的分离，这两个概念都被提升到一个同等的抽象水平上。数据抽象的优点绝不是被抛弃，而是通过对算法及其与数据结构关系的相应抽象来补充甚至提高。

通用编程的一个必要前提是彻底的领域分析 [PD90] 。

\textbf{领域分析} 构建通用组件的一个必要前提是对想要涵盖的算法和数据结构进行调查。

- 确定感兴趣的对象的数学结构

- 确定需要寻求通用实现的算法类别

- 建立一个用于表示抽象数学结构的数据结构分类法，与它们支持的功能相对应

- 分析一些有代表性的算法，了解其对数学以及数据结构的基本要求

这一步骤将在第三章进行。

\textbf{抽象} 下一步包括发现算法和数据结构在需求和功能上的共同点和差异性[Cop98]。

- 找到算法的共同要求，找到满足一大类算法的功能

- 将这些要求与数据结构的能力相匹配；根据算法的类别对数据结构进行分类

- 用一套（最好是最小的）`概念`来表示需求和它们相应的功能 `概念`只是需求集的另一个术语。一类核心概念将作为一个薄的中介层，将数据结构和算法分开。这种概念的最突出的例子（在序列领域）是`迭代器`的概念，在下面讨论。网格领域的概念将在4.1节中确定。

落实抽象的概念必须被映射到具体的软件实体。

- 选择合适的编程语言和功能，如模板（泛型）或多态性

- 找到一个合适的语法--表达概念的 "通用拼写"。

在$4.2$节中，我们描述了`通用组件`如何基于之前开发的概念。

在这个阶段，人们在选择目标语言方面并不完全自由。我们的选择是C++，这是在第2.3.5节中提出的决定。然而，应该指出的是，本论文的结果在很大程度上是独立于语言的。

在本节开始时，`效率`已被确定为通用编程的一个重要目标。因此，`抽象概念`必须遵守两个原则。首先，它们必须暴露--而不是隐藏--数据结构的基本性能特征，比如`随机访问`是否需要恒定时间。其次，通过使用`抽象概念`的`实现`而不是直接使用底层表示法所引入的开销必须被最小化。理想情况下，应该有可能以自动的方式，例如通过优化编译器，将其完全去除。

效率考虑是区分概念和要求系统与抽象数据类型$(\mathrm{ADT})-$概念的一个方面，与纯粹的ADT相比，实现实际上在某些定义明确的方面很重要。

与经典ADT的第二个区别是`概念的颗粒度`。我们已经提到，一类核心的抽象概念是`迭代器`，它基本上在算法和（序列）数据结构之间扮演着中介的角色。这个概念抓住了数据结构的一个基本方面，但在某种意义上，它从通常的ADT所描述的功能中切出了一个 "薄的水平切片"。具体的数据结构通常在不同的环境中扮演许多不同的角色，这种情况一般不会被ADT的概念很好地处理。

另一方面，一个给定领域的整套概念和要求很可能包括相互矛盾的问题，这些问题不能由任何具体的组件同时满足。在一个特定的算法（或一类算法）的背景下，我们实际上只需要满足这些要求的一个极小的子集。如果一个特定的组合出现得足够频繁，明确地命名它可能是有用的。然而，在理论上，可能有指数级的许多组合，对它们进行命名是不切实际的。

为了更深入地了解通用编程方法，我们详细地研究了一个众所周知的例子。

\subsubsection{An Introductory Example: The STL}

C++标准模板库（STL）[LS95]已经成为最著名的通用编程的例子之一。STL的重要性主要不在于它作为一个容器类库所提供的功能（尽管它远远超过了其他库所提供的功能），而是在于它对问题域的结构化方式。人们对通用技术的兴趣增加，当然有一个原因是这个库的存在。

STL关注的是线性序列的领域和对其进行操作的算法，如计数、排序和分区。

`序列`是一个真正无处不在的概念。除了它们在容器数据结构中的 "自然 "家园，它们常常是更复杂结构的一个方面，因此常常被隐含地表示出来。

STL确定了几个核心类别的概念，代表了领域的基本抽象。

- 一些任意的数据类型的`序列`，最明显的是`容器`。

- `迭代器`抽象了一个`序列`中的位置或地址的概念。

- 在序列上通用的算法，由一对迭代器[begin, end]表示。

- 函数对象封装了对不透明数据类型的操作，如比较、谓词或代数操作。

在这种情况下经常提到的其他类别是封装内存管理策略的分配器，以及改变某些实体的行为或语法的`适配器`。然而，`分配器`是专门用于实现容器的，不会干扰其他类别。另外，`适配器`在某种程度上与这些类别是正交的，我们把它们贡献给修改的概念所属的类别。所以，将`二元运算符`的一个参数绑定以产生一个单元运算符的函数-对象适配器属于函数-对象类别。

另一方面，我们也可以把例如在基本容器类型参数化中出现的数据类型视为附加概念。在STL的上下文中，也许只是不值得麻烦，因为一般来说，对这种类型的唯一要求是它是可分配的。其他一切都在算法或容器实现中被参数化，特别是`比较`操作。

下面是一个非常简单的通用算法的例子，计算满足一个`谓词 Pred`的项目的出现次数。

~~~C++
template <class Iter, class Pred>
int count(Iter begin, Iter end, Pred p)
{
    int cnt = 0;
    while (begin != end)
    {
        if (p(*begin))
            ++cnt;
        ++begin;
    }
    return cnt;
}
~~~

从这段代码中，我们可以得出一些看法。

- 算法不以`容器`为参数，而是以`迭代器`为参数，允许处理一般的序列，包括输入流和飞行中创建的序列。

- `序列`由迭代器的半开区间[begin, end]给出。

- `迭代器`的语法借用了C语言的指针；事实上，指针是有效的迭代器类型。

- 在这段代码中，迭代器必须提供以下操作。

    - 递增(++开始)

    - 解除引用 (*begin)

    - 相等测试（begin != end）。


也就是说，该算法的足迹只包括对`迭代器`的三次操作。

有趣的是，这些操作对于一大类算法来说已经足够了--此外，人们偶尔需要知道与迭代器相关的类型，最值得注意的是`value_type`，这是迭代器 "指向 "的类型。差异的主要来源是迭代器的增量能力。与指针的属性相比，这里使用的`unitstride forward increment`是一个相当弱的要求。对增量能力的更精细的区分导致了迭代器的五个不同的子类别。

这些是`随机访问`（允许在恒定时间内任意跳转），`双向`（允许增量和减量），`正向`（只允许增量），`输入`（要求增量和解引用交替进行，不可能赋值），以及`输出迭代器`（相同，但不可能读）。在表$2.1$中我们列出了这些类别以及一些原型模型。这些类别是分层排序的；见[Fig2.1] 。



所有的迭代器操作都保证是恒定时间的。再次强调：可以用随机访问功能 "增强 "双向迭代器，但不能用恒定时间随机访问。这样的伪随机访问迭代器不会被认为是可以替代随机访问迭代器的。

事实证明，算法可以在这种迭代器分类的基础上完全通用地实现。如果有必要，在迭代器类别上有一个编译时分支，以选择适当的实现，然后对这个具体的迭代器有最佳的复杂性。最优性应被理解为与所选算法有关；例如，BUBBLESORT对于所有排序算法的类别来说，从来没有最优的复杂性。

为了说明问题，请考虑二进制搜索。这个算法对一般的前向迭代器实现一次，使用$O(\log n)$比较和$O(n)$增量，对随机存取迭代器专门实现一次，只使用$O(\log n)$增量。

事实上，代码实际上是一样的，因为与二进制搜索相关的前向和随机访问迭代器的不同行为已经被封装在前进基元中，在随机访问上是$O(1)$，在前向迭代器上是$O(n)$。这种技术概括了通用编程中的一个重要设计原则。

尽量将非均匀性处理在一个尽可能低的水平。

我们将一次又一次地遇到它，因为它可以被看作是实现通用性的一种同质化手段。更高层次的（二进制搜索）可以以完全通用的方式实现。

在这一点上应该指出，同质化技术关键是取决于泛型程序和类可以被专业化。通用性机制的这一属性标志着比简单的基于宏观的方法有了显著的力量。如果专门化可以保持部分通用性（部分专门化），它就会变得更加强大，因为这允许建立专门化的层次结构。

从 "下面 "看，同质化模式变成了一个多算法模式。基于数据的（静态）属性，选择一个特定的 "算法"，在我们的例子中是ADVANCE。这种方法可以用在复制算法的实现上。如果序列是一个连续的位数可分配类型的内存块（例如内置类型的数组），那么就会调用更快的`memcpy()`例程。在更高的层次上，`copy()`可以被调用，而不用担心使用低级工具是否会更有效率。通用性是无怨无悔的。这里进行的优化超出了通常在直接的、非通用的实现中所做的。分支要求我们能够在编译时决定一个类型是否具有比特可分配属性。因此，多算法方法正常工作的一个必要前提是对概念的性能子类别进行彻底的分析，然后采用实现技术，使信息在编译时可用。这种分析通常是工作中最难的部分。

\subsubsection{Sparse matrices revisited}

对于稀疏矩阵来说，让一个实现适合于带有两个参数的随机访问下标的ADT$(i, j)$是非常诱人的，然后人们可以将所有种类的矩阵算法应用到这个抽象中。然而，这种方法实际上是毫无价值的，因为它忽略了基本的性能问题--而这正是发明稀疏矩阵的目的所在。一些可能对算法感兴趣的特征属性是

- 稀疏矩阵$A$的所有非零元素能否在与非零元素数量成比例的时间内被列举出来$N Z(A) ?$这将区分密集表示和稀疏表示。

- 能否在恒定的时间内确定一个给定的位置$(i, j)$是否为非零？

- 能否在恒定时间内访问给定位置的条目$(i, j) ?$如果不能，至少对角线位置？

- 能否在与该行（列）中的非零点数量成正比的时间内访问某一行（列）的所有条目？

一个重要的功能层是所谓的 "稀疏BLAS"：基本的代数矩阵-向量操作，如矩阵-向量乘积。在这一层之上，大多数的迭代求解算法都可以被构建，例如参见迭代方法库（IML++） [DLPR99] 或迭代模板库（ITL） [LS99a] 。然而，到目前为止，还没有通用的稀疏BLAS建立在更低的层次上，就像上面提到的那些；直接的方法会导致组件的组合爆炸（参见第30页）。一个非常有前途的方法是使用数据库的概念 [Kot99] 。

如前所述，一般来说，具体的数据类型并不局限于单一ADT的模型，相反，不同的ADT可能代表了对具体类型的可能看法。一个稀疏矩阵$A=\left(a_{i j}\right)$可以被看作（除其他外）是

- 一个由其非零条目组成的容器 $a_{i j}$ ，其中 $(i, j) \in N Z(A)=\left\{(i, j) \mid a_{i j} \neq 0\right\}$ 为

- 其行（列）的容器

- 一个以$1 \leq i \leq n$为节点的有向图，以及一条从$i$到$j$的边，如果$(i, j) \in N Z(A)$。

- 一个具有$a_{i j}=0$的全矩阵，如果$(i, j) \notin N Z(A)$的话

为了使用相应领域的算法，人们必须提供实现看---关系的适配器。例如，如果人们想在非零点序列上使用STL算法，就必须为这个序列提供STL风格的顺序迭代器。

\subsubsection{Generic Programming for Grids}

泛型编程已经证明了它对一类数学上简单但非常重要的概念的有用性，即线性序列。它是否可以扩展到更复杂的问题领域？

一个这样的候选领域是网格和基于网格的算法领域。它们对科学计算的重要性，特别是对PDEs的数值解，已经被讨论过了，还有它们在其他领域的作用。此外，我们对现有软件的调查显示，缺乏足够通用的组件来应对该领域的变化。

数据结构差异问题的可能解决方案的缺点，即复制和标准数据结构，已经在前面描述过。那里讨论的论点与网格领域高度相关。

通常，在数值PDE求解中，网格和相关的数据结构占程序总内存消耗的很高比例，这可能是问题大小的一个限制因素。因此，复制会导致内存和性能的瓶颈，除了像预处理（网格生成和划分）和后处理（可视化）这样的 "外围"操作是常见的做法外，复制被排除在外。但是，这些步骤也可以从通用范式中大大受益。

另外，在$3.1$和$3.3$节中讨论的数学网格类型和表示它们的数据结构的巨大差异性，使得我们不可能选择一个标准的数据结构。例如，对于笛卡尔网格，我们可以使用隐式表示法。然而，许多算法并不利用笛卡尔的特性，可以从通用的实现中获益。

此外，如前所述，基于网格的应用所使用的一些重要算法更适合在图上操作。因此，如果要重复使用图形算法，网格和图形的标准表示法就必须匹配，这是不可能的。

开发通用`网格组件`比开发`通用序列`组件更难。这有几个原因。一方面，数学结构更加丰富。序列主要通过遍历功能而不同，由迭代器的类别来表示，如向前、双向或随机访问。相比之下，网格可能在更多的方面存在差异，可能会影响到对最适合的算法的选择。

数学结构的丰富性导致了更详细的概念。我们将确定几何网格的三个主要子概念，即定义连接性的组合层，定义嵌入几何空间的几何层，以及定义如何将网格实体映射到任意值的数据关联层。组合概念本身由迭代器等组成，但对序列来说如此强大的单一迭代器抽象让位于整个迭代器家族。

此外，如上所述，网格可以扮演许多不同的角色，例如，它们可以以多种方式充当序列或图形。因此，一些作用于网格的算法更恰当地属于另一个领域。如果我们认真对待通用方法，它们的实现应该基于其他领域的抽象。为了在网格领域重用这些算法，我们必须在双方的抽象概念之间定义一个合适的映射，从而正式确定 "视同 "关系的含义。

最后，`动态数据结构`的语义对于网格来说比序列更复杂--改变网格的方法比改变序列的方法多，同时，对网格的改变必须尊重更多的结构。一些重要的算法最自然地作用于动态数据结构，例如网格细化。为这些算法寻找通用的实现方法是一个挑战。

到目前为止，讨论一直围绕着算法的通用实现。在我们对网格领域的调查中，我们将看到数据结构也可以从通用方法中受益，见第4.2节中描述的组件。也许最令人信服的例子可以在第5章分布式网格中找到，一个通用算法和数据结构的系统增强了对给定顺序网格的并行化支持。

\subsubsection{Language and Implementation Issues}

在选择通用范式作为主导原则之后，第一个决定是选择一种编程语言。在本案例中，选择的是 C++ 。让我们解释一下原因。

有许多语言支持参数多态性，比如ADA泛型 [MS94] ，EIFFEL [Mey92] ，或C++模板 [Str97][BN95] 。在所有这些语言中，只有C++在科学计算中得到了广泛的使用。

在这种情况下，C++已经证明了其提供高效代码的能力。最近，已经开发了一些技术[VJ97]，允许实现与FORTRAN相同的效率，FORTRAN仍然是这方面的参考。

另一个论点是$\mathrm{C}++[$ Cop98]的多范式性质。人们可以在适当的地方使用面向对象的特性，在重要的地方使用经典的程序式，以及对我们来说最重要的通用编程。所有这些范式都可以在科学计算应用中并行使用，比如第6章中讨论的。

事实上，C++对通用编程有非常详尽的支持。作为 C++ 标准库的一部分，STL的发展与C++标准 [Int98] 的发展同步，并对后者产生了明显的影响 [SS95] 。因此，C++的模板机制到现在已经比其原始版本复杂和强大得多。像模板专业化、部分专业化和函数模板的部分排序这样的功能允许建立通用性的层次结构，并进行上面描述的那种同质化（p.38）。这些特性也允许像模板元编程这样的技术 [Vel95b] ，或者可以用来让C++编译器做某种部分评估 [Vel99b] 。

成员模板无缝整合了泛型和面向对象的编程。默认的模板参数对于提供通用组件的简化版本很有用，同时允许更高的参数化程度的高级用法。最后，模板参数本身的潜力还没有被发掘出来。

总之，这些特征清楚地表明，C++的模板机制远远超出了简单的类似宏的替换技术。在比较丰富的内容中，它是任何足以用于科学计算的语言中所没有的。

第二个决定是为分析步骤中确定的概念定义一个语法（通用拼写）（见$4.1$节和附录7.3）。通用库中的所有实现都将坚持使用这种语法。

因此，任何实施都会（重新）引入一些任意性的因素，而这些因素在早期阶段已经通过大量的劳动被消除。核心问题是如何将这些任意的决定本地化并加以控制。

明显的 "方法是为问题领域制定一个标准化的语法。但是这被证明是相当不切实际的，因为标准化过程是缓慢的，如果成功的话。一个领域越复杂，就越不可能在什么属于这个领域的问题上达成共识，更不用说像接口这样的细节了。

也许最困难的问题是跨域的语法和语义（"view $x$ -as-y "关系）。正是在这里，标准化的方法最终必然会失败，因为很明显，每个领域都有自己的语言，也见2.2.4.4节的讨论。

一般来说，最好的希望是有一个事实上的标准。在C++社区中，由STL设定的 "标准 "似乎已经接近序列领域的这种状态。

STL的语法概括了预定义的语言结构，比如指针（用于迭代器）和函数调用（用于函数对象）。事实证明，如果语法是 "自然 "的，那么达成一致的机会就更大。在C++中，这通常意味着它使用 "典型的"操作符语法，并得到操作符重载的支持。不幸的是，这对于更复杂的情况来说已经不够了。

处理这种情况的一种可能性是将 "任意性参数" 捆绑到特殊的实体中，例如从C++模板编程中知道的所谓`traits`类 [Mye95] 。通过这些特征的参数化，实现允许用户引入从他们的母语拼写到算法库的翻译。

因此，`translator traits`绝不是一些小的变通办法，而是一个重要的`概念`，使重用首先成为可能。它们包括类型定义和算法所需的查询功能。

`traits`也允许向一个通用组件传递更多的上下文信息，因为通常情况下是可以的，例如不同的比较操作。这种技术的一个例子是附录C.1中记载的邻居搜索程序的CGT参数。在大多数例子中，为了保持简单的表述，没有显示这样的特征。

对通用方法的可行性的真正考验是独立开发的组件的互操作性。这对于序列的情况来说是相当直接的。一些初步的例子已经被开发出来，用于与GGCL图库的互操作（见下文），但完整的证明还有待完成。

\subsubsection{Related Work}

在科学计算和其他以算法为中心的领域，如计算几何学，`通用编程`越来越成为关注的焦点。因此，通用的软件组件正在变得可用。在下文中，我们将讨论一些例子，包括用于密集和稀疏线性代数、计算几何和图算法的组件。

BLITZ++ [Vel99a] 实现了基本 $n$维数组以及对它们的代数操作。宣布的目标是实现与FORTRAN 77相同或更高的性能。这是通过使用模板元编程等高级技术来实现的 [Vel95b]。对于缓存优化的模版操作，作者报告了使用直接的方法比FORTRAN代码有明显的速度提升。模板操作使用基于`HILBERTS`空间填充曲线的数据定位增强阵列遍历 [VJ97]。原则上这也可以用FORTRAN语言实现。通用方法的决定性优势在于，虽然在传统的环境中，这个策略必须在每个循环中重现，但这个策略的单一通用实现就足够了--这是一个明显的关注点分离 [HL95] 。

矩阵模板库MTL[LS99b]包含密集和稀疏矩阵的数据结构，以及通用的底层算法（BLAS-功能）和通用的LU-因子化。

GMCL（生成矩阵计算库[CEKN99] ）定义了生成矩阵数据结构。参数化的可能性包括入口类型、结构类型（密集型、带状型、三角形等）、数据布局等。因此，它们允许丰富的具体数据结构集合被实例化。据报道，GMCL支持大约1800种不同的实例，仅计算可能的入口类型的内置浮点类型。

迭代模板库ITL [LS99a]提供了用于解决线性系统的迭代方法的通用实现。它包含像CG这样的迭代算法和像ILU这样的预处理程序。

CGAL[pro99]实现了几何计算的通用类和程序，例如凸面体和三角计算。底层数据结构的复杂性比之前引用的矩阵/阵列库要高得多。大多数算法都是通过特征类（见上文）进行参数化，以实现原始操作的定制。增量算法通常以类的形式实现，如DELAUNAY三角法和增量凸壳法$3 \mathrm{D}$ 。这些类由几何特征类导入所需的基本几何操作和`谓词`来设置参数。像点这样的几何实体被算术类型所参数化，比如实数的精确或浮点表示。

最近的一个库是GGCL（Generic Graph Component Library [LSL99][LLS99] ），它使用基于`容器`的方法来处理图的邻接关系，有点类似于我们在后面章节中开发的概念。对顶点或边的数据的访问使用`装饰器模式`（见[GHJV94]），这似乎是相当普遍的，但不像本工作后面开发的网格函数方法那样舒适（第75页，第4.1.4节）。

LEDA（第26页）库本身并没有定义通用图算法。然而，最近增加了一个图迭代器扩展包[NW96]，它实现了一些基本的图算法，例如广度优先遍历算法或DIJKSTRAs最短路径算法。这些都是作为允许逐步执行的算法类来实现的。Weihe, Kühl和Nissen [KNW97] [KW96] 已经在这个方向上进行了较早研究。对边缘数据（例如DIJKSTRA中的长度）的访问是通过数据访问器[KW97]进行参数化。它们扮演着数据关联（网格函数）的角色，在第75页讨论。

近年来，在编程和软件开发领域发生了许多有趣的发展，似乎也与科学计算高度相关，如主动式库 [VG98] ，生成式编程 $\left[\mathrm{CEG}^{+}\right]$ ，或面向方面编程 [KLM $+97]$ 。对这些发展的详细介绍将超出本论文的范围。一个很好的概述可以在 [Cza98][CE00] 中找到。我们将在$7.3$节中简要地回到这些问题，在那里我们讨论进一步研究的可能方向。


\section{The Grid Domain}


在上一章中，我们已经指出了网格对于许多计算科学领域的基本作用，比如科学计算、计算机图形和计算几何。但究竟什么是网格？如果我们把这个问题问给在刚才提到的领域工作的人，在任何单一的情况下，答案也许在第一眼就会很清楚。然而，仔细观察肯定会发现，不可能给出一个与网格一词的所有用途相匹配的正式定义--事实上，有一个数学结构家族通常被称为`grids`, `meshes`, `subdivisions`, 或 `complexes`。

因此，实现可重用的网格组件的一个重要步骤是彻底的领域分析。在第一步中，我们介绍了网格的一些基本数学特性，指出了它们的显著特征，并为网格相关的数学术语建立了一种词汇表。然后，在第3.2节中，我们分析了一些典型的网格算法，以找出它们需要哪些网格属性，以及网格数据结构必须提供哪些功能才能应用该算法。最后，第3.3节针对算法的要求分析了网格数据结构。也从这个角度考察了这种数据结构的现有实现。

本章的结果是第四章中开发通用可重用网格组件的重要前提。

\subsection{Mathematical properties of grids}

像`拓扑学`和`多角形理论`这样的数学领域已经发展了一些概念，为网格的推理提供了坚实的基础。下面几节将回顾这些学科的一些定义和结果。我们首先研究`拓扑学`的基础，然后回顾凸多面体理论的贡献，最后讨论网格的组合特性及其与几何网格的关系。

当人们考虑到计算机中的有限可表示性时，组合和几何方面的区别就自然产生了。对于`combinatorial kernel`来说，这通常更容易实现，因此，它也构成了几乎所有网格数据结构的基础。

`几何方面`就其本质而言是非离散的，因此一般来说不能准确地表示。事实证明，在这方面，拓扑学的概念往往是 "一般的"，而多角形理论所承认的几何图形通常是 "受限制的"。

\subsubsection{Topology of Cellular Systems}

雷尼-汤曾经说过。"拓扑学正是一门允许从局部到整体的数学学科"。从局部到全局结构的一个工具是`cellular complexes`，它提供了一种通过局部联系简单对象（细胞）来表示复杂几何结构的方法。正是这种表示方式首先使拓扑学相关问题的计算处理成为可能。

本节只定义与本主题有直接关系的概念；关于基本术语，请参见任何介绍性的文本，如HENLE [Hen79] 或 JÄNICH [Jän90] 。对细胞系统理论的全面处理可以在MOISE [Moi77] 、LUNDELL和WEINGRAM [LW69] 或FRITSCH和PICCININI [FP90] 的书中找到。

基本构件是 $\mathbb{R}^{k}$ 中`open balls`的`同构`图像。

\textbf{Definition} 1（开放单元）。设$X$是一个Hausdorff空间。如果一个集合$c \subset X$与开放的$k$维球$\mathbb{D}^{k}=\{x \in \left.\mathbb{R}^{k} \mid\|x\|<1\right\}$的内部同构，那么它就是一个开放的$k$单元。根据域的不变性定理，$k$这个数字是唯一的，被称为$c$的维度。

以适当方式装在一起的细胞集合形成更大的结构，即所谓的`complexes`。

\textbf{Definition} 2（CW-complex） 一个有限的$C W$-complex $\mathcal{C}$是一个由成对不相交的集合$c$和$\|\mathcal{C}\|:=\bigcup_{c \in \mathcal{C}} c$上的Hausdorff topology组成的系统，其中集合$c$是$\|\mathcal{C}\|$中的开放单元，对于每个$k$ -单元$c$有一个连续特征映射

$$
\Phi: \overline{\mathbb{D}^{k}} \mapsto \bar{c}
$$

这是$\mathbb{D}^{k}$与$c$的同构，并且将$\mathbb{S}^{k-1}$映射为$\mathcal{C}$的低维单元的联合，即$c$的边。$\|\mathcal{C}\|$中的闭合$\bar{c}$是$c$和其所有边的联合。复数$\mathcal{C}$被认为是底层空间$X=\|\mathcal{C}\|$的单元分解。

如果对于一个$k$-单元$c$，映射$\Phi$延伸到$\overline{\mathbb{D}^{k}}$的整体上的同构，那么$c$是规则的；那么它的边是$\mathbb{S}^{k-1}$的分解同构。如果CW复合体$\mathcal{C}$的所有单元都是正规的，那么它就是正规的。

直观地说，非规则性来自于识别单元的部分边界，如[Fig3.1]中的环形。在实践中，非规则单元出现在多块网格下的粗略网格中，例如所谓的$C$ -网格或$O$ -网格。

\textbf{Remark} 1.在拓扑学文献中，$C W$-complex不一定是有限的；为它们假定的附加公理（这引起了名称中的'$C W$'）在有限情况下是微不足道的。为了避免混淆，我们此后将只使用复数这个术语，指的是有限$C W$-复数。

\textbf{Definition} 3.如果$\mathcal{C}$是维数为$d$的复数，我们称其0-单元的顶点，1-单元的边，2-单元的面，$d-1$单元的面，以及$d$单元的简单单元。

在整个文献中，顶点和边的使用是一致的，而面和面的使用则不是这样的；参见关于多边形的章节$3.1 .2$。虽然在拓扑学中，使用任何维度的单元是相当普遍的，但在数值模拟实践中，特别是有限体积的说法中，其使用仅限于最大维度的单元 $d$ 。

因此，在使用顶点、面等术语的情况下，单元将专门表示$d$-单元，而术语$k$-单元、$k$-元素或只是元素将分别用来表示尺寸$k$或未确定尺寸的单元。与有限元混淆的危险应该较少。参见表$3.1$中的概述。

复合物的定义建议将其看作是将一个给定的拓扑空间$X$细分为单元。思考复合体的一个补充方式是通过将单元粘在一起来构建它们。这导致我们定义邻接关系。

\textbf{Definition} 4（入射）。如果一个元素$f$是另一个元素$c$的边，即$f \subset \bar{c}$，我们说$f$和$c$是入射，并写成$f<c .$ 如果，此外还有$\operatorname{dim} f=\operatorname{dim} c-1$，那么我们也写成$f \prec c$。

如果两个元素$e, f$入射，没有任何关于相对尺寸的信息，我们使用一般符号$e \lessgtr f .$ 所有$k$-元素$e \in \mathcal{C}^{k}$入射到一个元素$f$的序列被表示为$\mathcal{I}_{k}(f)$ ，参考第89页。


相同维度的元素$k$从不相交，因为开放单元的边界没有内点，因此不能包含$\mathbb{D}^{k}$的同构图像。

在这种情况下，相邻关系的概念并没有被很好地使用。我们对顶点和单元进行定义。

\textbf{Definition} 5（相邻性）。如果两个单元有一个面与之相邻，那么它们就是相邻的；如果顶点与一条共同的边相邻，那么它们就是相邻的。相邻的单元（顶点）被称为邻居。

\textbf{Definition} 6（同质维）。一个不属于另一个元素边界的元素被称为主元素。如果每一个主元素的维数都是$d$，那么一个复合体就具有同质维数$d$。

在[AH35]之后，有可能在一个复合体的有限元素集上定义一个离散拓扑$\mathcal{C}$，这允许用拓扑语言来表达许多组合语句。

\textbf{Definition} 7（离散拓扑学）。在复数$\mathcal{C}$上的离散拓扑学中，当且仅当一个$A$集合是一个$k$元素与它的边的联合，或这类集合的联合时，该集合是封闭的。

由此可见，包含一个给定元素$e$的最小开放集（在离散拓扑学中）是通过与所有高维的入射元素的联合得到的。这个集合被称为$e$的开放星st $(e)$ 。st $(e)$的边界被称为$e$的$\operatorname{link} \operatorname{lnk}(e)$。只要所考虑的集合是元素的联合体，那么边界是相对于原始拓扑结构还是离散拓扑结构而言并不重要。

\textbf{Definition} 8（子复数）。如果$\mathcal{C}^{\prime}$本身是一个复数，那么复数$\mathcal{C}$的一个子集$\mathcal{C}^{\prime} \subseteq \mathcal{C}$被称为$\mathcal{C}$的子复数。这里可以理解为，$\left\|\mathcal{C}^{\prime}\right\|$被赋予了关于$\|\mathcal{C}\|$的子空间拓扑结构。

这相当于说，对于每个$c \in \mathcal{C}^{\prime}$，它的边也包含在$\mathcal{C}^{\prime}$中；或者说，$\left\|\mathcal{C}^{\prime}\right\|$在$\|\mathcal{C}\| .$中是封闭的 如果$R \subset \mathcal{C}$，那么$R$的封闭$\bar{R}$是包含$R$的最小的子复合。一种特殊的子复合物是骨架，通过去除高维的元素得到。

\textbf{Definition} $\mathbf{9}(k$ -skeleton $) . \operatorname{By} \mathcal{C}^{k}$ ，我们指的是$k$ -elements of $\mathcal{C}$ 。由所有$l$-元素组成的集合$l \leq k$，被称为$k$-骨骼。

对于每个$k$，$k$-骨架是$\mathcal{C}$的一个子复数。特别是，1-skeleton是一个图。请注意，除了$k=0$之外，$\mathcal{C}^{k}$一般来说不是一个子复合物。

复数的一个重要特例是简约复数。

\textbf{Definition} 10（简单的复合体）。如果$\|\mathcal{C}\| \subset \mathbb{R}^{n}$为某个$n$，并且$k$的$\mathcal{C}$单元是$k$-维简单$(0 \leq k \leq d)$，那么$\mathcal{C}$被称为简单复合体，是空间$\|\mathcal{C}\|$的三角化。

简单的复合体总是有规律的，因为每个单线都是有规律的。从历史上看，在WHITEHEAD提出CW复合体之前，简单复合体已经被使用很久了。从拓扑学的角度来看，CW-复数通常比单纯复数更受欢迎，因为它们具有更大的灵活性。因此，有可能将环形分解为具有一个2单元、两个1单元和一个0单元的一般复合物，见[Fig3.1] 。需要更多的简单单元来创建一个同构的简单复合物，见 [Jän90] 。这种增加的通用性对于几何建模的目的也很有趣，尤其是唯一的几何约束是单元与适当维度的盘的同构。另一方面，许多实体建模方法使用单元与具有有限多孔的单位球同构。这种情况甚至不包括在CW-complex的一般定义中。

到目前为止，一个复合体的基础空间$X$是相当随意的。对于大多数实际目的来说，一个相当有限的类就足够了。

\textbf{Definition} 11（流形）。维度为$d$的流形是局部同构于$\mathbb{R}^{d}$的Hausdorff空间；有边界的流形是局部同构于$\mathbb{R}^{d}$或封闭半空间$\mathbb{H}^{d}=\left\{x \in \mathbb{R}^{d} \mid x_{d} \geq 0\right\} .$的流形，$M$的边界是$M$局部同构于$\mathbb{H}^{d}$ 的点的集合。

因此，一个流形（有边界）的规则细分被称为流形（有边界）复合物，简称m复合物和mwb复合物。这样的细分显然是同维的。流形的简单例子是球体$\mathbb{S}^{d}$，以及有边界流形的封闭单位球$\overline{\mathbb{D}^{d}}$。显然，流形可以被看作是有边界的流形的特殊情况。

[Fig3.3]显示了一个非manifold复合体的例子。请注意，一个mwb-complex的子复合体不一定是mwb-complex，即使它是同维的，见[Fig3.4]。这个复合体显然可以嵌入到维数为2的mwb复合体中，而第一个例子则不能，因为中间面有三个入射单元。



\textbf{Definition} 12（边界）。只与一个$d$单元相邻的面称为mbw复合体的边界面；其他面（与两个$d$单元相邻）为内部面。边界复合体是所有边界面的闭合。

我们上面所定义的更恰当地称为组合边界（MOISE [Moi77] ）。要证明它与拓扑流形边界相同是不难的，对于$d=2 .$的情况需要著名的乔丹曲线定理。$d=3$的情况更难，当知道乔丹定理的类似物在$\mathbb{R}^{3}$中失败时就可以理解：存在着所谓的野球，确实将$\mathbb{R}^{3}$分成两个以上的部分，请再次参阅MOISE书中的一个例子。然而，这里的主要困难来自于允许单位球的任意同构图像作为单元。从实践的角度来看，考虑到这种映射在计算机中的有限可表示性，这并不构成问题。对于有限类型的几何单元（如简单），证明很简单。

在物理建模中出现的大多数拓扑空间都是$d$-维的域或实体。

\textbf{Definition} 13（实体）。一个$d$维的实体是一个$d$维的边界嵌入在$\mathbb{R}^{d}$的人形。因此，相应的单元分解被称为实体复合体。

紧凑实体的边界是一个没有边界的紧凑$d-1$-manifold。

乍一看似乎只有mwb-复合体对科学计算有兴趣，但是更一般的复合体类型在很多地方出现。一个复合体的$k$-骨架不是流形复合体（除非在特殊情况下），一般来说，单元集的闭合也不是。在复杂求解现象的几何建模中，如冲击前沿，所谓的冲击跟踪，或者在模拟某些力作用下的表面演化[Bra92][Bra]中，非流形复合物会以一种自然的方式出现。

\subsubsection{Convex Polytopes}

在最基本的几何对象中，凸多角形是最基本的几何对象。它们可以被看作是细胞结构，但比一般的复合体表现出更多的规则性。关于凸多面体理论的介绍，见ZIEGLER [Zie94] 一书。这里我们只举出一些定义和结果。

\textbf{Definition} 14（凸多角形）。凸多边形$\mathcal{P}$是$\mathbb{R}^{d+1}$中某个$d \geq 0$的有限点集的凸壳。$\mathcal{P}$的维度是它的仿生壳的维度。

$\mathcal{P}$与 "切线 "半空间的交集给我们提供了$\mathcal{P}$的面（在本节中，我们使用术语面，因为它在多面体理论中被使用，它对应于$k$-元素或$k$-单元的拓扑学）。

\textbf{Definition} 15（多角形的面）。如果对于一个固定的$c \in \mathbb{R}^{d+1}$，不等式$c^{T} x \leq \gamma$对所有$x \in \mathcal{P}$都有效，那么$f=\mathcal{P} \cap\left\{x \in \mathbb{R}^{d+1} \mid c^{T} x=\gamma\right\}$就是$\mathcal{P}$的一个面。根据这个定义，$\mathcal{P}$和$\emptyset$也是（不恰当的）面。所有其他的面都被称为适当的面。一个面的维度是其凸壳的维度；按照惯例，$\emptyset$的维度被设定为$-1$ 。如上所述，维数为0的面被称为顶点。

下面的定理收集了多面体的有用的几何和组合属性。

\textbf{Theorem} 1.设$\mathcal{V}(\mathcal{P})$为多角形$\mathcal{P} .$的顶点集，以下性质成立。

1.  $\mathcal{P}$是其顶点的凸壳。

$$
\mathcal{P}=\left\{\sum_{v \in V(\mathcal{P})} \lambda_{v} v \mid \sum \lambda_{v}=1, \quad \lambda_{v} \geq 0\right\}
$$

对于一个点$x=\sum_{v \in \mathcal{V}(\mathcal{P})} \lambda_{v} v \in \mathcal{P}$，$\lambda_{v}$的数字一般来说不是唯一的，除非是简单点。它们被称为$x .$的arycentric坐标。

2. $\mathcal{P}$是$\mathbb{R}^{d+1}$的有限多个半空间的交点。由这些半空间定义的维度$d$的面被称为$\mathcal{P}$的面。

3. 每个面$f$本身就是一个多面体，其顶点集为$\mathcal{V}(f)=\mathcal{V}(\mathcal{P}) \cap f .$ $f$的适当面被称为子面。

4. $f$的面是$\mathcal{P}$中包含在$f$中的面，特别是$\mathcal{V}(f)=$$\mathcal{V}(\mathcal{P}) \cap f$。

5. 面的交叉点是面。

6. 一个面是由其顶点集唯一决定的，也就是说，没有两个面有相同的顶点集。因此，它是其顶点集的凸壳。

7. 一个面是由包含它的面的集合唯一决定的。它是定义这些面的仿生空间的交点。

从定义中可以看出，多角形的面是封闭的。一个开放的面是一个没有子面的面。从该定理中，我们立即看到，多面体的开放面是一个复合体的元素。这个复合体是一个实体（见第50页$)$，而多面体的边界复合体是一个流形复合体。请注意，属性$5-7$对于一般的实体复合体来说是不正确的，参见[Fig3.5].

几何表征1和2是互补的。它们对应于组合特性6和$7 .$。应该注意的是，几何特性一般来说是不稳健的。对于一个非单纯顶点（在一个顶点上，多角形具有单纯形的局部结构），干扰定义入射面的超平面将导致组合变化。当移动一个非单纯面的顶点时也会发生同样的情况。因此，如果对组合结构感兴趣，那么除了单数之外，几何特征与不精确算术的结合并不足以表示多面体。

\subsubsection{Combinatorial Structure of Complexes}

一般的蜂窝状复合体和凸形多边形都是用几何学概念介绍的。然而，我们无法在计算机中表示任意的几何复合体。相比之下，有限复数的组合结构很适合这一目的，并且是任何离散表示法的核心。

因此，在接下来的两节中，我们将采用不同的观点，主要将复合物视为组合实体，而将几何结构视为一个额外的实体，这将不得不在以后的步骤中附加。

为了了解网格的组合属性能够（或不能）说明底层的复杂情况，有兴趣单独研究它们。这些属性对数据结构的内部布局以及适用于网格的一类算法有很大影响。

重要的是要看到哪些算法只依赖于复合体的组合--而不是几何--属性。作为一条经验法则，只使用组合信息会导致更稳定的算法，而当一个算法可以只用组合术语来制定时，使用几何信息往往是一种不恰当的推理的标志。

在一个复合体的封闭元素上$\mathcal{C}$，包容$\subset$定义了一个偏序$<$，即第$47 .$页上定义的发生关系，这个关系包含了$\mathcal{C}$的组合结构，由poset的概念捕捉到。

\textbf{Definition} 16（poset）。一个poset$(\mathcal{S},<)$是一个有限集$\mathcal{S}$，连同一个偏序<，它是反对称和传递的。

图$3.6$使用哈斯图来显示一个复合体的位置集。元素被画在所有较小的元素之上。如果任何两个元素是可比的，并且没有 "中间 "的元素，则用一条线连接。如果存在唯一的最小和最大元素，那么一个poset就是有界的$\hat{0}$，$\hat{1} . \mathrm{A}$链是一个poset的完全有序子集。如果每个最大的链都有相同的长度，即元素数减去1，那么一个有界的poset就被称为分级的。对于$a \leq b$，区间$[a, b]$是其间所有元素的集合。

$$
[a, b]=\{c \in \mathcal{S} \mid a \leq c \leq b\}
$$

如果$\mathcal{S}$是分级的，那么$a \in \mathcal{S}$的等级就是$[\hat{0}, a]$中一个最大链的长度。

$\mathcal{C}$的位置集可以通过连接不适当的元素$\hat{0}=\emptyset$和$\hat{1}=\|\mathcal{C}\|$，使之成为一个有界的位置集，其尺寸为$-1$和$d+1$。那么下面的定理就会成立。

\textbf{Theorem} 2.对于同维$d$的规则复数$\mathcal{C}$，单元格形成的poset是分级的，$k-1$元素的等级为$k$。

证明。对于$d=0$来说，这个说法显然是正确的，如果它在$d-1$中成立，我们可以作如下论证。由于同维性，每个最大的链必须包含一个维度为$d$的单元，并且规则性保证在$\bar{c}$中存在一个维度为$d-1$的单元$c^{\prime}$。现在$c^{\prime}$位于$d-1$的骨架中，通过归纳法有等级$d$，因此$c$有$\operatorname{rank} d+1$ 。

\textbf{Definition} 17（格子）。格子是一个有界的位置集，其中任何两个元素$a, b$都拥有唯一的最大下界$\min (a, b)=a \wedge b$（相遇）和唯一的最小上界$\max (a, b)=a \vee b$（连接）。如果一个等级$d+1$的分级网格的每个元素都是等级为1的元素的连接（原子），那么它就是原子性的；如果每个元素都是最大等级$d$的元素的相遇（外套），它就是外套性的。

两个元素$c_{1}, c_{2}$的相遇对应于它们的几何交叉点$\overline{c_{1}} \cap \overline{c_{2}}$，连接到包含它们的最小维度的元素$c$。  $\bar{c} \supset c_{1} \cup c_{2}$ .两个元素的连接可以是整个网格。一般来说，满足和连接操作不是分配性的。

\textbf{Theorem} 3.凸多边形的poset是一个原子和外套的格子。此外，它还具有钻石属性。如果e和$g$分别是维数为$k-1$和$k+1$的入射面，那么区间$(e, g)$正好包含维数为$f_{1}, f_{2}$的两个面

对于一个任意的复合体来说，poset一般来说不是一个格子，见[Fig3.5] .$ 如果一个网格的格子是原子的，这意味着$k$ -单元是由它们的顶点集唯一决定的；如果格子是外套式的，$k$ -单元的顶点集可以从$d$ -单元的顶点集的知识单独决定。因此，原则上只需存储已知有外套网格的每个$d$-单元的顶点集。当从一些仅有部分已知的格式中读取网格时，这一观察也是有用的，例如，由顶点集的指数给出的组合立方体，但没有规则这些与立方体的面的关系。

具有非空边界的实心复合体不是外套式的，因为边界面不能通过单元格的相交得到。在某些情况下，例如，如果复合体是凸多边形的子复合体，这可以通过为每个边界面添加人工单元来补救（或者将边界面的顶点集作为算法的额外输入）。

\textbf{Definition} 18（抽象复合体）。维度为$d$的抽象（或组合）复数$\mathcal{A}$是一个有限有界的位置集（不一定是分级的），其元素$e \in$$P \backslash\{\hat{0}, \hat{1}\}$被标记为一个维度$\operatorname{dim}(e) \in[0, d]$ ，这样$e<f$意味着$\operatorname{dim}(e)<$$\operatorname{dim}(f)$

如果一个抽象复数$\mathcal{A}$是分级的，那么一个元素的维度显然必须与它的等级减一相吻合。对于一个复数$\mathcal{C}$，我们用$\mathcal{A}(\mathcal{C})$表示相应的抽象复数。

\textbf{Definition} 19（组合形态）。抽象复合物$\mathcal{A}_{1}, \mathcal{A}_{2}$之间的组合形态是一种尊重发生的映射$\Phi: \mathcal{A}_{1} \mapsto \mathcal{A}_{2}$。  $e<f \Longrightarrow$ $\Phi(e)<\Phi(f)$ 。如果$\Phi$是注入性的，它被称为单态性；如果是双射性的，它被称为同态性。

如果两个几何复合体$\mathcal{C}_{1}, \mathcal{C}_{2}$是同构的，并且$\mathcal{C}_{1}$的元素被映射到$\mathcal{C}_{2}$的元素，那么$\mathcal{A}_{1}$和$\mathcal{A}_{2}$显然是同构的。

一般来说，反之亦然：如果两个抽象复合体是同构的，这并不意味着它们是同构的，例如，二维环、克莱因瓶和投影空间$\mathbb{R} \mathbb{P}^{2}$都可以由同一个抽象复合体来表示，它由一个单元、两条边和一个顶点组成。然而，我们可以证明，当且仅当两个简单的复合体的抽象复合体是同构的，它们才是同构的。

\textbf{Definition} 20（对偶位置集）。我们说，如果两个位置集$\mathcal{P}$和$\mathcal{Q}$具有相同的元素，但顺序关系相反，那么它们就是对偶的。因此，获得一个poset$\mathcal{P}$的对偶的过程可以被认为是把它的哈斯图倒过来。对于一个等级为$d$的分级poset，这意味着等级为$k$的元素对应于对偶中等级为$d-k$的元素。

如果两个复合体的位置集是对偶的，那么它们就被称为对偶。在流形复合体的情况下，有可能构建一个几何实现（见下文），它是同一流形的一个细分（见[AH35]）。对于有边界的流形来说，这是不可能的--我们必须为每个边界成分添加一个人工单元。因此，人们通常会修改边界上的对偶位置集，例如将边界的对偶位置集（它是一个流形复数）加入到对偶位置集中。在几何学上，这相当于将 "扩大的 "复数（包括人工外单元）的对偶与原复数相交，也见[Ale98] 。

\section{The Euler-Poincaré Formula}。

空间的一个基本拓扑属性$X$是欧拉特征$\chi(X) \in \mathbb{Z}$。借助于$X$的单元格分解$\mathcal{C}$，它可以通过欧拉-庞加莱公式计算出来。

$$
\chi(X)=\sum_{c \in \mathcal{C}}(-1)^{\operatorname{dim} c}=\sum_{k=0}^{d}(-1)^{k}\left|\mathcal{C}^{k}\right|
$$

其中$\left|\mathcal{C}^{k}\right|$是$k$的$\mathcal{C}$单元的数量。尽管对分解$\mathcal{C}$有明显的依赖性，但欧拉特性是基础空间$X$的拓扑不变量。

对于2-球体，我们有$\chi\left(\mathbb{S}^{2}\right)=2$，在这种情况下，方程$3.1$简化为经典的欧拉公式

$$
V-E+F=2
$$

其中$V, E$和$F$分别为顶点、边和面的数量。

二维实体的欧拉特性$\Omega \subset \mathbb{R}^{2}$是构件数减去孔数。对于三维实体，欧拉特征等于成分数-隧道数$+$孔数。对于任何维度的凸多边形，欧拉特征等于1。

\subsubsection{Geometric Realizations of Abstract Complexes}

我们通过 "忘记 "复数的几何属性，得出了一个有限的、可表示的结构。然而，在实践中，我们通常希望与几何复合物一起工作。因此，有必要回答如何以一致和建设性的方式将几何信息与抽象复合物联系起来的问题。

组合属性与几何属性的分离不仅具有理论意义，它也导致了相应数据结构中关注点的更清晰的分离，见3.3.1.3节。定义21（几何实现）。一个抽象复数$\Gamma$的几何实现$\mathcal{A}$（或简称为几何）是一个具有同构位置集的复数$\mathcal{C}$。我们把$\|\mathcal{A}\|_{\Gamma}:=\|\mathcal{C}\|$写成$\mathcal{A}$在$\Gamma$下的图像。

这个定义回答了关于几何和组合结构的一致性问题；但它没有提供如何以可在计算机中表示的建设性方式描述这种实现的线索。

原则上，给出每个元素的特征映射就足够了。然而，这些没有给出一个元素的几何形状和它的侧面之间的关系。因此，我们被引向元素原型这一稍有限制的概念，它也包含组合信息，并引入其边的标准列举。这使得我们也可以处理某些类型的非规则单元。

\textbf{Definition} 22（一个元素的原型）。让$c$是组合复数$\mathcal{A}$的$k$-元素。$c$的原型$\mathfrak{a}_{c}$是一个维度为$k$的正则复数，正好有一个$k$-元素$a_{c}$并满足以下特性。

1.它是$\mathfrak{a}_{c}=\bar{a}_{c}$ ，和$\mathfrak{a}_{c} \subset \mathbb{R}^{k}$ 。

2.有一个连续的特征映射

$$
\Phi_{c}: \mathfrak{a}_{c} \mapsto \bar{c}
$$

是$a_{c}$在$c$上的同构，它引出了一个也叫$\left.\Phi_{c}\right)$的抛射性组合形态$\mathcal{A}\left(\mathfrak{a}_{c}\right) \mapsto \mathcal{A}(\bar{c})\left(\right.$。

3.  $\Phi_{c}$将$a_{c}$的每条边都映射到$c$的同维边上。此外，如果$\bar{c}$是规则的，那么$\Phi_{c}$就是一个同构的。

4.对于每个维度$j<k$，在$j$的边上有一个固定的顺序。

5.对于$c$的每一面$f$，都有一个固定的原型$\mathfrak{a}_{f}$。

映射$\Phi$可以将$a_{c}$的几个面送到$c$的同一个面，从而将这些面 "粘在一起"。该原型允许区分这些边。然而，由于在$\Phi_{c}$下具有相同预像的边必须具有相同的维度，该定义排除了边被 "挤在一起 "导致维度损失的单元。因此，像图$3.1$中的环形分解的单元格是允许的，像图$3.2$中的单元格则不允许。

Archetypes允许经济地存储重复的发生模式，特别是在面向细胞的数据结构中，见3.3节。通常，它们被隐含地使用，见第 $3.2 .1$ 节。

现在可以通过为$\mathcal{A}$的每个$d$单元列出原型来定义一个抽象复合物$\mathcal{A}$的几何实现。这些原型必须是一致的，也就是说，对于两个单元$c_{1}, c_{2}$附带的每个元素$e$，我们必须有

$$
\Phi_{c_{1}}(e)=\Phi_{c_{2}}(e)
$$

有时，我们需要更多，例如在定义单元上的有限元空间时。在这种情况下，我们可以要求每个原型是一个凸的多面体。这就在每个$d$-单元上定义了arycentric坐标。对于低维的元素，我们可以通过以下要求来加强条件$3.2$。对于每一个入射到两个单元$c, c^{\prime}$的元素e，存在一个线性映射

$$
L=L_{e}=L_{e, c, c^{\prime}}: \mathbb{R}^{d} \mapsto \mathbb{R}^{d}
$$

这样，连续性关系

$$
\Phi_{c}=\Phi_{c^{\prime}} \circ L \quad \text { on } \quad \mathfrak{a}_{c}
$$

认定。根据重心坐标的仿生不变性，这些坐标也是唯一地定义在尺寸为$k<d$的元素上。

在许多实际的方法中，通过简单地固定顶点的几何位置，就可以给出一个几何嵌入。然而，这只有在所有单元都是组合简单的情况下才是毫不含糊的。那么我们可以通过简单地给出$\Phi_{c}$的顶点上的$\mathcal{A} .$的值来定义一个线性嵌入。 在其他情况下，例如六面体单元，我们隐含地假设三线嵌入，对于平面和平行面来说，它退化为线性的嵌入。然而，在一般情况下，将这种映射明确化当然是个好主意。

在简单的情况下，映射$L$可以以直接的方式定义。在其他情况下，$\mathfrak{a}_{c}$和$\mathfrak{a}_{c}^{\prime}$的面之间不需要存在线性映射，例如，两个平面四边形不一定彼此仿生等价。在这种情况下，我们必须用一个更一般的识别映射来取代线性映射$L_{f}$。

然而，对于大多数实际用途来说，维度是以3为界限的，而可用的原型只限于一些标准的原型，这并不构成问题。请注意，线性映射只需要在原型之间，而不是在几何单元本身之间。

\subsubsection{Some Special Grids and Geometries}

对于像有限元方法这样的数值算法的使用，上面定义的一般复数是很普遍的。对于复杂几何形状的建模，凸多面体是限制性的。一般来说，不同的背景需要不同程度的灵活性和通用性，包括组合和几何方面。

\textbf{Definition} 23（网格）。从现在开始，我们为同维的复合物保留网格这个术语。因此，网格的子网格是一个也是同维的子复合物。

从最简单和最有限的可能性开始，笛卡尔网格是一个网格，其组合结构等同于网格的单元是

$$
\left\{\left[i_{1}, i_{1}+1\right] \times \ldots \times\left[i_{d}, i_{d}+1\right] \mid 0 \leq i_{j} \leq m_{j}\right\}
$$

伪笛卡尔网格是笛卡尔网格的一个子网格（同一维度）。

维度为$d$的多块网格由一个一般的复合体（粗网格）组成，其单元是$d$-维的立方体，每个立方体又被$d$-维的笛卡尔网格（块）划分。入射到同一立方体一侧的区块在该侧是同构的。多块网格的粗大网格是使用非规则网格的一个典型例子。一个非常常见的单元类型是所谓的O型网格，它是极坐标系的一个环形部分，也就是一个有两个对边标识的四角形。

任何不属于上述三种类型的网格被称为非结构化网格。一个特例是简约网格，它的单元在组合上等同于简约。

一个计算域几乎总是一个有边界的流形。一个有边界的流形复合体，其单元在组合上等同于凸多边形，允许上述那种几何学上的实现。此外，如果入射集合是一个格子，我们称这样的格子为多顶格。

多面体网格的格子属性保证了元素顶点集的交点总是唯一地定义了一个低维元素，这是一些算法的重要前提条件，例如算法CELL NEIGHBOR SEARCH，第61页。通常情况下，元素多面体的类型只限于少数，如$2 \mathrm{D}$中的三角形和四角形，以及$3 \mathrm{D} .$中的四面体、立方体和棱镜。通常情况下，这个函数空间的元素是低度和小支持度的片面定义的多项式，一般来说，它至少需要在面上是连续的。这对任意多面体来说不是一项简单的任务。

线性或直线几何（维度为$n$）是一种几何实现，其中每个$k$元素都被映射到$k$维度的仿生子空间的子集。特别是，边总是通过直线段连接顶点。

一个映射的几何体是通过将全局映射与一个更简单的嵌入相结合来定义的，比如说一个线性几何体。

笛卡尔几何学是笛卡尔网格的几何学，它是整数网格的统一缩放和平移；因此，几何单元是轴平行的正方形。

\subsection{Grid Algorithm Requirements}

我们一再强调算法对科学计算的重要性，算法实现的重用是成功掌握该领域软件复杂性的关键--就像任何其他以算法为中心的领域一样。

正如之前所指出的，将数据表示问题与算法方面分离是实现可重用算法组件的一个重要步骤。底层数学结构越复杂，分离就越重要（也越困难）。

现在是分析在网格上运行的算法的时候了，看看它们如何与网格互动，以及网格数据结构需要什么样的功能。不用说，没有希望分析该领域的每一种算法；然而，精心挑选的一组有代表性的算法将为我们提供有益的见解，特别是，分析将阐明许多需求的共同点。

\subsubsection{Persistent Storage of Grids}

需要的最基本的操作之一是在一些持久的存储介质上输出一个网格。为了这个目的，存在着许多格式。为了举例说明，我们使用表$3.2$中描述的格式，用于一般的二维网格，混合组合和几何信息。


算法表3.1给出了从网格中写入这种格式的文件的算法。我们可以很容易地发现这个算法的要求。

1.查询一个网格的单元格和顶点的数量。
2.遍历所有顶点和所有单元格
3.3. 获取一个单元格的顶点数量；遍历一个单元格的顶点。
4.读取一个顶点的坐标
5.访问每个顶点的数字，这样顶点是连续编号的，从1开始。

关于连续列举，这可以在算法过程中产生，具体如下。


然后我们有一个新的要求，即把临时（整数）数据与一个顶点联系起来。

当然，这种算法忽略了任何复杂的几何类型，因为文件格式只能表示顶点坐标，而没有弧形边缘或类似的东西。另外，在试图从这样的表示法中重建网格时，有一个关于细胞顶点序列的微妙的隐含假设，即连续的顶点属于同一边缘。事实上，这是一个关于细胞原型的假设。在二维空间中可能没有太多选择，但在三维空间中这是一个真正的问题，在那里原型不再是 "自然的"，必须明确地固定在某个地方。

\subsubsection{Cell Neighbor Search}

许多算法需要访问他们的邻居单元。这种信息往往需要从更基本的数据中创建，比如表 $3.2$ 中描述的文件格式提供的信息。在这种情况下，单元格的顶点序列是已知的，这样连续的顶点就是一个面的顶点集，即二维的边。三维网格的文件格式将需要提供关于面的顶点集的额外信息。

从这种情况出发，可以通过算法$3.2$计算单元格邻居，得出以下要求。

1.每个面的顶点集是唯一的（例如，网格是多角形的，见第58页）。

2. 每个面最多有2个细胞

3.对一个网格的所有单元进行迭代

4. 在不知道单元格邻居的情况下，对一个单元格的所有面进行迭代

5. 访问一个面的顶点集，（对一个面的顶点进行迭代就可以了

6.比较顶点集的平等性，这意味着：顶点必须是平等可比的。

7.为了保证地图$\mathcal{N}$的有效实现，这样的顶点集必须是完全有序的，或者被赋予一个哈希函数，这基本上意味着对顶点有同样的要求。

考虑到固定的底层网格，对单元和顶点有一种最小的表示方法也是有利的（有利于内存效率） $\mathcal{G}$ 。

\subsubsection{Bandwidth-reducing Ordering of Grid Elements}

通常，网格元素对应于线性方程组的未知数。对于基于消除策略的求解算法，减少矩阵的带宽往往是有利的，也就是由线性方程耦合的两个未知数的最大差值，见 [Saa96] 。

这个问题最好用图来表述，其中节点对应未知数，两个节点之间的边意味着相应的未知数被矩阵中的一个非零条目所连接。然后，任务是为节点编号，使相邻节点编号的最大差值最小。


一个著名的带宽最小化启发式算法是CUTHILL-MCKEE算法，它本质上是一种广度优先的遍历，按节点度增加的顺序对每层进行排序。


根据通用编程的精神，这个算法应该以图的形式实现，而不是以网格的形式。很明显，这增加了重用的可能性。如果我们有一个带有未知数的网格，比如说，单元格，两个未知数通过方程连接，当且仅当它们对应的单元格是邻居时，那么这个网格可以很容易地被映射成这样一个图，把单元格看作节点，把面看作边。但这决不是网格产生图形的唯一可能方式。例如，如果未知数住在顶点上，就会产生一个不同的图形。

因此，为算法的操作找到 "自然 "的数学结构是非常重要的--基于网格的描述必须区分所有这些情况，而基于图形的描述则不需要。

现在，为了分析CUTHILL-MCKEE ORDERING的网格功能，我们必须固定一种解释。为了简单起见，我们选择单元格面的情况，然后指出在采取不同情况下的变化。

1.对单元格的邻居进行迭代

2.查询一个小区的邻居数量

3.整数$(N)$和布尔（Mark）数据与单元格的联系


一个特别的说明适用于映射马克：如果赋值$\operatorname{Mark}(v)=0 \forall v \in \mathcal{G}$能在恒定时间内完成，那将是有利的，特别是如果算法只在网格（图）的一部分上执行。

如果我们将未知数存储在顶点上，例如定义线性系统，使属于一个共同单元的顶点由一个方程耦合（典型的FEM矩阵），那么我们将不得不用顶点代替 "单元"，用一个顶点附带的所有单元和单元附带的所有顶点的更复杂的迭代来代替邻居迭代；事实上，这里需要的是对一个顶点的链接进行迭代（见第48页）。

当未知数在比这个例子中更大的距离上耦合时，情况会变得更糟。对于典型的数值应用，这种耦合可以用所谓的模版来描述，这是在第5.5.4节中讨论的话题。

网格到图形的映射可以用一种通用的方式完成。目前，细胞邻接图与GGCL库的初步映射（第44页）已经实现。因此，对于从网格产生的每一种类型的图形，只需要一个软件组件，以及一个实现实际算法的组件。

\subsubsection{Graphical Output}

网格的图形输出当然是一个重要的工具，例如，它可以对网格质量进行视觉控制。实际上，产生视觉输出的任务由两个子任务组成。第一，从网格数据结构中生成几何实体；第二，在一些图形设备上对这些实体进行渲染，比如像素图形或postscript文件。渲染步骤还包括诸如剪裁、照明和相机定位（对于三维物体）。

在这里，我们只关注第一步，依靠一些未指定的图形设备的通用绘制方法，该方法适用于像线和多边形这样的简单对象。

图形输出的可能性是多方面的，我们只限于举一些典型的例子。一个简单的线条图形（"线框"）可以按以下方式制作。



一个更高级的可视化方法，特别是对于$3 \mathrm{D}$网格，是单元的收缩视图。每个单元都向其中心缩减了一些系数，以提供对连接性的更好的洞察力。


这些微小算法的要求如下。

1.对所有边或所有单元格的迭代

2. 对一个单元格的所有面进行迭代

3. 边缘与几何段的映射

4.一个切面与一个几何多边形的映射

5.写入对多边形顶点坐标的访问

6. 细胞中心的计算

请注意，一般来说，属于边缘的片段可能是弯曲的。在这种情况下，必须进行额外的工作，将它们转化为更简单的实体。多边形也是如此。

然而，将这些转换的责任分配给渲染引擎GraphicsDevice是明智的，因为关于可表示基元的知识就在这里。另外，可以用一种更有意义的方式来处理分辨率问题；例如，一个曲线段必须分成多少个线段的问题。

\subsubsection{Particle Tracing }

在$2.2 .4 .3$节中已经讨论过的粒子追踪技术，是可视化静止流的一个重要工具。基本上，它是对一个网格上的随时间变化的矢量场的积分。我们勾勒出一个给定时间间隔的单个粒子的积分，例如数值模拟的一个时间步长。

在这里，我们使用一些数值ODE求解方法，该方法在局部场上工作 $F_{c}$ ，我们假设该场足够平滑，并在任何点提供恒定时间的评估 $x \in c$ 。例如，它可以是一个常数或线性函数。此外，一些在网格中定位点$x$的方法是必要的。在这里，我们知道一个好的起始单元作为提示，因此可以使用局部搜索方法。


在这里，我们只搜索细胞的最近附近 $c_{0}$ 。假设增量与单元直径相比很小，这可能是真的，也可能不是真的。一般来说，对于局部搜索，我们可以从$c_{0}$开始，对网格进行广度优先的遍历，直到找到包含$x$的单元。这里的问题是停止的标准。如果一个单元格位于边界上或靠近边界，我们必须决定该点是否已经通过边界离开了网格。为了做到这一点，我们还可以在搜索中加入方向性信息，这可以指导宽度优先的遍历。例如，我们可以总是选择在适当方向上的邻居。

所示简单版本的要求如下。

1. 在单元格（或顶点）上存储浮点数据

2.测试细胞中的点状包容

3. 对单元格邻居的迭代，或对与给定单元格共享一个顶点的所有单元格的迭代。

对于高级搜索，我们还需要。

1.迭代一个单元格的切面

2. 与切面相交的射线

3. 测试一个面是否在网格的边界上

在一个有限的单元格集合上的迭代，比如那些与给定单元格共享一个顶点的单元格，往往需要标记已经访问过的单元格。为了提高效率，这种标记必须绝对是与被标记的单元格数量成线性关系的，也就是说，开始时所有单元格的取消标记必须是 $O(1)$ 。

一个不同的方法是从离散网格数据中 "伪造 "一个全局定义的函数，提供从任意空间位置的评估。然而，在这种情况下，单元的位置必须发生在全局函数中，这最终导致了与增量搜索相同的问题。全局搜索一般来说是很昂贵的，因为它没有利用连续的评价通常在空间上很接近的事实。

\subsubsection{Grid Refinement}

根据一些误差指标对计算网格进行细化是偏微分方程自适应数值方法的一个关键组成部分。这种算法是比较复杂的，特别是在三维空间。

两个流行的方案是基于二分法和所谓的红绿细化 [Ban98][Bey98] ，基于一些细化模板。$2 \mathrm{D}$ 最早和最简单的二分法是最长边二分法，由RIVARA [Riv84] 提出。其基本概要如下。



在这种算法中，满足以下要求是至关重要的。

1.网格是一个三角结构

2.可以将一个单元格的顶点集组合成属于两个后裔的两个集合

3.访问一个单元格的边缘

4.访问与某一边缘相关的单元格

5.访问一条边的顶点

显而易见，这里的区别要求是分割单元的能力--其余的只是要求一些相当 "标准 "的入射访问。如果我们选择在一个独立于原始网格的数据结构中建立精炼的网格，我们可以减少对后者的要求，使用一个为算法优化的数据结构来表示中间结果。

\subsubsection{Finite Volume Flux Calculation}

通量平衡方法的简单方案基本上有以下形式（参见第152页）。


这里`boundaryflux`和`interiorflux`是两个例行程序，分别计算边界和内部面的数值通量。两者都使用状态 $U$ 。一般来说，如果我们有一个从$c$单元进入$n$单元的内部面的通量$F$，那么从$n$进入$c$的通量是$-F$ 。因此，我们可以测试通量是否已经被计算过，并使用其结果。一种方法是在单元格上引入一个任意的顺序，只计算从较小的单元格进入较大的单元格的通量，并将其与较大的单元格的通量相反的符号相加。

除了这种基本算法，还有一些方法可以实现更高阶的近似。其中一个例子是所谓的恢复策略，它从恒定的单元格值中构建分片线性函数。第一步是对这些值进行体积平均插值到顶点。


一个不同的方法是在单元格而不是顶点上进行循环。



收集所有算法替代方案的要求，我们有以下内容。

1.对一个网格的所有单元和所有顶点进行迭代 2.对一个单元附带的所有顶点进行迭代

3.对与一个顶点相关的所有单元进行迭代

4. 向量值与顶点和单元格的联系

5. 标量值与顶点的临时关联$\left(\Sigma_{\mathrm{vol}}(v)\right)$

6.获取细胞量

7. 访问单元和面的重心、面的体积和定向法线（在internalflux()中）。

\subsubsection{Finite Element Matrix Assembly}

刚性矩阵的构建是有限元方法的一个关键组成部分。细节基本上取决于所涉及的有限元的类型，也就是说，取决于基础函数空间。详见$6.3 .1$节。

最简单的情况当然是以顶点为中心的线性元素。


在泊松方程$(6.18)$的特殊情况下，第$161, a(c, \phi(v), \psi(w))$页评估了积分

$$
a\left(\phi_{v}, \psi_{w}\right)=\int_{c} \nabla \phi_{v} \nabla \psi_{w} d x
$$

一般来说，这个程序会使用顶点的局部坐标来数值化地评估一个更复杂的积分。

在一般情况下，会有一个与节点相关的Ansatz函数，这些节点可以位于任何元素类型中。我们必须用所有节点的双循环来取代顶点的双循环，这就需要对一个单元的所有元素类型进行迭代。当然，也需要对本地坐标进行访问。

总结一下要求。

1.对网格单元的迭代

2. 对一个单元的所有元素类型进行迭代

3.细胞的局部坐标系

4.为节点分配唯一的数字，也就是首先为元素分配数字。

\subsubsection{Summary of Requirements}

我们可以将这些要求分为组合（见表3.3）、几何（见表3.4）和数据关联（见表3.5）部分。总结一下这些表格，以下一组组合功能是不断重复出现的。

1.对网格或其子范围的所有元素（顶点、边、单元）的迭代，以及对元素数量的查询。

2. 迭代某个锚点元素所附带的所有元素，例如一个单元格所附带的所有顶点，并查询这些元素的数量。

3.元素的连续列举。

4.元素的子集，要求属于一个和同一网格的元素的最小代表。

5.随机访问给定锚点元素的闭合中的元素，与锚点的组合原型有关，例如一分为二的单线的两半的顶点集，或者（FEM）与单元格边相关的节点的局部坐标。

6.将许多不同类型的数据与元素联系起来，有时与某一类型的所有元素联系起来，有时只与其中的一小部分联系起来。

功能的几何部分也有一些重复出现的部分。

1.组合实体到几何实体的映射，例如顶点到空间坐标，边到曲线段，或面到多边形。

2. 计算元素的几何图像的几何度量，例如体积、重心和面的法线。

原则上，大多数几何测量可以基于几何实体来计算，但是不明确要求转换为后者来计算几何测量似乎是明智的。此外，有些，如定向（向外）法线是基于组合实体定义的，在这种情况下，一个面的两个入射单元中的一个被选中，这是更独特的。

根据它们使用的功能类型，我们可以将算法分为组合型（邻居搜索、CuTHILL-MCKEE）、几何型（图形、细化、通量、刚度矩阵）或函数型（粒子追踪）。后一类算法假设在整个网格上定义了一个（片状）连续函数。


\subsection{Grid Data Structures}

在调查了一些有代表性的网格算法之后，现在是时候通过对网格表示的计算方面的研究来补充对网格的数学特性的研究。这项研究将以网格算法领域分析的结果为指导。

我们首先讨论了实现网格数据结构的基本差异性，然后根据我们迄今为止的分析，对现有的方法进行了比较。

\subsubsection{Variabilities of Grid Data Structures}

在我们之前的分析中，发现网格算法的要求可以分为三大类：组合功能（迭代），网格上的数据关联/存储，以及几何基元，我们依次讨论。

\subsubsection{Combinatorial Variabilities}

\textbf{底层数学模型.}。在$3.1$节中，我们已经看到，即使是基础数学结构也有很大的不同。对于笛卡尔网格，组合结构可以用完全隐含的方式来表示。此外，是否只表示特殊的组合单元类型（如单纯体）、一般的凸形多边形或甚至更一般的类型，也有不同的情况。后者出现在几何建模中，通常使用带孔的单元，这些单元甚至不与单位球同构。此外，通常情况下，即使是非结构化的网格也包含一些结构，例如在那些被定期细化过几次的区域。这一点可以被巧妙地利用，以节省一些存储空间，但要将可接受的单元格类型限制为简单的[OR97] 。

另一个常见的区别是流形带边界的网格是否可以被表示--后者在计算几何中经常是这样，当网格表示固体的表面时（B-rep）。

绝大多数数据结构只能表示固定维度的网格；但是，也有关于表示任意维度的网格的结果，见 [Bri89] 。计算几何学的大部分工作都是围绕着二维网格展开的。

\纹理bf{功能.}。对网格表示的操作可以分成不同的组。

- 元素访问。定义了哪些元素类型？一个人可以按顺序访问所有的元素吗？需要多少信息来唯一地确定一个特定网格的元素？

- 发生率-查询。哪些 "单元格的所有顶点 "这样的问题可以被回答？参见$4.1 .3$节，对某类发生率查询进行系统化。- 全局属性查询（Global-property-queries）。数据结构是否提供关于拓扑属性的信息，如连接组件的数量、$k$单元或边界组件的数量？

- 一致性的维护。通常情况下，一个数据结构可以代表比它应该持有的更广泛的数学对象类别，例如，一个用于存储有边界的细分流形的数据类型可能包含如图$3.4$（第50页）的配置。是否有操作来检测这种退化现象？

- 修改。这一方面包括全局网格的构建，另一方面包括增量的动态更新，如单元的删除和添加或欧拉操作（见[Män83]）。如何保证一致性？

\textbf{Efficiency.}。这是在网格大小主导计算时间的所有情况下的首要关注。通常情况下，在下面列出的三个标准之间会有一个权衡。

- 查询效率。发生率查询的成本有多高？这不仅仅是指渐进式的说法，也是指在具体硬件上的具体实现。SHEWCHUK [She96]报告说，在替换网格数据结构时，差异为2倍。然而，查询的累积成本并不只是网格的函数，还取决于使用网格的算法的查询结构，也可以参见 $6.5$ 节中的基准结果。

- 存储效率。储存一个网格需要多少内存？这在很大程度上取决于数学模型，例如，是否允许任意单元，或者网格中是否有一些规则或层次结构，在这种情况下，所有或部分的发生率信息可以被推导出来，例如，见 [OR97] 。支持的查询和修改功能也会影响到所需的存储大小。对于简单的网格，存在各种压缩方法，见 [Ros98] 。

- 修改的效率。对数据结构进行增量或累积修改的成本有多大？廉价的修改往往与查询效率相反。在首先有一个构建网格的阶段，之后只进行查询的情况下，将整个网格复制到另一个表示中可能会更好。

\Implementation Complexity.}文本bf{实施的复杂性。数据结构固有的复杂性往往会大大阻碍正确实现的产生，导致其他低劣的解决方案被优先考虑。另一点是对增量开发的支持程度，也就是说，功能是否可以在以后的时间里轻易地被添加。

关于网格数据结构的核心问题是，是否存在一个自然的 "最大 "功能集（一个微内核），超过这个功能就可以以通用方式实现。我们将在 $4.2$ 节中开始回答这个问题。

\subsubsection{Data Association Variabilities}

在数学背景下，或者在抽象地描述一个算法时，我们经常以一种相当无辜的方式谈论诸如 "让$f$是$\mathcal{G}$边上的一个函数 "或者 "将$c$附带的所有顶点标记为被访问"。由于函数的数学概念隐藏了这些函数如何执行其映射的计算方面，它大大简化了对网格的推理。

这里的基本数学概念是一个函数 为了更精确地说明问题，我们把网格函数称为一个函数

$$
f: \mathcal{G}^{k} \mapsto \mathcal{T}
$$

将一些网格$\mathcal{G}$的$k$元素（$f$的元素类型）映射到一些类型$\mathcal{T}$（$f$的值类型）的对象。对于$f:$有两种不同的可能性 要么，它是总体的，即定义在$\mathcal{G}^{k}$的每个元素上，要么，它是部分的，即只定义在$\mathcal{G}^{k}$的一个子集上。我们将分别把这样的函数称为总网格函数或部分网格函数。

$f, \operatorname{dom} f$的域 ，是定义$f$的元素集合。因此，$\operatorname{dom} f=\mathcal{G}^{k}$为总网格函数，而dom$f \subset \mathcal{G}^{k}$为部分网格函数。

必须考虑到额外的计算方面。

- 映射是计算出来的还是明确存储的？

- 对一个值的访问效率如何？

- 如果存储，是否有可能在一个给定的元素上改变值？

- 如果存储，如何访问一个元素的值？

- 如果存储，该函数是否必须为特定网格的所有$k$-元素明确定义，或者只有一小部分元素与默认值不同？

- 是否有可能创建临时网格功能？在任何时候可以有多少个共存？对价值类型是否有任何限制$\mathcal{T} ?$ ？

- 评价的前提条件是否要在运行时检查？

- 在部分网格函数的域外访问一个元素的值，其语义是什么？是错误，是返回无效的值，还是用户可以定义一个要返回的值？

- 动态行为。如果底层网格发生变化，网格功能是否仍然有效？预计底层网格会经常变化吗？


全部函数和部分函数之间的数学区别值得特别注意。它与对于一个存储的网格函数是否必须明确定义所有的值的问题不同，但这些方面还是密切相关的。

对于一个存储的总网格函数，预期的默认行为是相对明确的：它可以在$\mathcal{G}^{k}$中的任何元素上被访问，但如果没有明确设置，其值是未定义的。然而，对于部分网格函数，为没有明确定义值的元素定义一个默认值往往是很方便的。

要看到这一点，请考虑以下常见的情况。在一个算法的高层描述中，人们发现一个类似 "将所有顶点标记为未访问 "的语句。如果有关的算法在网格的大小上是亚线性的，例如局部搜索，那么 "标记为未访问 "的动作是至关重要的 $O(1)$ 。因此，我们在这里要的是一个网格函数

$$
f: \mathcal{G}^{0} \mapsto\{\text { true, false }\}
$$

它对读的访问具有全函数语义，但对写的访问具有部分函数语义。

事实证明，这种行为是一种非常普遍的需求，如果需要的话，在实践中相当容易获得读取访问的部分函数行为，例如，通过设置一个唯一的、无效的默认值。此外，这样的部分网格函数的实现一般都有一个手段来确定一个元素是否属于该域，这可以被客户端使用。

完全定义和部分定义的网格函数之间的区别似乎是一个基本的区别；通常，可以毫不含糊地确定一个给定的函数是完全的还是部分的。因此，为这些完全和部分定义的特征提供实现是至关重要的；产生了完全和部分网格函数。

部分函数和全部函数之间的其他重要区别包括空间和时间的权衡（部分函数使用较少的空间，但通常有些慢）和额外的功能。在一个巧妙的实现中，应该可以得到部分网格函数$f$的域，也就是明确定义了$f$的元素集。

\subsubsection{Geometric Variabilities}

在第3.1.4节中，我们已经看到了数学网格的组合和几何方面是如何干净地分开的。在本章早些时候，我们注意到有些算法根本没有使用任何几何信息。

在软件组件领域，保持这种分离既直接又有用。  `Straightforward` ，因为固有的组合结构不会被几何嵌入所触及。有益的是，这种分离使得组件更有针对性，增强了重用性，并根据算法是否使用几何信息对其进行干净的分类。

数学嵌入有以下可能性。

- 拓扑空间$X:$的类型 它可能是某些$n \geq d$的$\mathbb{R}^{n}$（其中$n=d$是最常见的情况），一个嵌入$\mathbb{R}^{n}$的流形，或更复杂的东西。

- 如果$X=\mathbb{R}^{n}:$的原型映射到$\mathbb{R}^{n}$，可以选择非常不同的方式。在最简单的情况下，它可能是线性的，将每个实体映射到$\mathbb{R}^{n}$的仿生子空间中，但也可能是任意弯曲的嵌入。

计算方面的内容对网格几何来说尤其丰富。

- 功能性。什么类型的几何信息是可用的？见表$3.6$中的（限制性）概述。

- 效率权衡。如何管理这些基元的计算和存储之间的权衡？

- 精确性。该组件是否对基元进行精确的计算，而不是数字近似计算？这对非线性嵌入尤其重要。

- 运算。几何学是使用精确运算还是浮点运算？

- 动态行为。如果底层网格发生变化会怎样？

- 可变性。是否可以逐步改变几何形状？

- 排他性。不同的几何形状是否可以平行用于同一个网格？

所用的算术问题对适用的算法类别特别重要。许多计算几何学的方法都假定了精确的预言，例如，如果一个点位于超平面之上或之下，则可能失败。另一方面，数值方法往往对浮点运算中固有的不精确性不太敏感。在这里，性能问题是最重要的。与几何计算相比，根据算术结果做出决定的频率较低，对一致性的要求也不高。因此，在网格上使用这两种类型的算法时，可能需要不同的几何组件。

调整存储和计算之间的权衡提供了一个几乎连续的可能性。它们的范围从笛卡尔几何学，其中所有的东西（包括顶点坐标）都可以即时计算或者是恒定的（体积），到非线性嵌入，其中所有需要的量都可以提前计算。在这里，为一个特定的应用进行微调可能被证明是值得的，而不会过于复杂。

网格-几何组件可能提供的操作集合是巨大的。首先，一个几何体可以定义代表组合元素的几何对应物的类型。某种类型的$n$维矢量代表顶点，某种线段或弧线代表边等等，还有从组合元素到几何实体的映射。此外，还有一些测量运算符。边缘的长度、面的面积和单元的体积。(为了简单起见，我们在这一节中把组合元素与它们的几何图像联系起来）。)接下来是中心点、法线和更多。然而，这些在每一种可能的情况下都没有任何意义。如果嵌在$\mathbb{R}^{3} ?$中的2D网格的一个面的法线或一个单元格的中心不是线性的，那么这个面的法线是什么？表$3.6$给出了一个概述，以及可能的限制。

\subsubsection{Review of Grid Data Structures}

由于需求不同，不同领域开发了不同类型的数据结构。在计算几何学中，大多数工作都集中在细分的二维流形的表示上，有时有边界，有时没有边界。

其中最著名的是GUIBAS和STOLFI的QUAD-EDGE数据结构 [GS85] 。它以对称的方式表示流形的细分及其对偶。因此，顶点和面是可以互换的，不能在语法上进行区分。单元（面）可以是任意的简单多边形，不需要是规则的，也就是说，一个顶点可以在一个面的边界上出现几次。

2-manifolds的其他常见表示包括WINGED-EDGE和HALF-EDGE数据结构。概述和讨论见 [Ket97] 。这些实现所提供的发生率查询依赖于面和顶点周围的边的排序，并且可以访问两个顶点的下一条和上一条边。LASZLO和DOBKIN在[DL89]中介绍了这种方法的3D变体，其中利用了面和单元格在边上的排序。BRISSON在[Bri89]中利用元素板块的钻石属性，将这些顺序关系推广到任意维度，见4.1.3.3节。他提议将必要的信息存储在所谓的单元图中。那么，一个立方体单元将由$6 \cdot 4 \cdot 2=48$个节点表示，每个节点与其他4个节点相连，总共有$48 \cdot 4=192$个链接，而一个四面体仍然需要96个链接。

所有这些方法的一个共同特点是很容易访问直接入射的元素，但是产生比如说一个给定单元的所有顶点的查询就不那么明显了，特别是在更高的维度。然而，后一种访问模式在数值模拟算法中比在计算几何中更为典型。

在几何建模[Mor97]中，最常用的数据结构之一是边界表示法，简称B-reps。如果要建模的实体包含内部边界，也就是说，由不同的区域组成，要加以区分，相应的B-rep代表一个非网格，因为边缘可能与两个以上的面发生关系。

在数值模拟中，网格通常是一个实体域的细分，也就是一个有边界的流形。通常，单元类型被限制在一个或几个基本的凸多边形，如$2 \mathrm{D}$中的三角形或四角形以及三维中的四面体、棱镜或立方体。对于有限元算法，必须定义低度多项式的函数空间和网格上的局部支持，这严重制约了可能的单元形状（[Wie97]）。其他方法，如有限体积法（FVM），对单元的类型限制较少。

在网格上操作的数值算法经常以单元为基础的方式访问数据，例如需要每个单元的所有顶点或切面。因此，相应的网格数据结构通常也是面向单元的。它们大多由单元的列表组成，每个单元都有对其顶点和单元邻居的引用。虽然这些数据结构适用于数值算法，但有趣的是，它们也可以成功地用于计算几何学。SHEWCHUK在[She96]中报告说，在从类似QUAD-EDGE的数据结构切换到基于单元的数据结构后，Delaunay三角计算的实现速度提高了2倍。

最后，对于笛卡尔网格，入射信息是完全隐含的。网格元素由$d$维的整数索引表示，入射查询可简化为简单的索引操作。

对修改操作的支持是计算几何和数值模拟中网格表示的另一个明显区别。前者通常提供一些欧拉运算符的变体，如附加、分割和删除单元，而后者一般只允许细化和取消定义的操作。细化通过所谓的细化规则，用更小的单元的固定模式取代一个单元。这些规则通常包含闭合规则，以确保相邻单元中的子分部匹配。一些成熟的细化程序是红绿细化 [Ban98] 和基于二分法 [Joe95] 。

同样，定义在网格上的函数空间是这里的主要约束来源。此外，细化经常与多网格方法等分层技术结合使用，这使得网格层的适当嵌套成为必要。

网格生成软件介于数值模拟和计算几何之间。它经常使用比数值算法更多的其他类型的数据结构。

\textbf{Grid functions} 有不同的方法来处理网格函数。在数值分析中，人们通常采用$d$-维数组来处理直角坐标网格。

如果使用非结构化网格，需要的数据通常存储在元素本身。对于非永久需要的数据，如临时标志，也是如此。那么，跟踪哪些数据被使用，哪些不被使用的负担就归于算法实现者了。另外，在网格数据结构的设计中，必须预计到哪些数据会被使用，因此在数据结构和算法之间引入了一个强大的耦合。数据结构必须知道哪些算法将在它们上面执行

然而，这种 "元素中的数据 "方法的优点是使动态网格更容易处理，因为数据的寿命是与底层元素的寿命相联系的。它的缺点是需要永久存储所有的元素类型，即使数据只是临时存储在这些元素上。更糟糕的是，它经常需要永久存储临时数据，可能会成为一个严重的性能瓶颈。

试图补救这种情况的方法包括使用无类型的指针，由客户负责，以及引入多用途的字段。例如，斯坦福图库（Stanford Graph Base）就采用了后一种方法（[Knu93]）。所有这些技术都使客户端更难正确使用数据结构。此外，没有对部分网格功能的支持--如果要设置默认值，必须访问每个元素。

\textbf{Grid geometries}这些几乎总是只隐含地表示，给予访问顶点坐标，并假设线性嵌入。这使得我们很难使用不同的几何图形，因为很难追踪到这些隐含假设的每一次使用。使用哪种几何嵌入的决定不是局部的，而是分散在所有使用几何信息的组件中。

网格几何形状通常与它们的底层网格融合，防止同时使用不同的几何形状。

\subsubsection{Discussion}

在上一节中，我们研究了典型的网格算法的要求并进行了分类，导致了第一个粗略的划分，即组合、几何和数据关联方面。然后，我们调查了网格数据结构的差异和权衡，最后根据我们的发现审查了这些结构的现有实现。尽管这些数据结构有明显的多样性，但很明显，它们都代表了强烈重叠的数学网格类别，正如第3.1节所研究的。因此，在这种数学网格上操作的算法原则上应该适用于这些数据结构中的很大一部分。

这些数据结构中的大多数实际上在原则上可以提供必要的功能，但在网格功能方面有一些限制，特别是部分网格功能。在其他情况下，很清楚如何增加功能，可能是通过增加辅助数据结构。

然而，提供这种功能的实际方式有很大的不同。通常情况下，数据抽象没有得到很好的发展。特别是，网格函数和几何图形往往不能被识别为独立于组合网格的抽象概念。

通常，我们可以看到，源于某个领域的数据结构，例如有限元模拟或计算几何，是针对该领域的典型算法的需要而设计的。这些算法大量使用的操作被以一种舒适和有效的方式支持，然而其他的操作没有或只有微弱的支持，尽管有可能做得更好。

然而，即使在单一领域内，也很少有 "最佳 "数据结构这样的东西。选择哪种数据结构取决于算法集（算法概况），以及实际的或有代表性的数据集--同样的数据结构可能对小的或有规律的数据集表现良好，而对大的或无规律的数据集则不好。

那么，事实再次证明，有必要将表征问题与算法问题分开，在第2.3节中已经详细论述了支持这一主题的问题。因此，作为前面几节指出的重叠的结果，一个共同的功能平台是可取的和可能的。这将是下一章的任务。82 第3章.网格领域


\section{Components for Grids}


我们已经论证了为网格数据结构的功能建立一个通用框架的潜在收益和主要可行性。现在，是时候确定这样一个通用内核的细节了。在这个过程中，我们将决定哪些功能属于最内层--一个微内核，它将为每个具体的网格类型提供特殊的实现方式；相反，哪些功能可以在外层通用实现。微内核将与数学意义上的实际网格概念紧密对应，而其他任何东西都将被干净地分开。这种方法将导致可扩展的网格软件（定义见第20页）。微内核功能的实现工作是固定的，除此之外的一切都可以通用地实现。

因此，本章被分为两个主要部分。第一部分描述了属于微内核的特殊部分，第二部分描述了建立在微内核之上的通用组件。这里特别强调的是那些足以作为许多高级算法基础的通用组件。其中一些组件甚至可以用来实现微内核组件，从而减少创建新的符合内核的实现的劳动。

\subsection{A Micro-kernel for Grid Data Structures}

\What Belongs into a Micro-kernel?}小节。

有一点必须从一开始就明确。我们不能规定所有网格数据结构都必须支持的一套通用功能。如果这套功能足够大，那么一些具体的实现就会被排除在外，没有必要。另一方面，所有可能的和有用的网格表示的功能的交集基本上是空的。

事实上，通用方法是反过来的。从算法开始，我们推导出对这些算法的要求集。这已经在$3.2$节中以一种示范性的方式完成了。常见的需求模式可以被形式化以产生概念。如果一个具体的类型满足了概念中捆绑的需求，它就是一个概念的模型。具体类型通常是几个概念的模型。

一个类型可以被用作通用组件的参数，当且仅当它是该组件对该参数的所有要求的一个模型。例如，为了将CELL NEIGHBOR SEARCH算法（第61页）应用于网格类型，后者必须允许对单元、以及单元附带的面和面附带的顶点进行迭代。用我们将要提出的概念$^{1}$来表达，网格类型必须是单元格范围$(\rightarrow$第210页$)$的模型，其单元格类型必须是面网格范围$(\rightarrow$第210页$)$的模型，其面类型必须是顶点网格范围$(\rightarrow$的模型。

有相当数量的此类概念是充分描述网格功能所必需的。其中一些概念的半正式定义在附录7.3中给出。它们会扰乱这里的表述流程，因为它们必须不可避免地引入一些任意性的元素。这些概念的描述是基于C++的语法，并遵循SGI STL文档$[\mathrm{sgi} 96] .$的例子。网格概念可以用来记录通用组件，例如，见附录（C.1）中CELL NEIGHBOR SEARCH的通用实现。

微内核被定义为一个概念的集合；一个具体的网格类型通常实现其中的一个子集。例如，有一个概念用于迭代与一个顶点相关的边，然而许多网格数据结构不支持这种类型的查询，因此将其排除在外。

现在，哪些概念属于这个内核？在开发一个名副其实的微内核时，第一个目标显然是保持它的最小化或至少是小型化。越多的网格功能可以由建立在内核之上的通用组件提供，就越好。

然而，在一定水平之下，事实证明，为了利用底层数据表示的特定知识，有太多的专业化是必要的。微内核的一个明显的 "下限 "是在另一个表示法中复制网格的能力--实现一个复制机制。在此基础上，其他的组件可以被通用地定义。作为一个例子，考虑一个网格提供对细胞的迭代，以及细胞的面和顶点。从这些信息中，如果需要的话，可以通过CELL NEIGHBOR SEARCH生成单元格邻居信息，至少在网格的位置集是一个晶格的情况下。然而，如果网格已经存储了这些信息，甚至可以推导出这些信息（笛卡尔网格），这种方法显然是浪费的。因此，对单元格邻居的迭代应该被视为一个内核概念。

另一方面，如果我们看一下像网格的子范围这样的结构（第4.2.1节），似乎不可能通过为每一种网格类型提供特殊的实现来获得很多好处。即使在笛卡尔网格的情况下，一般的子ranges也不能比下面所示的通用组件更有效地实现。当然，直角坐标系的子范围在这里起着特殊的作用。

我们现在准备详细讨论微内核。在算法分析中观察到的将网格功能粗略地剖析为组合、几何和数据关联方面的做法，也是我们对微内核概念的基本分类原则。

当然，最复杂的部分是组合的部分。这里我们区分了网格元素，直接对应于3.1节的$k$元素，元素柄提供了网格元素的最小表示，序列迭代器允许将网格视为其元素的序列，所有这些在4.1.2节中讨论。包含在元素位置集（见第52页）中的入射信息被入射迭代器封装起来（第4.1.3节）。

`data association`方面由网格函数（4.1.4）捕获，如上所述。它们产生了一套精心分层的概念。

`Geometric embeddings`由专门的网格几何组件$(4.1 .5)$表示，它为对应于组合网格元素的几何实体引入了额外的概念。

`Mutating`组合操作发挥的作用比预期的要小得多。在实践中，我们经常可以用基元进行粗粒度的操作，比如复制网格、扩大网格和移除网格的碎片。这将在4.1.6中讨论。

4.1.7节讨论了一些`concrete`网格类型（一些微内核概念的模型）。

如果将第69页的需求清单与我们将要介绍的概念相比较，我们可以说所有的需求都由适当的概念来表示，除了那些与原型的详细知识有关的概念，如局部坐标或单线分切。这仍然是未来工作的一个主题，但似乎原型的概念可能是正确的抽象。

为了说明问题，我们有时会展示使用C++语法的程序代码片段。然而，应该明确的是，所介绍的概念是独立于编程语言的。

\subsubsection{Grids, Elements and Handles}

如果我们完全忘记网格的入射结构$\mathcal{G} ?$，还剩下什么呢？ 除了网格元素的裸体集合，即集合$\mathcal{G}^{0}, \mathcal{G}^{1}, \ldots, \mathcal{G}^{d}$之外，将没有其他东西了。

为了区分不同维度的元素，不同维度$k, 0 \leq k \leq d$的类型需要不同：有（网格）顶点$(\rightarrow \mathrm{p}$203）、边缘等概念，正式确定了$k$-维度元素的概念。请注意，一些元素，如Facet和Cell $(\rightarrow$ p. 205 $)$ 是根据共维而不是维度来命名的。这允许以独立于维度的方式制定许多算法，例如第66页的基本通量计算例子，它自然是以共维度来表达的。

元素的实例必须是平等可比的，这种比较必须区分不同的元素，甚至来自不同的网格。此外，给定这样一个元素，必须能够推断出该元素属于哪个网格。这个网格我们称之为该元素的锚点。在入射迭代的背景下（第4.1.3.1节），我们将遇到的锚不是网格，而是其他元素。

元素概念由元素句柄补充 $(\rightarrow$ p. 205 $)$ 。手柄是元素的一种索引，也必须具有平等的可比性。然而，这种比较只需要区分同一网格内的元素。手柄不需要知道它们的底层网格；它们被认为是关于存储的最小表示。因此，它们允许有效地实现元素集和网格的变形（见第54页）。在最简单的情况下，句柄只是积分或指针类型。

在元素与网格和句柄对之间必须有一个双射关系。一个元素必须能够得到它的句柄，一个网格必须从一个句柄产生一个元素。

如本节开头所述，一个网格可以被看作是不同元素类型的最多$d+1$个序列的集合。这就导致了元素网格范围概念的定义。例如，一个网格类型是顶点网格范围的模型 $(\rightarrow \mathrm{p}$ 。210），如果它提供一个顶点类型，本身就是网格顶点$(\rightarrow$ 第203页$)$的模型，一个相应的手柄类型，最重要的是，通过网格顶点迭代器$(\rightarrow$ 第206页，可以对其顶点进行迭代。)我们要求一个顶点网格范围 "知道 "它所包含的顶点的数量。

这种迭代器的家族被称为（网格）序列迭代器$(\rightarrow$第205页）。一般来说，一个网格类型是几个不同元素网格范围概念的模型，但不要求它是每个可能的元素范围的模型。例如，我们将在下面（第4.1.7.1节）看到定义简单串行网格表示法接口的网格的例子，它们是顶点网格范围和单元格范围的模型，但不是边缘网格范围或面状网格范围的模型；更准确地说，它们是单元格-顶点输入网格范围的模型$(\rightarrow$ 第212页），这个概念只是捆绑了一些共同的要求。

这当然限制了它们的可用性；然而，由于它们的主要目的是封装串行表示法的细节，它们主要被用来在一个更强大的数据结构中创建这个表示法的副本。因此，它并不假装比实际情况更多，它只是以统一的方式提供对表示法中现成的信息的访问。

到目前为止，我们还没有谈及网格概念。这部分是由于一般来说，对网格可以规定的东西不多，最重要的方面是由元素网格范围的概念来把握。网格和网格范围之间的区别是相当微妙的。它与入射迭代有关，将在第4.2.1节讨论。相应的网格$(\rightarrow$第211页$)$概念引入了（几乎）没有额外的功能，它只是增加了约束。

到目前为止提出的定义定义了网格微内核的底层，在这里不能真正说是一个网格。然而，即使在这个阶段，也有一些算法序列算法而不是网格算法--不需要比现在更多的功能。首先，可以计算每个维度的元素数量，并推导出欧拉特征（见第55页）作为$\mathcal{G}$的全局属性。如果有网格几何（第4.1.5节）$\Gamma$，我们可以计算几何嵌入的范围$\|\mathcal{G}\|_{\Gamma}$，找到具有极值坐标的顶点并执行类似任务。然而，根据几何学的实现，大多数几何学函数需要一组最小的入射信息。

计算一个网格（类型为Grid）和一个网格几何（类型为Geom）的包围盒的实现可以是以下样子。


看看这个小算法的要求，我们看到Grid必须是一个顶点网格范围的模型，这意味着存在Grid::VertexIterator类型，这是一个网格顶点迭代器的模型。Geom类型必须是顶点网格几何的模型，也就是说，必须导出一个Geom::coord_type类型，并且有一个Geom::coord(Grid::Vertex)方法返回一个顶点的坐标。只要几何体是线性的，该算法就能正常工作（见第58页），对于弯曲的单元格，该算法就不正确。

我们也可以考虑使用一个通用的边界框算法，在一个任意的点序列上操作。这需要向这个算法传递一个迭代器适配器，这使得网格 "看起来像 "一个点的集合。然而，因为网格不是一个任意的点集合，所以可以进行特殊化。例如，如果几何空间的维度等于网格的组合维度，只检查边界上的顶点就足够了。

应该强调的是，上面提到的要求并不意味着每个网格元素必须被永久存储。除了已经提到的能够（部分）隐式表示的（半）规则网格的情况外，即使对于非结构化网格，永久存储也不是强制性的。我们可以只存储单元和顶点，隐含地表示边缘和面等元素，同时保证对它们的访问完全透明。例如，在Triang2D网格类型（B.1）中就是这样做的。

以隐含方式表示元素的可能性对元素平等性比较有影响。一个元素类型的两个对象的平等并不意味着它们包含相同的数据，相反，它意味着它们表示相同的 "数学 "元素。对于非永久存储的元素，我们不能依靠对象身份（唯一的内存引用）来确保平等性测试的正确语义。

例如，如果顶点被存储，它们可以通过其编号或内存位置来唯一识别。另一方面，我们可以选择不永久地存储面（二维的边），而是 "即时 "创建它们，用顶点的集合或单元格和局部面的编号对来表示。(cell,local facet)对不是唯一的表示。对于每个内部面，有两种不同的可能性。因此，在这种情况下，为了区分面，我们需要比较一个唯一的表示。有序的顶点对是唯一的，但只有当每个元素由其顶点集决定时，它才是毫不含糊的。如果网格位置集是一个原子晶格，就是这种情况（见第53页）。只有在这种情况下，隐式表示才是合理的。

\subsubsection{Incidence Queries}

对事件信息的访问是网格数据结构功能的核心部分。我们可以确定两种不同类型的入射查询，一种是询问与给定元素入射（或相邻）的特定维度的所有元素，另一种是通过局部操作访问邻域，忽略了元素类型。

尽管第二种类型的操作可以用来模仿第一种类型的操作，但一般来说，这样做并不直接，而且也不那么有效率。因为访问一个给定类型的所有元素是许多算法中常见的重复模式，我们选择这一点作为基于发生的功能的基础，提出本地操作符作为替代和补充（4.1.3.3节）。

\subsubsection{Incidence Sequences and Iterators}

发生率序列建立在一个细胞的原型所提供的细胞边的枚举上。对于非规则元素，存在着重复的问题。在原型中不同的元素可能会被映射到网格中的同一个元素。对这些元素进行多次计数似乎更自然，因为这样可以对规则和非规则元素进行一致的处理。另外，只计算一次这样的元素的变体比反之更容易从 "多次计算 "的方法中得出（通过简单的标记）。

\textbf{Definition} 24（下行发生序列，锚）。针对$j>k$的$j-k$-下行发生序列$\mathcal{I}_{j \rightarrow k}$是一个映射

$$
\begin{aligned}
\mathcal{I}_{j \rightarrow k}: \mathcal{G}^{j} & \mapsto \operatorname{seq} \mathcal{G}^{k} \\
e & \mapsto\left(\Phi\left(\mathfrak{a}_{1}^{k}\right), \ldots, \Phi\left(\mathfrak{a}_{n_{k}}^{k}\right)\right), \quad \Phi=\Phi_{e}, \mathfrak{a}=\mathfrak{a}_{e} \quad \text { archetype of } e
\end{aligned}
$$

对于一个$j$元素$e$来说，产生了附带的$k$元素的序列（术语seq$\mathcal{G}^{k}$是指$\left.\mathcal{G}^{k}\right)$上的有限序列集合。元素$e$是序列$\mathcal{I}_{j \rightarrow k} .$的锚 鉴于元素$e \in \mathcal{G}^{i}$，我们通常将$\mathcal{I}_{j \rightarrow k}(e)$缩写为$\mathcal{I}_{k}(e)$。

在 "向上 "发生的情况下，例如与顶点相邻的细胞，我们一般没有低维锚的原型。然而，我们可以使用邻域的局部视图来定义入射序列。每个入射的高维元素都有一个原型，它可能包含几次锚点，因此应该在锚点的入射序列中出现相同的次数。

\textbf{Definition} 25（上行发生序列）。对$j<k$来说，一个j-向上的发生序列$\mathcal{I}_{j \rightarrow k}$是一个映射

$$
\begin{aligned}
\mathcal{I}_{j \rightarrow k}: \mathcal{G}^{j} & \mapsto \operatorname{seq} \mathcal{G}^{k} \\
e & \mapsto\left(f_{1}, \ldots, f_{n}\right)
\end{aligned}
$$

其中每个元素$f \in \mathcal{G}^{k}$与$f>e$在$\mathcal{I}_{j \rightarrow k}(e)$中出现的次数与$e$在$\mathcal{I}_{k \rightarrow j}(f)$中出现的次数相同。

重复的一个例子是第46页图中的环形。  第46页上的$3.1$，其中唯一的单元格在$\mathcal{I}_{2}(v)$中出现了四次

这些定义导致了算法上的简单解决方案，对非规则网格也有效。例如，我们可以通过对$j$元素的全局循环，将当前的$j$元素追加到所有入射$k$元素的序列中，从$\mathcal{I}_{k \rightarrow j}$序列的知识中获得向上的入射序列。

就像普通序列导致了STL框架中的迭代器概念一样，入射序列导致了入射迭代器$(\rightarrow$第206页）概念，例如VertexOnCell迭代器$(\rightarrow \mathrm{p} .$207)([Fig4.2]）或FacetOnCell Iterator $(\rightarrow \mathrm{p} .207)$ ，这只是其中两个最常用的概念。


一个演示入射迭代器使用的简单例子是一个循环，为每个顶点计算入射单元的数量，并将结果存储在一个网格函数中。


在这种情况下，Grid必须是Vertex Grid Range和Cell Grid Range的模型，而Grid:. Cell必须是Vertex Grid Range的模型。Cell必须是顶点网格范围的模型，这意味着存在一个Grid::VertexOnCelliterator类型。下面介绍网格函数，在这种情况下，模板grid_function<Grid:: Vertex, int>必须是总网格函数的模型 $(\rightarrow$ p. 215 $)$ 。

\subsubsection{Adjacency Iterators}

k-k-adjacency序列$(k=0$或$k=d)$与入射序列基本相同，只是它包含与锚点相邻的元素（第48页）。同样，重复是允许的，甚至对于规则的锚点元素也可以存在，例如由两个逻辑方块形成的开放圆柱体的边界。如果网格位置集是一个晶格，就不会出现重复。

对于d-d-adjacency序列，我们要求相邻单元的排序与相应的切面序列相同，但如果切面在边界上，因此不对应于相邻的单元，它可能包含更少的元素。

相应的迭代器概念是Adjacency Iterator，一个重要的例子是CellOnCell Iterator $(\rightarrow \mathrm{p} .207)$ ，见[Fig4.3]。

\subsubsection{An Alternative: The switch Operator}

BRISSON [Bri89] 引入的切换操作器为$2 \mathrm{D}$和$3 \mathrm{D}$网格的类似操作提供了一个统一的、与尺寸无关的方法，例如，见GUIBAS和STOLFI [GS85] 或DOBKIN和LASZLO [DL89] 。它们依赖于具有钻石属性的网格位置集（见第53页），其定义如下。



\textbf{Definition} 26（切换操作）。如果$e_{k-1} \prec e_{k} \prec e_{k+1}$，那么区间$\left(e_{k-1}, e_{k+1}\right)$包含两个元素，例如$e_{k}$和$e_{k}^{0} .$，那么切换操作符的定义是

$$
\operatorname{switch}\left(e_{k-1}, e_{k}, e_{k+1}\right)=e_{k}^{\diamond} \quad \text { for } \quad 0 \leq k \leq d
$$

这里维度用下标表示。如果$k=0$，那么$e_{-1}$被理解为不适当的元素$\hat{0}=\emptyset$，并且开关操作会翻转边$e_{1}$的顶点。 同样，$e_{d+1}$是$\hat{1}=\mathcal{G}$，并且开关$\left(e_{d-1}, e_{d}, e_{d+1}\right)$返回与面$e_{d-1}$邻近的其他单元。在switch的参数列表中，不正确的元素通常会被抑制。

一个有边界的流形网格对于边界面来说不具有钻石属性。在这种情况下，我们可以同意定义一个（或多个）人造的 "外部 "单元，用一个特殊的值来标识。一般来说，除了测试它的有效性，对外部单元做任何事情都是错误的。当然，也可以设计一些数据结构，使之有可能与这样的 "单元 "一起工作。然而，由于这些单元通常比内部单元包含更多的面，它们的实现将与其他单元有很大的不同。事实上，它将包含整个边界面的网格。在实践中，如果需要相应的功能，明确地处理边界似乎更方便。无论如何，许多算法（尤其是数值离散化）必须在这里采取特殊的行动。

大多数算法都不使用切换操作符。一个例外是边界迭代器，4.2.2.4节。

\栏目下的{网格功能}。

我们已经看到，算法需求的一个重要部分是对与网格元素相关的数据的访问。如果我们再仔细观察一下，我们可以看到实际的需求可以通过相关概念的层次结构来描述。

网格函数的最基本概念是网格元素函数 $(\rightarrow \mathrm{p}$ 。212 ):它简单地将一个给定类型的元素映射到另一个类型。这是对STL可适应单项函数概念的细化。一个例子是一个简单的适配器，它返回一个单元格的顶点数量。下一个细化是网格函数（$\rightarrow$ 第213页）的概念。我们将网格函数绑定到一个特定的网格。这使得我们可以在网格函数的域和范围内进行迭代。如果值可以被改变，我们就说是可改变的网格函数（Mutable Grid Function $(\rightarrow$ p. 214）。)

到目前为止讨论的概念不包含创建网格函数的规定，例如用于存储特定于算法的临时值。容器网格函数$(\rightarrow$第214页）概念增加了这种功能。

我们在前面已经指出（第76页$)$，总网格函数和部分网格函数的根本区别。相应地，我们将容器网格函数细化为总网格函数$(\rightarrow$第215页$)$和部分网格函数$(\rightarrow$第216页）。)上面第90页有一个简单的例子，通用的实现方式在第4.2.3节中讨论。

\subsubsection{ Grid Geometries }

网格几何是等同于组合复合物的几何实现的数学概念的软件。3.1.4节中已经分析了许多数学和计算方面的变化。这里有许多决定要做；网格几何学是定位它们的自然场所。

其基本概念是顶点网格几何。它简单地提供了一个从网格顶点$\mathcal{G}$到一些拓扑空间$X .$的映射，通常，这个空间是$\mathbb{R}^{n}$，对于一些$n \geq d=\operatorname{dim}(\mathcal{G}) .$，$X$的尺寸被称为几何嵌入的外部尺寸。顶点网格几何概念提供了一个相关的类型，它是$X$的一个点的计算表示，例如一个$n$的维度矢量，如果$X=\mathbb{R}^{n}$，见第87页上的例子。

尽管对顶点坐标的访问是现有数据结构普遍支持的唯一的几何功能，但即使是最简单的算法，它也难以满足。当然，这个明显悖论的解决方案是，3.3.1.3之前提到的许多决定都隐含在客户端代码中。例如，如果我们只是简单地取两个端点的距离，为了计算一条边的长度，我们首先假设边是线性段，其次，根据距离计算的细节，我们常常假设一个$X$的矢量空间结构 尽管在最重要的实际情况下是合理的，但这些假设在一般情况下并不成立。只要想想用来模拟地球表面的网格，其中的边缘是测地线。此外，边缘的长度可能被频繁使用，以至于永久地存储它们是值得的。客户端算法不应该知道这一点。

从$3.2$节可以看出，大多数算法使用的几何信息比单纯的顶点坐标略多。下一步是将所有组合元素映射到几何对象上。边到线段，面到多边形，单元到$d$维多角形。一般来说，这些对象可以是任意弯曲的，只需要是一些 "线性 "原型的同构图像。

如果一个几何体支持这些实体的体积测量，我们就说是一个体积网格几何体。体积 "在这里是指$k$维实体的$k$维度测量，即边的长度、面的面积等。除此之外，算法还需要许多不同的几何信息。其中比较常见的是（惯性的）中心和面的法线。

但这里已经出现了困难。什么是弧线段的中心？是惯性中心，一般来说，它位于外面？还是相对于同一参数化的中心，比如说arclength？答案通常取决于上下文--例如，"中心 "是否需要进行分割（网格细化）或数值积分。因此，为这些实体使用更具体的名称似乎是明智的，这取决于上下文。不幸的是，这种方法大大增加了为几何图形定义的函数的数量。

另一方面，对于线性几何图形，所有这些可能的解释都会导致相同的值，并且可以直接从体格几何概念定义的功能中推导出来。因此，这种常见的情况基本上可以由一个通用组件来处理，后面会讨论（第105页）。

\subsubsection{Grid Creation, Copy and Modification}

人们普遍认为，数据结构上的变异性操作往往比非变异性操作更难。对于网格来说，这显然也是一种情况。

修改操作往往深深依赖于内部表示。另外，一个数据结构能够有效支持的 "动态变化 "的数量有很大的不同，从对网格部分的粗粒度替换的原子操作（如欧拉算子），到笛卡尔网格中非常有限的动态行为。

这种基本的修改操作显然属于非通用的、针对网格的部分。事实证明，对原子操作的明显需要，例如在网格细化中，是可以规避的。在许多重要的情况下，我们可以用很少的粗粒度变异基元来做，此外，这些基元还有提供更高水平功能的优势。这使得我们有可能统一对待具有不同动态能力的网格。

更具体地说，我们确定了三种基本的变异操作。网格复制、网格扩大和网格切割。网格扩大意味着将另一个网格 "粘 "到一个现有的网格上，使用一组待识别的顶点或面。网格切割意味着移除网格部分。

所有修改操作的一个共同问题是维护依赖性组件的一致性。这尤其涉及到网格函数和几何图形。例如，如果一个网格被扩大了一部分，并且有一个与这个网格绑定的网格函数，它可能在产生的网格的新部分上没有被定义。

这是一个问题，特别是当网格函数与网格数据结构物理解耦的时候，参见第80页。与底层网格的松散耦合有其优点，但似乎会使一致性的维护更加困难。

在这种情况下，确保一致性的关键是使用关联副本，在源副本和目标副本之间建立一个网格同构（$\rightarrow$ p.54）。通过这种变形，与源网格相关的信息可以被映射到目标网格中。

当然，以一种更 "自动 "的方式来处理一致性维护会更令人满意。一个可能的方法是使用 "通知者-观察者 "模式[GHJV94]，其中一个网格扮演着通知者的角色，而从属组件是观察者，对网格变化事件做出反应。但是，仍然有一个问题，即如何找到与源网格相关的相应的 "源组件"，至少在网格复制或放大的情况下。这有待于进一步的工作。

复制/扩大/切割功能一般要为每一种网格类型单独实现；但是在内部，它可以使用通用算法来执行标准任务，例如，通过$3.2$页上的算法$61 .$的实现来计算单元格相邻关系，而且，"源 "的部分没有被修改；它可以被做成一个参数。因此，我们称这些组件为半通用的。

这些程序并不是真正意义上的概念，这里使用的是这个术语。然而，它们是许多变异算法的基本构件，比如第134页的CONSTRUCT OVERLAP，因此它们的作用类似于其他非变异的非通用组件，比如网格迭代器。关于复制操作的描述见附录C.3。

可以用这些基元执行的任务数量多得令人吃惊。网格复制可以用来实现通用的构造函数。除了普通的复制构造函数和赋值运算符，它对于实现网格转换也是必不可少的。

复制基元的一个重要应用是对特定文件格式的抽象。对于每个这样的格式，可以定义一个网格适配器（见4.1.7.1节），然后可以用它来从这个格式构造一个网格，或者向这个格式写一个网格。

因此，网格类型不需要知道文件格式，只要提供半通用的网格拷贝就足够了。当然，同样的技术也可以用于其他（无论是否序列化）的网格表示，例如通过消息传递缓冲器。我们经常使用它来从标准模板中创建样本网格，比如笛卡尔网格或诺依曼三角。

网格扩大和切割可用于混合网格生成和网格细化。在第一种情况下，网格的一部分是由不同的算法分别生成的，然后粘在一起。在第二种情况下，一个网格的一部分被替换成一个细化的版本，从而将细化逻辑封装在一个单独的组件中。

这些操作的另一个重要用途发生在分布式网格组件中，在第五章中讨论。

\subsubsection{Examples of Concrete Grid Kernel Components}

为了了解事情的真正运作方式，看一看具体的实现往往是很有用的。以下是已经开发的主要网格内核。

- `Triang2D` ，一个非常简单的二维三角形的数据结构，在附录（B.1）中讨论。

- `Complex2D`是一个用于一般二维复合体的数据结构，其单元是简单的多边形。

- `RegGrid2D`是一个隐式表示的例子，即笛卡尔网格。网格元素由两个整数坐标表示。

除了这些类型，还有一些其他组件是GridRange概念的模型，或者更准确地说，是Cell-Vertex Input Grid Range $(\rightarrow$ p.212 $)$ 的模型，比如文件格式适配器、直角坐标网格的Neumann triangulations掩码等等，下面将讨论其中一些。

\subsubsection{Serialized-grid Adapters}

通常情况下，网格是以序列化的形式给出的。在一个文件中的 "平面 "表示，在一个消息传递缓冲区或类似的地方。

术语序列化是指将一些数据结构的（非线性）核心表示映射到项目的线性序列上；相应地，去序列化是指反过程。

特别是对于文件表示法，有许多不同的格式在使用。如果使用（半）通用的复制程序（见第4.1.6节）从这样的格式中构建一个给定的网格表示，就必须为平面文件提供一种$m a s k$，它提供上述的一些基本网格功能。然后，对于$n$网格数据结构及其相应的CopyGrid操作和$m$网格文件格式，我们能够产生$n \cdot m$ReadGrid$_{k j}$程序，从文件格式$F_{j}$中读取网格类型$G_{k}$ 。这至少在原则上是正确的，除非编码的信息和需要的信息差别很大，以至于需要一个不同的复制机制。

为了使事情更具体，我们考虑一个二维三角网格的文件格式，首先给出网格中顶点和单元的数量，然后是顶点的坐标，最后是单元的顶点集，见$59 .$页的表$3.2$

图$4.5$（a）中的文件包含图$4.5(\mathrm{~b})$中的网格。从文件内容中，我们可以很容易地得出以下信息。顶点和单元格的数量，顶点和单元格的迭代，以及对单元格附带的顶点的迭代。

我们还可以访问顶点的坐标。这种几何信息在建立组合结构时并不需要，但它可以用来初始化线性几何。为了使这些信息在需要的时候可以使用，我们可以简单地将（组合）网格和几何的概念融合到一个单一的软件组件中。由此产生的grid_file_xyz类是细胞-顶点输入网格范围的模型（→第212页）；其实现在附录中有所记载（图B.3，B.2）。

然后，从文件中读取网格的方法很简单，就像

~~~C++
grid_file_xyz Gfile("xyz.grid");
grid_type G;
CopyGrid(G,Gfile);
~~~


如果我们也实现了从任意网格到grid_file_xyz的逆向拷贝程序，那么我们可以把特定文件格式的适配器类看作是这种格式在编程语言方面的定义。这样一来，函数

~~~C++
CopyGrid(a_grid &, grid_file_xyz const&); // read from xyz format
CopyGrid(grid_file_xyz &, a_grid const&); // write to xyz format
~~~

是$\mathrm{xyz}$文件格式的唯一接口。也就是说，它们包含了与这种格式的细节有关的唯一代码，无论存在多少不同的网格实现。

以同样的方式，可以为用消息传递缓冲区编码的网格创建包装器，将序列化的机制与使用它们的网格数据结构屏蔽开来。

\subsubsection{Implicit Grids}

在许多情况下，网格没有被明确编码，而是以隐含的方式给出。例如笛卡尔网格、张量网格、对偶网格或标准三角计算，例如笛卡尔网格的诺伊曼三角计算。它们的共同点是具有某种轻量级的特性。入射关系以一种廉价的方式计算（隐式网格），或者从底层数据结构中推导出来（网格适配器）。

在这些隐式表示中，使用最多的可能是笛卡尔网格。在这里，只有几何图形可能被明确地存储；在笛卡尔几何图形的情况下，甚至没有必要这样做。通常情况下，当利用规则结构时，算法可以制定得更有效，特别是在数值模拟领域。因此，笛卡尔网格的完整实现不仅包含一个通用的网格接口，而且还给出了对笛卡尔结构的访问。通过这种方式，可以使用一般网格的通用算法，同时在重要的地方不影响效率。

网格掩码实现了以某种定义良好的方式从另一个网格派生出来的网格的概念，例如张量-乘积网格或对偶网格（见第54页）。

\subsection{Generic Grid Components}

本节介绍了一些基于刚刚开发的微内核的组件，这些组件是通用的。这意味着任何符合微内核的网格类型都可以使用这些组件而不需要进一步的劳动。

特别注意的是那些足以作为更复杂的组件（如算法）的基础的通用组件，因此可以被看作是对基本网格功能的扩展。

因此，很多篇幅都是关于网格子范围（4.2.1节）和迭代器（4.2.2节）。这些行为与具体的网格所提供的专门的 "本地 "版本完全一样，如`Triang2D` $(\rightarrow$ p. 217 $)$ ，从而允许通用组件的无缝嵌套。

像容器网格函数（第4.2.3节）和网格几何（第4.2.4节）这样的内核概念可以在最常见的情况下通用实现。在开发新的符合要求的网格内核时，这些通用版本可以减少编程工作，或者将现有的数据结构调整到内核中。

一般来说，我们在出现通用算法的地方进行讨论，例如第5章和$6 .$在$4.2 .5$节中，我们提到了这种讨论的确切位置--仍然比其他组件多，这里不得不进行严格的选择。

\subsubsection{Element-ranges and Subgrids}

一个算法最常见的概括是让它在一个子结构上操作--一个子序列、一个子图、一个子网格。限制算法工作区域的能力在分布式计算或自适应可视化中非常重要，如果人们想关注网格的一小部分。

在数学环境中，这种可能性是如此简单和明显，以至于我们几乎从不费力地提及它。相反，在计算环境中，在我们说 "让$\mathcal{S}^{\prime}$是$\mathcal{G}$的一个子网格，由...... "定义之前，还有一些工作要做。.首先，必须有软件实体以一种有效的方式代表子结构的概念--除非我们想复制。其次，有关算法的实现必须能够对这些数据组件进行操作。反过来说，这些组件必须在所有基本方面表现得像 "真实的东西"。

根据4.1.2到4.1.3节中对网格的分层描述，我们区分了两种主要的网格子结构。一方面，有元素子范围，它是网格元素范围的简单子序列。另一方面，我们有网格子范围和子网格。在定义8的意义上，这些都是适当的子复合物，但在一些发生迭代器的语义上有细微的差别，现在要讨论一下。

如果我们假设子网格和子范围是同维的$d^{\prime} \leq d$，那么它们的$d^{\prime}$元素集的闭合决定了哪些低维的元素被包含在内，这是由子复数的特性决定的。对这些元素的算法确定导致了闭合迭代器，在下一节讨论。

乍一看，我们会期望与网格子结构$\mathcal{R}$相关的入射迭代器被限制在$\mathcal{R}$的元素中。然而，这并不是我们在许多情况下需要的行为。例如，在平行执行PDE求解的数值离散化算法时，算法被限制在一个局部的工作范围内，但在这个范围周围的某个 "光环 "内访问信息。这个光环的实际范围是由算法的模版精确决定的，而模版又可以由入射查询的序列来描述。关于这个问题的详细说明见第五章。

因此，我们将网格子范围定义为网格的一个子复合体，其入射关系继承自底层的基础网格。$\mathcal{R}$中元素的任何向上入射序列（见第89页）都与$\mathcal{G}$中的入射序列相同。相反，$\mathcal{G}$的子网格$\mathcal{S}$中的入射序列只包含$\mathcal{S} .$的元素。 我们使用一般的网格子结构或部分来表示两种可能性中的任何一种。

请注意，对于下行入射序列，没有问题，因为相应的元素无论如何都包含在网格子结构中。因此，子网格原则上可以重复使用其基础网格的所有入射迭代器，而子网格只能重复使用下行入射迭代器。

有许多方法来描述一个网格部分的特征。

- 普通的元素枚举（最高维度的）。

- 组合表征（骨架、边界网格或一个元素的某些邻域）。

- 对于一个单元格的所有顶点的几何谓词$(f(v)>0$）。

或这些的组合。

对于列举的子范围和边界网格，存在通用的实现方式（这里没有介绍），其中边界下的网格本身可能是一个网格部分。

后一种可能性清楚地显示了通用方法的优势之一。组件可以随意嵌套。在这种情况下，一个简单的应用是通过只画每个分区的边界面来实现网格分区的经济可视化。

如果底层网格有特殊的结构（例如，如果它是笛卡尔的），我们希望也有尊重这种结构的网格部件，也就是说，属于同一类网格并表现出相同的特殊功能。在这种情况下，我们可以用专门的网格部件来补充通用版本，这些部件与通用部件共存，见[Fig4.6] (a) 和 (b) 。

\textbf{Implementation issues} 枚举的元素范围可以用一个元素句柄的容器和对底层网格的引用来实现。

(枚举的)子范围和子网格都建立在元素范围之上。这里留下了一些自由，是明确地存储低维元素的序列，还是依靠封闭迭代器进行顺序访问。请注意，闭合迭代器一般也需要存储$O\left(\left|\mathcal{S}^{k}\right|\right)$的网格部分$\mathcal{S}$，因为它们需要跟踪已经访问过的元素。一个有用的策略可能是一种懒惰的评估方法：低维元素被明确地存储起来，但只有在实际要求迭代时才存储。

\subsubsection{Generic Iterators}

我们已经看到，迭代器封装了大量的核心网格功能。因此，我们很难期待所有的迭代器都能由通用模板提供。然而，根据基本的网格实现所提供的功能组合，一些迭代器可以被通用地派生。下面几节展示了这种情况的详细例子。这里描述的迭代器模板可以减少创建一个符合微内核的网格的工作量。

\Subsubsection{Sequence Iterators}。

如果$k$-元素被明确地存储在每个维度上$0 \leq k \leq d$，那么显然序列迭代器直接对应于底层容器的迭代器；在这种情况下不需要通用迭代器。另一方面，如果某些元素类型缺乏直接的表示，那么就有可能出现通用性。

我们在此假设一个基于单元格的网格，并展示如何推导出面迭代器和边迭代器的通用实现。在两个维度上，这些显然是重合的，我们可以选择一个相同的通用版本。

面可以用一个单元格（handle）和该单元格原型中的一个局部数字来表示。在一个有边界的流形网格中对切面进行迭代，可以利用这样一个事实，即每个切面最多附带两个单元格（如果在边界上则只附带一个）。给予 "外部 "单元一个严格小于任何其他单元的句柄，我们可以从一个面的两个可能的表示中选择一个具有更大的单元句柄。对面的迭代是指对所有单元格的所有面进行迭代，跳过那些 "相反 "表示更大的面。这种方法假定相反的表示法是现成的，例如，如果提供了单元格-单元格-相邻关系。由于一个单元格的面与它的邻居是一一对应的（除了边界面），这里可以理解为，在单元格-单元格-相邻关系的情况下，一个本地的面的编号可以立即访问相应的邻居。实现这些想法的通用组件是FacetIterator $(\rightarrow$ p. 226 $)$ 。

如果细胞邻接信息不可用，我们可以采用明确标记面的方法。一个网格函数

$$
\text { visited }: \mathcal{F}_{\mathcal{G}} \mapsto\{0,1\}
$$

有助于跟踪已经看到的面（访问和标记技术）。请注意，在这种情况下，切面上的网格函数不能使用两个入射单元的表示方法来区分切面。这里适合的不同的独特表示是面的顶点集。这就是第61页介绍的细胞邻居搜索算法所做的，该算法的目的是确定细胞的邻居。

边缘，而不是由两个单元决定，可以由顶点唯一地表示。如果边缘-顶点-和顶点-迭代器可用，边缘迭代器可以像面迭代器一样实现，比较顶点而不是单元。否则，就会再次使用显式标记策略。比较边是通过它们的顶点集来完成的，这比面更容易，因为总是有两个顶点。

应该注意的是，这些迭代器本质上依赖于顶点集的唯一性，如果网格的位置集是一个原子网格，就可以满足这个要求。

\Subsubsection{Incidence Iterators}。

我们可以使用switch-operator（第4.1.3.3节）来实现某些类型的入射迭代器。在$2 \mathrm{D}$中，我们观察到边和单元是围绕每个顶点循环排序的。给定一个三联体$v \prec e \prec c$，所有入射到顶点$v$的边和单元格都可以通过交替的边和单元格开关得到，见[Fig4.7]。取$v$相对于$e$的对称性，我们得到所有相邻的顶点。

因此，为了在二维网格中加入以顶点为中心的入射迭代器，需要一个映射



必须提供，为每个顶点$v$提供一个胚芽$(e, c)$，以开始迭代。一个合适的数据结构是一个网格函数，将顶点映射到（边，单元）处理对。

~~~C++
grid_function<Vertex, pair<edge_handle, cell_handle> > germs;
~~~

对于三维空间来说，情况要稍微复杂一些。对于边，有一个入射面和单元的循环顺序，对于面，有一个边和顶点的顺序。所以可以使用类似于$2 \mathrm{D}$情况的技术。相反，与顶点相邻的元素集没有表现出自然顺序。一个可能的方法是使用广度优先遍历顶点附带的标志（见下文）。

\subsubsection{Closure Iterators}

当一个子网格由一个单元集$C \subset \mathcal{G}^{d}$定义时，我们必须找到一种方法来依次访问闭合中的所有低维元素 $\bar{C}$ 。我们提出了简单的算法来确定子复合物中的面、边和顶点的序列 $\mathcal{G}_{C}=\bar{C} \subset \mathcal{G}$ 。

\textbf{FacetIterator} 有两种可能性，取决于是否有有效的检验方法来列入细胞集 $C$ 。

1.外面存在一个谓词。  $\mathcal{G}^{d} \mapsto\{0,1\}$ 的复杂度为$O(1)$ 。那么就可以使用第4.2.2.1节的通用面片迭代器。这不需要额外的存储，并且每个面最多访问两次。

2.我们使用访问和标记技术。这使用了存储$O\left(\left|\mathcal{G}_{C}^{d-1}\right|\right)$，每个面最多访问两次。

\textbf{EdgeIterator}选择的策略是访问和标记，通过使用一个嵌套的循环在$C$的所有单元和每个单元的所有边上。使用的存储空间是$O\left(\left|\mathcal{G}_{C}^{1}\right|\right)$，每条边$e$被访问的次数最多就是$C$中与$e$相关的单元格。这个数字不是有界的；但是，我们可以证明，对于有限制的细胞类型，每条边的平均细胞数是有界的，见 [Loe76] 。

\textbf{VertexIterator} 这里几乎使用了与边缘迭代器相同的方法，并且同样适用。



\subsubsection{Boundary Iterators}

回顾一下，一个网格（部分）的边界有一个纯粹的组合定义。它是在网格部分中正好有一个入射单元的面的集合的封闭。为了达到最大的通用性，我们在这里假设一个谓词

$$
\text { inside : } \mathcal{G}^{d} \mapsto\{0,1\}
$$

在$\mathcal{G}$的单元格上给出，在$\left.(c)=1\right\}$内定义了一个单元格集$C=\left\{c \in \mathcal{G}^{d} \mid\right.$。我们的目标是$\mathcal{G}_{C}=\bar{C}$的边界。这个任务分为两部分。对边界的一个组成部分进行局部迭代，对所有组成部分进行全局迭代。

\section{Boundary Component Iterator}

边界的一个分量上的局部迭代器使用局部切换操作。迭代器的局部状态由一个所谓的标志来描述，也就是一个二维的元组$(v, e, c)$，或者$d$维的$\left(e_{0}, \ldots, e_{d}\right)$，其中$e_{0} \prec e_{1} \prec \ldots \prec e_{d}$ 。对于每个分量，二维网格的边界是环形有序的。如果网格在每个边界顶点都是局部同构于半空间，那么每个边界分量都是同构于$\mathbb{S}^{1}$ 。给定一个初始边界标志$(v, e, c)$ ，其中$v, e \in$ $\partial \mathcal{G}$ 和 $c \in \mathcal{G}$ ，该算法通过连续应用切换操作产生下一个边界标志。

算法NEXT-BOUNDARY-FLAG-2D构成了一个边界组件迭代器的增量操作。这个迭代器的输出定义了一个边界组件的循环顺序。如果边界顶点$v$的环境由$n$个楔子组成，$v$将在序列中正好出现$n$次，见[Fig4.8] (b) 。


该算法只使用常数空间。操作数由边上的开关操作数$s_{e}$主导，$s_{e}$等于网格内$v$的单元格数。这个数字原则上是无界的，即使当每个单元的平均顶点数是有界的时候，入射到一个顶点的单元数也是有界的，数值PDE求解中使用的网格就是这种情况。

因此，在最坏的情况下，完整扫描一个边界部件所要做的工作可能与相应的网格部件中的细胞数量成正比；然而，这只发生在病理情况下。

总之，为了确定一个任意网格的边界（由inide-predicate给出），一般来说，有必要扫描其所有的单元。如果我们只从任何网格的内部取出一个单元$c$，就会有一个新的边界分量，如果$c$的邻居都没有被检查到，我们就无法发现。这些考虑导致了边界迭代的全局部分。

\textbf{Global boundary grid iterator} 为了确保边界的每一部分都被访问，我们必须为每个边界组件提供一个面（胚芽）。如果有$n$组件，我们必须为每个组件提供一个迭代胚芽。现在，如果我们知道只有一个组件，那么只要找到一个任意的边界面就足够了。然而，在一般情况下，有必要扫描网格的所有单元来确定所有的边界成分。一旦这样做了，就可以通过为每个分量只保留一个菌种来紧凑地存储边界。从边界面的序列中提取菌种可以通过边界组件迭代器和访问过的面的明确标记来完成。

\subsubsection{Container Grid Functions}

容器网格功能几乎可以完全以通用方式实现，如果我们同意将数据存储在元素之外，正如第80页所讨论的。通用性对于图像类型$\mathrm{T}$是相当明显的，但对于域类型$\mathrm{E}$也是如此，它是所考虑的网格类型的一个元素类型。

我们需要知道的是，事实上，元素类型如何被用来访问内存位置。这里基本上出现了两种可能性。要么，相应的句柄是连续编号的，例如从0到$n-1$的整数，其中$n=\left|\mathcal{G}^{k}\right|$是元素的数量。在这种情况下，我们可以对（总）网格函数使用数组。如果不是这种情况，我们可以依靠散列或元素柄的排序来将元素映射到内存位置。我们只讨论散列的情况，因为在实践中它比使用平衡树更有效率。

在部分网格函数的情况下，默认情况下，总是使用哈希表。请注意，如果通用版本被认为是不合适的，总是有可能为具体的元素类型选择一个特定的实现。C++的部分特殊化功能提供了一种舒适的方式，只需固定两个通用参数中的一个。

定义的两个基本类别是

~~~C++
template<class E, class T>
class grid_function_vector;

template<class E, class T>
class grid_function_hash;
~~~

从哈希版本中，我们派生出总网格和部分网格函数的类，它们的接口略有不同。

~~~C++
template<class E, class T>
class partial_grid_function_hash
: public grid_function_hash<E,T>;

template<class E, class T>
class total_grid_function_hash
: public grid_function_hash<E,T>;
~~~


对于矢量版来说，这是没有必要的，因为它只能用于总网格函数。

如果我们想在一个具体的网格类中使用这些通用版本，我们只需要再次从这三个类中派生出一个，同时固定元素参数。

~~~C++
template<class T>
class grid_function<MyVertex,T>
: public grid_function_vector<MyVertex,T> {
// repeat constructors
};

template<class T>
class partial_grid_function<MyVertex,T>
: public partial_grid_function_hash<MyVertex,T> {
// repeat constructors
};
~~~


为了从类型E中推导出关于元素的必要信息，我们使用了一个traits技术。一个叫做element_traits的类模板被专门用于每个元素类型。它包含，除其他外，要使用的哈希函数的类型。

在这些通用版本中，只考虑了3.3.1.2节中列出的最基本的变化参数，即类型$\mathrm{E}$（元素）和$\mathrm{T}$（图像）。一个更全面的方法还可以加入其他参数，如参数检查和实现选择。

\subsubsection{Grid Geometries}

网格几何是另一种类型的微内核组件，一般来说不需要关于底层组合网格的太多信息。

在最简单的线性几何$(\rightarrow \mathrm{p} .58)$的情况下，对顶点坐标的访问是推导其余几何功能所需要的。在 "纯 "组合网格的情况下，即使是这种类型的信息也可以通过使用网格函数将顶点映射到某种类型的坐标中来通用地添加。

一个简短的例子看起来如下。

~~~C++
template <class GRID, class POINT>
class linear_geometry_2d
{
    // some typedefs ...
    grid_function<Vertex, POINT> XY;

public:
    // coordinates of vertex
    POINT const &coord(Vertex const &V) const { return XY(V); }
    // outward pointing normal, with length = length(*fc)
    POINT outer_area_normal(FacetOnCellIterator const &fc) const
    {
        typedef point_traits<POINT> pt;
        return POINT(pt::y(XY[fc.V2()]) - pt::y(XY[fc.V1()]),
                     pt::x(XY[fc.V1()]) - pt::x(XY[fc.V2()]));
    }
};
~~~


\subsubsection{Generic Algorithms}

基于网格的算法形成了一个非常异质和复杂的领域--比前几节讨论的主题要广泛得多。因此，对算法及其通用实现的介绍发生在算法产生的背景中。

在续集中，我们仅限于提示这些地点，另外还提到一些在其他地方没有找到的例子。

\textbf{Combinatorial algorithms}也许是最广泛使用的，如CELL NEIGHBOR SEARCH（在第61页介绍，在附录C.1中实现），或NEXTBOUNDARY-FLAG-2D，在$2 \mathrm{D}$中作为边界迭代器的基础。

\textbf{Distributed grids}在第五章中有详细的讨论；那里介绍的一些算法是INCIDENCE HULL（见第133页）、DISTRIBUTED HULL（第137页$)$和CONSTRUCT OVERLAP（第134页）。在这种情况下，重用的主要单位原来不是单一的算法或数据结构，而是由协调的算法和面向数据的组件组成的复杂系统，参见5.7节。

\textbf{Visualization}方法是数值应用的一个重要成分。这里没有详细讨论这个领域。对于简单的$x y$图、彩色图和二维网格上的隔离线，以及粒子追踪方法的第一个版本，我们已经创建了通用的实现方法（另见第65页）。

在这种情况下，除了与网格/网格功能数据布局有关的变量外，还出现了许多其他变量。

- 产生图形的 "渲染引擎 "的类型

- 几何输出的类型，例如颜色图、等值线密度或粒子路径的渲染

- 算法参数，如数字ODE求解方法或粒子追踪的细胞定位策略。

特别是在粒子追踪的情况下，对变异性的详细分析似乎是一项有趣和有希望的任务。

最后，第六章讨论了数值算法，这也是本论文的出发点之一。在$6.2$节中，提出了一个通用的有限体积求解器，它的参数化--除了网格和几何--还包括双曲方程和通量计算方法。第$6.3$节专门讨论了椭圆问题的解决，涉及到一个简单的有限元离散化和多网格方法的组件，包括分层网格。


\section{Concepts and Components for Parallel PDE solution with Distributed Grids}

\subsection{Introduction}

平行计算对于大规模数值模拟来说是一个越来越重要的问题。诚然，单位成本的（顺序）计算能力逐年增加，但对更大更快的计算的需求也在增加。并行计算机以顺序执行时间的一小部分进行同样的计算，从而使一个给定问题的解决更快，并允许增加问题的大小，从而克服解决大规模问题时内存容量的限制因素。

在过去的几年里，并行硬件已经成熟并变得更加普遍。特别是，随着互连的速度越来越快，成本越来越低，可以用价格低廉的组件构建可与专用并行架构媲美的高性能集群。因此，强大的计算资源变得广泛可用，并且必须由并行软件加以利用。

然而，并行计算能力的使用并不是免费的。并行架构很复杂，而且仍然比顺序硬件表现出更多的多样性。对于后者，计算机的简单RAM（VON NEUMANN）观点是一个非常成功的、合理的统一抽象（尽管有一些与内存层次有关的限制，见第15页）。

对于并行机器来说，没有这样的通用计算模型。一些模型使并行程序的推理更容易，但隐藏了重要的性能方面，特别是数据定位问题。更现实的并行计算机抽象往往是更接近并行计算机的复杂结构的模型。因此，对底层硬件结构的额外依赖不可避免地被引入到软件中，使其可移植性降低。

并发进程的更多语义为编程的复杂性打开了一个新的来源，因此也是错误的来源。必须在编程的便利性（特别是关于分布式数据的一致性维护）和计算效率之间建立一个微妙的平衡。一般来说，这取决于具体的应用，可以做出妥协。平均分配计算工作的需要，数据的重复，以及维护一致性所需的通信，都会带来额外的开销。如果不小心处理这些开销，并行计算在执行时间方面的好处可能会部分丧失。

这些困难使得并行软件的生产成为一项要求极高的任务。困扰顺序硬件的软件开发的 "软件危机 "在并行计算中更加严重。

目前还没有看到通用的万能药。相反，特定领域的方法有可能大大缓解在特定情况下创建并行程序。

在这一章中，我们提出了一种针对基于网格的应用领域的方法。我们的主旨是PDE求解算法的分布式执行；然而，我们将要描述的概念既不拘泥于任何物理类型的分布，也不限于数值算法。网格分布的逻辑方面与基于网格的算法的结构特性之间的关系将变得非常清楚。

本章的大纲如下。首先，简要介绍了并行机器和编程模型的基础知识（第5.2节）。接下来，我们介绍了几何数据分区的范式，它是所考虑的一类问题的任何具体并行化的基础（第5.3节），并简要介绍了哪些类型的软件工具可以帮助实现这一范式（第5.4节）。

本章的第二部分专门详细介绍了我们为支持基于网格的并行计算而开发的概念和组件。分布式重叠网格的中心概念在第$5.5 .$节中介绍。特别是，我们正式定义了非结构化网格上的算法模版（第5.5.4节），允许对适当的网格重叠进行一般规范和实际确定。为分布式网格设置数据结构所需的算法在第5.6节中描述。我们在第$5.7$节中总结，讨论了这些概念的通用实现的一些方面，它允许在任意网格数据结构之上使用。这种非琐碎的算法和数据结构的实现，有力地证明了通用方法的可行性。

\subsection{Machines and Models for Parallel Computing}

本节的目的不是对并行计算进行全面介绍，而是提供尽可能多的必要信息，以估计我们的方法如何以及在哪里适合这个领域。一个非常广泛和全面的处理可以在 [Zom96] 中找到，一个更倾向于科学计算的介绍是 [FWM94] 。

在并行硬件的层面上，人们区分了处理器严格同步工作的机器（SIMD - 单指令流，多数据流）和异步工作的机器（MIMD机器）。

SIMD机器的例子是处理器阵列，如MP-I和连接机CM-2，矢量计算机和收缩阵列，但在较小的范围内，现代PC处理器的MMX技术也属于这个类别。

MIMD机器可以根据它们是否提供全局地址空间（共享内存，对称多处理器-SMP）或不提供全局地址空间（分布式内存，多计算机）来进一步区分。这种区分只是在逻辑意义上（程序员的观点），因为存在着混合设计，有时借助复杂的硬件或系统软件，在物理上的分布式内存之上提供全局地址空间，即所谓的分布式共享内存（DSM）。分布式内存结构的例子是工作站网络（NoWs）、IBM SP-2或Thinking Machines CM-5。最近并行硬件的趋势有利于多层机器（见[BF99]和那里引用的参考文献）：通过高速网络连接的SMP集群。因此，并行架构非但没有变得简单，反而变得更加复杂，顺序机器的本地分层内存系统也是如此。总而言之，人们最终会有几层内存层次：两到三个本地缓存，一个SMP的全机内存，一个具有高速互连的MIMD机器的虚拟内存，可能还有一些通过WAN连接的这样的集群。从这样一个架构中获得最佳性能是一项要求很高的任务。

一个适合SIMD架构的抽象机器模型是PRAM模型，它假设每个处理器都能以单位成本访问每个内存位置。这使得高效$^{1}$算法的设计更加简单；然而，在MIMD的情况下，统一内存访问的假设是不现实的。有几个PRAM模型的扩展，然而，所有这些都包含统一内存访问的假设。

SIMD架构的典型编程方法是数据并行编程范式，它假设了非常规则的数据，如向量和矩阵。请注意，在本论文中，"数据并行 "一词是在更广泛的意义上使用的，它与比单指令更粗略的操作有关。

MIMD计算机的突出特点是不均匀的内存访问特性，它在分布式内存机中表现得最为突出，远程内存不能直接访问，只能使用特殊的消息传递原语，如今通常由MPI [MPI] 或PVM [PVM] 等标准化库提供。但共享内存机器也有非统一的内存访问。

现代的这种机器的抽象模型是由批量同步并行模型（BSP）[Val90]提供的，它包含了对计算/通信效率比和网络容量的测量。

适合MIMD计算机的编程风格是SPMD（单程序-多数据）或数据分区方法，以及MPMD（或任务-并行）风格。这种区别并不明显，因为单个程序中的不同分支可以在不同的进程中执行，在极端情况下会产生与MPMD类似的效果。

使用SPMD方法更容易，因为只需要维护一个程序，而且通常只需要考虑一个控制流。在许多情况下，特别是在科学计算中，SPMD已被证明是合适的。

因此，主要的编程工作集中在数据分配上。如果没有共享内存，对远程数据的访问必须通过明确调用消息传递机制来完成。这使编程相当复杂，但对进程间的通信有很强的控制力，因此有更多的机会对性能进行微调。另一方面，如果考虑到SMP机器的数据访问的不均匀性，高效并行执行的需要往往会强加一个类似于分布式内存的逻辑程序结构。

对于并行的PDE解决方案，数据分区方法的一个变种，称为几何分区或域分解，已经证明了它的有用性。

\subsection{Geometric Partitioning for Parallel PDE Solu- tion}

与偏微分方程的数值解有关的计算的关键属性是什么？在并行化背景下，它们最突出的特点当然是，它们是基于网格的。重要的算法在网格上工作，分布过程基本上是由底层网格的分布驱动的。

基于网格的算法的一些特点如下。

- 在底层网格数据结构中，有一个自然的定位概念。

- 算法通常在数据上进行局部工作。

- 算法通常有一个可预测的数据访问模式。

- 数据要么与网格元素有某种关联，要么是全局性的（如公差、时间步长）。

- 执行的工作量与底层数据结构的大小大致成正比

因此，对于这些类型的应用，适当的并行化策略是几何分区或域分解 $^{2}$ 。

通过这种数据并行的方法，算法被认为是不可改变的。相同的方法被相应数据的所有所有者应用（所有者-计算规则）；结果与顺序情况相同。显然，并不是每个顺序算法都会产生这种类型的有用的并行版本；应用程序员的任务是提供适合这种方法的算法，或者决定改变后的行为是否仍然可以接受。

在某些情况下，所产生的算法，尽管没有产生与顺序情况相同的结果，但仍然是有用的。重要的例子是线性方程的迭代方法，或者更确切地说，这种方法的一次迭代。这些方法在并行化后产生了一个块状的版本。通过选择适当的重叠，通常可以确保收敛性，但这在很大程度上取决于方法和具体问题。

例如，Jacobi迭代的并行化没有问题，而对于Gauss-Seidel方法，并行算法的收敛行为在很大程度上取决于具体的线性系统。对于具有强烈顺序性的方法，如ILU，情况变得更糟。在这种情况下，我们将提出的概念可能必须加以完善。

因此，算法的决定不能由一般的软件来做，而必须由算法设计者负责，在这种情况下，数字分析师。然而，软件可以支持以高层次、简洁的方式表达这些决定。

分布式网格的核心任务是保证数据在底层算法中的充分定位。一个算法所使用的所有数据元素都必须在本地进行缓存。这一点尤其适用于分布式内存，但以更温和的形式，这一原则也适用于共享内存设置。为了实现这一点，网格数据结构必须提供适当数量的重复（重叠）。这种重叠的具体形状取决于所采用的算法，并且可以根据底层并行计算机的性能特点进行优化。

我们顺便指出，被称为 "非重叠 "的分解技术也涉及到我们在这里使用这个术语的意义上的数据重复（因此也是重叠），即各部分边界上的低维实体。

数据的重复使得有必要保持其一致性。因此，与网格元素之间的重叠相关的数据必须在有关进程之间进行交换。

接受网格分布作为几何分区的主导原则，应用于并行PDE求解，可以区分出两种基本情况。

- 静态分布。底层网格的分布保持固定

- 动态分布。网格的分布随时间变化而变化。

显而易见，静态分布是更基本的，因为它是动态分布的一个特例。对于没有空间适应性的算法，通常可以只用静态分布来实现并行化。在静态情况下，只有网格上的数据在网格部分之间进行交换。这些数据属于网格函数的责任，（见3.3.1.2和4.1.4节），因此分布式网格函数（5.5.5节）是支持静态情况下通信的主要实体。

上面描述的一般领域分解策略导致了一些具体问题，这些问题必须在静态情况下解决。

- 如何才能使负载均衡？最初如何将网格划分为大小大致相等的部分？

- 初始网格分布是如何产生的？

- 如何确定重叠的确切范围？

- 如何在细节上保持数据的一致性？

- 如何将重叠和沟通的开销降到最低？

- 数据传输是如何完成的？如何识别和处理时间上的依赖性？

负载平衡问题导致了一个图的分区问题：给定一个图（在本例中用网格表示），确定其节点的分区，使各部分（近似）相等，图分区之间的边界大小（近似）最小。

这个问题的最优解是已知的NP-hard。因此，存在大量的近似解法的算法，概述见[Els97]。此外，还存在用于图划分的软件包，例如METIS [Kar99] 或JOSTLE [Wal99] 。

因此，在本论文中，我们将网格划分作为一个预处理步骤。我们开发了一个METIS库的通用接口，它封装了所需的数据结构转换的细节。在任何情况下，网格划分算法都是通用实现的候选方案，因为这将消除复制的开销，这将导致可能的内存或运行时间瓶颈。

从$5.5$节开始，我们围绕分布式重叠网格的概念，发展了解决其余问题的一般概念。这些概念产生了数据结构和相关算法，隐藏了解决这些任务的细节，并为网格分布属性和数据一致性维护提供了非常高水平的描述。

动态情况带来了额外的问题。

- 如何处理动态负载的不平衡？

- 如何逐步重新划分网格？

- 网格块如何迁移到其他进程，包括重叠的数据结构和网格上的数据？


这种情况还没有完全纳入到迄今为止实施的组件中。然而，我们指出了动态分布是如何融入本框架的。

和静态情况一样，增量重新分区的问题可以由现有的组件解决，如PARMETIS [Kar99] ，但通用组件甚至比静态情况下更有用，因为与复制网格数据结构相关的开销往往会加剧重复执行。网格迁移和分布式重叠生成在$5.6 .5$和$5.6 .3$部分进行了处理。

\subsection{Software Support for Parallel PDE Solution}

支持一般并行编程的软件工具，特别是支持并行PDE求解的软件工具，形成了一个非常异质的景观。现有的工具大致分为两类。一类是不使用关于手头问题的特殊性质的任何信息（通用工具），另一类是在一定程度上利用关于要执行的（几何）数据分区的知识（特定领域工具）。

我们首先对通用工具做了一个简短的概述，这些工具可以进一步粗略地分类为库、并行语言和并行编译器。

通用库通常被限制在只提供低级别的支持，如MPI和PVM等消息传递库。它们为执行数据分配任务提供的概念支持非常少。它们的主要优点是具有良好的可移植性、灵活性和性能，这使得它们可以作为更高级别的工具的基础。

用于并行编程的语言正在激增。特别是，广泛使用的语言（如C、C++和FORTRAN）的并行方言正在使用中。对于数据并行的结构化应用，高性能Fortran（HPF）可能是最著名的例子。ADAPTOR（[BZ94][BHKF99]）是一个将HPF程序编译成高效的消息传递FORTRAN代码的工具。关于16种并行C++方言的概述见 [WL96] 。

像CONCERT $/ \mathrm{ICC}++\left(\left[\mathrm{C}^{+}, \mathrm{GC} 98\right]\right)$等一些面向对象的方法所提供的分布式对象或全局指针这样的抽象，从编程的角度来看是有吸引力的，但是在这些实体之上的数据分布过于细粒度，因此对于科学计算来说过于昂贵。

并行化的编译器经常提供的结果在性能方面显然是次优的，参见[Zom96]，第30章。特别是对于涉及不规则数据结构的应用，如非结构化网格，缺少的关于数据分布的知识很难自动推导。指令通常可以用来指导编译器；然而，在极端情况下，这可能会导致大量的特定问题的工作，从而使自动工具的使用受到质疑。

所有这三种方法的共同点是它们的优点--通用性--也是它们在并行PDE解决方案方面的弱点，即缺少对计算问题结构的了解。直截了当地说，库在低概念水平上留下了许多明确说明这种知识的工作，而并行化的程序不允许有足够的这种知识被表达出来，以达到足够的性能。

平行语言介于这两个极端之间。获得好的结果仍然需要大量的编程工作，包括明确地制定关于问题的知识，尽管是在比库更高的水平上。使用并行编程语言通常意味着开发新的程序；现有的代码很难重复使用。

本讨论有意简短；关于并行编程的通用工具的更广泛的概述，见例如 [Zom96] ，第29章和第30章。

与到目前为止讨论的通用工具相比，特定领域的方法可以利用关于问题类别的知识。在并行PDE求解的情况下，或者更普遍的情况下，基于网格的计算，问题的基本结构方面是相同的，或者至少在许多具体案例中是相似的。因此，一劳永逸地封装这些问题可望获得巨大收益。特定领域的方法涉及到支持的数据模型类别（从非结构化的一般图形到笛卡尔网格）的通用性与它们所能提供的特定知识和自动化的数量之间的权衡。

一些方法，如第二章中提到的PETSC[BGMS97]，或BLOCKSOLVE[JP95]，建立在代数水平之上。它们提供了一套分布式代数数据结构（矩阵和向量），以及相应的并行求解算法。然而，组织这些矩阵的分布式构造的工作（例如FEM刚度矩阵，$6.3$）是留给用户的。我们在这里对这个代数层面下面的网格层面感兴趣。

其中一个比较通用的方法是BIRKEN [Bir98]的DDD库，使用基于图的模型来定义和建立数据一致性。它用分布信息增强了用户数据结构，因此独立于特定的数据结构。然而，基于网格的计算中可用的额外结构不能被直接利用；指定和产生正确的重叠的任务在很大程度上仍由用户承担。在[Bir98]中，BIRKEN提出了一个解决这个问题的策略，但目前还不清楚这是否已经导致了一个实际的解决方案。

存在许多专门用于基于网格的应用的方法，例如，BIRKEN（同上）对这些工具中的大约20种进行了概述。

其中很大一部分集中在规则的、块状结构的网格上，如KELP（ [Fin97] , [FBK98] ）或SAMRAI [HK98] 。在这种情况下，算法的局部访问模式是非常有规律的，网格重叠的确定是相当直接的。这些软件包通常允许局部细化的自适应算法，从而形成具有相当复杂的通信行为的笛卡尔斑块的层次结构。

算法通常是在库所提供的数据结构之上制定的，这里是在矩形斑块上。由于这种单独的斑块很简单，这并不是一个严重的限制；这种方法很适合纳入为笛卡尔网格编写的现有求解器软件。支持非结构化网格的有GRIDS软件包 [GHR+93] 、DIME [FWM94] 和SUMAA3D [FJP98] 等。

GRIDS是针对FORTRAN应用程序的。程序是用协调 "本地 "普通例程的脚本指定的。这些脚本由一个特殊的预处理器翻译成可编译的代码，并允许为网格元素上的数据指定数据依赖关系，这与我们下面介绍的模版相对应（第5.5.4节）。

SUMAA3D项目的目的是提供一个平行网格计算的平台。它的目的是提供平行网格的生成、划分和细化。这些算法是该系统的一个组成部分，因此与底层数据表示法密切相关。

几乎所有这些方法都建立在它们自己的数据结构之上；因此，将现有的应用程序（建立在不同的数据结构上）并行化是困难的。

在精神上与这些非结构化网格的方法相似的是分布式重叠网格的概念，这些概念将在下面的章节中展开。它们提供了一种手段，应用程序员可以在一个非常接近分布式非结构化网格的心理概念的抽象层次上工作。详细来说，我们的方法有以下特点。

- 通过使用通用编程方法，它完全独立于底层网格数据结构，因此可以很容易地与现有程序一起使用（见6.4节）。

- 不需要额外的语言工具（如预处理程序）。

- 重叠的特点是模版非常紧凑（少数几个数字）。

- 重叠是在运行时从模版中计算出来的，不同的算法原则上可以有不同的重叠。

- 开销与重叠的大小成正比（包括内存和速度）。

- 所有的概念都是完全独立于维度的

因此，它结合了上述单一工具中的优点，以及对一般重叠部分进行非常精简而又普遍有效的处理的额外好处。

\subsection{Distributed Overlapping Grids - Concepts}

\subsubsection{Introduction}

正如在$5.3$节中所指出的，PDEs的并行求解--或一般的基于网格的计算--基本上是由网格分布驱动的。

本节的目的是发展概念，将网格分布的基本成分具体化--网格重叠、算法的数据访问模式和重复数据的一致性维护。

这些概念一起允许以抽象但精确的方式指定基于网格的计算的并行化。在后面的章节$(5.7)$中，我们将展示这些概念是如何产生封装细节的通用软件组件的，从而允许在同等的抽象水平上进行编程，就并行化而言。

下面几节介绍的概念完全与网格维度无关。所有与维度有关的方面都被封装在网格微内核中，既与抽象概念无关，也与数据结构无关，更与本节和下节开发的算法无关。

到目前为止，只对二维结构做了具体的测试；然而，扩展到三维似乎很简单，主要涉及网格数据结构本身。这个扩展计划在不久的将来进行。

本节组织如下。在$5.5 .2$中，讨论了分布式重叠网格的详细结构$(\mathrm{DOG})$，引出了重叠范围的详细概念，以及局部、分布式和全局网格。

第5.5.3节中介绍了由分区引起的商格的重要概念。

在第5.5.4节中，我们展示了非结构化网格上的算法访问模式是如何被模版描述的，为此我们开发了一个非常紧凑的符号。随后，我们证明了模版操作的一些基本结果。

第5.5.5节介绍的分布式网格函数，是将分布式重叠网格和基于网格的算法联系在一起的概念，是静态并行网格计算的 "工作马"。在这里，我们也给 "数据并行算法 "这个术语一个确切的含义，并讨论了分布式网格函数的相关一致性。

\subsubsection{Distributed Grids and Overlap Structures}

在讨论分布式网格时，我们更喜欢用 "部分 "一词来代替通常所说的 "进程 "甚至 "处理器"，因为它更紧密地表达了我们感兴趣的逻辑结构；是否有一个进程与每个部分相关联是次要的。特别是，在本节和以下各节中提出的观点与实际的物理分布无关。它们同样适用于所有部件都在同一物理存储器中的情况，我们将这种情况称为复合网格。

关于分布式结构有两种相反的观点。一方面是全局观，即同时看到所有部分，不偏重任何一个部分；另一方面是局部观，即 "坐下来 "看一个部分，集中精力与相邻部分互动。

每种观点都有其优点，因此在适当的时候会采用其中一种。我们将在$5.7$节中看到，这些不同的观点如何能被追溯到单个的软件组件，它们分别代表着局部的一部分或全局的整体。


也有两种互补的方式来思考分布式重叠网格的问题。一方面，我们可以考虑一个全局网格$\widehat{\mathcal{G}}$，它被划分为重叠部分$\mathcal{G}_{i} .$；另一方面，我们可以把$\mathcal{G}_{i}$视为主要实体，它只是 "标准 "顺序网格加上一些描述重叠的额外结构（局部重叠网格）。不同$\mathcal{G}_{i}$上的重叠部分之间的适当识别，然后作为 "胶水"，允许从这些部分的集合（分布式重叠网格）推导出全局网格$\widehat{\mathcal{G}}$。

第二种观点与分布式电网的实际情况更密切相关，在这种情况下，全局性的电网并不存在。这些实体的一般关系由[Fig5.1]描述。

更正式地说，不相交的局部重叠网格之间的联系是通过识别网格范围的适当映射建立的。

\textbf{Definition} 27（重叠结构）。让$\mathcal{G}_{i}$是一个网格集，$1 \leq i \leq N$ 。在$\left(\mathcal{G}_{i}\right)_{1 \leq i \leq N}$上的重叠结构是一个网格同构的系统$\Phi_{i j} \quad(\rightarrow$第54页$)$关于双边重叠$\mathcal{O}_{i j}$

$$
\Phi_{i j}: \mathcal{O}_{i j} \subset \mathcal{G}_{i} \mapsto \mathcal{O}_{j i} \subset \mathcal{G}_{j}
$$

令人满意的

$$
\Phi_{i j}^{-1}=\Phi_{j i}, \quad \Phi_{i j}\left(\mathcal{O}_{i j}\right)=\mathcal{O}_{j i} \quad(\text { symmetry })
$$

和

$$
\Phi_{i j} \circ \Phi_{j k}=\Phi_{i k} \quad \text { on } \quad \mathcal{O}_{i j} \cap \Phi_{j i}\left(\mathcal{O}_{j k}\right) \quad \text { (transitivity) }
$$

为$1 \leq i, j, k \leq N .$正式地，我们设定

$$
\mathcal{O}_{i i}=\emptyset \quad 1 \leq i \leq N
$$

注意，通常矩阵$\left(\Phi_{i j}\right)$是稀疏的。大多数双边重叠$\mathcal{O}_{i j}$是空的。

\textbf{Definition} 28（对应关系）。不同部分$\mathcal{G}_{i}, \mathcal{G}_{j}$的网格元素$e^{i} \in \mathcal{G}_{i}, e^{j} \in \mathcal{G}_{j}$之间的对应关系$\sim$被定义为

$$
e^{i} \sim e^{j} \Leftrightarrow \Phi_{i j}\left(e^{i}\right)=e^{j}
$$

这显然是一种等价关系，其类$[e]$用$\widehat{e}$表示。我们通过以下方式定义全局网格$\widehat{\mathcal{G}}$： 1.

$$
\widehat{\mathcal{G}}:=\left\{\widehat{e} \mid e \in \bigcup_{i=1}^{n} \mathcal{G}_{i}\right\}
$$

如果$\widehat{\mathcal{G}}$中的两个元素在一个部分$\mathcal{G}_{i}$中存在入射代表物，那么它们就是入射。

$$
\widehat{e}<\widehat{f} \Leftrightarrow \exists i: e_{i}<f_{i} \quad \text { in } \quad \mathcal{G}_{i}, \quad e_{i} \in \widehat{e}, f_{i} \in \widehat{f}
$$

等价类$\widehat{e}$上的入射关系是很好定义的，因为不同的一对代表$e_{j}, f_{j}$通过网格同构$\Phi_{j i}$对应于$e_{i}, f_{i}$，它保留入射。由于$\mathcal{G}_{i}$是封闭的，全局网格中的入射$e<f$不可能通过将$e, f$分配给不同的部分而不重复地被 "切割"。

分布式网格上的每个网格实体都必须与重叠结构一致。例如，如果$\Gamma_{i}$上有几何体$\mathcal{G}_{i}$，我们要求

$$
\Gamma_{j}=\Gamma_{i} \circ \Phi_{j i} \quad \text { on } \quad \mathcal{O}_{j i}
$$

这允许以一种直接的方式定义一个全局几何$\widehat{\Gamma}$。


下一步是定义重叠范围$\mathcal{O}_{i j} .$的所有权关系。我们区分暴露的范围$\mathcal{E}_{i j}$，它属于部分$i$，共享的范围$\mathcal{S}_{i j}$，属于部分$i$和部分$j$，以及复制的范围$\mathcal{C}_{i j}$，它属于部分$j$ 。这些范围之间必须有以下对称关系。

$$
\begin{aligned}
\mathcal{E}_{i j} &=\Phi_{j i}\left(\mathcal{C}_{j i}\right) \\
\mathcal{S}_{i j} &=\Phi_{j i}\left(\mathcal{S}_{j i}\right) \\
\mathcal{C}_{i j} &=\Phi_{j i}\left(\mathcal{E}_{j i}\right) \\
\mathcal{O}_{i j} &=\mathcal{E}_{i j} \cup \mathcal{S}_{i j} \cup \mathcal{C}_{i j}
\end{aligned}
$$

和$\mathcal{E}_{i j}, \mathcal{S}_{i j}, \mathcal{C}_{i j}$是成对不相交的。一般情况见图$5.2($a）。对于经典的施瓦兹域分解技术，没有共享的范围，重叠的部分是断开的（图$5.2(\mathrm{~b}))$ 。

这些双边范围主要对不同部分之间的数据交换有用。为了决定哪里需要计算，哪里不需要计算，需要所谓的总范围，它大致上是双边范围的联合体。

$$
\begin{array}{ll}
\mathcal{O}_{i}= & \bigcup_{j=1}^{n} \mathcal{O}_{i j} & \mathcal{S}_{i}=\bigcup_{j=1}^{n} \mathcal{S}_{i j} \backslash \mathcal{C}_{i} \text { shared } \\
\mathcal{C}_{i} & =\bigcup_{j=1}^{n} \mathcal{C}_{i j} \quad \text { copied } & \mathcal{E}_{i}=\bigcup_{j=1}^{n} \mathcal{E}_{i j} \backslash\left(\mathcal{S}_{i} \cup \mathcal{C}_{i}\right) \quad \text { exported }
\end{array}
$$

它们的含义如下。在$\mathcal{E}_{i}$中的暴露元素上，本地部分专门负责执行任何计算。在共享范围上，一般来说，几个部分会对计算做出贡献，或者在每个部分上重复进行计算。最后，在复制的元素上，不进行本地计算。


在$\mathcal{S}_{i}$中省略了复制的元素，在$\mathcal{E}_{i}$中省略了共享的元素，其原因是最小工作原则。如果一个元素是从某个地方复制过来的，我们不需要对它做任何计算。如果一个元素与其他部分共享，我们只做我们这部分的计算（除非反正选择了冗余计算）。请注意，$\mathcal{S}_{i} \cap \mathcal{C}_{i k} \neq \emptyset$确实是可能的，正如$\mathcal{S}_{i j} \cap \mathcal{E}_{i} \neq \emptyset$一样，见[Fig5.2] (d)。

此外，我们还定义了派生范围

$$
\begin{array}{rlll}
\mathcal{P}_{i} & =\mathcal{G}_{i} \backslash \mathcal{O}_{i} & \text { private } & \mathcal{L}_{i}=\mathcal{P}_{i} \cup \mathcal{E}_{i} \cup \mathcal{S}_{i} & \text { local } \\
\mathcal{X}_{i} & =\mathcal{S}_{i} \cup \mathcal{E}_{i} & \text { exported } & \mathcal{I}_{i}=\mathcal{S}_{i} \cup \mathcal{C}_{i} & \text { imported } \\
\mathcal{W}_{i} & =\mathcal{P}_{i} \cup \mathcal{E}_{i} & \text { owned } & &
\end{array}
$$

私有元素$\in \mathcal{P}_{i}$是那些不能被任何其他部分看到的元素。反之，其他部分的元素如果不能从部分$i$看到，则被称为部分$i$的远程元素。出口元素是那些其他部分可能感兴趣的元素，进口元素是本地部分感兴趣但不完全拥有的元素。拥有的元素是那些不与任何其他部分共享的元素（独家所有权），而本地元素也包括共享的元素。有时，有必要为每个元素设置一个独特的所有者。这可以通过将每个共享元素正式归属于其所有者中最少的一个来实现，并假设各部分有一个总的顺序。这种元素集将被称为正式拥有。为了便于以后参考，我们总结一下包含关系，从私有范围开始。

$$
\mathcal{P}_{i} \subset \mathcal{W}_{i} \subset \mathcal{F}_{i} \subset \mathcal{L}_{i} \subset \mathcal{G}_{i}
$$

\subsubsection{The Quotient Grid}

在处理底层网格的相关子范围时，对给定网格的分区施加网格状结构的商的概念对固定想法非常有用。例如，对于重叠结构的分布式生成（见第5.6.3节），商的网格结构很重要。根据商格的结构，有时可以对通信过程进行优化。

\textbf{Definition} 29（分区）。网格$P$的（基于单元）分区$\mathcal{G}$是一个射影映射

$$
P: \mathcal{G}^{d} \mapsto\{1, \ldots, N\}
$$

分区$P_{i}:=\overline{P^{-1}(i)}$是$\mathcal{G}$的子网格。

分区可以被看作是一个诱导商格的单元。低维的元素将被证明是由$P_{i}$的交点组成的。然而，并不是每个$P_{i}$的非空交点都定义了商的一个元素。

网格$\mathcal{G}$的任意子集的尺寸是其元素的最大尺寸。$k$-维元素的商数关系定义为：$\mathcal{G}$。

$$
c_{1} \sim_{d} c_{2} \Longleftrightarrow P\left(c_{1}\right)=P\left(c_{2}\right)
$$

为$\mathcal{G}$的单元，并递归为两个$k$维的元素。

$$
e_{1} \sim_{k} e_{2} \Longleftrightarrow\left[\mathcal{I}_{n}\left(e_{1}\right)\right]=\left[\mathcal{I}_{n}\left(e_{2}\right)\right], \quad k+1 \leq n \leq d
$$

也就是说，如果$e_{1}, e_{2}$与等价的高维元素有附带关系。很容易看出，$\sim_{k}$是一个等价关系。

\textbf{Definition} 30（网格商）。网格$\mathcal{G}$和分区$P$的商$\mathfrak{G}=\mathcal{G} / P$是有等级的位置集$(\rightarrow$p.52$)$，具有以下（封闭）元素。

1.  $P_{i}$ , $\mathfrak{G}$ 的细胞

2.为了定义维度为$k=d-1, \ldots, 0$的封闭元素e，我们考虑相对于$\sim_{k} .$的等价类 这里只考虑$\mathcal{G}^{k}$的$e$元素，它们包含在维度为$k+1$的一个以上的商元中。$k$的$\mathfrak{G}$元素被定义为此类元素的封闭类。

$$
\mathfrak{G}^{k}=\overline{\left\{[e]_{k} \mid e \in \bigcup_{\mathfrak{e}_{1}, \mathfrak{e}_{2} \in \mathfrak{G}^{k+1}} \overline{\mathfrak{e}_{1}} \cap \overline{\mathfrak{e}_{2}}\right\}}
$$

顺序关系由以下公式给出

$$
\mathfrak{e}<\mathfrak{f} \Longleftrightarrow \exists e \in \mathfrak{e} \exists f \in \mathfrak{f} \quad \text { such that } e<f
$$

因此，这个poset确实是分级的，因为原始网格的poset是分级的。

$\mathfrak{G}$的开放元素仅仅是除去所有附带的低维元素后的封闭元素。$\mathfrak{G}^{k}$的一个开放元素int(e)的闭合原则上有两种不同的解释。一是作为$\mathcal{G}^{k}$的一个子集的闭合，二是相对于$(5.7)$的闭合。然而，很容易看出，这两种可能性都导致了$\mathcal{G}$的同一个子集，即封闭元素$\mathfrak{e}$。

一般来说，被视为$\mathfrak{e}$的子复合物的商元$\mathcal{G}$可能是断开的或有洞的，因此不能与盘同构。例子见图$5.3$。因此，我们称$\mathfrak{G}=\mathcal{G} / P$为广义的网格。显然，$\mathfrak{G}$总有一个细分是规则网格（见47）；我们可以只取原始网格$\mathcal{G}$ 。

然而，人们往往对底层商集的组合特性比其几何意义更感兴趣。$\mathcal{G} / P$的面正是双边共享的范围$\mathcal{S}_{i j}$，而低维度的元素给出了几个分区之间共享的元素的信息，这对通信调度很重要。

如果商网是笛卡尔的--即使是非结构化的局部网格也可能是这种情况--那么数据交换（和重叠）可以被限制在直接相邻的地方，见[Fig5.4]。在这种情况下，双边范围$\mathcal{E}_{i j}$和$\mathcal{C}_{i j}$必须通过删除不共享商格面的部分的双边重叠来扩大所留下的角片。


\subsubsection{Stencils of Algorithms}

一个通用的重叠网格组件的核心任务是自动确定与算法的数据访问模式有关的正确重叠结构，这通常涉及一个元素的某个邻域。

这种由算法诱导的邻域（依赖域）被称为其模版。

如何描述非结构化网格上的模版？中心思想最好通过一个例子来介绍。假设我们有一个简单的通量计算算法 $f$ 。


这个算法的抽象组合结构可以表示为从单元到入射面再到入射单元。

$$
C \mapsto F \mapsto C
$$

这种结构可以通过在入射序列$(d, d-1, d)$或$C F C$（用于细胞-面-细胞）中列出相应的尺寸来更简明地表达。

图$5.5(\mathrm{a})$可以看出。这个模版对于网格分布的意义是：每当$f$要对一个单元$c$进行计算时，它的所有邻居$n$（与$c$共享一个面）必须在本地网格$\mathcal{G}_{i}$中可以访问，而且此时的网格函数$U$必须是全球一致的$(\rightarrow$ 第129页$)$。

更一般地说，如果一个网格算法$f$只依赖于限制在一个网格元素的局部邻域的状态$S$（见第5.5.5节），就可以说它是局部操作。

$$
f(e, S)=f\left(e, S_{\mid \mathcal{N}(e)}\right) \quad \text { where } \quad e \in \mathcal{N}(e) \subset \mathcal{G}_{i}
$$

在上面的例子中，$S=U$ ，$\mathcal{N}(c)$是图中所示的邻居单元的集合。  $5.5(\mathrm{a})$ 对于每个元素$e$，都有一个最小的网格邻域，使得这个方程有效。$f$的模版是函数$V_{f}$。

$$
\begin{aligned}
V_{f}: \mathcal{G}^{k} & \mapsto\{\mathcal{N} \subset \mathcal{G}\} \\
V_{f}(e) &=\mathcal{N}(e)
\end{aligned}
$$

决定了最小邻域。

通常情况下，模版可以用相当简单的术语描述，通过使用入射序列，如上面的通量例子。对于一组给定的初始元素，例如网格分区边界上的单元，将这个入射序列应用于所有这些初始单元，然后确定分区外所有可能被算法需要的元素，见图$5.5(\mathrm{~b})$中的暗三角形。

\textbf{Definition} 31（入射序列，层，壳）。一个$d$维度网格的入射序列是一个$I$与$0 \leq a_{i} \leq d$的数字序列$\left(a_{0}, \ldots, a_{n}\right)$。其含义是，从一个维度为$a_{0}$的初始元素开始，所有维度为$a_{1}$的入射元素被访问，从这些入射元素开始，所有维度为$a_{2}$的入射元素被访问，依此类推。更正式的说，让$\mathcal{K} \subset \mathcal{G}$是维度$i .$的元素的初始集（胚芽）。 入射层$\mathcal{L}_{(i, j)}(\mathcal{K})$的定义如下

$$
\mathcal{L}_{(i, j)}(\mathcal{K}):=\bigcup_{e \in \mathcal{K}^{i}} \mathcal{I}_{j}(e)=\bigcup_{e \in \mathcal{K}^{i}}\left\{f \in \mathcal{G}^{j} \mid f \lessgtr e\right\}
$$

假设$I=\left(a_{0}, a_{1}, \ldots, a_{n}\right)$是网格$\mathcal{G} .$上的入射序列，那么由$I$和胚芽$\mathcal{K} \subset G^{a_{0}}$产生的壳$\mathcal{H}=\mathcal{H}_{I}(\mathcal{K})$和层$\mathcal{L}_{I}^{(k)}(\mathcal{K})$可以递归地定义为



$$
\begin{aligned}
\mathcal{L}_{I}^{(0)}(\mathcal{K}) &:=\mathcal{K} \\
\mathcal{L}_{I}^{(k)}(\mathcal{K}) &:=\mathcal{L}_{\left(a_{k-1}, a_{k}\right)}\left(\mathcal{L}_{I}^{(k-1)}(\mathcal{K})\right) \backslash \bigcup_{j=0}^{k-1}\left(\mathcal{L}_{I}^{(k-1)}(\mathcal{K})\right) \\
\mathcal{H}_{I}(\mathcal{K}) &:=\bigcup_{k=0}^{n} \mathcal{L}_{I}^{(k)}(\mathcal{K})
\end{aligned}
$$

为了缩写，我们还定义了部分外壳

$$
\mathcal{H}_{I}^{k}(\mathcal{K}):=\mathcal{H}_{\left(a_{0}, \ldots, a_{k}\right)}(\mathcal{K})=\bigcup_{j=0}^{k} \mathcal{L}_{I}^{(j)}(\mathcal{K})
$$

很明显，一个人有

$$
\begin{aligned}
&\mathcal{H}_{I}(A \cup B)=\mathcal{H}_{I}(A) \cup \mathcal{H}_{I}(B) \\
&\mathcal{H}_{I}(A \cap B) \subset \mathcal{H}_{I}(A) \cap \mathcal{H}_{I}(B)
\end{aligned}
$$

因为对于一个固定的模版，$\mathcal{H}_{I}$是$\mathcal{G}^{a_{0}}$的幂集到$\mathcal{G}$的幂集的一个映射。

图$5.5(\mathrm{a})$的钢网是基于单元格的钢网中较为有限的一类的代表。这些模版的形式是$\left(d, d_{1}, d, d_{2}, \ldots, d_{n}, d\right)$ ，其中$0 \leq d_{i} \leq d-1$ 。对于基于单元格的钢网$I$，我们设定$I_{[k]}:=\left(d, d_{k}, d\right)$，和$I_{[k, l]}:=\left(d, d_{k}, d, d_{k+1}, \ldots, d_{l}, d\right)$ 钢网$I=\left(d, d_{1}, d, d_{2}, \ldots, d_{n}, d\right)$的长度定义为$|I|=n$ 。如果给出两个网板 $I_{1}=\left(d, d_{1}, \ldots, d_{k}, d\right)$ 和 $I_{2}=\left(d, d_{k+1}, \ldots, d_{n}, d\right)$ ，组成的网板是 $I:=\left(I_{1}, I_{2}\right):=\left(d, d_{1}, \ldots, d_{n}, d\right)$ 。反之，我们将$I_{1}, I_{2}$称为$I$的拆分。 有时，模版被写成更短的形式$C V C$（对于$(d, 0, d)$或单元格-vertexcell$), C F C$对于$(d, d-1, d)$等等。

为了简短起见，我们在基于细胞的模版的情况下设定为

$$
\mathcal{L}_{d_{k}}(A):=\mathcal{L}_{\left(d, d_{k}, d\right)}^{(2)}(A)=\mathcal{L}_{\left(d, d_{k}\right)}\left(\mathcal{L}_{\left(d_{k}, d\right)}(A)\right)
$$

因为我们一般只对含有细胞的层感兴趣。

从现在开始，将只使用基于单元的钢网。对于基于顶点的模版也可以有类似的考虑。

直观上似乎很清楚，船体可以 "按部分 "计算，也就是说，如果 $I=\left(I_{1}, I_{2}\right)$ ，那么 $\mathcal{H}_{I}(\mathcal{K})=\mathcal{H}_{I_{2}}\left(\mathcal{H}_{I_{1}}(\mathcal{K})\right) .$ 这对任意网格来说不是真的，见[Fig5.6] (b) .我们对流形有界（mwb-）网格上基于单元格的钢网进行证明。这个结果在证明模版的单调性属性时需要用到（定理5）。

\textbf{Theorem} 4.如果$\mathcal{G}$是一个有边界的流形网格，那么，如果在每一层中，将整个部分网格$\mathcal{H}^{k-1}$而不是$\mathcal{L}^{k-1}$作为胚胎，则基于单元格的模板$I$的船体不会改变。也就是说，如果$I=\left(d, d_{0}, d, \ldots, d_{k}, d\right)$ ，那么

$$
\mathcal{L}_{d_{k}}\left(\mathcal{L}_{I}^{k-1}(A)\right) \backslash \mathcal{H}_{I}^{k-1}(A)=\mathcal{L}_{d_{k}}\left(\mathcal{H}_{I}^{k-1}(A)\right) \backslash \mathcal{H}_{I}^{k-1}(A)
$$

对于任何胚胎 $A \in \mathcal{G} .$ 由此可见，对于 $I=\left(I_{1}, I_{2}\right)$

$$
\mathcal{H}_{I}(\mathcal{K})=\mathcal{H}_{I_{2}}\left(\mathcal{H}_{I_{1}}(\mathcal{K})\right)
$$

\textbf{Proof} .为简洁起见，我们省略固定网板$I .$ 我们必须证明在步骤$k$中从$\mathcal{H}^{k-1}$到达的单元也是在上一层$\mathcal{L}^{k-1} \subset \mathcal{H}^{k-1}$的一个单元上到达的。

首先，让$e \in \overline{\mathcal{H}^{k-1}}$是一个非单元格元素，st$(e)$是$e(\rightarrow \mathrm{p} .48) .$的星，如果st$(e)$中存在一个不包含在$\mathcal{H}^{k-1}$中的单元格$c_{b}$，$\operatorname{st}(e) \cap \mathcal{H}^{k-1}$中一定存在一个与$\operatorname{st}(e) \backslash \mathcal{H}^{k-1}$中的一个单元格相邻的面$f$。

这是因为$S(e)$是一个球或维度为$d$的半空间的同构体，因此是一个开放的、连接的集合。有一个单元$c^{\prime} \subset \mathcal{H}^{k-1}$与$e$相邻，从$c^{\prime}$到$c$的路径在st$(e)$的内部必须离开$\mathcal{H}^{k-1}$，并且可以通过一个面稍作扭曲来实现。

单元$c_{b}$必须属于最后一层$\mathcal{L}^{(k-1)}$，因为如果它属于前一层$\mathcal{L}^{(k-j)}, j>1$，那么面的另一边的单元就会在$\mathcal{L}^{(k-j+1)}$层中达到，而不考虑$d_{k-j+1}$，参见$(5.17)$ 。

现在，让$c$是在层$k$中首次访问的单元格。

$$
c \in \mathcal{L}_{d_{k}}\left(\mathcal{H}^{k-1}\right) \backslash \mathcal{H}^{k-1}
$$

也就是说，存在$e \in \mathcal{H}^{k-1}$与$\operatorname{dim} e=d_{k}$以及$c^{\prime} \in \mathcal{H}^{k-1}$与$c \cap c^{\prime} \supset e$的单元格，即$c$和$c^{\prime}$包含在st $(e)$中（见图$\left.5.6(\mathrm{a})\right)$ 。根据之前的考虑，至少要有一个单元格$c_{b} \in \operatorname{st}(e) \cap \mathcal{L}^{k-1}$ 。那么还有$c_{b} \cap c \supset e$ ，因此

$$
c \in \mathcal{L}_{d_{k}}\left(\mathcal{L}^{k-1}\right) \backslash \mathcal{H}^{k-1}
$$

现在，为了证明$(5.16)$，我们注意到，我们刚刚证明了特殊情况$I=\left(J, d, d_{k}, d\right)$，即。

$$
\mathcal{H}_{\left(d, d_{k}, d\right)}\left(\mathcal{H}_{J}(A)\right)=\mathcal{H}_{I}(A)
$$

一般情况下，通过对$|I|$的归纳，可以得出结论。


显而易见的是

$$
d_{1} \geq d_{2} \Rightarrow \mathcal{H}_{\left(d, d_{1}, d\right)}(A) \subseteq \mathcal{H}_{\left(d, d_{2}, d\right)}(A)
$$

因为$c \in \mathcal{H}_{\left(d, d_{1}, d\right)}(A)$意味着存在$c^{\prime} \in A$与$\operatorname{dim}\left(c \cap c^{\prime}\right) \geq d_{1} \geq d_{2}$，从而存在$c \in \mathcal{H}_{\left(d, d_{2}, d\right)}(A) .$。 对于子网，可以预期有类似的关系。这就促使我们对基于单元格的模版进行部分排序的定义。

\textbf{Definition} 32（模版的部分顺序）。如果存在$I=\left(d, d_{1}, d, \ldots, d_{n}, d\right)$网板$J=\left(d, c_{1}, d, \ldots, c_{k}, d\right)$，在符号$I \geq J$中支配一个网板$J=\left(d, c_{1}, d, \ldots, c_{k}, d\right)$，如果存在$1 \leq i_{1}<\ldots<$$i_{k} \leq n$，使得

$$
c_{r} \geq d_{i_{r}} \quad \text { for } \quad 1 \leq r \leq k
$$

直观地讲，我们期望支配性模版能产生一个更大的壳。下面的定理表明，这的确是真的。这个结果可以用来决定在不同模版的情况下，是否由于主导性而不需要考虑其中的某些模版，例如见第6.2.3.3节关于有限体积方法中的不同模版。

\textbf{Theorem} 5（基于单元格的模版的赫尔单调性）。让

$$
I=\left(d, d_{1}, d, d_{2}, \ldots, d_{n}, d\right)
$$

是一个基于单元格的钢网，$\mathcal{G}$是一个Mwb网格。那么

(i) 对于所有细胞组$A, B \subset \mathcal{G}^{d}$

$$
A \subset B \Rightarrow \mathcal{H}_{I}(A) \subset \mathcal{H}_{I}(B)
$$

(胚芽单调性)

(ii) 如果$J$是另一个基于单元格的模版，那么

$$
J \leq I \Rightarrow \mathcal{H}_{J}(A) \subseteq \mathcal{H}_{I}(A)
$$

(模版的单调性)

\纹理bf{Proof.}。我们首先证明$(5.18)$的情况$|I|=1$，即$I=\left(d, d_{k}, d\right):$ 如果$c \in \mathcal{H}_{I}(B)$，那么$c \in B$或者有$c^{\prime} \in \bar{B}$，使得$c$和$c^{\prime}$都是维度$d_{k} .$的元素$e$的入射。] 都是维度为$d_{k} .$的元素$e$的附随 因为$A \supset B$，用$A$替换$B$也是如此，这就相当于$c \in \mathcal{H}_{I}(B)$

对于一般的$I$，我们可以在$I .$的长度上使用归纳法，使用分裂的$I=\left(I_{1}, I_{2}\right)$，我们有

$$
\mathcal{H}_{I}(B)=\mathcal{H}_{I_{1}}\left(\mathcal{H}_{I_{2}}(B)\right) \subset \mathcal{H}_{I_{1}}\left(\mathcal{H}_{I_{2}}(A)\right)=\mathcal{H}_{I}(A)
$$

为了证明（5.19），我们对$J$的长度使用归纳法。对于空模版，$(5.19)$是微不足道的。现在让$|J|=1$和$k$是这样的：$J \leq I_{k} .$ 那么



一般的$J$与$|J|>1$可以被分割成$\left(J_{1}, J_{2}\right)$与$\left|J_{1}\right|<|J|,\left|J_{2}\right|<|J| .$使用相应的分割$I=\left(I_{1}, I_{2}\right)$与$J_{1} \leq I_{1}, J_{2} \leq I_{2}$（根据模版支配的定义必须存在），我们有

$$
\begin{aligned}
\mathcal{H}_{J}(B) &=\mathcal{H}_{J_{1}}\left(\mathcal{H}_{J_{2}}(B)\right) & & \text { by theorem } 4 \\
& \subseteq \mathcal{H}_{I_{1}}\left(\mathcal{H}_{I_{2}}(B)\right) & & \text { by induction and }(5.18) \\
&=\mathcal{H}_{I}(B) & & \text { by theorem } 4
\end{aligned}
$$


\subsubsection{Distributed Grid Functions}

对于静态通信模式，只有网格上的数据被交换。因此，在这种情况下，（分布式）网格函数正是程序员必须处理分布问题的抽象层。

我们假设程序状态$S$是由网格函数$F_{A}$和数字$\lambda_{a}$（全局参数，如时间步长、公差等），加上网格和几何图形（后者被认为是不可改变的）组成。

$$
S=\left(F_{A}, F_{B}, \ldots, \lambda_{a}, \lambda_{b}, \ldots, \mathcal{G}, \Gamma\right)
$$

这里孤立地考虑网格函数并不是特别有用。为了正确定义基本概念，还必须考虑计算网格函数值的算法$f$$F$，发生计算的网格范围$W$，以及网格函数值被其他算法使用的网格范围$R$。这些合在一起，我们称之为计算元组。

\textbf{Definition} 33（计算元组）。一个计算元组是一个元组$\left(F, f, W, R, S_{f}\right)$ ，其中$S_{f} \subset S$ ，和

$$
F: \mathcal{G}^{k} \mapsto \mathcal{T}
$$

是一个从$k$元素到一个$\mathcal{T}$集合的网格函数。

$$
W \subseteq \mathcal{G}^{k}
$$

是一个工作（或写）范围。

$$
R \subseteq \mathcal{G}^{k}
$$

是一个读取范围，而

$$
f: \mathcal{G}^{k} \times S_{f} \mapsto \mathcal{T}
$$

是一种网格算法。

\textbf{Definition} 34（数据并行算法）。如果$S_{f}$不依赖于$F$，即$F \notin$$S_{f}$，我们说$f$是数据平行的。$f$在元素$e \in W$上的值不取决于$f$在$W$上的评估顺序。

本地数据并行算法的典型例子是PDEs的离散化。它们封装了许多应用的具体细节，并且无论全局分布情况如何都可以保持不变。

到目前为止，只考虑了局部网格函数。分布式网格函数（DGF）只是一个局部网格函数的向量$\left(F_{i}\right)_{1 \leq i \leq N}$，每个都是指分布式网格而不是局部网格。(为了清楚起见，我们省略了相关的计算元组。)算法$f$没有下标的事实是SPMD范式的结果：它对每个部分都是一样的。

现在我们想为分布式网格函数定义一致性。因此，我们假设程序的迭代结构。

这里$W^{(n)}=W$被认为是静态的。在步骤$n$，一个网格函数元组$(F, f, W, R)$在一个范围$L \subset W$上是一致的，如果

$$
F^{(n)}(e)=f\left(e, S^{(n)}\right) \quad \forall e \in L
$$

如果一个元组在$W$上是一致的，它就是局部一致的。如果每个$\left(F_{i}\right)_{1 \leq i \leq N}$都是局部一致的，并且任何两个局部网格函数在其共同支持上重合，那么分布式网格函数$\left(F_{i}\right)_{1 \leq i \leq N}$就是（全局）一致的（或同步的）。

$$
F_{i}=F_{j} \circ \Phi_{i j} \quad \text { on } \quad \mathcal{O}_{i j}
$$

全局一致的分布式网格函数允许通过以下方式定义全局网格函数$\widehat{F}$： 1.

$$
\widehat{F}(\widehat{e})=F_{i}\left(e_{i}\right), e_{i} \in \widehat{e} \quad \forall \widehat{e} \in \widehat{\mathcal{G}}^{k}
$$

根据TANENBAUM [Tan95]，一致性模型是系统层（DOG/DGF）和应用之间的一种论文。在我们的例子中，DGF层承诺。"如果你在一个分布式网格函数上调用synchronize()，那么之后相应元素上的值将是一样的"。

另一方面，应用程序有责任为DGF分配正确的读/写范围，为共享范围使用正确的模式，并且只在同步和随后的本地重新计算之间使用DGF。否则，就不会有一个有意义的全局网格函数的状态。但请看下面（第131页）的一个例子，不一致状态的控制版本是有用的。

因此，程序员在分布式网格功能方面必须做出的决定是

1. 确定每个网格函数的范围$W$和$R$。

2.决定一个分布式电网功能是否以及何时需要同步化

第1项需要相关算法的模版$f$，可能还需要选择在共享范围内是否应该在每个节点上进行部分或完全计算。

写范围$W_{i}$一般与本地范围$\mathcal{W}_{i}=\mathcal{P}_{i} \cup \mathcal{E}_{i} \cup \mathcal{S}_{i}$重合，而读范围$R_{i}$可能在$W_{i}$和$W_{i} \cup \mathcal{C}_{i} .$之间，因此，底层网格的预定义重叠范围通常可以不做任何修改。更多的例子可以在 $158 \mathrm{ff}$ 页找到。

如何从函数模版中计算出重叠量是$5.6$节的主题

关于同步时刻的决定通常是直接的，只要在局部一致时使其全局一致即可。


在这个阶段，也有可能将计算和通信重叠起来。该程序将不得不改为：

对于所有e出口的范围，做



对于所有$e \in$的剩余范围做


这被称为 "先计算后发送 "策略。

此外，经常需要进行全局性的还原操作。将这种操作的结果称为$\widehat{\lambda}$，以及还原运算符$\oplus$（关联，换元），这可以正式写为

在没有进一步了解算子$\oplus$的情况下，我们可以通过首先在形式上拥有的元素$e \in \mathcal{F}_{i}^{k}$上局部计算值$\lambda_{i}$，然后对$\lambda_{i} .$应用$g$的叶状还原来计算$\widehat{\lambda}$。 这后一种还原的实现将取决于物理分布。

\subsection{Distributed Overlapping Grids - Algorithms}

前面一节中关于重叠结构和钢网诱导壳的定义提出了一个问题，即如何在算法上确定这些实体。在本节中，我们介绍了执行这些任务和其他与分布式网格有关的任务的方法。在第5.6.1节中，讨论了与分布式网格函数的同步有关的问题。第5.6.2节描述了一个通用算法INCIDENCE HULL，用于计算由任意钢网生成的船体。整个重叠结构的构造（算法CONSTRUCT OVERLAP，第134页）是5.6.3节的主题。这里还介绍了算法DISTRIBUTED HULL（第137页），它在物理分布网格的情况下，从只存在共享范围的情况开始计算重叠。在$5.6 .4$节中研究了商数网格的确定（算法QUOTIENT GRID，第138页）。最后，第5.6.5节讨论了动态网格的一些方面，这些方面还没有完全搞清楚。

\subsubsection{Static Communication}

对于静态同步，只有网格函数的值需要被交换。为此，我们必须知道数据必须被复制的范围，以及由$\Phi_{i j} .$给出的对应关系。 对于实际执行，同步迭代的概念变成了一个关键的概念。通过这一点，我们意味着相应的范围是以相应的顺序被遍历的。如果我们假设相应的重叠范围$\mathcal{E}_{i j} \sim \mathcal{C}_{j i}$是序列，那么

$$
e_{i j}^{n} \sim c_{j i}^{n}, \quad 1 \leq n \leq N=\left|\mathcal{E}_{i j}\right|
$$

在这种情况下，映射$\Phi_{i j}$是由相应范围的同步排序隐式给出的。

在最简单的情况下，在同步操作中需要做的就是将$N$同质数据项从一个地方复制到另一个地方。这到底是如何发生的，取决于环境。在一个驻留在一个全局地址空间的复合网格中，只需使用普通的复制。在一个分布式内存环境中，使用某种消息传递，例如由MPI或PVM库提供。

如果共享范围上的值在每个局部上都被完全计算，就会出现这种简单的情况。它还假设数据有一个值的语义，也就是说，不引用其他数据。对于数字数据来说，这当然是一种情况。

对于部分计算的情况来说，情况要稍微复杂一些。在这里，共享范围内的数据必须通过减法运算来组合，通常是求和，参见[Fig5.7]。这引入了一些复杂性，因为必须确保每个值被精确使用一次，这使得有时必须使用临时存储。令人惊讶的是，这个问题在分布式内存背景下使用消息传递库更容易解决，因为它已经提供了必要的缓冲区。

部分计算的一个重要例子是有限元刚度矩阵装配，见 [Bas94] 或 [Haa97] 。没有复制的单元，在每个顶点上只有本地单元的矩阵条目被计算。在这里，共享顶点上的值必须被加上，以达到全局一致的状态。在矩阵的情况下，人们经常与只有局部一致的数据一起工作。与基于顶点的向量相乘的结果也是全局不一致的数据，可以通过同步操作使其一致。何时同步这些数据结构的问题与与它们相关的代数意义密切相关，不能委托给网格函数层。然而，如何做到这一点的细节可以完全隐藏。

如果分区网格的一些额外结构要用于优化通信，就会产生额外的复杂性，正如第121页所讨论的。

同步操作所触发的动作还有很多可能性。所以，在这种情况下，显然可以包括周期性边界，也见第133页。另外，它还可以用来在不同类型的网格混合网格之间传输数据，例如直角坐标系和非结构化网格。特殊的界面边界条件也可以在这个阶段处理。

Overset或Chimera网格技术（见例如[Pet97]）使用的网格在几何上是重叠的，但不是组合的，也就是说，在这里定义的意义上不是重叠的网格。尽管如此，相应的网格转移操作可以隐藏在分布式网格函数的罩子下面。

原则上，甚至有可能将所有这些可能性结合到一个单一的应用中，从而实现非常高的灵活性。

\subsubsection{Determination of Hulls Generated by a Stencil}

表$5.1$中的算法INCIDENCE HULL，在预期时间$O(|\mathcal{H}|)$内计算出一个船体$\mathcal{H}$。这个时间限制主要取决于是否有部分网格函数在预处理步骤中以恒定的时间将所有网格元素标记为未访问。

该算法适用于一般模版，而不仅仅是基于单元格的模版。然而，一个基本的先决条件是每个允许的子钢网的入射迭代器的可用性 $\left(a_{k}, a_{k+1}\right)$ 。例如，如果$(0, d)$是一个允许的子钢网，必须有一个CellOnVertex Iterator $(\rightarrow$ p. 206）类型为底层网格定义，如果$(d, f)$是允许的，网格必须提供对入射到一个单元的面的迭代。

为了估计算法INCIDENCE HULL的复杂性，我们假设所有类型的入射关系都被一个与网格大小无关的常数$C$所约束，也就是说。

$$
\left|\mathcal{I}_{k}(e)\right| \leq C \quad 0 \leq k \leq d \quad \forall e \in \mathcal{G}
$$

对于现实世界的网格来说，这当然是一个有效的假设；例如，在二维空间中，一个$C \leq 10$的值对于PDE计算中使用的绝大多数网格都是有效的。

我们注意到，由于在第$1 .$行中使用了部分网格函数，所以只访问了输出中包含的元素。 算法INCIDENCE HULL的潜在昂贵部分是第$7-11$行中的循环，这里的情况是第8行中测试的元素不止一次。

条件（5.20）现在意味着第7行的每个元素$f_{e}$最多可以被访问$C$次，也就是说，第8行的测试对输出中的任何元素最多执行$C$次，而对其他元素从不执行，也就是说，只有$C \cdot\left|\mathcal{H}_{I}\right|$测试是必要的。

\subsubsection{Construction of Overlapping Grids}

构建重叠网格的问题如下。给定一个全局网格、这个网格的一个分区和一个钢网，确定局部网格$\mathcal{G}_{i}$和前面几节所述的重叠范围。重叠结构和分布式网格的实际构建略有不同，取决于配置。根据整个全局网格是否可用，底层分区是基于单元还是基于顶点，或者所产生的网格是物理分布的还是驻留在一个全局存储器中，都有不同。

为了简单起见，我们首先集中讨论全局网格在本地内存中的情况，并在本地构建一个复合网格。此外，我们假设分区是基于单元的。在这种情况下，基本算法$5.2$ CONSTRUCT OVERLAP决定了必要的数据。

对于其他配置，CONSTRUCT OVERLAP必须进行调整。在物理分布式网格的情况下，建设可以在每个进程中并行进行，在最后阶段，只建设本地部分$\left(\mathcal{G}_{i}, \mathcal{O}_{i}\right)$。

这种方法不能扩展到大量的进程，因为全局网格可能大到无法装入单个存储器。下面，我们提出算法$5.3$，允许在分布式环境下计算重叠。它从本地部分$P_{i}$和共享范围$\mathcal{S}_{i j}$开始，是重叠的分布式构造的核心。

在周期性的边界，全局网格首先要通过适当的重叠来扩大。然后在扩大的部分创建新的分区，这些分区指向原始网格中的 "主 "分区，这些分区是从原始网格中复制出来的。这有助于将增加的网格部分与原始网格区分开来。

然后，可以使用基本算法，其中索引$i, j$是指扩大的分区集。最后，当网格部分$\left(\mathcal{G}_{i}, \mathcal{O}_{i}\right)$被构建时，新的分区必须与它们的主站重新识别。这样一来，形式为$\mathcal{O}_{i i}$的重叠范围也是可能的。算法$5.2$的一个稍加修改的版本可以用来纳入周期性边界，包含原始版本作为一个特例。

在一个真正的分布式环境中，首先会有一个分布式网格的生成。对于这项任务，必须给出计算域的初始细分。我们可以假设这样的细分是由一个初始（粗）网格给出的，它是所有部分都知道的。因此，平行网格的生成相当于对一些粗略网格的平行 "细化"，可能每个部分只由一个单元组成。(这里的 "细化 "一词必须在比通常更广泛的意义上理解）。)粗略的网格代表了识别网格实体的共同基础，可以使用 "引导 "方法。

一般来说，会涉及到第一步的表面网格生成，在由几个部分共享的粗略网格元素上建立低维网格，也就是$2 \mathrm{D}$中的边，以及$3 \mathrm{D}$中的边后的切面。

只有当网格生成过程是有规律的，即结果是平等的，并且在每个部分都容易匹配，这第一步才可以省略。例如，如果每个部分都生成笛卡尔结构的网格，特别是如果粗略的网格本身是笛卡尔网格的（一部分），就会出现这种情况。更为普遍的是，在通常的有限元意义上的细化，遵循一个规则的模式，可以直接识别独立创建的网格元素，因为父元素已经被识别。

并行电网发电不是一件容易的事，特别是如果考虑到负载平衡，见例如 [SFdC+ 97 $]$ 。

在网格生成后，可以假定共享范围$\mathcal{S}_{i}$和$\mathcal{S}_{i j}$是可用的（如果网格生成器不允许在其输出中识别顶点等输入边界元素，可以借助实体的几何匹配等装置）。

然后，总范围$\mathcal{E}_{i}$可由赫尔算法确定。对于双边范围$\mathcal{C}_{i j}$，我们采用了一个迭代程序，基于以下观察。

\tetxbf{定理}。  $6 .$ 在全局网格$\widehat{\mathcal{G}}$中，对于任何$1 \leq k \leq N$，$P_{i}$中需要的复制范围$\widehat{\mathcal{C}_{i k}}$包含在$P_{i}$的直接邻居的复制范围的联盟中（在商$\mathcal{G} / P(\rightarrow p .121))$ ，即。

$$
\widehat{\mathcal{C}}_{i k} \subset \bigcup_{j \in A_{i}} \widehat{\mathcal{C}}_{j k} \quad \text { with } \quad A_{i}=\left\{j \mid P_{i} \text { adjacent } t o P_{j}\right\}
$$

\textbf{Proof} .(我们省略.符号，以表明我们是在全局网格上操作。) 对于一个单元$c, c \in \mathcal{C}_{i k}$，意味着

$$
\begin{aligned}
c & \in \mathcal{H}_{I}\left(\mathcal{S}_{i}\right) \cap \mathcal{G}_{k} \\
&=\mathcal{H}_{I}\left(\bigcup_{j \in A_{i}} \mathcal{S}_{i j}\right) \cap \mathcal{G}_{k}=\bigcup_{j \in A_{i}} \mathcal{H}_{I}(\underbrace{\mathcal{S}_{i j}}_{\subset \mathcal{S}_{j}}) \cap \mathcal{G}_{k} \\
& \subset \bigcup_{j \in A_{i}} \mathcal{H}_{I}\left(\mathcal{S}_{j}\right) \cap \mathcal{G}_{k}=\bigcup_{j \in A_{i}} \mathcal{C}_{j k}
\end{aligned}
$$





当然，如果$P_{i}$和$P_{k}$不是直接邻接，这种包含就很有意思。然而，我们可以构建这样的例子：$P_{i}$和$P_{k}$是直接邻居，但$\mathcal{C}_{i k}$的一个单元只能通过第三部分到达。

\textbf{Theorem} 6引导我们进入以下迭代程序，以获得局部重叠范围（参见图$5.8):$ 我们设定$\mathcal{G}_{i}^{(0)}=P_{i}$ ，并递归定义下一个网格$\mathcal{G}_{i}^{(k+1)}$为当前网格中所有直接邻居所取的船体。

$$
\mathcal{G}_{i}^{(k+1)}=\mathcal{G}_{i}^{(k)} \bigcup_{j \in N} \mathcal{H}^{j}\left(\mathcal{S}_{j i}\right)
$$

这里$\mathcal{H}^{j}$是限制在当前网格$\mathcal{G}_{j}^{(k)}$的船体操作（固定网板$I$已被省略）。

我们现在证明，算法$5.3$确实在有限的步骤中计算了重叠范围。

\textbf{Theorem} 7.算法$5.3$在最多的步骤中为模版$I=\left(d, d_{1}, \ldots, d_{r}, d\right)$获得复制的范围$\mathcal{C}_{i k}$。

$$
\sum_{j=1}^{r} \max _{\mathfrak{e} \in \mathfrak{G}^{d_{j}}} \operatorname{diam}(\operatorname{st}(\mathfrak{e}))
$$

这里$\mathfrak{G}$是商格，用$\operatorname{diam}($st$(\mathfrak{e}))$我们指的是st(e)中两个单元的最大距离，此时只允许通过一个面传递到另一个单元。

\textbf{Proof} .我们对$|I| .$进行归纳 如果$|I|=1$ ，让$I=\left(d, d_{1}, d\right) .$ 让$c_{i} \in \mathcal{G}_{i}^{(0)}=P_{i}$和$c_{k} \in \mathcal{G}_{k}^{(0)}=P_{k}$在全局网格中，这样$\widehat{c_{k}} \in \mathcal{H}_{I}(\widehat{c})$。我们必须证明$c_{k}$在有限的$n=n(I)$步数内被复制到$\mathcal{G}_{i}$。

存在$\widehat{e}$，使得$\widehat{c}_{i}>\widehat{e}$和$\widehat{c_{k}}>\widehat{e} .$让$\mathfrak{e}=[\widehat{e}]$成为对应于$\widehat{e}$的商网元素。在商格中，有一条直接邻居的路径，从$\left[P_{i}\right]$通向$\left[P_{k}\right]$的星格$(\mathfrak{e})$ 。让这个路径成为$\left(P_{i}=P^{(0)}, \ldots, P^{(n)}=P_{k}\right)$ 。

单元 $c_{k}$ 将沿着这个路径被复制，从 $P_{k}$ 到 $P_{i}$ 。这是因为在每个部分$P^{(j)}$中，都有一个$\widehat{e}$的代表，因此它被所有这些单元所共享。因此，$c_{k}$在第一步被复制到$P^{(n-1)}$，而在$n$的第三步被复制到$P^{(0)}=P_{i}$。这里$n=n(I)$被两个部分$P_{i}, P_{k}$的最大距离所限定，这两个部分都入射到维度为$\geq d_{1}=\operatorname{dim} \widehat{e}$的同一个元素$\mathfrak{e}$，也就是$\operatorname{diam}(\operatorname{st}(\mathfrak{e}))$上。

现在的归纳步骤很容易。如果$|I|>1$，让$I=\left(I_{1}, I_{2}\right)$与$\left|I_{1}\right|,\left|I_{2}\right|<|I| .$组成船体$\mathcal{H}_{I}\left(\widehat{c_{k}}\right)$，包含$\widehat{c_{i}}$，也包含一个中间单元$\widehat{c_{m}} \in P_{m}$，从而


即$\widehat{c_{m}} \in \mathcal{H}_{I_{1}}\left(\widehat{c_{i}}\right)$ ，和$\widehat{c_{k}} \in \mathcal{H}_{I_{2}}\left(\widehat{c_{m}}\right) .$ 因此，$c_{k}$在$n\left(I_{2}\right)$步中被复制到$\mathcal{G}_{m}$，并在$n\left(I_{1}\right)$步中进一步复制到$\mathcal{G}_{i}$，从而也证明了$n(I)$ 的公式。

如果在一个步骤中没有发现任何部分的新元素，即$\mathcal{G}_{i}^{(k+1)}=\mathcal{G}_{i}^{(k)} \forall i$，那么在进一步的步骤中也不会发现任何新元素，算法就会终止。


\subsubsection{Determination of the Quotient Grid}

算法$5.4$确定了构成$\mathcal{G} / P .$元素的集合 为了证明算法的正确性，我们表明$5.5$中$\sim_{k}$的定义等同于只考虑次高维的事件元素。

$$
e_{1} \sim_{k} e_{2} \Longleftrightarrow\left[\mathcal{I}_{k+1}\left(e_{1}\right)\right]=\left[\mathcal{I}_{k+1}\left(e_{2}\right)\right]
$$

\textbf{Proof} .我们需要证明$\left[\mathcal{I}_{k+1}\left(e_{1}\right)\right]=\left[\mathcal{I}_{k+1}\left(e_{2}\right)\right]$意味着$\left[\mathcal{I}_{n}\left(e_{1}\right)\right]=\left[\mathcal{I}_{n}\left(e_{2}\right)\right]$的高维$k+1 \leq n \leq d$。对于$k=d-1$来说，这一点是微不足道的，通过对$l=d-k$的归纳，对所有$k$都是如此。

设$e_{1}, e_{2} \in \mathcal{G}^{k}$是这样的：$\left[\mathcal{I}_{k+1}\left(e_{1}\right)\right]=\left[\mathcal{I}_{k+1}\left(e_{2}\right)\right]$，并设$e_{1}^{n}>e_{1}$是维度为$n \geq k+2$的元素。因为$\mathcal{G}$的位置集是分级的，所以存在$e_{1}^{k+1}$'之间'。  $e_{1}^{n}>e_{1}^{k+1}>e_{1} .$ 根据$5.22$，存在$e_{2}^{k+1}>e_{2}$与$e_{1}^{k+1} \sim_{k+1} e_{2}^{k+1}$，通过归纳，对$\sim_{k+1}$采取定义$5.22$还是$5.5$都不重要。因此，有 $e_{2}^{n}>e_{2}^{k+1}$ 与 $e_{1}^{n} \sim{ }_{n} e_{2}^{n}$ 。这表明，$\left[\mathcal{I}_{n}\left(e_{1}\right)\right]=\left[\mathcal{I}_{n}\left(e_{2}\right)\right]$ .

如果商有笛卡尔网格的组合结构，那么 "跨越对角线的通信 "可以通过双边通信的巧妙排序来节省。这在图中显示 $5.4$ 。



在算法$5.4$的第4行中，我们可以通过只考虑那些位于分区$P_{i} .$边界上的面$e$，轻松地对$k=d-1$的情况进行优化，内部面无论如何都会在第10行被移除。为此，可以使用4.2.2.4节中介绍的边界迭代器。在第7行，闭合迭代器（第4.2.2.3节）对于访问元素集的所有低维元素很有用。

\subsubsection{Dynamic Grid Migration}

自适应算法产生局部修改的网格。因此，工作负荷可能变得不平衡；局部网格的一部分必须在进程之间迁移。

如前所述（第$5.3)$节），支持动态网格迁移所需的组件还没有完全开发。然而，一方面，必要的行动几乎可以完全隐藏在应用程序中，因此，我们的方法的优势--最小的侵入性--不会受到影响。

另一方面，正如我们将要指出的，许多工作可以通过我们前面介绍的 "标准 "组件来完成--或者至少可以大大缓解。

更具体地说，我们需要解决以下任务的组件，以支持动态网格迁移。

1.确定哪些大块的网格必须转移到其他部分

2.将网格块运送到其他部分

3.转移定义在被迁移块上的网格功能

4.从现有网格中切割出网格块

5.将一个网格块粘到另一个网格上。

6. 重新生成与分布式网格相关的额外数据结构，特别是重叠结构。

如前所述，第一个任务可以由现有的组件如PARMETIS [Kar99] 解决。

传输网格意味着一般的序列化/反序列化，这个问题主要由序列化表示的网格适配器 $(\rightarrow$ 第95页 $)$ ，以及半通用的复制操作 $(\rightarrow \mathrm{p} .93)$ 解决。4.1.6节中已经处理了切割和粘合网格块的任务。

转移定义在网格部分上的网格函数与静态同步的情况有些类似，但是，我们还必须跟踪本地网格块和它们的远程副本之间的关系。由于所有的复制/胶合操作都能保持源和副本之间的网格同构，这个问题可以通过结合所涉及的同构来解决。

最后，我们在第5.6.3节提出了一种分布式生成重叠的算法。

因此，原则上来说，动态网格的大部分必要成分都是可用的。然而，要把它们结合起来，还需要一些额外的工作。4

\subsection{Distributed Overlapping Grids - Generic Com- ponents}

前面几节介绍的大部分概念都顺利地映射到软件组件上。实际实施证实，网格微内核的功能确实是支持分布式网格概念的充分基础。因此，提供通用实现的目标可以实现；这些组件可以与任何实现接口的网格类型（基础网格）一起使用。在适当的地方，我们会指出特定组件对基础网格的要求。

在对给定的代码进行并行化时，保持内部数据表示不变是特别重要的，例如大型数值模拟，直接在这种具体表示上操作。一般来说，现有应用程序中使用的具体网格类型需要适应网格微内核，以提供所需的接口。这可以在额外代码的帮助下实现；特别是在不改变内部表示细节的情况下。在$6.4$节中，我们提出了一个详细的案例研究。

在$5.5 .2$节的开头已经指出，所开发的概念主要是在 "抽象分布 "层面上运作。分布的物理性质并不重要。以类似的方式，这些问题可以在大多数具体的组件中被抽象出来；细节在数据传输层中被分解出来，见图$5.9$和5.7.2节。

特别是，分布式网格和网格函数的基本特征可以被分解成共同的基础重叠网格和重叠网格函数，也见[Fig5.10]。对具体的物理分布的专门化是MPDistributedGrid（用于分布式内存和消息传递）和CompositeGrid（用于单一内存）。后者是一个相当有用的组件，它可以用于测试顺序设置中的算法，但也可以用于建立多块网格结构。对于重叠的网格功能也有类似的专门化。

有时，通过为特定情况使用专门的组件，特别是笛卡尔网格，可以获得巨大的收益。我们将在适当的地方指出这样做的可能性。

\subsubsection{Data-centered Components}

\subsubsection{Overlap Representation}

第5.5.2节中介绍的网格范围形成了一个逻辑序列，经常需要从中选择间隔，例如，对由共享和暴露范围组成的导出范围进行操作。原则上，我们可以使用第4.2.1节中介绍的标准网格范围，但为此目的创建一套新的组件更为经济。

\textbf{LayeredRanges} 这个组件在元素类型上是参数化的。由四个基本范围（private, exposed, shared, copied）形成的整个范围由一连串的元素句柄表示，而区间（基本以及派生范围，第120页）可以通过指示开始和结束位置来获得。

\textbf{Overlap} 重叠是在一个精细的基础网格和一个粗略的商数网格上进行参数化。它与商数的一个单元$P$相联系，并提供以下内容。

- 对商集的引用（或至少是对$P$的局部邻域的引用）。

- 对当地基础网格的参考

- 对于每个元素类型，在本地基础网格上的分层范围（总范围）。

- 对于每个元素类型，商数单元的映射到分层范围（双边范围）。

定义双边范围的映射可以很容易地通过商上的部分网格函数来实现。

严格来说，对商的引用在所有情况下都是不必要的，但是，如果根据商的属性进行特殊的优化（例如笛卡尔，见第121页），这个组件是需要的。

\subsubsection{Quotient Grid Representations}

原则上，我们可以为商使用一个足够普遍的网格组件，到现在为止，在具体实现中都是这样做的。

然而，对于一般的分区来说，这样的组件必须允许不相连的元素和有洞的元素，因此对于大多数其他情况来说过于笼统。

因此，提供一个实现分级位置集的数学概念的组件QuotientPoset是很有用的。这个组件可以通过使用从商数元素到细格子范围的网格函数，提供对细格子的基本实体的映射。

在某些情况下，一个更专门的组件来表示商将是有用的，例如，如果商是一个（伪）笛卡尔网格。那么，QuotientGenerator（第145页$)$）的专门版本也将是必要的。

\Distributed Grids and Grid functions}。

这些组件分为三层：重叠，包含重叠结构，但具有 "本地语义"；分布式，代表各部分的集合；全局，允许在逻辑全局网格上操作，例如在一台机器上收集数据。概述也见图$5.10$。

\begin{tabular}{lll}.
layer & grid components & grid function components （层和网格组件）。
\hline & & & ＆ ＆ ＆ ＆ ＆ ＆ ＆ ＆ ＆ ＆
Overlapping & OverlappingGrid (OG) & OverlappingGridFunction (OGF) （重叠和重叠网格(OG)） OGF
distributed & MpDistributedGrid (MpDG) CompositeGrid (CDG) & MpDistributedGridFunction (MpDGF)
& CompositeGridFunction (CDG)
\end{tabular}

\Overlapping grids / grid functions}。

\textbf{OverlappingGrid} (OG) 这个组件，就像重叠一样，是通过一个精细网格类型（或基础网格）和一个网格商数类型进行参数化。它由一个精细网格和一个重叠组成。对于应用算法的使用，它允许访问总范围和双边范围 $(\rightarrow$ p.119) 。局部范围类型的入射迭代器一般与基础网格的迭代器相同。

\textbf{Overlapping Gridfunction} (OGF) 重叠网格函数与重叠网格的关系就像普通网格函数与顺序网格的关系。一个OGF--通过元素类型和值进行参数化--包含一个本地网格函数和一个对重叠网格的引用。此外，它可以包含自己的范围，这些范围必须是其重叠网格的相应范围的子集。

\Distributed grids / grid functions}。

分布式电网不是一个具体的组件，而是一组组件的总称。正是在这里，分布的物理性质开始起作用。

每种类型的分布式网格都对应着一个分布式网格函数（DGF）。DGFs伴随着全局性的还原操作，如和、最小和最大。

\textbf{MpDistributed Grid} (MpDG) 一个消息传递的分布式网格在物理上是分布式的，所有对远程数据的访问都是通过像MPI这样的消息传递接口完成。商数的每个单元都有一个MpDistributed Grid，每个单元都生活在自己的进程中。除了重叠网格之外，一个MpDistributed Grid还包含一个网格商（或其足够的本地部分）。与重叠网格的区别在于，前者只代表局部部分，而MpDistributed Grid则代表分布在各进程中的整个网格。

在初始化时，必须做一些工作来将给定的网格商数拓扑结构映射到进程拓扑结构上。在MPI中，这可以通过调用MPI_Graph_create()来实现。

\textbf{Composite Grid} (CG) 该组件与物理分布式网格相反，包含所有重叠的网格，例如，通过使用网格函数将商数单元映射到重叠的网格，当然还有商数本身。

\textbf{MpDistributed Gridfunction} (MpDGF) 该类包含一个重叠的网格函数和通信处理程序列表，管理实际的数据传输。它们的主要附加功能包括方法`begin_synchronize()`和`end_synchronize()`，以实现全局一致的状态。此外，它们还可以通过指定共享范围的语义的缩减运算符进行参数化（除了元素和值）。默认情况下，那里没有必要进行数据交换。

对MpDGF的全局还原在逻辑上相当于对相关全局网格函数的还原。在MPI的情况下，它可以通过首先在正式拥有的$(\rightarrow$第120页）本地网格函数的部分进行计算，然后使用数据传输层提供的还原，它将封装一个MPI_Reduce（）例程。一般来说，只有在MpDGF处于全局一致的状态下，还原才有意义。

\textbf{Composite Gridfunction} (CGF) 一个复合网格函数包含一个对复合网格的引用和一个从粗单元到相应部分的重叠网格函数（局部网格函数）的映射。作为MpDGFs，它们提供了begin_synchronize()和end_synchronize()方法。

对CGF的全局还原是通过在所有局部网格函数上循环进行的，对正式拥有的元素进行还原，并将还原应用于每个部分的结果向量。

\ǞǞǞǞ全局网格/网格功能 }

全局网格是代表分布式网格的全局视图的抽象概念，定义见第118页。它们对于收集一个主站的信息是很实用的，或者，更广泛地说，对于将网格部分集中（和重新分配）在较少的进程上是很实用的。

全局网格函数与分布式网格函数的关系就像全局网格与分布式网格的关系一样。通常情况下，我们认为全局网格函数是不可改变的。

\textbf{MpGlobal Grid} (MpGG) 一个MpGlobal网格集中了MpDistributed网格的每个部分的信息。使用这种网格需要将分布式网格的远程部分传输到MpGlobal网格所在的进程中，以及传输网格部分双边边界上的识别信息。底层网格的数据结构可能与用于本地网格的数据结构相同。

\textbf{Composite Global Grid} （CGG）在复合全局网格的情况下，不需要为复合全局网格复制信息。相反，网格功能可以通过两阶段迭代器来实现，再加上一些额外的簿记数据结构。

\textbf{MpGlobal Gridfunction} (MpGGF) MpGGF收集来自MpDistributed网格函数的信息。它们包含对MpGlobal网格的引用，以及对前者的底层网格的网格函数。使用MpGGF使得从每个MpDGF传输数据成为必要，另外可能在共享元素上有所减少。

\textbf{Composite Global Gridfunction} (CGGF) 这些组件包含对复合全球网格的引用。像这样，不需要复制信息。

\subsubsection{The Data Transfer Layer}

数据传输的实际机制是取决于底层硬件的事情之一。对这些细节进行封装，可以使分布式网格功能等组件免于投入到一个特定的分布情况。

另外，这一层还隐藏了一些决定，比如是否对一个范围使用还原操作（例如对共享元素的加法，见第131页），甚至是否必须使用一些插值算法（对于过载网格）。

\textbf{MPITransferHandler} 数据是通过调用MPI的非block发送和接收操作来传输的。它的参数是本地范围的序列类型，以及一个可选的减少操作。

一个可能的扩展是接收方的映射，允许传递具有引用语义的数据。InCoreTransferHandler 在全局地址空间中，数据是通过简单的复制操作来传输的。参数化是由源和目标范围的类型决定的。

\textbf{InCoreBufferedTransferHandler} 数据是通过一个简单的复制操作，通过一个缓冲区来传输的。这对还原（在共享范围上）很重要，因为数据必须首先被复制，然后才可以用其他来源的数据进行还原改变。缩减的类型是一个额外的、可选的参数。

\textbf{MpGlobalReduction} 每个网格部分的一个数据项的全局还原是通过消息传递进行的。该组件通过数据的类型和缩减操作进行参数化。

\subsubsection{Algorithmic Components}

\textbf{Quotient generator}过程CoarseGridFromPartition将分区的网格作为输入参数，并从这些信息中构建一个网格商。对于二维的情况，实现了比表$5.4$中的算法更简单的算法。

如果要获得一个特殊类型的商（例如笛卡尔），必须使用一个特殊的实现。

\textbf{Hull generator} 程序IncidenceLayers需要一个网格$G$，一个区分内部和外部的谓词$I$$G$，一组$F$它输出一个分层单元范围$C$，它是由$S$从胚芽$F:$生成的 "内半壳"。

$$
C=\mathcal{H}_{S}^{G^{i}}\left(C_{F}^{o}\right)
$$

其中$G^{I}=\overline{\left\{c \in G^{d} \mid I(c)\right\}}$是$G$的 "内部 "部分，和

$$
C_{F}^{o}=\left\{c \in G^{d} \mid \exists f \in F: c \succ f \wedge \neg I(c)\right\}
$$

是指从$F$中的一个面所涉及的外部单元的集合。

这个组件建立在一些更简单的组件之上。网格范围通过掩盖网格的一部分来工作，部分网格函数用于标记被访问的元素，以及网板中发现的每一对 $(k, l)$ 的入射迭代器 $S$ 。

最后一个依赖性带来了一个有趣的编程问题，因为理想情况下，给定一个网格类型，INCIDENCE HULL的实现应该正好使用这些迭代器（并且能够处理相应的序列）。这可以通过向网格类型添加编译时的标志来实现，这些标志表明每个可能的迭代器类型的存在或不存在，并相应地构建算法。目前，我们只是假设CellOnCell、VertexOnCell和CellOnVertex的入射迭代器已经实现（见附录A.2.3及后），这对大多数FV/FEM算法来说已经足够了。

\textbf{Overlap generator} 过程ConstructOverlap接收一个分区网格$(G, P)$，相应的商$\mathfrak{G}$，和一个钢网$S .$，输出一个从$\mathfrak{G}$的单元格到上述重叠的映射。在内部，它的工作方式如下。

1.确定总的共享范围（分区网格的内部边界）。

2. 确定双边共享范围（同步！）。

3. 确定总的暴露和复制的范围（用IncidenceLayers）。

4. 确定双边暴露和复制的范围（同步！）。

增强版的ConstructOverlapPeriodic还允许处理周期性边界，由识别边界顶点的地图给出。

\textbf{Composite grid generator} 为了构建复合网格$C G$，程序ConstructComposite需要一个分区网格$(G, P)$和一个模版$S$。此外 $C G$ ，它还构建了本地和全局网格顶点和单元之间的映射。使用的算法如下。

1.构建与全局网格$O_{g}$相联系的重叠$G$，使用ConstructOverlap。

2. 从$(G, P)$中构建局部网格，用形态$\Phi_{l, g}$将$G$的一部分映射到局部网格。

3. 将重叠 $O_{g}$ 复制到局部重叠 $O_{l}$ ，使用形态 $\Phi_{l, g}$ 。

这个介绍不得不说得很简洁。对这些组件更详细的描述将在技术备忘录中公布。然而，从一个应用程序员的角度来看，这些组件中有许多并不直接相关。


\section{Practical Experience with the Generic Approach}

\subsection{Introduction}

本章的目的是提供案例研究，评估这项工作中提出的通用方法的效用--通用组件如何帮助构建真正的应用程序，以及它们在效率方面的表现如何？

为此，我们在数值PDE求解的背景下研究了几个具体的应用实例，这也是我们的出发点，并指导了本论文的整个思考。

为了显示该方法的广泛性和合理性，我们处理了相当不同类别的问题。因此，我们可以看到所使用的数值方法有很大的多样性。在这里，解决不同类型的PDEs的应用之间出现了本质的区别。

在第6.2节中，我们介绍了一类与物理流动现象有关的问题，并由双曲方程描述。用于解决此类问题的一大类算法是有限体积（FV）方法。

我们展示了一个通用的FV求解器是如何从各个算法部分构造出来的，从而产生了一个程序家族的核心。各个程序可能会有不同，其中包括解决的精确方程、用于空间离散化的算法、执行环境（顺序/分布式）和使用的数据结构（网格、几何）。这是一个例子，说明通用编程是如何在大范围内工作的。

另一方面，椭圆问题产生了一个不同的算法系列，即有限元方法（FEM），这将在第6.3节介绍。我们讨论了与多网格方法组件的通用实现有关的问题，这类算法特别适合于解决在有限元背景下出现的大型线性系统。特别是处理了分层网格的通用数据结构的问题。

重用通用组件并不意味着整个应用程序的设计和编写都要考虑到通用模式。相反，这些组件可以被现有的软件以一种渐进的方式使用。第6.4节中介绍了一个说明这种可能性的例子。在这里，通过使用第$5 .$章中描述的分布式网格组件，一个纳维-斯托克斯求解器被事先并行化了。

网格组件，特别是我们前面介绍的一组基本内核组件，只是数值模拟中实际需要的一部分。显然，不能为所有方面开发通用组件。

因此，很难通过给出重用代码的百分比来获得通用组件获得重用程度的量化措施。

然而，显而易见的是，满足不同应用需求的组件，如与网格相关的数据结构或可视化程序，确实可以 "现成 "重复使用，这也是第二章中提出的目标。

这样的重用需要底层网格类型符合微内核。对于在$6.2$和6.3节中讨论的新开发的应用程序来说，就是这种情况。对于现有的具有不同网格数据结构的应用程序，如$6.4$节，必须开发一个适应性，这是一个相当标准的任务，范围严格限制。在使用分布式网格组件进行并行化的情况下，这种相对较少的努力肯定会得到回报。

对于基于数值网格的组件，已经开发了通用组件，其中一些已经在不同的情况下成功地被重复使用。

一个完全不同的主题是使用通用组件所能获得的效率。为了评估这一方面，我们建立了一些小型的计算内核，并在$6.5$节中用来比较各种通用和非通用的实现。尽管结果必须谨慎对待，但它们清楚地表明，现代编译器技术已经接近一个点，可以消除由抽象层引入的开销。

\subsection{A Finite Volume Solver for the Euler Equations}

\subsubsection{The Mathematical Problem}

在一个域$D \subset \mathbb{R}^{2}$中的无粘性、可压缩、静止的流动由随时间变化的欧拉方程描述

$$
\boldsymbol{u}_{t}+f(\boldsymbol{u})_{x}+g(\boldsymbol{u})_{y}=0 \quad \text { in } \quad D
$$

以保守变量的状态向量$\boldsymbol{u}: D \times \mathbb{R}^{+} \mapsto \mathbb{R}^{4}$为例

$$
\boldsymbol{u}=(\rho, \rho u, \rho v, \rho E)^{T}
$$

其中$\rho$是密度，$(u, v)^{T}$是速度矢量，$E$是总能量；以及通量函数

$$
\begin{aligned}
f(\boldsymbol{u}) &=\left(\rho u, \rho u^{2}+p, \rho u v, u(\rho E+p)\right) \\
g(\boldsymbol{u}) &=\left(\rho v, \rho u v, \rho v^{2}+p, v(\rho E+p)\right)
\end{aligned}
$$

这里，压力$p=p(\boldsymbol{u})$通过热力学状态方程与状态$\boldsymbol{u}$相联系，例如

$$
p(\boldsymbol{u})=(\gamma-1)\left(\rho E-\frac{1}{2} \frac{(\rho u)^{2}+(\rho v)^{2}}{\rho}\right)
$$

对于一个理想的、多变的气体。方程（6.1）必须由一个初始条件来补充

$$
\boldsymbol{u}(x, y, 0)=\boldsymbol{u}_{0}
$$

此外，还需要在$\partial D$上设置边界条件。这是一个困难的话题，因为这些条件的确切性质取决于流动的具体物理学。最重要的三种类型的边界条件如下。流入边界条件，其中（部分）流动变量被规定，流出边界条件，其中没有规定任何变量或部分变量被规定，以及实壁边界条件，其中流动被要求与边界相切。

欧拉方程是守恒定律的一个例子。它们表达了质量、动量和能量的守恒。在考虑积分表述时，可以更好地看到这一点，通过对任意体积的积分得到 $\Omega$ 。

$$
\begin{aligned}
& \int_{\Omega} \boldsymbol{u}_{t} d V+\int_{\Omega} f(\boldsymbol{u})_{x}+g(\boldsymbol{u})_{y} d V \\
=& \frac{\partial}{\partial t} \int_{\Omega} \boldsymbol{u} d V+\int_{\partial \Omega} f(\boldsymbol{u}) n_{x}+g(\boldsymbol{u}) n_{y} d s
\end{aligned}
$$

其中$\vec{n}=\left(n_{x}, n_{y}\right)^{T}$是$\Omega .$的外向法线 积分$\int_{\Omega} \boldsymbol{u}_{t} d V$表示守恒量$\boldsymbol{u}$的时间变化，而$\int_{\partial \Omega} f(\boldsymbol{u}) n_{x}+g(\boldsymbol{u}) n_{y} d s$是$\boldsymbol{u}$穿过$\Omega$边界的通量。$\boldsymbol{u}$随时间变化的守恒量由两个积分相加为零的事实来表示。

公式$(6.5)$不仅使人们了解了这些方程的物理起源，而且还导致了一类重要的数值方法来解决它们，即有限体积方法（FVM），这将在第6.2.2节讨论。欧拉方程是双曲的。矩阵

$$
A(\boldsymbol{u}, \vec{n})=f(\boldsymbol{u}) \boldsymbol{u} n_{x}+g(\boldsymbol{u}) \boldsymbol{u} n_{y}
$$

对每个状态$\boldsymbol{u} \in \mathbb{R}^{4}$和每个方向$\vec{n} \in \mathbb{R}^{2}$都是可对角化的，具有实数特征值。此外，通量$f$和$g$是1均质的，即

$$
f(\boldsymbol{u})=f_{\boldsymbol{u}} \cdot \boldsymbol{u} \quad \text { and } \quad g(\boldsymbol{u})=g \boldsymbol{u} \cdot \boldsymbol{u}
$$

这一点很重要，因为有些数值方法正是利用了这一特性，或者反过来说，可以对具有这一特性的方程进行一般性的表述。

双曲方程的一个特点是，它们可能有不连续的解。例如，这种现象发生在超音速飞机的突然爆炸中。

同时，它们表现出信息流的有限速度，这一点最好通过考虑标量平流方程与 $f(u)=a u$ 来理解。

$$
\begin{aligned}
u_{t}+a u_{x} &=0 \quad a \in \mathbb{R} \\
u(x, 0) &=u_{0}(x)
\end{aligned}
$$

它的分析解是

$$
u(x, t)=u_{0}(x-t a)
$$

这意味着轮廓$u_{0}$以速度$a$进行平流。作为一个线性双曲方程，平流方程也是同质的。线性双曲系统也是如此，它在二维中的形式为

$$
\boldsymbol{u}_{t}+A \boldsymbol{u}_{x}+B \boldsymbol{u}_{y}=0
$$

双曲守恒定律的其他例子（尽管不是同质的）是标量布尔格斯方程或浅水方程。

\subsubsection{Finite Volume Algorithms}

\The Finite Volume Idea}。

从公式（6.5）中，我们可以推导出数值求解欧拉方程的方法，以及其他双曲守恒定律。

首先，我们必须选择覆盖所考虑的几何领域的控制体$\Omega_{i}, 1 \leq i \leq N$。这是通过选择一个适当的网格来完成的，其单元作为控制体。另一种可能的方法是使用一个给定网格的对偶来控制体积，这样就有一个体积对应于原始网格的每个顶点。

其次，有必要对$(6.5) .$的积分进行近似 未知解$\boldsymbol{u}$由单元格常数$\boldsymbol{u}^{i}$表示，近似于真实解的积分手段。积分手段是对函数的一种保守的近似。那么我们可以通过以下方式来近似第一个积分

$$
\frac{\partial}{\partial t} \int_{\Omega_{i}} \boldsymbol{u} d V \approx\left|\Omega_{i}\right| \frac{\partial}{\partial t} \boldsymbol{u}_{i} \quad 1 \leq i \leq N
$$

(这里$\left|\Omega_{i}\right|$是$\left.\Omega_{i} .\right)$的体积）这导致了半分解系统

$$
\begin{aligned}
\frac{\partial}{\partial t} \boldsymbol{u}_{i} &=-\frac{1}{\left|\Omega_{i}\right|} \int_{\partial \Omega_{i}} f(\boldsymbol{u}) n_{x}+g(\boldsymbol{u}) n_{y} d s \\
&=: \quad-\frac{1}{\left|\Omega_{i}\right|} \mathcal{F}^{i}(\boldsymbol{u}) \quad 1 \leq i \leq N
\end{aligned}
$$

这是在$N$中的一个$t$常微分方程系统。我们推迟决定如何对$\boldsymbol{u}$进行时间离散化的问题。

\subsubsection{First Order Upwind Discretization by Flux Vector Splitting}

$6.5$的第二个积分是更复杂的部分。由于近似解是以单元常数的方式表示的，所以单元边界上的通量函数的积分不是很明确。有几种处理这种情况的可能性，其中之一是上风通量-矢量分割（FVS）方法。

上风方法的动机是观察到信息的物理流动是有方向的。场内某处的干扰会影响下游的位置，而不是上游的位置。

这从标量平流方程$(6.6)$的精确解$u(t, x)=u_{0}(x-t a)$中很容易看出。如果$a>0$，初始轮廓$u_{0}$向右传输，如果$a<0$，向左传输。因此，$u_{0}$在$x_{0}$处的干扰将只影响'下游'位置$x>x_{0}$（如果$\left.a>0\right)$，或者反过来说，一个位置$x$只受到左侧（'上游'）信息的影响。

我们可以尝试在我们的数值方法中模仿这种信息流，从而指导如何定义细胞边界上的通量的决定。在一维中，控制体积$\Omega_{i}$是区间$\left[x_{i-1 / 2}, x_{i+1 / 2}\right]$，见图$6.1 .$ 如果我们试图评估积分

$$
\int_{\Omega_{i}} f(\boldsymbol{u})_{x} d x=\int_{x_{i-1 / 2}}^{x_{i+1 / 2}} f(\boldsymbol{u})_{x} d x
$$

我们看到，正如已经指出的，$f$在$x_{i-1 / 2}, x_{i+1 / 2}$点上没有定义，因为使用积分手段导致$u$的跳动，见[Fig6.1]。因此，我们用一个取决于左单元状态$u_{l}=u_{i-1}$和右单元状态$u_{r}=u_{i}$的数值通量函数$F\left(u_{l}, u_{r}\right)$取代单元边界$f$。

对于一维的、标量的、线性的情况，该怎么做就很直接了。在单元格边界，如果$a>0$，我们将$F\left(u_{l}, u_{r}\right)$设为左值$u_{l}$，否则设为右值$u_{r}$。形式上，这可以写成$F\left(u_{l}, u_{r}\right)=a^{+} u_{l}+a^{-} u_{r}=: f^{+}\left(u_{l}\right)+f^{-}\left(u_{r}\right)$ ，其中$a^{+}=\max (a, 0), a^{-}=\min (a, 0) .$ 换句话说，我们把通量矢量$f$分成正负两部分。

$$
f(u)=f^{+}(u)+f^{-}(u)
$$

从一个单元$C=\Omega_{i}$出来的总数值通量由以下公式给出

$$
\int_{\Omega_{i}} f(u)_{x} d x \approx F\left(u_{i}, u_{i+1}\right)-F\left(u_{i-1}, u_{i}\right)
$$

我们可以把这个量看作是一维单元所有面的外向通量的总和$C=\left[x_{i-1 / 2}, x_{i+1 / 2}\right] .$我们将在下面看到这个表述如何轻松地推广到更高维度。在边界上，我们可以使用人工邻接（ghost cell），或者直接在面上定义一个通量。


如果线性系统是可对角的，我们可以将该方法扩展到线性系统。在这种情况下，该方程由以下公式给出

$$
\boldsymbol{u}_{t}+A \boldsymbol{u}_{x}=0
$$

有一个可对角的$p \times p$矩阵$A=K \Lambda K^{-1}$ ，其中$\Lambda=\operatorname{diag}\left(\lambda_{1}, \ldots, \lambda_{n}\right)$ 。对角线矩阵$\Lambda$可以被分解成一个正部分

$$
\Lambda^{+}=\operatorname{diag}\left(\lambda_{1}^{+}, \ldots, \lambda_{n}^{+}\right)
$$

和一个负的部分 $\Lambda^{-}$ 。相应地，我们定义$A^{+}=K \Lambda^{+} K^{-1}$和$A^{-}=$$K \Lambda^{-} K^{-1}$，以及上风通量

$$
F\left(u_{l}, u_{r}\right)=A^{+} u_{l}+A^{-} u_{r}
$$

在非线性但同质系统的情况下，我们有 $f(\boldsymbol{u})=A(\boldsymbol{u}) \boldsymbol{u}$ ，与 $A(\boldsymbol{u})$ 雅各布 $f_{u}(\boldsymbol{u})$ ，并且我们可以使用分割 $f^{\pm}(u)=A^{\pm}(u) u$ 。对于数值通量的评估，我们必须决定在哪里评估导数 $A(\boldsymbol{u}) . \mathrm{A}$ 可能的选择，由于STEGER和WARMING（见 [Hir90] ），是

$$
F\left(u_{l}, u_{r}\right)=A^{+}\left(u_{l}\right) u_{l}+A^{-}\left(u_{r}\right) u_{r}
$$

到目前为止的讨论适用于一个空间维度的情况。对于更高的维度，我们假设单元由多面体给出，这样，单元边界上的积分由其（平面）面的积分之和给出 $e$ 。

$$
\begin{aligned}
& \int_{\partial \Omega_{i}} f(\boldsymbol{u}) n_{x}+g(\boldsymbol{u}) n_{y} d s \\
=& \sum_{e \prec \Omega_{i}} \int_{e} f(\boldsymbol{u}) n_{x}+g(\boldsymbol{u}) n_{y} d s \\
\approx & \sum_{e \prec \Omega_{i}}|e|\left(f_{\boldsymbol{u}}(\boldsymbol{u}) n_{x}+g \boldsymbol{u}(\boldsymbol{u}) n_{y}\right) \boldsymbol{u}
\end{aligned}
$$

这里$\vec{n}=\vec{n}(e)=\left(n_{x}, n_{y}\right)$表示面$e$的（恒定）外向法线，如上所述。以$A_{e}(\boldsymbol{u})=f \boldsymbol{u}(\boldsymbol{u}) n_{x}+g \boldsymbol{u}(\boldsymbol{u}) n_{y}$为例，我们又回到了一维的情况，面的法线通量为$f_{e}(\boldsymbol{u})=A_{e}(\boldsymbol{u}) \boldsymbol{u}$，也见[Fig6.2]。总而言之，所产生的数值通量是

$$
F_{e}\left(u_{C}, u_{N}\right)=A_{e}^{+}\left(u_{C}\right) u_{C}+A_{e}^{-}\left(u_{N}\right) u_{N}
$$

其中$u_{C}$是$\Omega_{i}=C$中的状态，$u_{N}$是与$e$相邻单元的状态，再看[Fig6.2] .

关于这个方法和相关方法的更多细节，见例如 [Tor97] 或 [Hir90] 。另一种获得跨细胞边界通量的方法是GODUNOV的方法。由于细胞两侧的状态是恒定的，原则上可以计算出沿面的精确解，并从中推导出通量，例如见 [Tor97] 或 [LeV92] 。

\subsubsection{Second Order Method by Recovery and Limiting}

在空间获得高阶方法的一种可能性是在计算通量之前对细胞状态应用一些平均（恢复）方法$U$。为了避免在不连续点附近的振荡，在高梯度存在的情况下，该过程必须被压制。何时发生这种情况由一个所谓的限制器来决定。

我们通常从计算顶点的体积平均数开始，收集所有入射单元的状态。这个过程在算法$6.2$中有更精确的描述（分布式情况）。

下一步是根据这些值确定一个近似函数，通常是一个多项式。在最简单的情况下，这只是每个单元的一个线性或双线性图。根据限制器函数的值，我们再取恢复函数的值或上述$u_{C}, u_{N}$的原始值。关于这个话题的进一步细节可以在 [Son93] 或 [Wie94] 中找到。

\subsubsection{Time Discretization}

到目前为止，我们有半具体化的系统

$$
\frac{\partial}{\partial t} \boldsymbol{u}_{i}=-\frac{1}{\left|\Omega_{i}\right|} \mathcal{F}^{i}(\boldsymbol{u}) \quad 1 \leq i \leq N
$$

其中$\mathcal{F}^{i}(\boldsymbol{u})$是单元$\Omega_{i}$的数值通量和。这是一个$N$的常微分方程系统，因此我们原则上可以使用许多方法来解决这样的系统。最简单的选择是显式欧拉方法，这将导致

$$
\boldsymbol{u}_{i}^{n+1}=\boldsymbol{u}_{i}^{n}-\frac{\Delta t}{\left|\Omega_{i}\right|} \mathcal{F}^{i}\left(\boldsymbol{u}^{n}\right) \quad 1 \leq i \leq N
$$

由于稳定性的原因，对可接受的时间步长有限制 $\Delta t$ 。$C F L-$条件规定，数值方法的依赖域包括方程的物理依赖域。数值方案中的信息必须包括影响物理流的信息。对于标量平流方程，这导致了

$$
|a| \Delta t \leq \Delta x
$$

其他合理的选择是中等阶数的显式Runge-Kutta方案。

隐式方案避免了对时间步长的限制，但更难实现，因为在这种情况下必须解决一个非线性方程组。当人们对稳态解感兴趣，或者问题非常僵硬，以至于显式方法需要非常小的时间步长时，隐式方法就变得有吸引力。

整个算法，包括时间离散化，由算法 $6.1$ 给出。



\subsubsection{A Program Family for Solution of Hyperbolic Equations}

任何用于解决上述类型的PDEs的软件的核心组件是一个有限体积求解器。它的任务是通过网格将几何域分解成有限体积，控制单个算法片段的合作，并管理几个这样的组件共享的数据结构。

我们将这些组件分为两个主要组别。第一，描述数学问题的组件，第二，实现数学问题的数值解的组件。此外，完整的应用程序还需要其他类型的组件，在6.2.3.4中简要讨论。

第一组包含代表方程、边界和初始条件以及几何域的实体。第二组包含，除其他外，网格和网格几何的表示，空间和时间离散算法，以及模拟状态。

为了利用泛型编程的力量，这些子组件中的大多数都是求解器组件的参数。然后，实际的程序往往采取BATORY[Bat95]所使用的 "类型方程 "的形式，所有这些 "松散的末端 "被绑在一起。结果是整个程序家族（这个术语由PARNAS[Par76]创造）。下面将讨论一些变化的参数；有些参数仍然隐含在实际代码中。

\subsubsection{Components Representing the Mathematical Problem}

一般来说，这些组件包含与问题的分析、数学描述相对应的信息。很常见的是，这些信息没有被明确，而是隐含在代码中，因此违反了 "责任定位 "的原则。

例如，一个代表双曲方程的类包含状态向量的维度（在二维欧拉方程的情况下为四维），不同物理量之间的转换方法，以及通量函数的导数。在应用FVS算法的情况下，方程部分可以被专门化，以额外提供相应的分割（6.12）。仔细观察还可以发现，被称为欧拉方程的实体实际上是一个方程系列，取决于材料（气体）参数和热力学状态方程，见例如 [Tor97] 。

方程组件不仅可以用于数值离散，还可以用于可视化目的，即必须从状态向量中提取不同的标量或矢量值的物理量 $u$ ，见下文（第160页 $) .$ 因此，它可以保护可视化系统不致力于特定的方程式。

具体成分已经实现了线性平流、欧拉方程（对于理想气体）和双成分气体通量，这是一个扩大的欧拉方程系统，见 $[\mathrm{SBB} 97]$ 。

表示几何领域的组件并不简单--整个几何建模的分支都在关注这个话题。

然而，在数值求解器中直接使用的关于域的信息并不多。大多数信息是以间接方式使用的，即通过生成的代表域的网格和附加在域的两侧的边界条件。这些必须被传递给离散的网格实体，以接近分析域。网格生成问题 "是指从 "分析 "域到相应的网格表示的过程。这是一个非微妙的过程，没有令人满意的标准程序存在。因此，我们在这里把它当作一个实体。一个 "网格化领域 "的抽象封装了从领域中生成网格的方式，同时保持了领域和网格之间的紧密关系。这种关系是必要的，因为一般来说，对网格的改变（例如细化）必须与域保持一致（边界顶点必须在域的边界上，等等）。

这种封装的优点是可以为专门领域使用特殊的生成器，例如逻辑方格。一个轻微的缺点是，它打破了问题级组件（几何域）和解决方案级组件（网格）之间的分离。

\Subsubsubsection{数值解法的组件}。

现在我们来看看PDE求解器应用的核心--网格和网格几何的组件，时间和空间离散，可能还有（线性或非线性）方程求解器。

前面已经详细讨论了网格和几何形状。对于离散化部分，单元类型是一般的还是限制的，例如三角形，可能很重要。关于网格的几何形状，一个重要的优化包括计算经常使用的数量，如单元体积，一劳永逸。如果数字组件始终使用网格几何来访问这些数量，这些决定将保持完全本地化和透明。

FV求解器最重要的求解组件是空间离散化。一般来说，这些离散化取决于方程（数学和计算特性）和网格（主要是计算特性）。在上面讨论的FVS方法的情况下，方程必须具备同质性的特性。对于这样的方程，我们可以实现通用的FVS组件，对方程有如下要求。

- 状态类型的定义$(\boldsymbol{u})$，几何坐标$(x)$，以及导数。

- 对给定的几何方向（面的法线）$A_{n}^{\pm}(\boldsymbol{u})$和状态$\boldsymbol{u}$进行评估。

- 各种边界条件下的通量转换

\サイトブランドでは、平行化によることがあります。

通过应用$5 .$章中提出的概念和组件，得到了一个并行运行的求解器版本。主要的劳动包括确定算法的全局循环，确定相应的局部函数的模板，并决定哪些网格函数必须分布。在分布式网格函数的情况下，同步操作必须在正确的地方调用。

在具有显式时间积分的有限体积算法的情况下，所有这些都相当简单，只影响到几行代码，即顶点平均数的计算（见6.2），每个单元恢复函数的计算，涉及通量计算的时间积分$6.1$ ，以及时间步长的计算，这涉及一个全局最大值。与顺序算法的唯一区别是在局部范围而不是整个网格上的循环，以及之后的同步操作。

顶点平均操作的模版由图$6.4$给出，通量计算的模版由图$6.3$给出。通过$(5.17)-$或简单的检查--我们看到由顶点平均产生的模版支配着通量计算的模版。因此，我们可以安全地使用前者来确定全局重叠，参见$127 .$页的定理5。

这适用于我们使顶点平均数、恢复函数系数和单元格状态的网格函数全部分布的情况。如果我们只想要最小数量的分布式网格函数，我们只让单元格状态分布。在这种情况下，我们必须添加其他网格函数的模版。对于一个单元的通量，我们必须访问每个邻居的恢复函数，为此，要访问该邻居的每个顶点的平均数，因此，要访问每个这样的顶点所附带的每个单元。这就导致了图$6.5 .$中的模版，只有在时间积分后才需要同步，代价是增加局部工作。

很明显，顺序的情况只是分布式情况的一个特殊情况。因此，我们可以在两种情况下使用相同的通用求解器类，通过类型参数控制生成的版本。其优点与任何参数化都是一样的。只有一个版本需要维护和调试，代码是分布式还是顺序式的决定集中在一行上。

\subsubsection{User Interaction}

如前所述，当人们想获得实际可用的数值模拟时，还有其他方面的问题。这里我们特别提到数据可视化（也称为后处理）和运行时参数控制。

从纯数学算法的角度来看，这些方面可能是边缘性的，但它们对于程序在 "外部世界 "的外观和可用性是决定性的。因为它们确实与算法内核有些正交，我们希望将它们与后者干净地分开。如果做得好，就有可能交替使用各种可视化系统，甚至并行使用，或者在不同的情况下使用不同的参数控制技术（例如，批处理或交互式运行）。这样的灵活性对实际工作的好处怎么估计都不为过。

然而，实现这种解耦并不是那么简单的事情。我们在实践中想要控制的大多数参数都属于算法领域，而要可视化的数据正是由算法产生的数据，所以这些项目必须以某种方式被暴露。

我们在此不详细处理这些话题。参数控制是使用面向对象的技术完成的，并在另一篇技术论文中描述 [Ber98] 。其中介绍的技术也被证明对SUPEA项目（能源和推进系统的过程模拟，[BBK99][BK98]）中实现的基于二进制组件的框架有用。

现在我们将对可视化做一些简单的评论。后处理与数值模拟的成功脱钩，主要取决于模拟数据对可视化组件的清晰阐述。后者必须能够访问仿真数据（状态矢量）和底层网格。幸运的是，我们已经拥有了关于这些东西的标准术语--本工作中开发的网格微内核。

因此，我们可以简单地说，模拟是一个提供几何网格（序列）和该网格上的函数（序列）的组件。可视化组件采用这一系列的网格函数，并从中产生图形输出。通常情况下，由数值算法产生的数据不是人们想要看到的。例如，在保守变量的二维欧拉方程的情况下，人们有一个四个变量的状态向量

$$
\boldsymbol{u}=(\rho, \rho u, \rho v, \rho E)
$$

我们必须从中计算出有趣的量，如方程（6.2）中的压力。如前所述，这些函数的集合以一种自然的方式被封装在方程对象中。它保护了具体的可视化组件，使其不至于致力于一个特定类型的方程。这样的解耦已被用于开发Visual3库[Hai91]的通用包装器，允许以最小的努力使用这个非常有能力的后处理工具。该库要求用户提供一组函数，所有这些函数都可以在网格和方程上通用地实现。

\subsection{A Prototype Finite Element Solver for Elliptic Problems}

受椭圆方程支配的物理问题表现出的行为与受双曲方程支配的问题完全不同。这种差异被传递到数值方法中。

\subsubsection{The FEM approach}

椭圆问题的原型是泊松方程。

$$
\begin{aligned}
-\Delta u &=f \text { on } \Omega \\
u &=0 \quad \text { on } \quad \Gamma=\partial \Omega
\end{aligned}
$$

方程的这种形式被称为经典方程，而解$u$是经典解。

通过将$(6.18)$与在边界$\partial \Omega$上消失的函数$v$相乘，并应用部分积分，我们可以得到弱或变异的表述。找到$u \in H_{0}^{1}(\Omega)$，使得

$$
a(u, v):=\int_{\Omega} \nabla u \nabla v \mathrm{~d} \Omega=\int_{\Omega} f v \mathrm{~d} \Omega \quad \forall v \in H_{0}^{1}(\Omega)
$$

这里$H_{0}^{1}(\Omega)$是在$\partial \Omega$上消失的函数空间，其广义第一偏导数在$\Omega$上是可平方整数。

公式（6.20）直接导致了有限元方法。空间$H_{0}^{1}(\Omega)$被一个有限维空间$V \subset H_{0}^{1}(\Omega)$所取代，$u$以及$v$只在这个子空间内变化（GALERKIN方法）。

通常，空间$V$是通过使用网格将域$\Omega$分解成单元$c_{i}, 1 \leq i \leq N$，并采取定义在单元上的分片多项式$\phi_{j}$来构建的。

最简单的这种空间由单元上的片状线性函数组成，因此必须是单轴。对于每个顶点$v_{j}$，帽基函数$\phi_{j}$在$v_{j}$上取值为1，在所有其他顶点上取值为0，并且在每个单元上都是线性的。这个基的一个基本特征是$\phi_{j}$的小支持，它等于星形$\left(v_{j}\right)$（见第48页）。一般来说，给定$\left(\phi_{j}\right)_{j=1}^{M}$的基础$V$，我们可以写出$u=\sum u_{j} \phi_{j}, v=\phi_{k}$，然后评估

$$
\sum_{j=1}^{M} \int_{\Omega} u_{j} \nabla \phi_{j} \nabla \phi_{k} \mathrm{~d} \Omega=\int_{\Omega} f \phi_{k} \mathrm{~d} \Omega \quad 1 \leq k \leq M
$$

通过设置来定义刚度矩阵$A$。

$$
a_{k j}=\int_{\Omega} \nabla \phi_{j} \nabla \phi_{k} \mathrm{~d} \Omega
$$

导致了线性系统

$$
A u=f
$$

为$u_{i}$，其中$f_{k}=\int_{\Omega} f \phi_{k} \mathrm{~d} \Omega .$由于$\phi_{j}$有一个小支持，矩阵$A$是稀疏的。$(6.22)$中的大多数积分都消失了。

因此，使用有限元方法解决$(6.20)$的算法包括两个基本部分。

1.通过评估$A$中的积分，组装刚度矩阵$(6.22)$。

2.求解系统（6.23）。

解决这样大的线性方程组（在$3 \mathrm{D}$中可能有多达一百万个未知数）是算法中计算要求最高的任务。因此需要高效的方法。多网格方法在这里特别适合，因为它们在解决稀疏线性系统方面具有最佳的复杂性。

关于线性有限元的矩阵装配程序的简图可以在第68页找到。对于更复杂的元素，涉及更高的度数的多项式，这个过程会相当复杂，有必要明确使用与单元原型相关的局部坐标信息（见第56页）。

这一论述是强行简略的；关于理论和数值方法的更多细节，见例如[GR94] 。

\subsubsection{ A Multigrid Algorithm }

在$1960 \mathrm{~s}$和$1970 \mathrm{~s}$（[Fed64][Bra73]，也见HACKBUSCH[Hac85]的专著）期间发明的多网格算法是GAUSS时代以来对线性方程组求解的最重要贡献之一。它允许在$O(n)$时间内求解带有$n$未知数的$(6.23)$类型的稀疏线性系统，这显然是最优的。

其基本思想是，未知函数由不同长度尺度上的函数叠加来逼近。经典的迭代方法，如Jacobi或Gauss-Seidel迭代，只对减少一个固定长度尺度的误差有效。多网格方法结合了不同尺度上的迭代，从而实现了误差的快速整体减少。

假设在上述有限元方法的表述中，我们得到了一个网格层次$\mathcal{G}_{0}, \ldots, \mathcal{G}_{l}$，而不是一个单一的网格$\mathcal{G} .$，如果这些$\mathcal{G}_{k}$被适当嵌套，它们会产生一个函数空间的层次$V_{0} \subset V_{1} \cdots \subset V_{l} .$，在每个网格上，会产生一个线性系统$A_{k} u_{k}=f_{k}$，其中最细的网格上的系统是我们最终想要解决的。

从最细的网格上的一些近似值$u_{l}$开始，一些平滑步骤被应用到$u_{l}$（预平滑）。

然后，缺陷$d_{l}=A_{l} u_{l}-f_{l}$被限制到下一个更粗的层次，产生$d_{l-1}$。这只是意味着函数$d_{l} \in V_{l}$被一个函数$d_{l-1} \in V_{l-1}$所近似。

在那里，缺陷方程$A_{l-1} v_{l-1}=d_{l-1}$通过递归应用多网格方法来解决$v_{l-1}$，如果达到最粗的水平，则通过一些其他手段来解决。

粗网格修正$v_{l-1}$被延长到细网格，得到$v_{l}$，$u_{l}$被相应更新。  $u_{l}=u_{l}-v_{l} .$ 在我们的例子中，由于$V_{l} \supset V_{l-1}$，函数$v_{l-1}$已经在$V_{l}$中，只需要在更精细的基础上表达。

最后，我们对$u_{l}$应用一些后平滑的步骤。

该算法在算法表$6.3 .$中有所概述，它包含了需要解释的各种参数。映射$S_{1}$和$S_{2}$是平滑器，即系统$A_{k} x=f_{k} .$解的迭代方案，例如，这里可以选择雅可比或高斯-赛德尔迭代。这些平滑器分别应用$\nu_{1}$和$\nu_{2}$次。典型值为$\nu_{i}=1,2$ 。根据问题的性质，选择一个适当的平滑器可能对收敛速度有很大影响。

数字$\gamma$控制了多重网格方法的递归应用的数量。典型值是$\gamma=1$（V型循环）和$\gamma=2(\mathrm{~W}$-循环）。

最后，映射$R_{l}$（限制）和$P_{l}$（延长）是网格级别$l$和$l-1$之间的网格转移操作。限制$R_{l}$将较细网格上的函数映射到较粗网格上的函数，而$P_{l}$则进入反方向。

通常情况下，它们通过 $R_{l}=P_{l}^{T} .$ 的关系在所谓的加尔金方法中，这些映射被用来在更粗的层次上定义线性系统，通过设置 $A_{l-1}=R_{l} A_{l} P_{l}$ 。

上述的另一种标准方法是在更粗的层次上获得线性系统，即在更粗的层次上应用离散化。见[Hac85]，第68页关于这些方法的相对优点的讨论。

\subsubsection{Components for Multigrid Methods}

一个可重复使用的多网格方法的实现必须区分几个层次。首先，算法$6.3$中描述的一般方法适合于一个通用程序，上面提到的大多数部分都是参数化的。$u, A$的类型以及平滑器、延长和限制运算符都可以是参数。

其次，人们必须为所需的数据类型和网格间运算符（限制/延长）提供实现，以及与网格层次有关的相应数据结构。

第一部分相对简单，我们可以或多或少地直接将算法$6.3$翻译成编程语言。然而，将这样的组件作为一个类来实现是很方便的，以便让运行时参数由一个透明的机制来设置，就像上面提到的那样（第160页 $)$ 。

第二项任务需要考虑网格层次结构应该包含哪种类型的信息。像往常一样，这取决于要在网格层次结构上执行的算法。如果要对基于顶点的元素进行延长和限制操作，我们当然需要知道相邻层次的两个网格中哪些顶点是相互对应的。

延长的最简单的可能性只是使用函数空间$V_{l-1} \subset V_{l}$的包含，因此只需要计算更细的基础中的新表示。在红绿细化的线性有限元的情况下，水平$l$的新顶点只出现在水平$l-1$的边上，这只是意味着顶点$v \in \mathcal{G}_{l}$上的系数是其父辈的系数的平均值。这里，对应于较低层次上的边的顶点的父顶点仅仅是该边的两个附带顶点。对于一个已经存在于下层的顶点，我们正式将两个父顶点设置为下层顶点。相应的程序由算法$6.4$给出。

对于限制，我们可以采取$P_{l}$的邻接，从而得到算法6.5。另一个选择是注入，即简单地将粗网格顶点的值设置为相应的细网格顶点的值。新顶点上的值（对应于粗边）不被考虑。

一般来说，我们需要知道较细网格中的顶点相对于它们所包含的下一个较粗网格中的单元的局部坐标。所有这些信息都可以用标准的网格函数来表示。因此，无论需要的具体信息是什么，都可以保持与底层网格类型无关的表示。

此外，人们还需要用于生成网格层次的算法组件。

这项任务可分为三个子任务，即

- 在每个级别上选择要精炼（或粗化）的单元格

- 通过将每个细胞映射到一组细化的细胞，即代表细化的小网格模板，对有标记的细胞进行细化。

- 根据细化器定义的细化关系，更新网格层次结构

这种分解为三个子任务的做法有助于将数值方面（离散化和误差估计）、细化策略（选择包括二分法和基于模板的红绿细化）和网格数据结构的管理分离开来，封装了要存储的数据选择。

至于细化部分，已经开发了一个用于常规红绿细化（无粗化）的（初步）实现。细化网格是一个隐式定义网格的例子。迭代器是基于相应的粗网格，使用预定义的模板来定义细网格迭代器。

通过使用第4.1.6节中讨论的粗粒度突变基元，一个给定的网格可以通过用其精炼版本替换单元而被改变。或者，也可以创建一个新的层次。

为多网格方法开发的组件已成功用于建立一个使用线性有限元的泊松方程的原型 "概念验证 "求解器。在微内核的基础上开发了一个通用的分层网格数据结构，包含了根据算法$6.4$和$6.5$实现延长和限制操作的必要信息。

这个应用还没有被并行化。多网格（或一般来说，分层）方法的并行化是一项复杂的任务，因为除了第五章中讨论的水平邻接关系外，还必须考虑网格分层之间的 "垂直 "关系，例如见 [Bas94] 。已经提出了在较粗的网格上选择重叠的不同方法，例如 [Mit97] 。

\subsection{Parallelization of an Existing Navier-Stokes Solver}

\subsubsection{The Need for Dealing with Existing Code}

如果一个人开发和倡导新的编程概念，他往往处于一种永久的冲突之中。一方面，人们看到现有的软件可以用新的方法以更清洁的方式进行（重新）开发，产生更好和更强大的结果。

然而，从实用的角度来看，我们一般不能期望一个复杂的应用程序的所有部分都能在这种单一的方法下开发。首先，我们必须利用现有的、经过验证的软件，我们不能简单地丢弃它们。其次，即使开发了新的软件，也会有具有不同技能和背景的人参与进来。不能指望他们都能迅速地采用新方法的要领，这有时需要对旧习惯进行深刻的反思。

因此，新的软件开发方式与其他通常更传统的方法论共存，对其实际效用非常重要。其中一个特别正确的主题是并行程序的开发。很多时候，我们面临的情况是，一个给定的代码是为顺序架构开发的，后来才出现了将其并行化的需要。这是对实际有用的并行化方法的一个酸性测试。是否有可能将基本的编码与并行化分开？

在我们将要描述的具体例子中，在SUPEA研究项目中必须开发一个不可压缩的纳维-斯托克斯方程的并行求解器（见上文）。负责这项任务的同事不是并行处理的专家，也不应该参与到实际的并行化工作中。由于这个原因和其他一些原因，我们决定首先开发一个顺序版本的程序，然后在另一个步骤中进行并行化。

此外，第4章中描述的概念还没有完全详细地制定出来。因此，顺序代码的开发是完全独立于这项工作中所描述的想法而进行的。

\subsubsection{Mathematical Problem and Sequential Algorithm}

要解决的方程是不可压缩的粘性流动的纳维尔-斯托克斯方程

$$
\begin{aligned}
u_{x}+v_{y} &=0 \\
\rho u_{t}+\rho u u_{x}+\rho v u_{y} &=-p_{x}+\mu \Delta u \\
\rho v_{t}+\rho u v_{x}+\rho v v_{y} &=-p_{y}+\mu \Delta v
\end{aligned}
$$

这里$p$是压力，$(u, v)$是速度矢量，$\Delta$是拉普拉斯算子，$\rho$是恒定密度，$\mu$是恒定分子黏度系数。

使用的数值方法是SIMPLE压力修正法[FP99] 。这里，人们交替计算速度场和压力，直到$(6.24)$和$(6.25 / 6.26)$都得到满足。

具体算法是在网格顶点上存储速度场，在单元上存储压力值。衍生物由顶点和单元周围的等高线积分来近似。由此产生的速度和压力修正的线性方程组通过高斯-赛德尔迭代来解决。

\subsubsection{The Parallelization}

在开发代码的并行版本时，必须采取一个两阶段的方法。首先，与网格有关的数据结构必须由适配器类来包装，以符合网格微内核的语法。基于这个适配器，现在可以使用分布式网格的通用组件，见[Fig6.6]。

在第二步中，实际的并行化必须被执行。这需要识别全局循环和相应的网格函数，它们必须成为分布式的，就像上面描述的那样$(6.2.3.3)$。

这种并行化所需的努力比低级别的并行化要低得多，例如直接使用通信原语。第一部分，编写微内核的适配器，包含大约1-1.5$\mathrm{KLOC}^{1}$，听起来很多，但大部分是 "模板 "代码，另外还因为存在许多小类而变得臃肿。事实上，开发和验证这部分只花了$2-3$天。对于这样的改编，有一个标准化的测试策略在这里肯定是有帮助的。

第二部分的并行化工作只影响了几十行。在确定了全局循环和减法之后，直接插入必要的同步操作就可以了。

这些全局操作有时可能是隐藏的，特别是在C++这样的面向对象的语言中。例如，迭代求解器的一个步骤就是这样一个全局循环，之后可以进行同步。通常情况下，残余向量的规范被用来决定迭代的终止。但是，规范的计算本身当然是一个全局操作（还原）。因此，必须进行全局还原来计算全局残差的规范，否则不同进程的迭代将独立终止，导致错误的行为。

由于组件的相对新颖性和顺序代码本身的一些问题，要对第二阶段所需的净工作给出一个合理的估计并不容易，但肯定少于一个星期，与其他方法相比，这仍然是非常少。例如，BIRKEN谈到使用他的DDD库需要几个月的时间 [Bir98] ，并且还指出特别的方法需要相当多的时间，例如，有整个项目致力于单一的Navier-Stokes代码的并行化 $\left[\mathrm{LMR}^{+} 97\right]$ 。

为了公平起见。他们的代码比我们的大得多，$100.000$与$6.000 \mathrm{LOC}$相比（这无论如何是一个粗略的衡量标准）。但是，我们的方法的主要优势还是很明显的。它封装了实现这种并行化所需的大部分努力。

同样，我们的Navier-Stokes应用没有使用自适应特征和负载再平衡。然而，正如第5.6.5节所讨论的那样，这些操作几乎可以完全隐藏在并行应用中，因此，相对于顺序程序的复杂性，应该进一步减少并行化的努力。

考虑到对顺序算法的充分了解，我们认为--在适应了微内核之后--在几天之内实现并行化可能是现实的当然，这在很大程度上取决于所涉及的算法的数量，以及代码的结构和可读性。

\subsection{Efficiency Measurements}

\subsubsection{Some General Considerations}

正如第一章所指出的，科学计算中软件的一个主要质量衡量标准是效率。因此，任何方法，无论其优点是什么，最终都必须证明它不会妨碍软件的效率。

说到这里，也许有必要对这种说法的绝对性进行限定。首先，并不是每个应用程序都是同样的性能关键 - 这取决于要用软件解决的问题的典型规模和数量。通常，编码效率是一个比代码效率更严重的瓶颈。其次，即使在性能关键的情况下，通常只有整个程序的几个部分真正影响到整体效率。

因此，对效率的要求最好被看作是一个连续体，从对一些大量使用的内核（臭名昭著的是BLAS线性代数内核）的最大性能的追求到对更多外围组件的适度要求。不过，作为一条经验法则，对于任何在应用程序的大部分数据上运行的算法组件来说，严重的性能缺陷会造成伤害。

现在，将高性能和现代（主要是面向对象的）软件工程技术结合起来的一个成熟的方法是确定性能关键的内核，并使用传统的、低层次的技术来实现它们，比如FORTRAN子程序，见例如 [DPW93] 。

然而，我们的方法集中在高层次的、通用的算法实现上，可在广泛的背景下重复使用。因此，低级别的内核不能成为主要的选择，尽管如果真的有必要的话，这样做并不存在障碍。一般来说，使用低级内核是有代价的，因为它们限制了全局范围内的应用的通用性，像$6.2$节中描述的那些程序家族不能以这种通用性来实现。

因此，有必要在其效率方面对通用方法进行评估。当然，我们获得的定量结果需要谨慎判断。一般来说，基准高度依赖于环境（硬件、编译器）和基准内核的具体编码，这很少与实际应用的整体性能直接相关。

然而，人们可以从这些数据中读出一些一般的观察和趋势。A. STEPANOV创造了一个术语 "抽象惩罚"，即在较高的抽象层次上制定一些算法，并由一个自动工具（如编译器）将其翻译成较低层次的性能损失。这将表明，在一些非微不足道的情况下，这种惩罚是可以消除的。

最后，人们应该意识到这样一个事实，即较高的抽象水平可以有效地导致比相应的较低水平的软件更有效率。这只是与手工进行某些优化的实际限制有关。例如，在[VJ97]中，VELDHUIZEN描述了如何针对数据位置优化一个模板操作，如果每次都要重复这个操作，那么在编码方面的努力就会被禁止。同样地，像用于重叠计算和通信的compute-and-send-ahead（见第130页）这样的策略也可以被封装在高层循环模板中。

\subsubsection{Benchmark A: Calculating Vertex-Cell Incidences}

这个基准由一个解决以下问题的小循环组成：给定一个具有单元-顶点发生率的网格（即具有VertexOnCell Iterator $(\rightarrow$ p.207），如果它符合微内核的话），我们想为每个顶点计算与它相邻的单元的数量。这可以通过下面的代码片段来解决。

~~~C++
grid_function<Vertex,int> NumCells(Grid,0);
for(CellIterator c(Grid); ! c.IsDone(); ++c)
    for(VertexOnCellIterator vc(*c); !vc.IsDone(); ++vc) {
        NumCells[*vc]++;
}

~~~

该基准涉及间接寻址，在$\mathrm{C}$和FORTRAN版本中可以看到。这种类型的访问对于非结构化的网格计算是典型的，它可能限制了FORTRAN代码相对于其在$\mathrm{C} / \mathrm{C}++$中的等价物的速度优势，在BLAS中观察到的是简单内核。

这个算法的八个版本已经被测量。两个使用Complex2D网格类型的版本（一个带有迭代器，一个直接访问数据），三个使用更简单的Triang2D类型的版本（带有迭代器、unrolled循环和一个foreach循环模板），两个使用普通C数组的实现（一个unrolled）和一个简单的F77实现。基准循环的源代码可以在附录D中找到。

两个C++编译器被用来编译这个基准，即KAI KCC v3. 4 [Kuc99] 和GNU g++ egcs-1.1.2 [The00] on Linux 2.2.14。对于每一种，都测试了5-6种不同的优化选项。使用的Fortran编译器是$g 77$v0.$5.24$，基于egcs-1.1.2，使用的选项是-03 -fforce-addr -funroll-loops。

一些最具启发性的结果在图$6.7$至6.9中显示。从中可以得出几个结论。

- 在没有优化的情况下，性能是相当灾难性的，这是可以预期的。

- 总的来说，KAI的编译器做了非常好的优化工作，与g$++$和FORTRAN相比都是如此。事实上，在Triang2D网格中使用迭代器的开销被完全消除了！这有力地证明了编译器技术已经成熟到足以支持通用编程风格。这有力地证明了编译器技术已经成熟到足以支持通用编程风格。

- 通常情况下，数据布局比高/低层次的区别更重要。两个版本的Complex2D都明显落后，这是因为内存布局更加零散（关于使用的数据结构，见附录）。

\subsubsection{Benchmark B: Cell Neighbor Calculation}

这个基准比较了算法$3.2$的通用实现（见第222页以下）和GEOMPACK [Joe91]的FORTRAN实现。后者仅适用于三角形，而通用算法则适用于具有任意单元（简单多边形）的网格。通用实现的代码列在附录中。

当然，这种比较必须谨慎考虑，因为这两种实现方式有很大的不同。然而，两者都在内部使用了哈希表，所以性能应该有很大的可比性。

因此，我们看到GEOMPACK实现的性能差异约为$2-3$，对KCC和g++来说都是如此。然而，GEOMPACK程序有一个错误，不能用于$\geq 50.000$单元的网格，这个因素似乎随着网格大小的增加而减少。

目前还不太清楚这种差异的原因；通用实现本身使用了SGI STL[sgi96]的哈希表，这些哈希表还没有与GEOMPACK的特设哈希表进行单独比较。

\subsubsection{Benchmark C: Facet Normal Calculation}

这个基准测试了几何计算的性能。对于一个网格中所有单元的所有面，向外的面法线（与$2 \mathrm{D}$面本身的长度相同）被加起来。下面是通用代码。

~~~C++
coord_type normal(0,0);
for(CellIterator c(Grid); ! c.IsDone(); ++c)
    for(FacetOnCellIterator fc(*c); ! fc.IsDone(); ++fc)
        normal += Geom.outer_area_normal(fc);
// normal should be zero
~~~

测试了以下版本。两个版本的Triang2D的实现，一个是低级别的内部实现，一个是使用网格接口，两个版本使用低级别的访问Complex2D数据，三个版本使用数组作为几何体，一个使用存储在Complex2D类型网格中的连接信息，一个使用存储在数组中的连接信息，还有一个利用了每个单元是一个三角形的事实。最后，一个FoRTRAN程序作为计时的参考。

![](https://cdn.mathpix.com/cropped/c6acd6600cece86ac795772da75dd291-175.jpg?height=556&width=317&top_left_y=651&top_left_x=772)


当从可变单元类型的网格切换到固定单元类型（本例中为三角形）时，性能的提升是显著的。这里测试的两个编译器只有在高级的Triang2D代码上表现非常不同，KCC比$\mathrm{g}++$好3.5倍。一般来说，KCC的表现要比$1.5$好一些。KCC为Triang2D类生成的代码比$\mathrm{g}++$为普通数组生成的代码效率高一倍左右。

\subsubsection{ Final Remarks }

我们只比较了非常小的内核。一般来说，很难预测在这个层面上的差异对应用层面的性能有多大影响--这些内核测量的基本上是开销，因为没有进行昂贵的计算。

另一方面，比较完整的应用程序的性能面临着一个困难，那就是必须至少有两个应用程序--比如说，一个以通用风格编写的，一个以经典、高效的低级风格编写的--实现完全相同的算法，否则结果的意义将是值得怀疑的。在实践中，这将意味着对整个应用程序进行重新编码，这通常是不可行的。

最后还有一句话适用于C++编译器的性能。如果我们在两年前做同样的测量，比如说使用当时可用的GNU g++，结果会得出结论，通用组件在效率方面没有竞争力。

然而，情况已经发生了变化，编译器技术已经成熟，并且仍在继续发展。由于这个持续的过程，在所有可用的编译器和优化选项中总是挑选最好的C++结果是合理和公平的，因为一般来说，这能更好地接近真正的可能性。因此，用KAI编译器得到的结果表明，如果选择了正确的抽象，抽象的惩罚就会消失。

\section{Summary, Discussion and Outlook}

\subsection{Summary}

在这篇论文中，我们为在科学计算软件开发中使用新的、以算法为中心的通用编程方法奠定了基础。对于计算网格和网格算法这一核心领域，必要的分析、概念和计算问题已经被详细地解决了。

在第二章中，指出了目前在科学计算中使用的软件开发技术的缺点，特别是它们无法提供可重复使用的算法组件，这些组件独立于复杂的、不规则的数据结构（如非结构化网格）的表示问题。

作为将算法与数据表示的固有的、不可避免的差异脱钩的一个可能的解决方案，我们研究了通用编程的范式。

在第三章中，对网格进行了全面的领域分析，包括网格的数学方面，对网格算法的分析，以及对网格数据结构的计算方面和差异性的审查。对比算法的要求和网格表示的计算能力，确定了三个主要的功能类别。组合类、几何类和数据关联类。这为在网格算法和数据结构领域应用通用范式奠定了基础。

下一步是对基本概念进行更正式、更详细的描述，从而形成一个网格微内核（4.1节）。然后表明，一些通用的通用组件，如网格范围、迭代器或网格函数，可以基于这个微内核（第4.2节）。

接下来的两章（5和6）包含了对4.1节中奠定的基础进行更高级使用的例子。

第5章介绍了针对特定领域的网格并行计算的方法，使用了几何数据分区范式。分布式重叠网格的几个概念被导出，其中包括网格重叠的结构描述（第5.5.2节）。这种描述既接近心理学概念，又足以精确描述 "数据并行"、分布式算法的语义。非结构化网格上的算法的 "数据访问模式 "的概念以一种新的方式被形式化，在第3.1节开发的符号的基础上，为这类算法引入了模版。在后面的章节中，我们证明了关于这些模版的一些基本事实（第5.5.4节）。

此外，基于形式化模版，推导出高效确定重叠的算法，从而将重叠的产生与具体的算法解耦（第5.6.2和5.6.3节）。

这些算法和前面提到的分布式网格概念所产生的数据结构是使用通用范式实现的，从而实现了基本的、顺序的网格数据结构的独立性。这个实施方案提供了通用范式在一套复杂组件上的广泛应用，包括算法和数据中心，以一种非常可重用的方式解决一个高度非琐碎的问题。

在第6章中，我们使用数值PDE解决方案的不同应用来评估通用方法。为了评估其合理性和广泛性，我们改变了问题的类型（椭圆和双曲方程）、算法的原型（有限元和有限体积方法）以及整体编程范式。我们详细讨论了两个完全按照通用方法开发的应用（第$6.2$和$6.3$节），以及在一个现有应用中选择性地使用通用组件（第6.4节）。在这里，一个纳维-斯托克斯求解器使用第五章中开发的组件进行了并行化。最后，使用一些小的计算内核对通用组件的性能进行了评估（第$6.5)$节）。

\subsection{Discussion}

据笔者所知，这是第一次成功地尝试为基于网格的算法创建完全独立于具体网格数据结构的可重复使用的组件。这一步使算法的发展与表示问题脱钩，必须被认为是一个决定性的进展。

使用本工作中开发的方法进行的算法开发，将比基于特定数据布局的组件具有更广泛的重用潜力，这也是目前的普遍做法。目前，也许最有说服力的通用方法的潜力的例子是由分布式网格系列的组件提供的，由两个不同的并行应用来证明。

现在我们将更详细地讨论通用组件的各个方面。在第7.2.1节中，我们研究与使用通用组件有关的问题。第7.2.2节从实现的角度研究了通用方法。第7.2.3节讨论了并行计算的具体案例。性能问题在第7.2.4节中进行了判断。

\subsubsection{Use and Reuse of Generic Components}

在研究通用组件的重用时，可以区分两种基本情况。首先，增量的情况，即以非通用风格编写的应用程序重复使用选定的组件。在这里，通常需要一些适应性的努力来将 "本地 "网格数据结构映射到微内核上。这种情况的原型是纳维-斯托克斯求解器的并行化，在$6.4$部分讨论。

第二，按照通用方法整体编写的应用程序。在这里，所有与网格相关的部分都是以微内核为基础的，特别是算法和网格数据结构。在$6.2 .$一节中已经讨论了一个原型。与增量重用的情况相比，这种方法带来了额外的好处。与这种情况有关的一些问题与实现一般的通用组件的问题类似，将在下一节讨论。

我们首先考虑与增量方案有关的一些方面，然后转向对通用组件重用的一般讨论。

\textbf{Incremental use and adaptation effort} 对于一个任意的网格表示法，必须创建一个适应性来满足微内核的要求。一个完整的适配（即在底层表示允许的范围内）包括通用的网格函数、网格几何和第4.1.6节中讨论的半通用的复制/扩大函数。它包括大部分直接的接口代码，可以按照现有的例子进行建模。因此，Triang2D（附录B.1），可以被看作是对基于数组的表示法的改编，经常在$\mathrm{C}$或FORTRAN实现中发现。作为一个经验法则，这样的改编包含大约1-1.5KLOC的代码，可能会进一步减少。

如果只需要使用很少的组件，只需要实现所需的概念就足够了；例如，如果网格表示法基本上必须被复制，那么工作就会缩减到几十行，如第221页图B.3所示。

适应性工作由标准化的测试程序支持，例如检查迭代器的正确操作。

然而，在任何与网格有关的组件的重用中，都会有一定的努力。在不同的数据结构之间进行转换的 "经典 "方式也需要付出非同小可的努力，而且通常更容易出错。如果有一个第三方组件的通用适配器（见下文），可能更容易首先创建一个有限的适应微内核，就像刚才讨论的那样。

然而，当重复使用大量的组件时，通用方法的真正力量就发挥出来了，因为所需的调整工作是不变的。一旦完成，所有的通用组件都可以使用，而在传统的情况下，必须为每一种新的组件类型做临时的调整。改编工作必须与重用的潜在收益相权衡。对于一个15行的算法来说，这当然不值得麻烦，而对于使用分布式网格组件来说，这绝对值得。因为努力是恒定的，对于一组细粒度的组件，如额外的迭代器，它往往也会得到回报。相反，对于 "传统 "背景下的临时适应，只有足够粗粒度的组件才值得重复使用。

\textbf{Off-the-shelf reuse of generic components} 对于通用应用程序，在微内核之上，上述讨论并不适用。通用组件可以使用现成的，不需要任何进一步的劳动。

第6章中介绍的实际案例研究表明，通用组件的重用在不同的粒度范围内确实有效。

分布式网格系列组件当然是粗粒度重用的一个例子，其内部包含许多细粒度重用的例子，例如网格范围。这也是 "传统 "方法难以立足的情况。对底层网格表示的必要修改会使 "复制方法 "难以实现。

简单的可视化算法，如等值线和彩色图谱，提供了另一个概念证明。在不同的网格和模拟数据类型中使用它们不会造成任何问题。

使用传统库所需的临时适应工作可以被封装起来，因此也可以被重用。有很多这样的库，执行科学应用急需的任务，如网格生成、网格划分或可视化。使用这样的包所需要的改编工作有时是相当大的，例如，VISUAL3可视化包[Hai99]需要实现一些子程序，总共可以组成几百行，而且需要详细研究文件。这样的改编已经以通用的方式一劳永逸地实现了，对网格、几何和方程的类型进行了参数化（另见第160页）。为METIS分区器创建了类似的改编 [Kar99] 。因此，这些包可以被任何应用程序使用，而无需进一步的劳动。

如果整个应用程序是按照通用模式编写的，就会产生高度参数化的程序，这些程序可以被看作是 "程序族 "或生成器。具体的程序可以根据需要生成，例如见第6.2节中讨论的双曲方程的有限体积代码系列。在其他方面，这些应用允许对数据结构进行试验，以找到最适合特定情况的数据结构。

在未来，这可能会导致高度可配置的系统，它提出了一个超越目前程序的步骤。主要问题将是协调组件之间的相互关系，例如需要三角网格的离散化或方程的特定属性，以实现足够的呼吸，关于这些配置任务的讨论见[CE00]。

\textbf{Correctness and documentation of generic components} 使用通用组件引入的一个问题是，其正确性也取决于满足要求的类型参数。这并不总是容易验证的，而且需要用户方面的一些理解。对于复杂的算法，提供额外的组件来检查参数的正确性可能会有帮助。

许多通用算法在其最一般的形式下有相当多的参数。为了帮助对这种通用性不感兴趣的用户，有几层接口是很有用的，可以用默认值来代替这些类型，例如参见CELL NEIGHBOR SEARCH C.1的实现。

因为大量的组件可以通过使用有限的、有据可查的概念来指定（见$4.1$和$7.3$节），可以预见，一旦用户对这些概念有了必要的了解，他们就能够迅速理解新组件的界面。这与更传统的组件类型相反，例如子程序，其中数据布局必须为每个功能重新指定。

由微内核概念引起的分类法也提供了一种简单的方法，可以根据数据结构的功能对其进行分类。因此，可以迅速推断出一个特定的算法是否被给定的数据结构所支持，或者是否必须使用一个更强大的算法。

\textbf{Technical issues} 在这一点上，我们必须提到一些技术性更强的实际困难，这与使用C++ 的模板机制的实现有关。大量模板化的程序代码往往会导致更长的编译时间，编译器运行时消耗大量的内存，有时还会因为符号名称过长而出现问题，导致可执行文件过大，并使一些汇编器崩溃。正如VELDHUIZEN [Vel99c] 所指出的，这些问题的一部分是由于编译器中模板处理代码的不良实现。

另一个问题是，有时对检测由于不兼容的模板参数而产生的错误的支持很差，这些参数来自于没有忠实于概念的类型参数。另外，对模板机制的所有影响的实际支持，包括部分专业化和函数签名的部分排序，一直是一个问题。随着越来越多的编译器实施新的C++标准$[\operatorname{In} t 98]$，这个问题现在正逐渐消失。

总而言之，在使用这些实现时，可能仍然会遇到其中的一些问题，但有理由期待它们在未来消失。

\subsubsection{Implementing Generic Components and Applications}

实现通用组件当然比实现 "普通 "类或例程更难，因为有额外的变化来源。即使第四章中介绍的基本工作已经完成，情况也是如此。因此，只有在预期参数有足够变化的领域，才值得这样做。这显然是网格领域的情况。

与具体类型相比，程序员对作为类型参数传递的数据结构的了解是非常有限的。因为经过广泛分析得到的概念反映了领域的基本属性，它们比类接口的临时细节，或者更糟糕的是裸露的数据布局要稳定得多。

根据我们的经验，一般来说，使用抽象接口可以增加实现的可读性和意向性，因为具体数据结构（或类接口）的特异性细节被移除，例如，比较附录D中所示的简单内核的各种实现。这也降低了出错的概率。当然，这与通用编程本身无关，然而，由于语法被要求在广泛的具体实现中统一，这种统一性也延伸到了更大的代码范围。另外，这种更高的水平并不意味着实质性的性能损失。

使用我们开发的概念，哪些算法可以以通用方式实现？

前面已经指出，一般来说，非变异性算法比变异性算法更适合。特别是在这里，改变网格的内部结构是至关重要的；改变网格函数的值不会引起特别的问题。

对于非突变的算法，情况似乎令人满意。我们只遇到了极少数不能基于微内核中的概念来实现的算法。

这当然部分是由于组件的实施和概念的规范是平行发展的，相互之间有很大影响。总的来说，开发的概念似乎忠实地反映了网格的数学结构。这也被大量的非常基本的组件所证明，比如迭代器和子网格，它们可以通用于微内核，见4.2节。因此，该方法允许开发真正可扩展的网格软件。新的功能可以以同时有利于所有网格数据结构的方式来实现。

然而，还有一些细化工作要做，例如，分类法允许在网格的数学类型上进行编译分支，如直角坐标或三角坐标。此外，几何学仍然需要更多的工作，因为算法所需的几何量的数量相当高。

唯一一组引起一些问题的非变异算法是那些需要对细胞原型有更详细了解的算法。一个例子是二分法的细化，它要求单元格是单线，并知道顶点相对于一些模型单线的排列组合。这里需要将更多的知识转移到算法中，而不是目前可能的概念。类似的困难可以预期在有限元矩阵装配中，一般来说，局部坐标是必要的。这当然是一个需要进一步研究的课题，但细胞原型似乎是一个正确的抽象概念。

对于变异算法，第4.1.6节已经介绍了一种使用粗粒度变异基元的方法。这些方法已经成功地用于分布式网格组件，我们还简要介绍了如何使用它们来实现网格细化（第165页）。总的来说，还需要收集更多关于变异算法的经验，这构成了与自适应PDEs求解有关的算法的一小部分，但却是很重要的一部分。

\subsubsection{Parallel Computing with Generic Components}

为描述网格重叠结构（双边/总范围，暴露/共享/复制范围）而开发的概念已被证明对一大类表现出严重的数据平行性的算法很有用。

首先，对于更狭义的数据并行算法，如$5.5 .5$节中所定义的，该方法保证了与顺序情况下的结果相同。例如，这种算法出现在双曲问题的时间明确的解决方案中，其中空间信息以有限的速度传播，见$6.2 .$节 在这种情况下，没有新的算法产生。

此外，该方法还可用于不正式满足第5.5.5节条件的算法。5.5.5的条件，比如高斯-赛德尔迭代。在这种情况下，我们必须决定所产生的并行算法是否可以接受。分布式网格组件提供的范围允许在一定程度上控制算法的执行，例如，我们可以选择在边界变量上开始迭代。另外，改变重叠宽度只意味着改变参数文件中的几个数字，这使得人们可以很容易地试验重叠的大小。

然而，在许多情况下，必须设计新的算法来有效地进行并行运算。这里的主要例子是线性方程组的解决，例如在椭圆问题的解决中出现。这里的特点是信息的速度是无限的。一个地方的变化会影响到所有地方的解决方案。一般来说，好的数值算法反映了分析问题的这一特性。

在分布式环境中应对这一特性的技术是SCHWARZ的经典领域分解，导致重叠，如图所示。  $5.2(\mathrm{~b}), \mathrm{p} .118$，或现代非重叠方法，如[BRW93][Haa99]中讨论的那样。这里的非重叠是指，在本工作中开发的术语中，重叠只包括一个共享范围（不包含任何单元）。

一般来说，这些算法对边界范围、重叠数据结构中容易获得的实体进行特殊操作。通常，特殊的界面边界条件被定义在共享范围上。因此，尽管还没有具体的软件实例支持，但似乎很有可能$-$--分布式重叠网格框架将大大简化此类算法的实施。我们总是可以选择进一步完善这些概念，例如，允许更细小的网格交错通信和计算。ILU算法将是这方面的一个可能的候选人。

还有待观察的是，稍微不规则的计算类型，如粒子追踪、网格细化或网格生成，是否能无缝地融入框架，或者是否必须对概念进行扩展。

层次化的数据结构，例如在多网格算法中出现的层次化数据结构，已经在顺序的情况下解决了（第6.3.3节）。原则上，没有什么能阻止这些概念同时应用于几个网格；必须对网格间的垂直依赖关系给予一些关注。

到目前为止，还没有针对动态网格迁移和负载平衡问题的实施方案。然而，在第5.6.5节中给出了解决这些任务的路线图，其中包括对构件的列举。当然，还有一些工作要做，但是根据目前已经取得的成果，这些困难似乎并不是无法克服的。

分层动态网格计算的并行化是一个涉及到的话题，见BASTIAN[Bas94]或BIRKEN[Bir98]的论文，这些论文专门讨论这些问题。

基于单元的模版，取代了第5.5.4节中定义的一般入射模版，被证明在迄今为止遇到的所有实际情况下是足够的。这种一般的、与算法无关的描述，加上高效的算法$5.1$和$5.3$，标志着具有实际影响的实质性进展。早期使用一般描述的尝试被限制在使用临时工具$\left([\right.$ Bir98 $\left.]\left[\mathrm{GHR}^{+} 93\right]\right)$的预处理或编译步骤，因此不太适合运行时计算。

利用我们的成果，可以在最佳时间内产生重叠。因此，现在可以对不同的网格函数/算法使用不同的重叠（以最小化交换的数据量），可以很容易地试验不同的钢网（例如用于迭代方法），或者在一个应用中尝试钢网和同步的不同组合，见第$158 .$页。

分布式重叠网格抽象强调的是分布的逻辑属性而不是物理属性。这在一定程度上允许忽略网格是否驻扎在同一个内存中（复合网格）或物理分布（物理分布式网格），其中的细节被数据传输层封装起来（5.7.2节）。

原则上，这可以实现对不同机器架构的透明适应或优化，如分布式或共享内存。然而，还有一些工作要做，因为到目前为止，全局循环的结构中仍然可以看到这种区别。将全局循环的逻辑封装到通用的 "foreach() "组件中似乎是可能的，这将允许进一步的通用化。然而，有些算法需要对执行的顺序有更多的控制。在这种方法中，必须考虑到这一点。

由于采用了通用的方法，这些组件可以用在任何顺序网格数据结构之上，可能要经过对微内核的调整，见上文。因此，现有的应用程序可以通过对代码的最小改动来实现并行化。当然，这并不排除必须改变现有的算法以有效地进行并行运算，见上面的讨论。我们的方法的一个重要优势是，它不依赖于额外的工具，如实现语言扩展的预处理器，而只依赖于符合C++标准的编译器。在实践中，基于扩展的方法经常受到其他开发工具的干扰，如调试器，或不同的扩展。

\subsubsection{Performance of Generic Components}

一般来说，通用组件的执行速度要比非通用组件慢，因为额外的抽象层通常会引入额外的代理层和临时对象，编译器必须移除这些对象才能得到等价的代码。这种额外的开销被称为 "抽象惩罚"。

这种惩罚能消除多少，在很大程度上取决于具体的实现、附加层的数量，最后也是最重要的一点，就是使用的编译器，以及所选择的选项。对于一些简单但有特点的情况，已经得到了定量的结果（见6.5节）。当然，对后者要慎重对待。这些内核在某种程度上代表了最坏的情况，因为没有进行太多的实际工作，因此开销的测量是相当直接的。

可以得出一些结论。在某些情况下，开销可以完全消除，这无疑是个好消息。此外，这些数字再次表明了对编译器和特定优化选项的敏感性。编译器技术是否会收敛到这个问题不那么重要的状态，仍然是一个未知数。

通常，一个更严重的性能瓶颈可能是糟糕的数据布局。特别是，"经典的 "面向对象的方法在对象中收集小群的异质数据有时似乎是性能杀手。幸运的是，人们可以很容易地尝试不同的数据结构，如果随后使用通用方法的话。

从相反的角度来看，更高层次的抽象在实践中可以导致更有效的代码，即如果它封装了在低层次上不切实际的优化。foreach()类型的循环抽象实现了通信和计算的重叠，或者优化了多维数组的遍历，以便在模版操作中获得更好的数据定位，就属于这种情况。例如，对非结构化网格的数据定位优化数据结构进行实验，可能会有收获。通用编程当然有助于进行这些实验。

\subsection{ Outlook}

这项工作中获得的结果鼓励在该领域进行进一步研究。为了挖掘通用方法的潜力，需要更多的通用组件，特别是算法。特别是，可以期待从并行负载平衡和分区的通用实现中获得巨大的收益，因为在这里复制网格数据结构是一个严重的瓶颈。许多通用算法是以独立于维度的方式实现的（例外：大多数可视化算法）；三维网格将被实施以证明这一点。

对于动态数据结构上的突变算法，还需要更多的工作，以评估这里提出的粗粒度方法的范围。

在数据结构方面，可以采用生成法$\left([\mathrm{Cza} 98],\left[\mathrm{CEG}^{+}\right]\right)$来开发整个参数化数据结构系列，例如，允许指定哪些数据将被永久存储的网格几何形状，或者具有各种阻断策略的网格/网格函数，以提高数据定位。

科学计算是一个跨学科的领域，有许多领域的内容。因此，必须加深与其他算法领域的软件组件的联系，如算法图论、计算机图形学和计算几何学。在使用CGAL[pro99]（计算几何）和GGCL[LSL99]（图算法）的组件方面，已经做了一些初步的尝试。这应该在一个更系统的范围内进行评估。特别是，图算法的通用库是有意义的，因为大量与科学计算相关的算法都是在图上操作的。网格划分和带宽最小化是我们提到的两个例子。

以上，我们已经反复谈到了用于解决偏微分方程的程序族。显然，还有许多方面可以留到程序的实际实例化时再讨论。对调试的支持，对所用算法的选择，更普遍的方程系列，等等。

如果系统地进行，这将需要对整个PDE解决方案领域进行彻底的领域分析，也可能是科学计算的其他领域，如非线性方程和优化。沿着生成式编程[CE00]、主动式库$\left[\mathrm{CEG}^{+}\right]$或产品线方法[Bat97]的思路，该领域的软件设计可以达到一个新的水平。我们希望这项工作的成果能够为实现这一目标贡献一小步。

\section{Bibliography}

最新版本的网址将公布在http: //www.math. tu-cottbus. de/ berti/diss.

[A+95] Ed Anderson et al. LAPACK users' guide.SIAM, 2nd edition, 1995 .

[ABL97] Erlend Arge, Are Magnus Bruaset, and Hans Petter Langtangen, editors.科学计算中的现代软件工具。Birkhäuser出版社，$1997 .$ 。

[AH35] Paul Alexandroff 和 Heinz Hopf.Topologie.Springer, 1935.更正后的重印本1974年.

[Ahl99] Krister Ahlander.一个面向对象的PDE求解器框架。博士论文，乌普萨拉大学，瑞典，1999年。

[Ale98] Paul S. Alexandrov.Combinatorial topology.Dover Publications, 1998.格雷洛克出版社出版的三卷本的重印本，1956,1957 , 1960。从1947年的讨论版翻译过来的。

[B $\left.^{+} 99\right]$ Peter Bastian et al. UG home page. http: //dom.ica3. uni-stuttgart.  $\mathrm{de} /{ }^{\sim} \mathrm{ug} /, 1999 .$

[Ban98] Randolph E. Bank.PLTMG: A Software Package for Solving Elliptic Partial Differential Equations - Users' Guide 8.0.SIAM Publications., 1998 .

[Bas94] Peter Bastian.Parallele adaptive Mehrgitterverfahren.博士论文，海德堡大学，1994年。

[Bat95] Don S. Batory。主观性和软件系统生成器。技术报告CS-TR-95-32，德克萨斯大学奥斯汀分校，9月1日， $1995 .$

[Bat97] Don S. Batory。智能组件和软件生成器。技术报告CS-TR-97-06，德州大学奥斯汀分校，1997年4月1日。

[BBK99] Georg Bader, Guntram Berti, and Klaus-Jürgen Kreul.Unstrukturierte parallele Strömungslöser auf hybriden Gittern.SUPEA项目的最终报告，科特布斯技术大学，$1999 .$ [BBar] Georg Bader和Guntram Berti。可重复使用的软件组件的设计原则，用于PDE问题的数值解。In Wolfgang Hackbusch and Gabriel Wittum, editors, Concepts of Numerical Software.Vieweg Verlag, To appear.第14届GAMM研讨会论文集, Kiel 1998 .

[Ber98] Guntram Berti.外部控制--一种将分层结构映射到外部控制机制的模式。技术报告，科特布斯工业大学数学研究所，1998年10月。

[Ber99] Guntram Berti.PDEs的并行数值解的概念。In Roland Vilsmeier, Fayssal Benkhaldoun, and Dieter Hänel, editors, Finite Volumes for Complex Applications II, pages 655-662.Hermès科学出版社，巴黎，1999年7月。FVCAII会议记录，1999年7月19-22日，德国杜伊斯堡。

[Bey98] Jürgen Bey.Finite-Volumen und Mehrgitter-Verfahren für elliptische Randwertprobleme.PhD thesis, Institut für Mathematik, Universität Tübingen, 1998 .

[Bey99] Jürgen Bey.AGM3D主页。http://elc2.igpm.rwth-aachen.de/ bey/agm.html，1999。(最后一次访问。  $11 / 1999)$ .

[BF99] Scott B. Baden和Stephen J. Fink。双层多计算机的编程方法。IEEE Transactions on Software Engineering, $1999 .$.

[BGMS97] Satish Balay, William D. Gropp, Lois C. McInnes, and Barry F. Smith。面向对象的数字软件库中的高效并行管理。In E. Arge, A. M. Bruaset, and H. P. Langtangen, editors, $[A B L 97]$ , pages 163-202.Birkhäuser出版社，1997年。

[BGMS98] Satish Balay, Bill Gropp, Lois Curfman McInnes, and Barry Smith.基于组件的数字软件系统的微内核设计。In Michael E. Henderson, Christopher R. Anderson, and Stephen L. Lyons, editors, Object Oriented Methods for Interoperable Scientific and Engineering Computing.SIAM，10月 $1998 .$ 。

[BGMS99] Satish Balay, William D. Gropp, Lois Curfman McInnes, and Barry F. Smith.PETSc - 用于科学计算的可移植、可扩展工具包。 http: //www-fp.mcs anl gov/petsc/, 1999 .

[BHKF99] Thomas Brandes, Resi Höver-Klier, and Peter Faber.ADAPTOR GMD的高性能Fortran编译系统。 http: //www .gmd. de/SCAI/lab/adaptor/, $1999 .$ （最后访问：$01 / 2000$ ）。  [BHW97] James M. Boyle, Terence J. Harmer, and Victor L. Winter.The TAMPR program transformation system:简化了数值软件的开发。In Erlend Arge, Are Magnus Pettersen, and Hans Petter Langtangen, editors, $[A B L 97]$ , pages $353-372 .$ Birkhäuser, 1997 .

[Bir98] Klaus Birken.Ein Modell zur effizienten Parallelisierung von Algorithmen on komplexen, dynamischen Datenstrukturen.博士论文，斯图加特大学，1998年10月。

[BK98] 托马斯-布莱特菲尔德和斯文-科里瓦尔。Tent:一个基于CORBA的组件架构，用于MPI-并行CFD模拟及其支持工具。In Proceedings of the International Conference on Parallel and Distributed Processing Techniques and Applications (PDPTA '98), Athens, Georgia, 1998.C.S.R.E.A.

[BL97] Are Magnus Bruaset and Hans Petter Langtangen.Diffpack中面向对象的预设迭代方法的设计。  $A C M$ Transactions on Mathematical Software, $23(1): 50-80$ , March $1997 .$ 。

[BL94] Randall Bramley和Tom Loos.EMILY: 大型稀疏矩阵的可视化工具.技术报告TR-412，印第安纳大学，计算机科学系，94年7月。

[BN95] John J. Barton和Lee R. Nackman。科学与工程 $C++$ .Addison-Wesley, 1995 .

[BO84] Marsha J. Berger and Joseph Ohliger.双曲偏微分方程的自适应网格细化.计算物理学杂志, $53: 484-512,1984$ 。

[BQH99] David L. Brown, Daniel J. Quinlan, and William Henshaw.Overture面向对象的工具，用于解决复杂移动几何中的CFD和燃烧问题。 http: //www. llnl.gov/CASC/Overture/, 1999 。

[BR78] Ivo Babuška 和 Werner C. Rheinboldt.有限元方法的A-后验误差估计.Int.J. Numer.Meth.Eng., $12: 1597-1615,1978$ 。

[Bra] Kenneth A. Brakke.The surface evolver home page. http://www.geom. umn. edu/software/evolver/.(最后一次访问：01/2000)。

[Bra73] Achi Brandt.用于快速数值解决边界值问题的多级自适应技术（MLAT）。In H. Cabannes and $\mathrm{R}$ .Teman, editors, Proceedings of the Third International Conference on Numerical Methods in Fluid Mechanics, volume 18 of Lecture Notes in Physics, pages $82-89$ , Berlin, 1973.Springer-Verlag.  [Bra92] Kenneth A. Brakke.表面演化器。实验数学》， $1(2): 141-165,1992$ 。

[Bri89] Eric Brisson.在$d$维度上表示几何结构。Topology and order.In Proc. 5th Annu.ACM Sympos.Comput.Geom., pages $218-$ $227,1989 .$ 。

[Bri99] Keith Briggs.The doubledouble homepage. http://www-epidem. plantsci.cam.ac.uk/ kbriggs/doubledouble.html, $1999 .$

[BRW93] Georg Bader, Rolf Rannacher, and Gabriel Wittum, editors.Numerische Algorithmen auf Transputer-Systemen.Teubner, $1993 .$.

[BSST93] Don S. Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas.可扩展的软件库。在ACM SIGSOFT '93软件工程基础研讨会的论文集中，第191-199页，12月 $1993 .$

[BZ94] Thomas Brandes和Falk Zimmermann。Adaptor - HPF程序的转换工具。In K. M. Decker and R. M. Rehmann, editors, Programming environments for massively parallel distributed systems: working conference of the IFIP WG10.3, April 25-29, 1994, Ascona, Italy, pages 91-96, Cambridge, MA, USA, 1994.Birkhäuser Boston Inc.

$\left[\mathrm{C}^{+}\right]$ Andrew Chien et al. Illinois Concert project. http://www-csag.ucsd. edu/projects/concert.html.(最后一次访问：01/2000)。

[CE00] Krzysztof Czarnecki和Ulrich Eisenecker。Generative Programming:方法、技术和应用。Addison-Wesley, $2000 .$.

[CEG $^{+}$ ] 。Krzysztof Czarnecki, Ulrich Eisenecker, Robert Glück, David Vandevoorde, and Todd Veldhuizen.生成式编程和活动库。

[CEKN99] Krzysztof Czarnecki, Ulrich Eisenecker, Johannes Knaupp, and Tobias Neubert.GMCL - 生成矩阵计算库。 http: / /electra. prakinf.tu-ilmenau.de/ czarn/gmcl/index.html, $1999 .$ 。

[Cop98] James O. Coplien.多范式设计 $C++$ .Addison-Wesley, 1998 .

[Cou98] Bernard Coulange.Software reuse.Springer Verlag, London, $1998 .$ 。

[Cro96] Thomas W. Crockett.Beyond the renderer:用于并行图形和可视化的软件架构。In A. Chalmers and $\mathrm{E}$ .Jansen, editors, Proc.First Eurographics Workshop on Parallel Graphics and Visualisation, pages 1-15, Bristol, U.K., September 1996.阿尔法书局。也可作为ICASE报告No.96-75（NASA CR-201637）。  [Cza98] Krzysztof Czarnecki.Generative Programming:基于自动配置和基于片段的组件模型的软件工程原则和技术。博士论文，伊尔梅瑙理工大学，德国， $1998 .$ 。

[DEG98] Tamal K. Dey, Herbert Edelsbrunner, and Sumanta Guha.计算拓扑学。In B. Chazelle, J. E. Goodman, and R. Pollack., editors, Advances in Discrete and Computational Geometry, Contemporary Mathematics.AMS, 1998 .

[DHH99] T. B. Dinesh, Magne Haveraaen, and Jan Heering.数值软件的代数编程风格及其优化。技术报告SEN-R9844，CWI，阿姆斯特丹，$1999 .$ 。

[DL89] David P. Dobkin和Micheal J. Laszlo。操作三维细分的基元。Algorithmica, $4: 3-32,1989 .$.

[DLPR99] Jack Dongarra, Andrew Lumsdaine, Roldan Pozo, and Karin Remington.IML++（迭代方法库）。http://math.nist.gov/iml++/， $1999 .$

[DPW93] Jack J. Dongarra, Roldan Pozo, and David W. Walker.LAPACK++:面向对象的高性能线性代数扩展的设计概述。In Proceedings, Supercomputing '93:波特兰，俄勒冈州，1993年11月15-19日，第162-171页，1109 Spring Street, Suite 300, Silver Spring, MD 20910, USA，1993。IEEE计算机学会出版社。

[DQ99] Kei Davis和Dan Quinlan.ROSE II: An optimizing code transformer for C++ object-oriented array class libraries.在第三届世界系统学、控制论和信息学多学科会议上 $\left(S C I^{\prime} 99\right), 1999 .$ 。

[Ede87] Herbert Edelsbrunner.Combinatorial Geometry中的算法.Springer Verlag, 1987 .

[Els97] Ulrich Elsner.图的划分--调查。技术报告SFB393/9727，开姆尼茨技术大学，12月 $1997 .$

[FBK98] Stephen J. Fink, Scott B. Baden, and Scott $R$ 。Kohn。对不规则块状结构应用的高效运行时间支持。并行和分布式计算杂志 $, 50(1): 61-82$ , 四月 $10 /$ 五月 $11998 .$ 。

[Fed64] Radii P. Fedorenko.论一个迭代过程的收敛速度.USSR Comput.数学和物理，$4: 227,1964 .$ 。

[Fil96] Mark Filipiak.网格生成。Epcc技术观察报告，爱丁堡平行计算中心，爱丁堡大学， $1996 .$ [Fin97] Stephen Fink.The KeLP programming system. http://www-cse.ucsd. edu/groups/hpcl/scg/kelp/index.html, 1997.(最后一次访问：01/2000)。

[FJP98] Lori Freitag, Mark Jones, and Paul Plassmann.SUMAA3d中的网格组件设计和软件集成。In Michael E. Henderson, Christopher R. Anderson, and Stephen L. Lyons, editors, Object Oriented Methods for Interoperable Scientific and Engineering Computing.SIAM，1998年10月。

[FP90] Rudolf Fritsch和Renzo A. Piccini.拓扑学中的细胞结构.剑桥大学出版社, 1990 .

[FP99] Joel H. Ferzinger 和 Milovan Perić.流体动力学的计算方法.斯普林格出版社，$1999 .$ 。

[FvFH90] James D. Foley, Andries van Dam, Steven $K$ 。Feiner，和John F. Hughes。计算机图形学--原理与实践（第二版）。Addison-Wesley, 1990 .

[FWM94] Geoffrey C. Fox, Roy D. Williams, and Paul C. Messina.并行计算工作!摩根考夫曼出版社，$1994 .$ 。

[GC-99a] Grand challenge coupled field problems. http://caswww.colorado. edu/ CF . d/Home. html, 1999.(最后访问 $11 / 1999$ )。

[GC-99b] Grand challenge in petroleum reservoir modeling. http: //wWw.pe.utexas. edu/HPCC/, 1999.(最后访问 $11 / 99)$ 。

[GC98] Bishwaroop Ganguly 和 Andrew Chien.使用Illinois Concert系统对自适应网格应用进行高级别的并行编程。In Proceedings of the 2nd International Scientific Computing in Object-Oriented Parallel Environments (ISCOPE'98), volume 1505 , pages 47-58, 1998 .

[GHJV94] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.设计模式--可重用的面向对象软件的要素.AddisonWesley, 1994 .

[GHR $\left.^{+} 93\right]$ Uwe Geuder, Monika Härdtner, Andreas Reuter, Bernhard Wörner, and Roland Zink.GRIDS - 基于网格算法的并行编程系统。计算机杂志》， $36(8): 702-711,1993$ 。

[Gol93] Herman H. Goldstine.从帕斯卡尔到冯-诺伊曼的计算机.普林斯顿大学出版社，普林斯顿，1993年。

[GR94] Christian Großmann and Hans-Görg Roos.Numerik partieller Differentialgleichungen.B. G. Teubner, 2nd edition, $1994 .$ [GRA99] GRAPE team.http: //www-sfb256.iam.uni-bonn.de/grape/main.html, $1999 .$ （最后访问。  $11 / 1999)$ .

[Gro98] William Gropp.利用图书馆中的现有软件。成功，失败，以及原因。在Michael E. Henderson, Christopher $\mathrm{R}$ 。Anderson, and Stephen L. Lyons, editors, Object Oriented Methods for Interoperable Scientific and Engineering Computing.SIAM，10月 $1998 .$ 。

[GS85] Leonidas Guibas和Jorge Stolfi.操作一般细分和计算Voronoi图的基元。  $A C M$ Transactions on Graphics, $4(2): 74-123$ , April $1985 .$ 。

[Haa97] Gundolf Haase.基于非重叠域分解数据分布的新矩阵-向量乘法。在Christian Lengauer, Martin Griebl, and Sergei Gorlatch, editors, Parallel Processing (Proceedings of EuroPar '97), Volume 1300 of Lecture Notes in Computer Science, pages $726-733$ .斯普林格出版社，1997年8月。

[Haa99] Gundolf Haase.Parallelisierung numerischer Algorithmen für partielle Differentialgleichungen.Teubner Verlag, Stuttgart, Leibzig, $1999 .$ 。

[Hac85] Wolfgang Hackbusch.Multigrid Methods and Applications.Springer, Berlin, 1985 .

[Hai91] Bob Haimes.Visual3 - 一个用于流动可视化的软件环境.计算流体力学中的计算机图形和流动可视化，VKI讲座系列10，$1991 .$ 。

[Hai99] Bob Haimes.Visual3主页。http://raphael.mit.edu/visual3/ visual3.html，1999年

[Hen79] Michael Henle.A combinatorial Introduction to Topology.Dover Publications, N.Y., 1979 .

[Hin83] Alan C. Hindmarsh.ODEPACK，一个系统化的ODE求解器集合。In R. S. Stepleman et al., editors, Scientific Computing, volume 1 of $I M A C S$ Transactions on Scientific Computation, pages $55-64 .$ North-Holland, $1983 .$ 。

[Hir90] Charles Hirsch.内部和外部流动的数值计算，第二卷：非粘性和粘性流动的计算方法。John Wiley\& Sons, Chichester, New York, Brisbane, Toronto, Singapore, (1990).

[HK98] Richard D. Hornung和Scott R. Kohn。SAMRAI结构化AMR框架中面向对象设计模式的使用。在迈克尔 $\mathrm{E}$ 。Henderson, Christopher $\mathrm{R}$ .Anderson, and Stephen L. Lyons, editors, Object Oriented Methods for Interoperable Scientific and Engineering Computing.SIAM，1998年10月。

[HL95] Walter Hürsch和Cristina Videira Lopes。分离关注点.技术报告NU-CCS-95-03，东北大学计算机科学学院，波士顿，马萨诸塞州，1995年2月24日。

[HMN93] Hans Hagen, Heinrich Müller, and Gregory M. Nielson, editors.Focus on Scientific Visualization.斯普林格出版社，$1993 .$ 。

[HPC99] 耦合场和GAFD湍流的高性能计算方法。  $0.4$ http://wwwmcb.cs.colorado.edu/home/gc/Home.html, 1999.(最后访问 $11 / 99$ )。

[HW95] Wolfgang Hackbusch 和 Gabriel Wittum，编辑。耦合问题的数值处理，《数值流体力学注释》第51卷。Vieweg Verlag, $1995 .$ 。

[Int98] 国际标准化组织。ISO/IEC 14882:1998:编程语言 $-C++.$ 国际标准化组织，瑞士日内瓦，1998。

[Jac97] Jonathan Jacky.The Way of Z: Practical Programming with Formal Methods.剑桥大学出版社，1997年。内容和其他信息见http://www.radonc.washington. edu/prostaff/jon/z-book/.

[Jän90] Klaus Jänich.Topologie.斯普林格出版社，3版，$1990 .$ 。

[Joe91] 巴里-乔。Geompack.一个使用几何算法生成网格的软件包。工程软件和工作站的进展, $13(5-6): 325-331$ , 1991年9月。

[Joe95] Barry Joe.利用局部变换构建三维改进质量的三角形。SIAM J. Sci. Comput., pages $1292-1307$ , 1995 .

[JP95] 马克T.Jones和Paul E. Plassmann.Blocksolve95用户手册:用于并行解决稀疏线性系统的可扩展的库软件。ANL Report 95/48, Argonne National Laboratory, December $1995 .$ 。

$\left[\mathrm{K}^{+} 99\right]$ Steve Karmesin等人，POOMA。Parallel Object-Oriented Methods and Applications. http://www.acl. lanl.gov/PoomaFramework/, $1999 .$

[Kar95] Even-André Karlsson，编辑。软件重用--一种整体的方法.John Wiley\& Sons, 1995 .

[Kar99] George Karypis.METIS主页。http://www-users.cs.umn.edu/ karypis/metis/，1999。(最后一次访问。  $11 / 1999)$ .  [Ket97] Lutz Kettner.为多面体表面设计一个数据结构。技术报告技术报告278，苏黎世联邦理工学院，理论计算机科学研究所，12月 $1997 .$ 。

[KLM+97] Gregor Kiczales, John Lamping, Anurag Menhdhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John Irwin.面向方面的编程。In Mehmet Akşit and Satoshi Matsuoka, editors, ECOOP '97Object-Oriented Programming 11th European Conference, Jyväskylä, Finland, volume 1241 of Lecture Notes in Computer Science, pages 220-242.Springer-Verlag, New York, NY, June 1997 .

[KMS81] Derek Kapur, David R. Musser, and Alexander A. Stepanov.Tecton:用于操作通用对象的语言。In J. Staunstrup, editor, Proceedings of a Workshop on Program Specification, volume 134 of $L N C S$ , pages 402-414, Aarhus, Denmark, August 1981.Springer.

[Knu93] Donald E. Knuth.The Stanford GraphBase:A Platform for Combinatorial Computing.Addison-Wesley, Reading, MA, $1993 .$ 。

[Knu96] Donald E. Knuth.计算机科学论文选，CSLI讲义第59卷。剑桥大学出版社，英国剑桥，1996年。

[KNW97] Dietmar Kühl, Marco Nissen, and Karsten Weihe.图算法的高效、可适应的实现。In Proc. of Workshop on Algorithm Engineering WAE'97.威尼斯大学，意大利，1997年9月。

[Kot99] Vladimir Kotlyar.用于合成稀疏矩阵程序的关系代数技术.康奈尔大学计算机科学系博士论文，1999年2月。可作为TR ncstrl.cornell/TR991732。

[KRYG82] David R. Kincaid, John R. Respess, David M. Young, and Roger G. Grimes。ITPACK $2 \mathrm{C}:$ 一个FORTRAN软件包，用于通过自适应加速迭代方法解决大型稀疏线性系统。ACM Trans.Math.软件，$8(3): 302-322,1982$ 。

[Kuc99] Kuck\& Associates, Inc.Introduction to KAI C++. http://www.kai. com/C_plus_plus/, 1999.(最后一次访问 $01 / 2000$ ) 。

[Kue98] Frank Kuehndel.避免缓存冲突的软件方法。技术报告CS-TR-98-16，德州大学奥斯汀分校，1998年9月1日。

[KW96] Dietmar Kühl 和 Karsten Weihe.图中节点和边的迭代器和手柄。技术报告15，康斯坦茨大学，1996年9月。  [KW97] Dietmar Kühl和Karsten Weihe。数据访问模板。  $C++$ 报告， $9(7): 15,18-21,1997$ 。(也可作为TR 9/1996，康斯坦茨大学）。)

[LeV92] Randall J. LeVeque.守恒定律的数值方法.Birkhäuser, 1992 .

[LeV94] Randall J. LeVeque.CLAWPACK: A software package for solving multidimensional conservation laws.In J. Glimm, editor, Proceedings of the Fifth International Conference on Hyberbolic Problems:Theorie, Numerics, $A p$ plications.世界科学组织，6月 $1994 .$ 。

[LHKK79] Charles L. Lawson, Richard J. Hanson, David $\mathrm{R}$ 。Kincaid, and Fred T. Krogh.Algorithm 539: Basic linear algebra subprograms for Fortran usage.ACM Trans.Math.软件，5:324-325，1979。

[LLS99] Andrew Lumsdaine, Lie-Quan Lee, and Jeremy Siek.The Generic Graph Component Library, GGCL. http://www.lsc.nd. edu/research/ggcl/, 1999.(最后一次访问 $01 / 2000$ )。

[LMR+97] Peter Luksch, Ursula Maier, Sabine Rathmayer, Matthias Weidmann, and Friedemann Unger.Sempa:用于并行科学计算的软件工程。IEEE并发， $5(3): 64-72$ ，1997年7月/9月。

[Loe76] Arthur L. Loeb.空间结构，其和谐与对位。Addison-Wesley, London, 1版, 1976 .

[LS95] Meng Lee and Alexander A. Stepanov.标准模板库。技术报告，惠普实验室，2月 $1995 .$

[LS99a] Andrew Lumsdaine 和 Jeremy Siek.迭代模板库（ITL）。http://www. lsc.nd.edu/research/itl/, $1999 . \quad$ （最后访问 $11 / 1999)$ .

[LS99b] Andrew Lumsdaine 和 Jeremy Siek.The Matrix Template Library (MTL). http://www. lsc.nd. edu/research/mtl/, 1999.(最后一次访问 $01 / 2000$ )。

[LSL99] Lie-Quan Lee, Jeremy G. Siek, and Andrew Lumsdaine.通用图形组件库。In Proccedings of OOPSLA'99, 1999 .

[LW69] Albert T. Lundell 和 Stephen Weingram.The Topology of $C W$ Complexes.Van Nostrand Reinhold, 1969 .

[MA97] Fredrik Manne和Svein Olav Andersen.大型数字代码的自动化调试。在 $[A B L 97]$ ，页 $339-352.1997$ 。

[Män83] Martti J. Mäntylä.计算拓扑学：计算机图形和几何建模中的拓扑操作和询问的研究。Acta Polytech.Scand.Math.Comput.Sci. Ser., $37: 1-46,1983 .$ [McI68] Doug McIlroy.大规模生产的软件组件。In Proceedings of the 1st International Conference on Software Engineering, GarmischPartenkirchen, Germany, pages 88-98, 1968 .

[Mey92] Bertrand Meyer。Eiffel:The Language.Object-Oriented Series.Prentice Hall, New York, NY, 1992 .

[Mit97] William F. Mitchell.使用全域划分的并行多网格方法。In Copper Mountain Conference on Multigrid Methods 97, 1997 .可在MGNet上找到。

[Mit99] William Mitchell.MGHAT netlib目录。http://elib.zib.de/ netlib/pdes/mgghat/，1999。

[MNU99] Kurt Mehlhorn, Stefan Näher, and Christian Uhrig.The LEDA home page. http: / / www mpi-sb.mpg . de/LEDA/, 1999 .

[Moi77] Edwin E. Moise.二维和三维的几何拓扑学。SpringerVerlag, New York, 1977 .

[Mor97] Michael E. Mortenson.Geometric Modeling.Wiley, New York, 2nd edition, $1997 .$ 。

[MPI] 消息传递接口（MPI）标准。http://www-unix.mcs. anl.gov/mpi/。(最后一次访问 $01 / 2000$ )。

[MS89] David R. Musser 和 Alexander A. Stepanov.通用编程。在Patrizia Gianni，编辑，符号和代数计算。International Symposium ISSAC '88, Rome, Italy, July $4-8,1988:$ proceedings, number 358 in LNCS, pages 13-25.Springer, 1989 .

[MS94] David R. Musser and Alexander A. Stepanov.面向算法的通用库。软件实践与经验, $24(7): 623-642$ , 七月 $1994 .$ 。

[MSD93a] Robert C. Malone, Richard D. Smith, and John K. Dukowicz.气候、海洋和并行计算。Los Alamos Science, 21,1993 .

[MSD93b] Robert C. Malone, Richard D. Smith, and John K. Dukowicz.在并行计算机上进行海洋建模的新数值方法。洛斯阿拉莫斯科学，$21,1993 .$ 。

[Mye95] Nathan Myers.一种新的、有用的技术。"`traits`"。  $C++$ 报告，$7(5): 32-$ 35，1995年6月。

[Nat95] 国家计算、信息和通信协调办公室。Hpcc蓝皮书1996:美国信息未来的基础。http://www.ccic.gov/pubs/blue96/index.html，1995年9月。  [Nor96] Charles D. Norton.科学计算中面向对象的编程范式.博士论文，伦斯勒理工学院，特洛伊，纽约，1996年。

[NW96] Marco Nissen 和 Karsten Weihe.将LEDA与图算法的可定制实现相结合。技术报告17，康斯坦茨大学，10月 $1996 .$

[OR97] Mario Ohlberger 和 Martin Rumpf.嵌套网格上的分层和自适应可视化。计算， $59(4): 365-385,1997$ 。

[Par76] David L. Parnas.关于程序族的设计和开发。IEEE Transactions on Software Engineering, SE-2(1):1-9, March 1976.

[PB99] Manish Parashar and James C. Browne.DAGH（分布式自适应网格层次）主页。http://www.caip.rutgers. edu/ parashar/ $\mathrm{DAGH} /, 1999 .$

[PD90] Ruben Prieto-Diaz.领域分析。介绍。ACM SIGSOFT软件工程笔记, $15(2): 47$ , 1990年4月。

[PdKÜK83] Robert Piessens, Elise deDoncker Kapenga, Christoph Überhuber, and David Kahaner.QUADPACK: a Subroutine Package for Automatic Integration.计算数学系列。Springer Verlag, $1983 .$ 。

[Pet97] N. Anders Petersson.一种构建重叠网格的算法.技术报告，查尔姆斯科技大学，3月 $1997 .$

[PHS98] Steve Plimpton, Bruce Hendrickson, and James Stewart.一个用于多个网格之间插值的并行交会算法。In Proceedings of SC'98: High Performance Networking and Computing, $1998 .$ Electronic Proceedings available at http://www.supercomp.org/sc98/ proceedings/.

[PIC99] PICS联盟。Grand challenges on groundwater remediation. http: //www. isc.tamu. edu/PICS/PICS.html, $1999 .$ 。

[PNDN97] Preeti Ranjan Panda, Hiroshi Nakamura, Nikil D. Dutt, and Alexandru Nicolau.通过平铺和数据对齐提高缓存性能。In G. Bilardi, A. Ferreira, R. Lüling, and J. Rolin, editors, Solving Irregular Structured Problems in Parallel (Proceedings of 4th Intl. Symp. IRREGULAR97), volume 1253 of $L N C S$ , pages 167-185.Springer Verlag, $1997 .$ 。

[pro99] The CGAL project.CGAL主页--计算几何算法库。http: //www.cs. uu.nl/CGAL/, $1999 .$ [PVM] PVM--并行虚拟机。http://www.epm. ornl.gov/pvm/pvm_ home. html.(最后一次访问 $01 / 2000$ )。

[PvW93] Frits H. Post和Theo van Wilsum.Focus on Scientific Visualization, chapter Fluid Flow Visualization.斯普林格，1993年。在 [HMN93] 。

[PWJ97] Stephen G. Parker, David M. Weinstein, and Christopher R. Johnson。SCIRun计算转向软件系统。In E. Arge, A. M. Bruaset, and H. P. Langtangen, editors, Modern Software Tools in Scientific Computing.Birkhäuser Press, 1997 .

[RB84] John R. Rice 和 Ronald F. Boisvert.使用ELLPACK解决椭圆问题.Springer Verlag, New York, 1984 .

[REL97] Rainer Roitzsch, Bodo Erdmann, and Jens Lang.一个面向对象的有限元代码。设计问题和在热疗计划中的应用。在 $[A B L 9 \%]$ 中，第 $105-124.1997$ 页。

[REL99] Rainer Roitzsch, Bodo Erdmann, and Jens Lang.Kaskade--自适应有限元代码系列。ftp://elib.zib.de/pub/elib/codelib/kaskade/, 1999 .

[Riv84] María-Cecilia Rivara.适用于自适应和多网格技术的三角网格细化算法.Internat.  $J .$ Numer.Methods Eng., $20: 745-756,1984 .$.

[Rob96] Arch D. Robison.C++在科学计算中变得更快。Computers in Physics, $10(5): 458-462$ , Sep/Oct $1996 .$.

[Ros98] Jarek Rossignac.EDGEBREAKER: 三角形网格的连接性压缩。技术报告98-35，GVU，1998。乔治亚理工大学的图形、可视化和可用性中心。

[RP97] Karin A. Remington和Roldan Pozo.The NIST Sparse BLAS. http: //math.nist.gov/spblas/, 1997.(最后访问 $01 / 2000$ ) 。

[RSS96] Martin Rumpf, Alfred Schmidt, and Kunibert G. Siebert.定义任意网格的函数--数值数据和可视化之间的灵活接口。计算机图形论坛，$15(2): 129-141,1996 .$ 。

[Saa96] Yousef Saad.稀疏线性系统的迭代方法.PWS出版公司, 1996 .

[Sam97] Johannes Sametinger.用可重复使用的组件进行软件工程。Springer Verlag, 1997 .  [SBB97] Klaus Schenk, Georg Bader, and Guntram Berti.多组分气体混合物的分析和近似。In M. Feistauer, K. Kozel, and R. Rannacher, editors, Proceedings of the 3rd Summer Conference Numerical Modelling in Continuum Mechanics, Prague, 1997 。

[Sch99] Joachim Schöberl.Netgen用户手册。http://www.sfb013.uni-linz. ac.at/ joachim/usenetgen/, 1999.(最后一次访问:  $11 / 1999)$ .

$\left[\mathrm{SFdC}^{+} 97\right]$ Mark S. Shephard, Joseph E. Flaherty, Hugues $\mathrm{L} .$ de Cougny, Carlo L. Bottasso, and Can Özturan.并行自动网格生成和自适应网格控制。In M. Papadrakikis, editor, Parallel Solution Methods in Computational Mechanics.John Wiley\& Sons, 1997 .

[sgi96] SGI标准模板库程序员指南。http://www.sgi. com/Technology/STL, since 1996 .(最后一次访问: $01 / 2000$ )。

[She96] Jonathan R. Shewchuk.三角形。设计一个 $2 \mathrm{D}$ 优质网格生成器和Delaunay Triangulator。在明 $\mathrm{C}$ 。Lin和Dinesh Manocha，编辑，应用计算几何学。迈向几何工程，《计算机科学讲座》第1148卷，第203-222页。Springer-Verlag，1996年5月。来自第一届ACM应用计算几何学研讨会。

[She99] Jonathan R. Shewchuk.Triangle:A two-dimensional quality mesh generator. http: / /www.cs.cmu edu/ quake/triangle.html, 1999 .

[SL98] Jeremy G. Siek 和 Andrew Lumsdaine.矩阵模板库:高性能数值线性代数的通用编程方法。在第二届面向对象的并行环境中的国际科学计算（ISCOPE'98）会议上，《计算机科学讲座》第1505卷，第 $59-70,1998$ 页。

[Son93] Thomas Sonar.论一般三角形上可压缩流的上风方案的设计.Numerical Algorithms, $4: 135-149,1993$ 。

[SR97] Thomas Schmidt 和 Roland Rühle.用于有限体积方法的可视化和调试的面向对象的工具。In Winter School of Computer Graphics '97 Conference Proceedings, Plzen, Czech Republic, $1997 .$.

[SS95] 阿尔-史蒂文斯和亚历山大-斯捷潘诺夫。阿尔-史蒂文斯采访亚历山大-斯捷潘诺夫。多布斯博士杂志，三月 $1995 .$

[Ste96] Alexander A. Stepanov.通用编程。In D. Bjørner, M. Broy, and I. V. Pottosin, editors, Perspectives of System Informatics, volume 1181 of Lecture Notes in Computer Science, page 40.Springer Verlag, $1996 .$ [Str97] Bjarne Stroustrup.The C++ Programming Language:第三版。Addison-Wesley Publishing Co., Reading, Mass., $1997 .$ 。

[Szy98] Clemens Szyperski.Component Software: Beyond Object-Oriented Programming.ACM Press and Addison-Wesley, New York, N.Y., 1998 .

[Tan95] Andrew S. Tanenbaum.Distributed Operating Systems.Prentice Hall, $1995 .$ 。

[TGE97] Christian Teitzel, Roberto Grosso, and Thomas Ertl.离散网格上非稳定流中粒子追踪的高效和可靠的集成方法。In W. Lefer and M. Grave, editors, Eighth Eurographics Workshop on Visualization in Scientific Computing, pages 49-56.The EuroGraphics Association, 1997 .

[The00] GCC团队。GCC主页。http://gcc.gnu.org/，2000年。（最后一次访问 $01 / 2000)$ 。

[Tho99] Joe F. Thompson，编辑。电网发电手册》。CRC出版社，$1999 .$ 。

[Tor97] Eleuterio F. Toro.流体动力学的黎曼求解器和数值方法.斯普林格出版社，$1997 .$ 。

[TWM85] Joe F. Thompson, Zahir U.E. Warsi, and Charles W. Mastin.Numerical grid generation.North-Holland, $1985 .$.

[Val90] Leslie G. Valiant.并行计算的桥接模型。通信 $A C M, 33(8): 103-111$ , 1990年8月。

[Vel95a] Todd L. Veldhuizen.表达式模板。  $C++$ 报告，$7(5): 26-31$ ，1995年6月。转载于C++ Gems, ed.Stanley Lippman.

[Vel95b] Todd L. Veldhuizen.使用C++模板元程序。  $C++$ 报告，$7(4): 36-43$ ，1995年5月。转载于C++ Gems, ed.Stanley Lippman.

[Vel99a] Todd L. Veldhuizen.Blitz++主页。http://oonumerics.org/ blitz/index.html， $1999 .$

[Vel99b] Todd L. Veldhuizen.作为部分评价的C++模板。在 $A C M S I G$ PLAN部分评价和基于语义的程序操纵研讨会 $\left(P E P M^{\prime} 99\right), 1999 .$ 中。

[Vel99c] Todd L. Veldhuizen.Techniques for scientific C++. http://extreme. indiana.edu/ tveldhui/papers/techniques/, August $1999 .$

[VG98] Todd L. Veldhuizen和Dennis Gannon。活动库。重新思考编译器和库的作用。In Proceedings of the SIAM Workshop on Object Oriented Methods for Inter-operable Scientific and Engineering Computing（OO'98）.SIAM出版社，1998年。  [VJ97] Todd L. Veldhuizen和M. Ed Jernigan.C++会比Fortran快吗？In Proceedings of the 1st International Scientific Computing in ObjectOriented Parallel Environments (ISCOPE'97), Lecture Notes in Computer Science.Springer-Verlag, 1997 .

[Wal99] Chris Walshaw.JOSTLE主页。http://www.gre.ac.uk/ jostle, $1999 .$ (最后访问: $11 / 1999$ ) 。

[WD97] R. Clint Whaley and Jack J. Dongarra.自动调整的线性代数软件.技术报告UT-CS-97-366，田纳西大学计算机科学系，1997年12月。

[Wei98] Karsten Weihe.关于算法的软件工程观点。技术报告50，康斯坦茨大学，1998年1月。

[Wie94] Monika Wierse.在非结构化网格上的高阶上风方案，适用于与时间有关的几何形状中的可压缩欧拉方程 $3 D$ 。弗莱堡大学博士论文，1994年9月。

[Wie97] Christian Wieners.四面体、金字塔、棱柱和六面体上的符合离散化。技术报告SFB 404预印本 $97 / 15$ ，斯图加特大学，1997年。

[WL96] Gregory V. Wilson和Paul Lu，编者。使用C++的并行编程.麻省理工学院出版社，1996年。

[Wol98] Alex Wolfe.美国开始通往30TFlops计算机的道路。HPCU新闻, $1(3)$ , 1998年1月。

[YFD97] T.-Y.Brian Yang, Geoffrey Furnish, and Paul F. Dubois.指导面向对象的科学计算。在 $R$ .Ege, M. Singh, and B. Meyer, editors, Proceedings.面向对象语言和系统的技术，TOOLS-23，第112-119页，1109 Spring Street, Suite 300 , Silver Spring, MD 20910, USA, 1997。IEEE计算机学会出版社。

[Zie94] Günter M. Ziegler.多角形讲义》，《数学研究生教材》第152卷。Springer-Verlag, Heidelberg, $1994 .$ 。

[Zom96] Albert Y. Zomaya，编辑。并行和分布式计算手册.McGraw Hill, New York, 1996 .



[Fig2.1]: https://cdn.mathpix.com/snip/images/SadrbZgvOVD-gGsE5HpYTv2D39hEB-7ZqDw6n48JEoQ.original.fullsize.png
[Fig3.1]: https://cdn.mathpix.com/snip/images/S4HADPj8rWQ1gSVSMVyz10IUrvMgaz-YZN8xRS0GazM.original.fullsize.png
[Fig3.2]: https://cdn.mathpix.com/snip/images/ejFU1JNRQuRgMlUx7ny4PG1CZlKOVXrbCk6fw1QD18Q.original.fullsize.png
[Fig3.3]: https://cdn.mathpix.com/snip/images/69uFadj55go28UXC3jnfkU_rIXVxOHAZnBM178Zh6BM.original.fullsize.png
[Fig3.4]: https://cdn.mathpix.com/snip/images/q43C7FmM9EB8kLOCDwAKxIaKzDuOp6IcGAriUyE3gbg.original.fullsize.png
[Fig3.5]: https://cdn.mathpix.com/snip/images/QNK0hrRctL0HSjqa5tNbeglZqxO76S0IlxpRGQbCTQ4.original.fullsize.png
[Fig3.6]: https://cdn.mathpix.com/snip/images/bUv2_ngB_8eUvyoz1Vcy8IiF4B5fIpOrMBT6zv11LB8.original.fullsize.png
[Fig4.1]: https://cdn.mathpix.com/snip/images/hk-94D86gok23p4tddt8jSWjzfdR_lbqlxIPJHgSaZo.original.fullsize.png
[Fig4.2]: https://cdn.mathpix.com/snip/images/TYByFfkTnuVnRP2Dc1wDsRSIRIbQg_ECjDEYbi90SSA.original.fullsize.png
[Fig4.3]: https://cdn.mathpix.com/snip/images/laYuV952_w5cXEViS6NYMr22PXvwUImaqLJgfxdgLek.original.fullsize.png
[Fig4.4]: https://cdn.mathpix.com/snip/images/YUHZGY_tUJdBuiz6L7KyDHVZO9AfjxHr2Wzc_1D967s.original.fullsize.png
[Fig4.5]: https://cdn.mathpix.com/snip/images/dAm8TxCm-e4uHSfyFGKtaxrKiXDTnvThJHbJJ2B_k14.original.fullsize.png
[Fig4.6]: https://cdn.mathpix.com/snip/images/YAX4nsmDQaeqEYpXLe5aGAAWCl4OrmpCMxGcr5afztg.original.fullsize.png
[Fig4.7]: https://cdn.mathpix.com/snip/images/q71mTTCvVILigOQDb_OfjNMV_xpwZG6f_2kGz2SrPuI.original.fullsize.png
[Fig4.8]: https://cdn.mathpix.com/snip/images/zM-wMT2KMl5kB8dtVcIY8x8Qy9YXyuZ8-nyb9oNxehY.original.fullsize.png
[Fig5.1]: https://cdn.mathpix.com/snip/images/UmgyMTeqc9dfD5uhPfCVL1ShqMFUsScgaTP07hPDVO0.original.fullsize.png
[Fig5.2]: https://cdn.mathpix.com/snip/images/XRs7VtzSZDW-CAs-8pAbub0zMQVW7q5L-0l7fn4K02w.original.fullsize.png
[Fig5.3]: https://cdn.mathpix.com/snip/images/0zuvvHxr9avtcKdOxVCll74iV8LNoLt4AL8PbZ-EFfk.original.fullsize.png
[Fig5.4]: https://cdn.mathpix.com/snip/images/i0vW3f8Nw1NIHagU6UifUrx7wxQ5ZjHmBTVGhxP0hBE.original.fullsize.png
[Fig5.5]: https://cdn.mathpix.com/snip/images/qOKVrlJfOpSyWs07ra_y4oBlbNkWaCEm2qCqGMPwvP0.original.fullsize.png
[Fig5.6]: https://cdn.mathpix.com/snip/images/n4rUAv5UuSL_uyMxsISywX02rCvxrzvg_1ouz5FKoVA.original.fullsize.png
[Fig5.7]: https://cdn.mathpix.com/snip/images/vS7jZR0fcRBtLVZNIbnBOJApDM6urzedYQl4xsmv3ZA.original.fullsize.png
[Fig5.8]: https://cdn.mathpix.com/snip/images/pOzdeuCGyHujCXaV_CeYZw1zMujQj4vZdxP00ruWtp8.original.fullsize.png
[Fig5.9]: https://cdn.mathpix.com/snip/images/Log93KgzcJg8oAUnkRSXjVQLoz-Ong5ISU0L3j0q0UA.original.fullsize.png
[Fig5.10]: https://cdn.mathpix.com/snip/images/vK_5-xyB0omoeODaP4pFskiA1WZwFmyac7w1EUAOFvU.original.fullsize.png
[Fig6.1]: https://cdn.mathpix.com/snip/images/cvxX8Lsc8bZpZf4up62kuXsIHPjLH2x0SRlzaXPd5Os.original.fullsize.png
[Fig6.2]: https://cdn.mathpix.com/snip/images/1pJl2MBN6dzeX8VryKwdzip_jiVmDMg0NZMy4gRXcNo.original.fullsize.png
[Fig6.3]: https://cdn.mathpix.com/snip/images/AtZoT8i4w5uRGtBtoQa0m93NsNdOEfnpDFyukCXZxjY.original.fullsize.png
[Fig6.4]: https://cdn.mathpix.com/snip/images/iomKwC7dikrVHM-zhWi0JZBBik25mJj0G-KduWwsm9o.original.fullsize.png
[Fig6.5]: https://cdn.mathpix.com/snip/images/fzYzF7C9wc7sHb5D6ne_Eib7PspPuseq9MTDOnKkN4M.original.fullsize.png
[Fig6.6]: https://cdn.mathpix.com/snip/images/Cl7lYnI8SCYB1m3Zym8h_xCHH--HYX233-T0n8VO4GU.original.fullsize.png
[Fig6.7]: https://cdn.mathpix.com/snip/images/4y5s0fdeqxXCtvRih6vBLeIWzawPM80LpxGJMmz6XTI.original.fullsize.png
[Fig6.8]: https://cdn.mathpix.com/snip/images/K1XLvieH_K7vKNzDFNr3W80YdDgeGYJuBrA7DxHK124.original.fullsize.png
[Fig6.9]: https://cdn.mathpix.com/snip/images/Y5lRo0jTUKqYphhcjaZExXiCR4Fexssl7ZJ3EsUfxow.original.fullsize.png
[Fig6.10]: https://cdn.mathpix.com/snip/images/f51oKmKEnOtR1dXVoA4DkCClCv6T9sn5f2ECPF8b68I.original.fullsize.png
[Fig6.11]: https://cdn.mathpix.com/snip/images/hXTGxMyCzoXDGkprem1MXh5joB8QA63OcFzBMIBsiH0.original.fullsize.png
[FigB.1]: https://cdn.mathpix.com/snip/images/K5zUZMqsFqZTDRWQrvM_JtX1xd24_yBiZBIwW3m_tFU.original.fullsize.png
[FigB.2]: https://cdn.mathpix.com/snip/images/Skr8kndpZEJKlfNJQ2lfWEcC2AQb4uz9vsKHvh8t3Yw.original.fullsize.png
[FigB.3]: https://cdn.mathpix.com/snip/images/K4xpX2S_NxIXHwVI3ekBh-1GdXx70OidO2n0TvEN7Jg.original.fullsize.png