\title{
DUNE -
分布式和
统一数字环境
环境
}


\author{
Oliver Sander\\
翻译： Jiaqi-2021-8-17
}



\section{Introduction}

这是一本关于DUNE软件系统的书。DUNE，`Distributed and Unified Numerics Environment`，是一个$\mathrm{C}++$库的集合，用于有限元（FE）和有限体积（FV）方法的不同方面。它是在开放源码许可下发布的，允许获取和查看源代码，并根据自己的需要进行修改。DUNE库被称为 `modules` 。它们形成了一个相互依赖的网络，但必须单独下载和安装。  [Fig1.1]显示了本书所涉及的模块集，尽管还有很多。

DUNE项目由`Peter Bastian`于2003年启动，旨在落实他在共同开发成功的UG3模拟代码[^13]时所获得的经验。早期，其他人也开始做出贡献，开发模式很快就像项目名称所暗示的那样`distributed`了。今天，DUNE主要被许多人用于学术研究，并以经典的集市式自由软件方式开发。主要的联系点是项目网站www.dune-project.org，它是协调项目发展的地方。该网站提供通常的功能，如软件下载、保存源代码和错误跟踪器的GITLAB实例、邮件列表和详细的类文档。该网站是用户和开发者应该去获得进一步信息的地方。

\subsection{The Case for Standardization}

编写DUNE的时候，考虑到有限元和有限体积代码的某些部分的标准化应该是可能的。

在过去的几十年里，有限元和有限体积方法的计算机代码大量涌现。在撰写本文时，WIKIPEDIA大约列出了45个代码，但在页面历史中还提到了更多的代码。这些程序的列表中，有的是由某个研究单位的少数人开发的小型研究代码，有的是由拥有大量第三方用户的大型团队开发的综合性强大软件。其中许多代码是在工业界为商业目的开发的，但也有一些来自学术团队的项目，如`DEAL.II` [^8] , `FENICS` [^120] ，以及`FEAP` [^152] 。


由于所有这些程序都实现了类似的算法，它们都需要类似的基础设施。一个有限元代码总是需要网格、形状函数和线性代数。大多数代码还需要离散函数空间，而多进程代码需要有办法将基于网格的数据从一个进程传到另一个进程。这些课题中的许多都是 "已经完成 "的，因为与单纯使用这些课题的人相比，积极研究这些课题的人很少。现在对网格数据结构的研究已经不多。人们不断发明新的有限元，但有限元空间是什么已经很清楚了。因此，用户应该能够使用离散函数进行研究，而不需要考虑实现细节。这并不意味着这些课题一定很容易。像分布式网格上的自适应红绿细化这样的功能是很难正确实现的，因此实际上只有少数代码支持它们。

尽管要求非常相似，但大多数代码仍然对其中的许多特征提供了自己的实现。虽然有些代码确实使用了线性代数的专用外部库，但几乎所有的代码都实现了自己的网格数据结构、形状函数和离散函数空间。这种方法的缺点是双重的。一方面，它绑定了资源。需要宝贵的开发人员时间来实现、调试和维护这些数据结构。另一方面，结果有可能不尽如人意。因为主要的开发者的兴趣在其他地方，所以可能会缺少一些功能，或者实现的质量较差。

DUNE的中心思想之一是，标准化可以在这方面有所帮助。首先，标准化是可能的，因为如上所述，有限元代码的各个方面原则上已经 "完成 "并达成一致。标准化可以节省开发时间，因为花在重新发明其他代码已经发明的轮子上的时间更少。同时，标准化的组件将更加强大，质量更好，因为它们被更多的人使用，因此可以期待得到更多开发者的关注：一个真正好的组件取代了几个竞争性的不那么好的组件。

除了这些技术上的优势，标准化也有利于知识的转移，因为标准化的组件形成了共同的知识，被更多的人所分享。这意味着，不同模拟代码的程序员之间的对话变得更容易。另外，人们可以更容易地从开发一个特定的模拟代码转向另一个，因为他们在新工作中需要学习的新东西更少。当然，在不同的模拟项目之间共享代码也变得更容易。

关于低级标准化的好处，一个很好的例子是用于分布式计算机上消息传递的MPI标准。在MPI出现之前，许多不同的实施方案提供了低级别的通信和消息传递。这些实现中有许多是由硬件供应商提供的，它们是闭源的，并针对特定的硬件进行了优化。被期望在一系列不同的硬件平台上运行的代码不得不应对这些实现、不同的编程接口和特异性的问题。例如，直到2014年，上述的UG3代码包含了八个不同的后端，用于不同的通信层。当人们意识到所有这些通信库都实现了类似的东西，并且问题空间已被充分理解，可以将所有必要的功能隐藏在一个共同的接口后面时，情况就发生了变化。结果就是MPI标准，它慢慢地取代了所有竞争的方法。虽然MPI可能有一些不喜欢的地方，但很少有人会质疑它的引入使分布式科学计算更简单、更有成效的说法。这也是DUNE的目标。

\subsection{Goal of the Book}

写这本书是为了教人们如何使用DUNE来编写自己的模拟代码。它试图针对两类人。首先，是那些还没有使用DUNE的人，他们想尝试一下。对于这些人来说，本书的部分内容是以教程的方式写的。介绍性的第3章展示了如何解决第一个有限元和有限体积问题，在全书中，有一些章节解释了完整的例子，展示了DUNE的特定方面。这些章节的标题都是以 "实例："开头。初次接触DUNE的人，或者想用它来快速解决某个PDE问题的人，应该从阅读第3章开始，看看感兴趣的例子章节，并阅读关于`dune-functions`和`dune-pdelab`模块的第10章和第11章。然后，他们应该能够决定DUNE是否是满足他们需要的正确工具。

另一方面，本书的目标读者也是已经对DUNE有了一定的了解，并希望了解更多。对于这些人来说，本书包含了大致上专门针对各个模块的章节。这些章节提供了这些模块中所使用的概念的背景信息，并试图在一定程度上系统地介绍这些接口。在这些部分，本书更具有 "参考 "的味道。然而，请注意，"系统地 "并不意味着 "完整"。DUNE的内容比本书所涉及的更多；要想获得更完整的观点，请查阅项目网站www.dune-project.org 上的在线文档。DUNE生态系统的一些最新发展在 [^17] 中有所描述。

DUNE旨在作为最高复杂度和最大规模的数值模拟的基础设施。然而，在本书中只有相当简单的例子：`Poisson`方程、`Stokes`问题、`p-Laplace`等，而且都只在二维域上。原因是这本书应该提供信息而不是留下印象。每个例子都显示了DUNE的一个特定方面，不必要的复杂的例子程序只会分散人们对要点的注意力。要想看到DUNE软件的令人印象深刻的应用，我们建议去搜索研究文献。

与此相关的是，细心的读者会注意到，高性能计算（HPC）从未被提及，尽管它是DUNE开发的特意目标之一。第6章描述了如何与分布式网格一起工作，但没有提到其他HPC技术。HPC的其他方面最近也在DUNE中得到了极大的关注[^18] [^19] ，但其结果还不够成熟，无法在书中描述它们。

\subsection{Structure of the Book}

本书分为三个部分。第一部分包括第2至4章，讨论介绍性材料。第2章回顾了有限元和有限体积方法，这是设计DUNE的动机所在。该章的论述是简短和肤浅的，任何对这些方法感兴趣的人在深入研究专门的教科书和研究文献之前，只应把该章作为一个起点。不过，它还是给出了一些与这些方法的实现有关的细节，这些细节通常在教科书中找不到。

第三章是关于如何开始使用DUNE的教程。对于从来没有使用过DUNE的人来说，这是开始阅读的地方。它简要地展示了如何安装DUNE和创建DUNE模块。然后，它介绍了`Poisson`方程的有限元代码的完整实现，以及传输方程的有限体积方法。



本书的以下部分由第$5-9$章组成，讨论了各个DuNE模块。正如DUNE模块之间只是松散的耦合，这些章节中的大部分可以独立阅读。第5章和第6章涉及DUNE网格界面。这是DUNE的历史和概念中心。这两章解释了什么是DUNE网格，编程界面是什么样的，以及如何使用它。它还介绍了一些目前可用的网格实现。这些章节中讨论的代码包含在DUNE模块 `dune-grid` 和 `dune-geometry` 中。第5章介绍了单进程情况下的网格接口。第6章展示了这些想法是如何扩展到分布在多个进程中的网格。

下一章介绍了DUNE的线性代数实现，包含在模块`dune-istl`中。虽然有几个好的线性代数实现，但`dune-istl`有几个有趣的功能，特别是针对有限元和有限体积计算。例如，它允许嵌套任意的向量和矩阵类型，以便给编译器提供尽可能多的关于稀疏线性代数问题的阻塞和稀疏结构的信息。它还包含一个强大的、高度可扩展的代数多网格预处理程序的实现。

第8章介绍了`dune-localfunctions`模块，它收集了单元素的有限元基础。文中描述了`dune-localfunctions`为这类有限元提供的接口，并解释了目前可用的几个元素。`dune-localfunctions`模块不依赖于`dune-grid`模块，因此如果需要，其有限元可以用于非DUNE网格。

第9章涵盖了数值正交的主题。在DUNE中，没有单独的模块；相反，正交规则是在`dune-geometry`模块中提供的。本章回顾了正交规则构造的几个方面，并解释了DUNE如何提供不同的规则。

前面的模块，有时被称为`DuNE core modules`，主要提供低层次的功能。最后两章，构成了本书的第三部分，提供了更高层次的抽象功能。

第10章介绍了`dune-functions`，该模块提供对函数和离散函数空间的统一访问。函数接口沿用了$\mathrm{C}++$标准库中`std::function`类的方法，但将其扩展到可微函数和定义在有限元网格上的函数。有限元函数的空间是通过指定这种空间的基数来表示的。`dune-functions`模块提供了各种标准基，以及一个强大的机制，可以将更简单的基结合到更复杂的基中。




之前的代码都没有，甚至没有`dune-functions`，包含偏微分方程的汇编程序。第11章中介绍了这种汇编程序的一个实现 `dune-pdelab` 。`dune-pdelab`模块建立在`dune-functions`的基础上，为许多标准的偏微分方程提供汇编程序和求解器。这些程序可以在顺序和分布式机器上工作，并可以与局部网格自适应相结合。用`dune-pdelab`解决PDEs只需要几行$\mathrm{C}++$代码，如果可以使用现有的本地汇编程序之一的话。本章还讨论了编写新的汇编程序。

本书以一个两部分的附录结束。附录A解释了DUNE的构建系统。虽然每个DUNE模块本身使用标准的cmake构建系统，但将不同模块联系在一起的外部逻辑是非标准的，因此需要一些解释。一旦DUNE用户需要超越编写简单的程序，例如，当依赖本地安装的第三方软件时，或编写代码内文档或单元测试时，这些信息就变得很重要。

最后，附录B列出了书中讨论的所有完整的示例程序源代码。C++代码可能相当长，完整的源代码通常不会在讨论它们的章节中显示。但是，特别是对于初学者来说，能够看到所有细节的完整代码是很重要的，因此，它们都被列在附录B中。

\subsection{Source Code in this Book}

这本书包含了大量的源代码；几乎所有的源代码都在 $\mathrm{C}++$ 。一方面，给出了简短的代码片断来演示个别功能。另一方面，也讨论了完整的应用实例。所有的代码都经过测试，可以在DUNE版本$2.7$中运行；如果不是这样，那么书中就有一个错误的印记，我们希望听到它。大多数代码也可能在较新的和稍旧的DUNE版本中运行，可能要经过一些小的调整。以 "示例："开头的章节讨论了完整的示例应用程序。所有这些应用程序都是这样构建的：整个代码都包含在一个文件中，因此只需要这个文件和来自[Fig1.1]的DUNE库来构建和运行这个例子。构建一个特定的例子的最简单的方法是按照第3章的解释设置一个新的Dune模块，将源文件复制到模块的`src`目录，并将其添加到`CMakeLists.txt`文件中。



讨论完整示例文件的章节没有显示完整的源代码。  $\mathrm{C}++$文件的字数非常多，把整个文件打印出来作为讨论的一部分会使文字相当难读。尽管如此，也有必要能够看一下完整的文件。有两种方法可以获得完整的源文件。首先，所有这些文件都印在附录B中。另外，它们被嵌入到本书的电子版本中。右键点击空白处的针状图标可以提供完整的源代码供下载。

在阅读本书的源代码时，应注意以下几点。

- 本书中处理的DUNE模块的所有代码都包含在命名空间Dune中。然而，为了节省空间，我们通常会省略命名空间的前缀。尽管如此，这些示例程序仍然可以工作，因为它们都在文件的顶部附近有这一行。

	~~~C++
	using namespace Dune;
	~~~

- 模块`dune-functions`和`dune-pdelab`中的代码还分别包含在嵌套命名空间`Dune::Functions`和`Dune::PDELab`中。虽然我们省略了外部命名空间Dune的前缀，但我们确实写了内部命名空间，以便给人们一个提示，告诉他们某个特定对象来自哪里。例如，为了声明一个来自`dune-functions`模块的一阶`Lagrangian`有限元基，我们写道

	~~~C++
	Functions::LagrangeBasis<GridView,1> firstOrderLagrangeBasis(gridView);
	~~~

	但这只有在
	~~~C++
	using namespace Dune;
	~~~
之前已被设置。

- 同样地，我们将省略有时需要用来区分嵌套值和嵌套类型的typename和模板指定器。也就是说，我们通常会写

	~~~C++
	template<class GridView>
	struct Foo
	{
    	using Element = GridView::Codim<0>::Entity;
    	[...]
	}
	~~~

	而不是

	~~~C++
	template<class GridView>
	struct Foo
	{
    	using Element = typename GridView::template Codim<0>::Entity;
    	[...]
	}
	~~~

	只有第二个版本是有效的 $\mathrm{C}++$ ，但第一个版本更容易阅读，而且占用的空间更少。

- 在展示类的接口时，我们通常只展示相关的部分。有些类会有额外的方法和输出一些额外的类型。有关所有的细节，请查阅www.dune-project.org 的类文档。如果安装了 `DOXYGEN` 程序，也可以通过调用 make doc 并将浏览器指向 `build-cmake/doc/doxygen/html/index.html` 来创建一个模块的类文档。

- 所有的例子程序都在$\mathrm{C}++$代码中硬连接问题参数。这当然是非常不方便的，这样做只是为了使例子尽可能的简单。`dune-common`模块包含了维护运行时参数树和从文本文件中读取参数的代码，但任何其他将参数引入$\mathrm{C}++$代码的方式都同样有效。

最后，请记住，DUNE是一个正在积极开发的软件。为了能够快速创新并保持代码的简单性，对于API的稳定性只有一些承诺（参见第$4.6$章，了解DUNE团队的承诺）。这意味着本书中的一些信息可能会随着时间的推移而变得过时。同样，关于接口的最新信息，请参考自动创建的类文档，网址是www.dune-project.org。




\section{Mathematical Concepts}


DUNE的设计是为了形成有限元和有限体积方法的实现基础。为了让潜在的用户快速了解这两种方法，我们在这里简要地重温一下。我们坚持基础知识，但试图指出一些影响DUNE设计的特点。对这些方法有更深兴趣的读者应该查阅关于这个主题的众多书籍之一。

\subsection{The Finite Element Method}

有限元方法于20世纪50年代引入工程界，用于解决固体力学问题。教科书[^44]包含了一个历史概述。虽然该方法现在用于所有类型的偏微分方程（PDEs），但它最容易解释的是椭圆方程。

设$\Omega \subset \mathbb{R}^{d}$是一个域，即一个开放的有界集，$f: \Omega \rightarrow \mathbb{R}$是一个具有足够平稳性的给定函数。此外，让$\mathcal{A}: \Omega \times \mathbb{R} \times \mathbb{R}^{d} \rightarrow \mathbb{R}^{d}$是一个一阶椭圆微分算子，而$R: \Omega \times \mathbb{R} \rightarrow \mathbb{R}$是另一个给定函数。我们称$R$为反应项，我们寻找一个函数$u: \Omega \rightarrow \mathbb{R}$来解决方程式

\begin{equation}
-\operatorname{div} \mathcal{A}(x, u, \nabla u)+R(x, u)=f \quad \text { in } \Omega
\label{2.1}
\end{equation}

为了不使这一论述变得过于技术性，我们直接假定算子$\mathcal{A}$和$R$独立于$x$。此外，我们认为它们是线性的，也就是说，有一个向量$\mathbf{v} \in \mathbb{R}^{d}$，一个矩阵$C \in \mathbb{R}^{d \times d}$，和一个数字$r \in \mathbb{R}$，使得

$$
\begin{aligned}
\mathcal{A}(x, u, \nabla u) &=C \nabla u+\mathbf{v} u \\
R(x, u) &=r u
\end{aligned}
$$

那么，模型方程为

\begin{equation}
-\operatorname{div}(C \nabla u+\mathbf{v} u)+r u=f \quad \text { in } \Omega
\label{2.2}
\end{equation}

如果矩阵$C$具有某些特性，该方程就是椭圆的，这些特性在这里并不重要。一般的非线性情况将在第11.2章讨论。

方程\ref{2.2}包括许多相关的偏微分方程。其中一个是`Poisson`方程

$$
-\Delta u:=-\operatorname{div} \nabla u=f
$$

其中$C$是身份，$\mathbf{v}$和$r$为零。其他是线性`reaction-diffusion`方程

$$
-\Delta u+r u=f
$$









其中$r$为非零，而`convection-diffusion`方程为

$$
-\Delta u+\mathbf{v}^{T} \nabla u=f
$$

其中$\mathcal{A}(x, u, \nabla u)=\nabla u+\mathbf{v} u$ 。这些将出现在本书的后面几章。线性弹性方程是对矢量值函数的直接概括 [^37] 。

为了得到一个很好解决的问题，必须应用边界条件。我们假设$\Omega$的边界$\partial \Omega$是由$\Gamma_{D}$和$\Gamma_{N}$（[Fig2.1]）两个不相交的部分组成，我们用$\mathbf{n}$表示对$\partial \Omega$的单位外法向量 。在边界的每一部分，我们描述不同类型的条件。经典的例子是`Dirichlet`边界条件

$$
u=\mathrm{g} \quad \text { on } \Gamma_{D}
$$

和`Neumann`边界条件

$$
\langle(C \nabla u+\mathbf{v} u), \mathbf{n}\rangle=\mathbf{j} \quad \text { on } \Gamma_{N}
$$

偏微分方程与一组边界条件的组合被称为 `a boundary value problem` 。根据方程的确切类型，对于一个良好处理的边界值问题，允许不同类型和组合的边界条件。关于偏微分方程的良好处置的一般介绍，请参见，例如， [^64] 。

\subsubsection{Weak Formulation}

为了明确起见，我们现在考虑椭圆的边界值问题

\begin{equation}
-\operatorname{div}(C \nabla u+\mathbf{v} u)+r u =f \quad \quad \text { in } \Omega 
\label{2.3}
\end{equation}


\begin{equation}
u =g \quad \quad  \text { on } \Gamma_{D} 
\label{2.4}
\end{equation}

\begin{equation}
\langle(C \nabla u+\mathbf{v} u), \mathbf{n}\rangle =\mathbf{j} \quad \quad  \text { on } \Gamma_{N}
\label{2.5}
\end{equation}

这种书写模型问题的方式被称为`the strong formulation` 。它隐含地假设它的解$u$是经典意义上的两次可微。然而，在许多情况下，这样的解并不存在。因此，更自然的是以不同的方式来写这个问题，即所谓的`the weak formulation` 。虽然这种表述有些技术性，但它对解函数的假设较少 $u$ 。

我们希望读者熟悉Sobolev空间理论的基本概念 [^37] [^162] 。用$H^{1}(\Omega)$表示$L^{2}$上所有标量$\Omega$函数的空间，其弱导数在$L^{2}(\Omega)$。作为解决方案的空间，我们引入

$$
H_{D}^{1}(\Omega):=\left\{v \in H^{1}(\Omega):\left.v\right|_{\Gamma_{D}}=\mathrm{g}\right\}
$$

其中$\left.v\right|_{\Gamma_{D}}=\mathrm{g}$应在痕迹的意义上理解。作为一个测试函数的空间，我们引入

$$
H_{\Gamma, 0}^{1}(\Omega):=\left\{v \in H^{1}(\Omega):\left.v\right|_{\Gamma_{D}}=0\right\}
$$

将\ref{2.3}与来自$H_{\Gamma, 0}^{1}(\Omega)$的测试函数$v$相乘，对$\Omega$进行积分，并使用格林定律，我们得到

$$
\int_{\Omega}\langle(C \nabla u+\mathbf{v} u), \nabla v\rangle d x+\int_{\Omega} r u v d x=\int_{\partial \Omega}\langle(C \nabla u+\mathbf{v} u), \mathbf{n}\rangle v d s+\int_{\Omega} f v d x
$$

根据测试函数的结构，我们在 $\Gamma_{D}$ 上有 $v=0$ 。因此，边界积分减少为$\Gamma_{N}$上的积分。在这里，我们可以插入诺伊曼边界条件\ref{2.5}，得到

$$
\int_{\Omega}\langle(C \nabla u+\mathbf{v} u), \nabla v\rangle d x+\int_{\Omega} r u v d x=\int_{\Gamma_{N}} \mathrm{j} v d s+\int_{\Omega} f v d x
$$

这必须对所有的 $v \in H_{\Gamma, 0}^{1}$ 保持不变。这被称为 `the weak formulation` （或 `variational formulation` ）的边界值问题 [^37] [^42] [^63] 。请注意，它只假设$u$是`once`弱可微。这与强形式\ref{2.3}形成对比，其中$u$必须是两次经典可微，方程才有意义。

弱表述通常以更短的方式书写。鉴于双线性形式

$$
a(u, v):=\int_{\Omega}\langle(C \nabla u+\mathbf{v} u), \nabla v\rangle+r u v d x
$$

和线性形式

$$
l(v):=\int_{\Gamma_{N}} \mathrm{j} v d s+\int_{\Omega} f v d x
$$





找到$u \in H_{D}^{1}(\Omega)$，使得

\begin{equation}
a(u, v)=l(v) \quad \forall v \in H_{\Gamma, 0}^{1}(\Omega)
\label{2.6}
\end{equation}

通过消除仿生空间$H_{D}^{1}:$进一步简化，让$u_{\mathrm{g}}$是$H_{D}^{1}$中的任何函数，即$H^{1}(\Omega)$中满足`Dirichlet`边界条件的函数。那么，弱表述\ref{2.6}等价于找到$\tilde{u} \in H_{\Gamma, 0}^{1}$，以便

$$
a(\tilde{u}, v)=l(v)-a\left(u_{\mathrm{g}}, v\right) \quad \forall v \in H_{\Gamma, 0}^{1}(\Omega)
$$

事实上，$u:=\tilde{u}+u_{\mathrm{g}}$将解决原问题。因此，在向量空间$H_{\Gamma, 0}^{1}$中寻找解决方案就足够了。用$u$代替$\tilde{u}$，用$l(v)$代替$l(v)-a\left(u_{\mathrm{g}}, v\right)$，因此我们从现在开始考虑以下问题。找出$u \in H_{\Gamma, 0}^{1}$，以便于

\begin{equation}
a(u, v)=l(v) \quad \forall v \in H_{\Gamma, 0}^{1}(\Omega)
\label{2.7}
\end{equation}

在对双线性形式的某些假设下，这个问题有一个唯一的解决方案 $a(\cdot, \cdot)$ 。关于存在性和很好解决性的结果，请参见专著，如 [^37] [^63] [^64] 。

\subsubsection{Discretization by Finite Element Methods}

这个弱的公式构成了有限元方法的起点。为了使问题可以通过数值算法来解决，我们用一个有限维的子空间来取代空间$H_{\Gamma, 0}^{1}$。这种近似被称为`Galerkin discretization` 。

让$V_{h}$是$H^{1}$的一个有限维子空间。下标$h$传统上用来表示与这种空间有关的对象。一旦引入$\Omega$的网格，$h$就被解释为元素大小的量度。与\ref{2.7}相对应的离散的`variational formulation`是要找到一个$u_{h} \in V_{h} \cap H_{\Gamma, 0}^{1}$，以便

\begin{equation}
a\left(u_{h}, v_{h}\right)=l\left(v_{h}\right) \quad \text { for all } v_{h} \in V_{h} \cap H_{\Gamma, 0}^{1}
\label{2.8}
\end{equation}

的形式$a(\cdot, \cdot)$和$l(\cdot)$如前。我们希望$u_{h}$的解是\ref{2.7}的解$u$的近似值，近似质量取决于空间$V_{h}$。

设$\left\{\phi_{i}\right\}_{i=0}^{n-1}$是$V_{h} \cap H_{\Gamma, 0}^{1}$的一个基础。那么\ref{2.8}相当于找到一个$u_{h} \in$$V_{h} \cap H_{\Gamma, 0}^{1}$，其中有

$$
a\left(u_{h}, \phi_{i}\right)=l\left(\phi_{i}\right) \quad \text { for all } 0 \leq i<n
$$

这又等同于线性方程组

\begin{equation}
A \bar{u}=b
\label{2.9}
\end{equation}






其中

$$
\begin{aligned}
&A \in \mathbb{R}^{n \times n}, \quad A_{i j}:=a\left(\phi_{i}, \phi_{j}\right)=\int_{\Omega}\left\langle\left(C \nabla \phi_{i}+\mathbf{v} \phi_{i}\right), \nabla \phi_{j}\right\rangle d x+\int_{\Omega} r \phi_{i} \phi_{j} d x \\
&b \in \mathbb{R}^{n}, \quad b_{i}:=l\left(\phi_{i}\right)=\int_{\Gamma_{N}} \mathrm{j} \phi_{i} d s+\int_{\Omega} f \phi_{i} d x
\end{aligned}
$$

和 $\bar{u} \in \mathbb{R}^{n}$ 是 $u_{h}$ 相对于基 $\left\{\phi_{i}\right\}$ 的系数。矩阵 $A$ 被称为 `stiffness matrix` 。这种表达方式来自于早期对固体力学问题的有限元方法的使用。在这种情况下，$A$描述了模拟物体的刚度，而矢量$b$描述了外部载荷。

在没有进一步假设的情况下，矩阵$A$是密集的，即$A$的几乎每个条目都是非零的。处理这样的矩阵是非常昂贵的，因为时间和空间要求随着$V_{h}$的维度呈四次方增长。有限元通过使用近似空间和相应的基数来解决这个问题，从而导致稀疏的刚度矩阵。换句话说，有限元是选择子空间的一种特殊方式 $V_{h}$ 。

为简单起见，假设$\Omega$的边界是一个（可能是非凸的）多面体。有限元方法通过引入`grid`，即把$\Omega$分割成称为`elements`的简单凸子来构造近似空间$V_{h}$。

\textbf{Definition} 2.1 $A$ 封闭的凸多边形$T$的集合$\mathcal{T}$被称为$\Omega$的符合网格，如果以下条件成立。

1.(分割）多面体的联合是域的闭合

$$
\bar{\Omega}=\bigcup_{T \in \mathcal{T}} T
$$


2.(符合性）来自$\mathcal{T}$的两个多面体的交点要么是低维的公共面，要么是空的。

在本书的其余部分，一个$d$维的多面体的面可以有任何小于或等于$d$的维。我们用 "面 "这个词来表示维度为$d-1$的面。

在最简单的情况下，一个网格的所有元素都是简单的。这样一个网格的例子显示在 [Fig2.2] 。然而，带有四边形或六面体元素的网格也很常见，而三维网格可能包含棱柱和金字塔（也见[Fig2.2]）。

虽然这里给出的网格定义是典型的教科书上的定义，但对于许多应用来说，它实际上限制性太强，实践者们已经使用了更普遍的计算网格的结构。例如，像`Virtual Element Method`[^21]和`Mimetic Finite Differences`[^119]这样的方法使用任意多边形作为元素[Fig2.3]（a），甚至可能是非凸的。另外，$\Omega$应具有片状平坦边界的要求在实践中往往不能满足。因此，用多角形元素来逼近这样一个域会导致误差。这种误差是可以被约束的（例如，见[^42]）；尽管如此，已经提出了使用多项式函数下的多边形图像作为元素的网格[^67] [^69] [^166] （[Fig2.3] (b)）。另外，今天许多感兴趣的PDEs不是在`Euclidean`空间的开放集上提出的，而是在这种空间的低维集上提出的。这些低维集合可能具有流形结构[^60]，但它们也可能表现出网络拓扑结构[^38][^125]（[Fig2.3]（c））。

最后，各种方法如`Discontinuous Galerkin`（第11.2.6章）或有限体积（第2.2章）方法放弃了定义$2.1$的一致性要求。然后，两个元素的交叉点可能是共同的低维面的真实子集 [^134] ( [Fig2.3] (d) 和 (e) ) 。这可以大大简化网格的构造，而不会使数值方法更加复杂。给出一个也包括所有这些情况的网格的精确定义是很困难的。一个尝试可以在 [^16] 中找到。

另一方面，各种网格的结构也比定义2.1所要求的要多。作为一个重要的例子，在[Fig2.3](e)和(f)中的网格，所有的元素面都垂直于一个坐标轴。这可以被实现者利用来进行额外的高效元素法线和体积计算。

现在的有限元方法将离散空间$V_{h}$构建为相对于网格的片状多项式的函数空间。最简单的是单数网格上的`Lagrange`元素。

\textbf{Definition} $2.2$ 让网格$\mathcal{T}$仅由单数元素组成，让$\Pi_{p}$为所有阶数不高于$p$的d变量多项式的集合。那么

$$
V_{h}^{(p)}:=\left\{v \in C(\bar{\Omega}):\left.v\right|_{T} \in \Pi_{p} \quad \forall T \in \mathcal{T}\right\}
$$

被称为相对于网格$p$的第`Lagrange`阶元素的空间 $\mathcal{T}$ 。

这是一个有限维向量空间，它确实是H的一个子空间 [^37] 。  [Fig2.4]显示了来自$V_{h}^{(1)}$和$V_{h}^{(2)}$的函数实例。











文献中出现了大量的备选有限元空间。最佳选择取决于方程、网格和所需的精度。这些空间主要在每个元素的多项式空间的类型和元素间的连续性要求方面有所不同。第8章解释了一些，它涉及到这些空间如何在DUNE中实现。对于一个更长的列表，请看 [^106] 。

代数系统 \ref{2.9} 需要选择 $V_{h}$ 的基。`Lagrange`空间的典范基础是`nodal basis` 。在每一个元素上定义一组无遮挡的`Lagrange`节点（[Fig2.5]），并在相邻元素的共同边界上确定相应的节点。让$\mathcal{V}$为整个网格的`Lagrange`节点集。那么`nodal basis`就是具有以下特征的函数$\phi_{i} \in V_{h}^{(p)}$的集合

$$
\phi_{i}\left(a_{j}\right)=\delta_{i j} \quad \text { for all } a_{j} \in \mathcal{V}
$$

$\delta_{i j}$ 表示`Kronecker` 符号。[Fig2.6]中显示了三个用于一阶和二阶空间的此类函数。

对于实现有限元方法来说，必须注意到`nodal basis`空间的`Lagrange`函数可以通过相应的`Lagrange`节点的位置与网格中的元素面相关联。根据基函数的`Lagrange`节点是在元素的`interior`中，还是在面或顶点上，等等，基函数本身被关联到元素、面或顶点。这种想法也适用于许多其他空间。它在有限元的实现中形成了一个重要的装置，有助于组织不同的基函数。这个概念在第 $8.2$ 章中再次出现。

`nodal basis`函数最重要的属性是其支持的位置性。事实上，如果一个给定的基函数$\phi_{i}$属于一个元素的`Lagrange`节点，那么它在所有其他元素上是零。同样，如果它属于被一些元素共享的`Lagrange`节点，那么$\phi_{i}$将只在这些元素上非零。因此，矩阵条目

$$
A_{i j}:=a\left(\phi_{i}, \phi_{j}\right)=\int_{\Omega}\left\langle\left(C \nabla \phi_{i}+\mathbf{v} \phi_{i}\right), \nabla \phi_{j}\right\rangle d x+\int_{\Omega} r \phi_{i} \phi_{j} d x
$$

只有当基函数$\phi_{i}$和$\phi_{j}$属于相同或相邻的元素时，才是非零。矩阵$A$为`sparse` ，线性系统（2.9）变成了稀疏线性系统

\begin{equation}
A \bar{u}=b
\label{2.10}
\end{equation}

这是一个重要的特性。只有在稀疏矩阵的情况下，即使是高分辨率的有限元网格，工作量也是可控的。

有限元方法的最后一步是求解线性系统\ref{2.10}，求解函数$u_{h}$的系数$\bar{u} \in \mathbb{R}^{n}$相对于有限元基$\left\{\phi_{i}\right\}_{i=0}^{n-1}$。即使$A$是稀疏的，这也可能是一项艰巨的任务。根据网格和有限元空间的不同，矩阵$A$可以变得非常大。在开发此类线性系统的快速求解器和预处理器方面已经投入了大量的精力，此类求解器是任何有限元软件的一个组成部分。非常大的问题通常不适合单个计算节点的内存；因此，除非使用像[^114]这样的无矩阵方法，否则矩阵将不得不分布在几个计算节点上，并进行并行组装。因此，解决方案的算法也必须针对并行架构进行设计和实施。

\subsubsection{Computing the `Stiffness Matrix`}

前面对有限元方法的介绍表明，网格的数据结构、函数空间基和稀疏线性代数必须是任何有限元实现的核心组成部分。这三个概念特别是在代数系统$A$的刚度矩阵$b$和载荷矢量\ref{2.10}的设置中相互影响。这个过程，传统上称为 `assembly` ，因此是数据结构设计的主要驱动力之一。DUNE的许多设计选择只有在对有限元装配的工作原理有一定了解的情况下才能理解，因此我们仔细研究一下。

让$n$为空间$V_{h}$的维度。那么刚度矩阵$A$是一个稀疏的$n \times n$矩阵，其条目为

\begin{equation}
A_{i j}:=a\left(\phi_{i}, \phi_{j}\right)=\int_{\Omega}\left\langle\left(C \nabla \phi_{i}+\mathbf{v}\right), \nabla \phi_{j}\right\rangle+r \phi_{i} \phi_{j} d x
\label{2.11}
\end{equation}

相应地，负载向量$b$有条目

$$
b_{i}:=l\left(\phi_{i}\right)=\int_{\Gamma_{N}} \mathrm{j} \phi_{i} d s+\int_{\Omega} f \phi_{i} d x, \quad i=0, \ldots, n-1
$$

在这些简单的例子中，指数$i, j$是自然数。然而，考虑具有块状结构的矩阵也是有意义的，使用多指数对行和列进行编号（10.2.4章）。

\textbf{Element Stiffness Matrices and Load Vectors}

在模型问题中，每个载荷向量条目$b_{i}$是域上的积分和域边界的积分之和。矩阵条目仅由域上的积分组成，但更高级的离散化也可以包含其他条款。所有的项都可以通过对网格元素进行求和来计算

\begin{equation}
A_{i j} =\sum_{T \in \mathcal{T}} \int_{T}\left\langle\left(C \nabla \phi_{i}+\mathbf{v}\right), \nabla \phi_{j}\right\rangle+r \phi_{i} \phi_{j} d x 
\label{2.12}
\end{equation}


\begin{equation}
b_{i} =\sum_{T \in \mathcal{T}}\left[\int_{T \cap \Gamma_{N}} j \phi_{i} d s+\int_{T} f \phi_{i} d x\right]
\label{2.13}
\end{equation}

然而，天真地使用这些表达式并不能带来有效的算法。首先，由于基函数$\phi_{i}$的支持度很小，\ref{2.12}和\ref{2.13}中的大多数元素积分无论如何都会是零。绕过循环更有效。对于每个元素$T$引入其支持与$T$以非微妙方式相交的基函数$\left\{\phi_{p}\right\}_{p=0}^{n_{T}-1}$的集合。然后，代数问题可以用下面的[算法]来组合。

[算法]: https://cdn.mathpix.com/snip/images/wSGACKggPcMiYjVT_kEc8Mk4mALip82Fcv2mRztlP90.original.fullsize.png





以这种方式编写，组装整个代数问题所需的工作是与网格元素的数量成线性关系。

为了实现这种算法，软件基础设施必须允许某些事情。首先，必须能够以某种顺序对所有网格元素进行迭代。这已经是很重要的一点了。虽然随机访问网格元素看起来很方便，但对于有限元方法来说，这几乎是不需要的。这一事实直接反映在DUNE网格界面的设计中（第$5.2)$章）。

其次，我们需要能够计算出`element stiffness matrices`。

\begin{equation}
\left(A_{T}\right)_{p q}=\int_{T}\left\langle\left(C \nabla \phi_{p}+\mathbf{v}\right), \nabla \phi_{q}\right\rangle+r \phi_{p} \phi_{q} d x \quad \forall T \in \mathcal{T}
\label{2.14}
\end{equation}

和元素载荷向量

\begin{equation}
\left(b_{T}\right)_{p}=\int_{T \cap \Gamma_{N}} j \phi_{p} d s+\int_{T} f \phi_{p} d x \quad \forall T \in \mathcal{T}
\label{2.15}
\end{equation}

它们分别是大小为$n_{T} \times n_{T}$和$n_{T}$的小密集矩阵和向量。这个问题将在下一节进行研究。

最后，支持与元素$T$相交的基函数$\left\{\phi_{p}\right\}_{p=0}^{n_{T}-1}$的集合被赋予局部编号$p=0, \ldots, n_{T}-1$。对于每个这样的局部编号 $p$ ，需要计算全局编号 $i(p)$ 。



\textbf{Transformation to the Reference Element}

前面算法的最内部步骤是对单个网格元素的积分

\begin{equation}
\left(A_{T}\right)_{p q}:=\int_{T}\left\langle\left(C \nabla \phi_{p}+\mathbf{v}\right), \nabla \phi_{q}\right\rangle+r \phi_{p} \phi_{q} d x
\label{2.16}
\end{equation}

和

\begin{equation}
\left(b_{T}\right)_{p}:=\int_{T \cap \Gamma_{N}} \mathrm{j} \phi_{p} d s+\int_{T} f \phi_{p} d x
\label{2.17}
\end{equation}

为了简化数字正交的使用，这些积分通常被转换为一个标准元素。对于每个组合类型的元素，我们引入一个参考元素。最重要的是`reference simplex`。

$$
T_{\text {ref }}:=\left\{\xi \in \mathbb{R}^{d} \mid \xi_{1}, \ldots, \xi_{d} \geq 0, \sum_{i=1}^{d} \xi_{i} \leq 1\right\}
$$

和`reference cube`。

$$
T_{\mathrm{ref}}:=[0,1]^{d}
$$

通过滥用符号，我们用相同的符号表示所有的参考元素$T_{\text {ref. }}$为了连接网格元素和它的参考元素，我们引入一个足够平滑的映射

\begin{equation}
F_{T}: T_{\text {ref }} \rightarrow T
\label{2.18}
\end{equation}

并假定它是可逆的，有一个足够平滑的逆。然后，$T$上的基函数可以通过引入以下方法拉回到参考元素上

$$
\hat{\phi}_{T, p}:=\phi_{p} \circ F_{T}
$$

这些新函数被称为 `shape functions` 。

计算基函数$\phi_{p}$的梯度$\nabla \phi_{p}$需要链式规则。相对于参考元素上的坐标$\xi$推导出$\hat{\phi}_{T, p}$，产生了

\begin{equation}
\nabla_{\xi} \hat{\phi}_{T, p}(\xi)=\nabla_{x} \phi_{T, p}\left(F_{T}(\xi)\right) \cdot \nabla_{\xi} F_{T}(\xi)
\label{2.19}
\end{equation}

这里，$\nabla_{\xi}$是关于$T_{\text {ref }}$坐标的导数，$\nabla_{x}$是关于$T$坐标的导数。矩阵$\nabla_{\xi} F_{T}$是$F_{T}$的`Jacobi matrix`，其条目为

$$
\left(\nabla F_{T}\right)_{a b}=\frac{\partial\left(F_{T}\right)_{a}}{\partial \xi_{b}}
$$

只要`Jacobi matrix`$\nabla F_{T}$能在$\xi$处倒置，方程\ref{2.19}就能解出所需的量。

\begin{equation}
\nabla_{x} \phi_{T, p}(x)=\nabla_{\xi} \hat{\phi}_{T, p}(\xi) \cdot\left(\nabla_{\xi} F_{T}(\xi)\right)^{-1}
\label{2.20}
\end{equation}







对于标量值的基函数，$\nabla_{x}$和$\nabla_{\xi}$都是行向量。然而，DUNE网格界面更倾向于将它们视为列向量。因此，DUNE汇编器通常会实现以下表达式

$$
\left(\nabla_{x} \phi_{T, p}\right)^{T}(x)=\left(\nabla_{\xi} F_{T}(\xi)\right)^{-T} \cdot\left(\nabla_{\xi} \hat{\phi}_{T, p}(\xi)\right)^{T}
$$

而不是\ref{2.20} 。

使用这些表达式和积分转换公式，我们就可以得到

\begin{equation}
\begin{gathered}
\left(A_{T}\right)_{p q}=\int_{T_{\mathrm{ref}}}\left\langle\left[C\left(\nabla_{\xi} F_{T}(\xi)\right)^{-T} \cdot\left(\nabla_{\xi} \hat{\phi}_{T, p}(\xi)\right)^{T}+\mathbf{v}\right],\left(\nabla_{\xi} F_{T}(\xi)\right)^{-T} \cdot\left(\nabla_{\xi} \hat{\phi}_{T, q}(\xi)\right)^{T}\right\rangle \\
+r \hat{\phi}_{p}(\xi) \hat{\phi}_{q}(\xi)\left|\operatorname{det} \nabla_{\xi} F_{T}(\xi)\right| d \xi
\end{gathered}
\label{2.21}
\end{equation}

为了使表达式\ref{2.16}\ref{2.17}或\ref{2.21}易于评估，有限元软件必须提供基函数$\left\{\phi_{i}\right\}_{i=0}^{n-1}$或$\left\{\hat{\phi}_{p}\right\}_{p=0}^{n_{T}-1}$的实现。这些实现需要有很高的效率，因为基函数和`shape functions`在问题组装过程中要评估很多次。对于二阶PDEs，需要数值和一阶导数，但高阶PDEs也需要`shape functions`的高阶导数。最后，网格需要提供地图$F_{T}$以及其导数。

先验地，一个元素的`shape functions`$\left\{\hat{\phi}_{p}\right\}$取决于该元素的几何结构。然而，对于许多重要的有限元空间，这种依赖性消失了。对于这些情况，软件系统通常对每个参考元素持有一个形状函数集的实现。在DUNE中，`dune-localfunctions`模块提供这样的函数集。第8章描述了该模块，同时也给出了一些关于有限元空间的更多信息。

元素载荷向量$b_{T}$的处理方法与此类似。虽然体积载荷项$\int_{T} f \phi_{p} d x$的处理是直接的，但`Neumann`边界项$\int_{T \cap \Gamma_{N}} \mathrm{j} \phi_{p} d s$需要额外考虑，因为它涉及到域边界的一部分的积分。为简单起见，假设相关元素边界$T \cap \Gamma_{N}$由一组元素面$\gamma_{0}, \ldots, \gamma_{m-1}$组成。那么，元素边界上的积分可以写成面的积分之和

$$
\int_{T \cap \Gamma_{N}} \mathrm{j} \phi_{p} d s=\sum_{i=0}^{m-1} \int_{\gamma_{i}} \mathrm{j} \phi_{p} d s
$$

每个面都对应着一个$d-1$维度的参考元素，通过再次滥用符号，我们把所有$\gamma_{0}, \ldots, \gamma_{m-1}$称为$T_{\text {ref }}^{\Gamma}$ 。相应的映射是 $F_{\gamma_{i}}$ : $T_{\text {ref }}^{\Gamma} \rightarrow \gamma_{i}$ ( [Fig2.7] ) 。再次使用积分转换公式，我们将边界积分重写为$d-1$维参考元素的积分之和

\begin{equation}
\int_{T \cap \Gamma_{N}} \mathrm{j} \phi_{p} d s=\sum_{i=0}^{m-1} \int_{T_{\mathrm{ref}}^{\Gamma}} \mathrm{j}\left(F_{\gamma_{i}}(\xi)\right) \hat{\phi}_{p}\left(\iota_{i}(\xi)\right)\left|\operatorname{det} \nabla F_{\gamma_{i}}(\xi)\right| d s
\label{2.22}
\end{equation}

地图$\iota_{i}: T_{\text {ref }}^{\Gamma} \rightarrow T_{\text {ref }}$是将面参考元素$T_{\text {ref }}^{\Gamma}$嵌入到元素参考元素$T_{\text {ref }}$中，由以下公式给出

$$
\iota_{i}(\xi):=F_{T}^{-1}\left(F_{\gamma_{i}}(\xi)\right)
$$

请注意，这是对$T !$的每个面的不同映射。有了它的帮助，就没有必要为元素面引入`shape functions`。相反，元素`shape functions`$\hat{\phi}_{p}$被整合到各个元素面。

\textbf{Numerical Quadrature}

在模型问题中，上一节的积分只包含多项式表达，因此可以用符号计算。然而，大多数应用需要更多的通用性，因此通常使用数字正交来计算积分。换言之，\ref{2.21} ，即。

$$
\begin{aligned}
\left(A_{T}\right)_{p q}=\int_{T_{\text {ref }}}\left\langle\left[C\left(\nabla F_{T}(\xi)\right)^{-T}\left(\nabla_{\xi} \hat{\phi}_{T, p}(\xi)\right)^{T}+\mathbf{v}\right],\right.&\left.\left(\nabla_{\xi} F_{T}(\xi)\right)^{-T}\left(\nabla \hat{\phi}_{T, q}(\xi)\right)^{T}\right\rangle \\
&+r \hat{\phi}_{p}(\xi) \hat{\phi}_{q}(\xi)\left|\operatorname{det} \nabla_{\xi} F_{T}(\xi)\right| d \xi
\end{aligned}
$$

被近似为

$$
\begin{array}{r}
\left(A_{T}\right)_{p q} \approx \sum_{k=0}^{n_{q}-1} \omega_{k}\left\langle\left[C\left(\nabla F_{T}\left(\xi^{k}\right)\right)^{-T}\left(\nabla_{\xi} \hat{\phi}_{T, p}\left(\xi^{k}\right)\right)^{T}+\mathbf{v}\right],\left(\nabla_{\xi} F_{T}\left(\xi^{k}\right)\right)^{-T}\left(\nabla \hat{\phi}_{T, q}\left(\xi^{k}\right)\right)^{T}\right\rangle \\
+r \hat{\phi}_{p}\left(\xi^{k}\right) \hat{\phi}_{q}\left(\xi^{k}\right)\left|\operatorname{det} \nabla_{\xi} F_{T}\left(\xi^{k}\right)\right|
\end{array}
$$

其中$\omega_{0}, \ldots, \omega_{n_{q}-1} \in \mathbb{R}$和$\xi^{0}, \ldots, \xi^{n_{q}-1} \in T_{\text {ref }}$是参考元素上正交规则的权重和点。元素载荷矢量$b_{T}$的表达方式与此类似--主要区别在于$(2.22)$中的面积分需要一个单独的正交规则。所有的有限元实现都为普通参考元素提供了正交规则的集合。

在许多常见的情况下，通过数字正交的近似可以是精确的。例如，对于简单网格上的一阶`Lagrange`元素，表达式$\left(\nabla F^{-1}\right)^{T}$、$\nabla \hat{\phi}_{i}$和$\nabla \hat{\phi}_{j}$都是常数（作为仿射函数的导数）。因此，如果$C, \mathbf{v}$, 和$r$也是常数，整个积分是常数，一点正交规则就足够了。

更高阶的正交规则对于更高阶的多项式基函数是需要的，当网格包含例如立方体元素时（因为那时$F$一般不再是仿生的）。如果$C$不是多项式，一般来说，不可能精确地积分\ref{2.21}。数字正交引入的误差的影响将在[^42]第4.1节中讨论。

最后，正交循环可能非常耗时，特别是在使用高次多项式的`shape functions`时。像[^121]和[^129]这样的作品研究了构成正交的嵌套循环的重新计算和自动转换。有专门的编译器和代码生成器用于这种类型的循环。

\subsubsection{Dealing with Dirichlet Boundary Conditions}

上一节已经展示了处理`Dirichlet`边界条件的两种方法

$$
u=\mathrm{g} \quad \text { on } \Gamma_{D}
$$

第一个弱表述\ref{2.6}将解空间限制在只符合边界条件的那些函数上

\begin{equation}
u \in H_{\Gamma, D}^{1}: \quad a(u, v)=l(v) \quad \forall v \in H_{\Gamma, 0}^{1}
\label{2.23}
\end{equation}

为了避免仿生空间$H_{\Gamma, D}^{1}$，问题随后被转换为纯矢量空间设置。

\begin{equation}
\tilde{u} \in H_{\Gamma, 0}^{1}: \quad a(\tilde{u}, v)=l(v)-a\left(u_{\mathrm{g}}, v\right) \quad \forall v \in H_{\Gamma, 0}^{1}
\label{2.24}
\end{equation}

相应的有限元问题是在这些空间与有限元空间$V_{h}$的交汇处提出的，并默认这些空间是非空的。最后，代数问题\ref{2.9}是由挑选空间$V_{h} \cap H_{\Gamma, 0}^{1}$的基础$\left\{\phi_{i}\right\}$而产生的。

虽然这种方法在理论上是优雅的，但在实践中几乎没有使用过。在这样的设置中，域边界上的元素比`shape functions`中的元素具有更少的`interior` 。虽然对这种依赖元素的形状函数集进行编程绝非不可能，但在代数层面处理`Dirichlet`边界条件更为方便。因此，在本书的其余部分，我们假设$\left\{\phi_{i}\right\}$是全空间$V_{h}$的基础，矩阵$A$和载荷矢量$b$是为这个全空间组装起来的。





\textbf{Writing Constraints into the Stiffness Matrix}

对于模型问题和`Lagrange`有限元空间，弱表述\ref{2.23}导致代数约束的形式为

\begin{equation}
u_{i}=\mathrm{g}_{i}:=\mathrm{g}\left(v_{i}\right)
\label{2.25}
\end{equation}

对于所有自由度$i$，其`Lagrange`节点$a_{i}$位于域边界上。最常见的方法是将这些约束直接写入线性系统\ref{2.10}中。为此，$i^{th}$的方程\ref{2.10}被简单地替换为方程$u_{i}=g_{i}$ 。在矩阵和向量方面，这意味着将矩阵$A$的$i^{th}$行填充为身份矩阵的相应行。负载向量$i^{th}$的$b$项被替换为$g_{i}$ , [X-Matrix1] 。


[X-Matrix1]: https://cdn.mathpix.com/snip/images/zfbJwmIRVvkFHDcZr4r-0xLMMDx3fjysUsyD3GQxATM.original.fullsize.png



这种方法很有效，容易实现，而且不需要额外的内存。缺点是，修改后的矩阵不是对称的，即使原矩阵是对称的。

\textbf{Static Condensation of `Dirichlet` Degrees of Freedom}

对称性可以通过第二个消除步骤来恢复。只需使用$i^{th}$行中新引入的1来消除$i^{th}$列中所有其他条目。对于每个$j \neq i$，这相当于用$\tilde{b}_{j}:=b_{j}-A_{j i} g_{i}:$[X-Matrix2]取代$b_{j}$条目。

[X-Matrix2]: https://cdn.mathpix.com/snip/images/axSCA4y3iRvn5Xfi0KrZqXmWGxdUf50UD4n1OMDKEl8.original.fullsize.png

经过这样的第二次修改，如果原来的问题是对称的，就可以再次使用对称问题的求解器。

从上一段的对称消除问题出发，从线性系统中完全消除`Dirichlet`自由度只是一个小步骤。这种消除被称为`static condensation`；它是\ref{2.24}的代数当量

这种方法似乎很有吸引力：它在数学上很优雅，甚至减少了要解决的线性系统的大小。然而，这种方法在实践中却很少使用。在许多常见的稀疏矩阵数据结构中，要消除矩阵的行和列是很困难的。因此，代价要么是更复杂的矩阵数据结构，要么是将相关行复制到一个全新的矩阵中（这至少会暂时需要大量的额外内存）。

\textbf{Modifying the Solvers}

以前的方法的缺点是它们破坏了原始刚度矩阵。这可能是一个问题：例如，在多级求解器中，可能仍然需要计算能量准则或粗略的网格近似值。因此，第三种方法是不动用矩阵和载荷矢量，但修改求解器算法以始终跳过标记为`Dirichlet`的自由度。修改后的求解器为迭代向量$\bar{u}$的每个条目保留一个布尔值，并且只有在相应的位没有被设置时才改变一个条目$u_{i}$。这种方法在DUNE扩展模块`dune-solvers`中使用，简化了多级算法和非线性方程的算法的实现和推理。特别是，不修改`Dirichlet`值的刚度矩阵可以简化对刚度矩阵进行多次转换的算法（例如，多体接触求解器[^163]或某些非光滑下降方法，如TNNMG[^83]）。

该方法的主要缺点是所有的求解器算法都必须进行修改。现成的标准线性求解器的实现不接受要跳过的自由度列表。另一方面，像IPOPT 6 [^158]这样的非线性问题的一般优化代码允许规定一般的线性侧约束。在这样一个灵活的设置中，像`Dirichlet`这样的约束只是一个简单的特例。

第二个缺点是运行时的效率。每次在接触向量组件之前检查一个布尔标志会降低执行速度，特别是在处理器上



具有深流水线的架构 [^92] 。这对线性方程来说是最重要的，因为每次访问任何系数都只需要进行少量的算术运算 $u_{i}$ ，而当问题是非线性的时候，就不那么重要了。

\subsection{The Finite Volume Method}

有限体积法是DUNE旨在支持的第二大类偏微分方程的方法。与基于偏微分方程的弱式表述的有限元方法不同，有限体积法使用的是积分表述。这使得该方法特别适用于具有守恒形式的方程，比如我们在第2.2.1节中考虑的线性传输方程。椭圆和抛物线方程更具挑战性，但也可以处理，正如我们在第2.2.2节中简要说明的那样。对有限体积方法的良好介绍是 [^12] [^66] 。

有限体积法的性质促使DUNE网格界面的一些设计选择。简单的`cell-centered`有限体积方法在不符合要求的网格上自然地工作，而且元素类型不仅仅是单纯的和立方体。为了适应这一点，DUNE的网格界面对元素形状和相邻元素之间的关系限制很少。另一方面，与许多有限元方法相比，有限体积方法通常需要更多关于相邻网格元素之间相互关系的信息。这种需求反映在DUNE网格界面的交点概念设计中（第$5.4$章）。

\subsubsection{Conservation Laws}

对于一个简单的标量守恒定律，有限体积法是最容易解释的。让$\Omega$是$\mathbb{R}^{d}$中的一个域，$\left[0, t_{\text {end }}\right]$是一个时间区间。我们正在寻找一个标量浓度$c: \Omega \times\left[0, t_{\text {end }}\right] \rightarrow \mathbb{R}$在一个给定的静止速度场$\mathbf{v}: \Omega \rightarrow \mathbb{R}^{d}$影响下的时间演化，从一个给定的初始浓度$c_{0}(x)$开始，所有$x \in \Omega$。在最简单的情况下，演变由线性传输方程描述

\begin{equation}
\frac{\partial c}{\partial t}+\operatorname{div}(c \mathbf{v})=0
\label{2.26}
\end{equation}

这是对所有的点$x \in \Omega$和所有的时间$t \in\left[0, t_{\text {end }}\right]$都成立的。

如前所述，我们用字母$\mathbf{n}$来表示域$\Omega$的外单位法线。速度场将$\Omega$的边界$\partial \Omega$分离成两部分。我们称流入边界$\Gamma_{\mathrm{in}}$为速度$\mathbf{v}$指向$\Omega$内部的那部分边界，即：。

$$
\Gamma_{\mathrm{in}}:=\{x \in \partial \Omega \mid\langle\mathbf{v}, \mathbf{n}\rangle<0\}
$$

和`outflow boundary` $\Gamma_{\text {out }}$ 整个其余部分。边界条件只能在流入的边界上提出 $\Gamma_{\text {in }}$ 。标准选择是`Dirichlet`条件，即规定浓度$c$，或`Neumann`边界条件，即规定通量$\mathbf{j}:=c \mathbf{v}$。在 `outflow boundary` $\Gamma_{\text {out }}$ 上，完全不能提出边界条件，因为那里的解完全由微分方程决定。隐含条件 $\mathbf{j}=c \mathbf{v}$ 有时被称为 `outflow boundary condition` 。

为了推导出\ref{2.26}的积分表述，我们将域$\Omega$划分为一组$\mathcal{T}$的封闭凸多边形$T_{i}$，从而

1.(分割）多边形的联盟是域的闭合

\begin{equation}
\bar{\Omega}=\bigcup_{T \in \mathcal{T}} T
\label{2.27}
\end{equation}

2.(无交集）对于$\mathcal{T}$中的任何两个多面体，其内部的交集为空

\begin{equation}
\operatorname{int} T_{i} \cap \operatorname{int} T_{j}=\emptyset \quad \forall T_{i}, T_{j} \in \mathcal{T}, i \neq j
\label{2.28}
\end{equation}

这样的分区又被称为`grid`，但要注意这个定义比有限元方法的相应定义$2.1$的限制性要小。在有限体积法的背景下，多边形$T$被称为`control volumes` 。两个有限体积网格的例子显示在 [Fig2.8] 中。

给定分区$\mathcal{T}$，我们将`Gauss`定理应用于每个控制量$T_{i} \in \mathcal{T}$，得到一组耦合问题

\begin{equation}
\frac{\partial}{\partial t} \int_{T_{i}} c d x+\int_{\partial T_{i}}\langle c \mathbf{v}, \mathbf{n}\rangle d s=0
\label{2.29}
\end{equation}

每个$T_{i}$都有一个。在滥用符号的情况下，我们在这里也使用$\mathbf{n}$来表示控制体的单位外法线。

为了在时间上进行离散，我们将时间间隔细分为不连续的步骤

$$
0=t_{0}<t_{1}<t_{2}<\ldots<t_{m}=t_{\text {end }}
$$









一个简单的显式`Euler`离散化可以得到

\begin{equation}
\int_{T_{i}} c\left(x, t_{k+1}\right) d x-\int_{T_{i}} c\left(x, t_{k}\right) d x+\Delta t_{k} \int_{\partial T_{i}}\langle c \mathbf{v}, \mathbf{n}\rangle d s=0 \quad \forall T_{i} \in \mathcal{T}
\label{2.30}
\end{equation}

其中$\Delta t_{k}:=t_{k+1}-t_{k}$是$k^{th}$的时间步长。然后我们用一个单元格常数函数$\bar{c}$来近似$c$，其中

$$
\bar{c}_{i}^{k}:=\frac{1}{\left|T_{i}\right|} \int_{T_{i}} c\left(x, t_{k}\right) d x
$$

是元素$T_{i}$在时间$t_{k}$的平均值，其中我们用$\left|T_{i}\right|$来表示$T_{i}$的体积。这样就可以把\ref{2.30}减少到

\begin{equation}
\bar{c}_{i}^{k+1}\left|T_{i}\right|-\bar{c}_{i}^{k}\left|T_{i}\right|+\Delta t_{k} \int_{\partial T_{i}}\langle c \mathbf{v}, \mathbf{n}\rangle d s=0
\label{2.31}
\end{equation}

在这种结构下，自由度与网格元素（有时被称为`grid cells`）相关联。由于这个原因，该方法经常被称为`cell-centered`有限体积方法。

现在的问题是如何将控制体积边界$\langle c \mathbf{v}, \mathbf{n}\rangle$上的未知通量$\partial T_{i}$与代数未知数$\bar{c}_{i}^{k}$联系起来。对于一个给定的元素 $T_{i}$ ，我们将边界 $\partial T_{i}$ 细分为面 $\gamma_{i j}$ 。这些面要么是与其他元素$\partial T_{i} \cap \partial T_{j}$的交点，要么是与边界$\partial T_{i} \cap \partial \Omega$的交点（[Fig2.9]）。对于每个这样的交叉点，让$\mathbf{v}_{i j}$是面$\gamma_{i j}$中点的速度，$\mathbf{n}_{i j}$是面$\gamma_{i j}$相对于$T_{i}$的单位外法线。法向通量$\langle c \mathbf{v}, \mathbf{n}\rangle$由每个面的一个常数近似，它取决于流动方向。我们设定

$$
\int_{\gamma_{i j}}\langle c \mathbf{v}, \mathbf{n}\rangle d s=\left|\gamma_{i j}\right| \cdot \begin{cases}\bar{c}_{j}^{k}\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle & \text { for }\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle<0 \\ \bar{c}_{i}^{k}\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle & \text { otherwise }\end{cases}
$$

这种近似通常被称为`a flux function` 。流入边界上的诺伊曼边界条件通过用给定边界通量$\mathbf{j}$在$\gamma_{i j}$上的合适近似值来实现$\bar{c}_{j}^{k} \mathbf{v}_{i j}$项。  `Dirichlet`边界条件$c=g$通过$\mathbf{j}=g \mathbf{v}$转为通量条件来实现。

通量函数可以改写为

$$
\int_{\gamma_{i j}}\langle c \mathbf{v}, \mathbf{n}\rangle d s=\left|\gamma_{i j}\right| \cdot \bar{c}_{i}^{k} \max \left(0,\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)-\left|\gamma_{i j}\right| \cdot \bar{c}_{j}^{k} \max \left(0,-\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)
$$

将此插入\ref{2.31}并求解$\bar{c}_{i}^{k+1}$，我们可以得到

$$
\bar{c}_{i}^{k+1}=\bar{c}_{i}^{k}\left(1-\Delta t_{k} \sum_{\gamma_{i j}} \frac{\left|\gamma_{i j}\right|}{\left|T_{i}\right|} \max \left(0,\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)\right)+\Delta t_{k} \sum_{\gamma_{i j}} \bar{c}_{j}^{k} \frac{\left|\gamma_{i j}\right|}{\left|T_{i}\right|} \max \left(0,-\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)
$$

为所有元素 $T_{i}$ 。这是一个显式方案，不需要解决方程组。足够小的时间步长的稳定性可以通过更新矩阵的特性来证明。

该方案是质量守恒的。当通过对所有元素的质量$\bar{c}_{i}\left|T_{i}\right|$求和来计算总质量时，`interior`交叉点的每个项出现两次，并且每个符号出现一次。因此，`interior`相交项被抵消，总质量变化只由边界通量引起。

观察一下，元素的几何形状并没有完全进入方案。所使用的只是元素和面的体积，以及面的中心。另一方面，在一个显式方案中，这些看似简单的量的计算可能会在整个运行时间中占很大的比例，令人吃惊。因此，用于单元中心有限体积网格的网格数据结构应该能够尽可能有效地计算它们。

\subsubsection{Second-Order Elliptic Equations}

有限体积法也可以应用于二阶椭圆方程。在那里，通量包含未知函数的导数，这带来了额外的挑战。

作为一个模型问题，再次考虑`Poisson`方程。让$\Omega \subset \mathbb{R}^{d}$是一个域，$f: \Omega \rightarrow \mathbb{R}$是一个体积源项。我们寻找一个标量函数$u: \Omega \rightarrow \mathbb{R}$来解决

$$
-\Delta u=f \quad \text { on } \Omega
$$

受制于合适的`Dirichlet`和`Neumann`边界条件。

为了得出`Poisson`方程的离散积分表述，再次将域$\Omega$划分为满足\ref{2.27}和\ref{2.28}两个性质的有限凸多边形集$\mathcal{T}$。对每个控制体积$T \in \mathcal{T}$的方程进行积分，并应用`Gauss`定理得到

\begin{equation}
-\int_{\partial T}\langle\nabla u, \mathbf{n}\rangle d s=\int_{T} f d x
\label{2.32}
\end{equation}

边界积分与\ref{2.29}非常相似，但现在元素边界通量为

$$
\mathbf{j}=\nabla u
$$

而不是$\mathbf{j}=c \mathbf{v}$。这里的核心问题是如何计算两个相邻控制体$T_{i}$和$T_{j}$之间的交点$\gamma_{i j}$上的梯度$\nabla u$ 。一种方法是假设对于每个控制体$T$有一个点$x_{T} \in T$，如果两个控制体$T_{i}$和$T_{j}$有一个共同的面，那么段$\left[x_{T_{i}}, x_{T_{j}}\right]$是与该面正交。然后我们将自由度与这些点$x_{T}$相关联，并在相邻元素的点之间进行线性内插。通过这种近似，在公共面$\gamma_{i j}$和线段$\left[x_{T_{i}}, x_{T_{j}}\right]$的交汇处的法线通量$\langle\nabla u, \mathbf{n}\rangle$由以下公式给出

$$
\langle\nabla u, \mathbf{n}\rangle=\nabla u \frac{x_{T_{i}}-x_{T_{j}}}{\left\|x_{T_{i}}-x_{T_{j}}\right\|} \approx \frac{u_{T_{i}}-u_{T_{j}}}{\left\|x_{T_{i}}-x_{T_{j}}\right\|}
$$

为了将`Dirichlet`和`Neumann`的边界条件纳入离散问题，首先假设`Dirichlet`和`Neumann`的边界是由网格解决。对于每个边界面$\gamma$，然后有一个规定的边界值$\mathrm{g}_{\gamma}$或规定的边界法向通量$\mathrm{j}_{\gamma}$ 。对于`Neumann`边界面$\gamma_{N}$，\ref{2.32}上的法线通量$\langle\nabla u, \mathbf{n}\rangle$可以直接替换为$\mathrm{j}_{\gamma}$。对于控制体$T$的`Dirichlet`面$\gamma_{D}$，法向导数$\langle\nabla u, \mathbf{n}\rangle$被近似为一个单边差分商。

$$
\langle\nabla u, \mathbf{n}\rangle \approx \frac{\mathrm{g}_{\gamma}-u_{T}}{h / 2}
$$

其中$h / 2$是$x_{T}$到$\gamma_{D}$之间的近似距离。

总的来说，这就形成了一个线性方程组

$$
-\sum_{\gamma_{i j}}\left|\gamma_{i j}\right| \cdot \frac{u_{i}-u_{j}}{\left\|x_{T_{i}}-x_{T_{j}}\right\|}=\int_{T_{i}} f d x \quad i=1, \ldots,|\mathcal{T}|
$$

为未知数$u_{i}$，并对上述边界值进行修改。

在这个方案中，未知数与元素中心相关。这些构成了$\mathcal{T}$ [^12]的所谓`dual-grid`的顶点，因此该方法被称为`a vertex-centered finite volume method`。

例如，如果控制体积网格为`Cartesian`，则所需的正交特性成立。另一种方法是选择`Voronoi`单元作为控制体[^66] 例3.2。然后，双网格是控制体积中心的`Delaunay`三角结构$x_{T_{i}}$ ，见[Fig2.10] 。




\subsection{Local Grid Adaptivity}

所有基于网格的PDEs方法的基本假设是，通过提高网格分辨率，即通过使元素尺寸$h$越来越小，可以减少近似误差。以下是$p$-九阶`Lagrangian`有限元的结果，是典型的。它指出，$H^{1}$的误差像$p$的-次方$h$那样减少。

\textbf{Theorem} $2.1$ 让$p \geq 1$和$u \in H_{\Gamma}^{1}(\Omega) \cap H^{p+1}(\Omega)$ 。那么，如果网格大小$h$足够小，我们可以得到先验约束

\begin{equation}
\left\|u-u_{h}\right\|_{H^{1}} \leq C h^{p}|u|_{H^{p+1}}
\label{2.33}
\end{equation}

与常数$C$无关的$u$ 。

相应的结果存在于许多其他有限元离散化 [^37] [^42] [^63] ，以及有限体积法 [^66] 。

\textbf{Theorem} $2.1$意味着$u_{h}$收敛于$u$，因为$h$归零。然而，对于实践者来说，收敛顺序是至关重要的：在给定的自由度数下，即在给定的成本下，指数的高阶转化为更多的精度。

不幸的是，像\ref{2.33}这样的界限只有在PDE的解$u$足够平滑时才成立。例如，为了用一阶有限元获得线性收敛，$u$必须是一个$H^{2}$函数。$u$不是$H^{2}$规则的情况很容易构建，在这些情况下确实可以观察到亚线性收敛。典型的例子是具有内角的域，如[Fig2.11]中的域，解的奇异性在这些角上发展。  [Fig2.11]也显示了一个边界的解







在这个域上的`Poisson`方程的值问题。解决方案在远离内角的地方是$H^{2}$-规则的，但在整个域上不是。

为了更 "直观 "地解释为什么这个例子的收敛效果不理想，请注意在拐角附近，解的图形有很高的曲率。因此需要一个具有许多小元素的网格来很好地近似拐角处的函数。另一方面，在远离角落的地方，解决方案是相当平坦的。在那里，很少的元素就足以很好地近似函数，而使用高分辨率的网格是很浪费的。

\subsubsection{Local Adaptivity of Grids and Finite Element Spaces}

如果使用局部网格适应性，收敛顺序可以经常得到改善。局部网格适应性意味着在奇点附近自动使用小元素，而在其他地方使用大元素。这种方法可以极大地提高每项工作的总体精度。我们在这里讨论它，因为对自适应网格的需要促使DUNE的一些设计决定。

本地适应性包括两个任务。首先，对于某个网格上给定的离散解$u_{h}$，我们需要估计当前的误差$u-u_{h}$，以及这个误差在整个领域中的分布。有了这些信息，网格就会被局部修改，以便将自由度集中在高误差区域，同时保持自由度的总体数量尽可能低。第一部分被称为 `posteriori error analysis` ，是数值数学的一个成熟的子领域 [^157] 。它涉及微分方程和它们的离散化，超出了本书的范围。第二部分是纯粹的几何学，只涉及网格数据结构。然而，它的实现可能是相当具有挑战性的。这些步骤与PDE的实际求解一起，构成了经典的`adaptive refinement loop`，在[Fig2.12]中得到了可视化。

有两种方法可以提高领域内特定区域的网格分辨率。

- 将大元素分割成小元素（ `h-refinement` ）。在某些情况下，将几个小元素合并成一个大元素也是很方便的（粗化）。

- 将网格顶点从低兴趣区移到高兴趣区，而不改变网格拓扑结构 $(r-$ 细化 $)$ 。这对于某些流动问题和有边界层的问题是有意义的。参见[^95]的概述。

局部自适应的第三种方法是`p-refinement`，它不触及网格，但在适当的地方增加有限元空间的多项式阶数。通常，`p-refinement`与`h-refinement`相结合，它们一起被称为`hp-refinement`。在适当的条件下，所产生的离散化误差随着自由度[^145]的数量呈指数级下降。  然而，对于连续函数的有限元空间，`hp-refinement`很少使用，因为不同阶的多项式之间的元素间连续性很难实现。对于没有连续性的有限元，它更自然 [^55] 。

本章的其余部分侧重于`h-refinement`，因为那是DUNE网格界面的主要目标。

\subsubsection{ `h-Refinement`}

在`h-refinement`中，在需要高分辨率的区域，元素大小$h$被减少。为了实现这一目标，受影响区域的元素被分割，并由尺寸较小的元素取代。挑战在于如何分割元素，使元素形状不至于太差，因为元素质量对离散化误差和求解器收敛速度有关键影响 [37] [^147] 。有几种不同的策略可以将元素分割成更小的元素。所有这些策略都可以在DUNE中使用。

\textbf{Edge Bisection}

边缘分割是一种具有单线元素的网格的细化技术。在二维网格中，通过将一条边分成两半，并将中点与对面的顶点相连，来分割给定的三角形。这样一来，原来的三角形就被分割成两个较小的三角形。在三维网格中，一条边的中点通过一个三角形连接到对面的边（ [Fig2.13] ）。

细化边缘的选择对保持网格质量很重要。例如，反复将元素在其最短的边上一分为二，会导致元素长宽比无限制的网格序列。文献中提出了各种挑选合适边的策略。Rivara[^137]表明，如果元素总是沿其最长的边被一分为二，则整体网格质量仍然是有限制的。其他的标准是纯粹的组合性的 [^128] 。

简单地沿一条边拆分元素，通常会导致网格出现悬空节点，即元素顶点与所有相邻元素的顶点不对应（[Fig2.14]）。具有悬空节点的网格被称为`nonconforming`；它们违反了网格定义$2.1$中的条件2。根据离散化方法的不同，悬空节点可能是也可能不是问题。例如，`cell-centered`有限体积方法很容易处理带有悬挂节点的网格，某些有限元方法也是如此，比如第11.2.6章的`Discontinuous Galerkin`（DG）方法。事实上，这种在不符合要求的网格上工作的能力是这些方法的主要卖点之一。





为了恢复符合要求的网格，边缘分割算法将额外细化有悬挂节点的元素，直到不再有这样的元素存在[^128] [Fig2.15]显示了[Fig2.11]中所示的奇异解的网格，由局部自适应边缘分割细化得到。

\textbf{Red (Regular) Refinement}

边缘分割将每个元素分割成两个新的元素，而红色（或规则）细化将任何$d$维元素细分为$2^{d}$个新元素。它是由`Bank, Sherman, and Weiser`[^10]为二维网格引入的。  [Fig2.16]显示了四边形和三角形的红色细化。新的顶点是通过平分边引入的，而连接边的中点则形成新的元素。对于四边形，在元素中心出现一个额外的新顶点。

与边的分割不同，三角形的红色细化产生的元素与旧的元素相似，在这个意义上，每个新的元素都可以仅通过旋转、平移和缩放来转化为它的父亲。对于具有平行对边的四边形也是如此。这意味着一连串的细化操作将不会影响网格的元素质量。

不幸的是，这种理想的相似性属性在更普遍的情况下并不成立；特别是，三维元素的红色细化涉及更多。  [Fig2.17]显示了六面体、棱镜和金字塔的典范分割，它们都是典范的。然而，细化一个四面体是有问题的。将四个角拆开，留下一个八面体，它可以沿着三条对角线中的任何一条拆成另外四个四面体（[Fig2.18]）。这些四面体与原来的四面体不相似，其形状取决于`diagonal`的选择。多位作者指出，在单个给定四面体的细化序列中，有一些挑选对角线的策略，导致只出现有限数量的相似度类 [^25] [^70] 。因此，网格质量会受到四面体网格定期细化的影响，但网格质量仍然是有界限的。虽然这些算法仅仅依赖于顶点编号，但对于总是选择最短的`diagonal` [^113] [^165] ，也存在类似的结果。

\textbf{Red-Green Refinement}

[Fig2.19]显示了通过自适应红色细化得到的[Fig2.11]的奇异性函数的网格。图中显示，当局部应用常规细化操作时，网格中会再次出现悬空节点。为了恢复符合要求的网格，`Bank, Sherman, and Weiser`[^10]提出在过渡区使用所谓的`closure (or green) refinement`规则( [Fig2.22] )。假设一个元素的子集已经用红色规则进行了细化。然后使用闭合细化规则来细化具有悬挂节点的元素，而不引入更多的顶点。虽然很明显，对于在三角形的边缘中点有悬空节点的所有8种组合，都有相应的细化规则，但对更高维度的概括就比较麻烦了[^78] 。

然而，绿色封闭对元素质量有负面的影响。通过绿色细化得到的两个三角形的元素质量比原始三角形更差。对同一个三角形重复应用绿色细化规则将导致网格质量无限制的网格序列（[Fig2.21]）。为了避免这种情况，`Bank, Sherman, and Weiser`[^10]提出，不对绿色元素进行细化，而是先将其删除，再用红色细化来代替。这可能会导致额外的悬空节点，然后通过额外的绿色细化步骤将其消除。其结果是，在这个网格中，没有任何元素有被绿色规则提炼过一次以上的历史。因此，由于红色细化使元素的质量受到限制，即使使用绿色封闭来避免悬空节点，整体网格的质量也保持在一定范围内。

\subsubsection{Hierarchical Grids and Refinement Trees}

在大多数关于有限元方法的文本中，网格作为非层次对象出现，如定义2.1。在这样的背景下，局部网格细化是通过从网格中移除元素，然后用细化后的元素替换来实现的。然而，大多数网格细化的实现都对此采取了不同的看法。非层次化的观点有几个问题。

- 要撤销细化步骤是很难的。传统的方法 "忘记 "了某些元素组是由一个较大的元素分割而成的。原则上，如果原始元素仍然可用，这样的组可以很容易地被原始元素取代。相反，在没有这些额外信息的情况下，对一般非结构化网格进行粗化是很困难的。

- 作为这种情况的一个特例，如果没有这些元素的历史信息，在应用新一轮红绿细化之前删除绿色封闭元素是很困难的。

- 几何多层次方法[^37] [^83] [^155]，形成了一个庞大而成功的线性（和一些非线性）问题求解器系列，需要不同分辨率的网格层次结构。

由于这些原因，大多数支持网格细化的网格数据结构不仅存储最新的细化网格，而且还存储导致最终网格的所有较粗的细化阶段。选择的数据结构通常是一个森林，即一个树的集合 [^54] 。最初，网格是一个元素的集合（所谓的`coarse grid`或`macro grid`），但每个元素被视为一棵树，只由一个节点组成。如果这样的元素现在被细化为一组更小的元素，新的元素并不取代旧的元素。相反，它们被添加到相应的树中，作为旧元素的子女。代表宏观网格和当前细化状态的森林被称为`hierarchical grid` （[Fig2.23]）。





旧意义上的网格是由无子元素形成的，即所谓的`leaf elements` 。DUNE称其为`leaf grid view`或`leaf grid` 。当细化过程继续进行时，它的一些元素不再是叶子元素，并从叶子网格视图中消失。在森林数据结构中，当前的网格总是作为叶子元素的集合出现，但细化过程的前几个阶段还是可以从数据结构中获得，其形式是不属于森林的叶子元素。

由于这种构造，以前的精炼网格的粗化变得很容易：通过将一个叶子元素和它的所有兄弟姐妹从树上移除，共同的父元素又变成了一个叶子元素，因此出现在有限元网格中。另外，`hierarchical grids`包含了实现几何多网格求解器所需的信息。细化森林的不同层次自然形成了不同分辨率的网格集，正如这些方法所要求的。

DUNE的网格界面将网格视为这里所描述的树的集合。这就是为什么在网格接口中出现了一点图的术语。DUNE网格接口的实际实现可以明确地存储细化树，也可以在需要时从根元素和细化历史中重新计算它们。在第 $5.1$ 章中，我们将从一个更加以实现为中心的角度再次讨论这个话题。

值得注意的是，细化树不仅被用于自适应有限元和有限体积方法的实现。它们也作为理论工具出现在自适应有限元空间的近似特性分析中；例如，见[^26] 。

\section{Getting Started with Dune}

本章描述了使用DUNE的第一个步骤。它展示了如何在计算机上安装DUNE，以及如何创建第一个DuNe模块。然后，它介绍了两个例子的应用，让人们对DUNE的使用有一个初步的印象。

\subsection{Installation of Dune}

进入DUNE世界的第一步是其安装。我们已经尽量使这个过程不那么痛苦。下面的说明假定已经安装了一个Unix风格的命令外壳和工具链。这在`Linux`和`Apple OSX`的所有版本中都很容易获得。在`Windows`上有WINDOWS SUBSYSTEM FOR LINUX，或CYGWIN环境。

运行本章的例子需要八个DUNE模块。  `dune-common` , `dune-geometry` , `dune-grid` , `dune-istl` , `dune-localfunctions` , dune-uggrid, dunetypetree, 和 `dune-functions` 。这些甚至足以运行本书的所有例子，除了第11章的例子，这些例子还需要`dune-pdelab`。

\subsubsection{Installation from Binary Packages}

使用预先编译的软件包时，安装是最容易的。在写这篇文章的时候，Debian Linux发行版和它的许多衍生版都是这种情况，但可能还有更多。一个最新的列表可以在DUNE项目的网页上找到：www.dune-project.org。在`Debian-type`系统中，输入

~~~Shell
sudo apt-get install libdune-functions-dev \
libdune-istl-dev \
libdune-uggrid-dev
~~~

来安装所有这八个DuNE模块。没有明确列出的模块会自动添加。要额外安装 `dune-pdelab` ，将 libdune-pdelab-dev 添加到列表中。然后DUNE模块就被全局地安装在机器上，DUNE构建系统会找到它们。

\subsubsection{Installation from Source}

如果没有可用的预编译包，或者在没有sudo权限的情况下工作，那么DUNE必须从源代码安装。首先，从DUNE网站下载代码：www.dune-project.org。建议下载发布版的tarballs，名称为

~~~Shell
dune-<modulename>-X.Y.Z.tar.gz
~~~

其中`<modulename>`是`common`、`geometry`、`grid`等中的一个，$X . Y . Z$是发行版本号。本书中的代码示例至少需要版本 $2.7.0$ 。

那些需要非常新的功能的人也可以得到DUNE模块的前沿开发版本。Dune的源代码使用git版本控制软件进行存储和管理。储存库在https://gitlab.dune-project.org。要克隆（即下载）一个模块的源代码，请键入

~~~Shell
git clone https://gitlab.dune-project.org/core/dune-<modulename>.git
~~~

其中`<modulename>`被`common`、`geometry`、`grid`、`localfunctions`或`istl`取代。其余三个模块可从`staging`命名空间获得。

~~~Shell
git clone https://gitlab.dune-project.org/staging/dune-uggrid.git
git clone https://gitlab.dune-project.org/staging/dune-typetree.git
git clone https://gitlab.dune-project.org/staging/dune-functions.git
~~~



这八条命令创建了八个目录，每个模块一个目录。每个目录包含相应模块的最新开发版本的源代码。如果需要，这个开发版本可以被一个特定的发布版本所取代，例如，通过调用

~~~Shell
git checkout releases/2.7
~~~

的目录中。详见git文档。

假设有一个名为dune的空目录，并且8个DUNE模块的源代码已经被下载到这个目录。当使用tarballs时，这些必须通过以下方式解压

~~~Shell
tar -zxvf dune-<modulename>-X.Y.Z.tar.gz
~~~

为每个DUNE模块。要建立它们，进入dune目录并输入

~~~Shell
./dune-common/bin/dunecontrol cmake : make
~~~


这将配置和构建所有的DUNE模块，这可能需要几分钟的时间。为了简洁起见，cmake和make这两个命令可以一起调用为。

~~~Shell
./dune-common/bin/dunecontrol all
~~~

一旦这个过程完成，DuNE就可以通过输入以下内容进行安装了

~~~Shell
./dune-common/bin/dunecontrol make install
~~~

这将把DUNE的核心模块安装到 `/usr/local` ，并且需要root权限。

要把DUNE安装到一个非标准的位置，可以设置一个自定义的安装路径。为此，创建一个文本文件dune.opts，其中应包含

~~~Shell
CMAKE_FLAGS="-DCMAKE_INSTALL_PREFIX=/the/desired/installation/path"
~~~

然后调用

~~~Shell
./dune-common/bin/dunecontrol --opts=dune.opts all
~~~

终止
~~~Shell
./dune-common/bin/dunecontrol --opts=dune.opts make install
~~~



`dunecontrol` 程序将从选项文件中获取变量 `CMAKE_FLAGS` 并将其作为任何调用 `cmake` 的命令行选项，而后者则用于配置各个模块。这个例子中的特殊选项将告诉 `cmake` 所有的模块都应该安装到 `/the/desired/installation/path` 。

不幸的是，必须提到的是，从DUNE版本$2.7$开始，使用已安装的模块工作仍然不是很成熟，可能会导致构建失败。因此，DUNE模块的安装是可选的，DUNE构建系统也会接受非安装的模块作为构建依赖。

当使用`dunecontrol`程序来管理进一步的模块时，必须告诉它在哪里可以找到DUNE核心模块。这可以通过在环境变量 `DUNE_CONTROL_PATH` 中添加路径 `/the/ desired/installation/path` 来实现。然而，请注意，如果`DUNE_CONTROL_PATH`被设置为任何东西，那么当前目录不会自动搜索Dune模块。如果要搜索当前目录，那么`DUNE_CONTROL_PATH`变量必须在某处包含::。

\subsection{A First Dune Application}

DUNE是按模块组织的，每个模块大致是一个具有预定义结构的目录。每个这样的模块实现了一个$\mathrm{C}++$库，可以从其他代码中使用。虽然不是必须的，但是把新的代码写到一个新的DUNE模块中是很方便的，因为这样可以简化依赖性跟踪，并允许进一步的DUNE模块轻松地依赖新代码。这样做的第一步是创建一个新的DUNE模块模板。

\subsubsection{Creating a new Module}

在下文中，我们再次假设有一个`Unix-type`的命令外壳可用，并且DUNE已经成功安装到标准位置，或者`DUNE_CONTROL_PATH`包含安装路径。为了创建一个新的模块，DuNE提供了一个特殊的程序，叫做 `duneproject` 。要调用它，只需输入

~~~Shell
duneproject
~~~
在外壳中。如果该程序没有全局安装，请使用 `dune-common/bin` 中的版本。

在创建模块之前，`duneproject`程序会问几个问题。首先是模块的名称。任何不含空格的`Unix`文件名都可以接受，但通常模块名称以`dune- `为前缀。具体来说，我们将新模块称为 `dune-foo` 。

下一个问题问的是新模块将依赖的其他DUNE模块。为了提供帮助，`duneproject`已经收集了一个它在系统上看到的所有模块的列表。这些是全局安装的模块，以及`DUNE_CONTROL_PATH`环境变量中列出的目录中的模块。在上述安装之后，至少应该看到 `dune-common` , `dune-geometry` , `dune-grid` , `dune-istl` , `dune-localfunctions` , `dune-typetree` , dune-uggrid，和 `dune-functions` 。所需的应该在一个白空间分隔的列表中输入（以后很容易再添加）。为了本介绍的目的，请全部选择它们。

接下来是模块版本号的问题。这些问题应该以X.Y开头（X和Y是数字），可以选择以第三个数字.Y或一个任意的字符串结束。接着是电子邮件地址的问题。这个地址将出现在该模块的`dune.module`文件中（而不是其他地方），它将成为对该模块感兴趣的其他人的联系点。之后，`duneproject`程序退出，现在有一个空白模块 `dune-foo` 。

~~~Shell
~/dune: ls
dune-foo
~~~

可以使用像树状程序这样的工具来查看dune-foo包含一个小的目录树。

~~~Shell
~/dune> tree dune-foo
dune-foo
|-- cmake
| ‘-- modules
| |-- CMakeLists.txt
| ‘-- DuneFooMacros.cmake
|-- CMakeLists.txt
|-- config.h.cmake
|-- doc
| |-- CMakeLists.txt
| ‘-- doxygen
| |-- CMakeLists.txt
| ‘-- Doxylocal
|-- dune
| |-- CMakeLists.txt
| ‘-- foo
| |-- CMakeLists.txt
| ‘-- foo.hh
|-- dune-foo.pc.in
|-- dune.module
|-- README
‘-- src
|-- CMakeLists.txt
‘-- dune-foo.cc

7 directories, 15 files
~~~

这棵树包含。

- 用于DUNE构建系统的cmake配置文件。

- 一个文本文件dune.module，它包含了模块的一些元数据。

- 在 `dune-foo.cc` 中有一个小的例子程序。

一个典型的DUNE模块的内容在附录A中有更详细的描述。

\subsubsection{Testing the new Module}

由duneproject创建的新模块包含一个 $\mathrm{C}++$ 源代码文件 `src/dune-foo.cc` 。这是一个小的测试程序，可以验证模块是否被正确构建。配置和构建模块是由`dunecontrol`程序再次控制的。

这个过程与上一节中描述的配置和构建DUNE核心模块几乎没有任何区别。只要再次移动到dune目录，然后输入

~~~Shell
dunecontrol all
~~~

在外壳中。这将在它运行时输出很多信息，但现在都不应该有任何关注（除非在某个地方出现实际的错误信息）。一旦`dunecontrol`终止，在`dune-foo/build-cmake/src`中有一个新的可执行文件`dune-foo` 。用以下方法启动它



它将打印

~~~Shell
Hello World! This is dune-foo.
This is a sequential program.
~~~


祝贺你!你刚刚运行了你的第一个DUNE程序。




\subsection{Example: Solving the `Poisson` Equation Using Finite `Elements`}

为了从一个真实的例子开始，我们将用有限元方法解决泊松方程。更具体地说，我们将解释产生 [Fig2.11] 中所示函数的程序。该图中的函数是泊松方程的弱解

\begin{equation}
-\Delta u=-5
\label{3.1}
\end{equation}

在$L$形域$\Omega=(0,1)^{2} \backslash[0.5,1)^{2}$上，具有`Dirichlet`的边界条件。

\begin{equation}
u= \begin{cases}0 & \text { on }\{0\} \times[0,1] \cup[0,1] \times\{0\} \\ 0.5 & \text { on }\{0.5\} \times[0.5,1] \cup[0.5,1] \times\{0.5\}\end{cases}
\label{3.2}
\end{equation}

和边界的其余部分的零`Neumann`条件。域和边界条件显示在 [Fig3.1] 中。

该示例程序解决了`Poisson`方程，并将结果输出到一个文件中，可以用`PARAVIEW`可视化软件打开。该程序代码包含在一个文件中。我们不会在这里展示相当完整的源代码，因为完整的C++程序需要很大的空间。然而，整个代码印在附录B.2中。另外，本文件电子版的读者可以通过页边的小针状图标访问y源代码文件。建立这个例子的最简单方法是将程序文件复制到`dune-foo/src/`中，然后调整文件`dune-foo/src/CMakeLists.txt`，或者直接用这个例子替换现有文件`dune-foo.cc`，保留`CMakeLists.txt`。

一个用于解决`Poisson`方程的DUNE示例程序可以在不同的抽象层次上编写。它可以使用许多DUNE模块和高级功能。在这种情况下，用户代码会很短，但对程序的内部工作没有详细控制。另一方面，一个例子的实现可以被写成只依赖于几个低级模块。在这种情况下，更多的代码将不得不手工编写。这意味着更多的工作，但也意味着更多的控制和对程序具体工作方式的理解。

本章的例子试图找到一个中间地带。它使用了DUNE的网格、形状函数、离散函数空间和线性代数模块。它没有使用DUNE模块来组装代数系统--这部分是手工编写的。第$11.3$章包含一个替代的实现，它使用`dune-pdelab`来组装代数问题。

同时，重写这个例子以不使用DUNE函数空间或不同的线性代数实现是很容易的。这就是DUNE--用户在控制。第$3.4$节中的有限体积例子比这里的`Poisson`例子使用的DUNE的部分少得多。

\subsubsection{The main Method}

我们从主方法开始，也就是位于以下位置的部分

~~~C++
int main (int argc, char** argv)
{
    [...]
}

~~~


它位于文件的末尾，前面有几个构成有限元汇编器的类。作为第一个动作，它设置了MPI（如果可用）。

~~~C++
// Set up MPI, if available
MPIHelper::instance(argc, argv);
~~~


注意，即使程序是纯顺序的，也需要这个命令，因为它做了一些重要的内部初始化工作。

记住，所有的DUNE代码都驻留在`Dune`命名空间。因此，像MPIHelper这样的类型名称需要以 `Dune::` 为前缀。由于这使得代码更加难以阅读，所以示例文件中包含了以下一行

~~~C++
using namespace Dune;
~~~

靠近顶部的位置。这样就可以省略`Dune::`的前缀。



\textbf{Creating a Grid}

第一个真正的动作是创建一个网格。本例程序将使用 [Fig3.2] 中的三角形网格。DUNE中支持非结构化三角形网格的一个网格实现是UGGrid网格管理器。

9h 网格本身是从`GMSH`格式的文件中读取的 [^74] 。该文件可以通过点击边缘的注释图标获得。下面的代码用`GMSH`文件1-shape.msh中的网格设置了一个二维UGGrid对象。

~~~C++
constexpr int dim = 2;
using Grid = UGGrid<dim>;
std::shared_ptr<Grid> grid = GmshReader<Grid>::read("l-shape.msh");
grid->globalRefine(2);
using GridView = Grid::LeafGridView;
GridView gridView = grid->leafGridView();
~~~


这个代码块的前两行定义了用于有限元网格的$\mathrm{C}++$数据结构，第三行将网格从文件中加载到这个数据结构的一个对象中。注意，网格尺寸dim是一个编译时参数。第288行对网格进行两次均匀的细化，以得到更高的分辨率的结果。为了使这部分代码能够被编译，它需要有以下几行

~~~C++
#include <dune/grid/uggrid.hh>
#include <dune/grid/io/file/gmshreader.hh>
~~~


在顶部。最后两行将第二个细化步骤的结果提取为一个非层次的网格。这个所谓的`leaf grid view`是实际的有限元计算将在这里进行的。

第285行引入了类型变量Grid来存储所使用的网格数据结构的类型。这暗示了DUNE的一个优点：它很容易在不同的网格数据结构中使用相同的代码。在代码的其余部分，只要需要网格的类型，我们就只参考Grid。这样就可以通过替换Grid的定义和随后的构造函数调用来改变成，比如说，一个结构化的立方体网格。事实上，要用结构化的立方体网格来取代非结构化的网格，请将Lines $285-286$改为

~~~C++
using Grid = YaspGrid<dim>;
auto grid = std::make_shared<Grid>({1.0,1.0},   // Upper right corner,
                                                // the lower left one
                                                // is implicitly (0,0) here
                                    {10, 10});  // Number of elements
                                                // per direction

~~~

`YaspGrid`类，来自文件`dune/grid/yaspgrid.hh`，是DUNE中结构化立方体网格的标准实现。

\textbf{Assembling the Stiffness Matrix and Load Vector}

现在我们有了一个网格，我们可以组装刚度矩阵和载荷矢量了。为此，我们首先需要矩阵和矢量对象来进行组合。我们可以通过以下线条获得这些对象

~~~C++
using Matrix = BCRSMatrix<double>;
using Vector = BlockVector<double>;

Matrix stiffnessMatrix;
Vector b;
~~~


`BCRSMatrix`和`BlockVector`都是来自`dune-istl`模块的数据结构，并通过将

~~~C++
#include <dune/istl/bcrsmatrix.hh>
#include <dune/istl/bvector.hh>
~~~

在程序的顶部附近。然而，使用其他线性代数实现而不是来自 `dune-istl` 的线性代数实现是很容易的。这就是DUNE的另一个优点。

下一个代码块选择一阶有限元空间和体积源项。

~~~C++
Functions::LagrangeBasis<GridView,1> basis(gridView);

auto sourceTerm = [](const FieldVector<double,dim>& x){return -5.0;};
~~~


空间是通过为它提供一个`basis`来指定的。闭合形式的体积源项被写成一个$\mathrm{C}++$lambda对象。

为了使主方法更具可读性，实际的汇编代码被放入一个子程序中，接下来将调用该程序。
~~~C++
assemblePoissonProblem(basis, stiffnessMatrix, b, sourceTerm);
~~~

`assemblePoissonProblem`方法将在第3.3.2章讨论。

\textbf{Incorporating the `Dirichlet` Boundary Conditions}

在调用`assemblePoissonProblem`后，变量`stiffnessMatrix`包含\ref{2.11}中定义的刚度矩阵$A$，但我们仍然需要纳入`Dirichlet`边界条件。如果$i^{th}$自由度属于`Dirichlet`边界，我们用身份矩阵的一行覆盖相应的矩阵行，用规定的`Dirichlet`值覆盖右侧向量中的条目。

实施过程分两步进行。首先我们需要弄清楚哪些自由度是`Dirichlet`自由度。由于我们使用的是拉格朗日有限元，我们可以使用`Lagrange`节点的位置来确定哪些自由度被`Dirichlet`边界条件所固定。我们定义一个谓词类，根据给定的位置是否在`Dirichlet`的边界上，返回`true`或`false`。然后，我们在`Lagrange`的基础上对这个谓词进行评估，得到一个带有所需信息的布尔值向量。

~~~C++
auto predicate = [](auto x)
{
    return x[0] < 1e-8
        || x[1] < 1e-8
        || (x[0] > 0.4999 && x[1] > 0.4999);
};
// Evaluating the predicate will mark all Dirichlet degrees of freedom
std::vector<bool> dirichletNodes;
Functions::interpolate(basis, dirichletNodes, predicate);
~~~


一般来说，没有一种确定`Dirichlet`自由度的方法适合所有需要。这里使用的简单方法对`Lagrange`空间和简单的几何形状很有效。然而，DUNE也支持其他方法来寻找`Dirichlet`的边界。

现在，通过位域`dirichletNodes`，下面的代码片段对刚度矩阵进行了相应的修改。

~~~C++
// Loop over the matrix rows
for (size_t i=0; i<stiffnessMatrix.N(); i++)
{
    if (dirichletNodes[i])
    {
        auto cIt = stiffnessMatrix[i].begin();
        auto cEndIt = stiffnessMatrix[i].end();
        // Loop over nonzero matrix entries in current row
        for (; cIt!=cEndIt; ++cIt)
        *cIt = (cIt.index()==i) ? 1.0 : 0.0;
    }
}
~~~


第339行在所有矩阵行上循环，第341行测试该行是否对应于`Dirichlet`自由度。如果是这样的话，我们就使用第346行开始的迭代器循环，对该行的所有非零矩阵项进行循环。注意这个循环与C++标准库中的迭代器循环非常相似。最后，第347行通过比较列和行的索引，将矩阵条目设置为身份矩阵的相应值。

修改右手边的向量就更容易了。前面的循环可以扩展到同时覆盖$b$数组的相应条目，但同样可以第二次使用`dune-functions`模块的插值功能。

~~~C++
auto dirichletValues = [](auto x)
{
    return (x[0]< 1e-8 || x[1] < 1e-8) ? 0 : 0.5;
};
Functions::interpolate(basis,b,dirichletValues, dirichletNodes);
~~~


代码定义了一个新的lambda对象，实现了`Dirichlet`值函数，并在$b$向量对象中计算其`Lagrange`插值系数。`Functions::interpolate`方法的第四个参数将插值限制在`dirichletNodes`中相应条目被设置的那些自由度。所有其他的都没有被触动。

在这一点上，我们已经设置了线性系统

\begin{equation}
A x=b
\label{3.3}
\end{equation}

在第2.1章中得出，这个系统包含`Dirichlet`的边界条件。矩阵$A$存储在变量`stiffnessMatrix`中，载荷矢量$b$存储在变量b中。我们抓住时机，将矩阵和载荷矢量写入两个文件中。虽然本章不需要，但矩阵和向量文件将在本书后面的例子中使用。

~~~C++
std::string baseName = "getting-started-poisson-fem-"
            + std::to_string(grid->maxLevel()) + "-refinements";
storeMatrixMarket(stiffnessMatrix, baseName + "-matrix.mtx");
storeMatrixMarket(b, baseName + "-rhs.mtx");
~~~

数据以MATRIXMARKET格式写入，描述于 [^33] 。


\textbf{Solving the Algebraic Problem}

为了解决代数系统\ref{3.3}，我们将使用共轭梯度（CG）方法和ILU预处理程序（参见[^138]了解这些算法的工作背景）。这两种方法都在`dune-istl`模块中实现，并分别需要头文件`dune/istl/solvers.hh`和`dune/istl/preconditioners.hh`。下面的代码构建了预设条件的求解器，并将其应用于代数问题。

~~~C++
// Choose an initial iterate that fulfills the Dirichlet conditions
Vector x(basis.size());
x = b;
// Turn the matrix into a linear operator
MatrixAdapter<Matrix,Vector,Vector> linearOperator(stiffnessMatrix);
// Sequential incomplete LU decomposition as the preconditioner
SeqILU<Matrix,Vector,Vector> preconditioner(stiffnessMatrix,
                                            1.0); // Relaxation factor
// Preconditioned conjugate gradient solver
CGSolver<Vector> cg(linearOperator,
                    preconditioner,
                    1e-5, // Desired residual reduction factor
                    50, // Maximum number of iterations
                    2); // Verbosity of the solver
// Object storing some statistics about the solving process
InverseOperatorResult statistics;
// Solve!
cg.apply(x, b, statistics);
~~~


这段代码运行后，变量$\mathrm{x}$包含\ref{3.3}的近似解，b包含相应的残差，统计数据包含一些关于求解过程的信息，比如已经进行的迭代次数。

\textbf{Outputting the Result}

最后，我们要访问结果，特别是在屏幕上查看它。DUNE本身不提供任何可视化功能（因为专用的可视化工具做得很好，而DUNE团队不想与之竞争），但结果可以被写入各种不同格式的文件，以便进行后期处理。在这个例子中，我们将使用VTK文件格式 [^107] ，这是 `PARAVIEW` 软件的标准格式。这需要头文件 `dune/grid/io/file/vtk/vtkwriter.hh` ，以及以下代码。

~~~C++
VTKWriter<GridView> vtkWriter(gridView);
vtkWriter.addVertexData(x, "solution");
vtkWriter.write("getting-started-poisson-fem-result");
~~~


第一行创建了一个`VTKWriter`对象并注册了网格视图。第二行将解决方案向量$x$作为顶点数据添加到写作者对象中。字符串 "solution "是给数据字段的一个名称。它出现在`PARAVIEW`中，防止在有多个字段时发生混淆。第三行实际上是在写文件，给它命名为 `getting-started-poisson-fem-result.vtu` 。

\textbf{Running the Program}

除了刚度矩阵装配程序（将在下一节介绍）之外，现在已经讨论了完整的程序。它可以通过在build-cmake目录下键入make来构建。然后可执行程序getting-started-poisson-fem将出现在`build-cmake/src`目录下。程序启动后，可以看到`GmshReader`对象给出了它正在读取的网格文件的一些信息，然后是共轭梯度的迭代。

~~~Shell
Reading 2d Gmsh grid...
version 2.2 Gmsh file detected
file contains 43 nodes
file contains 90 elements
number of real vertices = 43
number of boundary elements = 22
number of elements = 62
=== Dune::IterativeSolver
Iter Defect Rate
0 3.26472
1 0.851622 0.260856
2 0.510143 0.599025
[...]
21 6.52302e-05 0.925161
22 4.68241e-05 0.717829
23 2.2387e-05 0.478109
=== rate=0.596327, T=0.0213751, TIT=0.000929351, IT=23
~~~


程序终止后，在 `build-cmake/src` 目录中有一个名为 `getting-started-poisson-femresult.vtu` 的文件，可以用例如 `PARAVIEW` 打开。它包含网格和求解函数 $u_{h}$ ，当使用高度场进行可视化时，结果应该看起来像 [Fig3.3] 。

\subsubsection{Assembling the Stiffness Matrix}

现在我们展示如何组装`Poisson`问题的刚度矩阵和载荷向量。这里的例子程序是 "手工 "完成的--它包含一个完整的汇编循环，只使用DUNE核心模块和`dune-functions` 。这将说明如何使用网格和离散函数接口，并且可以作为为其他PDEs编写汇编程序的起点。几个额外的DUNE模块为有限元汇编程序提供了完整的框架。请看 `dune-pdelab` , `dune-fem` , 和 `dune-fufem` 模块，并阅读 $11$ 章。

\textbf{The Global Assembler}

主汇编循环包含在方法`assemblePoissonProblem`中，它位于示例文件中主方法的上方。它的签名是

~~~C++
template<class Basis>
void assemblePoissonProblem(const Basis& basis,
                            BCRSMatrix<double>& matrix,
                            BlockVector<double>& b,
                            const std::function<
                                double(FieldVector<double,
                                    Basis::GridView::dimension>)
                                               > volumeTerm)

~~~



该方法实现了第2.1.3章中解释的装配循环；特别是，它装配了各个`element stiffness matrices`，并将它们相加以获得全局刚度矩阵。第一步，它通过以下方式从有限元基础中检索网格对象

~~~C++
auto gridView = basis.gridView();
~~~


然后，对象`gridView`是基础定义的有限元网格。

接下来，代码初始化了全局刚度矩阵。在`BCRSMatrix`对象可以被填入数值之前，它必须被赋予其占用模式，即可能出现非零矩阵条目的所有行/列对的集合。

~~~C++
MatrixIndexSet occupationPattern;
getOccupationPattern(basis, occupationPattern);
occupationPattern.exportIdx(matrix);
~~~



为了简洁起见，我们在此不显示`get0ccupationPattern`方法的代码，因为它与实际的汇编程序循环非常相似。请查阅附录B.2中的完整源代码，以详细了解它。

对于所有属于模式的矩阵条目，下一行会向矩阵中明确写入一个零。

~~~C++
matrix = 0;
~~~

最后，向量$\mathrm{b}$被设置为正确的大小，并且也填充了零。

~~~C++
// Set b to correct length
b.resize(basis.dimension());

// Set all entries to zero
b = 0;
~~~

在这些预演之后，开始对网格中的元素进行主循环。

~~~C++
auto localView = basis.localView();

for (const auto& element : elements(gridView))
{
~~~


变量`localView`实现了对单个元素的有限元基础的限制。在其他方面，它提供了局部的形状函数集，以及它们与全局自由度的关系。`for`循环遍历网格中的元素。来自`dune-grid`模块的自由方法元素就像gridView中的所有网格元素的容器。在每次迭代中，对象元素将是对当前网格元素的`const`引用。

在循环中，我们首先将`localView`对象与当前元素绑定。所有随后对这个`localView`的调用现在都将隐含地引用该元素。然后，我们创建一个小的密集矩阵，并为它调用元素矩阵组装程序。

~~~C++
localView.bind(element);

Matrix<double> elementMatrix;
assembleElementStiffnessMatrix(localView, elementMatrix);
~~~


在这个实现中，元素集合器为当前元素设置了正确的矩阵尺寸。在调用`assembleElementStiffnessMatrix`后，变量`elementMatrix`包含元素变量所引用的`element`的元素刚度矩阵。

最后，元素矩阵被添加到全局矩阵中。

~~~C++
 for(size_t p=0; p<elementMatrix.N(); p++)
 {
 // The global index of the p-th degree of freedom of the element
 auto row = localView.index(p);

 for (size_t q=0; q<elementMatrix.M(); q++ )
 {
 // The global index of the q-th degree of freedom of the element
 auto col = localView.index(q);
 matrix[row][col] += elementMatrix[p][q];
 }
 }
~~~



两个for-loop遍历所有的形状函数对。`localView`对象知道相应的全局自由度，并通过其`index`方法提供其数字。

\textbf{The Element Assembler}

最后，还有一个局部问题：给定一个网格元素$T$，为`Laplace`算子和给定的有限元基础组装元素刚度矩阵$A_{T}$。记住，`Poisson`问题的元素刚度矩阵的一个条目$\left(A_{T}\right)_{p q}$的形式为

$$
\left(A_{T}\right)_{p q}=\int_{T}\left\langle\nabla \phi_{i}, \nabla \theta_{j}\right\rangle d x
$$

其中$\phi_{i}$和$\theta_{j}$是来自试验和测试空间的基函数，分别对应于$p$-th和$q$-th的局部自由度。为简单起见，本例实现对两个空间使用相同的基数，因此我们只使用符号$\phi$来表示基数函数。

矩阵条目是通过将$T$上的积分转换为参考元素$T_{\text {ref }}$上的积分来计算的。

\begin{equation}
\left(A_{T}\right)_{p q}=\int_{T_{\mathrm{ref}}}\left\langle\nabla F^{-T} \nabla \hat{\phi}_{p}, \nabla F^{-T} \nabla \hat{\phi}_{q}\right\rangle|\operatorname{det} \nabla F| d \xi
\label{3.4}
\end{equation}

其中$F$是$T_{\text {ref }}$到$T$的映射，$\hat{\phi}_{p}, \hat{\phi}_{q}$是$T_{\text {ref }}$上的`shape functions`，对应于$T$上的基函数$\phi_{i}, \phi_{j}$ 。我们用点$\xi^{k}$和权重$\omega_{k}$的正交规则对\ref{3.4}进行近似。

$$
\left(A_{T}\right)_{p q} \approx \sum_{k} \omega_{k}\left\langle\nabla F^{-T}\left(\xi^{k}\right) \nabla \hat{\phi}_{i}\left(\xi^{k}\right), \nabla F^{-T}\left(\xi^{k}\right) \nabla \hat{\phi}_{j}\left(\xi^{k}\right)\right\rangle\left|\operatorname{det} \nabla F\left(\xi^{k}\right)\right|
$$

这就是本地汇编人员必须实现的公式。

相应的方法有如下签名。

~~~C++
 template<class LocalView, class Matrix>
 void assembleElementStiffnessMatrix(const LocalView& localView,
 Matrix& elementMatrix)
~~~


第一个参数是有限元基础的`LocalView`对象。从这个视图中我们可以得到关于当前元素的信息，特别是它的尺寸和形状。

~~~C++
 using Element = typename LocalView::Element;
 constexpr int dim = Element::dimension;
 auto element = localView.element();
 auto geometry = element.geometry();
~~~


`geometry`对象包含从参考元素$T_{\text {ref }}$到实际元素$T$的转换$F$ 。然后，我们得到这个元素的`shape functions`$\left\{\hat{\phi}_{p}\right\}_{p=0}^{n_{T}-1}$的集合。

~~~C++
 const auto& localFiniteElement = localView.tree().finiteElement();
~~~


用DuNE的话说，持有`shape functions`集合的对象被称为`local finite element`（细节在第8章给出）。需要调用`tree`的方法是一个技术问题。它的存在是为了支持矢量值或混合有限元空间，暂时可以忽略不计。

我们现在可以向`localView`对象询问这个元素的`shape functions`的数量，并相应地初始化元素矩阵。

~~~C++
 elementMatrix.setSize(localView.size(),localView.size());
 elementMatrix = 0; // Fill the entire matrix with zeros
~~~


那么我们需要一个正交规则。这种规则由文件 `dune-geometry` 中的 `dune/geometry/quadraturerules.hh` 模块提供。

~~~C++
58 int order = 2 * (localFiniteElement.localBasis().order()-1);
59 const auto& quadRule = QuadratureRules<double, dim>::rule(element.type(),
60 order);
~~~


第58行估计了一个适当的正交顺序，用于单线网格，第59行获得实际的规则，作为对`dune-geometry`模块持有的单子的引用。DUNE中的正交规则不过是一个`std::vector`的正交点，因此在所有的点上循环是很直接的。

~~~C++
 for (const auto& quadPoint : quadRule)
 {
~~~

现在，quadPoint是当前的正交点，我们需要它的位置$\xi^{k}$，反转的`Jacobian`$\nabla F^{-T}\left(\xi^{k}\right)$，以及那里的因子$\left|\operatorname{det} \nabla F\left(\xi^{k}\right)\right|$。这些信息是由DUNE网格界面通过`geometry`对象直接提供的。

~~~C++
 // Position of the current quadrature point in the reference element
 const auto quadPos = quadPoint.position();

 // The transposed inverse Jacobian of the map from the reference element
 // to the grid element
 const auto jacobian = geometry.jacobianInverseTransposed(quadPos);

 // The determinant term in the integral transformation formula
 const auto integrationElement = geometry.integrationElement(quadPos);
~~~



然后我们计算所有`shape functions`$\left\{\nabla \hat{\phi}_{p}\right\}$在参考元素上的导数，并从左边乘以$\nabla F^{-T}$，得到基础函数$\left\{\nabla \phi_{i}\right\}$在元素$T$的梯度。

~~~C++
82 // The gradients of the shape functions on the reference element
83 std::vector<FieldMatrix<double,1,dim> > referenceGradients;
84 localFiniteElement.localBasis().evaluateJacobian(quadPos,
85                                                  referenceGradients);
86
87 // Compute the shape function gradients on the grid element
88 std::vector<FieldVector<double,dim> > gradients(referenceGradients.size());
89 for (size_t i=0; i<gradients.size(); i++)
90      jacobian.mv(referenceGradients[i][0], gradients[i]);

~~~

请注意$\left\{\hat{\phi}_{p}\right\}$的梯度是如何存储在第83行的`matrices`数组中的一行。这是因为`dune-localfunctions`将所有`shape functions`视为向量值函数，标量值空间的向量大小为1。在标量情况下，将梯度$\nabla \hat{\phi}_{p}$作为一个向量获得，需要在第90行使用后缀[^0]，它返回一个`FieldVector<double, dim>`类型的对象。

最后我们计算出实际的矩阵条目。

~~~C++
for (size_t p = 0; p < elementMatrix.N(); p++)
{
    auto localRow = localView.tree().localIndex(p);
    for (size_t q = 0; q < elementMatrix.M(); q++)
    {
        auto localCol = localView.tree().localIndex(q);
        elementMatrix[localRow][localCol] += (gradients[p] * gradients[q]) * quadPoint.weight() * integrationElement;
    }
}
~~~


通过运算符重载，`gradients [p]*gradients [q]`实现了两个向量之间的标量乘积。表达式`localView.tree().Iocalindex(p)`和`localView.tree().localindex(q)`从形状函数数计算元素矩阵指数。在这个简单的例子中，它们只是分别将$p$映射到$p$和$q$映射到$q$ 。更多细节见第10章。





\subsection{Example: Solving the Transport Equation with a Finite Volume Method}

本章介绍的第二个例子程序将展示如何实现一个简单的一阶有限体积法。这将演示DUNE网格界面的一些其他功能，例如，如何获得面法线和体积。

与上一节的`Poisson`求解器相比，所提出的有限体积实现使用的DUNE库的功能要少得多。没有使用专门的线性代数库，而是使用了C++标准库中的系数向量类型。同样，虽然`cell-centered`有限体积方法可以使用`dune-functions`模块中的函数空间基础对象来实现，但这不会使代码变得更简单。因此，这个例子完全不依赖于`dune-functions`。

\subsubsection{Discrete Linear Transport Equation}

作为示例问题，我们将使用在第2.2.1章中已经遇到的线性标量传输方程。让$\mathbf{v}: \Omega \times\left(0, t_{\text {end }}\right) \rightarrow \mathbb{R}^{d}$是一个给定的速度场，$c: \Omega \times\left[0, t_{\text {end }}\right] \rightarrow \mathbb{R}$是一个未知浓度。浓度沿速度流线的传输由以下方程描述

$$
\frac{\partial c}{\partial t}+\operatorname{div}(c \mathbf{v})=0 \quad \text { in } \Omega \times\left(0, t_{\text {end }}\right)
$$

在这个例子中，我们选择域$\Omega=(0,1)^{2}$，和最终时间$t_{\text {end }}=0.6$。作为速度场，我们选择

$$
\mathbf{v}(x, t)=(1,1)
$$




它是静止的和无发散的（[Fig3.4]）。通过对这个场的选择，边界的一部分成为流入的边界

$$
\Gamma_{\mathrm{in}}(t):=\{x \in \partial \Omega:\langle\mathbf{v}(x, t), \mathbf{n}(x)\rangle<0\}
$$

其中$\mathbf{n}$是领域单位外法线。在目前的例子中，流入边界由正方形的下边和左边组成，并在一段时间内保持固定。在流入的边界上，我们规定了浓度

$$
c(x, t)=0 \quad x \in \Gamma_{\mathrm{in}}, \quad t \in\left(0, t_{\mathrm{end}}\right)
$$

最后，我们提供初始条件

$$
c(x, 0)=c_{0}(x) \quad \text { for all } x \in \Omega
$$

我们将其设置为

$$
c_{0}(x)= \begin{cases}1 & \text { if }|x|>0.125 \text { and }|x|<0.5 \\ 0 & \text { otherwise }\end{cases}
$$

对于离散化，我们用一个由$n=80 \times 80$四边形元素组成的均匀网格覆盖该领域。时间间隔$\left[0, t_{\text {end }}\right]$被分割成均匀的子步骤

$$
0=t_{0}<t_{1}<t_{2}<\cdots<t_{m}=t_{\text {end }}
$$

步长为$\Delta t_{k}:=t_{k+1}-t_{k}=0.006$ 。我们用$T_{i}$表示$i^{th}$网格元素，$\left|T_{i}\right|$表示其体积。同样，$\gamma_{i j}$将表示元素$T_{i}$的共同面，$T_{j},\left|\gamma_{i j}\right|$表示该面的面积，$\mathbf{n}_{i j}$表示从$T_{i}$到$T_{j}$的单位法线。在$\gamma_{i j}$中心评估的速度场$\mathbf{v}$将被称为$\mathbf{v}_{i j}$ 。如第2.2.1节所述，我们在空间上使用`cell-centered`有限体积离散法，对通量进行完全的上风评估，在时间上使用显式`Euler`方案。特别是，我们用一个片断常数函数来近似未知浓度$c$，并通过该元素上$T_{i}, i=0, \ldots, n-1$的平均值$c$来确定该函数的值$\bar{c}_{i}$。我们得到以下关于时间$t_{k+1}$的未知元素平均数$\bar{c}_{i}^{k+1}$的方程式。

\begin{equation}
\bar{c}_{i}^{k+1}\left|T_{i}\right|-\bar{c}_{i}^{k}\left|T_{i}\right|+\Delta t_{k} \sum_{\gamma_{i j}}\left|\gamma_{i j}\right| \phi\left(\bar{c}_{i}^{k}, \bar{c}_{j}^{k},\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)=0 \quad \forall i=0, \ldots, n-1
\label{3.5}
\end{equation}

通量函数 $\phi$ 是跨越元素边界 $\gamma_{i j}$ 的通量 $\left\langle c \mathbf{v}, \mathbf{n}_{i j}\right\rangle$ 的一个近似值。在第$2.2.1$节中，我们已经推导出表达式

\begin{equation}
\phi\left(\bar{c}_{i}^{k}, \bar{c}_{j}^{k},\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right):=\bar{c}_{i}^{k} \max \left(0,\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)-\bar{c}_{j}^{k} \max \left(0,-\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)
\label{3.6}
\end{equation}

请注意，它在两种情况下有效切换，取决于是否有通量从$T_{i}$到$T_{j}$或反之。将通量函数（3.6）插入\ref{3.5}并重新排列项，我们可以在时间$t_{k+1}$为未知系数$\bar{c}_{i}^{k+1}$解决\ref{3.5}。由此得出的公式是一个简单的矢量更新

\begin{equation}
\bar{c}^{k+1}=\bar{c}^{k}+\Delta t_{k} \delta^{k}
\label{3.7}
\end{equation}

更新矢量$\delta^{k} \in \mathbb{R}^{n}$由以下公式给出

\begin{equation}
\delta_{i}^{k}:=-\sum_{\gamma_{i j}} \frac{\left|\gamma_{i j}\right|}{\left|T_{i}\right|}\left(\bar{c}_{i}^{k} \max \left(0,\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)+\bar{c}_{j}^{k} \max \left(0,-\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)\right)
\label{3.8}
\end{equation}

\subsubsection{The main Method}

有限体积例子的实现同样包含在一个文件中。完整的文件印在附录中（B.3章），电子版文本的用户可以通过点击页边的图标得到它。不要忘记，这个程序又有

~~~C++
using namespace Dune;
~~~

在顶部，以避免重复写`Dune::prefix`。

该实现分为两个方法：`main`方法和一个计算并应用\ref{3.8}中定义的更新向量$\delta$的方法进化。我们首先讨论`main`方法。与有限元的情况一样，它首先设置了`MPIHelper`变量。

~~~C++
 int main(int argc, char *argv[])
 {
 // Set up MPI, if available
 MPIHelper::instance(argc, argv);

~~~


`MPIHelper`实例设置了MPI消息传递系统，如果它被安装的话。尽管这个例子没有使用MPI，但DUNE的一些部分在内部调用它，不初始化它将导致运行时错误。

第一个真正的代码块设置了网格。

~~~C++
 constexpr int dim = 2;
 using Grid = YaspGrid<dim>;
 Grid grid({1.0,1.0}, // Upper right corner, the lower left one is (0,0)
 { 80, 80}); // Number of elements per direction

 using GridView = Grid::LeafGridView;
 GridView gridView = grid.leafGridView();
~~~


与前面的例子不同，有限体积的实现使用了一个结构化的网格。因此不需要从文件中读取网格，只要给出边界框和每个方向的元素数就足够了。

然后，我们为元素浓度平均数设置了矢量 $\bar{c}_{i}$ 。

~~~C++
130 MultipleCodimMultipleGeomTypeMapper<GridView>
131 mapper(gridView, mcmgElementLayout());
132
133 // Allocate a vector for the concentration
134 std::vector<double> c(mapper.size());
~~~


在第130行构建的`MultipleCodimMultipleGeomTypeMapper`对象是一个为网格元素分配数字的设备。这些数字随后被用来寻址存放实际模拟数据的数组。映射器的作用与前面例子中的函数空间基础相似，但它是一个更低级的构造，功能较少。它是由`dune-grid`模块提供的。

第134行创建了用于存储浓度值的数组 $\bar{c}_{i}$ 。请注意，我们使用了C++标准库中的数组类型。它不依赖于DUNE线性代数模块 `dune-istl` 或任何其他专用的线性代数库。

然后，数组$c$在元素中心被填充了初值函数$c_{0}$的值。首先，函数$c_{0}$被实现为一个lambda对象。

~~~C++
 auto c0 = [](const FieldVector<double,dim>& x)
 {
 return (x.two_norm()>0.125 && x.two_norm()<0.5) ? 1.0 : 0.0;
 };
~~~

然后，代码在元素上循环，在元素中心取样c0。这些单点评估被用作代数变量$\bar{c}_{i}^{k}$所代表的元素平均数的近似值。

~~~C++
146 // Iterate over grid elements and evaluate c0 at element centers
147 for (const auto& element : elements(gridView))
148 {
149     // Get element geometry
150     auto geometry = element.geometry();
151
152     // Get global coordinate of element center
153     auto global = geometry.center();
154
155     // Sample initial concentration c0 at the element center
156     c[mapper.index(element)] = c0(global);
157 }
~~~


在前面的例子中已经出现了元素的循环。注意第153行中使用的特殊方法`center`，以获得元素中心的坐标。虽然有一个更通用的机制来获取元素中任何一点的坐标（`geometry`对象的`global`方法），但元素中心在有限体积方案中使用得非常频繁，因此存在一个专门的方法。然后中心坐标被用作函数对象$\mathrm{cO}$的参数，它返回该点的初始浓度$c_{0}$。第156行显示了如何使用映射器对象。它的索引方法为给定的元素返回一个非负整数，用来访问数据阵列c。

下一个代码块为VTK格式构造一个写入器，并将离散的初始浓度写入一个文件。

~~~C++
162 auto vtkWriter = std::make_shared<Dune::VTKWriter<GridView> >(gridView);
163 VTKSequenceWriter<GridView>
164     vtkSequenceWriter(vtkWriter,
165         "getting-started-transport-fv-result"); // File name
166
167 // Write the initial values
168 vtkWriter->addCellData(c,"concentration");
169 vtkSequenceWriter.write(0.0); // 0.0 is the current time

~~~


第162行中的`VTKWriter`结构将各个浓度字段写入各个文件。下一行中的`VTKSequenceWriter`将这些数据联系在一起，成为一个时间序列的数据。除了单个的数据文件，它还写了一个`sequence`文件（后缀为.pvd），其中列出了所有数据文件及其时间点$t_{k}$ 。即使时间步长不一致，这些信息也能使随时间变化的数据正确地可视化。

主方法的最后一个块是实际的时间循环。

~~~C++
174 double t=0; // Initial time
175 const double tend=0.6; // Final time
176 const double dt=0.006; // Time step size
177 int k=0; // Time step counter
178
179 // Inflow boundary values
180 auto inflow = [](const FieldVector<double,dim>& x)
181 {
182     return 0.0;
183 };
184
185 // Velocity field
186 auto v = [](const FieldVector<double,dim>& x)
187 {
188     return FieldVector<double,dim> (1.0);
189 };
190
191 while (t<tend)
192 {
193     // Apply finite volume scheme
194     evolve(gridView,mapper,dt,c,v,inflow);
195
196     // Augment time and time step counter
197     t += dt;
198     ++k;
199
200     // Write data. We do not have to call addCellData again!
201     vtkSequenceWriter.write(t);
202
203     // Print iteration number, time, and time step size
204     std::cout << "k=" << k << " t=" << t << std::endl;
205 }

~~~



第174-177行初始化了几个变量，还有两个lambda对象`inflow`和$\mathrm{v}$分别用于流入的边界条件和速度场。从第191行开始的循环一直迭代到当前时间$t$超过指定的结束时间趋势。大部分的实际工作是在一个单独的方法`evolve`中完成的，我们在下面讨论。然后，主循环将浓度向量写入文件，并继续进行下一个时间步骤。

当运行时，该示例程序产生101个输出文件，以及序列文件 `getting-started-transport-fv-result.pvd` 。仿真结果的可视化在 [Fig3.5] 中给出。我们可以清楚地看到初始条件是如何沿着速度场传输的 $v$ 。明显的扩散是由粗略的数值方法造成的。

\subsubsection{The `evolve` Method}

`evolve`方法做了主要部分的工作。在每次调用`evolve`之后，当前迭代已经推进到下一个时间步长。

该方法的签名是。

~~~C++
17 template<class GridView, class Mapper>
18 void evolve(const GridView& gridView,
19             const Mapper& mapper,
20             double dt, // Time step size
21             std::vector<double>& c,
22             const std::function<FieldVector<double,GridView::dimension>
23                              (FieldVector<double,GridView::dimension>)> v,
24             const std::function<double
25                              (FieldVector<double,GridView::dimension>)> inflow)

~~~


前两个参数是网格和映射器。第三个参数是元素浓度值数组c。这个参数是一个非静态引用，因为该数组是就地修改的。参数$\mathrm{v}$和`inflow`分别是速度场和流入的边界条件函数。

该方法由一点初始化代码开始。

~~~C++
29 // Grid dimension
30 constexpr int dim = GridView::dimension;
31
32 // Allocate a temporary vector for the update
33 std::vector<double> update(c.size());
34 std::fill(update.begin(), update.end(), 0.0);
~~~


第33行设置的数组是$\delta^{k}$中定义的修正 $(3.8)$ 。

然后代码在所有的网格元素上循环 $T_{i}$ 。

~~~C++
39 for (const auto& element : elements(gridView))
40 {
41 // Element geometry
42 auto geometry = element.geometry();
43
44 // Element volume
45 double elementVolume = geometry.volume();
46
47 // Unique element number
48 typename Mapper::Index i = mapper.index(element);
~~~


这是在第 $3.3$ 章中的全局有限元集合器中已经看到的同类循环。对于每个元素 $T_{i}$ ，循环计算 \ref{3.8} 中定义的更新 $\delta_{i}^{k}$ 。在循环的顶部，元素体积$\left|T_{i}\right|$和它的索引$i$被预先计算。

元素$T_{i}$的修正$\delta_{i}^{k}$的公式\ref{3.8}由所有元素$T_{j}$的和组成，这些元素的边界与$T_{i}$的边界相交于一个$d-1$-维的集合。这种邻接关系在DUNE网格界面中由`Intersection`类型的对象表示。这些对象提供了关于一个元素与特定邻居或域边界关系的所有相关信息。这个概念被刻意概括为允许不符合要求的网格，即两个元素的交点不一定是一个共同的面的网格。因此，\ref{3.8}中的和被编码为对当前元素的所有交点的循环。

~~~C++
53 for (const auto& intersection : intersections(gridView,element))
54 {
55      // Geometry of the intersection
56      auto intersectionGeometry = intersection.geometry();
57
58      // Center of intersection in global coordinates
59      FieldVector<double,dim>
60          intersectionCenter = intersectionGeometry.center();
61
62      // Velocity at intersection center vij
63      FieldVector<double,dim> velocity = v(intersectionCenter);
64
65      // Center of the intersection in local coordinates
66      const auto& intersectionReferenceElement
67          = ReferenceElements<double,dim-1>::general(intersection.type());
68      FieldVector<double,dim-1> intersectionLocalCenter
69          = intersectionReferenceElement.position(0,0);
70
71      // Normal vector scaled with intersection area: nij | ij |
72      FieldVector<double,dim> integrationOuterNormal
73          = intersection.integrationOuterNormal(intersectionLocalCenter);
74
75      // Compute factor occuring in flux formula: hvij , nij i| ij |
76      double intersectionFlow = velocity*integrationOuterNormal;
~~~



循环本身使用了在网格元素上循环时已经看到的方便的基于范围的for语法。然后计算速度 $\mathbf{v}_{i j}$ 和乘积 $\mathbf{n}_{i j}\left|\gamma_{i j}\right|$ 。为了计算$\mathbf{v}_{i j}$，即$T_{i}$与其当前邻居$T_{j}$的共同交点中心的速度场$\mathbf{v}$的值，第56行首先获得$T_{i}$和$T_{j}$之间交点的几何图形（即形状）。就像一个元素的几何形状一样，这个交叉点的几何形状有一个中心方法，在第60行被调用。第63行然后评估该位置的速度场。

为了评估$\mathbf{n}_{i j}$，我们需要交点的局部坐标中的交点中心。这方面的直接方法并不存在。另一方面，有一个对应于交点的参考元素，它知道其中心。该参考元素在第67行被获取，其中心在第69行被评估。

代码没有单独计算$\left|\gamma_{i j}\right|$和$\mathbf{n}_{i j}$，而是调用一个专门的DUNE网格接口方法`integrationOuterNormal`，直接得出两者的乘积。这个乘积在有限体积方法中经常使用，所以专用方法是有意义的。更重要的是，直接评估比例法线$\left|\gamma_{i j}\right| \mathbf{n}_{i j}$，而不是先计算这两个单独的因子，可能会更有效率。

交叉循环的后半部分计算元素 $T_{i}$ 的实际更新 $\delta_{i}^{k}$ 。

~~~C++
80 // Outflow contributions
81 update[i] -= c[i]*std::max(0.0,intersectionFlow)/elementVolume;
82
83 // Inflow contributions
84 if (intersectionFlow<=0)
85 {
86      // Handle interior intersection
87      if (intersection.neighbor())
88      {
89          // Access neighbor
90          auto j = mapper.index(intersection.outside());
91          update[i] -= c[j]*intersectionFlow/elementVolume;
92      }
93
94      // Handle boundary intersection
95      if (intersection.boundary())
96          update[i] -= inflow(intersectionCenter)
97                      * intersectionFlow/elementVolume;
98 }
~~~


第81行增加了$-\bar{c}_{i} \frac{\left|\gamma_{i j}\right|}{\left|T_{i}\right|} \max \left(0,\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle\right)$，它涵盖了当前的交叉点是元素`outflow boundary`的$T_{i}$的情况。如果 $\left\langle\mathbf{v}_{i j}, \mathbf{n}_{i j}\right\rangle<0$ ，即，如果有流量进入元素 $T_{i}$ ，我们需要区分 $\gamma_{i j}$ 是否真的是与第二个元素 $T_{j}$ 的交点，或者 $\gamma_{i j}$ 是否是域边界 $\partial \Omega$ 的一部分（在这种情况下，它是在流入边界 $\left.\Gamma_{\text {in }}\right)$ 。线$84-98$涵盖了这两种情况。观察交叉点如何知道是否有相邻的元素$T_{j}$（通过邻居方法），以及我们是否在域边界上（通过边界方法）。如果网格分布在几个处理器上，两个方法可能同时返回`false`。然而，在这个简单的顺序的例子中，这种情况不可能发生。

这就结束了交叉点的循环，元素的循环也结束了。

~~~C++
100     } // End loop over all intersections
101 } // End loop over the grid elements
~~~


最后，浓度向量被更新。

~~~C++
105 // Update the concentration vector
106 for (std::size_t i=0; i<c.size(); ++i)
107     c[i] += dt*update[i];
108 }
~~~


关于`evolve`方法的讨论到此结束。






\section{The Design and Structure}

DUNE是一个大型软件系统。就像所有这样的系统一样，总是存在着程序复杂性不受控制地增加的危险，使得程序维护越来越困难。DUNE试图通过模块化设计和一套关于编程接口（API）应该是什么样子的规则来控制这个问题。这一章解释了这一设计的动机。它还给出了一些在$\mathrm{C}++$中编写接口的背景，并讨论了DUNE在这些接口方面采用的一些惯例。

\subsection{Software Functionality for Finite Element and Finite Volume Methods}

从第二章对有限元和有限体积方法的简要介绍中可以看出，实现这种方法所需的软件功能可以归纳为几个领域。下面是一个比较突出的列表。

\textbf{Grid Handling} 第二章的所有方法都依赖于一个计算网格。因此，这种方法的软件系统需要为这种网格提供一个数据结构。该数据结构需要允许有效地访问那些与有限元和有限体积方法有关的网格方面。例如，必须能够在所有网格元素上循环，以集合刚度矩阵，并且必须能够使用从参考元素到网格元素的映射$F_{T}$来执行数值正交。网格也需要从文件中读出，并在以后写回，以实现结果的可视化。

网格有多种类型，从简单的三角形网格（如 [Fig2.2] 中的网格）到 [Fig2.3] 中的奇特网格。一个好的网格软件必须处理所有这些情况，同时保留最大的效率。网格数据结构应该支持各种类型的局部细化和粗化，并可能允许顶点重新定位（ `r-refinement` ，见 [^95] ）。理想情况下，它们实现了第 $2.3.3$ 章的细化树的概念，然后也允许实现几何多网格方法 [^37] [^155] 。

在本书中，我们对网格的处理和网格的构建进行了区分。我们认为后者的问题超出了DUNE的范围，最好留给专门的特殊用途软件。概述见[^153]。






\textbf{Finite Element Basis Functions and Shape Functions} 正如在第2.1.2章中所看到的，有限元问题的装配需要跨越给定有限元空间的基础函数。这些函数可以直接使用，但它们经常被拉回参考元素，然后被称为形状函数。因此有限元代码必须直接或以形状函数的形式提供有限元基函数的实现。虽然主要使用一些标准的基函数，但对于特殊问题也有各种相当奇特的有限元基函数 [^106] 。

在有限元装配程序中，`shape functions`通常出现在积分项中。对于二阶PDEs，需要基函数值和一阶导数，但对于高阶方程，基函数的高阶导数可能成为必要。此外，还需要一种机制来将单个`shape functions`与全局自由度联系起来。

\textbf{Numerical Quadrature} 构成刚度矩阵和载荷向量的条目的积分\ref{2.14}和\ref{2.15}一般不能以封闭形式进行评估。因此，计算机代码必须为参考元素提供一个数字正交机制。正交规则是一个相当简单的对象，只包括参考元素中的一组点和相应的标量权重。有限元代码被期望提供一个这样的规则库，用于不同的元素类型，直到高阶，并且可能具有高的精度。这通常意味着储存大量的点坐标和权重表。

\textbf{Assembly} 代码中需要有一个部分，对于一个给定的方程和有限元空间，使用到目前为止描述的基础设施，组装刚度矩阵和载荷向量。在最简单的情况下，这段代码实现了第2.1.3章的循环。虽然循环本身对所有的PDEs都是一样的，但`element stiffness matrices`的装配取决于问题。因此，有限元软件通常会提供不同PDEs的局部装配例程集合。

\textbf{Matrices and Vectors} 汇编程序的结果通常是一个线性或非线性的代数方程组。因此，计算机代码需要提供数据结构来处理这种系统。全局刚度矩阵通常是稀疏的，也就是说，它们包含大量的零条目。稀疏矩阵有多种数据结构，每种结构都有优点和缺点[^133]；有效的计算机代码会给用户一个选择。另外，许多有限元离散化在自由度中引入了某种形式的块结构。线性代数数据结构可以尝试反映这一点，以提高效率。

\textbf{Algebraic Solvers} 最后，需要解决由问题离散化产生的代数问题。在大多数情况下，这涉及到解决大型稀疏线性方程组的问题。许多不同的算法被用于此，包括直接方法 [^47] , `Krylov` 方法 [^138] , 和多网格方法 [^37] [^155] 。对于非线性问题，牛顿型方法很常见。这类方法必须与离散化紧密互动，因为切向刚度矩阵必须在每次迭代中重新组合，而且将求解器的精度和阻尼与离散化误差相联系可能会有帮助 [^53] 。

\textbf{Concurrency and Communication} 今天的许多应用PDE问题变得如此巨大和具有挑战性，以至于需要利用现代硬件的各个方面来获得可接受的模拟时间。这包括各种层次的并发，如矢量计算、多线程和分布式计算。这些技术中有几个需要在并行运行的线程或进程之间进行通信。虽然存在良好的进程间通信的通用库（MPI是最突出的一个），但它们通常不直接支持偏微分方程仿真软件中使用的那种结构化的通信模式。例如，有限元代码中的通信通常会将子域网格边界附近的数据发送到持有相邻子域网格的处理器。一个好的有限元软件应该直接提供这样的功能，并帮助将这些通信模式从基于网格的观点转化为MPI的网格无关的观点。

\subsection{The Structure of Dune}

大多数有限元或有限体积代码都以某种方式提供了前面列表中的功能。然而，他们通常将其结合在一个单一的程序中。这意味着有一个单一的程序需要下载和安装。这个程序包含所有的功能，紧紧相连。它可以由图形用户界面（如ABAQUS）、脚本语言（FENICS[^120]或pdelib）控制，也可以像库一样提供编程接口。

相比之下，DUNE不是一个单一的程序。相反，它是一组库，它们尽可能地相互独立。在DUNE的术语中，每个这样的库被称为一个模块。每个模块都包含一个独特的、定义明确的功能部分。这种分离是基于上一节给出的需求清单：有一个网格处理模块，一个形状函数模块，一个线性代数模块和几个离散模块。  [Fig4.1]显示了本书所涉及的所有DuNE模块的图表，以及它们的依赖关系图。第$4.3$章对中心组件（称为核心模块）进行了概述，本书后面的几章则专门讨论了各个模块。

每个DuNE模块都是一个单独的实体，必须单独下载和安装。它包含一个名为dune.module的文本文件，正式指定对其他模块的依赖性。大多数的依赖关系将是硬性要求，这意味着







如果没有它所依赖的模块，一个模块根本就不能被构建。另外，依赖关系也可以是建议。在这种情况下，一个模块在没有依赖关系的情况下也可以工作，但功能会减少。

一组具有依赖关系的模块形成一个有向无环图。一个叫做dunecontrol的特殊程序（由`dune-common`模块提供）跟踪并解决这些依赖关系。换句话说，如果一个特定的模块需要被构建，dunecontrol会确保其所有的依赖关系在需要的时候被构建并可用。在这个意义上，dunecontrol的行为非常像不同的Linux发行版所使用的软件包管理器。dunecontrol程序的描述见附录A.1.1。

一旦一套DUNE模块被安装在系统上，最终用户就可以像其他$\mathrm{C}++$库一样使用它。例如，DUMUx [^109] 和 KASKADE [^76] 项目都在一些 DUNE 模块之上建立了 PDE 仿真工具箱。另一方面，许多应用程序开发人员也以DUNE模块的形式编写他们的应用代码。这给了他们一个新项目的开端（在duneproject程序的帮助下，一个空的新DUNE模块和所有构建系统的模板代码可以很容易地创建），并自动处理依赖性跟踪。此外，作为一个应用程序开始的东西，最终变成其他模块想要依赖的东西，这并不罕见。如果这个应用程序是一个DUNE模块，这就很容易实现。将DUNE设计成一组独立的库，而不是作为一个单一的代码，有相当多的优点。

- 使用DUNE并不是一个全有或全无的决定。一个单一的代码要么完全使用，要么根本不使用。如果一个给定的代码在一个领域表现出色，但在另一个领域却不尽如人意，这可能是个问题。另一方面，在DUNE中，只有那些真正需要的部分必须被安装和使用，而其他部分则可以使用其他东西。例如，有非常好的线性代数库可用。虽然DUNE确实提供了自己的线性代数（在`dune-istl`模块中，见第7章），但很容易将DUNE用于网格，而将其他东西（例如PETSC）用于线性代数。这极大地增加了用户的灵活性。

- 一个相关的观点是，模块化的结构使得迁移到DUNE（或离开DUNE）更加容易。假设我们的目标是移植一个有限元代码，它自己实现了整个基础设施，如网格、形状函数等，以代替DUNE的运行。与其一次性重写整个底层并切换到DUNE，不如一个模块一个模块地进行。例如，第一步可以保持代码的原样，只用调用`shape functions`来取代实现`dune-localfunctions`的部分。一旦运行稳定，下一步就可以用`dune-grid`中的数据结构取代网格数据结构。这种方式使过渡期的破坏性大大降低。

- DUNE的模块化结构允许一个分散的开发模式。第三方开发者可以在独立的模块中提供额外的功能，而不需要接触DUNE的核心模块。这种情况确实发生了：DUNE项目的网页上列出了一系列以各种方式扩展DUNE的模块，但这些模块是由与DUNE项目没有直接关系的人实现和主持的。例如，用于角点网格的OPM-grid网格管理器[^117] [^135]目前由`Open Porous Media Initiative`托管，dune-fufem离散化模块和dune-curvilinear模块用于具有多项式几何的网格。

这种分散模式的好处是，许多人可以在一个共同的软件系统上工作，同时将必要的沟通保持在最低水平。这可以战胜布鲁克定律，该定律指出，随着软件工程团队规模的扩大，沟通所损失的时间将吞噬因拥有更多团队成员而获得的额外生产力 [^39] 。相反，小的敏捷团队可以专注于单个模块，而不必太在意更大的DUNE生态系统。







- 分散式开发风格的一个副作用是出现了几个竞争性的相同功能的实现。最典型的例子是`dune-pdelab`和dune-fem模块，它们都实现了有限元和有限体积离散化程序（dune-pdelab在第11章介绍）。两者都是成熟的项目，有相当的用户基础。由于两者都有各自的优势，拥有这两个模块可以给用户带来更多的选择和灵活性。

- DUNE的设计是一套独立的模块，这使得它可以快速建立原型。要快速尝试一些东西，创建一个新的模块并尝试你想尝试的东西。如果不成功，只需删除模块目录，它就会完全消失。这有助于避免研究代码中有时出现的功能蠕变，即偶尔增加一些小功能，"只在短时间内"，然后再删除。

- 最后但同样重要的是，模块化设计是好的软件设计。模块化的代码更容易阅读和理解，因为模块只能访问它们明确声明依赖的其他模块的功能。相比之下，单体代码有时会有形成 "意大利面条结构"[^161]的倾向，这使得它们更难以理解和维护。

DUNE是第一批在PDE背景下实施这种激进的模块化的项目之一，而且效果非常好。

\subsection{The Dune Core Modules}

由于其分散的开发方式，不同的DUNE模块可以从不同的来源获得。但有一组六个模块构成了DUNE的核心，或者说DUNE本身。这些模块被称为DUNE核心模块。它们被托管在项目的主网站上，网址是www.dune-project.org，它们的开发由DUNE指导委员会负责监督。各个模块的功能遵循我们在第4.1章中描述的主题块。这种对应关系并不总是完美的，有时因为技术原因，有时因为历史原因而出现偏差。

我们在这里简单介绍一下核心模块，但在后面的章节中也会对它们进行详细描述。

- 模块`dune-common`是一切的基础。它包含了构建系统的基本架构，跟踪模块间依赖关系的dunecontrol程序，以及创建新模块的`duneproject`程序（见3.2.1节）。它还包含大量的辅助代码，如特殊容器

$a b$ 类，模板元编程的帮助，密集矩阵和向量类，分布式索引的实现，以及更多。  `dune-common`是所有其他模块所依赖的，没有它，DUNE就无法使用。

由于`dune-common`基本上是一个独立的辅助类的集合，没有什么相互关系，所以本书没有关于它的单独章节。了解`dune-common`所提供的最简单的方法是查看它的在线参考文档，网址是www.dune-project.org。

- `dune-grid` 为有限体积和有限元计算提供计算网格。它包含了 $\mathrm{C}++$ 中用数学术语描述的网格的抽象接口 [^15] 。这包括顶点和元素的迭代器，处理自适应网格细化的机制，以及分布式机器上的网格划分等内容。它不包括创建非结构化网格的机制，这将留给外部软件。第五章对 `dune-grid` 接口进行了详细解释。

除了接口之外，`dune-grid`模块还包含了几个网格的接口实现。其中一些是原生的，如`YaspGrid`，一个结构化的并行网格，或`OneDGrid`一个完全自适应的一维网格。其他的是对现有有限元库的网格管理器的封装。目前，`dune-grid`包含ALBERTA [^141]和UG3 [^13]的网格的适配器。后者的实际代码包含在dune-uggrid模块中，它是`dune-grid`的一个建议依赖项。抽象接口和实现之间的分离允许以一种简单、高效和统一的方式访问这些网格管理器的功能。

- 模块`dune-geometry`包含了网格界面的一部分，从`dune-grid`中分离出来成为一个单独的模块。在DUNE术语中，几何体是指从参考元素到世界空间的映射$F_{T}$，它描述了单个网格元素的几何体。  `dune-geometry`为这种映射提供了各种实现，例如，多线性或仿生映射的实现。这些不是`dune-grid`模块的一部分，因为有时需要它们的情况下，网格界面的其他部分就没有必要了。一个例子是在`dune-localfunctions`模块中实现的非仿生有限元（第八章）。

除了几何图形，`dune-geometry`模块还为不同的参考元素提供正交规则。这些都记录在第 $9$ 章中。

- `dune-localfunctions`提供了一个连接有限元集的接口，即有限元空间的基函数，以及相关的插值规则。该模块目前集中于可以在参考元素上以`shape functions`的形式表达的函数。  `dune-localfunctions`独立于`dune-grid`，只需要`dune-common`和`dune-geometry`即可工作。它还提供了一个不同的有限元集合，从简单的`Lagrangian`元素到高级的矢量值类型。`dune-localfunctions`模块将在第8章中解释。

- 最后，`dune-istl`（其中 "istl "是 "迭代求解器模板库 "的缩写）是一个线性代数库。它为各种类型的稠密和稀疏矩阵以及相应的矢量类型提供了实现。作为一个特殊的功能，这些类型可以以一种几乎任意的方式嵌套。这允许利用许多有限元问题中固有的阻塞和稀疏结构。  `dune-istl`还实现了几个基本的线性系统迭代求解器。这些都是在顺序和分布式机器上运行。特别值得一提的是代数多网格算法的实现，该算法可以扩展到非常大的处理器数量 [^31] [^100] 。该模块 `dune-istl` 将在第7章中解释。

本书还讨论了不属于官方DUNE核心的三个模块。

- dune-uggrid包含UG3有限元软件的网格数据结构的分叉 [^13] 。它提供了非结构化的、局部自适应的、多元素的二维和三维空间网格。在本书中使用它是因为`dune-grid`本身没有提供非结构化网格的实现。dune-uggrid模块在$5.10.1$章中有详细介绍。

- `dune-functions`模块提供了函数的接口。这包括定义在网格上的有限元函数，但也包括由闭式表达式定义的一般函数。  `dune-functions`还通过提供这种空间的基的接口来描述有限元函数的空间。一个强大的机制允许从较简单的空间轻松构建复杂的空间。`dune-functions`模块将在第10章介绍。

- 最后，`dune-pdelab`在这些函数空间基数的基础上提供了有限元集合器。它实现了第2.1.3章的一般全局元素循环，以及针对不同偏微分方程和不同类型边界条件的各种局部元素组合器。包括局部网格适应性的机制，所有这些都可以在分布式架构上运行。由于规模的原因，我们只能涵盖 `dune-pdelab` 的部分功能。我们将在第11章中进行介绍。

\subsection{Designing Efficient Interfaces}

可以说，DUNE最重要的方面是它为有限元和有限体积代码所使用的不同基础设施提供了一系列接口。这些接口必须足够通用，以涵盖（几乎）所有可能的使用情况。另一方面，它们应该是简单和简洁的：大型复杂的接口很难实现，也很难学习。它们必须易于记录，最后但同样重要的是，它们对运行时性能的影响应该是可以忽略不计的。C++语言为构建接口提供了几种不同的方法。它们在灵活性、易用性以及接口层所产生的运行时开销方面各不相同。在DUNE的不同部分使用了这些方法中的几种；有时是出于事实，有时是出于历史原因。为了让人们更好地理解为什么DUNE中的某些接口是以特定的方式设计的，本节讨论了三种构建接口的方式 $\mathrm{C}++$ 。

\subsubsection{Abstract Base Classes}

$\mathrm{C}++$ 中构建接口的经典方式是基于抽象基类 [^150] 。一个接口就是一个抽象基类，这个基类将所有需要的方法都声明为纯虚拟方法，比如说。

~~~C++
class AbstractInterface
{
public:
    virtual void doSomething() = 0;
};
~~~

编译器将不允许构造AbstractInterface类型的对象。只有派生类可以被构造，而且只有当它们重载了所有的纯虚函数时才可以。因此，接口的实现是源于接口类的类，并重载基类中的所有纯虚拟方法。

~~~C++
class InterfaceImplementationA
    : public AbstractInterface
{
public:
    virtual void doSomething();
};

void InterfaceImplementationA::doSomething()
{
    // do something
}
~~~


实现该接口的对象是通过指向基类的指针来引用的。由于编译器不允许构造具有纯虚拟方法的类对象，因此可以保证接口的所有方法都被实现。

基于抽象基类的接口有很多优点。它们相当容易理解和教授。编译器的支持是很好的，这特别意味着如果代码格式不正确，编译器会发出简短的、有帮助的错误信息。另外，与相应的模板技术相比，这种方法给编译器带来的压力要小很多。最后，接口规范被明确地编码在源代码中。类`AbstractInterface`就是接口。与`duck typing`（第4.4.2章）这样的技术相比，这是一个很大的优势，因为后者的接口只是隐式规定，必须单独记录。



不幸的是，抽象基类也有缺点，特别是对于像DUNE这样的高性能库。首先，它们不能被用于有成员模板参数的方法

~~~C++
template<class T>
virtual void foo(const T& t) = 0; // error
~~~



然而，这样的方法在各种DUNE接口中是需要的。

其次，虚拟函数调用会产生运行时开销。尽管这个开销非常小，但当被调用的方法非常短且调用非常频繁时，这个开销就会变得很明显。这一点最好的解释就是通过第二个接口的实现来扩展上面的例子。

~~~C++
class InterfaceImplementationB
    : public AbstractInterface
{
public:
    virtual void doSomething();
};
void InterfaceImplementationB::doSomething()
{
    // do something
}
~~~


接口方法通常通过基类调用。
~~~C++
void someMethod(AbstractInterface* object)
{
    object->doSomething();
}
~~~


在这种情况下，编译器无法决定`doSomething`方法的两个实现中的哪一个将被调用--必须由运行时系统来决定，这通常意味着至少有一个额外的指针访问。更糟糕的是，在编译时不知道被调用的方法会妨碍编译器的优化，比如内联。这两种影响加在一起，会导致可测量的速度下降 [^59] 。

为了改善这种情况，所有主要的编译器都实现了一种叫做 `devirtualization` 的优化技术。在某些情况下，编译器能够收集足够的信息，以便在编译时得出结论，哪个方法正在被虚拟函数调用。然后这个调用可以被一个直接的调用所取代，如果需要的话，还可以被内联。如果精确的调用目的地不是绝对确定的，但有很高的概率，`speculative devirtualization` 允许将该调用的价格降低到几乎是直接调用的价格 [^96] 。

由于潜在的运行时间成本，以及它与模板技术混杂在一起，教科书式的抽象基类在DUNE中很少使用。它们在某些场合被内部使用，但不用于任何主要的接口。

\subsubsection{Duck Typing}

在以前的方法中，一个接口是以明确给出的抽象基类的形式来声明的。声称要实现该接口的类必须通过从基类派生来明确说明这一点。然后，编译器会确保实现类确实实现了所有需要的方法。

这种方法是相当死板的。即使是实现了接口规范中所有方法的类，如果没有从正确的基类派生出来，也不会被接受为接口的实现。而且，在很多情况下，类应该实现不止一个接口。在 $\mathrm{C}++$ 中，从一个以上的基类派生是可能的，但这种方法也有其自身的缺陷，所以一般不提倡。

一种叫做`duck typing`的不同方法在没有任何接口类的情况下工作。在 `duck typing` 中，接口只是一个非正式的方法、类型和语义要求的列表，每个实现都必须满足。任何实现了所有要求的类都被接受为一个接口的实现，而不需要从特定的接口类派生 [^110] 。这种方法在C++标准库中被大量使用。例如，用于对容器中的元素进行排序的std方法被声明为

~~~C++
template<class RandomIt>
void sort(RandomIt first, RandomIt last)
~~~

任何类型的对象都可以作为参数传递，只要它们实现了 `RandomAccessiterator` 的方法。

与传统的动态多态性相比，`duck typing`的主要优点是灵活性大增。任何一个类都可以实现任意数量的接口，而不必担心复杂的继承层次结构。更重要的是，如果知道在特定情况下只有那部分接口是需要的，那么类就可以不实现接口的一部分。C++自省技术甚至允许调用代码测试接口的各个部分是否存在，并相应地调整其行为。

`duck typing`在$\mathrm{C}++$中的第二个优势是运行时效率。接口的实现通常是作为模板参数传递的。因此没有虚拟函数调用，也没有相应的性能损失。编译器可以应用其全部的优化技术。

`duck typing`在$\mathrm{C}++$中的缺点是，接口不能被编译器明确地执行。当实现没有满足调用代码的所有要求时，编译器确实会报告错误，但错误信息经常是隐晦的，比动态多态性的相应信息要差很多。这并不奇怪，因为接口规范只是隐含地给出，因此对编译器来说是未知的。它从未出现在代码的任何地方，而只是程序员之间的一种约定。如果需要一个正式的接口规范，那么它必须以单独的文本文件的形式来写。这样的文本很难创建和维护，因为没有技术机制来验证实现是否符合规范文件。

概念检查[^97][^151]已经被提出来作为一种允许正式接口验证的方式。它的某些方面已经包含在$\mathrm{C}++$语言的2020年修订版中，在撰写本文时，它们已经开始出现在主要的编译器中。在它们完全确立之前，DUNE提供了轻量级概念检查的手动实现，基于Niebler [^126] 提出的技术，并在RANGE-V3库中实现。例如，下面的方法评估检查其参数类型是否是一个将`double`映射到`double`的函数，即`operator ()`是否可以用`double`的参数为其调用并返回一个`double`。

~~~C++
template <class F>
void evaluate(F &&f)
{
    // Concept check that F has method ’double operator()(double)’
    static_assert(models<Functions::Concept::Function<double(double)>, F>(),
                  "Type does not model function concept");
    std::cout << "Value of f(1): " << f(1) << std::endl;
}
int main(int argc, char *argv[])
{
    evaluate([](double x)
             { return x * x; }); // Works
    //evaluate(42); // Error, ’42’ is not a function
}
~~~


如果`evaluate`被实例化的类型不是一个函数，那么会产生一个可读的错误信息。例如，对于代码

~~~C++
evaluate(42); // The integer 42 is not a function object
~~~

GCC-8.2打印出错误信息（删除了文件路径和行号）。

~~~Shell
In instantiation of ‘void evaluate(F&&) [with F = int]’:
required from here
error: static assertion failed: Type does not model function concept
static_assert(models<Functions::Concept::Function<double(double)>, F>(),
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~
error: expression cannot be used as a function
std::cout << "Value of f(1): " << f(1) << std::endl;
~~~

`dune-common` 模块提供了 `header dune/common/concept.hh` 中的一般概念检查设施。概念定义本身包含在各自的模块中。

在DUNE中，`duck typing`被用在很多地方，例如，`dune-istl`, `dunelocalfunctions`, 和`dune-functions`模块。在某些情况下，接口类确实存在，但它们没有功能上的目的，只是为了记录接口而存在。

\subsubsection{Wrappers and Engines}

DUNE核心模块中的几个地方，特别是DUNE网格界面，使用了第三种技术，被称为`wrapper-engine`方法。我们没有在文献中找到这种技术的描述，但它与例如`bridge`的模式有关 [^72] 。作为静态多态性的一种特殊形式，它具有纯模板`duck typing`的运行时效率，但使用了一个显式的接口类来执行和记录该接口。

在包装器-引擎的方法中，接口类不是继承树中的基类。相反，它是一个包装器，将实际的实现类（引擎）作为模板参数，并将所有调用转发给它。在下面的例子中，`Interface`是接口类，而`InterfaceImp`是一个实现。用户被阻止看到一个单独的`InterfaceImp`类型的对象，通常是通过使所有构造函数私有化。相反，她将总是与 `Interface<InterfaceImp>` 类型的对象打交道。

~~~C++
template <class Imp>
struct Interface
{
    void doSomething() const
    {
        imp_.doSomething();
    }

private:
    Imp &imp_;
};
struct InterfaceImp
{
    void doSomething() const
    {
        std::cout << "This is InterfaceImp doing something!" << std::endl;
    }
};
~~~

这种方法有几个优点。首先是封装性。用户只看到接口类 `Interface` ，有一套固定的方法和



输出的静态信息。其次，给定一个好的优化编译器，包装器-引擎接口的效率和 `duck typing` 一样高。不存在由于虚拟函数带来的开销。此外，由于所有的类型在编译时都是已知的，方法调用可以在适当的时候被内联。对模板成员函数的支持也不是问题。最后，存在着一个作为接口的类。这就自动提供了对接口的冗长描述，而不像在纯`duck typing`中，接口只是隐含的，需要在单独的文本文档中描述。特别是，这个文档在构造上是最新的，不会与实际的代码相背离。此外，接口是由编译器强制执行的。这使得在实现类没有实现正确的接口时更容易发现错误。

不幸的是，这种方法也有其问题。语言和编译器的支持并不像动态多态性那样好。如果`InterfaceImp`在对象声明时没有在动态多态设置中实现方法doSomething，编译器会报告错误，而在静态多态中，只有在实际使用该方法时才会出现错误。其次，调试变得更加困难。由于实现类的类型是接口类类型的一部分，编译器的错误信息变得更长，更难阅读。(不过也不是很困难，因为没有递归结构。)另外，由于额外的重定向，用调试器踏过程序会变得更加麻烦。

对于注重效率的DUNE电网接口（第5章）来说，已经决定包装器引擎概念的优势超过了成本。

\subsection{Coding Style}

不同的DUNE模块中的代码遵循某些风格规则。与其他一些项目的规则相比，这些规则没有那么彻底和正式，而且只有少数是自动执行的。这种规则的好处是，如果所有的模块都遵守一套共同的规则，那么使用和谈论DUNE代码就会变得更容易。这不仅关系到从事DUNE核心模块工作的人，而且也关系到大多数用户。在许多情况下，使用DUNE需要编写新的DUNE模块，这时遵循相同的风格规则是很方便的（即使不是必须的）。

在这一章中，我们重点讨论DUNE模块中$\mathrm{C}++$代码的风格规则。还有一些关于此类模块的文件命名和目录布局的规则。这些将在附录A.2.1中讨论。



\subsubsection{Rules Regarding the Code in a Dune Module}

一致的命名规则使库更容易使用。不幸的是，虽然DUNE确实有这样的规则，但它们并没有因此在整个代码库中得到遵守。这有历史原因，也很难改变，因为这些名字是公共接口的一部分，在很多用户代码中都有使用。

- 类和方法名称使用骆驼字母大小写 [^159] 。类型和类以大写字母开头，对象和方法名称以小写字母开头。例如，实现ALBERTA网格管理器[^141]的类被称为`AlbertaGrid`，而这个类的网格对象可以被称为`albertaGrid` 。这些规则有一些例外，以增加与标准模板库的互操作性。这些将在下面的章节中解释。

- 如果一个方法或类的名称包含一个首字母，那么这个首字母要么用大写字母，要么用小写字母（取决于上下文）来拼写。例如，在dune-ist 1中，块压缩行存储矩阵的类型是BCRSMatrix，返回这样一个矩阵的方法将被称为bcrsMatrix () 。

- 每个DUNE模块的代码都包含在Dune命名空间中（但不要忘记，在本书的所有代码例子中，`Dune::prefix`被省略了）。此外，每个模块的代码都包含在嵌套的名字空间中，有一个模块专用的名字。这通常是不含dune前缀的模块名称，以骆驼为例。例如，`dune-functions`模块的代码包含在`Dune::Functions`命名空间中，而`dune-pdelab`的代码包含在`Dune::PDELab`中。作为一个历史性的例外，核心模块`dune-common`、`dune-geometry`、`dune-grid`、`dune-istl`和`dune-localfunctions`中的代码被直接放在Dune命名空间中，而不是包含在进一步的模块特定命名空间中。

- 不允许从模块外使用的代码应该放在一个叫做`Impl`的命名空间中，嵌套在上述命名空间中。这样的代码允许在任何时候被改变。

- 私有类数据成员的名称以下划线结尾。

还有一些规则规定了缩进、大括号的使用等等。www.dune-project.org/dev/codingstyle 上有一个清单。

\subsubsection{Compatibility with the C++ Standard Library}

DUNE设计和实施的一个基本思想是，应该尽可能地遵循现有的标准。这种做法使新用户更容易熟悉DUNE，因为现有的标准可能已经知道了，如果没有，通常也有很好的文档可以学习。另外，已经建立的标准和标准实现通常都受到了专门的程序员团队的大量关注。因此，重新实现不太可能在所有方面都更好。一般来说，一个重新发明的轮子通常不如一个成熟的标准的轮子圆。

对于 $\mathrm{C}++$ 语言，既定的标准是 `C++ Standard Library` 。它提供了容器、算法和其他大量有用的小东西，并由 $\mathrm{C}++$ 标准化委员会与语言本身 [^98] 一起指定。它遵循一套完善的设计规则，并且有完善的文档。

DUNE中的许多概念是直接从标准库中获得的灵感。例如，网格作为一个可以被迭代的元素集合的概念与标准库中带有前向迭代器的容器密切相关。因此，在命名规则中也遵循标准库的惯例是有意义的。然而，由于历史原因，这并没有做到。例如，当标准库使用小写字母和下划线来命名方法（如`stl_method_name`）时，DUNE使用骆驼大写的风格（`duneMethodName`）。虽然这似乎是一个纯粹的美学问题，但在某些情况下确实变得很不方便。例如，`dune-common`中的几个类，如`ArrayList`、`ReservedVector`和`lru`，实现了容器类型。我们很自然地期望能够用标准库的算法来使用这样的容器，如 `std::fill` 或 `std::sort` 。然而，由于标准库使用 `duck typing` （第4.4.2章），这只有在DUNE容器类遵循标准库的命名规则时才能工作；例如，容器需要在 `value_type` 的名称下导出它们所包含的对象的类型。

因此，作为第$4.5.1$章规则的一个例外，有一些类遵循纯标准库的命名规则。例如，上面提到的`ArrayList`、`ReservedVector`和`lru`，但也有一些其他的。这样的类在各方面的表现都与标准库类相似，除了类名本身。特别是，像 `std::sort` , `std::find` , 和 `std::fill` 这样的标准库算法将在这些类上操作。

此外，相当多的类除了DuNE接口外，至少还提供了部分标准接口。例如，来自`dune-istl`的`BlockVector`类，基本上是一个浮点数（数组）的动态数组，将其迭代器的类型导出为iterator（标准库名称）和`Iterator`（DuNE的名称）。这同样适用于`FieldVector`类中的`dune-common`，它是一个固定大小的数字容器，广泛用于坐标等。相反，一些DUNE类是以需要实现标准库接口的类为参数的。例如，`dune-common`和`dune-istl`中的各种类采取`allocator`类型，需要实现标准库中的`allocator`[^150]概念。

虽然这种妥协可能没有在DUNE中完全使用标准库名称那么清晰和优雅，但它确实可以从现有的标准中获益，而不必完全重写DUNE的编程接口。

\subsection{Interface Stability and Backward Compatibility}

库的设计者和开发者总是面临着一个两难的境地。当他们为图书馆工作，思考它的设计，甚至可能自己使用它的时候，他们经常会想出一些改进和新功能。这并不奇怪：一方面，图书馆设计者和其他人一样是人，而且不断地学习新的东西。另一方面，对图书馆的要求会随着时间的推移而改变。如果该库为数值数学提供基础设施，那么新的需求可能会出现，因为有人开发了一种新的数值方法，而目前的设计无法正确支持这种方法。例如，`Intersection::centerUnitOuterNormal()`中的`dune-grid`方法就是因为人们对在有退化元素的网格上使用一阶有限体积方法感兴趣而引入的。另外，可能会出现一个新的硬件平台，如果不对库进行一些改变，可能就无法从中受益。例如，正在讨论允许更好地利用多核架构和矢量化单元的接口变化 [^19] 。

在最简单的情况下，接口的进化意味着增加新的方法，带来更多的功能。然而，这种变化也可能涉及到删除某些功能。这种情况可能会发生，因为已经有了提供同样功能的其他更好的方法。然后，为了使接口更小，旧的功能被删除。

这种变化将使许多用户感到高兴，因为他们从新功能和抛光的界面设计中受益。另一方面，用户重视稳定性。库的界面变化总是意味着用户的工作，因为使用库的代码需要更新。如果用旧版本的库编译的代码不能用新版本的库编译，这是个相当无害的问题。如果被依赖的程序继续构建，但开始以微妙的方式发生故障，情况就比较严重。

库的编写者以各种方式解决这个难题。有些人宣布所有现有的接口完全稳定，特别是意味着方法只能被添加，但不能被删除。这意味着在某一版本库中工作的用户代码将继续在所有未来版本中工作。在另一个极端，有些库的设计者可能根本不关心用户的苦恼，在任何时候都会增加和删除接口。

DUNE将自己定位在中间位置。一方面，DUNE的开发者认识到界面稳定性的价值，并努力不在没有充分理由的情况下改变界面。另一方面，它认为DUNE的用户相对较少（与glibc的用户相比），而且这些用户中的许多人都是相对精通技术的。因此，如果有必要改善整体设计，事情会以非落后的方式改变。

为了使这个过程对用户来说不是太痛苦，有一些承诺。





- 编程接口（API）在不同的维护版本之间不会改变（即，在版本$X . Y . n$中构建和运行的代码将继续在版本$X . Y .(n+1))$中构建和运行。ABI的稳定性没有保证；你将需要根据较新的版本重建你的代码。

- 在一个给定的功能版本$X . n$中编译和运行的代码将在下一个功能版本$X .(n+1)$中编译和运行，没有警告。对这一承诺，我们要抱有相当大的信心。见下面的讨论。

- 一个被计划删除的功能（无论是因为它真的被删除，还是因为它被重新命名）首先被标记为 "弃用"。废弃的功能必须至少出现在一个功能版本中，以便让用户注意到它。只有这样，这些功能才能在下一个版本（或以后的版本）中被真正删除。

    废弃标记的精确方式取决于该特性。方法、类和其他东西在配备了`[[deprecated("Custom text here")]]`属性后，可以使编译器发出一个废弃警告。文件可以通过将

    ~~~Shell
    #warning This file is deprecated. Use [...] instead!
    ~~~
在文件的某处。


虽然DUNE项目对第一条规则很严格，但在有些情况下需要对其他规则进行例外。例如，废止编译器属性在各种情况下都不能可靠地工作。那么使用一个已废弃的特性就不会触发警告，也不会通知用户该特性已被计划删除。另外，有时在技术上不可能同时以旧方式和新方式提供一个特性，例如，改变一个导出的常量

~~~C++
static const int foo = 42;
~~~

到一个方法

~~~C++
int foo() const {return 42;}
~~~

在同一类别中。因此，强烈建议DUNE的用户在升级到较新的版本之前，彻底阅读发行说明。

\section{Grids and the Dune Grid Interface}

`dune-grid`模块和它所包含的有限元网格的接口是DUNE软件系统的历史和概念核心。它是中心组件之一，显示了DUNE最好的设计思想。

本章将解释DUNE网格的抽象概念，并展示它们在实践中的应用。这将允许直接基于网格本身来编写汇编程序、误差估计器和I/O方法。后面的章节显示了一些预制的解决方案，但直接在网格接口层面上编程，可以得到最多控制和理解。

DUNE的创始思想是观察到不可能有一个适合所有需求的网格数据结构的实现。以UG3有限元软件系统中的网格管理器为例 [^13] 。这是一个极其强大和灵活的数据结构，可以处理不同元素类型的二维和三维网格，在单处理器和多处理器机器上具有完全的局部适应性。然而，这种能力有其代价。UG3网格需要相当多的内存，而且相对较慢。这对于有很多结构的问题来说是不方便的，例如，对于矩形域中的流动问题，可以使用均匀网格。在这种情况下，只需要很少的内存来存储网格本身，而网格管理器应该非常快，因为像元素体积和表面法线这样的信息可以被预先计算。当然，像UG3这样的非结构化网格数据结构也可以用于结构化网格，但是它的内存和运行时性能永远比不上专用的结构化网格实现。

继续这个思路，这个困境所包含的不仅仅是结构化和非结构化网格之间的区别。在这些之外，还有另一个巨大的范围的构造算作计算网格，其结构的数量各不相同。  [Fig2.3]中显示了二维网格，没有流形拓扑的网格，有曲线元素的网格，以及有自适应多分辨率（AMR）细化的结构网格 [^134] 。即使像UG3这样强大的网格管理器也不支持所有这些功能，因此，需要这些功能的应用经常需要手工编码的专用网格管理器。

DUNE建议通过提供不仅仅是一个而是整个网格数据结构的选择来解决这个难题。这些都实现了相同的接口，因此在给定的代码中很容易用一个交换另一个。这允许以前闻所未闻的灵活性，而不影响运行时间和内存效率。该机制在`dune-grid`模块中实现，其中心部分是网格实现的抽象接口，也就是访问所有这些不同网格实现的标准方式。该接口描述了网格必须提供的功能，如顶点和元素的迭代，网格元素与参考元素的映射，以及局部细化的方法。网格的用户（如有限元汇编代码）只需要知道这个接口。由于所有的网格实现都是相同的接口，因此它们可以在对客户代码进行最小改动的情况下进行交换。例如，这允许在结构化和非结构化网格之间轻松切换。它还允许更容易地访问更奇特的网格，这些网格可以被写成DUNE网格接口的实现，而不是作为特殊用途的实现硬连接到特定的仿真代码中。事实上，任何实现DUNE网格接口的网格管理器都非常容易（重新）使用，因为该接口对所有的DUNE网格都是一样的，并且有很好的文档。





很少有人试图把一般计算网格的概念正规化。值得注意的是 Berti [^24] 的工作，Benger [^22] 对非平面几何的概括，以及Botta 等人 [^36] 的非常抽象的基于关系的计算。在本书中，我们假设读者对网格有一个直观的概念，而抽象的网格定义的细节将被跳过。DUNE网格界面是基于[^16]中给出的正式定义，读者可以参考该定义，以便更深入地了解DUNE网格界面的设计思想。

来自[^16]的概念相当直接地映射到$\mathrm{C}++$模块中的一组`dune-grid`接口类。这些接口类和它们之间的一些相互关系在 [Fig5.1] 中显示。它们是使用第 $4.4.3$ 章的包装器引擎概念实现的，这似乎在效率、表现力和易用性之间提供了最佳平衡。因此，在[Fig5.1]中，每个接口类都有一个对应的实现类。这些实现类在编译器的错误信息中是可见的，但它们从不被用户直接处理。

本章最大的部分是解释界面。它侧重于单进程应用，而将并行网格所需的网格功能留给下一章。第$5.10$章介绍了包含在`dune-grid`模块中的网格接口的实现。其中一些是独立的实现，而另一些则依赖于外部有限元库。事实上，UG3 [^13]、ALBERTA [^141]和ALUGRID [^40] [^144]网格管理器的所有功能都可以通过DUNE网格接口获得。这是一个重要的功能，因为它允许使用强大的成熟代码，并以统一的简单方式来访问它们。

\subsection{Hierarchical Grids and Grid Views}

DUNE网格界面的出发点是第2.3.3章中介绍的分层网格的概念。虽然数值分析通常将网格视为给定领域的平面分区，但多网格方法和自适应网格细化的研究表明，将网格视为分层结构是有利的。这些网格是通过从一个平坦的网格（称为 "粗略的网格 "或 "宏观的网格"）开始，并对一些或所有的元素进行细化，可能会重复进行。不是让新的元素取代旧的元素，而是把它们放在 "上面"，从而形成一个层次化的树状结构，称为细化森林（一个树的集合；[Fig5.2]）。

分层网格在DUNE术语中被称为 "网格"。当 "网格 "一词出现在DUNE代码中时，它通常意味着 "分层网格"。`hierarchical grids`的类出现在[Fig5.1]的图的底部。仿真代码通常会在代码的某个地方构造一个这种类型的对象，并从它或它发出的对象中获取所有与网格有关的信息。网格构造在$5.7$章中讨论，如果需要的话，可以在进一步进行之前阅读。

分层网格对象的主要功能是提供对非分层网格的访问。毕竟，这些是数值离散化方法的操作对象。有两种典型的方法可以从细化森林中获得非层次网格。比较重要的一种是收集森林的所有叶子元素。这些构成了一个领域的网格，被称为叶子网格。它是自适应细化网格上非层次数值方法的典型选择。对于多网格方法，我们还需要访问非叶子元素。这些元素是按层次组织的，即所谓的`level grids` 。

在DUNE的语言中，叶子和水平网格是分层网格的视图。这种视图在DUNE的网格界面中由一个叫做`GridView`的类表示。分层的）网格实现类提供了上述两种类型的网格视图：水平视图和叶子视图。它们可以通过以下方法获得

~~~C++
LevelGridView levelGridView(int level) const
~~~

和

~~~C++
LeafGridView leafGridView() const
~~~

水平网格视图和叶子网格视图都实现了接口类 `GridView` 。接口方法列于[Tab5.1] 。这些方法提供了对网格元素的访问，元素邻接信息，以及控制分布在几个处理器上的网格的方法。






元素访问将在下面的$5.2$章讨论。这里显示的`GridView`分布式计算的方法列表只是为了完整性，它将在第六章才会讨论。

请注意，`levelGridView`和`leafGridView`方法通过值返回网格视图，并且返回值可以自由复制。这种复制在运行时间和内存消耗方面都是很便宜的。换句话说，`GridView`对象具有引用语义。它们不存储数据本身，而是提供对分层网格对象中实际数据的视图。这样做的坏处是，一般来说，一旦分层网格对象消失，`GridView`对象就不会包含任何有意义的东西。另外，由于`GridView`对象可能会缓存数据，所以不能保证在分层网格被修改后，它们仍然持有正确的信息。在这种情况下，必须再次调用`leafGridView`和`levelGridView`方法，以获得最新的`GridView`对象。

除了公共方法之外，`GridView`接口还包括一组静态输出的数字和类型。这些在[Tab5.2]中列出。每个`GridView`对象导出网格的尺寸和它所处空间的尺寸（`world space`或`physical space` ）。它还导出了该类所有方法的返回类型，还有一些。这样做的惯例源于$\mathrm{C}++11$标准之前的日子，它没有`auto`关键字和`decltype`这样的内省功能。虽然导出的类型在今天已经不那么重要了，但`dune-grid`仍然遵循这样的政策：一个接口类应该导出所有作为公共方法返回类型出现的类型。

\subsection{Iterating over `Vertices` and `Elements`}

网格视图的主要目的是提供对其网格元素和顶点的访问。在这种情况下，DUNE术语使用实体这个词来表示所有维度的网格顶点、边、元素等。因此，例如，一个0维的实体是一个网格顶点，一个1维的`entity`是一个边，等等。有两种访问实体的方式。在$\mathrm{C}++11$标准中引入的基于范围的for机制允许在所有元素和顶点上非常简洁地写出循环，这对许多情况来说是最有用的。如果需要灵活性，有一种方法可以使用迭代器访问所有元素。本节将主要讨论网格顶点和元素，一些DuNE网格也为边和面提供同样的迭代设施。

重要的是要认识到，对元素和顶点的访问是完全由`forward iteration`进行的。有一种机制可以发出一个网格视图的 "第一个 "元素，以及一种从一个实体到下一个实体的方法。没有其他的方式来访问一个元素或顶点；特别是，没有随机访问操作符允许通过顶点的编号来访问它。

其原因是许多现有的非结构化网格管理器在内部将顶点和元素、边等存储在不支持随机访问的数据结构中。例如，链接列表很常见，因为它们允许轻松插入和删除列表项[^43]，这是局部网格适应性所需要的。同时，几乎所有的有限元和有限体积计算的算法都只以线性方式访问顶点和元素。随机访问并不是真正需要的，因此对前向迭代访问的限制并不严重。在确实需要随机访问元素或顶点的罕见情况下，相关的网格数据必须事先被复制到一个数组中。

我们通过一些小例子来说明实体访问。给定一个名为`gridView`的变量中的网格视图对象，下面两行打印所有顶点坐标。

~~~C++
for (const auto& vertex : vertices(gridView))
    std::cout << vertex.geometry().corner(0) << std::endl;
~~~

第一行的表达式`vertices` ( `gridView` ) 创建了一个`linear range`，包含网格视图中的所有顶点。然后for循环对这个范围进行迭代。在每次迭代中，变量`vertex`是对当前顶点的一个常量引用。然后第二行打印顶点坐标。对于DUNE来说，所有的实体都是多面体，而顶点只是一个带有一个角的多面体。表达式`vertex.geometry()`访问实体的形状，corner(0)返回其唯一的，也就是第0个角的位置。当对 [Fig5.3] 中的例子网格运行时，程序将打印出


~~~Shell
0 0
1 0
2 0
0 0.5
0 1
1 1
2 1
~~~


这是该网格七个顶点的坐标列表。

遍历网格视图中的所有元素也是如此。下面的例子打印了一个网格视图中所有元素的类型。

~~~C++
for (const auto& element : elements(gridView))
    std::cout << element.type() << std::endl;
~~~

对于同一个网格，由此产生的输出是

~~~C++
(simplex, 2)
(simplex, 2)
(simplex, 2)
(cube, 2)
~~~


它是一个包含在网格中的所有元素的参考元素类型的列表。输出中的数字2指的是所有被循环的实体都有二维的参考元素。关于$5.5.2$方法实际返回的内容，详见第`type`章。

如前所述，对顶点和元素以外的网格实体进行迭代是可选的，并不是所有的DunE网格都能实现。如果实现了，边和面的范围可以分别通过`edges (gridView)`和`facets(gridView)`获得。如果没有实现相应的迭代，这些范围的行为是未定义的。

很多时候，按照上面描述的方法访问顶点和元素正是我们所需要的，但有时也需要一点额外的灵活性。使用一个参数在顶点和元素之间进行切换是很容易的；事实上，行

~~~C++
for (const auto& entity : entities(gridView,Dim<0>()))
{
// Do something with ’entity’
}
~~~


在所有的网格顶点上循环，（也就是0维的对象）。相应地，如果`gridView`中的网格是二维的，那么

~~~C++
for (const auto& entity : entities(gridView,Dim<dim>()))
{
// Do something with ’entity’
}
~~~


在这些元素上循环。在三维网格中，`Dim<1>( )`和` Dim<2>()`可能有效，取决于实际的网格实现。

为了对称性，还有一种方法可以通过它们相对于网格的二维度来访问顶点、元素等。一个实体的尺度是实体的尺度减去网格的尺度。特别是我们有这样的关系

~~~C++
codim(vertex) = grid dimension − vertex dimension = grid dimension
codim(facet) = grid dimension − facet dimension = 1
codim(element) = grid dimension − element dimension = 0.
~~~

因此

~~~C++
for (const auto& vertex : entities(gridView,Codim<dim>()))
{
// Do something with ’vertex’
}
~~~

在一个二维网格中的顶点上循环，并且

~~~C++
for (const auto& element : entities(gridView,Codim<0>()))
{
// Do something with ’element’
}
~~~



在元素上循环。在DUNE网格界面中，广泛使用了通过二维码对顶点和元素进行索引的方法，但是在技术上并没有理由倾向于使用二维码而不是维度。





在大多数情况下，使用范围对元素进行迭代是非常有效的。对于更多的控制，也可以使用迭代器访问顶点和元素。本节的其余部分在第一次阅读时可以跳过。

迭代器是指向其他对象的对象。它们在C++标准库[^103] [^150]中被大量使用，DUNE的网格界面尽量遵循该库。迭代器是通过`GridView`类的方法获得的，并且可以被取消引用以获得它们所指向的对象。此外，迭代器可以被递增，使其指向下一个对象。事实上，DUNE网格界面中的迭代器是`forward iterators`，也就是说，它们只能用于以线性方式访问网格视图的顶点，从第一个顶点开始，而不会向后移动。DUNE网格接口中的迭代器的行为与C++标准库中的`forward iterators`完全一样。

我们重新审视上面使用的例子，并使用迭代器重写它们。就像在标准模板库中所做的那样，网格视图对象提供了一个指向第一个顶点的迭代器，以及一个指向最后一个顶点的假想顶点，作为循环的结束标记。

~~~C++
auto it = gridView.begin<dim>();
auto endIt = gridView.end<dim>();
~~~


数字`dim`是要迭代的实体的co(!)维。在这个例子中，假设dim是网格的尺寸。因此，调用方法`gridView. begin<dim>()`会产生一个到第一个`vertex`的迭代器。在所有顶点上的循环就像这样简单

~~~C++
for (; it!=endIt; ++it)
{
// Do something with the vertex that ’it’ points to
}
~~~


特别是，这里又是一个例子，在控制台打印所有顶点坐标的列表。

~~~C++
auto it = gridView.begin<dim>();
auto endIt = gridView.end<dim>();
for (; it!=endIt; ++it)
    std::cout << it->geometry().corner(0) << std::endl;
~~~



请注意，与使用基于范围的for的循环不同，循环变量不是顶点本身，而是一个指向顶点的迭代器。为了得到实际的顶点，可以通过写 `it->` 来取消迭代器的引用。对于[Fig5.3]中所示的例子网格，程序输出同样是

~~~Shell
0 0
1 0
2 0
0 0.5
0 1
1 1
2 1
~~~


类似地，下面的例子打印了网格视图中所有元素的元素类型

~~~C++
auto it = gridView.begin<0>();
auto endIt = gridView.end<0>();
for (; it!=endIt; ++it) {
    std::cout << it->type() << std::endl;
~~~


前两行要求的是代码维度为0的实体的迭代器，也就是网格元素的迭代器。对于[Fig5.3]的网格，这将再次打印出

~~~C++
(simplex, 2)
(simplex, 2)
(simplex, 2)
(cube, 2)
~~~


注意在这些例子中，`auto`关键字允许编写迭代器循环而不需要明确说明迭代器的类型。这是很有帮助的，因为准确的类型规范可能会很麻烦。迭代器的类型被网格视图导出为

~~~C++
GridView::Codim<codim>::Iterator
~~~


参数`codim`是一个编译时的整数，它指定了要迭代的对象的类型（顶点、元素、边等），它通过给对象`codimension`相对于网格的方式来实现。因此，一个网格视图中所有元素的迭代器的类型是

~~~C++
GridView::Codim<0>::Iterator
~~~

而顶点迭代器的类型是

~~~C++
GridView::Codim<dim>::Iterator
~~~

两者都取决于网格视图，因为对叶子网格视图的迭代与对水平网格视图的迭代会有所不同。间接地，迭代器类型也将依赖于网格实现本身。这种依赖性是静态多态性的一个方面，它允许在内部确保迭代器的实现是针对网格实现的最佳调整，而没有不必要的运行时检查。

\subsection{Entities and Geometries}

解释DUNE网格实体的功能需要多说一点关于DUNE网格界面的设计思想。在DUNE中，一个（非层次的）网格的组成部分，如元素、顶点和边，在概念上被分成两部分。第一部分，被称为`entity`，是一个纯粹的拓扑学对象。零维的实体，即对应于网格顶点的实体，被看作是一个抽象的有限集合的元素，没有任何类似于位置的东西。高维的实体由低维的实体集合组成。例如，一个元素实体由其顶点实体和边缘实体组成，从中可以推断出其邻近的元素实体，或者与某一顶点相邻的所有边缘或元素。这种对邻接信息的集中，使实体成为一个纯粹的拓扑对象。一个由一个三角形和两个四边形组成的网格的集合系统的例子显示在[Fig5.4]的左边。

每个元素、顶点、边缘等的第二部分是几何信息。在代数拓扑学中，这被称为几何实现，而在DUNE中，它被简单地称为`geometry` 。它通过将实体嵌入到一个流形中来指定实体的形状。这个流形，在绝大多数情况下是一个低维的`Euclidean`空间，被称为世界空间。一个实体的几何实现是一个从参考元素到世界空间的$C^{1}$-异构。这种异构正是第2.1.3章有限元装配算法的描述中出现的地图$F: T_{\text {ref }} \rightarrow T$。一个实体的形状作为一个点集的直观想法是作为$F$的图像得到的，但此外这个形状还配备了一个参数化或坐标系。这种构造也显示在 [Fig5.4] 中。



将网格元素分成拓扑和几何两部分的想法并不新鲜，在Berti [^24] 和Benger [^22] 的作品中已经被推动到相当复杂的程度。数学根源可以在组合和代数拓扑学中找到，它引入了`complex`的概念，其中有不同复杂度的不同风格 [^90] 。纯粹的抽象简约复合体正好对应于符合简约网格的拓扑信息，而（非抽象的）纯粹简约复合体，即具有几何实现的抽象简约复合体则对应于网格本身。多面体复合体允许元素是任何凸多面体，但禁止弯曲的元素边界。广泛使用的CW-复合体允许弯曲的边界，但作为有限元网格的模型过于笼统 [^90] 。与用于有限元和有限体积计算的网格最相近的概念似乎是 `regular cell complexes with the intersection property` [^27] 。它们确实允许具有弯曲边界的多面体元素，但排除了很多病态的情况。

所有这些来自拓扑学的概念的一个严重缺点是，它们都没有令人满意地处理不符合要求的网格和悬空节点的想法，如 [Fig5.4] 或 [Fig5.8] 中的想法。这是 [^16] 中工作的动机，它在这个方向上修改了复合体的概念。这个一般定义构成了DUNE网格界面的基础。

\subsubsection{Entities}

DUNE的网格接口明确地包含了拓扑和几何的区别。每个元素、顶点、边缘等的拓扑部分由一个叫做`Entity`的接口类给出，而几何部分则由一个单独的接口类Geometry给出。本节讨论`Entity`接口类，而Geometry接口类将在$5.3.2$章中考虑。

`Entity`接口类有两种风格。虽然所有的实体都有一些共同的功能，但有一个专门针对零维度的实体（即网格元素）的接口，它有额外的功能。我们依次讨论这两个接口，并从对所有维度都可用的接口开始。为此，[Tab5.3]和[Tab5.4]分别列出了公共方法和类型。尽管这些表格中没有提到，但所有 `Entity` 对象都可以默认和复制构建，并从其他此类对象中分配。

第一个接口方法被称为

~~~C++
int level() const
~~~

它简单地返回实体在网格层次结构中的级别。级别是一个自然数，0表示该实体是最粗的网格的一部分。下一个方法

~~~C++
GeometryType type() const
~~~

返回一个标记对象，表示与实体相对应的参考元素。标记是一个类型为 `GeometryType` 的对象，在第 $5.5.2$ 章中有详细介绍。

实际的几何实现，或`geometry`，可通过以下方法获得

~~~C++
Geometry geometry() const
~~~

它的返回值是一个接口类Geometry的对象，实现了从参考元素到世界空间的映射$F$，并因此实现了实体的所有几何方面。它是一个复杂的类，具有相当多的功能，在第 $5.3.2$ 章中讨论。该方法

~~~C++
unsigned int subEntities(unsigned int codim) const
~~~

返回指定维度的实体的所有子实体的数量。如果`entity`是一个代表四边形的实体，代码为

~~~C++
std::cout << entity.subEntities(2)
          << " " << entity.subEntities(1)
          << " " << entity.subEntities(0) << std::endl;
~~~



将打印 "4 4 0"，即一个四边形的顶点、边和元素的数量。最后，该方法

~~~C++
PartitionType partitionType() const
~~~

只有在分布式机器上使用DUNE时才需要，这将在第6章中解释。



像DUNE网格接口的其他几个部分一样，`Entity`对象允许通过方法访问`Entity`接口类背后的实际实现类。

~~~C++
Implementation& impl()
~~~



(该方法的`const`版本也是可用的。) 该方法允许绕过网格接口抽象层，并控制特定网格实现的特殊功能。不过这也不是没有危险的。使用植入方法的代码只能在一个网格实现中运行，当从一个DUNE版本更新到另一个版本时，它可能会中断。只有在真正必要的情况下才可以使用它。

通用`Entity`接口的最后一个方法被称为

~~~C++
EntitySeed seed() const
~~~


它返回一个所谓的 `entity seed` 。实体种子是一种轻量级的实体存储机制。它存在的理由很微妙：有些应用需要在网格之外存储实体。原则上，`Entity`对象可以直接存储在容器中（它们有常规的构造器和分配/移动操作符）。例如，下面的代码片段将一个给定的网格视图的每个边界元素存储在一个叫做`std::vector`的`boundaryElements`中，然后打印出它们的参考元素类型。

~~~C++
std::vector<GridView::Codim<0>::Entity> boundaryElements;
for (const auto& element : elements(gridView))
    if (element.hasBoundaryIntersections())
        boundaryElements.push_back(element);

for (const auto& boundaryElement : boundaryElements)
    std::cout << boundaryElement.type() << std::endl;
~~~




这段代码做了它应该做的事情；然而，可能有一个问题：根据网格的实现，一个`Entity`对象可能会使用相当多的内存。因此，存储大量的`Entity`对象可能是个问题，这就是`EntitySeed`类发挥作用的地方。`EntitySeed`类型的对象可以以非常低的内存占用率来存储，因为它们除了在与相应的网格结合时获得`Entity`的回馈外，不能真正用于任何事情。下面的示例代码与前面的代码相同，但它使用`EntitySeed`对象来存储实体。


~~~C++
std::vector<Grid::Codim<0>::EntitySeed> boundaryElements;
for (const auto& element : elements(gridView))
    if (element.hasBoundaryIntersections())
        boundaryElements.push_back(element.seed());

for (const auto& boundaryElement : boundaryElements)
    std::cout << grid.entity(boundaryElement).type() << std::endl;
~~~


根据网格的实现，这可以节省大量的内存。


除了这些方法，`Entity`的接口还包括几条静态信息（[Tab5.4]）。特别是，该类导出了其所有方法的精确返回类型，以及三个整数：`mydimension`中的自身维度，codimension中的相对于网格的维度，以及dimension中的网格本身的维度。这些整数的命名有点不幸；它有历史原因，不太可能改变。


`Entity`类对网格元素（维度为0）的专门化包含了一些额外的方法。这些都列在[Tab5.5] 中。0维实体的更强大的接口反映了DUNE网格接口的一个重要设计原则。  `Elements` 是主要的对象，对其他维度实体的大部分访问应该通过元素发生。例如，即使许多网格实现允许直接遍历所有的网格边缘，但这并不是必需的。相反，标准的方法是通过迭代元素，并为每个元素迭代边缘。这反映了这样一个事实：有限元和有限体积代码中的主要集合循环几乎总是基于元素的（见第2.1.3节），而且即使是包含面贡献的算子（例如，对于DG方法；见第11.2.6章）通常也有一个简单的元素重构。对元素的关注也可以在网格界面的其他地方看到。


codimension-0`Entity`接口的第一个附加方法是将元素的子实体如边和顶点交出。


~~~C++
template<int codim>
Codim<codim>::Entity subEntity(int i) const
~~~


要求的二维码是一个模板参数，因为它影响了返回类型。另一方面，要求的子实体的数量是一个运行时参数。编号遵循第 $5.5$ 章中描述的惯例。例如，为了得到前面例子中四边形实体的2号边，写道

~~~C++
auto edge = entity.subEntity<1>(2); // ’1’ is the codimension of edges
                                    // in two-dimensional grids
~~~


这将返回一个正确尺寸的`Entity`类型的对象。一个给定维度的子实体的数量由`subEntities`方法计算，该方法适用于所有维度的实体，而不仅仅是网格元素（见上文）。

`Entity<0>`的进一步方法可以归为两组。第一组的方法将一个元素与它在网格细化层次结构中的上层和下层元素连接起来。对较粗的元素的访问与对较细的元素的访问不同，因为元素只有一个父元素（最多），但它们可以有任意数量的子元素（[Fig5.5] ）。对父元素的访问是由以下方法提供的

~~~C++
Entity<0> father() const
~~~


如果该实体没有父亲，那么该方法的行为就无法定义。这可能发生在两个原因上。要么该元素已经是最粗的网格层的一部分。或者，如果网格分布在几个进程中（第6章），那么父元素可能只存在于不同的进程中（在这种情况下，父方法找不到它）。有一个额外的方法

~~~C++
bool hasFather() const
~~~

它返回父元素在本地进程中是否存在，并可用于测试调用 `father` 是否安全。

访问子元素的工作方式不同。由于通常有不止一个孩子，所以有一个特殊的迭代器来迭代孩子。事实上，这个迭代器被称为`hierarchic iterator`，不仅迭代子元素，而且（如果要求的话）还迭代超过一代的子元素。迭代器是通过调用以下方法获得的

~~~C++
HierarchicIterator hbegin(int maxLevel) const
~~~

由此产生的前向迭代器将遍历调用`hbegin`的实体的所有后裔，直到并包括那些处于maxLevel级别的实体。获得一个循环结束的迭代器的相应方法是

~~~C++
HierarchicIterator hend(int maxLevel) const
~~~

迭代器的类型与实现有关，并由接口类导出。因此，举例来说，要在一个名为`element`的元素的所有直系子上循环，请写道

~~~C++
auto it = element.hbegin(element.level()+1);
auto endIt = element.hend(element.level()+1);
for (; it != endIt; ++it)
{
    // Do something with the son available through it->
}
~~~



由于这种语法在现代$\mathrm{C}++$中是不必要的冗长，所以也可以使用`range-based-for`的语法。


~~~C++
for (const auto& son : descendantElements(element,element.level()+1))
{
// Do something with the son available in ’son’
}
~~~

要确定一个元素是否是叶子元素，与确定一个元素是否有父亲一样困难。在单个进程上，当且仅当`hbegin`和`hend`返回同一个迭代器时，一个元素是叶子。然而，如果网格分布在多个进程中，则可能在不同的进程中存在着子元素。因此，方法

~~~C++
bool isLeaf() const
~~~


提供，当且仅当元素是全局细化层次的叶子实体时，返回`true`。

上面解释的方法可以确定元素之间的父子关系，但其纯粹的拓扑性质通常是不够的。为了能够实现不同网格层之间的数值数据传输，例如，对于几何多网格方法，有必要获得关于儿子如何在几何上划分`father element`的信息。这种信息在网格界面中以第二种几何实现的形式表示。这第二个实现可以通过调用方法

~~~C++
LocalGeometry geometryInFather() const
~~~

与`geometry`方法一样，`geometryInFather`方法提供关于元素的几何形状的信息。然而，与前者不同的是，`geometryInFather`方法返回元素的嵌入到它自己的`father element`。也就是说，`geometryInFather`返回的对象实现了从该元素的参考元素到其父的参考元素的映射。这在 [Fig5.6] 中得到了说明。该方法返回的对象实现了下一节解释的完整的`Geometry`接口，但它不一定与几何方法返回的对象属于同一类型（见下文）。

为了说明`geometryInFather`方法是如何用来实现从较粗的网格层次到较细的网格层次的数据插值，我们举出以下例子。假设元素是网格级1上的一个`Entity`，维数为0。假设在0级网格上有一个标量函数$f$，它可以通过调用以下函数来评估

~~~C++
auto value = f(level0Element, localCoordsInLevel0Element);
~~~

在元素上，我们假设有一组`Lagrange`点（元素的局部坐标），在`std::vector< FieldVector <double, dim> > lp`中，我们想在这些`Lagrange`点上插值$f$。挑战在于`Lagrange`点是相对于1级网格元素定义的，而函数$f$需要根据父亲上的坐标来评估。`geometryInFather`方法提供了必要的坐标转换。

~~~C++
for (size_t i=0; i<lp.size(); i++)
    values[i] = f(element.father(),
            element.geometryInFather().global(lp[i]));
~~~



而$\operatorname{lp}[\mathrm{i}]$是$i^{th}$`Lagrange`点在一级元素坐标中的位置，表达式`element.geometryInFather().global(lp [i])`是父元素的坐标位置。`geometryInFather`方法产生一个从元素到父元素的映射，`global`方法评估这个映射。注意

~~~C++
    element.geometry().global(x);
~~~

不一定是同一点，因为

~~~C++
    element.father().geometry().global(element.geometryInFather().global(x));
~~~


因为较细的网格可能覆盖一个与粗网格略有不同的领域；由于边界参数化的存在（[Fig5.6]）。

codimension-0 `Entity` 接口也提供了网格细化所需的功能。正如第$2.3$章所解释的，网格细化通常是以一系列的步骤进行的：首先，（叶子）网格元素的一个子集被标记为细化或粗化，只有在所有这些标记被设置后，后续步骤才会执行实际的网格修改。附在网格实体上的数字数据可能需要在这个步骤序列中传输。


为细化标记元素不是通过实体上的方法完成的，而是在网格本身上。然而，`Entity`类提供了一些在网格细化过程中需要的数据处理的辅助方法。尤其是

~~~C++
bool mightVanish() const
~~~

方法告诉我们，考虑到当前的细化标记状态，在下一轮网格修改中（通过调用分层网格的适应方法触发），该实体是否会消失。知道这个元素可能会消失，就可以保存附着在它身上的所有数据。

如果 `mightVanish` 返回 `false` ，那么该元素被保证留下，但如果它返回 true ，该元素可能留下或消失。这种不对称性的原因是，要确定一个元素是否会消失是相当困难的。因此，从某种意义上说，`mightVanish`只是一个提示；我们不妨忽略它，总是保存所有的数据，但这将是一种浪费。

反之，该方法

~~~C++
bool isNew() const
~~~

在对`adapt`的调用触发了一组网格修改后，将被调用。它返回一个给定的实体是否在上一个适应性周期中被新创建。如果是，这个元素的数据需要通过从更粗的实体的数据中插值来构建。关于DUNE中局部适应性的详细介绍以及如何使用`mightVanish`和`isNew`方法的例子，在第$5.9$章给出。

\subsubsection{Geometries}

实体的几何实现是由接口类实现的

~~~C++
class Geometry
~~~

与`Entity`类不同，它对所有二维的对象都有相同的接口。几何学是决定一个元素、边缘等在物理空间中的 "形状"，以及嵌入到其他元素中时的形状。

概念上，`Geometry`类实现了一个从参考元素$T_{\text {ref }}$到`Euclidean`空间的映射$F$。这个映射的图像被定义为元素$T$的形状。因此，我们也可以说，一个`Geometry`将参考元素$T_{\text {ref }}$映射到元素$T$。通过这样做，$F$在$T$上诱导出一个坐标系，这个坐标系被称为$T$的局部坐标系（[Fig5.7]）。假设$F$在$T_{\text {ref }}$上是连续可微的，有连续可微的逆。这个条件对于有限元和有限体积方法中所关注的绝大多数几何形状都是成立的，包括所有阶数的等参数和等几何元素。






一个几何体的目标空间并不总是网格的世界空间。事实上，这两者甚至可能有不同的维度。当一个`Geometry`对象不是用来嵌入一个实体到网格世界空间，而是嵌入另一个实体时，就会发生这种情况。例如，方法`Entity::geometryInFather`返回一个几何对象，将一个元素嵌入到它在网格细化层次中的父亲。因此，该几何体的目标空间是父元素的参考元素。如果网格由嵌入到$\mathbb{R}^{3}$的三角形表面组成，那么网格世界空间将是三维的，但`geometryInFather`返回的几何体的目标空间将只是二维的。在DUNE中，嵌入其他实体的几何体有时被称为`LocalGeometry`对象，但它们与映射到网格世界空间的实现是由同一个接口类来表示的。

`Geometry`类的界面反映了有限元和有限体积方法的要求。第$2.1.3$章中关于如何组装刚度矩阵的很多概念都出现在`Geometry`接口中。该类的所有公共方法的列表可以在[Tab5.6]中找到。

第$2.1.3$章的讨论确定，标准的有限元方法需要评估$F$、其一阶导数和积分转换公式所需的`Jacobian`系数$\sqrt{\operatorname{det}\left(\nabla F^{T} \nabla F\right)}$。因此，接口的最大部分由允许评估这些数量的方法组成。该方法

~~~C++
GlobalCoordinate global(const LocalCoordinate& xi) const
~~~

在参考元素$T_{\text {ref }}$中的一个给定点$F$进行评估。给定参考元素中的一个坐标矢量（在 "本地坐标 "中），它返回世界空间中的相应点（"全局坐标"）。如果为$T_{\text {ref }}$以外的点调用global，那么它的行为就无法定义。类型`LocalCoordinate`和`GlobalCoordinate`分别是大小为$\operatorname{dim} T_{\text {ref }}$的数组和世界空间的尺寸。与所有其他方法的返回类型一起，它们由`Geometry`接口类导出（见[Tab5.7]) 。





通常，`LocalCoordinate`和`GlobalCoordinate`数组是`FieldVector`类的实例（来自文件`dune/common/fvector.hh`），它实现了一个具有向量空间操作的静态大小的数组类。请注意，这两个数组的长度可能不一样。

虽然方法`global`允许评估地图$F: T_{\text {ref }} \rightarrow T$，但方法

~~~C++
LocalCoordinate local(const GlobalCoordinate& x) const
~~~

评估反 $F^{-1}: T \rightarrow T_{\text {ref }}$ 。这个方法的单一参数是一个 `GlobalCoordinate` ，它返回一个 `LocalCoordinate` 对象，其坐标在参考元素中。同样，如果输入的坐标实际上不包含在$T$中，其行为是未定义的。如果`local`是高度非线性的，或者$T$在世界空间中具有正的二维度，那么评估`local`可能会很困难，代价很高。在后一种情况下，鉴于只有有限精度的算术可用，输入点不太可能正好在$T$上。因此，`local`的实现被期望做一些合理的事情，即使被调用的点在$T$附近，但不完全在$T$上。

原则上，元素的角可以通过使用参考元素的角作为`global`方法的输入来获得。作为一个方便的捷径，有这样的方法

~~~C++
GlobalCoordinate corner(int i) const
~~~

其中接受一个整数参数i并返回$i^{th}$实体角在`GlobalCoordinate`中的位置。角的数量可以通过以下方法获得

~~~C++
int corners() const
~~~

作为一个例子，下面的代码片断计算了元素角的质量中心

~~~C++
GlobalCoordinate centerOfMass(0); // Initialize with zeros
for (int i=0; i<geometry.corners(); i++)
    centerOfMass += geometry.corner(i);
centerOfMass /= geometry.corners();
~~~


请注意，`Geometry`类提供了所有维度的几何实现的接口。这包括零维实体（即顶点）的极端情况，其参考元素是$\mathbb{R}^{0}$ ，我们将其解释为一个点。在这种情况下，`LocalCoordinate`是一个大小为零的数组，实际上`LocalCoordinate`类型的参数消失了。因此，为了获得存储在类型为`Geometry`的顶点对象中的顶点的位置，我们可以写道

~~~C++
Geometry::LocalCoordinates dummy; // Array of size zero
Geometry::GlobalCoordinate p = vertex.global(dummy);
~~~

或

~~~C++
Geometry::GlobalCoordinate p = vertex.corner(0); // Zero-th (only) corner
                                                 // of a zero-dimensional
                                                 // polytope
~~~

后者已经出现在第 $5.2$ 章。

有几种方法以各种形式提供$F$的导数。该方法

~~~C++
ctype integrationElement(const LocalCoordinate& xi) const
~~~

返回参数xi所给的点的雅各布行列式$\sqrt{\operatorname{det} \nabla F^{T} \nabla F}$。该方法

~~~C++
JacobianInverseTransposed
    jacobianInverseTransposed(const LocalCoordinate& xi) const
~~~

在同一点上返回矩阵$\nabla F^{-T}$。这两个量都出现在第2.1.3章中`element stiffness matrices`的表达式中。第3,6章和其他章节中的示例程序显示了这些方法的背景。

方法`jacobianInverseTransposed`返回的对象具有矩阵的语义，但精确的类型取决于网格的实现。在许多情况下，该类型是`FieldMatrix`（静态大小的密集矩阵，在`dune/common/fmatrix.hh`中实现），但这并不是强制性的。例如，`YaspGrid`的实现（第5.10.2章）实现了一个轴对齐的结构化立方体网格，因此，先验地知道$\nabla F^{-T}$总是一个`diagonal`矩阵。因此，`jacobianInverseTransposed`方法返回`DiagonalMatrix`类型的对象（来自`dune/common/diagonalmatrix.hh`），它只存储`diagonal`矩阵条目。因此，用`DiagonalMatrix`的乘法要比普通的矩阵乘法快得多。

对于对称性，也有一种方法

~~~C++
JacobianTransposed jacobianTransposed(const LocalCoordinate &xi) const
~~~

它返回矩阵 $\nabla F^{T}$ 。它的使用频率远远低于它的逆向类似物。一个重要的用途是在表面网格上进行模拟，$(\nabla F(\xi))^{T}$的行横跨$F(\xi)$处的网格切线空间。

接口的其余部分由各种辅助方法组成。例如，调用

~~~C++
bool affine() const
~~~

告知几何实现$F: \mathbb{R}^{d} \rightarrow \mathbb{R}^{w}$的形式是否为

$$
F(\xi)=B \xi+c \quad B \in \mathbb{R}^{w \times d}, c \in \mathbb{R}^{w}
$$

如果是这种情况（包括所有单线和均匀网格），方法`integrationElement`、`jacobianTransposed`和`jacobianInverseTransposed`的结果与它们的参数无关，只需要对每个元素计算一次。在使用高阶积分方法时，这可以节省大量的时间。

该方法

~~~C++
GeometryType type() const
~~~


返回一个标识参考元素的标记，也就是 $F$ 的定义域。它可以用来获取关于参考元素本身的更多信息（第$5.5$章），或者用来请求有限元`shape functions`（第8章）或正交规则（第9.2章）。

还有两种方法可以帮助实现有限体积方法。这种方法经常涉及到每个元素上的函数是常数。一个元素上的积分可以通过将元素体积乘以一个固定点的函数值来计算。为了便于实现，`Geometry`接口类提供了两个方法

~~~C++
Volume volume() const
~~~

和

~~~C++
GlobalCoordinate center() const
~~~

返回元素的体积和边界中心。它们适用于所有维度的对象；按照惯例，顶点的体积是 $1$ 。关于如何使用这些方法的例子，见第$3.4$章中的有限体积例子。

作为最后一个方法，Geometry接口类提供了

~~~C++
Implementation& impl()
~~~

(和相应的`const`方法），它允许访问底层的实现类。这个方法非常强大，但它也需要很多知识。只有在有充分理由的情况下才能使用它。

\subsection{Intersections Between `Elements`}

`Geometry`类允许计算元素上的积分，这也是符合要求的有限元方法所需要的核心部分。然而，对于有限体积方法，以及一些有限元方法，如DG方法，需要对两个相邻元素之间的界面进行积分。这种积分通常是将两个元素的`shape functions`与界面的法线相结合。同样，`Neumann`边界条件涉及域边界的积分。DUNE网格通过`Intersection`接口提供相关信息。



\subsubsection{Intersections}

如果网格是符合要求的，提供相邻元素的信息是相当直接的。记住，如果任何两个元素的交点是它们的共同子面，或者是空的，那么这个网格就叫做`conforming`（[Fig5.8] ，左边）。在许多情况下需要这样的网格；例如，对于`Lagrangian`有限元方法。然而，DG方法（第11.2.6章）和有限体积方法在不符合要求的网格上也能正常工作，使用这种额外的灵活性是很方便的。不符合要求的网格经常出现在没有闭合的自适应红色细化中（[Fig5.8] ，中间），但更普遍的情况也同样可能（[Fig5.8] 右）。

DUNE以最大的灵活性为目标，不对网格的一致性做任何假设。两个相邻的元素之间的交叉点并不限制为一个共同的面。相反，它可以是元素边界的一个几乎任意的子集。特别是，它不一定要通过细化一个面来产生（如图$5.8$，中心）。







DUNE通过交点的概念来处理这种一般情况。在数学上，DUNE意义上的交点是两个元素的封闭的集合论交点，并且必须有正的$d-1$维度。例如，考虑[Fig5.9]，它显示了[Fig5.8]的一般不合格网格，以及一个四边形元素$T$与其直接邻域的特写。元素$T$以不符合要求的方式与它的邻域相遇。与相邻元素的（集合论）交叉点被标记为粗线，并标为$\gamma_{0}, \ldots, \gamma_{6}$ 。这些对象，在DUNE的术语中被简单地称为 "交点"，携带着$T$与邻居的关系的信息。

按照惯例，域边界上的元素切面（或者，更普遍地，元素与域外部的交点）也是DUNE的交点。因此，有两种类型的交点。  `Intersection` 一个元素与另一个元素的交叉，以及一个元素与域边界的交叉。

交叉点在DUNE网格界面中由接口类 `Intersection` 表示。它提供了评估有限元和有限体积方法中出现的边界和界面积分所需的功能。例如，有一些方法可以获得元素法向量 $\mathbf{n}$ 。由于交点可能是非平面的，法向量取决于交点的位置（ [Fig5.10] ）。法线的方向也给出了交点的方向。然而，这个方向是不确定的。相反，它取决于程序中获得交点的方式。下一节将解释，单个交点是通过迭代一个给定元素的所有交点而获得的。对于以这种方式获得的所有交叉点，这个元素被称为`inside`元素。交点另一边的元素被称为`outside`元素，法线总是从内部指向外部。`inside`和`outside`这两个名字会在`Intersection`接口类中多次出现。

交叉点作为`Euclidean`空间中的对象有一个形状。这个形状的编码方式与网格元素的形状相同：每个交叉点都有一个参考元素，其形状是一个从参考元素到物理空间的映射$F$（[Fig5.10]）。由于这与元素形状如此相似，它实际上是用已经用于元素的相同接口类`Geometry`来实现的。因此，在理解了元素形状的工作原理之后，相交形状将变得很容易。

然而，有不止一个交叉点的形状。当对交点进行积分时，积分点经常涉及到在这个交点上相遇的两个元素的`shape functions`。为了评估这些，我们需要能够从交点上的局部坐标到两个元素中的局部坐标。这种坐标变化是由接口提供的，它提供了两个额外的交点的几何实现：一个在`inside`元素的参考元素中，另一个在`outside`元素的参考元素中（[Fig5.10]）。换句话说，有从交点参考元素到这两个元素的参考元素的映射。从交点的局部坐标到两个元素之一的局部坐标，就像评估这些地图一样容易。这种构造与第`geometryInFather`章的$5.3.1$方法在其父的参考元素中产生一个元素形状的方式非常相似。

\subsubsection{Iterating over Intersections}

通过遍历一个给定元素的所有交集来访问交集。对于这样检索出来的所有交叉点，这个元素就是`inside`元素。一如既往，只有前向迭代，基于范围的for循环和直接迭代器循环都可以使用。

重要的是要认识到，一个元素的交叉点取决于该元素是被解释为水平网格视图的一部分还是叶子网格视图的一部分。这一点最好用一个例子来解释。考虑一下 [Fig5.11] 中所示的层次网格。在0级视图中，元素$T_{1}$与网格边界有三个交点，与元素$T_{2}$有一个交点。然而，当被看作是叶子视图的一部分时，它有两个与相邻元素的交点，即与$T_{11}$和$T_{12}$，除了三个边界交点之外。因此，说明所需的网格视图对于获得适当的交叉点是必要的。

给出一个名为gridView的DUNE`GridView`对象，和一个名为element的二维零的实体，可以使用基于范围的for轻松访问相应的交点。下面的例子在元素的所有交点上循环，并打印出每个交点上的法线。

~~~C++
for (const auto& intersection : intersections(gridView, element))
    std::cout << intersection.centerUnitOuterNormal() << std::endl;
~~~


对于[Fig5.9]中的元素，这将打印出

~~~Shell
0 -1
0 -1
1 0
1 0
0 1
0 1
-1 0
~~~


要使用迭代器做同样的事情，可以写成

~~~C++
auto it = gridView.ibegin(element);
auto endIt = gridView.iend(element);
for (; it!=endIt; ++it)
    std::cout << it->centerUnitOuterNormal() << std::endl;
~~~

迭代器完全遵循标准库前向迭代器的规范 [^103] [^150] 。它们的类型可以用 `GridView::IntersectionIterator` 。

如果一个元素有$m$个交叉点，那么交叉点迭代器将至少停止$m$次。它可能会停止超过$m$次，因为网格实现被允许对交叉点进行细分。考虑一个不符合要求的三维单线网格，允许非常普遍的邻域配置。两个相邻四面体之间的交点是一个凸的$n$-gon，$n$在3和6之间。对这样的交点进行积分需要一个正交规则。然而，五边形和六边形的正交规则实际上很难构建--最实用的方法是对$n$-gon进行三角化。为了向用户隐藏这种复杂性，DUNE的网格接口允许网格实现在内部进行三角计算。如果两个四面体在一个五边形中相交，网格实现可以返回三个三角形来代替一个五边形的相交。

\subsubsection{The `Intersection` Interface Class}

DUNE网格接口通过接口类`Intersection`的对象表示交叉点。这些对象提供了关于相邻元素之间关系的所有信息。表`Intersection`类的所有公共方法和所有导出的静态信息列表分别在[Tab5.8]和[Tab5.9]中给出。

第一组方法提供关于交叉点类型的信息。该方法

~~~C++
bool boundary() const
~~~

如果它被调用的交叉点是域边界的一部分，则返回true。如果是这样的话，所有引用`outside`元素的方法都有未定义的行为。另一方面，边界返回`false`并不意味着有一个`outside`元素。对于一个例子，再看一下[Fig5.11]。在第一层网格视图中，元素$T_{11}$有四个交叉点。对应于右边垂直边缘的那个不是域边界的一部分，但是在该网格视图中也没有`outside`元素。类似的情况发生在分布式网格的进程间边界。要真正知道`outside`元素是否存在（在同一个处理器上），有这样一种方法

~~~C++
bool neighbor() const
~~~



当且仅当这种情况发生时，它返回`true`。

该方法

~~~C++
GeometryType type() const
~~~

返回交叉点的参考元素的类型，也就是其参数化的域。对于网格实体，参考元素是由标记类`GeometryType`编码的（见第5.5.2章）。最后，该方法

~~~C++
bool conforming() const
~~~

返回交集是否符合，即是否等同于`inside`和`outside`元素共享的整个元素面。有了这个信息，有时就可以在 "简单的 "符合情况和更具挑战性的不符合情况下切换不同的代码路径。





为一个`Neumann`的边界项组装贡献，只涉及边界方法返回真值的那些交叉点。然而，尽管这是一个经常使用的情况，但没有办法只在这些交叉点上进行迭代。相反，我们必须在所有的元素上进行循环，并为每个元素循环该元素的所有交点，跳过那些不在边界上的交点。不用说，这可能是低效的。



作为一种妥协，`Entity`类提供了方法

~~~C++
bool hasBoundaryIntersections() const
~~~


如果元素的至少一个交点是域边界的一部分，将返回`true`。如果这对一个给定的元素来说是真的，我们需要在该元素的所有交叉点上循环以获得更多的细节。然而，如果方法返回`false`，则可以跳过元素交叉点的迭代。

下一组方法返回构成交集的两个元素的信息。记住，它们被称为`inside`和`outside`元素，其中`inside`是用来获得交集的元素。这些方法

~~~C++
Entity inside() const
Entity outside() const
~~~

返回这两个元素。如果相交处没有`outside`元素，那么`outside`方法的行为就无法定义。这些方法

~~~C++
int indexInInside() const
int indexInOutside() const
~~~


返回交点所在的元素面（即二维1的元素面$)$）的局部编号，第二种方法同样只在交点有邻居时使用。不同元素类型的面的编号在章 $5.5$ 中给出。例如，对于 [Fig5.10] 中的交集，如果 $T_{1}$ 是 `inside` 元素， `indexInInside` 和 `indexInOutside` 分别返回 1 和 2。这些数字可以直接作为第5.3.1章的`Entity<0>::subEntity`方法的输入参数。事实上，该行

~~~C++
auto facet = intersection.inside().subEntity<1>(intersection.indexInInside());
~~~

返回交叉点所在的内部实体的面。

第三组方法提供了关于交点的实际形状的信息。网格接口假定交叉点是$C^{1}$-参考元素的异形图像，就像网格元素那样。因此，交叉点的几何形状可以用`Geometry`接口类来表示，在第$5.3.2$章中已经用于实体几何形状。

对于每个交叉点，`Intersection`接口提供三种不同的几何形状（[Fig5.10]）。第一个，由方法给出

~~~C++
Geometry geometry() const
~~~

给出了网格世界空间中交点的形状。例如，这可以用来评估交点上的全局定义的函数。假设函数由一个对象$f$实现，该对象支持用`operator()`（`FieldVector`$\mathrm{x}$）进行评估，其中$\mathrm{x}$是域$\Omega$中的一个坐标 。那么在交点`xi`上的一个点$f$的评估方法是

~~~C++
auto value = f(intersection.geometry().global(xi));
~~~

然而，更多的时候，函数是以网格元素上的局部坐标给出的。为了在交叉点上评估这些函数，需要有一种方法来从交叉点上的局部坐标转到元素上的局部坐标。这就是

~~~C++
LocalGeometry geometryInInside() const
~~~

和

~~~C++
LocalGeometry geometryInOutside() const
~~~

方法做的。它们返回的几何体的世界空间分别是`inside`和`outside`元素的参考元素（参见[Fig5.10] ）。其结果是一个`local geometry`，就像`geometryInFather`方法所返回的几何体。他们的目标空间的维度等于网格维度，而不是等于网格世界空间的维度。然而，局部和全局（规则）几何体都是由章`Geometry`类$5.3.2$实现的，因此它们的行为方式是一样的。作为使用`geometryInInside`和`geometryInOutside`方法的例子，下面的代码计算了一个交点上$\xi$的片状连续有限元函数的跳跃$\left[u_{h}\right]:=u_{h, 1}-u_{h, 2}$。

~~~C++
auto jump = u(intersection.geometryInInside().global(xi))
            - u(intersection.geometryInOutside().global(xi));
~~~

该方法将交点上的坐标转换为`inside`和`outside`元素上的坐标。

在比较交叉点的几何图形和相应的`subEntity`几何图形时必须小心。如果交点是符合要求的，也就是说，如果它覆盖了整个面，情况就特别混乱。这样的交点有一个几何图形，可以通过以下方式获得

~~~C++
intersection.geometry();
~~~

同样地，该面有一个几何图形，可以通过以下方式检索到

~~~C++
intersection.inside().subEntity<1>(intersection.indexInInside()).geometry();
~~~


这两个几何对象在空间中描述了相同的形状，所以人们期望它们是相等的。然而，网格接口规范并不要求它们由相同的参数化来表示，事实上对于许多网格实现来说，它们并不是这样。它们确实都是通过地图$T_{\text {ref }}^{\text {facet }} \rightarrow \mathbb{R}^{w}$来描述相同的形状，但是这两个地图可以通过从$T_{\text {ref }}^{\text {facet }}$到自身的地图而有所不同。忽视这一点可能会导致非常微妙的错误。

我们指出了第二个隐患。虽然方法`geometry`、`geometryInInside`和`geometryInOutside`通过`value`返回其结果，但返回的对象可能没有真值语义。DUNE网格接口只保证这些对象将保持有效，直到网格对象被删除，`localBalance`被调用，或者`adapt`被调用。特别是，递增交叉点迭代器不会改变交叉点的几何形状。换句话说，下面的代码片断是有效的。

~~~C++
std::vector<Geometry> geometries;
for (const auto& intersection : intersections(gridView, element))
    geometries.push_back(intersection.geometry());

for (const auto& geometry : geometries)
    std::cout << geometry.center() << std::endl;
~~~


它将打印对象 `element` 中给出的元素的所有交点的中心。

最后一组`Intersection`接口方法返回交叉点的各种法向量。记住，这些总是指向远离`inside`元素。给出交点上的局部坐标$\xi$，方法是

~~~C++
GlobalCoordinate outerNormal(const LocalCoordinate& xi) const
~~~

返回$\xi$点的法向量，长度未定，在一个`FieldVector`类型的对象中。如果只需要法线方向，就可以使用这个方法。

为了得到一个单位`outer`法线，可以简单地将`outerNormal`的返回值归一化。然而，在某些情况下（尤其是结构化的网格），单位外法线可以由网格本身更有效地计算，因为网格可能已经预先计算了某些数值。为了从中受益，`Intersection`类提供了以下方法

~~~C++
GlobalCoordinate unitOuterNormal(const LocalCoordinate& xi) const
~~~

其中在$\xi$处返回一个单位长度的法向量。

相关方法

~~~C++
GlobalCoordinate centerUnitOuterNormal() const
~~~

也会返回一个单位外法线，但是它不需要一个参数。法线总是在交点中心计算，更准确地说，是在`intersection.geometry().center()`返回的点上计算。这是一个为有限体积算法提供便利的方法，这些算法经常需要精确的信息。例如，在第$3.4$章的有限体积例子中就使用了这种方法。

还有一种方法是提供特定长度的法向量。在有限体积方法和DG方法中，计算跨元素边界的通量是一项常见的任务，也就是以下形式的条款

\begin{equation}
\int_{\partial T}\langle\nabla u, \mathbf{n}\rangle d s=\sum_{\gamma \subset \partial T \text { an intersection }} \int_{\gamma}\langle\nabla u, \mathbf{n}\rangle d s
\label{5.1}
\end{equation}

其中$u$是一个标量函数，$\mathbf{n}$是元素$T$的单位外法线。写为对交点参考元素$T_{\text {ref }}^{\gamma}$的积分，这涉及到表达式

$$
\mathbf{n} \sqrt{\operatorname{det}\left(\nabla F_{\gamma}^{T} \nabla F_{\gamma}\right)}
$$

其中$F_{\gamma}$是由交叉点几何学代表的地图，即从交叉点参考元素到网格世界空间的地图。术语$\mathbf{n} \sqrt{\operatorname{det}\left(\nabla F_{\gamma}^{T} \nabla F_{\gamma}\right)}$可以被解释为按比例的法线矢量，这就是方法的概念。作为一个例子，下面的代码片段为一个给定的函数$u$实现了表达式\ref{5.1}，可以在全局坐标中进行评估。

~~~C++
// Loop over all intersections
for (const auto& intersection: intersections(gridView, element))
{
    // Quadrature loop
    const auto& quadRule
        = Geometry::QuadratureRules<double, dim>::rule(intersection.type(), quadOrder);
    for (const auto& quadPoint : quadRule)
    {
    GlobalCoordinate uGradient
        = derivative(u)(intersection.geometry().global(quadPoint.position()));
    GlobalCoordinate scaledNormal
        = intersection.integrationOuterNormal(quadPoint.position());
    result += quadPoint.weight() * (uGradient * scaledNormal); // Scalar product
    }
}
~~~



关于数值正交的细节，请参见第9章，以及关于计算梯度的语法的第$10.5 .3$章。

[Tab5.8]中还有最后一种方法尚未讨论。方法`boundarySegmentIndex`需要将数据附加到域边界。第$5.6$章专门讨论这个问题，那里将解释这个方法。


\subsection{Reference `Elements`}



DUNE网格接口将元素的几何形状定义为从参考元素到`Euclidean`空间的映射，这个想法反映在`Geometry`类的接口中。在这个接口中，参考元素只是间接出现，例如，作为方法`global`的有效参数集，该方法评估了地图。

然而，有时有必要获得一些关于参考元素本身的信息。例如，知道一个给定的点是否包含在一个给定的参考元素中可能会有帮助。或者，在一个包含棱镜元素的网格中，$i^{th}$面是三角形还是四边形，以及其顶点的局部数字是什么。虽然这听起来像是要从网格元素中获得的信息，但把它单独存储起来，对所有的棱镜都是如此，这更优雅。

与网格元素类似，参考元素也有几何学和拓扑学方面的特点。在几何上，参考元素是一个固定的多边形。在大部分的有限元文献中，参考三角形是角为（0，0），（1，0），（0，1）的三角形。对于参考四边形，[0, 1]和[-1, 1]都被使用。在[^16]中更严格的表述中，参考元素因此被定义为`equivalence`类多面体。


在拓扑学上，参考元素定义了一个元素的局部面的编号。有各种方法来定义这些编号，每个有限元的实现都需要做出选择。对于DUNE中可用的一维、二维和三维参考元素，这些编号在[图5.12和[Fig5.13]中说明。

虽然有无限多的任何维度大于1的拓扑学上不同的凸多边形，但实际上很少被用作参考元素。有限元方法几乎只使用单纯体和立方体，而对于三维立方体网格中的红绿细化，则需要金字塔和棱镜（[Fig2.22]）。像虚拟元素法或拟态有限差分这样的高级方法也可以适应更多的一般元素类型 [^21] [^119] 。

DuNE网格界面并没有提供一套完整的参考元素。相反，它提供了上面提到的重要类型，以及一套可以通过某些规则构建的其他类型（在第5.5.2节解释）。对于更普遍的参考元素，我们必须扩展`dune-geometry`模块代码本身。

\subsubsection{Using the Dune Reference `Elements`}

参考元素的DuNE接口包含在`dune-geometry`模块中，在文件`dune/geometry/referenceelements.hh` 中。与DUNE网格接口的其他部分不同，参考元素使用`duck typing`，也就是说，用户代码可以直接处理实现类（第4.4.2章）。在写这篇文章的时候，有一个单一的参考元素的实现被所有的网格实现所使用，但是存在基础设施，可以让特定的网格实现他们自己的参考元素。

参考元素没有公共构造函数。相反，它们可以由工厂类[^72]产生。

~~~C++
template<class ctype, int dim>
ReferenceElements<ctype,dim>
~~~


它通过静态方法传递出参考元素对象

~~~C++
auto ReferenceElements<ctype,dim>::simplex()
auto ReferenceElements<ctype,dim>::cube()
auto ReferenceElements<ctype,dim>::general(const GeometryType& type)
~~~


其中前两个方法提供了相应维度的单轴和立方体参考元素。一般方法提供给定维度的任何实现的参考元素。要求的类型由类型`GeometryType`的对象指定（详见5.5.2节）。例如，要获得三维棱镜元素的参考元素，写道

~~~C++
auto referencePrism
    = ReferenceElements<double,3>::general(GeometryTypes::prism);
~~~


要用它来获得，例如，该参考棱镜的体积，请写出

~~~C++
std::cout << referencePrism.volume() << std::endl;
~~~


这将打印出 $0.5$ 的值，考虑到 [Fig5.13] 中 DUNE 参考棱镜的定义，这是正确的。

作为工厂的替代方案，有一些免费的功能

~~~C++
auto referenceElement(...)
~~~


允许获得各种参数的参考元素对象。例如，如果`GeometryType`是`GeometryType`对象，dim是尺寸，`ctype`是适合点坐标的数字类型，那么下面三行都会产生参考元素。

~~~C++
auto refElement = referenceElement<ctype,dim>(geometryType);
auto refElement = referenceElement<ctype>(geometryType, Dim<dim>());
auto refElement = referenceElement(ctype(), geometryType, Dim<dim>());
~~~


此外，`referenceElement`方法允许获得`Geometry`对象的参考元素。

~~~C++
auto refElement = referenceElement(geometry);
~~~

这要比

~~~C++
auto refElement = referenceElement<ctype,dim>(geometry.type());
~~~

并且也可以更有效率。

[Tab5.10] `ReferenceElement`类的公共方法列表可以看出，对应于网格元素的拓扑和几何方面，它可以被分成拓扑和几何部分。在拓扑学部分，前两个方法告知参考元素面的类型。该方法

~~~C++
GeometryType type(int i, int c) const
~~~


返回c维的$i^{th}$子面的类型。将i和$c$设为零，返回参考元素本身的类型。为了方便，还有一个方法

~~~C++
GeometryType type() const
~~~


它返回同样的东西。



该方法

~~~C++
int size(int c) const
~~~

例如，如果`dim`是参考元素的维度，那么`size (dim)`将返回角的数量，`size (1)`将返回面的数量，而`size (0)`将总是返回1。

下面的例子同时使用了`type`和`size`方法来打印金字塔的所有面的类型。

~~~C++
auto referencePyramid
    = ReferenceElements<double,3>::general(GeometryTypes::pyramid);

for (int i=0; i<referencePyramid.size(1); i++) // 1 is the codimension
                                               // of facets
    std::cout << referencePyramid.type(i,1) << std::endl;
~~~


更一般地说，参考元素知道它们的面的大小。该方法
~~~C++
int size(int i, int c, int cc) const
~~~

给出了代码为$i^{th}$的面的代码为cc的子面的数量$\mathrm{c}$ 。两个维度都是关于参考元素的。因此，例如，`size(0,1,dim )`返回第0个面的顶点数量，而尺寸$(0,1, \operatorname{dim}-1)$返回这个面的边的数量。如果$\operatorname{dim}==3$，则`size(0,2,dim)`返回第0个边的顶点数（当然总是2），以此类推。如果cc小于$c$，则该方法返回0。

然而，另一个方法提供了实际的子界面。调用

~~~C++
SubEntityRange subEntities(int i, int c, int cc) const
~~~

给出c维的$i^{th}$面的信息。它返回该面的代码为cc的子面的局部数字的范围。两个维度都是相对于参考元素而言的。subEntities方法的返回值是`Dune::IteratorRange`的子类，来自`dune-common`模块。因此，它提供了方法begin和end，允许在该范围内进行迭代。此外，`SubEntityRange`对象有方法

~~~C++
std::size_t size() const
~~~

和

~~~C++
bool contains(std::size_t i) const
~~~


第一个返回范围内的元素数，第二个可以用来测试范围内是否包含一个特定的子面索引。因此，要获得一个四面体的所有面的顶点编号，请写出

~~~C++
// Loop over facets
for (int i=0; i<referenceTetra.size(1); i++)
    // Loop over vertices of current facet
    for (auto v : referenceTetra.subEntities(i,1,3))
        std::cout << "facet: " << i << ", vertex: " << v << std::endl;
~~~


这将打印

~~~Shell
facet: 0, vertex: 0
facet: 0, vertex: 1
facet: 0, vertex: 2
facet: 1, vertex: 0
facet: 1, vertex: 1
facet: 1, vertex: 3
facet: 2, vertex: 0
facet: 2, vertex: 2
facet: 2, vertex: 3
facet: 3, vertex: 1
facet: 3, vertex: 2
facet: 3, vertex: 3
~~~


这与[Fig5.13]中说明的编号一致。`ReferenceElement`类的其余方法都具有几何性质。例如，方法

~~~C++
bool checkInside(const FieldVector<ctype,dim>& local) const
~~~


如果坐标为`local`的点被包含在参考元素中，则返回`true`。该方法

~~~C++
template<int codim>
Codim<codim>::Geometry geometry(int i) const
~~~


返回一个参考元素面的嵌入到参考元素本身。这与`Intersection`类的`geometryInInside`方法非常相似，后者返回面的（部分）嵌入到参考元素中（第5.4章）。然而，与`geometryInInside`方法的情况不同，这里可以处理任何维度的面；特别是，对二维0调用此方法将返回参考元素本身的几何形状。由`ReferenceElement::geometry`返回的对象正好实现了$5.3.2$章中解释的`Geometry`类的接口，并且其类型由`ReferenceElement`类导出。

后三种方法简单而方便。该方法

~~~C++
Volume volume() const
~~~

返回参考元素的体积，数字类型为 `Volume` 。该方法

~~~C++
FieldVector<ctype,dim> position(int i, int c) const
~~~


计算c维的$i^{th}$子面的顶点的质心。这对有限体积方法很有用，或者只是需要一个保证在参考元素中的点。如果c等于dim，返回值是$i^{th}$顶点的位置；如果$c$是0，是参考元素本身的质心。体积和位置信息也可以通过`geometry`方法获得，但直接在参考元素本身上获得这些信息会很方便。

最后，该方法

~~~C++
FieldVector<ctype,dim> integrationOuterNormal(int i) const
~~~


返回$i^{th}$面的外法向量。矢量的长度等于该面的积分元素，也就是积分转换公式中出现的$\sqrt{\operatorname{det} \nabla F_{\text {facet }}^{T} \nabla F_{\text {facet }}}$项（第5.3.2章）。这使得跨元素面的矢量场的数值正交变得非常有效。

与`Intersection`类的情况不同，它也返回法向量，这里不需要位置参数。因为所有的参考元素都是多面体，它们的切面是平面的，因此切面的法向量与位置无关。



\subsubsection{GeometryType and the Topology Id}

有几章已经提到了`GeometryType`类，它实现了一个标记来指定一个特定的参考元素。它被`Entity`类用来报告与实体相对应的参考元素（第$5.3.1)$章，反过来，它被`ReferenceElements`容器类接受，该类发出特定的参考元素对象。在$9.2$章中，它将被用来请求给定参考元素的正交规则。

有了一些关于DUNE如何构建其参考元素的背景知识，`GeometryType`类就更容易理解。理想情况下，参考元素的标记类将能够标记所有的凸多面体。不幸的是，除了一维和二维的多面体之外，这样的标注是很困难的，此外，在有限元计算中很少需要这些类型。DUNE选择了一种实用的方法，并实现了标准有限元方法中的那些参考元素。这包括所有维度的单纯体和超立方体，红绿自适应六面体网格所需的棱镜和金字塔，以及更高维度的各种棱镜和金字塔类型。对于未被可用参考元素列表覆盖的情况，有一个特殊的非类型（每个维度一个），它可以向应用程序发出信号，表明某种特殊处理是必要的。

DuNE系统地构建了参考元素，其过程在 [^49] 中有所解释。其基本思想是对维度的归纳。唯一的一维参考元素是单位区间（根据$\mathbb{R}$的同构性），它可以被解释为一维立方体或一维单线。从单位区间开始，DUNE考虑了两种构建二维多角形的方法。将单位区间与第二个单位区间进行张量乘法，得到单位平方$[0,1]^{2}=[0,1] \times[0,1]$ 。另一方面，圆锥乘法则导致单位三角形的出现。形式上，对于一个给定的参考元素$T_{\text {ref }} \in \mathbb{R}^{d-1}$，我们定义张量积

$$
T_{\mathrm{ref}}^{\mathrm{}}:=\left\{(x, z): x \in T_{\mathrm{ref}}, z \in[0,1]\right\}
$$

和圆锥体产品

$$
T_{\text {ref }}^{\circ}:=\left\{(x(1-z), z): x \in T_{\text {ref }}, z \in[0,1]\right\}
$$

这样继续到三维空间，单位正方形与一个区间的张量乘积导致单位立方体，三角形与区间的圆锥乘积导致单位四面体。单位正方形与单位区间的圆锥乘积导致金字塔，三角形与单位区间的张量乘积导致棱柱。这个过程在[Fig5.14]中得到了说明。任意维度的多面体都可以这样构造，包括超立方体和所有维度的单纯体。

虽然这种结构明显地产生了所有相关的参考元素的点集，但其真正的优势在于它也产生了这些参考元素的所有面的一致编号。该算法的确切性质超出了本文的范围，但它允许实现ReferenceElement类（第5.5.1章）的`subEntity`方法，即使是对高维的参考元素。

DUNE将张量积和锥形积的定义序列编码为一个整数。用 "1 "表示张量乘积，用 "0 "表示锥形乘积，这种乘积的序列给出一个二进制数字序列。这个数字序列，作为一个数字阅读，被称为参考元素的`topology id`。与元素维度（指定`topology id`位序列的位数）一起，这样一个`topology id`指定了一个参考元素。`topology id`是唯一的，只有一个例外。因为单位段既可以通过张量构建，也可以通过点与区间[0,1]的锥形乘法构建（它既是单曲线也是立方体），一位数的数字0和1都表示同一个参考元素。在解释`topology id`位时，必须牢记这一点。

`GeometryType`类（来自文件`dune/geometry/type.hh`）将`topology id`思想的复杂性隐藏在一个方便的接口后面。它是一个$\mathrm{C}++$的 "字面类型"，如果用`constexpr`的构造函数创建，可以在`constexpr`的上下文中使用。

有两种方法可以获得`GeometryType`对象, [Tab5.11]。第一种方法是调用它的一个构造函数。最重要的一个是

~~~C++
constexpr GeometryType(unsigned int topologyId,
                       unsigned int dim,
                       bool none=false)
~~~


但`GeometryType`对象也可以是默认构建的。

然而，在许多情况下，使用第二种构造方法更为方便。命名空间`GeometryType`s提供了一组静态对象和工厂方法，可以用来建立`GeometryType`对象。比如说。

~~~C++
GeometryType gt = GeometryTypes::triangle;
~~~

将建立一个`GeometryType`对象，代表二维参考三角形，并且

~~~C++
GeometryType gt = GeometryTypes::prism;
~~~

将对三维参考棱镜做同样的处理。这些线

~~~C++
GeometryType gt = GeometryTypes::simplex(4);
GeometryType gt = GeometryTypes::cube(4);
~~~

将分别设置四维参考单轴和立方体元素，而

~~~C++
GeometryType gt = GeometryTypes::none(3);
~~~

给出了一个三维中无类型的标记。在所有这些类型中，`pyramid`和`prism`只适用于三维元素，但其他类型可以用于任何空间尺寸。关于这些对象和方法的完整列表，请参考在线文档。

给定一个`GeometryType`对象，其属性可以被查询。比如说。

~~~C++
bool isHexahedron() const
~~~

如果给定的`GeometryType`对象是一个三维六面体，则返回`true`，并且

~~~C++
bool isCube() const
~~~

返回它是否是任何维度的超立方体。这些方法的完整列表在在线文档中给出。  `GeometryType`对象通过以下方式提供其`topology id`的表示方法

~~~C++
unsigned int id() const
~~~

其尺寸为

~~~C++
unsigned int dim() const
~~~

对于更深层次的东西，你需要询问相应的`ReferenceElement`对象。

最后， `GeometryType` 实现了几个比较运算符，允许它被用作关联标准库容器的键类型 [^103] 。请注意，所有无对象的比较是相等的，即使它们可能有不同的尺寸。为了方便调试，`operator<<`也被实现。

\subsection{Attaching Data to Grids}

有限元网格的目的是作为有限元方法中使用的离散函数空间定义的基础。这些空间的函数被表达为相对于离散空间的一些基的系数向量，一旦选择了网格和函数空间基，存储该空间的离散函数就意味着存储系数向量。在DUNE中，函数空间基由`GlobalBasis`对象表示。这些对象在 `dune-functions ` 模块中实现，并在第10章中解释。

对于大多数有限元空间，基函数和相应的系数可以与各个网格实体相关联。例如，一阶`nodal basis`空间的`Lagrange`函数可以关联到网格顶点（2.1.2章）。同样地，`Crouzeix-Raviart`元素的标准基函数可以与网格边缘相关联，而`Discontinuous Galerkin`（DG）空间的基函数自然也与元素相关联。并非所有用作有限元空间基函数的函数都可以合理地分配给网格的实体；一个例子是B-spline基的函数，其支持度比`Lagrangian`基函数大得多。不过，对于标准的有限元空间，这样的赋值是可能的，也是有用的。

由于数据系数与基函数相关，而基函数与网格实体相关，因此系数也与网格实体相关。因此，一个为数值模拟实现网格数据结构的软件需要提供一种方法，将数值数据附加到各个网格实体上。对于任何给定的实体，这些数据应该是容易和有效地检索的。另外，当网格由于自适应细化或负载平衡而发生变化时，必须有一种方法来尽可能地在这种网格修改步骤中保留离散的网格功能数据。最后，每个实体允许的数据类型和数量应该是任意的。应用在这里可以有任意的要求，而好的软件基础设施应该不加任何限制。

诱人的做法是将数字数据存储在实体数据结构本身，要么直接存储数据，要么存储数据的指针（ [Fig5.15] , left）。这种方法，例如UG3软件[^13]所使用的方法，允许轻松而廉价地访问任何特定实体的数据。当网格发生局部变化时，那些不受变化影响的实体自然会保留它们的数据。

然而，这种方法在执行速度上付出了相当大的代价。系数向量将作为线性代数算法的输入和输出数据，特别是稀疏系统的线性求解器。由于代数问题是出了名的大，相应的算法和它们的实现必须有最大的效率。将每个顶点的数据单独存储在堆上会导致数据碎片化，也就是说，数据会分散在计算机内存中。在现代计算机架构上，这导致了执行时间的严重增加。

为了最佳地利用现代计算机结构的内存层次，数据需要连续地放在内存中。一个类似于数组的数据结构是必须的，各个条目都可以通过数字来寻址。这就是DUNE所采取的方法。所有的数字数据都必须存储在完全在网格数据结构之外的类似数组的数据类型中。为了访问这些数据，网格实体提供整数，允许对数组进行寻址。在DUNE术语中，这样的数字被称为`index` 。对于网格视图中给定的`GeometryType`的所有实体的集合，相应的索引集合被保证是连续的，并且从零开始。因此，相应的数据可以存储在一个数组数据结构中，不会有未使用的空间。对于顶点数据，这在[Fig5.15]中得到了说明，右图。

然而，一旦网格发生变化，使用数组和索引的方法就会失效。在一个自适应细化或负载平衡的步骤之后，旧的指数必然不再是连续的，而必须分配新的指数。这些新的索引就不能解决现有的数据阵列，除非这些数据阵列被适当地重新排序。为了进行这种重新排序，DUNE网格界面提供了第二种叫做$i d$的数字，这将在第$5.6.3$章中解释。

\subsubsection{Index Sets and the Boundary Segment Index}

下面一节解释了用于获取给定实体索引的接口。由于这些指数不仅取决于实体本身，也取决于网格视图（ [Fig5.16] ），所以指数不能直接从实体类中获得。相反，给定网格视图的实体的索引分配是由一个专门的接口类提供的，这个接口类叫做IndexSet，可以通过方法从`GridView`类中获得

~~~C++
const IndexSet& indexSet() const
~~~

注意，返回值是一个常量引用 - IndexSet 对象不能被复制。IndexSet类的公共方法在[Tab5.12]中列出。此外，该类静态地导出了维度中的网格尺寸，以及网格实现用于存储索引的类型`IndexType`等（[Tab5.13]）。

下面的例子总是假设在一个叫做`indexSet`的变量中，有一个给定网格视图的`IndexSet`对象，以及一个叫做实体的任意尺寸的`Entity`对象。然后，`indexSet.index (entity)`将返回该实体的索引。作为一个使用的例子，假设有一个叫做data的`std::vector<double>`，保存顶点数据。下面的循环将打印出这些数据以及相应的顶点坐标。

~~~C++
for (const auto& vertex : vertices(gridView))
    std::cout << "index: " << indexSet.index(vertex) << " "
        << "position: " << vertex.geometry().corner(0) << " "
        << "data: " << data[indexSet.index(vertex)] << std::endl;
~~~


根据不同的网格实现，这个循环可能会也可能不会按照索引增加的顺序遍历顶点列表。例如，`UGGrid`的实现是按照顶点插入网格的顺序对其进行编号，但在迭代时，边界顶点会先出现。这种差异一开始可能会显得很奇怪，但几乎没有必要让这两种顺序相同。

除了给定实体的索引，`IndexSet`接口还提供其子实体的索引。这对于那些需要访问某个元素的顶点、边、面等数据的装配程序来说非常重要。这方面的方法是

~~~C++
template<class Entity>
IndexType subIndex(const Entity& entity, int i, unsigned int codim) const
~~~


第二个整数参数是一个维度（相对于网格而言），第一个参数是该维度的`subEntity`的局部数字。因此，举例来说，下面的循环会打印出实体中给出的六面体的所有边缘数据。

~~~C++
for (size_t i=0; i<entity.subEntities(2); i++) // Loop over all 12 edges
    std::cout << data[indexSet.subIndex(entity,i,2)] << std::endl;
~~~

如果`entity`是一个元素，并且`subEntity`的二维码在编译时是已知的，那么代替

~~~C++
indexSet.subIndex(entity,i,2)
~~~

也可以使用`Entity::subEntity`的方法，写成

~~~C++
indexSet.index(entity.subEntity<2>(i))
~~~

它返回相同的数字。然而，使用subIndex不仅可以缩短代码，而且往往比用`subEntity`方法构建完整的`subEntity`要快。

对于不包含在索引集对应的网格视图中的实体，调用最后两个方法中的任何一个，其结果都没有规定。为了测试一个给定的实体是否是网格视图的一部分，`GridView`类提供了以下方法

~~~C++
template<class Entity>
bool contains(const Entity& entity) const
~~~

为了方便起见，这个方法被复制到了`IndexSet`类中。因此，如果调用`indexSet.contains (entity)`返回真，那么同时调用`indexSet.index (entity)`方法是安全的。关于包含方法的运行时间复杂度没有保证，但对于大多数合理的网格实现来说，它应该需要恒定的时间。

接下来的两个方法告知在`IndexSet`的域中有多少个给定类型的对象。这尤其意味着可能出现的最大索引。这两种方法都被称为 `size` 。

~~~C++
IndexType size(GeometryType type) const
IndexType size(int codim) const
~~~


第一个方法接受一个`GeometryType`对象作为唯一的参数，并返回该`GeometryType`实体的数量（例如，网格视图中所有三角形的数量）。第二个方法接受一个整数参数，其含义是相对于网格的二维码，并返回该二维码的实体数量。因此，用`IndexSet`对象表示二维网格视图。

~~~C++
indexSet.size(GeometryTypes::simplex(2))
~~~

是三角形的数量，和
~~~C++
indexSet.size(0) // Elements have codimension 0
~~~

是所有元素的数量。

最后，该方法

~~~C++
Types types(int codim) const
~~~

允许确定在网格视图中实际存在哪些给定维度的实体类型。该方法返回一个迭代器范围，也就是说，一个可以向前迭代的轻量级容器类型。例如，代码

~~~C++
for (const auto& type : indexSet.types(0))
    std::cout << type << std::endl;
~~~

将打印网格视图中所有元素的类型。对于 [Fig5.17] 中的网格，其结果将是

~~~Shell
(simplex, 2)
(cube, 2)
~~~


对于处理包含一个以上元素类型的网格的人来说，有一个重要的陷阱。指数对每个`GeometryType`都是单独计算的。例如，在[Fig5.17]的网格中，元素索引0出现了两次，一次是三角形元素，一次是四边形元素。这样做的原因是运行时的速度。许多有限元空间为不同的元素类型分配了不同的自由度数。如果单独的元素类型有单独的索引，那么从给定的元素和形状函数数计算全局自由度的数量就容易得多，也快得多。对于一个给定维度的所有实体的单一连续索引，使用第`MultipleCodimMultipleGeomTypeMapper`章的$5.6.2$类。

到目前为止，文本只谈到了如何为网格实体分配数字。这些数字是需要用来将用户数据附加到这些实体的。然而，也有必要能够将用户数据附加到边界上。这种数据可以由标签或枚举值组成，以指定不同类型的边界条件，也可以是标量或矢量值的边界数据。

如何在DUNE中存储此类数据的基本思路与实体数据相同。数据本身被存储在一个数组中，而边界段可以提供一个适合索引数组的数字。然而，也有一些区别。首先，被分配数字的对象不是实体，而是交叉点。章$5.4$解释了相邻元素对之间以及域边界上的交点是如何存在的。只有后者带有指数。对于这组交叉点，指数是连续的，从0开始。然而，与实体的指数不同，边界段的指数并不区分不同的边界段类型。有一个连续的索引从0开始，而不是每个`GeometryType`都有一个。这是DUNE网格界面中的一个小的不一致，但可以说它使边界段指数更容易使用。

边界段指数和实体指数之间有第二个区别：边界段指数只为0级网格视图上的边界段定义。然而，可以从所有的边界交汇点询问指数。  `Intersection` 0级上的s将返回其索引。  `Intersection` 高层的s将返回其在$0$层的祖先的索引。这样设计的原因是，通常输入的网格只包括第0层的视图，边界条件是针对该视图而指定的。更高层次的网格视图只在模拟过程的后期出现，通过自适应网格细化。  [Fig5.18]展示了一个例子。

由于历史原因，边界段索引不能通过索引集类来使用。相反，它是`Intersection`接口类的一个成员函数（见[Tab5.8]）。

~~~C++
size_t boundarySegmentIndex() const
~~~

此外，0级边界段的总数可以通过调用方法获得

~~~C++
size_t numBoundarySegments() const
~~~

的（分层的）网格对象。

\subsubsection{The `MultipleCodimMultipleGeomTypeMapper` Class}

使用`IndexSet`接口很容易为简单的有限元空间编写应用程序，如一阶`Lagrangian`有限元、单元素类型网格上的DG空间，或`Crouzeix-Raviart`元素。这些都有一个共同点，即它们只将数据附加到一个单一类型的实体。对于更一般的空间，自由度的全局数必须根据`IndexSet`所提供的信息进行计算。根据实际空间的情况，实现这种计算可以从 "相当简单 "到 "相当困难 "不等。第十章的`GlobalBasis`类可以进行这样的计算，除非有很好的理由，否则应该使用。

然而，对于某些任务来说，使用完整的`GlobalBasis`可能是不可行的。特别是，编写新的`GlobalBasis`类需要手动实现索引计算，这可能很乏味。为了帮助这些计算，`dune-grid`提供了一个名为`MultipleCodimMultipleGeomTypeMapper`的辅助类，可从文件`dune/grid/common/mcmgmapper.hh`中获得。它完成了一个与索引集非常相似的任务：它为网格视图的实体分配索引（即从0开始的连续整数集的元素）。这些分配可以比索引集所提供的更通用，但没有达到`GlobalBasis`对象的全部通用性。索引集为网格的每个实体分配一个索引，而`MultipleCodimMultipleGeomTypeMapper`允许为`particular geometry types`的实体分配一个或多个索引。然后，对于这些几何类型之一的所有实体，这些指数是连续的，并且是零开始的。例如，为了得到三角形网格上的三阶`Lagrange`空间的编号，每个顶点和三角形应该有一个索引，每条边有两个。

一个重要的特例是为具有多个元素类型的网格构建连续的元素编号。记住，索引集为每个`GeometryType`单独分配索引（[Fig5.17]），即在一个既有三角形又有四边形元素的网格视图中，会有两个索引为0的元素。获得所有元素的单一连续索引的典型方法是使用一个`MultipleCodimMultipleGeomTypeMapper`。

`MultipleCodimMultipleGeomTypeMapper`是一个独立的类，其签名为

~~~C++
template<class GridView>
class MultipleCodimMultipleGeomTypeMapper
~~~

这种类型的对象是通过调用类的构造函数获得的

~~~C++
MultipleCodimMultipleGeomTypeMapper(const GridView& gridView,
                                    const MCMGLayout& layout)
~~~



`layout`参数是一个小型的辅助类，用于指定哪些几何体类型应该获得索引。下面将详细解释。

由于映射器的功能与索引集的功能相似，所以这两个编程接口也是相似的。[Tab5.14]列出了`MultipleCodimMultipleGeomTypeMapper`类的公共方法。这些方法

~~~C++
size_type size() const
size_type size(GeometryType type) const
~~~


分别返回索引总数，以及分配给给定`GeometryType`的一个实体的索引数。这些方法

~~~C++
template<class Entity>
bool contains(const Entity& entity, Index& result) const
bool contains(const GridView::Codim<0>::Entity& entity,
                int i,
                int cc,
                Index& result) const
~~~


如果一个给定的实体或`subEntity`被`MultipleCodimMultipleGeomTypeMapper`类分配了至少一个索引，则返回`true`。这与IndexSet类的`contains`方法非常相似。然而，与那些不同的是，如果实体被分配了一组索引，那么`MultipleCodimMultipleGeomTypeMapper`的`contains`方法会返回`result`字段中的第一个这样的索引。这在先验地知道这个索引是唯一的索引的情况下是有帮助的--然后可以直接使用它，而不用进一步调用映射器。

要获得一个给定实体的所有索引，有以下方法


~~~C++
template<class Entity>
IntegralRange<Index> indices(const Entity& entity) const
IntegralRange<Index> indices(const GridView::Codim<0>::Entity& entity,
                             int i,
                             unsigned int codim) const
~~~

它们返回类似于容器的轻量级对象，可以进行随机访问的迭代。它们可以直接用于基于范围的for循环中。例如，下面的代码打印了所有连接到一个给定实体的全局索引。

~~~C++
for (auto i: mapper.indices(entity))
    std::cout << i << std::endl;
~~~

对于每个实体只有一个自由度的重要情况，也有以下方法

~~~C++
template<class Entity>
Index index(const Entity& entity) const
Index subIndex(const GridView::Codim<0>::Entity& entity,
               int i,
               unsigned int codim) const
~~~

该方法

~~~C++
void update()
~~~


最后，重新计算内部状态。只要网格发生变化，就必须调用它。

选择哪些实体获得多少索引是使用一个谓词类进行的。在这种情况下，谓词类被称为映射器的`layout`。它必须有一个公共方法

~~~C++
std::size_t operator()(GeometryType type, int gridDim)
~~~

这将返回给定的几何体类型在维度为`gridDim`的网格中携带的索引数。例如，下面的lambda实现了前面提到的三角形网格的三阶`Lagrange`布局。

~~~C++
auto p3Layout = [](GeometryType type, int gridDim)
{
    if (type.isVertex())
        return 1;
    if (type.isLine())
        return 2;
    assert(type.isTriangle());
        return 1;
};
~~~

几个标准的布局对象直接在`mcmgmapper.hh`文件中实现。例如，每个元素一个索引的布局对象可以通过调用全局方法获得

~~~C++
MCMGLayout mcmgElementLayout()
~~~


同样，还有`mcmgVertexLayout`，用于基于顶点的数据布局，或者，更广泛的说。

~~~C++
template<int dim>
MCMGLayout mcmgLayout(Dim<dim>);
~~~

来选择一个给定维度的所有实体。由这些方法返回的类`MCMGLayout`被定义为

~~~C++
using MCMGLayout = std::function<std::size_t(GeometryType,int)>;
~~~

它可以容纳任何类型的对象，实现

~~~C++
size_t operator()(GeometryType,int)
~~~

下面这个简短的例子用上面定义的`p3Layout`对象设置了一个映射器，并打印出结果的索引。

~~~C++
MultipleCodimMultipleGeomTypeMapper<GridView> mapper(gridView, p3Layout);
unsigned int dim = GridView::dimension;
for (const auto &element : elements(gridView))
{
    std::cout << "element index: " << mapper.index(element) << std::endl;
    for (size_t i = 0; i < element.subEntities(dim - 1); ++i)
        for (const auto &index : mapper.indices(element, i, dim))
            std::cout << " vertex index: " << index << std::endl;
    for (size_t i = 0; i < element.subEntities(dim - 1); ++i)
        for (const auto &index : mapper.indices(element, i, dim - 1))
            std::cout << " edge index: " << index << std::endl;
}
~~~


当运行这段代码时，边缘和顶点的索引被打印了好几次，因为主循环在元素上迭代，因此边缘和顶点对于它们所属的每个元素都被访问一次。

\subsubsection{Persistent Numberings}

根据结构，当网格发生变化时，上一节的索引就会失效。如果实体被添加到网格中，这些实体可以以一种自然的方式被索引。然而，更普遍的网格变化也会涉及到实体被移除。那么，如果不改变在网格变化之前就已经存在的实体的索引，就不可能保持连续的索引。

DuNE网格基本上有两种变化方式：适应性网格细化和负载平衡。自适应网格细化主要是增加新的实体，但在使用红绿细化规则或明确要求删除实体时，实体也会消失。分布式机器上的负载平衡使整个网格保持不变，但改变各个进程的网格。


为了在网格变化中传输数据，索引机制是不够的。需要有一种方法来将数据附加到网格上，这种方法在网格被修改时是持久的，将数据保存在由实体索引组成的数组中。`dune-grid`解决这个问题的方法是提供第二种实体编号，在网格被修改时不会改变。这样的编号在DUNE中被称为id。每个实体都有两个，而且这两个在实体的整个生命期都不会改变。

自然地，这样的id不能用来处理保存在数组中的数据。然而，它们可以用于更一般的、关联的容器，如搜索树或哈希图 [^43] 。在改变网格之前，所有的数据都需要从它们的数组中复制到独立的容器中，这些容器可以通过持久化的id进行索引。这种复制的成本很高；然而，有人认为，网格细化和负载平衡操作的成本更高，相比之下，复制的价格并不重要。在网格修改之后，数据被复制回数组中。第$5.9.2$章展示了一个详细的例子，说明如何为自适应网格细化做这件事。

虽然id在许多方面与指数相似，但也有一些区别。最重要的是不同的注入性属性。让$E$是所有同维度、参考元素类型和细化级别的所有实体的集合，让$I$是一个id的集合。那么id映射$E \rightarrow I$是注入式的，有一个重要的例外。如果一个给定的网格级别上的实体也存在于不同的级别上，那么这两个副本就会映射到同一个id。这在下面的例子中得到了说明

该实体拥有的两个ID被称为`local`和`global`。在单处理器系统中，这两个ID没有功能上的区别，尽管它们不需要完全相同。在多处理器系统上，如果$E$是一个进程中所有实体的集合（在该进程中适用复制规则），那么本地id在上述意义上是双射的。相比之下，全局id映射对于整个分布式网格的所有实体集合来说是双射的。这个`double`构造的动机是声称完全的全局双射性并不总是需要的，而且局部id映射比全局的更容易构造和维护。

与索引类似，实体ID不是直接从实体中获得的，而是通过一个单独的类。这个类的名字是`IdSet`，与索引的IndexSet类相对应。然而，由于id不是针对特定的网格视图构建的，`IdSet`类是直接从分层网格中获得的，而不是从网格视图中获得。为了获得本地id的`IdSet`，请编写

~~~C++
const auto& localIdSet = grid.localIdSet();
~~~


相应地，写出

~~~C++
const auto& globalIdSet = grid.globalIdSet();
~~~

为全局ID。  `IdSet`对象不能被复制，而必须作为`const`的引用来传递。因此，这种引用总是指向最新的`IdSet`对象，即使网格已经被修改。


`IdSet`类的接口类似于`IndexSet`接口的瘦身版。它实际上只包含两个方法，即

~~~C++
template<class Entity>
IdType id(const Entity& entity) const
~~~


和

~~~C++
IdType subId(const Grid::Codim<0>::Entity& entity,
            int i,
            unsigned int codim) const
~~~



这些方法分别对应于`index`和`subIndex`类的两个方法：id返回参数`entity`中给出的实体的id，subId返回$i^{th}$`subEntity`的二维`entity`的id。第$5.9.2$章的网格适应性例子充分地使用了这些方法。

返回类型`IdType`是网格实现所使用的id的实现类型，对于本地和全局id可以是不同的。该类型可以从`IdSet`类中检索为`IdSet::IdType` 。对这些类型只有很弱的要求。从概念上讲，`IdType`可以是任何东西，但它必须可以作为标准库`std::map`和`std::unordered_map`容器的键。特别是，对于 `std::map` 来说，这意味着 `IdType` 实现了

~~~C++
bool operator<(const IdType&, const IdType&)
~~~

而且这个运算符实现了严格的弱排序。要想成为`std::unordered_map`的密钥，还必须具备以下条件

~~~C++
bool operator==(const IdType&, const IdType&)
bool operator!=(const IdType&, const IdType&)
~~~


和`std::hash<IdType>`必须满足标准库哈希对象的要求。为了完整起见，要求`IdType`是可默认构建、可复制构建和可复制分配的。最后，为了调试的目的，必须能够使用 `operator <<` 将 `IdType` 类型的对象写入标准 $\mathrm{C}++$ 流中。

\subsection{Creating Grids}

到目前为止，我们已经谈到了网格界面以及如何访问和操作现有的网格。本章将介绍如何首先创建网格。有几种方法可以做到这一点。例如，非结构化网格可以从文件中读取，还有一些方法可以直接从你的代码中设置结构化和非结构化网格。



DUNE的中心思想是，所有的网格实现都表现得一样，并且符合相同的接口。然而，当涉及到构造网格对象时，这个概念达到了极限，因为网格的实现方式差异太大，无法使一种构造方法适用于所有的对象。例如，建立一个非结构化的网格需要明确指定所有的顶点位置，而对于一个结构化的网格，这将是一种浪费。另一方面，构建结构化网格可能需要边界盒，而对于非结构化网格来说，这并不是必须的。因此，虽然有一个用于构建非结构化网格的官方接口（第$5.7.2)$章），但没有用于所有网格的接口。在实践中，这些差异并不构成严重的问题。

在本章中，创建一个网格总是指创建一个只有一个层次的网格。这样的网格也被称为 `level-0` 网格， `coarse grid` ，或者 `macro grid` 。目前DUNE中没有直接设置真正的`hierarchical grids`的功能。其基本假设是，用户将首先创建一个粗略的网格，然后使用细化技术生成一个层次结构。尽管名字是这样的（网格实现也是允许的），粗略的网格当然可以根据需要大而精。

为了避免误解，让我们指出，`dune-grid`并没有提供生成网格的方法。我们所说的生成网格是指从边界的描述中构建一个域的元素分区的过程。对于这项任务，有许多很好的实现，DUNE并不试图与它们竞争。在本章中，我们假设非结构化网格是由外部资源提供的，通常是以网格文件的形式。

本章首先介绍了如何构建结构化网格。这是最简单的任务，因为不涉及外部网格文件。接下来，$5.7.2$章介绍了`GridFactory`，这是一个较低级别的接口，可以直接在$\mathrm{C}++$代码中构建非结构化网格。它是实现替代文件阅读器的自然基础。最后，$5.7.3$章解释了如何从`GMSH`格式的文件中读取网格文件和相关数据。这是目前将非结构化网格加载到DUNE的主要方式。

\subsubsection{Creating Structured Grids}

创建统一结构网格相对简单，因为需要提供的信息很少。一般来说，对于统一结构网格，网格尺寸、边界盒和每个方向的元素数量就足够了。

在DUNE中，有两种方法来处理结构化网格：要么使用专门的结构化网格数据结构，如`YaspGrid`，要么使用非结构化网格管理器，如UGGrid，并将其设置为结构化网格。两者都是合理的做法。如果已知网格在整个计算过程中保持固定，那么第一种方式会产生一个节省时间和内存的网格实现。第二种方式可能是迈向自适应细化网格的第一步，非常有用。



在`dune-grid`中，`YaspGrid`类是结构化统一立方体网格的标准实现。所有的相关信息都直接交给它的一个构造函数。例如，要为域$\Omega=[0,1]^{2}$创建一个二维的`YaspGrid`，每个方向有10个元素，调用

~~~C++
FieldVector<double,2> upper = {1.0, 1.0};
std::array<int,2> elements = {10, 10};
YaspGrid<2> grid(upper, elements);
~~~

或者，更短。

~~~C++
YaspGrid<2> grid({1.0, 1.0}, {10, 10});
~~~


在这个例子中，左下角被硬连接到 `YaspGrid` 内的 $(0,0)$ 。为了更加灵活，`YaspGrid`可以用几个模板策略类来扩展。下面的代码为域 $[0.1,2.25] \times[-0.5,0.5] \subset \mathbb{R}^{2}$ 创建了一个网格。

~~~C++
FieldVector<double,dim> lower = {0.1, -0.5};
FieldVector<double,dim> upper = {2.25, 0.5};
std::array<int,dim> elements = {15, 10};
YaspGrid<dim, EquidistantOffsetCoordinates<double,dim> >
                                grid(lower, upper, elements);

~~~


设置`YaspGrid`对象的进一步方法在在线文档中描述。

`dune-grid`模块也有基础设施，可以使用非结构化网格的实现来设置结构化网格。`dune/grid/utility/`中的头文件`structuredgridfactory.hh`提供了类

~~~C++
template<class Grid>
class StructuredGridFactory
~~~


其唯一的接口包括两个静态方法

~~~C++
static std::unique_ptr<Grid>
        createCubeGrid( const FieldVector<ctype,dimworld>& lowerLeft,
                        const FieldVector<ctype,dimworld>& upperRight,
                        const std::array<unsigned int,dim>& elements)

~~~

和

~~~C++
static std::unique_ptr<Grid>
            createSimplexGrid(  const FieldVector<ctype,dimworld>& lowerLeft,
                                const FieldVector<ctype,dimworld>& upperRight,
                                const std::array<unsigned int,dim>& elements)

~~~


这两种方法都在两个向量`lowerLeft`和`upperRight`给出的边界框内创建结构化网格。数组元素的条目指定了每个坐标方向上的基本单元的数量。作为模板参数`Grid`给出的网格实现是用来存储网格的。第一种方法构建由超立方体组成的网格，而第二种方法将每个立方体分解为$d !:=d \cdot(d-1) \cdot \ldots \cdot 2 \cdot 1$个简单单元，使用`Coxeter-Freudenthal-Kuhn`三角法[^3]，因此，例如，线条


~~~C++
FieldVector<double,2> lowerLeft = {0.0, 1.0};
FieldVector<double,2> upperRight = {2.0, 2.0};
std::array<unsigned int,2> elements = {8, 17};
auto grid
    = StructuredGridFactory<AlbertaGrid<2> >::createSimplexGrid(lowerLeft,
                                                                upperRight,
                                                                elements);
~~~

为矩形域$\Omega=[0,2] \times$[1,2]创建一个被$8 \times 17 \times 2$三角形离散的二维`AlbertaGrid`对象。该代码

~~~C++
FieldVector<double,3> lowerLeft = {0.0, 0.0, 0.0};
FieldVector<double,3> upperRight = {1.0, 1.0, 1.0};
std::array<unsigned int,3> elements = {10, 10, 10};
auto grid
    = StructuredGridFactory<UGGrid<3> >::createCubeGrid(lowerLeft,
                                                        upperRight,
                                                        elements);
~~~

创建一个具有$10 \times 10 \times 10$六面体元素的单位立方体网格。在`StructuredGridFactory`中使用的算法适用于任何维度，并且只受限于可用的网格实现。

在内部，`StructuredGridFactory`类使用$5.7.2$章中描述的`GridFactory`类来实际创建网格；因此，`StructuredGridFactory`可以用于所有实现`GridFactory`接口的网格。此外，即使是结构化网格的实现，也有一些特殊化。例如，本节开头的`YaspGrid`例子可以替代性地写成

~~~C++
FieldVector<double,2> lowerLeft = {0.0, 0.0};
FieldVector<double,2> upperRight = {1.0, 1.0};
std::array<unsigned int,2> elements = {10, 10};
auto grid
      = StructuredGridFactory<YaspGrid<2> >::createCubeGrid(lowerLeft,
                                                            upperRight,
                                                            elements);

~~~


当需要在不同的网格实现之间频繁切换时，这可以使生活更容易。

\subsubsection{The Grid Construction Interface}

为了建立非结构化网格，有一个低级别的C++接口。这个接口的名字是`GridFactory`，它提供了一些方法，例如，一个一个地插入顶点和元素。它是DUNE提供的网格文件阅读器的基础，特别是下一节中描述的`GMSH`文件阅读器。在某些情况下，能够在$\mathrm{C}++$代码中完全指定一个粗大的网格也是很方便的。

`GridFactory`被编程为一个工厂类（因此而得名，参见[^72]）。工厂类的一个对象被输入了所有必要的信息，它将创建并交出一个网格。下面将首先演示使用`GridFactory`简单构建一个网格的必要步骤，然后解释一些额外的功能。如果输入的网格已经有了相关的数据，就会涉及一些微妙的编号问题。这些将在第 $5.7.2$ 章讨论。

\textbf{Setting up a Grid}

`GridFactory`接口存在于DUNE的所有非结构化网格。它被实现为一个类，以一个（分层的）网格类型作为模板参数。不同的网格实现对这个类进行了专业化处理。此外，每个`GridFactory`的专业化都继承自抽象的基类`GridFactoryInterface` 。基类主要是作为文档。[Tab5.15]中给出了它的公共方法列表。

假设有一个以某种方式给出的顶点和元素的列表，而目标是要从其中创建一个新的网格，例如，`AlbertaGrid`类型。第一步是创建一个`GridFactory`对象。  `GridFactory`对象是默认可构造的，但也可能有额外的构造函数。对于`AlbertaGrid`的例子，只要调用

~~~C++
GridFactory<AlbertaGrid> factory;
~~~

不需要为此包含额外的头文件--`GridFactory`对`AlbertaGrid`的特殊化包含在`AlbertaGrid`本身的头文件中。由此产生的工厂对象是空的。

现在可以在这个空的`GridFactory`对象中输入顶点位置。对于这一点，有一个方法

~~~C++
void insertVertex(const FieldVector<ctype,dimworld>& position)
~~~


类型`ctype`是网格用于坐标的数字类型，`dimworld`是其世界空间的尺寸。顶点的插入顺序不一定反映它们在`IndexSet`类中的索引，或者它们被迭代的顺序（见下文）。

一旦所有顶点都被插入，元素也可以被输入。对于每个元素，`GridFactory`方法

~~~C++
void insertElement(GeometryType type,
                    const std::vector<int>& vertices)
~~~

必须被调用。第一个参数是编码为`GeometryType`对象的元素类型（第5.5.2章）。如果遇到无法处理的元素类型，网格实现应该抛出一个异常。第二个参数是这个元素的顶点的索引集。数组的大小必须与类型参数所指定的多角体的顶点数量相匹配。顶点编号的顺序必须遵循[Fig5.12和[Fig5.13]中所示的DUNE参考元素顶点编号的惯例。顶点编号本身必须是指顶点插入到 `GridFactory` 的顺序。



现在工厂对象包含了一个简单的有限元网格所需的所有信息。为了完成网格对象的构造，有一个方法是

~~~C++
std::unique_ptr<Grid> createGrid()
~~~

这将在堆上创建网格对象，并将其所有权交给调用者。作为一个完整的例子，这里是构造 [Fig5.21] 的简单网格的代码。它使用了 `UGGrid` 的实现，因为它同时包含了三角形和四边形。

~~~C++

GridFactory<UGGrid<2> > factory;

factory.insertVertex({0, 0, 0});
factory.insertVertex({1, 0, 0});
factory.insertVertex({2, 0, 0});
factory.insertVertex({0, 0.5, 0});
factory.insertVertex({0, 1, 0});
factory.insertVertex({1, 1, 0});
factory.insertVertex({2, 1, 0});

factory.insertElement(GeometryTypes::simplex(2), {0, 1, 3});
factory.insertElement(GeometryTypes::simplex(2), {1, 5, 3});
factory.insertElement(GeometryTypes::simplex(2), {3, 5, 4});
factory.insertElement(GeometryTypes::cube(2), {1, 2, 6, 5});

std::unique_ptr<UGGrid<2> > grid = factory.createGrid();
// do something with grid
...
~~~

除了插入顶点和元素的方法外，还有一个可选的方法，允许明确地插入边界段。

~~~C++
void insertBoundarySegment(const std::vector<unsigned int>& vertices)
~~~

它可以为网格的部分或全部边界段被调用，但这样做对网格本身没有任何影响。相反，明确地插入边界段决定了这些段的枚举，以后可以通过`insertionIndex`方法（第5.7.2章）使用。这是将外部给定的数据附加到边界段的典型方法。如果边界段没有明确地给到`GridFactory`，网格实现本身就决定了它们的索引。

\textbf{Parametrized `Elements` and Domains}

还有两个可选的方法，允许向网格工厂提供额外的几何信息。让$T_{\text {ref }}$成为一个网格元素或一个边界段的参考元素。我们把任何从$T_{\text {ref }}$到世界空间$\mathbb{R}^{w}$的足够好的映射称为该元素或边界段的`parametrization`。



当领域几何的片状多项式近似的误差有问题时，参数化可以被网格细化所使用。例如，[Fig5.20]显示了一个八面体的网格，但它是为了近似一个椭圆体。椭圆体的确切形状是以八个粗略的网格边界段的参数形式给出的。随着网格的细化，新的边界顶点不是放在边缘中点上，而是利用边界参数的几何信息来确定它们的新位置。这样一来，越来越细的网格会越来越接近真实的几何形状。不是所有的DUNE网格都实现了这个功能。[Fig5.20]中的例子是用`UGGrid`构建的。

类似的机制也可以在元素参数化中实现。在关于[^140]网格管理器的文章`FoamGrid`中给出了一个例子。其他网格管理器可能会以不同的方式使用额外的几何信息。例如，实现高阶多项式元素形状的网格可以用它来设置元素的几何形状。

使用边界或元素参数化需要为每个边界段或元素实现一个对象，计算参数化图。然后，这些对象被移交给网格工厂。这是DUNE使用抽象基类的少数地方之一。边界参数化的实现必须派生自


~~~C++
template<int dim, int dimworld = dim, class ctype = double>
struct BoundarySegment
~~~


其中dim是参考元素的尺寸，`dimworld`是世界空间的尺寸，`ctype`是用于坐标的数字类型。这个抽象的基类规定了一个方法的重载

~~~C++
virtual FieldVector<ctype, dimworld>
        operator()(const FieldVector<ctype, dim-1>& local)
~~~


这个方法必须从参考元素上的局部坐标计算出世界坐标。对于每一个有参数化的边界段，必须通过调用这个类派生出的对象交给网格工厂。

~~~C++
void insertBoundarySegment
    (const std::vector<unsigned int>& vertices,
    const std::shared_ptr<BoundarySegment<dim,dimworld> >& boundarySegment)
~~~

此外，调用这个方法会影响边界段的编号，其方式与只有一个参数的`insertBoundarySegment`方法相同。对于支持参数化元素的网格，有这样的方法


~~~C++
void insertElement
    (const GeometryType& type,
    const std::vector<unsigned int>& vertices,
    const std::shared_ptr<VirtualFunction>& elementParametrization)
~~~

其中，`VirtualFunction`是以下内容的缩略语

~~~C++
VirtualFunction<FieldVector<ctype,dimension>, FieldVector<ctype,dimworld> >
~~~


该方法与第$5.7.2$章中描述的`insertElement`方法一样，但它允许将元素的参数化作为第三个参数提交。与边界参数化不同，元素参数化必须来自于

~~~C++
template<class Domain, class Range>
class VirtualFunction
~~~

定义于 `dune/common/function.hh` 。该类的后代必须实现方法

~~~C++
void evaluate(const Domain& x, Range& y) const
~~~

它在第二个参数中返回其结果。Lambdas和其他可调用程序需要通过调用

~~~C++
template<class F>
auto makeVirtualFunction(F&& f)
~~~


边界和元素参数之间的设计不一致是有历史原因的，可能会在以后的 `dune-grid` 版本中删除。

\textbf{Element and Vertex Numberings}

边界值问题的问题规格通常包括定义在域或域边界上的一些数据域。就像计算网格一样，这些数据域经常在文件中给出。它们可以包含在网格本身的文件中，也可以存在于明确或隐含地引用主网格文件的单独文件中。

在实践中，输入的网格数据通常以每个网格顶点、每个网格元素或每个边界段的数据集的形式给出。网格边界上的数据有时也以所有顶点或元素的数据集的形式给出，其中除了对域边界的限制外，其他的都被忽略了。数据与例如顶点的关联可以是隐性的，即数据和顶点以相应的顺序给出，也可以是显性的。在后一种情况下，每个数据字段都有一个索引，指定它属于哪个顶点或元素。

正如之前在第$5.6$章中所解释的，DUNE网格不能直接将数据附加到它们身上。相反，网格视图的每个实体都有一个数字（它的索引）附加在上面，这个索引被用来处理附加在该实体上的所有数据，这些数据存储在具有快速随机访问的容器中。为了将外部来源的数据附加到DUNE网格中，必须将网格实体的索引与输入数据放在一起。这是一个令人惊讶的困难问题。这种关系取决于顶点、元素以及可能的边界段被插入网格工厂的顺序。我们说一个顶点有`insertion index`$i, i=0,1,2, \ldots$，如果它是被插入网格工厂的$i^{th}$顶点的话（同样的定义对元素和边界段也适用）。使用网格工厂加载网格和可能的附加数据到DUNE网格工厂的代码，应该组织这些附加数据，以便按照插入顺序引用网格顶点和元素。

如果0级IndexSet的指数直接对应于插入指数，那么从DuNE内部访问这些数据就很容易。然而，由于两个原因，这是不可能的。首先，对于包含一个以上元素类型的网格，元素`insertion index`顾名思义是所有元素集合的一个连续的整数序列。而level-0指数则是对不同的元素类型分别进行计数（5.6.1章）。因此，两者不能重合。

第二个原因是潜在的速度损失。有人认为，对于一个给定的网格实现来说，顶点的排序是自然的，可能并不总是与顶点的插入顺序相吻合。因此，有必要对顶点进行重新编号，而这种说法继续下去，在建立网格的时候不能一劳永逸。每次访问0级顶点时，都必须重新计算，这可能太昂贵了。

由于这些原因，`GridFactory`类提供了三个方法，为顶点、元素和边界段提供`insertion index`。这些方法是：。

~~~C++
unsigned int insertionIndex(const Codim<0>::Entity& entity) const
unsigned int insertionIndex(const Codim<dim>::Entity& entity) const
unsigned int insertionIndex(const Grid::LeafIntersection& intersection) const
~~~



对于顶点和元素，这些指数总是存在的。如果没有明确给出边界段，相应的`insertionIndex`方法的行为是未定义的。

`insertionIndex`方法可以从调用`GridFactory::createGrid`开始使用，直到网格第一次被修改（因为网格修改允许改变0级索引，即使0级网格视图本身保持不变）。

为了使这个讨论不那么抽象，下面的例子展示了如何将输入的顶点和元素数据附加到DUNE网格中。这个例子假设一个网格刚刚被插入一个叫做`gridFactory`的网格工厂对象中，而且这个网格带有顶点和元素数据。输入的数据存储在两个容器 `inputVertexData` 和 `inputElementData` 中，这些数组中的数据是按照顶点和元素分别输入到网格工厂的顺序排列的。下面的代码对数据进行了重新排序，使其可以通过叶子网格索引集提供的索引进行索引。

~~~C++
using GridView = Grid::LeafGridView;
GridView gridView = grid.leafGridView();
// Reorder vertex data
duneVertexData.resize(inputVertexData.size());
for (const auto &vertex : vertices(gridView))
{
    auto inputIndex = gridFactory.insertionIndex(vertex);
    auto duneIndex = gridView.indexSet().index(vertex);
    duneVertexData[duneIndex] = inputVertexData[inputIndex];
}
// Reorder element data
MultipleCodimMultipleGeomTypeMapper<GridView>
    elementMapper(gridView, mcmgElementLayout());
duneElementData.resize(inputElementData.size());
for (const auto &element : elements(gridView))
{
    auto inputIndex = gridFactory.insertionIndex(element);
    auto duneIndex = elementMapper.index(element);
    duneElementData[duneIndex] = inputElementData[inputIndex];
}
~~~


执行这段代码后，数组`duneVertexData`和`duneElementData`包含了所需的输出。注意顶点数据是如何通过顶点索引直接访问的，但需要一个`MultipleCodimMultipleGeomTypeMapper`对象来从元素索引构建数组索引。如果已知网格只包含一个元素类型，那么这个额外的重定向就没有必要。

\subsubsection{Reading Unstructured Grids from Gmsh Files}

上一节的`GridFactory`接口构成了读取各种格式的网格和数据文件的代码的基础。DUNE提供了对其中一些格式的支持，但在DUNE中没有为网格文件阅读器提供接口规范。

可以说DUNE目前支持的最重要的文件格式是`GMSH`格式。  $\mathrm{GMSH}$是一个开源的几何建模器和网格发生器。它允许以交互方式或通过它自己的建模语言来定义几何体。从这样的几何体表示中，它创建了二维和三维空间的简单网格。元素的几何形状可以由五阶以下的多项式来描述。此外，`GMSH`能够导入CAD几何图形，例如从IGES或STEP文件中导入，并能为其生成网格。生成的网格可以以本地文件格式存储，文件名通常以.msh结尾。这些文件是ASCII文本，可以用文本编辑器进行检查。该格式在 `GMSH` 手册 [^74] 中有描述。除了网格之外，`GMSH`文件还可以包含元素和边界段的子域划分。

读取`GMSH`文件到`dune-grid`是由类来完成的。

~~~C++
template<class Grid>
class GmshReader
~~~

在头文件 `dune/grid/io/file/gmshreader.hh` 中。公共接口由三个静态方法组成，所有这些方法都被称为 `read` ，并且都会读取 `.msh` 文件。最基本的方法是加载网格，但不考虑任何分区数据。它的签名是

~~~C++
static std::unique_ptr<Grid> read( const std::string& fileName,
                                   bool verbose=true,
                                   bool insertBoundarySegments=true)
~~~


fileName中给出的文件被解释为一个`.msh`文件，并从它中构造出一个新的`Grid`类型的网格对象。内存管理的责任被移交给了调用者。因此，从一个`GMSH`文件中读取网格的最简单方法是

~~~C++
std::unique_ptr<FooGrid> grid = GmshReader<FooGrid>::read(filename);
[...] // Code that uses the grid
~~~



第三个参数控制`GmshReader`是否读取文件中可能存在的边界段信息。当从文件中读取$d$维网格时，除了$d$维元素外，该文件还可能包含$d-1$维元素。这些低维元素被解释为边界段。当`insertBoundarySegment`s被设置为false时，文件中的边界段被简单地忽略了。如果它们没有被忽略，`GmshReader`将使用内部使用的网格工厂的`insertBoundarySegment`方法明确地将边界段插入网格中。明确插入边界段有三个后果。

- 它设置边界段的插入索引。

- 它允许读取与边界段相关的边界条件标签（见下文）。

- 它允许读取更高阶的边界段几何图形。  `GMSH`部分支持五阶以下的多项式元素。高阶边界表示被作为边界段参数交给网格工厂，以用于 $5.7.2$ 章节中的描述。

读取方法有一个孪生子，使用一个从外面给的网格工厂。

~~~C++
static void read(GridFactory<Grid>& factory,
                const std::string& fileName,
                bool verbose = true,
                bool insertBoundarySegments=true)
~~~

与之前的方法相比，其优点是双重的。一方面，它允许使用具有非标准构造函数的网格工厂，或者在实际插入网格之前需要额外的设置代码。另一方面，在调用读取完成后拥有网格工厂对象，对于调用工厂的`insertionIndex`方法是必要的。这又是需要加载与输入网格相关的额外数据。

读取方法的第三个变种是从网格文件中提取额外的信息。  `GMSH`文件可以为每个元素包含通用的整数值。这些整数被`GMSH`使用，通过给元素分配相应的子域编号，将其归入子域。在`GMSH`术语中，这些数字被称为`physical entity`数字。类似地，整数号码可以附加到边界段。这些可以用来在边界的不同部分指定不同类型的边界条件。`GmshReader`允许将这些信息读入数组。相应的读取方法是

~~~C++
static void read(GridFactory<Grid>& factory,
                const std::string& fileName,
                std::vector<int>& boundarySegmentToPhysicalEntity,
                std::vector<int>& elementToPhysicalEntity,
                bool verbose = true,
                bool insertBoundarySegments=true)
~~~


这个签名中的新内容是两个数组 `boundarySegmentToPhysicalEntity` 和 `elementToPhysicalEntity` 。在成功调用该方法后，它们将分别包含文件中与边界段和元素相关的整数值。编号是边界段和元素的插入索引。这些又是由文件中的边界段和元素的顺序决定的，而不是由文件中给出的明确编号决定的。

为了说明这一点，这里有一个简短的 `GMSH` 示例文件。  [Fig5.21]显示了文件在`GMSH`中打开时的样子。

~~~C++
 $MeshFormat
 2.1 0 8
 $EndMeshFormat

 $Nodes
 7
 1 0 0 0
 2 1 0 0
 3 2 0 0
 4 0 0.5 0
 5 0 1 0
 6 1 1 0
 7 2 1 0
 $EndNodes

 $Elements
 11
 1 2 1 0 1 2 4
 2 2 1 0 2 6 4
 3 2 1 0 4 6 5
 4 3 1 1 2 3 7 6

 5 1 1 1 1 2
 6 1 1 1 2 3
 7 1 1 1 3 7
 8 1 1 1 7 6
 9 1 1 1 6 5
 10 1 1 1 5 4
 11 1 1 1 4 1
 $EndElements
~~~



其中大部分是不言自明的，只有`Elements`部分需要讨论一下。该部分的前四行是网格中的三个三角形和一个四边形，其余七行是七个边界段。

在每一行中，第一个数字是一个流水号，第二个数字是元素的类型（2代表三角形，3代表四边形，1代表线段）。在一个三角形的行中，最后三个数字是顶点数字。相应地，在一个四边形的线条中，最后四个数字是顶点。这解释了`Elements`部分的所有数字，除了第三和第四列的数字。这两列描述了附着在元素上的整数数据。第一个数字只是说还有多少个数据成员要来。在这个文件中，这个数字只是 $1$ 。`GMSH` 文件格式允许这里有更多的数字，但DUNE `GMSH` 阅读器目前只读取第一个数字。下面的数字（第四列中的数字）是实际的整数数据。这是将被读入数组 `elementToPhysicalEntity` 和 `boundarySegmentToPhysicalEntity` 的数字。

\subsection{Writing Grids and Data to VTK Files}

由有限元代码产生的模拟数据需要进行后处理才能使用。DUNE本身并不提供任何后处理设施。就像在网格生成的情况下，DUNE团队认为其他人在数据后处理方面做得比DUNE好得多。因此，DUNE并不试图去竞争，而是简单地将模拟数据写入文件。后期处理和数据可视化必须由能够读取文件的其他程序来完成。

虽然DUNE支持以多种格式写入网格和网格数据，但我们在这里只关注VTK文件，因为它们是最相关的。VTK格式是VTK工具包[^143]，以及`PARAVIEW`可视化软件的本地格式。该格式已被公开记录 [^107] 。它是基于 `eXtensible Markup Language ` (XML)，可以容纳二进制和ASCII数据。该格式可以容纳一般的非结构化网格，但它也有针对各种拓扑结构甚至是统一立方体网格的特殊表示方法。非结构化网格可以混合元素类型，如四面体和六面体，以及棱镜和金字塔等不明显的元素。甚至某些二阶元素的几何形状也是可能的。

几乎所有这些功能都可以通过使用模块 `dune-vtk` 从DUNE读写。25 同时，`dune-grid`模块提供了对以VTK格式写入网格的部分支持，并将顶点和元素数据添加到文件中。本章将对这种支持进行解释。第$5.8.1$节将展示如何写入顶点和元素数据，而第$5.8.2$节则涉及时间相关的数据。处理网格函数在第 $10.7$ 章中介绍。

\subsubsection{Writing Grids and Data}

DUNE的VTK写入功能是在一个类中实现的 `VTKWriter` ，位于头文件 `dune/grid/io/file/vtk/vtkwriter.hh` 中。该方法的公共接口很短，可以在[Tab5.16]中找到。

类 `VTKWriter` 需要一个模板参数，它必须是一个 `GridView` 。

~~~C++
template<class GridView>
class VTKWriter
~~~

一个VTK文件正好包含一个（非层次的）网格，因此一个`VTKWriter`对象正好存储一个`GridView`类型的对象。此外，一个VTK文件可以包含在这个网格上定义的任意数量的数据集。每个数据集要么与网格顶点相关，要么与网格元素（VTK称之为 "单元"）相关。数据集使用专门的方法传递给`VTKWriter`对象。最后，当一个特定的方法被调用时，网格和数据集被写入一个文件中。

`VTKWriter`类只有一个构造函数。它的签名是

~~~C++
VTKWriter(const GridView& gridView,
            VTK::DataMode dm = VTK::conforming,
            VTK::Precision precision = VTK::Precision::float32)
~~~



第一个参数是要写入VTK文件的网格视图。第二个参数提供了对跨元素边界不连续的数据字段的支持。默认情况下，（即当dm被设置为`VTK::conforming`时），VTK文件中的相邻元素共享共同的顶点。由于VTK只允许一个顶点上有一个自由度，因此片状线性场必然是连续的。要获得不连续的场，可将dm设为`VTK::nonconforming` 。在这种情况下，每个顶点对每个相邻元素都有一个副本，每个元素都有自己的顶点集。这个技巧允许在 "同一 "顶点上有多个自由度（每个元素一个），代价是增加了输出文件的大小。最后，参数精度允许设置VTK文件中用于数值的数据类型。最重要的选择是`VTK::Precision::float32`和`VTK::Precision::float64`，但也有一些其他选择。

一旦`VTKWriter`对象被设置好，它可以通过几个不同的方法来接收数据。其中前两个是添加元素和顶点数据。

~~~C++
template<class Container>
void addCellData(const Container& v, const std::string& name, int ncomps=1)

template<class Container>
void addVertexData(const Container& v, const std::string& name, int ncomps=1)
~~~



这两个方法都需要一个容器$\mathrm{v}$，它必须包含创建`VTKWriter`对象的网格视图的单元（即元素）或顶点数值。容器类型可以是任意的，只要它通过实现 `operator []` 支持随机访问。例如，`std::vector`就可以，第7章中`dune-istl`模块的向量数据类型也可以。`VTKWriter`的实现是通过使用`MultipleCodimMultipleGeomTypeMapper`类首先计算一个索引来访问一个给定顶点或元素的数据值。然后，该索引被用来调用容器 $\mathrm{v}$ 的 `operator []` 。请注意，构造函数的`DataMode`参数在这里被忽略了--如果它被设置为`VTK::nonconforming`，输出仍然是符合要求的。要真正得到不连续的输出需要一个函数作为数据，见第 $10.7$ 章。

两个方法的第二个参数`name`允许将一个任意的字符串与每个数据集相关联，该字符串存储在VTK文件中。  例如，`PARAVIEW`，在其用户界面上使用这个字符串来标记数据集。

最后，参数`ncomps`允许写入多成分数据。默认情况下，`ncomps`被设置为1，标量数据域被写入。如果`ncomps`被设置为较大的值$m$，那么容器$\mathrm{v}$中的每一组$m$值都被解释为一个单元或一个顶点的矢量数据。因此，输入容器$\mathrm{v}$的长度必须是标量数据的$m$倍。输出以`PARAVIEW`的形式出现在$m$独立标量场中。编写实际的VTK矢量字段只有在编写函数时才能实现（第10.7章）。


当所有的数据字段都被添加到`VTKWriter`对象中，输出文件可以通过以下方法写入

~~~C++
std::string write(const std::string& name,
            VTK::OutputType type = VTK::ascii)
~~~


第一个参数是文件名。目前，所有数据都被写成非结构化数据（VTK术语中的`UnstructuredGrid`），因此后缀`.vtu`被附加到名称中的字符串，以获得实际的文件名。一维网格被写成 `PolyData` 并得到后缀 `.vtp` 。方法`write`的返回值是带有后缀的完整文件名。第二个参数决定了数据在文件中的存储方式。目前有四个选项。

- `VTK::ascii` : 所有的数字数据都被写成ASCII，因此文件是完全可被人类阅读的。这对调试很有帮助；但是，写ASCII数据会导致文件很大，而且浮点精度可能会因为截断而丢失。

- `VTK::appendedraw` : 数据以原始二进制形式写入，二进制数据没有写入正确的XML位置，而是附加在XML文本之后。这导致了紧凑的文件，而且不损失精度。然而，这种文件只能在具有相同字节顺序的机器之间移动 [^160] 。

- `VTK::base64` , `VTK::appendedbase64` : 这两个选项使用base64编码[^102]，这是在文件大小和可移植性之间的妥协。数据要么被插入到XML段中（`VTK::base64)`），要么被附加到文件的最后（`VTK::appendedbase64`）。

当为分布式网格调用`write`方法时，其行为会有一些变化。然后文件名的前缀是`s\#\#\#\#-p#\#\#\#-` ，其中第一组`\#\#\#\#`编码的是进程总数，第二组是本地写入进程的等级。对于额外的控制，还有另一种方法`pwrite`（用于："路径写入"），允许更多的控制结果文件的放置位置。详见第$6.6$章。

\subsubsection{Writing Time-Dependent Data}

到目前为止，只有一个固定的网格，以及这个网格上的数据字段。演化问题的模拟输出是由与某些时间点相关的网格和数据域序列组成的。虽然网格在所有的时间点上都可能保持不变，但由于网格的适应性，它也可能发生变化。

在有限的意义上，即使没有进一步的基础设施，也可以对随时间变化的数据进行后处理。如果一连串的数据集被写进文件，文件名由一个共同的前缀和连续的数字组成

~~~C++
my_data_file_0000.vtu
my_data_file_0001.vtu
my_data_file_0002.vtu
...
~~~



那么`PARAVIEW`可视化软件的文件打开对话框将把整个序列解释为一个时间序列的数据，并将其加载到一个单一的数据对象。所有`PARAVIEW`随时间变化的数据的功能都可以用于这个对象；例如，可以通过拖动`PARAVIEW`GUI中的 "时间 "滑块来选择单个文件，只需点击几下就可以创建动画。

这种处理随时间变化的数据的方法简单方便，但只有在数据与均匀分布的时间点相关联时才有效。然而，对于执行自适应时间步进的模拟算法，精确的时间点必须记录在文件中，以便可视化和后处理软件能够使用它。

`dune-grid`模块提供了`VTKSequenceWriter`类，用于写入网格序列和相关时间点的数据（来自文件`dune/grid/io/file/vtk/ vtksequencewriter.hh` ）。它已经在第3.4章的有限体积例子中使用过了。`VTKSequenceWriter`类就像单独调用`VTKWriter`类一样写出各个数据集（文件名在最后有整数）。此外，它还会写一个`sequence file`，文件扩展名为`.pvd`，其中包含所有数据文件名和相应的时间点。如果网格在MPI并行设置中分布在几个进程中，那么只有等级0会写入序列文件。当把这个序列文件读入`PARAVIEW`时，它将自动读取所有相关的数据文件，并将给定的时间点与它们联系起来。

要写一个时间序列的数据，首先创建一个`VTKWriter`对象，该对象具有定义数据的网格视图。这个`VTKWriter`对象将写入数据文件，因此在构造函数中对数据模式的选择将被尊重。然后，创建一个`VTKSequenceWriter`对象。有两个构造函数

~~~C++
VTKSequenceWriter(std::shared_ptr<VTKWriter<GridView> > vtkWriter,
                const std::string& name)
~~~

和

~~~C++
VTKSequenceWriter(std::shared_ptr<VTKWriter<GridView> > vtkWriter,
                  const std::string& name,
                  const std::string& path,
                  const std::string& extendpath)
~~~


对应于`VTKWriter`类的write和pwrite方法。任何一个构造函数都会收到`VTKWriter`对象，它将进行单个数据文件的写入。两个构造函数都有一个字符串参数name，这是用于所有时间步长文件和序列文件的字符串前缀。例如，如果名字的前缀是`my_series`，那么序列文件将是

~~~C++
my_series.pvd
~~~

而各个时间步骤将是

~~~Shell
my_series-00000.vtu
my_series-00001.vtu
my_series-00002.vtu
...
~~~

(如果网格是一维的，那么文件扩展名将是`.vtp`而不是`.vtu`) 。

下一步，在VTKWriter中注册所有的数据字段或第一个时间步骤的离散函数。这就像上一节中描述的那样。要写一个数据集，调用方法

~~~C++
void write(double time, VTK::OutputType type = VTK::ascii)
~~~

的`VTKSequenceWriter`对象。对这个方法的调用做了两件事。首先，它调用 `pwrite` 对象的 write 方法（或 `pwrite` ，取决于使用了哪个构造函数）。这将把网格和所有当前注册的数据集写到一个VTK文件中。文件名是在`VTKSequenceWriter`构造函数的name参数中给出的，同时还有一个整数。参数`type`的作用与写入单个数据集时相同。其次，对`VTKSequenceWriter`对象的写入方法的调用会在序列文件中添加一行。当数据在一个时间步长和下一个时间步长之间发生变化时，没有必要明确地通知`VTKWriter`和`VTKSequenceWriter`类。`VTKWriter`对象存储了对数据容器的引用，因此它将始终写出它们的当前内容。对于一个完整的例子，请看第 $3.4$ 章中的有限体积代码。

\subsection{Local Grid Adaptivity}

`dune-grid`模块的优势之一是支持各种不同的局部网格适应性机制。第$2.3$章已经解释了自适应网格细化的工作原理；这里我们展示了如何用DUNE网格接口实现它。

局部网格适应性有时会被回避，因为它可能很难编程。事实上，让三维网格的红绿细化可靠地工作是一个挑战，特别是如果代码要在并行计算机上运行。幸运的是，`dune-grid`在这里完成了所有的繁重工作。它已经包含了几个网格的实现，提供了各种形式的自适应网格细化，这些都是通过抽象接口控制的。例如，`AlbertaGrid` 网格管理器可以对简单x网格进行边缘分割细化（ [Fig2.13] ）。  `UGGrid`实现了二维和三维空间的红色和红色-绿色细化，适用于包含一个以上元素类型的网格，甚至在分布式机器上。`ALUGrid` 网格管理器，作为一个单独的DUNE模块，也可以进行二分法和不符合要求的红色细化 [^2] 。顶点的重新定位（ `r-refinement` [^95] ）可以使用 `GeometryGrid` 元网格应用于所有网格。在未来，进一步的DUNE网格数据结构可能实现更多的适应性策略。

要统一所有这些不同的方法来对网格进行局部调整，并通过一个精确而具体的接口使其可用是很困难的。一个太详细的接口将使大多数网格无法完全实现，但一个太模糊的接口又不能提供足够的控制。DUNE提供了一个折中方案。适应性接口中对所有网格来说都是成文的、强制性的部分是相当模糊的，网格管理员有很大的自由来解释修改请求。为了获得更具体的适应性功能，大多数实现了某种形式的本地适应性的网格管理程序提供了某些非接口方法来控制细化行为。例如，虽然所有的网格都有标记元素进行细化的方法，但`UGGrid`对某些各向异性的细化规则有额外的元素标记方法（见[Fig5.25] ）。由于这些方法不是官方接口的一部分，它们可以为每个网格实现量身定做，并允许访问非常具体的功能。缺点是，使用这些功能的用户需要注意，当他们使用这些功能时，不能简单地把他们的网格实现换成另一种。

在这一章中，我们重点讨论所有网格通用的一般接口。在第5.10章中介绍一些网格的实现时，会讨论一些特定的实现特性。对于完整的功能列表，最好是查阅网格类的在线文档。

\subsubsection{Local Grid Adaptivity Without Data Transfer}

在DUNE中，局部网格适应性有两个难度。如果没有数据附着在网格上，局部网格适应性实际上只意味着将网格结构调整到自己喜欢的程度。这就是本节中所描述的内容。更具挑战性的任务是如何在修改网格的同时保留基于网格的数据，这一点将在之后讨论。

DUNE中的自适应网格修改是一个两步程序。首先，叶子网格元素的一个子集被标记为细化或粗化。然后，对方法的调用

~~~C++
bool adapt()
~~~



的网格会自动进行整个网格的重组。这取决于网格的实现来解释细化和粗化的标记。例如，同样的代码会用`AlbertaGrid`进行边缘分割细化，用`UGGrid`进行红绿细化。结构化网格可以决定在遇到单个细化标记时对整个网格进行细化，也可以决定不做任何事情。如果网格发生了任何变化，适应方法会返回`true`，否则会返回`false`。

元素被标记为细化或粗化，通过调用方法

~~~C++
bool mark(int refCount, const Codim<0>::Entity& element)
~~~

上的分层网格对象。两个参数中的第二个是要标记的叶子元素。第一个是一个整数，指定要求的修改种类。它是应该应用于该元素的细分的数量。因此，值为1意味着`refinement`，而值为$-1$意味着`coarsening`。值为0意味着不对该元素做任何事情。大多数网格最多只能实现这三个值。

如果标记成功，方法mark返回`true`。这使得网格实现可以提前发出信号，表明某些标记操作是不允许的。每个元素的当前标记状态可以通过调用方法

~~~C++
int getMark (const Codim<0>::Entity& element) const
~~~

再一次在网格上，返回1，0，或-1中的一个。例如，下面的代码片段细化了所有预先计算的指标超过10值的元素，并粗化了那些指标低于0.1的元素。

~~~C++
MultipleCodimMultipleGeomTypeMapper<GridView> mapper(gridView,
                                                     mcmgElementLayout());
for (const auto& element : elements(gridView))
{
    auto idx = mapper.index(element); // Get element index

    if (indicator[idx] < 0.1)
        grid.mark(-1, element); // Mark for coarsening
    else if (indicator[idx] > 10)
        grid.mark(1, element); // Mark for refinement
}

grid.preAdapt();
grid.adapt(); // Actual grid modification happens here
grid.postAdapt();
~~~

请注意我们是如何使用`MultipleCodimMultipleGeomTypeMapper`来为每个元素获得唯一的索引的，因为如果网格中存在多个元素类型，`IndexSet`接口提供的元素索引是不唯一的。如前所述，`preAdapt`和`postAdapt`是网格接口需要的。它们在这里没有实际作用，将在第 $5.9.2$ 章中解释。

虽然这个简短的例子几乎展示了所有关于网格自适应的知识，但我们还是用一个更大的、完整的例子来跟进。这个更大的例子产生了[Fig5.22]中所示的网格，它应该允许在没有太多准备的情况下发挥DUNE适应性的力量。完整的源代码可以在附录中找到（附录B.4），如果以电子形式阅读此文，也可以点击文本边缘的图标。

请考虑以下情况。给定一个半径为1的球体在尺寸为$6 \times 15$单位的矩形域中缓慢向上移动，我们希望网格在圆周附近的分辨率高，而在远离圆周的地方分辨率低。由于球体在移动，这意味着网格的某些部分必须被细化，只是在球体继续移动后再被粗化。

程序代码首先定义了一个辅助类 `Sphere` 。这个类的唯一目的是计算点到一个给定半径和中心的球体的距离。我们立即实现一个任意尺寸的球体。这样一来，用三维网格来尝试这个程序就变得更容易了。

~~~C++
template <int dim>
class Sphere
{
    double radius_;
    FieldVector<double, dim> center_;

public:
    Sphere(const FieldVector<double, dim> &center, const double &radius)
        : radius_(radius),
          center_(center)
    {
    }

    double distanceTo(const FieldVector<double, dim> &point) const
    {
        return std::abs((center_ - point).two_norm() - radius_);
    }

    void displace(const FieldVector<double, dim> &increment)
    {
        center_ += increment;
    }
};

~~~


然后是`main`方法。它很短，只有一百多行代码，包括空白行和注释。我们把它分成几个部分，并逐一讨论这些部分。第一部分是启动MPI，如果它被安装的话。然后，使用`UGGrid`网格管理器构建一个结构化的二维单纯网格。注意我们是如何使用第`StructuredGridFactory`章中的$5.7.1$实用类来创建这样一个网格的。

~~~C++
int main(int argc, char *argv[])
{
    // Set up MPI if available
    MPIHelper::instance(argc, argv);

    constexpr int dim = 2; // Grid and world dimension
    using Grid = UGGrid<dim>;

    // Start with a structured grid
    const std::array<unsigned, dim> n = {8, 25};

    const FieldVector<double, dim> lower = {0, 0};
    const FieldVector<double, dim> upper = {6, 15};

    std::shared_ptr<Grid> grid = StructuredGridFactory<Grid>::createSimplexGrid(lower, upper, n);

    using GridView = Grid::LeafGridView;
    const GridView gridView = grid->leafGridView();

~~~

下一个程序块构建一个中心为$(3,2.5)$、半径为$1.0$的球体，并设置各种参数，如时间步数。


~~~C++
Sphere<dim> sphere({3.0, 2.5}, 1.0);

// Set parameters
const int steps = 30; // Total number of steps
const FieldVector<double, dim>
    stepDisplacement = {0, 0.5}; // Sphere displacement per step

const double epsilon = 0.4; // Thickness of the refined region
// around the sphere
const int levels = 3; // Number of refinement levels

~~~



然后是30个时间步长的主循环。首先，在第$82-90$行中，代码粗化了以前迭代留下的任何细化元素。然后，第93-103行的循环进行实际细化。任何中心在球体epsilon内的元素都被标记为细化。然后，调用adapt来进行实际的网格细化。整个过程重复1次，以获得最多级数的元素细化树。

~~~C++
for (int i = 0; i < steps; ++i)
{
    std::cout << "Step " << i << std::endl;

    // Coarsen everything
    for (int k = 0; k < levels - 1; ++k)
    {
        for (const auto &element : elements(gridView))
            grid->mark(-1, element);

        grid->preAdapt();
        grid->adapt();
        grid->postAdapt();
    }

    // Refine near the sphere
    for (int k = 0; k < levels - 1; ++k)
    {
        // Select elements that are close to the sphere for grid refinement
        for (const auto &element : elements(gridView))
            if (sphere.distanceTo(element.geometry().center()) < epsilon)
                grid->mark(1, element);

        grid->preAdapt();
        grid->adapt();
        grid->postAdapt();
    }

~~~


最后，网格被写入一个VTK文件，球体被移动。第113行的结束括号标志着主循环的结束。

~~~C++
VTKWriter<GridView> vtkWriter(gridView);
vtkWriter.write("refined_grid_" + std::to_string(i));

// Move sphere
sphere.displace(stepDisplacement);
}

~~~


这个例子到此结束。请参考第$5.10$章中关于不同网格管理器的文字，以了解如何修改代码，使其使用不符合要求的或二段式细化。

\subsubsection{Preserving Data Across Grid Changes}

当有数据附着在网格上时，本地网格的适应性变得更加具有挑战性。通常，这些数据中至少有一部分是不会被丢弃的，而是必须在网格变化时尽可能地保留下来。例如，一个离散的函数可能存在于旧的网格上，并且应该被用作新网格上迭代求解器的初始迭代。

当然，这样的离散函数不可能被完美地保留下来。由于网格的变化，相应的离散函数空间也随之变化。因此，一般来说，旧的函数不能在新的网格上得到准确的表示。粗略地说，只要元素被移除，信息就会丢失。如果相应的有限元空间是嵌套的，元素的细化不会导致信息损失，但新的自由度必须由已知自由度的适当插值来确定。

当数值数据被存储在网格元素和顶点本身的数据结构中时，实现这一点是相当容易的。然而，DUNE将网格和数值数据严格分开，它们之间的唯一联系是通过第5.6章中描述的`index`和`id`数字：对于固定网格视图上的计算，每个实体提供一个`index` ，即一个非负整数，可以用来寻址包含数值数据的数组数据类型。然而，当网格被局部修改时，这些指数就会发生相应的变化。一般来说，不可能修改实体集并保留现有的枚举。为了在网格修改时保留数据，DUNE网格接口另外提供了持久的实体编号，即所谓的`ids`（5.6.3章）。Ids既不需要是正数，也不需要是连续的，但它们提供了足够的功能，可以作为关联容器中的键，如`std::map`或`std::unordered_map` [^103] 。我们的想法是在改变网格之前将数字数据归档到这样的关联容器中，之后一旦有了新的索引，就从那里复制到新的数组中。当然在`std::map`中的数据存储要比使用数组慢得多。然而，预计实际修改网格所需的时间会主导将数据复制到 `std::map` 的时间。

为了说明这在实践中是如何工作的，我们扩展了前面的例子。同样，我们按照一个移动的圆实现网格细化。然而，另外，通过在开始时内插一个给定的闭合函数来设置一个离散函数，然后这个离散函数从每个网格转移到下一个网格。为了简单起见，使用了一阶`Lagrangian`有限元空间。结果显示在[Fig5.23]中，它对应于[Fig5.22]，但现在使用高度场来可视化函数值。可以看出，在每个时间步长，网格上定义的函数是完全相同的。没有任何细节损失，因为在这个例子中，初始插值发生在最粗的网格层上。

像往常一样，完整的源代码包含在一个文件中。它被列在附录B.5中，也可以通过文本边缘的图标获得。该代码与之前的代码非常相似；特别是，它重复使用了`Sphere`类，因此这里不再打印。几乎所有的代码都被放在main方法中。除了`Sphere`类之外，唯一的例外是一个小的辅助函数，用于对单线上的标量值进行线性插值。

~~~C++
 template<int dim>
 double interpolate(const std::vector<double> values,
                    FieldVector<double,dim> p)
 {
    assert(values.size() == dim+1);
    double result = values[0];
    for (std::size_t i=0; i<p.size(); i++)
       result += p[i]*(values[i+1]-values[0]);
    return result;
 }

~~~



它用于通过在更粗的网格元素上的顶点值之间插值来计算新顶点的函数值。在生产代码中，像`dune-localfunctions`模块（第8章）中的形状函数实现将被用于此，但这里直接实现了插值，以保持代码的自洽。

`main`方法的结构很像前面例子的主方法。特别是它的开头部分，设置了MPI，并使用`UGGrid`网格管理器构建了一个结构化的三角形网格。

~~~C++
50 int main(int argc, char *argv[])
51 {
52 // Set up MPI if available
53 MPIHelper::instance(argc, argv);
54
55 constexpr int dim = 2; // Grid dimension
56 using Grid = UGGrid<dim>;
57
58 // Create UGGrid from structured triangle grid
59 const std::array<unsigned, dim> n = {8, 25};
60
61 const FieldVector<double, dim> lower = {0, 0};
62 const FieldVector<double, dim> upper = {6, 15};
63
64 std::shared_ptr<Grid> grid
65      = StructuredGridFactory<Grid>::createSimplexGrid(lower, upper, n);
66
67 using GridView = Grid::LeafGridView;
68 const GridView gridView = grid->leafGridView();
69 const auto& indexSet = gridView.indexSet();
70 const auto& idSet = grid->localIdSet();
~~~





然而，请注意，与之前的例子不同，代码要求网格在行`IndexSet`和本地`IdSet`。索引集将被用来寻址存放数据的数组（这里：一个`std::vector`）。id将用于索引`std::map`，它将在网格被改变时保存数据。

接下来的几行设置了一些参数，如时间步数、球体半径等等。这一部分是对第175页上一个例子的逐字复制。

~~~C++
75 Sphere<dim> sphere({3.0, 2.5}, 1.0);
76
77 // Set parameters
78 const int steps = 30;
79 const FieldVector<double, dim> stepDisplacement = {0, 0.5};
80
81 const double epsilon = 0.4; // Thickness of the refined region
82 // around the sphere
83 const int levels = 2;

~~~



更有趣的是，该代码随后设置并插值了例子中的网格函数。

~~~C++
88 auto dataFunction = [](const FieldVector<double,dim>& x)
89 {
90      return std::sin(x[1]);
91 };
92
93 std::vector<double> data(gridView.size(dim));
94 for (auto&& v : vertices(gridView))
95      data[indexSet.index(v)] = dataFunction(v.geometry().corner(0));

~~~



从第88行开始的赋值是将函数

$$
\left(x_{0}, \ldots, x_{d-1}\right) \mapsto \sin \left(x_{1}\right)
$$

作为一个C $++$ lambda。然后第$94-95$行在叶子网格视图的所有顶点上循环，在这些顶点上评估该函数，并将值存储在`data`数组中。注意`indexSet`对象是如何被用来访问与顶点相关的数据的。

在这一点上，一切都准备好了，我们可以进入主循环。如同在没有数据传输的例子中，每个时间步骤由两个子步骤组成。首先，所有的精炼元素被移除。然后，网格在新位置的球体附近再次被细化，球体被移动。下面的代码做了粗化处理。

~~~C++
99 for (int i = 0; i < steps; ++i)
100 {
101     std::map<Grid::LocalIdSet::IdType, double> persistentContainer;
102
103     // Coarsen everything
104     for (int j = 0; j<levels; ++j)
105     {
106     for (const auto& element : elements(gridView))
107         grid->mark(-1, element); // Mark element for coarsening
108
109     grid->preAdapt();
110
111     for (const auto& vertex : vertices(gridView))
112         persistentContainer[idSet.id(vertex)] = data[indexSet.index(vertex)];
113
114     grid->adapt();
115
116     data.resize(gridView.size(dim));
117
118     for (const auto& v : vertices(gridView))
119         data[indexSet.index(v)] = persistentContainer[idSet.id(v)];
120
121     grid->postAdapt();
122 }
~~~



在这个循环中，出现了在没有数据传输的例子中已经使用过的对标记和适应的相同调用，但另外，离散函数被处理。请记住，它的系数被存储在名为`data`的数组中。为了在网格被修改时保持该函数，代码另外创建了一个`std::map`，它可以保存`double`的值，并以网格的局部`IdType`为索引。该地图被称为`persistentContainer`，因为它在网格变化中持续存在。在第114行实际从网格层次结构中移除一个层次之前，所有的顶点数据都被从该层次复制到持久化容器中（第111-112行）。然后，在第114行，网格被修改，数据被复制回数据阵列中。在$j$的循环结束后，剩下的是一个单层网格，以及附加在顶点上的原始函数的点值。

在这个学术例子中，我们事先知道我们要删除除最粗的网格层之外的所有网格。因此没有必要为每个级别分别来回复制数据。然而，在实际模拟中，决定是否删除某一层的元素是基于该层的数据，为此，需要将其复制到一个数组中。第11.5.2章显示了一个使用实际误差估计器的适应性例子。

为了组织数据传输，代码必须在网格对象上再使用两个方法。这个方法是

~~~C++
bool preAdapt()
~~~


需要在元素被标记之后，在调用适应之前被调用。它设置元素的mightVanish标志。这些标志，可以通过方法

~~~C++
bool mightVanish()
~~~

如果该元素在下一次调用 `adapt` 的过程中可能消失，则返回 `true` 。如果该方法返回 `false` ，那么相应的元素将被保证留下，其数据不必被投射到更粗的层面。本例中没有使用该方法。如果在随后调用 `adapt` 的过程中，没有叶子元素会从分层网格中移除，那么 `preAdapt` 方法会返回 `false` 。

对适应的调用设置了`isNew`标志。这些可以通过以下方法访问

~~~C++
bool isNew()
~~~


的`Entity<0>` 。它在下文中只用于将数据插值到那些新创建的元素上。

该方法
~~~C++
void postAdapt()
~~~


将在网格被调整和数据被处理后被调用。它删除了最后一次调用适应的元素的isNew标志。`dune-grid`接口规范要求`preAdapt`和`postAdapt`方法与`adapt`同时被调用，即使没有数据被传输。这就是为什么它们也出现在上一节的例子中。

在粗化之后，网格围绕着球体被细化（球体在时间循环的上一次迭代结束时已经被移动）。同样，代码在所需级别的数量上循环，标记正确的元素，并修改网格。


~~~C++
127 for (int j = 0; j<levels; ++j)
128 {
129 // Select elements that are close to the sphere for grid refinement
130 for (const auto& element : elements(gridView))
131     if (sphere.distanceTo(element.geometry().center()) < epsilon)
132         grid->mark(1, element);
133
134 grid->preAdapt();
135
136 for (const auto& vertex : vertices(gridView))
137     persistentContainer[idSet.id(vertex)] = data[indexSet.index(vertex)];
138
139 grid->adapt();
~~~


第$136-137$行将网格数据保存在持久化容器中，下面一行触发了实际的网格修改。随后的离散函数的重构就比较麻烦了，因为新创建的顶点的值必须通过从父亲的元素中插值计算出来。

~~~C++
data.resize(gridView.size(dim));

for (const auto &element : elements(gridView))
{
    if (element.isNew())
    {
        for (std::size_t k = 0; k < element.subEntities(dim); k++)
        {
            auto father = element;
            auto positionInFather = ReferenceElements<double, dim>::general(element.type())
                                        .position(k, dim);

            do
            {
                positionInFather = father.geometryInFather().global(positionInFather);
                father = father.father();
            } while (father.isNew());

            // Extract corner values
            std::vector<double> values(father.subEntities(dim));
            for (std::size_t l = 0; l < father.subEntities(dim); l++)
                values[l] = persistentContainer[idSet.subId(father, l, dim)];

            // Interpolate linearly on the ancestor simplex
            data[indexSet.subIndex(element, k, dim)] = interpolate(values, positionInFather);
        }
    }
    else
        for (std::size_t k = 0; k < element.subEntities(dim); k++)
            data[indexSet.subIndex(element, k, dim)] = persistentContainer[idSet.subId(element, k, dim)];
}

grid->postAdapt();
~~~



这段代码在叶子网格的所有元素上循环。对于每一个元素，都要检查它是否在最后一次调用 `adapt` 时被创建（第147行）。如果不是这样，那么它的数据必须存在于 `persistentContainer` 中，并且可以简单地在第174-176行中复制回数据数组中。否则，元素的数据需要通过插值来构建。由于数据是基于顶点的，我们首先在第149行中循环处理元素的角。然后，对于每个角，行$151-161$在有数据的元素的最好的祖先中找到其局部坐标。注意，在使用红绿细化的情况下，这可能不是直接的父亲。然后在行$164-170$中对祖先的数据进行线性插值，使用上面显示的短插值辅助方法。这一部分利用了一个顶点的所有祖先共享相同的id（第$5.6.3)$章，这意味着`persistentContainer`可以被用于非叶顶点。当元素循环终止时，新的叶子网格视图的所有叶子元素都有正确的数据。

主循环的结束方式与之前的例子相同。当前网格被保存（这次有数据），并且球体被移动。

~~~C++
  VTKWriter<GridView> vtkWriter(gridView);
  vtkWriter.addVertexData(data, "data");
  vtkWriter.write("refined_grid_"+std::to_string(i));
 
  // Move sphere
  sphere.displace(stepDisplacement);
 }
~~~



这就结束了这个例子。当这个程序运行时，它将写出30个文件，每个文件中都有一个网格和数据，其中4个是[Fig5.23]中所示的文件。

\subsection{Some Existing Grid Managers}

DUNE网格接口有多种实现方式。每个实现都有其特殊的优势。有些比其他的更灵活，但使用更多的内存或运行时间。有些可以在分布式架构上使用，或者它们可以做自适应细化，而有些则不能。本章对`dune-grid`模块直接提供的网格实现做了一个简短的概述。它还简要介绍了 `ALUGrid` [^2] ，它需要从一个单独的模块中安装，但它功能强大，使用广泛。

在撰写本文时，`dune-grid`模块中有六个网格的实现。其中两个， `YaspGrid` 和 `OneDGrid` 是本地 DUNE 网格，其代码完全包含在 `dune-grid` 中。另外两个， `UGGrid` 和 `AlbertaGrid` ，是依靠外部库来完成真正工作的适配器实现。最后两个， `GeometryGrid` 和 `IdentityGrid` ，是所谓的 `meta grids` 。这些是被其他DUNE网格参数化的网格，扩展和修改了它们的行为。在本节中，我们将简要介绍这些网格中的每一个。

虽然 `dune-grid` 中的六个网格管理器共同构成了一个强大的集合，可以处理许多情况，但也有一些特殊情况是 `dune-grid` 中的任何实现所不能涵盖的。幸运的是，DUNE的模块化结构使得第三方开发者很容易在独立的DUNE模块中提供额外的网格管理器。我们提到`CpGrid`，OPM项目对退化六面体网格的实现，CurvilinearGrid作为一个具有多项式元素几何形状的非结构化网格[^69]，以及`FoamGrid` [^140] 中的非结构化的一维和二维曲面和网络网格。 还有各种额外的元网格，例如 `SubGrid` [^82] ， `MultiDomainGrid` [^124] ，以及 `PrismGrid` [^73] 。在DUNE项目主页上有一个更广泛的列表。

\subsubsection{External Grid Managers}

`dune-grid`中的两个网格管理器将非结构化网格的外部库连接到DUNE网格接口。

\textbf{UGGrid}

`UGGrid` 网格实现使用UG3有限元软件系统[^13] 的网格管理器。UG3自1990年代初在海德堡大学和斯图加特大学开发，是当时最强大和最广泛使用的有限元研究代码之一。虽然UG3的直接使用已基本停止（其中一个原因是它难以使用且文档不全），但其网格管理器直到今天仍是最灵活的网格管理器之一。UG3的相关部分被分叉，并被移到一个专门的DuNE模块中，称为`dune-uggrid` 。这个模块是 `dune-grid` 的可选依赖项。`UGGrid`模块中包含的`dune-grid`类允许通过现代的、易于使用的DuNE网格界面来驾驭UG3网格管理器的灵活性。本书中的许多例子都用到了它。

`UGGrid` 实现了二维和三维的非结构化网格。二维网格可以同时包含三角形和四边形，三维网格可以包含四面体、六面体、棱镜和金字塔。网格尺寸是`UGGrid`类的一个模板参数。虽然UG3本身只允许程序中的单维网格，但在DUNE中，二维和三维网格可以自由混合。在内存允许的情况下，任何数量的`UGGrid`对象都可以同时活着。

`UGGrid`的优势之一是非常灵活的细化规则集。默认情况下，它使用第2.3.2章中描述的经典的红绿策略。此外，`UGGrid`还提供了一个非接口方法

~~~C++
void setClosureType(ClosureType type)
~~~

可能的值是`ClosureType::GREEN`（默认值），或者`ClosureType::NONE` 。选择后者会关闭绿色闭合，从而导致不符合要求的红色细化。对产生的悬挂节点的顺序没有限制。  [Fig5.24]显示了在不同的初始网格上运行第$5.9.1$章的适应性例子得到的几个网格例子，以及有无绿色封闭。边界参数化可以被指定，并在细化网格时被考虑在内。[Fig5.20]中的边界参数化例子是用`UGGrid`计算的。

`UGGrid`支持各向异性的细化，即用非标准的细化规则明确标记元素。  [Fig5.25]显示了一些可能性。由于这种灵活性无法用第5.9章所述的标准Dune网格接口的简单标记机制来控制，`UGGrid`类提供了一个额外的`mark`方法，该方法将UG细化规则作为参数。

~~~C++
bool mark(const Codim<0>::Entity& element,
          UG_NS<dim>::RefinementRule rule,
          int side=0)
~~~


第一个参数是要标记为各向异性细化的元素。具体的各向异性细化规则是通过第二个参数选择的。枚举类型的几个可能的值在[Fig5.25]中显示，在线文档中给出了一个完整的列表。第三个参数只对二维网格有意义，它选择规则的方向（三维规则的方向在枚举值名称中编码）。由于这个各向异性网格细化的界面不是特别漂亮，它最终可能会改变。

`UGGrid`的另一个优势是其分布式计算的功能。网格可以分布在任意数量的进程中，如果需要，还可以重新分配。这种动态负载平衡与上述的高级细化规则一起工作得很好。一个简单的分区算法包含在网格本身；对于更高级的算法，网格可以连接到外部的网格分区器。与其他许多网格实现不同，`UGGrid`甚至支持分层的负载平衡，即细化层次中较粗的层次可以驻留在其他进程上，而不是较细的进程。这种特性的组合使得`UGGrid`成为目前最灵活的网格实现之一。

\textbf{AlbertaGrid}

ALBERTA是一个完整的有限元软件，由Alfred Schmidt和Kunibert Siebert于90年代初在弗莱堡开发[^141]，特别关注自适应多层次方法。`ALBERTA`的网格管理器可以通过DUNE网格接口以`AlbertaGrid`类的形式使用。与UG3的情况不同，`ALBERTA`没有专门针对DUNE的分叉。如果安装了实际的 ALBERTA 程序，DUNE 构建系统会接收它并构建 `AlbertaGrid` 绑定。

由于专注于自适应多层次方法，`Alberta`以网格数据结构为中心，将`hierarchical grids`实现为细化树的集合。只允许使用单线元素，网格可以是一维、二维或三维的。使用的适应机制在二维中是最新的顶点平分，在三维中是遵循Kossaczký [^112]的递归边缘平分。因此，所有的细化树都是二进制树。当网格被细化时，边界参数被考虑在内。[Fig2.15]中的自适应泊松例子是用`AlbertaGrid`计算的。



作为一个特点，很多实体信息实际上并没有存储在树节点上，而是从粗略的网格元素和细化信息中重新计算出来的。这使得数据结构非常精简，但是对网格元素的访问只能通过遍历分层树的程序来实现。由于这与DUNE的网格界面（使用层级和叶级的遍历）映射得很差，对`AlbertaGrid`实体的访问可能比其他网格要慢一些。另外，`AlbertaGrid`被限制在顺序问题上。网格管理器主要因其二分法细化而受到关注，它有时比红色或红色-绿色细化更可取。

\textbf{ALUGrid}

尽管完全不在`dune-grid`中，但如果不至少简单地提到`ALUGrid`[^2]，这篇文字就不完整了。  `ALUGrid`是另一个非结构化的网格实现，面向非常大的分布式问题，其中网格性能很重要。  `ALUGrid` 是在一个单独的模块dune-alugrid中提供的，可以从www.dune-project.org/modules/dune-alugrid。这里提到它是因为它非常强大和成熟，并且被广泛使用。

ALUGrid实现了二维和三维空间的非结构化网格。  `Elements`可以是超立方体或简单体，但网格不能同时包含两种元素类型。二维网格可以被嵌入到三维世界空间中。

其维护者开发的`ALUGrid`主要用于显式时间步进方案。由于这种方法不解决代数方程组，网格本身的性能变得非常关键。因此，我们在时间和空间效率高的数据结构上做了很多努力。  `ALUGrid`支持不符合要求的红色细化和符合要求的分割细化（2.3.2章），但不支持红绿细化。

`ALUGrid`数据结构支持分布式网格，并可扩展到大量的进程。为了适应随时间变化的自适应方法，如果自适应细化导致了负载不平衡，网格可以被重新划分。有多种负载平衡算法可用，包括基于空间填充曲线的内置算法，但也有外部负载平衡库，如ZOLTAN [^35] 针对大规模计算的进一步特殊功能包括直接构建分布式网格的接口（这是章`GridFactory`的标准$5.7.2$类尚未做到的），完整网格层次的备份和恢复，以及及时`overlap` 通信和计算的可能性。为了实现其中的一些功能，必须对网格界面进行扩展。

ALUGrid历来是一个实验网格界面扩展的乐园，主要是为了并行性能的需要。文章[^2]详细描述了这些扩展。其中一些可能最终会成为官方DUNE网格接口的一部分。




\subsubsection{Built-in Standalone Grid Managers}

目前，`dune-grid`模块包含两个不依赖外部库的网格实现。这两个是`YaspGrid`，是分布式结构化网格的快速和轻量级的实现，以及`OneDGrid`，它实现了一维的、局部自适应的网格。

\textbf{YaspGrid}

三个外部网格管理器都实现了非结构化的网格。相比之下，`YaspGrid`网格管理器实现了一个生产级的结构化网格。`YaspGrid`的域是$d$中的$\mathbb{R}^{d}$的二维超立方体，元素是$d$的二维超立方体，其边沿与轴对齐。这些元素可以是相同大小的，也可以以张量积结构排列，即元素以不同厚度的平行平面排列（[Fig5.26]）。这两种模式之间的切换发生在编译时。  `YaspGrid`完全不支持自适应网格细化；网格只能被全局细化。

由于`YaspGrid`是一个专门的结构化网格实现，它实现了这种网格的空间和时间效率，并结合了普通DUNE网格接口的便利性。事实上，一个具有统一元素大小的`YaspGrid`对象只需要一个恒定的内存，而不管网格元素的数量如何。单个元素和顶点不被存储，因为所有的元素信息都可以单独从索引中计算出来。对于张量网格模式，空间需求仍然只与每个方向上的元素数量之和成正比，远远小于元素的总数。


该实现使用了各种技巧，使网格访问尽可能快。例如，`Geometry`接口类（第$5.3.2)$章）的实现是为轴对齐的元素手工调整的。对于这样的元素，从参考元素到元素的变换$F$的`Jacobi matrix`预先知道是`diagonal` 。因此，`Geometry`方法`jacobianInverseTransposed`返回专用`diagonal`矩阵类的对象（`DiagonalMatrix` ，也见第7.3.2章）。因此，所有后续的矩阵-向量-乘法只需要$d$乘法。

不幸的是，`dune-grid` 网格界面没有提供结构化网格的扩展。例如，不可能通过整数坐标$i, j, k \in \mathbb{N}$访问三维网格的一个元素$T_{i j k}$。没有特别的理由不提供这样的接口，但是从来没有一个具体的行动来引入这样的接口。在写这篇文章的时候，`YaspGrid`也没有为这种访问提供非接口方法，但这在将来可能会改变。`YaspGrid`对元素和顶点的索引是lexicographic的，索引沿着$x_{0}$方向变化最快。有了这些知识，至少每个元素和顶点的数据可以在恒定的时间内从整数坐标中访问。

`YaspGrid`类的签名是

~~~C++
template<int dim, class Coordinates = EquidistantCoordinates<double, dim> >
class YaspGrid
~~~

参数`dim`是网格的尺寸和世界空间的尺寸。原则上它可以是任何自然数，但较大的`dim`值可能是一个编译器压力测试。第二个参数是一个策略对象，封装了坐标的存储方式。有三种选择。

1.  `Equidistant0ffsetCoordinates` : 所有元素都有相同的尺寸。

2.  `EquidistantCoordinates`（默认）。所有的元素都有相同的尺寸，网格的左下角被硬连接到 $(0, \ldots, 0) \in \mathbb{R}^{d}$ 。

3.  `TensorProductCoordinates` : 元素的每个平面可以有其单独的厚度。

`YaspGrid`对象直接通过其构造器进行设置。其中有各种不同的构造器，有的将一个坐标策略对象与附加信息结合在一起，有的将所有需要的信息直接使用坐标对象。例如。

~~~C++
EquidistantCoordinates coordinates({1.0, 1.0, 1.0}, {10,10,10});
YaspGrid<3> grid(coordinates);
~~~

为单位立方体$\Omega=[0,1]^{3}$构建一个结构化的统一网格，其中有$10 \times 10 \times 10$个大小相等的元素。该代码

~~~C++
 const int dim = 2;
 using Coordinates = TensorProductCoordinates<double,dim>;
 using GridType = YaspGrid<dim,Coordinates>;

 std::array<std::vector<double>, dim> coordinates;

 for (int j=-10; j<10; j++)
 {
    coordinates[0].push_back(1.6*std::atan(j));
    coordinates[1].push_back(std::atan(j));
 }

 GridType grid(coordinates);
~~~



创建 [Fig5.26] 的二维张量网格。关于如何构建`YaspGrid`对象的所有细节，请查阅类的文档。

`YaspGrid`为大规模并行计算提供了许多功能。网格可以分布在任何数量的处理器上。事实上，为了适应非常大的问题，`YaspGrid`用一个允许可调位长的自定义整数类型对其实体进行编号。子域必须是块状的，但是它们的大小和分布可以用简单的负载平衡类来控制。另一方面，动态负载平衡，即在模拟过程中重新划分网格，是不可能的。由于`YaspGrid`不支持自适应网格细化，负载平衡的静态性质并不是什么问题。作为DUNE中唯一的网格实现（目前），`YaspGrid`支持网格的重叠分区。例如，这种分区自然适合于实现重叠的 `Schwarz` 前置条件器 [^148] 。

\textbf{OneDGrid}

`OneDGrid` 网格管理器是面向小众应用的：它只提供 $\mathbb{R}^{1}$ 中的连续一维网格。然而，它是完全非结构化的，支持元素细化和粗化。除了现实世界的PDE应用是在一维域上提出的，一维非结构化网格管理器对于调试、原型设计和教学都有帮助。特别是，`OneDGrid`网格管理器可能是最简单的非结构化和自适应网格管理器。因此，很容易理解它的代码和内部工作原理。这对于那些有兴趣为DUNE网格界面实现自己的网格数据结构的人来说是有帮助的。

\subsubsection{Meta Grids}

`dune-grid`中最后两个网格的实现是所谓的 `meta grids` 。元网格是由另一个DUNE网格（称为宿主网格）作为参数的网格，它们以某种方式对其进行修改。由于元网格实现了完整的DUNE网格接口，它们可以像其他网格一样被使用。除了 `dune-grid` 模块中的两个元网格之外，还有更多有趣的元网格，例如 `SubGrid` [^82] ， `MultiDomainGrid` [^124] ，以及 `PrismGrid` [^73] 。

\textbf{GeometryGrid}

DUNE的第一个元网格是`GeometryGrid` 。它修改了主网格的几何形状。更确切地说，它允许为每个网格顶点分配新的坐标，并且用多线/affine的网格元素替换主网格的几何形状。见[Fig5.27]，其中用一个`YaspGrid`被扭曲成一个四分之一圆来证明这一点。由此产生的网格实现是拓扑学上的，但不是几何学上的结构。另外，`GeometryGrid`可以用来实现`r-refinement`和移动网格方法[^95]，网格界面本身不允许移动或变形现有网格。

设置 `GeometryGrid` 需要一个主网格对象和一个函数对象，这个函数对象可以从旧顶点的位置或指数产生新顶点坐标。下面的函数对象产生来自 [Fig5.27] 的变形。


~~~C++
struct AnalyticalDeformation
    : public AnalyticalCoordFunction<double, 3, 3, AnalyticalDeformation>
{
    FieldVector<double, 3> operator()(const FieldVector<double, 3> &x) const
    {
        return {(1 + x[2]) * std::cos(x[0]),
                x[1],
                (1 + x[2]) * std::sin(x[0])};
    }
};
~~~

然后可以通过以下代码设置一个变形的`YaspGrid`。

~~~C++
using AnalyticallyDeformedGrid = GeometryGrid<HostGrid,
                                        AnalyticalDeformation>;
AnalyticalDeformation analyticalDeformation;
AnalyticallyDeformedGrid analyticallyDeformedGrid(hostGrid,
                                        analyticalDeformation);
~~~



或者，可以在一个容器中提供新的顶点坐标。为此，变形函数对象必须继承自 `Dune::DiscreteCoordFunction` 。

~~~C++

template <class HostGridView>
struct DeformationFunction
    : public DiscreteCoordFunction<double,
                                   HostGridView::dimension,
                                   DeformationFunction<HostGridView>>
{
    static constexpr int dim = HostGridView::dimension;
    DeformationFunction(const HostGridView &gridView,
                        const std::vector<FieldVector<double, dim>> &
                            deformedPosition)
        : indexSet_(gridView.indexSet()),
          deformedPosition_(deformedPosition)
    {
    }
    template <class HostEntity>
    void evaluate(const HostEntity &hostEntity, unsigned int corner,
                  FieldVector<double, dim> &y) const
    {
        auto idx = indexSet_.subIndex(hostEntity, corner, dim);
        y = deformedPosition_[idx];
    }

private:
    const typename HostGridView::IndexSet &indexSet_;
    const std::vector<FieldVector<double, dim>> deformedPosition_;
};


~~~



将`YaspGrid`的[Fig5.27]的例子与这样的离散形变进行设置，其形式为：。

~~~C++
std::vector<FieldVector<double, 3>> vertexPositions(hostGridView.size(dim));
for (const auto &vertex : vertices(hostGridView))
{
    FieldVector<double, 3> x = vertex.geometry().corner(0);
    vertexPositions[hostGridView.indexSet().index(vertex)] = {(1 + x[2]) * std::cos(x[0]),
                                                              x[1],
                                                              (1 + x[2]) * std::sin(x[0])};
}
using DiscretelyTransformedGrid = GeometryGrid<HostGrid, DeformationFunction<HostGridView>>;
DeformationFunction<HostGridView> discreteTransformation(hostGridView,
                                                         vertexPositions);
DiscretelyTransformedGrid discretelyTransformedGrid(hostGrid,
                                                    discreteTransformation);

~~~





`GeometryGrid`实现了整个网格接口，可以像其他网格一样使用。特别是，它实现了并行分布式计算的所有功能，并且可以应用于分布式主机网格。

\textbf{IdentityGrid}

`dune-grid`中第二个可用的元网格是`IdentityGrid` 。正如其名，它产生的元网格与主网格的行为完全相同。  `IdentityGrid`的存在只是为了记录。它可以是有启发性的，因为它只包含了DUNE网格必须实现的模板代码，没有任何功能。事实上，要开始写一个新的网格管理器，建议先复制`IdentityGrid`，把所有的东西重命名为一个新的名字，然后开始逐一实现所需的功能。

\section{Dune Grids on Distributed Machines}

前一章一直假设只有一个进程，它知道整个网格。然而，今天相当一部分的应用需要多处理器机器来运行，要么是为了保持运行时间的可接受性，要么是为了处理大量的存储需求，经常是两者都需要。因此，`dune-grid`接口提供了将网格分布在并行机器上的设施，以及对它们的并发访问。它还提供了在各个子网格之间交换数据的方法。这些手段被设计用来覆盖通常在偏微分方程的分布式算法中发现的所有常见的通信模式。在DUNE网格接口的基础上，直接使用MPI可以满足更多的特殊需求。

该接口（以及本章）目前只包括分布式内存多处理。使用`OpenMP`或类似的工具对共享内存架构的明确支持正在进行中[18,19]，但在DUNE的官方版本中还没有实现的。

\subsection{The Dune Data Decomposition Model}

用DUNE网格界面进行并行计算的基本思想是网格划分。完整的网格被分割成子域，每个子域被分配给一个单独的进程。这些子域可以是也可以不是 `overlap` 。每个进程只与附属于其子域网格的数据一起工作。进程交换数据，但只与它们在子域分区上的直接邻居交换（ [Fig6.1] ）。

这种范式直接对应于数值分析文献中已知的经典单级域分解方法 [^148] [^154] 。但DUNE可以走得更远。由于DuNE网格是分层的（第5.1章），一些网格的实现，如`UGGrid`也可以将粗网格分配给不同的进程，而不是相应的细网格。这样就可以实现分布式的双网格和多网格方法，在这种情况下，将较粗的网格分配到比较细的网格更少的进程中往往是有用的。

分布式DUNE网格是一个集体对象：所有参与网格上计算的进程都同时实例化了这个网格对象。每个进程存储所有网格元素的一个子集，但每个元素可能存储在一个以上的进程中。如果是这种情况，它被称为分布式元素。对于低维的网格实体也是如此。任何这样的实体都可能被存储在一个以上的进程中，那么它就被称为分布式实体。

在DUNE数据分解模型中，一个流程中的每个实体都有一个分配给它的分区类型。有五种不同的可能分区类型。  `interior` , `border` , `overlap` , `front` , 和 `ghost` 。


我们首先讨论网格元素的分区，这比低维实体的分区更简单。网格元素被限制在三种分区类型中 `interior` , `overlap` , 和 `ghost` 。考虑一个给定的网格视图的所有元素，无论是水平网格视图还是叶子网格视图。每个元素可以存在于几个进程中，并且在每个进程中都有一个单独的分区类型。它在其中一个进程上的分区类型必须正好是`interior`。进程号`interior`中的$i$叶子元素形成一个子域$\Omega_{i} \subseteq \Omega$，所有的$\Omega_{i}, 0 \leq i<P$，形成一个不重叠的计算域$\Omega$的分解。也就是说，对于每个叶子元素，恰好有一个过程，这个元素具有分区类型`interior`。

这种方法对于像 `Neumann-Neumann` 方法 [^148] 这样的算法很有效。对于这种方法，需要将计算域分解为不重叠的子域，而这种分解是由`interior`元素提供。原则上，`Neumann-Neumann`方法可以实现，只将每个元素分配给一个单一的进程（在这里，它是`interior`的一个推论）。

然而，为了管理像子域边界残差这样的数据，在每个子域周围有一个额外的元素层是很方便的。  这一层中的`Elements`存在于一个以上的过程中；它们不是`interior`，而是对应于邻近子域的`interior`元素。这种只为促进数据交换而存在的元素被称为`ghost`元素。因此，在DUNE中，这些元素具有分区类型`ghost` 。

另一方面，当数值算法是一种重叠域分解方法时，例如经典的`Schwarz`方法[^148]，算法本身在计算域的重叠分区上运行。那么就需要两种类型的分布式元素。第一类是算法重叠区的元素。如果一个元素包含在`overlap`的$p$子域中，那么它在其中一个子域中是`interior`，而在其他的$p-1$中是`overlap`。这在[Fig6.2]中得到了说明。第二类分布式元素还是从非重叠方法中已经知道的`ghost`元素，它们在子域网格周围形成一个层。从界面上看，`overlap`和`ghost`元素之间没有区别，这种区别只是出于概念上的考虑。

`overlap`和`ghost`层的存在、厚度和确切结构由网格实现决定。例如，一个分布式的`YaspGrid`没有`ghost`元素，但它可能有`overlap` 。`overlap`层的厚度（以元素数计）是任意的，可以通过`YaspGrid`构造函数的一个专用参数来控制。  `UGGrid`和`ALUGrid`，在另一方面，根本没有实现`overlap`层。相反，它们在每个子域周围提供了一个由`ghost`元素组成的单元素层，没有其他选项。

为较低维度的网格实体（顶点、边等）分配分区类型的工作更为复杂。特别是，剩下的两个分区类型`border`和前部开始发挥作用。粗略地说，给定子域网格元素的分区类型，`border`实体将`interior`元素与`overlap`元素分开，而前沿实体将`overlap`元素与`ghost`元素分开。如果没有`overlap`，`interior`和`ghost`元素被`border`实体分开。更正式地说，对于任何进程$i$，让$\Omega_{i}$成为由`interior`元素决定的领域，即。

$$
\Omega_{i}:=\operatorname{int}(\underbrace{T \text { is `interior` }} T)
$$

$\Omega_{i}$或$\partial \Omega_{i} \cap \partial \Omega$中的每个实体都是一个`interior`实体。`border`域是`interior`域的边界中不属于域边界的那部分。

$$
B_{i}:=\overline{\partial \Omega_{i} \backslash \partial \Omega}
$$

而进程$i$上的$B_{i}$所包含的所有网格实体在该进程上具有分区类型`border`。`overlap`元素形成一个独立的域

$$
\Omega_{i}^{\text {overlap }}:=\operatorname{int}(\underbrace{T \text { is `overlap` }} T)
$$

该域边界上的所有点都是正面，除非它们是`border`或域边界。

$$
F_{i}:=\overline{\partial \Omega_{i}^{\text {overlap }} \backslash \partial \Omega} \backslash B_{i}
$$

注意，$\Omega_{i}^{\text {overlap }}$很可能是空的，在这种情况下，$F_{i}$也是空的。所有不包含在这四个集合之一的实体将是`ghost`实体。

在[Fig6.3]中对三个不同的例子说明了网格实体对分区类型的分配。每个例子都显示了一个具有$6 \times 4$元素的二维结构网格。存储在固定进程$i$中的实体用颜色显示，颜色表示分区类型。第一行显示了一个例子，进程$i$具有所有三种分区类型`interior`、`overlap`和`ghost`的模数0的实体（该行的左图）。该行的中间和右边的图片显示了分区类型对代码维度为1和2的实体的相应分配。中间一行显示了一个例子，一个`interior`分区被一个`overlap`扩展，但没有`ghost`元素存在。这是`YaspGrid`中使用的模型（`overlap`可以有一层以上的元素厚度）。最后一行显示了一个例子，`interior`分区被一层`ghost`元素所扩展。这就是UGGrid和`ALUGrid`中使用的模型。

网格实体的分区类型在DUNE网格界面中由一个枚举类型PartitionType表示，定义在文件 `dune/grid/common/gridenums.hh` 中。它可以取值 `InteriorEntity` , `BorderEntity` , `OverlapEntity` , `FrontEntity` , 和 `GhostEntity` 。给定一个任意二维的网格实体，该实体相对于本地进程的分区类型可以通过成员法得到

~~~C++
PartitionType Entity::partitionType() const
~~~

因此，例如，下面的代码片断将计算对象 `interior` 中给出的网格视图上本地进程的 `gridView` 元素的数量。

~~~C++
std::size_t counter = 0;
for (const auto& element : elements(gridView))
    if (element.partitionType() == InteriorEntity)
        counter++;
~~~

实体的分区类型不能由用户设置--它是由网格实现独家控制的。

DUNE网格界面提供了两个专门的方法来获取有关`overlap`和`ghost`层的信息。这些是`GridView`的成员方法。

~~~C++
int overlapSize(int codim) const
int ghostSize(int codim) const
~~~


并返回每个子域周围的`overlap`和`ghost`层的厚度，以横向的元素数来计算。参数codim的存在只是出于历史原因，并没有任何意义。不幸的是，精确定义网格元素层的厚度是很困难的，大多数实现都是报告一个近似值。另外，没有规定`ghost`元素的单元素层是只包括`interior`元素的面邻，还是也包括其他邻域。特别是，`UGGrid`对象声称`ghost`大小为1，但省略了`ghost`层中的顶点邻居（[Fig6.4]）。

在第 $5.2$ 章中已经讨论了对元素的迭代。在一个连续的网格中，像上面例子中的那个循环将遍历网格视图中的所有元素。在分布式设置中，调用该循环将遍历本地进程的所有元素，而不考虑分区类型。为了只对某些分区类型进行迭代，有一些全局元素和顶点方法的泛化，可以创建适当的范围。这些泛化的方法需要一个PartitionSet类型的第二个参数，它指定了要迭代的分区类型集合。类型`PartitionSet`定义在文件`dune/grid/common/partitionset.hh`中，它在命名空间`Dune::Partitions`中定义了单子对象`interior`、`overlap`、`ghost`等，它们可以被组合到集合。因此，例如，要遍历一个给定的网格视图的所有`interior`元素，请编写

~~~C++
for (const auto& element : elements(gridView,
                        Dune::Partitions::interior))
{
    // Do something with ’element’
}
~~~


通过使用加法运算符，单子可以被组合成集合。比如说。

~~~C++
Partitions::interior + Partitions::border
~~~

代表集合{内部$\} \cup\{$ `border` $\}$ 。为了遍历`interior`和`border`分区中的所有顶点，写成

~~~C++
for (const auto& vertex : vertices(gridView,
            Partitions::interior + Partitions::border))
{
// Do something with ’vertex’
}
~~~


所有分区类型的集合可作为 `Partitions::all` 。因此，为了遍历一个子域的所有元素，写成

~~~C++
for (const auto& element : elements(gridView, Partitions::all))
{
// Do something with ’element’
}
~~~


由于历史原因，只允许以下分区类型的组合。[树形]

[树]: https://cdn.mathpix.com/snip/images/XTUr4BVsmPREs2dxqxX1BT810SqxWM1Gr7FArXkqfBY.original.fullsize.png


由于总是将集合写成总和会变得很乏味，文件`partitionset.hh`也定义了一些快捷方式。目前， `interior` 是 `interior + border` 的边界，类似的还有 `interiorBorder0verlap` 、 `interiorBorder0verlapFront` ，以及所有。关于完整的列表，请查看`partitionset.hh`文件的在线文档。

必须注意的是，对给定子域网格的实体子集进行迭代并不改变这些实体的编号。在分布式设置中，第`IndexSet`章的$5.6.1$对象总是列举出本地进程的所有分区。因此，在一个真正的子集上进行迭代，例如`interior`分区，可能会跳过某些索引。数据数组的大小必须总是根据所有分区来确定，即使有些条目，例如`ghost`元素的条目，没有被使用。

网格界面的大多数其他方法在多进程环境下不会改变其行为。一个值得注意的例外是以下方法

~~~C++
bool neighbor() const
bool boundary() const
~~~

的接口类`Intersection`（见第5.4章）。在单进程设置中，neigher返回交叉点对面是否存在邻居元素，boundary返回交叉点是否在域边界上。在叶子网格视图中，邻居总是边界的否定值，但是在自适应细化网格的水平网格视图中，可能有不在域边界上的交点没有邻居。

对于一个分布式网格，如果在同一进程上有一个相邻的元素，方法neighbour返回true。因此它可能会返回`false`，即使是不在域边界上的叶子网格视图交点。另一方面，边界方法只在域边界上继续返回`true`。因此，对于内部子域边界上的交点，两种方法都会返回 `false` 。

\subsection{Setting up a Distributed Grid}

当使用结构化的网格实现时，设置分布式网格很容易：这样的网格可以直接构建为分布式网格。对于非结构化的网格，有两种方法。如果网格足够小，可以放入主进程的内存中，那么可以按照第$5.7$章所述，在主进程上构建网格，然后在所有进程中分布。否则，网格需要通过外部手段进行分割，每一部分都必须直接输入到相应的进程中。目前只有 `ALUGrid` 网格管理器 [^2] 支持这一点。

\subsubsection{Distributed Structured Grids}

统一结构的网格需要很少的内存来存储它们。因此，网格设置、分区和重新分区都是不需要大量通信的操作。`dune-grid`中唯一的分布式结构网格的实现是`YaspGrid`（第5.10.2章），它实现了任何尺寸的立方体网格，具有轴对齐的元素几何形状。这些网格可以分布在任意数量的进程中，但子域也必须具有立方体形式。

分布式`YaspGrid`对象是通过专门的构造函数来设置的。例如，要为单位广场设置一个具有$10 \times 10$元素的分布式二维网格，请调用。

~~~C++
constexpr int dim = 2;
FieldVector<double, dim> upper = {1.0, 1.0};
std::array<int, dim> elements = {10, 10};
std::bitset<dim> periodic("00"); // Not periodic in either
                                 // of the two directions
int overlapSize = 1;             // Thickness of the overlap layer

YaspGrid<dim> yaspGrid(upper, elements,
                       periodic, overlapSize,
                       MPI_COMM_WORLD);

~~~


前两个参数设置领域大小和网格分辨率。最后一个参数是将用于网格的MPI通信器。它指定了网格将被分配到的一组进程。`MPI-defined`值`MPI_COMM_WORLD`意味着所有可用的进程都将被使用。通信器前面的参数正好控制`overlap`层的大小。回顾一下第$6.1$章，DUNE允许重叠的子域分区，`YaspGrid`是一个数据结构，实际上实现了这一点。这里选择的值1意味着每个子域周围将有一层`overlap`元素。bitset periodic控制每个坐标方向的网格的周期性（在这个例子中关闭），这意味着域边界的相应部分可以使用第6.4.1章的子域通信机制进行通信。这与分布式计算没有直接关系，但是目前还没有`YaspGrid`构造函数允许指定MPI通信器而不同时设置周期性位。

分布式`YaspGrid`对象有更多的构造函数，只有在线文档描述了它们的全部。一些构造函数允许选择自定义的分区算法。默认实现试图通过考虑进程的数量和网格的尺寸来猜测一个好的分区。其他的分区算法可以通过从抽象基类`YLoadBalance`派生，并将派生类交给`YaspGrid`构造函数来实现。例如，文件`dune/grid/yaspgrid/partitioner.hh`中的`YaspFixedSizePartitioner`类，允许明确设置每个坐标方向所需的子域数量。

\subsubsection{Distributed Unstructured Grids}

建立非结构化的分布式网格是一个更大的挑战，因为涉及的数据多得多。如果初始网格非常大，它可能根本就不适合在一个单一的进程上。那么，在将其送入DUNE之前，需要将其分割成不同的片段，每一个片段都由相应的进程直接交给DUNE。`ALUGrid` 实现允许这样做，遵循 [^2] 中描述的程序。不幸的是，在DUNE网格接口中还没有官方支持。


网格接口的形式是第`GridFactory`章中描述的$5.7.2$类，假定初始网格足够小，可以装到主进程中。为了构造一个分布式网格，初始网格必须首先被读入主进程。然后，必须计算元素的分区，可以通过外部分区库，也可以依靠网格实现本身。最后，一个负载平衡步骤将每个元素发送到分区的相应进程中。所有支持分布式计算的DUNE网格都应该提供这种功能，即使它只使用非常简单的分区算法。分层网格类的实现必须提供一个方法

~~~C++
bool loadBalance()
~~~

该方法不需要参数，并返回一个布尔值。对一个给定的网格对象调用这个方法应该计算一个元素分区，并相应地将网格分配到可用的进程中。精确的分区方式留给各个网格的实现。例如，`UGGrid`使用简单的坐标平分，而`ALUGrid`使用基于空间填充曲线的方法[^2][^5] 。如果网格发生了任何变化，该方法返回true。对于那些完全不支持分布式网格的网格实现，`loadBalance`方法是存在的，但它是空的，返回`false` 。作为一个例子，下面的代码从一个`GMSH`文件中读取一个`UGGrid`，并使用坐标二分法将其分配到`MPI_COMM_WORLD`中的所有进程。


~~~C++
 using Grid = UGGrid<2>;
 std::shared_ptr<Grid> grid
    = GmshReader<Grid>::read("l-shape-refined.msh");
 grid->loadBalance();
~~~


网格实现所提供的网格划分算法经常过于简单。文献[^35][^105][^131][^132]中发表了大量这样的算法，每种算法都有不同的优点和缺点。不幸的是，它们都需要不同的参数集，使得它们很难在一个单一的接口中表现出来。因此，任何网格实现都被允许额外提供带有额外参数的非接口负载均衡方法，这些方法会触发网格实现特有的负载均衡算法。例如，`UGGrid`和`ALUGrid`都提供了根据外部网格划分器（如`PARMETIS`[^105]或`SCOTCH`[^131][^132]计算的叶状网格元素的任意划分来分配网格的方法。

对于`UGGrid`，给定这样一个容器形式的分区，每个元素都有目标进程号，网格可以通过调用以下方式进行分配

~~~C++
bool loadBalance(const std::vector<Rank>& targetProcesses,
                 unsigned int fromLevel)
~~~


上的`UGGrid`对象，其中Rank是MPI用于进程行列的类型。输入容器`targetProcesses`的大小预计等于叶子网格的`AllPartition`元素的数量。对于每个这样的元素，它必须包含该元素应该被发送的等级。元素的编号是由`MultipleCodimMultipleGeomTypeMapper`类实现的。参数`fromLevel`只有在分配一个之前已经被精炼过的网格时才有意义（这是明确允许的，见下一节）。在这种情况下，整个网格层次需要被分发。数字`fromLevel`是在元素细化层次中重新分配的最低（即最粗的）层次。所有在较低层次上的元素将留在原处。这个特性通常用于在少数进程上保持多网格层次结构的最粗层次，因为如果非常粗的网格被分布，通信成本通常超过了计算时间的节省。

作为计算这种分区的一种方法，`dune-grid`提供了一个简单的接口给`PARMETIS`网格分区器（在`dune/grid/utility/`文件夹的`parmetisgridpartitioner.hh`文件中）。下面的代码片段从 `GMSH` 文件中加载一个结构化的 `UGGrid` 对象，并使用 `PARMETIS` 分发它。

~~~C++
using Grid = UGGrid<2>;
std::shared_ptr<Grid> grid = GmshReader<Grid>::read("l-shape-refined.msh");

using GridView = Grid::LeafGridView;
const GridView gridView = grid->leafGridView();

// Create initial partitioning using ParMETIS
std::vector<unsigned int> part = ParMetisGridPartitioner<GridView>::partition(gridView, mpiHelper);

// Distribute the grid using the partitioning computed by ParMETIS
grid->loadBalance(part, 0);
~~~



这一操作的结果可以在 [Fig6.4] 中看到。左图是使用内置的 `UGGrid` 分区器的结果，右图是由 `PARMETIS` 产生的结果。

\subsection{Dynamic Load-Balancing}

在上一节中，网格在创建后就被分布到一组进程中。然而，人们也可能想在模拟过程中晚些时候重新分配一个已经分布的网格。这就是所谓的 `dynamic load-balancing` 。  [Fig6.5]展示了一个例子：左边的自适应细化网格已经被划分，使所有进程获得大致相同的自由度。然而，在几个时间步骤之后，精炼区域已经移动到另一个位置，分区变得不平衡（中心）。动态负载平衡又产生了一个平衡的工作负载（右）。

使用DUNE网格接口触发网格负载平衡与上一节中初始分布的设置方式没有什么不同。所有的负载平衡方法都可以在（几乎）任何时候被调用，以使分布适应当前的工作负荷。这些方法的语义完全没有变化。变化的是对`PARMETIS`接口的使用，这取决于是否计算了初始分布，或者是否修改了现有分布。下面的代码片段重新分配了一个已经分发的`UGGrid`对象。

~~~C++
float transVsComm = 1000; // Quality parameter,
                          // consult ParMETIS documentation
part = ParMetisGridPartitioner<GridView>::repartition(gridView,
                                                      mpiHelper,
                                                      transVsComm);
grid->loadBalance(part, 0);
~~~


变量`part`是上一节中已经使用过的目标进程等级的`std::vector`。浮点参数`transVsComm`平衡了新分区的运输成本与通信成本，在`PARMETIS`文档中有所描述。在第$5.9$章的网格适应性例子中插入这三行，可以创建[Fig6.5]中所示的网格。

当有数字数据附着在网格上时，动态负载平衡变得更加有趣。当网格的一部分移动到其他进程时，这种数据通常需要被传送。正如已经解释过的那样，DUNE将网格传输留给网格实现。用户可以说哪个元素要去哪里，但实际的元素运输和相应的簿记是完全隐藏的。这很方便，但它使数字数据与网格一起移动变得困难。这里的问题还是在于，网格数据结构和数字数据被严格分开。

1.网格对用户数据的存储方式一无所知。对于每个网格实体，可能有任意数量的数据字段，不同的类型，存储在不同的容器中。不能指望网格的实现知道这些情况。

2.每个数据项可能是一个自定义的数据类型，可能不容易被序列化（即转换为字节流）。

DUNE网格接口通过使用回调机制解决了这个问题。对于具有特定数据有效载荷的网格再分配，用户必须编写一个特定的回调类，称为 `DataHandle` 。该类实现了在发送方收集和序列化数据的方法，并在接收方再次分发数据。`DataHandle`知道用于存储数字数据的数据结构，其方法在网格传输过程中被网格实现调用。那么，与网格实体一起传输数据就是一个三步的过程。

\textbf{Gathering} ：与将被发送到不同进程的实体有关的数据被从其容器中收集。要从一个进程发送的全部数据被序列化，并存储在一个特殊的内存位置，称为`message buffer` 。`message buffer`是由网格实现提供的。


\textbf{Communication} : `message buffer` 中的实体和数据被发送到接收进程。

\textbf{Scattering} : 接收进程将从其他进程收到的数据放在正确的容器中。

作为一个额外的复杂情况，请注意重新分配网格必须改变索引集，因为实体在各个进程中被添加和/或删除。因此，保存在数组中的数据会变得无效，即使它与不受负载平衡影响的实体有关。补救措施与第5.9.2章中的网格适应性相同：在进行负载均衡之前，所有的数据都需要被复制到可以被一个 $i d$ 的关联容器中去。DataHandle只对关联容器进行操作，用户代码必须在负载均衡程序结束后，使用更新的索引集将数据复制回数组中。

DUNE网格接口的实现有望为用户自动处理通信步骤。然而，他们不能处理收集和分散，因为这取决于用户的数据布局。为此，用户必须编写数据处理类，其接口由CommDataHandleIF类指定（在`dune/grid/common/datahandleif.hh`）。


~~~C++
template<class DataHandleImp, class DataTypeImp>
class CommDataHandleIF
~~~


实际的实现必须派生自该类，给出自己的类型作为第一个模板参数 `DataHandleImp` 。第二个模板参数`DataTypeImp`是要传送的数据的$\mathrm{C}++$类型，如果有一个这样的固定类型的话。例如，如果数字数据由每个顶点的一个`double`组成，那么`DataTypeImp`应该是双倍。如果它由一个`double`和一个复数组成，那么

~~~C++
std::tuple<double,std::complex<double> >
~~~


是一个合适的参数。另一方面，如果数据类型对所有实体都不一样，或者在编译时不知道，那么`unsigned char`通常是`DataTypeImp` 的最佳选择。请注意，所有的大小信息都是以`unsigned char`为单位计算的。

为了使用数据句柄实现来实现负载平衡，每个网格实现都有一个接受数据句柄对象的负载平衡方法。

~~~C++
template<class DataHandle>
bool loadBalance(DataHandle& data)
~~~




为了使这样的方法发挥作用，`DataHandle`类的正确实现需要一定数量的公共方法，这些方法列在[Tab6.1]中。所有这些方法的存在都是为了被网格实现所调用，而不是由用户自己调用。除了接口方法外，数据处理类必须有构造函数或设置方法，告诉它要传送的数据的位置和结构。

前三个接口方法是用来告诉网格实现需要和网格实体一起传送什么数据。该方法

~~~C++
bool contains(int dim, int codim) const
~~~


必须返回`true`，这样网格才能为所有codimension codim的实体传送数据。当调用这个方法时，网格实现总是在第一个参数中提供网格维度。该方法必须返回将与该实体一起被传送的数据项（类型为`DataTypeImp` ）的数量。这个方法只在发送方被调用，并且只针对那些包含方法已经指定了这个维度的实体携带数据的代码维度的实体。它允许网格实现计算所需消息缓冲区的大小。


原则上，每个实体可以有不同数量的数据项。然而，在很多情况下，对于一个给定维度的所有实体来说，这个数字是相同的。为了让网格实现知道这个重要的情况，有这样一种方法

~~~C++
bool fixedSize(int dim, int codim) const
~~~



在开始遍历网格以收集数字数据之前，网格的实现会调用它一次。第一个参数始终是网格的维度。如果`fixedSize`对于一个给定的维度`codim`返回`true`，那么该维度的所有实体都会有相同数量的数据项（由这些实体中任何一个的size方法的返回值给出）。如果`fixedSize`返回`false`，那么在实际的数据收集之前，会对每个实体调用size，这可能会导致少量的性能损失。

然而，`DataHandle`接口的两个核心方法是`gather`和`scatter`这两个方法。这些方法分别从用于存储数字数据的（关联）容器中传输数字数据，同时将索引集改变到消息缓冲区并返回。收集方法接收一个DUNE网格实体和一个对消息缓冲区的非静态引用。

~~~C++
template<class MessageBuffer, class Entity>
void gather(MessageBuffer& messageBuffer, const Entity& entity) const
~~~


消息缓冲区是一个类似容器的小对象，其条目类型为`DataTypeImp`（见下文）。

对于每一个将被发送到另一个进程的实体，在实际的网格变化之前，gather方法被调用，而且该实体的代码维度是包含方法返回真。该方法必须找到附属于该实体的数据，并将其写入消息缓冲区。在所有相关的用户数据都以这种方式被收集后，网格将把消息缓冲区的内容与实体一起发送。

相反，`scatter`方法是在网格实体被传送后调用的。

~~~C++
template<class MessageBuffer, class Entity>
void scatter(MessageBuffer& messageBuffer, const Entity& entity, size_t n)
~~~



对于那些包含方法返回真值的实体，以及作为网格再分配的一部分从一个进程到另一个进程的实体，它被调用。它被赋予一个消息缓冲区和一个实体，并被期望从消息缓冲区读取实体的数据，并将其写入用于存储数字数据的关联容器中。由于数据项的数量可能因实体而异，`scatter`方法并不期望知道要读取多少数据。相反，数据项的数量是由网格实现通过第三个方法参数 $\mathrm{n}$ 交给该方法的。

消息缓冲器的类型未被指定，每个网格实现都有自己的类型。遵循鸭子类型范式（第4.4.2章），消息缓冲器的接口不被编译器强制执行。它非常薄，只由两个方法组成

~~~C++
void write(const DataTypeImp& value)
~~~

和

~~~C++
void read(DataTypeImp& value)
~~~


其中`DataTypeImp`是传递给`CommDataHandleIF`基类的第二个类型。写入方法必须被`gather`用来向消息缓冲区写入数据。它的工作原理类似于输出迭代器：当`gather`被调用时，消息缓冲区是空的，具有正确的长度，并且有一个内部迭代器指向第一个条目。调用write将给定的值写入该条目，并使迭代器前进。例如，假设一个实体需要传送存储在一个叫做 `values` 的数组中的四个值。这四个值可以通过以下方式写到消息缓冲区中

~~~C++
for (const auto& v : values)
    messageBuffer.write(v);
~~~


数据被按字节复制到消息缓冲区。这是一种相当粗糙的序列化形式。对于标准的数字类型，它可以很好地工作，但对于更多的特殊类型的数据，它可能会失败。未来的`dune-grid`版本可能有一个改进的接口。

要从消息缓冲区读取数据，`scatter`方法必须使用`read` 方法。当为一个实体调用 gather 时，缓冲区被 $\mathrm{n}$ 类型 `DataTypeImp` 的条目填满，内部迭代器指向第一个条目。对读取的调用将当前条目复制到参数值中，并使迭代器前进一个 `DataTypeImp` 。聚集方法预计将精确读取参数所给的条目数 $\mathrm{n}$ 。请注意，read方法改变了消息缓冲区，因为它推进了迭代器。因此，read不是一个常量方法，`messageBuffer`方法的`scatter`参数是一个非常量引用。

下面这个`DataHandle`类的实现示例使前面的解释更加具体。它取自第 $6.7$ 章中的完整例子。

~~~C++
template <class Grid, class AssociativeContainer>
struct LBVertexDataHandle
    : public CommDataHandleIF<LBVertexDataHandle<Grid, AssociativeContainer>,
                              typename AssociativeContainer::mapped_type>
{
    LBVertexDataHandle(const std::shared_ptr<Grid> &grid,
                       AssociativeContainer &dataContainer)
        : idSet_(grid->localIdSet()), dataContainer_(dataContainer)
    {
    }

    bool contains(int dim, int codim) const
    {
        assert(dim == Grid::dimension);
        return (codim == dim); // Only vertices have data
    }

    bool fixedSize(int dim, int codim) const
    {
        return true; // All vertices carry the same number of data items
    }

    template <class Entity>
    size_t size(const Entity &entity) const
    {
        return 1; // One data item per vertex
    }

    template <class MessageBuffer, class Entity>
    void gather(MessageBuffer &buffer, const Entity &entity) const
    {
        auto id = idSet_.id(entity);
        buffer.write(dataContainer_[id]);
    }

    template <class MessageBuffer, class Entity>
    void scatter(MessageBuffer &buffer, const Entity &entity, size_t n)
    {
        assert(n == 1); // This data handle implementation
        // transfers only one data item.
        auto id = idSet_.id(entity);
        buffer.read(dataContainer_[id]);
    }

private:
    const typename Grid::LocalIdSet &idSet_;
    AssociativeContainer &dataContainer_;
};

~~~


这个类处理每个网格顶点的一个未指定类型的数据元素的传输。数据被放在一个关联容器中交给该类，其类型由模板参数 `AssociativeContainer` 决定。该类保持对该容器的非静态引用，因此它可以从该容器中读取和写入。方法包含指定只有顶点数据，`fixedSize`告诉每个顶点有相同数量的数据项，而size告诉每个顶点正好有一个数据项。方法`gather`（在行$255-260)$中）获取实体参数中给出的顶点数据，并将其写入消息缓冲区。相反，`scatter`方法在接收实体的进程中被调用，消息缓冲区将包含相应的数据。该方法的代码从消息缓冲区读取数据，并将其复制到容器中。

为了看到数据处理类的作用，假设有一个类型为`std::vector<double>`的数组对象dataVector，它包含了当前叶子网格视图的每个顶点的一个数据项。下面的代码将这些数据复制到一个关联的容器中，触发网格的重新分配，并回收这些数据。

~~~C++
// Copy vertex data into associative container
using PersistentContainer = std::map<Grid::LocalIdSet::IdType, double>;
PersistentContainer persistentContainer;
const auto &idSet = grid -> localIdSet();

for (const auto &vertex : vertices(gridView))
    persistentContainer[idSet.id(vertex)] = dataVector[gridView.indexSet().index(vertex)];
// Distribute the grid and the data
LBVertexDataHandle<Grid, PersistentContainer>
    dataHandle(grid, persistentContainer);
grid->loadBalance(dataHandle);
// Get gridView again after load-balancing, to make sure it is up-to-date
gridView = grid->leafGridView();

// Copy data back into the array
dataVector.resize(gridView.size(dim));

for (const auto &vertex : vertices(gridView))
    dataVector[gridView.indexSet().index(vertex)] = persistentContainer[idSet.id(vertex)];

~~~

这个代码片段也取自第$6.7$章中的完整例子，在那里可以看到它的背景。

\subsection{Communication}

参与分布式仿真的不同进程需要相互通信。在有限元或有限体积计算中，有两种类型的通信。在`subdomain communication`期间，持有一个特定子域的进程与持有相邻子域的进程交换信息。相反，`collective communication`有时是必要的，所有进程与所有其他进程或主进程交谈。

\subsubsection{Subdomain Communication}

正如第6.1章所解释的，在分布式计算中，每个进程通常存储一个子域，也就是完整网格的一个连接部分。子域可以`overlap`与它们的邻居，这样的`overlap`区域的元素就存在于多个进程上。这些元素在一个进程上是`interior`类型，而在其他进程上是`overlap`或`ghost`类型。


作为任何解决PDE的数值算法的一部分，子域网格将不得不相互通信。这意味着附属于一个子域网格的数据需要被发送到其他进程。Dune网格接口的基本假设是，只需要为同样存在于其他子域的实体发送数据。因此，例如，在图6.2中，只有在至少一个进程上为黄色或绿色的元素的数据可以参与通信。这对于几乎所有经典的单级算法都是合理的 [148] 。Dune不直接支持分布式双网格方法，在同一领域的较粗和较细的网格之间也有通信。



子域通信是由网格实现提供的。网格接口允许指定需要发送和接收数据的实体集，以及一个回调机制，以便从其容器中获取数字数据。通信是由一个单一的方法`communicate`触发的，它是`GridView`接口类的一个成员方法。完整的签名是

~~~C++
template<class DataHandleImp, class DataType>
void communicate(CommDataHandleIF<DataHandleImp, DataType>& dataHandle,
                 InterfaceType ifType,
                 CommunicationDirection dir) const
~~~



这个方法的第一个参数是回调类，它将数字数据从其容器中传输到消息缓冲区，然后再返回。请注意，这个接口类与在负载平衡过程中用于数据传输的接口类是一样的。第二个参数指定了要进行数据通信的实体集，第三个参数选择了通信方向。由这种方法触发的通信是同步的，也就是说，进程的执行被阻止，直到整个通信完成。更有效的异步通信机制已经在 `ALUGrid` [^2] 中实现，并可能出现在 `dune-grid` 的未来版本中。

DUNE称交换数据的实体集合为 `communication interfaces` 。记得在第 $6.1$ 章中，子域的实体被分为五个分区类型 `interior` 、 `border` 、 `overlap` 、前部和 `ghost` ，而这些类型的组合被称为 `partition sets` 。一个通信接口只是一对分区集 $P_{1}$ 和 $P_{2}$ 。在通信步骤中，如果对于任何有效的二维$c$，存在二维$c$的实体，其在进程$i$上的分区类型是$P_{1}$，而在进程$j$上的分区类型是$P_{2}$，则进程$i$将向另一个进程$j$发送一个消息。从进程$i$到进程$j$的消息包含来自进程$i$上的每个实体的数据，这些实体的分区类型在$P_{1}$上存在，并且在那里有一个分区类型在$P_{2}$。这在 [Fig6.6] 中得到了说明。

在DUNE网格接口中，通信接口被实现为一个枚举类型 `InterfaceType` ，定义在文件 `dune/grid/common/gridenums.hh` 中。

它可以取值

$$
InteriorBorder\_InteriorBorder\_Interface,\\
InteriorBorder\_All\_Interface,\\
Overlap\_OverlapFront\_Interface,\\
Overlap\_All\_Interface,\\
All\_All\_Interface.\\
$$


当 `GridView::communicate` 方法的第三个参数被设置为值ForwardCommunication时，不同的 `InterfaceType` 值实现的通信模式如 [Fig6.6] 所示。为了有更多的选择，可以通过将 `GridView::communicate` 的第三个参数设置为 `BackwardCommunication` 来反转通信方向。

指定要发送的实际数据，重用了回调的想法和已经用于负载平衡的接口类`CommDataHandleIF`。`communicate`方法被赋予了一个数据处理类，该类将数据复制到消息缓冲区或从消息缓冲区复制出来。然而，与负载均衡的情况不同，网格本身并没有变化。因此，实体的编号在通信过程中保持不变，而且在给数据句柄之前，不需要将数据复制到关联数组中。作为一个例子，我们在这里展示了一个用于顶点数据通信的完整的数据句柄实现，它取自第6.7章的例子。

~~~C++
template <class GridView, class Vector>
struct VertexDataUpdate
    : public Dune::CommDataHandleIF<VertexDataUpdate<GridView, Vector>,
                                    typename Vector::value_type>
{
    using DataType = typename Vector::value_type;

    // Constructor
    VertexDataUpdate(const GridView &gridView,
                     const Vector &userDataSend,
                     Vector &userDataReceive)
        : gridView_(gridView),
          userDataSend_(userDataSend),
          userDataReceive_(userDataReceive)
    {
    }

    // True if data for this codim should be communicated
    bool contains(int dim, int codim) const
    {
        return (codim == dim); // Only vertices have data
    }

    // True if data size per entity of given codim is constant
    bool fixedSize(int dim, int codim) const
    {
        return true; // All vertices carry the same number of data items
    }

    // How many objects of type DataType have to be sent for a given entity
    template <class Entity>
    size_t size(const Entity &e) const
    {
        return 1; // One data item per vertex
    }

    // Pack user data into message buffer
    template <class MessageBuffer, class Entity>
    void gather(MessageBuffer &buffer, const Entity &entity) const
    {
        auto index = gridView_.indexSet().index(entity);
        buffer.write(userDataSend_[index]);
    }

    // Unpack user data from message buffer
    template <class MessageBuffer, class Entity>
    void scatter(MessageBuffer &buffer, const Entity &entity, size_t n)
    {
        assert(n == 1);
        DataType x;
        buffer.read(x);

        userDataReceive_[gridView_.indexSet().index(entity)] += x;
    }

private:
    const GridView gridView_;
    const Vector &userDataSend_;
    Vector &userDataReceive_;
};

~~~





与第 $6.3$ 章的负载平衡数据处理实现相比，只有微小的差别。行`contains`、`fixedSize`和`size`中的方法是相同的，因为两个数据处理类都是处理顶点数据的单项。另一方面，数据句柄直接操作数字数据的数组，因为网格在通信过程中不会改变，因此可以使用IndexSet对象。因此，构造函数接收数据数组，而不是像章 $6.3$ 中的关联容器。

`gather`方法与负载平衡数据句柄的`gather`方法的作用相同：它获取当前实体（在这个例子中是一个顶点）的单一数据项，并将其写入消息缓冲区。然而，`scatter`方法则不同。与负载平衡的情况不同，该方法从消息缓冲区中读取数据项，并$a d d s$它到那里的相应值。这样，在调用`communicate`之后，与存在于一个以上进程的顶点相关的每个值都是它在不同进程中的所有值的总和。第$6.7$章将表明这正是应用程序所要求的。也请参考该章，看看数据处理类在代码中是如何使用的。

\subsubsection{Collective Communication}

虽然上一节的数据交换机制涵盖了数值算法中出现的大多数通信模式，但有时非局部通信是必要的。这常常意味着一些简单的事情，比如向所有进程发送一组求解器参数，或者计算标量乘积所需的全局和。涉及所有进程的通信被称为 `collective communication` 。

集体通信并不直接涉及网格，因此可以使用任何通用的分布式计算库。现在，这很可能是MPI的一个实现。然而，直接使用MPI的硬编码迫使用户在任何时候都要安装MPI，而在许多情况下，如果代码在没有安装MPI的情况下也能使用，那就很方便。

由于这些原因，`dune-grid`模块为常用的`collective communication`功能提供一个接口。该接口在很大程度上受到MPI的启发，但也可能有其他的实现方式。特别是，存在一个顺序实现，在没有安装MPI的情况下使用。这允许编写使用像MPI一样的通信层的程序，但如果在构建时没有安装这样的库，就会优雅地退化为一个工作的单进程实现。

`dune-grid`的这个抽象层是以一个单一的类的形式出现的

~~~C++
template<class Communicator>
class CollectiveCommunication
~~~

`collective communication`机制的不同实现被作为该类的特化而给出，它们由`Communicator`模板参数选择，该参数应该是消息传递实现所使用的通信器类型。对于MPI来说，这将是`MPI_Comm`，这是一个由MPI实现定义的类型。对于顺序代码，有一个假的通信器 `No_Comm` ，在文件 `dune/common/parallel/communication.hh` 中定义。我们假设其他消息传递系统有一个与MPI通信器相当的概念，这原则上允许为它们对`CollectiveCommunication`类进行专业化。

`CollectiveCommunication`类没有公共构造函数。一个`CollectiveCommunication`类型的对象是通过调用以下方法获得的

~~~C++
const CollectiveCommunication& comm() const
~~~


由每个DuNE网格和每个DuNE网格视图提供。没有实现分布式功能的网格会返回`CollectiveCommunication`的顺序实现，即`CollectiveCommunication<No_Comm>`，它模仿了MPI等价物在单个进程上运行时的情况。也可以通过使用下面第$6.5$章中描述的`MPIHelper`类，获得一个没有网格的`CollectiveCommunication`对象。





`CollectiveCommunication`的成员方法封装了一组最重要的MPI通信例程。首先，有几个方法

~~~C++
int rank() const
int size() const
~~~


其中提供了本地进程等级和通信器中的进程总数。另外，该方法

~~~C++
operator MPI_Comm() const
~~~

允许将`CollectiveCommunication`对象转换为`MPI_Comm`类型的对象（如果没有安装MPI，则为`No_Comm`），并返回当前正在使用的MPI通信器。

~~~C++
MPI_Comm communicator = gridView.comm();
~~~


然后，有一套算术方法。比如说。
~~~C++
template<class T>
T max(T& in) const
~~~


计算所有进程中参数的最大值，并返回每个进程中的结果。同样地，方法

~~~C++
template<class T>
int max(T* inout, int len) const
~~~

计算长度为len的数组inout的每个分量在所有进程中的最大值，并返回每个进程中的结果。对于最小值、总和和积也有相应的方法。查看在线文档以获得最新的列表。这些方法都是对一个未指定的数字类型 $\mathrm{T}$ 进行操作。假设$\mathrm{T}$是一个可以用于MPI集体通信方法的类型。

然后，有一些一般的全局通信方法，列在[Tab6.2]中。它们中的大多数涉及从所有进程发送或接收一组数据。比如说。

~~~C++
template<class T>
int broadcast(T* inout, int len, int root) const
~~~

将数组`inout`的内容从编号为`root`的进程发送到所有其他进程。该方法

~~~C++
template<class T>
int gather(const T* in, T* out, int len, int root) const
~~~


反过来，从根号的进程上收集所有进程的数据。这些都是对MPI函数的薄层包装，具有更方便的语法，我们请读者参阅MPI文档以了解细节。由这些方法返回的`int`值是MPI错误代码。如果一切顺利，则返回数字0（意味着`MPI_SUCCESS` ）。非零返回值标志着错误。

\subsection{MPI Setup with the MPIHelper Class}

MPI消息传递系统需要在实际程序开始前运行一个设置程序。因此，每个使用MPI的$\mathrm{C}++$程序都需要以以下一行开始

~~~C++
MPI_Init(&argc, &argv);
~~~

其中做了这个设置。同样地，在终止程序之前。

~~~C++
MPI_Finalize();
~~~

需要被调用，以正确关闭MPI。当然，如果代码中包含这些行，必须安装MPI才能构建代码。

上一节已经论证了，即使没有MPI也能构建和运行的分布式代码是可取的。它描述了一种通信机制，允许MPI程序在构建时没有安装MPI的情况下至少可以按顺序运行。为了使该机制全面发挥作用，它需要涵盖MPI的启动。DUNE对此有 `MPIHelper` 单元，它在文件 `dune/common/parallel/mpihelper.hh` 中提供。如果安装了MPI，它的构造函数会执行MPI的设置，但如果没有，则什么也不做。该构造函数在第一次请求单子实例时被调用，这可以通过调用

~~~C++
MPIHelper::instance(argc, argv);
~~~

在构建时，这个调用将简单地转化为

~~~C++
MPI_Init(&argc, &argv);
~~~

如果安装了MPI。`MPIHelper`的析构器包含对`MPI_Finalize`的调用，因此不需要明确的关闭代码。如果没有安装MPI，那么构造函数和析构函数是空的。因此，如果

~~~C++
MPIHelper::instance(argc,argv);
~~~

是`main`方法的第一行，那么该程序将在顺序和并行的情况下建立和运行。

`MPIHelper`可以做得更多，但为此必须获得实际的单子对象。

~~~C++
const MPIHelper& mpiHelper = MPIHelper::instance(argc,argv);
~~~

`mpiHelper`对象有方法

~~~C++
int rank() const
int size() const
~~~

这允许确定当前进程的等级，以及进程的总数。这些数字总是指`MPI_COMM_WORLD`--注意，这可能不是网格使用的通信器。如果没有安装MPI，`rank`和`size`分别返回0和1。

`MPIHelper` 也提供了它的通信器本身。该类型可作为 `MPIHelper::MPICommunicator` 。该对象可以通过以下方法获得

~~~C++
static MPICommunicator getCommunicator()
~~~

它返回 `MPI_COMM_WORLD` 或一个 `No_Comm` 类型的对象。同样地，方法

~~~C++
static MPICommunicator getLocalCommunicator()
~~~

返回 `MPI_COMM_SELF` 或一个 `No_Comm` 类型的对象。最后，`MPIHelper`通过方法为其通信器发放一个`CollectiveCommunication`对象

~~~C++
static CollectiveCommunication getCollectiveCommunication()
~~~

它提供了第 $6.4.2$ 章中描述的全部全球通信基础设施。

\subsection{Writing Distributed Grids to VTK Files}

编写网格以及相关的顶点和元素数据在第 $5.8$ 章中已经详细讨论过了。当网格被分布时，其中的变化很小。和以前一样，将网格写入VTK文件的形式为

~~~C++
VTKWriter<GridView> vtkWriter(gridView);
// Attach numerical data to ’vtkWriter’ object
// ...
vtkWriter.write("filename");
~~~


然而，`write`方法的行为略有变化。从等级为$k$的进程中调用写法，将只写该本地进程上的网格（更准确地说：`InteriorBorder_Partition` ）。它还会在文件名前加上字符串`s\#\#\#\#-p##\#\#-`，其中$\#$的第一块被替换为进程总数，第二块被替换为进程等级$k$（都有前导零）。与顺序的情况一样，包括前缀和后缀的完整文件名作为`write`方法的返回值被返回。

为一个分布式网格调用 `write` 将使用户为每个子域留下一个单独的文件。这些文件通过一个额外的文件，即所谓的 `parallel file` ，被识别为一个更大的整体的一部分。如果有一个以上的进程调用写入，这个文件也会被写入写入方法，它的文件扩展名为 `.pvtu` 。它主要保存了构成整个网格的所有`.vtu`文件的列表，以及每个子域文件中预计包含的数据字段的列表。当加载`parallel file`到
ParaView时，那里引用的所有子域文件也会被加载，整个集合被视为一个单一的网格对象。



如果进程的数量很大，文件的数量就会让人喘不过气来。为了保持一点秩序，有第二种写入方法，它将不同类型的文件放入不同的目录。这种方法被称为`pwrite`（代表 "路径写入"）。

~~~C++
std::string pwrite(const std::string& name,
                    const std::string& path,
                    const std::string & extendpath,
                    VTK::OutputType type = VTK::ascii)
~~~


除了`name`和`type`两个参数外，它还接受两个额外的字符串参数`path`和`extendpath` 。第一个参数给出了放置`.pvtu`文件的目录名称。(和以前一样，名称字符串本身不应该包含目录部分，也没有文件类型扩展名）。)`extendpath`包含各个子域文件被写入的目录路径（相对于路径！）。这第二个字符串可以包含等级编号，因此不仅可以将`parallel file`与子域文件分开，还可以将不同等级的子域文件相互分开。这在编写与时间有关的数据时可能很有用，因为这会导致大量的文件。

要使用pwrit-facilities来写入随时间变化的数据，请记住，第`VTKSequenceWriter`章中介绍的$5.8.2$类有一个单独的构造函数

~~~C++
VTKSequenceWriter(std::shared_ptr<VTKWriter<GridView> > vtkWriter,
                  const std::string& name,
                  const std::string& path,
                  const std::string& extendpath)
~~~


`vtkWriter`参数是`VTKWriter`对象，它将进行单个数据文件的写入。三个字符串参数的含义与`pwrite`方法中的相同。当`write`类的`VTKSequenceWriter`方法被调用时，它将使用字符串参数中给出的名称和路径。`.pvtu`文件进入path，`.vtu`文件进入`path/extendpath` 。`.pvd`文件总是被写入当前目录，因此可以将pvtu、`.vtu`和`.pvd`文件都放在不同的位置。

\subsection{Example: The Poisson Equation on a Distributed Grid}

现在我们把本章讨论的功能结合到一个完整的例子中。由于这些功能都是相当低级的，所以代码有点啰嗦。在`dune-istl`和`dune-pdelab`模块中，有更高层次的分布式计算的接口，但超出了本书的范围。



这个例子程序是介绍性的第三章的`Poisson`求解器的扩展。事实上，两者都有很多共同的代码，因此这里将不介绍新程序的所有部分。像往常一样，整个示例代码都包含在9h一个文件中，它的全部内容出现在附录B.6中。本文件的电子版（副本）的读者也可以通过点击边缘的图标找到该文件。

该程序解决的问题与第$3.3$章中的问题完全相同，即泊松方程

$$
-\Delta u=-5
$$

在[Fig6.7]中所示的L形域上，边界条件为

\begin{equation}
\begin{aligned}
u &= \begin{cases}0 & \text { on }\{0\} \times[0,1] \cup[0,1] \times\{0\}, \\
0.5 & \text { on }\{0.5\} \times[0.5,1] \cup[0.5,1] \times\{0.5\}\end{cases} \\
\langle\nabla u, \mathbf{n}\rangle &=0 \quad \text { elsewhere. }
\end{aligned}
\label{6.1}
\end{equation}

然而，与原始代码不同的是，这里的例子将网格分布在几个进程中，然后实现一个分布式共轭梯度（CG）方法，其`Jacobi preconditioner` 。虽然对于这类问题来说，这不是一个非常强大的预处理程序，但只用到目前为止所涉及的DUNE的低级功能就可以轻松实现。我们将使用非重叠分解，并实现该算法，使其无论使用多少进程都能产生完全相同的迭代结果。

这个网格也显示在[Fig6.7]中，是第$3.3$章中的网格的两次统一细化版本，因为原始网格太粗，无法在几个过程中进行体面的分布。Gmsh网格文件被嵌入到本文的电子版中，可以通过页边的图标获得。

我们使用一阶`Poisson`有限元对`Lagrange`方程进行离散。使用更高阶的元素也可以类似地实现，但会使代码更具技术性。这个例子程序使用了`dune-functions`模块的功能来组装问题，就像第三章的`Poisson`例子一样，但它实现了实际的分布式方程求解，没有得到`dune-functions`的帮助。

\subsubsection{Setting up the Distributed Algebraic Problem}

我们首先讨论分布式代数问题是如何设置的。这涉及到加载和分布网格，并行组装子域代数问题，并在每个过程中设置正确的边界条件。所有这些都发生在主方法中，我们现在就来看看这个方法。它的大部分内容在第三章中都是熟悉的。该方法从设置`MPIHelper`实例开始。

~~~C++
 int main(int argc, char *argv[])
 {
 // Set up MPI
    const MPIHelper& mpiHelper = MPIHelper::instance(argc, argv);
~~~


我们存储一个对`MPIHelper`实例的引用，以后用它来获得进程等级。然后，我们构建一个`UGGrid`对象，并从文件`l-shape-refined.msh`中加载[Fig6.7]所示的网格。

~~~C++
 constexpr int dim = 2;
 using Grid = UGGrid<dim>;
 using GridView = Grid::LeafGridView;

 std::shared_ptr<Grid> grid = GmshReader<Grid>::read("l-shape-refined.msh");
 auto gridView = grid->leafGridView();
~~~



这看起来像顺序设置中的网格设置；然而，在内部，`GmshReader`对象只将网格加载到进程0的`UGGrid`对象中，而使所有其他进程为空。这样一来，网格就需要被明确地分配。

在这一点上，这个例子变得有点矫揉造作。为了分配网格，我们可以简单地调用

~~~C++
grid->loadBalance();
~~~


并完成它。然而，我们希望这个例子也能展示数据传输的负载平衡。为此，我们在主进程上为CG求解器构建一个初始迭代，然后将其与网格一起分发。初始迭代是对函数的点式评估

$$
u_{0}: \mathbb{R}^{2} \rightarrow \mathbb{R}, \quad u_{0}\left(x_{0}, x_{1}\right)=\min \left\{x_{0}, x_{1}\right\}
$$

这符合 `Dirichlet` 边界条件 \ref{6.1} 。下面的代码块设置了这个函数，并在主进程的顶点上对其进行采样。

~~~C++
std::vector<double> dataVector;

if (mpiHelper.rank() == 0)
{
    // The initial iterate as a function
    auto initialIterate = [](auto x)
    { return std::min(x[0], x[1]); };

    // Sample on the grid vertices
    dataVector.resize(gridView.size(dim));
    for (const auto &vertex : vertices(gridView,
                                       Dune::Partitions::interiorBorder))
    {
        auto index = gridView.indexSet().index(vertex);
        dataVector[index] = initialIterate(vertex.geometry().corner(0));
    }
}
~~~



网格和dataVector数组中的顶点数据现在可以分布在可用的进程中。为此，首先需要将其复制到一个关联容器中，因为用于寻址数组的索引会在负载平衡过程中发生变化（见第6.3章）。

~~~C++
 // Distribute the grid and the data
 LBVertexDataHandle<Grid, PersistentContainer>
                    dataHandle(grid, persistentContainer);
 grid->loadBalance(dataHandle);
~~~


接下来是实际的负载平衡。



第393行设置了一个自定义数据处理类的对象 `LBVertexDataHandle` 。它的实现出现在示例文件的顶部附近，在第6.3章中已经详细讨论过了。它实现了在负载平衡过程中对`persistentContainer`中顶点数据传输的回调。`LBVertexDataHandle`类的构造函数接收分层网格和数据容器，然后整个数据处理对象被传递给网格的`loadBalance`方法。注意，`LBVertexDataHandle`的构造函数不是网格接口的一部分，但可以接受任何数量的参数以适应应用的需要。

在调用`loadBalance`后，每个可用的进程都有网格的一部分。  [Fig6.4], 左边显示了程序在四个进程上运行时得到的分解结果。注意子域网格如何由`interior`元素和`ghost`元素组成。在这个例子中，使用了简单的内置`UGGrid`分区器。

最后，`dataVector`数组被调整为新的子域大小，并将数据复制回其中。

~~~C++
 // Get gridView again after load-balancing, to make sure it is up-to-date
 gridView = grid->leafGridView();

 // Copy data back into the array
 dataVector.resize(gridView.size(dim));

 for (const auto& vertex : vertices(gridView))
    dataVector[gridView.indexSet().index(vertex)]
        = persistentContainer[idSet.id(vertex)];
~~~



注意，`gridView`对象需要被刷新（在第399行），因为它不能保证在分层网格变化时保持最新。

下一个区块是第3.3章代码的副本：它选择矢量和矩阵数据类型，分别为载荷矢量和刚度矩阵构造空对象b和`stiffnessMatrix`，并为一阶拉格朗日有限元空间组装它们。

~~~C++
 using Matrix = BCRSMatrix<double>;
 using Vector = BlockVector<double>;

 Matrix stiffnessMatrix;
 Vector b;

 auto sourceTerm = [](const FieldVector<double,dim>& x){return -5.0;};

 // Assemble the Poisson system in a first-order Lagrange space
 Functions::LagrangeBasis<GridView,1> basis(gridView);
 assemblePoissonProblem(basis, stiffnessMatrix, b, sourceTerm);
~~~



方法`assemblePoissonProblem`进行实际组装。它与第$3.3$章中的相应方法相同，但有一个小但重要的例外。在顺序代码中，第57页第230行的源代码中所有元素的循环形式为

~~~C++
for (const auto& element : elements(gridView))
{
// ...
}
~~~


在分布式设置中，这个循环将遍历子域的所有元素，包括`ghost`元素。然而，这个例子使用了矩阵和负载向量的加法分解，并且必须将循环限制在`interior`元素上。因此，在并行代码中，该循环被替换为


~~~C++
for (const auto& element : elements(gridView,Partitions::interior))
{
// ...
}
~~~



下一步是为预处理程序做准备。为了使CG方法并行化，我们假设将域$\Omega$划分为子域`nonoverlapping` 。然后每个进程只在其子域的`interior`元素上装配矩阵和右手向量。结果是载荷向量 `additive` 和刚度矩阵 $A$ 的 $b$ 分解。它们对应于`interior`顶点的值是正确的--它们与在非分布式网格上装配得到的值相匹配。然而，位于子域边界的顶点上的条目缺乏在不同子域中的相邻元素的积分贡献。相反，真实的值是由不同过程中顶点的所有副本的值相加得到的。

对于像迭代数和修正数这样的其他量，我们需要`consistent`表示，即即使在子域边界也有正确的值的系数向量。一致性表征可以通过一步接口通信从加性表征构造出来。一般的规则是，像迭代和修正这样的原始对象需要在一致表示中可用，而像载荷向量和矩阵这样的对偶对象只需要在加性表示中可用。

我们刚刚组装的刚度矩阵是用加法表示的。然而，我们下面要使用的`Jacobi preconditioner`，将需要矩阵`diagonal`的一致表示。因此，下面的代码块会触发一个子域通信，将矩阵`diagonal`的相关部分加在一起。

~~~C++
 Vector diagonal(basis.size());
 for (std::size_t i=0; i<basis.size(); ++i)
 diagonal[i] = stiffnessMatrix[i][i];

 auto consistentDiagonal = diagonal;
 VertexDataUpdate<GridView,Vector> matrixDataHandle(gridView,
                                                    diagonal,
                                                    consistentDiagonal);

 gridView.communicate(matrixDataHandle,
                      InteriorBorder_InteriorBorder_Interface,
                      ForwardCommunication);
~~~


为此，首先将`diagonal`复制到一个名为`diagonal`的数组中。这不是严格意义上的需要，但它避免了为矩阵对角线写一个单独的数据处理。然后，数组`diagonal`被复制到第二个数组`consistentDiagonal`中，尽管它的名字叫 "`diagonal`"，但此时它只包含本地子域的矩阵`diagonal`贡献。然后代码构建了一个类型为 `VertexDataUpdate` 的对象。这是一个数据处理的实现，在第6.4章已经讨论过了。它从一个输入数组中获取顶点数据，并将其添加到输出数组中的顶点数据。对数组`diagonal`和`consistentDiagonal`应用这个方法的结果是在`consistentDiagonal`数组中对矩阵`diagonal`的一致表示。

实际的通信发生在对线 $441$ 中的通信方法的调用。它被赋予数据句柄和通信接口，即参与通信的实体集合。在这个例子中，我们需要发送和接收`border`实体上的数据。包含这些的最小的通信接口正是 `InteriorBorder_InteriorBorder_Interface` 。

作为最后的设置步骤，代数系统必须被修改以考虑到`Dirichlet`的边界条件。由于这个例子使用基于位置的标准来确定`Dirichlet`的自由度，当网格被分布时，代码不会改变。就像在顺序执行中一样，下面的代码块决定了`Dirichlet`的自由度。


~~~C++
 auto dirichletPredicate = [](auto p)
 {
    return p[0]< 1e-8 || p[1] < 1e-8 || (p[0] > 0.4999 && p[1] > 0.4999);
 };

 // Interpolating the predicate will mark
 // all desired Dirichlet degrees of freedom
 std::vector<bool> dirichletNodes;
 Functions::interpolate(basis, dirichletNodes, dirichletPredicate);
~~~


相应的`Dirichlet`值已经包含在`dataVector`阵列中。然后按照第2.1.4章所述，修改刚度矩阵和载荷向量。

~~~C++
// Loop over the matrix rows
for (size_t i = 0; i < stiffnessMatrix.N(); i++)
{
    if (dirichletNodes[i])
    {
        auto cIt = stiffnessMatrix[i].begin();
        auto cEndIt = stiffnessMatrix[i].end();
        // Loop over nonzero matrix entries in current row
        for (; cIt != cEndIt; ++cIt)
            *cIt = (i == cIt.index()) ? 1.0 : 0.0;

        // Modify corresponding load vector entry
        b[i] = dataVector[i];
    }
}
~~~


请看第$3.3.1$章，了解更多细节。

\subsubsection{The Distributed Preconditioned CG Method}

代码的其余部分实现了分布式共轭梯度（CG）方法 [^138] [^146] 。这个实现是这样的：每个迭代都与顺序的CG实现产生的结果相同。这在效率方面可能不是最佳的，但它使代码更容易解释。

对于一个对称的正定矩阵$A$，预处理的CG方法可以解决线性方程组

$$
A x=b
$$



通过沿搜索方向$J(x):=\frac{1}{2} x^{T} A x-b^{T} x$连续最小化函数$d_{0}, d_{1}, d_{2}, \ldots$，在$A$的假设下，$J$的最小化器是$A x=b$的解。给定一个初始迭代$x^{0}$，第一个搜索方向是

$$
d_{0}:=W^{-1} r^{0}=W^{-1}\left(b-A x^{0}\right)
$$

数量$r^{0}:=b-A x^{0}$是`residual`，而矩阵$W$是预处理程序。它是$A$的近似值，经常只以算法的形式给出，从`residual`向量$r$计算出$W^{-1} r$。本例使用`Jacobi preconditioner` $W=\operatorname{diag}\left(A_{11}, \ldots, A_{n n}\right)$ ，这样$d_{0}$是由$r^{0}$通过分量除以矩阵`diagonal`元素计算出来的。给定一个当前迭代$x^{k} \in \mathbb{R}^{n}$和一个方向$d_{k} \in \mathbb{R}^{n}$，然后该方法执行一个直线搜索步骤

$$
x^{k+1}:=x^{k}+\alpha^{k} d_{k}
$$

其中步长$\alpha^{k}$由以下公式给出

$$
\alpha^{k}:=\frac{\left\langle r^{k}, W^{-1} r^{k}\right\rangle}{\left\langle d_{k}, A d_{k}\right\rangle}
$$

最后，该方法更新了`residual`。

$$
r^{k+1}:=r^{k}-\alpha^{k} A d_{k}
$$

并使用`Gram-Schmidt`正交计算出一个新的搜索方向

$$
\begin{aligned}
&\beta_{k+1}:=\frac{\left\langle r^{k+1}, W^{-1} r^{k+1}\right\rangle}{\left\langle r^{k}, W^{-1} r^{k}\right\rangle} \\
&d_{k+1}:=W^{-1} r^{k+1}+\beta_{k+1} d_{k}
\end{aligned}
$$

迭代持续到$r^{k}$变得适当小。

为了将这种方法应用于分布式线性方程组，请注意CG方法主要由标量和矩阵-向量乘积组成。如果矩阵和`residuals`保持加法表示，并且迭代和方向保持一致表示，那么在非重叠分布式环境中，这些都很容易计算。例如，在这种情况下

\begin{equation}
\langle v, w\rangle=\left\langle v_{\text {add }}, w_{\text {cons }}\right\rangle=\sum_{i=1}^{N}\left\langle v_{\text {add }}^{i}, w_{\text {cons }}^{i}\right\rangle
\label{6.2}
\end{equation}

其中$v_{\text {add }}^{i}$和$w_{\text {cons }}^{i}$分别是子域$v$和$w$上向量的加性和一致性表示，$N$是子域的总数。因此，计算分布式标量积只涉及每个进程上的一个局部标量积，以及一个全局通信的总和。

实现分布式CG算法的代码首先设置了初始迭代和两个参数。


~~~C++
 // Set the initial iterate
 Vector x(basis.size());
 std::copy(dataVector.begin(), dataVector.end(), x.begin());

 // Solver parameters
 double reduction = 1e-3; // Desired residual reduction factor
 int maxIterations = 50; // Maximum number of iterations
~~~


被采样到dataVector数组中的`Dirichlet`边界值被用作初始迭代，因为这是获得包含正确的`Dirichlet`边界值的初始迭代向量的一种简单方法。

然后代码从负载向量`residual`$r^{0}=b-A x^{0}$和初始迭代中计算出$b$。


~~~C++
 auto r = b;
 stiffnessMatrix.mmv(x,r); // r -= Ax
~~~

方法$\mathrm{mmv}$是`dune-istl`模块的矩阵接口的一部分（第一章$7.3$）。它在一个有效的方法中实现了两个操作$r-=A * x$。由于$x$是以一致表示法给出的，而$A$和$b$是以加法表示法给出的，所以`residual`是以加法表示法得到的。

代码将通过跟踪残差的规范来监控收敛。为了实现与缩放有关的不变性，残差被初始迭代的`residual`归一化。计算这个初始`residual`的规范是需要通信的第一个操作。法线的计算是通过局部取加法`residual`（在$\mathrm{r}$中）与其一致表示的标量乘积，然后像\ref{6.2}那样在所有进程中对结果求和。这两个步骤分别使用第6.4.1章的子域通信接口和第6.4.2章的集体通信接口。请注意，向量的一致表示是由其加法表示得到的，取后者，对于`border`分区中的每个顶点，加上其他子域的相应条目。因此，适当的通信接口是`InteriorBorder_InteriorBorder_Interface`，对于顶点数据，只在`border`分区上进行通信。对于数据处理，可以使用`VertexDataUpdate`类，它已经被用来计算一致性矩阵 `diagonal` 。代码创建了一个变量`rConsistent`，将用于存储残差的一致表示，并用变量rhs的内容对其进行初始化，该变量包含残差的加法表示。然后，它用输入变量$r$和输出变量`rConsistent`设置了一个数据句柄，并进行一次通信。

~~~C++
 // Construct consistent representation of the data in r
 auto rConsistent = r;

 VertexDataUpdate<GridView,Vector> vertexUpdateHandle(gridView,
                                                      r,
                                                      rConsistent);

 gridView.communicate(vertexUpdateHandle,
                      InteriorBorder_InteriorBorder_Interface,
                      ForwardCommunication);
~~~




在此之后，`rConsistent`包含`residual`$r^{0}$的一致表示。为了计算其规范，我们取$r$与`rConsistent`的局部标量乘积，并将结果在所有过程中求和。

~~~C++
double defect0 = r.dot(rConsistent); // Norm on the local process
defect0 = grid->comm().sum(defect0);
defect0 = sqrt(defect0);
~~~


请注意第515行是如何使用Chapter $6.4.2$中的集体通信对象来计算全局和的。在这里直接使用MPI会更加冗长，有了集体通信对象，在没有安装MPI的情况下，代码甚至可以正常编译和运行。

作为下一步，代码会打印出初始残差的规范。请注意，这只发生在等级为0的过程中。如果没有这个限制，每个参与的过程都会有屏幕输出，这将是不可读的。

~~~C++
 if (mpiHelper.rank()==0)
 {
    std::cout << " Iteration Defect Rate" << std::endl;;
    std::cout << " 0" << std::setw(16) << defect0 << std::endl;
 }
~~~



然后，下面的代码通过预处理残差来设置初始搜索方向$d_{0}$，即通过计算$d_{0}=W^{-1} r^{0}$ 。

~~~C++
 // Construct initial search direction in variable d by applying
 // the Jacobi preconditioner to the residual in r.
 Vector d(r.size());
 for (std::size_t i=0; i<stiffnessMatrix.N(); ++i)
 {
    d[i] = 0;
    if (std::abs(consistentDiagonal[i]) > 1e-5) // Degree of freedom
                                                // is not on ghost vertex
        d[i] = rConsistent[i] / consistentDiagonal[i];
 }

~~~


$i^{th}$的条目$d_{0}$只是$\left(r^{0}\right)_{i} / A_{i i}$ 。然而，由于搜索方向是一个原始量，它的一致性表示是必需的。因此，代码必须使用`residual`和矩阵`diagonal`的一致表示来计算搜索方向。对非零`diagonal`项的检查剔除了那些对应于`ghost`顶点的自由度。

最后，代码计算出数量$\rho_{0}:=\left\langle r^{0}, W^{-1} r^{0}\right\rangle$，它被用于步长$\alpha_{0}$和`Gram-Schmidt`正交化系数$\beta_{k+1}:$的公式。

~~~C++
 double rho = d.dot(r);
 rho = grid->comm().sum(rho);
~~~


如$W^{-1} r^{0}=d_{0}$，这只是一个加法和一个一致的向量之间的标量积，用局部标量积和全局和很容易计算出来。

在这些准备工作之后，开始实际的迭代循环。它被实现为一个标准的for-loop，带有迭代计数器 $\mathrm{k}$ 。循环中的第一个任务是计算直线搜索的步长

$$
\alpha^{k}=\frac{\left\langle r^{k}, W^{-1} r^{k}\right\rangle}{\left\langle d_{k}, A d_{k}\right\rangle}
$$

为方向 $d_{k}$ 。

~~~C++
 // Current residual norm
 double defect=defect0;

 for (int k=0; k<maxIterations; ++k)
 {
        // Step length in search direction d
        Vector tmp(d.size());
        stiffnessMatrix.mv(d,tmp); // tmp=Ad^k
        double alphaDenom = d.dot(tmp); // Scalar product
        alphaDenom = grid->comm().sum(alphaDenom);
        double alpha = rho/alphaDenom;

~~~



注意，变量`rho`已经包含了步长$\alpha^{k}$表达式中的分子$\left\langle r^{k}, W^{-1} r^{k}\right\rangle$ 。分母$\left\langle d_{k}, A d_{k}\right\rangle$是一个原始量和对偶量之间的标量乘积，可以用通常的方法计算。知道了步长$\alpha^{k}$就可以设置新的迭代了

$$
x^{k+1}=x^{k}+\alpha^{k} d_{k}
$$

使用线

~~~C++
x.axpy(alpha,d); // Update iterate
~~~


`dune-istl`矢量数据类型的`axpy`方法在一个方法中实现了$\mathrm{x}+= alpha*d $。更新`residual`使用的公式是

$$
r^{k+1}=b-A x^{k+1}=r^{k}-\alpha^{k} A d_{k}
$$

编码为

~~~C++
r.axpy(-alpha,tmp); // Update residual
~~~


这比从头开始重新计算`residual`的效率更高。

然后代码再次计算`residual`准则，将其打印到屏幕上，并检查它是否小到可以终止迭代。这些都没有使用任何新的功能。

~~~C++
// Compute residual norm again
rConsistent = r;
gridView.communicate(vertexUpdateHandle,
                     InteriorBorder_InteriorBorder_Interface,
                     ForwardCommunication);

auto residualNorm = r.dot(rConsistent);
residualNorm = grid->comm().sum(residualNorm);
residualNorm = sqrt(residualNorm);

if (mpiHelper.rank() == 0)
{
    std::cout << std::setw(5) << k + 1 << " ";
    std::cout << std::setw(16) << residualNorm << " ";
    // Estimated convergence rate
    std::cout << std::setw(16) << residualNorm / defect << std::endl;
}

defect = residualNorm; // Update norm

if (defect < defect0 * reduction) // Convergence check
    break;
~~~


最后一项任务是计算`Gram-Schmidt`系数

$$
\beta_{k+1}:=\frac{\left\langle r^{k+1}, W^{-1} r^{k+1}\right\rangle}{\left\langle r^{k}, W^{-1} r^{k}\right\rangle}
$$

和新的搜索方向

$$
d_{k+1}=W^{-1} r^{k+1}+\beta_{k+1} d_{k}
$$

$\beta_{k+1}$的分母已经从计算步长$\alpha^{k}$中得知，但是分子需要再次调用预处理程序。请注意对应于`ghost`顶点的自由度又必须被跳过。我们使用变量 `rhoNext` 作为 $\beta_{k+1}$ 的分母。

~~~C++
    // Precondition the residual
    Vector preconditionedResidual(d.size());
    for (std::size_t i = 0; i < stiffnessMatrix.N(); i++)
    {
        preconditionedResidual[i] = 0;
        if (std::abs(consistentDiagonal[i]) > 1e-5) // Degree of freedom
            // not on ghost vertex
            preconditionedResidual[i] = rConsistent[i] / consistentDiagonal[i];
    }
    
    double rhoNext = preconditionedResidual.dot(r);
    rhoNext = grid->comm().sum(rhoNext);
    double beta = rhoNext / rho;
    
    // Compute new search direction
    d *= beta;
    d += preconditionedResidual;
    rho = rhoNext; // Remember rho for the next iterate
}
~~~



第612行的大括号结束了共轭梯度循环。剩下的就是把结果写到VTK文件中。为了更漂亮的可视化，我们写了一个额外的元素数据字段，其中包含过程编号（ [Fig6.8] )


~~~C++
 // For visualization: Write the rank number for each element
 MultipleCodimMultipleGeomTypeMapper<GridView>
 elementMapper(gridView,mcmgElementLayout());

 std::vector<int> ranks(elementMapper.size());
 for (const auto& element : elements(gridView))
    ranks[elementMapper.index(element)] = mpiHelper.rank();

 VTKWriter<GridView> vtkWriter(gridView);
 vtkWriter.addVertexData(x, "solution");
 vtkWriter.addCellData(ranks, "ranks");
 vtkWriter.write("grid-distributed-poisson-result");

~~~



对`VTKWriter`对象的处理与顺序设置中的相同，但它自动适应了分布式情况。每个进程写一个只包含该进程的`interior`元素的文件，主进程另外写一个pvtu文件（6.6章）。

\subsubsection{Running the Program}

如何调用该程序取决于所使用的MPI实现。对于OPEN MPI，必要的命令是

~~~C++
mpirun -np ## ./grid-distributed-poisson
~~~

其中`##`是要使用的进程数。它将产生屏幕输出

~~~Shell
Reading 2d Gmsh grid...
version 2.2 Gmsh file detected
file contains 541 nodes
file contains 1086 elements
number of real vertices = 541
number of boundary elements = 88
number of elements = 992
Iteration Defect Rate
0 0.305176
1 0.416417 1.36451
2 0.468409 1.12486
3 0.438753 0.936687
4 0.412924 0.941131
5 0.392524 0.950597
[...]
36 0.000345697 0.625268
37 0.000271504 0.785382
~~~



由于迭代的顺序不取决于进程的数量，屏幕输出也不取决于。在四个进程中，程序将离开子域文件

~~~Shell
s0004-p0000-grid-distributed-poisson-result.vtu
s0004-p0001-grid-distributed-poisson-result.vtu
s0004-p0002-grid-distributed-poisson-result.vtu
s0004-p0003-grid-distributed-poisson-result.vtu
~~~

和`parallel file`。

~~~C++
s0004-grid-distributed-poisson-result.pvtu
~~~

这可以在 `PARAVIEW` 中打开。当使用子域等级字段进行着色时，结果将如 [Fig6.8] 中所示。提升与第 $3.3$ 章的顺序 `Poisson` 例中的 [Fig3.3] 相同。

\section{Linear Algebra with `dune-istl`}

除了网格和它们的数据结构，在有限元代码中最需要注意的可能是线性代数。这是因为由有限元离散化产生的线性系统可能会变得非常大。储存大的稀疏矩阵在整个内存需求中占了相当大的比例，而解决线性系统可能占用整个计算时间的大部分。许多优秀的线性代数软件包是可用的。我们不求完整，只提一下 `PETSC` [^6] [^7] , `MTL` [^77] , `Trilinos` [^93] , `BLAS` ，和 `Hypre` [^68] 。一个全面的列表被保存在 [^56] 。为了应对不断增加的问题规模，许多人试图将其扩展到非常大的处理器数量。

通过DUNE网格界面的构建，DUNE不要求用户使用任何特定的线性代数软件包（第5.6节）。相反，从网格到向量和矩阵的接口是与数据类型无关的，基本上只要求向量和矩阵是随机访问的容器。这使得DUNE网格可以与大多数现有的线性代数软件包结合使用。

尽管现有的线性代数软件有很多，但DUNE也提出了自己的线性代数库。它包含在`dune-istl`模块中，并具有某些特点，使其特别适合于有限元和有限体积模拟。它的核心是一个强大的嵌套机制，在矩阵和矢量数据类型本身中编码典型的阻塞和稀疏模式。这可以使特定的有限元计算更加省时和省力。在这样的矩阵和向量数据类型之上，`dune-istl`提供了一个标准求解器算法的集合，其中很多是完全并行化的。其中一些是在`dune-istl`本身实现的，而另一些是使用现有求解器的适配器代码，如`UMFPACK`和`CHOLMOD` [^41] [^46] 。

本章首先介绍了矩阵和向量的嵌套机制（第7.1章）。然后$7.2$和$7.3$章详细解释了向量和矩阵界面，$7.4$章展示了求解器和预处理器。最后，第$7.5$章介绍了`dune-istl`的工作成果：一个完全并行的基于聚集体的代数多网格预处理器。它可以为第 $7.4$ 章的线性求解器提供预处理，甚至在非常大的机器上也被成功使用 [^31] [^100] 。`dune-istl` 模块最初在 [^14] [^29] 中描述。

\subsection{Constructing Matrix and Vector Types by Nesting}

在有限元方法的教科书中，刚度矩阵的特点是 "稀疏"，即大多数条目为零。矩阵数据结构需要利用这种稀疏性；否则，需要存储的零的数量将迅速超过任何可用的内存。  [Fig7.1]显示了这种矩阵的占用模式。灰色小方块代表非零条目，只有这些条目需要存储在矩阵数据结构中。

稀疏矩阵存在多种数据结构（见[^133]的概述）。然而，有限元计算中的稀疏矩阵经常具有比简单的稀疏性多得多的结构。下面是一些例子。

- 某些离散化的结果是，矩阵中的各个条目被分组在小的密集块中，例如大小为$2 \times 2$或$3 \times 3$ ( [Fig7.2] (a)。这样的块可以对整个矩阵有一个固定的大小；例如，离散化一个三维弹性问题将导致一个刚度矩阵，其中所有条目都被分组在$3 \times 3$块中。另一方面，$h p$自适应的DG离散化[^55]会导致具有不同大小块的矩阵，见[Fig7.2] (b) 。在那里，每个块属于一个元素，块的大小取决于该元素上的有限元空间的多项式阶。许多迭代方法可以在这种块上操作，而不是在标量上操作，见，例如， [^34] 。

- 当求解一个具有$m$不同因变量的PDE系统时，安排整个系数列表的一种可能方式是对它们进行方程排序。这导致矩阵具有$m \times m$块结构，其中块本身是大而稀疏的，见[Fig7.2]（c）。一个例子是第10.8章中解释的斯托克斯问题。像乌泽算法及其变种[37,138]这样的求解器直接对这种结构进行操作。

- 反应-扩散系统的离散化产生稀疏矩阵，其块本身就是稀疏矩阵（ [Fig7.2] (d)）。所有块的稀疏模式都是一样的。同样，某些矢量值相场方程的离散化产生稀疏矩阵，其块是固定大小的`diagonal`矩阵[^80] 。

这种结构的很多内容在编译时通常是已知的，这种知识可以被利用来产生更有效的代码。为了了解使用块结构可以带来的节省，考虑一下稀疏矩阵的标准压缩行存储（CRS）数据结构，基本上每个矩阵条目使用12个字节：一个双精度数字（8个字节）用于数值本身，一个整数（通常是4个字节，有时更多）用于记录该数值的列索引。在用于三维弹性问题的专用矩阵数据结构中，每个矩阵条目是一个密集的$3 \times 3$矩阵，每块只需要存储一个列索引。因此，每个标量矩阵条目的近似存储要求下降到$8+\frac{4}{9}$字节。这是一个大约$30 \%$的改进，它允许处理更大的问题并提高许多线性求解器的速度。

`dune-istl`模块旨在为许多这些模式提供特殊用途的数据结构。像往常一样，遵循DUNE的方式，有一个抽象的接口规定如何使用矩阵和向量数据结构，以及这些接口的一些不同的实现。例如，`BCRSMatrix`类实现了一个具有压缩行存储和运行时大小的稀疏矩阵，`FieldMatrix`实现了一个具有编译时大小的密集矩阵。类`BlockVector`实现了一个运行时大小的向量数据结构，而`FieldVector`以编译时大小做同样的事情。

然而，考虑到[Fig7.2]只显示了一长串可能模式的一个子集，显然为每个这样的模式类型实现一个专门的数据结构是相当无望的。因此，`dune-istl`采取了一种模块化的方法。它为某些基本类型的模式、存储方案等提供了一套数据结构，并允许使用矩阵作为矩阵条目。同样地，`dune-istl`向量的条目可以是其他`dune-istl`向量。每个矩阵或向量数据结构的条目类型是一个模板参数，它使该结构对编译器可见。

这个策略最容易通过几个例子来证明。首先，虽然一般的稀疏矩阵被实现为

~~~C++
BCRSMatrix<double>
~~~

的类型

~~~C++
BCRSMatrix<FieldMatrix<double,3,3> >
~~~

是一个稀疏矩阵，其条目是密集的$3 \times 3$块，如[Fig7.2]（a）中。矩阵的总体大小可以在运行时设置，但是$3 \times 3$块的大小是硬编码的数据类型，因此可以被优化编译器使用。同样地

~~~C++
BTDMatrix<BCRSMatrix<double> >
~~~

是一个三对角矩阵，其条目是具有标量条目的稀疏矩阵，并且

~~~C++
BCRSMatrix<BCRSMatrix<DiagonalMatrix<double,3> > >
~~~

是一个`diagonal`$3 \times 3$矩阵的稀疏矩阵。

构建具有阻断模式的向量的工作方式也是如此。例如，当

~~~C++
BlockVector<double>
~~~

是一个具有运行时大小的`double`项的向量，对于图7.2(a)的三维弹性系统，适当的向量类型将是

~~~C++
BlockVector<FieldVector<double,3> >
~~~

适用于第三和第四例矩阵类型的向量类型是

~~~C++
BlockVector<BlockVector<double> >
~~~

和

~~~C++
BlockVector<BlockVector<FieldVector<double,3> > >
~~~


但请注意，`VariableBlockVector`是对嵌套类型`BlockVector <BlockVector>`的更有效替代。包含在`dune-istl`中的求解器可以与大多数这些组合一起工作。

最里面的类型总是指定用于标量条目的数字类型，可以是实数或复数。用于标量的数据类型从来不是硬性规定的，这一事实使得各种有趣的应用可以轻松实现。例如，只需改变几行代码，你就可以用多精度数据类型做线性代数，如 `boost::multiprecision` 或 `GMP` [^79] 中的数据类型，或者用算法微分所需的 "活动 "数字类型 [^85] 。

`dune-istl`的嵌套机制很好地补充了`dune-functions`模块中实现的混合有限元空间的树状构造（第10章）。它的多功能性在$10.8$章给出的例子程序中得到了证明。

\subsection{Data Structures for Vectors}

矢量和矩阵接口是基于`duck typing`（第4.4.2章），也就是说，没有共同的基类或门面类来执行它们。我们首先描述`dune-istl`的向量接口，因为它比矩阵接口短一些，也简单一些。

\subsubsection{Abstract Interface}

一个`dune-istl`向量是一个一维的容器，具有额外的向量空间操作、标量积和规范。根据 `duck typing` ，如果一个C++数据结构实现了[Tab7.1]中列出的容器方法和[Tab7.3] 中的线性代数方法，并且导出了[Tab7.2] 中列出的类型，那么它将被称作 `dune-istl` 向量。必须注意的是，`dune-istl`矢量接口支持稀疏矢量，即不明确存储零项的矢量。稀疏向量在有限元模拟中很少使用，但也没有很好的理由排除它们。在`dune-istl`中，它们目前只以稀疏矩阵的行的形式出现。我们首先讨论`dune-istl`向量的容器界面，之后讨论线性代数的方法。



\textbf{Container Interface}

作为一个容器，`dune-istl`向量提供了对其条目的前向和后向顺序访问，更重要的是提供了随机访问。矢量的实现是以矢量中的条目的类型为模板的。这些类型应该是数字类型，如`double`、`float`或`std::complex<double>`，或者是`dune-istl`意义上的矢量。这允许嵌套的容器数据结构，如上节所示。

[Tab7.1]中给出了所有容器方法的列表。首先，`dune-istl`向量应该是$\mathrm{C}++$标准库意义上的随机访问容器。也就是说，必须要有方法

~~~C++
reference operator[](size_type i)
~~~

和

~~~C++
const_reference operator[](size_type i) const
~~~


提供对容器的$i^{th}$条目的访问。如果该条目在数据结构中不存在，那么该方法的行为就无法定义。

为了能够对稀疏向量进行随机访问，并对访问不存在的条目有一个明确的行为，`dune-istl`向量提供了以下方法

~~~C++
iterator find(size_type i)
const_iterator find(size_type i) const
~~~

与`operator []`不同，它们返回一个迭代器，如果$i^{th}$元素存在，则指向该元素，否则指向`end()`的返回值。因此，例如，如果vec是一个`double`值的稀疏数组，只包含偶数位置的条目，那么

~~~C++
double a = vec[5];
~~~


将导致未定义的行为。有了find方法，代码就可以以安全的方式编写。

~~~C++
auto iter = vec.find(5);
double a = (iter==vec.end()) ? 0 : *iter;
~~~

的方法

~~~C++
iterator begin()
iterator end()
~~~

和

~~~C++
iterator rbegin()
iterator rend()
~~~


提供对正向和反向随机存取迭代器的访问。对于稀疏向量，这些迭代器只停在非零项上。返回类型必须由向量类导出（[Tab7.2]) .

为了实现 `dune-istl` 接口，向量提供了一个容器类所期望的常规构造函数和赋值运算符。与标准库中的容器不同，`dune-istl` 向量必须支持从标量赋值。

~~~C++
Vector& operator=(const field_type& scalar)
~~~

递归地遍历嵌套树，用给定的值填满每一个标量条目。

有几种方法可以获得`dune-istl`矢量的大小。最重要的是，该方法

~~~C++
size_type N() const
~~~

返回作为容器的向量的条目数。换句话说，size () $-1$ 是可以作为 `operator []` 的参数的最大值。与此相反，名字有点不幸的方法

~~~C++
size_type size() const
~~~

只返回非零条目的数量。对于密集向量，size总是返回与$\mathbb{N}$相同的数字，但对于稀疏向量，size$<\mathbb{N}$可能出现。最后，方法

~~~C++
size_type dim() const
~~~

返回完整嵌套层次结构中标量项的总数。例如，对于一个类型为 `BlockVector <FieldVector<float, 2>>` 的对象，方法 dim 将返回两倍于 size 的数字。它是矢量作为一个元素的线性空间的维度，这解释了这个名字。

几个`dune-istl`向量可以提供自定义分配器。分配器是一个$\mathrm{C}++$对象，它封装了从系统堆分配和取消分配内存的过程。这允许对内存分配进行检测以进行调试，或者插入额外的安全检查。C++标准在第[^98]章中描述了分配器的接口，`dune-istl`向量希望分配器能遵循这个标准。

\textbf{Vector Space Operations, Scalar Products, and Norms}

在数学上，`dune-istl`矢量是欧氏矢量空间的一个元素。因此，必须支持标准的向量空间操作（[Tab7.3]）。矢量加法的支持是

~~~C++
Vector& operator+=(const Vector& other)
~~~

和

~~~C++
Vector& operator-=(const Vector& other)
~~~


与标量相乘的公式为

~~~C++
Vector& operator*=(const field_type& alpha)
~~~

和

~~~C++
Vector& operator/=(const field_type& alpha)
~~~

必须有一个重要操作的直接实现

$$
x \longleftarrow x+\alpha y, \quad \alpha \in \mathbb{K}, \quad x, y \in \mathbb{K}^{n}
$$


以方法的形式

~~~C++
Vector& axpy(const field_type& alpha, const Vector& y)
~~~

除了裸露的向量空间属性，`dune-istl`向量实现了标量积和规范，将底层空间变成了`Hilbert`和`Banach`空间。有两种不同的标量积。第一种。

~~~C++
field_type operator*(const Vector& y)
~~~

实现实数标量乘法

$$
\langle a, b\rangle=\sum_{i=0}^{n-1} a_{i} b_{i}
$$

第二个，作为一个成员方法实现

~~~C++
real_type dot(const Vector& y)
~~~

实现了`Hermitian`的产品

$$
\langle a, b\rangle=\sum_{i=0}^{n-1} \bar{a}_{i} b_{i}
$$

如果矢量空间是实数，这两个乘积就会重合。

这些规范与为稀疏BLAS标准定义的规范相同 [^28] 。有三种不同的类型。

1.$l_{1}$规范

$$
\text{ real\_type one\_norm() } \quad|a|_{1}:=\sum_{i=0}^{n-1}\left|a_{i}\right|=\sum_{i=0}^{n-1} \sqrt{\left(\operatorname{Re} a_{i}\right)^{2}+\left(\operatorname{Im} a_{i}\right)^{2}}
$$

和它的真实对应物

$$
\text{ real\_type one\_norm\_real() } \quad|a|_{1, \mathrm{r}}:=\sum_{i=0}^{n-1}\left|\operatorname{Re} a_{i}\right|+\left|\operatorname{Im} a_{i}\right|
$$

第二个变体是第一个变体的近似值，避免了复数情况下出现的昂贵的平方根。对于实值向量，这两个规范是重合的。

2.$l_{2}$规范

$$
\text{ real\_type two\_norm() } \quad|a|_{2}:=\sqrt{\sum_{i=0}^{n-1}\left(\operatorname{Re} a_{i}\right)^{2}+\left(\operatorname{Im} a_{i}\right)^{2}} \text { , }
$$

和它的平方

$$
\text{ real\_type two\_norm2() } \quad|a|_{2}^{2}:=\sum_{i=0}^{n-1}\left(\operatorname{Re} a_{i}\right)^{2}+\left(\operatorname{Im} a_{i}\right)^{2}
$$

与$l_{1}$的情况类似，第二个变体的存在是为了避免昂贵的平方根。

3.$l_{\infty}$规范



$$
\begin{aligned}
|a|_{\infty} &:=\max _{i=0, \ldots, n-1}\left|a_{i}\right| \\
&=\max _{i=0, \ldots, n-1} \sqrt{\left(\operatorname{Re} a_{i}\right)^{2}+\left(\operatorname{Im} a_{i}\right)^{2}}
\end{aligned}
$$

和它的真实对应物

$$
|a|_{\infty, \mathrm{r}}:=\max _{i=0, \ldots, n-1}\left(\left|\operatorname{Re} a_{i}\right|+\left|\operatorname{Im} a_{i}\right|\right)
$$

这也避免了对平方根的评估。

请注意，即使对于嵌套的向量类型，这三种规范也都是规范性的。

接口中缺少二进制运算符 `operator+` , `operator-` , 和 `operator*(field_type, Vector)` 。因此，不可能写出

~~~C++
BlockVector<double> a = {1.0, 2.0, 3.0};
BlockVector<double> b = {1.0, 4.0, 9.0};
BlockVector<double> c = a+b; // won’t compile
~~~


其原因是，虽然第一种变体看起来更短，但如果编译器不够聪明，它可能会在所有的容器条目上产生两个循环。著名的表达式模板已经被引入，以迫使编译器对这类表达式只发出一个循环 [^1] [^156] 。然而，表达式模板并没有在 `dune-istl` 中使用，因为它们会导致非常长的编译时间和编译器错误信息，而且会使库的调试更加困难。

相反，`dune-istl`添加向量的方法是

~~~C++
BlockVector<double> a = {1.0, 2.0, 3.0};
BlockVector<double> b = {1.0, 4.0, 9.0};
BlockVector<double> c = a;
c += b;
~~~



这也创造了两个循环，但至少它明确了这个事实。为了真正确保为表达式$c=a+b$创建一个单一的循环，该循环必须手工编写。

纯粹的`FieldVector`对象是一个例外。事实上，代码


~~~C++
FieldVector<double,3> a = {1.0, 2.0, 3.0};
FieldVector<double,3> b = {1.0, 4.0, 9.0};
FieldVector<double,3> c = a+b;
~~~


确实可以编译和运行。在这种情况下，我们认为最好也能提供二进制运算符，以使代码更易读。此外，轶事证据表明，现代编译器足够聪明，可以为这种算术表达式融合循环。

\subsubsection{Vector Implementations}

`dune-istl`模块目前提供了四个矢量实现。  `FieldVector` , `BlockVector` , `MultiTypeBlockVector` , 和 `VariableBlockVector` 。我们依次讨论这四种向量的实现方式。此外，矩阵的行必须实现向量接口。

\textbf{Field Vector}

该班级

~~~C++
template<class T, int n>
class FieldVector
~~~


实现了一个静态大小的向量。数据存储在堆栈中，因此`FieldVectors`只能用于小矢量，例如，速度场的三个分量。第一个模板参数$\mathrm{T}$是矢量成分的类型，第二个模板参数$\mathrm{n}$是矢量的长度。

`FieldVector`类忠实地实现了完整的`dune-istl`向量接口。`FieldVector`类型的对象可以被默认和复制构建，它们可以从标量（用该标量初始化所有条目）和初始化器列表中构建出来

~~~C++
FieldVector<double,3> v = {1.0, 2.0, 3.0};
~~~


当然，短的静态向量在有限元软件系统中的作用远远超过实际的线性代数。因此，尽管`FieldVector`是`dune-istl`矢量概念的实现，它实际上包含在`dune-common`中，在头文件`dune/common/fvector.hh`中。正如在第五章中可以看到的，`dune-grid`和`dune-geometry`将其用于坐标。`dune-localfunctions`模块将其用于形状函数值（第8章）。

作为一般`dune-istl`嵌套机制的一个例外，一个`FieldVector`总是结束嵌套递归。因此，它只能用实际的实数或复数类型来实例化 $\mathrm{T}$ 。其原因部分是历史原因，部分是由于`FieldVector`的实现实际上并不存在于`dune-istl`模块中。

作为另一个例外，`FieldVector`是唯一实现二进制算术运算符的`dune-istl`向量类。因此，举例来说，可以写成

~~~C++
FieldVector<double,3> a, b, c;
double alpha, beta;
c = alpha * a + beta * b;
~~~


对于所有其他`dune-istl`矢量类型，只存在单数运算符$+=,-=, *=$等。

\textbf{`BlockVector` }

该班级

~~~C++
template<class T, class A=std::allocator<T> >
class BlockVector
~~~


是 `dune-istl` 的工作母体向量类型。它实现了一个动态大小的向量，数据存储在堆上。这意味着`BlockVector`可以达到预期的大小（物理内存允许），`BlockVector`是有限元系数向量的标准选择。模板参数$\mathrm{T}$是矢量条目的类型，可以是任何数字或`dune-istl`矢量类型。下面创建了一个由10个每个长度为3的向量组成的向量；例如，对固体力学中的位移场很有用。

~~~C++
BlockVector<FieldVector<double,3> > d(10);
~~~


类似地，下面创建一个有10个`double`项的向量。

~~~C++
BlockVector<double> v(10);
~~~

`BlockVector`类型的对象实现了完整的容器和线性代数接口。它们可以从初始化器列表中构建，这对小向量来说非常方便。

~~~C++
BlockVector<float> fibonacci = {1,1,2,3,5,8};
BlockVector<FieldVector<double,3> > canonical = {{1,0,0}, {0,1,0}, {0,0,1}};
~~~


可以使用方括号访问向量的各个条目。

~~~C++
v[0] = 1.0;
~~~


当用方括号对嵌套的向量d进行索引时，返回的对象是一个`FieldVector <double, 3>` 。因此，单个组件以及整个子块都可以被方便地处理。

~~~C++
d[0] = {1.0, 0.0, 0.0}; // Set first block to canonical basis vector
d[0][1] = 1.0;          // d[0] is now {1.0, 1.0, 0.0}
~~~

一个`BlockVector`的大小可以在任何时候用以下方法改变

~~~C++
void resize(size_type size)
~~~


如同在标准库中，这将保留数据，但会使它所调用的对象的所有迭代器失效。

请注意，`BlockVector`类是有分配器意识的：它的第二个模板参数默认为`std::allocator`，并且可以被任何符合标准库的分配器实现[^150]取代。然后这个分配器被 `BlockVector` 对象用于所有的内存管理。

\textbf{MultiTypeBlockVector}

矢量的实现

~~~C++
template<typename... Args>
class MultiTypeBlockVector
~~~

与其他的不同，因为它是一个异质性的容器。这意味着它存储了不同类型的对象的集合，很像`std::tuple`。事实上，作为一个容器，`MultiTypeBlockVector`与`std::tuple`非常相似。在实现混合有限元方法和多物理学应用时，`MultiTypeBlockVector`和它的表亲`MultiTypeBlockMatrix`非常有帮助。在第 $10.8$ 章中给出了一个完整的例子。

`typename... Args`的模板参数是`variadic`，这意味着`MultiTypeBlockVector`类可以用任何数量的模板参数进行实例化。更何况，每个`MultiTypeBlockVector`都有一个固定大小的条目。每个参数都应该是一个`dune-istl`向量，`MultiTypeBlockVector`对象存储每个向量类型的一个对象。每个条目又可以嵌套，而且没有要求所有条目的嵌套深度都要相同。作为一个例子，下面的代码将$\mathbb{R}^{3}$中的弹性介质的位移向量与流体压力的标量变量结合起来。

~~~C++
using DisplacementVector = BlockVector<FieldVector<double,3> >;
using PressureVector = BlockVector<double>;
using MultiTypeVector = MultiTypeBlockVector<DisplacementVector,
                                                PressureVector>;
~~~


要构造这种类型的对象，要构造独立的组件，然后把它们交给`MultiTypeBlockVector`类的构造器。

~~~C++
DisplacementVector displacement = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
PressureVector pressure = {0, 0, 0};
MultiTypeVector multiType(displacement, pressure);
~~~



所有`std::tuple`的构造方法都支持。例如，也可以默认构建外向量，然后再提供单独的组件。

作为一个异构的容器，`MultiTypeBlockVector`类不能精确地满足`dune-istl`矢量容器接口的所有要求。特别是，由于任何两个向量条目都可能有不同的类型，标准的运行时迭代条目是不可能的，需要用静态循环来代替。同样地，标准的随机访问操作符

~~~C++
block_type& operator[](size_type i)
~~~


不能实现，因为返回类型在编译时必须知道，但它取决于参数i，而参数i在运行时才知道。

为了访问各个条目，`MultiTypeBlockVector`实现了一个特殊的静态版本`operator []`，有一个编译时的参数。

~~~C++
template<std::size_t i>
auto& operator[](const index_constant<i> indexVariable)
~~~


(以及相应的const操作符）。)`index_constant<i>` 类（来自文件 `dune/common/indices.hh` ）是 `std::integral_constant< std::size_t ,i>` 的别名。相应的对象将数字i封装为一个类型，因此迫使参数成为编译时的信息。然后，返回类型可以正确地依赖于这些信息。例如，要把一个`MultiTypeBlockVector`的条目2复制到一个单独的变量中，写道

~~~C++
auto tmp = multiTypeVector[index_constant<2>()];
~~~

这样做是可行的，但它是笨拙的。为了提高可读性，DUNE为最相关的自然数提供了缩略语。文件`dune/common/indices.hh`包含了这些定义

~~~C++
constexpr index_constant<std::size_t, 0> _0 = {};
constexpr index_constant<std::size_t, 1> _1 = {};
constexpr index_constant<std::size_t, 2> _2 = {};
...
~~~

在命名空间 `Dune::Indices` 中。有了这个，对组件2的访问就简洁了。

~~~C++
using namespace Dune::Indices;
auto tmp = multiTypeVector[_2];
~~~


这样的一行代码看起来基本上和普通容器的对应行一样，在这个意义上，异构的`MultiTypeBlockVector`几乎不比`BlockVector`更难使用。如果要访问的向量条目不是固定的，而只是作为一个编译时变量可用，那么就必须使用较长的语法，使用`index_constant`。

矢量空间运算、规范和标量积都不构成任何问题。  `MultiTypeBlockVector`实现了[Tab7.3]中列出的所有线性代数方法。 例如，给定两个类型相同的向量a和b，可以对它们进行加法和比例。

~~~C++
a += b;
a *= 2.0;
~~~

取标量积。

~~~C++
auto product = a*b;
~~~

并计算出[Tab7.3]中所列的规范。

~~~C++
auto l2 = a.two_norm();
auto max = a.infinity_norm();
...
~~~


基于这一功能，第`Krylov`章中提到的大多数$7.4.1$求解器都可以直接与`MultiTypeBlockVector`对象一起工作。

\textbf{VariableBlockVector}

最后，该类

~~~C++
template<class T, class A = std::allocator<T> >
class VariableBlockVector
~~~



并不提供额外的功能，但允许某些应用程序更有效地运行。有时，一个向量的向量是可取的，其中内向量和外向量都有动态大小。例如，在$p$自适应DG方法中，外向量将被元素索引，而每个内向量将存储一个元素的系数。这样的数据结构可以通过嵌套构建 `BlockVectors` 。

~~~C++
BlockVector<BlockVector<double> >;
~~~

然而，这样的类型使用内存的效率非常低。事实上，内存是为每个内部块单独分配的，导致了内存碎片化。这在 [Fig7.3] 的中心位置得到了可视化。碎片化会减慢迭代求解器的速度，如果向量条目在内存中连续排列，迭代求解器会更有效地运行。

这个问题的解决方案是`VariableBlockVector`类。一个类型的对象

~~~C++
VariableBlockVector<V>;
~~~

(其中$\mathrm{V}$是任何数字或`dune-istl`矢量类型）的行为就像

~~~C++
BlockVector<BlockVector<V> >;
~~~

然而，`VariableBlockVector`的实现确保了内存被分配在一个单一的块中，没有碎片，如[Fig7.3]的底部所示。

为了实现连续的内存布局，`VariableBlockVector`比`BlockVector`的`BlockVectors`对何时选择内向量大小有更多限制。基本上，内部矢量尺寸只能一次性设置，设置它们将使整个矢量内容失效。除了强制性的默认和复制构造函数外，还可以用给定的外部和内部尺寸构造一个`VariableBlockVector`对象。

~~~C++
VariableBlockVector(size_type nblocks, size_type m)
~~~


这将分配一个大小为 `nblocks` 的外向量，并将每个内向量的大小设置为 $\mathrm{m}$ 。要单独设置每个内向量的大小，构建对象时只需给出外部大小。

~~~C++
VariableBlockVector(size_type nblocks)
~~~

然后设置内部尺寸需要一个`CreateIterator`对象。这样的一个迭代器可以通过调用以下方法获得

~~~C++
CreateIterator VariableBlockVector::createbegin()
~~~



A `CreateIterator` 将对外向量的所有条目进行正向迭代。对于每一个这样的条目，相应的内向量的大小可以通过向被解读的迭代器写入所需的大小来设置。因此，例如，要构建一个有10个条目的`VariableBlockVector`对象，其中$i^{th}$条目是一个长度为i的向量，写道

~~~C++
VariableBlockVector<double> v(10);
std::size_t i=0;
for (auto cIt = v.createbegin(); cIt!=v.createend(); ++cIt)
    *cIt = i++;
~~~



该向量没有被正确初始化，没有分配内存，除非迭代器已经踏过所有的向量块。使用这样一个未初始化的向量会导致一个错误。`CreateIterator`是一个有效的标准库输出迭代器，因此像`std::fill`或`std::copy`这样的标准算法也可以用来设置块大小。

对应于两个构造函数，有两个方法

~~~C++
void resize(size_type nblocks, size_type m)
void resize(size_type nblocks)
~~~

这些设置了现有容器的块数和（第一个）统一的块大小。与调整`BlockVector`对象的大小不同，所有先前的内容都会因此而失效。当第二个调整大小的方法被调用时，必须使用上面描述的迭代器机制来重新设置块的大小。

对条目的随机访问和迭代与 `BlockVector` 的 `BlockVectors` 一样。解除迭代器（或调用 `operator []` ）会产生一个代理类型，其行为与 `BlockVector` 一样。可以使用该代理的`operator []`访问单个条目。

~~~C++
double a = v[i][j];
v[i][j] = 42.0 + a;
~~~

在所有其他方面，`VariableBlockVector`的行为就像`BlockVector <BlockVector >`类型的对象，没有必要单独描述。

\subsection{Data Structures for Matrices}

`dune-istl`矩阵的接口遵循与向量接口相同的思路，但由于矩阵有更多的代数结构，所以接口由更多的方法组成。

\subsubsection{Abstract Interface}

从概念上讲，`dune-istl`矩阵是一个二维的容器，具有线性代数的附加方法。它将被解释为一个向量的容器，尽管实现方式可能不同。该组织是按行排列的，也就是说，外部容器被解释为矩阵行的容器。


\textbf{Container Interface}

矩阵对象的构建取决于各个实现，但所有的实现至少必须是默认的和可复制的构建。一旦矩阵对象被正确设置，它的行数和列数可以通过成员方法来查询

~~~C++
size_type N() const // Number of rows
size_type M() const // Number of columns
~~~

分别。每个矩阵条目本身可以是一个矩阵，方法$\mathrm{N}$和M计算块的行和列的数量。

通过 `operator []` 可以访问（块）矩阵的行。每一行都要实现 `dune-istl` 矢量接口的容器部分；因此它也实现了 `operator []` ，一个名为'a'的矩阵的条目 $a_{i j}$ 可以通过 $\mathrm{a}[\mathrm{i}][\mathrm{j}]$ 来访问。这是索引密集矩阵的自然方式。

如果矩阵数据结构是稀疏的，事情就更复杂了。如果完整的行只包含零，则可以从数据结构中省略。对于这种情况，`operator []`的行为是未定义的：它可能会返回一个空行，但也可能会做其他事情。同样的问题也可能发生在每一行中：在$i^{th}$行中，$j$列的条目可能在数据结构中不存在。调用

~~~C++
auto value = a[i][j];
~~~


则会导致第二次调用`operator []`的行为未被定义。为了检查矩阵数据结构中是否存在一个给定的条目$(i, j)$，该接口提供了一个方法

~~~C++
bool exists(size_type i, size_type j) const
~~~

只有当这个方法对于给定的i和$j$返回`true`时，访问`a[i][j]`是安全的。此外，每个矩阵行都有一个方法

~~~C++
size_type size() const
~~~

其中返回该行中实际存储在数据结构中的块条目的数量。

为了有效地只访问稀疏矩阵的非零项，必须使用迭代器接口。矩阵提供了一个符合标准库的矩阵行的前向迭代器。如果行是完全空的，这个迭代器可以跳过这些行。因此，下面的代码是对矩阵的所有非零行进行迭代。

~~~C++
for (auto row = matrix.begin(); row != matrix.end(); ++row)
    std::cout << "row: " << row.index()
        << " has " << row->size() << " entries." << std::endl;  
~~~


观察一下非标准的`iterator`方法`index`如何允许获得当前行的编号。不幸的是，在大多数相关情况下，这种方法阻止了使用更可读的基于范围的语法。可以这样写

~~~C++
for (auto&& row : matrix)
    std::cout << "row has " << row->size() << " entries." << std::endl;
~~~

但在这样的循环中，行数是不可用的，因此其作用是有限的。

反过来，每一行通过提供方法支持对其非零项的随机访问迭代

~~~C++
row_type::iterator begin()
row_type::iterator end()
~~~



对于每个这样的条目，可以通过以下方法获得列索引

~~~C++
size_type index () const
~~~


的列迭代器。下面的代码显示了如何在一个稀疏矩阵的非零项上循环。

~~~C++
for (auto row = matrix.begin(); row != matrix.end(); ++row)
    for (auto col = row.begin(); col != row.end(); ++col)
        std::cout << "entry: " << row.index() << ", " << col.index() << std::endl
~~~


注意，根据矩阵的类型，每个矩阵条目可能又是一个稀疏的矩阵。要真正获得任意嵌套的`dune-istl`矩阵中的标量条目，需要进行模板元编程。

前面的讨论隐含地假设所有的矩阵条目都由相同的$\mathrm{C}++$类型表示。有一些异质的矩阵容器，比如`MultiTypeBlockMatrix`，它是`MultiTypeBlockVector`的矩阵表亲（见第7.3.2章）。在这种情况下，需要静态循环来遍历所有条目。

\textbf{Linear Algebra Operations}

`dune-istl`矩阵接口中的线性代数方法列表主要包括矩阵-向量乘法和矩阵规范。一些实现还允许矩阵反转和线性方程组的求解。

首先，虽然作为一个矢量空间的元素，矩阵可以被添加，并与标量相乘。与`dune-istl`矢量的情况类似，只有`FieldMatrix`类有一个二进制的`operator+`，一般写成

~~~C++
SomeISTLMatrix a,b,c;
c = a+b;
~~~

将不会被编译。相反，有

~~~C++
Matrix& operator+=(const Matrix& other)
~~~

和

~~~C++
Matrix& operator-=(const Matrix& other)
~~~

和矩阵的添加方法是写

~~~C++
c = a;
c += b;
~~~

这不会比 "a=b+c "的天真实现更快，但至少它使非优化编译器会发出两个循环的事实对源代码的读者来说很明显。


将稀疏矩阵 $\mathrm{b}$ 添加到稀疏矩阵c中可能需要在c的模式中插入额外的条目。对于重要的稀疏矩阵数据结构，这可能是相当昂贵的 [^133] 。因此，由于这种不匹配的添加在有限元应用中很少发生--`dune-istl`矩阵接口没有指定 "operator+= ` and ` operator-="在$b$的模式不是c的模式的子集情况下的行为。 对于与标量的乘法，有两种方法

~~~C++
Matrix& operator*=(const field_type& s)
Matrix& operator/=(const field_type& s)
~~~


至此，对`dune-istl`矩阵的向量空间接口的描述结束。接下来，有一些关于矩阵-向量乘法的方法。假设$A$是一个矩阵，$x$和$y$是具有适当长度的向量。该方法

~~~C++
void mv(const X& x, Y& y) const
~~~

将向量$\mathrm{y}$的内容替换为乘积$A x$。所有其他的乘法方法都有类似的特征，但都是将其结果添加到y中，而不是替换y的内容。

~~~C++
void umv(const X& x, Y& y) const
~~~

将乘积$A x$添加到y的内容中，类似地。

~~~C++
void mmv(const X& x, Y& y) const
~~~

从y中减去积$Ax$，并且

~~~C++
void umtv(const X& x, Y& y) const
~~~

将$A^{T} x$的结果添加到y中。关于这些方法的完整列表，见[Tab7.6]。

`dune-istl`矩阵接口提供了两种类型的规范。让 $A \in \mathbb{R}^{n \times m}$ 是一个具有标量项 $a_{i j}$ 的矩阵。`Frobenius`的$A$准则是

$$
\|A\|_{F}:=\sqrt{\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} a_{i j}^{2}}
$$

并可通过以下方法获得

~~~C++
real_type frobenius_norm() const
~~~

为了避免昂贵的平方根，而这并不总是需要的，还有一种方法是

~~~C++
real_type frobenius_norm2() const
~~~

其中返回 $\|A\|_{F}^{2}$ 。


`Frobenius`准则的定义以一种直接的方式延伸到嵌套块矩阵的情况。假设$A$的条目不是标量，而是其本身的矩阵$A_{i j}$。那么，`Frobenius`的准则可以用递归的方式写为

$$
\|A\|_{F}:=\sqrt{\sum_{i=0}^{n-1} \sum_{j=0}^{m-1}\left\|A_{i j}\right\|_{F}^{2}}
$$

因此，`frobenius_norm`方法将返回正确的值，即使是具有任意复杂嵌套结构的矩阵类型。

对于第二种类型的规范来说，事情就比较复杂了。让$A$再次成为一个有标量项的矩阵。行和准则是

$$
\|A\|_{\infty}:=\max _{i=0, \ldots, n-1}\left|a_{i}\right|_{1}=\max _{i=0, \ldots, n-1} \sum_{j=0}^{m-1}\left|a_{i j}\right|
$$

它用符号$\|\cdot\|_{\infty}$表示，因为它是向量无穷大规范的诱导规范。

$$
\|A\|_{\infty}=\max _{x \neq 0} \frac{\|A x\|_{\infty}}{\|x\|_{\infty}}, \quad \text { with } \quad\|x\|_{\infty}:=\max _{i=0, \ldots, m-1}\left|x_{i}\right|, \quad x \in \mathbb{R}^{m}
$$

对于有标量项的矩阵，这个准则可以通过以下方法获得

~~~C++
real_type infinity_norm() const
~~~

不幸的是，这种方法对于嵌套矩阵很难正确实现。因此，大多数dune-istl矩阵对标量矩阵正确地实现了行-和准则，但对嵌套块状矩阵只提供了以下的递归近似。[X-process]

[X-process]: https://cdn.mathpix.com/snip/images/kn5SrjDtK0igbybAAZ8a-ASY5OMtVqAmlySHu8km-VU.original.fullsize.png


然而，请注意，这并不是向量$\infty$-norm的诱导规范。对于复值矩阵，计算矩阵条目的绝对值涉及到平方根函数。该方法

~~~C++
real_type infinity_norm_real() const
~~~

用`dune-istl`向量接口中的one_norm_real方法替换$\left|a_{i}\right|_{1}:=\sum_{j=0}^{m-1}\left|a_{i j}\right|$定义中的one-norm。也就是说，对于复数条目$|z|:=\sqrt{(\operatorname{Re} z)^{2}+(\operatorname{Im} z)^{2}}$被$|z|_{r}:=|\operatorname{Re} z|+|\operatorname{Im} z|$所取代。这种近似方法节省了对昂贵的平方根方法的调用。

作为接口的可选扩展，一些矩阵提供了矩阵反演和线性方程组求解的方法。通常情况下，对于那些存在廉价的典型算法的矩阵实现来说，就是这种情况。对于这些矩阵。

~~~C++
void invert()
~~~

将在原地反转矩阵。该方法

~~~C++
void solve(X& x, const Y& b)
~~~

将解决系统 $A x=b$ 。最后，几个矩阵的实现提供了方法

~~~C++
Matrix& leftmultiply(const Matrix& B)
~~~

它用乘积$B A$取代了矩阵$A$。

\subsubsection{Matrix Implementations}

目前，DUNE的核心模块为`dune-istl`矩阵接口提供了八个不同的实现。并非所有的都在`dune-istl`本身中。`FieldMatrix`和`DiagonalMatrix`类包含在`dune-common`模块中，因为它们被网格实现所使用。

\textbf{FieldMatrix}

该班级

~~~C++
template<class T, int n, int m>
class FieldMatrix
~~~

实现了一个静态大小的密集矩阵。数据在对象中分配，因此堆栈分配的`FieldMatrix`对象只能用于小矩阵。  `FieldMatrix`是与`FieldVector`对象一起使用的典型矩阵类型。在一个典型的情况下，$3 \times 3$ `FieldMatrix`对象作为线性弹性矩阵的条目（如[Fig7.2] (a) ）。

入口类型T应该是一个实数或复数类型，如`double`, `float`, `complex<double>`, 等等。与`FieldVector`类型的推理相同，`FieldMatrix`类结束了嵌套递归，也就是说，不可能使用其他`dune-istl`矩阵作为`FieldMatrix`的条目。

由于小密集矩阵类型在线性代数之外还有用处，所以该类没有在 `dune-istl` 模块中实现，而是在 `dune-common` ，文件 `dune/common/fmatrix.hh` 中。例如，许多网格实现将其用于从参考元素到网格元素的映射$F$的导数。

`FieldMatrix`类实现了通常的默认和复制构造函数。按照`dune-istl`的矩阵接口，它也可以从标量中构建。该行

~~~C++
FieldMatrix<double,3,3> m(0);
~~~

构建一个$3 \times 3$的矩阵，其中充满了零。注意下面的陷阱：行

~~~C++
FieldMatrix<double,3,3> m(1);
~~~


将不会设置一个身份矩阵!建立这样一个矩阵的正确方法是从一个`ScaledIdentityMatrix`中分配（见下文）。

~~~C++
FieldMatrix<double,3,3> m = ScaledIdentityMatrix<double,3>(1);
~~~


最后，一个`FieldMatrix`可以由一个`std::initializer_list`构建。另一种真正建立$3 \times 3$身份矩阵的方法是

~~~C++
FieldMatrix<double,3,3> matrix = {{1,0,0},
                                  {0,1,0},
                                  {0,0,1}};
~~~


由于`FieldMatrix`实现了一个密集矩阵，使用`operator []`访问是直接的。`operator []`的返回值是对`FieldVector`的引用，它被用来实现矩阵的行。因此，可以这样写

~~~C++
FieldMatrix<double,3,3> matrix;
[...]
FieldVector<double,3>& firstRow = matrix[0];
~~~

来处理单行，以及

~~~C++
double b = matrix[i][j];
matrix[i][j] = 1.0;
~~~

为单个条目。第7.3.1章中描述的迭代器访问也同样有效，但不能指望它比使用方括号的直接访问快。

由于`FieldMatrix`对象被期望是小的，`FieldMatrix`类实现了可选的方法solve和invert。在内部，手工编码的公式用于小矩阵，而一个`LU-decomposition`则用于大矩阵。注意，如果矩阵是对称的，这些算法不能利用对称性。如果知道一个给定的`FieldMatrix`是对称的，人们可能希望使用不同的解算器，而不是调用`solve` 。

除了`dune-istl`矩阵接口的向量空间方法外，`FieldMatrix`类还实现了相应的二进制（即双参数）操作。

~~~C++
FieldMatrix operator+(const FieldMatrix& other) const
FieldMatrix operator-(const FieldMatrix& other) const
FieldMatrix operator*(const FieldMatrix& other) const
~~~


因此，有可能写出这样的代码

~~~C++
FieldMatrix<double,3,3> A, B, C;
auto D = A + 0.5 * B * C;
~~~

这比只使用接口方法的代码更有可读性。

\textbf{DiagonalMatrix and ScaledldentityMatrix}

稀疏矩阵有两种实现方式，有特定的静态模式和静态大小。

~~~C++
template<class T, int n>
class DiagonalMatrix
template<class T, int n>
class ScaledIdentityMatrix
~~~



第一个包含在`dune/common/diagonalmatrix.hh`中（在`dune-common`模块中），第二个在`dune/istl/scaledidmatrix.hh`中（在`dune-istl`中）。`DiagonalMatrix`类实现了一个`diagonal`矩阵，其内部只存储`diagonal`项。更为激进的是，`ScaledIdentityMatrix`代表身份矩阵的倍数。这样的矩阵实现可以大大减少运行时间和内存占用。例如，某些相位场模型涉及到矢量`Laplacian`，它只是普通的`Laplacian`分别作用于矢量场的所有分量[^111]。这样一个系统的刚度矩阵可以写成一个普通的`Laplace`矩阵，但是每个条目都被$m \times m$的比例倍数所取代（$m$是矢量系数的数量）。这样一个刚度矩阵可以实现为

~~~C++
BCRSMatrix<ScaledIdentityMatrix<double,m> >
~~~

这比天真无邪的 "我 "使用的内存要少得多。

~~~C++
BCRSMatrix<FieldMatrix<double,m,m> >
~~~

它明确地存储了身份矩阵。因此，矩阵-向量乘积变得更快，因为使用了专门的算法与`diagonal`矩阵进行乘法。最后，较小的矩阵可以节省内存带宽，从而进一步提高执行速度。

作为第二个应用，`DiagonalMatrix`对象被用来加速结构化网格的实现。在`YaspGrid`网格管理器中（第5.10.2章），所有元素都是轴对齐的超立方体。因此，从参考超立方体到任何元素的映射$F$的导数总是`diagonal` 。  因此，`YaspGrid` 使用`DiagonalMatrix`对象作为`jacobianTransposed`和`jacobianInverseTransposed`方法的返回值。

这两种矩阵类型都可以默认和复制构建。也支持从标量构建，并以该标量填充`diagonal`上的所有矩阵元素。因此，与`FieldVector`的实现不同的是，这两个

~~~C++
DiagonalMatrix<double,3> m(1);
~~~

和

~~~C++
ScaledIdentityMatrix<double,3> m(1);
~~~

真的会产生身份矩阵。最后，`DiagonalMatrix`对象可以从`std::initializer_list`设置。该代码

~~~C++
DiagonalMatrix<double,3> matrix = {1,2,3};
~~~


创建一个$3 \times 3$的矩阵，在`diagonal`上给出数字。

`DiagonalMatrix` 和 `ScaledIdentityMatrix` 实现了 `dune-istl` 接口规定的所有矩阵向量乘法和规范。这些都是特殊用途的实现，因此比 `FieldMatrix` 的相应方法快得多。对单个矩阵元素的访问与一般矩阵容器接口一节中描述的一样。有关于行和行的条目的迭代器，而行-条目迭代器只会在`diagonal`的条目上停止。随机访问需要更加小心。  `Elements`可以使用两对方括号直接访问。

~~~C++
matrix[0][0] = 3.14;
double pi = matrix[0][0];
~~~

然而，这只对`diagonal`元素有明确的定义。以这种方式访问非`diagonal`条目会导致未定义的结果，因为它们不存在于内存中。特别是，读取非对角线可能不会返回0。要真正随机访问非 `diagonal` 项，需要将其中一个矩阵复制到 `FieldMatrix` 中。

~~~C++
DiagonalMatrix<double,3> a = {1,1,1};
FieldMatrix<double,3,3> b = a;
double c = b[2][0]; // well-defined: c equals zero
~~~

最后，由于其特殊的结构，`diagonal`矩阵的反转是微不足道的。因此，`DiagonalMatrix`和`ScaledIdentityMatrix`都实现了可选接口方法

~~~C++
template<class Vector>
void solve(Vector& x, const Vector& b) const
~~~

和

~~~C++
void invert()
~~~

两者都使用明显的最佳算法来倒置`diagonal`矩阵。因此，例如，给定一个`DiagonalMatrix`对象D和`FieldVector`对象$\mathrm{x}$和$\mathrm{b}$的正确长度。

~~~C++
D.solve(x,b);
~~~

将解决线性系统 $D x=b$ 。例如，这种系统出现在矢量拉普拉斯问题的多网格平滑器的内循环中 [^111] 。

\textbf{Matrix}

下面两节再次描述密集矩阵的实现。该类

~~~C++
template<class B, class A=std::allocator<B> >
class Matrix
~~~


是一个具有运行时行数和列数的密集矩阵。它是 `element stiffness matrices` 的默认选择。可以通过给出行数和列数来构造一个矩阵对象

~~~C++
Matrix<double> matrix(10,10);
~~~

这将产生一个$10 \times 10$的标量矩阵，其值未被初始化。另外，`Matrix`对象可以是默认构建的，其大小可以单独设置。

~~~C++
Matrix<double> matrix;
matrix.setSize(10,10);
~~~

矩阵的大小可以在任何时候改变；但是，改变大小会使所有的矩阵数据失效。`Matrix`类实现了完整的`dune-istl`矩阵接口，除了`invert`和`solve`方法之外。它还实现了行和列的迭代器。然而，由于矩阵是密集的，通过`matrix[i][j]`访问单个块条目也同样有效。

\textbf{MultiTypeBlockMatrix}

与`Matrix`类相比，`MultiTypeBlockMatrix`是一个具有静态行数和列数的密集异质矩阵。它是`MultiTypeBlockVector`的矩阵类似物--每个矩阵条目都必须存在，但每个条目可以是不同的$\mathrm{C}++$类型。这使得它成为用于混合有限元和多物理问题的自然矩阵数据结构。它在文件 `dune/istl/multitypeblockmatrix.hh` 中提供。

该类的声明是

~~~C++
template<typename... Args>
class MultiTypeBlockMatrix
~~~


模板参数为`variadic` ，即该类接受数量不等的模板参数。每个参数都要实现一个矩阵行。更具体地说，每个模板参数必须是一个`MultiTypeBlockVector`类，其中每个条目是一个`dune-istl`矩阵。不用说，所有这些向量都必须有相同数量的条目。例如，下面的代码为$2 \times 2$的[Fig7.2]块矩阵设置了一个C++类型（c），其中左上方的块是一个由小的$2 \times 2$矩阵块组成的稀疏矩阵，右下方的块是一个标量矩阵，而两个关的`diagonal`矩阵是分别由$2 \times 1$和$1 \times 2$块构成的稀疏矩阵。

~~~C++
using UpperLeft = BCRSMatrix<FieldMatrix<double,2,2> >;
using UpperRight = BCRSMatrix<FieldMatrix<double,2,1> >;
using LowerLeft = BCRSMatrix<FieldMatrix<double,1,2> >;
using LowerRight = BCRSMatrix<double>;
using MyMultiTypeMatrix
            = MultiTypeBlockMatrix<MultiTypeBlockVector<UpperLeft,UpperRight>,
                                  MultiTypeBlockVector<LowerLeft,LowerRight> >;
~~~



对于这样的类型，存在各种构造函数。对象可以是默认构建的，之后再填充数据，也可以通过对现有矩阵行的引用来构建。完整的列表见在线文档。

由于与`MultiTypeBlockVector`类相同的原因，`MultiTypeBlockMatrix`类的行和列上没有迭代器。然而，`MultiTypeBlockMatrix`的条目可以使用`operator []`和`dune/common/indices.hh`中的静态自然数_0, _1, _2等进行访问（参见`MultiTypeBlockVector`一节）。为了证明这一点，下面的代码为上面给出的例子类型的对象设置右下角矩阵块的大小。

~~~C++
myMultiTypeMatrix[_1][_1].setSize(10,10);
~~~



同样地，下面的代码将左上角的标量矩阵条目设置为3.14。

~~~C++
myMultiTypeMatrix[_0][_0][0][0][0][0] = 3.14;
~~~


关于使用$10.8$类的实际例子，见第`MultiTypeBlockMatrix`章。

与条目式访问相反，就矩阵向量积和矩阵规范而言，`MultiTypeBlockMatrix`和其他`dune-istl`矩阵之间完全没有区别。  `MultiTypeBlockMatrix`实现了[Tab7.6]中列出的所有操作（除了`solve`、`inverse`和`leftmultiply`方法之外），它们的行为符合预期。例如，下面的代码构造了与上面定义的矩阵类型相匹配的向量$\mathrm{x}$和$\mathrm{b}$，并计算了`residual` $r(x):=b-A x:$。

~~~C++
using Vector = MultiTypeBlockVector<BlockVector<FieldVector<double,2> >,
                                                    BlockVector<double> >;
Vector x = ...;
Vector b = ...;
auto r = b;
myMultiTypeMatrix.mmv(x,r); // r -= Ax
~~~



由于这些矩阵-向量乘积通常是实现`Krylov-type`迭代求解器所需要的全部内容，下面第$7.4.1$章中介绍的求解器对`MultiTypeBlockMatrix`类型的矩阵可以完美地工作。


$$
\text { Matrix }
$$

$$
\begin{aligned}
&A=\left(\begin{array}{cccc}
0 & 3 & 0 & 0 \\
4 & 1 & 0 & 0 \\
0 & 5 & 9 & 2 \\
6 & 0 & 0 & 5
\end{array}\right), \\
&\begin{array}{|l|l|l|l|l|l|l|l|l|}
\hline \text { val } & 3 & 4 & 1 & 5 & 9 & 2 & 6 & 5 \\
\hline \operatorname{col} & 1 & 0 & 1 & 1 & 2 & 3 & 0 & 3 \\
\hline
\end{array}
\end{aligned}
$$

代理人。



\textbf{BCRSMatrix}

该班级

~~~C++
template<class B, A=std::allocator<B> >
class BCRSMatrix
~~~

以`compressed-row-storage`（CRS）格式（前缀BCRS缩写为Block-CRS）实现一般稀疏矩阵。这是有限元实现中最常用的格式，因此`BCRSMatrix`是有限 `element stiffness matrices` 的标准选择。它被定义在头文件 `dune/istl/bcrsmatrix.hh` 中。

为了理解`BCRSMatrix`对象是如何构建和使用的，我们需要简单回顾一下CRS格式。更多细节请阅读，例如，[^133]，其中的格式被称为`sparse row-wise format`。CRS格式的稀疏矩阵由三个数组组成，我们称之为 `val` 、 `col` 和 `row` 。第一个数组存储矩阵中的所有非零值，从左上角到右下角排序。第二个数组`col`，与第一个数组大小相同，包含每个值的相应列索引。最后，第三个数组`row`包含每个`row`的一个整数条目，这是其他两个数组中这个`row`的第一个条目的索引。  [Fig7.4]显示了一个例子$4 \times 4$矩阵的数据结构的样子。要访问例如第三`row `和第二列中的条目，第一步是查找第三行的值，即'3'。此外，还要注意下面的值，也就是6'。然后在`col`的条目中搜索3和6之间的所需列号，在这个例子中是'1'。如果像本例中一样，找到了列号，那么`val`的相应条目就是所需的矩阵条目。否则，该矩阵条目为零。

CRS数据结构非常紧凑，对模式的信息存储非常少。遍历一行的所有非零条目是很便宜的，而且由于列索引可用，从右边乘以一个向量可以有效地实现。这使得CRS矩阵在使用`Krylov`求解器时很有吸引力，因为它只使用矩阵-向量乘积。有点令人惊讶的是，尽管对一列的非零项进行迭代是很昂贵的，但从左边乘以一个向量也很便宜[^133] 7.14章。另一方面，直接访问一个矩阵元素$(i, j)$需要对$i^{th}$行的所有元素进行二进制搜索，因此相对昂贵。尽管如此，`Gauss-Seidel`和`Jacobi`多网格方法的平滑器也可以便宜地实现。

另一个结果是，一旦CRS矩阵建立起来，再增加或删除矩阵元素就非常昂贵，因为（大）`val`和`col`数组的内容需要移位。一些实现允许在每行的末尾有一点额外的内存用于此目的，当然这也增加了整体的内存消耗，降低了缓存性能。

`BCRSMatrix`类使用CRS格式实现了一个稀疏的矩阵。忠实于`dune-istl`的嵌套策略，`BCRSMatrix`的每个条目可以是一个`dune-istl`矩阵或一个数字类型，由第一个模板参数B设置。

~~~C++
BCRSMatrix<double>
~~~

是有标量项的稀疏矩阵的典型选择。对于有3个矢量系数的矢量值方程，那么

~~~C++
BCRSMatrix<FieldMatrix<double , 3,3>>
~~~

更为合适，因为它降低了存储矩阵模式所需的数据量（与标量项的矩阵相比），并给解算和装配算法提供了更多关于矩阵结构的信息。

`BCRSMatrix`类实现了第7.3.1章中描述的整个矩阵接口，包括所有规范和矩阵-向量乘积。请注意，由于第260页给出的原因，方法infinity_norm不会计算由向量$\infty$ -norm引起的矩阵规范，除非`BCRSMatrix`的条目是标量。由于没有典型的方法来反转一般的稀疏矩阵，`BCRSMatrix`类并没有实现反转和求解方法。

用于将 `BCRSMatrix` 对象打印到屏幕上或将其写入文件的基础设施在文件 `dune/istl/io.hh` 和 `dune/istl/matrixmarket.hh` 中提供。

\textbf{How to Construct a `BCRSMatrix` Object}

在有限元模拟中实现CRS矩阵的主要挑战是如何设置它。CRS数据结构的最重要用途是保存刚度矩阵。这个矩阵的值是在网格元素的循环过程中计算出来的（2.1.3章），除非网格实体以非常特殊的方式排序，否则矩阵的条目基本上是以随机顺序访问的。然而，只有在模式（即col和row字段）已经设置好的情况下，数值才能被写进矩阵。一个天真的实现会在所有元素上迭代两次：一次是确定矩阵模式，另一次是确定实际值。其他方法可以用一个循环来设置矩阵，但有其他的缺点。

`BCRSMatrix`类提供了三种不同的方式来设置该模式。它们被称为构建模式，它们是在易用性、内存消耗和速度之间的不同妥协。第四种方式使用`MatrixIndexSet`类，它使矩阵设置更加容易，但代价是内存占用更大。

要构建一个`BCRSMatrix`对象，请调用其中一个构造函数

~~~C++
BCRSMatrix(size_type n,
           size_type m,
           BuildMode bm)
BCRSMatrix( size_type n, // This constructor only for implicit build mode
            size_type m,
            size_type avg,
            double compressionBufferSize,
            BuildMode bm)
~~~



两者都是用未初始化的模式创建一个空矩阵。每个构造函数都有一个枚举类型的参数`BuildMode`，它可以取三个值之一`BCRSMatrix::random, BCRSMatrix::implicit`，以及`BCRSMatrix::row_wise (see below`对avg和`compressionBufferSize`参数的解释）。)第二个构造函数只能在`implicit`构建模式下使用。此外，`BCRSMatrix`对象可以是默认构建的。在这种情况下，矩阵构建模式和尺寸由以下方法设置

~~~C++
void setSize(size_type rows, size_type columns)
void setBuildMode(BuildMode bm)
void setImplicitBuildModeParameters(size_type avg,
                        double compressionBufferSize)
~~~


我们依次讨论这四种方法中的每一种，并给出每种构建模式的完整示例程序。这些例子程序是一个文件的一部分，附在本文件的电子版本中。它没有在附录中重印，因为这里显示的几乎是整个文件的内容。

\textbf{The `random` Build Mode} `random` 构建模式在`BCRSMatrix`对象接受任何实际的矩阵条目之前构建整个模式。它需要对每一行的非零条目数有一个良好的上限。理想情况下，这些数字是确切知道的。

要在`random`模式下构建一个矩阵模式，首先要设置每一行的非零条目数。在行号$i=0, \ldots, n-1$上循环，对于每一个行号i调用成员方法

~~~C++
void setrowsize(size_type i, size_type numberOfNonzeroEntriesInIthRow)
~~~


理想情况下，参数`number0fNonzeroEntriesInIthRow`应该是$i^{th}$行中非零条目的确切数量。也可以在这里提供一个更大的数字，在这种情况下，行和`val`数组将包含大块的未使用的内存。这不会导致错误或未定义的行为，但会增加内存消耗，并可能妨碍执行速度。

在所有行的大小都被设定后，调用方法

~~~C++
void endrowsizes()
~~~

然后，实际的模式必须被设置。对于将出现在矩阵中的每个非零条目$a_{i j}$，调用

~~~C++
void addindex(size_type row, size_type col)
~~~

在一行中输入比先前宣布的更多的索引是一个错误。一旦所有条目都被输入，请调用

~~~C++
void endindices()
~~~

在这一点上，矩阵模式已经完全初始化，可以向其写入数值。为了展示一个完整的例子，下面的代码设置了来自 [Fig7.4] 的4×4矩阵。

~~~C++
 BCRSMatrix<double> matrix(4, 4, BCRSMatrix<double>::random);

 matrix.setrowsize(0,1);
 matrix.setrowsize(1,2);
 matrix.setrowsize(2,3);
 matrix.setrowsize(3,2);
 matrix.endrowsizes();

 matrix.addindex(0,1);
 matrix.addindex(1,0);
 matrix.addindex(1,1);
 matrix.addindex(2,1);
 matrix.addindex(2,2);
 matrix.addindex(2,3);
 matrix.addindex(3,0);
 matrix.addindex(3,3);
 matrix.endindices();

 matrix[0][1] = 3;
 matrix[1][0] = 4;
 matrix[1][1] = 1;
 matrix[2][1] = 5;
 matrix[2][2] = 9;
 matrix[2][3] = 2;
 matrix[3][0] = 6;
 matrix[3][3] = 5;

 // From the file dune/istl/io.hh
 printmatrix(std::cout, matrix, "random-built matrix", "--");
~~~

访问一个不属于模式的矩阵条目会产生错误信息。

\textbf{The `implicit` Build Mode}使用`random`方案来设置有限元刚度矩阵，需要对网格进行两次处理：一次是设置矩阵模式，另一次是汇集实际数值。这在时间和内存方面都是很昂贵的。对网格元素和它们的自由度进行一次完整的传递需要时间，而在这样的传递中确定行的大小和模式需要分配额外的记账内存。相比之下，`implicit`的构建模式允许在一次通过中设置和组装一个完整的矩阵，只要对每行的平均矩阵条目数有一个有根据的猜测。它将自己的内存占用率保持在尽可能低的水平，而且根本不要求调用代码保留额外的内存。

当用`BCRSMatrix`构建模式构建一个`implicit`对象时，它首先分配一块内存，其空间足以容纳预期的条目数，前面是一个空闲区域，称为`compression buffer` 。然后，用户可以开始提供矩阵条目，包括位置和数值。如果超过了某一行的预期条目数，进一步的条目将被写入动态分配的第二个缓冲区，称为`overflow area`，它以坐标-数值对的形式存储条目。在所有矩阵条目被插入后，一个压缩步骤优化了矩阵数据布局，并将`overflow area`中的任何条目整合到标准CRS方案中。这个算法是就地工作的，但它需要`compression buffer`，在这个过程中它被覆盖了。最终的结果是一个CRS数据布局，在单一的内存段中是完全连续的（ [Fig7.5] ）。

要使用该模式，请用专用构造函数构建一个矩阵对象

~~~C++
BCRSMatrix(size_type n, size_type m,
            size_type avg,
            double compressionBufferSize,
            BuildMode buildMode)
~~~



或者，使用其他构造函数（将`buildMode`参数设置为`implicit`），并使用方法提供额外的信息。

~~~C++
void setSize(size_type rows, size_type columns)
void setImplicitBuildModeParameters(size_type avg,
                        double compressionBufferSize)
~~~


参数avg表示每行矩阵条目的预期平均数量。参数`compressionBufferSize`表示`compression buffer`的大小，以所有行的预期条目数的一部分表示。换句话说，如果$\mathrm{N}$是矩阵的行数，`compression buffer`的总大小将是

$$
S_{\text {compression }}=\mathbb{N} \times \text { avg } \times \text { compressionBufferSize. }
$$

然后可以用条目来填充矩阵。然而，对于矩阵的行和列，不是使用`operator []`，而是使用方法

~~~C++
B& entry(size_type row, size_type col)
~~~

必须被使用。它返回一个对该值的引用，如果该条目还不存在，则隐含地创建该条目。然而，请注意，新创建的条目不会自动设置为零，因此，第一次访问需要进行赋值。新条目被放置在正确的矩阵行中，直到该行的平均条目数用完。更多的条目被放置在溢出区，溢出区的速度较慢，但没有大小限制。

在为每个非零矩阵条目调用了`entry`方法后，再调用

~~~C++
CompressionStatistics compress()
~~~

将数据重新组织成标准的CRS数据布局（[Fig7.5]）。在这一步之后，不得添加任何矩阵条目。压缩算法的时间复杂度是线性的，而且它不分配更多的内存。它使用并覆盖`compression buffer`，如果该缓冲区太小，压缩算法就会抛出一个异常而中止。对 "太小 "的精确定义--以及对`compressionBufferSize`参数的良好选择--不仅取决于最终矩阵中条目的总体数量，而且还取决于它们在矩阵行中的分布方式。例如，在自适应细化的网格上进行模拟，预计每行的非零条目数会有更大的差异，因此可能需要更大的`compression buffer` 。详情见`BCRSMatrix`类的在线文档。

`compress` 方法返回一个类型为 `CompressionStatistics` 的对象，其中包含压缩步骤的信息。它可以用来调整参数avg和 `compressionBufferSize` 。


下面的例子显示了如何使用[Fig7.4]构建模式从`implicit`构建示例矩阵。

~~~C++
 BCRSMatrix<double> matrix(4, 4,
 2, // Expected average number of nonzeros
 // per row
 0.2, // Size of the compression buffer,
 // as a fraction of the expected
 // total number of nonzeros
 BCRSMatrix<double>::implicit);

 matrix.entry(0,1) = 3;
 matrix.entry(1,0) = 4;
 matrix.entry(1,1) = 1;
 matrix.entry(2,1) = 5;
 matrix.entry(2,2) = 9;
 matrix.entry(2,3) = 2;
 matrix.entry(3,0) = 6;
 matrix.entry(3,3) = 5;

 // Compress matrix data structure
 auto compressionStatistics = matrix.compress();

 // From the file dune/istl/io.hh
 printmatrix(std::cout, matrix, "implicitly-built matrix", "--");

 // Show the actual average number of nonzeros per row for this matrix
 std::cout << "Average number of nonzeros per row: "
 << compressionStatistics.avg << std::endl;
~~~



这段代码比之前的短，而且速度更快，因为矩阵的模式和数值是一起设置的。不过，使用矩阵的效率还是和使用用`random`模式构建的矩阵一样高，因为它们最终有相同的内存布局。这些优势的代价是，如果`compression buffer`太小，算法会失败，如果缓冲区太大，算法会占用未使用的内存（[Fig7.5]）。这个代价是否可以接受，取决于用户的需求。

\textbf{The `row_wise` Build Mode} 第三种构建模式需要逐行提供模式。这是有可能的，例如，对于结构化网格的刚度矩阵，或者从文件中读取矩阵时。已经设置了模式的行可以立即填入数值。作为这种灵活性的代价，条目的值和列索引不是存储在一个连续的内存块中，而是每一行都被单独分配。这可能会影响缓存的性能。


为了逐行插入模式，`BCRSMatrix`类提供了一个单独的迭代器，称为 `CreateIterator` 。这个迭代器在矩阵的行上向前迭代。整个矩阵行的范围可以通过调用以下方法获得

~~~C++
CreateIterator BCRSMatrix::createbegin()
CreateIterator BCRSMatrix::createend()
~~~


A `CreateIterator`并不具备常规迭代器的所有功能--特别是它不能被取消引用。然而，矩阵模式条目可以通过调用

~~~C++
void CreateIterator::insert(size_type j)
~~~

调用这个方法将把当前行的第$j$个条目添加到模式中。对于每个矩阵行，该方法可以根据需要调用多次，而且列的索引不必以任何特定的顺序给出。将迭代器推进到下一行肯定会提交该行的模式。然后，前一行可以立即被填入数值。一旦`CreateIterator`遍历了所有的行，矩阵模式就完全被设定了，不能再被改变。

下面是使用[Fig7.4]构建模式对`row-wise`中的示例矩阵的设置情况。

~~~C++
 BCRSMatrix<double> matrix(4, 4, BCRSMatrix<double>::row_wise);

 auto ci = matrix.createbegin();

 ci.insert(1);
 ++ci;
 matrix[0][1] = 3;

 ci.insert(0);
 ci.insert(1);
 ++ci;
 matrix[1][0] = 4;
 matrix[1][1] = 1;

 ci.insert(1);
 ci.insert(2);
 ci.insert(3);
 ++ci;
 matrix[2][1] = 5;
 matrix[2][2] = 9;
 matrix[2][3] = 2;

 ci.insert(0);
 ci.insert(3);
 ++ci; // Important: advance to one-past-the-last-row,
 // to commit the last row pattern
 matrix[3][0] = 6;
 matrix[3][3] = 5;

 // From the file dune/istl/io.hh
 printmatrix(std::cout, matrix, "row_wise-built matrix", "--");
~~~






如果已知模式是按行排列的，`row_wise`构建模式是最方便的模式。然而，由于按行分配存储空间，矩阵数据在内存中是分散的，像矩阵-向量乘积这样的操作可能不如用其他构建模式建立的矩阵快。

\textbf{The `MatrixIndexSet` Approach}以前的构建模式试图避免在网格上做两遍，以便有效地建立一个稀疏的刚度矩阵。这是有代价的--`implicit`构建模式需要对矩阵行的大小进行某种初始猜测，而错误的猜测可能导致次优的线性代数性能甚至程序终止。

然而，在某些情况下，矩阵设置成本根本就不是一个问题。与实际使用矩阵的时间相比，做几次网格迭代所需的时间可能并不重要。同样地，内存消耗也不总是一个问题。在这种情况下，矩阵的设置应该是简单方便的。`dune-istl`模块为此提供了`MatrixIndexSet`类（在文件`dune/istl/matrixindexset.hh`）。它在内部使用随机构建模式，但在实际应用中，它构成了第四种矩阵构建模式。要使用它，请构建一个`MatrixIndexSet`对象，并使用方法添加所有模式条目

~~~C++
void add(size_type i, size_type j)
~~~

条目可以以任意的顺序添加。一旦完成，整个模式被复制到一个`BCRSMatrix`对象中，方法是

~~~C++
template<class MatrixType>
void exportIdx(MatrixType& matrix) const
~~~


下面是使用[Fig7.4]的例子矩阵是如何设置的，`MatrixIndexSet` 。

~~~C++
 MatrixIndexSet pattern(4,4);

 pattern.add(0,1);
 pattern.add(1,0);
 pattern.add(1,1);
 pattern.add(2,1);
 pattern.add(2,2);
 pattern.add(2,3);
 pattern.add(3,0);
 pattern.add(3,3);

 BCRSMatrix<double> matrix;

 pattern.exportIdx(matrix);

 matrix[0][1] = 3;
 matrix[1][0] = 4;
 matrix[1][1] = 1;
 matrix[2][1] = 5;
 matrix[2][2] = 9;
 matrix[2][3] = 2;
 matrix[3][0] = 6;
 matrix[3][3] = 5;

 // From the file dune/istl/io.hh
 printmatrix(std::cout, matrix, "matrix built with a MatrixIndexSet", "--");

~~~


这段代码很简单。问题是`MatrixIndexSet`对象可能会变得很大--对于标量矩阵来说，它消耗的内存几乎和最终矩阵本身一样多。此外，它还需要进行大量的分配和解配，因此它的速度可能不是很快。这是为额外的便利所付出的代价。

\textbf{`BDMatrix` and `BTDMatrix`}

类`BDMatrix`和`BTDMatrix`分别实现了（块）`diagonal`和（块）三对角矩阵的动态大小。它们的声明是

~~~C++
template<class B, class A=std::allocator<B> >
class BDMatrix
template<class B, class A=std::allocator<B> >
class BTDMatrix
~~~



两种类型的给定初始化对象都可以像一般稀疏矩阵一样使用。然而，矩阵的构造和设置更容易，而且实现起来也更省时省力一些。要构造这样的矩阵，请用单一的大小调用构造函数（`diagonal`和三对角矩阵是四次方的）。

~~~C++
BDMatrix<double> a(10);
BTDMatrix<FieldMatrix<double,2,2> > b(10);
~~~

并使用`operator []`设置行和列的条目。

~~~C++
// Make an identity matrix
BDMatrix<double> identity(10);
for (std::size_t i=0; i<identity.N(); i++)
identity[i][i] = 1.0;
~~~


即使这两个矩阵都是稀疏的，对于每一行`operator []`都是非常快的，因为这些模式是非常有规律的，并且是先验的。访问不在`diagonal`或三对角线模式中的条目会导致未定义行为，必须避免。  `BDMatrix`对象也可以通过初始化器列表来构建

~~~C++
BDMatrix<double> m = {1.0, 1.0, 1.0};
~~~

与`Matrix`对象一样，`BDMatrix`和`BTDMatrix`对象的大小可以在任何时候通过调用

~~~C++
void setSize(size_type n)
~~~

最后，`BDMatrix`和`BTDMatrix`都实现了求解方法，而`BDMatrix`甚至实现了反转方法。这甚至适用于嵌套矩阵，只要入口类型也实现了`invert`。经适当修改后，同样适用于线性方程组的求解。`BTDMatrix`的求解方法实现了三对角矩阵的专用算法[^75]，具有线性时间和空间复杂性。

\subsection{Solvers and Preconditioners}

`dune-istl`模块使用上述的矩阵和向量接口实现了一系列代数问题的求解器。大多数求解器是迭代式的，需要适当的预处理。因此，`dune-istl`提供了一个预处理程序的接口，以及一组预处理程序的实现。所有这些求解器和预处理器都可以在顺序机和MPI并行机上运行。特别重要的是代数多网格（AMG）预处理程序，它已被证明可以扩展到几十万个核心 [^31] [^100] 。本节介绍了求解器和预处理器，而`AMG`预处理器有自己的专门章节 $7.5$ 。

\subsubsection{Solvers}

`dune-istl`中的求解器接口是基于算子方程的概念。让$X, Y$是两个抽象空间，$A$是一个算子

$$
A: X \rightarrow Y
$$

然后，对于一个给定的$y \in Y$，任务是找到一个$x \in X$，以便

\begin{equation}
A(x)=y
\label{7.1}
\end{equation}

如果存在这样一个$x$，可以用算子$A$的逆运算来正式书写。

$$
x=A^{-1}(y)
$$

对于`dune-istl`，空间$X$和$Y$将始终是`Euclidean`空间。原则上，算子$A$可以是线性或非线性的。然而，目前只实现了线性算子的求解器。如果算子$A$是线性的，它可以被识别为一个矩阵，通过滥用符号，我们也用$A$表示。我们恢复标准的线性方程组

$$
A x=y
$$

在这种情况下，我们经常将向量$y$表示为$b$ 。

抽象算子的观点激励着解算器接口的构建方式。其基础是抽象的基类

~~~C++
template<class X, class Y>
class InverseOperator
~~~

(第4.4.1章）。)模板参数$X$和$Y$必须是`dune-istl`矢量数据类型，它们代表两个空间$X$和$Y$ 。从`InverseOperator`派生的类代表反算子$A^{-1}$，将这种反算子应用于向量$y$相当于解决算子系统$A(x)=y$。因此，`InverseOperator`类的两个主要（和唯一）方法是

~~~C++
virtual void apply(X& x, Y& y, InverseOperatorResult& res) = 0
virtual void apply(X& x, Y& y,
                               double reduction,
                               InverseOperatorResult& res) = 0
~~~


两者都对$\mathrm{y}$中给出的向量应用逆运算，并返回$\mathrm{x}$中的结果（即，它们解决系统$A(x)=y$）。如果实现使用迭代算法，那么参数 $\mathrm{x}$ 的内容将被用作初始迭代 $x^{0}$ 。注意，第二个参数$\mathrm{y}$是一个非静态引用。解算器的实现可以修改这个变量，事实上，许多`dune-istl`解算器在终止后会将`residual`留在y中。要注意这一点：它是微妙bug的来源。

第一个`apply`方法让实施者决定对$A^{-1} y$的评估应该有多精确，而第二个方法允许在`reduction`参数中要求一个剩余的减少系数。实施将尝试产生一个$x^{k} \in X$，使残差减去

$$
\operatorname{red}\left(x^{k}\right):=\frac{\left\|y-A x^{k}\right\|}{\left\|y-A x^{0}\right\|}
$$

小于 `reduction` 中给出的数字。

两个apply方法都期望有一个类型为`Inverse0peratorResult`的对象作为其最后的参数。在apply方法终止时，这个对象将被填入有关解决程序的信息。这些信息可以直接从该类的公共数据成员中获得。这些是

~~~C++
int iterations // Number of iterations
double reduction // Reduction achieved: red(xk) = kb − A(xk)k/kb − A(x0)k
bool converged // True if convergence criterion has been met
double conv_rate // Convergence rate (average reduction per step)
double elapsed // Elapsed time in seconds
~~~


此外，`Inverse0peratorResult`类有一个方法

~~~C++
void clear()
~~~

它将所有的值重置为合理的默认值。

解算器接口的实际实现来自于`InverseOperator`类，并实现了应用方法。在 `file dune/istl/solvers.hh` 中可以找到几个这样的实现。例如，类

~~~C++
template<class X>
class CGSolver : public InverseOperator<X,X>
~~~

实现了一个标准的预处理共轭梯度求解器 [^146] 。请注意，唯一的模板参数是用于迭代的向量类型X和右手边的向量。矩阵类型是在调用构造函数时给求解器的。

~~~C++
template<class LinearOperator, class Preconditioner>
CGSolver(LinearOperator& linearOperator,
         Preconditioner& preconditioner,
         real_type reduction, int maxIterations, int verbose)
~~~


其中的第一个参数代表方程7.1的算子。在线性情况下，`Operator`不是直接的矩阵类型，而是用接口类`MatrixAdapter`包裹的`dune-istl`矩阵。这种额外的重定向买到了一些额外的灵活性。非线性算子可以取代线性算子，而且有可能实现无矩阵的线性算子。最后，几个分布式求解器算法需要修改子域矩阵，用`Operator`层更容易做到。第二个模板参数`Preconditioner`代表预处理程序，可以从第7.4.2章的列表中选择，或者自定义实现。

作为一个例子，用这种实现方式解决一个线性系统的代码可以从第 $3.3$ 章的完整示例程序中看到以下节选。

~~~C++
 // Choose an initial iterate that fulfills the Dirichlet conditions
 Vector x(basis.size());
 x = b;
 // Turn the matrix into a linear operator
 MatrixAdapter<Matrix,Vector,Vector> linearOperator(stiffnessMatrix);
 
 // Sequential incomplete LU decomposition as the preconditioner
 SeqILU<Matrix,Vector,Vector> preconditioner(stiffnessMatrix,
                                             1.0); // Relaxation factor

 // Preconditioned conjugate gradient solver
 CGSolver<Vector> cg(linearOperator,
                     preconditioner,
                     1e-5, // Desired residual reduction factor
                     50, // Maximum number of iterations
                     2); // Verbosity of the solver
 // Object storing some statistics about the solving process
 InverseOperatorResult statistics;

 // Solve!
 cg.apply(x, b, statistics);
~~~



第381行从`MatrixAdapter`对象中给出的矩阵构造一个`stiffnessMatrix`。第384行设置了一个预处理程序；本例中是ILU预处理程序 [^138] 。第388行构造了实际的CG求解器，最后一行用右手边的向量b调用它。在这次调用之后，$x$将包含近似解，b是相应的残差，而`statistics`对象将包含所需的壁垒时间、迭代次数等。

在文件 `dune/istl/solvers.hh` 中有许多求解器的实现。其中一些比较重要的是。

- `CGSolver` , `BiCGStabSolver` : 这些是标准共轭梯度和`BiCGStab`算法的实现，分别用于对称正定和非对称矩阵 [^138] 。这两种算法都需要一个预处理程序。

- `LoopSolver` : 实现了标准的预设条件`Richardson`迭代。

$$
x^{x+1}=x^{k}+P\left(b-A x^{k}\right)
$$

对于一个给定的预处理程序 $P \approx A^{-1}$ 。

- `GradientSolver`：该类通过梯度法最小化标量函数$J(x)=\frac{1}{2} x^{T} A x-b^{T} x$来解决系统$A x=b$（只要$A$是对称的）。换句话说，迭代的计算方法是

$$
x^{x+1}=x^{k}+\lambda^{k} P\left(-\nabla J\left(x^{k}\right)\right)=x^{k}+\lambda^{k} P\left(b-A x^{k}\right)
$$

其中$P: Y \rightarrow X$是一个预处理程序，$\lambda^{k}>0$是最佳阻尼参数

$$
\lambda^{k}:=\frac{\left\langle P r^{k}, r^{k}\right\rangle}{\left\langle A P r^{k}, P r^{k}\right\rangle}, \quad r^{k}:=b-A x^{k}
$$

- `MINRESSolver` , `RestartedGMResSolver` : 这些实现了著名的 `MINRES` [^84] 和 `GMRES` [^139] 解算器，分别用于不确定的对称和非对称线性系统。

`dune-istl`模块本身并没有实现直接稀疏解算器，但它允许通过其接口调用几个标准的开源实现。分别来自文件`dune/istl/umfpack.hh`、`dune/istl/cholmod.hh`和`dune/istl/superlu.hh`的类`UMFPack`、`Cholmod`和`SuperLU`提供了对UMFPACK[^46]、CHOLMOD[^41]和SUPERLU[^116]解算器的访问。这样的求解器对于中小型问题来说是非常快的，而且它们的速度并不取决于矩阵的条件数。尽管底层库只支持标量项的矩阵，但围绕它们的`dune-istl`层也允许将它们用于块状矩阵。根据精确的矩阵类型，这可能涉及到矩阵的内部拷贝，这增加了存储需求，但对运行时间的影响可以忽略不计。关于直接求解器实现的细节，请参见在线类文档。



\subsubsection{Preconditioners}

上一节的所有迭代求解器都需要进行预处理，以便在任何非微观的有限元问题上达到合理的速度。为此，`dune-istl`提供了一个预处理程序的接口，以及各种标准实现。所有这些都在顺序和分布式环境中运行。

回顾一下，在数学上，方程$P$的预处理器$A x=b$是$A$的逆的近似值。

$$
P: Y \rightarrow X, \quad P \approx A^{-1}
$$

系统$A x=b$通过与$P$相乘进行预处理。

$$
P A x=P y
$$

如果做得好，这个系统的矩阵$P A$比原始矩阵$A$的条件好得多。

先决条件几乎没有被计算和存储为实际的矩阵。相反，它们以算法的形式存在，实现$P$对`residual`矢量$r \in \mathbb{R}^{n}$的应用。很多标准的预处理程序可以解释为方程$A v=r$的迭代求解算法，用初始迭代$v=0 \in \mathbb{R}^{n}$做一个步骤。

由于预处理器是反算子的某些形式，它们在`dune-istl`中的接口接近于`InverseOperator`的接口。`dune-istl`中的所有预处理程序必须继承自抽象基类

~~~C++
template<class X, class Y>
class Preconditioner
~~~


模板参数$X$和$Y$必须是`dune-istl`矢量接口的实现，并分别用于迭代和`residual`矢量对象。`Preconditioner`接口的中心方法是

~~~C++
virtual void apply(X& v, const Y& r)
~~~


它对$P$$r$应用预处理程序，即计算$v=P r$，并在第一个参数v中返回结果。如果预处理程序作为系统$A v=r$的迭代方法实现，那么调用`apply`时$\mathrm{v}$的值就是初始迭代值。对于标准预处理程序的应用，它应该等于 $0 \in \mathbb{R}^{n}$ 。


此外，`Preconditioner`接口规定了一个设置和一个最终确定的方法

~~~C++
virtual void pre(X& x, Y& b)
virtual void post(X& x)
~~~


解算器必须在第一次和最后一次调用`apply`之后分别调用这些方法。例如，这些方法可以照顾到预处理程序的内存管理任务。两个方法的参数$\mathrm{x}$是迭代向量，$\mathrm{b}$是线性系统的右手边。许多标准的预处理程序不考虑这些参数，但它们可能是有用的，例如，对于某些缩放算法。

`dune-istl` 模块在文件 `dune/ istl/preconditioners.hh` 中提供了几个标准的预处理程序。

- `Richardson`预处理程序通过一个按比例的身份矩阵$\lambda I$来接近$A^{-1}$ 。标量$\lambda$可以在构造函数中选择。在这里选择$\lambda=1$是最简单的方法，完全没有预处理程序。

- 预处理程序`SeqJac`、`SeqGS`、`SeqSOR`和`SeqSSOR`分别实现`Jacobi`、`Gauss-Seidel`、SOR和`SSOR`的预处理。这些预处理程序带有Seq前缀，以区别于它们的并行表兄弟，后者实现了分布式线性方程组的相同算法。

- `SeqILU` 通过不完全 $L U$ 分解实现预处理，无论是零阶还是高阶 [^138] 。`SeqILDL`预处理程序使用不完全$L D L$（`Cholesky`）分解对对称矩阵做同样的处理。

- `AMG` 是一个代数多网格预处理程序。它将在第 $7.5$ 章详细讨论。

- 类`Inverse0perator2Preconditioner`允许包裹任何求解器（即任何从`InverseOperator`派生的类）作为一个预处理器。

除了矩阵和向量类型外，其中一些预处理程序（例如 `SeqJac` , `SeqSOR` , `SeqSSOR` ）还有一个额外的整数模板参数，即块递归级别 $k$ 。这些预处理程序对嵌套层次结构中最外层的矩阵类型的条目进行操作。块递归级别参数决定了如何对矩阵 `diagonal` 上的块进行反演。如果这些块是矩阵和$k=1$（默认），那么就使用该`diagonal`项的反转和求解方法，不管是什么方法都比较合适。如果$k>1$，那么就递归调用该`diagonal`块的预处理程序，块递归级别为$k-1$ 。这允许在执行速度和预处理程序的近似能力之间进行各种权衡。对$k$的最佳选择取决于应用和矩阵类型。

\subsubsection{Distributed Solvers}

到目前为止，本文只涉及`dune-istl`中只有一个进程的情况。然而，求解器和预处理器是完全并行的，可以在几乎任意大小的分布式机器上使用 [^31] [^100] 。在 `dune-istl` 中有两种不同的分布式计算的概念方法。我们在此描述与前面的讨论有更直接关系的那一种。另一种是基于抽象的分布式索引集和 [^14] 中描述的数据一致性模型，由于篇幅有限，我们不予考虑。然而，在这两种方法中，机器模型预计都是分布式的；共享内存并行目前没有在 `dune-istl` 中得到利用。

与分布式线性代数的其他实现不同，如 `EPETRA` 或 `PETSC` [^6] [^7] ，`dune-istl` 不使用分布式矩阵和向量数据类型。矩阵和向量只存在于单个进程中，它们与其他进程中的其他矩阵和向量的关系必须由一个单独的代理来管理。从概念上讲，这也与`dune-grid`模块中的情况相反，在该模块中，网格对象是分布式对象，既代表了网格的不同部分，也代表了关于相互关系的信息。

这里要讨论的`dune-istl`并行化概念主要是指预设条件的`Krylov`求解器。它认为这种求解器是由某些构件构成的，其中只有一些构件需要知道数据分布。只要使用适当的并行化构件，主要求解器的实现就可以在顺序和分布的情况下发挥作用。

`dune-istl`接口确定了`Krylov`求解器使用的三个需要知道数据分布的构件，即矩阵-向量乘法、预处理器评估和标量积。这三个模块在 `dune-istl` 中被正式定义为接口。矩阵向量乘法由`LinearOperator`类完成，预处理程序由`Preconditioner`实现覆盖，还有一个接口用于标量积。

`dune-istl`模块提供了三种线性运算符的实现。第一个是`MatrixAdapter`类，在$7.4.1$章关于`dune-istl`求解器接口中已经遇到过，它出现在本书的许多代码示例中。它只是简单地包裹了局部矩阵，而没有对其进行修改。这与另外两个相反，`OverlappingSchwarzOperator`和`NonoverlappingSchwarzOperator`，它们确实对子域边界附近的矩阵进行了某些修改。这些都是由`Schwarz-type`领域分解算法引起的，这里不做讨论。详情见[^14] 。很少有必要写一个自定义的线性算子实现，因此我们在这里省略了接口描述。

第7.4.2章已经讨论了顺序预处理器。对于分布式预处理程序，接口并没有改变，但是实现者可能需要为并行预处理保留额外的信息。例如，一个并行的`Jacobi preconditioner`可以保留矩阵`diagonal`的一致副本。下一节将展示一个实现的例子。

最后，标量产品的接口是相当简单的。实现需要派生自抽象的基类ScalarProduct，并且（主要）实现两个纯虚拟方法

~~~C++
field_type dot(const X& x, const X& y)
~~~

和

~~~C++
real_type norm(const X& x)
~~~


给定一个`LinearOperator`的实现，一个并行的前置条件器，以及一个匹配的标量积实现，这些都可以插入到`Krylov`求解器中，以获得一个在分布式机器上工作的求解器。例如，`CGSolver`类有一个专门的构造函数，除了在任何情况下都需要的线性算子和预调节器外，还接受一个特殊的标量-乘积对象。

~~~C++
template<class LinearOperator, class ScalarProduct, class Preconditioner>
CGSolver(LinearOperator& linearOperator,
        ScalarProduct& scalarProduct,
        Preconditioner& preconditioner,
        real_type reduction, int maxIterations, int verbosity)
~~~


如果线性方程组分布在几个进程中，用这种机制构造的CG求解器将如期工作。求解器本身不对数据分布做任何假设，但当然，预处理程序、线性算子和标量积的假设必须匹配。

\subsubsection{Example: Solving the Poisson Equation with a Distributed Preconditioned CG Method}

本节在一个完整的例子中演示了分布式`dune-istl`求解器接口的使用。为了进行简单的比较，问题的设置和算法与第6.7章中的内容完全相同。该程序在$L$的[Fig6.7]形域上用一个由`Jacobi`方法预设的CG求解器来求解`Poisson`方程。因此，新例子的代码与第$6.7$章的代码基本相同，这里只讨论不同的部分。完整的例子代码9h印在附录B.7中；本书电子版的读者也可以通过点击页边的图标找到它yy。对于网格文件`l-grid-refined.msh`，即程序所使用的R，点击第二个图标。

这里的例子着重于如何在 `dune-istl` 接口的背景下编写分布式线性代数算法。这与展示如何使用 `dune-istl` 方便地解决分布式线性代数问题不一样。对这一点更感兴趣的读者应该看向更高层次的模块，如 `dune-pdelab` 或 `dune-fem` 。

该程序文件以问题汇编器开始。如同第6.7章的例子，集合器是以四种独立方法的形式实现的。这些方法在拉格朗日有限元空间中组装泊松方程的弱形式，并给定体积项。这些方法是`assembleElementStiffnessMatrix`和`assembleElementVolumeTerm`用于元素问题，`get0ccupationPattern`和`assemblePoissonProblem`用于全局装配。接下来是两个数据处理类，用于子域之间的通信。类`LBVertexDataHandle`用于传输顶点数据，同时分布网格，而`VertexDataUpdate`则用于使加法表示的向量保持一致。

正如上一节所解释的，`dune-istl`中的分布式计算是通过将并行的线性算子、前置条件器和标量积与其他顺序求解器的实现相结合来实现的。对于这里实现的算法，本书的顺序代码中已经使用的`MatrixAdapter`类可以作为线性算子使用。数据模型只是要求线性算子与给定的矩阵实现矩阵-向量乘积，而这正是`MatrixAdapter`所做的。

相比之下，预处理程序和标量积必须从头开始编写。因此，第一段新代码是预处理程序的实现。它包括与第$6.7$章相同的代码，但现在使用第$7.4.2$章中描述的预处理程序接口。先决条件在一个继承于接口类 `Preconditioner` 的类 `JacobiPreconditioner` 中实现。在构造函数中，它接收网格视图和对加法表示的局部过程`interior`元素的完整矩阵的引用。然后构造函数使用网格视图通信方法和 `VertexUpdate` 数据句柄来计算和存储矩阵的一致副本 `diagonal` 。没有依赖 $\mathrm{x}$ 或 $\mathrm{b}$ 的准备工作是必要的 $-$ 方法 pre 和 post 存在，但仍然是空的。

~~~C++
 template <class GridView, class Matrix, class Vector>
class JacobiPreconditioner : public Preconditioner<Vector, Vector>
{
public:
    // Constructor
    JacobiPreconditioner(const GridView &gridView, const Matrix &matrix)
        : gridView_(gridView), matrix_(matrix)
    {
        Vector diagonal(matrix_.N());
        for (std::size_t i = 0; i < diagonal.size(); ++i)
            diagonal[i] = matrix_[i][i];

        consistentDiagonal_ = diagonal;
        VertexDataUpdate<GridView, Vector> matrixDataHandle(gridView,
                                                            diagonal,
                                                            consistentDiagonal_);

        gridView_.communicate(matrixDataHandle,
                              All_All_Interface,
                              ForwardCommunication);
    }

    // Prepare the preconditioner
    virtual void pre(Vector &x, Vector &b) override
    {
    }

    // Apply the preconditioner
    virtual void apply(Vector &v, const Vector &r) override
    {
        auto rConsistent = r;

        VertexDataUpdate<GridView, Vector> vertexUpdateHandle(gridView_,
                                                              r,
                                                              rConsistent);

        gridView_.communicate(vertexUpdateHandle,
                              InteriorBorder_InteriorBorder_Interface,
                              ForwardCommunication);

        for (std::size_t i = 0; i < matrix_.N(); i++)
            v[i] = rConsistent[i] / consistentDiagonal_[i];
    }

    // Clean up
    virtual void post(Vector &x) override
    {
    }

    // Category of the preconditioner
    virtual SolverCategory::Category category() const override
    {
        return SolverCategory::sequential;
    }

private:
    const GridView gridView_;
    const Matrix &matrix_;
    Vector consistentDiagonal_;
};
~~~







对加法表示的向量$\mathrm{r}$应用前置条件的方法`apply`实现。`Jacobi preconditioner` 简单地将$\mathrm{r}$分量除以一致矩阵`diagonal` 。其结果是一个一致的预处理残差，这正是`CGSolver`所期望的。

最后一个方法`category`是必需的。它是确保`LinearOperator`、`preconditioner`和`scalar product`匹配机制的一部分。这个特殊的实现必须按顺序返回值，尽管代码是用于分布式计算。这是因为 `MatrixAdapter` 类别是与 `sequential` 硬连接的，这个例子的两个新实现必须遵守这个选择。

在预处理程序之后，是自定义标量积的实现。与`dune-istl`中的并行标量积不同，这里的标量积希望有一对矢量，其中一个是加法表示，一个是一致表示。



~~~C++
 class AdditiveScalarProduct : public ScalarProduct<Vector>
{
    using typename ScalarProduct<Vector>::field_type;
    using typename ScalarProduct<Vector>::real_type;

public:
    // Constructor
    AdditiveScalarProduct(const GridView &gridView)
        : gridView_(gridView)
    {
    }

    // Dot product of a consistent vector x and an additive vector y,
    // or vice versa
    virtual field_type dot(const Vector &x, const Vector &y) const override
    {
        return gridView_.comm().sum(x.dot(y));
    }

    // Norm of a vector given in additive representation
    virtual real_type norm(const Vector &x) const override
    {
        // Construct consistent representation of x
        auto xConsistent = x;

        VertexDataUpdate<GridView, Vector> vertexUpdateHandle(gridView_,
                                                              x,
                                                              xConsistent);

        gridView_.communicate(vertexUpdateHandle,
                              InteriorBorder_InteriorBorder_Interface,
                              ForwardCommunication);

        // Local scalar product of x with itself
        auto localNorm2 = x.dot(xConsistent);

        // Sum over all subdomains
        return std::sqrt(gridView_.comm().sum(localNorm2));
    }

    // Scalar product, linear operator, and preconditioner must be
    // of the same category
    virtual SolverCategory::Category category() const override
    {
        return SolverCategory::sequential;
    }

private:
    const GridView gridView_;
};
~~~




构造函数需要一个网格视图作为其单一参数，以便能够使用网格通信设施。点方法本身，在行 $417-420$ 中，只使用 `dune-grid` 的全局通信设施。由于两个输入向量预计一个是加法表示，一个是一致表示，计算全局标量积只是在每个子域上进行局部标量积，然后再进行全局和。当然，这种简单的方法只对不重叠的网格分区有效。更重要的是，为标量积组装参数向量的代码必须注意不要在`ghost`元素上组装贡献。

另一方面，规范方法的实现确实需要局部通信。该方法希望得到一个加法表示的向量。为了计算规范，还需要向量的一致表示。该表示法与第$6.7$章中使用`VertexDataUpdate`回调类计算的一样。与预处理程序一样，标量积也有顺序类别--否则它不能与`MatrixAdapter`类结合。

这些是这个例子所需要的所有辅助类。剩下的就是主方法了。它和第$6.7$章一样，以加载和分发网格开始。为了方便起见，这部分内容在此重复。


~~~C++
int main(int argc, char *argv[])
{
    // Set up MPI
    const MPIHelper &mpiHelper = MPIHelper::instance(argc, argv);

    // Set up the grid
    constexpr int dim = 2;
    using Grid = UGGrid<dim>;
    using GridView = Grid::LeafGridView;

    std::shared_ptr<Grid> grid = GmshReader<Grid>::read("l-shape-refined.msh");

    std::vector<double> dataVector;
    auto gridView = grid->leafGridView();

    if (mpiHelper.rank() == 0)
    {
        // The initial iterate as a function
        auto initialIterate = [](auto p)
        { return std::min(p[0], p[1]); };

        // Sample on the grid vertices
        dataVector.resize(gridView.size(dim));
        for (const auto &vertex : vertices(gridView, Partitions::interiorBorder))
        {
            auto index = gridView.indexSet().index(vertex);
            dataVector[index] = initialIterate(vertex.geometry().corner(0));
        }
    }

    // Copy vertex data into associative container
    std::map<Grid::LocalIdSet::IdType, double> persistentContainer;
    const auto &idSet = grid->localIdSet();

    for (const auto &vertex : vertices(gridView))
        persistentContainer[idSet.id(vertex)] = dataVector[gridView.indexSet().index(vertex)];

    // Distribute the grid and the data
    LBVertexDataHandle<Grid, std::map<Grid::LocalIdSet::IdType, double>>
        dataHandle(grid, persistentContainer);
    grid->loadBalance(dataHandle);

    // Get gridView object again after load-balancing,
    // to make sure it is up-to-date
    gridView = grid->leafGridView();

    // Copy data back into the array
    dataVector.resize(gridView.size(dim));

    for (const auto &vertex : vertices(gridView))
        dataVector[gridView.indexSet().index(vertex)] = persistentContainer[idSet.id(vertex)];
~~~




接下来，子问题在各个进程上被组装起来。这也与章 $6.7$ 的代码相同。


~~~C++
using Vector = BlockVector<double>;
using Matrix = BCRSMatrix<double>;

Vector rhs;
Matrix stiffnessMatrix;

// Assemble the Poisson system in a first-order Lagrange space
Functions::LagrangeBasis<GridView, 1> basis(gridView);

auto sourceTerm = [](const FieldVector<double, dim> &x)
{ return -5.0; };
assemblePoissonProblem(basis, stiffnessMatrix, rhs, sourceTerm);

// Determine Dirichlet degrees of freedom by marking all those
// whose Lagrange nodes comply with a given predicate.
auto dirichletPredicate = [](auto p)
{
    return p[0] < 1e-8 || p[1] < 1e-8 || (p[0] > 0.4999 && p[1] > 0.4999);
};

// Interpolating the predicate will mark all Dirichlet degrees of freedom
std::vector<bool> dirichletNodes;
Functions::interpolate(basis, dirichletNodes, dirichletPredicate);

///////////////////////////////////////////
// Modify Dirichlet matrix rows
///////////////////////////////////////////

// Loop over the matrix rows
for (size_t i = 0; i < stiffnessMatrix.N(); i++)
{
    if (dirichletNodes[i])
    {
        auto cIt = stiffnessMatrix[i].begin();
        auto cEndIt = stiffnessMatrix[i].end();
        // Loop over nonzero matrix entries in current row
        for (; cIt != cEndIt; ++cIt)
            *cIt = (i == cIt.index()) ? 1.0 : 0.0;
    }
}

// Set Dirichlet values
for (std::size_t i = 0; i < dirichletNodes.size(); i++)
    if (dirichletNodes[i])
        rhs[i] = dataVector[i];

~~~




这部分代码的唯一区别是，第$6.7$章中的版本包含计算一致矩阵的代码`diagonal`，现在由`JacobiPreconditioner`类完成。

经过这样的设置，分布式线性系统的实际并行求解很简单。

~~~C++
// Set the initial iterate
Vector x(basis.size());
std::copy(dataVector.begin(), dataVector.end(), x.begin());

// Set up the preconditioned conjugate-gradient solver
double reduction = 1e-3; // Desired residual reduction factor
int maxIterations = 50;  // Maximum number of iterations

MatrixAdapter<Matrix, Vector, Vector> linearOperator(stiffnessMatrix);
JacobiPreconditioner<GridView, Matrix, Vector> preconditioner(gridView,
                                                              stiffnessMatrix);
AdditiveScalarProduct<GridView, Vector> scalarProduct(gridView);

CGSolver<Vector> cg(linearOperator,
                    scalarProduct,
                    preconditioner,
                    reduction,
                    maxIterations,
                    (mpiHelper.rank() == 0) ? 2 : 0); // Only rank 0
// will print output

// Object storing some statistics about the solving process
InverseOperatorResult statistics;

// Solve!
cg.apply(x, rhs, statistics);
~~~



该代码看起来与第7.4.1章中`CGSolver`类的顺序使用非常相似。不同的是知道数据分解的特殊预处理程序和标量乘积。这些都是在第577和578行构建的，并交给了`CGSolver`构造器。

与顺序代码的唯一区别是输出控制。回想一下，`CGSolver`构造函数的最后一个参数是一个从0到2的整数粗略程度。 简单地将其设置为2，就像在顺序示例中那样，会导致所有进程的屏幕输出。这通常不是我们想要的，因此代码只在主进程上设置2，而在其他地方设置0。

当这个程序运行时，有

~~~C++
mpirun -np <number_of_processes> ./istl-distributed-poisson
~~~

的屏幕输出与第 $6.7$ 章的实现相同。该程序还将结果写入一组VTK文件中（这里没有显示相关的代码）。这些文件看起来与 [Fig6.8] 中的文件相同。

\subsection{The Algebraic Multigrid `Preconditioner`}

在文献中已知的所有有限元问题的预处理方法中，最有效的通常是多网格方法。它们的基础是在不同的分辨率水平上构建问题的近似值，并将所有这些水平上的修正结合起来以获得非常有效的预处理。

多网格方法有两种类型。  `geometric multigrid`需要一个（典型的）嵌套网格的层次结构来构建不同的近似值。当它们工作时， `geometric multigrid` 方法通常非常快，而且可以显示相当数量的理论结果 [^37] [^88] 。然而，这些方法也有其缺点。当PDE具有不连续或高度振荡的系数时，标准的粗近似空间效果很差 [^155] 。另外，在现实世界的应用中，必要的网格层次很难获得，因为虽然细化一个给定的粗网格很容易，但粗化一个给定的非结构化细网格却很有挑战性。

`Algebraic multigrid`（AMG）方法因此采取了一种不同的方法。在其纯粹的形式中，它们只考虑将稀疏矩阵作为输入，并试图仅根据代数信息构建不同层次的线性代数问题的近似值。为此，矩阵的关`diagonal`项$a_{i j}$被解释为自由度$i$和$j$之间关联性的度量，以及粗化，使强耦合的自由度被分组。理论上对`AMG`方法的了解要少得多，但在实践中它们确实经常表现得非常好 [^155] 。

`dune-istl`模块包含了一个最先进的代数多网格预处理程序的实现，为稳健性和速度而优化。它已在 [^30] 中作了详细描述。该实现在顺序和分布式机器上运行，并可扩展到大量的进程 [^31] [^100] 。由于分布式`AMG`的直接设置有点技术性，我们在这里只解释顺序式的实现。分布式`AMG`可以很容易地使用，例如，在`dune-pdelab`模块的帮助下。

\subsubsection{Agglomeration AMG}

`AMG`中的实现是所谓的`dune-istl`。考虑一个稀疏的线性方程组

$$
A x=b
$$

给定的可逆矩阵$A \in \mathbb{R}^{n \times n}$，和向量$b \in \mathbb{R}^{n}$ 。在初始设置阶段，`AMG`方法构建了一个大小为$n_{L}>$$n_{L-1}>\ldots>n_{0}$的矩阵$A_{L}, \ldots, A_{0}$的层次结构，在$L+1$不同的分辨率上表示原始矩阵$A=A_{L}$。这些表示是通过构建延长算子$P_{l-1}: \mathbb{R}^{n_{l-1}} \rightarrow \mathbb{R}^{n_{l}}$来建立的，这些算子将粗糙的向量映射到更精细的向量。为此，一个聚集`AMG`方法将$n_{l}$级的自由度划分为若干组（所谓的`aggregates`），根据一些连接强度的衡量标准，仅以矩阵条目[^155]定义。然后每个这样的组对应于一个自由度的层次$l-1$ 。这两个层次通过延长算子连接起来

$$
P_{l-1}: \mathbb{R}^{n_{l-1}} \rightarrow \mathbb{R}^{n_{l}}, \quad\left(P_{l-1}\right)_{i j}= \begin{cases}1 & \text { if } i \text { is in group } j \text { on level } l \\ 0 & \text { otherwise. }\end{cases}
$$

这可以解释为片断常数插值。使用这样的延长算子，$\mathbb{R}^{n_{l-1}}$中的向量可以通过以下方式注入到$\mathbb{R}^{n_{l}}$。

\begin{equation}
v \mapsto P_{l-1} v
\label{7.2}
\end{equation}

相反，线性函数$r: \mathbb{R}^{n_{l}} \rightarrow \mathbb{R}$可以通过应用延长算子的转置限制到$\mathbb{R}^{n_{l-1}}$。

\begin{equation}
r \mapsto P_{l-1}^{T} r
\label{7.3}
\end{equation}

最后，矩阵$A^{l-1}, l>0$由$A^{l}$通过`Galerkin`限制计算出来。

$$
A^{l-1}:=P_{l-1}^{T} A^{l} P_{l-1}
$$

从$A^{L}=A$开始，这可以构建矩阵的层次结构$A_{L}, \ldots, A_{0}$。

给定延长算子和矩阵层次，`AMG`迭代的工作方式就像几何多网格的工作方式。首先，像SSOR[^138]这样的简单迭代方法的几次迭代被应用于`smooth`的误差。由此产生的残差方程主要有低频成分，可以在下一个较粗的层次上进行近似。在那里使用预先计算的矩阵，并通过（7.3）限制残差，导致下一个较粗层次上的线性问题。如果该层是l=0，那么问题就在那里得到了精确的解决。否则，多网格迭代将被递归应用。之后，使用（7.2）将得到的修正向量延长到第l层（可能有一个缩放系数），并应用另一轮平滑迭代。



下面的伪代码显示了整个过程。平滑器在水平$l$上的一次迭代被写成与矩阵$S^{l}$：[X-进程2]的乘法。

[X-process2]: https://cdn.mathpix.com/snip/images/D2x4vk2U9ckMkcPIVqnWGUCseU3x77iMFYXqsewPPQU.original.fullsize.png



聚合 `AMG` 方法不适合作为求解器，但它可以成为一个稳健的预处理程序 [^30] [^155] 。

\subsubsection{The `dune-istl` Implementation of AMG}

`dune-istl`模块在类中实现了一个聚集`AMG`方法。

~~~C++
template<class Operator, class Vector, class Smoother>
class AMG
~~~


它包含在文件 `dune/istl/paamg/amg.hh` 中。与 `dune-istl` 中的大多数其他东西不同，它被保存在一个专门的命名空间 `Amg` 中，因此 `AMG` 类的全称是 `Dune::Amg::AMG` 。该类实现了第7.4.2章的抽象预处理器接口。

在三个模板参数中，第一个，`Operator`，是A的矩阵类型，封装在`MatrixAdapter`类中（7.4.1章）。然后，`Vector`是一个矢量类型，其块结构与矩阵的块结构一致，`Smoother`是要使用的平滑器的类型。可以使用第$7.4.2$章的任何迭代方法；流行的选择是类

~~~C++
template<class Matrix, class Vector, class Vector>
class SeqJac
template<class Matrix, class Vector, class Vector>
class SeqSOR
template<class Matrix, class Vector, class Vector>
class SeqSSOR
~~~


来自文件 `dune/istl/preconditioners.hh` 。进一步的平滑器很容易实现。

类型`AMG`的对象是通过调用其中一个构造函数获得的。最重要的一个是

~~~C++
template<class Criterion>
AMG(const Operator& fineOperator, const Criterion& criterion,
        const SmootherArgs& smootherArgs=SmootherArgs())
~~~



它为一个给定的矩阵和粗化准则构造一个`AMG`预处理程序。`AMG`构造函数接收三个对象。矩阵、粗化准则对象和一组用于平滑器的参数。参数`fine0perator`是原始问题的矩阵$A \in \mathbb{R}^{n \times n}$。为了与第`dune-istl`章中描述的$7.4$求解器和预处理器接口保持一致，矩阵不是直接给出的，而是必须包裹在一个`MatrixAdapter`对象中（然后确定类模板参数`Operator`）。粗化步骤的总数$L$不是由用户设定的，而是由粗化标准自动确定的。

`criterion`参数是一个策略类，它实现了将自由度分组为集合体的聚集策略，这些集合体形成了下一个更粗层次上的自由度。通常情况下，这里使用的类是

~~~C++
template<class CoarseningPolicy>
class CoarsenCriterion
~~~

来自文件 `dune/istl/paamg/matrixhierarchy.hh` 。它是其模板参数 `CoarseningPolicy` 的包装器，它做实际的工作。`CoarseningPolicy`的两个选择是在 `dune/istl/paamg/aggregates.hh` 中预定义的。

~~~C++
template<class Matrix, class Norm>
class UnSymmetricCriterion
template<class Matrix, class Norm>
class SymmetricCriterion
~~~


第一个方法是通过直接考虑（块）矩阵条目进行粗化，第二个方法是将每个对角线（块）条目$a_{i j}$与$A^{T}$的相应条目相结合，以确定自由度$i$和$j$之间的连接强度。精确的标准是针对具有跳跃系数的PDE问题，并在 [^30] 中描述。

两个`CoarseningPolicy`实现的模板参数`Matrix`是用于存储$A$的`dune-istl`矩阵类型（未被包裹）。Norm模板参数允许指定用于测量矩阵条目所代表的连接强度的函数。这与矢量值问题有关，其中每个矩阵条目本身就是一个小矩阵。`Norm`这个名字是历史性的，选得不好，因为事实上并非所有的实现都是数学意义上的规范。`Norm`接口的实现必须提供

~~~C++
real_type operator()(const MatrixEntry& entry) const
~~~


其中`MatrixEntry`可以是一个数字类型或像`FieldMatrix`这样的矩阵类型。文件`dune/istl/paamg/aggregates.hh`提供了一些替代品。对于标量问题，`FirstDiagonal`是一个不错的选择。

无论实际的`Norm`和`CoarseningPolicy`类是什么，包装类`CoarsenCriterion`总是有相同的构造函数。

~~~C++
CoarsenCriterion(int maxLevel=100,
                 int coarsenTarget=1000,
                 double minCoarsenRate=1.2,
                 double prolongDamp=1.6,
                 AccumulationMode accumulate=successiveAccu)
~~~


这个构造函数允许指定一些控制聚集过程的参数，比如多网格层次结构的深度`maxLevel`的上限。数字`coarsenTarget`指定了最粗层次的目标自由度数。如果当前最粗层次的自由度已经少于`coarsenTarget`，则不会再构建更粗层次。同样，如果粗化率，即连续层次之间的自由度比率，低于`minCoarsenRate`参数中给出的阈值，粗化将停止。参数prolongDamp允许为第293页`AMG`迭代的第18行中的延长校正$x^{l-1} \mapsto \eta P_{l-1} x^{l-1}$设置比例系数$\eta$。

`accumulate`参数仅适用于分布式情况：它控制矩阵层次结构的较粗部分是否保留在较少的进程中（`successiveAccu`，以节省通信成本）或不保留（`noAccu` ）。请注意，`CoarsenCriterion`类的所有构造函数参数都有默认值，通常不需要明确设置。

`CoarsenCriterion`类的成员方法允许控制进一步的参数。例如，方法

~~~C++
void setGamma(std::size_t gamma)
~~~

控制每一层所执行的多重网格迭代的数量（在第293页的算法中用$\gamma$表示）。在多网格理论的语言中，1的值将产生一个$V$ -循环，2的值将产生一个$W$ -循环[^155] 。大多数其他参数会影响聚合体的属性。这些方法

~~~C++
void setAlpha(double alpha)
~~~

和

~~~C++
void setBeta(double beta)
~~~


允许设置确定自由度之间的连接是否被标记为 "强"$(\geq \alpha)$或 "孤立"$(\leq \beta)$ 的界限。所需的最小和最大集合尺寸可以通过以下方法设置

~~~C++
void setMinAggregateSize(std::size_t size)
~~~

和

~~~C++
void setMaxAggregateSize(std::size_t size)
~~~


集合体的理想最大直径（在图论意义上，见[^30] [^54]）可以通过以下方法设定

~~~C++
void setMaxDistance(std::size_t size)
~~~

对于由各向同性的PDE离散化产生的代数问题，集料大小和直径的合理值由以下几点设定

~~~C++
void setDefaultValuesIsotropic(std::size_t dim, std::size_t diameter=2)
~~~

其中`dim`是PDE域的尺寸。最后，该方法

~~~C++
void setDebugLevel(int level)
~~~


控制`AMG`方法所打印的调试信息量。值为0将导致预处理程序完全不打印信息。更高的值意味着更多的信息。

与粗化准则相反，平滑器对象是由`AMG`类内部构建的。它们的设置由`smootherArgs`对象控制，该对象被赋予`AMG`构造函数，它持有参数

~~~C++
int iterations
~~~


为平滑器迭代的数量$\nu$，以及

~~~C++
double relaxationFactor
~~~


用于SOR和相关方法的松弛因子 [^138] 。类型`SmootherArgs`是由`AMG`类导出的，但也可以构造为

~~~C++
using SmootherArgs = Amg::SmootherTraits<Smoother>::Arguments;
~~~


最粗粒度的求解器被自动选择。它的类型取决于构建系统找到了`dune-istl`所支持的稀疏直接求解器中的哪一个。如果找到了一个稀疏直接求解器，并且最粗的问题只存在于一个进程中，那么该直接求解器将被用于解决第0层的问题。否则，用平滑器预处理的`BiCGStab`迭代将被用作后备方案。

\subsubsection{Example: Sequential Algebraic Multigrid}

为了说明`AMG`方法是如何在顺序设置中使用的，我们现在讨论一个完整的例子问题。下面的代码用预处理的CG方法和`AMG`预处理器来解决一个线性方程组。与前面的例子不同，该代码不包含设置线性系统的有限元集合器。相反，矩阵和右手向量是从两个`MATRIXMARKET`格式的文件中读取的。除了展示在DUNE中是如何完成的，从文件中读取矩阵也导致了一个更短的例子代码。

例子的完整$\mathrm{C}++$文件印在附录B.8中，本文件的电子版也将其作为文件附件。矩阵和矢量文件也被嵌入，并可通过两个绿色图标获得。它们对应于第3.3章中描述的泊松问题的一阶`Lagrange`离散化。事实上，它们是由该章的示例代码编写的，唯一的修改是将第288行的全局细化步骤数设置为4，以获得更大的代数问题。  $0.5$ 咨询矩阵市场网站，了解其他丰富的对称正定稀疏矩阵。

整个例子都包含在主方法中。该方法首先设置了问题。首先，它定义了矩阵和向量的$\mathrm{C}++$类型。由于这个例子处理的是一个标量问题，`BCRSMatrix<double>`和`BlockVector <double>`是合适的类型。然后，每个类型的一个对象被创建，并通过读取两个`MATRIXMARKET`格式的文件来填充。

~~~C++
 int main(int argc, char *argv[])
 {
 using Matrix = BCRSMatrix<double>;
 using Vector = BlockVector<double>;
 Matrix A;
 Vector b;
 loadMatrixMarket(A, "getting-started-poisson-fem-4-refinements-matrix.mtx");
 loadMatrixMarket(b, "getting-started-poisson-fem-4-refinements-rhs.mtx");
~~~


为了保持CG迭代，代码设置了一个正确大小的向量$\mathrm{x}$，并将其初始化为值0。

~~~C++
 Vector x(b.size());
 x=b;
~~~



下一个块设置了平滑器。我们选择了`SSOR`的平滑器，它能很好地处理由常数系数的标量椭圆方程产生的对称问题。

~~~C++
 using Smoother = SeqSSOR<Matrix,Vector,Vector>;

 Amg::SmootherTraits<Smoother>::Arguments smootherArgs;
 smootherArgs.iterations = 3;
 smootherArgs.relaxationFactor = 1;
~~~


预平滑和后平滑迭代的数量$\nu$被设置为3，`SSOR`方法的过度放松因子被设置为$1$。请注意，没有构建任何平滑器对象，那是由`AMG`类本身完成的。

下一个区块设置了粗化。

~~~C++
 using Norm = Amg::FirstDiagonal;
 using Criterion
 = Amg::CoarsenCriterion<Amg::UnSymmetricCriterion<Matrix,Norm> >;
 Criterion criterion(15, // Maximum number
 // of multigrid levels
 2000); // Create coarse levels until
 // problem size gets smaller
 // than this
 criterion.setDefaultValuesIsotropic(2); // Aggregate sizes and shapes
 criterion.setAlpha(.67); // Connections above this value
 // are "strong"
 criterion.setBeta(1.0e-4); // Connections below this value
 // are treated as zero
 criterion.setGamma(1); // Number of
 // coarse-level iterations
 criterion.setDebugLevel(2); // Print some debugging output
~~~


由于矩阵是对称的，除了为`Dirichlet`边界约束所做的修改外（第2.1.4章），对称和非对称标准之间没有区别，因此选择了更简单的非对称标准。代码设置的大多数参数值都有合理的默认值，可以省略。

接下来的代码块设置了前置条件器和CG求解器。第66行调用了`AMG`构造函数。在此之前，矩阵$A$需要被包裹在一个`MatrixAdapter`对象中，用于预处理程序和求解器。这发生在第65行。构建共轭梯度求解器的过程与之前所有的例子一样。


~~~C++
 using LinearOperator = MatrixAdapter<Matrix,Vector,Vector>;
 using AMG = Amg::AMG<LinearOperator,Vector,Smoother>;

 LinearOperator linearOperator(A);
 AMG amg(linearOperator, criterion, smootherArgs);

 CGSolver<Vector> amgCG(linearOperator,
                        amg, // Preconditioner
                        1e-5, // Desired residual reduction
                        50, // Maximum number of iterations
                        2); // Verbosity
~~~


启动求解器的情况也是如此，与之前的例子没有区别。

~~~C++
 InverseOperatorResult r;
 amgCG.apply(x,b,r);

 std::cout << "CG+AMG did " << r.iterations << " iterations." << std::endl;
~~~



这已经结束了这个例子的程序。尽管代码计算出了有限元问题的解决方案，但由于程序不知道相应的网格和函数空间基数，所以结果不能写入VTK文件。

当运行时，该代码产生以下输出。

~~~Shell
%%MatrixMarket
%%MatrixMarket
Level 0 has 8113 unknowns, 8113 unknowns per proc (procs=1)
aggregating finished.
Level 1 has 1809 unknowns, 1809 unknowns per proc (procs=1)
operator complexity: 1.21792
Using a direct coarse solver (UMFPack)
Building hierarchy of 2 levels (including coarse solver)
took 0.118297 seconds.
=== Dune::IterativeSolver
Iter Defect Rate
0 6.62899
1 0.156942 0.0236751
2 0.023006 0.14659
3 0.0066211 0.287799
4 0.00102052 0.154132
5 0.000145506 0.14258
6 2.10809e-05 0.144879
=== rate=0.121266, T=0.622719, TIT=0.103786, IT=6
CG+AMG did 6 iterations.

~~~

将其与第$3.3$章中使用的带有ILU预处理的CG方法的行为相比较，很明显，`AMG`预处理对这类问题的表现要好得多。考虑到`AMG`的例子所解决的问题与$3.3$章中的问题不一样，而是通过两个额外的统一细化步骤得到的更大的问题，它所需要的迭代次数不到四分之一，这更令人印象深刻。

\section{Local Finite `Elements` and the `dune-localfunctions` Module}

有限元方法中使用的离散函数空间是通过在各个网格元素上定义空间，并指定元素间的连续性条件来构建的。例如，三角形上的拉格朗日有限元在每个元素上使用完整的多项式空间，并且跨元素边界的完全连续性。相比之下，矢量值`Raviart-Thomas`元素使用完整多项式空间的真正子空间，并且只要求边缘中点的法线分量的连续性[^32] 。

因此，有限元空间的定义有一个局部和一个全局的方面，两者都必须在软件中表示出来。在DUNE中，局部方面是由`dune-localfunctions`模块处理的。它包括对单个网格元素的函数空间的处理。在DUNE的行话中，单个元素上的有限维函数空间被称为 `local finite elements` 。将这些局部函数空间与定义在整个网格上的全局函数空间相结合，涉及到上述的连续性条件。这些问题由`dune-functions`模块处理（将在第十章讨论），它建立在`dune-localfunctions`的基础上。

`dune-localfunctions`模块实现了两个目的。首先，它规定了一个与 `local finite elements` 的接口。这个接口试图具有足够的通用性，以包含大多数有限元代码实现者的需求，同时将接口的运行时间开销保持在最低水平。其次，该模块包含该接口的实现。这套实现包含常见的元素，如`Lagrange`和`Raviart-Thomas`元素，但也有一些特殊的元素。其目的是收集一个不断增长的本地有限元实现库，并通过通用接口使它们可用。

从概念上讲，局部有限元空间与有限元机制的其他部分是完全分开的。对于它们的定义和实现，人们需要单个网格元素，而不是整个网格。对于`affine families`的重要子案例（见下文$8.1$章），甚至只需要知道参考元素就足够了。因此，`dune-localfunctions`模块与其他DUNE核心模块的关系非常少。它只依赖于 `dune-common` 和 `dune-geometry` 。因此，在DUNE以外的有限元代码中使用`dune-localfunctions`的形状函数库是很容易的（也不是很讨厌）。



\subsection{Finite `Elements` and Affine Families}

在他的经典教科书[^42]中，Ciarlet将有限元定义为具有以下性质的三联体$(T, P, \Sigma)$。

1.  $T$是$\mathbb{R}^{d}$的一个封闭子集，有一个非空的`interior`和一个`Lipschitz-continuous`边界。(每一个这样的集合$T$对应于网格的一个元素）。)

2.  $P$是一个定义在集合$T$上的函数空间。

3.  $\Sigma$是一个线性独立线性形式的有限集合$\boldsymbol{\sigma}_{i}, 0 \leq i<N$ ，定义在空间$P$上。

这些线性形式被称为有限元的`degrees of freedom`。它们在$P$上必须是无解的，也就是说，对于每一组数字$\alpha_{0}, \ldots, \alpha_{N-1}$，在$P$中必须正好存在一个函数$\phi$，使得$\boldsymbol{\sigma}_{i}(\phi)=\alpha_{i}$对于所有$i=0, \ldots, N-1$ 。这意味着$P$必须是$N$-维的。这进一步意味着存在一个$\phi_{0}, \ldots, \phi_{N-1}$的唯一基础，使得$\left\{\phi_{i}\right\}_{i=0}^{N-1}$和$\left\{\boldsymbol{\sigma}_{i}\right\}_{i=0}^{N-1}$相互对等，也就是说，如果$i=j$，则$\boldsymbol{\sigma}_{i}\left(\phi_{j}\right)=1$，否则就是零。函数$\phi_{0}, \ldots, \phi_{N-1}$被称为形状函数。

举两个例子，让$T$是$\mathbb{R}^{d}$中的一个网格的单数元素。那么，对于$p$上的第-阶`Lagrange`元素，空间$P$是$d$上所有阶数最多为$p$的变量的多项式集合。自由度$\sigma_{i}: P \rightarrow \mathbb{R}$是$N$`Lagrange`节点上的点评价，如果`Lagrange`节点被适当定位，它们是线性独立的。对$\boldsymbol{\sigma}_{i}$的对偶基础正是由`Lagrange`多项式组成。同样，对于`Raviart-Thomas`上的最低阶$T, P$元素的空间是那些函数$v: T \rightarrow \mathbb{R}^{d}$的空间，其形式为

\begin{equation}
v(x)=\vec{a}+b x
\label{8.1}
\end{equation}

其中 $\vec{a} \in \mathbb{R}^{d}$ 和 $b \in \mathbb{R}$ 。自由度$\sigma_{i}$是元素面中心的法向分量的值。

某些有限元素在仿射变换下是不变的。例如，让$T_{1}$和$T_{2}$是两个可以通过仿射变换$A: T_{1} \rightarrow T_{2}$相互变换的网格元素。然后，相应的`Lagrange`有限元是仿生不变的，即如果$v \in P_{T_{1}}$ ，那么$v \circ A^{-1}: T_{2} \rightarrow \mathbb{R}$就在$P_{T_{2}}$中。自由度也相应地转换，也就是说，对于所有的$i=0, \ldots, N-1$，如果$a_{i, T_{1}}, a_{i, T_{2}}$分别是$T_{1}$和$T_{2}$上的`Lagrange`节点，$\boldsymbol{\sigma}_{i, T_{2}}\left(v \circ A^{-1}\right)=$$v\left(A^{-1} a_{i, T_{2}}\right)=v\left(a_{i, T_{1}}\right)=\sigma_{i, T_{1}}(v)$。这并不是对所有的有限元都成立!例如，如果$v: T_{1} \rightarrow \mathbb{R}^{d}$是一个`Raviart-Thomas`函数，即形式为\ref{8.1}，那么$\left(v \circ A^{-1}\right)(x)=\vec{a}+b A^{-1} x$通常不是同样的形式。

在仿生变换下不变的有限元素被称为形成所谓的`affine families` [^42] 。只需在一个单一元素上定义它们，即参考元素，并通过仿射变换在实际网格元素上构建空间。非仿生有限元也可以通过参考元素的变换来构造，但这些变换不是简单的仿生，而是取决于特定的有限元 $(T, P, \Sigma)$ 。`dune-localfunctions`模块目前专注于有限元的`affine families`。局部有限元实现的集合也包含一些非affine的，但这些只是针对参考元素给出的。用户需要自己了解并应用正确的变换到网格元素。

\subsection{The Interface for Finite Elements Defined on the Reference Element}

虽然`dune-localfunctions`的有限元界面并不完全照搬Ciarlet的定义，作为一个三元组，但它还是从它那里得到了相当多的启发。在DUNE中，相应的概念被称为局部有限元。添加限定词local是为了强调这样的有限元只指单个元素。此外，在`dune-localfunctions`中有时会使用局部这个词，以强调该接口目前只包括定义在参考元素上的有限元。在DUNE中，一个局部有限元包括三样东西。

1.一组`shape functions`在一个固定的参考元素$T_{\text {ref }}$ 上。

2.对任何足够平滑的函数$v$在$T_{\text {ref }}$上的自由度$\left\{\boldsymbol{\sigma}_{i}\right\}_{i=0}^{N-1}$的评估机制。

3.一个将每个自由度分配到`subEntity`的$T_{\text {ref }}$的地图，并给它一个索引以区别于分配到同一子实体的其他自由度。

与`Ciarlet`的定义有明显的相似之处。元素$T$没有明确出现在界面中，因为界面只涵盖参考元素$T_{\text {ref. }}$上的有限元素。然而，第1项中的`shape functions`集合直接对应于空间$P$，而第2项的自由度直接取自Ciarlet的定义。



第三项并没有出现在定义中。它不是有限元的数学理论所要求的，但它是实现有限元的一个重要工具。当单个网格元素上的`local finite elements`被组合到整个网格上的有限元空间时，局部自由度必须被分配到全局指数，并且必须纳入可能的连续性约束。根据空间的不同，这可能是一个高度非难的问题。为了支持这方面的算法，`dune-localfunctions`接口将每个自由度分配给参考元素的`subEntity`（可能分配给单一的`subEntity`，即参考元素本身），并且相对于分配给该子实体的所有自由度，给它一个唯一索引。对于大多数实际使用的有限元，有自然的这种分配。  [Fig8.2]显示了三阶`Lagrange`元素的分配。`dune-localfunctions`中的一些实现允许对这些赋值应用某些对称性变换，例如，边的翻转，以促进全局有限元空间的构造。

`dune-localfunctions`中的接口使用`duck typing`范式（第4.4.2章）。局部有限元在`dune-localfunctions`中被表示为实现接口类的类

~~~C++
class LocalFiniteElement
~~~

它可以被解释为一个容器，它容纳了三个子对象，实现了局部有限元的三个部分，并根据请求将它们发放出去。`LocalFiniteElement`接口的实现是典型用户要直接构建的唯一对象。在许多情况下，它们是从全局函数空间基础对象中接收的，比如`dune-functions`模块提供的对象（第10章）。

`LocalFiniteElement`接口主要由三个方法组成

~~~C++
const LocalBasisType& localBasis() const
const LocalInterpolationType& localInterpolation() const
const LocalCoefficientsType& localCoefficients() const
~~~


这些只是返回`const`对三个子对象的引用。此外，`LocalFiniteElement`接口还提供了以下方法

~~~C++
GeometryType type() const
~~~


返回定义局部有限元的参考元素的类型。最后，该方法

~~~C++
unsigned int size() const
~~~


返回 $N=\operatorname{dim} P=|\Sigma|$ , `shape functions` 和自由度的数量 $N$ 。

`LocalFiniteElement`类导出了其公共接口中使用的所有类型，但与`dune-grid`的接口类不同，它将这些类型全部收集在一个名为`LocalFiniteElement::Traits`的类型容器中。这个类型反过来又导出。

~~~C++
class LocalBasisType // The type returned by localBasis()
class LocalCoefficientsType // The type returned by localCoefficients()
class LocalInterpolationType // The type returned by localInterpolation()
~~~



这些都是偶尔有用的。

\subsubsection{Shape Functions and the `LocalBasis` Interface}

有限元的`shape functions`$\phi_{i}: T_{\mathrm{ref}} \rightarrow \mathbb{R}^{m}$是在遵循`LocalBasis`接口的类中实现。按照`duck typing`的范式，没有实际的类被称为`LocalBasis`，接口只是按照惯例存在。

[Tab8.1]中列出了预期的接口方法。核心的是那些评估`shape functions`或其导数的方法。假设人们很少需要处理单一的形状函数。相反，大多数有限元算法需要一次性访问某一点上的所有`shape functions`。因此，为了使常见的情况快速，`LocalBasis`接口只提供了一起查询有限元的所有`shape functions`的方法。特别是，该方法

~~~C++
void evaluateFunction(const Traits::DomainType& in,
        std::vector<Traits::RangeType>& out) const
~~~


在$T_{\text {ref }}$中的给定点$\xi$评估所有$\phi_{i}$。位置$\xi$作为第一个参数提供给特定的实现类型（通常是一个`FieldVector`）。类型`Traits`由每个`LocalBasis`实现导出；见下文。输出值通过第二个参数返回，该参数是对第二个实现特定类型的`std::vector`的引用。对于标量`shape functions`，这第二个类型通常是`FieldVector <double, 1>` 。它是一个数组类型，以适应矢量值的形状函数。变量out在进入`evaluateFunction`方法时并不期望有正确的大小。相反，方法本身会在填充前将out调整到正确的长度。

以类似的方式，在

~~~C++
void evaluateJacobian(const Traits::DomainType& in,
            std::vector<Traits::JacobianType>& out) const
~~~


方法返回所有`shape functions`在给定点$\xi \in T_{\text {ref provided }}$作为第一个方法参数的一阶导数。请注意，对于一个形状函数$\phi_{i}: T_{\text {ref }} \rightarrow \mathbb{R}^{m}$，其一阶导数（即`Jacobian`）是一个$m \times d$矩阵，其中$d=\operatorname{dim} T_{\text {ref. }}$因此，`evaluateJacobian`的输出参数是一个`std::vector`的特定实施矩阵类型。特别是，对于标量值的`shape functions`，它通常是`FieldMatrix<double, 1, d>` 。同样，在进入该方法之前，out容器不应该有正确的大小。

为了在实际代码中看到这一切，下面的代码片段在参考三角形上构造了一个二阶`Lagrange`有限元，并打印出所有形状函数值和元素中心的梯度（关于`Traits`类型见下文）。

~~~C++
const int dim = 2;
auto triangleCenter = ReferenceElements<double,dim>::simplex().position(0,0);
using LocalFEType = LagrangeSimplexLocalFiniteElement<double,double,dim,2>;
LocalFEType localFE;
// Get shape function values
using ValueType = LocalFEType::Traits::LocalBasisType::Traits::RangeType;
std::vector<ValueType> values;
localFE.localBasis().evaluateFunction(triangleCenter,values);

for (auto&& value : values)
    std::cout << value << std::endl;
// Get shape function Jacobians
using JacobianType = LocalFEType::Traits::LocalBasisType::Traits::JacobianType;
std::vector<JacobianType> jacobians;
localFE.localBasis().evaluateJacobian(triangleCenter,jacobians);
for (auto&& jacobian : jacobians)
    std::cout << jacobian << std::endl;
~~~



形状函数值和第一导数对许多有限元离散化来说是足够的。然而，有时需要更高的导数。为此，`LocalBasis`接口提供了以下方法


~~~C++
void partial(const std::array<unsigned int,dim>& order,
                const Traits::DomainType& in,
                std::vector<Traits::RangeType>& out) const
~~~


它计算`shape functions`在某一点的部分导数。一般来说，任意顺序的导数都可以通过这个接口来请求；但是，`LocalBasis`接口的实现并不需要全部实现它们。当请求一个未实现的部分导数时，其行为是未定义的。

方法`partial`有三个参数。第二个和第三个参数，in和out的行为与前面的方法一样：in接收评估点$\xi \in T_{\mathrm{ref}}$，结果返回`out`中。数组`out`包含每个形状函数的一个偏导数，因此其类型为

~~~C++
std::vector<Traits::RangeType>&
~~~



所需的偏导数是用第一个参数指定的，称为`order` 。它使用的是传统上在分析教科书中看到的多指数符号。具体来说，一个多指数$\alpha=\left(\alpha_{0}, \ldots, \alpha_{d-1}\right) \in \mathbb{N}_{0}^{d}$指定了偏导数

$$
\partial^{\alpha}:=\frac{\partial^{\alpha_{0}+\cdots+\alpha_{d-1}}}{\partial \xi_{0}^{\alpha_{0}} \ldots \partial \xi_{d-1}^{\alpha_{d-1}}}
$$

例如，下面的代码片段计算了`Hessians`的三阶`Lagrangian`形状函数在$\xi=(0.5,0.5)$的方形元素上的痕迹。


~~~C++
const int dim = 2;
LagrangeCubeLocalFiniteElement<double,double,dim,3> localFiniteElement;
const auto& localBasis = localFiniteElement.localBasis();
std::vector<double> traceOfHessian(localBasis.size(), 0.0);

FieldVector<double,dim> xi = {0.5, 0.5};
for (int i=0; i<dim; i++)
{
    std::array<unsigned int, dim> alpha; // The multi-index
    std::fill(alpha.begin(), alpha.end(), 0);
    alpha[i] = 2;   // Differentiate twice
                    // in the i-th direction
    std::vector<FieldVector<double,1> > out;
    localBasis.partial(alpha, xi, out);
    for (size_t j=0; j<out.size(); j++)
        traceOfHessian[j] += out[j];
}

~~~



`partial`返回单个偏导数而不是全差分的原因是效率。一方面，组成高阶微分的偏导数的数量随着阶数的增加而呈指数级增长。另一方面，有人认为，许多需要高阶形状函数导数的应用实际上不需要所有这些成分。如果需要完整的微分，它仍然可以由组件组装而成。

两个辅助函数提供了一些关于形状函数集这样的信息。该方法

~~~C++
unsigned int size() const
~~~

返回$N = dim P$，即该集合中的形状函数的数量。该方法

~~~C++
unsigned int order() const
~~~


给出一些关于 `shape functions` 的多项式顺序的信息。如果集合中的所有`shape functions`都是多项式，那么order返回集合中最高阶的多项式的阶。这个信息可以用来选择适当的正交规则。如果集合中的`shape functions`不是多项式，那么order方法的行为就无法定义。

与 `LocalFiniteElement` 接口一样， `LocalBasis` 接口的实现必须通过一个名为 `Traits` 的类型导出其公共接口中使用的类型。这个类型的原型类存在于文件 `dune/localfunctions/common/localbasis.hh` 中。它比`LocalFiniteElement`接口的相应`Traits`类型有更多的内容。比如说。

~~~C++
LocalBasis::Traits::RangeType
~~~

是用于存储形状函数值的向量类型，而

~~~C++
LocalBasis::Traits::RangeFieldType
~~~


是这种值的各个组成部分的数字类型。同样地，类型和

~~~C++
LocalBasis::Traits::DomainType
~~~


和

~~~C++
LocalBasis::Traits::DomainFieldType
~~~

是容器和数字类型，分别用于参考元素上的坐标。

最后。

~~~C++
LocalBasis::Traits::JacobianType
~~~

是用于形状函数导数的类型。更多细节见文件`dune/localfunction/common/localbasis.hh`的在线文档。

\subsubsection{Degrees of Freedom and the `LocalInterpolation` Interface}

界面的第二部分提供了一种评估局部有限元自由度的方法。对于定义在参考元素上的足够平滑的函数$f$，它计算出`Ciarlet`的定义值$\sigma_{0}(f), \ldots, \sigma_{N-1}(f)$。实现必须遵循一个称为`LocalInterpolation`的接口类（`Interpolation`这个名字是历史性的），它只有一个方法

~~~C++
template<class F, class C>
void interpolate(const F& f, std::vector<C>& out) const
~~~


与形状函数的界面类似，访问单个自由度是不可能的；只能一次评估所有$N$的自由度。插值方法的第一个参数$f$是要评估自由度的函数。结果，即数值$\sigma_{0}(f), \ldots, \sigma_{N-1}(f)$在第二个参数中返回，它是一个数字类型`std::vector`。函数$f$的类型和值$C$的类型都是方法的模板参数。数字类型$C$在`dune-localfunctions`接口的其他地方没有使用，因此对它几乎没有任何限制。

模板参数$F$是要评估自由度的函数$f$的类型。希望$\mathrm{F}$满足的精确接口取决于有限元。例如，如果自由度涉及$f$的点评估，$F$的类型必须是一个函数对象，即它必须实现

~~~C++
C operator()(const DomainType& xi)
~~~


其中`DomainType`是用于参考元素中的点$\xi$的类型。该方法可以不返回$C$类型的对象，而是返回一个不同的数字类型，如果该类型可以转换为C语言的话。涉及积分项的自由度通常用数值正交来实现。在这里，$\mathrm{f}$又只需要实现点评估。

对于使用导数作为自由度的元素（例如，见[42，第2.2章]），$f$的导数必须可用。那么，$\mathrm{f}$的预期接口被定义在`dune-functions`模块中（10.5章）。如果有一个自由方法`derivative`可以返回实现导数的函数，那么$\mathrm{C}++$对象就是一个可微分函数。换句话说，$f$在某一点$\xi \in T_{\text {ref }}$的一阶导数必须可以用

~~~C++
auto firstDer = derivative(f)(xi);
~~~


如果有必要，该过程必须是可嵌套的，以允许更高的衍生品。

~~~C++
auto secondDer = derivative(derivative(f))(xi);
~~~


更多细节见$10.5$章中`dune-functions`。

并不要求$f$为使用方向导数的有限元实现一个专门的接口。相反，`LocalInterpolation`的实现将请求$\mathrm{f}$的全部导数，如上所述，并由此计算方向导数。

\subsubsection{Subentity Assignments and the LocalCoefficients Interface}

对于有限元方法，各个网格元素上的空间$P$被合并为一个定义在整个网格上的离散函数的单一空间。这经常涉及到相邻元素上的函数之间的连续性条件。整个网格上的有限元函数空间就像元素函数空间一样被一个基所跨越，而且它也有一组全局自由度。

请记住第$2.1.3$章的内容，有限元问题的装配是逐个元素进行的。当在元素$T$上装配时，软件需要将形状函数$\phi_{p}$或自由度$\sigma_{p}$在$T$上的局部数$0 \leq p<N$与全局基础函数或自由度相关联（这就是第2.1.3章中出现的映射$p \mapsto i, q \mapsto j$）。这可能是一个不简单的问题，因为由于连续性的限制，局部数和全局数之间很少有简单的一对一的关系。对于许多有限元空间，来自多个元素的`shape functions`需要被映射到同一个全局自由度。这对于一阶`Lagrange`有限元来说是很容易的，因为每个自由度都对应于一个网格顶点；然而，对于更奇特的元素，如高阶`Raviart-Thomas`元素，这种识别可能相当困难。

从局部索引到全局索引的构建是`dune-functions`模块的特点之一（第10章$)$，它超出了dunelocalfunctions的范围（毕竟它处理的是局部事物）。然而，模块`dune-localfunctions`确实提供了一些基础设施来帮助实现本地-全球地图。这个基础结构的想法是，虽然Ciarlet对有限元的正式定义没有提到元素的几何形状$T$，但在实践中使用的几乎所有自由度都可以与定义域的面（polytopal）相关联。例如，一阶`Lagrange`有限元的`shape functions`与$T_{\text {ref }}$的角（即零维面）有关。对于高阶`Lagrangian`有限元，`shape functions`与边、顶点，甚至元素本身相关联（[Fig8.2]）。一个以上的形状函数可能与$T_{\text {ref }}$的特定面相关联。即使是像`Argyris`元素这样非常精细的有限元([^42]，第2.2章)，每个形状函数或局部自由度都可以附加到元素的一个面。这同样适用于`Raviart-Thomas`和`Brezzi-Douglas-Marini`元素，这些元素使用边和面的矩作为自由度[^32] 。

`LocalCoefficients`接口描述了单个`shape functions`和自由度对参考元素的面（或DUNE术语中的子实体）的分配。对于每个自由度，它存储

1. 相关子实体的二维码。

2. 该子实体的本地编号。

3. 这个元素在所有`shape functions`的集合中的索引，与同一个子实体相关。

这些信息被保存在类的对象中

~~~C++
class LocalKey
~~~

其中允许通过以下方法访问它

~~~C++
unsigned int subEntity() const
unsigned int codim() const
unsigned int index() const
~~~


关于子实体的正确本地编号，请参见第 $5.5$ 章中的 `ReferenceElements` 文件。

现在，`LocalCoefficient`接口类将`shape functions`的索引与它们相应的`LocalKey`对象联系起来。它只有两个公共方法

~~~C++
std::size_t size() const
~~~

和

~~~C++
const LocalKey& localKey(std::size_t i) const
~~~


第一个简单地返回本地有限元的`shape functions`的数量。第二个是接收0到$N-1$之间的局部形状函数数$i$，并以`LocalKey`的形式返回对元素`subEntity`的相应分配。例如，下面的代码为一个三角形上的三阶`Lagrange`元素的所有自由度打印了这些赋值

~~~C++
LagrangeSimplexLocalFiniteElement<double,double,2,3> localFE;

for (size_t i=0; i<localFE.size(); i++)
    std::cout << localFE.localCoefficients().localKey(i) << std::endl;
~~~

由此产生的输出是

~~~Shell
[ subEntity: 0, codim: 2, index: 0 ]
[ subEntity: 0, codim: 1, index: 0 ]
[ subEntity: 0, codim: 1, index: 1 ]
[ subEntity: 1, codim: 2, index: 0 ]
[ subEntity: 1, codim: 1, index: 0 ]
[ subEntity: 0, codim: 0, index: 0 ]
[ subEntity: 2, codim: 1, index: 0 ]
[ subEntity: 1, codim: 1, index: 1 ]
[ subEntity: 2, codim: 1, index: 1 ]
[ subEntity: 2, codim: 2, index: 0 ]
~~~


从第二列可以看出，3个自由度被分配给顶点，6个被分配给边，一个被分配给元素本身。

\subsection{Implementations of the Local Finite Element Interface}

`dune-localfunctions`模块提供了一系列的有限元接口的实现。本节简要介绍比较重要的几个。

\subsubsection{Affine-Equivalent Finite Elements}

仿射等效有限元是在参考元素上定义的，并通过仿射变换映射到网格元素。以下这种元素在版本$2.7$中可以使用 `dune-localfunctions` 。

\textbf{Lagrange Elements}

拉格朗日元素在单数元素上使用完整的多项式空间，在立方体上使用多项式的张量积；自由度是在某些固定点$a_{0}, \ldots, a_{N-1} \in T_{\mathrm{ref}}$（`Lagrange`节点）的点值。第$p$阶`Lagrangian``shape functions`$\phi_{0}, \ldots, \phi_{N-1}$是那些阶$T_{\text {ref }}$的多项式（多多项式，如果$T_{\text {ref }}$不是单轴），使得

$$
\phi_{i}\left(a_{j}\right)=\delta_{i j}:= \begin{cases}1 & \text { if } i=j \\ 0 & \text { otherwise }\end{cases}
$$

对于所有 $i, j=0, \ldots, N-1$ .在 `dune-localfunctions` 中有两种类型的 `Lagrange` 元素实现，都在头文件 `dune/localfunctions/lagrange.hh` 中。这些类

~~~C++
template<class DomainField, class RangeField, int dim, int order>
class LagrangeSimplexLocalFiniteElement
~~~

和

~~~C++
template<class DomainField, class RangeField, int dim, int order>
class LagrangeCubeLocalFiniteElement
~~~

为任何维度的单数和立方体元素提供任何阶数的局部`Lagrange`有限元。在这里和本节中，模板参数`DomainField`和`RangeField`分别是用于域坐标和形状函数值的数字类型，dim是域的尺寸$T_{\text {ref }}$ 。数阶是空间的多项式或多项式阶数。实现类的定义域和多项式顺序都被硬编码到它们的$\mathrm{C}++$类型中。因此，编译器有望能够很好地优化涉及这些类的代码。三维棱镜和金字塔也有相应的类。为了提高运行时的灵活性，`dune-localfunctions`还提供了以下类


~~~C++
template<class LagrangePoints,
               unsigned int dim,
               class DomainField, class RangeField>
class LagrangeLocalFiniteElement
~~~


这里，定义域（除了它的尺寸）和多项式顺序都是运行时参数，必须传递给构造函数

~~~C++
LagrangeLocalFiniteElement(const GeometryType& type, unsigned int order)
~~~


与带有编译时域类型的`Lagrange`实现相比，该实现支持所有可由第5.5.2章结构描述的元素类型；包括既不是单纯体也不是立方体的四维和更高维的元素。模板参数`LagrangePoints`允许控制`Lagrange`点的分布。在这里使用`EquidistantPointSet`类产生标准的统一间距。替代方案见在线文档。

没有任何实现具有编译时参考元素类型和运行时顺序，或者反之亦然。对于这种情况，第$8.4$章描述了一种在运行时切换不同实现类别的一般方法。

顺便说一下，本地有限元接口没有提供直接的方法来获得`Lagrange`节点的位置。在有限元计算中很少需要这些，但有一个技巧可以得到它们。对于任何带有$i=0, \ldots, d-1$的$d=\operatorname{dim} T_{\text {ref }}$，让$c_{i}$成为$i^{th}$坐标函数$c_{i}:\left(\xi_{0}, \ldots, \xi_{d-1}\right) \mapsto \xi_{i}$。由于 $\boldsymbol{\sigma}_{j}\left(c_{i}\right)=c_{i}\left(a_{j}\right)=\left(a_{j}\right)_{i}$ 为 $j$ -第 `Lagrange` 个节点 $a_{j} \in T_{\text {ref }}$ ，我们可以通过评估坐标函数 $c_{i}$ 上的自由度 $\left\{\boldsymbol{\sigma}_{i}\right\}_{i=0}^{N-1}$ 来提取所有 `Lagrange` 节点的 $i^{th}$ 的坐标。下面的代码片断就是这样做的。

~~~C++
constexpr int dim = 2;
LagrangeSimplexLocalFiniteElement<double, double, dim, 3> localFE;

std::vector<FieldVector<double, dim>> lagrangePoints(localFE.size());

for (int i = 0; i < dim; i++)
{
    auto ithCoord = [&i](const FieldVector<double, dim> &x)
    {
        return x[i];
    };

    std::vector<double> out;
    localFE.localInterpolation().interpolate(ithCoord, out);

    for (std::size_t j = 0; j < out.size(); j++)
        lagrangePoints[j][i] = out[j];
}

for (const auto &p : lagrangePoints)
    std::cout << p << std::endl;
~~~



同样的想法也适用于确定定义在整个有限元网格上的全局`Lagrange`函数的`Lagrange`节点位置。

\textbf{Refined Finite `Elements`}

`RefinedP1LocalFiniteElement`的实现是二阶`Lagrangian`有限元的一个变种。某些情况下需要一个比一阶`Lagrange`空间有更好近似特性的空间，但二阶`shape functions`有某些稳定性问题（例如[^81] ）。实现类

~~~C++
template<class DomainField, class RangeField, int dim>
class RefinedP1LocalFiniteElement
~~~


通过（概念上）细化一次参考元素，并使用一阶`Lagrange`基础来获得网格（[Fig8.3]）来实现。`shape functions`只是片状可微。在`shape functions`不可微分的点上调用`evaluateJacobian`方法会导致未定义的行为，用户应该知道这些点在哪里。同样地，类

~~~C++
template<class DomainField, class RangeField, int dim>
class RefinedP0LocalFiniteElement
~~~


实现了一个片状常数函数的空间，甚至不是每一个点都可以调用evaluateFunction。要使用精炼的 `local finite elements` 包括头文件 `dune/localfunctions/refined.hh` 。

\textbf{Hierarchical Basis Finite Elements}

分层有限元方法考虑将有限元空间$V_{h}$分割成直接和

$$
V_{h}=V_{h}^{0} \oplus V_{h}^{\mathrm{ext}}
$$

其中$V_{h}^{0}$通常是一阶`Lagrange`空间，而$V_{h}^{\mathrm{ext}}$是一个扩展。相应地，这种空间的形状函数集由一阶`Lagrange``shape functions`和额外的扩展函数组成，这些函数在元素顶点是零。它们仍然可以与参考元素的子实体相关联，它们有时被称为 `bubble functions` 。自由度是点评价的仿射函数，但由于基数不是`Lagrangian`，因此产生的系数不是函数的点值。分层有限元空间在误差估计和构建多层次求解器方面有应用 [^9] 。

`dune-localfunctions`模块只实现了二阶层次化的有限元。它们可用于单轴元素，名称为

~~~C++
template<class DomainField, class RangeField, int dim>
class HierarchicalP2LocalFiniteElement
~~~

从头文件 `dune/localfunctions/hierarchical/hierarchical.hh` 。该文件另外还包含一些类似的有限元；详情请查看在线文档。

\textbf{Crouzeix-Raviart and Rannacher-Turek Elements}

`Crouzeix-Raviart` 元素是有用的有限元素的最简单的例子，它不形成Sobolev空间的子空间 $H^{1}$ 。它只为单数元素定义，并使用一阶多项式的空间 [^45] 。然而，与一阶`Lagrange`元素相比，自由度是面的中点的点值。相应地，全局`Crouzeix-Raviart`函数并非处处连续，而只是在相邻元素的面的中点处。`dune-localfunctions`模块在类中提供了一个`Crouzeix-Raviart`实现。

~~~C++
template<class DomainField, class RangeField, int dim>
class CrouzeixRaviartLocalFiniteElement
~~~



来自文件 `dune/localfunctions/crouzeixraviart.hh` 。像往常一样`DomainField`和`RangeField`是坐标和形状函数值的数字类型，dim是域单纯的尺寸。

`Rannacher-Turek`元素将`Crouzeix`和`Raviart`的思想适应于四边形和六面体网格元素[^136]。在这里，需要一个小技巧，因为四边形元素上的`Crouzeix-Raviart`元素的天真定义是不明确的。虽然有些作者建议使用面的平均数作为自由度，但`dune-localfunctions`的实现在面的中点使用点评估，就像`Crouzeix-Raviart`元素一样。该实现包含在类

~~~C++
template<class DomainField, class RangeField, unsigned int dim>
class RannacherTurekLocalFiniteElement
~~~

由标头提供 `dune/localfunctions/rannacherturek.hh` 。

\textbf{Dual Mortar Finite Elements}

双砂浆有限元是由 `Wohlmuth` [^164] 引入的，作为砂浆方法 [^23] 中 `Lagrange` 测试函数的智能替换。与本章中的其他`local finite elements`不同，双迫击炮有限元通常只存在于网格的边界上，而不是在网格本身。它们在每个元素上都是仿射的，但不是全局连续的，并且具有与一阶`Lagrange`形状函数双正交的有趣特性，即

\begin{equation}
\int_{F} \phi_{i} \theta_{j} d x=\delta_{i j} \int_{F} \theta_{j} d x, \quad F \text { is facet of } T_{\mathrm{ref}}
\label{8.2}
\end{equation}

对于所有的一阶`Lagrange` `shape functions` $\phi_{i}$和对偶迫击炮`shape functions` $\theta_{j}$ 。因此，出现在迫击炮方法中的边界质量矩阵只有`diagonal`项，这使得它们的反转非常简单。对偶有限元的自由度是元素顶点的点评价的加权线性组合，它们最自然地被分配到元素顶点上。

`dune-localfunctions`模块为所有维度的单纯体和立方体提供一阶对偶有限元。它们在类中实现

~~~C++
template<class DomainField, class RangeField, int dim, bool faceDual=false>
class DualP1LocalFiniteElement
~~~

为单纯性和

~~~C++
template<class DomainField, class RangeField, int dim, bool faceDual=false>
class DualQ1LocalFiniteElement
~~~

用于立方体，都来自文件 `dune/localfunctions/dualmortarbasis.hh` 。模板参数 `DomainField` , `RangeField` , 和 `dim` 具有通常的含义。

参数`faceDual`允许控制生物对称性属性\ref{8.2} 。当设置为`true`时，`shape functions`$\theta_{0}, \ldots, \theta_{N-1}$履行$(8.2)$到信。如果`facedual`被设置为`false`，另一方面，\ref{8.2}在整合域被$T_{\text {ref }}$本身取代后成立。在大多数情况下，`true`需要设置在这里，原因如下。`dune-grid`网格界面的设置不是为了直接支持网格边界上的有限元空间。因此，如果需要这样的空间，例如通过砂浆法，就需要一个技巧。由`DualP1LocalFiniteElement`类提供的`shape functions`住在网格元素上，但它们只在元素边界被评估过。这样，就可以避免为边界有限元空间的自由度建立单独的索引机制，而可以使用$5.6$章的基础设施。

由于网格边界上的有限元空间在迫击炮法之外还有用处，我们通过下面的例子来演示这个技巧，它在单位方格上构造了一个均匀的单线网格，计算所有域边界面的\ref{8.2}的左积分，并打印出结果。计算这些积分是砂浆方法的一个重要方面。不幸的是，一个完整的实现需要更多的基础设施--建议使用`dune-grid-glue`模块来实现。

该示例程序仅由一个主方法组成。该文件被嵌入到电子文件中，并可通过边缘的图标获得。它也被打印在附录B.9中。该代码首先设置了一个统一的$2 \times 2$三角形网格。

~~~C++
 int main(int argc, char *argv[])
 {
 // Set up MPI if available
 MPIHelper::instance(argc, argv);

 // Construct a 2x2 structured triangle grid
 constexpr int dim = 2;
 using Grid = UGGrid<dim>;

 auto grid = StructuredGridFactory<Grid>::createSimplexGrid({0.0,0.0},
 {1.0,1.0},
 { 2, 2});
 auto gridView = grid->leafGridView();
~~~



接下来，它为方程\ref{8.2}的`shape functions`$\phi_{0}, \ldots, \phi_{N-1}$构建一个一阶`Lagrange`局部有限元，为测试函数$\theta_{0}, \ldots, \theta_{N-1}$构建一个`faceDual`设置为`true`的对偶砂浆有限元，以及一个密集矩阵对象，将持有积分\ref{8.2}。

~~~C++
LagrangeSimplexLocalFiniteElement<double,double,dim,1> lagrangeFE;
DualP1LocalFiniteElement<double,double,dim,true> dualFE;

// Matrix that will store the integrals
Matrix<double> facetMassMatrix;
~~~



注意这两个有限元是如何在三角形上定义的，尽管我们只对边界边缘的积分感兴趣。这对试算基函数$\phi_{0}, \ldots, \phi_{N-1}$来说是有直接意义的，因为在标准砂浆方法中，\ref{8.2}中的函数$\phi_{i}$实际上是在整个网格上定义的有限元函数的边界限制。然而，使用定义在三角形上的对偶迫击炮有限元，就是上述的诀窍：只有它在域边界上的值才会被使用。尽管如此，为了简单起见，矩阵将包含三角形所有自由度的条目，但只有与边界自由度有关的条目将被使用。

然后，代码在域边界的各个面进行循环，遍历所有元素的交点，跳过那些`interior`的交点。它还获得了当前的参考元素（这里总是一个三角形），随后用来检查给定的自由度是否与当前的交叉点有关。

~~~C++
 for (const auto& element : elements(gridView))
 {
    for (const auto& intersection : intersections(gridView, element))
    {
        if (intersection.boundary())
        {
            auto refElement = referenceElement<double,dim>(element.type());
~~~


为了准备在当前边界面的积分，质量矩阵被设置为适当的大小（在这个例子中总是$3 \times 3$），并以零初始化。

~~~C++
facetMassMatrix.setSize(lagrangeFE.size(), dualFE.size());
facetMassMatrix = 0;
~~~

然后，代码在当前交点上获取一个二阶正交规则，并在正交点上循环。

~~~C++
 constexpr auto intersectionDim
    = std::decay_t<decltype(intersection)>::mydimension;
 const auto& quad
    = QuadratureRules<double,intersectionDim>::rule(intersection.type(), 2);

 for (const auto& quadPoint : quad)
 {

~~~



这个循环的主体是这个例子的核心部分。首先，`Lagrange` `shape functions` $\phi_{0}, \ldots, \phi_{N-1}$和双臼`shape functions` $\theta_{0}, \ldots, \theta_{N-1}$必须在正交点`quadPoint`进行评估。这两组`shape functions`都是在整个当前网格元素上定义的，但评价点（即正交点）的位置是在当前交点（是元素边界的一部分）的坐标系中给出的。为了获得必要的坐标转换到元素坐标系，代码使用`intersectionInside`接口类提供的`Intersection`方法（参见5.4章）。

~~~C++
 auto quadPosInElement
    = intersection.geometryInInside().global(quadPoint.position());

 std::vector<FieldVector<double,1> > lagrangeValues, dualValues;
 lagrangeFE.localBasis().evaluateFunction(quadPosInElement, lagrangeValues);
 dualFE.localBasis().evaluateFunction(quadPosInElement, dualValues);
~~~




计算积分的实际循环\ref{8.2}需要跳过那些不与当前面相关的自由度。这是通过使用`LocalKey::subEntity`方法询问当前自由度与之相关的顶点，然后让参考元素检查与当前交叉点相关的面是否包含这个顶点。还要注意的是，由于我们是在元素边界的一部分上进行积分，所以使用了`Jacobian`的行列式。

~~~C++
  for (std::size_t i = 0; i < lagrangeFE.size(); i++)
 {
     LocalKey lagrangeLocalKey = lagrangeFE.localCoefficients().localKey(i); 

     auto lagrangeSubEntities = refElement.subEntities(intersection.indexInInside(),
                                                       1, // The codimension of facets
                                                       lagrangeLocalKey.codim()); 

     if (lagrangeSubEntities.contains(lagrangeLocalKey.subEntity()))
     {
         for (std::size_t j = 0; j < dualFE.size(); j++)
         {
             LocalKey dualLocalKey = dualFE.localCoefficients().localKey(j); 

             auto dualSubEntities = refElement.subEntities(intersection.indexInInside(),
                                                           1, // The codimension of facets
                                                           dualLocalKey.codim()); 

             if (dualSubEntities.contains(dualLocalKey.subEntity()))
             {
                 auto integrationElement = intersection.geometry()
                                               .integrationElement(quadPoint.position());
                 facetMassMatrix[i][j] += quadPoint.weight() * integrationElement * lagrangeValues[i] * dualValues[j];
             }
         }
     }
 }    
} // End of quadrature loop
~~~



这就结束了正交循环。剩下的就是打印当前的质量矩阵，并进入下一个交叉点。

~~~C++
        printmatrix(std::cout, facetMassMatrix, "facetMassMatrix", "--");

        } // End of ’if boundary’
    } // End of intersection loop
 } //End of element loop
~~~

当运行时，代码为网格的八个边界交点打印出八个$3 \times 3$矩阵。

~~~C++
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 2.50e-01 1.39e-17 0.00e+00
-- 1 1.39e-17 2.50e-01 0.00e+00
-- 2 0.00e+00 0.00e+00 0.00e+00
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 2.50e-01 1.39e-17 0.00e+00
-- 1 1.39e-17 2.50e-01 0.00e+00
-- 2 0.00e+00 0.00e+00 0.00e+00
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 2.50e-01 1.39e-17 0.00e+00
-- 1 1.39e-17 2.50e-01 0.00e+00
-- 2 0.00e+00 0.00e+00 0.00e+00
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 0.00e+00 0.00e+00 0.00e+00
-- 1 0.00e+00 2.50e-01 0.00e+00
-- 2 0.00e+00 1.39e-17 2.50e-01
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 2.50e-01 1.39e-17 0.00e+00
-- 1 1.39e-17 2.50e-01 0.00e+00
-- 2 0.00e+00 0.00e+00 0.00e+00
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 2.50e-01 0.00e+00 2.78e-17
-- 1 0.00e+00 0.00e+00 0.00e+00
-- 2 2.78e-17 0.00e+00 2.50e-01
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 0.00e+00 0.00e+00 0.00e+00
-- 1 0.00e+00 2.50e-01 0.00e+00
-- 2 0.00e+00 1.39e-17 2.50e-01
facetMassMatrix [n=3,m=3,rowdim=3,coldim=3]
-- 0 2.50e-01 0.00e+00 2.78e-17
-- 1 0.00e+00 0.00e+00 0.00e+00
-- 2 2.78e-17 0.00e+00 2.50e-01
~~~



请注意，它们确实是`diagonal`。在三个`diagonal`条目中，有一个始终是零。这个条目对应的是不在当前交点上的三角形顶点。

\subsubsection{Finite `Elements` that are not Affine-Equivalent}

`dune-localfunctions` 模块还提供了一些不构成 `affine families` 的有限元。所有这些元素都只提供给参考元素。用户必须为实际网格元素本身提供必要的非标准转换。

\textbf{Raviart-Thomas and Brezzi-Douglas-Marini Elements}

`Raviart-Thomas`和`Brezzi-Douglas-Marini`（BDM）有限元都是在$H$（div）中具有发散性的矢量场空间的符合离散。这些空间主要出现在椭圆方程的混合表述中，如 `Poisson` 问题或线性弹性方程 [^32] [^37] 。

`Raviart-Thomas`和BDM元素都是对每个元素的多项式。然而，$L^{2}$中对发散性的要求比弱微分性要弱，并不要求函数是全局连续的。相反，它只要求在元素边界的向量场的法向分量的连续性。因此，自由度包括元素面上的向量场法向分量的矩。

`Raviart-Thomas`和BDM元素没有形成第8.1章意义上的`affine families`，因为边界法线在仿生变换下不能保持正常。因此有必要使用Piola变换将梯度从参考元素$T_{\text {ref }}$变换到元素$T$ [^32]。最初只定义为单轴元素，`Raviart-Thomas`和BDM元素也被构造为立方体网格。然而，这些构造是比较困难的[32，第2.4章]。

`dune-localfunctions`模块提供了文件`dune/localfunctions/raviartthomas.hh`中`Raviart-Thomas`元素的实现，以及`dune/localfunctions/brezzidouglasmarini.hh`中BDM元素的实现。对于单数域，任何顺序和维度的`Raviart-Thomas`元素都是由类来实现的。

~~~C++
template<unsigned int dim, class DomainField, class RangeField>
class RaviartThomasSimplexLocalFiniteElement
~~~



在 [^49] 中对其中一些元素的构造做了简短描述。对于立方体元素，只有少数的尺寸和顺序可用，而且顺序和尺寸都是编译时的参数。

~~~C++
template<class DomainField, class RangeField,
          unsigned int dim, unsigned int order>
class RaviartThomasCubeLocalFiniteElement
~~~


详情请查看在线文档。

BDM元素的实现存在于单线域和立方体域，域的尺寸和顺序在编译时选择。

~~~C++
template<class DomainField, class RangeField,
        unsigned int dim, unsigned int order>
class BDMSimplexLocalFiniteElement
template<class DomainField, class RangeField,
        unsigned int dim, unsigned int order>
class BDMCubeLocalFiniteElement
~~~


同样，在写这篇文章的时候，只有一些低级的订单和尺寸是可用的。目前的清单可在在线文档中找到。

\textbf{Monomial Finite `Elements`}

用于非连续加尔金（DG）方法[^55] [^94] ，`dune-localfunctions` 提供单项式有限元，其形式为`shape functions` 。

\begin{equation}
\phi_{i}=\xi_{0}^{\alpha_{0}} \xi_{1}^{\alpha_{1}} \ldots \xi_{d-1}^{\alpha_{d-1}}, \quad\left(\alpha_{0}, \ldots, \alpha_{d-1}\right) \in \mathbb{N}_{0}^{d}
\label{8.3}
\end{equation}

相应的局部有限元是在类中实现的

~~~C++
template<class DomainField, class RangeField, int dim, int order>
class MonomialLocalFiniteElement
~~~



在文件`dune/localfunctions/monomial.hh`中。参数`DomainField`和`RangeField`是通常的数字类型，dim是领域维度，参数order指定了空间的最高多项式阶数。当然，这种结构适用于所有类型的参考元素。自由度是通过$L^{2}$-投影计算的。也就是说，对于一个给定的函数$f: T_{\text {ref }} \rightarrow \mathbb{R}$，对插值的调用将返回系数$v_{i}=\sigma_{i}(f), i=0, \ldots, N-1$，使得

$$
\mathcal{L}_{f}^{2}\left(v_{0}, \ldots, v_{N-1}\right):=\left\|f-\sum_{i=0}^{N-1} v_{i} \phi_{i}\right\|_{L^{2}\left(T_{\mathrm{ref}}\right)}^{2}
$$

是$\mathbb{R}^{N}$中的最小值，其中$\phi_{i}$是由\ref{8.3}给出的`shape functions`。这些系数很难直接解释。由于DG方法不涉及连续性条件，`LocalCoefficients`类将它们全部分配给元素本身。

\textbf{Orthonormal Finite `Elements`}

同样对于DG方法，`dune-localfunctions`有对$L^{2}$正交形状函数的有限元，即：。

$$
\int_{T_{\mathrm{ref}}} \phi_{i} \phi_{j} d \xi=\delta_{i j}
$$

为所有 $\phi_{0}, \ldots, \phi_{N-1}$ 。这个属性可以加快某些计算，因为现在元素质量矩阵的设置和反转都很便宜 [^94] 。局部有限元在类中实现

~~~C++
template<unsigned int dim, class DomainField, class RangeField>
class OrthonormalLocalFiniteElement
~~~


在文件 `dune/localfunctions/orthonormal.hh` 中。参考元素类型和多项式顺序在运行时通过构造函数设置

~~~C++
OrthonormalLocalFiniteElement(const GeometryType& type, unsigned int order)
~~~



自由度的计算方式与单项式有限元的计算方式相同，它们都被分配到元素本身。为了在非参考元素上保持正交性，`shape functions`需要适当的缩放。

\subsection{Run-Time Selection of Local Finite `Elements`}

`dune-localfunctions`中的一些有限元实现在编译时确定参考元素类型或多项式顺序等参数。这并不是接口所要求的--两者也可以是运行时参数。然而，在编译时固定这些特征可以使编译器更积极地进行优化，而且在许多情况下，确实预先知道将只使用一个固定的有限元阶，或者网格将包含，例如，只有单项元素。然而，在一次模拟中也经常需要使用几种不同的局部有限元实现方式。最典型的例子是混合了单轴和立方体元素的网格：`element stiffness matrices`的有限元装配程序必须在运行时根据当前元素的类型在不同的`local finite elements`之间切换。对于一些实现，如第8.3.1章的`LagrangeLocalFiniteElement`，这只是涉及用不同的`GeometryType`参数调用构造器。然而，在运行时在完全不相关的`LocalFiniteElement`实现之间进行切换也经常是很方便的。实现这一点的方法之一是使用抽象基类和虚拟继承的第二个编程接口（第4.4.1章），或者类似于`dune-functions`中实现的类型清除机制（第10.5.2章）。

在撰写本文时，`dune-localfunctions`并没有为`local finite elements`实现完全的类型擦除。相反，它提供了一个容器，可以从一个给定的实现类型列表中存储一个本地有限元对象。这个容器被称为

~~~C++
template<class... Implementations>
class LocalFiniteElementVariant
~~~

并在目录 `dune/localfunctions/common/` 的文件 `localfiniteelementvariant.hh` 中实现。它被称为 `Variant` 是因为它与C++17标准库中的 `std::variant` 非常相似 [^99] : 一个类型安全的联盟，可以容纳模板参数列表中给它的任何一种类型的对象。

由此产生的对象实现了 `LocalFiniteElement` 章中提出的完整的 $8.2$ 接口。它在各方面的表现都与局部有限元相似，可以作为`LocalFiniteElement`实现的直接替代。此外，它有一个方法

~~~C++
const auto& variant() const
~~~


类型为`LocalFiniteElementVariant`的对象是通过调用构造函数来构造的，该对象应该被存储。

~~~C++
template<class Implementation>
LocalFiniteElementVariant(Implementation&& impl)
~~~


通过模板技巧，参数类型`Implementation`被限制在那些出现在给类的变量列表`Implementations`中。与类型`std::variant`的对象不同，类型`LocalFiniteElementVariant`的对象总是默认可构造的，而且不需要明确列出`std::monostate`。

作为一个例子，我们展示了设置`LocalFiniteElementVariant`的代码，它可以在`Crouzeix-Raviart`和`Rannacher-Turek`元素之间切换（第8.3.1章），以用于包含三角形和四边形元素的网格。


~~~C++
constexpr int dim = 2;
using TriangleLFEType = CrouzeixRaviartLocalFiniteElement<double,double,dim>;
using QuadLFEType = RannacherTurekLocalFiniteElement<double,double,dim>;
LocalFiniteElementVariant<TriangleLFEType,QuadLFEType> lfeVariant;
// Init with a triangle element
lfeVariant = TriangleLFEType();
std::cout << "Finite element on a triangle has "
          << lfeVariant.size() << " degrees of freedom." << std::endl;
// Init with a quadrilateral element
lfeVariant = QuadLFEType();
std::cout << "Finite element on a quadrilateral has "
          << lfeVariant.size() << " degrees of freedom." << std::endl;
~~~


使用类型安全联盟的方法是有限的，因为所有可能的类型在编译时必须是已知的。然而，在许多实际情况下，可能的局部有限元类的列表确实是已知的，而且很小。其优点是实现起来比完全类型清除简单得多，而且通常也更有效率。

\section{Quadrature Rules}

有限元和有限体积方法都是以积分表达式为基础的，而这些表达式通常是用数值正交来计算的。实现这种方法的计算机代码需要提供正交规则，DUNE也不例外。虽然形成了自己的特征集，但DUNE的数值正交并没有在一个单独的模块中给出。相反，它是`dune-geometry`的一部分，因为它在概念上依赖于那里定义的参考元素。

\subsection{Numerical Integration}

有限元和有限体积计算中的积分域通常是参考元素，即$\mathbb{R}^{d}$中的某些固定多边形（2.1.3章）。到目前为止，立方体和单纯体是最常见的，但也可能出现一些其他的。使用一般多面体网格的方法通常不使用元素上的积分。在有限元计算中，大多数积分都是多项式或至少是在每个元素上可微的。在某些情况下会出现奇异积分，如断裂力学的XFEM方法 [^71] 。

本节简要回顾了构建正交规则的几种方法。除了专用的单线规则，DUNE还提供了一种算法，为第5.5.2章的所有DUNE参考元素构造正交规则。

\subsubsection{One-Dimensional Integration}

数字正交的大部分研究都集中在一维积分上。让$f:[a, b] \rightarrow \mathbb{R}$是一个给定的可积分函数。数值积分试图通过和来近似积分$\int_{a}^{b} f(s) d s$。

$$
I_{h}(f):=\sum_{i=0}^{n} w_{i} f\left(s_{i}\right)
$$

其中$s_{i} \in[a, b], i=0, \ldots, n$被称为`quadrature points`，$w_{i} \in \mathbb{R}$是相应的权重，加起来就是$b-a$。点和权重的集合被称为`quadrature rule` 。为了再现$\int_{a}^{b} f(s) d s \geq 0$对所有$f$的点非负的理想特性，通常只考虑具有正权的规则。大多数教科书将正交规则定义在[-1,1]这样的固定区间上；对其他领域的转换与第2.1.3章中的工作一样。


最常见的正交规则是基于函数 $f$ 在点 $s_{i}$ 上的多项式插值，而权重 $w_{i}$ 是以相应的 `Lagrange` 多项式 [^52] 的积分来给出。正交规则因各点在[a, b]中的分布方式而不同。例如，`Newton-Cotes`规则使用均匀间隔的点。通过`Gauss`正交规则可以获得更好的近似特性，其中$n+1$的点被赋予某些正交多项式的根。对于没有权重函数的积分，这些多项式是`Legendre`多项式，而相应的规则被称为`Gauss-Legendre`规则。积分误差由$(2 n+2)$-nd导数$f$限定；特别是它们可以精确地积分阶数高达$2 n+1$的多项式[52, Satz 9.12]。这种规则被称为具有`order` $2 n+1$ 。

这种方法的一般化允许对具有某些奇异性的函数进行积分。假设积分$f$可以写成积$f(s)=\omega(s) g(s)$，其中$\omega$是一个已知的正权函数。那么就有可能构建规则

$$
\int_{a}^{b} f(s) d s=\int_{a}^{b} \omega(s) g(s) \approx \sum_{i=0}^{n} w_{i} g\left(s_{i}\right)
$$

其误差是以$(2 n+2)$的导数而不是$f$的导数为界限的。特别是，如果$g$是一个度数不大于$2 n+1$的多项式，那么积分将被精确评估。这种规则的正交点是正交于标量积的多项式的根 $\langle g, h\rangle_{\omega}:=\int_{a}^{b} \omega g h d s$ 对于域[-1,1]，可以得到`Gauss-Chebyshev`正交规则$($，用于$\omega(s)=$$\left.\left(1-s^{2}\right)^{-1 / 2}\right)$，`Gauss-Jacobi`规则（用于$\left(\omega(s)=(1-s)^{\alpha}(1+s)^{\beta}, \alpha, \beta>-1\right)$ ，以及其他各种规则。

在有限元方法的某些情况下，单个元素上的积分仅是片断多项式的。例如`Hsieh-Clough-Tocher`或`Powell-Sabin`元素[^37]，或第8.3.1章的精炼元素。为了正确地整合这些函数，正交规则需要尊重分片结构。适当的规则是由多个按比例复制的`Gauss`规则组合而成的。这种规则被称为`composite rules` 。作为复合规则的构建块，特别有用的是`Gauss-Lobatto`规则。这些是`Gauss-Legendre`规则，但其两个外点被修改为$s_{0}=a$和$s_{n}=b$ 。由于这些边界点与相邻子域的边界点重合，复合规则的函数求值数量减少。

\subsubsection{Multi-Dimensional Integrals}

在有限元或有限体积模拟中出现的大多数积分都是在二维或三维域上。对于这样的域，上一节的方法可以重复使用。在域中选择一组点$\left\{s_{i}\right\}_{i}$，使相应的多项式插值问题被很好地提出，然后计算相应的权重$\left\{w_{i}\right\}_{i}$作为`Lagrange`多项式的积分。使用这种技术和其他技术构建了大量的立方体、简单体和其他领域的规则 [^149] 。其中很多都可以在DUNE中找到，但它们的详细描述已经超出了本书的范围。

多维域的规则也可以通过一维规则的乘法来构建。这对立方体来说特别容易，因为立方体是有限元和有限体积方法中最重要的领域之一。该构造是递归定义的。假设$D^{d-1}$是$\mathbb{R}^{d-1}$中的一个域，而$\left\{\tilde{s}_{j}, \tilde{w}_{j}\right\}_{j=0}^{\tilde{n}}$是$p$的第1阶正交规则。假设对于一维域[0,1]也有一个相同阶的规则$\left\{s_{j}, w_{j}\right\}_{j=0}^{m}$。那么对于$D^{d}:=D^{d-1} \times[0,1]$的阶$p$规则可以通过设置来构建

$$
\int_{D^{d}} f(x) d x \approx \sum_{i=0}^{\tilde{n}} \sum_{j=0}^{m} \tilde{w}_{i} w_{j} f(\underbrace{\tilde{s}_{i}, s_{j}}_{\in D^{d}})
$$

(Stroud [^149] , Chap. 2.2)。反复应用这种构造，可以得到所有维度的超立方体的$p$-阶正交规则。如果用$n+1$-点`Gauss-Legendre`规则对[0,1]进行积分，那么$d$-维超立方体的张量积规则由$(n+1)^{d}$点组成。

用类似的方法可以构建简单和金字塔的规则。让$D^{d-1}$再次成为$\mathbb{R}^{d-1}$中的一个区域，让$D^{d}$成为$D^{d-1}$上的锥体，顶点为$(0, \ldots, 0,1) \in \mathbb{R}^{d}$，定义为

$$
\begin{aligned}
D^{d}:=\left\{x \in \mathbb{R}^{d}: x_{i}=\tilde{x}_{i}(1-\lambda), i=0, \ldots, n-2, x_{d-1}=\lambda,\right.\\
0 &\left.0 \leq \lambda \leq 1,\left(\tilde{x}_{0}, \ldots, \tilde{x}_{d-2}\right) \in D^{d-1}\right\}
\end{aligned}
$$

这就是所谓的圆锥积。这种乘积域的例子是单纯体（每个单纯体都是一个低维单纯体上的圆锥体），以及三维金字塔，其中底层$D^{d-1}$是一个正方形。

为立方体构建张量积正交规则是可行的，因为$[0,1]^{d}$上的单项式积分可以写成一维积分与$[0,1]^{d-1}$上的积分的乘积。对于圆锥体上的积分也是如此。让$D^{d-1}(\lambda), 0 \leq \lambda \leq 1$成为$D^{d}$和平面$x_{d-1}=\lambda$的交点。在$D^{d-1}(\bar{\lambda})$上的积分可以通过亲和变换$D^{d-1}(\lambda)$到$D^{d-1}$上，并在那里进行积分来评估。对于每一个$x_{0}^{\alpha_{0}} \ldots x_{d-1}^{\alpha_{d-1}}$度的单项式$p=|\alpha|:=\alpha_{0}+\cdots+\alpha_{d-1}$，我们得到

$$
\begin{aligned}
\int_{D^{d}} x_{0}^{\alpha_{0}} \ldots & x_{d-1}^{\alpha_{d-1}} d x_{0} \ldots d x_{d-1} \\
&=\int_{0}^{1} x_{d-1}^{\alpha_{d-1}}\left[\int_{D^{d-1}}\left(1-x_{d-1}\right)^{d-1} \prod_{j=0}^{d-2}\left[x_{j}\left(1-x_{d-1}\right)\right]^{\alpha_{j}} d x_{0} \ldots d x_{d-2}\right] d x_{d-1} \\
&=\int_{0}^{1}\left(1-x_{d-1}\right)^{d-1+\beta} x_{d-1}^{\alpha_{d-1}} d x_{d-1} \int_{D^{d-1}} x_{0}^{\alpha_{0}} \ldots x_{d-2}^{\alpha_{d-2}} d x_{0} \ldots d x_{d-2}
\end{aligned}
$$





与$\beta:=\alpha_{0}+\cdots+\alpha_{d-2}$。第三行中关于$x_{d-1}$的积分可写为

\begin{equation}
\int_{0}^{1}\left(1-x_{d-1}\right)^{d-1}\left[\left(1-x_{d-1}\right)^{\beta} x_{d-1}^{\alpha_{d-1}}\right] d x_{d-1}
\label{9.1}
\end{equation}

而括号里的项是一个$p=|\alpha|$度的多项式。现在的诀窍是看到（9.1）是一个加权积分，可以用$p$-th阶`Gauss-Jacobi`规则精确积分。

\textbf{Theorem} 9.1 (Stroud [149, Thm. 2.5-1]) 假设域$D^{d}$可以写成$D^{d-1}$上的锥体，顶点为$(0, \ldots, 0,1) \in \mathbb{R}^{d}$ 。给出$D^{d-1}$的正交规则$\left\{\tilde{s}_{i}, \tilde{w}_{i}\right\}_{i=0}^{\tilde{n}}$的度数$p$，以及加权一维积分$\int_{0}^{1}(1-t)^{d-1} g(t) d t$的正交规则$\left\{s_{i}, w_{i}\right\}_{i=0}^{m}$的度数$p$，那么圆锥$D^{d}$的阶数$p$规则如下

$$
\int_{D^{d}} f(x) d x \approx \sum_{i=0}^{\tilde{n}} \sum_{j=0}^{m} \tilde{w}_{i} w_{j} f(\underbrace{\tilde{s}_{i}, s_{j}}_{\in D^{d}})
$$

张量乘法的重复应用导致了超立方体的公式，而圆锥乘法的重复应用则导致了单数规则。将这两者结合起来，就可以处理像三维金字塔（正方形与区间的圆锥积）和三维棱柱（三角形与区间的张量积）这样的领域。这种构造直接对应于第5.5.2章中给出的参考元素本身的递归构造。因此，DUNE的所有参考元素的正交规则可以通过张量乘法和圆锥乘法来定义。

不幸的是，通过乘法构建的正交规则并不是最佳的。首先，这些规则是不对称的：根据圆锥积的性质，正交点聚集在一个单纯的顶点附近。对于有限元计算来说，这意味着一个元素上的积分的近似误差可能取决于从该元素到参考元素的映射。另外，由低维规则的乘法构建的规则通常包含比给定精度所需的更多的点。因此，DUNE只在没有其他规则可用的情况下使用这些规则。

\subsection{The Dune Quadrature Rule Interface}

根据定义，正交规则是$\mathbb{R}^{d}$中带有相关标量权重的点的集合。因此，尽管正交规则的推导和分析有时可能很困难，但存储它们所需的相应数据结构却并不困难。

DUNE中数值积分的大部分功能都可以从单一的头文件中获得 `dune/geometry/quadraturerules.hh` 。正交点是由一个类来表示的

~~~C++
template<class ctype, int dim>
class QuadraturePoint
~~~


有一个接口，只输出三种类型。

~~~C++
constexpr int dimension = dim; // Domain dimension
using Field = ctype; // Number type for coordinates
// and weights
using Vector = FieldVector<ctype,dim>; // Type for point position
~~~

和两种方法

~~~C++
const Vector& position() const
const ctype& weight() const
~~~



我们可以访问一个正交点的位置$s \in \mathbb{R}^{d}$和权重$w \in \mathbb{R}$，这几乎是它的全部内容。`QuadraturePoint`类是由积分域的维度dim和数字类型`ctype`静态地参数化的。该类型用于权重 $w$ ，以及点的坐标 $s$ 。

`dune-geometry`中的所有正交规则都由专门的类实现。这些类继承于一个抽象的基类

~~~C++
template<class ctype, int dim>
class QuadratureRule
~~~


它反过来又继承了 `std::vector<QuadraturePoint<ctype, dim> >` 。因此，任何正交规则对象都将具有 `std::vector` 的完整接口。对一个给定的函数$f$进行积分，它实现了

~~~C++
double operator()(const FieldVector<double,dim>& x)
~~~

因此，用一个叫做quad的正交规则来计算是很容易的，因为

~~~C++
double result = 0;
for (const auto& quadPoint : quad)
    result += quadPoint.weight() * f(quadPoint.position());
~~~

此外，`QuadratureRule`对象产生积分域的类型（必须是DUNE参考元素之一），以及正交规则的多项式阶数，其方法是

~~~C++
virtual GeometryType type() const
~~~

和

~~~C++
virtual int order() const
~~~

分别。

对于一个给定的参考元素和顺序，一个特定类型的正交规则是已知的和固定的。一旦它被构建，在程序执行过程中就不会改变。这一点，再加上程序使用的正交规则总数相对较少，使得它们成为单子实现的良好候选者 [^72] 。这意味着对于每个给定的类型、参考元素和顺序，只存在一个正交规则对象。用户从不直接构造正交规则（构造函数是私有的），而是使用一个专门的工厂类。这个工厂保留现有的对象，必要时构造新的`QuadratureRule`对象，并根据要求提供对它们的引用。

在`dune-geometry`中，正交规则的工厂类是

~~~C++
template<class ctype, int dim>
class QuadratureRules
~~~

作为其唯一的公共成员，它有一个静态方法

~~~C++
static const QuadratureRule& rule(const GeometryType& gt,
                                  int order,
                                  QuadratureType::Enum qt
                                        = QuadratureType::GaussLegendre)

~~~


它返回一个对正交规则的单子对象的引用，该正交规则适用于gt指定的域和 `order` 中给出的顺序。gt的尺寸必须与`QuadratureRules`类的第二个模板参数所给的尺寸相匹配。

返回的正交规则的类型取决于参考元素的类型和请求的阶数。如果gt是一个单线，并且顺序不是太大，那么将返回一个专用的对称单线规则。否则，一个适当的规则将通过一维规则的乘法来创建。最后一个参数`qt`允许选择一维正交规则的类型。返回的规则是通过第9.1.2节所述的一维规则的张量乘法得到的乘积规则。目前，可以选择以下一维正交规则。

- `GaussLegendre` :域的`Gauss-Legendre`类型的正交规则 [0,1] 。

- `GaussLobatto` : `Gauss-Lobatto` [0,1] 的规则

- `GaussJacobi_1_0` , `GaussJacobi_2_0` : 这些是`Gauss-Jacobi`类型的规则，用于具有权重函数$\omega(s)=(1-s)^{\alpha}(1+s)^{\beta}$的积分。这两条规则对应于 $\alpha=1, \beta=0$ 和 $\alpha=2, \beta=0$ 的情况。

这些规则的点位置和权重取自于使用符号计算程序MAXIMA半自动创建的表格。因此，如果需要更高的阶数，相应的表格可以相当容易地被更新。

复合规则可以以模块化的方式从其他规则中构建。有一个单独的类

~~~C++
template<class ctype, int dim>
class CompositeQuadratureRule
~~~

(在`dune/geometry/quadraturerules/compositequadraturerule.hh`中)，它将任何给定的正交规则转换为一个复合规则。假设一个正交规则是作为参考元素`quad`的对象`gt`给出的。那么可以通过以下方式构建一个复合规则

~~~C++
CompositeQuadratureRule<ctype,dim> compositeQuad(quad,refinement);
~~~

这将通过对参考元素做`refinement`步的均匀细化来创建一个规则，并将原始规则转化为作用于每个子元素。因此，要将上面的例子中的函数$f$在四面体上用二阶复合规则对$\left(2^{3}\right)^{m}$个子元素进行整合，对于某些$m \in \mathbb{N}$，代码为


~~~C++
#include <dune/geometry/quadraturerules.hh>
[...]
const int dim = 3;
int quadOrder = 2;
GeometryType type = GeometryTypes::simplex(dim); // The reference element
                                                 // to integrate over
const auto& quad = QuadratureRules<double, dim>::rule(type, quadOrder);

CompositeQuadratureRule<double,dim> compositeQuad(quad,
                                                    m); // Refine domain
                                                        // m times
double result = 0;
for (const auto& quadPoint : compositeQuad)
    result += quadPoint.weight() * f(quadPoint.position());
~~~


使用这个，例如，用于第8.3.1章的精炼有限元。



\section{Function Space Bases and Discrete Functions}

在前几章中，我们已经描述了DUNE的网格、线性代数和有限元形状函数的接口。现在我们把抽象层次往上移一层，考虑全局函数空间和函数。我们所说的全局是指不是在单个元素上定义的函数空间和函数，而是在整个网格视图（即非分级网格）上定义的。这个功能由`dune-functions`模块涵盖。

`dune-functions`的主要目的是描述定义在网格视图上的离散函数空间。然而，代码中的核心概念不是函数空间本身，而是这种空间的基础。这是因为尽管有限元空间在有限元方法的理论考虑中起着核心作用，但实际计算使用离散函数的系数表示，相对于一个特定的基给出。另外，对于许多不同的有限元空间，在实践中使用的基础不止一个。例如，二阶`Lagrangian`有限元空间既使用节点（Lagrange）基[^37]，也使用分层基[^9]。  `Discontinuous Galerkin` 空间可以用`Lagrange` 基、单项式基、`Legendre` 基等[^94] 来描述。因此，在应用代码中能够区分同一空间的这些不同表示是很重要的。由于这些原因，主`dune-functions`接口表示离散函数空间的基，而不是空间本身。

有限元函数空间经常表现出相当多的结构。特别是，矢量值和混合有限元空间可以被写成更简单空间的产物。更有甚者，这类空间具有树状的自然结构，标量值或其他不可还原的空间构成叶子，而乘积则构成内部节点。`dune-functions`模块允许通过现有基数的乘法来系统地构造新基数。由此产生的树状结构在代码中作为类型信息被再现。这些想法最初出现在 [^123] 中。

对于这样一个非琐碎的树状结构中的基函数，没有单一的典型方式来索引它们。将所有的自由度保持在一个标准的数组中，就需要用一个连续的、零起点的整数集来进行索引。另一方面，从基础的树状结构来看，有一种自然的多索引，可以用来处理嵌套的向量和矩阵数据类型，就像 `dune-istl` 提供的那些。仔细观察可以发现，这两种可能性只是更广泛的索引规则的极端情况。虽然其中有些是设计好的，但许多其他的在应用中确实是有用的。`dune-functions`模块提供了一种系统的方法来构建许多这样的规则。

本章的前四节是关于函数空间基的。第10.1章描述了抽象的构造，第$10.2$章解释了相应的编程接口。第$10.3$章和第$10.4$章分别介绍了如何从较小的树和较大的树中获得基树。

本章的第二部分包括集合$\mathcal{D}$和$\mathcal{R}$之间的一般函数$f: \mathcal{D} \rightarrow \mathcal{R}$ 。作为$\mathrm{C}++11$标准的一部分，已经给出了这类函数的接口，`dune-functions`只是简单地重复使用这个接口。

然而，有限元背景下的函数通常有额外的特征。首先，一个函数的导数是经常需要的。一阶导数是最常见的，但高阶导数也会出现。其次，函数经常是相对于有限元网格以分块方式定义的。在这种情况下，使用全局坐标的评估通常非常昂贵。评估这种函数的自然方法是使用一个元素和该元素上的局部坐标。`dune-functions`模块使用局部函数，可以绑定到单个元素，然后可以在该元素的局部坐标中进行评估。这种机制使得在一个元素内进行多次评估的常见情况变得快速。

第$10.5$章解释了函数的`dune-functions`编程接口。第$10.6$章接着说明了如何通过结合基数和系数向量来获得离散函数。第$10.7$章介绍了VTK对函数的输出。最后，在第$10.8$章中，我们给出了一个完整的例子，说明如何用`dune-functions`来解决`Stokes`方程，使用`Taylor-Hood`元素。

\subsection{Function Space Bases}

在我们解释第$10.2$章中离散函数空间基的编程界面之前，我们需要说一下这些基如何被赋予抽象的树结构。只对标量值函数的有限元空间感兴趣的读者可以尝试直接进入第10.2章。他们只需要知道，只要那里提到局部有限元树，这个树就只由一个节点组成，也就是局部有限元基。同样，对于标量有限元空间来说，用于索引基函数的多索引树只是代表一个连续的、零起点的自然数集。

\subsubsection{Trees of Function Spaces}

本章所考虑的所有函数空间都是在一个固定的域$\Omega$上定义的。重点是关于相对于网格的片状多项式的函数空间，但在这一点上实际上还没有要求。

对于一个集合$R$，我们用$R^{\Omega}:=\{f: \Omega \rightarrow R\}$表示从$\Omega$映射到$R$的所有函数集合。我们用$P_{k}(\Omega) \subset \mathbb{R}^{\Omega}$表示在$\Omega$上相对于某个给定的三角化，度数最多为$k$的所有标量值连续片状多项式的空间。如果可以从上下文中推断出，我们将省略该域。

考虑到文献中出现的不同的有限元空间，有一些我们将称之为`irreducible` 。通过这个术语，我们指的是所有标量值函数的空间，但也包括其他像`Raviart-Thomas`空间这样不容易写成更简单空间的组合。许多其他的有限元空间是作为更简单的空间的组合自然产生的。两个向量空间$V$和$W$如何组合成一个新的空间主要有两种方式：和与积（也分别称为内部和与外部和）。

对于和，两个空间都需要有相同的范围空间 $R$ 。那么矢量空间的和

$$
V+W:=\{v+w: v \in V, w \in W\}
$$

在$R^{\Omega}$中，将有相同的范围空间。例如，$P_{2}$-空间可以被看作是$P_{1}$-空间加上`bubble functions`[^9]所跨越的层次性扩展。XFEM空间[^122]是通过向基本空间添加特定的加权`Heaviside`函数以捕捉某些不连续因素而构建的。`dune-functions`模块目前不支持构建有限元基的总和，但这可能会在以后的版本中添加。

从较简单的空间构建有限元空间的第二种方法是使用`Cartesian`产品。让$V \subset\left(\mathbb{R}^{r_{1}}\right)^{\Omega}$和$W \subset\left(\mathbb{R}^{r_{2}}\right)^{\Omega}$是两个函数空间。然后我们定义$V$和$W$的积为

$$
V \times W:=\{(v, w): v \in V, w \in W\}
$$

这个空间的函数取值在$\mathbb{R}^{r_{1}} \times \mathbb{R}^{r_{2}}=\mathbb{R}^{r_{1}+r_{2}}$。

乘积操作允许建立任意复杂度的向量值和混合有限元空间。例如，一阶`Lagrangian`有限元的空间，其值在$\mathbb{R}^{3}$中，可以看作是乘积$P_{1} \times P_{1} \times P_{1}$ 。最低阶的`Taylor-Hood`元素是速度的$P_{2} \times P_{2} \times P_{2}$与压力的$P_{1}$的乘积$P_{2} \times P_{2} \times P_{2} \times P_{1}$。如果有必要，可以很容易地包括更多的因子空间。我们把这种空间的产物称为复合空间。

在`Taylor-Hood`空间中，三联体$P_{2} \times P_{2} \times P_{2}$构成了一个语义单元--它包含了一个速度场的组成部分。乘积的关联性允许将`Taylor-Hood`空间写成$\left(P_{2} \times P_{2} \times P_{2}\right) \times P_{1}$，这使语义关系更加清晰。这种类型的分组表达式很容易被可视化为树。这表明可以将复合有限元空间解释为树状结构。在这些结构中，叶子节点代表标量或其他不可还原的空间，而内部节点代表其子节点的产物。然后，子树代表复合有限元空间。  [Fig10.1]显示了`Taylor-Hood`有限元空间的这种树状表示法。所有这些树都是`rooted`和`ordered`，也就是说，它们有一个专门的根节点，每个节点的子节点有一个固定的给定排序。基于这个子节点排序，我们给每个子节点关联相应的零基索引。

虽然内部树节点最初可能看起来像是树表示法中无用的人工制品，但它们往往非常有用，因为我们可以把根植于这些节点的子树当作它们自己的独立树。这通常允许重用那些期望在更复杂的环境中对这些子树进行操作的现有算法。

\subsubsection{Trees of Function Space bases}

有限维空间的乘法自然会在这种空间的基上引起相应的操作。我们引入一个广义的张量乘法符号。考虑函数空间$R_{0}, \ldots, R_{m-1}$的线性范围$R_{0}^{\Omega}, \ldots, R_{m-1}^{\Omega}$，以及$i^{th}$中的典范基向量$\mathbf{e}_{i}$。那么

$$
\mathbf{e}_{i} \otimes f:=(0, \ldots, 0, \underbrace{f}_{i \text { -th entry }}, 0, \ldots, 0) \in \prod_{j=0}^{m-1}\left(R_{j}^{\Omega}\right)=\left(\prod_{j=0}^{m-1} R_{j}\right)^{\Omega}
$$

其中$j$ -个位置的0表示$R_{j}^{\Omega}$中的零函数。设$\Lambda_{i}$是$V_{i}=\operatorname{span} \Lambda_{i}$空间的一个函数空间基，用于$i=0, \ldots, m-1$。那么，乘积空间的一个自然基$\Lambda$.

$$
V_{0} \times \cdots \times V_{m-1}=\prod_{i=0}^{m-1} V_{i}=\prod_{i=0}^{m-1} \operatorname{span} \Lambda_{i}
$$

是由

\begin{equation}
\Lambda=\Lambda_{0} \sqcup \cdots \sqcup \Lambda_{m-1}=\bigcup_{i=0}^{m-1} \Lambda_{i}:=\bigcup_{i=0}^{m-1} \mathbf{e}_{i} \otimes \Lambda_{i}
\label{10.1}
\end{equation}

乘积$\mathbf{e}_{i} \otimes \Lambda_{i}$应按元素理解，而 "离合 "符号$\sqcup$在这里被用作\ref{10.1}的简单简记，而不是理解为关联二元运算。使用这个新的符号，我们有

$$
\operatorname{span} \Lambda=\operatorname{span}\left(\Lambda_{0} \sqcup \cdots \sqcup \Lambda_{m-1}\right)=\left(\operatorname{span} \Lambda_{0}\right) \times \cdots \times\left(\operatorname{span} \Lambda_{m-1}\right)
$$





与函数空间的情况类似，基可以被解释为树。如果我们将一个基$\Lambda_{V}$关联到函数空间树中的每个空间$V$，那么通过简单地在每个节点中用$\Lambda_{V}$替换$V$就可以得到诱导的自然函数空间基树。对于`Taylor-Hood`基础，这导致了[Fig10.2]中描述的树。

\subsubsection{Indexing Basis Functions by Multi-Indices}

为了处理有限元空间的基础，需要对基函数进行索引。对基函数进行索引是为了在合适的向量和矩阵数据结构中解决相应的向量和矩阵系数。在简单的情况下，索引意味着简单地用自然数列举基函数，但对于许多应用来说，分层结构的向量和矩阵数据结构更加自然和有效。这就导致了分层结构的多索引的想法。

\textbf{Definition} $10.1$ （多索引） $A$ 对于某些$k \in \mathbb{N}_{0}$的元组$I \in \mathbb{N}_{0}^{k}$被称为长度为$k$的多索引，我们写成$|I|:=k$。所有多索引的集合用$\mathcal{N}=\bigcup_{k \in \mathbb{N}_{0}} \mathbb{N}_{0}^{k}$表示。

为了在一组多指数中建立一些结构，考虑前缀是很方便的。

\textbf{Definition} $10.2$ （多索引前缀）}。

1.如果$I \in \mathcal{N}$以$I=\left(I^{0}, I^{1}\right)$的形式代表$I^{0}, I^{1} \in \mathcal{N}$，那么我们称$I^{0}$为I的前缀。如果再加上$\left|I^{1}\right|>0$，那么我们称$I^{0}$为$I$的严格前缀。

2.对于$I, I^{0} \in \mathcal{N}$和一个集合$\mathcal{M} \subset \mathcal{N}$ :

a) 如果$I^{0}$是$I$的前缀，我们写成$I=\left(I^{0}, \ldots\right)$。

b) 我们写$I=\left(I^{0}, \bullet, \ldots\right)$，如果$I^{0}$是$I$的严格前缀。

c) 我们写$\left(I^{0}, \ldots\right) \in \mathcal{M}$，如果$I^{0}$是某个$I \in \mathcal{M}$的前缀。

d) 我们写$\left(I^{0}, \bullet, \ldots\right) \in \mathcal{M}$，如果$I^{0}$是某个$I \in \mathcal{M}$的严格前缀。





需要注意的是，一个给定集合的多索引不一定都有相同的长度。例如，[Fig10.3]通过对[图10.2]的基树进行扩展，用叶子节点来表示各个基函数，说明了泰勒-霍德基的所有基函数集合。泰勒-霍德基$\Lambda_{\mathrm{TH}}$的基函数的一个可能的索引，然后使用速度分量$(0, i, j)$和压力分量$(1, k)$的形式的多索引。对于速度多指数$(0, i, j)$，$i=0, \ldots, 2$决定了速度矢量场的分量，$j=0, \ldots, n_{2}-1:=\left|\Lambda_{P_{2}}\right|-1$决定了决定该分量的标量$P_{2}$基函数的编号。对于压力多指标$(0, k)$，$k=0, \ldots, n_{1}-1:=\left|\Lambda_{P_{1}}\right|-1$决定了决定压力的标量$P_{1}$函数的$P_{1}$基础函数的编号。

很明显，这些多指数的完整集合可以再次与一棵有根的树联系起来。在这棵树中，多指数对应于叶子节点，它们的严格前缀对应于`interior`节点，而标记边缘的多指数数字是有序树中子节点的指数。前缀可以被解释为从根到给定节点的路径。

这后一个事实可以被看作是索引树的定义属性。事实上，一组多指数（连同其所有的严格前缀）形成了一棵树，只要它是一致的，即多指数可以被看作是有序树中通往叶子的路径。也就是说，每个节点的子节点是用连续的零基指数来列举的，而通往叶子的路径（即多指数）是通过连接这些指数来建立的，这些指数从根开始，以叶子结束。由于这棵树的完整结构被编码在与叶子相关的多指数中，我们将--略微滥用符号--从现在开始把多指数的集合本身称为一棵树。

\textbf{Definition} $10.3$ 如果对于任何$(I, i, \ldots) \in \mathcal{I}$，也有$(I, 0, \ldots),(I, 1, \ldots), \ldots,(I, i-1, \ldots) \in \mathcal{I}$，但$I \notin \mathcal{I}$，则称为索引树。





上面给出的 `Taylor-Hood` 基础的索引树的例子显示在 [Fig10.4] 。

\textbf{Definition} $10.4$ 让$(I, \ldots) \in \mathcal{I}$ ，即$I$是$\mathcal{I}$中多索引的前缀。那么$\mathcal{I}$相对于$I$的大小为

\begin{equation}
\operatorname{deg}_{\mathcal{I}}^{+}[I]:=\max \{k: \exists(I, k, \ldots) \in \mathcal{I}\}+1
\label{10.2}
\end{equation}

就与$\mathcal{I}$相关的有序树而言，这相当于$I$的外度，即由$I$索引的节点的直接子女数。

利用多索引树的思想，函数空间基础的索引是一个从基础函数树的叶子节点到索引树的叶子的注入映射。

\textbf{Definition} $10.5$ 设$M$是一个有限集，$\iota: M \rightarrow \mathcal{N}$是一个注入映射，其范围$\iota(M)$形成一个索引树。那么$\iota$被称为$M$的索引图。如果对于某些$k \in \mathbb{N}$来说，另外的$\iota(M) \subset \mathbb{N}_{0}^{k}$被称为均匀的索引图，而如果$\iota(M) \subset \mathbb{N}_{0}$被称为平坦的。

继续`Taylor-Hood`的例子，如果整个有限元树的所有基函数$\Lambda_{\mathrm{TH}}=\left\{\phi_{I}\right\}$都由上述给定形式的多索引来索引，如果$\bar{x}$是具有兼容层次结构的系数向量，那么由系数向量$\bar{x}$定义的速度$v_{h}$和压力$p_{h}$的有限元函数为

\begin{equation}
\left(v_{h}, p_{h}\right)=\sum_{i=0}^{2} \sum_{j=0}^{n_{2}-1} \bar{x}_{(0, i, j)} \phi_{(0, i, j)}+\sum_{k=0}^{n_{1}-1} \bar{x}_{(1, k)} \phi_{(1, k)}
\label{10.3}
\end{equation}


有基础函数

$$
\phi_{(0, i, j)}=\mathbf{e}_{0} \otimes\left(\mathbf{e}_{i} \otimes \phi_{j}^{P_{2}}\right), \quad i=0,1,2, \quad \text { and } \quad \phi_{(1, k)}=\mathbf{e}_{1} \otimes \phi_{k}^{P_{1}}
$$

在所有基础函数的集合$\Lambda_{\mathrm{TH}}$上引入与$\iota: \Lambda_{\mathrm{TH}} \rightarrow \mathcal{N}$相应的索引图，我们可以将其写成紧凑的形式

$$
\left(v_{h}, p_{h}\right)=\sum_{\phi \in \Lambda_{\mathrm{TH}}} \bar{x}_{\iota(\phi)} \phi=\sum_{I \in \iota\left(\Lambda_{\mathrm{TH}}\right)} \bar{x}_{I} \phi_{I}
$$

或者，单独的速度场和压力场$v_{h}$和$p_{h}$分别由以下公式给出

$$
v_{h}=\sum_{i=0}^{2} \sum_{j=0}^{n_{2}-1} \bar{x}_{(0, i, j)}\left(\mathbf{e}_{i} \otimes \phi_{j}^{P_{2}}\right), \quad p_{h}=\sum_{k=0}^{n_{1}-1} \bar{x}_{(1, k)} \phi_{k}^{P_{1}}
$$

在前面的例子中，索引树与 [Fig10.3] 中描述的基函数树是同构的。然而，人们也可能对构建不模仿基函数树结构的多索引感兴趣。例如，为了提高`Taylor-Hood`基的集合矩阵的数据定位性，可能最好将对应于单个$P_{2}$基函数的所有速度自由度组合在一起，即对$j$-第$P_{2}$基函数的$i^{th}$组件使用索引$(0, j, i)$。相应的替代索引树显示在 [Fig10.5] 中。  [Fig10.6] 显示了分层刚度矩阵的相应布局。

然而，另一种方法是用一个自然数来索引`Taylor-Hood`基础上的所有基函数。这可以用一棵索引树来表示，$3 n_{2}+n_{1}$的叶子节点都直接连接到一个根。这种树的不同变化取决于自由度的排序方式。




胡德基地。左图：对应于[Fig10.4]的索引树。右边。对应于[Fig10.5]的索引树。

\subsubsection{Strategy-Based Construction of Multi-Indices}

设$\Lambda$为有限元基树的基函数集合。原则上，`dune-functions`允许任何由索引图给出的索引方案，即任何$\operatorname{map} \iota: \Lambda \rightarrow \mathcal{N}$是注入性的，其范围$\iota(\Lambda)$是一棵索引树。在实践中，在这一大组地图中，`dune-functions`允许使用某些转换规则系统地构建最重要的地图。

考虑一棵第10.1.2节意义上的函数空间基的树。我们想为这棵树构建一个索引，即一个索引树$\mathcal{I}$和一个从所有基函数集合$\Lambda$到$\mathcal{I}$中的多索引的双射关系$\iota$ 。该构造是递归进行的。为了描述它，我们在下面假设$\Lambda$是函数空间基础树中的一个节点，即它是函数空间树中的节点$V:=\operatorname{span} \Lambda$所对应的所有基础函数的集合。

为了结束递归，我们假设如果$V=\operatorname{span} \Lambda$是函数空间树的一个叶子节点，就会给出一个索引图$\iota: \Lambda \rightarrow \mathcal{N}$。最明显的选择是$\Lambda$的基函数的平坦的零基索引。然而，其他选择也是可能的。例如，在不连续的有限元空间的情况下，每个基函数$\phi \in \Lambda$也可以与一个两位数的多指数$\iota(\phi)=(i, k)$相关联，该指数结合了构成$\phi$支持的网格元素的指数$i$和该元素内$\phi$的指数。

对于实际的递归，如果$\Lambda$是函数空间基础树中的任何非叶子节点，那么它的形式为

$$
\Lambda=\Lambda_{0} \sqcup \cdots \sqcup \Lambda_{m-1}=\bigcup_{i=0}^{m-1} \mathbf{e}_{i} \otimes \Lambda_{i}
$$





其中$\Lambda_{0}, \ldots, \Lambda_{m-1}$是$\Lambda$的直接子空间，即乘积空间的子空间$\left\{\operatorname{span} \Lambda_{i}\right\}_{i=0, \ldots, m-1}$的基函数集。

$$
\operatorname{span} \Lambda=\operatorname{span}\left(\Lambda_{0} \sqcup \cdots \sqcup \Lambda_{m-1}\right)=\left(\operatorname{span} \Lambda_{0}\right) \times \cdots \times\left(\operatorname{span} \Lambda_{m-1}\right)
$$

对于递归构造，我们假设对于任何$i=0, \ldots, m-1$都给出了$\iota_{i}: \Lambda_{i} \rightarrow \mathcal{N}$上的索引图。我们的任务是从地图$\iota_{i}$中构建一个索引地图$\iota: \Lambda \rightarrow \mathcal{N}$。在下文中，我们描述了实现这一目标的四种策略；所有这些策略都已在 `dune-functions` 中实现。当阅读这些策略时，请记住任何$\phi \in \Lambda$对于$i \in\{0, \ldots, m-1\}$和一些$\hat{\phi} \in \Lambda_{i}$都有一个唯一的表示$\phi=\mathbf{e}_{i} \otimes \hat{\phi}$ 。有必要区分所有子女$\Lambda_{i}$都是相同的这种特殊情况。

\textbf{Definition} $10.6$ 如果一个内部节点$\Lambda$的所有子节点$\Lambda_{i}$都是相同的，并且配备了相同的索引图$\iota_{i}$，则该节点将被称为动力节点。一个不属于权力节点的内部节点被称为复合节点。

之所以需要这个定义，是因为以下一些策略只能适用于电源节点。

- \textbf{BlockedLexicographic} : 该策略将子索引预置到子基础内的多索引。也就是说，索引图$\iota: \Lambda \rightarrow \mathcal{N}$是由以下方式给出的

$$
\iota\left(\mathbf{e}_{i} \otimes \hat{\phi}\right)=\left(i, \iota_{i}(\hat{\phi})\right)
$$

直接表明$\iota$总是$\Lambda$的一个索引图。为了证明这一策略，下表显示了当子树$\Lambda_{0}, \Lambda_{1}, \ldots$的基函数被$\left(I^{0}\right),\left(I^{1}\right), \ldots$的多索引标记为$\Lambda_{0},\left(K^{0}\right),\left(K^{1}\right), \ldots$的多索引标记为$\Lambda_{1}$时，内部节点的多索引，以此类推。[例子1]

[例子1]: https://cdn.mathpix.com/snip/images/25L_nymuI0DrNpdVyXujVNrN38Qq8_Ync0wAewU0vhM.original.fullsize.png

- \textbf{BlockedInterleaved} : 这个策略只对权力节点有很好的定义。它将子索引附加到子基础内的多索引。也就是说，索引图$\iota: \Lambda \rightarrow \mathcal{N}$是由以下方式给出的

$$
\iota\left(\mathbf{e}_{i} \otimes \hat{\phi}\right)=\left(\iota_{i}(\hat{\phi}), i\right)
$$

下表给出了一个[例子2] 。

[例子2]: https://cdn.mathpix.com/snip/images/MPCwkAHjchyTSVtalRwU6OTfFMGH_dtguc0kulz8pLE.original.fullsize.png



为了说明这种策略对一般的复合节点不起作用，考虑$\iota_{0}\left(\Lambda_{0}\right)=\{0\}$和$\iota_{1}\left(\Lambda_{1}\right)=\{(0,0)\}$ 。然后是$\iota(\Lambda)=\{(0,0),(0,0,1)\}$，它不是一个索引树。

与前两种策略不同，下面两种策略没有引入新的多指数数字。这样的策略被称为扁平化。

- \textbf{FlatLexicographic} : 这个策略将所有索引树$\iota_{i}\left(\Lambda_{i}\right)$的根部合并成一个新的索引树。假设我们按照以下方式拆分多索引$\iota_{i}(\hat{\phi})$： 1.

\begin{equation}
\iota_{i}(\hat{\phi})=\left(i_{0}, I\right)
\label{10.4}
\end{equation}

其中$i_{0} \in \mathbb{N}_{0}$是第一个数字。然后，索引图$\iota: \Lambda \rightarrow \mathcal{N}$由以下公式给出

$$
\iota\left(\mathbf{e}_{i} \otimes \hat{\phi}\right)=\left(L_{i}+i_{0}, I\right)
$$

其中第一个数字的偏移量$L_{i}$是通过以下方式计算出来的

$$
L_{i}=\sum_{j=0}^{i-1} \operatorname{deg}_{\iota_{j}\left(\Lambda_{j}\right)}^{+}[()]
$$

在这个表达式中，`()`是空的索引前缀，因此，和是在索引树$\iota_{j}\left(\Lambda_{j}\right), j=0, \ldots i-1$的根的外度上（见定义10.4）。这种构造将$\Lambda_{j}$中所有基函数的多指数的第一个数字与$j>0$相抵消，使它们形成一个连续的序列。这保证了$\iota$始终是$\Lambda$的索引图。下表中给出了一个[例子3]。

[例子3]: https://cdn.mathpix.com/snip/images/bfP15PZ0dhIQU1GZLFljSv-kMKM_y2wm51wwyMozV34.original.fullsize.png



数字 "0 "故意在$\Lambda_{1}$一栏中出现两次，以证明不需要连续的第一个数字。

- FlatInterleaved。这个策略同样只对权力节点有效。它也将所有子索引树$\iota_{i}\left(\Lambda_{i}\right)$的根部合并成一个，但它将子节点交错排列。再次使用$(10.4)$中介绍的拆分$\iota_{i}(\hat{\phi})=\left(i_{0}, I\right)$，索引图$\iota: \Lambda \rightarrow \mathcal{N}$由以下公式给出

$$
\iota\left(\mathbf{e}_{i} \otimes \hat{\phi}\right)=\left(i_{0} m+i, I\right)
$$

其中固定跨度$m$是由$\Lambda$的子代数给出的。下表显示了一个[例子4]。


[例子2]: https://cdn.mathpix.com/snip/images/E453su1mGzf7w5vAlD2MlQiNHV2M_2CKWkTEqkq49fg.original.fullsize.png





同样，对于这种交错的策略，$\iota$可能不是一般复合节点的索引图。

这四种策略是由`dune-functions`提供的，但还有其他的策略，有时也很有用。因此在实验中，`dune-functions`也提供了一种使用自我实现的自定义规则的方法。

为了进一步说明这四种索引转换策略，我们回到`Taylor-Hood`的例子。虽然到目前为止为这个例子提出的索引方案是以一种临时的方式引入的，但我们现在将系统地应用这四种策略。回顾一下，`Taylor-Hood`的基数用以下方式表示

$$
\Lambda_{\mathrm{TH}}=\left(\Lambda_{P_{2}} \sqcup \Lambda_{P_{2}} \sqcup \Lambda_{P_{2}}\right) \sqcup \Lambda_{P_{1}}
$$

对于基本空间$\Lambda_{P_{1}}, \Lambda_{P_{2}}$的基数$P_{1}, P_{2}$，我们考虑固定给定的平指数映射

$$
\iota_{P_{1}}\left(\Lambda_{P_{1}}\right) \rightarrow \mathbb{N}_{0}, \quad \iota_{P_{2}}\left(\Lambda_{P_{2}}\right) \rightarrow \mathbb{N}_{0}
$$

这些通常是通过列举基函数所关联的网格实体来构建的。然后，`interior`乘积空间基础

$$
\Lambda_{V}=\Lambda_{P_{2}} \sqcup \Lambda_{P_{2}} \sqcup \Lambda_{P_{2}}
$$







与索引图$\iota_{P_{2}}$一起是定义$10.6$意义上的权力节点，而树根

$$
\Lambda_{\mathrm{TH}}=\Lambda_{V} \sqcup \Lambda_{P_{1}}
$$

是一个复合节点。速度的$k^{th}$分量的基础函数表示为

$$
v_{x_{k}, i}=\mathbf{e}_{0} \otimes\left(\mathbf{e}_{k} \otimes \phi_{i}^{P_{2}}\right)
$$

其中$i=0, \ldots, n_{2}-1$为$n_{2}=\left|\Lambda_{P_{2}}\right|=\operatorname{dim} P_{2}$，而压力的基础函数则用以下表示

$$
p_{j}=\mathbf{e}_{1} \otimes \phi_{j}^{P_{1}}
$$

其中$j=0, \ldots, n_{1}-1$为$n_{1}=\left|\Lambda_{P_{1}}\right|=\operatorname{dim} P_{1}$。

由于上述给出的策略中有两个可以用于复合节点，而所有四个都可以应用于功率节点，我们得到了八个不同的索引图，用于`Taylor-Hood`基础$\Lambda_{\mathrm{TH}}$ 。它们被列在[Tab10.1]中，其中标签$X(Y)$意味着策略$X$用于外积，策略$Y$用于内积。对于$X$和$Y$，我们使用BL（BlockedLexicographic）、BI（BlockedInterleaved）、FL（FlatLexicographic）和FI（FlatInterleaved）等缩写。[Fig10.4]和[Fig10.5]中描述的索引图分别为策略BL（BL）和BL（BI）所复制。

\subsubsection{Localization to Single Grid `Elements`}

在大多数情况下，对有限元基的访问是按元素进行的（参见第2.1.3章）。因此，考虑基数对单个网格元素的限制是很重要的。与前几节相比，我们现在要求领域$\Omega$有一个有限元网格。为了简单起见，我们将假设所有的基都是由相对于这个网格逐片定义的函数组成的，但实际上只需要要求所有的基函数对网格元素的限制能够被廉价地构造出来即可。

考虑给定树的所有基函数$\phi \in \Lambda$对单一固定网格元素$T$的限制。在这些限制函数中，我们抛弃了所有在 $T$ 上的恒定零函数。所有其他的则构成了$T$上的局部基础。

$$
\left.\Lambda\right|_{T}:=\left\{\left.\phi\right|_{T}: \phi \in \Lambda, \quad \operatorname{int}(\operatorname{supp} \phi) \cap T \neq \emptyset\right\}
$$

本地基础形成一棵与原始函数空间基础树同构的树，每个全局函数空间基础$\Lambda$被其本地对应的基础$\left.\Lambda\right|_{T}$取代。

对于$\Lambda$的一个给定的索引图$\iota$，这个从全局树到局部树的自然同构，自然地诱导出$\iota$的局部版本，其结果为

$$
\left.\iota\right|_{T}:\left.\Lambda\right|_{T} \rightarrow \mathcal{I},\left.\quad \iota\right|_{T}\left(\phi_{T}\right):=\iota(\phi)
$$

这是将给定网格元素$T$上的`shape functions`与相应的全局基函数的多索引联系起来的映射。请注意，$\left.\operatorname{map} \iota\right|_{T}$本身不是定义$10.5$意义上的索引图，因为$\left.\iota\right|_{T}\left(\left.\Lambda\right|_{T}\right)$只是索引树$\iota(\Lambda)$的一个子集，而不一定是索引树本身。

为了有效地索引$\left.\Lambda\right|_{T}$中的基函数，我们引入一个额外的局部索引图

$$
\iota_{\left.\Lambda\right|_{T}}^{\text {local }}:\left.\Lambda\right|_{T} \rightarrow \mathcal{N}
$$

这样，$\iota_{\left.\Lambda\right|_{T}}^{\text {local }}\left(\left.\Lambda\right|_{T}\right)$是一个索引树。索引$\iota_{\left.\Lambda\right|_{T}}^{\text {local }}\left(\left.\phi\right|_{T}\right)$被称为$\phi$的局部索引（就$T$而言）。为了区别于由$\iota$产生的索引，我们称$\iota(\phi)$为$\phi$的全局索引。本地索引通常用于解决元素刚度矩阵。原则上，这种索引可以使用另一个非平坦的索引树，它不必与全局基础的索引树重合。这意味着形状函数的局部索引又可以是一个多索引，但其类型、长度和排序可以与相应的全局索引完全不相关。这将允许对`element stiffness matrices`和负载向量使用嵌套类型。正如第10.2章所解释的，`dune-functions`的实现在这里有相当的限制，只允许平坦的局部索引，即$\iota_{\left.\Lambda\right|_{T}}^{\text {local }}\left(\left.\Lambda\right|_{T}\right) \subset \mathbb{N}_{0}$ 。

此外，对于全局基树的每个叶子局基$\left.\hat{\Lambda}\right|_{T}$，我们引入另一个局基索引图

$$
\iota_{\left.\hat{\Lambda}\right|_{T}}^{\text {leaf-local }}:\left.\hat{\Lambda}\right|_{T} \rightarrow \mathbb{N}_{0}
$$

由于没有涉及层次结构，这个索引只是一个自然数。索引$\iota_{\left.\hat{\Lambda}\right|_{T}}^{\text {leaf-local }}\left(\left.\phi\right|_{T}\right)$被称为$\phi$的叶子-本地索引（相对于$T$而言）。

在实际的编程接口中，人们通常通过索引直接访问基函数。我们以后会看到，在`dune-functions`中，叶子本地索引是`dune-localfunctions`模块的形状函数索引。因此，`dune-functions`的API需要实现映射

$$
\iota_{T}^{\text {leaf } \rightarrow \text { local }}:=\iota_{\Lambda_{T}}^{\text {local }} \circ\left(\iota_{\left.\hat{\Lambda}\right|_{T}}^{\text {leaf-local }}\right)^{-1}
$$

将叶子的本地索引映射到本地索引，以及

$$
\iota_{T}^{\text {local } \rightarrow \text { global }}:=\left.\iota\right|_{T} \circ\left(\iota_{\left.\Lambda\right|_{T}}^{\text {local }}\right)^{-1}
$$

将本地指数映射到全球多指数。

\subsection{Programming Interface for Function Space Bases}

`dune-functions`函数空间基的接口的设计遵循了上一节的思路。主要的界面概念是代表函数空间基数树的全局基数对象。这些树可以被定位到网格的各个元素上。这样的定位提供了对那里的（树）`shape functions`的访问，以及两个形状-函数索引图$\iota_{T}^{\text {leaf } \rightarrow \text { local }}$和$\iota_{T}^{\text {local } \rightarrow \text { global }}$ 接口的结构在[Fig10.7]中被可视化了。

全局基础接口不是通过派生特定的基类来执行的。相反，`dune-functions`是基于C++风格的鸭子类型，也就是说，任何提供所需接口的$\mathrm{C}++$类型都是该接口的有效实现（4.4.2章）。在内部，`dune-functions`依赖于`dune-typetree`模块，它实现了抽象的编译时树形数据结构。与迄今为止提到的所有其他DUNE模块不同，`dune-functions`将其所有代码保存在一个专门的命名空间`Dune::Functions` 中。

\subsubsection{The Interface for Global Function Space Bases}

我们首先描述了全局基地的用户界面。由于我们讨论的是鸭子类型的接口，下面使用的所有类名都是通用的。一棵全局基的树由一个类来实现，在下文中，我们将称之为`GlobalBasis`，它可以有任意数量的模板参数。在下面的接口声明中列出的所有类型和方法都应是通用实现类的公共成员 `GlobalBasis` 。

由于每个基础实现都可能需要它自己的特定数据来构建，我们并不强制要求一组精确的构造器。每个`GlobalBasis`可能有一个或几个构造器，其参数列表与实现有关。

`GlobalBasis`的主要目的是提供对基函数及其指数的访问。这种访问大部分是通过基数在单个网格元素上的定位发生的（第10.1.5节）。在编程接口中，这种本地化被称为 `LocalView` 。`LocalView`类型的对象是通过方法从`GlobalBasis`对象获得的

~~~C++
LocalView localView() const
~~~

`localView` 方法的精确返回类型取决于实现。由该方法创建的对象具有未定义的状态，需要在一个称为 `binding` 的过程中附加到各个网格元素。细节在第10.2.2节中解释。

a`GlobalBasis`的几个方法提供了关于树中所包含的基的大小的信息。全局基的基函数总数通过以下方法输出

~~~C++
size_type dimension() const
~~~

如果使用扁平的多索引，这个方法可以用来分配矢量容器。然而，`dimension`方法所提供的信息通常不足以分配被更多普通多索引访问的分层容器。因此，该基础通过方法提供了这些多索引的额外结构信息

~~~C++
size_type size(const SizePrefix& prefix) const
~~~


参数prefix本身就是一个多索引。如果$\mathcal{I}$是基础的所有全局多索引的集合，并且prefix是这个集合的一个前缀，那么size(prefix)返回相对于$\mathcal{I}$的大小$\operatorname{deg}_{\mathcal{I}}^{+}[prefix]$，即索引树中prefix节点的直接子节点数量。如果prefix不是$\mathcal{I}$的前缀，则结果是未定义的。如果前缀$\in \mathcal{I}$，即前缀本身是多索引之一，那么结果是零。类型`SizePrefix`总是类型`ReservedVector`的容器（来自`dune-common`模块；更多细节在第10.2.4章给出）。像所有在`GlobalBasis`接口中使用的其他类型一样，实现类必须导出它。为了方便，还有一个方法

~~~C++
size_type size() const
~~~


返回与size$(\{\})$相同的值，即索引树根部的子女数。对于标量基来说，这又是基函数的总数量。

最后，每个`GlobalBasis`提供了对它所定义的网格视图的访问，方法是

~~~C++
const GridView& gridView() const
~~~


相应的类型被导出为 `GridView` 。如果网格视图被修改（例如，通过局部网格细化），调用基础的任何方法的结果都是未定义的，直到基础被明确更新。对于这一点，有一个方法

~~~C++
void update(const GridView& gridView)
~~~

这告诉基础要根据新的网格视图调整其本地状态。

\subsubsection{The Interface for the Localized Basis}

一个函数空间基础对单个网格元素的定位是由一个叫做 `LocalView` 的接口表示的。`LocalView`类型的对象由`GlobalBasis`方法`localView`返回，没有办法直接构造这种对象。在下面的接口声明中列出的所有类型和方法都是通用类 `LocalView` 的公共成员。

一个新构建的`LocalView`对象还没有完全初始化。为了真正让该对象代表某个特定元素上的基础定位，它必须对该元素进行`bound`。这可以通过调用

~~~C++
void bind(const Element& element)
~~~


其中`Element`被定义为`GridView::Codim<0>::Entity` 。一旦这个方法被调用，`LocalView`对象就被完全设置好并可以使用。该调用可能包含了预先计算局部基础函数及其全局指数所需的昂贵计算。通过再次调用bind方法，本地视图可以在任何时候被绑定到另一个元素。要再次将本地视图设置为非绑定状态，请调用方法

~~~C++
void unbind()
~~~

本地视图将存储一个它所绑定的元素的副本，可以通过

~~~C++
const Element& element() const
~~~


绑定`LocalView`对象提供了关于当前元素的局部基础的大小信息。与当前元素的局部视图相关联的基函数的总数由以下方式返回

~~~C++
size_type size() const
~~~


在第$10.1$章的语言中，这个方法计算出数字$|\Lambda|_{T} \mid$。

为了允许为本地函数预先分配缓冲区，方法是

~~~C++
size_type maxSize() const
~~~

返回网格视图中与全局基础相关的所有元素的大小方法的最大返回值，也就是说，它计算 $\max _{T}|\Lambda|_{T} \mid$ 。由于该信息不依赖于某个特定的元素，方法maxSize甚至可以在非绑定状态下被调用。

作为一个例子，假设该基础是一个类型为`TaylorHoodBasis`的对象，它实现了泰勒-霍德基础，在上一节的例子中已经使用过。下面的代码在网格视图的所有元素上循环，并打印出每个元素的自由度数量。

~~~C++
auto localView = basis.localView();
for (auto&& element : elements(basis.gridView()))
{
    localView.bind(element);
    std::cout << "Element with " << localView.size()
    << " degrees of freedom" << std::endl;
}
~~~


对实际的局部基础函数的访问是由以下方法提供的

~~~C++
const Tree& tree() const
~~~


这封装了定位到元素$\left.\Lambda\right|_{T}$的基函数集合，在函数空间基的树中组织。虽然树本身可以在非绑定状态下被查询，但为了使用树的大部分方法，本地视图必须被绑定。下面是对树对象的接口的详细讨论。

对于`tree`所能访问的局部树中的任何一个局部基础函数，全局多指数由以下方法提供

~~~C++
MultiIndex index(size_type i) const
~~~


该方法的参数是由`node.localindex(k)`返回的树内基函数的局部索引（`localIndex`方法见第355页）；这里节点是由`tree ()`提供的树的叶节点，$\mathrm{k}$是相应局部有限元中形状函数的编号（见下文）。因此，`index`方法实现了$10.1 .5$节中介绍的映射$\iota_{T}^{\text {local } \rightarrow \text { global }}$，它将局部索引映射到全局多索引。多次访问同一个全局索引应该是很便宜的，因为在绑定过程中，实现者应该预先计算和缓存索引。在未绑定状态下调用 `index(size_type)` 的结果是未定义的。

扩展前面的例子，下面的循环打印出每个元素的每个自由度的全局指数。

~~~C++
auto localView = basis.localView();
for (auto&& element : elements(basis.gridView()))
{
    localView.bind(element);
    for (std::size_t i=0; i<localView.size(); i++)
    std::cout << localView.index(i) << std::endl;
}
~~~


当这段代码在二维三角形网格上运行Taylor-Hood基础时，它将打印每个元素的15个多指数，因为Taylor-Hood元素在每个三角形中有12个速度自由度和3个压力自由度。

最后，`GlobalBasis`类型的全局基础由`LocalView`对象知道，并由 globalBasis 方法导出。

~~~C++
const GlobalBasis& globalBasis() const
~~~


因此，只给出一个`LocalView`对象的代码可以从它那里检索到全局基础，并从那里检索到网格视图。

\subsubsection{The Interface for the Tree of Local Bases}

本地视图通过导出一个Tree对象提供对元素的本地基础函数的访问，该对象在其叶子中保留了本地基础函数。树结构被编码在Tree对象的类型中，使用`dune-typetree`模块的基础设施。

由`LocalView::tree`方法返回的对象实际上不是一棵树，而是（对）树的根节点的常量引用。为了在树内导航，任何非叶子节点都允许使用两个方法访问其子节点

~~~C++
template<class... ChildIndices>
auto child(ChildIndices... childIndices)
~~~


和

~~~C++
template<class ChildTreePath>
auto child(ChildTreePath childTreePath)
~~~



这些方法的参数是当前节点到所需后代的路径。

对于第一种方法，路径是作为一个索引序列传递的。指向权力节点的子节点的索引可以作为运行时的整数传递，通常是 `std::size_t` 类型的。指向复合节点的子节点的指数必须作为类型为 `Dune::index_constant<i>` 的对象静态传递。为了方便，这种类型的全局常量`_0, _1, ...`在`Dune::Indices`命名空间中实现，在头文件`dune/common/indices.hh`中。继续上一节的例子，如果localView是`TaylorHoodBasis`的局部视图，定位到一个特定的网格元素，那么第二个速度分量的叶节点可以通过以下方式获得

~~~C++
using namespace Dune::Indices; // Namespace containing
                               // the index constants _0, _1, _2, ...
const auto& node = localView.tree().child(_0, 1);
~~~



注意索引常数`Dune::Indices::_0`是如何被用来解决速度节点的，因为树根是一个复合节点，其子节点的类型不同。在速度子树内，三个子节点都是相同的，第二个子节点可以通过运行时的整数1来访问。

第二个子方法允许在一个专门的容器中传递树的路径。这样的容器需要处理静态和运行时值的序列。`dune-functions`模块为此使用了`Dune::TypeTree::HybridTreePath`，我们在第10.2.4章详细介绍。使用 `HybridTreePath` 对象，这个例子看起来如下。

~~~C++
auto treePath = TypeTree::treePath(_0, 1);
const auto& node = localView.tree().child(treePath);
~~~


在它的每个叶子节点上，本地化的基础函数树提供了所有相应形状函数的集合。这方面的方法是



这个方法返回的对象是`LocalFiniteElement`，如`dune-localfunctions`模块（第8章）中所规定的。因此，它提供了对形状函数值和导数的访问，对[^42]意义上的自由度的评估，以及对元素面的局部自由度的分配。`dune-localfunctions`对`shape functions`使用的编号是第10.1.5节中定义的叶子-局部索引。例如，如果节点是本地化Taylor-Hood树中的一个叶子节点，下面的代码在适当的参考元素的局部坐标中打印出$(0,0,0)$点的叶子形状函数集的所有形状函数值。

~~~C++
const auto& localBasis = node.finiteElement().localBasis();
std::vector<double> values;
localBasis.evaluate({0,0,0}, values);
for (auto v : values)
    std::cout << v << std::endl;
~~~



为了从一个给定的叶子节点获得对应于一个给定形状函数的元素刚度矩阵的条目，需要从该形状函数的叶子-局部索引中计算出局部索引。对于每个局部基础函数，该方法

~~~C++
size_type localIndex(size_type i) const
~~~

返回与整个局部树相关的当前元素的所有局部基础函数中的局部索引。这个方法的参数是叶子内的局部基础函数的索引。换句话说，localIndex方法实现了第10.1.5节中介绍的map $\iota_{T}^{\text {leaf } \rightarrow \text { local }}$。其返回值不是一个多索引。虽然原则上本地子树的所有基函数都可以使用一般的多索引，但`dune-functions`模块在此只支持平面索引，以保持实现的简单。

虽然`LocalFiniteElement`对象只在叶子节点上可用，但下面的方法又在树的每个节点上工作。调用

~~~C++
size_type size() const
~~~


返回以当前节点为根的子树中局部基函数的总数。特别是，为树根调用此方法，可以得到元素刚度矩阵的行和/或列的数量。

最后，所有节点都可以通过以下方法访问它们所绑定的元素

~~~C++
const Element& element() const
~~~

 \subsubsection{Multi-Indices}

多重指数在 `dune-functions` 中有多处出现。它们被用作全局索引，用于识别函数空间基础的各个基函数，也用于索引基础和索引树的内部节点。从实现的角度来看，基树和索引树有很大的不同。只有本地化的基树明确地出现在编程界面中，而索引树只是隐含地以具有适当结构的索引集的形式出现（定义10.3）。这些差异要求对不同类型的树进行单独的多索引实现。我们依次讨论这两种类型的树的实现。

\textbf{Multi-Index Implementations for Basis Trees}

本地化基函数的树是唯一明确出现在`dune-functions`编程界面中的树。该树结构被编码为$\mathrm{C}++$类型信息，使用`dune-typetree`模块中的工具。在这个树中的导航需要操作从根到特定节点的路径。原则上，这样的路径是一个整数的序列。

为了理解实现，请记住，非叶树节点可以有两种类型，`power`和`composite`（10.1.4节）。由于复合节点有不同类型的子节点，所以不可能使用运行时索引访问这些子节点。相反，复合节点中的子节点索引必须以静态的方式进行编码，使用在第7.2.2章中已经看到的`index_constant`类型。另一方面，一个动力节点的所有子节点具有相同的 $\mathrm{C}++$ 类型，可以使用 `std::size_t` 类型的动态索引进行访问。

在一个典型的树中，复合节点和动力节点一起出现。因此，有必要有一个容器，可以同时存储编译时和运行时的整数。这可以通过类

~~~C++
template<class... I>
class HybridTreePath
~~~


来自`dune-typetree`模块。从概念上讲，`HybridTreePath`是一个固定大小的容器，其中每个条目可以是不同的类型。各个条目的类型作为模板参数被传递。如果一个条目使用的类型是`std::size_t` ，那么这个条目将有一个动态值。另一方面，如果类型是`Dune::index_constant<i>`，那么它的值是静态的，可以用于编译时决定。

如果动态树路径条目只作为树中动力节点的子索引出现，而所有其他条目都是静态的，那么`HybridTreePath`类型的对象可以用来访问本地化基树的节点。例如，要访问`Taylor-Hood`中描述的[Fig10.2]安萨特树中的速度分量所对应的叶子节点，可以使用类型为多索引的

~~~C++
HybridTreePath<Dune::index_constant<0>, std::size_t>;
~~~


而压力叶子节点的多指标将使用类型为

~~~C++
HybridTreePath<Dune::index_constant<1> >;
~~~

要构建这些类型的对象，请调用

~~~C++
using namespace Dune::Indices;
HybridTreePath<Dune::index_constant<0>, std::size_t> i00(_0,0);
HybridTreePath<Dune::index_constant<0>, std::size_t> i01(_0,1);
HybridTreePath<Dune::index_constant<0>, std::size_t> i02(_0,2);
~~~


为速度叶子结点，和

~~~C++
HybridTreePath<Dune::index_constant<1> > i1(_1);
~~~



为压力节点。如上所述，常数 `_0` 和 `_1` 是在命名空间 `Dune::Indices` 中预定义的。


这种构造方式过于冗长，因为静态指数必须作为模板和构造参数来提供。为了简化此类对象的构造，`dune-typetree`模块提供了辅助函数

~~~C++
template<class... I>
auto TypeTree::treePath(I... i)
~~~



该方法用给定的条目创建一个 `HybridTreePath` 对象。由于这是一个自由方法，而不是一个构造函数，因此只需给出一次条目，并且它们的类型是推断出来的。前面例子中的多索引可以用以下方法构造

~~~C++
auto i00 = TypeTree::treePath(_0, 0);
auto i01 = TypeTree::treePath(_0, 1);
auto i02 = TypeTree::treePath(_0, 2);
auto i1 = TypeTree::treePath(_1);
~~~


这要短得多。

要访问`HybridTreePath`对象的条目，该对象有方法

~~~C++
template<std::size_t i>
constexpr decltype(auto)
        operator[](const Dune::index_constant<i>& indexVariable) const
~~~



根据模板参数i，返回类型是`std::size_t` 或 `Dune::index_constant<i>` 。请注意，尽管函数已经是`constexpr`，但这种构造是必要的：因为`HybridTreePath`对象是为了在运行时上下文中选择不同类型的子对象，它们必须把编译时的索引值编码到运行时的索引对象中。后者只有通过使这些索引对象的类型依赖于它们的编译时值才能实现。

然而，由于`Dune::index_constant`类型的对象可以隐含地转换为`std::size_t`，因此也存在着

~~~C++
auto operator[](std::size_t i) const
~~~


因此，为了得到树状路径的第一个数字，可以写成

~~~C++
std::size_t d0 = myHybridTreePath[0];
~~~

对于`Taylor-Hood`树中的树路径，这将按照预期返回0或1。然而，这个返回值在编译时的情况下已经不能使用了。

这些只是`HybridTreePath`类中比较重要的方法。完整的描述见`dune-typetree`模块的在线文档。

\textbf{Multi-Index Implementations for Index Trees}

索引树是由用于标记基础函数的多索引形成的。在概念上，`dune-functions`接口中有两个这样的树：全局指数树和局部指数树。为了保持实现的简单性，`dune-functions`只允许本地索引树的平面（即个位数）多索引。因此，只需要讨论全局索引的数据类型。

与上一节的树状路径不同，全局索引是运行时的构造。一个单一的$\mathrm{C}++$类型代表了一个给定基础的所有此类索引，即使该基础有一个非简单的树结构。确切的类型是由基础实现选择的，并且可能因基础而异。它主要取决于指数是否是统一的，即所有来自该集合的指数是否有相同的数字。在访问`std::tuple`或`MultiTypeBlockVector`（来自`dune-istl`模块，第7章）等容器时，拥有纯粹的动态多指数会很不方便。然而，它的优点是可以使用标准的运行时循环来迭代索引。

动态多指数是持有固定整数类型条目的随机访问容器。它们都实现了一个共同的接口，由两个成员函数组成

~~~C++
std::size_t size() const
~~~

和

~~~C++
auto operator[](std::size_t i) const
~~~

`size` 方法返回多指数的位数，`operator []` 允许按其位置访问每个条目。由于多指数通常不会被用户代码改变，所以这两种方法都是 `const` 。

下面我们将对 `dune-functions` 中用于表示多指数的类型做一个概述。在最一般的情况下，对于一个给定的基础，并非所有的多指数都有相同的位数。作为例子，请考虑[Tab10.1]中 第$1,2,5$行 和 第6列，它们给出了`Taylor-Hood`基础的这种编号。在这些情况下，多指数通常用类来表示

~~~C++
template<class T, int k>
class ReservedVector
~~~


来自 `dune-common` 模块，它由条目类型 $\mathrm{T}$ 和容量 $\mathrm{k}$ 参数化。它实现了一个标准库兼容的随机访问容器，具有动态大小，不得超过$\mathrm{k}$条目。与`std::vector<T>`这样的完全动态向量实现相比，`ReservedVector`类将其条目存储在栈上。这避免了动态内存管理，并使实现更有效率。全局多指数通常只有少量的数字，并且有一个已知的上界。因此，总是使用大小为$\mathrm{k}$的缓冲区的开销，即使是少于$\mathrm{k}$位的指数，通常也会很小。

然而，许多基数可以通过统一的索引树进行索引，即所有索引具有相同位数的索引集。在这种情况下，`ReservedVector`的容量可以被设置为正确的长度，而且不浪费缓冲区空间。然而，除了缓冲区外，每个`ReservedVector`对象还必须存储容器长度，当已知索引集是统一的，就不需要了。  因此，实现统一索引集的 `GlobalBasis` 对象可以选择使用固定大小的容器类型，如 `std::array` 而不是 `ReservedVector` 。

最后，如果基数的索引是平坦的，即只有一个数字的多指数，那么使用数组就会很麻烦。从道义上讲，平坦的多指数只是非负的整数。然而，如果$i$是一个长度为1的`std::array`，用它来访问一个名为`vec`的`std::vector`的相应条目就必须写成

~~~C++
auto value = vec[i[0]];
~~~

为了允许更直观的语法

~~~C++
auto value = vec[i];
~~~


`dune-functions` 实现了 `FlatMultiIndex` 类，用于基树的索引是平的情况。`FlatMultiIndex`类型的对象的行为与`std::array< T, 1>`类型的对象类似，但此外，它们允许将其内容投向$\mathrm{T} \&$。因此，`FlatMultiIndex`类型的对象可以像数字类型一样直接使用，也可以像多索引类型一样使用。

\subsection{Constructing Trees of Function Space Bases}

在 `dune-functions` 中有多种方法来构建有限元基。直接提供了一套标准基数。然后，这些可以被组合成树。反之，可以提取子树，它们（几乎）本身就像完整的基数。

\subsubsection{Basis Implementations Provided by `dune-functions`}

`dune-functions`模块包含了一个标准的有限元基数的集合。这些可以直接用于有限元模拟代码中。在写这篇文章的时候，有

- `LagrangeBasis` : `Lagrange` 顺序$k$ 的基础，其中$k$ 是运行时或编译时参数。这个实现适用于所有类型的符合要求的网格，包括具有多于一种元素类型的网格。在写这篇文章的时候，高阶空间只被部分实现。请查看在线类文档以了解当前状态。

- `LagrangeDGBasis` : 一个具有`Lagrange`形状函数的$k^{th}$阶`Discontinuous-Galerkin`（DG）基。作为一个DG基，它在不符合要求的网格上也能很好地工作。多项式阶数$k$是一个编译时参数。

- `RannacherTurekBasis` : 一个 $H^{1}$ 不符合要求的标量基础，它将 `Crouzeix-Raviart` 基础的想法适应于立方体网格 [^136] 。

- `BSplineBasis` : 如[^44]所述，在一个结构化的、轴对齐的网格上的B-spline基础。支持任意的阶数、尺寸和结点矢量，例如，允许使用 $C^{1}$ 元素来处理四阶微分方程。



    一个`BSplineBasis`对象在单个补丁上实现了一个基础，而网格必须与这个补丁相对应。为了使其发挥作用，对网格有几个限制。它必须是结构化和轴对齐的，并且只由（超）立方体元素组成。此外，元素的索引必须按字母顺序排列，并从左下角到右上角增加。元素的间距必须与结点的跨度相匹配。不幸的是，并不是所有这些要求都可以通过基础来检查，所以用户必须要有点小心。使用`YaspGrid`对象效果不错。

    与标准有限元基不同，在B-spline基中，基函数不能与顶点、边或元素等网格实体相关联。然而，`dune-localfunctions`编程接口规定，即使对于B-spline基，也必须有一个`LocalCoefficient`对象，该对象将`shape functions`分配给参考元素的面。对于`BSplineBasis`的实现，这个对象的行为是未定义的。

- `TaylorHoodBasis` : 一个一阶`Taylor-Hood`基础的实现。它的存在主要是作为一个例子，说明如何直接实现具有非三叉树的基。一般来说，非三阶乘积基可以很容易地以一种通用的方式构建。这种方法在第 $10.3 .2$ 章中有所描述，它是构建 `Taylor-Hood` 基础的首选方式。

对于上面列出的所有基数，由`tree.finiteElement()`提供的`shape functions`是以参考元素$T_{\text {ref }}$的坐标来实现。也就是说，如果一个网格元素$T$是通过变换$F: T_{\mathrm{ref}} \rightarrow T$得到的，那么代表基础函数$\phi$对元素$T$的限制的实现的局部形状函数是由$\left.\hat{\phi}\right|_{T}=\phi \circ F$给出。形成非`affine families`[^42]的有限元素可能需要额外的变换。以下全局基数的实现就属于这种情况。

- `RaviartThomasBasis` : `Raviart-Thomas`中问题的标准[^32]基础$H$（div）。可用于不同的顺序和元素类型。

- `BrezziDouglasMariniBasis` : 标准的 `Brezzi-Douglas-Marini` 基础，它是 $H$ (div)-conforming 问题的替代基础 [^32] 。

这两种基数都需要`Piola`转换来正确地将基数函数拉回参考元素上。从`dune-functions`$2.7$开始，这种转换并不是由`dune-functions`的实现来执行的，预计会在用户代码中发生。关于上面列出的基础实现的模板参数和构造器参数的详细讨论，我们参考在线文档。



\subsubsection{Combining Bases into Trees}

上一节的基数实现可以通过乘法来组合成新的基数。这将产生 $10.1$ 节中描述的树状结构。乘法代码驻留在 `BasisFactory` 名称空间，它是 `Dune::Functions` 中的一个嵌套名称空间。因此，本节中的例子需要一个

~~~C++
using namespace Dune::Functions::BasisFactory;
~~~

来进行编译。

将基数组合成树的方法并不直接操作上一节的基数类。相反，他们结合所谓的`pre-bases`，每个基础都有一个。这样做的原因是，在树状层次结构中结合实际的用户可见的基础类型在技术上具有挑战性，而树状层次结构本身又实现了函数空间基础的接口。因此，乘法运算符被应用于预基对象，并返回所得树的预基对象。然后，最终基础树的预基可以变成一个实际的基础。

由于产品预基中的所有预基都必须知道一些共同的信息，例如，网格视图，手动进行这种产品构建是冗长和容易出错的。作为一个更友好、更安全的解决方案，全局基础可以通过调用

~~~C++
template<class GridView, class PreBasis>
auto makeBasis(const GridView& gridView, PreBasis&& preBasis)
~~~



预基参数对产品进行编码。实际的基础是由`makeBasis`函数以一致的方式从预基中自动构建的。这也会自动确定一个合适的多指数类型，否则就必须由用户来完成。

在最简单的情况下，基础树由一个单叶组成。这个叶子就是，例如，上一节中的一个基础实现。作为惯例，每个全局基础`FooBarBasis`都有一个函数`BasisFactory::fooBar()`（与`FooBarBasis`定义在同一个头文件中），创建一个合适的预基础对象，存储所有基础的特定信息。这意味着，特别是人们可以写

~~~C++
auto raviartThomasBasis = makeBasis(gridView, raviartThomas<k>());
~~~

来获得给定网格视图的`Raviart-Thomas`基础。这个对`makeBasis`的调用等同于直接构建基础。

~~~C++
RaviartThomasBasis<GridView,k> raviartThomasBasis(gridView);
~~~



注意，`raviartThomas`函数，就像其他基地的相应函数一样，不需要网格视图作为参数。

如果`FooBarBasis`有模板和/或构造函数参数，那么按照惯例，它们的顺序与`BasisFactory::fooBar()`函数的模板和方法参数相同。作为唯一的区别，前者预留了网格视图类型和对象。


在一个产品中结合几个基数的前基数被称为`CompositePreBasis`，它被定义在文件夹`dune/functions/functionspacebases/`的头文件`compositebasis.hh`中。它实现了定义10.6中介绍的复合树节点。与上面的描述类似，可以使用全局函数来构造具有复合根的树的前基。

~~~C++
template<class... ChildPreBasis>
auto composite(ChildPreBasis&&... childPreBasis)
~~~


包含在命名空间 `BasisFactory` 中。该方法有未指定数量的参数，未指定类型。参数被认为是预基对象本身。它们可以是由`lagrange<1>()`或`raviartThomas <k>()`等构建的普通预基，也可以是由`composite`或`power`函数（见下文）分别构建的组合预基或动力预基。

例如，将`Raviart-Thomas`基与零阶`Lagrange`基结合起来（比方说用于解决`Poisson`方程[^37]的混合表述），适当的调用是

~~~C++
auto mixedBasis = makeBasis(
    gridView,
    composite(
        raviartThomas<0>(),
        lagrange<0>()
    ));
~~~


弹性理论中位移场的一阶`Lagrange`基的三份组合是由以下方式完成的

~~~C++
auto displacementBasis = makeBasis(
    gridView,
        composite(
        lagrange<1>(),
        lagrange<1>(),
        lagrange<1>()
    ));
~~~


这些例子产生了 [Fig10.8] 中所示的树。

第二个例子并不像它那样优雅。首先，将同一个标量`Lagrange`的基础列举三次是不方便的，也是不必要的措辞。其次，这个数字可能取决于一个参数。最后，实现可以从所有孩子都平等的明确知识中受益。基于这些原因，`dune-functions`提供了第二种组合基数的方法。`PowerPreBasis` 。该接口仍然是一个单一的方法

~~~C++
template<std::size_t k, class ChildPreBasis>
auto power(ChildPreBasis&& childPreBasis)
~~~



文件 `dune/functions/functionspacebases/powerbasis.hh` 中提供的。它将$\mathrm{k}$类型的子树的副本合并到一个新的树中。因此，上面的位移矢量场基础更容易被写成

~~~C++
auto displacementBasis = makeBasis(
    gridView,
    power<3>(
        lagrange<1>()
));
~~~



由于`composite`和`power`本身创造了预基，所有这些技术都可以结合起来。为了获得p-th阶`Taylor-Hood`基，请写出

~~~C++
auto taylorHoodBasis = makeBasis(
    gridView,
    composite(
        power<dim>(
            lagrange<p+1>()),
        lagrange<p>()
    ));
~~~



对power的调用产生了速度的dim-component`Lagrange`阶$\mathrm{p}+1$基础，对`composite`的调用将其与压力的p阶`Lagrange`基础相结合。请注意，这是构建`Taylor-Hood`基础的首选方式，与之相反的是

~~~C++
auto taylorHoodBasis = makeBasis(gridView, taylorHood());
~~~

和

~~~C++
auto taylorHoodBasis = TaylorHoodBasis<GridView>(gridView);
~~~

这些变体主要是作为一个实现实例而存在的。



前面的讨论遗漏了组合树中的自由度是如何编号的问题。在$10.1 .3$节中解释了自由度的指数如何通过其多指数结构形成一棵独立的树，以及这棵树是如何通过一组策略从基础树中构造出来。这些想法反映在`dune-functions`编程界面的设计中。首先，第10.3.1节的每个基都实现了对其自由度的编号，一般来说，这些编号是不能改变的。为了选择一个非微观基础的编号，对复合或幂的每次调用都可以用一个额外的标志来表示 `IndexMergingStrategy` 。四种实现的策略是

- `BlockedLexicographic`
- `BlockedInterleaved`
- `FlatLexicographic`
- `FlatInterleaved`


并在第10.1.4节中进行了描述。对于每个策略`FooBar`都有一个创建标志的函数`BasisFactory::fooBar( )`（在标题`functionspacebases/basistags.hh`中）。例如，可以用[Tab10.1]第二列（标有BL(BI)）中列出的索引来创建泰勒-霍德基础，其方法是


~~~C++
auto taylorHoodBasis = makeBasis(
    gridView,
    composite(
        power<dim>(
            lagrange<p + 1>(),
            blockedInterleaved()),
        lagrange<p>(),
        blockedLexicographic()
    ));
~~~


这将导致速度和压力自由度的多索引长度分别为3和2。用多索引长度为2的统一索引方案对基函数进行同样的排序（[Tab10.1]中标为BL(FI)的第4列），可得

~~~C++
auto taylorHoodBasis = makeBasis(
    gridView,
    composite(
        power<dim>(
            lagrange<p + 1>(),
            flatInterleaved()),
        lagrange<p>(),
        blockedLexicographic()
    ));
~~~


最后，通过以下方式得到一个仍然保留相同排序的平面索引方案（[Tab10.1]中标为FL(FI)的第8列）。

~~~C++
auto taylorHoodBasis = makeBasis(
    gridView,
    composite(
        power<dim>(
            lagrange<p + 1>(),
            flatInterleaved()),
        lagrange<p>(),
        flatLexicographic()
    ));
~~~



如果没有给出策略，`composite`将使用`BlockedLexicographic`策略，而权力将使用`BlockedInterleaved` 。

\subsection{Treating Subtrees as Separate Bases}

上一节已经展示了基数树如何被组合成更大的树。也可以从其他树中提取子树，并将这些子树本身视为基树。这种子树基的编程接口被称为 `SubspaceBasis` 。它主要与全局基础的界面相吻合，但除了 `GlobalBasis` 界面外，`SubspaceBasis` 还提供了关于子树如何嵌入全局基础的信息（在这里被称为 `root basis` ）。更具体地说，该方法

~~~C++
const GlobalBasis& rootBasis() const
~~~

提供了对 `root basis` 的访问，而该方法

~~~C++
const TypeTree::HybridTreePath& prefixPath() const
~~~


返回全树中与`SubspaceBasis`相关的子树的路径。为了方便起见，全局基础的行为类似于一个微不足道的`SubspaceBasis`，即它的方法rootBasis返回基础本身，prefixPath返回一个空树路径。请注意，`SubspaceBasis`与完整的全局基不同，因为全局多指数是根基的一个子集，因此它们通常既不是连续的也不是基于零的。相反，这些多指数允许访问存储完整`root basis`的系数的容器。

`SubspaceBasis`对象是通过一个全局工厂函数创建的，它被赋予`root basis`和所需子树的路径。路径可以作为单个`HybridTreePath`对象传递（见第10.2.4节），也可以作为单个索引的序列传递。

~~~C++
template<class GlobalBasis, class... PathIndices>
auto subspaceBasis(const GlobalBasis& rootBasis,
    const TypeTree::HybridTreePath<PathIndices...>& prefixPath)

template<class GlobalBasis, class... PathIndices>
auto subspaceBasis(const GlobalBasis& rootBasis,
    const PathIndices&... indices)
~~~



例如，假设`taylorHoodBasis`是第10.3.2节中定义的`Taylor-Hood`基础的任何一种实现。那么

~~~C++
auto velocityBasis = subspaceBasis(taylorHoodBasis, _0);
~~~

将提取速度自由度的子树，而

~~~C++
auto pressureBasis = subspaceBasis(taylorHoodBasis, _1);
~~~

将提取压力自由度的（微不足道的）子树。一个`SubspaceBasis`的可能不连续的多指数最好通过提取单一速度分量来说明

~~~C++
auto velocityX2Basis = subspaceBasis(taylorHoodBasis, _0, 2);
~~~


对于这个例子，下表显示了从完整基础中提取的`SubspaceBasis`的多指数，其中一列代表了[表10.1]中同样使用的不同指数合并策略。

[表10.1]: https://cdn.mathpix.com/snip/images/BfAgOnlbNDwAv_c65O89hgxbpR1vmQkwK-1h2Qaq3WM.original.fullsize.png

由此产生的大多数多指数集并不形成树。

\subsection{Functions}

`dune-functions`的第二个重要特征是一般函数的编程接口

\begin{equation}
f: \mathcal{D} \rightarrow \mathcal{R}
\label{10.5}
\end{equation}

集$\mathcal{D}$和$\mathcal{R}$之间。在许多重要的情况下，$\mathcal{D}$将是域$\Omega$，而$\mathcal{R}$是`Euclidean`空间，但`dune-functions`接口处理一般情况。

像`dune-functions`的其他部分一样，`duck typing`被用于接口（4.4.2章）。模型类形成了一个概念层次（如[Fig10.9]所示），尽管根本不涉及继承。接口的实现者需要编写具有模型类所指定的所有方法和行为的类。概念检查被用来产生可读的错误信息。下面几节将详细解释各个概念。

\subsubsection{Function Objects and Functions}

$\mathrm{C}++$语言有一种标准的方式来实现函数，在数学上给出了 \ref{10.5} 。如果一个语言构造是一个普通的函数，一个函数指针，或一个提供`operator ()`的类的对象（或对对象的引用），则被称为`function object`。我们将采用常见的惯例，把后者称为 `functor` 。在下文中，如果`operator ()`不返回`void`，我们将把一个函数对象表示为函数。换句话说，一个函数$f$是可以出现在如下形式的表达式中的任何东西

~~~C++
auto y = f(x);
~~~

为一个合适类型的参数$\mathrm{x}$。这类结构的例子有。

- 免费功能

    ~~~C++
    double sinSquared(double x)
    {
        return std::sin(x) * std::sin(x);
    }
    ~~~

- lambda表达式

    ~~~C++
    auto sinSquaredLambda = [](double x){return std::sin(x) * std::sin(x); };
    ~~~

- 漏斗

    ~~~C++
    struct SinSquared
    {
        double operator()(double x)
        {
            return std::sin(x) * std::sin(x);
        }
    };
    ~~~



这份清单并不详尽。

这三个例子都是以同样的方式调用。


~~~C++
double a = sinSquared(3.14); // Free function
double b = sinSquaredLambda(3.14); // Lambda expression
SinSquared sinSquaredObject;
double c = sinSquaredObject(3.14); // Functor
~~~

参数和返回值根本不需要是`double`，任何类型都可以。它们可以是标量或矢量类型，浮点或整数，甚至更多的奇特数据，如矩阵、张量和字符串。

要将一个函数作为参数传递给$\mathrm{C}++$方法，该参数的类型必须在被调用方法的签名中明确说明，例如

~~~C++
void evaluateAt42(double (*f)(double)) // Accepts a function pointer
void evaluateAt42(SinSquared f) // Accepts SinSquared function objects
~~~

为了允许`any`函数类型作为方法参数，它必须是一个模板参数。

~~~C++
template<class F>
void evaluateAt42(F&& f)
{
    std::cout << "Value of f(42): " << f(42) << std::endl;
}
~~~


然后，上面的任何一个例子函数都可以作为方法的参数 `evaluateAt42` 。

~~~C++
evaluateAt42(sinSquared); // Call with a free function
evaluateAt42(sinSquaredLambda); // Call with a lambda expression
evaluateAt42(sinSquaredObject); // Call with a functor
~~~


\subsubsection{Type Erasure and `std::function`}

对于前面的例子，`evaluateAt42`方法的三个不同实例是由编译器创建的，用于这里的三种不同的函数类型。然而，有时候，一个函数的精确类型在编译时并不知道，而是根据运行时的信息来选择。这种行为通常被称为 `dynamic dispatch` 。实现它的经典方法是使用继承和`virtual`关键字：所有实现函数的类必须继承自一个共同的基类，然后这个类的指针被传递，而不是函数本身。

这种方法的缺点已经在第4.4.1章讨论过了。与函数接口特别相关的是，在派生类中，`operator()`的返回值必须与基类中使用的返回值相匹配（除非是指针或引用类型，虽然这在函数接口中不会出现）。然而，经常方便的是，也允许返回值只与基类的返回值`convertible`一致。这在 $\mathrm{C}++$ 中是不可能的。

因此$\mathrm{C}++$标准库使用`type erasure`而不是继承来实现运行时多态性。从$\mathrm{C}++11$开始，标准库包含一个[^98]类，Sect.20.8.11。


~~~C++
template<class Range, class... Args>
class function<Range(Args...)>
~~~


将所有将一组类型参数 `Args ...` 映射到单一 $\mathrm{C}++$ 类型 `std::function` 后面的类型（可转换为）Range的函数包装起来。在 `dune-functions` 的上下文中，我们只对 `Args...` 是单一类型 `Domain` 的情况感兴趣。

给定两个类型 `Domain` 和 `Range` ，任何接受 `Domain` 作为参数并返回可转换为 `Range` 的函数对象都可以存储在一个 `std::function<Range(Domain)>` 类型的对象里。例如，重复使用第10.5.1节中$\sin ^{2}(x)$的三种实现，我们可以写成

~~~C++
std::function<double(double)> polymorphicF;
polymorphicF = sinSquared;       // Assign a free function
polymorphicF = sinSquaredLambda; // Assign a lambda expression
polymorphicF = SinSquared();     // Assign a functor
double a = polymorphicF(3.14);   // Evaluate
~~~

注意不同的C++结构体是如何被分配到同一个对象的。人们甚至可以这样写

~~~C++
// Okay: Return type int can be converted to double
polymorphicF = [](double x) -> int
{
    return floor(x);
};
~~~


但不是

~~~C++
// Error: Return type std::complex<double> cannot be converted to double
polymorphicF = [](double x) -> std::complex<double>
{
    return std::complex<double>(x,0);
};
~~~



看一下`std::function`的实现，我们可以看到虚拟函数和堆分配被使用了`internally`，但它们对外界是隐藏的。考虑到这一点，人们可能不会期望类型清除比使用虚拟方法的动态多态性有任何运行时的收益。虽然`std::function`本身没有任何虚拟方法，但对`operator()`的每次调用都要通过一个虚拟方法。此外，每次对复制构造函数或赋值操作符的调用都会调用堆分配。虚函数调用是运行时多态性的代价。它只能通过智能编译器的去虚拟化来避免 [^96] 。为了减轻堆分配的代价，`std::function`通常实现一种叫做小对象优化的技术[^104]，它是运行时和空间需求之间的权衡。类型`std::function`的对象需要更多的内存与它，但如果函数对象很小，就可以避免堆分配。对 `dune-functions` 中类型擦除引起的性能惩罚的测量可以在 [^62] 中找到。

\subsubsection{Differentiable Functions}

将函数\ref{10.5}的概念扩展到可微函数，需要同时提供对其导数的访问。

$$
D f: \mathcal{D} \rightarrow L(\mathcal{D}, \mathcal{R})
$$

其中，在最简单的情况下，$L(\mathcal{D}, \mathcal{R})$是$\mathcal{D}$到$\mathcal{R}$的仿生壳的线性映射集。例如，对于一个函数$f: \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}$，导数$D f$将每个向量$x \in \mathcal{D}=\mathbb{R}^{n}$映射到从$\mathcal{D}=\mathbb{R}^{n}$到$\mathcal{R}=\mathbb{R}^{m}$的线性映射$D f(x)$ 。由于我们可以用矩阵$M \in \mathbb{R}^{m \times n}$来识别任何线性映射$M: \mathbb{R}^{n} \rightarrow \mathbb{R}^{m}$，我们可以用$\mathbb{R}^{m \times n}$来识别$L(\mathcal{D}, \mathcal{R})$。因此$D f$本身就是一个将$\mathbb{R}^{n}$的向量映射到$\mathbb{R}^{m \times n}$的矩阵的函数。

为了提供对导数的访问，`dune-functions`模块以一种自然的方式扩展了上一节的想法。一个$\mathrm{C}++$构造$\mathrm{F}$是一个可微函数，如果除了具有上述的`operator()`外，还有一个自由方法

~~~C++
Function derivative(const F& f)
~~~

即返回一个实现导数的函数。典型的方法将是一个`friend`函数，如下面的多项式的原型实现所说明的。

~~~C++
template <class T> // T is the number type
class Polynomial
{
public:
    Polynomial(const std::vector<T> &coefficients)
        : coefficients_(coefficients) {}
    T operator()(const T &x) const
    {
        // The Horner scheme
        auto y = coefficients_.back();
        for (int i = coefficients_.size() - 2; i >= 0, --i)
            y = x * y + coefficients_[i];
        return y;
    }
    friend Polynomial derivative(const Polynomial &p)
    {
        std::vector<T> dpCoefficients(p.coefficients_.size() - 1);
        for (size_t i = 1; i < p.coefficients_.size(); ++i)
            dpCoefficients[i - 1] = p.coefficients_[i] * i;
        return Polynomial(dpCoefficients);
    }

private:
    std::vector<T> coefficients_;
};
~~~


要使用这个类，请编写

~~~C++
auto f = Polynomial<double>({1, 2, 3});
double a = f(3.14);
double b = derivative(f)(3.14);
~~~

然而，请注意，导数方法可能很昂贵，因为它需要计算整个导数函数，而不仅仅是一个单一的值。因此，通常最好只调用它一次，并单独存储导数函数。

~~~C++
auto df = derivative(f);
double b = df(3.14);
~~~


更高的导数是通过重复调用导数得到的。


~~~C++
auto df = derivative(f);
auto ddf = derivative(df);
double c = ddf(3.14);
~~~


支持这些操作的函数是一个名为 `DifferentiableFunction` 的接口的实现。

当结合可微分函数和动态多态性时，`std::function`类不能原样使用，因为它不提供对`derivative`方法的访问。然而，它可以作为更一般的类型擦除包装器的灵感。`dune-functions`模块提供了类

~~~C++
template<class Signature,
        template<class> class DerivativeTraits=DefaultDerivativeTraits,
        size_t bufferSize=56>   // Buffer size in bytes
                                // for small object optimization
class DifferentiableFunction
~~~

在文件 `dune/functions/common/differentiablefunction.hh` 中。部分地，它是对 `std::function` 的重新实现。第一个模板参数`Signature`等同于`std::function`的模板参数`Range(Args...)`（其中`Args. ..`为单一类型`Domain`），而`DifferentiableFunction`实现了一个方法

~~~C++
Range operator()(const Domain& x) const
~~~



这个方法的工作原理与`std::function`中的方法基本相同，只是它的参数类型是`const Domain &`而不是`Domain`，因为数学函数\ref{10.5}的参数总是不可变的。此外，类型擦除包装器`DifferentiableFunction`实现了一个自由方法

~~~C++
friend DerivativeInterface derivative(const DifferentiableFunction& f)
~~~


包裹函数实现的相应方法 $\mathrm{f}$ 。它允许调用`derivative`方法的对象，其精确类型只在运行时确定。

~~~C++
DifferentiableFunction<double(double)> polymorphicF;
polymorphicF = Polynomial<double>({1, 2, 3});
double a = polymorphicF(3.14);
auto polymorphicDF = derivative(polymorphicF);
double b = polymorphicDF(3.14);
~~~



虽然导数函数的域是$\mathcal{D}$，与原始函数的域相同，但其范围是$L(\mathcal{D}, \mathcal{R})$。不幸的是，从$\mathcal{D}$和$\mathcal{R}$的类型中不可能总是推断出$\mathrm{C}++$对象的最佳类型。为了处理这个问题，`dune-functions`提供了`DerivativeTraits`类，它将函数的签名映射到其导数的范围类型。该行

~~~C++
using DerivativeRange = DerivativeTraits<Range(Domain)>::Range;
~~~


是用来访问应该用来表示 $L(\mathcal{D}, \mathcal{R})$ 的元素的类型。模板`interior`专门用于DUNE矩阵和矢量类型的常见组合，并为导数范围提供合理的默认值。然而，也可以通过传递一个自定义的`DerivativeTraits`模板给`DifferentiableFunction`类，来使用其他类型。这允许，例如，使用优化的特定应用的矩阵和向量类型，或为一般化的导数概念提供合适的表示。

\subsubsection{`GridView` Functions and Local Functions}

在任何有限元应用中，一类重要的函数是离散函数，即相对于网格而言被逐一定义的函数。对于$\mathcal{T}$上的网格，如果函数$f: \Omega \rightarrow \mathcal{R}$相对于$\mathcal{T}$有一个自然的分片定义，则称为`discrete function` 。这样的函数通常在全局坐标中，即在$x \in \Omega$点上直接评估，成本太高。幸运的是这几乎没有必要。相反，人们往往知道一个元素$T$和$x$相对于$T$的局部坐标$\xi \in T_{\text {ref }}$，允许评估$f(x)=f\left(F_{T}(\xi)\right)$ 。) 廉价的。从形式上看，这意味着我们有本地化的版本

$$
f_{T}:=f \circ F_{T}: T_{\mathrm{ref}} \rightarrow \mathcal{R}
$$

的每个网格元素$f$，其中$F_{T}$是通常从参考元素$T_{\text {ref }}$到$T$的地图。

为了支持这种函数评估，DUNE使用了一个`binding`机制，与第$10.2$章中用来定位基树的机制非常相似。为了在一个给定元素的局部位置$\xi$评估一个离散函数$f: \Omega \rightarrow \mathcal{R}$，使用了以下代码。

~~~C++
auto localF = localFunction(f);
localF.bind(element);
auto y = localF(xi);
~~~


这里我们首先得到一个`local function``localF`，它代表$f$对单一元素的限制。然后，这个函数被绑定到一个特定的元素，使用的方法是

~~~C++
void bind(const Codim<0>::Entity& element)
~~~


这种明确的绑定允许函数在对该元素进行评估之前执行任何必要的设置程序。之后，本地函数可以使用第10.5.1章的标准函数接口进行评估，但现在使用本地坐标$\xi=F_{T}^{-1}(x)$相对于本地函数所绑定的元素。同样的本地化函数对象可以通过调用`bind`与不同的元素来用于其他元素。支持这些操作的函数被称为 `grid view functions` ，并被称为实现 `GridViewFunction` 模型。由本地函数实现的模型被称为 `LocalFunction` 。

由于有限元背景下的函数通常至少是可微的，`grid view functions`以及局部函数提供了第10.5.3节中概述的可微函数的完整接口。为了完全掌握接口的语义，请注意，严格来说，局部化与取导数并不相通。从形式上看，导数的本地化版本是由以下公式给出的

\begin{equation}
(D f)_{T}: T_{\text {ref }} \rightarrow L(\mathcal{D}, \mathcal{R}), \quad(D f)_{T}=(D f) \circ F_{T}
\label{10.6}
\end{equation}

与此相反，一个本地化函数的导数由以下公式给出

$$
D\left(f_{T}\right): T_{\text {ref }} \rightarrow L\left(T_{\text {ref }}, \mathcal{R}\right), \quad D\left(f_{T}\right)=\left((D f) \circ F_{T}\right) \cdot D F_{T}
$$

然而，在`dune-functions`的实现中，局部函数的导数按惯例总是返回全局坐标的值。因此，由`dfe1`和`dfe2`得到的函数

~~~C++
auto df = derivative(f);
auto dfT1 = localFunction(df);
dfT1.bind(element);

auto fT = localFunction(f);
fT.bind(element);
auto dfT2 = derivative(fT);
~~~


两者的行为都是一样的，实现$(D f)_{T}$和\ref{10.6}。这是因为$D\left(f_{T}\right)$在应用中几乎不被使用，而$(D f)_{T}$则经常被需要。为了表达接口中这种轻微的不一致，本地函数使用了一个特殊的`DerivativeTraits`实现，将导数范围转发到相应的全局函数中。

同样，类型擦除类允许以多态的方式使用网格视图函数和局部函数。该类

~~~C++
template<class Signature,
         class GridView,
         template<class> class DerivativeTraits=DefaultDerivativeTraits,
         size_t bufferSize=56> // Buffer size in bytes
                               // for small object optimization
class GridViewFunction
~~~


存储任何模拟`GridViewFunction`概念的函数，并给出签名和网格视图类型。同样地，模拟`LocalFunction`概念的函数可以存储在类

~~~C++
template<class Signature,
         class Element,
         template<class> class DerivativeTraits=DefaultDerivativeTraits,
         size_t bufferSize=56> // Buffer size in bytes
// for small object optimization
class LocalFunction
~~~


这些类型的擦除类可以组合使用。

~~~C++
GridViewFunction<double(GlobalCoordinate), GridView> polymorphicF;
polymorphicF = f;
auto polymorphicLocalF = localFunction(polymorphicF);
polymorphicLocalF.bind(element);
LocalCoordinate xLocal = ... ;
auto y = polymorphicLocalF(xLocal);
~~~

注意，如上所述，`polymorphicLocalF`中使用的`DerivativeTraits`与`polymorphicF`所使用的不一样。相反，它们是一种特殊的实现方式，即使对于域类型 `LocalCoordinate` ，也会转发到全局派生范围。

\subsection{Combining Global Bases and Coefficient Vectors}

现在我们把基数和函数的接口结合起来。通过 \ref{10.3} 中示例性的线性组合，将一个函数空间基和一个系数向量结合起来，可以得到一个离散函数。反之，离散和非离散函数可以投射到一个基的跨度上，从而得到一个相应的系数向量。在`dune-functions`中，这个过程被称为`interpolation`，尽管它不总是严格意义上的`interpolation`。

\subsubsection{Vector Backends}

在这两种情况下，各个基函数都需要与持有向量系数的容器数据类型的相应条目相关联。虽然在理论上是微不足道的，但在实践中却存在着差距，因为`dune-functions`用来标记基函数的多索引类型（第10.2.4节）不能用来访问标准随机访问容器的条目。

这个差距是由一个叫做 `vector backends` 的概念来弥补的。这些是对特定容器类的实现细节进行抽象的垫片类，并使它们可以被多索引所处理。目前`dune-functions`模块为`dune-istl`和$\mathrm{C}++$标准库中的容器提供了这样的后端，但其他的也可以很容易地加入。这使得将`dune-functions`函数空间基数与基本上任何线性代数实现相结合成为可能。

矢量后端概念有两个部分。当解释一个给定系数的向量相对于一个基时，只需要以非变通的方式进行访问。在`dune-functions`中，这一功能被编码在`ConstVectorBackend`的概念中，它只需要通过`operator []`使用函数空间基提供的多索引直接访问。

~~~C++
const auto& operator[](Basis::MultiIndex index) const
~~~


对于给定函数的插值，也需要一个相应的可变访问。此外，必须能够调整向量的大小，以匹配由基础生成的索引树。这两个额外的方法构成了`VectorBackend`的概念。

~~~C++
auto& operator[](Basis::MultiIndex index)
void resize(const Basis& basis)
~~~


注意，resize成员函数的参数不是一个数字，而是基础本身。这是必要的，因为调整嵌套容器的大小需要关于整个索引树的信息。

对于在`dune-istl`和`dune-common`模块中实现的向量类型，这样的后端可以通过以下方式获得

~~~C++
template<class SomeDuneISTLVector>
auto istlVectorBackend(SomeDuneISTLVector& x)
~~~

或

~~~C++
template<class SomeDuneISTLVector>
auto istlVectorBackend(const SomeDuneISTLVector& x)
~~~



(来自头文件 `dune/functions/backends/istlvectorbackend.hh` )。根据参数的常数，产生的对象实现了`VectorBackend`或只实现了`ConstVectorBackend`接口。尽管这些方法的名称中带有 istl 前缀，但它们实际上也能很好地用于 C++ 标准库中的容器，如 `std::array` 和 `std::vector` 。

由于非三阶乘积函数空间的基对应于具有非标度范围的函数，因此我们还必须将被扫描的乘积函数空间的组件映射为函数范围类型的组件。例如，如果由基生成的幂函数空间的函数

~~~C++
auto basis = makeBasis(
    gridView,
    power<dim>(
    lagrange<1>()
    ));
~~~


应该被解释为向量场，我们将把这个函数空间树的dim叶子节点映射为a `FieldVector <double, dim>` 的dim条目。当结合基数和范围类型时，`dune-function`使用一个默认的映射，将这个想法概括为更复杂的嵌套基数。假设$\mathrm{y}$是一个函数范围类型的对象。那么一个树状路径为`i0, ...,`的叶子节点与条目`y [i0]... [in]`相关。在范围类型不提供`operator []`的特殊情况下，它直接用于Ansatz空间的所有叶节点。这最后一条规则允许将一个标量函数一次性插值到一个基的所有分量中。为了增加灵活性，用户也可以提供自定义映射来代替这个映射。然而，我们将不讨论相应的接口，并在下文中依赖隐含的默认实现。

\subsubsection{Interpreting Coefficient Vectors as Finite Element Functions}

为了将一个基数和一个系数向量结合到一个离散函数上，`dune-functions`提供了方法

~~~C++
template<class Range, class Basis, class Coefficients>
auto makeDiscreteGlobalBasisFunction(const Basis& basis,
                                     const Coefficients& coefficients)
~~~

对于给定的基`basis`和系数向量`coefficients`，返回一个代表相应的有限元函数的对象。这个对象实现了`GridViewFunction`的概念，用于定义基础的网格视图，其范围类型为`Range` 。`basis`可以是全局基础，也可以是`SubspaceBasis` 。在后一种情况下，系数向量必须与全局基础相对应，但只有与子空间基础函数相关的系数才会被使用。

对于用来表示系数向量的`Coefficients`类型，有两种选择。要么它实现了`ConstVectorBackend`的概念，例如，所有由`istlVectorBackend`方法返回的对象都实现了。如果`Coefficients`没有实现这个概念，那么代码就会假定它是一个`dune-istl-style`容器，并试图用一个`ISTLVectorBackend`来包装它。这样一来，`makeDiscreteGlobalBasisFunction`方法就可以直接用`dune-istl`或标准库容器来调用，但其他的都必须明确地用适当的后端来包装。


必须注意的是，所产生的函数的范围类型一般不能从基础和系数类型中自动确定，因为可能有不止一个合理的选择。例如，一个标量函数可以返回 `double` 或 `FieldVector <double, 1>` 。因此，范围类型`Range`必须由用户明确给出。从基础的不同叶子节点到`Range`的条目的映射遵循第10.6.1章末尾描述的程序。

为了举例说明如何使用`makeDiscreteGlobalBasisFunction`，我们构建另一个泰勒-霍德基础的实例

~~~C++
auto taylorHoodBasis = makeBasis(
        gridView,
        composite(
            power<dim>(
                lagrange<p+1>()),
            lagrange<p>()
    ));
~~~



默认情况下，对于复合节点，合并策略为`BlockedLexicographic`，对于动力节点，合并策略为`BlockedInterleaved`。产生的指数是[Tab10.1]第2列中的指数。一个合适的矢量容器类型是

~~~C++
MultiTypeBlockVector<BlockVector<FieldVector<double,dim> >,
                        BlockVector<double>
                    >;
~~~


让$\mathrm{x}$成为这种类型的一个物体。为了得到相应的速度场作为一个离散函数，写成

~~~C++
// Create SubspaceBasis for the velocity field
auto velocityBasis = subspaceBasis(taylorHoodBasis, _0);

// Fix a range type for the velocity field
using VelocityRange = FieldVector<double,dim>;

// Create a function for the velocity field only
// but using the vector x for the full taylorHoodBasis.
auto velocityFunction
    = Functions::makeDiscreteGlobalBasisFunction<VelocityRange>(velocityBasis, x);
~~~



注意，`velocityBasis`所跨越的函数空间树的dim叶子节点被自动映射到`VelocityRange`类型的dim组件。最后一行创建的函数实现了第10.5.4章中描述的完整的`GridViewFunction`接口。

\subsubsection{Interpolation}

在有限元或有限体积模拟代码的各个部分，给定的函数需要在全局基础所跨越的空间中进行近似。例如，初始值函数可能以闭合形式给出，但需要转移到有限元表示中才能使用。同样，以闭合形式给出的`Dirichlet`值可能需要在`Dirichlet`自由度的集合上进行评估。根据有限元空间的不同，近似可能采取不同的形式。节点插值是`Lagrange`元素的自然选择，但对于其他空间$L^{2}$-投影或Hermitetype插值可能更合适。由于历史原因，`dune-functions`总是说到`interpolation` 。



`dune-functions` 模块在文件 `dune/functions/functionspacebases/interpolation.hh` 中提供了一组用于插值的方法。这些方法是典型的，因为它们使用`LocalInterpolation`接口的`dune-localfunctions`功能（第八章在每个元素上进行插值。这对许多人来说是合适的，但不是对所有的有限元空间。例如，不能为B-spline基数定义合理的局部插值，因此，标准插值功能不能用于`BSplineBasis`类。在DUNE$2.8$之前，这种方法对于非affine有限元也会失败，因为`LocalInterpolation`没有对参考元素应用非标准的变换。

内插功能是通过两个全局函数实现的。第一个函数处理一个给定的函数和基数的简单情况，其中函数将被投影到基数的跨度上，产生一个描述结果的系数向量。

~~~C++
template<class Basis, class Coefficients, class Function>
void interpolate(const Basis& basis,
                 Coefficients&& coefficients,
                 const Function& f)
~~~



请注意，这只有在$f$的范围类型和全局基础的基础是兼容的情况下才能工作。`dune-functions`模块实现了一个兼容层，允许使用来自DUNE核心模块的不同向量（或矩阵）类型和标量类型，例如，`double`用于$f$的范围，只要该范围类型的标量项的数量与基础所跨越的函数空间的范围尺寸相同。这也意味着假设各个基函数的系数是标量的。系数向量`coefficients`的类型要么必须实现`VectorBackend`的概念，要么必须可以被`istlVectorBackend`所包裹。例如，考虑函数

$$
f_{1}: \mathbb{R}^{2} \rightarrow \mathbb{R} \quad f_{1}=\exp \left(-\|x\|^{2}\right)
$$

实施为

~~~C++
auto f1 = [](const FieldVector<double,2>& x)
{
    return exp(-1.0*x.two_norm2());
};
~~~



此外，考虑一个标量二阶`Lagrange`空间

~~~C++
Functions::LagrangeBasis<GridView,2> p2basis(gridView);
~~~


和一个空的系数向量$x 1$，不一定有正确的大小。

~~~C++
std::vector<double> x1;
~~~


然后，单行

~~~C++
interpolate(p2basis, x1, f1);
~~~



将用函数 $f 1$ 的节点值填充 $\times 1$ 。

只要系数向量与基数相匹配，并且函数范围可以映射到与基数相关的乘积空间，这种内插法对非线性基树和由`subspaceBasis`函数获得的子树同样有效。考虑以下`Taylor-Hood`的二维网格的基，它使用平坦的多索引来标记其自由度。

~~~C++
using namespace Functions::BasisBuilder;
auto taylorHoodBasis = makeBasis(
    gridView,
    composite(
        power<GridView::dimension>(
            lagrange<2>(),
            flatLexicographic()),
        lagrange<1>(),
        flatLexicographic()
    ));
~~~



例如，这种基础的一个合适的系数向量是：。

~~~C++
BlockVector<double> x2;
~~~


在这种情况下，将$f 1$内插到`Taylor-Hood`基础的压力分量中可以通过以下方式实现

~~~C++
using namespace Indices;
interpolate(subspaceBasis(taylorHoodBasis, _1), x2, f1);
~~~


同样，我们可以将一个给定的矢量场$\mathrm{f} 2$插值到代表速度的非微观子树中，用

~~~C++
auto f2 = [](const FieldVector<double,2>& x) {
    return x; // Simple example function
};

interpolate(subspaceBasis(taylorHoodBasis, _0), x2, f2);
~~~


如果所提供的函数的范围类型具有与基础相同的嵌套结构，甚至可以插值到完整的`taylorHoodBasis`。

在某些情况下，只对域的一部分进行内插也是可取的。在代数上，内插就像以前一样进行，但只有所有系数的一个子集被写入容器中。最常见的使用情况是将`Dirichlet`数据插值到`Dirichlet`边界上的代数自由度。所有其他的自由度都不能被触及，因为它们可能包含，例如，通过其他方式获得的合适的初始迭代。

为了支持这种`interpolation`，插值方法的一个变种允许明确标记要写入的系数向量条目的子集。


~~~C++
template <class Basis, class Coefficients, class Function, class BitVector>
void interpolate(const Basis &basis,
                 Coefficients &&coefficients,
                 const Function &f,
                 const BitVector &bitVector
                 )
~~~


从概念上讲，额外的`bitVector`参数必须是一个具有与系数相同嵌套结构的布尔值的容器。它的条目被视为布尔值，表示是否应该写入系数的相应条目。例如，对于平面全局指数`std::vector < bool >`和`std::vector<char >`就很好用。`BitSetVector<N>`类（来自`dune-common`模块）可以作为`std::vector<std::bitset<N> >`的空间优化替代品。例如，为了将上面定义的$f 2$函数只插值到边界速度自由度中，首先设置一个合适的位向量。

~~~C++
std::vector<char> isBoundary;
auto isBoundaryBackend = Functions::istlVectorBackend(isBoundary);
isBoundaryBackend.resize(taylorHoodBasis);
std::fill(isBoundary.begin(), isBoundary.end(), false);
forEachBoundaryDOF(subspaceBasis(taylorHoodBasis, _0),
                   [&](auto &&index)
                   {
                       isBoundaryBackend[index] = true;
                   });
~~~


这使用了方便的方法

~~~C++
template<class Basis, class FunctionObject>
void forEachBoundaryDOF(const Basis& basis, FunctionObject&& predicate);
~~~



(来自文件`dune/functions/functionspacebases/boundarydofs.hh`），它实现了对位于域边界的实体相关的所有自由度的循环。该算法将为每个这样的自由度调用回调函数谓词，将其全局索引作为回调参数。

然后，实际的插值是一个单线。

~~~C++
interpolate(subspaceBasis(taylorHoodBasis, _1), x2, f2, isBoundary);
~~~

参见第$10.8 .3$章，了解更多的例子。

\subsection{Writing Functions to a VTK File}

第 $10.5$ 章意义上的函数可以被写入VTK文件，用于可视化和后处理 [^107] 。这方面的接口扩展了 `VTKWriter` 模块的 `dune-grid` 类，在第 $5.8.1$ 章中介绍过。建议在继续之前先阅读该章。

`VTKWriter`类允许将一个网格视图写入VTK文件，并将单元（即元素）和顶点数据附在其中。正如第5.8.1章所解释的，这些数据可以使用成员方法交给`VTKWriter`对象

~~~C++
template<class Container>
void addCellData(const Container& v, const std::string& name, int ncomps=1)
~~~

和

~~~C++
template<class Container>
void addVertexData(const Container& v, const std::string& name, int ncomps=1)
~~~



这些方法的`Container`参数预计将分别持有与网格元素或顶点相关的数值数据，VTK将此类数据解释为片状常数或线性函数。

然而，`VTKWriter`也直接接受定义在网格域$\Omega$上的函数作为数据。`VTKWriter`类中有两个方法用于此。

~~~C++
template<class F>
void addCellData(F&& f, VTK::FieldInfo vtkFieldInfo)

template<class F>
void addVertexData(F&& f, VTK::FieldInfo vtkFieldInfo)
~~~


这两种方法都接受一个函数$f$作为其第一个参数。`VTKWriter`对象在元素中心（`addCellData`）、顶点（`addVertexData`，如果数据模式为`VTK::conforming`）或元素角（`addVertexData`，如果数据模式为`VTK::nonconforming`）评估该函数，并将结果写到文件。

`VTK::FieldInfo`对象被用来向编写者传递有关函数的额外信息。大多数用户只需要它的构造函数

~~~C++
FieldInfo(std::string name,
          FieldInfo::Type type,
          std::size_t size,
          VTK::Precision prec = VTK::Precision::float32)
~~~



第一个参数是VTK用来表示该函数的名称。第二个参数描述了该函数的范围$\mathcal{R}$。可能的值是。

- `VTK::FieldInfo::Type::scalar` : 函数成分被写成独立的标量场。

- `VTK::FieldInfo::Type::vector` ：它们被写成一个矢量值场（将总是被零填充到三个分量）。



第三个参数size给出了范围的分量，这不是从函数类型的范围类型中自动提取的 $F$ 。最后，`prec`参数允许选择用于在VTK文件中存储函数的数值的数据类型，覆盖在构造函数中采取的选择。这里感兴趣的主要是 `VTK::Precision::float32` 和 `VTK::Precision::float64` 。

为了看到函数编写功能的作用，下面的例子显示了如何将一个标量函数写成单精度（4字节）的二维网格的元素数据。

~~~C++
auto f1 = [](const FieldVector<double, 2> &x)
{
    return std::sin(x.two_norm());
};
vtkWriter.addCellData(f1,
                      VTK::FieldInfo("first example function",
                                     VTK::FieldInfo::Type::scalar, 1));
~~~


另外，以下代码写了一个精度为`double`的2值函数。

~~~C++
auto f2 = [](const FieldVector<double, 2> &x)
{
    return FieldVector<double, 2>({x[0], -x[1]})
};
vtkWriter.addVertexData(f2,
                        VTK::FieldInfo("second example function",
                                       VTK::FieldInfo::Type::vector, 2,
                                       VTK::Precision::float64));
~~~


以这种方式编写的函数在VTK中最终成为片状常数（`addCellData`）或片状线性（`addVertexData`）函数。VTK文件格式确实支持高阶几何图形和相应的数据文件[^107]，但目前没有实现从`dune-grid`中写入这些文件。相反，该模块允许在一个给定网格的虚拟细化上对函数进行子采样。这样，非片状常数或片状线性的函数就可以被可视化了。

将子采样函数写入VTK文件是在一个单独的类`SubsamplingVTKWriter`中实现的，该类来自`subsamplingvtkwriter.hh`的头文件`dune/grid/io/file/vtk/`。这个类继承自 `VTKWriter` ，它有与 `VTKWriter` 类相同的模板参数和相同的公共成员方法。唯一的区别是构造函数

~~~C++
SubsamplingVTKWriter(const GridView& gridView,
                     RefinementIntervals intervals,
                     bool coerceToSimplex = false)
~~~



它的第一个参数是要写到文件中的网格视图。第二个参数指定虚拟细化，由专用类型的对象编码 `RefinementIntervals` 。这种类型的对象可以通过两个全局方法获得。第一个。

~~~C++
RefinementIntervals refinementIntervals(int intervals)
~~~

产生一个统一的细化，其中每个元素边被细分为新的间隔。该方法

~~~C++
RefinementIntervals refinementLevels(int levels)
~~~

另一方面，将执行标准统一细化的各级步骤（导致每条边总共有$2^{\text {levels }}$条新边）。如果可选的`coerceToSimplex`参数被设置为`true`，那么在应用细化之前，所有的元素都会被分割成单体。第`SubsamplingVTKWriter`章给出了一个显示使用$10.8$类的例子。

请注意，为了简化内部实现，`SubsamplingVTKWriter`对象总是以数据模式`VTK::nonconforming`写入VTK文件。如果输入的数据函数是连续的，这在输出中是不可见的，但产生的VTK网格将包含比预期更多的顶点。另一方面，如果输入的函数是不连续的，`SubsamplingVTKWriter`将自动重现不连续的情况，用户无需再设置任何选项。

由于`SubsamplingVTKWriter`继承自`VTKWriter`，它可以和`VTKSequenceWriter`一起使用（见第5.8.2章），后者将实际写入委托给`VTKWriter`对象。因此，用空间子采样来写随时间变化的数据是很直接的。

\subsection{Example: Solving the` Stokes Equation` with `dune-functions`}

在本章的最后，我们将展示一个完整的例子，证明`dune-functions`的特点。该程序将使用`Stokes`有限元解决静止的`Taylor-Hood`方程。它包含在一个文件中，打印在附录B.10中。如果你以电子形式阅读本文件，也可以通过点击空白处的图标访问该文件。

\subsubsection{The Stokes Equation}

`Stokes`方程对$d$维域中的粘性不可压缩流体进行建模 $\Omega$ 。这个问题有两个未知数：静止的流体速度场 $\mathbf{u}: \Omega \rightarrow \mathbb{R}^{d}$ ，以及流体压力 $p: \Omega \rightarrow \mathbb{R}$ 。他们必须一起解决边界值问题

$$
\begin{aligned}
-\Delta \mathbf{u}-\nabla p &=0 & & \text { in } \Omega \\
\operatorname{div} \mathbf{u} &=0 & & \text { in } \Omega \\
\mathbf{u} &=\mathbf{g} & & \text { on } \partial \Omega
\end{aligned}
$$

其中我们省略了物理参数。边界值问题只决定了压力$p$到一个常数函数为止。因此，压力通常被归一化，以便 $\int_{\Omega} p d x=0$

由于约束条件$\operatorname{div} \mathbf{u}=0$ ，相应的弱形式方程是一个鞍点问题。引入空间

$$
\begin{aligned}
\mathbf{H}_{\mathbf{g}}^{1}(\Omega) &:=\left\{\mathbf{v} \in H^{1}\left(\Omega, \mathbb{R}^{d}\right): \operatorname{tr} \mathbf{v}=\mathbf{g}\right\} \\
L_{2,0}(\Omega) &:=\left\{q \in L_{2}(\Omega): \int_{\Omega} q d x=0\right\}
\end{aligned}
$$

和双线性形式

$$
a(\mathbf{u}, \mathbf{v}):=\int_{\Omega} \nabla \mathbf{u} \nabla \mathbf{v} d x, \quad \text { and } \quad b(\mathbf{v}, q):=\int_{\Omega} \operatorname{div} \mathbf{v} \cdot q d x
$$

`Stokes`方程的弱形式是。找到$(\mathbf{u}, p) \in \mathbf{H}_{\mathbf{g}}^{1}(\Omega) \times L_{2,0}(\Omega)$，使得

$$
\begin{aligned}
a(\mathbf{u}, \mathbf{v})+b(\mathbf{v}, p) &=0 & & \text { for all } \mathbf{v} \in \mathbf{H}_{0}^{1}(\Omega) \\
b(\mathbf{u}, q) &=0 & & \text { for all } q \in L_{2,0}(\Omega)
\end{aligned}
$$

如果$\mathrm{g}$足够平滑，这个变分问题就有唯一的解。TaylorHood元素是离散化这个鞍点问题的标准方法[^37]，并将在下面的实现中使用。

\subsubsection{The Driven-Cavity Benchmark}

在我们的例子中，我们选择模拟一个二维驱动的腔体。这是文献中`Stokes`问题的一个标准基准 [^142] 。设$\Omega$为单位平方$[0,1]^{2}$，并将速度$\mathbf{u}$的`Dirichlet`边界条件设为

$$
\mathbf{u}(x)=\mathbf{g}(x):= \begin{cases}(0,1)^{T} & \text { if } x \in\{0\} \times[0,1] \\ (0,0)^{T} & \text { elsewhere on } \partial \Omega\end{cases}
$$

对这一点的解释是，一个流体容器，除了一侧之外，其余部分都是封闭的。当流体在封闭的两侧保持不动，一个外部媒介在左侧垂直的一侧驱动一个持续的向上运动。域和边界条件在[Fig10.10]中描述，左边。相应的解决方案显示在同一图的右边。速度形成一个涡流，而压力在左边的两个角上形成极值。



\subsubsection{Implementation}

该实现包括一个`Stokes`方程的汇编器和一个主方法。两者都将在下文中讨论。

\textbf{The `main` Method}

`main`方法设置了代数`Stokes`问题，调用线性求解器，并将结果写入VTK文件。它首先设置了MPI和网格。我们选择使用结构化的$4 \times 4$四边形网格对领域进行离散，我们通过使用`dune-grid`模块中的`YaspGrid`网格实现来获得。

~~~C++
 int main(int argc, char *argv[])
 {
    // Set up MPI, if available
    MPIHelper::instance(argc, argv);
    constexpr int dim = 2;
    using Grid = YaspGrid<dim>;
    FieldVector<double,dim> upperRight = {1, 1};
    std::array<int,dim> nElements = {4, 4};
    Grid grid(upperRight,nElements);

    using GridView = typename Grid::LeafGridView;
    GridView gridView = grid.leafGridView();
~~~

在网格视图上，我们再为`Taylor-Hood`元素设置函数空间基础。这很简单，就像

~~~C++
 using namespace Functions::BasisFactory;

 constexpr std::size_t p = 1; // Pressure order for Taylor-Hood

 auto taylorHoodBasis = makeBasis(
        gridView,
        composite(
            power<dim>(
                lagrange<p+1>(),
                blockedInterleaved()),
            lagrange<p>()
        ));
~~~


这种从`Lagrange`基的实例中构建`Taylor-Hood`基的方式已经在第10.3.2节讨论过了。这里使用的索引策略是`BlockedInterleaved`用于速度子树，`BlockedLexicographic`（默认）用于根。这导致了[Tab10.1]第2列中的索引方案，即速度自由度的索引为$(0, i, j)$，其中$i$为`Lagrange`节点，$j$为$\mathbb{R}^{d}$中的分量，而压力自由度的索引为$(1, i)$ 。

在能够组装`Stokes`系统的刚度矩阵之前，我们需要为线性代数挑选合适的数据结构。这些数据结构应该有一个与我们刚刚构建的`Taylor-Hood`基础所使用的多索引相匹配的阻塞结构。更具体地说，适当的向量容器将是一对向量，其中第一个向量的条目在$\mathbb{R}^{d}$中表示速度，第二个条目在$\mathbb{R}$中表示压力自由度。同样，矩阵必须由$2 \times 2$稀疏矩阵组成，其中$(0,0)$块的条目为$\mathbb{R}^{d \times d}$，$(0,1)$块的条目为$\mathbb{R}^{d \times 1}$。]，$(1,0)$-块有$\mathbb{R}^{1 \times d}$的条目，而$(1,1)$-块有$\mathbb{R}$的条目（如[Fig10.6]的右侧）。下面的代码设置了这种向量和矩阵类型。它使用了 `dune-istl` 的嵌套机制，但也可以使用其他线性代数库中的数据类型。


~~~C++
using VelocityVector = BlockVector<FieldVector<double,dim>>;
using PressureVector = BlockVector<double>;
using Vector = MultiTypeBlockVector<VelocityVector, PressureVector>;

using Matrix00 = BCRSMatrix<FieldMatrix<double,dim,dim>>;
using Matrix01 = BCRSMatrix<FieldMatrix<double,dim,1>>;
using Matrix10 = BCRSMatrix<FieldMatrix<double,1,dim>>;
using Matrix11 = BCRSMatrix<double>;
using MatrixRow0 = MultiTypeBlockVector<Matrix00, Matrix01>;
using MatrixRow1 = MultiTypeBlockVector<Matrix10, Matrix11>;
using Matrix = MultiTypeBlockMatrix<MatrixRow0,MatrixRow1>;
~~~


异构容器`MultiTypeBlockVector`和`MultiTypeBlockMatrix`分别在第$7.2.2$和$7.3.2$章中详细讨论。然而，必须强调的是，使用这种高级数据结构绝不是强制性的。正如在 $10.1 .4$ 和 $10.3 .2$ 章节中所详述的，使 `Taylor-Hood` 基础使用平面全局索引是微不足道的，它可以直接与 `std::vector` 等标准容器类型一起工作。

现在我们已经为矩阵和向量数据结构选择了$\mathrm{C}++$类型，我们可以实际组装这个系统了。组装右侧的向量rhs很容易，因为除了`Dirichlet`的边界数据（我们将在后面插入），它的所有条目都是零。一个具有正确类型和大小的全零向量是由以下几行设置的。

~~~C++
 Vector rhs;

 auto rhsBackend = Functions::istlVectorBackend(rhs);

 rhsBackend.resize(taylorHoodBasis);
 rhs = 0;
~~~


由`istlVectorBackend`返回的后端对象将`dune-functions`基础与`dune-istl`线性代数容器连接起来（7.2章）。特别是，它提供了对来自给定函数空间基树的整个层次的嵌套向量的方便调整。第337行一次性将整个向量填充为零，但请注意这实际上是一个`dune-istl`的特性。

为了获得刚度矩阵，我们首先创建一个正确类型的空矩阵对象。实际的装配是由一个单独的方法来完成的。

~~~C++
 Matrix stiffnessMatrix;
 assembleStokesMatrix(taylorHoodBasis, stiffnessMatrix);
~~~


由于矩阵组装是这个例子的核心部分，我们在介绍了`main`方法后，在下面详细解释。

假设现在我们在对象`stiffnessMatrix`中装配了正确的刚度矩阵。我们仍然需要修改线性系统以包括`Dirichlet`的边界信息。第一步，我们需要确定所有自由度的`Dirichlet`边界条件。为了存储这些信息，我们使用一个标志矢量，其结构与`VectorType`相同，并再次使用`ISTLVectorBackend`进行初始化。

~~~C++
 using VelocityBitVector = std::vector<std::array<char,dim> >;
 using PressureBitVector = std::vector<char>;
 using BitVector = TupleVector<VelocityBitVector, PressureBitVector>;

 BitVector isBoundary;

 auto isBoundaryBackend = Functions::istlVectorBackend(isBoundary);
 isBoundaryBackend.resize(taylorHoodBasis);

 using namespace Indices;
 for (auto&& b0i : isBoundary[_0])
 for (std::size_t j=0; j<b0i.size(); ++j)
 b0i[j] = false;
 std::fill(isBoundary[_1].begin(), isBoundary[_1].end(), false);
~~~


我们现在要标记`Dirichlet`边界上的所有速度自由度。在驱动腔的例子中，整个边界是`Dirichlet`边界。为了标记速度子树的边界自由度，请写出。

~~~C++
 Functions::forEachBoundaryDOF(
    Functions::subspaceBasis(taylorHoodBasis, _0),
    [&] (auto&& index) {
        isBoundaryBackend[index] = true;
    });
~~~



方便方法`forEachBoundaryDOF`（来自`dune/functions/functionspacebases/`中的文件`boundarydofs .hh`）实现了对与位于域边界的实体相关的所有自由度的循环。在这里，它只考虑速度自由度，因为我们用相应的子空间基础来调用它。尽管如此，`forEachBoundaryDOF`给出的全局索引对应于整个树，因此可以用来通过`ISTLVectorBackend`访问`isBoundary`容器。

现在我们已经确定了`Dirichlet`自由度的集合，我们定义一个实现实际`Dirichlet`值函数$\mathrm{g}$的方法，并将其点值写入右侧的向量rhs。

~~~C++
using Coordinate = GridView::Codim<0>::Geometry::GlobalCoordinate;
using VelocityRange = FieldVector<double, dim>;
auto &&g = [](Coordinate x)
{
    return VelocityRange{0.0, (x[0] < 1e-8) ? 1.0 : 0.0};
};

Functions::interpolate(Functions::subspaceBasis(taylorHoodBasis, _0),
                       rhs,
                       g,
                       isBoundary);
~~~


观察`dune-functions`接口如何允许插值lambda对象，这使得代码简短可读。同样，通过只传递相应的子空间基础，操作被限制在速度自由度上。作为最后一个参数的`isBoundary`矢量限制了插值只限于边界自由度。

硬度矩阵的修改是以一种更加手动的方式进行的。对于每个`Dirichlet`自由度，我们需要在相应的矩阵行中填上零，并在`diagonal`上写上1（2.1.4章）。下面的算法是通过在所有网格元素上循环，并对每个元素在所有`Dirichlet`自由度上循环来实现的。这比简单地在所有矩阵行上循环效率要低，但它可以避免为嵌套稀疏矩阵数据类型 `MatrixType` 实施迭代器。

~~~C++
auto localView = taylorHoodBasis.localView();
for (const auto &element : elements(gridView))
{
    localView.bind(element);
    for (size_t i = 0; i < localView.size(); ++i)
    {
        auto row = localView.index(i);
        // If row corresponds to a boundary entry,
        // modify it to be an identity matrix row.
        if (isBoundaryBackend[row])
            for (size_t j = 0; j < localView.size(); ++j)
            {
                auto col = localView.index(j);
                matrixEntry(stiffnessMatrix, row, col) = (i == j) ? 1 : 0;
            }
    }
}
~~~





对矩阵条目的访问需要一个类似于矢量后端的矩阵--一个转换层，将多索引转换为访问矩阵数据结构所需的正确指令序列。这样的后端编写起来更具挑战性，因为它需要同时处理行和列索引。在撰写本文时`dune-functions`并没有提供矩阵后端。相反，在第408行，示例代码使用了一个小的辅助方法`matrixEntry`，该方法是在示例文件中自己定义的。它比通用的矩阵后端简单得多，因为它是直接为`Stokes`问题的矩阵数据类型编写的。

~~~C++
template <class Matrix, class MultiIndex>
decltype(auto) matrixEntry(
    Matrix &matrix, const MultiIndex &row, const MultiIndex &col)
{
    using namespace Indices;
    if ((row[0] == 0) && (col[0] == 0))
        return matrix[_0][_0][row[1]][col[1]][row[2]][col[2]];
    if ((row[0] == 0) && (col[0] == 1))
        return matrix[_0][_1][row[1]][col[1]][row[2]][0];
    if ((row[0] == 1) && (col[0] == 0))
        return matrix[_1][_0][row[1]][col[1]][0][col[2]];
    return matrix[_1][_1][row[1]][col[1]];
}
~~~



请注意`MultiTypeBlockMatrix`的外部指数必须进行静态编码，因为不同的矩阵条目有不同的类型。内部矩阵可以直接使用运行时的整数来处理。

最后，我们可以解决这个线性系统。专用的 `Stokes` 求解器经常在某种Schur补数上操作，因此它们需要直接访问子矩阵 [^101] 。这可以通过本例中使用的嵌套矩阵类型来优雅地完成。然而，有效解决`Stokes`系统是一门艺术，我们不想在这里讨论。相反，我们使用`GMRES`求解器[^139]，完全没有任何预处理。众所周知，这可以收敛，尽管很慢。它的优点是只需几行就可以写出来。下面的代码显示了使用`dune-istl`求解线性方程组的典型方法，这与`dune-functions`完全不同。

~~~C++
// Initial iterate: Start from the rhs vector,
// that way the Dirichlet entries are already correct.
Vector x = rhs;

// Turn the matrix into a linear operator
MatrixAdapter<Matrix, Vector, Vector> stiffnessOperator(stiffnessMatrix);

// Fancy (but only) way to not have a preconditioner at all
Richardson<Vector, Vector> preconditioner(1.0);

// Construct the iterative solver
RestartedGMResSolver<Vector> solver(
    stiffnessOperator, // Operator to invert
    preconditioner,    // Preconditioner
    1e-10,             // Desired residual reduction factor
    500,               // Number of iterations between restarts,
    // here: no restarting
    500, // Maximum number of iterations
    2);  // Verbosity of the solver

// Object storing some statistics about the solving process
InverseOperatorResult statistics;

// Solve!
solver.apply(x, rhs, statistics);
~~~


观察一下`RestartedGMResSolver`对象是如何完全无视矩阵有嵌套结构的事实的。

一旦迭代求解器终止，其结果将被写入VTK文件。我们通过结合适当的系数向量和基子树来构造速度和压力的离散函数。

~~~C++
using VelocityRange = FieldVector<double, dim>;
using PressureRange = double;

auto velocityFunction = Functions::makeDiscreteGlobalBasisFunction<VelocityRange>(
    Functions::subspaceBasis(taylorHoodBasis, _0), x);
auto pressureFunction = Functions::makeDiscreteGlobalBasisFunction<PressureRange>(
    Functions::subspaceBasis(taylorHoodBasis, _1), x);
~~~



然后，我们把得到的速度写成一个矢量场，把得到的压力写成一个标量场。我们对网格进行两次取样，以得到二阶速度函数的近似值--目前`dune-grid`的`VTKWriter`类只写出片状线性函数。


~~~C++
SubsamplingVTKWriter<GridView> vtkWriter(
    gridView,
    refinementLevels(2));
vtkWriter.addVertexData(
    velocityFunction,
    VTK::FieldInfo("velocity", VTK::FieldInfo::Type::vector, dim));
vtkWriter.addVertexData(
    pressureFunction,
    VTK::FieldInfo("pressure", VTK::FieldInfo::Type::scalar, 1));
vtkWriter.write("stokes-taylorhood-result");
~~~


当运行时，这个程序产生一个名为 `stokes-taylorhood-result.vtu` 的文件。该文件可以在 `PARAVIEW` 中打开，结果看起来像 [Fig10.10] 中右边的图片。

\textbf{The Global Assembler}

现在我们已经涵盖了主方法，我们可以转向`Stokes`刚度矩阵的装配程序。我们从全局装配程序开始，它在主方法第342行中调用的`assembleStokesMatrix`方法中实现。全局装配器设置了矩阵模式，在所有元素上循环，并将`element stiffness matrices`累积到全局矩阵中。该方法的签名是

~~~C++
template<class Basis, class Matrix>
void assembleStokesMatrix(const Basis& basis, Matrix& matrix)
~~~



它得到的唯一参数是有限元基和要填充的矩阵。请注意，`Taylor-Hood`的基点在这里并不是硬性规定的，所以我们可以用不同的基点调用该方法。然而，毫不奇怪，`Stokes`问题的局部装配程序对基树结构做了相对严格的假设，所以这里没有什么实际的自由。理想情况下，全局装配器应该是完全通用的，所有关于当前空间和微分算子的知识都应该限制在局部装配器中。像`dune-pdelab`这样的实际离散化框架确实实现了这种分离，但是对于这里的例子，我们没有那么严格，以避免技术性问题。

`assembleStokesMatrix`方法的前几行设置了矩阵占用模式，并将所有矩阵条目初始化为零。

~~~C++
// Set matrix size and occupation pattern
setOccupationPattern(basis, matrix);

// Set all entries to zero
matrix = 0;
~~~


构建矩阵模式的方法`set0ccupationPattern`包含在示例文件本身中。对于每一个了解其他汇编代码的人来说，它是很容易理解的，因此我们省略了详细的描述。

接下来是实际的元素循环。我们首先从有限元基础请求一个`localView`对象。

~~~C++
auto localView = basis.localView();
~~~


之后开始对网格元素进行循环。对于每个元素，我们将`localView`对象与该元素绑定。从那时起，所有对本地视图的查询都将隐含地引用这个元素。

~~~C++
 for (const auto& element : elements(basis.gridView()))
 {
 // Bind the local FE basis view to the current element
 localView.bind(element);
~~~


然后我们创建元素刚度矩阵，并调用单独的方法`assembleElementStiffnessMatrix`来填充它。为了简单起见，代码使用密集的矩阵类型，即使先验地知道静止的`Stokes`矩阵不包含压力`diagonal`块中的条目。由于局部形状函数指数总是平坦的（第10.2.3章），一个没有嵌套的矩阵数据类型被用于元素刚度矩阵。

~~~C+++
 Dune::Matrix<double> elementMatrix;
 assembleElementStiffnessMatrix(localView, elementMatrix);
~~~


下面将详细讨论`assembleElementStiffnessMatrix`方法。除了`elementMatrix`之外，它只获得localView对象。前一个对象包含了所有必要的信息，以组装它所绑定的元素上的刚度矩阵。在调用`assembleElementStiffnessMatrix`后，`elementMatrix`对象包含当前元素的刚度矩阵。代码在元素刚度矩阵的条目上循环，并将它们添加到全局矩阵中。

~~~C++
for (size_t i = 0; i < elementMatrix.N(); i++)
{
    // The global index of the i-th local degree of freedom
    // of the current element
    auto row = localView.index(i);
    for (size_t j = 0; j < elementMatrix.M(); j++)
    {
        // The global index of the j-th local degree of freedom
        // of the current element
        auto col = localView.index(j);
        matrixEntry(matrix, row, col) += elementMatrix[i][j];
    }
}
~~~


第252行和258行返回的全局行和列索引的类型是一个多索引。它的长度是3，用于速度自由度，长度是2，用于压力自由度。第259行再次使用辅助函数`matrixEntry`来访问使用这些多索引的嵌套全局刚度矩阵。

尽管已知`Stokes`系统的右下角区块只包含0，但前面的循环还是写进了所有四个矩阵区块。一个更优化的代码版本可以完全不写右下角的子矩阵。

\textbf{The Local Assembler}

剩下的就是研究组装`element stiffness matrices`的方法。它的签名是

~~~C++
 template<class LocalView>
 void assembleElementStiffnessMatrix(const LocalView& localView,
 Matrix<double>& elementMatrix)
~~~


它只接收`Taylor-Hood`基的局部视图，预计将被绑定到一个元素，以及空元素矩阵。没有明确要求`LocalView`对象是`Taylor-Hood`基的局部视图，但在局部装配程序的各个部分都隐含了这个假设。`assembleElementStiffnessMatrix`方法的前几行收集了一些关于该方法要处理的元素的信息。特别是，它从`localView`对象中提取了元素本身，以及元素的尺寸和几何形状。

~~~C++
 using Element = typename LocalView::Element;
 const Element element = localView.element();

 constexpr int dim = Element::dimension;
 auto geometry = element.geometry();
~~~


接下来，元素刚度矩阵被初始化。`localView`对象知道它所绑定的元素的总自由度数，由于矩阵只有标量项，这就是矩阵行和列的正确数量。

~~~C++
 elementMatrix.setSize(localView.size(), localView.size());
 elementMatrix = 0; // Fills the entire matrix with zeros
~~~



最后，我们要求提供速度和压力的形状函数集。

~~~C++
 using namespace Indices;
 const auto& velocityLocalFiniteElement
    = localView.tree().child(_0,0).finiteElement();
 const auto& pressureLocalFiniteElement
    = localView.tree().child(_1).finiteElement();
~~~




第$60-63$行中返回的两个对象是`LocalFiniteElements`中的`dune-localfunctions`的意思。这些行也显示了`Taylor-Hood`基础的树状结构的作用。该表达式

~~~C++
localView.tree().child(_0,0)
~~~

返回根的第一个孩子的第一个孩子，即速度场的第一个分量的基础，和

~~~C++
localView.tree().child(_1)
~~~


返回压力空间的基础。由于树的根结合了两个不同的基，因此需要用`Dune::Indices`命名空间的静态标识符_0和1来指定其子节点。速度的内部节点结合了$d$倍的基数，因此可以用正常的整数0来指定其第一个子节点。这个本地`Stokes`组合器的特殊实现实际上是 "作弊"，因为它利用了所有速度分量使用相同基数的知识。因此，在第60行中只获取了速度子树的第一片叶子，然后用于所有组件。对每个分量单独使用`local finite elements`是很浪费的，因为同样的形状函数值和梯度要计算$d$次。

接下来，代码构建一个合适的正交规则并在正交点上循环。正交顺序的公式结合了关于元素类型、形状函数和微分算子的信息。它计算出最低的阶数，将`Stokes`方程的弱形式在立方体网格上精确积分。

~~~C++
 int order = 2*(dim*velocityLocalFiniteElement.localBasis().order()-1);
 const auto& quad = QuadratureRules<double,dim>::rule(element.type(), order);

 // Loop over all quadrature points
 for (const auto& quadPoint : quad)
 {
~~~



正交循环的开始与之前看到的较简单的局部汇编代码一样。首先，我们得到从参考元素到网格元素的映射$F$的反转置`Jacobian`，以及积分变换公式的`Jacobian`行列式。

~~~C++
 // The transposed inverse Jacobian of the map from the
 // reference element to the element
 const auto jacobianInverseTransposed
    = geometry.jacobianInverseTransposed(quadPoint.position());

 // The multiplicative factor in the integral transformation formula
 const auto integrationElement
    = geometry.integrationElement(quadPoint.position());
~~~


完成这些准备工作后，我们就可以组装刚度矩阵的第一部分，对应于速度-速度耦合。对于两个$d$值的速度基函数$\boldsymbol{\varphi}_{i}^{k}=\mathbf{e}_{k} \varphi_{i}$和$\boldsymbol{\varphi}_{j}^{l}=\mathbf{e}_{l} \varphi_{j}$，我们需要计算出

$$
a_{T}\left(\varphi_{i}^{k}, \varphi_{j}^{l}\right):=\int_{T} \nabla \varphi_{i}^{k} \nabla \varphi_{j}^{l} d x=\delta_{k l} \int_{T} \nabla \varphi_{i} \nabla \varphi_{j} d x
$$

在当前元素$T$上，其中$\varphi_{i}$和$\varphi_{j}$是相应的标量基函数，$\mathbf{e}_{k}, k=0, \ldots, d-1$是$\mathbb{R}^{d}$中的典范基向量。代码首先计算当前正交点的速度`shape functions`的导数，然后使用`jacobianInverseTransposed`中的矩阵将形状函数梯度转换为定义在网格元素上的实际基础函数的梯度。

~~~C++
 std::vector<FieldMatrix<double,1,dim> > referenceGradients;
 velocityLocalFiniteElement.localBasis().evaluateJacobian(
                                            quadPoint.position(),
                                            referenceGradients);

 // Compute the shape function gradients on the grid element
 std::vector<FieldVector<double,dim> > gradients(referenceGradients.size());
 for (size_t i=0; i<gradients.size(); i++)
 jacobianInverseTransposed.mv(referenceGradients[i][0], gradients[i]);
~~~



有了速度基函数梯度在手，我们就可以组装速度对刚度矩阵的贡献。

~~~C++
 for (size_t i=0; i<velocityLocalFiniteElement.size(); i++)
 for (size_t j=0; j<velocityLocalFiniteElement.size(); j++ )
 for (size_t k=0; k<dim; k++)
 {
    size_t row = localView.tree().child(_0,k).localIndex(i);
    size_t col = localView.tree().child(_0,k).localIndex(j);
    elementMatrix[row][col] += ( gradients[i] * gradients[j] )
                        * quadPoint.weight() * integrationElement;
 }
~~~



这里值得注意的是第109-110行，对于有限元基树的两个给定的`shape functions`，获得用于索引元素刚度矩阵的平面编号。表达式`child (_0, k)`为速度基的第$\mathrm{k}$个分量挑出树叶。循环变量$i$和$j$在这个集合中的`shape functions`上运行，并且

~~~C++
localView.tree().child(_0,k).localIndex(i);
~~~

返回$i^{th}$形状函数在该元素上的所有`shape functions`基础集合中的相应标量索引。这就是第10.1.5节的局部索引$\iota_{\left.\Lambda\right|_{T}}^{\text {local }}(\cdot)$。第112行然后用两个梯度$\nabla \varphi_{i}$和$\nabla \varphi_{j}$的正确加权乘积来更新相应的（标量）元素矩阵条目。

一旦理解了这一部分，计算速度-压力耦合项就很容易了。对于一个给定的速度基函数$\varphi_{i}^{k}$和压力基函数$\theta_{j}$，我们需要计算出

$$
\begin{aligned}
b_{T}\left(\boldsymbol{\varphi}_{i}^{k}, \theta_{j}\right) &:=\int_{T}\left(\operatorname{div} \boldsymbol{\varphi}_{i}^{k}\right) \theta_{j} d x \\
&=\int_{T} \sum_{l=0}^{d-1} \frac{\partial\left(\boldsymbol{\varphi}_{i}^{k}\right)_{l}}{\partial x_{l}} \theta_{j} d x=\int_{T} \frac{\partial \varphi_{i}}{\partial x_{k}} \theta_{j} d x=\int_{T}\left(\nabla \varphi_{i}\right)_{k} \theta_{j} d x
\end{aligned}
$$


在代码的这一点上，当前正交点的$\nabla \varphi_{i}$的值已经被计算出来，但$\theta_{i}$的值仍然未知。所有$i$的值都由以下两行评估。

~~~C++
 std::vector<FieldVector<double,1> > pressureValues;
 pressureLocalFiniteElement
    .localBasis().evaluateFunction(quadPoint.position(),pressureValues)
~~~


那么，双线性形式$b_{T}(\cdot, \cdot)$的实际矩阵装配是。

~~~C++
for (size_t i = 0; i < velocityLocalFiniteElement.size(); i++)
    for (size_t j = 0; j < pressureLocalFiniteElement.size(); j++)
        for (size_t k = 0; k < dim; k++)
        {
            size_t vIndex = localView.tree().child(_0, k).localIndex(i);
            size_t pIndex = localView.tree().child(_1).localIndex(j);

            auto value = gradients[i][k] * pressureValues[j] * quadPoint.weight() * integrationElement;
            elementMatrix[vIndex][pIndex] += value;
            elementMatrix[pIndex][vIndex] += value;
        }
~~~


第133行再次计算$\boldsymbol{\varphi}_{i}^{k}$的平面局部索引，第134行计算$\theta_{j}$的索引（记住，$_{ } 1$表示压力基）。最后，第$136-139$行计算积分值$\left(\nabla \varphi_{i}\right)_{k} \theta_{j}$，并将结果项添加到矩阵中。至此，斯托克斯问题的局部装配程序的实现就结束了。

\section{Discretizing Partial Differential Equations with `dune-pdelab`}

到目前为止，我们所描述的DUNE的所有部分在本质上都是相当低级的。本书第二部分所描述的DUNE核心模块的功能对人们编写自己的有限元或有限体积代码有很大的帮助；然而，如果不进行大量的额外编码，它们不足以实际解决甚至是简单的PDE。这一点可以从第$3.3$章中的代码例子中看出，该章仅使用核心模块和`dune-functions`就可以解决`Poisson`方程。尽管这是一个最容易实现的PDE例子，它仍然需要大约200行的源代码。

缺少的部分是一个使用`dune-functions`模块提供的函数空间来组装刚度矩阵和载荷向量的库。这样的功能比之前所介绍的功能具有更高的抽象水平。一个通用的装配框架将使用前面章节中描述的网格、形状函数和函数空间，它将使人们只需少量的额外编码就能解决简单的PDE问题。

`dune-pdelab`模块就是这样一个框架。它非常强大和灵活，能够处理大范围的离散空间和边界条件。同时，它非常高效，灵活性带来的开销被保持在最低水平 [^20] 。主要是，`dune-pdelab`实现了有限元问题的集合器。这些问题可以是线性的，也可以是非线性的，它们可以包括来自网格元素和元素面的贡献。模块中包含了一些常见偏微分方程的集合器，但也很容易编写新的集合器。为解决由此产生的代数问题，提供了几个非线性求解器。

作为其中的一部分，`dune-pdelab`实现了一个有限元函数空间的接口，它在`dune-functions`的基础上增加了一些附加功能。例如，当一个函数空间被定义在分布于多个进程的网格上时，它自动处理数据交换和通信。对于由于局部网格适应性而导致的网格变化也是如此。在网格细化和粗化过程中的数据保存，在第5.9.2章中手工实现时有点繁琐，现在对用户来说已经完全透明。`dune-pdelab`模块还提供了一个灵活的机制来对自由度施加线性约束。最明显的用途是`Dirichlet`边界值，如$11.3$章所解释的，但它也允许更有挑战性的事情，如在不符合要求的网格上构造符合要求的`Lagrange`有限元空间。最后，`dune-pdelab`引入了一组不同的线性代数后端，允许在编译时选择不同的实现方式。默认的后端使用`dune-istl`中的线性代数（第7章），但也可以使用其他如EIGEN[^87]。

`dune-pdelab`模块是一个庞大而强大的项目。由于规模的原因，我们不得不在本书中省略它的重要方面。例如，我们将不讨论分布式网格、实例问题或超越单纯的`Dirichlet`约束空间。对这些主题感兴趣的读者需要查阅在线资源。

\subsection{Example: Linear Reaction-Diffusion Equation}

我们在本章开始时展示了如何使用 `dune-pdelab` 解决一个简单的边界值问题。这个例子程序使用三个不同的符合和不符合的有限元空间来解决一个线性反应-扩散方程。代数问题使用带有`SSOR`预处理程序的CG求解器来解决。该例子的完整源代码包含在一个文件中，打印在附录B.11中。本文电子版的读者也可以通过点击边缘的图标访问该文件。

`dune-pdelab`中的所有代码都包含在嵌套的命名空间 `Dune::PDELab` 中。本章中的示例程序包含使用命名空间 `Dune` ;的行，在顶部，只给出前缀 `PDELab::explicitly` 。与其他DUNE模块不同，`dune-pdelab` 允许通过一个头文件`dune/pdelab.hh` 包含整个模块。

我们简单说明一下这个例子问题。设$\Omega$是$\mathbb{R}^{d}$中的一个域。线性反应-扩散方程的`Neumann`问题是找到一个函数$u: \Omega \rightarrow \mathbb{R}$，使得

\begin{equation}
\begin{aligned}
-\Delta u+c u &=f & & \text { in } \Omega \\
\langle\nabla u, \mathbf{n}\rangle &=0 & & \text { on } \partial \Omega
\end{aligned}
\label{11.1}
\end{equation}

对于给定的函数 $f, c: \Omega \rightarrow \mathbb{R}$ 。它是一般椭圆问题 $(2.1)$ 的一个特例，有 $\mathcal{A}(x, u, \nabla u)=\nabla u$ 和 $h(u)=c u$ 。如果$f$足够平滑，并且$c(x) \geq c_{0}$对某些$c_{0}>0$来说是个即期问题，那么根据`Lax-Milgram`定理[^37]，这个问题在$H^{1}(\Omega)$中有唯一解。

对于这个例子的实现，我们选择$\Omega$为单位平方$(0,1) \times(0,1)$，$c \equiv 10$，体积项$f: \Omega \rightarrow \mathbb{R}$等于$-10$，在$\Omega$中心周围半径为$1 / 4$的圆上，其他地方为10。该领域用一个由$8 \times 8$四边形元素组成的结构化网格进行离散。我们对该方程进行了三次求解。两次使用不同阶数的`Lagrangian`有限元，一次使用不符合要求的`Rannacher-Turek`元（8.3.1章）。这证明了从一个有限元离散化到另一个有限元离散化是多么容易。

该程序由三部分组成：一个参数类ReactionDiffusionProblem，实现了$f$和$c$函数，一个方法solveReactionDiffusionProblem，接收一个函数空间并进行模拟，还有一个主方法，针对三个不同空间调用三次。主方法像往常一样开始初始化潜在的MPI安装，并使用`YaspGrid`实现设置$8 \times 8$结构化网格。


~~~C++
int main(int argc, char *argv[])
{
    // Set up MPI, if available
    MPIHelper::instance(argc, argv);

    // Create a structured grid
    constexpr int dim = 2;
    using Grid = YaspGrid<dim>;
    FieldVector<double, dim> bbox = {1.0, 1.0};
    std::array<int, dim> elements = {8, 8};
    Grid grid(bbox, elements);

    using GridView = Grid::LeafGridView;
    GridView gridView = grid.leafGridView();

~~~


`YaspGrid` 网格管理器已在第 $5.10.2$ 章中详细讨论过。

在这之后，代码从dunefunctions模块中构建了三个不同的基础对象，并对每个对象调用了方法`solveReactionDiffusionProblem`。

~~~C++
// Solve boundary value problem using first-order Lagrange elements
using Q1Basis = Functions::LagrangeBasis<GridView, 1>;
auto q1Basis = std::make_shared<Q1Basis>(gridView);

solveReactionDiffusionProblem(q1Basis,
                              "pdelab-linear-reaction-diffusion-result-q1",
                              9); // Average number of matrix entries
// per row

// Solve boundary value problem using second-order Lagrange elements
using Q2Basis = Functions::LagrangeBasis<GridView, 2>;
auto q2Basis = std::make_shared<Q2Basis>(gridView);

solveReactionDiffusionProblem(q2Basis,
                              "pdelab-linear-reaction-diffusion-result-q2",
                              25); // Average number of matrix entries
// per row

// Solve boundary value problem using Rannacher-Turek elements
using RannacherTurekBasis = Functions::RannacherTurekBasis<GridView>;
auto rannacherTurekBasis = std::make_shared<RannacherTurekBasis>(gridView);

solveReactionDiffusionProblem(rannacherTurekBasis,
                              "pdelab-linear-reaction-diffusion-result-rt",
                              7); // Average number of matrix entries
// per row
}
~~~

方法`solveReactionDiffusionProblem`进行实际计算。除了有限元基础，它还得到两个参数。一个是用于结果文件的文件名。另一个是刚度矩阵每行的预期平均条目数。在这个例子中，`dune-pdelab`汇编器使用了`BCRSMatrix`稀疏矩阵的实现及其隐式矩阵构建模式（在第7.3.2章中解释），它需要先验地猜测每行非零矩阵条目的数量。自动计算这些是相当昂贵的，因此`dune-pdelab`将这项任务卸载给了用户。经过这几行，我们已经到达了主方法的终点。

现在我们来看看方法`solveReactionDiffusionProblem`，它完成了主要的工作。我们会注意到，这个方法很短，只有不到40行的代码。该方法的签名是

~~~C++
template <class Basis>
void solveReactionDiffusionProblem(std::shared_ptr<Basis> basis,
                                   std::string filename,
                                   int averageNumberOfEntriesPerMatrixRow)
{
~~~



上面已经解释了方法参数的含义。

该方法所做的第一件事是从作为基参数给定的基中构造一个`dune-pdelab`风格的离散函数空间。正如本章介绍中提到的，`dune-pdelab`对有限元基和空间有自己的一套抽象概念，虽然它们有很多共同的想法，但它们的实现大多是独立的。`dune-pdelab`的核心概念是网格函数空间，它大致相当于`dune-functions`的函数空间基。在本书的例子中，我们使用适配器类`Experimental::GridFunctionSpace`，它允许使用`dune-functions`的基数作为网格函数空间的实现。

~~~C++
using GridView = typename Basis::GridView;
using VectorBackend = PDELab::ISTL::VectorBackend<>;

using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                  VectorBackend,
                                                                  PDELab::NoConstraints>;

GridFunctionSpace gridFunctionSpace(basis);
~~~


与`dune-functions`基础相比，`GridFunctionSpace`的`dune-pdelab`提供了几个额外的功能，这需要两个额外的模板参数。VectorBackend类型选择用于矢量系数的容器数据类型。第49行的特殊选择选择了`dune-istl`中的`BlockVector`类（详见$11.4 .1$章）。第53行的第三个模板参数`PDELab::NoConstraints`指定没有额外的代数约束（如`Dirichlet`边界条件）作用于空间。

现在我们有了一个函数空间，我们可以设置有限元组装器了。它由三个类组成。第一个是一个叫做`ReactionDiffusionProblem`的小型辅助类，实现了系数函数$f$和$c$ 。它被定义在文件的顶部附近，而且非常简短。

~~~C++
template <class GridView>
struct ReactionDiffusionProblem
    : public PDELab::ConvectionDiffusionModelProblem<GridView, double>
{
    template <typename Element, typename Coord>
    auto f(const Element &element, const Coord &xi) const
    {
        const Coord center = Coord(0.5);
        auto distanceToCenter = (element.geometry().global(xi) - center).two_norm();
        return (distanceToCenter <= 0.25) ? -10.0 : 10.0;
    }

    template <typename Element, typename Coord>
    auto c(const Element &element, const Coord &xi) const
    {
        return 10.0;
    }
};
~~~


这个类中的每个方法都接受一个元素和这个元素的局部坐标的位置，并返回那里的相应函数值。代码构建了这样一个参数类，然后用它来构建一个类型为`ConvectionDiffusionFEM`的对象，这就是实际的元素集合器。

~~~C++
using Problem = ReactionDiffusionProblem<GridView>;
Problem reactionDiffusionProblem;
using LocalOperator = PDELab::ConvectionDiffusionFEM<Problem,
                                                     typename GridFunctionSpace::Traits::
                                                         FiniteElementMap>;
LocalOperator localOperator(reactionDiffusionProblem);
~~~



在 `dune-pdelab` 术语中，这样的元素组合器被称为 `local operator` ，这解释了行 $62-66$ 中使用的命名。被称为`PDELab::ConvectionDiffusionFEM`的算子（来自文件夹`dune/pdelab/localoperator/`中的文件`convectiondiffusionfem.hh`）集合了一个更一般的线性问题的`element stiffness matrices`，该问题涉及对流项以及反应和扩散。这里对参数函数的特殊选择使其成为测试问题（11.1）的元素集合器。

第三步也是最后一步是构建一个全局装配程序，它在网格元素上循环，调用`local operator`以获得元素矩阵，并将它们累积到全局刚度矩阵中。

~~~C++
using MatrixBackend = PDELab::ISTL::BCRSMatrixBackend<>;
MatrixBackend matrixBackend(averageNumberOfEntriesPerMatrixRow);
using GridOperator = PDELab::GridOperator<GridFunctionSpace, // Trial function space
                                          GridFunctionSpace, // Test function space
                                          LocalOperator,     // Element assembler
                                          MatrixBackend,     // Data structure
                                          // for the stiffness matrix
                                          double, // Number type for
                                          // solution vector entries
                                          double, // Number type for
                                          // residual vector entries
                                          double>; // Number type for
// stiffness matrix entries

GridOperator gridOperator(gridFunctionSpace,
                          gridFunctionSpace,
                          localOperator,
                          matrixBackend);

~~~


前两行选择矩阵后端，即用于刚度矩阵的矩阵数据结构。选择`ISTL::BCRSMatrixBackend`是选择`dune-istl`模块中的`BCRSMatrix`类；其他选择见第$11.4$章。

然后，代码构建了一个类型为`PDELab::GridOperator`的对象。在`dune-pdelab`模块中，词格运算符是全局汇编器的同义词，而`Grid0perator`类是这种汇编器的标准实现。它被配置为一个相当长的模板和运行时参数列表。前两个参数是试验和测试函数的有限元空间。请注意，这两个参数必须分别指定。在大多数情况下，它们将是相同的两个空间，但是对于像`Petrov-Galerkin`方法（见，例如[^63]）或误差估计器（第11.5.2章）这样的高级应用，可以指定两个独立的空间。

接下来的两个参数是元素集合器和矩阵后端，这两个参数我们刚刚设置好了。最后，我们可以选择三种数字类型。它们分别用于解向量的条目（`the domain`）、`residual`向量（`the range`）和刚度矩阵的条目。在大多数情况下，`double`是这里的适当选择。

最后，我们可以解决代数系统。我们将使用一个共轭梯度求解器，以`SSOR`方法为前提条件 [^138] 。首先，我们需要一个矢量来保存迭代结果。由于`dune-pdelab`对用户隐藏了线性代数的实现，我们没有直接构建一个向量数据类型。相反，我们向 `GridFunctionSpace` 的向量后端查询适当的向量类型。

~~~C++
 using VectorContainer = PDELab::Backend::Vector<GridFunctionSpace,double>;
 VectorContainer u(gridFunctionSpace,0.0); // Initial value
~~~

由于我们在行`dune-istl`中选择了$49, \mathrm{u}$的后端，将是$7.2$章中讨论的`BlockVector`类型的一个对象（围绕着一个包装类型）。第二个构造函数参数将所有条目初始化为零。

然后代码设置并调用预设的CG求解器。这是一个三步程序。

~~~C++
using LinearSolverBackend = PDELab::ISTLBackend_SEQ_CG_SSOR;
LinearSolverBackend linearSolverBackend(5000, 2);

using LinearProblemSolver = PDELab::StationaryLinearProblemSolver<GridOperator,
                                                                  LinearSolverBackend,
                                                                  VectorContainer>;

LinearProblemSolver linearProblemSolver(gridOperator,
                                        linearSolverBackend,
                                        u,
                                        1e-10);
linearProblemSolver.apply();

~~~



首先，我们从`dune-istl`模块构建实际的求解器。它也只能通过线性代数后端访问。然后，这个求解器被交给一个类型为 `StationaryLinearProblemSolver` 的对象。这个类将求解器与汇编器连接起来。它首先使用 `grid0perator` 对象来组装代数问题，然后使用 `linearSolverBackend` 对象来解决它，从 $u$ 的初始迭代开始。这整个过程是由第111行的方法apply的调用触发的。在这个调用之后，u包含了最终的迭代结果。剩下的就是把它写到一个文件中，以便以后进行后期处理和可视化。下面几行将$\mathrm{u}$的内容写到VTK文件中，然后可以使用`PARAVIEW`等查看。


~~~C++
// Make a discrete function from the FE basis and the coefficient vector
auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
    *basis,
    PDELab::Backend::native(u));

// We need to subsample, because the dune-grid VTKWriter
// cannot natively display second-order functions.
SubsamplingVTKWriter<GridView> vtkWriter(basis->gridView(),
                                         refinementLevels(4));
vtkWriter.addVertexData(uFunction,
                        VTK::FieldInfo("u",
                                       VTK::FieldInfo::Type::scalar,
                                       1));
vtkWriter.write(filename);
~~~




代码首先从`dune-functions`基和系数向量中构造一个离散函数。然后这个函数可以交给`SubsamplingVTKWriter`，如第10.7章中所述。我们需要对结果函数进行子采样，因为来自`dune-grid`的`VTKWriter`类目前只支持编写分片（多）线性函数。

VTK的编写代码主要使用`dune-grid`和dunefunctions模块的功能。唯一的 `dune-pdelab` 特定部分是对 `PDELab::Backend::native(u)` 的调用，它提供了对线性代数后端底层向量数据结构的引用（在这种情况下是 `BlockVector` ）。

启动后，该程序将产生以下输出。


~~~C++
=== matrix assembly (max) 0.00287509 s
=== residual assembly (max) 0.0014412 s
=== solving (reduction: 1e-10) === Dune::IterativeSolver
Iter Defect Rate
0 1.03754
1 0.498995 0.48094
2 0.0309844 0.0620935
3 0.00108314 0.0349576
4 9.55854e-05 0.0882486
5 5.97994e-06 0.0625612
6 9.76342e-07 0.16327
7 1.16108e-08 0.0118921
8 1.281e-09 0.110329
9 4.06776e-11 0.0317545
=== rate=0.0697759, T=0.00437401, TIT=0.000486001, IT=9
0.00441099 s
[...]
~~~


这里打印的部分报告了使用一阶有限元进行的模拟，后面是另外两个空间的类似输出块。这些输出是不言自明的。我们看到CG求解器的迭代列表，给出了迭代数、当前缺陷（残余）规范和缺陷减少率。请注意，一旦缺陷规范下降到初始缺陷规范的$10^{-10}$倍以下，迭代就会按照要求停止。中间穿插了模拟过程中不同部分的墙时测量。

程序将为`Lagrange`元素结果写三个文件，分别称为`pdelab-linear-reaction-diffusionresult-q1.vtu`和`pdelab-linear-reaction-diffusion-result-q2.vtu`，为使用`Rannacher-Turek`元素的模拟写三个文件。  [Fig11.1] 在 `PARAVIEW` 中显示了他们的可视化。可以看出，这三者都近似于相同的解函数，但三个试验空间之间的差异是明显可见的。二阶`Lagrange`方法给出了比一阶方法更平滑的近似值。在第三张图片中，元素边界的不连续点清晰可见，这是`Rannacher-Turek`空间的特点。


\subsection{Implementing Element Assemblers}

前面的例子使用了一个作为 `dune-pdelab` 的一部分随时可用的本地汇编程序。尽管 `dune-pdelab` 在 `dune/pdelab/localoperator` 目录中提供了大量这样的汇编器，但许多用户迟早会想写自己的汇编器。这就是本章的主题。

我们首先在$11.2 .1$和11.2.2章中解释了`residual`的表述，这是`dune-pdelab`看待偏微分方程的方式。然后，第$11.2 .3$章将通过解释`Local0perator`接口类来介绍实现。第11.2.4章中的第一个完整的例子将展示如何实现和使用本地汇编器来处理$p$ -拉普拉斯问题的反应项。其余两节将解释如何装配骨架和边界项，并通过第二个完整的例子来演示实现非连续加尔金（DG）方法。

\subsubsection{The Residual Formulation}

`dune-pdelab`模块对偏微分方程有一种特殊的观察方式。它专注于方程的残差。为了解释这一点，我们简要地重温一下第 $2.1$ 章中的通用椭圆模型问题。我们将更多地关注非线性问题，因为至少就汇编而言，`dune-pdelab`将所有问题都视为非线性问题。



设$\Omega$是$\mathbb{R}^{d}$的一个开放的有界子集，$f: \Omega \rightarrow \mathbb{R}$是一个具有足够平稳性的给定函数。此外，假设$\mathcal{A}: \Omega \times \mathbb{R} \times \mathbb{R}^{d} \rightarrow \mathbb{R}^{d}$是一个作用于$\Omega$中的位置、点值和一阶导数的函数，而$h: \mathbb{R} \rightarrow \mathbb{R}$是一个被称为反应项的特定函数。我们寻找一个函数$u: \Omega \rightarrow \mathbb{R}$来解决这个方程

\begin{equation}
-\operatorname{div} \mathcal{A}(x, u, \nabla u)+h(u)=f \quad \text { in } \Omega
\label{11.2a}
\end{equation}

受制于同质的`Neumann`边界条件

\begin{equation}
\langle\mathcal{A}(x, u, \nabla u), \mathbf{n}\rangle=0 \quad \text { on } \partial \Omega
\label{11.2b}
\end{equation}

对`Dirichlet`边界条件的处理，特意推迟到第\ref{11.3}章。

这个问题的弱式表述与第2.1节中的方法相同。将\ref{11.2a}与$H^{1}=H^{1}(\Omega)$中的测试函数$v$相乘，对$\Omega$进行积分，并使用`Green`的特性，得到

\begin{equation}
\int_{\Omega} \mathcal{A}(x, u, \nabla u) \nabla v d x+\int_{\Omega} h(u) v d x=\int_{\Omega} f v d x \quad \text { for all } v \in H^{1}
\label{11.3}
\end{equation}

我们将其简写为

\begin{equation}
a(u, v)=l(v) \quad \forall v \in H^{1}
\label{11.4}
\end{equation}

其中

$$
a(u, v):=\int_{\Omega} \mathcal{A}(x, u, \nabla u) \nabla v d x+\int_{\Omega} h(u) v d x
$$

和

$$
l(v):=\int_{\Omega} f v d x
$$

这两种形式在$v$中都是线性的，但$a(\cdot, \cdot)$在其第一个参数中可能是非线性的。为简单起见，我们假设$\mathcal{A}, h, f$是这样的：弱问题\ref{11.4}在$H^{1}$中有至少一个解。

\ref{11.4}是弱椭圆模型问题的教科书版本，而`dune-pdelab`的重点是`residual formulation` 。介绍一下残差形式

$$
r(v, w):=a(v, w)-l(w)
$$

定义为函数 $v, w \in H^{1}$ 。它的第一个参数是非线性的，但第二个参数是线性的。使用`residual`的形式，弱问题\ref{11.3}显然可以被改写为

\begin{equation}
\text { Find } u \in H^{1}: \quad r(u, v)=0 \quad \text { for all } v \in H^{1}
\label{11.5}
\end{equation}

这就是原始边界值问题的`residual formulation`。

我们现在想计算\ref{11.5}的（其中一个）解的有限元近似值。为此，我们首先引入两个有限元空间$U_{h}$和$V_{h}$，它们都是


近似于 `Sobolev` 空间 $H^{1}$ 。我们将在 $U_{h}$ 中寻找解决方案，但在 $V_{h}$ 中使用测试函数。在许多应用中，$U_{h}$和$V_{h}$将是同一个空间；然而，`dune-pdelab`也迎合了它们不同的方法，例如`Petrov-Galerkin`方法[^63] 。为了简单起见，我们在下文中假设这两个空间具有相同的维度 $n$ 。

如果有限元空间是符合的，即$U_{h} \subset H^{1}$和$V_{h} \subset H^{1}$，那么离散的`residual`问题是由$U_{h}$和$V_{h}$代替`residual`公式\ref{11.5}得出的。

$$
\text { Find } u_{h} \in U_{h}: r\left(u_{h}, v_{h}\right)=0 \quad \text { for all } v_{h} \in V_{h}
$$

然而，`dune-pdelab`更普遍地允许不符合要求的空间，即近似于`Sobolev`空间的空间$U_{h}, V_{h}$，而不是它的一个子集。对于这种情况，我们需要引入一个新的`residual`形式

$$
r_{h}(\cdot, \cdot): U_{h} \times V_{h} \rightarrow \mathbb{R}
$$

以适当的方式近似于$r(\cdot, \cdot)$。在下文中，我们总是将$r_{h}(\cdot, \cdot)$写成离散的`residual`形式，即使空间$U_{h}, V_{h}$是符合的。

\textbf{Assumption} $11.1$ 所有相关的边界值问题都可以写成以下形式

\begin{equation}
\text { Find } u_{h} \in U_{h}: \quad r_{h}\left(u_{h}, v_{h}\right)=0 \quad \forall v_{h} \in V_{h}
\label{11.6}
\end{equation}

对于合适的空间$U_{h}, V_{h}$，和形式$r_{h}(\cdot, \cdot)$。

这个假设当然排除了许多有趣的问题，但它是`dune-pdelab`设计的核心。我们总是假设$r_{h}(\cdot, \cdot)$在其第二个参数中是线性的，但在第一个参数中可能是非线性的。最后，假设`residual`问题\ref{11.6}至少有一个解。

使用$U_{h}$和$V_{h}$的基$\left\{\phi_{i}\right\}_{i=0}^{n-1}$，我们可以推导出离散`residual`方程\ref{11.6}的代数表述。将$v_{h}$中的\ref{11.6}替换为其基础表示$\sum_{i=0}^{n-1} v_{i} \theta_{i}$，我们得到

$$
r_{h}\left(u_{h}, \sum_{i=0}^{n-1} v_{i} \theta_{i}\right)=\sum_{i=0}^{n-1} v_{i} r_{h}\left(u_{h}, \theta_{i}\right)=0 \quad \forall v_{h} \in V_{h}
$$

这相当于

$$
r_{h}\left(u_{h}, \theta_{i}\right)=0 \quad \forall i=0, \ldots, n-1
$$

为了制定代数残差，让$\bar{u} \in \mathbb{R}^{n}$是$u_{h}$相对于基$\left\{\phi_{i}\right\}_{i=0}^{n-1}$的系数向量。我们定义一个映射$\mathcal{R}: \mathbb{R}^{n} \rightarrow \mathbb{R}^{n}$，即

$$
(\mathcal{R}(\bar{u}))_{i}:=r_{h}\left(u_{h}, \theta_{i}\right) \quad \text { for all } i=0, \ldots, n-1
$$



那么代数`residual`问题就是

\begin{equation}
\text { Find } \bar{u} \in \mathbb{R}^{n}: \quad \mathcal{R}(\bar{u})=0 \in \mathbb{R}^{n}
\label{11.7}
\end{equation}

这个非线性代数方程组的可解性直接来自于 \ref{11.6} 的假定可解性。

默认情况下，`dune-pdelab`另外假设代数`residual` $\mathcal{R}$对其参数有微弱的依赖性，并提供阻尼`Newton`方法[^51] [^130]作为解决`residual`方程\ref{11.7} 的标准方式。对于这样的`Newton`方法，`Jacobian`矩阵$\nabla \mathcal{R}(\bar{u})$定义为

$$
(\nabla \mathcal{R}(\bar{u}))_{i, j}:=\frac{\partial(\mathcal{R}(\bar{u}))_{i}}{\partial \bar{u}_{j}}
$$

需要对每个 `Newton` 迭代 $\bar{u}$ 进行计算。

如果微分算子$\mathcal{A}$和反应项$h$都是线性的，那么`residual`采取简单的形式

\begin{equation}
\mathcal{R}(\bar{u})=A \bar{u}-b
\label{11.8}
\end{equation}

其中$A$和$b$是第2.1章中定义的刚度矩阵和载荷向量。注意，这是线性方程的`residual`的负数，因为它通常在教科书中被定义。从这样的残差中，刚度矩阵可以被检索为$\mathcal{R}$的`Jacobian`，而$b$是$\mathcal{R}$在$0 \in \mathbb{R}^{n}$的负值。

\subsubsection{Assembling Element Residuals and Their Derivatives}

在第$2.1.3$章中，我们已经解释了有限元问题的代数式是如何从它们的离散对应物组装起来的。它表明，在实践中，这是通过对每个网格元素的弱方程的限制，以及对结果的适当求和来实现的。这些条款涉及对元素和元素边界的积分。这促使了以下的假设。

\textbf{Assumption} $11.2$ `residual`形式$r_{h}(\cdot, \cdot)$可以被加法拆分为元素、骨架和边界条款

\begin{equation}
r_{h}\left(u_{h}, v_{h}\right)=\sum_{T \in \mathcal{T}} r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right)+\sum_{\gamma^{\mathrm{i}} \in \mathcal{F}} r_{h, \gamma^{\mathrm{i}}}^{\mathrm{skel}}\left(u_{h}, v_{h}\right)+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B}} r_{h, \gamma^{\mathrm{b}}}^{\mathrm{bnd}}\left(u_{h}, v_{h}\right)
\label{11.9}
\end{equation}

其中，骨架$\mathcal{F}$是不在域边界上的面（即$d-1$-维元素面）的集合，$\mathcal{B}$是$\partial \Omega .^{3}$上的面集合。




因此，`dune-pdelab`中的代数问题是通过添加元素、骨架和边界项来组装的。不是所有的离散化都有这三个项，当然，第`residual`章的例子$11.1$形式只有元素项。在开始时，我们将重点放在这些元素项上，而将其他项推迟到$11.2 .5$章。

根据结构，$r_{h}(\cdot, \cdot)$的元素、骨架和边界贡献在第二个参数$v_{h}$中必须是线性的。只有当原始PDE问题是线性的，它们在第一个参数$u_{h}$中才是线性的。`dune-pdelab`模块假定这些形式是局部的，即$r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right)$只取决于元素$u_{h}$和$v_{h}$的值$T$，以及内部面项$r_{h, \gamma^{i}}^{\text {skel }}\left(u_{h}, v_{h}\right)$和边界面项$r_{h, \gamma^{\mathrm{b}}}^{\mathrm{bnd}}\left(u_{h}, v_{h}\right)$将只取决于$u_{h}$和$v_{h}$在$\gamma^{\mathrm{i}}$和$\gamma^{\mathrm{b}}$邻近元素上的值。这几乎被所有的有限元问题所满足，因为`residual`项由域的子集上的积分组成。例如，`residual`的形式是

$$
r_{h}\left(u_{h}, v_{h}\right):=\int_{\Omega}\left[\mathcal{A}\left(x, u_{h}, \nabla u_{h}\right) \nabla v_{h}+h\left(u_{h}\right) v_{h}\right] d x-\int_{\Omega} f v_{h} d x
$$

对应于\ref{11.4}，可以分割成一个元素积分的总和

$$
r_{h}\left(u_{h}, v_{h}\right)=\sum_{T \in \mathcal{T}} r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right)
$$

与

$$
r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right):=\int_{T}\left(\mathcal{A}\left(x, u_{h}, \nabla u_{h}\right) \nabla v_{h}+h\left(u_{h}\right) v_{h}\right) d x-\int_{T} f v_{h} d x
$$

这实际上只取决于$u_{h}$和$v_{h}$对$T$的限制。第11.2.6章将给出一个涉及骨架和边界项的例子。

`residual`形式的本地化特征促使我们构建相应的代数限制。让$T$是一个网格元素，并称$\bar{u}_{T} \in \mathbb{R}^{n_{T}}$为与元素$T$相关的自由度的向量，即$r_{h, T}^{\text {vol }}$所依赖的自由度。然后我们可以定义典型的限制算子

$$
\mathbf{R}_{T}: \mathbb{R}^{n} \rightarrow \mathbb{R}^{n_{T}}, \quad \mathbf{R}_{T}: \bar{u} \mapsto \bar{u}_{T}
$$

它的转置$\mathbf{R}_{T}^{T}$通过填充零将元素自由度的向量扩展为全局向量。同样，对于任何骨架面$\gamma^{\mathrm{i}}$，我们引入算子$\mathbf{R}_{T_{\text {in }}\left(\gamma^{\mathrm{i}}\right), T_{\text {out }}\left(\gamma^{i}\right)}$来限制$\gamma^{\mathrm{i}}$的两个相邻元素的自由度，以及限制支持边界面$\gamma^{\mathrm{b}}$的元素的自由度的算子$\mathbf{R}_{T\left(\gamma^{\mathrm{b}}\right)}$ 。有了这些算子，整体残差$\mathcal{R}$的组装可以写成三个循环

\begin{equation}
\begin{aligned}
\mathcal{R}(\bar{u}) &=\sum_{T \in \mathcal{T}}\left(\mathbf{R}_{T}\right)^{T} \mathcal{R}_{T}^{\mathrm{vol}}\left(\mathbf{R}_{T} \bar{u}\right) \\
&+\sum_{\gamma^{\mathbf{i}} \in \mathcal{F}}\left(\mathbf{R}_{T_{\text {in }}\left(\gamma^{\mathrm{i}}\right), T_{\text {out }}\left(\gamma^{\mathrm{i}}\right)}\right)^{T} \mathcal{R}_{\gamma^{\mathrm{i}}}^{\mathrm{skel}}\left(\mathbf{R}_{T_{\mathrm{in}}\left(\gamma^{\mathrm{i}}\right), T_{\mathrm{out}}\left(\gamma^{\mathrm{i}}\right)}\right) \\
&+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B}}\left(\mathbf{R}_{T\left(\gamma^{\mathrm{b}}\right)}\right)^{T} \mathcal{R}_{\gamma^{\mathrm{b}}}^{\mathrm{bnd}}\left(\mathbf{R}_{T\left(\gamma^{\mathrm{b}}\right)}\right)
\end{aligned}
\label{11.10}
\end{equation}

其中$\mathcal{R}_{T}^{\text {vol }}, \mathcal{R}_{\gamma^{1}}^{\text {skel }}, \mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}$是代数`residual`运算符对单个元素或元素对的自然限制。请注意，这种方法与第$2.1$章略有不同，在该章中，汇编只使用了元素的单一循环。

同样，$\mathcal{R}$在$\bar{u}$的`Jacobian`可以从三个环路的局部贡献中计算出来。

\begin{equation}
\begin{aligned}
\nabla \mathcal{R}(\bar{u}) &=\sum_{T \in \mathcal{T}}\left(\mathbf{R}_{T}\right)^{T} \nabla \mathcal{R}_{T}^{\mathrm{vol}}\left(\mathbf{R}_{T} \bar{u}\right) \mathbf{R}_{T} \\
&+\sum_{\gamma^{\mathrm{i}} \in \mathcal{F}}\left(\mathbf{R}_{T_{\mathrm{in}}\left(\gamma^{\mathrm{i}}\right), T_{\mathrm{out}}\left(\gamma^{\mathrm{i}}\right)}\right)^{T} \nabla \mathcal{R}_{\gamma^{\mathrm{i}}}^{\mathrm{skel}}\left(\mathbf{R}_{T_{\mathrm{in}}\left(\gamma^{\mathrm{i}}\right), T_{\mathrm{out}}\left(\gamma^{\mathrm{i}}\right)} \bar{u}\right) \mathbf{R}_{T_{\mathrm{in}}\left(\gamma^{\mathrm{i}}\right), T_{\mathrm{out}}\left(\gamma^{\mathrm{i}}\right)} \\
&+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B}}\left(\mathbf{R}_{T\left(\gamma^{\mathrm{b}}\right)}\right)^{T} \nabla \mathcal{R}_{\gamma^{\mathrm{b}}}^{\mathrm{bnd}}\left(\mathbf{R}_{T\left(\gamma^{\mathrm{b}}\right)} \bar{u}\right) \mathbf{R}_{T\left(\gamma^{\mathrm{b}}\right)}
\end{aligned}
\label{11.11}
\end{equation}

由于限制运算符独立于PDE，用户只需要提供局部残差$\mathcal{R}_{T}^{\text {vol }}, \mathcal{R}_{\gamma^{1}}^{\text {skel }}, \mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}$连同其`Jacobian`s$\nabla \mathcal{R}_{T}^{\text {vol }}, \nabla \mathcal{R}_{\gamma^{1}}^{\text {skel }}$$\nabla \mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}$来实现一个新的`dune-pdelab`汇编器。

\subsubsection{Implementing Element Assemblers: The `Local0perator` Interface}

局部残差$\mathcal{R}_{T}, \mathcal{R}_{\gamma^{\mathrm{i}}}$和$\mathcal{R}_{\gamma^{\mathrm{b}}}$以及它们的`Jacobian`s编码了用牛顿或类牛顿方法解决特定离散化PDE所需的所有信息。在 `dune-pdelab` 中，这些术语是由接口类 `Local0perator` 的实现来组合的。给定一个网格元素$T$、一个骨架交点$\gamma^{\mathrm{i}}$或一个边界交点$\gamma^{\mathrm{b}}$，以及与$T$或交点相邻的元素相关的自由度$\gamma^{\mathrm{i}}$和$\gamma^{\mathrm{b}}$，`Local0perator`对象分别实现了局部`residual`项$\mathcal{R}_{T}^{\text {vol }}, \mathcal{R}_{\gamma^{1}}^{\text {skel }}$和$\mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}$，以及它们的`Jacobian`s$\nabla \mathcal{R}_{T}^{\text {vol }}$、$\nabla \mathcal{R}_{\gamma^{1}}^{\text {skel }}$和$\nabla \mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}$ 。它被全局汇编器的通用 `dune-pdelab` 实现所使用，它被称为 `Grid0perator` 。该接口类是

~~~C++
template<class GridFunctionSpaceU, class GridFunctionSpaceV,
        class LocalOperator,
        class MatrixBackend,
        class DomainNumberType,
        class RangeNumberType,
        class JacobianNumberType>
class GridOperator
~~~


其中`GridFunctionSpaceU`和`GridFunctionSpaceV`分别是离散函数空间$U_{h}$和$V_{h}$的实现，`Local0perator`是元素组装器，`MatrixBackend`是稀疏矩阵的实现（第11.4章）。其余三个参数`DomainNumberType`、`RangeNumberType`和`JacobianNumberType`分别是用于原始向量和对偶向量（即迭代数和残差数）的系数以及刚度矩阵条目的数字类型。`Grid0perator`类型的对象是直接调用构造函数构建的

~~~C++
GridOperator(const GridFunctionSpaceU & gfsu, const GridFunctionSpaceV & gfsv,
            LocalOperator& localOperator,
            const MatrixBackend& matrixBackend = MatrixBackend())
~~~



`Grid0perator`对象在所有元素、骨架和边界交叉点上循环，并通过调用每个元素上的局部算子来组装全局`residual`$\mathcal{R}(\bar{u})$和`Jacobian`$\nabla \mathcal{R}(\bar{u}), \bar{u} \in \mathbb{R}^{n}$，并分别通过使用\ref{11.10}和\ref{11.11}将结果拼凑起来。这种分离反映了第$2.1.3$章中解释的有限元组装过程的数学表述，并将其扩展到包括骨架条款。

虽然`Grid0perator`类是一个固定的实现，用户永远不需要修改，但编写新的LocalOperator实现是经常发生的。这样的实现必须使用`duck typing`技术（第4.4.2章），也就是说，它们必须提供`Local0perator`类所要求的方法和类型，但编译器不会直接检查其合规性。LocalOperator接口使用了`duck typing`的一个更灵活的变体：一些方法是可选的，只有在设置了某些标志后才需要。

任何 `Local0perator` 接口的实现都必须继承自 `PDELab::LocalOperatorDefaultFlags` 类，它注入了某些基础设施。为了使全局操作者设置矩阵模式，它也必须继承自 `PDELab::FullVolumePattern` 。如果`Local0perator`也装配了骨架或边界贡献，那么该类可能也必须继承自`PDELab::FullSkeletonPattern`和`PDELab::FullBoundary pattern`，。此外，实现还必须设置标记

~~~C++
static const bool doPatternVolume
static const bool doPatternSkeleton
static const bool doPatternBoundary
~~~

如果使用相应的`Jacobian`矩阵模式条目。

主界面包括三种用于局部元素、骨架和边界贡献的方法，以及三种用于相应雅各布的方法。还有更多的可选方法，但这些方法将不会在本书中讨论。[Tab11.1]给出了方法的清单。由于历史原因，计算残差的方法被称为α方法。


为了控制一个方法是否被实施，`Local0perator`必须导出一个`bool`标志的列表。

~~~C++
static const bool doAlphaVolume
static const bool doAlphaSkeleton
static const bool doAlphaBoundary
~~~



每个标志代表一对α/jacobian方法。如果对应于某对方法的标志是`false`，这些方法永远不会被调用，甚至可以从本地运算符的实现中完全省略。如果`doAlphaSkeleton`和`doAlphaBoundary`标志都是假的，则跳过通过交叉点的迭代。

为了组装全局`residual`或`Jacobian`，`Grid0perator`对象对网格的元素进行迭代。对于每个元素，它将调用适当的体积方法。然后它将遍历元素的交点，并在交点上调用适当的`skeleton`或`boundary`方法。在这一章和随后的例子中，我们重点讨论体积项。边界和骨架项，例如`Neumann`边界条件和DG方法需要的，将在第11.2.5章处理。

第一个与元素相关的方法是`alpha_volume`，它计算$\mathcal{R}_{T}^{\text {vol }}$，即从拆分\ref{11.9}得出的项$r_{h, T}^{\text {vol }}$的代数形式。`alpha_volume`方法的签名是

~~~C++
template <class EntityGeometry, class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void `alpha_volume`(const EntityGeometry &entityGeometry,
                  const LocalFunctionSpaceU &localFunctionSpaceU,
                  const Vector &x,
                  const LocalFunctionSpaceV &localFunctionSpaceV,
                  Residual &r) const
~~~



该方法有五个参数，它们的类型都由相应的成员模板参数决定。第一个，`entityGeometry`，代表网格元素，其类型是来自`dune-grid`接口的`Entity`类的包装器（第5.3章）。参数`localFunctionSpaceU`和`localFunctionSpaceV`分别是用于试验和测试空间的有限元。当`alpha_volume`被调用时，类型`LocalFunctionSpaceU`和`LocalFunctionSpaceV`将是一个名为`PDELab::LocalFunctionSpace`的类的实例。在不进一步讨论细节的情况下，该类型的对象有一个方法

~~~C++
const Traits::FiniteElementType& finiteElement() const
~~~

它返回一个 `LocalFiniteElement` 章意义上的类 $8$ 。这就是如何获得实际的形状函数--参见第8章关于如何使用它们的细节。

第三个方法参数 $x$ 存储局部函数的系数 $\mathbf{R}_{T} \bar{u}$ 。第五个参数 $r$ 接收残差。当方法`alpha_volume`被调用时，容器$r$已经有了正确的长度，并且数值被初始化。预计`alpha_volume`方法`add`对r的内容的局部贡献。这样一来，将几个局部运算符的实现结合到一个总和运算符上就更容易了。

$x$和$r$的精确类型是由`dune-pdelab`提供的专用向量类，用于容纳单个元素的有限元空间的自由度。这些容器的数据布局是由元素上的`shape functions`集合决定的。因此，访问单个条目需要将`localFunctionSpaceU`和`localFunctionSpaceV`对象一起传递。对象 $x$ 的类型是 `PDELab::LocalVector` 。访问$i^{th}$形状函数的条目是由方法提供的

~~~C++
template <class LocalFunctionSpace>
LocalVector::value_type &operator()(
    const LocalFunctionSpace &localFunctionSpace,
    size_type i)
~~~


另一方面，类型 `Residual` 是一个 `WeightedVectorAccumulationView` 。它的目的是只允许写。其主要方法是

~~~C++
template <class LocalFunctionSpace>
void accumulate(const LocalFunctionSpace &localFunctionSpace,
                size_type i,
                value_type v)
~~~



其中在局部函数空间$i^{th}$的自由度上增加了值$\mathrm{v}$。

为了获得 `Jacobian` $\nabla \mathcal{R}_{T}^{\text {vol }}$ ， `LocalOperator` 类有一个方法叫做 `jacobian_volume` 。它的签名是

~~~C++
template <class EntityGeometry, class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Jacobian>
void `jacobian_volume`(const EntityGeometry &entityGeometry,
                     const LocalFunctionSpaceU &localFunctionSpaceU,
                     const Vector &x,
                     const LocalFunctionSpaceV &localFunctionSpaceV,
                     Jacobian &jacobian) const
~~~


签名与`alpha_volume`方法非常相似；唯一不同的是最后一个参数，现在是一个矩阵而不是一个矢量。同样，在调用`jacobian_volume`之前，`Grid0perator`对象正确地初始化了这个矩阵对象，并且必须向它添加值。像`residual`矢量一样，它有一个专门的方法来做这件事。

~~~C++
template <class LocalFunctionSpaceU, class LocalFunctionSpaceV>
void accumulate(const LocalFunctionSpaceV &localFunctionSpaceV, size_type i,
                const LocalFunctionSpaceU &localFunctionSpaceU, size_type j,
                value_type v)
~~~


与它的残差向量对应方法类似，调用这个方法将$\mathrm{v}$的内容添加到由索引$i$和$j$指定的矩阵条目中。由于行和列的编号分别由本地测试空间和试验空间决定，相应的`localFunctionSpaceV`和`localFunctionSpaceU`对象也必须被传递。

\subsubsection{Example: The `p-Laplace` Equation with a Reaction Term}

我们现在给出一个完整的例子，演示`volume`方法在`Local0perator`实现中的使用。它为带有反应项的`p-Laplace`方程实现了一个局部汇编器，并用`Newton`的方法解决离散方程。完整的示例代码印在附录B.12中，可以通过页边的图标获得。

设$\Omega$为一域，$f: \Omega \rightarrow \mathbb{R}$适当地平滑。标量函数`p-Laplace`的$u$方程为[^91][^118] 。

$$
-\operatorname{div}\left(|\nabla u|^{p-2} \nabla u\right)=f
$$

指数$p$是一个严格大于1的固定实数。显然，`p-Laplace`方程是椭圆模型问题\ref{11.2a}的一个特例，有

$$
\mathcal{A}(x, u, \nabla u)=|\nabla u|^{p-2} \nabla u
$$

和$h(u)=0$ 。因此，它的弱形式是

$$
\text { Find } u \in W^{1, p}: \quad \int_{\Omega}|\nabla u|^{p-2}\langle\nabla u, \nabla v\rangle d x=\int_{\Omega} f v d x \quad \forall v \in W^{1, p}
$$

其中，$W^{1, p}$是基于$p$的一阶`Sobolev`空间的可变形函数[^37][^162] 。

除非至少在边界的一部分施加`Dirichlet`边界条件，否则`p-Laplace`方程是不能被很好地构成的。由于我们想在第11.3章之前避免这样的边界条件，所以我们通过增加一个线性反应项来强制执行良好构象。我们得到弱的例子问题

$$
\int_{\Omega}|\nabla u|^{p-2}\langle\nabla u, \nabla v\rangle d x+\int_{\Omega} c u v d x=\int_{\Omega} f v d x \quad \forall v \in W^{1, p}
$$

有一个额外的系数函数 $c: \Omega \rightarrow \mathbb{R}$ 。





这就是本章要解决的例子问题。对于$\Omega$我们选择单位平方$(0,1)^{2}$ 。反应函数$c$被设定为常数100，对于体积项$f$我们选择

$$
f(x)= \begin{cases}100 & \text { if }\|x-(0.5,0.5)\| \leq 0.25 \\ 0 & \text { otherwise }\end{cases}
$$

如[Fig11.2]中的说明。

然后我们用结构化的$8 \times 8$网格对$\Omega$进行离散化，也在[Fig11.2]中显示。作为有限元空间$U_{h}$和$V_{h}$我们选择二阶`Lagrange`空间。带有反应项的`p-Laplace`方程的离散`residual`是

$$
r_{h}\left(u_{h}, v_{h}\right)=\int_{\Omega}\left|\nabla u_{h}\right|^{p-2}\left\langle\nabla u_{h}, \nabla v_{h}\right\rangle d x+\int_{\Omega} c u_{h} v_{h} d x-\int_{\Omega} f v_{h} d x
$$

对于任何 $u_{h} \in U_{h}$ 和 $v_{h} \in V_{h}$ 。在假设$11.2$的意义上，它可以被分割为

\begin{equation}
r_{h}\left(u_{h}, v_{h}\right)=\sum_{T \in \mathcal{T}} r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right)
\label{11.12}
\end{equation}

与

$$
r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right)=\int_{T}\left|\nabla u_{h}\right|^{p-2}\left\langle\nabla u_{h}, \nabla v_{h}\right\rangle d x+\int_{T} c u_{h} v_{h} d x-\int_{T} f v_{h} d x
$$

局部化形式\ref{11.12}包含体积项，但没有骨架或边界项。相应地，我们将在代码中看到方法`alpha_volume`和`jacobian_volume`，但没有其他方法。

\textbf{The `main` Method}

在这些准备工作之后，让我们开始讨论实际的代码。该程序文件包含一个`PLaplaceLocalOperator`类和一个`main`方法。像往常一样，`main`方法开始设置`MPIHelper`实例并创建一个网格。

~~~C++
 int main(int argc, char *argv[])
 {
  // Initialize MPI
  MPIHelper::instance(argc,argv);
 
  constexpr int dim = 2;
  using Grid = YaspGrid<dim>;
  FieldVector<double,dim> upper = {1.0, 1.0};
  std::array<int,dim> elements = {8, 8};
  Grid grid(upper,elements);
 
  using GridView = Grid::LeafGridView;
  GridView gridView = grid.leafGridView();
~~~


`Yaspgrid`的实现被用于具有$8 \times 8$四边形元素的结构化网格。

接下来是有限元空间的设置。正如公布的那样，代码对试验和测试函数使用二阶`Lagrange`有限元空间，但其他阶数也同样适用。

~~~C++
using Basis = Functions::LagrangeBasis<GridView, 2>;
auto basis = std::make_shared<Basis>(gridView);

using VectorBackend = PDELab::ISTL::VectorBackend<>;

using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                  VectorBackend,
                                                                  PDELab::NoConstraints>;

GridFunctionSpace gridFunctionSpace(basis);
~~~



这与我们在第 $11.1$ 章中看到的线性例子没有任何区别。

现在我们创建有限元集合器。首先，我们实现两个系数函数 $f$ 和 $c$ 。由于它们很简单，我们把它们存储在lambda表达式中。由于我们假设$p$的顺序是固定的，我们简单地将其存储为一个数字。

~~~C++
auto f = [](const FieldVector<double, dim> &x)
{
    FieldVector<double, dim> center(0.5);
    auto distanceToCenter = (x - center).two_norm();
    return (distanceToCenter <= 0.25) ? 100 : 0;
};

auto c = [](const FieldVector<double, dim> &x)
{
    return 100.0;
};

double p = 5.0;
~~~






请注意，与第$11.1$章中的例子不同，我们不需要遵循`dune-pdelab`中的系数函数的接口，因此我们可以用更简单的方式实现它们，将全局点坐标作为参数。

然后我们构造一个`PLaplaceLocal0perator`类型的对象，把指数$p$和两个系数函数交给它。

~~~C++
 using LocalOperator = PLaplaceLocalOperator<dim>;
 LocalOperator localOperator(p,f,c);
~~~


`PLaplaceLocalOperator`将`residual`形式的`p-Laplace`方程集合在一个元素上。它在示例文件的顶部实现，并将在下面进行解释。`LocalOperator`对象反过来被交给一个 `Grid0perator` 类型的对象。

~~~C++
using MatrixBackend = PDELab::ISTL::BCRSMatrixBackend<>;
MatrixBackend matrixBackend(25); // 25: Expected average number of entries
// per matrix row

using GridOperator = PDELab::GridOperator<GridFunctionSpace, // Trial function space
                                          GridFunctionSpace, // Test function space
                                          LocalOperator,     // Element assembler
                                          MatrixBackend,     // Data structure
                                          // for the stiffness matrix
                                          double, // Number type for
                                          // solution vector entries
                                          double, // Number type for
                                          // residual vector entries
                                          double>; // Number type for
// stiffness matrix entries

GridOperator gridOperator(gridFunctionSpace,
                          gridFunctionSpace,
                          localOperator,
                          matrixBackend);
~~~



下面，`Grid0perator`对象将在所有元素上循环，它将集合全局残差的元素贡献。这里所有的模板和构造函数参数还是和第11.1章中的线性情况一样。

现在全局汇编器已经设置好了，我们可以构建代数求解器。我们使用`Newton`方法，该方法在`dune-pdelab`中已准备好使用。`Newton`求解器需要一个线性求解器和一个初始迭代器，我们先设置好这些。

~~~C++
using LinearSolverBackend = PDELab::ISTLBackend_SEQ_CG_SSOR;
LinearSolverBackend linearSolverBackend(5000, // Max. number of iterations
                                        2);   // Verbosity level

// Make vector of coefficients
using U = PDELab::Backend::Vector<GridFunctionSpace, double>;
U u(gridFunctionSpace, 0.0); // Initial iterate
~~~


这又和第11.1章中的线性例子一样。然后我们可以构造并调用实际的`Newton`求解器。

~~~C++
PDELab::NewtonMethod<GridOperator, LinearSolverBackend>
    newtonMethod(gridOperator,
                 linearSolverBackend);

newtonMethod.setReduction(1e-10); // Requested reduction
// of the residual
newtonMethod.setMinLinearReduction(1e-4); // Minimal reduction of the
// inner linear solver
newtonMethod.setVerbosityLevel(2); // Solver verbosity
newtonMethod.apply(u);
~~~



第$358-362$行设置参数，控制`Newton`求解器和内部线性迭代求解器的终止标准。最后一行进行实际求解。在每次迭代中，`newtonMethod`对象将调用`grid0perator`以获得`residual`及其`Jacobian` 。`grid0perator`反过来将调用`local0perator`以获得元素贡献。然后，线性求解器（linearSolver）对象将被用来解决所产生的系统。最后，使用 [^89] 中描述的线搜索策略应用计算出的修正。

此时，非线性代数问题已经得到解决，我们需要做的就是将结果写入文件中。这方面的代码直接取自第11.1章的线性反应-扩散例子。

~~~C++
// Make a discrete function from the finite element basis
// and the coefficient vector
auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
    *basis,
    PDELab::Backend::native(u));

// We need to subsample, because the dune-grid VTKWriter
// cannot natively display second-order functions.
SubsamplingVTKWriter<GridView> vtkwriter(gridView, refinementLevels(2));
vtkwriter.addVertexData(uFunction,
                        VTK::FieldInfo("u",
                                       VTK::FieldInfo::Type::scalar,
                                       1));
vtkwriter.write("pdelab-p-laplace-result");
~~~



我们再次使用子采样VTK写入器，因为从版本$2.7$开始，`dune-grid`并不支持写入二阶有限元。请再次注意，`dune-pdelab`根本不参与编写VTK文件。

\textbf{The `Local0perator` Implementation}

我们现在讨论这个例子的主要部分：局部运算符的实现。带有继承性和布尔标志的类签名是。

~~~C++

template <int dim>
class PLaplaceLocalOperator : public PDELab::LocalOperatorDefaultFlags,
                              public PDELab::FullVolumePattern
{
public:
    // Pattern assembly flags
    static const bool doPatternVolume = true;
    // Residual assembly flags
    static const bool doAlphaVolume = true;
~~~


该类以网格尺寸dim为模板，并继承于标准基类 `PDELab::LocalOperatorDefaultFlags` 。此外，继承自`PDELab::FullVolumePattern`的代码用于设置正确的矩阵稀疏度模式。两个bool标志向`Grid0perator`发出信号，这个局部运算符只实现`alpha_volume`和`jacobian_volume`方法。在这个简单的例子中，不需要其他的方法。

接下来是订单$p$和系数函数$f$和$c$的数据成员，以及单一构造函数。

~~~C++
// The order of the p-Laplace term
const double p_;

// Source term
std::function<double(const FieldVector<double, dim> &)> f_;

// Reaction term
std::function<double(const FieldVector<double, dim> &)> c_;

PLaplaceLocalOperator(double p,
                      const std::function<double(const FieldVector<double, dim> &)> &f,
                      const std::function<double(const FieldVector<double, dim> &)> &c)
    : p_(p),
      f_(f),
      c_(c)
{}
~~~


注意，$\mathrm{p}$是一个常数，但$\mathrm{f}$和c可以是一般的函数对象。这些函数对象将在作为`FieldVector <double, dim>`类型对象的全局坐标中被评估--对于每个元素定义的系数函数，可以使用`dune-functions`模块中的`DiscreteGlobalBasisFunction`类（第10.6章）。

`LocalOperator`实现的核心是方法 `alpha_volume` 和 `jacobian_volume` 。对于一个给定的网格元素 $T$ ，方法 `alpha_volume` 计算出

\begin{equation}
\left(\mathcal{R}_{T}\left(u_{h}\right)\right)_{i}=\int_{T}\left|\nabla u_{h}\right|^{p-2}\left\langle\nabla u_{h}, \nabla \theta_{i}\right\rangle d x+\int_{T} c u_{h} \theta_{i} d x-\int_{T} f \theta_{i} d x
\label{11.13}
\end{equation}

为这个元素上的所有`shape functions` $\theta_{0}, \ldots, \theta_{n_{T}-1}$的测试空间。该方法`alpha_volume`具有第11.2.3章中讨论的签名，并以几个初始类型声明开始。

~~~C++
template <class EntityGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void alpha_volume(const EntityGeometry &entityGeometry,
                  const LocalFunctionSpaceU &localFunctionSpaceU,
                  const Vector &x,
                  const LocalFunctionSpaceV &localFunctionSpaceV,
                  Residual &residual) const
{
    // Extract types of shape function values and gradients
    using TrialFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
    using TestFE = typename LocalFunctionSpaceV::Traits::FiniteElementType;
    using LocalBasisU = typename TrialFE::Traits::LocalBasisType;
    using LocalBasisV = typename TestFE::Traits::LocalBasisType;
    using RangeU = typename LocalBasisU::Traits::RangeType;
    using RangeV = typename LocalBasisV::Traits::RangeType;
    using GradientU = typename LocalBasisU::Traits::JacobianType;
    using GradientV = typename LocalBasisV::Traits::JacobianType;
~~~


然后，它为试验和测试函数值以及试验和测试函数梯度构建数组，包括本地（即在参考元素上）和转换到网格元素$T$ 。

~~~C++
std::vector<RangeU> phi(localFunctionSpaceU.size());
std::vector<RangeV> theta(localFunctionSpaceV.size());

std::vector<GradientU> localGradPhi(localFunctionSpaceU.size());
std::vector<GradientV> localGradTheta(localFunctionSpaceV.size());

std::vector<GradientU> gradPhi(localFunctionSpaceU.size());
std::vector<GradientV> gradTheta(localFunctionSpaceV.size());
~~~


这个例子很细致地将试用函数$\left\{\phi_{i}\right\}$和测试函数$\left\{\theta_{i}\right\}$正确地分开。因此，对于试验和测试基数不同的情况，汇编器将组装出正确的矩阵。对于已知两个基数相同的常见情况，这使得代码的长度和速度超过了需要。不过我们还是以这种方式来写本章的所有例子，因为它更符合实现和`dune-pdelab`接口背后的数学原理。真正的实现会希望检查出相同的基数，并单独处理这种情况。接下来是正交循环的开始。正交规则是由`dune-geometry`模块提供的，在第9章中有解释。

~~~C++
int intOrder = (localFunctionSpaceU.finiteElement().localBasis().order() - 1) * (p_ - 1) + (localFunctionSpaceV.finiteElement().localBasis().order() - 1);
const auto &quadRule = QuadratureRules<double, dim>::rule(entityGeometry.entity().type(),
                                                          intOrder);
for (const auto &quadPoint : quadRule)
{
~~~



整合顺序是通过结合试验和测试形状函数的顺序来计算的，以获得适合于`residual`表达的顺序 \ref{11.13} 。

然后代码评估了在当前正交点上的定理和测试`shape functions` $\phi_{i}$ 和 $\theta_{i}$ , $i=0, \ldots n_{T}-1$ 的值。它还评估了相应的梯度。然后通过与$\nabla F^{-T}$左乘，将这些坐标从参考元素坐标转换为世界坐标，其中$F$是映射参考元素$F: T_{\mathrm{ref}} \rightarrow T$到当前网格元素$T$的地图`Jacobian` 。详见第2.1.3章。

~~~C++
// Evaluate basis functions on reference element
localFunctionSpaceU.finiteElement().localBasis().evaluateFunction(quadPoint.position(), phi);
localFunctionSpaceV.finiteElement().localBasis().evaluateFunction(quadPoint.position(), theta);

// Evaluate gradient of basis functions on reference element
localFunctionSpaceU.finiteElement().localBasis().evaluateJacobian(quadPoint.position(), localGradPhi);
localFunctionSpaceV.finiteElement().localBasis().evaluateJacobian(quadPoint.position(), localGradTheta);

// Transform gradients from reference element to grid element
const auto jacInvTransp = entityGeometry.geometry()
                              .jacobianInverseTransposed(quadPoint.position());

for (std::size_t i = 0; i < localFunctionSpaceU.size(); i++)
    jacInvTransp.mv(localGradPhi[i][0], gradPhi[i][0]);

for (std::size_t i = 0; i < localFunctionSpaceV.size(); i++)
    jacInvTransp.mv(localGradTheta[i][0], gradTheta[i][0]);
~~~



回顾第8.2.1章，`Jacobian`s的`shape functions`通常是矩阵，如果`shape functions`是标量值，则只有一行。在上面的转换代码中，这些行必须被视为向量，这解释了额外的[^0]索引。

接下来的几行将分别计算当前正交点的$u_{h}$和$\nabla u_{h}$的值，通过线性组合方法参数$x$中给出的$u_{h}$的系数以及形状函数值和导数。

~~~C++
// Compute u at integration point
RangeU u = 0;
for (std::size_t i = 0; i < localFunctionSpaceU.size(); ++i)
    u += x(localFunctionSpaceU, i) * phi[i];

// Compute gradient of u
GradientU gradU = 0;
for (std::size_t i = 0; i < localFunctionSpaceU.size(); ++i)
    gradU.axpy(x(localFunctionSpaceU, i), gradPhi[i]);
~~~



这里可以看出，$\mathrm{x}$不是一个标准的容器。查询其$i^{th}$条目需要将局部形状函数集与数字i一起交出。`LocalOperator`代码和容器实现之间的这一额外层次对于形成树状结构的有限元基是需要的，正如第$10.1$章所介绍的那样。请注意，变量`gradU`又是矩阵类型的，只有单行。使用`gradU`作为矢量的代码将使用一个额外的[^0]索引来访问该行。

最后，一个短循环计算出当前正交点的实际`residual`条目贡献。该代码实际上实现了$\left(\left|\nabla u_{h}\right|^{2}\right)^{\frac{1}{2}(p-2)}$而不是$\left|\nabla u_{h}\right|^{p-2}$，以避免在$\left|\nabla u_{h}\right|$的表达式中出现昂贵的平方根。

整合
 $$
\left|\nabla u_{h}\right|^{(p-2)}\left\langle\nabla u_{h}, \nabla \theta_{i}\right\rangle+c u_{h} \theta_{i}-f \theta_{i}

$$

~~~C++
auto globalPos = entityGeometry.geometry().global(quadPoint.position());
auto factor = quadPoint.weight() * entityGeometry.geometry()
                                       .integrationElement(quadPoint.position());

for (std::size_t i = 0; i < localFunctionSpaceV.size(); ++i)
{
    auto value = (std::pow(gradU[0].two_norm2(), 
                0.5 * (p_ - 2)) * (gradU[0] * gradTheta[i][0]) 
              + c_(globalPos) * u * theta[i] 
              - f_(globalPos) * theta[i]) * factor;
    residual.accumulate(localFunctionSpaceV, i, value);
}

~~~



与输入系数容器$\mathrm{x}$类似，输出容器`residual`也不是一个普通的数组。为了给$i^{th}$条目添加一个数字调用值，需要使用第159行的`accumulate`调用。这种额外的间接性允许支持形成树的有限元基（第10.1章）。关于`alpha_volume`方法的讨论到此结束。



`jacobian_volume`方法实现了切线矩阵$\nabla \mathcal{R}_{T}\left(\mathbf{R}_{T} \bar{u}\right)$，其条目为

\begin{equation}
\begin{aligned}
\left(\nabla \mathcal{R}_{T}\left(\mathbf{R}_{T} \bar{u}\right)\right)_{i, j}=& \frac{\partial\left(\mathcal{R}_{T}\left(\mathbf{R}_{T} \bar{u}\right)\right)_{i}}{\partial\left(\mathbf{R}_{T} \bar{u}\right)_{j}} \\
=& \int_{T}\left[\frac{p-2}{2}\left(\left|\nabla u_{h}\right|^{2}\right)^{\frac{p-2}{2}-1} \cdot \frac{\partial}{\partial\left(\mathbf{R}_{T} \bar{u}\right)_{j}}\left|\nabla u_{h}\right|^{2} \cdot\left\langle\nabla u_{h}, \nabla \theta_{i}\right\rangle\right.\\
&\left.\quad+\left|\nabla u_{h}\right|^{p-2} \cdot\left\langle\nabla \phi_{j}, \nabla \theta_{i}\right\rangle\right] d x \\
& \quad+\int_{T} c \theta_{i} \phi_{j} d x \\
=& \int_{T}\left[(p-2)\left|\nabla u_{h}\right|^{p-4} \cdot\left\langle\nabla u_{h}, \nabla \phi_{j}\right\rangle \cdot\left\langle\nabla u_{h}, \nabla \theta_{i}\right\rangle\right.\\
& \\
& \\
&+\int_{T} c \theta_{i} \phi_{j} d x
\end{aligned}
\label{11.14}
\end{equation}

其中，我们使用了

$$
\frac{\partial}{\partial\left(\mathbf{R}_{T} \bar{u}\right)_{j}}\left|\nabla u_{h}\right|^{2}=2 \sum_{l=0}^{d-1} \sum_{k=0}^{n_{T}-1} \bar{u}_{k} \frac{\partial \phi_{k}}{\partial x_{l}} \frac{\partial \phi_{j}}{\partial x_{l}}=2 \sum_{l=0}^{d-1} \frac{\partial u_{h}}{\partial x_{l}} \frac{\partial \phi_{j}}{\partial x_{l}}=2\left\langle\nabla u_{h}, \nabla \phi_{j}\right\rangle
$$

该方法的签名是

~~~C++
template <class EntityGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Jacobian>
void jacobian_volume(const EntityGeometry &entityGeometry,
                     const LocalFunctionSpaceU &localFunctionSpaceU,
                     const Vector &x,
                     const LocalFunctionSpaceV &localFunctionSpaceV,
                     Jacobian &jacobian) const
{
~~~



其代码与 `alpha_volume` 非常相似。最初的部分再次设置了各种类型和对象。

~~~C++
using TrialFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
using TestFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
using LocalBasisU = typename TrialFE::Traits::LocalBasisType;
using LocalBasisV = typename TestFE::Traits::LocalBasisType;
using RangeU = typename LocalBasisU::Traits::RangeType;
using RangeV = typename LocalBasisV::Traits::RangeType;
using GradientU = typename LocalBasisU::Traits::JacobianType;
using GradientV = typename LocalBasisV::Traits::JacobianType;


std::vector<RangeU> phi(localFunctionSpaceU.size());
std::vector<RangeV> theta(localFunctionSpaceV.size());

std::vector<GradientU> localGradPhi(localFunctionSpaceU.size());
std::vector<GradientV> localGradTheta(localFunctionSpaceV.size());

std::vector<GradientU> gradPhi(localFunctionSpaceU.size());
std::vector<GradientV> gradTheta(localFunctionSpaceV.size());
~~~





然后，下面的正交循环评估了试验和测试空间的`shape functions`。它还评估了它们的梯度，并将它们从参考元素坐标转换为世界坐标。为了简单起见，我们使用与`residual`本身相同的正交顺序，尽管这可能不是最佳的。


~~~C++
int intOrder = (localFunctionSpaceU.finiteElement().localBasis().order() - 1) * (p_ - 1) * (localFunctionSpaceV.finiteElement().localBasis().order() - 1);
const auto &quadRule = QuadratureRules<double, dim>::rule(entityGeometry.entity().type(),
                                                          intOrder);

for (const auto &quadPoint : quadRule)
{
    // Evaluate shape functions on reference element
    localFunctionSpaceU.finiteElement().localBasis().evaluateFunction(quadPoint.position(), phi);
    localFunctionSpaceV.finiteElement().localBasis().evaluateFunction(quadPoint.position(), theta);

    // Evaluate gradients of shape functions on reference element
    localFunctionSpaceU.finiteElement().localBasis().evaluateJacobian(quadPoint.position(), localGradPhi);
    localFunctionSpaceV.finiteElement().localBasis().evaluateJacobian(quadPoint.position(), localGradTheta);

    // Transform gradients from reference element to grid element
    const auto jacInvTransp = entityGeometry.geometry()
                                  .jacobianInverseTransposed(quadPoint.position());

    for (std::size_t i = 0; i < localFunctionSpaceU.size(); i++)
        jacInvTransp.mv(localGradPhi[i][0], gradPhi[i][0]);

    for (std::size_t i = 0; i < localFunctionSpaceV.size(); i++)
        jacInvTransp.mv(localGradTheta[i][0], gradTheta[i][0]);
~~~


这与计算`residual`本身的代码非常相似。然后代码在正交点评估$\nabla u_{h}$。与`residual`本身不同，这里不需要$u_{h}$的点值。

~~~C++
// Compute gradient of u
GradientU gradU(0.0);
for (std::size_t i = 0; i < localFunctionSpaceU.size(); ++i)
    gradU.axpy(x(localFunctionSpaceU, i), gradPhi[i]);
~~~



最后一个循环计算表达式\ref{11.14}，并将其加入存储在`object`矩阵中的元素刚度矩阵。

~~~C++
auto factor = quadPoint.weight() * entityGeometry.geometry()
                                       .integrationElement(quadPoint.position());
auto globalPos = entityGeometry.geometry().global(quadPoint.position());

// Integrate
for (std::size_t i = 0; i < localFunctionSpaceV.size(); i++)
    for (std::size_t j = 0; j < localFunctionSpaceU.size(); j++)
    {
        auto value = (p_ - 2) * std::pow(gradU[0].two_norm2(), 0.5 * p_ - 2) * (gradU[0] * gradPhi[j][0]) * (gradU[0] * gradTheta[i][0]);
        value += std::pow(gradU[0].two_norm2(), 0.5 * p_ - 1) * (gradTheta[i][0] * gradPhi[j][0]);
        value += c_(globalPos) * theta[i] * phi[j];
        jacobian.accumulate(localFunctionSpaceV, i,
                            localFunctionSpaceU, j,
                            value * factor);
    }
~~~



注意使用特殊的`accumulate`方法来更新矩阵条目。与`residual`方法中的`residual`向量一样，矩阵对象`jacobian`不是一个实际的矩阵容器。对 `accumulate` 的调用将作为最后一个方法参数给出的值添加到矩阵条目 $(i, j)$ 中。必须提供局部函数空间对象来控制形成树状的有限元空间的自由度编号。

\textbf{Running the Program}

当该程序运行时，它产生了以下输出。

~~~Shell
Initial defect: 2.9898e+00
=== Dune::CGSolver
Iter Defect Rate
0 2.9898e+00
1 8.2228e-03 2.7503e-03
2 3.7030e-04 4.5033e-02
3 4.3728e-06 1.1809e-02
=== rate=1.1351e-02, T=8.1717e-03, TIT=2.7239e-03, IT=3
Newton iteration 1. New defect: 2.7633e+00. \
Reduction (this): 9.2424e-01. Reduction (total): 9.2424e-01
=== Dune::CGSolver
Iter Defect Rate
0 2.7633e+00
1 1.7670e+00 6.3943e-01
2 9.6523e-01 5.4626e-01
3 1.3731e-01 1.4226e-01
4 3.2171e-02 2.3429e-01
5 1.1449e-02 3.5590e-01
6 6.0409e-03 5.2761e-01
7 1.1805e-03 1.9542e-01
8 1.6940e-04 1.4349e-01
=== rate=2.9746e-01, T=2.0751e-02, TIT=2.5938e-03, IT=8
Newton iteration 2. New defect: 2.3743e+00. \
Reduction (this): 8.5923e-01. Reduction (total): 7.9413e-01
[...]
=== Dune::CGSolver
Iter Defect Rate
0 3.1771e-10
1 5.6390e-11 1.7749e-01
2 3.8550e-11 6.8363e-01
3 1.8346e-11 4.7592e-01
=== rate=3.8652e-01, T=8.0403e-03, TIT=2.6801e-03, IT=3
Newton iteration 11. New defect: 1.8346e-11. \
Reduction (this): 5.7745e-02. Reduction (total): 6.1362e-12
~~~



我们可以看到`Newton`求解器的11次迭代，我们只打印了其中的第一次和最后几次。每个迭代都显示了当前的缺陷（即当前迭代时$\mathcal{R}$的规范），以及该规范相对于前一个迭代和初始迭代的减少系数。它还显示了用于解决线性`Newton`修正问题的CG求解器的迭代历史。由此产生的有限元函数在 [Fig11.3] 中得到了可视化。

\subsubsection{Skeleton and Boundary Integrals}

在本章中，我们到目前为止所看的例子问题只涉及到网格元素上的积分。然而，`dune-pdelab`的设计在其可分离性假设11.2中也预见到了对元素边界的积分。在那里，人们认为`residual`可以写成三个和

$$
\begin{array}{r}
r_{h}\left(u_{h}, v_{h}\right)=\sum_{T \in \mathcal{T}} r_{h, T}^{\mathrm{vol}}\left(u_{h}, v_{h}\right)+\sum_{\gamma^{\mathrm{i}} \in \mathcal{F}} r_{h, \gamma^{\mathrm{i}}}^{\mathrm{skel}}\left(u_{h}, v_{h}\right)+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B}} r_{h, \gamma^{\mathrm{b}}}^{\mathrm{bnd}}\left(u_{h}, v_{h}\right), \\
u_{h} \in U_{h}, \quad v_{h} \in V_{h}
\end{array}
$$

其中$r_{h, T}^{\text {vol }}$涉及元素上的积分项$T, r_{h, \gamma^{\mathrm{i}}}^{\text {skel }}$涉及两个相邻元素之间的交点$\gamma^{\mathrm{i}}$上的积分，$r_{h, \gamma^{\mathrm{b}}}^{\text {bnd }}$代表域边界项。例如，对于像`Discontinuous Galerkin`（DG）方法[^4][^55][^94]这样的不符合要求的离散法，需要骨架项。诺伊曼和`Robin`边界条件需要对域边界进行积分。

虽然前几节只讨论并使用了体积项$r_{h, T}^{\mathrm{vol}}$，但现在是讨论其他项的时候了。`LocalOperator`类定义了局部`residual`项集合器的接口，它有骨架和边界贡献$r_{h, \gamma^{\mathrm{i}}}^{\text {skel }}$和$r_{h, \gamma^{\mathrm{b}}}^{\text {bnd }}$的成员方法，以及它们的`Jacobian`s。我们首先讨论与域边界项有关的方法，因为它们的接口比与骨架积分有关的方法要简单一些。第一个方法是`alpha_boundary`，它计算网格边界元素面对`residual`的贡献。它的界面是

~~~C++
template <class IntersectionGeometry, class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void alpha_boundary(const IntersectionGeometry &intersectionGeometry,
                    const LocalFunctionSpaceU &localFunctionSpaceUIn,
                    const Vector &xIn,
                    const LocalFunctionSpaceV &localFunctionSpaceVIn,
                    Residual &residualIn) const

~~~


`Grid0perator`将为每个边界交叉点调用该方法一次。该方法必须将$\mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}$，即$r_{h, \gamma^{\mathrm{b}}}^{\text {bnd }}$的代数等价物添加到作为最后一个参数给出的本地`residual`矢量residualIn。

该方法看起来与第11.2.3章中讨论的`alpha_volume`方法非常相似。它有五个参数，所有这些参数的自由类型都是由相应的成员模板参数决定的。与`alpha_volume`不同的是，`alpha_boundary`方法接收了一个边界交点$\gamma^{\mathrm{b}}$作为它的第一个参数`intersectionGeometry`，它代表了积分项的域（关于交点的细节，见第$5.4$章）。与`alpha_volume`方法的entityGeometry参数一样，`intersectionGeometry`对象只是`Intersection`接口意义上的封装器。实际的交叉点可以通过调用方法来检索

~~~C++
const Intersection& intersection() const
~~~

的`intersectionGeometry`对象。



参数`localFunctionSpaceUIn`和`localFunctionSpaceVIn`是将用于试验和测试空间的`local finite elements`。它们被定义在与当前边界相交的元素$T_{\text {in }}$上（`dune-grid`称之为`inside`元素）。`alpha_boundary`实现必须计算`shape functions`对实际边界本身的限制。  在`LocalFiniteElement`模块意义上的`dune-localfunctions`对象可以通过调用有限元素方法从这些对象中检索出来，这在前面的例子中已经可以看到。

容器 `xIn` 存储了当前配置在元素 $T_{\text {in }}$ 上的局部系数。访问单个条目需要试用函数空间 `localFunctionSpaceUIn` 连同索引，就像在 `alpha_volume` 方法中一样。同样地，residualIn是方法写出结果残差的地方。它们的类型与`alpha_volume`方法中的自定义类型相同。特别是，这意味着必须使用其方法 accumulate 将数值添加到 residualIn 中。

为了获得`Jacobian`的边界项与$u_{h}$的系数的关系，有以下方法

~~~C++
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Jacobian>
void jacobian_boundary(const IntersectionGeometry &intersectionGeometry,
                       const LocalFunctionSpaceU &localFunctionSpaceUIn,
                       const Vector &xIn,
                       const LocalFunctionSpaceV &localFunctionSpaceVIn,
                       Jacobian &jacobianIn) const
~~~



它计算出的矩阵

$$
\nabla \mathcal{R}_{\gamma^{\mathrm{b}}}^{\mathrm{bnd}}\left(u_{h}\right) \in \mathbb{R}^{n_{1} \times n_{2}}
$$


其中$n_{1}$是元素上试验函数空间的自由度数，$n_{2}$是元素上试验函数的数量。矩阵的条目$(i, j)$将包含数字

$$
\frac{\partial\left(\mathcal{R}_{\gamma^{\mathrm{b}}}^{\text {bnd }}\right)_{i}}{\partial u_{j}}
$$

`jacobian_boundary`的参数与`alpha_boundary`方法的参数相同。唯一不同的是第五个参数，它接收结果。虽然`alpha_boundary`方法在这里有一个矢量数据类型，但`jacobian_boundary`方法期望的是一个矩阵。该矩阵类型的语法要求与第11.2.3章中讨论的`jacobian_volume`方法相同。下一节给出了该方法的一个实现示例。

至于体积方法，`Grid0perator`类并不能自动识别`Local0perator`实现中的`alpha_boundary`方法。如果`LocalOperator`实现有一个方法`alpha_boundary`，它必须设置

~~~C++
constexpr static bool doAlphaBoundary = true;
~~~

作为`LocalOperator`实现类的一个静态成员常量。否则`alpha_boundary`方法将不会被`Grid0perator`对象调用。

`LocalOperator`接口的第二个方法允许计算网格骨架的交点$\gamma^{\mathrm{i}}$上的`residual`。如果网格是符合要求的，那么骨架自然会被分解成元素面，但不符合要求的网格也可以被处理。

骨架上的残余项是通过以下方法组装的

~~~C++
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void `alpha_skeleton`(const IntersectionGeometry &intersectionGeometry,
                    const LocalFunctionSpaceU &localFunctionSpaceUIn,
                    const Vector &xIn,
                    const LocalFunctionSpaceV &localFunctionSpaceVIn,
                    const LocalFunctionSpaceU &localFunctionSpaceUOut,
                    const Vector &xOut,
                    const LocalFunctionSpaceV &localFunctionSpaceVOut,
                    Residual &residualIn, Residual &residualOut) const
~~~



如果`doAlphaSkeleton`被`LocalOperator`的实现所设置，它就会被`Grid0perator`调用，用于不属于域边界的每个交叉点。当理解了`alpha_boundary`方法后，这个签名很容易理解。当前的交叉点再次以交叉点几何对象`intersectionGeometry`的形式交给该方法。然后，有形状函数集、当前配置和结果残差的参数。然而，与只涉及一个元素的`alpha_boundary`方法不同，骨架中的交叉点是由两个网格元素共享。因此，`alpha_skeleton`对每个对象有两个参数。它们通过后缀`In`（用于`inside`元素）和`Out`（用于`outside`元素）进行区分。例如，`localFunctionSpaceUIn`包含相交的`inside`元素的安萨特局部有限元空间，`xOut`包含`outside`元素的局部配置。


为了计算骨架`residual`项的导数，`LocalOperator`有`jacobian_skeleton`方法。

~~~C++
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Jacobian>
void `jacobian_skeleton`(const IntersectionGeometry &intersectionGeometry,
                       const LocalFunctionSpaceU &localFunctionSpaceUIn,
                       const Vector &xIn,
                       const LocalFunctionSpaceV &localFunctionSpaceVIn,
                       const LocalFunctionSpaceU &localFunctionSpaceUOut,
                       const Vector &xOut,
                       const LocalFunctionSpaceV &localFunctionSpaceVOut,
                       Jacobian &jacobianInIn, Jacobian &jacobianInOut,
                       Jacobian &jacobianOutIn, Jacobian &jacobianOutOut)
    const

~~~



它的七个输入参数与`alpha_skeleton`方法相同。然而，它有四个输出矩阵参数，而不是 `alpha_skeleton` 的两个矢量参数。这四个矩阵是$2 \times 2$块状矩阵的块。

$$
\left(\begin{array}{cc}
\text { jacobianInIn } & \text { jacobianInOut } \\
\text { jacobianOutIn } & \text { jacobian0ut0ut }
\end{array}\right)=\left(\begin{array}{cc}
\left.\frac{\partial}{\partial u_{\mathrm{in}}} r^{\mathrm{skel}}\right|_{\mathrm{in}} & \left.\frac{\partial}{\partial u_{\mathrm{out}}} r^{\mathrm{skel}}\right|_{\mathrm{in}} \\
\left.\frac{\partial}{\partial u_{\mathrm{in}}} r^{\mathrm{skel}}\right|_{\text {out }} & \left.\frac{\partial}{\partial u_{\mathrm{out}}} r^{\mathrm{skel}}\right|_{\text {out }}
\end{array}\right) .
$$


例如，`jacobianInOut`包含`residual`元素上的代数`inside`条目相对于`outside`元素上的局部配置系数的导数。像往常一样，本地`residual`和配置向量包含元素上所有自由度的条目，而不仅仅是与共同交点相关的条目。

\subsubsection{Example: Discontinuous Galerkin Methods}

我们以一个结合了体积、骨架和边界项的完整例子来结束关于局部算子的章节。为此，我们重新审视第11.1章的线性反应-扩散的例子。那里的边界值问题的强形式是

$$
-\Delta u+c u=f \quad \text { in } \Omega=[0,1]^{2}
$$

与恒定的反应强度$c \equiv 10$，源函数

$$
f= \begin{cases}-10 & \text { on a circle of radius } 1 / 4 \text { around the center of } \Omega \\ 10 & \text { elsewhere }\end{cases}
$$







而且它是以零`Neumann`边界条件提出的。我们保留方程和领域，但现在我们将`Neumann`的边界条件修改为

$$
\langle\nabla u, \mathbf{n}\rangle=\mathbf{j}:= \begin{cases}-2 & \text { if } x_{1}=1 \text { and } x_{2} \in\left[\frac{1}{2}, 1\right] \\ 0 & \text { otherwise }\end{cases}
$$

问题的设置在 [Fig11.4] 中得到了说明。

边界值问题的`residual`表述为

$$
\text { Find } u \in H^{1}(\Omega): r(u, v)=0 \quad \text { for all } v \in H^{1}(\Omega)
$$

用`residual`的形式

$$
r(u, v):=\int_{\Omega}[\langle\nabla u, \nabla v\rangle+c u v-f v] d x-\int_{\partial \Omega} \mathrm{j} v d x
$$

与之前的例子不同，这种形式除了包含体积积分外，还包含域边界的积分$\partial \Omega$。

我们将使用`Symmetric Interior Penalty Galerkin` $($ SIPG $)$ 方法来离散问题，这是一种特殊的`Discontinuous Galerkin` 方法 [^4] [^58] 。在文献中，这种方法也被简单地称为`Interior Penalty`（IP）。设$\mathcal{T}$是$\Omega$的一个网格，并定义不符合要求的有限元空间

$$
\mathrm{DG}^{k}:=\left\{u \in L_{2}(\Omega):\left.u\right|_{T} \in \Pi_{k} \forall T \in \mathcal{T}\right\}
$$

这个空间的函数在元素边界不一定是连续的，我们把它们解释为在那里是多值的。让$\gamma$成为一个交点，即


两个相邻的元素 $T_{\mathrm{in}}$ 和 $T_{\mathrm{out}}$ 。对于一个函数$u_{h} \in \mathrm{DG}^{k}$，我们定义$u_{h}^{\mathrm{in}}$是对$T_{\mathrm{in}}$的限制，而$u_{h}^{\text {out }}$是对$T_{\text {out }}$的限制。跨越$\gamma$的跳跃是

$$
\llbracket u_{h} \rrbracket_{\gamma}(x):=u_{h}^{\mathrm{in}}(x)-u_{h}^{\mathrm{out}}(x) \quad \forall x \in \gamma
$$

同样地，我们将平均数定义为

$$
\left\{u_{h}\right\}_{\gamma}(x):=\frac{1}{2}\left(u_{h}^{\mathrm{in}}(x)+u_{h}^{\mathrm{out}}(x)\right) \quad \forall x \in \gamma
$$

请注意，跳跃$\llbracket u_{h} \rrbracket_{\gamma}$的符号取决于$\gamma$的方向，但平均值的符号不取决于此。有了这些定义，SIPG方法的离散问题为

\begin{equation}
\text { Find } u_{h} \in \mathrm{DG}^{k}: \quad r_{h}^{\mathrm{SIPG}}\left(u_{h}, v_{h}\right)=0 \quad \forall v_{h} \in \mathrm{DG}^{k}
\label{11.15}
\end{equation}

其中

\begin{equation}
\begin{aligned}
r_{h}^{\mathrm{SIPG}}\left(u_{h}, v_{h}\right):=& \int_{\Omega} \nabla u_{h} \nabla v_{h} d x+\int_{\Omega} c u_{h} v_{h} d x \\
&-\int_{\mathcal{F}}\left\{\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right\} \llbracket v_{h} \rrbracket d s-\int_{\mathcal{F}}\left\{\left\langle\nabla v_{h}, \mathbf{n}\right\rangle\right\} \llbracket u_{h} \rrbracket d s \\
&+\kappa \sum_{\gamma \in \mathcal{F}} \frac{1}{h_{\gamma}} \int_{\gamma} \llbracket u_{h} \rrbracket \llbracket v_{h} \rrbracket d s \\
&-\int_{\Omega} f v_{h} d x-\int_{\partial \Omega} \mathrm{j} v_{h} d s
\end{aligned}
\label{11.16}
\end{equation}

和$\mathcal{F}$是所有骨架交点的联合。请注意分离成体积项、骨架项和边界项。这个`residual`的体积项与第11.1章的符合离散化中的体积项相同。$r_{h}^{\mathrm{SIPG}}(\cdot, \cdot)$定义中第二行的项惩罚了元素间边界的跳动$\llbracket u_{h} \rrbracket$。第三行条款确保$r_{h}^{\mathrm{SIPG}}(\cdot, \cdot)$的二次方部分保持椭圆，对于惩罚参数$\kappa$足够大。最后一行包含$u_{h}$与`residual`形式无关的部分。在$f$上的体积积分是源项，而在域边界$\partial \Omega$上的积分是`Neumann`边界条件$\langle\nabla u, \mathbf{n}\rangle=\mathrm{j}$的弱形式。

只要惩罚参数$\kappa$足够大，`residual`方程\ref{11.15}就有一个唯一的解[^4] [^55] 。随着网格的细化[^4] [^55]，这个解以最优的顺序收敛到精确的解。

\textbf{The `main` Method}

像往常一样，示例程序被包含在一个文件中。它被打印在附录B.13中，可以通过边缘的图标获得。该文件包含`main`方法，该方法设置问题并调用代数求解器，以及计算SIPG `residual`形式（11.16）的局部算子的实现，以及其`Jacobian` 。

我们依次讨论这两部分。`main`方法与第11.1章中带有`Lagrange`元素的反应-扩散系统的方法非常相似。它首先是初始化MPI，然后设置网格。


~~~C++
int main(int argc, char *argv[])
{
    // Initialize MPI, if present
    MPIHelper::instance(argc, argv);

    constexpr int dim = 2;
    using Grid = UGGrid<dim>;
    std::shared_ptr<Grid> grid = StructuredGridFactory<Grid>::createCubeGrid({0.0, 0.0},
                                                                             {1.0, 1.0},
                                                                             {4, 4});

    // Nonconforming refinement near the domain center
    grid->setClosureType(Grid::NONE); // UGGrid-specific:
    // turn off green closure

    using Position = FieldVector<Grid::ctype, dim>;
    for (const auto &element : elements(grid->leafGridView()))
        if ((element.geometry().center() - Position(0.5)).two_norm() < 0.25)
            grid->mark(1, element);

    grid->preAdapt();
    grid->adapt();
    grid->postAdapt();

    using GridView = Grid::LeafGridView;
    const GridView gridView = grid->leafGridView();
~~~



与第11.1章不同的是，该代码没有使用`YaspGrid`的网格实现。相反，为了展示DG方法如何自然地处理不符合要求的网格，代码使用了`UGGrid`的实现，并进行了一些自适应的红色细化，如[Fig11.4] 所示。对`preAdapt`和`postAdapt`的调用是DUNE网格接口规定的，尽管这里没有传输数据。

下一步是设置网格函数空间。代码使用`dune-functions`模块中的函数空间基础`LagrangeDGBasis`。它实现了空间`Lagrange`的标准不连续基础，编译时顺序为$k$ 。该代码将这个顺序设置为 $k=2$ 。然后，基对象被用来建立一个`GridFunctionSpace`对象，它是现在众所周知的`dune-pdelab`有限元空间的抽象概念。

~~~C++
// Make dune-functions basis
using DGBasis = Functions::LagrangeDGBasis<GridView, 2>;
auto dgBasis = std::make_shared<DGBasis>(gridView);

// Make dune-pdelab grid function space
using VectorBackend = PDELab::ISTL::VectorBackend<>;
using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<DGBasis,
                                                                  VectorBackend,
                                                                  PDELab::NoConstraints>;

GridFunctionSpace gridFunctionSpace(dgBasis);

~~~



然后，代码设置了汇编器。首先，定义了三个参数函数 $c, f$ 和 $\mathrm{j}$ 。为了简单起见，代码把这三个函数都实现为小的lambda对象，然后交给`Local0perator`实现。


~~~C++
// Reaction strength
auto c = [](const FieldVector<double, dim> &x)
{
    return 10.0;
};

// Source term
auto f = [](const FieldVector<double, dim> &x)
{
    const auto center = FieldVector<double, dim>(0.5);
    auto distanceToCenter = (x - center).two_norm();
    return (distanceToCenter <= 0.25) ? -10.0 : 10.0;
};

// Neumann boundary data
auto neumann = [](const FieldVector<double, dim> &x)
{
    return (x[0] >= 0.999 && x[1] >= 0.5) ? -2 : 0;
};

~~~



然后，实际的汇编程序被设置。`LocalOperator`的实现被称为`ReactionDiffusionDG`，它在例子文件的前面被定义。它被赋予三个参数函数c、f、neumann和coercivity参数 `kappa` 。与函数空间基数和矩阵后端一起，`ReactionDiffusionDG`局部运算器然后被用来设置`GridOperator`对象。

~~~C++
// Make local operator
using LocalOperator = ReactionDiffusionDG<GridView>;
double kappa = 3;
LocalOperator localOperator(c, f, neumann, kappa);
using MatrixBackend = PDELab::ISTL::BCRSMatrixBackend<>;
MatrixBackend matrixBackend(45); // 45: Expected approximate number
// of nonzeros per matrix row

using GridOperator = PDELab::GridOperator<GridFunctionSpace, // Trial function space
                                          GridFunctionSpace, // Test function space
                                          LocalOperator,     // Element assembler
                                          MatrixBackend,     // Data structure
                                          // for the stiffness matrix
                                          double, // Number type for
                                          // solution vector entries
                                          double, // Number type for
                                          // residual vector entries
                                          double>; // Number type for
// stiffness matrix entries

GridOperator gridOperator(gridFunctionSpace,
                          gridFunctionSpace,
                          localOperator,
                          matrixBackend);
~~~



通过实验选择了$\kappa=3$这个值。`Grid0perator`类的设置与以前的例子一样。

在这一点上，汇编程序已经准备好了，代数求解器可以被构建和运行。

~~~C++
// Make a vector of degrees of freedom, and initialize it with 0
using VectorContainer = typename GridOperator::Traits::Domain;
VectorContainer u(gridFunctionSpace, 0.0);

// Make linear solver and solve problem
using LinearSolverBackend = PDELab::ISTLBackend_SEQ_CG_ILU0;
LinearSolverBackend linearSolverBackend(50, // Maximum number
                                        // of iterations
                                        2); // Solver verbosity

using LinearProblemSolver = PDELab::StationaryLinearProblemSolver<GridOperator,
                                                                  LinearSolverBackend,
                                                                  VectorContainer>;

LinearProblemSolver linearProblemSolver(gridOperator,
                                        linearSolverBackend,
                                        u,
                                        1e-10); // Desired relative
// residual reduction
linearProblemSolver.apply();

~~~



作为最后一步，结果被写入一个VTK文件。这里与先前的例子没有区别。


~~~C++
// Make a discrete function from the FE basis and the coefficient vector
auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
    *dgBasis,
    PDELab::Backend::native(u));

// We need to subsample, because VTKWriter
// cannot natively display second-order functions.
SubsamplingVTKWriter<GridView> vtkWriter(gridView,
                                         refinementLevels(5));
vtkWriter.addVertexData(uFunction,
                        VTK::FieldInfo("u",
                                       VTK::FieldInfo::Type::scalar,
                                       1));
vtkWriter.write("pdelab-dg-diffusion-result");

~~~



请记住，`SubsamplingVTKWriter`总是使用`VTK::nonconforming`数据模式（第$5.8.1$和$10.7)$章），因此它自动捕捉了DG函数的跳转。

\textbf{The Local Operator}

`LocalOperator`的实现`ReactionDiffusionDG`构成了这个例子的中心部分。它将离散的SIPG`residual`\ref{11.15}及其`Jacobian`矩阵组装起来。由于这种DG离散化比纯粹的`Lagrange`离散化涉及更多，`Local0perator`的实现也更加复杂。总的来说，`ReactionDiffusionDG`类实现了六个方法。  `alpha_volume`和`jacobian_volume`用于扩散、反应和源项，`alpha_skeleton`和`jacobian_skeleton`用于DG离散化的附加项，而alpha_boundary和`jacobian_boundary`用于`Neumann`边界条件。

一旦研究了第$11.2 .4$章的`p-Laplace`例子，`volume`方法就很容易理解。因此这里省略了它们的介绍（但在附录B.13中显示了它们）。只有后四种方法将被讨论。

`ReactionDiffusionDG`类有如下签名。

~~~C++
template <class GridView>
class ReactionDiffusionDG
    : public PDELab::LocalOperatorDefaultFlags,
      public Dune::PDELab::FullVolumePattern,
      public Dune::PDELab::FullSkeletonPattern,
      public Dune::PDELab::FullBoundaryPattern
{

~~~



基类注入代码，为三个贡献的矩阵稀疏性模式进行设置。然后，该类包含一个简短的辅助方法，计算一个几何体的直径。


~~~C++
template <class Geometry>
static auto diameter(const Geometry &geometry)
{
    typename Geometry::ctype h = 0.0;
    for (int i = 0; i < geometry.corners(); i++)
        for (int j = i + 1; j < geometry.corners(); j++)
            h = std::max(h, (geometry.corner(j) - geometry.corner(i)).two_norm());

    return h;
}

~~~


下面用它来计算网格交叉点的直径$h_{\gamma}$。

然后该类声明了四个数据成员变量。除了矫顽力参数$\kappa$，还有三个参数函数$c, f$，和$\mathrm{j}$。它们被存储在类型为`std::function`的对象中，以限制该类的模板参数的数量。


~~~C++
double kappa_;

static constexpr int dim = GridView::dimension;

std::function<double(const FieldVector<double, dim> &)> c_;
std::function<double(const FieldVector<double, dim> &)> f_;
std::function<double(const FieldVector<double, dim> &)> neumann_;

~~~



之后，`Local0perator`实现声明了它所实现的`interface`方法集。通过将标志`doAlphaVolume`、`doAlphaSkeleton`和`doAlphaBoundary`设置为`true`，该类声明它将为`volume`、`skeleton`和`boundary`术语实现alpha和jacobian方法。doPattern标志将使`Grid0perator`对象以`volume`, `skeleton`, 和`boundary`项的默认模式初始化`Jacobian`矩阵。

~~~C++
 // Residual assembly flags
 enum { doAlphaVolume = true };
 enum { doAlphaSkeleton = true };
 enum { doAlphaBoundary = true };

 // Pattern assembly flags
 enum { doPatternVolume = true };
 enum { doPatternSkeleton = true };
 enum { doPatternBoundary = true };

~~~


该类中的下一个是构造函数。它简单地接受问题参数并将其存储在类的数据成员中。


~~~C++
ReactionDiffusionDG(std::function<double(const FieldVector<double, dim> &)> c,
                    std::function<double(const FieldVector<double, dim> &)> f,
                    std::function<double(const FieldVector<double, dim> &)>
                        neumann,
                    double kappa)
    : kappa_(kappa),
      c_(c),
      f_(f),
      neumann_(neumann)
{
}
~~~




然后，代码中包含了`alpha_volume`和`alpha_jacobian`方法，我们跳过这些方法。

`ReactionDiffusionDG`类的第一个新方法是`alpha_skeleton`，它集合了\ref{11.16}中给出的SIPG`residual`的骨架部分的代数表述，用于给定的离散函数$u_{h}$。更确切地说，该方法实现了两个相邻元素$T_{\mathrm{in}}$和$T_{\text {out }}:$之间的单一交点$\gamma$的贡献。

\begin{equation}
\begin{array}{r}
\left(\mathcal{R}_{\gamma}^{\text {SIPG,skel }}\left(u_{h}\right)\right)_{i}:=-\int_{\gamma}\left\{\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right\} \llbracket \theta_{i} \rrbracket d s-\int_{\gamma}\left\{\left\langle\nabla \theta_{i}, \mathbf{n}\right\rangle\right\} \llbracket u_{h} \rrbracket d s \\
+\frac{\kappa}{h_{\gamma}} \int_{\gamma} \llbracket u_{h} \rrbracket \llbracket \theta_{i} \rrbracket d s \quad i=0, \ldots, n-1
\end{array}
\label{11.17}
\end{equation}

这些贡献只有在测试函数$\theta_{i}$的支持率与元素$T_{\text {in }}$或$T_{\text {out }}$相交时才可能为非零。我们将这些测试函数分别称为 $\theta_{i}^{\text {in }}$ 和 $\theta_{i}^{\text {out }}$ 。同样地，我们把试验基函数对两个元素$T_{\mathrm{in}}$和$T_{\mathrm{out}}$的限制写成$\phi_{i}^{\text {in }}$和$\phi_{i}^{\text {out }}$，而把整个多值DG基函数写成$\phi_{i}$。

`alpha_skeleton`方法的接口是

~~~C++
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void `alpha_skeleton`(const IntersectionGeometry &intersectionGeometry,
                    const LocalFunctionSpaceU &localFunctionSpaceUIn,
                    const Vector &xIn,
                    const LocalFunctionSpaceV &localFunctionSpaceVIn,
                    const LocalFunctionSpaceU &localFunctionSpaceUOut,
                    const Vector &xOut,
                    const LocalFunctionSpaceV &localFunctionSpaceVOut,
                    Residual &residualIn, Residual &residualOut) const
{

~~~



如第11.2.5章所述，`intersectionGeometry`是对当前交点的封装，`localFunctionSpaceUIn`和`localFunctionSpaceUOut`分别是内侧的`local finite elements`和`outside`元素，`xIn`和`xOut`是$u_{h}$ 的各自对应系数向量。参数`localFunctionSpaceVIn`和`localFunctionSpaceVOut`持有两个元素$T_{\mathrm{in}}$和$T_{\mathrm{out}}$上的测试函数空间的`local finite elements` 。最后，产生的残差被返回到两个容器 `residualIn` 和 `residual0ut` 中。

该方法的实现是漫长的，因为所有的设置代码都要做两次，对涉及的两个元素各做一次。该方法首先存储各种类型和几何对象供以后使用。

~~~C++
using TrialFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
using TestFE = typename LocalFunctionSpaceV::Traits::FiniteElementType;
using LocalBasisU = typename TrialFE::Traits::LocalBasisType;
using LocalBasisV = typename TestFE::Traits::LocalBasisType;
using RangeU = typename LocalBasisU::Traits::RangeType;
using RangeV = typename LocalBasisV::Traits::RangeType;
using GradientU = typename LocalBasisU::Traits::JacobianType;
using GradientV = typename LocalBasisV::Traits::JacobianType;
using size_type = typename LocalFunctionSpaceV::Traits::SizeType;

// References to inside and `outside` elements
const auto &elementInside = intersectionGeometry.inside();
const auto &elementOutside = intersectionGeometry.outside();

// Intersection and element geometries
auto geo = intersectionGeometry.geometry();
auto geoIn = elementInside.geometry();
auto geoOut = elementOutside.geometry();

// Geometries of intersection in local coordinates
// of elementInside and elementOutside
auto geoInInside = intersectionGeometry.geometryInInside();
auto geoInOutside = intersectionGeometry.geometryInOutside();

~~~


然后，代码使用第32行中定义的方法`diameter`预先计算出交点直径$h_{\gamma}$。


~~~C++
auto h = diameter(geo);
~~~



之后，它创建容器来存储形状函数值和`inside`和`outside`元素上的梯度。独立的容器被用来存储与参考元素坐标和网格元素坐标有关的梯度。


~~~C++
// Shape function values
std::vector<RangeU> phiIn(localFunctionSpaceUIn.size());
std::vector<RangeV> thetaIn(localFunctionSpaceVIn.size());
std::vector<RangeU> phiOut(localFunctionSpaceUOut.size());
std::vector<RangeV> thetaOut(localFunctionSpaceVOut.size());

// Shape function gradients on the reference element
std::vector<GradientU> localGradPhiIn(localFunctionSpaceUIn.size());
std::vector<GradientV> localGradThetaIn(localFunctionSpaceVIn.size());
std::vector<GradientU> localGradPhiOut(localFunctionSpaceUOut.size());
std::vector<GradientV> localGradThetaOut(localFunctionSpaceVOut.size());

// Shape function gradients on the grid element
std::vector<GradientU> gradPhiIn(localFunctionSpaceUIn.size());
std::vector<GradientV> gradThetaIn(localFunctionSpaceVIn.size());
std::vector<GradientU> gradPhiOut(localFunctionSpaceUOut.size());
std::vector<GradientV> gradThetaOut(localFunctionSpaceVOut.size());
~~~


接下来是正交循环。为了简单起见，代码使用`inside`元素上的基础的两倍的多项式阶数作为合适的正交阶数的猜测。


~~~C++
const auto quadOrder = 2 * localFunctionSpaceUIn.finiteElement().localBasis().order();
constexpr auto intersectionDim = IntersectionGeometry::mydimension;
const auto &quadRule = QuadratureRules<double, intersectionDim>::
    rule(intersectionGeometry.geometry().type(),
         quadOrder);

for (const auto &quadPoint : quadRule)
{
~~~


正交循环一直延伸到方法的末端。在循环体的开始，代码评估了`shape functions`及其`Jacobian`s。`geoInInside`和`geoInOutside`对象被用来将正交点的位置从交点上的坐标转换到相邻元素上的坐标（第$5.4$章）。由于涉及到两个元素上的基函数，所以需要对值和梯度进行四次调用，而试验和测试函数是分开处理的。


~~~C++
// Quadrature point position in local coordinates of adjacent elements
auto quadPointLocalIn = geoInInside.global(quadPoint.position());
auto quadPointLocalOut = geoInOutside.global(quadPoint.position());

// Evaluate shape functions
localFunctionSpaceUIn.finiteElement().localBasis().evaluateFunction(quadPointLocalIn, phiIn);
localFunctionSpaceUOut.finiteElement().localBasis().evaluateFunction(quadPointLocalOut, phiOut);
localFunctionSpaceVIn.finiteElement().localBasis().evaluateFunction(quadPointLocalIn, thetaIn);
localFunctionSpaceVOut.finiteElement().localBasis().evaluateFunction(quadPointLocalOut, thetaOut);

// Evaluate gradients of shape functions
localFunctionSpaceUIn.finiteElement().localBasis().evaluateJacobian(quadPointLocalIn,
                                                                    localGradPhiIn);
localFunctionSpaceUOut.finiteElement().localBasis().evaluateJacobian(quadPointLocalOut,
                                                                     localGradPhiOut);
localFunctionSpaceVIn.finiteElement().localBasis().evaluateJacobian(quadPointLocalIn,
                                                                    localGradThetaIn);
localFunctionSpaceVOut.finiteElement().localBasis().evaluateJacobian(quadPointLocalOut,
                                                                     localGradThetaOut);

~~~

然后形状函数梯度被转换为两个网格元素Tin和Tout的坐标。这是以通常的方式发生的，但由于涉及两个不同的元素，所以也使用了两个不同的转换矩阵。

~~~C++
auto jacInvTranspIn = geoIn.jacobianInverseTransposed(quadPointLocalIn);
for (size_type i = 0; i < localFunctionSpaceUIn.size(); i++)
    jacInvTranspIn.mv(localGradPhiIn[i][0], gradPhiIn[i][0]);
for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
    jacInvTranspIn.mv(localGradThetaIn[i][0], gradThetaIn[i][0]);

auto jacInvTranspOut = geoOut.jacobianInverseTransposed(quadPointLocalOut);
for (size_type i = 0; i < localFunctionSpaceUOut.size(); i++)
    jacInvTranspOut.mv(localGradPhiOut[i][0], gradPhiOut[i][0]);
for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
    jacInvTranspOut.mv(localGradThetaOut[i][0], gradThetaOut[i][0]);
~~~


然后，下面的模块在当前积分点计算$u_{h}$和$\nabla u_{h}$，分别是基函数值及其梯度的线性组合。

~~~C++
// Compute values of u_h
RangeU uIn(0.0);
for (size_type i = 0; i < localFunctionSpaceUIn.size(); i++)
    uIn += xIn(localFunctionSpaceUIn, i) * phiIn[i];
RangeU uOut(0.0);
for (size_type i = 0; i < localFunctionSpaceUOut.size(); i++)
    uOut += xOut(localFunctionSpaceUOut, i) * phiOut[i];

// Compute gradients of u_h
GradientU gradUIn(0.0);
for (size_type i = 0; i < localFunctionSpaceUIn.size(); i++)
    gradUIn.axpy(xIn(localFunctionSpaceUIn, i), gradPhiIn[i]);
GradientU gradUOut(0.0);
for (size_type i = 0; i < localFunctionSpaceUOut.size(); i++)
    gradUOut.axpy(xOut(localFunctionSpaceUOut, i), gradPhiOut[i]);
~~~


由于$u_{h}$在正交点不连续，有两个$u_{h}$的值要计算，还有两个$\nabla u_{h}$的值。

最后，三个循环计算$\mathcal{R}_{\gamma}^{\text {SIPG,skel }}$的三个项的值，定义在\ref{11.17}。

~~~C++
        // Unit normal from T_in to T_out
        auto n_F = intersectionGeometry.unitOuterNormal(quadPoint.position());

        // Integration factor
        auto factor = quadPoint.weight() * geo.integrationElement(quadPoint.position());

        // Interior penalty term
        auto interiorPenaltyTerm = -0.5 * (gradUIn[0] * n_F + gradUOut[0] * n_F);
        for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
            residualIn.accumulate(localFunctionSpaceVIn,
                                  i,
                                  interiorPenaltyTerm *thetaIn[i] * factor);
        for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
            residualOut.accumulate(localFunctionSpaceVOut,
                                   i,
                                   -interiorPenaltyTerm *thetaOut[i] * factor);

        // Symmetric interior penalty term
        for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
            residualIn.accumulate(localFunctionSpaceVIn,
                                  i,
                                  -0.5 * (gradThetaIn[i][0] * n_F) * (uIn - uOut) * factor);
        for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
            residualOut.accumulate(localFunctionSpaceVOut,
                                   i,
                                   -0.5 * (gradThetaOut[i][0] * n_F) * (uIn - uOut) * factor);

        // Coercivity term
        auto coercivityTerm = (kappa_ / h) * (uIn - uOut);
        for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
            residualIn.accumulate(localFunctionSpaceVIn,
                                  i,
                                  coercivityTerm *thetaIn[i] * factor);
        for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
            residualOut.accumulate(localFunctionSpaceVOut,
                                   i,
                                   -coercivityTerm *thetaOut[i] * factor);
    }
}

~~~





注意输出`residual`的贡献现在被分成两部分，一部分包含用`inside`元素的测试函数$\theta_{i}^{\text {in }}$测试的结果，另一部分是对`outside`元素的测试函数$\theta_{i}^{\text {out }}$。

- 第一对循环将$-\left\{\left\langle\nabla u_{h}, \mathbf{n}_{\gamma}\right\rangle\right\} \theta_{i}^{\text {in }}$添加到`inside`元素的`residual`，将$\left\{\left\langle\nabla u_{h}, \mathbf{n}_{\gamma}\right\rangle\right\} \theta_{i}^{\text {out }}$添加到`outside`元素的`residual`。这相当于\ref{11.17}的术语$-\left\{\left\langle\nabla u_{h}, \mathbf{n}_{\gamma}\right\rangle\right\} \llbracket \theta_{i} \rrbracket$。

- 第二对循环将$-\frac{1}{2}\left\langle\nabla \theta_{i}^{\mathrm{in}}, \mathbf{n}_{\gamma}\right\rangle \llbracket u_{h} \rrbracket$添加到`residual`的`inside`元素中，并将$-\frac{1}{2}\left\langle\nabla \theta_{i}^{\text {out }}, \mathbf{n}_{\gamma}\right\rangle \llbracket u_{h} \rrbracket$添加到`outside`元素的`residual`中。这与术语$-\left\{\left\langle\nabla \theta, \mathbf{n}_{\gamma}\right\rangle\right\} \llbracket u_{h} \rrbracket$相对应。



- 第三对循环将$\frac{\kappa}{h_{\gamma}} \llbracket u_{h} \rrbracket \theta_{i}^{\text {in }}$添加到`inside`元素中，并将$-\frac{\kappa}{h_{\gamma}} \llbracket u_{h} \rrbracket \theta_{i}^{\text {out }}$添加到`outside`元素中。这对应于术语$\frac{\kappa}{h_{\gamma}} \llbracket u_{h} \rrbracket \llbracket \theta_{i} \rrbracket$ 。

`alpha_skeleton`方法到此结束。

下一个方法是`jacobian_skeleton` ，它计算`residual` $\mathcal{R}_{\gamma}^{\mathrm{SIPG}, \operatorname{skel}}\left(u_{h}\right)$与$u_{h}$的系数$\bar{u}^{\mathrm{in}} \in \mathbb{R}^{n_{T} \mathrm{in}}$和$\bar{u}^{\text {out }} \in \mathbb{R}^{n} T_{\text {out }}$分别在$T_{\text {in }}$和$T_{\text {out }}$的交点的导数。由于`residual`在$u_{h}$中是线性的，导数是一个独立于$u_{h}$的矩阵。导数是

\begin{equation}
\frac{\left.\partial \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \mathrm{skel}}(\bar{u})\right)_{i}}{\partial \bar{u}_{j}^{\mathrm{in}}}=-\frac{1}{2} \int_{\gamma}\left\langle\nabla \phi_{j}^{\mathrm{in}}, \mathbf{n}_{\gamma}\right\rangle \llbracket \theta_{i} \rrbracket d s-\int_{\gamma}\left\{\left\langle\nabla \theta_{i}, \mathbf{n}_{\gamma}\right\rangle\right\} \phi_{j}^{\mathrm{in}} d s+\frac{\kappa}{h_{\gamma}} \int_{\gamma} \phi_{j}^{\mathrm{in}} \llbracket \theta_{i} \rrbracket d s 
\label{11.18a}
\end{equation}


\begin{equation}
\frac{\left.\partial \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \mathrm{skel}}(\bar{u})\right)_{i}}{\partial \bar{u}_{j}^{\text {out }}}=-\frac{1}{2} \int_{\gamma}\left\langle\nabla \phi_{j}^{\text {out }}, \mathbf{n}_{\gamma}\right\rangle \llbracket \theta_{i} \rrbracket d s \\
+\int_{\gamma}\left\{\left\langle\nabla \theta_{i}, \mathbf{n}_{\gamma}\right\rangle\right\} \phi_{j}^{\text {out }} d s-\frac{\kappa}{h_{\gamma}} \int_{\gamma} \phi_{j}^{\mathrm{out}} \llbracket \theta_{i} \rrbracket d s
\label{11.18b}
\end{equation}

其中\ref{11.18a}表示相对于`inside`元素的自由度的导数，\ref{11.18b}表示`outside`元素的相应导数。矩阵行可以根据相应的`residual`矢量条目是否与内部或`outside`元素相关联进行分类。对于\ref{11.18a}，利用该

$$
\llbracket \theta_{i} \rrbracket=\theta_{i}^{\mathrm{in}}-\theta_{i}^{\text {out }} \quad \text { and } \quad\left\{\nabla \theta_{i}\right\}=\frac{1}{2}\left(\nabla \theta_{i}^{\mathrm{in}}+\nabla \theta_{i}^{\text {out }}\right)
$$

我们得到

\begin{equation}
\frac{\left.\partial \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \operatorname{skel}}\left(\bar{u}^{\mathrm{in}}\right)\right)_{i}}{\partial \bar{u}_{j}^{\mathrm{in}}}=-\frac{1}{2}\left[\left\langle\nabla \phi_{j}^{\mathrm{in}}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \theta_{i}^{\mathrm{in}}+\left\langle\nabla \theta_{i}^{\mathrm{in}}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \phi_{j}^{\mathrm{in}}\right]+\frac{\kappa}{h_{\gamma^{\mathrm{i}}}} \phi_{j}^{\mathrm{in}} \theta_{i}^{\mathrm{in}}
\label{11.19a}
\end{equation}

和

\begin{equation}
\frac{\left.\partial \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \mathrm{skel}}\left(\bar{u}^{\mathrm{out}}\right)\right)_{i}}{\partial \bar{u}_{j}^{\mathrm{in}}}=\frac{1}{2}\left[\left\langle\nabla \phi_{j}^{\mathrm{in}}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \theta_{i}^{\text {out }}-\left\langle\nabla \theta_{i}^{\text {out }}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \phi_{j}^{\mathrm{in}}\right]-\frac{\kappa}{h_{\gamma^{\mathrm{i}}}} \phi_{j}^{\mathrm{in}} \theta_{i}^{\text {out }}
\label{11.19b}
\end{equation}

同样，对于\ref{11.18b}，我们可以得到

\begin{equation}
\frac{\left.\partial \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \text { skel }}\left(\bar{u}^{\mathrm{in}}\right)\right)_{i}}{\partial \bar{u}_{j}^{\text {out }}}=\frac{1}{2}\left[-\left\langle\nabla \phi_{j}^{\text {out }}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \theta_{i}^{\mathrm{in}}+\left\langle\nabla \theta_{i}^{\mathrm{in}}, \mathbf{n}_{\gamma^{i}}\right\rangle \phi_{j}^{\text {out }}\right]-\frac{\kappa}{h_{\gamma^{i}}} \phi_{j}^{\text {out }} \theta_{i}^{\mathrm{in}}
\label{11.19c}
\end{equation}

和

\begin{equation}
\frac{\left.\partial \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \mathrm{skel}}\left(\bar{u}^{\mathrm{out}}\right)\right)_{i}}{\partial \bar{u}_{j}^{\text {out }}}=\frac{1}{2}\left[\left\langle\nabla \phi_{j}^{\text {out }}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \theta_{i}^{\text {out }}+\left\langle\nabla \theta_{i}^{\text {out }}, \mathbf{n}_{\gamma^{\mathrm{i}}}\right\rangle \phi_{j}^{\mathrm{out}}\right]+\frac{\kappa}{h_{\gamma^{\mathrm{i}}}} \phi_{j}^{\text {out }} \theta_{i}^{\text {out }}
\label{11.19d}
\end{equation}

这种自然的$2 \times 2$矩阵块结构在方法界面上是可见的。

~~~C++
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Jacobian>
void jacobian_skeleton(const IntersectionGeometry &intersectionGeometry,
                       const LocalFunctionSpaceU &localFunctionSpaceUIn,
                       const Vector &xIn,
                       const LocalFunctionSpaceV &localFunctionSpaceVIn,
                       const LocalFunctionSpaceU &localFunctionSpaceUOut,
                       const Vector &xOut,
                       const LocalFunctionSpaceV &localFunctionSpaceVOut,
                       Jacobian &jacobianInIn, Jacobian &jacobianInOut,
                       Jacobian &jacobianOutIn, Jacobian &jacobianOutOut)
    const

~~~



其中四个输出矩阵`jacobianInIn`、`jacobianInOut`、`jacobianOutIn`和`jacobianOut0ut`对应于$\nabla \mathcal{R}_{\gamma}^{\mathrm{SIPG}, \mathrm{skel}}$ 的四个子矩阵。所有的方法参数已经在第11.2.5章中进行了描述。

该方法的实现与`alpha_skeleton`方法类似，通过预先计算各种几何对象，并为形状函数值和梯度分配容器。


~~~C++
// Define types
using TrialFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
using TestFE = typename LocalFunctionSpaceV::Traits::FiniteElementType;
using LocalBasisU = typename TrialFE::Traits::LocalBasisType;
using LocalBasisV = typename TestFE::Traits::LocalBasisType;
using RangeU = typename LocalBasisU::Traits::RangeType;
using RangeV = typename LocalBasisV::Traits::RangeType;
using GradientU = typename LocalBasisU::Traits::JacobianType;
using GradientV = typename LocalBasisV::Traits::JacobianType;
using size_type = typename LocalFunctionSpaceV::Traits::SizeType;

// References to inside and outside elements
const auto &elementInside = intersectionGeometry.inside();
const auto &elementOutside = intersectionGeometry.outside();

// Get geometries
auto geo = intersectionGeometry.geometry();
auto geoIn = elementInside.geometry();
auto geoOut = elementOutside.geometry();

// Geometries of intersection in local coordinates
// of elementInside and elementOutside
auto geoInInside = intersectionGeometry.geometryInInside();
auto geoInOutside = intersectionGeometry.geometryInOutside();

// Intersection diameter
auto h = diameter(geo);

// Shape function values
std::vector<RangeU> phiIn(localFunctionSpaceUIn.size());
std::vector<RangeU> phiOut(localFunctionSpaceUOut.size());
std::vector<RangeV> thetaIn(localFunctionSpaceVIn.size());
std::vector<RangeV> thetaOut(localFunctionSpaceVOut.size());

// Shape function gradients on the reference element
std::vector<GradientU> localGradPhiIn(localFunctionSpaceUIn.size());
std::vector<GradientU> localGradPhiOut(localFunctionSpaceUOut.size());
std::vector<GradientV> localGradThetaIn(localFunctionSpaceVIn.size());
std::vector<GradientV> localGradThetaOut(localFunctionSpaceVOut.size());

// Shape function gradients on the grid element
std::vector<GradientU> gradPhiIn(localFunctionSpaceUIn.size());
std::vector<GradientU> gradPhiOut(localFunctionSpaceUOut.size());
std::vector<GradientV> gradThetaIn(localFunctionSpaceVIn.size());
std::vector<GradientV> gradThetaOut(localFunctionSpaceVOut.size());

~~~


紧接着开始正交循环，首先计算试验基函数$\left\{\phi_{i}^{\mathrm{in}}\right\}_{i}$和$\left\{\phi_{i}^{\text {out }}\right\}_{i}$以及测试基函数$\left\{\theta_{i}^{\mathrm{in}}\right\}_{i}$和$\left\{\theta_{i}^{\text {out }}\right\}_{i}$在当前正交点的数值和梯度。



~~~C++
auto quadOrder = 2 * localFunctionSpaceUIn.finiteElement().localBasis().order();
constexpr auto intersectionDim = IntersectionGeometry::mydimension;
const auto &quadRule = QuadratureRules<double, intersectionDim>::
    rule(intersectionGeometry.geometry().type(),
         quadOrder);

for (const auto &quadPoint : quadRule)
{
    // Position of quadrature point in local coordinates
    // of inside and outside elements
    auto quadPointLocalIn = geoInInside.global(quadPoint.position());
    auto quadPointLocalOut = geoInOutside.global(quadPoint.position());

    // Evaluate shape functions
    localFunctionSpaceUIn.finiteElement().localBasis().evaluateFunction(quadPointLocalIn, phiIn);
    localFunctionSpaceUOut.finiteElement().localBasis().evaluateFunction(quadPointLocalOut, phiOut);

    localFunctionSpaceVIn.finiteElement().localBasis().evaluateFunction(quadPointLocalIn, thetaIn);
    localFunctionSpaceVOut.finiteElement().localBasis().evaluateFunction(quadPointLocalOut, thetaOut);

    // Evaluate gradients of shape functions
    localFunctionSpaceUIn.finiteElement().localBasis().evaluateJacobian(quadPointLocalIn,
                                                                        localGradPhiIn);
    localFunctionSpaceUOut.finiteElement().localBasis().evaluateJacobian(quadPointLocalOut,
                                                                         localGradPhiOut);

    localFunctionSpaceVIn.finiteElement().localBasis().evaluateJacobian(quadPointLocalIn,
                                                                        localGradThetaIn);
    localFunctionSpaceVOut.finiteElement().localBasis().evaluateJacobian(quadPointLocalOut,
                                                                         localGradThetaOut);

    // Transform gradients of shape functions to element coordinates
    auto jacInvTranspIn = geoIn.jacobianInverseTransposed(quadPointLocalIn);
    for (size_type i = 0; i < localFunctionSpaceUIn.size(); i++)
        jacInvTranspIn.mv(localGradPhiIn[i][0], gradPhiIn[i][0]);
    for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
        jacInvTranspIn.mv(localGradThetaIn[i][0], gradThetaIn[i][0]);

    auto jacInvTranspOut = geoOut.jacobianInverseTransposed(quadPointLocalOut);
    for (size_type i = 0; i < localFunctionSpaceUOut.size(); i++)
        jacInvTranspOut.mv(localGradPhiOut[i][0], gradPhiOut[i][0]);
    for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
        jacInvTranspOut.mv(localGradThetaOut[i][0], gradThetaOut[i][0]);
~~~



这都与`alpha_skeleton`方法非常相似。

然后，四个循环用$\mathcal{R}_{\gamma}^{\mathrm{SIPG}, \text { skel }}\left(\bar{u}^{\mathrm{in}}\right)$和$\mathcal{R}_{\gamma}^{\mathrm{SIPG}, \mathrm{skel}}\left(\bar{u}^{\text {out }}\right)$相对于$\bar{u}^{\mathrm{in}}$和$\bar{u}^{\text {out }}$的条目的导数填充结果的四个子矩阵，如表达式\ref{11.19a}-\ref{11.19d}。


~~~C++
        // Unit normal from T_in to T_out
        auto n_F = intersectionGeometry.unitOuterNormal(quadPoint.position());

        // Integration factor
        auto factor = quadPoint.weight() * geo.integrationElement(quadPoint.position());

        // Fill jacobianInIn
        for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
        {
            for (size_type j = 0; j < localFunctionSpaceUIn.size(); j++)
            {
                jacobianInIn.accumulate(localFunctionSpaceVIn,
                                        i,
                                        localFunctionSpaceUIn,
                                        j,
                                        (-0.5 * (gradPhiIn[j][0] * n_F) * thetaIn[i] - 0.5 * phiIn[j] *         (gradThetaIn[i][0] * n_F) + (kappa_ / h) * phiIn[j] * thetaIn[i]) *         factor);
            }
        }

        // Fill jacobianInOut
        for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
        {
            for (size_type j = 0; j < localFunctionSpaceUIn.size(); j++)
            {
                jacobianInOut.accumulate(localFunctionSpaceVIn,
                                         i,
                                         localFunctionSpaceUOut,
                                         j,
                                         (-0.5 * (n_F * gradPhiOut[j][0]) * thetaIn[i] + 0.5 * phiOut[j] *      (n_F * gradThetaIn[i][0]) - (kappa_ / h) * phiOut[j] * thetaIn[i])      * factor);
            }
        }

        // Fill jacobianOutIn
        for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
        {
            for (size_type j = 0; j < localFunctionSpaceUOut.size(); j++)
            {
                jacobianOutIn.accumulate(localFunctionSpaceVOut,
                                         i,
                                         localFunctionSpaceUIn,
                                         j,
                                         (0.5 * (n_F * gradPhiIn[j][0]) * thetaOut[i] - 0.5 * phiIn[j] *        (n_F * gradThetaOut[i][0]) - (kappa_ / h) * phiIn[j] * thetaOut[i]  ) * factor);
            }
        }

        // Fill jacobianOutOut
        for (size_type i = 0; i < localFunctionSpaceVOut.size(); i++)
        {
            for (size_type j = 0; j < localFunctionSpaceUOut.size(); j++)
            {
                jacobianOutOut.accumulate(localFunctionSpaceVOut,
                                          i,
                                          localFunctionSpaceUOut,
                                          j,
                                          (0.5 * (n_F * gradPhiOut[j][0]) * thetaOut[i] + 0.5 * phiOut[j] *         (n_F * gradThetaOut[i][0]) + (kappa_ / h) * phiOut[j] * thetaOut        [i]) * factor);
            }
        }
    }
}

~~~




至此，`jacobian_skeleton`方法结束。

反应-扩散问题的`LocalOperator`实现的最后一个方法是`alpha_boundary`和`jacobian_boundary`，它们分别计算`Neumann`边界项$-\int_{\partial \Omega} \mathrm{j} \theta d s$和其`Jacobian`。它们比骨架项的方法简单得多，因为它们只涉及一个元素。此外，由于`Neumann`项不依赖于$u_{h}$，所以根本不使用试验函数空间`localFunctionSpaceUIn`。


~~~C++
// Boundary integral implementing the Neumann term
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void alpha_boundary(const IntersectionGeometry &intersectionGeometry,
                    const LocalFunctionSpaceU &localFunctionSpaceUIn,
                    const Vector &xIn,
                    const LocalFunctionSpaceV &localFunctionSpaceVIn,
                    Residual &residualIn) const
{
    using TestFE = typename LocalFunctionSpaceV::Traits::FiniteElementType;
    using RangeV = typename TestFE::Traits::LocalBasisType::Traits::RangeType;
    using size_type = typename LocalFunctionSpaceV::Traits::SizeType;

    // Get geometry of intersection in local coordinates of element_inside
    auto geoInInside = intersectionGeometry.geometryInInside();

    std::vector<RangeV> thetaIn(localFunctionSpaceVIn.size());

    // Loop over quadrature points
    const int quadOrder = 2 * localFunctionSpaceVIn.finiteElement().localBasis().order();
    constexpr auto intersectionDim = IntersectionGeometry::mydimension;
    const auto &quadRule = QuadratureRules<double, intersectionDim>::
        rule(intersectionGeometry.geometry().type(),
             quadOrder);

    for (const auto &quadPoint : quadRule)
    {
        // Position of quadrature point in local coordinates of elements
        auto quadPointLocalIn = geoInInside.global(quadPoint.position());

        // Evaluate basis functions
        localFunctionSpaceVIn.finiteElement().localBasis().evaluateFunction(quadPointLocalIn, thetaIn);

        // Integration factor
        auto factor = quadPoint.weight() * intersectionGeometry.geometry()
                                               .integrationElement(quadPoint.position());

        // Evaluate Neumann boundary condition
        auto neumannValue = neumann_(intersectionGeometry.geometry()
                                         .global(quadPoint.position()));

        // Integrate
        for (size_type i = 0; i < localFunctionSpaceVIn.size(); i++)
            residualIn.accumulate(localFunctionSpaceVIn,
                                  i,
                                  -1 * neumannValue * thetaIn[i] * factor);
    }
}

~~~





更重要的是，`Neumann`项相对于$u_{h}$的导数消失了，`jacobian_boundary`方法可以简单地成为空。

~~~C++
 template<class IntersectionGeometry,
    class LocalFunctionSpaceU, class Vector,
    class LocalFunctionSpaceV, typename Jacobian>
 void jacobian_boundary(const IntersectionGeometry& intersectionGeometry,
        const LocalFunctionSpaceU& localFunctionSpaceUIn,
        const Vector& xIn,
        const LocalFunctionSpaceV& localFunctionSpaceVIn,
        Jacobian& jacobianInIn) const
 {
    // Does not do anything---the Jacobian of the boundary term is zero.
 }

~~~


然而，请注意，不能简单地撇开该方法。由于`doAlphaBoundary`标志被设置，`GridOperator`假定该方法是存在的。从代码中完全省略它，会导致编译时错误。




\textbf{Running the Program}

当程序运行时，它打印出以下屏幕输出。

~~~Shell
=== matrix setup (max) 0.0141681 s
=== matrix assembly (max) 0.040603 s
=== residual assembly (max) 0.0111276 s
=== solving (reduction: 1e-10) === Dune::IterativeSolver
Iter Defect Rate
0 1.18145
1 0.558789 0.472969
2 0.353185 0.632054
3 0.292861 0.829199
4 0.0752357 0.256899
[...]
18 1.88705e-09 0.279193
19 4.09746e-10 0.217135
20 9.82223e-11 0.239715
=== rate=0.313321, T=0.0352053, TIT=0.00176027, IT=20
0.0531138 s

~~~~



它还将一个名为 ` pdelab-dg-diffusion-result.vtu` 的文件写入磁盘，其中包含子采样结果函数 $u_{h}$ 。[Fig11.5]左侧显示了作为高度场的结果的可视化。可以清楚地看到有限元解决方案的不连续性。同一个图的右边显示了使用更细的网格运行程序时的结果。正如DG理论所预测的那样，不连续性随着网格分辨率的增加而减少。

\subsection{Dirichlet Boundary Conditions}

在本章之前的所有例题中，我们有意省略了`Dirichlet`边界条件，即形式为的约束条件

$$
u=\mathrm{g} \quad \text { on } \Gamma_{D}
$$





对于域边界$\partial \Omega$的子集$\Gamma_{D}$上的给定函数$\mathrm{g}$ 。现在我们补上这一点。

在`dune-pdelab`、`Dirichlet`中，边界条件被作为一个更普遍的机制的特例来实现，该机制允许对有限元函数的系数应用任意的线性约束。这有一些有趣的应用，比如在不符合要求的网格上构造符合要求的有限元空间，符合要求的$p$自适应方法，以及周期性边界条件。然而，为了限制本书的总体篇幅，将只讨论`Dirichlet`边界条件。对更一般的约束条件感兴趣的读者应该查阅在线文档。

\subsubsection{Dirichlet Boundary Conditions and the Residual Form}

非零的`Dirichlet`边界条件不适合第11.2.1章的框架，因此我们略作概括。让$\Omega$是$\mathbb{R}^{d}$的一个开放的有界子集，而$f: \Omega \rightarrow \mathbb{R}$是一个具有足够平滑性的给定函数。与第11.2.1章一样，我们寻找一个函数$u: \Omega \rightarrow \mathbb{R}$来解决方程

$$
-\operatorname{div} \mathcal{A}(x, u, \nabla u)+h(u)=f \quad \text { in } \Omega \subset \mathbb{R}^{d}
$$

其中$\mathcal{A}: \Omega \times \mathbb{R} \times \mathbb{R}^{d} \rightarrow \mathbb{R}^{d}$是一阶椭圆微分算子的代数表示，而$h: \mathbb{R} \rightarrow \mathbb{R}$是描述反应项的函数。与第$11.2.1$章相比，我们将领域边界划分为两部分$\Gamma_{D}$和$\Gamma_{N}$，我们用混合条件代替纯`Neumann`边界条件\ref{11.2b}。

\begin{equation}
u =\mathrm{g} \quad \quad \text { on } \Gamma_{D} 
\label{11.20a}
\end{equation}

\begin{equation}
\langle\mathcal{A}(x, u, \nabla u), \mathbf{n}\rangle &=\mathrm{j} & & \text { on } \Gamma_{N}
\label{11.20b}
\end{equation}


其中$g: \Gamma_{D} \rightarrow \mathbb{R}$是一个给定的`Dirichlet`具有足够平滑性的边界值函数。

为了说明这个问题的弱形式，我们引入新的`Sobolev`空间

$$
H_{D, \mathrm{~g}}^{1}:=\left\{v \in H^{1}(\Omega): v=\mathrm{g} \text { on } \Gamma_{D}\right\}
$$

和

$$
H_{D, 0}^{1}:=\left\{v \in H^{1}(\Omega): v=0 \text { on } \Gamma_{D}\right\}
$$

边界条件应在痕迹[^37] [^42]的意义上理解。使用标准程序，我们发现模型问题的弱形式为

\begin{equation}
\begin{aligned}
\text { Find } u \in H_{D, \mathrm{~g}}^{1}: \int_{\Omega}\langle\mathcal{A}(x, u, \nabla u), \nabla v\rangle d x &+\int_{\Omega} h(u) v d x \\
&=\int_{\Omega} f v d x+\int_{\Gamma_{N}} \mathrm{j} v d s \quad \forall v \in H_{D, 0}^{1}
\end{aligned}
\end{equation}

这个方程的`residual`形式是

\begin{equation}
\text { Find } u \in H_{D, \mathrm{~g}}^{1}: \quad r(u, v)=0 \quad \forall v \in H_{D, 0}^{1}
\label{11.21}
\end{equation}


与

$$
r(u, v):=\int_{\Omega}\langle\mathcal{A}(x, u, \nabla u), \nabla v\rangle d x+\int_{\Omega} h(u) v d x-\int_{\Omega} f v d x-\int_{\Gamma_{N}} \mathrm{j} v d s
$$

这个问题不属于\ref{11.5}类型，因为解$u$不是从线性空间中提取的。然而，空间$H_{D, g}^{1}$是仿生的，因此对于任何$w_{\mathrm{g}} \in H_{D, \mathrm{~g}}^{1}$都可以写成$H_{D, \mathrm{~g}}^{1}=w_{\mathrm{g}}+H_{D, 0}^{1}$ 。利用这一点，`residual`的表述\ref{11.21}可以只用线性空间重新表述。我们得到

$$
\text { Find } \tilde{u} \in H_{D, 0}^{1}: \quad r\left(w_{\mathrm{g}}+\tilde{u}, v\right)=0 \quad \forall v \in H_{D, 0}^{1}
$$

为了离散化问题，我们选择两个有限元空间$U_{h}$和$V_{h}$分别作为试验和测试函数。函数$w_{\mathrm{g}}$由一个离散函数$w_{h, \mathrm{~g}}$来近似。通常，$w_{h, \mathrm{~g}}$在`Dirichlet`边界上近似于$\mathrm{g}$，而在远离该边界的地方为零。

为了允许不符合要求的有限元，即有限元空间$U_{h}, V_{h}$不是$H_{D, 0}^{1}$的子空间，我们正式用离散近似`residual`代替$r_{h}$ 。如前所述，`residual`形式$r_{h}: U_{h} \times V_{h} \rightarrow \mathbb{R}$在其第一个参数中可能是非线性的，但在其第二个参数中总是线性的。总之，我们得到了仿射`residual`形式，它概括了假设11.1给出的线性形式。

\textbf{Assumption} 11.3 所有相关的边界值问题都可以写成以下形式

\begin{equation}
\text { Find } u_{h} \in w_{h, \mathrm{~g}}+U_{h}: \quad r_{h}\left(u_{h}, v_{h}\right)=0 \quad \forall v_{h} \in V_{h}
\label{11.22}
\end{equation}

对于合适的向量空间 $U_{h}, V_{h}$ 、函数 $w_{h, \mathrm{~g}}$ 和形式 $r_{h}(\cdot, \cdot)$ 。

我们再次假设$U_{h}, V_{h}, w_{h, \mathrm{~g}}$ ，和$r_{h}(\cdot, \cdot)$是这样的：\ref{11.22}至少有一个解。

在`dune-pdelab`中，像`Dirichlet`这样具有同质$H_{D, 0}^{1}$边界条件的空间离散化被称为约束空间，因为它们被看作是$H^{1}$这样的 "完整 "空间与$v=0$上的同质线性代数约束的结合。迭代方法（如`Newton`方法，它是解决非线性系统\ref{11.22}的标准方法，当从初始迭代$w_{h, \mathrm{~g}}$开始时，如果在具有同质`Dirichlet`边界条件的空间中计算校正，将产生具有正确边界条件的迭代结果。

仿生`dune-pdelab`公式的实现分两步进行。它首先需要一个代表应用于有限元空间的约束类型的类。`dune-pdelab`模块提供了几种选择；以前的例子使用了

~~~C++
PDELab::NoConstraints
~~~

其中规定了没有约束。对于`Dirichlet`边界条件的适当类型是

~~~C++
PDELab::ConformingDirichletConstraints
~~~

这两种类型都是作为标签类使用的。不期望用户构造这种类型的对象；相反，该类型被用来对`GridFunctionSpace`类进行参数化。例如，具有`Dirichlet`约束的一阶`Lagrange`空间的`GridFunctionSpace`对象的设置代码是。

~~~C++
using Basis = Functions::LagrangeBasis<GridView, 1>;
auto basis = std::make_shared<Basis>(gridView);

using VectorBackend = PDELab::ISTL::VectorBackend<>;
using Constraints = PDELab::ConformingDirichletConstraints;

using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                  VectorBackend,
                                                                  Constraints>;

GridFunctionSpace gridFunctionSpace(basis);
~~~



其次，实现需要有一个所谓的`ConstraintsContainer object`，用来存储实际的约束。由于`dune-pdelab`中的约束是线性的，`ConstraintsContainer`可以被概念化为一个稀疏的矩阵。这个矩阵的内核正是由那些满足约束条件的系数向量组成。与上面的`Constraints`标签类不同，用户程序应该自己创建一个`ConstraintsContainer`对象。准确的类型由`GridFunctionSpace`类导出为

~~~C++
template<class T>
class GridFunctionSpace::ConstraintsContainer<T>::Type
~~~

其中$\mathrm{T}$是用于存储约束矩阵条目的数字类型。在下一节示例代码的第86行中给出了如何访问该类型的例子。限制条件的组装是由自由方法触发的

~~~C++
template <class Predicate, class GridFunctionSpace, class ConstraintsContainer>
void PDELab::constraints(const Predicate &predicate,
                         const GridFunctionSpace &gridFunctionSpace,
                         ConstraintsContainer &constraintsContainer,
                         const bool verbose = false)
~~~



类型`Predicate`必须是一个谓词类，它决定了受限自由度的集合。对于类型`ConformingDirichletConstraints`的约束，它必须实现一个方法

~~~C++
template <class IntersectionGeometry>
bool isDirichlet(const IntersectionGeometry &intersection,
                 const IntersectionGeometry::Geometry::LocalCoordinate &xi)
    const
~~~


如果边界交叉点上坐标为xi的点是`Dirichlet`边界$\Gamma_{D}$的一部分，返回true。

然后在构建`ConstraintsContainer`时，`Grid0perator`的类型和对象必须被移交出去。为此，该类有一个扩展的模板签名

~~~C++
template <class GridFunctionSpaceU, class GridFunctionSpaceV,
          class LocalOperator,
          class MatrixBackend,
          class DomainNumberType, class RangeNumberType,
          class JacobianNumberType,
          class ConstraintsU = PDELab::NoConstraints,
          class ConstraintsV = PDELab::NoConstraints>
class GridOperator
~~~


`ConstraintsContainer`试验和测试空间的对象就可以交给一个专门的构造器了。

~~~C++
GridOperator(const GridFunctionSpaceU &gridFunctionSpaceU,
             const ConstraintsContainerU &constraintsContainerU,
             const GridFunctionSpaceV &gridFunctionSpaceV,
             const ConstraintsContainerV &constraintsContainerV,
             LocalOperator &localOperator,
             const MatrixBackend &matrixBackend = MatrixBackend())
~~~


`GridOperator`用这个构造函数设置的对象将在受限空间中组装代数有限元问题。

设置具有`Dirichlet`约束的代数有限元问题的最后一步是设置或修改初始迭代，使其满足`Dirichlet`边界条件。这通常是通过将`Dirichlet`值函数$w_{\mathrm{g}}$投影到空间$U_{h}$来实现的。虽然`dune-pdelab`提供了这样的方法，但本书的所有例子都直接使用`dune-functions`的相应功能（10.6.3章）。具体做法见第$11.3 .2$章中的例子。

除了具有约束意识的`GridFunctionSpace`和`GridOperator`对象，`dune-pdelab`模块为处理`Dirichlet`约束提供了一系列进一步的有用功能。例如，方法

~~~C++
template <class ConstraintsContainer, class VectorContainer>
void set_constrained_dofs(const ConstraintsContainer &constraintsContainer,
                          VectorContainer::ElementType v,
                          VectorContainer &vector)
~~~




将系数向量`vector`的所有约束项设置为标量值$\mathrm{v}$ 。对象`constraintsContainer`是描述`Dirichlet`约束的约束容器。类型`VectorContainer`是由当前线性代数后端（第11.4章）决定的数组类型，`VectorContainer::ElementType`是相应的数字类型。类似地，该方法

~~~C++
template <class ConstraintsContainer, class VectorContainer>
void copy_constrained_dofs(const ConstraintsContainer &constraintsContainer,
                           const VectorContainer &xIn, VectorContainer &xOut)
~~~


只将受约束的自由度从矢量$\mathrm{xIn}$复制到矢量`xOut`。反之，这些方法

~~~C++
template <class ConstraintsContainer, class VectorContainer>
void set_nonconstrained_dofs(const ConstraintsContainer &constraintsContainer,
                             VectorContainer::ElementType v,
                             VectorContainer &vector)
~~~


和

~~~C++
template <class ConstraintsContainer, class VectorContainer>
void copy_nonconstrained_dofs(const ConstraintsContainer &constraintsContainer,
                              const VectorContainer &xIn,
                              VectorContainer &xOut)
~~~



对无约束的自由度做同样的处理。进一步的方便方法在文件 `dune/pdelab/constraints/common/constraints.hh` 中定义。更多细节见其在线文档。

\subsubsection{Example: The Poisson Equation with `Dirichlet` Boundary Conditions}

为了演示如何在`Dirichlet`中实现`dune-pdelab`的边界条件，我们重新审视第3.3章的泊松例子。那一章的实现只使用了`dune-functions`和一个手写的汇编程序，而我们现在使用了`dune-pdelab`的全部基础结构。这使得代码明显缩短。

要解决的问题是`Poisson`方程

\begin{equation}
-\Delta u=-5
\label{11.23}
\end{equation}

在$L$形域$\Omega=(0,1)^{2} \backslash[0.5,1)^{2}$上，具有`Dirichlet`的边界条件

\begin{equation}
u=\mathrm{g}:= \begin{cases}0 & \text { on }\{0\} \times[0,1] \cup[0,1] \times\{0\} \\ 0.5 & \text { on }\{0.5\} \times[0.5,1] \cup[0.5,1] \times\{0.5\}\end{cases}
\label{11.24}
\end{equation}

和边界其余部分的均质`Neumann`条件。域和边界条件已经在 [Fig3.1] 中显示，网格可以在 [Fig3.2] 中看到。这个新例子的完整源代码包含在一个文件中，打印在附录B.14中。本文电子版的读者也可以通过点击边缘的图标访问该文件。该文件只包含主方法和一个名为PoissonProblem的小参数类。组合`Poisson`问题\ref{11.23}的弱形式的局部算子由`dune-pdelab`提供，其形式为名为`Local0perator`的实现（在头文件`dune/pdelab/localoperator/convectiondiffusionfem.hh`）。参数类被用来控制这个LocalOperator的实现。它派生自`PDELab::ConvectionDiffusionModelProblem`，并为源项和边界条件的类型实现了方法。

~~~C++
template <class GridView, class Range>
class PoissonProblem
    : public PDELab::ConvectionDiffusionModelProblem<GridView, Range>
{
public:
    using Traits = typename PDELab::ConvectionDiffusionModelProblem<GridView, Range>::
        Traits;
    // Source term
    auto f(const typename Traits::ElementType &element,
           const typename Traits::DomainType &xi) const
    {
        return -5.0;
    }

    //! Boundary condition type function
    auto bctype(const typename Traits::IntersectionType &intersection,
                const typename Traits::IntersectionDomainType &xi) const
    {
        auto x = intersection.geometry().global(xi);
        return (x[0] < 1e-8 || x[1] < 1e-8 || (x[0] > 0.4999 && x[1] > 0.4999))
                   ? PDELab::ConvectionDiffusionBoundaryConditions::Dirichlet
                   : PDELab::ConvectionDiffusionBoundaryConditions::Neumann;
    }
};

~~~


该类接收模板参数，代表网格视图和用于函数值的数字类型。它导出了一个叫做`Traits`的类型，它又导出了本地操作者所需的编译时信息。

方法$f$需要一个网格元素和该元素中的一个局部位置。在这个特定的实现中，它总是返回数字 $-5$ ，这是方程 \ref{11.23} 的右侧。第二个方法 `bctype` 实现了将域边界 $\partial \Omega$ 分割为两个部分 $\Gamma_{D}$ 和 $\Gamma_{N}$ 。它接收一个边界交点和该交点上的局部位置xi，并返回一个枚举值 `Dirichlet` 或 `Neumann` 。(这些枚举值存在于`PDELab::ConvectionDiffusionBoundaryConditions`命名空间中。)`alpha_boundary`的`ConvectionDiffusionFEM`方法只会在bctype返回`Neumann`的交点上集合`Neumann`的贡献，即使我们的具体例子没有非零的`Neumann`贡献，但正确实现分割会更干净。这里的特殊代码实现了 \ref{11.24} 中给出的分区。

`main`方法首先设置MPI，从`GMSH`文件中创建非结构化网格，并对该网格进行两次全局细化。

~~~C++
int main(int argc, char *argv[])
{
    // Initialize MPI, if available
    MPIHelper::instance(argc, argv);

    constexpr int dim = 2;
    using Grid = UGGrid<dim>;
    std::shared_ptr<Grid> grid = GmshReader<Grid>::read("l-shape.msh");

    grid->globalRefine(2);

    using GridView = Grid::LeafGridView;
    GridView gridView = grid->leafGridView();

~~~


到目前为止，与没有`Dirichlet`约束的例子没有区别。然后，下一个代码块设置了受限网格函数空间。它将被用于试验和测试函数，因此对应于第11.3.1章的约束线性空间$U_{h}=V_{h} \subset H_{D, 0}^{1}$。

~~~C++
using Basis = Functions::LagrangeBasis<GridView, 1>;
auto basis = std::make_shared<Basis>(gridView);

using VectorBackend = PDELab::ISTL::VectorBackend<>;
using Constraints = PDELab::ConformingDirichletConstraints;

using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                  VectorBackend,
                                                                  Constraints>;

GridFunctionSpace gridFunctionSpace(basis);

~~~


与先前的例子相比，`GridFunctionSpace`类的第三个模板参数现在是`PDELab::ConformingDirichletConstraints`，是一个非实质性的约束汇编器对象。

接下来，使用`ConstraintsContainer`对象，对系数向量的值进行实际的线性约束组装。由于我们已经将约束类型设置为`ConformingDirichletConstraints`，因此约束容器只能容纳以下类型的约束

$$
u_{i}=0, \quad i \in \mathcal{I}
$$

其中$u_{i}$是配置向量$\bar{u} \in \mathbb{R}^{n}$的一个系数，$\mathcal{I} \subset\{0, \ldots, n-1\}$是一个索引集。因此，唯一需要的信息是这个索引集，它是从形成`Dirichlet`边界$\Gamma_{D}$的边界交点集计算出来的。为了保持一致性，它取自`PoissonProblem`类。由于谓词方法bctype是作为参数类`PoissonProblem`的成员方法来实现的，它必须通过称为`ConvectionDiffusionBoundaryConditionAdapter`的包装方法从那里提取。

~~~C++
using Problem = PoissonProblem<GridView, double>;
Problem problem;
PDELab::ConvectionDiffusionBoundaryConditionAdapter<Problem> bctype(problem);
~~~



网格函数空间导出`ConstraintsContainer`所附的类型为`GridFunctionSpace::ConstraintsContainer<double>`类型。`double`参数是用于线性约束的系数的数字类型。对约束方法的调用完成了约束矩阵的实际组装。

~~~C++
using ConstraintsContainer = GridFunctionSpace::ConstraintsContainer<double>::Type;
ConstraintsContainer constraintsContainer;
PDELab::constraints(bctype, gridFunctionSpace, constraintsContainer);
~~~



下一步是为受限的试验和测试函数空间设置一个`Grid0perator`对象。这很容易：`LocalOperator`对象是通过调用`ConvectionDiffusionFEM`构造函数与`PoissonProblem`对象获得的。

除了不受约束的代码，`Grid0perator`接收相应的`ConstraintsContainer` ，既作为模板参数又作为构造函数参数。

~~~C++
using LocalOperator = PDELab::ConvectionDiffusionFEM<Problem,
                                                     GridFunctionSpace::Traits::
                                                         FiniteElementMap>;
LocalOperator localOperator(problem);

using MatrixBackend = PDELab::ISTL::BCRSMatrixBackend<>;
MatrixBackend matrixBackend(7);

using GridOperator = PDELab::GridOperator<GridFunctionSpace,
                                          GridFunctionSpace,
                                          LocalOperator,
                                          MatrixBackend,
                                          double, double, double,
                                          ConstraintsContainer,  // For trial space
                                          ConstraintsContainer>; // For test space
GridOperator gridOperator(gridFunctionSpace,
                          constraintsContainer, // Trial space
                          gridFunctionSpace,
                          constraintsContainer, // Test space
                          localOperator,
                          matrixBackend);

~~~







`ConstraintsContainer`出现两次：一次是试验空间，一次是测试空间。

在建立了受限的有限元空间之后，代码构建了一个系数向量u来保存求解器的迭代结果，并以`Dirichlet`边界值对其进行初始化。

~~~C++
using U = PDELab::Backend::Vector<GridFunctionSpace, double>;
U u(gridFunctionSpace, 0.0);
auto g = [](auto x)
{ return (x[0] < 1e-8 || x[1] < 1e-8) ? 0 : 0.5; };
Functions::interpolate(*basis, PDELab::Backend::native(u), g);
~~~



lambda $g$ 实现了函数 $w_{\mathrm{g}}: \Omega \rightarrow \mathbb{R}$ ，其对 `Dirichlet` 边界 $\Gamma_{D}$ 的限制是 `Dirichlet` 的边界值函数 $\mathrm{g}$ 。线性求解器在$U_{h}$中计算修正，它是$H_{D, 0}^{1}$的一个子空间，因此只包含`Dirichlet`上的零值的函数。因此，所有的迭代结果都有正确的`Dirichlet`值。对 `PDELab::native` 的调用是必要的，以从 $u$ 中提取实际的 `dune-istl` 容器。详见第$11.4$章。

在这之后，设置和调用代数求解器就很简单了。

~~~C++
// Select a linear solver backend
using LinearSolverBackend = PDELab::ISTLBackend_SEQ_CG_SSOR;
LinearSolverBackend linearSolverBackend(50, 2);

// Select linear problem solver
using LinearProblemSolver = PDELab::StationaryLinearProblemSolver<GridOperator,
                                                                  LinearSolverBackend,
                                                                  U>;
LinearProblemSolver linearProblemSolver(gridOperator,
                                        linearSolverBackend,
                                        u,
                                        1e-5);
// Solve linear problem.
linearProblemSolver.apply();

~~~



同样，将结果写入VTK文件与之前的例子相比也没有变化。

~~~C++
VTKWriter<GridView> vtkwriter(gridView);
auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
    *basis,
    PDELab::Backend::native(u));
vtkwriter.addVertexData(uFunction,
                        VTK::FieldInfo("u",
                                       VTK::FieldInfo::Type::scalar,
                                       1));
vtkwriter.write("pdelab-poisson-dirichlet-result");
~~~


这就结束了对这个例子的讨论。  [Fig11.6]显示了用这个例子计算的结果的可视化。

\subsection{Linear Algebra Backends}

像`Grid0perator`类实现的有限元汇编器的结果是一个线性或非线性代数方程系统。因此，它需要数值线性代数对象的数据结构：稀疏矩阵和向量。任何有限元或有限体积代码都必须以这样或那样的形式拥有它们，它们的效率会对模拟的整体速度产生关键影响。

虽然矩阵和向量的数据结构的设计空间比有限元网格的设计空间要小一些，但还是存在相当多的不同的线性代数实现。每一种都有它的优点和缺点，不同的人为了他们的目的选择不同的库。这种情况类似于网格数据结构的选择，没有一种实现可以满足所有的需求。因此，为了做到真正的灵活，有限元软件必须不把用户捆绑在一个特定的线性代数实现上。

DUNE试图在几个层面上实现这种灵活性。来自`dune-grid`模块的网格接口一丝不苟地避免了对特定线性代数软件的要求（章$5.6$）。在更高的抽象层次上，`dune-pdelab`将装配过程与线性代数数据结构脱钩。它为矩阵和向量定义了一个抽象接口，并为这个接口提供了几个实现。在 `dune-pdelab` 的语言中，这些不同的实现被称为线性代数后端。

让`dune-istl`这个专门的DUNE线性代数模块来声明这个抽象接口会更符合DUNE的精神。然而，构建一个像`dune-istl`那样丰富和通用的接口，同时又能被一个以上的线性代数库有效地实现，证明是太困难了。`dune-pdelab`模块通过声明一个只面向单一用户的接口，摆脱了这种困境。  `dune-pdelab` .它比通用的线性代数接口更有局限性，因此可以更容易实现。`dune-pdelab` 汇编器和迭代求解器只使用这个接口的方法。这样一来，线性代数与离散化完全脱钩，即使不深入了解，也可以使用不同的线性代数库。目前，`dune-pdelab`提供了用于`dune-istl`、EIGEN库[^87]和使用$\mathrm{C}++$标准库的数据结构的后端。这些后端在本章中都有描述。

\subsubsection{The ISTL Backend}

在本书的前几章中，我们一直试图彻底地、系统地描述DUNE接口。对于线性代数的后端，我们稍稍偏离了这种方法。由于接口只存在于`dune-pdelab`中，`dune-pdelab`的用户通常只直接操纵其中的一小部分。而且，界面的所有方面都不是一成不变的，有些方面可能会在`dune-pdelab`的后期修订中发生变化。由于只有`dune-pdelab`使用这些接口，这种不稳定性通常不是一个问题。

因此，我们没有逐一讨论接口方法，而是通过讨论一个典型的用例来解释线性代数的后端。为此，我们重新审视第11.1章中介绍的线性反应-扩散方程的代码。这段代码将在本章中反复出现，每次都使用不同的线性代数后端。所有的化身都取自一个源文件，该文件已印在附录B.15中。此外，本文件的电子版包含该文件的嵌入式副本。

线性代数后端为`dune-pdelab`提供了三种东西：向量、矩阵和线性求解器。第一个例子使用ISTL后端，因为它既是最精细的，也是使用最广泛的。这个例子由一个接收网格视图和结果文件名的单一方法组成。代码的第一部分在给定的网格视图上构造二阶`Lagrange`空间的基础，并使用它来构造一个`GridFunctionSpace`，即`dune-pdelab`意义上的函数空间。


~~~C++
template <class GridView>
void solveReactionDiffusionProblemISTL(const GridView &gridView,
                                       std::string filename)
{
    // Make grid function space
    using Basis = Functions::LagrangeBasis<GridView, 2>;
    auto basis = std::make_shared<Basis>(gridView);

    using VectorBackend = PDELab::ISTL::VectorBackend<>;

    using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                      VectorBackend,
                                                                      PDELab::NoConstraints>;

    GridFunctionSpace gridFunctionSpace(basis);

~~~


这里的关键部分是第47行，它选择了向量后端，即用于系数向量的数据结构。从`PDELab::ISTL`命名空间中取出的事实是选择了`dune-istl`模块中的一个向量数据结构。目前可用于此类向量的后端是

~~~C++
template<Blocking blocking = Blocking::none, std::size_t blocksize = 1>
class VectorBackend
~~~


它从 `dune-istl` 模块中选择数据类型 `BlockVector <FieldVector <NumberType, blocksize> >` 用于系数向量，其中块大小是给 `VectorBackend` 模板的数字，而 `NumberType` 是后来由 `Grid0perator` 确定。对于第一个模板参数 `ISTL::VectorBackend` ，可以在 `Blocking::none` 、 `Blocking::bcrs` 和 `Blocking:::fixed` 之间选择，但除了默认值无外，一切都超出了本书的范围。在第51行，`VectorBackend`被赋予`GridFunctionSpace`，从那里开始，一切都会自动运行。

代码的下一部分是构建有限元汇编器，即把有限元问题变成线性代数问题的装置。

~~~C++
// Make grid operator
LinearReactionDiffusionProblem<GridView, double> problem;
using LocalOperator = PDELab::ConvectionDiffusionFEM<decltype(problem),
                                                     typename GridFunctionSpace::Traits::
                                                         FiniteElementMap>;
LocalOperator localOperator(problem);

using MatrixBackend = PDELab::ISTL::BCRSMatrixBackend<>;
using GridOperator = PDELab::GridOperator<GridFunctionSpace, // Trial function space
                                          GridFunctionSpace, // Test function space
                                          LocalOperator,     // Element assembler
                                          MatrixBackend,     // Data structure
                                          // for the stiffness matrix
                                          double, // Number type for
                                          // solution vector entries
                                          double, // Number type for
                                          // residual vector entries
                                          double>; // Number type for
// stiffness matrix entries

MatrixBackend matrixBackend(25);
GridOperator gridOperator(gridFunctionSpace,
                          gridFunctionSpace,
                          localOperator,
                          matrixBackend);

~~~





`Grid0perator`对象需要知道将刚度矩阵装配到哪个数据结构中。第66行选择一个合适的矩阵后端。对于`ISTL`后端，标准选择是

~~~C++
template<class EntriesPerRow = std::size_t>
class ISTL::BCRSMatrixBackend
~~~


其中使用一个`BCRSMatrix<FieldMatrix>`作为底层容器。数字类型由网格操作员设置；它是`Grid0perator`模板列表中的第七个条目。

矩阵后端的类型被用于构建全局装配器，由`Grid0perator`类实现。这并不令人惊讶：全局汇编器必须知道它所汇编的矩阵类型。它也需要知道矢量类型，但它并不直接接收它们：而是由两个`GridFunctionSpace`对象移交矢量类型。

向量后端是通过选择一个特定的$\mathrm{C}++$类型来选择的。相比之下，人们可能要构建一个`MatrixBackend`对象，并把它交给`Grid0perator` 。这允许给`MatrixBackend`额外的信息。例如，`dune-istl`矩阵后端需要估算每行矩阵条目的平均数量，因为它在内部使用第7.3.2章的隐式构建模式。这与实施有关；其他后端可能需要这里的不同信息。最后，代码选择一个线性求解器，并求解产生的线性系统。

~~~C++
// Select vector data type to hold the iterates
using VectorContainer = PDELab::Backend::Vector<GridFunctionSpace, double>;
VectorContainer u(gridFunctionSpace, 0.0); // Initial iterate

// Select a linear solver backend
using LinearSolverBackend = PDELab::ISTLBackend_SEQ_CG_SSOR;
LinearSolverBackend linearSolverBackend(5000, // Maximal number
                                             // of iterations
                                        2); // Verbosity level

// Solve linear problem
using LinearProblemSolver = PDELab::StationaryLinearProblemSolver<GridOperator,
                                                                  LinearSolverBackend,
                                                                  VectorContainer>;
LinearProblemSolver linearProblemSolver(gridOperator,
                                        linearSolverBackend,
                                        u,
                                        1e-10);
linearProblemSolver.apply();

~~~



第89行设置了保存迭代求解器的当前迭代的容器。它的精确类型是由矢量后端决定的。本例中使用的ISTL矢量后端在内部使用了一个具有正确的`BlockVector <FieldVector>`大小的`FieldVector`。第93-96行选择线性求解器后端，在本例中是一个（连续的）共轭梯度算法，由`SSOR`方法[^138]作为前提条件。其他选择是 `ISTLBackend_SEQ_BCGS_SSOR` ，一个稳定的双共轭梯度方法，具有相同的前置条件，以及 `ISTLBackend_SEQ_SuperLU` ，它使用直接稀疏解算器 `SUPERLU` [^116] 。[Tab11.2]中列出了可用的求解器后端。此外，还有并行求解器的选择，但这超出了本书的范围。

线性求解器后端对象需要由用户创建，通常它需要一些与实现相关的设置。在本例中，这些数字是最大的迭代次数，以及粗略程度。然后，线性求解器的后端类型和对象都被交给`StationaryLinearProblemSolver`类，该类组装问题并调用线性求解器。线性求解器后端实现的精确接口通常不会被用户看到，因为它只被 `StationaryLinearProblemSolver` 和 `Newton` 求解器使用。

为了完整起见，我们展示了这个例子的最后部分，即把结果写入一个VTK文件。这样的代码已经在本章前面的例子中出现过几次。请注意，来自`dune-functions`的`makeDiscreteGlobalBasisFunction`需要一个实际的数组，而不是`dune-pdelab`的矢量后端对象。自由方法


~~~C++
NativeVector& PDELab::Backend::native(const VectorContainer& u)
~~~


从矢量后端产生一个`dune-istl`矢量。关于这种直接访问的更多内容，将在第11.4.3章给出。


~~~C++
    // Output as VTK file
    SubsamplingVTKWriter<GridView> vtkwriter(gridView, refinementLevels(2));
    auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
        *basis,
        PDELab::Backend::native(u));
    vtkwriter.addVertexData(uFunction,
                            VTK::FieldInfo("u",
                                           VTK::FieldInfo::Type::scalar,
                                           1));
    vtkwriter.write(filename);
}
~~~

这标志着 `solveReactionDiffusionProblemISTL` 方法的结束。下面几节将讨论它的变化，即使用其他线性代数后端。



\subsubsection{The Eigen Backend}

`Eigen` 后台使用MPL2授权的线性代数库EIGEN [^87] 。EIGEN非常重视执行速度，并大量使用表达式模板 [^1] [^156] 。

`Eigen`后端提供一个矢量后端和一个矩阵后端。矢量后端是

~~~C++
class PDELab::EigenVectorBackend
~~~

并且不提供任何参数。在内部，它使用

~~~C++
Eigen::Matrix<double, Eigen::Dynamic, 1>
~~~


来自EIGEN库的数据结构（一个具有动态行数的单列矩阵）。这是密集向量的标准EIGEN类型。

矩阵的后端是

~~~C++
template<int Options = Eigen::RowMajor>
class PDELab::EigenMatrixBackend
~~~



它使用EIGEN库中的`SparseMatrix`矩阵类，它是一个以`compressed-row-storage`格式的变体存储的稀疏矩阵。`Options`参数是直接交给EIGEN的。它选择了矩阵内部使用行为主还是列为主的存储方式。

`Eigen`后端还包裹了EIGEN库中的几个稀疏线性求解器。[Tab11.3]中列出了一些选择。`_Up`和`_Lo`的后缀表示是否将`Eigen::upper`或`Eigen::lower`标志传递给底层EIGEN求解器。这些标志表明三角分解是在矩阵的上三角还是下三角部分进行的。每个求解器后端都有一个构造函数，它将最大的迭代次数作为其单一参数。

将反应-扩散的例子从`ISTL`的后端切换到EIGEN的对应版本只需要一些小的改动，这表明了后端概念的优势。为了完整起见，我们在此打印整个修改后的方法。唯一的区别是在第136、153和179行，在这里选择了矢量、矩阵和求解器的后端。至于`ISTL`后端，`MatrixBackend`对象需要被赋予每行非零条目的预期平均数。

~~~C++
template <class GridView>
void solveReactionDiffusionProblemEigen(const GridView &gridView,
                                        std::string filename)
{
    // Make grid function space
    using Basis = Functions::LagrangeBasis<GridView, 2>;
    auto basis = std::make_shared<Basis>(gridView);

    using VectorBackend = PDELab::Eigen::VectorBackend;

    using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                      VectorBackend,
                                                                      PDELab::NoConstraints>;

    GridFunctionSpace gridFunctionSpace(basis);

    // Make grid operator
    LinearReactionDiffusionProblem<GridView, double> problem;
    using LocalOperator = PDELab::ConvectionDiffusionFEM<decltype(problem),
                                                         typename GridFunctionSpace::Traits::
                                                             FiniteElementMap>;
    LocalOperator localOperator(problem);

    using MatrixBackend = PDELab::Eigen::MatrixBackend<>;
    using GridOperator = PDELab::GridOperator<GridFunctionSpace, // Trial function space
                                              GridFunctionSpace, // Test function space
                                              LocalOperator,     // Element assembler
                                              MatrixBackend,     // Data structure
                                              // for the stiffness matrix
                                              double, // Number type for
                                              // solution vector entries
                                              double, // Number type for
                                              // residual vector entries
                                              double>; // Number type for
    // stiffness matrix entries

    MatrixBackend matrixBackend(25);
    GridOperator gridOperator(gridFunctionSpace,
                              gridFunctionSpace,
                              localOperator,
                              matrixBackend);

    // Select vector data type to hold the iterate
    using VectorContainer = PDELab::Backend::Vector<GridFunctionSpace, double>;
    VectorContainer u(gridFunctionSpace, 0.0); // Initial iterate

    // Select a linear solver backend
    using LinearSolverBackend = PDELab::EigenBackend_CG_Diagonal_Up;
    LinearSolverBackend linearSolverBackend(5000);

    // Solve linear problem
    using LinearProblemSolver = PDELab::StationaryLinearProblemSolver<GridOperator,
                                                                      LinearSolverBackend,
                                                                      VectorContainer>;
    LinearProblemSolver linearProblemSolver(gridOperator,
                                            linearSolverBackend,
                                            u,
                                            1e-10);
    linearProblemSolver.apply();

    // Output as VTK file
    SubsamplingVTKWriter<GridView> vtkwriter(gridView, refinementLevels(2));
    auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
        *basis,
        PDELab::Backend::native(u));
    vtkwriter.addVertexData(uFunction,
                            VTK::FieldInfo("u",
                                           VTK::FieldInfo::Type::scalar,
                                           1));
    vtkwriter.write(filename);
}

~~~

注意到与相应的ISTL例子的相似性。

\subsubsection{Working with the Actual Data Structures}

在目前介绍的标准用例中，很多细节都发生在幕后。线性代数库是由`dune-pdelab`控制的，而用户从来没有看到过底层的数据结构。例如，在第11.4.1章的ISTL后端例子的代码中，从来没有出现过实际的`dune-istl`向量和矩阵对象，除了在第116行，解的系数向量被交给了`dune-functions`。这当然是非常方便的。线性代数的实现只需改变几个类型定义就可以切换了。只需要最低限度的底层库的知识，而且用户代码很短。

另一方面，有时需要有更多的控制。例如，人们可能希望将嵌套的 `dune-istl` 数据结构与 `dune-istl` 中没有的求解器一起使用。对于这样的目的，可以直接访问本地数据结构。这样一来，代码就会与特定的线性代数实现捆绑在一起，但作为交换，用户会重新获得完全的控制权。

矢量的 `dune-pdelab` 抽象被称为 `vector container` 。这样的向量容器总是与一个 `GridFunctionSpace` 相关联。对于一个给定的`GridFunctionSpace`，相应的向量容器类型可以是



我们不讨论这个类的全部接口，但让我们提一下，对于任何矢量容器类型`VectorContainer`对应的一些`GridFunctionSpace`，有构造函数

~~~C++
VectorContainer(const GridFunctionSpace& gridFunctionSpace)
~~~

和

~~~C++
VectorContainer(const GridFunctionSpace& gridFunctionSpace,
                const NumberType& v) // Initialize with scalar v
~~~

允许在有或没有初始化内容的情况下构造一个系数向量。还有一个构造函数，接收一个本地的向量数据结构

~~~C++
VectorContainer(const GridFunctionSpace& gridFunctionSpace,
                Container& container)
~~~


通过这个构造函数，`VectorContainer`将使用给定的数组容器作为其存储。类型`Container`是后端实际使用的向量容器类型，没有进一步的封装。`VectorContainer`抽象还有一个用于线性代数操作的有限接口，这将在第11.4.4章中简要介绍。

为了获得对`VectorContainer`的实际数组数据结构的访问，有一个自由方法

~~~C++
template<class VectorContainer>
Vector& PDELab::Backend::native(VectorContainer& vectorContainer)
~~~


例如，假设 $\mathrm{x}$ 是 `VectorContainer` 类型的一个对象。然后写出

为其内容的引用。当使用ISTL后端时，那么xNative将是对`BlockVector <FieldVector<NumberType, blocksize> >`对象的引用，其中数字块大小由给`VectorBackend`类的模板参数决定（第11.4.1章），而`NumberType`被指定为`PDELab::Backend::Vector`类型的一部分，即。

~~~C++
using VectorContainer = PDELab::Backend::Vector<GridFunctionSpace,NumberType>;
~~~

访问本地矩阵数据结构的方式与此类似。`dune-pdelab` 矩阵的抽象被称为MatrixContainer，它总是与矩阵的域和范围空间的向量类型相联系。对于一个给定的后端来说，一个矩阵容器可以作为

~~~C++
template <class Backend,
          class VectorContainerU,
          class VectorContainerV,
          class NumberType>
class PDELab::Backend::Matrix
~~~


四个模板参数中的第一个是`MatrixBackend`类型。下面两个是`VectorContainer`类型，分别用于域空间和范围空间的向量，即分别用于可以从右边和左边乘以矩阵的向量。对于像ISTL这样的后端，这尤其意味着向量嵌套和阻塞模式是合适的。最后，第四个参数是用于标量矩阵条目的数字类型。


构建MatrixContainer对象需要一个`Grid0perator`，即一个全局装配器。以下是可用的构造函数。

~~~C++
template <class GridOperator>
MatrixContainer(const GridOperator &gridOperator) template <class GridOperator>
MatrixContainer(const GridOperator &gridOperator,
                const NumberType &v) // Initial value for all entries
template <class GridOperator>
MatrixContainer(const GridOperator &gridOperator, Container &container)
~~~


所有三个构造函数都使用`grid0perator`对象初始化了矩阵模式。第一个构造函数不初始化数值，而第二个构造函数用标量v填充所有的矩阵条目。第三个构造函数使用一个本地矩阵，并使用它来存储，而不是分配自己的矩阵。对底层矩阵数据结构的访问可以再次使用free方法。

~~~C++
template<class MatrixContainer>
Matrix& PDELab::Backend::native(MatrixContainer& matrixContainer)
~~~


在构造一个网格运算符时，必须给它一个矩阵后端，以及两个向量后端，分别用于试验和测试向量（11.2章）。反之，给定一个`Grid0perator`，向量和矩阵类型也可作为。

~~~C++
GridOperator::Traits::Domain // For primal vectors, e.g., iterates
GridOperator::Traits::Range // For dual vectors, e.g., residuals
GridOperator::Jacobian // Tangent stiffness matrix type
~~~


`GridOperator`对象有成员方法用于直接组装`residual`及其`Jacobian`。首先，该方法

~~~C++
void residual(const Domain& x, Range& r) const
~~~

在给定的配置$\bar{u} \in \mathbb{R}^{n}$下组装`residual`矢量$\mathcal{R}(\bar{u}) \in \mathbb{R}^{n}$，并将其添加到参数$r$中给出的系数矢量。两个参数 `Domain` 和 `Range` 都是 `VectorContainer` 接口的实现。请注意，根据\ref{11.8}，线性系统$A x=b$的`residual`是$r(x)=A x-b$。因此，为了得到矢量$b$，`residual`$\mathcal{R}(0)$必须乘以$-1$。同样地，该方法

~~~C++
void jacobian(const Domain& u, Jacobian& nablaR) const
~~~

在给定的配置$\bar{u} \in \mathbb{R}^{n}$下组装`Jacobian` $\nabla \mathcal{R}(\bar{u}) \in \mathbb{R}^{n \times n}$的`residual` $\mathcal{R}$ 。如果问题是线性的，那么这个方法就可以得到刚度矩阵。该结果被添加到nablaR变量中，该变量是`MatrixContainer`接口的实现。

我们展示了如何在另一个反应-扩散的例子中使用这些功能。该代码再次使用ISTL后端来组装线性代数问题，但为了解决这个问题，它直接获得了向量和矩阵数据结构，并使用它们调用了一个`dune-istl`求解器，而没有通过相应的`dune-pdelab`线性求解器后端。

由于这个例子与第11.4.1章的`dune-istl`例子非常相似，所以只讨论其中的区别。特别是，我们跳过网格函数空间和网格运算符的构造。第一个区别可以在第255行找到（对应于第11.4.1章的第89行），在这里代码为线性求解器的迭代创建了一个向量，并将其初始化为0。


~~~C++
using VectorContainer = typename GridOperator::Traits::Domain;
VectorContainer xContainer(gridFunctionSpace, 0.0);
~~~


与第89行不同的是，向量容器类型从`Grid0perator`中提取出来，进行更改。然后，调用 `Grid0perator` 来组装当前 `residual` 及其 `Jacobian` 。

~~~C++
// Evaluate residual at the zero configuration
typename GridOperator::Traits::Range rContainer(gridFunctionSpace, 0.0);

gridOperator.residual(xContainer, rContainer);

// Compute stiffness matrix
using MatrixContainer = typename GridOperator::Jacobian;
MatrixContainer matrixContainer(gridOperator, 0.0);

gridOperator.jacobian(xContainer, matrixContainer);
~~~



由于问题是线性的，矩阵实际上并不依赖于`xContainer`，但接口要求无论如何都要交出该向量容器。

对于实际求解，代码检索本地`dune-istl`数据结构，其中包含当前迭代，零点的负`residual`，以及刚度矩阵。

~~~C++
auto &x = PDELab::Backend::native(xContainer);
auto &b = PDELab::Backend::native(rContainer);
b *= -1.0;
const auto &stiffnessMatrix = PDELab::Backend::native(matrixContainer);
~~~


注意，根据\ref{11.8}，线性系统$A x=b$的`residual`是$\mathcal{R}(x)=A x-b$。因此，为了得到矢量 $b$ ，`residual` $\mathcal{R}(0)$ 必须乘以 $-1$ 。这个乘法是使用`BlockVector`接口的方法进行的。

为了后续使用，代码还为本地类型定义了名称。

~~~C++
using DomainVector = std::decay_t<decltype(x)>; // Decay from reference
// to value type
using RangeVector = std::decay_t<decltype(b)>;
using Matrix = std::decay_t<decltype(stiffnessMatrix)>;
~~~


最后，代码调用了一个本地`dune-istl`求解器。这部分代码与早期的例子类似，比如第3.3章中的例子。

~~~C++
// Turn the matrix into a linear operator
MatrixAdapter<Matrix, DomainVector, RangeVector>
    linearOperator(stiffnessMatrix);

// SSOR as the preconditioner
SeqSSOR<Matrix, DomainVector, RangeVector> preconditioner(stiffnessMatrix,
                                                          1, // Number of
                                                          // iterations
                                                          1.0); // Damping

// Preconditioned conjugate-gradient solver
CGSolver<DomainVector> cg(linearOperator,
                          preconditioner,
                          1e-4, // Desired residual reduction factor
                          50,   // Maximum number of iterations
                          2);   // Verbosity level

// Object storing some statistics about the solving process
InverseOperatorResult statistics;

// Solve!
cg.apply(x, b, statistics);
~~~



虽然这个例子与第11.4.1章的例子相比没有任何优势，但它展示了如何从`dune-pdelab`中提取组装的代数问题，以将其送入其他不相关的求解器实现。

\subsubsection{The Simple Backend}

`Simple`后端，正如其名称所言，旨在简单。它完全不使用外部线性代数软件，只依赖$\mathrm{C}++$标准库的功能。它不提供求解器，因此线性代数问题必须使用上一节的技术反馈给第三方求解器。

`Simple` 后台提供了一个单一的 `VectorContainer` ，它可以作为

~~~C++
template<class Container = Simple::default_vector>
class PDELab::Simple::VectorBackend
~~~



它在内部使用`std::vector`，但这个选择可以通过设置`Container`参数来覆盖。

有一个矩阵后端用于密集矩阵，一个用于稀疏矩阵。由于C++标准库不提供矩阵，`Simple`后端实际上包含简单的矩阵实现本身。第一个。

~~~C++
template<class Container = Simple::default_vector>
class PDELab::Simple::MatrixBackend
~~~


实现了一个密集矩阵，将其条目以`std::vector`的方式按行顺序存储。第二个是

~~~C++
template<class Container = Simple::default_vector,
        class IndexType = std::size_t>
class PDELab::Simple::SparseMatrixBackend
~~~


是一个简单的压缩行存储稀疏矩阵 [^133] 。第一个模板参数是用于所有内部数组的数组类型（同样默认为 `std::vector` ）。第二个参数是用于行和列索引的类型。

使用`Simple`后台的反应-扩散例子主要在求解器方面与其他例子不同。第一部分设置了GridFunctionSpace并选择`Simple::VectorBackend<>`作为矢量数据类型。

~~~C++
template <class GridView>
void solveReactionDiffusionProblemSimple(const GridView &gridView,
                                         std::string filename)
{
    // Make grid function space
    using Basis = Functions::LagrangeBasis<GridView, 2>;
    auto basis = std::make_shared<Basis>(gridView);

    using VectorBackend = PDELab::Simple::VectorBackend<>;

    using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                      VectorBackend,
                                                                      PDELab::NoConstraints>;

    GridFunctionSpace gridFunctionSpace(basis);

~~~





然后，代码设置了 `GridOperator` ，使用 `Simple::SparseMatrixBackend` 作为矩阵后端。

~~~C++
LinearReactionDiffusionProblem<typename Basis::GridView, double> problem;
using LocalOperator = PDELab::ConvectionDiffusionFEM<decltype(problem),
                                                     typename GridFunctionSpace::Traits::
                                                         FiniteElementMap>;
LocalOperator localOperator(problem);

using MatrixBackend = PDELab::Simple::SparseMatrixBackend<>;
using GridOperator = PDELab::GridOperator<GridFunctionSpace, // Trial function space
                                          GridFunctionSpace, // Test function space
                                          LocalOperator,     // Element assembler
                                          MatrixBackend,     // Data structure
                                          // for the stiffness matrix
                                          double, // Number type for
                                          // solution vector entries
                                          double, // Number type for
                                          // residual vector entries
                                          double>; // Number type for
// stiffness matrix entries

GridOperator gridOperator(gridFunctionSpace,
                          gridFunctionSpace,
                          localOperator);

~~~



不需要把参数交给矩阵后端，因此在用户代码中根本不需要构建矩阵后端对象。

然后代码与第11.4.3章类似：它构建了一个充满零的系数向量，并使用它来明确计算刚度矩阵和线性方程组的右侧。

~~~C++
// Vector for the iterates
typename GridOperator::Traits::Domain xContainer(gridFunctionSpace, 0.0);

// Evaluate residual at the zero vector
typename GridOperator::Traits::Range rContainer(gridFunctionSpace, 0.0);

gridOperator.residual(xContainer, rContainer);
rContainer *= -1.0;

// Compute stiffness matrix
using MatrixContainer = typename GridOperator::Traits::Jacobian;
MatrixContainer matrixContainer(gridOperator, 0.0);

gridOperator.jacobian(xContainer, matrixContainer);

~~~



同样，由于$x \in \mathbb{R}^{n}$处的`residual`是$\mathcal{R}(x)=A x-b$（见\ref{11.8}），`Jacobian`是刚度矩阵，$x=0$处的`residual`是负载荷矢量$b$ 。然而这一次，代码使用了`dune-pdelab``VectorContainer`接口的方法来计算符号变化（在第375行）。

在这一点上，我们可以提取本地数据结构并将其交给所需的求解器，如上一节所示。为了保持简短的论述，我们转而实现一个简单的阻尼`Richardson`迭代[^138]。

$$
x_{k+1}=x_{k}+\omega\left(b-A x_{k}\right) \quad \omega>0
$$

使用矢量和矩阵后台的线性代数方法。

~~~C++
double omega = 0.2;
for (int i = 0; i < 200; i++)
{
    // Damped Richardson iteration
    auto correction = rContainer;
    matrixContainer.usmv(-1.0, xContainer, correction);
    xContainer.axpy(omega, correction);
}

~~~



方法usmv是来自`dune-pdelab`矩阵容器接口的一个方法。它计算$-1 \cdot A x$，并将结果添加到向量`correction`。它不是一个来自`dune-istl`矩阵接口的方法，尽管那里存在相同的方法。

作为最后的评论，请注意编写这段代码的无矩阵变体将是多么容易。与其通过矩阵-向量乘法计算`residual`$b-A x_{k}$，还不如在每次迭代时通过调用`Grid0perator::residual`方法直接计算。然后，就完全不需要刚度矩阵了，这可能会节省大量的内存。

\subsection{Local Grid Adaptivity}

当偏微分方程的解显示出非常局部的特征时，局部网格适应性可以帮助减少计算时间而不牺牲精度。一个典型的例子是第`Poisson`章的$3.3$问题，其中$L$形域的内角导致了解决方案的奇异性。除非自由度集中在奇点周围，否则标准的`Lagrange`离散化将不会以最佳顺序收敛。在[Fig2.15]、[Fig2.19]和[Fig2.20]中已经展示了具有这种局部变化的分辨率的网格实例。


网格适应性已经在第$5.9$章中结合DUNE网格界面进行了讨论。DUNE网格接口的重点是`h-refinement` ，即分割和合并元素以控制局部分辨率（2.3.2章）。有一些接口方法用于元素的局部细化和粗化，但是网格实现不需要实现它们，因为它们对所有种类的网格数据结构都没有意义。不过，大多数可用于DUNE的非结构化网格确实支持网格适应性--更多细节在第$5.10$章中给出。

除了对网格数据结构的实际修改外，在实现局部网格适应性时，面临的挑战是如何在网格修改过程中保留附着在网格上的仿真数据。任何附加在网格上的离散函数在网格细化或粗化后（如果需要的话）仍然可以使用，并且在新的网格允许的情况下，近似质量的损失尽可能小。第$5.9$章展示了如何在网格接口的层面上做到这一点。这种方法给了程序员对数据处理、插值方法和其他算法细节的完全控制。然而，它是繁琐的，因为它在一个非常低的抽象层次上操作，即使是简单的有限元空间也需要相当多的代码。为了方便标准情况的编码，`dune-pdelab`为网格适应性和持久性函数提供了一个更高层次的接口。它提供了标准标记策略的实现，甚至为复杂的有限元空间提供了持久的有限元函数。本章简要介绍了其中的一些功能，然后讨论了一个完整的例子。

\subsubsection{Local Adaptivity in `dune-pdelab`}

在一个非常抽象的层面上，在 `dune-pdelab` 中用自适应 `h-refinement` 解决静止的PDEs，遵循经典的细化循环，这在 $2.3$ 章中已经解释过。  [Fig11.7] 显示了 `dune-pdelab` 所看到的循环。前两个步骤，`assemble`和`solve`，建立了PDE问题的代数表述，并计算其解。本章前面的部分已经展示了如何通过`dune-pdelab`来实现这一目的。`estimate`步骤做了两件事：首先，它试图估计整体误差。如果这个总体误差足够低，那么循环就可以终止了。其次，`estimate`步骤计算误差的局部指标，这些指标与网格元素有关。误差估计是高度特定的问题，需要由用户提供。第11.5.2章的例子将展示如何使用LocalOperator机械来达到这个目的。最后三个步骤按照误差指标的建议修改网格。与[Fig2.12]中的经典细化循环相比，`dune-pdelab`循环有一个单独的`judge`步骤，它在其他地方被视为`mark`的一部分。`judge`、`mark`和`adapt`步骤是由`dune-pdelab`以文件`dune/pdelab/adaptivity/adaptivity.hh`中的几个方法的形式通用地提供。我们假设`estimate`步骤产生了一个与网格元素相关的平方误差指标向量$\eta^{2}=\left(\eta_{T}^{2}\right)_{T \in \mathcal{T}}$，并依次讨论以下三个步骤。



\textbf{judge: Determining Which `Elements` to Modify}

`judge`步骤根据`estimate`步骤产生的误差指标，确定要细化和粗化的元素集。`dune-pdelab`接口假定局部误差指标总是与网格元素相关。因此，让$n_{\mathcal{T}}$为网格元素的数量，$\eta^{2} \in \mathbb{R}^{n_{\mathcal{T}}}$为元素误差指标的向量。有几种策略可以把这种指标变成细化标记。例如，人们可能希望将固定比例的元素标记为细化，而将固定比例的元素标记为粗化。这个策略是通过以下方法实现的

~~~C++
template <class VectorContainer>
void element_fraction(const VectorContainer &etaSquared,
                      VectorContainer::ElementType alpha,
                      VectorContainer::ElementType beta,
                      VectorContainer::ElementType &refineThreshold,
                      VectorContainer::ElementType &coarsenThreshold,
                      int verbose = 0)
~~~


第一个参数，`etaSquared` ，是元素误差指标数组$\eta^{2}$，从线性代数后端（第11.4章）以`VectorContainer`类型的对象给出。这个`VectorContainer`必须与一个`GridFunctionSpace`相对于当前叶栅视图的片状常数函数相关联，它决定了向量条目的排序。

参数`alpha`和be`t`a分别是要细化和粗化的元素的分数。对于给定值 $0 \leq$ alpha, beta $\leq 1$ , `element_fraction` 方法标记具有最大误差指标值的（近似）alpha $\cdot n_{\mathcal{T}}$ 元素进行细化，以及（近似）beta $\cdot n_{\mathcal{T}}$ 元素的最低值进行粗化。然而，请注意，该方法实际上并没有在DuNE网格界面的意义上标记任何元素（第5.9章）。相反，它在输出参数 `refineThreshold` 和 `coarsenThreshold` 中返回两个阈值。在完成`element_fraction`方法后，它们包含了误差指示值，高于和低于该值的元素应该分别被标记为细化和粗化，以达到理想的分数。这两个数字作为细化循环的`mark`阶段的输入，该阶段进行实际标记。最后，粗略参数允许控制该方法产生的屏幕输出量。

与其选择最上面的`alpha`$\cdot n_{\mathcal{T}}$元素进行细化，还可以让分数`alpha`参考累积平方误差值。换句话说，一组$\mathcal{M}$的元素被标记为细化，以便于

$$
\sum_{T \in \mathcal{M}} \eta_{T}^{2} \geq \text { alpha } \sum_{T \in \mathcal{T}} \eta_{T}^{2}
$$

这种方法在文献中被称为Dörfler `marking` [^57] [^157] 。它由`dune-pdelab`提供的方法的形式是

~~~C++
template <class VectorContainer>
void error_fraction(const VectorContainer &etaSquared,
                    VectorContainer::ElementType alpha,
                    VectorContainer::ElementType beta,
                    VectorContainer::ElementType &refineThreshold,
                    VectorContainer::ElementType &coarsenThreshold,
                    int verbose = 0)

~~~


这种方法的参数与 `element_fraction` 的相应参数的意义完全相同。

\textbf{mark: Marking the Grid for Local Modification}

在`mark`步骤中，叶子网格视图上的网格元素被标记为细化或粗化，实际上还没有修改网格。该步骤是以自由方法的形式实现的

~~~C++
template <class Grid, class VectorContainer>
void mark_grid(Grid &grid, const VectorContainer &etaSquared,
               VectorContainer::ElementType refineThreshold,
               VectorContainer::ElementType coarsenThreshold,
               int minLevel = 0,
               int maxLevel = std::numeric_limits<int>::max(),
               int verbose = 0)

~~~



其中第一个参数是要修改的（分层）网格。第二个参数是一个带有平方元素误差指标的向量，就像`element_fraction`和`error_fraction`方法一样。第三和第四个参数是判断步骤中计算的细化和粗化阈值。如果一个元素在 `etaSquared` 中给出的错误指标大于 `refineThreshold` 中给出的细化阈值，则该元素被标记为细化。同样，如果该指标低于 `coarsenThreshold` 中给出的值，则该元素被标记为粗化。通常，这里使用 `element_fraction` 或 `error_fraction` 计算的值。此外，两个可选参数 `minLevel` 和 `maxLevel` 允许设置网格分辨率的上下限。只有当一个元素在网格细化层次中的级别严格大于minLevel时，它才会被标记为粗化。同样地，细化标记只适用于严格低于 `maxLevel` 的元素。默认值完全不施加任何限制。

即使在mark_grid被调用之后，网格仍然是不变的。然而，它的叶子元素现在带有细化和粗化标记，所以调用`preAdapt`、`adapt`和`postAdapt`，如第$5.9$章所解释的，将正确修改网格。

\textbf{adapt: Modifying the Grid and Adjusting Grid Functions}

当一个离散的函数被附加到网格上，并且需要跨网格修改步骤保留，那么仅仅在网格上调用`adapt`是不够的。第$5.9$章已经展示了如何在附加到网格实体的代数数据层面上跨网格修改保留数据。`dune-pdelab`模块将很多复杂的东西隐藏在一个简单的界面后面。相关的方法是

~~~C++
template <class Grid, class GridFunctionSpace, class VectorContainer>
void adapt_grid(Grid &grid,
                GridFunctionSpace &gridFunctionSpace,
                VectorContainer &x,
                int intOrder)
~~~



这里，grid是（分层的）网格，`gridFunctionSpace`是描述有限元空间的对象，$\mathrm{x}$是相对于该空间的系数向量，定义了需要和网格一起修改的函数。请注意，该方法只能处理一个函数--处理多个函数时，`GridFunctionSpace`对象需要将它们组合成一个树状结构，如第$10.1$章中所解释的。

`intOrder`参数允许控制离散函数从旧网格转移到新网格的一个特定方面。当网格元素被细化时，那么未细化元素上的现有函数必须在相对于细化元素定义的更大空间中被表示出来。为此，使用`dune-localfunctions`模块的LocalInterpolation基础设施（第8.2.2章）。反之，当元素被粗化时，现有的函数必须在更小的空间中表示。为此，`adapt_grid`方法使用$L^{2}$-投影，`intOrder`为实现投影的质量矩阵的装配设定了积分顺序。对于一个完美的投影，必须选择两倍的多项式阶数，但更小的数字经常是足够的。




\subsubsection{Example: Adaptive Finite `Elements` for the Poisson Equation}

我们通过给出一个完整的例子来证明`dune-pdelab`的适应性特征。为此，我们扩展了介绍性章节`Poisson`中的例子$3.3$，以包括基于残差型误差估计器[^157]的局部网格适应性。完整的代码印在附录B.16中，它的电子版可以通过页边的图标获得。这就是用于制作网格自适应一章中的[Fig2.20]的程序。

首先回顾一下，第$3.3$章中的例子计算了方程的弱解

\begin{equation}
-\Delta u=f
\label{11.25}
\end{equation}

在$f \equiv-5$形域$\Omega=(0,1)^{2} \backslash[0.5,1)^{2}$上有$f \equiv-5$，有`Dirichlet`边界条件。

$$
u= \begin{cases}0 & \text { on }\{0\} \times[0,1] \cup[0,1] \times\{0\} \\ 0.5 & \text { on }\{0.5\} \times[0.5,1] \cup[0.5,1] \times\{0.5\}\end{cases}
$$

和`Neumann`条件$\mathrm{j} \equiv 0$在边界的其余部分。域和边界条件在[Fig3.1]中显示，但为了方便，我们在[Fig11.8]中重复它们。由于该域有一个向内的角，该问题不是$H^{2}$规则的，在该角附近可以观察到解的无界导数（[Fig2.11]）。对于离散化，我们使用与第$3.3$章相同的符合三角网格（在[Fig11.8]中再次显示），并且我们使用一阶`Lagrange`有限元对问题进行离散。网格将使用`UGGrid`网格管理器来存储，该管理器实现了红-绿`h-refinement`，正如在$2.3.2 .15$章中所解释的那样。在以前的章节中已经展示了如何使用`dune-pdelab`解决具有`Dirichlet`边界条件的`Poisson`问题，我们将在这里充分使用这一知识。

为了控制适应性，代码实现了一个标准的残差型误差估计器。让$u$是边界值问题\ref{11.25}的弱解，而$u_{h}$是相应的有限元解。我们的想法是，误差$u-u_{h}$与残差有关。

$$
r\left(u_{h}, v\right)=\int_{\Omega} f v d x-\int_{\Omega}\left\langle\nabla u_{h}, \nabla v\right\rangle d x+\int_{\Gamma_{N}} \mathrm{j} v d s, \quad v \in H_{D, 0}^{1}
$$

事实上，当且仅当`residual`$r_{h}\left(u_{h}, \cdot\right)$弱解方程\ref{11.25}时，$H^{1}$的误差准则等同于`residual`[^157]的运算准则。

这一见解可以通过用可计算的量来逼近$r\left(u_{h}, \cdot\right)$的算子规范而变成一个误差估计器。为此，我们将`residual`本地化，沿着元素分割积分

$$
r_{h}\left(u_{h}, v\right)=\sum_{T \in \mathcal{T}}\left[\int_{T} f v d x-\int_{T}\left\langle\nabla u_{h}, \nabla v\right\rangle d x+\int_{T \cap \Gamma_{N}} \mathrm{j} v d s\right]
$$

并在每个元素上使用`Green`的标识，以获得

$$
r_{h}\left(u_{h}, v\right)=\sum_{T \in \mathcal{T}}\left[\int_{T}\left(f+\Delta u_{h}\right) v d x-\int_{\partial T}\left\langle\nabla u_{h}, \mathbf{n}\right\rangle v d s+\int_{T \cap \Gamma_{N}} \mathrm{j} v d s\right]
$$

量$\int_{T}\left(f+\Delta u_{h}\right) v d x$对应于元素`Poisson`方程的弱形式$T$ 。元素边界上的积分之和可以改写为网格上的元素交点之和。我们得到

$$
\begin{aligned}
r_{h}\left(u_{h}, v\right)=& \sum_{T \in \mathcal{T}} \int_{T}\left(f+\Delta u_{h}\right) v d x \\
&+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B} \cap \Gamma_{N}} \int_{\gamma^{\mathrm{b}}}\left(\mathrm{j}-\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right) v d s+\sum_{\gamma^{\mathrm{i}} \in \mathcal{F}} \int_{\gamma^{\mathrm{i}}} \llbracket\left\langle\mathbf{n}, \nabla u_{h}\right\rangle \rrbracket v d s
\end{aligned}
$$

其中$\mathcal{B} \cap \Gamma_{N}$是`Neumann`边界上的元素面的集合，$\mathcal{F}$是网格骨架。在`Dirichlet`边界上的面的积分被剔除，因为测试函数$v$在那里是零。

基于残差的估计器将这些项合并为一个局部误差指标

\begin{equation}
\begin{aligned}
&\eta_{T}^{2}:=h_{T}^{2}\left\|f+\Delta u_{h}\right\|_{0, T}^{2} \\
&\quad+\frac{1}{2} \sum_{\gamma^{i} \in \mathcal{F}} h_{\gamma^{i}}\left\|\llbracket\left\langle\nabla u_{h}, \mathbf{n}\right\rangle \rrbracket\right\|_{0, \gamma^{i}}^{2}+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B} \cap \Gamma_{N}} h_{\gamma^{\mathrm{b}}}\left\|\mathrm{j}-\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right\|_{0, \gamma^{\mathrm{b}}}^{2}
\end{aligned}
\label{11.26}
\end{equation}

其中$h_{T}$是元素的直径$T, h_{\gamma}$是面的直径$\gamma$ ，$\|\cdot\|_{0}$表示$L^{2}$-norm。可以证明，数量$\eta:=\sqrt{\sum_{T} \eta_{T}^{2}}$与额外的数据振荡项相结合，从上面和下面[^157]对离散解$u_{h}$的误差进行了约束。同时，使用$\eta_{T}^{2}$作为细化指标的自适应细化策略可以被证明是收敛的[^57] [^128] ，并且在实践中运行良好。由于该例子只使用片状常数数据$f$和$\mathrm{j}$，我们可以在下文中不考虑数据振荡项。

\textbf{The `main` Method}

示例程序的代码由三部分组成。一个作为`ConvectionDiffusionFEM`局部运算符的问题描述的类`PoissonProblem`，一个计算错误指标$\eta_{T}^{2}$、$T \in \mathcal{T}$的局部运算符`ResidualErrorEstimator`，以及一个`main`方法。`PoissonProblem`类与第$11.3$章中使用的类相同，我们在此不再重复。相反，我们讨论`main`方法，并展示局部误差估计器的实现。

`main`方法首先初始化`MPIHelper`，并从`GMSH`文件中加载[Fig11.8]所示的非结构化网格到UGGrid对象中。本文件的电子版将网格作为文件附件，可通过文本边缘的图标访问。

~~~C++
int main(int argc, char *argv[])
{
    // Initialize MPI, if available
    MPIHelper::instance(argc, argv);

    constexpr int dim = 2;
    using Grid = UGGrid<dim>;
    std::shared_ptr<Grid> grid = GmshReader<Grid>::read("l-shape.msh");
    using GridView = Grid::LeafGridView;
    auto gridView = grid->leafGridView();

~~~


之后，该方法直接定义了一个存储错误阈值的变量。

~~~C++
    const double estimatedErrorThreshold = 0.1;
~~~


[Fig11.7]的自适应细化循环将进行迭代，直到估计的总误差下降到这个阈值以下。

接下来，代码设置了离散函数空间；一个具有`Dirichlet`约束的一阶`Lagrange`空间和ISTL矢量后端。


~~~C++
// Make grid function space
using Basis = Functions::LagrangeBasis<GridView, 1>;
auto basis = std::make_shared<Basis>(gridView);

using Constraints = PDELab::ConformingDirichletConstraints;
using VectorBackend = PDELab::ISTL::VectorBackend<>;

using GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<Basis,
                                                                  VectorBackend,
                                                                  Constraints>;

GridFunctionSpace gridFunctionSpace(basis);
~~~



对`Dirichlet`边界条件的处理与第11.3章中一样。

~~~C++
PoissonProblem<GridView, double> poissonProblem;
PDELab::
    ConvectionDiffusionBoundaryConditionAdapter<decltype(poissonProblem)>
        bctype(poissonProblem);

using ConstraintsContainer = GridFunctionSpace::ConstraintsContainer<double>::Type;
ConstraintsContainer constraintsContainer;
PDELab::constraints(bctype, gridFunctionSpace, constraintsContainer);

~~~



方法`bctype`，指定`Dirichlet`边界上的自由度的谓词，从文件前面给出的`PoissonProblem`类的问题描述中导入。

接下来，主方法从$u$中为一个离散函数创建一个系数向量`GridFunctionSpace` 。这个向量将保存离散问题的解$u_{h}$在各个网格上的系数，因此它必须在细化循环开始之前被定义。`Dirichlet`的值是通过取样功能设置的

$$
\mathrm{g}(x)= \begin{cases}0 & \text { if } x_{0} \leq 0 \text { or } x_{1} \leq 0 \\ 0.5 & \text { otherwise }\end{cases}
$$

在`Lagrange`节点。



观察一下第338行的实际取样是如何通过`dune-functions`中的方法完成的，直接在`dune-istl`容器上操作，可以通过`PDELab::Backend::native`方法访问。

在这些准备工作之后，开始实际的细化循环。

~~~C++
std::size_t i = 0; // Loop variable, for data output
while (true)       // Loop termination condition
// is near the middle of the loop body
{
    std::cout << "Iteration: " << i
              << ", highest level in grid: " << grid->maxLevel()
              << ", degrees of freedom: " << gridFunctionSpace.globalSize()
              << std::endl;

~~~



它被实现为一个`while`循环，其循环条件永远不会失败，因此该循环只能由`break`语句终止。选择这种结构是因为测试迭代是否应该终止发生在细化循环的中间，见 [Fig11.7] 。

按照该图中的步骤顺序，我们首先需要在给定的网格上组装问题，并解决由此产生的代数问题。我们从线性代数后端创建一个装配器和一个线性求解器。


~~~C++
using LocalOperator = PDELab::ConvectionDiffusionFEM<decltype(poissonProblem),
                                                     GridFunctionSpace::Traits::
                                                         FiniteElementMap>;
LocalOperator localOperator(poissonProblem);

using MatrixBackend = PDELab::ISTL::BCRSMatrixBackend<>;
MatrixBackend matrixBackend(7); // Expected average number
// of matrix entries per row
using GridOperator = PDELab::GridOperator<GridFunctionSpace,
                                          GridFunctionSpace,
                                          LocalOperator,
                                          MatrixBackend,
                                          double, double, double,
                                          ConstraintsContainer,
                                          ConstraintsContainer>;
GridOperator gridOperator(gridFunctionSpace, constraintsContainer,
                          gridFunctionSpace, constraintsContainer,
                          localOperator,
                          matrixBackend);

// Select a linear solver backend
using LinearSolverBackend = PDELab::ISTLBackend_SEQ_CG_SSOR;
LinearSolverBackend linearSolverBackend(5000, // Maximum number
                                        // of iterations
                                        1); // Verbosity level

// Select linear problem solver
using LinearProblemSolver = PDELab::StationaryLinearProblemSolver<GridOperator,
                                                                  LinearSolverBackend,
                                                                  U>;
LinearProblemSolver linearProblemSolver(gridOperator,
                                        linearSolverBackend,
                                        u,
                                        1e-10);

// Solve linear problem
linearProblemSolver.apply();

~~~




这时，向量容器u包含了当前网格上的有限元解$u_{h}$。这个当前解被写入一个文件，文件名以细化迭代数为后缀。这样一来，所有的中间网格都可以方便地在以后进行检查。

~~~C++
VTKWriter<GridView> vtkwriter(gridView);
auto uFunction = Functions::makeDiscreteGlobalBasisFunction<double>(
    *basis,
    PDELab::Backend::native(u));
vtkwriter.addVertexData(uFunction,
                        VTK::FieldInfo("u",
                                       VTK::FieldInfo::Type::scalar,
                                       1));
vtkwriter.write("pdelab-adaptivity-result-" + std::to_string(i));
~~~



我们现在已经计算出了关于给定网格的模型问题的解决方案。从这里开始，我们进入实际的误差估计步骤。有点令人惊讶的是，代码使用了一个特殊的`LocalOperator`实现来计算平方误差指标 $\eta_{T}^{2}$ 。诀窍是认识到平方指标的向量可以写成片状常数函数空间上的线性形式的代数表示。让$\theta_{T}$成为在元素$T$上的值为1，而在其他地方为0的函数。那么，误差指标\ref{11.26}可以被改写为

$$
\eta_{T}^{2}=r^{\mathrm{err}}\left(u_{h}, \theta_{T}\right)
$$

与

\begin{equation}
\begin{aligned}
r^{\mathrm{err}}\left(u_{h}, \theta\right): &=\sum_{T \in \mathcal{T}} h_{T}^{2} \int_{T}\left|\left(f+\Delta u_{h}\right)\right|^{2} \theta d x \\
&+\sum_{\gamma^{\mathrm{i}} \in \mathcal{F}} h_{\gamma^{\mathrm{i}}} \int_{\gamma^{\mathrm{i}}} \llbracket\left\langle\nabla u_{h}, \mathbf{n}\right\rangle \rrbracket^{2}\{\theta\} d s \\
&+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B} \cap \Gamma_{N}} h_{\gamma^{\mathrm{b}}} \int_{\gamma^{\mathrm{b}}}\left|\mathrm{j}-\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right|^{2} \theta d s
\end{aligned}
\label{11.27}
\end{equation}

这在$\theta$中确实是线性的，它具有典型的假设$11.2$的三分法，这是`dune-pdelab`汇编程序界面的核心。因此，我们定义了一个片状常数测试函数空间，以及一个相对于其标准基础定义的系数向量 `etaSquared` ，它将持有局部误差指标 $\eta_{T}^{2}$ 。

~~~C++
using P0Basis = Functions::LagrangeBasis<GridView, 0>;
auto p0Basis = std::make_shared<P0Basis>(gridView);

using P0GridFunctionSpace = PDELab::Experimental::GridFunctionSpace<P0Basis,
                                                                    VectorBackend,
                                                                    PDELab::NoConstraints>;

P0GridFunctionSpace p0GridFunctionSpace(p0Basis);
using U0 = PDELab::Backend::Vector<P0GridFunctionSpace, double>;
U0 etaSquared(p0GridFunctionSpace, 0.0);

~~~



然后，我们设置了一个新的`Grid0perator`对象，其自定义的`LocalOperator`名为`ResidualErrorEstimator`，实现了误差估计器的`residual`公式\ref{11.27}。这个`Local0perator`的实现将在第11.5.2章详细描述。它被赋予问题描述，因为它必须知道源项和边界条件。

~~~C++
using EstimatorLocalOperator = ResidualErrorEstimator<decltype(poissonProblem)>;
EstimatorLocalOperator estimatorLocalOperator(poissonProblem);
using EstimatorGridOperator = PDELab::GridOperator<GridFunctionSpace,
                                                   P0GridFunctionSpace,
                                                   EstimatorLocalOperator,
                                                   MatrixBackend,
                                                   double, double, double>;
EstimatorGridOperator estimatorGridOperator(gridFunctionSpace,
                                            p0GridFunctionSpace,
                                            estimatorLocalOperator,
                                            matrixBackend);

~~~


注意这次`Grid0perator`如何接收两个不同的函数空间，即有限元解的一阶`Lagrange`空间$u_{h}$，和片状常数测试函数空间$\theta$。下面将详细讨论`estimatorLocalOperator`的实现。

然后我们通过调用`residual`方法对u中的当前有限元解进行网格算子评估指标。

~~~C++
estimatorGridOperator.residual(u,etaSquared);
~~~


我们现在已经完成了细化循环的`estimate`步骤。矢量容器`etaSquared`现在包含叶栅视图的每个元素$T$的$\eta_{T}^{2}$。通过对$\eta_{T}^{2}$[^157]进行求和，可以得到总误差的平方值，这个估计值被用来决定是否应该终止细化循环。


~~~C++
// Terminate if desired accuracy has been reached
double totalEstimatedError = std::sqrt(std::accumulate(etaSquared.begin(),
                                                       etaSquared.end(),
                                                       0.0));
std::cout << "Total estimated error: " << totalEstimatedError << std::endl;

if (totalEstimatedError < estimatedErrorThreshold)
    break;
~~~




如果估计的误差不够小，我们就通过使用`etaSquared`数组中的元素误差指标来确定哪些元素要进行细化标记。代码中使用了`error_fraction`方法实现的Dörfler标记。我们将参数alpha设为正值，beta设为零，只允许细化而不允许粗化。

~~~C++
double alpha = 0.4;      // Refinement fraction
double refineThreshold;  // Refinement threshold
double beta = 0.0;       // Coarsening fraction
double coarsenThreshold; // Coarsening threshold
int verbose = 0;         // No screen output

PDELab::error_fraction(etaSquared,
                       alpha, beta,
                       refineThreshold, coarsenThreshold,
                       verbose);

~~~


在这个调用之后，变量`refineThreshold`包含误差值，它将构成误差的上层$40 \%$的元素与其他元素分开；`coarsenThreshold`包含0，因为通过设置β为零，没有元素会被标记为粗化。实际的标记是由 `mark_grid` 方法完成的。

~~~C++
PDELab::mark_grid(*grid, etaSquared, refineThreshold, coarsenThreshold);
~~~


最后，调用`adapt_grid`进行实际的网格修改，并将当前u中的离散解从旧网格转移到新网格。

~~~C++
PDELab::adapt_grid(*grid, gridFunctionSpace, u, 2 );
~~~



这里的参数2是用于$L^{2}$投影的正交阶数，用于将数据传输到更粗的网格（11.5.1章）。由于本例中没有发生粗化，这个数字没有影响。

在网格函数空间和解决方案适应新的网格后，`Dirichlet`的边界约束需要重新应用于适应的解决方案向量$u$。这发生在一个两部分的过程中。首先，`Dirichlet`值函数$\mathrm{g}$在整个网格上被采样为一个临时矢量`dirichletValues`，使用`dune-functions`的方法。然后，由`Dirichlet`边界条件约束的自由度被从临时向量复制到$\mathrm{u}$。这样，只有`Dirichlet`的边界值$u$被修改。

~~~C++
    // Reassemble the Dirichlet constraints
    PDELab::constraints(bctype, gridFunctionSpace, constraintsContainer);
    
    // Interpolate the Dirichlet values function on the entire domain!
    PDELab::Backend::Vector<GridFunctionSpace, double>
        dirichletValues(gridFunctionSpace);
    Functions::interpolate(*basis,
                           PDELab::Backend::native(dirichletValues),
                           g);
    
    // Copy all Dirichlet degrees of freedom into the actual solution vector
    PDELab::copy_constrained_dofs(constraintsContainer, dirichletValues, u);
    
    // Increment loop counter
    i++;
}
~~~


这就结束了细化循环，以及`main`方法。

\textbf{Local Error Indicator}

剩下要讨论的是计算误差指标向量的 `LocalOperator` 实现方法 $\eta_{T}^{2}$ 。回顾一下，我们将教科书上的 `residual` 估计器 \ref{11.26} 重新表述为片状常数函数空间上的线性函数

$$
\eta_{T}^{2}=r^{\mathrm{err}}\left(u_{h}, \theta_{T}\right)
$$

与

$$
\begin{aligned}
r^{\text {err }}\left(u_{h}, \theta\right): &:=\sum_{T \in \mathcal{T}} h_{T}^{2} \int_{T}\left|\left(f+\Delta u_{h}\right)\right|^{2} \theta d x \\
&+\sum_{\gamma^{\mathrm{i}} \in \mathcal{F}} h_{\gamma^{\mathrm{i}}} \int_{\gamma^{\mathrm{i}}} \llbracket\left\langle\nabla u_{h}, \mathbf{n}\right\rangle \rrbracket^{2}\{\theta\} d s \\
&+\sum_{\gamma^{\mathrm{b}} \in \mathcal{B} \cap \Gamma_{N}} h_{\gamma^{\mathrm{b}}} \int_{\gamma^{\mathrm{b}}}\left|\mathrm{j}-\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right|^{2} \theta d s
\end{aligned}
$$

以这种形式书写，指标集是由元素贡献、来自骨架的元素交点的贡献和来自`Neumann`边界交点的贡献组成。因此，`LocalOperator`实现了`alpha_volume`、`alpha_skeleton`和alpha_boundary方法。由于$\eta_{T}^{2}$相对于$u_{h}$的导数在自适应有限元计算中是不需要的，相应的雅各布方法被省略。

该类的签名很简单。它唯一的模板参数是问题描述类，它提供源项函数和边界条件。该类只继承了`PDELab::LocalOperatorDefaultFlags`，因为没有`Jacobian`的计算，因此不需要矩阵占用模式。

~~~C++
template <class Problem>
class ResidualErrorEstimator
    : public PDELab::LocalOperatorDefaultFlags
{
    Problem problem_;

public:
    ResidualErrorEstimator(const Problem &problem)
        : problem_(problem)
    {}

~~~





然后该类设置三个标准标志，向`Grid0perator`宣布`residual`包含体积、骨架和边界项。

~~~C++
static const bool doAlphaVolume = true;
static const bool doAlphaSkeleton = true;
static const bool doAlphaBoundary = true;
~~~

由于上述原因，`doPattern`标志是不需要的。

然后是方法`alpha_volume`，它计算元素部分

$$
\eta_{T, \mathrm{vol}}^{2}:=h_{T}^{2} \int_{T}\left|\left(f+\Delta u_{h}\right)\right|^{2} \theta_{T} d x
$$

的错误指示器。代码实际上并没有评估测试函数$\theta_{T}$，因为无论如何它在$T$上的值是1。为了简单起见，我们还利用了这样一个事实：$u_{h}$是$T$上的一个仿射函数，因此也是$\Delta u_{h}=0$。

~~~C++
template <class EntityGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void alpha_volume(const EntityGeometry &entityGeometry,
                  const LocalFunctionSpaceU &localFunctionSpaceU,
                  const Vector &x,
                  const LocalFunctionSpaceV &localFunctionSpaceV,
                  Residual &residual) const
{
    using RangeField = typename LocalFunctionSpaceU::Traits::
        FiniteElement::Traits::LocalBasisType::Traits::RangeType;

    // Element diameter
    auto h_T = diameter(entityGeometry.geometry());

    // Loop over quadrature points
    int intOrder = localFunctionSpaceU.finiteElement().localBasis().order();
    constexpr auto entityDim = EntityGeometry::Entity::mydimension;
    const auto &quadRule = QuadratureRules<double, entityDim>::rule(entityGeometry.geometry()
                                                                        .type(),
                                                                    intOrder);

    for (const auto &quadPoint : quadRule)
    {
        // Laplace of uh is always zero,
        // because we are using first-order elements on simplices
        RangeField laplaceU = 0.0;

        // Evaluate source term function f
        auto f = problem_.f(entityGeometry.entity(), quadPoint.position());

        // Integrate $h_{T}^{2}\left(f+\Delta u_{h}\right)^{2}$
        auto factor = quadPoint.weight() * entityGeometry.geometry()
                                               .integrationElement(quadPoint.position());
        auto value = std::pow(h_T * (f + laplaceU), 2);
        residual.accumulate(localFunctionSpaceV, 0, value * factor);
    }
}

~~~



接下来是方法`alpha_skeleton`，它计算骨架贡献率

$$
\eta_{\gamma^{\mathrm{i}}, \mathrm{skel}}^{2}:=h_{\gamma^{\mathrm{i}}} \int_{\gamma^{\mathrm{i}}} \llbracket\left\langle\nabla u_{h}, \mathbf{n}\right\rangle \rrbracket^{2}\{\theta\} d s
$$

对于每个不在域边界上的交点$\gamma^{\mathrm{i}}$。注意测试函数$\theta$在`inside`元素上是1，在外面的元素上是0，或者反之亦然。因此，平均表达式$\{\theta\}$可以用值$\frac{1}{2}$代替。


~~~C++

template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void alpha_skeleton(const IntersectionGeometry &intersectionGeometry,
                    const LocalFunctionSpaceU &localFunctionSpaceUIn,
                    const Vector &xIn,
                    const LocalFunctionSpaceV &localFunctionSpaceVIn,
                    const LocalFunctionSpaceU &localFunctionSpaceUOut,
                    const Vector &xOut,
                    const LocalFunctionSpaceV &localFunctionSpaceVOut,
                    Residual &residualIn, Residual &residualOut) const
{
    // Extract type of shape function gradients
    using TrialFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
    using LocalBasisU = typename TrialFE::Traits::LocalBasisType;
    using GradientU = typename LocalBasisU::Traits::JacobianType;
    using size_type = typename LocalFunctionSpaceU::Traits::SizeType;

    auto insideGeometry = intersectionGeometry.inside().geometry();
    auto outsideGeometry = intersectionGeometry.outside().geometry();

    auto h_F = diameter(intersectionGeometry.geometry());

    auto geometryInInside = intersectionGeometry.geometryInInside();
    auto geometryInOutside = intersectionGeometry.geometryInOutside();

    std::vector<GradientU> localGradPhiIn(localFunctionSpaceUIn.size());
    std::vector<GradientU> localGradPhiOut(localFunctionSpaceUOut.size());

    // Loop over quadrature points and integrate the jump term
    const int intOrder = 2 * localFunctionSpaceUIn.finiteElement().localBasis().order();
    constexpr auto intersectionDim = IntersectionGeometry::mydimension;
    const auto &quadRule = QuadratureRules<double, intersectionDim>::rule(
        intersectionGeometry.geometry().type(),
        intOrder);

    for (const auto &quadPoint : quadRule)
    {
        // Position of quadrature point in local coordinates of elements
        auto quadPointLocalIn = geometryInInside.global(quadPoint.position());
        auto quadPointLocalOut = geometryInOutside.global(quadPoint.position());

        // Evaluate gradient of basis functions
        localFunctionSpaceUIn.finiteElement().localBasis().evaluateJacobian(quadPointLocalIn, localGradPhiIn);
        localFunctionSpaceUOut.finiteElement().localBasis().evaluateJacobian(quadPointLocalOut, localGradPhiOut);

        // Compute gradient of u
        GradientU localGradUIn(0.0);
        for (size_type i = 0; i < localFunctionSpaceUIn.size(); i++)
            localGradUIn.axpy(xIn(localFunctionSpaceUIn, i), localGradPhiIn[i]);
        GradientU localGradUOut(0.0);
        for (size_type i = 0; i < localFunctionSpaceUOut.size(); i++)
            localGradUOut.axpy(xOut(localFunctionSpaceUOut, i), localGradPhiOut[i]);

        GradientU gradUIn;
        auto jacIn = insideGeometry.jacobianInverseTransposed(quadPointLocalIn);
        jacIn.mv(localGradUIn[0], gradUIn[0]);

        GradientU gradUOut;
        auto jacOut = outsideGeometry.jacobianInverseTransposed(quadPointLocalOut);
        jacOut.mv(localGradUOut[0], gradUOut[0]);

        // Integrate
        const auto n_F = intersectionGeometry.unitOuterNormal(quadPoint.position());
        auto jumpSquared = std::pow((n_F * gradUIn[0]) - (n_F * gradUOut[0]), 2);
        auto factor = quadPoint.weight() * intersectionGeometry.geometry()
                                               .integrationElement(quadPoint.position());

        // Accumulate indicator
        residualIn.accumulate(localFunctionSpaceVIn,
                              0,
                              0.5 * h_F * jumpSquared * factor);
        residualOut.accumulate(localFunctionSpaceVOut,
                               0,
                               0.5 * h_F * jumpSquared * factor);
    }
}

~~~





对于具有`alpha_skeleton`界面方法（第11.2.5章）工作知识的读者来说，这一切应该是很简单的。作为与标准程序的唯一轻微偏差，该方法没有将试行形状函数梯度$\left\{\nabla \phi_{i}^{\mathrm{in}}\right\}$和$\left\{\nabla \phi_{i}^{\text {out }}\right\}$从参考元素坐标转换为网格元素坐标。因为它们只用于计算函数梯度$\left.\nabla u_{h}\right|_{T_{\text {in }}}$和$\left.\nabla u_{h}\right|_{T_{\text {out }}}$，后者的数量首先在参考元素上计算，然后转换到网格元素上。

最后，还有一个方法`alpha_boundary`，该方法对所有的边界交叉点都会被调用，它必须集合`Neumann`边界贡献。

$$
\eta_{\gamma^{\mathrm{b}}, \mathrm{Neu}}^{2}:=h_{\gamma^{\mathrm{b}}} \int_{\gamma^{\mathrm{b}}}\left|\mathrm{j}-\left\langle\nabla u_{h}, \mathbf{n}\right\rangle\right|^{2} \theta d s
$$

由于测试函数$\theta$在该贡献为非零时取值为1，我们可以再次从实现中省略$\theta$。


~~~C++
template <class IntersectionGeometry,
          class LocalFunctionSpaceU, class Vector,
          class LocalFunctionSpaceV, class Residual>
void alpha_boundary(const IntersectionGeometry &intersectionGeometry,
                    const LocalFunctionSpaceU &localFunctionSpaceUIn,
                    const Vector &xIn,
                    const LocalFunctionSpaceV &localFunctionSpaceVIn,
                    Residual &residualIn) const
{
    using TrialFE = typename LocalFunctionSpaceU::Traits::FiniteElementType;
    using LocalBasisU = typename TrialFE::Traits::LocalBasisType;
    using GradientU = typename LocalBasisU::Traits::JacobianType;
    using size_type = typename LocalFunctionSpaceU::Traits::SizeType;

    auto insideGeometry = intersectionGeometry.inside().geometry();

    auto geometryInInside = intersectionGeometry.geometryInInside();

    // Intersection diameter
    auto h_F = diameter(intersectionGeometry.geometry());

    std::vector<GradientU> localGradPhi(localFunctionSpaceUIn.size());

    // Loop over quadrature points and integrate the jump term
    const int intOrder = localFunctionSpaceUIn.finiteElement().localBasis().order();
    constexpr auto intersectionDim = IntersectionGeometry::mydimension;
    const auto &quadRule = QuadratureRules<double, intersectionDim>::rule(
        intersectionGeometry.geometry().type(),
        intOrder);

    for (const auto &quadPoint : quadRule)
    {
        // Skip if quadrature point is not on Neumann boundary
        auto bcType = problem_.bctype(intersectionGeometry.intersection(),
                                      quadPoint.position());
        if (bcType != PDELab::ConvectionDiffusionBoundaryConditions::Neumann)
            return;

        // Position of quadrature point in local coordinates of element
        auto quadPointLocalIn = geometryInInside.global(quadPoint.position());

        // Evaluate gradient of trial shape functions
        localFunctionSpaceUIn.finiteElement().localBasis().evaluateJacobian(quadPointLocalIn,
                                                                            localGradPhi);

        // Evaluate gradient of u_h
        GradientU localGradU(0.0);
        for (size_type i = 0; i < localFunctionSpaceUIn.size(); i++)
            localGradU.axpy(xIn(localFunctionSpaceUIn, i), localGradPhi[i]);

        GradientU gradU;
        auto jac = insideGeometry.jacobianInverseTransposed(quadPointLocalIn);
        jac.mv(localGradU[0], gradU[0]);

        // Evaluate Neumann boundary value function
        auto neumann = problem_.j(intersectionGeometry.intersection(),
                                  quadPoint.position());

        // Integrate
        auto factor = quadPoint.weight() * intersectionGeometry.geometry()
                                               .integrationElement(quadPoint.position());

        const auto n = intersectionGeometry.unitOuterNormal(quadPoint.position());

        residualIn.accumulate(localFunctionSpaceVIn,
                              0,
                              h_F * std::pow((neumann - n * gradU[0]), 2) * factor);
    }
}

~~~



最后，这个类包含了一个小型的辅助方法 diameter，用来计算元素和交点的直径 $h_{T}$ 和 $h_{\gamma}$。这个方法是对第11.2.6章`Discontinuous Galerkin`例子中的同名方法的逐字复制，因此这里不再显示。由于在DUNE中元素和交叉点的几何形状都被表示为`Geometry`对象，所以只需要一个方法。

\textbf{Running the Program}

当运行时，该程序产生以下屏幕输出。

~~~Shell

Reading 2d Gmsh grid...
version 2.2 Gmsh file detected
file contains 43 nodes
file contains 90 elements
number of real vertices = 43
number of boundary elements = 22
number of elements = 62
Iteration: 0, highest level in grid: 0, degrees of freedom: 43
=== matrix setup (max) 0.000568451 s
=== matrix assembly (max) 0.00179137 s
=== residual assembly (max) 0.00117358 s
=== solving (reduction: 1e-10) === Dune::IterativeSolver
=== rate=0.017215, T=0.00123597, TIT=0.000205994, IT=6
0.00126493 s
Total estimated error: 1.26612
Iteration: 1, highest level in grid: 1, degrees of freedom: 64
=== matrix setup (max) 0.000901343 s
=== matrix assembly (max) 0.00300309 s
=== residual assembly (max) 0.00206459 s
=== solving (reduction: 1e-10) === Dune::IterativeSolver
=== rate=0.0551536, T=0.00272761, TIT=0.000303067, IT=9
0.00275909 s
Total estimated error: 1.072
[...]

Iteration: 12, highest level in grid: 11, degrees of freedom: 7227
=== matrix setup (max) 0.126007 s
=== matrix assembly (max) 0.411516 s
=== residual assembly (max) 0.26253 s
=== solving (reduction: 1e-10) === Dune::IterativeSolver
=== rate=0.746897, T=2.91045, TIT=0.0368411, IT=79
2.91064 s
Total estimated error: 0.0973319
~~~




可以看出，细化循环执行了13次，然后因为估计误差下降到所要求的阈值$0.1$而停止。

[Fig11.9] ，左边显示了程序的输出。可以看出，网格在内角附近被细化了，那里的解变得很单一。为了比较，我们还显示了从四边形元素的网格开始时的网格（[Fig11.9] ，中间），以及使用双切细化时的网格（[Fig11.9] ，右边）。通过简单地将第294行的网格管理器定义从`UGGrid`切换到`AlbertaGrid`来实现双切细化。由于双切细化比红绿细化引入的新元素更少，细化循环迭代了23次而不是13次，以达到相同的估计误差水平。






\section{A. The Dune Build System}

任何非微不足道的编译语言的软件都需要一个构建系统。这样的系统不仅要编译、链接和安装代码，而且还要跟踪外部的依赖关系，提供通过参数引导构建过程的方法，并可以帮助组织自动代码测试。

目前市场上有几个标准的构建系统，它们可以满足大多数软件项目的要求。然而，由于DUNE是一组相互依赖的模块，而不是单一的代码，构建和安装DUNE会带来一些特殊的挑战。例如，依赖性跟踪与其他软件库的做法有些不同，而且经常需要用相同的参数集来构建整个模块集。因此，DUNE一直有自己的构建系统，如今它是在标准工具 `cmake` 的基础上编写的。

关于如何使用DUNE构建系统的介绍性例子已经出现在第三章。初次接触DUNE并想构建第一个例子的读者应该从这里开始。本章将对DUNE构建系统和DuNE模块的内部结构进行更深入的解释。

\section{A.1. Building and Installing Dune Modules}

DUNE模块是DUNE软件系统的构建块。每个模块都是一个独立的$\mathrm{C}++$源码树，从中建立库和/或可执行文件。此外，由于DUNE使用了大量的$\mathrm{C}++$模板编程，大量的代码驻留在$\mathrm{C}++$头文件中，大多数DUNE模块中都有大量的头文件。源树的目录层次必须符合预定的结构，每个模块必须包含一点元数据和一些cmake配置文件。[FigA.1]显示了本书讨论的DUNE模块的示意图，模块之间的构建依赖关系用箭头表示。这种模块化设计的优点已经在第 $4.2$ 章中讨论过了。

要从源码构建一组模块，每个模块都必须单独下载和构建。每个模块只有在其依赖关系已经被构建的情况下才能被构建。这意味着这些模块必须以合适的顺序构建。就其本身而言，每个DUNE模块都使用标准的`cmake`构建系统，只是由`dune-common`模块提供的一些DUNE特有的宏来增强。

DUNE模块可以通过两种方式建立和安装。许多重要的模块现在在主要的Linux发行版中都是可用的，并且可以使用标准的软件包管理系统轻松安装。如果某个平台上没有可用的软件包，或者如果需要的前沿功能还没有发布，那么这些模块就需要下载、构建和手动安装。

\section{A.1.1. The `dunecontrol` Program}

虽然构建和安装模块的过程原则上可以手工完成，但`dune-common`模块提供了`dunecontrol`程序，它使构建和安装DUNE模块更加容易。`dunecontrol`程序的工作方式很像Linux的软件包管理器，它跟踪DUNE模块网络中的依赖关系，计算适当的构建顺序，然后使用它们的cmake构建系统一个一个地构建模块。主要的区别是，`dunecontrol`不下载模块的源代码。这个步骤必须单独完成。本节的其余部分描述了dunecontrol的主要功能。

\section{dunecontrol Build Commands}

`dunecontrol`程序是一个命令行工具。对`dunecontrol`的调用有以下形式。[TabA.1] 

~~~C++
dunecontrol [OPTIONS] COMMAND(S) [COMMAND-OPTIONS]
~~~


程序被赋予一个命令（或一个用冒号分隔的命令列表），后面可能有特定的命令选项。此外，在命令之前，`dunecontrol`还接受一般选项。我们在这里只讨论比较重要的命令；完整的命令列表见`dunecontrol` `-help`或程序手册。

最常用的命令是`cmake`和`make`，它们以适当的顺序建立一个DUNE模块的集合。在下文中，假设一组DUNE模块源已经被下载到一个公共目录中。假设所有依赖的DUNE模块都是这组模块的一部分，或者可以作为系统范围的安装。要构建公共目录下的所有模块，请进入该目录并运行

~~~Shell
dunecontrol cmake
dunecontrol make
~~~


这将构建（但不是安装）当前目录下的所有模块。更详细地说，两个调用中的第一个调用执行了以下三个步骤。

1.对于`dunecontrol`找到的每个模块，它都会检查（递归）是否能找到被列为依赖的模块。如果没有找到所有需要的依赖关系，构建过程就会中止。依赖关系可以被版本化（见附录A.2.2）。标记为建议的缺失的依赖关系只是导致一个警告。然后对模块的依赖关系图进行排序，产生一个有效的模块构建顺序。通过运行dunecontrol print，可以看到构建顺序的模块列表。

2.除非另有规定，否则每个模块的源代码树中都会创建一个名为`build-cmake`的构建目录。这些构建目录的名称和位置可以用`-builddir`选项来控制（见下文）。

3.程序`cmake`为每个模块被调用。它检查构建工具链的属性，寻找不是DUNE模块的依赖，并创建makefiles。`cmake`程序没有找到某些外部依赖，可能会导致硬性错误，但它也可能只是禁用某些功能。

随后对

~~~Shell
dunecontrol make
~~~

然后执行以下第四步。

4.为每个模块运行`make`程序。这将编译该模块的所有代码。所有可执行文件、库和其他生成的文件都放在模块的构建目录中。如果需要，DUNE构建系统可以被配置为在这里使用`make`程序的替代品，例如ninja，据说它比make更快（见附录A.1.3关于如何做的例子）。另外，在非unix平台上，构建工具可能要用特定平台的东西来代替。

由于这四个步骤通常是一起进行的，因此有一些捷径可以触发它们。首先，由于`dunecontrol`程序可以用一个以上的命令来调用（这些命令之间用冒号隔开），所有四个步骤都可以通过以下方式触发

~~~Shell
dunecontrol cmake : make
~~~

如果这样打字还是太多，另一个选择是

~~~Shell
dunecontrol all
~~~

不过要注意，这里的all指的是 "所有构建步骤"，而不是 "所有模块"。到目前为止，这些模块已经被配置和构建，但它们还没有被安装。安装DUNE是一个有争议的话题。事实上，只要所有的下游代码使用`dunecontrol`程序，就不需要安装DUNE模块。如果需要，DUNE模块的安装可以通过调用

~~~Shell
dunecontrol make install
~~~


将模块安装到系统的默认位置。这可能需要管理员权限--要以用户权限在本地安装模块，请将安装路径作为`cmake`选项传递，如附录A.1.3所解释。在写这篇文章的时候，不幸的是，与已安装的模块一起工作还没有得到很好的测试，可能需要进一步改进。

\section{dunecontrol Build Options}

配置和构建过程可以受到`dunecontrol`程序的各种选项的影响。例如，为了只考虑当前目录下的模块子集，-only和-module选项限制了`dunecontrol`所考虑的模块集。特别是

~~~Shell
dunecontrol --only=<module-name> all
~~~

将只对名为<module-name>的单个模块执行上面列出的四个步骤。  同样地。

~~~Shell
dunecontrol --module=<module-name> all
~~~

将为模块<module-name>及其所有直接和间接的依赖关系做这四个步骤。

默认情况下，每个模块的源代码树内都会创建一个名为 `build-cmake` 的独立构建目录。名称和相对位置可以通过传递一个相对路径作为`-builddir`选项来改变。比如说。

~~~Shell
dunecontrol --builddir=build-debug --module=dune-foo all
~~~

将在`build`目录下构建模块dune-foo和它所依赖的所有DUNE模块，这些目录被称为`build-debug`，在各自源树的根目录下创建。通过选择绝对路径，可以在文件系统中的任意位置指定一个自定义构建目录。

~~~Shell
dunecontrol --builddir=$HOME/dune-build-dir all
~~~

这将在用户的主目录中创建一个新目录 `dune-build-dir`，各个模块的 `build` 目录将作为 `dune-build-dir` 的子目录出现。它们的名称将与`dune.module`文件中指定的模块名称相同（附录A.2.2）。



\section{Further dunecontrol Commands}

dunecontrol还有一些有用的命令。比如说。

~~~Shell
dunecontrol exec <command>
~~~

将循环所有的源目录，并在每个目录中调用`<command>`。同样地。

~~~Shell
dunecontrol bexec <command>
~~~

将对构建目录做同样的处理。因此，举例来说。

~~~Shell
dunecontrol --module=dune-foo bexec "rm -rf *"
~~~


将清空构建目录中的 dune-foo 模块及其所有的直接和间接依赖关系。这个特别的例子对于强迫 `cmake` 进行全面重建很有用。当依赖关系发生变化时，这样的重建是必要的，例如，一个被推荐但不存在的DUNE模块突然变得可用。

最后，有几个命令可以对模块集进行版本控制操作。运行

~~~Shell
dunecontrol status
~~~

显示每个模块的版本控制状态，以及

~~~Shell
dunecontrol update
~~~

试图从其上游仓库更新源码。目前这两种方法都是针对GIT和SUBVERSION版本控制系统实现的。对于更精细的控制，命令

~~~Shell
dunecontrol git <git command>
dunecontrol svn <svn command>
~~~

允许在每个模块的源代码目录中执行单独的 `git` 或 `svn` 命令。参见`dunecontrol`的在线帮助，以获得完整的命令和选项列表。

\section{A.1.2. Specifying the Module Search Path with the `DUNE_CONTROL_PATH` Variable}

以上，为了简单起见，我们假设所有要构建的模块都包含在一个目录中。这有时限制性太强，因此，支持更多的一般性设置。为了理解`dunecontrol`是如何搜索模块的，重要的是要理解`dunecontrol`必须找到DUNE模块的两个稍微不同的原因。它需要找到它应该建立的模块，并且需要找到作为其他模块的依赖关系的模块。后者可能是由`dunecontrol`先前构建的，但它们也可能是由系统软件包管理器以二进制形式预装的。

默认情况下，`dunecontrol`会在当前目录及其子目录下寻找需要构建的模块。当寻找依赖关系时，全局安装的模块也被考虑在内。如果 `dunecontrol` 找到一个本地模块和一个全局模块的名称相同，那么本地模块会被优先考虑。如果它找到两个同名的本地模块，它将以错误信息中止工作。注意，模块的名称是dune.module文件（附录A.2.2）中的相应字符串，而不是模块源目录的名称（尽管两者通常应该重合）。

另外，`dunecontrol`可以在`DUNE_CONTROL_PATH`环境变量中给出一组要寻找DUNE模块的目录。这允许保持DUNE模块分布在几个目录中，或者从其他目录中调用`dunecontrol`，而不是模块源树所在的目录。目录的列表必须用冒号隔开。当寻找构建依赖时，全局安装的模块仍将被考虑，即使全局安装路径不是 `DUNE_CONTROL_PATH` 的一部分。另一方面，与Unix系统中处理其他环境变量的方式类似，当`DUNE_CONTROL_PATH`被设置时，那么当前目录不会被自动考虑。如果需要的话，必须明确地将其添加到`DUNE_CONTROL_PATH`变量中。

下面这个小怪癖值得再提一下。传统的 Unix 方式是，一个软件被构建、安装，然后可以作为其他软件的依赖。DUNE的一个特点是模块的安装步骤可以被跳过：最新的构建目录可以作为其他模块的依赖，即使它们还没有被安装。换句话说，在寻找依赖关系时，`dunecontrol`对已安装的模块和构建目录没有区别。如果所有的DUNE模块都保存在本地（即在属于用户账户的目录树中），就不需要实际安装这些模块。这可以简化许多其他模块所依赖的DUNE模块的开发，但并不明确推荐这样做。

\section{A.1.3. Setting Build Options for Sets of Modules}

在许多情况下，有必要为每个模块的构建过程传递选项。最常见的情况是非标准的安装目录，位于非标准位置的外部库，或编译器的优化选项。当直接构建单个模块时，这类选项可以直接传递给 cmake 构建系统，如 cmake 文档中所述。例如，下面的命令用 $-03$ 优化构建 dune-grid，并将其安装在用户主目录下的 dune-inst 文件夹中。

~~~Shell
cd dune-grid
mkdir build-cmake
cd build-cmake
cmake -DCMAKE_CXX_FLAGS=’-O3’ -DCMAKE_INSTALL_PREFIX=$HOME/dune-inst ..
make
make install
~~~


在处理单个模块时，用这种方式传递选项很方便。然而，当需要构建整个模块组时，这种方式就会变得很繁琐，而且通常要确保这组模块的所有模块都是用相同的选项构建的。当使用 `dunecontrol` 构建模块时，可以将这些选项交给 `dunecontrol` ，然后由它传递给 cmake。为此，`dunecontrol`允许编写

~~~Shell
dunecontrol --[COMMAND]-opts=<options> COMMAND(S)
~~~

这将把选项传递给由 `dunecontrol` 发出的 cmake 或 make 命令。例如，下面的命令将构建和安装当前目录下的所有模块，选项与前面的例子相同。

~~~Shell
dunecontrol --cmake-opts="-DCMAKE_CXX_FLAGS=’-O3’ \
                            -DCMAKE_INSTALL_PREFIX=$HOME/dune-inst" cmake
dunecontrol make
dunecontrol make install
~~~


另外，也可以在命令后面直接写上 cmake 选项。

~~~Shell
dunecontrol cmake "-DCMAKE_CXX_FLAGS=’-O3’ \
                    -DCMAKE_INSTALL_PREFIX=$HOME/dune-inst"
dunecontrol make
dunecontrol make install
~~~


同样地，使用`-make-opts`可以向`make`程序传递选项。最经常使用的是传递 $-j<n>$ ，以便与 $\mathrm{n}$ 进程并行构建。

选项集可能很长，在命令行上传递所有的选项可能会变得很乏味。一个更好的方法是将选项存储在一个专门的选项文件中。这样的文件可以使用`dunecontrol`选项交给`-opts`。

~~~Shell
dunecontrol --opts=<options file> COMMAND(S)
~~~

选项文件是一个以shell语法编写的文本文件，运行时可以设置某些变量的值。在大多数情况下，它只包含如下几行


~~~Shell
CMAKE_FLAGS="<...>"
~~~

或

~~~Shell
MAKE_FLAGS="<...>"
~~~

连同以#开头的注释行。然后，这些值会被传递给构建环境。目前可以设置以下变量。

~~~Shell
CMAKE:                   The precise cmake executable to use
CMAKE_FLAGS:             Flags to be passed to the cmake program
CMAKE_MODULE_PATH:       Semicolon-separated list of folders specifying a search path
                         for cmake modules
MAKE_FLAGS:              Flags to be passed to the make program
~~~


下面是一个小例子。

~~~Shell
# Use a particular compiler (clang++),
# install to a custom directory
# disable the external library SuperLU,
# use ninja instead of make as the build-tool
CMAKE_FLAGS="-DCMAKE_CXX_COMPILER=clang++ \
-DCMAKE_INSTALL_PREFIX=’$HOME/user/dune-inst’ \
-DCMAKE_DISABLE_FIND_PACKAGE_SuperLU=true \
-GNinja"
# Build with four processes in parallel
MAKE_FLAGS="-j 4"

~~~


这个例子使用 cmake 的 -D 选项来选择一个特定的编译器和本地安装目录，并使用 `-G` 选项来选择一个编译系统生成器，在这个例子中是 ninja。详情请参见 cmake 文档。

从这个例子也可以看出，cmake的`-D`选项也被用来在配置时关闭功能。要禁用一个外部依赖性Foo，可以添加

~~~Shell
-DCMAKE_DISABLE_FIND_PACKAGE_Foo=true
~~~


到`CMAKE_FLAGS`变量。依赖关系的名称是区分大小写的，但没有规范的命名方案。正确的软件包名称可以在 cmake 输出中找到。例如，如果要在安装了MPI库的情况下进行顺序编译，可以通过设置MPI依赖关系来明确禁用

~~~Shell
-DCMAKE_DISABLE_FIND_PACKAGE_MPI=true
~~~

在CMAKE_FLAGS中。

在构建过程中发生的错误会被记录在相应的DUNE模块的构建目录下CMakeFiles目录中的一个名为`CMakeError.log`的文件中。这不是DUNE特有的，而是一个标准的cmake功能。CMakeError.log 的内容通常提供了问题所在的提示。不过请注意，cmake 的缓存很积极，在修改了构建系统或构建环境后运行它可能不会真正发现变化，除非 cmake 被强制进行完全的重新运行。为此，从模块的构建目录中删除 `CMakeCache.txt` 文件。为了安全起见，请删除整个构建目录。

许多构建错误实际上是由几个模块的构建系统之间的错误相互作用造成的。当有疑问时，人们可能想触发所有目前正在使用的DUNE模块的重建。这可以很方便地通过调用

~~~Shell
dunecontrol bexec "rm CMakeCache.txt"
~~~

在构建之前。它删除了所有模块中的CMakeCache. txt文件。

\section{A.2. Dune Modules}

本节描述了一个典型的DUNE模块的结构。一个DUNE模块是一个源树，它遵守关于命名和目录层次的某些约定。它必须包含某些配置文件（主要用于cmake），以及一个名为 `dune.module` 的元信息的文件。

\section{A.2.1. The Structure of Dune Modules}

一个新创建的DUNE模块dune-foo有如下目录结构。


~~~Shell
dune-foo
|-- cmake
| ‘-- modules
| |-- CMakeLists.txt
| ‘-- DuneFooMacros.cmake
|-- CMakeLists.txt
|-- config.h.cmake
|-- doc
| |-- CMakeLists.txt
| ‘-- doxygen
| |-- CMakeLists.txt
| ‘-- Doxylocal
|-- dune
| |-- CMakeLists.txt
| ‘-- foo
| |-- CMakeLists.txt
| ‘-- foo.hh
|-- dune-foo.pc.in
|-- dune.module
|-- README
‘-- src
|-- CMakeLists.txt
‘-- dune-foo.cc
~~~



源代码树包含7个目录和15个文件。这些文件包含了构建系统的配置，模块的元信息，以及一个最小的$\mathrm{C}++$例子。主目录名称通常与模块名称相匹配，但这并不是严格的要求。按照惯例，目录名应该以`dune-`的前缀开始，但这不是一个技术要求。

顶层目录有四个子目录。

1.cmake目录包含模块特有的构建系统宏。这些必须位于cmake/modules目录中。这个目录中的任何cmake代码都可以被 `dune-foo` 模块本身和所有依赖 `dune-foo` 的下游DUNE模块使用。

文件 `cmake/modules/DuneFooMacros` . cmake 是特殊的：它的内容在配置模块 `dune-foo` ，或任何其他将 `dune-foo` 作为必要或可选依赖的 DUNE 模块时总是被执行。如果`dune-foo`模块的依赖关系不是DUNE模块本身，那么它们应该在文件`DuneFooMacros.cmake`中被检查出来（另见附录A.2.5）。通常，cmake `find_package`可以用来做这个。在一个由`duneproject`新创建的DUNE模块中，该文件是存在的但却是空的。

2.doc目录是用来存放模块文档的。默认情况下，它包含了使用DOXYGEN工具建立在线代码文档的基础设施（第A.2.6章）。几个核心模块也使用这个目录来存储`IATEX`格式的手册和教程。

3.根植于dune目录下的子树保存着模块的代码。由于DUNE大量使用$\mathrm{C}++$模板，大部分代码都包含在头文件中，但要编译成库的代码也应该存储在dune子树中。

dune目录本身应该是空的，除了一个`CMakeLists.txt`文件和另一个目录。这个目录包含实际的代码，可能在更多的子目录中。它的名字要和模块的名字一样，没有`dune-`的前缀。因此，例如，在模块`dune-grid`中，这个目录被称为grid。这个约定的效果是，头文件#include指令有一个标准化的形式。包含`dune-grid `中的头文件的代码是这样写的


~~~C++
#include <dune/grid/...>
~~~


而来自dune-istl的头文件则由

~~~C++
#include <dune/istl/...>
~~~

因此，从阅读`#include`指令中可以看出，一个特定的头文件来自哪个模块。DUNE模块中的C++头文件传统上有一个`.hh`后缀。

4.最后，src目录存放模块中包含的可执行文件的代码。这些通常是使用被依赖的DUNE模块进行某种数值模拟的程序。可编译的C++源文件应该总是以.cc结尾。新创建的DUNE模块包含一个简短的例子程序，称为`dune-<modulename>.cc`。如果一个模块只提供一个库，那么src目录也可以是空的。

有时可执行文件是模块功能的示例程序，而不是严肃的模拟代码。在这种情况下，src目录可能被改名为examples。例如，在`dune-functions`模块中就是这种情况。


至于主源树目录中的文件，两个核心的`dune.module`和`config.h.cmake`将在下面的专门章节中讨论。文件`dune-foo.pc.in`包含pkg-config工具$^{9}$用来寻找`dune-foo`模块的信息。

最后，DUNE模块的每个目录都包含一个名为`CMakeLists.txt`的文件，它是用cmake语言编写的。在调用cmake时，主模块目录下的CMakeLists. txt文件被执行。每当遇到 `add_subdirectory` 命令时，该子目录下的 `CMakeLists.txt` 文件就会被执行。顶层的CMakeLists.txt文件很特别，因为它正确设置了整个DUNE模块。用户可以自由地在其中添加更多的代码，但由`duneproject`生成的部分不能被删除。

\section{A.2.2. The `dune.module` File}

每个DUNE模块都包含一个名为`dune.module`的小文本文件，它包含模块的元数据。特别是，它列出了正式的模块名称（原则上可能与源目录的名称不同），以及模块的依赖性。

一个典型的`dune.module`文件看起来像这样。

~~~Shell
################################
# Dune module information file #
################################
# Name of the module
Module: dune-foo
Version: 3.1.4
Maintainer: paul.atreides@dune-project.org
# Required build dependencies
Depends: dune-grid dune-localfunctions
# Optional build dependencies
#Suggests:
~~~


它由以下形式的行组成

~~~Shell
<keyword>: <value(s)>
~~~

以#开头的行被视为注释。可能的关键词有：。

- `Module` : `dunecontrol` 构建系统的官方模块名称。其他模块对这个模块的依赖必须使用这个名称。然而，只改变这个字符串并不足以完全改变模块的名称。这个名字在模块的主CMakeLists.txt文件中也是硬编码的，它也是`dune-foo.pc.in`文件名称的一部分。

- `Version` : 一个编码模块版本的字符串。除了文档值之外，它还允许依赖一个模块的特定版本。版本字符串应该遵循X.Y.Z方案，但也可以附加其他任意的后缀。按照惯例，当前开发分支上的版本是X.Y-git，其中X.Y是下一个版本的计划编号。版本号在$\mathrm{C}++$代码中也可以通过`config.h`文件中定义的预处理器变量获得（见附录A.2.3）。

- `Maintainer` : 负责模块维护和错误修复的人或团体的联系电子邮件地址。出现在 `PACKAGE_BUGREPORT` 文件 `config.h` 中定义的预处理程序变量中。

- `Depends` : 以白空间分隔的DUNE模块列表，本模块需要这些模块来构建和正常运行。这里使用的名字是在各个模块的dune.module文件中给出的名字。请注意，在构建和运行时的依赖关系之间没有区别。这里只需要列出直接依赖关系--间接依赖关系由 `dunecontrol` 自动解决。

依赖关系可以是版本的，也就是说，只有特定版本或版本范围内的模块才满足依赖关系。版本要求出现在模块名称后面的括号中，其形式为(<运算符><版本>)。有效的操作符是 $<=,=,>=,<$ 和 $>.$ 例如，$(>=2.7.0)$ 表示模块必须有 $2.7.0$ 或更高版本。两个条件可以用\&&表示 "和"，||表示 "或"。例如，通过写 $2.7.0$ 和 $3.0.0$ 之间的版本，要求 $(>=2.7 \& \&<3.0)$ 。

另一方面，`dunecontrol`选项-skipversioncheck允许不考虑这些检查。

- `Suggests` : 以空格分隔的DUNE模块列表，该模块可以使用这些模块，但这些模块对于构建该模块来说并不是严格必要的。通常情况下，这些模块允许在构建时启用额外的功能。当建议的依赖性不满足时，`dunecontrol`发出警告，但不会中止构建过程。例如，`dune-grid`模块将`dune-uggrid`列为一个建议。

如果发现了建议的依赖关系，这将通过定义变量 `<module>_FOUND` 向 cmake 发出信号，其中 `<module>` 是 DUNE 模块的名称。因此，例如，在 `CMakeLists.txt` 文件中，编译可以由以下结构控制

~~~C++
if (dune-uggrid_FOUND)
    add_executable("unstructured-grid-example" unstructured-grid-example.cc)
endif ()
~~~


建议的依赖性的存在是通过定义预处理器变量 `HAVE_<MODULE_NAME>` 到 1 来向 $\mathrm{C}++$ 代码发出信号。这里`<MODULE_NAME>`是模块名称，但用大写字母写，连字符用下划线代替。


\section{A.2.3. The Files `config.h` and `config.h.` cmake}

正如Unix系统上的$\mathrm{C}++$软件一样，每个DUNE模块的构建系统都会在模块的构建目录中写入一个叫做`config.h`的文件。这个文件包含了一些构建系统关于构建环境的知识，通过一系列的预处理器宏转移到$\mathrm{C}++$代码中。DUNE模块中的所有非头文件$\mathrm{C}++$都应包括`config.h`作为其第一个头文件。

`config.h`文件中的第一块信息包含了`dune.module`文件中规定的一些元数据。例如，带有附录A.2.2的`dune.module`文件的模块的`config.h`文件将包含以下定义

~~~C++
#define HAVE_DUNE_GRID 1
~~~

以及`dune-grid`的版本号，形式为

~~~C++
#define DUNE_GRID_VERSION "2.7.0"
#define DUNE_GRID_VERSION_MAJOR 2
#define DUNE_GRID_VERSION_MINOR 7
#define DUNE_GRID_VERSION_REVISION 0
~~~


此外，该文件还包含所有直接和间接依赖关系的类似定义。例如，如果该模块依赖于dune-grid，那么其config.h文件将包含

以及`dune-grid`的版本号，形式为

来自`dune-common`模块的头文件`dune/common/version.hh`包含了在$\mathrm{C}++$代码中方便地处理这些版本信息的工具。

此外，任何模块都可以在其`config.h`文件中提供任何种类的额外模块特定信息。此外，这些信息将出现在所有下游模块的`config.h`文件中。打算出现在`config.h`中的信息需要写进模板文件`config.h.cmake`，它是每个DUNE模块的一部分。这个过程严格遵循cmake的程序，这里不做解释。详情请见cmake文档。

\section{A.2.4. Adding New Code to a Dune Module}

新的代码被添加到DUNE模块中，就像添加到任何其他带有cmake构建系统的$\mathrm{C}++$软件中一样，但有一些DUNE特有的功能。

由于DUNE几乎到处都使用$\mathrm{C}++$模板，很多典型的DUNE代码都保存在头文件中。新的头文件应该放在 `dune/<modulename>` 文件夹中，或其子文件夹中。在一个重模板的代码中，所有的头文件通常被下游模块所需要，因此它们必须被安装。标准的cmake机制被用于此。在要安装的头文件目录的 `CMakeLists.txt` 文件中，将头文件添加到安装指令的文件列表中。

~~~Shell
install(FILES
header1.hh
header2.hh
[...]
DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/<header path in source tree>)
~~~

给出的头文件路径是相对于主模块安装目录的，也就是说，它应该以 `dune/` 开始。

实际上编译代码需要DUNE特有的cmake宏。要创建一个库，使用cmake命令


~~~Shell
dune_add_library(<basename> SOURCES <sourcefile>.cc)
~~~


这将创建静态库和共享库。在Unix系统中，它们将分别被称为 `lib<basename>.a` 和 `lib<basename>` .so。选项SOURCES指定了一个以空格分隔的源文件列表，这些文件将被编译和连接到库中。其他库可以通过`ADD_LIBS`选项被纳入。请查阅在线文档以了解更多的可能性。

要被编译成可执行文件的文件（如模拟代码或例子）必须通过标准的cmake命令宣布给cmake。

~~~Shell
add_executable(<executablename> <sourcefile>.cc)
~~~

它将名为<sourcefile>.cc的源文件编译成名为<executablename>的可执行文件。各种选项允许影响编译和连接过程。这种可执行文件的源代码通常放在主模块源代码目录下的src目录中，而不是在dune下。

可执行文件需要以包含路径、链接库、编译器和链接器选项的形式获得有关其依赖关系的信息。所有这些都由一个叫做 `dune_enable_all_packages` 的 cmake 宏自动处理，它在顶层的 `CMakeLists.txt` 文件中被调用（在调用 `add_subdirectory` 之前）。这个宏将构建系统发现的所有依赖项的路径、标志等添加到所有可执行文件中。这意味着，只要有相应的`add_executable`调用，所有的可执行文件通常都会在开箱后构建和链接。其代价是在构建可执行文件时，一长串可能不需要的路径和标志被交给编译器和链接器，但这通常不是问题。

对于那些想要更多控制的用户，DUNE构建系统提供了专门的宏来添加个别的依赖性到可执行文件。例如，在任何依赖 `dune-istl` 的DUNE模块中，这一行

~~~Shell
add_dune_umfpack_flags(<executablename>)
~~~

如果使用直接稀疏解算器 `UMFPACK` [^46] ，将添加构建<executablename>所需的所有标志和路径。同样，还有 `add_dune_mpi_flags` , `add_dune_parmetis_flags` ，以及许多其他的。如果依赖的是DUNE模块本身，就不需要这样的宏了。手动连接库可以通过 `target_link_libraries` 命令完成。更多的控制可以使用cmake功能，如 `set_property` 和 `get_property` 。

\section{A.2.5. Dependencies that are not Dune Modules}

并非一个 DUNE 模块的所有依赖都是其他 DUNE 模块。这样的外部依赖关系不会被 `dunecontrol` 程序自动处理，而需要由 cmake 直接处理。cmake 程序用它的 `find_package` 命令来寻找这种依赖关系。如果外部代码有足够的 cmake 识别能力， 那么它可能在某个标准位置提供了一个 `config-file` 包。然后 `find_package` 命令将找到外部依赖的库、头文件以及所有进一步的相关信息。

如果没有`config-file`包，DUNE模块本身必须提供一个所谓的`find-module`包，它寻找依赖关系，并确定它所需要的各种编译器和链接器标志。每个自定义的`find-module`是一个专门的文件，必须保存在使用它的第一个DUNE模块的`cmake/modules`文件夹中。对于一个名为 SomePackage 的外部包，cmake `find-module` 必须被称为 `FindSomePackage.cmake` 。  如果 cmake 遇到 `find_package` (SomePackage) 命令，而又找不到相应的 `config-file` 包，它会搜索文件 `FindSomePackage.cmake` ，并执行其中的代码。这段代码应该确定所有相关的信息，并将其写入标准的 cmake 变量中。许多这样的 `find-module` 包在网上都有。根据外部依赖关系的普遍程度，可能不需要从头开始编写 `find-module`。

通过 `dune_enable_all_packages` 机制（见上文），新的依赖关系的编译器和链接器标志将应用于所有可执行文件的构建。为了使 `dune_enable_all_packages` 能够接受新的依赖关系，需要注册新的标志。这可以通过宏的方式完成

~~~Shell
dune_register_package_flags(INCLUDE_DIRS <list of directories>
                                LIBRARIES <list of libraries>)
~~~

它应该在 `find-module` 的最后被调用。这些选项允许将头文件路径和库添加到 `dune_enable_all_packages` 保存的全局标志列表中。此外，`COMPILE_OPTIONS`允许设置特定的编译器选项，而选项`COMPILE_DEFINITIONS`可以用来设置预处理器的标志。

对于每个寻找名为 SomePackage 的软件的自定义 `find-module` ，提供一个宏 `add_dune_somepackage_flags` 也是很好的风格，它应该被定义在 cmake/modules 文件夹中的 AddSomePackageFlags. cmake 中。这个宏应该为单个可执行文件提供所有必要的路径和选项（见上文），并且是在 `dune_enable_all_packages` 不合适时使用的工具。


\section{A.2.6. Documentation}

DuNE构建系统提供了基础设施，使用DOXYGEN工具来构建代码的文档，使用IATEX来构建一般文档。一个DUNE模块的所有文档都是通过调用

~~~Shell
make doc
~~~

在该模块的构建目录中。

DOXYGEN程序解析源代码，从中提取注释块，并从这些注释中构建各种输出格式的文档。默认情况下，DUNE构建系统将调用DOXYGEN，以产生HTML输出。HTML文档将出现在构建目录中的`doc/doxygen/html`文件夹中，主页面是`doc/doxygen/html/index.html` 。

DOXYGEN是由一大批选项控制的。这些选项被存储在一个文本文件中，通常被称为Doxyfile。原则上，每个DUNE模块都可以有自己的Doxyfile；然而，典型的Doxyfile在不同的模块之间差别不大。因此，DUNE构建系统在一个单独的文件中包含了共同的部分，称为Doxystyle，它位于 `dune-common/doc/doxygen` 。每个下游模块只保留一个名为Doxylocal的文本文件，其中包含模块的特定位。当make doc被调用时，这两个文件被连接起来，模块名称和目录的占位符被替换成实际值。这里是默认的Doxylocal文件，由`duneproject`编写，略微缩短了形式。

~~~Shell
# The INPUT tag can be used to specify the files and/or directories that contain
# documented source files. You may enter file names or directories, separated
# by spaces.

INPUT += @top_srcdir@/dune/

# The EXCLUDE tag can be used to specify files and/or directories that should
# be excluded from the INPUT source files.

# EXCLUDE += @top_srcdir@/dune/foo/test

# The EXAMPLE_PATH tag can be used to specify one or more files or
# directories that contain example code fragments that are included
# with the \include command.

# EXAMPLE_PATH += @top_srcdir@/src
# The IMAGE_PATH tag can be used to specify one or more files or
# directories that contain image that are included with the \image command.

# IMAGE_PATH += @top_srcdir@/dune/foo/pics

~~~


\section{A. The DUNE Build System}

该文件主要决定在哪里寻找源文件、图像和其他输入。变量`@top_srcdir`被模块源代码目录的绝对路径所取代。进一步的`DOXYGEN`选项可以被添加到Doxylocal中，然后将覆盖`dune-common`模块中Doxystyle文件的默认值。

默认情况下，一个模块的doc目录只包含doxygen子目录和一个微不足道的`CMakeLists.txt`文件。然而，它也可能包含其他格式的模块信息的进一步子文件夹。对于`IATEX`文件，DUNE构建系统提供了UseLatexMk. cmake工具，它使用latexmk从`IATEX`源构建pdf文件。它提供了一个单一的命令

~~~Shell
add_latex_document(SOURCE <texsource>.tex)
~~~

其中`<texsource>.tex`应该是一个`IATEX`文件。由于latexmk程序是用来调用$\mathrm{T}_{\mathrm{E}} \mathrm{X}$引擎的，所有的依赖性跟踪都是在内部进行的，对pdflatex、bibtex等所需的调用次数是自动进行的，无需用户进一步干预。add_latex_document宏有更多的选项，这些选项在在线文档中有所描述。

`UseLatexMk.cmake`宏还引入了一个名为`clean_latex`的make目标，它删除了所有由`IATEX`工具链创建的文件。这允许从头开始构建DuNE模块的`IATEX`文件，而不触及C++代码的构建。

\section{A.2.7. Automated Tests}

许多DUNE模块包含测试程序，检查模块功能的各个部分。这些测试的范围从验证单个类的特定细节功能的小型单元测试一直到运行完整的数值模拟并检查结果是否正确的全面的集成测试。拥有这样的测试是专业软件开发的一个重要部分，特别是对于像DUNE这样的富含模板的代码，在构建模块时，很多代码并没有被真正锻炼过。没有测试，很多bug只有在下游使用模块的代码时才会显现。测试源通常被收集在名为test的目录中。可能有一个或多个这样的目录，在一个模块的目录层次中的不同位置。

构建模块时，测试不会自动构建。相反，编译和链接测试需要手动触发，使用命令

在构建目录中。这将产生一组测试可执行文件，可以像其他可执行文件一样单独运行。整个测试集可以使用 ctest 命令运行，该命令是正常 cmake 安装的一部分。它调用一个模块的所有可用测试，并以概览形式报告结果。查看 ctest -help 可以得到很多有用的选项，比如通过匹配正则表达式来选择要运行的测试集，或者显示失败测试的输出。

一个新写的测试被cmake宏宣布给DUNE构建系统。

~~~Shell
dune_add_test(SOURCES <testsource>.cc)
~~~

它将测试添加到 `build_tests` 目标中，提供必要的编译器和链接器标志，并将测试添加到由 ctest 运行的程序列表中。测试行为可以通过 `dune_add_test` 命令的各种选项来控制。

- `COMPILE_ONLY` : 如果设置，给定的测试将在make过程中被编译 `build_tests` ，但它不会被test运行。这对于减少测试时间很有用。

- `CMAKE_GUARD` : 这允许根据 cmake 变量有条件地构建单元测试。它的参数是一个布尔条件。如果这个条件被评估为 `FALSE` ，测试源将被一个只返回值 77 的假源取代，并且 ctest 将忽略测试结果。这种方法比用 cmake 的 if-clause 来保护对 `dune_add_test` 的调用更为可取。这个测试至少会出现在测试结果列表中，即使它不能被构建或运行。

- `MPI_RANKS` : 为了测试有关分布式计算的功能，一个测试可能需要在一个以上的进程上运行。可以给`MPI_RANKS`选项一个数字列表，对这个列表中的每个数字进行一次测试。数字决定了该次运行要使用多少个进程。全局限制可以通过环境变量 `DUNE_MAX_TEST_CORES` 的形式来设置。

- `TIMEOUT` : 允许运行测试的最大时间（秒）。这可以防止死锁的分布式测试完全锁住系统。它的默认值是5分钟，但在使用 `MPI_RANKS` 选项时，必须设置一个明确的值。

这些只是比较突出的选项，完整的清单请查阅在线文档。









\section{Bibliography}

[^1]: D. Abrahams and A. Gurtovoy. $C++$ Template Metaprogramming. AddisonWesley, 2005 .

[^2]: M. Alkämper, A. Dedner, R. Klöfkorn, and M. Nolte. "The DUNE-ALUGrid Module". In: Archive of Numerical Software 4.1 (2016), pp. 1-28.

[^3]: E. L. Allgower and K. Georg. Introduction to Numerical Continuation Methods. Vol. 45. Classics in Applied Mathematics. SIAM, 2003 .

[^4]: D. N. Arnold, F. Brezzi, B. Cockburn, and L. D. Marini. "Unified Analysis of Discontinuous Galerkin Methods for Elliptic Problems". In: SIAM J. Numer. Anal. $39.5(2002)$ , pp. 1749-1779.

[^5]: M. Bader. Space-Filling Curves - An Introduction with Applications in Scientific Computing. Springer, 2013 .

[^6]: S. Balay, S. Abhyankar, M. F. Adams, J. Brown, P. Brune, $K$ . Buschelman, V. Eijkhout, W. D. Gropp, D. Kaushik, M. G. Knepley, L. C. McInnes, K. Rupp, B. F. Smith, and H. Zhang. PETSc Users Manual. Tech. rep. ANL-95/11 Revision 3.5. Argonne National Laboratory, 2014. URL: http://www .mcs . anl. gov/petsc.

[^7]: S. Balay, W. D. Gropp, L. C. McInnes, and B. F. Smith. "Efficient Management of Parallelism in Object Oriented Numerical Software Libraries". In: Modern Software Tools in Scientific Computing. Ed. by E. Arge, A. M. Bruaset, and H. P. Langtangen. Birkhäuser Press, 1997 , pp. 163-202.

[^8]: W. Bangerth, R. Hartmann, and G. Kanschat. "deal.II - a General Purpose Object Oriented Finite Element Library". In: ACM Trans. Math. Softw. $33.4$ $(2007)$ , pp. $24 / 1-24 / 27$ .

[^9]: R. E. Bank. "Hierarchical bases and the finite element method". In: Acta Numerica 5 (Jan. 1996), pp. 1-43. DOI: 10.1017/S0962492900002610.

[^10]: R. E. Bank, A. H. Sherman, and A. Weiser. "Some Refinement Algorithms and Data Structures for Regular Local Mesh Refinement". In: Scientific Computing. Applications of Mathematics and Computing to the Physical Sciences. Ed. by R. Stepleman. North-Holland, 1983, pp. 3-17.

[^11]: J. W. Barrett and C. M. Elliott. "Finite Element Approximation of the `Dirichlet` Problem Using the Boundary Penalty Method". In: Numerische Mathematik $49(1986)$ , pp. $343-366$ .

[^12]: T. Barth, R. Herbin, and M. Ohlberger. "Finite Volume Methods: Foundation and Analysis". In: Encyclopedia of Computational Mechanics. 2nd edition. Wiley, 2017. DOI: $10.1002 / 9781119176817$ . ecm2010.

[^13]: P. Bastian, K. Birken, K. Johannsen, S. Lang, N. Neuß, H. Rentz-Reichert, and C. Wieners. "UG - a flexible Software toolbox for solving partial differential equations". In: Comp. Vis. Sci $1(1997)$ , pp. $27-40$ .

[^14]: P. Bastian and M. Blatt. "On the Generic Parallelisation of Iterative Solvers for the Finite Element Method". In: Int. J. Computational Science and Engineering $4.1(2008)$ , pp. $56-69$ . DOI: 10.1504/IJCSE.2008.021112.

[^15]: P. Bastian, M. Blatt, A. Dedner, C. Engwer, R. Klöfkorn, R. Kornhuber, M. Ohlberger, and O. Sander. "A Generic Interface for Parallel and Adaptive Scientific Computing. Part II: Implementation and Tests in DUNE". In: Computing $82.2-3(2008)$ , pp. $121-138$ .

[^16]: P. Bastian, M. Blatt, A. Dedner, C. Engwer, R. Klöfkorn, M. Ohlberger, and O. Sander. "A Generic Interface for Parallel and Adaptive Scientific Computing. Part I: Abstract Framework". In: Computing $82.2-3(2008)$ , pp. 103-119.

[^17]: P. Bastian, M. Blatt, A. Dedner, N.-A. Dreier, C. Engwer, R. Fritze, C. Gräser, C. Grüninger, D. Kempf, R. Klöfkorn, M. Ohlberger, and O. Sander. "The DUNE Framework: Basic Concepts and Recent Developments". In: Computers and Mathematics with Applications (2020). DOI: 10.1016/j.camwa. $2020.06$ . 007

[^18]: P. Bastian, C. Engwer, J. Fahlke, M. Geveler, D. Göddeke, O. Iliev, O. Ippisch, R. Milk, J. Mohring, S. Müthing, M. Ohlberger, D. Ribbrock, and S. Turek. "Advances Concerning Multiscale Methods and Uncertainty Quantification in EXA-DUNE". In: Software for Exascale Computing - SPPEXA 2013-2015. Ed. by H.-J. Bungartz, P. Neumann, and W. Nagel. Vol. 113. Lecture Notes in Computational Science and Engineering. Springer, 2016, pp. $25-43$ . DOI: $10.1007 / 978-3-319-40528-5_{-} 2$ .

[^19]: P. Bastian, C. Engwer, J. Fahlke, M. Geveler, D. Göddeke, O. Iliev, O. Ippisch, R. Milk, J. Mohring, S. Müthing, M. Ohlberger, D. Ribbrock, and S. Turek. "Hardware-Based Efficiency Advances in the EXA-DUNE Project". In: Software for Exascale Computing - SPPEXA 2013-2015. Ed. by H.-J. Bungartz, P. Neumann, and W. Nagel. Vol. 113. Lecture Notes in Computational Science and Engineering. Springer, 2016, pp. $3-23$ . DOI: $10.1007 / 978-3-319-40528$ 5_1.

[^20]: P. Bastian, F. Heimann, and S. Marnach. "Generic implementation of finite element methods in the distributed and unified numerics environment (DUNE)". In: Kybernetika $46.2(2010)$ , pp. 294-315. [^21] L. Beirão da Veiga, F. Brezzi, A. Cangiani, G. Manzini, L. D. Marini, and A. Russo. "Basic Principles of Virtual Element Methods". In: Mathematical Models and Methods in Applied Sciences $23.01(2013)$ , pp. $199-214$ . DOI: $10$ . 1142/S0218202512500492.

[^22]: W. Benger. "Visualization of General Relativistic Tensor Fields via a Fiber Bundle Data Model". PhD thesis. Freie Universität Berlin, $2005$ .

[^23]: C. Bernardi, Y. Maday, and A. Patera. "Domain Decomposition by the Mortar Element Method". In: Asymptotic and Numerical Methods for Partial Differential Equations with Critical Parameters. Ed. by H. Kaper, M. Garbey, and G. Pieper. Vol. 384. NATO ASI Series (Series C: Mathematical and Physical Sciences). Springer, 1993, pp. $269-286$ . DOI: $10.1007 / 978-94-011-1810-1_{-} 17$ .

[^24]: G. Berti. "Generic Software Components for Scientific Computing". PhD thesis. Technische Universität Cottbus, 2000 .

[^25]: J. Bey. "Tetrahedral Grid Refinement". In: Computing $55.4$ (1995), pp. 355378

[^26]: P. Binev, W. Dahmen, and R. DeVore. "Adaptive finite element methods with convergence rates". In: Numerische Mathematik $97.2$ (2004), pp. 219-268.

[^27]: A. Björner, M. L. Vergnas, B. Sturmfels, N. White, and G. M. Ziegler. Oriented Matroids. 2 nd edition. Vol. $46$ . Encyclopedia of mathematics and its applications. Cambridge University Press, $1999$ .

[^28]: BLAST Forum. "Basic Linear Algebra Subprograms Technical (BLAST) Forum Standard". In: International Journal of High Performance Applications and Supercomputing 16.1 (2001). URL: http: // www.netlib.org/blas/blastforum/.

[^29]: M. Blatt and P. Bastian. "The Iterative Solver Template Library". In: $A p$ plied Parallel Computing. State of the Art in Scientific Computing. Ed. by B. Kagstrüm, E. Elmroth, J. Dongarra, and $\mathrm{J}$ . Wasniewski. Lecture Notes in Scientific Computing 4699. 2007, pp. 666-675. URL: $10.1007 / 978-3$ - 540$ 75755-9 \% 5 C_82.

[^30]: M. Blatt. "A Parallel Algebraic Multigrid Method for Elliptic Problems with Highly Discontinuous Coefficients". PhD thesis. Universität Heidelberg, $2010$ .

[^31]: M. Blatt, O. Ippisch, and P. Bastian. "A massively parallel algebraic multigrid preconditioner based on aggregation for elliptic problems with heterogeneous coefficients". In: ArXiv e-prints (Sept. 2012). arXiv: $1209.0960$ [math. NA].

[^32]: D. Boffi, F. Brezzi, and M. Fortin. Mixed Finite Element Methods and Applications. Springer, 2013 .

[^33]: R. F. Boisvert, R. Pozo, and K. A. Remington. The Matrix Market Exchange Formats: Initial Design. NISTIR $5935$ . National Institute of Standards and Technology, $1996$ . 

[^34]: M. Bolten and H. Rittich. "Fourier Analysis of Periodic Stencils in Multigrid Methods". In: SIAM Journal on Scientific Computing $40.3(2018)$ , A1642A1668. DOI: $10.1137 / 16 \mathrm{M} 1073959$ .

[^35]: E. G. Boman, Ü. V. Çatalyurek, C. Chevalier, and K. D. Devine. "The Zoltan and Isorropia parallel toolkits for combinatorial scientific computing: Partitioning, ordering, and coloring". In: Scientific Programming $20.2$ (2012), pp. 129 $150$ .

[^36]: N. Botta, C. Ionescu, C. Linstead, and R. Klein. Structuring distributed relationbased computations with $S C D R C $ . Tech. rep. PIK Report No. 103 , Potsdam Institute for Climate Impact Research, $2006$ .

[^37]: D. Braess. Finite Elemente. Springer, 2013 .

[^38]: A. Bressan, S. Canić, M. Garavello, M. Herty, and B. Piccoli. "Flows on networks: recent results and perspectives". In: EMS Surv. Math. Sci. $1.1$ (2014), pp. 47-111.

[^39]: F. Brooks. The Mythical Man-Month. Addison-Wesly, 1975 .

[^40]: A. Burri, A. Dedner, R. Klöfkorn, and M. Ohlberger. "An efficient implementation of an adaptive and parallel grid in DUNE". In: Proc. of the $2 n d$ Russian-German Advanced Research Workshop on Computational Science and High Performance Computing. $2005$ .

[^41]: Y. Chen, T. A. Davis, W. W. Hager, and S. Rajamanickam. "Algorithm 887: CHOLMOD, Supernodal Sparse Cholesky Factorization and Update/Downdate". In: ACM Trans. Math. Softw. $35.3(2008), 22: 1-22: 14$ . DOI: $10.1145 /$ $1391989.1391995$ .

[^42]: P. Ciarlet. The finite element method for elliptic problems. SIAM, 2002 .

[^43]: T. H. Cormen, C. E. Leiserson, and R. L. Rivest. Introduction to Algorithms. MIT Press, 1990 .

[^44]: J. A. Cottrell, T. J. R. Hughes, and Y. Bazilevs. Isogeometric Analysis. Wiley, $2009$ .

[^45]: M. Crouzeix and P.-A. Raviart. "Conforming and nonconforming finite element methods for solving the stationary Stokes equations I". In: Revue francaise d'automatique informatique recherche opérationnelle 7.R3 (1973), pp. 33-75.

[^46]: T. A. Davis. "Algorithm 832: UMFPACK V4.3-an unsymmetric-pattern multifrontal method". In: ACM Transactions on Mathematical Software (TOMS) $30.2(2004)$ , pp. $196-199$ .

[^47]: T. A. Davis. Direct Methods for Sparse Linear Systems. SIAM, 2006. DOI: $10.1137 / 1.9780898718881$ .

[^48]: A. Dedner, R. Klöfkorn, M. Nolte, and M. Ohlberger. "A generic interface for parallel and adaptive scientific computing: Abstraction principles and the DUNE-FEM module". In: Computing $90.3$ (2011), pp. 165-196. [^49] A. Dedner and M. Nolte. "Construction of Local Finite Element Spaces Using the Generic Reference `Elements`". In: Advances in DUNE. Ed. by A. Dedner, B. Flemisch, and R. Klöfkorn. Springer, 2012, pp. 3-16.

[^50]: A. Dedner and M. Nolte. "The Dune Python Module". In: arXiv e-prints (2018). arXiv: $1807.05252$ [CS.MS]

[^51]: P. Deuflhard. Newton Methods for Nonlinear Problems. Springer, 2006 .

[^52]: P. Deuflhard and A. Hohmann. Numerische Mathematik I. de Gruyter, $1991$ .

[^53]: P. Deuflhard and M. Weiser. Adaptive Numerical Solution of PDEs. de Gruyter, $2012$ .

[^54]: R. Diestel. Graph Theory. 5 th edition. Springer, $2016$ .

[^55]: V. Dolejší and M. Feistauer. Discontinuous Galerkin Method. Springer Series in Computational Mathematics 48. Springer, 2015 .

[^56]: J. Dongarra. Freely Available Software for Linear Algebra. online. last checked on Jul. 21.2020. URL: http://www.netlib.org/utk/people/ JackDongarra/laSw. html.

[^57]: W. Dörfler. "A Convergent Adaptive Algorithm for Poisson's Equation". In: SIAM J. Numer. Anal. $33.3(1996)$ , pp. 1106-1124.

[^58]: J. Douglas and T. Dupont. "Interior Penalty Procedures for Elliptic and Parabolic Galerkin Methods". In: Computing Methods in Applied Sciences. Ed. by R. Glowinski and L. J.L. Vol. $58$ . Lecture Notes in Physics. Springer, 1976, pp. 207-216.

[^59]: \quad \mathrm{K}$ . Driesen and U. Hölzle. "The Direct Cost of Virtual Function Calls in C++". In: Proceedings of the 11th ACM SIGPLAN Conference on Object-oriented Programming, Systems, Languages, and Applications. OOPSLA '96. ACM, 1996, pp. 306-323.

[^60]: G. Dziuk and C. Elliott. "Surface Finite `Elements` for Parabolic Equations". In: Journal of Computational Mathematics $25.4(2007)$ , pp. $385-407$ .

[^61]: C. Engwer, C. Gräser, S. Müthing, and O. Sander. "Function space bases in the `dune-functions` module". In: ArXiv e-prints (2018). eprint: $1806.09545$ (cs.MS).

[^62]: C. Engwer, C. Gräser, S. Müthing, and O. Sander. "The interface for functions in the `dune-functions` module". In: Archive of Numerical Software $5.1(2017)$ , pp. $95-105$ . DOI: $10.11588 /$ ans $ .2017 .1 .27683$ .

[^63]: A. Ern and J.-L. Guermond. Theory and Practice of Finite `Elements`. Springer, $2004$ .

[^64]: L. C. Evans. Partial Differential Equations. 2nd edition. American Mathematical Society, 2010 . 

[^65]: R. Eymard, G. Henry, R. Herbin, F. Hubert, R. Klöfkorn, and G. Manzini. "3D Benchmark on Discretization Schemes for Anisotropic Diffusion Problems on General Grids". In: Finite Volumes for Complex Applications VI Problems \& Perspectives. Ed. by J. Fort, J. Fürst, J. Halama, R. Herbin, and F. Hubert. Vol. 4. Springer Proceedings in Mathematics. Springer, 2011, pp. $895-930$ . DOI: $10.1007 / 978-3-642-20671-9_89$ .

[^66]: R. Eymard, T. Gallouët, and R. Herbin. "Finite Volume Methods". In: Handbook of Numerical Analysis. Ed. by P. Ciarlet and J. Lions. Vol. 7. Elsevier, 2000, pp. 713-1018.

[^67]: H. Fahs. "Discontinuous Galerkin Method for Time-Domain Electromagnetics on Curvilinear Domains". In: Applied Mathematical Sciences $4.19$ (2010), pp. $943-958$ .

[^68]: R. Falgout, J. Jones, and U. Yang. "The Design and Implementation of hypre, a Library of Parallel High Performance Preconditioners". In: Numerical Solution of Partial Differential Equations on Parallel Computers. Ed. by A. M. Bruaset and A. Tveito. Vol. 51 . Lecture Notes in Computational Science and Engineering. Springer, 2006, pp. 267-294. DOI: $10.1007 / 3-540-31619-1_{-} 8$ .

[^69]: A. Fomins and B. Oswald. "Dune-CurvilinearGrid: Parallel Dune Grid Manager for Unstructured Tetrahedral Curvilinear Meshes". In: arXiv e-prints $(2016)$ . arXiv: $1612.02967$ [cs.CG].

[^70]: H. Freudenthal. "Simplizialzerlegungen von beschränkter Flachheit". In: Ann. Math. $43.3(1942)$ , pp. $580-582$ .

[^71]: T.-P. Fries and T. Belytschko. "The extended/generalized finite element method: An overview of the method and its applications". In: International Journal for Numerical Methods in Engineering $84.3(2010)$ , pp. $253-304$ . DOI: $10.1002 /$ nme. 2914 .

[^72]: E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: `Elements` of Reusable Object-Oriented Software. Addison-Wesley, $1994$ .

[^73]: C. Gersbacher. "The Dune-PrismGrid Module". In: Advances in DUNE. Ed. by A. Dedner, B. Flemisch, and R. Klöfkorn. Springer, 2012, pp. 33-44.

[^74]: C. Geuzaine and F. Remacle. Gmsh Reference Manual. 2015. URL: http: //www.geuz.org/gmsh/doc/texinfo/gmsh.pdf.

[^75]: G. H. Golub and C. F. V. Loan. Matrix Computations. 3rd edition. The John Hopkins University Press, 1996 .

[^76]: S. Götschel, M. Weiser, and A. Schiela. "Solving Optimal Control Problems with the Kaskade7 Finite Element Toolbox," in: Advances in DUNE. Ed. by A. Dedner, B. Flemisch, and R. Klöfkorn. 2012, pp. 101-112.

[^77]: P. Gottschling, $\mathrm{T}$ . Witkowski, and A. Voigt. "Integrating object-oriented and generic programming paradigms in real-world software environments: Experiences with AMDiS and MTL4". In: POOSC 2008 at ECOOP08. Paphros, Cyprus, 2008 . 

[^78]: J. Grande. Red-Green Refinement of Simplicial Meshes in D Dimensions. Tech. rep. 436. IGPM, RWTH Aachen, 2015. URL: https://www.igpm.rwthaachen.de/Download/reports/pdf/IGPM436.pdf.

[^79]: T. Granlund and the GMP development team. GNU MP - The GNU multiple precision arithmetic library. Version 6.1.0. Free Software Foundation. 2015 . URL: https://gmplib.org/gmp-man-6.1.0.pdf.

[^80]: C. Gräser, M. Kahnt, and R. Kornhuber. "Numerical approximation of multiphase Penrose-Fife systems". In: Comput. Methods Appl. Math. $16.4(2016)$ , pp. $523-542$ . DOI: $10.1515 / \mathrm{cmam}-2016-0020$ .

[^81]: C. Gräser, R. Kornhuber, and U. Sack. "On hierarchical error estimators for time-discretized phase field models". In: Numerical Mathematics and Advanced Applications 2009. Ed. by G. Kreiss, P. Lötstedt, A. Malqvist, and M. Neytcheva. 2010, pp. $397-405$ . DOI: $10.1007 / 978-3-642-11795-4_42$ .

[^82]: C. Gräser and O. Sander. "The dune-subgrid Module and Some Applications". In: Computing 8.4 (2009), pp. 269-290.

[^83]: C. Gräser and O. Sander. "Truncated Nonsmooth Newton Multigrid Methods for Block-Separable Minimization Problems". In: IMA Journal of Numerical Analysis $39.1(2018)$ , pp. $454-481$ .

[^84]: A. Greenbaum. Iterative Methods for Solving Linear Systems. SIAM, $1997$ .

[^85]: A. Griewank and A. Walther. Evaluating derivatives: principles and techniques of algorithmic differentiation. 2 nd edition. SIAM, 2008 .

[^86]: S. Gross and A. Reusken. Numerical Methods for Two-phase Incompressible Flows. Vol. 40. Series in Computational Mathematics. Springer, $2011$ .

[^87]: G. Guennebaud, B. Jacob, et al. Eigen v3. 2010. URL: http: / / eigen. tuxfamily.org.

[^88]: W. Hackbusch. Multi-Grid Methods and Applications. Springer, $1985$ . DOI: $10.1007 / 978-3-662-02427-0$ .

[^89]: W. Hackbusch and A. Reusken. "Analysis of a damped nonlinear multilevel method". In: Numerische Mathematik $55.2(1989)$ , pp. $225-246$ . DOI: $10.1007 /$ BF01406516.

[^90]: A. Hatcher. Algebraic Topology. Cambridge University Press, 2002 .

[^91]: J. Heinonen, T. Kilpeläinen, and O. Martio. Nonlinear potential theory of degenerate elliptic equations. Dover Publications, $2006$ .

[^92]: J. Hennessy and D. Patterson. Computer Architecture - A Quantitative Approach. 5 th edition. Morgan Kaufmann, $2011$ .

[^93]: M. A. Heroux, R. A. Bartlett, V. E. Howle, R. J. Hoekstra, J. J. Hu, T. G. Kolda, R. B. Lehoucq, K. R. Long, R. P. Pawlowski, E. T. Phipps, A. G. Salinger, H. K. Thornquist, R. S. Tuminaro, J. M. Willenbring, A. Williams, and K. S. Stanley. "An overview of the Trilinos project". In: $A C M$ Trans. Math. Softw. $31.3(2005)$ , pp. $397-423$ . DOI: $10.1145 / 1089014.1089021$ . 

[^94]: J. S. Hesthaven and T. Warburton. Nodal Discontinuous Galerkin Methods. Springer, 2008 .

[^95]: W. Huang and R. D. Russell. Adaptive Moving Mesh Methods. Springer, 2011 .

[^96]: J. Hubička. Devirtualization in $C++$ . online blog. (at least) seven parts, last checked on Jul. 21.2020. 2014. URL: http://hubicka.blogspot.de/2014/01/ devirtualization-in-c-part-1.html.

[^97]: International Organization for Standardization. $C++$ extensions for concepts. ISO/IEC. 2015. URL: https:// www.iso.org/standard/64031.html.

[^98]: International Organization for Standardization. ISO/IEC 14882:2011 Programming Language $\mathrm{C}++.2011$ .

[^99]: International Organization for Standardization. ISO/IEC 14882:2017 Programming Language $\mathrm{C}++.2017$ .

[^100]: O. Ippisch and M. Blatt. "Scalability of $\mu \varphi$ and the Parallel Algebraic Multigrid Solver in `dune-istl`". In: Hierarchical Methods for Dynamics in Complex Molecular Systems. Vol. 10. Forschungszentrum Jülich GmbH, 2012, pp. 527 $532$ .

[^101]: V. John. Finite Element Methods for Incompressible Flow Problems. Springer, $2016$ .

[^102]: S. Josefsson. The Base16, Base32, and Base64 Data Encodings. RFC 4648 . Network Working Group, 2006. URL: https://tools.ietf.org/html/rfc4648

[^103]: N. M. Josuttis. The $C++$ Standard Library - A Tutorial and Reference. 2nd edition. Addison Wesley Longman, 2012 .

[^104]: JVAPen. Small Object Optimization. last accessed 11-March-2019. URL: https://riptutorial.com/cplusplus/example/31654/small-object-optimization.

[^105]: G. Karypis and K. Schloegel. PARMETIS - Parallel Graph Partitioning and Sparse Matrix Ordering Library, Version 4.0. University of Minnesota, Department of Computer Science and Engineering. Minneapolis, MN 55455 , Mar. 2013 .

[^106]: R. C. Kirby, A. Logg, M. E. Rognes, and A. R. Terrel. "Common and unusual finite elements". In: Automated Solution of Differential Equations by the Finite Element Method. Springer, 2012. Chap. 3, pp. 95-119.

[^107]: Kitware. VTK File Formats (for VTK Version 4.2). 2003. URL: wWw.vtk.org/ img/file-formats.pdf.

[^108]: R. Klöfkorn and M. Nolte. "Performance Pitfalls in the Dune Grid Interface". In: Advances in DUNE. Ed. by A. Dedner, B. Flemisch, and R. Klöfkorn. Springer, 2012 , pp. $45-58$ . 

[^109]: T. Koch, D. Gläser, K. Weishaupt, S. Ackermann, M. Beck, B. Becker, S. Burbulla, H. Class, E. Coltman, S. Emmert, T. Fetzer, C. Grüninger, $\mathrm{K}$ . Heck, J. Hommel, T. Kurz, M. Lipp, F. Mohammadi, S. Scherrer, M. Schneider, G. Seitz, L. Stadler, M. Utz, F. Weinhardt, and B. Flemisch. "DuMu $^{\mathrm{x}} 3-$ an open-source simulator for solving flow and transport problems in porous media with a focus on model coupling". In: Computers and Mathematics with Applications (2020). DOI: 10.1016/j.camwa. 2020.02.012.

[^110]: A. Koenig and B. E. Moo. "Templates and Duck Typing". In: Dr. Dobb's (2005). online. URL: Www.drdobbs.com/templates-and-duck-typing/184401971.

[^111]: R. Kornhuber and R. Krause. "Robust multigrid methods for vector-valued Allen-Cahn equations with logarithmic free energy". In: Comp. Vis. Sci $9.2$$(2006)$ , pp. 103-116.

[^112]: I. Kossaczký. "A recursive approach to local mesh refinement in two and three dimensions". In: Journal of Computational and Applied Mathematics $55.3$ (1994), pp. 275-288.

[^113]: T. Kröger and T. Preusser. "Stability of the 8 -tetrahedra shortest-interior-edge partitioning method". In: Numerische Mathematik $109(2008)$ , pp. $435-457$ . DOI: $10.1007 / \mathrm{s} 00211-008-0148-8$ .

[^114]: M. Kronbichler and K. Kormann. "A generic interface for parallel cell-based finite element operator application". In: Computers $\&$ Fluids 63 .Supplement C (2012), pp. 135-147. DOI: 10.1016/j.compfluid.2012.04.012.

[^115]: R. J. LeVeque. Finite Volume Methods for Hyperbolic Problems. Cambridge University Press, 2002 .

[^116]: X. S. Li. "An Overview of SuperLU: Algorithms, Implementation, and User Interface". In: Transactions on Mathematical Software (TOMS) $31.3$ (Sept. 2005), pp. 302-325.

[^117]: K.-A. Lie. An Introduction to Reservoir Simulation Using MATLAB/GNU Octave: User Guide for the MATLAB Reservoir Simulation Toolbox (MRST). Cambridge University Press, 2019. DOI: $10.1017 / 9781108591416$ .

[^118]: P. Lindqvist. Notes on the $p$ -Laplace equation. Report. University of Jyväskylä, Department of Mathematics and Statistics, 2006. URL: http://urn. fi/URN : ISBN: $951-39-2586-2$

[^119]: K. Lipnikov, G. Manzini, and M. Shashkov. "Mimetic finite difference method". In: Journal of Computational Physics 257, Part B (2014), pp. 1163-1227. DOI: $10.1016 / \mathrm{j} . j \mathrm{cp} .2013 .07 .031$ .

[^120]: A. Logg, K.-A. Mardal, and G. N. Wells, eds. Automated Solution of Differential Equations by the Finite Element Method. Springer, 2012. DOI: $10.1007 / 978$ $3-642-23099-8$

[^121]: F. Luporini, D. A. Ham, and P. H. J. Kelly. "An Algorithm for the Optimization of Finite Element Integration Loops". In: ACM Trans. Math. Softw. (TOMS) $44.1(2017)$ . DOI: $10.1145 / 3054944$ . 

[^122]: N. Moës, J. Dolbow, and T. Belytschko. "A finite element method for crack growth without remeshing". In: Int. J. Numer. Methods Eng. $46.1$ (1999), pp. 131-150.

[^123]: S. Müthing. "A Flexible Framework for Multi Physics and Multi Domain PDE Simulations". PhD thesis. Universität Stuttgart, 2015 .

[^124]: S. Müthing and P. Bastian. "Dune-MultidomainGrid: A Metagrid Approach to Subdomain Modeling". In: Advances in DUNE. Ed. by A. Dedner, B. Flemisch, and $\mathrm{R}$ . Klöfkorn. Springer, 2012, pp. $59-73$ .

[^125]: T. D. Ngo, A. Fourno, and B. Noetinger. "Modeling of transport processes through large-scale discrete fracture networks using conforming meshes and open-source software". In: Journal of Hydrology $554(2017)$ , pp. $66-79$ . DOI: $10.1016 / \mathrm{j} \cdot$ jhydrol. $2017.08 .052$ .

[^126]: E. Niebler. Concept checking in $C++11$ . online blog, http://ericniebler.com/2013/11/23/concept-checking-in-c11. last checked on Dec. 8. 2015 . $2013$ .

[^127]: J. Nitsche. "Über ein Variationsprinzip zur Lösung von Dirichlet-Problemen bei Verwendung von Teilräumen, die keinen Randbedingungen unterworfen sind". In: Abh. Math. Sem. Univ. Hamburg $36(1971)$ , pp. $9-15$ .

[^128]: R. H. Nochetto, K. G. Siebert, and A. Veeser. "Theory of adaptive finite element methods: An introduction". In: Multiscale, Nonlinear and Adaptive Approximation. Ed. by R. DeVore and A. Kunoth. Springer, 2009 , pp. 409-542. DOI: $10.1007 / 978-3-642-03413-8_{-} 12$ .

[^129]: K. B. Ølgaard and G. N. Wells. "Optimizations for quadrature representations of finite element tensors through automated code generation". In: $A C M$ Trans. Math. Softw. (TOMS) $37.1(2010)$ . DOI: $10.1145 / 1644001.1644009$ .

[^130]: J. M. Ortega and W. C. Rheinboldt. Iterative Solution of Nonlinear Equations in Several Variables. Classics in Applied Mathematics. SIAM, $1970$ .

[^131]: F. Pellegrini. PT-Scotch and libPTScotch 6.0 User's Guide. Tech. rep. Université Bordeaux 1 \& LaBRI, UMR CNRS 5800 , Bacchus team, INRIA Bordeaux Sud-Ouest, 2012 .

[^132]: F. Pellegrini. Scotch and libScotch 6.0 User's Guide. Tech. rep. Université Bordeaux 1 \& LaBRI, UMR CNRS 5800 , Bacchus team, INRIA Bordeaux Sud-Ouest, 2012 .

[^133]: S. Pissanetzky. Sparse Matrix Technology. Academic Press, $1984$ .

[^134]: T. Plewa, T. Linde, and V. G. Weirs, eds. Adaptive Mesh Refinement - Theory and Applications. Vol. 41. Lecture Notes in Computational Science and Engineering. Springer, 2004 .

[^135]: D. Ponting. "Corner point geometry in reservoir simulation". In: Proceedings of the 1st European Conference on Mathematics of Oil Recovery. Ed. by P. King. Clarendon Press, 1989, pp. $45-65$ . DOI: $10.3997 / 2214-4609.201411305$ . 

[^136]: R. Rannacher and S. Turek. "Simple Nonconforming Quadrilateral Stokes Element". In: Numerical Methods for Partial Differential Equations 8 (1992), pp. 97-111.

[^137]: M. C. Rivara. "Mesh Refinement Processes Based on the Generalized Bisection of Simplices". In: SIAM J. Numer. Anal. $21.3$ (1984), pp. 604-613.

[^138]: Y. Saad. Iterative methods for sparse linear systems. 2nd edition. SIAM, 2003 .

[^139]: Y. Saad and M. H. Schultz. "GMRES: A generalized minimal `residual` algorithm for solving nonsymmetric linear systems". In: SIAM Journal on Scientific and Statistical Computing $7(1986)$ , pp. $856-869$ .

[^140]: O. Sander, T. Koch, N. Schröder, and B. Flemisch. "The Dune `FoamGrid` implementation for surface and network grids". In: Archive of Numerical Software $5.1(2017)$ , pp. $217-244$ . DOI: $10.11588 /$ ans $ .2017 .1 .28490$ .

[^141]: A. Schmidt and K. G. Siebert. Design of Adaptive Finite Element Software The Finite Element Toolbox ALBERTA. Vol. 42. Lecture Notes in Computer Science and Engineering. Springer, 2005 .

[^142]: R. Schreiber and H. B. Keller. "Driven cavity flows by efficient numerical techniques". In: Journal of Computational Physics $49.2(1983)$ , pp. 310- 333 .

[^143]: W. Schroeder, K. Martin, and B. Lorensen. The Visualization Toolkit. Kitware, $2006$ .

[^144]: B. Schupp. "Entwicklung eines effizienten Verfahrens zur Simulation kompressibler Strömungen in 3D auf Parallelrechnern". PhD thesis. Albert-LudwigsUniversität Freiburg, Mathematische Fakultät, $1999$ .

[^145]: C. Schwab. $p$ and hp-Finite Element Methods. Oxford Science Publications, $1998$ .

[^146]: J. R. Shewchuk. An Introduction to the Conjugate Gradient Method Without the Agonizing Pain. Tech. rep. School of Computer Science, Carnegie Mellon University, 1994

[^147]: J. R. Shewchuk. What is a Good Linear Finite Element? Interpolation, Conditioning, Anisotropy, and Quality Measures. Tech. rep. Department of Electrical Engineering and Computer Science, University of California at Berkeley, 2002 .

[^148]: B. Smith, P. Bjørstad, and W. Gropp. Domain Decomposition - Parallel Multilevel Methods for Elliptic Partial Differential Equations. Cambridge University Press, 1996 .

[^149]: A. H. Stroud. Approximate Calculation of Multiple Integrals. Prentice-Hall, $1971$ .

[^150]: B. Stroustrup. The $C++$ Programming Language. 3rd edition. Addison-Wesley, $2007$ . 

[^151]: A. Sutton, B. Stroustrup, and G. Dos Reis. Concepts Lite: Constraining Templates with Predicates. Tech. rep. N3580. JTC1/SC22/WG21 - The C++ Standards Committee, 2013. URL: http:// www.open-std.org/jtc1/sc22/ wg21/docs/papers/2013/n3580.pdf.

[^152]: R. L. Taylor. FEAP - A Finite Element Analysis Program, Version 8.4 User Manual. Tech. rep. University of California at Berkely, 2013. URL: http: //www.ce.berkeley.edu/projects/feap/manual84.pdf.

[^153]: J. F. Thompson, B. K. Soni, and N. P. Weatherill, eds. Handbook of Grid Generation. CRC Press, $1999$ .

[^154]: A. Toselli and O. Widlund. Domain Decomposition Methods - Algorithms and Theory. Springer, 2004 .

[^155]: U. Trottenberg, C. Oosterlee, and A. Schüller. Multigrid. Elsevier, 2001 .

[^156]: T. Veldhuizen. "Expression Templates". In: $C++$ Report $7.5(1995)$ , pp. $26-31$ .

[^157]: R. Verfürth. A Posteriori Error Estimation Techniques for Finite Element Methods. Oxford University Press, 2013 .

[^158]: A. Wächter and L. T. Biegler. "On the Implementation of a Primal-Dual Interior Point Filter Line Search Algorithm for Large-Scale Nonlinear Programming". In: Mathematical Programming $106.1(2006)$ , pp. $25-57$ .

[^159]: Wikipedia. Camel case. last accessed 9-February-2020. 2020. URL: https: //en.wikipedia.org/wiki/Camel_case.

[^160]: Wikipedia. Endianness. last accessed 9-February-2020. 2020. URL: https: //en.wikipedia.org/wiki/Endianness.

[^161]: Wikipedia. Spaghetti code. last accessed 9-February-2020. 2020. URL: https: //en. Wikipedia.org/wiki/Spaghetti_code.

[^162]: J. Wloka. Partial differential equations. Cambridge University Press, 1987 .

[^163]: B. Wohlmuth and R. Krause. "Monotone Methods on Nonmatching Grids for Nonlinear Contact Problems". In: SIAM Journal on Scientific Computing $25.1$$(2003)$ , pp. 324-347.

[^164]: B. I. Wohlmuth. Discretization Methods and Iterative Solvers Based on Domain Decomposition. Vol. 17. Lecture Notes in Computer Science and Engineering. Springer, 2001 .

[^165]: S. Zhang. "Successive Subdivisions of Tetrahedra and Multigrid Methods on Tetrahedral Meshes". In: Houston Journal of Mathematics $21.3$ (1995), pp. 541 $556$ .

[^166]: M. Zlámal. "Curved `Elements` in the Finite Element Method. I". In: $S I A M$ Journal on Numerical Analysis $10.1(1973)$ , pp. $229-240$ . 



[Fig1.1]: https://cdn.mathpix.com/snip/images/-7li8TwQ3AVj04LR-Wh_0P5THcieFlJY0gO1Rw4397U.original.fullsize.png
[Fig2.1]: https://cdn.mathpix.com/snip/images/e03HzAA60_iBZa-0nl1XhX2ExQJqUmqzizdopNHwZZo.original.fullsize.png
[Fig2.2]: https://cdn.mathpix.com/snip/images/oN0XIcAFOKZjUe8Xe2nvwkLIbjzQSMJ1hVyDVWp3xEc.original.fullsize.png
[Fig2.3]: https://cdn.mathpix.com/snip/images/L7f8cjxEtAbdZACqPq9qAs141yNw6zdDY5C7Ldkzck4.original.fullsize.png
[Fig2.4]: https://cdn.mathpix.com/snip/images/NXPsD39emDlWIaY2hXQrWQuMk_t5wcp_HbhGhKtJBZQ.original.fullsize.png
[Fig2.5]: https://cdn.mathpix.com/snip/images/VC_gATv7Ob6eZ8r83961wdQaEuu9xRBe2FxmeR8Yw1s.original.fullsize.png
[Fig2.6]: https://cdn.mathpix.com/snip/images/3uRu0HxbTzFzqa-HXuUwToXFG1DDLTJ1EMwXUgJH6Og.original.fullsize.png
[Fig2.7]: https://cdn.mathpix.com/snip/images/YywuDa9jFtfNdBvHAMva1Z9N0LrVVgG7agn0vMdjHys.original.fullsize.png
[Fig2.8]: https://cdn.mathpix.com/snip/images/Z0YJLfmiIgheTAhrHkq-GVFMZNoKGWbuKMIn6sIbyiA.original.fullsize.png
[Fig2.9]: https://cdn.mathpix.com/snip/images/5wBo394AmMF4s73WScwp7igdEs64E7r1H_G-kPKRIGw.original.fullsize.png
[Fig2.10]: https://cdn.mathpix.com/snip/images/KPl4F-twxI9McutoYvKQFZUjJOpOtcAJQjBmxqFzeY0.original.fullsize.png
[Fig2.11]: https://cdn.mathpix.com/snip/images/tufsfHj3M_PkQPNviX45TL2Etlzp-LsLbml-FlNwewQ.original.fullsize.png
[Fig2.12]: https://cdn.mathpix.com/snip/images/dE6EGUwM8v2Dw_HJdl-lbBlVG6g1E6XNV1-bimQBnTE.original.fullsize.png
[Fig2.13]: https://cdn.mathpix.com/snip/images/t98N93H1Xy5TCTOg5oY8VjVG4xNsGjeAZpFsdJTLyqk.original.fullsize.png
[Fig2.14]: https://cdn.mathpix.com/snip/images/B3H_-ihYUm98WXJ2ejLbK0zsij8Ep15pcTmrQmIaD-E.original.fullsize.png
[Fig2.15]: https://cdn.mathpix.com/snip/images/q87O1vOMeVQBnF2PkcAgs-7yGIYnacVd9E__zy7hImY.original.fullsize.png
[Fig2.16]: https://cdn.mathpix.com/snip/images/YP-sosGCYa30wslW5XGtXZtjkjEz0wvkHSqpQwJBcLk.original.fullsize.png
[Fig2.17]: https://cdn.mathpix.com/snip/images/VLmah6quPrU2IlHgJ4oE4d4JfhOOHxGdZYqMA-H6KfE.original.fullsize.png
[Fig2.18]: https://cdn.mathpix.com/snip/images/PXWSvfq6hif3LJPgxEdwAniKmPB6N4kWH97FSJTcIlY.original.fullsize.png
[Fig2.19]: https://cdn.mathpix.com/snip/images/NXM9xlRmIBbhMiJznJltRRVNecKLkatlAEHVh3oyLpI.original.fullsize.png
[Fig2.20]: https://cdn.mathpix.com/snip/images/Tsi38pTAs4l-e32SkQqzAO-KMHwCvwQbn1nO7-W34R4.original.fullsize.png
[Fig2.21]: https://cdn.mathpix.com/snip/images/v7FmLopgM5-FNczNkCG8O63R5dybpaS5oHYXC9Wqvmc.original.fullsize.png
[Fig2.22]: https://cdn.mathpix.com/snip/images/dtUg0vg-BLi4ovqO39Os6VVlRLM7kKr4IbqOySEfduQ.original.fullsize.png
[Fig2.23]: https://cdn.mathpix.com/snip/images/ELMS1VB4Dzs9HSH1aUTO7e6t7Qtwc_OkixuYEExaDe8.original.fullsize.png
[Fig3.1]: https://cdn.mathpix.com/snip/images/jMNVmUx2JRLdVxkU_atgbkhAjUqTlz_ySrdm1gO6Fh0.original.fullsize.png
[Fig3.2]: https://cdn.mathpix.com/snip/images/fnSCvfOYau_EAjHxcX8BodbVXzGeGmtvI9KErbiB8_s.original.fullsize.png
[Fig3.3]: https://cdn.mathpix.com/snip/images/kn0PBMV17LZ-pDPA8HnDIiR84-GPIyAXYKDnhRJu5IQ.original.fullsize.png
[Fig3.4]: https://cdn.mathpix.com/snip/images/l_xg4jktYuV7tSFWobWnpxCl3giKn91MkxxYdroi6uk.original.fullsize.png
[Fig3.5]: https://cdn.mathpix.com/snip/images/DdvQuJiyvumkM-HEs8RRfi7Z93vE3S4O24S53MER3y4.original.fullsize.png
[Fig4.1]: https://cdn.mathpix.com/snip/images/W7vzAWBkR0_goA_G55j2jYkhv5gVK3bCqrr-3-XtTYM.original.fullsize.png
[Fig5.1]: https://cdn.mathpix.com/snip/images/1InkXECQRzLTTOGpRIYLNJjcdvjYTob0QLBeMJcxjGE.original.fullsize.png
[Fig5.2]: https://cdn.mathpix.com/snip/images/DW2mKmR2BsPMtwXSgYYbuQFbVgd00vGkg8ukm8REWf4.original.fullsize.png
[Fig5.3]: https://cdn.mathpix.com/snip/images/2m_1TdBa8mb4yy9rf7ChOqHFXttL2aSo5NrmnOw-PBc.original.fullsize.png
[Fig5.4]: https://cdn.mathpix.com/snip/images/iRM2m6SltAswexnwqG8RQFzbVJwOKW8x77Gg-dBTsJg.original.fullsize.png
[Fig5.5]: https://cdn.mathpix.com/snip/images/7q71YCn3Jw3pMjPVDTq8BR3rJdJyphg-WYQdrmWlXu4.original.fullsize.png
[Fig5.6]: https://cdn.mathpix.com/snip/images/zwtPNfMVy5gTn8yOj88K0Vml280yP4R5jfHfl6-bFbE.original.fullsize.png
[Fig5.7]: https://cdn.mathpix.com/snip/images/JwbC4PiGYe8zs7ko1cTXYeqWcmhbFH4L39AMeU39ROM.original.fullsize.png
[Fig5.8]: https://cdn.mathpix.com/snip/images/jruBLjmjlrdcbtP8OF5xNP_lSa26Q-6okbkuw2aa6fY.original.fullsize.png
[Fig5.9]: https://cdn.mathpix.com/snip/images/H-K8rNjAQo2asx3BPN0-OXXFqSMFsjTU552PlJ1PDDA.original.fullsize.png
[Fig5.10]: https://cdn.mathpix.com/snip/images/UJvkPqFGqobWh3qdm3hHRVXZYml9KNe631djtPJn0HY.original.fullsize.png
[Fig5.11]: https://cdn.mathpix.com/snip/images/ZGqN24-GFmg29dO0GLHy6M4EEoBgUSL1nmdEFpeTPZo.original.fullsize.png
[Fig5.12]: https://cdn.mathpix.com/snip/images/A95y0pO8OqcTFNZlVbP0bdEACF2vh4VpdFOSJVD3C2U.original.fullsize.png
[Fig5.13]: https://cdn.mathpix.com/snip/images/RqFsMjj_3HjcgSoa0CxWc121ltY76tqcVldLVzd8psU.original.fullsize.png
[Fig5.14]: https://cdn.mathpix.com/snip/images/eLPrcnorOf3JYE7PnjmaFalvf8TTz3SaKR46rKDBKAE.original.fullsize.png
[Fig5.15]: https://cdn.mathpix.com/snip/images/S811YEsJ2Z5eOv3IGQAO3AXGIjcNykk8DyJb3B7ZgA8.original.fullsize.png
[Fig5.16]: https://cdn.mathpix.com/snip/images/4RnX43EY6psgAYsS3Z3ABIIvWCsTs31zed_Q15t3N4s.original.fullsize.png
[Fig5.17]: https://cdn.mathpix.com/snip/images/tOtsnHu9sY76ZCcU6wuuSg3KU_7OHL4-dvC2xZNNHTw.original.fullsize.png
[Fig5.18]: https://cdn.mathpix.com/snip/images/1t9hyYtkUjo0k2jcc-DqZkIpXnbDn2CmVeILBSob36I.original.fullsize.png
[Fig5.19]: https://cdn.mathpix.com/snip/images/qkxTFLKPYY4FOoPEL2NSLJPhGoK_FSJLveF2_joF1nY.original.fullsize.png
[Fig5.20]: https://cdn.mathpix.com/snip/images/l0m-8vVsMH3v5aFih_F8X75Z7bmBwULKefEBK5_17tY.original.fullsize.png
[Fig5.21]: https://cdn.mathpix.com/snip/images/052-DQ9JkZYw9qRoGXNoKB4MHZSchQl-7_NxybPchXY.original.fullsize.png
[Fig5.22]: https://cdn.mathpix.com/snip/images/55jGZe1oUaahZcNUwCU1IOUQUy8DtjypwQ_GnbZe2Kk.original.fullsize.png
[Fig5.23]: https://cdn.mathpix.com/snip/images/Qc1DNYk73moc0Qd16m39AijnG5U2dNPxOS7wP0q3qlM.original.fullsize.png
[Fig5.24]: https://cdn.mathpix.com/snip/images/rpjk8TkZWblQVf37CtMDKzw8nDBQxS4ybXvNjV2mLHc.original.fullsize.png
[Fig5.25]: https://cdn.mathpix.com/snip/images/yBuM3x0HlCn-nYzDmEKVGHdu1F2pmAWR3-92t2VXtKU.original.fullsize.png
[Fig5.26]: https://cdn.mathpix.com/snip/images/kPOsEfc2OYmqMtUB4XK47YTMomxPGSL0qylSIHt_05A.original.fullsize.png
[Fig5.27]: https://cdn.mathpix.com/snip/images/LFo1T0UvJf3ovRsIr4dO8aNUJt05MfizUdbN9E_db1I.original.fullsize.png
[Fig6.1]: https://cdn.mathpix.com/snip/images/lp3Z90dtUi9GHPolIpLY2QaNyJKvtq6tcYNkENp9dYw.original.fullsize.png
[Fig6.2]: https://cdn.mathpix.com/snip/images/7icS49ANULK19KNJ5c_4Ai9UXXuVJxeFK7-RAZQUke0.original.fullsize.png
[Fig6.3]: https://cdn.mathpix.com/snip/images/l38FXmLpwKuNS7CLaJSnCT7mGPxWBtnuGM03Bl0YDJc.original.fullsize.png
[Fig6.4]: https://cdn.mathpix.com/snip/images/XCFsL2bLL6EGbIISvgXTtAjFDba8T7kar7R3URCUQIk.original.fullsize.png
[Fig6.5]: https://cdn.mathpix.com/snip/images/jkjhUNxQN5t_Lhe7siv8igv6fjRfV5nCkWgYBSCkBcE.original.fullsize.png
[Fig6.6]: https://cdn.mathpix.com/snip/images/VXo5owB-ARnu-7QMqnRQBBugUfX_Ykbnb3v3JOPNIic.original.fullsize.png
[Fig6.7]: https://cdn.mathpix.com/snip/images/Rktn7N_uGRy0Qcv58orwR5Wf2ijFX7VNYTKnpUj1eyY.original.fullsize.png
[Fig6.8]: https://cdn.mathpix.com/snip/images/uztSku39gGpS2YeEfGhEgA-IeNDDb08oQCQPCfhsgOA.original.fullsize.png
[Fig7.1]: https://cdn.mathpix.com/snip/images/bfF96TJ0FBPiul4AkoGRoVWmK6wSFEX4FEudDetb46o.original.fullsize.png
[Fig7.2]: https://cdn.mathpix.com/snip/images/39Ipzq6JTigxheddCoGNGfxGMfcYEhFN7RItAMPhv6w.original.fullsize.png
[Fig7.3]: https://cdn.mathpix.com/snip/images/ieOTGb3vMtPrQsbsQh1SfFISJOUuiMCFXYM3tqT-810.original.fullsize.png
[Fig7.4]: https://cdn.mathpix.com/snip/images/ijweyAxdQ3p3dWCl8aqVApzRNIml31o8kPoyVey-1I4.original.fullsize.png
[Fig7.5]: https://cdn.mathpix.com/snip/images/amq5MuIEzTSzSNexbBbE8K4LTfPUJte49YAoAE-kk0A.original.fullsize.png
[Fig8.1]: https://cdn.mathpix.com/snip/images/P-3wKHFSOIjS516puSKAh7ls5rQUgIJDrSV-v-RHDdY.original.fullsize.png
[Fig8.2]: https://cdn.mathpix.com/snip/images/I73RWsjP9su5rjj2pbcb_sJQPB7sqD3W50PdKKe9_tw.original.fullsize.png
[Fig8.3]: https://cdn.mathpix.com/snip/images/Ey3dbJ7YBEhpdWGhXBP9FoejSqzecpoBOw1C7mBKK5M.original.fullsize.png
[Fig10.1]: https://cdn.mathpix.com/snip/images/GKbbI9_3qadnfTXS_P44vu2nLOmux5b04a-8-KCBl8Y.original.fullsize.png
[Fig10.2]: https://cdn.mathpix.com/snip/images/TqDxOQA2tQIPZxSyYlb_8LTOAv2hmOn2OlhibuILKd0.original.fullsize.png
[Fig10.3]: https://cdn.mathpix.com/snip/images/DI7Rta8mCmMO5l1HFjjTS373UCk-JK4cb_z6u6vpKAA.original.fullsize.png
[Fig10.4]: https://cdn.mathpix.com/snip/images/bPZduvjielGW4sGrqMsVinEpmAh8Bdp3Zw-BUG8P8wQ.original.fullsize.png
[Fig10.5]: https://cdn.mathpix.com/snip/images/Y62e_c1E5AIChFszCffBkqeJlWDkcfC4QDQst4kdTno.original.fullsize.png
[Fig10.6]: https://cdn.mathpix.com/snip/images/izIBIhuiC4cNe-HrRvSanAo_fctjgFiFzkMdlq2KAvM.original.fullsize.png
[Fig10.7]: https://cdn.mathpix.com/snip/images/Dw9vtpSTtN1JU3tP2ljFGYzHxWWQRfkJo9kiNjvIFqY.original.fullsize.png
[Fig10.8]: https://cdn.mathpix.com/snip/images/VCOx-iAXzXdUST7cj3KekQuORVMQZ_eHdrIPPXl3yDU.original.fullsize.png
[Fig10.9]: https://cdn.mathpix.com/snip/images/-lhp4itXGlaAJsuDOmwlQRoVlvwNeUx9EgkoXIgFKns.original.fullsize.png
[Fig10.10]: https://cdn.mathpix.com/snip/images/nKB9OObGGQfjYXKc54flZxlSgUGNIhWKXSt5IpuitiY.original.fullsize.png
[Fig11.1]: https://cdn.mathpix.com/snip/images/JO_wlCG1kKm6ankAQqUD3Y3WhuXip8X8NQqBKahlatc.original.fullsize.png
[Fig11.2]: https://cdn.mathpix.com/snip/images/nrNuM2a-tFqdbuk9lO4MJ5nipQ6nVUwE13fdLe43u2k.original.fullsize.png
[Fig11.3]: https://cdn.mathpix.com/snip/images/g8BJeKY75sG74m9oLucsywFLwU5TLqcJjXuvx66r-Fk.original.fullsize.png
[Fig11.4]: https://cdn.mathpix.com/snip/images/ETqgJnpl3OJZirAv1vAUmTBWc5AVyrn-fVov7u8EaS0.original.fullsize.png
[Fig11.5]: https://cdn.mathpix.com/snip/images/6Npxi99ELV4qgtwS1hUD0MNR3Gnx12kHfOgfLMd7EE0.original.fullsize.png
[Fig11.6]: https://cdn.mathpix.com/snip/images/dw6iZ7lxTI_9B5oqA00S1J3ta76Tm72rcw80sCSS8Tk.original.fullsize.png
[Fig11.7]: https://cdn.mathpix.com/snip/images/fvWIXOfhOD8vcIhwtqdnnSRy01ZYuihS7Z6EUQwDyrg.original.fullsize.png
[Fig11.8]: https://cdn.mathpix.com/snip/images/xzGDpHbtoKbIjPj2UJaGsC4054SRB1lfHHWNB82jKT4.original.fullsize.png
[Fig11.9]: https://cdn.mathpix.com/snip/images/rdIIRzKkQPayynXmyp3HoLMbEEyZNdIjrCCznI0Ilp0.original.fullsize.png
[FigA.1]: https://cdn.mathpix.com/snip/images/ZI3bZLEkn9IFTRrHZPRfbrxL2_L3t0pbEKO-q3nPMa0.original.fullsize.png


[Tab5.1]: https://cdn.mathpix.com/snip/images/bNsLcLG3Xv3tEc4k5BeY483lDkA1L8cXKSGI49bF5Lw.original.fullsize.png
[Tab5.2]: https://cdn.mathpix.com/snip/images/k3qLEOSEvf9M4JnXxoPELrjbGjZWBIZujdBEpO9TOyI.original.fullsize.png
[Tab5.3]: https://cdn.mathpix.com/snip/images/AhdEWrg6-ljgoJ02PAUFizUCdeQNJLGB_Vv2ubrdrjg.original.fullsize.png
[Tab5.4]: https://cdn.mathpix.com/snip/images/8CBzfu6cZ1JrNVOQt7qGpyR3yBD3Jv8lwm8V8pegkTg.original.fullsize.png
[Tab5.5]: https://cdn.mathpix.com/snip/images/z-v6bT27oCHV3qohRoC5eaifMwX5smySV6jgrX-s95U.original.fullsize.png
[Tab5.6]: https://cdn.mathpix.com/snip/images/cYDuYkTgzYoBheUClSP85srczcMlPjzLHbM5cZZJoog.original.fullsize.png
[Tab5.7]: https://cdn.mathpix.com/snip/images/W92sQ3SntRwnSJ9SU6ws9iSxfGJfxpVmqUhq0HkwDBs.original.fullsize.png
[Tab5.8]: https://cdn.mathpix.com/snip/images/a_7UmLDlSnfnhWOOlI-r2T33vmSyXXGrFpaJVR2USGk.original.fullsize.png
[Tab5.9]: https://cdn.mathpix.com/snip/images/Ka1KqV2GWyTzlpGAbrpHMr8olbYmqGHKITIi9VXFyQk.original.fullsize.png
[Tab5.10]: https://cdn.mathpix.com/snip/images/tCHuuuprtNsKOTkVwKMXmg2enabvI6dxLTaW8MkY--A.original.fullsize.png
[Tab5.11]: https://cdn.mathpix.com/snip/images/NCX15ZBgJ9eQ1IEcOBlQnn1Y2JniWnUdHKApeWrT9XA.original.fullsize.png
[Tab5.12]: https://cdn.mathpix.com/snip/images/KHuiGm_2I8wTRmgTfu4SxPTsdmW5Hlv2GYZqJH08Qc8.original.fullsize.png
[Tab5.13]: https://cdn.mathpix.com/snip/images/0HBKp0hGtSPlGLNFhk2VjDUjUaFU5Za9J7JngfYuLkQ.original.fullsize.png
[Tab5.14]: https://cdn.mathpix.com/snip/images/sTKl7DX_7WDxLMQPPlsg_Ho_R3nfdteb2ti5-DsfnOA.original.fullsize.png
[Tab5.15]: https://cdn.mathpix.com/snip/images/KOYbyO_hvSj0i12PI_h1zJJVLxyoKljFNSt1O-dwMLo.original.fullsize.png
[Tab5.16]: https://cdn.mathpix.com/snip/images/v0Krn-swPze1nEzyWbaLfw7LlBRxMmLIIbqXbLKfOB8.original.fullsize.png
[Tab6.1]: https://cdn.mathpix.com/snip/images/lPqvGzBuPkMvUj8MSUHzdmpYpaufmWZ7kTTy4DfW-gY.original.fullsize.png
[Tab6.2]: https://cdn.mathpix.com/snip/images/xNLpzx2s9QV-ejb8PRpgiQwUxMSzK-1hSBnbN-EcmV4.original.fullsize.png
[Tab7.1]: https://cdn.mathpix.com/snip/images/_NlvLpV32-ao9ahe-gj_z8Gh0g7wemgNPmdhZkrAhgE.original.fullsize.png
[Tab7.2]: https://cdn.mathpix.com/snip/images/UMMqMn4F0hTob9dh5dzOWjl-x89xGj6ciX6u6i79WMQ.original.fullsize.png
[Tab7.3]: https://cdn.mathpix.com/snip/images/EMqR4k8NboGPWDVsCSfvwhI2Tk3JyJxH4L_uj_WcmJI.original.fullsize.png
[Tab7.4]: https://cdn.mathpix.com/snip/images/udsJYUV5hMzmxdCF5u3kqAD0Twgw4dF0Mu2kBVGMTeQ.original.fullsize.png
[Tab7.5]: https://cdn.mathpix.com/snip/images/E2AbrfhlkZDQE_FIzutVxJr6YLHPR7bXW4ABSYJbYaY.original.fullsize.png
[Tab7.6]: https://cdn.mathpix.com/snip/images/3cYNseb8Kxy28MedNe_OKWWAdWrg0vAMhKEGRBSuU5I.original.fullsize.png
[Tab8.1]: https://cdn.mathpix.com/snip/images/r6nZAFkJEfZ2BJjlUeQEgXemvdP3P4Nfo5Y7HbkZkPI.original.fullsize.png
[Tab10.1]: https://cdn.mathpix.com/snip/images/a90_3MAxZcnf2WXWD9kONIx-JZA6PDkHFKoZ2fzC4ig.original.fullsize.png
[Tab11.1]: https://cdn.mathpix.com/snip/images/9i7SinDiSlN1EdvpAJTfLpg8_eO-pGFgc6ZZOegvCGo.original.fullsize.png
[Tab11.2]: https://cdn.mathpix.com/snip/images/ViDTT0gGCmHO-gp0chqZvgkUjRu2IBhpZFD1w-YWYlE.original.fullsize.png
[Tab11.3]: https://cdn.mathpix.com/snip/images/sKoAgZi_bABiaGwzGbFCR2ui6Qmqk3So9DVcsDtNgVQ.original.fullsize.png
[TabA.1]: https://cdn.mathpix.com/snip/images/SWawnSP6jDw1Fuj8f84j7lJZfoNCYpNvnrYjaOJp2lk.original.fullsize.png
