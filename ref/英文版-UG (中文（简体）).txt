\title{
UG - 一个灵活的解决偏微分方程的软件工具箱
}

\作者：{
P.Bastian, K. Birken, K. J ohannsen, S. Lang, N. Neuß, H. Rentz-Reichert, C. Wieners
}

\begin{abstract}
在过去的二十年里，一些非常有效的偏微分方程数值解法技术已经被开发出来。我们对非结构化网格的自适应局部网格细化、多网格求解器和并行化技术特别感兴趣。

到目前为止，这些创新技术主要是在大学研究代码中实现的，只有很少的商业代码使用它们。这有两个原因。首先，针对许多工程应用的多网格解决方案和自适应细化仍然是一个活跃的研究课题，不能认为已经成熟到可以常规应用。其次，在一个具有足够通用性的代码中实现所有这些技术需要大量的时间和不同领域的知识。

UG（非结构化网格的缩写）的设计是为了克服这些问题。它提供了非常通用的工具，用于生成和操作二维和三维空间的非结构化网格，以及灵活的数据布局。因此，它一方面可以作为探索新算法的工具，另一方面，已经实施的一系列算法可以应用于复杂问题。

在本文中，我们展示了UG的软件设计结构，并对其中的一些子系统进行了更详细的探讨。最后，我们试图用几个非微不足道的例子来说明该方法的能力。
\end{abstract}

\section{Introduction}

在过去的20年里，已经开发了非常有效的偏微分方程数值解法技术。最显著的是这些。

- 使用非结构化网格对复杂的几何形状进行逼近。

- 适应性局部网格细化，以尽量减少一定精度所需的自由度数量。

- 用于快速解决线性方程组的稳健多网格方法； - 这些算法在MIMD型机器上的并行化。

到目前为止，这些创新技术主要是在大学研究代码中实现的$[2,11,21,4]$，只有很少的商业代码使用它们，例如[22]。其原因有两个方面。首先，快速和稳健的迭代求解器的构造仍然是一个问题。多网格方法已经非常成功地应用于计算流体力学领域$[16,20,26]$，但对非线性结构力学或多孔介质中的多相流动问题的应用仍处于起步阶段。

第二个原因是，将上述所有技术整合到一个代码中，需要几十个人年的重大编码工作。此外，现有代码的结构往往不适合纳入所有这些方法，因为它们需要在网格生成器、误差估计器、求解器和负载平衡器之间进行强有力的互动。

UG（非结构化网格的简称）是为了克服这些问题而设计的，它提供了可重复使用的软件工具，简化了复杂工程应用中非结构化网格上并行自适应多网格方法的实施。UG的核心是其非结构化网格数据结构。它允许人们创建由三角形、四边形、四面体、金字塔形、六面体和棱形元素组成的二维和三维空间的网格。网格数据结构是分层的，元素可以在本地被细化和移除。

几何数据结构由用于表示稀疏矩阵和向量的代数数据结构来补充。自由度可以与网格的节点、边、面和元素相关联，因此也允许实现不符合要求的、混合的或高阶的有限元离散。有大量的线性代数子程序、迭代内核和多网格组件可用。对于标准情况，如符合要求的有限元，用户不需要写一行代码就可以使用多网格方法（甚至对于偏微分方程系统）。离散化方案的实现被大量的例程所简化，这些例程提供了形状函数及其导数、正交公式、有限体积构造等。

UG主要是作为探索新离散方案、求解器和误差估计器的工具。一个强大的图形用户界面可以帮助大大减少开发时间。UG有一个带命令解释器的内置外壳，允许用户在其屏幕上打开任意数量的窗口。网格、等高线、彩色图和矢量图都可以在二维和三维中显示。三维中的隐线去除有效地使用了分层数据表示法。

UG的另一个巨大优势是它对并行性的支持。从[4]中描述的第一个并行版本中获得的经验导致了一个新的编程模型DDD，该模型可用于[8]中描述的具有类图数据结构的应用程序的并行化。DDD是UG并行版本的基础，但也可以独立使用。UG将允许从顺序计算到并行计算的非常平滑的过渡。

本文的其余部分组织如下。下一节简要介绍了非结构化网格上的局部多网格方法，因为这是UG的数学基础。然后对UG库所提供的软件工具进行了详细的解释。最后，用上面列出的一些问题类别获得的结果来证明我们方法的力量。

\Section{Local multigrid methods}。

标准的多网格方法（见例如[14]）可以应用于非结构化网格和局部细化，但必须加以修改，以避免算法的复杂性恶化。特别是，平滑过程必须只在细化区域进行。最小的要求是对更细层次上的所有新点进行平滑处理。Y serentant[27]和Bank-Dupont-Y serentant[3]对一个加法多网格变体进行了分析。在这里，收敛率取决于层次的数量。最佳复杂度可以通过BramblePasciak-Xu[10]和其乘法对应方BramblePasciak-Wang-Xu[9]的所有细化元素上的平滑的加法多网格方法获得（关于不同方法的讨论见[5]）。在此，我们详细解释由Bastian[4]实现的概念，它是UG的基础。我们使用一个乘法多重网格方法，在一个略微扩大的细化区域中进行平滑处理。到目前为止，这是获得最佳复杂度的唯一方法，同时也为广泛的应用提供了稳健性。

\小节{格子和多格子}。

网格是一个封闭的多边形或多面体集合，并分解为元素。我们考虑三角形和四边形元素，以及四面体、金字塔、棱镜和六面体。对于一个元素$E$，在$mathbb{R}^{d}$中的相应域，$d=2,3$用$Omega(E)$表示，边界用$partial E$表示。如果$partial E \cap \partial E^{\prime}$是空的，所有元素$E \neq E^{\prime}$有一个共同的节点（角）、一条共同的边或一个共同的侧面，那么这个网格就是一致的。

让$Omega\subset\mathbb{R}^{d}$是一个域。一个多网格$\mathscr{F}=\left\{\Omega_{0}, \Omega_{1}\right.$, $\left.\Omega_{2}, \ldots, \Omega_{k}\right\}$是一串逼近$Omega$的一致网格。元素的集合用$mathscr{O}_{l}, l=0, \ldots, k$表示。不同网格的元素将被区分开来。对于$l>0$，我们假设存在一个父元素$mathscr{F}(E) \in \mathscr{O}_{l-1}$，用于所有$E \in \mathscr{E}_{l}$ 的元素。一般来说，$Omega(E)\subset\Omega(\mathscr{F}(E))$，但是这个属性在弯曲的边界附近会被违反。对于$F\in `mathscr{O}_{l-1}$，让

$$
\mathscr{S}(F)=left\{E\in `mathscr{E}_{l}.\中 =F(E)=F\right\}。
$$

是$F$的子元素的集合。元素$F$对$mathscr{S}(F)$的细化可以是规则的、不规则的或复制的类型。应用细化规则的结果是生成相应类型的元素，例如，对$F$应用不规则细化规则的结果是$mathscr{S}(F)$是不规则元素。对于复制元素，我们有$\Omega(F)=\Omega(\mathscr{S}(F))$。

全局细化算法符合以下规则。

1. $Omega_{0}$的所有元素都是有规律的。

2.规则和不规则的细化只能应用于规则元素。

3.复制规则可以应用于任何元素。

关于细化规则和细化算法的完整讨论，请参考第3章。3.3.为了在所有层次上覆盖领域$/Omega$，需要复制元素。在最终的实现中，大部分的复制元素可以被省略，这将在下面解释。在下文中，如果一个元素被定期或不定期地精炼（但不是复制），我们将把它称为精炼元素。

\textbf{例1.单位$Omega==left\{x\in `mathbb{R}^{2}的多网格。\$mid\right.$|x|<1\}$。

![](https://cdn.mathpix.com/snip/images/Nyp7W1UIGMQEu7mG3NSQkNrwwMytz1KwcAkAHhWiES0.original.fullsize.png)

\subsection{Geometrically based data}。

我们假设一个线性问题是在$Omega$上给出的，并且我们可以为每一个接近$Omega$的网格定义一个有限维度的解，以接近$Omega$上的连续解。因此，向量和矩阵必须在每个网格上被定义。为简单起见，我们只解释未知数被分配给节点的情况。l$层面上的节点集合用$$mathscr{R}$表示。我们称$P\in `mathscr{R}$为点或插值点，其位置将用$operatorname{pos}(P)$表示。不同层次上的点将被区分开来，但它们可能具有相同的位置。元素$E$的角用$/mathscr{P}(E)$表示。一般来说，父点不能被定义为精炼元素，但对于复制元素$E$上的所有点$P\in\mathscr{P}(E)$，存在一个定义良好的父点$mathscr{F}(P)$。此外，$n[P]$表示与$P相关的自由度数量。 n[E]=sum_{P\in `mathcal{P}(E)} n[P]$ resp. $n_{l}=sum_{P `mathscr{R}} n[P]$表示每个元素的自由度数量， resp.在$Omega_{l}$。

让$mathscr{F}==left\{Omega_{0}, \ldots, \Omega_{k}\right\}$是一个多网格，让

- $x_{l}\in \mathbf{R}^{n_{l}}$ 是$l$层面上的网格的一个向量。

- $x[E]\in `mathbf{R}^{n[E]}$ 对$E `mathscr{E}_{l}$ 元素的限制和

- $x[P]\in \mathbf{R}^{n[P]}$ 对插值点$P \in \mathscr{P}_{i}$的限制。

在最高层$Omega_{k}$的网格上，离散化问题

$$A_{k} x_{k}=b_{k}$$

是由全局刚度矩阵$A_{k}给出的。\在\mathbb{R}^{n_{k}中\中的全局刚度矩阵$A{k}，和全局右手边$b_{k}。\in \mathbb{R}^{n_{k}}$，全局解向量用$x_{k}$表示。例如，有限元离散化是由元素刚度矩阵$A(E)$和元素右手边$b(E)$构建的。全局刚度矩阵$A_{k}$和全局右手向量$b_{k}$由$sum_{E\in \mathscr{E}_{k}}组合而成。A(E)$ resp. $sum_{E\in \mathscr{X}_{k}} b(E)$ 以及由于边界条件对某些点$P\in \mathscr{P}\left(\partial \Omega_{k}right)$ 的修改。对于较低层次的$l<k$，我们只需要刚度矩阵$A_{l}$，因为在多网格算法中，辅助问题$A_{l} c_{l}=d_{l}$被解决，其中右手边被缺陷$d_{l}$取代，解矢量被校正矢量$c_{l}$取代。

给定两个插值点$P$和$Q$，子矩阵$A[P, Q]\in \mathbb{R}^{n[P] \times n[Q]}$由所有矩阵$A(E)$构建，其中$P, Q\in \mathscr{P}(E) $。这里，我们只考虑离散化，如果$A[P, Q]=0$不存在$P, Q\in `mathscr{P}(E)$的元素，则A[P, Q]=0$。

\subsection{Grid transfer}。

对于多网格方法，网格转移对于不同层次上的数值的耦合至关重要。一般来说，从l-1级到l级的插值由矩阵$I_{l}给出。\中的$I_{l}，在$mathbb{R}^{n_{l}中的$I_{l}。\times n_{l-1}}$。在本地，子矩阵$I[E]/in `mathbb{R}^{n[E] `times n[F]}$可以通过从父元素$F$到子元素$E`in `mathscr{S}(F)$的点多线性内插来构造。因此，内插是一个局部操作，只有当存在一个$E\in `mathscr{E}_{l}$的元素，使得$P\in `mathscr{P}(E)$和$Q\in `mathscr{P}(`mathscr{F}(E))$，I[P, Q] `neq 0$。通常，从细级到粗级的网格转移将由转置的矩阵$R_{l}=I_{l}^{T}$定义。此外，较粗层次上的刚度矩阵可以通过$A_{l-1}=R_{l}计算。A_{l}I_{l}$。存在各种概念来适应网格转移和粗网格矩阵，以适应不同的扩散常数或支配性对流。

\subsection{Vector classes}。

在局部细化网格上实现多网格方法时，较高层次上的解决方案将只针对细化元素进行计算。此外，我们要求缺陷计算和平滑可以在每一级上进行，而不需要参考低一级。因此，我们用所有的精炼元素和一些复制元素建立局部网格。为了精确定义，我们将引入矢量类的概念。

向量类的定义是递归的。

- 设$operatorname{cl}(P)=3$，如果存在一个精炼的元素$E$，使得$P/in `mathscr{P}(E)$。

- $operatorname{set}\如果$operatorname{cl}(P)=2$，如果$operatorname{cl}(P)=3$，如果存在一个元素$E$，使得$P，Q=在$mathscr{P}(E)$中，并且$operatorname{cl}(Q)=3$。

- 设$mathrm{cl}(P)=1，如果$operatorname{cl}(P)=2，$operatorname{cl}(P)=3，并且如果存在着

- 设一个元素$E$，使得$P, Q\in\mathscr{P}(E)$和$operatorname{cl}(Q)=2$

- 设$operatorname{cl}(P)=0\quad$，所有剩余的点$P\在$mathscr{R}$中。

如果$x[P]=x[\mathscr{F}(P)]$对于所有$operatorname{cl}(P)<3$的点，向量$x_{0}, x_{1}, \ldots, x_{k}$是一致的。类似地，如果$A[P, Q]=A[\mathscr{F}(P), \mathscr{F}(Q)]$对于所有$operatorname{cl}(P)<3$和$operatorname{cl}(Q)<3$的点，矩阵$A_{0}, A_{1}$, $ldots, A_{k}$是一致的。根据结构，刚度矩阵$A$和右手边$b$是一致的。

设$x_{0}, ldots, x_{k}$为一致，$d_{l}=b_{l}-A_{l} x_{l}$为缺陷。如果$x_{l}[P]$对于$operatorname{cl}(P)=3$有所改变，那么对于$P$的点$operatorname{cl}(P)/geq 2$，新的缺陷将有所改变。为了计算新的缺陷，我们需要$x_{l}[P]$用于$operatorname{cl}(P) geq 1$的所有点。这促使我们提出以下定义：局部网格$Omega_{l}^{text {loc }}$是表面网格$Omega_{l}$的最小子集，这样$P就在$mathscr{P}\left(\Omega_{l}^{mathrm{loc}}}right)$的所有$P$的$operatorname{cl}(P) geq 1$，即。

$$
\mathscr{E}\left(\Omega_{l}^{\mathrm{loc}}\right)=\left\{E \in \mathscr{S}_{l}\for some \left.P \in `mathscr{P}(E)`right\}。
$$

在基础层面，我们有$Omega_{0}^{text {loc }}=Omega_{0}$。

\教科书bf{示例}2。我们考虑一种离散化，插值点由所有节点的集合建立。然后，例1的表面网格定义了以下的局部网格。

基层的点得到3级。在这里，第1层的所有点也得到了等级3。在局部网格$Omega_{2}^{text {loc }$上，$P_{25}, P_{29}, P_{30}, P_{31}, P_{32}, P_{33}, P_{34}, P_{39}$得到等级3。$P_{23}, P_{24}, P_{27}, P_{28}, P_{38}, P_{40}$ 属于第2类，$P_{26}, P_{35}, P_{36}, P_{37}$ 属于第1类。$ $P_{9}$在$mathscr{R}$中的点的儿子属于0类，但这个点和相应的两个元素不会被复制到$Omega_{2}^{text {loc }}$。

局部多网格方法将被定义为使解矢量$x_{0}, ldots, x_{k}$和修正量$c_{0}, ldots, c_{k}$始终一致。如果刚度矩阵$A_{l}\left[`Omega_{l}^{mathrm{loc}}right]$和右手边$b\left[`Omega_{l}^{mathrm{loc}}right.$在局部网格上组装，它们是不一致的。因此，$b[P]$和$A[P, P]$
为$operatorname{cl}(P) \leq 1$，不得在局部网格上使用。尽管如此。表面网格上的缺陷$d_{l}=$b_{l}-A_{l} x_{l}$可以由局部缺陷$d\left[\Omega_{l}^{l o c}\right]=b\left[\Omega_{l}^{mathrm{loc}}\right]-构建。A\left[\Omega_{l}^{\mathrm{loc}}\right] x\left[\Omega_{l}^{\mathrm{loc}}\right]$


$$
\begin{aligned}
\for } l=1, \ldots, k\text { set } & d_{l}[P]=d\left[\Omega_{l}^{l o c}\right][P] \text { for cl }(P) \geq 2 \text { and }\\
& d_{l}[P]=d_{l-1}[`mathcal{F}(P)] `text { for cl }(P)<2
\end{aligned}
$$

我们不需要$d_{l}[P]$在$operatorname{cl}(P)<2$时的值；它们将在平滑步骤中被设置为零。因此，$d_{l}$的限制必须不改变$d_{l-1}[Q]$，因为$Q\in `mathscr{T}_{l-1}$使得$operatorname{cl}(`mathscr{S}(Q))<2$。为了简单起见，我们设定$operatorname{ncl}(Q)=\operatorname{cl}(\mathscr{S}(Q))$，如果$mathscr{S}(Q)$是复制元素上的一个点，$operatorname{ncl}(Q)=3$，如果$Q/in\mathscr{E}(\mathscr{F}(E))$为一个精炼元素$E$。那么，可以改变$d_{l-1}[Q]$的点集得到$operatorname{ncl}(Q) geq 2$

\Subsection{Smoother and solver}.

我们为表面网格制定多网格方法，但所有的步骤将被定义为只使用局部网格上的点。每一层的基本步骤都是平滑的。

$$
\begin{array}{r}。
\mathrm{S}\left(\mathrm{c}_{1}, \mathrm{~d}_{1}\right)=\left\{\begin{array}{l}
\纹理 { 设置 }\`mathrm{d}_{l}[`mathrm{P}]=0 `text { for }.\ymathrm{cl}(mathrm{P})<2 }。
\纹理 { 解决 }W_{1} w_{l}=\mathrm{d}_{1}, ``````。
\纹理 { 设置 } w_{l}[\mathrm{P}]=0 纹理 { for }\opatorname{cl}(`mathbf{P})<3```。
\mathrm{~d}_{1}:=\mathrm{d}_{l}-A_{1} w_{l},\left.
\left.c_{l}:=c_{l}+w_{l}\right\}
\end{array}right.
\end{array}
$$

方程$W_{l} w_{l}=d_{l}$的求解过程应该是局部的，例如$W_{l}=operatorname{blockdiag}\left(A_{l}right)$或者$W_{l}=L U$（不完全LU分解）。

一个 "多重网格循环 "是递归定义的，它结合了网格转移和几个平滑步骤。循环取决于参数$theta<1, \nu_{0}+nu_{1}\geq 1$和$gamma\geq 1$。\geq 1$ 和 $gamma \geq 1$ 。

![](https://cdn.mathpix.com/snip/images/L8qE5VasFRkPTHtvYSnkGPieorcnI-n5YAGc2HsbnK8.original.fullsize.png)

现在，我们可以定义一个多栅格求解器。

![](https://cdn.mathpix.com/snip/images/9OVSnipmR7fETOTlQrKTVn-OFkitJ5j7XKtgliZIhO4.original.fullsize.png)

这里不需要更新缺陷，因为在每个多网格循环之后，$d_{k}=b_{k}-A_{k}left(x_{k}+c_{k}right)$的等式成立。缺陷的计算和解决方案的更新是表面网格上的全局操作，可以使用矢量类构建局部操作。

\Section{The UG library}.

像UG这样的大型软件系统，通常会在若干不同的抽象层次上进行描述。在这一章中，我们将从上到下地介绍这一层次，在较低的层次上，由于篇幅所限，我们将重点介绍几个基本部分。UG有三个设计层次，即架构设计、子系统设计和组件设计。

至少在架构和子系统层面上，UG是一种模块化设计，信息隐藏原则被广泛使用。所有的状态信息都分布在各子系统之间。UG是用$mathrm{C}$编程语言实现的。

\subsection{Architecture design}。

UG中的最高抽象级别是架构设计级别，如图所示。

\textbf{UG图书馆}。

UG库是完全独立于要解决的偏微分方程的。它提供了几何和代数数据结构以及大量的网格操作选项、数值算法、可视化技术和用户界面。

\textbf{问题类库}。

这一部分提供离散化、误差估计器，如果需要，还提供特定偏微分方程组的非标准求解器。

\textbf{Applications}。

应用程序最后提供领域描述、边界条件和系数函数，以完成问题描述。仿真运行通常由一个脚本文件控制，由UG的用户界面解释。

\Subsection{UG库子系统设计}。

架构设计的每一个构件都被分解成几个子系统。UG库的各个子系统如图2所示。现在我们对每个子系统所提供的服务做一个非正式的说明。然后，在接下来的小节中会对一些子系统进行更详细的解释。

![](https://cdn.mathpix.com/snip/images/mnOY4dKYy3z2dIvoC9pE_gHPIL6lZvU_2tHZVGSJfpo.original.fullsize.png)

\纹理bf{Usser接口}。

用户界面为用户提供了一种 "类似shell "的命令语言。UG库的所有操作通常可以通过在shell中输入命令或在代码中调用$C$函数来执行。脚本语言可用于控制复杂的仿真运行。可以打开多个图形窗口来显示仿真结果。在两个空间维度上，网格可以被交互操作。用户界面是基于下面描述的便携式设备界面。

\textbf{Graphics}。

图形子系统提供了一些基本的可视化方法，如网格图、等高线图、彩色图或矢量场。在三维空间中，已经实现了平面切割和隐线去除。集成图形包的优点是不需要编写中间数据文件，而且可以方便地显示矩阵结构和条目等信息。图形子系统在下面有更详细的描述。

\textbf{Numerics}。

数值子系统以模块化的形式提供数值算法，从基本的线性代数（1级和2级）到解决非线性时间依赖性偏微分方程的方法。此外，它还提供对离散化过程的支持，例如正交规则。数值子系统在下面有更详细的描述。

\textbf{Grid Manager}。

网格管理器子系统提供了非结构化网格和稀疏矩阵数据结构，以及对其进行操作的功能。这包括生成二维和三维的简单三角图。网格管理器在下面有更详细的解释。域管理器

域管理器的目的是为描述一般的二维和三维域以及域的表面（边界条件）和内部（系数）的函数提供功能。一般的方法是，一个$d$维的域$\Omega$由其边界$partial\Omega$描述，它是一个$d-$的一维超曲面。这在偏微分方程的背景下是非常自然的，因为无论如何都要提供边界条件。描述边界的标准方法是通过局部映射$f_{i}:\mathbb{R}^{d-1} \rightarrow \mathbb{R}^{d}$，$i=1\ldots n$，$n$为斑块数。另一种方法是将边界分解为若干个斑块，每个斑块由一个简单的表面网格给出。在这种情况下，一个补丁不存在简单的映射$f_{i}$。领域接口也将被用来访问CAD数据。

\纹理bf{设备管理器}。

设备管理器提供了一个叫做 "屏幕 "的默认设备，它至少允许基本的字符输入/输出。可选的是，屏幕设备还具有交互式图形功能。屏幕设备已经为标准C库、X11、远程X 11（使用套接字通信和远程机器上的X11功能守护程序）和苹果Macintosh实现。只写的图形输出可以用postscript和二进制格式（"元文件"）。

\纹理bf{低}

这个子系统提供了一些基本的功能，如内存管理、简单的数据库工具和便携式文件输入/输出。此外，还包括一些调试工具。

\纹理bf{负载平衡器}。

负载平衡器子系统的目的是解决在并行环境中必须将映射数据映射到处理器上时出现的图的划分和调度问题。目前的实现使用Chaco[15, 17]来实现这一目的。

\textbf{动态分布式数据（DDD）}。

DDD子系统实现了一种新的并行编程模型，特别适合管理分布式 "类图 "数据结构。数据对象可以轻松地在进程之间创建、删除和传输。分布式对象之间的通信以一种灵活和有效的方式得到支持。这个子系统将在下文中详细解释。

\纹理bf{并行处理器接口（PPIF）}。

PPIF是DDD使用的一种可移植的消息传递接口。它已经为PVM、MPI、PARIX、NX和T3D/T3E实现。当与快速的本地通信一起使用时，PPIF的开销非常小（例如，T3D上的共享内存获取/输入）。

\subsection{The grid manager subsystem}。

每个子系统都被分解为组件。组件通常在单个文件或几个文件中实现。图3显示了网格管理子系统的组件设计。主要组件是粗网格的生成，分层多网格结构的细化和取消细化，以及为各种元素类型提供标准形状函数。目前，自动粗网格的生成只适用于简单的网格。对于三维情况，$mathrm{J}$的网格发生器。Schöberl[23]已与UG连接。

![](https://cdn.mathpix.com/snip/images/xTUIB3aOX9mYFacQGZRUXVY2kVZvRZwjlA4ghIVEf2I.original.fullsize.png)

在下文中，我们集中讨论网格管理器的两个方面，即非结构化网格数据结构和细化算法。

\textbf{非结构化的网格数据结构.}。

UG的核心是其非结构化的网格数据结构，由 "几何 "和 "代数 "部分组成。几何部分是基于元素的，也就是说，所有的信息都可以从元素的本地访问。表2中给出了ELEMENT的数据类型。

无符号的整数组件控制用于存储各种信息，如元素类型（三角形、四边形、四面体等），元素如何被细化，子元素的数量等。id组件为元素提供了一个全局唯一的标识，主要由用户界面使用。一个网格级别$l$的所有元素，即$mathscr{S}_{l}$的集合，都包含在一个由pred和succ指针实现的双链表中。$mathrm{n}[\mathrm{l}$ ] 数组包含对元素角的引用，其类型为NODE。父亲和儿子指针提供了对较低和较高网格级别上的父亲和儿子元素的访问。注意，只有一个子元素的引用被存储。其余的子元素可以通过对细化规则的了解轻松访问。$mathrm{nb}[$]数组提供了对每个面（二维的边）上所有相邻元素的访问。所有与单个几何对象相关的代数信息都存储在一个VECTOR类型的数据结构中。一个元素的向量分量指的是与这个元素相关的代数信息。由于UG没有为3 \mathrm{D}$中的面提供数据结构，与3 \mathrm{D}$中的面相关的代数信息也可以通过sidevector $[$ ] 数组从元素中获取。最后，如果一个或多个面是域边界的一部分，bnds $[$]数组提供了对额外信息的访问。BNDS数据类型是由域子系统导出的。ELEMENT数据结构是通用的，也就是说，指针的实际数量取决于元素的使用环境。数字$n c$和$n s$是由元素类型给出的。此外，某些指针可能根本不存在，例如，内部元素省略bnds []，如果不需要面的自由度，则省略sidevector []等。

接下来要详细考虑的数据类型是表3中的NODE和VERTEX数据类型。多网格层次结构中不同网格级别的节点是有区别的，但由于它们经常与更粗的网格级别的节点共享相同的位置，所以位置信息被存储在VERTEX数据类型中，该数据类型在不同级别中不重复。VERTEX数据类型的基本信息是其$mathrm{x}$分量中的全局位置，由其xi和father分量给出的相对于下一个较粗网格级别的位置，以及bndp分量中的边界信息。从更粗的网格层插值是通过使用对粗网格元素父的引用来完成的，该元素包含全局位置和本地坐标$mathrm{xi}$。这允许人们将新的节点从它们的层次位置上移开，例如，$g$.以解决内部边界。

NODE数据结构同样有一个控制组件，持有状态信息，一个全局唯一的ID，以及实现双链表的pred和 succ组件。start组件指向一个LINK结构的单链表，实现了网格中所有相邻节点的列表。父亲和儿子组件提供了对共享相同VERTEX结构的节点的访问，这些节点由下一个更粗和更细的网格级别上的myvertex给出。最后，向量指的是与节点相关的自由度。

一个节点的邻居的链接列表是通过表4所示的LINK数据类型实现的。每个列表元素包含一个控制字，一个对下一个列表元素的引用和一个对相邻节点的引用。由于节点-邻居关系是一种对称的关系，我们可以将两个LINK结构组合成一个EDGE结构，也是在表4中给出的。此外，EDGE数据类型包含对与边相关的自由度的引用，以及对边的细分所得到的更细网格上的新节点的引用。请注意，从一个给定的LINK结构到它的EDGE和反方向的LINK都有快速访问。

这就完成了对数据结构的几何部分的描述。代数部分使用一个（修改过的）块压缩行存储格式来存储矩阵和向量。向量和矩阵块由表5$中所示的VECTOR和MATRIX数据类型实现。

VECTOR数据类型提供了对它所关联的几何对象的访问，即一个NODE、EDGE或ELEMENT类型的对象。控制字中的附加信息表明矢量块是否与元素的一个面相关。一个网格层面上的所有矢量块都是由一个双链表连接起来的，可以方便地进行重新排序。索引部分包含块的编号，跳过部分表示矩阵的某一行是否与Dirichlet边界条件相关，并在网格转移中被跳过。与一个给定的矢量块相关的矩阵块行是通过开始组件访问的。最后，代数分量被存储在值[ ]数组中。请注意，VECTOR数据类型是通用的，即分量$n v$的数量可能不同。

MATRIX数据类型用一个单链表实现了矩阵的块行。对角线块总是这个列表中的第一个块。单个块中存储的数值$n m$取决于与行和列块相关的几何对象的类型，即一个节点-节点耦合可能包含与节点-边缘耦合不同数量的组件。


注意，每个几何对象只有一个VECTOR类型的对象。值域中的条目数$n v$不仅包含自由度，还包含右手边和数值算法所需的额外存储（缺陷、修正、最后时间步长等）。MATRIX对象也是如此，它实际上可能包含几个矩阵，例如，刚度矩阵和刚度矩阵的不完全分解。数字子系统为描述实际计算中使用的向量和矩阵提供了一个符号化的机制。这些向量和矩阵的组件一般是存储在VECTOR和MATRIX数据结构中的组件的子集。

网格数据结构通过提供对元素、节点、顶点和向量的各种链接列表的访问而完成。数值算法的形式表明对数据结构的访问是逐级的。表6中的GRID数据类型提供了这种访问。由于所有的列表都是双链接的，所以可以对第一个和最后一个元素进行访问。

然后，所有的网格层次被合并到MULTIGRID数据类型中。它提供了对所有网格级别的访问，一些状态信息和多网格层次结构的上下文。组件theFormat指的是一个FORMAT类型的结构，它描述了每个几何对象在VECTOR和MATRIX数据结构中要保留的DOUBLE值的数量。此外，人们可以控制VECTOR对象的互连模式。多网格数据结构所需的所有内存都是从低子系统中实现的特殊HEAP中分配的。这个内存管理器特别适合有效地管理许多小对象。最后，每个MULTIGRID数据结构指的是对BVP类型的边界值问题（域、边界条件、系数函数）的描述，它由域子系统导出。

有人可能会说，这种非结构化的网格数据结构需要大量的内存。如果考虑标量模型问题，这当然是真的。但是，如果我们考虑复杂的三维应用，大部分的内存被数值数据所占据。为了说明这一点，请考虑下一节中介绍的两相流应用。在一个32乘32乘32的六面体网格上进行三维模拟需要102美元的内存。66美元被刚度矩阵的条目、ILU矩阵以及未知和辅助向量占据。

\纹理bf{细化算法}。

从第2节的讨论中可以看出，一个多网格序列$mathscr{T}=\left\{Omega_{0}, \Omega_{1}^{l o c}, \Omega_{2}^{l o c}, \ldots\right.$\left.\Omega_{k}^{text {loc }}\right}$应该满足以下特性。

- 嵌套性。网格层$l>0$上的每个元素$E$都有一个唯一的父元素$F=mathscr{F}(E)$，有$Omega(E) \subset \Omega(F)$。就代码而言，这种包含是不必要的，但随后需要额外的稳定性条件。

- 一致性。每个（局部）网格级别$Omega_{l}^{mathrm{loc}$是一个一致的网格（见2.1小节的定义）。

- 稳定性。所有的内角必须统一地远离零。

细化算法适用于各种元素类型和细化规则。一般来说，应用于元素$E$的细化规则允许$Omega(E)$通过使用$E$的角、边中心、面中心和元素中心被重新三角化。所有元素类型都可用于此目的。有规律的细化规则是那些连续应用时稳定的规则。图4显示了各种元素类型的规则精化规则。对于四面体，使用了Bey[6]的规则精化策略。与其他元素类型相比，四面金字塔不能只用金字塔来细分。它被细分为6个金字塔和4个四面体。

如果只应用有规律的细化规则，产生的网格就会自动一致。这与三维空间中的二分法类型的细化策略不同（参见[19]）。如果只有一些元素被有规律地细化，那么网格的一致性必须通过在过渡区域匹配边缘和面的细化模式来保证。这是通过引入不规则的细化规则来实现的，这些规则可能会减少内角。UG中的细化算法使用全套细化规则，即总是存在与任何边和面细化模式相匹配的细化规则。对于二维的情况和三维的简约情况，规则的数量非常少，可以存储在数据库中。在其他情况下，通过将元素中心与面的四边形和三角形连接起来，按要求生成适当的规则，从而形成金字塔形和四面体元素[18]。由于有全套的细化规则，不需要迭代就能找到一致的闭合，这在并行版本中特别有用。

只允许对规则元素进行细化，从而确保整体稳定性。如果不规则元素必须被细化，它们必须首先被规则元素取代，而规则元素又必须与相邻元素一致。全局细化算法的任务是将误差估计器所要求的细化与一致性和稳定性相匹配。下面我们给出全局细化算法的高级版本。作为输入，该算法接收一个多网格层次结构$mathscr{T}$，其中叶子元素（没有儿子的元素）已经被标记为所需的细化规则或粗化标签。如果一个元素的所有儿子都被标记为粗化，它们就会从数据结构中删除。当然，只有叶子元素可以被删除，因为粗化应该是与细化相反的操作。

![](https://cdn.mathpix.com/snip/images/--RV8mBtseWYTfxgPMkhBwg8DNK-qIzC9qnd7XLgrv4.original.fullsize.png)


RefineMultiGrid算法的整体结构类似于一个多网格V型循环。第一个for-loop(1)从顶层$k$进行到第一层。在这第一个循环中，没有对数据结构进行任何操作，只有细化标签被操作!函数MakeConsistent通过用一组一致的细化规则来标记$l$层的元素，计算出$l+1$层的一致网格。函数RestrictTags计算了l级标签对l-1级标签的影响。这时，如果有必要，不规则的细化规则会被规则的细化规则所取代。在第(4)行开始的第二个forloop中，数据结构实际上被修改，从粗级到细级进行。在第(5)行进入第二个循环时，$l$层的网格已经被修改，$l+1$层是由存储在$l$层的标签构建的。在第(5)行中再次调用MakeConsistent来计算一致的标签；然后DetermineCopies计算代数类，进而决定$l+1$层所需的复制元素。第(7)行的函数RefineGrid实际上修改了数据结构，即在$l+1$层创建/删除了适当的对象，并正确设置了指针。完成后，RefineMultiGrid函数已经构建了一个新的多网格层次结构。这个层次结构的顶层可以是$k-1, k$或$k+1$。如[4]所示，该算法的逐级结构非常适用于并行化。图5显示了一个用金字塔元素和环状体三角化的局部精炼球的切面。

\The DDD subsystem}。

为了在UG应用中利用并行计算机的力量，网格管理器子系统被扩展到处理分布在处理器本地存储器中的网格。考虑到所涉及的数据结构的复杂性及其因网格细化和负载平衡而产生的动态变化，由于缺乏对通信和分配方法的抽象，直接使用消息传递的编程模型肯定会失败。因此，我们设计了一个抽象的编程模型，支持对分布式网格数据的高级操作，并将其整合到UG库中。从架构的角度来看，这个动态分布式数据（DDD）模型是作为一个UG子系统实现的；不过，为了允许其他应用程序的并行化，也有一个独立的版本。

DDD支持的基本抽象是分布式图的概念。图的节点对应于那些应用程序的数据结构，这些数据结构应可分布在不同的处理器上（DDD对象）；图的边代表数据结构之间的引用（参见正式规范文件[8]）。分布式对象被用来耦合几个本地图（每个处理器一个），以建立分布式图。DDD库的实现包含三个具有不同功能的组件，如表7所述，这些组件可用于操作分布式图结构和调用高效的通信程序（详细说明见DDD参考手册[7]）。

关于UG并行网格管理器，以下数据类型被认为是DDD对象。

\纹理bf{ELEMENT}：元素是分布式网格的中心数据结构。作为动态负载平衡的结果，元素被标记为一个目标处理器。网格迁移算法通过调用传输组件的DDD命令来执行网格的重新分配。所有其他数据类型的重新分配直接取决于元素的迁移。网格重叠策略是以Master和Ghost元素的方式制定的。

\纹理bf{NODE}。分布式网格中的节点重叠情况取决于元素重叠方案。存在三种类型的节点。主节点、边界节点和幽灵节点。对于新创建的节点的识别（在自适应细化过程中），使用DDD识别组件。

\纹理bf{VERTEX}。顶点的复制与相应节点的复制直接相关。DDD提供了一些机制，允许以简单的方式表达这种依赖关系。

\纹理bf{VECTOR}。这种代数数据类型的分布也取决于元素的分布。由于每个向量都与其在其他处理器上的副本相耦合，因此可以使用DDD接口组件，以使之前以不一致的方式存储的向量变得一致。通常情况下，这是由数字子系统调用DDD接口通信来完成的，该通信有三个参数：每个VECTOR数据结构应该通信的数据大小，一个将VECTOR结构中的数据复制到消息缓冲区的收集程序，一个将消息缓冲区的数据整合到VECTOR中的分散程序。

通过使用DDD，并行网格管理器与顺序网格管理器在使用界面和程序代码方面都是一样的。前者有利于清晰的算法和层次抽象，后者对于持续的代码开发和维护来说是必要的。作为网格管理器子系统的一部分，只有数值子系统需要进行明显的代码调整；因此，任何使用标准数值技术的顺序UG应用都可以使用最先进的并行计算的所有优势，而无需为并行化做出额外的努力。

\Subsection{The graphics subsystem}。

UG中的图形子系统提供了一些基本的可视化方法以及一些互动工具。根据设备管理器的能力，图形输出显示在X11窗口上，写入二进制元文件格式或写入postscript文件（"设备"）。可以在不同的设备上同时打开任意数量的窗口。

图形子系统的基本对象是plotobjects（由结构PLOTOBJ表示）和work（由结构WORK表示）。Plotobjects是（抽象）对象的表示，例如网格（2D/3D）或稀疏矩阵的图形（2D）。它们包含对作为数据库的多网格结构的引用。不同的方法可以应用于plotobjects。最简单的是绘制方法，它显示一个plotobject。其他方法能够改变绘图对象的配置，比如findrange方法，改变例如包含标量场评估的绘图对象的颜色范围。同样，其他方法可以改变底层数据库的状态（即多网格结构），如movenode方法。

表8列出了可用的plotobjects，并给出了它们的简短描述。表9列出了UG中实现的方法以及简短的描述。请注意，并非每一种方法都可以应用于每一个绘图对象。最后，表10更详细地描述了图形子系统的三个组成部分。

\Subsection{The numerics subsystem}。

UG的数值子系统为网格管理器基于几何的数据结构中的向量和矩阵的计算提供了广泛的数值工具（参见第2.2节）。所有代数对象都可以通过UG脚本中的抽象符号来描述和引用。

使用脚本可以自由配置数值组件，例如，cg方法可以使用多网格循环作为预处理，多网格循环可以使用所有类型的平滑器和网格转移。这个线性求解器可以在牛顿方法中调用，它可以在每个时间步长中应用。因此，对于一个典型的时间依赖性非线性问题，用户只需提供缺陷计算的集合程序和元素级线性化问题的刚度矩阵的集合程序。为随时间变化的网格适应性提供了一个通用的分层误差指标，但为了获得最佳网格，通常需要一个与问题相关的误差估计器。为了灵活组合脚本级的组件，我们开发了数字程序的概念。

在许多情况下，问题类和应用程序不需要任何并行扩展，因为所有全局数值操作都包含在UG库中。特别是，在BLAS例程和平滑程序中调用了收集和分散例程。

\Section{Applications}。

\Subsection{The finite element library}。

对于许多应用，多线性符合近似不是最佳选择。特别是，如果解是光滑的，域的几何形状是简单的，可以在最粗的网格上解决，高阶元素的收敛性要好得多。为了减少线性弹性中的锁定现象，可以使用不符合要求的元素和混合元素，通过高阶混合元素可以获得有效的误差界限，四阶问题可以通过$C^{1}$元素进行近似。

在UG中，实现了一个通用的有限元库[25]。因此，我们考虑节点、边、面和元素上的插值点$mathscr{P}$。

这个列表可以很容易地扩展：基本上，局部刚度矩阵$A(E)$和局部插值矩阵$I(E)$的组合必须在每个离散化中实现，然后所有其他工具可以被应用。

首先，我们比较了再入角域中标量测试问题的离散化。

![](https://cdn.mathpix.com/snip/images/V4L6neMMFGU3p6b0kyrkHdpQt4PlfdPHcsB2m63UNak.original.fullsize.png)



这里，细化策略确保了所有情况下的最佳收敛顺序（参见表13）。

下一个例子展示了一个具有变化系数的扩散问题的近似。

最后，我们给出了一个具有随时间变化的表面载荷的线性弹性的例子。这里，一个由六面体、金字塔和四面体组成的网格被同时细化和粗化。它在随后的三个时间步骤中被绘制出来。

\Density-driven flow in porous media}小节。

在许多情况下，地下水在多孔介质中的流动涉及影响液体密度的溶质的运输。如果密度变化超过20美元/%$，这发生在盐穹或盐层附近，流动和输送就会产生强烈的耦合。主要的耦合是通过流体方程的体力项和传输方程的平流项产生的。第二个耦合来自于传输方程中与速度有关的流体动力分散。这些耦合导致了方程中的非线性，排除了分析解，是数值模拟的一个挑战。

密度驱动的流动问题可以用两个非线性的、耦合的、随时间变化的微分方程来描述，一个是流体的连续性方程，一个是溶质传输的连续性方程。假设Darcy定律有效，流体的连续性方程是以压力为单位写的。这两个方程在以顶点为中心的有限体积上使用不同的控制体积结构进行离散。在主导对流的情况下，对齐的有限体积方法，即有限体积与给定的速度对齐，比标准的有限体积方法更好。此外，在计算流体速度时，对涉及到的条款进行了一致的速度近似。瞬态方程用完全隐式的时间步长方案解决，并带有时间步长控制。非线性方程在完全耦合模式下使用近似的牛顿多网格方法进行求解，其中线性化系统使用线性多网格方法进行求解。

对于沿海含水层中的海水入侵问题，即所谓的亨利问题，存在Segol[24]的半分析稳态解，因此被广泛用作基准。然而，这个问题对一致的速度和小过渡区的描述不是很敏感。图6显示了与分析解和其他数值结果$[12,13].$相比，稳态20美元、50美元和80美元的浓度隔离线，得到的数值解都与分析解非常接近。

另一个测试问题是所谓的Elder问题。一个封闭的矩形盒子，以横截面为模型，顶部边界上有一个溶质源被考虑。我们对这个问题进行了修改，将该领域划分为五个子域。在四个子域中，与第五个子域相比，渗透率值减少了10^{3}$的系数。计算是在一个非结构化的网格上进行的，在最细的网格上有50849个节点，使用对齐的有限体积。图7显示了盐分布的时间演变。



\Subsection{Two-phase flow in porous media}.

两种不相溶流体在多孔介质中的流动由两个耦合的高度非线性时间依赖性偏微分方程描述，见[1]的介绍。这些方程在开发有效的原位修复技术方面发挥着重要作用。由于方程的双曲/抛物线特性、强异质性和高非线性，它们对多网格求解构成了一个挑战。

开发了一个问题类，以完全耦合的方式解决两相流方程，使用湿润相压力和非湿润相饱和度作为未知数。实现了有限体积和控制体积有限元离散化的一阶上卷。这两种离散方法都支持二维和三维的所有元素类型。时间离散化是完全隐式的，导致每个时间步长的非线性代数方程组。非线性方程然后通过牛顿多网格技术进行迭代求解。采用直线搜索法来实现全局收敛。UG中已经实现了几种多网格技术，以处理由饱和前沿和绝对渗透率变化引起的系数跳跃。这些跳跃一般不与粗网格线对齐。在下面的模拟中，使用了一种带有对角线缩放、点块ILU平滑器$left(\nu_{1}=\nu_{2}=2\right)$和$mathrm{W}$循环$(\gamma=2)$的多梯度方法。

图8显示了密集的非水相液体（DNAPL，一种密度高于水且与水不相容的液体）渗入随机生成的多孔介质的饱和图。仿真历史如表14所示。该表显示，随着网格大小的增加（和固定的时间步长），多网格迭代的平均数和最大数保持在一定范围内。

图 9 显示了三维 DNAPL 渗入异质多孔介质的饱和等值面。在储层的中心位置插入了一个低渗透率的块状物。进入压力效应阻止了DNAPL渗透到低渗透率的透镜中。这个问题的多网格性能如表15所示。 表15.三维渗透问题的模拟数据

\Section{Conclusions}.

我们详细描述了$mathrm{UG}$的基本理念和软件设计结构。目前，UG库中大部分子系统的概念和实现已经基本完成，但这些组件还将进一步扩展。在未来的工作中，我们将重点关注不同的应用和有几百万未知数的复杂问题的大型模拟。尽管软件设计是本文的主要重点，但人们应该牢记，高效和稳健的数值方法的开发至少也是同样重要的。我们在这个方向上的工作通过数值例子来说明。

从关注软件适用性的用户角度来看，我们可以说，不仅要有基本的代码文档，还要有对概念的描述和对理论背景的解释（都要有例子）。到目前为止，我们只为UG提供了基本的文档。

我们想强调的是，这个软件的开发涉及到一大群同事和几年的时间。我们在开发过程中的经验表明，必须包括一个版本控制系统和调试工具，以提高软件设计和编码的效率。明确定义子系统之间的内部接口和外部接口（例如用于领域描述、粗略网格生成、可视化后处理）对于维护和可扩展性至关重要。

\Section{References}.

1.Aziz, K., Settari, A.: 石油储层模拟。Elsevier, 1979

2.R. Bank:PLTMG用户指南7.0美元版本，SIAM，1994年

3.R. Bank, T. Dupont, H. Y serentant: The Hierarchical Basis Multigrid Method, Numer.Math.52 (1988) $427-458$

4.P. Bastian:Parallele adaptive Mehrgitterverfahren.Teubner Skripten zur Numerik, Stuttgart: Teubner-Verlag, 1996

5.P. Bastian, G. Wittum: 论稳健和适应性多网格方法。在。P. Hemker, P. Wesseling (eds.):Multigrid Methods IV.ISNM，巴塞尔。Birkhäuser, 1994

6.J. Bey:四面体网格细化。Computing $mathbf{5 5}$ (1995) 355-378 7.K. Birken：《并行编程环境下的动态分布式数据--DDD参考手册》。Forschungs- und Entwicklungsberichte RUS-23, Rechenzentrum der Universität Stuttgart, 1994 8.K. Birken, P. Bastian:并行编程环境中的动态分布式数据（DDD）--规范和功能。Forschungs- und Entwicklungsberichte RUS-22, Rechenzentrum der Universität Stuttgart, 1994

9.J. H. Bramble, J. E. Pasciak, J. Wang, J. Xu:无规则性假设的多梯度算法的收敛估计，Math.Comp.57 (1991) $23-45$

10.J.H. Bramble, J. E. Pasciak, J. Xu:Parallel Multigrid Preconditioners Math.Comp. $mathbf{5 5}$ (1990) 1-22

11.P. Deuflhard, P. Leinen, H. Y serentant: Concepts of an A daptive Hierarchical Finite Element Code.IMPACT of Computing in Science and Engineering, 1 (1989) 3-35

12.H.-J. Diersch: FEFLOW User's Manual Version 4.2., tech. rep.WASY $mathrm{GmbH}$, Berlin, 1994

13.E. Frind, J. Molson: SALTFLOW 2.0$ 用户指南。加拿大滑铁卢地下水研究中心，1994。

14.W. Hackbusch: Multi-Grid Methods and Applications.BerlinHeidelberg-New York:Springer, 1985

15.B. Hendrickson, $R .$ Leland:chaco用户指南1.0版。技术。

Rep. SAND93-2339, Sandia国家实验室, 1993

16.E. H. Hirschel (ed.):用高性能计算机进行流动模拟II。Braunschweig: Vieweg, 1996

17.S. Lang:最后一次使用平行适应性Mehrgitterberechnungen。

埃朗根-纽伦堡大学, IMMD III, 1994年

18.S. Lang:非结构化网格层次的自适应细化和取消细化。技术报告，斯图加特大学，计算机应用研究所，1997。准备中

19.J. M. Maubach:通过反射产生的N$简化网格的局部双切细化。SIAM J. Sci. Comput.16 (1995) 210-227

20.D. J. Mavripilis:非结构化网格的三维多网格雷诺平均纳威-斯托克斯求解器。AIAA Journal, 33 (1995) 21.L. C. McInnes, B. Smith:PETSc2.0:使用MPI来开发数值软件库的案例研究。In Proc. of the MPI Developers Conference, Notre Dame, IN, 1995

22.M. Raw:3 D$ navier-stokes方程的耦合代数多义性求解器。In Proc. of the $10^{text {th }}$ GAMM Seminar Kiel, Notes on Numerical Fluid Mechanics, W. Hackbusch, G. Wittum (eds.) vol. 49 , Braunschweig: Vieweg

23.J. Schöberl:计算力学中混合有限元模型的分析和实现。硕士论文，林茨大学，1995 24.G. Ségol: 经典地下水模拟。Englewood Cliffs, NJ: Prentice Hall, 1994

25.C. Wieners:有限元的自适应多网格方法的实现。斯图加特大学，SFB404预印本97/12，1997 26.G. Wittum: Stokes- and Navier-Stokes方程的多网格方法。Numer.Math., 54 (1989) 543-563

27.H. Y serentant: Uber die Ausspaltung von Finite-Element-Räumen in Teilräume verschiedener Verfeinerungsstufen.Habilitationsschrift, 1984