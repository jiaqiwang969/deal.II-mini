<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_12.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-12 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-12 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Overview">Overview</a>
        <li><a href="#Theequation">The equation</a>
        <li><a href="#Thetestproblem">The test problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheScratchDataandCopyDataclasses">The ScratchData and CopyData classes</a>
        <li><a href="#TheAdvectionProblemclass">The AdvectionProblem class</a>
      <ul>
        <li><a href="#Theassemble_systemfunction">The assemble_system function</a>
      </ul>
        <li><a href="#Alltherest">All the rest</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Whyusediscontinuouselements">Why use discontinuous elements</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-12/doc/intro.dox</p>
<p><br />
</p>
<p><em> Note: A variant called <a class="el" href="step_12b.html">step-12b</a> of this tutorial exists, using <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> as is done in this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="AnexampleofanadvectionproblemusingtheDiscountinuousGalerkinmethod"></a></p><h1>An example of an advection problem using the Discountinuous Galerkin method</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>本例专门介绍了 <em> 非连续Galerkin方法 </em> ，简称为DG方法。它包括以下内容。</p><ol>
<li>
用DG方法对线性平流方程进行离散化。 </li>
<li>
使用FEInterfaceValues组装跳跃项和单元间界面上的其他表达式。 </li>
<li>
使用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. </li>
</ol>
<p>组合系统矩阵。</p>
<p>这个项目特别关注的是DG方法的循环。这些被证明是特别复杂的，主要是因为对于面的条件，我们必须分别区分边界、规则的内部面和有悬挂节点的内部面的情况。 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 处理了单元和面迭代的复杂性，并允许为不同的单元和面项指定 "工作者"。面条款本身的整合，包括对自适应细化面的整合，是通过FEInterfaceValues类完成的。</p>
<p><a class="anchor" id="Theequation"></a></p><h3>The equation</h3>
<p>本例中解决的模型问题是线性平流方程</p>
<p class="formulaDsp">
\[ \nabla\cdot \left({\mathbf \beta} u\right)=0 \qquad\mbox{in }\Omega, \]
</p>
<p>受制于边界条件</p>
<p class="formulaDsp">
\[ u=g\quad\mbox{on }\Gamma_-, \]
</p>
<p>在域的边界 \(\Gamma=\partial\Omega\) 的流入部分 \(\Gamma_-\) 。 这里， \({\mathbf \beta}={\mathbf \beta}({\bf x})\) 表示一个矢量场， \(u\) 是（标量）解函数， \(g\) 是边界值函数。</p>
<p class="formulaDsp">
\[ \Gamma_- \dealcoloneq \{{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})&lt;0\} \]
</p>
<p>表示域边界的流入部分， \({\bf n}\) 表示边界的单位外向法线 \(\Gamma\) 。这个方程是本教程第9步中已经考虑过的平流方程的保守版本。</p>
<p>在每个单元格 \(T\) 上，我们从左边乘以一个测试函数 \(v_h\) ，并通过部分整合得到。</p>
<p class="formulaDsp">
\[ \left( v_h, \nabla \cdot (\beta u_h) \right)_T = -(\nabla v_h, \beta u_h) + \int_\Gamma v_h u_h \beta \cdot n \]
</p>
<p>当对所有单元 \(T\) 求和时，边界积分是在所有内部和外部面进行的，因此，有三种情况。</p><ol>
<li>
流入的外部边界（我们用给定的 \(g\) 代替 \(u_h\) ）。 \(\int_{\Gamma_-} v_h g \beta \cdot n\) </li>
<li>
流出的外部边界。 \(\int_{\Gamma_+} v_h u_h \beta \cdot n\) </li>
<li>
内面（两边的积分变成了跳跃，我们使用上风速度）。 \(\int_F [v_h] u_h^{\text{upwind}} \beta \cdot n\) </li>
</ol>
<p>。</p>
<p>这里，跳跃被定义为 \([v] = v^+ - v^-\) ，其中上标指的是面的左（'+'）和右（'-'）值。如果 \(\beta \cdot n&gt;0\) ，上风值 \(u^{\text{upwind}}\) 被定义为 \(u^+\) ，否则为 \(u^-\) 。</p>
<p>因此，依赖网格的弱形式为：。</p>
<p class="formulaDsp">
\[ \sum_{T\in \mathbb T_h} -\bigl(\nabla \phi_i,{\mathbf \beta}\cdot \phi_j \bigr)_T + \sum_{F\in\mathbb F_h^i} \bigl&lt; [\phi_i], \phi_j^{upwind} \beta\cdot \mathbf n\bigr&gt;_{F} + \bigl&lt;\phi_i, \phi_j \beta\cdot \mathbf n\bigr&gt;_{\Gamma_+} = -\bigl&lt;\phi_i, g \beta\cdot\mathbf n\bigr&gt;_{\Gamma_-}. \]
</p>
<p>这里， \(\mathbb T_h\) 是三角形的所有活动单元的集合， \(\mathbb F_h^i\) 是所有活动内部面的集合。这种公式被称为上风非连续Galerkin方法。</p>
<p>为了实现这种双线性形式，我们需要用通常的方法计算单元项（第一个和）来实现单元上的积分，用FEInterfaceValues计算界面项（第二个和），以及边界项（另外两个项）。所有这些的求和是通过 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. 完成的。</p>
<p><a class="anchor" id="Thetestproblem"></a></p><h3>The test problem</h3>
<p>我们在 \(\Omega=[0,1]^2\) 上求解平流方程， \({\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)\) 代表一个圆形的逆时针流场， \(g=1\) 代表 \({\bf x}\in\Gamma_-^1 := [0,0.5]\times\{0\}\) ， \(g=0\) 代表 \({\bf x}\in \Gamma_-\setminus \Gamma_-^1\) 。</p>
<p>我们通过估计每个单元的梯度规范，自适应地细化网格，在一连串的网格上求解。在每个网格上求解后，我们以vtk格式输出解决方案，并计算解决方案的 \(L^\infty\) 准则。由于精确解是0或1，我们可以用它来衡量数值解的过冲程度。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>前面几个文件已经在前面的例子中讲过了，因此不再做进一步的评论。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span> </div></div><!-- fragment --><p>这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过&ndash;正如你在以前的教程程序中所看到的&ndash;用户与有限元类的交互根本不多：它们被传递给 <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> 和 <code><a class="el" href="classFEValues.html">FEValues</a></code> 对象，仅此而已。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span> </div></div><!-- fragment --><p>FEInterfaceValues需要这个头来计算界面上的积分。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span> </div></div><!-- fragment --><p>我们将使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散产生的系统矩阵的特殊块状结构。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span> </div></div><!-- fragment --><p>我们将使用梯度作为细化指标。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span> </div></div><!-- fragment --><p>最后，新的包含文件用于使用MeshWorker框架中的Mesh_loop。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span> </div></div><!-- fragment --><p>像所有的程序一样，我们在完成这一部分时，要包括所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不含前缀。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12 </div><div class="line">{ </div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  BoundaryValues() = <span class="keywordflow">default</span>; </div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points, </div><div class="line">                          std::vector&lt;double&gt; &amp;          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>, </div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>; </div><div class="line">}; </div></div><!-- fragment --><p>考虑到流动方向，单位方块 \([0,1]^2\) 的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右边界上规定了值0。该函数在流出边界上的值将不会在DG方案中使用。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points, </div><div class="line">                                     std::vector&lt;double&gt; &amp;          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>, </div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{  </div><div class="line">  (void)component; </div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1); </div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(), </div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size())); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i) </div><div class="line">    { </div><div class="line">      <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)  </div><div class="line">        values[i] = 1.; </div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        values[i] = 0.; </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p>最后，一个计算并返回风场的函数 \(\beta=\beta(\mathbf x)\) 。正如在介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置 \(z\) 分量（即为零），而这个函数在目前的实现中不能用于1D。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) </div><div class="line">{ </div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()); </div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field; </div><div class="line">  wind_field[0] = -p[1]; </div><div class="line">  wind_field[1] = p[0]; </div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10) </div><div class="line">    wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>(); </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> wind_field; </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="TheScratchDataandCopyDataclasses"></a> </p><h3>The ScratchData and CopyData classes</h3>
<p>以下对象是我们在调用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. 时使用的抓取和复制对象 新对象是FEInterfaceValues对象，它的工作原理类似于FEValues或FEFacesValues，只是它作用于两个单元格之间的接口，并允许我们以我们的弱形式组装接口条款。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">struct </span>ScratchData </div><div class="line">{ </div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping, </div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe, </div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature, </div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face, </div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | </div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>, </div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags = </div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>) </div><div class="line">    : fe_values(mapping, fe, quadrature, update_flags) </div><div class="line">    , fe_interface_values(mapping, </div><div class="line">                          fe, </div><div class="line">                          quadrature_face, </div><div class="line">                          interface_update_flags) </div><div class="line">  {} </div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data) </div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(), </div><div class="line">                scratch_data.fe_values.get_fe(), </div><div class="line">                scratch_data.fe_values.get_quadrature(), </div><div class="line">                scratch_data.fe_values.get_update_flags()) </div><div class="line">    , fe_interface_values(scratch_data.fe_interface_values.get_mapping(), </div><div class="line">                          scratch_data.fe_interface_values.get_fe(), </div><div class="line">                          scratch_data.fe_interface_values.get_quadrature(), </div><div class="line">                          scratch_data.fe_interface_values.get_update_flags()) </div><div class="line">  {} </div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values; </div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values; </div><div class="line">}; </div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyDataFace </div><div class="line">{ </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>; </div><div class="line">  std::vector&lt;types::global_dof_index&gt; joint_dof_indices; </div><div class="line">}; </div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData </div><div class="line">{ </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>; </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs; </div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices; </div><div class="line">  std::vector&lt;CopyDataFace&gt;            face_data; </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell) </div><div class="line">  { </div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell); </div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell); </div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell); </div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line">  } </div><div class="line">}; </div></div><!-- fragment --><p><a class="anchor" id="TheAdvectionProblemclass"></a> </p><h3>The AdvectionProblem class</h3>
<p>在这个准备工作之后，我们继续进行这个程序的主类，称为AdvectionProblem。</p>
<p>这对你来说应该是非常熟悉的。有趣的细节只有在实现集合函数的时候才会出现。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>AdvectionProblem </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  AdvectionProblem(); </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(); </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line">  <span class="keywordtype">void</span> setup_system(); </div><div class="line">  <span class="keywordtype">void</span> assemble_system(); </div><div class="line">  <span class="keywordtype">void</span> solve(); </div><div class="line">  <span class="keywordtype">void</span> refine_grid(); </div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>; </div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>; </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping; </div></div><!-- fragment --><p>此外，我们要使用DG元素。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe; </div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler; </div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature; </div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face; </div></div><!-- fragment --><p>接下来的四个成员代表要解决的线性系统。 <code>system_matrix</code> and <code>right_hand_side</code> 是由 <code>assemble_system()</code>, the <code>solution</code> 产生的，在 <code>solve()</code>. The <code>sparsity_pattern</code> 中计算，用于确定 <code>system_matrix</code> 中非零元素的位置。</p>
<div class="fragment"><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern; </div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix; </div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution; </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> right_hand_side; </div><div class="line">}; </div></div><!-- fragment --><p>我们从构造函数开始。 <code>fe</code> 的构造器调用中的1是多项式的度数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem() </div><div class="line">  : mapping() </div><div class="line">  , fe(1) </div><div class="line">  , dof_handler(triangulation) </div><div class="line">  , quadrature(fe.tensor_degree() + 1) </div><div class="line">  , quadrature_face(fe.tensor_degree() + 1) </div><div class="line">{} </div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system() </div><div class="line">{ </div></div><!-- fragment --><p>在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。</p>
<div class="fragment"><div class="line">dof_handler.distribute_dofs(fe); </div></div><!-- fragment --><p>我们从生成稀疏模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到 <code>sparsity_pattern</code> 并可以被丢弃。</p>
<p>为了建立DG离散的稀疏模式，我们可以调用类似于 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, 的函数，该函数被称为 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>: 。</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs()); </div><div class="line"><a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp); </div><div class="line">sparsity_pattern.copy_from(dsp); </div></div><!-- fragment --><p>最后，我们设置了线性系统的所有组成部分的结构。</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern); </div><div class="line">  solution.reinit(dof_handler.n_dofs()); </div><div class="line">  right_hand_side.reinit(dof_handler.n_dofs()); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="Theassemble_systemfunction"></a> </p><h4>The assemble_system function</h4>
<p>这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是在调用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 时包含逻辑，我们只需要指定在每个单元格、每个边界面和每个内部面应该发生什么。这三个任务是由下面的函数里面的lambda函数处理的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system() </div><div class="line">{ </div><div class="line">  <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>; </div><div class="line">  <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function; </div></div><!-- fragment --><p>这是将对每个单元格执行的函数。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell, </div><div class="line">                             ScratchData&lt;dim&gt; &amp;scratch_data, </div><div class="line">                             CopyData &amp;        copy_data) { </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = </div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell(); </div><div class="line">  copy_data.reinit(cell, n_dofs); </div><div class="line">  scratch_data.fe_values.reinit(cell); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points(); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values; </div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>(); </div></div><!-- fragment --><p>我们解决的是一个同质方程，因此在单元项中没有显示出右手。 剩下的就是整合矩阵条目。</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) </div><div class="line">    { </div><div class="line">      <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]); </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i) </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j) </div><div class="line">          { </div><div class="line">            copy_data.cell_matrix(i, j) += </div><div class="line">              -beta_q                      <span class="comment">// -\beta </span></div><div class="line">              * fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i </span></div><div class="line">              * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j </span></div><div class="line">              * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx </span></div><div class="line">          } </div><div class="line">    } </div><div class="line">}; </div></div><!-- fragment --><p>这是为边界面调用的函数，包括使用FEFaceValues的正常积分。新的逻辑是决定该术语是进入系统矩阵（流出）还是进入右手边（流入）。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell, </div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no, </div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data, </div><div class="line">                                 CopyData &amp;          copy_data) { </div><div class="line">  scratch_data.fe_interface_values.reinit(cell, face_no); </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face = </div><div class="line">    scratch_data.fe_interface_values.get_fe_face_values(0); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); </div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>(); </div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>(); </div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(q_points.size()); </div><div class="line">  boundary_function.value_list(q_points, g); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) </div><div class="line">    { </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; </div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (beta_dot_n &gt; 0) </div><div class="line">        { </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i) </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j) </div><div class="line">              copy_data.cell_matrix(i, j) += </div><div class="line">                fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i </span></div><div class="line">                * fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j </span></div><div class="line">                * beta_dot_n                    <span class="comment">// \beta . n </span></div><div class="line">                * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx </span></div><div class="line">        } </div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i) </div><div class="line">          copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i </span></div><div class="line">                                   * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g </span></div><div class="line">                                   * beta_dot_n  <span class="comment">// \beta . n </span></div><div class="line">                                   * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx </span></div><div class="line">    } </div><div class="line">}; </div></div><!-- fragment --><p>这是在内部面调用的函数。参数指定了单元格、面和子面的指数（用于自适应细化）。我们只是将它们传递给FEInterfaceValues的reinit()函数。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell, </div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f, </div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf, </div><div class="line">                             <span class="keyword">const</span> Iterator &amp;    ncell, </div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf, </div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf, </div><div class="line">                             ScratchData&lt;dim&gt; &amp;  scratch_data, </div><div class="line">                             CopyData &amp;          copy_data) { </div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values; </div><div class="line">  fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf); </div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>(); </div><div class="line"></div><div class="line">  copy_data.face_data.emplace_back(); </div><div class="line">  CopyDataFace &amp;copy_data_face = copy_data.face_data.back(); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>(); </div><div class="line">  copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>(); </div><div class="line"></div><div class="line">  copy_data_face.cell_matrix.reinit(n_dofs, n_dofs); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>(); </div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>(); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint) </div><div class="line">    { </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint]; </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i) </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j) </div><div class="line">          copy_data_face.cell_matrix(i, j) +=  </div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i] </span></div><div class="line">            * </div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind} </span></div><div class="line">            * beta_dot_n                                   <span class="comment">// (\beta . n) </span></div><div class="line">            * JxW[qpoint];                                 <span class="comment">// dx </span></div><div class="line">    }  </div><div class="line">}; </div></div><!-- fragment --><p>下面的lambda函数将处理从单元格和面组件中复制数据到全局矩阵和右侧的问题。</p>
<p>虽然我们不需要AffineConstraints对象，因为在DG离散中没有悬空节点约束，但我们在这里使用一个空对象，因为这允许我们使用其<code>copy_local_to_global</code>功能。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints; </div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) { </div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix, </div><div class="line">                                         c.cell_rhs, </div><div class="line">                                         c.local_dof_indices, </div><div class="line">                                         system_matrix, </div><div class="line">                                         right_hand_side); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data) </div><div class="line">    { </div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix, </div><div class="line">                                             cdf.joint_dof_indices, </div><div class="line">                                             system_matrix); </div><div class="line">    } </div><div class="line">}; </div><div class="line"></div><div class="line">ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face); </div><div class="line">CopyData         copy_data; </div></div><!-- fragment --><p>在这里，我们最终处理了装配问题。我们传入ScratchData和CopyData对象，以及上面的lambda函数，并指定我们要对内部面进行一次装配。</p>
<div class="fragment"><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(), </div><div class="line">                        dof_handler.end(), </div><div class="line">                        cell_worker, </div><div class="line">                        copier, </div><div class="line">                        scratch_data, </div><div class="line">                        copy_data, </div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> | </div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> | </div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>, </div><div class="line">                        boundary_worker, </div><div class="line">                        face_worker); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="Alltherest"></a> </p><h3>All the rest</h3>
<p>对于这个简单的问题，我们使用了最简单的求解器，称为Richardson迭代，它代表了简单的缺陷修正。这与一个块状SSOR预处理相结合，该预处理使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状的Gauss-Seidel预处理（见PreconditionBlockSOR类，放松=1）会做得更好。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve() </div><div class="line">{ </div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12); </div><div class="line">  <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control); </div></div><!-- fragment --><p>这里我们创建了预处理程序。</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner; </div></div><!-- fragment --><p>然后将矩阵分配给它，并设置正确的块大小。</p>
<div class="fragment"><div class="line">preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>()); </div></div><!-- fragment --><p>做完这些准备工作后，我们就可以启动线性求解器了。</p>
<div class="fragment"><div class="line">  solver.solve(system_matrix, solution, right_hand_side, preconditioner); </div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step() </div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl; </div><div class="line">} </div></div><!-- fragment --><p>我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由 <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> 类完成的，它计算近似梯度的方式类似于本教程 <a class="el" href="step_9.html">step-9</a> 中描述的 <code>GradientEstimation</code> 。事实上， <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> 类是在 <a class="el" href="step_9.html">step-9</a> 的 <code>GradientEstimation</code> 类之后开发的。与 <a class="el" href="step_9.html">step-9</a> 中的讨论相关，这里我们考虑 \(h^{1+d/2}|\nabla_h u_h|\) 。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在 \(H^2\) 中，而只在 \(H^1\) 中（或者，更准确地说：在 \(H^1_\beta\) 中，即在方向 \(\beta\) 上的导数是可平方整除的函数空间）。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid() </div><div class="line">{ </div></div><!-- fragment --><p><code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> 类将梯度计算为浮点精度。这已经足够了，因为它们是近似的，只作为细化指标。</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div></div><!-- fragment --><p>现在，近似梯度被计算出来了</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping, </div><div class="line">                                              dof_handler, </div><div class="line">                                              solution, </div><div class="line">                                              gradient_indicator); </div></div><!-- fragment --><p>并且它们的单元格按系数 \(h^{1+d/2}\) 进行缩放。</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0; </div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators()) </div><div class="line">  gradient_indicator(cell_no++) *= </div><div class="line">    <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2); </div></div><!-- fragment --><p>最后它们作为细化指标。</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation, </div><div class="line">                                                  gradient_indicator, </div><div class="line">                                                  0.3, </div><div class="line">                                                  0.1); </div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>(); </div><div class="line">} </div></div><!-- fragment --><p>这个程序的输出包括一个自适应细化网格的vtk文件和数值解。最后，我们还用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. 计算了解的L-无穷大规范。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>; </div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl; </div><div class="line">  std::ofstream output(filename); </div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);  </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>); </div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping); </div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output); </div><div class="line"></div><div class="line">  { </div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping, </div><div class="line">                                      dof_handler, </div><div class="line">                                      solution, </div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                      values, </div><div class="line">                                      quadrature, </div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>); </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty = </div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation, </div><div class="line">                                        values,  </div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>); </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl; </div><div class="line">  } </div><div class="line">} </div></div><!-- fragment --><p>下面的 <code>run</code> 函数与前面的例子类似。</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>() </div><div class="line">  { </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle) </div><div class="line">      {  </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0) </div><div class="line">          { </div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation); </div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3); </div><div class="line">          } </div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">          refine_grid(); </div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span> </div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        setup_system(); </div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs() </div><div class="line">                  &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        assemble_system(); </div><div class="line">        solve(); </div><div class="line"></div><div class="line">        output_results(cycle); </div><div class="line">      } </div><div class="line">  } </div><div class="line">} <span class="comment">// namespace Step12 </span></div></div><!-- fragment --><p>下面的 <code>main</code> 函数与前面的例子也类似，不需要注释。</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() </div><div class="line">{ </div><div class="line">  <span class="keywordflow">try</span> </div><div class="line">    { </div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod; </div><div class="line">      dgmethod.run(); </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (...) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">} </div></div><!-- fragment --><p> examples/step-12/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个程序的输出包括控制台输出和vtk格式的解决方案。</p>
<div class="fragment"><div class="line">Cycle 0</div><div class="line">  Number of active cells:       64</div><div class="line">  Number of degrees of freedom: 256</div><div class="line">  Solver converged in 4 iterations.</div><div class="line">  Writing solution to &lt;solution-0.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09057</div><div class="line">Cycle 1</div><div class="line">  Number of active cells:       112</div><div class="line">  Number of degrees of freedom: 448</div><div class="line">  Solver converged in 9 iterations.</div><div class="line">  Writing solution to &lt;solution-1.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.10402</div><div class="line">Cycle 2</div><div class="line">  Number of active cells:       214</div><div class="line">  Number of degrees of freedom: 856</div><div class="line">  Solver converged in 16 iterations.</div><div class="line">  Writing solution to &lt;solution-2.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09813</div><div class="line">Cycle 3</div><div class="line">  Number of active cells:       415</div><div class="line">  Number of degrees of freedom: 1660</div><div class="line">  Solver converged in 26 iterations.</div><div class="line">  Writing solution to &lt;solution-3.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09579</div><div class="line">Cycle 4</div><div class="line">  Number of active cells:       796</div><div class="line">  Number of degrees of freedom: 3184</div><div class="line">  Solver converged in 44 iterations.</div><div class="line">  Writing solution to &lt;solution-4.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09612</div><div class="line">Cycle 5</div><div class="line">  Number of active cells:       1561</div><div class="line">  Number of degrees of freedom: 6244</div><div class="line">  Solver converged in 81 iterations.</div><div class="line">  Writing solution to &lt;solution-5.vtk&gt;</div></div><!-- fragment --><p>我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-0.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-2.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5.png"/>
</div>
<p> 。</p>
<p>最后我们展示一个3D计算的图。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5-3d.png"/>
</div>
<p><a class="anchor" id="dg-vs-cg"></a></p>
<p><a class="anchor" id="Whyusediscontinuouselements"></a></p><h3>Why use discontinuous elements</h3>
<p>在这个程序中，我们使用了不连续的元素。这是一个合理的问题，为什么不简单地使用正常的、连续的元素呢？当然，对于每个有数值方法背景的人来说，答案是显而易见的：连续Galerkin（cG）方法对于输运方程是不稳定的，除非特别添加稳定项。然而，DG方法<em>is</em>则是稳定的。用目前的程序来说明这一点并不十分困难；事实上，只需要做以下的小修改就可以了。</p>
<ul>
<li>将该元素改为FE_Q，而不是FE_DGQ。</li>
<li>以与步骤6完全相同的方式增加对悬挂节点约束的处理。</li>
<li>我们需要一个不同的求解器；步骤29中的直接求解器是一个方便的选择。一个有经验的deal.II用户将能够在10分钟内完成这一工作。</li>
</ul>
<p>虽然上面显示了二维解决方案，在界面上含有一些小的尖峰，但是在网格细化的情况下，这些尖峰的高度是稳定的，当使用连续元素时，结果看起来有很大不同。</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-0.png"/>
</div>
  </td><td valign="top">1 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-1.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">2 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-2.png"/>
</div>
  </td><td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-3.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">4 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-4.png"/>
</div>
  </td><td valign="top">5 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-5.png"/>
</div>
   </td></tr>
</table>
<p>在细化迭代5中，图像不能再以合理的方式绘制成三维图。因此我们展示了一个范围为 \([-1,2]\) 的彩色图（当然，精确解的解值位于 \([0,1]\) ）。在任何情况下，很明显，连续Galerkin解表现出振荡行为，随着网格的细化越来越差。</p>
<p>如果出于某种原因想使用连续元素，有很多策略可以稳定cG方法。讨论这些方法超出了本教程程序的范围；例如，感兴趣的读者可以看看步骤31。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>鉴于在这种情况下确切的解是已知的，进一步扩展的一个有趣的途径是确认这个程序的收敛顺序。在目前的情况下，解是非光滑的，因此我们不能期望得到特别高的收敛阶，即使我们使用高阶元素。但是，即使解<em>is</em>光滑，方程也不是椭圆的，因此，我们应该得到等于最优插值估计的收敛阶，这一点并不明显（例如，我们通过使用二次元会得到 \(h^3\) 在 \(L^2\) 准则下的收敛）。</p>
<p>事实上，对于双曲方程来说，理论预测常常表明，我们所能希望的最好结果是比插值估计值低二分之一的阶。例如，对于流线扩散法（此处用于稳定传输方程解的DG法的替代方法），可以证明对于度数为 \(p\) 的元素，在任意网格上的收敛阶为 \(p+\frac 12\) 。虽然在均匀细化的网格上观察到的顺序经常是 \(p+1\) ，但人们可以构建所谓的彼得森网格，在这些网格上实际上达到了更差的理论约束。这应该是比较容易验证的，例如使用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> 函数。</p>
<p>一个不同的方向是观察运输问题的解决经常有不连续性，因此，我们<em>bisect</em>在每个坐标方向上的每个单元的网格可能不是最佳的。相反，一个更好的策略是只在平行于不连续的方向上切割单元。这被称为<em>anisotropic mesh refinement</em>，是步骤30的主题。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* --------------------------------------------------------------------- </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * This file is part of the deal.II library. </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute </span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General </span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either </span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version. </span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at </span></div><div class="line"><span class="comment"> * the top level directory of deal.II. </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * --------------------------------------------------------------------- </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Author: Guido Kanschat, Texas A&amp;M University, 2009 </span></div><div class="line"><span class="comment"> *         Timo Heister, Clemson University, 2019 </span></div><div class="line"><span class="comment"> */</span> </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12 </div><div class="line">{ </div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    BoundaryValues() = <span class="keywordflow">default</span>; </div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points, </div><div class="line">                            std::vector&lt;double&gt; &amp;          values, </div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points, </div><div class="line">                                       std::vector&lt;double&gt; &amp;          values, </div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{  </div><div class="line">    (void)component; </div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1); </div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(), </div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size())); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)  </div><div class="line">          values[i] = 1.; </div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">          values[i] = 0.; </div><div class="line">      } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) </div><div class="line">  { </div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()); </div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field; </div><div class="line">    wind_field[0] = -p[1]; </div><div class="line">    wind_field[1] = p[0]; </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10) </div><div class="line">      wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>(); </div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> wind_field; </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">struct </span>ScratchData </div><div class="line">  { </div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping, </div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe, </div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature, </div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face, </div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | </div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>, </div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags = </div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>) </div><div class="line">      : fe_values(mapping, fe, quadrature, update_flags) </div><div class="line">      , fe_interface_values(mapping, </div><div class="line">                            fe, </div><div class="line">                            quadrature_face, </div><div class="line">                            interface_update_flags) </div><div class="line">    {} </div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data) </div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(), </div><div class="line">                  scratch_data.fe_values.get_fe(), </div><div class="line">                  scratch_data.fe_values.get_quadrature(), </div><div class="line">                  scratch_data.fe_values.get_update_flags()) </div><div class="line">      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(), </div><div class="line">                            scratch_data.fe_interface_values.get_fe(), </div><div class="line">                            scratch_data.fe_interface_values.get_quadrature(), </div><div class="line">                            scratch_data.fe_interface_values.get_update_flags()) </div><div class="line">    {} </div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values; </div><div class="line">    <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values; </div><div class="line">  }; </div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyDataFace </div><div class="line">  { </div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>; </div><div class="line">    std::vector&lt;types::global_dof_index&gt; joint_dof_indices; </div><div class="line">  }; </div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData </div><div class="line">  { </div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>; </div><div class="line">    Vector&lt;double&gt;                       cell_rhs; </div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices; </div><div class="line">    std::vector&lt;CopyDataFace&gt;            face_data; </div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt; </div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell) </div><div class="line">    { </div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell); </div><div class="line">      cell_rhs.reinit(dofs_per_cell); </div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell); </div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line">    } </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>AdvectionProblem </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    AdvectionProblem(); </div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(); </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line">    <span class="keywordtype">void</span> setup_system(); </div><div class="line">    <span class="keywordtype">void</span> assemble_system(); </div><div class="line">    <span class="keywordtype">void</span> solve(); </div><div class="line">    <span class="keywordtype">void</span> refine_grid(); </div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>; </div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>; </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe; </div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature; </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face; </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern; </div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix; </div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution; </div><div class="line">    Vector&lt;double&gt; right_hand_side; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem() </div><div class="line">    : mapping() </div><div class="line">    , fe(1) </div><div class="line">    , dof_handler(triangulation) </div><div class="line">    , quadrature(fe.tensor_degree() + 1) </div><div class="line">    , quadrature_face(fe.tensor_degree() + 1) </div><div class="line">  {} </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system() </div><div class="line">  { </div><div class="line"></div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe); </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs()); </div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp); </div><div class="line">    sparsity_pattern.copy_from(dsp); </div><div class="line"></div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern); </div><div class="line">    solution.reinit(dof_handler.n_dofs()); </div><div class="line">    right_hand_side.reinit(dof_handler.n_dofs()); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system() </div><div class="line">  { </div><div class="line">    <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>; </div><div class="line">    <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell, </div><div class="line">                                 ScratchData&lt;dim&gt; &amp;scratch_data, </div><div class="line">                                 CopyData &amp;        copy_data) { </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs = </div><div class="line">        scratch_data.fe_values.get_fe().n_dofs_per_cell(); </div><div class="line">      copy_data.reinit(cell, n_dofs); </div><div class="line">      scratch_data.fe_values.reinit(cell); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points(); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values; </div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>(); </div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) </div><div class="line">        { </div><div class="line">          <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]); </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i) </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j) </div><div class="line">              { </div><div class="line">                copy_data.cell_matrix(i, j) += </div><div class="line">                  -beta_q                      <span class="comment">// -\beta </span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i </span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j </span></div><div class="line">                  * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx </span></div><div class="line">              } </div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell, </div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no, </div><div class="line">                                     ScratchData&lt;dim&gt; &amp;  scratch_data, </div><div class="line">                                     CopyData &amp;          copy_data) { </div><div class="line">      scratch_data.fe_interface_values.reinit(cell, face_no); </div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face = </div><div class="line">        scratch_data.fe_interface_values.get_fe_face_values(0); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); </div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>(); </div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>(); </div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(q_points.size()); </div><div class="line">      boundary_function.value_list(q_points, g); </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; </div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (beta_dot_n &gt; 0) </div><div class="line">            { </div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i) </div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j) </div><div class="line">                  copy_data.cell_matrix(i, j) += </div><div class="line">                    fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i </span></div><div class="line">                    * fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j </span></div><div class="line">                    * beta_dot_n                    <span class="comment">// \beta . n </span></div><div class="line">                    * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx </span></div><div class="line">            } </div><div class="line">          <span class="keywordflow">else</span> </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i) </div><div class="line">              copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i </span></div><div class="line">                                       * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g </span></div><div class="line">                                       * beta_dot_n  <span class="comment">// \beta . n </span></div><div class="line">                                       * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx </span></div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell, </div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f, </div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf, </div><div class="line">                                 <span class="keyword">const</span> Iterator &amp;    ncell, </div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf, </div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf, </div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data, </div><div class="line">                                 CopyData &amp;          copy_data) { </div><div class="line">      <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values; </div><div class="line">      fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf); </div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>(); </div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back(); </div><div class="line">      CopyDataFace &amp;copy_data_face = copy_data.face_data.back(); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>(); </div><div class="line">      copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>(); </div><div class="line"></div><div class="line">      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>(); </div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>(); </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint]; </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i) </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j) </div><div class="line">              copy_data_face.cell_matrix(i, j) +=  </div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i] </span></div><div class="line">                * </div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind} </span></div><div class="line">                * beta_dot_n                                   <span class="comment">// (\beta . n) </span></div><div class="line">                * JxW[qpoint];                                 <span class="comment">// dx </span></div><div class="line">        }  </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) { </div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix, </div><div class="line">                                             c.cell_rhs, </div><div class="line">                                             c.local_dof_indices, </div><div class="line">                                             system_matrix, </div><div class="line">                                             right_hand_side); </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data) </div><div class="line">        { </div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix, </div><div class="line">                                                 cdf.joint_dof_indices, </div><div class="line">                                                 system_matrix); </div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face); </div><div class="line">    CopyData         copy_data; </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(), </div><div class="line">                          dof_handler.end(), </div><div class="line">                          cell_worker, </div><div class="line">                          copier, </div><div class="line">                          scratch_data, </div><div class="line">                          copy_data, </div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> | </div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> | </div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>, </div><div class="line">                          boundary_worker, </div><div class="line">                          face_worker); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve() </div><div class="line">  { </div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12); </div><div class="line">    <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control); </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner; </div><div class="line"></div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>()); </div><div class="line"></div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, right_hand_side, preconditioner); </div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step() </div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl; </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid() </div><div class="line">  { </div><div class="line"></div><div class="line"></div><div class="line">    Vector&lt;float&gt; gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping, </div><div class="line">                                                  dof_handler, </div><div class="line">                                                  solution, </div><div class="line">                                                  gradient_indicator); </div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0; </div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators()) </div><div class="line">      gradient_indicator(cell_no++) *= </div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2); </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation, </div><div class="line">                                                    gradient_indicator, </div><div class="line">                                                    0.3, </div><div class="line">                                                    0.1); </div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>(); </div><div class="line">  } </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>; </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl; </div><div class="line">    std::ofstream output(filename); </div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; </div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);  </div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>); </div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping); </div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output); </div><div class="line"></div><div class="line">    { </div><div class="line">      Vector&lt;float&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping, </div><div class="line">                                        dof_handler, </div><div class="line">                                        solution, </div><div class="line">                                        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                        values, </div><div class="line">                                        quadrature, </div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>); </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty = </div><div class="line">        <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation, </div><div class="line">                                          values,  </div><div class="line">                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>); </div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl; </div><div class="line">    } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>() </div><div class="line">  { </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle) </div><div class="line">      {  </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0) </div><div class="line">          { </div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation); </div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3); </div><div class="line">          } </div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">          refine_grid(); </div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span> </div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        setup_system(); </div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs() </div><div class="line">                  &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        assemble_system(); </div><div class="line">        solve(); </div><div class="line"></div><div class="line">        output_results(cycle); </div><div class="line">      } </div><div class="line">  } </div><div class="line">} <span class="comment">// namespace Step12 </span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() </div><div class="line">{ </div><div class="line">  <span class="keywordflow">try</span> </div><div class="line">    { </div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod; </div><div class="line">      dgmethod.run(); </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (...) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">} </div><div class="line"></div><div class="line"></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
