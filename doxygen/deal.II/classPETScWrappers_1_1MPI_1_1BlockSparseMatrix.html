<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::MPI::BlockSparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MPI::BlockSparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__block__sparse__matrix_8h_source.html">deal.II/lac/petsc_block_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MPI::BlockSparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix__inherit__graph.svg" width="383" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade4118d440380e83038aa30fe8006813"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ade4118d440380e83038aa30fe8006813">BaseClass</a> = <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td></tr>
<tr class="separator:ade4118d440380e83038aa30fe8006813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3749d356343dcef47f6981de8bd4d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a> = <a class="el" href="classBlockMatrixBase.html#a11eb26331dcea2cd7095abf2a7182f87">BaseClass::BlockType</a></td></tr>
<tr class="separator:aaa3749d356343dcef47f6981de8bd4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba37cb0601d734660b7c351646685d7b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> = <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">BaseClass::value_type</a></td></tr>
<tr class="separator:aba37cb0601d734660b7c351646685d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878af45706f93d6f694c1e920773f93f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a878af45706f93d6f694c1e920773f93f">pointer</a> = <a class="el" href="classBlockMatrixBase.html#ae305c4e1fdaf318cd3dfdce7ff5d4fbf">BaseClass::pointer</a></td></tr>
<tr class="separator:a878af45706f93d6f694c1e920773f93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92534f0a1fd029166fbb78c15cc15a6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a92534f0a1fd029166fbb78c15cc15a6f">const_pointer</a> = <a class="el" href="classBlockMatrixBase.html#a7c4888a73231c2eff68d01e6ecc6e975">BaseClass::const_pointer</a></td></tr>
<tr class="separator:a92534f0a1fd029166fbb78c15cc15a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa5d25ba37a80fbe5d74094193b129"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a18aa5d25ba37a80fbe5d74094193b129">reference</a> = <a class="el" href="classBlockMatrixBase.html#a026a82c1fb4827731009779a8e679963">BaseClass::reference</a></td></tr>
<tr class="separator:a18aa5d25ba37a80fbe5d74094193b129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03603b5a886dcd734f27f5d28859e2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ae03603b5a886dcd734f27f5d28859e2c">const_reference</a> = <a class="el" href="classBlockMatrixBase.html#a1f04c58b85ae49f430354a71b525e533">BaseClass::const_reference</a></td></tr>
<tr class="separator:ae03603b5a886dcd734f27f5d28859e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4459b251139d45f979377f3937f7266f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> = <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">BaseClass::size_type</a></td></tr>
<tr class="separator:a4459b251139d45f979377f3937f7266f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c619d491397ad3d0ff5a5d80815064"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a> = <a class="el" href="classBlockMatrixBase.html#a9676f6127d493633bb4b66ee1952ad24">BaseClass::iterator</a></td></tr>
<tr class="separator:a87c619d491397ad3d0ff5a5d80815064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3608c60f37d6e2ec541caef93e886a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a> = <a class="el" href="classBlockMatrixBase.html#a3318caa7ab0c4b2eb257cfb99daa5429">BaseClass::const_iterator</a></td></tr>
<tr class="separator:aab3608c60f37d6e2ec541caef93e886a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a45f953f5baee30434449e1f8e9c9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> &gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a></td></tr>
<tr class="separator:aa3a45f953f5baee30434449e1f8e9c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0d1da8d9b58a69b543612bcae2e6050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#af0d1da8d9b58a69b543612bcae2e6050">BlockSparseMatrix</a> ()=default</td></tr>
<tr class="separator:af0d1da8d9b58a69b543612bcae2e6050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac28906675796dc4a0cce7978690e122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aac28906675796dc4a0cce7978690e122">~BlockSparseMatrix</a> () override=default</td></tr>
<tr class="separator:aac28906675796dc4a0cce7978690e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768f82745f771a3615c885409a985295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a768f82745f771a3615c885409a985295">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a> &amp;)</td></tr>
<tr class="separator:a768f82745f771a3615c885409a985295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf71e633299538f6433616e77f705e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#acf71e633299538f6433616e77f705e63">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:acf71e633299538f6433616e77f705e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ae01f6a8df5bc82ec8f65b1c472219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a33ae01f6a8df5bc82ec8f65b1c472219">reinit</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> <a class="el" href="classBlockMatrixBase.html#a2478164707bf2932ad32ddd27babfc00">n_block_rows</a>, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> n_block_columns)</td></tr>
<tr class="separator:a33ae01f6a8df5bc82ec8f65b1c472219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc259ab453f20839a7a9261adefaecd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#abc259ab453f20839a7a9261adefaecd5">reinit</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;rows, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;cols, const <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;bdsp, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;com)</td></tr>
<tr class="separator:abc259ab453f20839a7a9261adefaecd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d521feeceef075838a60dc94f329a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aa1d521feeceef075838a60dc94f329a1">reinit</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;sizes, const <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;bdsp, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;com)</td></tr>
<tr class="separator:aa1d521feeceef075838a60dc94f329a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3506ef24b261c12293599e4a9c47ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a3f3506ef24b261c12293599e4a9c47ae">vmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;src) const</td></tr>
<tr class="separator:a3f3506ef24b261c12293599e4a9c47ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f74e6e9ebef8c10748a55a1120fc15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ad8f74e6e9ebef8c10748a55a1120fc15">vmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;src) const</td></tr>
<tr class="separator:ad8f74e6e9ebef8c10748a55a1120fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7626baf09f92854eba9e3a4e8a87bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a9c7626baf09f92854eba9e3a4e8a87bf">vmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;src) const</td></tr>
<tr class="separator:a9c7626baf09f92854eba9e3a4e8a87bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e849cb0f0d53a27eebad2f70afbb9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a7e849cb0f0d53a27eebad2f70afbb9ef">vmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;src) const</td></tr>
<tr class="separator:a7e849cb0f0d53a27eebad2f70afbb9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1025b10f63c69f3e9b9ad7738e37c55b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a1025b10f63c69f3e9b9ad7738e37c55b">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;src) const</td></tr>
<tr class="separator:a1025b10f63c69f3e9b9ad7738e37c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed644062e23218a84153ab9bf653e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a7ed644062e23218a84153ab9bf653e77">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;src) const</td></tr>
<tr class="separator:a7ed644062e23218a84153ab9bf653e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11e1a578c61c0ef58457951a0d3eb9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ab11e1a578c61c0ef58457951a0d3eb9d">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;src) const</td></tr>
<tr class="separator:ab11e1a578c61c0ef58457951a0d3eb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4b4f5d0655d6603ddc0a9e4b466543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#acb4b4f5d0655d6603ddc0a9e4b466543">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;src) const</td></tr>
<tr class="separator:acb4b4f5d0655d6603ddc0a9e4b466543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42c718e89670e10f68a14279244e43f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ae42c718e89670e10f68a14279244e43f">collect_sizes</a> ()</td></tr>
<tr class="separator:ae42c718e89670e10f68a14279244e43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaace33a3a780113892827537f6a69b2e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaace33a3a780113892827537f6a69b2e">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:aaace33a3a780113892827537f6a69b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26513a0e6d6666ecece85e649d4f687"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ac26513a0e6d6666ecece85e649d4f687">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:ac26513a0e6d6666ecece85e649d4f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05bb6e490e39a67f79f6a798a2f69ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ac05bb6e490e39a67f79f6a798a2f69ca">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:ac05bb6e490e39a67f79f6a798a2f69ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60e3f81c6bacc4202f4dd951514f616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac60e3f81c6bacc4202f4dd951514f616">copy_from</a> (const BlockMatrixType &amp;source)</td></tr>
<tr class="separator:ac60e3f81c6bacc4202f4dd951514f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column)</td></tr>
<tr class="separator:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee186fad06d29d6670f241298f43faae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aee186fad06d29d6670f241298f43faae">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column) const</td></tr>
<tr class="separator:aee186fad06d29d6670f241298f43faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c51896e8656797b2086bbdfb59506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab46c51896e8656797b2086bbdfb59506">m</a> () const</td></tr>
<tr class="separator:ab46c51896e8656797b2086bbdfb59506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bb440e54c21af96dcb43fd41958a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78bb440e54c21af96dcb43fd41958a05">n</a> () const</td></tr>
<tr class="separator:a78bb440e54c21af96dcb43fd41958a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478164707bf2932ad32ddd27babfc00"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2478164707bf2932ad32ddd27babfc00">n_block_rows</a> () const</td></tr>
<tr class="separator:a2478164707bf2932ad32ddd27babfc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8a7553aacb22087640d6543a352637"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a7b8a7553aacb22087640d6543a352637">n_block_cols</a> () const</td></tr>
<tr class="separator:a7b8a7553aacb22087640d6543a352637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9784ec81d727db00f7dbfdc9859ee029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9784ec81d727db00f7dbfdc9859ee029">set</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> j, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> value)</td></tr>
<tr class="separator:a9784ec81d727db00f7dbfdc9859ee029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac6afa3a2f54b3a76ef38d8883d55a104">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4af16696853c4a9463031fabe748a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afd4af16696853c4a9463031fabe748a7">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd4af16696853c4a9463031fabe748a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f8f8fd5343815c3f7586478f3226d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc0f8f8fd5343815c3f7586478f3226d">set</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:adc0f8f8fd5343815c3f7586478f3226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78136f111eaa3f476a1981528be0d1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78136f111eaa3f476a1981528be0d1bd">set</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a78136f111eaa3f476a1981528be0d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> j, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> value)</td></tr>
<tr class="separator:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec5bc680c14603ef59da590d0db0f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#acec5bc680c14603ef59da590d0db0f4a">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:acec5bc680c14603ef59da590d0db0f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254582e171452592759674d9074e1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0254582e171452592759674d9074e1b7">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a0254582e171452592759674d9074e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b25e1191e6a59ec8885912e50bd686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a00b25e1191e6a59ec8885912e50bd686">add</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a00b25e1191e6a59ec8885912e50bd686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c963b73dfee26bb1160755b40aad8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a02c963b73dfee26bb1160755b40aad8d">add</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a02c963b73dfee26bb1160755b40aad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9ee9987ece33a052d2b7a44034a8a01a">add</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> factor, const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &gt; &amp;matrix)</td></tr>
<tr class="separator:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29846f2e327eb1252f8bcea47494f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2a29846f2e327eb1252f8bcea47494f7">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> j) const</td></tr>
<tr class="separator:a2a29846f2e327eb1252f8bcea47494f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133093964e34c80a89b8e494f32ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a32133093964e34c80a89b8e494f32ff2">el</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> j) const</td></tr>
<tr class="separator:a32133093964e34c80a89b8e494f32ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6afe454cf2282f21d1230ad74bcde2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc6afe454cf2282f21d1230ad74bcde2">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> i) const</td></tr>
<tr class="separator:adc6afe454cf2282f21d1230ad74bcde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74954a421ab950fef132131c2eb6b5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a74954a421ab950fef132131c2eb6b5f9">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a74954a421ab950fef132131c2eb6b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2190cc18dbc94dfb98d99d1d62ef4fb5">operator*=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> factor)</td></tr>
<tr class="separator:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e772b9ccf9ea814802a81948190517f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5e772b9ccf9ea814802a81948190517f">operator/=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> factor)</td></tr>
<tr class="separator:a5e772b9ccf9ea814802a81948190517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69dc529dec11d15c40904ef729ad25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5b69dc529dec11d15c40904ef729ad25">vmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a5b69dc529dec11d15c40904ef729ad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f2265bcb165f5b9016787d62c8d1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a657f2265bcb165f5b9016787d62c8d1a">Tvmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a657f2265bcb165f5b9016787d62c8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194567f1611984e0ffbd0a2967f94bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a194567f1611984e0ffbd0a2967f94bd9">matrix_norm_square</a> (const BlockVectorType &amp;v) const</td></tr>
<tr class="separator:a194567f1611984e0ffbd0a2967f94bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40df5806b5d3cc3f19a31a7e11b36f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a40df5806b5d3cc3f19a31a7e11b36f51">frobenius_norm</a> () const</td></tr>
<tr class="separator:a40df5806b5d3cc3f19a31a7e11b36f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d63be4e435be84abbdd0eff9c8fa7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab9d63be4e435be84abbdd0eff9c8fa7a">matrix_scalar_product</a> (const BlockVectorType &amp;u, const BlockVectorType &amp;v) const</td></tr>
<tr class="separator:ab9d63be4e435be84abbdd0eff9c8fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754a13320e96366f2b5b4269a232767b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a754a13320e96366f2b5b4269a232767b">residual</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;x, const BlockVectorType &amp;b) const</td></tr>
<tr class="separator:a754a13320e96366f2b5b4269a232767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a345092f0dea627d1b250fe51f3da6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0a345092f0dea627d1b250fe51f3da6c">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a0a345092f0dea627d1b250fe51f3da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80251837872592496f08d63deb87cd0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a80251837872592496f08d63deb87cd0c">begin</a> ()</td></tr>
<tr class="separator:a80251837872592496f08d63deb87cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed413af2409b398fd003acf6a33f351e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed413af2409b398fd003acf6a33f351e">begin</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> r)</td></tr>
<tr class="separator:aed413af2409b398fd003acf6a33f351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1f6468acb2728b28ed5fad880436c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3dd1f6468acb2728b28ed5fad880436c">begin</a> () const</td></tr>
<tr class="separator:a3dd1f6468acb2728b28ed5fad880436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bd8ac7f288e11fbb9a15fcf7fa0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed8bd8ac7f288e11fbb9a15fcf7fa0af">begin</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> r) const</td></tr>
<tr class="separator:aed8bd8ac7f288e11fbb9a15fcf7fa0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969257f13a198e3b39372c513d3dc5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a969257f13a198e3b39372c513d3dc5aa">end</a> ()</td></tr>
<tr class="separator:a969257f13a198e3b39372c513d3dc5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9494559d41237c44b235153035bcce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af9494559d41237c44b235153035bcce4">end</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> r)</td></tr>
<tr class="separator:af9494559d41237c44b235153035bcce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f188b3a4f6540c5d8ecde61b31ade05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0f188b3a4f6540c5d8ecde61b31ade05">end</a> () const</td></tr>
<tr class="separator:a0f188b3a4f6540c5d8ecde61b31ade05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa28a3d5286822c32a3f7ef7437e730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afa28a3d5286822c32a3f7ef7437e730d">end</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> r) const</td></tr>
<tr class="separator:afa28a3d5286822c32a3f7ef7437e730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa06c2fc3d4a49502844155f66078bf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aaa06c2fc3d4a49502844155f66078bf0">get_row_indices</a> () const</td></tr>
<tr class="separator:aaa06c2fc3d4a49502844155f66078bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe907561eea46905c41c3e0efd53cd0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afe907561eea46905c41c3e0efd53cd0e">get_column_indices</a> () const</td></tr>
<tr class="separator:afe907561eea46905c41c3e0efd53cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0ef9c39b0f6e1e5f69ca8eb58e9ac9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9e0ef9c39b0f6e1e5f69ca8eb58e9ac9">memory_consumption</a> () const</td></tr>
<tr class="separator:a9e0ef9c39b0f6e1e5f69ca8eb58e9ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4041ccf8874d3ff3894e2c5e738d769a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4041ccf8874d3ff3894e2c5e738d769a">DeclException4</a> (ExcIncompatibleRowNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt; ','&lt;&lt; arg4&lt;&lt; &quot;] have differing row numbers.&quot;)</td></tr>
<tr class="separator:ga4041ccf8874d3ff3894e2c5e738d769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f7d355e1a8b4ca45e2f30b3ba48916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga10f7d355e1a8b4ca45e2f30b3ba48916">DeclException4</a> (ExcIncompatibleColNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt; ','&lt;&lt; arg4&lt;&lt; &quot;] have differing column numbers.&quot;)</td></tr>
<tr class="separator:ga10f7d355e1a8b4ca45e2f30b3ba48916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2c94c4773a37d8672d23ca782bd50234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2c94c4773a37d8672d23ca782bd50234">clear</a> ()</td></tr>
<tr class="separator:a2c94c4773a37d8672d23ca782bd50234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4109f58621de12f02b521df0bbb4728f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a4109f58621de12f02b521df0bbb4728f">vmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a4109f58621de12f02b521df0bbb4728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd4c9d2a02835be4a0e7fdb9c5fb84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adfd4c9d2a02835be4a0e7fdb9c5fb84b">vmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:adfd4c9d2a02835be4a0e7fdb9c5fb84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70152dd877ead20e92468b11dd923fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a70152dd877ead20e92468b11dd923fdb">vmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a70152dd877ead20e92468b11dd923fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f20e2d1a54fa9cc7e312175f23101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a003f20e2d1a54fa9cc7e312175f23101">vmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a003f20e2d1a54fa9cc7e312175f23101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e896a6aadc0f6663ca4bfd69e8e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1b5e896a6aadc0f6663ca4bfd69e8e73">Tvmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a1b5e896a6aadc0f6663ca4bfd69e8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f970e6afe14484f051897f5c78060f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af6f970e6afe14484f051897f5c78060f">Tvmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:af6f970e6afe14484f051897f5c78060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20df57e0ac765128dfaa48add407e490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a20df57e0ac765128dfaa48add407e490">Tvmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a20df57e0ac765128dfaa48add407e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002a305f47b31aa962b58f6a863f831d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a002a305f47b31aa962b58f6a863f831d">Tvmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a002a305f47b31aa962b58f6a863f831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f52ce530c3028e0d3194a719cb82576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6f52ce530c3028e0d3194a719cb82576">prepare_add_operation</a> ()</td></tr>
<tr class="separator:a6f52ce530c3028e0d3194a719cb82576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d3d021b1004a8fb027b50e0862c149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a79d3d021b1004a8fb027b50e0862c149">prepare_set_operation</a> ()</td></tr>
<tr class="separator:a79d3d021b1004a8fb027b50e0862c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa401f344887a4647a9a14ef41629aed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa401f344887a4647a9a14ef41629aed9">row_block_indices</a></td></tr>
<tr class="separator:aa401f344887a4647a9a14ef41629aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a10666cbe2741f71f6cf17ebedaf9080d">column_block_indices</a></td></tr>
<tr class="separator:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352220e7e9c26aaffd42bce3b2f25b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6352220e7e9c26aaffd42bce3b2f25b4">sub_objects</a></td></tr>
<tr class="separator:a6352220e7e9c26aaffd42bce3b2f25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>基于 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> 类的阻塞式稀疏矩阵。这个类实现了封锁稀疏矩阵的PETSc SparseMatrix基对象所特有的函数，并将实际工作中对各个块的大部分调用留给基类中实现的函数。关于这个类何时有用的描述，也请参见这里。 与deal.II-type SparseMatrix类相比，PETSc矩阵没有外部对象来表示稀疏性模式。因此，我们不能通过附加一个块状稀疏模式来确定这种类型的块状矩阵的各个块的大小，而是通过调用 <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a33ae01f6a8df5bc82ec8f65b1c472219">reinit()</a> 来设置块的数量，然后分别设置每个块的大小。为了固定块矩阵的数据结构，有必要让它知道我们已经改变了基础矩阵的大小。为此，我们必须调用collect_sizes()函数，其原因与BlockSparsityPattern类所记载的大致相同。 @ @ "" </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00057">57</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ade4118d440380e83038aa30fe8006813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4118d440380e83038aa30fe8006813">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ade4118d440380e83038aa30fe8006813">PETScWrappers::MPI::BlockSparseMatrix::BaseClass</a> =  <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对基类进行类型化定义，以便更简单地访问它自己的别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00064">64</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aaa3749d356343dcef47f6981de8bd4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3749d356343dcef47f6981de8bd4d2">&#9670;&nbsp;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">PETScWrappers::MPI::BlockSparseMatrix::BlockType</a> =  <a class="el" href="classBlockMatrixBase.html#a11eb26331dcea2cd7095abf2a7182f87">BaseClass::BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对底层矩阵的类型进行类型化定义。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00070">70</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aba37cb0601d734660b7c351646685d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba37cb0601d734660b7c351646685d7b">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">PETScWrappers::MPI::BlockSparseMatrix::value_type</a> =  <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从基类中导入别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00076">76</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a878af45706f93d6f694c1e920773f93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878af45706f93d6f694c1e920773f93f">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a878af45706f93d6f694c1e920773f93f">PETScWrappers::MPI::BlockSparseMatrix::pointer</a> =  <a class="el" href="classBlockMatrixBase.html#ae305c4e1fdaf318cd3dfdce7ff5d4fbf">BaseClass::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00077">77</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a92534f0a1fd029166fbb78c15cc15a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92534f0a1fd029166fbb78c15cc15a6f">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a92534f0a1fd029166fbb78c15cc15a6f">PETScWrappers::MPI::BlockSparseMatrix::const_pointer</a> =  <a class="el" href="classBlockMatrixBase.html#a7c4888a73231c2eff68d01e6ecc6e975">BaseClass::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00078">78</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a18aa5d25ba37a80fbe5d74094193b129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18aa5d25ba37a80fbe5d74094193b129">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a18aa5d25ba37a80fbe5d74094193b129">PETScWrappers::MPI::BlockSparseMatrix::reference</a> =  <a class="el" href="classBlockMatrixBase.html#a026a82c1fb4827731009779a8e679963">BaseClass::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00079">79</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae03603b5a886dcd734f27f5d28859e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03603b5a886dcd734f27f5d28859e2c">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#ae03603b5a886dcd734f27f5d28859e2c">PETScWrappers::MPI::BlockSparseMatrix::const_reference</a> =  <a class="el" href="classBlockMatrixBase.html#a1f04c58b85ae49f430354a71b525e533">BaseClass::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00080">80</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a4459b251139d45f979377f3937f7266f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4459b251139d45f979377f3937f7266f">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">PETScWrappers::MPI::BlockSparseMatrix::size_type</a> =  <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">BaseClass::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00081">81</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a87c619d491397ad3d0ff5a5d80815064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c619d491397ad3d0ff5a5d80815064">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">PETScWrappers::MPI::BlockSparseMatrix::iterator</a> =  <a class="el" href="classBlockMatrixBase.html#a9676f6127d493633bb4b66ee1952ad24">BaseClass::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00082">82</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aab3608c60f37d6e2ec541caef93e886a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3608c60f37d6e2ec541caef93e886a">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">PETScWrappers::MPI::BlockSparseMatrix::const_iterator</a> =  <a class="el" href="classBlockMatrixBase.html#a3318caa7ab0c4b2eb257cfb99daa5429">BaseClass::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00083">83</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa3a45f953f5baee30434449e1f8e9c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a45f953f5baee30434449e1f8e9c9d">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a>&gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00363">363</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0d1da8d9b58a69b543612bcae2e6050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d1da8d9b58a69b543612bcae2e6050">&#9670;&nbsp;</a></span>BlockSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MPI::BlockSparseMatrix::BlockSparseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数；将矩阵初始化为空，没有任何结构，也就是说，矩阵根本无法使用。因此，这个构造函数只对作为类的成员的矩阵有用。所有其他的矩阵都应该在数据流中的一个点上创建，在那里所有必要的信息都是可用的。 你必须在使用前用reinit(BlockSparsityPattern)初始化矩阵。然后每行和每列的块数由该函数决定。 </p>

</div>
</div>
<a id="aac28906675796dc4a0cce7978690e122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac28906675796dc4a0cce7978690e122">&#9670;&nbsp;</a></span>~BlockSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MPI::BlockSparseMatrix::~BlockSparseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a768f82745f771a3615c885409a985295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768f82745f771a3615c885409a985295">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>伪拷贝操作符只拷贝空对象。块状矩阵的大小需要相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00027">27</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="acf71e633299538f6433616e77f705e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf71e633299538f6433616e77f705e63">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？ 仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零的情况下进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00247">247</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a33ae01f6a8df5bc82ec8f65b1c472219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ae01f6a8df5bc82ec8f65b1c472219">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a>&#160;</td>
          <td class="paramname"><em>n_block_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调整矩阵的大小，通过设置块的行数和列数。 这将删除所有的块，并用未初始化的块代替，也就是那些尚未设置大小的块。你必须通过调用块本身的 <code>reinit</code> 函数来做到这一点。不要忘了之后在这个对象上调用collect_sizes()。 你必须自己设置块的大小的原因是，大小可能是变化的，每行的最大元素数可能是变化的，等等。在这里不复制SparsityPattern类的接口是比较简单的，而是让用户调用他们想要的任何函数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00036">36</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abc259ab453f20839a7a9261adefaecd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc259ab453f20839a7a9261adefaecd5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>bdsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>com</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>有效地重新引用块状矩阵进行并行计算。只有简单类型的BlockSparsityPattern可以有效地并行存储大型稀疏模式，所以这是唯一支持的参数。IndexSets描述了每个块的本地拥有的DoF的范围。注意，IndexSets需要升序和1:1。 对于一个对称的结构，前两个参数使用同一个向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00060">60</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa1d521feeceef075838a60dc94f329a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d521feeceef075838a60dc94f329a1">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>bdsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>com</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但只针对对称结构。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00099">99</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a3f3506ef24b261c12293599e4a9c47ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3506ef24b261c12293599e4a9c47ae">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M*src\) 与 \(M\) 为该矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00261">261</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ad8f74e6e9ebef8c10748a55a1120fc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f74e6e9ebef8c10748a55a1120fc15">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00269">269</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a9c7626baf09f92854eba9e3a4e8a87bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7626baf09f92854eba9e3a4e8a87bf">&#9670;&nbsp;</a></span>vmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块行的情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00277">277</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a7e849cb0f0d53a27eebad2f70afbb9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e849cb0f0d53a27eebad2f70afbb9ef">&#9670;&nbsp;</a></span>vmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00285">285</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1025b10f63c69f3e9b9ad7738e37c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1025b10f63c69f3e9b9ad7738e37c55b">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M^T*src\) 与 \(M\) 为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00292">292</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a7ed644062e23218a84153ab9bf653e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed644062e23218a84153ab9bf653e77">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块行的情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00300">300</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ab11e1a578c61c0ef58457951a0d3eb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11e1a578c61c0ef58457951a0d3eb9d">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00308">308</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="acb4b4f5d0655d6603ddc0a9e4b466543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4b4f5d0655d6603ddc0a9e4b466543">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__block__sparse__matrix_8h_source.html#l00316">316</a> of file <a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae42c718e89670e10f68a14279244e43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42c718e89670e10f68a14279244e43f">&#9670;&nbsp;</a></span>collect_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::collect_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数收集了子对象的大小，并将其存储在内部数组中，以便能够将矩阵的全局索引转为子对象的索引。在你改变子对象的大小后，你必须*每次都调用这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00109">109</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aaace33a3a780113892827537f6a69b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaace33a3a780113892827537f6a69b2e">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵的域空间的划分，即该矩阵必须与之相乘的向量的划分。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00115">115</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac26513a0e6d6666ecece85e649d4f687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26513a0e6d6666ecece85e649d4f687">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵的范围空间的划分，即由矩阵-向量乘积产生的向量的划分。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00126">126</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac05bb6e490e39a67f79f6a798a2f69ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05bb6e490e39a67f79f6a798a2f69ca">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对与该矩阵一起使用的MPI通信器对象的一个引用。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html#l00137">137</a> of file <a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac60e3f81c6bacc4202f4dd951514f616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60e3f81c6bacc4202f4dd951514f616">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将作为参数的矩阵复制到当前对象中。 复制矩阵是一个昂贵的操作，我们不希望通过编译器生成的代码意外发生 <code>operator=</code> 。（例如，如果不小心声明了一个当前类型为<em>by value</em>而不是<em>by reference</em>的函数参数，就会发生这种情况）。复制矩阵的功能是在这个成员函数中实现的。因此，该类型对象的所有复制操作都需要一个明确的函数调用。 源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型。 该函数返回一个对<code>this</code>的引用。 </p>

</div>
</div>
<a id="a1e54eb8c095bf2191a29c36a7784a5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e54eb8c095bf2191a29c36a7784a5b6">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问具有给定坐标的块。 </p>

</div>
</div>
<a id="aee186fad06d29d6670f241298f43faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee186fad06d29d6670f241298f43faae">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问具有给定坐标的区块。常量对象的版本。 </p>

</div>
</div>
<a id="ab46c51896e8656797b2086bbdfb59506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46c51896e8656797b2086bbdfb59506">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回共域（或范围）空间的维数。注意，矩阵的维度是 \(m \times n\) 。 </p>

</div>
</div>
<a id="a78bb440e54c21af96dcb43fd41958a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bb440e54c21af96dcb43fd41958a05">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a4459b251139d45f979377f3937f7266f">size_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回域空间的维度。请注意，矩阵的维度是 \(m \times n\) . </p>

</div>
</div>
<a id="a2478164707bf2932ad32ddd27babfc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2478164707bf2932ad32ddd27babfc00">&#9670;&nbsp;</a></span>n_block_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::n_block_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一列中的块数。如果目前没有与此矩阵相关的稀疏模式，则返回0。 </p>

</div>
</div>
<a id="a7b8a7553aacb22087640d6543a352637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8a7553aacb22087640d6543a352637">&#9670;&nbsp;</a></span>n_block_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::n_block_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个行中的块数。如果目前没有与该矩阵相关的稀疏模式，则返回0。 </p>

</div>
</div>
<a id="a9784ec81d727db00f7dbfdc9859ee029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9784ec81d727db00f7dbfdc9859ee029">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将元素&lt;tt&gt;(i,j)/tt&gt;设置为<code>值</code>。如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="ac6afa3a2f54b3a76ef38d8883d55a104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6afa3a2f54b3a76ef38d8883d55a104">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix中给出的所有元素设置到<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球的索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="afd4af16696853c4a9463031fabe748a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4af16696853c4a9463031fabe748a7">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="adc0f8f8fd5343815c3f7586478f3226d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0f8f8fd5343815c3f7586478f3226d">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="a78136f111eaa3f476a1981528be0d1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78136f111eaa3f476a1981528be0d1bd">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给出的值，在给定的行和col_indices给出的列中设置为稀疏矩阵。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要插入零值还是要过滤掉它们。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="ad8fe7a35a3336d251a4b3aa2c3ed9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fe7a35a3336d251a4b3aa2c3ed9748">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向元素添加<code>value</code>（<em>i,j</em>）。 如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="acec5bc680c14603ef59da590d0db0f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec5bc680c14603ef59da590d0db0f4a">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假定一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中通常的情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a0254582e171452592759674d9074e1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0254582e171452592759674d9074e1b7">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a00b25e1191e6a59ec8885912e50bd686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b25e1191e6a59ec8885912e50bd686">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a02c963b73dfee26bb1160755b40aad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c963b73dfee26bb1160755b40aad8d">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a9ee9987ece33a052d2b7a44034a8a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee9987ece33a052d2b7a44034a8a01a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将<code>matrix</code>按<code>factor</code>的比例添加到这个矩阵中，也就是说，矩阵<code>factor*matrix</code>被添加到<code>this</code>。如果调用矩阵的稀疏性模式不包含输入矩阵的稀疏性模式中的所有元素，这个函数将抛出一个异常。 然而，根据MatrixType，可能会出现额外的限制。 一些稀疏矩阵格式要求<code>matrix</code>是基于与调用矩阵相同的稀疏模式的。 </p>

</div>
</div>
<a id="a2a29846f2e327eb1252f8bcea47494f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29846f2e327eb1252f8bcea47494f7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目(i,j)的值。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 为了避免滥用，如果想要的元素在矩阵中不存在，这个函数会抛出一个异常。 </p>

</div>
</div>
<a id="a32133093964e34c80a89b8e494f32ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32133093964e34c80a89b8e494f32ff2">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数主要像operator()()，它返回矩阵条目&lt;tt&gt;(i,j)的值。唯一的区别是，如果这个条目不存在于稀疏模式中，那么就不会引发异常，而是返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 </p>

</div>
</div>
<a id="adc6afe454cf2282f21d1230ad74bcde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6afe454cf2282f21d1230ad74bcde2">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次方的，以及矩阵的对角线块不是二次方的，这个函数会抛出一个错误。 这个函数比operator()()快得多，因为对于二次矩阵来说，对角线条目可能是每行中第一个被存储的，因此访问时不需要搜索正确的列号。 </p>

</div>
</div>
<a id="a74954a421ab950fef132131c2eb6b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74954a421ab950fef132131c2eb6b5f9">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在矩阵的所有子块上调用compress()函数。 参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象 </a> 以获得更多信息。 </p>

</div>
</div>
<a id="a2190cc18dbc94dfb98d99d1d62ef4fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2190cc18dbc94dfb98d99d1d62ef4fb5">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

</div>
</div>
<a id="a5e772b9ccf9ea814802a81948190517f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e772b9ccf9ea814802a81948190517f">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵除以一个固定系数。 </p>

</div>
</div>
<a id="a5b69dc529dec11d15c40904ef729ad25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b69dc529dec11d15c40904ef729ad25">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。在 \(dst\) 上添加 \(M*src\) ， \(M\) 为该矩阵。 </p>

</div>
</div>
<a id="a657f2265bcb165f5b9016787d62c8d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657f2265bcb165f5b9016787d62c8d1a">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加矩阵-向量乘法。将<em>M<sup>T</sup>src</em>加到<em>dst</em>上，<em>M</em>是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 </p>

</div>
</div>
<a id="a194567f1611984e0ffbd0a2967f94bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194567f1611984e0ffbd0a2967f94bd9">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量<em>v</em>相对于该矩阵诱导的规范，即<em>v<sup>T</sup>Mv)</em>的规范。这很有用，例如在有限元背景下，一个函数的<em>L<sup>T</sup></em>规范等于相对于代表有限元函数节点值的向量矩阵的矩阵规范。请注意，尽管函数的名称可能暗示了一些不同的东西，但由于历史原因，返回的不是法线，而是它的平方，正如上面所定义的标量积。 很明显，对于这个操作，矩阵需要是平方的。 </p>

</div>
</div>
<a id="a40df5806b5d3cc3f19a31a7e11b36f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40df5806b5d3cc3f19a31a7e11b36f51">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方和的平方根。 </p>

</div>
</div>
<a id="ab9d63be4e435be84abbdd0eff9c8fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d63be4e435be84abbdd0eff9c8fa7a">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 </p>

</div>
</div>
<a id="a754a13320e96366f2b5b4269a232767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754a13320e96366f2b5b4269a232767b">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aba37cb0601d734660b7c351646685d7b">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::residual </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算残差<em>r=b-Ax</em>。将残差写进<code>dst</code>。 </p>

</div>
</div>
<a id="a0a345092f0dea627d1b250fe51f3da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a345092f0dea627d1b250fe51f3da6c">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印矩阵到给定的数据流中，使用格式&lt;tt&gt;(line,col) value，即每行有一个矩阵的非零条目。可选的标志是根据底层稀疏矩阵的类型，以不同的风格输出稀疏模式。 </p>

</div>
</div>
<a id="a80251837872592496f08d63deb87cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80251837872592496f08d63deb87cd0c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器从第一个条目开始。 </p>

</div>
</div>
<a id="aed413af2409b398fd003acf6a33f351e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed413af2409b398fd003acf6a33f351e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从<code>r</code>行的第一个条目开始的迭代器。 </p>

</div>
</div>
<a id="a3dd1f6468acb2728b28ed5fad880436c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1f6468acb2728b28ed5fad880436c">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从第一条开始的迭代器。 </p>

</div>
</div>
<a id="aed8bd8ac7f288e11fbb9a15fcf7fa0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8bd8ac7f288e11fbb9a15fcf7fa0af">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从<code>r</code>行的第一个条目开始的迭代器。 </p>

</div>
</div>
<a id="a969257f13a198e3b39372c513d3dc5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969257f13a198e3b39372c513d3dc5aa">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>最后的迭代器。 </p>

</div>
</div>
<a id="af9494559d41237c44b235153035bcce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9494559d41237c44b235153035bcce4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#a87c619d491397ad3d0ff5a5d80815064">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。 </p>

</div>
</div>
<a id="a0f188b3a4f6540c5d8ecde61b31ade05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f188b3a4f6540c5d8ecde61b31ade05">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>最后的迭代器。 </p>

</div>
</div>
<a id="afa28a3d5286822c32a3f7ef7437e730d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa28a3d5286822c32a3f7ef7437e730d">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aab3608c60f37d6e2ec541caef93e886a">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。 </p>

</div>
</div>
<a id="aaa06c2fc3d4a49502844155f66078bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa06c2fc3d4a49502844155f66078bf0">&#9670;&nbsp;</a></span>get_row_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::get_row_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对行的底层BlockIndices数据的引用。 </p>

</div>
</div>
<a id="afe907561eea46905c41c3e0efd53cd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe907561eea46905c41c3e0efd53cd0e">&#9670;&nbsp;</a></span>get_column_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::get_column_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对列的基本BlockIndices数据的引用。 </p>

</div>
</div>
<a id="a9e0ef9c39b0f6e1e5f69ca8eb58e9ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0ef9c39b0f6e1e5f69ca8eb58e9ac9">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定此对象的内存消耗（以字节为单位）的估计值。注意，如果是在基于MPI的程序中调用，则只返回当前处理器上保留的内存。 </p>

</div>
</div>
<a id="ga4041ccf8874d3ff3894e2c5e738d769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4041ccf8874d3ff3894e2c5e738d769a">&#9670;&nbsp;</a></span>DeclException4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleRowNumbers&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The blocks  and  have differing row numbers.&quot;&#160;</td>
          <td class="paramname">[&quot; &lt;&lt; arg1 &lt;&lt; ',' &lt;&lt; arg2 &lt;&lt; &quot;][&quot; &lt;&lt; arg3 &lt;&lt; ',' &lt;&lt; arg4 &lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ga10f7d355e1a8b4ca45e2f30b3ba48916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10f7d355e1a8b4ca45e2f30b3ba48916">&#9670;&nbsp;</a></span>DeclException4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleColNumbers&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The blocks  and  have differing column numbers.&quot;&#160;</td>
          <td class="paramname">[&quot; &lt;&lt; arg1 &lt;&lt; ',' &lt;&lt; arg2 &lt;&lt; &quot;][&quot; &lt;&lt; arg3 &lt;&lt; ',' &lt;&lt; arg4 &lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a2c94c4773a37d8672d23ca782bd50234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c94c4773a37d8672d23ca782bd50234">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。它也忘记了它之前绑定的稀疏模式。 这个函数对所有的子矩阵进行清除，然后将这个对象重置为完全没有块。 这个函数是受保护的，因为它可能需要释放额外的结构。如果足够的话，一个派生类可以再次将其公开。 </p>

</div>
</div>
<a id="a4109f58621de12f02b521df0bbb4728f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4109f58621de12f02b521df0bbb4728f">&#9670;&nbsp;</a></span>vmult_block_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::vmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M*src\) 与 \(M\) 是这个矩阵。 由于在vmult/Tvmult函数的块和非块版本之间衍生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器衍生。 </p>

</div>
</div>
<a id="adfd4c9d2a02835be4a0e7fdb9c5fb84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd4c9d2a02835be4a0e7fdb9c5fb84b">&#9670;&nbsp;</a></span>vmult_block_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::vmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像之前的函数一样，但只适用于矩阵只有一个块列的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a70152dd877ead20e92468b11dd923fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70152dd877ead20e92468b11dd923fdb">&#9670;&nbsp;</a></span>vmult_nonblock_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::vmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像之前的函数一样，但只适用于矩阵只有一个块行的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名字下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a003f20e2d1a54fa9cc7e312175f23101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f20e2d1a54fa9cc7e312175f23101">&#9670;&nbsp;</a></span>vmult_nonblock_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::vmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生出来的唯一名称。 </p>

</div>
</div>
<a id="a1b5e896a6aadc0f6663ca4bfd69e8e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5e896a6aadc0f6663ca4bfd69e8e73">&#9670;&nbsp;</a></span>Tvmult_block_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::Tvmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M^T*src\) 与 \(M\) 是这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 由于vmult/Tvmult函数的块和非块版本之间的模板参数派生问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生出来的唯一名称。 </p>

</div>
</div>
<a id="af6f970e6afe14484f051897f5c78060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f970e6afe14484f051897f5c78060f">&#9670;&nbsp;</a></span>Tvmult_block_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::Tvmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块行的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个唯一的名称下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a20df57e0ac765128dfaa48add407e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20df57e0ac765128dfaa48add407e490">&#9670;&nbsp;</a></span>Tvmult_nonblock_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::Tvmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a002a305f47b31aa962b58f6a863f831d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002a305f47b31aa962b58f6a863f831d">&#9670;&nbsp;</a></span>Tvmult_nonblock_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::Tvmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生的唯一名称。 </p>

</div>
</div>
<a id="a6f52ce530c3028e0d3194a719cb82576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f52ce530c3028e0d3194a719cb82576">&#9670;&nbsp;</a></span>prepare_add_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::prepare_add_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些矩阵类型，特别是PETSc，需要同步设置和添加操作。这必须对BlockMatrix中的所有矩阵进行操作。本例程通过通知所有块来准备添加元素。在添加元素之前，所有的内部例程都会调用它。 </p>

</div>
</div>
<a id="a79d3d021b1004a8fb027b50e0862c149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d3d021b1004a8fb027b50e0862c149">&#9670;&nbsp;</a></span>prepare_set_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::prepare_set_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通知所有区块，让它们为设置元素做准备，见prepare_add_operation()。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa401f344887a4647a9a14ef41629aed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa401f344887a4647a9a14ef41629aed9">&#9670;&nbsp;</a></span>row_block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::row_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行和列的索引数组。 </p>

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00794">794</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a id="a10666cbe2741f71f6cf17ebedaf9080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10666cbe2741f71f6cf17ebedaf9080d">&#9670;&nbsp;</a></span>column_block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::column_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00795">795</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a id="a6352220e7e9c26aaffd42bce3b2f25b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6352220e7e9c26aaffd42bce3b2f25b4">&#9670;&nbsp;</a></span>sub_objects</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;<a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html#aaa3749d356343dcef47f6981de8bd4d2">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &gt; &gt; &gt; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>  &gt;::sub_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>子矩阵的数组。 </p>

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00801">801</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__block__sparse__matrix_8h_source.html">petsc_block_sparse_matrix.h</a></li>
<li>source/lac/<a class="el" href="petsc__parallel__block__sparse__matrix_8cc_source.html">petsc_parallel_block_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
