<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceSparsityTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparsityTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SparsityTools Namespace Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Sparsity.html">Sparsity patterns</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSparsityTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a34d8cbf5559e454001e512c4368c2c3e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">Partitioner</a> { <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">Partitioner::metis</a> = 0, 
<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea9b2a08291b328fd80d8196926ba685ec">Partitioner::zoltan</a>
 }</td></tr>
<tr class="separator:a34d8cbf5559e454001e512c4368c2c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a452753b6ffdf31b33f2bcd792b05df93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const unsigned <a class="el" href="classint.html">int</a> n_partitions, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;partition_indices, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">Partitioner::metis</a>)</td></tr>
<tr class="separator:a452753b6ffdf31b33f2bcd792b05df93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c64b340d0dbd53018574a1e0fff2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#aa51c64b340d0dbd53018574a1e0fff2e">partition</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;cell_weights, const unsigned <a class="el" href="classint.html">int</a> n_partitions, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;partition_indices, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">Partitioner::metis</a>)</td></tr>
<tr class="separator:aa51c64b340d0dbd53018574a1e0fff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a19180267dae516a09317edb4995cff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a2a19180267dae516a09317edb4995cff">color_sparsity_pattern</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;color_indices)</td></tr>
<tr class="separator:a2a19180267dae516a09317edb4995cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7da91ef608d0e4c17d75c21070db6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#ad7da91ef608d0e4c17d75c21070db6e4">reorder_Cuthill_McKee</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity, std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;new_indices, const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt;())</td></tr>
<tr class="separator:ad7da91ef608d0e4c17d75c21070db6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576797328aeace287d271ee4e48e04a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a576797328aeace287d271ee4e48e04a6">reorder_hierarchical</a> (const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity, std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;new_indices)</td></tr>
<tr class="separator:a576797328aeace287d271ee4e48e04a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc0c7a206ced91b154666215ea3c218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">distribute_sparsity_pattern</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;dsp, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_rows, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_relevant_rows)</td></tr>
<tr class="separator:afbc0c7a206ced91b154666215ea3c218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c7bdbdb62642f60d60087e4cb6195f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">distribute_sparsity_pattern</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;dsp, const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;rows_per_cpu, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;myrange)</td></tr>
<tr class="separator:ae2c7bdbdb62642f60d60087e4cb6195f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b755ade5ed0b3a1bd8a049c3d65934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a78b755ade5ed0b3a1bd8a049c3d65934">distribute_sparsity_pattern</a> (<a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;dsp, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_rows, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_relevant_rows)</td></tr>
<tr class="separator:a78b755ade5ed0b3a1bd8a049c3d65934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f68c3f11df0649b0ea1fbe643102e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a24f68c3f11df0649b0ea1fbe643102e9">distribute_sparsity_pattern</a> (<a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;dsp, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;owned_set_per_cpu, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;myrange)</td></tr>
<tr class="separator:a24f68c3f11df0649b0ea1fbe643102e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171ce3f9588cab4fdbb3472d70e08bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a171ce3f9588cab4fdbb3472d70e08bfc">gather_sparsity_pattern</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;dsp, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_rows, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_relevant_rows)</td></tr>
<tr class="separator:a171ce3f9588cab4fdbb3472d70e08bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a454c5ce9cef3e1307c2480ccda92a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a49a454c5ce9cef3e1307c2480ccda92a">DeclExceptionMsg</a> (ExcMETISNotInstalled, &quot;The function you called requires METIS, but you did not &quot; &quot;configure deal.II with METIS.&quot;)</td></tr>
<tr class="separator:a49a454c5ce9cef3e1307c2480ccda92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c47d2cd20daaaa033f341da9f085cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a81c47d2cd20daaaa033f341da9f085cb">DeclException1</a> (ExcInvalidNumberOfPartitions, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of partitions you gave is &quot;&lt;&lt; arg1&lt;&lt; &quot;, but must be greater than zero.&quot;)</td></tr>
<tr class="separator:a81c47d2cd20daaaa033f341da9f085cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0c3b130ae827c6681fd6424c968c55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a0f0c3b130ae827c6681fd6424c968c55">DeclException1</a> (ExcMETISError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;    An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a METIS function&quot;)</td></tr>
<tr class="separator:a0f0c3b130ae827c6681fd6424c968c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6d548c3d5235264497d27c4b1bbd09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a7a6d548c3d5235264497d27c4b1bbd09">DeclException2</a> (ExcInvalidArraySize, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The array has size &quot;&lt;&lt; arg1&lt;&lt; &quot; but should have size &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:a7a6d548c3d5235264497d27c4b1bbd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0047211003bffd6e5773c3f901562647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSparsityTools.html#a0047211003bffd6e5773c3f901562647">DeclExceptionMsg</a> (ExcZOLTANNotInstalled, &quot;The function you called requires ZOLTAN, but you did not &quot; &quot;configure deal.II with ZOLTAN or zoltan_cpp.h is not available.&quot;)</td></tr>
<tr class="separator:a0047211003bffd6e5773c3f901562647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for functions that deal with things that one can do on sparsity patterns, such as renumbering rows and columns (or degrees of freedom if you want) according to the connectivity, or partitioning degrees of freedom. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a34d8cbf5559e454001e512c4368c2c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d8cbf5559e454001e512c4368c2c3e">&#9670;&nbsp;</a></span>Partitioner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerator with options for partitioner </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538"></a>metis&#160;</td><td class="fielddoc"><p>Use METIS partitioner. </p>
</td></tr>
<tr><td class="fieldname"><a id="a34d8cbf5559e454001e512c4368c2c3ea9b2a08291b328fd80d8196926ba685ec"></a>zoltan&#160;</td><td class="fielddoc"><p>Use ZOLTAN partitioner. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8h_source.html#l00055">55</a> of file <a class="el" href="sparsity__tools_8h_source.html">sparsity_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a452753b6ffdf31b33f2bcd792b05df93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452753b6ffdf31b33f2bcd792b05df93">&#9670;&nbsp;</a></span>partition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use a partitioning algorithm to generate a partitioning of the degrees of freedom represented by this sparsity pattern. In effect, we view this sparsity pattern as a graph of connections between various degrees of freedom, where each nonzero entry in the sparsity pattern corresponds to an edge between two nodes in the connection graph. The goal is then to decompose this graph into groups of nodes so that a minimal number of edges are cut by the boundaries between node groups. This partitioning is done by METIS or ZOLTAN, depending upon which partitioner is chosen in the fourth argument. The default is METIS. Note that METIS and ZOLTAN can only partition symmetric sparsity patterns, and that of course the sparsity pattern has to be square. We do not check for symmetry of the sparsity pattern, since this is an expensive operation, but rather leave this as the responsibility of caller of this function.</p>
<p>After calling this function, the output array will have values between zero and <code>n_partitions-1</code> for each node (i.e. row or column of the matrix).</p>
<p>If deal.II was not installed with packages ZOLTAN or METIS, this function will generate an error when corresponding partition method is chosen, unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without the packages installed, and only requires them installed when multiple partitions are required.</p>
<p>Note that the sparsity pattern itself is not changed by calling this function. However, you will likely use the information generated by calling this function to renumber degrees of freedom, after which you will of course have to regenerate the sparsity pattern.</p>
<p>This function will rarely be called separately, since in finite element methods you will want to partition the mesh, not the matrix. This can be done by calling <code><a class="el" href="namespaceGridTools.html#a99eba8e3b388258eda37a2724579dd1d">GridTools::partition_triangulation</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00399">399</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="aa51c64b340d0dbd53018574a1e0fff2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c64b340d0dbd53018574a1e0fff2e">&#9670;&nbsp;</a></span>partition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs the same operation as the one above, except that it takes into consideration a set of <code>cell_weights</code>, which allow the partitioner to balance the graph while taking into consideration the computational effort expended on each cell.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weights</code> vector is empty, then no weighting is taken into consideration. If not then the size of this vector must equal to the number of active cells in the triangulation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00416">416</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a2a19180267dae516a09317edb4995cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a19180267dae516a09317edb4995cff">&#9670;&nbsp;</a></span>color_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> SparsityTools::color_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>color_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using a coloring algorithm provided by ZOLTAN to color nodes whose connections are represented using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object. In effect, we view this sparsity pattern as a graph of connections between nodes, where each nonzero entry in the <code>sparsity_pattern</code> corresponds to an edge between two nodes. The goal is to assign each node a color index such that no two directly connected nodes have the same color. The assigned colors are listed in <code>color_indices</code> indexed from one and the function returns total number of colors used. ZOLTAN coloring algorithm is run in serial by each processor. Hence all processors have coloring information of all the nodes. A wrapper function to this function is available in <a class="el" href="namespaceGraphColoring.html">GraphColoring</a> namespace as well.</p>
<p>Note that this function requires that <a class="el" href="classSparsityPattern.html">SparsityPattern</a> be symmetric (and hence square) i.e an undirected graph representation. We do not check for symmetry of the sparsity pattern, since this is an expensive operation, but rather leave this as the responsibility of caller of this function.</p>
<div class="image">
<img src="color_undirected_graph.png" alt="color_undirected_graph.png"/>
</div>
<p> The usage of the function is illustrated by the image above, showing five nodes numbered from 0 to 4. The connections shown are bidirectional. After coloring, it is clear that no two directly connected nodes are assigned the same color.</p>
<p>If deal.II was not installed with package ZOLTAN, this function will generate an error.</p>
<dl class="section note"><dt>Note</dt><dd>The current function is an alternative to <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a> which is tailored to graph coloring arising in shared-memory parallel assembly of matrices. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00455">455</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="ad7da91ef608d0e4c17d75c21070db6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7da91ef608d0e4c17d75c21070db6e4">&#9670;&nbsp;</a></span>reorder_Cuthill_McKee()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::reorder_Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;<a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given sparsity pattern, compute a re-enumeration of row/column indices based on the algorithm by Cuthill-McKee.</p>
<p>This algorithm is a graph renumbering algorithm in which we attempt to find a new numbering of all nodes of a graph based on their connectivity to other nodes (i.e. the edges that connect nodes). This connectivity is here represented by the sparsity pattern. In many cases within the library, the nodes represent degrees of freedom and edges are nonzero entries in a matrix, i.e. pairs of degrees of freedom that couple through the action of a bilinear form.</p>
<p>The algorithms starts at a node, searches the other nodes for those which are coupled with the one we started with and numbers these in a certain way. It then finds the second level of nodes, namely those that couple with those of the previous level (which were those that coupled with the initial node) and numbers these. And so on. For the details of the algorithm, especially the numbering within each level, we refer the reader to the book of Schwarz (H. R. Schwarz: Methode der finiten Elemente).</p>
<p>These algorithms have one major drawback: they require a good starting node, i.e. node that will have number zero in the output array. A starting node forming the initial level of nodes can thus be given by the user, e.g. by exploiting knowledge of the actual topology of the domain. It is also possible to give several starting indices, which may be used to simulate a simple upstream numbering (by giving the inflow nodes as starting values) or to make preconditioning faster (by letting the Dirichlet boundary indices be starting points).</p>
<p>If no starting index is given, one is chosen automatically, namely one with the smallest coordination number (the coordination number is the number of other nodes this node couples with). This node is usually located on the boundary of the domain. There is, however, large ambiguity in this when using the hierarchical meshes used in this library, since in most cases the computational domain is not approximated by tilting and deforming elements and by plugging together variable numbers of elements at vertices, but rather by hierarchical refinement. There is therefore a large number of nodes with equal coordination numbers. The renumbering algorithms will therefore not give optimal results.</p>
<p>If the graph has two or more unconnected components and if no starting indices are given, the algorithm will number each component consecutively. However, this requires the determination of a starting index for each component; as a consequence, the algorithm will produce an exception if starting indices are given, taking the latter as an indication that the caller of the function would like to override the part of the algorithm that chooses starting indices. </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00579">579</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a576797328aeace287d271ee4e48e04a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576797328aeace287d271ee4e48e04a6">&#9670;&nbsp;</a></span>reorder_hierarchical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::reorder_hierarchical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a given sparsity pattern, compute a re-enumeration of row/column indices in a hierarchical way, similar to what <a class="el" href="namespaceDoFRenumbering.html#a410cb640ec086808d4c56dd4e4873048">DoFRenumbering::hierarchical</a> does for degrees of freedom on hierarchically refined meshes.</p>
<p>This algorithm first selects a node with the minimum number of neighbors and puts that node and its direct neighbors into one chunk. Next, it selects one of the neighbors of the already selected nodes, adds the node and its direct neighbors that are not part of one of the previous chunks, into the next. After this sweep, neighboring nodes are grouped together. To ensure a similar grouping on a more global level, this grouping is called recursively on the groups so formed. The recursion stops when no further grouping is possible. Eventually, the ordering obtained by this method passes through the indices represented in the sparsity pattern in a z-like way.</p>
<p>If the graph has two or more unconnected components, the algorithm will number each component consecutively, starting with the components with the lowest number of nodes. </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00900">900</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="afbc0c7a206ced91b154666215ea3c218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc0c7a206ced91b154666215ea3c218">&#9670;&nbsp;</a></span>distribute_sparsity_pattern() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::distribute_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_relevant_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communicate rows in a dynamic sparsity pattern over MPI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dsp</td><td>A dynamic sparsity pattern that has been built locally and for which we need to exchange entries with other processors to make sure that each processor knows all the elements of the rows of a matrix it stores and that may eventually be written to. This sparsity pattern will be changed as a result of this function: All entries in rows that belong to a different processor are sent to them and added there.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">locally_owned_rows</td><td>An <a class="el" href="classIndexSet.html">IndexSet</a> describing the rows owned by the calling MPI process. The index set shall be one-to-one among the processors in the communicator.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mpi_comm</td><td>The MPI communicator shared between the processors that participate in this operation.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">locally_relevant_rows</td><td>The range of elements stored on the local MPI process. This should be the one used in the constructor of the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, and should also be the locally relevant set. Only rows contained in this set are checked in dsp for transfer. This function needs to be used with <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a> for it to work correctly in a parallel computation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l01030">1030</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="ae2c7bdbdb62642f60d60087e4cb6195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7bdbdb62642f60d60087e4cb6195f">&#9670;&nbsp;</a></span>distribute_sparsity_pattern() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::distribute_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDynamicSparsityPattern.html#a2d7249323016034cf1e20072c0b58907">DynamicSparsityPattern::size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows_per_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>myrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Communicate rows in a dynamic sparsity pattern over MPI, similar to the one above but using a vector <code>rows_per_cpu</code> containing the number of rows per CPU for determining ownership. This is typically the value returned by <a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(MPI_Comm, <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a>) &ndash; given that the construction of the input to this function involves all-to-all communication, it is typically slower than the function above for more than a thousand of processes (and quick enough also for small sizes). </p>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l01008">1008</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a78b755ade5ed0b3a1bd8a049c3d65934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b755ade5ed0b3a1bd8a049c3d65934">&#9670;&nbsp;</a></span>distribute_sparsity_pattern() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::distribute_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_relevant_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the function above, but for <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dsp</td><td>The locally built sparsity pattern to be modified.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">locally_owned_rows</td><td>An <a class="el" href="classIndexSet.html">IndexSet</a> describing the rows owned by the calling MPI process. The index set shall be one-to-one among the processors in the communicator.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mpi_comm</td><td>The MPI communicator to use.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">locally_relevant_rows</td><td>Typically the locally relevant DoFs. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l01112">1112</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a24f68c3f11df0649b0ea1fbe643102e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f68c3f11df0649b0ea1fbe643102e9">&#9670;&nbsp;</a></span>distribute_sparsity_pattern() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::distribute_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>owned_set_per_cpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>myrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000057">Deprecated:</a></b></dt><dd>Use the <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">distribute_sparsity_pattern()</a> with a single index set for the present MPI process only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l01097">1097</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a171ce3f9588cab4fdbb3472d70e08bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171ce3f9588cab4fdbb3472d70e08bfc">&#9670;&nbsp;</a></span>gather_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparsityTools::gather_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>dsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_relevant_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gather rows in a dynamic sparsity pattern over MPI. The function is similar to SparsityTools::distribute(), however instead of distributing sparsity stored in non-owned rows on this MPI process, this function will gather sparsity from other MPI processes and will add this to the local <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsp</td><td>A dynamic sparsity pattern that has been built locally and which we need to extend according to the sparsity of rows stored on other MPI processes.</td></tr>
    <tr><td class="paramname">locally_owned_rows</td><td>An <a class="el" href="classIndexSet.html">IndexSet</a> describing the rows owned by the calling MPI process. The index set shall be one-to-one among the processors in the communicator.</td></tr>
    <tr><td class="paramname">mpi_comm</td><td>The MPI communicator shared between the processors that participate in this operation.</td></tr>
    <tr><td class="paramname">locally_relevant_rows</td><td>The range of rows this MPI process needs to gather. Only the part which is not included in the locally owned rows will be used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sparsity__tools_8cc_source.html#l00916">916</a> of file <a class="el" href="sparsity__tools_8cc_source.html">sparsity_tools.cc</a>.</p>

</div>
</div>
<a id="a49a454c5ce9cef3e1307c2480ccda92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a454c5ce9cef3e1307c2480ccda92a">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityTools::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcMETISNotInstalled&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The function you called requires&#160;</td>
          <td class="paramname"><em>METIS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but you did not &quot; &quot;configure deal.II with METIS.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a81c47d2cd20daaaa033f341da9f085cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c47d2cd20daaaa033f341da9f085cb">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumberOfPartitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of partitions you gave is &quot;&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but must be greater than zero.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a0f0c3b130ae827c6681fd6424c968c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0c3b130ae827c6681fd6424c968c55">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcMETISError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot; An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a METIS function&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a7a6d548c3d5235264497d27c4b1bbd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6d548c3d5235264497d27c4b1bbd09">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityTools::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidArraySize&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The array has size &quot;&lt;&lt; arg1&lt;&lt; &quot; but should have size &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a0047211003bffd6e5773c3f901562647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0047211003bffd6e5773c3f901562647">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparsityTools::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcZOLTANNotInstalled&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The function you called requires&#160;</td>
          <td class="paramname"><em>ZOLTAN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but you did not &quot; &quot;configure deal.II with ZOLTAN or zoltan_cpp.h is not available.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
