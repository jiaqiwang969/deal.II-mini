<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSphericalManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SphericalManifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSphericalManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SphericalManifold&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__manifold.html">Manifold description for triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="grid_2manifold__lib_8h_source.html">deal.II/grid/manifold_lib.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SphericalManifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSphericalManifold__inherit__graph.svg" width="191" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad64992c5cbbf4b9c933c7dc810d331a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#ad64992c5cbbf4b9c933c7dc810d331a4">SphericalManifold</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classSphericalManifold.html#a64a4033ac330d9c1592aa23e117bddb8">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;())</td></tr>
<tr class="separator:ad64992c5cbbf4b9c933c7dc810d331a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2789d19572e9054df24d4f56ca89fb"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a7c2789d19572e9054df24d4f56ca89fb">clone</a> () const override</td></tr>
<tr class="separator:a7c2789d19572e9054df24d4f56ca89fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583ee1989abe66f8b9ead2c4cc79e38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#ac583ee1989abe66f8b9ead2c4cc79e38">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const override</td></tr>
<tr class="separator:ac583ee1989abe66f8b9ead2c4cc79e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f186c631d913c683d687aee65b3f48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a95f186c631d913c683d687aee65b3f48">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const override</td></tr>
<tr class="separator:a95f186c631d913c683d687aee65b3f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa07d5cf46d4f9110887793475c4b5f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const override</td></tr>
<tr class="separator:a3fa07d5cf46d4f9110887793475c4b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a0b3c46c740ac5a979b0aa5b8eb51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a805a0b3c46c740ac5a979b0aa5b8eb51">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, typename <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const override</td></tr>
<tr class="separator:a805a0b3c46c740ac5a979b0aa5b8eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22df33a99a097469704e1209fbffda3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#af22df33a99a097469704e1209fbffda3">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:af22df33a99a097469704e1209fbffda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be1a0a1464f08ee3865462994be827f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a5be1a0a1464f08ee3865462994be827f">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a5be1a0a1464f08ee3865462994be827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:af0163e726b6c4af36638d889fb3afed4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">project_to_manifold</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate) const</td></tr>
<tr class="separator:af0163e726b6c4af36638d889fb3afed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be8b4b185d2469dcdfff826ff854cd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9be8b4b185d2469dcdfff826ff854cd7">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:a9be8b4b185d2469dcdfff826ff854cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f18f34e5f98fea7cbd40bd3245f0aee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a6f18f34e5f98fea7cbd40bd3245f0aee">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a6f18f34e5f98fea7cbd40bd3245f0aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b1f7a138589989fe84984e12f3d945"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a87b1f7a138589989fe84984e12f3d945">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a87b1f7a138589989fe84984e12f3d945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238d0f0a7f973ff25f4cab4ec21e9b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a238d0f0a7f973ff25f4cab4ec21e9b56">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:a238d0f0a7f973ff25f4cab4ec21e9b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e9a7899b69fbe5fdf7961f9c4c7374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a39e9a7899b69fbe5fdf7961f9c4c7374">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:a39e9a7899b69fbe5fdf7961f9c4c7374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:a684ad0b97b0f225eb4eb7ee04ab41d7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a684ad0b97b0f225eb4eb7ee04ab41d7e">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a684ad0b97b0f225eb4eb7ee04ab41d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a64a4033ac330d9c1592aa23e117bddb8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a64a4033ac330d9c1592aa23e117bddb8">center</a></td></tr>
<tr class="separator:a64a4033ac330d9c1592aa23e117bddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4797f8168f747583c6745f591c7addfb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a4797f8168f747583c6745f591c7addfb">guess_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;directions, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;distances, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const</td></tr>
<tr class="separator:a4797f8168f747583c6745f591c7addfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ce83b5c4e919e1bbdbfee96ccfd9a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a59ce83b5c4e919e1bbdbfee96ccfd9a8">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;directions, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;distances, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate_point) const</td></tr>
<tr class="separator:a59ce83b5c4e919e1bbdbfee96ccfd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a2b077178e7257d6f3ad65a4aaaa9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a58a2b077178e7257d6f3ad65a4aaaa9d">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const</td></tr>
<tr class="separator:a58a2b077178e7257d6f3ad65a4aaaa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7896a0ba10773b84ce39511008ae6340"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPolarManifold.html">PolarManifold</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html#a7896a0ba10773b84ce39511008ae6340">polar_manifold</a></td></tr>
<tr class="separator:a7896a0ba10773b84ce39511008ae6340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class SphericalManifold&lt; dim, spacedim &gt;</h3>

<p><a class="el" href="classManifold.html">Manifold</a> description for a spherical space coordinate system.</p>
<p>You can use this <a class="el" href="classManifold.html">Manifold</a> object to describe any sphere, circle, hypersphere or hyperdisc in two or three dimensions. This manifold can be used as a co-dimension one manifold descriptor of a spherical surface embedded in a higher dimensional space, or as a co-dimension zero manifold descriptor for a body with positive volume, provided that the center of the spherical space is excluded from the domain. An example for the use of this function would be in the description of a hyper-shell or hyper-ball geometry, for example after creating a coarse mesh using <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>. (However, it is worth mentioning that generating a good mesh for a disk or ball is complicated and requires addition steps. See the "Possibilities for extensions" section of step-6 for an extensive discussion of how one would construct such meshes and what one needs to do for it.)</p>
<p>The two template arguments match the meaning of the two template arguments in Triangulation&lt;dim, spacedim&gt;, however this <a class="el" href="classManifold.html">Manifold</a> can be used to describe both thin and thick objects, and the behavior is identical when dim &lt;= spacedim, i.e., the functionality of SphericalManifold&lt;2,3&gt; is identical to SphericalManifold&lt;3,3&gt;.</p>
<p>While <a class="el" href="classPolarManifold.html">PolarManifold</a> reflects the usual notion of polar coordinates, it may not be suitable for domains that contain either the north or south poles. Consider for instance the pair of points \(x_1=(1,\pi/3,0)\) and \(x_2=(1,\pi/3,\pi)\) in polar coordinates (lying on the surface of a sphere with radius one, on a parallel at height \(\pi/3\)). In this case connecting the points with a straight line in polar coordinates would take the long road around the globe, without passing through the north pole.</p>
<p>These two points would be connected (using a <a class="el" href="classPolarManifold.html">PolarManifold</a>) by the curve </p><p class="formulaDsp">
\begin{align*} s: [0,1] &amp; \rightarrow &amp; \mathbb S^3 \\ t &amp; \mapsto &amp; (1,\pi/3,0) + (0,0,t\pi) \end{align*}
</p>
<p> This curve is not a geodesic on the sphere, and it is not how we would connect those two points. A better curve, would be the one passing through the North pole: </p><p class="formulaDsp">
\[ s(t) = x_1 \cos(\alpha(t)) + \kappa \times x_1 \sin(\alpha(t)) + \kappa ( \kappa \cdot x_1) (1-\cos(\alpha(t))). \]
</p>
<p> where \(\kappa = \frac{x_1 \times x_2}{\Vert x_1 \times x_2 \Vert}\) and \(\alpha(t) = t \cdot \arccos(x_1 \cdot x_2)\) for \(t\in[0,1]\). Indeed, this is a geodesic, and it is the natural choice when connecting points on the surface of the sphere. In the examples above, the <a class="el" href="classPolarManifold.html">PolarManifold</a> class implements the first way of connecting two points on the surface of a sphere, while <a class="el" href="classSphericalManifold.html">SphericalManifold</a> implements the second way, i.e., this <a class="el" href="classManifold.html">Manifold</a> connects points using geodesics. If more than two points are involved through a <a class="el" href="classSphericalManifold.html#af22df33a99a097469704e1209fbffda3">SphericalManifold::get_new_points()</a> call, a so-called spherical average is used where the final point minimizes the weighted distance to all other points via geodesics.</p>
<p>In particular, this class implements a <a class="el" href="classManifold.html">Manifold</a> that joins any two points in space by first projecting them onto the surface of a sphere with unit radius, then connecting them with a geodesic, and finally rescaling the final radius so that the resulting one is the weighted average of the starting radii. This <a class="el" href="classManifold.html">Manifold</a> is identical to <a class="el" href="classPolarManifold.html">PolarManifold</a> in dimension two, while for dimension three it returns points that are more uniformly distributed on the sphere, and it is invariant with respect to rotations of the coordinate system, therefore avoiding the problems that <a class="el" href="classPolarManifold.html">PolarManifold</a> has at the poles. Notice, in particular, that computing tangent vectors at the poles with a <a class="el" href="classPolarManifold.html">PolarManifold</a> is not well defined, while it is perfectly fine with this class.</p>
<p>For mathematical reasons, it is impossible to construct a unique map of a sphere using only geodesic curves, and therefore, using this class with <a class="el" href="classMappingManifold.html">MappingManifold</a> is discouraged. If you use this <a class="el" href="classManifold.html">Manifold</a> to describe the geometry of a sphere, you should use <a class="el" href="classMappingQ.html">MappingQ</a> as the underlying mapping, and not <a class="el" href="classMappingManifold.html">MappingManifold</a>.</p>
<p>This <a class="el" href="classManifold.html">Manifold</a> can be used <em>only</em> on geometries where a ball with finite radius is removed from the center. Indeed, the center is a singular point for this manifold, and if you try to connect two points across the center, they would travel on spherical coordinates, avoiding the center.</p>
<p>The ideal geometry for this <a class="el" href="classManifold.html">Manifold</a> is an HyperShell. If you plan to use this <a class="el" href="classManifold.html">Manifold</a> on a HyperBall, you have to make sure you do not attach this <a class="el" href="classManifold.html">Manifold</a> to the cell containing the center. It is advisable to combine this class with <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to ensure a smooth transition from a curved shape to the straight coordinate system in the center of the ball. (See also the extensive discussion in step-65.) </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l00236">236</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00307">307</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad64992c5cbbf4b9c933c7dc810d331a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64992c5cbbf4b9c933c7dc810d331a4">&#9670;&nbsp;</a></span>SphericalManifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classSphericalManifold.html">SphericalManifold</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;spacedim&#160;&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Constructor takes the center of the spherical coordinates. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7c2789d19572e9054df24d4f56ca89fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2789d19572e9054df24d4f56ca89fb">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a clone of this <a class="el" href="classManifold.html">Manifold</a> object. </p>

<p>Implements <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac583ee1989abe66f8b9ead2c4cc79e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac583ee1989abe66f8b9ead2c4cc79e38">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given any two points in space, first project them on the surface of a sphere with unit radius, then connect them with a geodesic and find the intermediate point, and finally rescale the final radius so that the resulting one is the convex combination of the starting radii. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a95f186c631d913c683d687aee65b3f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f186c631d913c683d687aee65b3f48">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the derivative of the <a class="el" href="classSphericalManifold.html#ac583ee1989abe66f8b9ead2c4cc79e38">get_intermediate_point()</a> function with parameter w equal to zero. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a6bd82ff6170512f65ad5c43e8440c23a">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a3fa07d5cf46d4f9110887793475c4b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa07d5cf46d4f9110887793475c4b5f">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.)</p>
<p>This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation.</p>
<p>The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself).</p>
<dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#af0087568e69730a3acc7b42535ab3337">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a805a0b3c46c740ac5a979b0aa5b8eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a0b3c46c740ac5a979b0aa5b8eb51">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex. </p>

</div>
</div>
<a id="af22df33a99a097469704e1209fbffda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22df33a99a097469704e1209fbffda3">&#9670;&nbsp;</a></span>get_new_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>This function is optimized to perform on a collection of new points, by collecting operations that are not dependent on the weights outside of the loop over all new points.</p>
<p>The implementation does not allow for <code>surrounding_points</code> and <code>new_points</code> to point to the same array, so make sure to pass different objects into the function. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a3d90f7b0e6f66ce0b84676d9aeacfc4e">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5be1a0a1464f08ee3865462994be827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be1a0a1464f08ee3865462994be827f">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a point on the spherical manifold which is intermediate with respect to the surrounding points. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a4797f8168f747583c6745f591c7addfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4797f8168f747583c6745f591c7addfb">&#9670;&nbsp;</a></span>guess_new_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdouble.html">double</a>, <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; &gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::guess_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a point on the spherical manifold which is intermediate with respect to the surrounding points. This function uses a linear average of the directions to find an estimated point. It returns a pair of radius and direction from the center point to the candidate point. </p>

</div>
</div>
<a id="a59ce83b5c4e919e1bbdbfee96ccfd9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ce83b5c4e919e1bbdbfee96ccfd9a8">&#9670;&nbsp;</a></span>get_new_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a point on the spherical manifold which is intermediate with respect to the surrounding points. This function uses a candidate point as guess, and performs a Newton-style iteration to compute the correct point.</p>
<p>The main part of the implementation uses the ideas in the publication</p>
<p>Buss, Samuel R., and Jay P. Fillmore. "Spherical averages and applications to spherical splines and
interpolation." ACM Transactions on Graphics (TOG) 20.2 (2001): 95-126.</p>
<p>and in particular the implementation provided at <a href="http://math.ucsd.edu/~sbuss/ResearchWeb/spheremean/">http://math.ucsd.edu/~sbuss/ResearchWeb/spheremean/</a> </p>

</div>
</div>
<a id="a58a2b077178e7257d6f3ad65a4aaaa9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a2b077178e7257d6f3ad65a4aaaa9d">&#9670;&nbsp;</a></span>get_new_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is an array view with as many entries as <code>surrounding_points.size()</code> times <code>new_points.size()</code>.</p>
<p>This function is optimized to perform on a collection of new points, by collecting operations that are not dependent on the weights outside of the loop over all new points.</p>
<p>The implementation does not allow for <code>surrounding_points</code> and <code>new_points</code> to point to the same array, so make sure to pass different objects into the function. </p>

</div>
</div>
<a id="af0163e726b6c4af36638d889fb3afed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0163e726b6c4af36638d889fb3afed4">&#9670;&nbsp;</a></span>project_to_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself.</p>
<p>This class is used by the default implementation of the function <a class="el" href="classSphericalManifold.html#a5be1a0a1464f08ee3865462994be827f">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called.</p>
<p>If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#af3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9be8b4b185d2469dcdfff826ff854cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be8b4b185d2469dcdfff826ff854cd7">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a6f18f34e5f98fea7cbd40bd3245f0aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f18f34e5f98fea7cbd40bd3245f0aee">&#9670;&nbsp;</a></span>get_new_point_on_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a87b1f7a138589989fe84984e12f3d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1f7a138589989fe84984e12f3d945">&#9670;&nbsp;</a></span>get_new_point_on_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a238d0f0a7f973ff25f4cab4ec21e9b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d0f0a7f973ff25f4cab4ec21e9b56">&#9670;&nbsp;</a></span>get_new_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a39e9a7899b69fbe5fdf7961f9c4c7374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e9a7899b69fbe5fdf7961f9c4c7374">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a684ad0b97b0f225eb4eb7ee04ab41d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ad0b97b0f225eb4eb7ee04ab41d7e">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a64a4033ac330d9c1592aa23e117bddb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a4033ac330d9c1592aa23e117bddb8">&#9670;&nbsp;</a></span>center</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::center</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The center of the spherical coordinate system. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l00317">317</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="a7896a0ba10773b84ce39511008ae6340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896a0ba10773b84ce39511008ae6340">&#9670;&nbsp;</a></span>polar_manifold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPolarManifold.html">PolarManifold</a>&lt;spacedim&gt; <a class="el" href="classSphericalManifold.html">SphericalManifold</a>&lt; dim, spacedim &gt;::polar_manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A manifold description to be used for get_new_point in 2D. </p>

<p class="definition">Definition at line <a class="el" href="grid_2manifold__lib_8h_source.html#l00373">373</a> of file <a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="grid_2manifold__lib_8h_source.html">manifold_lib.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
