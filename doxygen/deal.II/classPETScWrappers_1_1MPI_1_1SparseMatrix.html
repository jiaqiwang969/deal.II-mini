<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1MPI_1_1SparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::MPI::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPETScWrappers_1_1MPI_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MPI::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__sparse__matrix_8h_source.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MPI::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MPI_1_1SparseMatrix__inherit__graph.svg" width="214" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPETScWrappers_1_1MPI_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a315d6badf3f70e87ddf2a784ab5a6436"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a315d6badf3f70e87ddf2a784ab5a6436">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a315d6badf3f70e87ddf2a784ab5a6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f79582d2d2681b5f55167761d84168"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> = <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td></tr>
<tr class="separator:a29f79582d2d2681b5f55167761d84168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae584b9befbadcc9293f710bde79b3d21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> = PetscScalar</td></tr>
<tr class="separator:ae584b9befbadcc9293f710bde79b3d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7999b55f6e18fdcb9a0c8f4609f4eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ad7999b55f6e18fdcb9a0c8f4609f4eb8">~SparseMatrix</a> () override</td></tr>
<tr class="separator:ad7999b55f6e18fdcb9a0c8f4609f4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e3abd3a9f663b13ebce9191b143ea9"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ac7e3abd3a9f663b13ebce9191b143ea9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ac7e3abd3a9f663b13ebce9191b143ea9">SparseMatrix</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a>, const SparsityPatternType &amp;sparsity_pattern, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_rows_per_process, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_columns_per_process, const unsigned <a class="el" href="classint.html">int</a> this_process, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations=true)</td></tr>
<tr class="separator:ac7e3abd3a9f663b13ebce9191b143ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0092f1d907d29212c0b8bd0c644cae0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a0092f1d907d29212c0b8bd0c644cae0e">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> d)</td></tr>
<tr class="separator:a0092f1d907d29212c0b8bd0c644cae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130d139e9ef5e4569cc6271ee199d72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a130d139e9ef5e4569cc6271ee199d72c">copy_from</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a130d139e9ef5e4569cc6271ee199d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287ce9bac8a06bbc02a8159a2b821a0a"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a287ce9bac8a06bbc02a8159a2b821a0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a>, const SparsityPatternType &amp;sparsity_pattern, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_rows_per_process, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_columns_per_process, const unsigned <a class="el" href="classint.html">int</a> this_process, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations=true)</td></tr>
<tr class="separator:a287ce9bac8a06bbc02a8159a2b821a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada623c75b093257140547fae23a73b1e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ada623c75b093257140547fae23a73b1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ada623c75b093257140547fae23a73b1e">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_rows, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_columns, const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a>)</td></tr>
<tr class="separator:ada623c75b093257140547fae23a73b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6a6ca194d954faa0ba49acf29bd518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a0f6a6ca194d954faa0ba49acf29bd518">reinit</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a0f6a6ca194d954faa0ba49acf29bd518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa85242545b5d377c3734526c3c72ee"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a2fa85242545b5d377c3734526c3c72ee">get_mpi_communicator</a> () const override</td></tr>
<tr class="separator:a2fa85242545b5d377c3734526c3c72ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12c63ba4f6a2e0d6d9e2c275b0e63ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab12c63ba4f6a2e0d6d9e2c275b0e63ba">DeclException2</a> (ExcLocalRowsTooLarge, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of local rows &quot;&lt;&lt; arg1&lt;&lt; &quot; must be larger than the total number of rows &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:gab12c63ba4f6a2e0d6d9e2c275b0e63ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afb5db3c1463666ece5abd2a880f7e0"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a9afb5db3c1463666ece5abd2a880f7e0">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:a9afb5db3c1463666ece5abd2a880f7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c898e34c68304eb76c843c7ef215183"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a2c898e34c68304eb76c843c7ef215183">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:a2c898e34c68304eb76c843c7ef215183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11774f0d639c6d6b7d5fffe5ede29c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ae11774f0d639c6d6b7d5fffe5ede29c6">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:ae11774f0d639c6d6b7d5fffe5ede29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33c46847f3028baacd2e15e5538978b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ac33c46847f3028baacd2e15e5538978b">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:ac33c46847f3028baacd2e15e5538978b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a1dbabb70ef99a4be889474c4c5dc4756">mmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446bb9a2e86487360cd8c73c021197e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a446bb9a2e86487360cd8c73c021197e4">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a446bb9a2e86487360cd8c73c021197e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1b895d26bc6c0a0cf96d37d00e5853c4">clear</a> ()</td></tr>
<tr class="separator:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5067751068b7290030fe97cc8cadd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af5067751068b7290030fe97cc8cadd02">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:af5067751068b7290030fe97cc8cadd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af2a6e591d33f2af5e44a20c8b3e30943">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d04e83f54969c8c504da62bdee60a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a90d04e83f54969c8c504da62bdee60a8">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a90d04e83f54969c8c504da62bdee60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc988c43c687b2af0b7e4352def7f19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abc988c43c687b2af0b7e4352def7f19b">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:abc988c43c687b2af0b7e4352def7f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae9fe7cc7dd404261b63b7ee651233de1">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a017ad4b1e0e18954db42d489e91ed0bb">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b079c5bf7843592a347a9874752eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a97b079c5bf7843592a347a9874752eef">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a97b079c5bf7843592a347a9874752eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068368a605f2661042e104f0ad3eef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a068368a605f2661042e104f0ad3eef47">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a068368a605f2661042e104f0ad3eef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8298c20ffaf1ba83c286e119fd53e7d0">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abec5dd7bf11e94aeeeca18e94576c06e">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be932238458b6c1cd83b51571891a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5be932238458b6c1cd83b51571891a6a">add</a> (const PetscScalar factor, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a5be932238458b6c1cd83b51571891a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918fe8858fea210e01de289340c2468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:af918fe8858fea210e01de289340c2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d67d301ec5cb4181b071168a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25c2d67d301ec5cb4181b071168a6783">clear_rows</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;rows, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:a25c2d67d301ec5cb4181b071168a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264ec17db96d955590626c8da8e6aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ae264ec17db96d955590626c8da8e6aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8eddd61ef58cb9f312b47b0e3c165f7a">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89476484bfd365c60972c76d3a893925"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a89476484bfd365c60972c76d3a893925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2bb6345b774b4029dc1cc04b6c5ecedf">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i) const</td></tr>
<tr class="separator:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d397cb51074c94824c3db0a21e6210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m</a> () const</td></tr>
<tr class="separator:ae6d397cb51074c94824c3db0a21e6210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31319c249e3ff1bf572c79ee0f41bade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a31319c249e3ff1bf572c79ee0f41bade">n</a> () const</td></tr>
<tr class="separator:a31319c249e3ff1bf572c79ee0f41bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b350e8500ad00885d36508ded03c159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size</a> () const</td></tr>
<tr class="separator:a8b350e8500ad00885d36508ded03c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca73a7174b92973d2a57e41af737fd1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range</a> () const</td></tr>
<tr class="separator:adca73a7174b92973d2a57e41af737fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988bc02bfef4479879867a411eb2b682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a988bc02bfef4479879867a411eb2b682">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> index) const</td></tr>
<tr class="separator:a988bc02bfef4479879867a411eb2b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc9652ade95e371d4191e28461eeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adfcc9652ade95e371d4191e28461eeb8">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:adfcc9652ade95e371d4191e28461eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0aee7127b31ea26d3847ce7d4d9236ad">row_length</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row) const</td></tr>
<tr class="separator:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1976b38af71b46e0fa5f3b4837f2fd05">l1_norm</a> () const</td></tr>
<tr class="separator:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ba7168f27d27bae50b653587fd8f"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afd06ba7168f27d27bae50b653587fd8f">linfty_norm</a> () const</td></tr>
<tr class="separator:afd06ba7168f27d27bae50b653587fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5ab9e8f1061cef606eaeb0993ce3d887">frobenius_norm</a> () const</td></tr>
<tr class="separator:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0c76f22865de9a597b7342f87463e"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae7e0c76f22865de9a597b7342f87463e">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:ae7e0c76f22865de9a597b7342f87463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aef113fe7fed539cc6e5a75f457571"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0aef113fe7fed539cc6e5a75f457571">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:aa0aef113fe7fed539cc6e5a75f457571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bff0bbfcb1159616cb078ae9d68374"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a95bff0bbfcb1159616cb078ae9d68374">trace</a> () const</td></tr>
<tr class="separator:a95bff0bbfcb1159616cb078ae9d68374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b99bfc37fc183a7d978ec48f83623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4b99bfc37fc183a7d978ec48f83623">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:aad4b99bfc37fc183a7d978ec48f83623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455541189a44467806299d3f0e0d2005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a455541189a44467806299d3f0e0d2005">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a455541189a44467806299d3f0e0d2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e08f3caffe58c6213f1a142140d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a228e08f3caffe58c6213f1a142140d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa53f7571665e69020dd5c1c90cf2e04d">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714cb0c98ae635dd7591b40192dc9240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a714cb0c98ae635dd7591b40192dc9240">Tvmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a714cb0c98ae635dd7591b40192dc9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab7d09f592d2683c8d9cb7e422dfc2e57">residual</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const</td></tr>
<tr class="separator:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417ad4470cefee04a01c4595b609d310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a417ad4470cefee04a01c4595b609d310">begin</a> () const</td></tr>
<tr class="separator:a417ad4470cefee04a01c4595b609d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7d876a5651cfc339c93a5406b4f7eb79">begin</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2141ca2fb58139da5e1f532634958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6cc2141ca2fb58139da5e1f532634958">end</a> () const</td></tr>
<tr class="separator:a6cc2141ca2fb58139da5e1f532634958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748f0b7f03b5b7452a38b92561d2943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0748f0b7f03b5b7452a38b92561d2943">end</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a0748f0b7f03b5b7452a38b92561d2943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11a01597f3233c1f817a09471c937e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac11a01597f3233c1f817a09471c937e3">operator Mat</a> () const</td></tr>
<tr class="separator:ac11a01597f3233c1f817a09471c937e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85273881d243958293bf3155e605ba67"><td class="memItemLeft" align="right" valign="top">Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a85273881d243958293bf3155e605ba67">petsc_matrix</a> ()</td></tr>
<tr class="separator:a85273881d243958293bf3155e605ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76b6ce3247735964836a82eedff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacd76b6ce3247735964836a82eedff6d">transpose</a> ()</td></tr>
<tr class="separator:aacd76b6ce3247735964836a82eedff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f6b575f15d540cf10688b30d09941"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9f2f6b575f15d540cf10688b30d09941">is_hermitian</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a9f2f6b575f15d540cf10688b30d09941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127fd1b40ab452473f96cc298694528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad127fd1b40ab452473f96cc298694528">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:ad127fd1b40ab452473f96cc298694528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515e640202d1ad50bd9baa13c404cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7515e640202d1ad50bd9baa13c404cb1">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a7515e640202d1ad50bd9baa13c404cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7a8873fc01cd20682e079dbb8f225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0af7a8873fc01cd20682e079dbb8f225">memory_consumption</a> () const</td></tr>
<tr class="separator:a0af7a8873fc01cd20682e079dbb8f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa059253b9ee3357d06dbd37816a1d22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afa059253b9ee3357d06dbd37816a1d22">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:afa059253b9ee3357d06dbd37816a1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4656c942eaca0ea491fba37a0a6225eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4656c942eaca0ea491fba37a0a6225eb">DeclException2</a> (ExcWrongMode, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;)</td></tr>
<tr class="separator:a4656c942eaca0ea491fba37a0a6225eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9795580277a7bc3a4348443768b6c0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9795580277a7bc3a4348443768b6c0fd">prepare_action</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> new_action)</td></tr>
<tr class="separator:a9795580277a7bc3a4348443768b6c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0e10ef38e7bb5901bc5678a8a4ffd6d">assert_is_compressed</a> ()</td></tr>
<tr class="separator:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add</a> ()</td></tr>
<tr class="separator:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b00916f856722282dcd9abb408581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set</a> ()</td></tr>
<tr class="separator:a9d1b00916f856722282dcd9abb408581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49501300c99d6fea596a39fbe38b8961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">mmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:a49501300c99d6fea596a39fbe38b8961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c266e288f1d409c1b09eae7114792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:ab97c266e288f1d409c1b09eae7114792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfce46e53089351cc7fe6b9ea44e167f"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a></td></tr>
<tr class="separator:abfce46e53089351cc7fe6b9ea44e167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1deda2ab63ef62230745b4ff99bd26d6">last_action</a></td></tr>
<tr class="separator:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae46377c65ba286db6d4f7f98fde872b3"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ae46377c65ba286db6d4f7f98fde872b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ae46377c65ba286db6d4f7f98fde872b3">do_reinit</a> (const SparsityPatternType &amp;sparsity_pattern, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_rows_per_process, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_columns_per_process, const unsigned <a class="el" href="classint.html">int</a> this_process, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations)</td></tr>
<tr class="separator:ae46377c65ba286db6d4f7f98fde872b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e61d74115d8d6e6aa8cf0533ce3e7"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:aae4e61d74115d8d6e6aa8cf0533ce3e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#aae4e61d74115d8d6e6aa8cf0533ce3e7">do_reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_rows, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_columns, const SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:aae4e61d74115d8d6e6aa8cf0533ce3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a480a46d7e16cbc9ef06e5442cb1cec2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a></td></tr>
<tr class="separator:a480a46d7e16cbc9ef06e5442cb1cec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>实现一个基于PETSc的并行稀疏矩阵类，矩阵的行分布在一个MPI网络上。所有的功能实际上都在基类中，除了用于生成并行稀疏矩阵的调用。这是可能的，因为PETSc只在抽象矩阵类型上工作，并在内部分配给根据实际矩阵类型进行实际工作的函数（很像使用虚拟函数）。只有创建特定类型矩阵的函数不同，并在这个特定的类中实现。 在平行向量类的文档中，有许多关于通信模型以及访问单个元素的评论。这些评论在这里也适用。 </p><h3>Partitioning of matrices</h3>
<p>PETSc对并行矩阵进行分区，以便每个MPI进程 "拥有
"一定数量的行（即只有这个进程在这些行中存储各自的条目）。每个进程拥有的行数必须通过参数 <code>local_rows传递给构造函数和</code> <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit()</a>函数。在所有MPI进程中作为 <code>local_rows</code> 传递的单个值当然要与矩阵的全局行数相加。 除此之外，PETSc还对它所拥有的矩阵的矩形块（即矩阵中 <code>local_rows</code> 乘以n()的元素）进行分区，这样就可以有效地进行矩阵向量乘法。因此，这种列的划分必须与矩阵被乘以的向量的划分相匹配，就像行的划分必须与目的向量的划分相匹配。这个分区是通过 <code>local_columns</code> 变量传递给构造函数和reinit()函数的，这个变量也必须与矩阵中的全局列数相加。local_columns <code>这个名字可能命名不当，因为它并没有反映出只有这些列被存储在本地，但它反映出这些列是传入向量的元素被存储在本地的事实。</code> 让事情变得更加复杂的是，PETSc需要对每一行要存储的元素数量有一个非常好的估计，以提高工作效率。 否则，它就会把大部分时间花在分配小块内存上，这个过程如果经常发生，会使程序变得缓慢。如果对每行的条目数进行良好的估计还不够，它甚至需要将其拆分如下：对于它拥有的每一行，它需要估计这一行中属于为这个过程而设置的列的元素数（见上文），以及其他列中的元素数。 因为一般来说，这个信息不是很容易得到，所以这个类的大多数初始化函数都假设你作为参数给 <code>n_nonzero_per_row</code> 或由 <code>row_lengths的所有元素数量都落入这个过程</code> "拥有
"的列中，而没有落入其他列中。这对大多数行来说是一个合理的猜测，因为在一个好的域划分中，节点只与同一子域内的节点进行交互。然而，对于子域界面上的节点来说，这并不成立，对于这些节点对应的行，PETSc将不得不分配额外的内存，这是一个昂贵的过程。 避免这种情况的唯一方法是告诉PETSc矩阵的实际条目将在哪里。为此，这个类有一些构造函数和 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit()</a> 函数，它们接收一个包含所有这些信息的 <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> 对象。虽然在一般情况下，如果构造函数和reinit()函数知道本地行和列的数量就足够了，但获得稀疏模式的函数也需要知道本地行的数量（ <code>local_rows_per_process</code>) 和列的数量（ <code>local_columns_per_process</code>) 对于所有其他过程，以便计算矩阵的哪些部分是哪些。因此，仅仅计算属于某个进程的自由度数量是不够的，你必须在所有进程中都有所有进程的数字。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00284">284</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a315d6badf3f70e87ddf2a784ab5a6436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d6badf3f70e87ddf2a784ab5a6436">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a315d6badf3f70e87ddf2a784ab5a6436">PETScWrappers::MPI::SparseMatrix::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器大小的类型。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00291">291</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a29f79582d2d2681b5f55167761d84168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f79582d2d2681b5f55167761d84168">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">PETScWrappers::MatrixBase::const_iterator</a> =  <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为迭代器类声明一个别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00277">277</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="ae584b9befbadcc9293f710bde79b3d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae584b9befbadcc9293f710bde79b3d21">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">PETScWrappers::MatrixBase::value_type</a> =  PetscScalar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明一个类似于所有其他容器类的别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00289">289</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数。创建一个空矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00034">34</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ad7999b55f6e18fdcb9a0c8f4609f4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7999b55f6e18fdcb9a0c8f4609f4eb8">&#9670;&nbsp;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::~<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器释放PETSc对象。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00047">47</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac7e3abd3a9f663b13ebce9191b143ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e3abd3a9f663b13ebce9191b143ea9">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rows_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_columns_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>this_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用给定的稀疏模式进行初始化，通信发生在所提供的 <code>communicator</code>. <code>local_rows_per_process</code> 和 <code>local_columns_per_process</code> 参数的含义，请参见类文档。 请注意，如果你不向PETSc提供对行的长度的良好估计，它的速度会非常慢。使用本函数是一个非常有效的方法，因为它通过使用给定的稀疏模式参数，为矩阵的每一行使用准确的非零条目数。如果 <code>preset_nonzero_locations</code> 标志是 <code>true</code>, ，这个函数不仅预先设置了正确的行大小，而且还预先分配了矩阵中正确的非零条目。 PETsc允许以后向矩阵添加额外的非零条目，只需向这些元素写入即可。然而，这将导致额外的内存分配，效率非常低，将大大降低你的程序速度。因此，从一开始就做好内存分配是非常有效的。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00055">55</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0092f1d907d29212c0b8bd0c644cae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0092f1d907d29212c0b8bd0c644cae0e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。由于这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？ 仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00090">90</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a130d139e9ef5e4569cc6271ee199d72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130d139e9ef5e4569cc6271ee199d72c">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>制作PETSc矩阵的副本 <code>other</code>. 假设两个矩阵具有相同的SparsityPattern。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00097">97</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a287ce9bac8a06bbc02a8159a2b821a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287ce9bac8a06bbc02a8159a2b821a0a">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rows_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_columns_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>this_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用给定的稀疏模式进行初始化，通信发生在所提供的 <code>communicator</code>. 上。注意，如果你不向PETSc提供对行长度的良好估计，它可能会非常慢。使用本函数是一个非常有效的方法，因为它通过使用给定的稀疏模式参数，使用矩阵每一行的非零条目的确切数量。如果 <code>preset_nonzero_locations</code> 标志是 <code>true</code>, ，这个函数不仅预先设置了正确的行大小，而且还预先分配了矩阵中正确的非零条目。 PETsc允许以后向矩阵添加额外的非零条目，只需向这些元素写入即可。然而，这将导致额外的内存分配，效率非常低，将大大降低你的程序速度。因此，从一开始就做好内存分配是非常有效的。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00113">113</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ada623c75b093257140547fae23a73b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada623c75b093257140547fae23a73b1e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个矩阵，其中IndexSets的size()决定了全局的行和列的数量，IndexSet的条目给出了调用处理器的行和列。注意，只支持升序的1:1 IndexSets。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00137">137</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0f6a6ca194d954faa0ba49acf29bd518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6a6ca194d954faa0ba49acf29bd518">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化这个矩阵，使其具有与 <code>other</code>. 相同的结构 这不会复制其他矩阵的值，但你可以使用copy_from()来实现。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00074">74</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2fa85242545b5d377c3734526c3c72ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa85242545b5d377c3734526c3c72ee">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对与该矩阵一起使用的MPI通信器对象的引用。 </p>

<p>Implements <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae1aadd5aebcdc166b840df3430a23606">PETScWrappers::MatrixBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00512">512</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a9afb5db3c1463666ece5abd2a880f7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afb5db3c1463666ece5abd2a880f7e0">&#9670;&nbsp;</a></span>matrix_norm_square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的法线的平方，即 \(\left(v^\ast,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 很明显，对于这个操作，矩阵需要是二次的。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始的，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时矢量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00482">482</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2c898e34c68304eb76c843c7ef215183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c898e34c68304eb76c843c7ef215183">&#9670;&nbsp;</a></span>matrix_scalar_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u^\ast,Mv\right)\) 。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始的函数，而不是PETSc包装类）的效率高，因为PETSc不支持这个操作，需要一个临时向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00491">491</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae11774f0d639c6d6b7d5fffe5ede29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11774f0d639c6d6b7d5fffe5ede29c6">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的域空间的划分，即这个矩阵要与之相乘的向量的划分。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00500">500</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac33c46847f3028baacd2e15e5538978b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33c46847f3028baacd2e15e5538978b">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵的范围空间的划分，即由矩阵-向量乘积产生的向量的划分。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00526">526</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1dbabb70ef99a4be889474c4c5dc4756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbabb70ef99a4be889474c4c5dc4756">&#9670;&nbsp;</a></span>mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法 \(C = AB\) ，或者， \(C = A \text{diag}(V) B\) 给出一个兼容的向量 \(V\) 。 这个函数调用 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">MatrixBase::mmult()</a> 来做实际工作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00552">552</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a446bb9a2e86487360cd8c73c021197e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446bb9a2e86487360cd8c73c021197e4">&#9670;&nbsp;</a></span>Tmmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与<code>this</code>的转置进行矩阵-矩阵乘法，即 \(C = A^T B\) ，或者， \(C = A^T \text{diag}(V) B\) 给定一个兼容的向量 \(V\) 。 这个函数调用 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">MatrixBase::Tmmult()</a> 来做实际工作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00563">563</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae46377c65ba286db6d4f7f98fde872b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46377c65ba286db6d4f7f98fde872b3">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rows_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_columns_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>this_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00298">298</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aae4e61d74115d8d6e6aa8cf0533ce3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4e61d74115d8d6e6aa8cf0533ce3e7">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与以前的函数相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00155">155</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b895d26bc6c0a0cf96d37d00e5853c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b895d26bc6c0a0cf96d37d00e5853c4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00092">92</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af5067751068b7290030fe97cc8cadd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5067751068b7290030fe97cc8cadd02">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将元素(<em>i,j</em>)设置为 <code>value</code>. 如果现在的对象(来自这个对象的派生类)恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类形成了很大的反差，如果该条目不存在则会抛出错误。如果<code>value</code>不是一个有限的数字，就会抛出一个异常。 </p>

</div>
</div>
<a id="af2a6e591d33f2af5e44a20c8b3e30943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a6e591d33f2af5e44a20c8b3e30943">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素设置为<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="a90d04e83f54969c8c504da62bdee60a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d04e83f54969c8c504da62bdee60a8">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的功能相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的局部到全局的索引。 </p>

</div>
</div>
<a id="abc988c43c687b2af0b7e4352def7f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc988c43c687b2af0b7e4352def7f19b">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="ae9fe7cc7dd404261b63b7ee651233de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fe7cc7dd404261b63b7ee651233de1">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给定的值，在由col_indices给定的列中设置为稀疏矩阵的行。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="a017ad4b1e0e18954db42d489e91ed0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017ad4b1e0e18954db42d489e91ed0bb">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>value</code> 添加到元素（<em>i,j</em>）。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类非常不同，后者在该条目不存在的情况下会抛出一个错误。如果<code>value</code>不是一个有限的数字，就会抛出一个异常。 </p>

</div>
</div>
<a id="a97b079c5bf7843592a347a9874752eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b079c5bf7843592a347a9874752eef">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a068368a605f2661042e104f0ad3eef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068368a605f2661042e104f0ad3eef47">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a8298c20ffaf1ba83c286e119fd53e7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8298c20ffaf1ba83c286e119fd53e7d0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="abec5dd7bf11e94aeeeca18e94576c06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5dd7bf11e94aeeeca18e94576c06e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类形成鲜明对比，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a5be932238458b6c1cd83b51571891a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be932238458b6c1cd83b51571891a6a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵 <code>other</code> 按系数 <code>factor</code> 的比例添加到当前矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00430">430</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af918fe8858fea210e01de289340c2468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af918fe8858fea210e01de289340c2468">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将此<code>行</code>中的所有元素设置为零，将其删除。这个函数并不修改分配的非零条目的数量，它只是将一些条目设置为零。不过，它可能会将它们从稀疏模式中删除（但会保留分配的内存，以备以后再次添加新的条目）。 这个操作用于消除约束（例如由于挂起的节点），并确保我们可以将这个修改写入矩阵，而不需要从矩阵中读取条目（例如非零元素的位置）。</p>
<ul>
<li>如果没有这个操作，消除平行矩阵的约束是一个相当复杂的过程。 第二个参数可以用来将该行的对角线条目设置为一个不同于零的值。默认是将其设置为零。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00127">127</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a25c2d67d301ec5cb4181b071168a6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c2d67d301ec5cb4181b071168a6783">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与clear_row()相同，只是它同时作用于若干行。 第二个参数可以用来将所有被清除的行的对角线条目设置为不同于0的内容。请注意，所有这些对角线项都得到相同的值</p>
<ul>
<li>如果你想要不同的对角线条目的值，你必须手动设置它们。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00136">136</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae264ec17db96d955590626c8da8e6aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264ec17db96d955590626c8da8e6aad">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PETSc矩阵存储了它们自己的稀疏性模式。因此，与我们自己的SparsityPattern类相类似，这个函数压缩了稀疏模式，并允许将得到的矩阵用于所有其他操作，而以前只允许使用汇编函数。因此，一旦你组装了矩阵，就必须调用这个函数。 更多信息请参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00193">193</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8eddd61ef58cb9f312b47b0e3c165f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eddd61ef58cb9f312b47b0e3c165f7a">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 与 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类中的相应函数相比，如果相应的条目不存在于该类的稀疏模式中，我们不会抛出一个异常，因为PETSc并不传输这一信息。 因此这个函数完全等同于<code><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a></code>函数。 </p>

</div>
</div>
<a id="a89476484bfd365c60972c76d3a893925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89476484bfd365c60972c76d3a893925">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵条目的值（<em>i,j</em>）。如果这个条目不存在于稀疏模式中，那么就返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00165">165</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a2bb6345b774b4029dc1cc04b6c5ecedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6345b774b4029dc1cc04b6c5ecedf">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次的，这个函数会抛出一个错误。 由于我们不能直接访问底层数据结构，这个函数并不比使用el()函数的元素访问快。然而，我们提供这个函数是为了与SparseMatrix类兼容。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00181">181</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae6d397cb51074c94824c3db0a21e6210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d397cb51074c94824c3db0a21e6210">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个矩阵的行数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00237">237</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a31319c249e3ff1bf572c79ee0f41bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31319c249e3ff1bf572c79ee0f41bade">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个矩阵中的列数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00250">250</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8b350e8500ad00885d36508ded03c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b350e8500ad00885d36508ded03c159">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的本地维度，即存储在当前MPI进程中的行数。对于顺序矩阵，这个数字与m()相同，但对于并行矩阵，这个数字可能更小。 要想知道到底哪些元素被存储在本地，可以使用local_range()。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00263">263</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adca73a7174b92973d2a57e41af737fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca73a7174b92973d2a57e41af737fd1">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> &gt; PETScWrappers::MatrixBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一对指数，表明该矩阵的哪些行是本地存储的。第一个数字是存储的第一行的索引，第二个数字是本地存储的最后一行之后的那一行的索引。如果这是一个连续的矩阵，那么结果将是一对(0,m())，否则将是一对(i,i+n)，其中<code>n=<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size()</a></code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00276">276</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a988bc02bfef4479879867a411eb2b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988bc02bfef4479879867a411eb2b682">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::MatrixBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p>

</div>
</div>
<a id="adfcc9652ade95e371d4191e28461eeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc9652ade95e371d4191e28461eeb8">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00290">290</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0aee7127b31ea26d3847ce7d4d9236ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee7127b31ea26d3847ce7d4d9236ad">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>特定行中的条目数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00302">302</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1976b38af71b46e0fa5f3b4837f2fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1976b38af71b46e0fa5f3b4837f2fd05">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的l1准则，即 \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\) ，（最大列数之和）。这是一个自然的矩阵准则，与向量的l1准则兼容，即 \(|Mv|_1\leq |M|_1 |v|_1\) 。(参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00338">338</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afd06ba7168f27d27bae50b653587fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06ba7168f27d27bae50b653587fd8f">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的linfty-norm，即 \(|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|\) ，（最大行数之和）。这是一个自然的矩阵规范，与向量的linfty-norm兼容，即 \(|Mv|_infty \leq |M|_infty |v|_infty\) 。(参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00351">351</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5ab9e8f1061cef606eaeb0993ce3d887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab9e8f1061cef606eaeb0993ce3d887">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00364">364</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae7e0c76f22865de9a597b7342f87463e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0c76f22865de9a597b7342f87463e">&#9670;&nbsp;</a></span>matrix_norm_square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的准则的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 很明显，对于这个操作，矩阵需要是二次的。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始的，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时向量。 注意，如果当前对象代表一个并行的分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么给出的向量也必须是一个分布式向量。反之，如果矩阵不是分布式的，那么向量也不可能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00376">376</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa0aef113fe7fed539cc6e5a75f457571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aef113fe7fed539cc6e5a75f457571">&#9670;&nbsp;</a></span>matrix_scalar_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 这个函数的实现不如deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始函数，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时矢量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00385">385</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a95bff0bbfcb1159616cb078ae9d68374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bff0bbfcb1159616cb078ae9d68374">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的轨迹，即矩阵中所有对角线项的总和。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00395">395</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aad4b99bfc37fc183a7d978ec48f83623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4b99bfc37fc183a7d978ec48f83623">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00408">408</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a455541189a44467806299d3f0e0d2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455541189a44467806299d3f0e0d2005">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00419">419</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a228e08f3caffe58c6213f1a142140d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228e08f3caffe58c6213f1a142140d3f">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M*src</em>与<em>M</em>是这个矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00441">441</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa53f7571665e69020dd5c1c90cf2e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53f7571665e69020dd5c1c90cf2e04d">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个并行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00452">452</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adb7231c9d5f340181ac3c45827f5b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7231c9d5f340181ac3c45827f5b9e4">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>为该矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00463">463</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a714cb0c98ae635dd7591b40192dc9240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714cb0c98ae635dd7591b40192dc9240">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 来源和目的地不能是同一个向量。 注意，如果当前对象代表一个并行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00474">474</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab7d09f592d2683c8d9cb7e422dfc2e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d09f592d2683c8d9cb7e422dfc2e57">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入 <code>dst</code>. 返回残差向量的<em>l<sub>2</sub></em>准则。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么所有的向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00574">574</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a417ad4470cefee04a01c4595b609d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417ad4470cefee04a01c4595b609d310">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器从第一个条目开始。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考以行号为参数的begin()的版本。 </p>

</div>
</div>
<a id="a7d876a5651cfc339c93a5406b4f7eb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d876a5651cfc339c93a5406b4f7eb79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器从第 <code>r</code>. 行的第一个条目开始 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<code>end(r)</code>。还要注意的是，在这种情况下，迭代器可能不能被解除引用。 </p>

</div>
</div>
<a id="a6cc2141ca2fb58139da5e1f532634958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2141ca2fb58139da5e1f532634958">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>最后的迭代器。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考end()的版本，以一个行号作为参数。 </p>

</div>
</div>
<a id="a0748f0b7f03b5b7452a38b92561d2943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748f0b7f03b5b7452a38b92561d2943">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。它指向超过行 <code>r</code>, 末尾的第一个元素，或者超过整个稀疏模式的末尾。 请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 </p>

</div>
</div>
<a id="ac11a01597f3233c1f817a09471c937e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11a01597f3233c1f817a09471c937e3">&#9670;&nbsp;</a></span>operator Mat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::operator Mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的时候使用。特别是，它应该只用于对矩阵的只读操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00590">590</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a85273881d243958293bf3155e605ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85273881d243958293bf3155e605ba67">&#9670;&nbsp;</a></span>petsc_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat &amp; PETScWrappers::MatrixBase::petsc_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对底层PETSc类型的引用。它可以用来修改底层数据，所以只有在你知道你在做什么的时候才使用它。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00596">596</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aacd76b6ce3247735964836a82eedff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd76b6ce3247735964836a82eedff6d">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对一个矩阵进行原地转置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00602">602</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a4a1057a35382b7c328e6c85b0f5ab35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1057a35382b7c328e6c85b0f5ab35e">&#9670;&nbsp;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试矩阵是否是对称的。 默认公差为 \(1000\times32\) -位机器精度。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00614">614</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a9f2f6b575f15d540cf10688b30d09941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2f6b575f15d540cf10688b30d09941">&#9670;&nbsp;</a></span>is_hermitian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_hermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试一个矩阵是否是赫米特的，即它是其转置的复共轭。默认公差为 \(1000\times32\) -位机器精度。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00624">624</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ad127fd1b40ab452473f96cc298694528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad127fd1b40ab452473f96cc298694528">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用PETSc内部矩阵查看器功能<code>MatView</code>打印PETSc矩阵对象的值。默认格式是打印非零矩阵元素。对于其他有效的查看格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00636">636</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a7515e640202d1ad50bd9baa13c404cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7515e640202d1ad50bd9baa13c404cb1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印矩阵的元素到给定的输出流。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>要写入的输出流。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_output</td><td>这个参数被忽略。它的存在是为了与其他矩阵类中的类似函数兼容。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00651">651</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0af7a8873fc01cd20682e079dbb8f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7a8873fc01cd20682e079dbb8f225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::MatrixBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该矩阵在该CPU上所消耗的字节数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00682">682</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afa059253b9ee3357d06dbd37816a1d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa059253b9ee3357d06dbd37816a1d22">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcSourceEqualsDestination&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are attempting an operation on two matrices that &quot; &quot;are the same&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but the operation requires that the &quot; &quot;two objects are in fact different.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a4656c942eaca0ea491fba37a0a6225eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656c942eaca0ea491fba37a0a6225eb">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcWrongMode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况。 </p>

</div>
</div>
<a id="a9795580277a7bc3a4348443768b6c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9795580277a7bc3a4348443768b6c0fd">&#9670;&nbsp;</a></span>prepare_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>new_action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确保此调用后的动作所需的添加/设置模式与当前模式兼容。应该从所有访问矩阵元素的内部函数中调用。 </p>

</div>
</div>
<a id="aa0e10ef38e7bb5901bc5678a8a4ffd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e10ef38e7bb5901bc5678a8a4ffd6d">&#9670;&nbsp;</a></span>assert_is_compressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::assert_is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>内部函数，检查是否有未决的插入/添加操作。否则会抛出一个异常。在调用任何修改矩阵的PETSc内部函数之前，都是有用的。 </p>

</div>
</div>
<a id="aa6e49d52a74cc86386a9aff01fa88c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e49d52a74cc86386a9aff01fa88c74">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于某些矩阵存储格式，特别是PETSc分布式块状矩阵，单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。这个函数确保矩阵处于允许添加元素的状态；如果它之前已经处于这种状态，那么这个函数什么也不做。 </p>

</div>
</div>
<a id="a9d1b00916f856722282dcd9abb408581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1b00916f856722282dcd9abb408581">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。 </p>

</div>
</div>
<a id="a49501300c99d6fea596a39fbe38b8961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49501300c99d6fea596a39fbe38b8961">&#9670;&nbsp;</a></span>mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法 \(C = AB\) 的基础函数，或者，如果给出一个大小与B兼容的向量 \(V\) ，则为 \(C = A \text{diag}(V) B\) ，其中 \(\text{diag}(V)\) 定义了一个带有向量项的对角矩阵。 这个函数假定调用矩阵 \(A\) 和 \(B\) 的大小兼容。 \(C\) 的大小将在本函数中设置。 矩阵 \(C\) 的内容和稀疏模式将被这个函数重置，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00558">558</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab97c266e288f1d409c1b09eae7114792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97c266e288f1d409c1b09eae7114792">&#9670;&nbsp;</a></span>Tmmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基准函数，用于执行矩阵与<code>this</code>的转置相乘，即 \(C = A^T B\) ，或者，如果给出一个可选矢量 \(V\) ，其大小与 \(B\) 兼容，则为 \(C = A^T \text{diag}(V) B\) ，其中 \(\text{diag}(V)\) 定义了一个带有矢量项的对角矩阵。 这个函数假设调用矩阵 \(A\) 和 \(B\) 的大小兼容。 \(C\) 的大小将在本函数中设置。 矩阵 \(C\) 的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00566">566</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb72d666c41a0ac3c16def795c0c99b">&#9670;&nbsp;</a></span>BlockMatrixBase< SparseMatrix ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00504">504</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a480a46d7e16cbc9ef06e5442cb1cec2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480a46d7e16cbc9ef06e5442cb1cec2a">&#9670;&nbsp;</a></span>communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> PETScWrappers::MPI::SparseMatrix::communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用于该并行矢量的通信器对象的副本。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00479">479</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abfce46e53089351cc7fe6b9ea44e167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfce46e53089351cc7fe6b9ea44e167f">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat PETScWrappers::MatrixBase::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个PETSc中的通用矩阵对象。实际的类型是稀疏矩阵，在构造函数中设置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00817">817</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a1deda2ab63ef62230745b4ff99bd26d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deda2ab63ef62230745b4ff99bd26d6">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::MatrixBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储最后一个动作是写还是加操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00823">823</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a></li>
<li>source/lac/<a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
